<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-E1K9nNha9u"><script async defer data-website-id="f999c61c-4313-4008-b56e-7b3181301711" src="https://umi.outpost54.top/umami.js"></script><title>【Linux】进程通信 | 共享内存 | 信号量 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.outpost54.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://vrcl.outpost54.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/QA">留言板</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/QA">留言板</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【Linux】进程通信 | 共享内存 | 信号量</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2022-11-13 10:40:16</span> <span class="mobile">2022-11-13 10:40</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-01-15 16:12:54</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E7%8E%A9%E4%B8%8ALinux/">玩上Linux</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>6.5k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>上篇Linux的博客是有关管道的，今日就让我们继续康康进程间通信的另外一种方法：<code>共享内存</code></p><span id="more"></span><p>完整代码详见我的gitee仓库 👇</p><blockquote><p><a class="link" target="_blank" rel="noopener" href="https://gitee.com/ewait/raspberry-practice/tree/master/code/22-11-12_systemV">https://gitee.com/ewait/raspberry-practice/tree/master/code/22-11-12_systemV<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>[TOC]</p><h1 id="1-啥是共享内存？"><a href="#1-啥是共享内存？" class="headerlink" title="1.啥是共享内存？"></a>1.啥是共享内存？</h1><p>进程间通信的基本方式，就是让两个进程看到同一份资源。</p><p>共享内存的方式，通过系统接口开辟一段内存，再让多个进程去访问这块内存，就能同时看到一份资源。</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211120900047.png" alt="image-20221112090042941"></p><p>这里贴出之前动态库博客中的图，共享内存的方式和该图展示的方式类似。进程需要调用系统接口，将已经开辟好的共享内存映射到自己的页表中，以实现访问。</p><p>这里就出现了一个问题：</p><ul><li>操作系统的接口怎么知道进程要的是那一块共享内存？即共享内存是怎么标识的？</li></ul><p>要知道，之前我们打开文件、开辟管道等等，都是具有唯一的文件路径来标识文件的。如果按以前的想法：<code>打开文件-&gt;系统返回文件的文件描述符</code>，共享内存则应该是<code>开辟共享内存-&gt;系统返回共享内存的编号</code></p><ul><li>这就出现了问题！</li></ul><p>假设进程A开辟了一段共享内存，系统返回了编号123，那么进程A要怎么让其他想使用这块共享内存进行通信的进程，<span id="jump">知道它开辟的共享内存编号</span>是123呢？总不能开个管道告诉它吧？那岂不是多此一举😂</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211031201142.gif" alt="QQ图片20220502222002"></p><p>所以，共享内存的编号其实和命名管道一样，<strong>是由用户手动在代码中指定的</strong>。只要进程使用这个编号去获取共享内存，他们就能获取到同一份！</p><hr><h1 id="2-相关接口"><a href="#2-相关接口" class="headerlink" title="2.相关接口"></a>2.相关接口</h1><p>说完了基本概念，现在让我们来康康它的使用</p><h2 id="2-1-ftok"><a href="#2-1-ftok" class="headerlink" title="2.1 ftok"></a>2.1 ftok</h2><p><code>ftok - convert a pathname and a project identifier to a System V IPC key</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure><p>前面提到了，共享内存的key是我们自己指定的。Linux系统给定了<code>ftok</code>接口，将用户提供的<code>pathname</code>工作路径，以及<code>proj_id</code>项目编号转换为一个共享内存的key（其实就是int类型）</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211121323400.png" alt="image-20221112132307366"></p><p>只要我们的<strong>工作路径和项目编号</strong>传的是一样的，那么它返回的key就是一样的！</p><h2 id="2-2-shmget"><a href="#2-2-shmget" class="headerlink" title="2.2 shmget"></a>2.2 shmget</h2><p><code>shmget - allocates a System V shared memory segment</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><p>参数分别为key值，共享内存的大小，以及创建共享内存的方式。</p><p>key值需要通过<code>ftok</code>函数获取；</p><p>其中共享内存的大小最好设置为4kb的整数倍，因为操作系统IO的基本单位是4KB。如果你申请了不是4的整数倍的字节，比如15个字节，其还是会申请16个字节(4个页)交给你，而其中有1kb的内存你是无法使用的，即造成了内存浪费😥</p><p>创建共享内存的<code>shmflg</code>:</p><ul><li><code>IPC_CREAT</code>：创建共享内存。如果存在则获取，如果不存在则创建后获取</li><li><code>IPC_EXCL</code>：必须配合<code>IPC_CREAT</code>使用，如果不存在指定的共享内存，就进行创建；如果该共享内存存在，则<strong>出错返回</strong>（即保证获取到的共享内存一定是当前进程创建的，是一个新的共享内存）</li></ul><p>返回值是一个共享内存的<strong>标识符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On success, a valid shared memory identifier is returned.  On errir, -1 is returned, and errno is set to indicate the error.</span><br></pre></td></tr></table></figure><p>这些工作都是操作系统做的。其内核中有专门的管理单元来判断一个共享内存是否存在，以及何时被创建、被使用、被什么进程绑定等等…</p><p>命令行键入<code>man shmctl</code>，可以看到下面的内核结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">key_t</span>          __key;    <span class="comment">/* Key supplied to shmget(2) */</span></span><br><span class="line">    <span class="type">uid_t</span>          uid;      <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>          gid;      <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">    <span class="type">uid_t</span>          cuid;     <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">    <span class="type">gid_t</span>          cgid;     <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">/* Permissions + SHM_DEST and</span></span><br><span class="line"><span class="comment">                                           SHM_LOCKED flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共享内存要被管理，其内核结构中一定有一个唯一的key值来标识该共享内存，即和文件的<code>inode</code>一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span>     __key; <span class="comment">//共享内存的唯一标识符，由用户在shmget中提供</span></span><br></pre></td></tr></table></figure><p>关于key为何要让用户提供，已经在上面做出过解释👉 <a href="#jump">回顾一下</a></p><hr><h2 id="2-3-shmat-x2F-shmdt"><a href="#2-3-shmat-x2F-shmdt" class="headerlink" title="2.3 shmat&#x2F;shmdt"></a>2.3 shmat&#x2F;shmdt</h2><p>at其实是attach绑定的缩写，这个接口的作用是将一个共享内存和我们当前的进程绑定。</p><p>其实就是将这个共享内存映射到进程的页表中（堆栈之间）</p><p><code>shmat, shmdt - System V shared memory operations</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure><p>一共有两个函数，分别为at和dt，用于绑定&#x2F;解绑共享内存</p><p><code>shmat</code>的三个参数如下</p><ul><li>shmid：为<code>shmget</code>的返回值</li><li>shmaddr：指定共享内存连接到当前进程中的地址位置。通常为空，表示让系统来选择共享内存的地址。</li><li>shmflg：如果指定了<code>SHM_RDONLY</code>位，则以只读方式连接此段；否则以读写的方式连接此段；通常设置为0</li></ul><p>调用成功的时候，返回指向共享内存第一个字节的指针；出错返回-1</p><ul><li><code>shmdt</code>的参数为<code>shmat</code>正确调用时的返回值</li></ul><p>以下是man手册中对这两个函数返回值的描述👇</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On success shmat() returns the address of the attached shared memory segment; on error (void *) -1 is returned, and errno is set  to</span><br><span class="line">       indicate the cause of the error.</span><br><span class="line"></span><br><span class="line">       On success shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.</span><br></pre></td></tr></table></figure><h2 id="2-4-shmctl"><a href="#2-4-shmctl" class="headerlink" title="2.4 shmctl"></a>2.4 shmctl</h2><p>这个函数可以用于操作我们的共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure><p>其中cmd的参数有下面几种</p><ul><li><p><code>IPC_RMID</code> 删除该共享内存</p></li><li><p><code>IPC_STAT</code> 把<code>shmid_ds</code>结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖<code>shmid_ds</code>的值</p></li><li><p><code>IPC_SET</code> 如果进程有足够的权限，就把共享内存的当前关联值设置为<code>shmid_ds</code>结构中给出的值</p></li></ul><p>最后一个buf参数是一个指向<code>shmid_ds</code>结构的指针，一般设为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The buf argument is a pointer to a shmid_ds structure</span><br></pre></td></tr></table></figure><p><code>shmid_ds</code>的基本结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uid_t</span> shm_perm.uid;</span><br><span class="line">    <span class="type">uid_t</span> shm_perm.gid;</span><br><span class="line">    <span class="type">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以删除为例，其操作如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);<span class="comment">//删除shmid的共享内存</span></span><br></pre></td></tr></table></figure><h2 id="2-5-ipcs命令"><a href="#2-5-ipcs命令" class="headerlink" title="2.5 ipcs命令"></a>2.5 ipcs命令</h2><p>先来康康几个<code>ipcs</code>命令的选项，其中我们要用到的是<code>-m</code>查看共享内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipcs -c <span class="comment">#查看消息队列/共享内存/信号量</span></span><br><span class="line">ipcs -s <span class="comment">#单独查看信号量</span></span><br><span class="line">ipcs -q <span class="comment">#单独查看消息队列</span></span><br><span class="line">ipcs -m <span class="comment">#单独查看共享内存</span></span><br></pre></td></tr></table></figure><p>执行了之后，会列出当前操作系统中开辟的共享内存，以及它们的基本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m </span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 1          muxue      0          1024       0    </span><br></pre></td></tr></table></figure><p>这里的key和我们使用<code>ftok</code>获取到的key值是一样的，只不过我们打印的时候是十进制，操作系统列出来的为十六进制</p><p>我们可以使用<code>ipcrm -m 共享内存的shmid</code>来删除共享内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 1          muxue      0          1024       0                       </span><br><span class="line"></span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcrm -m 1</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br></pre></td></tr></table></figure><p>可以看到我们自己创建的共享内存已经被删除了</p><hr><h3 id="消息队列-x2F-信号量的接口"><a href="#消息队列-x2F-信号量的接口" class="headerlink" title="消息队列&#x2F;信号量的接口"></a>消息队列&#x2F;信号量的接口</h3><p>消息队列和信号量的接口和共享内存很相似</p><p>消息队列用的不多，信号量的难度很高！😂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息队列相关接口</span></span><br><span class="line">msgget <span class="comment">//获取</span></span><br><span class="line">msgctl <span class="comment">//操作</span></span><br><span class="line">msgsnd <span class="comment">//发送信息</span></span><br><span class="line">msgrcv </span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量</span></span><br><span class="line">semget</span><br><span class="line">semctl</span><br><span class="line">semop</span><br></pre></td></tr></table></figure><h3 id="ipcrm"><a href="#ipcrm" class="headerlink" title="ipcrm"></a>ipcrm</h3><p>这个命令可以用与删除ipc资源，包括共享内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -m shmid <span class="comment">#删除共享内存</span></span><br></pre></td></tr></table></figure><p>但是，当我们尝试用该命令删除一个正在被使用的共享内存时，它并不会被立即删除（立即删除会影响进程运行）</p><p>此时执行删除，在共享内存的<code>status</code>列会出现<code>dest</code>；观察结果，当<strong>进程结束</strong>的时候，这个共享内存会被直接删除（进程内部并没有调用<code>shmctl</code>接口）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 21         muxue      666        1024       2                       </span><br><span class="line"></span><br><span class="line">[muxue@bt-7274:~/git]$ ipcrm -m 21</span><br><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x00000000 21         muxue      666        1024       2          dest         </span><br><span class="line"></span><br><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                 </span><br></pre></td></tr></table></figure><p>相比之下，如果不执行<code>ipcrm</code>命令+进程内部不调用<code>shmctl</code>接口，这个共享内存就会一直存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 22         muxue      666        1024       0                       </span><br></pre></td></tr></table></figure><p>结论：使用<code>ipcrm -m</code>命令删除共享内存之后，其共享内存不一定会立即释放。如果有进程关联了该共享内存，则会在进程<strong>去关联之后释放</strong></p><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h1><h2 id="3-1-创建并获取"><a href="#3-1-创建并获取" class="headerlink" title="3.1 创建并获取"></a>3.1 创建并获取</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件实在太多，为了博客篇幅，这里省略了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJ_ID 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH_NAME <span class="string">&quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">CreateKey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PATH_NAME, PROJ_ID);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt;<span class="string">&quot;ftok: &quot;</span>&lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//key获取错误直接退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = CreateKey();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id = shmget(key, NUM, IPC_CREAT | IPC_EXCL);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="File-exists"><a href="#File-exists" class="headerlink" title="File exists"></a>File exists</h3><p>这里会发现，第一次运行代码的时候，程序成功获取了共享内存；但是第二次运行的时候，却报错说<code>File exists(文件存在)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./test</span><br><span class="line">shmget: 1</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./test</span><br><span class="line">shmget err: File exists</span><br></pre></td></tr></table></figure><p>这是因为共享内存的声明周期是随内核的。即只要这个共享内存不被删除，他就会一直存在，直到内核因为某种原因释放掉它，亦或者操作系统关机</p><p>通过上面提到的<code>ipcrm -m shmid</code> 命令删除共享内存，才能重新运行代码获取新的共享内存</p><blockquote><p>为了避免这个问题，应该在进程结束后使用<code>shmctl</code>接口删除共享内存</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./test</span><br><span class="line">shmget success: 2</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 2          muxue      0          1024       0                       </span><br></pre></td></tr></table></figure><h3 id="设置权限值"><a href="#设置权限值" class="headerlink" title="设置权限值"></a>设置权限值</h3><p>默认情况下，我们创建的共享内存的<code>perms</code>是0，代表没有用户能访问这个共享内存。所以在创建的时候，我们需要在flag里面直接或上这个共享内存的权限值</p><p>代码如下👇</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = CreateKey();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    shmctl(id,IPC_RMID,nullptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候创建的共享内存就有正确的权限值了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 4          muxue      666        1024       0    </span><br></pre></td></tr></table></figure><h2 id="3-2-挂接-x2F-取消挂接"><a href="#3-2-挂接-x2F-取消挂接" class="headerlink" title="3.2 挂接&#x2F;取消挂接"></a>3.2 挂接&#x2F;取消挂接</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关联共享内存</span></span><br><span class="line"><span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>因为shmat函数的返回值是一个<code>void*</code>指针，我们可以以使用<code>malloc</code>一样的方式使来挂接共享内存。随后对这个内存的操作就是正常的指针操作了！</p><p>同样的，另外一个进程也需要用同样的方式挂接共享内存，才能读取到相同的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 4          muxue      666        1024       1   </span><br></pre></td></tr></table></figure><p>挂接成功后，可以发现<code>nattch</code>的值从0变为1</p><h3 id="取消-x2F-删除"><a href="#取消-x2F-删除" class="headerlink" title="取消&#x2F;删除"></a>取消&#x2F;删除</h3><p>取消挂接的方式很简单，直接把<code>shmat</code>的返回值传入即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmdt(str);<span class="comment">//取消挂接</span></span><br></pre></td></tr></table></figure><p>如果是服务端，则还需要在取消挂接之后，删除共享内存。避免下次程序运行的时候，无法通过key获取到新的共享内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shmctl</span>(id,IPC_RMID,<span class="literal">nullptr</span>);<span class="comment">//删除共享内存</span></span><br></pre></td></tr></table></figure><h2 id="3-3-写入内容"><a href="#3-3-写入内容" class="headerlink" title="3.3 写入内容"></a>3.3 写入内容</h2><p>因为共享内存本质就是一个内存，其和malloc出来的内存都是一样的，直接使用即可</p><p>这里还是用一个服务端和一个客户端来进行演示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mykey.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key值</span></span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">CreateKey</span>();</span><br><span class="line">    <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">shmget</span>(key, NUM, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//关联共享内存</span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] shmat success\n&quot;</span>);</span><br><span class="line">    <span class="comment">//读取数据，sleep(1)</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">40</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%03d] %s\n&quot;</span>,i,str);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(str);<span class="comment">//shmat的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] shmdt(str)\n&quot;</span>);</span><br><span class="line">    <span class="comment">//删除共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(id,IPC_RMID,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mykey.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key值</span></span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">CreateKey</span>();</span><br><span class="line">    <span class="comment">//获取共享内存</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">shmget</span>(key, NUM, IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//关联共享内存</span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] shmat success\n&quot;</span>);</span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> base = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        str[i] = base+i;</span><br><span class="line">        str[i+<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write times: %02d\n&quot;</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//去关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(str);<span class="comment">//shmat的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] shmdt &amp; exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑起来之后，客户端向共享内存中写入数据（注意控制<code>\0</code>）服务端进行读取。这便实现了我们进程之间的通信</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211130917762.png" alt="image-20221113091741600"></p><p>不过我们发现，客户端已经停止写入之后，服务端还是在不停的读取。如果我们不控制<code>while</code>循环的话，其会一直这么读取下去</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211130918667.png" alt="image-20221113091847579"></p><p>这便牵扯出共享内存的一个特性了</p><h3 id="共享内存没有访问控制"><a href="#共享内存没有访问控制" class="headerlink" title="共享内存没有访问控制"></a>共享内存没有访问控制</h3><p>在管道的博客中提到，管道是有访问控制的进程通信方式，写端没有写入数据的时候，读端会在<code>read</code>中进行等待</p><p>而共享内存因为我们是直接像操作一个malloc出来的空间一样访问，<strong>没有使用任何系统接口</strong>（相比之下管道需要使用<code>read/write</code>）所以操作系统没有办法帮我们进行访问控制</p><p>也正是因为没有等待，共享内存是进程中通信中<strong>最快</strong>的一种方式</p><h3 id="通过管道进行共享内存的控制"><a href="#通过管道进行共享内存的控制" class="headerlink" title="通过管道进行共享内存的控制"></a>通过管道进行共享内存的控制</h3><p>既然共享内存没有访问控制，那么我们可以利用管道来让控制共享内存的读写</p><ul><li>写端写完后，将完成信号写入管道，由读端读取</li><li>读端从管道中获取到信号后，访问共享内存读出内容</li><li>如果写端没有写好，读端就会在管道read内部等待</li></ul><p>你可能会说，那为何不直接用管道通信呢？</p><ul><li>管道仅作访问控制，只需要一个int乃至一个char类型即可；</li><li>相比直接管道通信，内存的方式更好控制（毕竟使用内存的方式和使用指针一样，管道还需要文件操作）</li><li>读取很长一串数据的时候，共享内存的速度优势能体现出来</li></ul><p>以下是完整代码👇</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mykey.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJ_ID 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH_NAME <span class="string">&quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;sc.pipe&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">CreateKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(PATH_NAME, PROJ_ID);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt;<span class="string">&quot;ftok: &quot;</span>&lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//key获取错误直接退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateFifo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mkfifo</span>(FIFO_FILE, <span class="number">0666</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;fifo: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开管道文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Open</span><span class="params">(<span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(FIFO_FILE, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让读端通过管道等待</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果写端没有写入，其就会在read中等待</span></span><br><span class="line">    <span class="type">ssize_t</span> s = <span class="built_in">read</span>(fd, &amp;val, <span class="built_in">sizeof</span>(val));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送完成信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Signal</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> sig = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, &amp;sig, <span class="built_in">sizeof</span>(sig));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//server.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mykey.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建管道</span></span><br><span class="line">    <span class="built_in">CreateFifo</span>();</span><br><span class="line">    <span class="comment">//获取key值</span></span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">CreateKey</span>();</span><br><span class="line">    <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">shmget</span>(key, NUM, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//获取管道</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">Open</span>(O_RDONLY);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;open fifo success: &quot;</span> &lt;&lt; fd &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//关联共享内存</span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] shmat success\n&quot;</span>);</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">40</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> ret = <span class="built_in">Wait</span>(fd);<span class="comment">//通过管道等待</span></span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%03d] %s\n&quot;</span>,i,str);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;[server] wait finish, break&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(str);<span class="comment">//shmat的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] shmdt(str)\n&quot;</span>);</span><br><span class="line">    <span class="comment">//删除共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(id,IPC_RMID,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">unlink</span>(FIFO_FILE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mykey.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key值</span></span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">CreateKey</span>();</span><br><span class="line">    <span class="comment">//获取共享内存</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">shmget</span>(key, NUM, IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取管道</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">Open</span>(O_WRONLY);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;open fifo success: &quot;</span> &lt;&lt; fd &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//关联共享内存</span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] shmat success\n&quot;</span>);</span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> base = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        str[i] = base+i;</span><br><span class="line">        str[i+<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write times: %02d\n&quot;</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">Signal</span>(fd);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//去关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(str);<span class="comment">//shmat的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] shmdt &amp; exit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] close fifo\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>管道控制了之后，当客户端退出的时候，管道也不会继续读取，而是在read内等待</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211131049472.png" alt="image-20221113104949379"></p><p>如果客户端最后关闭了管道的写段，服务器端就会直接退出。这样我们就实现了通过管道控制<strong>共享内存</strong>的读写👍</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211131117485.png" alt="image-20221113111731418"></p><hr><h1 id="4-相关概念"><a href="#4-相关概念" class="headerlink" title="4.相关概念"></a>4.相关概念</h1><h2 id="4-0-临界资源"><a href="#4-0-临界资源" class="headerlink" title="4.0 临界资源"></a>4.0 临界资源</h2><p>能被多个进程看到的资源，被称为<code>临界资源</code></p><p>如果不对临界资源进行访问控制，进程对该资源的访问就是<strong>乱序的</strong>（比如父子进程向显示器打印内容）可能会因为数据交叉导致乱码、数据不可用等情况</p><p>以此可见，显示器、管道、共享内存都是临界资源</p><ul><li>管道是有访问控制的临界资源</li></ul><p>进程访问临界资源的代码，称为<code>临界区</code></p><ul><li>一个进程中，并不是所有的代码都在访问临界资源。如管道中，其实只有<code>read/write</code>接口在访问临界资源</li></ul><p><strong>互斥</strong>：任何时刻，只允许一个进程访问临界资源</p><p><strong>原子性</strong>：一件事情只有<code>做完/没做</code>两种状态，没有中间状态</p><p>下面对信号量的概念进行讲解~只用基本理解即可</p><h2 id="4-1-信号量"><a href="#4-1-信号量" class="headerlink" title="4.1 信号量"></a>4.1 信号量</h2><p>信号量是对<code>临界资源</code>的控制方式之一，其本质是一个<strong>计数器</strong></p><ul><li>信号量保证<strong>不会有多余</strong>的进程连接到这份临界资源</li><li>还需要保证每一个进程的能够访问到临界资源的不同位置（根据上层业务决定）</li></ul><p>信号量根据情况的不同分为两种：</p><ul><li>二元信号量（<strong>互斥</strong>状态，当进程使用的时候为1，没有进程使用的时候为0）</li><li>多元信号量（常规）</li></ul><p>如果一个进程想访问由信号量控制的临界资源，必须先申请信号量。申请成功，就一定能访问到这个临界资源中的一部分（或者全部）</p><h3 id="原子性的说明"><a href="#原子性的说明" class="headerlink" title="原子性的说明"></a>原子性的说明</h3><p>先来想想，我们对一个变量<code>+1/-1</code>需要做什么工作：</p><ul><li>将这个变量从内存中拿到CPU的寄存器中</li><li>在寄存器中完成加减操作</li><li>放回内存</li></ul><p>这其中是有很多个中间状态的，设该变量初始值为100</p><ul><li>假设一个进程A拿走了这个变量，放入CPU的寄存器</li><li>另外一个进程B也来拿走了这个变量</li><li>此时A和B拿到的都是100</li><li>A对该变量进行了循环<code>--</code>操作，最终该变量变成了50，将其放回内存</li><li>B对该变量<code>-1</code>，将其放回内存</li><li>最终导致A对变量的操作被B覆盖，出现了变量不统一的情况</li></ul><p>而我们的信号量为了保证能够正确的控制进程的访问，<strong>其就必须维护自身的原子性</strong>！不能有<strong>中间状态</strong></p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211031203959.jpg" alt="QQ图片20220424132543"></p><p>说人话就是，如果进程A在访问信号量，进程B来了，信号量应该拒绝B的访问，直到A访问结束。不能让B中途插入访问，从而导致<strong>可能的数据不统一</strong></p><blockquote><p><strong>共享内存同样可以通过信号量进行访问控制</strong></p></blockquote><h3 id="改变信号量的值"><a href="#改变信号量的值" class="headerlink" title="改变信号量的值"></a>改变信号量的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nops)</span>;</span><br></pre></td></tr></table></figure><p>功能： 操作信号量，<code>P V</code> 操作</p><p>参数：</p><ul><li>semid 为信号量集的标识符；</li><li>sops 指向进行操作的结构体数组的首地址；</li><li>nsops 指出将要进行操作的信号的个数；</li></ul><p>返回值： 成功返回0，出错返回-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       If successful semop() and semtimedop() return 0; otherwise they return -1 with errno indicating the error.</span><br></pre></td></tr></table></figure><h2 id="4-2-扩展-mmap"><a href="#4-2-扩展-mmap" class="headerlink" title="4.2 扩展 mmap"></a>4.2 扩展 mmap</h2><blockquote><p>这部分仅供参考，可能有错误😥<a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/224953636#:~:text=struct%20ipc_ids%20%7B%20int%20in_use%3B%2F%2F%E8%AF%B4%E6%98%8E%E5%B7%B2%E5%88%86%E9%85%8D%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%AA%E6%95%B0%20int%20max_id%3B%2F%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95%20unsigned,ipc_ids%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%20struct%20ipc_id_ary%20nullentry%3B%2F%2F%E5%A6%82%E6%9E%9CIPC%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%88%99entries%E5%AD%97%E6%AE%B5%E6%8C%87%E5%90%91%E4%BC%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20struct%20ipc_id_ary%2A%20entries%3B%2F%2F%E6%8C%87%E5%90%91%E8%B5%84%E6%BA%90ipc_id_ary%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88%20%7D%3B">部分资料参考<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>前面贴出过<code>IPC</code>资源的内核结构，它们都有一个共同的特点：第一个成员都相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span>  <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">time_t</span>          sem_otime; <span class="comment">/* Last semop time */</span></span><br><span class="line">    <span class="type">time_t</span>          sem_ctime; <span class="comment">/* Last change time */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   sem_nsems; <span class="comment">/* No. of semaphores in set */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span>     <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">time_t</span>          msg_stime;    <span class="comment">/* Time of last msgsnd(2) */</span></span><br><span class="line">    <span class="type">time_t</span>          msg_rtime;    <span class="comment">/* Time of last msgrcv(2) */</span></span><br><span class="line">    <span class="type">time_t</span>          msg_ctime;    <span class="comment">/* Time of last change */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   __msg_cbytes; <span class="comment">/* Current number of bytes in</span></span><br><span class="line"><span class="comment">                                                queue (nonstandard) */</span></span><br><span class="line">    <span class="type">msgqnum_t</span>       msg_qnum;     <span class="comment">/* Current number of messages</span></span><br><span class="line"><span class="comment">                                                in queue */</span></span><br><span class="line">    <span class="type">msglen_t</span>        msg_qbytes;   <span class="comment">/* Maximum number of bytes</span></span><br><span class="line"><span class="comment">                                                allowed in queue */</span></span><br><span class="line">    <span class="type">pid_t</span>           msg_lspid;    <span class="comment">/* PID of last msgsnd(2) */</span></span><br><span class="line">    <span class="type">pid_t</span>           msg_lrpid;    <span class="comment">/* PID of last msgrcv(2) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它们的<strong>第一个成员</strong>都是一个<code>struct ipc_perm</code>，其中包含了一个信号量的基本信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">key_t</span>          __key;    <span class="comment">/* Key supplied to shmget(2) */</span></span><br><span class="line">    <span class="type">uid_t</span>          uid;      <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>          gid;      <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">    <span class="type">uid_t</span>          cuid;     <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">    <span class="type">gid_t</span>          cgid;     <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">/* Permissions + SHM_DEST and</span></span><br><span class="line"><span class="comment">                                           SHM_LOCKED flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而内核中对<code>IPC</code>资源的管理，是通过一个<strong>数组</strong>进行的。我们所获取的<code>shmid</code>，和文件描述符一样，<strong>都是一个数组的下标</strong></p><p>其中我在测试的时候，便发现了一点：我们每一次获取的新的共享内存，它的编号都会<code>+1</code>，而不像文件描述符一样，提供第一个没有被使用的下标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> in_use;<span class="comment">//说明已分配的资源个数</span></span><br><span class="line">    <span class="type">int</span> max_id;<span class="comment">//在使用的最大的位置索引</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> seq;<span class="comment">//下一个分配的位置序列号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> seq_max;<span class="comment">//最大位置使用序列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span> <span class="comment">//保护 ipc_ids的信号量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span> <span class="title">nullentry</span>;</span><span class="comment">//如果IPC资源无法初始化，则entries字段指向伪数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span>* <span class="title">entries</span>;</span><span class="comment">//指向资源ipc_id_ary数据结构的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内核中，<code>struct ipc_id_ary* entries</code>是一个指向所有<code>ipc_perm</code>的<strong>指针数组</strong>。其能够通过该数组找到我们对于id（下标）的资源，对其进行访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">p</span>[0];</span><span class="comment">//指针数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211131639022.png" alt="image-20221113163918931"></p><p>那你可能想问了，这里只是第一个元素啊？那如果我想访问<code>shmid_ds</code>结构的其他成员，岂不是没有办法访问了？</p><p>要是这么想，就还是太年轻了😂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(strcut shmid_ds*)</span><br></pre></td></tr></table></figure><p>我们只需要对这个指针进行强转，就能直接访问其他成员！</p><p>这是因为：<font color="orange">C语言中，结构体第一个元素的地址，和结构体整体的地址是一样的！</font></p><p>指针的类型会限制这个指针访问元素的能力，只要我们进行强转，其就能直接访问父结构体的其他成员！</p><blockquote><p>这是一种<strong>切片</strong>的思想</p></blockquote><p>用这种办法，可以用统一的规则在内核中管理不同的<code>IPC</code>资源，没有必要再为每一个IPC资源建立一个单独的数组来管理。</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211031202438.gif" alt="QQ图片20220419103136"></p><p>不得不说，<code>linus</code>大佬是真的牛逼！</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于共享内存的操作到这里就OVER了！</p><p>最后还了解了一些内核设计上的小妙招，不得不说，真的牛批~</p><p><strong>如果本文有什么问题，欢迎在评论区提出</strong></p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202211031206219.png" alt="QQ图片20220527185356"></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【Linux】进程通信 | 共享内存 | 信号量</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2022-11-13 10:40:16</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2022/11/13/note_Linux/17共享内存_信号量/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E8%BF%9B%E7%A8%8B/">#进程</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/11/20/note_Linux/18%E4%BF%A1%E5%8F%B7/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【Linux】进程通信 | 信号</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/11/11/note_Linux/16%E7%AE%A1%E9%81%93/"><span class="title flex-center"><span class="post-nav-title-item">【Linux】进程通信 | 管道</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="//img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/waline.css"><link rel="stylesheet" href="//img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/waline-meta.css"><script data-pjax src="//img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://vrcl.outpost54.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true'
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%95%A5%E6%98%AF%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">1.啥是共享内存？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.相关接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-ftok"><span class="nav-text">2.1 ftok</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-shmget"><span class="nav-text">2.2 shmget</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-shmat-x2F-shmdt"><span class="nav-text">2.3 shmat&#x2F;shmdt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-shmctl"><span class="nav-text">2.4 shmctl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-ipcs%E5%91%BD%E4%BB%A4"><span class="nav-text">2.5 ipcs命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-x2F-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-text">消息队列&#x2F;信号量的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ipcrm"><span class="nav-text">ipcrm</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8"><span class="nav-text">3.使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%8E%B7%E5%8F%96"><span class="nav-text">3.1 创建并获取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#File-exists"><span class="nav-text">File exists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90%E5%80%BC"><span class="nav-text">设置权限值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%8C%82%E6%8E%A5-x2F-%E5%8F%96%E6%B6%88%E6%8C%82%E6%8E%A5"><span class="nav-text">3.2 挂接&#x2F;取消挂接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E6%B6%88-x2F-%E5%88%A0%E9%99%A4"><span class="nav-text">取消&#x2F;删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%86%99%E5%85%A5%E5%86%85%E5%AE%B9"><span class="nav-text">3.3 写入内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%B2%A1%E6%9C%89%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">共享内存没有访问控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="nav-text">通过管道进行共享内存的控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="nav-text">运行结果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">4.相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-0-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="nav-text">4.0 临界资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">4.1 信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-text">原子性的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%80%BC"><span class="nav-text">改变信号量的值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%89%A9%E5%B1%95-mmap"><span class="nav-text">4.2 扩展 mmap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-text">结语</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep%20v3.6.1-blue" height="20px"> </a><a href="https://www.travellings.cn/go.html" target="_blank"><img src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/travellingICON.gif" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054%E5%8F%B7-ff69b4" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/%E5%8F%88%E6%8B%8D%E4%BA%91_logo5.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>