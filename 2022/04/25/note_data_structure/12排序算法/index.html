<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-E1K9nNha9u"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><title>【C语言】八大排序算法（带图详解） | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【C语言】八大排序算法（带图详解）</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2022-04-25 11:13:49</span> <span class="mobile">2022-04-25 11:13</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-02-11 10:52:09</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%AA%E5%A4%8D%E6%9D%82/">数据结构太复杂</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a>&nbsp;</li><li>| <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;</li><li>| <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>&nbsp;</li><li>| <a href="/tags/%E6%8E%92%E5%BA%8F/">排序</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>7.3k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你把本专栏从头看到这里，那么恭喜你，本篇博客已经是是初阶数据结构的收尾啦😁！让我们一起来学习一下，那些常见的<strong>排序算法</strong>！</p><blockquote><p>本篇博客主要讲述<strong>八大排序</strong>🕵️‍♀️，桶排序/基数排序可能会在后期补上！欢迎大家收藏本文！</p></blockquote><p><img lazyload="" alt="image-20220422200828833" data-src="https://img1.musnow.top/i/23/02/202204222008002.png"></p><p>在之前的学习中，我们已经接触过ez的冒泡排序，和通过堆实现的堆排序，本篇博客就不再详解这两个了！</p><blockquote><p>有些排序的思路不是那么好懂，我的讲解也会有不到位的地方，欢迎在评论区提出你的疑惑或建议！🌭</p></blockquote><p>[TOC]</p><h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h1><h2 id="1-1直接插入"><a href="#1-1直接插入" class="headerlink" title="1.1直接插入"></a>1.1直接插入</h2><p><strong>基本思想</strong>：把待排序的数依照大小插入<strong>一个已经有序的序列</strong>中，直到所有数插入完毕，就能得到一个新的有序序列</p><blockquote><p>实际上我们日常生活中打<strong>斗地主</strong>，在码牌的时候就运用了这种思想。把相同的数放在一起，并依照从小到大排列</p><p><img lazyload="" alt="image-20220422160009868" data-src="https://img1.musnow.top/i/23/02/202204221600928.png"></p></blockquote><p>你可能会疑惑，都“已经有序”了，那还怎么排序？</p><ul><li>这需要我们之前学习链式二叉树时接触到的<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/124212851">分治思想<i class="fas fa-external-link-alt"></i></a></li><li>当我们手头上只有两个数的时候，将大的那个数插入到小的数后头，就形成了一个有序的2数序列</li><li>这时候再让下一个数加入进来，把它插入到相应位置，得到一个有序的3数序列</li><li>依次递进，最终就能得到一个有序的N数序列</li></ul><p>如果学习过分治思想的你，肯定一拍桌子道：“我知道了，手头上只有两个数的时候，就是<strong>分治的末端条件</strong>！”</p><p>没错，我们就是要利用这种<strong>思想</strong>，实现<strong>从两个数开始</strong>的插入排序！</p><blockquote><p>给定一个数组，需要你使用插入排序，将它变成<strong>升序</strong>序列</p></blockquote><p>我们就从9开始，将1插入到9的前面，2插入到1、9之间，……</p><p><img lazyload="" alt="image-20220422161806094" data-src="https://img1.musnow.top/i/23/02/202204221618132.png"></p><p>这样就能最终排序出<code>1 2 3 4 5 5 6 7 8 9</code>的结果</p><p><img lazyload="" alt="image-20220422162143696" data-src="https://img1.musnow.top/i/23/02/202204221621780.png"></p><p>最后以代码的形式操作，如下面所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//在一个数组中插入新的数，每一趟都让最后的end+1的数据大于end</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> end = i;</span><br><span class="line">		<span class="type">int</span> tmp = a[end+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (tmp &lt; a[end])</span><br><span class="line">			{</span><br><span class="line">				a[end + <span class="number">1</span>] = a[end];</span><br><span class="line">				end--;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		a[end+<span class="number">1</span>] = tmp;</span><br><span class="line">		<span class="comment">//最后end不符合条件出循环的时候，end可能为-1，a[end]会越界</span></span><br><span class="line">		<span class="comment">//如果是break出的循环，end+1和tmp的位置相同，自己等于自己，问题不大</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>由此我们可以总结出直接插入排序的一些特性</p><ul><li>时间复杂度：O(N^2^)</li><li>空间复杂度：O(1)，是<strong>原地算法</strong></li><li>元素越接近有序的时候，需要交换的次数就越少，算法的效率越高</li></ul><hr><h2 id="1-2希尔排序"><a href="#1-2希尔排序" class="headerlink" title="1.2希尔排序"></a>1.2希尔排序</h2><p><strong>希尔排序是对直接插入的优化</strong>，又称“缩小增量法”。之前我们是进数组之后直接开R，现在先Q一下再R闪，这样才能打出更秀的操作。不过我的盲僧很菜，R闪就没有成功过😥</p><blockquote><p>喂喂喂，好像跑题了！</p></blockquote><p><strong>基本思想</strong>：先选定一个整数gap，让后把待排序数据<strong>以gap为间隔</strong>进行单独的插入排序（预排序），这样让数列做到<strong>局部有序</strong>，最后在进行插入排序，达到优化<strong>插入排序算法效率</strong>的目的</p><p>比如我们设定<code>gap=3</code>，这样原本的数组就被分割成了下面的模样，接着我们先对这3组数据进行单独的插入排序【这个操作被称为 <strong>预排序</strong>】</p><p><img lazyload="" alt="image-20220422164129904" data-src="https://img1.musnow.top/i/23/02/202204221641951.png"></p><p>你能写出它们单独插入排序后的结果吗？</p><p><img lazyload="" alt="image-20220422164534325" data-src="https://img1.musnow.top/i/23/02/202204221645372.png"></p><p>这时候我们的序列虽然不是有序的，但是只看一个小局部的时候，它是有序的。</p><p>这样能<strong>减少</strong>插入排序操作时候的<strong>比较次数</strong>，自然效率就变高了</p><hr><p>执行完<strong>预排序</strong>后，我们就可以对现在的新序列进行插入排序了。但是直接这么调用还不够优化。</p><p><img lazyload="" alt="QQ图片20220424132543" data-src="https://img1.musnow.top/i/23/02/202204241449059.jpg"></p><p>再仔细看看上面的思路，你会发现，其实<code>gap=1</code>的时候，就相当于一次插入排序了</p><ul><li>而且当数据量很大的时候，我们也需要实时改变我们的<code>gap</code>。</li><li>待排序数据有100个，gap=3就太小了，优化了个寂寞。</li><li>待排序数据有10个，gap=20就是搬起石头砸自己的脚，同样不行！</li></ul><p>解决这个方法其实很简单，我们只需要根据待排序数据的大小动态设置gap就可以了，比如<code>gap=n/2</code></p><p>这时候就可以进行这么一个操作：<strong>每次预排序过后就改变一下gap</strong>，直到最后gap=1执行一次插入排序，数列有序</p><hr><p>落实到代码上，我们只需要把插入排序中所有和1有关的操作都改成gap，就实现了希尔排序</p><ul><li>这里需要注意的是gap的范围，因为我设置的是gap每次都/3，所以在最后可能会出现<code>gap=2/3=0</code>的情况，这时候其实排序还没有结束，但已经跳出循环了。我们需要在末尾+1保证最后一次插入排序的gap=1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//只要把插入排序中的1全部改成grap，就能形成一次间隔为3的预排序</span></span><br><span class="line">	<span class="comment">//当grap=1时，效果同插入排序相同</span></span><br><span class="line">	<span class="type">int</span> grap = n;</span><br><span class="line">	<span class="keyword">while</span> (grap &gt; <span class="number">1</span>)<span class="comment">//当grap=1，说明上一把已经是插入排序了</span></span><br><span class="line">	{</span><br><span class="line">		grap=grap/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">//每一次都/3,再+1防止grap=2/3的情况</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - grap; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="type">int</span> end = i;</span><br><span class="line">			<span class="type">int</span> tmp = a[end + grap];</span><br><span class="line">			<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (tmp &lt; a[end])</span><br><span class="line">				{</span><br><span class="line">					a[end + grap] = a[end];</span><br><span class="line">					end -= grap;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			a[end + grap] = tmp;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>希尔排序的时间复杂度不好确定，因为我们通常会选取不同的gap，导致时间效率也不同。不过大部分资料中给出的时间复杂度如下👇<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="24.591ex" height="2.565ex" role="img" focusable="false" viewBox="0 -883.9 10869.4 1133.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="TeXAtom" transform="translate(975.3,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(3434.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(3823.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">到</text></g><g data-mml-node="mi" transform="translate(4823.5,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(5586.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(5975.5,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(7475.7,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="msup" transform="translate(8197.9,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="TeXAtom" transform="translate(975.3,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(10480.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><br>在“菜鸟教程”网，有对希尔排序时间复杂度的解析👉<a class="link" target="_blank" rel="noopener" href="https://www.runoob.com/data-structures/shell-sort.html#:~:text=%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%20O%20%28n%20%28logn%29%29%20%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BF%AB,%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AF%B9%E4%B8%AD%E7%AD%89%E5%A4%A7%E5%B0%8F%E8%A7%84%E6%A8%A1%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%EF%BC%8C%E4%BD%86%E5%AF%B9%E8%A7%84%E6%A8%A1%E9%9D%9E%E5%B8%B8%E5%A4%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F%E4%B8%8D%E6%98%AF%E6%9C%80%E4%BC%98%E9%80%89%E6%8B%A9%EF%BC%8C%E6%80%BB%E4%B9%8B%E6%AF%94%E4%B8%80%E8%88%AC%20O%20%28n%5E2%20%29%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%AE%97%E6%B3%95%E5%BF%AB%E5%BE%97%E5%A4%9A%E3%80%82%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9B%AE%E7%9A%84%E4%B8%BA%E4%BA%86%E5%8A%A0%E5%BF%AB%E9%80%9F%E5%BA%A6%E6%94%B9%E8%BF%9B%E4%BA%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%8D%E7%9B%B8%E9%82%BB%E7%9A%84%E5%85%83%E7%B4%A0%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%B1%80%E9%83%A8%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%B9%B6%E6%9C%80%E7%BB%88%E7%94%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%B0%86%E5%B1%80%E9%83%A8%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E3%80%82">传送门<i class="fas fa-external-link-alt"></i></a></p><p><img lazyload="" alt="image-20220422171733818" data-src="https://img1.musnow.top/i/23/02/202204221717852.png"></p><hr><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h1><h2 id="2-1直接选择"><a href="#2-1直接选择" class="headerlink" title="2.1直接选择"></a>2.1直接选择</h2><p><strong>基本思路</strong>：遍历一遍数组，从中找出最大或最小的那一个数，然后将其放在数组前端。下一次遍历的时候，不再遍历这个数。</p><p>注意：得到最大最小值后，需要将其和数组开头（或者结尾）的数进行<strong>交换</strong>，而不能直接覆盖，不然会出现数据丢失</p><hr><p>这个排序的思路非常好理解。进一步拓展，如果我一次遍历选出两个数，将最大值放在数组尾部，最小值放在数组开头，就可以减少一半遍历的次数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>{</span><br><span class="line">	<span class="type">int</span> tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 直接选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> max ,min;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right){</span><br><span class="line">		max = min = left;<span class="comment">//存放下标便于后面的交换</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (a[i] &gt;=a[max]){</span><br><span class="line">				max= i;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt;= a[min]){</span><br><span class="line">				min= i;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		Swap(&amp;a[min], &amp;a[left]);</span><br><span class="line">		<span class="keyword">if</span> (max == left) {</span><br><span class="line">			max = min;</span><br><span class="line">		}<span class="comment">//如果max数据在开头，第一次交换会被替换</span></span><br><span class="line">        <span class="comment">//所以需要重定向max的位置，再交换max</span></span><br><span class="line">		Swap(&amp;a[max], &amp;a[right]);</span><br><span class="line">		left++;</span><br><span class="line">		right--;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>不过，这个算法需要多次遍历数组，效率自然低的离谱，堪比冒泡（甚至比冒泡还拉）</p><ul><li>时间复杂度：O(N^2^)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="2-2堆排序"><a href="#2-2堆排序" class="headerlink" title="2.2堆排序"></a>2.2堆排序</h2><p>堆排序是指利用<code>二叉树-堆</code>这种数据结构来进行选择数据的一种排序算法，它是选择排序的一种。</p><p>需要注意的是：升序要建大堆，排降序建小堆</p><p>堆排序已经在之前的博客中讲解过，点击下方连接即可查看！👇</p><blockquote><p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/124102518">【C语言】什么是堆？堆排序和TopK问题又是如何实现的<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>这里给出堆排序的源码，或许聪明的你看源码就能看懂呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> root)</span></span><br><span class="line">{</span><br><span class="line">	assert(a);</span><br><span class="line">	<span class="type">int</span> parent = root;</span><br><span class="line">	<span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//左孩子</span></span><br><span class="line">	<span class="keyword">while</span> (child &lt; n){</span><br><span class="line">		<span class="comment">//找左右孩子中小的那一个</span></span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>])</span><br><span class="line">		{<span class="comment">//如果左孩子大于右孩子，则选择右孩子</span></span><br><span class="line">			child++;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (a[child] &gt; a[parent]){</span><br><span class="line">			Swap(&amp;a[child], &amp;a[parent]);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 升序用大堆</span></span><br><span class="line"><span class="comment">// 降序用小堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 向下调整--建堆 O(N)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i){</span><br><span class="line">		AdjustDown(a, n, i);<span class="comment">//此时建的是一个小堆</span></span><br><span class="line">	}</span><br><span class="line">	PrintArray(a, n);</span><br><span class="line">	<span class="type">size_t</span> end = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (end &gt; <span class="number">0</span>){</span><br><span class="line">		Swap(&amp;a[<span class="number">0</span>], &amp;a[end]);<span class="comment">//前后交换，最大的数放到末尾，不进行下一次调整</span></span><br><span class="line">		AdjustDown(a, end, <span class="number">0</span>);</span><br><span class="line">		end--;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><hr><h1 id="3-交换排序"><a href="#3-交换排序" class="headerlink" title="3.交换排序"></a>3.交换排序</h1><h2 id="3-1咕噜咕噜排序"><a href="#3-1咕噜咕噜排序" class="headerlink" title="3.1咕噜咕噜排序"></a>3.1咕噜咕噜排序</h2><p>说道<strong>冒泡</strong>排序啊，那就是陪伴咱们<strong>C语言学习始终</strong>的一个老朋友了。</p><p>在初识C语言的学习中，我曾写过一篇博客，里面讲解了用冒泡来模拟实现库函数<code>qsort</code>👉<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/122674411">传送门<i class="fas fa-external-link-alt"></i></a></p><p><img lazyload="" alt="冒泡" data-src="https://img1.musnow.top/i/23/02/202204221928011.jpg"></p><p>它的思路就是对两个数进行比较，较大的数往尾部移动，较小的数字往头部移动</p><p><img lazyload="" alt="冒泡" data-src="https://img1.musnow.top/i/23/02/202204222014860.gif"></p><p>在<strong>very very long time ago</strong>，我也写过关于冒泡排序的博客👇</p><blockquote><p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/119911717?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165062690016780366548985%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165062690016780366548985&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-119911717.nonecase&utm_term=%E5%86%92%E6%B3%A1&spm=1018.2226.3001.4450">初识C语言==＞冒泡排序<i class="fas fa-external-link-alt"></i></a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> exchange = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]){</span><br><span class="line">				exchange=<span class="number">1</span>;</span><br><span class="line">				Swap(&amp;a[j], &amp;a[j + <span class="number">1</span>]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (exchange == <span class="number">0</span>){</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//如果单趟排序没有发生交换，说明此时已经有序</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>空间复杂度：O(N^2^)</li><li>时间复杂度：O(1)</li></ul><hr><h2 id="3-2快速排序"><a href="#3-2快速排序" class="headerlink" title="3.2快速排序"></a>3.2快速排序</h2><p>快速排序是Hoare于1962年提出的一种二叉树结构的交换排序算法。</p><p><strong>基本思想</strong>：任取待排序序列中的某个元素作为基准值，按照该基准值将待排序集合分割成<strong>两个子序列</strong>，左子序列中所有元素均<strong>小于基准值</strong>，右 子序列中所有元素均<strong>大于基准值</strong>，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</p><p><img lazyload="" alt="QQ图片20220424132540" data-src="https://img1.musnow.top/i/23/02/202204241343241.jpg"></p><h3 id="3-2-1-Hoare法"><a href="#3-2-1-Hoare法" class="headerlink" title="3.2.1 Hoare法"></a>3.2.1 Hoare法</h3><p>发明快排的大佬给出了一个方法，假设<strong>0下标处</strong>为<code>基准值key</code>。用左右指针来遍历数组，右指针找到比key<strong>小</strong>的数后停下，左指针找找到比key<strong>大</strong>的数后停下，它们俩进行<strong>交换</strong>。</p><p>最后left和right相遇的时候，左右序列就已经排好了，此时将key与它们相遇的位置进行交换。<strong>新的序列key的左边小于key，右边大于key</strong>（此时不一定有序）</p><ul><li>疑问：既然最后要将相遇位置和key进行交换，那要怎么保证相遇位置小于key？</li><li>答：通过右指针先走来实现！</li></ul><p>可能说完思路后，你还是不太了解这左右指针是怎么走的，别着急，来康康我画的动图👇</p><p><img lazyload="" alt="Hoare法" data-src="https://img1.musnow.top/i/23/02/202204222132566.gif"></p><p>因为是右指针先走，所以右指针停下的位置，一定是小于key的位置。此时只会是L来交R，不可能是R往左遇到L（因为L停下的位置大于key，在此右边不可能没有一个小于key的值）</p><p>比如下图所示，如果L的位置右边只有一个比key小的值，那R在第一趟就会来到2的位置，然后L向右走一步与R相交，直接交换</p><p><img lazyload="" alt="image-20220422213636856" data-src="https://img1.musnow.top/i/23/02/202204222136890.png"></p><h4 id="两种极端情况"><a href="#两种极端情况" class="headerlink" title="两种极端情况"></a>两种极端情况</h4><p>也会有<span id="jump">下面的</span>两种<strong>极端情况</strong></p><ul><li>key右侧没有比key小的值，那么R会直接与L相交，再原地交换key</li><li>key右侧没有比key大的值，R先移动（原地不动），L直接与R在末尾相交，前后交换</li></ul><p>这两种极端情况，就是快排的<strong>弱势</strong>所在，在后头会讲述如何<strong>优化key的选则</strong>，来避免这种极端情况</p><hr><p>下面给出hoare法的代码，中间的代码是一趟hoare排序的实现，而在末尾，我们递归排序key的前半区域和后半区域，一直递归到最小区间：【区间只有一个值，或者区间不存在】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span><span class="comment">//hoare</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end){</span><br><span class="line">		<span class="keyword">return</span> ;<span class="comment">//分治的末端条件判断</span></span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//一趟排序</span></span><br><span class="line">	<span class="type">int</span> left = begin, right = end;</span><br><span class="line">	<span class="type">int</span> keyi = begin;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> ((a[right] &gt; a[keyi])&amp;&amp;(right&gt;=begin))</span><br><span class="line">		{</span><br><span class="line">			right--;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">while</span> ((a[left] &lt;= a[keyi])&amp;&amp;(left&lt;right))</span><br><span class="line">		{</span><br><span class="line">			left++;</span><br><span class="line">		}</span><br><span class="line">		Swap(&amp;a[left], &amp;a[right]);</span><br><span class="line">	}</span><br><span class="line">	Swap(&amp;a[left],&amp;a[keyi]);</span><br><span class="line">	keyi = left;<span class="comment">//必须移动keyi的位置</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//递归排序左右区间</span></span><br><span class="line">	QuickSort1(a, begin, keyi<span class="number">-1</span>);</span><br><span class="line">	QuickSort1(a, keyi + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="3-2-2-挖坑法"><a href="#3-2-2-挖坑法" class="headerlink" title="3.2.2 挖坑法"></a>3.2.2 挖坑法</h3><p>挖坑法的思路比Hoare更好理解，详情见👇动图</p><p><img lazyload="" alt="挖坑法" data-src="https://img1.musnow.top/i/23/02/202204241345343.gif"></p><p>我们先用一个变量保存key的值（不是保存下标），然后R先走找比key小的，与坑位交换，L找比key大的，与坑位交换。最终LR相遇的时候，把key放回相遇位置，就完成了一趟排序</p><blockquote><p>注意：图中为了便于理解，将<strong>坑位用空白</strong>表示。实际在内存中操作的时候，坑位可以一直是key的值，不需要真的把它移走或者删除</p></blockquote><p>怎样？是不是比方法1好理解一些呢？</p><p>下面给出挖坑法的代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挖坑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> left = begin, right = end;</span><br><span class="line">	<span class="type">int</span> keyi = a[begin];<span class="comment">//先存放keyi的值</span></span><br><span class="line">	<span class="type">int</span> pit = begin;<span class="comment">//pit作为坑位</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> ((a[right] &gt; keyi) &amp;&amp; (right &gt;= begin))</span><br><span class="line">		{</span><br><span class="line">			right--;</span><br><span class="line">		}</span><br><span class="line">		Swap(&amp;a[pit], &amp;a[right]);</span><br><span class="line">		pit = right;</span><br><span class="line">		<span class="keyword">while</span> ((a[left] &lt;= keyi) &amp;&amp; (left &lt; right))</span><br><span class="line">		{</span><br><span class="line">			left++;</span><br><span class="line">		}</span><br><span class="line">		Swap(&amp;a[pit], &amp;a[left]);</span><br><span class="line">		pit = left;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	QuickSort2(a, begin, pit - <span class="number">1</span>);</span><br><span class="line">	QuickSort2(a, pit + <span class="number">1</span>, end);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="3-2-3-前后指针法"><a href="#3-2-3-前后指针法" class="headerlink" title="3.2.3 前后指针法"></a>3.2.3 前后指针法</h3><p>这部分就不画动图了，不知下面的这种方式能不能讲解清楚呢？</p><p><img lazyload="" alt="image-20220424144222726" data-src="https://img1.musnow.top/i/23/02/202204241442819.png"></p><p><img lazyload="" alt="image" data-src="https://img1.musnow.top/i/23/02/202204241444345.png"></p><p>这里需要弄明白的是cur和prev是分别在什么情况下移动</p><ul><li>cur比key<strong>小</strong>的时候，prev往后++一位，二者交换（在刚开始的时候是原地交换，但在图4中就不是原地交换了）</li><li>cur比key<strong>大</strong>的时候，prev不动，cur继续往后++，直到找到比key小的数或者越界后停止（如果找到比key小的，就执行上一步的交换）</li><li>最终cur越界了，交换prev和key的数据，一趟排序完成</li></ul><hr><p>下面给出前后指针法的代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort3</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span><span class="comment">//前后指针</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> keyi = begin;</span><br><span class="line">	<span class="type">int</span> prev = begin, cur = begin + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= end)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> ((a[cur] &lt; a[keyi]) &amp;&amp; (a[++prev] != a[cur]))</span><br><span class="line">		{</span><br><span class="line">			Swap(&amp;a[prev], &amp;a[cur]);</span><br><span class="line">		}</span><br><span class="line">		cur++;</span><br><span class="line">	}</span><br><span class="line">	Swap(&amp;a[prev], &amp;a[keyi]);</span><br><span class="line">	keyi = prev;</span><br><span class="line">	</span><br><span class="line">	QuickSort3(a, begin, keyi - <span class="number">1</span>);</span><br><span class="line">	QuickSort3(a, keyi + <span class="number">1</span>, end);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="优化极端情况"><a href="#优化极端情况" class="headerlink" title="优化极端情况"></a>优化极端情况</h4><p><a href="#jump">上面</a>提到了快速排序有两种极端情况，我们可以用一个操作来优化它：</p><p>既然key取数组首或尾部都可能会遇到它的后面没有比它小（或大）的数，那我们就让key尽量作为数组有序后应该处于中部的数来作为key</p><p>这时候不能直接选取待排序数组中部的数，因为它不一定是数值正好的那个</p><p>我们可以选取数组<strong>开头、末尾、中间的3个数进行比较</strong>，再选择这3个数里面<strong>居中</strong>的那个数作为我们的key，这样就能避免无效遍历！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetMid</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (a[left] &lt; a[mid])</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &lt; a[right]){</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[left] &gt; a[right]){</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">// a[left] &gt; a[mid]</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &gt; a[right]){</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[left] &lt; a[right]){</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//其实这个没啥意义</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>但是单纯加上这个代码并不可行，因为这时候的key不再处于序列开头了，也就意味这我们后头的代码都需要重新写一遍！</p><p><img lazyload="" alt="image-20220424141305225" data-src="https://img1.musnow.top/i/23/02/202204241413267.png"></p><p>这不坑爹吗这是？！</p><p>为了不没事找事重写一遍代码，这里直接把找到的<strong>MID和left进行交换</strong>就OK了！</p><p><img lazyload="" alt="image-20220424141554572" data-src="https://img1.musnow.top/i/23/02/202204241415619.png"></p><p>同时，为了避免多次递归<strong>导致栈溢出</strong>，我们还可以设置一个条件，在序列长度小于10的时候调用其他排序（比如插入排序）来实现后面的排序操作</p><h3 id="3-2-4快排的时间-x2F-空间复杂度"><a href="#3-2-4快排的时间-x2F-空间复杂度" class="headerlink" title="3.2.4快排的时间/空间复杂度"></a>3.2.4快排的时间/空间复杂度</h3><p>快排的递归调用非常类似链式二叉树的前序遍历，它一共会递归<code>logN</code>层级，每一层加起来都有N个数，这样就能算出它的时间复杂度</p><ul><li>时间复杂度：O(N*logN)</li><li>空间复杂度：O(logN)，这个是递归开辟栈帧的空间消耗</li></ul><hr><h2 id="3-3快排非递归实现"><a href="#3-3快排非递归实现" class="headerlink" title="3.3快排非递归实现"></a>3.3快排非递归实现</h2><p>这部分的知识就比较深奥了，你可以先看看这篇博客，了解一下函数调用的时候会发生什么👉<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123288455">传送门<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>但不要担心，其实它的思路并没有那么难！</p></blockquote><p>首先需要先搞明白，递归调用的本质是在操作什么？</p><p>在快排中，递归调用的本质是让程序<strong>自己来缩小排序的范围，再逐步扩大</strong></p><p>那我们可不可以利用<strong>数据结构中的栈</strong>，来模拟实现程序运行中的递归操作呢？</p><ul><li>排序完一趟后，将下一趟的左右范围入栈</li><li>程序先调用存放在<strong>栈顶</strong>的右边范围进行排序，并把这个范围的左右小区间再次入栈</li><li>最后右边的区间已经不可再分，就开始返回调用左边区间</li></ul><p>这个操作就犹如链式二叉树的后序遍历，先递归访问右节点，再往回返回左节点</p><p>最后得到的结果就是类似递归调用完毕后的结果</p><p><img lazyload="" alt="image-20220424152639099" data-src="https://img1.musnow.top/i/23/02/202204241526140.png"></p><blockquote><p>如果你还没有学习数据结构里面的栈，<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123760510">点我速览<i class="fas fa-external-link-alt"></i></a>！</p></blockquote><p>下面给出一个非递归的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort4</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">{</span><br><span class="line">	Stack st;</span><br><span class="line">	StackInit(&amp;st);</span><br><span class="line">	StackPush(&amp;st, begin);</span><br><span class="line">	StackPush(&amp;st, end);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!StackEmpty(&amp;st))</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> right = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line">		<span class="type">int</span> left = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> keyi = PartSort3(a, left, right);</span><br><span class="line">		<span class="comment">// [left,keyi-1][keyi+1，right]</span></span><br><span class="line">		<span class="keyword">if</span> (left &lt; keyi<span class="number">-1</span>)</span><br><span class="line">		{</span><br><span class="line">			StackPush(&amp;st, left);</span><br><span class="line">			StackPush(&amp;st, keyi<span class="number">-1</span>);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (keyi + <span class="number">1</span> &lt; right)</span><br><span class="line">		{</span><br><span class="line">			StackPush(&amp;st, keyi+<span class="number">1</span>);</span><br><span class="line">			StackPush(&amp;st, right);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	StackDestory(&amp;st);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>注意：因为这里需要得到一趟递归调用后<strong>返回的keyi</strong>，所以我们需要把之前写的<strong>一趟快排</strong>单独拿出来，并设置返回值</p><p><img lazyload="" alt="image-20220424153520330" data-src="https://img1.musnow.top/i/23/02/202204241535401.png"></p><p>来调用一下试试，成功了！</p><p><img lazyload="" alt="image-20220424153658856" data-src="https://img1.musnow.top/i/23/02/202204241536895.png"></p><hr><h1 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h1><p><strong>基本思想</strong>：采用分治递归，将已有的子序列合并，得到一个有序的序列。即先使每个子序列有序，再使子序列段间有序</p><ul><li>若将<strong>两个</strong>有序表合并成一个有序表，称为<strong>二路归并</strong></li></ul><p>实现的步骤如下图</p><p><img lazyload="" alt="image-20220424222741365" data-src="https://img1.musnow.top/i/23/02/202204242227495.png"></p><ul><li>先将区间通过递归分割成<strong>分治末端</strong>（只有一个值）</li><li>再对相邻两个区间进行比较，开辟一个新的数组，依次将两个区间中<strong>小</strong>的那个按顺序摆放在新的数组中，再拷贝回原数组，就实现了归并</li><li>当区间不存在的时候，开始返回递归，直到序列有序</li></ul><h2 id="4-1打印printf调试大法"><a href="#4-1打印printf调试大法" class="headerlink" title="4.1打印printf调试大法"></a>4.1打印printf调试大法</h2><p>这里最需要注意的就是分治的序列区间问题，如果代码不对，就很容易形成<strong>越界访问</strong>！</p><p>这里我们可以通过<code>printf调试大法</code>来实现，打印出每一层递归时的区间，就能发现可能存在的<strong>越界访问</strong>问题。这种方法还能帮助我们理解<strong>分治递归</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf("[%d,%d][%d,%d]\n", begin, mid, mid+1, end);</span><br></pre></td></tr></table></figure><p><img lazyload="" alt="GIF" data-src="https://img1.musnow.top/i/23/02/202204242314760.gif"></p><blockquote><p>如果你在写程序的时候，发现控制台的光标闪动了很久都没有打印出数据，那么多半是程序中有<strong>死循环和bug</strong></p></blockquote><p>比如现在，我们初步查看递归调用中是没有出现越界的，但是答案错误，进一步调试发现，tmp数组中有序数字，并没有被我们完整的拷贝回去</p><p>原本是<code>2 5</code>拷贝回去变成了<code>2 2</code>，这个问题的根源很明显是memcpy函数调用有问题</p><p><img lazyload="" alt="image-20220424230425270" data-src="https://img1.musnow.top/i/23/02/202204242304381.png"></p><p>一看，哭笑不得，写了俩sizeof，魔怔了属于是</p><p><img lazyload="" alt="image-20220424230621551" data-src="https://img1.musnow.top/i/23/02/202204242306592.png"></p><p>修改之后，没问题啦！</p><p><img lazyload="" alt="image-20220424230718378" data-src="https://img1.musnow.top/i/23/02/202204242307428.png"></p><hr><h2 id="4-2递归源码"><a href="#4-2递归源码" class="headerlink" title="4.2递归源码"></a>4.2递归源码</h2><p>这里给出最终的源码，一些地方写了注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_代表这是子函数</span></span><br><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span>* a,<span class="type">int</span>* tmp, <span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end){</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	_MergeSort(a, tmp, begin, mid);</span><br><span class="line">	_MergeSort(a, tmp, mid+<span class="number">1</span> , end);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf("归并[%d,%d][%d,%d]\n", begin, mid, mid+1, end);</span></span><br><span class="line">	<span class="type">int</span> begin1 = begin, end1 = mid ;</span><br><span class="line">	<span class="type">int</span> begin2 = mid+<span class="number">1</span> , end2 = end;</span><br><span class="line">	<span class="type">int</span> cur = begin;</span><br><span class="line">	<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//取小的放到新数组中</span></span><br><span class="line">		<span class="keyword">if</span> (a[begin1] &lt; a[begin2]) {</span><br><span class="line">			tmp[cur++] = a[begin1++];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			tmp[cur++] = a[begin2++];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一个循环结束，并不代表归并完毕，可能只有一个数组的数据跑完了</span></span><br><span class="line">	<span class="comment">//我们需要将另外一个数组的数据全部拷贝到tmp中（因为剩下的的数据已经有序）</span></span><br><span class="line">	<span class="keyword">while</span> (begin1 &lt;= end1) {</span><br><span class="line">		tmp[cur++] = a[begin1++];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (begin2 &lt;= end2) {</span><br><span class="line">		tmp[cur++] = a[begin2++];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(a+begin,tmp + begin, ((end - begin +<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>)));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span>(tmp==<span class="literal">NULL</span>){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	_MergeSort(a, tmp, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">	tmp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="4-3非递归实现"><a href="#4-3非递归实现" class="headerlink" title="4.3非递归实现"></a>4.3非递归实现</h2><p>归并排序的非递归无法用<strong>栈</strong>来实现，因为我们不能把之前的<strong>大区间</strong>全给出栈了，因为这些区域还需要在最后重新进行归并！</p><ul><li>利用循环来控制不同的区间，由小到大，直到<code>gap=n</code>跳出循环</li><li>gap是归并数据的个数，gap=1代表1个数归并，gap=2代表两两归并</li></ul><p><img lazyload="" alt="image-20220425093418208" data-src="https://img1.musnow.top/i/23/02/202204250934315.png"></p><p>根据上面的思路，我们可以写出下面的范围循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 间距为gap是一组，两两归并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//i+gap是个数，再-1是下标</span></span><br><span class="line">        <span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//i+gap到i+2gap是个数，再-1是下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打印调试大法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"归并[%d,%d][%d,%d] -- gap=%d\n"</span>, begin1, end1, begin2, end2, gap);</span><br><span class="line">    }</span><br><span class="line">    gap *= <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>跑一遍之前的测试用例，发现能搞定！这不就完事了吗？</p><p><img lazyload="" alt="image-20220425094754302" data-src="https://img1.musnow.top/i/23/02/202204250947362.png"></p><p>并没有！这里gap的操作都是<code>*2</code>，而且我们给的数组是偶数个，正好对的上</p><p>如果我们再加一个数呢？程序打印出了每一层的递归区间，但是没有打印出最终的结果——因为这里在最后<code>free</code>的时候发现了<strong>数组越界访问</strong></p><blockquote><p>小知识，数组越界一般都是在free的时候检查到的</p><p><img lazyload="" alt="image-20220425101224451" data-src="https://img1.musnow.top/i/23/02/202204251012497.png"></p></blockquote><p><img lazyload="" alt="image-20220425095240283" data-src="https://img1.musnow.top/i/23/02/202204250952347.png"></p><p><img lazyload="" alt="image-20220425095947193" data-src="https://img1.musnow.top/i/23/02/202204250959296.png"></p><p>接下来要做的事就是控制下标区间，避免它越界</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>begin</th><th>end</th></tr></thead><tbody><tr><td>i</td><td>i+gap-1</td></tr><tr><td>i+gap</td><td>i+2*gap-1</td></tr></tbody></table><p>仔细分析过后，发现当<code>gap=2,i=8</code>的时候，就会出现+gap之后越界的情况</p><p><img lazyload="" alt="image-20220425100539742" data-src="https://img1.musnow.top/i/23/02/202204251005867.png"></p><p>而会出现越界情况的，不止有end2，end1和begin2都可能会出现</p><p>我们需要做的就是把越界的下标<strong>修正为不越界的</strong>下标</p><ul><li>end1越界，修正为不越界即可</li><li>begin2和end2都越界，修正为非法区间<code>begin2&gt;end2</code></li><li>begin2不越界，end2越界，修正end2即可</li></ul><p>修正下标后，可以看到程序已经正常排序出了序列</p><p>虽然打印出来的范围还是有越界的下标，但是这个是<code>begin&gt;end</code>的<strong>非法区间</strong>，不符合程序运行的条件，就不会产生越界</p><p><img lazyload="" alt="image-20220425101925149" data-src="https://img1.musnow.top/i/23/02/202204251019242.png"></p><h3 id="4-3-1-条件断点"><a href="#4-3-1-条件断点" class="headerlink" title="4.3.1 条件断点"></a>4.3.1 条件断点</h3><p>这里还有一个骚操作，比如我们已经知道了是8-9的下标越界，这样我们就可以设置一个<strong>断点</strong>，来直接F5跳到那个情况，而不需要<strong>疯狂按F10</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件断点，用于调试</span></span><br><span class="line"><span class="keyword">if</span> (begin1 == <span class="number">8</span> &amp;&amp; end1 == <span class="number">9</span> &amp;&amp; begin2 == <span class="number">10</span> &amp;&amp; end2 == <span class="number">11</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><hr><p>这样我们的非递归实现也搞定啦！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">	<span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// 间距为gap是一组，两两归并</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap)</span><br><span class="line">		{</span><br><span class="line">			<span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;<span class="comment">//i+gap是个数，-1是下标</span></span><br><span class="line">			<span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;<span class="comment">//i+gap到i+2gap是个数，-1是下标</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (end1 &gt;= n) {</span><br><span class="line">				end1 = n - <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(begin2&gt;=n){</span><br><span class="line">				begin2 = n;</span><br><span class="line">				end2 = n - <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (begin2 &lt; n &amp;&amp; end2 &gt;= n) {</span><br><span class="line">				end2 = n - <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="comment">//printf("归并[%d,%d][%d,%d] -- gap=%d\n", begin1, end1, begin2, end2, gap);</span></span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> index = i;</span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">					tmp[index++] = a[begin1++];</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					tmp[index++] = a[begin2++];</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">				tmp[index++] = a[begin1++];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">				tmp[index++] = a[begin2++];</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">memcpy</span>(a, tmp, n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">		gap *= <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="4-4归并排序的时间-x2F-空间复杂度"><a href="#4-4归并排序的时间-x2F-空间复杂度" class="headerlink" title="4.4归并排序的时间/空间复杂度"></a>4.4归并排序的时间/空间复杂度</h2><ul><li>时间复杂度：O(N*logN)</li><li>空间复杂度：O(N)，创建数组的消耗</li></ul><hr><h1 id="5-计数排序"><a href="#5-计数排序" class="headerlink" title="5.计数排序"></a>5.计数排序</h1><p>计数排序的<strong>基本思路</strong>：利用数组的下标作为映射，遍历到x，在数组的x下标处++一次。最后再依照下标顺序将之前遍历到的数倒出来，就形成了正序序列。</p><p>我在<strong>网上</strong>找来了一个很棒的动图（这个好像在很多博客里面都有😂）</p><p><img lazyload="" alt="计数排序" data-src="https://img1.musnow.top/i/23/02/202204251026710.gif"></p><blockquote><p>这个排序的思路就不难了，但有一点我们可以优化一下</p></blockquote><p>假设我们的序列是从300开始，而不是从0开始，那么开辟一个301个数的数组显然会浪费300之前的下标（因为并没有值）</p><p>这时候我们可以找出数组的范围，开辟一个对应范围长度的数组，再利用相对映射的方式，来进行计数</p><p><img lazyload="" alt="image-20220425103313697" data-src="https://img1.musnow.top/i/23/02/202204251033755.png"></p><p>最后的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CountSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> min = a[<span class="number">0</span>], max = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">			min = a[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">			max = a[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>* count = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * range);</span><br><span class="line">	assert(count);</span><br><span class="line">	<span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * range);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	{</span><br><span class="line">		count[a[i] - min]++;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> (count[i]--)</span><br><span class="line">		{</span><br><span class="line">			a[j++] = i + min;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="5-1计数排序的特性"><a href="#5-1计数排序的特性" class="headerlink" title="5.1计数排序的特性"></a>5.1计数排序的特性</h2><ul><li>时间复杂度：O(range+N)</li><li>空间复杂度：O(range)</li></ul><p>计数排序适用于范围集中的数，不然会产生很大的空间浪费</p><p>计数排序可以排序<strong>带负数</strong>的序列，同样是通过映射的方式</p><p>但是计数排序只能<strong>排序整型数据</strong>，浮点类型是搞不定的</p><hr><p>看到这里，我们的八大排序就已经讲解完毕啦！</p><p>不知道我讲解的够不够清楚呢？</p><p><img lazyload="" alt="QQ图片20220425092846" data-src="https://img1.musnow.top/i/23/02/202204251038074.jpg"></p><p>下面还有一个小点，就是关于排序算法的<strong>稳定性</strong></p><h1 id="6-排序算法的稳定性"><a href="#6-排序算法的稳定性" class="headerlink" title="6.排序算法的稳定性"></a>6.排序算法的稳定性</h1><p>估计很多人和我一样，都对这个“稳定性”有错误的理解</p><p>我本来以为，稳定性代表的是排序算法的<strong>时间波动</strong>大不大</p><p>实际上的稳定性，是算法对于<strong>某一个数</strong>的处理好不好</p><p>比如下图，假设大家在考试，从上到下依次是交卷的顺序，我们发现王舞和李四的成绩相同，但是李四先交的卷。对于评判来说，当然是<code>先交卷且分高的</code>同学牛逼一点</p><p>所以依照分数排序的时候，我们应该把李四排在王舞之前</p><p><img lazyload="" alt="image-20220425104144768" data-src="https://img1.musnow.top/i/23/02/202204251041817.png"></p><p>但有些算法在排序的时候，就做不到这一点</p><p>这里对<strong>直接选择排序</strong>做一个简单的解释</p><p><img lazyload="" alt="image-20220425104914317" data-src="https://img1.musnow.top/i/23/02/202204251049368.png"></p><p>因为两个3的位置调换，就导致排序不够稳定</p><p>实际上，所有需要进行<strong>选择交换</strong>的排序都不够稳定</p><blockquote><p>但是冒泡排序在交换的时候是严格保证大的数在后头，相等的数不交换的思路，所以冒泡排序是稳定的</p></blockquote><h2 id="6-1-稳定性表格"><a href="#6-1-稳定性表格" class="headerlink" title="6.1 稳定性表格"></a>6.1 稳定性表格</h2><table><thead><tr><th>排序算法</th><th>稳定性</th><th>排序算法</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入</td><td>稳定</td><td>希尔</td><td>不稳定</td></tr><tr><td>冒泡</td><td>稳定</td><td>直接选择</td><td>不稳定</td></tr><tr><td>归并排序</td><td>稳定</td><td>堆排序</td><td>不稳定</td></tr><tr><td>-</td><td>-</td><td>快速排序</td><td>不稳定</td></tr><tr><td>-</td><td>-</td><td>计数排序</td><td>不稳定</td></tr></tbody></table><h2 id="6-2-时间复杂度表格"><a href="#6-2-时间复杂度表格" class="headerlink" title="6.2 时间复杂度表格"></a>6.2 时间复杂度表格</h2><p><img lazyload="" alt="image" data-src="/../../img/Pasted%20image%2020221227201606.png"></p><h1 id="7-利用clock函数查看排序耗时"><a href="#7-利用clock函数查看排序耗时" class="headerlink" title="7.利用clock函数查看排序耗时"></a>7.利用clock函数查看排序耗时</h1><p>排序算法写完后，我们可以通过调用clock函数来查看每一个排序的耗时</p><p>先利用<code>srand和time</code>函数来创建随机数数组，在调用每一个函数，来查看它们排序的耗时</p><p></p><p>由于代码过长，这里只给出某一个排序的计时代码，其他就<code>CV</code>一下就OK了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span>* a1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">{</span><br><span class="line">	a1[i] = rand();<span class="comment">//生成随机数 数组</span></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> begin1 = clock();<span class="comment">//读取系统时钟</span></span><br><span class="line">InsertSort(a1, N);</span><br><span class="line"><span class="type">int</span> end1 = clock();<span class="comment">//再读取系统时钟</span></span><br><span class="line"><span class="comment">//二者相减得出该函数运行时长</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InsertSort:%d\n"</span>, end1 - begin1);</span><br><span class="line"><span class="built_in">free</span>(a1);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img lazyload="" alt="image-20220425110430139" data-src="https://img1.musnow.top/i/23/02/202204251104224.png"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到这里，排序的绝大数知识点就讲解完毕啦！</p><p>本篇博客画了很多图，还挺不容易的，还请大家点赞支持一下！</p><p><img lazyload="" alt="image-20220425105301408" data-src="https://img1.musnow.top/i/23/02/202204251053471.png"></p><p>特别是那两个看起来很简单的动图，实际上<strong>麻烦</strong>的很</p><p><img lazyload="" alt="image-20220425105414115" data-src="https://img1.musnow.top/i/23/02/202204251054302.png"></p><p>球球了，点个赞呐！</p><p><img lazyload="" alt="QQ图片20220416195218" data-src="https://img1.musnow.top/i/23/02/202204251055973.jpg"></p><p></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【C语言】八大排序算法（带图详解）</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2022-04-25 11:13:49</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2022/04/25/note_data_structure/12排序算法/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/C%E8%AF%AD%E8%A8%80/">#C语言</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E6%8E%92%E5%BA%8F/">#排序</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/04/29/note_cpp/1%E5%88%9D%E8%AF%86Cpp/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【C++】凝视C++的第一眼</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/04/21/raspberry/%E5%AE%9E%E9%AA%8C12-PCF8591%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%99%A8/"><span class="title flex-center"><span class="post-nav-title-item">【树莓派】实验12-PCF8591模数转换器</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true'
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">1.插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5"><span class="nav-text">1.1直接插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">1.2希尔排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">2.选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9"><span class="nav-text">2.1直接选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">2.2堆排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-text">3.交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E5%92%95%E5%99%9C%E5%92%95%E5%99%9C%E6%8E%92%E5%BA%8F"><span class="nav-text">3.1咕噜咕噜排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">3.2快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-Hoare%E6%B3%95"><span class="nav-text">3.2.1 Hoare法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5"><span class="nav-text">两种极端情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E6%8C%96%E5%9D%91%E6%B3%95"><span class="nav-text">3.2.2 挖坑法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-text">3.2.3 前后指针法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5"><span class="nav-text">优化极端情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4%E5%BF%AB%E6%8E%92%E7%9A%84%E6%97%B6%E9%97%B4-x2F-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">3.2.4快排的时间&#x2F;空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3%E5%BF%AB%E6%8E%92%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.3快排非递归实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">4.归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E6%89%93%E5%8D%B0printf%E8%B0%83%E8%AF%95%E5%A4%A7%E6%B3%95"><span class="nav-text">4.1打印printf调试大法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2%E9%80%92%E5%BD%92%E6%BA%90%E7%A0%81"><span class="nav-text">4.2递归源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.3非递归实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="nav-text">4.3.1 条件断点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4-x2F-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">4.4归并排序的时间&#x2F;空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">5.计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">5.1计数排序的特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-text">6.排序算法的稳定性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E7%A8%B3%E5%AE%9A%E6%80%A7%E8%A1%A8%E6%A0%BC"><span class="nav-text">6.1 稳定性表格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8%E6%A0%BC"><span class="nav-text">6.2 时间复杂度表格</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%88%A9%E7%94%A8clock%E5%87%BD%E6%95%B0%E6%9F%A5%E7%9C%8B%E6%8E%92%E5%BA%8F%E8%80%97%E6%97%B6"><span class="nav-text">7.利用clock函数查看排序耗时</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-text">结语</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://musnow.top" target="_blank"><img src="https://img.shields.io/badge/%E4%B8%BB%E7%AB%99-%E7%82%B9%E6%88%91-blueviolet" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>