<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><script>"https://blog.musnow.top"!=window.location.href&&window.alert("您当前访问的是镜像站点，主站为 https://blog.musnow.top")</script><title>【C++】函数重载的形式及其背后原理 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【C++】函数重载的形式及其背后原理</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2022-04-29 23:29:21</span> <span class="mobile">2022-04-29 23:29</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-03-11 19:25:36</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E9%81%87%E8%A7%81C/">遇见C++</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/C/">C++</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>3.5k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>常言道：<strong>中国有俩球，谁都赢不了</strong>！这句话在不同的语境下有不同的意思</p><p>C++中，函数支持在同一作用域下声明几个功能类似的<strong>同名函数</strong>，但需要遵守以下规定……</p><span id="more"></span><p>C++中，函数支持在同一作用域下声明几个功能类似的<strong>同名函数</strong>，但需要遵守以下规定</p><ul><li>形参个数不同</li><li>形参类型不同</li><li>形参类型的顺序不同</li></ul><p>编译器会在调用这些同名函数的时候，根据具体情况来选择不同的函数</p><hr><p>[TOC]</p><h1 id="1-函数重载的样式"><a href="#1-函数重载的样式" class="headerlink" title="1.函数重载的样式"></a>1.函数重载的样式</h1><blockquote><p>上面提到了函数重载的3个规定，下面让我们来用具体示例认识一下它们</p></blockquote><p>假设我们需要一个A+B的代码，如果每次都需要<strong>根据不同数据类型来写不同的函数</strong>去实现这个功能，未免有点太过繁杂。</p><p>在C++中，只需要修改函数的参数，即构成了函数重载，编译器就会自己选择对应的函数进行相加操作</p><h2 id="1-1形参类型不同"><a href="#1-1形参类型不同" class="headerlink" title="1.1形参类型不同"></a>1.1形参类型不同</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> rb)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Add</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt;endl;</span><br><span class="line">     cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">10L</span>, <span class="number">20L</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">10.0</span>, <span class="number">20.0</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204291851097.png" alt="image-20220429185145046"></p><h2 id="1-2形参个数不同"><a href="#1-2形参个数不同" class="headerlink" title="1.2形参个数不同"></a>1.2形参个数不同</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//个数不同</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204291853519.png" alt="image-20220429185334477"></p><h2 id="1-3形参类型顺序不同"><a href="#1-3形参类型顺序不同" class="headerlink" title="1.3形参类型顺序不同"></a>1.3形参类型顺序不同</h2><p>这里的顺序并不是a和b的顺序哈！只把a和b换一个位置是不构成函数重载的</p><p>这里指的是先传int再传double，和先传double再传int的<strong>两种函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参类型的顺序不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>  a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">double</span>  a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204291857813.png" alt="image-20220429185748785"></p><hr><h2 id="1-4非函数重载"><a href="#1-4非函数重载" class="headerlink" title="1.4非函数重载"></a>1.4非函数重载</h2><p>只修改函数的<strong>返回值类型</strong>是不构成函数重载的</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204291859666.png" alt="image-20220429185949622"></p><hr><h1 id="2-C-实现函数重载的原理"><a href="#2-C-实现函数重载的原理" class="headerlink" title="2.C++实现函数重载的原理"></a>2.C++实现函数重载的原理</h1><blockquote><p>在看后续内容之前，建议先复习一下<strong>程序运行的4个阶段</strong>，以便理解后面的操作👉<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123227200">传送门<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>这里使用我的树莓派在Linux系统下给大家演示一下函数重载背后的样式</p><p>首先我创建了3个文件，<code>test.c Add.h Add.cpp</code>，文件的内容一并给出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Add.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">Add</span>(<span class="number">1.5</span>,<span class="number">2.5</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们使用<code>gcc</code>这个C语言编译器编译程序的时候，出现了很多报错，因为C语言是不支持函数重载的</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204291942181.png" alt="image-20220429194238128"></p><h2 id="2-1编译生成可执行文件"><a href="#2-1编译生成可执行文件" class="headerlink" title="2.1编译生成可执行文件"></a>2.1编译生成可执行文件</h2><p>需要使用<code>g++</code>编译器来编译这个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp add.cpp -o Tcpp</span><br></pre></td></tr></table></figure><p>执行<code>./Tcpp</code>运行该函数，可以看到正常输出了相加后的结果</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204291945286.png" alt="image-20220429194548261"></p><hr><h2 id="2-2查看汇编"><a href="#2-2查看汇编" class="headerlink" title="2.2查看汇编"></a>2.2查看汇编</h2><p>接下来我们要使用另外一个命令来查看可执行文件Tcpp的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -S Tcpp</span><br></pre></td></tr></table></figure><p>在这里面可以找到我们两个Add函数的位置，可见它们的地址是不同的，并且一个函数名为<code>_Z3Addii</code>，另外一个是<code>_Z3Adddd</code></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204291947915.png" alt="image-20220429194758864"></p><h3 id="2-2-1汇编函数名的含义"><a href="#2-2-1汇编函数名的含义" class="headerlink" title="2.2.1汇编函数名的含义"></a>2.2.1汇编函数名的含义</h3><p>这两个汇编代码中的函数名，其实包含了<strong>函数名、函数参数</strong>这两个信息</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204291951982.png" alt="image-20220429195153935"></p><p>拆分了其中一个，那么另外一个<code>_Z3Adddd</code>的意思就很明确了，末尾的两个d代表函数参数是<code>(double,double)</code></p><hr><p>我们可以创建另外一个文件，查看它的汇编代码，进一步确认命名规则（其实这个命名规则是反推得出的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序后，执行<code>objdump -S</code>，可以看到f函数被命名为<code>_Z1fii</code>，代表函数名长度为1，原本函数名f，和函数参数<code>(int ,int)</code></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204291958005.png" alt="image-20220429195810955"></p><p>现在我们知道了汇编中这个函数名的命名规则，那它和C++支持函数重载有什么关系呢？</p><hr><p>在这之前，我们还需看看<strong>c语言</strong>程序，汇编代码中函数又是怎么命名的</p><h3 id="2-2-2查看C语言汇编"><a href="#2-2-2查看C语言汇编" class="headerlink" title="2.2.2查看C语言汇编"></a>2.2.2查看C语言汇编</h3><p>这里我把之前的函数修改成了C语言的样式，<code>gcc</code>编译后再来看看它的汇编</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292002113.png" alt="image-20220429200244080"></p><p>然后你就会发现，C语言汇编代码中的函数名，就是函数原本的名字<code>f</code>，没有添加任何东西！</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292003036.png" alt="image-20220429200356998"></p><h2 id="2-3得出结论"><a href="#2-3得出结论" class="headerlink" title="2.3得出结论"></a>2.3得出结论</h2><p>看到这里，你能猜出来为什么C++支持函数汇编，而C语言不支持了吗？</p><blockquote><p><font color="Orange">没错</font>！那是因为C++的汇编代码中，<strong>函数名还保存了函数的形参类型</strong>，而C语言中并没有保存，自然无法区分两个函数</p></blockquote><p>这个汇编函数名的命名方式也能解释C++函数重载的3种样式</p><p>假设我们有一个fun函数，那么我们可以推断出它的<strong>汇编函数名</strong></p><table><thead><tr><th>类型</th><th>形式一</th><th>形式二</th></tr></thead><tbody><tr><td>形参个数不同</td><td>_Z3funii(int,int)</td><td>_Z3funiii(int,int,int)</td></tr><tr><td>形参类型不同</td><td>_Z3funii(int,int)</td><td>_Z3fundd(double,double)</td></tr><tr><td>形参类型顺序不同</td><td>_Z3funid(int,double)</td><td>_Z3fundi(double,int)</td></tr></tbody></table><p>同时也能解释为何只修改<strong>函数返回值类型</strong>是不构成重载的，因为汇编代码中没有保存函数的返回值</p><hr><p>正因为C++在汇编处理中能够以这种命名方式来区分同名的不同函数，并给它们赋予不同的<strong>地址</strong>，<strong>编译器在链接符号表</strong>的时候，才能通过<strong>函数传参的不同</strong>找到它需要调用的<strong>对应函数的地址</strong></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292021872.png" alt="image-20220429202120839"></p><p>在main函数的汇编中，也能找到对应函数的<strong>调用操作</strong></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292022889.png" alt="image-20220429202215847"></p><hr><h1 id="3-语法extern”C”"><a href="#3-语法extern”C”" class="headerlink" title="3.语法extern”C”"></a>3.语法extern”C”</h1><p>因为C++汇编处理中对函数名的修饰和C语言不同，所以C++中有这么一个语法，专门用来告诉编译器，某某某函数要用<strong>C语言的规则来修饰</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="built_in">fun</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用这种方式修饰的<code>fun</code>函数，在汇编中就<strong>只有函数名</strong>，而不是C++形式原本的<code>_Z3funii</code></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292108727.png" alt="image-20220429210808692"></p><p>这样<strong>C语言</strong>的代码就可以<strong>链接</strong>这种方式写的<strong>C++静态库</strong>（前提是这个静态库中没有函数重载和C++的语法）</p><blockquote><p><span id="jump">然后我</span>就想问：这和C的静态库有啥区别……</p></blockquote><p>当然有了！一个库里面有很多很多代码，总有些函数接口是C语言也能支持的嘛，这些接口就用C语言的方式来修饰，这样C语言也能调用了，不一举两得？</p><h2 id="3-1C-调用C语言静态库"><a href="#3-1C-调用C语言静态库" class="headerlink" title="3.1C++调用C语言静态库"></a>3.1C++调用C语言静态库</h2><p>除了更改修饰方式外，<code>extern&quot;C&quot;</code>还用于让C++程序来调用C语言写的库</p><blockquote><p>比如树莓派要用到的<code>wiringPi库</code>，它是用C语言实现的，在编程为静态库后，里面汇编对函数的修饰就固定了，并没有C++下的<code>_Z1...</code>和参数类型修饰。</p></blockquote><p>这时候如果用C++直接来调用这个函数，C++程序是找不到对应的函数的。在这种情况下，<code>extern&quot;C&quot;</code>的作用就是让编译器以<strong>C语言的方式去寻找对应函数</strong></p><p>比如下图的代码，调用了<code>wiringPi</code>库里面的<strong>初始化函数</strong>，是最常用的一个函数</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292152191.png" alt="image-20220429215242153"></p><p>我们用G++编译器编译这个代码，就会发现，欸tnnd怎么没有报错啊？</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292153358.png" alt="image-20220429215353327"></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292155647.jpg" alt="QQ图片20220419102802"></p><p>其实吧，库函数的开发者早就想到了这一点。在平日编程中，也有办法来解决这个问题——那就是用<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123412732">条件编译<i class="fas fa-external-link-alt"></i></a>指令！</p><h2 id="3-2用条件编译解决问题"><a href="#3-2用条件编译解决问题" class="headerlink" title="3.2用条件编译解决问题"></a>3.2用条件编译解决问题</h2><p>前情提要：在C++的编译环境中有一个预定义符号<code>__cplusplus</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt; __cplusplus &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>在linux环境下，编译器打印出了以下数字</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292200444.png" alt="image-20220429220017411"></p><p>而在windows的VS2019编译器下打印了下面的数字</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292203717.png" alt="image-20220429220319680"></p><p>咱先不管这个数字是啥意思（看起来是一个日期），至少在C语言中是没有这个预定义符号的</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292205044.png" alt="image-20220429220529989"></p><p>这样我们就可以利用这个预定义符号，假设是C++环境，就放出<code>extern&quot;C&quot;</code>来声明函数，如果是C语言环境，就不用<code>extern&quot;C&quot;</code></p><p>方法一：批量extern</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line">    <span class="comment">//这里可以放多个函数的声明</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>方法二：define一个符号为<code>extern&quot;C&quot;</code>，然后在每一个定义前面单独加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> EXTERN extern <span class="string">&quot;C&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> EXTERN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function">EXTERN <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function">EXTERN <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//……</span></span><br></pre></td></tr></table></figure><p>这样不管是C语言，还是C++的程序，都能正常建立符号表，找到对应的函数</p><blockquote><p>Github：<a class="link" target="_blank" rel="noopener" href="https://github.com/WiringPi/WiringPi/blob/master/wiringPi">wiringPi库源码仓库<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>可以看到，大佬当初编写wiringPi库的时候就用了这个方法，这也是为什么在我的树莓派上，G++编译器也能直接识别出wiringPi库的原因</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292212797.png" alt="image-20220429221236754"></p><blockquote><p>在找这部分资料的时候，还发现了一个小故事：<code>wiringPi</code>库现在已经不官方开源了。因为有很多初学者拿代码去烦原作者（于是作者在官网上写了“这不是给初学者玩的”告示）还有很多人倒卖他写的库，所以他就在最后一次公开后，停止了官方开源</p></blockquote><h2 id="3-3C语言调用C-的库"><a href="#3-3C语言调用C-的库" class="headerlink" title="3.3C语言调用C++的库"></a>3.3C语言调用C++的库</h2><p>同理，有的时候我们也会用C语言来调用C++的库</p><p><font color="Red">但是！</font>就如我<a href="#jump">上头</a>说的，这个库里面，可以供C语言调用的函数<strong>不能有C++的语法和函数重载</strong></p><blockquote><p>Github：<a class="link" target="_blank" rel="noopener" href="https://github.com/google/tcmalloc">TcMalloc代码仓库<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>比较好的一个例子是<strong>谷歌</strong>的tcmalloc库：此存储库包含TCMalloc的C++代码。 TCMalloc是谷歌对C的malloc（）和C++运算符的定制实现，用于在我们的C和C++代码中分配内存。TCMalloc是一个快速的多线程malloc实现。</p><hr><p>整个库的函数入口是在<code>tcmalloc.cc</code>中定义的，打开它可以看到，虽然大部分代码都是用C++实现的，但是少部分函数接口因为没有C++的语法，所以使用了<code>extern &quot;C&quot;</code>让C语言也支持它</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292226945.png" alt="image-20220429222658895"></p><p>但是我还发现，有些带有C++的函数接口，也用了<code>extern &quot;C&quot;</code>，那是不是我们上面的结论错了呢？</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292233455.png" alt="image-20220429223300422"></p><p><strong>实践出真知</strong>！</p><h1 id="4自己整一个静态库"><a href="#4自己整一个静态库" class="headerlink" title="4自己整一个静态库"></a>4自己整一个静态库</h1><h2 id="4-1C-调用C语言静态库"><a href="#4-1C-调用C语言静态库" class="headerlink" title="4.1C++调用C语言静态库"></a>4.1C++调用C语言静态库</h2><p>首先创建一个VS的空项目，把我之前写的C语言单链表代码放进去</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292238977.png" alt="image-20220429223816858"></p><p>右键这里的项目名称-属性，然后在<code>配置属性-常规-配置类型</code>中，把项目改成静态库</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292240434.png" alt="image-20220429224022321"></p><p>修改完毕后，<strong>编译程序</strong>，你会发现debug目录下多了静态库文件<code>.lib</code></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292256255.png" alt="image-20220429225627216"></p><p>然后在我们当前的C++项目中，修改<code>项目属性-链接器-常规-附加库目录</code>和<code>项目属性-链接器-输入-附加依赖项</code></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292254355.png" alt="image-20220429225404293"></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292254375.png" alt="image-20220429225441335"></p><p>最后以<code>#include &quot;../Slist/Slinklist.h&quot;</code>的形式引用静态库</p><p>你会发现直接引用是会报错的，因为这个单链表的库是用C语言写的，我们没有使用<code>extern &quot;C&quot;</code>来引用</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292242444.png" alt="image-20220429224245378"></p><p>使用了之后，程序正常调用了C语言的库，并打印出了结果！</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292253205.png" alt="image-20220429225307159"></p><h2 id="4-2C语言调用C-静态库"><a href="#4-2C语言调用C-静态库" class="headerlink" title="4.2C语言调用C++静态库"></a>4.2C语言调用C++静态库</h2><p>接着，我们再写一个简单的C++程序，用上面同样的方法编译成静态库，并在C语言的项目中调用它</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292307830.png" alt="image-20220429230736776"></p><p>可以看到，这个<strong>没有任何C++语法</strong>的C++静态库被正常调用并打印出了结果</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292306181.png" alt="image-20220429230658140"></p><p>如果我们不使用<code>extern &quot;C&quot;</code>，C语言项目就无法正常使用该静态库</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292309401.png" alt="image-20220429230922301"></p><p>而当我们在C++的静态库中包含C++的头文件后，C语言项目中也报错了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>光是链接库函数头文件和命名空间就报错了，那不能使用带C++语法的函数也是板上钉钉的事情了！</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292310606.png" alt="image-20220429231028543"></p><p>而在具有<code>extern &quot;C&quot;</code>属性的路径中，也不能包含函数重载，VS会报错</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292313484.png" alt="image-20220429231321433"></p><p>在头文件中定义自己的命名空间，在C语言项目中也是无法通过编译的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muxue &#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muxue;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292316660.png" alt="image-20220429231603592"></p><p>现在可以确认我们的结论，只有不包含任何C++的语法和函数重载的C++静态库，才能正常被C语言项目调用！</p><h3 id="勘误，上述结论错误"><a href="#勘误，上述结论错误" class="headerlink" title="勘误，上述结论错误"></a>勘误，上述结论错误</h3><blockquote><p>22-05-06，在同学的提示下，发现了这个错误</p></blockquote><p>之前C调用C++的方式有问题，因为我是直接把C++的语法放到了<strong>头文件</strong>中，在展开的时候C程序编译会报错</p><p>但如果把C++的语法放入cpp文件，头文件中不包含的话，就不会报错了！</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205061528173.png" alt="image-20220506152800090"></p><p>可以看到在最后的测试项目中，C语言程序成功调用了c++的语法并正确输出了内容</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205061529883.png" alt="image-20220506152923834"></p><p>这也能解释我关于谷歌TCmalloc库的疑惑了，看来C和C++真的是互通有无啊！</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇笔记详细解释了C++中函数重载的类型，以及背后的实现原理。</p><p>这个博客花了我整整4小时的时间，感觉很充实！</p><blockquote><p>所以求个赞不过分吧！谢谢大家！</p></blockquote><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202204292324467.jpg" alt="QQ图片20220424132540"></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【C++】函数重载的形式及其背后原理</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2022-04-29 23:29:21</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2022/04/29/cpp/2函数重载/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/C/">#C++</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/05/01/tools/6md%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【MD】Markdown如何插入视频、mp3和gif</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/04/29/cpp/1%E5%88%9D%E8%AF%86Cpp/"><span class="title flex-center"><span class="post-nav-title-item">【C++】凝视C++的第一眼</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true',
              requiredMeta: ['nick','mail'] 
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A0%B7%E5%BC%8F"><span class="nav-text">1.函数重载的样式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E5%BD%A2%E5%8F%82%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C"><span class="nav-text">1.1形参类型不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E5%BD%A2%E5%8F%82%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%90%8C"><span class="nav-text">1.2形参个数不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E5%BD%A2%E5%8F%82%E7%B1%BB%E5%9E%8B%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C"><span class="nav-text">1.3形参类型顺序不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4%E9%9D%9E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-text">1.4非函数重载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-C-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">2.C++实现函数重载的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-text">2.1编译生成可执行文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96"><span class="nav-text">2.2查看汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1%E6%B1%87%E7%BC%96%E5%87%BD%E6%95%B0%E5%90%8D%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-text">2.2.1汇编函数名的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2%E6%9F%A5%E7%9C%8BC%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96"><span class="nav-text">2.2.2查看C语言汇编</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E5%BE%97%E5%87%BA%E7%BB%93%E8%AE%BA"><span class="nav-text">2.3得出结论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E8%AF%AD%E6%B3%95extern%E2%80%9DC%E2%80%9D"><span class="nav-text">3.语法extern”C”</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1C-%E8%B0%83%E7%94%A8C%E8%AF%AD%E8%A8%80%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-text">3.1C++调用C语言静态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E7%94%A8%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-text">3.2用条件编译解决问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3C%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8C-%E7%9A%84%E5%BA%93"><span class="nav-text">3.3C语言调用C++的库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4%E8%87%AA%E5%B7%B1%E6%95%B4%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-text">4自己整一个静态库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1C-%E8%B0%83%E7%94%A8C%E8%AF%AD%E8%A8%80%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-text">4.1C++调用C语言静态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2C%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8C-%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-text">4.2C语言调用C++静态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8B%98%E8%AF%AF%EF%BC%8C%E4%B8%8A%E8%BF%B0%E7%BB%93%E8%AE%BA%E9%94%99%E8%AF%AF"><span class="nav-text">勘误，上述结论错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-text">结语</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/about">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_3_tp.gif" height="20px"> </a><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>