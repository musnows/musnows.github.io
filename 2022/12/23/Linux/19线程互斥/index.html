<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><title>【Linux】线程概念 | 互斥 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【Linux】线程概念 | 互斥</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2022-12-23 16:30:16</span> <span class="mobile">2022-12-23 16:30</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-03-11 19:25:36</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E7%8E%A9%E4%B8%8ALinux/">玩上Linux</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>11.2k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>千呼万唤始出来，终于到多线程方面的学习了！</p><span id="more"></span><blockquote><p>所用系统<code>Centos7.6</code> 本文的源码👉<a class="link" target="_blank" rel="noopener" href="https://gitee.com/musnow/raspberry-practice/tree/master/code/22-12-15_pthread">【传送门】<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>[TOC]</p><h1 id="1-线程的概念"><a href="#1-线程的概念" class="headerlink" title="1.线程的概念"></a>1.线程的概念</h1><p>在之前的linux学习中，已经接触过了进程的概念，进程由一个<code>task_struct</code>结构体在操作系统中进行描述，CPU在执行的时候，会依照进程时间片进行轮询调度，让每一个进程的代码都得以推进，实现多个进程的同时运行</p><p>而线程，可以理解为是一种轻量化的进程，每一个进程都可以创建多个线程，并行执行不同的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程:线程 = 1:N</span><br></pre></td></tr></table></figure><p>在之前的多进程操作中，我们使用<code>fork</code>接口创建子进程，通过<code>if/else</code>语句判断，实现对特定执行流的划分</p><ul><li>创建子进程时，需要拷贝一份<code>task_struct/mm_struct</code>并创建页表</li><li>当子进程修改了一部分变量，会发生<strong>写时拷贝</strong>，修改页表在物理内存上的映射</li></ul><p>可以看到，当我们需要创建一个新进程的时候，操作系统需要做不少的工作</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212151917491.png" alt="image-20221215191721355"></p><h2 id="1-1-执行流"><a href="#1-1-执行流" class="headerlink" title="1.1 执行流"></a>1.1 执行流</h2><p>让我们康康执行流这一概念：</p><ul><li>单执行流进程：内部只有一个执行流的进程</li><li>多执行流进程：内部有多个执行流的进程</li></ul><p><code>进程=内核数据结构+代码和数据</code>，在内核视角中，进程是<code>承担分配系统资源的基本实体</code>（进程的基座属性）</p><ul><li>进程：向系统申请资源的基本单位（系统分配）</li><li>线程：系统调度的基本单位</li></ul><hr><h2 id="1-2-线程创建时做了什么？"><a href="#1-2-线程创建时做了什么？" class="headerlink" title="1.2 线程创建时做了什么？"></a>1.2 线程创建时做了什么？</h2><p>那线程的创建需要做什么呢？</p><blockquote><p>不同操作系统的实现不同，一般用<code>tcb</code>指代描述线程的结构体</p></blockquote><p>在linux中，没有进程和线程在概念上的区分，其以<strong>执行流</strong>为基础，线程只是简单的对<code>task_strcut</code>进行了二次封装；线程是在进程内部运行的执行流</p><ul><li>说人话：linux下的线程是<strong>用进程模拟</strong>的</li><li>换句话：linux下的进程也是一种线程，但是其<strong>只有一个执行流</strong></li><li>对于CPU而言，其看到的<code>task_struct</code>都是一个执行流</li></ul><p>而创建线程时也有说法，线程隶属于某一个进程下，并不是独立的子进程，所以不需要创建新的<code>mm_struct</code>和页表映射，创建的效率高于子进程。只需要将<code>task_struct</code>指向原有进程的<code>mm_struct</code>和页表即可。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212151923818.png" alt="image-20221215192345757"></p><p>同样的，CPU在推行多线程操作的时候，无须执行pcb切换，就能实现<strong>单进程多个线程操作</strong>的同时进行，执行效率变高！</p><blockquote><p>线程是一种<code>Light weight process 轻量级进程</code>，简称<code>LWP</code></p></blockquote><h2 id="1-3-内核源码中的体现"><a href="#1-3-内核源码中的体现" class="headerlink" title="1.3 内核源码中的体现"></a>1.3 内核源码中的体现</h2><p>在<code>task_strcut</code>结构体中，有这么一个字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br></pre></td></tr></table></figure><p>转到定义，其内部都是一些<strong>寄存器</strong>信息，用于标识这个线程的基本信息。这也是linux中没有<strong>单独</strong>实现线程tcb的体现，而是用<code>task_struct</code>来模拟的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Cached TLS descriptors: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>	<span class="title">tls_array</span>[<span class="title">GDT_ENTRY_TLS_ENTRIES</span>];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sp0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sysenter_cs;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		usersp;	<span class="comment">/* Copy from PDA */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		es;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		ds;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		fsindex;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		gsindex;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		ip;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		fs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		gs;</span><br><span class="line">	<span class="comment">/* Hardware debugging registers: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg1;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg2;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg3;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg6;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg7;</span><br><span class="line">	<span class="comment">/* Fault info: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		cr2;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		trap_no;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		error_code;</span><br><span class="line">	<span class="comment">/* floating point and extended processor state */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">thread_xstate</span>	*<span class="title">xstate</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="comment">/* Virtual 86 mode info */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm86_struct</span> __<span class="title">user</span> *<span class="title">vm86_info</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		screen_bitmap;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		v86flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		v86mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		saved_sp0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		saved_fs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		saved_gs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* IO permissions: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*io_bitmap_ptr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		iopl;</span><br><span class="line">	<span class="comment">/* Max allowed port in the bitmap, in bytes: */</span></span><br><span class="line">	<span class="type">unsigned</span>		io_bitmap_max;</span><br><span class="line"><span class="comment">/* MSR_IA32_DEBUGCTLMSR value to switch in if TIF_DEBUGCTLMSR is set.  */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	debugctlmsr;</span><br><span class="line">	<span class="comment">/* Debug Store context; see asm/ds.h */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ds_context</span>	*<span class="title">ds_ctx</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-4-线程的私有物"><a href="#1-4-线程的私有物" class="headerlink" title="1.4 线程的私有物"></a>1.4 线程的私有物</h2><p>我们知道，一个进程是完全独立的。但是线程并不是，因为线程只是进程的一个执行流分支，它从进程继承了绝大部分属性（也可以理解为是共享的）</p><ul><li>用户id和组id</li><li>进程id</li><li>进程工作目录</li><li>文件描述符表</li><li>信号的处理方式（如果进程有对某个信号进行自定义捕捉，那么线程会共用这个自定义捕捉）</li><li>和进程共用一个堆</li></ul><p>但线程也会有自己的<strong>私有物</strong>！</p><ul><li>线程id</li><li>线程独立的寄存器（因为线程也需要执行代码，有上下文数据）</li><li>栈（线程运行函数时也需要压栈和出栈，必须独立否则执行流会出问题）</li><li>errno（单独的报错信息）</li><li>信号屏蔽字（可以单独针对某个信号处理）</li><li>线程调度优先级</li></ul><h2 id="1-5-线程优缺点"><a href="#1-5-线程优缺点" class="headerlink" title="1.5 线程优缺点"></a>1.5 线程优缺点</h2><h3 id="1-5-1-缺点"><a href="#1-5-1-缺点" class="headerlink" title="1.5.1 缺点"></a>1.5.1 缺点</h3><ul><li><p>线程是缺乏保护的（不具备进程的<strong>独立性</strong>）这也被称为<code>健壮性</code>；线程的健壮性低</p><ul><li>当进程被停止的时候，其下线程也会被停止</li><li>当有一个线程出bug了，会让整个进程退出</li><li>多线程中的全局变量问题</li></ul></li><li><p>线程缺乏访问控制，在一个线程中调用某些操作系统的接口会影响整个进程</p></li><li><p>debug多线程较麻烦</p></li><li><p>如果同一个进程所用线程太多，可能会无法充分利用cpu性能而造成性能损失</p></li></ul><h3 id="1-5-2-优点"><a href="#1-5-2-优点" class="headerlink" title="1.5.2 优点"></a>1.5.2 优点</h3><ul><li>开辟的消耗低于进程，占用的资源低于进程</li><li>切换线程无须切换页表等结构，速度快</li><li>等待慢IO设备时，进程可以继续执行其他操作；将部分IO操作重叠，能让进程同时等待多个IO操作</li><li>能充分利用处理器的<strong>可并行数量</strong></li></ul><hr><h1 id="2-基础函数"><a href="#2-基础函数" class="headerlink" title="2.基础函数"></a>2.基础函数</h1><p>linux下提供了<code>pthread</code>库来实现线程操作</p><h2 id="2-1-pthread-create"><a href="#2-1-pthread-create" class="headerlink" title="2.1 pthread_create"></a>2.1 pthread_create</h2><p>人如其名，这个函数的作用是来创建新进程的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><ul><li>第一个参数是一个<strong>输出型参数</strong>，为该线程的id</li><li>第二个参数是用于指定线程的属性，暂时设置为<code>NULL</code>使用默认属性</li><li>第三个参数是让该进程执行的函数，这是一个函数指针，参数和返回值都为<code>void*</code></li><li>第四个参数是<strong>传给第三个执行函数的参数</strong></li></ul><p>创建正常后返回0，否则返回错误码</p><p>注意，使用了pthread库后，需要在编译的时候指定链接，<code>-lpthread</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;<span class="comment">//线程id</span></span><br></pre></td></tr></table></figure><p>创建线程后打印可以发现，线程id是一个非常大的值，并不像进程PID那么小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cout &lt;&lt; &quot;pthread_create &quot;&lt;&lt; t1 &lt;&lt; &quot; &quot; &lt;&lt; t2 &lt;&lt; endl;</span></span><br><span class="line">pthread_create <span class="number">140689524995840</span> <span class="number">140689516603136</span></span><br></pre></td></tr></table></figure><p>可以通过<code>printf %x</code>的方式来减少打印长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;0x%x  0x%x\n&quot;,t1,t2);</span></span><br><span class="line"><span class="number">0x393d0700</span>  <span class="number">0x38bcf700</span></span><br></pre></td></tr></table></figure><h2 id="2-2-pthread-join"><a href="#2-2-pthread-join" class="headerlink" title="2.2 pthread_join"></a>2.2 pthread_join</h2><p>光是创建进程还不够，我们还需要对进程<strong>进行等待</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>这里第一个参数是线程的id，第二个参数是进程的退出状态</p><p>等待成功后返回0，否则返回错误码</p><ul><li>join可以在线程退出后，释放线程的资源</li><li>同时获取线程对应的退出码</li><li>join还能保证是新创建的线程退出后，主线程才退出</li></ul><h3 id="2-2-1-基础的多线程操作"><a href="#2-2-1-基础的多线程操作" class="headerlink" title="2.2.1 基础的多线程操作"></a>2.2.1 基础的多线程操作</h3><p>有了这两个，我们就能写一个简单的多线程操作了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func1</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func1 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func1,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main::&quot;</span> &lt;&lt; <span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行会发现，多线程操作成功启动，且打印的进程pid都是一样的，<strong>代表其隶属于同一个进程</strong></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212152032424.png" alt="image-20221215203210372"></p><p>我们可以用下面的语句来查看轻量级进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aL</span><br></pre></td></tr></table></figure><p>可以看到，执行了程序之后，出现了3个<code>PID</code>相同，<code>LWP</code>不同的轻量级进程，这就代表我们的多线程操作成功了；</p><p>同时也能看到，在多线程操作时，谁先运行是不确定的。这是由系统调度随机决定的</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212152033288.png" alt="image-20221215203326193"></p><h3 id="2-2-2-C-的多线程操作"><a href="#2-2-2-C-的多线程操作" class="headerlink" title="2.2.2 C++的多线程操作"></a>2.2.2 C++的多线程操作</h3><p>C++11也支持了多线程操作，其封装了操作系统的pthread接口，基本的操作很相似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1,(<span class="type">char</span>*)<span class="string">&quot;test1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func2,(<span class="type">char</span>*)<span class="string">&quot;test2&quot;</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main:: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后的效果是一样的，C++的thread库还可以传入<code>functional</code>封装的可调用函数，和<code>lambda</code>表达式</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212152054822.png" alt="image-20221215205453606"></p><h2 id="2-3-线程退出"><a href="#2-3-线程退出" class="headerlink" title="2.3 线程退出"></a>2.3 线程退出</h2><h3 id="2-3-1-retval"><a href="#2-3-1-retval" class="headerlink" title="2.3.1 retval"></a>2.3.1 retval</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><p>我们可以使用该函数的第二个参数来获取线程所执行方法的返回值。<code>retval</code>是一个二级指针，是一个<strong>输出型参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func1</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func1 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func1,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main:: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* r1;</span><br><span class="line">    <span class="type">void</span>* r2;</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,&amp;r1);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,&amp;r2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 1 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 2 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当两个线程退出之后，主函数中成功打印出了他们的返回值</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212161842059.png" alt="image-20221216184220924"></p><p>注意，因为我们是将<code>void*</code>的指针强转为int，如果在打印的时候强转为<code>int</code>，会出现<strong>精度丢失</strong>的报错，需要使用<code>long long</code>来规避报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ make</span><br><span class="line">g++ test.cpp -o test -lpthread -std=c++11</span><br><span class="line">.test.cpp: In function ‘void test3()’:</span><br><span class="line">test.cpp:88:35: error: cast from ‘void*’ to ‘int’ loses precision [-fpermissive]</span><br><span class="line">     cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (int)r1 &lt;&lt; endl;</span><br><span class="line">                                   ^</span><br><span class="line">make: *** [test] Error 1</span><br></pre></td></tr></table></figure><h3 id="2-3-2-pthread-exit"><a href="#2-3-2-pthread-exit" class="headerlink" title="2.3.2 pthread_exit"></a>2.3.2 pthread_exit</h3><p>除了直接return，线程还可以调用<code>pthread_exit</code>函数实现退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>效果完全一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return (void*)10;</span></span><br><span class="line">pthread_exit((<span class="type">void</span>*)<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>注意，主线程main中调用该函数，并不会导致进程退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; tid: &quot;</span> &lt;&lt; <span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">	<span class="comment">//func2会执行10s</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">test5</span>();</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);<span class="comment">//主线程提前退出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主函数已经调用了<code>pthread_exit</code>退出了，但是线程还在跑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./test</span><br><span class="line">func2 thread:: 1 :: 9474 tid: 9475</span><br><span class="line">func2 thread:: 2 :: 9474 tid: 9476</span><br><span class="line">func2 thread:: 1 :: 9474 tid: 9475</span><br><span class="line">func2 thread:: 2 :: 9474 tid: 9476</span><br><span class="line">main exit</span><br><span class="line">func2 thread:: 1 :: 9474 tid: 9475</span><br><span class="line">func2 thread:: 2 :: 9474 tid: 9476</span><br></pre></td></tr></table></figure><h3 id="2-3-3-ptrhead-cancel"><a href="#2-3-3-ptrhead-cancel" class="headerlink" title="2.3.3 ptrhead_cancel"></a>2.3.3 ptrhead_cancel</h3><p>除了上面俩种方式，我们还可以在main里面直接把某一个线程给关掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func1,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main:: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">11</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_cancel</span>(t1);</span><br><span class="line">            <span class="built_in">pthread_cancel</span>(t2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span>* r1;</span><br><span class="line">    <span class="type">void</span>* r2;</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,&amp;r1);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,&amp;r2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 1 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 2 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被提前终止的进程，返回值都为-1</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212161903290.png" alt="image-20221216190338205"></p><h3 id="2-3-4-为什么进程退出不会向主进程发送信号？"><a href="#2-3-4-为什么进程退出不会向主进程发送信号？" class="headerlink" title="2.3.4 为什么进程退出不会向主进程发送信号？"></a>2.3.4 为什么进程退出不会向主进程发送信号？</h3><p>要理清楚这个问题，还是需要深知一个概念：线程是进程中的一个执行流，它并不是一个独立的进程。</p><p>先来回顾一下进程退出的几种情况：</p><ul><li>代码跑完，结果正确</li><li>代码跑完，结果有问题</li><li>代码出错了，异常</li></ul><p>线程退出的情况也是这样，但线程如果因为某些异常退出，<strong>进程也会同步退出</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./test</span><br><span class="line">this is main:: 13845</span><br><span class="line">Floating point exception</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ </span><br></pre></td></tr></table></figure><p>由此可见，<code>线程异常 = 进程异常</code></p><p>这里也就涉及到<code>1.5.1</code>中提到的线程<strong>健壮性</strong>问题，线程的异常会影响其他线程的运行，会导致进程整体异常退出。</p><p>所以在<code>join</code>等待线程退出的时候，我们只需要考虑线程正常退出的情况；</p><blockquote><p>异常退出的时候恐怕也等不了😂因为进程也挂了</p></blockquote><h2 id="2-3-5-exit"><a href="#2-3-5-exit" class="headerlink" title="2.3.5 exit"></a>2.3.5 exit</h2><p>任何一个线程执行<code>exit()</code>函数，都会导致整个进程退出</p><hr><h2 id="2-4-pthread-detach"><a href="#2-4-pthread-detach" class="headerlink" title="2.4 pthread_detach"></a>2.4 pthread_detach</h2><p>等待是有性能损失的！默认创建的进程是<code>joinable</code>，也就是可以被主线程进行<code>pthread_join</code>等待的；</p><p>这个函数的作用是让主线程不管创建出来的子线程，也不用去等待它，相当于取消了它的<code>joinable</code>属性；</p><p>就好比父进程不想管子进程的时候，将<code>SIGCHLD</code>设置为<code>SIG_IGN</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>一个线程是否应该等待，取决于是否需要获取该线程的返回值；如果无须获取返回值，则使用分离能提高运行效率</p><blockquote><p>即便线程所运行的函数return是无效的，但我们可以用输出型参数来获取返回值</p></blockquote><h3 id="2-4-1-实操"><a href="#2-4-1-实操" class="headerlink" title="2.4.1 实操"></a>2.4.1 实操</h3><p>使用也很简单，只需要指定线程的id就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main - global: &quot;</span> &lt;&lt; global &lt;&lt; <span class="string">&quot; - &amp;global: &quot;</span> &lt;&lt; &amp;global &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上也不会有什么区别，但是我们已无法获取到该线程的返回值</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212181127252.png" alt="image-20221218112720052"></p><hr><h3 id="2-4-2-detach后join"><a href="#2-4-2-detach后join" class="headerlink" title="2.4.2 detach后join"></a>2.4.2 detach后join</h3><p>但如果我们在detach之后又进行<code>pthread_join</code>会发生什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func3</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;func thread:%s - global:%d - &amp;global:%p\n&quot;</span>,(<span class="type">char</span>*)arg,global,&amp;global);</span><br><span class="line">        global++;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* r1=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">void</span>* r2=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,&amp;r1);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,&amp;r2);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 1 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 2 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诶，这不还是获取到了返回值吗？这么说，他这个<code>detach</code>岂不是没用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./test</span><br><span class="line">func thread:1 - global:103 - &amp;global:0x7fb5648b06fc</span><br><span class="line">func thread:2 - global:103 - &amp;global:0x7fb5640af6fc</span><br><span class="line">func thread:1 - global:104 - &amp;global:0x7fb5648b06fc</span><br><span class="line">func thread:2 - global:104 - &amp;global:0x7fb5640af6fc</span><br><span class="line">func exit</span><br><span class="line">func exit</span><br><span class="line">retval 1 : 10</span><br><span class="line">retval 2 : 10</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ </span><br></pre></td></tr></table></figure><p>实际上，当我们create一个线程的时候，它会先去执行线程创建的相关代码，此时main又直接去执行后面的代码了；此时<code>pthread_join</code>的调用是成功的，因为线程自己的<code>detach</code>代码<strong>还没有被执行</strong>！</p><hr><p>而如果我们在create之后，等线程开始运行了在执行<code>detach</code>，此时join就会失败</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* r1=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">void</span>* r2=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_join</span>(t1,&amp;r1);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(ret) &lt;&lt; endl;</span><br><span class="line">    ret = <span class="built_in">pthread_join</span>(t2,&amp;r2);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(ret) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 1 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 2 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印错误码也能看到，系统提示我们给<code>join</code>传入了一个无效的参数，线程依旧在正常运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt<span class="number">-7274</span>:~/git/linux/code/<span class="number">22</span><span class="number">-12</span><span class="number">-15</span>_pthread]$ ./test</span><br><span class="line">func thread:<span class="number">1</span> - global:<span class="number">101</span> - &amp;global:<span class="number">0x7f2d439136fc</span></span><br><span class="line">func thread:<span class="number">2</span> - global:<span class="number">101</span> - &amp;global:<span class="number">0x7f2d431126fc</span></span><br><span class="line">func thread:<span class="number">2</span> - global:<span class="number">102</span> - &amp;global:<span class="number">0x7f2d431126fc</span></span><br><span class="line">func thread:<span class="number">1</span> - global:<span class="number">102</span> - &amp;global:<span class="number">0x7f2d439136fc</span></span><br><span class="line"><span class="number">22</span>:Invalid argument</span><br><span class="line"><span class="number">22</span>:Invalid argument</span><br><span class="line">retval <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">retval <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">func thread:<span class="number">2</span> - global:<span class="number">103</span> - &amp;global:<span class="number">0x7f2d431126fc</span></span><br><span class="line">func thread:<span class="number">1</span> - global:<span class="number">103</span> - &amp;global:<span class="number">0x7f2d439136fc</span></span><br></pre></td></tr></table></figure><p>所以正确的做法，<strong>应该是在主线程中分离线程</strong>，不要在线程自己的代码中执行detach，否则就会出现上面的分离失败的情况</p><h3 id="2-4-3-线程分离后，主线程先退出"><a href="#2-4-3-线程分离后，主线程先退出" class="headerlink" title="2.4.3 线程分离后，主线程先退出"></a>2.4.3 线程分离后，主线程先退出</h3><p>如果执行完毕<code>pthread_detach</code>后，主线程提前退出了，会发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，线程也跟着一并退出了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./test</span><br><span class="line">func thread:1 - global:100 - &amp;global:0x7f01cd49a6fc</span><br><span class="line">func thread:2 - global:100 - &amp;global:0x7f01ccc996fc</span><br><span class="line">func thread:2 - global:101 - &amp;global:0x7f01ccc996fc</span><br><span class="line">func thread:1 - global:101 - &amp;global:0x7f01cd49a6fc</span><br><span class="line">func thread:2 - global:102 - &amp;global:0x7f01ccc996fc</span><br><span class="line">func thread:1 - global:102 - &amp;global:0x7f01cd49a6fc</span><br><span class="line">main exit</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ </span><br></pre></td></tr></table></figure><p>因为线程<strong>没有独立性</strong>，完全属于这个进程。不可能出现你家房子塌了，你自己的房间还在的情况😂</p><blockquote><p>进程退出的时候，操作系统就回收了这个进程的程序地址空间，连资源都被释放了，线程就没有办法继续运行，自然就退出了。</p></blockquote><p>所以，为了避免这种问题，一般我们分离线程的时候，都倾向于让主线程保持在后台运行（常驻内存的程序）</p><h2 id="2-5-gettid-x2F-syscall"><a href="#2-5-gettid-x2F-syscall" class="headerlink" title="2.5 gettid&#x2F;syscall"></a>2.5 gettid&#x2F;syscall</h2><p>该函数是一个系统接口，<strong>但它并不能直接运行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       gettid - get thread identification</span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/types.h&gt;</span><br><span class="line">       pid_t gettid(void);</span><br><span class="line"></span><br><span class="line">       Note:  There  is  no  glibc wrapper for this system call; see</span><br><span class="line">       NOTES.</span><br></pre></td></tr></table></figure><p>我们需要用<strong>syscall函数</strong>来调用该接口，这也是第一次接触到syscall函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span>   <span class="comment">/* For SYS_xxx definitions */</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall</span><span class="params">(<span class="type">int</span> number, ...)</span>;</span><br></pre></td></tr></table></figure><p>在syscall的man手册中，我们就能看到获取线程id相关的示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EXAMPLE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> tid;</span><br><span class="line"></span><br><span class="line">    tid = syscall(SYS_gettid);</span><br><span class="line">    tid = syscall(SYS_tgkill, getpid(), tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用下面的代码进行测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; tid: &quot;</span> &lt;&lt; <span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tis is main - pid:%d - tid:%d\n&quot;</span>,<span class="built_in">getpid</span>(),<span class="built_in">syscall</span>(SYS_gettid));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可以看到进程打印出了相同的PID和不同的TID，其TID对应的就是<code>ps -aL</code>中显示的<code>LWP</code>编号</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212181307710.png" alt="image-20221218130755643"></p><h1 id="3-相关概念"><a href="#3-相关概念" class="headerlink" title="3.相关概念"></a>3.相关概念</h1><h2 id="3-1-线程id是什么？"><a href="#3-1-线程id是什么？" class="headerlink" title="3.1 线程id是什么？"></a>3.1 线程id是什么？</h2><p>前面提到过，<code>pthread_t</code>是线程独立的id，本质上是一个无符号长整形，打印出来后，是一个很大的数字。这个数字有什么特别的含义吗？</p><p>先来回顾一下线程的基本概念：</p><ul><li>线程是一个独立的执行流</li><li>线程在运行过程中，会产生自己的临时数据</li><li>线程调用函数的压栈出栈操作，有自己独立的栈结构</li></ul><p>因此，既然有一个独立的栈结构，其就需要有一个标识符来指向这个栈结构，方便程序运行的时候进行调用！</p><p>所以，<code>pthread_t</code>本质上是一个地址！其指向的就是这个<strong>线程的控制块</strong>，其内部包含了这个线程的独立栈结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;0x%x  0x%x\n&quot;,t1,t2);</span></span><br><span class="line"><span class="number">0x393d0700</span>  <span class="number">0x38bcf700</span> <span class="comment">//打印出来的结果也很像地址</span></span><br></pre></td></tr></table></figure><h2 id="3-2-pthread库"><a href="#3-2-pthread库" class="headerlink" title="3.2 pthread库"></a>3.2 pthread库</h2><p>pthread库并不是一个内核级的接口库，其实际上是封装了系统的<code>clone/vfork</code>等接口，从而为我们提供的用户级的线程库。</p><p>使用pthread库创建的进程，和内核中的LWP是<code>1:1</code>的</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212181023276.png" alt="image-20221218102338117"></p><p>pthread是一个<strong>动态库</strong>，所以在编译的时候需要加上链接选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o test -lpthread</span><br></pre></td></tr></table></figure><p>在我的 <a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/127668016?spm=1001.2014.3001.5501">动静态库<i class="fas fa-external-link-alt"></i></a> 的博客中有讲述过，动态库是在运行的时候动态链接的，其会将库中的代码映射到进程地址空间的<code>共享区</code>，从而调用动态库中的代码</p><blockquote><p>举个例子，当我们调用<code>pthead_create</code>的时候，<strong>进程会跳到共享区中</strong>，执行动态库中的代码，创建成功后返回自己的<code>代码区</code>，完成一个线程的创建</p></blockquote><p>而线程所用的独立栈，也是pthread库帮我们管理的。因为有共享区的存在，我们能通过<code>pthread_t</code>直接访问到动态库中管理的<strong>线程的控制模块</strong>，从而完成线程的压栈、出栈等等操作</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212181036505.png" alt="image-20221218103643205"></p><p>下为linux的<code>pthreadtypes.h</code>中的部分内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __SIZEOF_PTHREAD_ATTR_T 36</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">pthread_attr_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __have_pthread_attr_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">pthread_attr_t</span> <span class="title">pthread_attr_t</span>;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __have_pthread_attr_t	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="3-3-线程的局部存储"><a href="#3-3-线程的局部存储" class="headerlink" title="3.3 线程的局部存储"></a>3.3 线程的局部存储</h2><p>假设我们有一个全局变量，我们想让创建出来的每一个线程，都能独立的使用这个全局变量，那就需要用到线程的<strong>局部存储</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global = <span class="number">10</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func3</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func thread &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt;  <span class="string">&quot; - global: &quot;</span> &lt;&lt; global &lt;&lt; <span class="string">&quot; - &amp;global: &quot;</span> &lt;&lt; &amp;global &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main - global: &quot;</span> &lt;&lt; global &lt;&lt; <span class="string">&quot; - &amp;global: &quot;</span> &lt;&lt; &amp;global &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行，不管是主线程还是线程，都打印的是相同的值和地址</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212181107524.png" alt="image-20221218110718405"></p><p>如果在执行的函数<code>func3</code>中添加一个<code>global++</code>，则能观察到所有线程都是公用的一个变量，这里的+是同步的。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212181110159.png" alt="image-20221218111031984"></p><p>如果我们想让<code>int global</code>变成局部变量，则需要在它之前加上一个<code>__thread</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread <span class="type">int</span> global = <span class="number">100</span>;<span class="comment">//可以让线程独立使用的全局变量</span></span><br></pre></td></tr></table></figure><p>此时可以看到，两个线程和主线程打印的global变量地址不同，他们的<code>++</code>操作是独立的，变量的值也是独立的</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212181116428.png" alt="image-20221218111639283"></p><p>这就实现了将某一个变量划分给线程进行<strong>局部存储</strong></p><h1 id="4-线程互斥问题"><a href="#4-线程互斥问题" class="headerlink" title="4.线程互斥问题"></a>4.线程互斥问题</h1><h2 id="4-1-临界资源"><a href="#4-1-临界资源" class="headerlink" title="4.1 临界资源"></a>4.1 临界资源</h2><p>在先前<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/127834035?spm=1001.2014.3001.5501">共享内存 信号量<i class="fas fa-external-link-alt"></i></a>的博客中，已经涉及到了这部分的内容；即关于操作<strong>原子性</strong>和访问<strong>临界资源&#x2F;临界区</strong>的相关问题。</p><ul><li>能被多个进程&#x2F;线程看到的资源，被称为<code>临界资源</code></li><li>进程&#x2F;线程访问临界资源的代码，被称为<code>临界区</code></li></ul><p>在线程中，同样存在访问<strong>临界资源</strong>而导致的冲突：</p><ul><li>线程A对一个<strong>全局变量val</strong>进行了<code>-1</code>操作，当操作执行到放回内存那一步的时候，发生了线程切换，线程B开始工作</li><li>线程B同样访问了该全局变量val，对它进行了<code>-10</code>操作，此时因为线程A的<code>-1</code>操作尚未写回内存，全局变量val还是保持初值。线程b将<code>-10</code>之后的全局变量val写回了内存</li><li>又发生了线程切换，跳转到线程A停止的<strong>线程上下文数据</strong>中开始执行，将全局变量写入内存</li><li>这时候，线程B的<code>-10</code>操作就被A的写入覆盖了！</li></ul><p>举个实际点的例子，以100为全局变量的初始值</p><ul><li>线程A执行-1，<code>100-1=99</code>，还未写入内存时，就线程切换</li><li>线程B取到的全局变量还是100，对其执行-10，并写入内存， 此时全局变量为90</li><li>返回线程A继续执行写入内存操作，全局变量又被复写成了99；<strong>相当于B的操作是无效的</strong></li></ul><p>这种条件下会产生很多问题，也是我们不希望看到的！</p><h2 id="4-2-原子-x2F-互斥性"><a href="#4-2-原子-x2F-互斥性" class="headerlink" title="4.2 原子&#x2F;互斥性"></a>4.2 原子&#x2F;互斥性</h2><p>这种时候，我们就需要保证访问该全局变量的操作是<strong>原子</strong>的，不能出现中间状态；</p><p>也应该是<strong>互斥</strong>的，不能出现两个线程同时访问一份资源的情况</p><blockquote><p>互斥性：任何时候都只有一个执行流在访问某一份资源</p></blockquote><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212181937011.png" alt="image-20221218193343035"></p><p>为了达成这一目的，我们需要给线程的操作<strong>加锁</strong></p><h2 id="4-3-线程加锁"><a href="#4-3-线程加锁" class="headerlink" title="4.3 线程加锁"></a>4.3 线程加锁</h2><p>线程加锁涉及到几个操作：</p><ul><li>提供一把锁</li><li>在需要维持原子性（临界区）的位置加上锁</li><li>访问临界区结束后，打开锁</li><li>进程结束后，把锁丢了</li></ul><p>接下来就让我们一一解决这些问题</p><h3 id="4-3-1-pthread-mutex-init"><a href="#4-3-1-pthread-mutex-init" class="headerlink" title="4.3.1 pthread_mutex_init"></a>4.3.1 pthread_mutex_init</h3><p>pthread在设计之初就考虑到了这种问题，所以它便给我们提供了加锁相关的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>首先我们需要定义一把锁，类型是<code>pthread_mutex_t</code></p><ul><li>如果我们需要的是一把<strong>全局变量</strong>的锁，则可以直接使用<code>PTHREAD_MUTEX_INITIALIZER</code>给这把锁初始化</li><li>如果是一把局部的锁，则使用函数<code>pthread_mutex_init</code>进行初始化</li></ul><p>初始化的方法很简单，传入锁和对应的属性就行。此时我们忽略属性问题，设置为<code>NULL</code>使用<strong>默认属性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认属性的全局锁or静态static锁</span></span><br><span class="line"><span class="comment">//无须调用函数初始化，可以直接用</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数进行初始化局部的锁（当然也可以初始化全局锁）</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//定义一把锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, nullptr);<span class="comment">//初始化</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);<span class="comment">//销毁</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-加锁-x2F-解锁"><a href="#4-3-2-加锁-x2F-解锁" class="headerlink" title="4.3.2 加锁&#x2F;解锁"></a>4.3.2 加锁&#x2F;解锁</h3><p>有了锁，那么就可以在需要的位置加上这把锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>其中lock是<strong>阻塞式</strong>加锁，如果你调用这个接口的时候，锁正在被别人使用，则会在这里等待；trylock是<strong>非阻塞</strong>加锁，如果你调用该接口时锁正被使用，则直接<code>return</code>返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The pthread_mutex_trylock() function shall be equivalent to pthread_mutex_lock(), except that if the mutex object referenced  by  mutex  is  currently locked (by any thread, including the current thread), the call shall return immediately. </span><br></pre></td></tr></table></figure><p>加了锁之后，在需要的位置<code>unlock</code>解锁；</p><ul><li>加锁和解锁操作<strong>本身</strong>是原子的，不会出现冲突</li><li>加了锁之后，可以理解为加锁解锁操作<strong>中间</strong>的代码也是原子性的，<strong>必须要运行到解锁位置</strong>才能让另外一个线程&#x2F;进程执行这里的代码</li><li>加锁的本质是让线程执行临界区的代码串行化</li></ul><h3 id="4-3-3-加锁的注意事项"><a href="#4-3-3-加锁的注意事项" class="headerlink" title="4.3.3 加锁的注意事项"></a>4.3.3 加锁的注意事项</h3><ul><li>只对临界区加锁；锁保护的就是临界区</li><li>加锁的粒度越细越好（即加锁的区域越小越好）</li><li>加锁是编程的一种规范；在实际问题中，我们要保证访问某一临界资源的所有操作都要加上锁。不能出现函数A加锁了，但是B没有加锁的情况（这样会导致A的加锁也没有意义）</li></ul><h2 id="4-4-示例-倒水问题"><a href="#4-4-示例-倒水问题" class="headerlink" title="4.4 示例-倒水问题"></a>4.4 示例-倒水问题</h2><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212240951765.png" alt="image-20221224095101707"></p><p>以<strong>倒水</strong>为示例，假设杯子容量为10000，<strong>装满了水就会溢出</strong>。我们使用多个线程对这个杯子加水，直到满了之后线程退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//临界资源</span></span><br><span class="line"><span class="type">int</span> water = <span class="number">0</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> cup = <span class="number">10000</span>;<span class="comment">//杯子的容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(water&lt;cup)<span class="comment">//临界区</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            water++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水已经满了 &quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 线程退出&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2,t3,t4;<span class="comment">//创建4个线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t3,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t4,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接分离线程</span></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t3);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;<span class="comment">//啥都不干</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果如下，明明水已经满了，但还是会有部分线程报告水还没有满，且数字有很严重的偏差</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t3 水没有满：9993</span><br><span class="line">t3 水没有满：9994</span><br><span class="line">t3 水没有满：9995</span><br><span class="line">t3 水没有满：9996</span><br><span class="line">t3 水没有满：9997</span><br><span class="line">t3 水没有满：9998</span><br><span class="line">t3 水没有满：9999</span><br><span class="line">t3 水已经满了</span><br><span class="line">t3 线程退出</span><br><span class="line"> 水没有满：2723</span><br><span class="line">t4 水已经满了</span><br><span class="line">t4 线程退出</span><br><span class="line">0</span><br><span class="line">t2 水已经满了</span><br><span class="line">t2 线程退出</span><br><span class="line">t1 水没有满：9668</span><br><span class="line">t1 水已经满了</span><br><span class="line">t1 线程退出</span><br></pre></td></tr></table></figure><p>多运行几次，也能发现相同的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t2 水没有满：9997</span><br><span class="line">t2 水没有满：9998</span><br><span class="line">t2 水没有满：9999</span><br><span class="line">t2 水已经满了 10000</span><br><span class="line">t2 线程退出</span><br><span class="line">t4 水没有满：1889</span><br><span class="line">t4 水已经满了 10001</span><br><span class="line">t4 线程退出</span><br><span class="line">t3 水没有满：0</span><br><span class="line">t3 水已经满了 10002</span><br><span class="line">t3 线程退出</span><br><span class="line">t1 水没有满：0</span><br><span class="line">t1 水已经满了 10003</span><br><span class="line">t1 线程退出</span><br></pre></td></tr></table></figure><h3 id="4-4-1-只有一个线程在工作？"><a href="#4-4-1-只有一个线程在工作？" class="headerlink" title="4.4.1 只有一个线程在工作？"></a>4.4.1 只有一个线程在工作？</h3><p>除了偏差外，还有一个小问题，往前翻打印记录，会发现一直都是<strong>某一个线程在倒水</strong>，其他线程似乎啥事没有干？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t3 水没有满：9786</span><br><span class="line">t3 水没有满：9787</span><br><span class="line">t3 水没有满：9788</span><br><span class="line">t3 水没有满：9789</span><br><span class="line">t3 水没有满：9790</span><br></pre></td></tr></table></figure><p>这是因为当运行t3的时候，t3在while循环中继续运行的消耗，<strong>小于切换到其他线程的消耗</strong>。所以控制块就让t3一直运行，直到它break退出循环</p><p>此时我们只需要加上一个usleep，增加每一个while循环中需要<strong>处理的负担</strong>，就能让所有线程都来倒水</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usleep功能把进程挂起一段时间， 单位是微秒（百万分之一秒）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">usleep</span><span class="params">(<span class="type">useconds_t</span> usec)</span>;</span><br></pre></td></tr></table></figure><p>这是因为线程切换同样也是时间片到了，从内核返回用户态的时候做检测，切换至其他线程。</p><p>添加usleep能创造更多<strong>内核&#x2F;用户的中间态</strong>，从而增多切换线程的次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(water&lt;cup)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span>);<span class="comment">//休息100微秒</span></span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            water++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水已经满了&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 线程退出&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这还是没有解决数字出错的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t4 水没有满：9995</span><br><span class="line">t3 水没有满：9996</span><br><span class="line">t1 水没有满：9997</span><br><span class="line">t2 水没有满：9998</span><br><span class="line">t4 水没有满：9999</span><br><span class="line">t4 水已经满了 10000</span><br><span class="line">t4 线程退出</span><br><span class="line">t3 水没有满：10000</span><br><span class="line">t3 水已经满了 10001</span><br><span class="line">t3 线程退出</span><br><span class="line">t1 水没有满：10001</span><br><span class="line">t1 水已经满了 10002</span><br><span class="line">t1 线程退出</span><br><span class="line">t2 水没有满：10002</span><br><span class="line">t2 水已经满了 10003</span><br><span class="line">t2 线程退出</span><br></pre></td></tr></table></figure><h3 id="4-4-2-加锁-问题解决"><a href="#4-4-2-加锁-问题解决" class="headerlink" title="4.4.2 加锁-问题解决"></a>4.4.2 加锁-问题解决</h3><p>这时候就需要请出我们的锁了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略头文件</span></span><br><span class="line"><span class="type">int</span> water = <span class="number">0</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> cup = <span class="number">10000</span>;<span class="comment">//杯子的容量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(water&lt;cup)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            water++;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span>);<span class="comment">//假装喝水</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水已经满了 &quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="comment">//此处也需要加锁，否则break出去之后其他线程会因为没有解锁而挂起</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 线程退出&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果遇到2号信号，就在销毁锁后退出进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">des</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//销毁锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pthread_mutex_destroy, exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT,des);<span class="comment">//自定义捕捉2号信号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">nullptr</span>);<span class="comment">//初始化锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> t1,t2,t3,t4;<span class="comment">//创建4个线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t3,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t4,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接分离线程</span></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t3);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;<span class="comment">//啥都不干</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可见，数字错误问题就没有出现了；<strong>但又出现了只有一个线程工作的问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t1 水没有满：<span class="number">9996</span></span><br><span class="line">t1 水没有满：<span class="number">9997</span></span><br><span class="line">t1 水没有满：<span class="number">9998</span></span><br><span class="line">t1 水没有满：<span class="number">9999</span></span><br><span class="line">t1 水已经满了 <span class="number">10000</span></span><br><span class="line">t1 线程退出</span><br><span class="line">t3 水已经满了 <span class="number">10000</span></span><br><span class="line">t3 线程退出</span><br><span class="line">t4 水已经满了 <span class="number">10000</span></span><br><span class="line">t4 线程退出</span><br><span class="line">t2 水已经满了 <span class="number">10000</span></span><br><span class="line">t2 线程退出</span><br><span class="line">^Cpthread_mutex_destroy, exit</span><br></pre></td></tr></table></figure><p>这还是因为线程切换的效率问题；也有可能是因为其它线程申请锁的时候，发现t1在用，就进行了<strong>阻塞等待</strong>而挂起</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212191022656.png" alt="image-20221219102217522"></p><p>只需要在解锁之后添加一个<code>usleep</code>模拟其他工作，就能让所有线程都跑起来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span>(water&lt;cup)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    water++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">100</span>);<span class="comment">//假装喝水</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有出现数据错误，加锁的目的成功达到！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t1 水没有满：9993</span><br><span class="line">t3 水没有满：9994</span><br><span class="line">t4 水没有满：9995</span><br><span class="line">t2 水没有满：9996</span><br><span class="line">t1 水没有满：9997</span><br><span class="line">t3 水没有满：9998</span><br><span class="line">t4 水没有满：9999</span><br><span class="line">t2 水已经满了 10000</span><br><span class="line">t2 线程退出</span><br><span class="line">t1 水已经满了 10000</span><br><span class="line">t1 线程退出</span><br><span class="line">t3 水已经满了 10000</span><br><span class="line">t3 线程退出</span><br><span class="line">t4 水已经满了 10000</span><br><span class="line">t4 线程退出</span><br><span class="line">^Cpthread_mutex_destroy, exit</span><br></pre></td></tr></table></figure><h2 id="4-5-加锁的进一步解释"><a href="#4-5-加锁的进一步解释" class="headerlink" title="4.5 加锁的进一步解释"></a>4.5 加锁的进一步解释</h2><p>在这个代码示例中，我们给中间的几行代码加了锁；但这并不意味着执行中间这部分代码的时候，就不会发生线程切换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">if</span>(water&lt;cup)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    water++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>事实上，代码执行的任何地方，都可能发生进程&#x2F;线程的切换。但因为我们加了锁，切换的时候，其他线程要来访问这里的资源，<strong>就必须先申请锁</strong></p><p>此时锁在<strong>被切走的进线程手上</strong>，所以其他线程无法访问临界区的资源，也就不会发生数据不一致的问题。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202211031203810.gif" alt="QQ图片20220504102516"></p><blockquote><p>换言之，只要<strong>张三</strong>拿到了锁，那么它也就不担心自己的工作会被别人覆盖的问题；</p><p>而对其他线程而言，张三访问临界区的工作，只有<strong>还没进入</strong>临界区和<strong>访问完毕</strong>临界区两种状态</p></blockquote><p>因此会导致一个问题，那就是线程切换的效率较低，其他线程出现了阻塞等待的情况；为了避免此问题，我们应该让访问临界区的操作快去快回，尽量不要在临界区里面干啥耗时的事情</p><h3 id="4-5-1-加锁原子性的保证"><a href="#4-5-1-加锁原子性的保证" class="headerlink" title="4.5.1 加锁原子性的保证"></a>4.5.1 加锁原子性的保证</h3><blockquote><p>备注：这部分仅供学习参考，若有错误，还请指出！</p></blockquote><p>那么加锁这个操作，是如何保证其自身的原子性呢？在加锁的途中不会发生线程切换吗？</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212240939271.png" alt="Snipaste_2022-12-24_09-38-46"></p><p>我找到了一张能大概说明汇编加锁过程的图片，其中<code>movb</code>的操作就是将al寄存器写为0，<code>xchgb</code>的操作是将al寄存器的内容和内存中mutex锁的值进行交换</p><ul><li>开始的时候，锁被正常初始化，内存中mutex的值为1（锁只会被初始化一次）</li><li>线程A开始加锁，al寄存器和mutex的值发生交换，此时内存中的mutex为0，al为1</li><li>判断al不为0，代表获取锁成功，线程A加锁成功</li><li>线程B也来申请锁了，<code>movb</code>将al寄存器写为0，再和内存中的mutex交换后，发现还是0，则代表锁在别人手上，此时就需要挂起等待</li></ul><p>前面一直强调，线程是有自己独立的栈结构和上下文数据的，在加锁的这部分汇编操作中，同样可能会在任何地方发生线程切换。切换的时候，线程的<strong>上下文数据</strong>（图中寄存器的状态）会被保留下来，<strong>随这个线程一起被切换走</strong></p><p>所以线程A被切换的时候，属于它上下文中那个值为1的al寄存器也被切走了（注意，这里切走的是数据，al寄存器本身作为硬件，<strong>有且只有一个</strong>）</p><p>由此看来，真正获取锁的操作，其实只有<code>xchgb</code>一条交换指令来完成，<font color="Red">保证加锁操作只由一条汇编语句实现</font>，就能保证该操作的原子性！</p><p>解锁的方法就很简单了，<code>movb</code>将1写回mutex变量即可，也是一条汇编完成；而且一般情况下，解锁是不会有执行流和你抢的。</p><blockquote><p>其实加锁远不止一种方法，锁的种类有非常多，还有<strong>总线锁、旋转锁</strong>等等，每一个锁的实现都不太一样！上面提到的为<code>互斥锁</code></p></blockquote><h3 id="4-5-2-总线锁"><a href="#4-5-2-总线锁" class="headerlink" title="4.5.2 总线锁"></a>4.5.2 总线锁</h3><p>现在的CPU一般都有自己的内部缓存，根据一些规则将内存中的数据读取到内部缓存中来，以加快频繁读取的速度。现在服务器通常是多 CPU，更普遍的是，每块CPU里有多个内核，而每个内核都维护了自己的缓存，那么这时候多线程并发就会存在缓存不一致性，这会导致严重问题。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202301031154743.webp" alt="img"></p><p>总线锁就是将cpu和内存之间的<strong>通信</strong>锁住，使得在锁定期间，其他cpu处理器不能操作其他内存中数据，故总线锁开销比较大！</p><p>总线锁的实现是采用cpu提供的<code>LOCK#</code>信号，当一个cpu在总线上输出此信号时，其他cpu的请求将被阻塞，那么该cpu则<strong>独占共享内存</strong>，相当于锁住了</p><ul><li>何为总线？</li></ul><p>CPU总线是所有CPU与芯片组连接的主干道，<strong>负责CPU与外界所有部件的通信</strong>，包括高速缓存、内存、北桥，其控制总线向各个部件发送控制信号、通过地址总线发送地址信号指定其要访问的部件、通过数据总线双向传输</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202301031153214.png" alt="image-20230103115306140"></p><h1 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5.死锁"></a>5.死锁</h1><p>死锁就是一种因为两放都不会释放对方需要的资源，从而陷入的永久等待状态</p><h2 id="5-1-死锁情况演示"><a href="#5-1-死锁情况演示" class="headerlink" title="5.1 死锁情况演示"></a>5.1 死锁情况演示</h2><p>举个例子，张三拿了锁A，申请锁B的时候，发现锁B无法申请，而进入等待；李四拿了锁B，接下来他想申请锁A，结果发现张三拿着锁A，那就只能进入等待。这就陷入了一个僵局，张三想要李四的，李四想要张三的，谁都不让谁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> m1;<span class="comment">//锁1</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> m2;<span class="comment">//锁2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func1</span><span class="params">(<span class="type">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m2);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func1 is running... &quot;</span> &lt;&lt;(<span class="type">const</span> <span class="type">char</span>*)arg&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m2);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m1);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 is running... &quot;</span> &lt;&lt;(<span class="type">const</span> <span class="type">char</span>*)arg&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;m1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;m2,<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func1,(<span class="type">void</span>*)<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分离</span></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;main running...&quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m1);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这个代码便能模拟出这个情况，线程1先要了锁1，再要锁2；线程2先要锁2再要锁1，他们俩就容易打起来，造成死锁。</p><p>运行代码的时候我们却发现，似乎并不是这样的，线程1好像还是成功拿到了俩把锁，并运行了起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./test</span><br><span class="line">main running...</span><br><span class="line">func1 is running... t1</span><br><span class="line">func1 is running... t1</span><br><span class="line">main running...</span><br><span class="line">func1 is running... t1</span><br><span class="line">main running...</span><br><span class="line">func1 is running... t1</span><br><span class="line">main running...</span><br></pre></td></tr></table></figure><p>那是因为我们没有执行其他一些工作，从而将线程1和2申请锁的时间错开</p><p>将代码改成下面这样，利用<code>usleep</code>让两个线程休眠不同时间，结果就不同了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func1</span><span class="params">(<span class="type">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">200</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m2);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func1 is running... &quot;</span> &lt;&lt;(<span class="type">const</span> <span class="type">char</span>*)arg&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m2);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">300</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m1);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 is running... &quot;</span> &lt;&lt;(<span class="type">const</span> <span class="type">char</span>*)arg&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，此时只有主线程在运行，线程t1和t2出现了死锁！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./test</span><br><span class="line">main running...</span><br><span class="line">main running...</span><br><span class="line">main running...</span><br><span class="line">main running...</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202211031204889.jpg" alt="QQ图片20220519220428"></p><h2 id="5-2-死锁的条件"><a href="#5-2-死锁的条件" class="headerlink" title="5.2 死锁的条件"></a>5.2 死锁的条件</h2><ul><li>互斥条件：某份资源同一时间只能由一个执行流访问</li><li>请求与保持：一个执行流因请求某种资源进入阻塞等待，而不释放自己的资源（好比上面代码例子中两个线程都不释放自己的锁，又想要别人的锁）</li><li>不剥夺条件：一个执行流已获得的资源，在未使用之前不能被剥夺（部分锁是允许被剥夺的）</li><li>循环等待：若干执行流之间形成一种头尾相接的循环等待资源的状态</li></ul><p>一把锁也能造成死锁吗？答案是肯定的！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;m1);</span><br><span class="line">pthread_mutex_lock(&amp;m1);</span><br><span class="line"><span class="comment">//两次申请同一把锁</span></span><br></pre></td></tr></table></figure><p>如果有人写出这种bug代码，那就会出现一把锁把自己死锁了；死锁本来就是代码的bug，所以这种低级错误也是死锁的情况之一😂</p><h2 id="5-3-避免死锁"><a href="#5-3-避免死锁" class="headerlink" title="5.3 避免死锁"></a>5.3 避免死锁</h2><p>避免死锁，其中最简单明了的办法，就是破坏上面提到的死锁的4个条件；其中互斥条件没啥好办法破坏（除非你不加锁），更主要的是看另外3个条件是否能破坏！</p><ul><li>保持加锁顺序一致：不要出现上面代码中的线程a先申请锁1，线程b先申请锁2的情况。在不同的执行流中，按相同的顺序申请锁（比如线程a和b都是按锁1&#x2F;2的顺序申请的）一定程度上能破坏<code>请求与保持</code>条件</li><li>降低加锁的粒度：锁保护的区域变小，加锁的粒度减小，能一定程度上避免锁未释放</li><li>资源一次性分配：减少临时资源分开给的情况</li><li>允许抢占：线程之间依靠优先级抢夺锁，这种情况就是<strong>锁允许被剥夺</strong></li></ul><hr><h1 id="6-线程安全"><a href="#6-线程安全" class="headerlink" title="6.线程安全"></a>6.线程安全</h1><p>线程安全：多个线程并发执行同一段代码的时候，<strong>不会</strong>出现不同的结果</p><p>线程不安全的情况：</p><ul><li>不保护临界资源</li><li>在多线程操作中调用<strong>不可重入</strong>函数（概念见<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/128138012?spm=1001.2014.3001.5502">linux信号<i class="fas fa-external-link-alt"></i></a>部分）</li><li>返回指向静态变量的指针的函数</li></ul><p>线程安全：</p><ul><li>每个线程只操作局部变量，或者只对全局、静态变量只读不写</li><li>接口对线程来说是原子操作（被锁保护）</li><li>多个线程切换不会使函数接口的结果出现<strong>二义性</strong></li><li>多线程操作不调用不可重入函数</li></ul><p>注意，绝大多数的系统自带的库（比如C++的STL库）都是<strong>不可重入</strong>的</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202212241021973.jpeg" alt="QQ图片20220512164211"></p><p>不可重入是函数的一种<strong>性质</strong>，并不是它的缺点！如果一个库函数明明告知你了我是不可重入的，你还不加保护的在多线程操作中调用它，<strong>那么这段代码是有bug的</strong>，并不是库函数本身有问题</p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【Linux】线程概念 | 互斥</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2022-12-23 16:30:16</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2022/12/23/Linux/19线程互斥/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E7%BA%BF%E7%A8%8B/">#线程</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/12/23/blog/%E5%8D%9A%E5%AE%A2%E8%A1%A8%E6%83%85%E5%8C%85/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【图床】博客表情包</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/12/11/nas/8%E7%89%B9%E6%AE%8A%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E7%9A%84%E8%A7%A3%E9%87%8A/"><span class="title flex-center"><span class="post-nav-title-item">【Nas】一些日志记录</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true',
              requiredMeta: ['nick','mail'] 
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1.线程的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-text">1.1 执行流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%97%B6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1.2 线程创建时做了什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="nav-text">1.3 内核源码中的体现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A7%81%E6%9C%89%E7%89%A9"><span class="nav-text">1.4 线程的私有物</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E7%BA%BF%E7%A8%8B%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">1.5 线程优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-%E7%BC%BA%E7%82%B9"><span class="nav-text">1.5.1 缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-%E4%BC%98%E7%82%B9"><span class="nav-text">1.5.2 优点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="nav-text">2.基础函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-pthread-create"><span class="nav-text">2.1 pthread_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-pthread-join"><span class="nav-text">2.2 pthread_join</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E5%9F%BA%E7%A1%80%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="nav-text">2.2.1 基础的多线程操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-C-%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="nav-text">2.2.2 C++的多线程操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-text">2.3 线程退出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-retval"><span class="nav-text">2.3.1 retval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-pthread-exit"><span class="nav-text">2.3.2 pthread_exit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-ptrhead-cancel"><span class="nav-text">2.3.3 ptrhead_cancel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E4%B8%8D%E4%BC%9A%E5%90%91%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%EF%BC%9F"><span class="nav-text">2.3.4 为什么进程退出不会向主进程发送信号？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-5-exit"><span class="nav-text">2.3.5 exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-pthread-detach"><span class="nav-text">2.4 pthread_detach</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E5%AE%9E%E6%93%8D"><span class="nav-text">2.4.1 实操</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-detach%E5%90%8Ejoin"><span class="nav-text">2.4.2 detach后join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E5%90%8E%EF%BC%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%85%88%E9%80%80%E5%87%BA"><span class="nav-text">2.4.3 线程分离后，主线程先退出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-gettid-x2F-syscall"><span class="nav-text">2.5 gettid&#x2F;syscall</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">3.相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E7%BA%BF%E7%A8%8Bid%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">3.1 线程id是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-pthread%E5%BA%93"><span class="nav-text">3.2 pthread库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-text">3.3 线程的局部存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="nav-text">4.线程互斥问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="nav-text">4.1 临界资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%8E%9F%E5%AD%90-x2F-%E4%BA%92%E6%96%A5%E6%80%A7"><span class="nav-text">4.2 原子&#x2F;互斥性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81"><span class="nav-text">4.3 线程加锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-pthread-mutex-init"><span class="nav-text">4.3.1 pthread_mutex_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-%E5%8A%A0%E9%94%81-x2F-%E8%A7%A3%E9%94%81"><span class="nav-text">4.3.2 加锁&#x2F;解锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-%E5%8A%A0%E9%94%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">4.3.3 加锁的注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E7%A4%BA%E4%BE%8B-%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="nav-text">4.4 示例-倒水问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%9C%A8%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="nav-text">4.4.1 只有一个线程在工作？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-%E5%8A%A0%E9%94%81-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="nav-text">4.4.2 加锁-问题解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E5%8A%A0%E9%94%81%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%A7%A3%E9%87%8A"><span class="nav-text">4.5 加锁的进一步解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-%E5%8A%A0%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-text">4.5.1 加锁原子性的保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-%E6%80%BB%E7%BA%BF%E9%94%81"><span class="nav-text">4.5.2 总线锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%AD%BB%E9%94%81"><span class="nav-text">5.死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5%E6%BC%94%E7%A4%BA"><span class="nav-text">5.1 死锁情况演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">5.2 死锁的条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-text">5.3 避免死锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">6.线程安全</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/about">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_3_tp.gif" height="20px"> </a><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>