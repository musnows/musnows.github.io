<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="慕雪年华"><meta name="referrer" content="no-referrer"><title>【Linux】线程概念 | 同步 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.outpost54.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/MainBG.jpg","background_post_img":"https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"Qe4QleZhY3IMzI6EMSokgLGZ-MdYXbMMI","appkey":"TPXkCvMB9gw8xBObFcDaLiGc","server_urls":"lecd.outpost54.top","placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://vrcl.outpost54.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/QA">留言板</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item"><a target="_blank" rel="noopener" href="https://www.travellings.cn/go.html">🚉</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/QA">留言板</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li><li class="drawer-menu-item flex-center"><a target="_blank" rel="noopener" href="https://www.travellings.cn/go.html">🚉</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【Linux】线程概念 | 同步</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2022-12-30 17:30:16</span> <span class="mobile">2022-12-30 17:30</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-01-10 13:07:29</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E7%8E%A9%E4%B8%8ALinux/">玩上Linux</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>4.6k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>除了线程互斥，我们还有线程同步，来康康吧</p><span id="more"></span><p>[TOC]</p><h1 id="1-为什么需要同步"><a href="#1-为什么需要同步" class="headerlink" title="1.为什么需要同步"></a>1.为什么需要同步</h1><p>在部分条件下，互斥是正确的，但是不合理。比如食堂打饭的时候，食堂阿姨一次只能给一个人打饭，于是就选择通过竞争来获得打饭的权利。此时就会出现有些线程因为优先级过低或者CPU调度问题，一直打不到饭，于是就出现了<strong>饥饿问题</strong>。</p><p>这是因为我们对多线程访问同一个资源没有进行限制，全靠CPU调度来决定运行顺序；所以我们需要对线程进行一定的控制，这就是<strong>线程同步</strong>的概念</p><ul><li>饥饿问题：某一个线程一直无法申请到某种资源（比如因为优先级过低）</li><li>同步：保证数据安全（临界资源访问）的前提下，让线程根据一定条件和顺序访问临界资源，从而避免饥饿问题</li><li>竞态条件：因为时序问题（CPU调度）而导致程序异常；</li></ul><h1 id="2-生产消费模型"><a href="#2-生产消费模型" class="headerlink" title="2.生产消费模型"></a>2.生产消费模型</h1><p>这个模型其实很简单，消费者去超市购买东西，生产者把商品投放到超市中。</p><ul><li>这时候就不需要消费者直接去找工厂问他xx东西又没有生产，他需要购买；而是转去超市里面购买xx东西；</li><li>如果xx东西没有货了，超市就会通知生产者进行补货。如果超市里面的货架已经满了，就通知生产者不需要继续生产了；</li><li>当商品没货了，超市会告知消费者这个东西没货，消费者会停止消费行为；而生产者补货了之后，超市就会通知消费者让他来购买</li></ul><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202301031841235.png" alt="image-20230103184124025"></p><p>在基础模式中，消费者要想知道一个东西有没有货，需要去超市里面看（相当于轮循检测）</p><p>我们可以引入一个<strong>通知方式</strong>，比如超市开放一个微信公众号，告知消费者xx物品是否有货，以及告知消费者什么时候需要补货，此时就不需要消费者和生产者<strong>不断询问</strong>超市关于一个商品的情况了！这就相当于<code>线程同步</code>！</p><h2 id="2-1-生产者和消费者的关系"><a href="#2-1-生产者和消费者的关系" class="headerlink" title="2.1 生产者和消费者的关系"></a>2.1 生产者和消费者的关系</h2><p>下面提到的是普适情况</p><ul><li>消费者有多个，他们之间是竞争关系（互斥）竞争商品的购买</li><li>生产者有多个，他们之间是竞争关系（互斥）竞争超市的货架</li><li>消费者和生产者之间，既有互斥关系，也是同步关系（需要生产者供货了之后，消费者才能消费）这两个关系并不冲突！</li></ul><p>除了上面提到的<strong>3种生产关系</strong>，还有下面俩点</p><p>在实际程序中，消费者和生产者都是由线程承担的（<strong>2种角色</strong>）</p><p>超市是内存中特定的一个数据结构，也是临界资源（<strong>1个交易场所</strong>）</p><blockquote><p>我们可以用<strong>321原则</strong>来快速记住这几条，这样就记住了生产消费模型！👍</p></blockquote><h2 id="2-2-以简单代码为例"><a href="#2-2-以简单代码为例" class="headerlink" title="2.2 以简单代码为例"></a>2.2 以简单代码为例</h2><p>在旧模式中，main函数调用另外一个函数，想获得返回值，需要等这个函数运行完毕；好比消费者购买东西，需要去找厂家并等待厂家生产……</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202301031903172.png" alt="image-20230103190310130"></p><p>而在生产消费者模型中，main作为主线程，只需要把待处理的数据丢进缓冲区；而线程B从缓冲区中取出数据，处理完毕后放回缓冲区。main可以先执行其他代码，过一会再过来拿线程B处理好的结果。</p><p>这就实现了<strong>生产和消费的解耦</strong>！</p><p><img lazyload alt="image" data-src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/img1/202301031904159.png" alt="image-20230103190405101"></p><hr><p>接下来我们就要解决下面这些问题😁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.如何让多个消费者线程等待呢?又如何让消费者线程被唤醒呢?</span><br><span class="line">2.如何让多个生产者线程等待呢?又如何让生产者线程被唤醒呢?</span><br><span class="line">3.如何衡量消费者和生产者所关心的条件是否就绪呢?</span><br></pre></td></tr></table></figure><p>而前面提到的通知方式，在linux系统中，就是<code>条件变量</code>了！</p><h1 id="3-条件变量接口"><a href="#3-条件变量接口" class="headerlink" title="3.条件变量接口"></a>3.条件变量接口</h1><h2 id="3-1-init-x2F-destroy"><a href="#3-1-init-x2F-destroy" class="headerlink" title="3.1 init&#x2F;destroy"></a>3.1 init&#x2F;destroy</h2><p>基本的接口和pthread库的其他接口很相似，都是一样的用法；其中<code>attr</code>也是设置条件变量的属性，这里置为nullptr即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure><h2 id="3-2-pthread-cond-wait"><a href="#3-2-pthread-cond-wait" class="headerlink" title="3.2 pthread_cond_wait"></a>3.2 pthread_cond_wait</h2><p>这两个接口都是让线程在一个条件变量下进行等待，其中<code>timewait</code>接口可以设置等待的时间（超时了就不等了）</p><p>条件变量也是临界资源，所以这里需要一个mutex锁来保证<strong>条件变量</strong>读写的原子性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                      <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><h2 id="3-3-pthrea-cond-signal-x2F-broadcast"><a href="#3-3-pthrea-cond-signal-x2F-broadcast" class="headerlink" title="3.3 pthrea_cond_signal&#x2F;broadcast"></a>3.3 pthrea_cond_signal&#x2F;broadcast</h2><p>这个接口的作用是给在条件变量下等待的线程发信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>其中<code>broadcast</code>是给在当前条件变量等待的<strong>所有线程</strong>发信号，而<code>signal</code>是发送信号，只唤醒一个线程；</p><p>如果调用成功，这两个函数都会返回0；否则返回错误码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       If  successful, the pthread_cond_broadcast() and pthread_cond_signal() functions shall return zero; otherwise, an error number shall</span><br><span class="line">       be returned to indicate the error.</span><br></pre></td></tr></table></figure><h2 id="3-4-代码示例"><a href="#3-4-代码示例" class="headerlink" title="3.4 代码示例"></a>3.4 代码示例</h2><p>下面这个代码可以很好的演示上面提到的多个接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">//锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;<span class="comment">//条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> quit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>*<span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!quit)<span class="comment">//这里有bug，后续会提到</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread is running... &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread quit... &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2,t3;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t3,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[a/b]$ &quot;</span>;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_broadcast</span>(&amp;cond);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            quit = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main break: &quot;</span> &lt;&lt; quit &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_broadcast</span>(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t3,<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次输入a，就<code>signal</code>会唤醒一个线程；每次输入b，会调用<code>broadcast</code>，唤醒当前所有线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test</span><br><span class="line">[a/b]$ a</span><br><span class="line">thread is running... t1</span><br><span class="line">[a/b]$ a</span><br><span class="line">thread is running... t2</span><br><span class="line">[a/b]$ a</span><br><span class="line">thread is running... t3</span><br><span class="line">[a/b]$ b</span><br><span class="line">thread is running... t1</span><br><span class="line">thread is running... t2</span><br><span class="line">thread is running... t3</span><br></pre></td></tr></table></figure><h3 id="3-4-1-小bug"><a href="#3-4-1-小bug" class="headerlink" title="3.4.1 小bug"></a>3.4.1 小bug</h3><p>上面的代码示例，会出现下面的问题，即我们输入除了a和b以外的所有字符，都应该会把全局变量<code>quit</code>改成true，让三个线程都退出</p><p>但观察到的现象却是只有一个线程退出了，其他线程阻塞等待了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test</span><br><span class="line">[a/b]$ q</span><br><span class="line">main break: 1</span><br><span class="line">thread is running... t3</span><br><span class="line">thread quit... t3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是因为<code>pthread_cond_wait</code>里面进行了<strong>独特的操作</strong>，即等待之前，它会释放锁，等待之后，他会重新申请锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                      <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_unlock(mutex);<span class="comment">//先解锁</span></span><br><span class="line">    <span class="comment">//避免因为该线程拿着锁去休眠了，导致其他线程无法申请该锁</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//条件变量相关代码</span></span><br><span class="line">	</span><br><span class="line">    pthread_mutex_lock(mutex);<span class="comment">//条件满足后，再加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个退出的线程，退出之前申请了锁却没有释放，于是就导致其他线程在<strong>条件满足后</strong>，没有办法申请锁，只能阻塞等待！</p><h3 id="3-4-2-修正"><a href="#3-4-2-修正" class="headerlink" title="3.4.2 修正"></a>3.4.2 修正</h3><p>修正的方法很简单，我们只需要在<code>while(!quit)</code>循环的退出条件满足之后，释放一下锁，就OK了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>*<span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!quit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread is running... &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//正确操作：需要在条件满足后，解锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread quit... &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就能看到，所有线程都正常退出了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test</span><br><span class="line">[a/b]$ q</span><br><span class="line">main break: 1</span><br><span class="line">thread is running... t1</span><br><span class="line">thread quit... t1</span><br><span class="line">thread is running... t2</span><br><span class="line">thread quit... t2</span><br><span class="line">thread is running... t3</span><br><span class="line">thread quit... t3</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$</span><br></pre></td></tr></table></figure><h3 id="3-4-3-典型错误"><a href="#3-4-3-典型错误" class="headerlink" title="3.4.3 典型错误"></a>3.4.3 典型错误</h3><p>根据这点，就能引出一个比较典型的错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (condition_is_false) &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_cond_wait(&amp;cond);<span class="comment">//解锁和加锁的操作，该函数会帮我们完成</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);<span class="comment">//二次申请同一把锁，出现死锁！</span></span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>两次申请同一把锁，就好比自己把自己绊倒了😂我们要避免写出这样的错误代码！</p><hr><h1 id="4-阻塞队列-生产消费模型实例"><a href="#4-阻塞队列-生产消费模型实例" class="headerlink" title="4.阻塞队列-生产消费模型实例"></a>4.阻塞队列-生产消费模型实例</h1><p>这个队列的作用，就是提供一个超市，供生产者和消费者进行数据的交换</p><ul><li>生产者，往队列里面push数据</li><li>消费者，从队列里面pop数据</li></ul><p>看起来有些类似于管道，同样的，生产者和消费者在读取阻塞队列的时候，不仅需要保证自己的操作是原子操作，还需要做到一定的<code>访问控制</code>；即消费者在队列空的时候不能继续pop，生产者在队列满的时候不能继续push</p><p>此时，我们还可以引入一个<code>微信公众号</code>，也就是一定的通知方式：不要让生产者、消费者疯狂检测阻塞队列，而是引入条件变量，在队列不为空的时候，通知消费者；在队列不为满的时候，通知生产者；这样就达到了线程之间的同步。</p><h2 id="4-1-成员变量"><a href="#4-1-成员变量" class="headerlink" title="4.1 成员变量"></a>4.1 成员变量</h2><p>要实现阻塞队列，我们首先需要理清楚需要什么成员变量，来保护该队列</p><ul><li>用于访问控制的锁，同一时刻只能有一个线程访问队列</li><li>用户线程同步的条件变量，因为我们需要在不同的条件下通知不同的人，所以需要2个条件变量</li><li>一个队列，为了方便，采用<code>std::queue</code>，这样就不用自己造轮子了</li></ul><p>理清楚了之后，就可以来写成员变量啦；我采用了模板类型，这样阻塞队列就可以用来存放任何我们想要的类型了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;T&gt; _bq;<span class="comment">//队列</span></span><br><span class="line">    <span class="type">size_t</span> _size;<span class="comment">//大小</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> _mutex;<span class="comment">//锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> _proInf;<span class="comment">//通知生产者</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> _conInf;<span class="comment">//通知消费者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlockQueue</span>(<span class="type">int</span> sz=<span class="number">5</span>)</span><br><span class="line">        :_size(sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;_mutex,<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;_proInf,<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;_conInf,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">BlockQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;_mutex);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;_proInf);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;_conInf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可能想问，queue不是有封装size吗？哪这里我们还定义一个大小变量，会不会有些多余？</p><p>nope！实际上，这里的这个<code>_size</code> 就好比我们在C语言写顺序表的时候，成员<code>capacity</code>；其作用是来判断我们的队列<strong>有没有满</strong>的。</p><hr><h2 id="4-2-push和pop"><a href="#4-2-push和pop" class="headerlink" title="4.2 push和pop"></a>4.2 push和pop</h2><p>对于一个队列，最重要的操作就是在队头出数据，队尾入数据</p><p>简单说来，就是需要在处理队列数据的时候进行加锁，保证原子性；</p><p>除此以外，生产者和消费者有不同的操作逻辑：</p><ul><li>生产<ul><li>判断是否符合生产条件（队列没有满）</li><li>满，不生产；不满，生产；</li><li>满了的时候，生产者应在条件变量中等待（等待消费者消费）</li><li>不满的时候，生产者生产，并通知消费者来消费</li></ul></li><li>消费<ul><li>判断是否满足消费条件（队列不为空）</li><li>空，不消费；不空，消费；</li><li>空了的时候，消费者应该在条件变量中等待（等待生产者生产）</li><li>不空的时候，消费者消费，并通知生产者继续生产</li></ul></li></ul><p>这样就实现了阻塞队列push和pop的基本逻辑；由此可以写出下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者消费</span></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;_mutex);</span><br><span class="line">    <span class="comment">//判断条件</span></span><br><span class="line">    <span class="keyword">if</span>(_size)<span class="comment">//空，不消费</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;_conInf,&amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费并通知生产者</span></span><br><span class="line">    T tmp = _bq.<span class="built_in">front</span>();</span><br><span class="line">    _bq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;_proInf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;_mutex);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者生产</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;_mutex);</span><br><span class="line">    <span class="comment">//判断条件</span></span><br><span class="line">    <span class="keyword">if</span>(bq.<span class="built_in">size</span>()&gt;=_size)<span class="comment">//满，不生产</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;_proInf,&amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产并通知消费者</span></span><br><span class="line">    _bq.<span class="built_in">push</span>(in);</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;_conInf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-1-运行测试"><a href="#4-2-1-运行测试" class="headerlink" title="4.2.1 运行测试"></a>4.2.1 运行测试</h3><p>有了这个基本框架，我们就可以来测试一下代码啦！</p><p>先来一个生产者和消费者康康吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">consume</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockQueue&lt;<span class="type">int</span>&gt; *bqp = (BlockQueue&lt;<span class="type">int</span>&gt; *)args;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line">        <span class="type">int</span> ret = bqp-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;consume &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; 消费：&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">produce</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockQueue&lt;<span class="type">int</span>&gt; *bqp = (BlockQueue&lt;<span class="type">int</span>&gt; *)args;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 制作</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;########↓&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 投放到超市</span></span><br><span class="line">        bqp-&gt;<span class="built_in">push</span>(a);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;produce &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; 生产：&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="function">BlockQueue&lt;<span class="type">int</span>&gt; <span class="title">bq</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,produce,(<span class="type">void</span>*)&amp;bq);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,consume,(<span class="type">void</span>*)&amp;bq);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，刚开始消费者并没有运行，而是等待生产者生产出数据了之后，再开始消费！我们的目的成功达成！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./test</span><br><span class="line">########↓</span><br><span class="line">produce 139716365768448 生产：41</span><br><span class="line">########↓</span><br><span class="line">produce 139716365768448 生产：11</span><br><span class="line">consume 139716357375744 消费：41</span><br><span class="line">########↓</span><br><span class="line">produce 139716365768448 生产：19</span><br><span class="line">consume 139716357375744 消费：11</span><br><span class="line">########↓</span><br><span class="line">produce 139716365768448 生产：19</span><br><span class="line">consume 139716357375744 消费：19</span><br><span class="line">########↓</span><br><span class="line">produce 139716365768448 生产：25</span><br><span class="line">consume 139716357375744 消费：19</span><br><span class="line">########↓</span><br><span class="line">produce 139716365768448 生产：63</span><br><span class="line">consume 139716357375744 消费：25</span><br></pre></td></tr></table></figure><p>如果增加线程到2生产2消费，则会看到下面的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./test</span><br><span class="line">########↓</span><br><span class="line">produce 140483816179456 生产：51</span><br><span class="line">consume 140483807786752 消费：51</span><br><span class="line">########↓</span><br><span class="line">produce 140483799394048 生产：38</span><br><span class="line">consume 140483791001344 消费：38</span><br><span class="line">########↓</span><br><span class="line">produce 140483816179456 生产：37</span><br><span class="line">consume 140483807786752 消费：37</span><br></pre></td></tr></table></figure><p>每次被唤醒的生产者和消费者都是不一样的，交替唤醒</p><h3 id="4-2-2-进一步封装"><a href="#4-2-2-进一步封装" class="headerlink" title="4.2.2 进一步封装"></a>4.2.2 进一步封装</h3><p>为了代码的可读性，我们可以对阻塞队列进一步封装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;T&gt; _bq;<span class="comment">//队列</span></span><br><span class="line">    <span class="type">size_t</span> _size;<span class="comment">//大小</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> _mutex;<span class="comment">//锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> _proInf;<span class="comment">//通知生产者</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> _conInf;<span class="comment">//通知消费者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlockQueue</span>(<span class="type">int</span> sz=<span class="number">5</span>)</span><br><span class="line">        :_size(sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;_mutex,<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;_proInf,<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;_conInf,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">BlockQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;_mutex);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;_proInf);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;_conInf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费者消费</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        <span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//判断条件</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())<span class="comment">//空，不消费</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ConWait</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费并通知生产者</span></span><br><span class="line">        T tmp = _bq.<span class="built_in">front</span>();</span><br><span class="line">        _bq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">WakeUpPro</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        <span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产者生产</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        <span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//判断条件</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isFull</span>())<span class="comment">//满，不生产</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ProWait</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产并通知消费者</span></span><br><span class="line">        _bq.<span class="built_in">push</span>(in);</span><br><span class="line">        <span class="built_in">WakeUpCon</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        <span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒消费者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WakeUpCon</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;_conInf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒生产者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WakeUpPro</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;_proInf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费者等待</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;_conInf,&amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产者等待</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;_proInf,&amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断条件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size == _bq.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _bq.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-使用task分配运算任务"><a href="#4-2-3-使用task分配运算任务" class="headerlink" title="4.2.3 使用task分配运算任务"></a>4.2.3 使用task分配运算任务</h3><p>因为阻塞队列是用模板类型的，我们可以自己实现一个<code>仿函数</code>，来给生产者消费者分配任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> one=<span class="number">0</span>, <span class="type">int</span> two=<span class="number">0</span>, <span class="type">char</span> op=<span class="string">&quot;+&quot;</span>) </span><br><span class="line">        : _elem1(one), _elem2(two), _operator(op)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 仿函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运行仿函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (_operator)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            result = _elem1 + _elem2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            result = _elem1 - _elem2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            result = _elem1 * _elem2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_elem2 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;div zero, abort&quot;</span> &lt;&lt; endl;</span><br><span class="line">                result = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = _elem1 / _elem2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_elem2 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;mod zero, abort&quot;</span> &lt;&lt; endl;</span><br><span class="line">                result = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = _elem1 % _elem2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;unknown: &quot;</span> &lt;&lt; _operator &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取元素，方便打印</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> *e1, <span class="type">int</span> *e2, <span class="type">char</span> *op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        *e1 = _elem1;</span><br><span class="line">        *e2 = _elem2;</span><br><span class="line">        *op = _operator;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _elem1;</span><br><span class="line">    <span class="type">int</span> _elem2;</span><br><span class="line">    <span class="type">char</span> _operator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">string ops =<span class="string">&quot;+-*/%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">consumer</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockQueue&lt;Task&gt; *bqp = (BlockQueue&lt;Task&gt; *)args;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Task t = bqp-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">t</span>();    <span class="comment">//处理任务</span></span><br><span class="line">        <span class="type">int</span> one, two;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        t.<span class="built_in">get</span>(&amp;one, &amp;two, &amp;op);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;consumer [&quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot; 消费了一个任务: &quot;</span> &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockQueue&lt;Task&gt; *bqp = (BlockQueue&lt;Task&gt; *)args;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 制作任务</span></span><br><span class="line">        <span class="type">int</span> one = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> two = <span class="built_in">rand</span>() % <span class="number">20</span>;</span><br><span class="line">        <span class="type">char</span> op = ops[<span class="built_in">rand</span>() % ops.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="function">Task <span class="title">t</span><span class="params">(one, two, op)</span></span>;</span><br><span class="line">        <span class="comment">// 投放给消费者生产</span></span><br><span class="line">        bqp-&gt;<span class="built_in">push</span>(t);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;producter[&quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot; 生产了一个任务: &quot;</span> &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; <span class="string">&quot; = ?&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="function">BlockQueue&lt;Task&gt; <span class="title">bq</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,producer,(<span class="type">void</span>*)&amp;bq);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,consumer,(<span class="type">void</span>*)&amp;bq);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>));<span class="comment">//乘一个数字添加随机性</span></span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，可以看到生产者生产了问题之后，消费者会去解答。此时我们只需要在线程中取回运算好的结果，就OK了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./test</span><br><span class="line">producter[140703422265088] 1673319321 生产了一个任务: 43-16 = ?</span><br><span class="line">consumer [140703413872384] 1673319322 消费了一个任务: 43-16 = 27</span><br><span class="line">producter[140703422265088] 1673319322 生产了一个任务: 45/12 = ?</span><br><span class="line">consumer [140703413872384] 1673319322 消费了一个任务: 45/12 = 3</span><br><span class="line">producter[140703422265088] 1673319323 生产了一个任务: 17/7 = ?</span><br><span class="line">consumer [140703413872384] 1673319323 消费了一个任务: 17/7 = 2</span><br><span class="line">producter[140703422265088] 1673319324 生产了一个任务: 49-14 = ?</span><br><span class="line">consumer [140703413872384] 1673319324 消费了一个任务: 49-14 = 35</span><br><span class="line">producter[140703422265088] 1673319325 生产了一个任务: 4%4 = ?</span><br><span class="line">consumer [140703413872384] 1673319325 消费了一个任务: 4%4 = 0</span><br></pre></td></tr></table></figure><hr></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【Linux】线程概念 | 同步</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2022-12-30 17:30:16</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2022/12/30/note_Linux/20线程同步/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E7%BA%BF%E7%A8%8B/">#线程</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2023/01/05/tools/wikijs%E4%BD%BF%E7%94%A8artalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【Artalk】在wiki js站点上使用Artalk评论系统</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/12/23/%E5%8D%9A%E5%AE%A2%E8%A1%A8%E6%83%85%E5%8C%85/"><span class="title flex-center"><span class="post-nav-title-item">【图床】博客表情包</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="//img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/waline.css"><link rel="stylesheet" href="//img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/waline-meta.css"><script data-pjax src="//img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://vrcl.outpost54.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true'
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5"><span class="nav-text">1.为什么需要同步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.生产消费模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">2.1 生产者和消费者的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E4%BB%A5%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BE%8B"><span class="nav-text">2.2 以简单代码为例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">3.条件变量接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-init-x2F-destroy"><span class="nav-text">3.1 init&#x2F;destroy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-pthread-cond-wait"><span class="nav-text">3.2 pthread_cond_wait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-pthrea-cond-signal-x2F-broadcast"><span class="nav-text">3.3 pthrea_cond_signal&#x2F;broadcast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.4 代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E5%B0%8Fbug"><span class="nav-text">3.4.1 小bug</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E4%BF%AE%E6%AD%A3"><span class="nav-text">3.4.2 修正</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E5%85%B8%E5%9E%8B%E9%94%99%E8%AF%AF"><span class="nav-text">3.4.3 典型错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="nav-text">4.阻塞队列-生产消费模型实例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">4.1 成员变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-push%E5%92%8Cpop"><span class="nav-text">4.2 push和pop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="nav-text">4.2.1 运行测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%B0%81%E8%A3%85"><span class="nav-text">4.2.2 进一步封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E4%BD%BF%E7%94%A8task%E5%88%86%E9%85%8D%E8%BF%90%E7%AE%97%E4%BB%BB%E5%8A%A1"><span class="nav-text">4.2.3 使用task分配运算任务</span></a></li></ol></li></ol></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep%20v3.6.1-blue" height="20px"> </a><a href="https://www.travellings.cn/go.html" target="_blank"><img src="https://img-7758-typora.oss-cn-shanghai.aliyuncs.com/hexo/travellingICON.gif" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054%E5%8F%B7-ff69b4" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>