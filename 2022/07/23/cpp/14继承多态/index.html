<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><script>"https://blog.musnow.top"!=window.location.href&&window.alert("您当前访问的是镜像站点，主站为 https://blog.musnow.top")</script><title>【C++】继承多态详解(未完成) | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【C++】继承多态详解(未完成)</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2022-07-23 21:10:46</span> <span class="mobile">2022-07-23 21:10</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-03-11 19:25:36</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E9%81%87%E8%A7%81C/">遇见C++</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/C/">C++</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>4.9k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>在之前的CPP大作业中，为了应付期末（是这样的）关于继承和多态部分的内容只是<strong>草草过了一遍</strong>，并没有深挖背后的实现原理，以及使用的时候一些注意事项。</p><p>本篇博客是对类和对象<strong>继承多态</strong>部分的深化！</p><span id="more"></span><p>[TOC]</p><h1 id="1-继承派生关系"><a href="#1-继承派生关系" class="headerlink" title="1.继承派生关系"></a>1.继承派生关系</h1><p>继承是提高代码复用性的一个重要手段。它允许我们在保持基类原有属性的基础上，对其进行一定的扩张，增加不同的功能以应对实际情况。</p><p>与其相似的增加代码复用性的语法，还有<strong>模板</strong></p><h2 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h2><p>继承和派生是父与子的关系，其中子类拥有父类成员的同时，还会拥有自己的成员</p><ul><li>继承是一个特殊的语法，用于多个类有公共部分的时候</li><li>父类：基类</li><li>子类：派生类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例：网站的公共部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ART</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; <span class="string">&quot;归档&quot;</span> &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;关于我们&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;网站访问量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//文章页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LINK</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; <span class="string">&quot;归档&quot;</span> &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;关于我们 &quot;</span> &lt;&lt; <span class="string">&quot; 网站访问量&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//友链页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的情况中，ART和LINK类中都有网站的公共部分，这时候就出现了代码的重复。继承的出现就是用于解决这个问题的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面使用继承的方式来写，WEB类是网站的公共部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WEB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; <span class="string">&quot;归档&quot;</span> &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;关于我们&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;网站访问量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ART、LINK是两个子类，继承了WEB的公共部分</span></span><br><span class="line"><span class="comment">//这样就减少了代码量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ART</span> : <span class="keyword">public</span> WEB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//文章页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LINK</span> : <span class="keyword">public</span> WEB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//友链页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试可以发现，ART和LINK作为派生类，在继承了基类WEB的成员的基础上，还拥有了它们独特的单独成员</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272021620.png" alt="image-20220527202138439"></p><p>同一个类可以同时继承多个基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-权限问题"><a href="#1-2-权限问题" class="headerlink" title="1.2 权限问题"></a>1.2 权限问题</h2><p>继承有3中类型：public、private、protected。这里会显示出类中protected权限和private权限的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们分别用上面三种方式对类A进行继承的时候，得到的结果是不同的</p><ul><li>用什么继承方式，派生类中继承的成员就变成什么类型</li><li>不管用什么继承方式，都无法访问基类中的私有成员</li></ul><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272034572.png" alt="image-20220527203404310"></p><p>关于权限问题，我们还需要了解下面几点：</p><ul><li>基类的私有成员在派生类中不可见，但实际上它也被继承过去了。但是编译器和语法的限制让我们无法访问。</li><li>保护限定符由此出现，如果在基类中的成员不想被外界直接访问，则可以定义为保护</li><li>class默认继承方式为私有，struct默认继承方式为保护</li><li>实际中我们一般使用public继承，保护&#x2F;私有方式不利于维护和拓展</li></ul><h2 id="1-3-同名问题（作用域）"><a href="#1-3-同名问题（作用域）" class="headerlink" title="1.3 同名问题（作用域）"></a>1.3 同名问题（作用域）</h2><p>在继承体系中，基类和子类都有自己独立的作用域</p><p>当基类和派生类中出现同名成员函数或者同名成员变量时，会出现冲突。这时候编译器会做一定的处理：直接访问变量名和函数名的时候，优先访问派生类自己的成员，而屏蔽掉基类的。</p><p>这种情况被称之为<code>隐藏</code>：</p><ul><li>函数名相同构成隐藏（并非重载）</li><li>成员变量名相同构成隐藏</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承同名成员的处理</span></span><br><span class="line"><span class="comment">//	普通的同名成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DAD1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DAD1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_a = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD func int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;<span class="comment">//基类中的该变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SON1</span> : <span class="keyword">public</span> DAD1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SON1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;SON: &quot;</span> &lt;&lt; _a &lt;&lt; endl;<span class="comment">//优先访问派生类的_a</span></span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;DAD: &quot;</span> &lt;&lt; DAD1::_a &lt;&lt; endl;<span class="comment">//访问基类的_a</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;SON func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;<span class="comment">//派生类的同名变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272044379.png" alt="image-20220527204445283"></p><p>实际操作中，不建议写同名的成员</p><h2 id="1-4-静态成员"><a href="#1-4-静态成员" class="headerlink" title="1.4 静态成员"></a>1.4 静态成员</h2><p>在继承体系中，基类的静态成员有且只能有一个。即所有的子类和他们的对象，都是只有那一个静态成员的。我们可以用这个特性来对继承派生中出现的<strong>对象</strong>进行计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="built_in">Person</span> () &#123;++ _count ;&#125;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	string _name ; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _count; <span class="comment">// 统计人的个数。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person :: _count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果出现了与静态成员同名，访问方法就有所变化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问同名的静态成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DAD2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> D_a;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD2 Test1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD2 Test1(int)  &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DAD2::D_a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SON2</span> : <span class="keyword">public</span> DAD2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> D_a;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;SON2 Test1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> SON2::D_a = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272049585.png" alt="image-20220527204928480"></p><h2 id="1-5-友元"><a href="#1-5-友元" class="headerlink" title="1.5 友元"></a>1.5 友元</h2><p>友元关系不会被继承，基类的友元函数无法访问派生类的<code>私有/保护</code>成员</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202207222001980.png" alt="image-20220722200127880"></p><h2 id="1-6-默认成员函数"><a href="#1-6-默认成员函数" class="headerlink" title="1.6 默认成员函数"></a>1.6 默认成员函数</h2><p>我们知道，C++类和对象中有6个默认成员函数</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205191810112.png" alt="image-20220519181052014"></p><p>在派生类中，这些默认成员函数有新的使用方法</p><ul><li>派生类的构造函数必须在初始化列表中调用基类的构造函数，初始化父类的一部分成员。如果你没有写，编译器会自动调用默认构造函数（先调用基类，在调用子类）</li><li>派生类的拷贝构造同上，必须显式调用基类拷贝构造函数</li><li>派生类的赋值重载也需要调用基类赋值重载完成操作</li><li>派生类的析构函数编译器会自动调用基类，先析构派生类，再析构基类成员（符合栈后进先出原则）</li><li>在基类析构函数不是<strong>虚析构</strong>的时候，<strong>子类析构和父类析构</strong>构成<code>隐藏</code>关系</li></ul><hr><h3 id="构造和析构顺序"><a href="#构造和析构顺序" class="headerlink" title="构造和析构顺序"></a>构造和析构顺序</h3><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><ul><li>继承中先调用父类构造函数</li><li>再调用子类构造函数</li></ul><p>析构顺序与构造相反</p><h3 id="显示调用构造函数"><a href="#显示调用构造函数" class="headerlink" title="显示调用构造函数"></a>显示调用构造函数</h3><p>如何显示调用构造函数呢，下面是一个代码示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, string sex, <span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _sex = sex;</span><br><span class="line">        _age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line">    string _sex;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string name,string sex,<span class="type">int</span> age,<span class="type">int</span> no)</span><br><span class="line">        :<span class="built_in">Person</span>(name,sex,age),</span><br><span class="line">        _No(no)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _No;<span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">sobj</span><span class="params">(<span class="string">&quot;李华&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">18</span>,<span class="number">1000</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，可见子类正常调用了基类构造函数并进行了初始化</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202207231840530.png" alt="image-20220723184035493"></p><h2 id="1-7-基类和派生类赋值问题"><a href="#1-7-基类和派生类赋值问题" class="headerlink" title="1.7 基类和派生类赋值问题"></a>1.7 基类和派生类赋值问题</h2><p>派生类成员可以赋值给基类的 对象&#x2F;指针&#x2F;引用。一般我们把这种情况称为<code>切片</code>，形象地表示把派生类中父类那部分切来赋值过去。</p><p>但是！反过来是不行的哦，你不能把基类对象赋值给派生类对象。</p><blockquote><p>基类的指针&#x2F;引用可以用强制类型转换给基类的指针&#x2F;引用。但是这样不够安全，除非基类的指针指向的是对应的派生类。</p><p>如果基类是多态类型，可以使用<code>dynamic_cast</code>来进行安全处理</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    string _name;</span><br><span class="line">    string _sex; </span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> _No ;<span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student sobj ;</span><br><span class="line">    <span class="comment">// 1.子类对象可以赋值给父类对象/指针/引用</span></span><br><span class="line">    Person pobj = sobj ;</span><br><span class="line">    Person* p1 = &amp;sobj;</span><br><span class="line">    Person&amp; p2 = sobj;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//2.基类对象不能赋值给派生类对象</span></span><br><span class="line">    <span class="comment">//sobj = pobj;//err</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.基类的指针可以通过强制类型转换赋值给派生类的指针</span></span><br><span class="line">    p1 = &amp;sobj;<span class="comment">//子类对象给基类指针</span></span><br><span class="line">    Student* ps1 = (Student*)p1; <span class="comment">//基类指针指向子类，正常转换</span></span><br><span class="line">    ps1-&gt;_No = <span class="number">15</span>; </span><br><span class="line">    cout&lt;&lt;ps1-&gt;_No &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    p1 = &amp;pobj;<span class="comment">//基类对象给基类指针</span></span><br><span class="line">    Student* ps2 = (Student*)p1; <span class="comment">//转换虽然可以，但是会存在越界访问</span></span><br><span class="line">    ps2-&gt;_No = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;ps2-&gt;_No &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202207231830411.png" alt="image-20220723182953327"></p><p>关于最后提到的越界访问问题，我们知道，指针变量的大小都是相同的，其指针类型的区别主要在访问能力的不同。比如<code>char*</code>指针解引用只能访问1个字节，<code>int*</code>指针解引用可以访问4个字节，以此类推，<code>Student*</code>指针解引用可以访问<code>sizeof(Student)</code>个字节的空间。</p><p>而子类对象的大小都是大于等于基类对象的大小的。这就导致子类指针访问基类对象内容时，一次解引用访问的空间超长，造成了越界访问</p><hr><p>实际上，当我们切片讲子类对象赋值给父类对象的时候，编译器会进行切片操作，即新的父类对象中的内容只会包含父类的成员。子类多出去的那一部分成员会被剔除。</p><p>这一点我们可以在VS的调试中证实</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202207231839825.png" alt="image-20220723183948793"></p><p>因为基类的成员变量被设置成了保护，所以我们不能直接在外部进行修改。需要显式调用基类的构造函数</p><h2 id="1-8-虚继承（菱形继承问题）"><a href="#1-8-虚继承（菱形继承问题）" class="headerlink" title="1.8 虚继承（菱形继承问题）"></a>1.8 虚继承（菱形继承问题）</h2><p>有的时候，继承会出现下面这种情况：一个子类继承了两个基类，而这两个基类又同时是一个基类的派生类</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205280831658.jpg" alt="未命名_副本"></p><p>这时候，D里面就会有两份A的内容，相当于两份公共部分。这是我们不想看到的，因为会造成空间浪费。而且直接访问的时候，编译器会报错“对变量X的访问不明确”</p><hr><p>比如：intel和amd联合推出的NUC小电脑中，有一款CPU是他们合作开发的</p><p>如何解决同时继承AMD和INTEL的问题？</p><ul><li>这时候会出现两个同名变量，一个是AMD里面有的，另外一个是INTEL里面有的<br>因为他们是从CPU里面继承来的。</li><li>虽然我们可以指定作用域来分别修改和访问。但是实际上这个公共部分就出现了浪费（比如是网站的公共部分，多给你一份没有啥意义）</li></ul><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272058955.png" alt="image-20220527205808893"></p><p>和前面说道的同名问题一样，我们可以指定作用域来访问特定的变量，但是这样是治标不治本的方法，并没有解决空间浪费的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方法1（治表不治本）</span></span><br><span class="line"><span class="comment">//用类域来修改和访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;intel: &quot;</span> &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;amd: &quot;</span>   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这就需要我们使用<strong>虚继承</strong>来操作：给B和C对A的继承加上<code>virtural</code>关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CPU</span>()</span><br><span class="line">		:_Structure(<span class="string">&quot;x86&quot;</span>)</span><br><span class="line">	&#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> _Structure[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">INTEL</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> CPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">INTEL</span>()</span><br><span class="line">		:<span class="built_in">i_Brand</span>(<span class="string">&quot;intel&quot;</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> i_Brand[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMD</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> CPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AMD</span>()</span><br><span class="line">		:<span class="built_in">a_Brand</span>(<span class="string">&quot;amd&quot;</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> a_Brand[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时继承AMD和INTEL</span></span><br><span class="line"><span class="comment">//相当于有两个_Structure变量</span></span><br><span class="line"><span class="comment">//实际上我们只需要一个就够了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NUC</span> :<span class="keyword">public</span> AMD, <span class="keyword">public</span> INTEL &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NUC n1;</span><br><span class="line">	<span class="comment">//对“_Structure”的访问不明确</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; n1._Structure &lt;&lt; endl;//err</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//解决方法1（治表不治本）</span></span><br><span class="line">	<span class="comment">//用类域来修改和访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;intel: &quot;</span> &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;amd: &quot;</span>   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解决方法2，在AMD和INTEL对CPU的继承上加virtual</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;n1访问：&quot;</span> &lt;&lt; n1._Structure &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//现在就没有报错了</span></span><br><span class="line">	<span class="comment">//因为这时候AMD和INTEL中的_Structure都会指向同一个地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;intel: &quot;</span> &lt;&lt; &amp;(n1.INTEL::_Structure) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;amd:   &quot;</span> &lt;&lt; &amp;(n1.AMD::_Structure) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改INTEL中的_Structure，也会连代修改AMD中的_Structure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候直接访问变量就不会报错了。因为这时候，B和C中的该变量指向了同一个地址，修改操作会同步。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272057303.png" alt="image-20220527205708237"></p><h3 id="继承模型"><a href="#继承模型" class="headerlink" title="继承模型"></a>继承模型</h3><p>这种虚继承的模型是什么样子的呢？进入调试窗口，可以看到这里分别分为了3个模块，保存了不同基类的成员。而它们之中的<code>_Stucture</code>成员只有一个，不会出现异义</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202207231901496.png" alt="image-20220723190101443"></p><p>那这里空着的空间是用来做什么的呢？是内存对齐吗？</p><p>非也！</p><h3 id="虚基表"><a href="#虚基表" class="headerlink" title="虚基表"></a>虚基表</h3><p>下图能帮你了解这个内存的区块是怎么划分的</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202207232021030.png" alt="image-20220723202104931"></p><p>这样做就有一个好处，即便我们使用不同的基类指针（比如amd或者intel）来指向nuc的子类对象，它们都可以通过虚基表里面存放的偏移量来计算CPU成员的位置。从而避免了出现异义的问题。</p><hr><p>而如果我们在继承的时候去掉<code>virtual</code>关键字，即使用普通继承，它的继承模型又会不同</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202207232025279.png" alt="image-20220723202515227"></p><p>这里就因为内存对齐的问题，我们无法看清楚它的全貌。不过在菱形继承问题中，不使用虚继承会造成两个CPU对象的继承，导致访问不明确的特性是可以看出来的。</p><h2 id="1-9-继承和组合"><a href="#1-9-继承和组合" class="headerlink" title="1.9 继承和组合"></a>1.9 继承和组合</h2><ul><li>继承：上述所说。每一个派生类对象都是一个基类对象<code>is-a</code></li><li>组合：在一个类里面包含另外一个类的对象成员。每一个B对象中都包含了一个A <code>has-a</code></li></ul><p>实际情况中，建议优先选择组合，而不是继承。</p><ul><li>继承增加了代码的复用性，但是在一定程度上破坏了基类的封装性。派生类和基类的关联很强，耦合度高。</li><li>对象组合是另外一种复用的选择，这时候，对象A的内部结构是不得而知的。这样就减小了对象之间的关联性，耦合度低，保护了封装，更方便代码的维护</li></ul><p>不过，继承还有另外一种用途，那就是多态。我们下边会讲解的！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多继承所导致的菱形继承问题，在一定程度上让C++的语法变得复杂了。比如java是没有多继承的。在实际使用情况中，不建议使用多继承。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202207280837462.jpg" alt="QQ图片20220424132540"></p><h1 id="2-多态"><a href="#2-多态" class="headerlink" title="2.多态"></a>2.多态</h1><ul><li>静态多态：运算符重载</li><li>动态多态：派生类和虚函数组成的多态</li></ul><p>多态通俗地讲就是多种形态，当不同的对象去完成相同的事情的时候，会产生不同的状态。</p><h2 id="2-1-虚函数"><a href="#2-1-虚函数" class="headerlink" title="2.1 虚函数"></a>2.1 虚函数</h2><h3 id="2-1-1-基本使用以及动态多态"><a href="#2-1-1-基本使用以及动态多态" class="headerlink" title="2.1.1 基本使用以及动态多态"></a>2.1.1 基本使用以及动态多态</h3><p>虚函数，并不代表这个函数是虚无的。而表示这个函数在一定情况下会被替换（就好比继承中的虚继承问题）。要实现动态多态，就需要借助虚函数来实现。以下面这个动物说话的代码为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//void Talk()</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Talk</span><span class="params">()</span><span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal is talking&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAT</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Talk</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CAT is talking&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DOG</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Talk</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DOG is talking&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类中不使用虚函数时，该函数的内容已确定</span></span><br><span class="line"><span class="comment">//不管传参什么类，都会调用Animal自己的Talk函数</span></span><br><span class="line"><span class="comment">//加上虚函数virtual后，会调用CAT和DOG的Talk函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MakeTalk</span><span class="params">(Animal&amp; it)</span> </span>&#123;</span><br><span class="line">	it.<span class="built_in">Talk</span>();<span class="comment">//调用对应的Talk函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当基类Animal中的Talk函数没有用virtual修饰时，不管给这个函数传参什么类的对象，它都会调用Animal自己的Talk函数</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272139327.png" alt="image-20220527213937251"></p><p>当我们用虚函数进行修饰后，就会调用派生类CAT和DOG的Talk函数，这就实现了一个简单的动态多态。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272140385.png" alt="image-20220527214022282"></p><p>对于虚函数，有几点需要注意：</p><ul><li>当基类的指针或引用指向派生类的对象时，就会触发动态多态，派生类中的同名函数会覆写基类中的虚函数</li><li>不能定义静态虚函数——因为静态函数是属于整个类的，而不是属于某一个对象</li><li>不能定义虚构造函数——总不能用派生类的构造来覆写基类的构造吧？</li><li>析构函数可以是虚函数</li></ul><h3 id="2-1-2-虚析构函数"><a href="#2-1-2-虚析构函数" class="headerlink" title="2.1.2 虚析构函数"></a>2.1.2 虚析构函数</h3><p>有的时候，我们需要析构一个子类对象时，往往会给<strong>基类</strong>的析构函数加上virtual修饰，这样只要传派生类的对象给基类的指针&#x2F;引用，就可以直接调用派生类对应的析构函数，完成不同的析构操作。而不是都呆呆的调用基类的析构函数——那样就会产生内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Queue</span>()</span><br><span class="line">		:_a(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Queue</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[] _a;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>* _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> :<span class="keyword">public</span> Queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyStack</span>(<span class="type">int</span> capa)</span><br><span class="line">		:_a1(<span class="keyword">new</span> <span class="type">int</span>[capa])</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">MyStack</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~MyStack&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[] _a1;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>* _a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue* q1=<span class="keyword">new</span> <span class="built_in">MyStack</span>(<span class="number">4</span>);<span class="comment">//父类指针指向子类</span></span><br><span class="line">	<span class="keyword">delete</span> q1;<span class="comment">//调用子类的析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-纯虚函数"><a href="#2-2-纯虚函数" class="headerlink" title="2.2 纯虚函数"></a>2.2 纯虚函数</h2><p>在虚函数的基础上，C++定义了纯虚函数：有些时候，在基类里面定义某一个函数是没有意义的，这时候我们可以把它定义为<strong>纯虚函数</strong>，具体的实现让派生类去同名覆写。</p><p>纯虚函数的基本形式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//virtual 函数返回类型 函数名()=0;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>派生类中必须重写基类的纯虚函数，否则该类也是抽象类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//virtual void Print();//虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B print &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C print &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在派生类中覆写了该函数后，即可实例化对象并调用该函数</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272207840.png" alt="image-20220527220700695"></p><p>和虚函数一样，使用基类的引用或指针来接收派生类的对象，即可调用对应的函数</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272209664.png" alt="image-20220527220929573"></p><h2 id="2-3-抽象类"><a href="#2-3-抽象类" class="headerlink" title="2.3 抽象类"></a>2.3 抽象类</h2><p>包含纯虚函数的类就是抽象类，抽象类有下面几个特点：</p><ul><li>抽象类无法实例化对象</li><li>抽象类的派生类必须重写基类的纯虚函数，不然派生类也是抽象类</li><li>如果在基类中定义的纯虚函数是const修饰的，则派生类中对应的函数也需要用const修饰</li></ul><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202205272205203.png" alt="image-20220527220539119"></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【C++】继承多态详解(未完成)</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2022-07-23 21:10:46</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2022/07/23/cpp/14继承多态/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/C/">#C++</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/08/01/cpp/15%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E9%98%B6/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【C++】搜索二叉树/KVL树</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/07/18/cpp/13STL_stack_queue/"><span class="title flex-center"><span class="post-nav-title-item">【C++】STL：stack/queue/priority_queue/deque</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true',
              requiredMeta: ['nick','mail'] 
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F%E5%85%B3%E7%B3%BB"><span class="nav-text">1.继承派生关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">1.1 基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="nav-text">1.2 权限问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%90%8C%E5%90%8D%E9%97%AE%E9%A2%98%EF%BC%88%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%89"><span class="nav-text">1.3 同名问题（作用域）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">1.4 静态成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%8F%8B%E5%85%83"><span class="nav-text">1.5 友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">1.6 默认成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-text">构造和析构顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">显示调用构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98"><span class="nav-text">1.7 基类和派生类赋值问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%88%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-text">1.8 虚继承（菱形继承问题）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%9E%8B"><span class="nav-text">继承模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E8%A1%A8"><span class="nav-text">虚基表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88"><span class="nav-text">1.9 继承和组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%A4%9A%E6%80%81"><span class="nav-text">2.多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">2.1 虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="nav-text">2.1.1 基本使用以及动态多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">2.1.2 虚析构函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">2.2 纯虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">2.3 抽象类</span></a></li></ol></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/about">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_3_tp.gif" height="20px"> </a><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>