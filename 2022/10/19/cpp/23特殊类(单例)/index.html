<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><title>【C++】特殊类设计 | 单例模式 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【C++】特殊类设计 | 单例模式</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2022-10-19 16:13:46</span> <span class="mobile">2022-10-19 16:13</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-02-20 21:15:08</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E9%81%87%E8%A7%81C/">遇见C++</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/C/">C++</a>&nbsp;</li><li>| <a href="/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">类和对象</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>3k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>本篇博客让我们来康康一些特殊类的实现方式！</p><span id="more"></span><h1 id="1-不支持拷贝的类"><a href="#1-不支持拷贝的类" class="headerlink" title="1.不支持拷贝的类"></a>1.不支持拷贝的类</h1><p>在一些场景下，比如智能指针、多线程操作、IO流等是不支持拷贝的。因为它们的拷贝会导致一些问题，秉着<code>解决不了问题，就解决提出问题的人</code>的思路，禁止了这些类的拷贝</p><p><code>C++98</code>中，可以将拷贝构造和<code>=重载</code>只声明不定义，并将其访问权限设置为<strong>私有</strong></p><ul><li>设置为私有可以防止其他人在类外定义</li></ul><p><code>C++11</code>中，提供了一个特殊的关键字<code>delete</code>来禁止实现拷贝构造和 <code>=重载</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止拷贝的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BanCopy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="built_in">BanCopy</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_a = _b = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//C++11</span></span><br><span class="line">	<span class="built_in">BanCopy</span>(<span class="type">const</span> BanCopy&amp; c) = <span class="keyword">delete</span>;</span><br><span class="line">	BanCopy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BanCopy&amp; c) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//C++98的办法，声明为私有且不定义</span></span><br><span class="line">	<span class="comment">//BanCopy(const BanCopy&amp; c);</span></span><br><span class="line">	<span class="comment">//BanCopy&amp; operator=(const BanCopy&amp; c);</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">	<span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/202210191609856.png" alt="image-20221019160903815"></p><h1 id="2-只能在堆上创建的类"><a href="#2-只能在堆上创建的类" class="headerlink" title="2.只能在堆上创建的类"></a>2.只能在堆上创建的类</h1><p>操作方法和上面的思路类似，只需要把构造函数私有化就可以了</p><ul><li>同时还需要取消拷贝构造，否则可以用拷贝构造在栈上开一个新的对象</li><li>赋值重载不一定需要取消，因为赋值重载无法创建新对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能在堆上开辟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> HeapOnly* <span class="title">CreatObj</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HeapOnly</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 构造函数私有</span></span><br><span class="line">	<span class="built_in">HeapOnly</span>()</span><br><span class="line">		:_a(<span class="number">0</span>),</span><br><span class="line">		_b(<span class="number">0</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="built_in">HeapOnly</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">		:_a(a),</span><br><span class="line">		_b(b)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="comment">// 同时拷贝构造也需要私有，禁止拷贝创建对象</span></span><br><span class="line">	<span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp; h) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="comment">// 赋值不一定需要delete，因为赋值不能创建新对象</span></span><br><span class="line">	<span class="comment">// HeapOnly&amp; operator=(const HeapOnly&amp; h) = delete;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">	<span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样写了之后，想创建对象就可以调用<code>static</code>函数来操作</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/202210190915829.png" alt="image-20221019091538726"></p><p>而且因为我们并没有私有化析构函数，所以析构是可以正常调用的！</p><h2 id="2-1-另类操作"><a href="#2-1-另类操作" class="headerlink" title="2.1 另类操作"></a>2.1 另类操作</h2><p>还可以使用<code>static</code>函数提供一个接口来专门处理析构，再把析构函数设计成私有，构造函数公有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能在堆上开辟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> HeapOnly* <span class="title">CreatObj</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HeapOnly</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DelObj</span><span class="params">(HeapOnly* ptr)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为析构私有了，所以可以把构造公有</span></span><br><span class="line">	<span class="built_in">HeapOnly</span>()</span><br><span class="line">		:_a(<span class="number">0</span>),</span><br><span class="line">		_b(<span class="number">0</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="built_in">HeapOnly</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">		:_a(a),</span><br><span class="line">		_b(b)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 构造函数私有</span></span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同时拷贝构造也需要私有，禁止拷贝创建对象</span></span><br><span class="line">	<span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp; h) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="comment">// 赋值不一定需要delete，因为赋值不能创建新对象</span></span><br><span class="line">	<span class="comment">// HeapOnly&amp; operator=(const HeapOnly&amp; h) = delete;</span></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">HeapOnly</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_a = _b = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">	<span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样设计了之后，直接在<strong>栈上&#x2F;全局区</strong>开辟空间会报错，但是new不受影响。</p><p>因为析构私有了，所以<code>delete</code>不能正确调用析构函数，我们需要使用<code>static</code>函数指定指针进行析构</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/202210191505524.png" alt="image-20221019150534487"></p><p>除了这种办法，还有另外一个法子可以不传入指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除自己</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DelObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure><p>直接用对象调用此函数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapOnly* h6 = <span class="keyword">new</span> <span class="built_in">HeapOnly</span>();</span><br><span class="line">h6-&gt;<span class="built_in">DelObj</span>();</span><br></pre></td></tr></table></figure><p>只不过这样可能有些不太好理解，视具体情况而定喽！</p><h1 id="3-只能在栈上创建的类"><a href="#3-只能在栈上创建的类" class="headerlink" title="3.只能在栈上创建的类"></a>3.只能在栈上创建的类</h1><p>相同的思路，设计一个<code>static</code>的创建对象函数，来创建一个栈上的对象<code>return</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能在栈上开辟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> StackOnly <span class="title">CreatObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">StackOnly</span>();<span class="comment">//创建匿名对象返回，编译器直接优化为一个构造</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//这么写的话，就不能禁止拷贝构造</span></span><br><span class="line">		<span class="comment">//StackOnly st;</span></span><br><span class="line">		<span class="comment">//return st;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不能禁用拷贝构造，因为return的时候可能会调用（编译器优化是取决于平台的）</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">StackOnly</span>()	&#123;</span><br><span class="line">		_a = _b = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">	<span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们必须要有拷贝构造，因为<code>return</code>的时候，编译器如果不优化，那就是构造+拷贝，优化了之后才能变成直接构造</p><p>这是取决于平台的，如果禁用了拷贝，万一有些平台编译器没有做这种优化，你的代码就跑不动了</p><ul><li>另外，还有一个方法便是禁用掉<code>operator new()</code>，以此禁止了在堆上创建空间。如果用这种办法，构造函数就不需要设计为私有了</li></ul><p>但是这两个办法都有个缺陷，那就是用户可以用<strong>拷贝构造</strong>在静态区上创建一个对象。这只能算个小瑕疵，可以不用管它</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/202210190929905.png" alt="image-20221019092924850"></p><h1 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4.单例模式"></a>4.单例模式</h1><p>单例模式是<strong>设计模式</strong>的其中一种</p><blockquote><p>设计模式是一套被反复使用且较为流行的代码设计经验总结。</p><p>设计模式有非常多，感兴趣的老哥可以去搜专门的博客了解一下</p></blockquote><p>单例模式：一个类只能创建一个对象。该模式可以保证在一个进程中，某一个类只会有<strong>一个实例化的对象</strong></p><blockquote><p>举个例子，比如服务器的配置信息是一个类，这个类就可以设计成单例模式，保证所有人访问到的配置信息完全相同，修改的时候也能同步给所有人。</p></blockquote><h2 id="4-1-饿汉"><a href="#4-1-饿汉" class="headerlink" title="4.1 饿汉"></a>4.1 饿汉</h2><p>饿汉模式采用<code>static</code>成员来实现单例，思路和上面也是一样的，让构造函数私有而无法创建其他对象</p><ul><li>那我们的static对象要怎么创建呢？</li></ul><p>先来看看下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式（饿汉）</span></span><br><span class="line"><span class="comment">// 饿汉模式采用static对象，是在main函数之前创建的</span></span><br><span class="line"><span class="comment">// 会影响程序启动的速度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _sgp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;----- System Info -----&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;     CPU &quot;</span> &lt;&lt; _cpu &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;     GPU &quot;</span> &lt;&lt; _gpu &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;     MEM &quot;</span> &lt;&lt; _mem &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-----     End     -----&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>()</span><br><span class="line">		:_cpu(<span class="string">&quot;i9-12900ks&quot;</span>),</span><br><span class="line">		_gpu(<span class="string">&quot;RTX 4090&quot;</span>),</span><br><span class="line">		_mem(<span class="string">&quot;128GB&quot;</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	string _cpu;</span><br><span class="line">	string _mem;</span><br><span class="line">	string _gpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//static Singleton _sg;//声明</span></span><br><span class="line">	<span class="type">static</span> Singleton* _sgp;<span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Singleton Singleton::_sg;//定义</span></span><br><span class="line">Singleton* Singleton::_sgp = <span class="keyword">new</span> <span class="built_in">Singleton</span>();<span class="comment">//定义</span></span><br><span class="line"><span class="comment">//因为这里的sg和sgp都是属于类里面的成员，不受访问限定符的限制，才可以正常调用构造函数</span></span><br></pre></td></tr></table></figure><p>因为<code>_sg/_sgp</code>这两个成员都在类内部声明的，所以它们属于整个类域，可以成功访问到内部的构造函数。</p><p>而在其他地方的对象由于没有办法访问到构造函数，而无法创建</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/202210191531803.png" alt="image-20221019153141746"></p><p>由于饿汉模式是static对象，其初始化是在main函数之前进行的。如果采用饿汉模式的单例过多，程序迟迟没有运行到<code>main</code>处，会导致一个程序启动很慢</p><h2 id="4-2-懒汉"><a href="#4-2-懒汉" class="headerlink" title="4.2 懒汉"></a>4.2 懒汉</h2><p>一开始不创建对象，第一调用GetInstance再创建对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉</span></span><br><span class="line"><span class="comment">// 一开始不创建对象，第一调用GetInstance再创建对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InfoMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> InfoMgr* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_sp == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_sp = <span class="keyword">new</span> InfoMgr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> _sp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetAddress</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_address = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">string&amp; <span class="title">GetAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _address;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">InfoMgr</span>()</span><br><span class="line">		:_address(<span class="string">&quot;bilibili&quot;</span>),</span><br><span class="line">		_secretKey(<span class="number">1234</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="built_in">InfoMgr</span>(<span class="type">const</span> InfoMgr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	string _address;</span><br><span class="line">	<span class="type">int</span> _secretKey;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> InfoMgr* _sp; <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">InfoMgr* InfoMgr::_sp = <span class="literal">nullptr</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure><p>这里我们将内部的<code>_sp</code>定义为了<code>nullptr</code>，如果谁第一个调用，做一个判断，如果是<code>nullptr</code>就创建实例</p><hr><p>由于懒汉可能会出现多个线程同时第一次访问这个单例，就会导致在两个线程中都在初始化这个单例，而某一次初始化会失败。这是一个线程安全问题，需要我们对单例进行加锁操作</p><blockquote><p>多线程加锁问题，参考linux下的操作：<a href="https://blog.musnow.top/2023/01/19/note_linux/22%E7%BA%BF%E7%A8%8B%E6%B1%A0/">C++线程操作</a>；<br>C++的操作以这个思路，修改为使用C++的thread库即可</p></blockquote><h2 id="4-3-二者优缺点"><a href="#4-3-二者优缺点" class="headerlink" title="4.3 二者优缺点"></a>4.3 二者优缺点</h2><p>饿汉的优点</p><ul><li>简单易用</li><li>因为是在main函数前初始化，处于单线程状态，没有线程安全问题</li></ul><p>缺点：</p><ul><li>但是初始化顺序不确定，如果有其他类的依赖关系，可能会出现依赖项B在当前单例A后初始化，导致A无法完成初始化而程序boom</li><li>饿汉单例是在main函数之前创建的，拖慢程序启动速度</li></ul><hr><p>懒汉的优点</p><ul><li>第一次调用的时候才初始化变量，提高程序启动速度</li><li>可以控制初始化顺序，按顺序来初始化，避免依赖关系问题</li></ul><p>缺点：</p><ul><li>第一次调用的时候，加载会慢一些</li></ul><p>基于这两个的优缺点，让我想出来一个不算办法的办法</p><p>如果想控制饿汉的初始化顺序，可以在<code>main</code>一启动的时候，就调用一个初始化函数来初始化这些单例。这样依旧会拖慢进程启动的顺序，但解决了初始化顺序的问题！</p><blockquote><p>实际上，一个单例究竟要不要在main之前就初始化需要看具体情况的！</p></blockquote><h2 id="4-4-单例释放资源"><a href="#4-4-单例释放资源" class="headerlink" title="4.4 单例释放资源"></a>4.4 单例释放资源</h2><p>一般情况下，单例的类是不需要手动释放的，因为整个进程都需要使用这个单例</p><p>但如果我们的单例和一个文件挂钩，进程结束的时候，需要将单例里面的信息保存到文件里面，要怎么操作？</p><p>可以写一个垃圾回收类，在最后调用析构来回收资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉 -- 一开始不创建对象，第一调用GetInstance再创建对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InfoMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> InfoMgr* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 还需要加锁，留着后面填坑</span></span><br><span class="line">		<span class="keyword">if</span> (_spInst == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_spInst = <span class="keyword">new</span> InfoMgr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> _spInst;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetAddress</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_address = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">string&amp; <span class="title">GetAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _address;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实现一个内嵌垃圾回收类    </span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">CGarbo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">CGarbo</span>() &#123;</span><br><span class="line">			<span class="keyword">if</span> (_spInst)</span><br><span class="line">				<span class="keyword">delete</span> _spInst;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象</span></span><br><span class="line">	<span class="type">static</span> CGarbo Garbo;<span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">InfoMgr</span>()</span><br><span class="line">		:_address(<span class="string">&quot;bilibili&quot;</span>),</span><br><span class="line">		_secretKey(<span class="number">1234</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">InfoMgr</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 假设析构时需要信息写到文件持久化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">InfoMgr</span>(<span class="type">const</span> InfoMgr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	string _address;</span><br><span class="line">	<span class="type">int</span> _secretKey;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> InfoMgr* _spInst; <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">InfoMgr* InfoMgr::_spInst = <span class="literal">nullptr</span>; <span class="comment">// 定义</span></span><br><span class="line">InfoMgr::CGarbo Garbo;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure><h2 id="4-5-static单例"><a href="#4-5-static单例" class="headerlink" title="4.5 static单例"></a>4.5 static单例</h2><p>有人会采用下面的方式来实现懒汉的单例，其采用static对象，让编译器自动帮我们实现单例！</p><ul><li>全局static变量会在main之前初始化</li><li>局部static变量会在第一次调用的时候初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 局部的静态对象，第一次调用时初始化</span></span><br><span class="line">		<span class="type">static</span> Singleton _s;</span><br><span class="line">		<span class="keyword">return</span> &amp;_s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 构造函数私有</span></span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">	<span class="comment">// 拷贝构造/赋值重载取消</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是！这个操作并不通用，其取决于编译器和平台的实现。特别是在C++11之前；</p><p>C++11之后，保证了局部静态变量初始化时的线程安全，我们便可以采用这种办法来实现单例。</p><blockquote><p><a href="https://blog.musnow.top/2023/02/20/note_cpp/29c++11%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/">C++11中局部static变量的线程安全问题</a></p></blockquote><p>但是！一定要确认你的代码只在C++11的环境下运行！！</p><h1 id="5-不能被继承的类"><a href="#5-不能被继承的类" class="headerlink" title="5.不能被继承的类"></a>5.不能被继承的类</h1><p>C++98中，只需要将构造函数私有，派生类无法调用基类构造函数，也就无法继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++98,构造私有</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> A <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_a = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而C++11中提供了一个关键字<code>final</code>，用这个关键字修饰类，就无法被继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11直接用关键字final</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>几个特殊类到这里就讲解结束辣，其中懒汉多线程加锁还留了一个坑，待后续我会回来更新补上的！</p><p>感谢你看到最后!</p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【C++】特殊类设计 | 单例模式</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2022-10-19 16:13:46</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2022/10/19/cpp/23特殊类(单例)/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/C/">#C++</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">#类和对象</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/10/19/cpp/22%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E7%A9%BA/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【C++】智能指针（空）</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/10/18/cpp/25%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"><span class="title flex-center"><span class="post-nav-title-item">【C++】空间配置器</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true',
              requiredMeta: ['nick','mail'] 
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%B8%8D%E6%94%AF%E6%8C%81%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%B1%BB"><span class="nav-text">1.不支持拷贝的类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B1%BB"><span class="nav-text">2.只能在堆上创建的类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%8F%A6%E7%B1%BB%E6%93%8D%E4%BD%9C"><span class="nav-text">2.1 另类操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B1%BB"><span class="nav-text">3.只能在栈上创建的类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">4.单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E9%A5%BF%E6%B1%89"><span class="nav-text">4.1 饿汉</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%87%92%E6%B1%89"><span class="nav-text">4.2 懒汉</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E4%BA%8C%E8%80%85%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">4.3 二者优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%8D%95%E4%BE%8B%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="nav-text">4.4 单例释放资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-static%E5%8D%95%E4%BE%8B"><span class="nav-text">4.5 static单例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB"><span class="nav-text">5.不能被继承的类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-text">结语</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/about">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_3_tp.gif" height="20px"> </a><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>