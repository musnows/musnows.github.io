<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><title>【C++】C++11中局部static变量的线程安全问题 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【C++】C++11中局部static变量的线程安全问题</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2023-02-20 21:13:46</span> <span class="mobile">2023-02-20 21:13</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-03-10 22:54:08</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E9%81%87%E8%A7%81C/">遇见C++</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/C/">C++</a>&nbsp;</li><li>| <a href="/tags/C-11/">C++11</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>2.2k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>C++11中局部static变量的线程安全问题</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家都知道，在C++11标准中，要求局部静态变量初始化具有<a class="link" target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020">线程安全<i class="fas fa-external-link-alt"></i></a>性，所以我们可以很容易实现一个线程安全的单例类：</p><pre><code>class Foo
&#123;
public:
    static Foo *getInstance()
    &#123;
        static Foo s_instance;
        return &amp;s_instance;
    &#125;
private:
    Foo() &#123;&#125;
&#125;;
</code></pre><p>在C++标准中，是这样描述的（在<a class="link" target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">标准草案<i class="fas fa-external-link-alt"></i></a>的6.7节中）：</p><blockquote><p>such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization. If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.</p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>标准关于局部静态变量初始化，有这么几点要求：</p><ol><li>变量在代码第一次执行到变量声明的地方时初始化。</li><li>初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。</li><li>在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。</li><li>如果初始化过程中发生了对初始化的递归调用，则视为未定义行为。</li></ol><p>关于第4点，如果不明白，可以参考以下代码：</p><pre><code>class Bar
&#123;
public:
    static Bar *getInstance()
    &#123;
        static Bar s_instance;
        return &amp;s_instance;
    &#125;
private:
    Bar()
    &#123;
        getInstance();
    &#125;
&#125;;
</code></pre><h1 id="GCC的实现"><a href="#GCC的实现" class="headerlink" title="GCC的实现"></a>GCC的实现</h1><p>以GCC 7.3.0版本为例，我们来分析GCC是如何实现标准的。</p><h2 id="Foo-getInstance"><a href="#Foo-getInstance" class="headerlink" title="Foo::getInstance()"></a>Foo::getInstance()</h2><p>使用GCC编译后，我们使用gdb将文章开头的<code>Foo::getInstance()</code>反汇编：</p><pre><code>Dump of assembler code for function Foo::getInstance():
   0x00005555555546ea &lt;+0&gt;:     push   %rbp
   0x00005555555546eb &lt;+1&gt;:     mov    %rsp,%rbp
=&gt; 0x00005555555546ee &lt;+4&gt;:     movzbl 0x20092b(%rip),%eax        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;
   0x00005555555546f5 &lt;+11&gt;:    test   %al,%al
   0x00005555555546f7 &lt;+13&gt;:    sete   %al
   0x00005555555546fa &lt;+16&gt;:    test   %al,%al
   0x00005555555546fc &lt;+18&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;
   0x00005555555546fe &lt;+20&gt;:    lea    0x20091b(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;
   0x0000555555554705 &lt;+27&gt;:    callq  0x5555555545b0 &lt;__cxa_guard_acquire@plt&gt;
   0x000055555555470a &lt;+32&gt;:    test   %eax,%eax
   0x000055555555470c &lt;+34&gt;:    setne  %al
   0x000055555555470f &lt;+37&gt;:    test   %al,%al
   0x0000555555554711 &lt;+39&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;
   0x0000555555554713 &lt;+41&gt;:    lea    0x2008fe(%rip),%rdi        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;
   0x000055555555471a &lt;+48&gt;:    callq  0x555555554734 &lt;Foo::Foo()&gt;
   0x000055555555471f &lt;+53&gt;:    lea    0x2008fa(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;
   0x0000555555554726 &lt;+60&gt;:    callq  0x5555555545a0 &lt;__cxa_guard_release@plt&gt;
   0x000055555555472b &lt;+65&gt;:    lea    0x2008e6(%rip),%rax        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;
   0x0000555555554732 &lt;+72&gt;:    pop    %rbp
   0x0000555555554733 &lt;+73&gt;:    retq   
End of assembler dump.
</code></pre><p>在<code>+4</code>、<code>+20</code>、<code>+53</code>出现的<code>_ZGVZN3Foo11getInstanceEvE10s_instance</code>使用<code>c++filt</code>分析为<code>guard variable for Foo::getInstance()::s_instance</code>，而<code>+41</code>、<code>+65</code>位置出现的<code>_ZZN3Foo11getInstanceEvE10s_instance</code>则为<code>Foo::getInstance()::s_instance</code>。后者是<code>s_instance</code>这个局部静态变量，前者从名字看就知道是个<code>guard</code>标志变量，用来指示局部静态变量的初始化状态。</p><h3 id="4-18"><a href="#4-18" class="headerlink" title="+4 ~ +18"></a>+4 ~ +18</h3><p>测试<code>guard</code>变量的第一个字节，如果为<code>0</code>，代表<code>s_instance</code>未初始化，进入<code>+27</code>；否则代表<code>s_instance</code>已初始化，进入<code>+65</code>。</p><h3 id="20-～-27"><a href="#20-～-27" class="headerlink" title="+20 ～ +27"></a>+20 ～ +27</h3><p>以<code>guard</code>变量地址作为参数，执行<code>__cxa_guard_acquire</code>函数。</p><h3 id="32-～-39"><a href="#32-～-39" class="headerlink" title="+32 ～ +39"></a>+32 ～ +39</h3><p>测试返回值，如果为<code>0</code>，代表<code>s_instance</code>已初始化，进入<code>+65</code>；否则代表<code>s_instance</code>未初始化，进入<code>+41</code>。</p><h3 id="41-～-48"><a href="#41-～-48" class="headerlink" title="+41 ～ +48"></a>+41 ～ +48</h3><p>初始化<code>s_instance</code></p><h3 id="53-～-60"><a href="#53-～-60" class="headerlink" title="+53 ～ +60"></a>+53 ～ +60</h3><p>以<code>guard</code>变量地址作为参数，执行<code>__cxa_guard_release</code>函数。</p><h3 id="65-～-73"><a href="#65-～-73" class="headerlink" title="+65 ～ +73"></a>+65 ～ +73</h3><p>返回<code>s_instance</code>地址</p><h2 id="cxa-guard-acquire"><a href="#cxa-guard-acquire" class="headerlink" title="__cxa_guard_acquire"></a>__cxa_guard_acquire</h2><p>我们来看看<code>__cxa_guard_acquire</code>这个函数具体做了什么，该函数代码位于<code>gcc-7-7.3.0/gcc-7.3.0/libstdc++-v3/libsupc++/guard.cc</code>。由于这个函数针对不同平台做了不同的实现，有些我们不需要的代码，以我机器的设置，支持线程和futex系统调用，所以删除了一些不相关的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cxa_guard_acquire (__guard *g)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If the target can reorder loads, we need to insert a read memory</span></span><br><span class="line">    <span class="comment">// barrier so that accesses to the guarded variable happen after the</span></span><br><span class="line">    <span class="comment">// guard test.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (_GLIBCXX_GUARD_TEST_AND_ACQUIRE (g))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> guard_bit = _GLIBCXX_GUARD_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> pending_bit = _GLIBCXX_GUARD_PENDING_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">expected</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (__atomic_compare_exchange_n(gi, &amp;expected, pending_bit, <span class="literal">false</span>,</span><br><span class="line">                                            __ATOMIC_ACQ_REL,</span><br><span class="line">                                            __ATOMIC_ACQUIRE))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// This thread should do the initialization.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5</span></span><br><span class="line">            <span class="keyword">if</span> (expected == guard_bit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Already initialized.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">if</span> (expected == pending_bit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Use acquire here.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7</span></span><br><span class="line">                <span class="type">int</span> newv = expected | waiting_bit;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8</span></span><br><span class="line">                <span class="keyword">if</span> (!__atomic_compare_exchange_n(gi, &amp;expected, newv, <span class="literal">false</span>,</span><br><span class="line">                                                 __ATOMIC_ACQ_REL,</span><br><span class="line">                                                 __ATOMIC_ACQUIRE))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 9</span></span><br><span class="line">                    <span class="keyword">if</span> (expected == guard_bit)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Make a thread that failed to set the</span></span><br><span class="line">                        <span class="comment">// waiting bit exit the function earlier,</span></span><br><span class="line">                        <span class="comment">// if it detects that another thread has</span></span><br><span class="line">                        <span class="comment">// successfully finished initialising.</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 10</span></span><br><span class="line">                    <span class="keyword">if</span> (expected == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 11</span></span><br><span class="line">                expected = newv;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 12</span></span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAIT, expected, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acquire</span> (g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先检测<code>guard</code>变量，<code>guard</code>变量等于<code>1</code>的话，直接返回<code>0</code>，代表<code>s_instance</code>已初始化，不需要再次初始化。</li><li>检测是否为多线程环境，如果没有多线程的话，也就没有必要去做额外工作来保证线程安全了。</li><li><code>guard_bit</code>表示<code>s_instance</code>已经初始化成功；<code>pending_bit</code>表示<code>s_instance</code>正在初始化；<code>waiting_bit</code>表示有其他线程正在等待<code>s_instance</code>的初始化。</li><li>使用一个原子操作来检测<code>guard</code>变量是否为<code>0</code>，如果为<code>0</code>，则由当前线程初始化<code>s_instance</code>，把<code>pending_bit</code>写入guard变量，返回<code>1</code>。如果不为<code>0</code>，则将guard当前值写入<code>expected</code>。</li><li>检测<code>expected</code>值是否为<code>guard_bit</code>，如果是，则<code>s_instance</code>已初始化完成，不再需要初始化，返回<code>0</code>。</li><li>检测<code>expected</code>值是否为<code>pending_bit</code>，如果是，说明<code>s_instance</code>正在初始化，且没有其他线程等待初始化。</li><li>将<code>newv</code>变量设置为<code>pending_bit | waiting_bit</code>，表示<code>s_instance</code>正在初始化且有线程正在等待初始化。</li><li>使用一个原子操作来检测<code>guard</code>变量是否为<code>pending_bit</code>，如果不是，说明有其他线程修改了<code>guard</code>变量，需要做进一步检测；如果是，说明没有其他线程修改<code>guard</code>变量，则将<code>pending_bit | waiting_bit</code>写入<code>guard</code>变量。</li><li>如果<code>expected</code>等于<code>guard_bit</code>，说明<code>s_instance</code>被初始化成功，不需要再初始化，返回<code>0</code>。</li><li>如果<code>expected</code>等于<code>0</code>，说明<code>s_instance</code>初始化失败，回到<code>4</code>重新开始检测。</li><li>如果在<code>8</code>中没有其他线程修改过<code>guard</code>变量，将<code>expected</code>设置为<code>pending_bit | waiting_bit</code>，表示<code>s_instance</code>正在初始化且有线程（也就是当前线程）正在等待初始化。</li><li>如果在<code>6</code>处没有进入if分支，说明<code>expected</code>等于<code>pending_bit | waiting_bit</code>，如果进入了if分支，由<code>11</code>可得，此时<code>expected</code>也被修改为了<code>pending_bit | waiting_bit</code>。总之，此时<code>s_instance</code>正在初始化且有线程正在等待初始化。利用<code>futex</code>系统调用，再次检测<code>guard</code>变量是否发生了变化，如果发生了变化，回到<code>4</code>重新开始检测；如果没有发生变化，仍然等于<code>pending_bit | waiting_bit</code>，则挂起当前线程。</li></ol><p>总之，<code>__cxa_guard_acquire</code>要么返回<code>0</code>要么返回<code>1</code>，用来指示<code>s_instance</code>已初始化或未初始化。<code>__cxa_guard_acquire</code>可能会导致当前线程挂起，这发生在<code>s_instance</code>正在初始化的时候。</p><h2 id="cxa-guard-release"><a href="#cxa-guard-release" class="headerlink" title="__cxa_guard_release"></a>__cxa_guard_release</h2><p>由于<code>__cxa_guard_acquire</code>可能导致当前线程挂起，因此需要在<code>s_instance</code>初始化完成后使用将<code>__cxa_guard_release</code>线程唤醒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_guard_release (__guard *g) <span class="keyword">throw</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> guard_bit = _GLIBCXX_GUARD_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="type">int</span> old = __atomic_exchange_n (gi, guard_bit, __ATOMIC_ACQ_REL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> ((old &amp; waiting_bit) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">0</span>);</span><br><span class="line">    _GLIBCXX_GUARD_SET_AND_RELEASE (g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检测是否为多线程环境</li><li>使用原子操作将<code>guard</code>变量置为<code>guard_bit</code>，同时获取<code>guard</code>变量原始值。</li><li>如果<code>guard</code>变量原始值包含<code>waiting_bit</code>，说明有线程挂起（或将要调用<code>futex</code>欲使线程挂起），调用<code>futex</code>唤醒挂起的进程。</li></ol><h2 id="cxa-guard-abort"><a href="#cxa-guard-abort" class="headerlink" title="__cxa_guard_abort"></a>__cxa_guard_abort</h2><p>由于<code>s_instance</code>可能初始化失败（本例中并未体现），因此还有一个<code>__cxa_guard_abort</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_guard_abort (__guard *g) <span class="keyword">throw</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line">        <span class="type">int</span> old = __atomic_exchange_n (gi, <span class="number">0</span>, __ATOMIC_ACQ_REL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((old &amp; waiting_bit) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>__cxa_guard_release</code>基本一致，不同的地方在于会将<code>guard</code>变量置<code>0</code>。</p><h2 id="递归初始化调用"><a href="#递归初始化调用" class="headerlink" title="递归初始化调用"></a>递归初始化调用</h2><p>由于在C++11标准中，初始化如果发生了递归是未定义行为，所以GCC 7.3.0针对是否为<a class="link" target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程<i class="fas fa-external-link-alt"></i></a>环境做了不同的处理。如果是多线程环境，不进行额外处理，会发生死锁；如果是单线程环境，则会抛异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire() is a helper function used to acquire guard if thread support is</span></span><br><span class="line"><span class="comment">// not compiled in or is compiled in but not enabled at run-time.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">acquire</span><span class="params">(__guard *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Quit if the object is already initialized.</span></span><br><span class="line">    <span class="keyword">if</span> (_GLIBCXX_GUARD_TEST(g))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">init_in_progress_flag</span>(g))</span><br><span class="line">        <span class="built_in">throw_recursive_init_exception</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看到了GCC如此复杂的实现，我的个人感想是还是不要自己造轮子来保证单例类的线程安全了，想要做到和GCC一样的高效还是比较难的，利用C++11标准的带来的便利就挺好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文作者：imred</span><br><span class="line">原文链接：https://blog.csdn.net/imred/article/details/89069750</span><br></pre></td></tr></table></figure></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/C/">#C++</a>&nbsp;</li><li class="tag-item"><a href="/tags/C-11/">#C++11</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2023/02/23/docker/8docker%E5%AE%89%E8%A3%85centos%E9%81%87%E5%88%B0%E6%8A%A5%E9%94%99/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo &#39;appstream&#39; Cannot prepare internal mirrorlist</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2023/02/20/tools/15curl%E6%A8%A1%E6%8B%9Freferer%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90/"><span class="title flex-center"><span class="post-nav-title-item">【Curl】通过curl模拟referer获取到有防盗链的图片</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true',
              requiredMeta: ['nick','mail'] 
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-text">分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GCC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">GCC的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Foo-getInstance"><span class="nav-text">Foo::getInstance()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-18"><span class="nav-text">+4 ~ +18</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%EF%BD%9E-27"><span class="nav-text">+20 ～ +27</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%EF%BD%9E-39"><span class="nav-text">+32 ～ +39</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-%EF%BD%9E-48"><span class="nav-text">+41 ～ +48</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-%EF%BD%9E-60"><span class="nav-text">+53 ～ +60</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#65-%EF%BD%9E-73"><span class="nav-text">+65 ～ +73</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cxa-guard-acquire"><span class="nav-text">__cxa_guard_acquire</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cxa-guard-release"><span class="nav-text">__cxa_guard_release</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cxa-guard-abort"><span class="nav-text">__cxa_guard_abort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B0%83%E7%94%A8"><span class="nav-text">递归初始化调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://musnow.top" target="_blank"><img src="https://img.shields.io/badge/%E4%B8%BB%E7%AB%99-%E7%82%B9%E6%88%91-blueviolet" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>