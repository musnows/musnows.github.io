<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-E1K9nNha9u"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><title>【Linux】来写一个tcp的服务端+客户端 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【Linux】来写一个tcp的服务端+客户端</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2023-02-05 12:30:55</span> <span class="mobile">2023-02-05 12:30</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-02-08 17:09:38</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E7%8E%A9%E4%B8%8ALinux/">玩上Linux</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/%E7%BD%91%E7%BB%9C/">网络</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>4.7k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>今天让我们来写一个tcp的服务器&#x2F;客户端代码</p><span id="more"></span><blockquote><p>完整代码见我的gitee <a class="link" target="_blank" rel="noopener" href="https://gitee.com/musnow/raspberry-practice/tree/master/code">连接<i class="fas fa-external-link-alt"></i></a></p><p>阅读本文前，建议先阅读👉 <a href="https://blog.musnow.top/2023/02/01/note_linux/27udp%E4%BB%A3%E7%A0%81/">udp服务器</a></p></blockquote><h1 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1.基本框架"></a>1.基本框架</h1><p>tcp的服务器和udp服务器初始化接口是非常相似的，区别就在于要选择<code>字节流</code>进行初始化</p><p>但是到运行状态就不同了</p><ul><li>tcp是需要连接的</li><li>udp不需要连接</li></ul><p>所以就会出现分歧：udp可以用sendto和receve来发送&#x2F;接收信息，服务端只需要监听特定端口收到了什么信息；</p><p>但tcp并不能这么做，在通信之前，tcp服务器必须要和客户端建立链接。</p><p>举个不恰当的例子，udp服务器好比一个水盆，等待水的注入；而tcp服务器是个水管，必须要两头连通了，才能开始注水</p><h2 id="1-1-类成员"><a href="#1-1-类成员" class="headerlink" title="1.1 类成员"></a>1.1 类成员</h2><p>类的成员变量和udp很相似，都是需要服务器的ip、端口、sockfd这些信息。为了更容易区分，将tcp服务器的<code>socket fd</code>改为<code>_listenSock</code>，意为监听端口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 服务器端口号</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">    <span class="comment">// 服务器ip地址</span></span><br><span class="line">    string _ip;</span><br><span class="line">    <span class="comment">// 服务器socket fd信息</span></span><br><span class="line">    <span class="type">int</span> _listenSock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-头文件"><a href="#1-2-头文件" class="headerlink" title="1.2 头文件"></a>1.2 头文件</h2><p>这里对头文件进行一定的说明，因为服务器代码中的头文件实在太多了</p><p>当你需要使用一个接口的时候，可以去采用man手册来获取该接口的头文件信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 头文件太多了，所以新起一个文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span><span class="comment">//判断字符串大写小写接口需要的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span><span class="comment">// 忽略大小写比较strcasecmp</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">//很多liunx系统接口都需要这个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// 网络</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">// 网络</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 网络</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_ERR 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIND_ERR   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_ERR 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USAGE_ERR  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONN_ERR   5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br></pre></td></tr></table></figure><h1 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h1><p>接口的介绍就跟随实现一步一步来吧</p><h2 id="2-1-构造sock"><a href="#2-1-构造sock" class="headerlink" title="2.1 构造sock"></a>2.1 构造sock</h2><p>这里出现了tcp和udp第一个不同之处，tcp是面向字节流的，udp面向的是数据报</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TcpServer</span>(<span class="type">uint16_t</span> port,<span class="type">const</span> string&amp; ip=<span class="string">&quot;&quot;</span>)</span><br><span class="line"> :_port(port), _ip(ip), _listenSock(<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建socket套接字,采用字节流（即tcp）</span></span><br><span class="line">    _listenSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//本质是打开了一个文件</span></span><br><span class="line">    <span class="keyword">if</span> (_listenSock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">logging</span>(FATAL, <span class="string">&quot;socket:%s:%d&quot;</span>, <span class="built_in">strerror</span>(errno), _listenSock);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;socket create success: %d&quot;</span>, _listenSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-初始化sockaddr-in"><a href="#2-2-初始化sockaddr-in" class="headerlink" title="2.2 初始化sockaddr_in"></a>2.2 初始化sockaddr_in</h2><p>继续，初始化sockaddr_in的操作和udp是完全一致的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 绑定网络信息，指明ip+port</span></span><br><span class="line"><span class="comment">// 2.1 先填充基本信息到 struct sockaddr_in</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;</span><br><span class="line"><span class="built_in">memset</span>(&amp;local,<span class="number">0</span>,<span class="built_in">sizeof</span>(local));<span class="comment">//初始化</span></span><br><span class="line"><span class="comment">// 协议家族，设置为ipv4</span></span><br><span class="line">local.sin_family = AF_INET; </span><br><span class="line"><span class="comment">// 端口，需要进行 本地-&gt;网络转换</span></span><br><span class="line">local.sin_port = <span class="built_in">htons</span>(_port);</span><br><span class="line"><span class="comment">// 配置ip</span></span><br><span class="line"><span class="comment">// 如果初始化时候的ip为空，则调用INADDR_ANY代表任意ip。否则对传入的ip进行转换后赋值</span></span><br><span class="line">local.sin_addr.s_addr = _ip.<span class="built_in">empty</span>() ? <span class="built_in">htonl</span>(INADDR_ANY) : <span class="built_in">inet_addr</span>(_ip.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h2 id="2-3-bind"><a href="#2-3-bind" class="headerlink" title="2.3 bind"></a>2.3 bind</h2><p>也是一样，绑定服务器的ip和端口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.2 绑定ip端口</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_listenSock,(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logging</span>(FATAL, <span class="string">&quot;bind: %s:%d&quot;</span>, <span class="built_in">strerror</span>(errno), _listenSock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">logging</span>(DEBUG,<span class="string">&quot;socket bind success: %d&quot;</span>, _listenSock);</span><br></pre></td></tr></table></figure><h2 id="2-4-监听listen"><a href="#2-4-监听listen" class="headerlink" title="2.4 监听listen"></a>2.4 监听listen</h2><p>对于tcp服务器来说，成员变量的<code>_listenSock</code>是用来监听的，即找个老哥一直盯着云服务器的这个端口，看看有没有需要连接它的客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p>其中第一个参数是我们的<code>_listenSock</code>，第二个参数是用于限制在阻塞等待连接的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.   If  a connection  request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt  at  con‐nection succeeds.</span><br></pre></td></tr></table></figure><p>翻译过来就是，<code>backlog</code>参数限制了能被阻塞等待连接的数量。如果超过这个数量，则会返回一个<code>ECONNREFUSED</code>错误。亦或者如果协议支持重传，多余的请求会被忽略，后续可以重传</p><p>man手册下面的notes还有更多解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The behavior of the backlog argument on TCP sockets changed with Linux 2.2.  Now it specifies  the  queue  length  for completely  established  sockets waiting to be accepted, instead of the number of incomplete connection requests.  The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog.  When syn‐cookies are enabled there is no logical maximum length and this setting is ignored.  See tcp(7) for more information.</span><br><span class="line"></span><br><span class="line"> If  the  backlog  argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128.  In kernels before 2.4.25, this  limit  was  a  hard  coded  value,SOMAXCONN, with the value 128.</span><br></pre></td></tr></table></figure><p>如果<code>backlog</code>参数高于<code>/proc/sys/net/core/somaxconn</code>中的默认值128，则会被截断为128</p><hr><p>在我们这里，将其设置为5即可，反正也是做测试嘛，问题不大</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.监听</span></span><br><span class="line"><span class="comment">// tcp服务器是需要连接的，连接之前要先监听有没有人来连</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(_listenSock, <span class="number">5</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logging</span>(FATAL, <span class="string">&quot;listen: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">exit</span>(LISTEN_ERR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">logging</span>(DEBUG, <span class="string">&quot;listen: %s, %d&quot;</span>, <span class="built_in">strerror</span>(errno), _listenSock);</span><br></pre></td></tr></table></figure><h1 id="3-运行"><a href="#3-运行" class="headerlink" title="3.运行"></a>3.运行</h1><p>初始化到这就完毕了，下面就是开跑了</p><h2 id="3-1-accept"><a href="#3-1-accept" class="headerlink" title="3.1 accept"></a>3.1 accept</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p>这个接口的作用就相当于tcp中的<code>recevefrom</code>，传参是完全相同的；与之不同的是，该函数的返回值是一个全新的<code>sockfd</code></p><ul><li>tcp需要和客户端建立链接</li><li>链接需要用socket fd 来管理</li><li>所以accept必须返回新的socket fd，让服务端有办法管理新的链接和已有链接</li><li>原有的socket fd不受影响</li><li>如果没有客户端来连接，进程会在accept内阻塞等待</li></ul><p>下为man手册中的描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The  accept()  system  call  is  used  with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).  It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected  socket,  and  returns  a  new  file descriptor referring to that socket.  The newly created socket is not in the listening state.  The original socket sockfd is unaffected by this call.</span><br></pre></td></tr></table></figure><p>举个例子，tcp服务器自身的socket fd只会用来监听端口上有没有消息，当监听到有消息并通过<code>accept</code>建立连接后，就会让另外一位服务员来对这个连接提供服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">int</span> conet = <span class="built_in">accept</span>(_listenSock,(<span class="keyword">struct</span> sockaddr*)&amp;peer,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(conet&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">logging</span>(FATAL, <span class="string">&quot;accept: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(CONN_ERR);<span class="comment">//连接错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里len的参数是<code>socklen_t</code>，其本质上是一个无符号整形</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">__socklen_t</span> <span class="type">socklen_t</span>;</span><br><span class="line">__STD_TYPE __U32_TYPE <span class="type">__socklen_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __U32_TYPE		unsigned int</span></span><br></pre></td></tr></table></figure><h2 id="3-2-获取连接信息"><a href="#3-2-获取连接信息" class="headerlink" title="3.2 获取连接信息"></a>3.2 获取连接信息</h2><p>这部分和udp是完全相同的，通过accept返回的socket fd，获取用户的ip和端口耨</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接信息</span></span><br><span class="line">string senderIP = <span class="built_in">inet_ntoa</span>(peer.sin_addr);<span class="comment">// 来源ip</span></span><br><span class="line"><span class="type">uint16_t</span> senderPort = <span class="built_in">ntohs</span>(peer.sin_port); <span class="comment">// 来源端口</span></span><br><span class="line"><span class="built_in">logging</span>(DEBUG, <span class="string">&quot;accept: %s | %s[%d], socket fd: %d&quot;</span>, <span class="built_in">strerror</span>(errno), senderIP.<span class="built_in">c_str</span>(), senderPort, conet);</span><br></pre></td></tr></table></figure><p>其实到这里，我们就可以运行服务器进行测试了。因为tcp的特性，我们不需要写客户端，直接用浏览器就能连上服务端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//参数只有两个（端口/ip）所以参数个数应该是2-3</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span> &amp;&amp; argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; port [ip]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string ip;</span><br><span class="line">    <span class="comment">// 3个参数，有ip</span></span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ip = argv[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TcpServer <span class="title">t</span><span class="params">(atoi(argv[<span class="number">1</span>]),ip)</span></span>;</span><br><span class="line">    t.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先编译后执行代码，让tcp服务器运行起来</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63e198bcc215e.png" alt="image-20230207081805916"></p><p>随后在浏览器的地址栏输入<code>公网ip:端口</code>（先要开启防火墙内的端口）</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63e198b144512.png" alt="image-20230207081754768"></p><p>此时会发现什么都加载不出来，这是对的，因为我们并没有写前端，也没有提供任何服务。但是来到后台，可以看到出现了一个新的连接，并显示出了ip+端口</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63e19990d9e97.png" alt="image-20230207082138291"></p><h2 id="3-3-提供服务（线程）"><a href="#3-3-提供服务（线程）" class="headerlink" title="3.3 提供服务（线程）"></a>3.3 提供服务（线程）</h2><p>接下来要做的，就是写一个简单的服务了，这里我写的是字符串转ASCII码，会将发出去的字符串的ascii码加加起来后返回</p><h3 id="3-3-1-问题1-如何通信"><a href="#3-3-1-问题1-如何通信" class="headerlink" title="3.3.1 问题1 如何通信"></a>3.3.1 问题1 如何通信</h3><p>此时问题就来了，tcp服务器不能使用recevefrom和sendto，那么获取到socket之后要怎么进行通信呢？</p><p>答案是：<strong>用linux的文件读写接口</strong>，read和write。别忘了，socket fd本质上就是一个linux下的文件描述符！</p><h3 id="3-3-2-问题2-多客户端"><a href="#3-3-2-问题2-多客户端" class="headerlink" title="3.3.2 问题2 多客户端"></a>3.3.2 问题2 多客户端</h3><p>tcp服务器要想给多个客户端提供服务，就必须采用多线程&#x2F;多进程的方式来实现操作。否则会出现一个严重的问题，服务端因为提供服务而没有<code>accept</code>，无法链接上下一个客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//accept 获取到链接上的客户端</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//如果在这里提供服务，则会其他连接会在listen里面阻塞</span></span><br><span class="line">    	<span class="comment">//只有当前服务终止了，其他客户端的其中之一才能连上服务器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-问题3-线程传参"><a href="#3-3-3-问题3-线程传参" class="headerlink" title="3.3.3 问题3 线程传参"></a>3.3.3 问题3 线程传参</h3><p>既然需要采用多线程服务，那就需要设定好给线程传的参数。理论上来说，我们只需要传入accept的返回值<code>socket fd</code>即可进行<code>read/write</code></p><p>但实际上，我们还需要打印debug消息，要知道当前是谁向你发送了这条消息，ip和端口是什么。</p><p>为了方便操作，这里封装一个结构体，将socket fd，客户端的ip+端口封装成一个参数进行传参（<strong>线程的函数只能传入一个参数</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClientData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> _fd;</span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">    <span class="built_in">string</span> _ip;</span><br><span class="line">    TcpServer* _this;</span><br><span class="line"></span><br><span class="line">    ClientData(<span class="type">int</span> fd,<span class="type">uint16_t</span> port,<span class="type">const</span> <span class="built_in">string</span>&amp; ip,TcpServer* this1)</span><br><span class="line">        :_fd(fd),_port(port), _ip(ip),_this(this1)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可能会想到另外一个办法，那就是在tcp服务器的class中新增一个map成员变量，用于映射socket fd和客户端信息的键值对，但是这无法实现。</p><p>因为在类中设计的多线程函数，为了去掉默认传入的<code>this</code>指针，必须要设置成<code>static</code>静态的，此时该静态函数<strong>无法访问</strong>类内成员！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为需要取消this指针，所以需要设置成静态的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">threadRoutine</span><span class="params">(<span class="type">void</span>*args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>()); <span class="comment">//设置线程分离</span></span><br><span class="line">    ClientData* data=(ClientData*)args;</span><br><span class="line">    <span class="comment">// 通过预先设置的this指针来访问类内成员，并进行传参</span></span><br><span class="line">    data-&gt;_this-&gt;<span class="built_in">transService</span>(data-&gt;_fd,data-&gt;_ip,data-&gt;_port);</span><br><span class="line">    <span class="keyword">delete</span> data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-服务代码"><a href="#3-3-4-服务代码" class="headerlink" title="3.3.4 服务代码"></a>3.3.4 服务代码</h3><p>解决了上面的问题，就可以继续往下看看服务端的代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供服务</span></span><br><span class="line"><span class="type">pthread_t</span> service;</span><br><span class="line"><span class="comment">// 因为这个成员使用范围极小，所以采用new/delete，避免占用太多空间</span></span><br><span class="line">ClientData* data = <span class="keyword">new</span> <span class="built_in">ClientData</span>(conet,senderPort,senderIP,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;service,<span class="literal">nullptr</span>,threadRoutine,(<span class="type">void</span>*)data);</span><br></pre></td></tr></table></figure><p>在accept之后，通过线程操作用线程来提供服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">threadRoutine</span><span class="params">(<span class="type">void</span>*args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>()); <span class="comment">//设置线程分离</span></span><br><span class="line">    ClientData* data=(ClientData*)args;</span><br><span class="line">    <span class="comment">// 通过预先设置的this指针来访问类内成员，并进行传参</span></span><br><span class="line">    data-&gt;_this-&gt;<span class="built_in">transService</span>(data-&gt;_fd,data-&gt;_ip,data-&gt;_port);</span><br><span class="line">    <span class="keyword">delete</span> data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>threadRoutine</code>的作用就是把线程的单参数转为多参数，传给真正用来服务的函数。函数的操作很简单，就是Linux下文件操作的读写。</p><p>读写成功后，将客户端发来的信息转成ASCII码的和发回给客户端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transService</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> std::string &amp;clientIp, <span class="type">uint16_t</span> clientPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(!clientIp.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">assert</span>(clientPort&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 开始服务</span></span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取客户端发来的信息,s是读取到的字节数</span></span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[s]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//手动添加字符串终止符</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(buf,<span class="string">&quot;quit&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//客户端主动退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 服务</span></span><br><span class="line">            string tmp = buf;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">str2ascii</span>(tmp);<span class="comment">//获取字符串的ascii总和</span></span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            string retS =  <span class="built_in">to_string</span>(ret);<span class="comment">//转字符串</span></span><br><span class="line">            cout &lt;&lt; retS &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">write</span>(sockfd,retS.<span class="built_in">c_str</span>(),retS.<span class="built_in">size</span>());<span class="comment">//写入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//s == 0代表对方关闭,客户端退出</span></span><br><span class="line">            <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;client quit: %s[%d]&quot;</span>, clientIp.<span class="built_in">c_str</span>(), clientPort);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;read err: %s[%d] -  %s&quot;</span>, clientIp.<span class="built_in">c_str</span>(), clientPort, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">logging</span>(DEBUG,<span class="string">&quot;server quit %d&quot;</span>,sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 服务函数可以不暴露</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">str2ascii</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:str)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-提供服务（子进程）"><a href="#3-4-提供服务（子进程）" class="headerlink" title="3.4 提供服务（子进程）"></a>3.4 提供服务（子进程）</h2><p>上面的代码采用的是线程来提供服务，除了线程，我们还有父子进程的方式，也能避免阻塞</p><p>需要注意的是，父子进程都需要关闭掉对方使用的文件描述符，避免出现文件描述符在服务结束后还没有关闭的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> id = fork();</span><br><span class="line"><span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(_listenSock);<span class="comment">//因为子进程不需要监听，所以关闭掉监听socket</span></span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="built_in">transService</span>(conet, senderIP, senderPort);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程</span></span><br><span class="line"><span class="built_in">close</span>(conet); <span class="comment">// 因为此时是子进程提供服务，conet会有拷贝，相当于有两个进程打开了该文件</span></span><br><span class="line"><span class="comment">// 如果父进程不关闭，即便子进程结束服务了，该文件描述符也会保持开启</span></span><br><span class="line"><span class="type">pid_t</span> ret = <span class="built_in">waitpid</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>直接这样写有一个很大的问题，那就是父进程没有办法正常释放子进程的资源</p><ul><li>如果进行阻塞等待，那就违背了初衷，完全没有意义</li><li>如果进行非阻塞等待，在<code>waitpid</code>结束之后，父进程直接去干其他事了，完全忘记了这里的这个子进程</li></ul><p>所以我们要做的，就是在子进程退出，向<strong>父进程发送信号</strong>的时候回收子进程</p><h3 id="3-4-1-信号回收"><a href="#3-4-1-信号回收" class="headerlink" title="3.4.1 信号回收"></a>3.4.1 信号回收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD, FreeChild);<span class="comment">//自定义捕捉</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回收子进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FreeChild</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(signo == SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果没有子进程了，waitpid就会调用失败</span></span><br><span class="line">        <span class="type">pid_t</span> id = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>, WNOHANG); <span class="comment">// 非阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父进程等待成功, child pid: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还有子进程没有退出</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;尚有未退出的子进程，父进程继续运行&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//退出等待子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父进程等待所有子进程结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了自定义捕捉，我们还可以设置成ignore不搭理子进程，这样子进程退出的时候就会被系统自动释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD, SIG_IGN);</span><br></pre></td></tr></table></figure><h3 id="3-4-2-爷爷进程"><a href="#3-4-2-爷爷进程" class="headerlink" title="3.4.2 爷爷进程"></a>3.4.2 爷爷进程</h3><p>这里还有另外一个骚操作，那就是在创建子进程之后，再创建一个子进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供服务（孙子进程）-2</span></span><br><span class="line"><span class="type">pid_t</span> id = fork();</span><br><span class="line"><span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(_listenSock);<span class="comment">//因为子进程不需要监听，所以关闭掉监听socket</span></span><br><span class="line">    <span class="comment">//又创建一个子进程，大于0代表是父进程，即创建完子进程后父进程直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(fork()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 孙子进程执行</span></span><br><span class="line">    <span class="built_in">transService</span>(conet, senderIP, senderPort);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 爷爷进程</span></span><br><span class="line"><span class="built_in">close</span>(conet); </span><br><span class="line"><span class="type">pid_t</span> ret = <span class="built_in">waitpid</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>); <span class="comment">//此时就可以直接用阻塞式等待了</span></span><br><span class="line"><span class="built_in">assert</span>(ret &gt; <span class="number">0</span>);<span class="comment">//ret如果不大于0，则代表等待发生了错误</span></span><br></pre></td></tr></table></figure><p>采用这种办法以后，由于父进程退出了，<strong>孙子进程会直接被操作系统接管</strong>。下图中能看到这些进程的父进程都是<strong>1</strong>，即操作系统。这时候我们也不需要担心子进程的释放问题了</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63e1c184403cd.png" alt="image-20230207111205871"></p><h1 id="4-客户端"><a href="#4-客户端" class="headerlink" title="4.客户端"></a>4.客户端</h1><p>客户端部分的代码和udp也很相似，只不过将sendto改成了write</p><p>下方提供了客户端的代码，都写了注释😁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./clientTcp serverIp serverPort</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)<span class="comment">//客户端必须要有3个参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage:\n\t&quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; serverIp serverPort&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Example:\n\t&quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; 127.0.0.1 8080\n&quot;</span></span><br><span class="line">                &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(USAGE_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析服务端的ip和端口</span></span><br><span class="line">    string serverIp = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint16_t</span> serverPort = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建tcp的socket SOCK_STREAM</span></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;socket: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(SOCKET_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. connect，发起链接请求，你想谁发起请求呢？？当然是向服务器发起请求喽</span></span><br><span class="line">    <span class="comment">// 2.1 先填充需要连接的远端主机的基本信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(serverPort);</span><br><span class="line">    <span class="built_in">inet_aton</span>(serverIp.<span class="built_in">c_str</span>(), &amp;server.sin_addr);</span><br><span class="line">    <span class="comment">// 2.2 发起请求，connect 会自动bind</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;server, <span class="built_in">sizeof</span>(server)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;connect: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(CONN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;connect success: &quot;</span> &lt;&lt; sock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端发现的消息</span></span><br><span class="line">    string message;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message.<span class="built_in">clear</span>();<span class="comment">//每次循环开始，都清空一下msg</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入你的消息# &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, message);<span class="comment">//获取输入</span></span><br><span class="line">        <span class="comment">// 如果客户端输入了quit，则退出</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(message.<span class="built_in">c_str</span>(), <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 向服务端发送消息</span></span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">write</span>(sock, message.<span class="built_in">c_str</span>(), message.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) <span class="comment">// 写入成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            message.<span class="built_in">clear</span>();<span class="comment">//清空输入的消息</span></span><br><span class="line">            message.<span class="built_in">resize</span>(BUFFER_SIZE);</span><br><span class="line">            <span class="comment">// 因为string的c_str本质上是返回地址，所以强转后是可以往里面写入的</span></span><br><span class="line">            s = <span class="built_in">read</span>(sock, (<span class="type">char</span> *)(message.<span class="built_in">c_str</span>()), BUFFER_SIZE);<span class="comment">// 获取服务端的结果</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; <span class="number">0</span>)<span class="comment">// 读取成功</span></span><br><span class="line">            &#123;</span><br><span class="line">                message[s] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//追加\0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印返回值</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Server Echo# &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &lt;= <span class="number">0</span>) <span class="comment">// 写入失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-运行测试"><a href="#4-1-运行测试" class="headerlink" title="4.1 运行测试"></a>4.1 运行测试</h2><p>先运行服务端，再运行客户端，客户端输入后，服务短会返回字符串的ascii码总和</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63e1aff8cb944.png" alt="image-20230207095713615"></p><p>而客户端输入quit后，在服务端可以看到客户端退出，但服务端并没有推出，正在等待下一个连接</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63e1b0576b69f.png" alt="image-20230207095848863"></p><h1 id="5-守护进程"><a href="#5-守护进程" class="headerlink" title="5.守护进程"></a>5.守护进程</h1><p>守护进程吧默认的0.1.2都重定向到<code>dev/null</code>，是因为设置成独立的进程组和进程会话了之后，当前进程是没有和bash关联的，默认这个0，1，2所指向的bash是无效的，此时如果不重定向，使用cout打印的时候，就会引发异常（可以理解为往一个不存在的文件中写内容）无法实现守护进程</p><p>重定向了之后，所有的打印输出都会被丢到<code>/dev/null</code>这个文件垃圾桶中，也就不需要担心上述的问题</p><p>linux系统中有一个接口<code>daemon</code>，可以帮我们实现守护进程。</p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【Linux】来写一个tcp的服务端+客户端</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2023-02-05 12:30:55</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2023/02/05/note_Linux/29tcp代码/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E7%BD%91%E7%BB%9C/">#网络</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2023/02/08/note_cpp/27using%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【C++】using的三种用法</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2023/02/04/note_Python/8python%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%8B%E8%BD%BDmd%E6%96%87%E4%BB%B6%E4%B8%AD%E5%9B%BE%E7%89%87/"><span class="title flex-center"><span class="post-nav-title-item">【Python】自动解析markdown中的图片并保存</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true'
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><span class="nav-text">1.基本框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-text">1.1 类成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">1.2 头文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">2.初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%9E%84%E9%80%A0sock"><span class="nav-text">2.1 构造sock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%88%9D%E5%A7%8B%E5%8C%96sockaddr-in"><span class="nav-text">2.2 初始化sockaddr_in</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-bind"><span class="nav-text">2.3 bind</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E7%9B%91%E5%90%AClisten"><span class="nav-text">2.4 监听listen</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E8%BF%90%E8%A1%8C"><span class="nav-text">3.运行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-accept"><span class="nav-text">3.1 accept</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF"><span class="nav-text">3.2 获取连接信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%EF%BC%88%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="nav-text">3.3 提供服务（线程）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E9%97%AE%E9%A2%981-%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="nav-text">3.3.1 问题1 如何通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E9%97%AE%E9%A2%982-%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">3.3.2 问题2 多客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E9%97%AE%E9%A2%983-%E7%BA%BF%E7%A8%8B%E4%BC%A0%E5%8F%82"><span class="nav-text">3.3.3 问题3 线程传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%A0%81"><span class="nav-text">3.3.4 服务代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%EF%BC%88%E5%AD%90%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="nav-text">3.4 提供服务（子进程）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E4%BF%A1%E5%8F%B7%E5%9B%9E%E6%94%B6"><span class="nav-text">3.4.1 信号回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E7%88%B7%E7%88%B7%E8%BF%9B%E7%A8%8B"><span class="nav-text">3.4.2 爷爷进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">4.客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="nav-text">4.1 运行测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-text">5.守护进程</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://musnow.top" target="_blank"><img src="https://img.shields.io/badge/%E4%B8%BB%E7%AB%99-%E7%82%B9%E6%88%91-blueviolet" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>