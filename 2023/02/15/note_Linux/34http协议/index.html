<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-E1K9nNha9u"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><title>【网络】http(s)协议 | 介绍 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【网络】http(s)协议 | 介绍</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2023-02-15 11:30:55</span> <span class="mobile">2023-02-15 11:30</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-02-16 22:40:34</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E7%8E%A9%E4%B8%8ALinux/">玩上Linux</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/%E7%BD%91%E7%BB%9C/">网络</a>&nbsp;</li><li>| <a href="/tags/http/">http</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>10.3k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>已经学习过自己定制一个协议了，现在就来看看当下广泛使用的http协议吧</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><blockquote><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p></blockquote><p>http和https是当下最通用的协议之一，我们访问的大部分网页用的都是这个协议；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/</span><br></pre></td></tr></table></figure><p>这两个协议主要的差别，那就是http是用明文传输数据的，我们的数据在互联网裸奔，可能有安全问题；相比之下，https传输数据的过程会对数据进行加密，但这也不代表https是完全安全的。</p><h2 id="1-1-url"><a href="#1-1-url" class="headerlink" title="1.1 url"></a>1.1 url</h2><p>要认识这两个协议，我们要从url的认识开始；</p><p><code>HTTP(S)</code> 不允许使用用户名或密码，一个合法的 <code>HTTP(S)</code> URL 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure><ul><li>开头为协议名：http 或 https 协议；</li><li><code>&lt;host&gt;</code>：主机名。一个 URL 中，既可以使用域名也可以使用 IP 表示主机地址</li><li><code>&lt;port&gt;</code>：端口。主机名和端口之间使用冒号分隔。端口是可选的，如果省略将采用默认端口，http 默认端口是 80，https 默认端口 443；</li><li><code>&lt;path&gt;</code>：资源路径。资源在网络主机上的路径，路径也是可选的，缺省访问默认资源；</li><li><code>&lt;query&gt;</code>：查询参数。格式为 key&#x3D;value，多个参数使用 &amp; 分隔；参数也是可选的；</li><li><code>&lt;frag&gt;</code>：片段。从 # 开始到最后，一般用于定位到资源内的一个片段，比如文档的一个章节；片段也是可选的。</li></ul><h3 id="1-1-1-栗子-①"><a href="#1-1-1-栗子-①" class="headerlink" title="1.1.1 栗子 ①"></a>1.1.1 栗子 ①</h3><p>接下来举一个具体的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile</span><br></pre></td></tr></table></figure><p>如上是我的个人博客中的一篇文章</p><ul><li>协议是https</li><li>域名是<code>blog.musnow.top</code>，对应的就是<code>&lt;host&gt;:&lt;port&gt;</code>；这里隐藏了端口，会在下面说明。</li><li><code>/2022/08/07/note_linux/6gdb_g++_make_vim/</code>这一长串都是文件的路径，其标示了文件在服务器上存放的位置</li><li>这个url内没有带<code>&lt;query&gt;</code>参数</li><li><code>#4-make-x2F-makefile</code>对应的是<code>&lt;frag&gt;</code>片段，标识了我当前浏览的位置</li></ul><p>当你把这个url粘贴道浏览器，其会直接跳转到对应的标题位置，而不是这篇文章的页首；这就是<code>&lt;frag&gt;</code>片段的作用</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec475e3c6a2.png" alt="image-20230215104544655"></p><h3 id="1-1-2-栗子-②"><a href="#1-1-2-栗子-②" class="headerlink" title="1.1.2 栗子 ②"></a>1.1.2 栗子 ②</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=test</span><br></pre></td></tr></table></figure><p>当我们在百度搜索单词<code>test</code>的时候，百度的url中就会出现<code>&lt;query&gt;</code>参数；</p><p>其中<code>?</code>是参数的开头，后续的一串以<code>&amp;</code>分隔的kv键值对，就是参数的内容。在这里面我们能看到<code>word=test</code>，我们查询的单词test就在这个参数后；</p><p>我们的搜索访问，就是将这些参数传送给服务器，再由百度的服务器返回搜素结果的。</p><h2 id="1-2-域名和端口隐藏"><a href="#1-2-域名和端口隐藏" class="headerlink" title="1.2 域名和端口隐藏"></a>1.2 域名和端口隐藏</h2><p>但我们日常访问的网页中，很少见到过<code>ip:端口</code>的形式，而大多是用域名为我们提供服务的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/</span><br></pre></td></tr></table></figure><p>这并不代表其背后不需要端口号。而是因为如果我们的访问<strong>不指定端口</strong>的时候，http(s)协议会采用默认端口号80或443，从而实现隐藏端口号提供服务</p><blockquote><p>http 默认端口是 80，https 默认端口 443</p></blockquote><p>毕竟对于用户而言，记住一个域名已经不容易了，还要记住你的服务是在哪一个端口，那就更难了；</p><p>而域名也不是凭空给我们提供服务的，每一个域名都需要绑定一个具体的公网ip（域名解析），才能为用户提供服务。在域名的背后，都是一个ip，每一个ip也就是一台服务器。</p><p>域名的作用，就是来隐藏掉ip这个无规律的长数字，方便用户访问；</p><blockquote><p>你觉得是记住<code>baidu.com</code>容易，还是记住<code>114.514.77.58</code>容易呢？</p></blockquote><p>在命令行使用ping工具，我们能知道一个网站服务器的ip是什么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.bilibili.com</span><br></pre></td></tr></table></figure><p>比如我们ping一下b站的域名，可以看到其公网ip是<code>183.131.147.29</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正在 Ping a.w.bilicdn1.com [183.131.147.29] 具有 32 字节的数据:</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=10ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line"></span><br><span class="line">183.131.147.29 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 10ms，最长 = 12ms，平均 = 11ms</span><br></pre></td></tr></table></figure><h2 id="1-3-ip-端口"><a href="#1-3-ip-端口" class="headerlink" title="1.3 ip:端口"></a>1.3 ip:端口</h2><p>我们可以用<code>ip:端口</code>来访问自己的服务（以下ip纯属虚构，如有撞车，纯属巧合）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">114.514.77.58:8080</span><br></pre></td></tr></table></figure><p>当我们把这个粘贴道浏览器，再复制粘贴出来的时候，我们会发现前面多了一个http</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://114.514.77.58:8080</span><br></pre></td></tr></table></figure><p>这是因为当我们使用ip访问一个服务的时候，浏览器会默认采用http的协议去访问，所以在前面加了一个我们看不到的<code>http://</code></p><h2 id="1-4-协议作用"><a href="#1-4-协议作用" class="headerlink" title="1.4 协议作用"></a>1.4 协议作用</h2><p>http协议的作用，就是向<strong>服务器</strong>申请特定的资源，再将资源拉取到本地进行展示or使用。</p><p>资源都是存在我们的服务器上的，当用户请求的时候，服务器必须要知道资源的路径，将其<code>read</code>打开读取，再<code>write</code>写给我们的客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p>所以http的请求中才会带上资源的路径，这是方便服务器进行资源文件的读取；同时，文件的路径也是对一个文件的唯一标识，在告诉服务器文件路径的同时，也保证了我们请求的文件的唯一性，不会出现二义性；</p><hr><p>这时候又会出现一个问题，当我们访问网站的根目录的时候，没有提供文件的路径呀，那这时候，访问的什么文件呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br></pre></td></tr></table></figure><p>实际上，我们访问的是服务器根目录的<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br><span class="line">https://www.baidu.com/index.html</span><br></pre></td></tr></table></figure><p>你可以试着打开这两个链接，其出现的页面是完全一致的；</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec4cb9820b6.png" alt="image-20230215110843400"></p><p>类似于端口号隐藏，http协议也确定了当下使用的网页文件的命名为<code>index.html</code>，当我们访问一个网站的时候，就会默认访问根目录下的<code>index.html</code>文件（既然是默认的，那就可以直接隐藏）如果这个文件不存在，那就不会渲染出我们看到的网页！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.html是用前端语言编写的网页代码</span><br></pre></td></tr></table></figure><p>同理，当我们访问博客的时候，读取道的也不是目录，而是目录下的<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec4d38428a8.png" alt="image-20230215111050026"></p><p>我的博客使用的是hexo框架，其网页的源路径在github上开源了，可以帮助你理解url中的文件路径。</p><p>当前你看到的文件目录，就是博客服务的根目录。访问的博客首页，就是根目录下的<code>index.html</code></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec4d71b69ed.png" alt="image-20230215111147560"></p><p>用作示例的<a href="https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/index.html">linux工具使用</a>博客，也可以根据它的路径，找到<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec4e066de99.png" alt="image-20230215111416443"></p><p>这便是http协议url中文件路径的作用！</p><p>这里的<code>/</code>根目录是<strong>服务端设置</strong>的，并不一定是（大概率不是）服务端linux服务器的根目录</p><h2 id="1-5-编码解码"><a href="#1-5-编码解码" class="headerlink" title="1.5 编码解码"></a>1.5 编码解码</h2><p>在url中，还会对一些特殊字符进行编解码，比如中文，和一些特殊的符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile</span><br></pre></td></tr></table></figure><p>比如在作为示例的url中，这里出现了<code>x2F</code>，而原文中是<code>4.make/makefile</code>;这里的编码就是为了避免<code>make/makefile</code>被识别成路径的标识符，从而出现错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=%E4%BD%A0%E5%A5%BD</span><br></pre></td></tr></table></figure><p>当url路径中有中文的时候，也会被转码成特定的格式</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec503e1f0d6.png" alt="image-20230215112344227"></p><p>我们在浏览器上看到的依旧是中文，这是因为浏览器这段帮我们进行了解码</p><blockquote><p>将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成<code>%XY</code>格式</p></blockquote><h1 id="2-http协议请求格式"><a href="#2-http协议请求格式" class="headerlink" title="2.http协议请求格式"></a>2.http协议请求格式</h1><p>了解了http协议中的url网址，现在就可以进一步了解http协议的报头和报文了;</p><p>一个<code>http request/response</code>的基本格式如下</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec536219bf8.png" alt="image-20230215113707995"></p><p>在请求中，客户端会提供自己的请求方法（GET&#x2F;POST&#x2F;PUT等等），并提供url来标识自己需要的文件路径；这个url可能是短链接（截取根目录之后的部分），也有可能是完整的链接。</p><p>随后，就会跟上一大堆的请求参数，注意，这里的请求参数并不是url中的<code>&lt;query&gt;</code>参数，而是http协议自身的请求参数。每一个请求参数都用了<code>\r\n</code>作为分隔，这和我们写的<a href="https://blog.musnow.top/2023/02/11/note_linux/32tcp%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/#3-1-%E5%8D%8F%E8%AE%AE%E5%AE%9A%E5%88%B6">自定义协议</a>中采用<code>\t</code>进行分割是相同的原理！</p><p>这几个部分中，请求的正文可以不带（为空）</p><h2 id="2-1-读取多长？"><a href="#2-1-读取多长？" class="headerlink" title="2.1 读取多长？"></a>2.1 读取多长？</h2><p>为了让协议读取的时候，能够知道什么时候读取完毕了报头，http协议提供了一个<code>\r\n</code>的空行，读取道这个空行，就代表报头读取完毕了，剩下的内容都是报文。</p><p>而为了标识报文的长度，http协议会在发送的时候提供一个参数<code>content-length</code>，用于标识报文的长度。在读取完毕报头后，肯定是读取到了这个<code>content-length</code>参数的，也就知道后续应该继续读取多长，才能读完整个协议字段！</p><p>关于这部分的介绍，可以查看另外一篇博客 <a href="https://blog.musnow.top/2023/02/15/note_Linux/35http%E4%B8%ADcontent-length/">http协议content-length详解</a></p><h2 id="2-2-响应的状态码"><a href="#2-2-响应的状态码" class="headerlink" title="2.2 响应的状态码"></a>2.2 响应的状态码</h2><p>和我们进程的退出状态一样，http也表明了一部分响应的状态码，其中我们日常最常见到的，是<code>404/403</code>这两个状态码</p><blockquote><p><a class="link" target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660">http状态码-百度百科<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>状态码就是标识服务器提供的服务状态，告诉客户端它的请求是否成功了。如果状态码是200，代表请求是成功的。其余状态码会有各自的使用场景，比如404状态码，代表请求的资源不存在，所以才叫 <code>404 not found!</code></p><h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h1><p>完整代码详见 <a class="link" target="_blank" rel="noopener" href="https://gitee.com/musnow/raspberry-practice/tree/master/code">Gitee<i class="fas fa-external-link-alt"></i></a></p><h2 id="3-1-前端页面"><a href="#3-1-前端页面" class="headerlink" title="3.1 前端页面"></a>3.1 前端页面</h2><p>由于本人并没有学习过前端语法，这里采用 <a class="link" target="_blank" rel="noopener" href="https://www.runoob.com/html/html-tutorial.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a> 提供的前端示例代码来演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们日常所访问的网页都是这样的代码，经由浏览器进行渲染，再展示出来</p><h2 id="3-2-服务端代码"><a href="#3-2-服务端代码" class="headerlink" title="3.2 服务端代码"></a>3.2 服务端代码</h2><p>由于http是基于tcp的，这里直接把之前写的tcpServer搬过来就能用！具体的代码解析请看注释，想必说的是很清楚的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF <span class="string">&quot;\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF_LEN strlen(CRLF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE_LEN strlen(SPACE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOME_PAGE <span class="string">&quot;index.html&quot;</span> <span class="comment">// 首页文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOT_PATH <span class="string">&quot;web&quot;</span> <span class="comment">// 网址根目录地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取http请求中的路径</span></span><br><span class="line"><span class="function">string <span class="title">getPath</span><span class="params">(string http_request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> pos = http_request.<span class="built_in">find</span>(CRLF);<span class="comment">//找到第一行的分隔符</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    string request_line = http_request.<span class="built_in">substr</span>(<span class="number">0</span>, pos);<span class="comment">//取出第一行</span></span><br><span class="line">    <span class="comment">//请求的第一行：GET /a/b/c http/1.0</span></span><br><span class="line">    <span class="type">size_t</span> first = request_line.<span class="built_in">find</span>(SPACE);<span class="comment">// 找到第一个空格</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> second = request_line.<span class="built_in">rfind</span>(SPACE); <span class="comment">// 从后往前找空格</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 找到两个空格了，两个空格之间的就是请求的路径</span></span><br><span class="line">    string path = request_line.<span class="built_in">substr</span>(first+SPACE_LEN, second - (first+SPACE_LEN));</span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        path += HOME_PAGE; <span class="comment">//再加上被隐藏的index.html文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="function">string <span class="title">readFile</span><span class="params">(<span class="type">const</span> string &amp;recource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(recource, ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in.<span class="built_in">is_open</span>()) <span class="comment">//文件打开失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;404&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    string content;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, line))</span><br><span class="line">    &#123;</span><br><span class="line">        content += line;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handlerHttpRequest</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;###########start#############&quot;</span> &lt;&lt; endl;<span class="comment">//打印一个分隔线</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10240</span>];</span><br><span class="line">    <span class="type">ssize_t</span> s = <span class="built_in">read</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;###########end############&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string path = <span class="built_in">getPath</span>(buffer);</span><br><span class="line">    <span class="comment">// 假设用户请求的是 /a/b 路径</span></span><br><span class="line">    <span class="comment">// 那么服务端处理的时候，就需要添加根目录位置和默认的文件名</span></span><br><span class="line">    <span class="comment">// &lt;root&gt;/a/b/index.html</span></span><br><span class="line">    <span class="comment">// 在本次用例中，根目录为 ./web文件夹，所以完整的文件路径应该是</span></span><br><span class="line">    <span class="comment">// ./web/a/b/index.html</span></span><br><span class="line"></span><br><span class="line">    string resources = ROOT_PATH; <span class="comment">// 根目录路径</span></span><br><span class="line">    resources += path; <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="built_in">logging</span>(DEBUG,<span class="string">&quot;[sockfd: %d] filePath: %s&quot;</span>,sock,resources.<span class="built_in">c_str</span>()); <span class="comment">// 打印用作debug</span></span><br><span class="line"></span><br><span class="line">    string html = <span class="built_in">readFile</span>(resources);<span class="comment">// 打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始响应</span></span><br><span class="line">    string response = <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;</span><br><span class="line">    <span class="comment">//如果readFile返回的是404，代表文件路径不存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(html.<span class="built_in">c_str</span>(),<span class="string">&quot;404&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.0 404 NOT FOUND\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加后续字段</span></span><br><span class="line">    response += <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>;</span><br><span class="line">    response += (<span class="string">&quot;Content-Length: &quot;</span> + <span class="built_in">to_string</span>(html.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    response += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    response += html;</span><br><span class="line">    <span class="comment">// 发送给用户</span></span><br><span class="line">    <span class="built_in">send</span>(sock, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h2><p>启动服务器之前，请先打开你的云服务器防火墙中的对应端口；这里我绑定的是端口10000，在浏览器中用<code>ip:端口</code>的方式可以正常访问！</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec6f01b93dd.png" alt="image-20230215133459929"></p><p>这里标识的<code>不安全</code>是因为我们没有采用带加密的https协议，这不是当下需要考虑的问题。不管他就可以了。</p><p>按F12打开开发者页面，可以看到下方出现了完整的html代码，我们成功提供了服务！</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec720503cdc.png" alt="image-20230215134751216"></p><h2 id="3-4-后端打印的报文"><a href="#3-4-后端打印的报文" class="headerlink" title="3.4 后端打印的报文"></a>3.4 后端打印的报文</h2><p>在服务器后端，我们看到其打印出来了一个基本的http请求，和上面说明的格式是一样的。这里简单的进行一部分说明：</p><ul><li>GET：请求方式为获取数据</li><li><code>/</code>：请求的是根路径</li><li><code>HTTP/1.1</code>：使用的http协议版本</li><li><code>Connetion</code>：代表我们和服务器的链接方式，keep-alive代表保持连接</li><li><code>User-Agent</code>：客户端信息，可以看到是windows系统、Chrome内核的浏览器（我是用的是edge浏览器）</li><li>Accept: 支持接收的信息类型</li><li><code>Aceept-Encoding</code>: 对信息进行压缩</li><li><code>Accept-Language</code>：支持的语言</li><li><code>Cookie</code>：身份信息，后面会详细介绍</li></ul><p>其中出现了一个空行，代表报文结束；</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec78b4c5cf2.png" alt="image-20230215141623151"></p><p>往下滑，会发现浏览器还发出了第二个请求，路径是<code>/favicon.ico</code>，这是默认的站点头像文件的命名。因为我们的html文件中没有写明站点头像的路径，所以浏览器就尝试请求默认的头像文件</p><p>但是，当前我们的站点根目录web下并没有该文件，应该返回一个404状态码。</p><ul><li>请求中出现了一个新的参数<code>Referer</code>，代表是从当前网页请求头像的。相比之下，请求网页的报文中没有<code>Referer</code>参数</li></ul><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec8b10b0daf.png" alt="image-20230215153442298"></p><p>此时可以随便找个图片做头像，看看能不能加载出来；为了方便，我随便找了一张纯绿色的图片，并将其<a class="link" target="_blank" rel="noopener" href="http://www.ico51.cn/">在线转换为ico<i class="fas fa-external-link-alt"></i></a>，放入了站点的根目录。</p><p>重启服务器进程，刷新浏览器再次请求，可以看到成功出现了站点的头像；</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec7575b082e.png" alt="image-20230215140232033"></p><h2 id="3-5-常见参数表"><a href="#3-5-常见参数表" class="headerlink" title="3.5 常见参数表"></a>3.5 常见参数表</h2><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec8de7299b2.png" alt="img"></p><h1 id="4-请求方法"><a href="#4-请求方法" class="headerlink" title="4.请求方法"></a>4.请求方法</h1><p>一般我们获取一个网页，用的都是GET方法。接下来用一个带按钮的表单创建请求，尝试向服务端发送<code>&lt;query&gt;</code>参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-1-GET"><a href="#4-1-GET" class="headerlink" title="4.1 GET"></a>4.1 GET</h2><p>在method里面，我们指定了get方法，此时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时页面中出现了两个输入框，供我们输入密码，且密码会显示为<code>****</code>而不是明文</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec89644d733.png" alt="image-20230215152726050"></p><p>点击按钮，会跳转到一个404页面，这是因为我们的<code>a/index.html</code>路径并不支持参数请求，所以发送了404错误码</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec89a063d20.png" alt="image-20230215152834203"></p><p>不过这不重要，我们看看后端打印的内容。其中参数是追加到url中，以明文传输过来的；正文部分为空，并没有携带参数</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec8b5dd10c0.png" alt="image-20230215153559515"></p><h2 id="4-2-POST"><a href="#4-2-POST" class="headerlink" title="4.2 POST"></a>4.2 POST</h2><p>将请求方法改成post，再次尝试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候能正常显示出<code>a/index.html</code>页面，url中不再带有参数</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec8beb1e0c5.png" alt="image-20230215153820898"></p><p>此时查看后端中的信息，能看到请求方法变为POST，参数出现在了正文部分，而不是url中</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec8c2e7faa5.png" alt="image-20230215153928118"></p><h2 id="4-3-GET-x2F-POST区别"><a href="#4-3-GET-x2F-POST区别" class="headerlink" title="4.3 GET&#x2F;POST区别"></a>4.3 GET&#x2F;POST区别</h2><p>这也是GET和POST方法的区别之一：</p><ul><li>GET方法通过url传参</li><li>POST方法会将url参数提取出来，拼接到正文部分</li></ul><p>由此能推出二者的安全性区别</p><ul><li>GET方法相对不安全，因为参数直接以明文贴在了url上</li><li>POST方法以正文传参，使用https协议的时候能进行加密，相对较安全</li></ul><h2 id="4-4-更多方法"><a href="#4-4-更多方法" class="headerlink" title="4.4 更多方法"></a>4.4 更多方法</h2><p>http请求还支持更多方法，如下</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec8daba6e19.png" alt="img"></p><h1 id="5-状态码"><a href="#5-状态码" class="headerlink" title="5.状态码"></a>5.状态码</h1><h2 id="5-1-状态码表"><a href="#5-1-状态码表" class="headerlink" title="5.1 状态码表"></a>5.1 状态码表</h2><p>下面是一个响应状态码的总表</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec8ef551dec.png" alt="image-20230215155118813"></p><h2 id="5-2-404-x2F-403状态码"><a href="#5-2-404-x2F-403状态码" class="headerlink" title="5.2 404&#x2F;403状态码"></a>5.2 404&#x2F;403状态码</h2><p>我们能看到404和403都是客户端状态码，为什么说是客户端错误呢？这是因为你向服务器请求了一个服务器没有的资源，<strong>这个问题不应该是服务器的问题</strong>。</p><p>这就好比你去西瓜摊买肉，人家压根不卖肉。问题出在你身上，你不应该找西瓜摊老板买肉。所以404状态码，应该是客户端的问题！</p><p>而403状态码的含义是<code>403 forbidden</code>，服务器拒绝了你的请求（你没有权限访问）这也是客户端的问题。你不能去超市买东西，然后问老板能不能让你看看老板的钱罐子。老板肯定不给你看啊！所以才会告诉你403，不给你访问。</p><h2 id="5-3-5xx状态码"><a href="#5-3-5xx状态码" class="headerlink" title="5.3 5xx状态码"></a>5.3 5xx状态码</h2><p>什么时候会出现服务器错误的5xx状态码呢？</p><p>当你请求一个服务，服务端需要处理之后给你返回结果。此时服务器在处理过程中，可能因为程序有bug提前退出，这时候就应该给客户端发送一个<code>5xx</code>状态码，标识服务器在处理你的请求的过程中，出现了错误，无法返回结果。</p><h2 id="5-4-301-x2F-302重定向"><a href="#5-4-301-x2F-302重定向" class="headerlink" title="5.4 301&#x2F;302重定向"></a>5.4 301&#x2F;302重定向</h2><p>关于3开头的状态码，主要谈谈下面这两个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">301 永久重定向</span><br><span class="line">302 临时重定向</span><br></pre></td></tr></table></figure><p>为何一个是永久，一个是临时呢？</p><p>在http进行响应的时候，服务端可以发送一个<code>location</code>参数，发送一个新的url给客户端；我们的浏览器在收到这个参数后，会自动打开对应的页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: https://www.baidu.com/</span><br></pre></td></tr></table></figure><p>我们可以用上面的代码来测试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试进行302重定向</span></span><br><span class="line">string response = <span class="string">&quot;HTTP/1.1 302 Temporarily moved\r\n&quot;</span>;</span><br><span class="line">response+= <span class="string">&quot;Location: https://www.baidu.com/\r\n&quot;</span>;</span><br><span class="line">response+= <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给用户</span></span><br><span class="line"><span class="built_in">send</span>(sock, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>此时访问我们自己的<code>IP:端口</code>，会跳转到百度的页面。这就是重定向的作用</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ec9497019d5.png" alt="image-20230215161520817"></p><ul><li>那临时重定向和永久重定向有什么区别呢?</li></ul><p>假如我设立了一个公开站点，域名是<code>test.com</code>，这几年一直提供服务，积累了一部分的用户。过了一会，我不想要这个域名了，想换一个<code>test.cn</code>；可用户已经有那么多，大家都只记得你的<code>test.com</code>，如果直接更换域名，就会导致用户无法访问<code>test.com</code>，以为你跑路了，就放弃使用你的网页。</p><p>这样的结果显而易见：严重的客户流失！</p><p>所以，为了避免这个问题，我可以先将服务迁移到<code>test.cn</code>新域名，在旧域名<code>test.com</code>中设置一个301重定向到<code>test.cn</code>，告诉用户我换新域名了。这样持续一段时间后，等到<code>test.com</code>的使用者不多了，就可以考虑彻底取消<code>test.com</code>的解析，关停此域名了。</p><p>在上面的场景中，我是需要更换域名，是永久更换。我们就应该把状态码设置为301，告诉客户端这个域名将被永久重定向到另外一个域名上</p><hr><p>另外的情况是，我有一个<code>example.com</code>域名，我的服务需要进行维护；此时就将<code>example.com</code>重定向到另外一个域名<code>example.cn</code>，指向另外一个服务器，让这个服务器临时提供服务。</p><p>服务维护完毕后，就将重定向取消，继续使用当前的服务器。</p><p>这个场景中，重定向只是维护期间的一个临时策略，所以状态码设置成302，告诉客户端我只是临时进行重定向，我还会回来的。</p><h1 id="6-cookie-x2F-session"><a href="#6-cookie-x2F-session" class="headerlink" title="6.cookie&#x2F;session"></a>6.cookie&#x2F;session</h1><p>日常生活中，当我们在一个web页面中登录了（如github&#x2F;gitee&#x2F;csdn）这个网页在很长一段时间内都会保持登录，直到超时亦或者是出现了异地访问。</p><p>假如你现在有个网页，但是每次用户访问的时候，都需要重新输入用户名和密码，刚刚输入过了，换一个页面又不行了。这样一来，用户还会想用你这个服务吗？</p><p>为了避免此类问题，http协议就需要引入其他的参数，来维持用户的登录会话。cookie&#x2F;session便是因此而来的。</p><h2 id="6-1-set-cookie"><a href="#6-1-set-cookie" class="headerlink" title="6.1 set cookie"></a>6.1 set cookie</h2><p>服务端可以在响应头中带上<code>Set-Cookie</code>字段，给客户端设置上cookie</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response += <span class="string">&quot;Set-Cookie: This is my cookie test\r\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>打开f12开发者界面，能在其中看到我们设置的cookie</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63eca303c2533.png" alt="image-20230215171652910"></p><p>再次刷新网页，可以看到在之后的请求中，浏览器都会发送一次服务器设置的cookie。这样服务端在收到cookie后，就能解析到自己设置的cookie，确定了指定的用户</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63eca34befdf0.png" alt="image-20230215171805924"></p><p>在服务器端也能看到这个字段</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63eca54f23dfe.png" alt="image-20230215172640992"></p><h2 id="6-2-什么是cookie"><a href="#6-2-什么是cookie" class="headerlink" title="6.2 什么是cookie"></a>6.2 什么是cookie</h2><p>所谓cookie，其实就是浏览器帮我们存取了一定的身份信息在本地（内存or磁盘）</p><p>下一次打开特定的网页的时候，就能显示对应的身份信息（不一定是你的账户密码），并告诉服务器，服务器就识别到了你当前的用户，并为你保持登陆状态。</p><p>既然是保存在用户本地的，那就有可能被窃取。一些恶意软件就会去扫描你浏览器本地缓存中的cookie信息，对于一些安全性不高的网站而言，有了这个cookie，就相当于他有了你的账户，可以直接登录你的账户进行操作。</p><p>因此，引入了另外一种身份认证的方式 <code>cookie+session</code></p><h2 id="6-3-cookie-session"><a href="#6-3-cookie-session" class="headerlink" title="6.3 cookie+session"></a>6.3 cookie+session</h2><p>比起将身份信息存到客户端，存至服务端更为安全（攻击企业服务器的成本，比在用户端植入木马程序的成本更高）</p><ul><li>用户使用账户密码请求登录，服务器收到登录请求，验证成功后，给客户端返回一个<code>唯一字符串session_id</code>来标识用户</li><li>客户端下一次请求的时候，带上了这个唯一字符串</li><li>服务器收到请求，在本地的<code>session_id</code>库中查找这个id，找到后，就将用户信息匹配给客户端，相当于客户端登录成功了</li></ul><p>这样，就将原本存在用户本地的身份认证信息，<strong>存到了服务端中</strong>。客户端就只剩下一个孤零零的字符串id，不会有用户的私密信息。即便丢失，也不会影响用户的隐私。</p><ul><li>你可能会说，那我偷走这个id不也是一样的效果？</li></ul><p>其实没有那么简单，服务端可以将<code>session_id</code>和用户的ip或者终端User-Agent绑定，这样只要用户<strong>切换设备</strong>或者<strong>换了登录的地点</strong>（比如从三亚跑到了哈尔滨）就直接让<code>session_id</code>失效，要求用户重新登录。</p><h1 id="7-长短链接"><a href="#7-长短链接" class="headerlink" title="7.长短链接"></a>7.长短链接</h1><p>在早期的http协议中，采用的都是短链接，一次连接只能处理1次http请求。当时的网页大多以文字为主，数据量很小，一起请求也能够满足需求。</p><p>但现在时代已经变了，一个网页里面有图片，文字，音频，视频。这些文件的体积打起来之后，短链接的方式就不适用了。此时就出现了长链接，一次tcp链接，可以持续传输数据。</p><p>相比短链接，长链接连上之后，能持续传输数据，<strong>避免了tcp3次握手的消耗</strong>，提高了数据传输的效率！</p><h2 id="7-1-Connetion"><a href="#7-1-Connetion" class="headerlink" title="7.1 Connetion"></a>7.1 Connetion</h2><p>在本文的<code>3.4</code>中，便出现了这个参数，一般情况下，会有下面两种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connetion: keep-alive</span><br><span class="line">Connetion: closed</span><br></pre></td></tr></table></figure><p>其中<code>keep-alive</code>就是长链接，<code>closed</code>代表当前端口只支持短链接。</p><p>当客户端发送的请求头中包含<code>Connetion: keep-alive</code>字段，如果服务器支持长链接，就需要在响应头中也带上<code>Connetion: keep-alive</code>，这样双方协商成功，大家都可以使用长链接。</p><p>如果服务器的响应头中没有带<code>Connetion: keep-alive</code>，那么客户端就会认为服务器不支持长链接，下次请求的时候，会重新向服务器链接，再获取资源。</p><p>如果客户端和服务端任意一方的响应头中包含<code>Connetion: closed</code>，那么就会认为当前的会话只支持短链接，下次请求会重新建立链接。</p><h2 id="7-2-http和tcp的关系"><a href="#7-2-http和tcp的关系" class="headerlink" title="7.2 http和tcp的关系"></a>7.2 http和tcp的关系</h2><p>http虽然是基于tcp的，但http本身是无链接的。</p><blockquote><p>举个最明显的栗子，在你打开一个网页之后，你关闭掉自己的wifi，你的网页并不会因此消失。只是无法进行后续操作而已。</p></blockquote><p>http是一个无链接的应用层协议，其借助tcp进行数据的流式传输，但不一定需要客户端和服务端保持连接。</p><p>所以，http就可以借助单个tcp套接字<strong>持续的传输数据</strong>，也就天然地支持了长链接通信。</p><p>总结一下，http只是借用了tcp的能力，其无连接的特性和tcp没有关系！</p><h2 id="7-3-pipeline"><a href="#7-3-pipeline" class="headerlink" title="7.3 pipeline"></a>7.3 pipeline</h2><p>这其中会牵扯到一个<code>pipeline</code>，其维护了http长链接请求时的<strong>响应顺序</strong>。</p><p>比如人家需要加载一个网页，服务端应该先把网页的整体框架给用户加载出来，再给用户加载图片、视频、音频等资源。下图B站的加载就是一个很好的栗子。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ee31578364a.png" alt="image-20230216213625496"></p><p>否则乱序了，比如只出现了一个孤零零的图片，就会让人感觉非常奇怪。</p><h1 id="8-https"><a href="#8-https" class="headerlink" title="8.https"></a>8.https</h1><p>因为http的数据是无加密明文发送的，相对来说并不是非常的安全；为了实现数据加密，https在http的下层添加了一个<code>SSL/TLS</code>软件层，来进行数据加解密工作</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ecc49657516.png" alt="image-20230215193931213"></p><h2 id="8-1-为啥要加密？"><a href="#8-1-为啥要加密？" class="headerlink" title="8.1 为啥要加密？"></a>8.1 为啥要加密？</h2><p>要知道，所有的加密工作，都是为了防止数据在中间传输的过程，被窃取或修改。如果我们请求一个网站登录的时候，数据包中就会包含我们的账户密码。如果被窃取，我们的隐私就泄露了。这是很难受的一件事！</p><blockquote><p>这也是为什么，我们经常能听到<code>免费公共wifi不安全</code>这一说法，因为我们在这个wifi上进行的所有数据交换，都会走这个wifi的路由器，很容易被<code>中间人</code>窃取并获取到我们的数据包。</p><p>这种情况下，https的加密就更有必要了！</p></blockquote><p>但是，加密解密是需要时间的，所以https响应的速度会稍慢于http。不过当下cpu的执行速度已经非常快，这点时间差距很小，不会特别影响我们的日常使用！</p><p>不过，加密并不是一个万金油，并不是说加密了之后的数据就一定能避免被窃取。但加密可以大大提高窃取破解的成本，无形中降低了数据被窃取的概率，保证了一定的数据安全。</p><h2 id="8-2-常见加密方式"><a href="#8-2-常见加密方式" class="headerlink" title="8.2 常见加密方式"></a>8.2 常见加密方式</h2><h3 id="8-2-1-对称加密"><a href="#8-2-1-对称加密" class="headerlink" title="8.2.1 对称加密"></a>8.2.1 对称加密</h3><p>所谓对称加密，好比有一个带锁的盒子，客户端和服务器都有一把钥匙。客户端先把信息丢进盒子里，再用🔑锁上盒子，发送给服务端。服务端用🔑打开盒子，取出数据。</p><p>因为客户端和服务器持有的钥匙是完全一致的，所以被称为对称加密。在加密的场景下，钥匙一般被称为<code>密钥</code></p><p>在网络场景里，<strong>对称加密是不可取的</strong>。只要客户端和服务端传输密钥的时候被窃取，那么双方的加密就失效了。因为是用同一个密钥来加密解密，我拿走了你的钥匙，自然就能打开你这把锁。</p><p>也就是说，<font color="orange">密钥的传输也需要加密</font>。但是这又引出一个问题，我都没有你的密钥，我怎么解密你发过来的密钥信息？这是一个<code>先有蛋还是先有鸡</code>的死循环！</p><h3 id="8-2-2-非对称加密"><a href="#8-2-2-非对称加密" class="headerlink" title="8.2.2 非对称加密"></a>8.2.2 非对称加密</h3><p>非对称加密场景下，会有一个公钥和私钥</p><ul><li>私钥对数据加密，变成密文</li><li>公钥对数据解密，变成明文</li></ul><p>二者也可以反过来</p><ul><li>私钥对数据解密</li><li>公钥对数据加密</li></ul><p>其中最常用的非对称加密，也就是我们在<a href="https://blog.musnow.top/2022/05/09/note_linux/1%E4%BD%BF%E7%94%A8ssh%E8%BF%9E%E6%8E%A5git/">git的ssh操作</a>中使用过的<code>rsa</code>密钥，其中就有一个<code>.pem</code>公钥和一个私钥。我们将公钥提供给github，私钥保存到本地，就能实现无密码上传数据到git仓库。</p><hr><p>但是非对称加密还是会存在中间人攻击的问题。先看如下图，你应该能发现，其中有一个重要的环节，<strong>就是服务端要把公钥发送给客户端</strong></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ee25050db71.png" alt="image-20230216204344555"></p><p>在这个场景中，公钥是公开传输给客户端的，也就是后续服务器发送给客户端的所有信息，都可以被其他人用这个公钥解析出来；</p><p>整个环节中，只做到了客户端发送给服务器的信息安全，因为只有服务器拥有私钥，能解密出数据。</p><h3 id="8-2-3-双非对称"><a href="#8-2-3-双非对称" class="headerlink" title="8.2.3 双非对称"></a>8.2.3 双非对称</h3><p>这时候，我们可以采用双非对称密钥加密的方式！既然非对称只能保证单方的数据安全，那使用两个非对称，不就能保证双方数据安全了嘛！</p><ul><li>客户端和服务端交换公钥<code>a&#39; 和 b&#39;</code></li><li>客户端给服务端发信息：先用<code>a&#39;</code>对数据加密，再发送；只能由服务器解密，因为只有服务器有私钥a</li><li>服务端给客户端发信息：先用<code>b&#39;</code>对数据加密，再发送；只能由客户端解密，因为只有客户端有私钥b</li></ul><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ee2acb5bf6c.png" alt="image-20230216210830169"></p><p>因为两份私钥都只有客户端和服务器自己拥有，所以黑客没有办法进行数据的窃取，也就保证了数据的安全。</p><p>即便中间人<strong>替换了交换的公钥</strong>，也会因为后续的通信，客户端or服务端<strong>本地的私钥</strong>无法正常解密，而发现数据被窃取！</p><p>但是但是，这样左还算有很大的<strong>缺点</strong></p><ul><li>效率太低（非对称加密解密负载太高，效率低下，特定场景下无法满足要求）</li><li>依旧可能存在安全问题</li></ul><h3 id="8-2-4-非对称-对称"><a href="#8-2-4-非对称-对称" class="headerlink" title="8.2.4 非对称+对称"></a>8.2.4 非对称+对称</h3><ul><li>服务端具有非对称公钥S和私钥S’</li><li>客⼾端发起请求，获取服务端公钥S</li><li>客⼾端在本地生成对称密钥C, 通过公钥S加密, 发送给服务器.</li><li>由于中间人没有私钥，即使截获了数据，也无法还原出内部的原文，也就无法获取到对称密钥</li><li>服务器通过私钥<code>S&#39;</code>解密，还原出客户端发送的对称密钥C，并且使用这个对称密钥加密给客户端发送的响应数据</li><li>后续客户端和服务端都采用密钥C来进行对称加密通信</li></ul><p>因为对称<strong>密钥C在传输过程中是加密</strong>的，只有客户端和服务端知道密钥是什么，也就实现了数据的安全通信！</p><h2 id="8-3-数据摘要（指纹）"><a href="#8-3-数据摘要（指纹）" class="headerlink" title="8.3 数据摘要（指纹）"></a>8.3 数据摘要（指纹）</h2><p>数字指纹(数据摘要)， 其基本原理是利⽤单向散列函数(<code>Hash函数</code>)对信息进行运算，生成⼀串<strong>固定长度</strong>的数字摘要。</p><p>常见的摘要算法有<code>MD5/SHA1/SHA256/SHA512</code>等；</p><p>数字指纹并不是⼀种加密机制，但可以用来判断<strong>数据有没有被窜改</strong>，亦或者是下载的数据包有没有出现损坏。</p><ul><li>同一个数据文件，用同一个方法生成的数据摘要是一致的</li><li>不同文件生成的数据摘要可能会撞车，但几率极低，可以认为具有唯一性！</li><li>我们无法用数据摘要反推出数据内容（怎么可能用一个字符串推测出原本的内容呢？那样还存放源文件干哈？😂）</li></ul><p>数据摘要在网盘产品中也有使用，当我们使用<strong>百度云盘、阿里云盘</strong>的时候，会遇到一个大的资源文件只用了<strong>短短几秒</strong>就成功上传到服务器的情况。此时，我们并不是真的用几秒就把数据传输上去了，而是经历了以下阶段</p><ul><li>网盘客户端对本地文件生成数据摘要</li><li>生成后，判断服务器端<strong>已有文件</strong>中，是否有同该数据摘要相同的文件</li><li>如果有，代表该文件已经存在了云盘中</li><li>服务器将该文件给你的账户建立一个软链接&#x2F;硬链接，就实现了<code>&quot;妙传&quot;</code></li><li>如果没有，则老老实实的从本地上传文件到云盘</li></ul><p>云盘厂家这么做的原因很简单：避免同一份文件被多次存储。当下网盘给用户的免费空间动则上T，如果所有文件都重复保存，那对于云服务器厂家来说，资源消耗太大了。</p><p>这个做法并不会产生数据隐私问题，一般只有电影等资源文件才有可能妙传成功。你可以使用一些“其他手段”，比如把资源打个压缩包，并在压缩包中随便丢另外一个文件，让文件的数据指纹和已有资源不相同，就不会进行<code>妙传</code>了。</p><h2 id="8-4-数字签名"><a href="#8-4-数字签名" class="headerlink" title="8.4 数字签名"></a>8.4 数字签名</h2><p>对数据摘要进行加密，生成的内容被称为<strong>数字签名</strong></p><h2 id="8-5-中间人攻击"><a href="#8-5-中间人攻击" class="headerlink" title="8.5 中间人攻击"></a>8.5 中间人攻击</h2><p>中间人攻击（Man-in-the-MiddleAttack），简称“<code>MITM攻击</code>”；</p><p>以<code>8.2.2</code>的单非对称加密为例，中间人可以在整个过程中进行<strong>偷梁换柱</strong>，窃取双方的信息</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ee26a502a69.png" alt="image-20230216205047679"></p><p>透过这个栗子🌰，实际上，如果中间人在客户端和服务端<strong>开始通信之前</strong>就来窃听并<strong>准备换柱</strong>了，他就有可能替换双方密钥，从而解密双方发送的信息！</p><p>最重要的一点，是客户端or服务端<strong>都没有办法证明</strong>，当前的公钥是直接从服务端or客户端发来的，它们没有办法检验公钥的权威性，只能被动接受。由此给中间人<code>偷梁换柱</code>提供了可能。</p><h2 id="8-6-CA证书"><a href="#8-6-CA证书" class="headerlink" title="8.6 CA证书"></a>8.6 CA证书</h2><p>所谓CA证书，是由<strong>CA机构</strong>颁发的权威证书。CA机构在颁发证书时，会在证书中附带上该站点的域名，以及申请人（企业）的相关信息</p><ul><li>CA机构会有一个自己的私钥和公钥，其公钥向<strong>所有人</strong>公开</li><li>CA机构的私钥由其自己保存（私钥一定不能泄露）</li><li>当下的浏览器、操作系统都会内置认可的CA；只有被认可的CA，才能为站点提供ssl证书服务</li></ul><p>在我们windows本地就能看到当前操作系统认可的CA机构其公钥；在edge浏览器中，点击右上角选择，进入设置，在选择隐私页面，找到<code>管理证书</code></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ee3dd712d42.png" alt="image-20230216222946008"></p><p>点击它，就能看到当前本地认可的CA</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ee3e40b1733.png" alt="image-20230216223131725"></p><h3 id="8-6-1-ssl证书加密原理"><a href="#8-6-1-ssl证书加密原理" class="headerlink" title="8.6.1 ssl证书加密原理"></a>8.6.1 ssl证书加密原理</h3><p>当一个站点获取了ssl证书后，在向用户发送ssl证书中包含的公钥的同时，还会发送一个<strong>由CA机构</strong>对ssl证书公钥做的<strong>数字签名</strong></p><ul><li>ssl证书公钥的数字签名A，通过CA机构的<strong>私钥</strong>进行加密</li><li>ssl证书的公钥B</li></ul><p>当客户端收到这份信息之后，会采用hash函数对收到的ssl证书公钥进行数字签名，得到一个<strong>本地生成的数字签名C</strong></p><p>再用CA机构的公钥对传输过来的数字签名A进行解密，得到数字签名A的明文；判断由CA机构生成的ssl公钥数字签名A是否和本地生成的数字签名C相同；</p><ul><li>如果相同，则代表证书正确！</li><li>不相同，代表证书出现错误！</li></ul><p>画个图，大概就是下面这样</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/23/02/63ee3aa8d2aa1.png" alt="image-20230216221611664"></p><p>由于当下发送的数据包中，同时存在ssl公钥的明文+由CA机构加密后的数字签名，中间人无法进行任何攻击修改！</p><ul><li>若修改ssl公钥，由于中间人没有CA机构的私钥，无法对修改后的ssl公钥生成对应的加密后数字签名</li><li>若使用CA公钥解密数字签名后修改……依旧会因为没有CA机构私钥，无法把修改后的签名加密回去</li><li>如果中间人用自己的私钥生成一个数字签名，但我不认识你这个CA，也不知道你的公钥是什么，怎么解密你的信息呢？</li></ul><p>综上，中间人要想偷梁换柱，只有一个办法了，那就是拿一个<strong>真的证书</strong>整体替换掉这个数据包。</p><p>可ssl证书中还包含了域名、站点主体等各类信息，我当下访问的是<code>baidu.com</code>，结果收到的证书是<code>qq.com</code>的，那肯定有问题啊！浏览器会直接拒绝访问！😂</p><p>当我们访问一些网站，<strong>浏览器报ssl证书过期</strong>，也是会出现一定的安全问题的！</p><h3 id="8-6-2-ssl证书-非对称-对称"><a href="#8-6-2-ssl证书-非对称-对称" class="headerlink" title="8.6.2 ssl证书+非对称+对称"></a>8.6.2 ssl证书+非对称+对称</h3><p>有了上面这个不能被篡改的ssl证书公钥，下面我们就可以利用<code>非对称+对称加密</code>的方式进行通信了</p><ul><li>客户端收到ssl证书，向服务器发送一个本地生成的密钥D（使用ssl证书公钥进行加密）</li><li>服务端收到密钥D的加密信息，使用ssl证书的私钥进行解密，获取到密钥D</li><li>客户端和服务端使用密钥D进行对称加密通信</li></ul><p>这样即解决了安全问题，又规避了非对称加密的效率问题，一举多得！</p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【网络】http(s)协议 | 介绍</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2023-02-15 11:30:55</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2023/02/15/note_Linux/34http协议/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E7%BD%91%E7%BB%9C/">#网络</a>&nbsp;</li><li class="tag-item"><a href="/tags/http/">#http</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2023/02/15/note_Linux/35http%E4%B8%ADcontent-length/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【网络】http(s)协议 | content-length详解</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2023/02/12/note_Linux/33jsoncpp%E5%BA%8F%E5%88%97%E5%8C%96/"><span class="title flex-center"><span class="post-nav-title-item">【网络】自定义协议 | 序列化和反序列化 | Jsoncpp</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true'
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-url"><span class="nav-text">1.1 url</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E6%A0%97%E5%AD%90-%E2%91%A0"><span class="nav-text">1.1.1 栗子 ①</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E6%A0%97%E5%AD%90-%E2%91%A1"><span class="nav-text">1.1.2 栗子 ②</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%9F%9F%E5%90%8D%E5%92%8C%E7%AB%AF%E5%8F%A3%E9%9A%90%E8%97%8F"><span class="nav-text">1.2 域名和端口隐藏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-ip-%E7%AB%AF%E5%8F%A3"><span class="nav-text">1.3 ip:端口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%8D%8F%E8%AE%AE%E4%BD%9C%E7%94%A8"><span class="nav-text">1.4 协议作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="nav-text">1.5 编码解码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-http%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F"><span class="nav-text">2.http协议请求格式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E8%AF%BB%E5%8F%96%E5%A4%9A%E9%95%BF%EF%BC%9F"><span class="nav-text">2.1 读取多长？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%93%8D%E5%BA%94%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-text">2.2 响应的状态码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%AE%9E%E4%BE%8B"><span class="nav-text">3.实例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="nav-text">3.1 前端页面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="nav-text">3.2 服务端代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%B5%8B%E8%AF%95"><span class="nav-text">3.3 测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%90%8E%E7%AB%AF%E6%89%93%E5%8D%B0%E7%9A%84%E6%8A%A5%E6%96%87"><span class="nav-text">3.4 后端打印的报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%A1%A8"><span class="nav-text">3.5 常见参数表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="nav-text">4.请求方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-GET"><span class="nav-text">4.1 GET</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-POST"><span class="nav-text">4.2 POST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-GET-x2F-POST%E5%8C%BA%E5%88%AB"><span class="nav-text">4.3 GET&#x2F;POST区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E6%9B%B4%E5%A4%9A%E6%96%B9%E6%B3%95"><span class="nav-text">4.4 更多方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-text">5.状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E7%8A%B6%E6%80%81%E7%A0%81%E8%A1%A8"><span class="nav-text">5.1 状态码表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-404-x2F-403%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-text">5.2 404&#x2F;403状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-5xx%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-text">5.3 5xx状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-301-x2F-302%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">5.4 301&#x2F;302重定向</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-cookie-x2F-session"><span class="nav-text">6.cookie&#x2F;session</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-set-cookie"><span class="nav-text">6.1 set cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E4%BB%80%E4%B9%88%E6%98%AFcookie"><span class="nav-text">6.2 什么是cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-cookie-session"><span class="nav-text">6.3 cookie+session</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E9%95%BF%E7%9F%AD%E9%93%BE%E6%8E%A5"><span class="nav-text">7.长短链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-Connetion"><span class="nav-text">7.1 Connetion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-http%E5%92%8Ctcp%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">7.2 http和tcp的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-pipeline"><span class="nav-text">7.3 pipeline</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-https"><span class="nav-text">8.https</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E4%B8%BA%E5%95%A5%E8%A6%81%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="nav-text">8.1 为啥要加密？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F"><span class="nav-text">8.2 常见加密方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-text">8.2.1 对称加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-text">8.2.2 非对称加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-%E5%8F%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0"><span class="nav-text">8.2.3 双非对称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-4-%E9%9D%9E%E5%AF%B9%E7%A7%B0-%E5%AF%B9%E7%A7%B0"><span class="nav-text">8.2.4 非对称+对称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E6%95%B0%E6%8D%AE%E6%91%98%E8%A6%81%EF%BC%88%E6%8C%87%E7%BA%B9%EF%BC%89"><span class="nav-text">8.3 数据摘要（指纹）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="nav-text">8.4 数字签名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-text">8.5 中间人攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-CA%E8%AF%81%E4%B9%A6"><span class="nav-text">8.6 CA证书</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-1-ssl%E8%AF%81%E4%B9%A6%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86"><span class="nav-text">8.6.1 ssl证书加密原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-2-ssl%E8%AF%81%E4%B9%A6-%E9%9D%9E%E5%AF%B9%E7%A7%B0-%E5%AF%B9%E7%A7%B0"><span class="nav-text">8.6.2 ssl证书+非对称+对称</span></a></li></ol></li></ol></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep%20v3.6.1-blue" height="20px"> </a><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://musnow.top" target="_blank"><img src="https://img.shields.io/badge/%E4%B8%BB%E7%AB%99-%E7%82%B9%E6%88%91-blueviolet" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>