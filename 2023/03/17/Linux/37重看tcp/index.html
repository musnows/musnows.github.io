<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><title>【Linux】tcp协议 | 详解 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【Linux】tcp协议 | 详解</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2023-03-17 15:30:55</span> <span class="mobile">2023-03-17 15:30</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-03-18 18:41:21</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E7%8E%A9%E4%B8%8ALinux/">玩上Linux</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/tcp/">tcp</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>6.5k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>本文带你详细了解tcp协议的相关知识</p><span id="more"></span><blockquote><p>本文中部分截图为手写，字丑见谅</p></blockquote><h1 id="1-linux下常用网络命令"><a href="#1-linux下常用网络命令" class="headerlink" title="1.linux下常用网络命令"></a>1.linux下常用网络命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/servcies <span class="comment"># 系统常用服务和端口</span></span><br></pre></td></tr></table></figure><p>我们自己写网络服务器进程时，绑定的端口不能和系统端口冲突。尽量绑定1024以上的端口，推荐绑定不常用的5位数端口</p><h2 id="1-1-netstat命令"><a href="#1-1-netstat命令" class="headerlink" title="1.1 netstat命令"></a>1.1 netstat命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br><span class="line">netstat -l <span class="comment"># 只列出listen状态服务</span></span><br><span class="line">netstat -n <span class="comment"># 将显示的信息用数字（id）代替</span></span><br><span class="line">netstat -p <span class="comment"># 显示端口和进程pid的关联</span></span><br><span class="line">netstat -t <span class="comment"># tcp</span></span><br><span class="line">netstat -u <span class="comment"># udp</span></span><br><span class="line">netstat -a <span class="comment"># 显示所有服务</span></span><br></pre></td></tr></table></figure><h2 id="1-2-pidof"><a href="#1-2-pidof" class="headerlink" title="1.2 pidof"></a>1.2 pidof</h2><p>获取某个进程名的进程pid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof 进程名</span><br></pre></td></tr></table></figure><p>比如我想查看<code>sshd</code>的进程id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pidof sshd</span><br><span class="line">20706 20703 10775 6067 6009 3339 3338 3272 3269 1340</span><br></pre></td></tr></table></figure><h1 id="2-udp协议"><a href="#2-udp协议" class="headerlink" title="2.udp协议"></a>2.udp协议</h1><p>一下为udp报文格式的结构图</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/6414432a16b9f.png" alt="image-20230317183835725"></p><p>udp采用了定长报文，这也是udp <code>面向数据报</code> 的</p><ul><li>udp采用16位作为ip+端口的存放，源端口和目的端口用于数据的<strong>解包分用</strong>（系统需要知道当前的数据包应该丢给上层的哪一个端口）</li><li>16位udp长度，表示整个数据报 <code>udp首部+udp数据</code> 的最大长度</li><li>16位校验和用于校验报文是否出现错误。如果校验和出错，就会直接丢弃报文</li></ul><p>由于udp的长度标志位只有16位，所以一个udp报文能传输的最大数据是<code>64kb</code> ( 2<sup>2 </sup>)</p><p>如果需要用udp传输大于<code>64kb</code>的数据，则需要在<strong>应用层</strong>进行拆分，在接收方的<strong>应用层</strong>进行合并。</p><h2 id="2-1-理解报头"><a href="#2-1-理解报头" class="headerlink" title="2.1 理解报头"></a>2.1 理解报头</h2><p>所谓报头，其实就是操作系统内核中的一个C语言的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例，不代表真实情况</span></span><br><span class="line"><span class="comment">//udp报头采用了位段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udp_hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> src_port:<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dst_port:<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> udp_len:<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> udp_check:<span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加报头的本质，其实就是给数据的头部添加上一个<code>struct udp_hdr</code>结构体；</p><p>而解包的时候，也是将指针移动固定长度（8个字节）的空间，将指针强转为<code>struct udp_hdr</code>，即获取到了当前报文的udp报头</p><h2 id="2-2-udp的特点"><a href="#2-2-udp的特点" class="headerlink" title="2.2 udp的特点"></a>2.2 udp的特点</h2><p>udp传输的过程类似于<code>飞鸽传书</code></p><ul><li>无连接：知道对方的<code>ip:端口</code>就能直接传输数据，不需要建立连接</li><li>面向数据报：定长报文，不能灵活控制报文的读取次数和数量<ul><li>一次必须要读取完毕一个完整的udp报文</li><li>假设报文100字节，不能通过10次每次读10字节来获取报文。必须一次读完100字节</li></ul></li><li>不可靠：没有确认机制和重传机制，如果因为各种原因，鸽子在路上出事了，那传输的信息也直接丢失了。udp也不会给应用层返回错误信息。</li></ul><h2 id="2-3-udp缓冲区"><a href="#2-3-udp缓冲区" class="headerlink" title="2.3 udp缓冲区"></a>2.3 udp缓冲区</h2><p>udp支持<code>全双工</code>，udp的socket即可写也可读</p><p>udp没有发送缓冲区，应用层调用<code>sendto</code>会直接将数据交给OS内核（其实就是拷贝），内核再交由网络模组进行后续传输。</p><blockquote><p>由于udp采用了定长报头，其报头较为简单，OS只需要添加上报头即可发送。这个过程很快，所以缓冲区的作用不大。</p></blockquote><p>udp有接收缓冲区，这个接收缓冲区只是一味地接收，并不能保证报文的顺序</p><blockquote><p>因为不保证顺序，所以有可能<strong>乱序</strong>，也是<strong>udp不可靠</strong>的体现</p></blockquote><p>若缓冲区满，新到达的udp数据就会被丢弃。</p><h2 id="2-4-丢包"><a href="#2-4-丢包" class="headerlink" title="2.4 丢包"></a>2.4 丢包</h2><p>一个数据包丢包可能有多种情况</p><ul><li>数据包内容出错（比特位翻转等）</li><li>数据包延迟到达（延迟过久视为丢包）</li><li>数据包在路上被阻塞（到不了）</li><li>数据包在路上由于网络波动而丢失（网络突然抽风了，报文直接不见了）</li></ul><p>udp的报文也是如此，但udp<strong>不可靠</strong>并不是一个贬义词，应该是一个中性词。</p><ul><li>udp不可靠是他的特点，由于udp简单，其不需要进行连接，报头添加的效率快，由此性能消耗小于tcp。</li><li>带来的缺点就是udp不可靠</li></ul><p>在直播场景中，udp的使用很多。同一场直播观看的人数会很多，如果每一个用户都维持一个tcp连接，服务器的负载就太大了。用udp就能直接向该用户广播数据，负载小。</p><h2 id="2-5-基于udp的应用层协议"><a href="#2-5-基于udp的应用层协议" class="headerlink" title="2.5 基于udp的应用层协议"></a>2.5 基于udp的应用层协议</h2><ul><li>NFS: 网络文件系统</li><li>TFTP: 简单文件传输协议</li><li>DHCP: 动态主机配置协议</li><li>BOOTP: 启动协议（用于无盘设备启动）</li><li>DNS: 域名解析协议</li></ul><h1 id="3-tcp协议"><a href="#3-tcp协议" class="headerlink" title="3.tcp协议"></a>3.tcp协议</h1><p>下图为tcp协议报头的一个基本结构图，我们需要了解整个结构，以及每一个部分的作用</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/6414766c49315.png" alt="image-20230317221627931"></p><h2 id="3-1-源和目的端口号"><a href="#3-1-源和目的端口号" class="headerlink" title="3.1 源和目的端口号"></a>3.1 源和目的端口号</h2><p>这部分和udp相同，tcp也需要源端口和目的端口号，以用于找到报文要去的目的地。</p><h2 id="3-2-4位首部长度"><a href="#3-2-4位首部长度" class="headerlink" title="3.2 4位首部长度"></a>3.2 4位首部长度</h2><p>相比于udp的定长报头，tcp采用了不定长的方式。但tcp的报头有<strong>标准的20字节</strong>，所有报头都至少有20字节。</p><p>在这20字节中，有一个<code>4位首部长度</code>，用于标识tcp报文的<strong>真实长度</strong>。</p><p>我们知道，4位二进制可以表示<code>0~15</code>，这不比固定的20字节还少吗？难道说，这4位首部长度标识的是比20字节多余的内容？</p><p>并不是！这4位首部长度的标识是有单位的，每一位实际上代表的是4字节，即tcp报头的最大长度为<code>15*4=60</code>字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于标准长度也记入4位首部长度，所以4位首部长度的最小值为 0101</span><br></pre></td></tr></table></figure><p>读取tcp报文的时候，只需要先读取20字节，再从这20字节中<strong>取出</strong>4位首部长度，获得报头的实际长度；再重新读取，即获得了<strong>完整</strong>的tcp报头。剩下的部分就是报文携带的数据了（有效载荷）</p><h2 id="3-3-32位序号-x2F-确认序号"><a href="#3-3-32位序号-x2F-确认序号" class="headerlink" title="3.3 32位序号&#x2F;确认序号"></a>3.3 32位序号&#x2F;确认序号</h2><h3 id="3-3-1-如何确认信息被对方收到？"><a href="#3-3-1-如何确认信息被对方收到？" class="headerlink" title="3.3.1 如何确认信息被对方收到？"></a>3.3.1 如何确认信息被对方收到？</h3><blockquote><p>tcp具有确认应答的机制</p></blockquote><p>当我们和对方<strong>微信交流</strong>的时候，怎么样才能确认自己的信息被对方看到了？</p><ul><li>A发 吃饭了吗？</li><li>B回应 吃了</li></ul><p>在这个场景中，只有B给A发出回应，A才能确认自己的消息被B看到了。</p><p>tcp通信也是如此，只有给对方发送的报文收到了对方的应答，发送方才能确认自己的报文被对方收到了。</p><p>为此，tcp引入了<code>32位序号/确认序号</code></p><hr><h3 id="3-3-2-确认应答"><a href="#3-3-2-确认应答" class="headerlink" title="3.3.2 确认应答"></a>3.3.2 确认应答</h3><p>用于确认自己和对方的通信，究竟收到了哪一个报文（序号）以及确认信息发出的顺序。</p><p>比如客户端会向服务器发 <code>吃了吗？吃的什么？好吃吗？晚上想去干什么？</code>，如果没有对报头带上序号，服务器接收到的可能就会是下面这样 <code>好吃吗？晚上想去干什么？吃的什么？吃了吗？</code>，看起来是不是十分怪异？</p><p>所以，为了保证tcp报文的顺序性，以及保证报文被送达到对方。tcp引入了以序号为基础的<code>确认应答</code>机制</p><ul><li>客户端向服务器发送一个报头，并将<strong>序号</strong>设置为1</li><li>服务端收到信息后，回复客户端一个报头，将<strong>确认序号</strong>设置为1</li><li>此时客户端就能确认服务器收到了自己刚刚发出的序号为1的消息</li></ul><p>以上是一次通信的过程，如果是多次通信呢？</p><ul><li>客户端连续向服务器发送了n个消息，服务器应答：1、2、3、4……</li><li>服务器的每次应答，除了代表报文n已经被收到了，还必须代表n之前的报文被全部收到</li><li>比如假设客户端发送了1-10的报文，而第6个报文出现了丢失，那么服务端就应该设置<code>确认序号</code>为5，代表<strong>5和5之前</strong>的报文都被正常收到。</li><li>此时客户端发现，明明自己已经都发到10了，服务端还在回应5。这就代表发送过程中，<strong>6号报文丢失了</strong>！于是客户端从6号报文开始，<strong>重发报文</strong>：6、7、8……</li></ul><p>不管是服务端给客户端发信息，还是客户端给服务器发信息，收方都需要对信息进行回应。tcp通信中，<strong>通信双方地位是对等</strong>的！</p><h3 id="3-3-3-为什么有两组确认序号？"><a href="#3-3-3-为什么有两组确认序号？" class="headerlink" title="3.3.3 为什么有两组确认序号？"></a>3.3.3 为什么有两组确认序号？</h3><p>tcp是<strong>全双工</strong>的，通信一方在发送响应信息的同时，可能也会携带新的报文给对方。</p><ul><li>客户端给服务器发了一条消息 <code>吃了吗？</code></li><li>服务器在回复的同时，也带上了新的请求 <code>吃了，你呢？</code></li><li>服务器的这种策略叫做：<strong>捎带应答</strong></li></ul><p>此时服务端就需要在填充<em>客户端</em>消息的<strong>确认序号</strong>的同时，填充<em>自己</em>所发消息的<strong>序号</strong>。这样才能保证tcp在双向交流中的可靠性！</p><p>所以在tcp报头中，<strong>序号和确认序号</strong>缺一不可！</p><h3 id="3-3-4-没有完美的协议！"><a href="#3-3-4-没有完美的协议！" class="headerlink" title="3.3.4 没有完美的协议！"></a>3.3.4 没有完美的协议！</h3><p>经过上面的过程，我们会发现，总有一条报文，<strong>在收到对方回应之前</strong>，是无法得知对方是否收到信息的。</p><p>这也说明：没有一定可靠的协议！</p><h3 id="3-3-5-按序到达"><a href="#3-3-5-按序到达" class="headerlink" title="3.3.5 按序到达"></a>3.3.5 按序到达</h3><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/641543370a163.png" alt="image-20230318125057097"></p><p>序号除了用于确认应答，还有多个功能</p><ul><li>保证数据的顺序收发问题</li></ul><p>比如一个http的报头，原本的格式应该是下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></table></figure><p>结果由于传输的过程中乱序了，变成了下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 GET /</span><br></pre></td></tr></table></figure><p>这种情况，是不能被应用层所正常解析的！数据全都乱了，原本写好的代码也没用了。</p><p>所以，为了避免数据在传输中<code>乱序</code>，tcp的序号就有了新的功能——保证数据的按序到达。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.客户端发送了1-5号报文</span><br><span class="line">2.服务端收到了1 3 4 2 5（乱序）</span><br><span class="line">3.服务端在tcp的接收缓冲区中，将报文重排序为1-5</span><br><span class="line">4.将重排序后的正确数据交付给应用层</span><br></pre></td></tr></table></figure><p>但是，如果<strong>只</strong>按顺序来接收数据，那就无法处理<code>优先级</code>问题。<span id="jump">这部分</span>将在后文<strong>6个标记位</strong>详解。</p><p>序号除了可以用于排序，还能用于<code>去重</code>，这部分也将在后文<strong>超时重传</strong>部分解析。</p><h2 id="3-4-16位窗口大小"><a href="#3-4-16位窗口大小" class="headerlink" title="3.4 16位窗口大小"></a>3.4 16位窗口大小</h2><h3 id="3-4-1-发送和接收缓冲区"><a href="#3-4-1-发送和接收缓冲区" class="headerlink" title="3.4.1 发送和接收缓冲区"></a>3.4.1 发送和接收缓冲区</h3><p>tcp同时拥有发送和接收缓冲区。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/6415458533954.png" alt="image-20230318130053000"></p><p>我们在应用层调用的<code>read/write</code>函数，实际上只是将数据<code>从接收缓冲区中拷贝出来/发送的数据拷贝到发送缓冲区</code>。</p><blockquote><p>如果write包含将数据发送给对方的过程，那么这个函数的调用效率就太低了，影响应用层执行其他代码。</p></blockquote><p>数据并没有被立即送入网络传输，而是由tcp协议自主决定发送数据的长度和发送的时间！这一切，都是由<strong>操作系统</strong>来决定的。这就是为什么tcp又称为<code>传输控制协议</code>！</p><h3 id="3-4-2-接收缓冲区满了咋办"><a href="#3-4-2-接收缓冲区满了咋办" class="headerlink" title="3.4.2 接收缓冲区满了咋办"></a>3.4.2 接收缓冲区满了咋办</h3><p>既然有缓冲区，就肯定会存在缓冲区被写满的问题。</p><ul><li>发送缓冲区满，由操作系统告知应用层，不再往发送缓冲区中写入数据</li><li>接受缓冲区满<ul><li>直接丢弃数据？</li><li>告诉对方，不再给自己发信息？</li></ul></li></ul><p>在实际的tcp收发过程中，由于<strong>接收方缓冲区满</strong>而丢弃数据，是不可接受的。因为数据跨过了茫茫网络，都已经到你机器上了，结果因为你缓冲区满了给它丢掉了，这不是坑人吗？</p><p>虽然出现这种情况，我们可以让发送方重传报文，但这样效率太低！</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202211031203959.jpg" alt="QQ图片20220424132543"></p><p>所以，我们应该让收发双方知晓对方的缓冲区大小，从而避免这个问题！</p><p>这就是tcp报头中<code>16位窗口大小</code>的作用了！</p><h3 id="3-4-3-告知对方收缓大小"><a href="#3-4-3-告知对方收缓大小" class="headerlink" title="3.4.3 告知对方收缓大小"></a>3.4.3 告知对方收缓大小</h3><p>如下图，在客户端和服务端<code>互通有无</code>的时候，假设服务端的<strong>接收缓冲区</strong>满了，应该告知客户端，让他别再给自己发消息了。</p><p>此时，服务端设置自己的<code>16位窗口大小</code>，以此告知客户端自己的缓冲区<strong>剩余</strong>容量。</p><p>如果对方发来的报文中，<code>16位窗口大小</code>所表示的缓冲区剩余容量已经不足了，发送方就不应该继续发送，而应该等待对方从缓冲区中取走数据。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/64154988e2f2b.png" alt="image-20230318131802239"></p><p>这是已经开始通讯的情况，但如果是<strong>第一次</strong>通讯呢？如果客户端一来就发送了一个巨大的数据，直接塞满了服务端的缓冲区，那不是出事了？</p><p>这便是tcp在<strong>三次握手</strong>中要做的事情了，简单来说就是在通信开始前就互相告知自己缓冲区的大小。后文会讲解。</p><h3 id="3-4-4-缓冲区是否独立？"><a href="#3-4-4-缓冲区是否独立？" class="headerlink" title="3.4.4 缓冲区是否独立？"></a>3.4.4 缓冲区是否独立？</h3><ul><li>进程的tcp缓冲区是独立的吗？</li></ul><p>每个进程都有自己的内核空间，内核空间里有tcp缓冲区，所以每个进程都有自己独立的tcp缓冲区</p><ul><li>线程的tcp缓冲区是独立的吗？</li></ul><p>是的！虽然这些线程共享同一个内核TCP缓冲区，但是每个线程使用的缓冲区是独立的，互相之间不会产生冲突。每个线程对自己的缓冲区进行读写操作时，会使用内核提供的同步机制，如互斥锁、信号量等来确保线程之间的缓冲区不会互相干扰，从而实现数据的安全读写。</p><h2 id="3-5-六个标记位"><a href="#3-5-六个标记位" class="headerlink" title="3.5 六个标记位"></a>3.5 六个标记位</h2><p>在4位首部长度右侧，有一块保留长度，和6个标记位。这六个标记位是所有设备都支持的标记位。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/64156cd9c9751.png" alt="image-20230318154843384"></p><h3 id="3-5-1-8个标记位？"><a href="#3-5-1-8个标记位？" class="headerlink" title="3.5.1 8个标记位？"></a>3.5.1 8个标记位？</h3><p>在部分书籍中，还会出现8个标记位与4位保留长度的说法（下图源自《图解tcp&#x2F;ip第五版》）</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/64156e7dd3169.png" alt="image-20230318155543377"></p><ul><li>CWR（Congestion Window Reduced）：该标志位用于通知对方自己已经将拥塞窗口缩小。在TCP SYN握手时，发送方会将CWR标志位设置为1，表示它支持ECN（Explicit Congestion Notification）拥塞控制，并且接收到的TCP包的IP头部的ECN被设置为11。如果发送方收到了一个设置了ECE（ECN Echo）标志位的TCP数据包，则它将调整自己的拥塞窗口，就像它从丢失的数据包中快速恢复一样。然后，发送方会在下一个数据包中设置CWR标志位，向接收方表明它已对拥塞做出反应。发送方在每个RTT（Round Trip Time）间隔最多做出一次这种反应。</li><li>ECE（ECN Echo）：该标志位用于通知对方从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时，TCP首部中的ECE会被设置为1。接收方会在所有数据包中设置ECE标志位，以便通知发送方网络发生了拥塞。</li></ul><p>而我百度到的文章提到，tcp给多出来的两个标记位新增了功能：</p><ul><li>除了以上6个标志位，还有一个实验性的标志位NS（Nonce Sum），用于防止TCP发送者的数据包标记被意外或恶意改动。NS标志位仍然是一个实验标志，用于帮助防止发送者的数据包标记被意外或恶意更改。<a class="link" target="_blank" rel="noopener" href="https://www.codetd.com/article/12421677">[3]<i class="fas fa-external-link-alt"></i></a><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38323666/article/details/85338477">[4]<i class="fas fa-external-link-alt"></i></a></li><li>TCP标志位中还有两个标志位后来加的一个功能：显式拥塞通知（ECN）。ECN允许拥塞控制的端对端通知而避免丢包。但是，ECN在某些老旧的路由器和操作系统（例如：Windows XP）上不受支持。在TCP连接上使用ECN也是可选的；当ECN被使用时，它必须在连接创建时通过SYN和SYN-ACK段中包含适当选项来协商。 <a class="link" target="_blank" rel="noopener" href="https://www.likecs.com/show-203551574.html">[2]<i class="fas fa-external-link-alt"></i></a><a class="link" target="_blank" rel="noopener" href="https://www.codetd.com/article/12421677">[3]<i class="fas fa-external-link-alt"></i></a></li></ul><p>诸如<code>tcp的标记位到底是6个还是8个?</code>这种摸棱两可的问题，在考试中不会问道。</p><p>在学习中，我们只需要掌握所有设备都支持的<strong>6个标记位</strong>即可</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/02/202211031205743.png" alt="狗头"></p><h3 id="3-5-2-ACK"><a href="#3-5-2-ACK" class="headerlink" title="3.5.2 ACK"></a>3.5.2 ACK</h3><p>该标记位用于标识本条报文是对之前的报文的<code>确认应答</code></p><p>ACK标记位的设置和其他标记位并不冲突，在<code>捎带应答</code>的时候，可以同时设置多个标记位</p><h3 id="3-5-3-SYN-x2F-FIN"><a href="#3-5-3-SYN-x2F-FIN" class="headerlink" title="3.5.3 SYN&#x2F;FIN"></a>3.5.3 SYN&#x2F;FIN</h3><ul><li>SYN：表示请求建立连接，并在建立连接时用于同步序列号，所以又称为<code>同步报文</code>；</li><li>FIN：表示请求关闭连接，又称为<code>结束报文</code>。设置为1时，代表本方希望断开连接。此时双方要交换FIN（四次挥手）才能真正断开tcp连接。</li></ul><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/6415723928135.png" alt="image-20230318161138819"></p><h4 id="3-5-3-1-三次握手"><a href="#3-5-3-1-三次握手" class="headerlink" title="3.5.3.1 三次握手"></a>3.5.3.1 三次握手</h4><p>在三次握手的时候，经历了如下过程</p><ul><li>连接发方A向对方主机B发送SYN报文，请求建立连接（A进入<code>SYN-SENT</code>状态）</li><li>主机B在收到报文后，回应<code>ACK+SYN</code>的报文，在确认应答的同时，请求建立连接（B进入<code>SYN-RCVD</code>状态）</li><li>A收到这条报文后，发送确认应答ACK（A认为连接成功建立 <code>ESTABLISHED</code>）</li><li>B收到A发送的ACK，三次握手完成（B认为连接成功建立 <code>ESTABLISHED</code>）</li></ul><h4 id="3-5-3-2-四次挥手"><a href="#3-5-3-2-四次挥手" class="headerlink" title="3.5.3.2 四次挥手"></a>3.5.3.2 四次挥手</h4><p>在断开连接，四次挥手的时候，经历了如下过程</p><ul><li>A要断开连接，发送FIN（A进入<code>FIN WAIT 1</code>状态）</li><li>B收到了FIN，发送ACK（B进入<code>CLOSE-WAIT</code>半关闭状态）</li><li>A收到了ACK（A进入<code>FIN WAIT 2</code>状态)</li><li>此时只是A要和B单方面分手，<code>A-&gt;B</code>的路被切断了，但是<code>B-&gt;A</code>的还没有，B还能继续给A发数据</li><li>B发完数据了，也和A分手了，B发送FIN（B进入<code>LAST ACK</code>状态）</li><li>A收到FIN，发送回应ACK（A进入<code>TIME WAIT</code>状态，将在<strong>一段时间后</strong>进入<code>CLOSE</code>断连状态）</li><li>B收到了ACK（B进入<code>CLOSE</code>状态）</li><li>连接关闭</li></ul><p>我们不仅需要知道3次握手和4次挥手的过程，还需要知道每一次的状态变化！</p><blockquote><p>3次握手和4次挥手对于应用层而言，都只有1个对应的函数。这些操作都是由tcp自主完成的。</p></blockquote><h3 id="3-5-4-PSH"><a href="#3-5-4-PSH" class="headerlink" title="3.5.4 PSH"></a>3.5.4 PSH</h3><p>PSH标记位的作用是：要求对方立马取走缓冲区中数据</p><p>如下图，S在接收缓冲区满了之后过了很久，还没有取走缓冲区中的数据，C实在忍不住了，给S发一个<code>PSH</code>标记位的报文，要求S立马取走这些数据！</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/641578af00365.png" alt="image-20230318163912700"></p><p>tcp在收到此报文后，将由操作系统告知应用层，取走缓冲区中的数据。</p><p>如果应用层不听操作系统的咋办？<strong>那就代表应用层写的有bug</strong>！人家给你发了那么多东西了你还不处理，有点过分了！</p><h3 id="3-5-5-URG"><a href="#3-5-5-URG" class="headerlink" title="3.5.5 URG"></a>3.5.5 URG</h3><p>URG是<strong>紧急指针标记位</strong>。</p><p>在<a href="#jump">3.3.5 按序到达</a>部分提到过，如果只关注序号，则无法处理优先级问题。有一些数据对于应用层来说，优先级较高。如果tcp只会老老实实的按顺序把数据交付给应用层，那在高优先级的数据也搞不过操作系统对tcp的处理。</p><p>所以，为了能操作优先级，tcp提供了<code>URG</code>标记位，设置了此标记位的报文具有较高优先级。</p><p>应用层有专门的接口可以优先读取带有<code>URG</code>标记位的报文。</p><h4 id="3-5-5-1-16位紧急指针"><a href="#3-5-5-1-16位紧急指针" class="headerlink" title="3.5.5.1 16位紧急指针"></a>3.5.5.1 16位紧急指针</h4><p>为了能标识这个紧急数据在报文中的位置，tcp还提供了<code>16位紧急指针</code>；这个指针的指向便是<strong>紧急数据</strong>在tcp报文中的偏移量。<strong>紧急数据</strong>规定只有1个字节！</p><p>由于紧急指针的数据可以被提前读取，不受tcp缓冲区的约束，所以又被称为<code>带外数据</code></p><p>下图就举了一个紧急指针使用的场景：</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/64157b0e4aeba.png" alt="image-20230318164915979"></p><p>TCP 在传输数据时是有顺序的，它有<strong>字节号</strong>，URG配合紧急指针，就可以找到紧急数据的<strong>字节号</strong>。</p><p>紧急数据的字节号公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">紧急数据字节号(urgSeq)=TCP报文序号(seq)+紧急指针(urgpoint)−1</span><br></pre></td></tr></table></figure><p>比如图中的例子，如果 <code>seq = 10,urgpoint = 5</code>，那么字节序号 <code>urgSeq = 10 + 5 -1 = 14</code></p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/641582bf3d3bc.png" alt="image-20230318172209050"></p><p>知道了字节号后，就可以计算紧急数据字位于<strong>所有传输数据中</strong>的第几个字节了。如果从第0个字节开始算起，那么紧急数据就是第<code>urgSeq - ISN - 1</code>个字节（ISN 表示初始序列号），减1表示不包括第一个SYN段，因为一个SYN段会消耗一个字节号。</p><h3 id="3-5-6-RST"><a href="#3-5-6-RST" class="headerlink" title="3.5.6 RST"></a>3.5.6 RST</h3><p>RST为复位报文，即<code>RESET</code>。</p><p>如下图，如果A给B发送的ACK在传输路途上丢失了，咋办？</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/6415911e126cc.png" alt="image-20230318182326946"></p><p>这时候，就会出现A认为连接已经建立，而B由于没收到A的ACK而处于<code>SYN-RCVD</code>状态。</p><ul><li>此时A开始给B发送数据，B一看，不是说好了要建立连接才能发送数据的吗，你这是在干嘛？</li><li>于是B告知A，发送RST标志位的报文，要求和A重新建立连接（重新进行三次握手）</li><li>重新建立连接成功后，AB再正常发送信息。</li></ul><p>我们使用浏览器访问一些网页时，<code>F5刷新</code>就可以理解为浏览器向服务器发送了一个带有RST标记位的报文</p><h2 id="3-6-为什么是3次握手？"><a href="#3-6-为什么是3次握手？" class="headerlink" title="3.6 为什么是3次握手？"></a>3.6 为什么是3次握手？</h2><p>为什么握手的次数是3次，不是1次、2次、4次、5次？</p><p>在讨论这个问题之前，我们要知道：连接建立是有消耗的！需要维护其缓存区、连接描述符（linux下为文件描述符）等等数据。</p><ul><li>如果是一次握手？</li></ul><p>一次握手，即A给B发送一个SYN，双方就认为连接建立了。</p><p>那么我们直接拿个机器，写个死循环，一直给对方发送SYN，自己直接丢弃文件描述符（不做维护）</p><p>由于服务器并不知道你直接丢弃了文件描述符，其还是要为此次连接维护相关数据，这样会导致服务器的资源在短时间内被大量消耗，最后直接dead了</p><blockquote><p>这种攻击叫做<strong>SYN洪水</strong></p></blockquote><ul><li>如果是二次握手？</li></ul><p>A给B发送一个SYN，B给A发送一个ACK，即认为连接建立。</p><p>这和一次握手其实是相似的，服务器发送完毕ACK之后，就认为连接已经建立，需要维护相关资源。而我们依旧可以直接丢弃，不进行任何维护，最后还是服务器的资源被消耗完了</p><ul><li>三次握手</li></ul><p>双方都必须维护连接的相关资源，这样，哪怕你攻击我的服务器，你也得付出同等的资源消耗。最后就是比谁资源更多呗！</p><p>相比于前两种情况，三次握手能在支持全双工的同时，一定程度上避免攻击。</p><p>注意，是一定程度上避免攻击。我们依旧可以用很多宿主机“堆料”来和服务器硬碰硬，这是无可避免的情况</p><ul><li>更多次握手？</li></ul><p>由于三次握手已经满足了我们的要求，更多次握手依旧有被攻击的可能，还降低了效率，完全没必要！</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/64158f71c8c50.png" alt="image-20230318181619570"></p><h2 id="3-7-超时重传"><a href="#3-7-超时重传" class="headerlink" title="3.7 超时重传"></a>3.7 超时重传</h2><p>为了保证可靠性，如果一个报文长时间未收到对方的ACK回应，则需要进行<code>超时重传</code>。</p><p>linux下每一次尝试的时间间隔为500ms，若500ms内尚未收到对方的ACK，则重发报文，再等待1000ms……以此类推。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/6415924e3984a.png" alt="image-20230318182832179"></p><p>超时重传还可能遇到下面的情况：</p><ul><li>服务器收到了消息，也发送了ACK，但是ACK在路上丢失了</li><li>客户端没有收到ACK，于是进行超时重传</li><li>服务器再次收到了消息，此时接收缓冲区里出现了两个一样的数据</li></ul><p>但是，我们的报文是有序号的，tcp就可以<strong>直接根据序号去重</strong>，所以，tcp交给应用层的数据是<code>去重+排序</code>之后的数据！</p><hr><p>如果同一个报文超时重传了好几次，还没有收到对方的应答，就会认为对方的服务挂掉了，此时本端会强制断连。</p><p>此时客户端就可以发送一个带有RST标记位的报文，要求和对方重新建立连接。</p><h2 id="3-8-出现了很多CLOSE-WAIT状态的连接？"><a href="#3-8-出现了很多CLOSE-WAIT状态的连接？" class="headerlink" title="3.8 出现了很多CLOSE-WAIT状态的连接？"></a>3.8 出现了很多CLOSE-WAIT状态的连接？</h2><p>在上面提到过，当客户端向服务器发送FIN之后，服务器回复ACK，会进入<code>CLOSE-WAIT</code>状态。此时服务器还能给客户端发送消息，双方都还在维护连接的相关资源。</p><p>如果一个服务出现了很多个处于<code>CLOSE-WAIT</code>状态的连接，就必须要检查一下，应用层的代码里面是不是没有调用<code>close(fd)</code>函数来关闭对应的文件描述符。</p><ul><li>一方的<code>close(fd)</code>就对应了两次挥手</li></ul><p>对方明明都要和你分手了，你还挂着对方当备胎，还要找对方要钱，也太不像话了😂</p><h1 id="4-验证状态"><a href="#4-验证状态" class="headerlink" title="4.验证状态"></a>4.验证状态</h1></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【Linux】tcp协议 | 详解</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2023-03-17 15:30:55</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">2023/03/17/Linux/37重看tcp/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/tcp/">#tcp</a>&nbsp;</li></ul><div class="article-nav"><div class="article-next"><a class="next" rel="next" href="/2023/03/16/tools/18git%20status%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"><span class="title flex-center"><span class="post-nav-title-item">【Git】解决git status中文乱码问题</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true',
              requiredMeta: ['nick','mail'] 
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4"><span class="nav-text">1.linux下常用网络命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-netstat%E5%91%BD%E4%BB%A4"><span class="nav-text">1.1 netstat命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-pidof"><span class="nav-text">1.2 pidof</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-udp%E5%8D%8F%E8%AE%AE"><span class="nav-text">2.udp协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%90%86%E8%A7%A3%E6%8A%A5%E5%A4%B4"><span class="nav-text">2.1 理解报头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-udp%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">2.2 udp的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-udp%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">2.3 udp缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E4%B8%A2%E5%8C%85"><span class="nav-text">2.4 丢包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-text">2.5 基于udp的应用层协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-tcp%E5%8D%8F%E8%AE%AE"><span class="nav-text">3.tcp协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%BA%90%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-text">3.1 源和目的端口号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-4%E4%BD%8D%E9%A6%96%E9%83%A8%E9%95%BF%E5%BA%A6"><span class="nav-text">3.2 4位首部长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-32%E4%BD%8D%E5%BA%8F%E5%8F%B7-x2F-%E7%A1%AE%E8%AE%A4%E5%BA%8F%E5%8F%B7"><span class="nav-text">3.3 32位序号&#x2F;确认序号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E4%BF%A1%E6%81%AF%E8%A2%AB%E5%AF%B9%E6%96%B9%E6%94%B6%E5%88%B0%EF%BC%9F"><span class="nav-text">3.3.1 如何确认信息被对方收到？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94"><span class="nav-text">3.3.2 确认应答</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%A4%E7%BB%84%E7%A1%AE%E8%AE%A4%E5%BA%8F%E5%8F%B7%EF%BC%9F"><span class="nav-text">3.3.3 为什么有两组确认序号？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E6%B2%A1%E6%9C%89%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%81"><span class="nav-text">3.3.4 没有完美的协议！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-%E6%8C%89%E5%BA%8F%E5%88%B0%E8%BE%BE"><span class="nav-text">3.3.5 按序到达</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-16%E4%BD%8D%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F"><span class="nav-text">3.4 16位窗口大小</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">3.4.1 发送和接收缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%A1%E4%BA%86%E5%92%8B%E5%8A%9E"><span class="nav-text">3.4.2 接收缓冲区满了咋办</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E5%91%8A%E7%9F%A5%E5%AF%B9%E6%96%B9%E6%94%B6%E7%BC%93%E5%A4%A7%E5%B0%8F"><span class="nav-text">3.4.3 告知对方收缓大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%98%AF%E5%90%A6%E7%8B%AC%E7%AB%8B%EF%BC%9F"><span class="nav-text">3.4.4 缓冲区是否独立？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%85%AD%E4%B8%AA%E6%A0%87%E8%AE%B0%E4%BD%8D"><span class="nav-text">3.5 六个标记位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-8%E4%B8%AA%E6%A0%87%E8%AE%B0%E4%BD%8D%EF%BC%9F"><span class="nav-text">3.5.1 8个标记位？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-ACK"><span class="nav-text">3.5.2 ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-SYN-x2F-FIN"><span class="nav-text">3.5.3 SYN&#x2F;FIN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">3.5.3.1 三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-text">3.5.3.2 四次挥手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-PSH"><span class="nav-text">3.5.4 PSH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-URG"><span class="nav-text">3.5.5 URG</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-5-1-16%E4%BD%8D%E7%B4%A7%E6%80%A5%E6%8C%87%E9%92%88"><span class="nav-text">3.5.5.1 16位紧急指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-6-RST"><span class="nav-text">3.5.6 RST</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF3%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-text">3.6 为什么是3次握手？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="nav-text">3.7 超时重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E5%87%BA%E7%8E%B0%E4%BA%86%E5%BE%88%E5%A4%9ACLOSE-WAIT%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-text">3.8 出现了很多CLOSE-WAIT状态的连接？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E9%AA%8C%E8%AF%81%E7%8A%B6%E6%80%81"><span class="nav-text">4.验证状态</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/about">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_3_tp.gif" height="20px"> </a><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>