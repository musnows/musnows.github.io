<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><title>【图】拓扑排序 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/MainBG.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":"meufCipLPHNWVE3gWEnozHzz-gzGzoHsz","appkey":"CFX9WelJjGHkaMnSunOlv3dX","server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【图】拓扑排序</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2023-03-12 09:00:49</span> <span class="mobile">2023-03-12 09:00</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-03-12 09:13:27</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%AA%E5%A4%8D%E6%9D%82/">数据结构太复杂</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;</li><li>| <a href="/tags/Java/">Java</a>&nbsp;</li><li>| <a href="/tags/%E5%9B%BE/">图</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>2.6k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><p>本文搬运自csdn</p><span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">什么是拓扑排序？</a></li><li><a href="#%E6%80%8E%E4%B9%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">怎么拓扑排序？</a></li><li><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0">拓扑排序实现</a></li></ul></li><li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">关键路径</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">什么是关键路径？</a></li><li><a href="#%E6%80%8E%E4%B9%88%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">怎么求关键路径？</a></li><li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E5%AE%9E%E7%8E%B0">关键路径实现</a></li><li><a href="#%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B">求关键路径过程示例</a></li></ul></li></ul><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><a class="link" target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F&spm=1001.2101.3001.7020">拓扑排序<i class="fas fa-external-link-alt"></i></a></h1><h2 id="什么是拓扑排序？"><a href="#什么是拓扑排序？" class="headerlink" title="什么是拓扑排序？"></a>什么是拓扑排序？</h2><p>  在图论中，<strong>拓扑排序</strong>是一个<strong>有向无环图</strong>的所有顶点的线性序列(获得拓扑有序序列)。且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/640d23c77df53.png"></p><h2 id="怎么拓扑排序？"><a href="#怎么拓扑排序？" class="headerlink" title="怎么拓扑排序？"></a>怎么拓扑排序？</h2><p><strong>拓扑排序步骤：</strong></p><ol><li>在有向图中选一个没有前驱的顶点且输出之。</li><li>从图中删除该顶点和所有以它为尾的弧。</li></ol><p>  重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止。后一种情况则说明有向图中存在环。</p><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/eb618be1ff4873833c8469dae9093d1e.png"><br>  图中，V1 和 V6 没有前驱，则可任选一个。假设先输出 V6，在删除 V6 及弧 &lt;V6, V4&gt;,&lt;V6, V5&gt; 之后，只有顶点 V1 没有前驱，输出 V1 且删去 V1 及弧 &lt;V1, V2&gt;,&lt;V1, V3&gt; 和 &lt;V1, V4&gt;，之后 V3 和 V4 都没有前驱。依此类推，可从中任选一个继续进行。整个拓扑排序的过程如上图。</p><h2 id="拓扑排序实现"><a href="#拓扑排序实现" class="headerlink" title="拓扑排序实现"></a>拓扑排序实现</h2><p>  我们采用<strong>邻接表</strong>作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组。入度为零的顶点即为没有前驱的顶点，删除顶点以及它为尾的弧的操作，则可换以弧头顶点的入度减 1 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line">	<span class="comment">//有向图G采用邻接表存储结构 </span></span><br><span class="line">	<span class="comment">//若G无回路，则输出G的顶点的一个拓扑序列并返回OK，否则ERROR </span></span><br><span class="line">	FindInDegree(G, indegree);<span class="comment">//对各顶点求入度indegree[0..vernum-1] </span></span><br><span class="line">	InitStack(S);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//建零入度顶点栈S </span></span><br><span class="line">		<span class="keyword">if</span>(!indegree[i])<span class="comment">//入度为0者进栈 </span></span><br><span class="line">			Push(S, i);</span><br><span class="line">	count = <span class="number">0</span>;<span class="comment">//对输出顶点计数 </span></span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">		Pop(S, i);	printf(i, G.vertices[i].data);	count++;<span class="comment">//输出i号顶点并计数 </span></span><br><span class="line">		<span class="keyword">for</span>(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">			k = p-&gt;adjvex;<span class="comment">//对i号顶点的每个邻接点的入度减1 </span></span><br><span class="line">			<span class="keyword">if</span>(!(--indegree[k]))<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">				Push(S, k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count&lt;G.vexnum)<span class="comment">//该有向图有回路 </span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对有 n 个顶点和 e 条弧的有向图而言，建立求各顶点的入度的时间复杂度 O(e)；建零入度顶点栈的时间复杂度为 O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减 1 的操作在 WHILE 语句中总共执行 e 次，所以，总的**时间复杂度为 O(n+e)**。<br>  当有向图中无环时，也可利用深度优先遍历进行拓扑排序，因为图中无环，则由图中某点出发进行深度优先搜索遍历时，最先退出 DFS 函数的顶点即出度为零的顶点，是拓扑有序序列中最后一个顶点。由此，按退出 DFS 函数的先后记录下来的顶点序列(如同求强连通分量时 finished 数组中的顶点序列)即为逆向的拓扑有序序列。</p><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><h2 id="什么是关键路径？"><a href="#什么是关键路径？" class="headerlink" title="什么是关键路径？"></a>什么是关键路径？</h2><p><strong>AOE网：</strong> 在一个表示工程的带权有向图中，用顶点表示事件（如V1），用有向边表示活动（如&lt;V1,V2&gt; &#x3D; a1），边上的权值表示活动的持续时间，称这样的有向图为边表示的活动的网。<br><strong>源点：</strong> 在AOE网中，没有入边的顶点称为源点；如顶点V1。<br><strong>终点：</strong> 在AOE网中，没有出边的顶点称为终点；如顶点V9。<br><strong>AOE网的性质：</strong></p><ol><li>只有在进入某顶点的活动都已经结束，该顶点所代表的事件才发生；例如，V5 事件发生需要 a4 和 a5 两个活动都结束。</li><li>只有在某顶点所代表的事件发生后，从该顶点出发的各活动才开始；例如，V5 事件结束，活动 a7 和 a8 活动才能开始。<br><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/d52c8bebe169544eea3f93136b617d61.jpeg"></li></ol><p>  在AOE网中，所有活动都完成才能到达终点，因此完成整个工程所必须花费的时间（即最短工期）应该为源点到终点的最大路径长度。具有最大路径长度的路径称为<strong>关键路径</strong>。关键路径上的活动称为<strong>关键活动</strong>。<br>  假设开始点是 V1，从 V1 到 Vi 的最长路径长度叫做事件 Vi 的<strong>最早发生事件</strong>。这个时间决定了所有以 Vi 为尾的弧所表示的活动的<strong>最早开始时间</strong>。我们用 e(i) 表示活动 ai 的最早开始时间。还可以定义一个活动的<strong>最迟开始时间</strong> l(i)，这是在不推迟整个过程完成的前提下，活动 ai 最迟必须开始进行的时间。两者之差 l(i)-e(i) 意味着完成活动 ai 的时间余量。我们把 l(i)&#x3D;e(i) 的活动叫做关键活动。</p><p><strong>向关键路径要时间，向非关键路径要资源。</strong></p><ol><li><strong>从前往后，计算工期与每项活动的最早开始时间；</strong></li><li><strong>从后往前，倒推每项活动最晚开始时间。</strong></li><li><strong>关键路径：最早开始时间&#x3D;最晚开始时间</strong></li></ol><h2 id="怎么求关键路径？"><a href="#怎么求关键路径？" class="headerlink" title="怎么求关键路径？"></a>怎么求关键路径？</h2><p>ve(j)：最早发生时间<br>vl(j)：最迟发生时间</p><ol><li>输入 e 条弧&lt;j, k&gt;，建立 AOE-网的存储结构；</li><li>从源点 v0 出发，令 <code>ve[0]=0</code>，按拓扑有序求其余各顶点的最早发现时间 <code>ve[i] (1≤i≤n-1)</code>。如果得到的拓扑有序序列中顶点个数小于网中顶点数 n，则说明网中存在环，不能求关键路径，算法终止；否则执行步骤(3)。</li><li>从汇点 vn 出发，令 <code>vl[n-1]=ve[n-1]</code>，按逆拓扑有序求其余各顶点的最迟发生时间<code>vl[i] (n-2≥i≥2)</code>；</li><li>根据各顶点的 ve 和 vl 值，求每条弧 s 的最早开始时间 e(s) 和最迟开始时间 l(s)。若某条弧满足条件 e(s)&#x3D;l(s)，则为关键活动。</li></ol><p>  根据上述算法，计算各顶点的 ve 值是在拓扑排序的过程中进行的，需对拓扑排序的算法作如下修改：</p><ol><li>在拓扑排序之前设初值，令 <code>ve[i]=0 (0≤i≤n-1)</code>；</li><li>在算法中增加一个计算 vj 的直接后继 vk 的最早发生时间的操作：若 <code>ve[j]+dut(&lt;j, k&gt;) &gt; ve[k]</code>，则 <code>ve[k]=ve[j]+dut(&lt;j, k&gt;)</code>；</li><li>为了能按逆拓扑有序序列的顺序计算各顶点的 vl 值，需记下在拓扑排序的过程中求得的拓扑有序序列，这需要在拓扑排序算法中，增设一个栈以记录拓扑有序序列，则在计算求得各顶点的 ve 值之后，从栈顶至栈底便为逆拓扑有序序列。</li></ol><h2 id="关键路径实现"><a href="#关键路径实现" class="headerlink" title="关键路径实现"></a>关键路径实现</h2><p><strong>改写的拓扑排序代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">TopologicalOrder</span><span class="params">(ALGraph G, Stack &amp;T)</span>&#123;</span><br><span class="line">	<span class="comment">//有向图G采用邻接表存储结构，求各顶点事件的最早发生时间 ve(全局变量) </span></span><br><span class="line">	<span class="comment">//T为拓扑序列顶点栈，S为零入度顶点栈 </span></span><br><span class="line">	<span class="comment">//若G无回路，则用栈T返回G的一个拓扑序列，且函数值为OK，否则ERROR </span></span><br><span class="line">	FindInDegree(G, indegree);<span class="comment">//对各顶点求入度indegree[0..vernum-1] </span></span><br><span class="line">	InitStack(S);<span class="comment">//建零入度顶点栈S </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//建零入度顶点栈S </span></span><br><span class="line">		<span class="keyword">if</span>(!indegree[i])<span class="comment">//入度为0者进栈 </span></span><br><span class="line">			Push(S, i);</span><br><span class="line">	InitStack(T);	count = <span class="number">0</span>;	ve[<span class="number">0.</span>.G.vexnum-<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">		Pop(S, j);	Push(T, j);	count++;<span class="comment">//j号顶点入T栈并计数 </span></span><br><span class="line">		<span class="keyword">for</span>(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">			k = p-&gt;adjvex;<span class="comment">//对j号顶点的每个邻接点的入度减1 </span></span><br><span class="line">			<span class="keyword">if</span>(--indegree[k] == <span class="number">0</span>)<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">				Push(S, k);</span><br><span class="line">			<span class="keyword">if</span>(ve[j]+ *(p-&gt;info)&gt;ve[k])</span><br><span class="line">				ve[k] = ve[j] + *(p-&gt;info);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count &lt; G.vexnum)<span class="comment">//该有向图有回路 </span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>关键路径算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">CriticalPath</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line">	<span class="comment">//G为有向图，输出G的各项关键活动 </span></span><br><span class="line">	<span class="keyword">if</span>(!TopologicalOrder(G, T))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	vl[<span class="number">0.</span>.G.vexnum-<span class="number">1</span>] = ve[G.vexnum-<span class="number">1</span>];<span class="comment">//初始化顶点事件的最迟发生事件 </span></span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(T))&#123;<span class="comment">//按拓扑逆序求各顶点的vl值 </span></span><br><span class="line">		<span class="keyword">for</span>(Pop(T, j),p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">			k = p-&gt;adjvex;	dut = *(p-&gt;info);</span><br><span class="line">			<span class="keyword">if</span>(vl[k]-dut &lt; vl[j])</span><br><span class="line">				vl[j] = vl[k]-dut;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;<span class="comment">//求ee，el和关键活动 </span></span><br><span class="line">		<span class="keyword">for</span>(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">			k = p-&gt;adjvex;	dut = *(p-&gt;info);</span><br><span class="line">			ee = ve[j];	el = vl[k]-dut;</span><br><span class="line">			tag = (ee==el)?<span class="string">&#x27;*&#x27;</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">			printf(j, k, dut, ee, el, tag);<span class="comment">//输出关键活动 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>  上面两种算法的时间复杂度均为 O(n+e)，计算弧的活动最早开始时间和最迟开始时间的时间复杂度为 O(e)，所以总的求关键路径的**时间复杂度为 O(n+e)**。</p><h2 id="求关键路径过程示例"><a href="#求关键路径过程示例" class="headerlink" title="求关键路径过程示例"></a>求关键路径过程示例</h2><p><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/f0dcb74c0eff3d6f56e8415a2664e1dd.png"><br><img lazyload alt="image" data-src="https://img1.musnow.top/i/2023/03/d52c8bebe169544eea3f93136b617d61.jpeg"></p><p>上图的关键活动为 a1，a4，a7，a8，a10 和 a11。它们构成两条关键路径：(V1，V2，V5，V7，V9) 和 (V1，V2，V5，V8，V9)。</p><p><strong>实践证明：用 AOE-网来估算某些工程完成的时间是非常有用的。只有在不改变网的关键路径的情况下，提高关键活动的速度才有效。若网中有几条关键路径，那么，单是提高一条关键路径上的关键活动的速度，还不能导致整个工程缩短工期，而必须提高同时在几条关键路径上的活动速度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版权声明：本文为CSDN博主「qw&amp;amp;jy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_43448856/article/details/119959241</span><br></pre></td></tr></table></figure></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>&nbsp;</li><li class="tag-item"><a href="/tags/Java/">#Java</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E5%9B%BE/">#图</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2023/03/13/oj/%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%8F%E4%B8%80%E4%BD%8D%E6%8B%86%E5%88%86%E8%BE%93%E5%87%BA/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【C++】将浮点数每一位拆分并输出</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2023/03/12/tools/17%E5%8F%88%E6%8B%8D%E4%BA%91uos+picgo/"><span class="title flex-center"><span class="post-nav-title-item">【教程】Typora+PicGo+又拍云UOS搭建博客图床</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comments-anchor"></div><div class="comment-area-title"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="waline-comment-container"><link rel="stylesheet" href="/css/my/waline.css"><link rel="stylesheet" href="/css/my/waline-meta.css"><script data-pjax src="/css/my/waline.js"></script><div id="waline-comment"></div><script data-pjax>function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://waline.musnow.top/',
              lang: 'zh-CN' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'false' === 'true',
              requiredMeta: ['nick','mail'] 
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }</script></div></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><span class="nav-text">文章目录</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="nav-text">什么是拓扑排序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="nav-text">怎么拓扑排序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="nav-text">拓扑排序实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="nav-text">什么是关键路径？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="nav-text">怎么求关键路径？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">关键路径实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="nav-text">求关键路径过程示例</span></a></li></ol></li></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/about">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_3_tp.gif" height="20px"> </a><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/UPYUN-CDN.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>