[{"title":"【公告】2023-10-06 宣传一下我的 wiki 站点","url":"/posts/955376979/","content":"考虑到 hexo 博客对技术博客的归档和展示并不是以最好的排版呈现出来的，我又不想换 vuepress 这些框架，于是自己部署了一个 MrDoc 项目，打算将我所学的 Cpp&#x2F;Linux 后端知识给系统性的整理到这个网站上。\n网站可以在线编辑，也方便我跨平台操作。个人感觉这个开远光项目比一些动态博客系统都好用（只不过缺少评论，那是专业版的功能）\n目前网站刚刚搭建，只更新了少部分文档。大家感兴趣地可以收藏一下这个网站：https://wiki.musnow.top/\n首页截图如下\n\n如果有 java 或其他方向的老哥愿意共建文档站，也可以联系我，我可以给你编辑权限，创建一个属于你的文档集。\n2023-06-06 尝试使用 qexo 作为博客后端  尝试使用 qexo 作为博客后端，还挺好玩的！\n项目地址 https://github.com/Qexo/Qexo\n\n2023-03-30 本站更新为 butterfly 主题  本站更新为 butterfly 主题，keep 主题留档站点👉点我\n2023-03-28 图床被攻击  自一周之前起，图床 CDN 遭到了恶意请求（同一个 ip，同一张图片，每秒请求 15 次，日扣费 5 元。在我禁掉他的 ip 后，他换了另外一个 ip 继续请求同一张图片，因为两个 ip 的属地相同，都是  家宽，所以我认为是同一个人）\n详细信息见日志文章\n2023-03-25 url 替换  使用了 hexo-abbrlink插件，将所有 post 文章的链接配置为固定连接.\n评论和之前文章中引用的连接都已更新\nnpm install hexo-abbrlink --save\n\n\nhttps://blog.csdn.net/Mculover666/article/details/103137719\n\n2023-02-03 域名更换  域名更换为 blog.musnow.top, 更有个人标识度\n2023-02-01 关于页面藏起来了  我把关于页面藏起来啦，看看你能不能找到它的位置呢？\n2023-01-18 之前 valine 的评论已导入  已从 leancloud 国内版本导入了之前 valine 的评论到 waline，并修改了数据库中有变动的 url\n2023-01-13 站点更新 keep 版本，使用 git 管理主题  现在使用 git 的submodule 来管理 keep 主题文件\nhttps://zhuanlan.zhihu.com/p/87053283\n今天发现 jsdelivr 的 cdn 挂掉了，导致很多资源都加载不出来，转为用 nmpkg 了。同时我缓存了 2.4.16 版本的 waline 文件，全都放在阿里云了。\n2023-01-09 站点页脚添加网站运行时间  今天给站点页脚添加了网站运行时间，同时注释掉了底部的 hexo 提示框；还添加了一些 shields.io 的图标，感觉很不错！\n参考博客 hexo+yilia 添加网站运行时间，ICP 备案信息，设定站点建立时间\n\n\n今天加入了萌 ICP 备，和真的 ICP 备案没有关系，其本质和  开往  是一个类型的项目。\n2023-01-08 更新博客邮箱提醒的模板  根据教程更新了 vecrel 中 waline 所使用的评论提醒模板，响应速度还是很快的，而且配置没有 leancloud 的邮箱提醒那么麻烦；\n不过我发现 vercel 的访问可能没有那么快速，有的时候会出现评论加载不出来的情况，需要多刷新几次！\n更详细的内容请看👉7-2- 使用 -Waline 评论系统\n2023-01-07 加入开往  这个也是在逛别人的主页的时候看到的，感觉很不错！那就加入吧！\n\n开往链接 https://www.travellings.cn/\n开往是一个以跳转功能为主的友链接力项目，其名字“开往”取自“开放的网络”。\n将开往放入您的网页，表示您乐于分享并支持开放的网络。\n每当有人访问加入开往的网页时，点击“开往“会随机跳转到另一个加入开往的网页。之后，再次点击网页上的”开往“或后退网页，将继续随机跳转到另一个加入开往的网页。\n\n2023-01-06 更新 keep 版本  啊呀呀，今天折腾了一整天，才把 keep 从 3.4.5 -&gt; 3.5.2，因为我之前站点的个性化配置都是修改的 npm 包，结果发现一更新，包里面修改过的内容全没了！😥😥\n于是又根据自己写的教程，重新修改了一番，并给自定义过的背景添加了根据明暗自动变化颜色的功能（之前是没有的）\n而且评论系统也从 valine -&gt; waline，其主要的好处就是，waline 支持上传图片，用来在评论区回答一部分问题的时候，还是很方便的，不需要用户还去找个图床了。\n我通过替换 keep 主题 cdn 导入的 waline.js 文件的方式，修改了 waline 默认的图片上传限制 128KB -&gt; 1024KB\n\n我这种修改办法肯定  非常非常不规范，但是的确生效了🤣？就是不知道后续会不会出现 bug，希望不要有😶‍🌫️\n\n虽然折腾了非常非常久，还做了一些无用功，但是真的搞定的时候，还是很开心哒！\n2022-04-16 建站  今天，基于 HEXO + KEEP 主题的站点终于建立起来啦！\n搭建这个站点的灵感来源于我在逛 CSDN 时候遇到的一个博主的个人站点，并发现了 HEXO 这个开源的博客搭建框架\n首个版本是基于 Gitee Pages 的，感觉还不错！\n使用 hexo 和 keep 主题搭建个人博客\n"},{"title":"【Linux】一些工具的简单使用，vim/gcc/gdb/make","url":"/posts/1451721896/","content":"本篇博客将介绍 linux 下面一些简单工具的使用\n\n\n[TOC]\n1.vim 编辑器1.1 安装 vim# centossudo yum install vim# debiansudo apt-get install vim\n\n需要注意的是，vim 编辑器下不能使用 CTRL+S 来保存文件，因为在 linux 中这个快捷键的作用是暂停该终端，整个系统都会卡住，这时候使用 CTRL+Q 取消暂停就可以了。\n1.2 文本操作vim 一共有三种模式：命令模式，编辑模式，底行模式；\n\n进入 vim 时就是默认的命令模式，此状态下敲击键盘会被识别为命令\n按 i 进入编辑模式，此时的输入是正常写入文本\n在命令模式中，按英文半角下的 : 进入底行模式，此时输入的是底行模式的特殊命令与配置\n\n以下是命令模式下的一些文本批量化操作\nyy 复制当前行，nyy 复制 n 行p  粘贴再当前行的后面，np 粘贴 n 次剪贴板的内容dd 剪切（删除）当前行，ndd 操作 n 行u  撤销ctrl+r  重做shift+g 光标快速定位到文本末尾gg 光标快速移动到文本头n+shift+g 光标定位到文本的第 n 行shift+4 光标定位到该行末尾shift+6 光标定位到该行开头w,b   以单词为单位进行移动光标h,j,k,l  左、下、上、右shift+`  大小写快速切换r   替换光标所在处的字符，支持 nrshift+r  批量化替换x  删除光标所在处的字符，nx 删除 n 个\n\nvim 进入  插入模式  的快捷键有a i o，分别对应不同的功能\n1.3 底行模式的操作 vim 编辑器中 底行模式  的一些操作如下。在其他模式下按 esc 即退出到底行模式\n:w   &quot; 只保存:q   &quot; 不保存退出:wq  &quot; 保存并退出:reg &quot; 打开 vim 的寄存器面板:syntax on &quot; 开启语法高亮:set nu    &quot; 显示行号:set nonu  &quot; 取消行号显示:set tabstop=4 &quot; 设置 tab 的缩进，默认为 8:set softtabstop=4 &quot;softtabstop 是“逢 8 空格进 1 制表符”, 前提是你 tabstop=8:set shiftwidth=4 &quot; 设置程序自动缩进所使用的空格长度:set autoindent &quot; 自动对齐上一行（这个选项会导致复制的时候代码排版混乱，可以考虑关闭，或者开启粘贴模式）:set paste &quot; 开启粘贴模式:set mouse=a &quot; 设置鼠标模式，默认是 a:%s/A/B/g 将当前文件中的 A 全部替换成 B\n上面的一些配置，写入 .vimrc 配置文件即可长时生效。\n如果需要写入 .vimrc 配置文件，需要先把 : 和注释  都去掉\n2.gcc&#x2F;g++ 编译器g++ 操作和 gcc 是一样的，这里我们使用 gcc 作为演示\n2.1linux 下使用不同命令执行程序的几个阶段  第一步是预处理，只做文本操作\ngcc -E test.c -o tset.i\n在这个阶段会\n\n展开头文件\n对 define 等等操作进行替换\n处理条件编译指令\n同时删除所有注释\n\n编译操作\ngcc -S test.i -o test.s\n\n汇编操作\ngcc -c test.s -o test.o\n形成可执行程序\ngcc test.o -o mytest\n这三个命令的顺序就是 ESc 其中只有 -c 选项是小写的\n正好就是键盘左上角 esc 按键的顺序\n2.2 代码和库  这里我们操作 &#x2F; 编译的都是自己的代码。比如 printf 我是调用的 c 语言库中的函数，并没有自己完成一个打印的实现。\n这时候就需要和系统的 c 语言库产生关联\nc 标准库的位置ls /lib64/libc*\n上面的最后一步形成可执行程序 mytest 时，系统会自动帮我们把这里的代码和库里面的方法连接起来，形成一个最终的可执行程序，并使用 ./mytest 来执行输出结果\n所以我们平时说的装环境就是需要安装语言的静态和动态库，这样才能正常利用库里面的函数进行代码的编译处理\n同时我们在编译器里面写代码时的代码补全功能也是通过在库函数的头文件里面搜索来完成的。\n\n2.3 动态 &#x2F; 静态链接 &amp; 库\n动态：linux(.so) windows(.dll)\n静态：linux(.a)  windows(.lib)\n\n网吧是全校所有同学共享的，你在网吧开的机子是和别人一起用的。从学校去网吧（库），然后获得一台机子（库函数），打游戏（执行方法）.这就是一个动态的编译链接的过程，即为  动态库。\n如果学校允许带电脑，当你想打游戏的时候用的是自己的电脑，用的是自己的方法，这种情况就是用的  静态库。每一个人拥有自己的电脑，这个电脑的功能和网吧里面的功能是一样的，当我们把库中的相关代码直接拷贝到自己的可执行程序中，即为静态链接\n\n动态链接：所有人共享同一个资源\n优点：可以节省资源；\n缺点：一旦库丢失，会导致所有程序失效\n\n\n静态链接：都用的是自己的方法，将库里面的代码拷贝到自己的文件中\n优点：不依赖任何库，程序可以独立运行\n缺点：浪费资源\n\n\n\n查看链接状态，默认是动态链接\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ ldd mytest    linux-vdso.so.1 =&gt;  (0x00007ffc0dd8b000)    /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f89bd66c000)    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f89bd185000)    libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f89bcf81000)    /lib64/ld-linux-x86-64.so.2 (0x00007f89bd553000)\n\n查看可执行程序的构成\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ file mytestmytest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7cf0ffacfdaeadf8de9b4c0fea379b2a15c37e4c, not stripped\n\n2.3.1 手动指定进行静态链接gcc test.c -o mytest1 -static\n静态链接生成的可执行程序大小很大，动态链接的默认是 8040 左右的体积。\n-rwxrwxr-x 1 muxue muxue   8416 Aug  7 07:34 mytest-rwxrwxr-x 1 muxue muxue 861288 Aug  7 07:44 hello\n所以一般情况下我们都推荐使用动态链接，避免占用太大的空间\n\n当我首次尝试这种方式的时候，出现了下面的报错\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ gcc hello.c -o hello -static/usr/bin/ld: cannot find -lccollect2: error: ld returned 1 exit status\n因为系统里面默认不会带 .a 的静态库，所以会报错。这时候需要我们手动安装一下。\nsudo yum install -y glibc-staticsudo yum install -y libstdc++-static\n安装成功！\nInstalled:  glibc-static.x86_64 0:2.17-326.el7_9                                                          Complete!\n这时候执行就不会报错了！\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ gcc hello.c -o hello -static[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ \n\n3.gdb 调试  默认生成的可执行程序是无法调试的！在 linux 里面发布的可执行程序默认是 release 版本的，无法 debug\n需要添加一个 -g 选项进行编译\ngcc test.c -o test_g -g\n同时 debug 版本的可执行文件也会比 release 版本大一些，这大的空间里面存放的就是调试信息\n-rwxrwxr-x 1 muxue muxue 8360 Aug  7 07:50 test-rwxrwxr-x 1 muxue muxue 9376 Aug  7 07:53 test_g\n\n利用下面这个语句可以查看可执行程序的调试信息\nreadelf -S test | grep debug\n可以看到 debug 版本包含了很多调试信息，而 release 版本里面没有\n[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ readelf -S test | grep debug[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ readelf -S test_g | grep debug  [27] .debug_aranges    PROGBITS         0000000000000000  00001061  [28] .debug_info       PROGBITS         0000000000000000  00001091  [29] .debug_abbrev     PROGBITS         0000000000000000  00001122  [30] .debug_line       PROGBITS         0000000000000000  00001164  [31] .debug_str        PROGBITS         0000000000000000  0000119f\n3.1 尝试调试一个简单的代码  以下是一些简单的 gdb 操作\nb 行号：打断点info b：查看断点d 断点编号：取消断点l 行号：显示代码l main：显示包含 main 的那一行r：run，开始运行程序, 跳到第一个断点r 参数 1 参数 2：运行程序的时候给程序传入命令行参数，跳到第一个断点s：step，逐语句，对应 vs 的 F11（进入函数）n：next，逐过程，对应 vs 的 F10c：continue，跳转道下一个断点p：查看变量display / undisplay：常显示 或 取消常显示until 行号：跳转到指定行finish：执行完一个函数后停下bt：查看函数调用堆栈signal 信号名：给当前正在调试的程序发送信号\n\n提醒：编译的时候记得加上 -g 选项指定 debug 版本\n下面是一个用于演式的示例代码\n#include &lt;stdio.h&gt;int Add(int a,int b)&#123;    printf(&quot;Add(a,b)\\n&quot;);    return a+b;&#125;int main()&#123;    printf(&quot;hello wolrd！\\n&quot;);    int ret=Add(1,20);    printf(&quot;ret: %d\\n&quot;,ret);    return 0;&#125;\n\ndebug 操作演示如下，命令是gdb 可执行文件名；\n[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ gdb test_gGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/muxue/GIT/raspi/vim/TestGdb/test_g...done.(gdb) l23       int Add(int a,int b)4       &#123;5           printf(&quot;Add(a,b)\\n&quot;);6           return a+b;7       &#125;89       int main()10      &#123;11          printf(&quot;hello wolrd！\\n&quot;);(gdb) b 11Breakpoint 1 at 0x4005a7: file test.c, line 11.(gdb) llUndefined command: &quot;ll&quot;.  Try &quot;help&quot;.(gdb) l 105           printf(&quot;Add(a,b)\\n&quot;);6           return a+b;7       &#125;89       int main()10      &#123;11          printf(&quot;hello wolrd！\\n&quot;);12          int ret=Add(1,20);13          printf(&quot;ret: %d\\n&quot;,ret);14          return 0;(gdb) b 13Breakpoint 2 at 0x4005c3: file test.c, line 13.(gdb) rStarting program: /home/muxue/GIT/raspi/vim/TestGdb/test_g Breakpoint 1, main () at test.c:1111          printf(&quot;hello wolrd！\\n&quot;);Missing separate debuginfos, use: debuginfo-install glibc-2.17-326.el7_9.x86_64(gdb) shello wolrd！12          int ret=Add(1,20);(gdb) sAdd (a=1, b=20) at test.c:55           printf(&quot;Add(a,b)\\n&quot;);(gdb) p retNo symbol &quot;ret&quot; in current context.(gdb) finishRun till exit from #0  Add (a=1, b=20) at test.c:5Add(a,b)0x00000000004005c0 in main () at test.c:1212          int ret=Add(1,20);Value returned is $1 = 21(gdb) sBreakpoint 2, main () at test.c:1313          printf(&quot;ret: %d\\n&quot;,ret);(gdb) p ret$2 = 21(gdb) p &amp;ret$3 = (int *) 0x7fffffffdf3c(gdb) sret: 2114          return 0;(gdb) s15      &#125;(gdb) qA debugging session is active.        Inferior 1 [process 5932] will be killed.Quit anyway? (y or n) y[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ \n整体的操作并不是特别复杂，大家可以自己尝试一番，有问题可以评论提出\n\n4.make&#x2F;makefile这是一个批量处理工具，我们可以通过 make 来批量编译一些代码，避免手动敲打命令行的出错问题。这在大型项目中非常重要。\nmakefile 是当前路径下的一个普通文件，存放了如下内容：\n\n依赖关系\n依赖方法\n\n假设我们需要形成一个 c 语言的可执行文件\n依赖关系：test -&gt; test.c依赖方法：gcc test.c -o test\n其对应的 makefile 如下\ntest:test.c    gcc test.c -o mytest\n注意，第二行的依赖方法必须 tab 缩进，不然无法正常调用！\n编写好 makefile 后，直接在当前路径下执行 make。系统会自动查找名称为 makefile&#x2F;Makefile 的文件执行\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ makegcc test.c -o test[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ ./testhello wolrd！Add(a,b)ret: 21\n\n我们还可以写一个清除指令，用于在编译后删除大量临时出现的可执行程序\n.PHONY:cleanclean:    rm -f test\n在原本的 makefile 后追加这部分内容即可\n通过 make clean 来清理文件\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ make cleanrm -f test[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test.c\n4.1 出现 missing separator 解决方案  当我执行 make clean 的时候出现了这个报错\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ make cleanmakefile:4: *** missing separator.  Stop.\n这是因为在我的 makefile 中，依赖方法前面的缩进是 4 个空格，而不是 1 个 tab\n注意需要使用 tab 进行缩进，而不能手动打空格！\n4.2make 如何判断需不需要重新生成？当我们在一个文件夹内执行过 make 之后，再次 make，系统会提示当前的可执行程序 test 已经是最新版本，无需更新。\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ makegcc test.c -o test[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ makemake: `test&#x27; is up to date.[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ \n\n那么系统是如何实别出来我们的原代码是否有过更改的呢？\n4.2.1 stat 时间戳  我们可以使用 stat 命令查看一个文件的时间戳\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test  File: ‘test’  Size: 8440            Blocks: 24         IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450818     Links: 1Access: (0775/-rwxrwxr-x)  Uid: (1001/   muxue)   Gid: (1001/   muxue)Access: 2022-08-07 17:18:40.463120772 +0800Modify: 2022-08-07 17:18:40.463120772 +0800Change: 2022-08-07 17:18:40.463120772 +0800 Birth: -[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test.c  File: ‘test.c’  Size: 201             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450788     Links: 1Access: (0664/-rw-rw-r--)  Uid: (1001/   muxue)   Gid: (1001/   muxue)Access: 2022-08-07 09:30:39.043992599 +0800Modify: 2022-08-07 09:30:38.544992699 +0800Change: 2022-08-07 09:30:38.544992699 +0800 Birth: -\n\n这里可以看到，一个文件的时间戳分为 3 个，分别是Access 查看、modify 修改，Change 更改。\n第一个查看很好理解，那么 modify 和 change 有什么区别呢？\n我们可以手动修改一个程序看看情况\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ vim test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test.c  File: ‘test.c’  Size: 207             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450788     Links: 1Access: (0664/-rw-rw-r--)  Uid: (1001/   muxue)   Gid: (1001/   muxue)Access: 2022-08-07 17:25:12.958082845 +0800Modify: 2022-08-07 17:25:12.808082859 +0800Change: 2022-08-07 17:25:12.808082859 +0800 Birth: -\n\n这里我通过 vim 进入该文件，添加了一行注释，可以看到，相比于之前的时间，3 个时间戳都被修改成了最新的时间。这是因为我们修改文件的时候一定会查看，也有 modify 和 change\n而如果我只是修改这个文件的权限，并不修改它的内容，会发生什么？\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ chmod o-r test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test.c  File: ‘test.c’  Size: 207             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450788     Links: 1Access: (0660/-rw-rw----)  Uid: (1001/   muxue)   Gid: (1001/   muxue)Access: 2022-08-07 17:25:12.958082845 +0800Modify: 2022-08-07 17:25:12.808082859 +0800Change: 2022-08-07 17:27:34.378068762 +0800 Birth: -\n\n可以看到，只有 change 发生了变化。\n文件 = 内容 + 属性 ，在这里的 modify 对应的就是内容修改，而 change 对应的是属性修改。而当我们修改文件内容的时候，会引起 文件大小  的变化，也是属性变化，所以修改内容也可能会引起 change 的变化！\n\n了解了这个时间戳，那么系统是怎么判断是否需要重新生成就很简单了：比较依赖关系中左边的目标文件和右边源文件的 modify 时间，如果源文件的 modify 时间  早于目标文件 ，那么说明目标文件生成之后， 源文件并没有发生更改，那么也无需再次生成\n4.2.2  PHONY 关键字的作用  在前面提到的 clean 代码中，我们使用了 .PHONY 关键字来修饰 clean。\n这个关键字让 clean 作为一个伪目标，且  总是被执行\n\n怎么理解这个总是被执行？\n\n当我们的源文件没有发生更改的时候，make 不会重新生成，这个叫做  总是不被执行\n\nPHONY 关键字的作用就是屏蔽系统对于 modify 时间的检查，每一次都会强制执行该语句的依赖方法。\n\n一般情况下我们只有在 clean 的时候才会使用 .PHONY 关键字来修饰\n4.3 $@ $^ 高级用法mytest:test1.c test2.c\tgcc -o $@ $^\n第一个 $@ 代表是左边的目标文件，$^代表是源文件，这样写可以实现全匹配，不需要自己一个一个写源文件了\n[muxue@bt-7274:~/git/linux/code/22-08-07_make_gdb]$ cat makefiletest:test.c add.c\tgcc $^ -o $@[muxue@bt-7274:~/git/linux/code/22-08-07_make_gdb]$ makegcc test.c add.c -o test[muxue@bt-7274:~/git/linux/code/22-08-07_make_gdb]$ ./test4\n\n4.4 定义变量\n4.5 命令行提供变量makefile 除了可以帮我们快速编译项目，有的时候我们还可以把一些常用的命令给写进去。比如打包压缩某一个目录的文件（备份）\ntar -zcvf ./.bak/code.tar.gz ./code\n\n上面这个命令的作用是，将 code 目录打包生成一个 code.tar.gz 压缩文件，放入到当前路径的 .bak 文件夹中。\n此时我的需求是给这个命令传一个参数日期，让生成的压缩包文件名能带上日期，makefile 可以这么写\n.PHONY:tartar:\ttar -zcvf ./.bak/code$&#123;d&#125;.tar.gz ./code\n\n这里留下了 d 作为一个参数，可以在执行 make 命令的时候指定\nmake d=230128\n\n这样操作了之后，打包压缩出来的文件名就会是code230128.tar.gz 完美达成目的！\n\n5. 尝试编写一个简单的 linux 进图条  当我们在 linux 系统上下载一些软件的时候，总是可以看到用文字组成的进度条，这些进图条是怎么做出来的呢？\n下面我们可以尝试用 C 语言写出一个简单的进度条。在这之前，我们需要了解一些概念\n5.1 缓冲区  在我之前的 C 语言文件操作 博客中，提到了一个缓冲区的概念。简单来说，当我们 printf 一道字符串的时候，系统是先把这个字符串写入缓冲区，再把缓冲区的内容输出到屏幕上\n比如下面这个代码，再 linux 环境中，\\n会自动刷新缓冲区。\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123;\twhile (1)\t&#123;\t\tprintf(&quot;hehe\\n&quot;);\t\t// 在 linux 环境中，不带 &#x27;\\n&#x27; 的时候，并不会打印（没有刷新缓存区）\t\t// 而在 VS 环境中，带不带都会正常打印\t\tsleep(1);//linux 环境中，sleep 函数的参数，单位是秒（VS 是毫秒）        //             linux 环境下，sleep 函数需要小写，VS 下是 Sleep\t&#125;\treturn 0;&#125;\n\n如果我们去掉\\n，系统则不会立即打印内容。\n\n这时候需要我们手动用 fflush(stdout) 刷新一下缓冲区，现在程序会在一行中打印了\nfflush(stdout);// 手动刷新缓冲区\n\n\n5.2 回车和换行  在我们日常生活中提到的换行一般指的是  回车 + 换行\n实际上，回车和换行是有区别的：\n\n回车：光标回到该行的最前面\n换行：光标去到下一行，但是位置不变\n\n在 C 语言中，\\n执行的就是  回车 + 换行 ，而\\r 是回车\n那么我们就可以利用这个特性，来实现一个简单的倒计时\n#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main()&#123;    int i=9;\twhile (i&gt;=0)\t&#123;\t\tprintf(&quot;%d\\r&quot;,i);\t\t// 在 linux 环境中，不带 &#x27;\\n&#x27; 的时候，并不会打印（没有刷新缓存区）\t\t// 而在 VS 环境中，带不带都会正常打印         fflush(stdout);// 手动刷新缓冲区\t\tsleep(1);//linux 环境中，sleep 函数的参数，单位是秒（VS 是毫秒）        //             linux 环境下，sleep 函数需要小写，VS 下是 Sleep        i--;\t&#125;\treturn 0;&#125;\n\n\n\n5.3 进度条  做好前面的准备工作后，现在我们就可以来打印一个简单的进度条了！\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define NUM 102#define STYLE &#x27;#&#x27;void process()&#123;    char bar[NUM];    memset(bar, &#x27;\\0&#x27;, sizeof(bar));    const char *lable = &quot;|/-\\\\&quot;;// 在末尾打印一个转动的“小圆圈”    int cnt = 0;    while(cnt &lt;= 100)    &#123;        // 默认是右对齐，使用 - 改位左对齐        printf(&quot; 加载中:%-100s[%d\\%][%c]\\r&quot;, bar, cnt, lable[cnt%4]);        fflush(stdout);        bar[cnt++] = STYLE;// 打印预定义的符号        usleep(200000);    &#125;    printf(&quot;\\n&quot;);&#125;int main()&#123;    process();    return 0;&#125;\n\n\n这样一个简单的进图条就搞定辣！\n后记linux 中一些工具的使用可能不会有 windows 的编译器那么方便，比如 GDB 调试。但是在后续编写一些只有 linux 平台才能运行的代码的时候，我们必须学会使用这些工具，否则操作起来会非常麻烦！\n感谢你看到最后，有任何问题都欢迎在评论区提出哦！\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】权限管理","url":"/posts/3787294814/","content":"Linux 部分的内容，我以权限管理作为起始。\n\n\n关于 Linux 命令行操作的部分，大家可以去网上搜搜，教程很多，且全面：【链接】。这里我就不再把相同的东西复述一遍了，毕竟 Linux 命令这种东西，你不会的时候可以去查，常见的命令敲多了肯定忘不掉\n不多说，开始 Linux 权限操作的内容吧！\n\n本篇博客所有演示均在 CentOS7.6 下进行\n\n\n[TOC]\n1. 什么是权限？权限是用于对用户进行约束的。正好比视频网站的 vip 一样，没有 vip 权限，你就看不到只有 vip 才能观看的影片。\n1.1 root 和 user在 linux 中，用户分为两种\n\nroot：超级用户\n其他：普通用户\n\n其中 root 用户的权限最高，可以在系统里面为所欲为。其所作操作在一定程度上会影响用户的使用环境。比如你在 root 里面安装了某个程序，那么所有子用户都可以使用这个程序，反之不行。\n在 root 用户中，你还可以通过 su user 这个命令切换到任何子用户而不用输入密码。但是从子用户切换到 root 则需要输入 root 用户的密码。所以，保证你的 root 用户密码不被他人知道是很重要的！\n\n2. 权限管理  本篇博客主要关注 Linux 中的文件权限\n2.1 文件访问者  在 Linux 中，文件访问者分 3 类，对于文件的权限也分 3 类\n\n\n\n访问者\n文件权限\n\n\n\n拥有者 owner\nr 读\n\n\n所属组 grouper\nw 写\n\n\n其他用户 other\nx 执行\n\n\n我们要怎么看一个文件对于这三位不同的访问者的权限有什么不同呢？\n使用 ll 或者 ls -l 命令即可看到区别\n\n这里文件的前缀，即标识了一个文件的对于 3 个角色的权限。\n其中 muxue 是文件的  拥有者 ，root 代表 所属组。\n2.1.1 linux 的组  这里需要说明一下，在我之前的  腾讯云多人一机  的博客中，是用下面这种方式创建子用户的👇\n\n这里就把子用户分到了 root 组下面，作用是让子用户可以通过 su 获得 root 权限\n如果你在创建用户的时候没有指定组的话，系统会自动创建一个  与用户名同名  的组。\n\n组有什么用？\n\n当在一个公司中，多人使用同一台服务器进行开发的时候，就需要通过组来对子用户进行进一步分类。即 A 组中其他用户（grouper）可以查看到子用户 A1 的代码，但是 B 组的用户（other）都看不到 A 组内的东西。\n这样就能实现多个小组开发不同的板块，而互不干扰。\n\n2.1.2 学会看文件前缀  说回正题，我们要怎么看一个文件夹 &#x2F; 文件的前缀呢？\ndrwxr-xr-x 5 muxue root    4096 7 月   3 11:56 code-rw-r--r-- 1 muxue root 1908226 2 月  23 2021 get-pip.pydrwxr-xr-x 7 muxue root    4096 6 月  26 08:10 GIT\n\n\n关于第一列的文件类型，有下面几种\n\n现在我们知道了文件权限的查看方式，要如何修改一个文件的特定权限呢？\n2.2 chmod 修改权限  我们可以使用 chmod 命令来修改文件权限\nchmod u-r test.txt\n\n上面这个命令的作用是，给拥有者去掉 test.txt 文件的 r 权限。可以用下面这个命令把权限加回去\nchmod u+r test.txt\n\n同理，如果你需要修改所属组和其他人的权限的话，指定 g 和 o 即可\nchmod g-r test.txt // 去掉所属组的 r 权限chmod o-rwx test.txt // 去掉其他用户的所有权限\n\n除了上面这种依次修改的方式，我们还可以用逗号隔开，用一条命令搞定\nchmod u+rwx,g+rwx,o-rwx test.txt // 给拥有者，所属组加上所有权限。去掉 other 的所有权限\n\n如果你想批量修改成同一个权限，还可以使用 a 来指定 all\nchmod a=rw test.txt\n\n\n2.2.1 以八进制修改文件权限  除了上面这个 + 和 - 比较好辩认的方式以外，我们还可以通过“八进制”的方式来修改文件权限。\n对于一个用户来说，拥有所有权限 rwx，如果我们将它与二进制进行对应，就会得到下面的结果\nrwx111二进制对应 7\n\n注意，这里的八进制并不是要通过八进制来读写权限的编码，而是用二进制来读取后，可得到最高权限 7（不会超过 7，所以是八进制）\n了解上面这个方式后，你便可以写出所有权限类型对应的编号\n\n\n\n权限\n二进制\n对应编号\n\n\n\nrwx\n111\n7\n\n\nrw-\n110\n6\n\n\nr-x\n101\n5\n\n\nr–\n100\n4\n\n\n-w-\n010\n2\n\n\n-wx\n011\n3\n\n\n–x\n001\n1\n\n\n当我们修改一个文件的权限的时候，就不需要用 a= 这种相对古板的方式。而可以通过编码来直接指定 3 类用户的不同权限\nchmod 777 test.txt // 给所有用户为 rwx 权限chmod 664 test.txt // 给 u 和 g 用户为 rw-，o 用户为 r--//……\n\n2.3 rwx 权限区别  修改完这些文件后有什么区别呢？\n当我们创建一个文件夹和一个常规文件时，作为拥有者，默认有文件夹的所有权限和文本文件的 rw 权限。\n\n2.3.1 常规文件  先来看看 test.c 的各种权限有什么不同吧！\n我们可以通过 cat 读取 test.c 文件的内容，这便是读权限 r\n\n而通过 vim、nano 等编辑器修改这个文件，就是写权限 w\n如果我们去掉 r 和 w 权限，就无法读，也无法写\n\n使用 nano 打开 test.c 文件，会有以下报错\n\n那么对于一个常规文件而言，x 权限有什么用呢？\n我们知道，当我们使用 gcc 等编译器编译代码文件时，会出现一个 a.out 可执行文件。这里的 x 便是可执行文件的标识。同时，这个文件也是用绿色标明出来了。\n\n如果我们给 test.c 也加上 x 权限，则它也会变成绿色，可以直接用 ./test.c 来执行。当然，直接执行一个 .c 文件是没有意义的\n\n2.3.2 文件夹（目录）\n在 Linux 下，一切皆文件。我们所说的目录也是一个文件\n文件 = 内容 + 属性\n在目录中保存的是文件的属性（包括文件名）我们想访问一个文件，首先要通过路径去找到这个文件。\n\n那么对于一个文件夹而言，rwx 权限又是什么呢？\n\n当我们使用 ls 的时候，其实是可以指定路径的，默认为.（当前路径）\n可以看到，现在显示出了 Mytest 中的 my.txt 文件。\n如果我们去掉文件夹的 r 权限，在执行 ls。就会报错权限不够\n\n得出结论，ls 查看某一个文件夹中的文件，需要拥有文件夹的 r 权限。即便你进入这个文件夹，如果没有 r 权限，依旧无法用 ls 显示文件夹里面的内容。\n但是这时候，我们还拥有文件夹的 w 权限，我们可以把其他文件拷贝到 Mytest 文件夹中\n\n把 r 权限加回来，可以看到 test.c 文件已经被拷贝进去了\n\n这便是 w 权限的作用，修改文件夹中间的内容。比如拷贝另外一个文件到文件夹中\n\n去掉 w 权限后，我们也无法删除文件夹中的内容\n\n最后，对于文件夹而言，x 权限代表的是能否 cd 进入该文件夹\n\n\n此时虽然我们无法 cd 进入，但我们拥有 rw 权限，可以直接从外部修改这个文件夹里面的内容，并进行访问吗？\n\n答案是 nope！不可以\n\n因为在 Linux 中，所有的操作都要通过路径来进行。路径也是访问文件夹的一个方式（需要 x 权限）此时因为无法 cd 进入该文件夹，也就无法通过路径访问这个文件夹的内容。所以没了 x 权限之后啥事都干不了\n当我们把 x 权限加回来之后，就可以这么做了\n\n\n如果对于目录只没有 r 权限，允许进入，可创建文件并写入内容，但不可读取其中内容\n如果对于目录只没有 w 权限，允许进入，允许在目录下 ls 查看文件列表，但不可以修改里面的文件\n如果目录没有 rw 权限，允许进入，但是不能修改也不能查看目录下的文件内容\n如果没有 x 权限，无法进入，也无法修改 &#x2F; 查看其中内容\n\n关于最后一点，不同系统的实现可能不一样。我的系统是CentOS7.6，请以你的实际情况为准！\n\n2.4 chown&#x2F;chgrp2.4.1 chown 修改拥有者  我们可以通过这个指令，把一个文件的拥有者修改为指定用户\nchown [参数] 用户名 文件名\n\n注意，在默认情况下，系统是不允许你修改文件的拥有者的。不过我们可以通过在语句前面加 sudo 的方式，短暂获取 root 权限，对文件拥有者进行修改\n\n这里如果提示不在 sudoer flis 里面，可以参考  博客  里面第八点的解决方案\n\n\n注意，这里我修改为了 root 用户，root 用户拥有最高权限！即便这是子用户的文件，root 用户也可以为所欲为进行修改和删除，不受任何权限的约束。\n如果我们把用户改成  其他子用户，其实这个子用户依旧访问不到这个文件。\n\n这就好比你告诉你的朋友，我要送你一个键盘。这个键盘的拥有者即将变成你的朋友。但是你没有把键盘给你朋友，键盘还在你家里，你的朋友依旧用不了这个键盘。\n\n换到 Linux 环境中，就是在 A 的用户路径下有一个 B 用户的文件。但由于 B 用户  无法访问 A 的用户路径，所以依旧无法访问到这个“属于 B 的文件”\n2.4.2 chgrp 修改所属组chgrp [参数] 用户名 文件名\n\n这里因为我的环境里面没有其他组，所以就不演示该功能的成果了\n\n\n2.5 关于默认权限Linux 中有一个默认权限：\n\n默认目录权限 777\n默认常规文件 666\n\n可为什么我创建的目录文件的权限是 755，而常规文件的权限是644 呢？\n\n这里我们可以用 umask 命令查看权限掩码\n\n这个权限掩码是什么意思呢？\n抛弃首位不看，后面的是 022。根据2.2.1 中提到的八进制方式，我们可以解读出这个权限为\n--- -w- -w-\n\n权限掩码的作用就是，在权限掩码中出现的权限，在实际创建文件的时候不会出现！\n仔细观察你就可以发现，这里我的文件夹权限如下，正好和掩码相反！\nrwx rwx rwx // 默认权限 777--- -w- -w- // 掩码 022rwx r-x r-x // 实际创建 755\n\n而常规文件的默认权限 666 是rw-rw-rw-，实际创建的结果也和掩码相反！\nrw- rw- rw- // 默认权限 666--- -w- -w- // 掩码 022rw- r-- r-- // 实际权限 644\n\n如何计算？这里的权限并不是简单的相减得出来的，其是通过  默认权限 &amp;(~umask)得出的\n\n先对默认权限的 umask 进行  按位取反\n再将取反后的结果和默认权限（目录 777，常规文件 666）按位  与得出\n\n2.5 file 命令  除了用文件属性的第一位来查看我们文件的属性之外，我们还可以用 file 命令来查看更加详细的文件属性\n\n当我们创建了一个 C 语言文件，并对他进行编译后，可以得到一个 C 的源文件和一个可执行文件\n\n常用选项如下\n-c 详细显示指令执行过程，便于排错或分析程序执行的情形-z 尝试去解读压缩文件的内容\n\n2.6 粘滞位  简单介绍，粘滞位就相当于给一个目录上了胶水，其他人无法删除被黏住的目录（和目录下的文件）！\nchmod +t test\n\n前面提到了，作为 other，你可以去访问别人的目录（只要other 有对应的权限）\n比如这里我用 \tmuxue 用户创建了一个 test1.c 文件，另外一个用户可以读取这个文件，但是不能写入\n\nvim 打开该文件会报错\n\n但这里有一个 bug 就是，即便你没有那个目录内文件的权限，你依旧可以删除这个目录下的文件！\n\n粘滞位的存在就是保护整个目录，不允许被其他用户删除！\n\n添加粘滞位后，可以看到在 Other 的权限处出现了一个大写的 T\n这时候我们再尝试用另外一个账户删除，就会报错——吗？\n\n以上就是一个明显的  错误  示范，粘滞位保护  只能在 root 下进行操作，而且粘滞位只能给目录上，并不能单独给一个文件上！\n\n给目录上了粘滞位后，再尝试删除，系统会报警告\n\n被保护后的目录，该  目录和目录下的文件  只能被下面的用户删除：\n\n超级用户 root\n目录的所有者\n该文件的所有者\n\n关于最后一点，虽然粘滞位保护了目录下的其他人的文件不能被你删除。但这不影响你在这个目录下创建 &#x2F; 写入 &#x2F; 删除你自己的文件\n\n结语  关于 linux 权限管理到这就结束啦！\nlinux 操作在未来找工作的时候非常重要，也是我们学习的时候和其他童鞋拉开差距的一环。\n\n因为很多人可能上完本科 4 年都不知道企业招聘的时候会考 linux 操作😥\n\n有什么问题可以在下面留言！看到了就会回复的\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】使用腾讯云搭建 CentOS 的 Linux 编程学习环境，实现多用户使用同一个云服务器","url":"/posts/656771008/","content":"为了帮助自己系统地学习 Linux 系统和命令行操作，我购入了腾讯云的轻量云服务器，预装了 CentOS7.6 系统\n\n\n本篇博客是一个笔记，记录了创建过程中遇到的一些问题，包括：\n\n云服务器多用户隔离使用（因为我的服务器是和同学一起拼购的）\ngit 仓库 ssh 密匙设置\n设置 Xshell 用户名的显示颜色\n\n\n感谢你关注  慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n以下是一个导读。其实不管是服主还是个人用户，都推荐使用以下阅读顺序\n\n如果你是服主，看本文的顺序是 1→2(其中 2.1 跳过)→6→8→4.1\n配置好环境并  下载好 git后，服主就不需要做其他什么的了，就和其他人一起看完本文👇\n如果你不是服主，只需要看 2.2.4 连接上你的账户，即可开始操作  第 3、4、5、7 点，可跳过 4.2 和 4.3\n\n如果你的 linux 是虚拟机安装的，也可以根据本文所教知识，进行 ssh 的连接和系统一些简单的配置的操作\n\n[TOC]\n1. 云服务器初始化  这部分 tx 云其实是有帮助文档的，但是它就是不在一个文档里面从头到尾写全，导致你需要翻来翻去找具体的操作，很恼火\n1.1 购买云服务器\n23.02.16 更新：当前学生优惠已经无了，请以官网实际价格为准，本文仅供参考\n\n选择腾讯云的理由很简单，现在它比阿里云便宜，2 核心 4GB 的版本只需要 168 一年（作为对比，同时期  阿里云没有打折，1 核 2GB 的版本 99 一年）\n\n腾讯云校园计划https://cloud.tencent.com/act/campus\n\n注意：如果你只买  一年 ，请不要购买下面的校园服务器！！！！ 购买校园服务器的资格只有一次，只买一年就花掉这个资格太不划算了！！！\n而且校园云服务器因为是“首单特惠”，是不支持  同价续费  的，续费价格也是天价！！！（续费要 900 多一年）\n\n在轻量应用服务器里面还有一个便宜的版本，2 核 2GB 只要 58 一年 ，但是那个 只能买一年，续费的价格很贵！！！\n\n如果要买 2-3 年，请购买上面的校园服务器\n如果只买一年，请购买下面的这个 58/ 年 的版本【链接】\n\n\n230312 更新：现在校园服务器似乎已经不支持购买多年了😂\n\n注册腾讯云账户并实名认证后，就可以正常购买。这里不赘述了。\n我选择的系统是CentOS7.6，这个系统非常适合我们初学 Linux\n\n\n1.2 控制台管理  创建完实例后，你应该就能在控制台里面看到你的云服务器了，右下角显示的是公网 IP，我们后续使用 Xshell 链接 的时候需要它\n\n进入后做的第一件事，就是充值你的 root 账户密码。建议设置的稍微复杂一点，一定要用小本本记下来！\n\n1.3 下载 Xshell我们需要用 Xshell 和 Xftp 作为我们的 linux 链接终端，点击官网链接下载\n\nhttps://www.xshell.com/zh/free-for-home-school/\n\n家庭和校园使用是免费的（个人用户）填了邮箱就可以了，官方会往你的邮箱里面发一个下载软件的链接\n完成上面三步后，现在已经可以连接我们的云服务器了！\n2. 连接云服务器 2.0 直接连接 root 账户 你可以先使用 root 的账户密码以及公网 ip 连接服务器\n\n输入公网 IP，端口号 22 不要改\n\n然后点击确认，系统会让你输入用户名和密码，使用用户名 root 和你刚刚设置的 root 密码就可以登录了\n\n还可以在 tx 云这里直接点登录，会使用 tx 云的默认账户 lighthouse 连接你的云主机\n\n\n\n这个方法只适合基础使用，下面讲解两个不同的方法\n\n\n2.1 使用 SSH 密钥  因为 Xshell 比较聪明，会帮我们记住账户密码，自动输入。但是在很多软件（比如 putty）每次开启连接都需要输入账户和密码。这时候我们可以使用更加安全的加密 SSH 方式连接我们的终端\n\n如果你想达到多人一机的目的，请跳过本步骤，直接看2.2\n\n2.1.1 创建本地密钥  在 Xshell 的选项卡中，新建一个密匙\n\n无需修改默认参数\n\n这里会让你输入密匙名称和密码，请记住这里的密码！如果忘记了就只能重新生成一个密匙了\n\n\n生成完毕后，点击  用户密匙管理者\n\n找到刚刚生成的密匙，点击  属性 - 公钥，把这里的内容复制下来\n\n2.1.2 绑定实例  然后来到 tx 云控制台，密钥，点击创建密钥\n\n选择已有公钥，把刚刚复制的内容丢进去并起个名字。注意这里的地域必须和云服务选择的相同！\n\n搞定后，在云服务器的  密钥对  界面中绑定密钥（需要先把云服务器关机）\n\n绑定成功后，重启云服务器\n2.1.3Xshell 会话设置  新建一个会话，这里同样填公网 ip\n\n然后需要设置  用户身份验证 ，这里很重要！Xshell 提示“ 密钥没有和云服务器绑定”都是因为这里没有设置！\n\n选择你创建的本地密匙，输入  创建密匙  时的密码！\n\n不出意外，设置完毕后，你就可以免登录连接到云服务器的 root 用户了\n\n这个方案只适用于  单用户使用，如果多个用户想用这个方法连接同一个云服务器，就会出现大家一起用一个文件路径的问题（就比如我和同学拼，大家都用 SSH 连接了 root 用户，白搞）\n\n目前我没找到如何用 SSH 密匙连接到云服务器指定用户下\n\n2.2 使用账户密码登录实现多人一机Linux 系统是可以实现多用户管理的，首先我们要创建一个新的用户\n\n参考https://cloud.tencent.com/developer/ask/24465\n\n2.2.1 创建新用户  先用 root 连接终端，输入下面的命令\nuseradd 用户名\n\n上面这个命令会建立一个新的用户和同名用户组，用户名自定义;\nuseradd -g root 用户名\n\n这个命令的含义是在 root 分组下（这个是 root 用户默认的分组）创建一个用户。如果没有什么特殊的需求，没必要指定用户组为 root，用第一条命令直接添加用户就可以了\n\n使用下面的命令设置刚刚创建的用户的密码\npasswd 用户名\n\n随后，使用下面命令测试进入另外一个用户\nsu - 用户名\n\n因为我们是从具有最高权限的 root 用户进入子用户，所以是不需要输入密码的，但是如果你从子用户往 root 跑，就需要输入 root 用户的密码！\n\n你可以在 root 用户和子用户终端下用 mkdir 文件夹名字 创建两个不同的文件夹，ls查看当前路径下的文件夹\n你会发现，root 和另外一个用户直接是相互看不到对方的文件夹的，这就是我们要达到的  隔离  效果！相当于互不干扰！\n从  子用户 A跑到  子用户 B中，需要  输入子用户 B 的密码。\n这需要 root 用户在里面创建新的用户。在 root 里面设置过子用户密码密码后，后续可以修改子用户密码👇\n2.2.2 修改密码  实际上，在自己的用户名下，是可以更改当前用户名的密码的\npasswd\n\n\n所以可以让服主创建好用户后，自己登陆进去，把自己的密码改掉\n\n注意：Linux 学习中有时候会有一些指令只有 root 用户能干，所以最好是不要那么在乎这些“隐私问题”，root 也公开给大家使用就行了\n\n一般情况下，直接在某一个语句之前加sudo，就会用上 root 权限\n2.2.3 腾讯云多用户管理  另外，腾讯云支持多用户管理，你可以在用户组这里邀请其他人，他们就能在自己的控制台里面看到你的云服务器了\n\n\n2.2.4Xshell 使用账户密码连接  这时候我们就不能使用 2.1 所用的 ssh 密钥登录了，而是使用账户和密码\n\n使用这个方式前，需要在云服务器控制台解绑所有 SSH 密钥\n\n刚开始直接连接会显示“SSH 服务器拒绝了密码”，这是因为我们没有开启允许密码登录\n\n\n参考https://cloud.tencent.com/developer/article/1909909\n\n在 root 用户下，使用 vim 打开下面这个文件。如果你不会使用 vim 编辑器，请见本文的第三点\nvim /etc/ssh/sshd_config\n\n在最后添加下面的这个语句，:wq!保存并退出\nPasswordAuthentication=yes\n\n\n搞定后，重启云主机，即可用账号密码登录其他账户\n\n如果设置了这个还是不行，可以在控制台中直接重置 root 密码。重置密码的时候会自动帮你设置好这个（如果没有就再手动设置一下，哈哈）\n\n\n系统内配置好后，在 xshell 中新建会话，填入如下的内容\n\n在 Xshell 中直接用对应的  账户和密码登录，就可以打开每个单独的账户\n\nX11 警告是正常现象，请忽略它\n\n到这里，你就可以和好基友分享这个服务器了！成本大大降低\n2.3 查看当前使用云服务器的用户  在 Xshell 终端中输入who，可以查看当前有谁连接了云服务器\n这里会显示连接云服务器的  时间 ，pts 代表远程连接，/2代表不同的远程连接窗口\n\n\n3. 一些基本的 Linux 指令  之前写博客的时候，忽略了大家可能都是第一次上手 linux，对 linux 命令行一窍不通的。有朋友反应后面的 git 操作，很多部分都搞不明白怎么用\n这里列出本篇博客需要用到的一些 linux 指令和 vim 编辑器的指令。注意，这个只是帮助你完成本篇博客向导后续的 git 设置，并不是一个完整的命令行教学。建议自行搜索 git 命令行以及 Linux 命令行进行学习\n3.1Linux 指令ls # 显示当前路径下的所有文件ls -a # 显示当前路径下包括隐藏文件的所有文件cd 文件路径   # 打开对应文件路径cd ..   # 回到上一个文件目录cd ~   # 回到用户的根目录touch 文件名  # 创建对应的文件mkdir 文件夹名字 # 创建一个文件夹mv 源路径 目标路径 # 移动文件夹或者文件#mv 语句还用于重命名文件，操作是mv 原来的名字 新名字cat 文件名字  # 显示对应文本文件的内容# 如 cat .gitconfig，会显示.gitconfig 文件中的所有内容\n\n下图演示了部分语句，能帮助你理解这些命令的作用\n\n如果你不小心输错了某些指令或者指令没输入完毕就按了回车，可以使用 ctrl+c 终止当前操作，linux 会另起一个新的入口给你输入命令\n\n3.2vim 编辑器操作vim 文件名 # 打开对应的文件进行写入\n\n这里我直接以编辑一个 C++ 程序为例，演示 vim 的操作\n\n打开后是这样的，因为你的 vim 编辑器还没有设置（见本文第 5 点），所以和我的不一样，但是这不影响我们的操作。\n注意左下角是 vim 指令输入的位置以及 vim 当前模式的提示位置\n\n现在往这个文件中键入内容，你会发现无法键入，这是因为 vim 是查看模式，我们需要在  英文模式下  按键盘上的的i（中文模式按 i 是没有反应的）开启 vim 的插入模式（也就是 insert 模式）\n\n开启插入模式后，你就可以往这个文件里面写入内容了。注意 vim 编辑器是基于键盘的，你需要用键盘方向键定位位置，而不是用鼠标\n\n我往文件中新增了 c++ 语法的内容，现在我想保存这个文件，并退出 vim 编辑器\n操作是先在英文模式下  按键盘的 ESC 退出插入模式 ，然后输入:wq 保存并退出文件\n\n这就回到了之前的 linux 命令行界面\n\n下面给出一些常用的 vim 指令，后续配置 git 的时候会用到\n:w  # 保存文件，相当于 windows 的 ctrl+s:q  # 退出文件，前提是这个文件没有被更改# 如果你不想保存刚刚的更改，可以使用:q! # 强制退出文件:wq # 保存并退出文件:wq! # 因为部分文件是配置文件，系统权限不够，所以需要加! 绕开# 后续在编辑 gitconfig 文件的时候，就需要使用:wq!\n\n\n如果你想从 windows 中复制内容，粘贴到终端中，需要使用 shift+ins 键而不是使用ctrl+v\n复制ctrl+ins，粘贴 shift+ins\n如果你不小心习惯性地按了 ctrl+s 并发现系统卡住了，那是因为这个快捷键在 Linux 中是暂停终端，可以按 ctrl+q 复原\n\n上面讲述了 vim 的一些操作，下面让我们来尝试一下编一个代码\n3.3 尝试编译代码 C++ 需要使用g++ 编译器来编译代码，如果是 C 语言内容，则使用 gcc 来编译，操作是一样的\n以下面的指令编译我们刚刚写的代码文件，生成可执行文件 TEST\ng++ test.cpp -o TEST\n\n可以看到编译器报错了，我们再 vim 回去修改代码\n\n修改完毕后，重新编译我们的代码，可以看到没有报错，生成了可执行文件 TEST\n\n使用 ./TEST 语句运行可执行文件 TEST，即可看到程序输出结果\n\n好了，学会这些后，你应该就能完成后面 git 的配置操作了！😋\n\n4.Linux 的 git 设置  这里我们使用账户密码方式来配置我们的 git，因为 ssh 密钥的方式出现了些许 bug\n4.1 下载 git输入下面的指令查看 git 的版本，如果没有出现，那说明 git 没有被安装\ngit --version\n\nCentOS使用下面的指令安装，必须使用 root 用户 。其他 LINUX 系统（比如 ubuntu）需要把yum 改成apt-get\nsudo yum install git\n\n\n因为我之前用了树莓派，使用的是apt-get。在这上面不管用，我还去搜了好久为啥sudo: apt-get: command not found😥\n后面才知道 CentOS 使用的方法不一样\n4.2 创建 SSH 密匙  如果你想学习 SSH 的方式使用 git，那也可以试试👉传送门\n\n注：如果你是 github 用户，且使用 https 的 git 仓库链接 时，多次遇到各种各样的无法连接问题，则需要切换使用 ssh 方式与 github 通信！这能解决 https 链接时部分类似 time out 的网络问题\n\n\n4.3 使用账户密码方式操作 git其实在配置之  前，我也不知道 git config 可不可以实现多用户独立上传，但是我知道 SSH 肯定是可以，这点也验证过了。\n我更推荐你使用 4.2 所提到博客中 ssh 的方式操作 git，这样会更方便！\n4.3.1 配置全局 git 设置  直接使用下面 3 个语句来设置某个 Linux 用户下的  全局git 邮箱和用户名\ngit config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;git config --global push.default current\n\n测试了一下 --global 指令后，发现它保存的文件是我们  用户路径  下的，而  不是 root 下的全局目录。经过我和同学的测试，这个配置会一直保留，并不会因为终端关闭而失效\n在用户的 ~ 家目录，使用下面这个指令可以查看 git 配置文件的内容，每个不同的 Linux 用户中，配置文件互不影响！\ncat .gitconfig \n\n\n使用 SSH 的好处是不需要输入密码，不过我们可以用 git 指令来让 git 保存你的密码，这样也能在之后的上传中不需要输入密码，操作是编辑 .gitconfig  文件，在最后加上这两行；\n作用是在下一次执行 git push 操作的时候，保存用户名和密码\n[credential]          helper = store\n\n使用 vim .gitconfig 修改后的配置文件应该和我这个相同\n[user]\temail = 你的 gitee/github 邮箱\tname = 用户名[push]\tdefault = current[credential]\thelper = store\n\n\n4.3.2 克隆和上传操作  使用 mkdir 文件夹名 创建一个文件夹，cd进去后，执行 clone 工作，这时候需要使用的是 HTTPS 链接\n\ngit clone 远程仓库的 https 链接\n\n\n如果你之前使用了 SSH 克隆了仓库，可以考虑重新克隆，也可以使用下面的语句更改仓库 URL，注意这里的 URL 是 新的仓库 git 地址\ngit remote set-url origin URL \n\ncd进入仓库目录，即可修改仓库中的文件\n\n修改完毕后，先用 git status 查看当前状态\n\n可以看到这里列出来我们的 README 文件 被修改了，下面执行一次 git push 操作。这部分涉及到 git 命令行操作，如果你不会，可以搜几篇 git 的博客学习一下\ngit add 文件夹 # 添加需要上传的文件路径git commit -m &quot; 输入 push 信息 &quot; #git push 的信息\n\n这里的 git add 可以添加单个文件，也可以添加整个文件夹\n\ngit push # 和远程仓库同步\n\n最后 git push 的时候，会提示让你输入远程仓库的用户名和密码\n我同学尝试的时候，这里出现了报错。本来我们以为是  用户名或者密码有问题，一直在找到底是哪里出错了\nfatal: Authentication failed for &#x27;https://gitee.com/……&#x27;\n\n实际上是因为我们填错了！！！链接\n\n正确的填写方法应该是这样！！！我们  错误的把第一个填了 gitee 的用户名 ，应该要填写的是 gitee 账户的 邮箱\nUsername for &#x27;https://gitee.com&#x27;: 你的 gitee 邮箱Password for &#x27;https://xxxxx@gitee.com&#x27;: 填 gitee 密码\n\n注：这里填写密码的时候是  不会显示内容的，直接盲打就可以了\n修改正确之后就可以正常 PUSH 代码了\n\n经过  我和同学的测试 ，这个方法 不会  因为终端关闭而重置，可以多次复用且不需要每次都输入 git 的账户和密码，计划通！\n你还可以看看 git 命令行语句的进阶学习👉传送门\n4.4 git status 乱码  一条命令解决\ngit config --global core.quotepath false\n\n修复前\n&quot;project/Library_c/Student - \\345\\211\\257\\346\\234\\254.txt&quot;\n\n修复后\nproject/Library_c/Student - 副本.txt\n\n\n5.vim 编辑器配置  腾讯云的 CentOS 已经默认安装了 vim 编辑器，但是 vim 编辑器本身的默认设置和我们的习惯不同，比如 tap 它默认是 8 个空格（windows 下是 4 个）以及缩进的一些问题，这就需要我们自己设置一下 vim 编辑器\nvim  ~/.vimrc\n\n用上面的语句打开 vim 编辑器后，用 i 开启 vim 的插入模式，输入下面的命令\nsyntax on # 开启语法高亮set nu  # 显示行号set tabstop=4 # 设置 tap 为 4 个空格set softtabstop=4 set shiftwidth=4 set autoindent # 自动对齐\n\n写完后，:wq!保存即可\n这里我给出了注释，实际写入配置文件的时候，请去掉注释\n6. 将 Linux 命令行设置为中文  以CentOS为例，默认的命令行显示是全英文的（但这不代表你不能在里面设置中文的文件夹名字）我也更推荐大家采用英语的终端来学习 linux，因为绝大多数 linux 下的终端工具，都是以英语作为工具的命令教程的。\n\n实在看不懂，就用翻译软件读读，后来看得多了，就熟悉了！\n\n我们打开云服务器的root 账户（必须是 root 账户）\nlocale\n\n使用上面的这个指令查看现在的语言，发现是 en 英文\n\nlocale -a\n\n使用上述命令查看  当前支持的语言，会显示一大堆，滑到最底部，可以看到我这个系统里面已经有了zh-CN，支持中文！\n\n\n如果 locale -a 发现没有出现 zh，那就下载中文支持包\n&gt;yum install kde-l10n-Chinese\n\n腾讯云的 CentOS 里面已经有中文了，所以不需要进行这一步操作\n\n\n修改系统语言为中文\nlocalectl set-locale LANG=zh_CN.utf8\n\n重启 Xshell 终端（不是重启云服务器），再次使用 locale 指令查看，发现已经设置成了中文语言包\n\n重启 Xshell 终端（不是重启云服务器），就可以看到，git 这里的提示已经变成了中文。不然就是上文出现过的的英文页面👉回到上头康康\n\n修改 Xshell 中文显示字体  如果你觉得默认的中文字体很难看，可以在 Xshell 中修改一下，点击左上角的  文件 - 当前会话属性\n\n找到  外观，把亚洲字体改成黑体，看起来就舒服多了\n\n这里还可以更改  游标  的样式，我改成了在 windows 中更熟悉的  竖线  样式\n7. 设置命令行用户名的显示颜色\n参考 https://blog.csdn.net/nmb_jiang/article/details/105195981\n\n默认情况下，Xshell 显示的服务器用户名和名字都是白色的\n\n敲的命令多了之后，就分不清啥是啥了，眼睛都得瞎掉\n我们可以设置一下，以 CentOS 为例，需要用 vim 编辑器打开 .bashrc 文件\nvim .bashrc\n\n在打开的文件中，键入 i 开启 vim 的编辑模式，在文件的末尾输入\nPS1=&#x27;[\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]]\\$ &#x27;\n\n输入完毕后，按 esc 退出插入模式，输入 :wq! 保存该文件\n\n顺带一提，如果你和我一样用的是 tabby 这个 ssh 终端，则还可以在末尾追加如下内容实现检测工作路径（方便 sftp 传文件）\n&gt;PS1=&quot;$PS1\\[\\e]1337;CurrentDir=&quot;&#x27;$(pwd)\\a\\]&#x27;\n\n修改好退出后运行下面的指令使其生效\nsource .bashrc\n\n\n看起来就舒服多了！\n另外，建议把 root 改成黄色 + 绿色的组合，和子用户区分开来。修改的方法是一样的\nPS1=&#x27;[\\[\\033[01;33m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;32m\\]\\w\\[\\033[00m\\]]\\$ &#x27;\n\n如果不想显示 host 主机的名字，可以把中间部分给删除了\nPS1=&#x27;[\\[\\033[01;33m\\]\\u\\033[00m\\]:\\[\\033[01;32m\\]\\w\\[\\033[00m\\]]\\$ &#x27;\n\n这样配置后的显示效果如下，更简洁\n[muxue:~]$\n\n8. 出现 is not in the sudoers file 解决方法\n当我们使用 sudo 命令切换用户的时候可能会遇到提示以下错误：用户名 is not in the sudoers file.\n\n我们需要把当前用户加入 sudo 的配置文件中\n在 root 用户下，打开 sudo 的配置文件\nvim /etc/sudoers\n\n打开这个文件，你会发现腾讯云的默认用户 lighthouse 已经添加过这个语句了。我们在最后加上xxx ALL=(ALL) ALL，其中 xxx 代表用户名\n比如需要添加 KK 用户，就这么填\nKK ALL=(ALL) ALL\n\n\n9. 删除用户  如果有用户的名设置错了，或者想  彻底删除  掉某一个用户，可以用下面的命令\nuserdel -r 用户名\n\n结语  看到这里，云 Linux 编程学习环境就搭建好啦！\n速速开始学习 Linux 命令行吧！👍\n\n\n有什么问题可以在评论区提出哦！\n\n","categories":["玩上Linux"],"tags":["Linux","git"]},{"title":"【Linux】进程概念","url":"/posts/3785030062/","content":"本文演示所用系统为CentOS 7.6\n\n\n1. 操作系统  操作系统是不会直接对用户提供服务的。因为这样会暴露自己的底层实现，对系统稳定性造成了威胁\n\n操作系统是通过  系统调用层  的方式对外提供接口服务的。\n\n这就好比你是通过前端按钮来使用一个网站的功能，而通常你是看不到网页的后端实现的。\n\nLinux 系统的底层是用 C 语言写的，所以这些接口服务本质上就是一些 C 语言的函数。这些函数用于操作系统的各种管理。\n我们学习 Linux 的系统编程，本质上是在学习这些和系统对接的函数。\n1.1 编程语言和系统对接  不同的操作系统，其提供的各种管理硬件的函数是不同的。这时候我们的 C&#x2F;C++ 等其他语言想和系统对接（如 printf 打印到屏幕上）就需要在底层帮用户管理好这些系统接口的调用。当我们使用这些语言的时候，就不需要自己手动去调用\n1.2 描述进程 -PCB\nPCB 并不是那些绿油油的电路板，这里指的是process control block\n\n进程是有一个担当分配系统资源（CPU 时间，内存）的实体\n\n进程信息被放在一个叫做  进程控制模块  的数据结构中，可以理解为进程属性的集合\n在 Linux 中的 PCB 其实就是一个结构体task strcut，包含了这个进程的各种信息。\n\ntask_struct的内容大家可以上网搜搜，能力强的朋友可直接去看 Linux 的源码。\n1.3 组织进程  我们可以在 Linux 的源码中找到组织进程的方式。所有运行在系统里面的进程都是以 task_struct 为成员的  链表  形式存在内核中。下面是关于这个结构体的一部分解析\n\n\n标示符: 描述本进程的唯一标示符，用来区别其他进程\n状态: 任务状态，退出代码，退出信号等。\n优先级: 相对于其他进程的优先级。 \n程序计数器: 程序中即将被执行的下一条指令的地址。 \n内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针\n上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图 CPU，寄存器]。\nI／O 状态信息: 包括显示的 I&#x2F;O 请求, 分配给进程的 I／O 设备和被进程使用的文件列表。 \n记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。 \n其他信息\n\n\n相关解析可以看看这篇博客【传送门】\n1.4 查看进程 1.4.1 ps 命令 可以用 ps 命令来查找进程信息。下面这个指令是显示所有的进程\nps axj\n\n系统会打印下面的很多进程信息，这就好比 windows 下的任务管理器\n\n如果我们使用一个 while(1) 的死循环函数，运行的时候就变成了一个进程了。我们可以用下面的命令来查找特定的进程信息\nps axj | grep test\n\n\n上图中我们搜索 test，出现了两个进程。第一个进程很明显是我们运行的可执行程序。那么第二个是什么呢？\n\n实际上，所有的指令都是一个进程。只不过 ls 这种类型的命令很快就能执行完毕。\n\n这样一来，我们便可以确认，出现的第二个进程实际上是我们执行这条搜索语句出现的。可以用下面的这个指令来屏蔽 grep 的结果，只显示我们自己的那个程序。\nps axj | grep test | grep -v grep\n\n最后一个指令的意思是忽略掉包含 grep 的结果，现在就不会显示第二个 grep 的进程了\n\n1.4.2 proc 目录  还可以通过 /proc 系统文件夹来查看系统进程信息。这里面的内容都是一个实时的进程信息\n\n每一个进程都有一个自己的PID(process id)，用来标识唯一的进程\n可以用下面的这个指令来显示一个提示信息，其中的 &amp;&amp; 代表逻辑与，只有第一个命令执行成功，才会执行第二个命令\nps ajx | head -1 &amp;&amp; ps ajx | grep test | grep -v grep\n\n\n这里就告诉我们了这个命令的 PID 是什么，即第 2 位数字\n\n如果你需要查看 PID 为 1 的进程，则打开对应进程的文件夹\n\n上面我们搜到的进程 PID 为5408，查看对应文件夹可以看到下面的内容\n\n当我们关闭了 ./test 进程在去查找，会发现没有这个路径了\n\n在每一个进程文件夹中都有一个 cwd 和exe\n\ncwd其指向的是进程当前的工作路径\nexe指向的是进程对应可执行程序的磁盘文件\n\n比如现在我使用 ps 命令查找到了下面这个 python 代码进程\n\n使用 ls -l /proc/19423 命令打开对应文件夹，便可以看到 cwd 和exe的指向\n\n这代表该进程是用 python3.10 进行执行的，其工作目录为 cwd 指向的路径\n\npid、工作路径等等信息都存放在进程的 task_struct 中\n\n1.4.3 C 语言代码获取 ppid 和 pid除了在命令行中输入命令以外，我们还可以通过 C 语言代码中和系统通信的库函数来获取当前进程的ppid 和 pid\n#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123;    printf(&quot;pid: %d\\n&quot;, getpid());    printf(&quot;ppid: %d\\n&quot;, getppid());    return 0;&#125;\n\n\n使用一个 while(1) 循环，我们就可以看看这个进程是否和我们用 ps 搜出来的结果相同\n\n\n可以看到，搜寻出来的结果和该程序自己打印的结果是一样的\n实际上，我们所有在命令行上执行的程序，都是bash（即当前命令行）的子进程\n\n1.5 fork 通过系统调用创建父子进程  如果你用过 gitee 或者 github，想必对 fork 并不陌生。在 git 托管网站上，我们 fork 别人的仓库，便会在自己的账户中出现一个别人仓库的“子仓库”。我们可以在这个“子仓库”里面修改一部分信息，再创建一个 pull request 合并入被 fork 的仓库\n而在 Linux 系统中，fork 的作用便是可以创建一个父子进程，这两个进程  相互独立，且有很多特殊的地方等着我们的探索\n比如：fork 具有  两个不同的返回值！\n下面是一个示例代码\n#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123;    pid_t id = fork();    //id=0 子进程；&gt;0 为父进程    if(id == 0)    &#123;        //child        while(1)        &#123;            printf(&quot; 子进程，pid: %d, 父进程是: %d\\n&quot;, getpid(), getppid());            sleep(1);        &#125;    &#125;    else&#123;        //parent        while(1)        &#123;            printf(&quot; 父进程，pid: %d, 父进程是: %d\\n&quot;, getpid(), getppid());            sleep(1);        &#125;    &#125;&#125;\n\n运行上面的代码，你会发现父子进程竟然交叉运行了！而且这两个进程都有不同的 pid。其中子进程的 ppid 即为父进程的pid！\n\n奇怪，我们的 while 循环明明是写在 if 里面的啊？为什么 else 里面的 while 也被正常执行了呢？\n1.5.1 man fork这便需要我们了解一下 fork 到底是何方神圣了。\nman fork\n\n\n如果你出现 No manual entry for fork 的报错，在 CentOS 下请尝试执行下面的命令\nsudo yum install -y man-pages\n\n\n同时可以看到关于 fork 的返回值的描述\n\n这便能告诉我们，为啥 fork 下方同一个 id 值使用打印会返回不同的结果；以及 if else 被交叉运行的原因。\n\nfork 之后，父子进程共享代码，都会执行后面的 if else 语句\nfork 之后，父子进程的返回值不相同，所以 if else 语句进入的模块也不相同\n\nfork 进程给父进程返回  子进程 pid，方便父进程管理自己的子进程。这是因为父进程必须要有标识子进程的方法！\n\n一个父亲可以有多个孩子，需要 pid 来进行管理\n一个子进程只能有 1 个父亲，所以用 0 来标识子进程创建成功即可。它可以用 ppid 方便的找到自己的父进程。\n\n1.5.2 fork 做了什么fork 会调用系统的OS system call，创建一个子进程\n\ntask_struct + 父进程代码和数据\ntask_struct + 子进程代码和数据\n\n子进程的代码和数据大多数都是  从父进程继承  下来的，不过 pid 和 ppid 肯定不会继承。其内部的  变量 / 数据  和父进程独立（这个后续的博客会涉及）\n\n当 fork 创建好子进程并进行 return 的时候，它的功能就已经完成了\n此时还会将  子进程  放入  运行队列\n\n了解了这个之后，再来理解一下进程是如何被运行的👇\n2. 如何理解进程被运行  在我们的系统中，每一个 CPU 都有一个  运行队列\n这个运行队列之中存放的便是task_struct，系统会依次运行每一个进程。\n\n在上面我们的 fork 创建子进程之后，便会把子进程放入运行队列\n\n所以实际上，fork 并不是有两个返回值，而是在先运行了父进程后，又创建了一个子进程。这两个进程共享代码，而且它们都是挂载在同一个 bash 命令行上，才会出现上述交替打印的情况。\n\n结语  下篇博客是有关  进程状态  的内容，阿巴阿巴，好久没写博客了\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】进程地址空间","url":"/posts/1845419185/","content":"本篇博客来认识一下 linux 下程序地址空间的概念\n\n\n\n演示所用系统：CentOS 7.6\n\n[TOC]\n1. 引入程序地址空间  之前学习 C/C++ 的时候，多少应该都听过栈区 &#x2F; 堆区 &#x2F; 静态区 &#x2F; 全局区的概念，还有一张很经典的演示图，大部分讲解这几个内存区域的图片都和下图类似\n\n但是有一个问题，这里的程序地址空间，是我们的物理内存上的东西吗？\n并不是！\n\n程序 &#x2F; 进程地址空间是操作系统上的概念，它和我们物理内存本身不是一个东西\n\n\n1.1 验证不同区域  用下面这个代码来简单验证一下不同区域上的区别\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int un_global_val;// 未初始化全局变量int global_val=100;// 已初始化全局变量//main 函数的参数int main(int argc, char *argv[], char *env[])&#123;    printf(&quot;code addr         : %p\\n&quot;, main);    printf(&quot;init global addr  : %p\\n&quot;, &amp;global_val);    printf(&quot;uninit global addr: %p\\n&quot;, &amp;un_global_val);    char *m1 = (char*)malloc(100);    char *m2 = (char*)malloc(100);    char *m3 = (char*)malloc(100);    char *m4 = (char*)malloc(100);    int a = 100;    static int s = 100;    printf(&quot;heap addr         : %p\\n&quot;, m1);    printf(&quot;heap addr         : %p\\n&quot;, m2);    printf(&quot;heap addr         : %p\\n&quot;, m3);    printf(&quot;heap addr         : %p\\n&quot;, m4);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m1);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m2);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m3);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m4);    printf(&quot;stack addr a      : %p\\n&quot;, &amp;a);    printf(&quot;stack addr s      : %p\\n&quot;, &amp;s);    printf(&quot;\\n&quot;);    for(int i = 0; i &lt; argc; i++)    &#123;        printf(&quot;argv addr         : %p\\n&quot;, argv[i]);    &#125;    printf(&quot;\\n&quot;);    for(int i =0 ; env[i];i++)    &#123;        printf(&quot;env addr          : %p\\n&quot;, env[i]);    &#125;    return 0;&#125;\n\n\n通过上面的测试，可以看到其结果和文章最开始的那张图相同。这里解释一下  向上 / 向下  的含义\n\n向上增长：向地址增大的方向增长\n向下增长：向地址减小的方向增长\n\n不过那个图片内部还少了一些东西，比如命令行参数和环境变量其实是存放在栈区之上的。补全之后的图片如下\n\n其中我们还可以发现，栈区和堆区之间有非常大的内存空隙\nheap addr         : 0x1a140f0heap addr         : 0x1a14160stack addr        : 0x7ffe6671ec60stack addr        : 0x7ffe6671ec58\n\n因为在 C&#x2F;C++ 中定义的变量都是在  栈上保存的，栈向下增长，先定义的变量地址较高！\nint a = 100;static int s = 100;\n\n关于函数中 static 修饰的变量，可以看到其地址空间属于全局静态区。虽然在函数中用 static 修饰是限制其只能在该函数内访问，但是该变量的声明周期是跟随整个程序的！\nstack addr a      : 0x7ffe6671ec44stack addr s      : 0x601048\n\n说了这么多，我们也没看看出来程序地址空间在哪儿啊？\n1.2 fork 感知地址空间的存在  下面可以用一个简单的 fork 代码来确认程序地址空间的存在！\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    int test = 10;    int ret = fork();    if(ret == 0)    &#123;        while(1)        &#123;            printf(&quot; 我是子进程 %d,ppid:%d,test:%d,&amp;test: %p\\n\\n&quot;,getpid(),getppid(),test,&amp;test);            sleep(1);        &#125;    &#125;    else    &#123;            while(1)        &#123;            printf(&quot; 我是父进程 %d,ppid:%d,test:%d,&amp;test: %p\\n\\n&quot;,getpid(),getppid(),test,&amp;test);            sleep(1);        &#125;    &#125;           return 0;&#125;\n\n依旧是最简单的一个 fork 代码，正常情况下，二者打印的结果应该是一样的！\n\n可如果我们在子进程中修改一下 test 呢？\n\n这时候就会发现一个离谱的现象：子进程和父进程打印的 test 值不一样，但是其地址却  完全相同！\n如果我们在 C/C++ 中使用的地址就是物理地址，是不可能出现这种情况的！怎么可能在  物理内存  的同一个地址访问出两个不同的结果呢？\n\n就好比张三和李四在  同一天的同一时间  去了 AA 路 30 号 这个地址，不可能会出现张三去了发现是超市，而李四去了发现是医院的情况\n\n这便告诉我们了程序地址空间的存在，亦或者说，我们在编程中使用的地址都是  虚拟地址\n2. 简述程序地址空间  每一个进程在启动的时候，都会让操作系统给其分配一个地址空间，这就是进程地址空间\n\n以  先描述再组织  的理念，进程地址空间其实是操作系统内核的一个数据结构struct mm_struct\n之前提到过进程具有独立性，在多进程运行的时候，需要独享各种资源。而进程地址空间的作用，就是让进程  认为  自己是独占操作系统中的所有资源！\n\n这个操作，其实就是操作系统给该进进程画了一个假的内存（虚拟地址）进程需要内存的时候，操作系统就会在  页表  里面画一个地址给他，再将该地址  映射  到物理内存上面\n\n问题：一个分页存储管理系统中，地址长度为 32 位，其中页号占 8 位，则页表长度是？\n解析：页号即页表项的序号，总共占 8 个二进制位，意味着页表项的个数就是 2^8\n\n\n而当进程需要申请内存的时候，本质就是操作系统在 mm_strcut 中修改不同区域的 end 罢了！\n在 Linux 源码中可以看到这玩意的存在，其中的 struct vm_area_struct * mmap; 就是一个我们的虚拟地址管理的内核\n\n这里就能看到虚拟地址空间的 start 和 end 了！\n\n2.1 程序地址空间和代码编译\n程序地址空间不仅是操作系统需要考虑，我们用的编译器也会考虑这部分的内容\n\n我们知道，C 语言代码需要经过  预处理 - 编译 - 链接 - 汇编  这几个步骤\n\n程序编译出来，没有被加载的时候，程序内部  有地址（如果没有地址，无法进行链接）\n程序编译出来，没有被加载的时候，程序内部  有区域 （readelf -s 可执行文件 可以查看区域）\n\n[muxue@bt-7274:~/git/raspi/code/22-10-07_程序地址空间]$ readelf -S testThere are 30 section headers, starting at offset 0x19f8:Section Headers:  [Nr] Name              Type             Address           Offset       Size              EntSize          Flags  Link  Info  Align  [0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0  [1] .interp           PROGBITS         0000000000400238  00000238       000000000000001c  0000000000000000   A       0     0     1  [2] .note.ABI-tag     NOTE             0000000000400254  00000254       0000000000000020  0000000000000000   A       0     0     4  [3] .note.gnu.build-i NOTE             0000000000400274  00000274       0000000000000024  0000000000000000   A       0     0     4  [4] .gnu.hash         GNU_HASH         0000000000400298  00000298       000000000000001c  0000000000000000   A       5     0     8  [5] .dynsym           DYNSYM           00000000004002b8  000002b8       00000000000000c0  0000000000000018   A       6     1     8  [6] .dynstr           STRTAB           0000000000400378  00000378       0000000000000059  0000000000000000   A       0     0     1  [7] .gnu.version      VERSYM           00000000004003d2  000003d2       0000000000000010  0000000000000002   A       5     0     2  [8] .gnu.version_r    VERNEED          00000000004003e8  000003e8       0000000000000020  0000000000000000   A       6     1     8  [9] .rela.dyn         RELA             0000000000400408  00000408       0000000000000018  0000000000000018   A       5     0     8  [10] .rela.plt         RELA             0000000000400420  00000420       00000000000000a8  0000000000000018  AI       5    23     8  [11] .init             PROGBITS         00000000004004c8  000004c8       000000000000001a  0000000000000000  AX       0     0     4  [12] .plt              PROGBITS         00000000004004f0  000004f0       0000000000000080  0000000000000010  AX       0     0     16  [13] .text             PROGBITS         0000000000400570  00000570       00000000000001e2  0000000000000000  AX       0     0     16  [14] .fini             PROGBITS         0000000000400754  00000754       0000000000000009  0000000000000000  AX       0     0     4  [15] .rodata           PROGBITS         0000000000400760  00000760       000000000000005e  0000000000000000   A       0     0     8  [16] .eh_frame_hdr     PROGBITS         00000000004007c0  000007c0       0000000000000034  0000000000000000   A       0     0     4  [17] .eh_frame         PROGBITS         00000000004007f8  000007f8       00000000000000f4  0000000000000000   A       0     0     8  [18] .init_array       INIT_ARRAY       0000000000600e10  00000e10       0000000000000008  0000000000000008  WA       0     0     8  [19] .fini_array       FINI_ARRAY       0000000000600e18  00000e18       0000000000000008  0000000000000008  WA       0     0     8  [20] .jcr              PROGBITS         0000000000600e20  00000e20       0000000000000008  0000000000000000  WA       0     0     8  [21] .dynamic          DYNAMIC          0000000000600e28  00000e28       00000000000001d0  0000000000000010  WA       6     0     8  [22] .got              PROGBITS         0000000000600ff8  00000ff8       0000000000000008  0000000000000008  WA       0     0     8  [23] .got.plt          PROGBITS         0000000000601000  00001000       0000000000000050  0000000000000008  WA       0     0     8  [24] .data             PROGBITS         0000000000601050  00001050       0000000000000004  0000000000000000  WA       0     0     1  [25] .bss              NOBITS           0000000000601054  00001054       0000000000000004  0000000000000000  WA       0     0     1  [26] .comment          PROGBITS         0000000000000000  00001054       000000000000002d  0000000000000001  MS       0     0     1  [27] .symtab           SYMTAB           0000000000000000  00001088       0000000000000648  0000000000000018          28    46     8  [28] .strtab           STRTAB           0000000000000000  000016d0       000000000000021e  0000000000000000           0     0     1  [29] .shstrtab         STRTAB           0000000000000000  000018ee       0000000000000108  0000000000000000           0     0     1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),  L (link order), O (extra OS processing required), G (group), T (TLS),  C (compressed), x (unknown), o (OS specific), E (exclude),  l (large), p (processor specific)\n\n需要注意的是，程序内部的地址，和内存的地址没有关系\n可以理解为，我们程序内部都存放的是一个相对地址。编译程序的时候，认为程序是按照 0000~FFFF 进行编址的。\n当程序被加载到内存当中时，假设系统将该程序的代码从内存 0x100 开始加载，就可以依照程序编址的数据加上这个  偏移量，从而存放在内存中。\n比如程序中有一个代码段的位置是0x1F，这时候在加载程序的时候，就会把这个代码段加上偏移量来加载\n\n\n\n代码地址\n虚拟地址\n\n\n\n0x1f\n0x11f\n\n\n0x20\n0x120\n\n\n大概就是这样，吧哩吧啦……\n2.2 写时拷贝  现在就可以来解答一下 1.2 中出现的问题了\n\n当子进程尝试修改 test 变量的时候，操作系统就会开始一个写时拷贝，开辟一个新的空间，将对应的值考入该空间，再重新映射页表。\n这时候，虽然页表左侧的虚拟地址没有变化，但是映射的物理地址已经不一样了！\n\n这样就能保证父子进程的独立性，谁修改变量都互不影响！\n\n类似 C++ 中实现的  深拷贝！\n\n2.2.1 fork 两个返回值的解释 pid_t id 这个变量属于父进程栈空间中定义的变量，但是 fork 内部，return 会被执行两次（return 的本质是通过寄存器将返回值写入到接收返回值的变量中）\n当 id = fork() 的时候，谁先返回，谁就会发生一次写时拷贝。所以同一个变量有不同的内容值，本质上也是  同一个虚拟地址 ，对应了 不同物理地址  的体现！\n\n打印 fork 的返回值，即可观察到和 1.2 中一样的情况，虚拟地址相同，但是 ret 的值不同\n\n\n3. 程序地址空间的作用  需要注意的是，内存作为一个硬件，没有办法拒绝你的读写！内存是不带控制功能的！\n直接让用户修改物理内存风险极大：\n\n野指针问题\n用户可能直接修改操作系统需要用到的内存地址，导致系统 boom\n\n程序地址空间让访问内存时添加了一层软硬件层，可以对转化过程进行审核，拦截非法的访问\n\n比如操作系统检测到进程在往虚拟地址的常量区读取数据的时候，不做阻拦；但是往常量区  写入  数据的时候，会进行拦截。这才是无法修改常量数据的真正原理\n\n\n保护内存\n可以使用进程管理更好的对功能模块进行  解耦（linux 内存管理）\n让程序 &#x2F; 进程可以用统一的方式 &#x2F; 视角来看待内存，以统一的方式编译加载所有可执行程序，简化程序本身的设计和实现\n\n同时，程序地址空间还可以  延迟  用户的内存使用。比如我们现在 malloc 了 100 个字节的空间，实际上操作系统并不会立马给你申请空间，而是操作你的 mm_struct 让进程以为自己已经申请成功了。当程序真正使用这个空间的时候，操作系统才会去  物理内存  中进行映射！\n\n申请的时候，是通过 linux 的  内存管理模块  进行操作的。同时，写时拷贝  也是通过操作系统的内存管理模块来完成的！\n\n这种“延迟访问”，可以避免某些程序申请了内存而  在一段时间内没有使用  的问题！避免了内存资源的无效占用（也是一种浪费）\n4. 页表  前面只是对页表做了一个基本的解释，但页表并不单纯进行虚拟地址和物理地址的映射，其还会增添权限，是否命中的判断，以及 U/K 权限的标识\n\n\n权限：避免你修改 const 属性的数据\n是否命中：如果对于物理内存处没有数据，则没有命中；需要从硬盘中加载数据到内存中，将  是否命中  更改为是\nU&#x2F;K 权限：用户级和内核级的差别，参考 linux 信号 5.1中关于用户态和内核态的描述；避免用户态的进程执行内核态的源码\n\n前面提到，每一个进程都有一个独立的程序地址空间。要是  页表只有一张  的话，会发生什么事呢？\n以 32 位 系统为例：\n\n内存一共有 2^32 次方个字节，也就是 4Gb\n假设页表每一个字节的条目需要 8 个字节的空间，那就需要 32G 的空间来  存放页表！\n页表肯定不能存在硬盘里面，但这么大的空间一般电脑的内存可放不下\n这也就告诉我们，页表并不是只有一张！\n\n页表实际上是有多张的👌\n4.1 分页存储  当 cpu 访问进程地址空间的时候，其访问的其实是  虚拟地址\n32 位环境下，为了保证地址能覆盖到所有位置，每一个地址都有 32 个比特位；当 MMU 拿到虚拟地址的时候，其实会将虚拟地址拆分\n10     +    10     +    1201010101 00 01000111 11 00001011 1001xxxxxxxx xx yyyyyyyy yy zzzzzzzz zzzz\n\n\n这里面的前 10 位会用于在  页目录  中，用于查找二级页表\n中间 10 位会在  二级页表  中查找页，指向的是页在物理内存中的起始地址\n最后的 12 字节，一共是 2^12=4kb，可以覆盖单个页的大小， 是单个页中的偏移量\n\n这里又涉及到了一个知识点，那便是 Linux 下 IO 的  基本单位是 4kb\n有了这两级的页表后，第一级页表只需要 2^10 个条目，第二级页表有多个，每一个也是 2^10 个条目，最后再指向 4kb 的页\nlinux 下有专门的结构体来描述单个页，和其他系统一样，有了对单个页的描述后，我们就可以用一个数组将页给管理起来。此时对内存的管理，就转换成了对  数组的增删查改\nstruct page&#123;&#125;;\n\n页表实现了分离之后，就可以  按需创建，不会出现一次性创建一个非常大的页表，导致内存空间都被占满的情况！\n\n最初的算法其实是有问题的，因为页表的映射并不需要对每一个字节进行映射。只需要映射到 4kb 这一块即可，总共的条目是 2^32 / 2^12 = 2^20 个，所占用空间也没那么大了\n\n4.2 加载  如果在寻址的时候，发现二级页表中所对应的 page 是 NULL，那么代表该代码的数据没有被加载到内存中\n此时就可以从硬盘中加载，并把 page 的首地址给映射进二级页表中\n\n结语  关于这部分的理解其实并不算十分透彻，或许在日后的项目实践中能加深理解呢~\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】进程概念","url":"/posts/3785030063/","content":"本篇博客是有关  进程状态  的，好久没有写 Linux 的博客了，一起来看看吧！\n\n\n\n实验系统：CentOS 7.6\n\n1. 系统进程的运行状态  当我们想到进程的时候，一定要首先想到 task_struct 结构体。该结构体内部有一个 state 状态码，用于标识当前进程处于什么状态\n\n1.1 运行态 CPU 会有一个进程队列（双链表），队列的每一个成员都是一个task_struct 结构体，用来维护即将运行的进程。当轮到某个进程运行的时候，CPU 就会将这个进程的数据和代码放入内存和自己的寄存器，并开始运行\n只要进入了运行队列的进程，就是  运行态  的进程\n\n所以运行态并不是正在运行的进程\n\n为什么我们对这件事的感知不大呢？那是因为现代的 CPU 的运行速度非常快，这些运行队列的轮转周期很短\n1.2 终止态  终止态：进程还在，但是永远不会运行，在队列中等待被释放\n为什么进程都终止了，不立马释放对应的资源，而需要维护一个终止态？\n\n这是因为当前 CPU&#x2F; 操作系统正在忙着干其他的事情，没时间过来释放你。所以会将不运行的进程放入终止态的队列（将该进程 task_struct 结构体插入该队列）\n当操作系统空闲的时候，便会取终止态队列里面的进程进行释放\n\n1.3 阻塞态  一个进程使用资源的时候，不仅仅会申请 CPU 的计算资源，还有可能申请其他更多的资源，比如  网络 / 硬盘 / 网卡 / 显卡  等等\n如果申请这些资源的时候得不到满足，就需要排队\n\nCPU 资源：运行队列\n其他资源：也需要进行排队\n\n 下面用伪代码的方式来描述一下进程为何会阻塞 \nstruct cpuinfo&#123;    //……    // 运行队列    task_struct *queue;&#125;struct disk_div&#123;   \t// 磁盘的等待队列    task_struct *queue;&#125;struct net_div&#123;   \t// 网卡的等待队列    task_struct *queue;&#125;\n\n当我们的进程访问某种资源，特别是外存（磁盘）这种慢设备资源的时候，如果磁盘暂时还没有准备好，操作系统就会把当前进程从运行队列剥离，插入到对应需要访问的设备下的等待队列中\n\nDDR4 内存  的读写大约是 40GB&#x2F;S，即便是现在市面上较快的 pcie4.0 固态硬盘 其读写速度也只有 7GB&#x2F;S 左右，这个差距还是很大的。所以才说磁盘是“慢设备”资源\n\n操作系统移动 task_struct 到对应的队列下，就是起了它管理进程的作用。同时将进程剥离  运行队列 ，也能让等待慢设备资源的进程不至于把整个系统卡死。当我们电脑上运行的进程很多的时候，就有可能遇到当前的进程在等待过程中出现了 阻塞，此时进程的代码不会运行。最直观的反应便是当前进程卡住不动了。\n\n1.4 进程挂起  进程挂起和进程阻塞很类似，但也有不同。\n\n进程挂起和阻塞不同的是，阻塞只是单纯地在等待慢资源。而  挂起  则是该进程的数据被放入回了磁盘，进程本身依旧在排队等待。操作系统会有一个专门的 swap 分区，用来存放  挂起进程  的代码和数据。\n操作系统这么管理，是为了不让内存在多进程运行的时候不够用了。这也是为什么，当我们内存不够用的时候，往往伴随着磁盘的频繁读取。\n\n当然，内存不够也有可能是某一个进程需要  一次性加载  的代码数据已经超过了内存的大小😂\n\n下图中左下角的部分便演示了操作系统在处理阻塞和挂起态的操作循环\n\n\n2.Linux 下的进程状态描述  在 linux 下进程的状态是存放在一个数组里面的\n\n2.1 S 和 R 状态的说明  其中 R 对应的是运行态，S 对应的就是阻塞态（linux 下为休眠）\n我们可以运行一个程序看看它处于什么状态\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    while(1)&#123;        printf(&quot;%d\\n&quot;,getppid());        sleep(1);    &#125;    return 0;&#125;\n\n运行发现，左侧打印出了当前进程 PID，而右侧当我们使用ps 命令查询该进程的时候，发现该进程的状态是 S+ 也就是休眠状态\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test32080 30455 30455 32080 pts/0    30455 S+    1001   0:00 ./test\n\n\n这是为什么？程序不是一直都在运行吗？\n首先需要知道的是，printf需要将数据打印输出到屏幕上，屏幕作为外设，同样属于慢资源。所以我们的进程绝大部分时间都是处于 sleep(1) 以及等待屏幕刷新的过程中。而 CPU 只需要执行 printf 一个操作，这个操作几乎是瞬间就进行，当然也看不到该进程处于运行态了\n即便我们把 sleep(1) 去掉，进程也是需要等待屏幕刷新，同样处于 S+ 状态\n那要怎样才能让进程处于运行态呢？很简单，我们写一个  不和外设  交互的  死循环  即可\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    while(1)&#123;\t\tint a = 10;    &#125;    return 0;&#125;\n\n可以看到现在进程的状态是R+，处于运行态！\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test32080 32489 32489 32080 pts/0    32489 R+    1001   0:06 ./test\n\n\n2.2 D 状态 disk sleep除了基本的 S 状态，linux 下还有一个专门的 disk sleep 状态。如同它的名字一样，这个状态是专门为访问硬盘的进程设计的\n假设有下面这样一个场景\n1. 进程 A 需要访问磁盘资源，写入 1GB 的数据2. 磁盘很忙，进程 A 进入 S 状态等待读写3. 操作系统发现这里有个进程没干活，内存又不够了，于是把进程 A 干掉了4. 轮到进程 A 独写的时候，磁盘发现进程 A 已经被干掉了，于是没管它的 1GB 数据5. 结果：这个 1GB 数据丢失了\n\n出现这种数据丢失，谁都不想的嘛。所以 Linux 就设置了一个 D 状态，\n\nS 浅度睡眠\nD 深度睡眠\n\n处于 D 状态的进程不能被操作系统 kill 掉。要想杀掉一个 D 状态的进程，只有下面三种办法\n\n等硬盘读写完毕，给进程返回结果之后，进程从 D 状态变成其他状态，操作系统进行处理\n关机重启\n拔掉电脑的电源\n\n\n\nlinux 下可以用 DD 命令直接对硬盘进操作\n\n\n3. 僵尸进程 Z僵尸进程对应的状态码是 Z，而X 是1.2提到的终止态\n3.1 为什么会存在僵尸进程?当 Linux 中的一个进程退出的时候，一般不会进入 X 状态（终止态，可以回收资源），而是进入 Z 状态\n\n进程运行了一定的程序，可以理解为这个进程的任务\n当该进程退出的时候，需要知道这个进程是如何结束的（可以理解为终止的原因）\n一般是将执行结果交还给操作系统或者父进程\n\n维护一个状态 Z，就是为了维护进程的退出信息，可以让  父进程 / 操作系统  读取\n\n父进程 / 操作系统  是通过进程等待来读取进程的退出信息的\n\n在 task_struct 里面就有一个专门的成员来维护退出信息\n\n3.2 如何复现僵尸状态？我们创建子进程的时候，只要父进程不搭理子进程，一直运行父进程，提前终止子进程，就可以观察到子进程进入僵尸状态\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    int ret = fork();    if(ret == 0)    &#123;        int i = 6;        while(i)        &#123;            printf(&quot; 我是子进程，我的 ppid 是 %d,pid 是 %d\\n 我还有 %i 秒终止 &quot;,getppid(),getpid(),i--);            sleep(1);        &#125;        printf(&quot; 子进程进入僵尸状态 \\n&quot;);        exit(0);    &#125;    else&#123;        printf(&quot; 我是父进程，我的 ppid 是 %d,pid 是 %d\\n&quot;,getppid(),getpid());        while(1)        &#123;            int a = 10;           &#125;    &#125;           return 0;&#125;\n\n\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test1 | grep -v grep32080 30962 30962 32080 pts/0    30962 R+    1001   0:05 ./test130962 30963 30962 32080 pts/0    30962 S+    1001   0:00 ./test1[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test1 | grep -v grep32080 30962 30962 32080 pts/0    30962 R+    1001   0:06 ./test130962 30963 30962 32080 pts/0    30962 Z+    1001   0:00 [test1] &lt;defunct&gt;\n\n英语小课堂：defunct\n\n一般我们都会要求父进程回收子进程，不过这个得后续才能学到了！\nps 循环监控脚本  我们可以使用一个监控脚本来更方便的监控结果\nwhile :; do ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\n上面这个语句的作用是，每一秒执行一次 ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep 命令，直到我们使用 ctrl+c 终止进程\n需要注意分隔符，while后面的是 :; 不要写成双冒号！\n3.3 长时间僵尸状态的弊端  如果一个僵尸进程长时间不被处理，就容易出现  内存泄漏！\n子进程的状态是用数据维护的，如果父进程一直不回收子进程，该子进程的 task_struct 就一直留存在内存中，这就是一定的内存泄漏。\n3.4 孤儿进程  当一个进程的父进程先退出的时候，子进程就会变成孤儿进程\n\n为什么这里我们没有看到父进程进入 Z 或者 X 状态呢？那是因为这里父进程的父进程是bash，命令行回收了我们的父进程。\n可子进程为何还在这里呢？\n\n父进程退出之后，子进程并不会不见，而是会被 1 号 进程（操作系统）领养。\n这时候我们可以把子进程称为  孤儿进程\n\n注：1 号进程又称 init 进程\n\n\n而操作系统领养之后的子进程，即便你使用 ctrl+c 也干不掉这个进程\n\n仔细观察，可以看到子进程被操作系统领养后，运行状态上的 + 不见了\n PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND32080  2842  2842 32080 pts/0     2842 S+    1001   0:00 ./test2 2842  2843  2842 32080 pts/0     2842 S+    1001   0:00 ./test2################################################################ PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND    1  2843  2842 32080 pts/0    32080 S     1001   0:00 ./test2\n\n前台和后台进程  状态码上带有 + 号，代表进程是一个前台进程\n\n能被 CTRL+C 终止的都是前台进程\n后台进程一直在运行，会影响我们的命令行输入\n\n我们可以使用 kill -9 干掉该进程，干掉进程之后，就可以使用 CTRL+C 恢复正常的命令行了\n\n3.5 守护进程和精灵进程  守护进程 &amp; 精灵进程：这两种是同一种进程的不同翻译，是特殊的孤儿进程，不但运行在后台，最主要的是脱离了与终端和登录会话的所有联系，也就是默默的运行在后台不想受到任何影响\n\n4. 进程暂停 T暂停一共有两种状态，一种是stopped，第二种是tarcing stop\n\n一般 linux 系统是用大 T 指代stopped，用小 t 指代tarcing stop\n4.1 T-stoppedkill 发信号  在之前的操作中，我们已经学过使用 kill -9 pid 来干掉一个进程，实际上 kill 命令能干的事情远不止这一个\nkill -l\n\n使用这个命令可以查看到 kill 命令支持什么操作\n\n其中我们要用到的是第 19 和第 18，分别用于  暂停 / 恢复  一个进程\n#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;start!\\n&quot;);    while(1)&#123;        ;    &#125;    return 0;&#125;\n\n写一个啥事不干的死循环用于测试，可以看到该进程处于 R+ 状态\n\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ kill -19 9503\n\n执行 kill -19 命令之后，我们可以看到该进程被终止，状态码变为大 T\n\n进程暂停并不代表进程结束，这就好比我们看视频的时候暂停一样。你暂停了播放，但是播放器这个进程并不会直接终止！\n要想让这个进程重新运行，执行 kill -18 即可，进程恢复为 R 状态。此时也没有了+，代表这是一个后台进程\n\n PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND32080  9503  9503 32080 pts/0    32080 T     1001   0:55 ./test3######################## PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND32080  9503  9503 32080 pts/0    32080 R     1001   0:55 ./test3\n\n使用 kill -9 干掉该后台进程即可\n4.2 t-tarcing stoptarcing一词意为追踪，最简单的情况便是我们使用的 gdb 调试打断点\n\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test30493 12333 12333 30493 pts/1    12333 S+    1001   0:00 gdb test_g12333 12412 12412 30493 pts/1    12333 t     1001   0:00 /home/muxue/GIT/raspi/code/22-09-24_? 程 /test_g\n\n这时候 test_g 进程就是一个处于小 t 状态的进程\n\n5. 进程优先级\n权限：能还是不能的问题，决定进程能不能访问某种特定的资源\n优先级：进程可以访问该资源，但有先后顺序（运行队列）\n\n进程在排队获取资源的本质就是在确认优先级。这是因为系统的某些慢资源不够多个进程同时使用，这时候就需要让进程进入排队来先后访问。\n而优先级越高的进程，操作系统执行它的响应就会更快。其会把它插入到优先级低于它的进程之前，先运行这个“vip 进程”，再运行那些“普通进程”\n5.1 linux 进程优先级  可以用下面的 ps -la 命令查看当前 bash 下的进程\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps -lF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 27595 30493  0  80   0 - 38587 -      pts/1    00:00:00 ps0 S  1001 30493 30492  0  80   0 - 29576 do_wai pts/1    00:00:00 bash[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD1 S  1001 27546     1  0  80   0 -  1833 hrtime pts/0    00:00:00 test20 R  1001 27598 30493  0  80   0 - 38595 -      pts/1    00:00:00 ps\n\n其中的 PRI 和NI就是我们进程优先级的数据\n\nlinux 的进程优先级 &#x3D;priority_old+nice\nlinux 下进程的默认优先级是 80，PRI值越低，优先级越高\nNI值是进程优先级的修正数据，我们修改进程优先级，修改的是 NI 值而不是PRI\n\n这两个值允许的范围如下，Linux 系统并不支持用户无节制的修改优先级\n-20 &lt;= NI &lt;= 1960 &lt;= PRI &lt;= 99\n\n5.2 使用 top 命令进行修改优先级 linux 下修改优先级的操作如下，运行test1 程序后，先查看它的优先级信息\n[muxue@bt-7274:~]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 29632 30493 98  80   0 -  1833 -      pts/1    00:00:42 test11 Z  1001 29633 29632  0  80   0 -     0 do_exi pts/1    00:00:00 test1 &lt;defunct&gt;0 R  1001 30732 29713  0  80   0 - 38595 -      pts/0    00:00:00 ps\n\n在使用 sudo top 后，进入界面按 r，输入需要设置的进程pid 后，再输入需要调整的 nice 值\n\n\n[muxue@bt-7274:~]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 29632 30493 99  70 -10 -  1833 -      pts/1    00:02:41 test11 Z  1001 29633 29632  0  80   0 -     0 do_exi pts/1    00:00:00 test1 &lt;defunct&gt;\n\n这里可以看到，test1 进程的优先级已经被我们改成了70\n再来尝试第二次，这次 nice 设置为 20 看看\n\n[muxue@bt-7274:~]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 30697 30493 98  99  19 -  1833 -      pts/1    00:00:16 test11 Z  1001 30698 30697  0  80   0 -     0 do_exi pts/1    00:00:00 test1 &lt;defunct&gt;\n\n诶，pid 设置成 20 之后，为啥 NI 值变成了 19，而 PRI 变成了 99 呢？\n\n依据我们以往的惯性思维，既然进程优先级 &#x3D;priority_old+nice，那么修改了之后不应该是原本的 70+20&#x3D;90 吗？为什么是 99 呢？\n\n这是因为每一次设置的时候，priority_old都会被重置成 80。所以可以直接记住，Linux 下  进程的优先级 &#x3D;80+Ni 值\nThe End感谢你看到最后，如果本篇博客有啥问题，欢迎在评论区提出！\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】环境变量","url":"/posts/977518181/","content":"本篇博客记录了 Linux 下一些概念的解释，以及环境变量的相关操作\n\n\n\n所用系统：CentOS 7.6\n\n1. 概念解释 1.1 进程竞争性 系统进程的数目较多。而 CPU 资源等其他资源不够用，所以进程之间存在竞争性，也就出现了优先级，这在  上篇博客  中有过介绍\n1.2 进程独立性  进程运行具有独立性，不会因为某个进程出错，而影响其他进程的运行\n我们知道，一个进程是  内核结构 task_truck+ 代码和数据  组成的。而 linux 系统是通过  进程地址空间  方式来保证进程的独立性，那是下篇博客会讲到的内容\n1.3 并行  并行：多个进程在  多个 CPU下分割，同时运行\n\n我们一般的电脑都是只有 1 个 cpu，那是怎么做到多个进程运行的？\n注意：多个进程都在系统中运行≠多个进程在系统中  同时运行。要想知道这是怎么做到的，需要了解并发的概念\n1.4 并发  大部分操作系统都是  分时  的，操作系统会给每一个进程赋予一个  时间片，这样在一个调度周期中，可以调用到每一个需要运行的进程。\n这样，在一个时间段内，多个进程会通过  交叉运行  的方式，让每一个进程的代码，在这段时间内都能得到运行\n\n比如每一个进程运行 10ms，假设有 10 个进程需要运行，那么在 1s 内，这 10 个进程都会被运行 10 次。1s=1000ms\n\ncpu 进行多个进程的快速交替运行，以实现我们看到的单 cpu 运行多个进程的情况\n这种情况就叫做  并发\n\n1.5  进程优先级管理  操作系统正在运行一个低优先级进程的时候，突然来了一个高优先级数据怎么办？\n\n操作系统支持不同优先级进程的存在\n同一个优先级的进程可以存在多个\n操作系统是用  队列  来管理进程的，队列只支持支持尾删尾插\n\n这种情况要怎么处理呢？如果给队列头插，那不就破坏了队列的属性了？\n实际上，操作系统并不是用单一队列来进行管理的，而是用了一个  哈希桶  来进行处理\n\n可以理解为哈希桶是一个数组，后面链接了不同优先级的进程\n当一个更高优先级的进程需要运行的时候，操作系统只需要改变 cpu 当前运行队列在哈希桶里面的指向，即可马上完成高低优先级进程之间的切换\n操作系统还会管理一个  位图，用于标识某一个优先级内是否存在进程\n\n哈希和位图这两个数据结构都会在 C++ 的博客中讲解\n\n除了位图和哈希表之外，操作系统还会管理一个结构体，用于标识目前正在使用的进程哈希桶active，以及新进程的管理桶old\nstruct runqueue&#123;\thash_queue* active;\thash_queue* old;&#125;;\n\n当出现  新进程  的时候，操作系统不会把它直接链接到 active 里面，而是放入 old 中；\nactive内部的进程运行完了之后，只需要 swap 一下 active/old 指针，即可完成新进程表和运行完的旧表之间的交换！\n\n这种调度算法也被称为  大 O(1)调度法\n\n1.6 进程间切换 CPU 存在寄存器，这些寄存器储存了进程的 临时数据\n\n寄存器分为可见寄存器（eax&#x2F;ebx）和不可见寄存器\n\n当进程在运行过程中，会产生各种临时数据\nint test()&#123;\tint a = 10;\treturn a;&#125;int main()&#123;    int b = test();    return 0;&#125;\n\n我们知道，定义在函数 test 中的 a 是一个局部变量，出了作用域就会销毁，那么 main 函数里面的 b 是怎么拿到 test 的返回值的？\n这里就用到了寄存器：a 的值会先放入寄存器中，销毁了之后，再把寄存器里面的值赋值给 b\n和内存一样，CPU 只有一套寄存器。这一套寄存器在运行不同进程的时候，可以保存不同的临时数据\n\n这时候如果来了一个高优先级进程 A，直接覆盖了正在运行的进程 B 及其寄存器中的数据，就可能导致进程 B 存在寄存器中的数据丢失，导致 B 无法继续运行\n\n所以，在进程的 task_struct 结构体中，就有一个专门的成员用于保存进程的上下文数据\n\n上下文数据：进程在运行中产生的各种临时数据\n当进程被剥离的时候，需要保存上下文数据\n当进程恢复运行的时候，需要重新加载上下文数据\n\n\n关于进程 pcb 和 task_struct 的内容可以看我之前的博客 进程概念\n\n2. 环境变量 2.1 引入环境变量 当我们运行自己编译的一个可执行文件的时候，需要带上 ./ 指定路径\n\n使用 file 命令查看系统的相关指令，你会发现它们和我们自己写的 mytest 本质上是一样的，都是一个 executable 的可执行文件\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ file /bin/ls/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=c8ada1f7095f6b2bb7ddc848e088c2d615c3743e, stripped[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ file /bin/gcc/bin/gcc: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=84ea48c51fa70f8cd586b7801bc655487156db7b, stripped[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ file mytestmytest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=db352023d208d9f48899641c3536a8c13b7bc7bf, not stripped\n\n那为何运行诸如 ls pwd gcc 等等系统命令的时候，不需要在前面带上 ./ 路径来运行呢？\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ mytest-bash: mytest: command not found[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ lsmakefile  mytest  mytest.c\n\n这是因为：指向一个可执行程序，前提是需要找到它！\nlinux 系统只能找到它自己预设好的命令，找不到我们的mytest\n在 linux 命令行中，输入 env 即可查看当前系统的环境变量\n\n其中 PATH 就是可执行程序存放的路径！系统就是通过  环境变量  来查找可执行程序的\n2.2 添加删除环境变量  别急，我们先来学习一下怎么添加环境变量。实际上，我们的 bash 命令行里面是可以定义变量的，变量分为两种类型\n\n本地变量（局部）\n环境变量（全局）\n\n直接使用  变量名 = 值  的方式，就可以定义一个本地变量。使用 echo 命令可以查看这个本地变量。这时候我们用 env | grep 变量名 在环境变量里面查找，会发现当前的环境变量里面没有这个东西\n[muxue@bt-7274:~]$ aaaa=1234[muxue@bt-7274:~]$ echo $aaaa1234[muxue@bt-7274:~]$ env | grep aaaa[muxue@bt-7274:~]$\n\n这时候需要用 export 命令，创建一个环境变量\n[muxue@bt-7274:~]$ export bbbb=4321[muxue@bt-7274:~]$ env | grep bbbbbbbb=4321\n\n或者可以导入当前的本地变量\n[muxue@bt-7274:~]$ export aaaa[muxue@bt-7274:~]$ env | grep aaaaaaaa=1234\n\n删除的时候则使用 unset 命令取消环境变量\n[muxue@bt-7274:~]$ unset bbbb[muxue@bt-7274:~]$ env | grep bbbb[muxue@bt-7274:~]$ \n\n查看环境变量\necho: 显示某个环境变量值\nexport: 设置一个新的环境变量\nenv: 显示所有环境变量\nunset: 清除环境变量\nset: 显示本地定义的 shell 变量和环境变量\n\necho $ 环境变量名 # 查看环境变量set | less # 查看所有的 shell 变量和环境变量\n\n认识一些环境变量\nUSER：当前登录的用户\nHOME：当前用户的工作路径\nLANG：当前的语言和编码设定\nPATH：可执行命令的路径\nSHELL：当前使用的命令行是啥\nLOGNAME：当前登录的用户名\nPWD：当前所处路径\nOLDPWD：上一个路径，使用 cd - 跳回上一个路径\nHISTSIZE：系统会记录的历史命令条数\n\n我们可以用 history 命令查看之前运行过的命令，这里面保存的正好是 3000 条，和环境变量 HISTSIZE 的设置一致！\n[muxue@bt-7274:~]$ env | grep $HISTSIZEHISTSIZE=3000[muxue@bt-7274:~]$ history | wc --l3000\n\n需要注意的是，系统预载的环境变量都是在  配置文件  里面的。当前我们对环境变量做的任何操作都只会  临时保存。关闭当前的命令行重新开一个，之前设置的环境变量就会消失\n[muxue@bt-7274:~]$ cat /etc/bashrc\n\n系统的环境变量配置文件为 /etc/bashrc，用户的则为工作目录下的.bashrc 以及.bash_profile\n查看上个进程退出状态码  在 linux 下有一个特殊的环境变量 ?，这个环境变量存放的是上一个进程的退出码。比如我们进程中return 0 退出，那么查询到的就是 0\necho $?\n\n\n\n2.3 环境变量 PATH使用 echo $PATH 查看当前系统可执行文件的路径\n这里的路径都以 : 作为分割，linux 查找命令的时候，就会在下面的这些路径里面查找\n[muxue@bt-7274:~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin\n\n除了直接使用ls，我们也可以使用路径的方式来调用 ls\n[muxue@bt-7274:~]$ /usr/bin/ls bin  git  install.sh  kook  mon\n\n而如果想让系统能找到自己的可执行程序，就可以直接把可执行程序复制到这些路径中！\n给 PATH 中添加可执行文件[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ cp mytest ~/bin[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ mytesthello world!hello world!\n\n比如现在，我把 mytest 这个可执行程序复制到了 ~/bin 也就是 /home/muxue/bin 的路径下，此时直接使用 mytest 就能找到对应的命令了！\n除了这种办法以外，我们还可以把当前的路径写入 PATH 环境变量中\n[muxue@bt-7274:~]$ export PATH=$PATH:/home/muxue/git/raspi/code/test# 这样写是在原本的 path 后面追加内容。不能直接 path= 自己的路径，会直接覆盖[muxue@bt-7274:~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin:/home/muxue/git/raspi/code/test\n\n这时候直接执行 mytest 也成功了！\n[muxue@bt-7274:~]$ mytesthello world!hello world!hello world!\n\n前面提到了我们设置的这个环境变量都是临时的，所以重启了之后，自己设置的这个路径也会消失\n[muxue@bt-7274:~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin\n\n注意：一般情况下不建议在 linux 系统路径中安装自己的可执行程序，因为这样会污染系统的命令环境！\n3.C&#x2F;C++ 获取环境变量 3.1 main 函数的参数 之前一直没有了解过这个知识点，C&#x2F;C++ 的 main 函数是可以带参数的！\n#include&lt;stdio.h&gt;// 第一个参数指代命令个数，执行该可执行文件时传入的几个命令// 第二个参数是一个指针数组，存放了每一个命令的常量字符串int main(int arg,char* argv[])&#123;    printf(&quot;arg: %d\\n&quot;,arg);    for(int i =0;i&lt;arg;i++)    &#123;        printf(&quot;argv[%d]: %s\\n&quot;,i,argv[i]);    &#125;    return 0;&#125;\n\n\n有了这两个参数，我们就可以利用它写一个命令行版本的计算器\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//main 函数可以带参数// 第一个参数指代命令个数，执行该可执行文件时传入的几个命令// 第二个参数是一个指针数组，存放了每一个命令的常量字符串int main(int arg,char* argv[],char *envs[])&#123;    if(arg != 4)    &#123;        printf(&quot;Usage: %s [-a|-s|-m|-d] first second\\n&quot;, argv[0]);        return 0;    &#125;    int x = atoi(argv[2]);    int y = atoi(argv[3]);    if(strcmp(&quot;-a&quot;, argv[1]) ==0)    &#123;        printf(&quot;%d+%d=%d\\n&quot;,x, y, x + y);    &#125;    else if(strcmp(&quot;-s&quot;, argv[1]) ==0)    &#123;        printf(&quot;%d-%d=%d\\n&quot;,x, y, x - y);    &#125;    else if(strcmp(&quot;-m&quot;, argv[1]) ==0)    &#123;        printf(&quot;%d*%d=%d\\n&quot;,x, y, x * y);    &#125;    else if(strcmp(&quot;-d&quot;, argv[1]) ==0 &amp;&amp; y != 0)    &#123;        printf(&quot;%d/%d=%d\\n&quot;,x, y, x / y);    &#125;    else    &#123;        printf(&quot;Usage: %s [-a|-s|-m|-d] first second\\n&quot;, argv[0]);    &#125;    return 0;&#125;\n\n实现非常简单，其使用方法如下👇\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ gcc test.c -o test -std=c99[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -a 10 2010+20=30[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -s 10 2010-20=-10[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -m 10 3010*30=300[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -d 30 1030/10=3[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test 1 1 1 1 Usage: ./test [-a|-s|-m|-d] first second\n\n上面这个小程序演示了 main 函数的参数的作用。\n看到这里，想必你应该不难理解 linux 系统的命令是如何使用参数的，诸如 ls -l 等等选项，其实都是通过 main 函数的参数实现的！\n通过 main 函数的参数，可以让同一个可执行文件  依据命令  输出不同的结果！\n3.2 使用第三个参数获取环境变量  除了上面提到的 main 函数前两个参数，实际上 main 函数还可以带第三个参数！\n// 第一个参数指代命令个数，执行该可执行文件时传入的几个命令// 第二个参数是一个指针数组，存放了每一个命令的常量字符串// 第三个参数用于导入环境变量！int main(int arg,char* argv[],char *envs[])&#123;    for(int i =0;envs[i];i++)    &#123;        printf(&quot;envs[%d]: %s\\n&quot;,i,envs[i]);    &#125;\treturn 0;&#125;\n\n因为 envs 是一个指针数组，所以可以通过判空来终止 for 循环\n\n在这个数组的最后，可以看到我们刚刚执行的命令也被写入了环境变量\n\n除了上面这个办法，我们还可以用下面两种方式来获取环境变量\nenviron 外部导入环境变量C 语言提供了一个 environ 来导入环境变量，其作用和 main 函数第三个参数是一样的\n\nextern char ** environ;printf(&quot;get env from [environ]\\n&quot;);for(int i = 0; environ[i]; i++)&#123;    printf(&quot;%d: %s\\n&quot;, i, environ[i]);&#125;\n\n\n其输出的结果也是一样的\ngetenv 函数man getenv\n\n\n这个函数就能实现一些骚操作，比如写一个只有我自己可以运行的可执行文件\nint main(int arg,char* argv[],char *envs[])&#123;    char* user = getenv(&quot;USER&quot;);    if(strcasecmp(user,&quot;muxue&quot;)!=0)//strcasecmp 忽略大小写    &#123;        printf(&quot; 权限禁止！\\n&quot;);        return -1;    &#125;    printf(&quot; 成功执行！\\n&quot;);    return 0;&#125;\n\n通过 getenv 函数获取到环境变量中的USER，判断其与我自己设定的 user 是否相同。如果不同就拒绝执行，相同才成功执行\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test成功执行！[root@bt-7274:/home/muxue/git/raspi/code/22-10-04_环境变量]# ./test权限禁止！\n\n可以看到，哪怕是 root 用户也搞不来这个可执行程序！\n\n4. 关于本地变量的说明  在2.2中提到了本地变量和环境变量的区别\n\n本地变量（局部）\n环境变量（全局）\n\n所谓的本地变量，其实是 bash 内部定义的变量。\n我们首先需要了解的是，linux 下大部分的进程或命令都是以  子进程  方式运行的，其父进程都是当前打开的bash\n由此可知，bash内部的本地变量，并  不会  被这些子进程所继承\n而环境变量具有全局属性，可以被子进程继承并获取！\n\n那么问题来了，export/echo也是命令。如果它们也是子进程，那它们是怎么获取到 bash 内部的本地变量，并将其导入到环境变量中的呢？\nnope！实际上，这两个命令都是由 bash 自己执行的（调用自己的对应的函数完成功能）我们把这种命令称作  内建命令\n结语  关于环境变量的基本认识到这里就 OVER 啦。本博客是我的课堂笔记，难免会有问题，还请各位大佬指出~\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】简易 shell 的实现","url":"/posts/2663421239/","content":"本篇博客，来教大家用 C 写一个简易的linux shell，帮助理解之前学习的进程控制相关知识\n\n\n\n演示系统：CentOS7.6\n\n[TOC]\n前言  之所以说是  简易  的 shell，是因为我们现在的水平肯定写不出来 linux 系统里面那么复杂的 shell。\n我们的目的仅仅是为了学习父子进程、进程替换、内建命令等等知识，并把这些知识的作用通过这个小 shell 体现出来\n\n源码仓库：gitee\n\n\n1. 基础框架  之前的学习中有提到过，我们在 linux 命令行内运行的很多进程，都是以子进程的方式运行的。说白了就是 bash 进程里面给我们 fork 创建了其他子进程，再用子进程进行  进程替换，指向对应的可执行文件\n而需要做到这一点，我们要一步一步来\n\nbash 首先要显示命令行的提示符  用户名 @主机名 路径（参考之前 vim 博客中的进度条程序）\n获取用户的输入内容\n从用户的输入中，以 &quot; &quot; 空格为分割，分离出命令和参数\nfork 创建子进程，子进程执行进程替换，父进程等待子进程结束\n\n这一切都是在一个 while(1) 的死循环里面执行的，bash 本质上就是一个死循环的父进程\n2. 开整一个 2.1 打印命令行提示符 先来试试打印出命令行的提示符吧！\nprintf(&quot;[慕雪 @FS-1041 当前路径]# &quot;);fflush(stdout); // 刷新缓冲区，达到不换行的效果\n\n\n\n为何要使用fflush？\n\n如果不这么弄，而使用 \\n 换行，就会出现命令行提示符一直在闪动打印。这不是我们想要的结果\n光是打印一个基本的路径可不太够哦，我们还可以试着获取环境变量的 PWD 得到当前的路径，再打印出来\nchar cur_pwd[SIZE] = &quot;~&quot;;int sz_pwd = strlen(getenv(&quot;HOME&quot;));strcat(cur_pwd, getenv(&quot;PWD&quot;) + sz_pwd);printf(&quot;[慕雪 @FS-1041 %s]# &quot;, cur_pwd);fflush(stdout); // 刷新缓冲区，达到不换行的效果\n\n这里我们必须要去掉 PWD 前面 /home/ 用户名 的内容，将其替换成~\n打印出来的效果如下，是不是和我们 linux 的命令行很像啦！\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n你还可以从环境变量中获取 HOSTNAME 和USER来替换掉前面的内容\n这里为了和 linux 自己的 shell 区分一下，我就不替换了\n\n2.2 获取用户输入C 语言获取用户输入，我们一般用的是scanf\n但是这个函数在现在这个地方可不那么好用喽！我们输入命令的时候需要用空格分开命令行参数。scanf 会因为空格而停止接受\n我们可以用 gets 函数来解决这个问题！\n#define NUM 1024char cmd_line[NUM]; // 命令行输入// 2. 获取用户的输入内容memset(cmd_line, &#x27;\\0&#x27;, sizeof(cmd_line) * sizeof(char));fgets(cmd_line, NUM, stdin);           // 标准输入 stdin 获取键盘输入内容\n\n获取了之后先打印一下cmd_line，可以看到成功获取了我们输入的结果\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# test i k dtest i k d[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]#\n\n但为什么多打了一个换行呢？\n这是因为 fgets 在接受输入的时候，把我们输入结束的  回车  也给收起来辣\ncmd_line[strlen(cmd_line) - 1] = &#x27;\\0&#x27;; // 去掉 \\n 回车\n\n光是去掉回车还是有点问题，如果我们只敲了一个回车，后续我们分离参数的时候，总不能对一个空的字符串进行处理吧？\n所以还需要单独判断 strlen(cmd_line)==1 的情况，直接continue\nif(strlen(cmd_line)==1)&#123;    continue;// 等于 1 的情况只能是敲了一个回车&#125;// 其他情况去掉 \\n 回车cmd_line[strlen(cmd_line) - 1] = &#x27;\\0&#x27;; \n\n这样我们的 bash 就和 linux 自己的 bash 一样，敲回车会直接新起一行，不做任何操作\n\n如果不这么处理，就会引发段错误导致 bash 直接终止\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# Segmentation fault\n\n2.3 分离参数  获取好用户输入啦，下一步就是分离参数了！\n这里面我们直接使用 strtok 这个函数即可！\nchar * strtok (char * str, const char * sep );\n\n它的作用是根据分隔符返回这个分隔符在字符串里面的起始位置；如果传入的是一个 NULL，则从上一次处理的位置继续往后处理。\n\nstrtok 函数找到 str 中的下一个标记，并将其用 \\0 结尾，返回一个指向这个标记的指针\n如果字符串中不存在更多的标记，则返回 NULL 指针\n\n\n该函数的详解参考我的博客 点我 \n\n😥最开始的时候我忘记了这个函数，直接自己写了一个分离算法，debug 了好久才勉强搞出来，太笨蛋了\n#define SEP &quot; &quot; // 分隔符size_t cmd_args_num = 0;  // 分离出来的参数个数char *cmd_args[SIZE];     // 分离参数cmd_args[0] = strtok(cmd_line, SEP);cmd_args_num = 1;while (cmd_args[cmd_args_num++] = strtok(NULL, SEP));cmd_args_num--;// 这里 -1 是因为 while 循环最后会多 ++ 1 次\n\n注意！=赋值操作符是有返回值的！它的返回值是我们的左值，也就是每一次获取到的 strtok 的结果，这个结果被 cmd_args[cmd_args_num] 所接受\n那么，当 strtok 返回 NULL 的时候，while 就会接受到 = 的返回值，从而停止循环\nfor(int j=0;j&lt;cmd_args_num;j++)&#123;    printf(&quot;args[%d] %s\\n&quot;,j,cmd_args[j]);&#125;\n\n通过打印，可以看到它成功分离出来了我们的参数\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# ls -largs[0] lsargs[1] -l\n\n单独处理 ls在 linux 的 bash 下，我们执行的 ls 都是带颜色的。这是因为 centos 的配置文件中，将 ls 设置成了 ls --color=auto 的别名，要想我们自己 bash 里面的 ls 也带上颜色，则需要单独处理一下 ls\n// 3. 分离出命令和参数cmd_args[0] = strtok(cmd_line, SEP);cmd_args_num = 1;// 给 ls 命令添加颜色if (strcmp(cmd_args[0], &quot;ls&quot;) == 0)    cmd_args[cmd_args_num++] = (char *)&quot;--color=auto&quot;;while (cmd_args[cmd_args_num++] = strtok(NULL, SEP));cmd_args_num--;// 这里 -1 是因为 while 循环最后会多 ++ 一次\n\n最终 ls -l 分离出来的参数如下\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# ls -largs[0] lsargs[1] --color=autoargs[2] -l\n\n2.4 进程替换  参数分离出来了，下一步要做的，便是进程替换了\n我们需要使用的是 exec 函数里面的哪一个呢？\n\n带 p 的exec函数，它会自动去 PATH 里面查找可执行文件\n带 v 的，函数，因为我们的传参已经分离在了一个字符指针数组里面\n\n基本的代码如下，父进程打印内容是为了测试，实际的 bash 肯定是没有这个打印的~\n// 6. 创建程序 替换pid_t ret_id = fork();if (ret_id == 0) // 子进程&#123;    execvp(cmd_args[0], cmd_args); // 程序替换    exit(134);                     // 执行到这里，子进程一定替换失败&#125;// 父进程int status = 0;pid_t ret = waitpid(ret_id, &amp;status, 0);printf(&quot;\\n&quot;);if (ret &gt; 0)&#123;    printf(&quot;bash 等待子进程成功！code: %d, sig: %d\\n&quot;, WEXITSTATUS(status), WTERMSIG(status));&#125;\n\n运行成功！\n\n执行 python3 的文件也是 ok 的\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# python3 test.pyargs[0] python3args[1] test.pyhello pythonbash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]#\n\n3. 内建命令  完成了上面的几步后，一个基础的 bash 就搞定了\n但是这样还不够，不信 cd 试一下？\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# lsmakefile  myshell  myshell.c  myshell_err.c  test  test.cpp  test.pybash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# cd testbash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# lsmakefile  myshell  myshell.c  myshell_err.c  test  test.cpp  test.pybash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n 诶，为什么 cd 了之后，再次 ls，路径没有变化呢？\n这是因为我们的 cd 是被  子进程  执行的，切换的是子进程的工作目录。可子进程执行完 cd 之后就结束运行了，它根本没有影响到父进程 bash！\n\n之前学习的时候，我们提到过内建命令这一个概念。有一些命令不应该是子进程执行的，而应该是 bash 自己执行的，比如这里的cd，还有导入环境变量的export\n其实说白了就是 bash 检测到内建命令，就执行他自己的一个函数呗\n3.1 cd 和 export 命令 cd/export 命令，c 语言中都有现成的函数供我们使用，还是很方便的\n// 这里导入环境变量之后，不会影响 linux 的 shell// 而是从我们的 myshell 开始所有子进程都会继承int PutEnvIn(char *new_env)&#123;    putenv(new_env);    return 0;&#125;// 不使用内建命令，则不会生效int ChangeDir(const char *new_path)&#123;    chdir(new_path);    return 0; // 调用成功&#125;\n\n以下是 main 函数里面的内容，完整代码请去我的代码仓库查看\n// 5. 内建命令if (strcmp(cmd_args[0], &quot;cd&quot;) == 0 &amp;&amp; cmd_args[1] != NULL)&#123;    ChangeDir(cmd_args[1]); // 让调用方进行路径切换, 父进程    continue;&#125;// 目前，环境变量信息在 cmd_line, 会被清空// 此处我们需要自己保存一下环境变量内容char env_buffer[SIZE][NUM];size_t env_num = 0; // 环境变量的数量if (strcmp(cmd_args[0], &quot;export&quot;) == 0 &amp;&amp; cmd_args[1] != NULL)&#123;    strcpy(env_buffer[env_num], cmd_args[1]);    PutEnvIn(env_buffer[env_num]);    env_num++;    continue;&#125;\n\n这时候 cd 就能正常执行了，不过 pwd 还没有修改，我没想好要怎么操作捏\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# lsmakefile  myshell  myshell.c  myshell_err.c  test  test.cpp  test.pybash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# cd test[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# lsbash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n试一试export，也没问题呢\n//test.cpp#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;ts= &quot; &lt;&lt; getenv(&quot;ts&quot;) &lt;&lt;endl;    return 0;&#125;\n\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# make testg++ test.cpp -o test -std=c++11bash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# export ts=12341[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# ./testts= 12341bash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n3.2 alias 别名设置  上面两个命令有现成的，alias的设置就需要我们手写啦\n#define NUM 1024#define SIZE 128// 变量名别名typedef struct alias_cmd&#123;    char _cmd[SIZE];    char _acmd[SIZE];&#125; alias;alias cmd_alias[SIZE]; // 缓存别名键值对(结构体)size_t alias_num = 0;  // 已缓存的别名个数\n\n这里我先定义了一个结构体，用来存放变量别名的键值对，方便我们进行替换\n然后就是漫长的替换步骤，这部分我 debug 了非常久才写出来，都带了注释，大家可以看看\n// 设置别名(新命令，原命令)void set_alias(char *cmd, char *acmd)&#123;    // 查找别名里是否已经有了这个    for (int i = 0; i &lt; alias_num; i++)    &#123;        if (strcmp(cmd_alias[i]._cmd, cmd) == 0) // 是已有的别名        &#123;            strcpy(cmd_alias[i]._acmd, acmd);            // printf(&quot;set cmd %s acmd %s\\n&quot;,cmd_alias[i]._cmd,cmd_alias[i]._acmd);            return;        &#125;    &#125;    // 没有提前退出，说明是新增别名    strcpy(cmd_alias[alias_num]._cmd, cmd);    strcpy(cmd_alias[alias_num]._acmd, acmd);    alias_num++;&#125;// 判断一个命令是否有别名bool is_alias(char *cmd_args[], int sz)&#123;    int i = 0;    for (i = 0; i &lt; alias_num; i++)    &#123;        if (strcmp(cmd_alias[i]._cmd, cmd_args[0]) == 0) // 是别名        &#123;            size_t index = 1, j;            char *cmd_args_temp[SIZE];                                           // 临时数组用于分离别名里面的命令            memset(cmd_line_alias, &#x27;\\0&#x27;, sizeof(cmd_line_alias) * sizeof(char)); // 清空别名命令缓存            // 先把别名中的命令分开            strcpy(cmd_line_alias, cmd_alias[i]._acmd); // 不能直接使用_acmd，不然会影响下次别名使用            cmd_args_temp[0] = strtok(cmd_line_alias, SEP);            // 别名的时候也需要设置 ls 的颜色（需要保证原本命令的第一个不是 ls，不然本来就已经有 &quot;--color=auto&quot; 了）            if (strcmp(cmd_args_temp[0], &quot;ls&quot;) == 0 &amp;&amp; strcmp(cmd_args[0], &quot;ls&quot;) != 0)                cmd_args_temp[index++] = (char *)&quot;--color=auto&quot;;            while (cmd_args_temp[index++] = strtok(NULL, SEP))                ;            index--; // while 会多 +1，需要重新操作一下            // 从原本数组的第二位开始往后设置            for (j = 1; j &lt; cmd_args_num; j++)            &#123;                cmd_args_temp[index++] = cmd_args[j];            &#125;            // 替换掉原本的数组            cmd_args_num = index;              // 此时的 index 长度正确，不需要 -1            for (j = 0; j &lt; cmd_args_num; j++) // 因为 while 最后会多 ++ 一次，所以需要 -1            &#123;                // 原本的位置没有那么大空间，放不下，不能拷贝                // strcpy(cmd_args[j],cmd_args_temp[j]);                cmd_args[j] = cmd_args_temp[j];                // printf(&quot;temp[%d] %s   args[%d] %s\\n&quot;,j,cmd_args_temp[j],j,cmd_args[j]);            &#125;            cmd_args[j] = NULL; // 最后一个位置设置成 NULL            return true;        &#125;    &#125;    return false;&#125;\n\n其实肯定是有更好的方案的，但是我还没想出来咋弄。现在这个能跑就 OK，哈哈\n以最基本的 ll 命令来测试以下，替换成功！修改已有的别名也是没有问题的\n[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# alias ll=&#x27;ls -l&#x27;[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# lltotal 60-rw-rw-r-- 1 muxue muxue   136 Oct 15 23:21 makefile-rwxrwxr-x 1 muxue muxue 14040 Oct 16 17:05 myshell-rw-rw-r-- 1 muxue muxue  8217 Oct 16 16:59 myshell.c-rw-rw-r-- 1 muxue muxue  6942 Oct 15 22:38 myshell_err.c-rwxrwxr-x 1 muxue muxue  9072 Oct 16 17:08 test-rw-rw-r-- 1 muxue muxue   130 Oct 15 23:22 test.cpp-rw-rw-r-- 1 muxue muxue    21 Oct 16 00:11 test.pybash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# alias ll=&#x27;ls -l -a&#x27;[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# lltotal 68drwxrwxr-x  2 muxue muxue  4096 Oct 16 17:08 .drwxrwxr-x 13 muxue muxue  4096 Oct 15 17:31 ..-rw-rw-r--  1 muxue muxue   136 Oct 15 23:21 makefile-rwxrwxr-x  1 muxue muxue 14040 Oct 16 17:05 myshell-rw-rw-r--  1 muxue muxue  8217 Oct 16 16:59 myshell.c-rw-rw-r--  1 muxue muxue  6942 Oct 15 22:38 myshell_err.c-rwxrwxr-x  1 muxue muxue  9072 Oct 16 17:08 test-rw-rw-r--  1 muxue muxue   130 Oct 15 23:22 test.cpp-rw-rw-r--  1 muxue muxue    21 Oct 16 00:11 test.pybash 等待子进程成功！code: 0, sig: 0[慕雪 @FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n结语  就这样，一个最基本的 bash 或者说 shell 就被我们搞定啦\n其实内建命令远不止 3 里面提到的那几个，不过我们学习的目的已经达到了~ 也没必要死磕在这里\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】动静态库","url":"/posts/2737580475/","content":"在最初  学习 GCC 的使用  的时候，提到了动态、静态库的创建办法。今天就让我们来详细了解一番，它们之间究竟有何不同吧！\n\n\n\n演示所用系统：centos7.6\n\n[TOC]\n1. 动态库和静态库  先来了解一下动态库和静态库的基本概念吧！\n\n静态库.a 程序编译链接的时候，把静态库的代码连接到自己的可执行程序中，程序运行的时候将不再需要静态库\n动态库.so 程序在运行的时候才去链接动态库的代码，多个程序共享库的代码\n\n2. 生成\n测试所用代码 👉 点我\n\n我写好了两个头文件和两个源文件，为了减少博客篇幅，此处只贴出 .c 的函数实现\n//myMath.c#include&quot;myMath.h&quot;int Add(int a,int b)&#123;    return a+b;&#125;//myPrint.c#include &quot;myPrint.h&quot;void Print(const char* msg)&#123;    printf(&quot;time: %d, msg: %s\\n&quot;,(unsigned int)time(NULL),msg);&#125;\n\n2.1 静态库  生成静态库所用命令为ar -rc，对应的完整 make 操作如下\nlibMytest.a:myMath.o myPrint.o\tar -rc libMytest.a myMath.o myPrint.omyMath.o:myMath.c\tgcc -c myMath.c -o myMath.omyPrint.o:myPrint.c\tgcc -c myPrint.c -o myPrint.o\n\n生成好静态库后，我们可以用  ar -tv 命令来查看该库的目录列表\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ ar -tv libmytest.arw-rw-r-- 1001/1001   1240 Nov  3 09:28 2022 myMath.orw-rw-r-- 1001/1001   1632 Nov  3 09:28 2022 myPrint.o[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ \n\n2.2 动态库  动态库的生成无需额外的命令，只需要在 gcc 编译的时候，指定 -shared 即可\n同时，依赖的 .o 文件也需要用 -fPIC 来编译\n-fPIC 与位置无关码，和动态库的特性有关-shared 代表需要编译一个动态库\n\n其 make 操作如下\nlibmytest.so:myMath.o myPrint.o\tgcc -shared -o libmytest.so myMath.o myPrint.omyMath.o:myMath.c\tgcc -fPIC -c myMath.c -o myMath.omyPrint.o:myPrint.c\tgcc -fPIC -c myPrint.c -o myPrint.o\n\n2.3 一并发布  这里我写了一个更加完整的 makefile，可以同时编译生成动静态库，并将其打包到一个指定的文件夹内\n.PHONY:allall:libmytest.so libmytest.a.PHONY:liblib:\tmkdir -p lib-static/lib\tmkdir -p lib-static/include\tcp *.a lib-static/lib\tcp *.h lib-static/include\tmkdir -p lib-dynamic/lib\tmkdir -p lib-dynamic/include\tcp *.so lib-dynamic/lib\tcp *.h lib-dynamic/includelibmytest.so:myMath.o myPrint.o\tgcc -shared -o libmytest.so myMath.o myPrint.omyMath.o:myMath.c\tgcc -fPIC -c myMath.c -o myMath.omyPrint.o:myPrint.c\tgcc -fPIC -c myPrint.c -o myPrint.olibmytest.a:myMath.o myPrint.o\tar -rc libmytest.a myMath.o myPrint.omyMath_s.o:myMath.c\tgcc -c myMath.c -o myMath_s.omyPrint_s.o:myPrint.c\tgcc -c myPrint.c -o myPrint_s.o.PHONY:cleanclean:\trm -rf *.o *.a *.so lib-static lib-dynamic\n\n3. 使用#include &quot;myPrint.h&quot;#include &quot;myMath.h&quot;#include &quot;stdio.h&quot;int main()&#123;    printf(&quot;ret %d\\n&quot;,Add(1,2));    Print(&quot; 这是一个测试 &quot;);    return 0;&#125;\n\n当我们使用了动静态库后，就没有办法直接编译这个可执行程序了\nmuxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ gcc test.c/tmp/ccKHwYHv.o: In function `main&#x27;:test.c:(.text+0xf): undefined reference to `Add&#x27;test.c:(.text+0x2a): undefined reference to `Print&#x27;collect2: error: ld returned 1 exit status[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ \n\n这是因为，gcc 没办法找到我们对应的头文件\n\n&quot;&quot;是在当前路径下找\n&lt;&gt;是在库目录下面找\n\n因为我们的头文件既不在当前路径，也不在系统的库中，所以 gcc 就没有办法找到头文件和函数声明\n3.1 静态库  链接静态库的方法如下\ngcc test.c -L../lib-static/lib/ -I../lib-static/include/ -lmytest -o test\n\n\n-L选项后带的是库的路径\n-I选择后带的是头文件的搜索路径\n-l(小写的 L)选项带的是库的名字，需要去掉库文件名前面的 lib 和后缀.a\n-o test代表生成可执行文件名为 test\n\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ gcc test.c -L../lib-static/lib/ -I ../lib-static/include/ -lmytest -o test[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ ./testret 3time: 1667441311, msg: 这是一个测试[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ \n\n特点  静态库的特点便是，其库的实现已经被编译链接进入了可执行程序，即便我们将库给删除，也不影响可执行程序的运行\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ make cleanrm -rf *.o *.a *.so lib-static lib-dynamic[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ lltotal 24-rw-rw-r-- 1 muxue muxue  702 Nov  3 09:28 makefile-rw-rw-r-- 1 muxue muxue   60 Nov  3 08:52 myMath.c-rw-rw-r-- 1 muxue muxue   35 Nov  3 08:51 myMath.h-rw-rw-r-- 1 muxue muxue  117 Nov  3 09:01 myPrint.c-rw-rw-r-- 1 muxue muxue   77 Nov  3 09:01 myPrint.hdrwxrwxr-x 2 muxue muxue 4096 Nov  3 09:50 test[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ ./test/./testret 3time: 1667440486, msg: 这是一个测试[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ \n\n如果我们把自己的库的实现丢入了系统的库目录下（一般是 /lib64/）编译的时候就不需要带-L 选项了，只需要用 -l 指定库名即可\ngcc test.c -lmytest\n\n但是将自己的库丢入系统库路径下的操作  并不推荐 ，就和你将自己的可执行程序丢入/usr/bin 路径里面一样，会污染系统的环境\n\n3.2 动态库  动态库和静态库链接的基本方式是一样的\ngcc test.c -L../lib-dynamic/lib/ -I ../lib-dynamic/include/ -lmytest -o testd\n\n这里选项的含义和上面完全一致，不同的是运行的时候\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ ./testd./testd: error while loading shared libraries: libmytest.so: cannot open shared object file: No such file or directory[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ \n\n直接运行，你会发现报错了！这个报错的大概意思就是找不到动态库文件\nldd 命令  使用 ldd 命令查看 testd 可执行文件的  动态库  结构，会发现我们自己的库是没有找到的\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ ldd testd        linux-vdso.so.1 =&gt;  (0x00007ffd051fe000)        /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f7de6d19000)        libmytest.so =&gt; not found        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f7de6832000)        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f7de662e000)        /lib64/ld-linux-x86-64.so.2 (0x00007f7de6c00000)[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ \n\n这是因为，动态库的特点便是运行的时候也需要指定！这是一个动态链接的过程！\n动态链接  动态库需要执行  动态链接：在可执行程序开始运行之前，外部函数的机器码由操作系统从磁盘上的该动态库复制到内存中\n刚刚我们的指定只是告诉了 gcc 编译器库路径在哪儿，但是可执行程序运行的时候并不知道！\n那么如何让可执行程序找到我们的动态库呢？\n\n将动态库拷贝到系统的 /lib64 文件夹中\n通过修改环境变量的方式，类似于 PATH，可执行程序运行的时候，会自动到LD_LIBRARY_PATH 里面找动态库\n修改系统配置文件\n\n3.3 找到动态库 3.3.1 环境变量 LD_LIBRARY_PATH 和修改 PATH 的环境变量一样，我们可以通过修改环境变量的方式增加动态库的查找路径\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/muxue/git/linux/code/22-11-02_动静态库 /lib-dynamic/lib/\n\n修改了之后的环境变量如下\nLD_LIBRARY_PATH=:/home/muxue/.VimForCpp/vim/bundle/YCM.so/el7.x86_64:/home/muxue/.VimForCpp/vim/bundle/YCM.so/el7.x86_64:/home/muxue/.VimForCpp/vim/bundle/YCM.so/el7.x86_64:/home/muxue/git/linux/code/22-11-02_动静态库 /lib-dynamic/lib/\n\n再次运行./testd 成功执行！\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/muxue/git/linux/code/22-11-02_动静态库 /lib-dynamic/lib/[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ ./testdret 3time: 1667443224, msg: 这是一个测试\n\n修改配置文件的办法，便是将该路径永久写入环境变量（修改环境变量的操作只对当前 bash 有效）这里就不演示辣！\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ ldd testd        linux-vdso.so.1 =&gt;  (0x00007ffde04ea000)        /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007fe9000bc000)        libmytest.so =&gt; /home/muxue/git/linux/code/22-11-02_动静态库 /lib-dynamic/lib/libmytest.so (0x00007fe8ffda1000)        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fe8ff9d3000)        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fe8ff7cf000)        /lib64/ld-linux-x86-64.so.2 (0x00007fe8fffa3000)\n\nldd 命令的结果也显示出了我们自己写的动态库的路径\n3.3.2 &#x2F;etc&#x2F;ld.so.conf.d除了修改环境变量，我们还可以修改 /etc/ld.so.conf.d 下的文件\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ ls /etc/ld.so.conf.dbind-export-x86_64.conf  kernel-3.10.0-1160.62.1.el7.x86_64.conf  kernel-3.10.0-1160.76.1.el7.x86_64.confdyninst-x86_64.conf      kernel-3.10.0-1160.71.1.el7.x86_64.conf  mariadb-x86_64.conf[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ \n\n这里的操作非常简单，我们只需要在该目录下新增一个 .conf 文件，并在里面写入动态库的绝对路径即可！\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ ls /etc/ld.so.conf.dbind-export-x86_64.conf  kernel-3.10.0-1160.62.1.el7.x86_64.conf  kernel-3.10.0-1160.76.1.el7.x86_64.conf  mytest.confdyninst-x86_64.conf      kernel-3.10.0-1160.71.1.el7.x86_64.conf  mariadb-x86_64.conf[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ cat /etc/ld.so.conf.d/mytest.conf/home/muxue/git/linux/code/22-11-02_动静态库 /lib-dynamic/lib/[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ \n\n设置了之后，第一次运行，还是显示找不到动态库\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ ./testd./testd: error while loading shared libraries: libmytest.so: cannot open shared object file: No such file or directory[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ \n\n我们只需要执行下面的命令让配文件生效，就 OK 了！\nsudo ldconfig # 子用户权限不够，需要加 sudo\n\n执行完该命令后，可执行程序也能成功运行了 1\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ sudo ldconfig[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ ./testdret 3time: 1667448942, msg: 这是一个测试[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库 /test]$ \n\n测试完毕之后，建议将配置文件删除，并重新加载动态库配置文件\nsudo rm /etc/ld.so.conf.d/mytest.confsudo ldconfig\n\n这样做是避免污染\n3.3.3 在 lib64 下创建一个软连接ln -s /home/muxue/git/linux/code/22-11-02_动静态库 /lib-dynamic/lib/libmytest.so /lib64/libmytest.so\n\n创建软连接的方式和将我们的文件复制进去本质是一样的，只不过软连接只是一个快捷方式，如果我们把源给删了，软连接也会失效\n这部分就不做演示了\n\n4. 优劣 4.1 静态库 静态库编译之后的可执行程序可以脱离静态库运行，也不需要知道库的路径。\n即便这个库被删除，也丝毫不影响我们的可执行程序\n4.2 动态库  动态库的代码只需要一份，所有的可执行程序便都可以使用\n在运行期间，动态库可以被多个进程所共享。但前提是，可执行程序需要知道该动态库的路径，以便将其加载到内存中（或者找到它在内存中的位置）\n\n这样就保证了多个进程同时使用同一个库，节省了内存的消耗，也节省了磁盘空间\n\n这里动态库的可执行文件大小，小于静态库的可执行文件\n\n因为测试的代码不多，所以差距尚不明显\n\n5. 动态库 -fPIC 的作用\n参考https://blog.csdn.net/itworld123/article/details/117587091\n\ngcc -fPIC -c myMath.c -o myMath.o\n\nfPIC 的全称是 Position Independent Code， 用于生成位置无关代码\n\n什么是位置无关代码？\n个人理解是代码无绝对跳转，跳转都为相对跳转\n\n如果我们的静态库中，不使用其他库的代码（比如stdio.h）\nint fuc(int a)&#123;\treturn ++a;&#125;\n\n这时候，就可以再编译的时候不带 -fPIC  否则会报错\n/usr/bin/ld: /tmp/ccCViivC.o: relocation R_X86_64_32 against `.rodata&#x27; can not be used when making a shared object; recompile with -fPIC/tmp/ccCViivC.o: could not read symbols: Bad value\n\n但显然，这种情况是非常少见的，所以我们一般编译动态库的时候，都需要带上这个参数，来实现真正意义上的动态库编译\n\n\n加 fPIC 选项生成的动态库，显然是位置无关的，这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针的值，加上一个偏移得到全局变量 &#x2F; 函数的地址。\n加 fPIC 选项的源文件对于它引用的函数头文件编写有很宽松的尺度。比如只需要包含个声明的函数的头文件，即使没有相应的 C 文件来实现，编译成 so 库照样可以通过。\n对于  不加  fPIC，则加载 so 文件时，需要对代码段引用的数据对象需要重定位，重定位会修改代码段的内容，这就造成每个使用这个 .so 文件代码段的进程在内核里都会生成这个 .so 文件代码段的 copy。每个 copy 都不一样，取决于这个 .so 文件代码段和数据段内存映射的位置。这种方式更消耗内存，优点是加载速度可能会快一丢丢， 弊大于利\n\n\n结语  动静态库的基本认识到这里就 OVER 辣，大家也可以去尝试下载一些第三方的库来使用，比如在树莓派上最常用的 wiringPi 库，还有 C++ 的 boost 库等等\nsudo yum install -y boost-devel\n\n有什么问题，可以在评论区提出哦！\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】进程控制","url":"/posts/2395550697/","content":"阿巴阿巴，进程概念结束了，现在该学习如何控制一个进程了\n\n\n\n所用系统：CentOS 7.6\n\n[TOC]\n1. 进程创建 1.1 fork 关于 linux 下的进程创建其实我们已经接触过了，那便是使用 fork 函数来进行操作\npid_t ret = fork();\n\nfork 的返回值：子进程返回 0、父进程返回子进程 pid；出错返回 -1\n\n小 tips，其实 pid_t 就是 int 类型！\ntypedef __pid_t pid_t;\n\n在上篇程序地址空间的博客中已经提到，当一个进程调用 fork 函数的时候\n\n操作系统会给子进程分配一个新的内存块 mm_struct+ 页表 和内核数据结构 task_strcut 给子进程\n将父进程的部分数据结构拷贝自子进程（写时拷贝）\n将子进程添加系统进程列表当中\nfork返回，开始调度器调度\n\n简单说来，便是 fork 之前只有父进程单独运行。fork 之后父子进程的执行流会分别执行，且相互独立\n\nfork 之后，是父进程先执行还是子进程先执行依赖于调度器的调度。并非一定是父进程先执行！\n\n需要注意的是，子进程虽然共享父进程的所有代码，但是它只能从 fork 之后开始执行\n这里涉及到了 cpu 的 eip 程序计数器（又称 pc 指针）这玩意的作用就是保存当前正在执行的指令的下一条指令！\n\n注意，这里说的是 CPU 执行的指令，并非 linux 下 bash 里面的命令\n\neip 程序计数器会把下一个指令拷贝给子进程，子进程就会从该 eip 所指向的代码处（即 fork 之后的代码）开始运行\nfork 啥时候会出错  如果你写一个循环代码一直创建子进程，那么就有可能创建失败！\n能够创建的  子进程个数  依赖于代码的复杂度\n1.2 写时拷贝  之前已经提到过写时拷贝的概念，这里再次说明一番\n\n\n为什么要写时拷贝，创建子进程的时候直接把数据分开不行吗\n\n答，这样会存在内存浪费！\n\n一般情况下，父进程创建子进程之后，会出现下面的一些情况\n\n父进程的代码和数据，子进程不一定全部都会使用。即便使用、也不一定会进行修改\n理想状态下，可以把父子进程会修改的内容进行分离，不会修改的部分共享即可。但是这样的实现非常复杂\n如果 fork 的时候，就直接分离父子进程的数据，会增加 fork 运行的时间复杂度和空间复杂度\n\n所以最终 linux 采用了写时拷贝的方式，只会在需要的时候，拷贝父子需要修改的数据。这样延迟拷贝，变相提高了内存的使用率\n2. 进程终止 2.1 程序退出码 在之前学习 C&#x2F;C++ 的时候，我们知道 main 函数是一个程序的入口函数，那么你知道 main 函数内部的返回有何用，又被谁接收了吗？\nint main()&#123;\treturn 0;&#125;\n\n使用 echo $? 命令查看环境变量，可以看到我们进程的推出码\n\nint main()&#123;\treturn 10;&#125;\n\n修改对应的返回值，再次运行程序，可以看到不同的结果\n\n知识点：?环境变量存放的是  上一次运行  的程序的退出码\n[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ echo $?10[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ echo $?0\n\n比如这里我们连续两次访问这个环境变量，可以看到第一次的结果是我们自己运行的程序返回的 10，第二次的结果是 0（echo 命令的返回值）\n\n2.1.1 strerror那么，这个程序退出码有什么含义呢？\n这里我们使用 for 循环打印一下库函数中 strerrror 函数内记录的错误码\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;    int i=0;    for(i=0;i&lt;100;i++)    &#123;        printf(&quot;[%d] %s\\n&quot;,i,strerror(i));    &#125;    return 0;&#125;\n\n可以看到，100 个错误码被打印了出来\n\n进一步加大循环的次数，能看到 C 语言中定义的错误码一共是 134 个。后续全部打印unknown error\n\n我们设计程序的退出码的时候，可以参照 C 语言库函数的错误码来进行设置，这样能更好地和库内部进行对接，或用 strerror 函数来获取到错误信息\n\n这就是用错误码来实现的  异常管理\n\n2.2 程序退出的几种状态  一般情况下，程序有下面的几种退出状态：\n\n代码跑完，结果与预期相符\n代码跑完，结果有问题\n代码没有跑完，提前出现异常终止，或者被外部关闭\n\n一般情况下，我们不会去在乎一个进程为何会成功；而更在乎一个错误的进程到底哪儿有 bug。所以就需要想办法获取到这个进程的错误码\n错误码表征了程序退出的信息，交由父进程进行读取\n上面我们在 bash 中能通过 echo 读取上一个进程的退出码，那是因为我们自己运行的可执行程序，其父进程就为当前的 bash。bash 接受了我们进程的退出码，放入到了环境变量中\n\n2.3 终止的常见做法  一般情况下，我们可以在 main 函数中 return，或者在任何地方使用 exit() 来终止程序\n这里还需要提及另外一个版本的exit()，即_exit\n\n最可见的区别便是，exit 会刷新缓冲区，而 _exit 不会\nvoid test2()&#123;    printf(&quot;i&#x27;m good, exit&quot;);    exit(0);&#125;void test3()&#123;    printf(&quot;i&#x27;m good, _exit&quot;);    _exit(0);&#125;\n\n这里我先调用 test2 函数，输出的结果是这样的👇\n[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ gcc test_strerror.c -o test &amp;&amp; ./testi&#x27;m good, exit[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ \n\n如果调用的是 test3，则会出现下面的情况\n[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ gcc test_strerror.c -o test &amp;&amp; ./test[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ \n\n程序什么都没有打印！\n缓冲区  这部分是基础 IO 的知识\nlinux 下有一个输入输出的缓冲区，当我们调用 printf 的时候，系统不会立马打印，而是会将待打印的内容先写入缓冲区，直到我们输出 \\n 或者调用 fflush 函数手动刷新缓冲区。\nfflush(stdout);// 手动刷新缓冲区\n\nexit 和_exit在 _exit 的 man 手册中也能看到，该函数会立即干掉这个进程；而 exit 还会做一些其他的操作\n\n2.4 终止的时候，内核做了什么？我们知道，进程 &#x3D; 内核结构task/mm_struct 等+ 进程代码、数据\n操作系统可能并不会释放该进程的task_struct/mm_struct，而是留给下一个进程使用！\n要知道，如果想使用一个结构体，就需要对它进行开空间和初始化操作。而在操作系统中，创建、终止进程是一个非常高频的操作。如果总是不断的创建内核结构再释放，其内存利用率就很低，而且拖慢系统运行速度。\n这时候系统就会使用内核的  数据结构缓冲池，又称 slab 分派器，来管理这些仍待使用的内核结构。当有新进程出现的时候，更新内核结构的信息，并将其插入到运行队列中\n\n3. 进程等待  之前讲过子进程退出，父进程如果不管不顾，就会造成  僵尸进程的问题，从而导致内存泄漏等一系列问题\n\n另外，僵尸进程一旦出现，即便是 kill -9 也无法杀掉这个进程\n\n所以父进程需要监看子进程的退出状态，并进行相应的操作\n父进程通过  进程等待  的方式回收子进程资源，获取子进程的退出信息\n\n3.1 如何等待  进程等待这里我们需要用到两个函数\npid_t wait(int*status);pid_t waitpid(pid_t pid, int *status, int options);\n\n它们的头文件是\n#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;\n\n3.2 wait先来康康第一个，其作用是等待子进程退出，status是一个输出型参数，子进程退出后，我们可以从中获取到子进程的退出信息\n\nstatus 是从子进程的 task_struct 中拿出来的，子进程会将自己的退出码写入task_struct\n如果我们不关心子进程的退出状态，则可以给 status 传一个NULL 空指针\n若等待失败，则返回 -1\n\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 5;        while(i--)        &#123;            printf(&quot; 我是子进程 %-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);            sleep(1);        &#125;        printf(&quot; 子进程退出 \\n&quot;);        exit(0);    &#125;    else    &#123;            printf(&quot; 我是父进程 %-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(5);        int status = 0;        pid_t st = wait(&amp;status);        printf(&quot; 等待成功, 子进程 pid:%d, 状态信息：%d\\n&quot;,st,status);        sleep(5);    &#125;           return 0;&#125;\n\n\n嗯，看起来没啥问题，我们成功获取了子进程的 pid 以及退出码 0\n那如果我们修改一下子进程中 exit 的值呢？\nexit(11);\n\n\n呀，出问题了，为何状态码变成 2816 了？\n3.2.1 关于 status实际上，输出型参数中 status 的值并非是完整的退出状态信息，其分为下面两种情况\n\n所以说，正确访问状态码的方式，是先将 status 右移 8 位，再用按位与取出状态码\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 5;        while(i--)        &#123;            printf(&quot; 我是子进程 %-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n&quot;,getpid(),getppid(),ret,&amp;ret);            //i++;            sleep(1);        &#125;        printf(&quot; 子进程退出 \\n&quot;);        exit(11);    &#125;    else    &#123;            printf(&quot; 我是父进程 %-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(5);        int status = 0;        pid_t st = wait(&amp;status);        //printf(&quot; 等待成功, 子进程 pid:%d, 状态信息：%d\\n&quot;,st,status);// 直接打印 status 是错误的！        //status 的低 16 位才有效，其中这 16 位的高 8 位是状态码        printf(&quot; 等待成功, 子进程 pid:%d, 状态信息：%d\\n&quot;,st,(status&gt;&gt;8)&amp;0xFF);//0xff 是 8 个 1        sleep(5);    &#125;           return 0;&#125;\n\n\n再来修改一下 exit 的值为 200，依旧正确！\n子进程退出  等待成功, 子进程 pid:770, 状态信息：200\n\n\n3.3 waitpid该函数的原型如下\npid_t waitpid(pid_t pid, int *status, int options);\n\n\npid：&gt;0指定等待子进程 pid；-1等待所有子进程\nstatus：同 wait，为输出型参数\noptions：若设置为 0，则进行  阻塞  等待；其余选项见下图\n\n\n返回值：\n\n正常等待，返回子进程的 pid\n如果设置了 options，而 waitpid 发现没有已退出的子进程可收集，返回 0\n调用中出错，返回 -1。此时errno 会被设置成相对应的值来显示错误\n\nwait(): on success, returns the process ID of the terminated child; on error, -1 is returned.waitpid(): on success, returns the process ID of the child whose state has changed; if WNOHANG  was  specified  and  one  or  more child(ren) specified by pid exist, but have not yet changed state, then 0 is returned.  On error, -1 is returned.\n\n代码示例\nint main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 4;        while(i--)        &#123;            printf(&quot; 我是子进程 %-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n&quot;,getpid(),getppid(),ret,&amp;ret);            //i++;            sleep(1);        &#125;        printf(&quot; 子进程退出 \\n&quot;);        exit(0);    &#125;    else    &#123;            printf(&quot; 我是父进程 %-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(5);        int status = 0;        pid_t st = waitpid(ret,&amp;status,0);// 指定等待上面创建的子进程        //status 的低 16 位才有效，其中这 16 位的高 8 位是状态码        printf(&quot; 等待成功, 子进程 pid:%d, 状态信息：%d\\n&quot;,st,(status&gt;&gt;8)&amp;0xFF);//0xff 是 8 个 1        sleep(5);    &#125;          return 0;&#125;\n\n\n3.4 信号终止  目前 linux 支持的信号如下，在后续信号的章节会单独讲解！\n\n\n前面提到了，除了正常的终止，status 中还可以保存信号终止的信息\n\n这里的 core dump 标志是用来干嘛的我们暂且不提（后续信号部分会有讲解）先来试试用 kill 来干掉子进程！\n这里我们要取出的是 status 中最低 7 位的数据，就需要按位与一个  二进制  末尾是 7 个 1 的数字\n注意 ：如果子进程是因为 信号  退出，那么我们  不需要  关注退出码，其没有意义！\nint main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 20;        while(i--)        &#123;            printf(&quot; 我是子进程 %-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n&quot;,getpid(),getppid(),ret,&amp;ret);            //i++;            sleep(1);        &#125;        printf(&quot; 子进程退出 \\n&quot;);        exit(0);    &#125;    else    &#123;            printf(&quot; 我是父进程 %-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(30);        int status = 0;        pid_t st = waitpid(ret,&amp;status,0);// 指定等待上面创建的子进程        //status 的低 16 位才有效，其中这 16 位的高 8 位是状态码        printf(&quot; 等待成功, 子进程 pid:%d, 状态：%d，信号：%d\\n&quot;,st,(status&gt;&gt;8)&amp;0xFF,status&amp;0x7F);//0xff 是 8 个 1        sleep(10);    &#125;          return 0;&#125;\n\n 程序最开始的时候，子进程正常创建，父进程等待子进程结束\n\n这里使用 kill 给子进程发信号，干掉了子进程\n[muxue@bt-7274:~/git/c_code]$ kill -9 5952[muxue@bt-7274:~/git/c_code]$ \n\n父进程 sleep 结束后执行 waitpid 获取到了子进程的结束信息以及信号 9\n\n同时通过之前写的检测脚本\nwhile :; do ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\n能看到子进程进入 z 僵尸状态\n\n父进程回收子进程的过程\n\n换一个 kill 的信号，父进程也能正确获得其结果\n[muxue@bt-7274:~/git/c_code]$ kill -30 7607[muxue@bt-7274:~/git/c_code]$ \n\n我是子进程 7607 , ppid:7606 , ret:0    , &amp;ret:0x7ffccf2aeb20我是子进程 7607 , ppid:7606 , ret:0    , &amp;ret:0x7ffccf2aeb20等待成功, 子进程 pid:7607, 状态：0，信号：30\n\n除了我们可以手动使用 kill 给进程发信号，一些错误也会让进程自己退出。比如信号 8 就是浮点数错误，可以用除 0 来复现这个错误\n操作系统是怎么知道我们除 0 了？\n\n在 CPU 内有一个状态寄存器，当 cpu 进行运算的时候出错了，会更新状态寄存器。操作系统检测到 CPU 用状态寄存器给他报了个错，就会识别错误类型，并通过信号干掉当前运行的进程\n我们运行的进程中的软件错误，部分是会在硬件层面上体现的\n\n3.5 库里面提供的宏  自己写按位与多麻烦呀，库里面提供了几个宏供我们使用\n\nWIFEXITED(status)  查看子进程是否是正常退出的，正常退出为真\nWIFSIGNALED(status)查看子进程是否为信号终止，信号终止返回真\nWEXITSTATUS(status) 提取子进程退出码\nWTERMSIG(status) 提取子进程退出信号\n\n// 其余部分代码和上面相同，子进程 exit(11)int status = 0;pid_t st = waitpid(ret,&amp;status,0);// 指定等待上面创建的子进程if(WIFEXITED(status))// 子进程正常退出返回真&#123;       printf(&quot; 等待成功, 子进程 pid:%d, 状态：%d，信号：%d\\n&quot;,st,WEXITSTATUS(status),WTERMSIG(status));&#125;else&#123;    printf(&quot; 非正常退出, 子进程 pid:%d, 状态：%d，信号：%d\\n&quot;,st,WEXITSTATUS(status),WTERMSIG(status));&#125;\n\n下图为子进程正常exit\n\n下图为子进程被 kill -9 干掉\n\n3.6 阻塞等待和非阻塞等待  前面的 waitpid 函数中的 option 参数就和  阻塞 &#x2F; 非阻塞等待  有关\n0       阻塞WNOHANG 非阻塞\n\n3.6.1 阻塞等待  当我们调用某些函数的时候，因为  条件不就绪，需要我们进行阻塞等待\n\n本质：当前程序自己变成阻塞状态，当一切就绪的时候再被唤醒。\n这时候我们等待的不是硬件资源，而是等待  子进程  运行结束（软件资源）\n\n阻塞等待时，将父进程放入子进程 task_struct 中的等待队列。当操作系统检测出子进程退出，就从等待队列中  唤醒  父进程，阻塞等待成功！\n\n给 waitpid 的option传入 0，即为阻塞等待\npid_t st = waitpid(-1,&amp;status,0);// 阻塞等待\n\n在子进程被信号干掉或者执行完毕退出之前，父进程不会向后执行代码。在用户层面看来，就是一个程序卡住了\n3.6.2 非阻塞等待  给waitpid的option 传入WNOHANG，即为非阻塞等待\n等待期间，父进程可以干其他的事情\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int add(int a,int b)&#123;    return a+b;&#125;int pls(int a,int b)&#123;    return a*b;&#125;int main()&#123;    pid_t id = fork();    if(id == 0)    &#123;        // 子进程        int i =5;        while(i--)        &#123;            printf(&quot; 我是子进程, 我的 PID: %d, 我的 PPID:%d\\n&quot;, getpid(), getppid());            sleep(2);        &#125;        exit(0);    &#125;    else if(id &gt;0)    &#123;        // 父进程        // 基于非阻塞的轮询等待方案        int status = 0;        int i = 1, j=2;        while(1)        &#123;            pid_t ret = waitpid(-1, &amp;status, WNOHANG);            if(ret &gt; 0)            &#123;                printf(&quot; 等待成功, %d, exit code: %d, exit sig: %d\\n&quot;, ret, WIFEXITED(status), WTERMSIG(status));                break;            &#125;            else if(ret == 0)            &#123;                // 等待成功了，但子进程没有退出                printf(&quot; 子进程好了没？没有，父进程做其他事情 \\n&quot;);                printf(&quot;add %d  &quot;,add(i++,j++));                printf(&quot;pls %d\\n&quot;,pls(i++,j++));                sleep(1);            &#125;            else&#123;                //err                printf(&quot; 父进程等待出错！\\n&quot;);                break;            &#125;        &#125;    &#125;    return 0;&#125;\n\n这里我们给父进程写了一个死循环，一直等待子进程退出。每一次循环都会调用一次 waitpid 的接口，直到成功获取了子进程的退出信息\n这种多次调用 waitpid 接口的方式又被称为  轮询检测\n\n举个具体例子，当我们使用一个聊天软件需要加载图片的时候，父进程（聊天框）可以先显示一个图片的  加载图 ，告诉你图片正在加载（子进程）。而你还是可以正常浏览其他人的发言。等图片加载完毕（子进程退出）之后，父进程就可以把那个 临时  的加载图替换成获取到的图片本身，这就是一次成功的非阻塞等待\n\n4. 进程替换  在之前的 fork 中，我们的子进程都是运行的已经预先写好的代码，或者说是继承了父进程的代码继续向后执行。\n进程替换  就是让子进程可以执行磁盘里面其他的  可执行文件 ，包括 Linux 系统的命令、其他语言写的代码py c++ php 等等……\n4.1 原理  其实就是让子进程通过调用操作系统的接口，来执行一个已有的可执行程序\n\n这个过程中并没有创建新的子进程，本质上还是当前子进程\n\n程序替换的过程\n\n将磁盘中的程序加载进入内核结构\n重新建立页表映射，因为是子进程调用的程序替换，那么就会修改子进程的页表映射\n效果：子进程代码和父进程彻底分离，子进程执行了一个  全新的程序\n\n\n4.2 如何替换  系统提供了非常多的函数接口，供我们在一个程序中调用系统中其他的可执行程序\n\n\n要想调用，首先要找到这个程序在那儿，以及要用什么办法执行这个程序（命令行参数）下面以具体的例子来了解一下吧\n\n需要注意的是：我们需要先用 fork 创建子进程，再调用上面这些函数接口来使用其他可执行文件。这些函数接口本身并  不会创建新的子进程！\n\n4.3 execlint execl(const char *path, const char *arg, ...);\n\n\npath 是需要运行程序的路径\narg代表需要执行的程序\n...是可变参数，可以传入不定量的参数。这里我们填入的是命令行的参数\n\n说起来学到了这里我才知道原来 C 语言支持可变参数……\n#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;    printf(&quot; 开始测试 \\n\\n&quot;);    int ret = execl(&quot;/usr/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);    printf(&quot; 执行结束 %d\\n&quot;,ret);    return 0;&#125;\n\n需要注意的是，当我们填入命令行参数的时候，必须要以 NULL 作为参数的结尾\n\n我们会发现，调用了其他可执行程序之后，在后面的 printf 函数并没有被执行！\n这是因为，当我们用这个函数来调用其他可执行程序，本质上已经把当前的  代码和数据  替换掉了！既然是替换，那么原本的 printf(&quot; 执行结束 %d\\n&quot;,ret); 肯定也不会执行\n返回值问题  那execl不是有一个 int 类型的返回值吗？如果程序替换了之后不会执行后面的代码，那这个返回值还有什么用呢？\n\n查手册可以看到，这个返回值只有出错的时候才会返回 -1，同时会更新ERRNO\nint main()&#123;    printf(&quot; 开始测试 \\n\\n&quot;);    int ret = execl(&quot;/usr/bin/&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);    printf(&quot; 执行结束: %d\\n&quot;,ret);    printf(&quot; 错误原因: %s\\n&quot;,strerror(errno));    return 0;&#125;\n\n现在我们把执行文件改成 usr/bin/ 这个错误文件，那么就会调用失败，同时可以看到调用失败的原因是，我们没有权限去执行/usr/bin\n\nint ret = execl(&quot;/usr/erqer/&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);\n\n如果改成一个乱七八糟的路径，也会打印出错误结果为“文件或路径不存在”\n\n根据这个特效，我们在执行 exec 这些替换函数的时候，其实没有必要去  判断  返回值。因为这些函数只有出错的时候，才会执行后面的代码！\n\n无需判断返回值，直接打印 errno 找出错误原因即可\n\n替换别的代码  之前说过，替换不仅可以替换系统的命令，还可以替换成其他语言的代码\n比如下面是一个最简单的 py 代码\nprint(&quot; 我是一个 python 程序！&quot;)#python 中 print 会默认换一行\n\n我们在 C 中利用 execl 来调用这个自己写的 python 程序。如果你不知道你系统中有没有 python，或者不知道它的路径，可以用 which 来查看位置\n\nint main()&#123;    printf(&quot; 开始测试 \\n\\n&quot;);    int ret = execl(&quot;/usr/local/bin/python3&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);    //int ret = execl(&quot;/usr/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);    printf(&quot; 执行结束: %d\\n&quot;,ret);    printf(&quot; 错误原因: %s\\n&quot;,strerror(errno));    return 0;&#125;\n\n可以看到，python 程序被成功执行！\n\n子进程替换  了解了替换程序的基本方法了之后，可以先来试试写一个父子进程\n这里让父进程进行 3.6.2 里面的轮询检测\nint add(int a,int b)&#123;    return a+b;&#125;int pls(int a,int b)&#123;    return a*b;&#125;int main()&#123;    pid_t id = fork();    if(id == 0)    &#123;        // 子进程        int i = 3;        while(i--)        &#123;            printf(&quot; 我是子进程, 我的 PID: %d, 我的 PPID:%d\\n&quot;, getpid(), getppid());            sleep(2);// 便于观察            int ret = execl(&quot;/usr/local/bin/python3&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);            printf(&quot; 子进程执行出错: %d\\n&quot;,ret);            printf(&quot; 子进程错误原因: %s\\n&quot;,strerror(errno));            exit(-1);        &#125;    &#125;    else if(id &gt;0)    &#123;        // 父进程        // 基于非阻塞的轮询等待方案        int status = 0;        int i = 1, j=2;        printf(&quot; 我是父进程, 我的 PID: %d, 我的 PPID:%d\\n&quot;, getpid(), getppid());        while(1)        &#123;            pid_t ret = waitpid(-1, &amp;status, WNOHANG);            if(ret &gt; 0)            &#123;                printf(&quot; 等待成功, %d, exit code: %d, exit sig: %d\\n&quot;, ret, WIFEXITED(status), WTERMSIG(status));                break;            &#125;            else if(ret == 0)            &#123;                // 等待成功了，但子进程没有退出                printf(&quot; 子进程好了没？没有，父进程做其他事情 \\n&quot;);                printf(&quot;add %d  &quot;,add(i++,j++));                printf(&quot;pls %d\\n&quot;,pls(i++,j++));                sleep(1);            &#125;            else&#123;                //err                printf(&quot; 父进程等待出错！\\n&quot;);                break;            &#125;        &#125;    &#125;    return 0;&#125;\n\n\n可以看到，子进程替换了 python 程序成功了之后，不会执行后面的printf\n这里的 exit code 也被设置成了 1\n\n这里我自己想出来了一个问题，这里的 exit code 和我们 python 程序里面设置的有没有关系呢？来试试~\nprint(&quot; 我是一个 python 程序！&quot;)exit(10)#execl 父进程接收到的退出码和这里没有关系\n\nemm 结果没变，说明没有关系\n我是一个 python 程序！等待成功, 20333, exit code: 1, exit sig: 0\n\n即便我们 python 程序里面有 bug，这里也不会有啥变化\nprint(&quot; 我是一个 python 程序！&quot;)a =10/0\n\n我是一个 python 程序！Traceback (most recent call last):  File &quot;/home/muxue/git/linux/code/22-10-13_exec/test.py&quot;, line 3, in &lt;module&gt;    a =10/0ZeroDivisionError: division by zero等待成功, 21179, exit code: 1, exit sig: 0\n\n同时我们也可以看到，子进程执行程序替换，是不会影响父进程的（进程具有独立性）\n这是因为数据发生了写时拷贝，程序替换的时候可以理解为代码和数据都通过  写时拷贝  进行了父子的分离（注意分离的是代码和数据，并非父子关系！）\n4.4 execv学会了前面的execl，再来看看这个\nint execv(const char *path, char *const argv[]);\n\n可以看到这个函数莫得可变参数，而是需要我们用一个  指针数组  来传入命令行参数！其余都是一样的！\n\n复习一下，const 修饰指针有下面两种形式\n\n在 * 之前修饰，代表该指针指向  对象的内容  不能被修改（地址里的内容不能改）\n在 * 之后修饰，代表该指针  指向的对象  不能被修改（指向的地址不能改）\n\n\nvoid testExecv()&#123;    printf(&quot; 开始测试 \\n\\n&quot;);    char*const arg[]=&#123;        &quot;ls&quot;,        &quot;-l&quot;,        &quot;-a&quot;,        NULL    &#125;;    int ret = execv(&quot;/usr/bin/ls&quot;,arg);    printf(&quot; 执行结束: %d\\n&quot;,ret);    printf(&quot; 错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n调用成功！\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试total 36drwxrwxr-x  2 muxue muxue  4096 Oct 14 13:36 .drwxrwxr-x 12 muxue muxue  4096 Oct 13 15:19 ..-rw-rw-r--  1 muxue muxue    69 Oct 13 15:24 makefile-rwxrwxr-x  1 muxue muxue 13192 Oct 14 13:36 test-rw-rw-r--  1 muxue muxue  2402 Oct 14 13:37 test.c-rw-rw-r--  1 muxue muxue   111 Oct 14 13:23 test.py[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n\n4.5 execlpint execlp(const char *file, const char *arg, ...);\n\n注意，这里参数的说明从 path 变成了file\n这个函数和 execl 的区别在于，它会自己去系统环境变量的 PATH 里面查找可执行程序\n[muxue@bt-7274:~/git]$ echo $PATH/home/muxue/.vscode-server/bin/d045a5eda657f4d7b676dedbfa7aab8207f8a075/bin/remote-cli:/usr/local/bin:/usr/bin:/usr/local/python3/bin:/usr/local/python3/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin:/usr/local/python3/bin:/usr/local/python3/bin[muxue@bt-7274:~/git]$ \n\n只有找不到这个程序的时候，才会报错！\nvoid testExeclp()&#123;    printf(&quot; 开始测试 \\n\\n&quot;);    int ret = execlp(&quot;python3&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);    printf(&quot; 执行结束: %d\\n&quot;,ret);    printf(&quot; 错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n结果如下，成功调用\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试  我是一个 python 程序！[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n随意指定一个程序，就会报错\nint ret = execlp(&quot;python3300&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);\n\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试  执行结束: -1错误原因: No such file or directory[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n4.6 execvpint execvp(const char *file, char *const argv[]);\n\n知道了 execv/excel 之间的区别，那么 execvp/execlp 之间的区别也就很明显辣！\n同样也是只有传参的区别，其他的操作完全一样\nvoid testExecvp()&#123;    printf(&quot; 开始测试 \\n\\n&quot;);    char*const arg[]=&#123;        &quot;ls&quot;,        &quot;-l&quot;,        &quot;-a&quot;,        NULL    &#125;;    int ret = execvp(&quot;ls&quot;,arg);    printf(&quot; 执行结束: %d\\n&quot;,ret);    printf(&quot; 错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试total 36drwxrwxr-x  2 muxue muxue  4096 Oct 14 13:48 .drwxrwxr-x 12 muxue muxue  4096 Oct 13 15:19 ..-rw-rw-r--  1 muxue muxue    69 Oct 13 15:24 makefile-rwxrwxr-x  1 muxue muxue 13368 Oct 14 13:48 test-rw-rw-r--  1 muxue muxue  2994 Oct 14 13:48 test.c-rw-rw-r--  1 muxue muxue   112 Oct 14 13:45 test.py[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n4.7 execle&#x2F;execvpe&#x2F;execve这几个函数放在一起了，因为它们的使用方法很相似\nint execle(const char *path, const char *arg,                  ..., char * const envp[]);int execvpe(const char *file, char *const argv[],                   char *const envp[]);int execve(const char *filename, char *const argv[],           char *const envp[]);\n\n首先它们的函数名中都有个 e，这个 e 代表的是  环境变量，代表我们可以把特定的环境变量传入其中进行处理。它们的环境变量都是在最末尾传的\n\n\n\n函数\n参数\n说明\n\n\n\nexecle\n可执行文件的完整路径，命令行参数，环境变量\n利用  可变参数  传入命令行参数\n\n\nexecve\n可执行文件的完整路径，命令行参数，环境变量\n利用  数组  传入命令行参数\n\n\nexecvpe\n可执行文件名字，命令行参数，环境变量\n利用  数组  传入命令行参数；只需要传入可执行文件的名字，会自动在 PATH 里面搜索\n\n\n测试  这里我先用 C++ 写一个打印程序，来打印我们的环境变量\n#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;hello c++&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;-------------------------------------------\\n&quot;;    cout &lt;&lt; &quot;PATH:&quot; &lt;&lt; getenv(&quot;PATH&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;-------------------------------------------\\n&quot;;    cout &lt;&lt; &quot;MYPATH:&quot; &lt;&lt; getenv(&quot;MYPATH&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;-------------------------------------------\\n&quot;;        return 0;&#125;\n\n利用 g++ 将其编译为可执行文件mytest\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ lsmakefile  mytest  test  test.c  test.cpp  test.py\n\n下面开始测试\nvoid testExecve()&#123;    extern char ** environ;// 引入外部环境变量    printf(&quot; 开始测试 \\n\\n&quot;);    char*const arg[]=&#123;        &quot;./mytest&quot;,        NULL    &#125;;    int ret = execve(&quot;/home/muxue/git/linux/code/22-10-13_exec/mytest&quot;,arg,environ);    printf(&quot; 执行结束: %d\\n&quot;,ret);    printf(&quot; 错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n\n从 cpp 文件的打印结果可以到，我们传入了完整的环境变量，PATH成功打印，但是 MYPATH 没有打印出来。这是因为环境变量里面没有这个\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ echo $MYPATH[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n利用 export 导入环境变量\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ export MYPATH=4321[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ echo $MYPATH4321[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n再次测试，可以看到两个环境变量都被打印出来了\n\n自己传入环境变量  上面我们是直接引入外部环境变量\nextern char ** environ;// 引入外部环境变量\n\n我们还可以自己整一个数组来传入环境变量\nvoid testExecve()&#123;    extern char ** environ;    printf(&quot; 开始测试 \\n\\n&quot;);    char*const arg[]=&#123;        &quot;./mytest&quot;,        NULL    &#125;;    char*const env[]=&#123;        &quot;MYPATH=this is c test&quot;,        NULL    &#125;;    int ret = execve(&quot;/home/muxue/git/linux/code/22-10-13_exec/mytest&quot;,arg,env);    printf(&quot; 执行结束: %d\\n&quot;,ret);    printf(&quot; 错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n诶，怎么连 PATH 都打印不出来了？？这不是系统里面有的环境变量吗？\n\nchar*const env[]=&#123;    &quot;PATH=path test&quot;,    &quot;MYPATH=this is c test&quot;,    NULL&#125;;\n\n重新设置传入的环境变量，PATH才能成功打印\n\n这说明这几个函数的环境变量参数，在传入的时候，是会  覆盖  掉系统的环境变量的！\n关于环境变量参数的问题  实际上，其余不带 e 的函数，也是能获取到系统的环境变量的（直接继承父进程 BASH 的环境变量）\n而带 e 的函数允许我们  单独控制环境变量\n\n直接传入 extern char ** environ; 的系统环境变量\n将  特定的环境变量  传入\n临时  自定义  一部分环境变量\n\n\n注意 PATH 和自己的可执行程序  这里只对 execvpe 说明一下，如果想用它调用我们自己写的 mytest，那么就需要把 mytest 放入系统PATH 里面，不然是找不到的！\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试  执行结束: -1错误原因: No such file or directory\n\n所以还是用它来调用系统的命令吧\nchar*const arg_[]=&#123;    &quot;ls&quot;,    &quot;-l&quot;,    &quot;-a&quot;,    NULL&#125;;int ret = execvpe(&quot;ls&quot;,arg_,env);\n\n4.8 execve 是系统接口  如果你有注意看，应该会发现 execve 的 man 手册是单独拎出来的，左上角的编号也不一样\n\n这是因为，实际上只有 execve 是 Linux 系统提供的接口\n而其他函数都是 C 语言库中对 execve 的二次封装，来  适应  不同的使用场景！\n4.9 函数命名总结\nl(list)：使用可变参数列表\nv(vector)：用数组传参\np(path)：自动在环境变量 PATH 中搜索\ne(env)：表示自己维护环境变量\n\n\n结语  进程控制章节的内容到这里就基本结束啦，后续有补充的内容会在本博客里面新增！\n感谢你看到最后，有啥问题可以在评论区提出哦\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】进程通信 | 管道","url":"/posts/3971907787/","content":"今天让我们来认识如何使用  管道  来进行进程间通信\n\n\n[TOC]\n1. 何为管道？在最初学习 linux 的基础命令时，接触过用 | 来连接多个命令的操作。当时便提到了这是一个管道操作，但没有详解管道到底是什么。\n1.1 管道是进程间通信的一种方式  管道管道，如同其名，是一个可以让数据在内部  流动  的东西。创建管道，就好比在两个阀门（进程）之间搭了一根  水管，我们可以自由控制管道中水的流向\n不过，在 Linux 系统中提供的管道接口，只支持  单项流动。一个管道只支持从A-&gt;B，不支持B-&gt;A\n要想进行双向通信，则需要创建两个管道\n1.2 进程通信  既然管道是用来进程通信的，那进程通信又是什么，它有何用呢？\n进程通信的目的是让两个进程可以相互交流，包括以下几种情况：\n\n数据传输，从进程 A 发送数据道进程 B\n资源共享，多个进程使用同一个资源\n通知事件，进程 A 向进程 B 发送消息，告知进程 B 发生了什么事件\n进程控制，父进程通过管道来控制子进程的执行，进程 A 控制进程 B 的执行等等\n\n除了管道，我们还可以通过 systemV/POSIX 来实现进程通信\n进程通信的核心思想：让两个进程  获取到同一份资源\n1.3 管道分类  管道分为两种\n\n匿名管道，pipe\n命名管道，管道文件\n\n且听我慢慢道来\n2. 匿名管道  匿名管道主要用于父子进程之间的通信，其使用 pipe 接口来进行创建\n\n\n类似于fork，我们只需要在创建了之后判断函数的返回值就可以了\n其中 pipefd[2] 是一个输出型参数，我们要预先创建好一个 2 个空间的数组，传入该函数。pipe会创建一个匿名管道（可以理解为一个只属于该进程的临时文件）并将  读端  赋值给 pipefd[0]， 写端  赋值给pipefd[1]\n\n如果我们需要父进程写，子进程读，就在父进程关闭读端，子进程关闭写端\n如果我们需要父进程读，子进程写，就在父进程关闭写段，子进程关闭读端\n\n通过这种方式，我们就在父子进程中打通了一个管道，可以让父子进程进行一定的交流\n而 fd 正是我们之前学习过的 Linux 下文件描述符，其管道的读写操作和调用系统接口读写文件完全相同！\n\n博客：linux 文件操作\n\n2.0 康康源码 /include/linux/pipe_fs_i.h 中可以找到管道操作的源码\nstruct pipe_buffer &#123;\tstruct page *page;\tunsigned int offset, len;\tconst struct pipe_buf_operations *ops;\tunsigned int flags;\tunsigned long private;&#125;;\n\n其中我们的管道文件拥有一个缓冲区，这个缓冲区有一个专门的 struct pipe_buf_operations 结构体用来处理它的输入输出方法，以及 flags 用来标识当前缓冲区的装态\n2.1 创建  首先，我们需要用 pipe 接口创建一个匿名管道，使用并不难\n// 1. 创建管道int pipefd[2] = &#123;0&#125;;if(pipe(pipefd) != 0)&#123;    cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;    return 1;&#125;\n\n因为 pipe 是通过 pipefd 这个  输出型参数  来创建管道的，所以我们并不需单独定义一个变量来接受该函数的  返回值，直接在 if 语句中进行判断即可\nvoid TestPipe2()&#123;     // 1. 创建管道    int pipefd[2] = &#123;0&#125;;    if(pipe(pipefd) != 0)    &#123;        cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;        return ;    &#125;    cout &lt;&lt; pipefd[0] &lt;&lt; &quot; &quot; &lt;&lt; pipefd[1] &lt;&lt; endl;&#125;\n\n先来个小测试，打印这两个值可以发现，它其实是  两个不同的文件描述符 。系统分别用 读方法和写方法  打开了同一个文件，供我们使用\n\n0 为读端；1 为写端\n\n[muxue@bt-7274:~/git/linux/code/22-11-04_pipe]$ ./test3 4[muxue@bt-7274:~/git/linux/code/22-11-04_pipe]$ \n\n我们自己打开的文件描述符是从 3 开始的，012对应的是stdin/stdout/stderr\n2.2 父子通信  有了匿名管道，接下来就可以尝试在父子进程中进行通信了\n以  父写子读  为例，我们需要在子进程关闭写段，父进程关闭读端\npipefd是父进程的资源，fork创建子进程之后，该资源会发生一次  写时拷贝，以供父子进程共享\n// 2. 创建子进程pid_t id = fork();if(id &lt; 0)&#123;    cerr &lt;&lt; &quot;fork error&quot; &lt;&lt; endl;    return 2;&#125;else if (id == 0)&#123;    // 3. 子进程管道    // 子进程读取, 关掉写端    close(pipefd[1]);    //...&#125;else&#123;    // 4. 父进程管道    // 父进程写入，关掉读端    close(pipefd[0]);    //...&#125;\n\n处理完之后，后续的操作便是 linux 的文件操作了\n完整代码  以下是完整代码，通过文件接口对 pipefd 进行read/write，就能让父进程发送的字符串被子进程读取道\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;using namespace std;#define NUM 1024// 匿名管道int TestPipe()&#123;    // 1. 创建管道    int pipefd[2] = &#123;0&#125;;    if(pipe(pipefd) != 0)    &#123;        cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;        return 1;    &#125;    // 2. 创建子进程    pid_t id = fork();    if(id &lt; 0)    &#123;        cerr &lt;&lt; &quot;fork error&quot; &lt;&lt; endl;        return 2;    &#125;    else if (id == 0)    &#123;        // 3. 子进程管道        // 子进程来进行读取, 子进程就应该关掉写端        close(pipefd[1]);        char buffer[NUM];        while(1)        &#123;            cout &lt;&lt; &quot;time_stamp: &quot; &lt;&lt; (size_t)time(nullptr) &lt;&lt; endl;            // 子进程没有带 sleep，为什么子进程你也会休眠呢？？            memset(buffer, 0, sizeof(buffer));            ssize_t s = read(pipefd[0], buffer, sizeof(buffer) - 1);            if(s &gt; 0)            &#123;                // 读取成功                buffer[s] = &#x27;\\0&#x27;;                cout &lt;&lt; &quot; 子进程收到消息, 内容是: &quot; &lt;&lt; buffer &lt;&lt; endl;            &#125;            else if(s == 0)            &#123;                cout &lt;&lt; &quot; 父进程写完了，我也退出啦 &quot; &lt;&lt; endl;                break;            &#125;            else&#123;                cerr &lt;&lt; &quot;err while chlid read pipe&quot; &lt;&lt; endl;            &#125;        &#125;        close(pipefd[0]);        exit(0);    &#125;    else    &#123;        // 4. 父进程管道        // 父进程来进行写入，就应该关掉读端        close(pipefd[0]);        const char *msg = &quot; 你好子进程，我是父进程, 这次发送的信息编号是 &quot;;        int cnt = 0;        while(cnt &lt; 10)        &#123;            char sendBuffer[1024];            sprintf(sendBuffer, &quot;%s : %d&quot;, msg, cnt);// 格式化控制字符串            write(pipefd[1], sendBuffer, strlen(sendBuffer));            cnt++;            cout &lt;&lt; &quot;cnt: &quot; &lt;&lt; cnt &lt;&lt; endl;            sleep(1);        &#125;        close(pipefd[1]);        cout &lt;&lt; &quot; 父进程写完了 &quot; &lt;&lt; endl;    &#125;    // 父进程等待子进程结束    pid_t res = waitpid(id, nullptr, 0);    if(res &gt; 0)    &#123;        cout &lt;&lt; &quot; 等待子进程成功 &quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot; 父进程退出 &quot; &lt;&lt;endl;    return 0;&#125;\n\n运行成功，可以看到父进程每次写入之后，子进程读取\n\n父进程休眠的时候，子进程  看起来啥事没有做\n实际上，子进程是在  等待  父进程对管道的写入\n2.3 等待  之前我们学习过进程等待相关的知识点，其中提到了进程有时候需要等待另外一个进程的执行。比如父进程等待子进程执行完成（上面的代码也用了 waitpid 等待）\n而管道，就是进程需要等待的资源之一\n\n如果管道为空，读端必须要等待写端写入，否则无法执行后面的代码\n如果管道满了，写段必须等待读端取走数据，否则不能写入。因为此时写入会覆盖之前的数据\n\n那么，进程是在执行到  什么函数  的时候开始等待的呢？\n答案是：进程将在 read/write 中进行阻塞等待！\n\n执行到 read 的时候，操作系统判断匿名管道中没有有效数据，让执行 read 的进程等待管道写入\n执行到 write 的时候，操作系统判断管道已经满了，就让执行 write 的进程等待管道被读取（而且需要管道被清空了才能继续写入）\n这个判断机制是管道文件中自带的，是一种同步和互斥机制\n相比之下，我们向显示器输出的时候，就没有访问控制，父子进程向显示器输出内容的顺序是完全随机的\n\n本质就是将该进程的 task_strcut 放入等待队列中，并将状态从 R 设置为S/D/T\n写入等待  对第二点进行一个测试，我们把父进程改成死循环，子进程每休眠 3s 读取一次管道\n\n执行后会发现，父进程几乎是在一瞬间写入了 1226 次 数据，随后子进程开始读取，此时我们会发现，尽管子进程已经开始读取了，但是父进程却米有动静。\n\n子进程需要将管道内的数据读取一部分，父进程才能继续执行写入。\n此时父进程就是在 write 里面进行等待的\n\n进一步观察会发现，当子进程读取到 77 次消息的时候，父进程又开始往管道里面写入了\n\n嘿，你猜怎么着？父进程刚好写入了 74 次消息！而子进程继续读取之前的管道信息\n\n这便告诉我们，父进程需要等待子进程将管道内容读取一部分（清理掉一部分）之后，才能继续往管道内部写入。\n\n但在读端，这一切都不一样了\n读取等待  我们让父进程直接睡上 20s 在进行写入，可以看到，子进程是执行到 read 开始等待的\n\n当父进程第一次写入之后，子进程立马打印出了消息的内容。随后父进程又进入了休眠，子进程开始了新一次等待\n\n简而言之，就是只要你不往管道里面写东西，子进程就需要一直等下去！\n源码中的体现  源码中有一个单独的结构体，用来标识管道文件。其中 inode 便是 Linux 下的文件描述符\nstruct pipe_inode_info &#123;\twait_queue_head_t wait;\tunsigned int nrbufs, curbuf;\tstruct page *tmp_page;\tunsigned int readers;\tunsigned int writers;\tunsigned int waiting_writers;\tunsigned int r_counter;\tunsigned int w_counter;\tstruct fasync_struct *fasync_readers;\tstruct fasync_struct *fasync_writers;\tstruct inode *inode;\tstruct pipe_buffer bufs[PIPE_BUFFERS];&#125;;\n\n在这里我们可以看到一个 wait 结构体，其为一个等待队列，维护写入和读取的等待\nstruct __wait_queue_head &#123;\tspinlock_t lock;\tstruct list_head task_list;&#125;;typedef struct __wait_queue_head wait_queue_head_t;\n\nspinlock是何方神圣我们暂且不知，但 list_head 结构体告诉我们，这是一个等待队列的链表\nstruct list_head &#123;\tstruct list_head *next, *prev;&#125;;\n\n\n2.4 控制多个子进程  上面只是实现了父进程和一个子进程的通信，在实际场景中这远远不够用。接下来就来实现一个父进程和多个子进程之间的通信，通过管道给子进程分配不同的任务！\n具体的操作在注释中有所标明，如果有什么问题欢迎评论提出！\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;using namespace std;// 提供三个 lambda 表达式auto func1 = []() &#123;cout &lt;&lt; &quot;this is func1,run by &quot; &lt;&lt; getpid() &lt;&lt;endl;&#125;;auto func2 = []() &#123;cout &lt;&lt; &quot;this is func2,run by &quot; &lt;&lt; getpid() &lt;&lt;endl;&#125;;auto func3 = []() &#123;cout &lt;&lt; &quot;this is func3,run by &quot; &lt;&lt; getpid() &lt;&lt;endl;&#125;;// 通过 func 存在数组中vector&lt;function&lt;void()&gt;&gt; func_v;void LoadFunc()&#123;    func_v.push_back(func1);    func_v.push_back(func2);    func_v.push_back(func3);&#125;// 有一种概念叫做”负载均衡”，在多线程 / 多进程操作中较多使用// 其理念就是每一个进程 / 线程分到的任务应该是平均的，避免出现某一个进程干的活比别人多的情况void BalanceDivide(const vector&lt;pair&lt;int,int&gt;&gt;&amp; processMap)&#123;    // 设置初始化    srand((size_t)time(nullptr));    int total = 15;// 分配 20 次任务    while(total&gt;0)    &#123;        sleep(1);        // 选择一个进程, 选择进程是随机的，没有压着一个进程给任务        // 较为均匀的将任务给所有的子进程 --- 负载均衡        int pick = rand() % processMap.size();        // 选择一个任务        int task = rand() % func_v.size();        // 把任务给一个指定的进程        write(processMap[pick].second, &amp;task, sizeof(task));        // 打印对应的提示信息        cout &lt;&lt; &quot; 父进程指派任务 -&gt;&quot; &lt;&lt; task &lt;&lt; &quot; 给进程: &quot; &lt;&lt; processMap[pick].first &lt;&lt; &quot; 编号: &quot; &lt;&lt; pick &lt;&lt; endl;        total--;    &#125;    // 结束后，写入 0 代表进程终止    for(int i=0;i&lt;processMap.size();i++)    &#123;        int end = -1;        write(processMap[i].second, &amp;end, sizeof(end));        cout &lt;&lt; &quot;stopping process pid = &quot; &lt;&lt; processMap[i].first &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;assign task end!&quot; &lt;&lt; endl;&#125;// 子进程工作，参数为 pipefd[0]void Working(int pfd)&#123;    cout &lt;&lt; &quot;chlid [&quot; &lt;&lt; getpid() &lt;&lt; &quot;] start working&quot; &lt;&lt; endl;    while(1)    &#123;        int optCode = 0;// 读取任务下标        ssize_t s = read(pfd, &amp;optCode, sizeof(optCode));        if(s == 0)        &#123;            break;// 读取了 0 个字节代表错误        &#125;        else if(optCode == -1)        &#123;            break;// 读取到 -1，代表终止        &#125;           assert(s == sizeof(int));// 判断是否为正确的 size        // 执行父进程提供的任务        if(optCode &lt; func_v.size())         &#123;            func_v[optCode]();        &#125;    &#125;    cout &lt;&lt; &quot;chlid [&quot; &lt;&lt; getpid() &lt;&lt; &quot;] end working&quot; &lt;&lt; endl;&#125;int main()&#123;       LoadFunc();// 加载    vector&lt;pair&lt;int,int&gt;&gt; assignMap;    int processNum = 5;    for(int i=0;i&lt;processNum;i++)    &#123;        int pipefd[2];        if(pipe(pipefd)!=0)        &#123;            cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;            continue;        &#125;        int pid = fork();        if(pid==0)// 子进程        &#123;            close(pipefd[1]);// 关闭写            // 开始工作            Working(pipefd[0]);            close(pipefd[0]);            exit(0);// 退出子进程        &#125;        close(pipefd[0]);// 父进程关闭读        pair&lt;int,int&gt; p = &#123;pid, pipefd[1]&#125;;// 进程 pid 和 pipefd 写端的键值对        assignMap.push_back(p);        sleep(1);    &#125;    cout &lt;&lt; &quot;create all process success!&quot; &lt;&lt; endl;    BalanceDivide(assignMap);// 分配任务    // 结束分配后，等待子进程停止运行    for (int i = 0; i &lt; processNum; i++)    &#123;        if (waitpid(assignMap[i].first, nullptr, 0) &gt; 0)        &#123;            cout &lt;&lt; &quot;wait for pid = &quot; &lt;&lt; assignMap[i].first &lt;&lt; &quot; wait success! &quot;                 &lt;&lt; &quot;num: &quot; &lt;&lt; i &lt;&lt; endl;        &#125;        close(assignMap[i].second);    &#125;        return 0;&#125;\n\n先是父进程创建了 5 个子进程\n\n再开始用生成随机数的方式，为每一个进程指派相应的“任务”（其实就是一个函数）\n\n15 次任务指派完毕之后，以一个循环，通过管道写入 -1 作为停止符，让子进程停止工作。同时 main 函数中进行 waitpid 等待子进程运行成功！\n\n2.5 命令行 |命令行中输入的 | 命令，其实就是一个匿名管道\n\n这里我们用 | 运行两个 sleep 命令，再查看这两个进程，可以看到这两个进程是属于同一个父进程的，这说明这两个 sleep 进程是一对兄弟~\n\n当父进程创建一对管道的时候，它可以创建两个子进程，并将管道交付给子进程进行使用\n\n父进程创建管道，创建子进程 AB\n父进程关闭 pipefd[0] 和[1]\n子进程 A 关闭读端，执行写入\n子进程 B 关闭写段，执行读取\n\n而 | 就是将信息转给两个子进程使用的一种匿名管道！这也能解释为什么我们可以先 ps ajx，再用| grep 在内部搜索内容并打印出来。其就是通过匿名管道实现了几个命令中的信息共享\n\n3. 命名管道  和匿名管道不同的是，命名管道是通过一个管道文件来实现的，其有一个文件的“实体”，支持多个进程打开同一个管道文件，执行读写操作，实现管道的交流\n\n我们通过 mkfifo 接口创建一个 FIFO(front in front out/ 先进先出) 的管道文件，这里的注释也表明他是一个命名管道a named pipe\n除了可以用函数调用，mkfifo 同时也是一个命令\nmkfifo 管道名字\n\n3.1 创建管道文件  操作方法和创建一个文件的方法是一样的，指定一个路径，并指定该文件的权限。为了避免受系统的权限掩码值的影响，我们要用 umask 将权限掩码值置零\numask(0);if(mkfifo(&quot;test.pipe&quot;, 0600) != 0)&#123;// 当返回值不为 0 的时候，代表出现了错误    cerr &lt;&lt; &quot;mkfifo error&quot; &lt;&lt; endl;    return 1;&#125;\n\n运行之后可以看到，出现了一个新的文件。其文件权限值的开头为p，代表它是一个管道文件\n\n之后的操作同样是文件操作，因为管道文件本质上就是一个文件\n\n先使用 open 方法，指定用读、写方法\n再分别在读写端 read/write 操作文件\n操作完成之后，close文件，并删除该文件\n因为  管道文件  有唯一的路径，其能够完成让两个进程看到同一份资源，也就实现了进程通信的功能！\n\n3.2 实现两个进程之间的通信  下面通过一个服务端和客户端的代码，来演示多进程通信。\n\n服务端负责创建管道文件，以读方式打开该管道文件\n客户端以写方式打开管道文件，向服务端发送消息\n\n完整代码如下，包含一个头文件和两个源文件\n//MyPath.h#pragma once#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;using namespace std;#define NUM 1024#define FILE_PATH &quot;test.pipe&quot;//server.cpp#include&quot;MyPath.h&quot;int main()&#123;    // 创建管道文件    umask(0);    if(mkfifo(FILE_PATH, 0600) != 0)    &#123;        cerr &lt;&lt; &quot;mkfifo error&quot; &lt;&lt; endl;        return 1;    &#125;    // 打开管道文件    int pipeFd = open(FILE_PATH, O_RDONLY);    if(pipeFd &lt; 0)    &#123;        cerr &lt;&lt; &quot;open fifo error&quot; &lt;&lt; endl;        return 2;    &#125;    // 开始通信    cout &lt;&lt; &quot; 服务器启动 &quot; &lt;&lt; endl;    char buffer[NUM];    while(1)    &#123;        // 服务端执行读        ssize_t s = read(pipeFd, buffer, sizeof(buffer)-1);        if(s &gt; 0)        &#123;            buffer[s] = &#x27;\\0&#x27;;            cout &lt;&lt; &quot; 客户端 -&gt; 服务器# &quot; &lt;&lt; buffer &lt;&lt; endl;        &#125;        else if(s == 0)        &#123;            cout &lt;&lt; &quot; 客户端退出，服务器终止接收 &quot; &lt;&lt; endl;            break;        &#125;        else        &#123;            cout &lt;&lt; &quot;read: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;            break;        &#125;    &#125;    close(pipeFd);    cout &lt;&lt; &quot; 服务器关闭 &quot; &lt;&lt; endl;    unlink(FILE_PATH);    return 0;&#125;//client.cpp#include&quot;MyPath.h&quot;int main()&#123;    int pipeFd = open(FILE_PATH, O_WRONLY);    if(pipeFd &lt; 0)    &#123;        cerr &lt;&lt; &quot;open: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        return 1;    &#125;    // 客户端执行管道写入    char line[NUM];    while(true)    &#123;        printf(&quot; 请输入你的消息# &quot;);        fflush(stdout);        memset(line, 0, sizeof(line));        //fgets 的结尾会自动添加 \\0        if(fgets(line, sizeof(line), stdin) != nullptr)        &#123;            // 这里的意义是去掉接收到的回车 \\n            // 如：abcde\\n\\0 通过下面的代码去掉 \\n            line[strlen(line) - 1] = &#x27;\\0&#x27;;            write(pipeFd, line, strlen(line));// 管道写入        &#125;        else        &#123;            break;        &#125;    &#125;    close(pipeFd);    cout &lt;&lt; &quot; 客户端退出 &quot; &lt;&lt; endl;    return 0;&#125;\n\n通过头文件中的文件路径，我们能保证客户端和服务端处于同一个工作目录下，以便他们正确打开同一个管道文件\n先运行 server，会发现并没有出现  服务器启动  的打印\n\n客户端启动了之后，服务器端才打印出  服务器启动\n\n这时候，我们就可以在客户端输入消息，转到服务端读取\n\n这就完成了两个进程之间的通信。这两个进行并非父子进程，也不是兄弟关系！\n客户端 CTRL+C 终止的时候，服务端也会退出！\n\n等待  前面提到了，当客户端没有启动的时候，服务端的打印没有被执行\n进一步测试发现，当我们同时用写方式打开管道文件的时候，这两个进程都会在 open 中等待，而不执行cout\n\n23776 31027 31027 23776 pts/23   31027 S+    1001   0:00 ./server23952 31043 31043 23952 pts/24   31043 S+    1001   0:00 ./client\n\n这说明，管道文件必须要  同时以读写方式  打开，才能正常执行后续代码。如果一个进程以  写方式  打开了一个管道，而该管道没有  读端（反过来也是一样的），该进程就会进行阻塞等待\n\n4. 管道的特性\n单个管道只支持单向通信，这是内核实现决定的。半双工  的一种特殊情况\n管道自带同步机制，能够判断管道的状态，是否写满，是否没有写入等等\n管道是面向字节流的，先写的字符一定是先被读取的，在 2.3 中有所体现。需要用户来定义区分内容的边界（比如网络 tcp 协议）\n管道是一个文件，管道的生命周期跟随进程\n\n4.1 什么是半双工？半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；\n管道就是一种半双工的特殊情况，因为管道本身是支持任意进程读写的。对于进程 A，它既可以成为管道的读端，又可以成为管道的写端。但一旦确认之后，管道的读写方向就不能被改变。\n所以管道是属于半双工的一种特殊情况\n4.2 拓展：单工 &#x2F; 半双工 &#x2F; 双工  参考资料来源：博客园\n\n单工数据传输只支持数据在一个方向上传输；\n半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；\n全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。\n\n结语  阿巴阿巴，关于管道的内容到这里就基本 over 了，我们通过匿名管道实现了控制多个子进程。通过命名管道实现了两个不相干进程之间的通信\n\n下篇博客是关于共享内存的\n\n如果有啥问题，可以在评论区提出哦！\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】文件 IO","url":"/posts/2864480005/","content":"让我们来认识一下 linux 下的文件接口吧！\n\n\n\n演示所用系统：CentOS7.6\n本文所有代码都可以在我的 gitee 仓库查看【链接】\n\n[TOC]\n1. 什么是文件？\n文件 = 文件内容 + 文件属性，文件属性也是数据，即便我们创建一个空文件，也是会占用磁盘空间的\n文件操作 = 文件内容的操作 + 文件属性的操作 ，在之前linux 权限 的博客里面就提到过，文件操作有可能即改变内容，又改变属性\n文件打开操作  其实是把文件的属性和内容加载到内存中，没有被打开的文件依旧处于磁盘当中\n当前路径  为当前进程所处的工作路径\n\n我们的打开文件操作需要和磁盘这个硬件打交道，只有操作系统才能直接操作硬件。所以我们的文件操作其实都是  调用的系统接口。\n实际上，所有编程语言都对操作系统接口进行了封装，这样才能保证他们的  跨平台性。因为不同操作系统的各种接口各不相同，如果不进行封装，直接调用系统接口，则该代码只能在指定系统上跑！\n1.2 C 语言文件操作  在学习 Linux 下文件相关内容之前，我们先来复习一下 C 语言的文件接口\nvoid writetest()&#123;    char*file=&quot;test.txt&quot;;    FILE* f=fopen(file,&quot;w&quot;);    for(int i =0;i&lt;10;i++)    &#123;        fprintf(f,&quot;hello linux! %d\\n&quot;,i);    &#125;        fclose(f);    f=NULL;&#125;void readtest()&#123;    char*file=&quot;test.txt&quot;;    FILE* f=fopen(file,&quot;r&quot;);    char buff[128];// 将读取到的数据写入 buff 数组里面    for(int i =0;i&lt;10;i++)    &#123;        fgets(buff,20,f);        printf(&quot;%s&quot;,buff);    &#125;    fclose(f);    f=NULL;&#125;\n\n这里用循环先往 test.txt 内输入 10 行数据，再读取并打印到屏幕上\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test1hello linux! 0hello linux! 1hello linux! 2hello linux! 3hello linux! 4hello linux! 5hello linux! 6hello linux! 7hello linux! 8hello linux! 9[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n\n除了 w 和 r 方法外，C 语言还提供了 w+ r+ a 以及带 b 的二进制读写\n\n这部分内容可以去看看我之前的 C 语言文件操作 博客！\n\nC 语言默认打开了三个输入输出流，都是一个 FILE* 的指针，分别为stdin/stdout/stderr，记住这个点，后面会用到哦\n\n2. 初识 Linux 系统的文件接口 Linux 下的文件操作用的接口为open/write/read，都需要先用 open 打开文件并指定打开方式后，再用write/read 操作进行读写\n\n注：man 查询的时候需要指定man 2 open，否则查询到的是命令不是函数接口\n\n\n这里 open 一共有两个函数接口，没错，就是  函数重载！这是因为 linux 下的 C 语言标准和我们之前在 win 下学习所用的标准是不一样的！\n\n第一个参数为pathname，文件路径\n第二个参数为flags，打开文件的方式\n\n打开文件的方式并不像 C 语言用 w/r 等等代替，而是需要我们传入多个 flag 进行  按位与 ，这一点和C++ 中的文件类一样！\n\n这里的 flag 其实是一种位图结构。每一个 flag 只需要在一个比特位上为 1（十进制 2 的倍数）其余位为 0，保证互不影响。这样在按位与的时候，才能正确凑到一起，并通过按位或进行 flag 的取出\n\n flag 的参数中，下面这三个值，必须指定一个且只能指定一个\n\nO_RDONLY: 只读打开\nO_WRONLY: 只写打开\nO_RDWR: 读，写打开\n\n剩余的参数是用作额外操作的\n\nO_CREAT: 若文件不存在，则创建；需要传入 mode 参数，来指明新文件的访问权限\nO_APPEND: 追加写\nO_TRUNC: 清空文件\n……\n\n常用的参数就上面这些，更多参数可以使用 man 2 open 查看完整 flag 列表\n\n这种  大写 + 下划线  的命名方式告诉我们，它其实就是系统中预先定义好的  宏！\n\n需要注意的是，open 函数的返回值是一个 int 类型，它被称为  文件描述符，后面会有详解\n\n2.1 读文件\n读文件的操作和 fgets 类似，需要指定文件描述符，以及用于保存文件内容的buf，和数据长度count\n#define SIZE 256void test1()&#123;    char buf[SIZE];    int fd1 = open(&quot;test.txt&quot;, O_RDONLY);    read(fd1,buf,strlen(buf)-1);    ssize_t s = read(fd1, buf, sizeof(buf)-1);    if(s &gt; 0)    &#123;       buf[s] = &#x27;\\0&#x27;;       printf(&quot;%s&quot;, buf);    &#125;    close(fd1);&#125;\n\nssize_t是有符号整型，其实就是 int\ntypedef int ssize_t\n\n这里我们打开了刚刚测试 C 语言用的 test.txt 文件，成功读出了里面的内容\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testhello linux! 0hello linux! 1hello linux! 2hello linux! 3hello linux! 4hello linux! 5hello linux! 6hello linux! 7hello linux! 8hello linux! 9[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n2.2 写文件\n注意的是，默认情况下，如果我们不在 open 的时候指定第三个参数，其创建的新文件，权限是乱掉的。而单给第三个参数传入 0666 还不够，我们需要先把系统的 umask 在当前进程中设置为 0，以避免系统 umask 的默认值对我们创建文件的权限造成影响\nvoid test2()&#123;    umask(0);// 先把 umask 设置为 0，保证权限值设置正确，不受系统 umask 影响    int fd = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);\t// 这里我们指定了 0_CREAT，所以需要指定 0666 作为权限值    const char *str = &quot;bbbbbb\\n&quot;;    write(fd, str, strlen(str));    close(fd);&#125;\n\n执行上述代码后，可以看到数据被成功写入\n\n这里我们还指定了 O_TRUNC，所以每一次执行的时候，文件内部的内容都会被清空。修改str 后重新进行测试，可以看到原有的内容不见了\n\n如果不指定，其不会清空已有内容。而是会从开头进行写入，覆盖开头已有的内容（左边为写入后，右边为写入前）\n\n实际上，C 语言的文件操作，调用的就是 linux 的文件接口\nfopen(&quot;test.txt&quot;, &quot;w&quot;); // 底层调用 open，O_WRONLY | O_CREAT | O_TRUNCfopen(&quot;test.txt&quot;, &quot;a&quot;); // 底层调用 open，O_WRONLY | O_CREAT | O_APPEND\n\n写方式覆盖？在测试的时候，我发现了一个神奇的情况\nvoid test2()&#123;    umask(0);// 先把 umask 设置为 0，保证权限值设置正确，不受系统 umask 影响    int fd1 = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT, 0666);    int fd2 = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fd1: %d  fd2: %d\\n&quot;,fd1,fd2);    const char *str = &quot;bbadsfasdfasdfa23123bbbb&quot;;    write(fd1, str, strlen(str));    close(fd1);&#125;\n\n这里我分别用 fd1/fd2 打开了 test.txt 文件，打印它们的文件描述符可以看到，结果不一样\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testfd1: 3  fd2: 4[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n但是，执行的写入，却是  O_TRUNC 的覆盖方法！\n\n实际上，并不是 fd2 的写入方法覆盖了 fd1 的，而是当我们使用  O_TRUNC 方法打开文件的时候，文件里面的内容就已经被清空了！\n\n\n可以看到，刚刚才 begin fd2 的时候，test.txt的文件大小就已经变成 0 了\n为了避免这种情况，建议不要在同一个进程里面多次打开一个之前已经打开过的文件！\n3. 文件描述符 3.1 为什么是从 3 开始？ 这里我们一次性打开多个文件，打印他们的文件描述符\nvoid test3()&#123;    int fda = open(&quot;loga.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdb = open(&quot;logb.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdc = open(&quot;logc.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdd = open(&quot;logd.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fde = open(&quot;loge.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fda: %d\\n&quot;, fda);    printf(&quot;fdb: %d\\n&quot;, fdb);    printf(&quot;fdc: %d\\n&quot;, fdc);    printf(&quot;fdd: %d\\n&quot;, fdd);    printf(&quot;fde: %d\\n&quot;, fde);&#125;\n\n\n会发现打印的文件是从 3 开始的。这和我们之前是否有打开过文件没关系，任何进程 open 的自己的文件都是从 3 开始的！\n还记得前面 C 语言部分提到的 stdin/stdout/stderr 吗？\nlinux 系统下一切皆文件，这三个家伙也不例外！既然 C 语言的文件操作封装了系统的接口，那么其内部肯定是有文件描述符的存在的，我们只需要找到它就行了。\n这一点，代码补全就可以帮忙了\n\nvoid test4()&#123;    //c 语言中的 FILE 是一个结构体，里面管理了 linux 系统的文件描述符    printf(&quot;stdin %d\\n&quot;,stdin-&gt;_fileno);//  0    printf(&quot;stdout %d\\n&quot;,stdout-&gt;_fileno);// 1    printf(&quot;stderr %d\\n&quot;,stderr-&gt;_fileno);// 2    FILE* f1 = fopen(&quot;test.txt&quot;,&quot;w&quot;);    printf(&quot;f1 %d\\n&quot;,f1-&gt;_fileno);//3&#125;\n\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./teststdin 0stdout 1stderr 2f1 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n打印之后我们发现，其 0 1 2 就是被 C 语言的这三个默认打开的文件流占用了，而我们用 C 语言 fopen 打开的文件，其文件描述符也是从 3 开始的！\n\n用文件描述符调用 stdin&#x2F;out既然 stdout 对应的文件描述符是 1，那我们可不可以直接调用系统的接口往屏幕上输出东西呢？\nvoid test5()&#123;    char buf[SIZE]=&quot;12345678910\\n&quot;;    write(1,buf,strlen(buf));&#125;\n\n当然是可以的！\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test12345678910[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n同理，我们还可以这样来接收用户输入\nvoid test6()&#123;    char buf[SIZE];    ssize_t s = read(0,buf,sizeof(buf));    if(s&gt;0)    &#123;        buf[s]=&#x27;\\0&#x27;;        printf(&quot;stdin: %s\\n&quot;,buf);    &#125;&#125;\n\n\n运行的时候，程序会挂起等待用户输入，由此可以打印获取输入的结果👇\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ makegcc test.c -o test -std=c99[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testasdfasdfadfadfstdin: asdfasdfadfadf[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n\n3.2 从 0 开始？数组下标！\n既然 stdin/stdout/stderr 分别对应的是0/1/2，而我们打开的自己的文件对应的是 3 开始，有没有可能，这些数字是一个数组的下标呢？\n\n一个进程打开的文件，其数据是在内存中的。操作系统内核肯定需要管理一个进程已经打开的文件！万一有“大聪明”忘记 close 文件了，而操作系统又没去管理已有文件，其不就会造成  内存泄漏  吗？\n在操作系统中，有一个struct file，其管理的就是已经打开了的文件\nstruct file&#123;    // 包含了文件的内容 + 属性&#125;\n\n同时，这个文件内核还会被插入到进程的 task_struct 中，因为一个进程是可以同时打开多个文件的。操作系统在对已打开文件进行管理的同时，还需要对一个  进程打开的文件  进行管理（知道某个文件是谁打开的）\n\n下载的 linux 源码中，task_strcut 的位置如下\nlinux-2.6.32.12/include/linux/sched.h\n\n\n\n而我们文件描述符，其实就是进程中管理文件的一个数组的下标。\n\nstruct files_struct &#123;  /*   * read mostly part   */\tatomic_t count;\tstruct fdtable *fdt;\tstruct fdtable fdtab;  /*   * written part on a separate cache line in SMP   */\tspinlock_t file_lock ____cacheline_aligned_in_smp;\tint next_fd;\tstruct embedded_fd_set close_on_exec_init;\tstruct embedded_fd_set open_fds_init;\tstruct file * fd_array[NR_OPEN_DEFAULT];// 文件数组&#125;;\n\n这样对进程打开的文件的管理，就被转化为了对这个数组的  增删查改\n3.3 Linux 下一切皆文件  最初学习 Linux 的时候，就提到了 Linux 下一切皆文件\n现在我们知道了内核中是用 file 结构体来管理文件的，那么，它是怎么用  文件  来管理键盘、鼠标、显示器、磁盘、网卡的呢？\n这时候就可以来“浅浅”的看一下源码了！不求看懂代码实现，只求理解理念\n\nstruct file位于 include/linux/fs.h 中\n\nstruct file &#123;\t/*\t * fu_list becomes invalid after file_free is called and queued via\t * fu_rcuhead for RCU freeing\t */\tunion &#123;\t\tstruct list_head\tfu_list;\t\tstruct rcu_head \tfu_rcuhead;\t&#125; f_u;\tstruct path\t\tf_path;#define f_dentry\tf_path.dentry#define f_vfsmnt\tf_path.mnt\tconst struct file_operations\t*f_op;\tspinlock_t\t\tf_lock;  /* f_ep_links, f_flags, no IRQ */\tatomic_long_t\t\tf_count;\tunsigned int \t\tf_flags;\tfmode_t\t\t\tf_mode;\tloff_t\t\t\tf_pos;\tstruct fown_struct\tf_owner;\tconst struct cred\t*f_cred;\tstruct file_ra_state\tf_ra;\tu64\t\t\tf_version;#ifdef CONFIG_SECURITY\tvoid\t\t\t*f_security;#endif\t/* needed for tty driver, and maybe others */\tvoid\t\t\t*private_data;#ifdef CONFIG_EPOLL\t/* Used by fs/eventpoll.c to link all the hooks to this file */\tstruct list_head\tf_ep_links;#endif /* #ifdef CONFIG_EPOLL */\tstruct address_space\t*f_mapping;#ifdef CONFIG_DEBUG_WRITECOUNT\tunsigned long f_mnt_write_state;#endif&#125;;\n\n其余内容用来干哈子的咱暂且不管，目光聚焦于这一个结构体\nconst struct file_operations\t*f_op;\n\n翻译过来，这个成员的名字为文件操作。再来复习一下 const 修饰指针 的知识点\n\nconst 修饰指针有下面两种形式（关键字：const 和指针，const 常量指针，const 指针）\n\n在 * 之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）\n在 * 之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）\n\n\n在这个结构体中，就有 read/write 方法，它们是两个函数指针\nstruct file_operations &#123;\tstruct module *owner;\tloff_t (*llseek) (struct file *, loff_t, int);\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\tssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);\tssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);\tint (*readdir) (struct file *, void *, filldir_t);\tunsigned int (*poll) (struct file *, struct poll_table_struct *);\tint (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\tint (*mmap) (struct file *, struct vm_area_struct *);\tint (*open) (struct inode *, struct file *);\tint (*flush) (struct file *, fl_owner_t id);\tint (*release) (struct inode *, struct file *);\tint (*fsync) (struct file *, struct dentry *, int datasync);\tint (*aio_fsync) (struct kiocb *, int datasync);\tint (*fasync) (int, struct file *, int);\tint (*lock) (struct file *, int, struct file_lock *);\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\tint (*check_flags)(int);\tint (*flock) (struct file *, int, struct file_lock *);\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\tint (*setlease)(struct file *, long, struct file_lock **);&#125;;\n\nlinux 操作系统内的文件系统以  统一的方式  看待所有的设备。\n特定的设备的 read/write 方法是不一样的，只需要在这些硬件的  驱动程序  中给操作系统提供读写这个设备的函数实现，操作系统则将  函数指针  指向对应的函数，便能实现对某一个硬件设备的操作！\n比如调用显示器驱动的 write 刷新显示器的画面，调用网卡的 read/write 来下载 / 上传  数据等等！\n\n\n3.4 分配规则  分配文件描述符的时候，会从头开始遍历fd_array[]，找到第一个没有被使用的下标，分配给新的文件！\nvoid test7()&#123;    int fda = open(&quot;loga.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdb = open(&quot;logb.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);        printf(&quot;fda: %d\\n&quot;, fda);    printf(&quot;fdb: %d\\n&quot;, fdb);    close(fda);    printf(&quot;\\n&quot;);    int fdc = open(&quot;logc.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fdc: %d\\n&quot;, fdc);&#125;\n\n上述代码中，我们先打开了两个文件，打印可以看到其文件描述符为3/4；关掉第一个文件后，再打开一个新的文件，会发现文件描述符还是 3（第一个为空的文件描述符）\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testfda: 3fdb: 4fdc: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n输出重定向  同理，如果我们在打开文件之前，就关闭掉 C 语言打开的stdout，那么此时打开文件的 fd 就为 1，我们的 printf 则会把数据打印到该文件当中！\nvoid test8()&#123;    // 文件描述符分配的时候，会在数组里面找第一个为空的描述符    printf(&quot;start test!\\n&quot;);// 打印到屏幕上    close(1);// 关闭 stdout    int fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fd: %d\\n&quot;,fd);// 打印到文件中    close(fd);&#125;\n\n可以看到，运行 ./test 之前，文件里面没有内容。执行之后，就把我们 printf 的数据输出到文件当中了！\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./teststart test![muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtfd: 1[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n这种操作就叫做  输出重定向！\n另外  一种情况  下，如果我们在关闭 stdout 之前不进行 printf，则不会立马刷新到log.txt 而是需要我们刷新了缓冲区之后，才会写入到文件中\nclose(1);// 关闭 stdoutint fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);printf(&quot;fd: %d\\n&quot;,fd);fflush(stdout);close(fd);\n\n这里有个小技巧 &gt;log.txt 可以用来清空文件的内容\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ &gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$\n\n\n3.5 dup2上面是我们手动进行的  输出重定向  操作。操作系统提供了一个  接口，可以让我们很方便地进行输出重定向\nint dup2(int oldfd, int newfd);\n\n\n这里我们要用的是 dup2 函数，它的作用如下\ndup2() makes newfd be the copy of oldfd, closing newfd first if necessary, but note the following:*  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.*  If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.\n\n一定要看清楚，是将 newfd 变成 oldfd 的一个拷贝，在执行完毕之后，就只剩 oldfd 了！\n如果 newfd 原本已经打开了一个文件，该操作会先将 newfd 给关掉\nRETURN VALUEOn success, these system calls return the new descriptor.  On error, -1 is returned, and errno is set appropriately.\n\n该函数成功的时候会返回newfd，否则返回-1\n\n下面为一个示例代码，假设我们想将输出的内容重定向到一个文件中，则可以使用 dup2 将 1 替换为我们自己的 fd，此时oldfd=fd,newfd=1\nvoid test9()&#123;    int fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    dup2(fd, 1);    int ret = dup2(fd, 1);    if(ret &gt; 0)         close(fd);    printf(&quot;ret: %d\\n&quot;, ret);//ret 为 newfd    // 本来往显示器打印，最终变成向指定文件打印 -&gt; 重定向    fprintf(stdout, &quot; 打开文件成功，fd: %d\\n&quot;, fd);    fflush(stdout);// 刷新缓冲区    close(fd);&#125;\n\n结果如下，我们成功的将内容 printf 到了指定文件中\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ &gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n\n为什么这里可以用 stdout 来输出到文件中呢？\n\n因为当我们使用 dup2 的时候，stdout 所指向的文件描述符 1 已经被替换成了log.txt，此时对 stdout 的操作就是对我们自己的文件操作\n\n为什么这里我们已经把 fd 关掉了，但是替换掉的文件描述符 1 不受影响呢？\n\n同一个文件是可以被打开多次的！执行 dup2 的时候，可以理解为操作系统又一次打开了 fd 指向的文件，在文件底层，则有一个计数来判断该文件被打开了几次。当我们 close(fd) 的时候，只是让该文件底层 struct file 的打开计数 -1，并非完全关闭了该文件！此时1 还能正确指向 log.txt 呢\n追加重定向  这里只需要我们改变 fd 打开的方式，加上 O_APPEND 即可！\nvoid test9()&#123;    int fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_APPEND, 0666);    dup2(fd, 1);    int ret = dup2(fd, 1);//    if(ret &gt; 0)         close(fd);    printf(&quot;ret: %d\\n&quot;, ret);//ret 为 newfd    // 本来往显示器打印，最终变成向指定文件打印 -&gt; 重定向    fprintf(stdout, &quot; 打开文件成功，fd: %d\\n&quot;, fd);    fflush(stdout);// 刷新缓冲区    close(fd);&#125;\n\n运行可以看到，成功在后面追加\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3ret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n输入重定向// 输入重定向void test11()&#123;    int fd = open(&quot;log.txt&quot;,O_RDONLY);    if(fd&lt;0)    &#123;        perror(&quot;open&quot;);        return ;    &#125;    int ret = dup2(fd,0);// 重定向 stdin    if(ret &gt; 0)         close(fd);    char buf[128];    while(fgets(buf,sizeof(buf),stdin)!=NULL)    &#123;        printf(&quot;%s&quot;,buf);    &#125;&#125;\n\n此时我们的 stdin 被dup2替换成了log.txt，其获取输入的操作转为了读取文件\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3ret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testret: 1打开文件成功，fd: 3ret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n3.6 标准输出 &#x2F; 标准错误  之前写代码的时候，我们常常直接使用了 printf 来打印一些错误信息，而没有怎么用过 perror/cerr 这两个库函数\n那么它们和 printf/cout 又有什么区别呢？\nint main()&#123;    // stdout    printf(&quot;hello printf\\n&quot;);    fprintf(stdout, &quot;hello fprintf to stdout\\n&quot;);    fputs(&quot;hello fputs to stdout\\n&quot;, stdout);    cout &lt;&lt; &quot;hello cout&quot; &lt;&lt; endl;    // stderr    perror(&quot;hello perror&quot;);    fprintf(stderr, &quot;hello fprintf to stderr\\n&quot;);    fputs(&quot;hello fputs to stderr\\n&quot;, stderr);    cerr &lt;&lt; &quot;hello cerr&quot; &lt;&lt; endl;    return 0;&#125;\n\n测试发现，似乎没有啥区别啊，不都打印到屏幕上了吗？\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./testhello printfhello fprintf to stdouthello fputs to stdouthello couthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n非也！当我们使用重定向的时候，就出现问题了\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &gt;log.txthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello printfhello fprintf to stdouthello fputs to stdouthello cout[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n欸？不是使用了重定向吗，为什么还在屏幕上输出了内容呢？\n仔细一看，输出的都是 stderr 的内容，而没有 stdout。cat 文件一看，stdout 的内容都在文件里面嘞！\n还记得吗？stdout/stderr对应的文件描述符是1/2，而在默认情况下，它们都指向的是显示器。\n\n注意：虽然它们两个指向都是显示器，但它们是通过两个  不同的文件描述符，独立地往显示器上打印内容的！\n\n我们重定向的时候，其实省略了一个 1，默认情况下，重定向只对 1 号描述符，也就是 stdout 有效！\n./test &gt;log.txt./test 1&gt;log.txt\n\n如果我们把这里的 1 换成 2，结果就不一样了\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test 2&gt;log.txthello printfhello fprintf to stdouthello fputs to stdouthello cout[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n可以看到，stderr 的内容进了文件，而 stdout 的内容输出到了屏幕上\n区分错误和正常输出  这么设计的意义，就是为了方便我们定位问题。将错误和正常的打印输出写道不同的文件中。如果我们像只关注错误，就只需要去查找记录了错误信息的文件即可\n混合输出 2&gt;&amp;1如果我们就是不听不听，非要把他俩打一个文件里面，应该怎么弄呢？\n./test &gt;log.txt 2&gt;&amp;1\n\n这个 2&gt;&amp;1 的操作需要我们理解：\n\n./test运行可执行程序\n&gt;log.txt代表重定向，默认只重定向了 1\n现在指向 log.txt 的是 1 号文件描述符，代表 stdout\n2&gt;&amp;1代表将 2 重定向到 1，可以理解为dup2(1,2);\n执行结束后，2 就成了 1 的一份拷贝，现在只剩下了 1\n因为 1 指向的是log.txt，所以 2 也指向的是相同文件\n\n而这个语句必须写在 &gt;log.txt 的后面， 否则意义就错误了👇\n./test 2&gt;&amp;1 &gt;log.txt # 错误写法\n\n\n2&gt;&amp;1代表将 2 重定向到 1，此时 1 指向的是屏幕，所以 2 也指向了屏幕\n&gt;log.txt代表将 1 指向文件，此时 1 指向了文件，但是 2 还是指向屏幕\n白写！\n\n执行了正确的命令后，来看看结果吧！\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &gt;log.txt 2&gt;&amp;1[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello printfhello fprintf to stdouthello fputs to stdouthello couthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n标准错误和标准输出的内容都被写入到文件中了！\n上面的整法实在有点太长了，而且还有可能记不住写反了。所以有一种简写的方式\n# 简写方式&amp;&gt;log.txt# 上面的写法等同于&gt;log.txt 2&gt;&amp;1\n\n测试一下，没问题！\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ &gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &amp;&gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello printfhello fprintf to stdouthello fputs to stdouthello couthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n\n关于 2&gt;&amp;1 的详解参考👉 传送门\n\n\n4.C 语言缓冲区 4.1 观察现象 先来看看下面的代码，分别调用 C 语言的 printf 和操作系统的 write 接口，往屏幕上打印内容。结束后sleep(3)\nvoid test1()&#123;    printf(&quot;test printf &quot;);    const char*msg = &quot;test write &quot;;    write(stdout-&gt;_fileno,msg,strlen(msg));    sleep(3);&#125;\n\n\n我们惊奇的发现，第一个打印出来的竟然是 write，而不是在它之前的printf 接口！\nvoid test1()&#123;    printf(&quot;test printf &quot;);    fflush(stdout);    const char*msg = &quot;test write &quot;;    write(stdout-&gt;_fileno,msg,strlen(msg));        sleep(3);&#125;\n\n只有在 printf 后立马调用 fflush 刷新缓冲区，才能按正确的“顺序”打印出内容来\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest printf test write [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n在调用其他 C 语言的函数，往屏幕上输出信息。我们会发现结果相同！都是先打印出来 write 结果，才  一次性  打印出所有 C 语言函数的结果\nvoid test2()&#123;    printf(&quot;test printf &quot;);    fprintf(stdout,&quot;test fprintf &quot;);    fputs(&quot;test fputs &quot;,stdout);    const char*msg = &quot;test write &quot;;    write(stdout-&gt;_fileno,msg,strlen(msg));        sleep(3);&#125;\n\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest write test printf test fprintf test fputs [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n由此可见，之前我们一直提到的缓冲区，其实是 C 语言提供 的！\n\n注意：缓冲区不止 C 语言内部有，操作系统内也有。本文只讨论 C 语言提供的缓冲区\n\n\n4.2 缓冲区在哪?printf(&quot;test printf &quot;);fprintf(stdout,&quot;test fprintf &quot;);fputs(&quot;test fputs &quot;,stdout);\n\n上面这几个函数都有一个共同的特点：它们都往 stdout 里面打印了内容！\n\nprintf虽然没有显示指定stdout，但是底层是有的\n\n我们知道，C 语言的文件是一个 FILE 类型的结构体。该结构体内封装了很多属性，其中 stdout 的_fileno文件描述符，就是该 FILE 对应的语言级别的缓冲区！\n关闭文件描述符  如果我们在数据刷新之前，关闭了 stdout 对应的文件描述符，会发生什么？\nprintf(&quot;test printf &quot;);fprintf(stdout,&quot;test fprintf &quot;);fputs(&quot;test fputs &quot;,stdout);const char*msg = &quot;test write &quot;;write(stdout-&gt;_fileno,msg,strlen(msg));sleep(3);close(stdout-&gt;_fileno);\n\n结果就是，啥都没有刷新！\n缓冲区都被关闭了，其内部的数据都无了，肯定不会刷新啦~\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest write [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n而在  输出重定向  中，打印的内容没有直接被显示的，也是因为我们没有在关闭 fd 之前刷新stdout（此时指向的是 fd）中的缓冲区\nclose(1);// 关闭 stdoutint fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);printf(&quot;fd: %d\\n&quot;,fd);fflush(stdout);close(fd);\n\nFILE既然 stdout 的缓冲区在 FILE 内部，推而广之，所有用 C 语言打开的文件，FILE中都会有一个  文件描述符  和它自己的  语言级别缓冲区\ntypedef struct _IO_FILE FILE;\n\n库函数中的 FILE 是一个 struct _IO_FILE 类型的结构体，其定义如下\nstruct _IO_FILE &#123;  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  // 下面这些就是它的缓冲区  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;\t/* Current read pointer */  char* _IO_read_end;\t/* End of get area. */  char* _IO_read_base;\t/* Start of putback+get area. */  char* _IO_write_base;\t/* Start of put area. */  char* _IO_write_ptr;\t/* Current put pointer. */  char* _IO_write_end;\t/* End of put area. */  char* _IO_buf_base;\t/* Start of reserve area. */  char* _IO_buf_end;\t/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;// 文件描述符#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;\n\n我们可以看到有多个变量用于维护该文件的缓冲区，也证实了缓冲区是由 C 语言提供的这一结论。\n4.3 缓冲区的作用C 语言提供缓冲区的理由很简单，相对于内存而言，其余硬件都是满设备。\n\n为代码提供缓冲区，可以提高该程序 &#x2F; 进程输出的效率\n缓冲区可以集中处理数据刷新，减少 IO 的次数，提高了  整机  运行效率\n\n4.4 什么时候刷新缓冲区？什么时候刷新缓冲区，对应的是  刷新策略  问题\n常规的刷新策略\n\n无缓冲（立即刷新）\n行缓冲（逐行刷新）\n全缓冲（缓存区满，刷新）\n\n特殊情况\n\n进程退出（刷新）\n用户调用函数，强制刷新\n\n刷新与子进程void test3()&#123;    const char*str1=&quot;test printf\\n&quot;;    const char*str2=&quot;test fprintf\\n&quot;;    const char*str3=&quot;test fputs\\n&quot;;    const char*str4=&quot;test write\\n&quot;;    //C 语言    printf(str1);// 这样写也是 ok 的    fprintf(stdout,str2);    fputs(str3,stdout);    // 系统接口    write(stdout-&gt;_fileno,str4,strlen(str4));    // 子进程创建    fork();&#125;\n\n上面的代码，会出现两种运行情况\n\n如果直接打印到屏幕上，打印的顺序和内容都是正确的\n如果重定向到文件中，却发现 C 语言打印的内容都多打了一次！\n\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest printftest fprintftest fputstest write[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test &gt; log.txt[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txttest writetest printftest fprintftest fputstest printftest fprintftest fputs[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n刷新的本质，其实就是把缓冲区中数据，调用 write 接口通过操作系统写入到文件中。而 FILE 内部的缓冲区，是属于  父进程内部  的数据。\n当我们在刷新之前 fork 创建子进程的时候，会发生一次  写时拷贝\n结果就是父进程、子进程  各刷新一次。于是就出现了上面的 C 语言的内容多了一份的现象！\n\n4.5 简单模拟实现  缓冲区，本质就是 C 语言在文件的结构体中维护的一个数组。同时维护了多种  刷新策略 ，在不同的时刻将该数组的内容调用系统接口write 写入文件\n这里我们提供了一个简单的 MyFILE 结构体，内部封装文件描述符、刷新策略、缓冲区\n#define NONE_FLUSH 0x0 // 无刷#define LINE_FLUSH 0x1 // 行刷#define FULL_FLUSH 0x2 // 全缓存typedef struct MyFILE&#123;    int _fileno;    char _buffer[NUM];    int _end;// 缓冲区结尾    int _fflags; // 刷新策略&#125;MyFILE;\n\n有了自己的文件结构体，对应的也需要分装一下系统的 open/read/write/close 等接口，还有 fflush 用于强制刷新\n\n封装接口  为了做到尽量简单，这里暂时只封装 r/w/a 三种打开方法\nMyFILE *my_fopen(const char *filename, const char *method)&#123;    assert(filename);    assert(method);    int flags = O_RDONLY;    if(strcmp(method, &quot;r&quot;) == 0)    &#123;        flags = O_RDONLY;    &#125;    else if(strcmp(method, &quot;w&quot;) == 0)    &#123;        flags = O_WRONLY | O_CREAT | O_TRUNC;    &#125;    else if(strcmp(method, &quot;a&quot;) == 0)    &#123;        flags = O_WRONLY | O_CREAT | O_APPEND;    &#125;    int fileno = open(filename, flags, 0666);    if(fileno &lt; 0)    &#123;        return NULL;    &#125;    MyFILE *fp = (MyFILE *)malloc(sizeof(MyFILE));    if(fp == NULL) return fp;    memset(fp, 0, sizeof(MyFILE));    fp-&gt;_fileno = fileno;    fp-&gt;_fflags |= LINE_FLUSH;// 默认行缓冲    fp-&gt;_end = 0;    return fp;&#125;\n\n这里暂时只用行缓冲和全缓冲来体验一下缓冲区的作用。同时只对字符串结尾的 \\n 进行了判断，情况不够全面。\n\n这里其实我很好奇，C 库里面是怎么处理 \\n 的捏；总不能用遍历吧？那样效率也太低了。个人猜测是和预先设置的特殊字符有关系。\n\nvoid my_fwrite(MyFILE *fp, const char *start, int len)&#123;    assert(fp);    assert(start);    assert(len &gt; 0);    // 先写入到缓冲区里面    strncpy(fp-&gt;_buffer+fp-&gt;_end, start, len); // 将数据写入到缓冲区了    fp-&gt;_end += len;    if(fp-&gt;_fflags &amp; NONE_FLUSH)    &#123;&#125;    else if(fp-&gt;_fflags &amp; LINE_FLUSH)    &#123;        // 这里的判断只是测试，实际上还需要判断中间有无 \\n        if(fp-&gt;_end &gt; 0 &amp;&amp; fp-&gt;_buffer[fp-&gt;_end-1] == &#x27;\\n&#x27;)        &#123;            // 写入到内核中            write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);            fp-&gt;_end = 0;            syncfs(fp-&gt;_fileno);        &#125;    &#125;    else if(fp-&gt;_fflags &amp; FULL_FLUSH)    &#123;// 满了刷新        if(fp-&gt;_end &gt; 0 &amp;&amp; fp-&gt;_end==NUM)        &#123;            // 写入到内核中            write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);            fp-&gt;_end = 0;            syncfs(fp-&gt;_fileno);        &#125;    &#125;&#125;\n\n这里有一个新接触的函数syncfs\nint syncfs(int fd);\n\n该函数是一个系统调用接口，用于将文件内核缓冲区内的数据写入到指定文件中。\n前面我们提到的缓冲区，一直说的都是 C 语言内部维护的。从这个接口也能看出，操作系统同样对文件进行了缓冲区的维护。\n\nvoid my_fflush(MyFILE *fp)&#123;    assert(fp);    if(fp-&gt;_end &gt; 0)    &#123;        write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);        fp-&gt;_end = 0;        syncfs(fp-&gt;_fileno);    &#125;&#125;void my_fclose(MyFILE *fp)&#123;    my_fflush(fp);    close(fp-&gt;_fileno);    free(fp);&#125;\n\n运行测试int main()&#123;    MyFILE *fp = my_fopen(&quot;log.txt&quot;, &quot;w&quot;);    if(fp == NULL)    &#123;        printf(&quot;my_fopen error\\n&quot;);        return 1;    &#125;        const char *a = &quot;hello my 111\\n&quot;;    my_fwrite(fp, a, strlen(a));    printf(&quot; 消息立即刷新 \\n&quot;);    sleep(3);    const char *b = &quot;hello my 222 &quot;;    my_fwrite(fp, b, strlen(b));    printf(&quot; 写入了一个不满足刷新条件的字符串 \\n&quot;);    sleep(3);    const char *c = &quot;hello my 333 &quot;;    my_fwrite(fp, c, strlen(c));    printf(&quot; 写入了一个不满足刷新条件的字符串 \\n&quot;);    sleep(3);    const char *d = &quot;end\\n&quot;;    my_fwrite(fp, d, strlen(d));    printf(&quot; 写入了一个满足刷新条件的字符串 \\n&quot;);    sleep(3);    my_fclose(fp);    printf(&quot; 程序结束 \\n&quot;);&#125;\n\n刚开始的时候，我们写入了一个 \\n 结尾的字符串，其立马写入到了文件中\n\n随后写入了两个不满足刷新条件的字符串，文件中没有出现结果\n\n\n而当我们写入一个满足刷新条件的字符串后，缓冲区的内容就  同时  被写入到文件中了！\n\n子进程测试  除此之外，我们还可以测试一下子进程是否会出现刷新两次的情况\nvoid test2(MyFILE * fp)&#123;    const char *s = &quot;-test &quot;;    my_fwrite(fp, s, strlen(s));    printf(&quot; 写入了一个不满足刷新条件的字符串 \\n&quot;);    fork();&#125;int main()&#123;    MyFILE *fp = my_fopen(&quot;log.txt&quot;, &quot;w&quot;);    if(fp == NULL)    &#123;        printf(&quot;my_fopen error\\n&quot;);        return 1;    &#125;    //test1(fp);    test2(fp);    // 模拟进程退出    my_fclose(fp);    printf(&quot; 程序结束 \\n&quot;);&#125;\n\n结果如我们所料，文件中出现了两个 -test  ，原因在4.4 中已做解释\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test1写入了一个不满足刷新条件的字符串  程序结束  程序结束[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txt-test -test [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n\n5. 文件系统  之前我们提到的这些数据，都是存放在内存中的。接下来我们便要来了解一下操作系统是如何管理磁盘上的文件。\n\n5.1 磁盘的物理结构  以机械硬盘为例，其内部主要由盘片和磁头组成。\n\n当我们改变磁盘上某一个位置的 NS 极，就好比更改了此处保存的数据0/1\n\n在机械硬盘中，一个盘片对应一个磁头\n\n每个盘片被分为诺干个同心圆，每一个同心圆就是一个  磁道\n每个磁道被划分为诺干  段（扇区）\n每个扇区的存储容量为512 字节\n\n由此可见，当我们读写机械硬盘的时候，需要去找某一个盘面、某一个磁道的某一片扇区，就能找到该扇区的数据！\n\n盘面（磁面）有自己对应的磁头\n磁道是由距离圆心的半径决定的\n扇区是由盘面旋转决定的\n\n而操作系统的文件系统所作的工作，便是将文件和其对应的  扇区  联系起来。用上面提到的办法，便可以查找到每一个扇区！\n\n这种查找数据位置的操作，被称为 CHS 寻址，CHS 分别对应磁柱、磁面、扇区\n5.2 CHS 和 LBA\n更详细的解析参考：https://blog.csdn.net/jadeshu/article/details/89072512\n\n假设我们把一个磁道的数据“拉直”，其就变成了一条直线。依此类推，可以把每一个盘面上的每一条磁道都“拉直”\n\n最终，其不就变成了和上图类似的“长条状”了吗？我们学过的什么数据结构也是线性长条的捏？\n没错！就是  数组！\n此时，对磁盘文件的修改，就可以抽象成对内核中一个数组的  增删查改  操作！\n这种抽象之后的磁盘，被称为LBA 逻辑块地址，他们之中有一个转换关系👇\n用 C 表示当前柱面号，H 表示当前磁头号，S 表示当前扇区号，CS 表示起始柱面号，HS 表示起始磁头号，SS 表示起始扇区号，PS 表示每磁道有多少个扇区，PH 表示每柱面有多少个磁道，计算公式如下：$$LBA &#x3D; (C – CS) * PH * PS + (H – HS) * PS + (S – SS)$$通过这个公式，我们就能将磁盘中的一个区块的数据，转为数组中的一个下标，来方便操作系统访问$$C &#x3D; LBA &#x2F; (PH * PS) + CS$$\n$$H &#x3D; (LBA &#x2F; PS) % PH + HS$$\n$$S &#x3D; LBA &#x2F; PS + SS$$修改了  数组  中的数据之后，操作系统将 LBA 对应的 CHS 地址算出来交给  磁盘，让磁盘来修改指定扇区的数据，便实现了保存数据到磁盘中的操作\n\n5.3 IO 的基本单位  对于操作系统而言，一次 IO 的基本单位是 4kb，也就是 8 个扇区8*512 字节\n\n磁盘的基本单位：扇区（一般为 512 字节)\n文件系统访问磁盘的基本单位：4kb\n\n在操作系统中，会对前面提到的那个“数组”进一步抽象，8 个扇区会被合并成一个 4KB 的区块，用于  单次 IO。为了方便管理每一个区块，又将多个区块合并，作为一个  分区  进行管理\n这便是我们电脑上同一块物理硬盘可以对应  不同分区  的来源了！\n\n为什么？为什么操作系统要以 4kb 作为 IO 的基本单位呢？\n\nhttps://www.51cto.com/article/617936.html\n\n在上文中提到，Linux 选择 4KB 作为“页操作”（即读取内存，以及从内存写入磁盘）的基本单位算是一个历史遗留问题了。\n\n过小的页大小会带来较大的寻址开销\n过大的页大小浪费内存空间，造成内存碎片\n\n而当初这么选择，肯定是有其功用的！\n\n能提高 IO 效率，不需要多次写入 512 字节的数据\n不让文件系统的设计和磁盘有强相关性，解耦合\n\n对于第二点进行说明，如果文件系统不在扇区外额外选择一个空间作为 IO 的基本单位，那么其设计必定会依赖于  磁盘扇区大小。\n如果某一天，所有磁盘的扇区大小都从 512 字节变成了 1024 字节，那就必须要  修改操作系统的源码，才能正确访问新的硬盘。同时还需要对旧盘做优化，可谓事倍功半。\n而提前设定好一个更大的 IO 基本单位，便是避免了磁盘变动而造成的无法访问。有了这个更大的 IO 基本单位，我们只需要把磁盘的扇区组成一个 4kb 大小的空间进行 IO，不用管其磁盘扇区大小到底是多少了。\n\n当然，如果哪天扇区大小大于 4kb 了，恐怕就得改源码了？\n这部分我也不是很懂呢，以上只是个人浅显的理解\n\n\n5.4 系统结构  下图向我们展示了一个磁盘是如何被文件系统“拆分”的\n首先是分区，每一个分区都有一个 BootSector 和文件系统。我们主要关注文件系统中，单个 Block Group 里面的内容\n\nlinux 采用的是文件内容、文件属性分开存放的存储方式\n\n文件的属性是稳定的\n文件的内容在不断增多\n\ndata blocks：保存数据内容inode table：保存文件的 inodeinode bitmap：位图结构，指示 inode 是否被使用GDT：全称 group descriptor table，保存了 inode 个数、起始 inode 编号、多少 inode 被使用、多少 data blocks 被使用……Super Blocks：该 Block Group 文件系统的顶层数据结构\n\ninode这里提到的 inode 是 linux 下每一个文件的独立编号。linux 并不以文件名来识别文件，而是用文件编号来识别唯一的文件的。\ninode 保存了一个文件的基本信息\n\n文件的属性\nrwx 权限\n所属用户、所属组\n硬链接个数\n文件访问、修改、创建的时间\n指向 data blocks 中文件的内容\n\n\nstruct inode的位置在/include/linux/fs.h\n\n\n查看 inode 编号的方法为ls -i，其中这串数字便是该文件的 inode 编号\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -i1453833 makefile  1453832 test.cpp\n\n我们也可以看到，. 和..这两个文件夹也是有自己的 inode 编号的，印证了 linux 下一切皆文件，包括目录\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -ilatotal 161453831 drwxrwxr-x  2 muxue muxue 4096 Nov  2 09:58 .1443736 drwxrwxr-x 16 muxue muxue 4096 Nov  2 09:20 ..1453833 -rw-rw-r--  1 muxue muxue   81 Nov  2 09:58 makefile1453832 -rw-rw-r--  1 muxue muxue  437 Nov  2 09:35 test.cpp\n\nstat 命令  还可以用 stat 命令来查看单个文件的 inode 信息\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ stat test.cpp  File: ‘test.cpp’  Size: 437             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1453832     Links: 1Access: (0664/-rw-rw-r--)  Uid: (1001/   muxue)   Gid: (1001/   muxue)Access: 2022-11-02 09:35:07.684160444 +0800Modify: 2022-11-02 09:35:04.328161202 +0800Change: 2022-11-02 09:35:04.328161202 +0800 Birth: -\n\ninode 内部有一个结构，指向data blocks。前面提到过，文件系统 IO 的基本单位是 4KB，对应的，一个 blocks 的大小就是 4KB\n每一个文件都对应一个 inode，至少对应一个 data blocks（inode 中储存了 blocks 编号）\n因为 inode 所能保存的编号有限，所以对 data blocks 的保存分为两种情况\n\n部分 data blocks 直接保存了文件的内容。如果是小文件，inode 中保存的 block 就足够存下所有文件内容了\n如果是大文件，inode 中一部分 blocks 会用来保存该文件剩余 data blocks 的编号\n\n在内核中，文件系统会对这两种情况进行区分\n注意\n\n因为每一个文件都肯定有一个 inode 与之对应，所以创建空文件也是占用磁盘空间的\n可能会出现 inode 被用完了，磁盘空间却没有满的情况。但这时候也已经无法创建新文件了\n\n😂你可以尝试写一个 while1 循环，不断往系统中创建新文件，看看能不能达到这个临界值（咳咳，虽然好玩，但  并不推荐  你这么做）\n\n文件名存在哪儿？前面提到过，inode 保存了文件的属性，文件名是否为文件的属性呢？也算！\n但 inode 中并不保存文件名字！\n实际上，文件名是存在该文件所在  目录的文件内容  中的\n\n目录也是文件，文件就有文件属性 + 文件内容\n\n可以理解为，目录的内容保存的是一个键值对，其中 key 为文件名，value 为 inode 编号\n这便是为何一个目录中  不能出现同名文件，这是一个不支持键值冗余的map(cpp-stl)\n目录权限  既然目录也是文件，那么它就也有自己的文件权限\n\nhttps://blog.csdn.net/muxuen/article/details/125776348\n\n在我之前关于 linux 文件权限的讲解中，就提到了和目录有关的权限问题\n\n进入目录需要 x 权限\n创建文件需要 w 权限\n查看文件名需要 r 权限\n\n了解文件系统了之后，现在我们知道为什么目录的操作需要这些权限了。在目录下创建文件，本质就是在修改目录所对应的  文件内容！\n\n5.5 创建 &#x2F; 删除文件  当我们创建一个文件的时候，文件系统做了什么捏？\n\n创建一个新的文件结构体，和对应的 inode 编号\n根据目录的 inode，找到该目录的 data blocks\n将文件名和 inode 编号的对应关系写入到目录的数据块中\n\n当我们删除一个文件的时候：\n\n操作系统只需要删除当前目录下 inode 和文件名的对应关系\n同时在 inode bitmap 中将对应的 inode 置为 0（代表没有使用）\n\n这样就算是删除该文件了！好比我们操作线性表进行尾删操作，只是对size-1，并没有真的把该位置的数据删除\n\n这便能解释为什么复制粘贴一个文件的速度远慢于删除文件的速度\n因为没有将文件的 inode 和 data block 清空，所以给我们  恢复数据  带来了可能。只要该文件之前使用的 inode/data block 并没有被复写，我们就有可能还原出该文件的数据！\n\n\n6. 软硬链接  在最初学习 linux 命令行的时候，就已经学习过了 ln 创建文件链接的操作\n\n 这部分我没有写博客，因为网上的教程实在是太多啦\n\n但是当时并不知道  软链接 / 硬链接  到底有什么区别，学习了文件系统之后，回头再来看看\n\n6.1 查看文件硬链接个数ls -li\n\n当我们执行上面这个命令的时候，可以看到每一个文件的完整属性\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -liatotal 161453831 drwxrwxr-x  2 muxue muxue 4096 Nov  2 09:58 .1443736 drwxrwxr-x 16 muxue muxue 4096 Nov  2 09:20 ..1453833 -rw-rw-r--  1 muxue muxue   81 Nov  2 09:58 makefile1453832 -rw-rw-r--  1 muxue muxue  437 Nov  2 09:35 test.cpp\n\n可之前一直没有去了解，这个第三列的 2  16   1  1  到底是什么玩意呢？\n不卖关子，前面提到 inode 会保存文件的硬链接个数，第三列的数字，代表的便是该文件的硬链接个数！\n这里我们创建一个新的文件夹，和一个新的文件\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ mkdir test_r[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ touch test_f[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -litotal 121453833 -rw-rw-r-- 1 muxue muxue   81 Nov  2 09:58 makefile1453832 -rw-rw-r-- 1 muxue muxue  437 Nov  2 09:35 test.cpp1453836 -rw-rw-r-- 1 muxue muxue    0 Nov  2 16:07 test_f1449813 drwxrwxr-x 2 muxue muxue 4096 Nov  2 16:07 test_r[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n你会发现，文件夹默认的硬链接数是 2，而文件默认的硬链接数是 1\n为什么？当我们 cd 进入目录的时候，linux 便会找到底层的 inode，进入该 inode 所对应的文件中。\n如果想知道一个目录的目录名，我们必须要去该目录的  上级  找。\n为了方便查找当前目录以及其上级目录的 inode，每一个目录下面，默认都会有 .. 和. 这两个目录文件！\n进入刚刚我们新创的文件夹看看，你会发现，.文件的 inode 就是该文件夹的 inode！\n\n从这里便引出了软连接和硬链接的区别\n6.2 软硬链接区别  这里我创建了一个新文件夹，在里面创建了一个 test.c 文件\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -litotal 41453842 -rw-rw-r-- 1 muxue muxue 78 Nov  2 16:13 test.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ \n\n同时对该文件夹创建一个硬链接和软连接\nln -s 源 目标 # 创建软连接ln 源 目标 # 创建硬链接\n\n康康结果👇\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ln -s test.c testSoft.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -litotal 41453842 -rw-rw-r-- 1 muxue muxue 78 Nov  2 16:13 test.c1453843 lrwxrwxrwx 1 muxue muxue  6 Nov  2 16:14 testSoft.c -&gt; test.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ln test.c testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -litotal 81453842 -rw-rw-r-- 2 muxue muxue 78 Nov  2 16:13 test.c1453842 -rw-rw-r-- 2 muxue muxue 78 Nov  2 16:13 testHard.c1453843 lrwxrwxrwx 1 muxue muxue  6 Nov  2 16:14 testSoft.c -&gt; test.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ \n\n你能看出区别吗？\n\n软链接的 inode 和源文件不相同，是一个全新的文件\n硬链接的 inode 和源文件相同！同时它们的硬链接数 +1\n\n把这些文件都以指针理解，会更方便一些\n\n\n软连接的文件内容是所指向文件的路径\n硬链接只是在当前目录下新增文件名和 inode 编号的  映射关系，并对 inode 中硬链接个数 +1\n\n如果我们删除了 test.c，软连接就会失效，但硬链接并不会，因为硬链接本身和test.c 是一个东西！\n\n而 inode 中对硬链接的计数，就好比 C++ 中智能指针的引用计数，如果该计数为 0，就代表这个文件需要删除了！\n\n解答！知道了区别，我们也便知道为何一个新目录的  默认硬链接个数是 2了，其便是每一个目录都默认带的 . 文件，用于标识当前目录的 inode；另外一个是该文件本身\n\n每一个新创建的文件，默认都和自己映射，所以硬链接个数为 1\n\n同时，我们也可以通过 .. 文件的硬链接个数，快速知道上级目录中有多少个文件夹（除去默认的. 和..）\n上级目录内的文件夹个数 = 当前目录.. 文件的硬链接个数 - 2某一个目录内的文件夹个数 = 该目录.. 文件的硬链接个数 - 2\n\n6.3 unlink 命令  我们可以通过 unlink 命令来取消链接\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ lstestHard.c  testSoft.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ unlink testSoft.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -liatotal 121453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:39 .1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..1453842 -rw-rw-r--  1 muxue muxue   78 Nov  2 16:13 testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ \n\nunlink 也可以用来删除正常文件，但一般只用它来删除链接文件！\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -liatotal 121453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:39 .1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..1453842 -rw-rw-r--  1 muxue muxue   78 Nov  2 16:13 testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ unlink testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -liatotal 81453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:40 .1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..\n\n\n结语linux 文件系统的内容，到这里就 over 辣！后续如果有什么新增知识，会来这里添加！\n\n感谢你看到最后，如果有什么问题，可以在评论区提出哦\n","categories":["玩上Linux"],"tags":["Linux","文件"]},{"title":"【Linux】进程通信 | 信号","url":"/posts/2620423276/","content":"本篇博客让我们一起来康康  信号  部分的内容\n\n系统为 CentOS7.6，完整代码见 Gitee\n\n\n\n[TOC]\n1. 什么是信号  在进程运行过程中，会出现各种各样的情况。操作系统需要用一套机制，来管理进程的  事件\n\n进程退出\n进程停止\n进程恢复运行\n……\n\n同时，这套管理机制是  异步  的，属于一种  软（件）中断\n\n和硬件中断打断处理器类似，软件中断打断进程的执，让其执行对应代码进行响应\n\n1.1 何为异步?\n以网购物品为例：当商品寄到自提点的时候，会给你发送一条取件的短信（信号）。此时我正在打游戏，没时间去处理这个快递（即取快递的行为并不是必须立马执行）\n但这个时候，我已经知道有一个快递到了（知道自己获取到了一个信号）本质上就是知道了一会要去取快递（一会要处理信号）\n当游戏一把打完了，我们就去取快递了（处理信号）\n\n这就是一种  异步  的过程。因为  你不知道你的快递什么时候会到站点 ，进程也不知道自己 什么时候会收到一个信号\n1.2 信号的种类  使用 kill -l 命令，我们可以看到目前 linux 系统下 64 种不同的类型。\n其中前 32 为标准（Standard）信号，后 32 为实时（Real-time）信号；本篇博客只关注标准信号\n\n这些信号，都是 linux 系统中预定义的  宏\n\n其中最常用的便是 9 号信号，来中断进程。平时我们最常用的 CTRL+C，也是通过 向进程发 2 号信号  让进程退出的\n[muxue@bt-7274:~/git]$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX\n\n在 include/linux/signal.h 中，我们  可以看到对信号  的解释，以及其  默认处理方法 default action\n/* * In POSIX a signal is sent either to a specific thread (Linux task) * or to the process as a whole (Linux thread group).  How the signal * is sent determines whether it&#x27;s to one thread or the whole group, * which determines which signal mask(s) are involved in blocking it * from being delivered until later.  When the signal is delivered, * either it&#x27;s caught or ignored by a user handler or it has a default * effect that applies to the whole thread group (POSIX process). * * The possible effects an unblocked signal set to SIG_DFL can have are: *   ignore\t- Nothing Happens *   terminate\t- kill the process, i.e. all threads in the group, * \t\t  similar to exit_group.  The group leader (only) reports *\t\t  WIFSIGNALED status to its parent. *   coredump\t- write a core dump file describing all threads using *\t\t  the same mm and then kill all those threads *   stop \t- stop all the threads in the group, i.e. TASK_STOPPED state * * SIGKILL and SIGSTOP cannot be caught, blocked, or ignored. * Other signals when not blocked and set to SIG_DFL behaves as follows. * The job control signals also have other special effects. * *\t+--------------------+------------------+ *\t|  POSIX signal      |  default action  | *\t+--------------------+------------------+ *\t|  SIGHUP            |  terminate\t| *\t|  SIGINT            |\tterminate\t| *\t|  SIGQUIT           |\tcoredump \t| *\t|  SIGILL            |\tcoredump \t| *\t|  SIGTRAP           |\tcoredump \t| *\t|  SIGABRT/SIGIOT    |\tcoredump \t| *\t|  SIGBUS            |\tcoredump \t| *\t|  SIGFPE            |\tcoredump \t| *\t|  SIGKILL           |\tterminate(+)\t| *\t|  SIGUSR1           |\tterminate\t| *\t|  SIGSEGV           |\tcoredump \t| *\t|  SIGUSR2           |\tterminate\t| *\t|  SIGPIPE           |\tterminate\t| *\t|  SIGALRM           |\tterminate\t| *\t|  SIGTERM           |\tterminate\t| *\t|  SIGCHLD           |\tignore   \t| *\t|  SIGCONT           |\tignore(*)\t| *\t|  SIGSTOP           |\tstop(*)(+)  \t| *\t|  SIGTSTP           |\tstop(*)  \t| *\t|  SIGTTIN           |\tstop(*)  \t| *\t|  SIGTTOU           |\tstop(*)  \t| *\t|  SIGURG            |\tignore   \t| *\t|  SIGXCPU           |\tcoredump \t| *\t|  SIGXFSZ           |\tcoredump \t| *\t|  SIGVTALRM         |\tterminate\t| *\t|  SIGPROF           |\tterminate\t| *\t|  SIGPOLL/SIGIO     |\tterminate\t| *\t|  SIGSYS/SIGUNUSED  |\tcoredump \t| *\t|  SIGSTKFLT         |\tterminate\t| *\t|  SIGWINCH          |\tignore   \t| *\t|  SIGPWR            |\tterminate\t| *\t|  SIGRTMIN-SIGRTMAX |\tterminate       | *\t+--------------------+------------------+ *\t|  non-POSIX signal  |  default action  | *\t+--------------------+------------------+ *\t|  SIGEMT            |  coredump\t| *\t+--------------------+------------------+ * * (+) For SIGKILL and SIGSTOP the action is &quot;always&quot;, not just &quot;default&quot;. * (*) Special job control effects: * When SIGCONT is sent, it resumes the process (all threads in the group) * from TASK_STOPPED state and also clears any pending/queued stop signals * (any of those marked with &quot;stop(*)&quot;).  This happens regardless of blocking, * catching, or ignoring SIGCONT.  When any stop signal is sent, it clears * any pending/queued SIGCONT signals; this happens regardless of blocking, * catching, or ignored the stop signal, though (except for SIGSTOP) the * default action of stopping the process may happen later or never. */\n\n这也意味着：即便没有接收到信号，进程也具备有  识别和处理  这个信号的能力！因为在系统中，已经给每一个进程和信号指定了默认动作！\n1.3 信号产生  有很多情况会产生信号\n\n系统接口（kill 命令）\n键盘产生（CTRL+R  CTRL+\\)\n软件条件（进程停止，进程运行完退出）\n硬件异常（比如除 0 错误）\n\n1.4 信号动作  既然有默认动作，那肯定也有非默认的了。实际上，一个进程对信号的处理分为三种不同的方式\n\n默认动作\n自定义动作\n忽略\n\n前面提到，一个进程并不一定需要立刻处理一个信号。那么它一定需要有一个办法来记住自己收到的信号。\n而存储信号，是由  进程的 PCB来完成的！\n细心的你可能会发现，进程中的信号一共是 64 个，刚好是 8 个字节！我们可以通过  位图  结构，用两个 int 类型来存放一个进程收到的各种信号。\n\n在系统内核中，分别有三个表，用来存放进程的信号。而这些信号在位图中的位置，就是在 handler 方法集中处理动作的  下标\nblock - 1 表示该进程屏蔽这个信号pending - 表示进程收到了什么信号，1 代表收到且未处理handler - 每一个信号所对应的处理方法，默认 / 忽略 / 自定义\n\n这一切都是处于进程 PCB 中的，只有  操作系统  能为我们管理。所以操作系统提供了相关的接口，方便我们对进程信号进行自定义设置。\npending 表中的信号只能保存一个，如果一个信号尚未处理，该位图为 1；另外一个相同信号到来的时候，会被直接丢弃掉。（pending 表只能记住一个信号）\nhandler 表中的两个宏如下：\n\nSIG_DFL 默认方法\nSIG_IGN 忽略\n忽略是信号处理的一种方式，我们能正常收到这个信号，处理方法是不管他\n\n\n2. 系统接口2.1 signal#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler);\n\n这个函数可以用于设置某个信号的处理方法。如果设置成功，则返回值为这个信号的  旧处理动作；不过我们一般不关心这个函数的返回值。\nRETURN VALUE   signal()  returns the previous value of the signal handler, or SIG_ERR on error. In the event of an error, errno is set to indicate the cause.\n\n比如我们将键盘退出的 2 号自定义一个回调函数，那么就不能用 ctrl+c 终止这个进程；\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;int main()&#123;    // 将二号信号设置一个回调，其余信号不做处理    signal(2, handler);    cout &lt;&lt; &quot; 进程信号已经设置完了 &quot; &lt;&lt; endl;    sleep(3);    while (true)    &#123;        cout &lt;&lt; &quot; 进程正在运行: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    return 0;&#125;\n\n因为是系统调用接口，所以我们的当前进程处于什么状态，都不会影响这个回调办法的调用。\n比如 CTRL+C 的默认策略是终止某个前台进程，但在我们之前的测试中，即便这个进程在 sleep 或者是在某些共享资源中进行阻塞等待，它依旧能被 CTRL+C 所发送的 2 号信号终止。\n同理，在设置了自定义的信号捕捉函数后，我们发送信号的时候，操作系统也能根据当初设置的回调函数（底层有对应的结构体来存储和这个进程相关的信号处理函数）成功将其调用。\n2.1.1 前台进程和后台进程  这里对 ctrl+c 的作用进一步描述，它只能用来中断一个  前台进程\n./test # 我们直接运行一个进程，就是前台进程\n\n之前这种直接运行进程，在 bash 上打印内容的方式，都是一个前台进程，可以用 ctrl+c 终止；我们可以在后面加上 &amp; 设置为一个后台进程\n\n&amp;只是临时在后台运行，bash 关闭后会终止；如果想持久在后台运行，需要在命令最前面加上nohup\n\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./test &amp;[1] 8898[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898^C[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898^C[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898\n\n这时候这个进程会一直在当前 bash 的后台打印，期间我们可以执行其他的命令，但是它依旧会不停的打印。ctrl+c无法终止这个进程，因为它并没有在前台运行！\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ps jax | grep test22965  8898  8898 22965 pts/22   22965 S     1001   0:00 ./test\n\nps命令查看，可以看到其运行态为S；而前台进程，运行态为S+\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ps jax | grep test22965  9664  9664 22965 pts/22    9664 S+    1001   0:00 ./test\n\n不过，虽然我们不能用 CTRL+C 终止这个进程，但使用 kill -2 发送 2 号信号，是可以终止掉这个进程的（前提是没有自定义 2 号信号的方法）\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程信号已经设置完了  进程正在运行: 10464进程正在运行: 10464进程正在运行: 10464进程正在运行: 10464进程正在运行: 10464[1]+  Interrupt               ./test[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n2.1.2 循环捕捉所有信号  我们可以用一个 for 循环，捕捉所有的信号；所有信号的列表可以通过 kill -l 命令获取到。\n//.....// 其余代码同上int main()&#123;    // 对所有的进程信号都设置一个回调    for (int sig = 1; sig &lt;= 31; sig++)    &#123;        signal(sig, handler);    &#125;    //signal(2, handler);// 将二号信号设置一个回调，其余信号不做处理    cout &lt;&lt; &quot; 进程信号已经设置完了 &quot; &lt;&lt; endl;    sleep(3);    while (true)    &#123;        cout &lt;&lt; &quot; 进程正在运行: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    return 0;&#125;\n\n设置了之后，对应的信号都会调用我们自己写的函数。但有一个例外，那便是kill -9，九号信号是不能被自定义捕获的！\n\n2.1.3 信号 9&#x2F;19在 LINUX 下，9 号信号是一个管理员信号，具有杀死进程的最高权限，不能被自定义捕捉！\n\n你想啊，要是 linux 不对 9 号进行限制，那我把所有信号都捕捉了，岂不是这个进行没有办法被外部中止了？小病毒啊！😂\n\n和 9 号信号一样不能被屏蔽的，还有 19 号信号 SIGSTOP\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process running: 7779process running: 7779process running: 7779process running: 7779process running: 7779[1]+  Stopped                 ./tsig[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n而 6 号信号可以被捕捉，自定义捕捉方法执行后，进程依旧会退出。参考2.4 abort\n2.2 killkill 不仅是一个系统命令，同时还有一个系统接口；\n\n一般这种情况，用 man kill 查看命令的文档，man 2 kill查看接口函数\n\n之前我以为它只是一个用来干掉进程的命令（毕竟 kill 就是这个意思）现在才知道原来它的作用是给进程发信号\n//kill - send signal to a process#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;int kill(pid_t pid, int sig);\n\n它的返回值很简单，如果成功发送信号，则返回 0，否则返回 -1 并且更新 errno\nRETURN VALUE       On success (at least one signal was sent), zero is returned.  On error, -1 is returned, and errno is set appropriately\n\n所以我们可以写一个简单的函数实现，来制作一个自己的 kill 命令\nvoid mykill(int argc,char *argv[])&#123;    if(argc != 3)    &#123;        cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; signo-id process-id&quot; &lt;&lt;endl;        exit(1);    &#125;    if(kill(static_cast&lt;pid_t&gt;(atoi(argv[2])), atoi(argv[1])) == -1)    &#123;        cerr &lt;&lt; &quot;kill: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(2);// 出现错误    &#125;    exit(0);// 正常执行&#125;//argc 和 argv 是命令行参数//argc 传入命令个数，包括./test//argv 传入命令的字符串地址int main(int argc, char *argv[])&#123;    mykill(argc,argv);    return 0;&#125;\n\n成功发送了信号！\n\n如果我们使用错误的时候，则会发送提示信息👍\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./mkillUsage: ./mkill signo-id process-id\n\n2.2.1 killall这个接口可以通过进程名向所有  这个名字的进程  发信号\n[muxue@bt-7274:~/git]$ killall tsig\n\n通过测试可以发现，它发送的是第 15 号信号\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process running: 5846process running: 5846process 5846 get signal: 15process running: 5846process running: 5846\n\n\n2.3 raise这个系统接口的作用是给自己发信号\n#include &lt;signal.h&gt;int raise(int sig);\n\n返回 0 代表调用成功，非 0 代表失败\nRETURN VALUE       raise() returns 0 on success, and nonzero for failure.\n\n用下面的代码进行测试，进程会不断的给自己发送 2 号信号\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;void TestSignal()&#123;    signal(2, handler);// 将二号信号设置一个回调，其余信号不做处理    cout &lt;&lt; &quot; 进程信号已经设置完了 &quot; &lt;&lt; endl;    sleep(3);&#125;int main(int argc, char *argv[])&#123;    TestSignal();// 设置对进程信号的屏蔽    while(1)    &#123;        raise(2);        sleep(1);    &#125;    return 0;&#125;\n\n此时能看到每一秒会调用我们自己写的 handler 方法，打印收到 2 号信号\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process get signal: 2process get signal: 2process get signal: 2process get signal: 2process get signal: 2\n\n2.4 abort向自己发送 6) SIGABRT 信号\n#include &lt;stdlib.h&gt;void abort(void);\n\n还是 2.3 中的代码，将 raise(2) 修改为abort()，同时捕捉 6 号信号。\n此时能观察到我们自己写的 handler 方法的确被调用了，但是进程依旧终止了\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process get signal: 6Aborted[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n这说明 6 号信号有一个特性：可以被捕捉执行自定义方法，但  执行完毕之后需要退出！\n相比之下，9 号信号是  不能被捕捉\n\n2.5 alarm这个接口的作用是一个定时器，设定秒数，时间到了之后，会收到 14) SIGALRM 信号\n#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);\n\nRETURN VALUE    alarm()  returns  the number of seconds remaining until any previously scheduled alarm was due to be delivered, or zero if there was no previously scheduled alarm.\n\n用下面的代码进行测试\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;void TestSignal()&#123;    // 对所有的进程信号都设置一个回调    for (int sig = 1; sig &lt;= 31; sig++)    &#123;        signal(sig, handler);    &#125;    cout &lt;&lt; &quot; 进程信号已经设置完了 &quot; &lt;&lt; endl;    sleep(3);&#125;int main(int argc, char *argv[])&#123;    TestSignal();// 设置对进程信号的屏蔽    alarm(4);//4s 后向自己发送 14 信号    cout &lt;&lt; &quot;set alarm, sleep&quot; &lt;&lt; endl;    sleep(8);    cout &lt;&lt; &quot;sleep finish&quot;&lt;&lt;endl;    return 0;&#125;\n\n可以看到在休眠期间，进程收到了 14 号信号。此时进程并没有退出，而是继续休眠\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了set alarm, sleepprocess get signal: 14sleep finish[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n如果我们不对 14 号信号自定义捕捉，则会  直接退出进程\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigset alarm, sleepAlarm clock[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n另外需要注意的是，alarm信号本身不会让进程休眠。如果进程在 alarm 信号设定秒数之前结束，则什么事情都不会发生\n2.6 sigset_t 信号集  这是一个数据类型，其为 block&#x2F;pending 位图的存储结构，被称作  信号集 / 信号屏蔽字\n虽然我们能直接使用这个类型， 但是对这个信号集中的位图操作必须要  调用系统接口  来完成\n#include &lt;signal.h&gt;int sigemptyset(sigset_t *set);// 初始化位图(清空)int sigfillset(sigset_t *set);// 全部置为 1int sigaddset(sigset_t *set, int signum);// 设置位图中某一位的数据int sigdelset(sigset_t *set, int signum);// 删除位图中某一位的数据// 判断某一位信号是否在该集合中int sigismember(const sigset_t *set, int signum);\n\n2.7 sigprocmask更改或则获取当前进程的信号屏蔽字\n#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n\n其中第一个参数为处理方法，分别有下面三种\n\nSIG_BLOCK 将 set 参数中包含的位数设置为屏蔽\nSIG_UNBLOCK 将 set 参数中包含的位数解除屏蔽\nSIG_SETMASK 将当前的信号屏蔽字设置为 set（覆盖）\n\n第三个参数是一个输出型参数。如果传入了 oldset，那么旧的信号屏蔽字会被放入 oldset 中\nSIG_BLOCK  The set of blocked signals is the union of the current set and the set argument.SIG_UNBLOCK  The signals in set are removed from the current set of blocked signals.  It is permissible to attempt  to  unblock  a  signal which is not blocked.SIG_SETMASK   The set of blocked signals is set to the argument set.If oldset is non-NULL, the previous value of the signal mask is stored in oldset.RETURN VALUE       sigprocmask() returns 0 on success and -1 on error.  In the event of an error, errno is set to indicate the cause.\n\n如果用该接口接触了对某一个信号的阻塞，那么在该函数 return 前，至少其中一个消息被送达\n2.8 sigpending获取当前进程的 pending 信号集\n#include &lt;signal.h&gt;int sigpending(sigset_t *set);\n\n参数为一个输出型参数。正确获取返回 0，否则 -1\n这时候我们就可以写一个简单的函数来打印当前进程的信号集了\n// 打印信号集的内容void showPending(sigset_t* pdg_ptr)&#123;    for(int i=1;i&lt;32;i++)    &#123;        if(sigismember(pdg_ptr,i))        &#123;            cout &lt;&lt; &quot;1&quot;;        &#125;        else        &#123;            cout &lt;&lt; &quot;0&quot;;        &#125;    &#125;    cout &lt;&lt; endl;&#125;int main()&#123;    sigset_t pdg;    while(1)    &#123;        sigemptyset(&amp;pdg);// 初始化信号集        if(sigpending(&amp;pdg)==0)// 获取        &#123;            showPending(pdg);// 获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    return 0;&#125;\n\n运行之后可以看到，程序一直在打印当前进程的信号集\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigstart process: 30981000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n不过此时我们并没有对信号进行屏蔽，所以给这个进程发信号会被立即处理（递达）不能在 pending 表中观察到现象\n2.8.1 屏蔽 2 号信号  此时尝试使用 sigprocmask 来屏蔽某一个信号，再来观察情况\nint main(int argc, char *argv[])&#123;    //block 掉 2 号信号    sigset_t nsig,osig;    sigemptyset(&amp;nsig);    sigemptyset(&amp;osig);    sigaddset(&amp;nsig,2);// 在 nsig 中设置 2 为 1    sigprocmask(SIG_BLOCK,&amp;nsig,&amp;osig);// 添加屏蔽    cout &lt;&lt; &quot;start process: &quot; &lt;&lt; getpid() &lt;&lt; endl;    sigset_t pdg;    while(1)    &#123;        sigemptyset(&amp;pdg);// 初始化信号集        if(sigpending(&amp;pdg)==0)// 获取        &#123;            showPending(&amp;pdg);// 获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    return 0;&#125;\n\n可以看到当我们键入 CTRL+C 的时候，2 号信号被 block 了没有处理，pending 表上的 2 号信号就会变为 1，且多次 CTRL+C 不会有变化\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigstart process: 360800000000000000000000000000000000000000000000000000000000000000^C0100000000000000000000000000000010000000000000000000000000000001000000000000000000000000000000100000000000000000000000000000^C01000000000000000000000000000000100000000000000000000000000000\n\n2.8.2 屏蔽所有信号  可以用一个循环设置所有的信号位，让当前进程屏蔽掉所有信号\nint main(int argc, char *argv[])&#123;    //block 掉所有信号    sigset_t nsig,osig;    sigemptyset(&amp;nsig);    sigemptyset(&amp;osig);    for(int i=1;i&lt;32;i++)    &#123;        sigaddset(&amp;nsig,i);// 在 nsig 中设置 2 为 1    &#125;    sigprocmask(SIG_BLOCK,&amp;nsig,&amp;osig);// 添加屏蔽    cout &lt;&lt; &quot;start process: &quot; &lt;&lt; getpid() &lt;&lt; endl;    sigset_t pdg;    while(1)    &#123;        sigemptyset(&amp;pdg);// 初始化信号集        if(sigpending(&amp;pdg)==0)// 获取        &#123;            showPending(&amp;pdg);// 获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    return 0;&#125;\n\n运行之后可以观察到，不管给这个进程发几号信号，都会被屏蔽显示在 pending 集中；9 号信号依旧是老大哥，不受影响，依旧能干掉这个进程\n\n2.8.3 解除屏蔽  如果在设置屏蔽之后，休眠 15s（在此期间接收信号）再接触对信号的屏蔽\nint main(int argc, char *argv[])&#123;    //block 掉所有信号    sigset_t nsig,osig;    sigemptyset(&amp;nsig);    sigemptyset(&amp;osig);    for(int i=1;i&lt;32;i++)    &#123;        sigaddset(&amp;nsig,i);// 在 nsig 中设置 2 为 1    &#125;    sigprocmask(SIG_BLOCK,&amp;nsig,&amp;osig);// 添加屏蔽    TestSignal();// 设置信号自定义处理    cout &lt;&lt; &quot;start process: &quot; &lt;&lt; getpid() &lt;&lt; endl;    sigset_t pdg;    int k=15;    while(k--)    &#123;        sigemptyset(&amp;pdg);// 初始化信号集        if(sigpending(&amp;pdg)==0)// 获取        &#123;            showPending(&amp;pdg);// 获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    // 利用 osig 恢复之前的 block 表    sigprocmask(SIG_SETMASK,&amp;osig,nullptr);    sigemptyset(&amp;pdg);// 初始化信号集    if(sigpending(&amp;pdg)==0)// 获取    &#123;        showPending(&amp;pdg);// 获取成功，打印    &#125;    sleep(10);    cout &lt;&lt; &quot;process quit&quot;&lt;&lt;endl;    return 0;&#125;\n\n此时就能观察到，信号被立马处理，pending 表变为全 0\n\n2.9 sigaction#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *act,\t\t\tstruct sigaction *oldact);\n\n这个函数的参数和 signal 函数很相似，不过都变为了一个结构体。这个接口也可以用来处理  实时信号（不在文本考虑范围内）\n\n第一个参数是需要处理信号的编号\n第二个参数是自定义的 action\n第三个参数是输出型参数，可以获取到旧的处理方法；如果你不关心旧的处理方法，可以将它置为 NULL 空指针；\n\n设置成功后返回 0，出错返回 -1；\n这个结构体的成员如下：\nstruct sigaction &#123;    void     (*sa_handler)(int);// 对信号的处理方法    void     (*sa_sigaction)(int, siginfo_t *, void *);// 可忽略    sigset_t   sa_mask;// 参考 2.8 中的处理方法    int        sa_flags;// 设为 0    void     (*sa_restorer)(void);// 可忽略&#125;;\n\n2.9.1 基本使用#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;using namespace std;// 打印收到的信号void handler(int signo)&#123;    cout &lt;&lt; &quot;process &quot; &lt;&lt; getpid() &lt;&lt; &quot; get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;int main(int argc, char *argv[])&#123;    struct sigaction nact,oact;    nact.sa_flags = 0;    nact.sa_handler = handler;    sigemptyset(&amp;nact.sa_mask);// 初始化    sigaction(2,&amp;nact,&amp;oact);    while(1)    &#123;        cout &lt;&lt; &quot;process running: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(2);    &#125;    return 0;&#125;\n\n运行之后，我们自定义捕捉了 2 号信号，成功调用自己的 handler 方法！\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigprocess running: 15029process running: 15029^Cprocess 15029 get signal: 2process running: 15029process running: 15029^Cprocess 15029 get signal: 2process running: 15029process running: 15029process running: 15029^\\Quit[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n请注意，信号处理函数在自定义捕获后，进程接收到信号，会调用自定义捕捉的函数，再继续往后运行。所以如果你捕获了 2 号信号，用 ctrl+c 来退出的时候，理论上也是会调用对象的析构函数的（前提是你的进程里面没有死循环）。\n信号 2 终止后是否会调用析构函数？上面的代码中，我们有死循环，所以再接受到信号处理后，调用完毕函数，就会自动回到死循环的位置。\n在下面的函数中，我们的 main 是直接在 sleep 里面阻塞等待的，那么在获取到 ctrl+c 的信号后，会先调用信号处理函数，再回到 main 函数中继续往后执行，最终调用对象的析构。\n// 上面的代码省略了// mytest 和 myclass 是两个类，类中的构造和析构都添加了打印// mytest 中用智能指针包裹了一个 myclass 对象class mytest&#123;public:    mytest(int a):_ptr(make_shared&lt;myclass&gt;(a))    &#123;        cout &lt;&lt; &quot;init mytest&quot; &lt;&lt; endl;    &#125;    ~mytest()    &#123;        cout &lt;&lt; &quot;destroy mytest&quot; &lt;&lt; endl;    &#125;private:    shared_ptr&lt;myclass&gt; _ptr;&#125;;int main()&#123;    RegisterSigTermHandler(); // 捕捉 2 号信号    mytest t1(1);    map&lt;int,mytest&gt; tmap;    for(int i=0;i&lt;6;i++)    &#123;        tmap.emplace(i,t1);    &#125;    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;    tmap.clear();    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;    sleep(10); // 在这里 ctrl+c，接收到信号，运行完毕信号处理函数后，会继续往后运行。    cout &lt;&lt; &quot;-- end --&quot; &lt;&lt; endl;    return 0;&#125;\n这个程序的终端输出如下，在接收到信号后，会先调用信号处理函数，打印 singal 字符串，再返回到 main 函数，打印 -- end -- 字符串，最终退出 main 函数，析构掉两个对象。\n&gt; ./testinit myclassinit mytest----destroy mytestdestroy mytestdestroy mytestdestroy mytestdestroy mytestdestroy mytest----^Csingal-- end --destroy mytestdestroy myclass\n\n记录这一点，是因为 GPT 告诉我如果是接收到信号退出是不会执行析构函数的。然而情况并非如此。析构函数依旧会被正常执行！\n那如果有死循环的话，应该如何保证对象的析构能被正常执行呢？\n\n在死循环中加上 if(全局变量) 的判断逻辑，并在信号处理函数中设置变量\n在信号处理函数中手动调用一个 shutdown 函数，为了避免一个函数写两次，可以在析构函数中也调用这个 shutdown 函数。\n\n但是，如果你的进程中是多层嵌套循环的话，最终的退出可能没有完全退出，会导致析构函数不被正常调用的资源泄漏问题！如果你需要使用的资源中包含 IPC（进程间通信）这些必须要被删除的对象的话，这个问题就需要注意了。\n\n比如你进程退出的时候析构函数没有调用，没有删除掉消息队列，下一次启动的时候，消息队列读端如果先启动，有可能会读取到上次冗余的脏数据。\n所以我们要保证 IPC 资源能被正常释放。\n\n2.9.2 sa_mask这个成员是一个 sigset_t 类型，用于当处理一个信号的时候，连带屏蔽其他信号；\n\n当一个进程正在处理 A 信号的时候，操作系统会把 A 信号自动添加入 Block 表，屏蔽该信号（不允许同时处理两个 A 信号，避免信号 A 的  递归式处理）\n\n如果你想在处理 2 号信号的时候，阻塞掉 3、4、5 号信号，就可以对 sa_mask 进行设置，设置方法参考 2.8 的操作\n因为现在我演示的自定义方法只是一个再简单不过的示例，实际上进程收到信号的时候需要根据不同情况进行不同的自定义处理，这些自定义处理的过程可能会很长。此时就可以 block 掉其他的信号，不让它们影响当前进程运行的自定义方法\n3. 软件崩溃的本质  之前我们经常会遇到软件出错奔溃的情况，那么奔溃的本质是什么呢？\n3.1 情景演示  用下面的一个  除零错误  作为演示\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process &quot; &lt;&lt; getpid() &lt;&lt; &quot; get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;void TestSignal()&#123;    // 对所有的进程信号都设置一个回调    for (int sig = 1; sig &lt;= 31; sig++)    &#123;        signal(sig, handler);    &#125;    cout &lt;&lt; &quot; 进程信号已经设置完了 &quot; &lt;&lt; endl;    sleep(3);&#125;int main(int argc, char *argv[])&#123;    TestSignal();    int a = 10;    int b = 0;    try    &#123;        int c = a / b; // C++ 的除 0 不是异常，不会抛出        // 所以会直接 linux 系统运行报错    &#125;    catch (const exception &amp;e)    &#123;        cerr &lt;&lt; &quot;a/0 err&quot; &lt;&lt; endl;        abort();    &#125;    catch (...)    &#123;        cout &lt;&lt; &quot;base catch&quot; &lt;&lt; endl;        abort();    &#125;    return 0;&#125;\n\n运行了之后，该进程会一直收到 8 号信号，直到我们手动 kill 掉这个进程\nprocess 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8Killed\n\n你可能会觉得奇怪，不是用 try/catch 进行了异常处理吗？为什么没有用呢？\n那是因为，在 C++ 中，并  不会将除零错误当作一个异常  进行处理！\n\n\n我们自定义捕捉了 8 号信号，没能让进程终止。但此时这个进程已经出现了一个严重的 bug，操作系统就会一直给进程发这个信号\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigFloating point exception[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n相比之下，如果不自定义捕捉，则会  直接报错 + 终止进程；\n8 号信号是 SIGFPE，FPE 即为Floating point exception 的缩写！\n3.2 说明  崩溃的本质，是该进程收到了异常信号，从而终止。\n以除零错误为例，CPU 内部会有一个状态寄存器，检测到用户进行除零计算的时候，会将状态寄存器设置为  浮点数错误 。当操作系统检测到这个错误的时候，便会向当前 正在运行的进程  发送 8 号信号。而我们的进程在收到信号的时候，会处理这个信号，默认的处理方法就是终止进程！\n同理，当我们访问一个野指针的时候，操作系统能在虚拟地址转换的时候发现这个问题，向我们的进程发送 11 号信号\nint main(int argc, char *argv[])&#123;    TestSignal();    int *p;    *p=20;    return 0;&#125;\n\n11) SIGSEGV 代表  段错误，写 OJ 题目的时候这个报错很常见😂\nprocess 6754 get signal: 11process 6754 get signal: 11process 6754 get signal: 11process 6754 get signal: 11process 6754 get signal: 11Killed\n\n4.coredump在  进程控制  的博客中，提到当进程因为信号终止的时候，其 status 中的 0-7 位会是对应的终止信号，而第 8 位是该进程的 core dump 标记位\n\n在 1.2 贴出来的源码注释中可以看到，有不少信号的默认动作是进行core dump，比如 8 号信号。那么这个东西到底是什么玩意呢？\n\n通过 fork 创建子进程，让子进程除零产生 8 号信号，子进程退出\nint main(int argc, char *argv[])&#123;    int status;    int id = fork();    if(id == 0)    &#123;        // 子进程        int b=0;        int a = 10/b;    &#125;    int ret = waitpid(id,&amp;status,0);    // 打印子进程的退出信息    printf(&quot;exitcode:%d signo:%d coredump: %d\\n&quot;,(status&gt;&gt;8)&amp;&amp;0xff,status&amp;0x7f,(status&gt;&gt;7)&amp;0x1);    return 0;&#125;\n\n此时可以观察到，coredump 标记位为 0\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigexitcode:0 signo:8 coredump: 0\n\n4.1 开启该功能  默认情况下，我们云服务器的 core dump 功能是被关闭的，需要我们手动开启；\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -acore file size          (blocks, -c) 0  #coredump 功能被关闭了data seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 14691max locked memory       (kbytes, -l) unlimitedmax memory size         (kbytes, -m) unlimitedopen files                      (-n) 100002pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) 14691virtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n使用 ulimit -a 命令指定 core file 的大小\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -c 10000[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -acore file size          (blocks, -c) 10000\n\n再次运行刚刚的代码，可以看到标记位为 1，并且产生了一个 core.27908 文件，这个文件的后缀是产生 coredump 文件的进程 pid\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigexitcode:0 signo:8 coredump: 1[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ lltotal 292-rw------- 1 muxue muxue 593920 Nov 20 12:34 core.27908-rw-rw-r-- 1 muxue muxue    194 Nov 20 10:31 makefile-rw-rw-r-- 1 muxue muxue    601 Nov 20 09:57 mkill.cc-rw-rw-r-- 1 muxue muxue    203 Nov 20 09:56 test.cc-rwxrwxr-x 1 muxue muxue  13768 Nov 20 12:34 tsig-rw-rw-r-- 1 muxue muxue   1772 Nov 20 12:34 tsignal.cpp[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\nvscode 告诉我们这个不是一个普通的文本文件\n\n这个现象告诉我们，默认动作是 coredump 的信号，会让进程退出，将 coredump 标记位置为 1 并且产生一个 core. 文件\n4.2 使用 coredump这个功能会将进程在运行中产生异常的上下文数据，执行 core dump（核心转储）为一个文件，方便我们 debug\n如下所示，使用 -g 命令以 debug 模式编译 test.cc, 运行的时候可以看到除零错误之后跟了一个(core dumped) 提示我们进行了 core dump 操作，对应产生了一个 core. 文件\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ g++ test.cc -g -o test[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./testFloating point exception (core dumped)\n\n这时候打开 gdb，输入 core-file 文件名 加载文件，就可以直接定位到出错代码的位置！\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ gdb testGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/muxue/git/linux/code/22-11-16_signal/test...done.(gdb) core-file core.31997[New LWP 31997]Core was generated by `./test&#x27;.Program terminated with signal 8, Arithmetic exception.#0  0x000000000040065c in main () at test.cc:1313          int a=10/0;Missing separate debuginfos, use: debuginfo-install glibc-2.17-326.el7_9.x86_64 libgcc-4.8.5-44.el7.x86_64(gdb)(gdb)\n\n这可比我们手动 debug 找错误方便多了\n\n4.3 为什么默认关闭？你可能会觉得，这个功能不挺好的吗，为啥默认没有开启呢？\n先来看看这个文件的大小，足足有580KB\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ls -lhttotal 292K-rw-rw-r-- 1 muxue muxue 1.8K Nov 20 12:37 tsignal.cpp-rw------- 1 muxue muxue 580K Nov 20 12:34 core.27908\n\n一般而言，服务端运行的一些进程，都需要保持稳定性。比如 B 站的服务器挂了，第一时间要做的是  重启服务进程（并不是重启服务器机器）\n如果设置了这个 coredump，当服务器进程因为错误退出的时候，会生成一个 core. 文件；这时候有一个守护进程（用来监视并及时重启服务器进程）发现服务器进程退出了，就会重启它。\n这时候又遇到了刚刚那个 bug，服务器进程又退出了，守护进程又来重启它……\n如此往复，就会生成非常非常多的 core. 文件，塞满我们的硬盘。\n对于  求稳  为主的服务器而言，这可不是一个好事。所以云服务器上默认禁止了这个功能。\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -c 0[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -acore file size          (blocks, -c) 0\n\n用 umlimit -c 0 指定大小为 0 关闭该功能\n\n5. 进程处理信号  前面八八了这么一大堆，进程到底是什么时候来处理信号的呢？\n\n开门见山：进程从内核态切换成用户态的时候，处理信号\n\n5.1 内核态 &#x2F; 用户态  在程序地址空间的博客中，提到了每一个进程都有 1gb 的内核空间；该内核空间用于内核级页表的映射，即映射操作系统的物理内存！\n\n有内核级页表的存在，无论进程怎么切换，都能找到操作系统内核的代码和数据，前提是有权限访问。\n\nCPU 中的 CR3 状态寄存器会标识当前进程处于内核态还是用户态\n内核态可以访问所有代码和数据，权限最高\n用户态只能访问当前进程自己的数据\n\n当我们进程需要执行内核接口的时候，就需要将进程切换为内核态；运行完毕之后，切换回用户态。\n当我们进程出现了异常，会从用户态切换成内核态，由操作系统检测相关异常并向进程发送对应信号。\n当我们进程的  时间片  到了（需要切换进程）也会从用户态转为内核态，由操作系统来进行进程切换。\n5.2 信号检测  当进程从内核态切换回用户态的时候，会进行信号的检测和处理。此时判断 pending 表中是否有未处理信号，以及该信号是否有被 block。如果一个信号没有被 block，则将该信号递达给进程，执行对应的处理方法\n\n执行用户的自定义方法时，应该以什么身份执行？\n\n注意，当我们给一个信号指定了自定义处理方法，就代表该信号的处理方法是  用户提供的。此时需要以用户的身份去执行这个代码，才能正确访问用户级页表。\n这么做也能  避免恶意代码  的注入。如果有人在自定义方法中写一个修改系统内核的恶意代码，也能被操作系统发现并阻止。\n这个过程可以用下面这张图来解释（并非完整过程，仅供参考理解）\n\n每次处理完信号后，会返回用户进程，从上一次中断的位置开始继续往后运行\n6. 可重入函数// 头插void insert(Node* p)&#123;\tp-&gt;next=head;\thead=p;&#125;\n\n上面这个函数是一个非常简单的链表头插函数\n如果我们这个头插函数处理的是一个全局的链表，就可能会因为用户态、内核态的切换，函数重入造成错误\n\n所以 insert 就是一个  不可重入函数！除了这个头插，还有一些其他的函数也符合这个特效：\n\n调用了 malloc 或者 free（可能会多次 malloc 和多次 free）\n调用了 I&#x2F;O 库的函数\n绝大多数库函数都是不可重入的，比如 C++ 的 STL 库\n\n依此类推，如果一个函数只访问他自己的局部变量，不会影响其他参数。那么他就是一个  可重入函数\n6.1 原子操作  所谓原子操作是指不会被 线程调度 机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）\n\n如果一个函数进行了对全局变量的原子操作，那么它也是  可重入  的函数。因为原子操作不包含中间态\n如果一个函数对全局变量进行了非原子操作（比如上面的链表头插）那么他就是一个不可重入函数\n\n7.volatile之前的学习中就已经知道，这个关键字的作用是每一次访问变量的时候，都必须要去内存中取。\n\n假设我们进程中需要通过一个  全局变量  进行  条件判断\nint flag=0;int main()&#123;    if(flags)    &#123;        //..    &#125;    else    &#123;        //..    &#125;    return 0;&#125;\n\n如果我们  自定义捕捉  了一个信号，收到该信号的时候，会修改 flag，执行 if&#x2F;else 语句中对应的代码。\n由于  编译器的优化问题，每一次访问 flag 的时候，它可能不会每次都去内存中取，就会出现一个问题\n\n寄存器中 flag&#x3D;0\n经过自定义捕捉函数处理，内存中 flag&#x3D;1\n\n这两个 flag 在 if 条件中会导向不同的结果！\n为了避免这种可能因为平台、编译器、优化问题导致的代码 bug，我们需要告诉所有编译器，不准对 flag 变量做任何优化处理，必须要老老实实的去内存中拿这个变量的数据！\n//volatile 保持内存的可见性volatile int flag = 0;\n\n7.1 示例\ngcc 编译器可以通过 -O2 指定较高的优化等级\n\n以下面的代码为例\n#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;// 保持内存的可见性int flag = 0;void handler(int signo)&#123;    flag = 1;    printf(&quot;\\n 更改 flags: 0-&gt;1\\n&quot;);&#125;int main()&#123;    printf(&quot;process start %d\\n&quot;,getpid());    signal(2, handler);// 自定义捕捉 2 号信号    while (!flag)        ;// 啥事不干的循环   \tprintf(&quot;process exit!\\n&quot;);    return 0;&#125;\n\n运行之后，键入 CTRL+C，你会发现进程依旧没有退出！理论上来说flags=1，!flags 为假，应终止循环，退出进程才对！\n[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test -O2[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./testprocess start 22333^C更改 flags: 0-&gt;1^C更改 flags: 0-&gt;1^C更改 flags: 0-&gt;1^C更改 flags: 0-&gt;1^\\Quit[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$\n\n如果我们加上 volatile 关键字，则不会出现这个问题，进程能够正常退出\n[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test -O2[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./testprocess start 23086^C更改 flag: 0-&gt;1process exit![muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$\n\n去掉 gcc 编译器的优化参数，去掉 volatile 关键字，会发现进程也能正常退出\n[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./testprocess start 23224^C更改 flag: 0-&gt;1process exit![muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$\n\n这就是编译器优化不同的影响！加上 volatile 关键字能避免这个问题，使代码运行能有唯一结果！\n8. 子进程发送信号  当子进程的状态变化的时候，会向父进程发送 17 号信号\nvoid testfork()&#123;    int status;    int id = fork();    if(id == 0)    &#123;        // 子进程        cout &lt;&lt; &quot;chlid process: &quot; &lt;&lt;getpid()&lt;&lt;endl;        int b=0;        int a = 10/b;    &#125;    TestSignal();    int ret = waitpid(id,&amp;status,0);    // 打印子进程的退出信息    printf(&quot;exitcode:%d signo:%d coredump: %d\\n&quot;,(status&gt;&gt;8)&amp;&amp;0xff,status&amp;0x7f,(status&gt;&gt;7)&amp;0x1);&#125;\n\n观察结果，可以看到父进程收到了子进程的 17 号信号，此时子进程因为  错误退出\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了chlid process: 25319process 25318 get signal: 17exitcode:0 signo:8 coredump: 0[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n除了退出时会发送信号，子进程暂停、继续运行的时候，都会向父进程发送信号\n\n8.1 父进程回收子进程  既然父进程能收取到子进程发送的信号，那么我们自定义捕捉 17 号信号，在其中调用waitpid，即可在子进程出错或执行完毕需要退出的时候，进行父进程回收\n\n这样就不需要在 main 函数中进行主动 wait 了\n\n操作并不难，我们只需要将 17 号信号进行自定义捕捉，在捕捉函数中执行 waitpid 进行等待即可\n\n注意：这里的 waitpid 必须使用 WNOHANG 进行非阻塞等待\n当父进程正在阻塞等待子进程 A 的时候，它在处理 17 号信号，新的 17 号信号无法收到\n这就会导致在 A 之后种子的子进程，无法向父进程发送有效的 17 号信号\n从而出现了僵尸进程（未回收的子进程）\n\n使用  非阻塞等待，即可以避免此问题，又能让父进程在等待的过程中处理自己的其他工作，一举两得。\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;cassert&gt;using namespace std;void FreeChld(int signo)&#123;    assert(signo == SIGCHLD);    while (true)    &#123;        // 如果没有子进程了，waitpid 就会调用失败        pid_t id = waitpid(-1, nullptr, WNOHANG); // 非阻塞等待        if (id &gt; 0)        &#123;            cout &lt;&lt; &quot; 父进程等待成功, child pid: &quot; &lt;&lt; id &lt;&lt; endl;        &#125;        else if(id == 0)        &#123;            // 还有子进程没有退出            cout &lt;&lt; &quot; 尚有未退出的子进程，父进程继续运行 &quot; &lt;&lt; endl;            break;// 退出等待子进程        &#125;        else        &#123;            cout &lt;&lt; &quot; 父进程等待所有子进程结束 &quot; &lt;&lt; endl;            break;        &#125;    &#125;&#125;int main()&#123;    signal(SIGCHLD, FreeChld);    for (int i = 0; i &lt; 5; i++)    &#123;        pid_t id = fork();        if (id == 0)        &#123;            // 子进程            int cnt = 8;            while (cnt)            &#123;                cout &lt;&lt; &quot; 子进程 pid: &quot; &lt;&lt; getpid() &lt;&lt; &quot; cnt: &quot; &lt;&lt; cnt-- &lt;&lt; endl;                sleep(1);            &#125;            cout &lt;&lt; &quot; 子进程退出，进入僵尸状态: &quot; &lt;&lt; i &lt;&lt; endl;            exit(0);        &#125;        sleep(2);    &#125;    while (true)    &#123;        cout &lt;&lt; &quot; 父进程正在运行: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    return 0;&#125;\n\n如下右图中，第 0 个子进程退出进入将是状态，父进程收到 17 号信号，就开始回收子进程。此时还有 4 个子进程没有运行完毕，父进程会继续运行，等待其他子进程结束\n\n当所有子进程都等待结束了，waitpid返回 -1 让父进程退出回收子进程的循环，现在就只有父进程自己在干活了\nwhile :; do ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\n反应到监控信息上，父进程先是创建了 5 个子进程\n\n随后当第一个子进程退出的时候，父进程开始回收子进程。这里也能观测到，回收成功，并没有出现  僵尸状态  的子进程。\n\n8.2 父进程忽略子进程  前面提到过，SIG_IGN的作用是忽略这个子进程；你可能会想，这不对啊，忽略了子进程的信号，那岂不是父进程不想搭理子进程了吗？\n*\t|  SIGCHLD           |\tignore   \t|\n\n查 1.2 表你还会发现，SIGCHLD 的  默认动作  不就是忽略吗？自己设置一下是不是多此一举？\nsignal(SIGCHLD, SIG_IGN);\n\n然并不是这样，对于 SIGCHLD17 号信号而言，我们给父进程设置了手动忽略后，子进程退出的时候将 自动被回收\n这么做的前提，是父进程不需要和子进程在回收资源的时候进行处理，说人话就是，只要父进程不想管任何子进程的工作，那就可以直接把 17 号信号手动设置成SIG_IGN\n\n结语  进程信号到这里就基本 over 了，干货满满！\n如果对你有帮助，还请点个赞吧！！！\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】进程通信 | 共享内存 | 信号量","url":"/posts/3323274806/","content":"上篇 Linux 的博客是有关管道的，今日就让我们继续康康进程间通信的另外一种方法：共享内存\n\n\n完整代码详见我的 gitee 仓库 👇\n\nhttps://gitee.com/musnow/raspberry-practice/tree/master/code/22-11-12_systemV\n\n[TOC]\n1. 啥是共享内存？进程间通信的基本方式，就是让两个进程看到同一份资源。\n共享内存 (shm) 实现进程间通信的方式，通过系统接口开辟一段内存，再让多个进程去访问这块内存，就能同时看到一份资源。\n\n这里贴出之前动态库博客中的图，共享内存的方式和该图展示的方式类似。进程需要调用系统接口，将已经开辟好的共享内存映射到自己的页表中，以实现访问。\n这里就出现了一个问题：\n\n操作系统的接口怎么知道进程要的是那一块共享内存？即共享内存是怎么标识的？\n\n要知道，之前我们打开文件、开辟管道等等，都是具有唯一的文件路径来标识文件的。如果按以前的想法：打开文件 -&gt; 系统返回文件的文件描述符 ，共享内存则应该是 开辟共享内存 -&gt; 系统返回共享内存的编号\n\n这就出现了问题！\n\n假设进程 A 开辟了一段共享内存，系统返回了编号 123，那么进程 A 要怎么让其他想使用这块共享内存进行通信的进程，知道它开辟的共享内存编号  是 123 呢？总不能开个管道告诉它吧？那岂不是多此一举😂\n\n所以，共享内存的  编号  其实和命名管道一样，是由用户手动在代码中指定的。只要进程使用这个编号去获取共享内存，他们就能获取到同一份！\n\n2. 相关接口  说完了基本概念，现在让我们来康康它的使用\n2.1 ftokftok - convert a pathname and a project identifier to a System V IPC key\n#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;key_t ftok(const char *pathname, int proj_id);\n\n前面提到了，共享内存的 key 是我们自己指定的。Linux 系统给定了 ftok 接口，将用户提供的 pathname 工作路径，以及 proj_id 项目编号转换为一个共享内存的 key（其实就是 int 类型）\n\n只要我们的  工作路径和项目编号  传的是一样的，那么它返回的 key 就是一样的！\n这个函数也能用于信号量的 key 的创建！\n2.2 shmgetshmget - allocates a System V shared memory segment\n#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg);\n参数分别为 key 值，共享内存的大小，以及创建共享内存的方式。\nkey 值需要通过  ftok 函数获取；\n其中共享内存的大小最好设置为 4kb 的整数倍，因为操作系统 IO 的基本单位是 4KB。如果你申请了不是 4 的整数倍的字节，比如 15 个字节，其还是会申请 16 个字节 (4 个页) 交给你，而其中有 1kb 的内存你是无法使用的，即造成了内存浪费😥\n创建共享内存的shmflg:\n\nIPC_CREAT：创建共享内存。如果存在则获取，如果不存在则创建后获取\nIPC_EXCL：必须配合 IPC_CREAT 使用，如果不存在指定的共享内存，就进行创建；如果该共享内存存在，则  出错返回（即保证获取到的共享内存一定是当前进程创建的，是一个新的共享内存）\n\n返回值是一个共享内存的  标识符\nRETURN VALUE       On success, a valid shared memory identifier is returned.  On errir, -1 is returned, and errno is set to indicate the error.\n\n这些工作都是操作系统做的。其内核中有专门的管理单元来判断一个共享内存是否存在，以及何时被创建、被使用、被什么进程绑定等等…\n命令行键入man shmctl，可以看到下面的内核结构\nstruct shmid_ds &#123;    struct ipc_perm shm_perm;    /* Ownership and permissions */    size_t          shm_segsz;   /* Size of segment (bytes) */    time_t          shm_atime;   /* Last attach time */    time_t          shm_dtime;   /* Last detach time */    time_t          shm_ctime;   /* Last change time */    pid_t           shm_cpid;    /* PID of creator */    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */    shmatt_t        shm_nattch;  /* No. of current attaches */    ...&#125;;struct ipc_perm &#123;    key_t          __key;    /* Key supplied to shmget(2) */    uid_t          uid;      /* Effective UID of owner */    gid_t          gid;      /* Effective GID of owner */    uid_t          cuid;     /* Effective UID of creator */    gid_t          cgid;     /* Effective GID of creator */    unsigned short mode;     /* Permissions + SHM_DEST and                                           SHM_LOCKED flags */    unsigned short __seq;    /* Sequence number */&#125;;\n\n共享内存要被管理，其内核结构中一定有一个唯一的 key 值来标识该共享内存，即和文件的 inode 一样\nkey_t     __key; // 共享内存的唯一标识符，由用户在 shmget 中提供\n\n关于 key 为何要让用户提供，已经在上面做出过解释👉 回顾一下\n\n2.3 shmat&#x2F;shmdtat 其实是 attach 绑定的缩写，这个接口的作用是将一个共享内存和我们当前的进程绑定。\n其实就是将这个共享内存映射到进程的页表中（堆栈之间）\nshmat, shmdt - System V shared memory operations\n#include &lt;sys/types.h&gt;#include &lt;sys/shm.h&gt;void *shmat(int shmid, const void *shmaddr, int shmflg);int shmdt(const void *shmaddr);\n\n一共有两个函数，分别为 at 和 dt，用于绑定 &#x2F; 解绑共享内存\nshmat的三个参数如下\n\nshmid：为 shmget 的返回值\nshmaddr：指定共享内存连接到当前进程中的地址位置。通常为空，表示让系统来选择共享内存的地址。\nshmflg：如果指定了 SHM_RDONLY 位，则以只读方式连接此段；否则以读写的方式连接此段；通常设置为 0\n\n调用成功的时候，返回指向共享内存第一个字节的指针；出错返回 -1\n\nshmdt的参数为 shmat 正确调用时的返回值\n\n以下是 man 手册中对这两个函数返回值的描述👇\nRETURN VALUE       On success shmat() returns the address of the attached shared memory segment; on error (void *) -1 is returned, and errno is set  to       indicate the cause of the error.       On success shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.\n\n2.4 shmctl这个函数可以用于操作我们的共享内存\n#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmctl(int shmid, int cmd, struct shmid_ds *buf);\n\n其中 cmd 的参数有下面几种\n\nIPC_RMID  删除该共享内存\n\nIPC_STAT  把 shmid_ds 结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖 shmid_ds 的值\n\nIPC_SET 如果进程有足够的权限，就把共享内存的当前关联值设置为 shmid_ds 结构中给出的值\n\n\n最后一个 buf 参数是一个指向 shmid_ds 结构的指针，一般设为 NULL\nThe buf argument is a pointer to a shmid_ds structure\n\nshmid_ds的基本结构如下\nstruct shmid_ds&#123;    uid_t shm_perm.uid;    uid_t shm_perm.gid;    mode_t shm_perm.mode;&#125;;\n\n以删除为例，其操作如下\nshmctl(shmid, IPC_RMID, NULL);// 删除 shmid 的共享内存\n\n2.5 ipcs 命令  先来康康几个 ipcs 命令的选项，这些命令可以帮助我们查看共享资源。其中我们要用到的是 -m 查看共享内存\nipcs -c # 查看消息队列 / 共享内存 / 信号量ipcs -s # 单独查看信号量ipcs -q # 单独查看消息队列ipcs -m # 单独查看共享内存\n\n执行了之后，会列出当前操作系统中开辟的共享内存，以及它们的基本信息\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m ------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 1          muxue      0          1024       0    \n\n这里的 key 和我们使用 ftok 获取到的 key 值是一样的，只不过我们打印的时候是十进制，操作系统列出来的为十六进制。\nipcrm 删除进程通信资源  这个命令可以用与删除 ipc 资源，包括共享内存\nipcrm -m shmid # 删除共享内存\n\n我们可以使用 ipcrm -m 共享内存的 shmid 来删除共享内存\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 1          muxue      0          1024       0                       [muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcrm -m 1[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       \n\n可以看到我们自己创建的共享内存已经被删除了。\n\n但是，当我们尝试用该命令删除一个  正在被使用  的共享内存时，它并不会被立即删除（立即删除会影响进程运行）\n此时执行删除，在共享内存的 status 列会出现 dest；观察结果，当 进程结束  的时候，这个共享内存会被直接删除（进程内部并没有调用 shmctl 接口）\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 21         muxue      666        1024       2                       [muxue@bt-7274:~/git]$ ipcrm -m 21[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x00000000 21         muxue      666        1024       2          dest         [muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                 \n\n相比之下，如果不执行 ipcrm 命令 + 进程内部不调用 shmctl 接口，这个共享内存就会一直存在\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 22         muxue      666        1024       0                       \n\n结论：使用 ipcrm -m 命令删除共享内存之后，其共享内存不一定会立即释放。如果有进程关联了该共享内存，则会在进程  去关联之后释放；\n2.6 共享内存和管道的对比  面试的时候问道了这个问题！\n\n2.7 消息队列 mq&#x2F; 信号量的接口  消息队列和信号量的接口和共享内存很相似\n消息队列用的不多，信号量的难度很高！😂 后文会介绍信号量。\n// 消息队列相关接口msgget // 获取msgctl // 操作msgsnd // 发送信息msgrcv // 信号量semgetsemctlsemop\n\n3. 使用3.1 创建并获取// 头文件实在太多，为了博客篇幅，这里省略了#define NUM 1024#define PROJ_ID 0x20#define PATH_NAME &quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;key_t CreateKey()&#123;    key_t key = ftok(PATH_NAME, PROJ_ID);    if(key &lt; 0)    &#123;        cerr &lt;&lt;&quot;ftok: &quot;&lt;&lt; strerror(errno) &lt;&lt; endl;        exit(1);//key 获取错误直接退出程序    &#125;    return key;&#125;int main()&#123;    key_t key = CreateKey();    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    return 0;&#125;\n\nFile exists这里会发现，第一次运行代码的时候，程序成功获取了共享内存；但是第二次运行的时候，却报错说File exists(文件存在)\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./testshmget: 1[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./testshmget err: File exists\n\n这是因为共享内存的声明周期是随内核的。即只要这个共享内存不被删除，他就会一直存在，直到内核因为某种原因释放掉它，亦或者操作系统关机\n通过上面提到的ipcrm -m shmid 命令删除共享内存，才能重新运行代码获取新的共享内存\n\n为了避免这个问题，应该在进程结束后使用 shmctl 接口删除共享内存\n\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./testshmget success: 2[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 2          muxue      0          1024       0                       \n\n设置权限值  默认情况下，我们创建的共享内存的 perms 是 0，代表没有用户能访问这个共享内存。所以在创建的时候，我们需要在 flag 里面直接或上这个共享内存的权限值       \n代码如下👇\nint main()&#123;    key_t key = CreateKey();    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | 0666);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    sleep(5);    shmctl(id,IPC_RMID,nullptr);    return 0;&#125;\n\n这时候创建的共享内存就有正确的权限值了\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 4          muxue      666        1024       0    \n\n3.2 挂接 &#x2F; 取消挂接// 关联共享内存char *str = (char*)shmat(id, nullptr, 0);\n\n因为 shmat 函数的返回值是一个 void* 指针，我们可以以使用 malloc 一样的方式使来挂接共享内存。随后对这个内存的操作就是正常的指针操作了！\n同样的，另外一个进程也需要用同样的方式挂接共享内存，才能读取到相同的数据\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 4          muxue      666        1024       1   \n\n挂接成功后，可以发现 nattch 的值从 0 变为 1\n取消 &#x2F; 删除  取消挂接的方式很简单，直接把 shmat 的返回值传入即可\nshmdt(str);// 取消挂接\n\n如果是服务端，则还需要在取消挂接之后，删除共享内存。避免下次程序运行的时候，无法通过 key 获取到新的共享内存\nshmctl(id,IPC_RMID,nullptr);// 删除共享内存\n\n3.3 写入内容  因为共享内存本质就是一个内存，其和 malloc 出来的内存都是一样的，直接使用即可\n这里还是用一个服务端和一个客户端来进行演示\n//server.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    // 获取 key 值    key_t key = CreateKey();    // 创建共享内存    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | 0666);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    sleep(2);    // 关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[server] shmat success\\n&quot;);    // 读取数据，sleep(1)    int i=0;    while(i&lt;=40)    &#123;        printf(&quot;[%03d] %s\\n&quot;,i,str);        i++;        sleep(1);    &#125;    // 去关联    shmdt(str);//shmat 的返回值    printf(&quot;[server] shmdt(str)\\n&quot;);    // 删除共享内存    shmctl(id,IPC_RMID,nullptr);    printf(&quot;[server] exit\\n&quot;);    return 0;&#125;//client.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    // 获取 key 值    key_t key = CreateKey();    // 获取共享内存    int id = shmget(key, NUM, IPC_CREAT);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    sleep(2);    // 关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[client] shmat success\\n&quot;);    // 写入数据    int i=0;    while(i&lt;26)    &#123;        char base = &#x27;A&#x27;;        str[i] = base+i;        str[i+1] = &#x27;\\0&#x27;;        printf(&quot;write times: %02d\\n&quot;,i);        i++;        sleep(1);    &#125;    // 去关联    shmdt(str);//shmat 的返回值    printf(&quot;[client] shmdt &amp; exit\\n&quot;);    return 0;&#125;\n\n跑起来之后，客户端向共享内存中写入数据（注意控制\\0）服务端进行读取。这便实现了我们进程之间的通信\n\n不过我们发现，客户端已经停止写入之后，服务端还是在不停的读取。如果我们不控制 while 循环的话，其会一直这么读取下去\n\n这便牵扯出共享内存的一个特性了\n共享内存没有访问控制  在管道的博客中提到，管道是有访问控制的进程通信方式，写端没有写入数据的时候，读端会在 read 中进行等待。\n而共享内存因为我们是直接像操作一个 malloc 出来的空间一样访问，没有使用任何系统接口（相比之下管道需要使用read/write）所以操作系统没有办法帮我们进行访问控制！\n也正是因为没有阻塞等待就能直接访问这块内存空间，共享内存是进程中通信中  最快  的一种方式。\n通过管道进行共享内存的控制  既然共享内存没有访问控制，那么我们可以利用管道来让控制共享内存的读写\n\n写端写完后，将  完成信号  写入管道，由读端读取\n读端从管道中获取到信号后，访问共享内存读出内容\n如果写端没有写好，读端就会在管道 read 内部等待\n\n你可能会说，那为何不直接用管道通信呢？\n\n管道仅作访问控制，只需要一个 int 乃至一个 char 类型即可；\n相比直接管道通信，共享内存的方式更好控制（毕竟使用内存的方式和使用指针一样，我们比较熟悉，管道还需要文件操作；）\n读取很长一串数据的时候，共享内存的速度优势能体现出来；\n\n以下是完整代码👇\n//mykey.hpp#pragma once#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;using namespace std;#define NUM 1024#define PROJ_ID 0x20#define PATH_NAME &quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;#define FIFO_FILE &quot;sc.pipe&quot;key_t CreateKey()&#123;    key_t key = ftok(PATH_NAME, PROJ_ID);    if(key &lt; 0)    &#123;        cerr &lt;&lt;&quot;ftok: &quot;&lt;&lt; strerror(errno) &lt;&lt; endl;        exit(1);//key 获取错误直接退出程序    &#125;    return key;&#125;void CreateFifo()&#123;    umask(0);    if(mkfifo(FIFO_FILE, 0666) &lt; 0)    &#123;        cerr &lt;&lt; &quot;fifo: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(2);    &#125;&#125;// 打开管道文件int Open(int flags)&#123;    return open(FIFO_FILE, flags);&#125;// 让读端通过管道等待ssize_t Wait(int fd)&#123;    char val = 0;    // 如果写端没有写入，其就会在 read 中等待    ssize_t s = read(fd, &amp;val, sizeof(val));    return s;&#125;// 发送完成信息int Signal(int fd)&#123;    char sig = &#x27;g&#x27;;    write(fd, &amp;sig, sizeof(sig));&#125;//server.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    // 创建管道    CreateFifo();    // 获取 key 值    key_t key = CreateKey();    // 创建共享内存    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | 0666);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    // 获取管道    int fd = Open(O_RDONLY);    cout &lt;&lt; &quot;open fifo success: &quot; &lt;&lt; fd &lt;&lt; endl;    sleep(2);    // 关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[server] shmat success\\n&quot;);    // 读取数据    int i=0;    while(i&lt;=40)    &#123;        ssize_t ret = Wait(fd);// 通过管道等待        if(ret!=0)        &#123;            printf(&quot;[%03d] %s\\n&quot;,i,str);            i++;            sleep(1);        &#125;        else        &#123;            cout&lt;&lt;&quot;[server] wait finish, break&quot; &lt;&lt; endl;            break;        &#125;    &#125;    // 去关联    shmdt(str);//shmat 的返回值    printf(&quot;[server] shmdt(str)\\n&quot;);    // 删除共享内存    shmctl(id,IPC_RMID,nullptr);    close(fd);    unlink(FIFO_FILE);    printf(&quot;[server] exit\\n&quot;);    return 0;&#125;//client.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    // 获取 key 值    key_t key = CreateKey();    // 获取共享内存    int id = shmget(key, NUM, IPC_CREAT);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    // 获取管道    int fd = Open(O_WRONLY);    cout &lt;&lt; &quot;open fifo success: &quot; &lt;&lt; fd &lt;&lt; endl;    sleep(2);    // 关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[client] shmat success\\n&quot;);    // 写入数据    int i=0;    while(i&lt;26)    &#123;        char base = &#x27;A&#x27;;        str[i] = base+i;        str[i+1] = &#x27;\\0&#x27;;        printf(&quot;write times: %02d\\n&quot;,i);        i++;        Signal(fd);        sleep(1);    &#125;    // 去关联    shmdt(str);//shmat 的返回值    printf(&quot;[client] shmdt &amp; exit\\n&quot;);    close(fd);    printf(&quot;[client] close fifo\\n&quot;);    return 0;&#125;\n\n运行结果  管道控制了之后，当客户端退出的时候，管道也不会继续读取，而是在 read 内等待\n\n如果客户端最后关闭了管道的写段，服务器端就会直接退出。这样我们就实现了通过管道控制  共享内存  的读写👍\n\n\n4. 相关概念 4.0 临界资源 能被多个进程看到的资源，被称为  临界资源\n如果不对临界资源进行访问控制，进程对该资源的访问就是  乱序的（比如父子进程向显示器打印内容）可能会因为数据交叉导致乱码、数据不可用等情况；\n以此可见，显示器、管道、共享内存都是临界资源。\n\n管道  是有访问控制的临界资源\n\n进程访问临界资源的代码，称为  临界区\n\n一个进程中，并不是所有的代码都在访问临界资源。如管道中，其实只有 read/write 接口在访问临界资源。\n\n互斥：任何时刻，只允许一个进程访问临界资源。\n原子性 ：一件事情只有 做完 / 没做  两种状态，没有中间状态。\n下面对信号量的概念进行讲解~ 只用基本理解即可；\n4.1 信号量 4.1.1 概念 信号量是对  临界资源  的控制方式之一，其本质是一个  计数器 ；准确来说，是一个拥有 原子性  的计数器。\n\n信号量保证  不会有多余  的进程连接到这份临界资源\n还需要保证每一个进程的能够访问到临界资源的不同位置（根据上层业务决定）\n\n信号量根据情况的不同分为两种：\n\n二元信号量（互斥  状态，当进程使用的时候为 1，没有进程使用的时候为 0）\n多元信号量（常规的计数器）\n\n如果一个进程想访问由信号量控制的临界资源，必须先申请信号量才能进行访问。但是只要我申请成功了，就一定能访问到这个临界资源中的一部分（或者全部）\n4.1.2 原子性的说明  先来想想，我们对一个变量 +1/-1 需要做什么工作：\n\n将这个变量从内存中拿到 CPU 的寄存器中\n在寄存器中完成加减操作\n放回内存\n\n这其中是有很多个中间状态的，设该变量初始值为 100\n\n假设一个进程 A 拿走了这个变量，放入 CPU 的寄存器\n另外一个进程 B 也来拿走了这个变量\n此时 A 和 B 拿到的都是 100\nA 对该变量进行了循环 -- 操作，最终该变量变成了 50，将其放回内存\nB 对该变量-1，将其放回内存\n最终导致 A 对变量的操作被 B 覆盖，出现了变量不统一的情况\n\n而我们的信号量为了保证能够正确的控制进程的访问，其就必须维护自身的原子性 ！不能有 中间状态\n\n说人话就是，如果进程 A 在访问信号量，进程 B 来了，信号量应该拒绝 B 的访问，直到 A 访问结束。不能让 B 中途插入访问，从而导致  可能的数据不统一；\n\n共享内存同样可以通过信号量进行访问控制\n\n4.1.3 接口  创建信号量 semget使用如下函数获取一个信号量，或者创建一个新的信号量；\n调用这个函数之前，我们需要使用 ftok 函数创建一个 key_t 值作为信号量的标识符。\nint semget(key_t key, int nsems, int semflg);\n\n\nkey 是一个唯一标识符，用于标识信号量集。\nnsems 是信号量集中信号量的数量。\nsemflg 是标志位，用于指定信号量的权限。\n\n一般情况下，我们将 semflg 写为 IPC_CREAT | 权限值 ，这里的权限值和 linux 中文件权限值是相同的，比如需要所有人都有一切权限，就可以写 777；一般写成 666 就行了，这代表所有用户，所属组和其他用户都拥有读写权限。\n指定了 IPC_CREAT 标志位，则表示如果该信号量不存在，则创建它；如果存在，则返回已存在的信号量的标识符。\n初始化信号量 semctlint semctl(int semid, int semnum, int cmd, ...);\n\n\nsemid 是信号量集的标识符。\nsemnum 是信号量在信号量集中的索引。\ncmd 是操作指令，可以是 SETVAL、GETVAL 等。\n对于 SETVAL 操作指令，需要通过可变参数 ... 来设置初始化的值。\n\n对于该函数的第三个参数cmd，有如下类型的选项\n\nIPC_STAT：获取信号量的状态信息，包括信号量的当前值、最后一次修改时间等。\nIPC_SET：设置信号量的状态信息，比如设置信号量的权限、所有者等。\nIPC_RMID：删除信号量，释放占用的系统资源。\nGETVAL：获取信号量的当前值。\nSETVAL：设置信号量的当前值。\n\n除了上述常见的操作类型，还有其他一些操作类型用于更具体的操作，例如：\n\nGETPID：获取最后一次操作信号量的进程 ID。\nGETNCNT：获取当前正在等待信号量解锁的进程数量。\nGETZCNT：获取当前等待信号量解锁的进程数量。\n\n根据我们的需要选择对应的操作符来进行信号量的操作即可；\n如下是一个获取信号量当前值的操作。\nint semid;  // 信号量集标识符// 需要初始化int sem_num = 0;  // 信号量索引，如果信号量集里面只有一个信号量，就用 0int cmd = GETVAL;  // 获取信号量的命令，GETVAL 表示获取当前值// 执行这个函数时，返回值就是信号量当前值// 如果返回 -1 就代表获取失败了int sem_value = semctl(semid, sem_num, cmd);\n\n修改信号量 semopint semop(int semid, struct sembuf *sops, size_t nops);\n\n功能： 操作信号量，P V 操作\n参数： \n\nsemid 为信号量集的标识符；\nsops 指向进行操作的结构体数组的首地址；\nnsops 指出将要进行操作的信号的个数；\n\n返回值： 成功返回 0，出错返回-1\nRETURN VALUE       If successful semop() and semtimedop() return 0; otherwise they return -1 with errno indicating the error.\n\n结构体 sembuf这里我们会用到 struct sembuf这个结构体来操作信号量，在系统中这个结构体的声明如下\nstruct sembuf&#123;  unsigned short int sem_num;\t/* semaphore number */  short int sem_op;\t\t/* semaphore operation */  short int sem_flg;\t\t/* operation flag */&#125;;\n\n\nsem_num：表示要操作的信号量在信号量集中的索引，如果信号量集只有一个信号量，则为 0。\nsem_op：表示进行的操作类型，可以是正数、负数或零。正数表示增加（释放）信号量的值，负数表示减少（获取）信号量的值，零表示检查信号量的值。\nsem_flg：表示操作的标志位，用于指定额外的操作选项。一般用的是两个：\nSEM_UNDO 表示异常时撤回对信号量的操作\nIPC_NOWAIT 表示如果信号量没有就绪，不进行阻塞等待，直接错误退出\n\n\n\n比如如下操作，就是给信号量新增值的处理（如果 sem_op 为负数，那就是减去值）需要注意的是，信号量的值不能为负数。如果你想减去值，请保证信号量里面有足够的值给你减，否则进程会在 semop 中阻塞等待。\nstruct sembuf semaphore;semaphore.sem_num = 0;semaphore.sem_op = 1;  // 新增信号量 1semaphore.sem_flg = SEM_UNDO; // SEM_UNDO 标记位代表异常的时候还原（撤销）操作\n\n如下操作是等待信号量变成 0\nstruct sembuf semaphore;semaphore.sem_num = 0;    // 操作的信号量索引semaphore.sem_op = 0;     // 检查信号量的值semaphore.sem_flg = 0;    // 操作标志位为 0semop(semid, &amp;semaphore, 1);  // 等待信号量变成 0// 如果没有变成 0，就会阻塞等待// 如果 sem_flg 设置了 IPC_NOWAIT，那就不会阻塞等待，而是直接返回 EAGAIN\n\n在 man 手册里面是这么描述的\nIf  sem_op is zero, the process must have read permission on the semaphore set.  This is a &quot;wait-for-zero&quot; operation: if semval is zero,the operation can immediately proceed.  Otherwise, if IPC_NOWAIT is specified in sem_flg, semop() fails with errno set  to  EAGAIN  (andnone  of  the  operations  in sops is performed).  Otherwise, semzcnt (the count of threads waiting until this semaphore&#x27;s value becomeszero) is incremented by one and the thread sleeps until one of the following occurs:·  semval becomes 0, at which time the value of semzcnt is decremented.·  The semaphore set is removed: semop() fails, with errno set to EIDRM.·  The calling thread catches a signal: the value of semzcnt is decremented and semop() fails, with errno set to EINTR.\n\n翻译一下，如果 sem_op设置为了 0，且没有设置 IPC_NOWAIT，那么进程就会在 semop函数中等待，直到出现下面的情况：\n\n信号量变成 0，等待成功\n信号量被销毁\n执行流接收到信号退出（信号是下一章要学习的内容，和信号量没关系）\n\n示例  如下是单个进程操作信号量的示例代码\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/unistd.h&gt;int main() &#123;    int semid;    key_t key;    struct sembuf semaphore;    // 创建或获取信号量集    key = ftok(&quot;.&quot;, &#x27;S&#x27;);    semid = semget(key, 1, IPC_CREAT | 0666);    if (semid == -1) &#123;        perror(&quot;Failed to create semaphore\\n&quot;);        exit(1);    &#125;    printf(&quot;1\\n&quot;);    // 初始化信号量的值为 1    if (semctl(semid, 0, SETVAL, 1) == -1) &#123;        perror(&quot;Failed to initialize semaphore value\\n&quot;);        exit(1);    &#125;    printf(&quot;12\\n&quot;);    // 对信号量进行操作    semaphore.sem_num = 0;    semaphore.sem_op = 34;  // 新增信号量值    semaphore.sem_flg = SEM_UNDO;    if (semop(semid, &amp;semaphore, 1) == -1) &#123;        perror(&quot;Failed to perform semaphore operation\\n&quot;);        exit(1);    &#125;    printf(&quot;13\\n&quot;);    // 获取信号量的当前值    int cmd = GETVAL;  // 获取信号量的命令，GETVAL 表示获取当前值    int sem_value = semctl(semid, 0, cmd);    if(sem_value == -1)    &#123;        perror(&quot;Failed to perform semaphore operation\\n&quot;);        exit(1);    &#125;    else&#123;        printf(&quot;current val for sem: %d\\n&quot;,sem_value);    &#125;    printf(&quot;14\\n&quot;);    // 释放信号量    semaphore.sem_op = -34;  // 减少信号量值    if (semop(semid, &amp;semaphore, 1) == -1) &#123;        perror(&quot;Failed to release semaphore\\n&quot;);        exit(1);    &#125;    printf(&quot;15\\n&quot;);    // 删除信号量集    if (semctl(semid, 0, IPC_RMID) == -1) &#123;        perror(&quot;Failed to remove semaphore\\n&quot;);        exit(1);    &#125;    printf(&quot;16\\n&quot;);    return 0;&#125;\n\n运行结果如下，这里的 printf 是我用来标识进程跑到那个阶段的，没有啥实际意义。\n11213current val for sem: 35141516\n\n4.2 扩展 mmap\n这部分仅供参考，可能有错误😥部分资料参考\n\n 前面贴出过 IPC 资源的内核结构，它们都有一个共同的特点：第一个成员都相同\nstruct shmid_ds &#123;    struct ipc_perm shm_perm;    /* Ownership and permissions */    size_t          shm_segsz;   /* Size of segment (bytes) */    time_t          shm_atime;   /* Last attach time */    time_t          shm_dtime;   /* Last detach time */    time_t          shm_ctime;   /* Last change time */    pid_t           shm_cpid;    /* PID of creator */    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */    shmatt_t        shm_nattch;  /* No. of current attaches */    ...&#125;;struct semid_ds &#123;    struct ipc_perm sem_perm;  /* Ownership and permissions */    time_t          sem_otime; /* Last semop time */    time_t          sem_ctime; /* Last change time */    unsigned long   sem_nsems; /* No. of semaphores in set */&#125;;struct msqid_ds &#123;    struct ipc_perm msg_perm;     /* Ownership and permissions */    time_t          msg_stime;    /* Time of last msgsnd(2) */    time_t          msg_rtime;    /* Time of last msgrcv(2) */    time_t          msg_ctime;    /* Time of last change */    unsigned long   __msg_cbytes; /* Current number of bytes in                                                queue (nonstandard) */    msgqnum_t       msg_qnum;     /* Current number of messages                                                in queue */    msglen_t        msg_qbytes;   /* Maximum number of bytes                                                allowed in queue */    pid_t           msg_lspid;    /* PID of last msgsnd(2) */    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */&#125;;\n\n它们的  第一个成员  都是一个struct ipc_perm，其中包含了一个信号量的基本信息\nstruct ipc_perm &#123;    key_t          __key;    /* Key supplied to shmget(2) */    uid_t          uid;      /* Effective UID of owner */    gid_t          gid;      /* Effective GID of owner */    uid_t          cuid;     /* Effective UID of creator */    gid_t          cgid;     /* Effective GID of creator */    unsigned short mode;     /* Permissions + SHM_DEST and                                           SHM_LOCKED flags */    unsigned short __seq;    /* Sequence number */&#125;;\n\n而内核中对 IPC 资源的管理，是通过一个  数组  进行的。我们所获取的 shmid，和文件描述符一样， 都是一个数组的下标\n其中我在测试的时候，便发现了一点：我们每一次获取的新的共享内存，它的编号都会+1，而不像文件描述符一样，提供第一个没有被使用的下标\nstruct ipc_ids &#123;    int in_use;// 说明已分配的资源个数    int max_id;// 在使用的最大的位置索引    unsigned short seq;// 下一个分配的位置序列号    unsigned short seq_max;// 最大位置使用序列    struct semaphore sem; // 保护 ipc_ids 的信号量    struct ipc_id_ary nullentry;// 如果 IPC 资源无法初始化，则 entries 字段指向伪数据结构    struct ipc_id_ary* entries;// 指向资源 ipc_id_ary 数据结构的指针&#125;;\n\n在内核中，struct ipc_id_ary* entries是一个指向所有 ipc_perm 的指针数组。其能够通过该数组找到我们对于 id（下标）的资源，对其进行访问\nstruct ipc_id_ary&#123;        int size;        struct kern_ipc_perm *p[0];// 指针数组&#125;;\n\n\n那你可能想问了，这里只是第一个元素啊？那如果我想访问 shmid_ds 结构的其他成员，岂不是没有办法访问了？\n要是这么想，就还是太年轻了😂\n(strcut shmid_ds*)\n\n我们只需要对这个指针进行强转，就能直接访问其他成员！\n这是因为：C 语言中，结构体第一个元素的地址，和结构体整体的地址是一样的！\n指针的类型会限制这个指针访问元素的能力，只要我们进行强转，其就能直接访问父结构体的其他成员！\n\n这是一种  切片  的思想\n\n用这种办法，可以用统一的规则在内核中管理不同的 IPC 资源，没有必要再为每一个 IPC 资源建立一个单独的数组来管理。\n\n不得不说，linus大佬是真的牛逼！\n\n4.3 多进程共享锁 mutex共享内存因为缺少访问控制，常常需要借助其他具有访问控制的进程通信手段来间接实现访问控制。\n但实际上有一个更加符合我们使用习惯的写法，那就是使用 pthread_mutex 锁的 PTHREAD_PROCESS_SHARED 多进程共享属性，让这把锁可以在  多个进程  中被使用。在每个进程中，我们都可以像使用自己的锁一样使用它，以此实现了一把能同时管多个进程的一把互斥锁！\n#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main()&#123;    // 共享内存的名字必须以 / 开头    int shared_mem_fd = shm_open(&quot;/my_shared_memory&quot;, O_CREAT | O_RDWR, 0666);    // 创建了一个 mutex 大小的共享内存(这个函数的作用是将 fd 文件给截断 / 扩展为第二个参数的大小)    ftruncate(shared_mem_fd, sizeof(pthread_mutex_t));    // 用 mmap 挂载到本地    // addr：指定映射的虚拟地址，通常设置为 NULL，让系统自动分配。    // length：指定映射的长度，以字节为单位。    // prot：指定映射区域的保护权限，可选值为 PROT_READ（可读权限）、PROT_WRITE（可写权限）、PROT_EXEC（可执行权限）以及它们的组合。    // flags：指定映射的类型和其他标志位，常见的标志位有 MAP_SHARED（共享映射）、MAP_PRIVATE（私有映射）、MAP_ANONYMOUS（匿名映射）等。    // fd：如果要映射文件，则为文件描述符；如果映射的是匿名内存区域，则传入 -1。    // offset：从文件开始处的偏移量，通常设置为 0。    //    // 返回值：成功时，返回映射区域的起始地址指针；    //        失败时，返回 MAP_FAILED，并设置 errno 来指示错误类型。    void *shared_mem_ptr = mmap(NULL, sizeof(pthread_mutex_t), PROT_READ | PROT_WRITE, MAP_SHARED, shared_mem_fd, 0);    pthread_mutexattr_t attr;    pthread_mutexattr_init(&amp;attr);    pthread_mutexattr_setpshared(&amp;attr, PTHREAD_PROCESS_SHARED); // 设置锁的属性为共享锁    // 如果删除上面这一行，那么当下这个锁就是父进程的私有锁，不具有公有属性    // 即便我们使用共享内存将锁映射到了父子进程的页表中    // 观察到的现象是，即便父进程已经释放锁了，但是子进程依旧是在阻塞状态中    // 个人猜测：因为这个锁是父进程独有的，所以子进程在调用 lock 函数访问 mutex 的时候，实际上是将 mutex 进行了一次写时拷贝；    //          拷贝的时候，这个锁是被占用的，拷贝过去之后也是一个被占用中的锁。    //          但实际上压根没有进程在占用这个被子进程拷贝出去的独立的锁，父进程的解锁操作也不会在进程间同步，这就是一种死锁。    pthread_mutex_t *mutex = (pthread_mutex_t *)shared_mem_ptr;    pthread_mutex_init(mutex, &amp;attr); // 指定使用共享内存的地址来初始化锁    pid_t pid = fork();    if (pid &lt; 0)    &#123;        fprintf(stderr, &quot;Fork failed.\\n&quot;);        return 1;    &#125;    else if (pid == 0)    &#123;        // Child process        sleep(1); // 子进程先休眠 1 秒，等待夫进程获取锁        printf(&quot;Child trying to acquire the mutex... %p\\n&quot;, mutex);        pthread_mutex_lock(mutex); // 子进程获取锁，这时候父进程在休眠，无法获取        printf(&quot;Child acquired the mutex.\\n&quot;);        // Do some work...        sleep(2);        pthread_mutex_unlock(mutex);        printf(&quot;Child released the mutex.\\n&quot;);    &#125;    else    &#123;        // Parent process        printf(&quot;Parent trying to acquire the mutex... %p\\n&quot;, mutex);        pthread_mutex_lock(mutex);        printf(&quot;Parent acquired the mutex.\\n&quot;);        // Do some work...        sleep(2);        pthread_mutex_unlock(mutex); // 父进程释放锁后，观察到的情况是子进程成功获取锁        printf(&quot;Parent released the mutex.\\n&quot;);        wait(NULL); // 等待子进程执行完毕        pthread_mutexattr_destroy(&amp;attr); // 父进程来销毁相关资源        pthread_mutex_destroy(mutex);        munmap(shared_mem_ptr, sizeof(pthread_mutex_t));        shm_unlink(&quot;/my_shared_memory&quot;);    &#125;    return 0;&#125;\n\n\n结语  关于共享内存的操作到这里就 OVER 了！\n最后还了解了一些内核设计上的小妙招，不得不说，真的牛批~\n如果本文有什么问题，欢迎在评论区提出\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】线程概念 | 同步","url":"/posts/2186356144/","content":"除了线程互斥，我们还有线程同步，来康康吧\n\n\n[TOC]\n1. 为什么需要同步  在部分条件下，互斥是正确的，但是不合理。比如食堂打饭的时候，食堂阿姨一次只能给一个人打饭，于是就选择通过竞争来获得打饭的权利。此时就会出现有些线程因为优先级过低或者 CPU 调度问题，一直打不到饭，于是就出现了  饥饿问题。\n这是因为我们对多线程访问同一个资源没有进行限制，全靠 CPU 调度来决定运行顺序；所以我们需要对线程进行一定的控制，这就是  线程同步  的概念\n\n饥饿问题：某一个线程一直无法申请到某种资源（比如因为优先级过低）\n同步：保证数据安全（临界资源访问）的前提下，让线程根据一定条件和顺序访问临界资源，从而避免饥饿问题\n竞态条件：因为时序问题（CPU 调度）而导致程序异常；\n\n2. 生产消费模型  这个模型其实很简单，消费者去超市购买东西，生产者把商品投放到超市中。\n\n这时候就不需要消费者直接去找工厂问他 xx 东西又没有生产，他需要购买；而是转去超市里面购买 xx 东西；\n如果 xx 东西没有货了，超市就会通知生产者进行补货。如果超市里面的货架已经满了，就通知生产者不需要继续生产了；\n当商品没货了，超市会告知消费者这个东西没货，消费者会停止消费行为；而生产者补货了之后，超市就会通知消费者让他来购买\n\n\n在基础模式中，消费者要想知道一个东西有没有货，需要去超市里面看（相当于轮循检测）\n我们可以引入一个  通知方式 ，比如超市开放一个微信公众号，告知消费者 xx 物品是否有货，以及告知消费者什么时候需要补货，此时就不需要消费者和生产者 不断询问  超市关于一个商品的情况了！这就相当于  线程同步！\n2.1 生产者和消费者的关系  下面提到的是普适情况\n\n消费者有多个，他们之间是竞争关系（互斥）竞争商品的购买\n生产者有多个，他们之间是竞争关系（互斥）竞争超市的货架\n消费者和生产者之间，既有互斥关系，也是同步关系（需要生产者供货了之后，消费者才能消费）这两个关系并不冲突！\n\n除了上面提到的3 种生产关系，还有下面俩点\n在实际程序中，消费者和生产者都是由线程承担的（2 种角色）\n超市是内存中特定的一个数据结构，也是临界资源（1 个交易场所）\n\n我们可以用 321 原则 来快速记住这几条，这样就记住了生产消费模型！👍\n\n2.2 以简单代码为例  在旧模式中，main 函数调用另外一个函数，想获得返回值，需要等这个函数运行完毕；好比消费者购买东西，需要去找厂家并等待厂家生产……\n\n而在生产消费者模型中，main 作为主线程，只需要把待处理的数据丢进缓冲区；而线程 B 从缓冲区中取出数据，处理完毕后放回缓冲区。main 可以先执行其他代码，过一会再过来拿线程 B 处理好的结果。\n这就实现了  生产和消费的解耦！\n\n2.3 并发  生产消费模型的并发，更多的体现在消费者在处理任务的同时，生产者可以生产任务；\n线程切换的成本低于进程，由此便提高了数据处理的效率\n\n接下来我们就要解决下面这些问题😁\n1. 如何让多个消费者线程等待呢? 又如何让消费者线程被唤醒呢?2. 如何让多个生产者线程等待呢? 又如何让生产者线程被唤醒呢?3. 如何衡量消费者和生产者所关心的条件是否就绪呢?\n\n而前面提到的通知方式，在 linux 系统中，就是  条件变量  了！\n3. 条件变量接口 3.1 init&#x2F;destroy 基本的接口和 pthread 库的其他接口很相似，都是一样的用法；其中 attr 也是设置条件变量的属性，这里置为 nullptr 即可\n#include &lt;pthread.h&gt;int pthread_cond_destroy(pthread_cond_t *cond);int pthread_cond_init(pthread_cond_t *restrict cond,                      const pthread_condattr_t *restrict attr);pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\n3.2 pthread_cond_wait这两个接口都是让线程在一个条件变量下进行等待，其中 timewait 接口可以设置等待的时间（超时了就不等了）\n条件变量也是临界资源，所以这里需要一个 mutex 锁来保证  条件变量  读写的原子性\n#include &lt;pthread.h&gt;int pthread_cond_timedwait(pthread_cond_t *restrict cond,                           pthread_mutex_t *restrict mutex,                           const struct timespec *restrict abstime);int pthread_cond_wait(pthread_cond_t *restrict cond,                      pthread_mutex_t *restrict mutex);\n\n3.3 pthrea_cond_signal&#x2F;broadcast这个接口的作用是给在条件变量下等待的线程发信号\n#include &lt;pthread.h&gt;int pthread_cond_broadcast(pthread_cond_t *cond);int pthread_cond_signal(pthread_cond_t *cond);\n\n其中 broadcast 是给在当前条件变量等待的  所有线程  发信号，而 signal 是发送信号，只唤醒一个线程；\n如果调用成功，这两个函数都会返回 0；否则返回错误码\nRETURN VALUE       If  successful, the pthread_cond_broadcast() and pthread_cond_signal() functions shall return zero; otherwise, an error number shall       be returned to indicate the error.\n\n3.4 代码示例  下面这个代码可以很好的演示上面提到的多个接口\n#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;signal.h&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/syscall.h&gt;using namespace std;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;// 锁pthread_cond_t cond;// 条件变量volatile bool quit = false;void*func(void* arg)&#123;    while(!quit)// 这里有 bug，后续会提到    &#123;        pthread_cond_wait(&amp;cond,&amp;mutex);        cout &lt;&lt; &quot;thread is running... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;thread quit... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;&#125;int main()&#123;    pthread_cond_init(&amp;cond,nullptr);    pthread_t t1,t2,t3;    pthread_create(&amp;t1,nullptr,func,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func,(void*)&quot;t2&quot;);    pthread_create(&amp;t3,nullptr,func,(void*)&quot;t3&quot;);    char c;    while(1)    &#123;        cout &lt;&lt; &quot;[a/b]$ &quot;;        cin &gt;&gt; c;        if(c==&#x27;a&#x27;)        &#123;            pthread_cond_signal(&amp;cond);        &#125;        else if(c==&#x27;b&#x27;)        &#123;            pthread_cond_broadcast(&amp;cond);        &#125;        else        &#123;            quit = true;            break;        &#125;        usleep(500);    &#125;    cout &lt;&lt; &quot;main break: &quot; &lt;&lt; quit &lt;&lt; endl;    sleep(1);    pthread_cond_broadcast(&amp;cond);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);    pthread_join(t3,nullptr);    return 0;&#125;\n\n每次输入 a，就 signal 会唤醒一个线程；每次输入 b，会调用broadcast，唤醒当前所有线程\n[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test[a/b]$ athread is running... t1[a/b]$ athread is running... t2[a/b]$ athread is running... t3[a/b]$ bthread is running... t1thread is running... t2thread is running... t3\n\n3.4.1 小 bug上面的代码示例，会出现下面的问题，即我们输入除了 a 和 b 以外的所有字符，都应该会把全局变量 quit 改成 true，让三个线程都退出\n但观察到的现象却是只有一个线程退出了，其他线程阻塞等待了\n[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test[a/b]$ qmain break: 1thread is running... t3thread quit... t3\n\n这是因为 pthread_cond_wait 里面进行了  独特的操作，即等待之前，它会释放锁，等待之后，他会重新申请锁\nint pthread_cond_wait(pthread_cond_t *restrict cond,                      pthread_mutex_t *restrict mutex)&#123;\tpthread_mutex_unlock(mutex);// 先解锁    // 避免因为该线程拿着锁去休眠了，导致其他线程无法申请该锁    \t// 条件变量相关代码\t    pthread_mutex_lock(mutex);// 条件满足后，再加锁&#125;\n\n第一个退出的线程，退出之前申请了锁却没有释放，于是就导致其他线程在  条件满足后，没有办法申请锁，只能阻塞等待！\n3.4.2 修正  修正的方法很简单，我们只需要在 while(!quit) 循环的退出条件满足之后，释放一下锁，就 OK 了！\nvoid*func(void* arg)&#123;    while(!quit)    &#123;        pthread_cond_wait(&amp;cond,&amp;mutex);        cout &lt;&lt; &quot;thread is running... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;            &#125;    pthread_mutex_unlock(&amp;mutex);// 正确操作：需要在条件满足后，解锁    cout &lt;&lt; &quot;thread quit... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;&#125;\n\n此时就能看到，所有线程都正常退出了！\n[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test[a/b]$ qmain break: 1thread is running... t1thread quit... t1thread is running... t2thread quit... t2thread is running... t3thread quit... t3[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$\n\n3.4.3 典型错误  在我们的正常思路中，申请条件变量之前应该解锁，申请完毕后再加锁；根据这点，就能引出一个比较典型的死锁错误。\n因为，实际上pthread_cond_wait(&amp;cond); 这个函数是会主动帮我们处理加锁和解锁的操作的。所以我们并不需要自己来处理。否则会出现死锁！正常使用的时候，我们应该把锁传入这个函数，让它来帮我们处理。\npthread_mutex_lock(&amp;mutex);while (condition_is_false) &#123;    pthread_mutex_unlock(&amp;mutex);    pthread_cond_wait(&amp;cond);// 解锁和加锁的操作，该函数会帮我们完成    pthread_mutex_lock(&amp;mutex);// 二次申请同一把锁，出现死锁！&#125;pthread_mutex_unlock(&amp;mutex);\n\n两次申请同一把锁，就好比自己把自己绊倒了😂我们要避免写出这样的错误代码！\n\n4. 阻塞队列 - 生产消费模型实例  这个队列的作用，就是提供一个超市，供生产者和消费者进行数据的交换\n\n生产者，往队列里面 push 数据\n消费者，从队列里面 pop 数据\n\n看起来有些类似于管道，同样的，生产者和消费者在读取阻塞队列的时候，不仅需要保证自己的操作是原子操作，还需要做到一定的  访问控制；即消费者在队列空的时候不能继续 pop，生产者在队列满的时候不能继续 push\n此时，我们还可以引入一个  微信公众号，也就是一定的通知方式：不要让生产者、消费者疯狂检测阻塞队列，而是引入条件变量，在队列不为空的时候，通知消费者；在队列不为满的时候，通知生产者；这样就达到了线程之间的同步。\n4.1 成员变量  要实现阻塞队列，我们首先需要理清楚需要什么成员变量，来保护该队列\n\n用于访问控制的锁，同一时刻只能有一个线程访问队列\n用户线程同步的条件变量，因为我们需要在不同的条件下通知不同的人，所以需要 2 个条件变量\n一个队列，为了方便，采用std::queue，这样就不用自己造轮子了\n\n理清楚了之后，就可以来写成员变量啦；我采用了模板类型，这样阻塞队列就可以用来存放任何我们想要的类型了\ntemplate&lt;class T&gt;class BlockQueue&#123;private:    queue&lt;T&gt; _bq;// 队列    size_t _size;// 大小    pthread_mutex_t _mutex;// 锁    pthread_cond_t _proInf;// 通知生产者    pthread_cond_t _conInf;// 通知消费者public:    BlockQueue(int sz=5)        :_size(sz)    &#123;        pthread_mutex_init(&amp;_mutex,nullptr);        pthread_cond_init(&amp;_proInf,nullptr);        pthread_cond_init(&amp;_conInf,nullptr);    &#125;    ~BlockQueue()    &#123;        pthread_mutex_destroy(&amp;_mutex);        pthread_cond_destroy(&amp;_proInf);        pthread_cond_destroy(&amp;_conInf);    &#125;&#125;;\n\n你可能想问，queue 不是有封装 size 吗？哪这里我们还定义一个大小变量，会不会有些多余？\nnope！实际上，这里的这个 _size 就好比我们在 C 语言写顺序表的时候，成员capacity；其作用是来判断我们的队列 有没有满  的。\n\n4.2 push 和 pop对于一个队列，最重要的操作就是在队头出数据，队尾入数据\n简单说来，就是需要在处理队列数据的时候进行加锁，保证原子性；\n除此以外，生产者和消费者有不同的操作逻辑：\n\n生产\n判断是否符合生产条件（队列没有满）\n满，不生产；不满，生产；\n满了的时候，生产者应在条件变量中等待（等待消费者消费）\n不满的时候，生产者生产，并通知消费者来消费\n\n\n消费\n判断是否满足消费条件（队列不为空）\n空，不消费；不空，消费；\n空了的时候，消费者应该在条件变量中等待（等待生产者生产）\n不空的时候，消费者消费，并通知生产者继续生产\n\n\n\n这样就实现了阻塞队列 push 和 pop 的基本逻辑；由此可以写出下面的代码\n// 消费者消费T pop()&#123;    // 加锁    pthread_mutex_lock(&amp;_mutex);    // 判断条件    if(_size)// 空，不消费    &#123;        pthread_cond_wait(&amp;_conInf,&amp;_mutex);    &#125;    // 消费并通知生产者    T tmp = _bq.front();    _bq.pop();    pthread_cond_signal(&amp;_proInf);    // 解锁    pthread_mutex_unlock(&amp;_mutex);    return tmp;&#125;// 生产者生产void Push(const T&amp; in)&#123;    // 加锁    pthread_mutex_lock(&amp;_mutex);    // 判断条件    if(bq.size()&gt;=_size)// 满，不生产    &#123;        pthread_cond_wait(&amp;_proInf,&amp;_mutex);    &#125;    // 生产并通知消费者    _bq.push(in);    pthread_cond_signal(&amp;_conInf);    // 解锁    pthread_mutex_unlock(&amp;_mutex);&#125;\n\n4.2.1 运行测试  有了这个基本框架，我们就可以来测试一下代码啦！\n先来一个生产者和消费者康康吧\n#include &quot;blockqueue.hpp&quot;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;void *consume(void *args)&#123;    BlockQueue&lt;int&gt; *bqp = (BlockQueue&lt;int&gt; *)args;    while(1)    &#123;        // 消费        int ret = bqp-&gt;pop();        cout &lt;&lt; &quot;consume &quot; &lt;&lt; pthread_self() &lt;&lt; &quot; 消费：&quot; &lt;&lt; ret &lt;&lt; endl;        sleep(1);    &#125;&#125;void *produce(void *args)&#123;    BlockQueue&lt;int&gt; *bqp = (BlockQueue&lt;int&gt; *)args;    while (1)    &#123;        // 制作        cout &lt;&lt; &quot;########↓&quot; &lt;&lt; endl;        int a = rand()%100;        // 投放到超市        bqp-&gt;push(a);        cout &lt;&lt; &quot;produce &quot; &lt;&lt; pthread_self() &lt;&lt; &quot; 生产：&quot; &lt;&lt; a &lt;&lt; endl;        sleep(2);    &#125;&#125;int main()&#123;    srand((unsigned int)time(nullptr));    pthread_t t1,t2;    BlockQueue&lt;int&gt; bq(5);    pthread_create(&amp;t1,nullptr,produce,(void*)&amp;bq);    pthread_create(&amp;t2,nullptr,consume,(void*)&amp;bq);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);    return 0;&#125;\n\n可以看到，刚开始消费者并没有运行，而是等待生产者生产出数据了之后，再开始消费！我们的目的成功达成！\n[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./test########↓produce 139716365768448 生产：41########↓produce 139716365768448 生产：11consume 139716357375744 消费：41########↓produce 139716365768448 生产：19consume 139716357375744 消费：11########↓produce 139716365768448 生产：19consume 139716357375744 消费：19########↓produce 139716365768448 生产：25consume 139716357375744 消费：19########↓produce 139716365768448 生产：63consume 139716357375744 消费：25\n\n如果增加线程到 2 生产 2 消费，则会看到下面的情况\n[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./test########↓produce 140483816179456 生产：51consume 140483807786752 消费：51########↓produce 140483799394048 生产：38consume 140483791001344 消费：38########↓produce 140483816179456 生产：37consume 140483807786752 消费：37\n\n每次被唤醒的生产者和消费者都是不一样的，交替唤醒\n4.2.2 进一步封装  为了代码的可读性，我们可以对阻塞队列进一步封装\n#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;using namespace std;template&lt;class T&gt;class BlockQueue&#123;private:    queue&lt;T&gt; _bq;// 队列    size_t _size;// 大小    pthread_mutex_t _mutex;// 锁    pthread_cond_t _proInf;// 通知生产者    pthread_cond_t _conInf;// 通知消费者public:    BlockQueue(int sz=5)        :_size(sz)    &#123;        pthread_mutex_init(&amp;_mutex,nullptr);        pthread_cond_init(&amp;_proInf,nullptr);        pthread_cond_init(&amp;_conInf,nullptr);    &#125;    ~BlockQueue()    &#123;        pthread_mutex_destroy(&amp;_mutex);        pthread_cond_destroy(&amp;_proInf);        pthread_cond_destroy(&amp;_conInf);    &#125;    // 消费者消费    T pop()    &#123;        // 加锁        lock();        // 判断条件        if(isEmpty())// 空，不消费        &#123;            ConWait();        &#125;        // 消费并通知生产者        T tmp = _bq.front();        _bq.pop();        WakeUpPro();        // 解锁        unlock();        return tmp;    &#125;    // 生产者生产    void push(const T&amp; in)    &#123;        // 加锁        lock();        // 判断条件        if(isFull())// 满，不生产        &#123;            ProWait();        &#125;        // 生产并通知消费者        _bq.push(in);        WakeUpCon();        // 解锁        unlock();    &#125;private:    void lock()    &#123;        pthread_mutex_lock(&amp;_mutex);    &#125;    void unlock()    &#123;        pthread_mutex_unlock(&amp;_mutex);    &#125;    // 唤醒消费者    void WakeUpCon()    &#123;        pthread_cond_signal(&amp;_conInf);    &#125;    // 唤醒生产者    void WakeUpPro()    &#123;        pthread_cond_signal(&amp;_proInf);    &#125;    // 消费者等待    void ConWait()    &#123;        pthread_cond_wait(&amp;_conInf,&amp;_mutex);    &#125;    // 生产者等待    void ProWait()    &#123;        pthread_cond_wait(&amp;_proInf,&amp;_mutex);    &#125;    // 判断条件    bool isFull()    &#123;        return _size == _bq.size();    &#125;    bool isEmpty()    &#123;        return _bq.empty();    &#125;&#125;;\n\n4.2.3 使用 task 分配运算任务  因为阻塞队列是用模板类型的，我们可以自己实现一个  仿函数，来给生产者消费者分配任务\n#pragma once#include &lt;iostream&gt;using namespace std;class Task&#123;public:    Task(int one=0, int two=0, char op=&quot;+&quot;)         : _elem1(one), _elem2(two), _operator(op)    &#123;&#125;    // 仿函数    int operator() ()    &#123;        return run();    &#125;    // 运行仿函数    int run()    &#123;        int result = 0;        switch (_operator)        &#123;        case &#x27;+&#x27;:            result = _elem1 + _elem2;            break;        case &#x27;-&#x27;:            result = _elem1 - _elem2;            break;        case &#x27;*&#x27;:            result = _elem1 * _elem2;            break;        case &#x27;/&#x27;:        &#123;            if (_elem2 == 0)            &#123;                cout &lt;&lt; &quot;div zero, abort&quot; &lt;&lt; endl;                result = -1;            &#125;            else            &#123;                result = _elem1 / _elem2;            &#125;            break;        &#125;         case &#x27;%&#x27;:        &#123;            if (_elem2 == 0)            &#123;                cout &lt;&lt; &quot;mod zero, abort&quot; &lt;&lt; endl;                result = -1;            &#125;            else            &#123;                result = _elem1 % _elem2;            &#125;            break;        &#125;        default:            cout &lt;&lt; &quot;unknown: &quot; &lt;&lt; _operator &lt;&lt; endl;            break;        &#125;        return result;    &#125;    // 获取元素，方便打印    void get(int *e1, int *e2, char *op)    &#123;        *e1 = _elem1;        *e2 = _elem2;        *op = _operator;    &#125;private:    int _elem1;    int _elem2;    char _operator;&#125;;\n\n测试一下\n#include &quot;blockqueue.hpp&quot;#include &quot;task.hpp&quot;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;string&gt;string ops =&quot;+-*/%&quot;;void *consumer(void *args)&#123;    BlockQueue&lt;Task&gt; *bqp = (BlockQueue&lt;Task&gt; *)args;    while (1)    &#123;        Task t = bqp-&gt;pop();        int result = t();    // 处理任务        int one, two;        char op;        t.get(&amp;one, &amp;two, &amp;op);        cout &lt;&lt; &quot;consumer [&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 消费了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = &quot; &lt;&lt; result &lt;&lt; endl;    &#125;&#125;void *producer(void *args)&#123;    BlockQueue&lt;Task&gt; *bqp = (BlockQueue&lt;Task&gt; *)args;    while (1)    &#123;        // 制作任务        int one = rand() % 50;        int two = rand() % 20;        char op = ops[rand() % ops.size()];        Task t(one, two, op);        // 投放给消费者生产        bqp-&gt;push(t);        cout &lt;&lt; &quot;producter[&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 生产了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = ?&quot; &lt;&lt; endl;        sleep(1);    &#125;&#125;void test2()&#123;    pthread_t t1,t2;    BlockQueue&lt;Task&gt; bq(5);    pthread_create(&amp;t1,nullptr,producer,(void*)&amp;bq);    sleep(1);    pthread_create(&amp;t2,nullptr,consumer,(void*)&amp;bq);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;int main()&#123;    srand((unsigned long)time(nullptr));// 乘一个数字添加随机性    test2();    return 0;&#125;\n\n运行，可以看到生产者生产了问题之后，消费者会去解答。此时我们只需要在线程中取回运算好的结果，就 OK 了！\n[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./testproducter[140703422265088] 1673319321 生产了一个任务: 43-16 = ?consumer [140703413872384] 1673319322 消费了一个任务: 43-16 = 27producter[140703422265088] 1673319322 生产了一个任务: 45/12 = ?consumer [140703413872384] 1673319322 消费了一个任务: 45/12 = 3producter[140703422265088] 1673319323 生产了一个任务: 17/7 = ?consumer [140703413872384] 1673319323 消费了一个任务: 17/7 = 2producter[140703422265088] 1673319324 生产了一个任务: 49-14 = ?consumer [140703413872384] 1673319324 消费了一个任务: 49-14 = 35producter[140703422265088] 1673319325 生产了一个任务: 4%4 = ?consumer [140703413872384] 1673319325 消费了一个任务: 4%4 = 0\n\n\n5. 阻塞队列 - 循环队列 5.0 为啥用循环队列 上面的队列是封装了 queue，下面我们要利用环形队列的方式来实现一个功能相同的环形队列。\n所谓循环队列，就是在一个一维数组中，通过头尾两个指针，来标识队列的头尾。如果数据数量超出空间末尾，则在空间的开头放入，并移动尾指针\n\n这部分可以看我的博客 循环队列\n\n用上循环队列，就有一个显著的优势：因为我们访问的（假设是数组）是不同下标位置，其并非同一块内存空间 ，所以是可以同时访问的！这样就进一步显现了生产消费的 并发属性\n这就相当于把循环队列这个  临界资源分成了一小块一小块；只有满 &#x2F; 空的时候，头尾指针会指向同一块空间，其余时间都是不冲突的！\n注意 ：这需要 程序猿来保证，获取了信号量之后，访问的肯定是临界资源中的不同区域，否则如果访问到了同一块区域，还是会出问题的！\n5.1 POSIX 信号量  这里又要重新认识一下信号量了，在  先前的博客  中，简单提到了信号量的概念，其本质上是一个  计数器。\n\np 操作：申请资源\nv 操作：归还资源\n\n对信号量的操作是原子的，不会因为线程切换而发生错误和冲突。\n循环队列需要有两个标识符，来标识当前数据的头尾。注意，信号量可  不能做下标  使用，这里我们可以用 int 类型，加锁来解决原子性问题；\n\n信号量在环形队列中的作用，还是用于标识 空间剩余 / 数据数量\n因为这是一个阻塞队列：\n\n生产者放入数据，对应的是空间信号量，只有有空间的时候，才能往环形队列里面放入\n消费者取出数据，对应的是数据信号量，没有数据也就不能取了\n\n此时，先前介绍的 semop 函数在此环节不太适合，在此介绍两个来自 pthread 库的新接口；这些接口在编译的时候都需要带上-lpthread\n5.1.1 sem_init&#x2F;destroy#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value);int sem_destroy(sem_t *sem);\n\n因为都是 pthread 库的，其使用方法还是很相似的，我们需要对信号量进行初始化，并给定一个 value 作为信号量的初始值；\n对 init 函数的 pshared 参数做一定讲解，在 man 手册中的介绍是这样的\n\n如果我们的信号量需要在线程中共享，那就将该参数设置为 0；\n如果信号量需要在进程中共享，其就应该处在共享内存区域，可以对添加了共享内存的进程之间共享；\n阻塞队列是给线程使用的，所以我们设置成 0 就可以了。\n5.1.2 sem_wait这个接口和锁 &#x2F; 条件变量的 wait 是一样的，其作用是申请一个信号量，如果信号量为 0，则在此处等待，直到信号量非 0\nNAME       sem_wait, sem_timedwait, sem_trywait - lock a semaphoreSYNOPSIS       #include &lt;semaphore.h&gt;       int sem_wait(sem_t *sem);       int sem_trywait(sem_t *sem);       int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);       Link with -pthread.\n\n可以简单理解为，这个接口的作用就是让  信号量 -1\ntrywait则是非阻塞检测；timewait是设置等待的时间，超时就不等了。这点和条件变量的接口是一样的\n5.1.3  sem_post这个接口的作用就是释放一个信号量，相当于给这个信号量+1\nNAME       sem_post - unlock a semaphoreSYNOPSIS       #include &lt;semaphore.h&gt;       int sem_post(sem_t *sem);\n\n5.1.4 在循环队列里面使用  知道了这几个接口，对于我们环形队列的使用就比较明了了\n\n当生产者开始生产的时候，申请一个空间信号量（剩余空间 -1）生产完毕后，释放一个数量信号量（剩余数量 +1）\n当消费者开始消费的时候，申请一个数量信号量（剩余数量 -1）生产完毕后，释放一个空间信号量（剩余空间 +1）\n\n除了这两个信号量，生产消费的时候，还需要操作头尾指针，指向队列正确的位置\n5.2 成员变量  前面铺垫了那么多，现在就可以来试试水了！\nvector&lt;T&gt; _rq;// 队列sem_t _spaceSem;// 空间信号量sem_t _valueSem;// 数据信号量pthread_mutex_t _proMutex;// 生产者的锁pthread_mutex_t _conMutex;// 消费者的锁size_t _rear;// 尾指针size_t _front;// 头指针\n\n因为信号量就可以充当条件变量的角色，所以这里就不需要条件变量来通知生产者 &#x2F; 消费者了\n5.3 构造 &#x2F; 析构  接下来要做的，就是写构造 &#x2F; 析构了\nRingQueue(int capa = 5)    :_rq(capa),    _rear(0),    _front(0)&#123;    sem_init(&amp;_spaceSem,0,capa);// 空间    sem_init(&amp;_valueSem,0,0);// 数量为 0    pthread_mutex_init(&amp;_proMutex,nullptr);    pthread_mutex_init(&amp;_conMutex,nullptr);&#125;~RingQueue()&#123;    sem_destroy(&amp;_spaceSem);    sem_destroy(&amp;_valueSem);    pthread_mutex_destroy(&amp;_proMutex);    pthread_mutex_destroy(&amp;_conMutex);&#125;\n\n5.4 生产消费  首先我们需要知道，当队列满 &#x2F; 空的时候，分别对应啥情况\n\n满：生产太多了，生产者得休息\n空：消费太多了，消费者得缓缓\n\n因为有信号量帮我们  做了访问控制 ，所以我们 不需要判断  循环队列什么时候为满，什么时候为空：\n\n满的时候：数量 &#x3D; 队列容量，空间信号量 &#x3D;0，无法申请空间，无法生产\n此时生产者会在  空间信号量  里面等待，不会继续生产；消费者继续消费\n空的时候：空间 &#x3D; 队列容量，数量信号量 &#x3D;0，没有可以消费的\n此时消费者会在  数量信号量  里面等待，不会继续消费；生产者继续生产\n\n这也是信号量作为访问控制的一大特征，当你申请成功了，就代表你肯定有临界资源的访问权限了；再加上我们给访问临界区加了锁，自然也不会出现被其他线程抢了的情况🎉\n// 生产者void Push(T&amp; in)&#123;    sem_wait(&amp;_spaceSem);// 获取空间    pthread_mutex_lock(&amp;_proMutex);    _rq[_rear] = in; // 生产    _rear++;         // 写入位置后移    _rear %= _rq.size(); // 更新下标，避免越界    pthread_mutex_unlock(&amp;_proMutex);    sem_post(&amp;_valueSem);// 释放数量&#125;// 消费T pop()&#123;    sem_wait(&amp;_valueSem);    pthread_mutex_lock(&amp;_conMutex);    T tmp = _rq[_front];    _front++;    _front %= _rq.size();// 更新下标，保证环形特征    pthread_mutex_unlock(&amp;_conMutex);    sem_post(&amp;_spaceSem);    return tmp;&#125;\n\n5.5 测试string ops =&quot;+-*/%&quot;;void *consumer(void *args)&#123;    RingQueue&lt;Task&gt; *bqp = (RingQueue&lt;Task&gt; *)args;    while (1)    &#123;        Task t = bqp-&gt;pop();        int result = t();    // 处理任务        int one, two;        char op;        t.get(&amp;one, &amp;two, &amp;op);        cout &lt;&lt; &quot;consumer [&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 消费了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = &quot; &lt;&lt; result &lt;&lt; endl;    &#125;&#125;void *producer(void *args)&#123;    RingQueue&lt;Task&gt; *bqp = (RingQueue&lt;Task&gt; *)args;    while (1)    &#123;        // 制作任务        int one = rand() % 50;        int two = rand() % 20;        char op = ops[rand() % ops.size()];        Task t(one, two, op);        // 投放给消费者生产        bqp-&gt;push(t);        cout &lt;&lt; &quot;producter[&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 生产了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = ?&quot; &lt;&lt; endl;        sleep(1);    &#125;&#125;void test2()&#123;    pthread_t t1,t2;    RingQueue&lt;Task&gt; bq(5);    pthread_create(&amp;t1,nullptr,producer,(void*)&amp;bq);    sleep(1);    pthread_create(&amp;t2,nullptr,consumer,(void*)&amp;bq);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;int main()&#123;    srand((unsigned long)time(nullptr));// 乘一个数字添加随机性    test2();    return 0;&#125;\n\n刚开始运行的时候，发现了这个错误\n\n这是因为在 task 中，我们重写了构造函数，编译器就不会生成默认构造了\nTask(int one, int two, char op)     : _elem1(one), _elem2(two), _operator(op)&#123;&#125;\n\n而创建环形队列的时候，会自动调用构造函数。此时发现没有匹配的构造函数（无参），就会报错！\n解决办法是，添加上一个无参构造，直接使用 default 关键字即可\nTask() = default;// 使用系统默认生成的无参构造\n\n运行，可以看到生产消费稳定跑起来了！\n[muxue@bt-7274:~/git/linux/code/23-01-17 ringqueue]$ ./testproducter[139758380586752] 1673936332 生产了一个任务: 24-8 = ?producter[139758380586752] 1673936333 生产了一个任务: 34/19 = ?consumer [139758372194048] 1673936333 消费了一个任务: 24-8 = 16consumer [139758372194048] 1673936333 消费了一个任务: 34/19 = 1producter[139758380586752] 1673936334 生产了一个任务: 18*16 = ?consumer [139758372194048] 1673936334 消费了一个任务: 18*16 = 288producter[139758380586752] 1673936335 生产了一个任务: 48+15 = ?consumer [139758372194048] 1673936335 消费了一个任务: 48+15 = 63\n\n增多线程，也能正常运行！\n[muxue@bt-7274:~/git/linux/code/23-01-17 ringqueue]$ ./testproducter[140344921630464] 1673936659 生产了一个任务: 44-15 = ?consumer [140344913237760] 1673936660 消费了一个任务: 44-15 = 29producter[140344921630464] 1673936660 生产了一个任务: 33+14 = ?consumer [140344913237760] 1673936660 消费了一个任务: 33+14 = 47producter[140344904845056] 1673936661 生产了一个任务: 14/12 = ?consumer [140344896452352] 1673936661 消费了一个任务: 14/12 = 1producter[140344921630464] 1673936661 生产了一个任务: 24-16 = ?consumer [140344913237760] 1673936661 消费了一个任务: 24-16 = 8producter[140344904845056] 1673936662 生产了一个任务: 3-3 = ?consumer [140344896452352] 1673936662 消费了一个任务: 3-3 = 0producter[140344921630464] 1673936662 生产了一个任务: 36*7 = ?consumer [140344913237760] 1673936662 消费了一个任务: 36*7 = 252producter[140344904845056] 1673936663 生产了一个任务: 28+8 = ?consumer [140344896452352] 1673936663 消费了一个任务: 28+8 = 36producter[140344921630464] 1673936663 生产了一个任务: 26-5 = ?consumer [140344913237760] 1673936663 消费了一个任务: 26-5 = 21\n\n结语  关于线程同步的知识点，大概就是这些了。博客写的满满当当，在理解了接口的基本命名和使用逻辑后，感觉就没有那么难了\n加油哦！\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】线程实例 | 简单线程池","url":"/posts/1969264863/","content":"今天来写一个简单版本的线程池\n\n\n1. 啥是线程池  池塘，顾名思义，线程池就是一个有很多线程的容器。\n我们只需要把任务交到这个线程的池子里面，其就能帮我们多线程执行任务，计算出结果。\n与阻塞队列不同的是，线程池中内有一个队列用于任务管理，并帮我们  封装了线程创建的工作 。我们不再需要在主执行流里面创建线程（创建线程也是有时间消耗的），而是 只关注于任务的创建，交给线程池来运行并产生结果就 OK 了\n前面已经学习过阻塞队列了，此时再来写线程池，就没有那么困难了！\n本次线程池的设计还会采用  单例模式，同一个模板类型的任务，只需要一个线程池即可\n1.1 简单复习单例模式  单例模式分为两种设计方式，一个是懒汉，一个是饿汉\n\n懒汉：刚开始先不创建单例，等第一次使用的时候在创建；缺点是第一次获取单例需要等待，优点是程序启动快\n饿汉：main 函数执行前，就将单例创建起来；缺点是程序启动会比较慢，优点是启动之后获取单例会快\n\n2. 代码示例 - 处理 task2.1 成员变量  因为是线程池，需要在内部创建出线程来运行，所以我们需要一个 num 来标识需要创建的线程的数量\ntemplate &lt;class T&gt;class ThreadPool&#123;private:\tbool _isStart;  // 线程池子是否启动    int _threadNum; // 线程数量    queue&lt;T&gt; _tq;   // 任务队列    pthread_mutex_t _mutex;// 锁    pthread_cond_t _cond;  // 条件变量    static ThreadPool&lt;T&gt; *instance; // 单例模式需要用到的指针&#125;\n\n这里我们并不需要弄一个数组来存放已经创建的线程，因为我们并不关心线程的退出信息，也不需要对线程进行管理。在创建好线程之后，直接 detach 即可\nstatic 变量我们需要在类外初始化，因为是模板类型，所以还需要带上 template 关键字\n// 初始化 static 变量template &lt;class T&gt;ThreadPool&lt;T&gt; *ThreadPool&lt;T&gt;::instance = nullptr;\n\n2.2 构造 &#x2F; 析构（单例）本次使用的是  懒汉模式  的单例，提供一个指针作为单例，不开放构造函数（构造函数私有化）\n同时，利用 delete 关键字，禁止拷贝构造和赋值重载；析构依旧保持公有\nprivate:    ThreadPool(int num = DEFALUT_NUM)        : _threadNum(num),          _isStart(false)    &#123;        assert(num &gt; 0);        pthread_mutex_init(&amp;_mutex, nullptr);        pthread_cond_init(&amp;_cond, nullptr);    &#125;    ThreadPool(const ThreadPool&lt;T&gt; &amp;) = delete;// 取消拷贝    void operator=(const ThreadPool&lt;T&gt; &amp;) = delete;// 取消赋值\n\n析构函数并不需要进行过多处理，将锁和条件变量销毁即可\n~ThreadPool()&#123;    pthread_mutex_destroy(&amp;_mutex);    pthread_cond_destroy(&amp;_cond);&#125;\n\n这种情况下，我们还需要有一个 static 成员函数 来获取单例；在之前的  单例模式博客  中，提到当初实现的懒汉模式是线程不安全的，因为没有对线程进行加锁，避免多个执行流同时获取单例，导致单例对象冲突的问题。\n现在学习了 linux 的加锁操作，就可以避免掉这个 bug 了\n两次 nullptr 判断  其中关于两次 nullptr 判断的原因，详见注释\n\n第一个判断是为了保证单例，只要单例存在了，就不再创建单例\n第二个判断是保证线程安全，可能会出现线程 a 在创建单例，线程 b 在锁中等待的情况；此时如果不进行第二次 nullptr 判断，线程 b 从锁中被唤醒后，又会继续执行，多创建了  一个单例！\n\npublic:    static ThreadPool&lt;T&gt; *getInstance()    &#123;        static pthread_mutex_t mt;// 使用 static，锁只会创建一次；避免多次实例化，一个执行流一个锁就失去效果了        pthread_mutex_init(&amp;mt,nullptr);        if (instance == nullptr) // 第一次判断        &#123;            pthread_mutex_lock(&amp;mt);// 加锁，保证只有一个执行流走到这里            if (instance == nullptr)// 第二次判断是来确认的，避免出现在加锁前，被其他执行流获取过实例了            &#123;                instance = new ThreadPool&lt;T&gt;();// 确认是 null，创建单例            &#125;        &#125;        pthread_mutex_unlock(&amp;mt);        pthread_mutex_destroy(&amp;mt);        return instance;    &#125;\n\n2.3 启动线程池  有了线程池，接下来要做的就是启动它😁\n启动之前，我们需要 assert 判断一下该线程池是否已经启动了，避免多次启动线程池出现问题。启动完成之后，更新 isStart 的状态值\nvoid start()&#123;    assert(!_isStart);// 如果开启了，那么就不能执行该函数    for (int i = 0; i &lt; _threadNum; i++)    &#123;        pthread_t temp;        pthread_create(&amp;temp, nullptr, threadRoutine, this);// 把 this 当参数传入        usleep(100);        pthread_detach(temp);// 分离线程    &#125;    _isStart = true;// 标识状态，代表线程池已经启动了&#125;\n\n这里还有另外一个函数 threadRoutine，这是每一个线程需要执行的函数，其为 static 函数。这里我们获取到的都是单例的this 指针，访问成员都需要通过 this 指针来访问\nstatic void *threadRoutine(void *args)&#123;    ThreadPool&lt;T&gt; *tp = static_cast&lt;ThreadPool&lt;T&gt; *&gt;(args);//c++ 强转    while (1)    &#123;        tp-&gt;lockQueue();        while (!tp-&gt;haveTask())        &#123;            tp-&gt;waitForTask();        &#125;        // 任务被拿到了线程的上下文中        T t = tp-&gt;pop();        tp-&gt;unlockQueue();        // 规定每一个封装的 task 对象都需要有一个 run 函数        t.resultPrint(t.run());// 运行并打印结果    &#125;&#125;\n\n2.4 封装的加锁 &#x2F; 解锁 &#x2F; 通知操作  这部分操作比较简单，就不多提了。其实就是把已有的函数改个名字，变成无参可直接调用的函数罢了。\nprivate:    void lockQueue() &#123; pthread_mutex_lock(&amp;_mutex); &#125;    void unlockQueue() &#123; pthread_mutex_unlock(&amp;_mutex); &#125;    bool haveTask() &#123; return !_tq.empty(); &#125;    void waitForTask() &#123; pthread_cond_wait(&amp;_cond, &amp;_mutex); &#125;    void singalThread() &#123; pthread_cond_signal(&amp;_cond); &#125;    T pop()    &#123;        T temp = _tq.front();        _tq.pop();        return temp;    &#125;\n\n其中 pop() 函数设置为了私有，因为线程池会自己开始处理任务，所以不需要外部pop\n\n2.5 插入任务  最后就只剩下任务的插入了，插入一个任务后，使用条件变量，唤醒线程池中的一个线程来执行这个任务！\n// 往线程池中给任务void push(const T &amp;in)&#123;    lockQueue();    _tq.push(in);// 插入任务    singalThread();// 任务插入后，唤醒一个线程来执行    unlockQueue();&#125;\n\n到这里，线程池就大功告成了！\n3. 测试  本次测试依旧使用了在线程博客中提到过的 task.hpp，完整代码详见 我的 gitee 仓库\n因为使用了线程池，主执行流只需要来派发任务即可；\n#include &quot;threadpool.hpp&quot;#include &quot;task.hpp&quot;#include &lt;string&gt;#include &lt;time.h&gt;int main()&#123;    const string operators = &quot;+/*/%&quot;;    ThreadPool&lt;Task&gt;*tp = ThreadPool&lt;Task&gt;::getInstance();    tp-&gt;start();    srand((unsigned long)time(nullptr) ^ getpid() ^ pthread_self());    // 派发任务的线程    while(1)    &#123;        int one = rand()%50;        int two = rand()%10;        char oper = operators[rand()%operators.size()];        cout &lt;&lt; &quot;[&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] 主线程派发计算任务: &quot; &lt;&lt; one &lt;&lt; oper &lt;&lt; two &lt;&lt; &quot;=?&quot; &lt;&lt; &quot;\\n&quot;;        Task t(one, two, oper);        tp-&gt;push(t);        sleep(1);    &#125;    &#125;\n\n此时线程池就会帮我们运行，并将结果输出！\n[muxue@bt-7274:~/git/linux/code/23-01-18 threadpool]$ ./test[140202992179008] 主线程派发计算任务: 14/8=?[140202973767424] 新线程完成计算任务: 14/8=1[140202992179008] 主线程派发计算任务: 43*2=?[140202965374720] 新线程完成计算任务: 43*2=86[140202992179008] 主线程派发计算任务: 10/9=?[140202956982016] 新线程完成计算任务: 10/9=1[140202992179008] 主线程派发计算任务: 25*9=?[140202948589312] 新线程完成计算任务: 25*9=225[140202992179008] 主线程派发计算任务: 8/0=?div zero, abort[140202940196608] 新线程完成计算任务: 8/0=-1[140202992179008] 主线程派发计算任务: 38%1=?[140202973767424] 新线程完成计算任务: 38%1=0[140202992179008] 主线程派发计算任务: 23/7=?[140202965374720] 新线程完成计算任务: 23/7=3[140202992179008] 主线程派发计算任务: 4%4=?[140202956982016] 新线程完成计算任务: 4%4=0[140202992179008] 主线程派发计算任务: 44*8=?[140202948589312] 新线程完成计算任务: 44*8=352[140202992179008] 主线程派发计算任务: 4/2=?\n\n3.1 修改轻量级进程的名字Linux 提供了一个有趣的接口，可以允许我们修改轻量级进程的名字；\n没有修改的时候，默认的名字都是该进程的可执行程序的名字\n[muxue@bt-7274:~/git/linux/code/23-01-18 threadpool]$ ps -aL  PID   LWP TTY          TIME CMD 6592  6592 pts/7    00:00:00 test 6592  6593 pts/7    00:00:00 test 6592  6594 pts/7    00:00:00 test 6592  6595 pts/7    00:00:00 test 6592  6596 pts/7    00:00:00 test 6592  6597 pts/7    00:00:00 test 6730  6730 pts/8    00:00:00 ps\n\n我们使用 prctl 接口，修改名字；这个接口的作用是对一个进程进行操作。\n#include &lt;sys/prctl.h&gt;int prctl(int option, unsigned long arg2, unsigned long arg3,\t\tunsigned long arg4, unsigned long arg5);\n\n其中修改线程名字的操作如下\nprctl(PR_SET_NAME, &quot;handler&quot;);// 修改线程名字为 handler\n\n分别修改主执行流和线程池中线程的名字，即可获得不一样的结果\n[muxue@bt-7274:~/git/linux/code/23-01-18 threadpool]$ ps -aL  PID   LWP TTY          TIME CMD 7793  7793 pts/7    00:00:00 master 7793  7794 pts/7    00:00:00 handler 7793  7795 pts/7    00:00:00 handler 7793  7796 pts/7    00:00:00 handler 7793  7797 pts/7    00:00:00 handler 7793  7798 pts/7    00:00:00 handler 7828  7828 pts/8    00:00:00 ps\n\n这样可以用于标识线程的属性，还是有些用的！\nThe end本篇博客到这里就 over 啦，有啥问题欢迎评论区提出哦！\n\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】tar 命令打包 | 查看压缩文件 | 打包时忽略文件","url":"/posts/4159326627/","content":"tar 命令打包 | 查看压缩文件 | 打包时忽略文件 等操作\n\n\n1. 起因  今天下午写阿狸 bot 的代码的时候，写错了 aiofiles 的保存操作\n# 正确写法async def write_file_aio(path:str, value):    async with aiofiles.open(path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:        await f.write(json.dumps(value, indent=2, sort_keys=True,ensure_ascii=False))        # 错误写法# 前面是一样的await f.write(json.dump(value, indent=2, sort_keys=True,ensure_ascii=False))\n\n注意这两个函数，一个是json.dump；一个是json.dumps\n就是因为这里写错了，导致 bot 执行全局变量保存的时候，所有文件都没有成功保存——还直接把本地文件清空了！！！\n\n当时的我是真的欲哭无泪啊，都不知道如何是好\n\nvscode 的  时间线  功能帮我保存了一部分文件，可是绝大部分文件都是程序生成的，没有经过 vscode，其自然也就没有保存历史版本，这可给我整难受了\n\n\n要不是之前有一个 val-bot-test 目录用于代码测试，那就几乎等同于阿狸 bot 的用户信息全部丢失，最最最最难受的，还是我 bot 记录了好久的服务器日志啊，本来有 3w 多 cmd 的，现在恢复的文件还是几个月前的，数据量少了好多……\n\n唉，不说这些玩意了，今天我们要来康康怎么在 linux 下用 tar 命令打包和压缩文件夹，留作备份！\n2.tar 命令打包  参考 https://blog.csdn.net/catoop/article/details/40651947\n2.1 将整个目录打包  以当前目录下的 code 文件夹为例\ntar -cvf ./code.tar ./code # 仅打包不压缩tar -zcvf ./code.tar.gz ./code # 打包，gzip 压缩tar -jcvf ./code.tar.bz2 ./code # 打包，bzip2 压缩\n\n注意，这里的 ./code.tar 是生成的目标文件，./code是源路径；目标文件的命名没有要求，命名成 tar.gz/tar.bz2 只是一个用于标明的好习惯\n2.2 查看压缩包里面的文件  下面的命令是分别查看不同压缩格式的压缩包里面的文件目录的，其会直接在 bash 打印出来\ntar -tvf ./code.tar tar -ztvf ./code.tar.gz tar -jtvf ./code.tar.bz2 \n\n2.3 解压文件  解压的文件会默认存在当前目录\ntar -xvf ./code.tar tar -zxvf ./code.tar.gz tar -jxvf ./code.tar.bz2 \n\n2.4 解压一部分文件  假设我们需要解压 code.tar 里面 test 目录的文件，可以用下面的命令\ntar -xvf ./code.tar test\n\n知道这几个用法，就基本够用了！\n2.5 打包的时候忽略一些文件  现在我需要压缩的是 code 里面的 python 运行代码，其中会有一个没有用的__pycache_，我们应该将其忽略，以减小压缩包体积\n下面的命令就是忽略 code 路径下所有 __pycache__ 文件或者文件目录\ntar -zcvf code.tar.gz --exclude=*__pycache__ code\n\n注意，忽略的路径后面不需要带/，否则还是会被打包。比如下面的用法就是错的\ntar -zcvf code.tar.gz --exclude=*__pycache__/ code # 错误\n\n3. 一定要多多备份  像我今天出现这样的情况，实在是不应该！\n阿狸 bot 是有 vip 业务的，vip 信息文件的丢失，也很有可能会导致 vip 用户的丢失。更别提还有广大的普通用户在使用阿狸呢。\n平时我知道要在云盘、nas 备份自己的代码、笔记、学习资料等等个人文件，却忘记了云服务器上的 bot 同样需要备份\n\n这下可算是吸取教训了，一次性把所有 bot 都给备份了！\n","categories":["玩上Linux"],"tags":["Linux","阿狸开发日志","Python"]},{"title":"【Linux】线程概念 | 互斥","url":"/posts/1309150756/","content":"千呼万唤始出来，终于到多线程方面的学习了！\n\n\n\n所用系统Centos7.6  本文的源码👉【传送门】\n\n[TOC]\n1. 线程的概念  在之前的 linux 学习中，已经接触过了进程的概念，进程由一个 task_struct 结构体在操作系统中进行描述，CPU 在执行的时候，会依照进程时间片进行轮询调度，让每一个进程的代码都得以推进，实现多个进程的同时运行\n而线程，可以理解为是一种轻量化的进程，每一个进程都可以创建多个线程，并行执行不同的代码\n进程: 线程 = 1:N\n\n在之前的多进程操作中，我们使用 fork 接口创建子进程，通过 if/else 语句判断，实现对特定执行流的划分\n\n创建子进程时，需要拷贝一份 task_struct/mm_struct 并创建页表\n当子进程修改了一部分变量，会发生  写时拷贝，修改页表在物理内存上的映射\n\n可以看到，当我们需要创建一个  新进程  的时候，操作系统需要做不少的工作\n\n1.1 执行流  让我们康康执行流这一概念：\n\n单执行流进程：内部只有一个执行流的进程\n多执行流进程：内部有多个执行流的进程\n\n进程 = 内核数据结构 + 代码和数据 ，在内核视角中，进程是 承担分配系统资源的基本实体（进程的基座属性）\n\n进程：向系统申请资源的基本单位（系统分配）\n线程：系统调度的基本单位\n\n\n1.2 线程创建时做了什么？那线程的创建需要做什么呢？\n\n不同操作系统的实现不同，一般用 tcb 指代描述线程的结构体\n\n在 linux 中，没有进程和线程在概念上的区分，其以  执行流  为基础，线程只是简单的对 task_strcut 进行了二次封装；线程是在进程内部运行的执行流\n\n说人话：linux 下的线程是  用进程模拟  的\n换句话：linux 下的进程也是一种线程，但是其  只有一个执行流\n对于 CPU 而言，其看到的 task_struct 都是一个执行流\n\n而创建线程时也有说法，线程隶属于某一个进程下，并不是独立的子进程，所以不需要创建新的 mm_struct 和页表映射，创建的效率高于子进程。只需要将 task_struct 指向原有进程的 mm_struct 和页表即可。\n\n同样的，CPU 在推行多线程操作的时候，无须执行 pcb 切换，就能实现  单进程多个线程操作  的同时进行，执行效率变高！\n\n线程是一种 Light weight process 轻量级进程，简称LWP；是现代 linux 对线程提供的原生支持\n\n1.3 内核源码中的体现  在task_strcut结构体中，有这么一个字段\n/* CPU-specific state of this task */\tstruct thread_struct thread;\n\n转到定义，其内部都是一些  寄存器  信息，用于标识这个线程的基本信息。这也是 linux 中没有  单独  实现线程 tcb 的体现，而是用 task_struct 来模拟的（task_struct中包含线程的信息）\nstruct thread_struct &#123;\t/* Cached TLS descriptors: */\tstruct desc_struct\ttls_array[GDT_ENTRY_TLS_ENTRIES];\tunsigned long\t\tsp0;\tunsigned long\t\tsp;#ifdef CONFIG_X86_32\tunsigned long\t\tsysenter_cs;#else\tunsigned long\t\tusersp;\t/* Copy from PDA */\tunsigned short\t\tes;\tunsigned short\t\tds;\tunsigned short\t\tfsindex;\tunsigned short\t\tgsindex;#endif#ifdef CONFIG_X86_32\tunsigned long\t\tip;#endif#ifdef CONFIG_X86_64\tunsigned long\t\tfs;#endif\tunsigned long\t\tgs;\t/* Hardware debugging registers: */\tunsigned long\t\tdebugreg0;\tunsigned long\t\tdebugreg1;\tunsigned long\t\tdebugreg2;\tunsigned long\t\tdebugreg3;\tunsigned long\t\tdebugreg6;\tunsigned long\t\tdebugreg7;\t/* Fault info: */\tunsigned long\t\tcr2;\tunsigned long\t\ttrap_no;\tunsigned long\t\terror_code;\t/* floating point and extended processor state */\tunion thread_xstate\t*xstate;#ifdef CONFIG_X86_32\t/* Virtual 86 mode info */\tstruct vm86_struct __user *vm86_info;\tunsigned long\t\tscreen_bitmap;\tunsigned long\t\tv86flags;\tunsigned long\t\tv86mask;\tunsigned long\t\tsaved_sp0;\tunsigned int\t\tsaved_fs;\tunsigned int\t\tsaved_gs;#endif\t/* IO permissions: */\tunsigned long\t\t*io_bitmap_ptr;\tunsigned long\t\tiopl;\t/* Max allowed port in the bitmap, in bytes: */\tunsigned\t\tio_bitmap_max;/* MSR_IA32_DEBUGCTLMSR value to switch in if TIF_DEBUGCTLMSR is set.  */\tunsigned long\tdebugctlmsr;\t/* Debug Store context; see asm/ds.h */\tstruct ds_context\t*ds_ctx;&#125;;\n\n当我们创建一个线程时，Linux 内核会为该线程分配一个唯一的线程标识符（TID），并在内部维护线程相关的数据结构。然而，每个线程在内核中仍然被视为独立的进程，并且共享同一个进程地址空间、文件描述符表以及其他进程资源。\n通过使用进程模拟线程的方式，Linux 实现了以下优势：\n\n轻量级：相比于传统意义上的进程，线程的创建和销毁更加高效，占用的系统资源更少。\n\n并发性：线程之间可以并发执行，通过共享相同的地址空间，线程可以直接访问进程的内存区域，简化了线程间的通信和同步操作。\n\n兼容性：由于早期版本的 Linux 内核并不直接支持线程，使用进程模拟线程的方式使得老旧的代码可以无缝迁移到新的内核版本中运行。\n\n\n现代的 Linux 内核已经提供了对线程的原生支持，称为轻量级进程（Lightweight Process，LWP）。通过使用 LWP，每个线程都可以在内核中独立地进行调度和管理，而无需依赖进程资源。这种方式更加高效，并且更符合线程概念的定义。然而，为了保持向后兼容性，Linux 仍然保留了使用进程模拟线程的机制。\n1.4 线程的私有物  我们知道，一个进程是完全独立的。但是线程并不是，因为线程只是进程的一个执行流分支，它从进程继承了绝大部分属性（也可以理解为是共享的）\n\n用户 id 和组 id\n进程 id\n进程工作目录\n文件描述符表\n信号的处理方式（如果进程有对某个信号进行自定义捕捉，那么线程会共用这个自定义捕捉）\n和进程共用一个堆\n\n但线程也会有自己的  私有物！\n\n线程 id\n线程独立的寄存器（因为线程也需要执行代码，有上下文数据）\n栈（线程运行函数时也需要压栈和出栈，必须独立否则执行流会出问题）\nerrno（单独的报错信息）\n信号屏蔽字（可以单独针对某个信号处理）\n线程调度优先级\n\n1.5.3 线程结构体  在 Linux 内核中的 struct thread_struct 结构体中包含了如下字段，这些字段有助于模拟线程。因为我们对 linux 内核代码的了解并不多，这里只做基本认识，可以和上方的 struct thread_struct 结构体源码对照着看\n\ntls_array: 这个字段表示线程的 TLS（Thread Local Storage）描述符数组。TLS 是一种机制，允许线程在其单独的存储区域中存储和访问变量。每个线程都可以有自己的 TLS 数组。\n\nsp0和sp: 这些字段表示线程的栈指针，用于管理线程的函数调用栈。\n\nsysenter_cs, usersp, es, ds, fsindex, gsindex: 这些字段用于保存与线程相关的段寄存器信息，例如代码段选择子、用户栈指针以及各种段寄存器的索引。\n\nip, fs, gs: 这些字段记录线程的指令指针和段寄存器的值。\n\ndebugreg0, debugreg1, debugreg2, debugreg3, debugreg6, debugreg7: 这些字段用于保存硬件调试寄存器的值，用于调试目的。\n\ncr2, trap_no, error_code: 这些字段记录了发生异常或中断时的相关信息。\n\nxstate: 这个字段用于保存浮点数和扩展处理器状态。\n\n\n1.5 线程优缺点1.5.1 缺点\n线程是缺乏保护的（不具备进程的  独立性 ）这也被称为 健壮性；线程的健壮性低\n\n当进程被停止的时候，其下线程也会被停止\n当有一个线程出 bug 了，会让整个进程退出\n多线程中的全局变量问题\n\n\n线程缺乏访问控制，在一个线程中调用某些操作系统的接口会影响整个进程\n\ndebug 多线程较麻烦\n\n如果同一个进程所用线程太多，可能会无法充分利用 cpu 性能而造成性能损失\n\n\n1.5.2 优点\n线程开辟的消耗低于进程，占用的资源低于进程\n切换线程无须切换页表等结构，速度快！\n等待慢 IO 设备时，进程可以继续执行其他操作；将部分 IO 操作重叠，能让进程同时等待多个 IO 操作；\n能充分利用处理器的  可并行数量；\n\n1.6 linux 下线程和进程的区别  在 Linux 系统中，进程和线程是两个并发执行的基本单位。它们之间有以下区别：\n\n资源占用：每个进程都有独立的地址空间、文件描述符、堆栈等资源，而线程共享进程的资源，包括地址空间、文件描述符等。因此，创建线程比创建进程更加轻量级。在线程直接切换也比进程切换效率更高。\n调度：进程是由操作系统进行调度和分配资源的基本单位，而线程是  进程的执行单元，由操作系统进行调度和分配 CPU 时间片。\n通信和同步：进程间通信需要使用操作系统提供的机制，如管道、消息队列、共享内存等。而线程之间可以通过共享内存的方式直接进行通信。此外，线程之间的同步更加方便，可以使用互斥锁、条件变量等机制。\n独立性：进程之间相互独立，一个进程的崩溃不会影响其他进程。而线程共享进程的资源，一个线程的崩溃会导致整个进程的崩溃。\n\n总结来说，进程是资源分配的基本单位，线程是执行的基本单位。进程之间相互独立，线程之间共享部分资源。\n在实际应用中，需要根据情况的不同，选择使用进程或线程来实现并发执行。\n\n2. 基础函数 linux 下提供了pthread 库来实现线程操作\n2.1 pthread_create人如其名，这个函数的作用是来创建新进程的\n#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr,\t\t\t\t\tvoid *(*start_routine) (void *), void *arg);//Compile and link with -pthread.\n\n\n第一个参数是一个  输出型参数，为该线程的 id\n第二个参数是用于指定线程的属性，暂时设置为 NULL 使用默认属性\n第三个参数是让该进程执行的函数，这是一个函数指针，参数和返回值都为void*\n第四个参数是  传给第三个执行函数的参数\n\n创建正常后返回 0，否则返回错误码\n注意，使用了 pthread 库后，需要在编译的时候指定链接，-lpthread\ntypedef unsigned long int pthread_t;// 线程 id\n\n创建线程后打印可以发现，线程 id 是一个非常大的值，并不像进程 PID 那么小\n//cout &lt;&lt; &quot;pthread_create &quot;&lt;&lt; t1 &lt;&lt; &quot; &quot; &lt;&lt; t2 &lt;&lt; endl;pthread_create 140689524995840 140689516603136\n\n可以通过 printf %x 的方式打印十六进制，来减少打印长度\n//printf(&quot;0x%x  0x%x\\n&quot;,t1,t2);0x393d0700  0x38bcf700\n\n2.2 pthread_join光是创建进程还不够，我们还需要对进程  进行等待\n#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);//Compile and link with -pthread.\n\n这里第一个参数是线程的 id，第二个参数是进程的退出状态\n等待成功后返回 0，否则返回错误码\n\njoin 可以在线程退出后，释放线程的资源\n同时获取线程对应的退出码\njoin 还能保证是新创建的线程退出后，主线程才退出\n\n2.2.1 基础的多线程操作  有了这两个，我们就能写一个简单的多线程操作了\n#include&lt;iostream&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;using namespace std;void* func1(void* arg)&#123;    while(1)    &#123;        cout &lt;&lt; &quot;func1 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;&#125;void* func2(void* arg)&#123;    while(1)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;&#125;int main()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    while(1)    &#123;        cout &lt;&lt; &quot;this is main::&quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);    &#125;    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);    return 0;&#125;\n\n执行会发现，多线程操作成功启动，且打印的进程 pid 都是一样的，代表其隶属于同一个进程\n\n我们可以用下面的语句来查看轻量级进程\nps -aL\n\n可以看到，执行了程序之后，出现了 3 个 PID 相同，LWP不同的轻量级进程，这就代表我们的多线程操作成功了；\n同时也能看到，在多线程操作时，谁先运行是不确定的。这是由系统调度随机决定的\n\n2.2.2 C++ 的多线程操作C++11 也支持了多线程操作，其封装了操作系统的 pthread 接口，基本的操作很相似\nvoid test2()&#123;    thread t1(func1,(char*)&quot;test1&quot;);    thread t2(func2,(char*)&quot;test2&quot;);       while(1)    &#123;        cout &lt;&lt; &quot;this is main:: &quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);    &#125;    t1.join();    t2.join();&#125;\n\n执行后的效果是一样的，C++ 的 thread 库还可以传入 functional 封装的可调用函数，和 lambda 表达式\n\n2.3 线程退出2.3.1 retvalint pthread_join(pthread_t thread, void **retval);\n\n我们可以使用该函数的第二个参数来获取线程所执行方法的返回值。retval是一个二级指针，是一个  输出型参数\n#include&lt;iostream&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;using namespace std;void* func1(void* arg)&#123;    int a = 5;    while(a--)    &#123;        cout &lt;&lt; &quot;func1 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func1 exit&quot; &lt;&lt; endl;    return (void*)100;&#125;void* func2(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func2 exit&quot; &lt;&lt; endl;    return (void*)10;&#125;void test3()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    int a = 15;    while(a--)    &#123;        cout &lt;&lt; &quot;this is main:: &quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);    &#125;    void* r1;    void* r2;    pthread_join(t1,&amp;r1);    pthread_join(t2,&amp;r2);    sleep(2);    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;&#125;int main()&#123;        test3();    return 0;&#125;\n\n可以看到，当两个线程退出之后，主函数中成功打印出了他们的返回值\n\n注意，因为我们是将 void* 的指针强转为 int，如果在打印的时候强转为 int，会出现 精度丢失  的报错，需要使用 long long 来规避报错\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ makeg++ test.cpp -o test -lpthread -std=c++11.test.cpp: In function ‘void test3()’:test.cpp:88:35: error: cast from ‘void*’ to ‘int’ loses precision [-fpermissive]     cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (int)r1 &lt;&lt; endl;                                   ^make: *** [test] Error 1\n\n2.3.2 pthread_exit除了直接 return，线程还可以调用 pthread_exit 函数实现退出\n#include &lt;pthread.h&gt;void pthread_exit(void *retval);//Compile and link with -pthread.\n\n效果完全一样\n//return (void*)10;pthread_exit((void*)10);\n\n注意，主线程 main 中调用该函数，并不会导致进程退出\nvoid* func2(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; &quot; tid: &quot; &lt;&lt; syscall(SYS_gettid) &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func2 exit&quot; &lt;&lt; endl;    pthread_exit((void*)10);&#125;void test5()&#123;    pthread_t t1,t2;\t//func2 会执行 10s    pthread_create(&amp;t1,nullptr,func2,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    sleep(1);    pthread_detach(t1);    pthread_detach(t2);    sleep(1);&#125;int main()&#123;        test5();    pthread_exit(0);// 主线程提前退出    cout &lt;&lt; &quot;main exit&quot; &lt;&lt; endl;    return 0;&#125;\n\n可以看到，主函数已经调用了 pthread_exit 退出了，但是线程还在跑\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc2 thread:: 1 :: 9474 tid: 9475func2 thread:: 2 :: 9474 tid: 9476func2 thread:: 1 :: 9474 tid: 9475func2 thread:: 2 :: 9474 tid: 9476main exitfunc2 thread:: 1 :: 9474 tid: 9475func2 thread:: 2 :: 9474 tid: 9476\n\n2.3.3 ptrhead_cancel除了上面俩种方式，我们还可以在 main 里面直接把某一个线程给关掉\n#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);//Compile and link with -pthread.\n\nvoid test3()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    int a = 15;    while(a--)    &#123;        cout &lt;&lt; &quot;this is main:: &quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);        if(a==11)        &#123;            pthread_cancel(t1);            pthread_cancel(t2);            break;        &#125;    &#125;    void* r1;    void* r2;    pthread_join(t1,&amp;r1);    pthread_join(t2,&amp;r2);    sleep(2);    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;&#125;\n\n被提前终止的进程，返回值都为 -1\n\n2.3.4 为什么进程退出不会向主进程发送信号？要理清楚这个问题，还是需要深知一个概念：线程是进程中的一个执行流，它并不是一个独立的进程。\n先来回顾一下进程退出的几种情况：\n\n代码跑完，结果正确\n代码跑完，结果有问题\n代码出错了，异常\n\n线程退出的情况也是这样，但线程如果因为某些异常退出，进程也会同步退出！\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testthis is main:: 13845Floating point exception[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ \n\n由此可见，线程异常 = 进程异常\n这里也就涉及到 1.5.1 中提到的线程  健壮性  问题，线程的异常会影响其他线程的运行，会导致进程整体异常退出。\n所以在 join 等待线程退出的时候，我们只需要考虑线程正常退出的情况；\n\n异常退出的时候恐怕也等不了😂因为进程也挂了\n\n2.3.5 exit任何一个线程执行 exit() 函数，都会导致整个进程退出\n\n2.4 pthread_detach等待是有性能损失的！默认创建的进程是 joinable，也就是可以被主线程进行pthread_join 等待的；\n这个函数的作用是让主线程不管创建出来的子线程，也不用去等待它，相当于取消了它的 joinable 属性；\n就好比父进程不想管子进程的时候，将 SIGCHLD 设置为SIG_IGN\n#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread);//Compile and link with -pthread.\n\n一个线程是否应该等待，取决于是否需要获取该线程的返回值；如果无须获取返回值，则使用分离能提高运行效率\n\n即便线程所运行的函数 return 是无效的，但我们可以用输出型参数来获取返回值\n\n2.4.1 实操  使用也很简单，只需要指定线程的 id 就行了\nvoid test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    while(1)    &#123;        cout &lt;&lt; &quot;this is main - global: &quot; &lt;&lt; global &lt;&lt; &quot; - &amp;global: &quot; &lt;&lt; &amp;global &lt;&lt; endl;        sleep(1);    &#125;    pthread_detach(t1);    pthread_detach(t2);&#125;\n\n运行上也不会有什么区别，但是我们已无法获取到该线程的返回值\n\n\n2.4.2 detach 后 join但如果我们在 detach 之后又进行 pthread_join 会发生什么呢？\nvoid* func3(void* arg)&#123;    pthread_detach(pthread_self());    int a = 7;    while(a--)    &#123;        printf(&quot;func thread:%s - global:%d - &amp;global:%p\\n&quot;,(char*)arg,global,&amp;global);        global++;        sleep(1);    &#125;    cout &lt;&lt; &quot;func exit&quot; &lt;&lt; endl;    return (void*)10;&#125;void test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    void* r1=nullptr;    void* r2=nullptr;    pthread_join(t1,&amp;r1);    pthread_join(t2,&amp;r2);    sleep(2);    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;&#125;\n\n诶，这不还是获取到了返回值吗？这么说，他这个 detach 岂不是没用？\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc thread:1 - global:103 - &amp;global:0x7fb5648b06fcfunc thread:2 - global:103 - &amp;global:0x7fb5640af6fcfunc thread:1 - global:104 - &amp;global:0x7fb5648b06fcfunc thread:2 - global:104 - &amp;global:0x7fb5640af6fcfunc exitfunc exitretval 1 : 10retval 2 : 10[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ \n\n实际上，当我们 create 一个线程的时候，它会先去执行线程创建的相关代码，此时 main 又直接去执行后面的代码了；此时 pthread_join 的调用是成功的，因为线程自己的 detach 代码  还没有被执行！\n\n而如果我们在 create 之后，等线程开始运行了在执行detach，此时 join 就会失败\nvoid test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    sleep(2);    pthread_detach(t1);    pthread_detach(t2);    sleep(1);    void* r1=nullptr;    void* r2=nullptr;    int ret = pthread_join(t1,&amp;r1);    cout &lt;&lt; ret &lt;&lt; &quot;:&quot; &lt;&lt; strerror(ret) &lt;&lt; endl;    ret = pthread_join(t2,&amp;r2);    cout &lt;&lt; ret &lt;&lt; &quot;:&quot; &lt;&lt; strerror(ret) &lt;&lt; endl;    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;    sleep(20);&#125;\n\n打印错误码也能看到，系统提示我们给 join 传入了一个无效的参数，线程依旧在正常运行\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc thread:1 - global:101 - &amp;global:0x7f2d439136fcfunc thread:2 - global:101 - &amp;global:0x7f2d431126fcfunc thread:2 - global:102 - &amp;global:0x7f2d431126fcfunc thread:1 - global:102 - &amp;global:0x7f2d439136fc22:Invalid argument22:Invalid argumentretval 1 : 0retval 2 : 0func thread:2 - global:103 - &amp;global:0x7f2d431126fcfunc thread:1 - global:103 - &amp;global:0x7f2d439136fc\n\n所以正确的做法，应该是在主线程中分离线程，不要在线程自己的代码中执行 detach，否则就会出现上面的分离失败的情况\n2.4.3 线程分离后，主线程先退出  如果执行完毕 pthread_detach 后，主线程提前退出了，会发生什么？\nvoid test5()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    sleep(1);    pthread_detach(t1);    pthread_detach(t2);    sleep(2);    cout &lt;&lt; &quot;main exit&quot; &lt;&lt; endl;&#125;\n\n显而易见，线程也跟着一并退出了\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc thread:1 - global:100 - &amp;global:0x7f01cd49a6fcfunc thread:2 - global:100 - &amp;global:0x7f01ccc996fcfunc thread:2 - global:101 - &amp;global:0x7f01ccc996fcfunc thread:1 - global:101 - &amp;global:0x7f01cd49a6fcfunc thread:2 - global:102 - &amp;global:0x7f01ccc996fcfunc thread:1 - global:102 - &amp;global:0x7f01cd49a6fcmain exit[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ \n\n因为线程  没有独立性，完全属于这个进程。不可能出现你家房子塌了，你自己的房间还在的情况😂\n\n进程退出的时候，操作系统就回收了这个进程的程序地址空间，连资源都被释放了，线程就没有办法继续运行，自然就退出了。\n\n所以，为了避免这种问题，一般我们分离线程的时候，都倾向于让主线程保持在后台运行（常驻内存的程序）\n2.5 gettid&#x2F;syscall该函数是一个系统接口，但它并不能直接运行\nNAME       gettid - get thread identificationSYNOPSIS       #include &lt;sys/types.h&gt;       pid_t gettid(void);       Note:  There  is  no  glibc wrapper for this system call; see       NOTES.\n\n我们需要用 syscall 函数 来调用该接口，这也是第一次接触到 syscall 函数\n#define _GNU_SOURCE         /* See feature_test_macros(7) */#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;   /* For SYS_xxx definitions */int syscall(int number, ...);\n\n在 syscall 的 man 手册中，我们就能看到获取线程 id 相关的示例\n//EXAMPLE#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;int main(int argc, char *argv[])&#123;    pid_t tid;    tid = syscall(SYS_gettid);    tid = syscall(SYS_tgkill, getpid(), tid);&#125;\n\n用下面的代码进行测试\nvoid* func2(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; &quot; tid: &quot; &lt;&lt; syscall(SYS_gettid) &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func2 exit&quot; &lt;&lt; endl;    pthread_exit((void*)10);&#125;void test1()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func2,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);       while(1)    &#123;        printf(&quot;tis is main - pid:%d - tid:%d\\n&quot;,getpid(),syscall(SYS_gettid));        sleep(1);    &#125;    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;\n\n运行可以看到进程打印出了相同的 PID 和不同的 TID，其 TID 对应的就是 ps -aL 中显示的 LWP 编号\n\n3. 相关概念 3.1 线程 id 是什么？ 前面提到过，pthread_t是线程独立的 id，本质上是一个无符号长整形，打印出来后，是一个很大的数字。这个数字有什么特别的含义吗？\n先来回顾一下线程的基本概念：\n\n线程是一个独立的执行流\n线程在运行过程中，会产生自己的临时数据\n线程调用函数的压栈出栈操作，有自己独立的栈结构\n\n因此，既然有一个独立的栈结构，其就需要有一个标识符来指向这个栈结构，方便程序运行的时候进行调用！\n所以，pthread_t本质上是一个地址！其指向的就是这个  线程的控制块，其内部包含了这个线程的独立栈结构。\n//printf(&quot;0x%x  0x%x\\n&quot;,t1,t2);0x393d0700  0x38bcf700 // 打印出来的结果也很像地址\n\n3.2 pthread 库 pthread 库并不是一个内核级的接口库，其实际上是封装了系统的clone/vfork 等接口，从而为我们提供的用户级的线程库。\n使用 pthread 库创建的进程，和内核中的 LWP 是 1:1 的\n\npthread 是一个  动态库，所以在编译的时候需要加上链接选项\ng++ test.cpp -o test -lpthread\n\n在我的 动静态库  的博客中有讲述过，动态库是在运行的时候动态链接的，其会将库中的代码映射到进程地址空间的 共享区，从而调用动态库中的代码\n\n举个例子，当我们调用 pthead_create 的时候，进程会跳到共享区中 ，执行动态库中的代码，创建成功后返回自己的 代码区，完成一个线程的创建\n\n而线程所用的独立栈，也是 pthread 库帮我们管理的。因为有共享区的存在，我们能通过 pthread_t 直接访问到动态库中管理的  线程的控制模块，从而完成线程的压栈、出栈等等操作\n\n下为 linux 的 pthreadtypes.h 中的部分内容\n# define __SIZEOF_PTHREAD_ATTR_T 36typedef unsigned long int pthread_t;union pthread_attr_t&#123;  char __size[__SIZEOF_PTHREAD_ATTR_T];  long int __align;&#125;;#ifndef __have_pthread_attr_ttypedef union pthread_attr_t pthread_attr_t;# define __have_pthread_attr_t\t1#endif\n\n3.3 线程的局部存储  假设我们有一个全局变量，我们想让创建出来的每一个线程，都能独立的使用这个全局变量，那就需要用到线程的  局部存储\nint global = 10;// 全局变量void* func3(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func thread &quot; &lt;&lt; (char*)arg &lt;&lt;  &quot; - global: &quot; &lt;&lt; global &lt;&lt; &quot; - &amp;global: &quot; &lt;&lt; &amp;global &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func exit&quot; &lt;&lt; endl;&#125;void test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    while(1)    &#123;        cout &lt;&lt; &quot;this is main - global: &quot; &lt;&lt; global &lt;&lt; &quot; - &amp;global: &quot; &lt;&lt; &amp;global &lt;&lt; endl;        sleep(1);    &#125;    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;\n\n执行，不管是主线程还是线程，都打印的是相同的值和地址\n\n如果在执行的函数 func3 中添加一个global++，则能观察到所有线程都是公用的一个变量，这里的 + 是同步的。\n\n如果我们想让 int global 变成局部变量，则需要在它之前加上一个__thread\n__thread int global = 100;// 可以让线程独立使用的全局变量\n\n此时可以看到，两个线程和主线程打印的 global 变量地址不同，他们的 ++ 操作是独立的，变量的值也是独立的\n\n这就实现了将某一个变量划分给线程进行  局部存储\n4. 线程互斥问题 4.1 临界资源 在先前  共享内存 信号量  的博客中，已经涉及到了这部分的内容；即关于操作  原子性  和访问  临界资源 &#x2F; 临界区  的相关问题。\n\n能被多个进程 &#x2F; 线程看到的资源，被称为  临界资源\n进程 &#x2F; 线程访问临界资源的代码，被称为  临界区\n\n在线程中，同样存在访问  临界资源  而导致的冲突：\n\n线程 A 对一个  全局变量 val进行了 -1 操作，当操作执行到放回内存那一步的时候，发生了线程切换，线程 B 开始工作\n线程 B 同样访问了该全局变量 val，对它进行了 -10 操作，此时因为线程 A 的 -1 操作尚未写回内存，全局变量 val 还是保持初值。线程 b 将 -10 之后的全局变量 val 写回了内存\n又发生了线程切换，跳转到线程 A 停止的  线程上下文数据  中开始执行，将全局变量写入内存\n这时候，线程 B 的 -10 操作就被 A 的写入覆盖了！\n\n举个实际点的例子，以 100 为全局变量的初始值\n\n线程 A 执行 -1，100-1=99，还未写入内存时，就线程切换\n线程 B 取到的全局变量还是 100，对其执行 -10，并写入内存， 此时全局变量为 90\n返回线程 A 继续执行写入内存操作，全局变量又被复写成了 99；相当于 B 的操作是无效的\n\n这种条件下会产生很多问题，也是我们不希望看到的！\n4.2 原子 &#x2F; 互斥性  这种时候，我们就需要保证访问该全局变量的操作是  原子  的，不能出现中间状态；\n也应该是  互斥  的，不能出现两个线程同时访问一份资源的情况\n\n互斥性：任何时候都只有一个执行流在访问某一份资源\n\n\n操作系统维护原子性，就必须保证该操作  只用一条汇编语句  执行（这样才不会出现进程 &#x2F; 线程切换导致的问题）这个在后面会详细介绍\n为了达成这一目的，我们需要给线程的操作  加锁\n4.3 线程加锁  线程加锁涉及到几个操作：\n\n提供一把锁\n在需要维持原子性（临界区）的位置加上锁\n访问临界区结束后，打开锁\n进程结束后，把锁丢了\n\n接下来就让我们一一解决这些问题\n4.3.1 pthread_mutex_initpthread 线程库在设计之初就考虑到了线程安全问题，所以它便给我们提供了加锁相关的操作。\n#include &lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex);int pthread_mutex_init(pthread_mutex_t *restrict mutex,                       const pthread_mutexattr_t *restrict attr);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\n首先我们需要定义一把锁，类型是pthread_mutex_t\n\n如果我们需要的是一把  全局变量  的锁，则可以直接使用赋值 PTHREAD_MUTEX_INITIALIZER 给这把锁初始化\n如果是一把局部的锁，则使用函数 pthread_mutex_init 进行初始化\n\n初始化的方法很简单，传入锁和对应的属性就行。此时我们忽略属性问题，设置为 NULL 使用  默认属性\n// 使用默认属性的全局锁 or 静态 static 锁// 无须调用函数初始化，可以直接用pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;// 使用函数进行初始化局部的锁（当然也可以初始化全局锁）pthread_mutex_t mutex;// 定义一把锁pthread_mutex_init(&amp;mutex, nullptr);// 初始化pthread_mutex_destroy(&amp;mutex);// 销毁\n\n4.3.2 加锁 &#x2F; 解锁  有了锁，那么就可以在需要的位置加上这把锁\n#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);\n\n其中 lock 是  阻塞式  加锁，如果你调用这个接口的时候，锁正在被别人使用，则会在这里等待；trylock 是  非阻塞  加锁，如果你调用该接口时锁正被使用，则直接 return 返回（相当于看看锁能否被获取）\nThe pthread_mutex_trylock() function shall be equivalent to pthread_mutex_lock(), except that if the mutex object referenced  by  mutex  is  currently locked (by any thread, including the current thread), the call shall return immediately. \n\n加了锁之后，在需要的位置 unlock 解锁；\n\n加锁和解锁操作  本身  是原子的，不会出现冲突\n加了锁之后，可以理解为加锁解锁操作  中间  的代码也是原子性的，必须要运行到解锁位置  才能让另外一个线程 &#x2F; 进程执行这里的代码\n加锁的本质是让线程执行临界区的代码串行化\n\n4.3.3 加锁的注意事项\n只对临界区加锁；锁保护的就是临界区\n加锁的粒度越细越好（即加锁的区域越小越好。如果访问的不是临界区，则可以不考虑加锁）\n加锁是编程的一种规范；在实际问题中，我们要保证  访问某一临界资源  的所有操作  都要加上锁。不能出现函数 A 加锁了，但是 B 没有加锁的情况（这样会导致 A 的加锁也没有意义）\n\n4.4 示例 - 倒水问题\n以  倒水  为示例，假设杯子容量为 10000，装满了水就会溢出。我们使用多个线程对这个杯子加水，直到满了之后线程退出\n#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;signal.h&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/syscall.h&gt;using namespace std;// 临界资源int water = 0;// 全局变量int cup = 10000;// 杯子的容量void* func(void* arg)&#123;    while(1)    &#123;        if(water&lt;cup)// 临界区        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            water++;        &#125;        else        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水已经满了 &quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            break;        &#125;    &#125;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 线程退出 &quot; &lt;&lt; &quot;\\n&quot;;    return (void*)0;&#125;int main()&#123;    pthread_t t1,t2,t3,t4;// 创建 4 个线程    pthread_create(&amp;t1,nullptr,func,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func,(void*)&quot;t2&quot;);    pthread_create(&amp;t3,nullptr,func,(void*)&quot;t3&quot;);    pthread_create(&amp;t4,nullptr,func,(void*)&quot;t4&quot;);    // 直接分离线程    pthread_detach(t1);    pthread_detach(t2);    pthread_detach(t3);    pthread_detach(t4);    while(1)    &#123;        ;// 啥都不干    &#125;    return 0;&#125;\n\n输出的结果如下，明明水已经满了，但还是会有部分线程报告水还没有满，且数字有很严重的偏差\nt3 水没有满：9993t3 水没有满：9994t3 水没有满：9995t3 水没有满：9996t3 水没有满：9997t3 水没有满：9998t3 水没有满：9999t3 水已经满了t3 线程退出 水没有满：2723t4 水已经满了t4 线程退出0t2 水已经满了t2 线程退出t1 水没有满：9668t1 水已经满了t1 线程退出\n\n多运行几次，也能发现相同的问题\nt2 水没有满：9997t2 水没有满：9998t2 水没有满：9999t2 水已经满了 10000t2 线程退出t4 水没有满：1889t4 水已经满了 10001t4 线程退出t3 水没有满：0t3 水已经满了 10002t3 线程退出t1 水没有满：0t1 水已经满了 10003t1 线程退出\n\n4.4.1 只有一个线程在工作？除了偏差外，还有一个小问题，往前翻打印记录，会发现一直都是  某一个线程在倒水，其他线程似乎啥事没有干？\nt3 水没有满：9786t3 水没有满：9787t3 水没有满：9788t3 水没有满：9789t3 水没有满：9790\n\n这是因为当运行 t3 的时候，t3 在 while 循环中继续运行的消耗，小于切换到其他线程的消耗。所以控制块就让 t3 一直运行，直到它 break 退出循环\n此时我们只需要加上一个 usleep，增加每一个 while 循环中需要  处理的负担，就能让所有线程都来倒水\n//usleep 功能把进程挂起一段时间， 单位是微秒（百万分之一秒）#include &lt;unistd.h&gt;int usleep(useconds_t usec);\n\n这是因为线程切换同样也是时间片到了，从内核返回用户态的时候做检测，切换至其他线程。\n添加 usleep 能创造更多  内核 &#x2F; 用户的中间态，从而增多切换线程的次数\nvoid* func(void* arg)&#123;    while(1)    &#123;        if(water&lt;cup)        &#123;            usleep(100);// 休息 100 微秒            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            water++;        &#125;        else        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水已经满了 &quot; &lt;&lt; &quot;\\n&quot;;            break;        &#125;    &#125;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 线程退出 &quot; &lt;&lt; &quot;\\n&quot;;    return (void*)0;&#125;\n\n但是这还是没有解决数字出错的问题\nt4 水没有满：9995t3 水没有满：9996t1 水没有满：9997t2 水没有满：9998t4 水没有满：9999t4 水已经满了 10000t4 线程退出t3 水没有满：10000t3 水已经满了 10001t3 线程退出t1 水没有满：10001t1 水已经满了 10002t1 线程退出t2 水没有满：10002t2 水已经满了 10003t2 线程退出\n\n4.4.2 加锁 - 问题解决  这时候就需要请出我们的锁了\n// 省略头文件int water = 0;// 全局变量int cup = 10000;// 杯子的容量pthread_mutex_t mutex;void* func(void* arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;mutex);        if(water&lt;cup)        &#123;            usleep(100);            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            water++;            pthread_mutex_unlock(&amp;mutex);            usleep(100);// 假装喝水        &#125;        else        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水已经满了 &quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            pthread_mutex_unlock(&amp;mutex);            // 此处也需要加锁，否则 break 出去之后其他线程会因为没有解锁而挂起            break;        &#125;    &#125;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 线程退出 &quot; &lt;&lt; &quot;\\n&quot;;    return (void*)0;&#125;// 如果遇到 2 号信号，就在销毁锁后退出进程void des(int signo)&#123;    // 销毁锁    pthread_mutex_destroy(&amp;mutex);    cout &lt;&lt; &quot;pthread_mutex_destroy, exit&quot; &lt;&lt; endl;    exit(0);&#125;int main()&#123;    signal(SIGINT,des);// 自定义捕捉 2 号信号    pthread_mutex_init(&amp;mutex,nullptr);// 初始化锁    pthread_t t1,t2,t3,t4;// 创建 4 个线程    pthread_create(&amp;t1,nullptr,func,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func,(void*)&quot;t2&quot;);    pthread_create(&amp;t3,nullptr,func,(void*)&quot;t3&quot;);    pthread_create(&amp;t4,nullptr,func,(void*)&quot;t4&quot;);    // 直接分离线程    pthread_detach(t1);    pthread_detach(t2);    pthread_detach(t3);    pthread_detach(t4);    while(1)    &#123;        ;// 啥都不干    &#125;    return 0;&#125;\n\n运行可见，数字错误问题就没有出现了；但又出现了只有一个线程工作的问题\nt1 水没有满：9996t1 水没有满：9997t1 水没有满：9998t1 水没有满：9999t1 水已经满了 10000t1 线程退出t3 水已经满了 10000t3 线程退出t4 水已经满了 10000t4 线程退出t2 水已经满了 10000t2 线程退出^Cpthread_mutex_destroy, exit\n\n这还是因为线程切换的效率问题；也有可能是因为其它线程申请锁的时候，发现 t1 在用，就进行了  阻塞等待  而挂起\n\n只需要在解锁之后添加一个 usleep 模拟其他工作，就能让所有线程都跑起来\npthread_mutex_lock(&amp;mutex);if(water&lt;cup)&#123;    usleep(100);    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;    water++;    pthread_mutex_unlock(&amp;mutex);    usleep(100);// 假装喝水&#125;\n\n没有出现数据错误，加锁的目的成功达到！\nt1 水没有满：9993t3 水没有满：9994t4 水没有满：9995t2 水没有满：9996t1 水没有满：9997t3 水没有满：9998t4 水没有满：9999t2 水已经满了 10000t2 线程退出t1 水已经满了 10000t1 线程退出t3 水已经满了 10000t3 线程退出t4 水已经满了 10000t4 线程退出^Cpthread_mutex_destroy, exit\n\n4.5 加锁的进一步解释  在这个代码示例中，我们给中间的几行代码加了锁；但这并不意味着执行中间这部分代码的时候，就不会发生线程切换\npthread_mutex_lock(&amp;mutex);// 加锁if(water&lt;cup)&#123;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;    water++;&#125;pthread_mutex_unlock(&amp;mutex);// 解锁\n\n事实上，代码执行的任何地方，都可能发生进程 &#x2F; 线程的切换。但因为我们加了锁，切换的时候，其他线程要来访问这里的资源，就必须先申请锁\n此时锁在  被切走的进线程手上，所以其他线程无法访问临界区的资源，也就不会发生数据不一致的问题。\n\n\n换言之，只要  张三  拿到了锁，那么它也就不担心自己的工作会被别人覆盖的问题；\n而对其他线程而言，张三访问临界区的工作，只有  还没进入  临界区和  访问完毕  临界区两种状态\n\n因此会导致一个问题，那就是线程切换的效率较低，其他线程出现了阻塞等待的情况；为了避免此问题，我们应该让访问临界区的操作快去快回，尽量不要在临界区里面干啥耗时的事情\n4.5.1 加锁原子性的保证\n备注：这部分仅供学习参考，若有错误，还请指出！\n\n那么加锁这个操作，是如何保证其自身的原子性呢？在加锁的途中不会发生线程切换吗？\n\n我找到了一张能大概说明汇编加锁过程的图片，其中 movb 的操作就是将 al 寄存器写为 0，xchgb的操作是将 al 寄存器的内容和内存中 mutex 锁的值进行交换\n\n开始的时候，锁被正常初始化，内存中 mutex 的值为 1（锁只会被初始化一次）\n线程 A 开始加锁，al 寄存器和 mutex 的值发生交换，此时内存中的 mutex 为 0，al 为 1\n判断 al 不为 0，代表获取锁成功，线程 A 加锁成功\n线程 B 也来申请锁了，movb将 al 寄存器写为 0，再和内存中的 mutex 交换后，发现还是 0，则代表锁在别人手上，此时就需要挂起等待\n\n前面一直强调，线程是有自己独立的栈结构和上下文数据的，在加锁的这部分汇编操作中，同样可能会在任何地方发生线程切换。切换的时候，线程的  上下文数据 （图中寄存器的状态）会被保留下来， 随这个线程一起被切换走\n所以线程 A 被切换的时候，属于它上下文中那个值为 1 的 al 寄存器也被切走了（注意，这里切走的是数据，al 寄存器本身作为硬件，有且只有一个）\n由此看来，真正获取锁的操作，其实只有 xchgb 一条交换指令来完成，保证加锁操作只由一条汇编语句实现，就能保证该操作的原子性！\n解锁的方法就很简单了，movb将 1 写回 mutex 变量即可，也是一条汇编完成；而且一般情况下，解锁是不会有执行流和你抢的。\n\n其实加锁远不止一种方法，锁的种类有非常多，还有  总线锁、旋转锁  等等，每一个锁的实现都不太一样！上面提到的为  互斥锁\n\n4.5.2 总线锁  现在的 CPU 一般都有自己的内部缓存，根据一些规则将内存中的数据读取到内部缓存中来，以加快频繁读取的速度。现在服务器通常是多 CPU，更普遍的是，每块 CPU 里有多个内核，而每个内核都维护了自己的缓存，那么这时候多线程并发就会存在缓存不一致性，这会导致严重问题。\n\n总线锁就是将 cpu 和内存之间的  通信  锁住，使得在锁定期间，其他 cpu 处理器不能操作其他内存中数据，故总线锁开销比较大！\n总线锁的实现是采用 cpu 提供的 LOCK# 信号，当一个 cpu 在总线上输出此信号时，其他 cpu 的请求将被阻塞，那么该 cpu 则  独占共享内存，相当于锁住了\n\n何为总线？\n\nCPU 总线是所有 CPU 与芯片组连接的主干道，负责 CPU 与外界所有部件的通信，包括高速缓存、内存、北桥，其控制总线向各个部件发送控制信号、通过地址总线发送地址信号指定其要访问的部件、通过数据总线双向传输\n\n5. 死锁  死锁就是一种因为两放都不会释放对方需要的资源，从而陷入的永久等待状态\n5.1 死锁情况演示  举个例子，张三拿了锁 A，申请锁 B 的时候，发现锁 B 无法申请，而进入等待；李四拿了锁 B，接下来他想申请锁 A，结果发现张三拿着锁 A，那就只能进入等待。这就陷入了一个僵局，张三想要李四的，李四想要张三的，谁都不让谁\n#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;signal.h&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/syscall.h&gt;using namespace std;pthread_mutex_t m1;// 锁 1pthread_mutex_t m2;// 锁 2void* func1(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m1);        pthread_mutex_lock(&amp;m2);        cout &lt;&lt; &quot;func1 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;void* func2(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m2);        pthread_mutex_lock(&amp;m1);        cout &lt;&lt; &quot;func2 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;int main()&#123;    pthread_mutex_init(&amp;m1,nullptr);    pthread_mutex_init(&amp;m2,nullptr);    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;t2&quot;);    // 分离    pthread_detach(t1);    pthread_detach(t2);    while(1)    &#123;        cout &lt;&lt; &quot;main running...&quot; &lt;&lt;endl;        sleep(1);    &#125;    pthread_mutex_destroy(&amp;m1);    pthread_mutex_destroy(&amp;m2);    return 0;&#125;\n\n上面的这个代码便能模拟出这个情况，线程 1 先要了锁 1，再要锁 2；线程 2 先要锁 2 再要锁 1，他们俩就容易打起来，造成死锁。\n运行代码的时候我们却发现，似乎并不是这样的，线程 1 好像还是成功拿到了俩把锁，并运行了起来\n[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./testmain running...func1 is running... t1func1 is running... t1main running...func1 is running... t1main running...func1 is running... t1main running...\n\n那是因为我们没有执行其他一些工作，从而将线程 1 和 2 申请锁的时间错开\n将代码改成下面这样，利用 usleep 让两个线程休眠不同时间，结果就不同了\nvoid* func1(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m1);        usleep(200);        pthread_mutex_lock(&amp;m2);        cout &lt;&lt; &quot;func1 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;void* func2(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m2);        usleep(300);        pthread_mutex_lock(&amp;m1);        cout &lt;&lt; &quot;func2 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;\n\n可以看到，此时只有主线程在运行，线程 t1 和 t2 出现了死锁！\n[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./testmain running...main running...main running...main running...\n\n\n5.2 死锁的条件\n互斥条件：某份资源同一时间只能由一个执行流访问\n请求与保持：一个执行流因请求某种资源进入阻塞等待，而不释放自己的资源（好比上面代码例子中两个线程都不释放自己的锁，又想要别人的锁）\n不剥夺条件：一个执行流已获得的资源，在未使用之前不能被剥夺（部分锁是允许被剥夺的）\n循环等待：若干执行流之间形成一种头尾相接的循环等待资源的状态\n\n一把锁也能造成死锁吗？答案是肯定的！\npthread_mutex_lock(&amp;m1);pthread_mutex_lock(&amp;m1);// 两次申请同一把锁\n\n如果有人写出这种 bug 代码，那就会出现一把锁把自己死锁了；死锁本来就是代码的 bug，所以这种低级错误也是死锁的情况之一😂\n5.3 避免死锁  避免死锁，其中最简单明了的办法，就是破坏上面提到的死锁的 4 个条件；其中互斥条件没啥好办法破坏（除非你不加锁），更主要的是看另外 3 个条件是否能破坏！\n\n保持加锁顺序一致：不要出现上面代码中的线程 a 先申请锁 1，线程 b 先申请锁 2 的情况。在不同的执行流中，按相同的顺序申请锁（比如线程 a 和 b 都是按锁 1&#x2F;2 的顺序申请的）一定程度上能破坏  请求与保持  条件\n降低加锁的粒度：锁保护的区域变小，加锁的粒度减小，能一定程度上避免锁未释放\n资源一次性分配：减少临时资源分开给的情况\n允许抢占：线程之间依靠优先级抢夺锁，这种情况就是  锁允许被剥夺\n\n\n6. 线程安全  线程安全：多个线程并发执行同一段代码的时候，不会  出现不同的结果\n线程不安全的情况：\n\n不保护临界资源\n在多线程操作中调用  不可重入  函数（概念见 linux 信号 部分）\n返回指向静态变量的指针的函数\n\n线程安全：\n\n每个线程只操作局部变量，或者只对全局、静态变量只读不写\n接口对线程来说是原子操作（被锁保护）\n多个线程切换不会使函数接口的结果出现  二义性\n多线程操作不调用不可重入函数\n\n注意，绝大多数的系统自带的库（比如 C++ 的 STL 库）都是  不可重入  的\n\n不可重入是函数的一种  性质 ，并不是它的缺点！如果一个库函数明明告知你了我是不可重入的，你还不加保护的在多线程操作中调用它， 那么这段代码是有 bug 的，并不是库函数本身有问题\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】旋转锁 | 读写锁","url":"/posts/822375107/","content":"在之前的线程学习中，用到的锁都是挂起等待锁，如果申请不到锁，那就会在锁中等待；\n自旋锁则不大相似\n\n\n[TOC]\n1. 自旋锁 1.1 概念 自旋锁是一个轮询检测锁，其检测机制并不是挂起等待，而是不断的询问锁有没有空闲；类似于一个 while(1) 循环的trylock()\n由于其需要不断的轮询检测，所以会占用一定的 CPU 资源；如果线程较多，就容易给 cpu 造成负荷。\n但是自旋锁无须唤醒  挂起等待  状态的线程，其消耗较小。\n总结一下：\n\n自旋锁适合竞争不激烈，且临界区较小（呆的时间短）的情况\n自旋锁不适合大量线程，临界区长的情况\n\n自旋锁的优缺点反过来，便是挂起等待锁的优缺点了。我们要根据不同场景，正确选择锁的类型\n1.2 接口  相关接口和 mutex 都是很相似的，这里就不演示使用的效果了\n1.2.1 pthread_spin_init&#x2F;destroy#include &lt;pthread.h&gt;int pthread_spin_destroy(pthread_spinlock_t *lock);int pthread_spin_init(pthread_spinlock_t *lock, int pshared);\n\n1.2.2 pthread_spin_lock自旋锁同样有 trylock 接口，用于判断锁是否就绪\n#include &lt;pthread.h&gt;int pthread_spin_lock(pthread_spinlock_t *lock);int pthread_spin_trylock(pthread_spinlock_t *lock);\n\n1.2.3 pthread_spin_unlock#include &lt;pthread.h&gt;int pthread_spin_unlock(pthread_spinlock_t *lock);\n2. 读写锁  有的时候，我们会有一份 config 配置文件，这个配置文件会有非常多的线程进行读取，但是很少进行修改和写入。\n此时我们如果对配置文件的读取进行加锁，就容易导致效率问题，众多线程不断被阻塞，产生性能损失。\n此时，就可以用一个专门的读写锁，对读者和写者加不同的锁，在提升读取性能的同时，保证写入不冲突\n2.1 读者写者的关系  写着和写着之间不用多说，肯定是互斥关系；\n读者和写者  之间也是互斥关系，在写入的时候，不能进行读取，否则容易出现二义性问题；\n\n写者写入了一个 a，线程甲来读取，得到的结果是 a\n写者继续写入了 b，线程乙来读取，得到的结果是 ab\n\n这是因为写者的写入还没有完成，导致甲乙读者会获取到完全不同的结果，这是不对的；\n读者和读者之间没有关系，因为读者并不会修改数据，也不会取走数据，其存在对临界资源没有影响。\n\n2.2 接口 2.2.1 init&#x2F;destroy 读写锁只需要初始一个锁就行了，无须对读者写者初始化两个不同的锁\n#include &lt;pthread.h&gt;int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,\t\t\t\t\tconst pthread_rwlockattr_t *restrict attr);\n\n2.2.2 读者加锁  读写锁的读者锁 &#x2F; 写者锁是分开的，我们要针对不同的线程调用不同的锁\n#include &lt;pthread.h&gt;int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n\n但是解锁的接口是一样的\n#include &lt;pthread.h&gt;int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n\n2.2.3 写者加锁#include &lt;pthread.h&gt;int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n\n2.2.4 设置锁的属性\n参考 PTHREAD_RWLOCKATTR_SETKIND_NP - Linux 手册页\n\n读写锁可以允许我们设置是读者优先还是写者优先。如果采用默认的属性，可能会出现读者一直在读，写者没有办法写入的情况（打印错位是正常情况）\n[muxue@bt-7274:~/git/linux/code/23-01-20 rwlock]$ ./testreader [140484801697536]reader [140484801697536] 0reader [140484793304832]reader [reader [140484784912128140484793304832]reader [140484784912128] 0] 0reader [140484759734016]reader [140484759734016] 0reader [140484776519424]\n\n此时就出现了  写者饥饿  问题，写者无法访问临界资源，饿死了😂\n我们可以根据自己的需求进行设置读写锁的属性\nint pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *attr, int pref); /* pref 共有 3 种选择PTHREAD_RWLOCK_PREFER_READER_NP (默认设置) 读者优先，可能会导致写者饥饿情况PTHREAD_RWLOCK_PREFER_WRITER_NP 写者优先，目前有 BUG，导致表现行为和 PTHREAD_RWLOCK_PREFER_READER_NP 一致PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP 写者优先，但写者不能递归加锁，避免死锁*/\n\n下面是一个示例\npthread_rwlock_t rwlock;// 锁pthread_rwlockattr_t attr;// 属性pthread_rwlockattr_init(&amp;attr);// 初始化属性pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);// 设置锁的属性为写者优先pthread_rwlock_init(&amp;rwlock, &amp;attr);// 初始化并设置读写锁的属性\n\n2.3 代码#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;using namespace std;volatile int board = 0;// 临界资源pthread_rwlock_t rw;// 全局读写锁void *reader(void* args)&#123;    const char *name = static_cast&lt;const char *&gt;(args);    cout &lt;&lt; &quot;reader [&quot;&lt;&lt;pthread_self() &lt;&lt;&quot;]&quot;&lt;&lt; endl;    //sleep(1);    while(true)    &#123;        pthread_rwlock_rdlock(&amp;rw);        cout &lt;&lt; &quot;reader [&quot;&lt;&lt;pthread_self() &lt;&lt;&quot;] &quot; &lt;&lt; board &lt;&lt; endl;        pthread_rwlock_unlock(&amp;rw);        usleep(110);    &#125;&#125;void *writer(void *args)&#123;    const char *name = static_cast&lt;const char *&gt;(args);    //sleep(1);    while(true)    &#123;        pthread_rwlock_wrlock(&amp;rw);        board++;        cout &lt;&lt; &quot;writer [&quot; &lt;&lt; pthread_self() &lt;&lt;&quot;]&quot;&lt;&lt; endl;        pthread_rwlock_unlock(&amp;rw);        usleep(100);    &#125;&#125;int main()&#123;    pthread_rwlock_init(&amp;rw, nullptr);    pthread_t r1,r2,r3,r4,r5,r6, w1,w2;    pthread_create(&amp;r1, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r2, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r3, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r4, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r5, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r6, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;w1, nullptr, writer, (void*)&quot;writer&quot;);    pthread_create(&amp;w2, nullptr, writer, (void*)&quot;writer&quot;);    pthread_join(r1, nullptr);    pthread_join(r2, nullptr);    pthread_join(r3, nullptr);    pthread_join(r4, nullptr);    pthread_join(r5, nullptr);    pthread_join(r6, nullptr);    pthread_join(w1, nullptr);    pthread_join(w2, nullptr);    pthread_rwlock_destroy(&amp;rw);    return 0;&#125;\n\n运行结果如下\nreader [140067523458816] 7086reader [140067548636928] 7086writer [140067515066112]writer [140067506673408]reader [140067540244224] 7088reader [140067565422336] 7088reader [140067557029632] 7088reader [140067531851520] 7088reader [140067523458816] 7088writer [140067515066112]writer [140067506673408]reader [140067548636928] 7090writer [140067515066112]reader [140067523458816] 7091writer [140067506673408]reader [140067548636928] 7092reader [140067557029632] 7092\n\n可以看到读者的线程较多，且能够正确读取数据。\n如果在读者的 whiile 中加上sleep(10)\nvoid *reader(void* args)&#123;    const char *name = static_cast&lt;const char *&gt;(args);    cout &lt;&lt; &quot;reader [&quot;&lt;&lt;pthread_self() &lt;&lt;&quot;]&quot;&lt;&lt; endl;    while(true)    &#123;        pthread_rwlock_rdlock(&amp;rw);        cout &lt;&lt; &quot;reader [&quot;&lt;&lt;pthread_self() &lt;&lt;&quot;] &quot; &lt;&lt; board &lt;&lt; endl;        sleep(10);// 睡        pthread_rwlock_unlock(&amp;rw);        usleep(110);// 避免出现只有一个线程工作    &#125;&#125;\n\n能够看到多个读者之间不冲突，不会出现读者 A 申请锁后，读者 B 就无法访问临界区的情况。如果是互斥锁，读者 A 申请之后进入休眠，B 就无法申请该锁。\n\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】网络原理","url":"/posts/4145270627/","content":"本篇博客让我们一起来了解一下网络的基本原理\n\n\n1. 网络发展背景  关于网络发展的历史背景这种东西就不多 bb 了，网上很容易就能找到参考资料，我的专业性欠缺，文章参考意义也不大。这里只做简单说明。\n网络发展经过了如下几个模式：\n\n独立模式：计算机之间相互独立，靠人移动数据\n互联模式：多台计算机连接到一起，实现数据共享\n局域网 LAN：计算机数量增多，通过交换机 &#x2F; 路由器连接到一起\n广域网 WAN：将相隔距离非常远的计算机连在一起\n\n交换机是啥？简单来说就是一个有很多网口的设备，将设备插上去后（一般用的都是 RJ45 网线）就能相互交流信息。我们家用的 WIFI 路由器其实已经集成了交换机的功能！\n1983 年，TCP&#x2F;IP 协议成为 ARPANET 上的标准协议，人们把 1983 年称为互联网的诞生时间。\n1.1 计算机设备之间是怎么交流的？计算机内部有非常多的设备，在设备和设备之间一定要用“线”进行连接。这样这些设备才能相互通信。比如主板上的总线，链接硬盘的 sata 线等等。\n而这个计算机的结构本质上也能被看作一个小型网络。\n此时我们将计算机 A 和 B 用  数据线  连接起来，就能在  物理层面  上，让 A 和 B 相互通信（此时暂且不考虑通过何种方式通信，只要用数据线连起来了，那就一定能通信）\n\n在主机内，线短\n跨主机，线长\n\n当数据线长了之后，线路和线路之间就容易产生信号的干扰，导致数据的错误 &#x2F; 丢失。此时我们就需要一个  更可靠、高效  的方式来实现远距离计算机之间的通信，这就是网络的意义\n1.2 集群  进一步扩大，实际上，还可以用多台主机相连，实现单一的功能。这时候，这一堆主机被称为  集群\n\n存储集群：硬盘\n缓存集群：内存\n计算集群：Cpu&#x2F;Gpu\n\n不同的集群干不同的事，再用数据线连起来，就成了一台由多个主机共同构成的“电脑”\n\n在大型的数据中心里面，就是用这种方式来处理海量的数据的。\n1.3 因特网  当前我们主要在计算机上使用的是 Internet，官方名称为因特网，日常说的互联网就是因特网。\n但还有另外一个  互连网 ，其概念是互相连接的网络，英文名是 internet（小写的 i）， 互联网 ≠ 互连网！\n1.4 ISP&#x2F;IXPISP 的中文名是互联网服务提供者，在我们国内说的就是三大运营商\nIXP 是狐狸那我交换点，允许两个网络直接相连并快速提供分组的转发。\n2. 协议  协议是一种约定，约定好两台设备要用什么方式来交流。\n比如我们都是中国人，可以用  普通话  这个  协议  来交流；而广东地区的人，可以用  粤语  来交流。\n计算机之间想交流，肯定也需要确定好一个  行业通用的协议！\n否则不同计算机的  架构 / 操作系统 / 硬件设备  不一样，若协议不统一，也就无法正常交流。这就好比一个说英语的人听不懂普通话一样。\n2.1 分层  网络的协议是分层的\n2.1.1 为什么要分层  软件分层，就好比将主代码和功能代码给分开\n\n此时只要功能代码提供的接口不变，主代码的调用方式就不变\n主代码无须关心功能代码是如何处理的，只关心其处理的结果（返回值）\n工程师修改代码的时候，只需要定位到具体模块进行修改，不会出现牵一发动全身的情况\n\n这样，就实现了主模块和功能模块的  解耦\n\n由于网络涉及到了软件到硬件  各种层面  的设备操作，所以其必须采用分层的协议。不同设备采用不同的协议，才能最大层面的保证网络系统整体不出 bug\n\n网络协议有一个特点：同层设备  都可以认为自己在直接和对方通信\n2.1.2 电话机例子  以下图为例，当俩个人用座机打电话的时候，他们会认为自己在直接和对方交流，而不会认为自己是在和电话机交流\n\n此时，就可以把这个系统分 3 层：分别是两人之间的语言协议，电话机和电话机之间读取数据的协议，以及最底层用于传输信号的通信协议\n\n用户不会去关心电话机用的是什么协议，而是关心自己应该用什么语言和对方交流\n电话机不会去关心用户是用什么语言交流的，其只负责把收到的声音转换成电信号\n通信协议不管电话机是怎么封装的，其只负责传输数据\n\n这里就能看出来，不仅同层的设备可以认为自己是  直接  和对方交流，而且它还  不需要  管其他层用的是什么协议！\n\n电话机不会因为你说英语而用不了\n\n这就是  分层实现解耦  的效果，也算是每一层都实现了自己的封装\n2.2 OSI 七层模型\nOSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型， 是一个逻辑上的定义和规范; \n它把网络从逻辑上分为了 7 层。每一层都有相关、相对应的物理设备，比如路由器，交换机;\nOSI 七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输;\n它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整。 通过七 个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯\n\n\n可以用下面的这个表格来简单了解一下每一层的功能\n\n\n\n分层名称\n功能\n概览\n\n\n\n应用\n针对特定应用的协议\nSTMP 邮件 &#x2F; 远程登录 &#x2F; 文件传输\n\n\n表示\n数据固有格式和网络标准格式的转换\n接收不同表现形式的信息\n\n\n会话\n通信管理，负责建立 &#x2F; 断开通信连接，维持不同应用程序的通信\n何时建立 &#x2F; 何时断开 &#x2F; 建立多久\n\n\n传输\n两个节点之间的数据传输\n维持传输可靠性\n\n\n网络\n地址管理 &#x2F; 路由选择（逻辑寻址\n确定最佳路径\n\n\n数据链路\n互联设备之间传送和识别数据\n将数据组合成字节\n\n\n物理\n以 01 二进制进行数据传输\n网线\n\n\n但是 OSI 七层模型相对比较复杂，我们主要关注的还是 TCP/IP 模型\n2.3 TCP&#x2F;IPTCP&#x2F;IP 是一组协议的代名词，它其中包括很多协议，组成了一个整体。为了方便使用，TCP&#x2F;IP 协议将 OSI 的上方 3 层统一称为应用层，由用户字节决定如何进行数据的序列化 &#x2F; 反序列化，什么时候建立连接，什么时候断开连接\n\nTCP&#x2F;IP 模型可以认为是 4&#x2F;5 层，每一层也有自己不同的功能。每一层都会调用另外一层，来实现自己的需求\n\n物理层: 负责光 &#x2F; 电信号的传递方式。 比如现在以太网通用的网线 (双绞 线)、早期以太网采用的的同轴电缆 (现在主要用于有线电视)、光纤, 现在的 wifi 无线网使用电磁波等都属于物理层的概念。物理层的能力决 定了最大传输速率、传输距离、抗干扰性等。集线器(Hub) 工作在物理层\n数据链路层: 负责设备之间的数据帧的传送和识别。 例如网卡设备的驱动、帧同步 (就是说从网线上检测 到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作。 有以太 网、令牌环网, 无线 LAN 等标准。交换机(Switch) 工作在数据链路层\n网络层: 负责地址管理和路由选择。 例如在 IP 协议中, 通过 IP 地址来标识一台主机, 并通过路由表的方式规 划出两台主机之间的数据传输的线路 (路由)。路由器(Router) 工作在网路层\n传输层: 负责两台主机之间的数据传输。 如传输控制协议 (TCP)， 能够确保数据可靠的从源主机发送到目标 主机\n应用层: 负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问 协议（Telnet）等。 我们的网络编程主要就是针对应用层。\n\n为啥这里有 5 层，却有时候又说是 4 层呢？😏\n因为  物理层  关注的较少，所以一般都只注重于剩下的 4 层\n3. 网络和操作系统之间的关系  用户的网络请求要想成功发送给对方，那就一定要经过  网卡  这个硬件；而要经过网卡，那就肯定要经过操作系统——只有操作系统能直接访问硬件！\n所以，数据在主机内流动的时候，就一定会从  用户走到内核，再最终走到物理层进行传输！\n\n因为计算机的体系结构决定了数据流动的时候，一定要经过操作系统，所以肯定会是  自顶向下 &#x2F; 自底向上  进行流动的！\n\n这就引出了二者的关系\n\n网络协议栈  是属于操作系统的：在操作系统中，有一个模块就是专门来处理 tcp&#x2F;ip 协议的。\n\n前面提到，每一层都可以认为自己是在和对方同层的用户直接通信。这样做是有一定代价的，且听我细细道来。\n3.1 快递例子  当我们网购商品的时候，我们作为用户，是直接和商家联系的。下了订单后，商家要去做一系列的操作，最终我们从快递小哥处拿到了商品\n\n\n\n客户\n商家\n\n\n\n在商家处下订单\n接收到用户订单\n\n\n从快递员处收到货物\n将货物交给快递员\n\n\n货物运输到集散点\n货物运输到集散点\n\n\n但，我们收到的快递并不是只有我们要的商品，往往这里面都会多出一些东西\n\n如图，我们的商品被一个盒子包裹着，外头还多了一个快递单\n\n\n\n客户\n商家\n\n\n\n\n在商家处下订单\n接收到用户订单\n给出收件地址\n\n\n从快递员处收到货物\n将货物交给快递员\n添加外箱并填写邮寄单\n\n\n货物运输到集散点\n货物运输到集散点\n开始运输\n\n\n在这个例子中，每一层其实都给出了自己的独有协议。我们可以把最下面的运输当作  物理层。\n快递小哥在包装快递的时候，就会给快递增加一个外箱，并填写好邮寄单。当另外一边的快递小哥收到这个货物的时候，就可以更具邮寄单上的信息，将快递送到用户手上。\n3.2 报头 &#x2F; 解包  此过程中，为了维护快递的  出发地 / 终点地  信息，快递员给货物添加上了  客户不需要  的东西。\n\n在网络协议中，每一层协议，都会给我们要传输的数据  添加上  独有的协议信息，再交付给下一层；这些信息是用来维护数据的（就好比快递单号上的地址）\n多出来的协议数据被称为：报头\n\n\n收到信息后，同层协议会  取出  自己的那份协议信息进行分析，再交付给上一层\n拆开数据的过程被称为：解包\n\n\n\n\n不知道快递的例子能否帮助你理解这个过程\n\n3.3 报头的作用  数据会有不同的应用，也对应了不同的协议。在封包的时候，添加的报头信息里面就应包含目标的协议信息\n\n比如我的信息是 SMTP 邮箱信息，那么在目标主机接收到进行解包了以后，也需要将这个信息交给支持 SMTP 的邮箱软件进行处理\n报头属性里面就需要包含支持  分用👆的属性（还有一些公共属性）\n报头属性里面还需要包含区分  有效载荷  和报头的属性，也就是将要发送的数据，和这一层的报头给拆开，不能到时候分不出来，无法正常解包了\n\n这个过程就是一个  分用  的过程，我们传送的信息，被称为  有效载荷\n\n快递点也是一样，如果快递点收到的都是商品而没有快递单，快递小哥也就无法知道快递应该送给谁了\n4. 局域网  以太网的命名来自物理学中的  以太，这部分的故事可以百度😶‍🌫️大学物理课上也讲过。\n\n如果两台主机，处于同一局域网中，他们之间能通信吗？\n和同学开手机热点联机 MC 的经历告诉我😏，是可以的\n\n4.1 MAC 地址  局域网就好比一个餐厅，里面有很多人在聊天。当你在餐厅里面和张三聊天的时候，旁边的人也能听到你们俩交流的内容。局域网内也是如此。\n要想在局域网内准确地找到一个设备，那就需要一个唯一标识码。就好比想在教室里面找到一个人，需要知道名字一样（排除同名问题）\n每台主机唯一的标识码，就是该主机对应的 MAC 地址\n\nMAC 地址用来识别数据链路层中相连的节点\n长度为 48 位, 及 6 个字节。 一般用 16 进制数字加上冒号的形式来表示(例如: 08:01:27:04:fb:19) \nMAC 地址在网卡出厂时就确定了，不能修改！ 且 mac 地址通常是唯一的（虚拟机中的 mac 地址不是真实的 mac 地址，可能会冲突；也有些网卡支持用户配置 mac 地址）\n\n局域网内没有发送限制，任何一台主机随时都可发送消息。此时还需要引入  碰撞检测  机制，在没有人发送信号的时候，本设备再发送信号。避免多台主机通信时，出现信号撞到一起（碰撞域）而导致的信息丢失。\n以系统编程的角度来看，此时的局域网可以认为是一个  临界资源。保证数据不被碰撞，就是保护临界资源的一致性！😛\n4.2 通信原理  和前面提到的报头 &#x2F; 解包一样，局域网内的数据，也是自顶向下、自底向上流动的。\n每一层都有自己的协议，也需要加上自己的报头\n\n5. 广域网  在广域网内通信就没有那么简单了。这就好比唐僧去西天取经，不是直接走到西天的，而是需要经过多个驿站（中途地点）\n在广域网内通信，我们则是通过 ip 地址来做驿站，来查找目标主机的\n\n在局域网内用的是 mac 来标识目标的唯一性\n广域网内采用 ip 来标识目标的唯一性\n\n5.1 IP 地址IP 协议有两个版本，IPv4 和 IPv6（本文只关注 v4）\nIP 地址是在 IP 协议中，用来标识网络中不同主机的地址；\n对于 IPv4 来说，IP 地址是一个 4 字节，32 位的整数。通常使用 “点分十进制” 的字符串表示 IP 地址, 例如 192.168.0.1；用点分割的每一个数字表示一个字节, 范围是 0 - 255；\n因 ipv4 的规定的局限性，ipv4 的 ip 现在已经逐渐枯竭，很多地方的运营商已经不提供家用宽带的公网 IP 地址。\n5.2 通信过程  在广域网通信的时候，每次都需要提供源 IP 和目标 IP，这就是  从哪儿来 / 到哪儿去；同时，还需要提供源 MAC 和目标 MAC 进行标识。\n在通信过程中，会有路由器来告诉你应该去哪儿。在这期间，我们的数据会在  不同的局域网  内进行切换。\n\n在切换过程中，路由器会更新你的源 IP&#x2F;MAC（目标 IP 不变）并提供目标的 MAC 地址\n\n唐僧去西天取经，他的  目的地  是不会变的，但是上一站 &#x2F; 下一站会不断变化\n\n以下图为例，当我们的数据走到 IP 这一层时，就会加上 IP 协议的报头。并在路由器内进行  解包，再换上新的 IP 报头。\n\n此时 IP 一层就可以和其他层区分开，因为在 IP 层之上，发送 / 接收  主机收到的数据是完全一样的！\n\nIP 层是一个软件层，任何底层的差异，都可以通过加一层软件层来解决。这是一种  软件虚拟化  技术，linux 的  文件系统  也使用了这种技术\n\n也就是说，通过 IP 层，可以屏蔽底层网络的差距。在通过 ip 通信的时候，不需要关注底层的路由等硬件信息以及数据传输的实现。\n5.3 端口  一台主机里面有非常多的进程，每一个进程都能访问网络发送信息。\n光用 IP 地址，我们实际上只能找到对应的主机，却无法确定是这台主机里面的 xx 应用发出的信息。\n此时，就需要利用端口号来  确定  我们要访问的进程是什么了。\n\nIP：确保主机唯一性\n端口 port：确保该主机上的进程唯一性\n\n如果你有用过 docker，那肯定就知道端口号这一存在。大部分 docker 都需要映射一个端口以对外提供服务。\n网络间的通信，本质上是不同主机上的  进程通信\n\n端口号是一个 2 字节的整数，限定了端口范围（1-65,536）\n端口号用于标识一个进程，告诉系统，当前的数据应交给哪一个进程去运行\n同一个进程可以使用多个端口号\n但是一个端口号只能对应一个进程\n\n网络通信中，有源 IP 和目标 IP，也有源端口和目标端口。我们把这一对 IP+ 端口被称为socket 对\n5.3.1 端口 &#x2F;PID 的关系  在一台主机里面，PID 也可以用于标识唯一的进程。但是，端口号和 PID 是属于两个完全不同的概念。\n\n假设餐厅里有一个  扫把，餐厅雇了个保洁员 A，让他来打扫餐厅的卫生。此时就可以把扫把认为是端口，保洁员 A 是一个进程。\n有一天，保洁员 A 生病了，请假一周。于是老板又请了一个保洁员 B，让他来打扫一周的卫生。此时，保洁员 B 也能使用餐厅里面已有的扫把，来进行打扫工作\n\n保洁员 A&#x2F; 保洁员 B 干的工作是完全一致的\n他们使用的是同一个扫把\n\n\n我们知道，在 linux 中，一个同一个可执行程序，每一次执行的时候，它的进程 PID 都是不同的；但同一个可执行程序，干的活肯定是一样的。\n保洁员 A 和 B 就可以看作是同一个  可执行程序 ，他们用的也是同一个 端口 （扫把），但保洁员 A 和 B 的 进程 PID是不一样的！\n所以，在网络通信的时候，采用了  端口  这个扫把来标识需要进行网络通信的进程，而不是继续采用 PID 来标识👻\n\n操作系统只需要维护一个端口号和进程的哈希表，就能快速地通过端口号找到对应的进程\n\n5.4 TCP&#x2F;UDPTCP（Transmission Control Protocol 传输控制协议）\n\n传输层协议\n有链接（必须要和目标建立连接，才能开始数据传输）\n可靠传输（检查是否有丢包，需要保证数据完全被传输到目标主机）\n面向字节流\n\nUDP（User Datagram Protocol 用户数据报协议）\n\n传输层协议\n无连接（无须建立连接，比如所有人都能给你的电子邮箱发送邮件）\n不可靠传输（不检查丢包）\n面向数据报\n\n6. 网络字节序  在之前学习 int 类型的存储 的时候，提到过  大端 / 小端  的概念\n6.1 说明  在网络中，数据流同样有大端小端之分。TCP/IP协议规定，网络数据流应该采用大端字节序（低地址高字节）后发出的数据是高地址\n\n如上图的 1 为例，当网络中发送这个数字 1 的时候，会先发送00 00 00，最后发送的是01。这样能够方便数据的拼接\n\n发送主机将缓冲区中的数据按内存地址  从低到高  的顺序发出\n接受主机把数据依次保存到缓存区中，也是按地址从低到高的顺序保存\n\n这个规定更重要的意思是，如果不对网络字节数据的大小端做出限制，那么网络里面就会出现既有大端又有小端的情况，得写俩套代码来处理这个问题。\n而  限制为大端  之后，小端机器就需要在发送信息之前将数据转为大端，在接收到数据之后，将数据转换为小端。此时的处理就是  操作系统  的工作了，和 TCP/IP 协议本身没有关系了😛\n6.2 转换接口  为了提高可以移植性，有以下的这个接口将网络字节序和主机字节序进行转换\n#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t hostlong);uint16_t ntohs(uint16_t hostshort);\n\n在命名中，n 代表 network，h 代表 host，l 代表 long，s 代表 short。\n如果主机就是大端，这些函数什么都不会做。如果主机是小端，则会将主机字节序转换成网络字节序（或反之）\n更多…关于网络原理的前置知识暂时就记录这么多，后续有新增会来更新本文\n","categories":["玩上Linux"],"tags":["Linux","网络"]},{"title":"【Linux】来写一个 tcp 的服务端 + 客户端","url":"/posts/2171263616/","content":"今天让我们来写一个 tcp 的服务器 &#x2F; 客户端代码\n\n\n\n完整代码见我的 gitee 连接\n阅读本文前，建议先阅读👉 udp 服务器\n\n1. 基本框架 tcp 的服务器和 udp 服务器初始化接口是非常相似的，区别就在于要选择 字节流  进行初始化\n但是到运行状态就不同了\n\ntcp 是需要连接的\nudp 不需要连接\n\n所以就会出现分歧：udp 可以用 sendto 和 receve 来发送 &#x2F; 接收信息，服务端只需要监听特定端口收到了什么信息；\n但 tcp 并不能这么做，在通信之前，tcp 服务器必须要和客户端建立链接。\n举个不恰当的例子，udp 服务器好比一个水盆，等待水的注入；而 tcp 服务器是个水管，必须要两头连通了，才能开始注水\n1.1 类成员  类的成员变量和 udp 很相似，都是需要服务器的 ip、端口、sockfd 这些信息。为了更容易区分，将 tcp 服务器的 socket fd 改为_listenSock，意为监听端口\nclass TcpServer&#123;private:    // 服务器端口号    uint16_t _port;    // 服务器 ip 地址    string _ip;    // 服务器 socket fd 信息    int _listenSock;&#125;;\n\n1.2 头文件  这里对头文件进行一定的说明，因为服务器代码中的头文件实在太多了\n当你需要使用一个接口的时候，可以去采用 man 手册来获取该接口的头文件信息\n#pragma once// 头文件太多了，所以新起一个文件#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cassert&gt;#include &lt;ctype.h&gt;// 判断字符串大写小写接口需要的库#include &lt;unistd.h&gt; #include &lt;strings.h&gt;// 忽略大小写比较 strcasecmp#include &lt;sys/types.h&gt;  // 很多 liunx 系统接口都需要这个#include &lt;sys/socket.h&gt; // 网络#include &lt;netinet/in.h&gt; // 网络#include &lt;arpa/inet.h&gt; // 网络using namespace std;#define SOCKET_ERR 1#define BIND_ERR   2#define LISTEN_ERR 3#define USAGE_ERR  4#define CONN_ERR   5#define BUFFER_SIZE 1024\n\n2. 初始化  接口的介绍就跟随实现一步一步来吧\n2.1 构造 sock这里出现了 tcp 和 udp 第一个不同之处，tcp 是面向字节流的，udp 面向的是数据报\nTcpServer(uint16_t port,const string&amp; ip=&quot;&quot;) :_port(port), _ip(ip), _listenSock(-1)&#123;    // 1. 创建 socket 套接字, 采用字节流（即 tcp）    _listenSock = socket(AF_INET, SOCK_STREAM, 0); // 本质是打开了一个文件    if (_listenSock &lt; 0)    &#123;        logging(FATAL, &quot;socket:%s:%d&quot;, strerror(errno), _listenSock);        exit(1);    &#125;    logging(DEBUG, &quot;socket create success: %d&quot;, _listenSock);&#125;\n\n2.2 初始化 sockaddr_in继续，初始化 sockaddr_in 的操作和 udp 是完全一致的\n// 2. 绑定网络信息，指明 ip+port// 2.1 先填充基本信息到 struct sockaddr_instruct sockaddr_in local;memset(&amp;local,0,sizeof(local));// 初始化// 协议家族，设置为 ipv4local.sin_family = AF_INET; // 端口，需要进行 本地 -&gt; 网络转换local.sin_port = htons(_port);// 配置 ip// 如果初始化时候的 ip 为空，则调用 INADDR_ANY 代表任意 ip。否则对传入的 ip 进行转换后赋值local.sin_addr.s_addr = _ip.empty() ? htonl(INADDR_ANY) : inet_addr(_ip.c_str());\n\n2.3 bind也是一样，绑定服务器的 ip 和端口\n// 2.2 绑定 ip 端口if (bind(_listenSock,(const struct sockaddr *)&amp;local, sizeof(local)) == -1)&#123;    logging(FATAL, &quot;bind: %s:%d&quot;, strerror(errno), _listenSock);    exit(2);&#125;logging(DEBUG,&quot;socket bind success: %d&quot;, _listenSock);\n\n2.4 监听 listen对于 tcp 服务器来说，成员变量的 _listenSock 是用来监听的，即找个老哥一直盯着云服务器的这个端口，看看有没有需要连接它的客户端\n#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);\n\n其中第一个参数是我们的_listenSock，第二个参数是用于限制在阻塞等待连接的数量\nThe backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.   If  a connection  request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt  at  con‐nection succeeds.\n\n翻译过来就是，backlog参数限制了能被阻塞等待连接的数量。如果超过这个数量，则会返回一个 ECONNREFUSED 错误。亦或者如果协议支持重传，多余的请求会被忽略，后续可以重传\nman 手册下面的 notes 还有更多解释\nThe behavior of the backlog argument on TCP sockets changed with Linux 2.2.  Now it specifies  the  queue  length  for completely  established  sockets waiting to be accepted, instead of the number of incomplete connection requests.  The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog.  When syn‐cookies are enabled there is no logical maximum length and this setting is ignored.  See tcp(7) for more information. If  the  backlog  argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128.  In kernels before 2.4.25, this  limit  was  a  hard  coded  value,SOMAXCONN, with the value 128.\n\n如果 backlog 参数高于 /proc/sys/net/core/somaxconn 中的默认值 128，则会被截断为 128\n\n在我们这里，将其设置为 5 即可，反正也是做测试嘛，问题不大\n// 3. 监听// tcp 服务器是需要连接的，连接之前要先监听有没有人来连if (listen(_listenSock, 5) &lt; 0)&#123;    logging(FATAL, &quot;listen: %s&quot;, strerror(errno));    exit(LISTEN_ERR);&#125;logging(DEBUG, &quot;listen: %s, %d&quot;, strerror(errno), _listenSock);\n\n3. 运行  初始化到这就完毕了，下面就是开跑了\n3.1 accept#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n\n这个接口的作用就相当于 tcp 中的recevefrom，传参是完全相同的；与之不同的是，该函数的返回值是一个全新的sockfd\n\ntcp 需要和客户端建立链接\n链接需要用 socket fd 来管理\n所以 accept 必须返回新的 socket fd，让服务端有办法管理新的链接和已有链接\n原有的 socket fd 不受影响\n如果没有客户端来连接，进程会在 accept 内阻塞等待\n\n下为 man 手册中的描述\nThe  accept()  system  call  is  used  with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).  It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected  socket,  and  returns  a  new  file descriptor referring to that socket.  The newly created socket is not in the listening state.  The original socket sockfd is unaffected by this call.\n\n举个例子，tcp 服务器自身的 socket fd 只会用来监听端口上有没有消息，当监听到有消息并通过 accept 建立连接后，就会让另外一位服务员来对这个连接提供服务。\nwhile(1)&#123;    struct sockaddr_in peer;    socklen_t len = sizeof(peer);    // 获取连接    int conet = accept(_listenSock,(struct sockaddr*)&amp;peer,&amp;len);    if(conet&lt;0)    &#123;        logging(FATAL, &quot;accept: %s&quot;, strerror(errno));        exit(CONN_ERR);// 连接错误    &#125;    //。。。&#125;\n\n注意这里 len 的参数是socklen_t，其本质上是一个无符号整形\ntypedef __socklen_t socklen_t;__STD_TYPE __U32_TYPE __socklen_t;#define __U32_TYPE\t\tunsigned int\n\n3.2 获取连接信息  这部分和 udp 是完全相同的，通过 accept 返回的 socket fd，获取用户的 ip 和端口耨\n// 获取连接信息string senderIP = inet_ntoa(peer.sin_addr);// 来源 ipuint16_t senderPort = ntohs(peer.sin_port); // 来源端口logging(DEBUG, &quot;accept: %s | %s[%d], socket fd: %d&quot;, strerror(errno), senderIP.c_str(), senderPort, conet);\n\n其实到这里，我们就可以运行服务器进行测试了。因为 tcp 的特性，我们不需要写客户端，直接用浏览器就能连上服务端\nint main(int argc,char* argv[])&#123;    // 参数只有两个（端口 /ip）所以参数个数应该是 2-3    if(argc!=2 &amp;&amp; argc!=3)    &#123;        cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; port [ip]&quot; &lt;&lt; endl;        return 1;    &#125;        string ip;    // 3 个参数，有 ip    if(argc==3)    &#123;        ip = argv[2];    &#125;    TcpServer t(atoi(argv[1]),ip);    t.start();    return 0;&#125;\n\n先编译后执行代码，让 tcp 服务器运行起来\n\n随后在浏览器的地址栏输入  公网 ip: 端口（先要开启防火墙内的端口）\n\n此时会发现什么都加载不出来，这是对的，因为我们并没有写前端，也没有提供任何服务。但是来到后台，可以看到出现了一个新的连接，并显示出了 ip+ 端口\n\n3.3 提供服务（线程）接下来要做的，就是写一个简单的服务了，这里我写的是字符串转 ASCII 码，会将发出去的字符串的 ascii 码加加起来后返回\n3.3.1 问题 1 如何通信  此时问题就来了，tcp 服务器不能使用 recevefrom 和 sendto，那么获取到 socket 之后要怎么进行通信呢？\n答案是：用 linux 的文件读写接口，read 和 write。别忘了，socket fd 本质上就是一个 linux 下的文件描述符！\n3.3.2 问题 2 多客户端tcp 服务器要想给多个客户端提供服务，就必须采用多线程 &#x2F; 多进程的方式来实现操作。否则会出现一个严重的问题，服务端因为提供服务而没有accept，无法链接上下一个客户端\nwhile(1)&#123;    //accept 获取到链接上的客户端        while(1)    &#123;         // 如果在这里提供服务，则会其他连接会在 listen 里面阻塞    \t// 只有当前服务终止了，其他客户端的其中之一才能连上服务器    &#125;&#125;\n\n3.3.3 问题 3 线程传参  既然需要采用多线程服务，那就需要设定好给线程传的参数。理论上来说，我们只需要传入 accept 的返回值 socket fd 即可进行read/write\n但实际上，我们还需要打印 debug 消息，要知道当前是谁向你发送了这条消息，ip 和端口是什么。\n为了方便操作，这里封装一个结构体，将 socket fd，客户端的 ip+ 端口封装成一个参数进行传参（线程的函数只能传入一个参数）\nstruct ClientData&#123;    int _fd;    uint16_t _port;    string _ip;    TcpServer* _this;    ClientData(int fd,uint16_t port,const string&amp; ip,TcpServer* this1)        :_fd(fd),_port(port), _ip(ip),_this(this1)    &#123;&#125;&#125;;\n\n你可能会想到另外一个办法，那就是在 tcp 服务器的 class 中新增一个 map 成员变量，用于映射 socket fd 和客户端信息的键值对，但是这无法实现。\n因为在类中设计的多线程函数，为了去掉默认传入的 this 指针，必须要设置成 static 静态的，此时该静态函数  无法访问  类内成员！\n// 因为需要取消 this 指针，所以需要设置成静态的static void* threadRoutine(void*args)&#123;       pthread_detach(pthread_self()); // 设置线程分离    ClientData* data=(ClientData*)args;    // 通过预先设置的 this 指针来访问类内成员，并进行传参    data-&gt;_this-&gt;transService(data-&gt;_fd,data-&gt;_ip,data-&gt;_port);    delete data;    return nullptr;&#125;\n\n3.3.4 服务代码  解决了上面的问题，就可以继续往下看看服务端的代码了\n// 提供服务pthread_t service;// 因为这个成员使用范围极小，所以采用 new/delete，避免占用太多空间ClientData* data = new ClientData(conet,senderPort,senderIP,this);pthread_create(&amp;service,nullptr,threadRoutine,(void*)data);\n\n在 accept 之后，通过线程操作用线程来提供服务\nstatic void* threadRoutine(void*args)&#123;       pthread_detach(pthread_self()); // 设置线程分离    ClientData* data=(ClientData*)args;    // 通过预先设置的 this 指针来访问类内成员，并进行传参    data-&gt;_this-&gt;transService(data-&gt;_fd,data-&gt;_ip,data-&gt;_port);    delete data;    return nullptr;&#125;\n\nthreadRoutine的作用就是把线程的单参数转为多参数，传给真正用来服务的函数。函数的操作很简单，就是 Linux 下文件操作的读写。\n读写成功后，将客户端发来的信息转成 ASCII 码的和发回给客户端\nvoid transService(int sockfd, const string &amp;clientIp, uint16_t clientPort)&#123;    assert(sockfd &gt;= 0);    assert(!clientIp.empty());    assert(clientPort&gt;0);    // 开始服务    char buf[BUFFER_SIZE];    while(1)    &#123;        // 读取客户端发来的信息,s 是读取到的字节数        ssize_t s = read(sockfd, buf, sizeof(buf)-1);        if(s&gt;0)        &#123;            buf[s]=&#x27;\\0&#x27;;// 手动添加字符串终止符            if(strcasecmp(buf,&quot;quit&quot;)==0)            &#123;// 客户端主动退出                break;            &#125;            // 服务            string tmp = buf;            int ret = str2ascii(tmp);// 获取字符串的 ascii 总和            cout &lt;&lt; ret &lt;&lt; endl;            string retS =  to_string(ret);// 转字符串            cout &lt;&lt; retS &lt;&lt; endl;            write(sockfd,retS.c_str(),retS.size());// 写入        &#125;        else if (s == 0)        &#123;//s == 0 代表对方关闭, 客户端退出            logging(DEBUG, &quot;client quit: %s[%d]&quot;, clientIp.c_str(), clientPort);            break;        &#125;        else        &#123;            logging(DEBUG, &quot;read err: %s[%d] -  %s&quot;, clientIp.c_str(), clientPort, strerror(errno));            continue;        &#125;    &#125;    close(sockfd);    logging(DEBUG,&quot;server quit %d&quot;,sockfd);&#125;private:    // 服务函数可以不暴露    int str2ascii(const string&amp; str)    &#123;        int ret = 0;        for(auto e:str)        &#123;            ret += e;        &#125;        return ret;    &#125;\n\n3.4 提供服务（子进程）上面的代码采用的是线程来提供服务，除了线程，我们还有父子进程的方式，也能避免阻塞\n需要注意的是，父子进程都需要关闭掉对方使用的文件描述符，避免出现文件描述符在服务结束后还没有关闭的情况\npid_t id = fork();if(id == 0)&#123;    close(_listenSock);// 因为子进程不需要监听，所以关闭掉监听 socket    // 子进程    transService(conet, senderIP, senderPort);    exit(0);// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收&#125;// 父进程close(conet); // 因为此时是子进程提供服务，conet 会有拷贝，相当于有两个进程打开了该文件// 如果父进程不关闭，即便子进程结束服务了，该文件描述符也会保持开启pid_t ret = waitpid(id, nullptr, 0);\n\n直接这样写有一个很大的问题，那就是父进程没有办法正常释放子进程的资源\n\n如果进行阻塞等待，那就违背了初衷，完全没有意义\n如果进行非阻塞等待，在 waitpid 结束之后，父进程直接去干其他事了，完全忘记了这里的这个子进程\n\n所以我们要做的，就是在子进程退出，向  父进程发送信号  的时候回收子进程\n3.4.1 信号回收子进程  通过自定义捕捉系统信号，来回收子进程\nsignal(SIGCHLD, FreeChild);// 自定义捕捉\n\n// 回收子进程void FreeChild(int signo)&#123;    assert(signo == SIGCHLD);    while (true)    &#123;        // 如果没有子进程了，waitpid 就会调用失败        pid_t id = waitpid(-1, nullptr, WNOHANG); // 非阻塞等待        if (id &gt; 0)        &#123;            cout &lt;&lt; &quot; 父进程等待成功, child pid: &quot; &lt;&lt; id &lt;&lt; endl;        &#125;        else if(id == 0)        &#123;            // 还有子进程没有退出            cout &lt;&lt; &quot; 尚有未退出的子进程，父进程继续运行 &quot; &lt;&lt; endl;            break;// 退出等待子进程        &#125;        else        &#123;            cout &lt;&lt; &quot; 父进程等待所有子进程结束 &quot; &lt;&lt; endl;            break;        &#125;    &#125;&#125;\n\n除了自定义捕捉，我们还可以设置成 ignore 不搭理子进程，这样子进程退出的时候就会被系统自动释放\nsignal(SIGCHLD, SIG_IGN);\n\n3.4.2 爷爷进程  这里还有另外一个骚操作，那就是在创建子进程之后，再创建一个子进程\n// 提供服务（孙子进程）-2pid_t id = fork();if(id == 0)&#123;    close(_listenSock);// 因为子进程不需要监听，所以关闭掉监听 socket    // 又创建一个子进程，大于 0 代表是父进程，即创建完子进程后父进程直接退出    if(fork()&gt;0)&#123;        exit(0);    &#125;    // 孙子进程执行    transService(conet, senderIP, senderPort);    exit(0);// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收&#125;// 爷爷进程close(conet); pid_t ret = waitpid(id, nullptr, 0); // 此时就可以直接用阻塞式等待了assert(ret &gt; 0);//ret 如果不大于 0，则代表等待发生了错误\n\n采用这种办法以后，由于父进程退出了，孙子进程会直接被操作系统接管。下图中能看到这些进程的父进程都是1，即操作系统。这时候我们也不需要担心子进程的释放问题了\n\n4. 客户端  客户端部分的代码和 udp 也很相似，只不过将 sendto 改成了 write\n下方提供了客户端的代码，都写了注释😁\n#include &quot;utils.h&quot;// ./clientTcp serverIp serverPortint main(int argc, char *argv[])&#123;    if (argc != 3)// 客户端必须要有 3 个参数    &#123;        cerr &lt;&lt; &quot;Usage:\\n\\t&quot; &lt;&lt; argv[0] &lt;&lt; &quot; serverIp serverPort&quot; &lt;&lt; endl;        cerr &lt;&lt; &quot;Example:\\n\\t&quot; &lt;&lt; argv[0] &lt;&lt; &quot; 127.0.0.1 8080\\n&quot;                &lt;&lt; endl;        exit(USAGE_ERR);    &#125;    // 解析服务端的 ip 和端口    string serverIp = argv[1];    uint16_t serverPort = atoi(argv[2]);    // 1. 创建 tcp 的 socket SOCK_STREAM    int sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock &lt; 0)    &#123;        cerr &lt;&lt; &quot;socket: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(SOCKET_ERR);    &#125;    // 2. connect，发起链接请求，你想谁发起请求呢？？当然是向服务器发起请求喽    // 2.1 先填充需要连接的远端主机的基本信息    struct sockaddr_in server;    memset(&amp;server, 0, sizeof(server));    server.sin_family = AF_INET;    server.sin_port = htons(serverPort);    inet_aton(serverIp.c_str(), &amp;server.sin_addr);    // 2.2 发起请求，connect 会自动 bind    if (connect(sock, (const struct sockaddr *)&amp;server, sizeof(server)) != 0)    &#123;        cerr &lt;&lt; &quot;connect: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(CONN_ERR);    &#125;    cout &lt;&lt; &quot;connect success: &quot; &lt;&lt; sock &lt;&lt; endl;    // 客户端发现的消息    string message;    while (1)    &#123;        message.clear();// 每次循环开始，都清空一下 msg        cout &lt;&lt; &quot; 请输入你的消息# &quot;;        getline(cin, message);// 获取输入        // 如果客户端输入了 quit，则退出        if (strcasecmp(message.c_str(), &quot;quit&quot;) == 0)            break;        // 向服务端发送消息        ssize_t s = write(sock, message.c_str(), message.size());        if (s &gt; 0) // 写入成功        &#123;            message.clear();// 清空输入的消息            message.resize(BUFFER_SIZE);            // 因为 string 的 c_str 本质上是返回地址，所以强转后是可以往里面写入的            s = read(sock, (char *)(message.c_str()), BUFFER_SIZE);// 获取服务端的结果            if (s &gt; 0)// 读取成功            &#123;                message[s] = &#x27;\\0&#x27;;// 追加 \\0            &#125;            // 打印返回值            cout &lt;&lt; &quot;Server Echo# &quot; &lt;&lt; message &lt;&lt; endl;        &#125;        else if (s &lt;= 0) // 写入失败        &#123;            break;        &#125;    &#125;    // 关闭文件描述符    close(sock);    return 0;&#125;\n\n4.1 运行测试  先运行服务端，再运行客户端，客户端输入后，服务短会返回字符串的 ascii 码总和\n\n而客户端输入 quit 后，在服务端可以看到客户端退出，但服务端并没有推出，正在等待下一个连接\n\n5. 线程池  在上面的操作中，每次提供服务都需要当场新建一个线程。对于 tcp 这种要求高性能的网络服务器而言，其实是不太合适的。理论上来说，我们希望越早给客户建立联系越好，而不是食客都来了老板才去买菜。\n这时候，就可以把我们写的  线程池  和 tcp 服务器给联系起来！\n\n线程池的代码见我的gitee，此处只说明 task 类的编写\n\n5.1 task先前编写线程池的时候，将线程池要处理的任务写成了一个 task 类，并规定所有 task 类都需要提供一个 () 操作符重载，即仿函数。这样线程池就可以一视同仁的处理这些工作，我们只需要将新增的工作添加到线程池的任务队列里面\nclass Task&#123;    using callback_t = std::function&lt;void (int, std::string, uint16_t)&gt;;// 相当于 typedefpublic:    Task() = default;    // 将需要调用的函数传入，相当于通用    Task(int sockfd, const std::string &amp;clientIP, uint16_t clientPort,callback_t func)        : _sockfd(sockfd), _ip(clientIP), _port(clientPort),_func(func)    &#123;    &#125;    // 仿函数    void operator()()    &#123;        logging(DEBUG, &quot;TID[%p] = %s:%d START&quot;,\\            pthread_self(), _ip.c_str(), _port);        _func(_sockfd, _ip, _port);        logging(DEBUG, &quot;TID[%p] = %s:%d END  &quot;,\\            pthread_self(), _ip.c_str(), _port);    &#125;private:    int _sockfd;    std::string _ip;    uint16_t _port;    callback_t _func;&#125;;\n\n这里，我又将 task 队列给封装成了一个可以接收函数指针的方式。这样一来，只要我们任务的函数参数为(SOCKET,IP,PROT)，就能传入给这个 task 类，让线程池来运行\n5.2 tcpServer 的处理  因为需要线程池，我们在 tcpserver 中添加一个线程池的指针，通过线程池的类名来获取单例，赋值给成员变量。并让获取到的单例线程池开始运行\n// 4. 获取线程池 单例_tpool = ThreadPool&lt;Task&gt;::getInstance(4);_tpool-&gt;start();// 开始运行\n\n在 start 函数中，则将之前的任务函数实例化为一个 task，并将其 push 到线程池的任务队列中\n// 提供服务（通过线程池）Task t(conet,senderIP,senderPort,transService);_tpool-&gt;push(t);\n\n这样，就能通过线程池来提供服务了！\n5.3 运行测试  可以看到，我们的线程池正确运行了任务，给客户端提供了 ascii 返回值\n\n使用 ps -aL 命令查看轻量级进程，可以看到有 4 个线程在为我们服务\n PID   LWP TTY          TIME CMD7288  7288 pts/8    00:00:00 tcpServer7288  7289 pts/8    00:00:00 handler7288  7290 pts/8    00:00:00 handler7288  7291 pts/8    00:00:00 handler7288  7292 pts/8    00:00:00 handler7441  7441 pts/9    00:00:00 tcpClient7632  7632 pts/7    00:00:00 ps\n\n此时，即便我们多开几个终端，tcp 服务器也能正常提供服务\n\n但是！如果出现了一个尴尬的情况，线程池中的线程 &lt; 当前需要连接的客户端数量，会发生什么呢？\n5.4 task 等待问题  为了测试，我们将线程池单例中的线程个数初始化为 2 个\n\n此时，我们发现第三个客户端会进入阻塞状态，但实际上它已经成功链接上了服务器，task 也被插入到了任务队列里面，只不过当前没有空闲的线程来运行它\n\n如果我们把左侧其中一个客户端退出，最右侧的客户端就能正常收到服务器返回的结果了\n\n要解决这个问题，我们就需要让线程池有能力判断是否出现了阻塞问题，并扩容线程来解决阻塞。\n可是这又引出了另外一个问题：如果空闲了很久都没有任务过来，多出来的线程不就是在白白消耗资源吗？\n实际上，线程池适合处理的，应该是  短小的任务 ，而不是一个while(1) 循环；\n\n但是我还没有学习到如何将其修改为服务于短小任务的线程池，仍待后续的精进\n\n","categories":["玩上Linux"],"tags":["Linux","线程","网络"]},{"title":"【Linux】实现守护进程 | 以 tcpServer 为例","url":"/posts/2887088349/","content":"本文将以 tcp 服务器代码为基本，讲述如何将进程守护进程化，后台运行\n\n\n1. 守护进程  所谓守护进程，就是和其他进程没有关系的进程；其独立运行于系统后台，除非自己退出或收到信号终止，否则会一直运行下去\n1.1 进程组  在我们使用的 bash 中，同一时刻只会有一个  前台进程组\n\n如图，当一个前台进程开始运行之后，我们没有办法在当前终端开启  第二个前台进程。\n在运行的命令后面加 &amp;，临时让当前进程  在后台运行 。注意，此时 tcp 虽然在后台运行了， 但对于它而言，stdin/stdout/stderr 的文件描述符依旧指向的是当前 bash 的输入输出，所以它的日志依旧会打印到当前终端上。\n用 ps 命令查看当前进程的信息，其中 ppid 是当前进程的父进程，也就是当前 bash，pid是进程编号，pgid是进程的组编号，可以看到这个组编号和 grep 命令的组编号是不同的。\n\n我们用这个 c 语言的代码调用两次 fork，相当于创建了 3 个子进程。\n#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123;    fork();    fork();    sleep(100);    return 0;&#125;\n\n此时再来查看进程信息，能看到这 4 个进程的进程组 pgid 是相同的，而且和  第一个 test 的 pid 相同 ；这说明第一个 test 就是 父进程，后面的 3 个都是子进程。\n\n1.2 进程会话  这里还有一个我们之前没有太多了解的信息，进程的 sid 是什么？\n还是上面的例子，在图中能看到，我们执行的 test 和 grep 的 sid 都是相同的，而且都等于第一个 test 进程的 ppid（bash 的 pid）\n\n这表明图中的 5 个进程同属于一个进程会话，这个会话就是我们当前打开的 bash，并用 sid 来表示进程会话；\n\n这也是为什么我们登录 linux 的时候一定会有一个终端，linux 系统就是创建会话并加载 bash，来给用户提供服务的。\n\n既然存在会话，那就肯定会有会话的资源上限。一旦满了，就会开始杀掉一些进程。\n./test &amp;\n\n即便我们用 &amp; 让进程在后台运行，其也有可能收到会话的  创建 / 关闭  的影响而被操作系统干掉🧐比如我们将  当前正在运行进程的 bash 关掉，其前台进程会被直接终止，后台进程也会受到影响（有可能终止有可能不终止，取决于系统）\n这和我们对 tcp 服务器的需求不一致：我们需要的是让 tcp 服务器的进程能一直稳定的在后台运行，让操作系统别去管它；除非系统内存满了，负载重到实在没有办法的时候，操作系统才能过来把他刀了。\n为了不让守护进程受到进程会话的影响，我们就必须让其能够独立出来，自成一个进程组和一个新会话\n👆这种独立的进程，就可以被称为  守护进程 / 精灵进程\n2. 实现 2.1 自己写 别以为写这个很难哦，实际特别简单！\n2.1.1 setsid这里需要用到的 setsid 接口，其作用如名字一般，是设置当前进程的进程会话组\n#include &lt;unistd.h&gt;pid_t setsid(void);\n\n但是调用这个函数有一个要求：调用的进程不能是进程组的组长！\n比如下图中，第一个 test 就是进程组的组长，它不能调用这个函数。会报错\n\n那要怎么让自己不成为进程组的组长呢？很简单，创建一个子进程就 ok 了！\nif (fork() &gt; 0)    exit(0);// 父进程直接退出\n\n2.1.2 重定向到 dev&#x2F;null\n如果你不知道什么是/dev/null，简而言之，这是一个 linux 下的数据垃圾桶。和 windows 的回收站会存放删除的资料不同，这个垃圾桶是个黑洞，丢进去的东西不会被存放，是直接丢弃的！\n\n守护进程需要把默认的 0.1.2 文件描述符都重定向到dev/null，是因为设置成独立的进程组和进程会话了之后，当前进程是没有和 bash 关联的。\n此时，默认这个 0 1 2 所指向的 bash 是  无效  的！如果不重定向，使用 cout 打印的时候，就会引发异常（可以理解为往一个不存在的文件中写内容），服务器直接退出了，无法实现守护进程。\n重定向了之后，所有的打印输出都会被丢到 /dev/null 这个文件垃圾桶中，也就不需要担心上述的问题。\nif ((fd = open(&quot;/dev/null&quot;, O_RDWR)) != -1) // fd == 3&#123;    dup2(fd, STDIN_FILENO);    dup2(fd, STDOUT_FILENO);    dup2(fd, STDERR_FILENO);    // 6. 关闭掉不需要的 fd    // 因为 fd 只是临时用于重定向，操作完毕了就可以关掉了    if(fd &gt; STDERR_FILENO)         close(fd);&#125;\n\n你可能会疑惑，那日志信息也被丢到垃圾桶里面了，怎么办？\n很简单，因为我们服务器的日志都统一使用了 log.hpp 里面的 logging 函数，所以只需要对 logging 函数的输出重定向到日志文件里面，就 ok 了！\n2.1.3 chdir（选做）这个操作的目的是修改工作路径。作为服务器进程，很多日志信息是存放在 /etc/ 目录而不是当前路径下的，为了安全，也应该使用  绝对路径  而不用相对路径，避免出现工作目录切换而导致的无法读写文件的问题\n不过，如果使用绝对路径，即便我们不修改工作目录，也是能正常访问的；所以这个操作是选做的\n2.1.4 信号捕捉  自己写这个函数有个好处，那就是我们可以在里面自定义捕捉一些信号，给这些信号 加上自己的自定义方法；\n比如 SIGPIPE 就是管道的信号，当管道的读端关闭的时候，写端会被终止；此时写端就会收到这个信号。如果不对这个信号进行 SIG_IGN 忽略，我们的服务器会直接终止！\nsignal(SIGPIPE, SIG_IGN);\n\n除了这个信号，我们还可以对 2 号或者 3 号信号进行自定义捕捉，设定退出信号，让服务器能够  安全退出（保存日志信息到磁盘，释放资源等；虽然进程退出之后操作系统会帮我们干这些事，但我们这么写能让项目更规范）\n2.1.5 完整代码#pragma once#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; // O_RDWR 需要void daemonize()&#123;    int fd = 0;    // 1. 忽略 SIGPIPE (管道读写，读端关闭，写端会收到信号终止)    signal(SIGPIPE, SIG_IGN);    // 2. 更改进程的工作目录    // chdir(); // 可以改，可以不改    // 3. 让自己不要成为进程组组长    if (fork() &gt; 0)        exit(0);    // 4. 设置自己是一个独立的会话    setsid();    // 5. 重定向 0,1,2    if ((fd = open(&quot;/dev/null&quot;, O_RDWR)) != -1) // fd == 3    &#123;        dup2(fd, STDIN_FILENO);        dup2(fd, STDOUT_FILENO);        dup2(fd, STDERR_FILENO);        // 6. 关闭掉不需要的 fd        // 因为 fd 只是临时用于重定向，操作完毕了就可以关掉了        if(fd &gt; STDERR_FILENO)             close(fd);    &#125;    // 这里还有另外一种操作，就是把 stdin/stdout/stderr 给 close 了    // 但是这样会导致只要有打印输出的代码，进程会就异常退出&#125;\n\n没错，就这一点点代码，就能让我们的 tcp 服务器变成守护进程！\n\n此时我们的客户端依旧能正常连接服务端，获取结果\n\n2.2 nohupno hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。用 nohup 命令执行一个进程，就能让这个进程成为不受终端退出影响的进程\nnohup ./test &amp;\n\n此时，nohup 会在当前目录下创建一个 nohup.out 文件，用于记录 test 进程的输出信息（如果通过了 &gt; 或&gt;&gt;执行了重定向，则不会创建）\n\n通过 ps 可已看到，当前 test 进程的  进程会话  还是和 bash 相同，但我们关闭当前 bash，这个 test 进程依旧能正常运行，只不过父进程会变成操作系统1，我们的目的也算是达到了\n\n2.3 deamon 接口linux 系统中有一个接口daemon，可以帮我们实现守护进程\n#include &lt;unistd.h&gt;int daemon(int nochdir, int noclose);\n\n了解过守护进程的写法了之后，这两个参数的作用就很明显了\n\n第一个参数 nochdir 表明是否需要修改工作目录；如果设置为 0，则切换工作目录到 / 系统根目录\n第二个参数 noclose 表明是否需要重定向基础 io 到/dev/null；设置为 0 则重定向\n\n以下是 man 手册中的说明\nIf nochdir is zero, daemon() changes the calling process&#x27;s current working directory to the root directory (&quot;/&quot;); otherwise, the  cur‐rent working directory is left unchanged.If noclose is zero, daemon() redirects standard input, standard output and standard error to /dev/null; otherwise, no changes are madeto these file descriptors.\n\n我们直接用一个简单代码来演示\n#include &lt;unistd.h&gt;int main()&#123;    // 不需要修改工作目录，第一个参数设为 1    // 因为没有进行打印，重定向设置成 1，不进行重定向    int ret = daemon(1,1);    sleep(100);    return 0;&#125;\n\n运行之后可以看到，这个进程的父 id 是操作系统，其自成一个进程组和进程会话；和我们自己写的函数作用相同\n\n3. 重定向 log因为守护进程把输入输出丢到了垃圾捅里面，所以我们就需要重定向日志的输出\n#define LOG_PATH &quot;./log.txt&quot; // 工作路径下的 log.txt// 这个类只用于重定向，不需要在里面加其他东西class Logdup&#123;public:    Logdup()        :_fdout(-1),_fderr(-1)    &#123;&#125;    Logdup(const char* pout=LOG_PATH,const char* perr=&quot;&quot;)        :_fdout(-1),_fderr(-1)    &#123;        // 如果只传入了第一个 pout，则代表将 perr 和 pout 重定向为一个路径        umask(0);        int logfd = open(pout, O_WRONLY | O_CREAT | O_APPEND, 0666);        assert(logfd != -1);        _fdout = _fderr = logfd;// 赋值可以连等        // 判断是不是空串        if(strcmp(perr,&quot;&quot;)!=0)// 不相同，代表单独设置了 err 的路径        &#123;            logfd = open(perr, O_WRONLY | O_CREAT | O_APPEND, 0666);            assert(logfd != -1);            _fderr = logfd;        &#125;        dup2(_fdout, 1);// 重定向 stdout        dup2(_fderr, 2);// 重定向 stderr    &#125;    ~Logdup()    &#123;        if(_fdout!= -1)        &#123;            fsync(_fdout);            fsync(_fderr);            // 先写盘再关闭            close(_fdout);            close(_fderr);        &#125;    &#125;private:    int _fdout;// 重定向的日志文件描述符    int _fderr;// 重定向的错误文件描述符&#125;;c\n\n做完这一切之后，我们运行服务器，的确创建了 log.txt 文件，可里面空空如也\n\n这是因为我们的数据其实都被写道了缓冲区里面，我们需要在 logging 里面添加一个刷新机制，才能让数据尽快写入到硬盘中，避免日志丢失\nfflush(out); // 将 C 缓冲区中的数据刷新到 OSfsync(fileno(out));// 将 OS 中的数据写入硬盘\n\n此时再运行服务器，就能看到日志很快被写入文件里面了。\n\nover搞定啦！\n","categories":["玩上Linux"],"tags":["Linux","网络"]},{"title":"【Linux】来写一个 udp 的服务端 + 客户端","url":"/posts/368672249/","content":"来写一个 udp 的代码\n\n\n1.socket 编程接口#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)int socket(int domain, int type, int protocol);// 绑定端口号 (TCP/UDP, 服务器)      int bind(int socket, const struct sockaddr *address,         socklen_t address_len);// 开始监听 socket (TCP, 服务器)int listen(int socket, int backlog);// 接收请求 (TCP, 服务器)int accept(int socket, struct sockaddr* address,         socklen_t* address_len);// 建立连接 (TCP, 客户端)int connect(int sockfd, const struct sockaddr *addr,         socklen_t addrlen);\n\nlinux 下一切皆文件，socket 接口也不例外。其返回值本质上就是一个 fd 文件描述符，这样我们对网络的发送 &#x2F; 接收操作，就转换成了对文件的写入 &#x2F; 读取操作了\n在这里面有一个比较重要的结构 sockaddr 需要说明一番\n1.1 sockaddrsocket 是一层抽象的网络编程接口，适用于各种底层网络协议，如 IPv4&#x2F;IPv6。同时，这个接口还可以用于系统内部的通信。这就实现了用一个接口来干两件事。\n为此，就必须要在传值中进行一些修改。该接口新增了一个 sockaddr，用来接收目标信息。这个值的参数可以是sockaddr_in/scokaddr_un/sockadd_in6 之中的任意一个（需要强转指针）\nsockaddr本身不存放任何信息。\n这个参数可接收的结构体中，固定前 16 位就是用于标识符的。传到处理函数中，就会判断前 16 位中的标识符的类型，以确定传入参数的类型，再执行不同的实现\n\n比如传入的 scokaddr_un，前 16 位是AF_UNIX，那么当前使用的就是 本地通信\nsockaddr_in是 ipv4 通信，sockaddr_in6是 ipv6 通信\n\n\n你可能会有疑惑，既然 sockaddr 不存放信息，那为何不把这个参数设置为一个 void* 的指针？反正最后都是进了函数之后判断参数类型，void*指针也能达成目标呀🧐\n这个问题的答案很简单：当初设计这套接口的时候，C 语言还不支持void*😂\n\n1.2 存放位置  因为 sockaddr_in 这类的结构体，最终都需要被操作系统载入并实现网络操作。所以它们肯定是需要载入内核中的\n但这并不意味着这类结构体是存放在内核里面的，而是存放在  用户栈，用户态和内核态交换的时候，通过接口传值载入到内核的空间进行使用\n2.server了解了上面的信息，接下来，认识一下如果想建立一个udpserver，需要怎么操作吧！\n以下是一个 server 的类，包含了端口、ip、socker fd 三个基本信息\nclass UdpServer&#123;public:    UdpServer(uint16_t port,const string&amp; ip=&quot;&quot;)     : _port((uint16_t)port), _ip(ip), _sockfd(-1)    &#123;&#125;private:    // 服务器端口号    uint16_t _port;    // 服务器 ip 地址    string _ip;    // 服务器 socket fd 信息    int _sockfd;&#125;;\n\n2.1 创建套接字  这里需要用的是下面这个接口\nint socket(int domain, int type, int protocol);\n\n\n第一个参数 domain 标识该 socker 的作用域\n\n可以设置为本地，也可以设置为网络。支持如下参数\nName                Purpose                          Man pageAF_UNIX, AF_LOCAL   Local communication              unix(7)AF_INET             IPv4 Internet protocols          ip(7)AF_INET6            IPv6 Internet protocols          ipv6(7)AF_IPX              IPX - Novell protocolsAF_NETLINK          Kernel user interface device     netlink(7)AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)AF_AX25             Amateur radio AX.25 protocolAF_ATMPVC           Access to raw ATM PVCsAF_APPLETALK        Appletalk                        ddp(7)AF_PACKET           Low level packet interface       packet(7)\n\n因为我们要创建的是一个网络服务器，所以这里设置为AF_INET，也就是 IPV4 的服务\n\n第二个参数 type 指代套接字的类型，决定了通信时的报文类型\n\n这里支持流式（TCP）或者用户数据报（UDP），以及 RAW 原始格式（能够直接访问协议，方便 debug）\nSOCK_STREAM   Provides sequenced, reliable, two-way, connection-based byte streams. An out-of-band data  transmission  mechanism  may  be supported.SOCK_DGRAM    Supports datagrams (connectionless, unreliable messages of a fixed maximum length). SOCK_RAW        Provides raw network protocol access.\n\n更多支持的参数参考 man 手册\n\n第三个参数指代协议，在网络应用中，设置为 0 即可\n\n返回值是一个 linux 系统的  文件描述符\nRETURN VALUE       On success, a file descriptor for the new socket is returned.  On error, -1 is returned, and errno is set appropriately.\n\n\n这样，我们就能写出第一行代码，以及对这个代码的返回值判断\n_sockfd = socket(AF_INET, SOCK_DGRAM, 0);if (_sockfd &lt; 0)&#123;    logging(FATAL, &quot;socket:%s:%d&quot;, strerror(errno), _sockfd);    exit(1);&#125;\n\n因为 socket 是文件描述符，为了规范，我们还可以在析构函数里面调用一下close\n~UdpServer()&#123;    close(_sockfd);&#125;\n\n2.2 配置 sockaddr_in// 2. 绑定网络信息，指明 ip+portstruct sockaddr_in local;memset(&amp;local,0,sizeof(local));// 配置为 0\n\n因为用的是 ipv4 的网络通信，所以这里需要初始化一个 sockaddr_in 类型\n此时在 vscode 的代码补全中，可以看到 4 个成员，需要对它们赋值以配置服务器信息\n\n首先是把协议家族设置为IPV4，端口配置为函数参数中的端口\n// 协议家族，设置为 ipv4local.sin_family = AF_INET; // 端口，需要进行 本地 -&gt; 网络转换local.sin_port = htons(_port);\n\n随后配置 ip\n// 如果初始化时候的 ip 为空，则调用 INADDR_ANY 代表任意 ip。否则对传入的 ip 进行转换后赋值local.sin_addr.s_addr = _ip.empty() ? htonl(INADDR_ANY) : inet_addr(ip_.c_str());\n\n这里采用了 ?: 三目操作符，如果类构造的时候传入的 ip 是空（没有配置 ip）那就直接设置为任意 ip，否则传入成员变量；\n这样对 sockaddr_in 的配置就完成了。\n2.2.1 inet_addr这里需要使用 inet_addr 函数对传入的字符串类型的 ip（如192.168.0.1）进行转换\nin_addr_t inet_addr(const char *cp);// 对字符串 ip 进行转换\n\n因为对于网络来说，它并不认识字符串类型的 ip，而是要用网络字节流规定的类型。\n/* Internet address.  */typedef uint32_t in_addr_t;struct in_addr  &#123;    in_addr_t s_addr;  &#125;;\n\n对于该接口的底层做一个简单的说明：其实就是利用  位段，将数据转换为一个特殊的类型\n// 示例，非底层实现struct ip&#123;    uint32_t part1:8;    uint32_t part2:8;    uint32_t part3:8;    uint32_t part4:8;&#125;\n\n2.2.2 inet_ntoa同样的，如果我们作为客户端接受到了网络请求中的 ip，可以用 inet_ntoa 将其转换为字符串类型。\nchar *inet_ntoa(struct in_addr in);\n\n这里就引申出了一个问题：返回值的 char* 是存在哪里的？是静态区还是malloc？\n\nThe inet_ntoa() function converts the Internet host address in, given in network byte order, to a string in IPv4 dotted-decimal notation.  The string  is returned in a statically allocated buffer, which subsequent calls will overwrite.\n\n手册告诉我们，这个函数是维护了一个 static 变量来存放返回的 ip 的。\n因此，该函数并  不是一个线程安全  的函数，在 APUE 中明确标明了这一点；后续的调用会覆盖掉这个 IP 地址；\n2023.09.15 的面试问道了这个问题，感兴趣的可以看看我的  面经  里面的题目和解释，这里把题目贴出来；如下的函数调用会不会有什么问题？\nprintf(&quot;%s %s\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));\n\n说结论：对于 inet_aton 函数而言，正确的调用  办法是每次调用后都立即取走返回的 IP 地址字符串，可以用 std::string 接收，也可以用 strcmp 拷贝到一个自己定义的字符串数组变量中；\n具体的介绍请移步  面经  哦！\n\n2.3 bind 绑定 ip 端口#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr,         socklen_t addrlen);\n\n这个接口的作用就是指定 socket 和 sockaddr 进行绑定。第三个参数是 addr 元素的大小（不是指针大小，别搞错了）\n// 2.2 绑定 ip 端口if (bind(_sockfd,(const struct sockaddr *)&amp;local, sizeof(local)) == -1)&#123;    logging(FATAL, &quot;bind: %s:%d&quot;, strerror(errno), _sockfd);    exit(2);&#125;logging(DEBUG,&quot;socket bind success: %d&quot;, _sockfd);\n\n绑定了之后，我们的服务器就配置成功了\n测试一下，可以看到编译没有报错，也能正常运行！\n[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ make udpServerg++ -o udpServer udpServer.cpp -std=c++11[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ ./udpServerDEBUG | 1675326460 | muxue | socket create success: 3DEBUG | 1675326460 | muxue | socket bind success: 3\n\n在使用 UDP 进行通信的时候，我们不一定需要绑定具体的 IP 地址，可以用 INADR_ANY 来代替具体的本机 IP 地址，但是  端口号一定要进行绑定。（不然系统没办法让你的进程和某个端口关联来接收信息）\n2.3.1 main现在先来简单写一下 main 函数中启动服务的命令行参数吧\nint main(int argc,char* argv[])&#123;    // 参数只有两个（端口 /ip）所以参数个数应该是 2-3    if(argc!=2 &amp;&amp; argc!=3)    &#123;        cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; port [ip]&quot; &lt;&lt; endl;        return 1;    &#125;        string ip;    // 3 个参数，有 ip    if(argc==3)    &#123;        ip = argv[2];    &#125;    UdpServer s(atoi(argv[1]),ip);    s.start();    return 0;&#125;\n\n为了测试，先把 start() 函数设置为一个死循环\nvoid start()&#123;    while(1)    &#123;        cout &lt;&lt; &quot;running &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;&#125;\n\n编译运行，可以看到错误提示是可以用的。正确添加参数之后，也能绑定并开始运行\n[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ make udpServerg++ -o udpServer udpServer.cpp -std=c++11[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ ./udpServerUsage: ./udpServer port [ip][muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ ./udpServer 8080DEBUG | 1675327610 | muxue | socket create success: 3DEBUG | 1675327610 | muxue | socket bind success: 3running 4467running 4467running 4467^C\n\n注意，bind这个函数是  不允许你绑定云服务器的公网 ip 的。因为云服务器并不是直接暴露在公网上的，而是由提供商的入口服务器进入内网，在进入你的服务器。所以他不允许你绑定公网 ip；\n$ ./udpServer 8080 云服务器公网 ipDEBUG | 1675327690 | muxue | socket create success: 3FATAL | 1675327690 | muxue | bind: Cannot assign requested address:3\n\n一般情况下，可以选择不绑定 ip，或者绑定本地端口127.0.0.1\n\n如果绑定了127.0.0.1，那么服务只有本地可以访问。不绑定端口，就会默认绑定成0.0.0.0，允许本地和远程端口连接\n\n$ ./udpServer 8080 127.0.0.1DEBUG | 1675327757 | muxue | socket create success: 3DEBUG | 1675327757 | muxue | socket bind success: 3running 5067running 5067\n\n2.3.2 netstat可以用 netstat -lnup 命令查看当前开放的端口信息\n\n可以看到，第一行就是我们的 udp 服务器，本地端口是我们绑定的127.0.0.1:8080，远程端口是0.0.0.0:*，代表允许任何远程 ip 的任何端口来访问\n2.4 开始运行  上面的操作只是初始化了这个 udp 服务器的信息，并没有让它真正的运行起来；\n接下来要做的就是让服务器开始接收信息，并在屏幕上打印出来\n2.4.1 recvfrom这个接口的作用是来接收信息\n#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,                 struct sockaddr *src_addr, socklen_t *addrlen);\n\n\n第一个参数是前面创建的套接字\n第二个参数是用来接收信息的缓冲区\n第三个参数是缓冲区的大小\n第四个参数是标识符，设置为 0，代表  阻塞等待\n第五个参数，输出型参数，获取发送方的信息\n第六个参数，输入输出型参数，需要初始化为sizeof(src_addr)\n\n函数的返回值是接收到的数据的长度，没有接收到或者接受失败，则为-1\n示例如下\nchar inBuf[BUF_SIZE];struct sockaddr_in peer;      // 输出型参数 socklen_t len = sizeof(peer); // 输入输出型参数// peer 和 len 都是输出型参数，用于获取发送方的信息// len 是输入输出型参数，需要以 sizeof(peer) 初始化后传入// 第三个参数 0 为默认等待方式（阻塞等待）ssize_t s = recvfrom(_sockfd, inBuf, sizeof(inBuf)-1,0,(struct sockaddr *)&amp;peer, &amp;len);if (s &gt; 0) // s 代表获取到的数据长度，不为 0 代表成功获取&#123;    inBuf[s] = &#x27;\\0&#x27;; // 末尾追加 &#x27;\\0&#x27;&#125;else if (s == -1) // -1 没有收到信息，错误&#123;    logging(WARINING, &quot;recvfrom: %s:%d&quot;, strerror(errno), _sockfd);    continue;&#125;\n\n这样就能在 inBuf 中直接获取到发送信息的内容\n2.5 服务端 start以下是服务端运行的完整代码\nvoid start()&#123;    char inBuf[BUF_SIZE];// 接收到信息的缓冲区     while(1)    &#123;        struct sockaddr_in peer;      // 输出型参数        socklen_t len = sizeof(peer); // 输入输出型参数        // peer 和 len 都是输出型参数，用于获取发送方的信息        // len 是输入输出型参数，需要以 sizeof(peer) 初始化后传入        // 第三个参数 0 为默认等待方式（阻塞等待）        ssize_t s = recvfrom(_sockfd, inBuf, sizeof(inBuf)-1,0,(struct sockaddr *)&amp;peer, &amp;len);        if (s &gt; 0) // s 代表获取到的数据长度，不为 0 代表成功获取        &#123;            inBuf[s] = &#x27;\\0&#x27;; // 末尾追加 &#x27;\\0&#x27;        &#125;        else if (s == -1) // -1 没有收到信息，错误        &#123;            logging(WARINING, &quot;recvfrom: %s:%d&quot;, strerror(errno), _sockfd);            continue;        &#125;        string senderIP = inet_ntoa(peer.sin_addr);// 来源 ip        uint16_t senderPort = ntohs(peer.sin_port); // 来源端口        logging(NOTICE, &quot;[%s:%d]# %s&quot;, senderIP.c_str(),senderPort, inBuf);// 打印信息    &#125;&#125;\n\n如果你想让另外一台主机访问这个服务，则需要在  云服务器控制台和 linux 系统  中同时开放对应的 udp 端口\n\n参考 【Linux】设置系统防火墙\n\n3.client有了服务端，也要有对应的客户端来发送消息；除了发送消息的部分，其余操作和服务端基本一致。\n3.1 sendto#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,               const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);\n\n这里我们要用的是 sendto 接口\n\n第一个参数是 socket 套接字\n第二个参数是用于输入的缓冲区\n第三个参数是缓冲区的类型\n第四个参数是标识符，也设置为 0\n第五个参数和第六个参数与 recvfrom 一致，为目标服务器的信息\n\n关于 flag 参数，man 手册中有更多选项，这里我们依旧传入 0 采用默认策略\nThe flags argument is the bitwise OR of zero or more of the following flags.\n\n3.2 客户端需不需要手动 bind?首先我们要明确一点，bind 函数并没有规定一定要是服务端才能使用。也就是说，要不要使用 bind 是程序猿自己的选择。\n答案其实很简单：那就是不需要手动 bind\n首先我们要知道一点：如果一个网络进程在启动的时候没有手动 bind 端口，系统是会自动分配一个未使用的端口给它的\n\n对于服务器来说，IP: 端口  必须固定，否则没有办法给客户端提供稳定的服务。客户又不能拆了你的应用程序修改源码中的端口！\n而对于客户端来说，端口应该让系统自动分配。因为这样能避免冲突问题。不然如果有另外一个应用占用了客户端 bind 的端口，那这个程序就会因为  端口冲突  而一直打不开！\n\n所以，客户端不需要我们调用 bind 函数，只需要配置好服务端的目标 ip 和目标端口就行了\n3.3 代码示例#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cassert&gt;#include &lt;unistd.h&gt;#include &lt;strings.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;using namespace std;struct sockaddr_in server;// ./udpClient server_ip server_port// 客户端要连接 server，必须知道 server 对应的 ip 和 portint main(int argc, char *argv[])&#123;    if (argc != 3)    &#123;        cout &lt;&lt; &quot;Usage:\\n\\t&quot; &lt;&lt; argv[0] &lt;&lt; &quot; server_ip server_port&quot; &lt;&lt; endl;        return 1;    &#125;    // 1. 根据命令行，设置要访问的服务器 IP    string server_ip = argv[1];    uint16_t server_port = atoi(argv[2]);    // 2. 创建客户端    // 2.1 创建 socket    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);    if(sockfd&lt;0)    &#123;        cout &lt;&lt; &quot;socket 创建失败 &quot; &lt;&lt; endl;        return 2;    &#125;    bzero(&amp;server, sizeof(server));// 这个函数相当于 memset 全 0    server.sin_family = AF_INET;//ipv4    server.sin_port = htons(server_port);// 目标服务器端口    server.sin_addr.s_addr = inet_addr(server_ip.c_str());// 目标 ip    // 3. 通讯过程    string buffer;    while (true)    &#123;        cerr &lt;&lt; &quot;Please Enter# &quot;;        getline(cin, buffer);        // 发送消息给 server        sendto(sockfd, buffer.c_str(), buffer.size(), 0,               (const struct sockaddr *)&amp;server, sizeof(server));         // 首次调用 sendto 函数的时候，client 会自动 bind 自己的 ip 和 port        // 客户端不应该自己绑定端口，否则端口被占用 = 客户端不能用    &#125;    close(sockfd);    return 0;&#125;\n\n3.4 运行测试  这里提供一个 makefile，来快速编译服务端 &#x2F; 客户端的源码\n.PHONY:allall:udpClient udpServerudpClient: udpClient.cpp\tg++ -o $@ $^ -std=c++11 -lpthreadudpServer:udpServer.cpp\tg++ -o $@ $^ -std=c++11.PHONY:cleanclean:\trm -f udpClient udpServer\n\n运行服务器，指定 8080 端口启动。再运行客户端，指定 127.0.0.1 本地 ip 和 8080 端口\n\n可以看到，右侧我们收到的信息，都在左侧被打印了出来，同时显示了来源 ip 和端口\n3.5 windows 客户端  让我没想到的是，windows 上网络的接口和 linux 很相似；这里提供一个 windows 下的 udp 客户端，向我们的云服务器发送信息\n注：进行测试前，一定要在防火墙里面开放云服务器对应的 udp 端口\n#define _WINSOCK_DEPRECATED_NO_WARNINGS 1// 屏蔽报错#include&lt;winsock2.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;#pragma comment(lib,&quot;ws2_32.lib&quot;)#define BUFFER_SIZE  1024    // 缓冲区大小int main() &#123;    WSADATA WSAData;    // 初始化    if (WSAStartup(MAKEWORD(2, 2), &amp;WSAData) != 0)     &#123;        printf(&quot; 初始化失败!&quot;);        return -1;    &#125;        // 创建客户端用于通信的 Socket    SOCKET sock_Client = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    // 服务器的地址数据结构    SOCKADDR_IN addr_server;       addr_server.sin_family = AF_INET;    addr_server.sin_port = htons(10000);// 目标端口    addr_server.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); // 目标公网 ip(需要改成你自己的)    string sendBuf;    while (true)     &#123;        cout &lt;&lt; &quot; 请输入要传送的数据: &quot;;        getline(cin,sendBuf);        sendto(sock_Client, sendBuf.c_str(),sendBuf.size(), 0, (const SOCKADDR*)&amp;addr_server, sizeof(addr_server));        cout &lt;&lt; sendBuf.size() &lt;&lt; &quot;: &quot; &lt;&lt; sendBuf &lt;&lt; endl;    &#125;    closesocket(sock_Client);    WSACleanup();    return 0;&#125;\n\n测试一下，可以看到云服务器成功收到了信息，但因为 windows 和 linux 的文字编码问题，没能正确显示出中文\n\n发送英文信息是没有问题的！\n\n4. 更进一步 4.1 记录用户 有用户给你发送信息，理论上来说，服务端应该记录下用户，以备 debug;\n这部分并不难，我们记录下用户的 ip 和端口，还有用户的 peer 结构体，在服务器里面维护一个 map 来存放就可以了\nvoid CheckUser(struct sockaddr_in peer)&#123;    string tmp = inet_ntoa(peer.sin_addr);// 来源 ip    tmp += &#x27;:&#x27;;    tmp += to_string(ntohs(peer.sin_port));// 来源端口    // 在 map 中用 ip 端口来标识用户    auto it = _usrMap.find(tmp);    if(it == _usrMap.end())// 没找到    &#123;        _usrMap.insert(&#123;tmp,peer&#125;);    &#125;&#125;\n\n4.2 客户端接收回信  客户端发送信息给服务器后，可以来接收一下服务器的回信。比如在日常生活中，我们发邮件的时候，需要等待对方回信，这才表明你的信对方确实收到了，而不是丢在半路上了\n// 使用多线程操作，来获取服务器传回的信息pthread_t t;pthread_create(&amp;t, nullptr, recverAndPrint, (void *)&amp;sockfd);\n\n为了方便，这里采用多线程的方式来操作；客户端在接收到服务器的回信后，会打印出来\nvoid *recverAndPrint(void *args)&#123;    while (true)    &#123;        int sockfd = *(int *)args;        char buffer[1024];        struct sockaddr_in temp;        socklen_t len = sizeof(temp);        ssize_t s = recvfrom(sockfd, buffer, sizeof(buffer), 0, (struct sockaddr *)&amp;temp, &amp;len);        if (s &gt; 0)        &#123;            buffer[s] = 0;// 将接收到的信息打印出来（服务器返回的）            cout &lt;&lt; &quot;server echo# &quot; &lt;&lt; buffer &lt;&lt; &quot;\\n&quot;;        &#125;    &#125;&#125;\n\n4.3 消息路由  所谓消息路由，就是把接收到的消息广播给所有用户。可以理解为一个简单的聊天室。\n上面我们已经获取并记录了信息，下面要做的就是把信息重新发给其他用户；操作和客户端的发送是一样的\nvoid MsgRoute(const char* inBuf,size_t len)&#123;    struct sockaddr_in user;    for(auto e:_usrMap)    &#123;        user.sin_family = AF_INET;//ipv4        user.sin_port = e.second.sin_port;// 用户端口        user.sin_addr.s_addr = e.second.sin_addr.s_addr;// 用户 ip        // 向用户发送信息        sendto(_sockfd, inBuf, len, 0,               (const struct sockaddr *)&amp;user, sizeof(user));     &#125;&#125;\n\n测试，可以看到，服务端把收到的消息发送给了用户\n\n再新增一个客户端进行测试，可以看到两个客户都收到了服务器的回信\n\n这里对于聊天室来说还有一个小问题，那就是聊天框里面并不会二次出现你的消息。也就是服务器不会把你发送的消息再转发给你。\n我们在消息路由函数里面进行判断即可！\nvoid MsgRoute(struct sockaddr_in peer,const char* inBuf,size_t len)&#123;    struct sockaddr_in user;    for(auto e:_usrMap)    &#123;        // 如果 ip 和端口都相等，就代表是发送消息的用户        if(e.second.sin_port != peer.sin_port || e.second.sin_addr.s_addr != peer.sin_addr.s_addr)        &#123;            user.sin_family = AF_INET;//ipv4            user.sin_port = e.second.sin_port;// 用户端口            user.sin_addr.s_addr = e.second.sin_addr.s_addr;// 用户 ip            // 向用户发送信息            sendto(_sockfd, inBuf, len, 0,                   (const struct sockaddr *)&amp;user, sizeof(user));         &#125;    &#125;&#125;\n\n因为乱序打印的问题，所以看的可能不是很明显。但是我们的目的已经达到了！\n\n这样打印看的不是很清楚，可以使用管道文件来实现输出重定向\nmkfifo fifo # 创建一个 fifo 管道文件\n\n运行客户端的时候，指定输出\n./udpClient 127.0.0.1 1000 &gt; fifo\n\n在另外一个 bash 里面，用 cat 来获取输出\ncat &lt; fifo\n\n这就不会出现乱序打印的问题了。\nfifo是一个管道文件，需要执行 cat 后（读端），客户端（写端）才能运行\n5. 关于什么时候需要 bind本文以下内容建议学习了 UDP 底层报文和相关网络协议栈的知识后再来看，会方便理解一些。\n参考文章：socket 通信关于 bind IP 地址\n5.1 情况一  情况一：若有  客户端和服务器  之分的程序，创建 sock 后即可在该 socket 上用 recvfrom/sendto 方法发送接受数据了。\n因为客户端只需要用 sendto 发送数据到指定的地址，所以不需要 bind 本地的 ip 和端口。当然若是 bind 了，程序也没什么问题，区别就是不 bind 的时候，系统会自动 bind() 指定本机的 socket 参数地址来进行发送数据库。\n而服务器因为必须要有一个  显式的、固定的 IP 端口供客户端连接，所以 接收方  是必须要进行 bind 的。\n那 UDP 服务器是怎么知道客户端的 IP 地址和 UDP 端口？一般来说有两种方式：\n\n一种是客户端发消息显式地告诉服务器 IP 地址和端口，消息内容就包括 IP 地址和 UDP 端口。\n另外一种就是隐式的，服务器从收到的包的报文头部中得到包的源 IP 地址和端口。\n\n5.2 情况二  若是没有客户端和服务器之分的程序，即自己指定特定端口的 UDP 对等通信（双向对等通信），则客户端和服务器都需要bind() IP 地址和端口了。因为双方都需要知道对方的 IP 和端口才能进行数据收发。\n5.3 多播  但 UDP 中更常用的是  广播分发 ，服务端 socket 设定一个X.X.X.255 的广播地址并始终向它发送，每个客户端建立的 socket 只需要  加入  这个广播地址便可以收到，这个行为称为  加入多播组 。这便是 多播  的概念。\n一个多播组可以被多个进程加入，加入了这个多播组后，所有进程将  收到相同的消息。这样就实现了一对多通信。\n请注意，多播地址是  不能进行 bind 的 ，我们需要用相关的接口将自己的 fd 加入  目标多播组，才能从这个多播组中收到信息。发送方是不需要加入多播组的，直接往多播组的 ip 地址里面发就行了。\n\n接收方需要调用接口加入指定多播组\n发送方不需要加入多播组\n\n\n重点: 加入了多播组后，将  无法收到  原本 bind 的 ip 地址的消息！比如一个 udp 的 socket，原本 bind 了 0.0.0.0:5000，在加入多播组 之前，我能正常从 5000 端口中收到信息；但是加入了多播组后，我就只能从多播组里面收信息了。\n\n接收方加入多播组的接口如下，在接收方的 bind 之后 调用就行了\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#define MCAST_GROUP &quot;224.0.0.1&quot;#define MCAST_PORT 5007int main() &#123;    int sockfd;    struct sockaddr_in addr;    socklen_t addrlen = sizeof(addr);    char buffer[1024];    // 创建 UDP 套接字    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) &#123;        perror(&quot;socket&quot;);        exit(EXIT_FAILURE);    &#125;    // 设置接收端地址和端口    memset(&amp;addr, 0, sizeof(addr));    addr.sin_family = AF_INET;    addr.sin_addr.s_addr = htonl(INADDR_ANY);    addr.sin_port = htons(MCAST_PORT);    // 绑定接收端地址和端口    if (bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1) &#123;        perror(&quot;bind&quot;);        exit(EXIT_FAILURE);    &#125;    // 加入多播组    struct ip_mreq mreq;    mreq.imr_multiaddr.s_addr = inet_addr(MCAST_GROUP);    mreq.imr_interface.s_addr = htonl(INADDR_ANY);    if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)) == -1) &#123;        perror(&quot;setsockopt&quot;);        exit(EXIT_FAILURE);    &#125;    // 接收数据    if (recvfrom(sockfd, buffer, sizeof(buffer), 0, (struct sockaddr*)&amp;addr, &amp;addrlen) == -1) &#123;        perror(&quot;recvfrom&quot;);        exit(EXIT_FAILURE);    &#125;    // 打印接收到的数据    printf(&quot;Received: %s\\n&quot;, buffer);    // 关闭套接字    close(sockfd);    return 0;&#125;\n\n因为多播通常需要绑定特殊的 IP 地址（例如 224.0.0.0 到 239.255.255.255），这些 IP 地址是  无法在公网  上使用的，所以多播是只存在于局域网中的概念。要想实现多播，发送端和接受端必须处于  同一局域网。\n5.4 直播推流\n以下都是我根据自己的理解瞎逼逼的，有问题还请指出。\n\n公网上，也有使用 UDP 进行“多播”的例子，比如我们常用的直播就是使用的 UDP（因为直播是一个视频流推送给 N 个用户，如果每个用户都建立一个 tcp 连接会有巨大的消耗，服务器压根顶不住。再加上 tcp 需要等待用户发回 ack，在一对多的大型推流场景下，等待 ack 的消耗也不容忽视）\n直播推流情况下，其实并不是用局域网内的多播实现的，而是用 UDP 模拟实现一个类似“多播”的一对多通信。\n下面举个例子，我们暂时认为客户机也是拥有公网 IP 的，后续学习到 IP 层，会提到 NAT 技术，到时候就能理解家宽是怎么和服务器通信的了\n\n客户机想看主播的直播，直播 app 会发送一个请求到特定的IP: 端口，请求建立一个直播推流的连接。这个请求中就会包含客户机自己的 IP 地址和端口号\n服务端接受请求，解析出客户机的 IP 和端口号，并将其加入到推流队列中\n服务端每一次推流视频，都遍历全部连接到这个直播上的客户机的 IP 端口，通过 UDP 向他们发送视频数据。\n这样就实现了一个服务端向多个客户机“广播”直播推流数据的通信。\n\n需要注意的是，这和前文提到的局域网内的多播完全不同！这里我们依旧是用公网 IP 和端口进行一对一通信的，只不过服务器端进行了处理，会向所有客户机发送视频流数据罢了。\n你可能会有疑惑，现在的直播那么多人看，一个热门的直播间几万人甚至上十几万人，服务器用遍历发送的方式来得及吗？如果遍历发送一次所有客户机的耗时超过了每次发送的数据大小，岂不是大家都卡顿了吗？\n\n如果你了解 UDP 报文的结构的话，就知道 UDP 一次发送最多只能发送 64KB 的数据，对于直播推流 &#x2F; 视频来说，64KB 的数据恐怕只有 1 秒的视频。\n\n其实我们直播出现卡顿，就是这么个原因。服务端没有办法推流那么多用户了，就会出现卡顿乃至中断的情况。而且，只用同一台服务器对所有用户进行广播肯定是不够的，这时候就会引入不同线路来进行优化：\n\n主播连接一个主服务器，推流自己的直播视频数据\n主服务器将该直播视频流数据发送给全国各地的子服务器\n用户 A 进入直播间，将请求主服务器，发送自己的 IP 和端口号\n主服务器将用户 A 的 IP 和端口号解析，根据 IP 属地，发送给一个距离用户 A 最近的子服务器 B，让子服务器 B 来给用户 A 进行直播的推流\n此时用户 A 收到的视频数据：主播 -&gt; 主服务器 -&gt; 子服务器 B-&gt; 用户 A；\n\n这样，推流的压力就能分散给不同的子服务器线路。\n我们看直播的时候可以选择线路切换，其实也就是在不同的子服务器中进行切换，如果某个子服务器压力较低，此时在这个子服务器的线路上接收直播推流，用户的观看体验就比较流畅了。\n\nmore…关于 udp 编程的操作到这里就 Over 啦，现在我们认识了大部分的网络接口，下一步的目标，就是实现 tcp 服务器啦！\n\n","categories":["玩上Linux"],"tags":["Linux","线程","网络"]},{"title":"【Linux】popen pclose 接口介绍","url":"/posts/2190670283/","content":"本篇文章简单讲述了 c 语言接口 popen/pclose 的用法\n\n\n\n1. 函数作用  函数定义如下\n#include &lt;stdio.h&gt;FILE *popen(const char *command, const char *type);int pclose(FILE *stream);\n\npopen 函数会创建一个管道，fork 一个子进程，关闭管道的不使用端，通过exec 函数执行一个 shell 命令，等待命令终止。并将命令的输出结果通过管道返回给当前的进程；\n1.1 popenpopen 函数会创建一个管道，fork 后调用 shell 来打开进程。由于管道的定义是单向的，第二个参数 type 只能指定读或写，不能同时指定读和写；\n所得到的管道相应地是只读或只写的\n   The  popen()  function opens a process by creating a pipe, forking, and invoking the shell.  Since a pipe is by definition unidirectional, the type argument may specify only reading or writing, not both; the resulting stream is correspondingly read-only or write-only.\n\n简单说来，popen 会自动帮我们 fork 创建子进程和一个管道，将我们传入的参数 command 在 shell 中执行后，将返回值以  管道文件  的形式发送给调用方。\n如果调用 fork 或 pipe 失败，或者不能分配内存，将返回 NULL；否则返回标准 I&#x2F;O 流。popen()没有为内存分配失败设置 errno 值。如果调用 fork()或 pipe()时出现错误，errno 被设为相应的错误类型。如果 type 参数不合法，errno 将返回EINVAL\n1.2 pclose\n这个函数没有什么好说的，是用来关掉 popen 打开的文件的（即 popen 的返回值）\n\n但是，它的返回值可有说到了，其返回值就是我们终端操作的退出状态，以标识命令是否成功执行\n但是这个返回是通过 wait4 得到的，如果 wait4 出现错误，就会返回 -1 并设置errno\nThe pclose() function returns -1 if wait4(2) returns an error, or some other error is detected.  In the event of an error, these functions set errnro to indicate the cause of the error.\n\n这里还出现了一个新的错误码errnro，但是经过我的一番百度，没有发现任何地方有对 errnro 的说明，man 手册下方又变成了 errno\nIf pclose() cannot obtain the child status, errno is set to ECHILD.\n\n而且编译执行的时候，errnro是会报错的，所以姑且认为这里是 man 手册出错了！\n\nerrno才是正确的\nint ret = pclose(f);printf(&quot;pclose: %d | %s\\n&quot;,ret,strerror(errno));\n\n\n2. 代码示例 2.1 popen 读 以下方最简单的 ls 命令为例，我们以读方式打开，popen 就会将 ls 的执行结果写到文件里面返回给我们\n#include &lt;stdio.h&gt; int main()&#123;    FILE *f;    char readBuf[1024] = &#123;0&#125;;    f = popen(&quot;ls&quot;,&quot;r&quot;);    fread(readBuf,1024,1,f);    printf(&quot;%s\\n&quot;,readBuf);    pclose(f);    return 0;&#125;\n\n编译后执行结果如下\n$ ./testtesttest.cpp    \n\n2.2 popen 写  和读不同，如果用写方式执行 popen，命令的输出结果会直接打印到屏幕上\nvoid test2(FILE* f)&#123;    f = popen(&quot;ls&quot;,&quot;w&quot;);    int ret = pclose(f);    printf(&quot;pclose: %d | %s\\n&quot;,ret,strerror(errno));&#125;\n\nmakefile  test  test.cpppclose: 0 | Success\n\n这里我还以为后续可以接着往管道里面写数据，让他继续执行命令\nvoid test2(FILE* f)&#123;    f = popen(&quot;ls&quot;,&quot;w&quot;);    // 缓冲区中写入数据    strcpy(readBuf,&quot;ls -l&quot;);    printf(&quot;cmd: %s\\n&quot;,readBuf);    // 写道管道文件中    fwrite(readBuf,1024,1,f);    int ret = pclose(f);    printf(&quot;pclose: %d | %s\\n&quot;,ret,strerror(errno));&#125;\n\n可测试的结果告诉我，并不行\ncmd: ls -lmakefile  test  test.cpppclose: 0 | Success\n\n网上的资料大多数都是只演示了 r 方法，我不确定这里是不是我写的代码有问题，还是说本来就是这样的。暂且停留在这里吧！\n3. 优缺点  优点是：由于所有类 Unix 系统中参数扩展都是由 shell 完成的，所有它运行我们通过 popen 完成非常复杂的 shell 命令。而其他一些创建进程的函数（如 execl）调用起来就复杂的多，因为调用进程必须自己完成 shell 扩展。\n缺点是：针对每个 popen 调用，不仅要启动一个被请求的程序，还要启动一个 shell, 即每个 popen 调用将启动两个进程。从节省系统资源的角度来看，popen 函数的调用成本略高，并且对目标命令的调用比正常方式慢一些（通过 pipe 改进）。\nend关于 popen 和 pclose 的简单介绍到这里就结束了，欢迎评论区交流\n","categories":["玩上Linux"],"tags":["Linux","C语言"]},{"title":"【网络】自定义协议 | 序列化和反序列化 | Jsoncpp","url":"/posts/4060787526/","content":"以 tcpServer 的  计算器  服务为例，实现用 jsoncpp 来进行序列化和反序列化\n\n\n\n阅读本文之前，请先阅读 自定义协议 | 序列化和反序列化 | 以 tcpServer 为例\n\n1. 安装 jsoncpp我所用的系统是centos7.6，先用下面的命令查找相关的包\nsudo yum list | grep jsoncpp-devel\n\n显示出来的包如下\nRepository epel is listed more than once in the configurationjsoncpp-devel.x86_64                0.10.5-2.el7           @epel \n\n随后安装这个包\nsudo yum install jsoncpp\n\n不知道为什么，安装 jsoncpp-devel.x86_64 显示找不到相关包\n或者采用下面的两个命令\nsudo yum install epel-releasesudo yum install jsoncpp-devel\n\n如果执行完毕后显示找不到 jsoncpp，尝试重新安装epel-release\n\n刚开始我显示 epel 已经安装，但是找不到 jsoncpp 这个包，我在重新安装了 epel 后就能正常安装了\nsudo yum rm epel-releasesudo yum install epel-releasesudo yum install jsoncpp-devel\n\n如下图，正常查找到并安装完毕\n\n在 centos8 下，安装完毕后路径如下\n$ ls /usr/include/jsonallocator.h  assertions.h  autolink.h  config.h  features.h  forwards.h  json.h  reader.h  value.h  version.h  writer.h\n\n1.1 什么是 json？json 是一个 kv 键值对的序列化方式，每一个 key 都对应了一个 value\n&#123;\t&quot;data&quot;: &quot;value&quot;&#125;\n\n这就有点类似 c++ 中的 map，不过 json 能做的更多\n&#123;\t&quot;data1&quot;: &quot;value&quot;,\t&quot;data2&quot;: &#123;\t\t&quot;key1&quot;:&quot;value1&quot;,\t\t&quot;key2&quot;:&quot;value2&quot;,         &quot;key3&quot;:0,         &quot;key4&quot;:true\t&#125;&#125;\n\njson 可以在里面嵌套添加更多的内容，不管是字符串还是整形，还能是 bool 类型的true/false；\n因为 json 对反序列化序列化的控制很是不错，可读性也很好，所以被广泛使用！\n相比于自己写一个序列化方式，直接用别人的轮子，也不错👻\n类似的序列化框架还有xml\n2. 代码示例 2.1 序列化 相比我们自己写的序列化方式，json 的使用简单多了\nvoid serialize(std::string&amp; out)&#123;     // 使用 jsoncpp 的代码    Json::Value root;    root[&quot;x&quot;] = _x;    root[&quot;y&quot;] = _y;    root[&quot;op&quot;] = _ops;    Json::FastWriter fw; // 这个是写成一行，对于计算机来说处理的负担小    // Json::StyledWriter fw; // 这个会进行格式化，更好看（但是内容没差距）    out = fw.write(root);&#125;\n\n对于fw.write(root)，其返回值是一个 string，也方便我们接收\n\n其中 FastWriter 和StyledWriter有一点区别，如下\n//FastWriter&#123;&quot;data&quot;: &quot;value&quot;&#125;//StyledWriter&#123;\t&quot;data&quot;: &quot;value&quot;&#125;\n\n简单来说，StyledWriter会对我们的 kv 键值对进行格式化，更方便人类的阅读。而 FastWriter 是直接写成一整行，在传输的时候会方便一点（因为不需要\\n）\n2.2 反序列化  反序列化需要一个 Reader 来读取字符串，并将其内容根据键值隐射给成员变量\nbool deserialize(const std::string &amp;in)&#123;    //json    Json::Value root;    Json::Reader rd;    rd.parse(in, root);    _x = root[&quot;x&quot;].asInt();    _y = root[&quot;y&quot;].asInt();    _ops = root[&quot;op&quot;].asInt();&#125;\n\n3. 测试  因为 jsoncpp 是一个第三方库，我们链接的时候需要加上命令-ljsoncpp\ntcpServer:tcpServer.cpp\tg++ -o $@ $^ -std=c++11 -lpthread -ljsoncpp\n\n发送消息后，可以看到，json 帮我们格式化为如下形式的字符串\n&#123;&quot;op&quot;:43,&quot;x&quot;:1,&quot;y&quot;:200&#125;&#123;&quot;op&quot;:43,&quot;x&quot;:333,&quot;y&quot;:234&#125;\n\n\n4.gcc 给予宏定义  为了方便对序列化采用的方式进行控制，这里我使用了预处理指令 ifdef/endif 来进行判断，只要我们在文件头定义了MYPROTOCOL，这里就会采用我们自己的写的序列化方式，否则采用 json\n#define MYPROTOCOL 1  // 如果 define 了这个，那就使用自己的代码\n\n\n4.1 命令行  但是在文件里面修改 define 还是不太方便，我们可以直接采用 gcc 的命令行参数的方式，进行 define 的插入（这么做之前，要先删除文件中对 MYPROTOCOL 的 define）\ng++ -DMYPROTOCOL tcpServer.cpp -o tcpServer -lpthread -ljsoncppg++ -DMYPROTOCOL tcpClient.cpp -o tcpClient -lpthread -ljsoncpp\n\n可以看到，不加编译指令编译出来的服务器，采用的是 json 的方式来序列化\n\n添加了之后，就是用我们自己写的序列化方式来序列化了\n\n4.2 makefile因此，我们可以修改 makefile 来实现这一点\n.PHONY:allall:tcpClient tcpServerMYSELF=-DMYPROTOCOLtcpClient: tcpClient.cpp\tg++ $(MYSELF) -o $@ $^ -std=c++11 -lpthread -ljsoncpptcpServer:tcpServer.cpp\tg++ $(MYSELF) -o $@ $^ -std=c++11 -lpthread -ljsoncpp.PHONY:cleanclean:\trm -f tcpClient tcpServer\n\n当我们需要用自己协议的时候，就在最前面加上\nMYSELF=-DMYPROTOCOL\n\n否则直接  删除  这个定义，或者注释掉后面的内容，就能采用 jsoncpp\nMYSELF=#-DMYPROTOCOL\n\n这样就方便一些了\n\n","categories":["玩上Linux"],"tags":["Linux","网络"]},{"title":"【网络】自定义协议 | 序列化和反序列化 | 以 tcpServer 为例","url":"/posts/4225991450/","content":"以 tcpServer 的  计算器  服务为例，实现一个自定义协议\n\n\n\n阅读本文之前，请先阅读 tcpServer\n本文完整代码详见 Gitee\n\n1. 重谈 tcp注意，当下所对 tcp 的描述都是  以简单、方便理解  起见，后续会对 tcp 协议进行深入解读\n1.1 链接  我们知道，tcp 是面向连接的，客户端和服务端要先建立链接，才能开始通信\n\n在链接过程中，tcp 采用三次握手\n在断线过程中，tcp 采用四次挥手\n\n举个日常生活中的栗子，帮助理解 3 次握手和 4 次挥手\n\n1.2 信息发送\n假如我们现在需要发送结构化数据，那应该怎么办？\n\n我们知道，tcp 是面向字节流的，也就是其能够发送任意数据。也能够发送 C 语言结构体 的二进制数据；\n\n但能发送，就代表我们可以这么干吗？\n答案自然是  不行！\n\n不同平台，对  结构体对齐  的配置不同，大小端不同，其最终对我们字节流的解析也就不一样。如果采用直接发送结构体数据的方式来通信，适配性极低，我们的客户端和服务端都会被限制在当前的系统环境中运行；\n可是，哪怕是同一个系统，其内部对大小端的配置也有可能改变！到时候我们的代码恐怕就无法运行了！\n同理，在当初编写 C 语言通讯录 的代码的时候，也不能采用直接将结构体数据写入文件的方式。后续代码升级、环境改变，都可能导致我们存在文件中的数据失效，这肯定是我们不希望看到的情况。\n所以，为了解决这个问题，我们就应该将数据进行  序列化  之后再发送，客户端接收到信息后，进行  反序列化  解析出数据！\n2. 序列化和反序列化 2.1 简介 所谓序列化，就是将结构化的数据（可以暂时理解为 c 的结构体）转换成字符串的方式，发送出去\nstruct date&#123;    int year;    int month;    int day;&#125;;\n\n比如上面这个日期结构体，我们要想将其序列化，就可以用一个很简单的方式拼接成一个字符串（序列化）\nyear-month-day\n\n客户端收到这个字符串之后，就可以通过查找分隔符 - 的方式，取出三个变量，将其转成 int 后存放回结构体（反序列化）\n这样，我们就算是规定了一个序列化和反序列化的方式，也就是一个简单的  协议！\n\n2.2 编码解码  这里还会出现另外一个问题，我要怎么知道我已经  读取完毕  了一个序列化后的数据呢？\n2000-12-1010000-01-01\n\n如上，假设有一天，我们的年变成了五位数；这时候，服务端要怎么知道自己是否读取完毕了一个完整的序列化数据呢？\n这就需要我们做好规定，将前 n 字节作为标识长度的数据。接收到数据后，先取出前 n 个字节，读取道此次消息的长度 m，再往后读取 m 个字节的数据，成功取出完整的字符串;\n\n这个过程可以称作  编码和解码  的过程\n\n为了区分标识长度的数据和实际需要的序列化内容，我们可以在之中加上分隔符\\t；但这也需要我们确认，传输的数据本身不能带上\\t，否则会产生一系列的问题\n10\\t2000-12-10\\t11\\t10000-01-01\\t\n\n以上的这一系列工作，都是  协议定制  的一部分！我们给服务端和客户端规定了一个序列化和反序列化的方式，让二者通信规避掉了平台的限制。毕竟任何平台对  字符串  解码出来的数据都会是相同的！\n下面就用一个  计算器  的服务，来演示一下吧😏\n3. 计算器服务  因为本文的重心是对协议定制的演示，所以这里的计算器  不考虑连续操作符  的情况，\n3.1 协议定制  要想实现一个计算器，我们首先要搞明白计算器有几个成员\nx+yx/yx*y...\n\n一般情况下，一个计算器只需要 3 个成员，分别是两个操作数和一个运算符，就能开始计算。所以我们需要将这里的三个字段设计成一个字符串，实现序列化；\n比如我们应该规定序列化之后的数据应该是如下的，两个操作数和操作符之间应该要有  空格\na + b\n\n再在开头添加上数据长度的标识\n数据长度 \\t 公式 \\t7\\t10 + 20\\t8\\t100 / 30\\t9\\t300 - 200\\t\n\n对于服务端，我们需要返回两个参数：状态码和结果\n退出状态 结果\n\n如果退出状态不为 0，则代表出现错误，结果无效；只有退出结果为 0，结果才是有效的。\n同样的，也需要给服务器的序列化字符串添加上数据的长度\n数据长度 \\t 退出状态 结果 \\t\n\n这样就搞定了一个计算器的自定义协议；\n3.2 成员  依照如上的协议，先把请求和返回的成员变量写好\nclass Request&#123;    int _x;    int _y;    char _ops;&#125;;\n\nclass Response&#123;\tint _exitCode; // 计算服务的退出码\tint _result;  // 结果&#125;;  \n\n这些成员变量都设置为公有，方便在 task 里面进行处理（否则就需要写 get 函数，很麻烦）\n同时，最好还是把协议中的分隔符给定义出来，方便后续统一使用 or 更改\n#define CRLF &quot;\\t&quot;   // 分隔符#define CRLF_LEN strlen(CRLF) // 分隔符长度#define SPACE &quot; &quot;   // 空格#define SPACE_LEN strlen(SPACE) // 空格长度#define OPS &quot;+-*/%&quot; // 运算符\n\n3.3 编码解码  对于请求和回应来说，编解码的操作是一样的，都是往字符串的开头添加上长度和分隔符\n长度 \\t 序列化字符串 \\t\n\n解码就是将长度和分隔符去掉，只解析出序列化字符串\n序列化字符串\n\n编码解码的整个过程在注释里面都写明了😁为了方便请求和回应去使用，直接放到外头，不做类内封装\n// 参数 len 为 in 的长度，是一个输出型参数。如果为 0 代表 errstd::string decode(std::string&amp; in,size_t*len)&#123;    assert(len);// 如果长度为 0 是错误的    // 1. 确认 in 的序列化字符串完整（分隔符）    *len=0;    size_t pos = in.find(CRLF);// 查找分隔符    // 查找不到，err    if(pos == std::string::npos)&#123;        return &quot;&quot;;// 返回空串    &#125;       // 2. 有分隔符，判断长度是否达标    // 此时 pos 下标正好就是标识大小的字符长度    std::string inLenStr = in.substr(0,pos);// 提取字符串长度    size_t inLen = atoi(inLenStr.c_str());// 转 int    size_t left = in.size() - inLenStr.size()- 2*CRLF_LEN;// 剩下的字符长度    if(left&lt;inLen)&#123;        return &quot;&quot;; // 剩下的长度没有达到标明的长度    &#125;    // 3. 走到此处，字符串完整，开始提取序列化字符串    std::string ret = in.substr(pos+CRLF_LEN,inLen);    *len = inLen;    // 4. 因为 in 中可能还有其他的报文（下一条）    // 所以需要把当前的报文从 in 中删除，方便下次 decode，避免二次读取    size_t rmLen = inLenStr.size() + ret.size() + 2*CRLF_LEN;    in.erase(0,rmLen);    // 5. 返回    return ret;&#125;// 编码不需要修改源字符串，所以 const。参数 len 为 in 的长度std::string encode(const std::string&amp; in,size_t len)&#123;    std::string ret = std::to_string(len);// 将长度转为字符串添加在最前面，作为标识    ret+=CRLF;    ret+=in;    ret+=CRLF;    return ret;&#125;\n\n3.4 request编码解码写好了，先来处理比较麻烦的请求部分；说麻烦吧，其实大多数也是 c++ 的 string 操作，要熟练运用 string 的各类成员函数，才能很好的实现\n3.4.1 构造  比较重要的是这个构造函数，我们需要将用户的输入转成内部的三个成员\n用户可能输入 x+y，x+ y，x +y,x + y 等等格式\n\n这里还需要注意，用户的输入不一定是标准的 X+Y，里面可能在不同位置里面会有空格。为了统一方便处理，在解析之前， 最好先把用户输入内的空格给去掉！\n对于 string 而言，去掉空格就很简单了，直接一个遍历搞定\n// 删除输入中的空格void rmSpace(std::string&amp; in)&#123;    std::string tmp;    for(auto e:in)    &#123;        if(e!=&#x27; &#x27;)        &#123;            tmp+=e;        &#125;    &#125;    in = tmp;&#125;\n\n完成的构造如下，这里涉及到 C 语言的  函数 strtok，要复习复习\n// 将用户的输入转成内部成员// 用户可能输入 x+y，x+ y，x +y,x + y 等等格式// 提前修改用户输入（主要还是去掉空格），提取出成员Request(std::string in,bool* status)    :_x(0),_y(0),_ops(&#x27; &#x27;)&#123;    rmSpace(in);    // 这里使用 c 的字符串，因为有 strtok    char buf[1024];    // 打印 n 个字符，多的会被截断    snprintf(buf,sizeof(buf),&quot;%s&quot;,in.c_str());    char* left = strtok(buf,OPS);    if(!left)&#123;// 找不到        *status = false;        return;    &#125;    char*right = strtok(nullptr,OPS);    if(!right)&#123;// 找不到        *status = false;        return;    &#125;    // x+y, strtok 会将 + 设置为 \\0    char mid = in[strlen(left)];// 截取出操作符    // 这是在原字符串里面取出来，buf 里面的这个位置被改成 \\0 了    _x = atoi(left);    _y = atoi(right);    _ops = mid;    *status=true;&#125;\n\n3.4.2 序列化  解析出成员以后，我们要做的就是对成员进行序列化，将其按指定的位置摆成一个字符串。这里采用了  输出型参数  的方式来序列化字符串，也可以改成用返回值的方式来操作。\n这里需要注意的是，操作符本身就是 char 不能使用 to_string 来操作，会被转成 ascii 码，不符合我们的需求\n// 序列化 （入参应该是空的）void serialize(std::string&amp; out)&#123;    // x + y    out.clear(); // 序列化的入参是空的    out+= std::to_string(_x);    out+= SPACE;    out+= _ops;// 操作符不能用 tostring，会被转成 ascii    out+= SPACE;    out+= std::to_string(_y);    // 不用添加分隔符（这是 encode 要干的事情）&#125;\n\n3.4.3 反序列化  注意，思路不能搞错了。刚开始我认为 request 的反序列化应该针对的是服务器的返回值，实际并非如此！\n在客户端和服务端都需要使用 request，客户端进行序列化，服务端对接收到的结果利用request 进行反序列化。request 只关注于对请求的处理，而不处理服务器的返回值。\n// 反序列化bool deserialize(const std::string &amp;in)&#123;    // x + y 需要取出 x，y 和操作符    size_t space1 = in.find(SPACE); // 第一个空格    if(space1 == std::string::npos)    &#123;        return false;    &#125;    size_t space2 = in.rfind(SPACE); // 第二个空格    if(space2 == std::string::npos)    &#123;        return false;    &#125;    // 两个空格都存在，开始取数据    std::string dataX = in.substr(0,space1);    std::string dataY = in.substr(space2+SPACE_LEN);// 默认取到结尾    std::string op = in.substr(space1+SPACE_LEN,space2 -(space1+SPACE_LEN));    if(op.size()!=1)    &#123;        return false;// 操作符长度有问题    &#125;    // 没问题了，转内部成员    _x = atoi(dataX.c_str());    _y = atoi(dataY.c_str());    _ops = op[0];    return true;&#125;\n\n3.5 response3.5.1 构造  返回值的构造比较简单，因为是服务器处理结果之后的操作；这些成员变量都设置为了公有，方便后续修改。\nResponse(int code=0,int result=0)    :_exitCode(code),_result(result)&#123;&#125;\n\n3.5.2 序列化// 入参是空的void serialize(std::string&amp; out)&#123;    // code ret    out.clear();    out+= std::to_string(_exitCode);    out+= SPACE;    out+= std::to_string(_result);    out+= CRLF;&#125;\n\n3.5.3 反序列化  响应的反序列化只需要处理一个空格，相对来说较为简单\n// 反序列化bool deserialize(const std::string &amp;in)&#123;    // 只有一个空格    size_t space = in.find(SPACE);    if(space == std::string::npos)    &#123;        return false;    &#125;    std::string dataCode = in.substr(0,space);    std::string dataRes = in.substr(space+SPACE_LEN);    _exitCode = atoi(dataCode.c_str());    _result = atoi(dataRes.c_str());    return true;&#125;\n\n3.6 客户端  之前写的客户端，并没有进行序列化操作，所以我们需要添加上序列化操作，并对服务器的返回值进行反序列化。这期间需要加上一系列判断；\n为了限制篇幅，下面只贴出来客户端的循环操作；详情参考注释。\n// 客户端发现的消息string message;while (1)&#123;    message.clear();// 每次循环开始，都清空一下 msg    cout &lt;&lt; &quot; 请输入你的消息# &quot;;    getline(cin, message);// 获取输入    // 如果客户端输入了 quit，则退出    if (strcasecmp(message.c_str(), &quot;quit&quot;) == 0)        break;    // 向服务端发送消息    // 1. 创建一个 request（分离参数）    bool reqStatus = true;    Request req(message,&amp;reqStatus);    if(!reqStatus)&#123;        cout &lt;&lt; &quot;make req err!&quot; &lt;&lt; endl;        continue;    &#125;    // 2. 序列化和编码    string package;    req.serialize(package);// 序列化    package = encode(package,package.size());// 编码    // 3. 发送给服务器    ssize_t s = write(sock,package.c_str(), package.size());    if (s &gt; 0) // 写入成功    &#123;        // 4. 获取服务器的结果        char buff[BUFFER_SIZE];        size_t s = read(sock, buff, sizeof(buff)-1);        if(s &gt; 0)&#123;            buff[s] = &#x27;\\0&#x27;;        &#125;        std::string echoPackage = buff;        Response resp;        size_t len = 0;        // 5. 解码和反序列化        std::string tmp = decode(echoPackage, &amp;len);        if(len &gt; 0)// 解码成功        &#123;            echoPackage = tmp;            if(resp.deserialize(echoPackage))// 反序列化并判断            &#123;                printf(&quot;ECHO [exitcode: %d] %d\\n&quot;, resp._exitCode, resp._result);            &#125;            else            &#123;                cerr &lt;&lt; &quot;server echo deserialize err!&quot; &lt;&lt; endl;            &#125;        &#125;        else        &#123;            cerr &lt;&lt; &quot;server echo decode err!&quot; &lt;&lt; endl;        &#125;    &#125;    else if (s &lt;= 0) // 写入失败    &#123;        break;    &#125;&#125;\n\n3.7 服务端  服务端无须修改代码，需要修改的是 task 消息队列中处理的任务；这就是之前做好封装的好处，因为只需要修改 task 里面传入的函数指针，就算是修改了服务器所进行的服务\n// 提供服务（通过线程池）Task t(conet,senderIP,senderPort,CaculateService);_tpool-&gt;push(t);\n\n如下是计算器服务的代码\nvoid CaculateService(int sockfd, const std::string &amp;clientIP, uint16_t clientPort)&#123;    assert(sockfd &gt;= 0);    assert(!clientIP.empty());    assert(clientPort &gt; 0);    std::string inbuf;    while(1)    &#123;        Request req;        char buf[BUFFER_SIZE];        // 1. 读取客户端发送的信息        ssize_t s = read(sockfd, buf, sizeof(buf) - 1);        if (s == 0)        &#123;   // s == 0 代表对方发送了空消息，视作客户端主动退出            logging(DEBUG, &quot;client quit: %s[%d]&quot;, clientIP.c_str(), clientPort);            break;        &#125;        else if(s&lt;0)        &#123;            // 出现了读取错误，打印日志后断开连接            logging(DEBUG, &quot;read err: %s[%d] = %s&quot;, clientIP.c_str(), clientPort, strerror(errno));            break;        &#125;        // 2. 读取成功        buf[s] = &#x27;\\0&#x27;; // 手动添加字符串终止符        if (strcasecmp(buf, &quot;quit&quot;) == 0)        &#123; // 客户端主动退出            break;        &#125;        // 3. 开始服务        inbuf = buf;        size_t packageLen = inbuf.size();        // 3.1. 解码和反序列化客户端传来的消息        std::string package = decode(inbuf, &amp;packageLen);// 解码        if(packageLen==0)&#123;            logging(DEBUG, &quot;decode err: %s[%d] status: %d&quot;, clientIP.c_str(), clientPort, packageLen);            continue;// 报文不完整或有误        &#125;        logging(DEBUG,&quot;package: %s[%d] = %s&quot;,clientIP.c_str(), clientPort,package.c_str());        bool deStatus = req.deserialize(package); // 反序列化        if(deStatus) // 获取消息反序列化成功        &#123;            req.debug(); // 打印信息            // 3.2. 获取结构化的相应            Response resp = Caculater(req);            // 3.3. 序列化和编码响应            std::string echoStr;            resp.serialize(echoStr);            echoStr = encode(echoStr,echoStr.size());            // 3.4. 写入，发送返回值给客户端            write(sockfd, echoStr.c_str(), echoStr.size());        &#125;        else // 客户端消息反序列化失败        &#123;            logging(DEBUG, &quot;deserialize err: %s[%d] status: %d&quot;, clientIP.c_str(), clientPort, deStatus);            continue;        &#125;    &#125;    close(sockfd);    logging(DEBUG, &quot;server quit: %s[%d] %d&quot;,clientIP.c_str(), clientPort, sockfd);&#125;\n\n其中有一个计算函数，比较简单，通过 switch case 语句，计算结果，并判断操作数是否有问题。\nResponse Caculater(const Request&amp; req)&#123;    Response resp;// 构造函数中已经指定了 exitcode 为 0    switch (req._ops)    &#123;    case &#x27;+&#x27;:        resp._result = req._x + req._y;        break;    case &#x27;-&#x27;:        resp._result = req._x - req._y;        break;    case &#x27;*&#x27;:        resp._result = req._x * req._y;        break;    case &#x27;%&#x27;:    &#123;        if(req._y == 0)        &#123;            resp._exitCode = -1;// 取模错误            break;        &#125;        resp._result = req._x % req._y;// 取模是可以操作负数的        break;    &#125;    case &#x27;/&#x27;:    &#123;        if(req._y == 0)        &#123;            resp._exitCode = -2;// 除 0 错误            break;        &#125;        resp._result = req._x / req._y;// 取模是可以操作负数的        break;    &#125;    default:        resp._exitCode = -3;// 操作符非法        break;    &#125;    return resp;&#125;\n\n这样，我们的序列化处理就成功了！测试一下吧\n4. 测试  运行服务器，可以看到，服务器能成功处理客户端的计算，并返回结果\n\n输入 quit，服务器会打印信息，并退出服务\n\n","categories":["玩上Linux"],"tags":["Linux","网络"]},{"title":"【网络】http(s) 协议 | content-length 详解 | 转载","url":"/posts/1805390619/","content":"本文通过一个线上实例，详细介绍 http 协议中的 content-length 字段。\n\n\n前言http 协议是互联网中最重要的协议之一，虽然看上去很简单，但是实际中经常遇到问题，我们就已经遇到好几次了。有长连接相关的，有报文解析相关的。对 http 协议不能一知半解，必须透彻理解才行。\n本文通过一个线上实例，详细介绍 http 协议中的 content-length 字段。\n问题  我们的手机 App 在做更新时会从服务器上下载的一些资源，一般都是一些小文件，更新的代码差不多是下面这样的：\nstatic void update() throws IOException &#123;    URL url = new URL(&quot;http://172.16.59.129:8000/update/test.so&quot;);    HttpURLConnection conn = (HttpURLConnection) url.openConnection();    if(conn.getResponseCode() == 200) &#123;        int totalLength = conn.getContentLength();\tBufferedInputStream in = new BufferedInputStream(conn.getInputStream());\tbyte[] buffer = new byte[512];\tint readLength = 0;\tint length = 0;\twhile((length=in.read(buffer)) != -1) &#123;\t\treadLength += length;\t\t// 进度条\t\tSystem.out.println(((float)readLength) /((float)(totalLength)));\t&#125;    &#125;&#125;\n\n比如上面的代码更新一个 so 文件，先通过 content-length 获取文件的总大小，然后读 Stream，每读一段，就计算出当前读的总大小，除以 content-length，用来显示进度条。\n结果 weblogic 从 10 升级到 12 后，content-length 一直返回 -1，这样就不能显示进度条了，但是文件流还能正常读。把 weblogic 重启了，一开始还能返回 content-length，一会又是 -1 了。\n原因分析Http 协议的请求报文和回复报文都有 header 和 body，body 就是你要获取的资源，例如一个 html 页面，一个 jpeg 图片，而 header 是用来做某些约定的。例如客户端与服务端商定一些传输格式，客户端先获取头部，得知一些格式信息，然后才开始读取 body。\n\n客户端： Accept-Encoding:gzip （给我压缩一下，我用的是流量，先下载下来我再慢慢解压吧）\n服务端 1：Content-Encoding:null(没有 Content-Encoding 头。 我不给压缩，CPU 没空，你爱要不要）\n服务端 2：Content-Encoding:gzip (给你节省流量，压缩一下）\n\n\n客户端：Connection: keep-alive (大哥，咱好不容易建了个 TCP 连接，下次接着用）\n服务端 1: Connection: keep-alive （都不容易，接着用）\n服务端 2: Connection: close (谁跟你接着用，我们这个 TCP 是一次性的，下次再找我还得重新连)\n\nhttp 协议没有三次握手，一般客户端向服务端请求资源时，以服务端为准。还有一些 header 并没有协商的过程，而是服务端直接告诉客户端按什么来。例如上述的 Content-Length，是服务端告诉客户端 body 的大小有多大。但是！服务端并不一定能准确的提前告诉你 body 有多大。服务端要先写 header，再写 body，如果要在 header 里把 body 大小写进去，就得提前知道 body 大小。如果这个 body 是动态生成的，服务端先生成完，再开始写 header，这样需要很多额外的开销，所以 header 里不一定有 content-length。\n那客户端怎么知道 body 的大小呢？服务器有三种方式告诉你。\n1. 服务器已经知道资源大小，通过 content-length 这个 header 告诉你。\nContent-Length:1076(body 的大小是 1076B，你读取 1076B 就可以完成任务了）Transfer-Encoding: null\n\n2. 服务器没法提前知道资源的大小，或者不愿意花费资源提前计算资源大小，就会把 http 回复报文中加一个 header 叫 Transfer-Encoding:chunked，就是分块传输的意思。每一块都使用固定的格式，前边是块的大小，后面是数据，然后最后一块大小是 0。这样客户端解析的时候就需要注意去掉一些无用的字段。\nContent-Length:nullTransfer-Encoding:chunked (接下来的 body 我要一块一块的传，每一块开始是这一块的大小，等我传到大小为 0 的块时，就没了）\n\n3. 服务器不知道资源的大小，同时也不支持 chunked 的传输模式，那么就既没有 content-length 头，也没有 transfer-encoding 头，这种情况下必须使用短连接，以连接结束来标示数据传输结束，传输结束就能知道大小了。这时候服务器返回的 header 里 Connection 一定是 close。\nContent-Length:null Transfer-Encoding:null Connection:close(我不知道大小，我也用不了 chunked，啥时候我关了 tcp 连接，就说明传输结束了）\n\n实验  我通过 nginx 在虚拟机里做实验，默认 nginx 是支持 chunked 模式的，可以关掉。\n使用的代码如下，可能会调整参数。\nstatic void update() throws IOException &#123;    URL url = new URL(&quot;http://172.16.59.129:8000/update/test.so&quot;);    HttpURLConnection conn = (HttpURLConnection) url.openConnection();    //conn.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);    //conn.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;);    conn.connect();    if(conn.getResponseCode() == 200) &#123;        System.out.println(conn.getHeaderFields().keySet());        System.out.println(conn.getHeaderField(&quot;transfer-encoding&quot;));        System.out.println(conn.getHeaderField(&quot;Content-Length&quot;));        System.out.println(conn.getHeaderField(&quot;Content-Encoding&quot;));        System.out.println(conn.getHeaderField(&quot;Connection&quot;));    &#125;&#125;\n\n1.nginx 在开启 chunked_transfer_encoding 的时候(1) 在 reqeust header 里不使用 gzip，也就是不加accept-encoding: gzip\n\n\n\ntest.so 文件大小\n结果\n\n\n\n100B\n能正常返回 content-length, 没有 transfer-encoding 头\n\n\n69M\n能正常返回 content-length, 没有 transfer-encoding 头\n\n\n3072M\n能正常返回 content-length, 没有 transfer-encoding 头\n\n\n可以发现 nginx 不管资源多大，如果客户端不接受 gzip 的压缩格式，就不会使用 chunked 模式，而且跟是否使用短连接没关系。\n(2)在 request header 里加入 gzip，accepting-encoding: gzip\n\n\n\ntest.so 文件大小\n结果\n\n\n\n100B\n没有 content-length,transfer-encoding&#x3D;trunked\n\n\n69M\n没有 content-length,transfer-encoding&#x3D;trunked\n\n\n3072M\n没有 content-length,transfer-encoding&#x3D;trunked\n\n\n可以看到 nginx 在开启chunked_transfer_encoding，并且客户端接受 gzip 的时候，会使用 chunked 模式，nginx 开启 gzip 后不会计算资源的大小，直接用 chunked 模式。\n2.nginx 关闭 chunked_transfer_encoding(1) 在 reqeust header 里不使用 gzip，也就是不加accept-encoding:gzip\n\n\n\ntest.so 文件大小\n结果\n\n\n\n100B\n能正常返回 content-length, 没有 transfer-encoding 头\n\n\n69M\n能正常返回 content-length, 没有 transfer-encoding 头\n\n\n3072M\n能正常返回 content-length, 没有 transfer-encoding 头\n\n\n因为能很容易的知道文件大小，所以 nginx 还是能返回 content-length。\n(2)在 request header 里加入 gzip，accepting-encoding:gzip\n\n\n\ntest.so 文件大小\n结果\n\n\n\n100B\n没有 content-length 和 transfer-encoding 头，不论客户端 connection 为 keep-alive 还是 close，服务端返回的 connection 头都是 close\n\n\n69M\n没有 content-length 和 transfer-encoding 头，不论客户端 connection 为 keep-alive 还是 close，服务端返回的 connection 头都是 close\n\n\n3072M\n没有 content-length 和 transfer-encoding 头，不论客户端 connection 为 keep-alive 还是 close，服务端返回的 connection 头都是 close\n\n\n这就是上面说的第三种情况，不知道大小，也不支持 trunked，那就必须使用短连接来标示结束。\n问题解决方案  咨询了中间件组的同事，以前也遇到类似的问题，因为升级了 Weblogic 导致客户端解析 XML 出错，因为使用了 chunked 模式，中间有一些格式化的字符，而客户端解析的代码并没有考虑 chunked 模式的解析，导致解析出错。\n因为我们客户端必须用 content-length 展示进度，因此不能用 chunked 模式，Weblogic 可以把 chunked 模式关闭。用下面的方法：\n#!java weblogic.WLST connect(&#x27;username’,&#x27;password&#x27;, &#x27;t3://localhost:7001&#x27;)edit()startEdit()cd(&quot;Servers/AdminServer/WebServer/AdminServer&quot;)cmo.setChunkedTransferDisabled(true)save()activate()exit()\n\n改了之后，确实不返回 chunked 了，但是也没有 content-length，因为 Weblogic 就是不提前获取文件大小，而是强制加了connection:close，也就是前边说的第三种，通过连接结束标识数据结束。最后只能把这些资源放倒 apache 里了。\n总结  一个好的 http 客户端，必须充分实现协议，不然就可能出问题，浏览器对于服务端可能产生的各种情况都很好的做了处理，但是自己实现 http 协议的解析时一定得注意考虑多种情况。\n文章作者：牛立新  原文链接：https://www.cnblogs.com/nxlhero/p/11670942.html\n\n","categories":["玩上Linux"],"tags":["网络","nginx","http"]},{"title":"【Linux】buff cache 的真相","url":"/posts/2377102236/","content":"1. 表现现象  在 Linux 系统中，我们经常用 free 命令来查看系统内存的使用状态。在一个 CoreOS 的系统上，free命令的显示内容大概是这样一个状态：\ncore@localhost ~ $ free\n              total        used        free      shared  buff/cache   available\nMem:        8145320      391200     333888      204616      7420232     311660\nSwap:             0           0           0\n\n这里的默认显示单位是 kb，我们可以通过添加 -h 参数，来让free 命令显示的更为友好一些。\ncore@localhost ~ $ free -h\n              total        used        free      shared  buff/cache   available\nMem:          7.8Gi       381Mi       0.3Gi       199Mi       7.4Gi       0.3Gi\nSwap:            0B          0B          0B\n\n新版 linux 相对来说已经好很多了，在老版的时候，是没有 available 字段的。\n所以放当时来说，大家可能会有下面几种反应：\n\n对于不太了解 linux 系统的人来说，看到 free 之后，会觉得内存用了好多，我都没跑什么程序，内存就用完了！Linux 好占内存！\n稍微了解 linux，并在百度搜索过相关知识的人也许会说，嗯，看起来 free 是没有多少了，但是真实内存才用了 400Mi 不到，还有很多剩余内存可用。buff&#x2F;cache 占用比较多，说明系统中有进程曾经读写过文件，但是不要紧，这部分内存在系统内存吃紧的时候会释放出来的。\n\n但是，上面两种说法都有些片面了，都不是很正确。接下来让我们重新来认识一下 buff 和cache。\n2. 什么是 buff&#x2F;cache？在 Linux 2.4 的内存管理中，buffer指 Linux 内存的：Buffer cache。cache指 Linux 内存中的：Page cache。一般呢，是这么解释两者的。\n\nA buffer is someting that has yet to be ‘written’ to disk.\nA cache is someting that has been ‘read’ from the disk and stored for later use.\n\n翻译过来就是说：\n\nbuffer(buff) 是用来缓存尚未“写入”磁盘的内容。\ncache 是用来缓存从磁盘“读取”出来的东西。\n\n所以 buffer 被用来当成对 io 设备写的缓存。而 cache 被用来当作对 io 设备的读缓存。这里的 io 设备，主要指的是块设备文件和文件系统上的普通文件。\n但是在 Linux 2.6 以后，它们的意义不一样了。\n在 Linux 2.6 之后 Linux 将他们统一合并到了 Page cache 作为文件层的缓存。而 buffer 则被用作 block 层的缓存。block层的缓存是什么意思呢，你可以认为一个 buffer 是一个 physical disk block 在内存的代表，用来将内存中的 pages 映射为disk blocks，这部分被使用的内存被叫做buffer。\n\nbuffer里面的 pages，指的是Page cache 中的 pages，所以，buffer 也可以被认为 Page cache 的一部分。\n\n或者简单来说，buffer负责裸设备相关的缓存，cache负责文件系统的缓存。\nBuffer 的具体职责  在当前的系统实现里，buffer主要是设计用来在系统对块设备进行读写时作为缓存来使用。这意味着对块的操作会使用 buffer 进行缓存，比如我们在格式化文件系统的时候。\n但是一般情况下两个缓存系统是一起配合使用的，比如当我们对一个文件进行写操作的时候，cache的内容会被改变，而 buffer 则用来将 cache 的page标记为不同的缓冲区，并记录是哪一个缓冲区被修改了。\n这样，内核在后续执行脏数据的回写（writeback）时，就不用将整个 page 写回，而只需要写回修改的部分即可。\nCache 的具体职责 cache 主要用来作为文件系统上的文件数据的缓存来用，当进程对文件有 read/write 操作的时候。包括将文件映射到内存的系统调用mmap，就会用到cache。\n因为 cache 被作为文件类型的缓存来用，所以事实上也负责了大部分的块设备文件的缓存工作。\n3. 怎么回收 buff&#x2F;cache？Linux 内核会在内存将要耗尽的时候，自动触发内存回收的工作，以便释放出内存给急需内存的进程使用。\n但是这种回收的工作也并不是没有成本。\n理解 cache 是干什么的就知道，cache中存在着一部分 write 操作的数据。所以必须保证 cache 中的数据跟对应文件中的数据一致，才能对 cache 进行释放。\n于是伴随着 cache 清除的行为的，一般都是系统 IO 飙高。这是因为内核要将 cache 中缓存的 write 数据进行回写。\n我们可以使用下面这个文件来人工触发缓存清除的操作，Linux 提供了三种清空方式：\n\necho 1 &gt; /proc/sys/vm/drop_caches # 仅清除页面缓存\necho 2 &gt; /proc/sys/vm/drop_caches # 清除目录项和 inode\necho 3 &gt; /proc/sys/vm/drop_caches # 清除页面缓存、目录项以及 inode\n\n但是这种放时只能在执行的当时起作用，过一段时间之后又会发现内存被占满，怎么办呢？\n实际上内核提供了 vm.vfs_cache_pressure 参数用来控制缓冲区的回收频率，我们可以调整它。\n这个参数是用来控制内核回收 VFS 缓存的频率。修改这个值会提高或者降低回收 VFS 缓存的频率。值可以设置为 0-200 中的任意值。越大回收频率越快，可以把 vm.vfs_cache_pressure 赋值为 200 来获得最快的回收频率。这个值默认值一般为100。\n另外也可以使用 slabtop 分析内存使用情况。一般情况下，dentry和 *_inode_cache 值越高回收的效果越好。\n为什么是 dentry 和*_inode_cache呢，这是因为当读写文件时内核会为该文件对象建立一个 dentry，并将其缓存起来，方便下一次读写时直接从内存中取出提高效率。至于*_inode_cache 我就不是很清楚了，只知道是为了加快对索引节点的索引，如果有清楚的可以告诉我一下。\n4. 测试一下\n首先，我们先看一下目前的内存使用量\ncore@localhost ~ $ free -h              total        used        free      shared  buff/cache   availableMem:          7.8Gi       383Mi       7.1Gi       199Mi       291Mi       7.0GiSwap:            0B          0B          0B\n\n生成一个文件测试一下\ncore@localhost ~ $ dd if=/dev/zero of=testfile bs=1M count=10001000+0 records in1000+0 records out1048576000 bytes (1.0 GB, 1000 MiB) copied, 1.39192 s, 753 MB/s\n\n检查一下内存的使用情况，是否和上面介绍的一样\ncore@localhost ~ $ free -h              total        used        free      shared  buff/cache   availableMem:          7.8Gi       383Mi       6.1Gi       199Mi       1.3Gi       7.0GiSwap:            0B          0B          0B\n\n手动执行一下释放，看能否将内存释放出来\ncore@localhost ~ $ echo 1 | sudo tee /proc/sys/vm/drop_caches1\n\n检查一下内存是否被释放掉\ncore@localhost ~ $ free -h              total        used        free      shared  buff/cache   availableMem:          7.8Gi       383Mi       7.1Gi       199Mi       291Mi       7.0GiSwap:            0B          0B          0B\n\n继续测试一下读取文件\ncore@localhost ~ $ time -p cat testfile &gt; /dev/nullreal 0.39user 0.00sys 0.27\n\n可以看到用时 0.39s，我们看下内存使用\ncore@localhost ~ $ free -h              total        used        free      shared  buff/cache   availableMem:          7.8Gi       382Mi       6.1Gi       199Mi       1.3Gi       7.0GiSwap:            0B          0B          0B\n\n然后我们再次执行一下读取文件\ncore@localhost ~ $ time -p cat testfile &gt; /dev/nullreal 0.17user 0.00sys 0.17\n\n可以看到用时缩短到了 0.17s，这里需要说明一下的时由于我这边是  固态硬盘，所以差距没这么大，如果是机械硬盘的话差距会进一步扩大。毕竟内存缓存肯定是更快的！\n\n\n版权声明：本文为 CSDN 博主「kunyus」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/kunyus/article/details/104617426\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【网络】http(s) 协议 | 介绍","url":"/posts/2885791654/","content":"已经学习过自己定制一个协议了，现在就来看看当下广泛使用的 http 协议吧\n\n\n1. 介绍\n超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在 TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。\n\nhttp 和 https 是当下最通用的协议之一，我们访问的大部分网页用的都是这个协议；\nhttps://www.bilibili.com/\n\n这两个协议主要的差别，那就是 http 是用明文传输数据的，我们的数据在互联网裸奔，可能有安全问题；相比之下，https 传输数据的过程会对数据进行加密，但这也不代表 https 是完全安全的。\n1.1 url要认识这两个协议，我们要从 url 的认识开始；\nHTTP(S) 不允许使用用户名或密码，一个合法的 HTTP(S) URL 格式如下：\nhttp(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;\n\n\n开头为协议名：http 或 https 协议； \n&lt;host&gt;：主机名。一个 URL 中，既可以使用域名也可以使用 IP 表示主机地址\n&lt;port&gt;：端口。主机名和端口之间使用冒号分隔。端口是可选的，如果省略将采用默认端口，http 默认端口是 80，https 默认端口 443；\n&lt;path&gt;：资源路径。资源在网络主机上的路径，路径也是可选的，缺省访问默认资源； \n&lt;query&gt;：查询参数。格式为 key&#x3D;value，多个参数使用 &amp; 分隔；参数也是可选的； \n&lt;frag&gt;：片段。从 # 开始到最后，一般用于定位到资源内的一个片段，比如文档的一个章节；片段也是可选的。\n\n1.1.1 栗子 ①接下来举一个具体的例子\nhttps://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile\n\n如上是我的个人博客中的一篇文章\n\n协议是 https\n域名是blog.musnow.top，对应的就是&lt;host&gt;:&lt;port&gt;；这里隐藏了端口，会在下面说明。\n/2022/08/07/note_linux/6gdb_g++_make_vim/这一长串都是文件的路径，其标示了文件在服务器上存放的位置\n这个 url 内没有带 &lt;query&gt; 参数\n#4-make-x2F-makefile对应的是 &lt;frag&gt; 片段，标识了我当前浏览的位置\n\n当你把这个 url 粘贴道浏览器，其会直接跳转到对应的标题位置，而不是这篇文章的页首；这就是 &lt;frag&gt; 片段的作用\n\n1.1.2 栗子 ②https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=test\n\n当我们在百度搜索单词 test 的时候，百度的 url 中就会出现 &lt;query&gt; 参数；\n其中 ? 是参数的开头，后续的一串以 &amp; 分隔的 kv 键值对，就是参数的内容。在这里面我们能看到word=test，我们查询的单词 test 就在这个参数后；\n我们的搜索访问，就是将这些参数传送给服务器，再由百度的服务器返回搜素结果的。\n1.2 域名和端口隐藏  但我们日常访问的网页中，很少见到过 ip: 端口 的形式，而大多是用域名为我们提供服务的\nhttps://www.bilibili.com/\n\n这并不代表其背后不需要端口号。而是因为如果我们的访问  不指定端口  的时候，http(s)协议会采用默认端口号 80 或 443，从而实现隐藏端口号提供服务\n\nhttp 默认端口是 80，https 默认端口 443\n\n毕竟对于用户而言，记住一个域名已经不容易了，还要记住你的服务是在哪一个端口，那就更难了；\n而域名也不是凭空给我们提供服务的，每一个域名都需要绑定一个具体的公网 ip（域名解析），才能为用户提供服务。在域名的背后，都是一个 ip，每一个 ip 也就是一台服务器。\n域名的作用，就是来隐藏掉 ip 这个无规律的长数字，方便用户访问；\n\n你觉得是记住 baidu.com 容易，还是记住 114.514.77.58 容易呢？\n\n在命令行使用 ping 工具，我们能知道一个网站服务器的 ip 是什么\nping www.bilibili.com\n\n比如我们 ping 一下 b 站的域名，可以看到其公网 ip 是183.131.147.29\n正在 Ping a.w.bilicdn1.com [183.131.147.29] 具有 32 字节的数据:来自 183.131.147.29 的回复: 字节 =32 时间 =10ms TTL=55来自 183.131.147.29 的回复: 字节 =32 时间 =12ms TTL=55来自 183.131.147.29 的回复: 字节 =32 时间 =12ms TTL=55来自 183.131.147.29 的回复: 字节 =32 时间 =12ms TTL=55183.131.147.29 的 Ping 统计信息:    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 10ms，最长 = 12ms，平均 = 11ms\n\n1.3 ip: 端口  我们可以用 ip: 端口 来访问自己的服务（以下 ip 纯属虚构，如有撞车，纯属巧合）\n114.514.77.58:8080\n\n当我们把这个粘贴道浏览器，再复制粘贴出来的时候，我们会发现前面多了一个 http\nhttp://114.514.77.58:8080\n\n这是因为当我们使用 ip 访问一个服务的时候，浏览器会默认采用 http 的协议去访问，所以在前面加了一个我们看不到的http://\n1.4 协议作用 http 协议的作用，就是向 服务器  申请特定的资源，再将资源拉取到本地进行展示 or 使用。\n资源都是存在我们的服务器上的，当用户请求的时候，服务器必须要知道资源的路径，将其 read 打开读取，再 write 写给我们的客户端。\n/2022/08/07/note_linux/6gdb_g++_make_vim/\n\n所以 http 的请求中才会带上资源的路径，这是方便服务器进行资源文件的读取；同时，文件的路径也是对一个文件的唯一标识，在告诉服务器文件路径的同时，也保证了我们请求的文件的唯一性，不会出现二义性；\n\n这时候又会出现一个问题，当我们访问网站的根目录的时候，没有提供文件的路径呀，那这时候，访问的什么文件呢？\nhttps://www.baidu.com/\n\n实际上，我们访问的是服务器根目录的 index.html 文件\nhttps://www.baidu.com/https://www.baidu.com/index.html\n\n你可以试着打开这两个链接，其出现的页面是完全一致的；\n\n类似于端口号隐藏，http 协议也确定了当下使用的网页文件的命名为 index.html，当我们访问一个网站的时候，就会默认访问根目录下的index.html 文件（既然是默认的，那就可以直接隐藏）如果这个文件不存在，那就不会渲染出我们看到的网页！\nindex.html 是用前端语言编写的网页代码\n\n同理，当我们访问博客的时候，读取道的也不是目录，而是目录下的 index.html 文件\nhttps://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/\n\n\n我的博客使用的是 hexo 框架，其网页的源路径在 github 上开源了，可以帮助你理解 url 中的文件路径。\n当前你看到的文件目录，就是博客服务的根目录。访问的博客首页，就是根目录下的index.html\n\n用作示例的 linux 工具使用 博客，也可以根据它的路径，找到 index.html 文件\n/2022/08/07/note_linux/6gdb_g++_make_vim/\n\n\n这便是 http 协议 url 中文件路径的作用！\n这里的 / 根目录是  服务端设置  的，并不一定是（大概率不是）服务端 linux 服务器的根目录\n\nhexo 博客已更新为绝对数字路径，本文中演示的路径已经无法访问\n\n1.5 编码解码  在 url 中，还会对一些特殊字符进行编解码，比如中文，和一些特殊的符号\nhttps://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile\n\n比如在作为示例的 url 中，这里出现了 x2F，而原文中是4.make/makefile; 这里的编码就是为了避免make/makefile 被识别成路径的标识符，从而出现错误。\nhttps://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=%E4%BD%A0%E5%A5%BD\n\n当 url 路径中有中文的时候，也会被转码成特定的格式\n\n我们在浏览器上看到的依旧是中文，这是因为浏览器这段帮我们进行了解码\n\n将需要转码的字符转为 16 进制，然后从右到左，取 4 位 (不足 4 位直接处理)，每 2 位做一位，前面加上 %，编码成%XY 格式\n\n2.http 协议请求格式  了解了 http 协议中的 url 网址，现在就可以进一步了解 http 协议的报头和报文了;\n一个 http request/response 的基本格式如下\n\n在请求中，客户端会提供自己的请求方法（GET&#x2F;POST&#x2F;PUT 等等），并提供 url 来标识自己需要的文件路径；这个 url 可能是短链接（截取根目录之后的部分），也有可能是完整的链接。\n随后，就会跟上一大堆的请求参数，注意，这里的请求参数并不是 url 中的 &lt;query&gt; 参数，而是 http 协议自身的请求参数。每一个请求参数都用了 \\r\\n 作为分隔，这和我们写的  自定义协议  中采用 \\t 进行分割是相同的原理！\n这几个部分中，请求的正文可以不带（为空）\n2.1 读取多长？为了让协议读取的时候，能够知道什么时候读取完毕了报头，http 协议提供了一个 \\r\\n 的空行，读取道这个空行，就代表报头读取完毕了，剩下的内容都是报文。\n而为了标识报文的长度，http 协议会在发送的时候提供一个参数 content-length，用于标识报文的长度。在读取完毕报头后，肯定是读取到了这个content-length 参数的，也就知道后续应该继续读取多长，才能读完整个协议字段！\n关于这部分的介绍，可以查看另外一篇博客 http 协议 content-length 详解\n2.2 响应的状态码  和我们进程的退出状态一样，http 也表明了一部分响应的状态码，其中我们日常最常见到的，是 404/403 这两个状态码\n\nhttp 状态码 - 百度百科\n\n状态码就是标识服务器提供的服务状态，告诉客户端它的请求是否成功了。如果状态码是 200，代表请求是成功的。其余状态码会有各自的使用场景，比如 404 状态码，代表请求的资源不存在，所以才叫 404 not found!\n3. 实例  完整代码详见 Gitee\n3.1 前端页面  由于本人并没有学习过前端语法，这里采用 菜鸟教程 提供的前端示例代码来演示\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 (runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; 我的第一个标题 &lt;/h1&gt;&lt;p&gt; 我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n我们日常所访问的网页都是这样的代码，经由浏览器进行渲染，再展示出来\n3.2 服务端代码  由于 http 是基于 tcp 的，这里直接把之前写的 tcpServer 搬过来就能用！具体的代码解析请看注释，想必说的是很清楚的\n#define CRLF &quot;\\r\\n&quot;#define CRLF_LEN strlen(CRLF)#define SPACE &quot; &quot;#define SPACE_LEN strlen(SPACE)#define HOME_PAGE &quot;index.html&quot; // 首页文件#define ROOT_PATH &quot;web&quot; // 网址根目录地址// 获取 http 请求中的路径string getPath(string http_request)&#123;    size_t pos = http_request.find(CRLF);// 找到第一行的分隔符    if(pos == string::npos)         return &quot;&quot;;    string request_line = http_request.substr(0, pos);// 取出第一行    // 请求的第一行：GET /a/b/c http/1.0    size_t first = request_line.find(SPACE);// 找到第一个空格    if(pos == string::npos)         return &quot;&quot;;    size_t second = request_line.rfind(SPACE); // 从后往前找空格    if(pos == string::npos)         return &quot;&quot;;    // 找到两个空格了，两个空格之间的就是请求的路径    string path = request_line.substr(first+SPACE_LEN, second - (first+SPACE_LEN));    // 对 path 进行判断，如果 path 是以 / 结尾的，则在 path 中追加 index.html 文件名    if(path[path.size()-1] == &#x27;/&#x27;) &#123;        path += HOME_PAGE; // 加上被隐藏的 index.html 文件名    &#125;    return path;&#125;// 读取文件string readFile(const string &amp;recource)&#123;    ifstream in(recource, ios::binary);    if(!in.is_open()) // 文件打开失败    &#123;        return &quot;404&quot;;    &#125;    // 内容    string content;    string line;    while(getline(in, line))    &#123;        content += line;    &#125;    in.close();    return content;&#125;void handlerHttpRequest(int sock)&#123;    cout &lt;&lt; &quot;###########start#############&quot; &lt;&lt; endl;// 打印一个分隔线    char buffer[10240];    ssize_t s = read(sock, buffer, sizeof(buffer));    if(s &gt; 0)&#123;        cout &lt;&lt; buffer &lt;&lt; endl;        cout &lt;&lt; &quot;###########end############&quot; &lt;&lt; endl;    &#125;    string path = getPath(buffer);    // 假设用户请求的是 /a/b 路径    // 那么服务端处理的时候，就需要添加根目录位置和默认的文件名    // &lt;root&gt;/a/b/index.html    // 在本次用例中，根目录为 ./web 文件夹，所以完整的文件路径应该是    // ./web/a/b/index.html    string resources = ROOT_PATH; // 根目录路径    resources += path; // 文件路径    logging(DEBUG,&quot;[sockfd: %d] filePath: %s&quot;,sock,resources.c_str()); // 打印用作 debug    string html = readFile(resources);// 打开文件    // 开始响应    string response = &quot;HTTP/1.0 200 OK\\r\\n&quot;;    // 如果 readFile 返回的是 404，代表文件路径不存在    if(strcmp(html.c_str(),&quot;404&quot;)==0)    &#123;        response = &quot;HTTP/1.0 404 NOT FOUND\\r\\n&quot;;    &#125;    // 追加后续字段    response += &quot;Content-Type: text/html\\r\\n&quot;;    response += (&quot;Content-Length: &quot; + to_string(html.size()) + &quot;\\r\\n&quot;);    response += &quot;\\r\\n&quot;;    response += html;    // 发送给用户    send(sock, response.c_str(), response.size(), 0);&#125;\n\n3.3 测试  启动服务器之前，请先打开你的云服务器防火墙中的对应端口；这里我绑定的是端口 10000，在浏览器中用 ip: 端口 的方式可以正常访问！\n\n这里标识的  不安全  是因为我们没有采用带加密的 https 协议，这不是当下需要考虑的问题。不管他就可以了。\n按 F12 打开开发者页面，可以看到下方出现了完整的 html 代码，我们成功提供了服务！\n\n3.4 后端打印的报文  在服务器后端，我们看到其打印出来了一个基本的 http 请求，和上面说明的格式是一样的。这里简单的进行一部分说明：\n\nGET：请求方式为获取数据\n/：请求的是根路径\nHTTP/1.1：使用的 http 协议版本\nConnection：代表我们和服务器的链接方式，keep-alive 代表保持连接\nUser-Agent：客户端信息，可以看到是 windows 系统、Chrome 内核的浏览器（我是用的是 edge 浏览器）\nAccept: 支持接收的信息类型\nAceept-Encoding: 对信息进行压缩\nAccept-Language：支持的语言\nCookie：身份信息，后面会详细介绍\n\n其中出现了一个空行，代表报文结束；\n\n往下滑，会发现浏览器还发出了第二个请求，路径是/favicon.ico，这是默认的站点头像文件的命名。因为我们的 html 文件中没有写明站点头像的路径，所以浏览器就尝试请求默认的头像文件\n但是，当前我们的站点根目录 web 下并没有该文件，应该返回一个 404 状态码。\n\n请求中出现了一个新的参数 Referer，代表是从当前网页请求头像的。相比之下，请求网页的报文中没有Referer 参数\n\n\n此时可以随便找个图片做头像，看看能不能加载出来；为了方便，我随便找了一张纯绿色的图片，并将其  在线转换为 ico，放入了站点的根目录。\n重启服务器进程，刷新浏览器再次请求，可以看到成功出现了站点的头像；\n\n3.5 常见参数表\n4. 请求方法  一般我们获取一个网页，用的都是 GET 方法。接下来用一个带按钮的表单创建请求，尝试向服务端发送 &lt;query&gt; 参数\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 (runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; 我的第一个标题 &lt;/h1&gt;&lt;p&gt; 我的第一个段落。&lt;/p&gt;&lt;form action=&quot;/a/index.html&quot; method=&quot;get&quot;&gt;    Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;    Password: &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.1 GET在 method 里面，我们指定了 get 方法，此时\n&lt;form action=&quot;/a/index.html&quot; method=&quot;get&quot;&gt;    Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;    Password: &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;\n\n此时页面中出现了两个输入框，供我们输入密码，且密码会显示为 **** 而不是明文\n\n点击按钮，会跳转到一个 404 页面，这是因为我们的 a/index.html 路径并不支持参数请求，所以发送了 404 错误码\n\n不过这不重要，我们看看后端打印的内容。其中参数是追加到 url 中，以明文传输过来的；正文部分为空，并没有携带参数\n\n4.2 POST将请求方法改成 post，再次尝试\n&lt;form action=&quot;/a/index.html&quot; method=&quot;post&quot;&gt;    Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;    Password: &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;\n\n这时候能正常显示出 a/index.html 页面，url 中不再带有参数\n\n此时查看后端中的信息，能看到请求方法变为 POST，参数出现在了正文部分，而不是 url 中\n\n4.3 GET&#x2F;POST 区别  这也是 GET 和 POST 方法的区别之一：\n\nGET 方法通过 url 传参\nPOST 方法会将 url 参数提取出来，拼接到正文部分\n\n由此能推出二者的安全性区别\n\nGET 方法相对不安全，因为参数直接以明文贴在了 url 上\nPOST 方法以正文传参，使用 https 协议的时候能进行加密，相对较安全\n\n4.4 更多方法http 请求还支持更多方法，如下\n\n5. 状态码 5.1 状态码表 下面是一个响应状态码的总表\n\n5.2 404&#x2F;403 状态码  我们能看到 404 和 403 都是客户端状态码，为什么说是客户端错误呢？这是因为你向服务器请求了一个服务器没有的资源，这个问题不应该是服务器的问题。\n这就好比你去西瓜摊买肉，人家压根不卖肉。问题出在你身上，你不应该找西瓜摊老板买肉。所以 404 状态码，应该是客户端的问题！\n而 403 状态码的含义是403 forbidden，服务器拒绝了你的请求（你没有权限访问）这也是客户端的问题。你不能去超市买东西，然后问老板能不能让你看看老板的钱罐子。老板肯定不给你看啊！所以才会告诉你 403，不给你访问。\n5.3 5xx 状态码  什么时候会出现服务器错误的 5xx 状态码呢？\n当你请求一个服务，服务端需要处理之后给你返回结果。此时服务器在处理过程中，可能因为程序有 bug 提前退出，这时候就应该给客户端发送一个 5xx 状态码，标识服务器在处理你的请求的过程中，出现了错误，无法返回结果。\n5.4 301&#x2F;302 重定向  关于 3 开头的状态码，主要谈谈下面这两个\n301 永久重定向302 临时重定向\n\n为何一个是永久，一个是临时呢？\n在 http 进行响应的时候，服务端可以发送一个 location 参数，发送一个新的 url 给客户端；我们的浏览器在收到这个参数后，会自动打开对应的页面\nLocation: https://www.baidu.com/\n\n我们可以用上面的代码来测试一下\n// 尝试进行 302 重定向string response = &quot;HTTP/1.1 302 Temporarily moved\\r\\n&quot;;response+= &quot;Location: https://www.baidu.com/\\r\\n&quot;;response+= &quot;\\r\\n&quot;;// 发送给用户send(sock, response.c_str(), response.size(), 0);\n\n此时访问我们自己的IP: 端口，会跳转到百度的页面。这就是重定向的作用\n\n\n那临时重定向和永久重定向有什么区别呢?\n\n假如我设立了一个公开站点，域名是test.com，这几年一直提供服务，积累了一部分的用户。过了一会，我不想要这个域名了，想换一个test.cn；可用户已经有那么多，大家都只记得你的test.com，如果直接更换域名，就会导致用户无法访问test.com，以为你跑路了，就放弃使用你的网页。\n这样的结果显而易见：严重的客户流失！\n所以，为了避免这个问题，我可以先将服务迁移到 test.cn 新域名，在旧域名 test.com 中设置一个 301 重定向到 test.cn，告诉用户我换新域名了。这样持续一段时间后，等到test.com 的使用者不多了，就可以考虑彻底取消 test.com 的解析，关停此域名了。\n在上面的场景中，我是需要更换域名，是永久更换。我们就应该把状态码设置为 301，告诉客户端这个域名将被永久重定向到另外一个域名上\n\n另外的情况是，我有一个 example.com 域名，我的服务需要进行维护；此时就将 example.com 重定向到另外一个域名example.cn，指向另外一个服务器，让这个服务器临时提供服务。\n服务维护完毕后，就将重定向取消，继续使用当前的服务器。\n这个场景中，重定向只是维护期间的一个临时策略，所以状态码设置成 302，告诉客户端我只是临时进行重定向，我还会回来的。\n6.cookie&#x2F;session日常生活中，当我们在一个 web 页面中登录了（如 github&#x2F;gitee&#x2F;csdn）这个网页在很长一段时间内都会保持登录，直到超时亦或者是出现了异地访问。\n假如你现在有个网页，但是每次用户访问的时候，都需要重新输入用户名和密码，刚刚输入过了，换一个页面又不行了。这样一来，用户还会想用你这个服务吗？\n为了避免此类问题，http 协议就需要引入其他的参数，来维持用户的登录会话。cookie&#x2F;session 便是因此而来的。\n6.1 set cookie服务端可以在响应头中带上 Set-Cookie 字段，给客户端设置上 cookie\nresponse += &quot;Set-Cookie: This is my cookie test\\r\\n&quot;;\n\n打开 f12 开发者界面，能在其中看到我们设置的 cookie\n\n再次刷新网页，可以看到在之后的请求中，浏览器都会发送一次服务器设置的 cookie。这样服务端在收到 cookie 后，就能解析到自己设置的 cookie，确定了指定的用户\n\n在服务器端也能看到这个字段\n\n6.1.1 cookie path对于 cookie 来说，其还有一个路径的配置项。见下图，我在实现我的视频点播系统的时候，在 /usr/login 处直接用了如下 header 来 set-cookie\nrsp.set_header(&quot;Set-Cookie&quot;,&quot;sid=123456&quot;);// 如上语句是 httplib，等价于// Set-Cookie: sid=123456\\r\\n\n\n\n这就导致我对我的视频点播其他界面中的操作并没有携带上我自己 set 的这个 cookie，也就没有办法实现后续的 seesion 识别（这里我写死了是因为还在初始测试阶段）\n我们要做的就是在 cookie 后面携带一个 path，来告诉浏览器这个 cookie 应该是全局的\nSet-Cookie: sid=123456; path=/\n\n这样才能实现后续整个网站的请求都会带上这个 cookie，否则只有请求 /usr开头的路径才能带上这个 cookie\n\n如上图，这样设置了后，cookie path 已经是/ 代表根路径了\n\n6.2 什么是 cookie所谓 cookie，其实就是浏览器帮我们存取了一定的身份信息在本地（内存 or 磁盘）\n下一次打开特定的网页的时候，就能显示对应的身份信息（不一定是你的账户密码），并告诉服务器，服务器就识别到了你当前的用户，并为你保持登陆状态。\n既然是保存在用户本地的，那就有可能被窃取。一些恶意软件就会去扫描你浏览器本地缓存中的 cookie 信息，对于一些安全性不高的网站而言，有了这个 cookie，就相当于他有了你的账户，可以直接登录你的账户进行操作。\n因此，引入了另外一种身份认证的方式 cookie+session\n6.3 cookie+session比起将身份信息存到客户端，存至服务端更为安全（攻击企业服务器的成本，比在用户端植入木马程序的成本更高）\n\n用户使用账户密码请求登录，服务器收到登录请求，验证成功后，给客户端返回一个  唯一字符串 session_id来标识用户\n客户端下一次请求的时候，带上了这个唯一字符串\n服务器收到请求，在本地的 session_id 库中查找这个 id，找到后，就将用户信息匹配给客户端，相当于客户端登录成功了\n\n这样，就将原本存在用户本地的身份认证信息，存到了服务端中。客户端就只剩下一个孤零零的字符串 id，不会有用户的私密信息。即便丢失，也不会影响用户的隐私。\n\n你可能会说，那我偷走这个 id 不也是一样的效果？\n\n其实没有那么简单，服务端可以将 session_id 和用户的 ip 或者终端 User-Agent 绑定，这样只要用户  切换设备  或者  换了登录的地点 （比如从三亚跑到了哈尔滨）就直接让session_id 失效，要求用户重新登录。\n7. 长短链接  在早期的 http 协议中，采用的都是短链接，一次连接只能处理 1 次 http 请求。当时的网页大多以文字为主，数据量很小，一起请求也能够满足需求。\n但现在时代已经变了，一个网页里面有图片，文字，音频，视频。这些文件的体积打起来之后，短链接的方式就不适用了。此时就出现了长链接，一次 tcp 链接，可以持续传输数据。\n相比短链接，长链接连上之后，能持续传输数据，避免了 tcp3 次握手的消耗，提高了数据传输的效率！\n7.1 Connection在本文的 3.4 中，便出现了这个参数，一般情况下，会有下面两种情况\nConnection: keep-aliveConnection: closed\n\n其中 keep-alive 就是长链接，closed代表当前端口只支持短链接。\n当客户端发送的请求头中包含 Connection: keep-alive 字段，如果服务器支持长链接，就需要在响应头中也带上Connection: keep-alive\t，这样双方协商成功，大家都可以使用长链接。\n如果服务器的响应头中没有带Connection: keep-alive，那么客户端就会认为服务器不支持长链接，下次请求的时候，会重新向服务器链接，再获取资源。\n如果客户端和服务端任意一方的响应头中包含Connection: closed，那么就会认为当前的会话只支持短链接，下次请求会重新建立链接。\n7.2 http 和 tcp 的关系http 虽然是基于 tcp 的，但 http 本身是无链接的。\n\n举个最明显的栗子，在你打开一个网页之后，你关闭掉自己的 wifi，你的网页并不会因此消失。只是无法进行后续操作而已。\n\nhttp 是一个无链接的应用层协议，其借助 tcp 进行数据的流式传输，但不一定需要客户端和服务端保持连接。\n所以，http 就可以借助单个 tcp 套接字  持续的传输数据，也就天然地支持了长链接通信。\n总结一下，http 只是借用了 tcp 的能力，其无连接的特性和 tcp 没有关系！\n7.3 pipeline这其中会牵扯到一个 pipeline，其维护了 http 长链接请求时的 响应顺序。\n比如人家需要加载一个网页，服务端应该先把网页的整体框架给用户加载出来，再给用户加载图片、视频、音频等资源。下图 B 站的加载就是一个很好的栗子。\n\n否则乱序了，比如只出现了一个孤零零的图片，就会让人感觉非常奇怪。\n8.https因为 http 的数据是无加密明文发送的，相对来说并不是非常的安全；为了实现数据加密，https 在 http 的下层添加了一个 SSL/TLS 软件层，来进行数据加解密工作\n\n8.1 为啥要加密？要知道，所有的加密工作，都是为了防止数据在中间传输的过程，被窃取或修改。如果我们请求一个网站登录的时候，数据包中就会包含我们的账户密码。如果被窃取，我们的隐私就泄露了。这是很难受的一件事！\n\n这也是为什么，我们经常能听到  免费公共 wifi 不安全  这一说法，因为我们在这个 wifi 上进行的所有数据交换，都会走这个 wifi 的路由器，很容易被  中间人  窃取并获取到我们的数据包。\n这种情况下，https 的加密就更有必要了！\n\n但是，加密解密是需要时间的，所以 https 响应的速度会稍慢于 http。不过当下 cpu 的执行速度已经非常快，这点时间差距很小，不会特别影响我们的日常使用！\n不过，加密并不是一个万金油，并不是说加密了之后的数据就一定能避免被窃取。但加密可以大大提高窃取破解的成本，无形中降低了数据被窃取的概率，保证了一定的数据安全。\n8.2 常见加密方式 8.2.1 对称加密 所谓对称加密，好比有一个带锁的盒子，客户端和服务器都有一把钥匙。客户端先把信息丢进盒子里，再用🔑锁上盒子，发送给服务端。服务端用🔑打开盒子，取出数据。\n因为客户端和服务器持有的钥匙是完全一致的，所以被称为对称加密。在加密的场景下，钥匙一般被称为  密钥\n在网络场景里，对称加密是不可取的。只要客户端和服务端传输密钥的时候被窃取，那么双方的加密就失效了。因为是用同一个密钥来加密解密，我拿走了你的钥匙，自然就能打开你这把锁。\n也就是说，密钥的传输也需要加密 。但是这又引出一个问题，我都没有你的密钥，我怎么解密你发过来的密钥信息？这是一个 先有蛋还是先有鸡  的死循环！\n8.2.2 非对称加密  非对称加密场景下，会有一个公钥和私钥\n\n私钥对数据加密，变成密文\n公钥对数据解密，变成明文\n\n二者也可以反过来\n\n私钥对数据解密\n公钥对数据加密\n\n其中最常用的非对称加密，也就是我们在 git 的 ssh 操作 中使用过的 rsa 密钥，其中就有一个 .pem 公钥和一个私钥。我们将公钥提供给 github，私钥保存到本地，就能实现无密码上传数据到 git 仓库。\n\n但是非对称加密还是会存在中间人攻击的问题。先看如下图，你应该能发现，其中有一个重要的环节，就是服务端要把公钥发送给客户端\n\n在这个场景中，公钥是  公开传输给客户端  的，也就是后续服务器发送给客户端的所有信息，都可以被其他人用这个  公钥  解析出来；\n整个环节中，只做到了客户端发送给服务器的信息安全，因为只有服务器拥有私钥，能解密出数据。（单项数据安全）\n8.2.3 双非对称  这时候，我们可以采用双非对称密钥加密的方式！既然非对称只能保证单方的数据安全，那使用两个非对称，不就能保证双方数据安全了嘛！\n\n客户端和服务端交换公钥a&#39; 和 b&#39;\n客户端给服务端发信息：先用 a&#39; 对数据加密，再发送；只能由服务器解密，因为只有服务器有私钥 a\n服务端给客户端发信息：先用 b&#39; 对数据加密，再发送；只能由客户端解密，因为只有客户端有私钥 b\n\n\n因为两份私钥都只有客户端和服务器自己拥有，所以黑客没有办法进行数据的窃取，也就保证了数据的安全。\n即便中间人  替换了交换的公钥 ，也会因为后续的通信，客户端 or 服务端 本地的私钥  无法正常解密，而发现数据被窃取！\n但是但是，这样左还算有很大的  缺点\n\n效率太低（非对称加密解密负载太高，效率低下，特定场景下无法满足要求）\n依旧可能存在安全问题\n\n8.2.4 非对称 + 对称\n服务端具有非对称公钥 S 和私钥 S’\n客⼾端发起请求，获取服务端公钥 S\n客⼾端在本地生成对称密钥 C, 通过公钥 S 加密, 发送给服务器.\n由于中间人没有私钥，即使截获了数据，也无法还原出内部的原文，也就无法获取到对称密钥\n服务器通过私钥 S&#39; 解密，还原出客户端发送的对称密钥 C，并且使用这个对称密钥加密给客户端发送的响应数据\n后续客户端和服务端都采用密钥 C 来进行对称加密通信\n\n因为对称  密钥 C 在传输过程中是加密  的，只有客户端和服务端知道密钥是什么，也就实现了数据的安全通信！\n8.3 数据摘要（指纹）数字指纹 (数据摘要)， 其基本原理是利⽤单向散列函数(Hash 函数) 对信息进行运算，生成⼀串  固定长度  的数字摘要。\n常见的摘要算法有 MD5/SHA1/SHA256/SHA512 等；\n数字指纹并不是⼀种加密机制，但可以用来判断  数据有没有被窜改，亦或者是下载的数据包有没有出现损坏。\n\n同一个数据文件，用同一个方法生成的数据摘要是一致的\n不同文件生成的数据摘要可能会撞车，但几率极低，可以认为具有唯一性！\n我们无法用数据摘要反推出数据内容（怎么可能用一个字符串推测出原本的内容呢？那样还存放源文件干哈？😂）\n\n数据摘要在网盘产品中也有使用，当我们使用  百度云盘、阿里云盘  的时候，会遇到一个大的资源文件只用了  短短几秒  就成功上传到服务器的情况。此时，我们并不是真的用几秒就把数据传输上去了，而是经历了以下阶段\n\n网盘客户端对本地文件生成数据摘要\n生成后，判断服务器端  已有文件  中，是否有同该数据摘要相同的文件\n如果有，代表该文件已经存在了云盘的服务器中\n服务器将该文件给你的账户建立一个  软链接 &#x2F; 硬链接，就实现了&quot; 妙传 &quot;\n如果没有，则老老实实的从本地上传文件到云盘\n\n云盘厂家这么做的原因很简单：避免同一份文件被多次存储。当下网盘给用户的免费空间动则上 T，如果所有文件都重复保存，那对于云服务器厂家来说，资源消耗太大了。\n这个做法并不会产生数据隐私问题，一般只有电影等资源文件才有可能妙传成功。你可以使用一些 “其他手段”，比如把资源打个压缩包，并在压缩包中随便丢另外一个文件，让文件的数据指纹和已有资源不相同，就不会进行 妙传  了。\n\n这样做还有另外一个好处，那就是原资源因为违规被 ban 的时候，你的资源不会被  连坐😂\n\n8.4 数字签名  对数据摘要进行  加密 ，生成的内容被称为 数字签名\n8.5 中间人攻击  中间人攻击（Man-in-the-MiddleAttack），简称MITM 攻击\n以 8.2.2 的单非对称加密为例，中间人可以在整个过程中进行  偷梁换柱，窃取双方的信息。如下图：\n\n透过这个栗子🌰，实际上，如果中间人在客户端和服务端  开始通信之前  就来窃听并  准备换柱  了，他就有可能替换双方密钥，从而解密双方发送的信息！\n最重要的一点，是客户端 or 服务端  都没有办法证明 ，当前的公钥是直接从服务端 or 客户端发来的，它们没有办法检验公钥的权威性，只能被动接受。由此给中间人 偷梁换柱  提供了可能。\n这时候，就需要引入 CA 机构和 CA 证书了👇\n8.6 CA 证书  所谓 CA 证书，是由 CA 机构 颁发的权威证书。CA 机构在颁发证书时，会在证书中附带上该站点的域名，以及申请人（企业）的相关信息\n\nCA 机构会有一个自己的私钥和公钥，其公钥向  所有人  公开\nCA 机构的私钥由其自己保存（私钥一定不能泄露）\n当下的浏览器、操作系统都会内置认可的 CA；只有被认可的 CA，才能为站点提供 ssl 证书服务\n\n在我们 windows 本地就能看到当前操作系统认可的 CA 机构其公钥；在 edge 浏览器中，点击右上角选择，进入设置，在选择隐私页面，找到  管理证书\n\n点击它，就能看到当前本地认可的 CA\n\n8.6.1 ssl 证书加密原理  当一个站点获取了 ssl 证书后，在向用户发送 ssl 证书中包含的公钥的同时，还会发送一个  由 CA 机构  对 ssl 证书公钥做的  数字签名\n\nssl 证书公钥的数字签名 A，通过 CA 机构的  私钥  进行加密\nssl 证书的公钥 B\n\n当客户端收到这份信息之后，会采用 hash 函数对收到的 ssl 证书公钥进行数字签名，得到一个  本地生成的数字签名 C\n再用 CA 机构的公钥对传输过来的数字签名 A 进行解密，得到数字签名 A 的明文；判断由 CA 机构生成的 ssl 公钥数字签名 A 是否和本地生成的数字签名 C 相同；\n\n如果相同，则代表证书正确！\n不相同，代表证书出现错误！\n\n画个图，大概就是下面这样\n\n由于当下发送的数据包中，同时存在 ssl 公钥的明文 + 由 CA 机构加密后的数字签名，中间人无法进行任何攻击修改！\n\n若修改 ssl 公钥，由于中间人没有 CA 机构的私钥，无法对修改后的 ssl 公钥生成对应的加密后数字签名\n若使用 CA 公钥解密数字签名后修改……依旧会因为没有 CA 机构私钥，无法把修改后的签名加密回去\n如果中间人用自己的私钥生成一个数字签名，但我不认识你这个 CA，也不知道你的公钥是什么，怎么解密你的信息呢？\n\n综上，中间人要想偷梁换柱，只有一个办法了，那就是拿一个  真的证书  整体替换掉这个数据包。\n可是 ssl 证书中还包含了  域名、站点主体  等各类信息，我当下访问的是 baidu.com，结果收到的证书是qq.com 的，那肯定有问题啊！浏览器会直接拒绝访问！😂\n当我们访问一些网站，浏览器报 ssl 证书过期，也是会出现一定的安全问题的！如果一个网站没有使用 https，那么在这个网站上进行用户登录等敏感操作的时候，一定不要设置和你其他平台相同的密码！\n\n当然，如果某个网页本来就只是提供文件公开下载功能的，比如下载 linux 系统的 iso 镜像，那么它不套用 https 也是情有可原的，因为压根没有必要！\n\n8.6.2 ssl 证书 + 非对称 + 对称  有了上面这个不能被篡改的 ssl 证书公钥，下面我们就可以利用  非对称 + 对称加密  的方式进行通信了\n\n客户端收到 ssl 证书，向服务器发送一个本地生成的  密钥 D（使用 ssl 证书公钥进行加密）\n服务端收到  密钥 D的加密信息，使用 ssl 证书的私钥进行解密，获取到密钥 D\n客户端和服务端使用  密钥 D进行对称加密通信\n\n这样即解决了安全问题，又规避了非对称加密的效率问题，一举多得！\n9.Content-Type9.1 问题  之前写的 http 服务器有一个很大的弊端，就是 Content-Type 没能做到根据文件的格式进行自定义修改\n默认情况下，如果 index.html 中没有指定 icon 的路径，浏览器会自动请求根路径下的favicon.ico，如果没有这个文件，则不显示站点图标。\n如果在 index.html 有指定站点 icon 的路径，则会请求对应路径的图片。\n如下图，我在 index 中指定了 icon 的路径\n&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;http 协议学习&lt;/title&gt;&lt;link rel=&quot;shortcut icon&quot; href=&quot;https://img.musnow.top/i/2022/12/icon.png&quot;&gt;&lt;/head&gt;\n\n但是浏览器去请求的时候，返回的文件类型依旧是 text（因为已经写死了）\n\n最终结果就是，配置的 icon 无效，依旧不显示站点图标\n\n所以，我们应该在服务端给返回的文件添加上正确的Content-Type\n9.2 代码  为了访问支持多种文件类型，我在 tcpServer 的类中新增了一个 map，用于文件后缀和图标类型的对照。每每看到这个场景，我都想感慨一下：Python 的 dict 还是方便多了🤣\nvoid initMap()&#123;    _fileTypeMap.insert(&#123;&quot;html&quot;,&quot;text/html&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;jpg&quot;,&quot;image/jpeg&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;jpeg&quot;,&quot;image/jpeg&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;png&quot;,&quot;image/png&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;gif&quot;,&quot;image/gif&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;ico&quot;,&quot;image/x-icon&quot;&#125;);&#125;// 文件类型和 http 响应头的对照表map&lt;string,string&gt; _fileTypeMap;\n\n在设置 Content-Type 的时候，先从 path 中分离出客户端请求的文件类型\n// 获取文件的后缀string getFileType(const string&amp; path)&#123;    size_t i = path.rfind(&#x27;.&#x27;);    if(i!=string::npos)// 找到了    &#123;        string filetype(path,i+1);// 获取出文件类型        logging(DEBUG,&quot;Path: %s | fileType: %s&quot;,path.c_str(),filetype.c_str()); // 打印用作 debug        return filetype;    &#125;    return &quot;&quot;; // 没有后缀&#125;\n\n需要注意的是，一些 http 请求是这样的\nhttps://web.musnow.top/about/\n\n后端会收到这样的 path\n/about/\n\n这个 path 里面并没有文件名，而本文前面提到过，如果请求的链接中没有指明文件，那就给客户返回对应路径下的 index.html 文件。如果这个路径下没有 html 文件，则返回 404。这一步在分离请求头中的 path 时已经做了\n// 对 path 进行判断，如果 path 是以 / 结尾的，则在 path 中追加 index.html 文件名if(path[path.size()-1] == &#x27;/&#x27;) &#123;    path += HOME_PAGE; // 加上被隐藏的 index.html 文件名&#125;\n\n回到正题，在获取到文件后缀后，就可以在 map 里面查找对应的 content-type 了\n// 追加正确的文件类型 Content-Typeresponse += &quot;Content-Type: &quot;;string contentType = &quot;text/plain&quot;;auto it = fileTypeMap.find(fileType);if(it != fileTypeMap.end())&#123;    contentType = (*it).second;&#125;response += contentType;response += &quot;\\r\\n&quot;;\n\n但是，这样还是出现了问题，图片没办法正常加载\n\nF12 打开开发者面板，可以看到服务器返回的响应头是正确的，但是依旧无法显示出图片\n\n这是因为读取图片和读取 html 文件的操作是不一样。在读取 html 文件的时候，采用的是按行读取的策略\n// 读取 txt 文件string readTxtFile(const string&amp; file_path)&#123;    // 如果是文件存在但是打开失败了，应该返回 50x 代表服务器处理错误    // tcp 是面向字节流的，文件需要用二进制打开    ifstream in(file_path, ios::binary);    if(!in.is_open()) // 文件打开失败    &#123;        return &quot;503&quot;;// 文件打开失败    &#125;    // 内容    string content;    string line;    while(getline(in, line))    &#123;        content += line;    &#125;    in.close();    return content;&#125;\n\n但是图片文件应该需要一个完整的二进制流，而不是按行读取\n// 读取图片文件string readImgFile(const string&amp; file_path)&#123;    ifstream file(file_path, ios::binary);    // 打开失败，503    if (!file.is_open()) &#123;        return &quot;503&quot;;    &#125;    ostringstream ss;    ss &lt;&lt; file.rdbuf();    string content = ss.str();    file.close();    return content;&#125;\n\n为了区别图片和 html 文件，我新增了一个用于判断文件后缀的函数\nconst string imageType[] = &#123;&quot;png&quot;,&quot;jpg&quot;,&quot;gif&quot;,&quot;jpeg&quot;&#125;; // 图片类型// 判断请求头中文件类型是否为图片bool isImg(const string&amp; fileType)&#123;    for(auto&amp; t: imageType)    &#123;        // 如果完全一致        if(fileType == t)        &#123;            return true;        &#125;    &#125;    return false;&#125;\n\n最终合并成同一个函数\nstring readFile(const string &amp;file_path,bool is_img = false)&#123;    // 其实这里应该分两种情况，一种是文件不存在，一种是文件打开失败了    // 如果是文件不存在，应该返回 404    if(access(file_path.c_str(),0)!=0)// 判断文件是否存在，存在返回 0    &#123;//windows 下相同作用的接口为_access，头文件 io.h        return &quot;404&quot;;// 文件不存在    &#125;    // 读取对应的文件    if(!is_img)&#123;        return readTxtFile(file_path);    &#125;    else&#123;        return readImgFile(file_path);    &#125;&#125;\n\n在服务函数里面，也做出了区别\n// 获取文件的后缀string fileType = getFileType(path);// 打开文件string content = readFile(resources,isImg(fileType));\n\n再次测试，成功！\n\n主页 html 文件中配置的 log 也正常显示出来了！（和原来的颜色不一样）\n\n","categories":["玩上Linux"],"tags":["Linux","网络","http"]},{"title":"【图床】博客表情包","url":"/posts/4215614474/","content":" 这里是博客中可以用到的表情包列表，一并上传，避免多次上传占用阿里云空间;\n 大家觉得不错的可以保存下来😁但是不要恶意使用！\n\n\n 表情包 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["图床"]},{"title":"【Linux】udp | tcp | 协议详解","url":"/posts/4287572457/","content":"本文带你详细了解 tcp 协议的相关知识\n\n\n\n本文中部分截图为手写，字丑见谅\n\n1.linux 下常用网络命令cat /etc/servcies # 系统常用服务和端口\n\n我们自己写网络服务器进程时，绑定的端口不能和系统端口冲突。尽量绑定 1024 以上的端口，推荐绑定不常用的 5 位数端口。\n绑定低于 1024 的端口，会出现权限不足的报错\n$ ./tcpServer 100DEBUG | 1679473830 | muxue | socket create success: 3FATAL | 1679473830 | muxue | bind: Permission denied:3\n\n1.1 netstat 命令netstatnetstat -l # 只列出 listen 状态服务netstat -n # 将显示的信息用数字（id）代替netstat -p # 显示端口和进程 pid 的关联netstat -t # tcpnetstat -u # udpnetstat -a # 显示所有服务\n\n1.2 pidof获取某个进程名的进程 pid\npidof 进程名\n\n比如我想查看 sshd 的进程 id\n$ pidof sshd20706 20703 10775 6067 6009 3339 3338 3272 3269 1340\n\n2.udp 协议  一下为 udp 报文格式的结构图\n\nudp 采用了定长报文，这也是 udp 面向数据报 的\n\nudp 采用 16 位作为 ip+ 端口的存放，源端口和目的端口用于数据的  解包分用（系统需要知道当前的数据包应该丢给上层的哪一个端口）\n16 位 udp 长度，表示整个数据报 udp 首部 +udp 数据 的最大长度\n16 位校验和用于校验报文是否出现错误。如果校验和出错，就会直接丢弃报文\n\n由于 udp 的长度标志位只有 16 位，所以一个 udp 报文能传输的最大数据是64kb (216)\n如果需要用 udp 传输大于 64kb 的数据，则需要在  应用层  进行拆分，在接收方的  应用层  进行合并。\n2.1 理解报头  所谓报头，其实就是操作系统内核中的一个 C 语言的结构体。\n// 示例，不代表真实情况//udp 报头采用了位段struct udp_hdr&#123;    unsigned int src_port:16;    unsigned int dst_port:16;    unsigned int udp_len:16;    unsigned int udp_check:16;&#125;\n\n添加报头的本质，其实就是给数据的头部添加上一个 struct udp_hdr 结构体；\n而解包的时候，也是将指针移动固定长度（8 个字节）的空间，将指针强转为struct udp_hdr，即获取到了当前报文的 udp 报头\n2.2 udp 的特点 udp 传输的过程类似于 飞鸽传书\n\n无连接：知道对方的 ip: 端口 就能直接传输数据，不需要建立连接\n面向数据报：定长报文，不能灵活控制报文的读取次数和数量\n一次必须要读取完毕一个完整的 udp 报文\n假设报文 100 字节，不能通过 10 次每次读 10 字节来获取报文。必须一次读完 100 字节\n\n\n不可靠：没有确认机制和重传机制，如果因为各种原因，鸽子在路上出事了，那传输的信息也直接丢失了。udp 也不会给应用层返回错误信息。\n\n2.3 udp 缓冲区 udp 支持 全双工，udp 的 socket 即可写也可读\nudp 没有发送缓冲区，应用层调用 sendto 会直接将数据交给 OS 内核（其实就是拷贝），内核再交由网络模组进行后续传输。\n\n由于 udp 采用了定长报头，其报头较为简单，OS 只需要添加上报头即可发送。这个过程很快，所以缓冲区的作用不大。\n\nudp 有接收缓冲区，这个接收缓冲区只是一味地接收，并不能保证报文的顺序\n\n因为不保证顺序，所以有可能  乱序 ，也是udp 不可靠 的体现\n\n若缓冲区满，新到达的 udp 数据就会被丢弃。\n2.4 丢包  一个数据包丢包可能有多种情况\n\n数据包内容出错（比特位翻转等）\n数据包延迟到达（延迟过久视为丢包）\n数据包在路上被阻塞（到不了）\n数据包在路上由于网络波动而丢失（网络突然抽风了，报文直接不见了）\n\nudp 的报文也是如此，但 udp不可靠  并不是一个贬义词，应该是一个中性词。\n\nudp 不可靠是他的特点，由于 udp 简单，其不需要进行连接，报头添加的效率快，由此性能消耗小于 tcp。\n带来的缺点就是 udp 不可靠\n\n在直播场景中，udp 的使用很多。同一场直播观看的人数会很多，如果每一个用户都维持一个 tcp 连接，服务器的负载就太大了。用 udp 就能直接向该用户广播数据，负载小。\n2.5 基于 udp 的应用层协议\nNFS: 网络文件系统\nTFTP: 简单文件传输协议\nDHCP: 动态主机配置协议\nBOOTP: 启动协议（用于无盘设备启动）\nDNS: 域名解析协议\n\n\n本文往下都是 tcp 的内容了哦！\n3.tcp 协议  下图为 tcp 协议报头的一个基本结构图，我们需要了解整个结构，以及每一个部分的作用\n\n3.1 源和目的端口号  这部分和 udp 相同，tcp 也需要源端口和目的端口号，以用于找到报文要去的目的地。\n3.2 4 位首部长度  相比于 udp 的定长报头，tcp 采用了不定长的方式。但 tcp 的报头有  标准的 20 字节，所有报头都至少有 20 字节。\n在这 20 字节中，有一个 4 位首部长度，用于标识 tcp 报文的 真实长度。\n我们知道，4 位二进制可以表示0~15，这不比固定的 20 字节还少吗？难道说，这 4 位首部长度标识的是比 20 字节多余的内容？\n并不是！这 4 位首部长度的标识是有单位的，每一位首部长度，实际上代表的是 4 字节，即 tcp 报头的最大长度为 15*4=60 字节。\n由于标准长度也记入 4 位首部长度，所以 4 位首部长度的最小值为 0101\n\n读取 tcp 报文的时候，只需要先读取 20 字节，再从这 20 字节中  取出 4 位首部长度，获得报头的实际长度；再重新读取，即获得了 完整  的 tcp 报头。剩下的部分就是报文携带的数据了（有效载荷）\n3.2.1 TCP 报文完整长度  一个 TCP 报文段的最大长度为 65495 字节.\nTCP 封装在 IP 内，IP 报头有一个最大长度字段是 16 位，即65535 (2^16 - 1)，IP 头部最小 20，TCP 头部长度最小 20，所以最大封装数据长度为 65535-20-20=65495；\n3.3 32 位序号 &#x2F; 确认序号3.3.1 如何确认信息被对方收到？\ntcp 具有确认应答的机制\n\n当我们和对方  微信交流  的时候，怎么样才能确认自己的信息被对方看到了？\n\nA 发：吃饭了吗？\nB 回应：吃了\n\n在这个场景中，只有 B 给 A 发出回应，A 才能确认自己的消息被 B 看到了。\ntcp 通信也是如此，只有给对方发送的报文收到了对方的  应答，发送方才能确认自己的报文被对方收到了。\n为此，tcp 引入了32 位 序号 / 确认序号\n\n3.3.2 确认应答  用于确认自己和对方的通信，究竟收到了哪一个报文（序号）以及确认信息发出的顺序。\n比如客户端会向服务器发 吃了吗？吃的什么？好吃吗？晚上想去干什么？，如果没有对报头带上序号，服务器接收到的可能就会是下面这样 好吃吗？晚上想去干什么？吃的什么？吃了吗？，看起来是不是十分怪异？\n所以，为了保证 tcp 报文的顺序性，以及保证报文被送达到对方。tcp 引入了以序号为基础的  确认应答  机制：\n\n客户端向服务器发送一个报头，并将  序号  设置为 1\n服务端收到信息后，回复客户端一个报头，将  确认序号  设置为 2（为已经收到了的客户端消息的序号+1。确认序号为 2，代表 1 号报文收到，期望收到 2 号报文） \n此时客户端就能确认服务器收到了自己刚刚发出的序号为 1 的消息\n下次发送消息，客户端会从 2 号开始发送\n\n以上是一次通信的过程，如果是多次通信呢？ \n\n客户端连续向服务器发送了 n 个消息，服务器应答：1、2、3、4……\n服务器的每次应答会设置  确认序号，代表 n 之前的报文（不包括 n 自己）被全部收到\n比如假设客户端发送了 1-10 的报文，而第 6 个报文出现了丢失，那么服务端就应该设置  确认序号  为 6，代表 6 之前 的报文都被正常收到。\n此时客户端发现，明明自己已经都发到 10 了，服务端还在回应 6。这就代表发送过程中，6 号报文丢失了 ！于是客户端从 6 号报文开始， 重发报文：6、7、8……\n\n不管是服务端给客户端发信息，还是客户端给服务器发信息，收方都需要对信息进行回应。tcp 通信中，通信双方地位是对等  的！\n重点：TCP 确认序号应该设置为已经成功收到的报文的  下一位序号\n3.3.3 为什么有两组确认序号？tcp 是  全双工  的，通信一方在发送响应信息的同时，可能也会携带新的报文给对方。\n\n客户端给服务器发了一条消息 吃了吗？\n服务器在回复的同时，也带上了新的请求 吃了，你呢？ \n服务器的这种策略叫做：捎带应答\n\n此时服务端就需要在填充  客户端  消息的  确认序号  的同时，填充  自己  所发消息的  序号。这样才能保证 tcp 在双向交流中的可靠性！\n所以在 tcp 报头中，序号和确认序号  缺一不可！\n3.3.4 没有完美的协议！经过上面的过程，我们会发现，总有一条报文，在收到对方回应之前，是无法得知对方是否收到信息的。\n这也说明：没有一定可靠的协议！\n3.3.5 按序到达\n序号除了用于确认应答，还有多个功能\n\n保证数据的顺序收发问题\n\n比如一个 http 的报头，原本的格式应该是下面这样\nGET / HTTP/1.1\n\n结果由于传输的过程中乱序了，变成了下面这样\nHTTP/1.1 GET /\n\n这种情况，是不能被应用层所正常解析的！数据全都乱了，原本写好的代码也没用了。\n所以，为了避免数据在传输中  乱序，tcp 的序号就有了新的功能——保证数据的按序到达。\n1. 客户端发送了 1-5 号报文2. 服务端收到了 1 3 4 2 5（乱序）3. 服务端在 tcp 的接收缓冲区中，将报文重排序为 1-54. 将重排序后的正确数据交付给应用层\n\n但是，如果  只按顺序来接收数据，那就无法处理  优先级  问题。这部分  将在后文 6 个标记位 详解。\n序号除了可以用于排序，还能用于  去重 ，这部分也将在后文 超时重传  部分解析。\n3.4 16 位窗口大小3.4.1 发送和接收缓冲区tcp 同时拥有发送和接收缓冲区。\n\n我们在应用层调用的 read/write 函数，实际上只是将数据  从接收缓冲区中拷贝出来 / 发送的数据拷贝到发送缓冲区。\n\n如果 write 包含将数据发送给对方的过程，那么这个函数的调用效率就太低了，影响应用层执行其他代码。\n\n数据并没有被立即送入网络传输，而是由 tcp 协议自主决定发送数据的长度和发送的时间！这一切，都是由  操作系统  来决定的。这就是为什么 tcp 又称为  传输控制协议！\n3.4.2 接收缓冲区满了咋办  既然有缓冲区，就肯定会存在缓冲区被写满的问题。\n\n发送缓冲区满，由操作系统告知应用层，不再往发送缓冲区中写入数据\n接受缓冲区满\n直接丢弃数据？\n告诉对方，不再给自己发信息？\n\n\n\n在实际的 tcp 收发过程中，由于  接收方缓冲区满  而丢弃数据，是不可接受的。因为数据跨过了茫茫网络，都已经到你机器上了，结果因为你缓冲区满了给它丢掉了，这不是坑人吗？\n虽然出现这种情况，我们可以让发送方重传报文，但这样效率太低！\n\n所以，我们应该让收发双方知晓对方的缓冲区大小，从而避免这个问题！\n这就是 tcp 报头中 16 位窗口大小 的作用了！\n3.4.3 告知对方收缓大小  如下图，在客户端和服务端  互通有无  的时候，假设服务端的  接收缓冲区  满了，应该告知客户端，让他别再给自己发消息了。\n此时，服务端设置自己的 16 位窗口大小，以此告知客户端自己的缓冲区 剩余  容量。\n如果对方发来的报文中，16 位窗口大小  所表示的缓冲区剩余容量已经不足了，发送方就不应该继续发送，而应该等待对方从缓冲区中取走数据。\n\n这是已经开始通讯的情况，但如果是  第一次  通讯呢？如果客户端一来就发送了一个巨大的数据，直接塞满了服务端的缓冲区，那不是出事了？\n这便是 tcp 在  三次握手  中要做的事情了，简单来说就是在通信开始前就互相告知自己缓冲区的大小。后文会讲解。\n3.4.4 缓冲区是否独立？\n进程的 tcp 缓冲区是独立的吗？\n\n每个进程都有自己的内核空间，内核空间里有 tcp 缓冲区，所以每个进程都有自己独立的 tcp 缓冲区\n\n线程的 tcp 缓冲区是独立的吗？\n\n是的！虽然这些线程共享同一个内核 TCP 缓冲区，但是每个线程使用的缓冲区是独立的，互相之间不会产生冲突。每个线程对自己的缓冲区进行读写操作时，会使用内核提供的同步机制，如互斥锁、信号量等来确保线程之间的缓冲区不会互相干扰，从而实现数据的安全读写。\n3.5 六个标记位  在 4 位首部长度右侧，有一块保留长度，和 6 个标记位。这六个标记位是所有设备都支持的标记位。\n\n\nSYN: 连接标记位，用于建立连接（又称同步报文）\nFIN: 表示请求关闭连接，又称为  结束报文\nACK：响应报文，代表本次报文中包含对之前报文的确认应答\nPSH：要求对方立马从 tcp 缓冲区中取走数据\nURG：紧急指针标记位，用于紧急数据的传输\nRST：要求重置连接（双方重新建立一次新的 tcp 连接）\n\n3.5.1 8 个标记位？在部分书籍中，还会出现 8 个标记位与 4 位保留长度的说法（下图源自《图解 tcp&#x2F;ip 第五版》）\n\n\nCWR（Congestion Window Reduced）：该标志位用于通知对方自己已经将拥塞窗口缩小。在 TCP SYN 握手时，发送方会将 CWR 标志位设置为 1，表示它支持 ECN（Explicit Congestion Notification）拥塞控制，并且接收到的 TCP 包的 IP 头部的 ECN 被设置为 11。如果发送方收到了一个设置了 ECE（ECN Echo）标志位的 TCP 数据包，则它将调整自己的拥塞窗口，就像它从丢失的数据包中快速恢复一样。然后，发送方会在下一个数据包中设置 CWR 标志位，向接收方表明它已对拥塞做出反应。发送方在每个 RTT（Round Trip Time）间隔最多做出一次这种反应。\nECE（ECN Echo）：该标志位用于通知对方从对方到这边的网络有拥塞。在收到数据包的 IP 首部中 ECN 为 1 时，TCP 首部中的 ECE 会被设置为 1。接收方会在所有数据包中设置 ECE 标志位，以便通知发送方网络发生了拥塞。\n\n而我百度到的文章提到，tcp 给多出来的两个标记位新增了功能：\n\n除了以上 6 个标志位，还有一个实验性的标志位 NS（Nonce Sum），用于防止 TCP 发送者的数据包标记被意外或恶意改动。NS 标志位仍然是一个实验标志，用于帮助防止发送者的数据包标记被意外或恶意更改。3 4\nTCP 标志位中还有两个标志位后来加的一个功能：显式拥塞通知（ECN）。ECN 允许拥塞控制的端对端通知而避免丢包。但是，ECN 在某些老旧的路由器和操作系统（例如：Windows XP）上不受支持。在 TCP 连接上使用 ECN 也是可选的；当 ECN 被使用时，它必须在连接创建时通过 SYN 和 SYN-ACK 段中包含适当选项来协商。 2 3\n\n诸如tcp 的标记位到底是 6 个还是 8 个? 这种摸棱两可的问题，在考试中不会问道。\n在学习中，我们只需要掌握所有设备都支持的 6 个标记位 即可\n\n3.5.2 ACK该标记位用于标识本条报文是对之前的报文的  确认应答。设置了改标记位，那么接收方就应该去查看该报文中的确认应答序号。\nACK 标记位的设置和其他标记位并不冲突，在  捎带应答  的时候，可以同时设置包括 ACK 在内的多个标记位，而不影响当前报文的原本功能\n3.5.3 SYN&#x2F;FIN\nSYN：表示请求建立连接，并在建立连接时用于同步序列号，所以又称为  同步报文；\nFIN：表示请求关闭连接，又称为  结束报文。设置为 1 时，代表本方希望断开连接。此时双方要交换 FIN（四次挥手）才能真正断开 tcp 连接。\n\n\n3.5.3.1 三次握手  在三次握手的时候，经历了如下过程\n\n连接发方 A 向对方主机 B 发送 SYN 报文，请求建立连接（A 进入 SYN-SENT 状态）\n主机 B 在收到报文后，回应 ACK+SYN 的报文，在确认应答的同时，请求建立连接（B 进入 SYN-RCVD 状态）\nA 收到这条报文后，发送确认应答 ACK（A 认为连接成功建立 ESTABLISHED）\nB 收到 A 发送的 ACK，三次握手完成（B 认为连接成功建立  ESTABLISHED）\n\nA     SYN-&gt;      B A(SYN_SENT)      BA   &lt;-SYN+ACK    BA      (SYN_RCVD)BA     ACK-&gt;      BA(ESTABLISHED)   BA   (ESTABLISHED)B 收到 ACK\n\n为什么接收方要发送 ACK+SYN\n为什么接收方要发送 ACK+SYN，而不是只发送 ACK？\n\n接收方发送带有 ACK+SYN 标志的数据包，是为了确认收到了发送方的 SYN，并向发送方表明自己也同意建立连接。ACK 字段用于确认收到了之前的数据包，而 SYN 字段用于表示接收方也希望建立连接。\n若接收方只发送 ACK 而不带 SYN 标志，这可能会导致混淆。因为 TCP 中的 ACK 字段表示确认收到之前的数据包，而在初始握手阶段，双方都还没有进行数据传输，所以 ACK 字段无法明确指示是在确认 SYN 还是确认其他数据包。因此，发送方在收到只带 ACK 标志的数据包时，无法准确知道接收方是否同意建立连接。\n通过在握手过程中同时发送 ACK+SYN 标志，接收方可以在一个数据包中明确表示两个信息：确认收到发送方的 SYN，并表示自己也愿意建立连接。这样就能够确保双方在握手过程中能够准确理解对方的意图，并建立起可靠的连接。\n3.5.3.2 四次挥手  在断开连接，四次挥手的时候，经历了如下过程\n\nA 要断开连接，发送 FIN（A 进入 FIN WAIT 1 状态）\nB 收到了 FIN，发送 ACK（B 进入 CLOSE-WAIT 半关闭状态）\nA 收到了 ACK（A 进入 FIN WAIT 2 状态)\n此时只是 A 要和 B 单方面分手，A-&gt;B的路被切断了，但是 B-&gt;A 的还没有，B 还能继续给 A 发数据\nB 发完数据了，也和 A 分手了，B 发送 FIN（B 进入 LAST ACK 状态）\nA 收到 FIN，发送回应 ACK（A 进入 TIME WAIT 状态，将在  一段时间后  进入 CLOSE 断连状态）\nB 收到了 ACK（B 进入 CLOSE 状态）\n连接关闭\n\n我们不仅需要知道 3 次握手和 4 次挥手的过程，还需要知道每一次的状态变化！\n\n3 次握手和 4 次挥手对于应用层而言，都只有 1 个对应的函数。这些操作都是由 tcp 自主完成的。\n3.5.4 PSHPSH 标记位的作用是：要求对方立马取走缓冲区中数据\n如下图，S 在接收缓冲区满了之后过了很久，还没有取走缓冲区中的数据，C 实在忍不住了，给 S 发一个 PSH 标记位的报文，要求 S 立马取走这些数据！\n\ntcp 在收到此报文后，将由操作系统告知应用层，取走缓冲区中的数据。\n如果应用层不听操作系统的咋办？那就代表应用层写的有 bug！人家给你发了那么多东西了你还不处理，有点过分了！\n3.5.5 URGURG 是  紧急指针标记位。\n在 3.3.5 按序到达 部分提到过，如果只关注序号，则无法处理优先级问题。有一些数据对于应用层来说，优先级较高。如果 tcp 只会老老实实的按顺序把数据交付给应用层，那在高优先级的数据也搞不过操作系统对 tcp 的处理。\n所以，为了能操作优先级，tcp 提供了 URG 标记位，设置了此标记位的报文具有较高优先级。\n应用层有专门的接口可以优先读取带有 URG 标记位的报文。\n3.5.5.1 16 位紧急指针  为了能标识这个紧急数据在报文中的位置，tcp 还提供了 16 位紧急指针；这个指针的指向便是 紧急数据  在 tcp 报文中的偏移量。紧急数据  规定只有 1 个字节！\n由于紧急指针的数据可以被提前读取，不受 tcp 缓冲区的约束，所以又被称为  带外数据\n下图就举了一个紧急指针使用的场景：\n\nTCP 在传输数据时是有顺序的，它有  字节号 ，URG 配合紧急指针，就可以找到紧急数据的 字节号。\n紧急数据的字节号公式如下：\n紧急数据字节号(urgSeq) = TCP 报文序号(seq) + 紧急指针(urgpoint) −1\n\n比如图中的例子，如果 seq = 10,urgpoint = 5，那么字节序号 urgSeq = 10 + 5 -1 = 14\n\n知道了字节号后，就可以计算紧急数据字位于  所有传输数据中  的第几个字节了。如果从第 0 个字节开始算起，那么紧急数据就是第 urgSeq - ISN - 1 个字节（ISN 表示初始序列号），减 1 表示不包括第一个 SYN 段，因为一个 SYN 段会消耗一个字节号。\n3.5.6 RSTRST 为复位报文，即RESET。\n如下图，如果 A 给 B 发送的 ACK 在传输路途上丢失了，咋办？\n\n这时候，就会出现 A 认为连接已经建立，而 B 由于没收到 A 的 ACK 而处于 SYN-RCVD 状态。\n\n此时 A 开始给 B 发送数据，B 一看，不是说好了要建立连接才能发送数据的吗，你这是在干嘛？\n于是 B 告知 A，发送 RST 标志位的报文，要求和 A 重新建立连接（重新进行三次握手）\n重新建立连接成功后，AB 再正常发送信息。\n\n以上只是 RST 使用的情况之一。我们使用浏览器访问一些网页时，F5 刷新  就可以理解为浏览器向服务器发送了一个带有 RST 标记位的报文。\n3.6 为什么是 3 次握手？为什么握手的次数是 3 次，不是 1 次、2 次、4 次、5 次？\n在讨论这个问题之前，我们要知道：连接建立是有消耗的！需要维护其缓存区、连接描述符（linux 下为文件描述符）等等数据。基于这点认识，我们接着往下看\n\n如果是一次握手？\n\n一次握手，即 A 给 B 发送一个 SYN，双方就认为连接建立了。\n那么我们直接拿个机器，写个死循环，一直给对方发送 SYN，自己直接丢弃文件描述符（不做维护）\n由于服务器并不知道你（发送方）直接丢弃了文件描述符，其还是要为此次连接维护相关数据，这样会导致服务器的资源（为了维护 tcp 链接）在短时间内被大量消耗，最后直接 dead 了\n\n这种攻击叫做SYN 洪水\n\n\n如果是二次握手？\n\nA 给 B 发送一个 SYN，B 给 A 发送一个 ACK，即认为连接建立。\n这和一次握手其实是相似的，服务器发送完毕 ACK 之后，就认为连接已经建立，需要维护相关资源。而我们依旧可以直接丢弃，不进行任何维护，最后还是服务器的资源被消耗完了\n\n三次握手\n\n三次握手了之后，双方都必须维护连接的相关资源；这样，哪怕你攻击我的服务器，你也得付出同等的资源消耗。最后就是比谁资源更多呗！\n相比于前两种情况，三次握手能在  验证全双工  的同时，一定程度上避免攻击。\n三次握手还将最后一次 ACK 丢失的成本嫁接给了客户端（连接发起方）如果最后一次 ACK 丢失，要由客户端重新发起和服务器的连接。\n注意，三次握手只是  一定程度  上避免攻击。我们依旧可以用很多宿主机“堆料”来和服务器硬碰硬，这是无可避免的情况。\n\n更多次握手？\n\n由于三次握手已经满足了我们的要求，更多次握手依旧有被攻击的可能，还降低了效率，完全没必要！\n\n3.7 超时重传  为了保证可靠性，如果一个报文长时间未收到对方的 ACK 回应，则需要进行  超时重传。\nlinux 下每一次尝试的时间间隔为 500ms，若 500ms 内尚未收到对方的 ACK，则重发报文，再等待 1000ms……以此类推。\n\n超时重传还可能遇到下面的情况：\n\n服务器收到了消息，也发送了 ACK，但是 ACK 在路上丢失了\n客户端没有收到 ACK，于是进行超时重传\n服务器再次收到了消息，此时接收缓冲区里出现了两个一样的数据\n\n但是，我们的报文是有序号的，tcp 就可以  直接根据序号去重 ，所以，tcp 交给应用层的数据是 去重 + 排序  之后的数据！\n\n如果同一个报文超时重传了好几次，还没有收到对方的应答，就会认为对方的服务挂掉了，此时本端会强制断连。\n此时客户端就可以发送一个带有 RST 标记位的报文，要求和对方重新建立连接。如果重连失败，则可以认为对方确实挂掉了，这便是我们在浏览器中有时会看到的 SERVICE_UNAVALIABLE 服务不可用\n3.8 出现了很多 CLOSE-WAIT 状态的连接？在上面提到过，当客户端向服务器发送 FIN 之后，服务器回复 ACK，会进入 CLOSE-WAIT 状态。此时服务器还能给客户端发送消息，双方都还在维护连接的相关资源。\n如果一个服务出现了很多个处于 CLOSE-WAIT 状态的连接，就必须要检查一下，应用层的代码里面是不是没有调用 close(fd) 函数来关闭对应的文件描述符。\n\n一方的 close(fd) 就对应了两次挥手\n\n对方明明都要和你分手了，你还挂着对方当备胎，还要找对方要钱，也太不像话了😂\n3.8.1 活学活用🤣230322 下午，正准备通过之前写的 tcp 代码来验证 tcp 握手和挥手的各个状态的，没想到用命令一看，全是 CLOSE-WAIT 状态，填满了整个屏幕，这完全没办法写博客啊\n\n而且这些状态清一色来自 python3.10 的程序，看到它的时候，我已经基本猜到了是啥进程引发的了——我的  两个 valorant 机器人。查了查 pid，坐实了这一点\n\n我将数据写入到一个文件里面，统计了一下，一共 1200 多个CLOSE-WAIT\nnetstat -ntp &gt; log # 将统计结果写入文件 lognetstat -antp | grep CLOSE_WAIT # 只统计 CLOSE_WAIT 状态的链接\n\n\n这些状态值的远程 ip 来源虽然有多个，但一个 ip 出现了多次，于是我就使用 itdog 看了一下其中几个 ip 的来源，是Anycast/cloudflare.com，也就是很出名的 cloudflare-cdn。\n在我的 kook-valorant-bot 里面，有一项业务是方便开发者使用的 valorant 登录和商店查询的api（使用 aiohttp 库编写）\n为了统计其上线状态，我使用了 uptimerobot 定时请求，每 5 分钟获取一次 api 的在线情况\nhttps://stats.uptimerobot.com/Wl4KwU6Bzz\n\n嗯，运行状态倒是蛮好的，100% 在线\n\n前面提到过，系统是需要消耗资源来维护 tcp 链接的。如下图，机器人占用了将近 400mb 的内存，其中肯定有一部分就是被这些没有关闭的 tcp 链接所占用的\n\n大量 CLOSE-WAIT，只可能是一个原因：uptimebot 的请求已经结束并发送了 FIN，而我的 api 代码作为服务端，并没有在收到 FIN 后，对链接进行 close，于是链接一直处于CLOSE-WAIT 半关闭状态。只有程序关闭（机器人下线）才会被操作系统清空。\n\n后来又研究了一下，经过他人点醒，才发现上面的结论都是  错的\n\nhttps://segmentfault.com/q/1010000043572705/a-1020000043573118\n\n其实在 netstat 里面很明显的一点，表示这一切和 uptimebot 以及我写的 api 没有任何关系\n\n那就是这里面 Local Address 的端口，每一个都是不一样的。如果是我写的 api 导致的，那么他们的端口都应该是 api 绑定的端口，且固定才对！\n后来就找到了一个 2014 年的 issue，大概情况就是，python 的 requests 库会维护一个  连接池 （类似于线程池）。这些处于close-wait 状态的连接，都是 requests 库维护的。\nhttps://github.com/psf/requests/issues/1973\n好嘛，原来是自己学艺不精，闹了个大笑话。当时找处理 aiohttp 的 web 状态的资料找了老半天都没找到……原来一开始方向就错了😶‍🌫️\n3.9 异常情况\n进程终止：进程终止会释放文件描述符，仍然可以发送 FIN。和正常关闭没有什么区别 \n机器重启 &#x2F; 关机：和进程终止的情况相同，操作系统会在重启 &#x2F; 关机前  释放 TCP 文件描述符。\n机器断电 &#x2F; 网络断开：接收端认为连接还在，一旦接收端有写入操作，接收端发现连接已经不在了，就会进行reset。即使接收端没有写入操作，TCP 内置了一个保活定时器，会定期询问对方是否还在。如果对方不在，也会把连接释放。\n\n除了 TCP 本身，应用层的某些协议，也会有这样的重连检测机制。\n3.10 校验和\n这部分并不是重点。\n\n校验和能保证 TCP 双方发送的数据不会出现数据对不上的问题\n校验和是一种简单的数据验证机制，它通过对数据进行数学运算得到一个校验值，并将该校验值与原始数据一起传输。接收方收到数据后，会再次计算数据的校验和，并将结果与传输过来的校验值进行比较。如果两个校验和相匹配，那么说明数据在传输过程中没有发生错误或损坏。但如果校验和不匹配，接收方会认为数据发生了错误或损坏，于是会请求发送方重新传输数据。\nTCP 在数据包的头部添加了一个 16 位的校验和字段，该字段包含了数据段的校验和值。在发送端，TCP 将数据段中的所有字节（包括 TCP 头部和数据部分）加起来，然后取其反码作为校验和。接收端也采用同样的方式计算校验和，并与接收到的校验和进行比较，以验证数据的完整性。\n\n举个简单的栗子，我们可以把发送的数据体当作一个字符串，对其进行 MD5 计算，再将计算后的 MD5 同数据体一同发送给对方。这时候接受方收到信息后，同样进行相同算法的 MD5 计算，得出来的 MD5 和对方发送过来的 MD5 进行对比，如果相同，代表数据没有问题。不相同代表数据发送错误，该数据包被丢弃。\n如果发送的 MD5 在传输过程中出现了损坏，那么最终计算出来的 MD5 字符串依旧是不相同的，也会当作无效报文被丢弃;\n实际 TCP 使用的并不是 MD5，上面的这个栗子只是为了方便理解。\n\n校验和  不仅用于 TCP 协议，在许多其他协议中也有类似的机制，用于确保数据传输的可靠性。\n通过使用校验和，网络协议可以帮助确保数据在传输过程中不会因为噪声、干扰或其他错误而变得损坏。然而，需要注意的是，校验和并不能提供绝对的数据完整性保证，因为一些复杂的错误模式可能会导致校验和匹配，但数据仍然损坏。\n为了进一步增强数据的可靠性，TCP 协议还使用了序列号（按序到达）、确认应答（确认收到）和超时重传（避免丢包）等机制。\n3.11 快重传TCP 快重传（Fast Retransmit）是 TCP 协议中的一种拥塞控制机制，用于加快数据包的重传，以减少数据传输的延迟和提高网络性能。\n在 TCP 协议中，当发送方发送数据包到接收方后，会启动一个  定时器，等待接收方发送确认应答（ACK）回来。如果发送方在定时器超时前收到了相应的 ACK，说明数据包已经成功接收，发送方会将定时器停止，并继续发送下一个数据包。\n\n这个默认的  定时器  策略，是用于 TCP 的  超时重传  的。\n\n然而，如果发送方在定时器超时前没有收到 ACK，通常会认为数据包丢失了，因此会重新发送该数据包。但有时候，接收方实际上已经收到了数据包，只是 ACK 因为某种原因没有及时发送回来，这可能是由于网络延迟、拥塞等造成的。\n\n而 TCP快重传  的思想是，当发送方收到  连续的相同的 ACK时，不等待定时器超时，而是立即重传对应的数据包。\n这是因为连续收到相同的 ACK，表明接收方已经收到了一系列的数据包，并且正在等待接收下一个数据包。通过立即重传，可以  避免等待定时器超时  的延迟，从而更快地恢复数据传输。\n具体来说，TCP 快重传的步骤如下：\n\n发送方发送一个数据包，并启动定时器。\n接收方收到数据包后，发送对应的 ACK 回去。\n如果发送方收到三个连续的相同 ACK（即收到三个对同一个数据包的确认应答），就立即重传该数据包，而不等待定时器超时。\n\n需要注意的是，快重传只适用于可靠传输的 TCP 连接，而不适用于无连接的 UDP 协议。TCP 快重传是 TCP 协议中的一种优化措施，它能够在一定程度上改善网络性能，减少不必要的传输延迟，提高数据传输的效率。\n4. 验证状态  下面可以用代码来实地查看 tcp 在传输过程中的各种状态。之前写过一个  简单的 http 服务器，现在为了方便，直接拿来使用。\n采用如下命令进行 netstat 的循环监测\nwhile :; do netstat -ntp | grep 端口号;sleep 1; echo &quot;########################&quot;; done\n\n4.1 TIME-WAIT在浏览器访问，可以看到服务器返回的 html 页面\n\n后台可以看到，服务器接收到了请求的报头\n\n并按如下返回response\nDEBUG | 1679717397 | muxue | [sockfd: 4] filePath: web/index.html######### response header ##########HTTP/1.0 200 OKContent-Type: text/htmlContent-Length: 362Set-Cookie: This is my cookie test######### response end ##########\n\n使用 netstat 命令查看，当前多出了一个处于 time wait 状态的连接\n\n这代表四次挥手的第一个 FIN 是由服务器发出的，这一点在代码中也能体现，服务器 accpet 到连接后，会交由孙子进程来执行 handlerHttpRequest(conet) 服务\n// 提供服务（孙子进程）pid_t id = fork();if(id == 0)&#123;    close(_listenSock);// 因为子进程不需要监听，所以关闭掉监听 socket    // 又创建一个子进程，大于 0 代表是父进程，即创建完子进程后父进程直接退出    if(fork()&gt;0)&#123;        exit(0);    &#125;    // 父进程推出后，子进程被操作系统接管    // 孙子进程执行    handlerHttpRequest(conet);    exit(0);// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收&#125;// 爷爷进程close(conet); // 这个 close 并不会影响孙子进程内部的，因为有写时拷贝pid_t ret = waitpid(id, nullptr, 0); // 此时就可以直接用阻塞式等待了assert(ret &gt; 0);//ret 如果不大于 0，则代表等待发生了错误\n\n这个服务函数并不是 while(1) 的死循环，内部也没有进行 socket 的 close 操作，而是发送完毕客户端请求的文件后，直接退出了\nvoid handlerHttpRequest(int sock)&#123;    cout &lt;&lt;     &quot;########### header-start ##########&quot; &lt;&lt; endl;// 打印一个分隔线    char buffer[10240];    ssize_t s = read(sock, buffer, sizeof(buffer));    if(s &gt; 0)&#123;        cout &lt;&lt; buffer &lt;&lt; endl;        cout &lt;&lt; &quot;########### header-end   ##########&quot; &lt;&lt; endl;    &#125;    fflush(stdout);    string path = getPath(buffer);    // 假设用户请求的是 /a/b 路径    // 那么服务端处理的时候，就需要添加根目录位置和默认的文件名    // &lt;root&gt;/a/b/index.html    // 在本次用例中，根目录为 ./web 文件夹，所以完整的文件路径应该是    // ./web/a/b/index.html    string resources = ROOT_PATH; // 根目录路径    resources += path; // 文件路径    logging(DEBUG,&quot;[sockfd: %d] filePath: %s&quot;,sock,resources.c_str()); // 打印用作 debug    string html = readFile(resources);// 打开文件    // 开始响应    string response = &quot;HTTP/1.0 200 OK\\r\\n&quot;;    // 如果 readFile 返回的是 404，代表文件路径不存在    if(strcmp(html.c_str(),&quot;404&quot;)==0)    &#123;        response = &quot;HTTP/1.0 404 NOT FOUND\\r\\n&quot;;    &#125;    // 追加后续字段    response += &quot;Content-Type: text/html\\r\\n&quot;;    response += (&quot;Content-Length: &quot; + to_string(html.size()) + &quot;\\r\\n&quot;);    response += &quot;Set-Cookie: This is my cookie test\\r\\n&quot;;    response += &quot;\\r\\n&quot;;    cout &lt;&lt; &quot;######### response header ##########\\n&quot; &lt;&lt; response &lt;&lt; &quot;######### response end ##########\\n&quot;;    fflush(stdout);    response += html;    // 发送给用户    send(sock, response.c_str(), response.size(), 0);&#125;\n\n函数退出了之后，文件描述符就交由了操作系统。一个没有进程使用的文件描述符，会被操作系统直接 close 关掉。相当于  操作系统  帮我们发出了 FIN，就出现了 TIME WAIT 状态。\n4.1.1 为啥要有这个状态？知道了 4 次挥手的过程后，我们就能知道，TIME-WAIT是 4 次挥手的  发起方  才有的状态。\n既然对方已经给我发了 FIN，这不就代表对方也想和我分手吗？那我为啥还留着好友不删，非要等等呢？\n这是因为，我们发出的最后一次 ACK 是否被对方收到，是未知的！\n\nA 给 B 发送最后一次 ACK，B 没有收到\nA 不 TIME-WAIT 直接退出，A 已经断开连接了，但是 B 还在维护这个连接\n如果有 TIME-WAIT 状态，B 没有收到 ACK，会对 FIN 进行超时重传\nA 再次收到 FIN，代表上一次 ACK 丢了，那就再次发送 ACK\n如果 A 在 TIME-WAIT 状态什么信息都没有收到，那就代表自己的 ACK 被 B 收到了，便可以放心断连\n\n此时，TIME-WAIT状态保证了最后一次 ACK 的正常递达\n还有第二种情况：\n\nC 给 S 发送 FIN，准备断连\nS 给 C 发送 data，发送完毕后，立马发送 FIN\ndata 和 FIN 都在路由传输的过程，可能会出现 FIN 比 data 早到的情况\nC 收到 FIN，返回 ACK，进入 TIME-WAIT 状态，期间收到了 S 发送的 data\nC 成功接收 data，继续等待到计时器结束，释放链接\n\n此时，TIME-WAIT 状态保证了二者之间的消息能都被收到\n4.1.2 等多久？这里引入一个新概念：一个报文在双方之间传输花费的时间，被称为这个消息的 MSL（maximun segment lifetime 最大生存时间）\nTIME-WAIT 等待的时间需要适中，不同的操作系统，默认等待的时间都是不同的。CentOS 下，这个时间是 60s\n$ cat /proc/sys/net/ipv4/tcp_fin_timeout60\n\n一般情况下，设置为 MSL*2 是最好的，这样能保证双方数据的递达，和最后 ACK 的递达\n4.2 CLOSE-WAIT如果我们在 handlerHttpRequest(conet); 向客户端发送了 html 文件后，服务端休眠几秒钟；客户端打开网页后关闭网页，是否就能看到其他状态呢？\n// 发送给用户send(sock, response.c_str(), response.size(), 0);   // 休眠几秒钟作为测试sleep(20);\n\n如下，情况又不同了。这次出现的是 CLOSE-WAIT 状态，代表第一个 FIN 请求是客户端发出的\n\n这是因为当前的进程没有进行  长链接  的维护，如果想维护长连接，则服务器应该给客户也返回一个 http 协议报头 Connection: keep-alive\n如下图，可以看到客户端发来的 http-header 里面，是有该字段的。而服务器并没有返回相同的字段，客户端就认为服务器不支持长链接，从而主动发出了FIN \n\n进一步看 tcp 的状态，当前是有两个父进程为 1（采用了孙子进程的写法，父进程退出后会被操作系统接管）的进程在进行休眠，它们同属于 295942 这个 tcp 服务器主进程的进程组（PGID相同）\n当这两个进程结束休眠的时候，CLOSE-WAIT状态的连接立马消失了。因为操作系统接管了文件描述符后，进行了 close，服务端也发出了 fin，四次挥手成功，连接终止。\n\n4.3 ESTABLISHED如果我们给 response 加上长链接的报头，是否可以看到 ESTABLISHED 状态呢？\nresponse += &quot;Connection: keep-alive\\r\\n&quot;;\n\n可以看到，确实出现了这个状态，这代表双方成功维护起了长链接（虽然当前情况下，这个长链接并没有起到应有的作用）\n\n进一步轮换，将处理函数改为 while(1) 的死循环调用，我们应该可以通过一个 socket 实现多个报文的发送\n// 孙子进程执行logging(DEBUG, &quot;new child process&quot;);// 打印一个新进程的提示信息，方便观察结果while(1)&#123;    handlerHttpRequest(conet);&#125;\n\n可以看到，只出现了一个子进程，对客户端进行服务\n\n查看日志，能看到，成功实现了长链接通信\n\n如果不采用 while(1) 死循环进行服务，则客户端的每一次请求，都需要一个新的子进程来服务\n\n即便 response 中带有长链接标识，也会因为 fd 被操作系统回收而进入 TIME-WAIT 状态\n\n4.4 端口不能被 bind之前在 tcp 服务器的学习中，出现了如果立马把 tcp 服务器关了后开，同一个端口无法被 bind 的情况\n$ ./tcpServer 50000 &gt; logFATAL | 1679720482 | muxue | bind: Address already in use:3$ ./tcpServer 50000 &gt; logFATAL | 1679720491 | muxue | bind: Address already in use:3\n\n经过对 tcp 协议的学习，现在能知道为何这个端口不能被 bind 了。使用 netstat -ntp 命令查看，能看到这个端口上还有处于 TIME-WAIT 状态的链接，所以系统认为这个端口上还有 tcp 链接在运行，不允许  我们二次 bind 这个端口。这是操作系统在默认状态下的行为。\n\n前面提到过，centos 默认的 TIME-WAIT 等待时间是 60s。只要等待 60s，操作系统释放了这个端口上的冗余链接，就能被 bind 了！\n但是，这样会有很大的问题！请接着往下看\n4.4.1 问题  假设我现在的服务器进程是直接 bind 80 端口对外进行服务的，这样他人就能直接通过我服务器的 ip，以 http 协议与我的  服务进程  进行通信。\n以 http 网页服务为例，经过了很久很久的运行时间\n\n服务器进程出了恶性 bug，导致进程退出了\n服务器压力过大，操作系统为了释放资源，直接把服务进程给 kill 了\n\n这时候，由于第一个 FIN 是由服务端发出的，服务器会进入 TIME-WAIT 状态。\n假设  服务进程  崩溃的时候，有数个用户正在访问你的网页。对于他们而言，崩溃的表现就是，刷新网页，直接白屏，显示不出来后续的页面了。\n此时就需要运维老哥赶快 ssh 连上服务器，重启  服务进程\n为了关照运维老哥的头发，让出错的服务进程快速重启，一般情况下，我们会给这个服务进程增加一个监视进程\n\n监视进程是个死循环，其要做的功能很单一，所以负载并不大\n监视进程实时查看，每几秒就看一眼服务进程的状态\n服务进程挂掉了，监视进程在下一轮监视时会立马发现，通过 exec 系列函数 直接重启服务进程\n\n这时候，TIME-WAIT的问题就出现了：服务进程想绑定的是 80 端口，也只能绑定 80 端口（不然客户端无法知道服务器端口改变，也依旧无法访问服务）但是 80 端口还有没有清理的 tcp 链接，操作不给你 bind 啊！\n如果等操作系统 60s 后清除链接再 bind，那也太晚了🙅‍♀️\n大型服务进程启动时要干的活很多，所以启动会较慢。等待系统释放 TIME-WAIT 的链接后再 bind，相当于多给服务进程启动增加了 60s\n\n对于一些客户量级巨大的服务，时间就是生命呀！\n用户的耐心都不咋地，拿我自己举栗子吧！当我去访问一些网站时，如果 5s 之内网页没有加载出来，我就准备 x 掉那个网页了\n\n所以，为了避免由于 TIME-WAIT/CLOSE-WAIT 未释放而无法 bind 端口的问题，操作系统提供了  端口复用  的接口。让进程可以忽略冗余连接，直接 bind 这个端口！\n4.4.2 端口复用  端口复用，复用的是有 TIME-WAIT/CLOSE-WAIT 这种冗余链接的端口，而不是处于服务状态的端口哈！一个端口只能对应一个服务，老规矩可不能破坏了。\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);\n\n默认情况下，端口有冗余链接，无法 bind\n\n只需要在 bind 函数之前添加上如下代码，就能实现端口复用。\n// 1.1 允许端口被复用（即便还有 TIME-WAIT 的链接）int optval = 1;setsockopt(_listenSock, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));\n\n如下图，即便 50000 端口存在 time-wait 的链接，我们依旧可以正常 bind 这个端口！\n\n除了这种形式的端口复用，其实还有一个SO_REUSEPORT，它允许多个进程绑定同一个的端口；在 nginx 中就是采用这样的方式，让多个 worker 线程进行链接的竞争的。\n4.5 accpet 不影响 tcplinux 给我们提供的接口 accpt，并不参与 3 次握手的阶段\n将 http 服务的 accpet 给去掉，来观察这一情况。如下图，服务器直接是一个啥事不干的死循环，不对新来的连接进行 accept，此时浏览器访问该服务，依旧会出现两个处于ESTABLISHED 的连接\n\n这便证实了我们的结论：accpet 不参与 tcp3 次握手的过程\n4.6 listen 的第二个参数 4.6.1 概念 之前学习 tcp 服务器写法 的时候，粗略提到了 listen 函数第二个参数的作用。\n#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);//backlog 参数限制了能被阻塞等待连接的数量// 如果超过这个数量，则会返回一个 ECONNREFUSED 错误。亦或者如果协议支持重传，多余的请求会被忽略，后续可以重传\n\n这里的阻塞等待连接是什么意思？还是用前面用到的 http 服务，以实际情况来看看\n\n什么情况下，一个连接会被阻塞？\n\n这一点就涉及到服务器的承受能力了。假设服务器现在很忙，压根没时间去 accept 一个新的连接，那这个连接就一直存在操作系统的 tcp 连接中，而没有进程对它服务 。这种状态，就可以被称为连接的 阻塞等待\n4.6.2 看看具体情况  假设我将 listen 的第二个参数设置为了 2，服务器是个啥事不干的死循环\nif (listen(_listenSock, 2) &lt; 0)&#123;    logging(FATAL, &quot;listen: %s&quot;, strerror(errno));    exit(LISTEN_ERR);&#125;\n\n在浏览器内直接开 5 个窗口请求这个连接，加上我的手机，一共是 6 个请求\n\n但后台可以看到，再继续增加浏览器请求的数量，依旧都只有两个连接是处于 ESTABLISHED 状态，和 listen 的第二个参数正好相同！这两个连接因为没有被服务进程accept，它们就是处于阻塞等待状态的！\n\n4.6.3 为什么？为什么操作系统要给一个进程维护  阻塞等待  的连接呢？既然这个进程不进行新连接的 accept，操作系统为何不直接把这个连接丢弃呢？\n拿生活中非常场景的  餐厅排队  举例子吧。大家应该都见过一个餐馆在中晚餐高峰期时，门口有人在排队等位吧？特别是  河海底捞，每次想去都得提前预定，不然排队的时间吃门口的小零食都要吃饱了。\n\n那么，餐馆为什么要提供排队等位呢？为何服务员不直接告诉新来的客人，馆子里没空位了，请另寻他处呢？\n\n原因很简单：为了上桌率。\n\n一个餐馆的上桌率越高，就代表其生意越好。如果餐馆内部没桌了，但是外头有人排队，这样就能让有客人离开（空出桌子后）立马有新的客人上桌。\n\n对于我们的服务进程也是一样！\n\n假设这个服务进程有 10 个线程对外进行服务，此时来了第 11 位需要服务的客人。服务的 10 个线程（桌子）都被坐满了，没人能给 11 号客人服务。那这时候，操作系统就告诉 11 位客人：“你在这里稍作等待，我去给你  买个橘子  取个排队单号”，这时候 11 号客人就在操作系统为服务进程提供的等候位置上坐了下来，等待服务进程腾出空位来给他服务（链接阻塞等待）\n这时候，有一个用户断开了连接，空出来了一个进程，那么服务进程（餐馆）内的服务员就跑出来，和 11 号客户说，他可以上桌了（accept）这时候，服务进程就开始给 11 号客户提供服务了。\n这样一来，只要服务进程有空闲，就能立马有新的进程入座，让服务进程  不至于摸鱼。提高了服务器资源的利用效率。\n我买了一个服务器，我肯定是希望它在不崩溃的前提下  为越多客户服务越好，资源最大化嘛！\n4.6.4 该参数应该设置成多少？既然我们已经知道了这个参数的作用，那么应该把它设置为多少呢？\n\n餐馆也需要面临这个问题\n\n如果自己设置的排队等位太少，那么可能会有想排队的客户没有位置坐。\n如果设置的太多，那新来的客户压根不打算排队了，因为他们知道，轮到自己的时候，已经饿扁了。\n\n服务器也是如此\n\n第二个参数设置的低了，排队的空位太少，超过该参数的链接直接被 os 拒绝，错过了本来可以提供服务的用户\n第二个参数设置的高了，用户过来排队，等了好久都没等到，于是就报错  连接超时  了。\n而且，打开一个网页的响应速度，也会直接影响用户对你的服务的满意度。每次点开你的网页都需要加载个十几秒的，久而久之，用的人只会越来越少！\n设置的太高了，维护的连接也会占用系统资源，服务进程可用资源变少了！\n与其增长队列，还不如增加服务进程的服务能力（扩大店面）\n\n所以，我们应该根据自己服务的面向用户数量级，设置一个合适的等位数量！这个应该根据具体情况来看的！\n4.6.5 listen 和 accept如下图，我让服务进程只对一个链接进行 accept，相当于餐厅里面只有两张桌子。此时新来的链接就会处于等待状态，数量正好是 listen 的第二个参数（但是我的第二个参数是 2，我也不知道为啥会是 3 个🤣）\n\n5. 滑动窗口 tcp 中引入了 滑动窗口  的操作\n5.1 概念  在实际通信中，如果真的只是让双方一发一答，那效率也太低了。所以，一般都是直接一次性发送多条消息，对方也是对多条报文进行 ACK 的，而且只需要 ACK 一次（这点在前面序号部分已经讲过原理了）\n\n一次性可以发送多条报文，但前提是对方有能力收那么多\n窗口大小：一次性可以发送的数据数量（无需等待前面已发报文的 ACK，就可以发送这么多）\n窗口大小是由  对方的接收能力  决定的\ntcp 报头中，16 位窗口大小  就是滑动窗口的大小\nS 给 C 所发报头中的窗口大小，既代表 S 接收缓冲区的大小，又代表 C 可以一次发送的数据大小\nS 接收缓冲区的大小变化，也会导致 S 给 C 所发报文中，窗口大小的变化\n\n\n窗口越大，代表双方通信的  吞吐率  就越大\n发送的数据会保留在发送缓冲区中，发送缓冲区以如下区域构成\n已发，收到了 ACK 的报文（可删）\n已发，未收到 ACK 的报文\n未发，准备发送的报文\n\n\n\n5.2 看图  滑动窗口可以用下图来形象的理解，对图中的文字就不复述了（如果图片 404 了请及时告知我，谢谢）\n\n本人字丑，用 pad 写就更丑了，请谅解\n6. 流量控制  所谓流量控制，就是发送方根据对方的接收能力来选择发送数据的多少。\n如果 B 的接收缓冲区满了，会通过报文中的窗口大小告知 A，A 不再继续发送数据。\n此时，A 会在过一会后，向 B 发送一个  窗口探测  报文，该报文没有有效载荷，所以不会过多占用接收缓冲区；\nB 在收到该报文后，会回应报文，告知 A 自己的窗口大小，被称为  窗口更新\n\n7. 拥塞控制  前面提到的 tcp 处理措施，都是为了保证通信  双方的主机  不会出什么错误，导致数据的丢失。\n但是一直么有提到一点，网络出错  了咋办？\n你和对方打电话，结果电线都断了，那还咋电话呢？\n为了避免通信给网络造成太大的负担，tcp 除了考虑对方的接受能力以外，还需要考虑网络的承载能力。\n7.1 如何确认网络出问题？如果双方通信的时候，出现了丢包，我们真的能确认网络出现问题了吗？\n\n答案是否定的。\n\n你和朋友之间打电话，突然对方的声音卡了一下，你就能下结论，是的电话线断了吗？\n\n实际上，只有  你完全听不到对方声音  了，又确认双方的手机都没有问题，才能认为是通信出了问题。\n\n网络也是一样，只有出现  大面积丢包，才能认为是网络出了问题。\n我们知道，tcp 基于字节流，一次性可以发送大量的信息。要是一个进程的 tcp 连接一建立，就开始往网络里面  塞一大堆的信息，把网络给整堵塞了，那好吗？\n一个进程这么干，那多几个进程加入，网络直接雪上加霜。卡死了，谁都别想用！\n7.2 慢启动  所以，为了避免这种情况，tcp 添加了慢启动机制。\n说白了就是：刚开始发送的少，逐渐增多！\n\n\n整个过程如下：\n\n拥塞窗口从  一个段  的大小开始（约 1kb）\n拥塞窗口有一个阈值ssthresh，默认为对方的窗口大小，这在 3 次挥手的时候已经确定了\n收到  一次 ACK，且 拥塞窗口 &lt; 阈值，直接将现有拥塞窗口大小加倍【指数增长】\n也可以理解为，一个 ACK（注意是一个 ACK，并非一个报文）就加 1\n比如第一次发送了 1000 个消息，那么收到对方的 ACK 为 1000 后，直接将拥塞窗口大小加倍，此时为 2000，下一次发送就发 2000 的消息\n\n\n收到 ACK，拥塞窗口 &gt;= 阈值，窗口值 +1【线性增长】\n如果出现了  发送超时 ，阈值ssthresh 设置为  拥塞窗口 /2，拥塞窗口置为 1（从头开始，避免大面积的重传）\n拥塞窗口始终小于接收器窗口\n\n实际传输的数据大小 = min(拥塞窗口, 对方窗口大小)\n\n这便是慢启动的机制，上面贴的图能形象的展示数据慢慢增长到指数级增长的过程。\n8. 延迟应答8.1 问题\n如何在保证不拥塞网络的前提下，传输更多数据？\n\n要知道，网络环境复杂多变，一次性发送更多数据，是  优于  多次发送少量数据的\n记住：窗口越大，网络吞吐量越大，传输效率就越高！\n这时候，如何提高网络传输效率的问题，就被转换成了：上层如何尽快取走缓冲区中的数据的问题。\n\n8.2 概念  所谓  延迟应答，即收到消息后，等一会再给对方应答；\n此时等待的是  应用层取走接收缓冲区中  的数据。这样在回应 ACK 的时候，缓冲区的容量更富裕，ACK 中携带的窗口大小也就更大，下次对方就能发送更多数据，提高了 tcp 通信的效率！\n\n需要注意的是，窗口大小的增加，是与网络拥塞无关的。二者是 tcp 在传输中都要考虑的两个独立的问题。\n\n我们只要多等一等，就能给出时间让应用层取走一些数据，再给对方 ACK，就能让自己的滑动窗口大小更大！\n比如下面这个栗子：\n\n假设接收端缓冲区为 1MB，一次收到了 500KB 的数据；如果立刻应答，此时返回的窗口大小就是 500KB；\n但实际上，接收端处理的很快，在 30ms 后，应用层就取走了收到的这 500KB 的数据\n这时候，接收端在  等待  发送端给自己发来的 500KB 数据的时候，缓冲区就已经恢复成 1MB 了\n但  发送端并不能知晓这件事 ，它依旧是按 500KB 给接收端发送的信息。这时候，接收端的缓冲区就出现了 闲置\n如果我们让接受端晚一点（比如晚 200ms）再给发送端进行应答，此时应用层就已经取走缓冲区中的数据了，缓冲区大小恢复为 1MB，接收端发送的应答中滑动窗口的大小也增加为 1MB，发送端可以一次发送更多数据，缓冲区利用率提高！\n\n注意，接收端缓冲区提高，能让发送端一次发送数据量的上限提高。实际发送多少数据，还是由双方通信的内容决定的。\n\n8.3 策略  延迟应答的时间需要注意，不能太长（否则发送端会因为超时没有收到 ACK 而触发重传）；也不能太短，否则应用层还没来得及取走数据\n一般延迟应答有如下两个策略\n\n隔 N 个包应答一次\n隔一定时间应答一次（要在延迟的同时，避免对方进行超时重传）\n\n延迟应答的策略根据不同平台而不同，一般 N 取 2，间隔时间取200ms\n9. 捎带应答  在 tcp 报文的 ACK 应答的时候，如果采用一问一答的方式，会导致双方通信效率较低\nA -&gt; B 吃了吗B -&gt; A 吃了B -&gt; A 你呢？A -&gt; B 我还没有\n\n如果采用下面这种方式，就节省了一次收发的时间，提高了通信效率\nA -&gt; B 吃了吗B -&gt; A 吃了, 你呢？A -&gt; B 我还没有\n\nTCP 的捎带应答就是如此，在回答对方的消息 (ACK) 的同时，携带上自己要发送给对方的信息。\n要知道，所谓的 ACK 报文，只是需要将报头中的 ACK 标记位置为 1 即可，并不影响这个报文其他部分的功能！\n\n10. 面向字节流  调用 write 时，数据会先写入发送缓冲区中，并不是立马发送给对方\n\n如果一次性发送的字节数太长，会被拆分成多个 TCP 的数据包发出\n如果发送的字节数太短，可能会在缓冲区中等待，到一定数据量后，再发出\n\n这两个操作都是 TCP自主帮我们完成  的\n\n接收数据时，数据从  网卡（数据一定是先被网卡收到的），被驱动程序读取后，流入操作系统的接收缓冲区\n应用层调用 read 从接收缓冲区中拿到数据\n\n因为同时拥有接收和发送缓冲区（全双工），所以 TCP 程序的读写  不需要完全同步\n\n写 100 个字节，可以调用 write 写入 100 个字节，也可以调用 100 次 write 写入 1 个字节\n读 100 个字节，也可以多次读取，或一次性读取完毕\n二者都不需要考虑对方的写入是如何写入的！\n\n因为数据在缓冲区中都是没有严格分界的  字节数据 ，TCP 不关心这些数据的组成，所以 TCP 是面向字节流的。我们只需要读取之后，依照 应用层  的协议  进行数据的处理即可。\n这也是为什么使用 TCP 时，应用层的协议  需要规定一个协议中数据的边界（比如报文中数据字节的长度，或者用特殊字符来做边界，参考 HTTP 协议）\n11. 粘包问题  前面提到了，tcp 在读写数据的时候，并没有严格的读取字节的要求，那么就可能会遇到下面的问题（C 代表发送端，S 代表接收端）\n假设应用层定义的协议一个报文是 100KB 大小；C -&gt; 100KB SC -&gt; 100KB SS 一次性读取了 150KB 的数据；此时，它读取了 1.5 个应用层的报文，并不完整！\n\n这种情况，被称为  粘包问题\n解决粘包问题最好的办法，就是要明确  报文和报文之间的边界 ，其通过 应用层  的协议来明确，必须要在应用层来处理；\n\n定长报文，要求双方都必须读写特定长度的报文，多的拆包，少的补空\n变长报文，可以采用在报文开头写明本条报文长度的方式，告知对方应读取多少字节\n变长报文，还可以采用数据分隔符的方式作为边界（需要保证正文中不能出现分隔符，比如 http 中的\\r\\n）\n\n对于 UDP 而言，并  不存在  粘包问题。因为 UDP 采用的是定长报文（面向数据报），应用层只会读取到一个完整的报文。\n如果 UDP 的一个报文不完整，代表数据在传输过程中出现了丢失。\n12.UDP 可靠传输  有的时候，会遇到这个问题。解决这个问题的思路就是：借鉴！\ntcp 就是可靠的传输机制，我们只需要在 tcp 里面选择一部分tcp 协议的特性，加到 udp 中，就能在一定程度上实现 udp 的可靠传输\n\n报文中添加序号，保证按序到达\n引入确认应答，确认对方收到了信息\n引入按序到达，保证数据包发送的顺序正确\n引入超时重传，如果一段时间对方没有应答，则重发\n…\n\n这些操作就需要程序猿在应用层去实现了。\nThe endUDP&#x2F;TCP 协议的基本知识如上，后续还会继续补充\n","categories":["玩上Linux"],"tags":["Linux","tcp","udp"]},{"title":"【建站】hexo 搭建博客 + 建站相关教程","url":"/posts/1888648770/","content":"关于 HEXO 建站相关博客汇总\n\n\n1.hexo 部署和主题自定义【教程】hexo 搭建博客 +keep 主题美化\n2. 配置图床  以下为 typora+picgo 配置图床的教程\n【Picgo】正确重命名文件，避免重复上传\n2.1 阿里云 oss【教程】Typora+PicGo+ 阿里云 OSS 搭建博客图床\n2.2 又拍云 uos相比于阿里云 oss 的 bucket 只有防盗链，又拍云的 uos 还有 ip 黑白名单，cc 防护，单 ip 访问限制等等功能。对于博客图床防盗刷而言，很有用。\n但又拍云 uos 需要  域名已备案  才能自定义域名，否则只能使用官方提供的测试域名。如果你的域名已备案，个人更推荐使用又拍云 uos 作为博客图床。\n【教程】Typora+PicGo+ 又拍云 USS 搭建博客图床\n2.3 自建图床 lsky自建图床的优势在于，图片都在你服务器的本地，可以直接 tar 打包进行备份，或者手动从服务器下载到电脑作为备份。\n个人不太喜欢 oss 的一点，就是大多数 oss 服务商都没有提供批量下载 oss 内部文件的选项。估计是考虑到存储服务器的负载问题，所以没有提供这个功能。毕竟批量下载大量文件，是很耗资源的。\n虽然可以用 python 代码来实现批量下载，但服务商能直接提供批量下载的功能，还是更方面嘛！\n兰空图床是自建图床中比较方便的一个，且支持 picgo 上传\n【Docker】配置 lsky pro 兰空图床 \n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【网络】IP 网络层和数据链路层","url":"/posts/3482559497/","content":"IP 协议详解\n\n\n1. 概念1.1 四层模型\n应用层：解决如何传输数据（依照什么格式 &#x2F; 协议处理数据）的问题\n传输层：解决可靠性问题\n网络层：数据往哪里传，怎么找到目标主机\n数据链路层（物理层）：数据在物理硬件层面上传输\n\n网络层的 IP 协议，就是让网络，拥有将数据从 A 主机发送到 B 主机的能力。\n\n注意：拥有此能力，并不代表每次都能成功送达！（即可靠性非 100%）\n\n而失败的时候，就需要  传输层  来获取发生错误的原因，并进行错误重传或者超时重传等操作。\n所以，在从网络层获取到信息成功送达到对方的反馈之前，传输层需要暂时保留已经发送的数据。如果网络层发送失败了，传输层需要进行重发操作，以保证可靠性。\n\n1.2 主机、路由器、节点\n主机：拥有 IP 地址，但不进行路由控制的设备\n路由器：拥有 IP 地址，并进行路由控制的设备\n节点：主机和路由器的统称\n\n2.IP 报文2.1 报文结构IP 协议的报文与 TCP 的报文有一定程度上的相似\n下图为 IPV4 中报文的格式（IPV6 的报文和下图是不同的）\n\n\n四位版本号：指定 IP 协议的版本，IPV4 来说就是 4\n四位首部长度：IP 报头的长度（和 TCP 的定义一样，标准长度需要用  四位首部长度 * 4 字节 ，即最大报头长度为15*4=60 字节）\n八位服务类型：包含 3 位优先权字段（已经弃用）、4 位 TOS 字段和 1 位保留字段（必须置为 0）四位 TOS 分别表示：最大吞吐量、最高可靠性、最小成本、最小延时。只能四选一，需要根据具体传输层的协议要求进行选择。\n十六位总长度：包括报头的整个报文的长度，减去四位首部长度就能得出报文中数据字段的长度。\n十六位首部校验和：使用 CRC 校验来判断报头是否有数据损坏\n八位协议：上层协议类型（比如 tcp、udp、ssh 等）解决如何向上层交付的问题\n八位生存时间（TTL）：用于控制 IP 报文能在网络层传输的时间（生命周期的限制）比如有些报文由于路由时出现了错误，陷入了路由的死循环；亦或者是路由程序出现了 BUG，导致没办法被正常转发到正确的主机上；还有路由超时的问题。此时这个出错的报文就会在路由里面长时间游离而没办法抵达目的地（好比内存泄露）。规定了 TTL 之后，可以在 IP 报头中中记录报文的生命周期时间，当报文转发的耗时已经大于这个 TTL 之后，就将这个报文丢弃。\n三十二位源地址和三十二位位目标地址：表示发送端 IP 和接收端 IP\n选项字段：不定长，最多 40 字节（这是因为首部默认是 20 字节，再加上首部长度最多只能表示 60 个字节，所以选项字段就是 60-20=40）\n此处省略了几个字段，会在后文的  分片  中说明……\n\nIP 协议的报文中没有端口号，因为端口号是  传输层应该解决  的事情（UDP 和 TCP 的报头中才有端口号的字段）IP 层只关注如何将报文发送给目标主机。也就是两个主机之间如何正常通信的问题。\n2.2 分片 2.2.1 认识 MTUMTU 相 当于  发快递时对包裹尺寸的限制，这个限制是不同的  数据链路层  对应的物理层产生的限制。\n\n以太网帧中的数据长度规定最小 46 字节，最大 1500 字节；\nARP 数据包的长度不够 46 字节。要在后面补填充位；\n最大值 1500 称为以太网的最大传输单元(MTU)，不同的网络类型有不同的 MTU；\n如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的 MTU 了，则需要对数据包进行分片(fragmentation)；\n不同的数据链路层标准的 MTU 是不同的；\n\n所以，数据链路层不支持过大的数据，这就需要在网络层对数据进行分片。\n而网络层 IP 协议会  自动  帮我们分片，并在接收端组装。这个行为对传输层来说是不需要关注的，在  四层模型  中，每一层之间的功能需要进行解耦。\n分片之后，只要有一个分片报文丢失，这个报文的整体就会认为丢失了（因为没有办法拼出完整的报文数据）\n\n但这样就引出了一个问题：分片会提高丢包的概率，影响传输速率（发一次快递和发三次快递，明显三次快递丢东西的可能性更高）\n对于具有可靠性机制的 TCP 而言，丢包问题不大，我们可以在传输层进行重传。但 UDP 没有可靠性，此时出现分片后丢包了就没办法找回了。\n所以，网络层进行分片并不是主流！相比之下，在传输层就进行分片才是更好的选择。\n2.2.2 如何分片  在 IP 报头中，如下字段就是用于分片和组装操作的\n\n\n十六位标识 (id): 唯一的标识主机发送的报文。如果 IP 报文在数据链路层被分片了，那么  每一个片里面的这个 id 都是相同的\n三位标志字段: \n第一位保留 (保留的意思是现在不用， 但是还没想好说不定以后要用到)。 \n第二位置为 1 表示“禁止分片”， 这时候如果报文长度超过 MTU， IP 模块就会丢弃报文。 \n第三位表示”更多分片”， 如果分片了的话， 最后一个分片置为 0， 其他分片报文都是 1；0 就类似于一个分片的结束标记\n\n\n十三位分片偏移 (framegament offset): 是分片相对于原始 IP 报文开始处的偏移。 其实就是在表示当前分片在原完整报文中处在哪个位置。实际偏移的字节数是这个值 * 8 得到的。因此， 除了最后一个报文之外， 其他报文的长度必须是 8 的整数倍 (否则报文就不连续了)\n\n这一点非常重要！一定要记住：除了最后一个报文之外， 其他报文的长度必须是 8 的整数倍。\n此时，只要将三位标志字段中的  更多分片  置为 1，就代表当前报文并不是一个完整的报文，而是已经被分片后的报文。\n\n\n更多分片为 0，且分片偏移为 0，代表当前报文没有进行分片；\n更多分片为 1，且分片偏移为 0，代表当前是分片后报文中的第一个；\n更多分片为 0，且分片偏移  不为 0，代表当前是分片报文中的最后一个；\n\n\n此时就需要根据十六位标识来确定当前分片属于哪一个“组”，再将当前报文和后续收到的 ID 相同的报文集合在一起，通过十三位片偏移来进行排序，组装成完整数据！\n比如，第一个报文的起始偏移量是 0，第二个是 1000，第三个是 2000，这时候就根据片偏移排序进行拼接就可以了。（这只是个栗子）\n\n如何保证收完了？\n\n根据十六位标识，按照片偏移进行排序，排序后发现缺失了部分的报文，那就代表没有被收完。因为每一个报文的  偏移量 + 该报文长度 ，就是下一个报文的 偏移量！只要数据对不上，那就代表丢东西了。\n而开头和结尾的报文，就能通过上面提到的根据  更多分片标记位 + 分片偏移  来确定有没有丢。\n2.2.3 如何减少分片  虽然说 IP 网络层会自动帮我们分片，但是否分片是  可以通过传输层  来进行控制的\n只要传输层一次交付的数据没有超过需要分片的阈值，那网络层在传输的时候就不会进行分片了！\n减少分片的方式，那就是在传输层就进行一定的分片，这样能更好将  丢分片报文  这件事在传输层进行处理。而不是在网络层丢包后，没办法在传输层失败并处理。\n\n传输层进行限制  如果是 TCP 协议，在三次握手的时候，就会协商双方单词传输数据的大小。从而避免网络层对数据进行分片，以规避数据链路层的 MTU 限制。同时也维护了滑动窗口，如果网络层的传输出现了丢包，由传输层来进行重传操作，以实现可靠传输。\n\n限制成多少好呢？\n\n一般建议将该大小设置为比网络中的最小 MTU 值小一些，以防止出现分片\n\n后续会补上更多信息\n\n2.2.4 分片的限制  在上文中提到，MTU 的限制是最大 1500 字节，这个数据长度是包含 IP 协议的报头的（数据是从 IP 网络层向下交付给数据链路层的）\n假设我们有一个  网络层的 3000 字节  的数据，此时网络层要进行分片，并不是简单的 3000/1500=2 就能搞定了的。而是要计算上 IP 报头的长度（20 字节）\n每一个分片都是一个独立的 IP 报文，都会有自己独立的 IP 报头！否则缺少报头，在接收端没有办法进行数据组装操作。\n20+148020+148020+20\n\n一共需要分 3 片，才能将这网络层的 3000 字节的数据成功传输！\n但是这里就有一个问题了，明明1480+1480+20 = 2980，并不是 3000 字节啊？\n注意！上面提到的是网络层的 3000 字节数据。实际上，传输层只向下交付了 2980 字节 ，加上 IP 报头 20 字节才是 网络层的 3000 字节  数据。因为要进行分片，原本这 3000 字节的统一报头肯定是要丢弃的，我们需要操作的是传输层向下交付的 2980 字节数据，将其正确分片并添加上每一个分片的报头，再交给数据链路层。\n2.3 TTL上文提到 TTL 是用来控制报文的生命周期的，其为了避免报文在路由中出现  死循环。\n比如下图中，假设有一个报文路由到了路由器 D，原本他应该被正常交付给主机 C，但路由器 D 出现了一些问题，将这个报文交付给了路由器 I，路由器 I 给 J，J 给 H，H 给 C，路由器 C 又给 D，路由器 D 还是有 bug，又转发给了路由器 I。\n这时候，就出现了一个报文路由的死循环。\n如果没有 TTL 来控制生命周期，报文就会一直在这个死循环中跑，白白浪费路由器的性能！\n\n规定了 TTL 之后，当报文的生命周期已经到了，但却还没有发送到目的地，那就需要将这个报文丢弃了。（即超了 TTL 的时间就认为报文无效）\n3. 网段划分3.1 IP 如何找到对方主机？IP 如何找到对方主机呢？\n\nIP &#x3D; 目的网络 + 目的主机\n由此还衍生出网段划分\n\n以 IPV4 的 ip 为例，其格式为1.1.1.1，可以认为是下面的划分\n1.1.1  .1网段   . 主机\n\n这就好比你的学号，前 X 位里面是学院的代码，最后才是班级 + 班级内编号。先找到你所在学院，再找到班级，最后再找到你。\n反馈到 IP 里面，就是先找到网段，再找到主机。\n3.1.1 发送数据的本质 IP 就是先找到目的的 网段 ，再找这个网段中的目的 主机。（先根据目的网段进行路由，找到目的网络，再通过主机号找到目的主机）\n而查找目的主机的过程，本质是一个  排除  的过程。\n先通过网段排除一个大类，再通过主机号来排除该网段中的单个主机。这样就能避免我们  一个一个遍历  在全网中查找主机，提高了查找的效率\n\n子网划分的目的：就是提高查找目标主机的效率\n\n这也是学校里面用学号的原因，除了为了给每个学生提供一个唯一标识，还能通过学号来提高查找到某一个学生的效率。\n在全球互联网上，同样是通过 IP 地址的网段来划分国家，再划分到每个国家内部的不同区。这时候就会有一定 IP 地址资源的竞争。比如米国互联网发展早，下图中谷歌的服务器 IP 就老整齐了😂（不过这些服务器都在同一个地域，IP 很接近是合理的）\n\n3.1.2 网络号和主机号\n网络号：保证相互连接的两个网段具有不同的标识\n主机号：在同一网段中，主机之间具有相同的网络号，但是主机号不同以进行区分\n\n具体框架可以查看下图，192.168.128就是这个局域网的网段 ，而最后的 10 和 11 是不同主机的两个主机标识。一般情况下，网段中的 1 号主机就是这个网段中的路由器。\n\n我们家里的路由器除了进行路由转发，还有子网划分的功能。\n\n如果出现了一个开头并非 192.168.128 的 IP，主机就能知道这不是当前局域网的 IP，于是就会将报文直接转发给192.168.128.1，让路由器去找这个 IP 的目标主机（进行跨局域网的下一层转发）\n\n就好比我们的学号是学校的教务系统派发给每一位同学的，IP 中的网段也被“某人”在一定程度上根据地区进行了划分。\n3.2 IP 地址类别划分 3.2.1 ABCDE 通过 A 到 E 类不同的划分，会衍生出不同范围的 IP 号，然后再分配给不同的国家或地区\nA 类 0.0.0.0 到 127.255.255.255 B 类 128.0.0.0 到 191.255.255.255 C 类 192.0.0.0 到 223.255.255.255 D 类 224.0.0.0 到 239.255.255.255 E 类 240.0.0.0 到 247.255.255.255\n\n\n依照上面的划分，如果我是一个大型企业，申请了一个 B 类的 IP 地址。此时就能支持我的局域网内 2^16 台主机的 ip 分配。但实际上我顶多会有 2w 个主机，此时就出现了 IP 地址的浪费！\n3.2.2 CIDR 和子网掩码  为了避免上文中出现的 IP 浪费问题，CIDR（Classless Interdomain Routing）就出现了\n\n引入一个额外的子网掩码 (subnet mask) 来区分网络号和主机号；\n子网掩码也是一个 32 位的正整数. 通常用一串 0 来结尾，一串 1 开头；\n将 IP 地址和子网掩码进行 按位与 操作, 得到的结果就是网络号；\n网络号和主机号的划分与这个 IP 地址是 A 类、B 类还是 C 类  无关\n\n如果我们需要更多主机，就可以将子网掩码中最后一个 1 置 0，就能适配更多局域网主机。\n所以，现在已经不用 ABCDE 的类别划分方式了，都采用了  子网掩码  方式。\n\n根据上图可见，IP 地址与子网掩码做与运算可以得到网络号，主机号  的二进制位从全 0 到全 1 就是子网的地址范围； \nIP 地址和子网掩码还有一种更简洁的表示方法：例如 140.252.20.68/24, 表示 IP 地址为140.252.20.68, 子网掩码的 高 24 位是 1，也就是子网掩码255.255.255.0\n3.3 基础设施  有了网段划分，给不同国家和地区划分了 IP 之后，就需要有人来建设网络的  基础设施\n在我们国家，搞基础设施就是三大运营商（移动 电信 联通）\n比如几年前做的“光纤入户”就是基础设施建设的一部分。\n基础设施搭建好了后，再通过子网掩码和已经获取到的 IP 的网段来划分不同省份、不同市区；最终再落到每个入网用户的头上。\n3.4 缓解 IP 地址不够用的办法  有人肯定会问了，现在公网 IPV4 的资源那么匮乏，大部分家宽都是没有公网 ip 的，那我们平时的上网是怎么实现的？\n换句话说，如何缓解 IP 地址的匮乏？\n\n可以使用  动态 IP 分配  技术，只给直接接入公网的设备分配 IP 地址，每一个设备接入网络时，其获取到的 IP 地址不一定和上次相同。\nNAT 技术（重点）\nIPV6（但是现在普及率有待提高）\n\nIPV6 使用 16 字节（128 位）来标识一个 IP 地址，目前看来，2^128 位能给“地球上每一粒沙子”都分配一个 IP 地址了。虽然迟早也会有不够用的那一天，但至少是一个很不错的解决方案。我们国家就在大力推广 IPV6\n通过前文的报文结构图可知，IPV4 的 IP 地址只有 4 字节（32 位）\n\n4. 私有 IP4.1 特殊的 IP 地址  但是，直接采用 CIDR 的方式作为局域网控制的方式，就容易出现混乱。而且即便是采用了子网掩码的方式，依旧可能出现 IP 不够用的情况（一位网民很可能有多个设备， 再加上各类智能终端，现在需要上网的设备只会越来越多）\n需要注意的是 CIDR 只能提高 IP 地址的利用率，并不能提高 IP 地址的上限。\n所以，就衍生出了部分特殊的 IP 地址。这些 IP 地址被规定  只能用于局域网，由此来减少对公网 IP 的地址消耗。\n\n将 IP 地址中的主机地址全设为 0，就是该地址的网络号，代表当前局域网\n将 IP 地址中的主机地址全设为 1，就是广播地址，用于给同一个链路中相互连接的所有主机发送数据包。\n127.*的 IP 地址用于  本机回环 。我们通常使用127.0.0.1 来进行本地服务的访问和测试，该 IP 地址是 IPv4 回环地址的标准规定，IPv6 的回环地址为::1。\n\n我们在计算一个局域网中有多少设备的时候，需要减掉上文提到的网络号和广播地址。\n\n以下是特殊的只能用于局域网的私有 IP 地址，包含在这个范围中的， 都称为私有 IP， 其余的则称为全局 IP (或公网 IP)\n\n10.*, 前 8 位是网络号，共 16,777,216 个地址 \n172.16.到 172.31.，前 12 位是网络号，共1,048,576 个地址 \n192.168.*，前 16 位是网络号，共 65,536 个地址\n\n这里要记住 2 的 16 次方为65536，在网络的知识点里面经常会接触到这个数字。\n4.2 loopback 环回  上文提到了 127.* 是用于本地环回的。下图是环回驱动程序针对 IP 地址的判断\n\n在云服务器上执行ifconfig，也能看到本地环回的配置项；这里我们能发现，本地环回的 MTU 是远高于网络的 1500。毕竟是自己和自己通信，基本不会出现丢包，传输速度也是飞快，也就不用担心数据包太大的问题\n同时也能发现，我们的云服务器被分配到的 ip 地址并不是云服务器的公网 ip，这也就表明了我们的云服务器并没有被直接暴露在公网上，而是通过了云服务器厂家的入网服务器（或者也叫路由器）来进行公网 ip 的映射和数据包的转发操作。\neth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 10.0.12.2  netmask 255.255.252.0  broadcast 10.0.15.255        inet6 fe80::5054:ff:fec9:274f  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 52:54:00:c9:27:4f  txqueuelen 1000  (Ethernet)        RX packets 277674393  bytes 80031748700 (74.5 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 302405663  bytes 162670581730 (151.4 GiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 111135687  bytes 27644436547 (25.7 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 111135687  bytes 27644436547 (25.7 GiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\n4.2.1 环回  上图中的环回驱动程序会直接和 IP 协议的接收端（即 IP 输入函数）相连，当检测到 127.0.0.1 的 IP 访问请求的时候，会直接把这个报文转发给 IP 输入函数，而不将其插入到以太网中。\n就相当于你知道 127.0.0.1 这个 IP 地址代表的就是你自己，你想访问自己电脑上 8080 端口的程序，即便么有接入互联网的状况下也是能正常访问的！\nLoopback 环回接口对于  测试和诊断本地主机上的网络服务和应用程序  非常有用，因为它可以模拟网络通信而不涉及实际的网络传输。\n4.2.2 ARPARP 是一个在局域网数据链路层通过 IP 获取到局域网主机 MAC 地址的协议，具体请参考后文中的解析\n\n4.3 访问广域网的步骤 4.3.1 说明 下图中能看到我们家用主机是怎么来进行广域网的访问的基本流程；\n我们家里的路由器除了进行路由转发，还有子网划分的功能。可以看到左下角虽然是两个不同的家庭，但其可以分配出完全一样的局域网的子网 ip 192.168.1.1，和不同的 WAN 口 IP（WAN 口就是路由器连接互联网的口）\n这是因为我们的设备是直接和  当前路由器  相连的，访问的时候也只能通过  当前路由器  来进行局域网 IP 的转发。不可能会出现我访问一个局域网 IP，却跑到了别人家里的设备上的情况。因为这个局域网 IP 访问的报文并不会被转发到上层路由器上，也就不可能凭空飞到其他局域网中\n\n图中的 122.77.241.3 就是一个公网 IP 的服务器，当我们需要访问这个主机的时候，局域网的家用路由器在检测到这个目的 IP 的时候，发现其并不是局域网的 IP 地址，于是就会将这个报文给转发给上层的运营商路由器。\n运营商路由器是直接接入了公网 IP 的，其就能通过  网段划分 + 主机编号  来查找目标主机，将报文转发给 122.77.241.3  服务器，再将服务器返回的信息转发给你的家用路由器，再转发到你的主机上。\n这也告诉我们，想绕过运营商直接获得公网 IP 是不可能的，因为从  物理层面上，我们的家用路由器就不是接在公网 IP 上的！即便是可以申请到的家用公网 IP，也和云服务器的入网服务器一样，是运营商的路由器分配给你的。\n\n你会发现，家用申请的公网 ip，很多端口都是被屏蔽的（比如 80/443/8080）这些端口的屏蔽操作，以及海外网站的「墙」也是运营商的路由器进行检测和屏蔽的！\n\n4.3.2 内网访问公网的流程  假设我们的模型如下\n广域网   ↓ 运营商路由器 C （公网 IP 是 122.77.241.4）  ↓家用路由器 B （运营商路由器分配私有 IP 10.1.1.2）  ↓家用主机 A （家用路由器分配私有 IP 192.168.1.201）\n\n下面是一个家用主机 A，访问公网 IP 的主机 122.77.241.10 的具体步骤；\n本地主机 A 发送 IP 报文给家庭路由器 B————————————————————————| 源 IP：192.168.1.201   || 目的 IP：122.77.241.10 |————————————————————————路由器 B 收到报文后，检测目的 IP，发现并不似局域网的 IP于是交付给上层的运营商路由器 C；报文的源 IP 被修改为家用路由器 B 的 wan 口 IP————————————————————————| 源 IP：10.1.1.2        || 目的 IP：122.77.241.10 |————————————————————————运营商路由器 C 收到报文后，发现其也不是自己所在内网 10.1.1.* 的局域网 IP于是开始执行广域网 IP 寻址操作，找到目标公网 IP 的主机，再将报文发送给该主机；此时发送的报文又被改成了————————————————————————| 源 IP：122.77.241.4    || 目的 IP：122.77.241.10 |————————————————————————\n\n4.3.3 NAT 技术  这种不断替换源 IP 来进行路由转发的过程，就是NAT 技术！\n也正是 NAT 技术的存在，让我们能通过多级局域网来让更多的设备上网，大大缓解了公网 IP 的不足。\n也正是因为 IPV4 地址不足的问题被大大缓解，推广 IPV6 就没有我们想象中的那么顺利了。毕竟 IPV6 的 IP 格式和 V4 完全不同，需要每个层级的路由器都进行功能升级，这可是一个巨大的工程！\n\n4.3.4 NAT 怎么回来？NAPT当目标主机收到这个报文后，他的反馈报文如下\n————————————————————————| 源 IP：122.77.241.10   || 目的 IP：122.77.241.4  |————————————————————————\n\n同样是先到达运营商路由器，运营商路由器需要缓存每一个转发到公网的报文的来源信息；为此路由器会维护一个  转换表 ，记录着局域网主机的 私有 IP 地址: 端口号  与对应的  公网 IP 地址:NAT 端口号  的映射关系。\n比如此次 TCP 链接中，我将路由器公网 IP 的 122.77.241.4:30000 映射给了局域网 10.1.1.2:40000；当从公网收到服务器的响应报文后，从 转换表  里面就能够查到这个映射（一次通信中这个 NAT 映射是不会变的）从而确定该报文的局域网流向。\n\n需要注意的是，NAT 技术在端口映射的时候不一定会映射到和内网主机相同的端口，此时不仅需要修改 IP 报文中的来源 IP，还需要进一步修改传输层（比如 TCP 和 UDP）中的源端口号\n\n确定局域网 IP 后，就修改当前报文的目的 IP，继续往局域网转发；后面的子路由器也是如此，不再赘述。\n————————————————————————| 源 IP：122.77.241.10   || 目的 IP：10.1.1.2      |————————————————————————\n\n这种 IP: 端口 的关联关系表，就是由支持 NAT 技术的路由器来维护的，这个转换表被称为NAPT；当这次链接结束后，这对映射关系就会从转换表中被删除。\n\n4.3.5 NAT 和代理服务器  代理服务器看上去和 NAT 设备有一定类似，客户端向代理服务器发送请求，代理服务器将请求转发给真正需要请求的服务器；服务器返回结果后，代理服务器把结果传回客户端。\n4.3.5.1 NAT 和代理服务器的区别？\n从应用来说，NAT 是属于网络基础设置，解决的是公网 IP 不足的问题；代理服务器更贴近具体应用，比如通过代理服务器进行“翻墙”和游戏加速；\n从底层来讲，NAT 在网络层工作，对 IP 地址进行替换；代理服务器是在应用层工作；\n从使用范围来讲，NAT 一般部署在局域网出口，代理服务器既可以在局域网又可以在广域网部署\n从部署位置来看，NAT 集成在路由器或者防火墙的硬件上；代理服务器本质上是一个应用层软件，部署在服务器上\n\n代理服务器应用相对来说也比较广\n\n翻墙：广域网代理\n负载均衡：局域网代理\n\n4.3.5.2 反向代理  代理服务器分为正向代理和反向代理，这里来说说  反向代理，反向代理处于目标服务器和客户端之间，客户端通过反向代理访问目标服务器，而不会直接连接到目标服务器\n\n通过反向代理服务器作为一个云服务器主机集群的入网服务器\n举例，一个网站拥有 10 台提供服务的服务器和一台反向代理服务器\n域名解析到反向代理服务器\n反向代理服务器通过服务器监控程序，获取到 10 台服务器中负载最低的那个，并将报文转发给它\n反向代理服务器还会识别 10 台服务器中是否有宕机的服务器，如果有，则会告警给维护人员，并不再给这个宕机的服务器转发报文\n反向代理服务器还可以设置黑白名单，当遇到 DDOS 攻击的时候，将来源 IP 放入黑名单进行屏蔽，避免过多的访问让所有服务器都宕机影响业务；将本公司的其他服务器放入白名单（一般白名单都很短）\n\n反向代理的作用\n\n通过反向代理服务器实现了  负载均衡\n便于  统一管理  服务器集群，提供统一入网服务器\n避免了直接将提供服务的主机 IP 暴露在公网上而被直接攻击的问题，提高了  安全性。\n反向代理还能对网页内容进行一定的  缓存，从而减轻后端服务器的负担（比如缓存网页前端的静态资源，当用户访问的时候，由代理服务器直接返回资源，而不需要去请求实际提供服务的服务器）\n\n总之好处多多！\n4.3.5.3 正向代理  正向代理是位于客户端和目标服务器之间的中间服务器。客户端通过正向代理来访问互联网上的资源，而不是直接连接到目标服务器。正向代理的作用主要有以下几点：\n\n访问控制和过滤： 正向代理可以用于限制用户访问特定网站或资源，以实施访问控制策略。它可以过滤不良内容，提供更好的安全性和隐私保护。\n隐藏客户端身份： 正向代理可以隐藏客户端的真实 IP 地址，从而保护用户的隐私和匿名性。目标服务器只能看到代理服务器的 IP 地址，而无法获取到真正的客户端信息。\n缓存和加速： 正向代理服务器可以缓存常用的内容，从而减少对目标服务器的请求，提高访问速度。\n突破防火墙限制： 在一些网络环境中，访问特定网站可能受到限制或封锁。使用正向代理可以绕过这些限制，访问被封锁的资源。\n\n4.4 ISP 检测宽带账户\n下文中的部分内容来自 chatgpt，我对里面的内容进行了补充和修改\n\n运营商的路由器还会检测我们的账户是否还有余额。我们的家用路由器一般是通过光猫登录了自己的宽带账户；也可以将光猫设置成桥接模式，将接入光猫的路由器设置为宽带帐号（PPPoE）上网方式，登录运营商提供的宽带账户和密码，来接入网络。\nISP 的路由器检测你的宽带账户通常是通过以下步骤来完成的：\n\n设备连接与识别： 当你的计算机或其他网络设备连接到 ISP 提供的路由器时，路由器会分配一个私有 IP 地址给你的设备。这个 IP 地址是由路由器动态分配的，并且通常处于特定的私有 IP 地址范围，比如 10.11.1.0/16 或10.11.1.0/24等。此时，你的设备与路由器建立了一个  大局域网  内的连接。（运营商并不会直接给你分配 192.168.* 这样的私有 IP，因为这个 IP 一般是用于  最底层局域网  的，给你分配了，那家庭局域网的就没 IP 用了）\n认证过程： 在你尝试访问互联网时，ISP 的路由器会引导你的设备进行认证过程。这通常涉及向 ISP 服务器发送你的宽带账户的登录凭据（例如，用户名和密码）。\n账户验证： ISP 的服务器会验证你提供的登录凭据是否与其记录中的账户匹配。如果验证成功，说明你的宽带账户是有效的，路由器会为你的设备分配一个公共 IP 地址，这个 IP 地址是可供互联网访问的。\nIP 地址分配： 一旦认证成功，ISP 的路由器会为你的设备分配一个公共 IP 地址。这个 IP 地址是在互联网上唯一标识你的设备的地址，使你的设备可以与其他互联网设备进行通信。\n数据传输： 一旦有了公共 IP 地址，你的设备就可以与互联网上的其他设备进行通信，发送和接收数据。\n\n这样，通过认证和 IP 地址分配的过程，ISP 的路由器可以检测并识别你的宽带账户，从而让你的设备能够访问互联网。\n人话就是，登录了宽带账户  以后，当我们路由器发送的报文交付到运营商路由器的时候，该路由器就会检测你这个宽带账户的余额。如果没有余额了，就会直接丢弃掉你的 IP 报文。我们看到的结果就是无法上网！\n\n这个操作并不是每次都会执行的，只要你的路由器能稳定的接入到运营商的路由器上，那就不会每次都进行宽带账户的验证，否则会增加网络的负担。\n具体的验证流程都是运营商路由器和你的本地光猫自动完成的。\n\n而手机没有话费余额的时候，我们依旧能拨通诸如 120、119 等紧急号码，这也是运营商的服务对这些特殊的电话号码做了类似于  免费白名单  的操作（手机号码可以类比公网 IP 来理解）\n5. 域名 5.1 DNS 服务器 上文讲述的都是关于 IP 协议的事情。但实际上我们日常生活中，一般都不会直接使用 IP 地址 + 端口号的方式来访问某一个服务，而是使用域名来访问。比如\nwww.baidu.comwww.google.com\n\n所谓域名，就是这些  英文字符串  和 IP 的映射。\n比如 baidu.com 就是一个域名，而 www.baidu.com 是该域名下的三级域名（几级域名可以看有几个点）\n实际访问的时候，是百度在域名注册商哪里，将 www.baidu.com 指向了自己的服务器的地址(假设指向的是1.1.1.1) 我们访问百度，实际上访问的就是 IP 地址 1.1.1.1；\n\nDNS 是应用层协议，底层使用的是 UDP\n系统会缓存一部分 DNS 的结果\n\n在主机本地，有一个 hosts 文件，也可以用于设置主机到域名的映射，在 linux 里面就是 /etc/hosts 这个文件。 在访问域名的时候，操作系统会先检查自己本机器的 hosts，如果本地没有，就请求 DNS 服务器来获取解析结果。\n5.2 域名访问主机流程  当我们访问一个域名的时候，首先会去请求特殊的 DNS 服务器\n8.8.8.8 谷歌公司的 DNS 服务器119.29.29.29 腾讯提供的公共 DNS\n\n先请求这些 DNS 服务器，服务器内会针对域名查询对应的 DNS 解析，最后再访问该解析对应的 IP 地址\n而使用域名的时候，默认访问的是该主机的 80(HTTP)/443(HTTPS) 端口 ，我们也可以像 IP 一样，在域名之后用 : 端口 来指定特定端口号进行访问，即 域名: 端口。\n一般情况下，我们的主机都可以通过  自动配置 DNS从上层路由器中获取到 DNS 服务器的地址（比如运营商会在路由器基站中内置 DNS 服务器）\n5.2.1 DNS 劫持  所谓 DNS 污染和 DNS 劫持，就是因为我们访问的 DNS 服务器的时候，获取到的结果和预期不同，从而导致无法访问目标网站，或者访问了  假的目标网站\nwww.baidu.com 明明应该指向 1.1.1.1但被坏蛋劫持了 DNS 解析，变成了指向 1.1.1.3\n\n坏蛋可以在 1.1.1.3 服务器上，搭建一个和百度「看起来」一模一样的页面，并将你的报文给转发到百度服务器上。此时他就通过中间转发，获取到了你报文中的用户信息、密码等等参数；\n这时候因为这个  假的服务器  是直接给你提供服务了，使用的 HTTPS 证书也是这个假服务器的证书，对方可以直接通过自己的证书解密获取到你的信息，再转发给百度。\n5.2.2 DNS 和负载均衡  对于大公司而言，DNS 解析还有一个重要的作用，就是通过不同区域的设置来实现负载的均衡。\n假设百度在每一个省份都设立了一个自己的机房，那么它就可以通过 DNS 服务器，当不同省份的用户请求服务器的时候，返回他当前所处省份的机房地址。这时候就实现了每个机房的负载均衡。\n在现实中，就是将你的请求转接到离你最近的拥有机房的省份，这样既能保证所有服务器的负载均衡，又能保证你的访问能较快地获取到响应（广东访问广州的服务器，肯定比访问北京服务器的延迟低一些）\n5.3 DNS 分层DNS 服务器不会存放所有已知域名的 IP 解析，因为互联网上存在大量的域名，数量庞大且不断增长，单一 DNS 服务器无法存储和处理所有域名的 IP 映射。\n实际上，DNS 服务器通过  分层的架构  来解决这个问题。在根 DNS 服务器层级，有一组全球性的顶级 DNS 服务器，它们存储顶级域名（例如 .com、.org、.net 等）的 IP 地址。然后，在每个顶级域名下，有其他 DNS 服务器，负责管理该顶级域名下的子域名（例如，google.com、facebook.com等）。这个过程继续向下，形成了一个层级结构。\n当你的设备需要解析某个域名时，它首先会向本地 DNS 服务器（通常由你的 ISP，即  互联网服务提供商 ，人话就是国内的三大运营商提供）发起请求。如果本地 DNS 服务器知道所需域名的 IP 地址，它会直接返回该 IP 地址给你的设备。但如果本地 DNS 服务器不知道该域名的 IP 地址，它会向 根 DNS服务器发起请求。\n根 DNS 服务器将指导本地 DNS 服务器转向相应的  顶级 DNS 服务器 。然后，顶级 DNS 服务器可能会进一步将请求转发给负责该 特定域名的授权 DNS服务器。最终，这个授权 DNS 服务器将返回所需域名的 IP 地址给本地 DNS 服务器，本地 DNS 服务器再将其返回给你的设备。\n这个层级结构允许 DNS 系统更高效地处理大量的域名解析请求，并确保及时更新和管理域名与 IP 地址的映射。所以，单个 DNS 服务器并不会存放所有已知域名的 IP 解析，而是通过层级结构来分散和管理这些信息。\n\n5.4 dig 工具分析 DNS 解析过程yum install bind-utils\n\n安装了之后就可以使用 dig 命令来查看域名解析过程了\ndig 域名\n\n6. 路由  路由的过程，就是下图这样一跳一跳(Hop by Hop) “问路” 的过程\n所谓 “一跳” 就是数据链路层中的一个区间。具体在以太网中，指从源 MAC 地址到目的 MAC 地址之间的帧传输区间。\n\n6.1 问路栗子（帮助理解）拿日常生活中问路来举例子（请屏蔽现在有导航这件事）一般问路，会得到三种结果：\n\n我不知道\n我知道 XXX 知道\n我不知道，但是给你乱指（在路由寻址的过程中，这个情况是不存在的）\n\n比如张三要去南京大学的仙林校区，他飞机落地南京后，不知道怎么走；他找了个机场的保安，问他“我是从 xx 省新来的大学生，应该怎么去南京大学？” 保安让他先坐 xx 路公交车去仙林大学城，到哪里再去问其他人。\n张三到了仙林大学城后，又找到了路边的环卫工，又问“我从机场过来，应该怎么去南京大学。” 环卫工给他指了条明路，那里就是南京大学的教学楼，入口就在这附近。这时候张三获取了两个人（路由器）的帮助，成功递达了南京大学的仙林校区（目标主机）。\n可以看到，问路和上面图示中 IP 报文的路由是很相似的，都是一个路由一个路由的“问路”，最终找到目标主机。\n\n6.2 路由表  报文在各个路由器之间路由也是如此。当一个路由器遇到一个 IP 报文\n\n他首先检测这是不是自己分配的局域网中的 IP，是则可以直接转发到目标主机；\n不是则查看自己的  路由表，看看自己是否保存了这个 IP 应该往哪里走；\n如果它自己不知道，则可以和其他与自己相连的路由器通信（信息同步），问他们这个 IP 应该给谁（就好比你在公司里面问某一个工作应该交给谁去做）\n如果周边的路由（旁边的路人）都不知道该往哪里去，则路由器会将其交付给自己的  默认路由，报文继续转发，去下一个人那里问路了。\n\n这样的跳跃都会有一个前提条件：相邻的两个主机（或路由器）一定是在物理上相连，处于同一局域网之中。每次的跳跃，本质上是从一个子网跳到另外一个子网；广域网可以认为是最大的“子网”\n\n6.3 route 命令\n在 windows 电脑上可以使用  route print 命令打印路由表，本文不关注 windows 平台。\n\n在 linux 平台里面，可以通过 route 命令查看当前主机的路由表，在 Centos8 主机上，命令显示如下。\n可以看到，路由表的名字叫做 内核 IP 路由表，这也是 linux 系统中的一个内核数据结构。内部维护了路由表的目的地、Gateway 网关、Genmask 掩码、Flags 标志位、Metric、Ref、Use、Iface 接口\nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         _gateway        0.0.0.0         UG    100    0        0 eth0172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-96d69eeef1ac172.19.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-fa4aff4c583e\n\n\nFlags 中，U 代表当前路由表的条目是有效的，G 代表其是一个路由器。\nGateway 中，_gateway以及 0.0.0.0 代表的都是默认网关\nIface 中，只有 eth0 是一个真正的物理网络接口，而 docker0/br-* 都是 docker 容器虚拟出来的桥接网络接口\n\n假设我我们有一个目的 IP 是 172.16.0.2，获取到这个 IP 后，系统就会将其和路由表中的子网掩码依次进行  按位与；\n在 linux 环境下，可以使用如下代码来进行这两个 IP 的按位与操作。其中 inet_addr 和 inet_ntoa 是 linux 下的两个系统调用接口。用于 IP 字符串到无符号整数之间的转换，具体的介绍可以阅读我的 UDP 博客\n#include &lt;iostream&gt;#include &lt;arpa/inet.h&gt;int main() &#123;    // 将点分十进制的 IP 地址和子网掩码转换为无符号整数    unsigned int ipAddress = inet_addr(&quot;172.16.0.2&quot;);    unsigned int subnetMask = inet_addr(&quot;255.255.0.0&quot;);    // 进行按位与操作得到网络地址    unsigned int networkAddress = ipAddress &amp; subnetMask;    // 将网络地址转换回点分十进制表示法并输出结果    struct in_addr addr;    addr.s_addr = networkAddress;    std::cout &lt;&lt; &quot;IP 地址: &quot; &lt;&lt; &quot;172.16.0.2&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot; 子网掩码: &quot; &lt;&lt; &quot;255.255.0.0&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot; 网络地址: &quot; &lt;&lt; inet_ntoa(addr) &lt;&lt; std::endl;    return 0;&#125;// 非 linux 环境可以使用下方的代码进行处理void ip_and_gmask_test() &#123;    unsigned int ipAddress = 172 &lt;&lt; 24 | 16 &lt;&lt; 16 | 0 &lt;&lt; 8 | 2; // 将 IP 地址转换为 32 位无符号整数    unsigned int subnetMask = 255 &lt;&lt; 24 | 255 &lt;&lt; 16 | 0 &lt;&lt; 8 | 0; // 将子网掩码转换为 32 位无符号整数    unsigned int networkAddress = ipAddress &amp; subnetMask; // 按位与    std::cout &lt;&lt; &quot;IP 地址:  172.16.0.2&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot; 子网掩码: 255.255.0.0&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot; 网络地址: &quot; &lt;&lt; (networkAddress &gt;&gt; 24) &lt;&lt; &quot;.&quot; &lt;&lt; ((networkAddress &gt;&gt; 16) &amp; 255) &lt;&lt; &quot;.&quot; &lt;&lt; ((networkAddress &gt;&gt; 8) &amp; 255) &lt;&lt; &quot;.&quot; &lt;&lt; (networkAddress &amp; 255) &lt;&lt; std::endl;&#125;\n\n二者输出结果都是172.16.0.0\n得到输出结果后，再和路由表中该项的 Destination 进行对比，二者相等，代表当前 IP 就是需要通过该项进行路由，那就将这个报文通过 Iface 接口 eth0 发送出去就 OK 了\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0\n\n如果按位与的结果与 Destination 匹配不上，那就继续往下一个条目的子网掩码进行按位与。如果整个表都按位与完毕了，还没找到该去的地方，那就将其通过 default 默认路由发送出去。\n7. 数据链路层  前面谈了一大堆将数据从一个主机到路由器再跨越多个路由器递达目标主机的流程。\n要想实现这一点，我们还需要数据链路层的帮助，即实现同一局域网内两台主机在物理层面上的相互通信。\n\nIP 网络层：提供跨网络找到正确路由路径，并传输数据的能力\n数据链路层：提供将数据在同一网络中传输的能力\n物理层：实际上的数据在物理（网线）上传输\n\n数据链路层也有不同的传输方式，本文主要关注当前主流的  以太网；\n需要注意的是，以太网不是一种具体的网络，而是一种技术标准。它即包含了数据链路层的内容，也包含了一些物理层的规定，比如拓扑结构和访问控制方式，传输速率等。\n\n7.1 认识局域网的基本情况 7.1.1 局域网认识 不过在认识以太网之前，我们需要先知道局域网通信的一个基本情况；假设下图中就是一个局域网，其中包含了不同的主机\n\n首先，如果想要两台主机能够通信，我们就需要先将其链接到  同一根网线  上（在这里暂且不管 WIFI，其实本质上也是连在了这根网线上）；这就好比进程间通信的时候，你需要先能看到同一份资源，才能实现对这份资源的共享访问。\n虽然我们认为在局域网里面通信的时候，是两台主机直接交流，但实际上你可以把局域网当作一个教师，当张三和李四沟通的时候，其实会有很多其他的吃瓜群众都能接收到你发送的这个信息。\n反馈到以太网报文上，因为每个主机都是知道自己的地址的，所以只要检测到以太网报头中的  目的地址  不是自己的时候，就可以丢弃掉这个报文。因为目标并不在和你说话。这就好比在教室里面，你隔壁有俩人在聊天，他们并没有和你交谈，所以你可以不用管他们聊了什么。\n\n这也反馈出了为什么某些公共 WIFI 会不安全，因为只要接入了这个 WIFI，你就有办法检测到其他用户通过这个局域网发送了什么信息！\n\n因为局域网内的主机是通过目的地址判断有没有人和自己聊天的，所以即便我们的电脑开机后什么事情都没有干，在操作系统底层（数据链路层）其实一直都在从局域网中拿到新的数据链路层报文，并检测是否是发给自己的报文：\n\n是，向上交付\n否，丢掉\n\n7.1.2 碰撞域  由于数据链路层向下是直接交付给物理层的，在物理层（网线）中光电信号传输是不能同时传输多个数据的，这就要求我们同一个局域网的多台主机不能同时往局域网中发数据。为了解决这个问题，主机引入了休眠机制，通过不同时间的错开休眠，来避免两台主机同时往局域网中发数据的情况。\n\n理想情况：同一时间只有一台主机在局域网中发送数据\n碰撞问题：如果出现了同时发送，数据出现冲突，就需要剔除掉这部分数据\n\n通过  碰撞域  解决数据冲突问题，尽量达到理想情况；\n比如我们的交换机就有  划分碰撞域  的功能。接到交换机上的设备，除了通过交换机进行路由转发，如果在交换机的这部分设备中出现了数据碰撞，那么交换机就能把碰撞控制在当前这个小的碰撞域内，而不会向更大的局域网中传播。\n\n如果一个局域网里面只有一个交换机（路由器）那么这整个局域网共享碰撞域\n\n所以大公司内为了避免局域网因为碰撞问题而导致的网络卡顿，一般都会将几台电脑接入一个小的交换机中来  划分碰撞域。\n如上是物理层面的事情，软件层面上，一个 MAC 帧 不要太大，否则会大大增加碰撞的概率。所以 MAC 帧必须要对上层交付的数据大小提一个要求，不能交付太大的数据，这就是 MTU 的由来（一般都是 1500 字节，至于为什么是 1500，那就是学术层面的事情了）\n7.1.3 链路和数据链路  链路是一条物理的链路，中间没有任何交换节点；\n数据链路是基于链路上的，需要有协议来实现数据的传输；将这些协议和硬件加入到链路上，就行程了数据链路；\n7.2 以太网帧格式\n\n这里需要知道一个小知识，虽然 MAC 地址在一定程度上可以认为是全球唯一的，但实际上只需要保证同一个局域网内的 MAC 地址是唯一的，就 OK 了\n\n目的地址 &#x2F; 源地址：48 位的 MAC 地址，MAC 是每个主机在局域网内唯一的身份标识\n帧协议类型有三种值，分别对应IP、ARP、RARP，所以只需要 2 个字节\n帧末尾是 CRC 校验码，4 个字节\n\n这三个就是以太网固定添加的报头，在进行解包的时候，我们只需要取走数据最前面的 14 个字节（6+6+2），再丢弃末尾的 4 个字节，就能取到上层的原始数据。\nhttps://blog.csdn.net/sugelantianxin/article/details/117930398\n请注意，我们说的 MTU 是 1500，其实就是 IP 可以交付的（包括 IP 报头）的长度是 1500，这个1500 是不包含以太网帧的报头的！\n以太网帧的报头是 18 字节，如上图所示。实际上能传输的数据大小是  [64 -18, 1518 - 18] = [46, 1500]\n7.3 认识 MAC 地址\nMAC 地址用来识别数据链路层中相连的节点；\nMAC 地址长度为 48 位（6 个字节）一般用十六进制加上冒号的方式来表示，例如08:00:27:03:fb:19\nMAC 地址在网卡出场的时候就确定了，不能被修改。虚拟机中的 MAC 地址并不是真实的 MAC 地址，可能会和已有的冲突（但虚拟机会检测冲突并及时修改，不然虚拟机就上不了网了）也有很少部分网卡支持用户配置 MAC 地址\n\n7.3.1 MAC 地址和 IP 协议的区别MAC 地址和 IP 地址的区别如下：\n\nIP 地址描述的是路途总体的起点和终点\nMAC 地址描述的是路途上每一个小路由区间的起点和终点\n\n因为我们的主机不可能知道一个很远的内网主机的 MAC 地址，所以就需要 MAC 地址在小路由区间来标识起点和终点，并实现正确的数据传输。\n7.4 MTU 对上层的影响 7.4.1 MTU 对 IP 的影响 在前文提到过，为了避免光电信号在物理层传输的时候出现冲突，需要限制网络层给数据链路层传输的单次的数据大小，MTU 的具体说明可以参考本文 2.2.1 认识 MTU；\n因为 MTU 的存在，网络层 IP 协议中需要对较大的数据包进行分包（IP 分片和组装问题在上文也谈过了，这里就不重复了）\n但因为 IP 协议层分片和组装对于传输层来说是不可见的，如果 IP 分片后出现丢包导致数据丢失，那么传输层就必须得重传。所以传输层为了避免这种不受自己控制的事情，最终分片的操作应该是由  传输层  来进行处理才是最好的；\n7.4.2 MTU 对 UDP 的影响 UDP 最大可以传输数据是 2^16 字节，也就是64KB，而 1500 字节是1.5KB；也就是说，只要 UDP 携带的数据超过 1472 (1500 - 20 IP 首部 - 8 UDP 首部)，那么就会在网络层被分为多个 IP 数据报。\n一旦这个数据报中有一个 IP 报文丢失了，那么整个 UDP 报文就会丢失。再加上 UDP 并没有超时重传机制（不过可以根据具体的协议来定制应答和重传机制来保证数据可靠性），UDP 的报文在 IP 层中被分片后丢包的概率远大于 TCP\n7.4.3 MTU 对 TCP 的影响\nTCP 的一个数据报也不能无限大，还是受制于 MTU\nTCP 的单个数据报的最大消息长度，称为MSS(Max Segment Size); \nTCP 在建立连接的过程中，通信双方会进行 MSS 协商。最理想的情况， MSS 的值正好是在 IP 不会被分片处理的最大长度(这个长度仍然是受制于数据链路层的 MTU)。\n双方在发送 SYN 的时候会在 TCP 头部写入自己能支持的 MSS 值。然后双方得知对方的 MSS 值之后，选择较小的作为最终 MSS，进行数据传输；\nMSS 的值在 TCP 首部的 40 字节变长选项中 (kind=2)；\n\n\n\n7.5 ARP 协议7.5.1 说明\nARP 协议属于数据链路层，是 MAC 帧协议的上层\n\n因为在局域网内的传输时，我们是用 mac 地址来作为不同主机的标识符的，所以就必须存在一个 IP 地址到 MAC 地址的转换。\nARP 协议也是包含在以太网帧格式中的，其中属于他自己的正文只有 28 个字节；因为 MTU 限制最小的数据长度是 46 字节，所以在发送 ARP 报文的时候，需要给这个 28 字节后面填补空位。\n\n先来看看 ARP 请求 &#x2F; 应答中的各个字段的含义吧\n\n硬件类型：标定底层使用的是以太网还是其他帧格式，1 为以太网\n协议类型：指要转换的地址类型，0X0800为 IP 地址\n硬件地址长度：对于以太网来说为 6 字节（这里填的是数字 6，所以只需要占用 1 个字节）；\n协议地址长度：对于 IP 地址来说为 4 字节（同上）；\nop字段为 1 表示 ARP 请求，2 表示 ARP 应答\n\n当我们的主机开始发送报文之前，我们的主机是不知道某一个 IP 对于的目标主机的 MAC 地址的。所以就需要用 ARP 协议向局域网内发送一个请求，并得到目标主机的 ARP 响应，响应中就包含了该主机的 MAC 地址\n7.5.2 ARP 请求 &#x2F; 响应的流程  主机 A 需要给主机 B 发送数据，但是不知道主机 B 的 MAC 地址，它就需要发起一个 ARP 请求：\n\n以太网目的地址填为  全 F，代表广播；源地址填自己的 MAC 地址\n帧类型填 0806 代表 ARP 协议；\nARP 中的 OP 填为 1，代表是 ARP 请求；\n发送端以太网地址和 IP 地址填为  主机 A自己的 MAC 地址和自己的 IP 地址；\n目的以太网地址填为全 F，IP 地址填为目的的 IP 地址（注意我们是知道对方 IP 地址的）；\n向下交付给以太网的 MAC 帧，然后送入局域网；\n\n这个 ARP 请求的报文就开始在局域网内进行  广播\n\n收到这个 ARP 请求的主机在 MAC 帧收到，并向上交付给自己的 ARP 层；\nARP 层先通过 OP 为 1 判断是 ARP 的请求；\n取出请求中的目的 IP 地址，判断是否为本机 IP 地址，不是则丢弃；\n是本机的 IP 地址，代表这个报文是发给自己的 ARP 请求，需要构造 ARP 响应；\n\n于是  主机 B就收到了这个 ARP 请求，并开始构造 ARP 响应\n\n以太网目的地址填为 ARP 请求中的发送端 MAC 地址，源 MAC 地址填自己的\n帧类型填 0806 代表 ARP 协议\nARP 中的 OP 填 2，代表 ARP 响应\n发送端以太网地址和 IP 地址填为  主机 B自己的 MAC 地址和自己的 IP 地址\n目的以太网地址填为 A 的 MAC 地址（在 ARP 请求中得知的）IP 地址填为目的主机 A 的 IP 地址\n向下交付给以太网的 MAC 帧，然后送入局域网\n\n此时这个 ARP 的响应就开始在局域网中传输，因为此时以太网的目的地址不再是全 F，所以各个收到这个报文的主机，就可以直接通过 MAC 地址来判断是否是发给自己的 MAC 帧。如果不是就直接丢弃，不交付给上层；\n主机 A判断目的 MAC 帧是自己的，交付给上层的 ARP 协议\n\n判断 ARP 中的 OP 为 2，代表是 ARP 响应\n因为前面已经判断过目的 MAC 地址是自己的了，所以这时候不需要判断 ARP 中的目的 MAC 和目的主机 IP 了\n直接取出发送端主机 MAC 和主机 IP，就能得到主机 B 的 IP 和 MAC 地址的映射关系\n\n这时候主机 A 就  得到了主机 B 的 MAC 地址，可以正常进行数据的发送了！\n7.5.3 ARP 缓存与更新\n任何一台主机发出的一定是 ARP 的请求；\n接收到的 ARP 可能是对方向往发送的 ARP 请求，也可能是我发送的 ARP 请求的响应；\n\n但如果每台主机都不知道 IP 和 MAC 的映射关系，岂不是每次发送数据之前，都需要来个 ARP 请求和响应来获取对方 MAC 地址？这样整个局域网内就得被 ARP 请求和响应给塞满了。\n所以，当我们发送了一个 ARP 请求后，应该需要将 ARP 响应给暂时  缓存  到本机上，避免下次发送的时候不知道对方的 MAC 地址。操作系统中就有一张 ARP 缓存表，保存了局域网内部分主机的 IP 和 MAC 地址的映射关系。\n\n如果一个主机想获取到局域网内所有的 MAC 地址，就可以写个循环，把局域网内的所有 IP 都发送一次 ARP 请求，再将收集到的 ARP 响应给缓存起来（因为局域网内的主机网络号都是相同的，主机号都是是从 1 到 254，并不多，写个循环就行了）\n\n但这里会有一个问题：如果某台主机 B 离开了你这个局域网，主机 C 接入后，路由器给主机 C 分配了原本是给主机 B 用的 IP，这时候主机 A 里面的 ARP 缓存表没有更新，还是填了主机 B 的 MAC 地址（但主机 B 其实已经不在局域网里面了），这时候这个报文岂不是找不到目标主机了？\n所以 ARP 不仅仅需要缓存，还需要保有一定的  更新机制：可以设置一个定时器，定时向缓存表中已有 IP 的主机发送一条 ARP 请求，并得到对方的 ARP 响应。这时候就可以比对返回的 MAC 地址是否有变动，有变动则更新。\n如果一个 ARP 请求长时间没有得到响应，则可以认为该 IP 地址目前没有对应的主机，将其从缓存表中删除。\n7.5.4 中间人攻击  上文讲述了 ARP 的请求和响应的格式，假设出现了下面的这个情况：\n\n主机 A 想获取主机 B 的 MAC，发送 ARP 请求并获取到了响应\n主机 D 把自己的 IP 伪装成主机 B 的 IP，又给主机 A 发送了 ARP 响应\n此时主机 A 更新了 ARP 缓存表，将主机 B 的 IP B 映射给了 MAC D\n主机 D 用同样的办法，将主机 B 的 ARP 缓存表中的 IP A 映射给了 MAC D\n此时主机 A 给 B 发送消息，填的是 MAC D；B 给 A 发消息，填的也是 MAC D；\n主机 D 在收到 A 和 B 双方通信的报文后，先交付给自己的上层，再转发给对方；\nA 和 B 的双方通信就出现了一个  中间人 D，此时如果你的信息不是加密的，那就可以被主机 D 所窃取！\n\n这也是为啥出现了 https 来避免中间人攻击！\n7.5.5  RARPRARP（Reverse Address Resolution Protocol，逆地址解析协议）是一种网络协议，用于在局域网（LAN）中通过已知的物理地址查找相应的 IP 地址。\n与前面讲述的 ARP（Address Resolution Protocol，地址解析协议）不同，ARP 用于通过已知的 IP 地址查找相应的物理地址，通常用于将网络层（IP）地址映射到链路层（MAC）地址。RARP 则执行相反的操作，它允许主机在启动时使用其物理地址来请求分配给它的 IP 地址。\nRARP 协议在过去的计算机网络中用于在没有人工配置的情况下为计算机分配 IP 地址。当计算机启动时，它会向网络发送一个 RARP 请求包，其中包含它的物理地址（MAC 地址），以请求分配一个 IP 地址。网络中的 RARP 服务器会接收这个请求并回复包含 IP 地址的 RARP 响应包。\n然而，随着时间的推移，RARP 的使用逐渐减少，主要是因为它的局限性，例如不太适用于大型网络，以及需要特定的服务器来管理地址分配。现代的网络通常使用 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）来实现类似的功能，它更灵活且易于管理，可以自动分配 IP 地址以及其他网络配置参数给主机。\n总结  数据链路层\n数据链路层的作用：两个设备 (同一种数据链路节点) 之间进行传递数据；\n以太网是一种技术标准；既包含了数据链路层的内容， 也包含了一些物理层的内容。 例如: 规定了网络拓扑结构, 访问控制方式, 传输速率等；\n以太网帧格式\n理解 mac 地址\n理解 arp 协议\n理解 MTU\n\n网络层\n网络层的作用: 在复杂的网络环境中确定一个合适的路径. \n理解 IP 地址, 理解 IP 地址和 MAC 地址的区别\n理解 IP 协议格式\n了解网段划分方法\n理解如何解决 IP 数目不足的问题, 掌握网段划分的两种方案\n理解私有 IP 和公网 IP\n理解网络层的 IP 地址路由过程\n理解一个数据包如何跨越网段到达最终目的地\n理解 IP 数据包分包的原因\n了解 NAT 设备的工作原理\n\n传输层\n传输层的作用: 负责数据能够从发送端传输接收端\n理解端口号的概念\n认识 UDP 协议, 了解 UDP 协议的特点。\n认识 TCP 协议，理解 TCP 协议的可靠性\n理解 TCP 协议的状态转化\n掌握 TCP 的连接管理，确认应答, 超时重传, 滑动窗口, 流量控制, 拥塞控制, 延迟应答, 捎带应答特性\n理解 TCP 面向字节流, 理解粘包问题和解决方案\n能够基于 UDP 实现可靠传输\n理解 MTU 对 UDP&#x2F;TCP 的影响\n\n应用层\n应用层的作用: 满足我们日常需求的网络程序, 都是在应用层\n能够根据自己的需求，设计应用层协议\n了解 HTTP 协议\n理解 DNS 的原理和工作流程\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【教程】netlify 或 vercel 完全自动部署 hexo","url":"/posts/3433631517/","content":"教你用 netlify 或 vercel 完全自动部署 hexo\n\n\n1. 完全自动？在 【教程】hexo 搭建博客 +keep 主题美化 里面，就提到过使用 netlify 或者 vercel 来部署 hexo。但是那个是部署的静态页面\n\n部署静态页面仓库，类似 github pages，需要主动hexo d 才会有更新\n直接帮你从 hexo 配置文件部署，只需要 git push 更新源文件仓库\n\n之前的博客中，提到的是第一种方式。本文中是第二种方式的教程。直接从配置文件部署，有以下几大好处\n\n任何地方，只要有网，你都可以通过修改 github 仓库中的 source/_post 里面的 md 文件，实现更新博客\n如果你更换了电脑，无须再为了 hexo 配置 node.js 等环境。这对于不写前端的我来说很棒\n\n话不多说，直接开始！\n2.github 仓库  要做到这一点，先需要准备一个存放 hexo 配置文件的仓库。本地的如下文件夹，就是 hexo 的配置文件\n\n准备配置仓库，需要保证 node_modules 和public文件夹不要上传到仓库中，否则后续部署会失败。这是我的 gitignore 文件，仅供参考\n*.deploy_git/db.json*public/.git/node_modules/\n\n最终仓库的文件层级如下，为了防止文章被过容易的盗走（因为仓库里面有 md 文件，盗文章太容易了。虽然 html 也能被爬走），我将其设置为私有仓库了\n\n有了这个仓库之后，就可以进行后续操作了\n3.netlify先新增一个 site，选择从 existing project 中 import\n\n这需要你的 netlify 账户有 github 的授权。我是直接用 github 登录的，所以已经有授权了\n\n选择 hexo 配置文件的仓库\n\nbuild 命令修改为npm run build，其余不动\n\n到这里就可以 deploy 了！就这么简单！过一会成功了之后，就会显示出你的站点链接了！\n\n需要注意的是，nelify 默认提供的二级域名，国内极有可能无法访问\n\n不用担心，你只需要在 domain settings 里面添加你自己的域名，访问速度就能起飞了\n4.vercel和 netlify 的操作很像，选择 git 仓库\n\n模板选择 hexo，其他设置都没必要动。其中 build 需要进行的命令操作，已经在我们选择 hexo 目标的时候就选择上了\n\nvercel 会开始部署\n\n如果没有报错，那就是部署成功了（否则请检查你的仓库里面 hexo 配置文件是不是少了或者多了什么）\n\n完美，也部署好了！\n\nvercel 提供的子域名也有无法访问的问题，同样的，绑定了自己的域名就能在国内访问了。\n\n对于我来说，这两个平台都很不错，但是 vercel 有个很大的“缺点”，就是干了什么都要给你邮箱发个信息，还找不到地方关闭。对于我这种强迫症来说很不友好！！！\n\n5. 遇到的问题  文章更新时间不准确？我部署之后，遇到了 vercel 和 netlify 自动部署时会将所有文章的更新时间给重置为  最新 commit 的时间  的问题。说人话就是所有博客的更新时间都变成了你最后一次提交 git 的时间\n\n这是因为其实 netlify 和 vercel 的自动部署，都是主动去 git clone 你的仓库的，此时它创建的文件夹肯定是全新的一个文件夹，所有文件的修改时间都是刚刚 clone 的时间，默认情况下 hexo 用的就是文件的修改时间来做更新时间，所以就会出现这种问题。\n\n这样肯定不是很好，违背了  更新时间  的本意，用如下博客里面的办法就能解决这个问题；\nhttps://blog.im0o.top/posts/c6d9de72.html\n我采用的是在所有 md 文件的 front-matter 里面添加 updated 字段的方式（这是 hexo 支持的更新时间字段，格式和 date 字段完全相同）\ndate: 2023-12-08 20:32:14updated: 2023-12-08 21:32:14\n\n我使用了博客中提到的 powershell 脚本 的方式来批量修改 md 文件，它会根据 git log 中的 commit 记录来获取当前 md 文件最后一次修改的时间，并写入 front-matter 的updated字段中。\n将如下内容写入一个 update.ps1 文件，然后直接用 windows 的 powershell 中 ./update.ps1 执行它就可以了\n$fileEncoding = &quot;UTF8&quot;;Function Convert-FromUnixDate ($UnixDate) &#123;    [timezone]::CurrentTimeZone.ToLocalTime(([datetime]&#x27;1/1/1970&#x27;).AddSeconds($UnixDate))&#125;$fileNum = 0;Get-ChildItem -Path &quot;./source/_posts&quot; -recurse *.md | ForEach-Object -Process&#123;    $fileNum = $fileNum + 1;    if ($_ -is [System.IO.FileInfo]) &#123;        $filePath = $_.FullName;        Write-Host(&#x27;&#123;0&#125;. &#123;1&#125;&#x27; -f $fileNum, $filePath);        $lineNum = 0; # yaml 格式占据行数        $yamlStartEndNum = 0;        $existUpdated = $false;        $updatedNum = 0;        $newstreamreader = New-Object System.IO.StreamReader($filePath);        while (($readeachline = $newstreamreader.ReadLine()) -ne $null) &#123;            $lineNum = $lineNum + 1;            $temp = $readeachline -replace &quot; &quot;,&quot;&quot; -replace &quot;\\n&quot;,&quot;&quot;            if ($temp -match &quot;---&quot;) &#123;                $yamlStartEndNum = $yamlStartEndNum + 1;            &#125;            if ($readeachline.Contains(&quot;updated:&quot;)) &#123;                $existUpdated = $true;                $updatedNum = $lineNum;            &#125;            if ($yamlStartEndNum -ge 2) &#123;                # yaml end                break;            &#125;        &#125;        $newstreamreader.Dispose();        $filedata = Get-Content -Path $filePath -Encoding $fileEncoding;        $oldYamlStr = $filedata | Select-Object -First $lineNum        # git log format: https://www.cnblogs.com/ckAng/p/11205055.html https://git-scm.com/docs/git-log        # 此文件 最后一次 commit 的 Unix 时间戳        $dateUpdated = git log -1 --format=&#x27;%ct&#x27; $filepath        $dateUpdated = Convert-FromUnixDate $dateUpdated        $dateUpdated = $dateUpdated.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;);        $newUpdated = &quot;updated: &quot; + $dateUpdated;        #Write-Host(&quot;newUpdated: &quot; + $newUpdated)        $newYamlStr = &quot;&quot;        # 注意: yamlStr 是一个数组, 每一个元素为一行字符串        $tempOldYamlStr = $oldYamlStr;        if ($existUpdated) &#123;            #Write-Host($yamlStr[$updatedNum-1])            $oldUpdated = $oldYamlStr[$updatedNum-1];            $tempOldYamlStr[$updatedNum-1] = $oldYamlStr[$updatedNum-1] -replace $oldUpdated,$newUpdated        &#125;else &#123;            # 修改 yaml 结束行            # TODO: 好像取到的这一行不包括 最后的换行符, 导致加一个 换行 反而多了, 不过为了保险, 还是加上一个换行            $tempOldYamlStr[$lineNum-1] = $newUpdated + $([System.Environment]::NewLine) + &quot;---&quot; + $([System.Environment]::NewLine)        &#125;        $newYamlStr = $tempOldYamlStr        Write-Output $newYamlStr        $newFiledata = $newYamlStr + $filedata[$lineNum..$filedata.count]        $newFiledata | Set-Content -Path $filePath -Encoding $fileEncoding    &#125;&#125;#Write-Host(&quot; 更新 updated 完成 &quot;);\n\n使用该脚本过程中，我还遇到了一个文件编码导致的问题，记录在了如下 issue 中 https://github.com/Qexo/Qexo/issues/395\n主要问题如下图所示，其实就是 md 文件编码不一致，导致出现了一些奇怪的红点。用 python 来批量修改一下文件编码格式就能解决这个问题。\n\nThe end有问题可以在评论区提出~\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【博客】折腾记录","url":"/posts/1486215141/","content":"最近几天，折腾了一下 halo 和 typecho，结果都不尽如人意，总感觉有哪里不舒服。兜兜转转，最终还是回到了现有的 hexo 解决方案上来。为了避免自己被服务器“绑架”，又把 lsky 的部署给下了，图床全部迁移到了对象存储上。\n\n\n1. 为什么放弃了 halo 和 typecho？本来，想更换到动态博客，就是为了避免自己再去部署一个图床。采用  以大包小  的想法，避免自己服务器上部署太多“我自己觉得有用的”docker 容器，白白增加自己的维护成本。\n可真正了解了这两个框架后，才知道它们距离我心中的完美还有一定差距。\n1.1 服务器  首先，最主要的原因还是因为动态博客框架都得需要一个服务器。\n当下我活力旺盛，也有点闲钱来维护自己的爱好。但根据入坑以来浏览个人博客社群得到的经验，再加上对自己的了解，我估计到某个时间段，我加入放弃大军，让自己的博客陷入不维护的黑洞。\n这时候，免费的解决方案就很有必要了。\n这也是 hexo 这类静态博客框架的最大优势之一，光是可免费部署的平台，我个人知道的就有 5 个以上，这其中还包含了不太可能会停止免费的github pages。这么多平台，足够你将 hexo 部署多个备份，哪怕最终不维护博客了，旧的博文也不至于失联。\n1.2 编辑器 typecho 和 halo1 的编辑器还算可以，但 halo2 就让人很是无语，它竟然只有一个富文本编辑器，而且还 不支持导入 MD 文件 ，复制进去的MarkDown 内容 也无法正常识别！\n这给我惊住了，作为个人博客的框架，难道不应该第一时间考虑 MD 编辑器而不是富文本吗？难道大伙自己部署博客框架，有一点不就是为了避免被某个单一平台无法转换的格式绑定吗？\n虽然 halo2 路线图中明确表明了会加上 md 编辑器，但现在没有就是没有……我几百篇文章，总不能一个个重新敲一遍吧?\n这里就要表扬 halo1 了，其自带了一个可以导入 hexo 的 md 文件并自动识别 md 文件头部的 frontmatter 里面信息的工具，还算是给迁移提供了一点方便。\n编辑器的问题暂且不谈，毕竟这是一个可以克服的困难，下面来说说更新问题；\n1.3 更新文章问题  使用 hexo 的时候，我可以将自己本地的更新 push 到 github 上，由 vercel/netlify/github-action 自动部署为 hexo 博客。\ngit 上传一次，就能够更新  多篇  本地有更改的文章。\n而使用动态博客，包括 CSDN，如果对旧的博文有修改，就必须要去博客后台的编辑器修改……而我个人对  任何  博客，准确来说是任何平台的 在线编辑器  都不报信任。一次网络波动，就可能让你几小时的心血清空。除非其能提供类似  金山文档  的自动保存多份历史版本的功能，不然看上去人畜无害的  自动保存草稿 功能，也照样会欺骗你。😭 这点就不深入展开了，体验过的人自然懂我在说什么。\n自那以后，我就把自己的所有博客从在线编辑迁移到了本地 md，并配置了自己的图床（刚开始用的阿里 OSS）。\nHEXO 能直接和本地 MD 对接，我想修改什么，只需要修改本地，push 到云端。很多人喜欢 Obsidian 的原因也是如此，本地直接保存的就是 markdown 的文档，想用什么打开就用什么打开，不会被单一软件捆绑。\n而使用动态博客，就会出现我很不喜欢的 多端同步 问题（指本地编写好的 md 文件得想各种办法在不同设备中同步）。\n而 halo 和 typecho 编辑器的不突出，会让这个问题更严重 。其让我还是想用 本地编辑器去写文章再上传 ，而这又得让我去 部署图床\n\n不在博客框架的编辑器里面写，图片还是不能上传到部署博客系统的服务器本地，不用图床就没办法访问了，我也查过 halo 的 picgo 插件，似乎早就停止更新了\n\n那这样下来，感觉和用 CSDN 没啥区别了…… 那我还部署个人博客干嘛？\n上面说的感觉不是很清晰，列个表吧。\n动态博客更新流程  理想流程如下：\n\n在动态博客后台写博客，写完即更新\n图片上传到博客服务器后台\n出现需要修改的，也是直接在后台修改\n不需要在本地额外维护 md 文件和其他图床\n\n实际由于动态博客后台编辑器体验实在是大不如本地，导致我还是想用本地编辑器写文，这就导致流程变成了下面这样\n\n在本地 typora 编辑\n图片通过 picgo 等工具上传到图床（然鹅并不能上传到博客后台）\n写完后，打开博客后台，复制粘贴更新\n\n看上去并没有特别麻烦，但这样会出现一个附加的问题：\n\n由于图片不能直接上传到博客后台，你需要额外配置一个图床\n自建图床？服务器内存 -300mb 起步；本来 1h1g 就能跑博客后台，这下被迫升级 2g 甚至 4g，钱包空空\n使用 OSS 对象存储？得提防恶意刷流。\n\n图床并不是我讨厌的问题，我讨厌的实际上是下面这种情况：\n\n假设我有一篇文章 A，该文章引用了文章 B\n由于发现 A 有误，我来修改 A（在本地修改）\n修改 A 的过程中，发现引用的 B 过时了或者也有问题，顺便修改了 B\n此时我需要更新到博客\n上博客后台，我需要 搜索 A 和 B，然后复制粘贴本地的文档来更新\n\n整个步骤一下就多起来了，麻烦的要死！\n最终可能我就会因为麻烦不想去更新某些改动不大的文章，导致我的博客上的文章落后于本地，多来几次就不知道那些文章落后了，直接进入懒人死循环。\nHEXO 博客更新  然而，如果用 HEXO，此时就只需要执行两个命令，就能立马更新博客\nhexo clhexo g --d\n\n这其中，如果没有修改博客配置文件，hexo cl都可以不用执行；\n在同时本地修改了  多篇博客  的情况下，显然是 HEXO 更方便一键更新博客；\n目前我的博客 md 文件都是存在 obsidian 的库中的。每次使用 ob 或者 typora 编写完毕后，我会用 freefilesync 软件直接将 ob 中博客文件夹（ob 中还有非博客的其他笔记）同步到 hexo 本地库的 source/_post 文件夹中去，再执行一下 git push，就能用 netlify 或者 vercel 自动化部署 hexo。\n全程最麻烦的事情就是 git push，但还是比上文中自本地更新动态博客的方式方便了许多！\n如果你不想写提交信息，还可以用 python 或者其他语言写个自动执行 git 三板斧的 exe 脚本放到 HEXO 的 git 仓库路径下，需要更新的时候点击一下就可以了。这样下来更加方便。\nThe end剩下的下次有时间再写吧……\n本文记录的仅为本人的观点，不同人使用习惯不同，并没有抨击动态博客的意思，请不要误解！欢迎在评论区提出你的建议，友善交流！\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【Hexo】在中英文之间添加空格","url":"/posts/3894841472/","content":"如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找 hexo 有没有对应的插件，还是有的\nnpm install hexo-filter-auto-spacing --save\n\n安装了之后，在 hexo 的 _config.yml 里面添加配置项\n# hexo 中英文之间自动加空格# npm install hexo-filter-auto-spacing --saveauto_spacing:  enable: true\n\n随后 hexo s 就能看到插件启用后的结果了\n\n请注意，该插件仓库 https://github.com/hexojs/hexo-filter-auto-spacing 已经被设置为公共归档，且最后一次代码提交是2022 年 6 月。\n2023 年 12 月 10 日实测该插件依旧有用，但不保证 hexo 更新后依旧有效。慕雪使用的 hexo 和主题版本如下。\nhexo 6.2.0hexo-butterfly 4.9.0\n\n暂时没有搜到其他仍在更新的插件。\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【Linux】高级 IO 和多路转接 | select/poll/epoll","url":"/posts/3390191280/","content":"多路转接和高级 IO\n\n\n咳咳，写的时候出了点问题，标点符号全乱了（批量替换了几次），干脆就把全文的逗号和句号都改成英文的了（不然代码块里面的代码都是中文标点就跑不动了）\n\nIO 多路复用和本文提到的多路转接是一个东西！\n\n1. 高级 IO1.1 五种 IO 模型  用钓鱼佬的栗子, 来看看五种不同的 IO 模型吧\n\nA, 拿着鱼竿去钓鱼, 一直盯着鱼漂, 鱼漂有动静就收钩\nB, 拿着鱼竿去钓鱼, 时不时看看鱼漂, 有动静就收购\nC, 拿着鱼竿去钓鱼, 在鱼漂上弄个铃铛, 然后干其他的事情, 听到铃铛的声音就收钩\nD, 拿了一大堆鱼竿过来, 都摆弄好, 只要有一个鱼漂有动静, 就收钩\nE 是大老板, 直接叫人帮忙钓鱼, 钓到一定数量的🐟后通知自己, 自己过来取🐟（没有参与钓鱼过程）\n\n这五种钓鱼方式, 就对应了五种 IO 模型\n\nA, 阻塞等待, 等待到数据就立即读取\nB, 轮询检测, 检测到数据的时候读取\nC, 利用铃铛来作为通知方式, 听到了信号之后, 就去读取数据（信号驱动）\nD, 一次性检测多个文件描述符（多路转接）\nE, 没有自己参与钓鱼过程, 有别人帮忙监控文件描述符, 自己只关心拿走数据（异步 IO）\n\n在这五种 IO 模式中, D 的效率是最高的。因为它一次性监控了多个文件描述符, 这些文件描述符的 IO 在一定程度上重合了, 更容易等到数据。\n要知道, D 是过来钓鱼的, 他只要能钓到鱼就够了, 并不用关心到底是哪个鱼钩钓上来的鱼。同理, 我们的 IO 服务器也并不需要关心到底是哪个文件描述符在给自己传递信息, 我们只要每时每刻都在处理信息（都能钓到鱼）才是最高效率的体现。\n换句话说, 在钓鱼（处理 IO）的时候, 等的时间比例越低, 效率越高！\n1.2 阻塞和非阻塞  这两个概念我们在先前对 IO 的学习中已经见过了\n\n阻塞：进程会在函数调用中卡住, 在没有成功调用之前不会继续向后运行\n非阻塞：不管能否获取到数据, 函数都是直接返回结果;\n\n1.3 异步与同步通信\n异步通信：在调用发出后, 这个调用直接返回, 并没有携带结果; 类似std::async/future, 在调用发出后, 被调用着通过状态或通知来告知调用者, 亦或者是用回调函数来处理这个异步调用\n同步通信：在发出调用后, 没有得到结果前, 该调用不返回; 一旦返回就表明该调用成功获取到了返回值（调用者主动等待调用结果）\n\n这里的同步和线程 &#x2F; 进程同步并不是一个概念：\n\n线程和进程的同步指的是线程和进程之间有相互制约的关系, 需要在某些情况中协调他们的工作次序而进行等待\n\n\n了解完 IO 模型和上方的知识后, 下面就让我们来认识一下第一个接口吧！\n2.fcntl这个是一个系统调用, 可以给文件描述符进行不同的策略设置。\n当我们在 linux 中创建一个文件描述符的时候, 默认创建的都是阻塞的文件描述符。我们可以使用 fcntl 来将文件描述符设置成  非阻塞  的。\n2.1 接口  该函数的原型如下\n#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* arg */ );\n\n其中 cmd 是我们需要执行的策略, 下面是常见的几种选项\n\n复制一个现有的描述符（cmd&#x3D;F_DUPFD）\n获得 &#x2F; 设置文件描述符标记(cmd&#x3D;F_GETFD 或 F_SETFD)\n获得 &#x2F; 设置文件状态标记(cmd&#x3D;F_GETFL 或 F_SETFL)\n获得 &#x2F; 设置异步 I&#x2F;O 所有权(cmd&#x3D;F_GETOWN 或 F_SETOWN)\n获得 &#x2F; 设置记录锁(cmd&#x3D;F_GETLK, F_SETLK 或 F_SETLKW)\n\n这里我们使用的是第三个功能, 来获取和设置文件的状态标记, 就可以将文件描述符设置为非阻塞（这里要注意, 不是用第二种）\n2.2 设置非阻塞  我们需要先将文件描述符原本的属性给取出来, 然后再加上非阻塞的状态, 使用 fcntl 设置属性。\nvoid SetNoBlock(int fd) &#123;     int fl = fcntl(fd, F_GETFL);  // 先获取文件已有状态    if (fl &lt; 0) &#123;        perror(&quot;fcntl error&quot;);       return;    &#125;    // 在已有状态的基础上, 设置 O_NONBLOCK 非阻塞    fcntl(fd, F_SETFL, fl | O_NONBLOCK);  &#125;\n\n2.3 stdin 测试  然后, 我们还需要一个会出现阻塞的文件描述符来作为测试。但是, 如果是直接打开一个本地文件, 并不会出现阻塞态（因为文件流会被一次性读取出来）\n不过, 在我们最常用的 3 个默认文件描述符中, 就有一个是能够实现进程阻塞的, 它就是stdin, 因为在控制台里面等待用户输入的时候, 进程就是处于阻塞状态的！\n$ ./test请输入：\n\n所以我们就可以尝试将 stdin 设置为非阻塞, 来观察一下结果\nint main()&#123;    SetNoBlock(stdin-&gt;_fileno);    char buf[1024];    while(true)    &#123;        ssize_t read_size = read(stdin-&gt;_fileno, buf, sizeof(buf) - 1);        if(read_size &lt; 0)        &#123;            perror(&quot;read err&quot;);            sleep(2);            continue;        &#125;        printf(&quot;input:%s\\n&quot;, buf);        buf[0] = &#x27;\\0&#x27;;    &#125;    return 0;&#125;\n\n编译运行, 当没有读取到输入内容的时候, 并不会在 stdin 中阻塞, 而是会通过 perror 打印出资源暂时不可用的警告信息。\n$ ./testread err: Resource temporarily unavailableasdlfjklafinput:asdlfjklafread err: Resource temporarily unavailableadslfkjaldfjklasjfainput:adslfkjaldfjklasjfaaread err: Resource temporarily unavailableewqrqreqqrwerinput:ewqrqreqqrwerasjfaaread err: Resource temporarily unavailableqweioruqoruioqewurinput:qweioruqoruioqewuraread err: Resource temporarily unavailableweqioruqoieuotqitqwertqinput:weqioruqoieuotqitqwertq����aread err: Resource temporarily unavailable^C\n\n3. 多路转接之 select接下来就要进入我们的正题了, 关于  多路转接  的知识。\n在之前的时候, 我们如果想在一个进程里面维护多个 tcp 链接, 就需要用到子线程或者子进程来单独为每一个用户提供服务。但一个进程可以开的线程是有数量限制的, 在 32 位系统中, 这个数字大概是 2000。\n对于一个高并发的服务器来说, 这点线程数是完全不够用的！如果你的网站一次性有 2000 个人访问, 你的服务器就会因为开不出更多的线程而无法为更多的用户提供服务！\n所以, 多路转接  就出现了, 他能帮我们实现单个进程监控多个文件描述符, 同时为多个 socket 链接提供服务的操作！\n\n普通的本地文件描述符也是可以托管给多路转接的！\n\n3.1 认识 selectselect 的函数原型和我们之前接触过的 linux 系统调用接口都不大相似, 它的所有参数都是输入输出型参数, 而且还用到了一个我们平时较少接触的数据结构——位图\n/* According to POSIX.1-2001, POSIX.1-2008 */#include &lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds,            fd_set *exceptfds, struct timeval *timeout);\n\n先来依次说明一下每一个参数的作用吧\n\nnfds：需要 select 帮我们监视的  最大文件描述符 +1\nreadfds/writefds/exceptfds, 需要 select 帮我们检测的读 &#x2F; 写 &#x2F; 异常文件描述符（通过  位图  来设定）\ntimeout：阻塞监控的时长, 用来设置 select 单次阻塞等待的时间\n\n3.1.1 timeval首先来看看 timeout 的这个参数的 struct timeval 结构体框架, 内部包含两个成员变量, 一个表示秒数, 一个表示微秒数。最终 select 等待的时间是这两个参数的  和\nstruct timeval &#123;    long    tv_sec;         /* seconds */    long    tv_usec;        /* microseconds */&#125;;\n\n\n如果设置成 0, 则仅检测文件描述符的状态, 不管什么情况都会立即返回（完全非阻塞）\n如果设置成指定的时间, 则会阻塞等待这端时间, 如果有文件事件则返回; 如果没有等到文件时间, 那么时间到了就会返回\n如果将 timeout 参数设置成 nullptr, 则会 阻塞等待\n\n这个参数也是一个输入输出型参数, 返回值为剩余的秒数（如果等待成功的话）\n3.1.2 fd_set函数中有 3 个参数都是用到了这个 fd_set 结构, 它是一个位图结构, 同时也是一个输入输出参数\n\n输入：用户告诉操作系统, 需要帮我监控那几个文件描述符, 在需要监控的文件描述符上置 1\n输出：系统告诉用户, 那些文件描述符的相关事件就绪了\n\n虽然这是一个位图结构, 但其并不需要我们手动去设置, 操作系统顺便帮我们封装了相关的设置“函数”, 只需要传入 fd 和该结构体即可\nvoid FD_CLR(int fd, fd_set *set);  // 清空位图中对该文件描述符的设置int  FD_ISSET(int fd, fd_set *set);// 判断是否被设置了void FD_SET(int fd, fd_set *set);  // 设置对应位置的文件描述符void FD_ZERO(fd_set *set);         // 清空整个位图\n\n你可能回觉得奇怪, 为什么这些“函数”是大写的呢？Linux 中大写的应该是宏才对吧？\n答对了！这里的设置函数其实都是宏定义！\n/* Access macros for `fd_set&#x27;.  */#define\tFD_SET(fd, fdsetp)\t__FD_SET (fd, fdsetp)#define\tFD_CLR(fd, fdsetp)\t__FD_CLR (fd, fdsetp)#define\tFD_ISSET(fd, fdsetp)\t__FD_ISSET (fd, fdsetp)#define\tFD_ZERO(fdsetp)\t\t__FD_ZERO (fdsetp)\n\n既然是一个预定义好的位图, 那么它的长度就会收到操作系统底层的一定限制, 以下为源代码中 fd_set 结构体的定义\n// 路径 usr/include/sys/select.h/* The fd_set member is required to be an array of longs.  */typedef long int __fd_mask;/* Some versions of &lt;linux/posix_types.h&gt; define this macros.  */#undef\t__NFDBITS/* It&#x27;s easier to assume 8-bit bytes than to get CHAR_BIT.  */#define __NFDBITS\t(8 * (int) sizeof (__fd_mask))#define\t__FD_ELT(d)\t((d) / __NFDBITS)#define\t__FD_MASK(d)\t((__fd_mask) (1UL &lt;&lt; ((d) % __NFDBITS)))/* fd_set for select and pselect.  */typedef struct  &#123;    /* XPG4.2 requires this member name.  Otherwise avoid the name       from the global namespace.  */#ifdef __USE_XOPEN    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];# define __FDS_BITS(set) ((set)-&gt;fds_bits)#else    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];# define __FDS_BITS(set) ((set)-&gt;__fds_bits)#endif  &#125; fd_set;\n\n在另外一个头文件中, 可以找到 __FD_SETSIZE 这个宏的定义, 是 1024; 也就是说, fd_set这个位图最大的长度只有 1024 个比特位, 我们也只能监看这么多文件描述符！\n// 路径 usr/include/bits/typesizes.h/* Number of descriptors that can fit in an `fd_set&#x27;.  */#define __FD_SETSIZE\t\t1024\n\n这也是 select 的缺点之一, 同时监看的文件描述符数量是  有限制  的！\n3.1.3 nfds这个参数是 select 需要帮我们监看的最大文件描述符 +1, 这是因为 select 在监看的过程中需要用循环来进行检测, 这个最大文件描述符 +1 相当于是一个循环的边界条件;\n你只需根据当前已有的文件描述符号, 计算出最大文件描述符, 再加一传给这个函数即可。\n3.1.4 返回值man 手册中对返回值的描述如下\n\n成功的时候, 返回事件就绪的文件描述符数量\n失败的时候返回-1, 并设置 errno\n如果已经 timeout 了还没有事件就绪, 返回 0\n\nRETURN VALUE       On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor  sets  (that  is,  the total  number  of  bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens.  On error, -1 is returned, and errno is set to indicate the error; the file descriptor sets are unmodified, and  timeout becomes undefined.\n\n3.2 实例  函数原型看完了, 得从实例出发来试试了\n3.2.1 socket这里先对 socket 做了一个简单的封装, 包括初始化, 绑定相关的接口, 只需要在另外一个文件里面调用这个头文件即可 !\n//Sock.hpp#pragma once#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/stat.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;pthread.h&gt;#include &lt;cerrno&gt;#include &lt;cassert&gt;class Sock&#123;public:    static const int gbacklog = 20;    static int SocketInit()    &#123;        int listenSock = socket(PF_INET, SOCK_STREAM, 0);        if (listenSock &lt; 0)        &#123;            exit(1);        &#125;        // 设置端口复用, 避免 timewait 阻塞端口        int opt = 1;        setsockopt(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, sizeof(opt));        return listenSock;    &#125;    static void Bind(int socket, uint16_t port)    &#123;        struct sockaddr_in local; // 用户栈        memset(&amp;local, 0, sizeof local);        local.sin_family = PF_INET;        local.sin_port = htons(port);        local.sin_addr.s_addr = INADDR_ANY;        // 2.2 本地 socket 信息, 写入 sock_对应的内核区域        if (bind(socket, (const struct sockaddr *)&amp;local, sizeof(local)) &lt; 0)        &#123;            exit(2);        &#125;    &#125;    static void Listen(int socket)    &#123;        if (listen(socket, gbacklog) &lt; 0)        &#123;            exit(3);        &#125;    &#125;    static int Accept(int socket, std::string *clientip, uint16_t *clientport)    &#123;        struct sockaddr_in peer;        socklen_t len = sizeof(peer);        int serviceSock = accept(socket, (struct sockaddr *)&amp;peer, &amp;len);        if (serviceSock &lt; 0)        &#123;            // 获取链接失败            return -1;        &#125;        if(clientport) *clientport = ntohs(peer.sin_port);        if(clientip) *clientip = inet_ntoa(peer.sin_addr);        return serviceSock;    &#125;&#125;;\n\n另外重点说明一下这两行, 在之前学习 tcp 服务器的时候就提到过, 这里的 SO_REUSEADDR 是让端口可以被复用, 不会因为存在 TIME_WAIT 的链接而无法绑定端口。适用于服务器快速重启的情况。\n// 设置端口复用, 避免 timewait 阻塞端口int opt = 1;setsockopt(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, sizeof(opt));\n\n3.2.2 初始化  还是老一套, 通过命令行参数获取到端口号, 创建 socket_fd 并绑定端口和开始listen\nint main(int argc, char *argv[])&#123;    if (argc != 2) &#123;        cmd_usage(argv[0]);        exit(1);    &#125;       // 初始化 socket, 获取 socket fd 并绑定端口    int listensock = Sock::SocketInit();    Sock::Bind(listensock, atoi(argv[1]));    Sock::Listen(listensock); // 开始监听&#125;\n\n需要注意的是, 在 select 中的文件描述符都只剩位图了, 所以我们必须要有一个单独的文件描述符数组来协助我们管理正在维护的文件描述符。\n这里为了方便, 我设立了一个全局的数组变量, 长度为 sizeof(fd_set) * 8, 是fd_set 这个位图结构体能够支持的最大 socket 数量\nint fdsArray[sizeof(fd_set) * 8] = &#123;0&#125;; // 保存历史上所有的合法 fdint fdsArraySz = sizeof(fdsArray) / sizeof(fdsArray[0]);#define DFL_FD -1 // 数组中默认值\n\n在 main 函数中, 我们需要通过遍历来将这个数组设置为默认的文件描述符 -1 来表明当前位置没有被使用, 并将 0 下标处设置为listensock; 如果你使用的是 vector, 则可以直接用构造函数来初始化;\n// 将数组里面的文件描述符都初始化为默认值, 并将第一个下标设置为 listensocketfor (int i = 0; i &lt; fdsArraySz; i++)&#123;    fdsArray[i] = DFL_FD;&#125;fdsArray[0] = listensock;\n\n3.2.3 监听  初始化完毕数组后, 就可以开始循环调用 select 来进行监听了。\n需要注意的是, 因为 select 的fd_set是一个位图, 而且是输入输出参数。每次的 select 调用之后, 这些位图就会被操作系统修改为已经就绪的文件描述符（即参数本身会被修改）所以我们下一次调用之前, 需要重新设置位图参数！\n// 开始监听fd_set readfds;while(true)&#123;    int maxFd = DFL_FD;    FD_ZERO(&amp;readfds); // 清空位图    struct timeval timeout = &#123;5, 0&#125;; // 设置超时时间为 5 秒    // 遍历全局数组, 将有效的 fd 都添加进去, 并更新 maxfd    for (int i = 0; i &lt; fdsArraySz; i++)    &#123;           // 1. 过滤不合法的 fd        if (fdsArray[i] == DFL_FD) continue;           // 2. 添加所有的合法的 fd 到 readfds 中, 方便 select 统一进行就绪监听        FD_SET(fdsArray[i], &amp;readfds);         if (maxFd &lt; fdsArray[i]) &#123;            maxFd = fdsArray[i]; // 3. 更新出 fd 最大值        &#125;    &#125;    // 调用 select 开始监听    int sret = select(maxFd+1, &amp;readfds, nullptr, nullptr, &amp;timeout);    switch (sret)    &#123;    case 0: // 等待超时        cout &lt;&lt; &quot;time out ... : &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; endl;        break;    case -1:// 等待失败        cerr &lt;&lt; errno &lt;&lt; &quot; : &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        break;    default:        // 等待成功        cout &lt;&lt; &quot;wait success: &quot; &lt;&lt; sret &lt;&lt; endl;        break;    &#125;&#125;\n\n基本框架搭起来了, 我们这时候就只需要实现等待成功后取出链接和 IO 信息的操作了;\n先来测试一下当前的手脚架吧\n3.2.4 手脚架测试  编译启动, 使用命令行参数来绑定端口, 在没有收到数据之前, 进程会在 select 中阻塞等待 5 秒, 随后因为超时跳出阻塞态, 返回 0 并打印当前时间戳\n$ g++ main.cpp -o test$ ./test 10000time out ... : 1692955522time out ... : 1692955527time out ... : 1692955532time out ... : 1692955537time out ... : 1692955542\n\n使用 telnet 命令来链接当前服务, select检测到 listensock 文件描述符就绪, 会立刻返回（对于 listensock 来说, 来了新链接就是读 IO 就绪）但因为我们没有写取走新 socket 的代码, 所以这里会一直打印事件就绪;\n返回值为 1, 代表有一个文件描述符的事件就绪。\n\n3.2.5 处理新连接  在select事件就绪后, 使用如下函数来处理新的链接\nstatic void HandlerEvent(int listensock, fd_set &amp;readfds);\n\n这里额外写了一个打印数组中元素的函数, 方便我们观察结果。\n/// @brief 打印数组中的文件描述符static void ShowArray(int arr[], int num)&#123;    cout &lt;&lt; &quot; 当前合法 sock list: &quot;;    for (int i = 0; i &lt; num; i++)    &#123;        if (arr[i] == DFL_FD )            continue;        else            cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n首先我们需要遍历整个链接数组, 并判断当前位置是否是有效的文件描述符。无效直接跳过。\nfor (int i = 0; i &lt; fdsArraySz; i++)&#123;    if (fdsArray[i] == DFL_FD)        continue;    // 处理新连接和已有链接&#125;\n\n遍历的时候, 我们需要对 listensock 做单独的处理, 毕竟获取新连接和维护已有链接的流程是完全不同的。下面说说流程\n\n判断是否有在 select 中监听该文件描述符\n有监听, 继续往后执行, 开始进行 accept 获取新的链接\n获取失败, 直接跳出该函数, 结束该轮处理\n获取成功, 不能直接 read&#x2F;write, 而是应该通过数组交付给 select 帮我们监听事件\n下一轮循环中, select 便会帮我们监听该新链接的事件是否就绪\n\n因为走到这里的时候, 我们的 listensocket 里面是一定有新连接的, 所以对 accept 的调用是不会阻塞线程的！\nif (i == 0 &amp;&amp; fdsArray[i] == listensock)&#123;    // 判断 listensocket 有没有事件监听    if (!FD_ISSET(listensock, &amp;readfds))&#123;        cerr &lt;&lt; &quot;listensocket not set in readfds&quot; &lt;&lt; endl;        continue;    &#125;    // 具有了一个新链接    cout &lt;&lt; &quot;get new connection&quot; &lt;&lt; endl;    string clientip;    uint16_t clientport = 0;    int sock = Sock::Accept(listensock, &amp;clientip, &amp;clientport); // 不会阻塞    if (sock &lt; 0)        return; // 出错了, 直接返回    // 成功获取新连接    cout &lt;&lt; &quot;new conn:&quot; &lt;&lt; clientip &lt;&lt; &quot;:&quot; &lt;&lt; clientport &lt;&lt; &quot; | sock: &quot; &lt;&lt; sock &lt;&lt; endl;    // 这里我们不能直接对这个 socket 进行独写, 因为新链接来了并不代表新数据一并过来了    // 所以需要将新的文件描述符利用全局数组, 交付给 select    // select 帮我们监看 socket 上的读事件是否就绪    int i = 0;    for (i = 0; i &lt; fdsArraySz; i++)    &#123;        if (fdsArray[i] == DFL_FD)            break;    &#125;    // 达到上限了    if (i == fdsArraySz)    &#123;        cerr &lt;&lt; &quot;reach the maximum number of connections&quot; &lt;&lt; endl;        close(sock);    &#125;    else // 没有达到    &#123;        fdsArray[i] = sock; // 新的链接, 插入到数组中, 下次遍历就会添加到 select 监看中        ShowArray(fdsArray, fdsArraySz);    &#125;&#125;\n\n3.2.6 处理已有链接  这里暂时只做了对读的操作, 当读事件就绪的时候, 我们通过 read 读取已有的数据。这里因为 socket 中肯定是有数据的, 所以也不会出现阻塞的情况。\n// end if (i == 0 &amp;&amp; fdsArray[i] == listensock)else&#123;    // 处理普通 sock 的 IO 事件    if (FD_ISSET(fdsArray[i], &amp;readfds))    &#123;        // read、recv 读取即可        char buffer[1024];        ssize_t s = recv(fdsArray[i], buffer, sizeof(buffer), 0); // 不会阻塞        if (s &gt; 0)        &#123;            buffer[s] = 0;            cout &lt;&lt; &quot;client[&quot; &lt;&lt; fdsArray[i] &lt;&lt; &quot;]# &quot; &lt;&lt; buffer &lt;&lt; endl;        &#125;        else if (s == 0) // 对端关闭        &#123;            cout &lt;&lt; &quot;client[&quot; &lt;&lt; fdsArray[i] &lt;&lt; &quot;] quit, server close &quot; &lt;&lt; fdsArray[i] &lt;&lt; endl;            close(fdsArray[i]);            fdsArray[i] = DFL_FD; // 去除对该文件描述符的 select 事件监听            ShowArray(fdsArray, fdsArraySz);        &#125;        else // 异常了        &#123;            cout &lt;&lt; &quot;client[&quot; &lt;&lt; fdsArray[i] &lt;&lt; &quot;] error, server close &quot; &lt;&lt; fdsArray[i] &lt;&lt; endl;            close(fdsArray[i]);            fdsArray[i] = DFL_FD; // 去除对该文件描述符的 select 事件监听            ShowArray(fdsArray, fdsArraySz);        &#125;    &#125;&#125;\n\n这里我单次读取的时候, 最多只能读出 1024 字节的数据; 如果想一次性读取完毕, 则需要使用循环 + 设置非阻塞来进行读取。后续在 epoll 的代码示例中会展示这种写法。\n3.2.7 实测  到这里, 我们这套代码就基本完成了, 可以来测试一下能否实现单线程监听多个链接;\n在本地使用 telnet+ 多个终端进行测试, 可以看到我们成功实现了同时监听两个链接, 并接受这两个链接给自己发送的信息的功能。当 telnet 退出的时候, 也能成功回收文件描述符。\n\nselect 的小实现暂时先看到这里, 如果想用 select 实现同时读 + 写, 其实是很复杂的。需要一套完整的逻辑。这就留着到最后 epoll 的时候再统一展现吧！\n3.3 socket 就绪条件socket 不同事件的就绪有各自的条件\n3.3.1 读就绪\nsocket 内核中, 接收缓冲区中的字节数, 大于等于低水位标记SO_RCVLOWAT, 此时可以无阻塞的读该文件描述符, 并且返回值大于 0; \nsocket 在 TCP 通信中, 对端关闭连接, 此时对该 socket 读, 则返回 0;\n监听的 socket 上有新的连接请求;\nsocket 上有未处理的错误;\n\n3.3.2 写就绪\nsocket 内核中,  发送缓冲区中的可用字节数(发送缓冲区的空闲位置大小),  大于等于低水位标记 SO_SNDLOWAT,  此时可以无阻塞的写,  并且返回值大于 0;\nsocket 的写操作被关闭(close 或者 shutdown). 对一个写操作被关闭的 socket 进行写操作,  会触发 SIGPIPE 信号;\nsocket 使用非阻塞 connect 连接成功或失败之后;\nsocket 上有未读取的错误;\n\n3.3.3 异常就绪socket 上收到带外数据（TCP 报头中的 URG 和紧急指针）\n3.4 select 的特点\n可监控的文件描述符有上限, 取决于 fd_set 位图结构体的配置\n在监控文件描述符的时候, 需要用户额外的数组来维护文件描述符\n每次循环都得遍历整个数组, 效率较低（可以优化为保证有效文件描述符都在数组的前方）\n\n一下是它在效率上的一些缺点\n\n每次调用 select 都得手动设置一边 fd 集和（因为 fd_set 也是输出型参数, 在内核中会被修改）\n每次调用 select, 都需要把所有 fd 从用户态拷贝到内核态, 小陆地\n每次调用, 内核都须遍历传递进来的位图, 效率低\n监控的文件描述符有上限, 数量小\n\n4. 多路转接之 poll4.1 函数原型  接下来我们要了解的是另外一个多路转接方案, poll\n#include &lt;poll.h&gt;int poll(struct pollfd *fds,  nfds_t nfds,  int timeout);\n\n4.1.1 参数  这里的参数就和 select 完全不同了, 出现了另外一个结构体\nstruct pollfd &#123;    int   fd;         /* file descriptor */    short events;     /* requested events */    short revents;    /* returned events */&#125;;\n\n这一个结构体分别包含了三个成员\n\n文件描述符 fd;\n用户告诉内核需要监看的事件 events;\n内核返回的就绪事件 revents;\n\n但是从这个函数的参数上看来, 貌似它是一个只有一个元素的输入输出型参数, 难道说 poll 只能监看一个文件描述符吗？🧐\n非也, 我们将函数原型改一下就能看明白了, 实际上, 第一个参数是一个  结构体数组 , 第二个参数是该结构体数组的 长度！\nint poll(struct pollfd fds[],  nfds_t nfds,  int timeout);\n\n第三个参数和 select 中的 timeout 的功能相同, 如果到达一定时间还没有获取到参数, 则直接返回; 如果设置为 -1 则阻塞等待, 设置为 0 为完全非阻塞。\n这里的 timeout 并非输入输出型号参数, 其只是一个输入参数, 单位为  毫秒（记住, 不是秒, 是毫秒）\n4.1.2 返回值\n小于 0, 出错\n等于 0, 等待超时\n大于 0, 文件描述符已经就绪的数量\n\n4.1.3 事件  这里需要了解一下 poll 包含的事件类型了, 我们需要根据不同情况来选择想要的事件, 并设置到结构体的 event 中; 对于 select&#x2F;poll&#x2F;epoll 来说, 这些 socket 的就绪条件都是相同的。详见 3.3 socket 就绪条件;\n\n4.2 poll 优缺点 4.2.1 优点 在 poll 中, 使用的是一个结构体数组来表示需要监听的文件描述符, 以及事件就绪的文件描述符\n\n因为结构体中用户需要监听的 event 和内核返回的就绪 event 并不在一个变量上, 所以只需要设置一次即可（如果需求没有变动的话）, 无需像 select 每次都得重新遍历来设置位图\npoll 没有最大文件描述符限制\npoll 无需用户额外维护一个单独的文件描述符数组, 直接沿用该结构体数组即可\n\n4.2.2 缺点\n和 select 一样, poll 也需要轮询检测就绪的 fd 和相关事件\n每次调用 poll 需要把 pollfd 结构体从用户态拷贝到内核态\n虽然 poll 没有最大文件描述符限制, 但是监看的多了后性能会线性下降\n\n4.3 看看示例代码poll 的代码部分的主机结构和 select 基本相同，这里我们主要来说一下不同的地方\n#define NUM 1024#define DFL_FD -1struct pollfd fdsArray[NUM];\n\n首先是全局的数组，这时候不需要自己维护一个 int 文件描述符数组了，直接使用这个结构体作为全局数组就 OK 了；在 main 函数里面还是老样子，我们得把整个数组的 fd 都设置成默认的 fd 作为标识\nfor (int i = 0; i &lt; NUM; i++)&#123;    fdsArray[i].fd = DFL_FD;    fdsArray[i].events = 0;    fdsArray[i].revents = 0;&#125;fdsArray[0].fd = listensock;fdsArray[0].events = POLLIN;\n\n在 main 函数的主循环中，也是用 poll 来依次监听事件，并判断 poll 函数的返回值\nint timeout = 5;while (true)&#123;    int n = poll(fdsArray, NUM, timeout);    switch (n)    &#123;        case 0:            cout &lt;&lt; &quot;time out ... : &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; endl;            break;        case -1:            cerr &lt;&lt; errno &lt;&lt; &quot; : &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;            break;        default:            HandlerEvent(listensock);            break;    &#125;&#125;\n\n在 HandlerEvent 函数中，我们通过判断结构体内部的 revent 来得知是否有事件就绪\nif (fdsArray[i].revents &amp; POLLIN)&#123;&#125; // 读事件是否就绪\n\n对于 listensocket 来说，就绪了就执行 accept；并将新的文件描述符添加到数组中\nint j = 0;for (j = 0; j &lt; NUM; j++)&#123;    if (fdsArray[j].fd == DFL_FD)        break;&#125;// 通过 for 循环找到当前位置是默认的结构体下标if (j == NUM) // 如果达到上限才 break&#123;    cerr &lt;&lt; &quot; 我的服务器已经到了最大的上限了，无法在承载更多同时保持的连接了 &quot; &lt;&lt; endl;    close(sock);&#125;else&#123;    fdsArray[j].fd = sock; // 将 sock 添加到数组中    fdsArray[j].events = POLLIN;    fdsArray[j].revents = 0;    ShowArray(fdsArray, NUM);&#125;\n\n对于其他链接来说，就绪了就开始 read。如果 read 异常或者对端关闭，那就将对应位置的结构体全部初始化（清空），相当于将这个链接从监听中去掉！\nfdsArray[i].fd = DFL_FD; fdsArray[i].events = 0;fdsArray[i].revents = 0;\n\n其余的操作和 select 完全一致，在这里就不展示代码了！\n5.epollman 手册中提到, epoll 是为了处理大量 socket 文件描述符句柄而进行了一定改进的 poll;\n5.1 接口epoll 就不是只有一个函数接口了, 而是有 3 个相关的函数，使用过程就是三部曲：\n\nepoll_create 创建 epoll 文件句柄\nepoll_ctl 将需要监控的文件描述符进行注册\nepoll_wait 等待文件描述符就绪\n\n5.1.1 epoll_create#include &lt;sys/epoll.h&gt;int epoll_create(int size);int epoll_create1(int flags);\n\nepoll 在使用的时候, 我们需要用 create 函数创建一个 epoll 的句柄（本质上也是文件描述符）, 来管理当前进程需要操作系统帮我们监看的文件描述符\n\n自从linux 2.6.8 后, 这里的 size 参数是被忽略的\nepoll 的句柄在使用完毕后也需要用 close() 函数关闭\n错误的时候返回 -1 并设置 errno, 正确的时候返回文件描述符\n\n5.1.2 epoll_ctl该函数是对 epoll 中需要监看的文件描述符进行设置\n#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd,  int op,  int fd,  struct epoll_event *event);\n\n\n第一个参数是 epoll_create 的返回值\n第二个参数是动作, 包含三个不同的选项\nEPOLL_CTL_ADD：将新的文件描述符添加到 epfd 中\nEPOLL_CTL_MOD：修改已有文件描述符的监听事件\nEPOLL_CTL_DEL：删除已有文件描述符\n\n\n第三个参数是目标文件描述符\n第四个参数是一个 epoll_event 结构体\n\n这个结构体的定义如下\ntypedef union epoll_data &#123;    void        *ptr;    int          fd;    uint32_t     u32;    uint64_t     u64;&#125; epoll_data_t;struct epoll_event &#123;    uint32_t     events;      /* Epoll events */    epoll_data_t data;        /* User data variable */&#125;;\n\n事件  事件 events 可以是下面的这些选项\n\n\n\n事件\n说明\n\n\n\nEPOLLIN\n表示对应的文件描述符可以读 (包括对端 SOCKET 正常关闭);\n\n\nEPOLLOUT\n表示对应的文件描述符可以写;\n\n\nEPOLLPRI\n表示对应的文件描述符有紧急的数据可读 (这里应该表示有带外数据到来);\n\n\nEPOLLERR\n表示对应的文件描述符发生错误;\n\n\nEPOLLHUP\n表示对应的文件描述符被挂断;\n\n\nEPOLLET\n将 EPOLL 设为  边缘触发 (Edge Triggered)模式,  这是相对于  水平触发(Level Triggered) 来说的；\n\n\nEPOLLONESHOT\n只监听一次事件,  当监听完这次事件之后,  如果还需要继续监听这个 socket 的话,  需要手动再次把这个 socket 加入到 EPOLL 队列里；\n\n\n5.1.3 epoll_wait#include &lt;sys/epoll.h&gt;int epoll_wait(int epfd,  struct epoll_event *events,                int maxevents,  int timeout);int epoll_pwait(int epfd,  struct epoll_event *events,                 int maxevents,  int timeout,                 const sigset_t *sigmask);\n\n改函数的作用是收集在 epoll 监控的事件中，已经就绪的事件\n\n第一个参数是 epoll 的文件描述符句柄\n参数 events 是 epoll_events 结构体数组，是一个输出型参数。epoll 会将就绪的事件赋值到 events 数组里面；\nmaxevents 告诉内核这个 events 的大小，其不可以超过 epoll_create 的 size；\n参数 timeout 是超时时间，也是毫秒（0 非阻塞，-1 永久阻塞）\n返回值：成功返回 IO 事件就绪的文件描述符数目，0 代表超时，负数代表失败\n\n5.2 工作原理 5.2.1 从源码看流程 我们知道，select 通过位图来告诉操作系统需要管理的文件描述符，poll 通过结构体数组来告诉操作系统需要管理的文件描述符。\n但 epoll 里面，却变成了一个 epfd 文件句柄，我们只是给这个特定的句柄交付文件描述符。这说明底层肯定需要其他的数据结构，来管理某个进程的某个 epfd 交付给操作系统的文件描述符，以及需要监看的事件！\n在 Linux 2.6.32.16 源码 fs/eventpoll.c 中，可以找到如下这个结构体\n// linux 源码文件路径：fs/eventpoll.c/* * This structure is stored inside the &quot;private_data&quot; member of the file * structure and rapresent the main data sructure for the eventpoll * interface. */struct eventpoll &#123;\t/* Protect the this structure access */\tspinlock_t lock;\t/*\t * This mutex is used to ensure that files are not removed\t * while epoll is using them. This is held during the event\t * collection loop, the file cleanup path, the epoll file exit\t * code and the ctl operations.\t */\tstruct mutex mtx;\t/* Wait queue used by sys_epoll_wait() */\twait_queue_head_t wq;\t/* Wait queue used by file-&gt;poll() */\twait_queue_head_t poll_wait;\t/* List of ready file descriptors */\tstruct list_head rdllist;\t/* RB tree root used to store monitored fd structs */\tstruct rb_root rbr;\t/*\t * This is a single linked list that chains all the &quot;struct epitem&quot; that\t * happened while transfering ready events to userspace w/out\t * holding -&gt;lock.\t */\tstruct epitem *ovflist;\t/* The user that created the eventpoll descriptor */\tstruct user_struct *user;&#125;;\n\n在这里面，我们既可以看到熟悉的 mutex 锁，又可以看到一个 wait_queue 等待队列，一个双链表，和一个 rb_root 红黑树节点。\nstruct list_head &#123;\tstruct list_head *next, *prev;&#125;; // 内核中的双链表\n\n抽象出来之后，其大概的结构图如下\n\n当某一个进程调用 epoll_create 创建 epoll 的文件描述符句柄的时候，操作系统就会帮我们在底层创建一个 struct eventpoll 结构体，内部包含了就绪队列和一个红黑树（主要关注这两个成员）\n\n调用 epoll_ctl 的时候，操作系统就会将我们配置的文件描述符和对于的事件添加到红黑树节点中；\n重复添加的事件也可以通过红黑树的键值唯一性检查出来（避免冗余）\n所有添加到 epoll 中的事件都会与设备的  网卡驱动程序  建立回调消息，当某个文件描述符对应的链接有信息传来的时候，就会调用  回调函数，告知 epoll\n网卡收到消息\n驱动程序处理，并调用对应的回调机制\nepoll 通过回调消息收到事件就绪，将其链入 rdllist 双链表中\n上层只需要调回 epoll_wait 从该双链表中获取就绪事件\n\n\n该回调办法在底层为 ep_poll_callback，它会将就绪的事件插入到rdllist 双链表中\nepoll 中每一个事件都会建立一个对应的 epitem 结构体\n当调用 epoll_wait 有事件发生的时候，只需要检查 eventpoll 对象的 rdllist 双链表中是否有 epitem 元素即可，有则取出；\n如果 rdllist 不为空，则将发生的事件复制到用户态，并将事件数量返回给用户；对比需要遍历的 select/poll，这个获取就绪事件的 时间复杂度  是O(1)的（直接判断并取出就可以了）\n\n这一大圈操作都是操作系统自行完成的，对于用户来说是无感知的！\n关于 epitem 结构体，可以瞅一眼下面的注释，他也是在源码的 fs/eventpoll.c 文件中\nstruct epitem &#123;\t/* RB tree node used to link this structure to the eventpoll RB tree */\tstruct rb_node rbn; // 这个事件对应的红黑树节点\t/* List header used to link this structure to the eventpoll ready list */\tstruct list_head rdllink; // 这个事件对应的双链表节点\t/*\t * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the\t * single linked chain of items.\t */\tstruct epitem *next; \t/* The file descriptor information this item refers to */\tstruct epoll_filefd ffd; // 事件句柄信息\t/* Number of active wait queue attached to poll operations */\tint nwait; \t/* List containing poll wait queues */\tstruct list_head pwqlist;\t/* The &quot;container&quot; of this item */\tstruct eventpoll *ep; // 指向其所属的 epollevent 对象\t/* List header used to link this item to the &quot;struct file&quot; items list */\tstruct list_head fllink;\t/* The structure that describe the interested events and the source fd */\tstruct epoll_event event; // 该 fd 关注的事件&#125;;\n\n5.2.2 PSH 标记位  在学习 TCP 的时候，我们了解过 PSH 这个标记位，它的作用是告诉对端的应用层，尽快取走缓冲区中的数据。\n对于 epoll 而言，这个 PSH 的作用就是让 epoll 在 rdllist 里面新建一个就绪节点，这样上层就能知道这个文件描述符的事件就绪了（至于读不读取依旧是上层的问题）\n\n你可能会问，既然对方都发消息来催你取数据了，那不应该你的数据并没有被取走吗？这时候该文件描述符的就绪节点不应该已经存在了吗？为什么还需要额外创建一个就绪事件的节点来通知用户呢？\n\n这就涉及到 epoll 的两种工作策略 LT&#x2F;ET 了，后文会讲解；\n\n需要注意的是，epoll 并没有对 URG 进行特殊处理，而是视之为正常的可读事件连入就绪队列，但是事件类型有所不同，可以用 EPOLLPRI 来关注紧急事件\n（存疑，但是没有找到相关资料，暂且这么认为）\n\n5.2.3 epoll 优点  一下是 epoll 相比 poll 和 select 的优点\n\n接口使用方便，虽然拆分了 3 个函数，但是每个函数的功能非常明确；不需要每次使用都重新设置文件描述符，也实现了输入和输出参数的分离\n数据拷贝轻量：在需要的时候调用 epoll_ctl 来处理文件描述符和事件，并不会每次调用都得大批量在用户和内核态之间拷贝数据（poll 和 select 都需要）\n事件回调机制：使用事件回调来替代遍历，回调函数将就绪的文件描述符结构加入到就绪队列中；epoll_wait直接使用就绪队列，就能知道那些文件描述符就绪；即便文件描述符较多的时候，也能快速知道就绪的文件描述符（省去了遍历的时间消耗）\n无上限：文件描述符没有数量限制\n线程安全：在 eventpoll 结构体里面，我们可以看到有一个 mutex 锁，在 linux 底层已经帮我维护了 epoll 相关操作的线程安全性！\n\n在有些博客里面说 epoll 使用了  内存映射机制 ，这种说法是 错误  的！因为 epoll_event 结构体是在用户态创建的，我们势必还是需要进行一定的用户态到内核态的拷贝。\n\n内存映射机制：linux 内核直接将就绪队列通过 mmap 的方式映射到用户态，避免拷贝消耗（你可以理解为用户态和内核态之间的共享内存）\n\n5.3 工作模式  在 epoll 的工作模式中，我们可以选择水平触发和边缘触发，这就好比物理实验中示波器的两种触发模式；\n假设有这样一个 tcp 通信的栗子：\n\n对方给我发送了 2kb 数据\n我通过 epoll_wait 成功获取到这个文件描述符的读事件就绪\n我取出文件描述符，通过 recv 读取了 1kb 的数据\n但缓冲区里面还有 1kb……\n\n5.3.1 水平触发 LT所谓水平触发，就是只要 fd 的缓存区里面有数据，那么 epoll 就会一直认为这个 fd 的读事件是就绪的，并一直通知用户；\n\n上面的栗子中，因为用户只拿走了 1kb 数据，缓冲区里面还有 1kb，在第二次调用 epoll_wait 的时候，epoll 还是会报告该文件描述符的读事件就绪，让用户取走剩下的数据\n只有所有的数据都被处理完毕，epoll 才不会继续通知\nLT 支持阻塞和非阻塞读写\n\n因为 LT 模式只要缓冲区中还有剩余数据，epoll 就会一直通知我们，这就允许上层不需要一次性取走所有数据，或者说不立刻处理当前缓冲区的数据。\n因此，在 LT 模式中，只要是事件就绪，那么缓冲区里面一定会有数据。所以它是即支持阻塞，也支持非阻塞的文件读写的！\n\nselect&#x2F;poll 都是默认的 LT 模式，且不可以切换模式；epoll 默认是 LT，但可以切换到 ET\n\n5.3.2 边缘触发 ET边缘触发的含义，是只有某个文件描述符的数据变动的时候，才会通知用户；反应到读事件上，只有缓冲区数据增多了，才会通知用户；\n\n在上面的 tcp 通信栗子中，epoll 会在数据到来的时候通知用户；但即便用户没有一次性读取完毕所有数据，epoll 并不会继续通知了（除非有 PSH 信息到来）\n在 ET 模式下，文件描述符的事件就绪后，只有一次处理机会。第二次你就无法得知这个文件描述符上是否还有没有读完的数据了\n因为 ET 模式下 epoll_wait 返回的次数更少，所以 ET 的性能远高于 LT（nginx 默认采用 ET 模式的 epoll）\n因为我们只有一次机会，所以收到事件后必须立即处理\n只支持非阻塞\n\n5.3.3 LT 和 ET 的区别  因为 ET 模式下，epoll 只会提示你一次事件就绪，所以就倒逼程序猿在收到这个事件之后，一次性处理完数据；\n当然，LT 模式下你也可以这么做（如果每次都能一次性取走数据，那么 LT 和 ET 的性能差距就不大了）。但 ET 模式就相当于告诉所有使用者，必须这么做，减少了容错率；\n但 ET 的代码复杂度会增加；\n5.3.4 ET 和非阻塞  为什么 ET 必须要将文件描述符设置成非阻塞呢？\n假设下面这个场景，客户端 C 给服务端 S 发送 10kb 数据，在没有收到服务端对这个数据的响应之前，不会继续发送数据；\n\n但服务器一次性只读取了 1KB，剩下了 9KB 数据在缓冲区中；因为数据没有读完，所以不会给客户端发送响应。\n\n因为 epoll 设置了 ET 模式，所以并不会认为此时的文件描述符读就绪；epoll_wait不会针对这个文件描述符返回，剩下的 9KB 数据会一直留在缓冲区中；\n\n注意，服务端的代码逻辑是收到就绪事件就读取一次；并不存在再次读取的可能\n\n问题就来了！\n\n服务端必须要收到就绪事件才会把剩下的 9kb 数据给读取完毕\n服务端想要收到就绪事件，就必须收到客户端 C 发来的新数据\n但客户端 C 认为服务器没有给自己发送响应，不会继续发送数据\n\n这就相当于一个死循环了！\n\n因此，服务端为了保证一次性能将数据全部取出，必须要采用循环读取 + 非阻塞的方式来将缓冲区读完！\n如果采用阻塞式，那么在轮询读取的时候，就有可能因为缓冲区已经空了而阻塞！因为我们这个是一个单线程的模型，这样会直接导致整个服务器宕机了。\n而 LT 则不会出现此问题，因为只要缓冲区中有数据就会通知你，所以我们可以一次读取定长，再将读到的数据拼接起来。\n5.3.5 epoll 的使用场景epoll 的高性能是有一定特殊场景的，如果场景不适合，epoll 的性能可能表现不佳；\n\n对于多链接且链接中有一部分活跃的时候，适合使用 epoll\n\n比如各种互联网 APP 的入口服务器，就很适合使用 epoll 来处理上万客户端的请求；\n如果是系统内部处理服务器和服务器之间的通信，链接数较少的情况，这种时候使用 epoll 并不方便。得根据具体需要选择更加适合的 IO 模型。\n5.4 惊群效应\n参考 https://zhuanlan.zhihu.com/p/359774959\n\n5.4.1 概念  在多线程环境下，可能会遇到 epoll 的惊群效应；\n\n那么什么是惊群效应呢。其产生的原因是什么呢？\n\n惊群效应的具体情况是，当有多个线程或进程在 epoll 上等待某个事件（如套接字可读事件），当该事件发生时，所有等待的线程或进程都会被唤醒。然而，只有一个线程或进程可以成功地处理这个事件，而其他的线程或进程会进行不必要的竞争，可能会导致额外的上下文切换、锁竞争等问题，从而降低系统性能。\n\n以下是一个具体场景的说明\n\n在多线程或者多进程环境下，有些人为了提高程序的稳定性，往往会让  多个线程  或者  多个进程  同时在 epoll_wait 监听的 socket 描述符。当一个新的链接请求进来时，操作系统  不知道  选派那个线程或者进程处理此事件，则干脆将其中  几个线程  或者进程给唤醒，而实际上只有其中一个进程或者线程能够成功处理 accept 事件，其他线程都将失败，且 errno 错误码为EAGAIN。这种现象称为惊群效应。\n结果是肯定的，惊群效应肯定会带来资源的消耗和性能的影响，因为你无端地多唤醒了几个线程，这些线程 &#x2F; 进程却没有活干。\n5.4.2 多线程环境下解决办法\n专门的线程负责等待：在多线程场景下，不建议让多个线程进行 epoll_wait，而用单个线程进行 wait，并由该线程调用accept 建立新链接，并将就绪的文件描述符交付给其他线程，来处理后续的读写操作。\n使用线程池：不为每个链接都创立一个专门的线程，而是根据读写事件，将其交付给线程池中已有线程来处理；\n使用 ET 模式：该模式下读写就绪的时候只会通知一次，再加上 epoll 本身是线程安全的，所以只会有一个线程可以拿到这个就绪事件，从而避免惊群现象；\n互斥锁：同一时间只有一个线程进行等待和事件处理；\n\n5.4.3 多进程下解决办法  目前很多开源软件，如 lighttpd 和 nginx 等都采用 master/workers 的模式提高软件的吞吐能力及并发能力，在 nginx 中甚至还采用了  负载均衡  的技术，在某个子进程的处理能力达到一定负载之后，由其他  负载较轻的子进程  负责·的调用，那么 nginx 和 Lighttpd 是如何避免 epoll_wait 的惊群效用的呢？\n\nlighttpd 的解决思路是  无视  惊群效应\n\n仍然采用 master/workers 模式，每个子进程仍然自己在监听的 socket 上调用 epoll_wait，当有新的链接请求发生时，操作系统仍然只是唤醒其中部分的子进程来处理该事件，仍然只有一个子进程能够成功处理此事件，那么其他被惊醒的子进程捕获EAGAIN 错误，并无视。\n\nnginx 的解决思路是互斥锁\n\n在同一时刻，永远都只有一个  子进程在监听的 socket 上 epoll_wait，其做法是，创建一个全局的pthread_mutex_t，在子进程进行epoll_wait 前，则先获取锁。当 epoll_wait 返回之后，nginx 会调用 accept 把连接取出来，然后释放文件锁，让别的进程去监听。\n这是一种折衷的办法，并没有很完美，首先进程间  争抢锁  会有性能开耗（即使是非阻塞的锁），中间可能会有小段时间没有进程去获取锁，比如 A 进程拿到锁，其他进程将会过一小段时间尝试再去获取锁，而这小段时间里面如果请求量很大，A 仅接受一小部分请求就让出锁，则中间过程会有一些连接事件被 hang 住；\n5.4.4 内核解决了惊群效应了吗  惊群的根本原因在于 epoll 的默认行为是对于  多进程监听同一文件不会设置互斥，进而将所有进程唤醒，后续的内核版本主要提供了两种解决方案\n\n既然默认不会设置互斥，那就加一个互斥功能好了，linux 4.5内核之后给 epoll 添加了一个 EPOLLEXCLUSIVE 的标志位，如果设置了这个标志位，那 epoll 将进程挂到等待队列时将会设置一下互斥标志位，这时实现跟内核原生 accept 一样的特性，只会唤醒队列中的一个进程\n第二种方法：linux 3.9内核之后给 socket 提供 SO_REUSEPORT 标志，这种方式解决得更彻底，他允许不同进程的 socket 绑定到同一个端口，取代以往需要子进程共享 socket 监听的方式，这时候，每个进程的监听 socket 将指向 open_file_tables 下的不同节点，也就是说不同进程是在自己的设备等待队列下被挂起的，不存在共享 fd 的问题，也就不存在被同时唤醒的可能。而内核则在驱动中将设置了 SO_REUSEPORT 并且绑定同一端口的这些 socket 分到同一个 group 中，当有 tcp 连接事件到达的时候，内核将会对源 IP+ 源端口 取 hash 然后指定这个 group 中其中一个进程来接受连接，相当于在内核级别中实现了一个负载均衡\n\n基于以上两种方法，其实 epoll 生态在目前来说不存在所谓的惊群效应了。而新版本的 nginx 也采用了 SO_REUSEPORT来解决此问题。\n除非你溢用 epoll，比如多进程之间共享了同一个 epfd（父进程创建 epoll 由多个子进程来调用），那就不能怪 epoll 了，因为这时候多个进程都被挂到这个 epoll 下，这种情况下，已经不是仅仅是惊群效应的问题了；比如说，A 进程在 epoll 挂了 socket1 的连接事件，B 进程调用了 epoll_wait，由于属于同一个 epfd，当 socket1 产生事件的时候，进程 B 也会被唤醒，而更严重的事情在于，在 B 进程的空间下并不存在 socket1 这个 fd，从而把问题搞得很复杂。\n总结：千万不要在多线程 &#x2F; 多进程之间共享 epfd！\n6.Reactor 模型  接下来就让我们来用 epoll 编写一个基于 Reactor 模式的服务器吧！\n6.1 什么是 Reactor？\nReactor 模型是基于事件驱动的，通过一个或者多个输入同时传递给服务端进行处理\n服务端请求程序处理传入的多个请求，并分发到相应的处理线程\n基于 IO 多路转接（多路复用）模型：多个链接通用一个阻塞对象，引用程序只需要在一个阻塞对象等待，无需阻塞等待所有链接；当有新链接或者事件就绪的时候，由操作系统通知应用程序，开始进行业务处理\n基于线程池复用线程资源：不必给每个链接单独创建线程，而是将链接完成后的业务处理交付给已有线程池中的线程进行处理，一个线程在生命周期中可以处理多个链接的业务。\n\nreactor 模式有下面 3 种方式，参考博客 @顽石九变\n6.1.1 主从 Reactor 多线程模型  第一种是多线程模式的，有不同的从属 reactor 来进行事件监控和处理\n\nReactor 主线程负责监听事件并进行链接的 accept\naccpet 获取到链接后，分配给某一个从 Reactor 进行读写事件的监听\n从 Reactor 进行事件监听，当有新事件发生的时候，创建 Handler 进行事件处理\nHeadler 通过 read 读取数据，并处理数据（这里还可以将读取数据后的响应操作分发给线程池进行处理，线程池处理完毕后返回给 Handler），通过 send 返回给客户端\nReactor 主线程可以对应多个子线程\n\n\n\n6.1.2 单 Reactor 多线程\nReactor 通过多路转接监听客户端事件，收到事件后，进行分发\n如果是建立链接的请求，则执行 accept，建立链接后，创建一个 Handler 完成链接建立后的各个操作\n如果不是链接请求（读写就绪）则由 Reactor 分发调用链接对应的读写 Handler 来进行处理\nHandler 只负责响应具体的事件，而不进行具体的业务处理\n通过 Handler 中的 read 读取到数据后，分发给线程池子中的线程处理，处理完毕后返回 Handler，再通过写方法发送给客户端\n\n\n6.1.3 单 Reactor 单线程  第三种是单线程模式下的（半异步半同步模型），当收到某个客户端的就绪事件，就去处理这个客户端的请求。此时 Handler 会完成 read 到业务处理到 send 的全流程；\n本次主要写的是该模式下的操作，因为它基本是  串行  运行的，思路比较容易理解。但需要注意的是，这种模式支持的客户端量不应过多，否则会极大影响性能。\n\n\n6.1.4 总结  三种模式用生活案例来理解\n\n单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服务\n\n单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待\n\n主从 Reactor 多线程，多个前台接待员，多个服务员\n\n\nReactor 模型具有如下优点\n\n响应快，不必为单个同步事件所阻塞，虽然 Reactor 本身依然是同步的\n\n可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程 &#x2F; 进程的切换开销\n\n扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源\n\n复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性\n\n\n6.2 代码分析  话不多说，直接上代码吧！本次将所有处理模块都给拆分开来，一一进行说明\n6.2.1 Epoller.hpp首先是将对 epoll 的三个系统调用函数进行一定的封装，统一进行错误的判断处理。方便了其他模块的调用用；\n这部分的代码非常简单，就只在注释里写一下解析吧！\n#pragma once#include &lt;iostream&gt;#include &lt;cerrno&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;#include &lt;sys/epoll.h&gt;#include &quot;Log.hpp&quot;class Epoller&#123;public:    static const int gsize = 128;public:    static int CreateEpoller()    &#123;        int epfd = epoll_create(gsize); // 创建对应 size 的 epfd        if (epfd &lt; 0) // 错误判断        &#123;            logMessage(FATAL, &quot;epoll_create : %d : %s&quot;, errno, strerror(errno));            exit(3);        &#125;        return epfd; // 正确返回 epfd    &#125;    static bool AddEvent(int epfd, int sock, uint32_t event)    &#123;        struct epoll_event ev;        ev.events = event; // 设置 event        ev.data.fd = sock;        // 给对应的 socket 添加到 epoll 中        int n = epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &amp;ev);        return n == 0; // 返回值是是否调用成功    &#125;    static bool ModEvent(int epfd, int sock, uint32_t event)    &#123;        struct epoll_event ev;        ev.events = event;        ev.data.fd = sock;        // 修改已有 scoket 的 event        // 该 socket 必须先用 ADD 添加，否则无法修改，会返回 ENOENT 错误        int n = epoll_ctl(epfd, EPOLL_CTL_MOD, sock, &amp;ev);        return n == 0;    &#125;    static bool DelEvent(int epfd, int sock)    &#123;        // 删除指定 socket        int n = epoll_ctl(epfd, EPOLL_CTL_DEL, sock, nullptr);        return n == 0;    &#125;    static int LoopOnce(int epfd, struct epoll_event revs[], int num)    &#123;        // 单次 wait 的调用，从数组里面取回就绪的文件描述符        int n = epoll_wait(epfd, revs, num, -1);        if(n == -1)        &#123;            logMessage(FATAL, &quot;epoll_wait : %d : %s&quot;, errno, strerror(errno));        &#125;        return n;    &#125;&#125;;\n\n6.2.2 Sock.hpp同 select，见上文 3.2.1 socket 部分；\n6.2.3 Log.hpp一个巨简单的日志类\n#pragma once#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;cstdarg&gt;#include &lt;cassert&gt;#include &lt;cassert&gt;#include &lt;cstring&gt;#include &lt;cerrno&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define DEBUG 0#define NOTICE 1#define WARNING 2#define FATAL 3const char *log_level[] = &#123;&quot;DEBUG&quot;, &quot;NOTICE&quot;, &quot;WARINING&quot;, &quot;FATAL&quot;&#125;;#define LOGFILE &quot;serverTcp.log&quot;class Log&#123;public:    Log():logFd(-1)    &#123;&#125;    void enable()    &#123;        umask(0);        logFd = open(LOGFILE, O_WRONLY | O_CREAT | O_APPEND, 0666);        assert(logFd != -1);        dup2(logFd, 1);        dup2(logFd, 2);    &#125;    ~Log()    &#123;        if(logFd != -1)         &#123;            fsync(logFd);            close(logFd);        &#125;    &#125;private:    int logFd;&#125;;// logMessage(DEBUG, &quot;%d&quot;, 10);void logMessage(int level, const char *format, ...)&#123;    assert(level &gt;= DEBUG);    assert(level &lt;= FATAL);    char *name = getenv(&quot;USER&quot;);    char logInfo[1024];    va_list ap;    va_start(ap, format);    vsnprintf(logInfo, sizeof(logInfo) - 1, format, ap);    va_end(ap); // ap = NULL    FILE *out = (level == FATAL) ? stderr : stdout;    fprintf(out, &quot;%s | %u | %s | %s\\n&quot;,            log_level[level],            (unsigned int)time(nullptr),            name == nullptr ? &quot;unknow&quot; : name,            logInfo);    fflush(out); // 将 C 语言缓冲区中的数据刷新到 OS    fsync(fileno(out));   // 将 OS 中的数据尽快写入硬盘&#125;\n\n6.2.4 TcpServer这是我们 reactor 模型的重点\n1.Connection 类  这里先定义了一个 Connection 链接类，比较重要的是类里面有 3 个回调方法的指针。在 Reactor 中，我们用回调方法来替代了主执行流直接调用函数的方式。线程只需要接收到这个 Connection 对象，就可以用回调方法来实现对链接的数据处理\nusing func_t = std::function&lt;int(Connection *)&gt;;using callback_t = std::function&lt;int(Connection *, std::string &amp;)&gt;;class Connection&#123;public:    // 文件描述符    int sock_;    TcpServer *R_;// 主服务器的类指针    // 自己的接受和发送缓冲区    std::string inbuffer_;    std::string outbuffer_;    // 读、写、异常的回调函数    func_t recver_;     func_t sender_;    func_t excepter_;public:    Connection(int sock, TcpServer *r) : sock_(sock), R_(r)    &#123;&#125;    void SetRecver(func_t recver) &#123; recver_ = recver; &#125;    void SetSender(func_t sender) &#123; sender_ = sender; &#125;    void SetExcepter(func_t excepter) &#123; excepter_ = excepter; &#125;    ~Connection() &#123;&#125;&#125;;\n\n2.TcpServer 成员变量  再来看看 tcpserver 的成员变量有什么\nprivate:\t// 接收队列的长度    static const int revs_num = 64;    // 1. 网络 socket    int listensock_;    // 2. epoll 的 fd    int epfd_;    // 3. 将 epoll 和上层代码进行结合，已有链接    std::unordered_map&lt;int, Connection *&gt; connections_;    // 4. 就绪事件列表    struct epoll_event *revs_;    // 5. 设置完整报文的处理回调方法    callback_t cb_;\n\n3. 构造  随后便是在构造函数中初始化这些成员变量，先是从 Sock.hpp 中获取到监听文件描述符，然后再通过 Epoller 类获取到 epfd 句柄，最后是将 listensocket 放入 epoll 的监听中；\n这里的 std::bind 的作用，是将当前 TcpServer 的 this 指针绑定到 TcpServer::Accepter 函数的第一个参数上，否则在类外没有办法通过 Connection 类的回调指针来调用这个类的成员函数\nTcpServer(callback_t cb, int port = 8080) : cb_(cb)&#123;    // 当前监听的文件描述符及其事件    revs_ = new struct epoll_event[revs_num];     // 网络功能    listensock_ = Sock::SocketInit();    Util::SetNonBlock(listensock_);    Sock::Bind(listensock_, port);    Sock::Listen(listensock_);    // 多路转接    epfd_ = Epoller::CreateEpoller();    // 添加 listensock 匹配的 connection    AddConnection(listensock_, EPOLLIN | EPOLLET,                  std::bind(&amp;TcpServer::Accepter, this, std::placeholders::_1), nullptr, nullptr);&#125;\n\n4. 添加链接  在AddConnection函数中，我们会将 socket 给添加到 epfd 中；如果这个 epfd 是使用了 EPOLLET 的 ET 模式，则还需要设置非阻塞；\nvoid AddConnection(int sockfd, uint32_t event, func_t recver, func_t sender, func_t excepter)&#123;    if (event &amp; EPOLLET)        Util::SetNonBlock(sockfd);    // 添加 sockfd 到 epoll    Epoller::AddEvent(epfd_, sockfd, event);    // 将 sockfd 匹配的 Connection 也添加到当前的 unordered_map 中    Connection *conn = new Connection(sockfd, this);    conn-&gt;SetRecver(recver);    conn-&gt;SetSender(sender);    conn-&gt;SetExcepter(excepter);    connections_.insert(std::make_pair(sockfd, conn));    logMessage(DEBUG, &quot; 添加新链接到 connections 成功: %d&quot;, sockfd);&#125;\n\n设置非阻塞的代码很简单，在前文已经演示过了\nclass Util&#123;public:    static void SetNonBlock(int fd)    &#123;        int fl = fcntl(fd, F_GETFL);        fcntl(fd, F_SETFL, fl | O_NONBLOCK);    &#125;&#125;;\n\n5. 析构  在析构函数中，我们需要将 listensocket 和 epfd 两个文件描述符关闭，并析构掉链接数组\n~TcpServer()&#123;    if (listensock_ != -1)        close(listensock_);    if (epfd_ != -1)        close(epfd_);    delete[] revs_;    // 还需要析构掉连接池中尚存在的 connection 对象    for(auto&amp;c:connections_)&#123;        delete c.second;    &#125;&#125;\n\n6. 获取新连接 Accept在获取新连接这里，我们采用了一个死循环来获取。这是因为对于 listensocket 文件描述符而言，只要来了一个新链接，在 ET 模式下就会提示我们。但有可能会出现我们还没有来得及取走这个链接，就又来了一个新链接的情况（可以简化理解为一次性来了两个链接）\n这时候因为 ET 的特性，我们就需要一次性取走所有链接；为了避免在 Accept 的时候，因为链接已经都被取走了而阻塞住，我们需要将 listensocket 设置为  非阻塞；\n\n关于新链接为什么只关注读事件，在注释中有说明；\n\n对于 listensocket 来说，这个 Accepter 函数就是它的读事件回调，所以这个函数的参数也是一个 Connection *conn 对象，其是为了与其他事件处理函数统一（因为这个事件处理函数不在 Connection 类中，所以我们必须要获取一个对象才能访问到它的成员变量）\nint Accepter(Connection *conn)&#123;    while (true)    &#123;        std::string clientip;        uint16_t clientport = 0;        int sockfd = Sock::Accept(conn-&gt;sock_, &amp;clientip, &amp;clientport);        if (sockfd &lt; 0)        &#123;            // 接收函数被事件打断了            if (errno == EINTR)                continue;            // 本次数据没有准备好，可以理解为接收缓冲区空了            else if (errno == EAGAIN || errno == EWOULDBLOCK)                break;            else            &#123;                logMessage(WARNING, &quot;accept error&quot;);                return -1;            &#125;        &#125;        logMessage(DEBUG, &quot;get a new link: %d&quot;, sockfd);        // 注意：默认我们只设置了让 epoll 帮我们关心读事件，没有关心写事件        // 为什么没有关注写事件：因为最开始的时候，写空间一定是就绪的！        // 运行中可能才会存在写条件不满足 -- 写空间被写满了        AddConnection(sockfd, EPOLLIN | EPOLLET,                      std::bind(&amp;TcpServer::TcpRecver, this, std::placeholders::_1),                      std::bind(&amp;TcpServer::TcpSender, this, std::placeholders::_1),                      std::bind(&amp;TcpServer::TcpExcepter, this, std::placeholders::_1));    &#125;    return 0;&#125;\n\nEAGAIN or EWOULDBLOCK\tThe socket is marked nonblocking and the receive operation would block, or a receive timeout had been set and the timeout expired before data was received.  POSIX.1 allows either error to be returned for this case, and does not require these constants to have the same value, so  a  portable application should check for both possibilities.\n\n7. 链接的事件处理函数  其他链接的三个处理函数分别是TcpRever/TcpSender/TcpExcepter;\n首先，在处理某一个链接的时候，我们必须要保证这个链接在已有的 map 里面，否则代表这个链接已经被关闭或者异常退出了；同理，在异常和关闭链接的处理流程中，我们也需要将链接从 map 中删除\nbool IsExists(int sock)&#123;    auto iter = connections_.find(sock);    if (iter == connections_.end())        return false;    else        return true;&#125;\n\n读  对于读事件而言我们也是进行循环读取，该文件描述符也需要被设置为非阻塞。读取的内容拼接到该 Connection 对象的输入缓冲区 string 中；\n在读取完毕后，我们需要在协议里面定义一个根据  应用层协议字段  来分离报文的函数（避免 tcp 的粘包问题），最终会得到一个 string 的数组，每个数组成员都是一个完整的报文；\n最后，我们直接一个 for 循环，通过该 tcpserver 对象在初始化时候设置的 cb_ 函数回调指针，来处理每一个报文（为每一个报文提供服务）\nint TcpRecver(Connection *conn)&#123;    while (true)    &#123;        char buffer[1024];        ssize_t s = recv(conn-&gt;sock_, buffer, sizeof(buffer) - 1, 0);        if (s &gt; 0)        &#123;            buffer[s] = 0;            conn-&gt;inbuffer_ += buffer;        &#125;        else if (s == 0)        &#123;            logMessage(DEBUG, &quot;client quit&quot;);            conn-&gt;excepter_(conn);            break;        &#125;        else        &#123;            if (errno == EINTR) // 接收事件被打断                continue;            // 接收缓冲区空了            else if (errno == EAGAIN || errno == EWOULDBLOCK)                break; // 跳出循环            else            &#123;                // 出错了                logMessage(DEBUG, &quot;recv error: %d:%s&quot;, errno, strerror(errno));                conn-&gt;excepter_(conn);                break;            &#125;        &#125;    &#125;    // 将本轮全部读取完毕    std::vector&lt;std::string&gt; result;    PackageSplit(conn-&gt;inbuffer_, &amp;result);    for (auto &amp;message : result)    &#123;        cb_(conn, message);    &#125;    return 0;&#125;\n\n这个框架的好处就在于，你可以单独实现不同协议的报文分离函数和数据服务函数，而不需要重写 TcpServer 的实现，相当于解耦；\n写int TcpSender(Connection *conn)&#123;    while(true)    &#123;        ssize_t n = send(conn-&gt;sock_, conn-&gt;outbuffer_.c_str(), conn-&gt;outbuffer_.size(), 0);        if(n &gt; 0)        &#123;            // 去除已经成功发送的数据            conn-&gt;outbuffer_.erase(0, n);        &#125;        else        &#123;            // 写入操作被打断            if(errno == EINTR) continue;            // 写入缓冲区满了，没办法继续写            else if(errno == EAGAIN || errno == EWOULDBLOCK) break;             else // 异常            &#123;                conn-&gt;excepter_(conn);                logMessage(DEBUG, &quot;send error: %d:%s&quot;, errno, strerror(errno));                break;            &#125;        &#125;    &#125;    return 0;&#125;\n\n注意，这里的写入如果遇到(errno == EAGAIN || errno == EWOULDBLOCK) 这两种情况，并不能确保输出缓冲区中的数据已经被全部写入了；有可能是写入缓冲区满了导致无法继续写入；\n这种 i 情况下，我们需要判断 outbuffer 是否为空，如果不为空，则还是需要设置 EPOLLOUT 标记位，告知 epoll 继续帮我们关注写事件（这样 epoll 就会发信息告知 Reactor，Reactor 会重新调用写入函数，继续写入缓冲区的剩下数据）这个操作会在主执行流中进行统一判断\n// 主执行流conn-&gt;sender_(conn); // 主执行流调用发送函数// 判断本次是否发完毕了，没有发完毕还需要继续关心读写if(conn-&gt;outbuffer_.empty()) conn-&gt;R_-&gt;EnableReadWrite(conn-&gt;sock_, true, false);else conn-&gt;R_-&gt;EnableReadWrite(conn-&gt;sock_, true, true);\n\n// 打开或者关闭对于特定 socket 是否要关心读或者写//- EnableReadWrite(sock, true, false); // 只关心读//- EnableReadWrite(sock, true, true);  // 同时关心读写void EnableReadWrite(int sock, bool readable, bool writeable)&#123;    uint32_t event = 0;    event |= (readable ? EPOLLIN : 0);    event |= (writeable ? EPOLLOUT : 0);    Epoller::ModEvent(epfd_, sock, event);&#125;\n\n异常  为了统一进行异常处理，在上文中当我们遇到读写出错的时候，都会调用这个函数；\n在这个函数体内，会将链接从 epoll 中删除、关闭链接、释放 connection 对象、将文件描述符从 map 里面剔除；\n需要注意的是，一定要先将 socket 从 epoll 里面剔除掉，再关闭 socket！\nint TcpExcepter(Connection *conn)&#123;    // 0. 判断有效性    if(!IsExists(conn-&gt;sock_)) return -1;        // 所有的服务器异常，都会被归类到这里    // 1. 删除 epoll 的监看    Epoller::DelEvent(epfd_, conn-&gt;sock_);    logMessage(DEBUG, &quot;remove epoll event!&quot;);    // 2. close    close(conn-&gt;sock_);    logMessage(DEBUG, &quot;close fd: %d&quot;, conn-&gt;sock_);    // 3. delete conn;    delete connections_[conn-&gt;sock_];    logMessage(DEBUG, &quot;delete connection object done&quot;);    // 4. erase conn;    connections_.erase(conn-&gt;sock_);    logMessage(DEBUG, &quot;erase connection from connections&quot;);    return 0;&#125;\n\n8. 运行  对于 TcpServer 而言，一次的运行就是调用一次epoll_wait，再根据事件就绪的文件描述符，调用不同的事件处理函数\nvoid Dispatcher()&#123;    int n = Epoller::LoopOnce(epfd_, revs_, revs_num);    for (int i = 0; i &lt; n; i++)    &#123;        int sock = revs_[i].data.fd;        uint32_t revent = revs_[i].events;        // 判断是否出现错误，如果出现了错误，那就把 EPOLLIN 和 OUT 都加上        // 这样这个链接会进入下面的处理函数，并在处理函数中出现异常        // 处理函数中出现异常回统一调用 TcpExcpter 函数        if(revent &amp; EPOLLHUP) revent |= (EPOLLIN|EPOLLOUT);        if(revent &amp; EPOLLERR) revent |= (EPOLLIN|EPOLLOUT);        if (revent &amp; EPOLLIN)        &#123;            if (IsExists(sock) &amp;&amp; connections_[sock]-&gt;recver_)                connections_[sock]-&gt;recver_(connections_[sock]);        &#125;        // 当链接的写事件被激活的时候，在这里就会触发写事件的处理        // 所以并不需要在 recv 里面主动调用写事件处理函数        // 只需要告诉 epoll 让它帮我们监控写事件，那么就会在这里触发写操作        if (revent &amp; EPOLLOUT)        &#123;            if (IsExists(sock) &amp;&amp; connections_[sock]-&gt;sender_)                connections_[sock]-&gt;sender_(connections_[sock]);        &#125;    &#125;&#125;\n\n整个服务器运行起来，就一直调用分发函数就 OK 啦~\nvoid Run()&#123;    while (true)    &#123;        Dispatcher();    &#125;&#125;\n\n6.2.5 主执行流  对于主执行流而言，要做的就是获取到命令行参数的端口，然后创建 tcpserver 对象并绑定事件处理函数\n#include &quot;TcpServer.hpp&quot;#include &quot;Service.hpp&quot;#include &lt;memory&gt;using namespace std;static void usage(std::string process)&#123;    cerr &lt;&lt; &quot;\\nUsage: &quot; &lt;&lt; process &lt;&lt; &quot; port\\n&quot;         &lt;&lt; endl;&#125;int main(int argc, char *argv[])&#123;    if (argc != 2)    &#123;        usage(argv[0]);        exit(0);    &#125;    TcpServer svr(HandlerRequest, atoi(argv[1]));    svr.Run();    return 0;&#125;\n\n事件处理函数可以做任意封装，来实现你自己想要的功能\nint HandlerRequest(Connection *conn, std::string &amp;message)&#123;    // beginhandler 里面是具体的调用逻辑，calculator 是本次事务处理函数    return BeginHandler(conn, message, calculator);&#125;\n\n这里就是我们单个完整报文的处理函数，在 tcprecver 方法里面被调用了；\n根据上文描述的调用方法，我们可以确定，这里传入来的 message 肯定是一个完整的应用层报文，我们只需要创建一个属于我们自己的协议和协议中的数据处理函数就 OK 了！\nint BeginHandler(Connection *conn, std::string &amp;message, service_t service)&#123;    // message 一定是一个完整的报文，因为我们已经对它进行了解码    Request req;    // 反序列化，进行处理的问题    if (!Parser(message, &amp;req))    &#123;        // 写回错误消息        return -1;        // 可以直接关闭连接        // conn-&gt;excepter_(conn);    &#125;    // 业务逻辑    Response resp = service(req);    std::cout &lt;&lt; req.x &lt;&lt; &quot; &quot; &lt;&lt; req.op &lt;&lt; &quot; &quot; &lt;&lt; req.y &lt;&lt; std::endl;    std::cout &lt;&lt; resp.code &lt;&lt; &quot; &quot; &lt;&lt; resp.result &lt;&lt; std::endl;    // 序列化    std::string sendstr;    Serialize(resp, &amp;sendstr);    // 处理完毕的结果，发送回给 client    conn-&gt;outbuffer_ += sendstr;    conn-&gt;sender_(conn);    if(conn-&gt;outbuffer_.empty()) conn-&gt;R_-&gt;EnableReadWrite(conn-&gt;sock_, true, false);    else conn-&gt;R_-&gt;EnableReadWrite(conn-&gt;sock_, true, true);    std::cout &lt;&lt; &quot;--- end ---&quot; &lt;&lt; std::endl;    return 0;&#125;\n\n6.2.6 协议和数据处理  下面提供一个最基础的计算器协议，这个协议的好处是我们可以用 telnet 就模拟出请求，无需写一个 tcp 客户端。\nx 操作符 y#\n\n这个协议中，每个有效数据中都会带上一个空格，并以 # 作为单个报文的结尾；\n响应和请求的结构体格式也非常简单，响应里面是状态码和计算结果；我们在协议中添加序列化和反序列化函数就可以将响应和请求结构体转成字符串\nstruct Request&#123;    int x;    int y;    char op;&#125;;struct Response&#123;    int code;    int result;&#125;;\n\n完整代码\n#pragma once#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#define SEP &#x27;#&#x27;#define SEP_LEN sizeof(SEP)#define CRLF &quot;\\r\\n&quot;#define CRLF_LEN strlen(CRLF)#define SPACE &quot; &quot;#define SPACE_LEN strlen(SPACE)// 分离独立报文void PackageSplit(std::string &amp;inbuffer, std::vector&lt;std::string&gt; *result)&#123;    while (true)    &#123;        std::size_t pos = inbuffer.find(SEP);        if (pos == std::string::npos)            break;        result-&gt;push_back(inbuffer.substr(0, pos));        inbuffer.erase(0, pos + SEP_LEN);    &#125;&#125;struct Request&#123;    int x;    int y;    char op;&#125;;struct Response&#123;    int code;    int result;&#125;;bool Parser(std::string &amp;in, Request *req)&#123;    // 1 + 1, 2 * 4, 5 * 9, 6 *1    std::size_t spaceOne = in.find(SPACE);    if (std::string::npos == spaceOne)        return false;    std::size_t spaceTwo = in.rfind(SPACE);    if (std::string::npos == spaceTwo)        return false;    std::string dataOne = in.substr(0, spaceOne);    std::string dataTwo = in.substr(spaceTwo + SPACE_LEN);    std::string oper = in.substr(spaceOne + SPACE_LEN, spaceTwo - (spaceOne + SPACE_LEN));    if (oper.size() != 1)        return false;    // 转成内部成员    req-&gt;x = atoi(dataOne.c_str());    req-&gt;y = atoi(dataTwo.c_str());    req-&gt;op = oper[0];    return true;&#125;void Serialize(const Response &amp;resp, std::string *out)&#123;    std::string ec = std::to_string(resp.code);    std::string res = std::to_string(resp.result);    *out = ec;    *out += SPACE;    *out += res;    *out += CRLF;&#125;\n\n在 service.hpp 里面则是数据处理的计算函数，通过我们传入的请求，计算出结构并构造响应返回给用户\n#pragma once#include &quot;Protocol.hpp&quot;#include &lt;functional&gt;using service_t = std::function&lt;Response (const Request &amp;req)&gt;;static Response calculator(const Request &amp;req)&#123;    Response resp = &#123;0, 0&#125;;    switch (req.op)    &#123;    case &#x27;+&#x27;:        resp.result = req.x + req.y;        break;    case &#x27;-&#x27;:        resp.result = req.x - req.y;        break;    case &#x27;*&#x27;:        resp.result = req.x * req.y;        break;    case &#x27;/&#x27;:    &#123; // x_ / y_        if (req.y == 0)            resp.code = -1; // -1. 除 0        else            resp.result = req.x / req.y;    &#125;    break;    case &#x27;%&#x27;:    &#123; // x_ / y_        if (req.y == 0)            resp.code = -2; // -2. 模 0        else            resp.result = req.x % req.y;    &#125;    break;    default:        resp.code = -3; // -3: 非法操作符        break;    &#125;    return resp;&#125;\n\n6.2.7 测试  可以看到，我们的服务启动了之后，成功接收了一个链接，并计算出了我们发送的结果\n\n多个链接也不在话下！\n\nThe end多路转接这部分是 linux 服务器最重要的一部分知识，因为大部分服务器都抛弃了最传统的一个线程维护一个链接这样的方式，而采用了多路转接来实现对大量进程的维护；\n本文是学习阶段的产物，有错误在所难免，请大佬们指教！\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【图床】删除对象存储桶前一定要检查！","url":"/posts/3595872827/","content":"我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。\n什么情况？我在博客尚有引用某个对象存储 bucket 中图片的情况下，删除了那个 bucket（因为这个 bucket 很久没有用，算是弃用的）\n还好今天看旧笔记的时候，突然发现了这个问题，立马去重新搜索了一下这个旧 bucket 的图片链接，还好还好，受影响的只有两篇文章\n\n一篇之前导出过 PDF，图片还能找到\n另外一篇文章以文字为主，内部丢失的图片可有可无\n\n我恢复了第一篇里面的图片，然后修改了第二篇中和图片相关的文字说明，算是解决了这个问题。\n又重写检查了一下笔记目录，算是彻底没有这个被我删除的 bucket 里面的图片了。\n这一次还好，算是没有丢东西，不然数据不备份就删除的笑料又要多一个了……🤣\n以此为戒  删除 bucket 之前一定要检查自己到底还有没有使用这个 bucket 中的文件或者图片！\n删除图床本地目录前，一定要检查自己还有没有这个本地目录里面的图片！\n最佳方案：不要管那个 bucket，将其访问权限改成  私有  后，使用备注功能将其标记为弃用。以后不再使用该 bucket 即可。\n因为对于我个人使用来说，一个 bucket 里面不会有太多文件，目前最大的图床 bucket 也不过 2GB 而已，把它留在那里花不了几个钱！不然把 bucket 删了，哪天发现需要去里面找旧文件的时候无从下手就麻烦了！\n\n至于我为什么要删……其实是因为我有点强迫症，不用还留在那里看着有点不爽……\n\n当然还有另外一个解决方案：使用 rclone 等工具，将 s3 中的所有文件下载到本地，打包多地备份后，删除云端 bucket\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【博客】hexo 配置 sitemap 和百度 |bing| 谷歌收录","url":"/posts/3595872826/","content":"最近没事找事，又看了会关于博客主题的东西，之前的 sitemap 一直没有弄上去，现在有时间就弄一下。\n1.hexo 安装 sitemap 插件  在你的 hexo 路径下执行如下命令，安装 sitemap 生成插件\nnpm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save\n\n实测在 windows11 的 node v16.20.2 和npm  9.8.1下可以正常安装，但是安装 baidu-sitemap 插件的时候可能会有警告（不影响使用）\n安装完毕插件后，在你的 hexo 配置文件 _config.yml 中添加如下内容，指定站点地图的文件名字即可。\n# 百度和谷歌的 sitemap# npm install hexo-generator-baidu-sitemap --save# npm install hexo-generator-sitemap --savebaidusitemap:    path: baidusitemap.xmlsitemap:    path: sitemap.xml\n\n请注意，需要修改的是 hexo 的配置文件，并非主题配置文件！\n2. 如何修改 hexo 主题生成的 index.html 文件？一般情况下，站点平台都会让你在 index.html 的&lt;head&gt;里面加一个 html 语句，来验证站点的所有权。比图百度的验证 html 语句如下\n&lt;meta name=&quot;baidu-site-verification&quot; content=&quot; 验证码 &quot; /&gt;\n\n部分 hexo 主题可能提供了自定义 &lt;head&gt; 的选项（比如 butterfly 主题就有）\n如果你使用的主题没有提供自定义 &lt;head&gt;，可以尝试在主题文件夹下搜索 index 或者 head 关键字，来找到当前主题使用的index.html 生成源文件\n\n该方法  仅适用于将主题文件直接下载到 themes 文件夹下的情况，因为如果你用的是 npm 安装的主题，那么修改的主题文件是不会对其他地方的部署生效的，下一次更新主题还会覆盖掉。\n\n比如下图是 keep 主题 v3.6.1 版本中的 head.ejs，你只需要把提供的 meta 标签加到这里面，下一次部署的时候的index.html 中就会带上这个标头了。\nthemes\\keep\\layout\\_partial\\head.ejs\n\n\n3. 站长平台添加 sitemap百度  百度资源搜索平台 https://ziyuan.baidu.com/site/index#/\n百度实在是无语，之前安装了 hexo-baidu-url-submit 插件，主动调用百度 api 给他推送 url，结果弄了已经快一年了，还没有收录我的站点。\n\n实话说，百度不收录站点，网站看的人就很少。百度我自己博客的关键词，结果是一堆被百度收录的爬虫站点用我的文章赚流量。唉……\n\n在资源搜索平台的站点管理中添加你的站点，用第二点提到的方式进行验证\n\n添加完毕后，在普通收录中可以找到 sitemap 提交的区域。但是不知道为什么我这里的提交配额是 0，搜索了一下也没有找到原因。\n\n百度资源平台提交 sitemap 是取消了还是我被限制了？\n有人说是站点质量太低被百度屏蔽了，但是这个情况也是很多人都遇到过的。估计是百度策略更新什么的，不允许你添加了吧！\n如果你已经添加了 sitemap，请不要将其删除，免得到时候又没有办法添加了。\nbingbing 的站长平台直接搜就行：https://www.bing.com/webmasters/about?setlang=zh-cn\n\n国内裸连可能不稳定，需要用点方法。\n不过 bing 即便不提交 sitemap 也咔咔收录了我的博客，主打一个主动 + 来者不拒。\n\n进去之后，用微软账户登录，然后点击新增站点，输入你博客的域名\n\nbing 会让你验证站点所有权，根据下面三种方式的指引，选择一种就行了。如果你不知道如何修改 hexo 的源文件，使用 CNAME 验证 方式是最简单的（只要你有域名有权就行了）。\n\n不过估计有很多老哥都是白嫖的 github pages 或者 netlify&#x2F;vercel 的  二级域名，在没有域名所有权的情况下，你可以用前两种方式来验证。\n\nXML 文件方式：将 bing 提供的 XML 文件下载，然后放到你 hexo 源目录的 source 文件夹下，就可以了。\nHTML MATE 标记验证：部分 hexo 主题可能提供了自定义 header 的选项（比如 butterfly 主题就有）其他主题可以参考上文第二点操作\n\n域名验证完毕后，在左侧可以提交网站地图（即 sidemap）\n直接点击按钮提交你的站点地图的 url 就可以了。bing 会自动进行处理，如下图我的第一个 sitemap 已经成功处理出来了 383 个链接，非常完美。\n\n谷歌  实话说，一个纯中文且面向国内读者的站点，在谷歌上面收录了估计也没多大用处，但是可以没用，但不能没有。也给他弄一下吧。\nhttps://search.google.com/search-console/welcome\n首先是输入站点网址，因为我不需要验证所有站点，只把博客收录了就行，所以这里我选的是网址前缀。输入站点的时候需要把 http 也带上\n\n谷歌的验证方式也有很多种，这里的操作和 bing 是一样的，把它发给你的文件直接放到 hexo 的 source 路径下就可以了，或者采用 html 标签的方式验证。\n\n验证成功后，选择前往资源界面，即前往当前站点的控制台。\n如果你不小心点了完成，站点资源界面在站长工具的  左侧边栏  里面，在里面可以找到你已经添加了的站点。\n\n在左侧选择站点地图，点击添加即可\n\n\n搞定！有什么问题，欢迎评论区提出！\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【Python】pip 下载使用国内镜像源","url":"/posts/783373963/","content":"pip 下载使用国内镜像源\n\n\n1. 如何使用  在直接用 pip 安装包的时候，有时候会非常非常慢\n可以用下面的命令，在安装的时候使用清华的镜像源\n-i https://pypi.tuna.tsinghua.edu.cn/simple\n\n比如下面的操作\npip3.10 install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple\n\n速度直接起飞\n2. 修改配置文件 Linux 系统，在用户的家目录下创建一个.pip 文件夹，并在里面创建一个pip.conf\n[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn\n\n保存后，查看是否配置成功\n$ pip3.10 config listglobal.index-url=&#x27;https://pypi.tuna.tsinghua.edu.cn/simple&#x27;install.trusted-host=&#x27;https://pypi.tuna.tsinghua.edu.cn&#x27;\n\n这样就配置好了，重启后生效\n\nwindows 下 pip 配置文件路径如下（如果没有此文件，创建之）\nC:\\Users\\ 用户名 \\pip\\pip.ini\n\n输入如下内容\n[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = pypi.tuna.tsinghua.edu.cn\n\n3. 镜像源汇总  目前我测试能直接访问的镜像源有下面几个。\n清华 https://pypi.tuna.tsinghua.edu.cn/simple豆瓣 https://pypi.doubanio.com/simple/中科大 https://mirrors.bfsu.edu.cn/pypi/web/simple/阿里云 https://mirrors.aliyun.com/pypi/simple/\n","categories":["速通Python"],"tags":["Python"]},{"title":"【Python】在你的云服务 / 电脑上搭建 Python 环境","url":"/posts/800910784/","content":"本篇 wiki 会教你在你的电脑 &#x2F; 云服务器上搭建好 Python 环境\n\n\n创建你的 Python 环境  要想让 bot 跑起来，没有一个 Python 的环境怎么办？\n本篇 wiki 会教你在你的电脑 &#x2F; 云服务器上搭建好可以运行 KOOK 机器人的 Python 环境\n1.windows在 windows 下写 Python 代码的方式有很多种，这里我介绍的是vs code\n如果你已经有了 Pycham 等代码环境，直接使用即可，也没必要看这篇 wiki😋\n1.1 安装 Python\n进入 Python 官网 https://www.python.org/\n\n找到 download，下载最新的 Python 版本包\n\n\n这里下载官方推荐的 installer 即可\n\n\n\n注：如果下载速度很慢，可以考虑使用迅雷等下载工具\n\n下载完成后，打开安装包，一定要勾选 ADD PYTHON TO PATH 这个选项\n\n一定要勾选 ADD PYTHON TO PATH 这个选项！\n一定要勾选 ADD PYTHON TO PATH 这个选项！\n一定要勾选 ADD PYTHON TO PATH 这个选项！\n\n\n然后无脑下一步即可，后续就不需要修改什么，建议也不要修改安装路径\n\n安装完毕后，在 windows 开始中找到  命令提示符，也就是 windows 平台的 cmd 工具。\n或者用 win+r 快捷键，在弹出的框中输入 cmd 即可打开\n\n在里面输入Python，出现以下界面即为安装成功！\n\n\n1.2 安装 VSC\n微软官网下载 https://code.visualstudio.com/\n\n在官网可以直接下载 windows 上的 VSC，但是默认的下载链接下载是非常慢的！\nhttps://az764295.vo.msecnd.net/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n\n我们要做的就是把这个默认的下载链接改成国内的镜像源，下载速度就可以起飞！\n将下载地址中的 az764295.vo.msecnd.net 更换为 vscode.cdn.azure.cn 更改后：https://vscode.cdn.azure.cn/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n安装同样是无脑下一步！\n注 ：请不要修改 VSC 的安装位置，可能导致 VSC 无法正常运行Python 程序！\n\n打开 VSC 后，界面是英文的。别急，让我们安装几个插件，就可以愉快使用了\n点击左侧的这个按钮进入插件面版\n\n\n在这里可以安装插件，需要安装的插件有下面这些\nChinese(Simplified)  //VSC 汉化插件Python  //python 环境Pylance //python 环境Pip Manager // 安装、管理 pip 包Terminal Here // 方便我们打开终端vscode-json //json 格式化插件\n下好上面的插件后，你的左侧应该会多出来一个 pip manager 的按钮，在这里可以下载你需要的第三方依赖库\n\n\n到这里，windows 下的 Python 环境搭建就完成了！\n1.3 尝试写个最简单的 Python 代码  在 VSC 里面创建一个 test.py 文件（这里会让你选择一个工作目录，弄一个新的文件夹就可以了）\n填入下面的代码\nprint(&#x27;hello world&#x27;)\n按 CTRL+SHIFT+T 打开命令面板（左下角齿轮也可以打开），输入Terminal Here，选择下面这个选项\n\n\n在 VSC 的底部会打开这样的一个终端\n\n\n我们在这里输入Python test.py，即可运行刚刚写的 hello world 代码\n如果一切正常，应该是会输出这样的结果\n\n完成配置！\n2.Linux 平台  关于 Linux 平台的 Python 环境搭建，可以参考 博客\n\n\n下面是一次瞎升级 python 导致的错误记录, 本人所用系统为CentOS 7.6，\n\n2.1. 不要瞎改配置文件  我先是参考了一些奇葩博客，里面说道了下载完 python 新版本后，需要修改下面两个 yum 的配置文件\n实际上，压根不要修改这个配置文件！！！！\n/usr/bin/yum/usr/libexec/urlgrabber-ext-down\n\n说是要把开头的 #!/usr/bin/python2.7 修改为升级后的版本\n实际上，压根不要修改这个配置文件！！！！\n因为修改了之后执行 yum 会出现下面这个报错\n-bash: /usr/bin/yum: /usr/bin/python: 坏的解释器: 没有那个文件或目录\n\n\n参考这篇博客，把配置文件该回去才让 yum 复活【链接】\n\nyum 是基于 python2.7 的，你没事把人家依赖环境改了干哈子？\n2.2. 正确下载 Python 的方法  参考下面这个博客\n\nhttps://blog.csdn.net/weixin_41829333/article/details/110141988\n\n2.3. 要对症下药  教程博客里面提到了，需要重新创建软连接，这是没错\nln -sf /usr/local/bin/python3.8 /usr/bin/pythonln -sf /usr/local/bin/python3.8-config /usr/bin/python-config\n\n但是，并不是所有人的软连接都是用上面的代码创建！\n在执行完 python 新版本的 make 后，你需要通过下面的两个指令找到新版本 py 的安装路径\n[root@bt-7274:~]# whereis pythonpython: /usr/bin/python3.6m /usr/bin/python3.6 /usr/bin/python /usr/bin/python2.7-config /usr/bin/python2.7 /usr/lib/python3.6 /usr/lib/python2.7 /usr/lib64/python3.6 /usr/lib64/python2.7 /etc/python /usr/local/bin/python3.9-config /usr/local/bin/python3.9 /usr/local/lib/python3.9 /usr/include/python3.6m /usr/include/python2.7 /usr/local/python3/bin/python3.7 /usr/local/python3/bin/python3.9-config /usr/local/python3/bin/python3.7-config /usr/local/python3/bin/python3.9 /usr/local/python3/bin/python3.7m-config /usr/local/python3/bin/python3.7m /usr/share/man/man1/python.1.gz[root@bt-7274:~]# which python/usr/bin/python\n\n比如我这里很明显能看出来，我的新版本 python3.9 是安装在 /usr/local/bin 里面，而不是 /usr/bin 里面的\n同时，当我执行 py 出错时，报错的路径也是下面这个\n-bash: /usr/local/bin/python3: 没有那个文件或目录\n\n所以创建软链接的时候，需要对症下药进行修改！\nln -s /usr/local/python3/bin/python3 /usr/local/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3\n\n这样才能让 py 成功升级！\n2.4. 请重下依赖库  下载依赖库的时候，其实是只安装在了对应版本的 python 里面，也就是我的旧版本python3.7.8\n所以更新好了之后，你需要重新下所有的依赖库\n","categories":["速通Python"],"tags":["Linux","阿狸开发日志","Python","vscode"]},{"title":"【教程】hexo 搭建博客 +keep 主题美化","url":"/posts/138502038/","content":"感谢你来到  本小站，如果这篇博客对你有帮助，欢迎在下方评论😘！\n\n\n折腾了一整天，算是把基本的博客环境给搭建好了，页面效果还是挺不错的！后续对  寒舍  有什么新操作会对本文进行更新，可以多多关注一下哦\n\n\n本博客修改过的 keep 主题文件可以在这里查看👉 musnows&#x2F;hexo-theme-keep \n本博客修改后的 keep 主题预览站点为 keep-hexo.musnow.top\n\n1. 基本配置  我最开始  使用的平台是 HEXO+Gitee，参考这篇博客👉基于 Gitee+Hexo 搭建个人博客\n现在我不建议你使用 gitee pages，具体请看本文 4.1；\n可以根据本文向导配置 github pages，有问题可以评论提出哦╰(*°▽°*)╯\n\n操作之前，需要下载两个软件；先下载安装好 node.js 后再进行 git 操作\nnode.js：官网 https://nodejs.org/zh-cn/git：官网 https://git-scm.com/\n\n1.1 安装 hexo\n如果是 Centos 云服务器，安装 hexo 可以参考https://www.myfreax.com/how-to-install-node-js-on-centos-8/\n\n安装好这两个工具后，我们先打开 git bash（一般右键菜单里面就会有，如果找不到该软件请全局搜索）如果你安装的时候有选择 添加到命令行 ，那么是可以直接用 windows 的 cmd 来操作 git 的。这里避免你安装的时候没有选择此项，均用git bash 来演示\n\n【Git】在 Windows CMD 中和 VScode 中配置已经安装好的 git\n\n打开之后的界面应该是这样的\n\n我们 cd 进入你想要创建 hexo 本地文件的路径，比如我想在 D 盘里面创建我的 hexo 博客，那么就 cd 进入你想要的路径；如果你不知道如何填写路径，可以右键顶栏将路径复制为文本\n\n然后在 git bash 中，使用 shift+insert(ins) 进行粘贴\ncd D:\\example\n\n这样我们就成功进入我们想要的文件夹了\n\n输入 node -v 命令，测试 node.js 是否安装成功且可用；如果出现版本号，就是安装成功了（请确认 node.js 的版本大于v16）\n$ node -vv16.13.1\n\n随后在这里执行以下命令\nnpm -g install npm # 安装 npm 包管理器# 如果安装 npm 失败，则使用镜像源安装淘宝的 cnpmnpm -g install cnpm --registry=https://registry.npm.taobao.org# 如果安装了 cnpm，注意后续所有 npm 命令要用 cnpm 代替\n\n安装成功后，安装 hexo\nnpm install -g hexo-cli\n\n测试是否成功安装\nmoth@LAPTOP-R9S2524B MINGW32 /d/example$ hexo versionhexo-cli: 4.3.0os: win32 10.0.22000node: 16.13.1v8: 9.4.146.24-node.14uv: 1.42.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1l+quiccldr: 39.0icu: 69.1tz: 2021aunicode: 13.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV\n\n出现上面的字样，就是安装成功了；因为我是 2022 年 4 月操作的，这里安装的版本有点老，不过不影响使用，那就不升级了😶‍🌫️\n\n温馨提示：这些都是依赖项，如果不影响你的使用，那就不要升级！\n不要升级！不要升级！！不要升级！！！\n\n1.1.1 报错本系统不支持运行脚本  在另外一台电脑上部署 hexo 的时候，安装完毕 hexo，遇到了这个报错\nhexo : 无法加载文件 C:\\Users\\moth\\AppData\\Roaming\\npm\\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。\n\n\n解决办法，是进入 windows11 的设置页面，在  隐私 - 开发者设置 - 终端  中，允许本地 powershell 脚本在未签名的情况下运行\n\n勾上选项后，点击应用。之后运行 hexo 就没有报错了\n\n\n1.1.2 初始化博客文件夹  输入以下命令，我们会在当前文件夹创建一个 blog 文件夹，hexo 会在里面克隆基础 hexo 需要用的文件\n$ hexo init blogINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitfatal: unable to access &#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054WARN  git clone failed. Copying data insteadINFO  Install dependenciesINFO  Start blogging with Hexo!\n\n使用 cd 命令进入 blog 文件夹\ncd blog\n\n执行以下命令，安装一下依赖项\nnpm install\n\n\n随后输入下面三个命令\nhexo cl #hexo clean 的缩写hexo g # 生成文件hexo s # 开启本地预览\n\n输出的结果如下\nmoth@LAPTOP MINGW32 /d/example/blog$ hexo clINFO  Validating configmoth@LAPTOP MINGW32 /d/example/blog$ hexo gINFO  Validating configINFO  Start processingINFO  Files loaded in 94 msINFO  Generated: archives/index.htmlINFO  Generated: archives/2023/index.htmlINFO  Generated: archives/2023/01/index.htmlINFO  Generated: index.htmlINFO  Generated: fancybox/blank.gifINFO  Generated: fancybox/helpers/fancybox_buttons.pngINFO  Generated: fancybox/fancybox_loading@2x.gifINFO  Generated: css/fonts/fontawesome-webfont.ttfINFO  Generated: fancybox/fancybox_loading.gifINFO  Generated: js/script.jsINFO  Generated: fancybox/fancybox_overlay.pngINFO  Generated: fancybox/fancybox_sprite@2x.pngINFO  Generated: fancybox/fancybox_sprite.pngINFO  Generated: css/fonts/FontAwesome.otfINFO  Generated: fancybox/jquery.fancybox.cssINFO  Generated: fancybox/helpers/jquery.fancybox-buttons.cssINFO  Generated: css/images/banner.jpgINFO  Generated: css/style.cssINFO  Generated: fancybox/helpers/jquery.fancybox-buttons.jsINFO  Generated: fancybox/jquery.fancybox.jsINFO  Generated: fancybox/helpers/jquery.fancybox-media.jsINFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.cssINFO  Generated: fancybox/jquery.fancybox.pack.jsINFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.jsINFO  Generated: 2023/01/10/hello-world/index.htmlINFO  Generated: css/fonts/fontawesome-webfont.svgINFO  Generated: css/fonts/fontawesome-webfont.woffINFO  Generated: css/fonts/fontawesome-webfont.eotINFO  28 files generated in 232 msmoth@LAPTOP MINGW32 /d/example/blog$ hexo sINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n\n浏览器打开 http://localhost:4000，看到下面的预览，那就 OK 了！\n\n1.2 部署到 github pages在 Github 创建一个新仓库，名字为 用户名.github.io\n找到 blog 目录下会有一个_config.yml 文件，这是 hexo 的配置文件。在里面找到下面的字段，填入你的 github 仓库地址\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: https://github.com/musnows/musnows.github.io.git  branch: master\n\n如果你想同时部署到 gitee&#x2F;github，可以这样写\ndeploy:  type: git  repo: \t  github: https://github.com/musnows/musnows.github.io.git\t  gitee: git@gitee.com:musnow/musnow.git  branch: master\n\n随后，我们执行hexo d 部署到远程仓库\nhexo d # 部署hexo g --d # 生成文件的同时部署，推荐使用这个\n\n如果出现下面的错误，那是很正常的，因为我们没有安装部署的依赖项\nERROR Deployer not found: git\n\n安装 hexo-deployer-git\nnpm install hexo-deployer-git --save\n\n再次执行hexo g --d，输入你的 github 账户（邮箱）和密码，进行部署。\n可以看到 github 仓库多了一个 master 分支，其内部就是我们的远端文件。\n进入仓库的设置，找到 github pages 的设置，选择 master 分支部署，按下图配置\n\n等待部署成功后，就可以打开 https:// 你的名字.github.io 就可以访问了！\n做完上面的步骤，此时就可以来安装一个  主题  了。毕竟默认的 landscape 主题还是不够好用的😘\n\nssh 免密部署操作，参考  第 4 点\n\n1.2 keep 主题 Hexo 下keep 主题 初始化操作是根据开发者大哥的帮助文档进行的\n本文是对相关踩坑操作的一点说明，建议你先粗略浏览完本文，看看有啥坑🕳（挺多的）再进行 keep 主题的配置\n\nKeep 快速开始\n\n如果你想使用其他 hexo 主题，建议选择有  中文帮助文档  的 HEXO 主题，不然就得啃英语了。\n后面本站样式可能会做其他的更改，待我搞清楚进阶操作再说。毕竟咱对 CSS 和 HTML 代码是完全不懂（这是前端的内容，目前没有自学计划）\n\n前人栽树后人乘凉 ，在 keep 开发者博客的 友链  中找到了魔改了主题的老哥，直接学习起来😍！hexo 主题魔改汇总和总结\n更多内容详见本文 第 8 点\n\n当前你看到的主页已经是修改 keep 主题过后的啦！感觉如何？\n1.3 keep 主题安装目录在哪？如果你更具 keep 的官方文档用 npm 安装，你可能发现在 themes 里面没有 keep 主题的文件夹，那它到哪儿去了呢？\n\n找一找就能发现，其实在这里 blog\\node_modules\\hexo-theme-keep。这是因为我的主题是用 npm 安装的，node_modules是在当前目录安装的包的位置，所以会出现这种情况\n\n需要注意，后续修改 _comfig.yml 的时候，有的时候需要修改的是  主题  的配置文件，有些是 HEXO 官方 的配置文件，不要把二者弄混了！\n建议在 hexo 更目录的 source/_data 文件夹中创建一个keep.yml，修改配置文件只需要修改这里的keep.yml 即可，方便以后进行  平滑升级\n1.4 主题页面设置成中文 keep 主题默认的页面是英文的按钮，需要在 HEXO 配置文件_comfig.yml 中修改语言为 zh-CN 然后页面就变成中文啦！\n\n2. 如何添加博客文章 HEXO 采用的是 markdown 语法，只需要在本地的source/_posts 文件夹添加 md 源文件，就能在个人博客中显示\n以 keep 模板为例，我们需要在 md 源文件的  正文之前  添加如下语句，来设置博客的标题、上传时间、tag、分类，以及是否置顶\n\n如果要设置多个 tag，样式为[Hexo,typora, 博客]\n多个分类 categories 同理\n\n---title: 使用 hexo+gitee 搭建个人博客 date: 2022-04-23 13:30:14tags: [Hexo]categories: [ 差生文具多]sticky: 999 ---\n\n2.1 首页置顶  比如本文件的 sticky 我设置成了 999，你看到的就是本文在我的首页置顶了。如果不设置 sticky，首页默认是以 时间降序  排列文章（后发布的在前头）\n\n\n2.2 搭建图床（必做）本操作必做！为了保证你上传的 md 文件中的  图片  能在个人博客上正常显示，请先配置你的个人图床👉图床搭建教程\n如果你开启了阿里云 OSS 的 bucket 防盗链，还需要将你的站点加入白名单！\n2.3 如何导出 CSDN 的博客  如果你之前的博客是在 CSDN 上写的，可以在 markdown 编辑器的文章管理面板中导出为 md 文件\n\n为了避免图片后续无法访问，建议上传一下 csdn 的图片到自己的图床（可以通过 obsidian 的插件快捷上传全文图片）\n\n3. 图片无法显示问题 3.1 解决：设置空 referrer 我们的博客网站向其他站点访问图片的时候，会发送一个 referrer 。有些站点是会 block 掉你的博客访问的，比如 CSDN 的图片链接。\n这部分是我在设置  友链  的时候发现的，有些朋友给我的  头像链接  是 CSDN 的图片链接，但是设置完毕后头像图片不显示。\n包括你的  图床图片  不显示，也可能是因为 referrer 问题；比如我就发现我的阿里云 OSS 图片，在本地 HEXO S 的时候，博客中的图片无法加载\n\n解决办法参考这篇博客👉Hexo 博客不显示图床图片的解决方法\n\n具体操作是打开 HEXO主题  中包含全局网页 head 信息的文件（不同主题可能不一样，需要你找到主题的安装路径）keep 主题是hexo-theme-keep\\layout\\_partial\\head.ejs\n\n打开后在里面添加这个语句，设置 referrer 为空\n&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;\n\n\n设置完毕后，应该就可以正常访问图床图片和 CSDN 的图片外链了\n3.2 关于 oss 安全(CDN) 设置空 referrer 需要在 oss 的防盗链设置中开启 允许空 referrer，这能让用户  直接在浏览器中访问你的图片资源，某种意义上来说，是不安全的！\n但是关闭  允许空 referrer的功能，无法让 typora 显示出图片。这是因为 markdown 软件在请求的时候不会带上 referrer 的，本质上和直接用浏览器请求是一样的。\n所以，为了避免被人“一晚上抓走一套房”的 oss 流量盗用问题，建议为你的阿里云 oss 添加上 cdn（或者使用又拍云 oss 作为图床，又拍云的 oss 自带访问控制）\n\n以又拍云 cdn 为例，在 cdn 设置里面，可以配置访问控制\n\n这里有如下一些配置项，注释里面说明了它们对应的作用\nIP 黑白名单 # 白名单：允许的 ip, 黑名单：不允许的 ip# 如果发现某一个 ip 的请求次数过多，有恶意请求嫌疑，可以暂时将这个 ip 设置为黑名单 CORS 跨域共享 # 参考 http://ruanyifeng.com/blog/2016/04/cors.html 地区访问限制 # 禁止或允许特定地区的限制 Referer 防盗链 # 重点，建议开启白名单，只将自己的域名添加到白名单中（建议开启）User-Agent 防盗链 # 限制只有某种类型的客户端、浏览器可以访问资源Token 防盗链 # 有些麻烦，请自行了解。对于静态博客而言，并不方便 回源鉴权 # 如果源站服务器有鉴权操作，可以在这里配置IP 访问限制 # 对单个 ip 的请求速率进行限制（建议开启）CC 防护 # 防护 cc 攻击WAF 保护 # Web Application Firewall\n\n对于 hexo 静态博客而言，建议配置 Referer 的防盗链，和 IP 的访问限制。同一个 ip 如果访问速率过高，直接禁止其访问。\n如果你的 hexo 站点是部署在自己的服务器上，cdn 还有一个非常棒的功能，那就是  隐藏你服务器  的真实 ip，避免被打\n4.ssh 免密部署hexo cl // 清除已有格式hexo g --d // 将更改更新 并 push 到 git 仓库\n\ngit 本地用命令行操作的时候，可能每一次 hexo g --d 操作都会让你输入一次账户和密码，我们只需要生成一个 SSH 公钥给 git 仓库，就能跳过这个操作\n\n具体生成操作可以查看这个博客👉如何使用 ssh 密钥配置 git\n\n在设置好后，记得把 hexo 的 _config 文件中的 https 链接更换为 ssh 链接！\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:musnow/musnows.github.io.git  branch: master\n\n\n\n4.1 关于 gitee 和 github 的优劣  咳咳，gitee的一些 ex 操作让我不得不换到了 github！而且说句实话，虽然 gitee 服务器在国内，其 gitee pages 的访问速度真不见得比 github 快多少\n\ngithub 无审查（光是这一点已经赢了😂）gitee 说我写的技术博客有问题，不给我部署。又不告诉用户问题在哪，只能是一脸懵逼😥\ngithub 在 hexo g --d 部署了之后能自动更新；gitee 还需要你自己点一下更新按钮，很烦\ngithub 可以免费绑定你自己的域名；gitee 只有企业版才行\n\nhexo 切换到 github 非常方便，在 github 中创建一个  用户名.github.io的仓库，将你的 hexo 中 _config.yml 的远端仓库路径一改，部署了之后，直接就能正常访问！\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:musnows/musnows.github.io.git  branch: master\n\n对事不对人，平台只是一个载体，分享技术才是重要的！\n4.2 netlifynetlify 的部署非常容易，其访问速度比 github pages 快多了！实测 netlify 的延迟只有 80ms，而 github pages 是 200ms\n\n部署参考🦋Hexo+Github+Netlify 部署个人博客\n\n最最最棒的一点是，netlify 的部署速度很快，几乎是你 hexo d 刚刚上传到仓库，没过几秒他就部署成功了！\n你可以主要使用netlify，将 github.io 作为镜像站；不过这样的话，评论系统可能会出现一些问题，要注意设置主站的 url，别把评论系统弄 boom 了！\n\n操作很简单，github 登陆后，选择你的 github 仓库\n\n再选择对应的分支，点击底部的deploy site，就大功告成了！\n\n等待这里出现 published 的字样，就可以访问你的站点了。域名在 domain settings 里面设置就 OK\n\n4.3 vercelvercel 同理，也是选择musnows.github.io，注意模板不能选择 hexo，否则会部署失败。\n模板选择 other，过一会就能部署成功；这样就相当于一个站点有 3 个备份了，完美！\n\n5. 关于 hexo 文内 toc 问题keep 模板已经自带了边栏 toc，可以在右上角打开\n\n实际上，我们可以通过 hexo-toc 插件实现类似 CSDN 和 typora 的  文章内 toc（这个功能很多 markdown 编辑器都不支持，比如 obsidian）\n\n\n文内 toc 插件安装参考了这篇知乎文章👉传送门\n\n在 git 里面输入以下命令\nnpm install hexo-toc --save\n\n插件安装完毕后，就可以在 md 文件的头部插入 &lt;!-- toc --&gt;  来生成目录（在 typora 和 csdn 中是 [TOC] 格式）\n但是这个插件有一个问题，就是无法和 keep 模板的  边栏 toc 同时使用。即使用了该插件后，边栏 toc 无法跳转，就只能二选一了。\n无奈只能  卸载  这个插件了，个人感觉还是  边栏 toc重要一点\nnpm remove hexo-toc --save\n\n6. 自定义首页文章预览内容 hexo 本身支持自定义文件预览格式，在 md 文件中添加&lt;!-- more --&gt; 就可以自定义文章预览显示的内容\n效果如下👇 建议不要在  需要预览的内容  中设置  标题，不然看起来会非常怪异\n\n7. 评论系统 7.1 Valine 评论系统后台如何查看评论 在配置好 Valine 评论系统后，可以在 leancloud 后台管理中看到评论的 html 源码。\n但默认的排序的问题是，看不到用户是在那一篇文章下面评论的。我们可以通过调整内容排序（右上角那个带  橙色圆点  的按钮），把 url 往前移动，这样就能更方便地看到是谁评论了自己的博客，以及评论文章的位置\n\n7.1.1 leancloud 邮箱提醒  你可以利用 valine 插件 admin 来实现邮箱提醒\n\nGithub 项目地址：DesertsP&#x2F;Valine-Admin\n\n但是这个插件需要你有一个  备案过的域名！！！！\n然后我就在 22-04-27 这天发现，其实我设置的邮箱提醒已经生效了！😂真是一波三折（然后又挂了，参看 7.2 😥）\n大家根据这篇博客的教程进行邮件提醒的配置就 OK 了！valine 评论系统使用\n\n7.1.2 关于云引擎 500 报错  本部分更新于 2023-01-05，今天 更新了博  客的 url 地址，然后就发现 leancloud 的  邮箱提醒  挂掉了，看后台会有一个这样的报错\n[2023-01-06T03:20:03.518063400Z][instance:web1] LeanEngine: /self_wake: 500: Error: undefined is not a valid uri or options object.[2023-01-06T03:20:03.518111500Z][instance:web1]     at request (/home/leanengine/app/node_modules/request/index.js:44:11)[2023-01-06T03:20:03.518117400Z][instance:web1]     at /home/leanengine/app/cloud.js:54:5[2023-01-06T03:20:03.518121000Z][instance:web1]     at /home/leanengine/app/node_modules/leanengine/lib/leanengine.js:202:14[2023-01-06T03:20:03.518124500Z][instance:web1]     at processTicksAndRejections (internal/process/task_queues.js:97:5)\n\n最终我百度到了这个 issue，里面提到的和我的情况一模一样： 邮件提醒报错，不知道为什么 Error: undefined is not a valid uri or options object. #138 \n简单说来，就是云引擎需要绑定域名\n而我最开始选择的 leadcould 是在  国内 ，域名必须要ipc 备案 才能正常绑定；如果需要用独立 IP，那还得额外掏钱，50 一个月实在是负担不起😥\n\n至于之前为啥邮箱提醒能用呢？我也不知道；我猜是 leancloud 最近更新了策略，就需要强制绑定才能用了……\n\n解决方法，使用国际版 leancloud！\n7.2 使用 Waline 评论系统  这部分可以参考Waline 的帮助文档，本站的评论系统也于 2023-01-06 从 valine 更换为了 waline，keep 版本3.4.5-&gt;3.5.2\n\nWaline.js.org\nkeep 使用 waline\n\n配置好了 vercel 的自定义的域名之后，就可以通过下面两个方式来快捷管理\n评论系统：example.yourdomain.com评论管理：example.yourdomain.com/ui\n\n下图为更新前的 valine 评论界面\n\n以下为更新后的 waline 界面，其支持上传图片！可惜默认只支持 128kb，暂时还没有找到修改该限制的办法；对于我来说，waline 最大的优势就是邮箱提醒功能可以很方便地用 vecel 的环境变量搞定，效果也很不错！\n\n7.2.1 自定义 waline 邮箱提醒模板\n参考👉waline 邮件通知模板样式一览\n\n为了避免源站无法访问，这里贴出当前我使用的邮件通知模板;\n注意，我是用 vercel 部署 的，所以只需要修改  环境变量  就行了。如果你是其他部署方式，请参考上面博客中的详细教程!\nMAIL_SUBJECT\n&#123;&#123;parent.nick | safe&#125;&#125;，您在『&#123;&#123;site.name | safe&#125;&#125;』上的评论收到了来自  &#123;&#123;self.nick | safe&#125;&#125; 的回复\n\nMAIL_SUBJECT_ADMIN\n『&#123;&#123;site.name | safe&#125;&#125;』 上有新评论了\n\nMAIL_TEMPLATE\n&lt;div style=&quot;border-radius: 10px 10px 10px 10px;font-size:14px;color: #555555;width: 666px;font-family:&#x27;Century Gothic&#x27;,&#x27;Trebuchet MS&#x27;,&#x27;Hiragino Sans GB&#x27;, 微软雅黑,&#x27;Microsoft Yahei&#x27;,Tahoma,Helvetica,Arial,&#x27;SimSun&#x27;,sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffffff repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);&quot;&gt;&lt;div style=&quot;width:100%;background:#49BDAD;color:#ffffff;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));background-image: -webkit-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;&quot;&gt;&lt;p style=&quot;font-size:15px;word-break:break-all;padding: 23px 32px;margin:0;background-color: hsla(0,0%,100%,.4);border-radius: 10px 10px 0 0;&quot;&gt;您在 &lt;a style=&quot;text-decoration:none;color: #ffffff;&quot; href=&quot;&#123;&#123;site.url&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123;site.name&#125;&#125;&lt;/a&gt; 上的留言有新回复啦！&lt;/p&gt;&lt;/div&gt;&lt;div style=&quot;margin:40px auto;width:90%&quot;&gt;&lt;p&gt;Hi, &#123;&#123;parent.nick&#125;&#125;，您曾在文章上发表评论：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;&#123;&#123;parent.comment | safe&#125;&#125;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;&#123;&#123;self.nick&#125;&#125;&lt;/strong&gt; 给您的回复如下：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;&#123;&#123;self.comment | safe&#125;&#125;&lt;/div&gt;&lt;p&gt;您可以点击 &lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;&#123;&#123;site.postUrl&#125;&#125;&quot; target=&quot;_blank&quot;&gt; 查看回复的完整內容 &lt;/a&gt;，欢迎再次光临&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;&#123;&#123;site.url&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123;site.name&#125;&#125;&lt;/a&gt;。&lt;hr /&gt;&lt;p style=&quot;font-size:12px;color:#b7adad&quot;&gt; 本邮件为系统自动发送，请勿直接回复邮件哦，可到博文内容回复。&lt;/p&gt;&lt;/p&gt;&lt;style type=&quot;text/css&quot;&gt;a:link&#123;text-decoration:none&#125;a:visited&#123;text-decoration:none&#125;a:hover&#123;text-decoration:none&#125;a:active&#123;text-decoration:none&#125;&lt;/style&gt;&lt;/div&gt;&lt;/div&gt;\n\nMAIL_TEMPLATE_ADMIN\n&lt;div style=&quot;background-image: url(https://npm.elemecdn.com/sarakale-assets@v1/Article/email/bg.jpg);;padding:20px 0px 20px;margin:0px;background-color:#ded8ca;width:100%;&quot;&gt;&lt;div style=&quot;background: url(https://npm.elemecdn.com/sarakale-assets@v1/Article/email/leisi-714x62.png) repeat-y scroll top;&quot;&gt;&lt;div style=&quot;border-radius: 10px 10px 10px 10px;font-size:14px;color: #555555;width: 666px;font-family:&#x27;Century Gothic&#x27;,&#x27;Trebuchet MS&#x27;,&#x27;Hiragino Sans GB&#x27;, 微软雅黑,&#x27;Microsoft Yahei&#x27;,Tahoma,Helvetica,Arial,&#x27;SimSun&#x27;,sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffe8dd61;box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);margin:auto&quot;&gt;&lt;img class=&quot;headerimg no-lightbox entered loaded&quot;src=&quot;https://npm.elemecdn.com/sarakale-assets@v1/bg/bg3.jpg&quot;style=&quot;width:100%;overflow:hidden;pointer-events:none&quot;data-ll-status=&quot;loaded&quot;&gt;&lt;div style=&quot;width:100%;color:#9d2850;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;background: url(https://npm.elemecdn.com/sarakale-assets@v1/Article/email/line034_666x66.png) left top no-repeat;&quot;&gt;&lt;p style=&quot;font-size:16px;font-weight: bold;text-align:center;word-break:break-all;padding: 23px 32px;margin:0;border-radius: 10px 10px 0 0;&quot;&gt;您在 &lt;a style=&quot;text-decoration:none;color: #9d2850;&quot;href=&quot;&#123;&#123;site.url&#125;&#125;&quot;target=&quot;_blank&quot;&gt;&#123;&#123;site.name&#125;&#125;&lt;/a&gt; 上的文章有了新的评论 &lt;/p&gt;&lt;/div&gt;&lt;div style=&quot;margin:40px auto;width:90%;&quot;&gt;&lt;p&gt;&lt;strong&gt;&#123;&#123;self.nick&#125;&#125;&lt;/strong&gt; 回复说：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:15px;color:#555555;&quot;&gt;&#123;&#123;self.comment|safe&#125;&#125;&lt;/div&gt;&lt;p&gt;您可以点击 &lt;a style=&quot;text-decoration:none; color:#cf5c83&quot;href=&quot;&#123;&#123;site.postUrl&#125;&#125;&quot;target=&quot;_blank&quot;&gt; 查看回复的完整內容&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n\n7.2.2 163 邮箱自定义发件人名字  这里需要注意，官方给出了两个自定义  邮箱发件人  和发件邮箱  的环境变量，其对于网易的 163 和 126 邮箱来说，你必须要设置成你的  登录邮箱  才可以，否则会报错，没办法发送邮箱\nSENDER_EMAIL 用来自定义发件邮箱，但是网易邮箱不支持SENDER_NAME  自定义发件人\n\n而且还有一点，就是这两个环境变量需要都加上，邮箱自定义发件人才能生效；\n如果你只设置了 SENDER_NAME 环境变量，而没有设置 SENDER_EMAIL，那么发件人是不会生效的，此时发件人会是你的邮箱，很难看；\n\n7.2.3 强制用户填写昵称和邮箱  在 waline 的组件里面，可以配置用户必须填写的信息。比如为了让我对用户的回复能通过邮箱提醒到对方，我需要开启强制用户填写邮箱的功能\n\nhttps://waline.js.org/reference/client/props.html#requiredmeta\n\n如果你用的 hexo 主题有对这一项进行定制化，那就可以直接在主题配置文件里面加上（具体请参考你所用 hexo 主题的文档）\nkeep 主题并没有对此项进行配置，修改配置文件是没有用的。需要我们修改源码\nthemes/keep/layout/_partial/comment/waline.ejs\n\n找到下面的部分（第 37 行左右）\nWaline.init(&#123;    el: &#x27;#waline-comment&#x27;,    serverURL: &#x27;&lt;%= waline_env_server_url %&gt;&#x27;,    lang: &#x27;&lt;%= config.language %&gt;&#x27; || &#x27;zh-CN&#x27;,    comment: &#x27;.post-comments-count&#x27;,    reaction: &#x27;&lt;%= waline_reaction %&gt;&#x27; === &#x27;true&#x27; &#125;)\n\n在最后加上\nrequiredMeta: [&#x27;nick&#x27;,&#x27;mail&#x27;]\n\n添加之后的完整代码如下\nWaline.init(&#123;    el: &#x27;#waline-comment&#x27;,    serverURL: &#x27;&lt;%= waline_env_server_url %&gt;&#x27;,    lang: &#x27;&lt;%= config.language %&gt;&#x27; || &#x27;zh-CN&#x27;,    comment: &#x27;.post-comments-count&#x27;,    reaction: &#x27;&lt;%= waline_reaction %&gt;&#x27; === &#x27;true&#x27;,    requiredMeta: [&#x27;nick&#x27;,&#x27;mail&#x27;] &#125;)\n\n此时，用户想评论的时候，就必须填写昵称和邮箱了\n\n8. 部分 keep 魔改记录  目前本博客已经修改为 butterfly 主题。为了保证以下教程的可用性，我部署了一个不再更新的 keep 主题博客，大家可以查看该站点，参考 keep 主题魔改后的效果\nkeep-hexo.musnow.top\n\n突出的就是一个可持续性发展👻\n8.0 开始  除了本文第一点里面  提到的  魔改 keep 参考教程 ，我还修改了其他一些内容，并对keep v3.5.2 更新了的配置文件进行说明；以下是各个框的标号\n\n\n以下是不同框对应的配置文件路径和对应的类，帮助你找到他们的配置文件路径；更详细的介绍参考 hexo-keep 首页样式自定义\n1  Hexo\\themes\\keep\\source\\css\\layout\\_partial\\header.styl   .header-wrapper &#123;&#125;2  Hexo\\themes\\keep\\source\\css\\layout\\page.styl   .page-container &#123;&#125;3  Hexo\\themes\\keep\\source\\css\\layout\\_partial\\first-screen.styl   .description &#123;&#125;4  Hexo\\themes\\keep\\source\\css\\layout\\_partial\\first-screen.styl   .s-icon-list &#123;&#125;5  Hexo\\themes\\keep\\source\\css\\layout\\page.styl   .page-main-content &#123;&#125;6  Hexo\\themes\\keep\\source\\css\\layout\\home-content.styl   .home-content-container &#123;&#125;7  Hexo\\themes\\keep\\source\\css\\layout\\home-content.styl   .home-article-item &#123;&#125;\n\n版本基于KEEP V3.5.2，基本兼容V3.6.1，如果你发现配置文件位置有变动，请在下方留言告知。\n备注：keep 不支持深层次的自定义页面，所有的修改都是针对 npm 包进行的，会在你更新 keep 的时候丢失！所以想折腾，建议做好不再更新 keep 的准备哦（除非你愿意每次都改一遍）🤣\n\nblog&#x2F;node_modules&#x2F;hexo-theme-keep\n\n如果觉得本站修改过后的样式很不错，那可以去我的 Github 仓库，直接把 keep 的模组下载后放到你的本地就可以了；这样就只需要修改 keep/source/css/layout/page.styl里面的两个背景图 url 就可以了！\n\n8.1 雪花飘飘  我的主页有飘动的雪花，想知道怎么弄的？那就往下看吧！\n\n雪花代码来自博客👉hexo+next 添加雪花飘落背景效果\n\n在 Hexo-themes-keep\\source\\js 下新建文件snow.js\n/* 样式二 *//* 控制下雪 */function snowFall(snow) &#123;    /* 可配置属性 */    snow = snow || &#123;&#125;;    this.maxFlake = snow.maxFlake || 200; /* 最多片数 */    this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */    this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.msRequestAnimationFrame ||    window.oRequestAnimationFrame ||    function (callback) &#123;        setTimeout(callback, 1000 / 60);    &#125;;cancelAnimationFrame = window.cancelAnimationFrame ||    window.mozCancelAnimationFrame ||    window.webkitCancelAnimationFrame ||    window.msCancelAnimationFrame ||    window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function () &#123;    /* 创建画布 */    snowCanvas.apply(this);    /* 创建雪花形状 */    createFlakes.apply(this);    /* 画雪 */    drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123;    /* 添加 Dom 结点 */    var snowcanvas = document.createElement(&quot;canvas&quot;);    snowcanvas.id = &quot;snowfall&quot;;    snowcanvas.width = window.innerWidth;    snowcanvas.height = document.body.clientHeight;    snowcanvas.setAttribute(&quot;style&quot;, &quot;position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;&quot;);    document.getElementsByTagName(&quot;body&quot;)[0].appendChild(snowcanvas);    this.canvas = snowcanvas;    this.ctx = snowcanvas.getContext(&quot;2d&quot;);    /* 窗口大小改变的处理 */    window.onresize = function () &#123;        snowcanvas.width = window.innerWidth;        /* snowcanvas.height = window.innerHeight */    &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123;    this.x = Math.floor(Math.random() * canvasWidth); /* x 坐标 */    this.y = Math.floor(Math.random() * canvasHeight); /* y 坐标 */    this.size = Math.random() * flakeSize + 2; /* 形状 */    this.maxSize = flakeSize; /* 最大形状 */    this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */    this.fallSpeed = fallSpeed; /* 坠落速度 */    this.velY = this.speed; /* Y 方向速度 */    this.velX = 0; /* X 方向速度 */    this.stepSize = Math.random() / 30; /* 步长 */    this.step = 0 /* 步数 */&#125;flakeMove.prototype.update = function () &#123;    var x = this.x,        y = this.y;    /* 左右摆动(余弦) */    this.velX *= 0.98;    if (this.velY &lt;= this.speed) &#123;        this.velY = this.speed    &#125;    this.velX += Math.cos(this.step += .05) * this.stepSize;    this.y += this.velY;    this.x += this.velX;    /* 飞出边界的处理 */    if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123;        this.reset(canvas.width, canvas.height)    &#125;&#125;;/* 飞出边界 - 放置最顶端继续坠落 */flakeMove.prototype.reset = function (width, height) &#123;    this.x = Math.floor(Math.random() * width);    this.y = 0;    this.size = Math.random() * this.maxSize + 2;    this.speed = Math.random() * 1 + this.fallSpeed;    this.velY = this.speed;    this.velX = 0;&#125;;// 渲染雪花 - 随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function (ctx) &#123;    var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);    snowFlake.addColorStop(0, &quot;rgba(255, 255, 255, 0.9)&quot;); /* 此处是雪花颜色，默认是白色 */    snowFlake.addColorStop(.5, &quot;rgba(255, 255, 255, 0.5)&quot;); /* 若要改为其他颜色，请自行查 */    snowFlake.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;); /* 找 16 进制的 RGB 颜色代码。 */    ctx.save();    ctx.fillStyle = snowFlake;    ctx.beginPath();    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);    ctx.fill();    ctx.restore();&#125;;/* 创建雪花 - 定义形状 */function createFlakes() &#123;    var maxFlake = this.maxFlake,        flakes = this.flakes = [],        canvas = this.canvas;    for (var i = 0; i &lt; maxFlake; i++) &#123;        flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed))    &#125;&#125;/* 画雪 */function drawSnow() &#123;    var maxFlake = this.maxFlake,        flakes = this.flakes;    ctx = this.ctx, canvas = this.canvas, that = this;    /* 清空雪花 */    ctx.clearRect(0, 0, canvas.width, canvas.height);    for (var e = 0; e &lt; maxFlake; e++) &#123;        flakes[e].update();        flakes[e].render(ctx);    &#125;    /*  一帧一帧的画 */    this.loop = requestAnimationFrame(function () &#123;        drawSnow.apply(that);    &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;    maxFlake: 60&#125;);snow.start();\n\n添加完成后，在 hexo-theme-keep\\layout\\layout.ejs 中添加如下引用\n&lt;script type = &quot;text/javascript&quot; src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;\n\n添加完成后的 layout.ejs 文件示例如下\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&lt;%= config.language %&gt;&quot;&gt;&lt;%- partial(&#x27;_partial/head&#x27;) %&gt;&lt;body&gt;&lt;%- body %&gt;&lt;%- partial(&#x27;_partial/scripts&#x27;) %&gt;&lt;script type = &quot;text/javascript&quot; src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n重新部署，就 OK 啦！\n8.2 首页描述字体的背景框和透明度  这里对应的是 3 号框的文字\n修改 hexo-theme-keep\\source\\css\\layout\\_partial\\first-screen.styl 中以下部分，有注释的地方就是我修改了的地方\n.description &#123;  /*color $first-screen-font-color*/  color: rgb(255 250 250) /* 字体颜色 */  font-weight bold  font-size $first-screen-font-size  line-height 1.8  text-align center  background: rgba(50,50,50,0.3); /* 字体背景颜色和透明的 */  padding: 3px 15px; /* 字体背景框的大小 */  border-radius: 5px; /* 圆角 */        .desc-item &#123;    /*color $first-screen-font-color*/    color: rgb(255 250 250) /* 字体颜色 */  &#125;  +keep-tablet() &#123;    font-size $first-screen-font-size * 0.9  &#125;&#125;\n\n修改了之后，首页居中的介绍文字就会变成当前的模样（之前的样式没有背景框，在自定义背景后很容易就看不清）\n\n同时我们还需要修改4 号框，给它添加一个能够让它看得清的背景框（图标颜色没有办法修改，只能修改背景框颜色）\n\n4 号框所在配置文件和 3 号框相同，找到 .s-icon-list 字段，添加以下内容\n.s-icon-list &#123;  background: rgba(220 220 220,0.3); /* 字体背景颜色和透明的 */  padding:4px 11px 4px 11px; /* 字体背景框的大小 */  border-radius: 5px; /* 圆角 */  ...   &#125;\n\n8.3 顶部字体加粗\nhexo 顶部底部透明度渐变\n\n参考这篇博客的 1-2, 修改 keep\\source\\css\\layout\\_partial\\header.styl\n找到以下代码\n.menu-item &#123;\tfloat: left;\tposition: relative;\tmargin-left: 30px;\tfont-size: 1rem;\tcursor: pointer;\tcolor: var(--default-text-color);\t......\n\n加一条font-weight: bold，修改结果：\n.menu-item &#123;\tfloat: left;\tposition: relative;\tmargin-left: 30px;\tfont-size: 1rem;\tfont-weight: bold;\tcursor: pointer;\tcolor: var(--default-text-color);\t......\n\n顶栏和底栏透明度渐变修改参考 8.5，我更新过后的方法可以让顶栏和底栏的透明度渐变随着明暗模式变化\n8.4 文章侧边栏 toc更新了之后的侧边栏变到了页面的右边，且默认下是没有背景的（因为默认在文章页面也是纯白的，没有背景也能看得清）\n但是当下我已经设置了全局背景，所以就需要修改一下！\nkeep 更新 3.5.2 之后的侧边栏配置文件变了, 现在是在 keep/source/css/layout/_partial/ 中的toc.styl\n.post-toc-wrap &#123;  position relative  box-sizing border-box  width 100%  height 100%  overflow-y auto  font-size 0.92rem  font-weight: bold /* 字体加粗 */  border-radius: 5px; /* 圆角 */  ...&#125;\n\n添加我注释了的这几项就 OK 了，如果你想要旧版样式（固定在左侧）可以尝试将 position 修改为fixed\n8.5 明暗模式适配  修改  完背景颜  色和背景图之后，就会出现下面的情况：如果有用户的电脑是暗色模式，进入博客的时候，就会发现字完全看不清，整个界面都很难看\n\n解决办法那就是需要让我们的背景颜色能根据  明暗  自动切换！\n我们要做的，就是在 hexo-theme-keep\\source\\css\\ 中添加一个 my 文件夹，并在内部添加一个 user-style.styl\n// 全局背景的的颜色切换.dark-mode&#123;    --content-background-color:#37383fe6;&#125;.light-mode&#123;    --content-background-color:#ffffffe6;&#125;// toc 栏大小.post-toc-wrap .post-toc .nav&#123;  padding:21px&#125;// 使 toc 能够更具明暗模式自动切换颜色.light-mode .post-toc-wrap &#123;    background-color: #ffffffe6;&#125;.dark-mode .post-toc-wrap &#123;    background-color: #37383fe6;&#125;// 顶部背景透明度渐变，明暗变化.light-mode .header-wrapper &#123;    background: linear-gradient(to bottom, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0.4));&#125;.dark-mode .header-wrapper &#123;    background: linear-gradient(to bottom, rgba(30, 30, 30, 1), rgba(30, 30, 30, 0.4));&#125;// 底部背景透明度渐变，明暗变化.light-mode .page-main-content-bottom &#123;  background: linear-gradient(to top, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4))/* 透明度设置 */&#125;.dark-mode .page-main-content-bottom &#123;  background: linear-gradient(to top, rgba(30, 30, 30, 0.9), rgba(30, 30, 30, 0.4));&#125;\n\n写完后，在 css/style.styl 中引用这个文件就可以了\n@import &quot;my/user-style.styl&quot;\n\n刚开始我用的办法太蠢了，浪费了好多时间，而且经常失效。后来请教了一位会前端的朋友，他一下就帮我搞定了，呜呜呜呜😫\n\n按照上面修改了  顶栏和底栏  样式后，请不要开启 keep 配置文件中的header_transparent，否则两个效果叠加，主页顶栏会变得有些难看\n# Set transparent background for header.header_transparent: false  # Option values: true | false\n\n8.6 页脚自定义8.6.1 添加站点运行时间2023-01-09 添加了站点运行时间，删除了 hexo 主题的提示。\n要想添加网站运行时间，keep 主题修改 keep/layout/_partial/footer.ejs，找到如下代码\n&lt;% if (f_upyun) &#123; %&gt;    &lt;div class=&quot;ypyun-info info-item&quot;&gt;        &lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;&lt;%= f_upyun %&gt;&quot;&gt;        &lt;%- __(&#x27;footer_upyun&#x27;, &#x27;&lt;img src=&quot;/images/upyun.png&quot; height=&quot;20&quot;&gt;&#x27;) %&gt;        &lt;/a&gt;    &lt;/div&gt;&lt;% &#125; %&gt;    \n\n在下方添加如下代码，来自👉hexo+yilia 添加网站运行时间\n源站的代码有点问题，详见该页面评论（有人指出，但作者没有更新正文）\n&lt;!-- 添加网站运行时间 --&gt;        &lt;% if (theme.running_time &amp;&amp; theme.running_time.enable &amp;&amp; theme.running_time.create_time) &#123; %&gt;            &lt;div class=&quot;timerun-info info-item&quot;&gt;                &lt;span id=&quot;timeDate&quot;&gt; 载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt; 载入时分秒...&lt;/span&gt;                &lt;script&gt;                var now = new Date();                function createtime() &#123;                    // 此处修改你的建站时间或者网站上线时间                    var create_time = &#x27;&lt;%- theme.running_time.create_time %&gt;&#x27;;                    var grt = new Date(create_time);                    now.setTime(now.getTime() + 250);                    days = (now - grt) / 1000 / 60 / 60 / 24;                    dnum = Math.floor(days);                    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);                    hnum = Math.floor(hours);                    if (String(hnum).length == 1) &#123;                        hnum = &quot;0&quot; + hnum;                    &#125;                    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);                    mnum = Math.floor(minutes);                    if (String(mnum).length == 1) &#123;                        mnum = &quot;0&quot; + mnum;                    &#125;                    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);                    snum = Math.round(seconds);                    if (String(snum).length == 1) &#123;                        snum = &quot;0&quot; + snum;                    &#125;                    document.getElementById(&quot;timeDate&quot;).innerHTML = &quot; 本站已安全运行 &quot; + dnum + &quot; 天 &quot;;                    document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒 &quot;;                &#125;                setInterval(&quot;createtime()&quot;, 250);                &lt;/script&gt;            &lt;/div&gt;        &lt;% &#125; %&gt;        &lt;!-- 添加网站运行时间 --&gt;\n\n这里修改完毕后，还需要在 keep 的配置文件里面添加下面这一项；如果后续不想要了，可以直接设置为 false 禁用这一栏\n# 网站运行时间，格式形如：“本站已安全运行 101 天 12 小时 13 分 41 秒”# Runing Timerunning_time:  enable: true  create_time: &#x27;01/01/2021 00:00:00&#x27; # 此处修改你的建站时间\n\n如果你想删除 hexo 的提示，那就注释掉 footer.ejs 的这些代码\n&lt;!-- 注释掉这里的代码，就可以取消底部的 hexo 标识 --&gt;&lt;!-- &lt;div class=&quot;theme-info info-item&quot;&gt;    &lt;%- __(&#x27;powered_by&#x27;, &#x27;&lt;a target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) %&gt;&amp;nbsp;|&amp;nbsp;&lt;%- __(&#x27;theme&#x27;) %&gt;&amp;nbsp;&lt;a class=&quot;theme-version&quot; target=&quot;_blank&quot; href=&quot;https://github.com/XPoet/hexo-theme-keep&quot;&gt;Keep v3.5.2&lt;/a&gt;&lt;/div&gt; --&gt;\n\n8.6.2 修改页脚内容到底部的距离  如图，这个页脚到底部的距离实在有点宽，弄得背景图都被挡住了好大一部分；对于强迫症来说，这谁受得了，改了！\n\n找到 hexo-theme-keep\\source\\css\\layout\\_partial 修改 footer.styl 的 padding-bottom\n.info-container &#123;  padding-bottom 1rem  text-align center&#125;\n\n默认是 1rem，这里我直接改成 0 看看是不是修改对地方了；hexo s 一看，直接靠底了，说明我们改对地方了！\n\n随后我就修改成了 0.3rem，还是需要留一点边距的\n8.6.3 修改页脚字体颜色\n配置了背景图之后，页脚的字体颜色不那么容易看清楚，这时候应该怎么办？改他丫的！\n在浏览器按 F12 进入开发者模式，用截图软件（qq 截图或者 sanipaste）选取到这个框上，就能看到颜色的色值\n\n复制该色值，在 F12 所打开的开发者面板中的页面一栏，粘贴搜索，可以看到 --text-color-4 正好就对应了这个颜色\n\n改成黑夜模式，重复上述步骤，可以看到，此时颜色依旧对应的是 --text-color-4 那么就实锤了该变量即为页脚字体颜色的变量\n\n直接在 8.5 中配置好的 user-style.styl 里面添加，自定义一个颜色；我们的需求是让黑夜模式的字体更亮，白天模式的字体更黑\n.dark-mode&#123;    --content-background-color:#37383fe6;    --text-color-4:\t#F5F5F5; // 黑夜模式底部字体颜色&#125;.light-mode&#123;    --content-background-color:#ffffffe6;    --text-color-4: #242424; // 白天模式底部字体颜色&#125;//...\n\n大功告成！\n\n8.6.4 页脚添加 shields.io 的图标  为了更好的展示一部分内容，我们可以在页脚加上一些图标，并让这些图标可以点击跳转到指定页面！\n\nhttps://shields.io/\n\n修改 hexo-theme-keep\\source\\css\\layout\\_partial\\footer.ejs，在中间部分添加如下代码（直接跟在 8.6.1 配置的站点运行时间之后）\n如果你不知道具体的位置，还请移步我的 Github 仓库 查看更改后的文件\n&lt;div class=&quot;shields-info info-item&quot;&gt;\t&lt;a href=&quot;link for click&quot; &gt;        &lt;img src=&quot;img url&quot; height=&quot;20px&quot;&gt;     &lt;/a&gt;&lt;/div&gt;\n\n这里的 href 后跟随的是点击图标会跳转的网页，img src后面跟随的是图片的 url；\n\n比如我这样配置了之后，页脚就会出现一个这样的图标，用于标识我的 hexo 主题版本\n\n点击这个图标，会跳转到keep 主题的 Github 仓库；\n\n为了方便配置，写成下面的循环 +if 判断的形式；并且将图标的搞定锁定为 20px，避免不同图标大小导致不统一，很难看\n&lt;!-- 添加底部的 shields io 图片 --&gt;      &lt;% if (theme.shields &amp;&amp; theme.shields.enable) &#123; %&gt;          &lt;div class=&quot;shields-info info-item&quot;&gt;              &lt;% for (var i in theme.shields.data)&#123; %&gt;                  &lt;% if (theme.shields.data[i].img) &#123; %&gt;                      &lt;a href=&quot;&lt;%= theme.shields.data[i].link%&gt;&quot; &gt;                          &lt;img src=&quot;&lt;%= theme.shields.data[i].img%&gt;&quot; height=&quot;20px&quot;&gt;                      &lt;/a&gt;                  &lt;% &#125; %&gt;              &lt;% &#125; %&gt;          &lt;/div&gt;      &lt;% &#125; %&gt;\n\n这样就可以直接在配置文件中添加新的图标和 url，不需要来这里修改源码了！😁\n转到我们 keep.yml 配置文件，在最底部添加如下代码\n# Add shields.io in footershields:  enable: true # Option values: true | false  data:    hexo:      link: https://github.com/XPoet/hexo-theme-keep      img: https://img.shields.io/badge/hexo-keep%20v3.5.2-brightgreen\n\n这样就能在底部添加一个上面提到过的 hexo 主题图标\n要想追加，那就继续在后面以相同格式填写\n# Add shields.io in footershields:  enable: true # Option values: true | false  data:    hexo:      link: https://github.com/XPoet/hexo-theme-keep      img: https://img.shields.io/badge/hexo-keep%20v3.5.2-brightgreen    travelling:      link: https://www.travellings.cn/go.html      img: https://img.musnow.top/i/2023/05/647563ddab0fb.gif\n\n代码会自动判断 img 是否为空，如果 img 为空，则不会添加该模块；link 项可以为空，此时点击图标不会跳转到其他页面。\n效果还是不错哒！您可以在本页页脚查看😶‍🌫️\n8.7 点击头像跳转关于页面  这个操作就是把  没有多少人看  的关于  页面给藏起来，这样就不需要占用顶栏的一个 menu 了\n修改方法很简单，在 keep 主题中，默认点击头像的操作是跳转到当前页面（可以理解为啥都不做）\n我们只需要把链接改成跳转到关于页面就行了！\nthemes/keep/layout/_partial/header.ejs\n\n修改以下字段\n&lt;% if (s_logo || bi_logo_img) &#123; %&gt;    &lt;a class=&quot;logo-image&quot; href=&quot;/&quot;&gt;        &lt;%- image_tag(s_logo || bi_logo_img) %&gt;    &lt;/a&gt;&lt;% &#125; %&gt;\n\n修改之后\n&lt;% if (s_logo || bi_logo_img) &#123; %&gt;    &lt;a class=&quot;logo-image&quot; href=&quot;/about/&quot;&gt;        &lt;%- image_tag(s_logo || bi_logo_img) %&gt;    &lt;/a&gt;&lt;% &#125; %&gt;\n\n如果你想让点击网站标题也跳转到关于页面，那就把下面的 logo-title 也给改掉\n&lt;a class=&quot;logo-title&quot; href=&quot;/about/&quot;&gt;   &lt;%= bi_title || config_title || &#x27;Keep Theme&#x27; %&gt;&lt;/a&gt;\n\n随后进入 keep 的 config 文件，注释掉 memu 中的 about 页面，这并不代表 about 页面会被删除，只是不显示在 menu 上\nmenu:  Home: /  Archives: /archives  Categories: /categories  Tags: /tags  留言: /qa  Links: /links  #About: /about\n\n搞定！\n未完待续…期待后续的更新，亦或者是我能从折腾中走出来，别再瞎搞了……\n今天的升级部署就花了几乎一整天的时间😥\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【Python】解决 SSL certificate problem unable to get local issuer certificate","url":"/posts/3348986841/","content":"CentOS8 出现 SSL certificate problem: unable to get local issuer certificate 解决办法\n\n\n我想直接看解决办法\n1. 错误来源  我在一个 docker 安装的 Centos8.5 系统中启动我自己写的 kook 机器人时，遇到了下面的 bug\n\n其大概意思是没有办法获取到本地的issuer certificate。如果你知道证书和 CA 的含义，那么大概能猜到这个报错是什么意思。\n\n所有站点的 ssl 证书，都需要经过 CA 机构的认证和颁发。操作系统会默认  内嵌  已有 CA 机构的公钥，以用于解密 CA 颁发的证书中的数字签名。\n\n因为 CA 机构是内嵌在操作系统本地的，如果一个证书的颁发机构不在本地已有 CA 中，该站点就会被报不安全。\n而无法获取本地issuer certificate，我猜测意思就是没有办法获取道操作系统内嵌的 CA\n2. 解决  刚开始我尝试过通过 python 的 ssl 模组取消证书验证、更新本地证书和 openssl，都没有解决这个问题。\n在 Kook 平台 khl.py 服务器的大佬帮助下，最终定位并解决了这个问题。\n2.1 更新本地 ca 包  先 yum install ca-certificates，已经装过的话那就是 yum update ca-certificates 如果不行再 pip3 install certifi\n操作完毕上面的步骤，发现本地已经安装了最新版本的 ca-certificates，python 也有安装certifi 包\n$ yum update ca-certificatesRepository extras is listed more than once in the configurationWarning: failed loading &#x27;/etc/yum.repos.d/epel.repo&#x27;, skipping.Last metadata expiration check: 8:42:37 ago on Thu 23 Feb 2023 03:09:14 PM UTC.Dependencies resolved.Nothing to do.Complete!$ pip3.10 install  certifiDefaulting to user installation because normal site-packages is not writeableRequirement already satisfied: certifi in ./.local/lib/python3.10/site-packages (2022.12.7)$ pip3.10 install  certifi -UDefaulting to user installation because normal site-packages is not writeableRequirement already satisfied: certifi in ./.local/lib/python3.10/site-packages (2022.12.7)\n\n2.2 查看本地主机的链接  于是尝试使用如下命令，看看主机是否能成功连接到kaiheila.cn(kookapp.cn) 并认证 ssl 证书\nopenssl s_client -connect www.kookapp.cn:443 -showcerts\n\n输出了如下的信息\ndepth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CAverify return:1depth=1 C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1verify return:1depth=0 CN = *.kookapp.cnverify return:1CONNECTED(00000003)---Certificate chain 0 s:CN = *.kookapp.cn   i:C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1-----BEGIN CERTIFICATE-----MIIHkTCCBXmgAwIBAgIQCUlurlf6m1VXsuISNqlT8DANBgkqhkiG9w0BAQsFADBcMQswCQYDVQQGEwJVUzEXMBUGA1UEChMORGlnaUNlcnQsIEluYy4xNDAyBgNVBAMTK1JhcGlkU1NMIEdsb2JhbCBUTFMgUlNBNDA5NiBTSEEyNTYgMjAyMiBDQTEwHhcNMjIwNjE1MDAwMDAwWhcNMjMwNjE1MjM1OTU5WjAXMRUwEwYDVQQDDAwqLmtvb2thcHAuY24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDB1uHkQ/oEkGNloVa6wHz424VznxL+eUt6AAfNhtIXeone8rtnJqeoDJ24lmBYUrL00tChCp4rdTddcrqPppDYSEY7+/U0hf39pDrmsGKZeeOu7JvANjtvqLFdXsqe5CnXtxAo5QUXB9gckttoLTZZX5O1Gyi6mqDtsFCTaVpsQmZWVcbA21zLAdAZJyUyzM2VyfCUPQHs+VFErcmA9SN8nkppLyf00lIHCWR6v9HYC2XgjHN2JX8ARJwTEddhHjvleMc/SlHncU6fpZ8itWx8NzBL6MwPKEjmHgKp0VYBMY6PHrSR/j/XtgOweodp1JBIr6yLLlyCu/lJksCwMUIZAgMBAAGjggOSMIIDjjAfBgNVHSMEGDAWgBTwnIX9op99j8lou9XUiU0dvtOQ/zAdBgNVHQ4EFgQUYe6lb4/s4J82aqWfNDaev2MD8k4wIwYDVR0RBBwwGoIMKi5rb29rYXBwLmNuggprb29rYXBwLmNuMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwgZ8GA1UdHwSBlzCBlDBIoEagRIZCaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL1JhcGlkU1NMR2xvYmFsVExTUlNBNDA5NlNIQTI1NjIwMjJDQTEuY3JsMEigRqBEhkJodHRwOi8vY3JsNC5kaWdpY2VydC5jb20vUmFwaWRTU0xHbG9iYWxUTFNSU0E0MDk2U0hBMjU2MjAyMkNBMS5jcmwwPgYDVR0gBDcwNTAzBgZngQwBAgEwKTAnBggrBgEFBQcCARYbaHR0cDovL3d3dy5kaWdpY2VydC5jb20vQ1BTMIGHBggrBgEFBQcBAQR7MHkwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBRBggrBgEFBQcwAoZFaHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL1JhcGlkU1NMR2xvYmFsVExTUlNBNDA5NlNIQTI1NjIwMjJDQTEuY3J0MAkGA1UdEwQCMAAwggF/BgorBgEEAdZ5AgQCBIIBbwSCAWsBaQB3AOg+0No+9QY1MudXKLyJa8kD08vREWvs62nhd31tBr1uAAABgWbUskcAAAQDAEgwRgIhAL1qZKig2NqYtlAVnaXtJ7Tk+OuROrPHGR8t2zyNTb6xAiEAsLL5yuvJ/WtIj0bLwbKR0/nFe/Juub3aZjrNvUhzZIIAdQA1zxkbv7FsV78PrUxtQsu7ticgJlHqP+Eq76gDwzvWTAAAAYFm1LJ6AAAEAwBGMEQCIDK3qkxuTUB1Dngycy9/LECyVXjlpi2eJBAC6oZPJQ/VAiBs1iupiYwavmD2m6QrDzzZrW2MJWx4LMxCtvf6pmN3NwB3ALc++yTfnE26dfI5xbpY9Gxd/ELPep81xJ4dCYEl7bSZAAABgWbUsnkAAAQDAEgwRgIhAL5vfkeeQAwowpkUhf0U/Z2fFiL8IY+QsCyED40zw0d1AiEA02UjHM3tztsrMn2xyzmTkVgXnly/OozP+LjdwdsTa6gwDQYJKoZIhvcNAQELBQADggIBAGdBom7y2NXOZL7KxtZFBFQCBJrEQOHZvuN4Etkmotb+0aVnrEZ/Qc5+zl86YqURcmOZgPhzSjuVfTvUsJJ1TkC/tMYofoo1Db7B5yRxQmjEYRNLFAZ8rbP/pd5Js8ZGWW7RcxqG+zebqDDD2CWvpiJNStu/yjWwdsFXQUwU0XOGUfwJDHD0eSBaa3uclAn3kUqF82l2X9qzvy9EexGjPOSWyNuksjeScr32OyNUrwo7RUYJU4Ztl8xaiaxcvg7u2/o9WWzPhHMVI6ijrJbj6Wn+BMe3SMYcR/L+foItjWAuOqOVB7IKO32JgCkP1vyl8AWs0up8ddI/9jn3px8ii0HphKJnkCPZNmLnnOhFXQjoPy2PRmKqusP0kleJw1ZpQXsQpm3yZqFggyFH8S4ii83kkHBynC89dlwlBIkF29Ds4mYjau6mZZxE69By7ptvFvcYREYslaRMxd166PEf5mp5jBKSiI2iYcP8PQOudhObpkuw+KHz8ntkf++HeluuEiqsKyiyyiXm5dmRE/9uIUjPcQia5ohs2VpAgOLhLG6yphWCHQ6awFj9q3Ce1Mm5yXyZFvLXWGwoJj6jCVXAZDchwX4uiHW2fI3GHz1pTPg0L3NE/M2CHnQWJlh9cgOljmaZXCeKmLdA9phD+NQho5xVElRiF+rijlrkMutS7p1Y-----END CERTIFICATE----- 1 s:C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1   i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CA-----BEGIN CERTIFICATE-----MIIFyzCCBLOgAwIBAgIQCgWbJfVLPYeUzGYxR3U4ozANBgkqhkiG9w0BAQsFADBhMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBDQTAeFw0yMjA1MDQwMDAwMDBaFw0zMTExMDkyMzU5NTlaMFwxCzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjE0MDIGA1UEAxMrUmFwaWRTU0wgR2xvYmFsIFRMUyBSU0E0MDk2IFNIQTI1NiAyMDIyIENBMTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKY5PJhwCX2UyBb1nelu9APen53D5+C40T+BOZfSFaB0v0WJM3BGMsuiHZX2IHtwnjUhLL25d8tgLASaUNHCBNKKUlUGRXGztuDIeXb48d64k7Gk7u7mMRSrj+yuLSWOKnK6OGKe9+s6oaVIjHXY+QX8p2I2S3uew0bW3BFpkeArLBCU25iqeaoLEOGIa09DVojd3qc/RKqr4P11173R+7Ub05YYhuIcSv8e0d7qN1sO1+lfoNMVfV9WcqPABmOasNJ+ol0hAC2PTgRLy/VZo1L0HRMr6j8cbR7q0nKwdbn4Ar+ZMgCgCcG9zCMFsuXYl/rqobiyV+8U37dDScAebZTIF/xPEvHcmGi3xxH6g+dTCjetOjJx8sdXUHKXGXC9ka33q7EzQIYlZISF7EkbT5dZHsO2DOMVLBdP1N1oUp0/1f6fc8uTDduELoKBRzTTZ6OOBVHeZyFZMMdi6tA5s/jxmb74lqH1+jQ6nTU2/MmahGNxUuJpyhUHezgBA6sto5lNeyqc+3Cr5ehFQzUuwNsJaWbDdQk1v7lqRaqOlYjniomOl36J5txTs0wL7etCeMRfyPsmc+8HmH77IYVMUOcPJb+0gNuSmAkvf5QXbgPIZursn/UYnP9obhNbHc/9LYdQkB7CXyX9mPexnDNO7pggNA2jpbEarLmZGi4grMmfAgMBAAGjggGCMIIBfjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTwnIX9op99j8lou9XUiU0dvtOQ/zAfBgNVHSMEGDAWgBQD3lA1VtFMu2bwo+IbG8OXsj3RVTAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMHYGCCsGAQUFBwEBBGowaDAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNlcnQuY29tMEAGCCsGAQUFBzAChjRodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20vRGlnaUNlcnRHbG9iYWxSb290Q0EuY3J0MEIGA1UdHwQ7MDkwN6A1oDOGMWh0dHA6Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydEdsb2JhbFJvb3RDQS5jcmwwPQYDVR0gBDYwNDALBglghkgBhv1sAgEwBwYFZ4EMAQEwCAYGZ4EMAQIBMAgGBmeBDAECAjAIBgZngQwBAgMwDQYJKoZIhvcNAQELBQADggEBAAfjh/s1f5dDdfm0sNm74/dWMbbsxfYV1LoTpFt+3MSUWvSbiPQfUkoV57b5rutRJvnPP9mSlpFwcZ3e1nSUbi2oITGA7RCOj23I1F4zk0YJm42qAwJIqOVenR3XtyQ2VR82qhC6xslxtNf7f2Ndx2G7Mem4wpFhyPDT2P6UJ2MnrD+FC//ZKH5/ERo96ghz8VqNlmL5RXo8Ks9rMr/Ad9xwY4hyRvAz5920myUffwdUqc0SvPlFnahsZg15uT5HkK48tHR0TLuLH8aRpzh4KJ/Yp0sARNb+9i1R4Fg5zPNvHs2BbIve0vkwxAy+R4727qYzl3027w9jEFC6HMXRaDc=-----END CERTIFICATE--------Server certificatesubject=CN = *.kookapp.cnissuer=C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1---No client certificate CA names sentPeer signing digest: SHA256Peer signature type: RSA-PSSServer Temp Key: X25519, 253 bits---SSL handshake has read 3993 bytes and written 392 bytesVerification: OK---New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384Server public key is 2048 bitSecure Renegotiation IS NOT supportedCompression: NONEExpansion: NONENo ALPN negotiatedEarly data was not sentVerify return code: 0 (ok)---\n\n在这里面能看到如下内容\nSSL handshake has read 3993 bytes and written 392 bytesVerification: OK\n\n也就是说，我们的本地主机是能成功认证 kookapp.cn 的 ssl 证书的，那么问题就出现在 python 的 ssl 模块中了！\n2.3 检测 python 的 ssl 模块python 开启一个 REPL，输入如下的两行代码\nimport sslssl.create_default_context().cert_store_stats()\n\n输出的内容如下\n&gt;&gt;&gt; import ssl&gt;&gt;&gt; ssl.create_default_context().cert_store_stats()&#123;&#x27;x509&#x27;: 0, &#x27;crl&#x27;: 0, &#x27;x509_ca&#x27;: 0&#125;\n\n这里就能看出来问题了，全都是 0！难怪说没有办法获取本地的 CA\n作为对比，一台  正常的windows11 电脑输出如下\n&gt;&gt;&gt; import ssl&gt;&gt;&gt; ssl.create_default_context().cert_store_stats()&#123;&#x27;x509&#x27;: 87, &#x27;crl&#x27;: 0, &#x27;x509_ca&#x27;: 84&#125;\n\n2.4 解决错误  找到了错  误，那就得想办法解决！\npython 开启一个 REPL，输入如下的两行代码\nimport sslssl.get_default_verify_paths()\n\n输出内容如下，这是本地 python 查找 ca 证书的位置\n&gt;&gt;&gt; import ssl&gt;&gt;&gt; ssl.get_default_verify_paths()DefaultVerifyPaths(cafile=None, capath=&#x27;/usr/local/openssl-1.1.1/ssl/certs&#x27;, openssl_cafile_env=&#x27;SSL_CERT_FILE&#x27;, openssl_cafile=&#x27;/usr/local/openssl-1.1.1/ssl/cert.pem&#x27;, openssl_capath_env=&#x27;SSL_CERT_DIR&#x27;, openssl_capath=&#x27;/usr/local/openssl-1.1.1/ssl/certs&#x27;)\n\n其中 /usr/local/openssl-1.1.1/ssl/cert.pem 中应该会保存 CA 的信息\n查看本地的这个文件的内容\nls /usr/local/openssl-1.1.1/ssl/cert.pem\n\n好家伙，发现文件压根不存在！\nls: cannot access &#x27;/usr/local/openssl-1.1.1/ssl/cert.pem&#x27;: No such file or directory\n\n看看 openssl 的版本和路径\nopenssl  version -d\n\n输出如下\nOPENSSLDIR: &quot;/etc/pki/tls&quot;\n\n于是看看这个目录下有没有我们需要的cert.pem\n$ ls /etc/pki/tlscert.pem  certs  ct_log_list.cnf  misc  openssl.cnf  private\n\n有！那么接下来要做的，就是创建一个软连接，将其弄到 &#x2F;usr&#x2F;local 中！\nln -s /etc/pki/tls/cert.pem /usr/local/openssl-1.1.1/ssl/cert.pem\n\n3. 完美！做完这一切后，再次运行机器人，这次么有报错了！\n$ py3 main.py[FileManage] load all files[BOT] Start at: [23-02-24 00:25:29][BOT.TASK] fetch_public_channel success\n\n也成功响应了命令！\n\n似乎这个问题在 mac 下更常见？由于没有使用过 mac 设备，本文不解释相关内容\n\n\n","categories":["速通Python"],"tags":["Python","Kook","CentOS"]},{"title":"【Python】设置 logging 日志时间的时区","url":"/posts/1349268248/","content":"设置 logging 日志时间的时区\n\n\n1. 问题  最近我的几个 python-bot 项目都放在了 replit 上面白嫖运行，于是遇到了一个很让人头疼的问题。replit 的终端采用的是 UTC 标准时间，比北京时间晚了 8h，而我之前的项目，全都是用 print 来打印信息的（当时还不会用 logging）\n为了知道日志输出的时间，我在每一个 print 里面都调用了一个获取当前时间的函数\ndef getTime():    &quot;&quot;&quot; 获取当前时间，格式为 `23-01-01 00:00:00`&quot;&quot;&quot;    return time.strftime(&quot;%y-%m-%d %H:%M:%S&quot;, time.localtime())\n\n这个函数会返回系统的当前时间。对于 linux、windows 这些时区正确的机器而言，输出的都是北京时间，没有什么问题。\n\n如果你的 linux 机器（特别是用 docker 安装的）时区有问题，可以参考这篇文章来解决: 点我\n\n但是到 replit 上面就不一样了，即便你在 .replit 文件中添加了时区的环境变量，其依旧无法让 localtime 返回北京时间\nTZ = &quot;Asia/Shanghai&quot;\n\nshell 中输入 date 查看当前时间，依旧晚 8h\n\n我已经尝试过了，replit 这个并不能像 linux 修改时区 一样修改系统时间。\n我们就只能从 python 下手来解决这个问题了\n2. 解决  首先是 getTime 函数如和强制返回北京时间，我们需要将 time 改成使用 datetime\nfrom datetime import datetimefrom zoneinfo import ZoneInfo # 在 Py3.9 以后是标准库def getTime():    &quot;&quot;&quot; 获取当前时间，格式为 `23-01-01 00:00:00`&quot;&quot;&quot;    a = datetime.now(ZoneInfo(&#x27;Asia/Shanghai&#x27;)) # 返回北京时间    return a.strftime(&#x27;%y-%m-%d %H:%M:%S&#x27;)\n\n针对 logging 模块，也需要进行特殊处理\n\n参考 https://zhuanlan.zhihu.com/p/304672864\n\nlogging 模块中 asctime 的时间使用的是 time.localtime() 返回的时间 \n文档：library&#x2F;logging，library&#x2F;time\n而 time.localtime() 又是 ，使用的 time.time() 返回的时间，而 time.time() 返回的是 UTC 时间，即从 1970-1-1 00:00:00 到现在的秒数，由于时区不对，所以没有转成中国所在的 UTC+8 时区。\n经过 stackoverflow 上  这篇回答  的提醒，可以设定 logging.Formatter.converter 来转换时间，但是回答里是转换成 GMT 时间，我们需要自己重写一个函数来加上 UTC 偏移，返回正确的时间，传给 logging.Formatter.converter\n修改 logging.Formatter.converterimport loggingimport datetimedef beijing(sec, what):    beijing_time = datetime.datetime.now() + datetime.timedelta(hours=8)    return beijing_time.timetuple()logging.Formatter.converter = beijing# 只打印 info 以上的日志（debug 低于 info）logging.basicConfig(level=logging.INFO,                    format=&quot;[%(asctime)s] %(levelname)s:%(filename)s:%(funcName)s:%(lineno)d | %(message)s&quot;,                    datefmt=&quot;%y-%m-%d %H:%M:%S&quot;)\n\n还可以使用如下办法\nimport loggingfrom datetime import datetimefrom zoneinfo import ZoneInfodef beijing(sec, what):    beijing_time = datetime.now(ZoneInfo(&#x27;Asia/Shanghai&#x27;)) # 返回北京时间    return beijing_time.timetuple()# 日志时间改为北京时间logging.Formatter.converter = beijing\n\n两种办法都可以的！\n3. 验证  可以看到，修改之前，log 输出的时间离正确的时间差 8h\n\n修改了之后，输出的时间就对了！\n\n不过，修改这个也需要看你的项目  面向的对象  是谁。因为我写的都是 kook 平台的机器人，kook 作为国内平台，压根没有几个歪果仁用，所以直接修改，将程序里面所有需要涉及到  可读时间  的都指定为北京时间。\n如果你的项目是 discord 平台的机器人，那最好还是保留原状吧！\n需要注意的是，时区的设置  影响的是可读时间，即 23-03-24 20:14:48 这样的时间；和时间戳并没有关系。\n","categories":["速通Python"],"tags":["Python","Kook"]},{"title":"【Python】动手写一个 git 自动上传脚本！","url":"/posts/1095979040/","content":"本篇博客来教你用 Python 写一个简单的 git 自动上传脚本\n\n\n前言  为什么需要一个这样的东西？\n有的时候，我的学习代码其实没啥好 commit 的，写一个自动上传的脚本，就可以自动执行完所有的命令，而不需要自己手动进行 git 三板斧操作\n\n项目代码已开源  https://gitee.com/musnow/learn_python_code/tree/master/code/22-09-02%20auto_git\n\n效果如下  把 EXE 文件丢进你的 git 仓库路径，点一下就会自动执行命令\n\n\n打开你的仓库可以看到，成功上传了\n\n源码实现  其实很简单，就是用 OS 往系统的命令行里面写命令而已\nimport osimport timedef GetTime(): # 获取当前时间    return time.strftime(&quot;%y-%m-%d %H:%M:%S&quot;, time.localtime())# 修改默认的提交信息commit_msg=f&quot; \\&quot;Code updated: &#123;GetTime()&#125;\\&quot; &quot;#git 提交命令cmd_1 = &quot;git status&quot;cmd_2 = &quot;git add --all&quot;cmd_3 = &quot;git commit -m&quot;+commit_msgcmd_4 = &quot;git push&quot;print(&quot;[开始] 执行 git 自动上传 &quot;)print(&#x27;[CMD]&#x27;,cmd_1)os.system(cmd_1)# 显示当前动态print(&#x27;[CMD]&#x27;,cmd_2)os.system(cmd_2)# 添加所有文件更改到工作区print(&#x27;[CMD]&#x27;,cmd_3)os.system(cmd_3)# 自动 commitprint(&#x27;[CMD]&#x27;,cmd_4)os.system(cmd_4)#push 上传print(&quot;[结束] 完成 git 自动上传 &quot;)print(&quot; 窗口将在 5s 后关闭...&quot;)time.sleep(5)# 休眠 5 秒可以看清楚结果\n\n这里的 commit 信息非常粗暴，就是当前的时间。所以如果你是在写项目，那肯定还是好好写 commit 信息的好。不然到时候想回退版本都不知道往哪儿回退😂\n利用 pyinstaller 打包成 exe在 windows 命令行中，安装 pyinstaller 包\npip install pyinstaller\n\n安装完成之后，在命令行中输入pyinstaller，大概率会报错\nPS D:\\MyCode\\Python\\code\\22-09-02 auto_git&gt; pyinstallerpyinstaller : 无法将“pyinstaller”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再  试一次。所在位置 行:1 字符: 1+ pyinstaller+ ~~~~~~~~~~~    + CategoryInfo          : ObjectNotFound: (pyinstaller:String) [], CommandNotFoundException    + FullyQualifiedErrorId : CommandNotFoundException\n\n这时候如果你去搜教程，什么添加环境变量啊巴拉巴拉的，很麻烦，而且还不一定有用\n\n在我的 win11 上，添加环境变量就是无效的\n\n这时候我们只需要找到 python 的安装路径，和里面存放 pip 包的路径\n在我的电脑上，存放路径如下。如果你找不到，可以直接全盘搜索pyinstaller.exe\nC:\\Users\\ 用户名 \\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\Scripts\\pyinstaller.exe\n\n然后我们就可以直接执行下面的命令了\nC:\\Users\\ 用户名 \\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\Scripts\\pyinstaller.exe -F 文件名.py\n\n随后 pyinstaller 就会开始打包，并在当前路径下生成一个 build 和 dist 文件夹。其中 dist 文件夹里面就存放了我们的 exe 文件\n\n利用 ResourceHacker 修改 exe 文件的 icon实际上，pyinstaller是可以直接修改 exe 文件的 icon 的，命令如下\nC:\\Users\\ 用户名 \\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\Scripts\\pyinstaller.exe -F -w -i 图标.ico 文件名.py\n\n在我的电脑上，图标的确修改成功了，但是运行的时候，会多次弹出很多个命令行，非常不雅观！\n所以我就不用 pyinstaller 来生成图标，而是采用第三方软件 ResourceHacker（安装包自行百度）\n\n点击图标组里面的图标\n\n右键这个0:0，选择“替换图标”，找到你想要的图标进行替换即可\n图标只支持 .ico 文件，你可以用下面这个网站进行 jpg 转 ico\n\nhttp://www.ico51.cn/\n\n修改好后，需要点绿色的保存按钮。然后就修改成功了\n\n\n如果你发现没有修改成功，可能是因为 windows 缓存的问题，重启电脑即可！\n然后你就可以把这个 exe 丢到任何你想访到的 git 仓库路径下，自动上传文件啦！\n","categories":["速通Python"],"tags":["git","Python"]},{"title":"【Python】CentOS 安装 Python3.10 | 转载","url":"/posts/847195816/","content":"CentOS8 安装 Python3.10\n\n\n将所有命令里面 python 对应的版本号替换，就可以安装其他版本的 python\n1. 安装编译所需的依赖sudo yum -y updatesudo yum -y install openssl-devel libffi-devel bzip2-devel sqlite-develsudo yum -y groupinstall &quot;Development Tools&quot;\n\n考虑到本人需要安装 python 环境的一般都是台新机子，这里顺带给出几个常用软件包\nyum install gityum install vimyum install net-tools #netstat 命令\n\n顺便给出在 deepin 上的操作，除了安装包的命令不同，后续操作完全相同！（测试使用 deepin v23-beta 虚拟机）\nsudo apt-get updatesudo apt-get upgrade\n\nsudo apt install make build-essential libssl-dev zlib1g-devsudo apt install libbz2-dev libreadline-dev libsqlite3-dev wget curl llvmsudo apt install libncurses5-dev libncursesw5-dev xz-utils tk-dev\n\n\n2. 安装 Python 3.10 必需的 openssl &gt;&#x3D; 1.1.11.1.1q 发布于 2022-Oct-12 14:17:24 ，算是较新的版本了！\n\nhttps://www.openssl.org/source/old/1.1.1/\n\n# 下载wget https://www.openssl.org/source/openssl-1.1.1q.tar.gz --no-check-certificate# 解压tar zxf openssl-1.1.1q.tar.gz# 进入文件夹cd openssl-1.1.1q# 生成 makefilesudo ./config --prefix=/usr/local/openssl-1.1.1# 通过 make 安装sudo make &amp;&amp; sudo make install\n\n安装完毕这个之后，请检查环境变量中的 CA 证书是否正常，否则 python 运行时会报错。（主要是调用 api 时会报错）\nhttps://blog.musnow.top/posts/3348986841/\n目前我在 CentOS8 上安装此版本 openssl 时，python 必然出现此问题。建议依照上文检查，再往后执行 python 安装步骤；\n排查  将文章里面的解决步骤直接写在这里吧。安装好 openssl 后，执行如下命令，看看是否存在这个路径\nls /usr/local/openssl-1.1.1/ssl/cert.pem\n\n如果提示文件路径不存在，则执行如下命令\nln -s /etc/pki/tls/cert.pem /usr/local/openssl-1.1.1/ssl/cert.pem\n\n这样就能避免 python 导入 ssl 证书失败！\n\nPS: 如上操作在 centos7.2 和 centos8stream 中实测有效，其他系统无法保证有效！\n\n\ndeepin 安装的 python 出现了上文提到的 ssl 证书无法获取的问题，且目前暂时没有找到解决办法（解决办法和 centos 不同）\n以下是我在 deepin 虚拟机里面，用本文方案安装 python 后测试的结果：\n\npython3.10.5 出现此问题且未知修复办法\npython3.10.6 没有出现此问题\n\n\n3. 安装 Python 3.10# 下载wget https://www.python.org/ftp/python/3.10.5/Python-3.10.5.tgz# 解压tar zxf Python-3.10.5.tgz # 进入文件夹cd Python-3.10.5# 生成 makesudo ./configure --enable-optimizations --with-openssl=/usr/local/openssl-1.1.1 --with-openssl-rpath=auto --enable-loadable-sqlite-extensions# 安装sudo make altinstall\n\n如果官网安装慢，可以用如下连接下载对应版本\nwget https://registry.npmmirror.com/-/binary/python/3.10.6/Python-3.10.6.tgz\n\n\n慕雪的警告: 为了避免自己安装的 python 影响系统 yum 安装的使用，请不要将软连接直接连接成 python\n比如我们安装的是 python3.10.5，那软链接的时候，请链接python3.10 命令，而不是链接 python 命令！\n当前官方提供的 python3.10 安装包，会自动链接 python3.10 和pip3.10，理论上无需手动操作!\n\n\n原文  后半部分都是建立软连接的教程，为了避免引发误解，故此删除！\n版权声明：本文为 CSDN 博主「一_二」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/zltliqi/article/details/126449120\n\n","categories":["速通Python"],"tags":["Python","CentOS"]},{"title":"【Python】将 kook 机器人和爱发电对接，实现 vip 自动化销售","url":"/posts/2140431451/","content":"demo 开源地址 https://github.com/musnows/Kook-Afd-Webhook-Bot\n1. 简介  本文档主要讲解如何将 kook 机器人与爱发电的 webhook 功能进行对接\n\n商品以 vip 作为示例，提供一个基础的 python-demo\n\n主要流程如下\n\n机器人提供 vip 商城命令，用户执行，机器人发送一张包含不同价位 vip 价格和购买 url 的卡片给用户（临时消息，只有这个用户能看到）\n用户购买商品时，爱发电发送 webhook 给机器人\n机器人获取 webhook 信息中的custom_order_id，解析出用户 id 和购买天数，自动给对应用户上 vip\n\n相关文档\n\n机器人所用框架：github.com&#x2F;TWT233&#x2F;khl.py\n爱发电 webhook 接口文档：https://afdian.net/p/9c65d9cc617011ed81c352540025c377\n\n开始前，你需要先拥有自己的 kook-bot，并注册 爱发电，申请爱发电开发者权限\n\n如果你想使用 CDK（即兑换码）的方式来分发 vip，可以看看我的 Valorant-Shop-CN&#x2F;Kook-Valorant-Bot 项目\n\n2.python-demo2.1 webhook-api要想和爱发电的 api 对接，首先 bot 自己需要维护一个 webhook 的 api-url。这也要求你的机器人是部署在  可公网访问  的环境中，否则爱发电的 webhook 无法送达。\n\n爱发电开发者页面 https://afdian.net/dashboard/dev\n该 url 必须为 https 协议，所以你还需要绑定域名并配置 ssl\n\n同时，为了保证 webhook 中始终有 custom_order_id 字段，您需要告知您的用户，只能通过机器人生成的 url 来购买 vip。否则自动化流程将失效\n\n机器人收到爱发电 webhook\n解析 webhook 中的键值，获取到custom_order_id\n解析custom_order_id，获取到 kook 用户 id 和 vip 天数\n给用户添加上 vip 天数\n\ncustom_order_id=kook 用户id:vip 天数\n\n处理代码详见 api.py 和 apiHandler.py\n2.2 机器人  机器人命令如下\n\n\n\n命令\n说明\n\n\n\n&#x2F;shop\n获取购买 vip 的卡片\n\n\n&#x2F;vip\n看看自己 vip 剩余时长\n\n\n&#x2F;vip-l\n获取 vip 用户列表（会刷掉过期的 vip 用户）\n\n\n&#x2F;vip-test\n该命令只有 vip 用户才能执行，用于测试 vip 是否生效\n\n\n&#x2F;alive\n看看机器人活着不\n\n\n&#x2F;kill\n机器人下线，并保存文件\n\n\n代码详见 main.py\n2.2.1 vip 物品 url 获取  先创建你的 vip 店铺。爱发电的商品有  隐藏  功能，隐藏后的商品将不会显示在主页上，这样也能实现用户只能通过 bot 提供的链接来访问购买的操作\n\n\n这里我拿周 vip 和月 vip 作为示例\n\n点击商品，进入详情页，点击发电\n\n进入付款页面后，复制最上方的 url\n\nhttps://afdian.net/order/create?product_type=1&amp;plan_id=9aea871c304911ed8ec452540025c377&amp;sku=%5B%7B%22sku_id%22%3A%229aed6edc304911edbeb552540025c377%22,%22count%22%3A1%7D%5D\n\n我们要做的就是在这个 url 尾部添加上custom_order_id\n&amp;custom_order_id=kook 用户 id:vip 天数\n\n添加完毕后的链接如下\nhttps://afdian.net/order/create?product_type=1&amp;plan_id=9aea871c304911ed8ec452540025c377&amp;sku=%5B%7B%22sku_id%22%3A%229aed6edc304911edbeb552540025c377%22,%22count%22%3A1%7D%5D&amp;custom_order_id=kook 用户 id:vip 天数\n\n复制到浏览器，仍可正常访问，代表配置无误\n\n2.2.2 vip 物品 url 配置  找到 main.py 中的如下代码，将里面的 vip_item_link 替换成你自己的 url。如果需要添加更多商品，将两个 ---------- 中间的部分多复制几份即可\n@bot.command(name=&#x27;shop&#x27;,case_sensitive=False)async def shop_cmd(msg:Message,*arg):    logMsg(msg)    try:        cm = CardMessage()        c =Card(Module.Section(Element.Text(&quot; 欢迎选购机器人 Vip&quot;,Types.Text.KMD)))        # -------------        # vip 商品 1, 周 vip        vip_item_link1 = &quot;https://afdian.net/order/create?product_type=1&amp;plan_id=9aea871c304911ed8ec452540025c377&amp;sku=%5B%7B%22sku_id%22%3A%229aed6edc304911edbeb552540025c377%22,%22count%22%3A1%7D%5D&quot;        # 添加上自定义订单号的字符串        vip_item_link1+= f&quot;&amp;custom_order_id=&#123;msg.author_id&#125;:7&quot;        c.append(            Module.Section(                Element.Text(&quot; 周 vip&quot;, Types.Text.KMD),                Element.Button(&quot; 购买 &quot;, vip_item_link1, Types.Click.LINK)))        # -------------                # vip 商品 2, 月 vip        vip_item_link2 = &quot;https://afdian.net/order/create?product_type=1&amp;plan_id=ff2949022e9611ed89d452540025c377&amp;sku=%5B%7B%22sku_id%22%3A%22ff2bb4f82e9611ed83ac52540025c377%22,%22count%22%3A1%7D%5D&quot;        # 添加上自定义订单号的字符串        vip_item_link2+= f&quot;&amp;custom_order_id=&#123;msg.author_id&#125;:30&quot;        c.append(            Module.Section(                Element.Text(&quot; 月 vip&quot;, Types.Text.KMD),                Element.Button(&quot; 购买 &quot;, vip_item_link2, Types.Click.LINK)))                cm.append(c)        await msg.reply(cm,is_temp=True) # 临时消息，所以这个按钮只有当前用户可以点    except:        _log.exception(f&quot;Err in shop&quot;)\n\n2.2.3 启动机器人并配置 webhook先安装依赖项（Python 版本 3.10）\npip3.10 install -r requierments.txt\n\n\n配置文件示例config/config.exp.json\n在内部填写正确的机器人 token 字段后，重命名为config.json\n并将 config/log.exp 中的两个文件复制到 log/ 路径下\n\n然后启动机器人\npython3.10 start.py\n\n看到如下输出即为启动成功\n\n我们需要将 api 的地址填写到爱发电的 webhook url 中\n\n开发者页面 https://afdian.net/dashboard/dev\n\n记得开放对应端口防火墙，并正确绑定域名和开启 https\n\n填写 url 后点击保存，爱发电会发送一条测试 webhook 给你的机器人。如果在预先定义的 debug_ch 中看到了如下卡片，则代表 webhook 配置成功\n\n[23-04-19 19:46:07] INFO:api.py:aifadian_webhook:31 | request | /afd[23-04-19 19:46:07] INFO:apiHandler.py:afd_request:71 | trno:202106232138371083454010626 | afd-cm-send\n\nkill 掉机器人后，在 log 文件中也能看到这次测试 webhook 的请求体\n\n2.3 命令截图 2.3.1 基础测试 先测试一下机器人上线没有\n\n刚开始时，没有 vip 用户\n\n\n使用商城命令，获取购买按钮\n\n点击按钮，会跳转到爱发电的付款页面，能看到 url 最后成功附着上了用户 id 和时间\n&amp;custom_order_id=1961572535%3A7\n\nurl 中的 %3A 就是:\n\n2.3.2 购入 vip 测试  如下，我购买了一个周 vip，机器人成功获取到了 webhook 体中的自定义订单 id\n\n此时再次执行 vip 命令，能看到已经正确添加上了 7 天的 vip\n\n\n日志文件也成功记录\n\n\n测试完毕！\nThe end有任何问题，都可以加入我的  帮助服务器  与我联系\n\n本文档已被官方认可，并放置在了 kook 开发者频道 的常见问题中🎉\n\n\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】对 async 与 await 的理解","url":"/posts/1092148697/","content":"对 python async 与 await 的理解\n\n\n版权声明：本文为 CSDN 博主「MaNong125」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/MaNong125/article/details/120987087\n\nasync&#x2F;await 关键字是出现在 python3.4 以后。网上已经有很多文章对 async&#x2F;await 这两个关键字都有讲解，包括如何由 python2 的 yield from 发展到 async&#x2F;await 这两个关键字，以及一些代码实现都有。\n但是对于像我这样初次接触的人来说，光看代码分析也不一定能理解，我也是在度娘上搜索很多相关的网站，当中也有官网，都没有发现能让我一眼看懂在什么地方可以用 await，什么情况用 await 的文章。\n经过自己的重新思考，总算对 async、await 有一些初步的了解，所以想把自己的理解记录下来，希望对一些学习协程或者异步的初学者也有一定的帮助。\n对于网上能搜到的一些代码实现、例子，这里就不重复了。\n一、首先要知道什么是协程、异步。\n举个例子：假设有 1 个洗衣房，里面有 10 台洗衣机，有一个洗衣工在负责这 10 台洗衣机。那么洗衣房就相当于 1 个进程，洗衣工就相当 1 个线程。如果有 10 个洗衣工，就相当于 10 个线程，1 个进程是可以开多线程的。这就是多线程！\n那么协程呢？先不急。大家都知道，洗衣机洗衣服是需要等待时间的，如果 10 个洗衣工，1 人负责 1 台洗衣机，这样效率肯定会提高，但是不觉得浪费资源吗？明明 1 个人能做的事，却要 10 个人来做。只是把衣服放进去，打开开关，就没事做了，等衣服洗好再拿出来就可以了。就算很多人来洗衣服，1 个人也足以应付了，开好第一台洗衣机，在等待的时候去开第二台洗衣机，再开第三台，……直到有衣服洗好了，就回来把衣服取出来，接着再取另一台的（哪台洗好先就取哪台，所以协程是无序的）。这就是计算机的协程！洗衣机就是执行的方法。\n当你程序中方法需要等待时间的话，就可以用协程，效率高，消耗资源少。\n好了！现在来总结一下：\n洗衣房 ==&gt; 进程  洗衣工 ==&gt; 线程  洗衣机 ==&gt; 方法（函数）\n\n\n\n二、async\\await 的使用\n正常的函数在执行时是不会中断的，所以你要写一个能够中断的函数，就需要添加 async 关键。\nasync 用来声明一个函数为异步函数，异步函数的特点是能在函数执行过程中挂起，去执行其他异步函数，等到挂起条件（假设挂起条件是 sleep(5)）消失后，也就是 5 秒到了再回来执行。\nawait 用来用来声明程序挂起，比如异步程序执行到某一步时需要等待的时间很长，就将此挂起，去执行其他的异步程序。await 后面只能跟异步程序或有__await__属性的对象，因为异步程序与一般程序不同。假设有两个异步函数 async a，async b，a 中的某一步有 await，当程序碰到关键字 await b()后，异步程序挂起后去执行另一个异步 b 程序，就是从函数内部跳出去执行其他函数，当挂起条件消失后，不管 b 是否执行完，要马上从 b 程序中跳出来，回到原程序执行原来的操作。如果 await 后面跟的 b 函数不是异步函数，那么操作就只能等 b 执行完再返回，无法在 b 执行的过程中返回。如果要在 b 执行完才返回，也就不需要用 await 关键字了，直接调用 b 函数就行。所以这就需要 await 后面跟的是异步函数了。在一个异步函数中，可以不止一次挂起，也就是可以用多个 await。\n三、实例：\nasync def test2(i):    r = await other_test(i)    print(i,r) async def other_test(i):    r = requests.get(i)    print(i)    await asyncio.sleep(4)    print(time.time()-start)    return r url = [&quot;https://segmentfault.com/p/1210000013564725&quot;,        &quot;https://www.jianshu.com/p/83badc8028bd&quot;,        &quot;https://www.baidu.com/&quot;] loop = asyncio.get_event_loop()task = [asyncio.ensure_future(test2(i)) for i in url]start = time.time()loop.run_until_complete(asyncio.wait(task))endtime = time.time()-startprint(endtime)loop.close()\n\n输出结果：\nhttps://segmentfault.com/p/1210000013564725https://www.jianshu.com/p/83badc8028bdhttps://www.baidu.com/4.425147771835327https://segmentfault.com/p/1210000013564725 &lt;Response [200]&gt;4.5975635051727295https://www.jianshu.com/p/83badc8028bd &lt;Response [403]&gt;4.722797632217407https://www.baidu.com/ &lt;Response [200]&gt;4.722797632217407\n\n对于下面这几行代码：\nloop = asyncio.get_event_loop()task = [asyncio.ensure_future(test2(i)) for i in url]loop.run_until_complete(asyncio.wait(task))loop.close()\n\n可以在网上找到具体讲解，在这可用下图来粗略形容一下\n\n当所有的异步程序运行完就会返回最后结果。\n对于什么是 task 和 future，asyncio.wait()与asyncio.gather()、asyncio.ensure_future(）这些大家可以网上找到解释。\n说到这里，相信你也大概清楚在什么时候用 async、什么时候 await 了吧! 如果有说得不对的地方，请多多指正！！\n","categories":["速通Python"],"tags":["Python","Kook"]},{"title":"【KOOK】阿狸机器人 | 使用文档","url":"/posts/847195815/","content":"时光匆匆，自从 2022 年 6 月 20 日，阿狸的 GIT 仓库创建第一个 commit 开始，已经过去了一年零 64 天，这么长的时间里，我接受到了不少朋友的支持，也有不少朋友对代码编写的帮助，在此衷心地对大家表示感谢！\n但，由于拳头公司给 auth 鉴权接口新增了 cloudflare 防火墙和人机验证，导致类似阿狸这种集中式的机器人会被直接封禁云服务器 IP 而无法继续使用，所以，阿狸只能和大家说拜拜了！\n自 2023-08-24 起，KOOK 阿狸机器人和 QQ 频道阿狸机器人均停止服务。\n感谢！\n\n欢迎来到 Kook-Valorant-Bot 机器人使用文档\n\n开源代码：Github | Gitee\n机器人状态页：api&#x2F;v2&#x2F;bot\n爱发电支持页：点我发电\n\n有任何问题，欢迎  在本页下方评论（推荐）或加入阿狸帮助频道 \n\n0. 免责声明 1. 查询接口 老生常谈了，目前 valorant 查询的接口是使用拳头官方的登录接口获取到账户 token 后，用账户 token 请求对应的商店、任务、战绩等接口。\n该接口官方没有正式公布，目前的查询操作是在官方  默许  下进行的。根据外网开发者的经验（他们使用的更久）目前暂时还没有听说过有人因为该接口查询信息而被 ban 号。\n但，没有不代表封号风险不存在！\n所以，使用了登陆查询功能之后，即代表您愿意承担此类风险。\n2. 账户安全  机器人的代码  完全开源 ，输出的日志中不会包含用户的 账户 &#x2F; 密码 &#x2F; 邮箱验证码 ，所有信息均通过 kook 的 私聊  和 kook 的 api 传输到机器人进行处理。\n\n传输过程中的私密性将由 https 协议来保证；\n您的账户密码只有 kook 的后台能看到；\n\n如果您担心您的账户安全，请一定要开启邮箱双重验证；或不要使用机器人。\n3. 自动重登  机器人什么时候会进行重登？\n在查询的时候，机器人会先判断账户 token 是否有效，无效则 cookie 重登。具体场景如下:\n\n执行需要登录的查询命令\n早八的 notify 皮肤提醒功能会触发重登\n早八的 vip 商店提醒功能会触发重登\n\n1. 帮助命令 1.hello 执行本命令，阿狸会回复你好。可用于测试阿狸是否在线\n/hello\n\n\n2.@阿狸  在频道内 @机器人，会触发一个语句\n@打瓦的阿狸\n\n呀，听说有人想我了，是吗？输入 `/ahri` 或 `/vhelp` 打开帮助面板，和阿狸一起玩吧！\n\n如果是开发者 @，则会返回只有开发者才能执行的命令帮助面板\n3.ahri阿狸基础帮助命令\n/ahri 或 /Ahri\n\n\n4.vhelpvalorant 相关命令帮助\n/vhelp\n\n\n2. 基础命令 01.val 错误码 以下两个命令完全相同，van 是 val 的别名\n/val 错误码编号/van 错误码编号\n\n用这个命令可以查询游戏常见错误码的解决办法\n/val 1067\n\n\n同时支持查询 van 开头的错误码\n/val 9001\n\n\n02.DX 弹窗错误  如果你发现有人在咨询 DirectX Runtime 相关的错误，可以执行此命令\n/dx\n\n\n03.saveid&#x2F;myid此命令用于保存（修改）用户的游戏 id\n/saveid 游戏 id\n\n\n保存后，在和别人开黑的时候，可以用 myid 命令快捷发出自己的游戏 id\n/myid\n\n\n04.bundle查询一个皮肤系列包含什么皮肤（捆绑包）\n/bundle 皮肤名\n\n举个例子\n/bundle RGX # 查询显卡套\n\n\n05.login登录命令\n/login 账户 密码\n\n登录您的拳头账户，如果开启了邮箱验证，机器人将提示您使用 /tfa 命令进行验证\n\n/login 账户 密码 save\n\n后追save，即代表您愿意将账户密码存储到机器人后台的临时变量（内存）中。存在内存中的数据会在机器人进程退出后清空，他人无法获取。\n\n保存账户密码后，机器人将在尝试cookie 重新登录失败后，使用账户密码进行重新登录\n不管是 vip 用户还是普通用户，该功能都生效\n不支持邮箱登录用户 save 密码。开了邮箱登录的用户，指定 save 后依旧不会缓存\n\n该功能主要服务于机器人长时间开机的时候（不过目前经常需要维护重启，存的数据会丢失）\n06.tfa用于进行邮箱验证\n/tfa 邮箱验证码\n\n如下，刚开始发送验证码，机器人会提示验证码 xxx 收到\n\n如果登录成功，机器人会反馈您的游戏 id\n\n如果输入了一个错误的验证码，机器人会提示您重新输入\n\n07.login-l目前机器人支持至多 3 个拳头账户的同时登录，使用该命令可以查看当前已登录账户的游戏名和登录时间\n/login-l\n\n\n08.login-ap前面提到，login 登录可以指定 save 保存账户密码。\n机器人后台会在  使用账户密码重登  的时候对时间进行记录，用如下命令即可查询\n/login-ap\n\n这样你就能知道机器人啥时候用过你的账户密码操作了\n09.logout如果你不希望机器人在后台操作你的账户\n那就可以用这个命令登出所有账户\n/logout\n\n10.shop查询每日商店\n/shop\n\n如果你登录了多个账户，则需指定编号（编号为 /login-ap 中显示的账户序号）默认查询的是编号为 0 的账户商店\n/shop 1\n\n\n\n11.night查询夜市\n/night\n\n多账户操作和 shop 相同\n/night 账户序号\n\n\n12.uinfo查询用户信息（等级、经验值、玩家卡片、玩家称号、vp、rp 等）\n/uinfo\n\n该命令会自动查询所有已登陆账户，无须指定编号\n\n\n13.match查询最近 5 场的战绩\n/match\n\n多账户查询和 shop 相同\n\n绿色边框代表本场胜利，红色代表负\n\n14.mission查询你的每日 &#x2F; 每周任务\n/mission\n\n目前任务 uuid 尚未完全收录，很多任务都处于未知状态。\n需要大家在执行本命令后，帮助填写表单，尽早集齐所有任务信息。感谢！\n\n3. 皮肤提醒 1.notify-a 查询皮肤，机器人会返回一个皮肤选择表，用 sts 命令选择指定的皮肤，加入皮肤提醒队列\n/notify-a 皮肤名\n\n\n比如我想在商店刷出显卡暴徒的时候，让机器人私聊提醒我，那就可以用如下命令\n/sts 0\n\n这里的 0 是上图中显卡暴徒的编号\n2.notify-l/notify-l\n\n查看已添加的皮肤提醒\n\n3.notify-d删除 notify-l 中不需要提醒的皮肤\n/notify-d 皮肤 uuid\n\n示例\n/notify-d 6f2aefab-439d-140a-4dc6-87818e2d72cd\n\n\n4. 皮肤评价  所谓皮肤评价，就是查询商店的时候，显示在结果之下的信息。采用 leancloud 存储皮肤评价，数据库已在 kook 和 qq 频道的阿狸机器人中共用。\n目前尚有大量皮肤未评价，计算而出的商店评分参考价值低。还需各位多多帮助！\n\n1.rate该命令和 notify-a 类似，需要先通过皮肤名查找需要评论的皮肤\n/rate 皮肤名\n\n示例\n/rate 离子\n\n\n2.rts执行过 rate 命令后，用 rts 命令进行选择\n/rts 序号 打分 吐槽\n\n\n3.kkn执行本命令，查看昨日评分最高 &#x2F; 最低用户\n/kkn\n\n由于目前皮肤评价数据不足，所以参考性低\n\n5.VIP 专属  阿狸的 VIP 基础权益如下\n\n「全新商店展示图」vip 用户将获取到 16-9 的超帅商店返回值\n「商店图片背景自定义」vip 用户可自定义商店查询结果的图片背景\n「保存登录信息」vip 用户登陆后，阿狸会自动保存您的 cookie。在阿狸维护重启的时候，您的登录信息不会丢失（注：cookie 内并不包含你的账户密码）\n「早八商店提醒」阿狸将在早 8 点获取 vip 用户的每日商店并私聊发图给用户。同时会对这张图片进行缓存，当天使用 /shop 命令的时候，只需 2s 获取结果，三倍于普通用户的响应速度！\n\n一些说明\n\n目前商店查询 diy 背景图支持 16-9(横屏)的图片 \n请不要设置违规图片(擦边也不行)！若因为您上传违禁图片后导致阿狸被封，您将被剥夺 vip 权益并永久禁止兑换 vip\n\n1.vip-u该命令用于兑换 vip 的激活码\n/vip-u 激活码\n\n当您在  爱发电  购买 vip 后，爱发电会给您私聊一个 vip 的激活码。私聊阿狸，使用该激活码即可激活 vip。同一激活码只可使用一次。\n\n\n2.vip-c查看 vip 的剩余时间\n/vip-c\n\n\n3.vip-shop目前支持保存 4 张背景图\n3.1 查看已保存背景图  查看已保存的商店自定义背景图\n/vip-shop\n\n\n3.2 切换背景图  这里出现了图片的编号，如果需要切换图片，使用如下命令\n/vip-shop-s 图片编号\n\n就可以切换到对应的背景图\n\n3.3 删除背景图\n由于仅支持 4 个背景图，所以添加更多背景图之前，需要先删除已有的\n/vip-shop-d 图片编号\n\n示例如下\n\n\n3.4 添加背景图\n图片 url 获取看3.5\n\n请尽量使用 kook 上传图片后设置背景图，或使用  国内能直连  的图床图片 url，否则背景图设置很可能出错。\n/vip-shop 图片 url\n\n示例\n/vip-shop https://img.kookapp.cn/assets/2023-04/QUGTtwWxuv6bk2l4.jpg\n\n\n3.5 如何获取图片 urlPC 端将图片上传到 kook → 点击图片 → 底部... 处复制图片链接 → 使用 /vip-shop 命令设置背景\n\n\n6. 娱乐命令 01.roll 骰子 该命令可以掷骰子（生成随机数）\n/roll 左边界 右边界 生成数量\n\n示例\n/roll 1 100 3\n\n\n如果不给第三个数量参数，则默认只生成一个随机数\n/roll 1 100\n\n\n02.countdown 倒计时  在本频道触发一个倒计时\n/countdown 秒数\n\n示例\n/countdown 120\n\n生成一个 120 秒的倒计时\n\n03.tl 翻译  该命令为 translate 的缩写，用于翻译。支持中英互译，以及部分外国语言翻译成中文\n/tl 内容\n\n机翻，图一乐\n\n/tlon/tloff\n\n这两个命令是在本频道  开启 &#x2F; 关闭  实时翻译\n\n开启后，用户发送的所有信息都会被翻译出来\n\n用 /tloff 关闭实时翻译\n\n04.we 天气  该命令可以用于查询城市的天气情况\n/we 城市\n\n\nThe end阿狸的命令就这些啦，有任何问题都可以在下方留言！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【KOOK】linkguard 机器人配置个性化撤回提醒","url":"/posts/1370917284/","content":"linkguard 机器人配置个性化撤回提醒\n\n\n在一位用户的建议下，推出了此功能，经过 2h 的 coding，基本通过了测试\n1. 准备  打开 kook 的卡片编辑器，编辑好你准备的消息\nhttps://www.kookapp.cn/tools/message-builder.html#/card\n注意，卡片消息内不能包含按钮，否则会配置失败\n特殊字符  特殊字符 &#123;met&#125;，用于标识撤回用户信息中所发送的 @用户名 的位置；\n比如下图中，我是这样配置的\n\n实际发送的效果就如下\n\n如何获取图片 url？PC 端将图片上传到 kook → 点击图片 → 底部... 处复制图片链接 → 使用 /vip-shop 命令设置背景\n\n\n将你准备的图片 url 替换官方的示例图片 url 就可以了\n\n2. 命令  在卡片消息编辑器中，编辑好你的消息后，就可以用命令来上传你的卡片消息了\n命令为 /setifo，操作如下，先展开输入栏\n\n先键入命令，再点击代码块按钮\n\n将你的卡片消息粘贴进去，点击确定\n\n随后发送消息\n\n如果一切顺利，机器人会先发送一个消息示例，再提示您配置成功\n\n有用户发送链接时，机器人撤回就会使用此模板进行操作！\n","categories":["速通Python"],"tags":["Python","Kook"]},{"title":"【Python】pycharm 配置代码字体 + 中文字体","url":"/posts/232801310/","content":"如题，默认 pycharm 的字体是宋体和楷体的结合，我本人实在是不喜欢宋体，包括 word 中我也是用黑体创作，最终交作业的时候才会改成宋体（宋体看的真的很不舒服……）\n但是 jb 里面似乎没有提供  中文字体  这一设置选项，要改就只能修改整体\n但我又想让代码的英文用等宽字体，中文设置成黑体，要怎么办呢？\n这时候要用 pyc 的  回滚字体  配置\n在 pyc 的字体设置中，默认界面如下，我们只能设置一个字体\n\n但是打开版式设置，这里会有一个回滚字体，其能设置主字体无法显示的字符\n比如 jb mono 字体就么有对中文进行过适配，所以显示的中文是宋体。这里我们将回滚字体改成微软雅黑\n\n顿时舒服了！\n\n只不过 pyc 自己的界面用的还是宋体，这需要在  设置 - 外观  里面修改\n\n","categories":["速通Python"],"tags":["Python"]},{"title":"【Python】记录 pymysql.err.InterfaceError: (0, ') 的“解决办法”","url":"/posts/520209670/","content":"直奔主题吧！\n情况python 写的机器人遇到了一个 mysql 的错误 pymysql.err.InterfaceError: (0, &#39;&#39;)\n完整报错内容如下\nTraceback (most recent call last):  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/main.py&quot;, line 402, in user_active_on_msg    user_log = await Store.create_user_log(guild_id=gid, user_id=uid)  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/utils/Store.py&quot;, line 313, in create_user_log    user = await QueryMysql.insert_user_log(guild_id, user_id)  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/utils/data/QueryMysql.py&quot;, line 292, in insert_user_log    user = await query_user_log(guild_id, user_id)  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/utils/data/QueryMysql.py&quot;, line 283, in query_user_log    return await UserLog.query(guild_id, user_id)  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/utils/data/QueryMysql.py&quot;, line 21, in query    cursor.execute(MysqlSql.Select.UserLogGU, (guild_id, user_id))  File &quot;/home/mu/pybot/vshop-bot/vs-venv/lib/python3.10/site-packages/pymysql/cursors.py&quot;, line 153, in execute    result = self._query(query)  File &quot;/home/mu/pybot/vshop-bot/vs-venv/lib/python3.10/site-packages/pymysql/cursors.py&quot;, line 322, in _query    conn.query(q)  File &quot;/home/mu/pybot/vshop-bot/vs-venv/lib/python3.10/site-packages/pymysql/connections.py&quot;, line 557, in query    self._execute_command(COMMAND.COM_QUERY, sql)  File &quot;/home/mu/pybot/vshop-bot/vs-venv/lib/python3.10/site-packages/pymysql/connections.py&quot;, line 840, in _execute_command    raise err.InterfaceError(0, &quot;&quot;)pymysql.err.InterfaceError: (0, &#x27;&#x27;)\n\n百度  百度了，说是不要在数据库链接关闭后使用数据库。\n比如下面的代码就是有问题的，close 之后相当于你已经没有连上数据库了。这时候再 commit 肯定是不行的。就好比断网了再点击网页刷新按钮，是无济于事的！\ndb = &quot; 数据库连接 &quot;# 数据库操作db.close()db.commit()\n\n咋回事？然后呢，我还看到了一些博客提到了需要检查连接是否可用。还有其他的巴拉巴拉的。吓得我以为自己的代码是不是有什么问题，是不是这个报错只要跑久了就一定会出现？\n直到我想起来我操作过 docker 的 iptables，重启过 docker（我的 mysql 是 docker 搭建的）\n咳咳，数据库重启过，难怪连不上。怪我怪我。\n也提醒下大家，一定要先把需要用数据库的进程都给停了再去重启数据库！\n\n","categories":["速通Python"],"tags":["Python","MySQL"]},{"title":"【Python】如何多文件编写 KOOK 机器人","url":"/posts/3454615823/","content":"这个工作一定要早做！！不然就会像我一样，main.py 几千行，找个代码的位置都很困难🙅‍♀️\n好不容易才把阿狸的代码给重构了，将其他命令移动到了各自的文件\n1. 基础  在对 bot 进行编程的时候，根据功能不同，会将代码分成几大板块。\n如果将这些内容全部放入一个 main 文件中的话，虽然是可以的，但会显得非常长和杂乱，且不方便定位问题。\n再加上本人有一定强迫症，于是将 valorant 查询代码的实现和 translate 功能的实现分开封装，再在 main.py 文件中使用 bot.command 调用\n1.1 在支线文件中要怎么写？以一个最简单的 hello 代码为例。因为 khl.py 是异步框架，所以在支线文件中的函数都应该带上 async 和await来执行功能\n同时，支线文件中也需要 import 主文件中包含的库函数、以及 bot 的 token。一个比较偷懒的方法就是把主文件 import 过的内容原封不动的复制到支线文件中\nasync def world(msg: Message):    await msg.reply(&#x27; 你好呀~&#x27;)\n\n1.2 在主文件中要怎么写？\n主文件：包含 bot.run 的文件，有且只能有一个\n\n现在我们的支线文件中已经有一个函数的实现了，在主文件中只需要 import 支线文件的函数后，实现 bot.command 让机器人调用这条命令就行\nfrom test import world@bot.command(name=&#x27;hello&#x27;)async def world123(msg: Message):    await world(msg)\n\n要知道，这只是一个示例。像这种较短的程序无需分文件。但如果你的函数实现非常长的时候，就可以用相同的办法实现多文件编程。\n2. 进阶  前面的办法，也只是编程语言中最常用的导入函数方式。因为 Python 支持函数内嵌套函数，我们就能实现一个骚操作，在函数里面注册 bot。\n说人话就是，这个命令的完整实现，包括命令的注册，都可以丢到另外一个文件中！\n\n如下，我们只需要给支线文件中上一个函数，参数为 bot，再内部正常编写代码\nfrom khl import Bot,Messagedef init(bot:Bot):    @bot.command(name=&#x27;hello&#x27;) # 必须写明命令的 name    async def world123(msg: Message):        await world(msg)\n\n然后，在主文件中，bot 启动之前，调用这个 init 函数即可！\nfrom test import init # 支线文件from khl import Bot,Messagebot = Bot(token=config[&#x27;token&#x27;][&#x27;bot&#x27;])@bot.on_startupasync def bot_init(bot: Bot):\tinit(bot) # 调用支线文件中的 init 函数来注册命令\n\n这样才是真正的分文件编写 bot！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】deepin 下 pip 安装包找不到 Python.h 的解决办法","url":"/posts/824840011/","content":" 今天用 deepin 安装 python 包的时候，报了这个问题 \n\n\n(venv) mothra@mothra-PC:~/code/baidu-upd/encrypt2bdy$ pip3 install ruamel.yamlCollecting ruamel.yaml  Using cached https://files.pythonhosted.org/packages/d9/0e/2a05efa11ea33513fbdf4a2e2576fe94fd8fa5ad226dbb9c660886390974/ruamel.yaml-0.17.32-py3-none-any.whlCollecting ruamel.yaml.clib&gt;=0.2.7; platform_python_implementation == &quot;CPython&quot; and python_version &lt; &quot;3.12&quot; (from ruamel.yaml)  Using cached https://files.pythonhosted.org/packages/d5/31/a3e6411947eb7a4f1c669f887e9e47d61a68f9d117f10c3c620296694a0b/ruamel.yaml.clib-0.2.7.tar.gzBuilding wheels for collected packages: ruamel.yaml.clib  Running setup.py bdist_wheel for ruamel.yaml.clib ... error  Complete output from command /home/mothra/code/baidu-upd/encrypt2bdy/venv/bin/python3 -u -c &quot;import setuptools, tokenize;__file__=&#x27;/tmp/pip-install-55f2q2xf/ruamel.yaml.clib/setup.py&#x27;;f=getattr(tokenize, &#x27;open&#x27;, open)(__file__);code=f.read().replace(&#x27;\\r\\n&#x27;, &#x27;\\n&#x27;);f.close();exec(compile(code, __file__, &#x27;exec&#x27;))&quot; bdist_wheel -d /tmp/pip-wheel-m1ay2dbt --python-tag cp37:  sys.argv [&#x27;-c&#x27;, &#x27;bdist_wheel&#x27;, &#x27;-d&#x27;, &#x27;/tmp/pip-wheel-m1ay2dbt&#x27;, &#x27;--python-tag&#x27;, &#x27;cp37&#x27;]  test compiling /tmp/tmp_ruamel_qu43oc5r/test_ruamel_yaml.c -&gt; test_ruamel_yaml OK  running bdist_wheel  running build  running build_py  Generating grammar tables from /usr/lib/python3.7/lib2to3/Grammar.txt  Generating grammar tables from /usr/lib/python3.7/lib2to3/PatternGrammar.txt  creating build  creating build/lib.linux-x86_64-3.7  creating build/lib.linux-x86_64-3.7/ruamel  copying .ruamel/__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel  creating build/lib.linux-x86_64-3.7/ruamel/yaml  copying .ruamel/yaml/__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml  creating build/lib.linux-x86_64-3.7/ruamel/yaml/clib  copying ./__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib  copying ./setup.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib  copying ./LICENSE -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib  running build_ext  building &#x27;_ruamel_yaml&#x27; extension  creating build/temp.linux-x86_64-3.7  x86_64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/home/mothra/code/baidu-upd/encrypt2bdy/venv/include -I/usr/include/python3.7m -c _ruamel_yaml.c -o build/temp.linux-x86_64-3.7/_ruamel_yaml.o  _ruamel_yaml.c:6:10: fatal error: Python.h: 没有那个文件或目录    #include &quot;Python.h&quot;            ^~~~~~~~~~  compilation terminated.  error: command &#x27;x86_64-linux-gnu-gcc&#x27; failed with exit status 1----------------------------------------  Failed building wheel for ruamel.yaml.clib  Running setup.py clean for ruamel.yaml.clibFailed to build ruamel.yaml.clibInstalling collected packages: ruamel.yaml.clib, ruamel.yaml  Running setup.py install for ruamel.yaml.clib ... error    Complete output from command /home/mothra/code/baidu-upd/encrypt2bdy/venv/bin/python3 -u -c &quot;import setuptools, tokenize;__file__=&#x27;/tmp/pip-install-55f2q2xf/ruamel.yaml.clib/setup.py&#x27;;f=getattr(tokenize, &#x27;open&#x27;, open)(__file__);code=f.read().replace(&#x27;\\r\\n&#x27;, &#x27;\\n&#x27;);f.close();exec(compile(code, __file__, &#x27;exec&#x27;))&quot; install --record /tmp/pip-record-lh0gyakn/install-record.txt --single-version-externally-managed --compile --install-headers /home/mothra/code/baidu-upd/encrypt2bdy/venv/include/site/python3.7/ruamel.yaml.clib:    sys.argv [&#x27;-c&#x27;, &#x27;install&#x27;, &#x27;--record&#x27;, &#x27;/tmp/pip-record-lh0gyakn/install-record.txt&#x27;, &#x27;--single-version-externally-managed&#x27;, &#x27;--compile&#x27;, &#x27;--install-headers&#x27;, &#x27;/home/mothra/code/baidu-upd/encrypt2bdy/venv/include/site/python3.7/ruamel.yaml.clib&#x27;]    test compiling /tmp/tmp_ruamel_myagpa5e/test_ruamel_yaml.c -&gt; test_ruamel_yaml OK    running install    running build    running build_py    Generating grammar tables from /usr/lib/python3.7/lib2to3/Grammar.txt    Generating grammar tables from /usr/lib/python3.7/lib2to3/PatternGrammar.txt    creating build    creating build/lib.linux-x86_64-3.7    creating build/lib.linux-x86_64-3.7/ruamel    copying .ruamel/__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel    creating build/lib.linux-x86_64-3.7/ruamel/yaml    copying .ruamel/yaml/__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml    creating build/lib.linux-x86_64-3.7/ruamel/yaml/clib    copying ./__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib    copying ./setup.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib    copying ./LICENSE -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib    running build_ext    building &#x27;_ruamel_yaml&#x27; extension    creating build/temp.linux-x86_64-3.7    x86_64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/home/mothra/code/baidu-upd/encrypt2bdy/venv/include -I/usr/include/python3.7m -c _ruamel_yaml.c -o build/temp.linux-x86_64-3.7/_ruamel_yaml.o    _ruamel_yaml.c:6:10: fatal error: Python.h: 没有那个文件或目录      #include &quot;Python.h&quot;              ^~~~~~~~~~    compilation terminated.    error: command &#x27;x86_64-linux-gnu-gcc&#x27; failed with exit status 1    ----------------------------------------Command &quot;/home/mothra/code/baidu-upd/encrypt2bdy/venv/bin/python3 -u -c &quot;import setuptools, tokenize;__file__=&#x27;/tmp/pip-install-55f2q2xf/ruamel.yaml.clib/setup.py&#x27;;f=getattr(tokenize, &#x27;open&#x27;, open)(__file__);code=f.read().replace(&#x27;\\r\\n&#x27;, &#x27;\\n&#x27;);f.close();exec(compile(code, __file__, &#x27;exec&#x27;))&quot; install --record /tmp/pip-record-lh0gyakn/install-record.txt --single-version-externally-managed --compile --install-headers /home/mothra/code/baidu-upd/encrypt2bdy/venv/include/site/python3.7/ruamel.yaml.clib&quot; failed with error code 1 in /tmp/pip-install-55f2q2xf/ruamel.yaml.clib/\n\n 百度到的解决办法是安装 python-dev\nhttps://blog.csdn.net/CloudsRush/article/details/110580061\nsudo apt-get install python-dev\n\n 先安装了这个，没有用，于是又安装了对应 python 版本的 dev 包 \nsudo apt-get install python3.7-dev\n\n 搞定！这下 pip 安装的时候没有报错了！\n(venv) mothra@mothra-PC:~/code/baidu-upd/encrypt2bdy$ pip3 install ruamel.yamlCollecting ruamel.yaml  Using cached https://files.pythonhosted.org/packages/d9/0e/2a05efa11ea33513fbdf4a2e2576fe94fd8fa5ad226dbb9c660886390974/ruamel.yaml-0.17.32-py3-none-any.whlCollecting ruamel.yaml.clib&gt;=0.2.7; platform_python_implementation == &quot;CPython&quot; and python_version &lt; &quot;3.12&quot; (from ruamel.yaml)  Using cached https://files.pythonhosted.org/packages/d5/31/a3e6411947eb7a4f1c669f887e9e47d61a68f9d117f10c3c620296694a0b/ruamel.yaml.clib-0.2.7.tar.gzBuilding wheels for collected packages: ruamel.yaml.clib  Running setup.py bdist_wheel for ruamel.yaml.clib ... done  Stored in directory: /home/mothra/.cache/pip/wheels/2d/db/d8/e6ded7debed48ad2f416fc153122b7698eb136be4c254beffdSuccessfully built ruamel.yaml.clibInstalling collected packages: ruamel.yaml.clib, ruamel.yamlSuccessfully installed ruamel.yaml-0.17.32 ruamel.yaml.clib-0.2.7\n","categories":["速通Python"],"tags":["Linux","Python"]},{"title":"【Python】调用飞书 API 获取 excel 表格中数据","url":"/posts/3588260369/","content":"调用飞书 API 获取 excel 表格中数据\n\n\n1. 说明  关于云文档的 api，今天处理机器人的时候，有位用户提出了这个需求。但我翻了翻腾讯云文档和金山云文档，都没有看到正经的获取 execl 文档中数据的接口（其实是我愚笨实在是没看懂他文档里面在说什么），大多都是将云文档嵌入到网站中的接口。\n于是又看了看，找到了一个 seatable 是支持完整的 api，甚至支持用 sql 来查询 excel 中的数据。但其免费版本的 API 日用量只有区区5000/ 天，实在是不够机器人用的。\n又找到了飞书，这次总算是找到了我能看懂的用 api 来操作 excel 的文档了。\n\n顺带一提，我的域名邮箱就是用的飞书的免费服务，还是很香的。\n\nhttps://open.feishu.cn/document/server-docs/docs/sheets-v3/overview\n然后又找到了一个 CSDN 上的教程：https://blog.csdn.net/weixin_49160714/article/details/128004781\n此教程讲述的还是不够清除，感觉还是需要自己记录一下。万一以后用得上，也不用在到处找其他教程了。\n2. 创建 api 应用  要想能操作 api，首先需要在你创建的企业中创建一个  企业自建应用，名字随便填写\n\n为了操作 excel 表格，我们需要给予应用云文档的权限。\n\n在权限管理，往下滑找到云文档，全选所有权限，点击右侧批量开通\n\n注意，云文档的权限一共有 21 个，默认一页只是展示了 10 个，全选也只会添加 10 个权限，所以需要依次重复上述操作，把这里的 21 个权限都给选中给应用添加上。避免出现权限问题\n\n随后来到应用凭证，获取你的 appid 和 appsecret，这两个调用鉴权 api 来获取 token 的时候需要\n\n随后来到版本管理，随便创建一个版本，点击  申请发布，否则不能调用 api\n\n因为我本来就是企业的管理员，所以就能在消息里面直接看到申请，点击审核，允许就行了\n\n3. 调用 api 的基本示例 3.1 鉴权 首先要获取到自己的 token，如下代码，修改为你的 appid 和 secret，就能获取到 token\nimport requestsurl = &quot;https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal/&quot;# 应用凭证里的 app id 和 app secretpost_data = &#123;    &quot;app_id&quot;: &quot;&quot;,    &quot;app_secret&quot;: &quot;&quot;&#125;r = requests.post(url, data=post_data)tat = r.json()[&quot;tenant_access_token&quot;]print(tat)\n\n完整的 json 返回值示例如下\n&#123;&quot;code&quot;:0,&quot;expire&quot;:6087,&quot;msg&quot;:&quot;ok&quot;,&quot;tenant_access_token&quot;:&quot;token 内容 &quot;&#125;\n\n获取到 token 后，需要构造一个请求 headers 来请求其他 api\nheader = &#123;    &quot;Content-Type&quot;: &quot;application/json&quot;,    &quot;Authorization&quot;: &quot;Bearer &quot; + str(tat)&#125;  # 请求头\n\n3.2 写入  要想往 excel 表里面写入数据，首先得修 i 改一下权限\n\n代码如下，来解释一下如何获取云文档的 id，和 sh 的 id（这两个不同）\n比如下图中，我打开的云文档 url 里面就包含了云文档的 id，和当前 sheet1 的 id\n\n代码注释中有更多说明\n# 飞书文档的储存地址结构：https:// 企业地址 /sheets/shtcnjGdHzBm7Qa85UXQYk9OPxh?sheet=402cb1# 一般来说 sh 开头为文档地址，sheet= 后跟工作簿地址，这两块是代码需要引用的参数# 总结来说就是 https:// 企业地址 /sheets/ 云文档的完整 ID?sheet= 工作簿的 IDimport jsonsheets_base_url = &quot;https://open.feishu.cn/open-apis/sheets/v2/spreadsheets&quot;excel_id = &quot; 云文档的 id&quot;def insert_info():    url = f&quot;&#123;sheets_base_url&#125;/&#123;excel_id&#125;/values&quot;  # 写入的 sh 开头的文档地址，其他不变    post_data = &#123;        &quot;valueRange&quot;: &#123;            &quot;range&quot;: &quot;486268!C3:N8&quot;,            &quot;values&quot;: [[&quot;Hello&quot;, 1], [&quot;World&quot;, 1]]        &#125;    &#125;    # 在 486268 这个工作簿内的单元格 C3 到 N8 写入内容为 helloworld 等内容    r2 = requests.put(url, data=json.dumps(post_data), headers=header)  # 请求写入    print(r2.json())  # 输出来判断写入是否成功\n\n调用之后，控制台输出success，表中成功新增数据\n\n3.3 查询  由于我的需求是查询某一列的数据，这对记账之类的表格很有用。比如下图中 C 列里面的数据就是数字的加减\n\n这时候我们就可以用如下的方式调用，获取到这个 sheet 中，C 一整列的数据\nurl = f&quot;&#123;sheets_base_url&#125;/&#123;excel_id&#125;/values/486268!C1:C&quot;ret = requests.get(url, headers=header)print(ret.text)print(ret.json())\n\n返回结果示例如下，正好是表格中的数据！\n&#123;        &quot;code&quot;: 0,        &quot;data&quot;: &#123;            &quot;revision&quot;: 8,            &quot;spreadsheetToken&quot;: &quot; 云文档 ID&quot;,            &quot;valueRange&quot;: &#123;                &quot;majorDimension&quot;: &quot;ROWS&quot;,                &quot;range&quot;: &quot;486268!C1:C4&quot;,                &quot;revision&quot;: 8,                &quot;values&quot;: [[399], [-39], [-63], [65], [52], [0], [-63]]            &#125;        &#125;,        &quot;msg&quot;: &quot;success&quot;&#125;\n\n我需要的基本操作就是这些了。只要你学会了这两个操作，后续应该就能看懂飞书的 api 文档，来查询其他信息了。\n","categories":["速通Python"],"tags":["Python"]},{"title":"【Python】元组 / 列表 / 集合的区别","url":"/posts/1142930252/","content":"1. 说明  元组（tuple）、列表（list）和集合（set）是 Python 中常见的数据结构，它们有一些重要的区别。\n\n\n\n可变性：列表是可变的（mutable），可以对其进行添加、删除和修改操作。元组是不可变的（immutable），一旦创建就无法修改。集合也是可变的，但是它具有去重功能，不允许存在重复的元素，并且没有固定的顺序。\n\n语法 ：列表使用方括号[] 来表示，元素之间用逗号 , 分隔；元组使用圆括号 ()`` 来表示，元素之间同样用逗号, 分隔；集合使用大括号 {} 来表示，元素之间也用逗号,&#96; 分隔。\n例如：\nmy_list = [1, 2, 3]my_tuple = (4, 5, 6)my_set = &#123;7, 8, 9&#125;\n\n索引和切片：列表和元组都支持通过索引访问元素和切片操作。而集合是无序的，不支持索引和切片操作。\n\n重复元素：列表和元组允许存在重复的元素，而集合会自动去除重复的元素。\n例如：\nmy_list = [1, 1, 2, 2, 3, 3]  # 列表中可以有重复元素my_tuple = (4, 4, 5, 5)      # 元组中也可以有重复元素my_set = &#123;6, 6, 7, 7&#125;        # 集合会自动去除重复的元素# 如上 my_set = &#123;6,7&#125;\n\n可哈希性：集合的元素必须是可哈希（hashable）的，而列表和元组的元素可以是可哈希或不可哈希的。可哈希的意思是该对象的值在其生命周期中不发生改变，且能够唯一地确定一个对象。\n\n\n总的来说\n\n元组适用于存储固定的、不可变的数据；\n列表适用于需要频繁对其中的元素进行增删改操作的情况；\n集合适用于需要确保元素唯一性且不关心元素的顺序的场景。\n\n选择使用哪种数据结构取决于具体的需求和问题的特点。\n2. 可哈希性 2.1 概念 可哈希性（hashability）是指一个对象是否具有哈希值（hash value），并且能够保持不变。在 Python 中，可哈希的对象是指那些在其生命周期中不可变的对象。\n哈希值是一个固定长度的整数，用于唯一标识一个对象。哈希值是通过将对象的内容转换为一个数字来计算得到的。可哈希的对象具有以下特点：\n\n哈希值不会改变：一个对象的哈希值在其生命周期中是不变的，即使对象的内容发生了改变。\n相等的对象具有相同的哈希值：如果两个对象是相等的，则它们的哈希值也相等。\n\n可哈希性在 Python 中非常重要，主要体现在两个方面：\n\n字典的键（key）必须是可哈希的对象：因为字典是基于哈希表实现的，它使用键的哈希值来索引和快速查找对应的值。所以字典中的键必须是不可变的对象，例如整数、浮点数、字符串、元组等都是可哈希的。\n集合的元素必须是可哈希的对象：集合也是基于哈希表实现的，它使用哈希值来确定元素是否存在于集合中，并且保证集合中的元素唯一性。所以集合中的元素也必须是不可变的对象。\n\n总结起来，可哈希性是指对象在其生命周期中不发生改变，并且能够通过哈希函数计算得到一个固定的、唯一的哈希值。可哈希的对象可以作为字典的键和集合的元素使用。\n2.2 自定义类型的可哈希性  自定义类型（Custom types）可以维护可哈希性，但需要满足一定的条件。\n在 Python 中，对象的可哈希性是由其所属类的 __hash__() 方法和 __eq__() 方法共同决定的。下面是关于自定义类型维护可哈希性的条件：\n\n__hash__()方法的实现：自定义类型必须定义 __hash__() 方法，该方法返回一个整数作为对象的哈希值。通常情况下，可使用内置函数 hash() 来计算哈希值，具体实现如下：\ndef __hash__(self):    return hash((self.attribute1, self.attribute2, ...))\n\n注意，__hash__()方法应该返回一个不可变的值，并且相等的对象应该具有相等的哈希值。\n\n__eq__()方法的实现：为了确保相等的对象具有相等的哈希值，自定义类型也必须定义 __eq__() 方法来比较两个对象是否相等。__eq__()方法通常与 __hash__() 方法配合使用，具体实现如下：\ndef __eq__(self, other):    if isinstance(other, self.__class__):        return (self.attribute1 == other.attribute1) and (self.attribute2 == other.attribute2) and ...    return False\n\n注意，__eq__()方法应该返回布尔值表示两个对象是否相等。\n\n\n通过正确实现 __hash__() 和__eq__()方法，自定义类型就可以维护可哈希性。这样，对象就可以作为字典的键或集合的元素，并能够保持不变性和相等性的判断。\n然而，请注意，如果自定义类型中的属性是可变的（例如列表、集合等），则对象可能会发生改变，导致哈希值的改变。因此，在定义可哈希的自定义类型时，应该避免使用可变的属性。\n2.2.1 hash(自定义类型)当我们使用 hash函数来处理自定义类型时，python 就会调用这个自定义类型的 __hash__()函数\nhash(p1)# 等价于p1.__hash__()\n\n默认情况下，__hash__ 方法返回对象的标识符，而 __eq__ 方法在两个对象相同时返回 True。如果想要覆盖这个默认行为，我们可以实现 __hash__ 方法和 __eq__ 方法。\n2.2.2 只实现 eq如果一个自定义类型只实现了 __eq__而没有实现 __hash__，那么这个类型就不具备可哈希性，也就不能作为 dict 或者集和的键值\n比如如下 person 对象只实现了 __eq__\nclass Person:    def __init__(self, name, age):        self.name = name        self.age = age    def __eq__(self, other):        return isinstance(other, Person) and self.age == other.age\n\n如果尝试将这个对象放入 set，就会报错\nmembers = &#123;    Person(&#x27;John&#x27;, 22),    Person(&#x27;Jane&#x27;, 22)&#125;\n\nTypeError: unhashable type: &#x27;Person&#x27;\n\n同时 person 对象失去了 hash 功能\nhash(Person(&#x27;John&#x27;, 22))# TypeError: unhashable type: &#x27;Person&#x27;\n\n为了使得 Person 类可哈希，我们还需要实现 __hash__ 方法\nclass Person:    def __init__(self, name, age):        self.name = name        self.age = age    def __eq__(self, other):        return isinstance(other, Person) and self.age == other.age    def __hash__(self):        return hash(self.age)\n\n现在，Person 类既支持基于 age 的等值比较，又具有哈希功能。\n为了使得 Person 能够正常用于字典这种数据结构，类的哈希值必须具有不可变性。为此，我们可以将 age 定义为只读属性\nclass Person:    def __init__(self, name, age):        self.name = name        self._age = age    @property    def age(self):        return self._age    def __eq__(self, other):        return isinstance(other, Person) and self.age == other.age    def __hash__(self):        return hash(self.age)\n\n2.2.3 总结\n默认情况下，__hash__ 方法返回对象的 ID，__eq__ 方法使用 is 操作符进行比较。\n如果实现了 __eq__ 方法，Python 会将 __hash__ 方法设置为 None，除非实现了自定义的 __hash__ 方法。\n\n","categories":["速通Python"],"tags":["Python"]},{"title":"【API】API 的各种分类详解","url":"/posts/73383828/","content":"API，即应用程序编程接口，是为了方便应用程序之间的数据和功能交互而设计的一些标准方法。API 的分类可以从多个维度进行，我会对 API 的分类维度进行简单的介绍。\n\n\n根据使用方式的不同  通常情况下，API 可以分为两种使用方式：内部 API 和外部 API。\n内部 API 是指供企业内部开发人员和应用所使用的 API。当企业需要一些定制化的应用程序或者集成特定的功能时，内部 API 可以提供更好的技术支持，同时也能保证数据的安全性和可靠性。\n外部 API 则是供公众开发者使用的 API，通过提供数据和服务，使得外部的开发者可以构建丰富的应用程序并与当前的生态系统进行协作。越来越多的各类公司都开始向公众提供自己的 API，示例包括 Facebook、Twitter、Google 等。\n根据访问方式的不同  根据 API 的访问方式，API 可以分为以下几种：\n\nRESTful API REST（Representational State Transfer）是一种基于 HTTP 协议的 Web 应用程序架构标准。RESTful API 遵循 RESTful 架构的原则，通常由资源路径和请求方法组成，以达到可读性高、灵活性好的目的。\nSOAP API SOAP（Simple Object Access Protocol）是一种基于 XML 编码的远程调用协议，比较复杂而且处理时间和网络资源使用率高。虽然 SOAP 技术已经逐渐淡出市场，但在某些特殊场景下仍然会有所应用。\nGraphQL API GraphQL 是由 Facebook 公司开源的一种数据查询语言和 API 执行引擎，可以呈现出 XML schema 来表达整个数据的结构，并为前端工程师提供自由定义获取所需属性、代码重用等人性化的特色。\ngRPC API gRPC 可以理解为 Google Remote Procedure Call，是 Google 最新开源的跨语言 RPC 框架。借助基于 HTTP&#x2F;2 的二进制传输协议，gRPC 提供了比 JSON 和 RESTful 更快速和更可靠的通讯方式。\n\n根据功能的不同  根据 API 的功能性质，API 可以分为以下几类：\n\nWeb API Web API 一般都针对 Web 应用程序，提供一些标准的接口，例如：W3C DOM 接口、HTTP 接口、WebSocket 接口、Web Worker 接口等。这些 API 帮助浏览器取得用户元素信息、发送 AJAX 请求等等。\n操作系统 API 操作系统 API（如 Windows API 或 POSIX API）提供了与操作系统软件交互的方法，允许应用程序查询及控制硬件设备或操作系统内核任务等。此类 API 几乎适用于任何类型的环境。\n数据库 API 数据库 API 可以使应用程序通过某些 API 实现对一些数据存储的操作，例如：SQL、NoSQL 等数据库里都有相关的 API 调用。\n\n在实际使用中，API 支持访问不同的功能模块，例如数据转换、数据分析、网络安全、门户管理、日历等等，还可以根据不同的需求进行客制化的开发。\n总之，在开发过程中，根据实际需求选择合适的 API 类型是非常重要的，能够快速、高效地构建需要的应用程序。\n版权声明：本文为 CSDN 博主「luffy_fe」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_42107247/article/details/130508490\n\n","tags":["API"]},{"title":"【Python】request 库 InsecureRequestWarning 的原因","url":"/posts/903214799/","content":"今天在测试我自己写的 api 的时候，发现了之前出现的一个 warning 的真正原因\n1. 起因  先来看请求 api 的代码\ndef ApiRq(account:str,passwd:str,background=&#x27;&#x27;):    url = &quot;https://val.musnow.top/shop-url&quot;    params = &#123;         # 参数涉及到隐私，省略    &#125;  \tres = requests.get(url,params=params,verify=False) # 请求 api    return res.json()\n\n运行，会出现这个警告\n/home/muxue/.local/lib/python3.10/site-packages/urllib3/connectionpool.py:1045: InsecureRequestWarning: Unverified HTTPS request is being made to host &#x27;val.musnow.top&#x27;. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#ssl-warnings\n\n百度了一下，可以用下面的办法来去掉这个警告\nimport urllib3 # 屏蔽 ssl warningurllib3.disable_warnings(urllib3.connectionpool.InsecureRequestWarning)\n\n但是这样是不安全的，因为我们没有检查网站的证书，也就无法向服务器发送确认后的加密信息\n2. 出现这个警告的原因  出现这个警告，其实就是因为我们这里设置了不检查 ssl 证书\nres = requests.get(url,params=params,verify=False) # 请求 api\n\n如果你网站的证书是没有问题的，那么完全没有必要不检查，应该使用下面的代码\nres = requests.get(url,params=params)\n\n之前  我的 api 站点所用证书缺少证书链 ，所以出现了另外一个报错，从而使用了verify=False 才能正常运行代码，现在更新了证书，也就不需要了！\n此时直接运行代码，也不会报错了！\n[muxue@bt-7274:~/kook/test]$ py3 api_test.pystart test\n\n3. 进一步了解\n参考 https://blog.csdn.net/memory_qianxiao/article/details/82011282\n\nrequests 库其实是基于 urllib 编写的，对 urllib 进行了封装，使得使用时候的体验好了很多。\n现在 urllib 已经出到了 3 版本，功能和性能自然是提升了不少。所以，requests 最新版本也是基于最新的 urllib3 进行封装。\n在 urllib2 时代对 https 的处理非常简单，只需要在请求的时候加上 verify=False 即可，这个参数的意思是忽略 https 安全证书的验证，也就是不验证证书的可靠性，直接请求。但这其实是不安全的，因为证书可以伪造，不验证的话就不能保证数据的真实性。\n在 urllib3 时代，官方  强制验证https 的安全证书，如果没有通过是不能通过请求的，虽然添加忽略验证的参数，但是依然会 给出醒目的 Warning\n\n简单说来，就是如果是旧的 request 库，你可以用 verify=False 禁用掉证书验证，也不会出现报错；但是到 urllib3 后，官方要求一定要验证 https 证书，所以禁用掉证书验证，就会报出警告。\n除非你确认你调用的 api 是正规的，那么禁用掉证书验证是不应该的！\n4. 检查一下你的站点 ssl 证书是否 ok这里给大家推荐一个网站：myssl\n在这里输入你的域名，可以检测一下你的 ssl 证书是否正确部署，我的证书链问题就是在这里检测出来的\n\n只要是 A 那就是 ok 的！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook","api"]},{"title":"【Python】如何给你的 kook 机器人添加上翻译功能","url":"/posts/644618981/","content":"翻译功能实现  打开 code&#x2F;endpoints&#x2F;translate.py，这便是本仓库中翻译代码的实现。\n其中第一部分有道翻译的代码来自Many-Translaters 项目，该项目上一次维护是在 4 年前，且里面的部分代码已经无法使用。该代码属于一个白嫖产物，稳定性未知。\n为了不让我的 bot 在有道翻译接口失效后直接没有了翻译功能，这里我使用了  彩云小译  来作“备胎”\n\n你可以在  彩云小译  的官网上找到api 文档，内部包含了一个 Python 代码示例，开箱即用！免费用户申请的api-key，每月有 100w 字符的免费额度，对于我们的 bot 算是够用了。\n\n1. 关于 aiohttp 和 requests 的优劣  在khl.py一众大佬的建议下，我简单学习了 aiohttp 的代码，并将彩云小译的 requests 修改为了aiohttp\n# 原有 requests 代码response = requests.request(&quot;POST&quot;, url, data=json.dumps(payload), headers=headers)return json.loads(response.text)[&quot;target&quot;]# 替换为 aiohttp 代码async with aiohttp.ClientSession() as session:    async with session.post(url, data=json.dumps(payload), headers=headers) as response:        return json.loads(await response.text())[&quot;target&quot;]\n\n这里简单说一下 aiohttp 和requests的区别\n\nrequests途中，程序会挂起，bot 将不会响应其他命令\naiohttp作为异步框架，bot 在使用它的同时，可以同步处理其他命令\n\n举个栗子：假设有用户每 1 分钟调用一次 bot 的翻译接口，彩云小译的服务器用了 3 秒钟（实际肯定没那么久）响应了我们的 requests。这 3 秒钟内，如果有其他用户调用了 bot 的另外一个指令，我们的 bot 就跟 假死  了一样，不会响应该用户的指令\n这样看来，优势就很明显了：虽然在网络稳定的时候，requests和 aiohttp 不会形成鲜明的效率差距，但在 KOOK 或者彩云小译服务器拥堵期间，我们的 bot 也能做到不会因为 requests 时间太长而影响用户的使用体验。\n2. 利用抛异常机制更改翻译引擎  看到 main.py 中的 translate 部分，这里我 import 了translate.py中的相关函数，随后使用 bot.command 来调用这两个函数。那么如何让 bot 在有道翻译接口寄了的时候，自动去找备胎彩云小译呢？\n\n简单了解抛异常\n\n在 python 中，基本的抛异常机制如下：\ntry:    num(&#x27;a&#x27;, &#x27;b&#x27;)except:    print(&#x27; 程序奔溃啦！&#x27;)\n\n上面这个代码就是一个简单的抛异常机制。编译器会先尝试运行 try 后面的代码，如果该部分报错，则会转而执行 except 后的代码。\n转换倒我们这里的例子，我们只需要在 try 后面写入有道翻译的代码，在 except 后写入彩云小译的代码，编译器就能在有道的接口出错的时候，自动找备胎\ntry:\t# 有道代码实现except:    # 彩云小译代码实现\n\n\n3. 关于带空格英文句子传参问题  当我们翻译一个句子的时候，中文内容往往没有空格，但英文句子极其依赖于  空格  进行单词的分割。\n如果我们简单地使用 str 来接受传参，就会导致用户需要翻译的英文内容，只有第一个单词传了过来\nasync def translate(msg: Message,txt:str):\n\n比如当用户打出：/TL I LOVE YOU时，bot 实际接收到的只有首单词 I，它会翻译该单词，可后面的LOVE YOU 直接被无情抛弃了！\n这里我们就需要使用 python 中牛逼的不定传参 *arg 了！\nasync def translate(msg: Message,*arg):\n\n*arg是 python 中支持的不定参数传参，即函数先前不知道用户会传入多少个参数。我们可以在传参完毕后，再对这些参数进行操作。\n利用 *arg 的特性，我们可以一次性把所有单词都接收过来，再在函数中将它们拼成一个完整的字符串，传入到 translate 函数中。\nasync def translate(msg: Message,*arg):    word = &quot; &quot;.join(arg)\n\n这里的 &quot; &quot;.jion(arg) 代表用空格来分隔每一个参数，这样才能拼出一个完整的英文句子！\n\n\n\n好了，基本的单句翻译已经写好了，但我们还可以整点花活，让 bot 可以实时翻译某一个文字频道内的所有消息！\n4. 实时翻译（全局变量）见 main.py 中的ListTL，这里我为实时翻译创建了一个全局数组，用来存放需要实时翻译的文字频道 id。\n注意：ListTL作为全局变量，在函数中调用的时候，需要先用 global ListTL 进行全局变量声明。否侧程序会在该函数中创建临时变量！\n\n当用户需要实时翻译时，利用 /TLON 功能在他所在的文字频道开启该功能\n\nbot 可以在 msg.ctx.channel.id 中获取到用户所在文字频道的 id，并将其写入 List 中\n\n使用 @bot.command(regex=r&#39;(.+)&#39;) 正则表达式获取文字频道的所有内容，再通过判断该文字频道 id 是否存于 List 之中，来确认是否要进行实时翻译并返回结果\n\n这种正则方法也是让 bot 监看文字频道的一个非常好的办法，比如发现关键词之后，自动发送对应消息提示。\n\n当用户使用 /TLOFF 关闭实时翻译后，将对应位置的 List 置零，空出栏位\n\n具体的代码实现可以查看 main.py 中translate相关部分的函数\n5. 处理 met 和 rol 消息  为了避免冲突，机器人不应该翻译 @xx 用户  和@xx 角色 的消息，在 kook 的后台，机器人会接收到 (met)user_id(met)/(rol)role_id(rol) 格式的文字；\n用下面的代码处理，可以将这两个串替换成空串，不进行翻译\n# 单独处理 met 和 rol 消息，不翻译这部分内容 def deleteByStartAndEnd(s, start, end):    # 找出两个字符串在原始字符串中的位置    # 开始位置是：开始始字符串的最左边第一个位置；    # 结束位置是：结束字符串的最右边的第一个位置    while s.find(start) != -1:        x1 = s.find(start)        x2 = s.find(end, x1 + 5) + len(end)  # s.index() 函数算出来的是字符串的最左边的第一个位置，所以需要加上长度找到末尾        # 找出两个字符串之间的内容        x3 = s[x1:x2]        # 将内容替换为空字符串 s        s = s.replace(x3, &quot;&quot;)    print(f&#x27;Handel&#123;start&#125;: &#123;s&#125;&#x27;)    return s\n\n\n结语  使用实时翻译可以实现一些好玩的事情：比如把一句话来回翻译 N 遍进行“提纯”\n（非常无聊了属于是）\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】request.session 的 cookie 如何导入 aiohttp._cookie_jar","url":"/posts/3768471210/","content":"request.session的 cookie 导入 aiohttp._cookie_jar 的教程\n\n\n1. 起因  我的 kook-valorant-bot 使用了两个开源库，用于 riot 账户的登录并获取 token\n\n其中最主要用的是基于 aiohttp 的floxay&#x2F;python-riot-auth，但这个仓库不支持 2fa 用户（开启了邮箱双重验证的用户）作者去年就说会写上，但是他比较忙没有排期；\n于是我又去找了一个另外一个基于 request 的 Prodzify&#x2F;Riot-auth 支持 2fa 登录的，半月前已经给 bot 加上了这个 缺失半年  的功能。\n\n可是 Prodzify&#x2F;Riot-auth 没有  写 cookie 登录  方法，其每次登录都需要账户密码，2fa 用户每次都需要提供邮箱验证码；对于一个 bot 来说，每次操作这么麻烦，很是难受！\n随后，我去  询问了写 discord valorant bot 的作者，得知如果 2fa 用户使用 cookie 登录，其是不需要提供邮箱验证码的！\n那么问题就变成了，如何将 request 的 cookie 导入到 aiohttp 的 _cookie_jar 中，然后调用 floxay&#x2F;python-riot-auth 已经写好的 cookie 登录方法呢？\n\n1.1 前置声明  这里说明一下，我写 bot 全都是看 khl.py 的 example 自学的，到目前为止，我没有系统性的学习过 python 语法，关于 py 类和对象的知识全都得靠 C++ 的存货来旁敲侧击；所以如果我的 python 博客中出现错误，那是很正常的，还请指正！\n\n2. 查找办法  不多比比在互联网上大海捞针的困难了，我还是东平西凑才找到了一个办法\n\nPython CookieJar.update_cookies 方法代碼示例\n\n该教程提到了下面的办法来导入 cookie\n# 需要導入模塊: from aiohttp import CookieJar [as 別名]# 或者: from aiohttp.CookieJar import update_cookies [as 別名]def test_domain_filter_ip_cookie_send(loop) -&gt; None:    jar = CookieJar(loop=loop)    cookies = SimpleCookie(        &quot;shared-cookie=first; &quot;        &quot;domain-cookie=second; Domain=example.com; &quot;        &quot;subdomain1-cookie=third; Domain=test1.example.com; &quot;        &quot;subdomain2-cookie=fourth; Domain=test2.example.com; &quot;        &quot;dotted-domain-cookie=fifth; Domain=.example.com; &quot;        &quot;different-domain-cookie=sixth; Domain=different.org; &quot;        &quot;secure-cookie=seventh; Domain=secure.com; Secure; &quot;        &quot;no-path-cookie=eighth; Domain=pathtest.com; &quot;        &quot;path1-cookie=nineth; Domain=pathtest.com; Path=/; &quot;        &quot;path2-cookie=tenth; Domain=pathtest.com; Path=/one; &quot;        &quot;path3-cookie=eleventh; Domain=pathtest.com; Path=/one/two; &quot;        &quot;path4-cookie=twelfth; Domain=pathtest.com; Path=/one/two/; &quot;        &quot;expires-cookie=thirteenth; Domain=expirestest.com; Path=/;&quot;        &quot; Expires=Tue, 1 Jan 1980 12:00:00 GMT; &quot;        &quot;max-age-cookie=fourteenth; Domain=maxagetest.com; Path=/;&quot;        &quot; Max-Age=60; &quot;        &quot;invalid-max-age-cookie=fifteenth; Domain=invalid-values.com; &quot;        &quot; Max-Age=string; &quot;        &quot;invalid-expires-cookie=sixteenth; Domain=invalid-values.com; &quot;        &quot; Expires=string;&quot;    )    jar.update_cookies(cookies)    cookies_sent = jar.filter_cookies(URL(&quot;http://1.2.3.4/&quot;)).output(        header=&#x27;Cookie:&#x27;)    assert cookies_sent == &#x27;Cookie: shared-cookie=first&#x27;\n\n floxay&#x2F;python-riot-auth 里正好封装了 cookie jar，也就是说，我们只要想办法弄出来一个 SimpleCookie 对象，再调用 update_cookie 方法，就大功告成了！\n3. 最终实现  关于这两个登录项目的源码，请去 github 仓库查看\n下面只对 cookie 部分进行说明！\n3.1 request 和 aiohttp 的 cookies 差异\n因为 cookie 部分涉及到 riot 账户的登录信息，所以必须打码\n\n首先当然是从 request 里面拿到 cookie 了\nself.cookie = self.session.cookiesprint(self.cookie)\n\n这里直接打印，获取到的内容如下\n\n而 aiohttp 的 cookie 打印出来是下面这样的\nauth = riot_auth.RiotAuth(&quot; 账户 &quot;,&quot; 密码 &quot;)print(auth._cookie_jar._cookies)\n\n\n可以看到，两个库打印的内容不太相同，但是其键值是一致的，我们只需要把 request 的键值导入到 SimpleCookie 里面就可以了\n3.2 request.session 的 cookie 导出为 dict要想导入到 SimpleCookie 里面，我们可以先来看看这个类的构造是什么\n\n可以看到，该类其实是支持用 dict 来初始化的\n现在问题又变成了，如何将 request.session 的 cookie 导出为 dict\n百度一下，这个问题的答案还是能找得到的\nau = Auth(username=&quot; 账户 &quot;,password=&quot; 密码 &quot;)ck_dict = requests.utils.dict_from_cookiejar(au.cookie)print(ck_dict)\n\n此时打印出来的结果如下，成功转换成了 dict\n\n再把这个 dict 丢进SimpleCookie，运行无报错，那么说明 ojbk 了\n3.3 最终实现  现在就只需要进行如下的操作，就能实现把 2fa 用户的 cookie 导入到 riot_auth.RiotAuth() 里面了！\nimport asyncioif __name__ == &#x27;__main__&#x27;:    print(f&quot;Start&quot;)    au = Auth(username=&quot; 账户 &quot;,password=&quot; 密码 &quot;)    ck_dict = requests.utils.dict_from_cookiejar(au.cookie)    print(ck_dict)    scookie = SimpleCookie(ck_dict)    auth = riot_auth.RiotAuth()    auth._cookie_jar._cookies    auth._cookie_jar.update_cookies(scookie)    ret = asyncio.run(auth.reauthorize())    print(ret) # 成功！！！！\n\nauth.reauthorize()方法会返回一个 bool 值，标识是否登录成功\n\n当然成功啦！\n4. 结语  不得不说，这个问题的答案网上是真的无现成的，都得东平西凑，花了我差不多一个半小时才找到正确方法\n不过现在终于可以保存 2fa 用户的登录信息了，也算是 bot 的功能升级吧！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook","api"]},{"title":"【Python】关于 vip 和普通用户商店返回值图片出错的问题定位 + 大白话说明","url":"/posts/1592602771/","content":"在开发阿狸的过程中，遇到了一个全局变量写错而导致的 bug……\n\n\n问题引出  如果你最近几天有用过 shop 查询功能，可能会遇到下面的情况\n\n上图为普通用户的商店用了 vip 用户 16-9 的图片；\n下图为 vip 用户的商店用了普通用户 1-1 的图片\n\n\n简单说来，vip 的商店返回值是 16-9 的图片，而普通用户的商店是 1-1 的图片。\n在上面的三个每日商店返回值中，就出现了 vip 用户的商店用了 1-1 的图，或者普通用户的商店用了 16-9 的图。\n这个 bug 昨天（22.09.12）我就发现了，是一位 vip 用户的商店返回值里面用了普通用户的图片。而我昨天定位 bug 的时候，测试 bot 保存了画出来的 4 个小图，没有问题；然后再使用 &#x2F;shop 命令，发现测试 bot 没有出现这个问题。于是我就把阿狸  重启  了一下，问题也消失了！于是就秉持“遇事不决，重启解决”的错误心态，没有打理这个问题。\n而今天（22.09.13）早上，这个问题又出现了，这次是普通用户的商店返回值里面用了 vip 的图片。于是我又把 bot 重启了一下，果然，问题又消失了。哈哈！解决了——个锤子！\n\n代码逻辑介绍  这里先说明一下，阿狸的商店返回值逻辑如下：\n\n通过 api 获取玩家商店，api 返回的是 4 个武器的 uuid\n遍历所有武器，找到这 4 个武器名字 + 皮肤图片 + 价格 + 皮肤等级，将它们组合起来，画出一个小图\n再把画出来的 4 个小图，通过坐标映射，全部粘贴到最终的大图上面。也就是大家获取道的返回结果\n\n今天晚上，我自己获取商店的时候又双遇到了这个 bug，于是再次认真看了一边代码。这下可算是发现这个问题的位置了~ 且听我细细道来（看下面的图片）\n\nweapon_icon_temp（就叫它抽屉吧）是一个全局变量，里面存放了画好的单个武器的图片（武器名字 + 武器图片 + 价格 + 皮肤等级）下图是画好的单图示例\n\n除了抽屉（weapon_icon_temp），阿狸还会把这个图片存放到  本地路径  里面（仓库）这样在阿狸重启之后（抽屉会被清空 ）本地路径（仓库）里面的图片还在，可以从 仓库  里面拿出来，也节省了画图的时间。\n逻辑大概是这样的\n\n用户 A 获取商店，阿狸画出了 4 个皮肤的图片，并把它们存了起来（抽屉和仓库都存了）；\n用户 B 获取商店，阿狸发现这两个用户的商店皮肤有重合，这时候就没必要再画一张图了，于是阿狸就从  抽屉  里（weapon_icon_temp）拿出了之前给用户 A 画好的相同皮肤的图片，直接粘贴到用户 B 最后的大图上。\n\n下图为  普通用户  的画图逻辑\n\n\n现在，vip 的商店图片是 16-9，普通用户的商店图片是 1-1。所以阿狸会单独处理两种用户，并画出不同的图片，存放在不同的  本地路径（仓库）中。\n\n普通用户存放在 img_temp 本地路径中，vip 用户存放在 img_temp_vip 本地路径中\n\n\n可是，本地路径（仓库）的位置变啦，但是全局变量（抽屉）用的还是同一个啊！\n阿狸画图的时候，肯定是先从  抽屉  里面拿图片。因为抽屉顺手就能拿到，干嘛跑仓库里面去呢？（指全局变量访问比本地路径更快）\n这就导致了如果某个皮肤 A 先被  普通用户  张三查询到，而 vip 用户 李四在之后查询的时候，也获取到相同的皮肤 A，那么阿狸就从  抽屉  里面掏出了一张应该给  普通用户  用的图片，贴在了 vip 用户 李四的返回值上，于是李四就获取到了下面这一张图片\n\n解决  解决办法很简单，把 vip 和普通用户的抽屉分开就行了\n那为什么这个问题，重启阿狸就好了呢？\n前面提到过，抽屉会在阿狸关机的时候  清除（因为全局变量是写在内存里面的，会在使用完毕后释放，类似于你划掉手机的后台应用来释放手机的运存一样）\n这样一来，抽屉里面没有之前画好的图片，那么阿狸就会去仓库里面（仓库是分开的）找出了正确的图片，测试就看不出来有 bug 了！（因为这个 bug 的触发必须要普通用户和 vip 用户使用阿狸查询商店，而他们同时刷出了一个皮肤。我的测试没有这种环境）\n咳咳，说了这么多，不知道大家看明白了没有\n\n结语  阿狸会在 22.09.14 的早 8 点后重启，以修复这个 bug。为啥现在不弄呢？因为重启会把普通用户的登录信息清空。导致普通用户明天 8 点的皮肤提醒功能不能用，之前因为重启已经连续几天这样了（指普通用户因为没有登录信息，无法使用皮肤提醒功能）对普通用户也太不公平了！\n感谢你看到了最后！！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】生成本项目的 requeirments.txt","url":"/posts/1488017193/","content":"有的时候，我们需要对自己写的项目生成一个requeirments.txt，方便其他使用者快速安装依赖项\n\n\n\n参考https://www.cnblogs.com/shun7man/p/14080921.html\n\n1. 使用 pip如果你的项目本身就是在 venv 虚拟环境下跑的，那么可以直接用下面的语句生成一个依赖项文件\npip freeze &gt; requirements.txt\n\n\n但如果你和我一样，没有使用虚拟环境 ，而是用 全局  的包的话，那就会出现上图的情况，生成的 txt 文件里面出现了太多本项目没有用到的包，那你让别人安装那么多没有用的包，岂不是坑人嘛！\n所以可以用另外一个项目来解决这个问题\n2.pipreqs安装  项目地址 https://github.com/bndr/pipreqs\n使用之前需要先安装一个包\npip install pipreqs\n\n[muxue@bt-7274:~/kook/val-bot]$ pip3.10 install pipreqsDefaulting to user installation because normal site-packages is not writeableCollecting pipreqs  Downloading pipreqs-0.4.11-py2.py3-none-any.whl (32 kB)Collecting yarg  Downloading yarg-0.1.9-py2.py3-none-any.whl (19 kB)Collecting docopt  Downloading docopt-0.6.2.tar.gz (25 kB)  Preparing metadata (setup.py) ... doneRequirement already satisfied: requests in /home/muxue/.local/lib/python3.10/site-packages (from yarg-&gt;pipreqs) (2.28.1)Requirement already satisfied: urllib3&lt;1.27,&gt;=1.21.1 in /home/muxue/.local/lib/python3.10/site-packages (from requests-&gt;yarg-&gt;pipreqs) (1.26.11)Requirement already satisfied: idna&lt;4,&gt;=2.5 in /home/muxue/.local/lib/python3.10/site-packages (from requests-&gt;yarg-&gt;pipreqs) (3.3)Requirement already satisfied: certifi&gt;=2017.4.17 in /home/muxue/.local/lib/python3.10/site-packages (from requests-&gt;yarg-&gt;pipreqs) (2022.6.15)Requirement already satisfied: charset-normalizer&lt;3,&gt;=2 in /home/muxue/.local/lib/python3.10/site-packages (from requests-&gt;yarg-&gt;pipreqs) (2.1.1)Installing collected packages: docopt, yarg, pipreqs  DEPRECATION: docopt is being installed using the legacy &#x27;setup.py install&#x27; method, because it does not have a &#x27;pyproject.toml&#x27; and the &#x27;wheel&#x27; package is not installed. pip 23.1 will enforce this behaviour change. A possible replacement is to enable the &#x27;--use-pep517&#x27; option. Discussion can be found at https://github.com/pypa/pip/issues/8559  Running setup.py install for docopt ... doneSuccessfully installed docopt-0.6.2 pipreqs-0.4.11 yarg-0.1.9\n\n使用  安装完成后，使用下面的语句来生成文件\npipreqs . --encoding=utf8 --force\n\n这个语句的意思是生成  当前目录的项目  所用到的包的 requirements 文件\n\n可以看到，用这个项目生成的文件，包少多了，且确实是本项目需要用到的！\n3. 创建 venv 虚拟环境进行测试  为了方便进行测试，这里我以创建一个新的 python 虚拟环境为例\n3.1 创建虚拟环境  先来吧项目的代码复制到一个新的文件夹，创建一个虚拟环境\npython -m venv botest\n\n这会在当前目录下创建一个 botest 文件夹\n此时我们使用 pip list 查看当前环境下安装了什么包\n[muxue@bt-7274:~/kook/test]$ pip3.10 listPackage                Version---------------------- -----------aiofiles               0.8.0aiohttp                3.8.1aiosignal              1.2.0aliyun-python-sdk-core 2.13.36aliyun-python-sdk-kms  2.16.0APScheduler            3.9.1async-timeout          4.0.2attrs                  22.1.0certifi                2022.6.15cffi                   1.15.1charset-normalizer     2.1.1click                  8.1.3colorama               0.4.6crcmod                 1.7cryptography           38.0.2docopt                 0.6.2Flask                  2.2.2frozenlist             1.3.1h11                    0.14.0idna                   3.3itsdangerous           2.1.2Jinja2                 3.1.2jmespath               0.10.0khl.py                 0.3.7MarkupSafe             2.1.1multidict              6.0.2numpy                  1.24.1oss2                   2.16.0pandas                 1.5.2Pillow                 9.2.0pip                    22.3.1pipreqs                0.4.11pycparser              2.21pycryptodome           3.15.0pycryptodomex          3.15.0python-dateutil        2.8.2pytz                   2022.2.1pytz-deprecation-shim  0.1.0.post0requests               2.28.1riot-auth              1.0.3setuptools             63.2.0six                    1.16.0tzdata                 2022.2tzlocal                4.2urllib3                1.26.11uvicorn                0.18.3valorant               1.0.4Werkzeug               2.2.2yarg                   0.1.9yarl                   1.8.1zhconv                 1.4.3\n\n你会发现还是有很多包啊？这是因为我们只创建了虚拟环境，还没有启动它！\n3.2 启动 &#x2F; 关闭虚拟环境  用下面的命令启动\n[muxue@bt-7274:~/kook/test]$ source botest/bin/activate(botest) [muxue@bt-7274:~/kook/test]$ \n\n如果是 windows，要用如下命令\n./botest/Scripts/activate\n\n你会发现命令行前面多了一个(botest), 这就代表我们的虚拟环境启动成功了\n(botest) [muxue@bt-7274:~/kook/test]$ pip3.10 listPackage    Version---------- -------pip        22.2.1setuptools 63.2.0\n\n再次执行，发现只剩下两个默认的包了，这才是对的！\n要想退出虚拟环境，用下面的语句即可\ndeactivate\n\n3.3 测试  代码拷贝过来了，假设我们现在就是一个刚刚克隆了此仓库，要使用项目的程序猿\n此时我们需要利用 requirements.txt 快速安装需要的包\npip install -r requirements.txt\n\n他会开始一个个安装所需要的包，以及这些包所需要的依赖项；和我们手动安装包是一个效果\n\n随后就出现了一个意料之中的报错\n\n这是因为 riot_auth 这个包，并没有在 pypi 里面注册，其安装的方式是用 git 安装的\npip3.10 install git+https://github.com/floxay/python-riot-auth.git\n\n使用 pip freeze 创建出来的 txt 文件里面的依赖项，才是正确的包\nriot-auth @ git+https://github.com/floxay/python-riot-auth.git@e70f76002728b99005baccd6fe3157c03d4d9f02\n\n这也是我目前发现的该项目的一个 bug，已经提交了 issue 了！\n\nhttps://github.com/bndr/pipreqs/issues/350\n\n既然知道问题的情况，那就手动弄一下吧！不过需要提醒的是，这种 git 方式的 pip 包经常安装不上，会报下面的错误\n\n个人猜测和 github 的网络环境也有关系，所以得多试几次，或者手动克隆，粘贴到本地 .site-packages 源码里面\n如果一切顺利的话，那应该是能安装完成的！此时就可以愉快的运行项目代码了\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】ValueError:Sample larger than population or is negative 的原因","url":"/posts/2918276452/","content":"ValueError: Sample larger than population or is negative 的原因以及解决办法\n\n\n1. 出现  这几天重构 kook-valorant-bot 的代码的时候，遇到了这个问题\nJob &quot;vip_roll_task (trigger: interval[0:01:20], next run at: 2023-01-25 19:59:21 CST)&quot; raised an exceptionTraceback (most recent call last):  File &quot;/home/muxue/.local/lib/python3.10/site-packages/apscheduler/executors/base_py3.py&quot;, line 30, in run_coroutine_job    retval = await job.func(*job.args, **job.kwargs)  File &quot;/home/muxue/kook/val-bot/code/main.py&quot;, line 793, in vip_roll_task    ran = random.sample(range(0, len(VipRollDcit[msg_id][&#x27;user&#x27;]) - 1), vnum)  File &quot;/usr/local/lib/python3.10/random.py&quot;, line 482, in sample    raise ValueError(&quot;Sample larger than population or is negative&quot;)ValueError: Sample larger than population or is negativeerror raised during taskTraceback (most recent call last):  File &quot;/home/muxue/.local/lib/python3.10/site-packages/apscheduler/executors/base_py3.py&quot;, line 30, in run_coroutine_job    retval = await job.func(*job.args, **job.kwargs)  File &quot;/home/muxue/kook/val-bot/code/main.py&quot;, line 793, in vip_roll_task    ran = random.sample(range(0, len(VipRollDcit[msg_id][&#x27;user&#x27;]) - 1), vnum)  File &quot;/usr/local/lib/python3.10/random.py&quot;, line 482, in sample    raise ValueError(&quot;Sample larger than population or is negative&quot;)ValueError: Sample larger than population or is negative\n\n这部分代码是用来生成抽奖结果的随机数的，在网上百度了报错之后，得知是 random 生成随机数时产生的报错\n2. 复现  找到对应的代码\nran = random.sample(range(0, len(VipRollDcit[msg_id][&#x27;user&#x27;])-1), vnum) # 生成 n 个随机数\n\n这个代码的作用是，生成 vnum 个从 0 到 len(VipRollDcit[msg_id][&#39;user&#39;]) - 1 的随机数，不包含len(VipRollDcit[msg_id][&#39;user&#39;])-1\n\n咳咳，这里又发现了另外一个 bug：我以为是包含右边界的，所以手动 -1 了；现在导致  最后一个  参加抽奖的用户永远都抽不到奖了😥\n正确的 range 应该是(0, len(VipRollDcit[msg_id][&#39;user&#39;]))\n\n但是，如果参与抽奖的人数少于vnum，就会出现上面的报错\nimport randomran = random.sample(range(0, 2), 3) \n\n可以来简单测试一下，这里我想在 0 到 2 之间（其实就是0,1）生成 3 个随机数\n$ py3 test1.pyTraceback (most recent call last):  File &quot;/home/muxue/kook/test/global_val_test/test1.py&quot;, line 16, in &lt;module&gt;    ran = random.sample(range(0, 2), 3)   File &quot;/usr/local/lib/python3.10/random.py&quot;, line 482, in sample    raise ValueError(&quot;Sample larger than population or is negative&quot;)ValueError: Sample larger than population or is negative\n\n此时运行，就会有这样的报错。\n因为这个写法的作用是在 0-2 之间产生  不重复  的随机数，你的目标数量都大于这个集合之中已有数据的数量了，那要怎么生成不重复的随机数呢？\n3. 解决  解决办法很简单\n\n右边界不能  等于或者小于  左边界\n产生随机数的数量要  小于  边界之中数据的数量\n\n比如上面的代码，我们修改一下边界，就能获得正确的结果\nimport randomran = random.sample(range(0, 3), 3) print(ran)\n\n运行\n$ py3 test1.py[0, 2, 1]\n\n对于我的抽奖代码而言，则需要重新操作一番。即可能出现奖品数量  大于  参与抽奖的人数的情况；\n这时候就需要进行判断了\n\n奖品数量  少于  抽奖人数，使用 random 生成随机数\n奖品数量  大于  抽奖人数，抛弃多余奖品，直接生成一个从 0 到总人数的列表\n奖品数量  等于  抽奖人数，上面两种情况都可以用\n\n代码如下\n# 人数大于奖品数量if len(VipRollDcit[msg_id][&#x27;user&#x27;])&gt;vnum: \tran = random.sample(range(0, len(VipRollDcit[msg_id][&#x27;user&#x27;])), vnum) # 生成 vnum 个随机数else: # 生成一个从 0 到 len-1 的列表 如果只有一个用户，生成的是[0]\tran = list(range(len(VipRollDcit[msg_id][&#x27;user&#x27;])))\n\n这时候就 ok 了，没有问题了\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【方法分享】准大学生如何自学 C 语言","url":"/posts/4266945915/","content":"【方法分享】准大学生如何自学 C 语言\n\n\n[TOC]\n准大学生如何自学 C 语言  虽说现在已经接近我们最长的且无忧无虑的暑假的尾声\n但我估摸着很多小伙伴还是和我一样整天摸鱼，不知不觉就浪费了一天\n（其实只有我在摸鱼对吗，流下了不争气的泪水）\n不扯这些没用的，进入今天的正题\n本篇博客和大家分享一下我是如何自学 C 语言的，以及如何做学习笔记\n学习方法各不相同，请以自身情况为准\n一、找寻一个优质教学视频  好的教学资源永远是我们学习的第一步!\n在这里我建议以视频为主，书本为辅助\nC 语言的书籍繁多而杂，有很多热销书籍并非出自名门大家，有纰漏在所难免。作为初学者的我们肯定看不出这些纰漏，但它可能会把我们的学习引入死胡同。\n视频同样也会有错误的地方，这也是为何我们需要寻找  优质教学视频\n在看视频的基础上，复以书本练习为辅助，方为学习妙计（个人观点）\n在这里强烈推荐 b 站  比特鹏哥  的 C 语言教学视频 连接\n\n讲的非常非常非常详细，比我之前在  某堂在线  找到的不知名视频好太多了（那个视频里老师就对着你念 ppt，枯燥乏味无干货）\n这里推荐大家直接去看最新版本的视频，画质更好。内容新旧基本是一样的\n找完视频之后请立马开动，收进收藏夹只会让你开学了进度还是 0%\n不过想必来 csdn 看博客的你已经不是小菜鸡了（doge）\n二、使用优质编译器  拒绝 devc++ 学习 C 语言\n当然，它肯定能用，我也推荐你在电脑里面下一个 devc++\n但是它不适合日用学习！！\n理由非常简单，让我们看看 VS2019 和 devc++ 在同一个代码下的界面\n\n请问那边更容易让你眼花缭乱？视觉疲劳？\n(你要说 vs 颜色太多眼花缭乱，那我无力反驳)\n\nvs2019 同样可以改成白色背景，但深色对比度更高推荐深色\n\n同样的，当我们输入库函数的时候，vs 可以帮你补充剩下函数\n而 devc++ 就需要看你背单词的功力了\n\n而且在遇到代码错误的时候，vs2019 能更准确地报出错误的地方，\n有些中英文半角错误的符号，如分号、逗号。vs2019 都会用一个小波浪线标出，而 devc++ 莫得提示\n（讲道理初学的我最常犯的错误就是打错中英文半角 + 打错函数名……）\n\n前面提到建议在电脑里面下个 devc++，因为 vs2019 不能直接运行.c 文件，必须要把它放在一个“项目”里面才行\n对于单个文件的运行来说 devc++ 更方便，可以把它当作一个简易的.cpp 和.c 的运行器\nVS2019 可以直接在官网下载  社区版本，请不要下载 VS code，对于初学者来说它的初始化设置非常麻烦！\n官网链接 &#x3D;&gt;visualstudio.microsoft.com\n(由于微软的土豆服务器，我打不开官网，自然截不到图……太棒了微软)\n\n博客写到一半回去瞅了一眼，终于打开了\n我们需要下载的是 2019 的社区版本\n\n其次我们还需要收藏几个用于学习时查找资料的网站\n它们主要是用于查找函数定义的，具体方法我在之前的博客中已有过分享 [链接]网站推荐：\ncplusplus.com - The C++ Resources Network \ncppreference.com\n三、安排一个电子笔记  初学 c 语言时的知识繁多而杂，不记笔记的话很多知识点都是左耳进右耳出（至少我是这样）\n纸质笔记本在这种需要大量代码练习的学习中效率太低\n这时候就得请出我们的电子笔记本了\n在这里给大家推荐个人认为最好用的OneNote\n\n如果你是笔记本用户，有出厂赠送的 OneNote2016\\2019，直接用即可\n台式机用户 OneNote 多半是装系统就自带了的。没有的话可以去微软商店下一个OneNote for WIN10，或微软官网下载 OneNote2019\n\n\n优点：IOS\\ 安卓 \\WIN\\MAC 全平台同步，免费！\n缺点：微软土豆服务器，有时候跨平台同步极慢。\n\n同时建议大家下载一个snipaste，作为截图软件辅助我们的电子笔记\n\nOneNote 自带的截图会自动给你添加一个截图时间，有点影响界面观感\n\n\n新建一个笔记本，命名为 c 语言\n\n\nOneNote 主要的界面就是这种三段式的笔记夹。大家可以参照我的分类，把大类知识点放在第一个分区，小类放在第二个\n这样我们后期复习 or 回看遗忘知识点也会更加方便\n这里建议大家给每个小类知识点都做上数字序号，且不要重复\n这样就可以在已有的笔记内表明这个知识点和另外一个知识点的联系\n\nOneNote 的插入链接功能同样可以插入笔记本内页的连接\n如图，我们右击 16EOF，点击”复制指向页面的链接“\n\n然后在我们想插入这个链接的位置插入\n\n\n随后点击它，就能直接跳转到指定的笔记本页面\n在复习和知识点联动的时候非常方便实用\nOneNote 还有其他非常丰富的功能，在这里推荐大家看这个视频学习 OneNote 的用法，博客里就不再展开了\n岷 | 你不得不知道的 OneNote 功能 | 电子笔记能有多强！bilibili\n需不需要一个 ipad 来辅助学习？提到电子笔记，很多人都会想到用平板来做笔记\n这里我的建议是\n- 有 ipad 或其他平板的用户可以购入  平替笔  尝试\n\n不要直接买高贵的原装笔，对于做笔记来说无济于事，特别是 ipad\n发现不合适的时候你想二手出 or 吃灰就是浪费钱了，平替笔 90 一支不想用了也可以留着\n最好在购入七天内使用并判断这种方式适不适合你，这样不适合还能无理由退了\n\n\nipad 用户推荐益 b 思的 5 代青春版平替笔，98 一支，真的不是广告，我个人觉得还行顺便提一句而已！\n\n- 如果你没有平板，请不要给自己创造需求然后喜加一，因为平板联网激活后就不给退货的！\n在我两周的 win 电脑 + 平板做笔记的学习中，有如下问题需要注意\n\nOneNote 同步需要一定时间，在电脑截图后 ipad 端 OneNote 同步至少 20 秒。服务器抽风的话就祝自己好运了\n在 ipad 做笔记可能会让你漏掉老师所讲知识点，因为注意力不在电脑屏幕上，导致回退视频\n请不要在 ipad 打开你的 qq，不然可能做着做着就去聊天了……\n\n当我尝试丢掉平板直接用电脑做笔记的时候，发现效率直线上升！\n所以说用平板做笔记也是我自己给自己创造的需求（笑哭.jpg）\n四、除工具以外的学习方法  上述三点都是围绕学习工具来展开的，现在说说其他的一些个人经验\n1. 专心致志，不要让其他东西分心  现在这个阶段，我们的身心是很放松的，自学 c 语言其实是在给暑假生活的末尾加料\n这种放松会让你我觉得 C 语言的学习并不是什么必须要做的、非做不可的事情\n所以手机就会成为你学习路上最大的阻碍……（以下均为本人情况，请勿对号入座）\n\n消息来了看一眼\n\n这部分好像我会，刷会手机\n\n\n虽然我知道这万万不可，可就是控制不住自己这双手\n\n好吧，既然打不过，那我们就跑啊！\n手机关闭 WiFi，放在你不能直接够到的地方\n同样的，电脑也不要登录 qq，wx，保持无线电静默，专心看视频学习\n\n我觉得咱们这个年纪应该没有非回不可的消息，父母找自己多半直接打电话\n\n2. 多练习，多练习，多练习  学 C 语言和学数学一样，一定要多刷题（写代码）\n在看视频的同时，跟着教学内容自己尝试着写写那些代码\n别觉得视频里都打了没必要自己再打一遍\n实际上照着打都会有一堆错误……\n买了书本的小伙伴可以照着书本上的示例代码练习\n在练习的途中更容易发现自己的问题，从而获取更多知识\n3. 复习！前面提到了做笔记之事，笔记最主要的目的就是为了方便我们日后的复习。\n这里建议平时多去看看记录下来的操作符、字符类型、转义字符等等极其容易遗忘又经常用的上的知识点\n不然有时候就真的只能看着代码蒙蔽\n遇到新的小知识点的时候也要及时对笔记进行补充\n\n结语  以上就是本 c 语言初学者 + 准大一同大家的学习方法的分享\n这方法可能不适合你，有些朋友可能更偏爱纸笔笔记，这都是 OK 的\n学习方法各有异同，但我们都有一个为通向未来大道而努力的心\n这就够了~\n感谢你看到这里，点赞 + 关注再走呗！万分感谢！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】传值调用和传址调用","url":"/posts/2967424184/","content":"今天学习 C 语言的时候，接触到了两个全新的概念  话不多说，就此和大家分享一下 c 语言中函数的传  值调用和传  址调用，希望有所帮助  欢迎 dalao无情指正！\n\n\n引子 : 交换函数  我们先来写一个简单的函数\n目的是交换 a 和 b\n#include&lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint b = 20;\tint tmp = 0;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);// 显示 a 和 b 最初的值\ttmp = a;\ta = b;\tb = tmp;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);// 查看交换结果\treturn 0;&#125;\n\n运行的结果如图\n\n需要注意的是，这是在主函数 main 里面直接进行的交换程序，而我们想要的其实是一个可以在任何地方使用的交换函数\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint b = 20;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\tswap1(a, b);\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\treturn 0;&#125;\n\n若想达成以上目的，我们要先把上述代码优化成以下形式。其中 swap1 就是我们即将要写的  自定义函数\nvoid swap1(int x, int y)&#123;\tint tmp = 0;\ttmp = x;\tx = y;\ty = tmp;&#125;\n\n\nvoid表示自定义函数无返回类型\n\n这个自定义函数看起来没什么问题对吧！\n但是结果却告诉我们 a 和 b 并没有被交换\n\n这是为什么？\n查错方法  这里给大家介绍一个老师教授的查错方法。虽然我估计大家都知道（小声 bb）\n那就是用 vs 编译器自带的监视器了（快捷键 f10，我用的是最新的 vs2019，官网即可免费下载使用）\n\n\n左边有个很 Q 的黄色小箭头，告诉你正在监视那一步\n每按一次 f10 代码就会往下走一行\n当遇到 swap 此类函数时，按 f11 进入函数，f10 会直接跳过函数\n\n\n可以看到代码在第 25 行的时候，x 和 y 已经获得了 a 和 b 的值，tmp 此时为 0\n\n下一行继续，tmp 变成 10\n\n再下一行，x 获得 y 的值，x&#x3D;20\n\n然后 y 获得 tmp 里面保存的 x 的值，y&#x3D;10\n\n可当我们下一步跳出函数，回到主函数的时候\n会发现 a 和 b 仍然是 10 和 20，并没有发生交换\n\n聪明的你肯定已经想到这是为什么了\n函数中的 x 和 y 与主函数的 a 和 b 是独立的，x 和 y 的变化无法影响 a 和 b\n那怎么样函数中的 x 和 y 才能影响函数外的 a 和 b，从而达到我们交换的目的呢?\n这里需要涉及一个新的  大家都知道的  概念\n&amp; 取地址操作符  先用一个简单的例子让大家了解 &amp; 取地址操作符的作用\n在我们的 c 语言中，每个字符都对应了一个它独自的地址\n而 &amp; 符号就是取出这个字符的地址\nint main()&#123;\tint a = 10;\tint* pa = &amp;a;//pa 指针变量\t*pa = 20;// 解引用操作\tprintf(&quot;%d\\n&quot;, *pa);\treturn 0;&#125;\n\n这里面的 *pa 获取了 a 的地址，在打印的时候会顺着地址找到 a，显示 a 的结果\n让我们继续\n我们将上述交换函数代码的主函数改成如下形式\nint main()&#123;\tint a = 10;\tint b = 20;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);    //swap1(a, b);\tswap2(&amp;a, &amp;b);\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\treturn 0;&#125;\n\n比较 swap1 和 swap2，会发现 swap2 括号中的 a 和 b 前面都多了一个 **&amp; 操作符 **\n这个操作符会让 swap2 不再读取 a 和 b 的  数值，即 10 和 20\n而是会读取 a 和 b 在内存中的  地址\n相对应的，swap2 函数也要改成如下形式\n其实形式和 swap1 基本一样，只是 x 和 y 被替换成了 **pa 与 pb\nvoid swap2(int* pa, int* pb)&#123;\tint tmp = 0;\ttmp = *pa;\t*pa = *pb;\t*pb = tmp;&#125;\n\n\n表明 pa 和 pb 都是 *指针变量\npa 和 pb 保存的是 a 和 b 的  地址\n\n这时候我们再运行代码，a 和 b 被很好的调换了\n我们的目的也达成了\n\n实参和形参  要想了解为什么两个函数会有这样的不同\n我们需要学习  实参（实际参数）和形参（形式参数）\n\nvoid swap1(int x, int y)&#123;\tint tmp = 0;\ttmp = x;\tx = y;\ty = tmp;&#125;void swap2(int* pa, int* pb)&#123;\tint tmp = 0;\ttmp = *pa;\t*pa = *pb;\t*pb = tmp;&#125;int main()&#123;\tint a = 10;\tint b = 20;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\t//swap1(a, b);\tswap2(&amp;a, &amp;b);\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\treturn 0;&#125;\n\n\n在这串代码中，a 和 b 是实参\nx、y、*pa、 *pb 都是形参\n\n可以借用另外一个代码的例子进一步给大家了解实参\nint get_max(int x, int y)&#123;\tif (x &gt; y)\t\treturn x;\telse\t\treturn y;&#125;int main()&#123;\tint a = 10;\tint b = 20;\tint max = get_max(a, b); \tprintf(&quot;max= %d\\n&quot;, max);    max = get_max(100,300);    max = get_max(100,300+1);// 实参可以是表达式\tmax = get_max(100, get_max(3, 5));// 也可以是函数\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n在这串代码中，抛去上面的 a 和 b\n max &#x3D; get_max(100,300); 是我们使用这个函数的基本方式\n\n这里面的 100 和 300 是实参\n同时 **300+1 和 get_max(3, 5)** 也是实参\n对应的函数中的 x 和 y 就是形参\n\n\n当实参传给形参的时候  形参其实是实参的一份临时拷贝  对形参的改变是不会改变实参的\n\n这样解释大家应该对实参和形参有一定的认识了\n接下来就有请我们的标题人物隆重登场\n传值调用，传址调用  这两个调用方式十分重要，而且两个字从读音到长相（bushi）都十分相似\n所以大家一定要注意区分！\n\n简而言之\n\n当我们需要在函数内部操作函数外部的变量的时候→传址调用\n如果我们只需要外部变量的值，不需要改变外部变量→传值调用\n\n以上面的交换函数为例子\nvoid swap1(int x, int y)// 传值调用&#123;\tint tmp = 0;\ttmp = x;\tx = y;\ty = tmp;&#125;void swap2(int* pa, int* pb)// 传址调用&#123;\tint tmp = 0;\ttmp = *pa;\t*pa = *pb;\t*pb = tmp;&#125;\n\n因为 swap1 里面的 x 和 y 是传值调用，x 和 y 只获取了 a 和 b 的值，自然无法影响函数外面的 a 和 b\n而 swap2 中的 *pa 和 *pb 获取的是 a 和 b 的地址（址→地址）所以可以影响函数外的 a 和 b，实现它们的交换\n\n注：x，y，*pa ， *pb 都是局部变量，它们在出了函数外之后就无法使用，也失去了使用它们的意义\n\n结束语  本篇小博客到这里也结束啦，感谢你看到最后！\n如果感觉看完之后仍有不明白的地方\n可以去观看这期视频里面的讲解，swap 函数的讲解在 1 小时 17 分【点我跳转】\n我也是刚学 C 语言的小白，博文有错在所难免，请各位大佬  无情指正\n这篇博文虽然字不多，但依旧花了我 2 小时的时间，如果觉得不错就  点个赞  再走吧！\n求求了，跪谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【Python】自动解析 markdown 中的图片并保存","url":"/posts/3761902412/","content":"python 自动化下载 &#x2F; 上传 md 中图片实在是太方便了\n\n\n1. 起因  为什么需要 python 来下载 md 里面的图片？原因很简单，那就是需要把图片保存下来，上传到第二个图床（迁移）\n对于阿里云 OSS 来说，有两种迁移办法\n\n使用官方的数据导出功能\n使用 api 接口遍历 oss 目录下载所有图片\n\n这两种办法都不是那么方便，所以我选择了第三种\n\n解析本地 md 文件中的 img url，下载图片并保存到本地\n\n那要怎么做呢？👇\n2. 教程  我在 github 找到了这个项目 👉 Deali-Axy&#x2F;Markdown-Image-Parser\n作者的代码写的很棒，但是 README 里面却少了一个重要的启动教程，那就是你需要在当前目录下创建一个 files 文件夹（md 文件放到这里面），对应启动项里面开启的根目录\nif __name__ == &#x27;__main__&#x27;:    files_list = get_files_list(os.path.abspath(os.path.join(&#x27;.&#x27;, &#x27;files&#x27;)))\n\n随后，执行python spider.py，开始运行，脚本会自动将 md 转成 html 并下载图片\n我将作者的代码进一步细化，并修改了一部分 bug👇建议使用我 fork 的版本\nhttps://github.com/musnows/Markdown-Image-Parser\n2.1 UnicodeDecodeError在启动的时候，你可能会遇到这个报错\nUnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xbc in position 2: invalid start byt\n\n解决办法参考 👉 点我\n解决办法是将打开文件编码的utf-8 修改成ISO-8859-1\nwith open(file, encoding=&#x27;ISO-8859-1&#x27;) as f:           md_content = f.read()\n\n2.2 request failed因为作者并没有写判断，此时就会出现一个严重问题：本地图片也会进行 requests 请求\n比如我的 md 里面就有一些图片是本地的img/ 图片文件名，这个代码依旧对这个路径当做网络路径进行请求，于是就出现了报错\n所以就需要在 download_pics 函数中对 url 进行判断，这里可以写成下面的格式（因为我知道我的阿里云 OSS 链接里面不包含 img 文件夹，所以 img/ 的图片是本地文件\ndef download_pics(url, file,MDfilename):    if &#x27;img/&#x27; in url:        print(&#x27; 不处理本地图片: &#x27;, url)        return\n\n但是这样其实还是有点呆呆的，我们直接判断 http 在不在里面不就知道是不是网络图片了😂\ndef download_pics(url, file,MDfilename):    if &#x27;http&#x27; not in url:        print(&#x27; 不处理本地图片: &#x27;, url)        return\n\n2.3 图片保存路径  默认情况下，图片会保存到子文件夹下的 markdown 文件名目录\ntarger_dir = os.path.join(dirname,assert_dir)if not os.path.exists(targer_dir):     os.mkdir(targer_dir)\n\n这样其实非常非常不方便管理，有几个 md 文档就有几个 md 图片路径，可太难受了\n所以我们需要注释掉这部分代码，直接选择一个根目录进行图片的保存\ntarger_dir =&#x27;./files/img/&#x27; # 所有图片都保存到 ./files/img/ 文件夹里面\n\n2.4 try&#x2F;except作者代码里面的最最最大漏洞，那就是没有对 for 循环里面的请求进行try/except\n这样就会导致，如果有一个图片请求失败，整个  进程会直接终止！\n那么问题就来了，即便这个程序会在遍历的时候打印当前处理的文件名字，但这需要用户去翻命令行输出，再找到到底是哪一个图片发生错误，非常非常非常难受！\n如果重新执行，那就相当与把已经下好的图片又重下一遍，浪费 OSS 的流量。\n所以我们必须要给 for 循环内部添加上异常捕获，如果遇到错误，就将这个图片的 url 存下来，继续往后执行！\nfor file in files_list:    print(f&#x27; 正在处理：&#123;file&#125;&#x27;)    with open(file, encoding=&#x27;ISO-8859-1&#x27;) as f:        md_content = f.read()    pics_list = get_pics_list(md_content)    print(f&#x27; 发现图片 &#123;len(pics_list)&#125; 张 &#x27;)    for index, pic in enumerate(pics_list):        try:            print(f&#x27; 正在下载第 &#123;index + 1&#125; 张图片...&#x27;)            MDfilename = os.path.basename(file) # 当前处理的 md 文件的名字            download_pics(pic, file,MDfilename)            time.sleep(0.5) # 避免下载超速        except KeyboardInterrupt:            os.abort()        except:            print(traceback.format_exc())            if MDfilename not in err_img:                err_img[MDfilename]=[]            # 添加图片            err_img[MDfilename].append(pic)            print(&quot; 图片获取错误：&quot;,pic)            time.sleep(1)print(f&#x27; 处理完成。&#x27;)write_file(&#x27;err.json&#x27;,err_img)print(f&#x27; 写入 err 完成 &#x27;)\n\n完整代码见我的 github 仓库\n2.5 上传到 lsky 图床  现在我要迁移的图床是 lsky，所以为了方便，可以在将图片保存到本地的同时，将图片上传到 lsky 图床\n注意，上传之前，请在  用户组  将图片上传的格式改为原始文件命名，否则重命名了那就什么都没了！\n\n\n还发现了一个离谱的问题，那就是一些图片上传了之后，lsky 还是会给他改名字！！！\n\n比如这个 gif，他的 alt 里面是原始名字，但是 url 并不是！！！你说这离谱不\n解决方法那就是把本地的图片打一个压缩包，传到云服务器后台存储路径中覆盖一遍，把没有的图片给添加上\nunzip -o ~/docker/img.zip -d ~/docker/lsky/storage/app/uploads/23/02\n\n上传之前，先获取 token\ndef lsky():    url = &quot; 服务器地址 /api/v1/tokens&quot;    params = &#123;        &#x27;email&#x27;:&#x27; 账户邮箱 &#x27;,        &#x27;password&#x27;:&#x27; 密码 &#x27;    &#125;    res = requests.post(url,  params=params)  # 请求 api    return res.json()\n\n结果如下\n&#123;&#x27;status&#x27;: True, &#x27;message&#x27;: &#x27;success&#x27;, &#x27;data&#x27;: &#123;&#x27;token&#x27;: &#x27; 这里会返回 token&#x27;&#125;&#125;\n\n随后是上传的代码，注意兰空必须要用 open &#39;rb&#39; 重新打开一边图片，所以参数给 img_path 也就是图片的路径即可\n# 兰空图床def lsky_upload(img_path:str):    url = &quot; 你的兰空图床服务器 /api/v1/upload&quot;    header = &#123;        &quot;Authorization&quot;: &quot;Bearer 你的兰空 token&quot;,        &quot;Accept&quot;: &quot;application/json&quot;    &#125;    img = open(img_path, &#x27;rb&#x27;)    params = &#123;&#x27;strategy_id&#x27;: 1&#125;    myfiles = &#123;&#x27;file&#x27;: img&#125;    res = requests.post(url, headers=header, params=params,                        files=myfiles)  # 请求 api    return res.json()\n\n在 download_pics 的末尾添加如下代码，并对兰空图床的返回值进行判断，如果上传错误，同样添加到错误图片中！\n# 上传 lskyres = lsky_upload(img_path=f&quot;&#123;targer_dir&#125;/&#123;filename&#125;&quot;)print(res)if not res[&#x27;status&#x27;]:    global err_img    if MDfilename not in err_img:        err_img[MDfilename]=[]         err_img[MDfilename].append(url)    print(&quot; 兰空上传错误！&quot;,url)    time.sleep(1)\n\n上传成功的返回值 status 是 True\n3. 开始自动化上传  将上面的 bug 修改好了之后，就可以正式运行，在保存图片到本地的同时，上传到兰空图床了！\n\n图片也都成功保存到本地了\n\n上传完毕之后，也能在 err 里面看到错误的图片路径，以便重新处理。\n可以看到这里面有一部分是 gitee 和 csdn 的链接，这些图片有  防盗链，而且图片尾部添加了其他字段，导致 lsky 没有办法将其识别为图片（却少图片格式后缀）\n不过我的目标是将  阿里云 OSS 的图片转到 lsky，这些本来就不是阿里云 OSS 的图片和我的目的无关！\n\n做完这一切，最让我感慨的是，我的阿里云 oss 里面有 1g 的图片，实际用的却只有下面这一丢丢；其他估计都是重复上传的\n\n","categories":["速通Python"],"tags":["Python","图床"]},{"title":"【C 语言】sizeof 操作符","url":"/posts/4048071056/","content":"@[toc]\nsizeof 操作符  上篇博客提到了一个知识点  【链接】\n\nsizeof 操作符括号内的表达式是不会真正计算的\n\n这个是为什么呢？\n我们先来看看 sizeof 的基本用法\n基本用法#include&lt;stdio.h&gt;int main()&#123;\tint a=10;\tprintf(&quot;%d\\n&quot;,sizeof(a));\tprintf(&quot;%d\\n&quot;,sizeof(int));\t\tprintf(&quot;%d\\n&quot;,sizeof a);\treturn 0; &#125; \n\n打印结果为 3 个 4\n但当我们以这种方式书写的时候，编译器就会报错\nprintf(&quot;%d\\n&quot;,sizeof int);\n\n\n\n在使用 sizeof 的时候，变量 a 的括号可以省略\n\n但直接计算 int 的时候，括号不能省略\n\n\n\n 这说明 sizeof 是一个操作符，而不是函数\n\nint arr[10]=&#123;0&#125;;printf(&quot;%d\\n&quot;,sizeof  (arr));printf(&quot;%d\\n&quot;,sizeof  (int[10]));\n\n这两句代码打印的都是 40，其中 int[10]是 arr 数组的类型\n\n 冷知识，我们可以用 9[arr]来访问数组元素\n 但这么做会降低代码的可读性，所以我们还是采取 arr[9]的形式更好\n\nint arr[10]=&#123;0&#125;;arr[9]=1;printf(&quot;%d\\n&quot;,9[arr]);\n\n\n\nsizeof 和函数传参  先来看看下面这个代码\n#include&lt;stdio.h&gt;void test1(int arr[])&#123;\tprintf(&quot;%d\\n&quot;,sizeof(arr));//4&#125;void test2(char ch[])&#123;\tprintf(&quot;%d\\n&quot;,sizeof(ch));//4&#125;int main()&#123;\tint arr[10]=&#123;0&#125;;\tchar ch[10]=&#123;0&#125;;\tprintf(&quot;%d\\n&quot;,sizeof(arr));//40\tprintf(&quot;%d\\n&quot;,sizeof(ch));//10\ttest1 (arr);\ttest2 (ch);\t\t\treturn 0; &#125; \n\n32 位平台，打印结果如下\n\n\nVS 编译器下\nx86–32 位–int 4\nx64–64 位–int 8\n\n为什么在 main 函数里面打印的是 40 和 10\n到了函数里面就只有 4 了呢？\n数组传参  数组在传参的时候，传过去的只是首元素的地址\n\n数组名代码数组首元素的地址\n\n问：为什么字符变量只占一个字节，但这里打印的是 4 呢？\n答：这里传入的是 char 数组的指针，指针变量都是 4 个字节\n\nsiezof 和表达式  现在就到我们的重点了\n为什么 sizeof 括号里的表达式没有真正地运算？\nshort s=5;int a=10;printf(&quot;%d\\n&quot;,siezof(s=a+2));printf(&quot;%d\\n&quot;,s);\n\n\n这里就牵扯到 C 语言程序运行的几个步骤了\n\n编译–test.c\n链接\n运行–test.exe\n\n简单地说，只有在链接之后运行的代码，才会真正给 a 赋值\n而 sizeof 括号中的语句，是在  编译  中运行的\n程序会先计算这个表达式，推断出它的长度，再返回给 printf 打印\n所以，sizeof 括号内的表达式不会真的给 S 赋值\n你明白了吗？\n\nsizeof 和 strlen 的区别  再求字符串的长度的时候，我们可以使用 sizeof，也可以使用 strlen\n这两个的主要区别如下\n\nsizeof 会计算整个数组内字符串的长度，包括字符串暗藏的’\\0’\nstrlen 计算长度的时候，遇到’\\0’后停止\n\n在使用的时候，我们需要注意 sizeof 在计算长度的时候是会比 strlen 多算一个的\n根据具体情况选择 sizeof 或者 strlen\n\n结语  这篇博客迟到太久了，最近实在是有点忙\n如果有错误，还请各位 dalao 指出！万分感谢！\n高数太难了啊啊啊啊啊！（哭唧唧）\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【Python】教你白嫖 replit 部署 kook-ticket-bot","url":"/posts/2556995516/","content":"教你白嫖 replit 部署 kook 的 ticket 机器人\n\n\n1. 前言  最近有不少老哥来找我咨询有关 ticket 机器人的事情，当前 ticket 机器人需要云服务器才能部署，有些不太友好（要钱啊！而且也不是人人都会安装 python 环境）\n所以在这里利用 replit 和uptimerobot两个平台，给大家介绍一个白嫖的方法，实现部署kook-ticket-bot\n\n该方法理论上支持所有使用 khl.py 框架编写的机器人！\n\n注意！replit 上的免费仓库，默认是  公开  的，也就是所有人都能访问到你这个仓库里面的文件，包括 bot 的 token 和日志信息！若您的 ticket-bot 对数据私密性要求较高，请  自购服务器  或找开发者代为部署！\n2. 准备 2.1 注册账户 这两个平台国内访问缓慢，如果实在进不去，就下载一个steam++(又称 watt toolkit)\n\nhttps://gitee.com/rmbgame/SteamTools/releases/tag/2.8.6\n\n如图，下载 exe 就可以了\n\n安装打开以后，把这一堆无差别勾上，点一键加速，应该就 ok 了，访问会稍微快一点\n\n随后就是注册这两个平台的账户了，应该不需要教吧（doge）\n2.2 打开 gitee&#x2F;github 仓库\nhttps://gitee.com/musnow/Kook-Ticket-Bot/tree/main/code\nhttps://github.com/musnows/Kook-Ticket-Bot\n\n为了方便访问，我将 ticket-bot 在 gitee 也传了一份，大家打开仓库的 code 目录，准备拷贝代码。能使用 github 的，建议用 GitHub（因为 github 的代码更加新）\n2.3 申请 kook 开发者\nhttps://developer.kookapp.cn/app/index\n\n到 kook 的开发者平台，加入官方频道申请承为开发者，获取创建 bot 的权限；有了权限之后，新建一个应用\n\n\n随后进入机器人页面，复制这里的 token，先保存起来，后面要用（一会再来复制也行）\n\n进入邀请页面，给予机器人管理员权限（这样是为了方便，不然得钩一大堆）\n然后复制上面的邀请链接到浏览器，邀请机器人进入你的服务器\n\n\n3. 开始部署 3.1 创建 repl 来到 replit，创建仓库\n\n选择 python，然后给它取个名字\n\n创建之后进入这个项目\n\nimport from github会显示仓库不可用，所以只能手动操作了。\n3.2 添加代码文件  进来之后是这样的页面，只有一个main.py，其他什么都无\n\n点击右侧 shell，复制后，shift+ins 粘贴如下命令，可一建拉取所有代码，并覆盖已有文件。（创建 repl 的时候一定要选择 python，否则 pip 会无法运行）\ngit clone https://github.com/musnows/Kook-Ticket-Bot.git &amp;&amp; mv -b Kook-Ticket-Bot/* ./ &amp;&amp; mv -b Kook-Ticket-Bot/.[^.]* ./  &amp;&amp; rm -rf Kook-Ticket-Bot &amp;&amp; pip install -r requirements.txt\n\n\n如果如上命令不可用，则需要根据我仓库的代码，手动创建同名文件，并将代码复制进去：\n\ngithub 的代码更加新，如果能打开 github，请在 github 复制代码：https://github.com/musnows/Kook-Ticket-Bot\n实在打不开，再来 gitee：https://gitee.com/musnow/Kook-Ticket-Bot/tree/main/code\n\n有一个简便办法，就是在 github&#x2F;gitee 的 clone 按钮中选择下载 zip，然后将 zip 解压后，将文件夹上传上去，并把内部文件移动道根目录。\n\n\n3.3 添加配置文件  如果你直接运行了，会出现如下报错，代表没有找到 config/config.json 文件。即没有找到机器人运行必要的配置文件。\n\n新版本的 ticket 机器人  会自动创建 log 目录下的文件 ，但是config 下的配置文件依旧需要您手动操作！\n接下来就是根据  仓库的 README添加各类配置文件，本文不重复 README 中已有内容。\nconfig/config.json # 机器人 token 配置config/TicketConf.json # ticket 配置# 下面的文件机器人会自动创建，可以不弄log/TicketLog.json # ticket 日志log/TicketMsgLog.json # 消息记录log/ColorID.json # 表情回应上角色\n\n先把如上的几个文件全部建立好，然后根据  仓库的 README往里面添加键值。新版本 log 目录下的文件，机器人会自动创建，可以不手动创建。主要配置 config 即可。\n3.3.1 开启 kook 开发者模式  很多操作都需要复制 ID，先在设置高级设置中开启开发者模式\n\n3.3.2 配置 config下面给出一个 TicketConf.json 中需要配置的几项的样例\n\n\n在这里重申，添加了这两个角色 id 之后，必须要给予用户对应的角色（特别是腐竹）才能操作 bot 的命令，否则提示权限不足\n配置为文件添加完毕之后，应该是下面这样的\n\n3.4 开始运行\n新版本已经采用 logging 来替换 print，不再需要手动配置 logDup\n\n配置文件修改好后，就可以点击顶部的 run，尝试运行 bot 了，变成下面的样子那就是在运行了\n\n3.4.1 安装包  刚开始打印如果提示这个，代表没有找到对应的包\n\n先尝试在 shell 中输入如下命令\npip install -r requirements.txt\n\n如果出现了如图所示的安装页面，那就一切 ok，安装好了再点击 run 就可以了\n\n如果不行。那就在工具 tools 里面选择 packges，搜索 khl.py\n\n\n如下提示，安装成功！\n\n3.4.2 时区问题\n新版本自带的 .replit 文件已经写入了这个配置\n\n运行还会有这个警告\n/home/runner/tk-dev/venv/lib/python3.10/site-packages/tzlocal/unix.py:183: UserWarning: Can not find any timezone configuration, defaulting to UTC.  warnings.warn(&quot;Can not find any timezone configuration, defaulting to UTC.&quot;)\n\n点击显示隐藏文件\n\n打开 .replit 文件，在如下位置添加一行（然而这个时区配置没有用）\n[env]TZ = &#x27;Asia/Shanghai&#x27;# ....\n\n再次运行，就不会有这个报错了\n3.4.3 运行成功  在点击运行，出现如图所示的页面，那就是运行成功了！\n\n因为采用了 webhook 的链接，需要去后台填入callback url，填入后点击重试。如果没有红色字体报错，那就是成功了！\nreplit 给的 url/khl-wh\n\n\n如果不成功，先尝试在浏览器中访问此 url，看看是否出现了405 Method Not Allowed，如果出现了，代表程序正常运行，多点击几次重试即可。这点在 README 里面也有说明\n\n现在进 kook 里面，先测试一下我们的 bot 是否在线\n\n测试通过！后台也打印出了日志\n\n3.5 uptimeRobot别急别急，虽然到这里已经 ok 了，但我们还有一个步骤要做！\n进入 uptimeRobot，需要创建一个监控实例，来调用机器人的 url，保证我们的 bot 不会因为 replit 的策略（5 分钟不活跃就休眠）而下线过久。\n\n使用 webhook 连接，也是为了让 kook 发送报文给机器人的时候，让 repl 不休眠。\n理论上来说，只要你的  服务器用户够多，发言活跃（每次发言，kook 都会发送一条信息给机器人，不管是不是机器人的命令）是可以不用配置 uptimerobot 的。\n但是为了避免机器人在服务器不活跃的时候，无法收到 kook 的报文，而进入休眠态，还是建议大家按教程配置一下 uptimerobot 的监控\n\n\n点击add new monitor，选择 http\n\n\n按如下所示填写\n\nname 随便填个英文名\nurl 填在 replit 复制的链接，后面加上/khl-wh\nintervel 是单次监控的间隔，选择 5 分钟（低于 5 分钟得收费）\ntimeout 默认 30s 不需要修改\n两个 ssl 取消勾选\n\n\n建议勾选上这个，在 bot 下线的时候，会向你的邮箱发送通知\n\n配置完毕，点击右下角的 create\n\n这时候就会开始运行了！下方的 pause 可以暂停运行。\n\n如果你 create 完毕，发现是黑色的，那就点击一下 start 让他开始运行\n3.5.1 自建 uptime-kuma由于免费的 uptimerobot 的监控最低只能选择 5 分钟，正好和 replit 的休眠时间相同，导致即便你设置了 uptimerobot 的 ping，repl 依旧有几率休眠。\n您可以选择在 replit 上面部署一个 uptime-kuma，该项目可以自定义监控时间（无限制）；缺点就是 这个 repl 也需要用请求来进行保活（不确定能否自己请求自己实现保活）\n\nreplit 创建一个新的 repl，在 shell 中输入如下命令，即可一键部署。详细内容参考该项目的README\ngit clone https://github.com/valetzx/uptimekumaonreplit &amp;&amp; mv -b uptimekumaonreplit/* ./ &amp;&amp; mv -b uptimekumaonreplit/.[^.]* ./ &amp;&amp; rm -rf *~ &amp;&amp; rm -rf uptimekumaonreplit\n\n\n温馨提示：replit 的 repl 默认公开，若您部署了 uptime-kuma，请不要把该服务的用户名 &#x2F; 密码设置成任何和您已有其他平台的用户名 &#x2F; 密码相同。\n建议拿张纸记录下一个  随机  字符串作为 uptime-kuma 的密码，避免您常用的密码泄露。\n\n本人已经部署了该服务，若您有 repl 保活需求，可以  加入我的帮助服务器，将您的 replit-url 告知我。\n即：使用我部署的 uptime-kuma 来请求您的 replit-url，实现保活！\n3.5.2 解决 405 错误导致的 down在我 replit 部署机器人，使用 uptimerobot 的时候，遇到了下面的问题。我在 uptimerobot 里面填入了 replit 的 url 如下\nreplit 给的 url/khl-wh\n\n但由于免费版本的 uptimerobot 仅支持 head 请求，而 /khl-wh 路径是只支持 post 请求的。由此便引发了这个问题\n\n\n\n说来奇怪，我其他三个在 replit 上面用 webhook 部署的机器人并没有出现这个问题（理论上来说应该会出现才对）不管这个，有问题我们就解决问题\n\n\n解决办法如下，找到main.py，选中Bot，右键jump to definition，转到定义\n\n或者在左侧选择 show hidden files，进入venv 文件夹\n\n这时候便展开了隐藏的包文件，路径为\nvenv/lib/python3.10/site-packages/khl/bot/bot.py\n\n\n\n我们需要找的文件是\nvenv/lib/python3.10/site-packages/khl/receiver.py\n\n进去之后，找到  大概 180 行  的位置，有一个\nself.app.router.add_post(self.route, on_recv)\n\n复制如下代码替换原有，这个代码的作用是给 /khl-wh 添加 get 请求的支持，这样 uptimerobot 的 head 请求就不会报错了。\n修改的时候，一定要注意代码的缩进，要保证新的代码缩进和旧的代码缩进相同！否则可能导致意想不到的后果。\nasync def on_root(request: web.Request):    return web.Response(body=&quot;khl.py get recv!&quot;,                    content_type=&#x27;text/html&#x27;,status=200)self.app.router.add_post(self.route, on_recv)self.app.router.add_get(self.route, on_root)\n\n配置了之后，重新启动机器人，将 url 粘贴到浏览器，尝试访问\nreplit 给的 url/khl-wh\n\n这时候显示的就不再是 405，而是 khl.py get recv! 了，表明代码修改正确！\n\n这时候去看看 uptimerobot，它的请求就没有出错了！\n\n完美解决！\n4. 下线机器人bot 有一个特殊的 kill 命令。执行此 kill 命令，可以刷新缓冲区。\n避免出现数据在缓冲区中没有写入到文件，导致丢失日志 or 数据文件\n/kill @机器人\n\n\n如果你想退出 bot，建议使用 kill 命令来操作！\n大功告成！现在你可以根据 help 去测试一下各类命令是否能正常工作啦\n\n\n\n注意，关闭 ticket 之后可能会出现这个报错，这是因为用户从来没有给 bot 发送过信息，导致 bot 无法用户发送私信，忽略  此报错即可（新版本已经取消了这个报错）\n\n因为 replit 是免费的，所以 bot 的反应可能有些迟钝，正常情况！\n建议使用 kook 网页版进行测试，如果出现机器人不响应，先刷新一下网页。有很多时候纯粹是 kook 自己的客户端抽风导致命令消息看不到。\n再次提醒  再次提醒！replit 上的免费仓库，默认是  公开  的，也就是所有人都能访问到你这个仓库里面的文件，包括 bot 的 token 和日志信息！\n\n为了规避 token 泄漏造成过大影响，建议  每隔一段时间  就上后台重置 token\n\n若您的 ticket-bot 对数据私密性要求较高，请  自购服务器  或找开发者代为部署！\n关于自购服务器相关事项，可加入帮助服务器咨询我，我可以帮助你  配置服务器的 Python 基本环境\n\n\nPS：请不要误会，我不是卖服务器的，我也没有接广告😂\n\n","categories":["速通Python"],"tags":["Python","Kook"]},{"title":"【C 语言】冒泡排序","url":"/posts/1953150880/","content":"冒泡排序@[TOC]\n无内鬼，直入主题！\n冒泡排序的思想核心是：比较两两相邻的元素，并且可能的话需要交换\n说人话就是\n把原本是 9，8，7，6，5，4，3，2，1，0 的数组\n变成 0 ，1，2，3，4，5，6，7，8，9\n也可以把无序的数组排列为有序（从小到大 or 从大到小）\n基本的流程如下图：\n\n同时我们可以计算出，0·9 这十个数字，重新排列完需要循环 9 次\n也就是 N 个数字需要 N-1 趟的排列\n代码实现  说完了原理，还是需要敲代码来实现\n“老铁们 int main return 0 走一波！”\n#include&lt;stdio.h&gt;int main()&#123;\tint arr[] = &#123; 9,8,7,6,5,4,3,2,1,0 &#125;；// 排序为升序 - 冒泡排序    int sz = sizeof(arr) / sizeof(arr[0]);\tbubble_sort(arr, sz);// 冒泡排序的自定义函数\treturn 0;&#125;\n\n\n一维数组 [] 中的元素个数可以省略\n\nSZ 的位置问题  这里必须要注意的一点是\nsizeof 必须在主函数中计算元素个数\n因为如果在自定义函数中计算的话\nvoid bubble_sort(int arr[])&#123;\tint sz = sizeof(arr) / sizeof(arr[0]);// 放在此处 sz 计算为 1，err    for (i = 0; i &lt; sz; i++)&#125;\n\nSZ 计算出来的结果是 1\n\narr 数组名，传送的是数组首元素的地址\narr 作为形参，无法计算内部元素个数\n对后续要进行的操作如 for 循环中的 i&lt;sz 来说自定义函数中计算的 sz 是无效的\n\n更具体的原因在上一篇博客 《什么是数组名？》 中有介绍\n排除此问题后，sz 计算出的元素个数就是我们的 N\n这里以 i 为趟数，i&lt;sz 指趟数需小于元素个数\nvoid bubble_sort(int arr[], int sz)// 形参 arr 本质是指针&#123;\t// 确定趟数\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;        //\t&#125;&#125;\n\n接着书写第二环的 for 循环，即每一趟冒泡排序的操作\n       // 一趟冒泡排序int j = 0;for (j = 0; j &lt; sz - 1 - i; j++)&#123;\tif (arr[j] &gt; arr[j + 1] )\t&#123;              //\t&#125;&#125;\n\n这里需要注意的是 j 与 sz 的大小关系\n按照前面的流程图，每运行一趟冒泡序列，就会有一个数字被移动到数组的最后面\nN 个元素需要进行 N-1 次冒泡排序，同时经过一趟后，新的最后一个元素无需重新比对排序\n所以 j&lt;sz-1-i \n比较 &amp; 交换  因为 int arr 传入的是指针变量，如果想要自定义函数影响函数外的内容，也必须使用指针变量\n          // 交换int tmp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = tmp;\n\n实际进行两个数字之间的比较和交换的是上述代码\ntmp 这个空盒子也是我们的老朋友了\n总结起来完整的自定义函数如下\nvoid bubble_sort(int arr[], int sz)// 因为在主函数中计算 sz，这里需要加上 int sz&#123;\t// 确定趟数\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\t// 一趟冒泡排序\t\tint j = 0;\t\tfor (j = 0; j &lt; sz - 1 - i; j++)\t\t&#123;\t\t\tif (arr[j] &gt; arr[j + 1] )\t\t\t&#123;\t\t\t\t// 交换\t\t\t\tint tmp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = tmp;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n接下来我们可以用 F10 的监视器查看代码运行情况\n\narr 数组初始化完成，sz 计算得出为 10\n继续进行下一步，arr 数组中的内容成功被排列\n\n冒泡排序完成！\n结语  冒泡排序是对循环语句、自定义函数、下标以及数组的综合运用\n了解它的原理有助于我们写出更为复杂的排列组合代码\n点个赞再走呗，谢谢了！\n","categories":["初识C语言"],"tags":["C语言","算法","排序"]},{"title":"【C 语言】数组名是什么？","url":"/posts/4234112012/","content":"数组名是什么？@[TOC]\n在我们敲代码的过程中，经常要遇到使用数组的地方\n提到使用数组，就离不开数组名\nint arr[10] = &#123; 0 &#125;;//arr 就是数组名\n\n同时我们也经常要用到使用 sizeof 计算数组元素个数的情况\nint sz = sizeof(arr) / sizeof(arr[0]);\n\n所以了解数组名的概念对于我们的 c 语言学习十分重要\n数组名是数组首元素的地址  如题，这个概念在我们创建  自定义函数  的时候尤为重要\n最经常犯的错误就是在自定义函数内部求主函数中 arr 数组的元素个数\nvoid sp1(int arr[])&#123;\tint sz = sizeof(arr) / sizeof(arr[0]);// 放在此处 sz 计算为 1，err    for (i = 0; i &lt; sz; i++)&#125;\n\n这时从主函数传过来的 arr 只有首元素的地址，使用 sizeof 计算得到的 sz 只有 1\n对后续要进行的操作如 for 循环中的 i&lt;sz 来说是无效的\n这是因为 int arr 传到自定义函数中的是  形参\n而  形参 arr是无法计算内部元素大小的\n（具体的代码示例将在下篇博客的  冒泡排序  中展示）\n代码示例 1 sz我们可以用简单的代码来了解不同 arr 的书写方式得到的结果\n#include &lt;stdio.h&gt;int main()&#123;    int arr[10] = &#123; 0 &#125;;\tint sz = sizeof(arr);// 数组名表示整个数组\tprintf(&quot;%d\\n&quot;, sz);\treturn 0;&#125;\n\n可以看到结果是 40，这表明数组中 10 个元素所占用的字节是 40\n在这个代码里面，arr 表示的是整个数组，sizeof 求的自然也是整个数组所占字节的长度\n\n我们可以用下面这串代码得到数组内的元素个数，结果为 10\n#include &lt;stdio.h&gt;int main()&#123;    int arr[10] = &#123; 0 &#125;;    int sz = sizeof(arr) / sizeof(arr[0]);\tprintf(&quot;%d\\n&quot;, sz);\treturn 0;&#125;\n\n\n代码示例 2下面这串代码中，我们使用三种不同的方式键入 arr\n#include &lt;stdio.h&gt;int main()&#123;\tint arr[10] = &#123; 0 &#125;;\tprintf(&quot;%p\\n&quot;, &amp;arr);//1\tprintf(&quot;%p\\n&quot;, arr);//2\tprintf(&quot;%p\\n&quot;, &amp;arr[0]);//3\treturn 0;&#125;\n\n\n我们会发现三次打印的结果是一样的\n\n&amp;arr 取出的是整个数组的地址\narr 作为数组名–&gt; 数组首元素的地址\n&amp;arr[0]取出的是数组首元素的地址\n\n但实际上三者的本质是完全不同的\n可以用 +1 的方式来找出它们的不同之处\nint main()&#123;\tint arr[10] = &#123; 0 &#125;;\tprintf(&quot;%p\\n&quot;, &amp;arr);//1  &amp;arr 取出的是数组的地址\tprintf(&quot;%p\\n&quot;, &amp;arr+1);\tprintf(&quot;%p\\n&quot;, arr);//2\tprintf(&quot;%p\\n&quot;, arr+1);\treturn 0;&#125;\n\n\n可以看到 &amp;arr+1 之后的结果和 arr+1 的结果是不一样的\n\n\n\n&amp;arr+1 与 &amp;arr 之间相差 40\narr+1 与 arr 之间相差 4\n\n这是因为 &amp;arr 代表的整个数组的地址，加 1 即跳过了整个数组\n而 arr 只代表首元素地址，加 1 表示第二位的地址\n总结c 语言中有很多这样的小知识点，需要我们记录并加以了解\n只有理解了为什么，我们才能在后续的学习、代码创作中写出更好的代码\n点个赞再走呗，求求了！\n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C 语言】如何产生数组最大值","url":"/posts/3186646925/","content":"产生数组最大值@[TOC]\n今日风和日丽，是个写（水 ）博客的绝佳时机\n和大家分享一串 C 语言中产生数组中的元素的最大值的代码\n实现方式很简单，我们需要用到 for 循环和 if 语句\n#include &lt;stdio.h&gt;int main()&#123;\tint arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;// 数组初始化\tint max = 0;// 设置一个最大值\tint i = 0;\tint sz = sizeof(arr) / sizeof(arr[0]);// 计算数组元素个数\tfor (i = 0; i &lt; sz; i++)    &#123;\t\tif (arr[i] &gt; max)\t\t&#123;\t\t\tmax = arr[i];\t\t&#125;\t&#125;\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n当我们运行代码的时候，输出的结果是 10\n\n看样子我们成功输出了数组的最大值，这串代码已经完成了，对不对？\n但实际上这串代码是有问题的\n先别往下滑，想想它的问题出在那里了呢？\n——————————————————\n正负性  当我们把数组里面的数字全部改成负数的时候\n你会发现输出的结果等于 0，并不是数组内的最大值 -1\n\n出现这个情况的原理十分简单，我们设定的 int max &#x3D; 0，而 0&gt;-1，输出的结果也自然是 0 了\n解决这个问题的方法也非常简单\n如果我们数组内的数全部小于 0，那我们就设定MAX&#x3D; 数组内的某个数字，然后再进行比较，输出最大值不就行了？\nint main()&#123;\tint arr[] = &#123; -1,-2,-3,-4,-5,-6,-7,-8,-9,-10 &#125;;\tint max = arr[0];//arr[0]对应数组中第一个数的下标\tint i = 0;\tint sz = sizeof(arr) / sizeof(arr[0]);\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tif (arr[i] &gt; max)\t\t&#123;\t\t\tmax = arr[i];\t\t&#125;\t&#125;\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n\n避免不同数组的元素个数不同，max 应该设置为 arr[0]而不是 arr[3]或者 arr[5]\n\n这时候再次运行我们的代码，可以看到结果已经正确的显示为 -1 了\n\n进阶玩法  以自定义函数的形式实现此功能  使用自定义函数的时候，我们需要注意一个问题\n那就是我博客之前写到过的 《传址调用和传值调用》\n先把我们的主函数改造一番\nint main()&#123;    int arr[] =&#123; -1,-2,-3,-4,-5,-6,-7,-8,-9,-10 &#125;;\tint max = arr[0];\tint sz = sizeof(arr) / sizeof(arr[0]);\tsp(arr, sz,&amp;max);\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n其中 sp 就是我们要编写的自定义函数\n\n因为自定义函数中的步骤需要改变我们主函数中的 max，这里我们需要用取地址符，也就是传址调用\n\nsp(arr, sz,&amp;max);//&amp;max 是传址调用\n\n同样的，我们的自定义函数也需要使用 int* 来接收 max 的地址\nvoid sp(int arr[], int sz,int* pm)&#123;\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tif (arr[i] &gt; *pm)\t\t&#123;\t\t\t*pm = arr[i];\t\t&#125;\t&#125;&#125;\n\n运行结果正确\n\n结语  在制作自定义函数的时候，需要注意传  址调用和传  值调用的区别。具体介绍参考我之前的博客 [链接]\n感谢你看到最后，如果对你有帮助的话，点个赞再走呗！\n（没有帮助也可以点点赞~）\n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C 语言】变量的作用域和生命周期","url":"/posts/134934297/","content":"变量的作用域和生命周期[TOC]\n\n1. 全局变量和局部变量  定义在代码块外部的是全局变量\n定义在代码块内部的是局部变量\n什么是代码块？\n// 这是代码快外部int main()&#123;// 这是代码块内部&#125;\n\n实际上用 int main 来演示是不太对的, 实际使用的时候我们定义变量是在 int main 内部定义的\n下面这个例子更加清晰明了\nint main()&#123;\tint i = 0;// 这是代码块外部 -i 全局变量\tfor(i=0;i&lt;10;i++)\t&#123;// 代码块开始\t\tint j=0;// 这是代码块内部 -j 局部变量        for(j=0;j&lt;10;j++)\t&#125;// 代码块结束&#125;\n\n需要注意的是：\n同一个变量 a 可以在全局，局部变量中间同时使用，局部变量优先\n\n这里是指同时存在，同时使用，但不能同时定义\n在局部的代码块中重新定义一个全局变量是错误的\n\n下面这种形式就是 同时使用一个变量\nint main()&#123;    int sz = 8;\tint i = 0;\tif(i&lt;sz)\t&#123;\t\ti=1;\t&#125;&#125;\n\n\n在我们定义变量的时候，变量的名字不能相同\n\n同时变量的名字也不应和库函数名相同\n\n\n简单的说就是变量不要重复，也别和库函数冲突\n2. 变量的作用域  变量的作用域 -&gt; 变量的生效区域\n\n局部变量只在它自己的代码块中生效\n全局变量的作用域是整个代码\n\n注：在 VS 中全局变量的作用域是整个工程\n作用域的规定了变量生效区域\n如果你在局部变量的代码块外部使用这个局部变量\n这样是无效的，无法使用\n2-1. 声名外部变量的方法  在 vs 中全局变量的作用域是整个工程\n但是如果源文件不同，我们需要打一串声明来应用工程文件中另外一个源文件的全局变量\nextern int a\n\n以下是声名变量和定义变量的代码示例\n　　extern int a;// 声明全局变量 a　　int a; // 定义全局变量 a　　extern int a =0 ;// 定义全局变量 a 并给初始值　　int a =0;// 定义全局变量 a, 并给初始值\n\n3. 变量的生命周期  生命周期这个概念和作用域十分相似\n\n局部变量的生命周期从进入”{“开始，离开”}”结束\n全局变量的生命周期是整个程序（VS 项目）\n\n4. 局部变量 &amp; 自动变量  局部变量又称自动变量\nauto int a = 0;\n\n实际使用的时候我们一般都是省略 auto 的\n\n以上就是 C 语言中有关变量的一些概念，希望对你有帮助\n点个赞再走呗，万分感谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】数组练习题分享","url":"/posts/2092077457/","content":"好久没记录（氵）博客了，今天记录一下昨天学习的数组练习题中的内容\n\n\n数组练习题[TOC]\n\n昨天学习的练习题挺多的，下面只记录了几个我个人认为比较重要和典型的内容\n（1）错误的引用数组  题目：\nint arr[10]=&#123;0&#125;;\n\n下面错误的引用方式是：\n\nA. arr[0]&#x3D;1        B.arr[0]&#x3D;5*2          C.   arr[10]&#x3D;2               D.arr[1]&#x3D;arr[2]*arr[0]\n\narr[10]代表数组中有 10 个元素，但是 arr[10]的引用是下标，指第 11 个元素\n这超出了数组 10 个元素的范围\n答案是 C\n\n（2）数组中的逗号表达式  请问以下代码输出的结果是什么？\n#include&lt;stdio.h&gt;int main()&#123;\tint arr[]=&#123;1,2,(3,4),5&#125;;    printf(&quot;%d\\n&quot;, sizeof(arr));    return 0;&#125;\n\n首先，arr 数组中的每个元素都是一个整型元素，占用的字节是 4 个 bit 位\n所以 sizeof 计算数组中的元素个数，将它们所占空间相加\n\n其中逗号表达式(3,4)  —–&gt; 只产生一个结果，4\n\n以防万一，这里提一下逗号表达式的概念\n逗号表达式  逗号表达式中的内容可以是数字，也可以是表达式\n#include&lt;stdio.h&gt;int main()&#123;\tint a =3;    int b=5;    int c=0;    // 逗号表达式    int d=(c=1,a=c+3,b=a-4,c+=b);    printf(&quot;%d\\n&quot;,d);    return 0;&#125;\n\n这个代码的结果是 1\n运算过程如下\n\nc&#x3D;1\na&#x3D;c+3&#x3D;1+3&#x3D;4\nb&#x3D;a-4&#x3D;4-4&#x3D;0\nc+&#x3D;b  —-&gt; c&#x3D;c+b&#x3D;1+0&#x3D;1\n\n逗号表达式会从左到右依次计算里面的每个表达式\n输出的结果是逗号表达式中最后一个表达式的结果\n所以上面数组中 (3,4) 这个逗号表达式产生的结果是 4\nprintf 输出的结果是 16（4 个元素）\n\n（3）数组中字符串和字符元素的区别int arr1[]=&#123;&quot;abcdef&quot;&#125;;int arr2[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;;\n\n\n数组 arr1 和 arr2 等价  ×\n\n一个是字符串，一个是字符元素，它们的含义是不同的\n\n数组 arr1 和 arr2 的长度相同   ×\n\n这两个的长度实际上是不同的\n因为“abcdef”这个字符串的后面，是有一个字符串结束标志 \\0 的\n\n数组 arr1 的长度大于 arr2 的长度  √\n\n（这里我可能有错的地方，还请 dalao 无情指正）\n\n（4）自定义函数与数组的简单练习题  题目如下\n\n创建一个整形数组，实现以下操作\n1. 实现函数 init()初始化数组为全 0\n2. 实现 print()打印数组中的每个元素\n3. 实现 reverse()函数完成数组元素的逆置\n\n前两个自定义函数的实现形式非常相似\n我们只需要用一个 for 循环，利用 i 依次访问数组中的每个元素，将它们打印出来或者赋值为 0 实现初始化\nvoid print(int arr[], int sz)// 打印数组中的每个元素&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)    &#123;        printf(&quot;%d &quot;, arr[i]);    &#125;    printf(&quot;\\n&quot;);&#125;void init(int arr[], int sz)// 将数组中的每个元素都初始化为 0&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)    &#123;        arr[i] = 0;    &#125;&#125;\n\n这里需要注意的一个点是 sz（数组元素个数）我们必须在主函数 main 中计算，不能在自定义函数中计算\n因为传过来的数组是首元素的地址，这时候用 sizeof 计算的数组元素长度是不准确的\n主函数 main 如下\nint main()&#123;    int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;    int sz = sizeof (arr)/sizeof(arr[0]);    printf(&quot;%d\\n&quot;, sz);    print(arr, sz);    reverse(arr, sz);    print(arr, sz);    init(arr, sz);    print(arr, sz);    return 0;&#125;\n\nreverse 函数的基本理念和另外两个函数其实是相似的\n这里我们依旧会用到“空盒子”tmp 来完成我们的交换\n同时我们需要使用循环来确认什么时候停止交换\n即左右两个数组元素的下标一样的时候（或者值一样）就停止交换\nvoid reverse(int arr[], int sz)// 数组元素的逆置&#123;    int left = 0;    int right = sz - 1;    while(left &lt; right)    &#123;        int tmp = arr[left];        arr[left] = arr[right];        arr[right] = tmp;        left++;        right--;    &#125;&#125;\n\n当我们进行两个数组之间的元素调换的时候，也需要用 for 循环 +tmp 空盒子的方式一一交换每个数组对应下标的元素\n\n前提，两个数组的元素个数相同\n\n下面这种代码是错误的\nint tmp=arr1arr1=arr2arr2=tmp\n\n实现形式和上面打印和初始化的自定义函数的思路是一样的，这里不再赘述！\n\n如果本博客对你有帮助，还请点赞支持一下！这是对我的最大鼓励\n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C 语言】童年经典游戏 - 三字棋","url":"/posts/2819542311/","content":"@toc\n问题引入 - 什么是三子棋？想必大家儿时都玩过：# 字棋\n\n如图，即一个 3x3 的格子，玩家需要在横、竖、斜三条线上布下自己的棋子\n先连成一条线上 3 个棋子的玩家获胜\n如果格子填满后还未有胜者，即为平局\n今天就让我们用 c 语言代码 来完成一个基础的三子棋小游戏\n\n涉及知识点：\n二维数组、循环语句、自定义函数、自定义头文件\n关联博客：扫雷游戏\n\n\n自定义头文件  本次三子棋代码实现中，我们需要使用到自定义头文件\n使用自定义函数前，需要先对函数进行声明\n头文件就是一堆声明的集合\n\n问：为什么不把函数声明直接 main 函数前面？\n\n\n答：因为这样更方便团队进行同一个项目的分工制作\n\n如何创建自定义头文件？\n在 vs 编译器的“解决资源管理器”里，我们能看到头文件的文件夹\n右键它，新建项\n\n选择头文件进行新建，后缀是.h\n\n创建完后，我们可以在另外一个源文件中引用头文件\n#include &quot;game.h&quot;\n\n另外，因为我们使用的两个源文件（下面会提到）都需要使用 c 语言的库函数\n所以我们可以在自定义头文件中引用库函数的头文件\n\n这样只用在其他源文件中引用我们的自定义头文件\n就无需再引用 C 语言的库函数头文件了\n\n项目中不同源文件之间的连接  在三子棋代码中，我们需要编写两个源文件\n\n一个源文件为 main 函数所在的源文件\n另一个是自定义函数的定义部分所在的头文件\n\n在实际项目合作中，这种方式可以将不同的自定义函数（实现不同功能）的内容分工给每个人\n同样是为了方便团队合作\n在两个源文件中编写自定义函数的方式和在一个源文件中编写是一样的\n如在头文件 game.h 中声明了  初始化棋盘的函数\n// 初始化棋盘void Intboard(char board[ROW][COL], int row, int col);\n\n在实现自定义函数的 game.c 文件中只需要引用头文件 game.h\n就能正常编写自定义函数的实现部分\n#include &quot;game.h&quot;// 初始化棋盘void Intboard(char board[ROW][COL], int row, int col)&#123;   &#125;\n\n\n代码实现 1. 打印菜单 &amp; 初始化棋盘 游戏嘛，肯定需要一个最基本的初始菜单了\n玩家通过输入 1 或 0 来选择  进入游戏  还是  退出游戏\nvoid menu()&#123;\tprintf(&quot;**********************\\n&quot;);\tprintf(&quot;********1.play********\\n&quot;);\tprintf(&quot;********0.exit********\\n&quot;);\tprintf(&quot;**********************\\n&quot;);&#125;\n\n接下来我们需要弄一个初始化的函数\n三子棋一共是 3x3 的格子，所以我们需要一个  二维数组  来存放棋盘\n然后要先把这个棋盘中的每一个棋子都初始化为  空格\ngame.h\n#define ROW 3// 行#define COL 3// 列// 初始化棋盘void Intboard(char board[ROW][COL], int row, int col);\n\ntest.c\nchar ret = 0;// 存储数据 - 二维数组char board[ROW][COL] = &#123; 0 &#125;;// 初始化棋盘 - 初始化空格Intboard(board, ROW, COL);// 自定义函数传参\n\ngame.c\n// 初始化棋盘void Intboard(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tboard[i][j] = &#x27; &#x27;;// 将每个棋盘都初始化为空格\t\t&#125;\t&#125;&#125;\n\n2. 打印棋盘  玩家 &#x2F; 电脑每走一步，游戏都需要打印一次棋盘，告诉玩家自己下在了哪里，以及对手（电脑）落子的位置\n和简单打印二维数组不同\n我们需要在每个元素之间打印一个  分割线，达到以下效果\n//   |   |   //---|---|---//   |   |  //---|---|---//   |   |   \n\ngame.h 和 test.c 文件中写法同上，重点来看 game.c 文件中函数的实现\n// 打印棋盘void Display(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tprintf(&quot; %c &quot;, board[i][j]);// 打印数组元素\t\t\tif (j &lt; col - 1)\t\t\t\tprintf(&quot;|&quot;);// 竖分割线\t\t&#125;// 效果  a | b | c  \t\tprintf(&quot;\\n&quot;);// 换行\t\tif (i &lt; row - 1)\t\t&#123;\t\t\tfor (j = 0; j &lt; col; j++)\t\t\t&#123;\t\t\t\tprintf(&quot;---&quot;);// 横分割线\t\t\t\tif (j &lt; col - 1)\t\t\t\t\tprintf(&quot;|&quot;);// 竖分割线\t\t\t&#125;// 效果 ---|---|---\t\t\tprintf(&quot;\\n&quot;);\t\t&#125;\t&#125;&#125;\n\n这样我们就能输出一个如图所示的棋盘\n\n你可能注意到，这里多了两行提示\n这是我们 test.c 函数中的内容\n三子棋游戏需要以  函数返回值  来判断是否胜利（平局）\n不过这里的 test 函数主要用于玩家最开始 1 和 0 的选择（是否开始游戏）\nvoid test()&#123;\tint input = 0;\tsrand((unsigned int)time(NULL));\tdo\t&#123;\t\tmenu();\t\tprintf(&quot; 请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot; 退出游戏 \\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot; 选择错误，请重新选择!\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);&#125;int main()&#123;\ttest();\treturn 0;&#125;\n\n这里的 srand 以及 time 函数是用来生成随机数，作为电脑落子坐标的\n在  猜数字游戏  的博客里也有提到这两个函数  [链接]\nsrand((unsigned int)time(NULL));\n\n3. 游戏基本流程  打印完棋盘后，开始编写玩家落子、电脑落子以及判断谁最终胜利的函数\n在日常编写代码的时候，我们也最好使用这种方式\n\n先想好游戏的具体流程\n写出流程需要的函数名和判断过程\n最后补齐自定义函数的实现\n\ntest.c\nvoid game()&#123;\tchar ret = 0;\t// 存储数据 - 二维数组\tchar board[ROW][COL] = &#123; 0 &#125;;\t// 初始化棋盘 - 初始化空格\tIntboard(board, ROW, COL);\t// 打印棋盘\tDisplay(board, ROW, COL);\twhile (1)\t&#123;\t\t// 玩家走\t\tPlayerMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t// 判断玩家是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\t// 电脑走\t\tBotMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t// 判断电脑是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t// 判断状态\tif (ret == &#x27;*&#x27;)\t&#123;\t\tprintf(&quot; 玩家赢了 \\n&quot;);\t&#125;\telse if (ret == &#x27;#&#x27;)\t&#123;\t\tprintf(&quot; 电脑赢了 \\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot; 平局 \\n&quot;);\t&#125;&#125;\n\n代码中的 Iswin 函数用于判断谁胜利\n因为每走一步的结果有 4 种情况\n\n玩家赢\n电脑赢\n平局\n继续\n\n所以这里我们不再使用数字（也是避免和原有 menu 选择弄混）\n以字符的形式来表达这 4 种情况\n// 在游戏进行的过程中 --Iswin 判断//1. 玩家赢了 -*//2. 电脑赢了 -#//3. 平局 -Q//4. 继续 -C\n\n4. 玩家走棋  玩家走棋的时候，我们需要注意以下几点\n\n玩家应以 [1,3] 的数字作为落子坐标，而不应从 0 开始（下标从 0 开始）\n玩家是人，可能输错。在坐标出错的时候应给予提示，并让玩家重新输入\n落子前需要判断该坐标是否已有子。若有，提示玩家该处已下子\n\n// 玩家走void PlayerMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot; 玩家走:&gt; \\n&quot;);\twhile (1)\t&#123;\t\tprintf(&quot; 请输入下棋的坐标:&gt; &quot;);\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\tif (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)\t\t&#123;\t\t\t// 下棋 \t\t\t// 判断坐标是否被占用\t\t\tif (board[x - 1][y - 1] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\tboard[x - 1][y - 1] = &#x27;*&#x27;;\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot; 坐标已被占用，请重新输入 \\n&quot;);\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot; 坐标错误，请重新输入 \\n&quot;);\t\t&#125;\t&#125;&#125;\n\n细心的你肯定发现了，这里的玩家落子使用的是 *，也正是玩家胜利时的返回字符\n下面电脑落子的时候用的就是 #\n\n5. 电脑落子  电脑落子比玩家落子相对较简单\n我们只需要让生成的两个随机数在 1-3 之间即可\nvoid BotMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot; 电脑走: \\n&quot;);// 提示玩家此处是电脑落子\twhile (1)\t&#123;\t\tx = rand() % row;\t\ty = rand() % col;\t\tif (board[x][y] == &#x27; &#x27;)\t\t&#123;\t\t\tboard[x][y] = &#x27;#&#x27;;\t\t\tbreak;\t\t&#125;\t&#125;&#125;\n\n6. 判断是否胜利  上面提到，每走一步，我们都需要用 Iswin 函数判断是否有人胜利\n三子棋胜利有 3 种方式：行、列、对角线\n这里我们需要分别予以判断，是否存在某一个行、列、对角线上的子全为玩家或电脑所下\n// 判断胜利char Iswin(char board[ROW][COL], int row, int col)&#123;\t// 判断行\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tif (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[i][1];\t\t&#125;\t&#125;\t// 判断列\tfor (i = 0; i &lt; col; i++)\t&#123;\t\tif (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[1][i];\t\t&#125;\t&#125;\t// 判断对角线\tif (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\tif (board[2][0] == board[1][1] &amp;&amp; board[1][1] == board[0][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\t// 判断平局\t// 满了返回 1，不满返回 2\tif (1 == IsFull(board, row, col))\t&#123;\t\treturn &#x27;Q&#x27;;\t&#125;\t// 继续\treturn &#x27;C&#x27;;&#125;\n\n这里又出现了一个新的函数，IsFull\n\n7. 判断是否平局  当上面的判断胜利的语句走完后，若还没出现返回的情况\n我们就要判断是否是平局，即判断棋盘的 9 个棋子是否都已落下\nint IsFull(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tif (board[i][j] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 1;// 棋盘满了&#125;\n\n如果的判断胜利和平局的语句都走完后，还没出现返回的情况\n即说明游戏并未停止，我们需要继续游戏\n\n游戏效果  到这里，我们的三子棋游戏就完成了！\n跑一下看看效果吧！\n\n\n完整代码  这里贴出三子棋函数的完整代码供大家参考\ngame.c#define _CRT_SECURE_NO_WARNINGS 1#include &quot;game.h&quot;// 初始化棋盘void Intboard(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tboard[i][j] = &#x27; &#x27;;\t\t&#125;\t&#125;&#125;// 打印棋盘void Display(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tprintf(&quot; %c &quot;, board[i][j]);\t\t\tif (j &lt; col - 1)\t\t\t\tprintf(&quot;|&quot;);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t\tif (i &lt; row - 1)\t\t&#123;\t\t\tfor (j = 0; j &lt; col; j++)\t\t\t&#123;\t\t\t\tprintf(&quot;---&quot;);\t\t\t\tif (j &lt; col - 1)\t\t\t\t\tprintf(&quot;|&quot;);\t\t\t&#125;\t\t\tprintf(&quot;\\n&quot;);\t\t&#125;\t&#125;&#125;// 玩家走void PlayerMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot; 玩家走:&gt; \\n&quot;);\twhile (1)\t&#123;\t\tprintf(&quot; 请输入下棋的坐标:&gt; &quot;);\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\tif (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)\t\t&#123;\t\t\t// 下棋 \t\t\t// 判断坐标是否被占用\t\t\tif (board[x - 1][y - 1] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\tboard[x - 1][y - 1] = &#x27;*&#x27;;\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot; 坐标已被占用，请重新输入 \\n&quot;);\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot; 坐标错误，请重新输入 \\n&quot;);\t\t&#125;\t&#125;&#125;void BotMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot; 电脑走: \\n&quot;);\twhile (1)\t&#123;\t\tx = rand() % row;\t\ty = rand() % col;\t\tif (board[x][y] == &#x27; &#x27;)\t\t&#123;\t\t\tboard[x][y] = &#x27;#&#x27;;\t\t\tbreak;\t\t&#125;\t&#125;&#125;int IsFull(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tif (board[i][j] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 1;// 棋盘满了&#125;// 判断胜利char Iswin(char board[ROW][COL], int row, int col)&#123;\t// 判断行\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tif (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[i][1];\t\t&#125;\t&#125;\t// 判断列\tfor (i = 0; i &lt; col; i++)\t&#123;\t\tif (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[1][i];\t\t&#125;\t&#125;\t// 判断对角线\tif (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\tif (board[2][0] == board[1][1] &amp;&amp; board[1][1] == board[0][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\t// 判断平局\t// 满了返回 1，不满返回 2\tif (1 == IsFull(board, row, col))\t&#123;\t\treturn &#x27;Q&#x27;;\t&#125;\t// 继续\treturn &#x27;C&#x27;;&#125;\n\ntest.c#define _CRT_SECURE_NO_WARNINGS 1#include &quot;game.h&quot;void menu()&#123;\tprintf(&quot;**********************\\n&quot;);\tprintf(&quot;********1.play********\\n&quot;);\tprintf(&quot;********0.exit********\\n&quot;);\tprintf(&quot;**********************\\n&quot;);&#125;void game()&#123;\tchar ret = 0;\t// 存储数据 - 二维数组\tchar board[ROW][COL] = &#123; 0 &#125;;\t// 初始化棋盘 - 初始化空格\tIntboard(board, ROW, COL);\t// 打印棋盘\tDisplay(board, ROW, COL);\twhile (1)\t&#123;\t\t// 玩家走\t\tPlayerMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t// 判断玩家是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\t// 电脑走\t\tBotMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t// 判断电脑是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t// 判断状态\tif (ret == &#x27;*&#x27;)\t&#123;\t\tprintf(&quot; 玩家赢了 \\n&quot;);\t&#125;\telse if (ret == &#x27;#&#x27;)\t&#123;\t\tprintf(&quot; 电脑赢了 \\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot; 平局 \\n&quot;);\t&#125;&#125;void test()&#123;\tint input = 0;\tsrand((unsigned int)time(NULL));\tdo\t&#123;\t\tmenu();\t\tprintf(&quot; 请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot; 退出游戏 \\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot; 选择错误，请重新选择!\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);&#125;int main()&#123;\ttest();\treturn 0;&#125;\n\ngame.h#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define ROW 3#define COL 3// 初始化棋盘void Intboard(char board[ROW][COL], int row, int col);// 打印棋盘void Display(char board[ROW][COL], int row, int col);// 玩家走void PlayerMove(char board[ROW][COL], int row, int col);// 电脑走void BotMove(char board[ROW][COL], int row, int col);// 判断是否胜利char Iswin(char board[ROW][COL], int row, int col);// 判断是否有空位#pragma once\n\n\n结语  本篇三子棋的博客到此结束了\n感谢你看到最后！\n下篇博客会教大家，如何打包我们的代码为 dll 文件（此文件无法编译）\n点个赞再走吧，球球了！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】童年经典游戏 - 扫雷","url":"/posts/2375006677/","content":"想必屏幕前的你，肯定玩过 windows XP 系统自带的那个游戏，扫雷\n\n\n回想当年，我根本没看懂这个游戏是怎么玩的\n\n比起扫雷，三维弹球对我更有吸引力\n跑题了\n本篇博客就让我们一起来试试，如何通过 C 语言代码，制作出一个“扫雷游戏 se”\n1. 游戏程序主函数  在编写这类游戏代码时，我们要用到的主函数基本是一致的\n扫雷游戏的主函数和猜数字游戏的主函数相差很小\n小白必学！简单的 C 语言应用 &#x3D;&#x3D;＞猜数字游戏\nvoid menu()// 简易目录&#123;\tprintf(&quot;***************************\\n&quot;);\tprintf(&quot;**** 1. play   0. exit*****\\n&quot;);\tprintf(&quot;***************************\\n&quot;);&#125;int main()&#123;\tint input = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot; 请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();// 实现游戏的函数\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot; 退出游戏 \\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot; 输入错误 \\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n2. 游戏实现原理  想写好一串代码，首先我们要知道扫雷游戏需要通过什么方式来实现\n\n我们需要一个 9x9 的棋盘，用于生成我们的雷以及玩家的游玩\n在 c 语言中当然无法直接产生这样的画面\n但我们可以同符号 * 或者 #来代替网格，用 1 和 0 来表示有无雷\n如果我们只生成一个棋盘，那 1 和 0 会直接显示出来，达不到隐藏的效果\n所以我们需要用二维数组生成  两个棋盘，一个用于存放雷，一个用于玩家的游玩\nchar mine[ROWS][COLS];// 雷区布置char show[ROWS][COLS];// 玩家看到的界面\n\n扫雷游戏我们使用  头文件 + 源文件  的形式撰写代码\n\n这样写代码的优点在于后续我们可以直接通过更改.h 文件中的数组，从而更改我们的格子大小\n如: 改成 12x12 的游玩界面，改变雷区布雷个数等等\n\n所以我们需要在 game.h 中定义这些符号\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define ROW 9#define COL 9#define ROWS ROW+2#define COLS COL+2\n\n同时我们要在主函数的最上面引用这个自己写的头文件\n只要把库函数头文件放入 game.h 文件，在其他源文件中  只需引用 game.h\n不需要再次引用 &lt;stdio.h&gt;、&lt;stdlib.h&gt; 之类\n#include &#x27;game.h&#x27;\n\n棋盘大小为什么需要 11x11？你可能注意到了，在生成数组的时候，我使用了 ROWS，其值为 ROW+2\n我们最终展示的只是 9x9 的游戏界面，但生成的棋盘其实是 11x11 的\n这是因为我们需要在 mine 数组中实现扫描雷区的操作\n\n玩过扫雷游戏的你肯定知道：在你点击一个格子的时候，如果这个格子不是雷\n它会显示一个数字，告诉你它周围的 8 个格子中有几颗雷\n\n如图所示：\n\n在 C 语言中，我们可以用函数统计周围 8 个格子中雷’1’的个数\n但是如果你来到边缘，那就出现问题了\n\n如果我们想统计边缘的格子周边有几颗雷，就会遇到这种  溢出数组  的情况\n此时代码会报错\n为了避免这个问题，我们可以在原来 9x9 的基础上在周围加一圈空白的格子\n也就是代码所示的 ROW(行)COL(列)都要 +2 的情况\n#define ROW 9#define COL 9#define ROWS ROW+2#define COLS COL+2\n\n游戏过程  这里简单梳理一下我们的游戏过程\n\n玩家选择开始游戏\n生成两个棋盘，一个放置雷 \\ 扫描雷，一个向玩家展示游戏界面\n玩家输入坐标，选择排雷位置\n有雷–&gt; 玩家被炸死，游戏结束；无雷–&gt; 显示周边有几颗雷，游戏继续\n所有雷被排出，游戏胜利\n\n\n3. 游戏代码实现  接下来就进入我们的游戏代码部分\n3-1. 初始化和打印// 初始化扫雷InitBoard(mine, ROWS, COLS, &#x27;0&#x27;);InitBoard(show, ROWS, COLS, &#x27;*&#x27;);// 打印扫雷DisplayBoard(mine, ROW, COL);DisplayBoard(show, ROW, COL);\n\n我们需要初始化两个棋盘，其中雷区初始化为 0（0 代表无雷），展示区初始化为’*’，用✳代替界面\n同时我们打印这两个棋盘，查看初始化效果\n因为这是我们的自定义函数，所以需要在.h 文件中定义函数，在另外一个.c 文件中包含函数的实现\n\n// 初始化棋盘void InitBoard(char board[ROWS][COLS], int rows, int cols, char set);// 打印void DisplayBoard(char board[ROWS][COLS], int row, int col);\n\n初始化函数和打印函数比较简单，使用 for 语句达成我们的需求\nvoid InitBoard(char board[ROWS][COLS], int rows, int cols, char set)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; rows; i++)\t&#123;\t\tfor (j = 0; j &lt; cols; j++)\t\t&#123;\t\t\tboard[i][j] = set;\t\t&#125;\t&#125;&#125;void DisplayBoard(char board[ROWS][COLS], int row, int col)&#123;\tint i = 0;\tint j = 0;\tprintf(&quot;------ 扫雷游戏 ------\\n&quot;);\t// 打印列号\tfor (i = 0; i &lt;= col; i++)\t&#123;\t\tprintf(&quot;%d &quot;, i);\t&#125;\tprintf(&quot;\\n&quot;);\tfor (i = 1; i &lt;= row; i++)// 只打印中心的 99 方格\t&#123;\t\tprintf(&quot;%d &quot;, i);// 打印行号\t\tfor (j = 1; j &lt;= col; j++)// 只打印中心的 99 方格\t\t&#123;\t\t\tprintf(&quot;%c &quot;, board[i][j]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\tprintf(&quot;--------------------\\n&quot;);&#125;\n\n需要注意的是我们的最后打印棋盘的时候是从 i&#x3D;1 开始的，这样就能避开添加的空白边缘区域，只打印中心的 99 方格\n同时我们添加了列号和行号，这样能让玩家清除的知道自己应该输入什么坐标\n\n3-2. 布置雷区// 布置雷SetMine(mine, ROW, COL);\n\n这部分代码我在学习的时候就有点力不从心了\n同样的，我们需要在 game.h 中定义这个函数\n// 布置地雷void SetMine(char mine[ROWS][COLS], int row, int col);\n\n在 game.c 中写入自定义函数的实现\n// 放置雷void SetMine(char  mine[ROWS][COLS], int row, int col)&#123;\tint count = EASY_COUNT;\twhile (count)\t&#123;\t\tint x = rand() % row + 1;\t\tint y = rand() % col + 1;\t\tif (mine[x][y] ==&#x27;0&#x27;)\t\t&#123;\t\t\tmine[x][y] = &#x27;1&#x27;;\t\t\tcount--;\t\t&#125;\t&#125;&#125;\n\n这里面出现了一个前面没有提到的变量，EASY_COUNT\n本来这个位置只是个 10\n但如果我们想更改布雷个数，那每次都需要更改这里的 10，后面的代码中也需要更改，非常麻烦\n所以我们改为使用一个自定义变量，在 game.h 中定义这个变量的值\n#define EASY_COUNT 10\n\n这个值就代表我们布置雷的个数了\n3-3. 玩家排查雷// 在主函数中引用这个函数\tFindMine(mine,show, ROW, COL);// 需要把 mine 数组中排查的雷放入 show// 在 game.h 中定义这个函数void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS],int row, int col);\n\n因为我们需要把 mine 数组中排查出的雷的个数放入 show 数组中打印出来\n所以这里我们需要把两个数组都传送过去\n\n1. 输入排查的坐标 2. 检查坐标处是不是雷(1) 是雷 -boom！炸死 - 游戏结束 (2) 不是雷 - 统计坐标周围有几个雷 - 存储排雷的信息到 show 数组，游戏继续\n\nvoid FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)&#123;\tint x = 0;\tint y = 0;    \twhile (1)\t&#123;\t\tprintf(&quot; 请输入排雷坐标:&gt; &quot;);\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\t// 判断坐标是否正确\t\tif (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)\t\t&#123;\t\t\tif (mine[x][y] == &#x27;1&#x27;)\t\t\t&#123;\t\t\t\tprintf(&quot; 很遗憾，你被炸死了 \\n&quot;);\t\t\t\tDisplayBoard(mine, ROW, COL);\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t// 不是雷的情况下，统计坐标周围有几个雷\t\t\t\tint count = get_mine_count(mine, x, y);\t\t\t\tshow[x][y] = count + &#x27;0&#x27;;\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot; 坐标错误，请重新输入 \\n&quot;);\t\t&#125;\t&#125;&#125;\n\n注意，这里面我们需要添加一个代码来判断坐标合法性\n我们的棋盘是 9x9，玩家要是输入一个 (99,99) 的坐标，那肯定不在数组中的，是无效的\n我们需要提醒玩家他输错了\n‘0’的作用show[x][y] = count + &#x27;0&#x27;;\n\n你可能会对这行代码感到疑惑\n为什么要在 count 后面 + 上一个‘0’？\n这里就和我们 ascii 码表有关了\n\n因为我们初始化数组和布置雷的时候，我们给数组传入的都是 1 和 0 这两个  符号，并不是数字！\n但是在 show 数组中我们需要给玩家显示一个数字的  字符\n\n这里面我们提供的是1 的字符，并不是 1 它本身\n而我们在计算周边雷的个数的时候，传回来的是一个具体的数字\n观察表格，你会发现数字和对应的字符中间，都差了 48\n而 48 恰好是字符’0’对应的 ASCII 码值\n所以我们需要用 count 加上字符’0’，以此在界面中向玩家展示周边 8 格有几颗雷\n3-4. 系统扫描雷  如何把玩家选择的格子周边的雷扫描出来呢？\n设玩家的选择的坐标为 x 和 y\n\n\n\nx-1,y-1\nx-1,y\nx-1,y+1\n\n\n\nx,y-1\nx,y\nx,y+1\n\n\nx+1,y-1\nx+1,y\nx+1,y+1\n\n\n我们只需要把这些坐标全部在二维数组中键入，就能逐个扫描出雷的个数\n// 统计雷的个数static int get_mine_count(char mine[ROWS][COLS], int x, int y)&#123;\treturn mine[x - 1][y - 1] +\t\tmine[x - 1][y] +\t\tmine[x - 1][y + 1] +\t\tmine[x][y - 1] +\t\tmine[x][y + 1] +\t\tmine[x + 1][y - 1] +\t\tmine[x + 1][y] +\t\tmine[x + 1][y + 1] - 8 * &#x27;0&#x27;;&#125;\n\n这里因为我们扫描出来的也是‘1’的字符，系统中是字符 1 的 ascii 码值 49\n所以我们需要减去 8 个字符‘0’，这样就能得到雷的个数的  数字\n（然后在之前的那个函数中接受，count+‘0’，在 show 数组中显示）\n\n这个函数是在玩家排查雷的函数之前的\n因为在主函数中我们不需要使用这个自定义函数，所以不需要在 game.h 中定义\n我们想让它只在 game.c 中生效，所以用 static 修饰它\n\n\nstatic 的作用\n1. 修饰局部变量2. 修饰全局变量3. 修饰函数\n\n\n上面的代码其实还少了一个东西\n我们需要判断玩家什么时候胜利——雷区的 0（无雷方块）全部被玩家找出，玩家就胜利了\nint win = 0;while (win&lt; row * col - EASY_COUNT)\n\n这里我们需要更改的是 whlie 函数\n其中 row * col - EASY_COUNT  指方格总数减去雷的个数，得到的是无雷方块的个数\n玩家每成功排除一个无雷方块，win 就会加一个数字\nelse&#123;\t// 不是雷的情况下，统计坐标周围有几个雷\tint count = get_mine_count(mine, x, y);\tshow[x][y] = count + &#x27;0&#x27;;\t// 显示排查出来的信息\tDisplayBoard(show, ROW, COL);       win++;&#125;\n\n当 win 达到无雷方块个数的时候，whlie 循环就会停止\n随后我们判断玩家是否胜利，如果胜利，就打印棋盘，让玩家知道雷的位置\nif (win == row * col - EASY_COUNT)&#123;\tprintf(&quot; 恭喜你，游戏胜利！\\n&quot;);\tDisplayBoard(mine, ROW, COL);&#125;\n\n这里必须要判断，因为你失败了也是会跳出循环的！\n到此，我们的扫雷代码就是完成了\n4. 查看结果  这里我作弊，将雷的个数设置为 80 并打印出布置雷之后的棋盘\n输入最后一个雷的位置，系统提示我们游戏胜利\n\n输入雷的坐标后，也会提示你被炸死了\n\n到这里我们可以确认代码是编写成功了！\n完整代码获取 &#x3D;&#x3D;&gt;  [DAY018 扫雷]\n\n感谢你看到最后，写这个博客用了我 2 个小时，点个赞再走吧！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】野指针是什么？指针在什么情况下会出错？","url":"/posts/2226629578/","content":"@toc\n什么是野指针？概念︰野指针就是指针指向的位置是不可知的（如：随机的、不正确的、没有明确限制的)\n说人话就是：野指针是错误的指针引用形式，通常有以下几种情况\n\n指针未初始化\n越界访问\n指针指向的空间已释放\n\n悬垂指针（dangling pointer）：是指在程序中仍然存在，但不再指向有效内存地址的指针。当指针指向的对象被释放或销毁后，指针仍然保留着先前所指向的内存地址，这时指针就成为悬垂指针。\n1. 指针未初始化  这个概念非常容易理解，同变量一样，指针同样需要我们的初始化\n// 初始化指针int a = 10;int*p = &amp;a;\n\n指针未初始化 通常是以下情况\nint main()&#123;\tint*p;\t*p=20;&#125;\n\n这里的指针并没有指向某个内存地址，即便我们更改它的内容也是无效的\n\n指针会默认赋予一个随机值，属于非法访问内存\n\n当然，编译器遇到这种情况会直接报错\n\n2. 越界访问  越界访问的情况通常出现在数组中\nint arr[10]=&#123;1,2,3,4,5&#125;;int* p=arr;\n\n我们知道，数组名代表是首元素的地址\n我们可以利用 for 循环和指针 ++ 的方式，使指针访问数组中的每个元素\nint main()&#123;\tint arr[5]=&#123;1,2,3,4,5&#125;;\tint* p = arr;    int i =0;    for(i=0;i&lt;=5;i++)    &#123;        *p=0;        p++;    &#125;&#125;\n\n我们知道，数组中的元素访问都是通过下标的方式。5 个元素的数组，下标是从 0-4\n而在此代码中，p++ 第五次的时候，下标已经变成了 5，对应的是第六个元素\n但数组中并没有第六个元素，此时指针访问的就是一个空的地址了\n同样属于非法访问\n这就是  越界访问  的一种\n3. 指针指向的空间已释放  每当我们定义一个变量时，系统都会赋予这个变量一个内存的地址空间\n这时候我们把这个地址赋予给指针 p，指针便记录下了这个地址\n用图来给大家演示一下什么叫指向的空间已释放\n\n代码示例如下\nint* test()&#123;\tint a = 10;\treturn &amp;a;&#125;int main()&#123;\tint* p = test();\t*p = 20;\treturn 0;&#125;\n\n\n\n如何避免野指针？1. 指针初始化  在使用指针的时候，我们要像创建变量一样初始化指针\n如果不知道把指针初始化为什么，那就赋值为 NULL(代表 0)\n\n 1 int main() 2 &#123; 3     // 当前不知道 p 初始化为什么的时候 4     // 直接初始化为 NULL(空指针 --&gt;0) 5     int* p = NULL; 6     // 明确知道初始化的值 7     int a = 10; 8     int* ptr = &amp;a; 9     10     return 0;11 &#125;\n\n2. 小心指针越界  在使用指针的时候，我们要注意不能让指针越界\n如遇到数组的情况，一定要注意下标和元素个数的区别\n\n注意：C 语言本身是不会检查数据的越界行为的！\n\n3. 指针指向空间释放就置之为 NULL在我们指针使用完毕之后，为了避免指针指向的空间被系统释放\n我们可以将指针初始化为空指针,NULL\n4. 指针使用之前检查有效性  什么是有效性?\nNULL 的空指针就是无效的\n为了避免我们引用这种无效的空指针，我们可以在使用指针之前用 if 语句判断一下它是否为空\nif(p!=NULL)\t*p=10;\n\n判断为有效指针，我们再使用它\n做到以上 4 点，就能基本避免我们的代码出错。这只能避免，并不能杜绝\n“你永远叫不醒一个想写 bug 的人”\n\n结语  以上就是野指针的基本解释，希望对你有帮助\n点个赞再走吧！万分感谢！\n","categories":["初识C语言"],"tags":["C语言","指针"]},{"title":"【C 语言】二级指针","url":"/posts/1209573309/","content":"二级指针  什么是二级指针？我们通常使用的 int*p 就是一个一级指针，而二级指针存放的变量就是一个一级指针  代码示例如下：\nint main()&#123;\tint a =10;    int*pa= &amp;a;                    // 有两个 * 号 的原因    int ** ppa= &amp;pa;//int* 是代表变量 pa 的类型，*ppa 表明这是一个指针变量        return 0；&#125;\n\n这里面 pa 是指针变量，一级指针\nppa 是二级指针变量，&amp;pa 取出 pa 在内存中的起始地址\n如图所示\n小结  简单的说，指针变量也是变量，变量就有属于它的地址，而二级指针就是用来存放指针变量的地址的\n希望这对你有帮助！\n","categories":["初识C语言"],"tags":["C语言","指针"]},{"title":"【VS】如何解决 VS 编译器 scanf 报错问题","url":"/posts/4009185516/","content":"[toc]\n问题来源  当我们使用 vs 编译器编译 c 语言代码，并需要用到一些非常常用的库函数的时候（如 scanf）\nvs 编译器通常会报出如下错误\n\n\n有的时候即便报错了，程序也可以正常运行\n\n但有的时候就会同图中一样，程序无法运行\n\n\n出现这个错误的原因是 vs 编译器认为这些库函数是“不安全的”（我可真谢谢你，担 duo 心 guan 那 xian 么 shi 多，微软）\n解决方法  解决这个报错问题的方法有两种\n1. 使用_S 下标  如图所示，我们可以在库函数后面加一个_s，这时候 vs 就会把它认为是“安全的函数”，程序就可以正常运行了\n\n方法一的致命缺点  但是这么做有一个非常大的弊端——该代码只能在 vs 编译器里运行\n如图，如果我们将这一串带_S 的代码复制到 **devc++** 这款编译器里面\ndevc++ 编译器会报错，无法运行这串代码\n同样的，如果你需要在 mooc、牛客网或者其他  刷题网站  上填写代码的时候\n系统也无法运行这种带了_s 的 c 语言代码\n这时候代码的“可移植性” （即通用性）就变差了！\n\n这时候就需要我们的解决方法 2 了\n2. 使用防报错语句  只需要在这个源文件的第一行添加这样一串代码\n#define _CRT_SECURE_NO_WARNINGS 1\n\n这串代码的作用就是屏蔽掉 vs 编译器对函数危险性的  排查报错\n如图所示，我们的代码就能正常运行了\n\n这样操作，即便是将这一行防报错代码移植到另外一个编译器里，这串代码仍然能正常运行  而且有的时候即便加上_s，还是会出现一些和 scanf 无关的奇怪报错  使用方法二就能解决这个问题，这里建议大家还是使用方法二啦！\n\n方法二的缺点？你可能会说，那我岂不是每次写代码之前都需要打上这么一个 define 语句，那样也太麻烦了吧！\n再说了，我也背不下来啊！\n别急，下面我就会告诉你怎么让 vs 编译器每次创建源文件的时候自动带上这么一串代码\n如何在 vs 编译器里加上默认语句  这里我们需要用到另外一款同样很经典的软件——Notepad++  \n如果你还没安装这款软件，这里是下载链接——&gt; [点我]\n\n安装完成后，我们点击左上角的 文件\n\n打开如下路径里，箭头所指的new++file 文件\n\nvs 编译器默认安装路径是 c 盘\n如果你的 vs 编译器不在 c 盘，可以通过右键桌面 vs 编译器的快捷方式，打开文件所在的位置，找到你 vs 编译器的安装路径\n\n\n打开以后是空白的\n我们只需要讲这行 define 语句加入这个文件，ctrl+s 保存\n\n由于 vs 编译器处于 c 盘，修改这个文件需要申请管理员权限，点击同意即可！\n\n#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;\n\n\n这时候你创建的新的源文件，就会默认带上这串代码啦！\n由于 &lt;stdio.h&gt; 这个头文件实在是太常用了，所以我把它也加入了这个文件里。\n如果你愿意，也可以把 int main()加入这个文件，方法同上\n\n这样就不用每次创建新的源文件的时候自己手打啦！\n一劳永逸！\n\n结语  如果这篇文章对你有帮助的话，还请点个赞！\n万分感谢！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】剔除最大最小值后，计算数组元素的平均值","url":"/posts/3219014309/","content":"双 11 也不能阻挡我学习的心！\n\n\n[TOC]\n问题引入\n题目内容：\n定义一个含 10 个整型元素的一维数组, 从键盘上输入 10 个元素值, 求去掉最大值和最小值之后的元素平均值.\n输入格式:\n用循环控制依次输入 10 个元素值，scanf 语句中的格式控制串为: “%d”\n输出格式：\n输出平均值, printf 中的格式控制串为 “%lf\\n”\n\n输入样例：\n2 3 4 5 6 2 4 6 4 3\n\n输出样例：\n3.833333\n\n\n理解 1一般人看到这种题目，下意识会认为是去掉一个最大值一个最小值，再计算数组其他元素的最大值\n毕竟很多体育赛事都是这么计算选手的得分的\n实际上这道题并不是这么要求的，这点我们后面再提\n先来看看如何去掉数组中的一个最大值、一个最小值吧！\n去除一个最大 &#x2F; 最小值  先理清思路\n\n需要找到数组中的最大值和最小值\n在计算平均值的时候需要剔除这两个值\n\n想清楚这两点后，方法就很明确了\n之前我写过一篇博客，有关如何查找数组中最大值的 [链接]\n这里我们就能用上那个博客里面的方法，不过是以自定义函数的方式实现\nint sp1(int arr[], int sz, int* pm)&#123;\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tif (arr[i] &gt; *pm)// 找出最大值\t\t&#123;\t\t\t*pm = arr[i];\t\t&#125;\t&#125;\tfor (int k = 0; k &lt; sz; k++)\t&#123;\t\tif (arr[k] == *pm)// 确认最大值的数值\t\t&#123;\t\t\treturn k;// 返回该最大值的下标\t\t&#125;\t&#125;&#125;\n\n找出最小值的代码同上，只需要将其中的 &gt; 更改为 &lt;\n在 main 函数中，我们需要设立两个变量来接收得到的最大值和最小值的下标\nint main()&#123;\tint arr[10] = &#123; 0 &#125;;\tint a, b = 0;\tdouble ave,sum= 0;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;arr[i]);\t&#125;\tint sz = sizeof(arr) / sizeof(arr[0]);\ta =sp1(arr, sz, &amp;max);\tb =sp2(arr, sz, &amp;min);\tfor (int k = 0; k &lt; 10; k++)\t&#123;\t\tif (k != a &amp;&amp; k != b)\t\t&#123;\t\t\tsum = sum + arr[k];\t\t&#125;\t&#125;\tave = sum / 8;\tprintf(&quot;%lf\\n&quot;, sum);\tprintf(&quot;%lf\\n&quot;, ave);\treturn 0;&#125;\n\n在最后计算 sum 的时候，只需要用 if 语句让 K 不等于最大值和最小值的下标，就能剔除这两个值\n同时，我们的平均数也只需要除以 8 即可\n运行结果  键入数组中元素 1-10，程序成功的输出了剔除 1 和 10 之后 8 个元素的平均值\n\n但当我们把题目示例输进去时，得出的答案却和题目要求不同\n\n\n题目实际要求  上面提到，这道题的要求并不是只剔除一个最大值和最小值\n而是剔除  所有的最大值和最小值\n2 3 4 5 6 2 4 6 4 3\n\n观察输入样例可以发现，这 10 个数字的最大值是 6，最小值是 2\n但是不管是最小值 2 和最大值 6，都不止一个\n题目要求的就是要将这里面的  所有2 和 6 剔除掉，再计算剩余数据的平均值\n解题思路 1&amp;2对上面的代码进行优化，以循环的方式继续寻找最大值的下标\n\n缺点：此方法可能会出现多删的情况\n\n或\n更改代码，在找到最大值下标后，查找数组中有几个元素同这个最大值相同，再返回他们的下标\n\n此方法需要用数组来存放找到的元素的下标，较为麻烦\n\n\n解题思路 3 - 冒泡排序  先对数组进行冒泡排序，再剔除两边的最大值和最小值\n这里我选择的就是解题思路 3\n\n冒泡排序的方式可以参考我之前的博客 [链接]\n这里只贴出主函数内需要编写的内容\n计数器  因为需要剔除多个最大（小）值\n所以这里我们需要用一个变量进行计数\n每当我们找到和已知最大值相同的数字的时候，count 都会 ++（初值为 1）\n当循环走到第一个小于最大值的数后，循环就会终止\nint count2 = 1;for (int k = 8; k &gt;0 ; k--)\t&#123;\t\tif (arr[k] == arr[9])\t\t&#123;\t\t\tarr[k] = 0;// 令最大值为 0\t\t\tcount2 ++;\t\t&#125;\t\telse \t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\n\n查找最小值的代码同上，但是 for 循环中的条件需要更改\n注意，这里的下标 k 必须从 8 开始而不是从 9\n因为经过冒泡排序后，arr[9]本身就是数组中的最大值\n若从它开始循环判断，就会直接把最大值赋值为 0\n程序就出 bug 了\n\n主函数代码int main()&#123;\tint arr[10] = &#123; 0 &#125;;\tint a, b = 0;\tdouble ave, sum = 0;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;arr[i]);\t&#125;\tint sz = sizeof(arr) / sizeof(arr[0]);\t// 先对数组进行冒泡排序\tbubble_sort(arr, sz);\t// 此时下标 0 和 9 即为最大最小值\tint max = arr[0];\tint min = arr[9];\tint count1 = 1;\tint count2 = 1;\tfor (int j = 1; j &lt; 10; j++)\t&#123;\t\tif (arr[j] == arr[0])\t\t&#123;\t\t\tarr[j] = 0;// 令最小值为 0\t\t\tcount1 ++;\t\t&#125;\t\telse\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\tfor (int k = 8; k &gt;0 ; k--)\t&#123;\t\tif (arr[k] == arr[9])\t\t&#123;\t\t\tarr[k] = 0;// 令最大值为 0\t\t\tcount2 ++;\t\t&#125;\t\telse \t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t// 令前后两个最大最小值为 0\tarr[0] = 0;\tarr[9] = 0;\tfor (int k = 0; k &lt; 10; k++)\t&#123;\t\t\tsum = sum + arr[k];\t&#125;\t// 除去已知的所有最大最小值，计算平均数\tave = sum / (10- count1- count2);\t//printf(&quot;%lf\\n&quot;, sum);\tprintf(&quot;%lf\\n&quot;, ave);\treturn 0;&#125;\n\n在最后计算平均数的时候，我们需要剔除 count1 和 count2（10 减去后即为剩余元素的个数）\n这时候得出的答案就和题目所给示例相同了\n\n你学废了嘛？反正我是废了 \n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C 语言】如何将输入的数字逆序打印","url":"/posts/2746269565/","content":"﻿这个问题是我在做学校的作业时候看到的。只隐约有印象讲过，但是忘记了怎么操作。听同学的点通才回想起来，特此写个博客留记\n\n\n[toc]\n逆序打印  目的：输入“789”，打印“987”\n\n注：本博客的数字逆序只涉及 十进制\n\n代码实现有两种方式：1. 利用 if 语句进行大小判断，直到选出从大到小的数字排序  这个方法十分复杂，稍不留意就会弄错，所以在实际应用中不推荐这样操作  这里就不赘述具体代码了。(才不是懒，压根没试过）2. 使用 %10 的方法直接打印  代码如下：\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 0;\tscanf(&quot;%d&quot;, &amp;a);\tprintf(&quot;%d&quot;, a % 10);\tprintf(&quot;%d&quot;, a/10 % 10);\tprintf(&quot;%d&quot;, a/100 % 10);\treturn 0;&#125;\n\n代码结果如下\n\n这个代码成功达到了我们的目的，但是有一个比较明显的弊端  如果我们需要更多位的数字的逆序数时，这个代码就会变得很长，而且每次都需要我们手动添加一个新的 printf\n\n代码优化 1想要逆序比较长的数字，就需要用到循环语句，我使用的是 for 循环  主要需要解决的问题是，a 每 %10 一次后就需要除以 10 再 %10 一次\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 0;\tint n = 0;\tint i = 0;\tprintf(&quot; 请输入需要逆序的数字：&quot;);\tscanf(&quot;%d&quot;, &amp;a);\tprintf(&quot; 请输入该数字的位数：&quot;);\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\t\tprintf(&quot;%d&quot;, a % 10);\t\ta /= 10;\t\t\t&#125;\treturn 0;&#125;\n\n代码运行结果如下\n我们的目的成功达成！\n\n代码优化 2上面的代码虽然完成了我们设想的目的，但它还是有一个  缺点\n需要用户手动输入数字的位数\n\n设想一下，系统需要你填写你的手机号，你输入自己的手机号后，系统还要再问问你“你的手机号有几位数”\n这换谁都血压飙升，怒 m 代码猿了吧！\n\n那怎样让代码自动逆转我们需要的数字呢？\n\n注：这串代码是我在 b 站看到的，顿时联想到了自己的博客，于是又跑过来更新了! 原视频链接\n\n\n图里 while 后面的不等于符号应该是一个 vscode 的插件，我们需要将它改成!&#x3D;\n#include &lt;stdio.h&gt;int main()&#123;\tint num;\tprintf(&quot; 请输入一个数；&quot;);\tscanf(&quot;%d&quot;, &amp;num);\tint reverse = 0;\twhile (num != 0)\t&#123;\t\treverse = reverse * 10 + num % 10;\t\tnum /= 10;\t\t\t&#125;\t// 输出反转后的数字\tprintf(&quot; 反转后的数字是：%d\\n&quot;, reverse);\treturn 0;&#125;\n\n\n这串代码就是完美的了吗？\n并不是，如果我们键入 1000，结果就会发生一些细微的变化\n\n输出的结果竟然是 1，但我们需要的应该是 0001\n\n代码优化 3这里涉及到了 %d 时左补 0 的问题\nprintf 打印时 %d 左补 0假设下面这串代码是需要输出 1000 逆序后数字 0001 的 printf 语句\n因为 1000 只有 4 位，所以我们可以在 % 和 d 之间加上 04\n即满 4 位不补，不满 4 位左补 0\nint n =1;pirntf(&quot;%04d&quot;,n);\n\n但在逆序数字里面，我们需要打印的数字长度是不可控的\n这里需要用到左补 0 的另外一种代码\n\n用另外一个变量来表示数的位数\n\nint n=1;int m=3;// 代表数的位数，同 %03d 里面 3 的意义一样pirntf(&quot;%0*d&quot;,m,n);\n\n这样下来就简单了，我们只需要在原有的 while 循环里面加上另外一个变量\n每次逆序循环完成后，这个变量都 ++ 一次，就能达到我们的目的\n#include &lt;stdio.h&gt;int main()&#123;\tint num;\tint j = 0;\tprintf(&quot; 请输入一个数；&quot;);\tscanf(&quot;%d&quot;, &amp;num);\tint reverse = 0;\twhile (num != 0)\t&#123;\t\treverse = reverse * 10 + num % 10;\t\tnum /= 10;\t\tj++;\t&#125;\t// 输出反转后的数字\tprintf(&quot; 反转后的数字是：%0*d\\n&quot;,j, reverse);\treturn 0;&#125;\n\n运行结果如下：\n\n这下我们的目的才真正完成了，既可以不用自己多输入一遍数字的个数\n又能在输入 10000 这类数字的时候，逆序后自动左补 0\n\n希望这对你有帮助！","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C 语言】printf 函数的执行顺序，涉及函数传参","url":"/posts/3888883052/","content":"问题产生  偶然在 c 语言学习交流群看到了这么一串让人费解的代码\n\n#include &lt;stdio.h&gt;int main()&#123;\tint i = 0;\tint j = 0;\tscanf(&quot;%d&quot;, &amp;i);\tj = -i++;\tprintf(&quot;%d %d %d&quot;, i, j, i++);\treturn 0;&#125;\n\n这里让我疑惑的是，为什么打印的第一个 i 是 6 而不是 5？\n\nprintf 语句的执行顺序  这里要涉及到一个之前我并不清楚的知识点\nscanf(&quot;%d&quot;, &amp;i);j = -i++;printf(&quot;%d %d %d&quot;, i, j, i++);\n\n按照以往我的理解，代码的运行顺序是这样的\n\n1. 用 scanf 将数字赋值给 i\n2. 将 -i 赋值给 j，然后 i++ （注：后置 ++ 是先使用再 ++）\n3.printf 函数依次打印 5，-4，6\n\n可代码君它并不想这么跑\n这里要涉及到函数内数据传参的问题\n函数内数据传参  函数的传参是从右往左开始传参的\n所以这串代码在运行到 printf 的时候，会先执行第二个 i++ 语句，此时 i&#x3D;6\n然后再从左往右依次打印 i，j，和后置 ++ 之前的 i\n\n“首先 -i++，是把 -i 的值 -4 给了 j，然后 i++ 变成了 5，接下来就是函数的传参了，一般是从右 3 向左传参的”\n\n打印是从左往右打印，但是括号内部从右往左计算\n\n总结  这里送给大家一张图，总结这个问题的原理\n如果对你有帮助，还请点个赞再走吧！\n\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】简单的 printf 递归","url":"/posts/4128252829/","content":"简单的 Print 递归\n说句题外话，很多时候单词我是认识的，但是如果它全大写了，我总要反应老一会才能想出来它的意思\n有和我一样的人吗?\n\n今天的 c 语言课讲到了一道非常经典的递归题目\n代码如下：\n#include &lt;stdio.h&gt;void Print(int n)&#123;\tif (n &gt; 9)\t\tPrint(n / 10);\tprintf(&quot;%d &quot;, n % 10);&#125;int main()&#123;\tint num = 0;\tscanf(&quot;%d&quot;, &amp;num);\tPrint(num);\treturn 0;&#125;\n\n结果如下\n\n运行顺序  谈到递归的时候，最重要的就是要弄明白它究竟是怎么运行的\n老师上课讲的方法非常直观的表示了它的运算顺序\n这里我用粘贴代码块的方式来展示\n刚开始执行的是 scanf 输入，这里不再赘述\nvoid Print(int n)&#123;\tif (n &gt; 9)\t\tPrint(n / 10);\tprintf(&quot;%d &quot;, n % 10);&#125;\n\n这一块是我们递归的主体\nvoid Print(int n)&#123;\tif (n &gt; 9)\t  Print(3578 / 10);    \t\tif (n &gt; 9)\t\t\tPrint(357 / 10);    \tprintf(&quot;%d &quot;, 357 % 10);//7    \t\t\tif (n &gt; 9)\t\t\t\tPrint(35 / 10);    \t\tprintf(&quot;%d &quot;, 35 % 10);//5    \t\t\t\tif (n &gt; 9)// 这时候值为 3，已经不满足条件\t\t\t\t\t\tPrint(3 / 10);// 该语句不执行    \t\t\tprintf(&quot;%d &quot;, 3 % 10);//3\tprintf(&quot;%d &quot;, 3578 % 10);//8&#125;\n\n看起来可能有点乱，在这基础上加上一些箭头就会清晰了\n\n起初我的想法是，在进行 if 判断之后，会先执行下面的 printf，即先打印最后一位数 8，再向前打印\n\n实际上，if 语句后的 Print 函数的嵌套调用是在下一行 printf 之前的、\n也就是说它需要像图中这样完全调用完，直到 if 判断为假后，才会从后往前运行 printf 语句\n这才有了最开始我贴的结果\n程序依次打印了每一位的数字\n\n\n如果这篇博客对你有帮助，还请点赞收藏支持一下！万分感谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】验证哥德巴赫猜想","url":"/posts/3088418740/","content":"问题来源  这是学校的一个作业，原题如下\n\n题目先给出了哥德巴赫猜想的背景知识（我还真不知道）\n2000 以内的正偶数都能分解成两个质数（素数）之和\n题目要求  下面来梳理一下题目的要求：\n\n输出样式为 a&#x3D;b+c，使用 %4d&#x3D;%4d+%4d 输出\n每行输出 4 个，每行最后一个输出无空格\n每个偶数只需要一个结果即可（后续较大的偶数有很多种解）\n\n弄懂了题目要求，下面就来一步一步写代码\n\n如何判断素数？在上篇博客里面提到了如何判断素数 &#x3D;&#x3D;&gt;【链接】，这里不再赘述 \n我们需要搞定的是判断是那两个素数 b、c 相加等于我们需要的那个数 a\n因为需要多次判断，这里我们使用自定义函数\nint SuShu(int a)&#123;\tif (a == 2)\t&#123;\t\treturn 1;\t&#125;\tint j = 0;\tfor(j = 2; j &lt;=sqrt(a); j++)\t&#123;\t\tif (a % j == 0)\t\t&#123;\t\t\treturn 0;\t\t&#125;\t&#125;\treturn 1;&#125;\n\n为什么是 return1 和 0 呢？\n因为在写这段代码的时候，我本来是想判断之后返回一个素数，但是这个方法效率太低\n而且写到后面我自己都不会写了，遂放弃。\n\n主函数\n最终实现形式：n&#x3D;a+(n-a)\n\n在自定以函数里面返回的值是 1 和 0\n主函数里面就需要内容来接收\nif (SuShu(a) &amp;&amp; SuShu(n - a))// 判断 a 和 n-a 是否都是素数\n\n同时我们需要完成  打印 4 行换一行，以及每行最后一个不能有空格  的要求\n这时候直接在 printf 语句里面加空格已经不够了\n需要用到判断语句，判断已经打印了几个等式\nif (SuShu(a) &amp;&amp; SuShu(n - a))&#123;\tprintf(&quot;%4d=%4d+%4d&quot;, n, a, n - a);\tcount++;// 每打印一次就 ++ 一次\tif (count % 4 == 0)\t&#123;  // 打印 4 次后打印一个换行符\tprintf(&quot;\\n&quot;);\t&#125;\telse\t&#123;  // 不够 4 次，需要打印空格\tprintf(&quot; &quot;);\t&#125;&#125;\n\n素数判断的部分我们已经写完了\n接下来要写的是一个 for 循环，让 n 从 4 开始一直 + 到 2000\n另外，同 【如何判断素数】 博客中的  开平方法  一样\n在验证哥德巴赫猜想的时候，若 a&#x3D;b+c，b 和 c 中肯定有一个数小于或等于 a&#x2F;2\n在写 a 的 for 循环的时候，我们可以让判断条件 a&lt;&#x3D;n&#x2F;2，而不是 a&lt;n\nfor (n = 4; n &lt;= 2000; n+=2)&#123;\tfor (int a = 2; a &lt;= n/2 ; a++)\t&#123;  // 在之前我们并没有定义 a，需要在 for 循环里加上 int\t\tif (SuShu(a) &amp;&amp; SuShu(n - a))\t\t&#123;\t\t\tprintf(&quot;%4d=%4d+%4d&quot;, n, a, n - a);\t\t\tcount++;\t\t\tif (count % 4 == 0)\t\t\t&#123;\t\t\t\tprintf(&quot;\\n&quot;);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot; &quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t&#125;\n\n到这里，我们的主函数也完成啦！\n完整代码 + 效果演示#include &lt;stdio.h&gt;#include &lt;math.h&gt; int SuShu(int a)&#123;\tif (a == 2)\t&#123;\t\treturn 1;\t&#125;\tint j = 0;\tfor(j = 2; j &lt;=sqrt(a); j++)\t&#123;\t\tif (a % j == 0)\t\t&#123;\t\t\treturn 0;\t\t&#125;\t&#125;\treturn 1;&#125;// 验证哥德巴赫猜想，输出 4 到 2000 的偶数// 每个偶数的结果只输出一次int main()&#123;\tint n = 0;\tint count = 0;\tfor (n = 4; n &lt;= 2000; n+=2)\t&#123;\t\tfor (int a = 2; a &lt;= n/2 ; a++)\t\t&#123;\t\t\tif (SuShu(a) &amp;&amp; SuShu(n - a))\t\t\t&#123;\t\t\t\tprintf(&quot;%4d=%4d+%4d&quot;, n, a, n - a);\t\t\t\tcount++;\t\t\t\tif (count % 4 == 0)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\n&quot;);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot; &quot;);\t\t\t\t&#125;\t\t\t\tbreak; // 只打印一种情况\t\t\t&#125;\t\t&#125;\t\t\t&#125;\treturn 0;&#125;\n\n细心的你肯定注意到，在 main 函数中判断素数的语句里多了一个 break，它的作用是什么呢？\n如果没有 break，结果如下：\n代码会将符合条件的素数相加全部打印出来\n这显然不符合  每个偶数的结果只输出一次  的要求\n\n但在加了 break 这个断点之后\n代码的结果就和题目要求的一样了\n\n\n写代码中的误解  在最终提交代码的时候，我的代码格式出错了\n原因是我在 printf 语句里面加多了两个空格，如下：\nprintf(&quot;%4d= %4d+ %4d&quot;, n, a, n - a);\n\n为什么我会想当然的多加两个空格呢？\n因为题目所给的输出样例，让我误以为 &#x3D; 和 + 之间都有两个空格\n\n实际上这里并没有空格，它的“空格”是 printf 中的 %4d 造成的\n代码给这里留了 4 个数字的位置，但是大多都只有一个数字和两个数字\n于是它们前面就会有 3 或者 2 个留给数字的空，让我误以为这里有空格\n基础不牢，地动山摇！\n\n总结  通过这道题，我复习了循环和自定义函数的写法，也获得了哥德巴赫猜想的新知识\n多刷刷题总是好的\n希望这篇博客对你有帮助！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】如何判断素数","url":"/posts/2649139425/","content":"如何判断素数\n题目要求：输出 100-200 的素数\n\n首先我们要知道什么是素数（质数），以防有人忘记（比如刚学开始学 c 的我就忘记了）\n素数（质数）只能被 1 和它自己整除\n\n\n7 只能被 1 和 7 整除，是素数\n9 能被 3 整除，不是素数\n\n\n方法 1—试除法#include&lt;stdio.h&gt;int main()&#123;    int i=0;    int count=0;    for(i=100;i&lt;=200;i++)    &#123;        int j=0;        for(j=2;j&lt;i;j++)        &#123;             if(i%j==0)//i 可以整除 j，i 不是素数             &#123;                 break;             &#125;        &#125;        if(j==i)//i 只能整除它自己，是素数        &#123;            count++;            printf(&quot;%d &quot;,i);        &#125;    &#125;    printf(&quot;\\ncount=%d\\n&quot;,count);// 计算 100-200 之间有几个素数    return 0;&#125;\n\n\n这个代码比较死，只是输出了 100 到 200 之间的素数，完成了题目的要求\n我们可以把它改造成输入一个数字，判断是否是素数的形式\n\n代码改造 1-1\n用户输入一个数字\n代码判断是否为素数\n是，输出“是素数”以及用户输入的值\n不是，输出“不是素数”\n\n#include&lt;stdio.h&gt;int main()&#123;    int i=0;    int j=0;    scanf(&quot;%d&quot;,&amp;i);    for(j=2;j&lt;i;j++)    &#123;    \tif(i%j==0)        &#123;            printf(&quot; 不是素数 \\n&quot;);            break;    \t&#125;\t&#125;    if(j==i)    &#123;        printf(&quot; 是素数,i=%d\\n&quot;,i);    &#125;      &#125;\n\n结果如下：\n\n\n\n上面的这串代码能很好地完成我们的需求，但它还有优化的空间\n方法 2—开平方法  方法 1 中的 for 循环为 j&lt;i\n如果数字很大的话，要循环非常多次才能出现 j&#x3D;&#x3D;i 的情况\n这就拖慢了我们程序运行的速度\n这里我们引入一个概念\n\n若 i&#x3D;a*b\na 和 b 中至少有一个数字 &lt;&#x3D; 开平方 i\n\n\n如 16&#x3D;2x8&#x3D;4x4\n其中 2&lt;4\n\n这样就能得到一个结论：\n在根号 i 之前一定有一个数字 n 是非素数的除数\n如果找不到这个数字 n，说明该数字为质数\n\n利用  开平方法，我们可以将需要查找的数字范围缩小很多\n以下是用该方法完成  开头题目要求  的代码示例\n#include&lt;stdio.h&gt;int main()&#123;\tint i=0;\tfor(i=101;i&lt;=200;i+=2)\t&#123;\t\tint j=0;\t\tfor(j=2;j&lt;=sqrt(i);j++)\t\t&#123;\t\t\tif(i%j==0)\t\t\t&#123;\t\t\t\tbreak;             &#125;\t\t&#125;\t\tif(j&gt;sqrt(i))\t\t&#123;\t\t\tprintf(&quot;%d &quot;,i);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n\n将这个代码改造成 1-1 那种形式也不难，自己试试吧！\n两个方法分别的弊端  试除法  该方法会错过 1\n开平方法  该方法会错过 2\n\n感谢你看到最后  如果这篇博客对你有帮助，请点赞支持一下，万分感谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】用递归和非递归，求第 n 个斐波那契数","url":"/posts/1174654848/","content":"[toc]\n问题引入 - 什么是斐波那契数列？斐波那契数列中，第 n 项为 n-1 和 n-2 项之和\n\n1，1，2，3，5，8，13，21，34，55……\n\n这个数列非常经典，经常用于编程语言初学者的练习\n接下来让我们用  非递归和递归  两种方式来实现这个数列\n并了解两种方法的优缺点！\n\n1. 非递归方法（迭代）什么是迭代？\n迭代其实和循环的意义差不多（个人理解）\n\n我们计算斐波那契数列的时候，需要从第一项和第二项 1、1 开始计算\n没后一项数字都是前两项数字之和\n这样我们就可以利用循环，从第一项开始不断相加，再使其中一个  加数  等于得到的  和\n以此迭代，就能得到我们需要的第 n 个数字\n\n代码实现#include&lt;stdio.h&gt;// 非递归int fo1(int a)&#123;\tint tmp = 0;\tint num1 = 1;\tint num2 =1;\tif (a &lt; 3) // 前两项都为 1\t&#123;\t\treturn 1;\t&#125;\telse// 从第三项开始迭代\t&#123;\t\tfor (int i = 0; i &lt;= a - 3; i++)\t\t&#123;\t\t\ttmp = num1 + num2;\t\t\tnum1 = num2;\t\t\tnum2 = tmp;\t\t&#125;\t\treturn tmp;\t&#125;&#125;int main()&#123;\tint a,b = 0;\tscanf(&quot;%d&quot;, &amp;a);\tb=fo1(a);\tprintf(&quot;%d\\n&quot;, b);\treturn 0;&#125;\n\n结果如图：\n\n迭代的缺点  这种方法有个缺点，即数字很大的时候，容易栈溢出\n如果栈溢出没有影响，迭代的方法就非常适合\n\n比如：\n\n题目规定了不考虑栈溢出\n\n题目设定了数字范围\n\n\n\n\n2. 递归  使用递归的基本方法，和迭代其实是一样的\n最大的不同是：递归的核心是函数自己调用自己\n\n代码实现#include&lt;stdio.h&gt;// 递归int fo2(int a)&#123;\tif ((a == 1) || (a == 2))\t&#123;\t\treturn 1;\t&#125;\telse\t&#123;\t\treturn (fo2(a - 1) )+(fo2(a- 2));//n-1 和 n-2 项\t&#125;&#125;int main()&#123;\tint a,b = 0;\tscanf(&quot;%d&quot;, &amp;a);\tb=fo2(a);\tprintf(&quot;%d\\n&quot;, b);\treturn 0;&#125;\n\n最终执行的效果是一样的\n递归的缺点  递归的实现方式是函数不停地自己调用自己\n\n如图所示，当我们需要第 50 个斐波那契数列中的数时\n函数需要从 50 开始，49、48，再 48、47……\n这么一直递归到第 3 个斐波那契列数，才能逐级返回每项的数字，得出最终答案\n这就大大增加了程序运行的时间！\n\n你可能会发现程序依旧很快运行完了，那是因为现在电脑 cpu 的运行速度已经非常快了\n但在有运行时间要求的题目中，这样浪费时间是万万不可的\n\n\n总结  递归和迭代两种方法各有优劣，我们需要在具体情境中选择是使用递归还是迭代\n计算斐波那契数列只是这其中的一部分\n如果这篇博客对你有帮助，那就点个赞再走吧！\n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C 语言】整型数据在内存中的存储 (详解)","url":"/posts/3848679385/","content":"[toc]\n数据类型  我们知道，C 语言中有很多不同的数据类型\n在 cppreference.com 网站上可以找到 C 语言中的不同类型【链接】\n\n先来认识一个不那么常见的类型\n布尔类型 C99 中引入了布尔类型  _Bool实质：把 1 和 0 变成 ture 和 false\n#include&lt;stdbool.h&gt;int main()&#123;\t_Bool flag = true;\tif(flag)\t&#123;\t\tprintf(&quot;hehe\\n&quot;);\t&#125;\treturn 0;&#125;\n\n代码的效果如下：\n\n因为  布尔类型  和以 1-0 来判断正误的作用是相同的\n所以这个类型我们一般不会使用\n\n无符号数据的打印Unsigned 无符号数用 %u 打印\n\n\n用 %d 打印的时候，认为是有符号数\n用 %u 打印无符号数的时候，负数会乱码\n\n\n我们知道，整型数据在内存中占用 4 个字节（32 位），double 类型是 8 个字节\n不同数据占用的字节\n在之前的学习中，我们已经知道了如何使用这些不同的数据类型\n但是你知道，数据在内存中是怎么存储的吗？\n这篇博客将带你认识整型在内存中的存储\n\n整型在内存中的存储  先来认识一下整型家族都有谁吧！\n整型家族\n\nchar\n​\tunsigned char\n​\tsigned char\n\nshort\n​\tunsigned short [int]\n​\tsigned short [int]\n\nint\n​\tunsigned int\n​\tsigned int\n\nlong\n​\tunsigned long [int]\n​\tsigned long [int]\n\n\n\n我们平时用的最频繁的 int 其实是 signed int\n\nchar 到底是 signed char 还是 unsigned char，取决于编译器的实现\n常见的编译器下，char 就是 signed char\n\n在知道整型在内存中的存储方式之前\n我们需要先认识一下三个好朋友“原 反 补”\n“原反补”三兄弟  正整数：原反补码相同\n负整数：\n\n\n\n原码\n按照一个数的正负直接写出来的二进制\n\n\n\n反码\n符号位不变，其他位按位取反\n\n\n补码\n反码的二进制序列 +1，得到补码\n\n\n二进制要怎么写出来呢？下面以 15 为例（前面省略了 24 位）\n每一个 1 都是 2 的权重\n\n这就是二进制和十进制转换的方式\n而 15 作为正数，原反补码都是这个二进制数\n\n00000000 00000000 00000000 00001111\n正数的原反补码相同\n\n\n什么是符号位？每一个整型都有 4 个字节，由 32 个 bit 位组成\n其中原码的第一位，就是该二进制的  符号位\n正数为 0，负数为 1\n\n最高位为符号位，后面的是有效位\n\n再举个 -15 的例子\n\n\n\n10000000 00000000 00000000 00001111\n原码\n\n\n\n11111111 11111111 11111111 11110000\n反码\n\n\n11111111 11111111 11111111 11110001\n补码\n\n\n为了进一步了解数据在内存中的存储方式，我们将 15 的 &#x3D;&#x3D; 补码 &#x3D;&#x3D; 转化为十六进制\n每 4 个二进制比特位对应一个十六进制数，转换结果如下\n\n\n\n00000000\n00000000\n00000000\n00001111\n\n\n\n00\n00\n00\n0F\n\n\n\n可当我们  在 VS 编译器 - 监视 - 内存窗口  里面查看 15 数据的时候\n展示的是以下的 16 进制形式\n\n可以看到，内存中存储的十六进制，和我们计算出来的是 &#x3D;&#x3D; 反着的 &#x3D;&#x3D;\n这又是为什么呢？\n\n大小端问题  高位低位  来自于人类从左到右的阅读习惯。所以一串二进制数，左侧为高位，右侧为低位\n大端字节序存储：\n当一个数据的低字节的数据存放在高地址处，高字节序的内容放在了低地址处，这种存储方式就是大端字节序存储\n小端字节序存储：\n当一个数据的低字节数据存放在低地址处，高字节序的内容放在了高地址处，这种存储方式就是小端字节序存储\n\n简称：小同大异\n\n而我们图中 VS 内存窗口显示的这种“反着放”的方式，是因为：\n\nVS 编译器下，内存窗口显示的是  左低右高\n二进制码是  高00000000 00000000 00000000 00001111低\n\n所以 VS 编译器是  小端存储  的\n\n而如果是以  低00 00 00 0f高  的方式放入内存，则是  大端字节序存储\n\n负数示例\nint b=-10；\n\n\n\n\n原码 10000000\n00000000\n00000000\n00001010\n\n\n\n反码 11111111\n11111111\n11111111\n1110101\n\n\n补码 11111111\n11111111\n11111111\n11110110\n\n\nf    f\nf    f\nf    f\nf    6\n\n\n\n了解了大小端的机制之后，我们可以来写一个简单的函数\n判断当前编译器是大端还是小端\n#include &lt;stdio.h&gt;int check_sys()&#123;\tint a=1;\tchar*p=(char*)&amp;a;\tif(1==*p)\t\treturn 1;\telse\t\treturn 0;\t\t&#125;int main()&#123;\tint b=check_sys(); \tif(1==b)\t\tprintf(&quot; 小端 \\n&quot;);\telse\t\tprintf(&quot; 大端 \\n&quot;);    \treturn 0; &#125; \n\n这串代码的自定义函数部分可以进行优化\n\n因为 *p&#x3D;1 时返回 1\n其他情况返回 0\n所以可以选择直接返回 *p\n\n// 代码优化 2 int check_sys()&#123;\tint a=1;\tchar*p=(char*)&amp;a;\treturn *p;\t&#125;\n\n进一步优化，我们可以把(char*)&amp;a 直接进行解引用并返回他的值\n这样就能跳过中间变量 p\n// 代码优化 3int check_sys()&#123;\tint a=1;\treturn *(char*)&amp;a;\t&#125;\n\n这里有两个问题需要注意：\n不能直接对 a 进行强制类型转换，这种方式是错的\n大小端是把数据放在内存之后才有的现象\n\n大小端讲的是以字节为单位的顺序\nchar 类型只有一个字节，没有大小端问题\n\n\n为什么整型在内存中存放的是补码呢？\n在计算机系统中，数值一般用补码来表示和存储，原因在于，试用补码，可以将符号位和数值域统一处理；\n同时，加法和减法也可以统一处理(CPU 只有加法器)\n此外，补码与反码相互转换，其运算过程是相同的，不需要额外的硬件电路。\n\n计算机中只有加法器，减法用加法来模拟\n1-1→1+(-1)\n如果用原码的计算：\n\n\n\n00000000 00000000 0000000 00000001\n+\n\n\n\n10000000 00000000 0000000 00000001\n&#x3D;\n\n\n10000000 00000000 0000000 00000010\n-2 错误\n\n\n补码：\n\n\n\n00000000 00000000 0000000 00000001\n1 原\n\n\n\n10000000 00000000 0000000 00000001\n-1 原\n\n\n它们的补码\n\n\n\n00000000 00000000 00000000 00000001   +\n1 的补码\n\n\n\n11111111 11111111 1111111 11111111   &#x3D;\n-1 的补码\n\n\n00000000 00000000 0000000 00000000\n结果为 0\n\n\n 其中第一个 1 为符号位\n\n结语  到这里，整型在内存中存储的基本知识就已经讲完啦\n如果对你有帮助，还请不要吝啬手里的赞👍！\n能留下个评论就更好了\n这对我真的很重要！！！\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【C 语言】unsigned 无符号类型运用的两个实例","url":"/posts/26306730/","content":"@[toc]\n前排提醒😂本篇博客是对下一篇博客《char 类型在内存中的存放》的拓展\n并非对 unsigned 类型的详解！\n\n示例 1#include &lt;stdio.h&gt;int main()&#123;\tint i=-20;\tunsigned int j=10;\t\tprintf(&quot;%d\\n&quot;,i+j);\treturn 0; &#125; \n\n当有符号类型和无符号类型相加的时候，编译器是怎么处理的呢？\n10000000 00000000 00000000 00010100  -20的原码11111111 11111111 11111111 11101011   反码11111111 11111111 11111111 11101100   补码\n\n00000000 00000000 00000000 00001010   10的补码\n\n-20 的补码和 10 的补码 相加\n11111111 11111111 11111111 11110110 得到的补码11111111 11111111 11111111 11110101 反码10000000 00000000 00000000 00001010 原码 -10\n\n得到的结果为 -10\n\n当我们把 j 改为 -10 的时候，编译器依然能给出正确的答案 -30\n这是因为在计算的时候，编译器先按照  补码的形式  进行运算，最后 %d 打印，格式化为有符号整数\n\n数据的存储和类型无关，只有读取的时候有区别\n\n\n示例 2 第二个示例可以让我们了解无符号数在应用时候存在的限制\n#include&lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123;\tunsigned int i;\tfor(i=9;i&gt;=0;i--)\t&#123;\t\tprintf(&quot;%u\\n&quot;,i);\t\tSleep(1000);// 更好的观察数据的打印\t&#125;\treturn 0;&#125;\n\n因为这里我们使用的是 %u 打印无符号数\n而无符号数 i 中不可能出现负数，也就没有小于 0 的情况（i 永远大于等于 0）\n当 i&#x3D;0 后继续–，二进制补码变成如下形式\n11111111 11111111 11111111 11111111\n\n因为是无符号数，直接将补码视作原码进行计算\n就得出了在窗口中打印的非常大的数字\n\n\n小结  本篇博客展示了两种无符号数调用的情况\n下篇博客讲述 char 类型在数据中的存储的时候会用到！\n\n最近事情真的挺多的，英语 4 级、期末考试\n高数和线代真的太难了，两座大山压着我😥\n希望期末不挂科\n\n感谢你看到最后，求点赞关注！\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【C 语言】整型提升和算术转换","url":"/posts/3918217186/","content":"[toc]\n整型提升  要想知道什么是整型提升，那就要从表达式求值说起\n表达式求值\n表 达 式 求 值 的 顺 序 一 部 分 是 由 操 作 符 的 优 先 级 和 结 合 性 决 定\n同 样，有 些 表 达 式 的 操 作 数 在 求 值 的 过 程 中 可 能 需 要 转 换 为 其 他 类 型 \n\n什么是表达式？ 举个最简单的例子\nint main()&#123;\tint a=3;\tint b=5;\tint c = a + b * 7;\t//c 的式子即为表达式\treturn 0;&#125;\n\n而 C 的整个式子就是一个  表达式求值\n在这之中，参与计算的两个变量以及结果变量都是 int 类型，并不需要进行整型提升\n在我们日常编写代码的时候，编译器经常会有  隐式类型转换\n\n隐式类型转换\nC 的整型算术运算总是至少以缺省整型类型的精度来进行的\n为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转化为普通整型，这种转换称为  整型提升\n\nfloat f =3.14int num =f;\n\n在上面这个代码中就有隐式类型转换，由 float 型转换为 int 型\n但是会有精度的丢失\n\n此时 num 为 3\n\n\n我们知道，不同数据类型的数据大小如下\n数据类型及大小\n\n\nchar\n字符数据类型\n4byte\n\n\n\nshort\n短整型\n2byte\n\n\nint\n整型\n4byte\n\n\nlong\n长整型\n4(32), 8(64)\n\n\nlong long\n长长整型\n8byte\n\n\nfloat\n单精度浮点型（实型）\n4byte\n\n\ndouble\n双精度浮点型（实型）\n8byte\n\n\n可以看到，short 类型和 char 类型的字节数都是小于 int 类型的\n当我们将一个 int 类型的数据存放到 char 中时，会发生  截断\n截断 &amp; 提升\n把四个字节放在 1 个字节的内容中，截断，只保留一个字节\n把数字 5 放入 char 类型中，5 的 4 个字节的内容会被截断\n\n示例\nchar a = 3;   //00000000000000000000000000000011 为 3 的二进制   //00000011 -a\n\n在 char 类型 a 中，只存放了 3 的后 8 位 (1 个字节) 的内容\n这就是  截断  的表现形式\n\n在 char 类型数据的表达式求值中，就会发生整型提升\n规则如下：\n\n把最高位视为符号位进行提升，在 a 和 b 的 8 位码前加 24 个 0 或 1\n\n代码示例 1#include &lt;stdio.h&gt;int main()&#123;    char a = 3;    //00000000000000000000000000000011 为 3 的二进制    //00000011 -a    char b = 127;    //00000000000000000000000001111111 为 127 的二进制    //01111111 -b    char c = a + b;    // 把最高位视为符号位进行提升    // 在 a 和 b 的 8 位码前加 24 个 0    //00000000000000000000000000000011    //00000000000000000000000001111111    //00000000000000000000000010000010    //10000010 为 char c    //11111111111111111111111110000010  - 补码    //11111111111111111111111110000001  - 反码    //10000000000000000000000001111110  - 原码    // -126    // 发现 a 和 b 都是 char 类型的，都没有达到一个 int 的大小    // 这里就会发生整型提升    printf(&quot;%d\\n&quot;, c);//%d 是有符号数，打印原码    return 0;&#125;\n\n编译器中，负数是以补码的形式存放的\n但在使用的时候，要先转换成原码再计算其数值\n代码示例 2再来看一个比较大小的示例\nint main()&#123;\tchar a = 0xb6;\tshort b = 0xb600;\tint c = 0xb6000000;\t\tif(a==0xb6)\t\tprintf(&quot;a&quot;);\tif(b==0xb600)\t\tprintf(&quot;b&quot;);\tif(c==0xb6000000)\t\tprintf(&quot;c&quot;);        return 0;&#125;\n\n猜猜打印结果是什么？\n是这个吗？\nabc\n\n错！\n\n运行后，我们会发现编译器只打印了 c 这个字符\n\n因为 if 只会比较整型\n而 char 和 short 类型都不足 4 个字节，在比较的时候需要进行  整型提升\n提升之后的结果与原数据不同\n\n而 int c 本身就是整型，无须进行整型提升\nint c = 0xb6000000;\n\n所以代码只打印了字符 c\n\n代码示例 3再来看下面的这个代码，打印的结果是几呢？\n#include &lt;stdio.h&gt;int main() &#123;    int a = 3;   int b = 5;    short s = 5;   printf(&quot;%u\\n&quot;, sizeof(s = a + 3));        return 0;&#125;\n\n结果为 2\n因为最后的 s 是短整型，推断出来的长度为 2\n\n代码示例 4 -sizeofint main()&#123;\tchar c=1;\tprintf(&quot;%u\\n&quot;,sizeof(c));//1    printf(&quot;%u\\n&quot;,sizeof(+c));//4    printf(&quot;%u\\n&quot;,sizeof(-c));//4    printf(&quot;%u\\n&quot;,sizeof(!c));//4        return 0;&#125;\n\n当 +c 和 -c 参与计算的时候，就会进行整型提升\n\n这里涉及到了另外一个重要的知识点，sizeof 括号中表达式的问题\n下篇博客会详细介绍!\n\n\n算术转换  说完整型提升，接下来就是和  隐式类型转换  很像的  算术转换\n\n如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转换为另外一个操作数的类型，否则操作就无法进行。\n\n下面的层次体系称为  寻常算术转换\n\n\n\nlong double\n\n\n\ndouble\n\n\nfloat\n\n\nunsigned long int\n\n\nlong int\n\n\nunsigned int\n\n\nint\n\n\n具体是怎么转换的呢?\n在进行运算的时候，如果某个操作数的类型在上表中排名较低，那么首先要转换为另外一个操作数的类型后，再执行运算。\n简单地说，就是从下往上转换\n\n注意：算术转换要合理，不然会有潜在的问题\n\n\n代码示例 1下面的是一个简单算术转换的示例\n在 int 型和 float 类型一起计算的时候\nint 类型会转换为 float 类型进行计算\n#include&lt;stdio.h&gt; int main()&#123;\tint a=3;\tfloat f =5.5;\tfloat ra =a+f;\t// 算术转换，int--&gt;float \t\treturn 0;&#125;\n\n\n表达式属性  这里可以引出另外一个知识点，表达式的属性\n表达式的两个属性：\n\n值属性\n类型属性\n\n如以下代码中\n\na+b 的结果 30 就是这个表达式的指属性\n\n类型属性是 int\n\n\nint main()&#123;\tint a =10;\tint b=20;\ta+b;// 表达式 2 个属性：值属性，类型属性\t//30 值属性 \t//int 类型属性 \treturn 0;&#125;\n\n\n结语  本篇博客到这里就结束了\n如果对你有帮助的话，还请点个赞再走吧！\n这对我非常重要！\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【C 语言】浮点数在内存中的存储（详解）","url":"/posts/3650400098/","content":"[TOC]\n写在前面，markdown 语法的小知识点\n如何实现  文字变红且加上了底色？如hello world\nmarkdown 语法如下即可！\n`hello world`\n\n以及页内跳转\n&lt;span id=\"jump\"&gt; 这一句话没啥用 &lt;/span&gt;[回到开头](#jump)\n\n\n之前学习完了整形、字符类型在内存中的存储，今天让我们来看看 float 类型！\n\n整数类型👉【int】\n字符类型👉【char】\n\n常见的浮点数3.141591E10\n\n浮点数家族包括 float、double、long double  类型\n而浮点数表示的范围是在头文件 &lt;float.h&gt; 里面定义的\n需要了解的是\n\n如果你打出 3.14，编译器默认是 double 类型的。若想让他为 float 类型，则要在前面加 f\n\n\n1E10 是科学计数法，代表 1.0×10^10\n\n代码引例  这一句话没啥用\n先来看看下面这串代码\nint main(){\tint n = 9;\tfloat* pfloat = (float*)&amp;n;\tprintf(\"n 的值为：%d\\n\", n);\tprintf(\"*pfloat 的值为：%f\\n\", *pfloat);\t*pfloat = 9.0;\tprintf(\"num 的值为：%d\\n\", n);\tprintf(\"*pfloat 的值为：%f\\n\", *pfloat);\treturn 0;}\n\n运行的结果如下\n\n指针 pfloat 保留的是强制转换为 float 类型的 int 变量 n\n\n准确来说，是将 int 指针类型强制转换为了 float 指针类型\n\n那打印的结果不应该是 9 吗？为什么是 0.000000 呢？\n再来看看后面的代码，我们  让 *pfloat=9.0，用 %d 打印  的时候，却打印出了一串不知道怎么来的很大的数字。这又是为什么呢？\n一个涉及到的小知识点\n不管是 double 类型，还是 float 类型，默认小数点后都有 6 位\n我们可以用 %.f 的方式来控制打印，如 %.3f 就是只打印到小数点后 3 位\n\n\n答案只有一个：浮点型在内存中的存储方式和 int 类型完全不同！\n浮点型如何在内存中存放？根据国际标准 IEEE（电气和电子工程协会） 754，任意一个二进制浮点数 V 可以表示成下面的形式：\n\n\n(-1)^s 表示符号位，当 s=0，V 为正数；当 s=1，V 为负数。\n\nM 表示有效数字，大于等于 1，小于 2。\n\n2^E 表示指数位。\n\n\n\n\n十进制 &amp; 二进制的科学计数法  我们在小学就学到过，1.234×10^2=123.4\n而二进制中，其实就是把底数的 10 变成了 2，1.011*2^2=101.1\n记住以下这个结论即可\n\n二进制码 M 乘以 2 的 n 次方，相当于将二进制码 M 的小数点向右移动 n 位\n\nS\\M\\E 如何判断？我们以 5.5 为例，它的二进制是101.1\n相当于(-1)^0* 1.011*2^2\n和上面的公式比对，我们可以读出来 S=0，M=1.011，E=2\n\n在之前的学习中，我们知道 float 类型占用 4 个字节的空间，而 double 类型则是 8 个字节\n浮点类型的内存空间示意图\nfloat 类型的 S\\E\\M 被分区存放在这 4 个字节的内存空间中\n同理，double 类型的 S\\E\\M 也是分区存放，它的有效数字长于 float 类型\n对于 64 位的浮点数，最高的 1 位是符号位 S，接着的 11 位是指数 E，剩下的 52 位为有效数字 M\n\nIEEE754 对 M 的特殊规定  因为是二进制数，1≤M&lt;2，而 M 可以写成 1.xxxxxx 的形式，其中 xxxxxx 是小数部分\nIEEE 754 规定，在计算机内部保存 M 时，默认这个数的  第一位总是 1，因此可以被舍去，只保存后面的\nxxxxxx 部分\n\n比如保存 1.01 的时候，只保存小数点后的 01，等到读取的时候，再把第一位的 1 加上去\n这样做的目的是节省 1 位有效数字。以 32 位浮点数为例，留给 M 只有 23 位，将第一位的 1 舍去以后，等于可以保存 24 位有效数字。\n\n我在学习的时候，关于这个 24 位有效数字 曾产生了疑惑。\n实际上它并不难理解：\n在内存中，32 位浮点数的 M 有 23 位的空间，如果我们保存了小数点前面的 1，就只能保存 小数点后 22 位  的内容。\n但如果我们省略 1，只保留小数点后的内容，那不就能保存到  小数点后第 23 位  了吗？再加上原来小数点前的 1，不就是 24 位有效数字了！\n\nIEEE754 对指数 E 的特殊规定E 是一个无符号整数(unsigned int)\n\n如果 E 为 8 位，它的取值范围是 0-255\n如果 E 为 11 为，它的取值范围是 0-2047\n\n可是科学计数法里面的 E 是可以出现  负数  的。\n所以 IEEE754 规定，存入内存时 E 的  真实值  必须再加上一个  中间数\n\n8 位的 E，中间数是 127\n11 位的 E，中间数是 1023\n\n\n例：2^10 的 E 是 10，所以保存为 32 位浮点数 的时候，E 必须保存为 10+127=137，即 10001001。\n保存为 64 位浮点数的时候，E 保存为 10+1023=1033，即 10000001001\n\n①当 E 不为全 0 或全 1 时  浮点数采用下面的规则来进行存放：\n\n内存中指数 E 的计算值减去 127(或 1023)，得到 E 的真实值，再将有效数字 M 前面加上第一位的 1\n\n以 32 位浮点数  举例：\n0.5 的二进制形式为 0.1。科学计数法中整数部分必须为 1，小数点应右移一位。\n则为 1.0*2^(-1)，E 的真实值为 -1，存放在内存中为 -1+127=126(01111110)\nM 存放小数点后的 0，补全 23 位，全为 0\n这时候 0.5 的二进制表现形式就是\n0 01111110 00000000000000000000000\n\n\n\n\nS\nE\nM\n\n\n\n0\n01111110\n0 01111110 00000000000000000000000\n\n\n\n②当 E 为全 0 时\n这时，浮点数的指数 E 等于 1-127（或者 1-1023）即为真实值\n有效数字 M 不再加上第一位的 1，而是还原为 0.xxxxxx 的小数\n这样做是为了表示±0，以及接近于 0 的很小的数字\n\n③当 E 为全 1 时  当 E 为全 1 时，原 E 为 128，数字非常大，相当于无穷大\n\n这时，如果有效数字 M 全为 0，表示±无穷大（正负取决于符号位 s）\n\n\n解释开篇代码  回到开头\n整形 9 的原码如下\n00000000 00000000 00000000 00001001\n\n当我们将它强制存放到 float 类型的指针中时\n\n\n\nS\nE\nM\n\n\n\n0\n00000000\n0000000 00000000 00001001\n\n\n解码出来就是 $$(-1)^00.0000000 00000000 000010012^{-126}$$ 这是一个很小的数字，远小于 float 类型默认的小数点后六位，所以 printf 打印的是 0.000000\n\n*pfloat = 9.0;printf(\"num 的值为：%d\\n\", n);printf(\"*pfloat 的值为：%f\\n\", *pfloat);\n\n这里 9.0 就是以浮点数的形式存入 float 指针的\n\n9.0  十进制\n1001.0 二进制\n\nS=0,M=1.001,E=3二进制码0100 0001 0001 0000 0000 0000 0000 0000\n\n开启调试，在内存框中查看 n 的地址如下\n\n\n\n\n41\n10\n00\n00\n\n\n\n0100 0001\n0001 0000\n0000 0000\n0000 0000\n\n\n正好对应了浮点数 9.0 在内存中存放的二进制码\n最后 n 以 %d 打印出来，就是我们看到的 1091567616\n结语  考试周快要结束啦！\n寒假将开始新的代码学习\n\n终于补上了之前欠下的博客了，当作是一种复习吧，的确有不少东西已经忘记的差不多了😥\n\n感谢你看到最后，点个赞再走吧！\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【C 语言】指针进阶第二站，指针数组","url":"/posts/2460304186/","content":"[TOC]\n嘟嘟嘟🚌，指针进阶的第二站  指针数组  到了！\n上车上车！\n\n回顾一下第一站🚍的内容：字符指针\n\n\n指针数组  数组是一种类型的数的集合\n\n整型数组的元素都是 int 类型\n指针数组的元素都是  指针变量\n\nint* arr1[10];// 整型指针的数组char*arr2[10];// 一级字符指针的数组char** arr3[5];// 二级字符指针的数组\n\n参考这一份示意图\n\n示例 1: 定义多个字符指针  在上一站的字符指针里面，提到了可以直接用指针来创建一个  常量字符串\n同理，我们可以将多个指针放在一块，凑成指针数组，一次性创建多个  指向  常量字符串  的指针\n\nint main()&#123;\tchar* arr[] = &#123; &quot;abcdef&quot;, &quot;qwer&quot;, &quot;zhangsan&quot; &#125;;\tint i = 0;\tint sz = sizeof(arr) / sizeof(arr[0]);\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tprintf(&quot;%s\\n&quot;, arr[i]);\t&#125;\treturn 0;&#125;\n\n示例 2: 存放数组名的数组  在之前的学习中，我们知道：数组名代表数组首元素的地址\n可以说，数组名本质上也是一个  指针\n既然是指针，就能放进指针数组里面\nint main()&#123;\tint arr1[] = &#123; 1,2,3,4,5 &#125;;\tint arr2[] = &#123; 2,3,4,5,6 &#125;;\tint arr3[] = &#123; 3,4,5,6,7 &#125;;\tint* arr[] = &#123;arr1, arr2, arr3&#125;;\t//arr 是指针数组\tint i = 0;\tfor (i = 0; i &lt; 3; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; 5; j++)\t\t&#123;\t\t\tprintf(&quot;%d &quot;, arr[i][j]);//*(*(arr+i)+j)\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\treturn 0;&#125;\n\n这串代码中，我们需要了解的是 arr[i][j] 和*(*(arr+i)+j)之间的关系\n\n以下内容，我的理解可能有偏差。若有错误，还请大佬们无情指正！\n\n\narr[i][j]和 *(*(arr+i)+j)\n它们都是访问数组的形式，用到了不同的操作符\n但表达的含义相同：下标为 i、j 的元素\n\n在内存中，数据的存储是连续的\n创建一个二维数组，可以看到两行的数据是连续存放在数组里面的\nint arr4[2][2]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;\n\n\n既然是连续的，我们就可以用指针 ++ 的形式来访问二维数组里面的所有元素\n\n\n*(arr+i)指向第 i 行元素\n*(arr+i)+j指向第 i 行下标为 j 的元素的  地址\n*(*(arr+i)+j)再次解引用，得到 j 元素\n\n\n数组名的本质是地址 ，是该数组 首元素  的地址\n二维数组的首元素是  第一行 ，数组名 arr 就是 第一行的地址\n我们可以把二维数组的每一行理解为  独立的一个一维数组\n这时候，二维数组的形式和上述代码中 int* arr[] 数组的形式就相同了\nint arr1[] = &#123; 1,2,3,4,5 &#125;;int arr2[] = &#123; 2,3,4,5,6 &#125;;int arr3[] = &#123; 3,4,5,6,7 &#125;;//arr1 arr2 arr3 是二维数组里面的每一行int* arr[] = &#123;arr1, arr2, arr3&#125;;//arr 等价于一个二维数组，但有不同\n\n因此，我们可以用二维数组访问的形式来访问 int* arr[] 数组\n\nint* arr[]和二维数组的不同int*arr 数组里的元素 arr1，arr2，arr3 的地址是连续存放的\n\n这里设计到一个新概念：数组指针\n将在下一站🚌讲解！\n\n\n但是它们对应的各自的数组内数据并不连续\n如：arr1 和 arr2 这两个数组各自元素的地址并不连续\n\n\n示例 3：存放二级指针的数组  既然一级指针可以放进数组里，二级指针也是指针，同样也能塞进数组里\n下面这串代码里面的 arr2 就是一个  存放二级指针的数组\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint* p = &amp;a;\tint** pp = &amp;p;\tint** arr2[4] = &#123;pp&#125;;\treturn 0;&#125;\n\n\n结语🚍第二站的路程到这里就结束了！\n敬请期待下一站的  数组指针  航程吧！\n\n如果你对博客内容有疑问，欢迎在评论区提出哦，万分感谢！\n\n","categories":["初识C语言"],"tags":["C语言","数组","指针"]},{"title":"【C 语言】指针进阶第五站，函数指针","url":"/posts/2864366636/","content":"[TOC]\n\n指针进阶第五站🚏：函数指针\n点进我的主页，可以回顾前四站的内容哦~\n\n1 函数指针  函数也有自己的地址，函数名 &#x2F;&amp; 函数名 就是函数的地址\n \n1.1 基本形式  在数组指针  的学习中我们了解到\nint arr[5];int (*pa)[5] = &amp;arr;//pa 是数组指针\n\n\n指针变量 pa 的类型是int(*)[5]\n\n那么函数指针的形式是怎样的呢？\nvoid test(char* str)&#123;&#125;int main()&#123;\tvoid (*pt)(char*) = test;    //pt 是一个函数指针\treturn 0;&#125;\n\n\npt 的类型是void (*)(char*)\n\n下面哪个代码有能力存放函数的地址呢？\nvoid (*pfun1)();void *pfun2();\n\n答：pfun1 可以存放\n\n\npfun1 先和 * 结合，说明 pfun1 是指针，指针指向的是一个函数，指向的函数无 参数，返回值类型为 void\n\npfun2 先和 () 结合，判断为一个返回值为 int* 类型的函数\n\n\n\n那么，如何书写一个函数指针呢？\nint Add(int x, int y)&#123;\treturn x + y;&#125;\n\n以 Add 函数为例，它有两个 int 类型的形参，返回类型是 int\n所对应的函数指针就是 int(*)(int,int) 类型\nint (*pf)(int, int) = Add;\n\n依据以下几步就能正确写出函数指针\n\n确定函数的返回类型\n\n确定函数的参数类型和个数\n\n把函数参数类型里的变量名去掉，放入括号里\n(int x,int y)去掉 x、y，即(int,int)\n\n在前面加上函数的返回类型\n\n最后加上(*)，以及函数指针变量名\n\n\n需要注意的是，(*pf)的括号不能省略，否则编译器会报错\n\n去掉括号之后就相当于  函数声明，无法赋值\n\n\n1.2 用函数指针来调用函数  如下图所示，当我们定义了一个函数指针后\n就可以通过指针来访问原函数\n这时候 (*pf) 其实就相当于my_test\n\n我们可以通过函数指针来调用上面提到过的 Add 函数\nint Add(int x, int y)&#123;\treturn x + y;&#125;int main()&#123;\tint (* pf)(int, int) = Add;\tint sum = (*pf)(2,3);\tint sum1 = pf(2, 3);\tint sum2 = Add(2, 3);\tprintf(&quot;%d\\n&quot;, sum);\tprintf(&quot;%d\\n&quot;, sum1);\tprintf(&quot;%d\\n&quot;, sum2);\treturn 0;&#125;\n\n可以看到，sum 和 sum1 两种形式都正确调用了该函数\n\n因为我们已经把 Add 的地址转给了 pf 指针，函数名 Add和  指针 pf实际上是等价的\n所以在使用函数指针的时候，可以不带 * 使用。但是带 * 的时候一定要加括号！\n1.3 两个奇葩的代码  奇葩代码 1(*(void (*)())0)();\n\n\n这里的 0 仅为示例，我们在正常使用的时候并不能访问 0 的地址\n\n看到这个代码的时候，是不是有点懵？\n别急，让我们来慢慢分析一波！\n\n奇葩代码 2void (*signal(int , void(*)(int)))(int);\n\n\n说人话就是，signal 函数内  传入  了一个 void(*)(int) 的函数指针，返回值  也是一个 void(*)(int) 的函数指针！\nvoid fun(int num)&#123;\tprintf(&quot;fun--&gt;%d\\n&quot;, num);&#125;void (*signal( int, void(*)(int) ) )(int);int main()&#123;\tvoid(*pf)(int);// 定义一个函数指针\tpf = signal(100, fun);    // 为 signal 函数传参，并用 pf 指针接收\treturn 0;&#125;\n\n“这个代码 2 是真的奇葩，就没有什么办法把他变成人话吗？(简化一下)”\n当然有！那就是用 typedef 函数来给 void(*)(int) 指针起一个新名字！\ntypedef void(*pf_t)(int);// 把 void(*)(int)命名为 pf_t\n\nvoid(*p)(int);//p 是函数指针变量的名字typedef void(*pf_t)(int);//pf_t 是一个新的类型名\n\n这样我们的代码就能得到简化\nvoid (*signal( int, void(*)(int) ) )(int);// 源代码// 简化后pf_t siganal(int,pf_t);\n\n这样是不是就更容易分辨了？\n\n2 函数指针数组 2.1 基本形式 既然函数指针也是一个指针类型，那我们就可以用指针数组来存放它\n\n前提：这些函数的  参数类型、返回类型  一致\n\nint Add(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125;// 函数指针数组int (*pfArr[4])(int, int) = &#123;Add, Sub, Mul, Div&#125;;\n\n相比于分开写多次函数调用\n// 多次函数调用int (*pf1)(int,int) = Add;int (*pf2)(int, int) = Sub;int (*pf3)(int, int) = Mul;int (*pf4)(int, int) = Div;\n\n函数指针数组可以让我们以使用数组的形式来访问每个函数\nint Add(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125;int main()&#123;\tint (*pfArr[4])(int, int) = &#123;Add, Sub, Mul, Div&#125;;// 函数指针数组\tint i = 0;\tfor (i = 0; i &lt; 4; i++)\t&#123;\t\t//int ret = (*pfArr[i])(8, 4);\t\tint ret = pfArr[i](8, 4);\t\tprintf(&quot;%d\\n&quot;, ret);\t&#125;\treturn 0;&#125;\n\n这样也简化了我们的代码\n2.2 计算器实现2.2.1switch 语句\n目的：实现一个计算器\n菜单：用数字来选择运算类型\n方法：以 switch&#x2F;case 语句来实现函数调用\n结束：用 do&#x2F;while 实现多组输入，以及结束程序\n\nint Add(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125;void menu()&#123;\tprintf(&quot;**********************************\\n&quot;);\tprintf(&quot;*****  1. add     2. sub     *****\\n&quot;);\tprintf(&quot;*****  3. mul     4. div     *****\\n&quot;);\tprintf(&quot;*****  0. exit               *****\\n&quot;);\tprintf(&quot;**********************************\\n&quot;);&#125;int main()&#123;\tint input = 0;\tint x = 0;\tint y = 0;\tint ret = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot; 请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tprintf(&quot; 输入 2 个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Add(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 2:\t\t\tprintf(&quot; 输入 2 个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Sub(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 3:\t\t\tprintf(&quot; 输入 2 个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Mul(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 4:\t\t\tprintf(&quot; 输入 2 个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Div(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot; 退出计算器 \\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot; 选择错误 \\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n这种方式需要写非常多的重复代码，而且代码长度很长😵\n我们可以使用  函数指针  对它进行优化\n\n2.2.2 函数指针形式int main()&#123;\tint input = 0;\tint x = 0;\tint y = 0;\tint ret = 0;\tint (*pfArr[5])(int, int) = &#123;0, Add, Sub, Mul, Div&#125;;    //pfArr 是一个函数指针的数组，也叫转移表\tdo\t&#123;\t\tmenu();\t\tprintf(&quot; 请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tif (input == 0)\t\t&#123;\t\t\tprintf(&quot; 退出计算器 \\n&quot;);\t\t\tbreak;\t\t&#125;\t\telse if (input &gt;= 1 &amp;&amp; input &lt;= 4)\t\t&#123;\t\t\tprintf(&quot; 输入 2 个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = pfArr[input](x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot; 选择错误 \\n&quot;);\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n这样就避免了我们在每个 case 语句里都写上  输入提示、scanf 和不同的函数调用  所导致的代码冗余了\n运行试试吧！\n\n2.3 指向函数指针数组的指针  函数指针数组  是一个数组，数组可以用  数组指针  来存放地址\n\n指向  函数指针数组  的指针：是一个指针\n该指针指向一个数组，数组的每个元素都是一个  函数指针\n\nint Add(int x, int y)&#123;\treturn x + y;&#125;int main()&#123;\tint (*pa)(int, int) = Add;// 函数指针\tint (* pfA[4])(int, int);// 函数指针的数组\tint (* (*ppfA)[4])(int, int) = &amp;pfA;    //ppfA 是一个指针，该指针指向了一个存放函数指针的数组\treturn 0;&#125;\n\n\n3. 相关练习题\n定义一个函数指针，指向的函数有两个 int 形参并且返回一个函数指针，返回的指针指向一个有一个 int 形参且返回 int 的函数？下面哪个是正确的？\n&gt;A. int (*(*F)(int, int))(int)&gt;B. int (*F)(int, int)&gt;C. int (*(*F)(int, int))&gt;D. *(*F)(int, int)(int)\n\n一步步分析题目的要求\n\n该函数指针指向的函数有两个 int 类型，即(int,int)，ABCD 都有，无法排除\n\n仔细看看，D 的类型没有写全，直接排除\n\n返回一个函数指针，该指针指向一个  有一个 int 形参且返回 int 的函数\nB 是一个函数指针，返回类型是 int，错误\nC 的返回值是 int* 类型，错误\n\nA 选项去掉函数指针 F 后，剩下 int (*)(int)， 符合题意\n\n\n\n结语  函数指针的知识点是第一次接触到🧐\n你学废了吗？😂\n\n下一站🚃：回调函数\n\n","categories":["初识C语言"],"tags":["C语言","函数","指针"]},{"title":"【VS】如何下载 VS2019 并初始化 C/C++ 环境","url":"/posts/2731112594/","content":"1. 下载，百度 vs2019，去官网下载即可  一定要认准官网，官网，官网！\n作为初学者的我们，下载第一个免费的 community 社区版本即可！\n\n2. 基本配置\n3.\n4.\n5.\n6.\n7.\n8.\n9.\n到这里，你的 vs2019 就配置完成了！可以愉快地写代码了！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】char 类型如何在内存中存储？","url":"/posts/4229898968/","content":"@[toc]\n引子  上篇博客向大家介绍了 int 类型 在内存中的存储方式【链接】\n本篇博客我们继续往后，看看  整形家族  里的 char 类型 是如何在内存中存储的吧！\n\nchar 类型  字符类型包括以下两种形式\n\nunsigned char 无符号\n\nsigned char 有符号\n\n\n用一个简单的 printf 来看看它们在打印上的区别\n#include&lt;stdio.h&gt;int main()&#123;\tchar a=-1;\tsigned char b=-1;\tunsigned char c=-1;    printf(&quot;a=%d b=%d c=%d\\n&quot;,a,b,c);    \treturn 0;&#125;\n\n打印结果为\na=-1 b=-1 c=255\n\n这里我们可以得出两个结论\n\n1. 在 VS 编译器下，char 默认为 signed char\n2.unsigned char 的处理方式和 signed 不同\n\n无符号数的处理可以看我之前写的这一篇博客👉【链接】\n\n存放和提升  例一：-1先写出 -1 的原反补码\n10000000 00000000 00000000 00000001  -1原码11111111 11111111 11111111 11111110   反码11111111 11111111 11111111 11111111   补码\n\n在内存中存放的时候，a、b、c 存放的都是补码的最后一个字节，即11111111\n而当我们用 %d 打印的时候，会发生  整型提升\n\n整型提升的概念我写过另外一篇博客👉【点我】\n\n这里就是有符号和无符号处理不同的地方了\n因为 a、b 都是有符号的 char，所以编译器会将  最高位视为符号位  进行提升\n所以 a、b 进行整型提升后的结果如下\n11111111 11111111 11111111 11111111// 提升后 a、b 的补码\n\n而 c 是无符号 char 类型，编译器会在  最高位补 0\n00000000 00000000 00000000 11111111// 提升后 c 的补码\n\n此时最高位为 0，编译器将其视为  正数，此时补码就是原码，打印 255\n\n符号位 0 为正，1 为负\n正数的原码、反码、补码相同\n\n例二：-128#include &lt;stdio.h&gt;int main()&#123;\tchar a=-128;\tprintf(&quot;%u\\n&quot;,a);\treturn 0;&#125;\n\n打印的结果并不是 -128\n4294967168\n\n-128 的原反补码\n10000000 00000000 00000000 10000000  -128原码11111111 11111111 11111111 01111111   反码11111111 11111111 11111111 10000000   补码\n\na 中存放的是 1000 0000\n最高位视为符号位，整型提升后\n11111111 11111111 11111111 10000000// 新的补码\n\n但因为这里是 **%u 打印 ，视作 无符号数 **\n此时原反补码一致，直接视作  原码  进行计算\n打印结果即为4294967168\n\n如果我们让 a 等于 128，结果相同\n\nchar 变量中存放数值的范围  先来看看这样一串代码\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar a[1000];\tint i;\tfor (i = 0; i &lt; 1000; i++)\t&#123;\t\ta[i] = -1 - i;\t&#125;\tprintf(&quot;%d&quot;, strlen(a));\treturn 0;&#125;\n\n代码的结果如下：255\n\n在初始化的时候，我们设定了 a[1000]，a 数组里面理应有 1000 个元素\n那 strlen 函数求得的结果为何是 255，而不是 1000 呢？\n\n实际 char 类型中的数据范围分为有符号和无符号两种\n\nsigned char  1byte-8bit，取值范围 -128~127\nunsigned char 1byte-8bit，取值范围 0~255\n\n以二进制表示，如下图所示\n\n因为无符号 char 类型中，八位补码视作原码进行计算\n而有符号 char 类型中，在计算的时会将首位视为符号位\n11111111 // 补码11111110 // 反码，补码减 110000001 // 源码，读出 -1\n\n10000001// 补码10000000// 反码11111111// 首位符号位不读，其他位读出 -127\n\n10000000// 补码  这个二进制位不能 -1，直接视作源码计算 不能忘记这是个负数！10000000// 源码读出 128，加上负号为 -128\n\n下面这幅图可以形象地表示出 char 类型数据范围\n\nchar a[1000];int i;for (i = 0; i &lt; 1000; i++)&#123;\ta[i] = -1 - i;&#125;printf(&quot;%d&quot;, strlen(a));\n\n上面那串代码里面的 for 循环，实则是一直给数组 a 中从 -1 开始赋值到 -128，再从 127 赋值到 1，0……如此循环赋值，直到 i&#x3D;1000 跳出循环。\n而我们的 strlen 函数在计算数组长度的时候，遇到第一个 0 就会停止计算\n这样我们就得出了答案为 255！\n如何查询范围定义？\n我们可以通过头文件 &lt;limits.h&gt; 来查找范围定义\n\n在 VS2019 里面右键该头文件，点击“转到文档”\n\n这里我们就能看到各种数据类型的数据范围\n\n我们还可以看看其他的数据类型\n以  有符号 short为例，它的范围是 -32678 到 32767\n\n\n\n结语  以一串代码示例结束本篇博客吧！\n\n感谢你看到最后！\n点个赞呗，这对我灰常重要！！😘\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【C 语言】指针进阶第四站，数组 / 指针的传参问题","url":"/posts/3023563339/","content":"[TOC]\n朋友们，到站啦！\n指针进阶第四站🚏，传参问题\n\n0. 引例  自定义函数里形参的类型，要和函数调用中传过去的实参类型相对应\n\n在初阶 C 语言的学习里面，我们了解到传参分为  传址  和传值  两种类型\n一起来复习一下吧👉【链接】\n\ntest 函数里的是 int 类型，我们传过去的参数 a 也是 int 类型\nvoid test(int n)&#123;&#125;int main()&#123;    int a=1    test(a);    return 0;&#125;\n\n\n\n好了，现在你已经知道了函数传参的基本概念了😁\n那么就来分析一下  数组传参、指针传参  的代码吧！\n1. 一维数组传参  看看以下函数的代码示例\n你觉得谁是正确的，谁是错误的呢？\ninclude &lt;stdio.h&gt;void test(int arr[])&#123;&#125;void test(int arr[10])&#123;&#125;void test(int *arr)&#123;&#125;void test2(int *arr[20])&#123;&#125;void test2(int **arr)&#123;&#125;int main()&#123;\tint arr[10] = &#123;0&#125;;\tint *arr2[20] = &#123;0&#125;;\ttest(arr);\ttest2(arr2);    return 0;&#125;\n\n\nNO.1 形参使用数组的形式来接收，正确\n\nNO.2 同样是数组的形式，正确\n需要注意的是，数组传参并不会开辟一个新的数组\n所以函数 [] 里的数字是多少并不影响\n\nNO.3 数组名是首元素的地址，用指针接收，正确\n\nNO.4 arr2 是一个指针数组，(int *arr[20])和原数组对应，正确\n\nNO.5 数组名是首元素地址，arr2 的首元素是一个 int* 类型\n可以用二级指针来接收，正确！\n\n\n\n2. 二维数组传参  了解完一维数组了，那就来看看二维数组\n以下的函数传参，哪些是对的，哪些是错的呢？\nvoid test(int arr[3][5])// 一一对应，正确！&#123;&#125;void test(int arr[][])// 省略列，错误！&#123;&#125;void test(int arr[][5])// 可以省略行，正确！&#123;&#125;void test(int *arr)// 二维数组的首元素是第一行 &#123;&#125;// 第一行是 int(*)[5] 类型，错误！void test(int* arr[5])// 指针数组，错误！&#123;&#125;void test(int (*arr)[5])// 数组指针，正确！&#123;&#125;void test(int **arr)//arr 不是一级指针的地址，错误！&#123;&#125;int main()&#123;\tint arr[3][5] = &#123;0&#125;;    test(arr);    return 0;&#125;\n\n根据二维数组传参的代码，复习以下知识点\n\n二维数组的首元素是第一行\n二维数组在定义的时候可以省略行，不能省略列\n\n第一行的类型是 int[5]，应该放进  数组指针  里！\n\n3. 一级指针传参#include &lt;stdio.h&gt;void print(int *p, int sz)// 用 int* 来接受&#123; int i = 0; for(i=0; i&lt;sz; i++) &#123; printf(&quot;%d\\n&quot;, *(p+i)); &#125;&#125;int main()&#123; int arr[10] = &#123;1,2,3,4,5,6,7,8,9&#125;; int *p = arr; int sz = sizeof(arr)/sizeof(arr[0]);  print(p, sz);// 一级指针 p，传给函数 return 0;&#125;\n\n4. 二级指针传参\n什么是二级指针？👉点我\n\n以下是  二级指针传参的基本形式\npp 是 int** 类型，而 &amp;p 是指针变量的地址，要用二级指针来接收\n#include &lt;stdio.h&gt;void test(int** ptr)&#123; \tprintf(&quot;num = %d\\n&quot;, **ptr); &#125;int main()&#123; \tint n = 10; \tint*p = &amp;n; \tint **pp = &amp;p;\ttest(pp);\ttest(&amp;p);\treturn 0;&#125;\n\n再来看如下代码\n&amp;p、pp、arr这三个参数的类型都是  二级指针\ntest 函数里面要用 char** 来接收\nvoid test(char** p)&#123;&#125;int main()&#123;\tchar ch = &#x27;w&#x27;;\tchar* p = &amp;ch;\tchar** pp = &amp;p;\tchar* arr[5];\ttest(&amp;p);\ttest(pp);\ttest(arr);\t\treturn 0;&#125;\n\narr是指针数组的数组名，数组名是数组首元素的地址\n数组的首元素是 char* 类型，所以要用二级指针来接收\n\n5. 如何判断参数类型  如果我们在写代码的时候，不缺定应该用什么类型来接收的时候\n可以写一个测试代码，VS 编译器会报错“类型不一致”\n\n\n结语  传参问题并不算非常难，但我们仍要熟练掌握\n这样才能避免在写自定义函数的时候出现参数类型不同的 bug！\n\n站稳了，马上驶往下一站🚌：函数指针\n\n","categories":["初识C语言"],"tags":["C语言","数组","指针"]},{"title":"【C 语言】指针进阶第一站，字符指针 &typedef 关键字","url":"/posts/3113579721/","content":"[TOC]\n\n紧张刺激的寒假学习开始啦！\n\n简单回顾一下  指针  的概念\n\n内存会划分以字节为单位的空间，每一个字节都有一个编号（地址 &#x2F; 指针）\n\n指针变量  可以存放这个地址 &#x2F; 指针\n\n\n注：我们日常所说的指针，一般是  指针变量\n\n下面让我们坐上指针进阶的🚌，来到第一站！字符指针\n1 字符指针1.1 代码示例 1int main()&#123;\tchar ch = &#x27;w&#x27;;\tchar* p= &amp;ch;\t\tchar* pa = &quot;abcdef&quot;;\treturn 0;&#125;\n\n\n字符变量 ch 里面存放了字符 w\n字符指针 p 里面存放了 ch 的地址\n\n指针变量 pa 里面存放了 abcdef 字符串的地址，我们并没有对这个字符串进行初始化。而是直接把它放进了指针变量 pa 里面。\n和前两行的字符 w 不同，abcdef是存储在内存中的  只读数据区，无法修改，即便通过指针也无法修改。\n为了避免理解出错，我们一般会加上 const 修饰\nconst char* pa = &quot;abcdef&quot;;\n\n\n\nconst 放在 * 的左边\n表示 const 修饰的指针指向的内容，表示指针指向的内容不能通过指针来改变\n但是指针变量本身是可以改变的\n\nconst 放在 * 的右边\n表示 const 修饰的是指针变量本身，指针变量的内容不能被修改\n但是 *pa 指针指向的内容是可以通过指针来修改的\n\n\n\n\n1.2 代码示例 2int main()&#123;\tchar arr1[] = &quot;abcdef&quot;;\tchar arr2[] = &quot;abcdef&quot;;\tconst char* str1 = &quot;abcdef&quot;;\tconst char* str2 = &quot;abcdef&quot;;\tif (arr1 == arr2)\t\tprintf(&quot;arr1==arr2\\n&quot;);\telse\t\tprintf(&quot;arr1!=arr2\\n&quot;);\tif (str1 == str2)\t\tprintf(&quot;str1==str2\\n&quot;);\telse\t\tprintf(&quot;str1!=str2\\n&quot;);\treturn 0;&#125;\n\n它的结果如下：\n\n在例子 1 里面我们提到过，str1 和 str2 这种情况都指向一个  常量字符串\n既然字符串 abcdef 无法被改变，编译器也没有必要创建两个独立的内存空间来存放两个相同的字符串\n所以 str1 和 str2 的地址是完全一样的\n而 arr1 和 arr2 是完全不同的数组，它们的首元素地址不一样，打印的结果是不相等\n\n\n🚍第一站的距离比较短\n在站台上，我们发现了一个无人认领的袋子，里面装着一个关键字\ntypedef\n\n2typedef 关键字 2.1 如何使用 在 MSDN 中，我们可以查找到 typedef 的定义\n\n简单地说，typedef 的作用就是把一个已有的类型名换一个新的名字\ntypedef int* pint;\n\n这句代码的意思是：将 int* 命名为 pint\n\npint 在使用的时候和 int* 完全一致\n我们仍然可以使用 int*\n\n在结构体里面，我们可以用 typedef 来缩短原有结构体定义的语句\n如：将 struct Stu 命名为Stu\ntypedef struct Stu&#123;\tint ID[10];\tchar name[10];\tint age;&#125;Stu;\n\n2.2typedef 和#define 的区别  我们同样可以使用#define 语句，进行这项操作\n#define PINT int*\n\n👆定义语句 PINT 为 int*\n2.2.1 指针连续定义  先来了解一下如何正确连续定义两个指针\nint*pa,*pb;// 正确的连续定义int*pa，pb;// 错误//pa 是 int* 类型，而 pb 是 int 类型\n\n因为这两个的情况非常容易搞混，所以我们不建议连续定义指针\ntypedef int* pint;#define PINT int*int main()&#123;    pint pa,pb;// 可连续定义指针    //pa--&gt;int*    //pb--&gt;int*    PINT pa,pb;// 等同于 int*pa，pb    //pa--&gt;int*    //pb--&gt;int&#125;\n\n\ntypedef 会产生一个新的变量类型\n#define 只是在对应位置进行替换\n\n因为 typedef产生了一个新的类型，pint 为 int*，但与 int* 也有不同\nint pa,pb;//pa,pb 都是 int 类型pint pa,pb;//pa,pb 都是 int* 类型\n\n而我们直接用 int* 进行连续定义指针变量是错误的\nint*pa，pb;// 错误//pa 是 int* 类型，而 pb 是 int 类型\n\n\n你学会了吗？我反正是学废了\n嘟嘟嘟，去下一站！🚌\n","categories":["初识C语言"],"tags":["C语言","指针"]},{"title":"【C 语言】转义字符","url":"/posts/3193284021/","content":"前排提醒，这不算是转义字符的教学  算是个我个人学习的记录\n\n\n我们先来看下面这个代码\n#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;c:\\test\\32\\test.m&quot;);\treturn 0;&#125;\n\n问：printf 中的 c:\\test\\32\\test.m 包含几个字符？\n\n大家可以先思考一下这个问题  我们直接数的话，会得出这里面包括了 17 个字符  如果真的有那么简单也不需要这篇博客了对吧\n这里就要引入转义字符的概念了  常用的转义字符有以下几个\n比较常规的我们可以看表格中的定义\n需要注意的是”\\?”这个是用于连续问号的情况 ？？+（某个符号）  称为 三字母词  如：？？） 显示出来是 ]\\？就让？不被识别为三字母词，而显示问号这个字符  同时 \\\\ 也是让“\\”这个字符能以本身形式出现而不是被识别成转义字符  同时我们要知道的是\n“\\0”这个转义字符是字符串的结束，在我们输入字符串的时候后面会默认跟着一个隐藏的“\\0”  （如图）\n我们使用 strlen 计算字符串 abc 的长度的时候需要在后面 -1同时“\\0”也会有自己对应的下标 3\n\n\n说回我们的 c:\\test\\32\\test.m 通过查表，我们能轻易地发现这里面出现了两个 \\t 转义字符  每个转义字符在数字符长度的时候是记作一个的  除了这两个 \\t, 这里还藏有另外一个转义字符\\32\\32 这个转义字符正是图表中的 \\ddd 格式的转义字符  代表 32 是一个八进制数字\n而 \\32 在正常代码中 是指\n32 作为八进制数字对应的十进制数字，在 ASCII 表上对应的字符。如：八进制 32 是十进制的 26；那么 \\32 就代表十进制数 26 在 ASCII 码表上对应的符号，查表可知 26 是替代符号\n\n\n当然，在这里我们的 \\32 只是一个我们想要打印出来的字符，并没有实际作用\n所以答案就很明朗了。\nint main()&#123;\tprintf(&quot;c:\\test\\32\\test.m&quot;);\treturn 0;&#125;\n在这个代码中，(“c:\\test\\32\\test.m“)一共包含的字符数量是 13\n\n本篇不走心博客到这里也结束了\n\n介绍了部分转义字符的作用\n明确在计算字符数量的时候转义字符应视为同一个字符计数\n\n感谢你看到最后  还是求 dalao无情指正  啊！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】指针进阶终点站，回调函数和 qsort","url":"/posts/175319279/","content":"[TOC]\n\n嘟嘟嘟，指针进阶的公交车到终点站🚏啦！\n这一站我们将学习回调函数、qsort 的使用以及模拟实现\n\n1. 回调函数\n定义：\n回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一 个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该 函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或 条件进行响应。\n\n在上篇博客  函数指针数组  里，提到了一个计算器的代码\n在这里就能用到我们的回调函数，通过一个新的 calc 函数来调用计算函数，同样达到了避免 switch&#x2F;case 语句重复 的目的\n\n不过今天我们的学习重点的内容不在这里，而是一个全新的函数：qsort\n\n2.qsort 函数qsort 函数又称 快速排序函数\n2.1void* 指针void* p = &amp;a;\n\n\nvoid* 是一种无类型的指针，无具体类型的指针\nvoid* 的指针变量可以存放任意类型的地址\nvoid* 的指针不能直接进行解引用操作\nvoid* 的指针不能直接进行加减整数\n\n了解了这个之后，我们再来看看 qsort 函数 的定义\n2.2qsort 函数定义\nvoid qsort (void* base, size_t num, size_t size,            int (*compar)(const void*,const void*));\n\n这些参数分别代表什么意义呢？\n\nvoid*base 是待排序数据的起始地址\n\nsize_t num 是待排序数据的个数\n\nsize_t size 是待排序数据中每个数据的大小\n\nsiez_t 是专为 sizeof 函数的返回值设计的\n它是一个无符号整型\n\n\n\n\n\nint (*compar)(const void*,const void*)是一个函数指针\n该函数的参数为(const void*,const void*)，返回值为 int\n\n在 qsort 的应用中，需要我们自己来  编写这样一个 compar函数，来判断待排序数据谁大谁小\nqsort 库函数对 compar 函数做出了如下规定：\n\np1&gt;p2 时 返回 &gt;0 的数\np1&#x3D;p2 时 返回 0\np1&lt;p2 时 返回 &lt;0 的数\n\n\n\n\n\n为什么比较函数用的 void* 类型的指针?\n\n因为 qsort 函数并不知道你需要排序什么类型的数据，但是作为使用者，我们知道待排序的数据类型以及如何比较待排序的数据，这时候就可以将 void* 指针强制类型转换，变为所需要的指针！\n\n\n2.3 利用 qsort 函数来排序 int&#x2F;char首先我们建立一个待排序的整型数组，依照 qsort 函数的定义，将参数填入该函数\nint main()&#123;\tint arr[10] = &#123; 3,4,7,9,0,1,2,5,8,6 &#125;;\tint sz = sizeof(arr) / sizeof(arr[0]);\tint* ptr = arr;// 此处可以直接用 arr 来代替\tqsort(ptr, sz, sizeof(arr[0]), cmp_int);        return 0;&#125;\n\n接着，我们需要来编写这个 cmp_int 函数，用于判断两个整型的大小\n然后把这个函数名写入 qsort\n// 编写一个函数比较整型int cmp_int(const void* e1, const void* e2)&#123;\treturn *(int*)e1 - *(int*)e2;&#125;\n\n运行，可以看到数据已经按照升序重新排序了！\n\n如果你想降序排序，只需要将比较函数  参数  里的 e1 和 e2 对调位置\n\n\n再来试试排序 char 字符类型吧！\n// 比较字符int cmp_char(const void* e1, const void* e2)&#123;\tchar a = *(char*)e1;\tchar b = *(char*)e2;\tif (a == b)\t\treturn 0;\telse if (a &gt; b)\t\treturn 1;\telse\t\treturn -1;&#125;int main()&#123;\tchar arr1[5] = &#123; &#x27;d&#x27;,&#x27;i&#x27;,&#x27;a&#x27;,&#x27;c&#x27;,&#x27;k&#x27;&#125;;\tint sz1 = sizeof(arr1) / sizeof(arr1[0]);\tint* pc = arr1;\tqsort(pc, sz1, sizeof(arr1[0]), cmp_char);\tfor(int i = 0; i &lt; sz1; i++)\t&#123;\t\tprintf(&quot;%c &quot;, arr1[i]);\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;\n\n\n2.4 用 qsort 排序结构体  定义一个结构体，内容分别代表姓名、年龄、成绩\nstruct Stu&#123;\tchar name[20];\tint age;\tfloat score;&#125;;\n\n该结构体有 char、int、float 三种类型的数据，需要我们写三种对应的排序函数\n// 排序成绩int cmp_stu_by_socre(const void* e1, const void* e2)&#123;\tif (((struct Stu*)e1)-&gt;score &gt; ((struct Stu*)e2)-&gt;score)\t&#123;\t\treturn 1;\t&#125;\telse if (((struct Stu*)e1)-&gt;score &lt; ((struct Stu*)e2)-&gt;score)\t&#123;\t\treturn -1;\t&#125;\telse\t&#123;\t\treturn 0;\t&#125;&#125;// 按年龄排序int cmp_stu_by_age(const void* e1, const void* e2)&#123;\treturn ((struct Stu*)e1)-&gt;age - ((struct Stu*)e2)-&gt;age;&#125;// 按名字排序int cmp_stu_by_name(const void* e1, const void* e2)&#123;   // 用 strcmp 函数比较字符串\treturn strcmp(((struct Stu*)e1)-&gt;name, ((struct Stu*)e2)-&gt;name);&#125;\n\n再写一个函数来打印结构体变量\nvoid print_stu(struct Stu arr[], int sz)&#123;\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tprintf(&quot;%s %d %.2f\\n&quot;, arr[i].name, arr[i].age, arr[i].score);\t&#125;\tprintf(&quot;\\n&quot;);&#125;\n\n最后在主函数里定义结构体类型并写入 qsort 函数\nint main()&#123;\tstruct Stu arr[] = &#123; &#123;&quot;zhangsan&quot;,20,87.5f&#125;,&#123;&quot;lisi&quot;,22,99.0f&#125;,&#123;&quot;wangwu&quot;, 10, 68.5f&#125;,&#123;&quot;niuyeye&quot;,30,95.0f&#125; &#125;;\tint sz = sizeof(arr) / sizeof(arr[0]);\tqsort(arr, sz, sizeof(arr[0]), cmp_stu_by_name);\tprint_stu(arr,sz);\treturn 0;&#125;\n\n可以看到，我们的数据已经按照姓名排序了！\n\n\n3. 模拟实现 qsort 函数  那么，qsort 函数的原理是什么呢？\n之前我们写过用于排序整型的  冒泡排序\n其原理是比较数组内的 a 元素以及 a 的下一位元素，如果 a 大于 a+1 的元素，则将它们互换位置\nvoid bubble_sort(int arr[], int sz)// 形参 arr 本质是指针&#123;\t// 确定趟数\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\t// 一趟冒泡排序\t\tint j = 0;\t\tfor (j = 0; j &lt; sz - 1 - i; j++)\t\t&#123;\t\t\tif (arr[j] &gt; arr[j + 1] )\t\t\t&#123;\t\t\t\t// 交换\t\t\t\tint tmp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = tmp;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n有没有办法将冒泡排序给改写成  通用的排序函数  呢？\n思考：\n\n冒泡排序的时候，使用是 int 类型，int 类型是 4 个字节，无法排序比 4 个字节小的数据类型\n结构体类型的大小不一定是 4 的整数倍，也无法用 int 来排序\nchar 类型是 1 个字节，能否通过 char 类型来更改所有类型？\n\n答案当然是肯定的！\n在之前的指针学习里，我们了解到，尽管 char* 和int*类型的指针都占 4 个字节，但是 char* 类型只能访问 1 个字节的数据。\n我们可以利用 char* 指针的这个特点，对数据进行一个字节一个字节的交换，交换 4 次不就能交换完一个 int 类型了吗？同理也能通过 char* 的多次访问，交换其他类型的数据！\n\n既然是模拟实现 qsort 函数，那函数的参数应该和 qsort 相同\n直接把 qsort 函数改成 my_qsort，开整！\n\n利用冒泡排序的基本框架，我们可以写出以下的代码\n// 模拟实现 qsortvoid my_qsort(void* base, int sz,int width, int(*cmp)(const void* e1, const void* e2))&#123;\tfor (int i = 0; i &lt; sz - 1; i++)\t&#123;\t\tfor (int j = 0; j &lt; sz - i - 1; j++)\t\t&#123;\t\t\tif (cmp((char*)base + j * width , (char*)base + (j + 1) * width)&gt;0)\t\t\t&#123;\t\t\t\tmy_swap((char*)base + j * width, (char*)base + (j+1) * width ,width);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n你可能对 if 里面的语句感到很懵，别急，看图！\n\ncmp 就是一个回调函数，利用函数指针来调用  比较函数\n\n\n再来写一个 swap 函数，实现字节的交换\n// 用 char 类型的指针来一个一个地访问void my_swap(char* e1, char* e2,int sz)&#123;        //sz 是待排序数据的宽度:width\tfor (int k = 0; k &lt; sz; k++)\t&#123;\t\tchar tmp = *e1;\t\t*e1 = *e2;\t\t*e2 = tmp;\t\te1++;\t\te2++;\t&#125;&#125;\n\n测试一下，成功按照成绩来排序！\n\n结语  指针进阶的行程到这里就圆满结束啦！是不是感觉收获满满呢？\n\n学有余力的朋友们可以看看这一类指针笔试题👉点我\n\n到站，下车！🚍\n","categories":["初识C语言"],"tags":["C语言","函数","指针"]},{"title":"【C 语言】指针进阶第三站，数组指针","url":"/posts/2538395833/","content":"[TOC]\n\n上一站🚏我们学习了  指针数组\n今天来到我们的第三站🚌\n寒假也不能落下学习！\n\n今天学到了一个新的 markdown 语法\n我是红色\n&lt;font color=red&gt; 我是红色 &lt;/font&gt;\n\n\n数组指针  整型指针：指向整型的指针\n字符指针：指向字符的指针\n数组指针 ：指向 数组  的指针\n1 基本概念  下面哪个是数组指针呢？\n\n指针数组和数组指针的概念很容易混淆，一定要分清楚哦！\n\nint *p1[10];int (*p2)[10];\n\n\np1 是指针数组，每个元素的类型是int*\np2 是数组指针，每个元素的类型是int(*)[10]\n\nint (*p2)[10];//p2 先和 * 结合，表示 p2 是一个指针变量// 指向一个大小为 10 个整型的数组// 所以 p2 是数组指针\n\n注：[]的优先级高于 *，所以必须加上() 来保证 p2 先和 * 结合\n\n1.1 代码示例int* parr[6];int* (*pp)[6] = &amp;parr;\n\npp 是一个数组指针，类型是int*(*)[6], 存放的是 int* 类型的数组，该数组有 6 个元素\n\n\n一般情况下，去掉变量名，剩下的即为变量类型\n如：int* (*pp)[6]去掉变量名 pp，变量类型为int*(*)[6]\n\nchar arr[5];char (*pa)[5] = &amp;arr;\n\npa 也是一个数组指针，变量类型为char(*)[5]，指向 char 类型的数组，该数组元素个数为 5\n1.2 错误示范  你肯定会有一个疑问，变量类型为 int(*)[5] 的数组指针，能否指向数组元素为 3 或者 6 的数组呢？\n\n程序能够正常编译，但是会报出如下警告\nwarning C4048: “int (*)[5]”和“int (*)[3]”数组的下标不同\n\n在正常编写代码的时候，我们还是得保证  数组指针和原数组的元素个数一致！\n2arr 和 &amp;arr 的区别  在进一步了解数组指针之前，我们需要了解 arr 和 &amp;arr 的区别\n当我们用 %p 打印 arr 和 &amp;arr 时，会发现它们的结果是相同的\n\n但  这能说明 arr 和 &amp;arr 等价了吗？ \n并不能！\n再来看看下面这串代码\n\n\narr+1 跳过 4 个字节，一个元素 int 的大小\n&amp;arr+1 跳过 40 个字节，整个数组的大小\n\n其实 &amp;arr 和 arr 虽然指向的地址值相同，但是  意义  不同！\n\n&amp;arr 表示的是数组的地址，是 int(*)[10] 类型\narr 表示数组首元素的地址，是 int* 类型\n\n数组的地址 +1，跳过整个数组的大小\n所以 &amp;arr+1 和 &amp;arr 的差值为 40\n对应的 int(*p)[5] 和int* p1也有不同\n\np 接收的是 &amp;arr，整个数组的地址\np1 接收 arr，数组首元素的地址\n\n\n3 数组指针的使用 3.1 打印一维数组 下面这串代码是用  整型指针  打印数组元素的情况\n\n除了整型指针外，我们可以利用  数组指针  打印元素\nint main()&#123;\tint arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\tint (*p)[10] = &amp;arr;\tint i = 0;\tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, *((*p) + i));        //*p--&gt;arr\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;\n\n*p 等价于 arr，arr+i 等价于 &amp;arr[i]，对 arr+i 解引用就是 arr[i]\n\n但是这种方式实际上是把简单问题复杂化了：我们本来就可以用 int* 指针来打印数组元素，为何要利用数组指针来多此一举呢？\n所以在一维数组里面，我们一般不会这么写\n\n3.2 打印二维数组  假设我现在需要一个 print 函数来打印二维数组\n在之前，我们一般会想到用这张方式传入二维数组\nvoid print(int a[3][5], int r, int c);\n\n当我们想用数组指针的时候，情况就有些变化了\n\n数组名是数组首元素的地址\n二维数组的首元素是第一行\n二维数组的数组名表示第一行的地址\n\n//main 函数中print(arr,3,5);\n\n这里 prinf 里面的 arr 就需要用数组指针来接收\n该二维数组是 3 行 5 列，每一行都有 5 个元素，是一个 int[5]的数组\n对应的数组指针为 int(*)[5] 类型\nvoid print(int(*p)[5], int r, int c)\n\n这里的 p 指针指向的是二维数组第一行的地址\n\n*p：对 p 直接解引用\n相当于拿道了第一行元素的地址（把第一行看作数组，也就是数组的地址）\n相当于是二维数组  第一行首元素的地址\n\n\n\n对 (p+i) 解引用，就能拿到第 i 行第一个元素的地址\n*(p+i)+j第 i 行第 j 个元素的地址\n*(*(p+i)+j)第 i 行第 j 个元素\n\n\n这一部分和上篇博客  指针数组  的内容相似\n\n最终的函数实现如下\nvoid print(int(*p)[5], int r, int c)&#123;\tint i = 0;\tfor (i = 0; i &lt; r; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; c; j++)\t\t&#123;\t\t\tprintf(&quot;%d &quot;, *(*(p + i) + j));\t\t\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;int main()&#123;\tint arr[3][5] = &#123; &#123;1,2,3,4,5&#125;,&#123;2,3,4,5,6&#125;,&#123;3,4,5,6,7&#125; &#125;;\tprint(arr,3,5);\treturn 0;&#125;\n\n\n3.3 关于二维数组传参void fun2(int **p)&#123;    return;&#125;void test03()&#123;    int a[4]=&#123;1,2,3,4&#125;;    int b[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;    int *q[3]=&#123;b[0],b[1],b[2]&#125;;    //fun2(a);    //fun2(&amp;a);    //fun2(b);    fun2(q);&#125;\n在 2022 的暑假作业 day02 中有这么一道题目，问的是上面 4 种调用方式谁位合法。经过测试，只有最后一个是不报错的。\n这里涉及到了一个我之前从来没注意过的点：二维数组不能直接用二级指针接受。在上面的 2.2 中其实有提到，二维数组的接受需要用对应的数组指针来接受。比如  int b[3][4] 对应的数组指针就是 int (*p)[4] 类型的。不能直接简单粗暴地用二级指针 int** 来接收二维数组\nvoid fun3(int (*p)[4])&#123;    return;&#125;int main()&#123;\tint b[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;\tfunc3(b);// 这样才是正确的&#125;\n\n4 练习：判断  这一站最重要的就是区别  指针数组和数组指针\n4.1 int arr[5]int arr[5];\n\narr 是一个整型数组，有 5 个元素，每个元素是 int 类型的\n4.2 int*parr[10]int*parr1[10];\n\nparr1 是一个数组，数组有 10 个 int* 类型的元素\n所以 parr1 是指针数组\n\n4.3 int (*parr2)[10]int(*parr2)[10];\n\nparr2 和 * 结合，表示 parr2 是一个指针\n去掉 parr2 即为它的变量类型int(*)[10]\n所以 parr2 是一个  数组指针\n\n4.4 int(*parr3[10])[5]int(*parr3[10])[5];\n\n[]的优先级高于 *\nparr3 先和 [] 结合，说明 parr3 是一个数组\n该数组有 10 个元素，每一个元素都是一个数组指针，类型是int(*)[5]\n该数组指针指向的数组有 5 个 int 类型的元素\n\n结语  第三站数组指针到这里就结束啦！\n下一站🚌是：数组传参  和指针传参\n敬请期待哦~\n\n如果这篇博客对你有帮助，点个赞再走吧😘\n\n","categories":["初识C语言"],"tags":["C语言","数组","指针"]},{"title":"【C 语言】常用的字符串函数和内存函数","url":"/posts/2065508655/","content":"[TOC]\n今天我们来学习一些新的字符串函数和内存函数，了解它们背后运行的原理，并完成部分函数的  自我实现😘\n1. 字符串函数 1.1 strlen 这个函数我们已经很熟悉了，它的作用是计算字符串的大小，以 \\0 作为结尾\n模拟实现如下：\n//1.strlen 模拟实现int my_strlen(char* p)&#123;\tassert(p);\tint count = 0;\twhile (*p)\t&#123;\t\tcount++;\t\tp++;\t&#125;\treturn count;&#125;int main()&#123;\tchar arr[] = &#123; &quot;abcdef&quot; &#125;;\tint sz = my_strlen(arr);\tprintf(&quot;sz=%d\\n&quot;, sz);\treturn 0;&#125;\n\nassert：断言，库函数，用于判断指针是否为空，若为空会报错\n\n1.2 strcpy该函数用于拷贝字符串，将 arr2 里的内容拷贝到 arr1 里\nchar* strcpy(char * destination, const char * source );// 日常使用strcpy(arr1,arr2);\n\n它有以下几个特点\n\nCopies the C string pointed by source into the array pointed by destination, including the  terminating null character (and stopping at that point).\n\n\n源字符串必须以 ‘\\0’ 结束\n会将源字符串中的 ‘\\0’ 拷贝到目标空间。\n目标空间必须足够大，以确保能存放源字符串。\n目标空间必须可修改\n\n如果源字符串里没有 \\0，该函数就无法正确进行拷贝\n\nstrcpy 拷贝的时候是  复制  而不是剪贴，源空间里的内容不会消失\n\n以下模拟实现\n需要注意的就是 strcpy 会将源字符串的’\\0’一并拷贝，所以在编写判断条件的时候就要考虑到这个情况\n//2.strcpy 模拟实现，拷贝char* my_strcpy(char* a2, const char* a1)&#123;\tchar* dest = a2;\tassert(a1 &amp;&amp; a2);\tdo\t&#123;\t\t*a2++ = *a1;\t&#125; while (*a1++);\treturn dest;&#125;int main()&#123;\tchar arr1[] = &#123; &quot;abcdef&quot; &#125;;\tchar arr2[15]=&quot;xxxxxxxxx&quot;;\tmy_strcpy(arr2, arr1);\tputs(arr2);\treturn 0;&#125;\n\n\n1.3 strcatstrcat 函数用于追加字符串，简单来说就是把两个字符串接在一起\n其函数返回值为 dest\nchar * strcat (char * destination, const char * source );// 以下是使用char arr1[10] = &quot;hello&quot;;char arr2[] = &quot;bit&quot;;strcat(arr1,arr2);puts(arr1);// 结果为 &quot;hellobit&quot;\n\n\n源字符串必须以 ‘\\0’ 结束。\n目标空间必须有足够的大，能容纳下源字符串的内容。\n目标空间必须可修改。\n\n注意，使用 strcat 函数的时候不能自己追加自己，程序会死循环\n\n以下是模拟实现\n\n先让 dest 找到目的地字符串里的\\0\n然后进行追加，注意源字符串里的 \\0 同样会被追加过去\n\n//3,strcat 函数char* my_strcat(char* dest, const char* sour)&#123;\tassert(dest &amp;&amp; sour);\tchar* ptr = dest;\twhile (*dest)\t&#123;\t\tdest++;\t&#125;\tdo\t&#123;\t\t*dest++ = *sour;\t&#125; while (*sour++);\treturn ptr;&#125;int main()&#123;\tchar arr1[10] = &quot;hello&quot;;\tchar arr2[] = &quot;bit&quot;;\tmy_strcat(arr1, arr2);\tputs(arr1);\treturn 0;&#125;\n\n\n1.4 strcmpstrcmp 我们也是经常使用的，用于比较字符串\nint strcmp (const char * str1, const char * str2 );\n\n该函数在比较字符串的时候，实际上是一个字符一个字符地比较的\n\n\n第一个字符串大于第二个字符串，则返回大于 0 的数字\n第一个字符串等于第二个字符串，则返回 0\n第一个字符串小于第二个字符串，则返回小于 0 的数字\n\n模拟实现\n在 VS 编译器下，如果字符串 s1 大于 s2，返回的是 1。若小于返回的是 -1。但 C 语言只要求大于的时候返回大于 0 的数字，小于的时候返回小于 0 的数字，所以我们可以直接用字符相减得出返回值\n//4.strcmp 函数int my_strcmp(const char* str1, const char* str2)&#123;\tassert(str1 &amp;&amp; str2);\twhile(*str1 == *str2)\t&#123;\t\tif (*str1 == &#x27;\\0&#x27;)\t\t&#123;\t\t\treturn 0;\t\t&#125;\t\tstr1++;\t\tstr2++;\t&#125;\treturn *str1 - *str2;&#125;int main()&#123;\tchar arr1[] = &#123; &quot;abcdef&quot; &#125;;\tchar arr2[] = &#123; &quot;abcd&quot; &#125;;\t\tprintf(&quot;%d\\n&quot;,my_strcmp(arr2, arr1));\treturn 0;&#125;\n\n\n1.5 strncpy&#x2F;cat&#x2F;cmp以上 4 个库函数，都对操作数没有要求。\n而 strncpy、strncat、strncmp 这三个库函数，对操作数有要求\n\nstrncmp，最后一个参数 4，代表只对比前 4 个字符的大小\n\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;\tchar arr1[] = &quot;abcwef&quot;;\tchar arr2[] = &quot;abcqqqqqq&quot;;\tint ret = strncmp(arr1, arr2, 4);\tprintf(&quot;%d\\n&quot;, ret);    return 0;&#125;\n\n\n\nstrncat，最后一个参数 3，代表只追加  前 3 个字符  到目的地\nstrncpy，最后一个参数 5，代表只拷贝  前 5 个字符  到目的到底\n\n\n这三个函数的用法非常简单，这里不多赘述！\n\n1.6 strstrconst char * strstr (const char * str1, const char * str2 );      char * strstr (char * str1, const char * str2 );\n\n这个函数就是第一次见了，它的作用是在字符串 s1 里面查找是否有字符串 s2\n\n如果有，返回字符串 s2 在字符串 s1 里的起始地址\n如果没有，返回 NULL\n\n\n模拟实现\nstr 函数的模拟实现相对来说比较复杂\n最重要的就是遇到  多个字符相同而最后不同  的情况\n\n需要用另外一个指针 C 来遍历字符串，找寻 C 和 ptr2 所指元素相等的第一个字符\n然后用 ptr1 来和 ptr2 比较，C 保持不变\n如果匹配成功，返回 C 指针\n如果匹配失败，C++ 后赋值给 ptr1，继续进行查找\n\n\n//5.strstr 判断 str1 里面有没有 str2// 如果有，返回 str1 里 str2 的起始地址// 如果 str1 不包含 str2，返回 nullchar* my_strstr(const char* str1, const char* str2)&#123;\tconst char* s1 = str1;\tconst char* s2 = str2;\tconst char* cur = str1;\tassert(str1 &amp;&amp; str2);\tif (*str2 == &#x27;\\0&#x27;)\t&#123;\t\treturn (char*)str1;\t&#125;\twhile (*cur)\t&#123;\t\ts1 = cur;\t\ts2 = str2;\t\twhile (*s1 &amp;&amp; *s2 &amp;&amp; *s1 == *s2)\t\t&#123;\t\t\ts1++;\t\t\ts2++;\t\t&#125;\t\tif (*s2 == &#x27;\\0&#x27;)\t\t\treturn (char*)cur;\t\tcur++;\t&#125;\treturn NULL;\t\t&#125;int main()&#123;\tchar arr1[15] = &#123; &quot;helloworld&quot; &#125;;\tchar arr2[] = &#123; &quot;owo&quot; &#125;;\tchar* p=strstr(arr1, arr2);\tif (p == NULL)\t&#123;\t\tprintf(&quot; 找不到 \\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;%s\\n&quot;, p);\t&#125;\treturn 0;&#125;\n\n\n1.7 strtok该函数用于查找一个字符串中的分隔符\nchar * strtok (char * str, const char * sep );\n\n\nsep 参数是个字符串，定义了用作分隔符的  字符集合(可以包含多个分隔符)\n\n第一个参数指定一个字符串，它包含了 0 个或者多个由 sep 字符串中一个或者多个分隔符分割的标记\n\nstrtok 函数找到 str 中的下一个标记，并将其用 \\0 结尾，返回一个指向这个标记的指针\n\n\n\n注：strtok 函数会改变被操作的字符串（把分隔符改为 \\0），所以在使用 strtok 函数切分的字符串一般都是临时拷贝的内容，并且可修改\n\n\nstrtok 函数的第一个参数不为 NULL，函数将找到 str 中第一个标记，strtok 函数将保存它在字符串中的位置\nstrtok 函数的第一个参数为 NULL，函数将在同一个字符串中被保存的位置开始，查找下一个标记\n如果字符串中不存在更多的标记，则返回 NULL 指针\n\n如下如所示，在后续调用的时候，我们可以往 strtok 函数里传入 buf，也可以直接传入 NULL，因为传入 NULL 的时候该函数会在上一次操作的字符串里继续查找分隔符\n\n这样写很多行太麻烦，我们可以尝试用 for 循环的方式来简化代码\n\nfor 循环的第一个表达式只会执行一次，让 str&#x3D;strtok 第一次查找的返回值\n如果该返回值为空（没找到更多的分隔符），停止循环\n如果该返回值不为空，就让str=strtok(NULL, p)，继续查找并打印下一部分\n\nint main()&#123;\tconst char* p = &quot;@.&quot;;\tchar arr[] = &quot;zpengwei@yeah.net&quot;;\tchar buf[50] = &#123; 0 &#125;;//&quot;zpengwei@yeah.net&quot;\tstrcpy(buf, arr);\tchar* str = NULL;\tfor (str = strtok(buf, p); str != NULL; str=strtok(NULL, p))\t&#123;\t\tprintf(&quot;%s\\n&quot;, str);\t&#125;    return 0;&#125;\n\n\n\n1.8 strerrorchar * strerror (int errnum );\n\n\nC 语言中规定了一部分错误码，这些错误码有他们对应的错误信息\n\n这个函数的作用比较特殊：将错误代码翻译成提示信息\n\nerrno 是 C 语言提供的一个全局变量，可以直接使用，放在 errno.h 文件中\n当库函数使用发生错误时，会把 errno 这个全局的错误变量设置为本次执行库函数产生的错误码\n这时候可以用 strerror 函数将 errno 错误码翻译成错误信息\n#include &lt;errno.h&gt;// 需要调用 errno.h 头文件printf(&quot;%s\\n&quot;, strerror(errno));\n\n\n1.9 strcasecmp这个函数的作用是比较的时候忽略大小写，注意头文件是strings.h\n#include &lt;strings.h&gt;int strcasecmp(const char *s1, const char *s2);int strncasecmp(const char *s1, const char *s2, size_t n);\n\n这里还有一个 strncasecmp，作用相同，但是比较的是前 n 个字符\nThe strncasecmp() function is similar, except it compares the only first n bytes of s1.\n\n可以通过代码测试看出 strcmp 和 strcasecmp 两个函数的区别\nvoid test_cmp()&#123;    char str1[] = &quot;abc&quot;;    char str2[] = &quot;ABC&quot;;    printf(&quot;strcmp:     %d\\n&quot;, strcmp(str1, str2));    printf(&quot;strcasecmp: %d\\n&quot;, strcasecmp(str1, str2));&#125;\n\n运行\nstrcmp:     32strcasecmp: 0\n\n因为小写英文字母的 ascii 码大于大写英文字母，所以 strcmp 的结果大于 0，而 strcasecmp 忽略了大小写，返回 0 代表二者相同\n\n2. 内存函数 2.1 memcpy 这个函数的作用也是拷贝内容，和 strcpy 不同，memcpy 可以拷贝任意类型\nvoid * memcpy (void * destination, const void * source, size_t num );\n\n\n函数 memcpy 从 source 的位置开始向后复制 num 个字节的数据到 destination 的内存位置\n该函数在遇到 ‘\\0’ 的时候并不会停下来\n如果 source 和 destination 有任何的重叠，复制的结果都是未定义的\n\n使用方法如下\n\n模拟实现\n在之前的 qsort 快速排序函数 的模拟实现里面，我们接触到了 void* 指针，以及用 char* 指针来进行单个字节访问的模拟方法\n在这里我们使用 void* 指针进行数据的拷贝\n\n要注意的是我们不能直接对 void* 指针进行 ++，而要将其强制类型转换成 char* 指针后 +1\n\n////1.memcpy 模拟实现void* my_memcpy(void* dest, const void* sour, int num)&#123;\tassert(dest &amp;&amp; sour);\tvoid* ptr = dest;\twhile (num--)\t&#123;\t\t*(char*)dest = *(char*)sour;\t\tdest = (char*)dest + 1;\t\tsour = (char*)sour + 1;\t&#125;\treturn ptr;&#125;int main()&#123;\tint arr1[10] = &#123; 1,2,4,5,9,7,8 &#125;;\tint arr2[10] = &#123; 0 &#125;;\tmy_memcpy(arr2, arr1, 5 * sizeof(int));\tfor (int i = 0; i &lt; 5; i++)\t&#123;\t\tprintf(&quot;%d &quot;, arr2[i]);\t&#125;\treturn 0;&#125;\n\n\n2.2 memmovevoid * memmove (void * destination, const void * source, size_t num );\n\n这个函数和 memcpy 的功能基本一致，只有一点不同\n\nmemmove 在拷贝的时候，源地址和目的地可以重叠\n\n如图所示，我们可以将 arr1 数组的一部分拷贝回该数组里面\n\n但如果你测试一下，就会发现 vs 编译器下 memcpy 也是能够拷贝内存重叠的数据的\n\nC 语言并没有对 memcpy 函数做出如下要求，部分编译器的 memcpy 可能就不支持这样操作\n为了避免出错，我们在拷贝内存重叠数据的时候最好使用 memmove 函数\n\n\n模拟实现\n在编写该函数的时候，我们需要注意拷贝的顺序\n如果重叠部分还是  从前向后  拷贝的时候，就会出现后面的内容被前面拷贝来的数据篡改，结果不符合要求的情况\n\n\n如果我们的目的地在源地址的  后面 ，就应该 从后向前  拷贝，避免数据被改写\n\n如果我们的目的地在源地址的  前面 ，就应该 从前向后  拷贝\n\n这里的前 &#x2F; 后都是指有重叠的情况，如果没有重叠，从前往后 &#x2F; 从后往前都不影响\n\n\n\n最终的函数模拟如下\nvoid* my_memmove(void* dest, const void* sour, int num)&#123;\tassert(dest &amp;&amp; sour);\tvoid* ptr = dest;\tif (dest &lt; sour)\t&#123;\t\twhile (num--)\t\t&#123;\t\t\t*(char*)dest = *(char*)sour;\t\t\tdest = (char*)dest + 1;\t\t\tsour = (char*)sour + 1;\t\t&#125;\t&#125;\telse\t&#123;\t\twhile (num--)\t\t&#123;\t\t\t*((char*)dest+num) = *((char*)sour+num);\t\t&#125;\t&#125;\treturn ptr;&#125;int main()&#123;\tint arr1[10] = &#123; 1,2,4,5,9,7,8,3,0,6&#125;;\t//1 2 4 1 2 4 5 9 0 6\tmy_memmove(&amp;arr1[3], arr1, 5 * sizeof(int));\t\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, arr1[i]);\t&#125;\treturn 0;&#125;\n\n\n2.3 memcmpint memcmp (const void * ptr1,            const void * ptr2,  \t\t\tsize_t num );\n\n这个函数的作用是：以字节为单位进行比较\n\n模拟实现\nint my_memcmp(const void* ptr1, const void* ptr2, int num)&#123;\tassert(ptr1 &amp;&amp; ptr2);\twhile (num--)\t&#123;\t\tif (*(char*)ptr1 == *(char*)ptr2)\t\t&#123;\t\t\tptr1 = (char*)ptr1 + 1;\t\t\tptr2 = (char*)ptr2 + 1;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn *(char*)ptr1 - *(char*)ptr2;\t\t&#125;\t&#125;\treturn 0;&#125;int main()&#123;\tint arr1[5] = &#123; 1,3,5,6,8 &#125;;\tint arr2[5] = &#123; 2,4,7,9,0 &#125;;\tint arr3[5] = &#123; 1,3,4,7,9 &#125;;\tint ret1 = my_memcmp(arr1, arr3, 9);\tint ret2 = memcmp(arr1, arr3, 9);\tprintf(&quot;my_memcmp:%d\\n&quot;, ret1);\tprintf(&quot;memcmp:%d\\n&quot;, ret2);\treturn 0;&#125;\n\n运行结果\n\n\n2.4 memsetvoid * memset (void * ptr, int value, size_t num );\n\n这个函数的作用是把内存中 ptr 所在位置的 num 个字节的内容改为value\n\n示例代码如下图所示\n\n2.5 bzero这个函数的作用是将一个地址的前 n 个字节设置为 0，可以理解为 memset 的简化版本。其需要使用的头文件是strings.h，范围广于string.h\n#include &lt;strings.h&gt;void bzero(void *s, size_t n);\n\n使用方法也很简单\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;    char str[]=&quot;1234567890&quot;;    int sz = strlen(str);    printf(&quot;%s\\n&quot;,str);    bzero(str,3);// 将前三个字节写为 0    for(int i=0;i&lt;sz;i++)    &#123;        printf(&quot;%c&quot;,str[i]);    &#125;    printf(&quot;\\n&quot;);    return 0;&#125;\n\n可以看到，代码运行后，前三个字符没有被打印出来。这是因为 0 在 ASCII 码中是\\0，对于字符来说什么都不会打印\n\n\n3. 字符串打印  下面的函数都是对 printf 的变种，用法和 printf 是一样的，只不过打印的目标位置不同\n3.1 sprintfint sprintf(char *str, const char *format, ...)\n\n和 printf 的使用一样，只不过多了第一个参数，将 printf 的内容打印到一个字符数组 str 中\n3.2 snprintfint snprintf (char * str, size_t size, const char * format, ... );\n\n将 printf 的目标设置为 str 字符数组，并限定 size，超过 size 的部分会被截断（也就是最多只能打印 size 字节到 str 里面）\n3.3 fprintfint fprintf(FILE *stream, const char *format, ...)\n\n这个函数也是多了一个 FILE 文件指针，将 printf 的内容输出到文件指针中\n结语🍑今天的内容有点小多，这些函数以后我们就会经常接触啦~\n熟能生巧！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】程序运行过程：预处理 / 编译 / 汇编 / 链接","url":"/posts/4253775162/","content":"[TOC]\n哈喽啊，盆友们。一起来看看 C 语言 中编译预处理的内容吧！😜\n1. 程序运行的几个阶段  众所不周知，C 语言的程序运行分为几个阶段。\n咱们可以看看下面这个图，简单了解一二👇\n\n细分开来，编译  还分为 3 个小阶段：预编译（预处理）、编译、汇编\n\n这三个阶段又分别做了什么事情呢？这就需要我们用 linux 下的 gcc 编译器来验证了\n1.1 预编译  现在我们编写了一个这样的代码\n\n\n在运行窗口中输入以下指令，进行预编译操作，得到 test.i 文件\ngcc -E test.c -o test.i\n\n\n打开该文件，滑倒最底部，查看它与源代码的不同\n\n可以发现以下几点：\n\n头文件消失：实际上被展开了\n注释被删除\ndefine 定义的符号被替换\n\n这就是预编译阶段做的 3 件事，实际上都是一些  文本操作，并没有运行该代码\n1.2 编译  输入以下指令，生成 test.s 文件\ngcc -S test.i -o test.s\n\n\n打开该文件，发现我们好像看不太懂它里面写了些什么\n\n实际上，mov、sub都是汇编语言，这一步就是把 C 语言代码转变成了汇编代码。 进行了以下几步操作：\n\n语法分析\n词法分析\n语义分析\n符号汇总\n\n\n\n这一部分内容可以阅读《程序员的自我修养》这本书，记录一下\n\n1.3 汇编gcc -c test.s -o test.o\n\n\n这个指令会生成一个 test.o 目标文件\n\nLinux：目标文件后缀为.o\nWindows：目标文件后缀为.obj\n\n\n.o 目标文件和可执行成句的文件格式elf\nreadelf 工具可以解析 elf 格式的文件\n\n用文本编辑器打开这个文件，可以看到里面的东西都是乱码\n\n实际上这个文件里面存放的是二进制内容。\n汇编操作就是将汇编代码转换成  二进制指令\n其中有非常重要的一部：形成  符号表\n1.4 符号表和链接  这个代码中其实包含了两个源文件：test.c 、Add.c\n\n里面出现了两个符号，main 和 Add\n编译器会先对每个源文件创立一个符号表，为它们添加一个类似地址的参数。在链接阶段的时候，相同符号的地址参数会被设置为一样的\n\n这里编译会查看 Add 函数的定义在哪里\n如 main 函数中只是 extern，并没有 Add 的具体实现，最后链接之时，Add 符号的地址会被设置为 Add.c 中该符号的地址\n\n这个操作又叫：符号表的合并和重定位\n链接阶段还会执行另外一个操作：合并段表\ngcc test.o add.o -o test// 生成可执行程序 test\n\n\n使用 ./TEST 操作执行该文件，可以看到程序成功输出了 Add 后的答案\n\n\n2. 运行环境  程序执行的过程中：\n\n程序先载入内存。在操作系统中，这个操作由系统完成；在独立环境中，程序的载入必须手动完成，也可以是通过可执行代码置入只读内存来完成\n程序执行开始。调用 main 函数\n开始执行代码。这时将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时使用静态内存，存储于静态内存中的变量在程序的整个执行过程中保留它们的值\n终止程序。正常终止 main 函数，也可能是意外终止\n\n\n结语  本篇博客中，我们认识了解了程序运行的几个阶段。这里面还有很多更深层次的问题待我去探究。\n\n下篇博客：预处理详解\n\n点个赞再走呗，谢谢！\n","categories":["初识C语言"],"tags":["C语言","编译"]},{"title":"【C 语言】动态内存管理（详解 malloc/calloc/realloc）","url":"/posts/1456051952/","content":"[TOC]\n直入主题，动态内存管理！🕵️‍♂️\n1. 为什么会有动态内存分配？我们一般使用以下两种方式开辟内存\nint a = 20;// 在栈空间上开辟四个字节char arr[10] = &#123;0&#125;;// 在栈空间上开辟 10 个字节的连续空间\n\n但是上述的开辟空间的方式有两个特点： \n\n空间开辟大小是固定的。 \n数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。\n\n但是对于空间的需求，不仅仅是上述的情况。有些时候，我们并不能提前知道需要的空间大小，而部分编译器并不支持变长数组。这时候以数组的方式开辟连续空间的方法就有点不适用了。\n其次，全局变量 &#x2F; 局部变量是存放在栈区里面的。如果存放的变量太多，就会出现栈溢出的错误\n\n这时候就轮到动态内存上场了！\n\n2. 动态内存函数2.1 malloc#include &lt;stdlib.h&gt;//malloc 的头文件void* malloc (size_t size);\n\n这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。\n\n如果开辟成功，则返回一个指向开辟好空间的指针。 \n如果开辟失败，则返回一个 NULL 指针，因此 malloc 的返回值一定要做检查。 \n返回值的类型是 void* ，所以 malloc 函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。 \n如果参数 size 为 0，malloc 的行为是标准是未定义的，取决于编译器。\n\n#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t// 开辟 10 个整型的空间\t//int arr[10];\tint* p = (int*)malloc(40);\tif (NULL == p)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));        // 这个函数在之前介绍过，用于转义错误代码\t\treturn 0;\t&#125;\t// 使用\tint  i = 0;\tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\t// 释放\tfree(p);\tp = NULL;\t\treturn 0;&#125;\n\n2.2 free上述代码里面出现了另外一个重要的函数，free\nfree 函数用来释放动态开辟的内存，头文件是&lt;stdlib.h&gt;\n\n如果参数 ptr 指向的空间不是动态开辟的，那 free 函数的行为是未定义的\n如果参数 ptr 是 NULL 指针，则函数什么事都不做。\n\nfree 函数不能用来释放栈区里面的空间，栈区的空间由编译器进行  自动创建和自动释放\n重点！\n被 free 之后的指针 p 指向的空间已经不属于我们的应用程序了。最好在 free 之后立马把指针置为 NULL 避免访问野指针。\nfree(p);p = NULL;\n\n\n2.3 callocvoid* calloc (size_t num, size_t size);\n\ncalloc 函数的功能和 malloc 基本一致，但是有一点不同：\n\ncalloc 函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为 0。\n与 malloc 的区别只在于 calloc 会在返回地址之前把  申请的空间的每个字节初始化为全 0\n\n#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t// 开辟 10 个整型的空间\t//int arr[10];\tint* p = (int*)calloc(10, sizeof(int));\tif (NULL == p)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t// 使用\tint  i = 0;             \tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\t// 释放\tfree(p);\tp = NULL;\treturn 0;&#125;\n\n添加断点并调试，可以看到 calloc 函数把这一块内存都初始化为 0 了\n\n如果这块空间需要初始化，使用 calloc 函数比 malloc 更好\n\n\n\n2.4 realloc\n该函数用于更改已经创建好的动态内存空间（可改大可改小）\n\nvoid* realloc (void* ptr, size_t size);\n\n\nptr 是要调整的内存地址 \nsize 调整之后新大小\n返回值为调整之后的内存起始地址\n这个函数调整原内存空间大小的基础上，还会将原来内存中的数据  移动到新的空间\n如果开辟失败，返回空指针 NULL\n\n在进行扩容操作的时候，会出现两种情况：\n\n原动态内存空间之后有足够空间进行扩容\n原动态内存空间之后无足够空间\n\n如果是第一种情况，realloc 函数会在这之后增添空间，分配给 ptr 指针。原来空间的数据不发生变化。\n如果是第二种情况，realloc 会找一块新的空间，开辟好后返回给 ptr 指针，并把原空间里的数据移动到新空间的对应位置。\n\n情况 2 的时候，开辟完新空间之后，会把原来的空间给 free 掉(只有开辟成功才会释放原来的空间)\n\n\n#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t// 开辟 10 个整型的空间\t//int arr[10];\tint* p = (int*)calloc(10, sizeof(int));\tif (NULL == p)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t// 使用\tint  i = 0;\tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\t// 需要增容 - 80\tint*ptr = (int*)realloc(p, 80);\tif (NULL != ptr)\t&#123;\t\tp = ptr;\t\tptr = NULL;\t&#125;\t// 继续使用了\t\t// 释放\tfree(p);\tp = NULL;\treturn 0;&#125;\n\n几点注意：\n\nrealloc(p, 80) 80 指的是开辟之后新的空间大小为 80，而不是增加 80 的空间\nrealloc 函数可能开辟失败，这时候如果将开辟失败的返回值 NULL 赋值给了原有指针 p，就很危险。\n采用中间指针变量 ptr，先判断 realloc 函数是否开辟成功，若成功，则赋值给 p 指针。\n赋值给 p 之后 ptr 指针就没用了，置为空指针。\n\n\n最后我们不需要对 ptr 进行 free，因为 ptr 的指向和 p 是一样的\nfree(p)的时候，ptr 所指向的空间也被 free 掉了\n\n\nrealloc 缩小空间的时候，会把原来空间后面的内容都剔除\n\n\n3. 常见错误3.1 对 NULL 指针的解引用void test()&#123;  int *p = (int *)malloc(INT_MAX/4);  *p = 20;// 如果 p 的值是 NULL，就会有问题  free(p);&#125;\n\nINT_MAX是 int 类型的最大值，可以在头文件 limits.h 里面查询并使用\n3.2 对动态内存空间的越界访问  和数组一样，动态内存空间也是不能越界访问的！\nvoid test()&#123; int i = 0; int *p = (int *)malloc(10*sizeof(int)); if(NULL == p) &#123; exit(EXIT_FAILURE); &#125; for(i=0; i&lt;=10; i++)// 应该是 i&lt;10 &#123; *(p+i) = i;// 当 i 是 10 的时候越界访问 &#125; free(p);&#125;\n\n3.3 对非动态内存空间进行 freevoid test()&#123; int a = 10; int *p = &amp;a; free(p);//err&#125;\n\n3.4 使用 free 释放动态内存空间的一部分void test()&#123; int *p = (int *)malloc(100); p++; free(p);//p 不再指向动态内存的起始位置&#125;\n\n\n需要用一个指针来记住起始地址，用另外一个指针来进行赋值等操作\n\n3.5 对一个空间进行重复释放void test()&#123; int *p = (int *)malloc(100); free(p); free(p);// 重复释放&#125;\n\n在 free 之后立马把 p 置为空指针，就能避免这个问题\n\nfree 函数接收空指针，不做任何操作\n\n3.6 内存泄漏  如果忘记释放动态内存开辟的空间，就会导致  内存泄漏\nvoid test()&#123; \tint *p = (int*)malloc(100); \tif(NULL != p) \t&#123; \t\t*p = 20; \t&#125;    // 没有释放 p 的空间&#125;int main()&#123; \ttest();\twhile(1);&#125;\n\n一般情况下，谁使用就谁释放。函数里使用就在函数里释放，除非需要传回主函数进行操作。\n\n如果没有传回主函数，也没在函数里进行释放，该指针变量已经被销毁了，无法进行释放操作！\n\n如果主函数里程序没有结束，就造成了内存浪费\n\n4.C&#x2F;C++ 程序中内存区域划分\n栈区（stack）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。\n\n堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收 。分配方式类似于链表。\n\n数据段（静态区）（static）存放全局变量、静态数据。程序结束后由系统释放。\n\n代码段：存放函数体（类成员函数和全局函数）的二进制代码。\n\n\n\n有了这幅图，我们就可以更好的理解在《初识 C 语言》中讲的 static 关键字修饰局部变量的例子了。实际上普通的局部变量是在栈区分配空间的，栈区的特点是在上面创建的变量出了作用域就销毁。但是被 static 修饰的变量存放在数据段（静态区），数据段的特点是在上面创建的变量，直到程序结束才销毁，所以生命周期变长\n\n\n\n结语  动态内存其实就是数组的高级形式，它能让我们更方便的管理开辟的连续的空间。\n你学废了吗？🤤\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】函数调用的参数压栈（详解）","url":"/posts/3810457843/","content":"[TOC]\n前言  在早期的学习中，我们已经了解到当函数传值调用参数的时候，用的是形参。\n形参是实参的一份临时拷贝，对形参的改变不会影响实参里的值。\n\n传值调用和传址调用👉点我\n\n今天让我们以  汇编语言  来了解  函数调用的参数压栈  这一知识点\n所用编译器：VS2019\n\n不同编译器的实现可能略有不同，以实际为准\n\n\n1. 什么是栈区？栈，是一种数据结构。\n在学习 C 语言的过程中，我们一般只关注内存中的 3 个区域，分别是栈区、堆区和静态区。\n其中  堆区主要用于动态内存管理，在之前的博客中已经和大家介绍过。\n\n详解动态内存管理👉点我\n\n\n而栈区就是编译器给函数运行分配的空间了。\n和堆区空间需要手动分配不同，这一部分空间是编译器自动管理的，函数的栈帧会自动创建，自动销毁。\n1.1 栈区小知识点\n栈区的使用是从高地址到低地址\n栈区的使用遵循先进后出，后进先出\n栈区的放置是从高地址往低地址放置：push压栈\n删除是从低往高删除：pop出栈\n\n\n2. 知识点// 本次使用的代码#include &lt;stdio.h&gt;int Add(int x, int y)&#123;\tint z = 0;\tz = x + y;\treturn z;&#125;int main() &#123;\tint a = 10;\tint b = 20;\tint c = Add(a, b);\tprintf(&quot;%d\\n&quot;, c);\t\treturn 0;&#125;\n\n2.1 寄存器  常见寄存器有 eax、ebx、ecx、edx，其中 ebp 和 esp 较为特殊\n\nebp、esp 这两个寄存器中存放的是地址，这两个地址是用来维护函数栈帧的\n\n\neax&#x2F;ebx&#x2F;ecx&#x2F;edx：通用寄存器，保留临时数据\nebp：栈低指针\nesp：栈顶指针\neip：指令寄存器，保存当前指令的下一条指令的地址\n\n\n2.2 主函数调用  每一个函数调用，都要在栈区创建一个空间\n我们知道 main 函数是程序的入口\n实际上，main函数也是被其他函数调用的\n\nmainCRTStartup函数调用__tmainCRTStartup\n__tmainCRTStartup函数调用 main 函数\n\n编译器会先在内存高地址处开辟一部分空间给 mainCRTStartup 和__tmainCRTStartup函数，它们进行调用 main 函数的操作。\n\n在 VS2019 中，按 F10 进行调试，出现黄色小箭头后，右键 - 转到反汇编，即可打开调试中汇编语言的显示界面\n\n3. 逐条解释 3.1 从 main 开始 先来看第一部分代码，逐条语句进行解释\npush  ebp// 在栈顶开辟存放 ebp 这一寄存器对应值的空间mov  ebp,esp// 将 esp 的值传入 ebp 中（即将 ebp 指针移动到原本 esp 指向的位置）sub  esp,0E4h// 将 esp 的内容减去 0E4h（将 esp 移动到原 esp-0E4h 的位置）push ebx// 在栈顶放入 ebxpush esi// 在栈顶放入 esipush edi// 在栈顶放入 edi\n\n\n\nlea：load effecticve address 加载有效地址\ndword：double word – 4 个字节\n\nlea  edi,[ebp-24h]// 将 ebp-24h 的地址放入 edimov  ecx,9// 将 9 放入 ecx，对应十进制 36mov  eax,0CCCCCCCCh// 将 0CCCCCCCCh 放入 eaxrep stos  dword ptr es:[edi]// 将 edi 往下 ecx 个地址的数据全部初始化为 0CCCCCCCCh\n\n按 F10 往下运行，过 rep 那一步后，可以看到 36 个字节的数据都被初始化为0CCCCCCCCh\n\n\n继续往下运行，可以看到编译器初始化 a、b 变量的过程\n\n\n\nVS2019 下是小端存储\n\n\n\n\tint c =Add(a,b);mov    eax,dword ptr [b]// 把 b 的内容放入 eaxpush   eax  // 在栈顶放入 eaxmov    ecx,dword ptr [a]// 把 a 的内容放入 ecxpush   ecx  // 在栈顶放入 ecxcall   _Add (01A10B4h) // 在栈顶放入该地址（call 指令下一条指令的地址） \n\n最后这一步 call 很关键，后续会用到\n\n3.2 调用 Add按 F11，进入 Add 函数\n\n\npush    ebp// 将 ebp 上移mov     ebp,esp// 将 esp 内容放入 ebp（移动 ebp）sub     esp,0CCh//esp+0CCh（为 Add 开辟空间）push    ebx// 在栈顶放入 ebxpush    esi// 在栈顶放入 esipush    edi// 在栈顶放入 edi\n\nlea      edi,[ebp-0Ch]//ebp-0Ch 的空间  mov      ecx,3//3 存入 ecx  mov      eax,0CCCCCCCCh// 存入 eax  rep stos  dword ptr es:[edi]//esp 往下 0ch 的空间初始化mov      ecx,offset _6A27082D_test@c (024C003h)  call     @__CheckForDebuggerJustMyCode@4 (024131Bh)\n\n\n\n继续往下，寄存器初始化了 Z 地址处的数据 为 0\n\nmov    eax,dword ptr [x]// 将 x 的值放入 eaxadd    eax,dword ptr [y]// 将 y 的值加道 eax 中，即 x+y   mov    dword ptr [z],eax// 将 eax 的值放入变量 z\n\n\n\treturn z;mov    eax,dword ptr [z]// 将形参 z 的值放入 eax \n\n\npop     edi// 出栈，删除为 edi 创建的栈区pop     esi//pop 指令会将 esi 的值放入 esi（等于没变）  pop     ebx// 每 pop 一次，esp 就往高位移动一次      add     esp,0CCh// 为 esp 地址 +0CCh，即退出 Add 程序的栈区空间 cmp     ebp,esp// 将 esp 的值与 ebp 进行比较\n\n\ncall        __RTC_CheckEsp (0241244h)  mov         esp,ebp//ebp 的值赋给 esp，此时 esp 和 ebp 相同\n\n\npop         ebp// 弹出 ebp  \n\n这里执行弹出指令时\n\n将 ebp 所指向的 main 函数的起始地址赋值给了 ebp 指针\nesp 指针向高位移动一位\n\n最后的结果如下图所示，esp 和 ebp 重新开始维护 main 函数的栈区空间\n\n3.3 回到 main 函数ret  \n\n前面提到 call   _Add (01A10B4h) 这条指令非常重要，实际上，在执行 ret 指令时，esp 指针就指向了栈顶存放的call 指令的下一条指令的地址，同时，这个地址也被 pop 掉了\n\n回到调试界面，可以看到黄色小箭头的确指向了 call 指令的下一条\n\n而这一条指令的意思，是往 esp 里加 8，即向高位移动 8 个字节。\n实际上这条指令就是在  销毁我们的形参\n\nmov      dword ptr [c],eax// 将 eax 中的值放入变量 c  \n\n此时 eax 中存放的就是Add 函数的返回值\n\n这里我们可以得出一个结论：\n自定义函数的返回值是通过寄存器这一中间“变量”，返回主函数中的。\n\n先把返回值放入寄存器 A\n主函数从寄存器 A 中取出返回值，放入接受返回值的变量\n\n\n继续往下，可以看到 printf(&quot;%d\\n&quot;, c); 语句后，编译器又一次将变量 c 的值放回了 eax\n实际上这里是 printf 函数的运行：\n\n先把待打印变量放入 eax\n在栈顶压入 eax\noffset string &quot;%d\\n&quot;（猜测是数据类型检查）\n_printf ：执行 printf 函数\n\n\nadd  esp,8// 给 esp+8 个字节\n\n我对这一部分产生了疑惑，重新调试发现\n\npush eax这一指令让 esp 往低地址处走了 4 个字节\noffset string &quot;%d\\n&quot;这一指令也让 esp 往低走了 4 个字节\n\n\n执行完这一指令后，esp 回到了执行 printf 之前的地址处\n\n3.4 结束程序\treturn 0;xor    eax,eax//xor 指令是异或 -- 在这里的作用不清楚&#125;pop    edi// 出栈 --esp 对应移动  pop    esi//  pop    ebx//  \n\n\nadd    esp,0E4h//esp+0E4h（退出为 main 函数开辟的空间） cmp    ebp,esp// 比较 ebp 和 esp  \n\n\n\ncall   __RTC_CheckEsp (0241244h)  mov    esp,ebp// 将 ebp 的值复制给 esp // 此时 esp 和 ebp 的值依旧相同    \n\n\npop    ebp//ebp 出栈 --esp 和 ebp 分离ret//main 函数结束  \n\n\n\n4. 本篇博客中的汇编语言总结\nmov：数据转移指令\n\npush：数据入栈，同时 esp 栈顶寄存器往低位走\n\npop：数据弹出至指定位置，同时 esp 栈顶寄存器往高位走\n\nsub：减法\n\nadd：加法\n\ncall：函数调用。1. 压入返回地址；2. 转入目标函数\n\njump：通过修改 eip，转入目标函数，进行调用\n\nret：回复返回地址，压入 eip，类似 pop eip 指令\n\ncmp（比较）：执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数\n\nxor：在两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，并将结果存放在目标操作数中\n\n\n\n部分汇编指令参考：C 语言中文网\n\n\n5. 结语\n完成这篇博客的时候，已经是周六的 00:54🌛\n从周五的 19:20 开始，不知不觉中写了这么久\n\n函数调用堆栈这一部分的知识有些晦涩难懂，写下这篇博客也算是理清了一些思路吧。\n加油！\n顶不住了，睡觉去了\n\n说来讽刺，几个舍友还在打某 3 亿鼠标的枪战梦想……\n\n","categories":["初识C语言"],"tags":["C语言","编译"]},{"title":"【C 语言】自定义类型（详解）","url":"/posts/313651598/","content":"[TOC]\n在 C 语言中，有几个比较特殊的自定义类型：结构体 、 枚举 、 联合\n本篇博客，就让我们来认识一下这些自定义类型吧！😶\n1. 结构体  结构体是一些值的集合，结构体的每个成员可以是不同类型的变量\n1.1 结构体的声明  以个人信息为例，有姓名、性别、年龄、身高等几个元素。可以定义结构体如下\nstruct Stu&#123;\tchar name[20];\tchar sex[5];\tint age;\tint hight;&#125;s2, s3, s4;//s2,s3,s4 全局变量\n\n1.2 特殊声明  在声明结构体的时候，可以不完全声明\nstruct&#123;\tchar c;\tint a;\tdouble d;&#125;sa;struct&#123;\tchar c;\tint a;\tdouble d;&#125;*ps;\n\n这两个结构体就是两个  匿名结构体  类型，省略了结构体标签。\n\n匿名结构体类型只能定义一次，后续无法使用\n\n这两个结构体的内容是完全一样的。\n在第二个结构体里面，定义了一个结构体指针 *ps，请问这个指针能存放&amp;sa 吗？\nint main()&#123;\t// 编译器认为等号两边是不同的结构体类型，所以这种写法是错误的\tps = &amp;sa;\treturn 0;&#125;\n\n1.3 结构体的自引用  在定义结构体的时候，可以包含一个该结构体本身的成员\n// 代码 1- 错误struct Node&#123; int data; struct Node next;&#125;;// 正确的自引用方式struct Node&#123; int data; struct Node* next;&#125;;\n\n在很多时候，我们会使用 typedef 函数来为结构体重命名\n\ntypedef 函数不能重命名  匿名结构体\n\ntypedef struct&#123; int data;` Node* next;&#125;Node;// 不能重命名匿名结构体// 正确写法typedef struct Node&#123; int data; struct Node* next;&#125;Node;\n\n\n1.4 结构体变量的定义和初始化struct Point&#123; int x; int y;&#125;p1; // 声明类型的同时定义变量 p1struct Point p2; // 定义结构体变量 p2\n\n// 初始化：定义变量的同时赋初值。struct Point p3 = &#123;x, y&#125;;struct Stu        // 类型声明&#123; char name[15];// 名字 int age;      // 年龄&#125;;struct Stu s = &#123;&quot;zhangsan&quot;, 20&#125;;// 初始化struct Node&#123; int data; struct Point p; struct Node* next; &#125;n1 = &#123;10, &#123;4,5&#125;, NULL&#125;; // 结构体嵌套初始化struct Node n2 = &#123;20, &#123;5, 6&#125;, NULL&#125;;// 结构体嵌套初始化\n\n\n1.5 结构体内存对齐  结构体在内存中的存储方式比较特殊\nstruct S1&#123;\tchar c1;//1\tint i;//4\tchar c2;//1&#125;;\n\n结构体里面一共存放了 6 个字节的内容，按理来说，它所占的空间应该也是 6 个字节。\n但当我们用 sizeof 计算它的长度的时候，却得到了 12 个字节。\n\n这是为什么呢？\n\n结构体在内存中存放的时候，为了保证内存读取效率，需要进行  内存对齐\n\n\n第一个成员在与结构体变量偏移量为 0 的地址处。 \n\n其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处\n\n\n 对齐数 &#x3D; 编译器默认的一个对齐数 与 该成员大小的较小值\n VS 中默认的值为 8 \n\n结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。 \n\n如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处。结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。\n\n\n\n\noffsetof 函数：查看结构体成员变量相对于首地址的偏移量\n\n\n\ni 变量是 int 类型，4 个字节，默认对齐数是 8，对齐数是 4。C2 变量是 1 个字节，对齐数就是 1。\n\n所以 int i 就要从内存的 4 的整数倍的位置开始存放，也就是第 5 个字节的位置。c2 在 int 后，在对齐数 1 的整数倍的位置进行存放，也就是第 9 个字节的位置。\n\n而结构体的总大小应该是最大对齐数（这里就是 4）的整数倍，9 并不是 4 的整数倍，所以结构体的总大小应为 12 个字节\n\n\n\n如图，结构体的 3 个成员在内存中存放并不是完全连续的。char c1和 int i 之间相隔了 3 个字节，char c2后还空出了 3 个字节。\n\n特殊情况：数组\nstruct Stu &#123;\tint i;    //4  4,8 - 4    char c[5];\t//5  1,8 - 1&#125;;\n\n数组在计算对齐数的时候，是看单个元素的大小，而不是看整个数组的大小。\n\nchar c[5]数组占 5 个字节\n计算对齐数的时候，用 char 类型的 1 个字节 和 8 对比，对齐数是 1\n\n （请忽略图中 char 数组的下标）\n\n\n那么为什么需要  内存对齐  呢？\n\n平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。\n\n性能原因： 数据结构 (尤其是栈) 应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访 问。\n\n\n\n在设计结构体的时候，我们可以把占用空间小的结构体成员尽量放在一起，这样可以减小结构体所占的空间\n\n\n1.6 修改默认对齐数  我们可以利用 #pragma 预处理指令来更改默认对齐数\n#pragma pack(1)// 设置默认对齐数为 1struct S2&#123; char c1; int i; char c2;&#125;;#pragma pack()// 取消设置的默认对齐数，还原为默认\n\n\n\n1.7 结构体传参struct S&#123; int data[1000]; int num;&#125;;struct S s = &#123;&#123;1,2,3,4&#125;, 1000&#125;;// 结构体传参void print1(struct S s)&#123; printf(&quot;%d\\n&quot;, s.num);&#125;// 结构体地址传参void print2(struct S* ps)&#123; printf(&quot;%d\\n&quot;, ps-&gt;num);&#125;int main()&#123; print1(s);  // 传结构体 print2(&amp;s); // 传地址 return 0;&#125;\n\n在结构体传参的时候，我们最好传结构体的地址。\n\n函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。\n\n\n\n2. 位段  位端是一种特殊的结构体\n2.1 什么是位段?\n位段的声明和结构是类似的，有两个不同：\n1. 位段的成员必须是 int、unsigned int 或 signed int \n2. 位段的成员名后边有一个冒号和一个数字。\n\nstruct A&#123; int _a:2; int _b:5; int _c:10; int _d:30;&#125;;\n\n成员名后的  数字  表示，该成员需要几个比特的空间来存储\n\n在结构体内，最小的成员 char 类型都需要 1 个字节的空间。但有些数据并不需要 1 个字节来存储，这时候就可以用位段来减少空间占用\n\nint _a:2;//2bit - 00 01 10 11 - 四种情况\n\n位端的大小如下：先是开辟 4 个字节的空间，进行 a、b、c 的  连续存放。存放完毕后还剩 15 个 bit 的空间，不够存放 d 的 30 个 bit，所以开辟了第二个 4 个字节的空间，用来存放成员 d\n\n\n2.2 位段在内存中的存储\n位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型 \n\n位段的空间上是按照需要以 4 个字节（ int ）或者 1 个字节（ char ）的方式来开辟的\n\n位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段\n\n\n\n// 一个例子struct S&#123; char a:3; char b:4; char c:5; char d:4;&#125;;struct S s = &#123;0&#125;;s.a = 10;//1010- 截断 -010s.b = 12;//1100- 完整保存 -1100s.c = 3;//0011- 前补 0-00011s.d = 4;//0100- 完整保存 -0100\n\n\na 和 b 占一个字节\nc 占独立的一个字节\nd 占一个字节\n\n它在内存中的存储如下图所示：\n\n2.3 位段的跨平台问题  在不同编译器下，位段的存储方式会有很大的不同\n\n\nint 位段被当成有符号数还是无符号数是不确定的。\n位段中最大位的数目不能确定（16 位机器最大 16，32 位机器最大 32，写成 27，在 16 位机器会出问题）\n位段中的成员在内存中从左向右分配，还是从右向左分配 标准尚未定义\n当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的\n\n\n跟结构体相比，位段可以达到同样的效果，还能很好的节省空间，但是有跨平台的问题存在。\n2.4 位段的应用  在互联网中，数据在服务器和服务器之间传递的时候，会参照以下的范式。\n图里的 4 位 (4bit) 版本号  和首部长度 ，以及 3 位 标志，都没有达到 1 个字节的大小。这时候如果用结构体来保存，就会存在较大的空间浪费，从而加大服务器的压力。\n这时候就适合采用位段来存储这样的内容，节省空间。\n\n\n3. 枚举\n枚举的意思是一一列举\n\n在生活中有一些事物的类型是可以一一列举出来的（有限的）。\n比如：人的性别、星期、12 个月。\n在 C 语言中，就可以用枚举类型来定义这种有限的元素\n3.1 枚举类型的定义enum Day// 星期&#123; Mon, Tues, Wed, Thur, Fri, Sat, Sun&#125;;enum Sex// 性别&#123; MALE, FEMALE, SECRET&#125;；\n\n需要注意的是，枚举类型和结构体是不同的。\n\n&#123; &#125;中的内容是枚举类型的可能取值，也叫  枚举常量 \n\n枚举类型代表具体的数值。默认是从 0 开始，以 1 递增。\n\n枚举类型可以用来替代数值\n\n\n比如在 day 的枚举类型里面，每一个元素分别代表一个数字。默认是从 0 开始，以 1 递增。\nenum Day// 星期&#123; Mon,//0 Tues,//1 Wed,//2 Thur,//3 Fri,//4 Sat,//5 Sun//6&#125;;\n\n我们在定义的时候也可以赋初值\nenum Color// 颜色&#123; RED=1, GREEN=2, BLUE=4&#125;;\n\n如果你只对其中一个常量赋值了，后面的常量也是以 1 递增的\nenum Day// 星期&#123; Mon,//0 Tues,//1 Wed=5,//5 Thur,//6 Fri,//7 Sat,//8 Sun//9&#125;;\n\n3.2 枚举的优点  我们可以使用 #define 定义常量，为什么非要使用枚举？ \n枚举的优点： \n\n增加代码的可读性和可维护性 \n和 #define 定义的标识符比较枚举有类型检查，更加严谨。 \n防止了命名污染（用了 &#123; &#125; 封装） \n便于调试\n使用方便，一次可以定义多个常量\n\n其中第四点的内容见下图：\n\n\n3.3 枚举的使用enum Color// 颜色&#123; RED=1, GREEN=2, BLUE=4&#125;;// 在定义完枚举常量之后，无法在外部进行更改！RED=3,//errenum Color clr = GREEN;// 只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。clr = 5; //err\n\n\nenum Color里面的内容是  枚举常量\nenum Color clr是一个  枚举变量\n\n需要注意的是，如果你用数字给  枚举变量  赋值，在 .c 文件下不会报错，但是在 .cpp 文件下会报错\n\nCPP 文件的语法检查更严格！\n\n\n\n那么，如何日常使用中应用枚举类型呢？\n\n在计算器的代码中👉【博客链接】\n我们可以使用枚举常量来替代干巴巴的 case 0、case 1 等等\n// 这只是个示例// 详细代码见之前的博客enum Options&#123; \tEXIT,//0 \tADD,//1    SUB,//2    MUL,//3    DIV//4&#125;;void menu()&#123;\tprintf(&quot;**********************************\\n&quot;);\tprintf(&quot;*****  1. add     2. sub     *****\\n&quot;);\tprintf(&quot;*****  3. mul     4. div     *****\\n&quot;);\tprintf(&quot;*****  0. exit               *****\\n&quot;);\tprintf(&quot;**********************************\\n&quot;);&#125;int main()&#123;\tint input = 0;\tint x = 0;\tint y = 0;\tint ret = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot; 请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase ADD:         // 用枚举类型代替原本的数字，增强代码可读性\t\t\tbreak;\t\tcase SUB:\t\t\tbreak;\t\tcase MUL:\t\t\tbreak;\t\tcase DIV:\t\t\tbreak;\t\tcase EXIT:\t\t\tprintf(&quot; 退出计算器 \\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot; 选择错误 \\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n\n4. 联合体 4.1 联合类型的定义 联合也是一种特殊的自定义类型\n这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）\n// 联合类型的声明union Un&#123; char c; int i;&#125;;// 联合变量的定义union Un un;\n\n当我们计算这个联合体的大小的时候，发现它只有 4 个字节，并不是 5 个字节。\n而且 char c 和int i元素的起始地址相同，这说明它们是公用这 4 个字节的空间的。\n\n4.2 联合体的特点\n联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小\n（因为联合至少得有能力保存最大的那个成员）\n\nunion Un&#123; int i; char c;&#125;;union Un un;// 下面输出的结果是什么？un.i = 0x11223344;un.c = 0x55;printf(&quot;%x\\n&quot;, un.i);\n\n\n4.3 用联合体判断大小端\n在之前数据存储的学习中，我们了解到了什么是编译器的大小端，并写了一个函数来判断当前编译器的大小端👉链接\n\n#include &lt;stdio.h&gt;int check_sys()&#123;\tint a=1;\tchar*p=(char*)&amp;a;\tif(1==*p)\t\treturn 1;\telse\t\treturn 0;\t\t&#125;int main()&#123;\tint b=check_sys(); \tif(1==b)\t\tprintf(&quot; 小端 \\n&quot;);\telse\t\tprintf(&quot; 大端 \\n&quot;);    \treturn 0; &#125; \n\n\n将 int 类型地址强制转换成 char* 类型\n\n如果是小端，第一个地址是 01\n如果是大端，第一个地址是 00\n\n\n今天我们就利用  联合体的成员在内存中共享同一空间的特点，来改进这个代码。\nint cheak_sys()&#123;\tunion\t&#123;\t\tchar c;\t\tint i;\t&#125;u;\tu.i = 1;// 将 int 类型改成 1\treturn u.c;// 返回该类型的第一个字节&#125;int main()&#123;\tint ret = cheak_sys();\tif (1 == ret)\t\tprintf(&quot; 小端 \\n&quot;);\telse\t\tprintf(&quot; 大端 \\n&quot;);\t// 如果返回 1，表示小端\t// 如果返回 0，表示大端\treturn 0;&#125;\n\n\n使用联合体，就无需进行指针类型的强制转换\n对 char c 类型的定义可以覆盖掉 int i 的第一个字节\n\n\n4.4 联合体在内存中的存储  和结构体一样，联合体也需要进行内存对齐\n\n联合的大小至少是最大成员的大小\n当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍\n\nunion Un1&#123;\tchar c[5];//5  1,8 - 1\tint i;    //4  4,8 - 4&#125;;union Un2&#123;\tshort c[7];//14  2,8-2\tint i;     //4   4,8-4&#125;;\n\n需要注意的是，联合体在计算对齐数的时候，数组是按一个元素的大小进行计算，而不是以整个数组的大小进行计算！（这一点和结构体是一样的）\n\nUn2 中 short 数组的对齐数：\n\nshort c[7]一共 14 个字节\n每个元素是 2 个字节\n默认对齐数是 8\n所以它的对齐数是 2\n\n\n\n以 Un1 为例，它在内存里的存储方式如图 (请忽略图中 char 数组的下标)\n\nchar c[5]和 int i 类型共用前 5 个字节（其中 int i 占 4 个字节）\n因为需要对齐到最大对齐数的整数倍，所以大小是 8\n\n\n\n结语  自定义类型的内容非常丰富\n你学会了吗？\n\n码字不易，若有帮助，点个赞呗！\n\n","categories":["初识C语言"],"tags":["C语言","自定义类型"]},{"title":"【C 语言】数组竟然还可以这样调用？慕雪学艺不精了！","url":"/posts/842609448/","content":"数组竟然还可以这样调用？只能说慕雪学艺不精了！\n\n\n上代码！起因是群里的一个图，本来以为只是个开玩笑的 bug 图，谁知道其他群友说了，我才发现是自己毛都不懂\n\n代码就大概是下面这样，请问你的第一印象，这个代码是否有语法错误呢？\n#include &lt;stdio.h&gt;int main()&#123;    int a[10] = &#123;1,3,4,5,6,7&#125;;    printf(&quot;%d &quot;,a[4]);    printf(&quot;%d\\n&quot;,4[a]);    return 0;&#125;\n\n问题肯定是第二个 printf 中的4[a]，直接上编译运行结果，可以看到不但没有出错，二者的打印的数据也完全相同\n[muxue:~/code/c/c_cpp]$ gcc test.cpp -o test[muxue:~/code/c/c_cpp]$ ./test6 6\n\n为啥？如果你对 C 语言的指针有过了解，应该知道 a[n] 实际上在访问的时候，会被转成 *(a+n)来访问具体的地址\n既然是这样，那我们把 a 和 n 的顺序倒过来，访问的不就是 *(n+a)了吗？\n学过加法交换律的都知道，这两个访问的结果肯定是相同的\n所以这个代码是没有语法错误的，只不过看着很让人迷惑而已。\n不过，要是真有人在实际项目里面这样写代码，那就可以去“问候”一下他了。代码可读性极低。\n顺带一提 C++ 中的操作符[] 的重载是不支持你这么玩的哦！因为和 operator[] 函数的参数的顺序不一样了\n#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; a = &#123;1,3,4,5,6,7&#125;;    printf(&quot;%d &quot;,a[4]);    printf(&quot;%d\\n&quot;,4[a]);//err    return 0;&#125;\n\n编译报错\n[muxue:~/code/c/c_cpp]$ g++ test.cpp -o testtest.cpp: In function ‘int main()’:test.cpp:10:20: error: no match for ‘operator[]’ (operand types are ‘int’ and ‘std::vector&lt;int&gt;’)     printf(&quot;%d\\n&quot;,4[a]);                    ^\n\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】文件操作（详解）","url":"/posts/1752111627/","content":"[TOC]\n好久没有更新 C 语言学习的博客了，今天带来的是文件部分的知识点！😋\n1. 为什么需要文件？之前学习过通讯录的代码实现，可以给通讯录中增加、删除联系人。但是这个通讯录在你 exe 文件关闭的同时就被销毁了，它的内容并不能顺延到下一次打开这个通讯录，这对我们的使用产生了不便。\n而文件可以帮助我们  实现数据的持久化：将数据保存在磁盘文件中，下次打开通讯录的时候，之前保存的联系人不会消失。\n\n\n2. 什么是文件？文件就是存放在磁盘上的带特定格式的数据。\n2.1 文件分类  在程序设计中，一般讨论两种文件：程序文件、数据文件\n\n程序文件：代码源文件  如.c，目标文件.obj/.o，可执行文件.exe\n数据文件：程序在使用过程中读写的数据，比如读取内容的文件，以及数据输出的文件\n\n这篇博客我们了解的是  数据文件\n2.2 文件名  文件名包含 3 个部分：文件路径 + 文件名主干 + 文件后缀\n如：c:\\code\\test.txt\n文件标识常被称为文件名\n3. 文件的使用 3.1 文件指针 在文件操作中，非常重要的一个知识点就是  文件类型指针，简称文件指针\n每个文件在开辟的时候都有一个对于的文件信息区，用于保存文件的名字、状态、当前的位置等相关信息。这些信息保存在了一个结构体中，该结构体系统声明为FILE\n不同的 C 语言编译器都有不同的 FILE 类型，但是大同小异。\n打开一个文件的时候，系统会根据文件的内容，自动创建 FILE 结构体变量，并填充它的信息。\n\n我们需要使用文件的时候，就可以通过一个 FILE 类型的指针来访问这个结构体变量\n\n3.2 打开和关闭文件  文件在读写之前需要  打开文件 ，使用结束后需要 关闭文件\n\n这一点和动态内存管理很相似\n\nANSIC 规定用 fopen 函数来打开文件，fclose 来关闭文件。\n打开文件的同时，会返回一个 FILE* 的指针变量指向该文件。\n\n关闭文件后，文件指针就变成了  野指针，需要置为 NULL 防止错误调用\n\nfopen 函数打开文件失败，会返回空指针\n#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main()&#123;    // 打开文件\tFILE* pf = fopen(&quot;test.txt&quot;, &quot;r&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));// 用该函数打印错误信息\t\treturn 0;\t&#125;\t//1. 读文件    \t// 关闭文件\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main()&#123;\t// 打开文件\tFILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));// 用该函数打印错误信息\t\treturn 0;\t&#125;\t//2. 写文件        // 关闭文件\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n\nstrerror 函数在这篇博客里面有讲解👉点我\n\n3.2.1 文件使用方式  通过这张表格，我们可以了解一下文件使用方式的不同类型\n\n注意：使用它们用的都是  双引号，而不是单引号！\n\n\n用 w 写入的时候，会覆盖原本已有内容 。如果需要在已有内容后面 追加，需要使用 a\n\n3.2.2 标准输入输出流\n输出：内存→文件\n输入：文件→内存\n\n\n这里还有一个小知识点：C 语言程序，运行的时候会默认打开 3 个流\n\nstdin：标准输入流\nstdout：标准输出流\nstderr：标准错误流\n\n在执行输入输出操作的时候，之前我们是直接  将内存中的数据 printf 打印到屏幕上\n现在我们可以通过文件指针，将数据  输入到标准输出流，达到类似 printf 的效果\n\n3.3 文件输入输出函数  上述代码中，用到了 fputc 函数，这个函数的作用是将  一个字符输入到文件中\n下表列出了一些我们会用到的文件函数\n\n3.3.1 字符输入输出fputc 函数：向文件中写入单个字符\n\nfgetc 函数：从文件中读取单个字符\n可以看到，我们把刚刚文件中写入的字符全部打印出来了\n\n实现文件拷贝  将一个文件的内容拷贝到另外一个文件中\nint main()&#123;\t// 实现一个代码将 data.txt 拷贝一份 生成 data2.txt\tFILE* pr = fopen(&quot;data.txt&quot;, &quot;r&quot;);\tif (pr == NULL)\t&#123;\t\tprintf(&quot;open for reading: %s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\tFILE* pw = fopen(&quot;data2.txt&quot;, &quot;w&quot;);\tif (pw == NULL)\t&#123;\t\tprintf(&quot;open for writting: %s\\n&quot;, strerror(errno));\t\tfclose(pr);\t\tpr = NULL;\t\treturn 0;\t&#125;\t// 拷贝文件\tint ch = 0;\twhile ((ch = fgetc(pr)) != EOF)\t&#123;\t\tfputc(ch, pw);\t&#125;\tfclose(pr);\tpr = NULL;\tfclose(pw);\tpw = NULL;\treturn 0;&#125;\n\n\n\n3.3.2 文本行输入输出fputs 函数：将字符串写入到文件中\n// 写一行#include &lt;stdio.h&gt;int main()&#123;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;w&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\tfputs(&quot;hello world\\n&quot;, pf);\tfputs(&quot;hehe\\n&quot;, pf);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n运行代码，可以看到两行字符串已经被写入到了项目路径下的 data.txt 文件中\n\nfgets 函数：从文件中读取规定长度的字符串\n该函数在使用的时候具有第 3 个参数，用于限制读取字符串的长度\n//// 读文件 - 读一行int main()&#123;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;r&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\tchar buf[1000] = &#123;0&#125;;\t// 读文件\tfgets(buf, 3, pf);\tprintf(&quot;%s\\n&quot;, buf);\tfgets(buf, 3, pf);\tprintf(&quot;%s\\n&quot;, buf);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n运行程序，可以看到我们设置的是 3，却只读取了 2 个字符出来\n\n将 buf[2] 更改为 1，调试查看\n\n可以看到，在执行第一个 fgets 函数后，原本的 1 被写入成了\\0\n\n这就证实：fgets 函数在读取字符的时候，会以 \\0 作为结尾\n如果我们需要读取 3 个字符，就需要将限制设置为 4\n\n3.3.3 格式化输入输出  这里的“格式化”指的是结构体这种  具有特定格式的数据内容\nfprintf 函数：将格式化数据写入文件中\n#include&lt;stdio.h&gt;//……struct Stu&#123;\tchar name[20];\tint age;\tdouble d;&#125;;int main()&#123;\tstruct Stu s = &#123; &quot; 张三 &quot;, 20, 95.5 &#125;;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;w&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t// 写格式化的数据\tfprintf(pf, &quot;%s %d %lf&quot;, s.name, s.age, s.d);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n\nfscanf 函数：从文件中读取格式化数据，存放到对应结构体变量 s 中\n\n\n3.3.4 二进制输入输出\nfread、fwrite 可以操作任意类型的数据\n正如它的名字，二进制输入函数是将内容以二进制的方式输入到文件中\n\n\n使用该函数的时候需要使用 **”rb”,”wb”** 来打开文件\n\n\nfwrite(s, sizeof(struct Stu), 2, pf);//s 来源//sizeof 需要写入元素的大小//2 需要写入元素的个数//pf 写入的目标文件指针\n\n以下是写入结构体变量的例子\nstruct Stu&#123;\tchar name[20];\tint age;\tdouble d;&#125;;// 二进制的写int main()&#123;\tstruct Stu s[2] = &#123; &#123;&quot; 张三 &quot;, 20, 95.5&#125; , &#123;&quot;lisi&quot;, 16, 66.5&#125;&#125;;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;wb&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t// 按照二进制的方式写文件\tfwrite(s, sizeof(struct Stu), 2, pf);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n可以看到，此时写入的数据已经部分成了乱码。这时候它的内容已经是用二进制存放的了，txt 阅读器无法正确读出这些数据\n\n二进制的读取  就是复现这一步，将文本中的二进制数据以特定格式读取出来，并放入对应变量\nfread(s, sizeof(struct Stu), 2, pf);//s 存放文件内容的变量//sizeof 需要读取元素的大小//2 需要读取元素的个数//pf 读取的目标文件指针\n\n\n3.3.5 sscanf&#x2F;sprintf 函数  这两个函数比较特殊，它们的作用是将文件里面的  格式化数据 （如结构体）以 字符串  的形式拷贝到字符数组里面\n\n见下图\n\n\n\n3.4. 其他文件函数3.4.1 fseek\nhttps://cplusplus.com/reference/cstdio/fseek/?kw=fseek\n\n该函数的作用是：将文件指针移动到相对于某个位置的特定偏移量的位置\n\n听起来有点绕口，举例说明就知道了\n\n给定一个字符串“abcdef”\n每次使用一次 fgetc，文件指针就会往后进一位。使用两次，文件指针指向的是字符 c\n如果我们需要指向 f，就让指针\n\n从开始位置向后进 5 位\n从当前位置向后进 3 位\n从结束位置向前进 1 位\n\n\n我们可以用该函数，定位文件指针，将其更改到我们需要的位置，进行字符替换等操作\nint main()&#123;    FILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);    if (pf == NULL)    &#123;        printf(&quot;%s\\n&quot;, strerror(errno));        return 0;    &#125;    // 写文件    int ch = 0;    for (ch = &#x27;a&#x27;; ch &lt;= &#x27;z&#x27;; ch++)    &#123;        fputc(ch, pf);    &#125;    // 定位文件指针        fseek(pf, -2, SEEK_END);    fputc(&#x27;#&#x27;, pf);// 将当前字符替换成 #    fclose(pf);    pf = NULL;    return 0;&#125;\n\n\n3.4.2 ftell返回文件指针当前的偏移量（相对于文件开头）\n\n3.4.3 rewind\nhttps://cplusplus.com/reference/cstdio/rewind/?kw=rewind\n\n让文件指针的位置回到文件的起始位置\nfseek(pf, 0, SEEK_SET);//rewind 函数与该 fseek 函数操作等价// 但是 rewind 更方便\n\nint main()&#123;    FILE* pf = fopen(&quot;test.txt&quot;, &quot;r&quot;);    if (pf == NULL)    &#123;        printf(&quot;%s\\n&quot;, strerror(errno));        return 0;    &#125;    // 读文件    int ch = fgetc(pf);    printf(&quot;%c\\n&quot;, ch);//a    ch = fgetc(pf);    printf(&quot;%c\\n&quot;, ch);//b        int ret = ftell(pf);    printf(&quot;%d\\n&quot;, ret);//2    rewind(pf);    //fseek(pf, 0, SEEK_SET);    ret = ftell(pf);    printf(&quot;%d\\n&quot;, ret);//0    fclose(pf);    pf = NULL;    return 0;&#125;\n\n4. 文本文件和二进制文件  我们现在已经知道了 fread&#x2F;fwrite 函数可以实现二进制的输入输出，它们是怎么具体实现的呢？\n\n根据数据的组织形式，数据文件被称为  文本文件或者二进制文件。 数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。\n如果要求在外存上以 ASCII 码的形式存储，则需要在存储前转换。以 ASCII 字符的形式存储的文件就是文本文件。\n在内存中，字符一律以 ASCII 形式存储，数值型数据既可以用 ASCII 形式存储，也可以使用二进制形式存储。\n对于数字 10000，可以用下面两种方式存储\n\n1 0 0 0 0 作为 5 个字符来存储–占用 5 个字节\n以数字本身的二进制形式存储–占用 4 个字节\n\n这时候使用二进制的方式，就能节省空间\n\n用如下代码，将 10000 以二进制方式写入文件中\n\n在 VS 中我们可以以特定打开方式  二进制编辑器  打开 test.txt 文档\n\n可以看到 10000 是以二进制码的形式存放在文件中的\n\n\n这里涉及到了大小端的问题👉点我\n\n\n5. 文件读取结束的判定  在一般情况下，我们可以直接判断 fgets/fgetc 的返回值来判断文件是否读取结束。但这两个函数在文件读取错误的时候，也会返回和  文件读取结束  一样的结果，此时就需要判断文件是因为什么情况结束的了\n此时就需要用到两个函数，ferror 和 feof\n5.1 ferrorferror 函数：判断文件是否出现了读取错误。\n// 来自 https://cplusplus.com/reference/cstdio/ferror/int ferror (FILE * stream);\n\n\n在函数描述里面可以看到，该函数会判断传入的文件流  最近的一次文件读写  是否出现了错误。其判断的是文件流中的 errror indicator 错误描述符。\n\n如果  有，返回为真 (非 0 值)\n如果没有，返回 0\n\n同时在函数释义里面，提到了错误会被 clearerr/rewind/freopen 这三个函数清除\n5.2 feof此函数用于判断文件流是否读取到了文件末尾\n// https://cplusplus.com/reference/cstdio/feof/int feof (FILE * stream);\n\n\n\n如果遇到了文件末尾，返回非 0 值（真）\n如果没有遇到，返回 0\n\n在函数的描述处，提到了流的内部指针可能指向的是文件结尾。但在尝试读取文件结尾之前，不一定会设置 EOF 指示符。这句话不是很好理解，看下图\n\n指针只有读取了文件末尾，才能知道自己已经走到了文件末尾，从而设置 EOF 标识符\n5.3 二者使用场景 feof/ferror 的先后顺序并没有特定的要求，因为它们两个的判断功能是不同的\n\nferror 判断的是读取是否出现了错误\nfeof 判断的是读取是否到了文件尾部\n\n依照读取退出的不同情况，可以分为下面几种类型\n\n读取成功，文件指针走到文件尾部，属于正常退出；feof 能够判断出文件指针是否走到了文件尾部。\n读取失败，出现了一些错误，此时应该用 ferror 查看错误原因\n\n理论上而言，我们应该先用 feof 判断：因为  读取到文件尾退出是没有问题  的；\n只有 feof 判断没有到文件尾部，而读取函数又退出了，才需要我们用 ferror 进行错误的判断。\nif(feof(fp))    printf(&quot;EOF reach&quot;);else if(ferror(fp))    printf(&quot;error while readfile&quot;);\n\n实际上，这两个函数的返回值是互斥的\n\n成功读取到了文件尾部，那肯定是没出错的\n出错了，肯定  没能  走到文件尾部并设置 EOF 标识符（注意，文件指针可能已经指向了文件尾部，但出错了）\n\n所以，这两个函数的先后顺序并不会相互影响😂\n5.4 不推荐只用 feof 判断读取是否结束  上课时，老师告诉我们，并不推荐在读取文件过程中，使用 feof 函数  的返回值来判断文件是否读取结束，如下\nwhile(!feof(fp))// 用 feof 的返回值判断文件是否读取结束&#123;    c = fgetc(fp);    printf(&quot;%c&quot;,c);&#125;\n\nfgetc函数本身的返回值就拥有此功能，更推荐在 fgetc 的循环结束后，用 feof 函数判断是读取失败结束，还是遇到文件结尾正常结束\n//1. 文件打开操作//2. fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回 EOFwhile ((c = fgetc(fp)) != EOF) // 标准 C I/O 读取文件循环&#123;    putchar(c);&#125;printf(&quot;\\n&quot;);//3. 判断是什么原因结束的if (ferror(fp))    puts(&quot;I/O error when reading&quot;);else if (feof(fp))    puts(&quot;End of file reached successfully&quot;);\n\n但在我查阅资料的时候，看到 C 语言中文网站 上使用了 feof 来判断文件是否读取结束。我感觉 C 语言中文网里面说的并没有啥问题，单看 feof 的函数作用，也确实能用来判断文件是否读取完毕。\n后来经过询问，得知老师的意思是：不能  只用 feof 来判断文件是否正常读取结束。必须要将 feof 和 ferror 结合起来。包括上面提供的示例代码中 步骤 3也是同时使用了 ferror 和 feof！\n\n5.5 文件读取判错流程 5.5.1 文本文件 文本文件读取是否结束，判断读取函数 fgetc/fgets 的返回值\n\nEOF  (fgetc)\nNULL (fgets)\n\n退出读取文件的循环后，用 feof 和 ferror 判断是否出现了错误\n\n5.5.2 二进制文件  二进制文件的读取结束，则需要判断返回值是否小于实际要读的个数：\n\nfread 的返回值是  成功读取数据的个数，判断返回值是否小于实际要读取的个数\n如果不等于（实际上只会是小于），有两种情况\n读取失败，遇到错误\n读取完毕文件，文件中的内容没有 SIZE 大小\n\n\n此时的场景，适合  先用 feof 判断是否已到文件尾部，再用 ferror 判断是否为文件错误\n如果 feof 判断已经读到文件尾部，说明是文件中的内容少于 SIZE 大小，应该提示  文件中的数据不足 SZIE 字节\n如果 feof 判断未走到文件尾部，说明出现了错误，用 ferror 判断，并提示  文件读取遇到错误\n\n\n\n再次说明，feof 和 ferror 使用的先后顺序  没有  明确区别和硬性要求，我们只需要根据自己的场景，给错误判断加上对应的提示信息即可！\n\n6. 文件缓冲区\nANSIC 标准采用“缓冲文件系统”处理数据文件。\n\n所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。\n\n这就和 git 一样，是先将需要 push 的文件放入缓存区，确认文件无误后再 push 到远程仓库中\n\n如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓 冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小是C 编译系统（编译器）决定的。\n\n因为有缓冲区的存在，C 语言在操作文件的时候，需要做刷新缓冲区或者在文件操作结束的时候关闭文 件。 如果不做，可能导致读写文件的问题。\n代码示例 1#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main()&#123;\tFILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);\tfputs(&quot;abcdef&quot;, pf);// 先将代码放在输出缓冲区\tprintf(&quot; 睡眠 10 秒 - 已经写数据了，打开 test.txt 文件，发现文件没有内容 \\n&quot;);\tSleep(10000);\tprintf(&quot; 刷新缓冲区 \\n&quot;);\tfflush(pf);// 刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘）\t\tprintf(&quot; 再睡眠 10 秒 - 此时，再次打开 test.txt 文件，文件有内容了 \\n&quot;);\tSleep(10000);\tfclose(pf);\t// 注：fclose 在关闭文件的时候，也会刷新缓冲区\tpf = NULL;\treturn 0;&#125;\n\n运行程序，通过 sleep 函数暂停程序，可以看到刚开始字符串并没有存入文件中\n\n而是先写入输入缓存区，刷新缓存区后，才写入 txt 文件\n\n代码示例 2\n#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main()&#123;\twhile (1)\t&#123;\t\tprintf(&quot;hehe\\n&quot;);\t\t// 在 linux 环境中，不带 &#x27;\\n&#x27; 的时候，并不会打印（没有刷新缓存区）\t\t// 而在 VS 环境中，带不带都会正常打印\t\tSleep(1000);//linux 环境中，sleep 函数的参数，单位是秒（VS 是毫秒）        //             linux 环境下，sleep 函数需要小写，VS 下是 Sleep\t&#125;\treturn 0;&#125;\n\n\n在 Linux 环境下（树莓派）测试这个代码\n可以看到，去掉 \\n 后，代码并不会打印 hehe\n\n编译的时候，遇到报错👇，但是程序依旧编译出来了\nimplicit declaration of function ‘sleep’\n\nCSDN 查了查，发现是需要引用头文件#include &lt;unistd.h&gt;\n重新编译，没有报错了（此处 hehe 已经加了\\n，程序正常打印）\n\n\n结语  文件章节的内容非常丰富，你学费了吗！😁\n大多数内容还是需要我们多多操作来熟悉它的真正作用\n\n如果内容有误，还请大佬无情指正！\n\n","categories":["初识C语言"],"tags":["文件","C语言","函数"]},{"title":"【C 语言】clock_gettime 函数的使用","url":"/posts/107825263/","content":"函数的基本信息如下\n\n其中第一个参数是配置你想获取什么类型的时间\n第二个参数是一个  输出型参数，会将当前时间存放到一个结构体里面给你返回。\n返回值标识是否获取成功\n\n// 头文件#include &lt;time.h&gt;// 函数原型int clock_gettime(clockid_t clock_id,struct timespec * tp );// timespec 结构体struct timespec &#123;     __time_t tv_sec; /* 秒 */     __syscall_s long_t tv_nsec; /* 纳秒 */&#125;;\n\n第一个参数有下面几种选项\nCLOCK_REALTIME: 是指系统时间，随着系统时间的改变而改变。系统时钟会被用户而改变。并非不变的时间戳。CLOCK_MONOTONIC: 指从系统启动时开始计时。不受系统设置影响，也不会被用户改变。CLOCK_PROCESS_CPUTIME_ID: 指这个进程运行到当前代码时，CPU 花费的时间。CLOCK_THREAD_CPUTIME_ID: 指这个线程运行到当前代码时，CPU 花费的时间。\n\n使用例子\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;int main()&#123;    struct timespec now;    clock_gettime(CLOCK_MONOTONIC,&amp;now);    printf(&quot;Seconds = %ld \\t Nanoseconds = %ld\\n&quot;,, now.tv_sec, now.tv_nsec);    return 0;&#125;\n\n输出结果\nSeconds = 29642          Nanoseconds = 751516090\n\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】预处理操作（详解）","url":"/posts/3942304404/","content":"[TOC]\n前言😜上篇博客，我们提到了 C 语言程序运行的几个环节。\n本篇博客中提到的预处理指令，就是在  预处理阶段  运行的一些代码。\n\n本篇博客使用的编译器🎰\n\nVS2019（win10）\n树莓派（linux-gcc）\n\n\n\n1. 预定义符号__FILE__ // 进行编译的源文件__LINE__ // 文件当前的行号__DATE__ // 文件被编译的日期__TIME__ // 文件被编译的时间__STDC__ // 测试编译器是否遵循 ANSI C，遵循值为 1，不遵循则该符号未定义\n\n\n2.#define2.1 定义标识符#define name stuff\n\n#define MAX 1000#define reg register   // 为 register 这个关键字，创建一个简短的名字#define do_forever for(;;)  // 用更形象的符号来替换一种实现#define CASE break;case    // 在写 case 语句的时候自动把 break 写上// 如果定义的 stuff 过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。#define DEBUG_PRINT printf(&quot;file:%s\\tline:%d\\t \\                           date:%s\\ttime:%s\\n&quot; ,\\                        __FILE__,__LINE__ ,       \\                        __DATE__,__TIME__ )  \n\n加分号问题define 定义标识符的时候，最好不要在结尾加上;\n#define MAX 1000;#define MAX 1000\n\n\n2.2 定义宏\n除了定义标识符以外，define 还可以定义一个语句为标识符，允许把参数替换到文本中。这种机制叫做定义宏\n\n下面是宏的申明方式： \n#define name(parament-list)  stuff \n\n其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在 stuff 中\n\n参数列表的左括号必须与 name 紧邻。 如果两者之间有任何空白存在，参数列表就会被解释为 stuff 的一部分\n\n// 如#define DOUBLE(x) x+x\n\n宏需要注意的问题  这个宏有一个问题👇\n#define DOUBLE(x) x+xint main()&#123;\tprintf(&quot;%d\\n&quot;, 10*DOUBLE(3));\treturn 0;&#125;\n\n这个式子输出的结果是什么呢？是 60 吗？\n答案是否定的：#define宏在使用的时候执行的是直接替换\n这个语句就相当于10*3+3，根据操作符优先级可知，结果为30+3&#x3D;33\n\n想解决这个问题，我们需要记住这个原则：\n\n给变量加上括号以确保优先级\n给整个宏再加上一个括号防止外部数据影响\n\n#define DOUBLE(x) ((x)+(x))\n\n再运行程序，发现答案变成了 60\n\n\n用于对数值表达式进行求值的宏定义，都应该用这种方式加上括号。避免在使用宏时，参数中的操作符或邻近操作符之间产生不可预料的相互作用\n\n2.3define 替换规则\n2.4 使用 # 和##2.4.1#将字符串插入字符串int main()&#123;\tint a = 3;\tint b = 5;\tprintf(&quot;the num of a is %d\\n&quot;, a);\tprintf(&quot;the num of b is %d\\n&quot;, b);\tprintf(&quot;\\n&quot;);        return 0;&#125;\n\n\n在这个代码里面，打印的前置内容 a 和 b 需要根据打印的变量进行更改\n有没有一种办法，可以让他自己进行更改？\n#define PRINT(X) printf(&quot;the num of &quot;#X&quot; is %d\\n&quot;, X)int main()&#123;\tint a = 3;\tint b = 5;\tprintf(&quot;the num of a is %d\\n&quot;, a);\tprintf(&quot;the num of b is %d\\n&quot;, b);\tprintf(&quot;\\n&quot;);\tPRINT(a);\tPRINT(b);\treturn 0;&#125;\n\n可以看到，#X处的内容被替换成了我们需要打印的变量\n\n实际上，这里 #X 旁边的双引号，是将整个字符串拆分成了 3 份进行打印\n\n“the num of”\n#X\n“is %d\\n”\n\n字符串在打印的时候具有自动拼接的特性，所以我们可以通过这种方式将一个需要更改的字符插入到字符串中\n2.4.2## 将两个符号合并\n##可以把位于它两边的符号合成一个符号。 \n它允许宏定义从分离的文本片段创建标识符。\n\n如图，这个宏将 Class 和 10 两个分离的符号合并成了 Class10，printf 识别出来并打印的了 Class10 的值\n\n当我们同名变量有很多的时候，就可以利用这种宏来给不同的变量增加数据。\n#define ADD_TO_SUM(num, value) sum##num += value;int sum1,sum2,sum3,sum4;ADD_TO_SUM(3, 10);// 给 sum3 增加 10.\n\n这样的连接必须产生一个合法的标识符，否则其结果就是未定义的。\n\n2.5 带副作用的宏参数  当宏在定义中出现超过一次时，如果参数带有副作用，使用这个宏的时候就有可能出现危险，导致无法预测的结果\n\n副作用指表达式求值时出现的一些附带效果，如前置 ++ 和后置 ++\n\nx+1// 不带副作用x++// 有副作用\n\n以下这个宏可以体现上面描述的问题\n#define MAX(x,y) ((x)&gt;(y)?(x):(y))\n\n如果是一个函数封装，我们的理解是，a 和 b 原来的值 3 和 5 被传入 MAX，然后再各自 ++ 一次\n但实际上并不是这样，可以看到 a++ 了一次，但是 b++ 了两次\n\n这是为什么呢？\n\n宏执行的是直接替换\n\n#define MAX(x,y) ((x)&gt;(y)?(x):(y))// 上述宏被替换后的结果int m=((a++)&gt;(b++)?(a++):(b++))\n\n这个表达式中，执行比较的时候，a 和 b 各 ++ 一次，但是在最后返回 b 的时候，末尾 b++ 被执行了一次\n得到的结果就是a=4，b=7\n2.6 宏和函数对比  宏经常被用作执行简单的计算（如上面提到多次的 MAX）\n这时候宏对比函数有几个优点\n\n函数的调用需要压栈出栈，比实际执行这个小型代码需要的时间更长。宏比函数在程序的执行速度方面更胜一筹\n函数的参数必须声明位特定的类型，只适用于特定类型的表达式上。反之，宏可以用整型、长整型、浮点型等可以用 &gt; 来比较的类型。宏的调用与类型无关\n\n除了 MAX 这个简单宏语句外，宏的参数还可以出现  数据类型\n如下图中我们调用的这个宏，就可以做到用一种更简单的方式来调用 malloc 函数。此时的调用只需要写入  待开辟数据个数和数据类型，不需要再写强制类型转换等语句，方便使用\n\n有得就有失，宏当然也有缺点：\n\n每次使用宏，执行的是直接替换。如果此时宏比较长，则会增加程序的长度\n宏在预处理阶段执行了替换，无法进行调试\n宏与类型无关，不够严谨\n宏会出现操作符优先级问题，容易出错\n\n2.7 命名约定  一般来讲函数的宏的使用语法很相似，所以语言本身没法帮我们区分二者。 \n那我们平时的一个习惯是： \n\n把宏名全部大写：MAX\n\n函数名不要全部大写：Max\n\n\n#define MAX(x, y) ((x)&gt;(y)?(x):(y))int Max(int x, int y)&#123;\treturn x &gt; y ? x : y;&#125;\n\n2.7 #undef这条指令用于移除一个宏定义\n#undef NAME\n\n如果不移除，就无法重复定义  同名宏\n\n\n3. 命令行定义  一些 C 语言的编译器提供了一个功能，允许我们在命令行中定义一个符号，用于启动编译过程\n当我们需要一个程序的不同版本时，可以使用该指令\n\n如：在不同情况下需要不同长度的数组\n\n\n如果我们直接编译这部分代码，编译器会报错，SZ 未定义\n\n但当我们写上这么一行命令\ngcc test.c -D SZ=10\n\n可以看到编译器没有报错，再次 ls，发现多了一个 a.out 文件\n\n执行该文件，可以看到 SZ 被定义成 10 并成功打印\n4. 条件编译  在编译一个程序的时候，我们可以通过  条件编译指令  来控制一组语句的使用与否\n4.1if&#x2F;endif#define M 1int main()&#123;\tint i = 0;\tint n = 10;\tfor (i = 0; i &lt; 10; i++)\t&#123;#if M\t\tprintf(&quot;%d\\n&quot;, i);#endif\t\t// 其他代码\t&#125;\treturn 0;&#125;\n\n#if语句后为真即执行，为假不执行\n\n该语句之后只能跟随常量表达式，不能跟随定义的变量\n\n#define M 1#if M// 正确#if 3&gt;5#if M==1// 正确int a=1;#if a//err\n\n\n在 linux 环境下，使用编译语句执行预处理操作，可以看到生成的 test.i 文件中，printf 代码是被包含进去的\n\n如果把 M 更改为 0，再次执行预处理操作。printf 语句并没有包含在 for 循环中\n\n\n如果这里放入变量 n，不起作用\n\n\n你可能想问，如果这一行代码我不需要，直接注释掉不就 ok 了吗？\n并不然。\n有些时候我们为了验证之前写的程序是否正确，会编写一些测试代码，用于 debug。这些代码在测试完成后可以删除，但是如果我们下次还需要测试同一个函数的时候，就有需要重新写一遍，很是不方便。\n有了条件编译指令，我们就可以在程序的最上方 #define 定义一个常量，来控制是否进行测试。\n\n4.2 多个分支的调节编译#define M 150int main()&#123;#if M&lt;100\tprintf(&quot;less\\n&quot;);#elif M==100\tprintf(&quot;==\\n&quot;);#elif M&gt;100&amp;&amp;M&lt;200\tprintf(&quot;more\\n&quot;);#else\tprintf(&quot;hehe\\n&quot;);#endif\treturn 0;&#125;\n\n和之前一样，不运行的代码，VS2019 会显示为灰色\n\n4.3 判断符号是否已被定义#define M 0int main()&#123;#if defined(M)\tprintf(&quot;hehe\\n&quot;);#endif#ifdef M\tprintf(&quot;haha\\n&quot;);#endif// 这两条语句等价       return 0;&#125;\n\n\n如果想把条件改为  未定义的时候执行，可以使用下面这两种方式\n\n!：逻辑反操作符\n\n\n4.4 嵌套指令  和其他语句一样，条件编译语句也可以嵌套使用\n#define M 0#define N 1#if defined(M)     #ifdef OPTION1     \tM_option1();     #endif     #ifdef OPTION2     \tM_option2();     #endif#elif defined(N)     #ifdef OPTION2     \tN_option2();     #endif#endif\n\n\n5. 文件包含  我们知道，#include指令可以使另外一个文件被编译。它同时也是一个替换：\n\n编译器在预处理阶段删除这条指令，用包含文件的内容替换\n一个源文件被包含 10 次，就会被编译 10 次\n\n5.1 包含方式#include &quot;test.h&quot;// 本地文件#include &lt;stdio.h&gt;// 库文件\n\n你可能会有这个疑问，这两种包含方式之间有什么区别呢？\n双引号方式\n现在源文件（项目文件）所在目录下查找。\n如果该头文件未找到，编译器就会像查找库函数头文件一样在  标准位置  查找头文件。\n如果找不到就提示编译错误\n\nVS2019 标准位置（去 VS 的安装目录找）\nC:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.29.30133\\include\n\nLinux 环境标准位置\n/usr/include\n\n\n库文件方式\n只在标准路径下查找，如果找不到就提示编译错误\n\n既然双引号方式也会去标准路径下查找，那是不是说我们可以用  双引号方式  包含库函数的头文件？\n答案是肯定的\n但是这么做，会让我们难以分辨  头文件到底是库函数还是自定义头文件。两次查找也会影响程序编译效率\n\n5.2 嵌套文件包含问题  假如在项目合作中，出现了这种情况\n\n\ncomm.h 和.c 是公共文件\ntest1.h 和 test1.c 使用了公共模块\ntest2.h 和 test2.c 也使用了公共模块\ntest.h 和 test.c 最终使用了 test1 和 2 模块\n\n这种情况下，就相当于有两份 comm.h 的内容被拷贝到最终的程序中\n假如 comm.h 中有 define 或者全局变量的定义，这就相当于一个定义语句写了两遍，出现了重复定义\n如何解决？我们可以在每个头文件的开头写\n#ifndef __TEST_H__#define __TEST_H__// 头文件的内容#endif\n\n这样，如果 __TEST_H__ 符号已经被定义过，编译器就不会二次展开头文件中的代码，也就避免了这个问题\n如果你使用的是 VS 编译器，在创建.h 文件的时候，VS 会自己包含一个语句\n#pragma once\n\n这个语句也有相同的作用\n\nwarning: #pragma once in main file在我尝试在 linux 环境下使用 #pragma once 语句时，遇到了这个报错\n\n解决这个问题的办法很简单，就是不要编译头文件\n\n编译器会自动展开头文件，无需手动编译\n\n\n\n网上查了查：出现这个问题的原因是编译器在编译头文件的时候，#pragma once本身是没有含义的语句，所以报错了。\n\n也有人说是  因为 linux 不支持这个语句，我们来试试\n\n右侧代码中包含了两个 test.h 的引用，在预处理中只包含了一次\n\n去掉头文件中的#pragma once，再次编译，可以看到预处理文件中出现了两次头文件的内容\n\n这说明 linux-gcc 编译器是支持该语句的，并非网上说的不支持！\n还有更多……其实预处理指令还远不止本博客中包含的这些\n#error#pragma#line\n\n这些预处理指令还等待我的学习~ 记录在小本本上了\n\n如果这篇博客对你有帮助，还请点个👍吧！\n","categories":["初识C语言"],"tags":["C语言","编译"]},{"title":"【C 语言】猜数字游戏 | 首篇博客","url":"/posts/2820557606/","content":"这是一初学 c 语言的新人的  第一篇博客 ，尝试使用Markdown 的方式写入\n\n\n这是一初学 c 语言的新人的第一篇博客  尝试使用 Markdown 的方式写入(本来用的 51cto，发现人好少，于是跑过来了）\n什么是 MarkdownMarkdown 是现在普遍使用的一种文档书写语言格式，只需用一些非常简单易记的符号，如 #*/&gt;[]0\\，就可以轻松写出一篇具有良好的排版和可读性的文. 接下来进入我们的正题\n猜数字游戏  这是一非常经典的代码应用  基本逻辑如下：\n\n1．计算机生成一个随机数 2．玩家输入一个猜想的数字3．计算机提示“猜大了”或者“猜小了” 并在玩家猜测正确时提示“恭喜你，猜对了”\n先来看看游戏最终是什么样子的吧\n\n玩家运行，可以看到一个菜单以及选择\n\n\n键入 1 即为开始游戏\n\n系统在玩家猜小或者猜大之后都会有对应的提示，猜对之后程序也会再次运行，玩家可以选择退出或者再来一次\n那么这个猜数字游戏是怎么实现的呢？\n首先我们制作一个简易的 menu\nvoid menu()&#123;\tprintf(&quot;*****************************\\n&quot;);\tprintf(&quot;****  1.play   0.exit    ****\\n&quot;);\tprintf(&quot;*****************************\\n&quot;);&#125;\n光是这个 menu 还不够，我们需要写一个代码串来实现在 1.play 和 0.exit 之间选择的功能\nswitch case 语句  为了实现这个功能，我使用的是 switch 语句\nmenu();printf(&quot; 请选择 &gt;:&quot;);scanf(&quot;%d&quot;, &amp;input);switch (input)&#123;case 1:\tgame();// 猜数字游戏 \tbreak;case 0:\tprintf(&quot; 退出游戏 \\n&quot;);\tbreak;default:\tprintf(&quot;选择错误 \\n&quot;);\tbreak;&#125;\n是不是觉得少了点什么？别急！\n\n玩家肯定想多次游玩这个猜数字游戏，总不能是一个一次性游戏吧\n所以我们需要给这个 switch 加上  循环  语句\n这里我用的是 do whlie 循环\n\nint main()&#123;\tint input = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot; 请选择 &gt;:&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();// 猜数字游戏 \t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot; 退出游戏 \\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误 \\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n因为我们这里用到了 scanf 库函数，所以我们需要引用头文件 #include &lt;stdio.h&gt;\n注意这里我们的 game() 函数是接下来要编写的猜数字游戏的主要函数\n我们可以先屏蔽掉 game() 来测试目前代码是否正确\n\n如果你能复现和我一样的运行框，说明目前编译的选择程序是没问题的\n接下来便是重头戏  如何编写我们的 game() 程序？\n这里我们要先引入一个 rand 函数：rand 是一个生成随机数字的函数 点击查看 rand 函数定义\n\n从定义我们可以得知，rand 能生成的是 0 到 RAND_MAX 的整数\n\n通过查询百度百科我们可以知道 RAND_MAX最小为7FFF\n使用 WIN10 自带的计算器中的程序员计算器，可以得知 7FFF(16 进制)即为 32767(十进制)接下来我们可以编译一个简单的程序查看 rand 会生成什么数字\nvoid game()&#123;\tint ret = 0;\tint guess = 0;\tret = rand()%100+1; // 生成 1-100 的随机数\tprintf(&quot;%d\\n&quot;, ret);&#125;\n程序很好的生成了 1-100 的数字，但是真的有这么简单吗？如果你再次运行程序，就会发现两次运行每次生成的结果都  一模一样  玩家即便是重新进行游戏，猜的还是上一次猜的数字，那怎么行？这里我们就要引入和 rand 相关的另外一个小知识点\n生成随机数起始点  如果你在上面提到的 rand 定义的网站继续往下滑，便能看到 srand\n\n这就是我们接下来要用到的函数\nvoid game()&#123;\tint ret = 0;\tint guess = 0;\tret = rand()%100+1;// 生成 1-100 的随机数\tsrand(1);\tprintf(&quot;%d\\n&quot;, ret);&#125;\n我们先添加 srand(1) 查看效果\n\n这时每次生成的随机数字变成统一的 42\n如果我们改成 srand(2) 的话\n会发现除了第一个数字是 42 之外，其他的数字都是 46这是因为 rand 函数需要另外一个随机数作为它生成随机数的起点  如果我们想要 rand 每次都能生成不一样的随机数的话  就必须用 srand(这里需要一个随机数)这不是套娃吗？我们需要随机数来生成一个随机数，程序不会死循环？那什么样的数字是会一直变化的呢？\n时间函数  这里又要引入另外一个 time 函数\nsrand((unsigned)time(NULL));\n\n\n同时我们需要了解  时间戳  的定义\n当前计算机的时间 - 计算机的起始时间(1970.01.01 00:00:00) = (xxxx) 秒 \n\n这个数字便是我们最易得的随时在变化的数字。我们同样可以在刚才查询 rand 定义的网站找到 time 的定义 [点我查看]\n\n我们把刚才是 srand(2) 改成如下格式，再次调试代码\n\ntime 函数需要引用头文件#include&lt;time.h&gt;\n\n\n这一次我们终于生成了完全随机的 1-100 的数字\n\n但是有另外一个问题，这个 game 函数是处在 main 函数循环语句中的\n\n也就是每次游戏的时候，game 函数都会  重新生成一个新的随机数\n玩家猜测的并不是一个固定的数字，那也永远猜不到答案\n所以我们应该把 srand 添加到 main 主函数中，这样每一次游戏只会生成一个  固定  的随机数，这才是我们最终想要的效果!\n\n接下来我们需要编写 if、else if 语句来实现游戏的猜测以及提示\nwhile (1)\t&#123;\t\tprintf(&quot; 猜数字:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;guess);\t\tif (guess&gt;ret)\t\t&#123;\t\t\tprintf(&quot;猜大了 \\n&quot;);\t\t&#125;\t\telse if (guess&lt;ret)\t\t&#123;\t\t\tprintf(&quot;猜小了 \\n&quot;);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;恭喜你，猜对啦 \\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125;\n同时我们要屏蔽掉刚才放入 game 函数中的 srand 以及会告诉玩家答案的 printf\n\n这样我们的猜数字游戏就大功告成了！来试玩一下吧！\n\n可以看到游戏正是我们需要的样子！玩家也可以重复游戏\n这篇小博客到这里也就结束了  第一次尝试的时候，手贱不小心按了 F5，写了一半的博客直接无了\n不管怎样，感谢你看到最后\n还请 dalao 们对我的博客进行指正\n如果能点个赞什么的就最好了\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】可变参数列表","url":"/posts/2099966635/","content":"本篇博客让我们来认识一下 C 语言学习过程中往往被忽略的  可变参数列表\n\n\n所谓可变参数，就是一个不限定参数数量的函数，我们可以往里面传入任意个数的参数，以达成某些目的。\n关联：C++11 可变模板参数\n1. 函数#include &lt;stdarg.h&gt;void va_start(va_list ap, last);type va_arg(va_list ap, type);void va_end(va_list ap);void va_copy(va_list dest, va_list src);\n\n1.1 va_startvoid va_start(va_list ap, last_arg);\n\n\nap: 这是一个 va_list 类型的对象，它用来存储通过 va_arg 获取额外参数时所必需的信息\n这个函数的作用是初始化 ap 变量，它与 va_arg 和 va_end 函数一起使用。\n\n\nlast_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。\n\n要想设置一个带可变参数的函数，函数声明是下面这样的\nvoid test(int a,int b, ...);\n\n这里出现的省略号就是可变参数的特征，而变量 b 就是 va_start 函数需要的last_arg\n1.2 va_argtype va_arg(va_list ap, type);\n\n这个函数的作用是来提取可变参数列表中的参数。注意，每次提取的参数是直接返回的，并没有放到变量 ap 中。\n每次对 va_arg 的调用都会修改 ap，以便下次调用时，返回下一个参数；推断参数的时候需要指定 type，如果当前参数类型和 type 不统一，就会发生  不可预知  的错误（man 手册里面说的）\nIf ap is passed to a function that uses va_arg(ap,type) then the value of ap is undefined after the return of that function.\n\n如果 ap 被传递给va_arg(ap,type)，则在该函数返回后，ap 的值未定义。\n1.3 va_endvoid va_end(va_list ap);\n\n每一个 va_start 都需要有一个配套的va_end，其用于清空 ap\n可以把他俩的关系理解为malloc/free，记得加上就行\n1.4 va_copy这个函数的作用是将可变参数列表从第二个参数 src 拷贝到第一个参数dest\nvoid va_copy（va_list dest，va_list src）;\n\n其也能够  初始化 dest。调用了va_copy 后，无须调用 va_start 初始化 dest，但va_end 还是需要的。\n2. 简单示例2.1 打印多个参数#include&lt;stdarg.h&gt;#include&lt;stdio.h&gt;int print(int num_args,...)&#123;    va_list ap;    va_start(ap,num_args);// 初始化可变参数    for(int i=0;i&lt;num_args;i++)    &#123;        printf(&quot;%d &quot;,va_arg(ap,int));    &#125;    printf(&quot;\\n&quot;);    va_end(ap);// 结束对 ap 的使用&#125;int main()&#123;    print(5,1,2,3,4,5,6,7,8,9);    return 0;&#125;\n\n运行该函数，会打印如下结果\n$ ./test1 2 3 4 5 \n\n这就表明了，...省略号之前的参数，和 va_arg 返回可变参数其实是没有关系的。\nint print(int num_args,...)&#123;    va_list ap;    va_start(ap,num_args);// 初始化可变参数    for(int i=0;i&lt;8;i++)    &#123;        printf(&quot;%d &quot;,va_arg(ap,int));    &#125;    printf(&quot;\\n&quot;);    va_end(ap);// 结束对 ap 的使用&#125;int main()&#123;    print(5,1,2,3,4,5,6,7,8,9,10);    return 0;&#125;\n\n即便在最后都没有使用 num_args，也不会影响结果的正确性。va_start 需要这个参数，其实是用来标识可变参数的起点。\n$ ./test1 2 3 4 5 6 7 8 \n\n2.2 多参数求和#include&lt;stdarg.h&gt;#include&lt;stdio.h&gt;// 采用可变参数，第一个参数用于标识参数数量int sum(int num_args, ...)&#123;   int val = 0;   va_list ap;   int i;   va_start(ap, num_args);   for(i = 0; i &lt; num_args; i++)   &#123;      val += va_arg(ap, int);   &#125;   va_end(ap);    return val;&#125;void test1()&#123;    printf(&quot;10、20 和 30 的和 = %d\\n&quot;,  sum(3, 10, 20, 30) );    printf(&quot;4、20、25 和 30 的和 = %d\\n&quot;,  sum(4, 4, 20, 25, 30) );&#125;\n\n运行如下\n$ ./test10、20 和 30 的和 = 604、20、25 和 30 的和 = 79\n\n3. 利用可变参数实现 log 类  现在有了可变参数，我们就可以接用这个参数来进行日志的打印了\n#pragma once#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;cstdarg&gt;#include &lt;cassert&gt;#include &lt;cstring&gt;#include &lt;cerrno&gt;#include &lt;stdlib.h&gt;#define DEBUG 0#define NOTICE 1#define WARINING 2#define FATAL 3const char *log_level[]=&#123;&quot;DEBUG&quot;, &quot;NOTICE&quot;, &quot;WARINING&quot;, &quot;FATAL&quot;&#125;;// 采用可变参数列表void logging(int level, const char *format, ...)&#123;    assert(level &gt;= DEBUG || level &lt;= FATAL);    char *name = getenv(&quot;USER&quot;);// 获取环境变量中的用户（执行命令的用户）    char logInfo[1024];    // 获取可变参数列表    va_list ap; // ap -&gt; char*    va_start(ap, format);    vsnprintf(logInfo, sizeof(logInfo)-1, format, ap);    va_end(ap); // ap = NULL    // 根据日志等级选择打印到 stderr/stdout    FILE *out = (level == FATAL) ? stderr:stdout;    // 格式化打印到文件中    fprintf(out, &quot;%s | %u | %s | %s\\n&quot;, \\        log_level[level], \\        (unsigned int)time(nullptr),\\        name == nullptr ? &quot;unknow&quot;:name,\\        logInfo);&#125;\n\n3.1 vsnprint作用：使用 vsnprintf() 用于向一个字符串缓冲区打印格式化字符串，且可以限定打印的格式化字符串的最大长度。\n此函数需要 C99 或者 C++11 及以上版本才能支持。\nint vsnprintf(char* sbuf, size_t n, const char* format, va_list arg);\n\n\n第一个参数：目标缓冲区（字符数组）\n第二个参数，限定最多打印到缓冲区的字符数量为 n-1 个（留位置给\\0）\n第三个参数，打印的格式（如%d:%s）\n第四个参数，可变参数 arg，需要用 va_start 初始化\n\n返回：成功打印到 sbuf 中的字符的个数，不包括末尾追加的 \\0。如果格式化解析失败，则返回负数。\n用这个函数，就能把我们的来源字符串给输入到缓冲区 char logInfo[1024]; 中\n3.2 fprintf使用 fprintf，将 printf 的输出打印到指定文件中；用法和printf 是一样的\nint fprintf(FILE *stream, const char *format, ...);\n\n这样是为了区分stderr/stdout。同时添加上执行命令的用户信息，以及当前的时间戳\nfprintf(out, &quot;%s | %u | %s | %s\\n&quot;, \\    log_level[level], \\    (unsigned int)time(nullptr),\\    name == nullptr ? &quot;unknow&quot;:name,\\    logInfo);\n\n3.3 运行结果int main()&#123;    logging(DEBUG, &quot;socket create success: %d&quot;, 114514);    logging(FATAL, &quot;socket:%s:%d&quot;, strerror(errno), 11234);    return 0;&#125;\n\n$ ./testDEBUG | 1675322313 | muxue | socket create success: 114514FATAL | 1675322313 | muxue | socket:Success:11234\n\nThe end对于可变参数的简单介绍就到这里！基本的使用能看懂久 OK 啦！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】goto 语句","url":"/posts/3474605456/","content":"这是初识 c 语言的第五篇文章了\n虽然看的人不多，但我不会放弃哒\n毕竟这也是给我自己的一个学习记录，不想写日记就用这个代替了！\n\n\ngoto 语句c 语言中提供了可以随意使用的 goto 语句和标记跳转的标号\n理论上来说，goto 语句没什么必要，因为我们可以用 whlie 等循环语句来替代它\n\ngoto 是类循环语句，其本身是关键字\n\n\ngoto 语句在某些场景下用的到，如终止程序在某些深度嵌套的结构的处理过程，例如一次跳出两次或者多层的循环\n这种情况下 break 达不到我们的目的。break 只能从最内层循环退出到上一层的循环\n\ngoto 语句真正适合的场景如下：\nfor(...) \tfor(...)\t&#123;\t\tfor(...)        &#123;        \tif(disaster)         \t\tgoto error;          &#125;    &#125;\t...error:     if(disaster)// 处理错误情况\n\n用下面这个例子来给大家简单地演示一下 goto 的作用\n#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;hello world\\n&quot;);\tgoto again;\tprintf(&quot; 你好 \\n&quot;);again:\tprintf(&quot;hehe\\n&quot;);\treturn 0;&#125;\n\n结果如下\n\n可以看到，程序跳过了 printf(“你好 \\n”);，直接到下一步打印 hehe\n代码的执行流程图如下：\n\n其实 goto 的作用方式非常容易理解，即：走到 again\n这时候程序会直接跳到 again 后面的代码，不管这个 again 是在 goto 的  后面还是前面\n需要注意的是，again 在前面必须在特定的循环 \\ 条件代码中使用\n如果你将上述的代码改成这样\nint main()&#123;again:    printf(&quot;hello world\\n&quot;);\tgoto again;\tprintf(&quot; 你好 \\n&quot;);\tprintf(&quot;hehe\\n&quot;);\treturn 0;&#125;\n\n那么代码就会一直打印 hello world，进入死循环\n那 goto 就不是没有必要了，是毫无意义\n\n想知道 goto 在前面的时候要怎么书写代码吗\n且听下回分解\n（因为这个代码是个  关机小程序，我感觉重新写一篇博客会更好）\n点个赞再走吧，求求了！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C 语言】猜数字游戏","url":"/posts/2820557607/","content":"函数是什么?数学中我们常见到函数的概念，但是你了解 C 语言中的函数吗？维基百科中对函数是如下定义的。\n\n可以说  函数 function是计算机变成语言中非常重要的一环。如果我们想学好 c 语言，就必须学会如何使用  库函数 ，以及如何创建 自定义函数。\n回溯  在我的 【猜数字游戏】 博客中，已经有讲述过如何查询库函数的定义。在上一篇 【传值调用和传址调用】 中也有与自定义函数相关的内容。本篇博客将更细致地向初学 c 的伙伴们分享如何使用库函数。\n库函数  库函数，是 c 语言库中已经包含了的函数。这些函数的作用不一，但他们都有一个共同点——所有人都用的上。\n\n当你写出一串代码，肯定会想知道它运行的结果，这时候要用到 printf 来打印  大家第一个学习的 hello world 代码中就用到了 printf 库函数\n在编程过程中我们需要频繁地做字符串的拷贝 strcpy\n\n既然所有人都用的上，那为什么不让这些函数变成编程语言中预设的功能，让后来者更方便的使用编程语言呢？这样效率倍增，可移植性和易用性也大大增强，何乐而不为。库函数由此诞生\nC 语言常用的库函数\nIO 函数\n字符串操作函数\n字符操作函数\n内存操作函数\n时间 &#x2F; 日期函数\n数学函数\n其他库函数\n在 【猜数字游戏】 中使用到的 time 函数是时间函数的一种\n\n\n\n接下来我用两个函数的具体案例，和大家分享如何查找库函数定义以及如何尝试使用库函数  分别是 strcpy 函数 和 memset 函数\n查询库函数定义  在这里给大家分享两个超棒的网站！\n\ncppreference 中文\ncplusplus 英文\n\n如果要查询库函数定义，cplusplus 是我们的不二之选。它虽然只有英文，但是这难不倒我们代码人，实在不行就网页翻译一下嘛！\n夹带私货时间  如果你用的是 chrome 或者微软最新的 edge 浏览器，可以尝试安装侧边翻译这个插件  非常好用，强力推荐！\n\nmemset 函数  打开 cplusplus，输入我们需要查询的函数\n\n看不懂？没关系。只要了解下面几个简单的单词，我们就能尝试去读库函数的定义了\n\nfunction →函数\nParameters →参数\nReturn Value →返回值\nExample →例子\n\n在页面的左边我们可以看到函数的头文件\n\n需要注意的是，是 c++ 语言里的头文件，而左边的 &lt;string.h&gt; 才是我们 c 语言要用的头文件\n\ncplusplus 真正强大的地方，在于它可以让你直接在网页端编辑给出的代码例子\n\nmemset 其实是由两个单词组成的，memeory 内存 + set 设置\n\n读函数定义的文档的时候，最好是  逐字解读，不要整句翻译。\n\n注意每个函数下面绿色的这一行  以 memset 为例，void* 表示它是指针变量，int 表示整型，size_t 表示大小\n\nFill block of memory 填充内存块\nSets the first num bytes 设置前 num 个字节\nSets the first num bytes of the block of memory 设置内存块中的前 num 个字节\npointed by ptr 由 ptr 指引的\nto the specified value 设置成特殊的 value\n\n\n连起来就是：\n\n把由 ptr 指引的内存块的前 num 个字节设置成特殊的 value\n\n让我们继续解读\n\n\nptr 要被填充的内存块的 pointer 指示器\nvalue 要被设定的特殊值，它是 int 整型\nnum 有多少字节的内存要被设定成 value\nsize_t 无符号整型\n\n读到这里，关于 memset 的定义我们就能大概了解了  接下来就要进入实践了\n#include&lt;string.h&gt;//memset 头文件#include &lt;stdio.h&gt;//printf 头文件int main()&#123;\tchar arr[] = &quot;hello world&quot;;\tmemset(arr, &#x27;*&#x27;, 5);\tprintf(&quot;%s\\n&quot;, arr);\treturn 0;&#125;\n在使用 memset 的时候，我们遵循定义中的 (void * ptr, int value, size_t num)方式\nmemset(arr, &#x27;*&#x27;, 5);\n\narr 是我们要更改的内容\n‘*’ 指我们把 arr 中的内容最终改成  ‘*‘\n5 表示我们想更改 5 个字符的内容\n用 printf 打印最终更改后的结果\n\n运行的结果如下图所示\n\n可以看到，hello world 中的前五个字符，也就是 hello 被改成了 *****和 memset 的定义的描述完全一致！\n怎样，是否有点小激动？（反正我当时学到这里的时候是有的）让我们继续！\nstrcpy 函数  比起 memset 函数，strcpy 函数的使用频率更高  我们同样在 cplusplus 中查询 strcpy 函数的定义\n我们依旧用上述说的  逐步解读法  来查阅 strcpy 的定义\n\nCopies the C string 拷贝内容\npointed by source 由 source 指示的的内容\ninto the array pointed by destination 到目标数组中\n\n\n拷贝由 source 指示的内容到目标数组中\n\n照样实践一下\n#include &lt;string.h&gt;//strcpy 函数头文件#include &lt;stdio.h&gt;int main()&#123;\tchar arr1[] = &quot;bit&quot;;\tchar arr2[20] = &quot;##########&quot;;\tstrcpy(arr2, arr1);\tprintf(&quot;%s\\n&quot;, arr2);\treturn 0; &#125;\n(arr2, arr1)  其中 arr2 是我们的目标，arr1 是我们要拷贝的内容\nstrcpy(arr2, arr1);\n\n运行结果如下\n\n当你看到这里的时候，肯定会有和我一样的疑惑：为什么拷贝到 2 中的内容只有 bit 三个字节，但是后续的 ####### 没有打印出来呢？这里就涉及到转义字符里面的内容了\n字符结束标志 \\0 是字符串的结束标志，默认跟在我们输入的字符后面\n\n“bit” 字符实际为 ”bit\\0“\n\n打印的时候遇到”\\0“会自动停止\nchar arr1[] = &quot;bit&quot;;char arr2[20] = &quot;##########&quot;;              // bit\\0 遇到 \\0 认为字符串结束，所以不打印后面的 #\n与 strcpy 长得很像的还有另外一个库函数 strlen    strcpy - string copy - 字符串拷贝    strlen - string length - 字符串长度有关\n对于 strcpy 函数 和 memset 函数 的介绍到这里就结束了\n结语  到这里，对于查询库函数以及使用库函数的方法应该已经很清晰了（自我感觉  ） 希望对大家有所帮助 c 语言新人，有所纰漏在所难免，欢迎各路 dalao 无情指正！\n纯手打，4k 多字，今天效率比昨天高，2 小时就搞定了  点个赞再走吧，谢谢大家！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】关机程序","url":"/posts/2689863829/","content":"不知不觉就摸了几天鱼，及时醒悟，开始码之前在 goto 语句中提到的  关机小程序\n\n\n@[TOC]\n关机程序  在介绍这个程序之前，我们要了解 win10 系统的一些系统指令\nwindows 系统指令  用 win+r 打开系统的运行框（这个从 xp，win7 到 win10 都有）\n在弹出的运行框中输入shutdown -s -t 7200（后面跟着的数字是时间，单位是秒）\n\n\n系统将在右下角提示你定时关机的时间，届时还会在定时关机时间提前 60s 提醒你要关机\n想要取消定时关机，可以在运行中输入shutdown -a\n\n\n定时关机就被取消了\n了解了这个之后，我们就要知悉 C 语言中可以帮我们在系统的运行中输入指令的函数\nsystem 函数  首先，让我们在之前和大家分享过的网站 cplusplus 上查询该函数的定义\n\n简单地说，这个函数就是来帮我们 execute 执行系统命令的。\n同时，cpluscplus 网站告诉我们：这个函数的头文件是stdlib.h\n先写一个简单的关机程序来实操一下 system 函数\n#incldue &lt;stdlib.h&gt;int main()&#123;\tsystem(&quot;shutdown -s -t 60&quot;);//system() - 执行系统命令的\treturn 0;&#125;\n\n\n循环指令和关机程序  接下来让我们用一个有点损的方式写一个关机程序\n运行这个程序后，只有输入“我是🐖”才能取消关机\nint main()&#123;\tchar input[20] = &#123; 0 &#125;;\tsystem(&quot;shutdown -s -t 60&quot;);\twhile(1)\t&#123;\t\tprintf(&quot; 请注意，你的电脑将在 1 分钟内关机，如果输入: 我是猪，就取消关机 \\n 请输入 &gt;:&quot;);\t\tscanf(&quot;%s&quot;, input);\t\tif (strcmp(input, &quot; 我是猪 &quot;) == 0)// 头文件 #include &lt;string.h&gt;\t\t&#123;\t\t\tsystem(&quot;shutdown -a&quot;);\t\t\tbreak;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n这里我们还用到了 strcmp 函数，用于比较你输入的字符和“我是🐖”是否一致\n\n要注意“&#x3D;&#x3D;”不能用于比较字符\n\n这里用到的是十分基础的 while+if 的语句组合。\n运行结果如下\n\n\n输入我是🐖后注销会取消，如果输入错误会再次弹出提示\ngoto 语句写关机程序  当然，如果看过上一篇的你肯定知道这篇博客的重点是 goto\n主要是演示一下 again 在 goto 所在代码行之前的情况\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar input[20] = &#123; 0 &#125;;\tsystem(&quot;shutdown -s -t 60&quot;);// 头文件 &lt;stdlib.h&gt;again:\tprintf(&quot; 请注意，你的电脑将在 1 分钟内关机，如果输入: 我是猪，就取消关机 \\n 请输入 &gt;:&quot;);\tscanf(&quot;%s&quot;, input);\tif (strcmp(input, &quot; 我是猪 &quot;) == 0)// 比较两个字符 -strcmp() 头文件 &lt;string.h&gt;\t&#123;\t\tsystem(&quot;shutdown -a&quot;);\t&#125;\telse\t&#123;\t\tgoto again;\t&#125;\treturn 0;&#125;\n\n运行的结果和上面的 whlie 语句一样，这里就不截图了\n这个代码可以用来整蛊你的损友，或者在春节的时候阻止熊孩子“借”用你的女朋友（指电脑）\n询问框里的问题和对应的回答都可以随意更改，当然你也可以把时间改成 10 秒让人压根来不及反应\n如果你用的是 devc++，每次运行代码的时候都会自动生成一个 exe 文件\n\n把 logo 改改，就能去糊弄人了\n（话说 vs2019 要怎么生成 exe 啊，得去研究一下）\n郑重警告！\n\n娱乐一下即可\n\n若使用该程序导致电脑关机且未保存  重要文件\n\n\n本博主不负任何责任！\n点个赞再走呗，谢谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C 语言】排序三个输入的数字","url":"/posts/3460916609/","content":"如何将输入的 3 个数字排序并打印出来@[TOC]\n承接上篇博客中输出数组内元素最大值的内容\n本篇博客向大家分享如何将我们输入的三个数字进行大小排序并打印出来\n1.scanf 函数int main()&#123;\tint a = 0;\tint b = 0;\tint c = 0;\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);&#125;\n\n既然需要输入，那就要用到 scanf 函数来接受我们输入的数字\n\n要使用指针变量，因为这里的 scanf 需要改变我们的 a，b，c\nscanf 的头文件是 &lt;stdio.h&gt;\n\n2.tmp 盒子  相信大家在自己的学习中已经接触过使用 tmp 来进行大小比较的代码了\n什么？没有？\n那也没关系，基本实现的原理易懂的很！\nif (a &lt; b)\t&#123;\t\tint tmp = a;\t\ta = b;\t\tb = tmp;\t&#125;\n\n\n把 a 的值赋给 tmp\n因为 a 小于 b，所以我们让 a 等于更大的值\n再使用 tmp 把原来是 a 的值赋给 b\n\n这样就写好了一个大小比较和交换的语句了\n我们只需要 CTRL+C 然后 +V\n稍微改改里面的 abc\n就能写出下面的完整代码\n#include&lt;stdio.h&gt;int main()&#123;\tint a = 0;\tint b = 0;\tint c = 0;\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\tif (a &lt; b)\t&#123;\t\tint tmp = a;\t\ta = b;\t\tb = tmp;\t&#125;\tif (a &lt; c)\t&#123;\t\tint tmp = a;\t\ta = c;\t\tc = tmp;\t&#125;\tif (b &lt; c)\t&#123;\t\tint tmp = b;\t\tb = c;\t\tc = tmp;\t&#125;\tprintf(&quot;%d&gt;%d&gt;%d&quot;, a, b, c);\treturn 0;&#125;\n\n运行一下\n\n这里需要注意，我们输入数字的时候需要用空格隔开两个数字\n因为这串代码实现的是从大到小排列\n所以我们可以打印的时候在每个数字之间加个 &gt; 号\n这里显示的内容和下面这行代码 %d 中间的内容是一致的\nprintf(&quot;%d&gt;%d&gt;%d&quot;, a, b, c);\n\n比如我把中间的 &gt; 改成 #号，打印出来也是一致的\n\n注意的点  在编写这个 3 个数字比较的代码的时候，我们要先将 a 和 b、c 比较，再比较 b 和 c下面的这个代码是一个错误的代码\nif (a &lt; b)&#123;\tint tmp = a;\ta = b;\tb = tmp;&#125;if (b &lt; c)&#123;\tint tmp = b;\tb = c;\tc = tmp;&#125;if (a &lt; c)&#123;\tint tmp = a;\ta = c;\tc = tmp;\n\n因为我们需要先确定 a 里面装的是最大的那个数字，然后才能让 b 和 c 比较决出“季军”如果这样说你还是没太明白，可以尝试将这串代码输入 vs 编译器，用 ctrl+f10 调试，查看运行一个 if 语句之后 a，b，c 的赋值的变化\n\n结语  这串代码如果继续复制粘贴的话可以实现不止 3 个数字的大小排列并打印\n不知道能不能用自定义函数实现这个功能？\n点个赞再走呗，万分感谢！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【Artalk】在 wiki js 站点上使用 Artalk 评论系统","url":"/posts/3908173775/","content":"本篇博客将教您如何在 wiki js 站点上使用 artalk 评论系统\n\n\n[TOC]\n1. 介绍1.1 wiki js\nhttps://github.com/requarks/wiki/\n\nwiki js是一个开源的 wiki 站点，可以  在线编辑  页面。\n页面以 markdown 编辑，同时支持富文本格式；因为其用 git 来管理提交历史，且在线编辑不需要用户知道如何操作 git，所以非常适合  多人协作  撰写文档\n\n如果你只是想要一个博客站点，没有多人协作需求，那么 hexo 会更合适您\n\n共享文档（如金山文档）的提交历史大多数都不够详细，虽然有  插入 / 删除  历史，但是其没有标明上下文，你需要猜他是在文档的啥地方改了东西，非常不方便！\ngit 是一个版本管理软件，能清楚地知道 xx 用户修改了 xx 文档的 xx 行，并能看到  修改之前和修改之后的提交对比。这部分就不赘述了\nwiki js 还有很棒的一点就是，你可以设置一个 git 仓库作为文档的备份，其会定时把整个站点的所有页面（包括图片）都上传到这个 git 仓库里面。即便站点因为某些原因出问题了，我们还有 git 仓库的备份😁\n\nwiki js 的安装参考  官方文档 ，建议用 docker 部署，方便的很，直接对着敲命令就行了。进入系统创建管理员账户后，可以在设置的local 里面找到语言选择，下载中文语言包即可改成中文页面！\n\n\nWik js自带了评论系统 ，也支持 markdown 评论，但是它连最基础的 回复评论  都不支持，实在是有些捉急，所以才需要配置一下 artalk 来作为评论系统\n1.2 artalk\nhttps://artalk.js.org/\n\nartalk 同样是一个开源的评论系统，作者写 v1 的时候还是一名高中生（人比人气死人，我太菜了）\n咳咳，这不是重点！\n\nartalk 支持 markdown 发送评论，支持发送表情，还支持上传图片！作为 wikijs 的评论系统再合适不过了~\nemm，其实还有另外一个原因，那就是 wiki js 目前支持的 3 个第三方评论系统，似乎只有 artalk 是免费的😥\n\n2. 安装 artalk 后端 2.1 docker-compose 安装 基本安装方式参考官方文档，个人更加推荐用 docker compose 部署\n\nhttps://artalk.js.org/guide/deploy.html#docker-compose-%E9%83%A8%E7%BD%B2\n\n刚开始我拉取镜像的时候，一直出现 505 错误（添加了镜像源）后续在镜像后面加上  最新的版本号  才正常拉取了镜像\nversion: &quot;3.5&quot;services:  artalk:    container_name: artalk-go    image: artalk/artalk-go:2.3.0    ports:      - 8080:23366    volumes:      - ./data:/data\n\n创建好 docker-compose.yaml 文档后，用下面的命令运行\ndocker-compose up -d\n\n查看你服务器的 8080 端口（记得在云服务器防火墙里面开放端口）如果能打开下面的后端页面，那就是 ok 了\n\n2.2 开放管理员账户  默认情况下，管理员账户是关闭的，我们需要关闭容器后，修改配置文件开放一个管理员账户\ndocker-compose stop\n\ncd 进入 data 目录（这里的 data 目录是你在 docker compose 中映射的本地路径，默认应该就在 docker-compose.yaml 所在路径下会出现一个 data 文件夹）\n可以看到一个 artalk-go.yml 文件，我们需要修改的就是这个文件，找到下面的字段，对应修改后保存\n\n关于密码的部分参考文档 https://artalk.js.org/guide/backend/multi-site.html#%E7%AE%A1%E7%90%86%E5%91%98%E9%85%8D%E7%BD%AE\n\n\ndocker-compose up -d\n\n重新启动容器，用刚刚设置好的账户登录；后台的管理页面可以修改很多配置，我们不需要动配置文件了！\n2.3 配置 sslwiki js 必须要用 ssl 和 https 才能正常使用 artalk，我尝试了  公网 IP: 端口  的方式，它认不出来😥\n所以我们需要在 artalk 的后台配置一下 ssl（记得点界面右下角的应用）\n\n再次用域名打开页面，此时就没有报错了\n\n备注：我是用 frp 穿透到香港来映射域名的，所以 ssl 还需要在 frp 里面设置一下，请根据您自己的情况配置 ssl！\n2.4 图片上传  如果想让用户能上传图片，还需要做一些小操作；首先是启用图片上传（记得点界面右下角的应用）\n\n然后需要去后台在 data 目录下创建一个 artalk-img 文件夹（我刚开始没有创建这个文件夹的时候，没有办法正确上传图片）\n回到 wiki js 的界面测试一下，图片上传成功\n\n2.5 邮箱提醒  避免有老哥之前没有用过 stmp 服务，这里也简单说一下吧\n可以注册一个网易的 163 或者 126 邮箱，找到设置里面会有一个 stmp\n\n进入后，先把这两个服务都开启\n\n再点击这里新增授权密码，会弹出来一个二维码码让你用手机给一个号码发个短信，然后就会出现一个授权码，记住这个授权码\n\n回到 artalk 的后台进行如下配置\n\n这样就 OK 了，找朋友发条评论并  回复，测试一下邮箱提醒能否正常使用吧！\n3.wiki js 使用  这部分就很傻瓜了，直接用起来就可以了\n3.1 artalk 创建站点artalk 虽然会有一个默认站点，但是那个 wiki js 不一定能正常使用，所以我们需要自己创建一个站点\n\n需要填写站点名称和 url，名称建议用英文，避免编码问题\n\n然后为了避免错误，还可以在设置里面添加一下可信域名\n\n3.2 wiki js 使用  进入 wiki js 的管理页，找到评论，选择 artalk\n\n填入域名和在 artalk 里面配置的站点名字后，点击应用\n回到 wikijs 的页面，此时就可以看到 artalk 的界面啦！\n\n3.3 bug我使用的时候遇到了评论框飞到顶栏上面的 bug，已经在 wiki 的仓库中发评论了\n\nhttps://github.com/requarks/wiki/discussions/6015\n希望能尽快修复这个 bug~\n未完待续  后续有啥问题，我会在这里补充的~\n","categories":["docker真好玩"],"tags":["wikijs","Docker"]},{"title":"【Linux】浏览器写代码！部署 code-server 远程 vscode 网页","url":"/posts/2203891398/","content":"部署 code-server 远程 vscode 网页，在浏览器上写代码！\n\n\n参考文档 https://developer.aliyun.com/article/876967#slide-7\n1. 什么是 code-server？注意，这不是在 linux 系统上安装 vscode 软件（和 windows 一样的 vscode 客户端）\n\n开源仓库 https://github.com/coder/code-server\n\ncode-server 是一个社区项目（非微软官方）其作用是在你的 linux 主机（云服务器）上部署一个可以在  浏览器  上访问的 vscode 页面，类似官方的vscode.dev\n\n微软官方推出的 vscode 网页版 https://vscode.dev/ \n它可以通过浏览器的 api 访问你  电脑上的本地文件，此时浏览器就是一个 vscode 客户端\n\n\ncode-server 同理，其访问的是你 linux 服务器上的文件，作用类似于 vscode 插件 remote ssh，让我们可以用浏览器，在任何电脑、 平板  上进行远程开发，无须下载 vscode 客户端或者 ssh 软件！\n\n1.1 官方的 vscode-server?微软官方确实有一个 vscode-server，在官网可以下载。我测试了之后，发现它是打了一个隧道，通过 vscode.dev 的子域名访问，会转发到你的主机上。\n\n在我这里的测试，发现压根连不上微软的服务器。想想其实也很正常，因为 vscode-server 的文档页面连中文都没有，再加上微软的服务器，国内用不了也是意料之中\n2. 安装 2.1 下载安装包 截至本文创作时间23-03-09，code-server 的最新版本是4.10.1，可以用下面的命令获取到 linux 下的安装包\nwget https://github.com/cdr/code-server/releases/download/v4.10.1/code-server-4.10.1-linux-amd64.tar.gz \n\n如果上面这个命令你无法访问，可以去 github 的 releases 里面手动下载安装包\n\nhttps://github.com/coder/code-server/releases/\n\n我的系统是 amd64，即 x86 架构。在 github 里面也是找 linux amd64 的包进行安装\n$ uname -aLinux 1c2261732150 5.10.120 #0 SMP Fri Jan 6 08:05:47 2023 x86_64 x86_64 x86_64 GNU/Linux\n\n如果你使用的是树莓派等设备，请用 uname -a 确认你的系统架构，并下载对应的包\n\ngithub 的 release 下载慢，可以用下面这个网站加速（用迅雷下，速度起飞）\nhttps://doget.nocsdn.com/#/\n\n下载完成后，将压缩包用 xftp 传输到服务器上\n2.2 解压  使用下面的命令解压刚刚下载好的压缩包\ntar -zxvf code-server-4.10.1-linux-amd64.tar.gz\n\n给解压出来的文件夹改个短名字 vsc\nmv code-server-4.10.1-linux-amd64 vsc\n\ncd 进入这个文件夹\ncd vsc\n\nls -l，基本文件如下\ntotal 792drwxr-xr-x   8 muxue muxue   4096 Mar  4 12:26 .drwx------   6 muxue muxue   4096 Mar  9 22:42 ..drwxr-xr-x   2 muxue muxue   4096 Mar  4 12:26 bindrwxr-xr-x   3 muxue muxue   4096 Mar  4 12:26 lib-rw-r--r--   1 muxue muxue   1084 Mar  3 17:13 LICENSEdrwxr-xr-x 243 muxue muxue  12288 Mar  4 12:26 node_modules-rw-r--r--   1 muxue muxue 480100 Mar  4 12:26 npm-shrinkwrap.jsondrwxr-xr-x   5 muxue muxue   4096 Mar  3 17:13 out-rw-r--r--   1 muxue muxue   5235 Mar  4 12:24 package.json-rwxr-xr-x   1 muxue muxue   4877 Mar  3 17:13 postinstall.sh-rw-r--r--   1 muxue muxue   3056 Mar  3 17:13 README.mddrwxr-xr-x   3 muxue muxue   4096 Mar  3 17:14 src-rw-r--r--   1 muxue muxue 180977 Mar  3 17:13 ThirdPartyNotices.txtdrwxr-xr-x   2 muxue muxue   4096 Mar  3 17:14 typings-rw-r--r--   1 muxue muxue  76688 Mar  4 12:26 yarn.lock\n\n直接进入 bin 文件夹，我们需要用的可执行文件就在里头\n$ lscode-server\n\n这个 code-server 就是我们要的可执行文件\n2.3 启动 code-serverexport PASSWORD=&quot; 配置一个密码 &quot;code-server --port 8888 --host 0.0.0.0 --auth password\n\n上面这个命令，启动之后，会创建一个端口为 8888 的 web 服务，此时使用 ip:8888 的方式，应该就可以访问到你的 code-server 服务了！\n[2023-03-09T14:52:07.081Z] info  Wrote default config file to ~/.config/code-server/config.yaml[2023-03-09T14:52:07.516Z] info  code-server 4.10.0 ac1fba8bde0c3f29bf6bc27d3d7d75cb2390a7c2[2023-03-09T14:52:07.517Z] info  Using user-data-dir ~/.local/share/code-server[2023-03-09T14:52:07.532Z] info  Using config file ~/.config/code-server/config.yaml[2023-03-09T14:52:07.532Z] info  HTTP server listening on http://0.0.0.0:8888/[2023-03-09T14:52:07.532Z] info    - Authentication is enabled[2023-03-09T14:52:07.532Z] info      - Using password from $PASSWORD[2023-03-09T14:52:07.532Z] info    - Not serving HTTPS\n\n出现下面的页面，那就是安装成功了！输入你刚刚设置的密码，就可以像使用 vscode 一样使用 code-server 了！\n\n2.4 配置文件  首次启动了之后，会在你的用户路径下生成一个 .config/code-server 文件夹，里面有一个config.yaml\n$ ls .config/code-serverconfig.yaml\n\n打开这个文件，可以在里面配置 code-server 的密码，以及 https 访问。其余的配置项我还没有关注过，可以去看看 github 上的文档\nbind-addr: 127.0.0.1:8080auth: passwordpassword: 64f1881b805917a449d80874cert: false\n\n默认的密码巨长，改成你自己的即可。在这里还可以修改默认绑定的 ip 和端口，后续启动 code-server，就不需要手动指定了，直接运行即可\n./code-server\n\n2.5 tmux 后台运行\nnohup 运行 code-server 有一点问题，所以要用 tmux\n\n如果没有这个软件，先安装\nsudo yum install tmux\n\n创建一个新会话，你可以理解为这是一个脱离于 bash 的独立 shell 页面，即便当前 bash 退出了，code-server 也不会退出\ntmux new -s vscode_online\n\n开启新会话后，进入 vsc 的 bin 目录，启动 code-server，命令是不变的\n./code-server\n\n\n随后直接关掉当前 bash，此时就已经实现了 code-server 的后台运行\n# 接入会话tmux a -t vscode_online# 结束会话tmux kill-session -t vscode_online\n\n\n\n3. 一些问题 3.1 nginx 转发遇到 1006 错误 我在采用 nginx 转发的时候，遇到了这个问题\n\n个人猜测，这大概率是因为我在 config.yaml 里面配置了 code-server 的 https 导致的\ncert: false # 关闭 https\n\n将 cert 修改回 false，再次测试，发现还是有这个问题！\n\n实际上，如果你进行了 nginx 转发，并不需要配置 code-server 的 https\n保持默认的 http 即可\n\n\n后来发现是我的 nginx 转发设置有问题，正确的转发配置如下\nlocation / &#123;\tproxy_pass   http://127.0.0.1:8888;\tproxy_set_header Host $host;\tproxy_set_header Upgrade $http_upgrade;\tproxy_set_header Connection upgrade;\tproxy_set_header Accept-Encoding gzip;&#125;\n\n下面给出一个 nginx 的 https 的完整配置文件！\nserver &#123;    listen 443 ssl;    server_name  www.example.com;  # 域名    # 注意证书文件位置，是从 /etc/nginx/ 下开始算起的    ssl_certificate cert/example.com.crt;     ssl_certificate_key cert/example.com.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    client_max_body_size 1024m;    location / &#123;       \tproxy_set_header Host $host;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection upgrade;        proxy_set_header Accept-Encoding gzip;        # 当下是直接用 yum 安装的 nginx，可以直接用本地 ip 访问        # 如果是 docker 安装的 nginx，需要改为公网 ip        proxy_pass http://127.0.0.1:8888;    &#125;&#125;# 强制重定向 http -&gt; httpsserver &#123;    listen 80; # 监听 80 端口    server_name  www.example.com;  # 域名    # 把 http 的域名请求转成 https    return 301 https://$host$request_uri; &#125;\n\n3.2 C&#x2F;C++ 插件  由于 code-server 是一个第三方项目，所以一些官方的插件（如 pylance）直接在 code-server 的插件商店里面搜是没有的\n我们需要去微软的 vscode 官网上下载插件的 VSIX 文件，使用本地文件的方式进行安装\n\nhttps://marketplace.visualstudio.com/VSCode\n\n\n不过，pylance 用这个办法依旧无法安装。看来有些插件只有官方的 vsc 才能安装\n3.3 本地文件  如果你用过 vscode 的 remote-ssh 插件连过你这个服务器，用户目录下面会有两个文件夹\n.vsc.vscode-server\n\n这两个文件夹是 vscode 的插件 remote-ssh 生成的，和本文安装的 code-server 无关！\n3.4 tmux 常用语句tmux new　　创建默认名称的会话（在 tmux 命令模式使用 new 命令可实现同样的功能，其他命令同理，后文不再列出 tmux 终端命令）tmux new -s mysession　　创建名为 mysession 的会话tmux ls　　显示会话列表tmux a　　连接上一个会话tmux a -t mysession　　连接指定会话 mysessiontmux rename -t s1 s2　　重命名会话 s1 为 s2tmux kill-session　　关闭上次打开的会话tmux kill-session -t s1　关闭会话 s1tmux kill-session -a -t s1　　关闭除 s1 外的所有会话tmux kill-server　　关闭所有会话\n","categories":["差生文具多"],"tags":["Linux","vscode","CentOS"]},{"title":"【Nas】绿联安装 CentOS8 容器","url":"/posts/336198679/","content":"绿联安装 CentOS8 容器\n\n\n1. 创建容器  先在客户端安装容器，随后用 xshell 进入绿联的 ssh\n\n绿联如何  开启 ssh 参考视频 ；2023 年 11 月后，新版本的绿联直接把 远程调试  打开，给出的调试密钥就是 ssh 的密码。\n绿联的 ssh 端口是 922\n\n执行如下命令，以  特权模式  创建一个 centos 容器，并将容器内的 22 端口映射给主机的 22222 端口；如果你是希望在 centos 容器上进行网络编程开发，请多映射几个端口，以免到时候没办法访问项目的尴尬情况！\ndocker run -d \\\t-p 22222:22 \\\t--name centos \\\t--privileged=true \\\tcentos:latest \\\t/usr/sbin/init\n\n搞定了之后，进绿联客户端，停止容器运行，设置一个文件路径给容器内部，方便 docker 容器和 nas 资料互传（不设置也不是不行）\n\n注意，在客户端配置的时候，需要把所有能给的选项（-i -t 高级选项）全都勾上，避免 docker 安装的 centos 缺少权限；\n\n回到绿联的 ssh 终端，用下面的命令进入容器内部\ndocker exec -it centos /bin/bash\n\n你也可以用客户端里面的终端功能，但是那个太简陋了，不太好用。既然都已经能 ssh 连上绿联了，那完全没必要用客户端;\n当然，因为我们已经映射了 22 端口到绿联里面，所以你直接用 ssh 链接这个 22222 端口即可进入 docker 安装的 centos\nssh root@绿联的 IP -p 22222\n\n1.1 判断是否成功以特权模式安装systemctl \n\n执行此命令，看看是否有如下输出。如果没有，代表  没有成功  以特权模式安装。systemctl在 linux 中很常用，且开启容器的 ssh 也需要使用此命令！\n\n如果没能成功使用这个 systemctl  命令，请重试上面的步骤\n2. 更新软件docker 安装的 Centos 并没有虚拟机安装的那么完全，还需要我们进行软件源的配置操作\nyum update -y &amp;&amp; yum upgrade -y\n\n第一次执行此命令的时候，大概率会出现下面的报错（我在两个不同平台的 docker 里面启动的 centos 都遇到了这个问题）\nError: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist\n\n参考 Error: Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist 博客，用下面的命令解决这个问题\ncd /etc/yum.repos.d/\n\nsed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*\n\n随后执行如下命令。创建缓存\nyum makecache\n\n执行 makecache 后，系统会获取一些内容，让后我们重新指向如下命令\nyum update -y &amp;&amp; yum upgrade -y\n\n会进行一连串的更新，直到出现下面的 complete 窗口，代表成功！\n\n\n3.ssh 链接 3.1 安装 passwd 一个 linux 系统，不能 ssh 链接可不行，我们需要更新一下内容，实现 ssh 链接\nyum install passwd\n\n先安装 passwd 命令，设置 root 的密码\npasswd\n\n会弹出来让你输入密码，盲敲就行\n3.2 安装 vim 和 openssh用下面的命令安装 vim 和 openssh\nyum install vim openssh-server openssh-clients -y\n\n安装完毕后，修改 ssh 的配置文件（vim 的使用请百度）\nvim /etc/ssh/sshd_config\n\n取消注释  下面的字段即可开启 ssh\nPort 22ListenAddress 0.0.0.0ListenAddress ::PermitRootLogin yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys\n\n修改好了之后，退出终端；\n用下面的命令重启 ssh 服务，并设置开机启动 ssh\nsystemctl restart sshd.servicesystemctl enable sshd.service\n\n如果一切正常的话，这两个命令应该什么都不会输出！\n3.3 尝试 ssh 链接ssh 绿联本地 ip:22222\n\n会弹出来让你验证登录，到这里就是 ok 了\n\n3.4 配置 ls 命令颜色vim /etc/profile\n\n在末尾添加如下字段\nexport LS_OPTIONS=&#x27;--color=auto&#x27;alias ls=&#x27;ls $LS_OPTIONS&#x27;alias ll=&#x27;ls $LS_OPTIONS -lA&#x27;\n\n随后重启容器即可\n3.5 配置 yum 阿狸源  备份原有源\ntar -zcvf CentOS-bk.tar.gz /etc/yum.repos.d/CentOS-*\n\n看看本地的 centos 是什么版本\ncat /etc/redhat-release\n\n我这里的版本是 8.5\nCentOS Linux release 8.5.2111\n\n替换阿里源\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repocurl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-8.repo\n\n重新生成缓存\nyum clean allyum makecache\n\n\n现在速度快多了！\n开用！后续的使用就不再多说拉！既然你想安装 centos，想必对 linux 的了解肯定比我多😂\n","categories":["docker真好玩"],"tags":["CentOS","nas"]},{"title":"【docker】通过配置文件，修改已有容器的端口映射","url":"/posts/1996139841/","content":"docker 修改已有容器的端口映射\n\n\n\n参考 https://www.jb51.net/article/257510.htm\n\n1. 需求  之前我在我的 nas 上部署了一个 centos 容器，当时脑子抽了，没想起来要多映射几个端口。只映射了容器的 22 端口（ssh）\n对于应用开发而言，没有能够直接访问的端口可太蛋疼了。在 centos 里面开 frp 穿透出来访问吧，又太麻烦。\n如果在绿联的控制台里面修改端口隐射，会直接创建一个新的容器，原有容器的信息会丢失。现在这个 centos 系统已经用了一段时间了，开发环境都配置好了。创建一个新容器就是得重头配置，虽然不是啥难事，但是太耗时间了！！！😥\n于是就想着，能否通过修改配置文件的方式，实现修改容器的端口映射。\n2. 操作 2.1 开启 ssh 并关闭 docker 服务 修改之前，需要开启绿联 nas 的 ssh 服务 。绿联 nas 如何开启 ssh 参考  视频\n说白了就是开启设备设置中的远程调试，在  远程调试码  前面加上如下字符，就是 root 的密码。用 nas 的本地 ip 连接 ssh，端口为922（如果连不上，保持远程调试开启状态下，重启 nas 即可）\nL#W$%W1uGa\n\n2023 年 11 月后的绿联 nas，直接开启远程调试，给出的调试码就是 ssh 的密码。\n链接上 ssh 之后，先使用docker ps，查看需要修改容器的container id。注意，这里的 id 并不是完整的容器 id，先记录下来。\ncontainer id2b8f29d7b4b0\n\n随后进入绿联的  客户端，关闭 docker 服务；如果是其他 linux 系统，可以用如下命令关闭 docker 服务\nsystemctl stop docker\n\n命令行里面再次执行docker ps，确认 docker 服务确实已经关闭\n$ docker psCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\n\n如果显示如上，则代表 docker 并没有在运行。即 docker 被正常关闭了。\n2.2 找到 docker 安装路径  接下来要做的，就是查看 docker 安装的位置。对于群晖、威联通、绿联这种 nas 而言，其系统内对 docker 安装挂载的位置是不同的。比如绿联的 nas 自带了 16gb 的闪存（系统盘），但 docker 的安装位置并不在这 16GB 里面，而是在我们  用户的硬盘中。\n一般的 Linux 系统（以我的云服务器为例），docker 的安装位置应该是如下路径\n/var/lib/docker\n\nls 查看内部文件，如下\n# ls /var/lib/dockercontainers  image  network  overlay2  plugins  swarm  tmp  trust  volumes\n\n而绿联的系统并没有这个路径\ncan&#x27;t open &#x27;/var/lib/docker&#x27;: No such file or directory\n\n查看/var/lib，并没有发现 docker 文件夹\n# ls /var/lib/dbus   nginx  samba\n\n查看/var，发现了一个 dockerd，猜测这是 docker 相关文件存放的位置\n# ls /varall_aria2.txt    dockerd          factory   \n\n里面只有一个 json 文件\n# ls /var/dockerddaemon.json\n\ncat 命令查看，果不其然，是 docker 的安装路径\n# cat /var/dockerd/daemon.json&#123;&quot;data-root&quot;:&quot;/mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6&quot;,&quot;log-level&quot;:&quot;warn&quot;,&quot;iptables&quot;:true,&quot;api-cors-header&quot;:&quot;*&quot;,&quot;host375&quot;],&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]&#125;\n\n这就是 docker 的安装位置了\n/mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6\n\nls 查看，文件结构和云服务器的 docker 安装位置基本一样，这代表我们找对了！\n# ls /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6buildkit    containerd  containers  image       network     overlay2    plugins     runtimes    swarm    tmp        trust       volumes\n\n2.3 找到对应容器的配置文件路径 docker 路径下的containers 文件夹，包含了不同容器的配置  文件夹。ls 查看，发现都是一些看不懂的字符串。实际上，这里的字符串就是容器的 id\n# ls /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers\n\n2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf  9113e1ec4740726feb9623a897f81b9066bc1b63811bfc0a65875d8a2c46c60347aa763o2da18686c6301047ef57f24fb611a2ebea2066f0dbk68205a40777e3\n\n前面提到，docker ps显示的容器 id 并不是完整的。因为完整的很长很长，不可能在 ps 命令里面全显示出来。\n我需要修改的目标容器，缩短的 id 如下，对应的正是 containers 文件夹里面的第一个文件夹\n2b8f29d7b4b0\n\n看看这个文件夹里面有啥东西\n注意：此时命令已经很长很长。避免出错，建议开个记事本，在里面把命令写好，再复制到终端中执行！\nls -l /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf\n\n得到的文件结构如下，我们需要修改的是 config.v2.json 和hostconfig.json\n-rw-r-----    1 root     root         87802 Mar 11 18:12 2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf-json.logdrwx------    2 root     root          4096 Feb 23 18:42 checkpoints-rw-------    1 root     root          3300 Mar 11 18:12 config.v2.json-rw-r--r--    1 root     root          1925 Mar 11 18:12 hostconfig.json-rw-r--r--    1 root     root            13 Mar 11 18:12 hostname-rw-r--r--    1 root     root           174 Mar 11 18:12 hostsdrwx--x---    2 root     root          4096 Feb 23 18:43 mounts-rw-r--r--    1 root     root            83 Mar 11 18:12 resolv.conf-rw-r--r--    1 root     root            71 Mar 11 18:12 resolv.conf.hash\n\n2.4 备份  在 linux 的命令行中操作，备份是必不可少的！使用 cp 命令，把配置文件复制一份，并在名字中添加上 .bak 予以区别\ncp 源文件 目标文件\n\n以下是 cp 命令备份 config.v2.json 文件的命令示例，命令很长！\ncp /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/config.v2.json /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/config.v2.bak.json\n\n备份了我们需要修改的两个文件后，接下来就是修改配置文件了\n2.5 修改配置文件 2.5.1  hostconfig.json 使用 vim 来进行编辑（编辑之前，可以用 cat 先复制出内容，放到 vsc 等编辑器中格式化，方便找到对应的位置，或者直接在 vscode 中修改，然后覆盖回去，都 OK）\nvim /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/hostconfig.json\n\n如下便是要修改的字段，可以看到里面只有对 22 端口的映射\n&quot;PortBindings&quot;: &#123;        &quot;22/tcp&quot;: [            &#123;                &quot;HostIp&quot;: &quot;0.0.0.0&quot;,                &quot;HostPort&quot;: &quot;22222&quot;            &#125;,            &#123;                &quot;HostIp&quot;: &quot;::&quot;,                &quot;HostPort&quot;: &quot;22222&quot;            &#125;        ]    &#125;\n\n我们照猫画虎，直接添加上另外两个端口的映射。\n在英文输入法下，按 i 进入 vim 的编辑模式，通过键盘移动光标到指定位置，修改文件\n&quot;PortBindings&quot;: &#123;        &quot;22/tcp&quot;: [            &#123;                &quot;HostIp&quot;: &quot;0.0.0.0&quot;,                &quot;HostPort&quot;: &quot;22222&quot;            &#125;,            &#123;                &quot;HostIp&quot;: &quot;::&quot;,                &quot;HostPort&quot;: &quot;22222&quot;            &#125;        ],        &quot;50000/tcp&quot;: [            &#123;                &quot;HostIp&quot;: &quot;0.0.0.0&quot;,                &quot;HostPort&quot;: &quot;50000&quot;            &#125;,            &#123;                &quot;HostIp&quot;: &quot;::&quot;,                &quot;HostPort&quot;: &quot;50000&quot;            &#125;        ],        &quot;50001/tcp&quot;: [            &#123;                &quot;HostIp&quot;: &quot;0.0.0.0&quot;,                &quot;HostPort&quot;: &quot;50001&quot;            &#125;,            &#123;                &quot;HostIp&quot;: &quot;::&quot;,                &quot;HostPort&quot;: &quot;50001&quot;            &#125;        ]    &#125;\n\n编辑好了之后，按 esc 退出编辑模式，:wq保存并退出\n2.5.2 config.v2.json这个文件需要修改的是如下字段\n&quot;ExposedPorts&quot;: &#123;    &quot;22/tcp&quot;: &#123;&#125;&#125;\n\n添加上刚刚在 hostconfig.json 里面新增的端口\n&quot;ExposedPorts&quot;: &#123;    &quot;22/tcp&quot;: &#123;&#125;,    &quot;50000/tcp&quot;:&#123;&#125;,    &quot;50001/tcp&quot;:&#123;&#125;&#125;\n\n同样 :wq 保存并退出\n2.6 现在就已经修改好啦！相同的文件路径中还有一个 hostname 文件，可以修改容器的 hostname，就是 ssh 登录 docker 安装的 centos 后，显示在用户名 @右边的那个\n用户名 @hostname\n\n用 docker 安装的 centos 镜像，是  不能  在 centos 系统中修改容器 hostname 的\n\n在 docker 安装的 centos 系统内修改可以，但是不会真正生效；不过这个东西对使用系统毫无影响，所以不修改也没关系\n\n3. 重启 docker，查看是否修改成功  在绿联客户端里面重启 docker 服务之后，使用 docker ps 命令查看端口映射是否修改成功；其他 linux 系统用如下命令启动 docker。\nsystemctl start docker\n\n如果多出了刚刚我们在配置文件里面修改的 50000 和 50001 端口，就代表端口映射修改成功了！\n","categories":["docker真好玩"],"tags":["Linux","CentOS","Docker"]},{"title":"【Docker】deepin/centos 安装 docker","url":"/posts/2069190154/","content":"deepin 虚拟机和 centos 服务器安装 docker \n\n\n1. 更新软件包# deepinsudo apt-get update &amp;&amp; sudo apt-get upgrade# centossudo yum update &amp;&amp; yum upgrade\n\n安装 docker 之前，先更新一下软件包\nmothra@mothra-PC:~$ sudo apt-get update &amp;&amp; sudo apt-get upgrade请输入密码:验证成功  命中:1 https://community-packages.deepin.com/deepin apricot InRelease命中:2 https://community-packages.deepin.com/driver driver InRelease命中:3 https://pro-driver-packages.uniontech.com eagle InRelease命中:4 https://community-packages.deepin.com/printer eagle InRelease命中:5 https://home-store-img.uniontech.com/230506175326447/appstore deepin InRelease正在读取软件包列表... 完成  正在读取软件包列表... 完成  正在分析软件包的依赖关系树       正在读取状态信息... 完成  正在计算更新... 完成  升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。\n\n2. 安装 docker# deepinsudo apt-get install docker-cesudo apt-get install docker-compose# centosyum install -y https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpmyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.reposudo yum install docker-ce docker-ce-cli containerd.io\n\n\n\n启动 docker\nsystemctl start docker\n\n安装之后，用如下命令看看版本，看看是否安装成功\n$ docker -vDocker version 19.03.8, build 1b4342cd4c\n\n如下就是安装成功了\n\n开机自启动\nsystemctl enable docker\n\n2.1 centos8 安装报错找不到 docker\n参考 https://www.cnblogs.com/yizhangheka/p/16614941.html\n\n在 centos8 上安装 docker 的时候，发现找不到 docker 的相关信息\n# sudo yum install docker-ce docker-ce-cli containerd.ioLast metadata expiration check: 0:12:10 ago on Wed 10 May 2023 10:37:43 PM CST.No match for argument: docker-ceNo match for argument: docker-ce-cliNo match for argument: containerd.ioError: Unable to find a match: docker-ce docker-ce-cli containerd.io\n\n这是因为我们没有 docker 的软件源。依照如上博客中的教程，执行如下命令\n# 下载软件源yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm# 安装依赖包yum install -y yum-utils device-mapper-persistent-data lvm2# 更新 docker 源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 安装 dockersudo yum install docker-ce docker-ce-cli containerd.io\n\n这样就能安装成功了，执行 docker version 命令查看版本，出现如下内容就是成功安装 docker 了。\n&gt; docker versionClient: Docker Engine - Community Version:           24.0.6 API version:       1.43 Go version:        go1.20.7 Git commit:        ed223bc Built:             Mon Sep  4 12:33:07 2023 OS/Arch:           linux/amd64 Context:           default\n\n2.2 安装 docker-composepython 安装（可能失败）需要保证系统内的 python 环境完好\npip3 install -i https://mirrors.aliyun.com/pypi/simple docker-compose\n\n安装好了之后查看版本，如下便是安装成功了\n$ docker-compose versiondocker-compose version 1.29.2, build unknowndocker-py version: &lt;module &#x27;docker.version&#x27; from &#x27;/usr/local/lib/python3.10/site-packages/docker/version.py&#x27;&gt;CPython version: 3.10.5OpenSSL version: OpenSSL 1.1.1q  5 Jul 2022\n\n参考 https://www.cnblogs.com/yizhangheka/p/16614941.html\n但在我的 CentOS8 上，上面的 python 安装方式会失效；\n我使用的是python3.10.6，安装会出现如下报错，无法成功安装；\n  File &quot;&lt;string&gt;&quot;, line 201, in get_source_files  File &quot;/tmp/pip-build-env-v8dnn0u_/overlay/lib/python3.10/site-packages/setuptools/_distutils/cmd.py&quot;, line 107, in __getattr__    raise AttributeError(attr)AttributeError: cython_sources[end of output]\n\n从 Github 安装\n参考博客 https://computingforgeeks.com/install-docker-and-docker-compose-on-rhel-8-centos-8/https://serverspace.io/support/help/how-to-install-docker-on-centos-8/\n\n然后又找了些博客，可以使用如下命令，直接下载 docker-compose 的可执行文件安装\nsudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# 修改权限chmod +x /usr/local/bin/docker-compose\n\n安装完毕后的测试结果如下，也是 OK 的\n# docker-compose -v docker-compose version 1.29.2, build 5becea4c\n\n但是这个安装的版本实在是太老了，最新版本都已经到 2.23.0 了。又在想办法找最新版本的安装教程；我尝试修改上述 curl 命令中的版本号，但是没用\n\n所以还是得用老办法，先打开 github 的 release 页面 https://github.com/docker/compose/releases\n这时候我发现上述的 curl 安装命令其实本质上就是下载一个可执行文件。在 CentOS8 上，uname -s是 linux，uname -m 是x86_64，命令执行结果如下；\n&gt; uname -sLinux&gt; uname -mx86_64\n\n所以其实我们需要下载的是 docker-compose-linux-x86_64 这个文件，对应下图中红色箭头所指的位置\nhttps://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64\n\n\n找到最新版本的文件 url 了，将其用相同的方式下载下来不就行了？\nsudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64&quot; -o /usr/local/bin/docker-compose# 修改权限chmod +x /usr/local/bin/docker-compose\n\n如果 github 下载实在是太慢，可以尝试用 github 的代理地址下载；截至 20231028，该代理地址的下载速度很快，完全可用。\nsudo curl -L &quot;https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64&quot; -o /usr/local/bin/docker-compose\n\n安装完成，当前 v2.23.0 最新版本搞定！\n&gt; docker-compose --versionDocker Compose version v2.23.0\n\n3. 修改 docker 镜像源  国内下载 docker 的 images 有时候很慢，所以需要我们修改镜像源。可以打开下面这个网站\nhttps://www.daocloud.io/mirror#accelerator-doc\n\n\n额，写博客这天的时候，他们的服务 502 了。打不开网站。\n\n用如下办法修改\nsudo vim /etc/docker/daemon.json\n\n进入后，按 i 进入编辑模式，复制如下内容，用 shift+ins 粘贴\n&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125;\n\n然后 :wq 退出，用如下命令重启 docker 服务，镜像就设置好了\nsudo systemctl restart docker\n\n国内可用的 docker 镜像有下面这些，更多镜像可以百度看看。南京大学和上海交大的镜像源用的人少，似乎更好用。之前有一段时间 docker 国内的镜像都挂了，基本没办法 pull，现在应该是解决了。\n科大镜像：https://docker.mirrors.ustc.edu.cn/七牛云：https://reg-mirror.qiniu.com网易：https://hub-mirror.c.163.com/南京大学: http://docker.nju.edu.cn 上海交大: docker.mirrors.sjtug.sjtu.edu.cn打开下面的地址登录你的阿里云账号获取你的专属镜像源 https://cr.console.aliyun.com/#/accelerator阿里云：https://&lt; 你的 ID&gt;.mirror.aliyuncs.com\n\n4. 一些 docker 常用命令  因为当前我们用的是 deepin 的用户，而不是 root，所以执行 docker 相关命令的时候都需要带上sudo\nsudo docker ps # 查看当前正在运行的容器sudo docker ps -a # 查看当前所有容器（包括未运行的）sudo docker stats # 查看 docker 运行状态（资源占用）sudo docker stats 容器名字 # 某一个容器的运行状态sudo docker rm 容器名字  # 删除容器sudo docker rmi 镜像hash # 删除镜像\n\ndocker-compose 的操作需要根据 docker-compose.yml 进行，具体的请参考不同容器的 yml 文件编写和使用。一般用户量大的开源 docker 都会有 docker-compose.yml 的示例文件的！\n其他的 docker 操作，请根据特定容器进行操作，详情百度吧！\n","categories":["docker真好玩"],"tags":["Linux","Docker","deepin"]},{"title":"【docker】群晖 nas 部署开源论坛 Flarum | 转载","url":"/posts/2506750545/","content":"群晖 nas 部署开源论坛 Flarum，本文为转载\n\n\n版权声明：本文为 CSDN 博主「杨浦老苏」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/wbsu2004/article/details/127083835原文发布时间：2022-09-28 10:07:30 \n\n\n这回是居委会通知的\n\n\n\n本文完成于 5 月底\n\n什么是 Flarum ？\n\nFlarum 是一个非常简单的网站讨论平台。它快速且易于使用，具有运行成功社区所需的所有功能。它还具有极强的可扩展性，可实现终极定制。\n\n论坛虽然逐渐被淘汰了，但老苏觉得搭一个用来做知识管理，或者用来和家人分享照片、视频的快乐时光，还是挺不错的。\n局域网  用用就好了，不要映射到互联网\n安装  建数据库  网上能找到的都是docker-compose 的安装方式，除了 Flarum 外还需要安装 MariaDB。老苏用了群晖自带的 MariaDB 10 数据库。\n\n在 phpMyAdmin 中创建名为 flarum 的空数据库。\n\n安装镜像  在群晖上以 Docker 方式安装。\n在注册表中搜索 flarum ，选择第一个 mondedie/flarum，版本选 latest\n\n存储卷  在 docker 文件夹中，创建一个新文件夹 flarum，并在其中建 4 个子文件夹，分别是 assets、extensions、logs、nginx\n\n\n\n端口  本地端口不冲突就行，不确定的话可以用命令查一下\n# 查看端口占用\nnetstat -tunlp | grep 端口号\n\n本地端口8888，容器端口8888\n默认并没有映射端口\n\n需要点 + 号添加\n\n环境  其中部分属于需要修改的，部分属于需要新增的\n\n\n更多的环境变量请移步：https://github.com/mondediefr/docker-flarum\n\n\n常规  名称命名为 flarum，这是为了方便后面进入容器内做设置，不改也可以，改了可以少输入几个字母\n\n\n慕雪的提示：在我测试的时候，发现该镜像若修改环境变量中的 FORUM_URL， 可能  会导致 docker 无法正常启动！请在配置前确认您的远端地址，配置好后最好不要修改！\n\n命令行安装  如果你熟悉命令行，可能用 docker cli 更快捷\n# 新建文件夹 flarum 和 子目录mkdir -p /volume2/docker/flarum/&#123;assets,extensions,logs,nginx&#125;# 进入 flarum 目录cd /volume2/docker/flarum# 运行容器docker run -d \\   --restart unless-stopped \\   --name flarum \\   -p 8888:8888 \\   -v $(pwd)/assets:/flarum/app/public/assets \\   -v $(pwd)/extensions:/flarum/app/extensions \\   -v $(pwd)/logs:/flarum/app/storage/logs \\   -v $(pwd)/nginx:/etc/nginx/flarum \\   -e DEBUG=false \\   -e FORUM_URL=http://192.168.0.197:8888 \\   -e DB_HOST=192.168.0.197 \\   -e DB_PORT=3307 \\   -e DB_NAME=flarum \\   -e DB_USER=flarum \\   -e DB_PASS=123456 \\   -e DB_PREF=flarum_ \\   -e FLARUM_ADMIN_USER=laosu \\   -e FLARUM_ADMIN_PASS=123456 \\   -e FLARUM_ADMIN_MAIL=wbsu2003@gmail.com \\   mondedie/flarum\n\n\n慕雪的补充: 如果你使用的不是群晖这种自带数据库的 nas，也可以使用 docker 简单部署一个 mysql 作为 flarum 的数据库，命令如下；\n\ndocker run -d -p 3306:3306 \\--name mysql --privileged=true \\-v /data/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\mysql:5.7\n\n创建完毕后，进入容器进行 mysql 的用户创建\ndocker exec -it mysql /bin/sh\n\n用户创建相关语句可查看慕雪的另外一篇博客 -&gt;【点我】\n\n也可以用 docker-compose 安装，将下面的内容保存为 docker-compose.yml 文件\nversion: &quot;3&quot;services:  servas:    image: mondedie/flarum    container_name: flarum    restart: unless-stopped    ports:      - &quot;8888:8888&quot;    volumes:      - /volume2/docker/flarum/assets:/flarum/app/public/assets      - /volume2/docker/flarum/extensions:/flarum/app/extensions      - /volume2/docker/flarum/logs:/flarum/app/storage/logs      - /volume2/docker/flarum/nginx:/etc/nginx/flarum    environment:      - DEBUG=false      - FORUM_URL=http://192.168.0.197:8888      - DB_HOST=192.168.0.197      - DB_PORT=3307      - DB_NAME=flarum      - DB_USER=flarum      - DB_PASS=123456      - DB_PREF=flarum_      - FLARUM_ADMIN_USER=laosu      - FLARUM_ADMIN_PASS=123456      - FLARUM_ADMIN_MAIL=wbsu2003@gmail.com\n\n\n然后执行下面的命令，在 portainer 中执行也是可以的\n# 新建文件夹 flarum 和 子目录mkdir -p /volume2/docker/flarum/&#123;assets,extensions,logs,nginx&#125;# 进入 flarum 目录cd /volume2/docker/flarum# 将 docker-compose.yml 放入当前目录# 一键启动docker-compose up -d\n\n\n运行  第一次需要初始化，当在日志中看到 Forum is starting. 就可以访问了\n\n在浏览器中输入 http:// 群晖 IP:8888 就能看到主界面\n\n设置界面\n\n管理员后台\n\n中文  默认 Flarum 只支持英文，但是有中文扩展：https://discuss.flarum.org.cn/d/1211\n终端机  可以进入终端机中安装\n或者命令行填写\ndocker exec -it flarum /bin/sh\n\n\n执行下面的命令\n# 进目录cd /flarum/app# 安装中文语言包composer require flarum-lang/chinese-simplified# 清除缓存php flarum cache:clear\n\n\n\n命令行  在 SSH 客户端的命令行中执行下面的命令\n# 进入容器docker exec --user root -it flarum /bin/sh# 进目录cd /flarum/app# 安装中文语言包composer require flarum-lang/chinese-simplified# 清除缓存php flarum cache:clear\n\n\n\n安装完成后，在管理员后台能看到 Languages 中多了 简体中文;\n进入 简体中文，默认是 Disable\n\n改为 Enabled\n\n在 Basic 中，设置为缺省的语言\n\n保存后刷新页面\n\n主界面刷新一下\n\n发个帖子试试\n\n浏览效果\n\n参考文档\nflarum&#x2F;flarum: Simple forum software for building great communities.地址：https://github.com/flarum/flarum\n\n\nmondediefr&#x2F;docker-flarum: Docker image of Flarum地址：https://github.com/mondediefr/docker-flarum\n\n\n简体中文语言包 - Flarum 中文社区  地址：https://discuss.flarum.org.cn/d/1211\n\n\nFlarum 中文社区  地址：https://discuss.flarum.org.cn/\n\n","categories":["docker真好玩"],"tags":["MySQL","docker"]},{"title":"【docker】如何本地构建镜像并发布到 dockerhub","url":"/posts/1414052231/","content":"制作镜像，最后一个 . 指定的是当前路径，可以切换为其他路径\nsudo docker build -t 镜像名:tag .\n\n\n需要先登录你的 dockerhub 账户\nsudo docker login\n\n输入 docker hub 的账户和密码（不需要 token）\n然后给本地的镜像打个 tag\nsudo docker tag e2bdy:0.1.0 musnows/e2bdy:0.1.0sudo docker tag 本地镜像名: 版本 用户名 / 镜像名: 版本\n\n然后再执行 push\nsudo docker push musnows/e2bdy:0.1.0sudo docker push 用户名 / 镜像名: 版本","categories":["docker真好玩"],"tags":["docker"]},{"title":"【Docker】用开源 umami 监控你的站点访问量","url":"/posts/910878902/","content":"新年到，祝大家兔年吉祥！🎉\n\n\n1. 介绍umami 是一个开源的站点访问量监看程序，其支持 docker 部署到自己的服务器上。相比较百度等收费的网站信息监看，这种方式对于小站长来说更加实惠一些\n2.docker 安装的坑 2.1 docker-compose 以下是官方提供的 yml 文件，我只是将数据库 docker 的名字改成了umi-db，将 3000 端口映射给了本机的 3010 端口\nversion: &#x27;3&#x27;services:  umami:    image: ghcr.io/umami-software/umami:postgresql-latest    ports:      - &quot;3010:3000&quot;    environment:      DATABASE_URL: postgresql://umami:umami@umi-db:5432/umami      DATABASE_TYPE: postgresql      HASH_SALT: adsfadsfa23421313dfabadsf32rl    depends_on:      - umi-db    restart: always  umi-db:    image: postgres:12-alpine    environment:      POSTGRES_DB: umami      POSTGRES_USER: umami      POSTGRES_PASSWORD: umami    volumes:      - ./sql/schema.postgresql.sql:/docker-entrypoint-initdb.d/schema.postgresql.sql:ro      - umami-db-data:/var/lib/postgresql/data    restart: alwaysvolumes:  umami-db-data:\n\n写好文件后，使用 docker-compose up -d 命令，运行镜像。过一会再使用docker-compose ps，只要两个镜像都是正常运行状态，那就 ok 了\n2.2 坑  这里有一个小🕳，那就是我们并不需要设置数据库的端口。在我的服务器上，5432 端口已经被另外一个容器占领了，于是我就使用了下面的语法，想把数据库映射给 5433 端口\n备注：下面的这个是错误写法，umami 容器会因为连不上数据库而一直重启！\nversion: &#x27;3&#x27;services:  umami:    image: ghcr.io/umami-software/umami:postgresql-latest    ports:      - &quot;3010:3000&quot;    environment:      DATABASE_URL: postgresql://umami:umami@umi-db:5433/umami      DATABASE_TYPE: postgresql      HASH_SALT: adsfadsfa23421313dfabadsf32rl    depends_on:      - umi-db    restart: always  umi-db:    image: postgres:12-alpine    environment:      POSTGRES_DB: umami      POSTGRES_USER: umami      POSTGRES_PASSWORD: umami    ports:      - &quot;5433:5432&quot;    volumes:      - ./sql/schema.postgresql.sql:/docker-entrypoint-initdb.d/schema.postgresql.sql:ro      - umami-db-data:/var/lib/postgresql/data    restart: alwaysvolumes:  umami-db-data:\n\n实际上并不需要这么操作，因为默认状态下，这个数据库的端口都没有映射到本机，并不会和已有的端口冲突！\nDATABASE_URL: postgresql://umami:umami@umi-db:5432/umami\n\n这里其实已经指定了，是使用 umi-db 容器内部的 5432 端口，并不是使用云服务器的 5332 端口，二者是不一样的。\n直接使用官方原有的 docker-compose 文件就没问题了！\n3. 进入管理页面  安装完毕后，使用  云服务器 ip: 端口  的方式访问，进入后台。\n默认用户名是admin，默认密码是umami，进入之后请立刻修改密码。\n3.1 修改中文  点击右上角的头像，进入profile，设置语言为中文。\n\n3.2 添加站点  随后在网站选项栏添加网站，填入你的站点 url 和名字\n\n3.3 添加到 hexo 博客上  保存了之后，点击右侧的这个代码块图标，复制里面的代码\n\n到本地的 hexo 主题文件中，找到 head 文件，修改 &lt;head&gt; 处的代码，加入刚刚复制的代码\nkeep 主题文件位置 themes\\keep\\layout\\_partial\\head.ejs\n\n重新部署博客即可，数据过几小时就会生效\n3.4 添加到 wikijswiki js 的管理页面，网站分析一栏就有 umami\n\n填入你部署 umami 的服务器 url 和站点 id 即可，圈出来的部分就是网站 id，并不是你在 umami 里面设置的站点名字\n\n","categories":["docker真好玩"],"tags":["wikijs","Docker","hexo"]},{"title":"【Nginx】配置跨域请求问题 | 转载","url":"/posts/3435557393/","content":"ngnix 配置跨域请求问题\n\n\n1. 问题  今天在尝试写一个 html 代码（抄 csdn 的）请求我自己的 valorant api 的时候，遇到了下面的问题\n\n百度了一下，大概的意思就是，当前我的 api 服务器不支持跨域请求。\n此时请求其实已经完成了（后端日志显示已经返回了结果）在返回到浏览器的时候，浏览器检查了后端的设置，发现后端不允许跨域请求，所以屏蔽了我们的访问\n2. 解决  需要配置的是 nginx，在转发规则里面添加下面的内容\nlocation / &#123;      add_header Access-Control-Allow-Origin *;    add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;;    add_header Access-Control-Allow-Headers &#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;;    if ($request_method = &#x27;OPTIONS&#x27;) &#123;        return 204;    &#125;&#125; \n\n现在就 OK 了\n\n版权声明：本文为 CSDN 博主「Young 丶」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/agonie201218/article/details/112562252\n\n","categories":["玩上Linux"],"tags":["Linux","Docker"]},{"title":"【docker】绿联 nas 部署 mysql+wikijs","url":"/posts/3856317267/","content":"本文为绿联 docker 上 mysql+wikijs 的配置教程。\n\n\nmysql 是众多数据库之一，很多其他的 docker 容器都需要用到数据库。比如图床、wikijs\n\n所用 nas：绿联 dh2600\n\n1. 安装 mysql1.1 下载镜像  在绿联的 docker 套件 - 本地镜像 - 添加 - 官方库，搜索 mysql\n\n选择最新版本，点击确定，等待镜像拉取完毕\n\n1.2 创建容器  随后在本地镜像列表中选择刚刚下载的 mysql 镜像，点击+ 创建容器。\n未提及的选项都无需设置\n\n若需要对容器进行资源限制，则至少给 1G 内存\n网络选择 bridge\n存储空间建议本地新建一个文件夹进行映射，装载路径为/val/lib/mysql\n\n\n\n端口映射，其中 3306 是 http，33060 是 https，这部分本地映射一个没有被占用的端口即可\n\n\n\n环境变量处添加MYSQL_ROOT_PASSWORD，值为 mysql 的初始密码\n\n\n点击下一步 - 确定，容器创建完毕！\n\n如果你的系统支持 ssh，可以直接使用如下命令创建\ndocker run \\\t--name mysql \\\t-d \\\t-p 3306:3306 \\\t--restart unless-stopped \\\t-v 本地路径:/var/lib/mysql \\\t-e MYSQL_ROOT_PASSWORD=123456 \\\t-e TZ=Asia/Shanghai \\\tmysql:8.0.30\n\n这样创建出来的 mysql，root 用户密码是 123456\n1.3 确认安装成功  容器开始运行后，点击详细 - 终端，连接/bin/bash\n\n若配置正确，则应该出现下面的画面\n\n输入以下命令，进入 mysql 控制台\nmysql -uroot -p 密码\n这里的  密码  是刚刚载环境变量中设置的密码，比如上面演示的密码是 123456，那么就应该用下面的语句\nmysql -uroot -p123456\n如果出现下面的内容，则代表 mysql 安装成功！\n1.4 创建数据库  但有 mysql 还不够，如果想给其他项目使用，我们还需要创建数据库\n以 WIKI JS 为例，先输入以下语句进入数据库\nmysql -uroot -p 密码\n\n输入以下语句，创建数据库。可以复制后按 shift+ins 粘贴，不要用 ctrl+v 粘贴\nCREATE DATABASE 数据库名;\n创建一个名为 WIKIJS 的数据库\nCREATE DATABASE WIKIJS;\n\n1.5 创建用户  输入以下语句，查看当前数据库的用户\nselect user from mysql.user;\n显示的结果如下（不知道为啥我这里有两个 root，不影响使用）\nmysql&gt; select user from mysql.user;+------------------+| user             |+------------------+| root             || mysql.infoschema || mysql.session    || mysql.sys        || root             |+------------------+6 rows in set (0.00 sec)mysql&gt; \n\n为方便容器管理，我们给 WIKI JS 创建一个单独的用户，名为WIKI\nCREATE USER &#x27;WIKI&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;\n这样，我们就创建了一个 WIKI 用户，密码为123456\t\n创建完毕后，我们还需要给这个用户授权，让其有能力处理数据库\nGRANT ALL ON WIKIJS.* TO &#x27;WIKI&#x27;@&#x27;%&#x27;;\n上面这个语句的意思为，授予 WIKI 用户 在数据库 WIKIJS中所有权限（ALL).\n注意区分，ALL ON 后面的是数据名字，TO 后的是用户名字\n这样，WIKI 用户和 WIKIJS 数据库都创建完毕了，可以在 WIKI JS 的环境变量中进行配置了\n1.6 mysql 的实际运用  如果你不是程序猿，单独的 mysql 容器可能没啥用，后续将分享 mysql 容器的两个使用实例\n\nwiki js\nchevereto 图床\nlsky 图床\n\n1.7 docker 使用 mysql 命令总结  如果你看了上面那一堆，还是不懂，那就可以把下面的 3 个语句记住，对所有要用到 MySQL 数据库的 docker 容器都适用!\n-- 先在 nas 的系统中进入 MySQL 容器的终端里面，然后执行如下命令mysql -uroot -p 密码-- 进入 MySQL 命令行后，创建数据库和用户create database 数据库名字;-- 数据库名字要和上面创建的这个数据库对应CREATE USER &#x27; 用户名 &#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27; 用户的密码 &#x27;;GRANT ALL ON 数据库名字.* TO &#x27; 用户名 &#x27;@&#x27;%&#x27;;\n\n当然，如果你的 NAS 内存够多，你也可以选择抄别人的 docker-compose 文件一次性联动创建多个容器，突出一个傻瓜式；\n2.WIKI JS下面将继续讲解 wiki jsdocker 的安装，其至少需要 1G 内存，加上 mysql 容器，总共 至少需要 2G内存。请确认您 nas 的内存足够，再执行以下操作!\n2.1 是什么wikijs 就是一个文档的呈现方式。该站点具有以下几个优点\n\n数据存本地，安全性高\n多用户在线编辑，可进行权限管理\n有历史版本管理，方便查看旧版本情况\n若有需要，可以将文档自动同步到云存储平台备份，如 git 仓库\n可导出数据到本地，均为 markdown 格式。脱离 wiki js 也可以用 typora 等支持 markdown 的软件打开\n\n2.2 有啥用  你可能觉得，这玩意对家庭用户来说没啥用啊？实际上，它可以作为一个极其不错的  家庭记事本！\n所有的数据都是存在你本地的 nas 上的，只要在家就可以简单地通过 ip+ 端口的方式访问 wikijs。电脑手机都能直接在线编辑，免去了多端同步的烦恼。\n如果你有公网 ip，还可以在外网直接访问；没有公网 ip 的也可以用  樱花 frp进行内网穿透，免费 10m 带宽足够 wiki js 使用了（樱花 frp 的 docker 安装教程见官网帮助文档）\n相当于一个云同步的记事本！（只不过对手机编辑并不是很友好）\n2.3 下载 wikijs 镜像  老地方，添加镜像，选择 linuxserver/wikijs 的 latest 版本即可\n\n2.4 安装配置  网络模式选择 bridge\n创建一个新文件夹，映射给 wikijs 的/config，记得修改权限为读写\n\nwikijs 的端口只有一个，设置一个不冲突的即可\n\n环境变量需要我们配置很多！划重点！！\n\n在配置环境变量前，请先参考 01-mysql 中的教程，在 mysql 中创建一个 WIKIJS 数据库，和 WIKI 用户\n\n\n\n\n环境变量\n值\n\n\n\nDB_TYPE\nmysql\n\n\nDB_HOST\n数据库主机名或 ip，直接填写 nas 的 ip 即可\n\n\nDB_PROT\nmysql 容器的端口\n\n\nDB_USER\n数据库用户名\n\n\nDB_PASS\n数据库用户的密码\n\n\nDB_NAME\n数据库名称\n\n\n其中 DB_TYPE 为数据库类型，支持 mysql, postgres, mariadb, mssql, sqlite，本文使用的是 mysql\n下图为一个配置后的示例\n\n配置完环境变量后，容器就配置完成了，点击确定\n3. 使用 wikijs在浏览器页面输入你 nas 的 ip+ 端口，即可打开 wiki js 的网页。\n是英语的咋办？别担心，进去之后就可以改成中文了。\n\nAdministrator Email 管理员邮箱，输入一个你自己的邮箱即可\nPasswd 密码\nConfirm Passwd 确认密码\n\nurl 这里可以不填，填完信息后直接点击下面的 INSTALL 即可\n\n初次使用的时候需要下载一些依赖项，下载完成后，即可进入登录页面。输入你刚刚设置的账户邮箱，点击 log in 进入 wikijs 的管理后台\n\n进入之后你会看到两个选项（无截图）直接点击右边那个进入管理页面👇\n\n进入后选择Locale，在右侧可以看到中文，下载之后，选择中文再点击右上角绿色的 APPLY，页面就变成中文了\n\n随后就创建一个页面吧！\n学习 markdown 语法  如果你之前没有接触过任何 markdown 语法，则可以选择  富文本编辑器\n\n个人建议学习一下基本的 markdown 语法，非常简单！在很多平台（CSDN、知乎、博客园）以及很多笔记软件（为知、有道云、flowus 等）都是支持 markdown 的。\n\n学习 md 语法可以查看此网站 👉 markdown.com.cn\n\nOVER!现在你已经可以将 wiki js 作为多人协作文档编辑站点，或者是你的家庭记事本了！\n随时可看，随时可编辑！\n参考文章\n群晖内通过 Docker 安装 MySQL5.7.34\nMySQL 创建用户，设置密码\nMySQL 创建数据库\n轻量但功能强大的 Wiki.js\n\n","categories":["docker真好玩"],"tags":["docker","mysql"]},{"title":"【Nginx】Docker 配置 ngnix，实现同服务器 ip 多站点多域名","url":"/posts/1994863894/","content":"Docker 配置 ngnix，实现同服务器 ip，多域名映射多站点\n\n\n1. 说明  一般情况下，我们的域名映射到 ip 后，默认访问的是 80 端口。如果你的服务器只部署了一个服务，这样也是够用的。\n但是很多项目对性能的占用并没有那么夸张，一个服务器一个站点未免有些浪费了。虽然我们可以用  域名: 端口  来访问，但是这样对于用户来说并不友好，对于强迫症来说看着很不舒服🤣\n这时候，就需要配置  反向代理  来实现不同域名到服务器不同端口的映射。\n1.1 反向代理  你可以理解为，反向代理是服务器的一个中间商，其能将 80 端口的，不同域名来源的请求，导向到服务器上的不同端口\nwww.example.com 指向 8080 端口 aaa.example.com 指向 3000 端口 这两个域名都映射到服务器公网 ip 114.514.8.8\n\n当你访问 www.example.com 时，请求的是 114.514.8.8:80 端口，也就是反向代理的服务。此时反向代理能知道你的来源是www.example.com，于是就把你带到了 8080 端口的服务上；\n同理，访问 aaa.example.com 时，就会被带到 3000 端口。\n\n这里用 nginx 作演示，nginx是最常用的反向代理服务\n2.docker 安装 nginx\n本文参考：https://www.jianshu.com/p/6b317192480c\n\n用其他方式还得整一大堆依赖项，这里直接用 docker，方便又快捷;\n服务器安装 docker 的方式，根据你的系统，自行百度\ndocker pull nginx\n\n2.1 配置  启动之前，先在你的当前路径下创建一个文件夹（我这里是 root 用户）\nmkdir /root/docker/ngnix\n\n随后用下面的命令启动 nginx 容器\ndocker run \\--name=ngx \\-p 80:80 -p 443:443 \\-v /root/docker/nginx/conf.d:/etc/nginx/conf.d \\-v /root/docker/nginx/cert:/etc/nginx/cert \\-d nginx\n\n对一些参数进行说明\n\n-p命令映射端口，将 80 端口映射给服务器的 80 端口（右侧容器端口，左侧本地端口\n-v命名映射目录，将本地的 /root/nginx/conf.d 映射到 docker 里面的/etc/nginx/conf.d 这是 nginx 的配置文件路径\n--name设置容器的名字，和镜像名字无关\n\n安装完成后，打开云服务器的 ip，就能看到 nginx 的初始页面\n\n3. 编辑配置文件nginx.conf 配置文件我们直接用官方默认的就行，这里主要对站点的配置文件做说明；\n3.1 https如果不需要 https 加密，可以用下面的配置文件来操作，当使用 test.com 访问你的云服务器 ip 时，会被转到 4000 端口\nserver &#123;    listen 80;  # 监听 80 端口    server_name test.com;  # 自己的域名        location / &#123;\t\t# 设置缓冲区大小\t\tproxy_buffer_size 64k;        proxy_buffers   32 32k;        proxy_busy_buffers_size 128k;\t\t        proxy_set_header HOST $host;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\t\t# 需要代理的地址: 端口（因为是 docker 部署的，需要填公网 ip）        proxy_pass http://IP:4000;    &#125;&#125;\n\n3.1.1 关于 proxy_pass这里必须要注意一下proxy_pass\n因为我们的 nginx 是用 docker 部署的，此时你填 127.0.0.1 或 localhost，实际上访问的都是 nginx 这个 docker内部  的端口，是没有用的，会弹出 502 gateway 报错！\n正确的办法就是填云服务器的公网 ip+ 端口\n3.2 https配置 https 如下，这样配置会将 80 端口的 http 访问强制转成 https\n域名的证书可以在域名提供商里面申请，腾讯云支持申请  单域名 1 年的免费证书。还可以去 joyssl，申请 90 天的 域名通配符  证书\n因为在启动 docker 容器的时候，我配置了路径映射，证书配置的 cert/ 对应的其实是 /root/docker/nginx/cert/目录，将证书文件放到该目录下即可\nserver &#123;    listen 443 ssl;    server_name img.text.top;  # 域名    # 注意文件位置，是从 /etc/nginx/ 下开始算起的    ssl_certificate cert/img.text.top.crt; # 域名证书文件 crt    ssl_certificate_key cert/img.text.top.key; # 域名证书 key    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    client_max_body_size 1024m;    location / &#123;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header Host $host;        proxy_set_header Upgrade-Insecure-Requests 1;        proxy_set_header X-Forwarded-Proto https;        # 因为是 docker 部署的 nginx，所以要填云服务器公网 ip        proxy_pass http:// 云服务器公网 IP: 端口;    &#125;&#125;# 强制重定向server &#123;    listen 80; # 监听 80 端口    server_name img.text.top;  # 域名    # 把 http 的域名请求转成 https    return 301 https://$host$request_uri; &#125;\n\n修改配置文件后重启 nginx 的容器，即可正常访问\n\n更多：用 portainer 管理 dockerportainer 是一个图形化管理 docker 镜像和容器的项目，还是很不错的；缺点就是只有英文，想要中文可以配置中文包，但是中文包已经非常非常久没有更新了，索性直接用英文版\ndocker run -p 14730:9000 -p 14729:8000 --name portainer \\--restart=always \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /root/docker/portainer/data:/data \\-d portainer/portainer\n","categories":["docker真好玩"],"tags":["Linux","Docker"]},{"title":"【Docker】配置 lsky pro 兰空图床","url":"/posts/370869610/","content":"Docker 部署 lsky pro 兰空图床的教程\n\n\n1. 使用 Docker 部署 1.1 命令行 命令比较简单，用下面的即可\ndocker run -d \\--name lsky \\-p 14728:80 \\-v /root/docker/lsky:/var/www/html \\halcyonazure/lsky-pro-docker:latest\n\n\n--name 设置容器名字为 lsky\n-p 设置端口隐射，容器的 80 端口映射给本地的 14728 端口\n-v 设置存储映射，本地的/root/docker/lsky 映射给 /var/www/html\n\n完成后，进入IP:14728 即可打开你的图床页面\n\n此命令在 CentOS7.2 云服务器上测试有效，但在我的 nas 上测试无效\n\n230517 更新，当时写这篇博客的时候，使用的是旧版本的容器。目前新版本的容器已经切换了内部端口为 8089，所以新版本的命令如下\ndocker run -d \\--name lsky \\-p 14728:8089 \\-v /root/docker/lsky:/var/www/html \\halcyonazure/lsky-pro-docker:latest\n\n这也是为什么当初我写下了“在 nas 上测试无效”的记录。容器内部端口并不是 80\n2. 初始化  新用户直接用 sqlite 即可，如果对性能有更高要求，建议使用 mysql。\n\n因为我就是给自己作图床而已，对 mysql 的认知近乎为 0，所以直接用 sqlite 方便多了。\n\n后续打开主页面就能上传文件了\n2.1 设置管理员用户总容量  首先当然是进入用户组设置，把自己这个管理员用户的总容量改成 5gb（默认 500mb）\n\n在系统设置里可以改用户的初始容量，看你的情况要不要增加\n\n2.2 新建角色组  其次，可以在角色组里面新增一个管理员组，设置一下单图大小限制（默认 5mb）以及每天 &#x2F; 每周 &#x2F; 每月的图片上传数量限制；同时，在角色组这里还可以修改命名格式\n\n个人建议去掉路径命名中的日期，这样能一定程度上的避免  同一图片的二次存储。\n\n如果你上传了两个完全一样的图片，在  我的图片  里面会显示两个，但是只会有一个本地文件。\n\n文件的命名除了随机字符串，还可以选择 md5、时间戳命名\n\n2.3 设置阿里云 OSS 为存储  这部分很简单，照着标识的填就行了。个人还是选择了本地存储的方式（阿里云 OSS 批量导出数据很麻烦）\n\n填了之后，上传的图片会直接返回阿里云 OSS 的链接\n2.4 权限问题  如果你有一些本地的图片，想添加到 lsky 图床的根目录方便访问的话，就需要配置一下目录的图片\n举个例子，我有一图片的压缩包，我想将其放入 lsky 的 stroage/app 的my文件夹里面，那么创建这个文件夹的时候，就需要修改它的权限\nchown 33:tape my # 配置 my 文件夹的用户和用户组# 33 和 tape 是 docker 配置 lsky 的默认用户名和用户组\n\n否则 lsky 图床没有办法正确读取或者往这个目录写入，从而导致上传错误\n3.https 访问 3.1 修改代码 参考 https://github.com/lsky-org/lsky-pro/issues/321\n需要添加代码，docker 用下面的方式添加后重启即可\ndocker exec -it 容器名字 sed -i &#x27;32 a \\\\\\Illuminate\\\\Support\\\\Facades\\\\URL::forceScheme(&#x27;&quot;&#x27;&quot;&#x27;https&#x27;&quot;&#x27;&quot;&#x27;);&#x27; /var/www/html/app/Providers/AppServiceProvider.php\n\n个人感觉，该 issue 已经提出了将近一年，lsky 还是不支持在前端后台或者配置文件中直接配置 https，实在有点不太应该。或许维护者是认为该修改代码的操作并不困难，就没有写入配置文件中。\n不过这只是鸡蛋里挑骨头，lsky 整体还是非常好用的\n3.2 nginx 配置  安装 nginx，可以参考我的 nginx 安装博客\nserver &#123;    listen 443 ssl;    server_name img.text.top;  # 域名    # 注意文件位置，是从 /etc/nginx/ 下开始算起的    ssl_certificate cert/img.text.top.crt; # 域名证书文件 crt    ssl_certificate_key cert/img.text.top.key; # 域名证书 key    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    client_max_body_size 1024m;    location / &#123;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header Host $host;        proxy_set_header Upgrade-Insecure-Requests 1;        proxy_set_header X-Forwarded-Proto https;        # 因为是 docker 部署的 nginx，所以要填云服务器公网 ip        proxy_pass http:// 云服务器公网 IP: 端口;    &#125;&#125;# 强制重定向server &#123;    listen 80; # 监听 80 端口    server_name img.text.top;  # 域名    # 把 http 的域名请求转成 https    return 301 https://$host$request_uri; &#125;\n\n写入配置文件后，重启 nginx 容器，并将域名的解析设置成你云服务器的公网 ip，即可以用 img.text.top 或img1.text.top访问你的 lsky 图床\n\n3.2.1 http 重写为 https注意，默认情况下，lsky 的所有文件加载都会走 http，即便你打开了https://img.musnow.top，那些 css 和 js 的资源还是走了http://img.musnow.top，这种混合http 和 https 的加载容易被浏览器拦截，导致 lsky 图床的界面显示的乱七八糟。\n\n\n所以 nginx 配置文件的 location 中，一定要加上如下配置项，相当于将http 重写为 https\nproxy_set_header Upgrade-Insecure-Requests 1;\n\n如果你像我一样使用了 1panel 来管理站点，此时 openresty（1panel 用的就是这个）的安装路径如下\n/opt/1panel/apps/openresty/openRestry/www/sites/\n\n在这里面你可以看到你配置好的站点（文件夹名字都是域名）\n进入你想修改的域名站点中，可以看到下面几个文件夹\nindex  log  proxy  ssl  waf\n\n进入 proxy 文件夹，里面会有一个 root.conf，即为 根路径  的配置文件，你需要修改这个文件，在里面加上上述提到的配置项，否则 lsky 的界面会变乱。\n修改好了以后，进入 1panel 的 web 页面，找到站点的配置文件选项框\n\n点击最下方的保存并重载，即可生效\n\n刷新界面，可以看到页面加载正常了\n\n3.3 又拍云 cdn在我的配置项中，并没有把 img1 和img都解析到云服务器，而是将 img1 作为 cdn 加速的域名\n这里我使用的是  又拍云 CDN，注意使用之前，你需要申请好这两个子域名的 https 证书，可以是单域名证书，也可以是通配符证书。单域名证书能在又拍云 CDN 中免费申请\n\n推荐大家去申请一个  又拍云联盟，只需要在网站页脚贴一个 logo，就能白嫖一年 67 元的代金券。新人用户也有一个月的 61 元代金券\n\n\n3.3.1 创建 CDN 服务  进入控制台，点击创建 CDN 服务，按如下格式填写\n\n创建好了之后，如果访问 img1.text.top，那么就是经过了 cdn 的，如果访问img.text.top 即为源站\n此时你可以修改 lsky pro存储策略  中的图片访问 url，让 lsky 直接返回 img1.text.top 的连接\n\n3.3.2 回源 host创建好了之后，还需要进一步配置。在回源管理中，修改回源 host 为源站域名。如果是👆图创建的样式，那么源站域名就是img.text.top\n\n解释一下这里的回源 host\n\n简单来说就是浏览器在访问 img1.text.top 加速域名的时候，又拍云服务器会访问 img.text.top 进行回源操作\n此时他会发送一个 host，如果这里不设置，默认的 host 就是访问域名，即img1.text.top\n但是我们的云服务器中 nginx 可能没有配置 img1.text.top 的反代规则，此时就会被  随机跳到  一个配置了反代的端口上，无法正确跳转到img.text.top（此情况是配置了多个 nginx 反代，如果只有一个服务，可能不会出现跳转错误）\n配置了 host 为 img.text.top 后，CDN 进行回源的时候，就会告诉服务器我是img.text.top，服务器的反代就能正确识别并返回服务\n\n这个回源 host 在加速诸如 vercel、netlify、GitHub Pages 等具有  域名访问控制  的服务的时候尤为重要。比如下图就是因为我没有配置 host，导致 CDN 加速发送的请求域名并没有被 vercel 收录，也就不知道要转到那个服务上，于是便无法访问\n\n3.3.3 https 设置  使用 cdn 加速后，即便你源站有 ssl 证书，cdn 加速后的域名也不一定能正常访问\n\n此时就需要在 cdn 的配置中添加 https 证书\n\n这里可以添加自有证书，也可以在又拍云 CDN 申请单域名证书。又拍云申请 ssl 证书的操作还是挺快的，几分钟就好了，这点值得表扬\n\n3.3.4 缓存控制  这里还需要配置一下缓存控制，否则默认会是全站加速\n\n对于 lsky 来说，我们需要加速的只是图片资源你，并不需要加速管理页面\n\n如果配置了缓存规则之后，进入管理页面出现了问题，那就需要配置一下不缓存规则，把管理页面、设置页面给加入进去\n\n3.3.5 源站静态资源迁移  在回源设置里面有一条是静态资源迁移，这个还是很不错的！\n\n因为又拍云的 CDN 回源到 bucket 是不用钱的，这样就相当于只需要付存储的费用就行了。因为我的站点访问量小，对于 CDN 回源而产生的存储肯定少的可怜，完全不用担心费用问题\n\n需要操作的就是添加一个云存储\n\n配置一个操作员，提供写入和读取权限，就 OK 了。不需要绑定域名\n\n在静态资源迁移里面选择这个云存储即可\n4.picgo都用图床了，肯定不能少了老朋友 Picgo\n在插件商店可以搜到 lankong 插件，开源地址 hellodk34&#x2F;picgo-plugin-lankong\n\n配置插件参考 README；我这里发现 2.3.0 BATA8 无法正常运行插件，只有 2.3.1 版本的 picgo 可以用\n\n其中关于 permission 需要注意的是，这个设置的是兰空图床的权限，也就是你上传的图片能不能在图床网站上直接被看到。并不是阿里云 OSS 那种外部无法直接访问的  私有  权限。\n注意啊注意啊 ，token 需要你自己调用curl 或者用 postman/apifox 调用 api 获取\n别像我一样傻乎乎的，用这个示例值试了好久😥\n\n5.nsfwjs 鉴 h除非你的图床不打算公开给任何人用，关闭了  注册 / 游客上传  的功能；那么我建议你设置一下鉴 h 操作。\n兰空图床支持阿里云 &#x2F; 腾讯云的内容安全，但是这俩玩意说实话，对于一个无人问津的小站点而言，价格太恐怖了。\n相比之下，nsfw 的 api 可以直接用 docker 部署，经过我的测试，效果还是不错的\nversion: &#x27;3&#x27;services:  nsfw-api:    image: penndu/nsfw-api:latest    restart: unless-stopped    hostname: nsfw-api    container_name: nsfw-api    ports:      - &quot;14727:3000&quot;\n\n在角色组设置里面，可以设置图片审核。配置好 docker 之后，url 末尾需要带一个 /classify 才能正常调用。默认的阈值是 60，实在太低了，保险起见，越低越好。\n请注意，部署的 nsfw 的服务必须要能够外网访问，填机器本地 IP 是不行的\n这里我设置成了 15，能屏蔽掉很大一部分的 h 图\n\n但是违反其他规定的图片就需要你人工审核（或者去买阿里云 &#x2F; 腾讯的内容审核）了\n个人建议，关闭游客上传 &#x2F; 注册功能——除非你打算建立一个完全公开的图床站点，并对你图床的内容负责。\n\n配置好了之后，如果有用户上传奇怪的图片，会直接禁止，上传失败\n6. 修改页脚  使用 vscode(remote-ssh) 进入 lsky 的 docker 映射到本地的文件夹（如果你使用 nas 部署，则用 vscode 打开 smb 的文件夹，进入倒 lsky 映射到你 nas 本地的文件夹），搜索如下\npresent Lsky Pro. All rights reserved.\n\n有两个文件中都包含了页脚信息，都给他修改了就行；修改后重启容器就能生效\n\n如图，我的图床的页脚就是修改后的信息\n\n要是 lsky 后台配置项能直接加上这个配置项就好了，默认的页脚写的都还是 2018，太旧了。\nMore有任何问题，欢迎在下方评论\n","categories":["docker真好玩"],"tags":["图床","Docker"]},{"title":"【Docker】配置 wiki js","url":"/posts/1924263382/","content":"wikijs 是一个在线多人协作（带 git 版本管理）的 wiki 套件\n\n\n相比于其他 wiki 的展示功能为主，wikijs 将权限管理 + 多人协作作为了首个要素，其支持富文本编辑器 &#x2F;mardown 编辑器 &#x2F;html 源码编辑\n1.Docker-cli 部署\n在云服务器安装 https://docs.requarks.io/install/ubuntu\n\n可以跟着官方的指令走，下面节选了最终 3 个创建容器的命令\n\n配置密钥\nmkdir -p /etc/wiki# Generate DB secretopenssl rand -base64 32 &gt; /etc/wiki/.db-secret# Create internal docker networkdocker network create wikinet# Create data volume for PostgreSQLdocker volume create pgdata\n\n配置数据库\ndocker create \\--name=db \\-e POSTGRES_DB=wiki \\-e POSTGRES_USER=wiki \\-e POSTGRES_PASSWORD_FILE=/etc/wiki/.db-secret \\-v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro \\-v pgdata:/var/lib/postgresql/data \\--restart=unless-stopped \\-h db \\--network=wikinet \\postgres:11\n配置主容器\ndocker create --name=wiki \\-e DB_TYPE=postgres \\-e DB_HOST=db \\-e DB_PORT=5432 \\-e DB_PASS_FILE=/etc/wiki/.db-secret \\-v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro \\-e DB_USER=wiki \\-e DB_NAME=wiki \\-e UPGRADE_COMPANION=1 \\--restart=unless-stopped \\-h wiki \\--network=wikinet \\-p 3000:3000 -p 3443:3443 \\ghcr.io/requarks/wiki:2\n\n升级伴侣\ndocker create \\--name=wiki-update-companion \\-v /var/run/docker.sock:/var/run/docker.sock:ro \\--restart=unless-stopped \\-h wiki-update-companion \\--network=wikinet \\ghcr.io/requarks/wiki-update-companion:latest\n\n配置防火墙\nsudo ufw allow sshsudo ufw allow httpsudo ufw allow httpssudo ufw --force enable\n\n运行容器\ndocker start dbdocker start wikidocker start wiki-update-companion\n\n到这一步，就可以用 3000 端口访问了\n2.docker-compose 部署https://docs.requarks.io/install/docker\ndocker-compose 最好的一点就是方便管理，不需要单独管理上面的 3 个容器，而是用一条命令就能同时启停容器\nversion: &quot;3&quot;services:  db:    image: postgres:11-alpine    environment:      POSTGRES_DB: wiki      POSTGRES_PASSWORD: wikijsrocks      POSTGRES_USER: wikijs    logging:      driver: &quot;none&quot;    restart: unless-stopped    volumes:      - db-data:/var/lib/postgresql/data  wiki:    image: ghcr.io/requarks/wiki:2    depends_on:      - db    environment:      DB_TYPE: postgres      DB_HOST: db      DB_PORT: 5432      DB_USER: wikijs      DB_PASS: wikijsrocks      DB_NAME: wiki    restart: unless-stopped    ports:      - &quot;80:3000&quot;volumes:  db-data:\n\n3. 配置证书 let’s encrpy配置证书需要多指定两个环境变量，分别是你的域名以及用于申请证书的邮箱\n-e &quot;LETSENCRYPT_DOMAIN=wiki.example.com&quot; \\-e &quot;LETSENCRYPT_EMAIL=admin@example.com&quot; \\-p 443:3443\n\n如果不这么做，则需要在 nginx 反向代理上配置证书\n4. 超级方便的 sqlite（个人推荐）上面的两个办法，都需要多建一个数据库的容器。对于云服务器来说，内存是及其宝贵的资源。\n如果你和我一样，wikijs 只作为简单的记录用途，而不是生产用途（比如公司内部协作写文档），则可以使用轻便快捷的 sqlite 来作为数据库，避免多开一个容器的烦恼！\ndocker run -d -p 8080:3000 --name wiki --restart unless-stopped -e &quot;DB_TYPE=sqlite&quot; requarks/wiki\n\n一条命令搞定，不需要弄什么第二个数据库，怎么样，是不是很爽？\n\n参考https://b4d.sablun.org/blog/2021-02-07-instant-wikijs-with-docker/\n\n注意：请确认您不是在生产环境下使用 sqlite。相比于其他数据库，sqlite 的主要优势是方便，其性能是不如 mysql 等数据库的！\n4. 评论  默认的评论连回复都不支持，也没有一个管理页面和通知，如果要把 wiki 展示出来，这样就非常不方便\n建议配置一下 artalk 评论系统 教程\n","categories":["docker真好玩"],"tags":["wikijs","Docker"]},{"title":"【Docker】限制已运行容器的 Cpu 和内存","url":"/posts/2589797340/","content":"docker 限制已运行容器的 Cpu 和内存\n\n\n1. 问题描述  最近云服务器的内存经常不够用，而且是  莫名其妙  的增多，在腾讯云的控制台里面看，4gb 的内存占用了 3.2 gb，就卡到连 ssh 都连不上了\n\nPS: 已换过网络和设备，确认不是用户端网络问题导致无法 ssh\n\n\n实在没辙了，只能把我的几个不热门的 kook-bot 移植到 replit 白嫖，再限制一下 lsky 图床 docker 镜像的内存用量\n\n其实主要是 nsfw-api 的内存用量，我发现有人故意给我的图床上传 h 图。lsky 后台由于鉴黄不通过，不允许上传，也看不到是谁干的。隔这压力测试呢？\n我的图床基本只对自己的博客使用。开放游客上传，也只是方便大家临时上传一些图片，还请大家手下留情！！！😥\n\n这个操作我做了几次，也算是一个高频操作了。在此记录一下如何更改一个正在运行中容器的内存限制\n2. 修改内存限制  先使用 ps 命令查看当前容器和对应的 id\ndocker ps\n\n可以看到，lsky 图床和 nsfw 的镜像分别是第二个和第三个\n\n再用 stats 命令查看当前的状态\ndocker stats\n\n\n可以看到，图床的内存没有进行限制，nsfw 的内存已经被限制到了 618mb，当前已用 565mb，基本要满了.\n重启一下容器，发现初始化的时候  只需要 100mb左右的内存，合计着现在就有人在往图床里面上传图片？🤣🤣🤣\n\n这怎么行，直接给它内存限制干到 512mb，能省一点内存是一点，不能因为图床导致我服务器卡死。\n修改限制，要使用的是 container update 命令\n\n参考文档\n\n\n\n名称, 简写\n默认值\n描述\n\n\n\n–blkio-weight\n0\n阻塞 IO(相对权重)，介于 10 和1000之间，或 0 禁用(默认为0)\n\n\n–cpu-period\n0\n限制 CPU CFS(完全公平的调度程序)周期\n\n\n–cpu-quota\n0\n限制 CPU CFS(完全公平的调度程序)配额\n\n\n–cpu-rt-period\n0\n限制 CPU 实时周期(以微秒为单位)\n\n\n–cpu-rt-runtime\n0\n以微秒为单位限制 CPU 实时运行时间\n\n\n–cpu-shares, -c\n0\nCPU 份额(相对权重)\n\n\n–cpuset-cpus\n\n允许执行的 CPU(0-3,0)\n\n\n–cpuset-mems\n\n允许执行的内存率(0-3,0.1)\n\n\n–kernel-memory\n\n内核内存限制\n\n\n–memory, -m\n\n内存限制\n\n\n–memory-reservation\n\n内存软限制\n\n\n–memory-swap\n\n交换限制等于内存加交换：-1以启用无限制的交换\n\n\n–restart\n\n重新启动在容器退出时应用的策略\n\n\n模板如下\n\n\n\n\n\ndocker container update 容器名 --memory=&quot;2g&quot;  --memory-swap=&quot;-1&quot;\n\n上面的命令会限制容器的内存为 2gb，交换内存设置为-1（以启用无限制的交换）\n比如我现在想修改 nsfw 容器的内存限制，应该如下操作\ndocker container update nsfw-api --memory=&quot;0.5g&quot; \n\n然后发现报错了\nError response from daemon: Cannot update container 418fc2a79fa7ad2e637babe17424ee60e9027ef4a7fada3f279864e76bdaaa10: Memory limit should be smaller than already set memoryswap limit, update the memoryswap at the same time\n\n大概意思是让我们同时更新交换内存\ndocker container update nsfw-api --memory=&quot;0.5g&quot;  --memory-swap=&quot;-1&quot;\n\n现在就 ok 了，执行成功会在命令的下一行显示镜像的名字\nnsfw-api\n\n在 stats 看一下，发现已经修改成功了\ndocker stats\n\n\n修改其他容器的效果也是一样的，目的已经达到啦！\n3. 修改 cpu 限制  下面的命令意思是限制容器只能使用主机上两个 cpu\ndocker container update  容器名 --cpus=2\n\n所谓两个 CPU，其实就是主机上 CPU 的两个线程。比如如果你的云服务器是 2 核心 4 线程的，那么这个限制就代表该容器只能使用 2 个线程。\n\nhttps://www.cnblogs.com/sparkdev/p/8052522.html\nhttps://zhuanlan.zhihu.com/p/388012843\n\n","categories":["docker真好玩"],"tags":["Docker"]},{"title":"【Vercel】教你部署 imsyy/home 个人主页","url":"/posts/951011662/","content":"本篇博客教你如何部署一个自己的个人主页\n项目地址：https://github.com/imsyy/home\n\n\n1.fork 仓库 +vercel 部署  首先我们点击 fork，将仓库复刻到自己的账户\n\n随后进入 vercel，点击dashboard-add new-project\n\n选择你复刻的仓库\n\n然后什么都不用改，直接 deploy\n\n等待部署成功，点击 domains，在这里添加个  你自己的域名 + 解析。否则 vercel 默认的域名 无法直接访问\n\n到这里就已经部署成功了，可以不用管 vercel 了；\n克隆  下我们 fork 的仓库，接下来就是修改配置文件！\n\n备注，env 中已有的配置在这里不提\n\n1.1 本地预览  本地预览需要我们在本地安装好 node.js 环境以及 npm 包管理器，随后安装 yarn\nnpm install yarn\n\n安装完成后，进入项目所在文件夹，先执行 yarn install 安装依赖项。\nyarn install\n\n\n如果下载依赖的时候卡在其中某一个了，可能是网络问题，可以尝试给 npm&#x2F;yarn 的下载器配置镜像源【参考博客】\n\n依赖项搞定了，用 dev 查看预览页面\nyarn dev\n\n注意，第一次查看预览页面的时候，加载会非常慢，这是正常情况\nVITE v3.1.8  ready in 844 ms➜  Local:   http://127.0.0.1:3000/                       ➜  Network: use --host to expose    \n\n后续的修改，可以先在本地预览成功后，再部署到 vercel\n\n1.2 部署到云服务器  如果你想部署到云服务器，则使用\nyarn build\n\n会生成一个 dist 文件夹，弄到云服务器上就可以了（不会用，没试过）\n1.3 vercel 访问问题  如果根据上面的步骤设置了解析后，还是出现访问缓慢甚至无法访问的问题，可以将域名的 A 或者 cname 解析更改为下面的国内访问较快的解析\n76.223.126.88cname-china.vercel-dns.com\n\n下图是 vercel 官方对于此问题的说明，需要我们修改指向 vercel 的 dns 记录\n\n2. 社交链接  这里光是修改 .env 是不够的，因为作者暂时还没有写社交链接的判断，即便你把所有社交链接的环境变量都注释掉，他还是会显示出来\n这里需要我们修改代码，不算难，一步一步来就行\nsrc\\components\\SocialLinks\\index.vue\n\n打开这个文件，最顶部是 &lt;/template&gt; 包裹的一个div\n&lt;template&gt;  &lt;!-- 社交链接 --&gt;  &lt;div class=&quot;social&quot;&gt;  ....  &lt;/div&gt;&lt;/template&gt;\n\n我们需要修改的就是这里面的代码\n2.1 注释掉不需要的  比如下面这一个 &lt;a &lt;/a&gt;  包裹的就是 tg 的社交链接。如果你不需要，那就直接把它注释掉\n&lt;!-- &lt;a   id=&quot;telegram&quot;   :href=&quot;socialLinks.telegram&quot;   target=&quot;_blank&quot;   @mouseenter=&quot;changeTip&quot;   @mouseleave=&quot;leaveTip&quot;   &gt;    &lt;Icon size=&quot;24&quot;&gt;        &lt;Telegram /&gt;    &lt;/Icon&gt;&lt;/a&gt; --&gt;\n\n2.2 增加没有的社交链接  根据上面这个模板的格式，我们可以新增自己需要的社交链接，比如我就新增了一个 gitee 的链接。需要修改的只有 id 和icon里面的图标名字GitSquare\n&lt;a  id=&quot;gitee&quot;  :href=&quot;socialLinks.gitee&quot;  target=&quot;_blank&quot;  @mouseenter=&quot;changeTip&quot;  @mouseleave=&quot;leaveTip&quot;&gt;  &lt;Icon size=&quot;24&quot;&gt;    &lt;GitSquare /&gt;  &lt;/Icon&gt;&lt;/a&gt;\n\n这里的 Icon 图标都是从一个本地文件导入的，文件路径为\nnode_modules\\@vicons\\fa\\es\\index.d.ts\n\n你可以在这里面  搜索已有的图标名字，并回到社交链接的 src\\components\\SocialLinks\\index.vue 文件，修改如图所示的代码，新增图标（必须要在这里新增， 再去 html 里面引用）\nimport &#123; Github, Qq, Telegram, Twitter,GitSquare &#125; from &quot;@vicons/fa&quot;;\n\n\n最后，在 TipData 中新增一个点击会显示的文字，这里的 id 要和上面写的一样\nlet socialTipData = &#123;  github: &quot; 去 Github 看看 &quot;,  gitee: &quot; 去 Gitee 看看 &quot;,  qq: &quot; 有什么事吗 &quot;,  email: &quot; 来封 Email&quot;,  telegram: &quot; 你懂的 ~&quot;,  twitter: &quot; 你懂的 ~&quot;,&#125;;\n\n在社交链接的地址里面，新增 gitee 的地址，参考已有的 github 的地址的写法\nconst socialLinks = reactive(&#123;  github: &quot;https://github.com/&quot; + import.meta.env.VITE_SOCIAL_GITHUB,  gitee: &quot;https://gitee.com/&quot; + import.meta.env.VITE_SOCIAL_GITEE,  ...\n\n最后，还需要在鼠标移入移出事件中，新增一个 case，照着已有的抄就行\ncase &quot;gitee&quot;:  socialTip.value = socialTipData.gitee;  return true;\n\n最后的最后，回到 .env 环境变量，新增一个VITE_SOCIAL_GITEE，填写你的 gitee 用户名\nVITE_SOCIAL_GITEE = &quot;musnow&quot;\n\n搞定啦！\n\n2.3 添加没有的 icon如果一个图标在本地路径没有，可以试着用下面的办法导入一个本地图片，或者是图片 url\n本地图片的存储路径为public/images/\n&lt;a  id=&quot;gitee&quot;  :href=&quot;socialLinks.gitee&quot;  target=&quot;_blank&quot;  @mouseenter=&quot;changeTip&quot;  @mouseleave=&quot;leaveTip&quot;&gt;  &lt;img     src=&quot;/images/icon/gitee.png&quot; height=&quot;24&quot;  /&gt;&lt;/a&gt;\n\n但是上面这样弄会有边距问题，可以看到 gitee 和 qq 之间的边距比右侧更短，暂时没找到解决办法\n\n嗨嗨嗨 ，经过半小时的折腾，我找到解决办法了。在本地yarn dev 中 f12 找到如下的代码，这里要做的就是看其他图标的代码是怎么写的\n\n这里能看到，他们都用了一个 span 的xicon class，我们要做的，就是给这个 img 也加上一个xicon\n&lt;a  id=&quot;gitee&quot;  :href=&quot;socialLinks.gitee&quot;  target=&quot;_blank&quot;  @mouseenter=&quot;changeTip&quot;  @mouseleave=&quot;leaveTip&quot;&gt;  &lt;span class=&quot;xicon&quot; style=&quot;font-size: 24px;&quot;&gt;    &lt;img src=&quot;/images/icon/gitee.png&quot; height=&quot;24&quot;/&gt;  &lt;/span&gt;&lt;/a&gt;\n\n现在就 OK 了！\n\n2.4 添加 env 判断，若为空不显示  作者写的版本是写死的，即便你的 env 里面没有那个社交链接，他还是会展示在主页上。我的需求就是如果 env 里面  没有这个社交链接 / 为空，那就不展示这个社交链接的图标\n# 社交链接VITE_SOCIAL_GITHUB = &quot;musnows&quot;VITE_SOCIAL_GITEE = &quot;musnow&quot;VITE_SOCIAL_QQ = &quot;&quot;VITE_SOCIAL_EMAIL = &quot;&quot;VITE_SOCIAL_TELEGRAM = &quot;&quot;\n\n比如我个人的需求就不需要后面的 3 个，那就把环境变量设置为空，且自动不展示\n这时候要做的就是修改代码，添加一个判断语句（我没学过前端，百度到的）\n先在社交链接的文件里面，添加下面这个变量定义（可以理解为他就是一个类，通过  类名. 变量  的方式访问）\nlet socialEnv = &#123;  github: import.meta.env.VITE_SOCIAL_GITHUB,  gitee: import.meta.env.VITE_SOCIAL_GITEE,  kook: import.meta.env.VITE_SOCIAL_KOOK,  qq: import.meta.env.VITE_SOCIAL_QQ,  email: import.meta.env.VITE_SOCIAL_EMAIL,  telegram: import.meta.env.VITE_SOCIAL_TELEGRAM,  twitter: import.meta.env.VITE_SOCIAL_TWITTER,  travellings: import.meta.env.VITE_SOCIAL_TRAVELLINGS,&#125;\n\n随后要做的，就是在最上面的 div class=&quot;link&quot; 里面添加一个判断语句（需要给每一项都添加，注意名字别搞混了）\n&lt;span v-if=&quot;socialEnv.twitter&quot;&gt;  &lt;a    id=&quot;twitter&quot;    :href=&quot;socialLinks.twitter&quot;    target=&quot;_blank&quot;    @mouseenter=&quot;changeTip&quot;    @mouseleave=&quot;leaveTip&quot;  &gt;    &lt;Icon size=&quot;24&quot;&gt;      &lt;Twitter /&gt;    &lt;/Icon&gt;  &lt;/a&gt;&lt;/span&gt;\n\n这时候，就会自动判断这个环境变量是不是为空，如果为空那就不显示\n\n测试一下VITE_SOCIAL_GITHUB = &quot;musnows&quot;VITE_SOCIAL_GITEE = &quot;musnow&quot;VITE_SOCIAL_KOOK = &quot;https://kook.top/gpbTwZ&quot;VITE_SOCIAL_QQ = &quot;&quot;VITE_SOCIAL_EMAIL = &quot;&quot;VITE_SOCIAL_TELEGRAM = &quot;&quot;VITE_SOCIAL_TWITTER = &quot;&quot;VITE_SOCIAL_TRAVELLINGS = &quot;https://www.travellings.cn/go.html&quot;\n\n\nVITE_SOCIAL_GITHUB = &quot;&quot;VITE_SOCIAL_GITEE = &quot;musnow&quot;VITE_SOCIAL_KOOK = &quot;https://kook.top/gpbTwZ&quot;VITE_SOCIAL_QQ = &quot;111&quot;VITE_SOCIAL_EMAIL = &quot;&quot;VITE_SOCIAL_TELEGRAM = &quot;&quot;VITE_SOCIAL_TWITTER = &quot;&quot;VITE_SOCIAL_TRAVELLINGS = &quot;https://www.travellings.cn/go.html&quot;\n\n\n完美达成目标！\n变量复用  可以把原本的 socialLinks 改成使用socialEnv，避免两个都是 import，太长了不好看\nlet socialEnv = &#123;  github: import.meta.env.VITE_SOCIAL_GITHUB,  gitee: import.meta.env.VITE_SOCIAL_GITEE,  kook: import.meta.env.VITE_SOCIAL_KOOK,  qq: import.meta.env.VITE_SOCIAL_QQ,  email: import.meta.env.VITE_SOCIAL_EMAIL,  telegram: import.meta.env.VITE_SOCIAL_TELEGRAM,  twitter: import.meta.env.VITE_SOCIAL_TWITTER,  travellings: import.meta.env.VITE_SOCIAL_TRAVELLINGS,&#125;// 社交链接地址const socialLinks = reactive(&#123;  github: &quot;https://github.com/&quot; + socialEnv.github,  gitee: &quot;https://gitee.com/&quot; + socialEnv.gitee,  kook: socialEnv.kook,  qq: &quot;https://wpa.qq.com/msgrd?v=3&amp;uin=&quot; +    socialEnv.qq +    &quot;&amp;site=qq&amp;menu=yes&quot;,  email: &quot;mailto:&quot; + socialEnv.email,  telegram: &quot;https://t.me/&quot; + socialEnv.telegram,  twitter: &quot;https://twitter.com/&quot; + socialEnv.twitter,  travellings: socialEnv.travellings,&#125;);\n\n3. 站点首页文字字体\nhttps://github.com/imsyy/home/issues/49\n\n如果你修改了站点首页的文字，会发现一部分文字没办法正常显示\n\n根据作者在 issue 里面提供的链接，下载了完整的字体文件\nhttps://file.4everland.app/font/Other/Pacifico-Regular.ttf如果上面的链接坏了，可以去我的仓库里面下https://github.com/musnows/musnows/blob/main/Pacifico-Regular.ttf\n\n将其粘贴到以下路径，覆盖原本的字体文件\npublic/font\n\n现在就 Ok 了\n\n4. 网站 logo 配置 4.1 浏览器顶部图标 修改 index.html 中的如下字段\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://s1.hdslb.com/bfs/static/jinkela/long/font/regular.css&quot; /&gt;&lt;link rel=&quot;icon&quot; href=&quot;/images/icon/myPNG.jpg&quot;&gt;&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/images/icon/myPNG-r.jpg&quot;&gt;\n\n将你自己的 logo 图标放到 public/images 下即可。这里修改的是浏览器顶部的图标\n4.2 主页图标  主页图标的路径如下\nsrc/components/Message/index.vue\n\n里面有注释，找到字段修改即可\n&lt;!-- Logo --&gt;&lt;div class=&quot;logo&quot;&gt;  &lt;img class=&quot;logo-img&quot; src=&quot;/images/icon/logo.png&quot; alt=&quot;logo&quot; /&gt;  &lt;div class=&quot;name&quot;&gt;    &lt;span class=&quot;bg&quot;&gt;&#123;&#123; siteUrl[0] &#125;&#125;&lt;/span&gt;    &lt;span class=&quot;sm&quot;&gt;.&#123;&#123; siteUrl[1] &#125;&#125;&lt;/span&gt;  &lt;/div&gt;&lt;/div&gt;\n\n5. 网站链接配置  在环境变量 .env 中写明了配置网站的位置\n# 网站链接## 请在 src/components/Links/index.vue 中设置\n\n首先是这里的图标，还是在老位置node_modules\\@vicons\\fa\\es\\index.d.ts，找你需要的图标导入\nimport &#123;  Link,  Blog,  CompactDisc,  Cloud,  Compass,  Book,  Flask,  GitSquare,  Image,  GitAlt&#125; from &quot;@vicons/fa&quot;;\n\n随后网站链接就照着抄，起一个新的就可以了\n&#123;  icon: Compass,  name: &quot; 起始页 &quot;,  link: &quot;https://nav.imsyy.top/&quot;,&#125;,\n\n建议链接不超过 6 个，不然就会变成下面这样\n\n6.footer 配置src\\components\\Footer\\index.vue\n\n在页脚配置网站用户和链接，修改如下字段\n&lt;span  &gt;Copyright&amp;nbsp;&amp;copy;&amp;nbsp;&#123;&#123; fullYear &#125;&#125;  &lt;a href=&quot; 链接 &quot;&gt; 名字 &lt;/a&gt;&lt;/span&gt;\n\n如果你的站点经过了备案，修改如下字段\n&lt;a href=&quot;https://beian.miit.gov.cn&quot; target=&quot;_blank&quot;  &gt; 豫 ICP 备 2022018134 号 -1&lt;/a&gt;\n\n如果没有备案，可以把这部分注释掉\n7. 音乐播放器配置  这部分可能有老哥不太清楚，我顺便说一下吧!\n在环境变量里面，修改最底部的播放 id 就可以了\n# 歌曲 API 地址## 备用：https://api.wuenci.com/meting/api/VITE_SONG_API = &quot;https://api-meting.imsyy.top&quot;# 歌曲服务器 (netease- 网易云, tencent-qq 音乐)VITE_SONG_SERVER = &quot;netease&quot;# 播放类型 (song- 歌曲, playlist- 播放列表, album- 专辑, search- 搜索, artist- 艺术家)VITE_SONG_TYPE = &quot;playlist&quot;# 播放 IDVITE_SONG_ID = &quot;2893005411&quot;\n\nid 在哪儿找？登陆你的网页版网易云 &#x2F;QQ 音乐，找到一个歌单\n\n此处网页链接里面的 ID 就是播放 id，复制过来就 OK 了\nhttps://music.163.com/#/playlist?id=2024518101ID 是 2024518101\n\n8. 背景图设置src/components/store/index.vue\n\n这里有不少配置项，其中关于壁纸种类有 3 中\nstate: () =&gt; &#123;    return &#123;        innerWidth: null, // 当前窗口宽度        coverType: &quot;0&quot;, // 壁纸种类        musicIsOk: false, // 音乐是否加载完成        musicVolume: 0, // 音乐音量;        musicOpenState: false, // 音乐面板开启状态        backgroundShow: false, // 壁纸展示状态        boxOpenState: false, // 盒子开启状态        mobileOpenState: true, // 移动端开启状态        mobileFuncState: false, // 移动端功能区开启状态        setOpenState: false, // 设置页面开启状态        playerState: false, // 当前播放状态        playerTitle: null, // 当前播放歌曲名        playerArtist: null, // 当前播放歌手名        playerLrc: &quot; 歌词加载中 &quot;, // 当前播放歌词    &#125;&#125;,\n\n可以在 backgound 里面找到壁纸 3 个种类的不同：0 是本地壁纸，随机 1 到 10（可以在本地新增你喜欢的壁纸，并修改这里的随机数范围）\n0 是默认的几张本地壁纸，1 是 bing，2 是随机风景，3 是随机二刺螈👻\n&lt;el-radio label=&quot;0&quot; size=&quot;large&quot; border&gt; 默认壁纸 &lt;/el-radio&gt;&lt;el-radio label=&quot;1&quot; size=&quot;large&quot; border&gt;每日一图 &lt;/el-radio&gt;&lt;el-radio label=&quot;2&quot; size=&quot;large&quot; border&gt; 随机风景 &lt;/el-radio&gt;&lt;el-radio label=&quot;3&quot; size=&quot;large&quot; border&gt; 随机动漫&lt;/el-radio&gt;\n\n咳咳，才发现原来背景图可以在前端直接设置呀？点击左侧留言，再点击时间胶囊右侧的设置按钮。不过目前只能设置这一个内容，而且这个设置随着网页刷新会被覆盖掉，建议在后端设置好默认的壁纸\n\n9. 时间胶囊增加站点运行时间  点击左侧的网站介绍（就是社交链接上面那个面板）能打开时间胶囊。默认显示的信息挺不错的，但是还空了一块，这不得把站点运行时间给加上？\n\n参考 https://blog.csdn.net/jay_chou345/article/details/110201897\n\n将这一串代码添加到 src/components/TimeCapsule 的&lt;script setup&gt;和 &lt;/script&gt; 之间\n// 站点存活时间let runTime = &#123;  year: import.meta.env.VITE_SITE_YAER,  month: import.meta.env.VITE_SITE_MONTH,  day: import.meta.env.VITE_SITE_DAY,&#125;function secondToDate(second) &#123;  if (!second) &#123;      return 0;  &#125;  var time = new Array(0, 0, 0, 0, 0);  if (second &gt;= 365 * 24 * 3600) &#123;      time[0] = parseInt(second / (365 * 24 * 3600));      second %= 365 * 24 * 3600;  &#125;  if (second &gt;= 24 * 3600) &#123;      time[1] = parseInt(second / (24 * 3600));      second %= 24 * 3600;  &#125;  if (second &gt;= 3600) &#123;      time[2] = parseInt(second / 3600);      second %= 3600;  &#125;  if (second &gt;= 60) &#123;      time[3] = parseInt(second / 60);      second %= 60;  &#125;  if (second &gt; 0) &#123;      time[4] = second;  &#125;  return time;&#125;function setTime() &#123;  //month 要少一个月，不然会出问题。即 month 的范围为 0-11  var create_time = Math.round(new Date(Date.UTC(runTime.year, runTime.month,runTime.day, 0, 0, 0)).getTime() / 1000);  var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000);  var currentTime = secondToDate((timestamp-create_time));  var currentTimeHtml = currentTime[0] + &#x27; 年 &#x27; + currentTime[1] + &#x27; 天 &#x27;      + currentTime[2] + &#x27; 时 &#x27; + currentTime[3] + &#x27; 分 &#x27; + currentTime[4]      + &#x27; 秒 &#x27;;  if(document.getElementById(&quot;htmer_time&quot;)!=null)      document.getElementById(&quot;htmer_time&quot;).innerHTML = &quot; 本站已经苟活 &quot;+currentTimeHtml;&#125;// 即时刷新站点存活时间setInterval(setTime, 1000);\n\n随后在顶部的模板末尾的 &lt;/div&gt; 前添加如下代码\n&lt;span class=&quot;text&quot;&gt;  &lt;p id=&quot;htmer_time&quot;&gt;&lt;/p&gt;&lt;/span&gt;\n\n环境变量 .env 中添加如下字段\n# 站点运行时间（显示在时间胶囊中）## 注意：月份的范围是 0-11，否则会有 bugVITE_SITE_YAER = 2023VITE_SITE_MONTH = 0VITE_SITE_DAY  = 1\n\n这样就 OK 啦！\n\n当我开了一个 pull request 后，源项目作者提供了一个更简单的代码版本。该版本更加精简，但是不能显示秒数，不过完全够用了！\n\nhttps://github.com/imsyy/home/pull/63\n\n环境变量\nVITE_SITE_START = &quot;2020-10-24&quot;\n\nvue 中代码\n&lt;span class=&quot;text&quot;&gt;    &lt;p id=&quot;htmer_time&quot;&gt;&#123;&#123; startDateText &#125;&#125;&lt;/p&gt;&lt;/span&gt;\n\nlet startDate = ref(import.meta.env.VITE_SITE_START);let startDateText = ref(null);// 建站日期统计函数const siteDateStatistics = (startDate) =&gt; &#123;    const currentDate = new Date();    const differenceInTime = currentDate.getTime() - startDate.getTime();    const differenceInDays = differenceInTime / (1000 * 3600 * 24);    const differenceInMonths = differenceInDays / 30;    const differenceInYears = differenceInMonths / 12;    if (differenceInYears &gt;= 1) &#123;        return ` 本站已经苟活了 $&#123;Math.floor(differenceInYears)&#125; 年 $&#123;Math.floor(differenceInMonths % 12)&#125; 月 $&#123;Math.round(differenceInDays % 30)&#125; 天 `;    &#125; else if (differenceInMonths &gt;= 1) &#123;        return ` 本站已经苟活了 $&#123;Math.floor(differenceInMonths)&#125; 月 $&#123;Math.round(differenceInDays % 30)&#125; 天 `;    &#125; else &#123;        return ` 本站已经苟活了 $&#123;Math.round(differenceInDays)&#125; 天 `;    &#125;&#125;onMounted(() =&gt; &#123;    startDateText.value = siteDateStatistics(new Date(startDate.value));&#125;);\n\n\n\n10. 关闭新春灯笼  春节假期结束辣！我们首页的新春灯笼也要取下来了\n找到App.vue, 注释掉里面的 import\n// 新春灯笼// import &quot;@/utils/lantern.js&quot;;\n\n\nMore…有任何问题，欢迎评论提问\n","categories":["docker真好玩"],"tags":["git","hexo","vercel"]},{"title":"【C 语言】带你用偷懒的方式刷爆二叉树 OJ 题","url":"/posts/4165981723/","content":"[TOC]\n前言  上篇博客我带大家领略了一番链式二叉树的操作，现在让我们来看看二叉树的相关题目，一起来巩固一下知识点吧！\n\n\n点我复习上一篇博客的内容！👉传送门\n\n1. 一些选择题 1.1 设一棵二叉树中有 3 个叶子结点，有 8 个度为 1 的结点，则该二叉树中总的结点数为（ ）个A.11B.12C.13  √D.14\n\n\n设 Ni 表示度为 i 的节点个数，则节点总数 N &#x3D; N0 + N1 + N2\n节点个数于节点边的关系： N 个节点的树有 N-1 个边\n边与度的关系：N - 1 &#x3D; N1 + 2 * N2\n故：N0 + N1 + N2 - 1 &#x3D; N1 + 2 * N2\n因此，得：N0 &#x3D; N2 + 1\n回到原题，N0 &#x3D; 3，N1 &#x3D; 8，可得 N2 &#x3D; 2\n因此答案是 3 + 8 + 2 &#x3D; 13\n\n1.2有 N 个元素的完全二叉树的深度是 () 答案：logN+1\n\n高度为 h 的完全二叉树，节点个数在： 2^(h - 1) - 1 &lt; n &lt;= 2^h - 1\n即log(n + 1) &lt;= h &lt; log(n + 1) + 1\n这里需要注意的是 n 左右区间的开闭问题\n完全二叉树最少的节点个数是 2^(h - 1)-1+1 个，所以是n&gt;2^(h - 1) - 1\n\n1.3 由已知遍历序列画出原本树的结构  已知某二叉树的中序遍历序列为 JGDHKBAELIMCF，后序遍历序列为 JGKHDBLMIEFCA，则其前序遍历序列为（ ）A.ABDGHJKCEFILMB.ABDGJHKCEILMF   √C.ABDHKGJCEILMFD.ABDGJHKCEIMLF\n\n这道题我刚开始的思路是错的，因为我把它当作完全二叉树来看待，但题目并没有说它是完全二叉树\n\n主要思路：可以从后续遍历确定根节点为 A，中序遍历可以确定 A 的左右子树。再继续从后序遍历中确定 A 左右子树的根节点，依次往下判断\n\n所以我画了一个分析图，如下👇\n\n已知某二叉树的前序遍历序列为 ABDEC，中序遍历序列为 BDEAC，则该二叉树（ ）A. 是满二叉树B. 是完全二叉树，不是满二叉树C. 不是完全二叉树   √D. 是所有的结点都没有右子树的二叉树\n\n这道题的思路和上一道题是一样的\n\n已知某二叉树的前序遍历序列为 5 7 4 9 6 2 1，中序遍历序列为 4 7 5 6 9 1 2，则其后序遍历序列为（ ）A.4 2 5 7 6 9 1B.4 2 7 5 6 9 1C.4 7 6 1 2 9 5  √D.4 7 2 9 5 6 1\n\n本题依旧和上面两道题思路相同！\n\n1.4 单边树  一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（ ）A. 所有的结点均无左孩子B. 所有的结点均无右孩子C. 只有一个叶子结点D. 至多只有一个结点\n\n如果前序遍历和后序遍历序列正好相反，说明它是一个单边树，比如下面这前序和中序序列所构成的树的结构:\n12345（纵向）\n54321\n对于单边树，只有一个叶子节点\n\n1.520. 如果一颗二叉树的前序遍历的结果是 ABCD，则满足条件的不同的二叉树有（ ）种A.13B.14 √C.15D.16\n\n\n首先这棵二叉树的高度一定在 3~4 层之间:\n三层：\nA(B(C,D),()), A((),B(C,D)), A(B(C,()),D), A(B((),C),D),\nA(B,C(D,())), A(B,C((),D))\n四层：\n如果为四层，就是单边树，每一层只有一个节点，除过根节点，其他节点都有两种选择，在上层节点的左边还是右边，所以 222 共 8 种\n总共为 14 种。\n\n\n2.OJ 题刷起来！KY11 二叉树遍历\n牛客网 KY11 二叉树遍历 👉传送门\n\n\n这道题要求我们用先序遍历的操作从  一个数组中读出一个树，并构建出树的基本结构，再用中序遍历的方式打印出这颗树\n之前我们学习了前序遍历的操作，这里只需要把前序遍历中的 printf 操作改成构建新树即可\n\n因为涉及道 i 的多次调用，所以函数中的 i 需要取地址，必须保证多次调用的 i 会同步 ++\n构建完树的节点，并赋值后，需要递归构建左右子树，最后返回节点的地址\n题目中的 #代表 NULL，直接 return 空即可\n\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;typedef char BTDataType;typedef struct BTreeNode&#123;\tBTDataType data;\tstruct BTreeNode* left;\tstruct BTreeNode* right;&#125;BTNode;// 二叉树中序遍历 void BTreeInOrder(BTNode* root)&#123;\tif (root == NULL)&#123;\t\treturn ;\t&#125;\t\tBTreeInOrder(root-&gt;left);    printf(&quot;%c &quot;, root-&gt;data);\tBTreeInOrder(root-&gt;right);&#125;BTNode* CreatTree(char *arr,int*i)&#123;    if (arr[*i] == &#x27;#&#x27;)&#123;        (*i)++;\t\treturn NULL;\t&#125;        BTNode* newnode=(BTNode*)malloc(sizeof(BTNode));        newnode-&gt;data=arr[(*i)++];//i 必须取地址    newnode-&gt;left=CreatTree(arr,i);// 递归构建左子树    newnode-&gt;right=CreatTree(arr,i);// 递归构建右子树        return newnode;&#125;int main()&#123;    char arr[100];    scanf(&quot;%s&quot;,arr);        int i=0;    BTNode* root=CreatTree(arr,&amp;i);    BTreeInOrder(root);    return 0;&#125;\n\n100 相同的树\nleetcode：100. 相同的树\n\n\n题目要求很简单，给定两颗树的根节点，要求我们判断这两棵树是否相同\n\n如果两棵树都为空，树相同\n如果其中一个为空，另外一个不为空，树不同\n如果两个都不为空，但是节点值不相同，树不同\n然后再递归判断左子树和右子树，将它们的结果与 &amp;&amp; 在一起，其中一个为假，返回假\n\nbool isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;    if(p==NULL&amp;&amp;q==NULL)// 比较是否两个节点都为空，都为空是真        return true;        if(p==NULL||q==NULL)// 如果有一个为空，另外一个非空，即为假        return false;    if(p-&gt;val!=q-&gt;val)// 都不是空，判断 val 的值是否相等        return false;        // 递归判断左子树和右子树是否相等    return isSameTree(p-&gt;left,q-&gt;left)        &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);&#125;\n\n\n学会这道题后，后面一些题目其实只需要把它的代码改一改就能用了😂\n什么？你不信？那就看看下面这道题！\n\n101 对称二叉树\nleetcode：101. 对称二叉树\n\n\n题目要求很简单哈，判断是不是两边对称的树\n这和判断树相等有什么区别呢？不就是把左右子树的判断改一下就行了嘛？\n直接调用上一题的代码！注意最后的 return 值，是 p 的左和 q 的右 进行判断\nbool _isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;    if(p==NULL&amp;&amp;q==NULL)// 比较是否两个节点都为空，都为空是真        return true;        if(p==NULL||q==NULL)// 如果有一个为空，另外一个非空，即为假        return false;    if(p-&gt;val!=q-&gt;val)// 都不是空，判断 val 的值是否相等        return false;        // 递归判断左子树和右子树是否对称相等    return _isSameTree(p-&gt;left,q-&gt;right)        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;left);&#125;bool isSymmetric(struct TreeNode* root)&#123;    return _isSameTree(root-&gt;left,root-&gt;right);&#125;\n\n\n哈哈，是不是很爽，别急，后面还有可以偷懒的题目！\n\n572 另外一棵树的子树\nleetcode：572. 另一棵树的子树\n\n\n这道题我们要判断  一颗树是否为另外一棵树的子树，和判断一个字符串是不是另外一个字符串的子串很相似\n其实只需要递归判断每一个节点的左右子树是否和 subRoot 相同就可以了！\nbool _isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;    if(p==NULL&amp;&amp;q==NULL)// 比较是否两个节点都为空，都为空是真        return true;        if(p==NULL||q==NULL)// 如果有一个为空，另外一个非空，即为假        return false;    if(p-&gt;val!=q-&gt;val)// 都不是空，判断 val 的值是否相等        return false;        // 递归判断左子树和右子树是否相等    return _isSameTree(p-&gt;left,q-&gt;left)        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;right);&#125;bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot)&#123;    // if(root==NULL&amp;&amp;subRoot==NULL)    //     return true;    // if(root!=NULL&amp;&amp;subRoot==NULL)    //     return true;    // 让 isSametree 函数来比较这俩个    if(root==NULL)        return false;    if(_isSameTree(root,subRoot))        return true;    // 只要左右有一个是返回真，那就是子树    return isSubtree(root-&gt;left,subRoot)        || isSubtree(root-&gt;right,subRoot);&#125;\n\n\n是不是爽起来了？再来一道！\n\n\n226 翻转二叉树\nleetcode：226. 翻转二叉树\n\n\n这道题的思路如下哈！\n\n如果是空树，不需要翻转，直接 return\n如果非空，就把该节点的左右子树交换（这里不需要担心交换后找不到子树的问题）\n不需要单独搞空的子树，一并交换就可以\n当根节点为空的时候，return\n\n啪的一下很快哈，代码就写出来了！\nvoid _invertTree(struct TreeNode* root)&#123;    if(root==NULL)// 设置退出条件，如果根节点为空就返回        return;    // 让另外两个值来接收原本的左右节点    struct TreeNode* left=root-&gt;left;    struct TreeNode* right=root-&gt;right;    // 更改左右节点    root-&gt;right=left;    root-&gt;left=right;    // 递归子树    _invertTree(root-&gt;left);    _invertTree(root-&gt;right);&#125;struct TreeNode* invertTree(struct TreeNode* root)&#123;    if(root==NULL)// 判断空树        return NULL;    _invertTree(root);        return root;&#125;\n\n\n102 层序遍历（较难😥）\nleetcode：102. 二叉树的层序遍历\n\n\n这道题相对来说就么有那么容易了，你可能和我一样，压根没看明白题目要求中的后两个参数是用来干嘛的\n\n/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes)&#123;&#125;\n\n看了一些题解，这才算理解了这道题的要求\n\n*returnSize：存放的是二叉树的层数\n**returnColumnSizes：存放的是二叉树每一层的节点个数\n返回值要求是 int**：需要返回一个 指针数组 ，该数组中的每一个元素是一个 数组 A，数组 A 保存了二叉树每一层的节点值\n\n\n0. 错误思路  最开始我的想法是，用单独的函数计算出树的节点个数和层级，再进行一次层序遍历来得到树的值。\n但很显然，这一思路在本题是搞不通的！🤔\n1. 数组队列初始化  在上一篇博客  中，我讲述了利用队列来实现层序遍历的思路。这道 OJ 题目我们也是这么干的。不同的是，在我自己写的队列实现里，使用的是链式队列 。而本题使用 数组队列  会好一点！\n#define MAX 2000int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) &#123;    if (root == NULL)        return;    struct TreeNode* Queue[MAX];// 队列，存放节点的地址    int front = 0, tail = 0;// 指向队头和队尾\n\n2. 初始化数组  这部分会毕竟绕，先一步一步来理解\n*returnSize = 0;// 将二叉树层级初始化为 0// 存放二叉树的每一层节点的值int** ret = (int**)malloc(sizeof(int*) * MAX);// 开辟一个数组来存放每一层的节点个数*returnColumnSizes = (int*)malloc(sizeof(int*) * (MAX / 2));\n\n\nret是一个指针数组，存放的是数组 A，数组 A 里面是每一层的节点值。ret 也就是题目要求的返回值\n*returnColumnSizes开辟一个数组来保存每一层的节点数\n\n这里其实 returnColumnSizes 没有啥二级指针的必要，但是既然题目给了是 int**，我们就需要先* 解引用再 malloc 开辟数组\n3. 队列操作思路\n先让根节点入队列，tail++\n外层循环判断队列是否非空，如果非空就停止操作\n内层循环进行每一层的入队操作，这样才能得到每一层的节点值和  节点个数\n在内层循环中创建 ret 数组的  子数组，单独存放每一层的节点值\n最后将每一层的节点个数赋值给 *returnColumnSizes 数组，*returnSize++一次\n\n   struct TreeNode* head;   Queue[tail++] = root;// 根节点入队   while (front != tail)   &#123;       int Csize = 0;// 每一层的节点个数       int end = tail;       //end 是每一层最末一个节点的指针。在后续的入队列操作中 tail 会改变，所以需要保存 tail 的值       ret[*returnSize] = (int*)malloc(sizeof(int*) * (end - front));       // 为每一层开辟一个单独的数组来存放值       while (front &lt; end)       &#123;           head = Queue[front++];           ret[*returnSize][Csize++] = head-&gt;val;           // 数组赋值，同时每一层的节点个数 Csize++           if (head-&gt;left != NULL)               Queue[tail++] = head-&gt;left;           if (head-&gt;right != NULL)               Queue[tail++] = head-&gt;right;       &#125;       (*returnColumnSizes)[*returnSize] = Csize;// 赋值每一层的节点个数       (*returnSize)++;// 层数 +1   &#125;return ret;\n\n外层循环结束后，此时 ret 数组就是题目要求的结果了，返回 ret 就可以了！\n\n这里有一个小问题，当树为  空树  时，层级应该是 0。所以我们需要在第一行赋值 *returnSize = 0; 不然会执行出错\n\n\n这道题的思路是我看过题解之后才搞明白的，所以上面的只是一个思路的复现😭还是太菜了！\n\n结语  本篇刷题笔记到这里就结束啦，如果对涉及到的题目有什么不懂的地方，可以在评论区提出哦！\n\n\n要是知道，OJ 也能偷懒，嘿嘿嘿嘿……😂\n\n不过最后一道题是真的难，我还以为它和前中后序遍历一样，只是让我们遍历出数组的值呢🙃\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","OJ刷题","树"]},{"title":"【C 语言】数据结构 - 链式二叉树，详解分治递归和层序遍历","url":"/posts/2357097133/","content":"[TOC]\n前言  在之前关于树的学习中，我们接触了  二叉树  的知识点，以及  堆和堆排序  的操作。\n\n两个知识点都是超链接，可以点击查看我之前的博客，复习一下这两个知识点哦！\n\n\n接下来我们要更进一步，学习一下  链式二叉树  的操作\n本篇博客将以  知识点讲解 +OJ 题目验证  的方式来展开  链式二叉树  的内容\n\n1. 链式二叉树的基本结构  在学习链式二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。\n之前我们提到过，树最优的表示方法是  父母孩子表示法。但是对于二叉树这种度固定的树来说，可以 直接使用最简单的方法，定义两个指针指向它的左右叶子节点即可\ntypedef int BTDataType;typedef struct BTreeNode&#123;\tBTDataType data;\tstruct BTreeNode* left;\tstruct BTreeNode* right;&#125;BTNode;\n\n这里要说明的一件事是：普通树的“增删查改”操作是没有意义的，因为树并不是一个最优的储存结构。所以我们学习链式二叉树的操作时，更多学习的是  分治 递归  思想\n\n2. 分治递归思想  什么是  分治思想？\n举个例子，学校里面需要进行排查，找出本校里面  身高最高  的人。这时候校长可以去找各个年级的级组长，然后级组长去找各个班主任，班主任让班级里面的小组长统计组员身高数据。\n这时候的小组长已经可以返回一个  身高最高  的值给班主任了，然后再层层上报，校长只需要在最后上报的 4 个数据中找出一个最高的，即为本校最高的同学\n\n分治策略的思想就是  分而治之 ，即先将一个规模较大的大问题分解成若干个规模较小的小问题，再对这些小问题进行解决，得到的解，在将其组合起来得到最终的解。在上面的例子中，较小的问题就是 小组长统计组员身高 ，并上报。转换成代码语言就是return 一个值\n\n更详细的解释可以参考这篇大佬的博客👇\n五大常见算法策略之——递归与分治策略\n\n早先学习的递归求斐波那契数就运用了分治的思想👉传送门\nint fo2(int a)&#123;\tif ((a == 1) || (a == 2))\t\treturn 1;\telse\t\treturn (fo2(a - 1) )+(fo2(a- 2));//n-1 和 n-2 项&#125;\n\n当 a&#x3D;1 或者 2 的时候，就是分治的末端节点，通过 return 1 开始终止递归\n\n3. 前 &#x2F; 中 &#x2F; 后序遍历  了解了上面所说的分治递归思想后，接下来我们再学习链式二叉树的三种遍历方式\n\n前序遍历：根节点 - 左子树 - 右子树\n中序遍历：左子树 - 根节点 - 右子树\n后序遍历：左子树 - 右子树 - 根节点\n\n从前序遍历入手，我们来实操一下分治的思想：利用递归，以前序遍历的顺序打印出树中节点的值\n假设我们现在创建了一个这样的简单二叉树👇你能想出来前序遍历的打印顺序应该是咋样的吗？\n\n答案是1 2 3 4 5 6\n看到这里，你肯定一脸懵逼：啊，咋出来的？\n\n不着急，我们现给打印出来的内容加上它们的末端子树NULL，所以前序遍历的结果是：\n1 2 3 NULL NULL NULL 4 5 NULL NULL 6 NULL NULL\n\n不卖关子啦，直接下手分析这个遍历结果是怎么出来的！\n前面提到了，前序遍历的顺序是：根节点 - 左子树 - 右子树\n\n下图能让你更直观地看出来这  三种遍历方式的不同\n\n其中  前序遍历  转换为代码语言就是下面这样\n// 二叉树前序遍历 void BTreePrevOrder(BTNode* root)&#123;\tif (root == NULL)\t&#123;// 为了方便理解，把空节点也打印出来\t\tprintf(&quot;NULL &quot;);\t\treturn ;\t&#125;\tprintf(&quot;%d &quot;, root-&gt;data);\tBTreePrevOrder(root-&gt;left);\tBTreePrevOrder(root-&gt;right);&#125;\n\n在这之中，遇到根节点是 NULL 的情况，就是分治的末端情况，递归停止\n这样说来恐怕还是不清楚，要彻底弄清，我们必须要通过  画递归示意图  来解决\n\n图中某个单词打错了，画到一半才发现……请忽略它！😭\n\n如果你能理解上图中前序遍历的思路，那中序遍历和后序遍历的操作就非常简单了！猜猜怎么修改前序的代码呢？\n没错，只需要更改一下 printf 的位置就可以了！\n// 二叉树中序遍历void BTreeInOrder(BTNode* root)&#123;\tif (root == NULL)&#123;\t\tprintf(&quot;NULL &quot;);\t\treturn;\t&#125;\t\tBTreeInOrder(root-&gt;left);\tprintf(&quot;%d &quot;, root-&gt;data);\tBTreeInOrder(root-&gt;right);&#125;// 二叉树后序遍历void BTreePostOrder(BTNode* root)&#123;\tif (root == NULL)&#123;\t\tprintf(&quot;NULL &quot;);\t\treturn;\t&#125;\tBTreePostOrder(root-&gt;left);\tBTreePostOrder(root-&gt;right);\tprintf(&quot;%d &quot;, root-&gt;data);&#125;\n\n最后打印出来的结果分别是这样的，和上面的示意图完全对应！回到示意图\n\n\n3.1 通过递归遍历计算节点个数  上面的递归，我们打印出了各个节点的值\n只需要对其中一个递归的代码进行小修改，将 printf 改成计数 ++，就能把它从遍历变成计算二叉树的节点个数\n这里我选择  指针变量  的方式让主函数中能获取计数的结果\n// 二叉树节点个数void BTreeSize(BTNode* root,int* pcount)&#123;\tif (root == NULL)\t\treturn ;\t\t(*pcount)++;// 指针变量，main 函数中可调用\tBTreeSize(root-&gt;left,pcount);\tBTreeSize(root-&gt;right,pcount);&#125;\n\n\n你可以使用全局静态变量来进行计数，但是那样的计数会在下一次调用的时候叠加，需要在调用后置 0，非常不方便\n\n\n当然，我贴出来的这个方法也不是最优的，因为它需要创建一个额外的变量 count 作为参数调用，而不能直接 return 节点的数量\n\n所以就有了下面这个使用三目操作符 ? : 来进行  分治递归，计算节点个数\n\n其中根节点为空是末端情况，返回 0\n其他情况返回左子树和右子树的节点大小 +1（该节点自己）\n\n// 进阶方法int BTreeSize(BTNode* root) &#123;\treturn root == NULL ? 0 :\t\tBTreeSize(root-&gt;left)\t\t+ BTreeSize(root-&gt;right) + 1;&#125;\n\n3.2 用后续遍历的思想销毁树  当我们不需要用二叉树后，需要将其调用的内存释放\n问题就来了，如果你释放了根节点，那要咋找到它的左右子树呢？\n所以我们在释放的时候，要用  后序遍历  的顺序来进行释放，即先销毁左右子树，再向上销毁。这样就能避免找不到子树的问题\n// 二叉树销毁void BTreeDestory(BTNode** root)&#123;\tif (*root == NULL)\t\treturn;\t// 通过后续遍历的思想来摧毁树\tBTreeDestory(&amp;(*root)-&gt;left);\tBTreeDestory(&amp;(*root)-&gt;right);\tfree(*root);\t*root = NULL;// 使用二级指针可以直接在函数中置空根节点的指针&#125;\n\n3.3 前 &#x2F; 中 &#x2F; 后序遍历 OJ 题\n三道 Leetcode OJ 题\n\n144. 二叉树的前序遍历\n145. 二叉树的后序遍历\n94. 二叉树的中序遍历\n\n\n这里只对前序遍历的题目做出讲解，因为后面两个的思路完全一致，只需稍微更改代码\n\n题目给出一个树，需要你将它以前序遍历的顺序，将各个节点的值保存在一个数组中并返回它\n\n这里的输入用例是“伪代码”，[1,null,2,3]代表 1 的左子树是 NULL，右子树是 2；2 的左子树是 3，右子树是 NULL\n\n既然需要用数组来储存，首先我们需要知道这个二叉树一共有几个节点，这样才能方便我们开辟数组\n\n注意：这种接口型题目，数组都必须是  动态内存函数 malloc开辟的\n\n\n然后把前序遍历中的 printf 改成将值放入 arr 数组中即可！\n// 二叉树节点个数void BTreeSize(struct TreeNode* root,int* pcount)&#123;\tif (root == NULL)\t\treturn ;\t\t(*pcount)++;\tBTreeSize(root-&gt;left,pcount);\tBTreeSize(root-&gt;right,pcount);&#125;// 前序遍历代码void BTreePrevOrder(struct TreeNode* root,int*arr,int* i)&#123;\tif (root == NULL)&#123;\t\treturn ;\t&#125;\t    arr[(*i)++]=root-&gt;val;    // 因为在递归调用中需要多次调用不同的 i，所以需要取地址\tBTreePrevOrder(root-&gt;left,arr,i);\tBTreePrevOrder(root-&gt;right,arr,i);&#125;int* preorderTraversal(struct TreeNode* root, int* returnSize)&#123;    int count=0;    BTreeSize(root,&amp;count);// 计算树节点个数    int* arr=(int*)malloc(sizeof(int)*count);// 开辟数组    int i=0;// 下标    BTreePrevOrder(root,arr,&amp;i);    *returnSize=count;    return arr;&#125;\n\n\n\n4. 计算节点个数  在3.1中已经讲述了计算二叉树节点个数的方法，下面是更细致的节点个数计算\n4.1 叶子节点个数  众所周知，在这颗二叉树中，只有 3、5 和 6 是叶子节点\n\n想要判断一个节点是不是叶子节点，其实非常简单：只要它的左右子树都是空，就是叶子节点了。\n\n以此作为分治的末端条件，只要满足这个条件，就返回 1\n如果已经遍历到空节点了，返回 0\n其他情况，返回左子树和右子树的叶子节点个数之和\n\n// 二叉树叶子节点个数int BTreeLeafSize(BTNode* root)&#123;\tif (root == NULL)\t\treturn 0;\tif (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\t\treturn 1;\treturn BTreeLeafSize(root-&gt;left) + BTreeLeafSize(root-&gt;right);&#125;\n\n4.2 二叉树第 k 层节点个数  假设根节点是第 1 层，要想知道第 k 层一共有几个节点，需要怎么设计函数呢？\n\n先来这么想：3 所在层数对于根来说是第三层，但是对于 2 来说是第二层，对于 3 自己来说是第 1 层\n那么，我们是不是可以让第 k 层往下 -1 来进行递归呢？\n\n// 二叉树第 k 层节点个数int BTreeLevelKSize(BTNode* root, int k)&#123;\tassert(k &gt;= 1);// 保证 k&gt;=1\tif (root == NULL)\t\treturn 0;\tif (k == 1)\t\treturn 1;\treturn BTreeLevelKSize(root-&gt;left,k - 1)        + BTreeLevelKSize(root-&gt;right,k-1);&#125;\n\n\n\n4.3 二叉树的深度  在之前树的概念学习中，讲解过  树的深度（即树一共有几层）\n深度和之前举例的  校长统计身高  很相似，我们需要找出左右子树中较深的那一个并进行返回。末端的条件，就是节点为空的时候，return 0终止递归 \n// 二叉树深度，即一共有几层int BTreeDepth(BTNode* root)&#123;\tif (root == NULL)\t\treturn 0;\tint left = BTreeDepth(root-&gt;left);\tint right = BTreeDepth(root-&gt;right);\treturn left &gt; right ? left + 1 : right + 1;&#125;\n\n注意：这里 left+1 和 right+1 是为了计算上节点自己\n求二叉树深度 OJ 题leetcode 上有一道 oj 题就是求二叉树的最大深度，代码复制上，改个名，搞定！\n\n题目链接：104. 二叉树的最大深度\n\n\n\n5. 查找树中值为 x 的节点  在二叉树中查找一个值，基本思想就是把它遍历一遍，判断根节点以及左右子树中是否有 x 值的节点。\n具体的解析，写道下面的代码注释里啦！\n// 二叉树查找值为 x 的节点BTNode* BTreeFind(BTNode* root, BTDataType x)&#123;\tif (root == NULL)\t\treturn NULL;// 节点为空返回空\tif (root-&gt;data == x)\t\treturn root;// 节点自己就是 x，返回节点自己的地址\tBTNode* ret1 = BTreeFind(root-&gt;left, x);\tif (ret1 != NULL)// 如果左边找到了，返回左节点的地址\t\treturn ret1;\tBTNode* ret2 = BTreeFind(root-&gt;right, x);\tif (ret2 != NULL)// 如果右边找到了，返回右节点的地址\t\treturn ret2;\treturn NULL;// 两个都找不到，它自己也不是，返回空&#125;\n\n6. 层序遍历  如同其名，层序遍历就是一层一层地遍历\n\n比如上面这棵树，层序遍历的结果如下\n1 2 4 3 NULL 5 6\n\n要想实现层序遍历，我们需要借助之前学习的  栈和队列  知识里的  队列 👉 传送门\n在 VS 项目里面，导入预先写好的队列的头文件和源文件，再引用它就可以了！\n\n这里就能体现出之前预先 typedef 类型的作用了：只需要更改最先的数据类型，就可以搞定后面的一切！\n\n而引用头文件的时候，因为我们  需要在栈的代码中使用二叉树的定义 ，所以需要先引用 二叉树的头文件 ，再引用 队列  的头文件\n\n搞定这个后，我们再来讲述一下层序遍历的思路\n\n先插入根节点，然后在根节点出队列的同时，插入它的左右子树的节点\n当队列中的值都为 NULL 时，代表层序遍历完成\n\n\n所以我们需要入队列的  不是节点的值 ，因为那样无法找到节点的左右子树。入队列的是节点的 地址！\n// 层序遍历void BTreeLevelOrder(BTNode* root)&#123;\tQueue q;\tQueueInit(&amp;q);\tif (root != NULL)&#123;// 根节点非空，开始入队列\t\tQueuePush(&amp;q, root);\t&#125;\twhile (!QueueEmpty(&amp;q))\t&#123;\t\tBTNode* head = QueueFront(&amp;q);// 取队头数据\t\tQueuePop(&amp;q);// 出队列\t\tprintf(&quot;%d &quot;, head-&gt;data);\t\tif (head-&gt;left != NULL)\t\t&#123;\t\t\tQueuePush(&amp;q, head-&gt;left);\t\t&#125;\t\tif (head-&gt;right != NULL)\t\t&#123;\t\t\tQueuePush(&amp;q, head-&gt;right);\t\t&#125;\t\t// 层序遍历不需要递归，可以用循环解决问题\t&#125;\tprintf(&quot;\\n&quot;);\tQueueDestory(&amp;q);// 防止内存泄漏\treturn;&#125;\n\n遍历的结果如下\n\n6.1 判断二叉树是否为完全二叉树  学习了层序遍历后，就可以来判断一个二叉树是否为完全二叉树了！\n完全二叉树：前 k-1 层为满二叉树，最后一层不满，但是从左到右分布\n\n具体的思路是\n\n当队列中的队头为 NULL 时开始遍历，如果队列中都是 NULL，代表是满二叉树\n如果有非空节点，就不是满二叉树\n\n// 判断二叉树是否是完全二叉树bool BTreeComplete(BTNode* root)&#123;\tQueue q;\tQueueInit(&amp;q);\tif (root != NULL) &#123;\t\tQueuePush(&amp;q, root);\t&#125;\twhile (!QueueEmpty(&amp;q))\t&#123;\t\tBTNode* head = QueueFront(&amp;q);// 取队头数据\t\tQueuePop(&amp;q);// 出队列\t\tif (head == NULL)&#123;\t\t\tbreak;// 遇到队列中空节点，退出循环\t\t&#125;\t\tQueuePush(&amp;q, head-&gt;left);\t\tQueuePush(&amp;q, head-&gt;right);\t&#125;\twhile (!QueueEmpty(&amp;q))\t&#123;\t\tBTNode* head = QueueFront(&amp;q);// 取队头数据\t\tQueuePop(&amp;q);// 出队列\t\tif (head != NULL)\t\t&#123;\t\t\t//printf(&quot; 不是完全二叉树 \\n&quot;);\t\t\treturn false;\t\t&#125;\t&#125;\tQueueDestory(&amp;q);// 防止内存泄漏\treturn true;&#125;\n\n结语  链式二叉树的内容到这里就结束啦！\n如果博客里面有讲的不清楚的地方，欢迎大家在评论区提出哦！\n\n下篇博客将讲解一些有关二叉树的OJ 题和概念选择题！我们不见不散哦~\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","树","链表"]},{"title":"【Docker】配置 CentOS 容器时出现 Error Failed to download metadata for repo 'appstream' Cannot prepare internal mirrorlist | 转载","url":"/posts/1296728696/","content":"本站经常搬运一些其他博主文章，主要是为了持久化访问。避免日后他人删文 or 原文无法访问；所有搬运的文章都会写明原文地址，并且不会展示本站的copyright_info\n\n\n下文所出现的场景，是我在 linux 上使用 docker 安装 centos 容器时出现的！\n\n✨在学习使用 docker 技术过程中，基于 centos 镜像自定义新的镜像，其中基础镜像 centos 需要提前安装好 vim 和 net-tools，然而在刚开始通过 yum -y install vim 安装 vim 时，便出现了错误提示信息：\nError: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist\n\n✨上面的报错信息意思是，从仓库 ‘appstream’ 下载元数据失败：由于镜像列表中没有 URL，不能准备内部镜像列表。\n🥎问题分析：\n✨第一种可能的情况便是网络连接问题。检查是否可以连接外部网络，可以使用 ping baidu.com 查看是否有丢包情况。如果丢包，则进一步检查网络连接是否正常；如果没有丢包，继续阅读下文\n✨那么第二种情况，便是 CentOS 已经停止维护的问题。2020 年 12 月 8 号，CentOS 官方宣布了停止维护 CentOS Linux 的计划，并推出了 CentOS Stream 项目，CentOS Linux 8 作为 RHEL 8 的复刻版本，生命周期缩短，于 2021 年 12 月 31 日停止更新并停止维护（EOL），\n更多的信息可以查看 CentOS 官方公告 。 如果需要更新 CentOS，需要将镜像从 mirror.centos.org 更改为 vault.centos.org\n\n🥎那么针对上面提到的第二种情况，给出的解决方法如下：\n🔔 首先，进入到 yum 的 repos 目录\ncd /etc/yum.repos.d/\n\n🔔其次，修改 centos 文件内容\nsed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*\n\n🔔 然后，生成缓存更新（第一次更新，速度稍微有点慢，耐心等待两分钟左右）\nyum clean allyum makecache\n\n🔔 最后，运行 yum update 并重新安装 vim\nyum update -yyum -y install vim\n\n🎉至此，针对第二种情况出现的问题成功解决！\n原文作者：ReadThroughLife原文地址：https://blog.csdn.net/weixin_43252521/article/details/124409151\n\n","categories":["docker真好玩"],"tags":["CentOS","Docker"]},{"title":"【图】拓扑排序 | 转载","url":"/posts/1720780208/","content":"本文搬运自 csdn\n\n\n拓扑排序  什么是拓扑排序？  在图论中，拓扑排序  是一个  有向无环图  的所有顶点的线性序列(获得拓扑有序序列)。且该序列必须满足下面两个条件：\n\n每个顶点出现且只出现一次。\n若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。\n\n有向无环图（DAG）才有拓扑排序，非 DAG 图没有拓扑排序一说。\n  \n怎么拓扑排序？拓扑排序步骤：\n\n在有向图中选一个没有前驱的顶点且输出之。\n从图中删除该顶点和所有以它为尾的弧。\n\n  重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止。后一种情况则说明有向图中存在环。\n \n  图中，V1 和 V6 没有前驱，则可任选一个。假设先输出 V6，在删除 V6 及弧 &lt;V6, V4&gt;,&lt;V6, V5&gt; 之后，只有顶点 V1 没有前驱，输出 V1 且删去 V1 及弧 &lt;V1, V2&gt;,&lt;V1, V3&gt; 和 &lt;V1, V4&gt;，之后 V3 和 V4 都没有前驱。依此类推，可从中任选一个继续进行。整个拓扑排序的过程如上图。\n拓扑排序实现   我们采用 邻接表  作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组。入度为零的顶点即为没有前驱的顶点，删除顶点以及它为尾的弧的操作，则可换以弧头顶点的入度减 1 来实现。\nStatus TopologicalSort(ALGraph G)&#123;\t// 有向图 G 采用邻接表存储结构 \t// 若 G 无回路，则输出 G 的顶点的一个拓扑序列并返回 OK，否则 ERROR \tFindInDegree(G, indegree);// 对各顶点求入度 indegree[0..vernum-1] \tInitStack(S);\tfor(i=0;i&lt;G.vexnum;i++)// 建零入度顶点栈 S \t\tif(!indegree[i])// 入度为 0 者进栈 \t\t\tPush(S, i);\tcount = 0;// 对输出顶点计数 \twhile(!StackEmpty(S))&#123;\t\tPop(S, i);\tprintf(i, G.vertices[i].data);\tcount++;// 输出 i 号顶点并计数 \t\tfor(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;\t\t\tk = p-&gt;adjvex;// 对 i 号顶点的每个邻接点的入度减 1 \t\t\tif(!(--indegree[k]))// 若入度减为 0，则入栈 \t\t\t\tPush(S, k);\t\t&#125;\t&#125;\tif(count&lt;G.vexnum)// 该有向图有回路 \t\treturn ERROR;\telse\t\treturn OK;&#125;\n\n对有 n 个顶点和 e 条弧的有向图而言，建立求各顶点的入度的时间复杂度 O(e)；建零入度顶点栈的时间复杂度为 O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减 1 的操作在 WHILE 语句中总共执行 e 次，所以，总的 ** 时间复杂度为 O(n+e)**。  \n当有向图中无环时，也可利用深度优先遍历进行拓扑排序，因为图中无环，则由图中某点出发进行深度优先搜索遍历时，最先退出 DFS 函数的顶点即出度为零的顶点，是拓扑有序序列中最后一个顶点。由此，按退出 DFS 函数的先后记录下来的顶点序列 (如同求强连通分量时 finished 数组中的顶点序列) 即为逆向的拓扑有序序列。  \n关键路径  什么是关键路径？AOE 网： 在一个表示工程的带权有向图中，用顶点表示事件（如 V1），用有向边表示活动（如 &lt;V1,V2&gt; &#x3D; a1），边上的权值表示活动的持续时间，称这样的有向图为边表示的活动的网。源点： 在 AOE 网中，没有入边的顶点称为源点；如顶点 V1。终点： 在 AOE 网中，没有出边的顶点称为终点；如顶点 V9。AOE 网的性质：\n\n只有在进入某顶点的活动都已经结束，该顶点所代表的事件才发生；例如，V5 事件发生需要 a4 和 a5 两个活动都结束。\n只有在某顶点所代表的事件发生后，从该顶点出发的各活动才开始；例如，V5 事件结束，活动 a7 和 a8 活动才能开始。\n\n\n  在 AOE 网中，所有活动都完成才能到达终点，因此完成整个工程所必须花费的时间（即最短工期）应该为源点到终点的最大路径长度。具有最大路径长度的路径称为  关键路径 。关键路径上的活动称为 关键活动 。  假设开始点是 V1，从 V1 到 Vi 的最长路径长度叫做事件 Vi 的 最早发生事件 。这个时间决定了所有以 Vi 为尾的弧所表示的活动的 最早开始时间 。我们用 e(i) 表示活动 ai 的最早开始时间。还可以定义一个活动的 最迟开始时间 l(i)，这是在不推迟整个过程完成的前提下，活动 ai 最迟必须开始进行的时间。两者之差 l(i)-e(i) 意味着完成活动 ai 的时间余量。我们把 l(i)&#x3D;e(i) 的活动叫做关键活动。\n向关键路径要时间，向非关键路径要资源。\n\n从前往后，计算工期与每项活动的最早开始时间；\n从后往前，倒推每项活动最晚开始时间。\n关键路径：最早开始时间 &#x3D; 最晚开始时间\n\n怎么求关键路径？ve(j)：最早发生时间vl(j)：最迟发生时间\n\n输入 e 条弧 &lt;j, k&gt;，建立 AOE- 网的存储结构；\n从源点 v0 出发，令 ve[0]=0，按拓扑有序求其余各顶点的最早发现时间 ve[i] (1≤i≤n-1)。如果得到的拓扑有序序列中顶点个数小于网中顶点数 n，则说明网中存在环，不能求关键路径，算法终止；否则执行步骤(3)。\n从汇点 vn 出发，令 vl[n-1]=ve[n-1]，按逆拓扑有序求其余各顶点的最迟发生时间 vl[i] (n-2≥i≥2)；\n根据各顶点的 ve 和 vl 值，求每条弧 s 的最早开始时间 e(s) 和最迟开始时间 l(s)。若某条弧满足条件 e(s)&#x3D;l(s)，则为关键活动。\n\n  根据上述算法，计算各顶点的 ve 值是在拓扑排序的过程中进行的，需对拓扑排序的算法作如下修改：\n\n在拓扑排序之前设初值，令 ve[i]=0 (0≤i≤n-1)；\n在算法中增加一个计算 vj 的直接后继 vk 的最早发生时间的操作：若 ve[j]+dut(&lt;j, k&gt;) &gt; ve[k]，则 ve[k]=ve[j]+dut(&lt;j, k&gt;)；\n为了能按逆拓扑有序序列的顺序计算各顶点的 vl 值，需记下在拓扑排序的过程中求得的拓扑有序序列，这需要在拓扑排序算法中，增设一个栈以记录拓扑有序序列，则在计算求得各顶点的 ve 值之后，从栈顶至栈底便为逆拓扑有序序列。\n\n关键路径实现  改写的拓扑排序代码：\nStatus TopologicalOrder(ALGraph G, Stack &amp;T)&#123;\t// 有向图 G 采用邻接表存储结构，求各顶点事件的最早发生时间 ve(全局变量) \t//T 为拓扑序列顶点栈，S 为零入度顶点栈 \t// 若 G 无回路，则用栈 T 返回 G 的一个拓扑序列，且函数值为 OK，否则 ERROR \tFindInDegree(G, indegree);// 对各顶点求入度 indegree[0..vernum-1] \tInitStack(S);// 建零入度顶点栈 S \tfor(i=0;i&lt;G.vexnum;i++)// 建零入度顶点栈 S \t\tif(!indegree[i])// 入度为 0 者进栈 \t\t\tPush(S, i);\tInitStack(T);\tcount = 0;\tve[0..G.vexnum-1] = 0;// 初始化 \twhile(!StackEmpty(S))&#123;\t\tPop(S, j);\tPush(T, j);\tcount++;//j 号顶点入 T 栈并计数 \t\tfor(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;\t\t\tk = p-&gt;adjvex;// 对 j 号顶点的每个邻接点的入度减 1 \t\t\tif(--indegree[k] == 0)// 若入度减为 0，则入栈 \t\t\t\tPush(S, k);\t\t\tif(ve[j]+ *(p-&gt;info)&gt;ve[k])\t\t\t\tve[k] = ve[j] + *(p-&gt;info);\t\t&#125;\t&#125;\tif(count &lt; G.vexnum)// 该有向图有回路 \t\treturn ERROR;\telse\t\treturn OK;&#125; \n\n关键路径算法：\nStatus CriticalPath(ALGraph G)&#123;\t//G 为有向图，输出 G 的各项关键活动 \tif(!TopologicalOrder(G, T))\t\treturn ERROR;\tvl[0..G.vexnum-1] = ve[G.vexnum-1];// 初始化顶点事件的最迟发生事件 \twhile(!StackEmpty(T))&#123;// 按拓扑逆序求各顶点的 vl 值 \t\tfor(Pop(T, j),p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;\t\t\tk = p-&gt;adjvex;\tdut = *(p-&gt;info);\t\t\tif(vl[k]-dut &lt; vl[j])\t\t\t\tvl[j] = vl[k]-dut;\t\t&#125;\t&#125;\tfor(j=0;j&lt;G.vexnum;j++)&#123;// 求 ee，el 和关键活动 \t\tfor(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;\t\t\tk = p-&gt;adjvex;\tdut = *(p-&gt;info);\t\t\tee = ve[j];\tel = vl[k]-dut;\t\t\ttag = (ee==el)?&#x27;*&#x27;:&#x27;&#x27;;\t\t\tprintf(j, k, dut, ee, el, tag);// 输出关键活动 \t\t&#125;\t&#125;&#125; \n\n\n  上面两种算法的时间复杂度均为 O(n+e)，计算弧的活动最早开始时间和最迟开始时间的时间复杂度为 O(e)，所以总的求关键路径的 ** 时间复杂度为 O(n+e)**。  \n求关键路径过程示例 \n上图的关键活动为 a1，a4，a7，a8，a10 和 a11。它们构成两条关键路径：(V1，V2，V5，V7，V9) 和 (V1，V2，V5，V8，V9)。  \n实践证明：用 AOE- 网来估算某些工程完成的时间是非常有用的。只有在不改变网的关键路径的情况下，提高关键活动的速度才有效。若网中有几条关键路径，那么，单是提高一条关键路径上的关键活动的速度，还不能导致整个工程缩短工期，而必须提高同时在几条关键路径上的活动速度。\n版权声明：本文为 CSDN 博主「qw&amp;amp;jy」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43448856/article/details/119959241\n\n","categories":["数据结构太复杂"],"tags":["数据结构","Java","图"]},{"title":"【算法】算法的空间复杂度和时间复杂度","url":"/posts/3906762122/","content":"前言🕵️‍♂️在之前的学习中，已经接触过了  网上 OJ 题目\n在一些题目中，我们经常可以看到  时间复杂度和空间复杂度  的要求\n你可能和我有一样的疑惑，复杂度究竟是什么？我要怎么评判我自己写的算法的复杂度？\n今天就让我们来认识认识~~\n\n\n\n1. 算法效率🧐和做任何事情一样，我们写的算法，自然也有它的运行效率。效率越高越好\n1.1 什么是算法  算法可以简单地理解为我们为了求解一个问题，所写的函数\n在初识 C 语言中，我们学习过  利用递归求解斐波那契数列  的算法\nlong long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n这个算法只有 3 行代码，看上去非常简洁——但是简洁的代码不一定效率就高！\n1.2 如何衡量？算法在编写成可执行程序的时候，main 函数使用这个算法，需要调用一定的空间，消耗一定的时间。算法的效率就是通过  空间和时间  这两个维度来评判的\n\n时间复杂度：衡量一个算法的运行速度\n空间复杂度：衡量一个算法运行需要开辟的额外空间\n\n\n2. 时间复杂度⏰算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。算法中基本操作的执行次数，为算法的时间复杂度\n\n时间复杂度是一个近似值，并不是实际运行的时间\n实际上代码的运行时间，和机器的内存、cpu 性能和平台都有关系，同一个代码在不同的机器上运行时间都不一样，如果只以纯粹的时间来考核，很难分析\n\n找到某条基本语句与问题规模 N 之间的数学表达式，就算出了该算法的时间复杂度\nvoid test1(int N){\tint count =0;    for(int i=0;i&lt;N;i++)    {        for(int j=0;j&lt;N;j++)        {            count++;        }    }        for (int k = 0; k &lt; 2 * N ; ++ k)    {     \tcount++;    }        int M = 10;    while (M--)    {     \tcount++;    }        return;}\n\n请问这个代码中，count语句执行了几次？\n可以总结出如下表格\n\n\n\nN\nF(N)\n\n\n\n10\n130\n\n\n100\n10210\n\n\n1000\n1002010\n\n\n你可能会简单地认为，F(N)的结果就是我们的时间复杂度。其实并不然，我们并不需要一个精确的运行次数，只需要知道程序运行次数的量级就行了\n这里我们使用  大 O 渐进表示法  来表示时间复杂度（空间复杂度同理）\n2.1 大 O 的渐进表示法  大 O 符号（Big O notation）：是用于描述函数渐进行为的数学符号\n\n推导大 O 阶方法： \n\n用常数 1 取代运行时间中的所有加法常数。\n在修改后的运行次数函数中，只保留  最高阶项。 \n如果最高阶项存在且不是 1，则去除与这个项目相乘的常数。得到的结果就是大 O 阶\n\n\n使用这种方法后，test1函数的时间复杂度为  对于 test1 函数，在计算的时候，我们省略了最后的 +10，保留了最高阶数 N2，即得出了它的时间复杂度\n\n如果最高阶数前面有系数，如 2N，系数也将被省略\n\n因为当 N 的数值很大的时候，后面的那些值对我们总运行次数的影响已经非常小了。大 O 的渐进表示法  去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数\n2.1.1 O(logN)以什么为低\n来自《代码随想录》2021 年 12 月第 1 版 P13\n\n在计算过程中，假设我们有如下两个时间复杂度  和实际上，以 2 为底的 O 是可以转成以 10 为底的 O也就等同于  常数  总结出来就是  而在大 O 渐进法中常数可以忽略，所以我们可以认为 log 中的底数是意义不大的，可以忽略直接说logN\n2.2 多种情况取最坏  一些算法的时间复杂度会有最好、最坏和平均的情况\n\n最好情况：任意输入规模的最小运行次数(下界)\n平均情况：期望的运行次数\n最坏情况：任意输入规模的最大运行次数(上界)\n\n举个例子，当我们编写一个在数组中查找数值的算法时，它可能会出现这几种情况：\n\n最好情况：1 次就找到\n平均情况：N/2 次\n最坏情况：N 次\n\n在实际中的一般情况，我们关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)\n2.3 常见时间复杂度的计算NO.1 双独立循环void Func1(int N){     int count = 0;     for (int k = 0; k &lt; 2 * N ; ++ k)     {     \t++count;     }     int M = 10;     while (M--)     {     \t++count;     } \tprintf(\"%d\\n\", count);}\n\n这里出现了两个循环，分别是 2N 次和 10 次。前面提到了大 O 渐进法只  保留最高阶数并省略系数，所以它的时间复杂度是O(N)\nNO.2 双独立循环void Func2(int N, int M){     int count = 0;     for (int k = 0; k &lt; M; ++ k)     {     \t++count;     }     for (int k = 0; k &lt; N ; ++ k)     {     \t++count;     }     printf(\"%d\\n\", count);}\n\n这里出现了次数为 N 和 M 的两层循环\n\n当 M 和 N 差不多大的时候，时间复杂度可以理解为 O(M) 或 O(N)\n当 M 远远大于 N 时，时间复杂度为O(M)\n一般情况取 O(M+N)\n\n\nNO.3 常数阶void Func3(int N){     int count = 0;     for (int k = 0; k &lt; 100; ++ k)     {     \t++count;     }     printf(\"%d\\n\", count);}\n\n这里我们得知了具体的循环次数为 100，是一常数，时间复杂度为 O(1)，代表 常数阶\n\n只要循环次数已知，为一常数且和所传参数无关，其时间复杂度即为 O(1)\n\nNO.4 strchr// 计算 strchr 的时间复杂度const char * strchr (const char * str, int character );\n\n看到这道题的时候，你可能会一愣，strchr 是什么？\n\n在之前的博客里，我介绍了很多常用的字符串函数👉点我\n可这里面没有 strchr，但有 strstr\n\nstrstr 函数的作用：在字符串 1 中寻找是否有字符串 2\n其中第二个 str 代表的是string 字符串，那我们是不是可以猜想，chr 代表的是char 字符，其作用是在一个字符串中查找是否有一个字符呢？\n当然，光是猜想肯定是不够的，我们还需要求证一下\n\n如何查询库函数定义并尝试使用它？👉点我\n\n打开cplusplus 网站，搜索 strchr，即可转到函数定义\n\n可以看到，该函数的作用是  定位字符串中第一次出现该字符的位置，返回值是一个pointer 指针\n和我们猜想的一样，它的作用就是在字符串中查找一个字符，并返回它第一次出现的位置的地址。\n这样一来，strchr 函数的时间复杂度就很清楚了，就是遍历字符串所需要的次数，O(N)\nNO.5 冒泡排序void BubbleSort(int* a, int n){     assert(a);     for (size_t end = n; end &gt; 0; --end)     {         int exchange = 0;         for (size_t i = 1; i &lt; end; ++i)         {         \tif (a[i-1] &gt; a[i])         \t{                Swap(&amp;a[i-1], &amp;a[i]);                exchange = 1;         \t}    \t }     if (exchange == 0)    \t break;     }}\n\n冒泡排序  是一个非常经典的代码，其思路就是遍历整个数组，如果待排序数字大于它的下一位，则交换这两个数字\n\nN 个数字的数组需要 N-1 次排序才能完成\n每一次排序都需要遍历一次数组\n\n这样算来，冒泡排序的循环次数就是两个 N 相乘，即为 O(N^2)\n\n能否通过循环层级判断？细心的你可能会发现，上述代码中出现了两层循环，那是不是可以通过循环层级来判断时间复杂度呢？\n并不能！\nfor(int i=0;i&lt;n;i++){\tfor(int j=0;j&lt;3;j++)\t\tprintf(\"hehe\\n\");}\n\n如果是上述这种两次循环的情况，会打印 3n 次呵呵，其时间复杂度是 O(N) 而不是N^2\n\n我们要准确分析算法的思路，并不能简单地通过循环层级来判断时间复杂度\n\nNO.6 二分查找//a 数组，n 长度，x 需要查找的数int BinarySearch(int* a, int n, int x){     assert(a);     int begin = 0;     int end = n-1;     while (begin &lt;= end)     {         int mid = begin + ((end-begin)&gt;&gt;1);// 使用位移操作符来模拟 /2，防止 begin 和 end 相加后超出 int 范围         if (a[mid] &lt; x)         \tbegin = mid+1;         else if (a[mid] &gt; x)         \tend = mid-1;         else         \treturn mid;// 返回需要查找的数的下标     }     return -1;}\n\n二分查找的思路这里不再赘述\n假设我们找了 x 次，每一次查找都会使查找范围减半\nN/2/2/2/2 ……\n\n最后我们可以得出 2 条公式\n\n\n最好情况：O(1)\n最坏情况：O(logN)\n\n\n通过时间复杂度的对比，我们就能看出二分查找的优势在那里了\n\n\n\nN\nO(N)\nO(logN)\n\n\n\n1000\n1000\n10\n\n\n100w\n100w\n20\n\n\n10 亿\n10 亿\n30\n\n\n可以看到，当数据很大的时候，O(logN)的算法执行次数比 O(N)少了特别多!!（来自 BT-7274 的肯定）\n\nNO.7 计算 N!// 计算阶乘递归 Fac 的时间复杂度？long long Fac(size_t N){     if(0 == N)     \treturn 1;     return Fac(N-1)*N;}\n\n对于这个阶乘的递归函数而言，每次函数调用是O(1)，时间复杂度主要看递归次数\n对于数字 N 而言，递归需要 N 次，时间复杂度是O(N)\n递归算法时间复杂度计算  递归算法时间复杂度 = 递归次数 * 每次递归中操作次数\n\n\n如果每次函数调用是 O(1)，看递归次数\n每次函数调用不是 O(1)，那么就看他递归调用中次数的累加\n\nNO.8 斐波那契数列\n计算斐波那契数可以用递归和迭代两种算法👉点我\n\n// 计算斐波那契递归 Fib 的时间复杂度？long long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n\n每次递归，次数都会增加，总的来说是以 2^x 的量级增加的（x 代表行数）这里一共有 x-1 项，用  等比数列的求和公式  得出，结果为 2x-1\n所以最后得出的时间复杂度为 O(2N)\n\n需要注意的是，当递归调用到底部时，有一些调用会较早退出，这部分位于金字塔的右下角\n\n由于时间复杂度只是一个估算值，这一部分缺失的调用次数对总运行次数的影响不大，故忽略掉\n\nNO.9 非 +1 递增循环void fun(int n) {   int i=l;   while(i&lt;=n)      i=i*2;}\n\n此函数有一个循环，但是循环没有被执行 n 次，i 每次都是 2 倍进行递增，所以循环只会被执行 log2n 次\nNO.10 有序数组中查找和为 sum 的两个数  给定一个整数 sum，从有 N 个有序元素 的数组中寻找元素 a，b，使得 a+b 的结果最接近 sum，最快  的平均时间复杂度是？\nA. O(n)//√B. O(n^2)C. O(nlogn)D. O(logn)\n\n数组元素有序，所以 a,b 两个数可以分别从  开始和结尾处  开始搜，根据首尾元素的和是否大于 sum, 决定搜索的移动，整个数组被搜索一遍，就可以得到结果，所以最好时间复杂度为 n\nNO.11 双嵌套循环void test(int n){    for(int i=0;i&lt;n;i++)    {// 循环 1        for(int j=i;j&lt;n;j++)        {            // 循环 2        }    }}\n\n以上是一个很常用的循环。其中循环 2 的执行次数是一个等差数列，第一次是 n，第二次是 n-1，第三次是 n-2……一直到最后一次为 1；这个等差数列的求和为 n(n+1)/2，即 n2/2+n/2，因为时间复杂度需要 取大且忽略系数，所以最终的时间复杂度为 n2\n\n3. 空间复杂度🏠3.1 概念  空间复杂度是对一个算法在运行过程中临时占用空间大小的度量\n\n和时间复杂度不是真的计算时间一样，空间复杂度也不衡量算法具体占用的内存字节数。\n\n空间复杂度计算的是额外开辟的变量的个数，适用  大 O 渐近法\n注意：函数运行时所需要的  栈空间 (存储参数、局部变量、一些寄存器信息等) 在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。\n3.2 空间复杂度计算NO.1 冒泡排序void BubbleSort(int* a, int n){     assert(a);     for (size_t end = n; end &gt; 0; --end)     {         int exchange = 0;         for (size_t i = 1; i &lt; end; ++i)         {         \tif (a[i-1] &gt; a[i])         \t{                Swap(&amp;a[i-1], &amp;a[i]);                exchange = 1;         \t}    \t }     if (exchange == 0)    \t break;     }}\n\n我们会发现，冒泡排序算法并没有额外定义非常多的变量，一共只有 3 个，属于  常数阶\nsize_t end = n;int exchange = 0;size_t i = 1;\n\n其空间复杂度为O(1)\n计算时注意其与 N 的关系  当我们在算法中开辟空间，计算空间复杂度的时候，要注意开辟的这个空间与 N 有没有关系\nint arr[N];//c99 变长数组，和传过来的参数有关int* a=(int*)malloc(sizeof(int)*N);// 和传过来的参数有关，O(N)int* a=(int*)malloc(sizeof(int)*3);// 和传过来的参数无关，O(1)\n\nNO.2 斐波那契数列// 计算 Fibonacci 的空间复杂度？// 返回斐波那契数列的前 n 项long long* Fibonacci(size_t n){     if(n==0)     return NULL;     long long * fibArray = (long long *)malloc((n+1) * sizeof(long long));     fibArray[0] = 0;     fibArray[1] = 1;     for (int i = 2; i &lt;= n ; ++i)     {     \tfibArray[i] = fibArray[i - 1] + fibArray [i - 2];     }     return fibArray;}\n\n和上面的斐波那契数列的递归代码不同，这里我们新创建了一个数组，用来保存计算出来的斐波那契数\n一共 malloc 了 n+1 个长整型的空间，空间复杂度是 O(N)\n\n函数栈帧空间重复使用问题  如果是递归方法的斐波那契算法，其空间复杂度是多少呢？\nlong long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n答案也是O(N)\n因为对于递归算法而言，其开辟的函数栈帧空间是可以重复利用的！\n如 fib(8)的调用，其开辟的函数栈帧，是可以在后续继续调用 fib 函数时重复使用的\n\n通过函数的参数压栈，我们可以很好地理解这是为啥👉点我\n\n\n上图中 f1 和 f2 是两个函数，但执行了相同的功能。其函数调用的空间实际上是一个，f2 在 f1 销毁后继承了它的空间\n\n这就好比每一次新的递归都会开一家新的饭店，但是你下次还想吃东北菜的时候，可以去之前开的东北菜馆，咱没必要让别人再开一家馆子不是嘛？\n\n不过由于斐波那契数的递归算法会  递归非常多次 ，在数字很大的时候，会导致 栈溢出\n\n递归函数空间复杂度  针对递归函数，可以认为空间复杂度如下\n递归层级 * 每次递归的空间复杂度\n\n和时间复杂度的计算是很相似的。\n\n比如下面这个斐波那契数列的空间复杂度，如果入参是 5，调用会调用 5 层，每一层都是一个乘法操作，空间负载度是O(1)，最终得到的空间复杂度是O(5)，也就是O(N)\n// 版本 1long long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n这个写法肯定不是最优的，代码随想录中提供了个更好的解法\n// 版本 2// 进入这个函数时，前两个参数都给 1，N 正常给long long Fib(long long first,long long second,size_t N){     if(N &lt;= 0)         return 0;     if(N &lt; 3)     \treturn 1;     else if(N == 3)// 相当于减少了两次递归     \treturn first+second;\t     return Fib(second,first+second,N-1);}\n\n此时减少了 2 次递归，虽然并没有降低空间复杂度（还是O(N))，但时间负载度大大降低！\n\n版本 1 时间复杂度为 O(2n)\n版本 2 时间复杂度为 O(N)\n\n运行速度也会快非常多！\n\nNO.3 阶乘long long Fac(size_t N){     if(N == 0)     \treturn 1;     return Fac(N-1)*N;}\n\n虽然函数本身的空间不计入时间复杂度，这里计算的是递归调用时额外开辟的函数栈帧空间\n一共调用了 N-1 次，每个栈帧使用了常数个空间，空间复杂度是 O(N)\n4. 常见复杂度对比👐\n\n\n结语😘时间复杂度和空间复杂度可以帮我们很好的了解自己所写算法的好坏，在未来面试的时候，HR 肯定也更喜欢效率高的算法\n要多刷题，好好积累自己的能力，想必之后写出好算法也是水到渠成（吧？）\n\n如果这篇博客对你有帮助，点个赞再走呗~\n\n","categories":["数据结构太复杂"],"tags":["C语言","算法","数据结构","OJ刷题"]},{"title":"【C++】并查集","url":"/posts/2359019899/","content":"并查集这个数据结构本身并不难，其主要是提供一个思路，方便我们编写图的代码，和一些 OJ 题\n\n\n[TOC]\n1. 什么是并查集？并查集是多个独立集合的合集，用于表示数据之间的关系。\n比较生动的例子，就是我们生活中的朋友圈（不是 wx 的那个啊）\n\n张三和李四是好朋友，那么他们就构成了一个集合 A\n王舞和王陆是好朋友，那么他们也构成了一个集合 B\n此时，王舞突然认识了李四，这时候，就可以把 A 和 B 合并成一个集合\n\n推而广之，一个并查集中可以有多个这样的集合，多个朋友圈。\n\n并查集中的每一个集合是用  多叉树  来表示的\n\n2. 思路  并查集的思路并不难，给定一个数组的大小（需要在另外的地方管理编号）创建一个并查集\n下标即为数据的编号\n\n设定元素的初始值都是 -1\n如果下标 1 和 3 为一个集和，那就把 3 的元素（初始值 -1）加到 1 处，即 1 的元素为 -2；再把 3 的元素设置为 1 的下标，即 3 的元素为 1\n依此类推，最终只要下标所对应元素不为负数，那么这个下标就是一个集和的成员\n如果为负数，那么就是一个集合的根，且元素为这个集和中成员的个数（绝对值）\n\n如图所示，下标 678 所对应元素为 0，代表它们属于以下标 0 为根的一个集合。而下标 0 处的元素为 -4，代表这个集合里面有 4 个元素\n\n2.1 合并集合  如果我们需要合并一个集合，以上图中的 0 集合和 1 集合为例。我们只需要将 1 集合的元素 -3 加到 0 集合上，再把 1 集合的元素改成 0 即可\n此时的树就会是这样的👇\n\n2.2 压缩路径  当节点很多，集合可能会出现路径长度过大的情况。这时候我们就需要进行路径的压缩\n其方法很简单。遍历整个并查集，将同一集合的子节点改成相同的父亲即可\n\n这样在向上找集合的根时，无须跳转多次，一次就能找到。\n但由于并查集的访问是依靠数组下标实现的随机访问，时间复杂度为O(1)，只有数据样本量极大的时候，这么做才能有效果\n\n3. 代码  相比于其他数据结构复杂的实现，并查集的实现就简单多了。主要的函数只有几个，可以通过封装 vector 来实现\nclass UnionFindSet {public:\tUnionFindSet(const int sz)\t\t:_set(sz,-1)// 调用 vector 构造函数，初始化 sz 个 -1\t{}\tvoid Union(int x, int y)// 设置 x 和 y 为一个集合\t{\t\tint r1 = FindRoot(x);\t\tint r2 = FindRoot(y);\t\tif (r1 != r2)// 不在一个集和中\t\t{\t\t\t_set[r1] += _set[r2];\t\t\t_set[r2] = r1;\t\t}\t}\tint FindRoot(int n)// 找这个集合的根\t{\t\twhile (_set[n] &gt;= 0)\t\t{\t\t\tn = _set[n];\t\t}\t\treturn n;// 负数的时候为根\t}\tbool isUnion(int x,int y)// 判断是否在一个集合中\t{\t\treturn FindRoot(x) == FindRoot(y);\t}\tint UnionSZ()// 返回有几个集合\t{\t\tint count = 0;\t\tfor (int i = 0; i &lt; _set.size(); i++)\t\t{\t\t\tif (_set[i] &lt; 0)\t\t\t{\t\t\t\tcount++;\t\t\t}\t\t}\t\treturn count;\t}private:\tvector&lt;int&gt; _set;// 用来存放对应关系};\n\n这里没有写压缩路径的代码，其实也就是一个遍历搞定的事😂\n\n遍历，判断是否为同一集合\n是，找到这个集和的根\n将当前遍历到的节点父亲改成该集和的根\n\n思路还是不难的\n4.OJ 题4.1 剑指 Offer II 116. 省份数量\n剑指 Offer II 116. 省份数量 \n\n\n有了并查集，这道题就非常简单。最重要的是思路。我们无须现场造一个轮子，只需要写好找根函数，用一个数组就能实现一个简单的并查集\nclass Solution {public:    int FindRoot(const vector&lt;int&gt;&amp; v,int n)    {        int prev = n;// 初始下标        while(v[prev]&gt;=0)// 它的父亲下标        {            prev=v[prev];// 如果不为负数，那就还是需要往前找        }        return prev;    }    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected)     {        vector&lt;int&gt; v(isConnected.size(),-1);        for(int i=0;i&lt;isConnected.size();i++)        {            for(int j=0;j&lt;isConnected[i].size();j++)            {                if(isConnected[i][j]==1)// 为 1 代表是一个集合中的元素                {                    int root1 = FindRoot(v,i);                    int root2 = FindRoot(v,j);                    if(root1!=root2)                    {                        v[root1] += v[root2];                        v[root2] = root1;                    }                }            }        }        int count = 0;        for(int i=0;i&lt;v.size();i++)        {            if(v[i]&lt;0)            {                count++;            }        }        return count;    }};\n\n\n4.2 等式方程的可满足性\n990. 等式方程的可满足性\n\n\n这道题和上面那一道差不多，只不过把省份换成了字母之间的关系\nclass Solution {public:    int FindRoot(const vector&lt;int&gt;&amp; v,int n)    {        int prev = n;// 初始下标        while(v[prev]&gt;=0)// 它的父亲下标        {            prev=v[prev];// 如果不为负数，那就还是需要往前找        }        return prev;    }    bool equationsPossible(vector&lt;string&gt;&amp; equations) {        vector&lt;int&gt; v(26,-1);// 因为题目给的都是小写字母，直接建立 26 个小写字母的映射表        for(int i=0;i&lt;equations.size();i++)        {            int root1 = FindRoot(v,equations[i][0]-'a');// 第一个字母            int root2 = FindRoot(v,equations[i][3]-'a');// 第二个字母            if(equations[i][1]=='=')// 代表等于            {                if(root1!=root2)                {// 设置为一个集合中的元素                    v[root1] += v[root2];                    v[root2] = root1;                }            }            else// 不等于            {                if(root1==root2)                {                    // 如果不等于的同时，根还相同                    // 说明是同一个集合，不符合题意                    return false;                }            }        }        // 还需要遍历第二遍，避免漏网之鱼        for(int i=0;i&lt;equations.size();i++)        {            int root1 = FindRoot(v,equations[i][0]-'a');// 第一个字母            int root2 = FindRoot(v,equations[i][3]-'a');// 第二个字母            if(equations[i][1]=='!')// 不等于            {                if(root1==root2)                {                    // 如果不等于的同时，根还相同                    // 说明是同一个集合，不符合题意                    return false;                }            }        }        return true;    }};\n\n\n","categories":["数据结构太复杂"],"tags":["数据结构","图","C++"]},{"title":"【算法】从 x 的 n 次方看递归时间复杂度计算","url":"/posts/2475090872/","content":"从 x 的 n 次方看递归时间复杂度计算\n\n\n1. 循环  这个问题，最简单的办法是用循环\nint pow1(int x,int n){    int result = 1;    for(int i=0;i&lt;n;i++)    {        result*=x;    }    return result;}\n\n如上算法的时间复杂度为O(N)，但还是不够理想。这时尝试使用递归算法\n2. 递归 1int pow2(int x,int n){    if(n==0)// x^0 = 1        return 1;    return pow2(x,n-1)*x;}\n\n使用如上递归函数时间复杂度计算办法，该函数递归调用次数是从 n 一直减到 0，即 n 次。每次递归中，需要进行一次相乘的计算，即O(1)\n最终得到的时间复杂度 O(n*1) = O(n)，这和我们用循环写出来的代码没两样\n3. 递归 2，二叉树int pow3(int x,int n){    if(n==0)// x^0 = 1        return 1;    if(n==1)// 减少一次递归        return x;    if(n%2==1)// 奇数        return pow3(x,n/2)*pow3(x,n/2)*x;    // 偶数方    return pow3(x,n/2)*pow3(x,n/2);}\n\n最终求次方操作被抽象成了一个二叉树\n\n总递归次数，即二叉树中的节点个数。我们能算出来这颗满二叉树的节点个数为 2^4-1 = 15\n所以一共递归了 15 次，每次的操作还是一个相乘，O(1)\n所以最终的时间复杂度就是\n递归次数 = 满二叉树节点个数 = 2^m -1m = 二叉树层数（从 1 开始）= log(n)\n\n带入可以计算出来，最终的二叉树总节点数是 n-1 个，时间复杂度还是O(N)。这说明我们的算法还不够好\n\n二叉树相关知识点 https://blog.musnow.top/posts/4161984418/\n\n4. 递归 3如果观察第三个函数可以发现，不管是奇数还是偶数的奇怪，都进行了 2 次递归调用，但这两个递归调用都是完全相同的\npow3(x,n/2)*pow3(x,n/2);\n\n也就是说，我们可以先递归调用 1 次，存结果再计算！\nint pow4(int x,int n){    if(n==0)// x^0 = 1        return 1;    if(n==1)// 减少一次递归        return x;    int tmp = pow3(x,n/2);    if(n%2==1)// 奇数        return tmp*tmp*x;    // 偶数方    return tmp*tmp;}\n\n此时函数中只调用了 1 次递归，每次递归之后，数据都除 2，所以总共是 log2(n)次\n每次递归，还是一个乘法操作，时间复杂度 O(1) 最终得到的时间复杂度就是O(logN)！\nThe end这才是我们需要的时间复杂度较低的算法，同时也复习了递归调用的时间复杂度计算办法\n递归时间复杂度 = 递归次数 * 每次操作的负载度\n","categories":["把题目都给刷干净"],"tags":["C语言","算法","OJ刷题"]},{"title":"【C 语言】八大排序算法（带图详解）","url":"/posts/3996153794/","content":"前言  如果你把本专栏从头看到这里，那么恭喜你，本篇博客已经是是初阶数据结构的收尾啦😁！让我们一起来学习一下，那些常见的  排序算法！\n\n本篇博客主要讲述  八大排序🕵️‍♀️，桶排序 / 基数排序可能会在后期补上！欢迎大家收藏本文！\n\n\n在之前的学习中，我们已经接触过 ez 的冒泡排序，和通过堆实现的堆排序，本篇博客就不再详解这两个了！\n\n有些排序的思路不是那么好懂，我的讲解也会有不到位的地方，欢迎在评论区提出你的疑惑或建议！🌭\n\n[TOC]\n1. 插入排序 1.1 直接插入 基本思想 ：把待排序的数依照大小插入 一个已经有序的序列  中，直到所有数插入完毕，就能得到一个新的有序序列\n\n实际上我们日常生活中打  斗地主，在码牌的时候就运用了这种思想。把相同的数放在一起，并依照从小到大排列\n\n\n你可能会疑惑，都“已经有序”了，那还怎么排序？\n\n这需要我们之前学习链式二叉树时接触到的  分治思想\n当我们手头上只有两个数的时候，将大的那个数插入到小的数后头，就形成了一个有序的 2 数序列\n这时候再让下一个数加入进来，把它插入到相应位置，得到一个有序的 3 数序列\n依次递进，最终就能得到一个有序的 N 数序列\n\n如果学习过分治思想的你，肯定一拍桌子道：“我知道了，手头上只有两个数的时候，就是  分治的末端条件！”\n没错，我们就是要利用这种  思想 ，实现 从两个数开始  的插入排序！\n\n给定一个数组，需要你使用插入排序，将它变成  升序  序列9 1 2 5 7 4 8 6 3 5\n\n我们就从 9 开始，将 1 插入到 9 的前面，2 插入到 1、9 之间，……\n\n这样就能最终排序出 1 2 3 4 5 5 6 7 8 9 的结果\n\n最后以代码的形式操作，如下面所示\n// 插入排序 void InsertSort(int* a, int n){    // 在一个数组中插入新的数，每一趟都让最后的 end+1 的数据大于 end    for (int i = 0; i &lt; n - 1; i++)    {        int end = i;        int tmp = a[end+1];        while (end &gt;= 0)        {            if (tmp &lt; a[end])            {                a[end + 1] = a[end]; // 将当前和下一位交换                end-= 1; // 往前移动，继续比较            }            else                break;        }        a[end+1] = tmp;        // 最后 end 不符合条件出循环的时候，end 可能为 -1，a[end] 会越界        // 如果是 break 出的循环，end+1 和 tmp 的位置相同，自己等于自己，问题不大    }}\n\n由此我们可以总结出直接插入排序的一些特性\n\n时间复杂度：O(N^2^)\n空间复杂度：O(1)，是  原地算法\n元素越接近有序的时候，需要交换的次数就越少，算法的效率越高\n\n\n1.2 希尔排序  希尔排序是对直接插入的优化，又称“缩小增量法”。之前我们是进数组之后直接开 R，现在先 Q 一下再 R 闪，这样才能打出更秀的操作。不过我的盲僧很菜，R 闪就没有成功过😥\n\n喂喂喂，好像跑题了！\n\n基本思想 ：先选定一个整数 gap，让后把待排序数据 以 gap 为间隔  进行单独的插入排序（预排序），这样让数列做到  局部有序 ，最后在进行插入排序，达到优化 插入排序算法效率  的目的\n比如我们设定 gap=3，这样原本的数组就被分割成了下面的模样，接着我们先对这 3 组数据进行单独的插入排序【这个操作被称为  预排序】\n\n你能写出它们单独插入排序后的结果吗？\n\n这时候我们的序列虽然不是有序的，但是只看一个小局部的时候，它是有序的。\n这样能  减少  插入排序操作时候的  比较次数，自然效率就变高了\n\n执行完  预排序  后，我们就可以对现在的新序列进行插入排序了。但是直接这么调用还不够优化。\n\n再仔细看看上面的思路，你会发现，其实 gap=1 的时候，就相当于一次插入排序了\n\n而且当数据量很大的时候，我们也需要实时改变我们的gap。\n待排序数据有 100 个，gap=3 就太小了，优化了个寂寞。\n待排序数据有 10 个，gap=20 就是搬起石头砸自己的脚，同样不行！\n\n解决这个方法其实很简单，我们只需要根据待排序数据的大小动态设置 gap 就可以了，比如gap=n/2\n这时候就可以进行这么一个操作：每次预排序过后就改变一下 gap，直到最后 gap=1 执行一次插入排序，数列有序\n\n落实到代码上，我们只需要把插入排序中所有和 1 有关的操作都改成 gap，就实现了希尔排序\n\n这里需要注意的是 gap 的范围，因为我设置的是 gap 每次都 /3，所以在最后可能会出现 gap=2/3=0 的情况，这时候其实排序还没有结束，但已经跳出循环了。我们需要在末尾 +1 保证最后一次插入排序的 gap=1\n\n// 希尔排序void ShellSort(int* a, int n){    // 只要把插入排序中的 1 全部改成 grap，就能形成一次间隔为 3 的预排序    // 当 grap=1 时，效果同插入排序相同    int grap = n;    // 当 grap=1，说明上一把已经是一次直接插入排序了    // 此时数据已经有序，退出循环    while (grap &gt; 1)    {        grap=grap/3+1;// 每一次都÷3, 再 +1；防止 grap=2/3=0 的情况        for (int i = 0; i &lt; n - grap; i++)        {            int end = i;            int tmp = a[end + grap];            while (end &gt;= 0)            {                if (tmp &lt; a[end])                {                    a[end + grap] = a[end];                    end -= grap;                }                else                    break;            }            a[end + grap] = tmp;        }    }}\n\n希尔排序的时间复杂度不好确定，因为我们通常会选取不同的 gap，导致时间效率也不同。不过大部分资料中给出的时间复杂度如下👇到  在“菜鸟教程”网，有对希尔排序时间复杂度的解析👉传送门\n\n\n2. 选择排序 2.1 直接选择 基本思路：遍历一遍数组，从中找出最大或最小的那一个数，然后将其放在数组前端。下一次遍历的时候，不再遍历这个数。\n注意：得到最大最小值后，需要将其和数组开头（或者结尾）的数进行  交换，而不能直接覆盖，不然会出现数据丢失\n\n这个排序的思路非常好理解。进一步拓展，如果我一次遍历选出两个数，将最大值放在数组尾部，最小值放在数组开头，就可以减少一半遍历的次数。\n// 数据交换void Swap(int* a, int* b){    int tmp = *a;    *a = *b;    *b = tmp;}// 直接选择排序void SelectSort(int* a, int n){    int max ,min;    int left = 0, right = n - 1;    while (left &lt; right){        max = min = left;// 存放下标便于后面的交换        for (int i = left; i &lt;= right; i++)        {            if (a[i] &gt;=a[max]){                max= i;            }            if (a[i] &lt;= a[min]){                min= i;            }        }        Swap(&amp;a[min], &amp;a[left]);        if (max == left) {            max = min;        }// 如果 max 数据在开头，第一次交换会被替换        // 所以需要重定向 max 的位置，再交换 max        Swap(&amp;a[max], &amp;a[right]);        left++;        right--;    }}\n\n不过，这个算法需要多次遍历数组，效率自然低的离谱，堪比冒泡（甚至比冒泡还拉）\n\n时间复杂度：O(N^2^)\n空间复杂度：O(1)\n\n\n2.2 堆排序  堆排序是指利用  二叉树 - 堆  这种数据结构来进行选择数据的一种排序算法，它是选择排序的一种。\n需要注意的是：升序要建大堆，排降序建小堆\n堆排序已经在之前的博客中讲解过，点击下方连接即可查看！👇\n\n【C 语言】什么是堆？堆排序和 TopK 问题又是如何实现的\n\n这里给出堆排序的源码，或许聪明的你看源码就能看懂呢？\n// 交换数组中两个元素的位置 void Swap(int* pa, int* pb) {    int tmp = *pa;    *pa = *pb;    *pb = tmp;}// 打印数组void PrintArray(int* a,int n,const char*info){    printf(\"[%s]\",info);    for(int i=0;i&lt;n;i++)    {        printf(\"%d\",a[i]);    }    printf(\"\\n\");}// 堆排序void AdjustDown(int* a, int n, int root){    assert(a);    int parent = root;    int child = parent * 2 + 1;// 左孩子    while (child &lt; n){        // 找左右孩子中小(大) 的那一个         if (child + 1 &lt; n &amp;&amp; a[child] &lt; a[child + 1])        {// 如果左孩子大(小) 于右孩子，则选择右孩子            child++;        }        // 这个也需要根据上方 a[child] &lt; a[child + 1] 大于小于的不同进行修改        // 大堆，将大的往上调        // 小堆，将小的网上调        if (a[child] &gt; a[parent]){            Swap(&amp;a[child], &amp;a[parent]);            parent = child;            child = parent * 2 + 1;        }        else{            return;        }    }}// 升序用大堆// 降序用小堆void HeapSort(int* a, int n){    // 向下调整 -- 建堆 O(N)    for (int i = (n - 1 - 1) / 2; i &gt;= 0; --i){        AdjustDown(a, n, i);// 此时建的是一个小堆    }    PrintArray(a, n,\"建堆后\");    size_t end = n - 1;    while (end &gt; 0){        Swap(&amp;a[0], &amp;a[end]);// 前后交换，最大的数放到末尾，不进行下一次调整        AdjustDown(a, end, 0);        end--;    }}\n\n使用如下的数据进行测试\nint main(){    int arr[]={1,5,7,3,8,6};    int sz = sizeof(arr)/sizeof(arr[0]);    PrintArray(arr,sz,\"初始值\");    HeapSort(arr,sz);    PrintArray(arr,sz,\"完成排序\");    return 0;}\n\n可以得到升序序列\n$ ./test[初始值] 1 5 7 3 8 6 [建堆后] 8 5 7 3 1 6 [完成排序] 1 3 5 6 7 8 \n\n\n3. 交换排序 3.1 咕噜咕噜排序 说道  冒泡  排序啊，那就是陪伴咱们 C 语言学习始终 的一个老朋友了。\n在初识 C 语言的学习中，我曾写过一篇博客，里面讲解了用冒泡来模拟实现库函数 qsort👉 传送门\n\n它的思路就是对两个数进行比较，较大的数往尾部移动，较小的数字往头部移动\n\n在very very long time ago，我也写过关于冒泡排序的博客👇\n\n初识 C 语言 ==＞冒泡排序\n\n// 冒泡排序void BubbleSort(int* a, int n){    for (int i = 0; i &lt; n; i++)    {        int exchange = 0;        for(int j=0;j&lt;n-1-i;j++)        {            if (a[j] &gt; a[j + 1]){                exchange=1;                Swap(&amp;a[j], &amp;a[j + 1]);            }        }        if (exchange == 0){            break;           // 如果单趟排序没有发生交换，说明此时已经有序        }    }}\n\n\n空间复杂度：O(N^2^)\n时间复杂度：O(1)\n\n\n3.2 快速排序  快速排序是 Hoare 于 1962 年提出的一种二叉树结构的交换排序算法。\n基本思想 ：任取待排序序列中的某个元素作为基准值，按照该基准值将待排序集合分割成 两个子序列 ，左子序列中所有元素均 小于基准值 ，右 子序列中所有元素均 大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。\n\n3.2.1 Hoare 法  发明快排的大佬给出了一个方法，假设 0 下标处 为基准值 key。用左右指针来遍历数组，右指针找到比 key小  的数后停下，左指针找找到比 key大  的数后停下，它们俩进行  交换。\n最后 left 和 right 相遇的时候，左右序列就已经排好了，此时将 key 与它们相遇的位置进行交换。新的序列 key 的左边小于 key，右边大于 key（此时不一定有序）\n\n疑问：既然最后要将相遇位置和 key 进行交换，那要怎么保证相遇位置小于 key？\n答：通过右指针先走来实现！\n\n可能说完思路后，你还是不太了解这左右指针是怎么走的，别着急，来康康我画的动图👇\n\n因为是右指针先走，所以右指针停下的位置，一定是小于 key的位置。此时只会是 L 来相遇 R，不可能是 R 往左遇到 L（因为 L 停下的位置大于 key，在这个位置的右边不可能没有一个小于 key 的值）\n比如下图所示，如果 L 的位置右边只有一个比 key 小的值，那 R 在第一趟就会来到 2 的位置，然后 L 向右走一步与 R 相交，直接交换\n\n两种极端情况  也会有  下面的  两种  极端情况\n\nkey 右侧没有比 key 小的值，那么 R 会直接与 L 相交，再原地交换 key\nkey 右侧没有比 key 大的值，R 先移动（原地不动），L 直接与 R 在末尾相交，前后交换\n\n这两种极端情况，就是快排的  弱势  所在，在后头会讲述如何  优化 key 的选则，来避免这种极端情况\n\n下面给出 hoare 法的代码，中间的代码是一趟 hoare 排序的实现，而在末尾，我们递归排序 key 的前半区域和后半区域，一直递归到最小区间：【区间只有一个值，或者区间不存在】\nvoid QuickSort1(int* a, int begin, int end)//hoare{    if (begin &gt;= end){        return ;// 分治的末端条件判断    }    // 一趟排序    int left = begin, right = end;    int keyi = begin;    while (left &lt; right)    {        while ((a[right] &gt; a[keyi])&amp;&amp;(right&gt;=begin))        {            right--;        }        while ((a[left] &lt;= a[keyi])&amp;&amp;(left&lt;right))        {            left++;        }        Swap(&amp;a[left], &amp;a[right]);    }    Swap(&amp;a[left],&amp;a[keyi]);    keyi = left;// 必须移动 keyi 的位置    // 递归排序左右区间    QuickSort1(a, begin, keyi-1);    QuickSort1(a, keyi + 1, end);}\n\n3.2.2 挖坑法  挖坑法的思路比 Hoare 更好理解，详情见👇动图\n\n我们先用一个变量保存 key 的值（不是保存下标），然后 R 先走找比 key 小的，与坑位交换，L 找比 key 大的，与坑位交换。最终 LR 相遇的时候，把 key 放回相遇位置，就完成了一趟排序\n\n注意：图中为了便于理解，将  坑位用空白  表示。实际在内存中操作的时候，坑位可以一直是 key 的值，不需要真的把它移走或者删除\n\n怎样？是不是比方法 1 好理解一些呢？\n下面给出挖坑法的代码示例\n// 挖坑void QuickSort2(int* a, int begin, int end){    if (begin &gt;= end) {        return;    }    int left = begin, right = end;    int keyi = a[begin];// 先存放 keyi 的值    int pit = begin;//pit 作为坑位    while (left &lt; right)    {        while ((a[right] &gt; keyi) &amp;&amp; (right &gt;= begin))        {            right--;        }        Swap(&amp;a[pit], &amp;a[right]);        pit = right;        while ((a[left] &lt;= keyi) &amp;&amp; (left &lt; right))        {            left++;        }        Swap(&amp;a[pit], &amp;a[left]);        pit = left;    }    QuickSort2(a, begin, pit - 1);    QuickSort2(a, pit + 1, end);}\n\n3.2.3 前后指针法  这部分就不画动图了，不知下面的这种方式能不能讲解清楚呢？\n\n\n这里需要弄明白的是 cur 和 prev 是分别在什么情况下移动\n\ncur 比 key小  的时候，prev 往后 ++ 一位，二者交换（在刚开始的时候是原地交换，但在图 4 中就不是原地交换了）\ncur 比 key大  的时候，prev 不动，cur 继续往后 ++，直到找到比 key 小的数或者越界后停止（如果找到比 key 小的，就执行上一步的交换）\n最终 cur 越界了，交换 prev 和 key 的数据，一趟排序完成\n\n\n下面给出前后指针法的代码示例\nvoid QuickSort3(int* a, int begin, int end)// 前后指针{    if (begin &gt;= end) {        return;    }    int keyi = begin;    int prev = begin, cur = begin + 1;    while (cur &lt;= end)    {        while ((a[cur] &lt; a[keyi]) &amp;&amp; (a[++prev] != a[cur]))        {            Swap(&amp;a[prev], &amp;a[cur]);        }        cur++;    }    Swap(&amp;a[prev], &amp;a[keyi]);    keyi = prev;    QuickSort3(a, begin, keyi - 1);    QuickSort3(a, keyi + 1, end);}\n\n优化极端情况  上面  提到了快速排序有两种极端情况，我们可以用一个操作来优化它：\n既然 key 取数组首或尾部都可能会遇到它的后面没有比它小（或大）的数，那我们就让 key 尽量作为数组有序后应该处于中部的数来作为 key\n这时候不能直接选取待排序数组中部的数，因为它不一定是数值正好的那个\n我们可以选取数组  开头、末尾、中间的 3 个数进行比较 ，再选择这 3 个数里面 居中  的那个数作为我们的 key，这样就能避免无效遍历！\nint GetMid(int* a, int left, int right){    int mid = (left + right) / 2;    if (a[left] &lt; a[mid])    {        if (a[mid] &lt; a[right]){            return mid;        }        else if (a[left] &gt; a[right]){            return left;        }        else{            return right;        }    }    else // a[left] &gt; a[mid]    {        if (a[mid] &gt; a[right]){            return mid;        }        else if (a[left] &lt; a[right]){            return left;        }        else{            return right;        }    }    return -1;// 其实这个没啥意义}\n\n但是单纯加上这个代码并不可行，因为这时候的 key 不再处于序列开头了，也就意味这我们后头的代码都需要重新写一遍！\n\n这不坑爹吗这是？！\n为了不没事找事重写一遍代码，这里直接把找到的 MID 和 left 进行交换 就 OK 了！\n\n同时，为了避免多次递归  导致栈溢出，我们还可以设置一个条件，在序列长度小于 10 的时候调用其他排序（比如插入排序）来实现后面的排序操作\n3.2.4 快排的时间 / 空间复杂度  快排的递归调用非常类似链式二叉树的前序遍历，它一共会递归 logN 层级，每一层加起来都有 N 个数，这样就能算出它的时间复杂度\n\n时间复杂度：O(N*logN)\n空间复杂度：O(logN)，这个是递归开辟栈帧的空间消耗\n\n\n3.3 快排非递归实现  这部分的知识就比较深奥了，你可以先看看这篇博客，了解一下函数调用的时候会发生什么👉传送门\n\n但不要担心，其实它的思路并没有那么难！\n\n首先需要先搞明白，递归调用的本质是在操作什么？\n在快排中，递归调用的本质是让程序  自己来缩小排序的范围，再逐步扩大\n那我们可不可以利用  数据结构中的栈，来模拟实现程序运行中的递归操作呢？\n\n排序完一趟后，将下一趟的左右范围入栈\n程序先调用存放在  栈顶  的右边范围进行排序，并把这个范围的左右小区间再次入栈\n最后右边的区间已经不可再分，就开始返回调用左边区间\n\n这个操作就犹如链式二叉树的后序遍历，先递归访问右节点，再往回返回左节点\n最后得到的结果就是类似递归调用完毕后的结果\n\n\n如果你还没有学习数据结构里面的栈，点我速览！\n\n下面给出一个非递归的实现：\n// 非递归void QuickSort4(int* a, int begin, int end){    Stack st;    StackInit(&amp;st);    StackPush(&amp;st, begin);    StackPush(&amp;st, end);    while (!StackEmpty(&amp;st))    {        int right = StackTop(&amp;st);        StackPop(&amp;st);        int left = StackTop(&amp;st);        StackPop(&amp;st);        int keyi = PartSort3(a, left, right);        // [left,keyi-1][keyi+1，right]        if (left &lt; keyi-1)        {            StackPush(&amp;st, left);            StackPush(&amp;st, keyi-1);        }        if (keyi + 1 &lt; right)        {            StackPush(&amp;st, keyi+1);            StackPush(&amp;st, right);        }    }    StackDestory(&amp;st);}\n\n注意：因为这里需要得到一趟递归调用后  返回的 keyi，所以我们需要把之前写的  一趟快排  单独拿出来，并设置返回值\n\n来调用一下试试，成功了！\n\n\n4. 归并排序  基本思想：采用分治递归，将已有的子序列合并，得到一个有序的序列。即先使每个子序列有序，再使子序列段间有序\n\n若将  两个  有序表合并成一个有序表，称为  二路归并\n\n实现的步骤如下图\n\n\n先将区间通过递归分割成  分治末端（只有一个值）\n再对相邻两个区间进行比较，开辟一个新的数组，依次将两个区间中  小的那个按顺序摆放在新的数组中，再拷贝回原数组，就实现了归并\n当区间不存在的时候，开始返回递归，直到序列有序\n\n4.1 打印 printf 调试大法  这里最需要注意的就是分治的序列区间问题，如果代码不对，就很容易形成  越界访问！\n这里我们可以通过 printf 调试大法 来实现，打印出每一层递归时的区间，就能发现可能存在的  越界访问  问题。这种方法还能帮助我们理解  分治递归\nprintf(\"[%d,%d][%d,%d]\\n\", begin, mid, mid+1, end);\n\n\n\n如果你在写程序的时候，发现控制台的光标闪动了很久都没有打印出数据，那么多半是程序中有  死循环和 bug\n\n比如现在，我们初步查看递归调用中是没有出现越界的，但是答案错误，进一步调试发现，tmp 数组中有序数字，并没有被我们完整的拷贝回去\n原本是 2 5 拷贝回去变成了2 2，这个问题的根源很明显是 memcpy 函数调用有问题\n\n一看，哭笑不得，写了俩 sizeof，魔怔了属于是\n\n修改之后，没问题啦！\n\n\n4.3 非递归实现  归并排序的非递归无法用  栈来实现，因为我们不能把之前的  大区间  全给出栈了，因为这些区域还需要在最后重新进行归并！\n\n利用循环来控制不同的区间，由小到大，直到 gap=n 跳出循环\ngap 是归并数据的个数，gap=1 代表 1 个数归并，gap=2 代表两两归并\n\n\n根据上面的思路，我们可以写出下面的范围循环\nint gap = 1;while (gap &lt; n){    // 间距为 gap 是一组，两两归并    for (int i = 0; i &lt; n; i += 2 * gap)    {        int begin1 = i, end1 = i + gap - 1;        //i+gap 是个数，再 -1 是下标        int begin2 = i + gap, end2 = i + 2 * gap - 1;        //i+gap 到 i+2gap 是个数，再 -1 是下标        // 打印调试大法        printf(\"归并[%d,%d][%d,%d] -- gap=%d\\n\", begin1, end1, begin2, end2, gap);    }    gap *= 2;}\n\n跑一遍之前的测试用例，发现能搞定！这不就完事了吗？\n\n并没有！这里 gap 的操作都是*2，而且我们给的数组是偶数个，正好对的上\n如果我们再加一个数呢？程序打印出了每一层的递归区间，但是没有打印出最终的结果——因为这里在最后 free 的时候发现了  数组越界访问\n\n小知识，数组越界一般都是在 free 的时候检查到的\n\n\n\n\n接下来要做的事就是控制下标区间，避免它越界\nint begin1 = i, end1 = i + gap - 1;int begin2 = i + gap, end2 = i + 2 * gap - 1;\n\n\n\n\nbegin\nend\n\n\n\ni\ni+gap-1\n\n\ni+gap\ni+2*gap-1\n\n\n仔细分析过后，发现当 gap=2,i=8 的时候，就会出现 +gap 之后越界的情况\n\n而会出现越界情况的，不止有 end2，end1 和 begin2 都可能会出现\n我们需要做的就是把越界的下标  修正为不越界的  下标\n\nend1 越界，修正为不越界即可\nbegin2 和 end2 都越界，修正为非法区间begin2&gt;end2\nbegin2 不越界，end2 越界，修正 end2 即可\n\n修正下标后，可以看到程序已经正常排序出了序列\n虽然打印出来的范围还是有越界的下标，但是这个是 begin&gt;end 的非法区间，不符合程序运行的条件，就不会产生越界\n\n4.3.1 条件断点  这里还有一个骚操作，比如我们已经知道了是 8-9 的下标越界，这样我们就可以设置一个  断点 ，来直接 F5 跳到那个情况，而不需要 疯狂按 F10\n// 条件断点，用于调试if (begin1 == 8 &amp;&amp; end1 == 9 &amp;&amp; begin2 == 10 &amp;&amp; end2 == 11){    int x = 0;}\n\n\n这样我们的非递归实现也搞定啦！\n// 非递归void MergeSortNonR(int* a, int n){    int* tmp = (int*)malloc(sizeof(int) * n);    int gap = 1;    while (gap &lt; n)    {        // 间距为 gap 是一组，两两归并        for (int i = 0; i &lt; n; i += 2 * gap)        {            int begin1 = i, end1 = i + gap - 1;//i+gap 是个数，-1 是下标            int begin2 = i + gap, end2 = i + 2 * gap - 1;//i+gap 到 i+2gap 是个数，-1 是下标            if (end1 &gt;= n) {                end1 = n - 1;            }            if(begin2&gt;=n){                begin2 = n;                end2 = n - 1;            }            if (begin2 &lt; n &amp;&amp; end2 &gt;= n) {                end2 = n - 1;            }            //printf(\"归并[%d,%d][%d,%d] -- gap=%d\\n\", begin1, end1, begin2, end2, gap);            int index = i;            while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)            {                if (a[begin1] &lt; a[begin2])                    tmp[index++] = a[begin1++];                else                    tmp[index++] = a[begin2++];            }            while (begin1 &lt;= end1)                tmp[index++] = a[begin1++];            while (begin2 &lt;= end2)                tmp[index++] = a[begin2++];        }        memcpy(a, tmp, n * sizeof(int));        gap *= 2;    }    free(tmp);}\n\n4.2 递归源码  这里给出最终的源码，一些地方写了注释\n//_代表这是子函数void _MergeSort(int* a,int* tmp, int begin, int end){    if (begin &gt;= end){        return;    }    int mid = (begin + end) / 2;    _MergeSort(a, tmp, begin, mid);    _MergeSort(a, tmp, mid+1 , end);    //printf(\"归并[%d,%d][%d,%d]\\n\", begin, mid, mid+1, end);    int begin1 = begin, end1 = mid ;    int begin2 = mid+1 , end2 = end;    int cur = begin;    while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)    {        // 取小的放到新数组中        if (a[begin1] &lt; a[begin2]) {            tmp[cur++] = a[begin1++];        }        else {            tmp[cur++] = a[begin2++];        }    }    // 第一个循环结束，并不代表归并完毕，可能只有一个数组的数据跑完了    // 我们需要将另外一个数组的数据全部拷贝到 tmp 中（因为剩下的的数据已经有序）    while (begin1 &lt;= end1) {        tmp[cur++] = a[begin1++];    }    while (begin2 &lt;= end2) {        tmp[cur++] = a[begin2++];    }    memcpy(a+begin,tmp + begin, ((end - begin +1)*sizeof(int)));}// 归并排序void MergeSort(int* a, int n){    int* tmp = (int*)malloc(n * sizeof(int));    if(tmp==NULL){        printf(\"malloc failed\\n\");        exit(0);    }    _MergeSort(a, tmp, 0, n-1);    free(tmp);    tmp = NULL;    return;}\n\n4.4 归并排序的时间 / 空间复杂度\n时间复杂度：O(N*logN)\n空间复杂度：O(N)，创建数组的消耗\n\n\n5. 计数排序  计数排序的  基本思路：利用数组的下标作为映射，遍历到 x，在数组的 x 下标处 ++ 一次。最后再依照下标顺序将之前遍历到的数倒出来，就形成了正序序列。\n我在  网上  找来了一个很棒的动图（这个好像在很多博客里面都有😂）\n\n\n这个排序的思路就不难了，但有一点我们可以优化一下\n\n假设我们的序列是从 300 开始，而不是从 0 开始，那么开辟一个 301 个数的数组显然会浪费 300 之前的下标（因为并没有值）\n这时候我们可以找出数组的范围，开辟一个对应范围长度的数组，再利用相对映射的方式，来进行计数\n\n最后的代码如下\nvoid CountSort(int* a, int n){    int min = a[0], max = a[0];    for (int i = 1; i &lt; n; ++i)    {        if (a[i] &lt; min)            min = a[i];        if (a[i] &gt; max)            max = a[i];    }    int range = max - min + 1;    int* count = (int*)malloc(sizeof(int) * range);    assert(count);    memset(count, 0, sizeof(int) * range);    // 计数    for (int i = 0; i &lt; n; ++i)    {        count[a[i] - min]++;    }    // 排序    int j = 0;    for (int i = 0; i &lt; range; ++i)    {        while (count[i]--)        {            a[j++] = i + min;        }    }}\n\n5.1 计数排序的特性\n时间复杂度：O(range+N)\n空间复杂度：O(range)\n\n计数排序适用于范围集中的数，不然会产生很大的空间浪费\n计数排序可以排序  带负数  的序列，同样是通过映射的方式\n但是计数排序只能  排序整型数据，浮点类型是搞不定的\n\n看到这里，我们的八大排序就已经讲解完毕啦！\n不知道我讲解的够不够清楚呢？\n\n下面还有一个小点，就是关于排序算法的  稳定性\n6. 排序算法的稳定性  估计很多人和我一样，都对这个“稳定性”有错误的理解\n我本来以为，稳定性代表的是排序算法的  时间波动  大不大\n实际上的稳定性，是算法对于  某一个数  的处理好不好；\n比如下图，假设大家在考试，从上到下依次是交卷的顺序，我们发现王舞和李四的成绩相同，但是李四先交的卷。对于评判来说，当然是  先交卷且分高的  同学牛逼一点\n所以依照分数排序的时候，我们应该把李四排在王舞之前（即相同的数据在排序前后的位置不被改变）\n \n但有些算法在排序的时候，就做不到这一点\n这里对  直接选择排序  做一个简单的解释\n\n因为两个 3 的位置调换，就导致排序不够稳定\n实际上，所有需要进行  选择交换  的排序都不够稳定\n\n但是冒泡排序在交换的时候是严格保证大的数在后头，相等的数不交换  的思路，所以冒泡排序是稳定的\n\n6.1 稳定性表格\n\n\n排序算法\n稳定性\n排序算法\n稳定性\n\n\n\n直接插入\n稳定\n希尔\n不稳定\n\n\n冒泡\n稳定\n直接选择\n不稳定\n\n\n归并排序\n稳定\n堆排序\n不稳定\n\n\n-\n-\n快速排序\n不稳定\n\n\n-\n-\n计数排序\n不稳定\n\n\n6.2 时间复杂度表格\n7. 利用 clock 函数查看排序耗时  排序算法写完后，我们可以通过调用 clock 函数来查看每一个排序的耗时\n先利用 srand 和 time 函数来创建随机数数组，在调用每一个函数，来查看它们排序的耗时\n\n由于代码过长，这里只给出某一个排序的计时代码，其他就 CV 一下就 OK 了\nsrand(time(0));const int N = 10000;int* a1 = (int*)malloc(sizeof(int) * N);for (int i = 0; i &lt; N; ++i){    a1[i] = rand();// 生成随机数 数组}int begin1 = clock();// 读取系统时钟InsertSort(a1, N);int end1 = clock();// 再读取系统时钟// 二者相减得出该函数运行时长printf(\"InsertSort:%d\\n\", end1 - begin1);free(a1);\n\n运行结果：\n\n结语  到这里，排序的绝大数知识点就讲解完毕啦！\n本篇博客画了很多图，还挺不容易的，还请大家点赞支持一下！\n\n特别是那两个看起来很简单的动图，实际上  麻烦  的很\n\n球球了，点个赞呐！\n\n","categories":["数据结构太复杂"],"tags":["C语言","算法","排序","数据结构"]},{"title":"【C 语言】单链表太难学不懂？看这一篇就够了","url":"/posts/2793401961/","content":"[TOC]\n前言😀之前的博客中我们讲述了  顺序表的数据结构，顺序表和之前 C 语言学习的数组还是比较相似的。\n今天要学习的是  链表，这是一个全新的数据结构，和之前我们学的内容都不相同。\n\n编译器：VS2019\n\n1. 什么是链表  链表，如其名所示，是一个带链子的表\n和  顺序表的扩容开辟  相比，它可以利用内存  堆区  中的空闲空间，而不需要一个连续的长空间。从而达到提高空间利用效率的目的。\n\n\n链表中每一个单独开辟的“元素”称为一个节点\n链表有一个头指针 phead，用于指向链表的首节点\n单链表  中，每一个节点都有一个 next 指针，指向下一个节点\n链表的尾节点的 next 指向 NULL 空指针\n\n这样我们在使用的时候，就可以用过 next 指针访问链表的下一个节点，一直到最后一个节点的 next 为空停止。\n需要注意的是，链表的每个节点之间  并没有实际意义上的箭头 ，画出箭头只是方便我们理解。实际上，在内存中，链表的next 指针 就充当了箭头的角色。\n\n链表的结构在逻辑上连续，但在物理上不一定连续\n实际上在堆区开辟空间中，分配的内存可能连续，可能不连续\n\n1.1 链表的分类1 单向 &#x2F; 双向链表\n2 带头 &#x2F; 不带头  这里的  头，指的是一个头节点。该节点的next 指向链表实际的表头，val 中不存放有效数据\n实际使用时，带头的 head-&gt;next 相当于不带头的 phead 指针\n\n3 循环或者非循环\n本篇博客讲解的是  无头单向非循环  链表，双向链表将在之后的博客里面讲解！\n\n2. 开始敲代码！实际编写代码的时候，一定要记住：写完一个模块就要测试一次，不要全写完再测试！！！\n2.1  链表结构  和顺序表一样，使用单链表之前，我们需要创建一个“模板”，即单链表每个节点的结构体\ntypedef int SLTDataType;// 定义新符号，与该符号相关的都是链表内容typedef struct SListNode&#123;\tSLTDataType data; //val- 存放内容\tstruct SListNode* next; // 存储下一个节点的地址&#125;SListNode, SLN;\n\n2.2 开辟节点  当我们使用单链表时，需要先开辟一个头节点，并使它的 next 指针指向 NULL\nSListNode* node1 = (SListNode*)malloc(sizeof(SListNode));node1-&gt;data = 1;node1-&gt;next = NULL;\n\n这部分我们可以封装一个函数来实现！\nSListNode* BuySListNode(SLTDataType x)//x 代表该节点 val 的值&#123;\tSListNode* newnode = (SListNode*)malloc(sizeof(SListNode));\tif (newnode == NULL)\t&#123;\t\tprintf(&quot;malloc fail\\n&quot;);\t\texit(-1);\t&#125;\telse\t&#123;\t\tnewnode-&gt;data = x;\t\tnewnode-&gt;next = NULL;\t&#125;\treturn newnode;&#125;\n\n需要注意的是，使用这个函数的时候，我们应该先让另外一个指针来接收返回的newnode 地址，不建议直接让上一个节点的 next 来接收返回值\n\n这样做能方便我们后续 debug！\n\n// 建议做法SListNode* newnode = BuySListNode(x);tail-&gt;next = newnode;// 不建议tail-&gt;next=BuySListNode(x);\n\n2.3 尾插 &#x2F; 头插  尾插：将一个新节点连接到已有链表的尾部\n假设我们现在已经有了一个这样的链表，当我们需要尾插的时候，要怎么做呢？\n\n实际上，我们只需要开辟一个新的节点，并将上一个节点的 next 指向这个新开辟节点的地址即可！（尾插的新节点的next=NULL）\n\nvoid SListPushBack(SListNode** pphead, SLTDataType x)&#123;\tassert(pphead);\tSListNode* newnode = BuySListNode(x);\tif (*pphead == NULL)\t&#123;        // 如果原链表为空，直接让头指针 = 新开辟的节点地址\t\t*pphead = newnode;\t&#125;\telse// 原链表非空\t&#123; \t\tSListNode* tail = *pphead;\t\twhile (tail-&gt;next != NULL)\t\t&#123;   // 需要先找尾\t\t\ttail = tail-&gt;next;\t\t&#125;\t\ttail-&gt;next = newnode;\t&#125;&#125;\n\n而头插就没有尾插那么麻烦了！\n我们只需要将新节点的 next 指向原链表的头部，再将 head 头指针更改为新节点的地址 即可\nvoid SListPushFront(SListNode** pphead, SLTDataType x)&#123;\tassert(pphead);\tSListNode* newnode = BuySListNode(x);\tnewnode-&gt;next = *pphead;\t*pphead = newnode;&#125;\n\n细心的你应该注意到了，这里我们使用的都是二级指针pphead\n因为假设我们使用一级指针，直接传入头指针 phead 时，当我们需要更改该  指针指向的地址时，改动只会在函数内部生效，main 函数中的 phead 指针并没有被改变\n\n这是一个经典的函数  传址和传值  问题\n\n当我们需要更改 phead 本身时，需要传入二级指针\n\n\n2.4 尾删 &#x2F; 头删  尾删时，需要先进行找尾。并且需要保存尾部的前一个节点的地址\nwhile(tail-&gt;next!=NULL)// 会找到尾节点本身，不符合要求    // 尾删应该找到尾节点的前一个while (tail-&gt;next-&gt;next != NULL)\n\n同时，我们需要想到特殊情况\n\n链表为空，无需尾删\n链表只有一个，无需找尾\n\n具体的代码实现如下\nvoid SListPopBack(SListNode** pphead)&#123;\tassert(pphead);\t\tif (*pphead==NULL)\t&#123;\t\treturn;\t&#125;\telse if((*pphead)-&gt;next==NULL)\t&#123;\t\tfree(*pphead);\t\t*pphead = NULL;\t&#125;\telse\t&#123;\t\t// 有多个尾巴的情况\t\tSListNode* tail = *pphead;// 找尾巴\t\twhile (tail-&gt;next-&gt;next != NULL)\t\t&#123;\t\t\ttail = tail-&gt;next;\t\t&#125;\t\tfree(tail-&gt;next);\t\ttail-&gt;next = NULL;\t&#125;\t\treturn;&#125;\n\n头删的情况依旧简单一些\n我们需要用一个变量保存头节点，再让  头指针 phead 指向原本头节点的 next，最后 free 掉头节点即可\nvoid SListPopFront(SListNode** pphead)&#123;\tassert(pphead);\t\tif (*pphead == NULL)\t&#123;\t\treturn;\t&#125;\telse\t&#123;\t\tSListNode* oldhead = *pphead;\t\t*pphead = (*pphead)-&gt;next;\t\tfree(oldhead);\t\toldhead = NULL;\t&#125;\treturn;&#125;\n\n\n2.5 查找 &#x2F; 更改  查找函数需要我们在单链表中进行遍历，找到用户输入的 x 值，并返回它所在节点的地址\n\n查找函数并不需要更改 phead 指针，所以这里我们只需要传入一级指针\n\nSListNode* SListFind(SListNode* phead, SLTDataType x)&#123;\tassert(phead);\tSListNode* curt = phead;// 找 x 的位置\twhile (curt-&gt;next != NULL)\t&#123;\t\tif (curt-&gt;data == x)\t\t&#123;\t\t\treturn curt;\t\t&#125;\t\telse\t\t&#123;\t\t\tcurt = curt-&gt;next;\t\t&#125;\t&#125;\t// 找不到，返回空\treturn NULL;&#125;\n\n你可能会有一个疑惑，假设我的链表里面有多个 x 呢？这个函数  只能返回找到的第一个 x 的地址\n\n很遗憾，我们并没有什么好的办法来解决这个问题。除非用户知道他想找的 x 的准确地址，不然是很难搞定的。\n\n实际应用中，链表的一个节点存放的并不只有一个整型 x。我们可以通过其他参数进行多重判断。\n\n比如通讯录中，我们可以用名字 + 性别来精确查找。也可将所有找到的 x 都返回给用户进行选择，但那就不是本篇博客会涉及到的内容啦\n\n\n更改函数中，我们需要用户输入待更改节点的地址，和新的 val\n如果用户不知道需要更改节点的地址，可以用查找函数来查找。\nvoid SListmodify(SListNode* phead, SListNode* pos, SLTDataType x)&#123;\tassert(phead);\tpos-&gt;data = x;\treturn;&#125;\n\n\n2.6 在 pos 位置前 &#x2F; 后插入  除了基本的头尾增加，用户可能还需要在某一个特定节点前后进行插入，方便管理数据。这时候我们就需要灵活转变了\n\n链表不存在  顺序表中的数据越界\npos 位置可由 find 函数找到\n\n假设用户需要在 pos 位置之后插入，我们需要暂时断开链表，新插入一个节点后，重新链接\nvoid SListInsertAfter(SListNode** pphead, SListNode* pos, SLTDataType x)&#123;\tassert(pphead);\tassert(pos);\tSListNode* newnode = BuySListNode(x);\tSListNode* next = pos-&gt;next;// 原本 pos 的下一位\tpos-&gt;next = newnode;// 新插入的 pos 下一位\tnewnode-&gt;next = next;\treturn;&#125;\n\n如果是在 pos 之前插入，需要遍历查找 pos 的前一位，使用相同方法断开、插入、重连\nvoid SListInsert(SListNode** pphead, SListNode* pos, SLTDataType x)&#123;\tassert(pphead);\tassert(pos);\t\tif (pos == *pphead)\t&#123;\t\tSListPushFront(pphead, x);\t&#125;\telse\t&#123;\t\tSListNode* tail = *pphead;// 找 pos 前一个\t\twhile (tail-&gt;next != NULL)\t\t&#123;// 只写了这个情况，没有考虑 pos 是第一个的情况\t\t\tif (tail-&gt;next == pos)\t\t\t&#123;                 SListNode* newnode = BuySListNode(x);\t\t\t\ttail-&gt;next = newnode;\t\t\t\ttail-&gt;next-&gt;next = pos;\t\t\t\treturn;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\ttail = tail-&gt;next;\t\t\t&#125;\t\t&#125;\t&#125;\t\treturn;&#125;\n\n这里我们都传入了二级指针，因为当 pos 就是链表的头节点时，在 pos 前插入就相当于头插，可以直接调用之前写好的头插函数。\n当 pos 就是链表的头节点时，在其后插入相当于尾插。\n\n该函数不存在链表为空的情况，因为函数需要传入 pos。空链表中没有节点，pos 为空，assert 断言会报错。\n\n这里我编写的功能很简单，所以需要用户严格遵守使用规定，传入一个合法的 pos\n\n2.7 在 pos 位置删除数据  说完了插入，再来说说删除\n这里提供两个函数，一个是在删除 pos 位置的节点，另一个是删除 pos 下一位的节点\n这一部分其实就是对上一步的逆向，具体的就不详细说啦（偷懒）\n\n大家如果有不懂的，可以在评论区提问~~ 看到了就会回复的！\n\nvoid SListErase(SListNode** pphead, SListNode** pos)&#123;\tassert(pphead);\tassert(pos);\tif (*pos == *pphead)\t&#123;// 如果 pos 是头节点，等同于头删\t\tSListPopFront(pphead);\t&#125;\telse\t&#123;\t\tSListNode* tail = *pphead;// 找 pos 前一个\t\twhile (tail-&gt;next != NULL)\t\t&#123;\t\t\tif (tail-&gt;next == *pos)\t\t\t&#123;\t\t\t\ttail-&gt;next = (*pos)-&gt;next;\t\t\t\tfree(*pos);// 删除后 main 函数传过来的 pos 位置已被 free\t\t\t\t*pos = NULL;//*pos 置空，此时 main 函数中的 pos 也被置空\t\t\t\tpos = NULL;\t\t\t\treturn;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\ttail = tail-&gt;next;\t\t\t&#125;\t\t&#125;\t&#125;\treturn;&#125;void SListEraseAfter(SListNode** pphead, SListNode* pos)&#123;\tassert(pphead);\tassert(pos);\tSListNode* next = pos-&gt;next-&gt;next;\tfree(pos-&gt;next);\tpos-&gt;next = next;\treturn;&#125;\n\n2.8 打印链表  打印的时候可以打印出 -&gt; 箭头，方便我们查看链表的结构\nvoid SListPrint(SListNode* phead)&#123;\tSListNode* cur = phead;\twhile (cur != NULL)\t&#123;\t\tprintf(&quot;%d-&gt;&quot;, cur-&gt;data);\t\tcur = cur-&gt;next;\t&#125;\tprintf(&quot;NULL\\n&quot;);&#125;\n\n2.9 销毁链表  对于顺序表来说，销毁链表只需要 free 掉顺序表中  指向堆区空间的指针\n但对于链表来说，我们需要一步一步进行释放操作，并在释放完毕后将头指针置空\n\n如果该链表有头节点，则还需将头节点一并置空\n\nvoid SListDestroy(SListNode** pphead)&#123;\tassert(pphead);\tSListNode* curt = *pphead;\twhile (curt)\t&#123;\t\tSListNode* next = curt-&gt;next;\t\tfree(curt);\t\tcurt = next;\t&#125;\t*pphead = NULL;\treturn ;&#125;\n\n\n3. 测试  这一次，我依旧使用了  多文件编程  的方法来敲单链表的代码\n这样的好处在于，别人只需要看你的 .h 头文件，就能清楚的知道你这个项目大概实现了什么样的功能，就好比一篇文章的大纲一样。对于后续的项目实战来说，是非常重要的编程能力积累\n\n测试一下我们的代码，可以看到，所有函数的功能都能正常实现！\n\n\n结语🤳学习完单链表后，我开始接触了一些链表的 oj 题目，不得不说，链表这部分的题目，难度还是比之前 C 语言的时候练习的题目更大的！有很多题目都需要我们融会贯通之前的知识。\n最重要的是  通读代码和调试  的能力，这样才能更好地编写出算法\n\n如果这篇博客对你有帮助，还请点个👍，万分感谢！\n\n有什么问题的话，大家可以在评论区提出哦\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","链表"]},{"title":"【算法】C 程序的运行速度测试","url":"/posts/263649714/","content":"C 语言程序的运行速度测试\n\n\n代码随想录  上提到了一点，即我们应该学会估计一个时间复杂度较高的算法，在机器上的运行速度。\n\n如果题目给出的数据量级在高复杂度的算法中会超时，那就应该放弃使用这个代码，而想其他时间复杂度更优的解法；\n这样能避免在刷题的时候，图简单  写了个暴力写法却发现超时不过的尴尬（没错说的就是我自己）\n\n大部分 OJ 题目，对 C/C++ 代码的时间限制都是 1s。所以我们测试的目标也将放在 1s 上。\n\n1. 代码\n来源：http://www.360doc.com/content/23/0119/15/2690044_1064211133.shtml\n我的 Git：Gitee\n\n1.1 循环  首先是func.h，内部包含了三个循环函数，时间复杂度分别为O(N) O(N^2) O(NlogN)\n//func.h#include &lt;stdio.h&gt;// O(N)void func1(long long n){    printf(\"开始执行 O(N)的函数：%lld\\n\",n);    long long k=0;    for(long long i=0;i&lt;n;i++)    {        k++;    }}// O(N^2)void func2(long long n){    printf(\"开始执行 O(N^2)的函数：%lld\\n\",n);    long long k=0;    for(long long i=0;i&lt;n;i++)    {        for(long long j=0;j&lt;n;j++)        {            k++;        }    }}// O(NlogN)void func3(long long n){    printf(\"开始执行 O(NlogN)的函数：%lld\\n\",n);    long long k=0;    for(long long i=0;i&lt;n;i++)    {        // j 要从 1 开始        for(long long j=1;j&lt;n;j*=2)        {            k++;        }    }}\n\n1.2 获取毫秒级时间戳  随后是主文件，这里我们需要进行时间的测试，所以得想办法获取到毫秒级的时间戳。\ntime.h中的 time 函数只能够返回秒级时间戳，对于代码的时间测试来说显然是不够的。我们需要借助 Windows 和 Linux 的系统函数，获取到毫秒级时间戳\n#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;// http://www.360doc.com/content/23/0119/15/2690044_1064211133.shtml// 宏编译，分别使用 windows 和 linux 的系统函数 #ifdef _WIN32    #include&lt;time.h&gt;    #include&lt;windows.h&gt;#else    #include &lt;sys/time.h&gt;    #include &lt;unistd.h&gt;#endif// 获取当前毫秒级时间，给一个 char 指针，则打印到其中（字符串）// 后三位为毫秒uint64_t GetCurrentTimerMS(char* szTimer){    uint64_t nTimer = 0;#ifdef _WIN32\tSYSTEMTIME currentTime;\tGetLocalTime(&amp;currentTime);\tstruct tm temptm = {currentTime.wSecond,\t\tcurrentTime.wMinute,\t\tcurrentTime.wHour,\t\tcurrentTime.wDay,\t\tcurrentTime.wMonth - 1,\t\tcurrentTime.wYear - 1900\t};\tnTimer =  mktime(&amp;temptm) * 1000 + currentTime.wMilliseconds;#else\tstruct timeval tv;\tgettimeofday(&amp;tv,NULL);\t// printf(\"second:%ld\\n\",tv.tv_sec);  // 秒\tnTimer = tv.tv_sec*1000 + tv.tv_usec/1000;#endif    if(szTimer != NULL)        sprintf(szTimer, \"%llu\", nTimer);    return nTimer;}// 测试时间函数int test_def(){\tchar szTimer[64];\tuint64_t nTimer=-1;\tGetCurrentTimerMS(szTimer);\t// 带参数，字符串\tnTimer = GetCurrentTimerMS(NULL); // 不带参数\tprintf(\"millisecond1:%s\\nmillisecond2:%llu\\n\",szTimer,nTimer );  // 毫秒\treturn 0;}\n\n1.3 获取时间戳测试  先来执行一下这个测试函数test_def，结果如下\n$ gcc test.c -o test$ ./testmillisecond1:1681878963361millisecond2:1681878963361\n\n成功打印出了毫秒级的时间戳，分别是字符串类型和 uint64_t 长整型\n#ifdef _WIN32    #include &lt;time.h&gt;    #include&lt;windows.h&gt;#else    #include &lt;sys/time.h&gt;    #include &lt;unistd.h&gt;#endif\n\n这里还采用了宏定义，自动判断 windows 还是 linux，调用各自的系统接口函数。\n如下图，在 Windows 下的 Vs2019 也成功执行这个函数\n\n2. 开始测试  这个命令可以查看 linux 下的 cpu 型号\n$ cat /proc/cpuinfo | grep 'model name' |uniqmodel name      : Intel(R) Celeron(R) N5105 @ 2.00GHz\n\n2.1 示例  先测试 O(N) 算法在何等数量级时会超过 1s\n$ ./test请键入 n：500000000start_time: 1681880952986开始执行 O(N)的函数：500000000end_time:   1681880954073diff:       1087msstart_time: 1681880963999开始执行 O(N)的函数：450000000end_time:   1681880964993diff:       994ms请键入 n：460000000start_time: 1681881111806开始执行 O(N)的函数：460000000end_time:   1681881112804diff:       998ms请键入 n：470000000start_time: 1681881117572开始执行 O(N)的函数：470000000end_time:   1681881118604diff:       1032ms请键入 n：400000000start_time: 1681880967163开始执行 O(N)的函数：400000000end_time:   1681880968043diff:       880ms请键入 n：550000000start_time: 1681880970538开始执行 O(N)的函数：550000000end_time:   1681880971736diff:       1198ms\n\n如上，是我的 linux 服务器的测试结果。\n数量级大概在 460000000 的时候，就会达到 998ms，也就是将近 1s\n所以，当我们看到 Oj 的测试用量超过 4500000000 数量级的时候，就应该放弃 O(N) 算法！\n\n而在 windows 下，我的 R7 5800H 笔记本，运行到 700000000 数量级的时候，才需要 1s\n请键入 n：500000000start_time: 1681881322528开始执行 O(N)的函数：500000000end_time:   1681881323236diff:       708ms请键入 n：1000000000start_time: 1681881327548开始执行 O(N)的函数：1000000000end_time:   1681881328965diff:       1417ms请键入 n：600000000start_time: 1681881332928开始执行 O(N)的函数：600000000end_time:   1681881333792diff:       864ms请键入 n：800000000start_time: 1681881337404开始执行 O(N)的函数：800000000end_time:   1681881338537diff:       1133ms请键入 n：700000000start_time: 1681881341486开始执行 O(N)的函数：700000000end_time:   1681881342486diff:       1000ms\n\n2.2 结果  按如上办法测试，我分别测试了三种时间复杂度在多个平台上的结果。稍微了解这些数字，能帮助我们在判断题目选用算法上提供帮助。\n表中 E8 是科学计数法，代表 10 的 8 次方\n\n\n\n平台 /CPU\n时间复杂度\n数量级\n时间(毫秒)\n\n\n\nwindows (amd R7-5800H)\nO(N)\n7E9\n1000\n\n\n\nO(N2)\n3E4\n1022\n\n\n\nO(NlogN)\n1.7E7\n996\n\n\nCentos8 (Intel N5105)\nO(N)\n4.5E8\n994\n\n\n\nO(N2)\n2E4\n920\n\n\n\nO(NlogN)\n1.8E7\n966\n\n\nCentos7.2 (Intel Xeon Platinum 8255C)\nO(N)\n5.8E8\n990\n\n\n\nO(N2)\n2.4E4\n976\n\n\n\nO(NlogN)\n2.1E7\n976\n\n\n数据测试于23.04.19\n\n本来还想测测牛客和 leetcode 的，结果发现它们运行 O(N^2) 量级的函数，都 E7 了还是几 ms 就搞定了，感觉测试的结果不准，故放弃😂\n\n\n","categories":["把题目都给刷干净"],"tags":["C语言","算法","OJ刷题"]},{"title":"【C 语言】顺序表（详解）","url":"/posts/1519855244/","content":"[TOC]\n前言  顺序表是我们学习数据结构第一阶段的必经之路\n什么是顺序表，且听我慢慢道来\n本篇博客用到的知识点：\n\n动态内存管理\n自定义类型 - 结构体\n所用编译器：VS2019\n\n\n1. 什么是顺序表？1.1 线性表  线性表是数据结构的一种，它是 n 个具有相同特性的数据元素的有限序列。 常见的线性表：顺序表、链表、栈、队列、字符串……\n线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理内存上存储时，通常以数组和链式结构的形式存储。\n本篇博客所讲述的顺序表，就是以  数组结构存储的线性表\n\n\n2. 编写你的顺序表！为了保证写完之后不要进入  贤者 debug 状态 ，建议每编写一个模块，就在test.c 的 main 函数中进行测试，保证当前编写的模块正确后再进行下一步！\n不然问题多了，改起来很头疼的！\n\n2.0 赛前准备  和我们日常所用的数组不同，顺序表的这个结构，主要的组成部分是一个结构体（本篇博客中的线性表以 int 为例）\nstruct SeqList&#123;\tint* a;\tint size;     // 存储数据个数\tint capacity; // 存储空间大小&#125;;\n\n为了方便使用，我们可以使用 typedef 对符号进行重定义\ntypedef int SLDataType;// 和普通的整型区分开，以此命名的数据和顺序表直接相关// 动态顺序表typedef struct SeqList&#123;\tSLDataType* a;\tint size;     // 存储数据个数\tint capacity; // 存储空间大小&#125;SeqList;//SeqList 可以替代 struct SeqList\n\n2.1 初始化  本次编写顺序表代码，我们采用“多文件编程”方式，将函数的实现，函数的声明与主函数分开，分别放入两个源文件和一个头文件\n\n先在 main 函数中定义一个顺序表的结构体，编写 SQLinst 函数进行初始化\nSeqList s;// 创建结构体变量SQLinst(&amp;s);// 初始化\n\n在.h 文件中，我们写入函数声明和库函数的引用。\n注意需要在另外两个.c 文件中以 &quot;Seqlist.h&quot; 方式引用自定义头文件\n#include&quot;Seqlist.h&quot;\n\n\n初始化方式如下，我们先给 a 用 calloc 函数开辟 3 个 SLDataType(int)类型的空间\n\nCAPA：由 define 定义的符号，方便后续修改初始容量\n\nvoid SQLinst(SeqList* sql)&#123;\tassert(sql);\tsql-&gt;a = (SLDataType*)calloc(CAPA,sizeof(SLDataType));\tsql-&gt;capacity = CAPA;\tsql-&gt;size = 0;\treturn;&#125;\n\n\n2.2 容量检查  既然我们的函数是由 calloc 开辟的动态内存空间，就需要在顺序表内空间不够用的时候，检查容量，判断是否需要扩容\nvoid CheckCapacity(SeqList* sql)&#123;\tassert(sql);\tif (sql-&gt;size &lt; sql-&gt;capacity)\t\treturn;\telse\t&#123;\t\tsize_t newcapacity = 2 * (sql-&gt;capacity);\t\tSLDataType* tmp = (SLDataType*)realloc(sql-&gt;a,newcapacity*sizeof(SLDataType));\t\tif (tmp == NULL)\t\t&#123;\t\t\tprintf(&quot;realloc failed\\n&quot;);\t\t\texit(0);\t\t&#125;\t\telse\t\t&#123;\t\t\tsql-&gt;a = tmp;\t\t\tsql-&gt;capacity = newcapacity;\t\t&#125;\t&#125;\treturn;&#125;\n\n使用 realloc 函数的时候需要注意，它可能扩容失败，所以我们不能直接让 sql-&gt;a 来接收 realloc 函数的返回值（扩容失败返回 NULL，相当于前功尽弃）\n而是需要用一个中间变量 tmp 来接收开辟后的地址，确认 realloc 成功后再赋值给 a。同时，也需要将 sql-&gt;capacity 更改成新的容量\n\n2.3 打印顺序表void SQLprint(SeqList* sql)&#123;\tassert(sql);\tfor (int i = 0; i &lt; (sql-&gt;size); i++)\t&#123;\t\tprintf(&quot;%d &quot;, sql-&gt;a[i]);\t&#125;\tprintf(&quot;\\n&quot;);\treturn;&#125;\n\n2.4 尾插和尾删  和平时使用数组不同的是，线性表中把在表尾插入数据称作尾插、删除数据叫做尾删，对应的是 pushback 和popback\n\n如果你看过之前我的那篇  函数调用参数压栈  的博客，应该还记得，汇编代码中入栈和出栈也是 push 和 pop\n\nvoid SQLpushback(SeqList* sql, size_t x);// 尾插void SQLpopback(SeqList* sql);// 尾删\n\n实现方式很是简单，和我们日常在数组尾部插入元素相同\n需要注意的是，这里我们插入的数据是 size_t（unsigned int) 类型，也就是说，这个顺序表中并没有负数\nvoid SQLpushback(SeqList* sql, size_t x)&#123;\tassert(sql);\tCheckCapacity(sql);// 使用时检查容量\tsql-&gt;a[sql-&gt;size] = x;\tsql-&gt;size++;\treturn;&#125;void SQLpopback(SeqList* sql)&#123;\tassert(sql);    //sql-&gt;a[sql-&gt;size] = 0;    // 这里可以把最后一个数改为 0，也可以不改\tsql-&gt;size--;\treturn;&#125;\n\n\n2.5 头插和头删  和尾部修改数据不同，在头部修改数据，必须要把已有  数据整体往后移动\n\nvoid SQLpushfront(SeqList* sql, size_t x)&#123;\tassert(sql);\tCheckCapacity(sql);\tint i = sql-&gt;size;\twhile (i &gt;= 0)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i - 1];\t\ti--;\t&#125;\tsql-&gt;a[0] = x;// 整体后移 之后修改第一个数\tsql-&gt;size++;\treturn;&#125;void SQLpopfront(SeqList* sql)&#123;\tassert(sql);\tint i = 0;\twhile (i &lt; (int)sql-&gt;size)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i + 1];\t\ti++;// 直接整体前移即可\t&#125;\tsql-&gt;size--;\treturn;&#125;\n\n2.6 插入和删除  除了头尾的操作，我们还需要编写在顺序表中间的插入和删除操作\n\n插入：需要将插入位置之后的数据整体后移\n删除：删除位置之后的数据整体前移\npos：插入位置的  下标\n\nvoid SQLinsert(SeqList* sql, size_t pos, size_t x)&#123;\tassert(sql);\tif (pos &gt;= (int)sql-&gt;size)\t&#123;// 温和的判断，assert 太过暴力，在 OJ 里容易出错\t\tprintf(&quot;input err\\n&quot;);\t\treturn;\t&#125;\tCheckCapacity(sql);\tint i = sql-&gt;size;\twhile (i &gt; (int)pos)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i - 1];\t\ti--;\t&#125;\tsql-&gt;a[pos]=x;\tsql-&gt;size++;\treturn;&#125;void SQLerase(SeqList* sql, size_t pos)&#123;\tassert(sql);\tif (pos &gt;= (int)sql-&gt;size)\t&#123;// 温和的判断，assert 太过暴力，在 OJ 里容易出错\t\tprintf(&quot;input err\\n&quot;);\t\treturn;\t&#125;\tint i = pos;\twhile (i &lt; (int)sql-&gt;size-1)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i + 1];\t\ti++;\t&#125;\tsql-&gt;size--;\treturn;&#125;\n\n2.7 查找和更改  当我们需要查找的时候，必须从头开始遍历整个数组，来找到待查找元素\nint SQLfind(SeqList* sql, size_t x)&#123;\tassert(sql);\tfor (int i = 0; i &lt; sql-&gt;size; i++)\t&#123;\t\tif (sql-&gt;a[i] == x)\t\t&#123;\t\t\treturn i;// 返回下标\t\t&#125;\t&#125;\tprintf(&quot;find err\\n&quot;);\treturn -1;&#125;\n\n而修改函数则是在查找的基础上，更改掉目标元素\nvoid SQLmodify(SeqList* sql, size_t pos, size_t x)&#123;\tassert(sql);\tsql-&gt;a[pos] = x;\t\treturn;&#125;\n\n如果用户不知道自己想修改的元素的下标，可以通过 find 函数查找，再调用修改函数\n\n3. 菜单  一个小建议是，不要在一开始编写函数的时候就写出菜单！\n因为这样非常不方便 debug，你需要按菜单上的函数调用再进行下一步操作\n\n话说是不是应该在前面就告诉大家？😂\n\n\n菜单的使用需要配合 switch&#x2F;case 语句来执行，方便用户输入操作数进行函数调用\nvoid menu()&#123;\tprintf(&quot;*****************************\\n&quot;);\tprintf(&quot;******1. 头插  2. 尾插 *********\\n&quot;);\tprintf(&quot;******3. 头删  4. 尾删 *********\\n&quot;);\tprintf(&quot;******5. 插入  6. 删除 *********\\n&quot;);\tprintf(&quot;******7. 查找  8. 更改 *********\\n&quot;);\tprintf(&quot;******9. 打印  0.exit*********\\n&quot;);\tprintf(&quot;*****************************\\n&quot;);&#125;\n\n我们可以在每个模块 printf 对应的提示，方便用户操作顺序表\nint main()&#123;\tSeqList s;// 创建结构体变量\tSQLinst(&amp;s);// 初始化#if\tM\ttest1(&amp;s);// 测试函数#endif\t\tmenu();\tprintf(&quot; 请输入命令 &gt;&quot;);\tint option;\tscanf(&quot;%d&quot;, &amp;option);\tdo&#123;\t\tswitch (option)\t\t&#123;\t\tcase 0:\t\t&#123;\t\t\tSQLdestory(&amp;s);\t\t\tprintf(&quot;destory SQL\\n&quot;);\t\t\texit(0);\t\t&#125;\t\tcase 1:\t\t&#123;\t\t\tint x;\t\t\tprintf(&quot; 请输入需要头插的数 &gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;x);\t\t\tSQLpushfront(&amp;s, x);\t\t\tbreak;\t\t&#125;\t\tcase 2:\t\t&#123;\t\t\tint y;\t\t\tprintf(&quot; 请输入需要尾插的数 &gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;y);\t\t\tSQLpushback(&amp;s, y);\t\t\tbreak;\t\t&#125;\t\tcase 3:\t\t\tSQLpopfront(&amp;s);\t\t\tbreak;\t\tcase 4:\t\t\tSQLpopback(&amp;s);\t\t\tbreak;\t\tcase 5:\t\t&#123;\t\t\tint m, n;\t\t\tprintf(&quot; 请输入插入位置和插入数 &gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;m, &amp;n);\t\t\tSQLinsert(&amp;s, m, n);\t\t\tbreak;\t\t&#125;\t\tcase 6:\t\t&#123;\t\t\tint d;\t\t\tprintf(&quot; 请输入待删除数的位置 &gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;d);\t\t\tSQLerase(&amp;s, d);\t\t\tbreak;\t\t&#125;\t\tcase 7:\t\t&#123;\t\t\tint f;\t\t\tprintf(&quot; 请输入需要查找的数 &gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;f);\t\t\tprintf(&quot; 该数下标为:%d\\n&quot;, SQLfind(&amp;s, f));\t\t\tbreak;\t\t&#125;\t\tcase 8:\t\t&#123;\t\t\tint h, i;\t\t\tprintf(&quot; 请输入需要更改的下标和新的数字 \\n&quot;);\t\t\tprintf(&quot; 如果您不知道该数的位置，可以调用查找模块 \\n&quot;);\t\t\tprintf(&quot; 请输入 &gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;h, &amp;i);\t\t\tSQLmodify(&amp;s, h, i);\t\t\tbreak;\t\t&#125;\t\tcase 9:\t\t\tSQLprint(&amp;s);\t\t\tbreak;\t\t&#125;\t\tprintf(&quot; 请输入命令 &gt;&quot;);\t&#125; while (scanf(&quot;%d&quot;, &amp;option) != EOF);\treturn 0;&#125;\n\n最终效果如图\n\n一些 err当我使用 switch&#x2F;case 语句，在 case 语句中定义局部变量的时候，VS 报错“声明不能包含标签”\n\n这个报错并不会阻止程序运行\n\n\n解决办法是在 case 语句后带上大括号，报错就消失了\n\n\n总结  顺序表内容算是对前面学习的一些 C 语言知识的运用，数据结构的严谨性更胜一筹。\n比如在判断 pos 和 size 的大小的时候，会报错类型不一致。\n这时候我们需要把无符号整型的 size 强制转换为 int 类型，再和 pos 进行比较！\n\n如果这篇博客对你有帮助，还请点个👍吧\n\n","categories":["数据结构太复杂"],"tags":["C语言","数组","数据结构"]},{"title":"【C 语言】带你刷爆十道链表 OJ","url":"/posts/3770717253/","content":"[TOC]\n前言，CSDN 的小问题😥最近写博客的时候，发现 CSDN 的 markdown 语法不支持加粗  一句话末尾的标点符号\n** 你好呀，**** 你好呀 **，\n\n这两种方式在 typora 上都会加粗（包括末尾的标点）\n但是在 CSDN 上，第一种情况会显示出 markdown 源码，无法加粗\n\n你好呀，我是你的好朋友  你好呀，我是你的好朋友\n\n虽然这不是什么大事，但有的时候写博客，一句本来应该是加粗的话，多显示了几个 **，不太美观，还会给不了解 markdown 的读者带来困扰：“作者在这里打几个* 号 是干嘛？”\n\n上一篇博客 ，我们学习了 单向无头非循环链表 ，本篇博客就让我们实践一下，刷十道 leetcode 的 链表 OJ 题目  吧🌭\n如果你把本篇博客里的这几道题都弄明白了，那说明你对链表的掌握已经非常棒了！加油！\n话不多说，直接进入今天的正题！\n第一题：206. 反转链表\nleetcode：206. 反转链表\n\n题目需要我们把 1-2-3-4-5 的链表反转为 5-4-3-2-1 的链表\n\n有一种取巧的办法，是将所有数取出来放入一个数组，再倒着将数组里面的数放回去\n这种办法可以通过 OJ，因为 leetcode 并没有检查返回链表的地址。但并不符合题目的真正要求\n\nstruct ListNode* reverseList(struct ListNode* head)&#123;    struct ListNode* newhead=NULL;    struct ListNode* cur=head;    while(cur)    &#123;        struct ListNode* next=cur-&gt;next;        cur-&gt;next=newhead;        newhead=cur;        cur=next;    &#125;    return newhead;&#125;\n\n\n\n第二题：876. 链表的中间节点\nLeetCode： 876. 链表的中间结点\n\n\n这道题目需要我们返回单链表的中间节点\n如果链表节点个数是奇数，返回中间节点；\n如果链表节点个数是偶数，返回第二个节点。\n\n对于数组和顺序表来说，我们只需要利用下标直接访问中间节点即可\n对于单链表来说，我们不知道它究竟有多少个节点，即便知道了，也需要通过遍历的方法找到这个中间节点\n\n\n这道题我想出了两种解题方式\n解法一：遍历  通过遍历得出该链表的节点个数，再使用一个新的指针，查找中间节点\nstruct ListNode* middleNode(struct ListNode* head)&#123;    if(head==NULL)        return NULL;    int count=1;// 计算链表一共的节点数    struct ListNode* tail=head;// 找尾    while(tail-&gt;next!=NULL)    &#123;        tail=tail-&gt;next;        count++;    &#125;    int half=(count/2);     // 如果是 3 结果为 1，如果是 4 结果为 2    // 正好是从 head 开始寻找的次数    struct ListNode* mid =head;    while((mid-&gt;next!=NULL)&amp;&amp;(half--))    &#123;        mid=mid-&gt;next;    &#125;    return mid;&#125;\n\n对于链表 oj 题目，leetcode 会把这个链表的形式以注释的方式标注在最前面\n\n解法二：快慢指针（很爽👍）\n这种方法实现起来也很是  简洁，也击败了更多用户！\nstruct ListNode* middleNode(struct ListNode* head)&#123;    if(head==NULL)        return NULL;    struct ListNode*fast=head;    struct ListNode*slow=head;    while(fast&amp;&amp;fast-&gt;next)    &#123;        fast=fast-&gt;next-&gt;next;        slow=slow-&gt;next;    &#125;    return slow;&#125;\n\n\n\n第三题：OR36 链表的回文结构👨‍🔧\n牛客网：OR36 链表的回文结构\n\n\n这道题我们可以使用一个很特别的方法\n\n先找到这串链表的中间节点（可以用到 876 里的函数）\n\n再将这个节点之后的链表逆置（206 反转链表）\n\n\n1-2-3-2-1// 逆置后1-2-1-2-3\n\n需要注意的是，逆置函数并不会改变  第一个 2 的 next 节点，它依旧是链接在 3 上的\n// 进行遍历判断1-2-(3)1-2-3\n\n这样我们就能判断出该链表是否为回文结构了！\n\n开始敲代码，发现牛客网上只有 C++ 的选项，没有 C 语言\n\n实际上，C++ 编译器都是支持 C 语言的，我们可以直接在题目给出的 C++ 结构下进行 C 语言代码的编写\n\n题目要求的返回值是一个 bool 类型。如果你不了解它，布尔类型是 C99 引入的，简单的来说，ture 代表 1，false 代表 0\n\n在之前的博客中我写到过这个类型👉点我\n\n\nclass PalindromeList &#123;public:    // 链表逆置    struct ListNode* reverseList(struct ListNode* head) &#123;        struct ListNode* newhead = NULL;        struct ListNode* cur = head;        while (cur)        &#123;            struct ListNode* next = cur-&gt;next;            cur-&gt;next = newhead;            newhead = cur;            cur = next;        &#125;        return newhead;    &#125;    // 中间节点返回    //1 2 3 4  偶数个，返回 3    //1 2 3    奇数个，返回 2    struct ListNode* middleNode(struct ListNode* head) &#123;        if (head == NULL)            return NULL;        int count = 1;// 计算链表一共的节点数        struct ListNode* tail = head;// 找尾        while (tail-&gt;next != NULL)        &#123;            tail = tail-&gt;next;            count++;        &#125;        int half = (count / 2);        // 如果是 3 结果为 1，如果是 4 结果为 2        // 正好是需要从 head 开始寻找的次数        struct ListNode* mid = head;        while ((mid-&gt;next != NULL) &amp;&amp; (half--))        &#123;            mid = mid-&gt;next;        &#125;        return mid;    &#125;    bool chkPalindrome(ListNode* A) &#123;        struct ListNode* mid = middleNode(A);        struct ListNode* ret = reverseList(mid);        //1 2 3 2 1 回文链表        // 先逆转后面 3 个        //1 2 1 2 3        // 这时候第一个 2 存放的 next 依旧是下一个 3 的地址        // 使用 while 循环进行判断，都是判断 3 次是否相等        // 相等就是回文，否则不是        while (A &amp;&amp; ret)        &#123;            if (A-&gt;val == ret-&gt;val)            &#123;                A = A-&gt;next;                ret = ret-&gt;next;            &#125;            else            &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n\n\n第四题：链表中倒数第 K 个节点\n牛客网：链表中倒数第 k 个结点\n\n\n这道题我们同样可以使用快慢指针来解决\n倒数第 k 个节点，就需要快指针先走 k 步\n\n这里我尝试用 PS 做了一个动图，给大伙瞅瞅\n\n\n这道题也是只有 C++ 选项。和上道题一样，我们直接在 C++ 下编写 C 语言代码就可以了\nclass Solution &#123;public:    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;        if (pListHead == NULL)            return NULL;                struct ListNode* fast = pListHead;        struct ListNode* slow = pListHead;        int i = k;        while (i--)        &#123;            if (fast == NULL)            &#123;                return NULL;            &#125;            fast = fast-&gt;next;        &#125;        while (fast)        &#123;            fast = fast-&gt;next;            slow = slow-&gt;next;        &#125;        return slow;    &#125;&#125;;\n\n\n\n第五题：CM11 链表分割\n牛客网：CM11 链表分割\n\n\n这道题我使用了带头节点的做法，head-&gt;next等同于不带头链表的 head 指针\nclass Partition &#123;public:    ListNode* partition(ListNode* pHead, int x) &#123;    if(pHead==NULL)        return NULL;            struct ListNode* newhead=(struct ListNode*)malloc(sizeof(struct ListNode));// 新链表 - 比 x 小的部分    struct ListNode* Bigger=(struct ListNode*)malloc(sizeof(struct ListNode));// 比 x 大的部分            // 这里需要定义一个新的指针来遍历链表，防止找不到头    struct ListNode* head=newhead;    struct ListNode* big=Bigger;        while(pHead)    &#123;// 遍历里面比 x 小的，链接在 newhead 上        if(pHead-&gt;val  &lt;x)        &#123;            head-&gt;next=pHead;            pHead=pHead-&gt;next;            head=head-&gt;next;                    &#125;        else        &#123;// 比 x 大的链接在 bigger 上            big-&gt;next=pHead;            pHead=pHead-&gt;next;            big=big-&gt;next;        &#125;    &#125;    big-&gt;next=NULL;//big 的末尾需要置空    head-&gt;next=Bigger-&gt;next;// 让 head 的末尾链接 bigger 的头部            struct ListNode* list=newhead-&gt;next;    free(newhead);    free(Bigger);    return list;    &#125;&#125;;\n\n\n第六题：21. 合并两个有序链表\nleetcode：21. 合并两个有序链表\n\n\n这道题的解析就放注释啦\nstruct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)&#123;    if(list1==NULL)        return list2;    if(list2==NULL)        return list1;    struct ListNode* H1=list1;    struct ListNode* H2=list2;    struct ListNode* newList=NULL;    struct ListNode* tail=NULL;    if(H1-&gt;val&lt;H2-&gt;val)// 选取新链表的第一个节点    &#123;        newList=H1;        tail=H1;        H1=H1-&gt;next;    &#125;    else    &#123;        newList=H2;        tail=H2;        H2=H2-&gt;next;    &#125;    while(H1 &amp;&amp; H2)// 其中一个走完了，就退出循环    &#123;        if(H1-&gt;val&lt;H2-&gt;val)// 找小的那一个链接在尾部        &#123;            tail-&gt;next=H1;            tail=H1;// 等同于 tail=tail-&gt;next            H1=H1-&gt;next;        &#125;        else        &#123;            tail-&gt;next=H2;            tail=H2;// 等同于 tail=tail-&gt;next            H2=H2-&gt;next;        &#125;    &#125;// 最后结束了，还需要判断是谁走完了，把另外一个链表剩下的部分链接在尾部// 链表本身是有序的，所以最后无需再进行排序，直接链接即可    if(H1)        tail-&gt;next=H1;    if(H2)        tail-&gt;next=H2;        return newList;&#125;\n\n\n\n第七题：160. 相交链表\nleetcode：160. 相交链表\n\n\n题目需要我们返回两个相交链表的交点c1，如果不相交就返回 NULL。\n最后一行还提到了，这道题不能破坏原始链表\n\n本题思路如下：\n\n先用两个指针，分别遍历 A、B 链表，得到两个链表长度\n遍历完毕时，指针处在末尾C3，如果末尾不相等，就说明该链表不相交，返回 NULL\n如果相等，计算出 A、B 链表的长度差，使用快慢指针进行操作\n快指针从长链表开始走，先走 |A-B| 长度。然后慢指针也开始移动，直到它们相交\n\n\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;    if((headA==NULL)||(headB==NULL))        return NULL;    int countA=1;    int countB=1;    struct ListNode *HA=headA;    struct ListNode *HB=headB;    while(HA&amp;&amp;HA-&gt;next)    &#123;        countA++;        HA=HA-&gt;next;    &#125;    while(HB&amp;&amp;HB-&gt;next)    &#123;        countB++;        HB=HB-&gt;next;    &#125;    if(HB!=HA)// 结尾不相等，说明不相交        return NULL;    int num=abs(countA-countB);    struct ListNode* fast=NULL;    struct ListNode* slow=NULL;    if(countA&gt;countB)    &#123;        fast=headA;        slow=headB;    &#125;    else    &#123;        fast=headB;        slow=headA;    &#125;    while(num--)//fast 先走    &#123;        fast=fast-&gt;next;    &#125;    while(fast&amp;&amp;slow)    &#123;        if(fast==slow)            return fast;        fast=fast-&gt;next;        slow=slow-&gt;next;    &#125;    return NULL;&#125;\n\n\n\n第八题：141. 环形链表\nleetcode：141. 环形链表\n\n\n本题只需要我们判断该链表是否有环，我们同样使用快慢指针，快指针的速度是慢指针的两倍，进环以后，快指针能追上后来的慢指针，即该链表带环。\n\n如果快指针遇到了 NULL，即该链表不带环\n\n题目需要返回 bool 类型，前面已经提到过了~\n\nbool hasCycle(struct ListNode *head) &#123;    if(head==NULL)        return false;        struct ListNode * slow=head;    struct ListNode * fast=head;    struct ListNode * meet=NULL;    while(fast &amp;&amp; fast-&gt;next)    &#123;        fast=fast-&gt;next-&gt;next;        slow=slow-&gt;next;        if(fast==slow)        &#123;            return true;        &#125;    &#125;    return false;    &#125;\n\n\n特殊情况：追不上\n这里有一个附加的思考问题：fast 指针比 slow 走得快，它们就一定能追上吗？\n\n\n第九题：142. 环形链表Ⅱ（较难😰）\nleetcode：142. 环形链表 II\n\n这道题比上一道多了一个要求，需要我们返回链表环形的开始节点\n\n示例 1 里的开始节点为 2（下标为 1）\n示例 2 里的开始节点为 1（下标为 0）\n\n\n\n题目分析  这时候，单纯用快慢指针已经不行了，我们还需要想办法找到环的起始节点\n\n标出长度，直线部分为 L，我们并不知道 meet 究竟在环的哪一个部分 ，设环的 起点 b 到 meet的长度为 X（这里要注意先后顺序，避免搞混，见下图）\n\n假设有两个指针，一个 head 从链表的  开头 a开始走，一个从 meet 开始走，最终它们一定会在 b 点相交！\n\n从 meet 开始走的指针 meet，在环里走N*C-X 的长度来到 b（这里的 N 指的是在环中走的圈数，是个未知数）\n从链表开头 a 开始走的指针 head，走L 长度来到 b；\nmeet 和 head 每次都走一步（步长相同）；\n\n在上一道链表有环相交的题目中：\n\nfast 指针走了 L+N*C+X 的距离；\nslow 指针走了L+X；\n慢指针是不可能在环中走超过一圈的，因为快慢指针每次的步长为 1，是不可能错过的；\nfast 指针走的距离是 slow 的两倍，即 L+N*C+X = 2(L+X)；\n\n这时候就能根据上方公司得出一个结论：L = N*C - X；\n分解一下这个表达式，L=(N-1)*C + (C-X)，你会发现，C-X不就是 meet 到 b 点（相遇点）的距离吗？\n转换为文字说明，即 meet 指针走C-X 的长度来到 b 点，再走 N-1 圈就会与 head 相遇！\n敲代码  分析到这里，我们就可以开始敲代码了~\nstruct ListNode *detectCycle(struct ListNode *head) &#123;    if (head == NULL)        return NULL;    struct ListNode* slow = head;    struct ListNode* fast = head;    struct ListNode* meet = NULL;    while (fast &amp;&amp; fast-&gt;next)    &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        if (fast == slow)        &#123;            meet=fast;// 寻找相交点            break;        &#125;    &#125;    if((fast==NULL)|| (fast-&gt;next==NULL))        return NULL;// 如果 fast 是遇到空退出循环的，说明不带环    while(1)    &#123;        if(head==meet)// 相遇点即为环的起点             return meet;                meet=meet-&gt;next;        head=head-&gt;next;    &#125;    return NULL;&#125;\n\n\n第十题：138. 复制带随机指针的链表（很难😱）\nLeetCode：138. 复制带随机指针的链表\n\n众所周知，当 leetcode 给一道题标出 “中等” 的时候，我这种菜🐕就要写 N 久，所以对于我来说，简单 &#x3D; 有难度，中等 &#x3D; 非常难。\n本题较难的地方不在于复制链表，而在于处理新链表的 random 指针\n\n解法一：用计数器找到对应位置\n这个方法的缺点是，每一个节点都需要两次遍历，第一次计数，第二次是在新的链表中查找，时间复杂度是 O(N^2^)\n不过本题并没有对时间复杂度做出要求，所以这个方法肯定也是没问题的！\n\n重点来瞅瞅这个非常  女少  的解法二\n 解法二：先复制后断开 (๑•̀ㅂ•́)و✧ 这个解法的思路是，先在原链表的每一个节点之后插入一个和它相同的新节点\n\n再利用两个指针进行 random 的查找\n\n第一个 7 的 random 是空，我们直接给新的 7random 置空\n第二个 13 的 random 指向前一位 7，新 13 的 random 指向  原 13random 的下一位，即新开辟的 7\n第三个 11 的 random 指向 1，新 11 的 random 指向原链表 1 的下一位，即新的 1\n\n这样一一对应，就能在新开辟的链表中找到对应的 random！\n\n最后，我们需要做的，就是将新开辟的节点从原链表断开，重新链接成新的链表\n怎么样，是不是直接一个“妙”就跑出来了？\n\n\n本题并没有要求不改变原链表，但我们最好还是  把原链表还原成初始状态\n\n直接上手敲代码，啪啪啪，一提交，执行出错！\n\n\n仔细找了找，发现是第三个板块最后处理末尾的 NULL 指针时会出现问题\n\n最后的代码如下！\nstruct Node* copyRandomList(struct Node* head) &#123;\tif(head==NULL)        return NULL;    //1. 复制原链表    struct Node*HAED=head;// 记录头节点    while(head)// 将新链表的每个节点链接在原链表之后    &#123;        struct Node* newnode=(struct Node*)malloc(sizeof(struct Node));        newnode-&gt;val=head-&gt;val;        newnode-&gt;next=head-&gt;next;        head-&gt;next=newnode;        head=head-&gt;next-&gt;next;    &#125;    //2. 链接新链表的 random    struct Node* old=HAED;    while(old)    &#123;        struct Node* new=old-&gt;next;        if(old-&gt;random==NULL)            new-&gt;random=NULL;        else            new-&gt;random=old-&gt;random-&gt;next;        old=old-&gt;next-&gt;next;    &#125;    //3. 将新链表解下来    struct Node* ret=HAED-&gt;next;// 记录最后的返回链表    struct Node* oldlist=HAED;    while(oldlist)    &#123;        struct Node*copy=oldlist-&gt;next;        struct Node*next=copy-&gt;next;                oldlist-&gt;next=next;        if(copy-&gt;next==NULL)            copy-&gt;next=NULL;        else            copy-&gt;next=next-&gt;next;        oldlist=next;    &#125;     return ret;&#125;\n\n也就执行出错了十几次就找到错误了……问题不大（阿巴阿巴）\n\n第十一题：BM12 链表排序\nBM12 链表排序\n\n给定一个节点数为 n 的无序单链表，对其按升序排序。\n数据范围：0&lt;n≤100000，保证节点权值在 [-10^9,10^9] 之内。\n要求：空间复杂度 O(N)，时间复杂度 O(NlogN)\n\n方法 1：因为允许 O(N)的时间复杂度，直接将其写入一个数组，排序后重新链接就可以了。std::sort的时间复杂度正好是 O(NlogN)，也符合要求\n方法 2：采用归并排序，不断左右切分，最小的分支是只有 2 个节点的时候，排成有序地返回；再将两个链表给连起来\n\n具体的看代码的注释吧！\n/** * struct ListNode &#123; *  int val; *  struct ListNode *next; *  ListNode(int x) : val(x), next(nullptr) &#123;&#125; * &#125;; */#include &lt;unistd.h&gt;#include &lt;vector&gt;class Solution &#123;  public:    void PrintList(ListNode* head, const string&amp; pstr) &#123;        cout &lt;&lt; pstr &lt;&lt; &quot;  &quot;;        while (head != nullptr) &#123;            cout &lt;&lt; head-&gt;val &lt;&lt; &quot; &quot;;            head = head-&gt;next;        &#125;        cout &lt;&lt; endl;    &#125;    // 无差别逆置    ListNode* reverseNode(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) &#123;            return head;        &#125;        ListNode* ans = reverseNode(head-&gt;next);        head-&gt;next-&gt;next = head;        head-&gt;next = nullptr;        return ans;    &#125;    // 递归函数    ListNode* _sortInList(ListNode* head) &#123;        // 如果只有一个值，直接返回        if (head == nullptr || head-&gt;next == nullptr) &#123;            return head;        &#125;        // 如果是两个值，那就进行排序后返回新链表的头        if (head-&gt;next-&gt;next == nullptr) &#123;            ListNode* low = head, *big = head-&gt;next;            if (head-&gt;val &gt; head-&gt;next-&gt;val) &#123;                low = head-&gt;next;                big = head;            &#125;            low-&gt;next = big;            big-&gt;next = nullptr;            return low; // 返回一个升序的链表        &#125;        // 如果是超过两个链表，那就进行找中，并将其拆分为两个链表传给自己        ListNode* slow = head, *fast = head;        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;        // 走到这里，slow 就是中间的值，将其拆分掉        ListNode* Lhead = head;        ListNode* Rhead = slow-&gt;next;        slow-&gt;next = nullptr;        // 传递给自己，继续分化        Lhead = _sortInList(Lhead);        Rhead = _sortInList(Rhead);        // PrintList(Lhead, &quot;L&quot;);        // PrintList(Rhead, &quot;R&quot;);        // 最终获取到的两个链表都是有序的，将其连起来        ListNode phead(0), *cur_next;        while (Lhead != nullptr &amp;&amp; Rhead != nullptr) &#123;            // 找出小的，头插            if (Lhead-&gt;val &lt; Rhead-&gt;val) &#123;                cur_next = Lhead-&gt;next; // 先记录下下一个值                // 头插                Lhead-&gt;next = phead.next;                phead.next = Lhead;                // 移动到原本的下一个值                Lhead = cur_next;            &#125; else &#123;                cur_next = Rhead-&gt;next;  // 先记录下下一个值                Rhead-&gt;next = phead.next;// 头插                phead.next = Rhead;                Rhead = cur_next;// 移动到原本的下一个值            &#125;        &#125;        // 如果还有剩余值，那就全部头插        ListNode* not_empty = Lhead != nullptr ? Lhead : Rhead;        while (not_empty != nullptr) &#123;            cur_next = not_empty-&gt;next;// 先记录下下一个值            not_empty-&gt;next = phead.next;// 头插            phead.next = not_empty;            not_empty = cur_next;// 移动到原本的下一个值        &#125;        // 因为是把小值头插，最终得到的是降序序列，所以需要逆序        return reverseNode(phead.next);    &#125;    class BigListnode&#123;    public:        bool operator()(ListNode*L,ListNode*R)&#123;            return L-&gt;val &gt; R-&gt;val;        &#125;    &#125;;    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *     * @param head ListNode 类 the head node     * @return ListNode 类     */    ListNode* sortInList(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) &#123;            return head;        &#125;        // return _sortInList(head); // 方法 1，递归 + 归并        // 方法 2，用 vector 排序        ListNode* cur = head;        vector&lt;ListNode*&gt; nodev;        while (cur != nullptr) &#123;            nodev.push_back(cur);            cur = cur -&gt;next;        &#125;        // 排序，写个仿函数（排降序方便头插）        sort(nodev.begin(),nodev.end(),BigListnode());        ListNode phead(0);        // 遍历一遍，重新连起来        for(auto&amp;e:nodev)&#123;            // 头插            e-&gt;next = phead.next;            phead.next = e;        &#125;        return phead.next;    &#125;&#125;;\n\n\n\n结语💪刷完这些题，有没有觉得自己对链表的理解直接更上一层楼？\n\n如果大家对某道题有问题，或者有我没有说清楚的地方，可以在评论区提出来哦！\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","OJ刷题","链表"]},{"title":"【C++】图","url":"/posts/1235355339/","content":"本文包含了  图的基本概念\n\n\n1. 相关概念 1.1 无 &#x2F; 有向 无向图：每一个顶点之间的连线没有方向\n有向图：连线有方向（类似离散数学的二元关系 &lt;A,B&gt;代表从 A 到 B 的边，有方向）\n&lt;A,B&gt; 中 A 为始点，B 为终点\n\n在无向图中，(V,U)和 (U,V) 是同一条边\n1.2 顶点和边  图中的节点叫做顶点。\n顶点之间的线条就是边，表示事物与事物之间的关系。\n\n1.3 自回路 &#x2F; 多重图\n1.4 完全图  图中每一个顶点都有连线（有最多的边数）就叫做  完全图\n设顶点为 N 个\n\n无向完全图中 n(n-1)/2 条边\n有向完全图中 n(n-1) 条边\n\n1.5 邻接与关联  无向图中 (u,v) 是一条边\n\n顶点 u 和 v 邻接\n边 (u,v) 与顶点 u 和 v 相关联\n\n1.6 子图\n图中 G3 是 G1 的子图，G4 是 G2 的子图\n简单说来，就是  子图是原图的一部分，包括顶点、边（注意方向）都是原图中的一部分\n1.6 路径  路径是顶点序列\n路径是一个节点到另外一个节点需要经过的边\n\n路径长度：路径上边的数目\n简单路径：除起点、终点可以相同外，路径中其余顶点不相同\n回路：起点和重点相同的简单路径\n\n1.7 连通图  两个顶点之间只要有路径，那就是  连通  的\n\n连通图：无向图  中任意两点之间都有路径，那么就是一个连通图\n连通分量：无向图的  极大连通子图\n\n\n注意，虽然连通分量被称为“极大连通子图”，但它并不是节点最多的哪一个。比如上图中的 G2 和 G3 都是极大连通子图。\n\n\n强连通图：有向图  中，如果两个顶点之间 U 和 V 之间有 U 到 V 的路径，那就一定有从 V 到 U 的路径\n强连通分量：有向图的  极大联通子图\n\n\n强连通图 G1 的极大强连通分量就是它自己（只有非强连通图才有多个强连通分量）\n上图中 G2 就不是强联通图，因为 4 节点没有入边（也就没有节点能到 4）\n\n第三图的上半部分并非 G1 的强连通分量，但是是 G2 的强力连通分量。\n同时，单独的 4 顶点也是一个强连通分量（单独顶点都是）\n\n1.7 顶点的度  度：与该顶点相关联的边的数目\n\n入度：射入 v 的边的数目\n出度：从 v 射出去的边的数目\n\n1.8 生成树  生成树包含  图中的  所有顶点，但是只有足够构成一颗树的 n-1 条边\n\n因为 n-1 条边再加上一条就会构成回路\n生成树中不包含回路\n\n1.9 网  给图中的每条边都添加上  权值，带权的图称为网\n2. 表示法 2.1 邻接矩阵 用二维数组来表示每个顶点之间的关系（矩阵）\n\n优缺点  优点\n\n便于判断两个顶点之间是否有边，可以直接根据下标判断，O(1)\n便于计算各个顶点的度\n无向图：第 i 行元素之和就是顶点 i 的度（前提是用 1 来表示）\n有向图：第 i 行元素之和为顶点 i 的出度；第 i 列为入度\n\n\n\n缺点\n\n如果节点多，边少，就会出现空间浪费\n无法方便地找到一个顶点和那一条边相连（需要遍历）\n对于无向图，也会出现空间浪费\n\n2.2 邻接表  邻接表有些类似于哈希表的拉链法。每一个节点后面跟着一个单链表，用于存储与这个节点相连的节点。\n在 G2 的有向图中，一般存储的是  出度表，即从该节点出发的边。如果边有权值，则还需要存储权值\n\n优缺点  优点：\n\n可以快速找到一个节点和谁相连（出度）\n\n缺点\n\n不便于判断两个顶点之间是否有边\n不便于计算有向图各个顶点的度（需要遍历所有节点）\n\n关于第二个缺点，可以新增一个入度表（即一个出度表 &#x2F; 一个入读表）来计算。但是这样会增加时空复杂度。\n3. 遍历 3.1 深度优先 DFS 深度优先以递归为基本思路，从一个结点开始，递归向后遍历这个节点的单链表中的节点。\n\n为了避免同一个节点遍历多次，我们需要有一个 bool 数组来标识一个节点是否遍历过。如果遍历过，则把对应下标的值设定为 true 来标识\n由于深度优先的  递归部分  只能遍历  连通图 。若出现了上图中非联通的情况，需要我们在外循环中重新遍历一下bool 标识数组，确认所有节点都遍历完成。\n如果漏了节点（就是没有和其他节点联通的独立节点）那么就以此节点开头再进行一次深度遍历。\n\n3.2 广度优先 BFS\n广度优先遍历类似二叉树的层序遍历，依靠  循环 + 队列  来完成遍历\n\n入起始节点，打印起始节点的值\n出队头节点（第一次的时候是起始节点）往队列中入该节点单链表中的所有节点\n依此类推，出一个节点，就入这个节点单链表中的所有节点\n同样地用一个 bool 数组标识节点是否被访问。如果被访问了则跳过该节点\n也需要在队列循环结束后遍历一遍 bool 数组，确认所有节点都访问完毕。\n\n\n3.3 判断一个图是否连通  使用任何遍历方式，遍历完毕后检查 bool 数组\n若有节点没有被访问，则说明是非连通图\n4. 拓扑排序\nhttps://blog.musnow.top/posts/1720780208/\n\n给定一个图，每次都选择一个  无入度（没有入边）的节点加入序列中，并删除该节点的出边\n最终得到的序列就是一个拓扑排序之后的序列\n\n每次删除出边后，都可能形成  新的无入度  的节点\n\n因此，针对同一棵树的拓扑排序序列，可能有多种不同的情况\n5. 最小生成树算法  生成树的概念参考 1.8 生成树 ，最小生成树即让生成树中所有边的 权值加起来最小\n5.1 普里姆 Prim\n如图中所示，我们先根据这个树的结构构造三个数组\n\nnearest 代表和这个节点最近的节点（默认为 -1）\nlowcost 代表和这个节点最近节点的权值（默认为无穷大）\nmark 是一个 bool 数组，标识该节点是否已经加入到最小生成树\n\n当我们每从图中取出一个节点的时候，就需要更新这三个表\n如图，当我们取走 0 之后，就需要更新和 0 连通的三个节点，其中 nearest 代表刚刚删除掉的节点 0，lowcost 代表它们和 0 相连边的权值；同时要把 mark 中 0 改为 true，表明 0 已经加入生成树了\n\n第二次选取的时候，遍历 lowcost 表，找到权值最小的边为 (0,2) 权值为 1。此时就把 2 加入进去，并更新与 2 相连的节点 3（注，必须要权值更小才需要更新）\n\n依次遍历，直到所有节点都加入了最小生成树（左下角的图）\n\n该算法的时间复杂度为O(N^2)，只与节点的数量 N 有关\n5.2 克鲁斯卡尔 Kruskal\n构建一个和原图一样的节点图（无边）在原图中查找权值最小的边，判断其节点是否已经相同，如果没有形成环，则加入到最小生成树的图中\n\n判断是否成环可以通过  并查集  解决\n\n如下图，先遍历所有边，发现 (0,2) 的权值最小，判断该边加入后并不会使生成树形成环，则加入该边\n\n下图中 (0,2) 之间的边 1 已经移动到了 T 图上\n同时将 0 和 2 加入到同一个并查集的合集内\n\n\n同理继续找权值最小的边，加入到生成树中。如下，将 3 边移动到右图。\n\n此时我们遇到了 3 条权值最小的边，权值都为 5。此时可以随便加入一条边即可（不能使生成树  成环）\n如下图中 (0,3) 和(2,3)的边加入后会使图成环，不能选择该边\n\n并查集中 0、2、3、5 已经在一个  集合  中，此时判断 (0,3) 在一个集合，该边不能加入；(2,3)在一个集合中，该边不能加入\n\n\n应该选择 (1,2) 这条边，其不会让树成环\n\n此时所有边都已经连起来了，最小生成树  生成成功\n算法分析\n\n该算法的时间复杂度为O(E*logE)，其中 E 为边的数目\n6. 最短路径  带权有向图中，把一条路径（仅考虑简单路径）上所经边的权值之和定义为该路径的路径长度\n从源点到终点可能不止一条路径，把路径长度最短的那条路径称为  最短路径\n6.1 单源最短路径  思路有些类似  并查集，path 数组中存放的是每一个节点的上一条路径，若下标 1 处存放 0，则代表是从 0 走到 1。同时 d 数组中标识从 0 走到下标 1 的长度。\n\n把 1 加到 s 序列之后，发现 0 到节点 2 的路径长度缩短了，从原本的 (0,2) 的 6 变成了现在 (0,1)+(1,2) 的4+1=5，长度缩短，对应 d 数组中下标 2 处也需要更新\n继续下去，直到 U 数组中没有节点，S 数组中节点满，即可获得一个从 0 出发到任何节点的  单源最短路径\n\n6.1.1 狄克斯特拉算法 Dijkstra求解单源最短路径问题的算法\n前提：给定一个带权有向图 G 和源点 v，限定各边上的权值大于等于 0\n基于定理：最短路径上的顶点的最短路径就是该路径\n\n理解：现有一条 v 到 u 的最短路径 v-&gt;……-&gt;a-&gt;u，那么 v 到 a 的最短路径即为 v-&gt;……-&gt;a\n\n算法思路  把图 G 中的顶点集合 V 分成两部分：\n第一部分，为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，以后每求得一条最短路径 v，……，u，就将 u 加入到集合 S 中，直到全部顶点都加入到 S 中，算法结束）\n第二部分，为其余未求出最短路径的顶点集合（用 U 表示）\n过程：\n\n初始化：S 只包含源点即 S&#x3D;{v}，v 的最短路径为 0。U 包含除 v 以外的其他顶点，U 中顶点 i 距离为边上的权值（若 v 与 i 直接相连）或∞（v 与 i 不是直接相连）\n\n\n\n从 U 中选取一个距离 v 最小的顶点 u，把 u 加入 S 中（该选定的距离就是 v 到 u 的最短路径长度）\n\n\n\n\n以 u 为新考虑的中间点，修改 U 中各顶点 i 的最短路径长度\n\n\n若从源点 v 到顶点 i 的最短路径长度（经过顶点 u）比原来最短路径长度（不经过顶点 u）短，则修改顶点 i 的最短路径长度\n\n\n\n重复 2、3 步，直至所有顶点都包含在 S 中\n\n代码设计  着重解决两个问题：\n\n如何存放最短路径长度？\n\n用一维数组 d[i]存储。源点 v 默认，d[i]表示源点到顶点 i 的最短路径长度\n\n如 d[2]&#x3D;12 表示源点到顶点 2 的最短路径长度为 12\n\n\n如何存放最短路径？\n\n用一维数组 path[]存储。path 数组中所存储的数组代表当前顶点在最短路径中的前驱顶点\n\n如 path[3]&#x3D;1，表示在最短路径中，顶点 3 的前驱顶点是顶点 1\n\n算法演示\n这是初始化状态\n发现数组 d 中顶点 1 距离源点距离最近，那么就将顶点 1 加入到 S 中\n\n这时，我们需要更新剩余点的最短路径长度和最短路径\n显然，顶点 2，3，4，5，6 并不会都做更新。只有与顶点 1 直接相连的顶点才有可能会受影响。在上图中会受影响的为顶点 2 和顶点 4\n\n原本顶点 2 的最短路径长度是 6，最短路径是 &lt;0,2&gt;。现在由于顶点 1 的引入，最短路径长度变为 5，最短路径变为 &lt;0,1&gt;,&lt;1,2&gt;\n顶点 4 同理！\n至此，就完成了一次顶点的引入。下面重复上述操作至所有顶点都在 S 中即可\n下面是全过程：\n\n\n\n&#x3D;&#x3D; 总结一下：在更新 d 和 path 数组时，只有与本次引入 S 中的顶点 i 直接相连的后驱顶点才有可能发生改变，其余顶点是不可能变的 &#x3D;&#x3D;\n现在我们利用 d 和 path 数组来求解最短路径长度和最短路径：\n\n求源点 0 到终点 6 的最短路径长度\n\n即为 d[6] 的值，为 16\n\n求 0 到 6 的最短路径\n\n\n从终点往源点找\n时间复杂度  时间复杂度为 O(n2)\n","categories":["数据结构太复杂"],"tags":["数据结构","图","C++"]},{"title":"【C 语言】双向带头循环链表","url":"/posts/1493158800/","content":"[TOC]\n前言  在之前的数据结构学习中，我们学习了顺序表、链表这两种结构\n\n顺序表：博客链接 1\n单链表：博客链接 2\n链表 OJ：博客链接 3\n\n之前本来是不想写双链表的博客的，但是看着自己的数据结构专栏少了一 part，有强迫症的我感觉很不爽，于是补上了本篇大水文\n1. 双链表的结构  除了单链表以外，还有一个结构，是  双向带头循环链表。这个链表的形式如下\n\n头节点  的 prev 指向尾部节点\n尾节点的 next 指向头节点，构成循环\n\n\n别看它的形式有些复杂，实际代码的实现，比单链表还简单！\n因为 head-&gt;prev 指向了尾节点，所以不需要找尾。尾删的时候也不需要遍历找尾节点的前一位，因为尾节点的 prev 就存放了前一位的地址。\n\n2. 代码实现  下面贴出双链表实现的源码，如果大家有问题，可以在评论区提出\n只要你学会了  单链表的编写 ，也看完了我的 链表 OJ 题  博客，那双链表对于你来说肯定是信手拈来的\n\n2.1 头文件 DoubleList.h 头文件\n如果你想尝试自己编写双链表的代码，可以先把头文件复制到你的本地编译器，将这些函数的实现搞出来\n#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;// 带头 + 双向 + 循环链表增删查改实现typedef int LTDataType;typedef struct ListNode&#123;\tLTDataType data;\tstruct ListNode* next;\tstruct ListNode* prev;&#125;ListNode;// 创建并返回链表的头结点ListNode* ListCreate();// 双向链表销毁void ListDestory(ListNode* pHead);// 双向链表打印void ListPrint(ListNode* pHead);// 倒着打印，检查双链表是否完整void ListPrintReverse(ListNode* pHead);// 创建新的节点ListNode* BuyNode(LTDataType x);// 双向链表尾插void ListPushBack(ListNode* pHead, LTDataType x);// 双向链表尾删void ListPopBack(ListNode* pHead);// 双向链表头插void ListPushFront(ListNode* pHead, LTDataType x);// 双向链表头删void ListPopFront(ListNode* pHead);// 双向链表查找ListNode* ListFind(ListNode* pHead, LTDataType x);// 双向链表在 pos 的前面进行插入void ListInsert(ListNode* pos, LTDataType x);// 双向链表删除 pos 位置的节点void ListErase(ListNode* pos);\n\n2.2 源文件 DoubleList.c 源文件\n还是建议你写完之后再来和我的函数对比对比。\n一定要记住：写完一个模块，测试一个模块，不要等到最后再测试！\n#define _CRT_SECURE_NO_WARNINGS 1#include &quot;DoubleList.h&quot;ListNode* ListCreate()&#123;\tListNode* Createnode = (ListNode*)malloc(sizeof(ListNode));\tif (Createnode == NULL)\t\tprintf(&quot;CreateNode failed\\n&quot;);\telse\t&#123;\t\tCreatenode-&gt;next = Createnode;\t\tCreatenode-&gt;prev = Createnode;\t&#125;\treturn Createnode;&#125;void ListDestory(ListNode* pHead)&#123;\tassert(pHead);\twhile (pHead-&gt;prev!=pHead)\t&#123;\t\tListNode* tail = pHead-&gt;prev;\t\tListNode* tailprev = tail-&gt;prev;\t\tfree(tail);\t\tpHead-&gt;prev = tailprev;\t&#125;\tfree(pHead);&#125;void ListPrint(ListNode* pHead)&#123;\tassert(pHead);\t\tListNode* cur = pHead-&gt;next;\twhile (cur-&gt;next!=pHead)\t&#123;\t\tprintf(&quot;%d -&gt; &quot;,cur-&gt;data);\t\tcur = cur-&gt;next;\t&#125;\tprintf(&quot;%d&quot;, cur-&gt;data);// 打印最后一个节点\tprintf(&quot;\\n&quot;);&#125;void ListPrintReverse(ListNode* pHead)&#123;\tassert(pHead);\tListNode* tail = pHead-&gt;prev;\twhile (tail-&gt;prev != pHead)\t&#123;\t\tprintf(&quot;%d -&gt; &quot;, tail-&gt;data);\t\ttail = tail-&gt;prev;\t&#125;\tprintf(&quot;%d&quot;, tail-&gt;data);\tprintf(&quot;\\n\\n&quot;);\t&#125;ListNode* BuyNode(LTDataType x)&#123;\tListNode* Buy = (ListNode*)malloc(sizeof(ListNode));\tif (Buy == NULL)\t\tprintf(&quot;BuyNode failed\\n&quot;);\telse\t&#123;\t\tBuy-&gt;data = x;\t\tBuy-&gt;next = NULL;\t\tBuy-&gt;prev = NULL;\t&#125;\treturn Buy;&#125;void ListPushBack(ListNode* pHead, LTDataType x)&#123;\tassert(pHead);\tListNode* newnode = BuyNode(x);\tListNode* tail = pHead-&gt;prev;\ttail-&gt;next = newnode;\tnewnode-&gt;next = pHead;\tnewnode-&gt;prev = tail;\tpHead-&gt;prev = newnode;&#125;void ListPopBack(ListNode* pHead)&#123;\tassert(pHead);\tListNode* tail = pHead-&gt;prev;\tListNode* tailprev = tail-&gt;prev;\tfree(tail);\ttailprev-&gt;next = pHead;\tpHead-&gt;prev = tailprev;&#125;void ListPushFront(ListNode* pHead, LTDataType x)&#123;\tassert(pHead);\tListNode* newnode= BuyNode(x);\tnewnode-&gt;prev = pHead;\tnewnode-&gt;next = pHead-&gt;next;\tpHead-&gt;next = newnode;\tnewnode-&gt;next-&gt;prev = newnode;&#125;void ListPopFront(ListNode* pHead)&#123;\tassert(pHead);\tListNode* front = pHead-&gt;next-&gt;next;\tListNode* Popnode = pHead-&gt;next;// 待爆破的头节点\tpHead-&gt;next = front;\tfree(Popnode);\tfront-&gt;prev = pHead;&#125;ListNode* ListFind(ListNode* pHead, LTDataType x)&#123;\tassert(pHead);\tListNode* cur = pHead-&gt;next;\twhile (cur!=pHead)\t&#123;\t\tif (cur-&gt;data == x)\t\t\treturn cur;\t\telse\t\t\tcur = cur-&gt;next;\t&#125;\treturn NULL;&#125;void ListInsert(ListNode* pos, LTDataType x)&#123;\tassert(pos);\tListNode* newnode = BuyNode(x);\tListNode* Prev = pos-&gt;prev;\tPrev-&gt;next = newnode;\tnewnode-&gt;prev = Prev;\tnewnode-&gt;next = pos;\tpos-&gt;prev = newnode;&#125;void ListErase(ListNode* pos)&#123;\tassert(pos);\tListNode* Prev = pos-&gt;prev;\tListNode* Next = pos-&gt;next;\tPrev-&gt;next = pos-&gt;next;\tNext-&gt;prev = Prev;\tfree(pos);&#125;\n\n测试文件 test.c 这里不再给出\n结语  如果你对上面的代码有问题，欢迎在评论区提出！\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n一起向前！\n\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","链表"]},{"title":"【C 语言】什么是树，二叉树又是啥玩意","url":"/posts/4161984418/","content":"[TOC]\n前言  在之前的数据结构学习中，我们学习了  顺序表、链表、栈、队列  这几种结构\n它们都是用  链表或者数组  的方式来实现的，主要考察我们对  结构体  的运用\n\n今天让我们来学习一个新的数据结构，也就是下面这副图里面的  树\n\n啊不好意思，图拿错了！😜\n是下面这个才对\n\n\n1. 什么是树？1.1 树的概念  树是一种非线性的数据结构，它是由 n 个有限节点组成的具有一定层次关系的集合。\n把它叫做树是因为它看起来的确像  一个树的根部\n当然也可以理解为是  树干在上，树叶在下的结构\n\n有一个特殊的节点，被称为  根节点，也就是树的开头\n除了根节点外，其余节点都是, 个互不相交的集合。每一个集合都是一颗与树的结构类似的子树\n每一个节点只能有一个前驱，但是可以有很多个后驱\n因此，树是  递归定义的\n\n\n树中的子节点不能有交集\n\n上图中的 B 节点不能有 G 这个孩子，因为 G 已经有父母 C 了\n同理，G 节点也不能同时拥有  两对父母\n子节点之间也不能相连，如 E 和 F 不能相连\n\n\n1.2 树的相关知识点\n节点的度：一个节点含有的子树的个数称为该节点的度； 如下图：A 的度为 6\n\n叶节点或终端节点：度为 0 的节点称为叶节点； 图中 B、C、H、I…等节点为叶节点\n非终端节点或分支节点：度不为 0 的节点； 如上图中 D、E、F、G…等节点为分支节点\n简单的说，就是有娃的节点就是分支节点\n\n双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图，D 是 H 的父节点\n孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：H 是 D 的孩子节点\n\n兄弟节点：具有相同父节点的节点互称为兄弟节点； 如下图：P、Q 是兄弟节点\n\n\n树的度 ：一棵树中， 最大的节点的度称为树的度； 示例中树的度为 6（即 A 的度）\n节点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推\n树的高度或深度：树中节点的最大层次； 示例中树的高度为 4\n\n堂兄弟节点：双亲在同一层的节点互为堂兄弟；如下图：H、I 互为兄弟节点\n\n\n节点的祖先：从根到该节点所经分支上的所有节点；示例中A 是所有节点的祖先\n子孙 ：以某节点为根的子树中任一节点都称为该节点的子孙。示例中 所有节点都是 A 的子孙\n\n森林：由 m（m&gt;0）棵互不相交的树的集合称为森林\n多个不相交的树就是森林\n\n\n\n1.3 树的代码表示  表示树的方式有很多种，比如下面这种\n#define N 5 // 指定树的度为 5struct TreeNode{\tint data;\tstruct TreeNode* subs[N];// 用指针数组存放孩子节点的指针};\n\n但这种方法不够优，给大家展示一个用的最广泛的方法——孩子兄弟表示法\ntypedef int DataType;struct Node{ struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域};\n\n通过这种方法，父亲节点只需要保存它的第一个娃，其他娃就让大娃的兄弟节点来找\n也就是  家长只用管老大，老大管老二，老二管老三，依次往下……\n\n实际写代码的结构大概是下图这样\n\n2. 二叉树  在实际中，二叉树是使用较多的一种树的结构\n2.1 概念  二叉树是  度为 2的树，它是一个特殊的树\n\n二叉树不存在度大于 2 的节点\n二叉树是有序树，它的娃（子树）有左右之分，次序不能颠倒\n\n\n所以，二叉树都是由下面各类节点组成的树\n\n2.2 特殊的二叉树  满二叉树是一个特殊的完全二叉树\n\n满二叉树，每一层都是满的\n完全二叉树，最后一层必须从左到右连续\n\n满二叉树  满二叉树：如果每一个层的节点数都达到最大值，那这个二叉树就是满二叉树。也就是说：满二叉树的层数为 k，且节点总数是 2k-1\n\n满二叉树的节点数是一个  等比数列公式\n\n\n完全二叉树  完全二叉树：完全二叉树是效率很高的数据结构。对于深度为 K，有 n 个节点的二叉树，当且仅当每一个节点都与深度为 K 的满二叉树中编号从 1 至 n 的节点一一对应时，称为完全二叉树。\n简单说来，完全二叉树的最后一层不一定满，但必须要  从左到右连续\n\n\n2.3 二叉树的性质\n只有一个节点的二叉树，度  为 0\n若规定根节点的层数为 1，则一棵非空二叉树的第 i 层上最多有 2^(i-1) 个结点\n若规定根节点的层数为 1，则深度为 h 的二叉树的最大结点数是(2^h)-1\n对任何一棵二叉树, 如果度为 0 其叶结点个数为 n0, 度为 2 的分支结点个数为 n2，则有n0 = n2+1\n若规定根节点的层数为 1，具有 n 个结点的满二叉树的深度，h=log2(n+1) 。 (ps： 是 log 以 2 为底，n+1 为对数)\n对于具有 n 个结点的完全二叉树，如果按照  从上至下从左至右  的数组顺序对所有节点从 0 开始编号，则对于序号为 i 的结点有：\n若 i&gt;0，i 位置节点的 双亲  序号：(i-1)/2；i=0 时为根节点编号，无双亲节点\n若 2i+1&lt;n， 左孩子序号：2i+1，2i+1&gt;=n否则无左孩子\n若 2i+2&lt;n， 右孩子序号：2i+2，2i+2&gt;=n否则无右孩子\n\n\n\n\n\n2.4 几个选择题 1. 某二叉树共有 399 个结点，其中有 199 个度为 2 的结点，则该二叉树中的叶子结点数为（ ）A 不存在这样的二叉树B 200  √C 198D 199// 叶子节点的数量 总比度为 2 的节点多 1    2. 在具有 2n 个结点的完全二叉树中，叶子结点个数为（ ）A n    √B n+1C n-1D n/2//N0+N1+N2=2n//2N0+N1-1=2n//N1 只有 0 和 1 两种可能，因为 n 为整数，2n 为偶数，所以 2N0=2n，N0=n    3.一棵完全二叉树的节点数位为 531 个，那么这棵树的高度为（ ）A 11B 10  √C 8D 12// 假设高度是 h// 完全二叉树节点最多 2^h -1//             最少 2^(h-1)-1 +1// 可以通过这两个公式，推断出 h=104.一颗完全二叉树第六层的叶子节点为9，那么这棵树的节点数最多为（）A 108B 109 √C 112D 119//1  //2  //4  //8  //16  //32  //64 - 9*2// 因为题目中的是第六层的叶子节点，完全二叉树必须从左到右连续，所以说明第六层不只 9 个节点（那样算出来的结果不对）// 所以是第六层已经满了，第七层没有满// 把第七层去掉 9 个叶子节点的孩子就能算出最多的节点数\n\n3. 二叉树的存储结构  二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构\n3.1 顺序存储  顺序结构存储就是使用  数组  来存储\n一般使用数组只适合表示  完全二叉树，因为不是完全二叉树会有空间的浪费。\n\n现实使用中只有  堆才会使用数组来存储\n下一篇博客会带大家认识  堆这个特殊的树形结构（和内存里面那个堆😂没啥关系哈）\n\n\n\n看到这张图，你肯定想问，如果用数组结构存储，那还怎么还原出一颗树🎄呢？\n这里我们需要理解  物理存储  和逻辑结构  的关系\n\n二叉树顺序存储在  物理上是一个数组，在逻辑上是一颗二叉树\n那怎么计算这种情况下的父亲和娃呢？\nleftchild  = parent*2+1rightchild = parent*2+2parent     = (child-1)/2\n\n\n怎么样，是不是忽然感觉\n\n3.2 链式存储  这就就没啥好说的啦，使用一个简单的  二叉链  就能构成二叉树\ntypedef int BTDataType;// 二叉链struct BinaryTreeNode{ \tstruct BinTreeNode* _pLeft; // 指向当前节点左孩子 \tstruct BinTreeNode* _pRight; // 指向当前节点右孩子 \tBTDataType _data; // 当前节点的值}\n\n\n4. 树转换为二叉树 4.1 说明 有的时候，我们需要将一个  没有规律  的多叉树转换为二叉树。\n\n我们电脑磁盘的文件夹层级就是一个没有规律的树\n\n不说废话，直接来看栗子；下图就是一个没有啥规律可言的树，我们要做的，就是想办法把它变成一个二叉树！\n\n当然，如果以写代码的思考角度，在不要求顺序的前提下，我们可以直接遍历这棵树的所有节点，将其存入数组，再用二叉树的方式连接起来（或者直接节点数组当作  顺序存储  的二叉树）\n但是，以  应试  的角度，只能依照一个特定的方法，将其转成二叉树\n4.2 步骤\n连线：将树中具有兄弟关系的结点从左到右依次连线；\n去线：对于树中的每个结点，仅保留与其最左 (即第一个) 孩子的连线，去掉该结点到其余孩 子的所有连线；\n保留：如果当前节点已经是兄弟中的  最左节点（比如上图中的 B 和 E），则保留其与父节点的连线\n整形：调整为标准形状的二叉树（根结点 + 左子树 + 右叉树）\n\n依照上面的步骤，我们最终处理出的二叉树是下面的模样\n\n这里还有第二个栗子\n\n怎样，你学费了吗？\n5. 二叉树转成树或者森林  转换步骤是树转换为二叉树方法的逆过程，具体如下：\n\n整形：将二叉树中的所有结点的左孩子连线调整为垂直形态、右孩子连线调整为水平形态； \n连线：对于任一水平线上的结点，将该水平线上的第一个结点的父节点，与该水平线上的其他结点进 行连线； \n去线：去除所有的水平连线，即删除原二叉树中各结点与其右孩子的连线； 4\n整形：调整步骤 3 结束之后的树的形状，使其符合树的一般特征要求（父子、兄弟关系清晰）\n\n\n以下是俩示例\n\n\n结语  嘿嘿嘿，本篇博客到这里就结束啦！\n下篇博客将带来  堆的详解\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","树"]},{"title":"【C 语言】数据结构 - 栈（详解）","url":"/posts/3359083806/","content":"[TOC]\n前言  在之前的数据结构学习中，我们学习了顺序表、链表这两种结构\n\n顺序表：博客链接 1\n单链表：博客链接 2\n链表 OJ：博客链接 3\n\n除了单链表以外，还有一个结构，是  双向带头循环链表。这个链表的形式如下\n\n头节点  的 prev 指向尾部节点\n尾节点的 next 指向头节点，构成循环\n\n\n别看它的形式有些复杂，实际代码的实现，比单链表还简单！\n因为 head-&gt;prev 指向了尾节点，所以不需要找尾。尾删的时候也不需要遍历找尾节点的前一位，因为尾节点的 prev 就存放了前一位的地址。\n所以这里就偷懒不写博客了！反正也没啥人看😭\n\n好吧，最后我还是写了一篇水文👉点我\n\n\n本篇博客讲述的是另外一个特别的线性表，栈\n1. 什么是栈  数据结构里的栈，和函数栈帧中的“栈”有一定相似，但实际上它们完全不同\n栈作为一个特殊的线性表，它只允许在  表的一头  添加、删除数据。\n所有的数据都遵循  先进后出，后进先出  的原则\n\n压栈：栈的插入操作叫做进栈 &#x2F; 压栈 &#x2F; 入栈，新的数据存放在栈顶\n出栈：栈的删除操作，先删除栈顶的数据\n\n\n2. 栈的实现  栈可以用数组或者链表来实现，相对而言，数组的方法更优\n因为数组在尾插数据的时候，可以很方便的找到尾。而单链表需要遍历找尾，耗时较长。\n\n是不是有些似曾相识呢？没错，实际上栈区就是一个只能  尾插 + 尾删的顺序表\n3. 敲代码！3.1 头文件  先用头文件写好咱们的大纲，然后在来一一实现这些代码\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;stdbool.h&gt;// 支持动态增长的栈typedef int STDataType;typedef struct Stack&#123;\tSTDataType* a;\tint top; // 栈顶\tint capacity; // 容量&#125;Stack;// 初始化栈void StackInit(Stack* ps);// 销毁栈void StackDestroy(Stack* ps);// 入栈void StackPush(Stack* ps, STDataType data);// 出栈void StackPop(Stack* ps);// 获取栈顶元素STDataType StackTop(Stack* ps);// 获取栈中有效元素个数int StackSize(Stack* ps);// 检测栈是否为空，如果为空返回 false，如果不为空返回 truebool StackEmpty(Stack* ps);// 打印void StackPrint(Stack* ps);\n\n和顺序表不同的是，我们需要写一个单独的函数来  获取栈顶元素，这一点在很多 OJ 题目中都需要用到。\n3.2 函数实现  如果你看过了我之前顺序表的博客，这部分对你来说想必不难。\n\n如果有什么问题，欢迎在评论区提出！\n\n#include&quot;Stack.h&quot;// 初始化void StackInit(Stack* ps)&#123;\tSTDataType* new = (STDataType*)malloc(4*sizeof(STDataType) );\tif (new == NULL)\t\texit(-1);\telse\t&#123;\t\tps-&gt;a = new;\t\tps-&gt;top = 0;\t\tps-&gt;capacity = 4;\t&#125;&#125;// 销毁栈void StackDestroy(Stack* ps)&#123;\tassert(ps);\tfree(ps-&gt;a);\tps-&gt;a = NULL;\tps-&gt;capacity = 0;\tps-&gt;top = 0;&#125;// 入栈void StackPush(Stack* ps, STDataType data)&#123;\tassert(ps);\tif (ps-&gt;top == ps-&gt;capacity)// 容量检查\t&#123;\t\tSTDataType* new = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * (ps-&gt;capacity) * 2);\t\tif (new == NULL)\t\t&#123;\t\t\texit(-1);\t\t&#125;\t\telse\t\t&#123;\t\t\tps-&gt;a = new;\t\t\tps-&gt;capacity *= 2;\t\t&#125;\t&#125;\tps-&gt;a[ps-&gt;top] = data;\tps-&gt;top++;&#125;// 出栈void StackPop(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top &gt; 0)\t\t(ps-&gt;top)--;&#125;// 获取栈顶元素STDataType StackTop(Stack* ps)&#123;\tassert(ps);\tassert(ps-&gt;top &gt; 0);\treturn ps-&gt;a[ps-&gt;top - 1];&#125;// 获取栈中有效元素个数int StackSize(Stack* ps)&#123;\tassert(ps);\treturn ps-&gt;top;&#125;// 检测栈是否为空，如果为空返回 true，如果不为空返回 falsebool StackEmpty(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top == 0)\t\treturn true;\telse\t\treturn false;&#125;void StackPrint(Stack* ps)&#123;\tassert(ps);\tint n = ps-&gt;top;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tprintf(&quot;%d &quot;, ps-&gt;a[i]);\t&#125;\tprintf(&quot;\\n&quot;);&#125;\n\n大家在自己编写这种带多个板块的代码的时候，一定要一个板块写完就检查一遍！不要将问题都丢一块解决，那样会非常难受的！\n\n在其他版块都确认无误之后，也要过来瞅一眼 Destroy 板块，避免出现 free 错误等情况。\n这个板块我们可以通过打断点（VS 快捷键 F9）并调试的方法来检查该板块是否正确\n\n4. 知识巩固，来道 OJ！leetcode 20 有效的括号\nleetcode：20. 有效的括号\n\n\n这道题就是一道非常使用用栈来解决的 OJ 题\n题目要求我们判断给出的字符串中，括号是否一一对应\n&#123;[]&#125;// 对应&#123;[(])&#125;// 不对应&#123;&#123;()&#125;// 少了一个右边括号，不对应\n\n具体要怎么做呢？思路如下：\n\n用一个指针来遍历字符串，如果是左括号 &#123;([ 其中一个，就入栈\n如果是右边括号，说明左括号已经入栈完毕，开始比对\n栈顶的括号一定是和当前右括号匹配的，如果不是则为 false\n每判断一次，就让栈顶的左括号出栈一次\n\n最后的函数实现如下\n\n需要注意的是，STDataType 类型  需要更改为 char 类型，此时存放的是括号字符，并不是数字\n\ntypedef char STDataType;typedef struct Stack&#123;\tSTDataType* a;\tint top; // 栈顶\tint capacity; // 容量&#125;Stack;// 初始化void StackInit(Stack* ps)&#123;\tSTDataType* new = (STDataType*)malloc(sizeof(STDataType) * 4);\tif (new == NULL)\t&#123;\t\texit(-1);\t&#125;\telse\t&#123;\t\tps-&gt;a = new;\t\tps-&gt;top = 0;\t\tps-&gt;capacity = 4;\t&#125;&#125;// 销毁栈void StackDestroy(Stack* ps)&#123;\tassert(ps);\tfree(ps-&gt;a);\tps-&gt;a = NULL;\tps-&gt;capacity = 0;\tps-&gt;top = 0;&#125;// 入栈void StackPush(Stack* ps, STDataType data)&#123;\tassert(ps);\tif (ps-&gt;top == ps-&gt;capacity)\t&#123;\t\tSTDataType* new = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * (ps-&gt;capacity) * 2);\t\tif (new == NULL)\t\t&#123;\t\t\texit(-1);\t\t&#125;\t\telse\t\t&#123;\t\t\tps-&gt;a = new;\t\t\tps-&gt;capacity *= 2;\t\t&#125;\t&#125;\tps-&gt;a[ps-&gt;top] = data;\tps-&gt;top++;&#125;// 出栈void StackPop(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top &gt; 0)\t\t(ps-&gt;top)--;&#125;// 获取栈顶元素STDataType StackTop(Stack* ps)&#123;\tassert(ps);\tassert(ps-&gt;top &gt; 0);\treturn ps-&gt;a[ps-&gt;top - 1];&#125;// 检测栈是否为空，如果为空返回 true，如果不为空返回 falsebool StackEmpty(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top == 0)\t\treturn true;\telse\t\treturn false;&#125;bool isValid(char * s)&#123;    Stack st;    StackInit(&amp;st);    while(*s)    &#123;        if(*s==&#x27;&#123;&#x27;||*s==&#x27;[&#x27;||*s==&#x27;(&#x27;)        &#123;            StackPush(&amp;st,*s);            s++;        &#125;        else        &#123;            if(StackEmpty(&amp;st))            &#123;                return false;            &#125;            char top=StackTop(&amp;st);// 取栈顶元素            StackPop(&amp;st);// 把栈顶删除            // 如(&#123; 这两个，取了栈顶 &#123;，就立马 pop 掉它            if((*s==&#x27;&#125;&#x27;&amp;&amp;top==&#x27;&#123;&#x27;)            ||(*s==&#x27;)&#x27;&amp;&amp;top==&#x27;(&#x27;)            ||(*s==&#x27;]&#x27;&amp;&amp;top==&#x27;[&#x27;))            &#123;                s++;            &#125;            else            &#123;                StackDestroy(&amp;st);                return false;            &#125;        &#125;    &#125;    bool ret=StackEmpty(&amp;st);    // 如果为空，说明匹配完毕；非空说明还有剩下的左括号    StackDestroy(&amp;st);        return ret;&#125;\n\n这个算法的用时还是非常短的！\n\n结语  数据结构学到这里，其实在了解完这些结构的真正思路后，代码的实现反而并不是那么重要。\n在学习这部分知识的时候，一定要多画图！\n如果你不适应用鼠标画图，可以直接用纸笔画，一些非常简单的草图，也能极大帮助我们理解当前的代码，找出问题👍\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","栈"]},{"title":"【C 语言】三道例题让你彻底学会栈和队列","url":"/posts/909011629/","content":"[TOC]\n前言  本篇博客，将带着大家刷 3 道非常经典的 OJ 题。它们并不算特别难，但对我们理解数据结构中  栈和队列  的概念有很大的帮助。\n\n如果你还不了解  栈，可以  看看我之前  的博客👉点我\n队列  的博客就不写啦，本篇刷题的时候会提到队列的操作\n\n话不多说，直接开始吧！\n\n1. 用队列实现栈\nleetcode：225. 用队列实现栈\n\n\n这道题的要求很简单，用两个队列来模拟栈的实现。\n我们知道，队列的操作是  从后进，从前出，这就和我们在餐厅排队一样，先进入餐厅排队的人先得到座位。\n而栈是遵循  上进上出  的，即栈只能在栈顶插入元素和删除元素\n两个队列要如何结合，才能实现栈的要求呢？\n1.1 思路  首先我们讲数据 push 到其中一个队列中\n\n如果要访问此时的  栈顶 ，使用队列中的 tail 尾指针来访问，即题目要求的TOP 函数\n当我们需要 pop 数据的时候，将队列中的 N-1 个数据全部移动到另外一个队列里，再将最后的栈顶  数据删除并返回\n\n最终的目的就是保证一个队列为空，另外一个队列保存数据\n\n\n这样就达成了栈只能在栈顶删除数据的要求\n最后还有一个函数是boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n当两个队列中都没有数据的时候，这个模拟的栈就是空的；\n只要其中一个队列有数据的时候，就代表这个栈是有数据的。\n\n1.2 队列的代码  你可能会注意到，这道题中并没有给我们初始的队列代码，也就是说我们需要“造轮子”，将自己写的 C 语言队列代码放在前头\n\n这也是 C 语言在写一些 OJ 题目时不方便的原因\n\n\n这里我贴出一个队列的代码，大家可以复制到自己的编译器上测试一下。\n如果有不理解的地方，可以在评论区提出！\n\n和栈的代码实现不同，队列使用链表的方式更加方便。其相当于一个只能尾插和头删的单链表\n为了方便我们找尾进行尾插，这里定义了另外一个结构体类型Queue，其中 tail 指针指向链表的尾部，方便尾插（否则每次尾插都需要遍历）\n\ntypedef int QDataType;typedef struct QueueNode{\tQDataType data;\tstruct QueueNode* next;}QNode;typedef struct Queue{// 这个结构体里有两个指针\tQNode* head;// 头\tQNode* tail;// 尾}Queue;// 初始化void QueueInit(Queue* pq){\tassert(pq);\tpq-&gt;head = NULL;\tpq-&gt;tail = NULL;}// 摧毁void QueueDestory(Queue* pq){\tassert(pq);\tQNode* findtail = pq-&gt;head;// 找尾挨个挨个 free\twhile (findtail)\t{\t\tQNode* next = findtail-&gt;next;\t\tfree(findtail);\t\tfindtail = next;\t}\tpq-&gt;head = NULL;\tpq-&gt;tail = NULL;}// 插入（尾插）void QueuePush(Queue* pq, QDataType x){\tassert(pq);\tQNode* newnode = (QNode*)malloc(sizeof(QNode));\tif (newnode == NULL)\t{\t\tprintf(\"Push err\\n\");\t\texit(-1);\t}\tnewnode-&gt;data = x;\tnewnode-&gt;next = NULL;\tif (pq-&gt;tail == NULL)\t{\t\tassert(pq-&gt;head == NULL);\t\tpq-&gt;head = pq-&gt;tail = newnode;\t}\telse\t{\t\tpq-&gt;tail-&gt;next = newnode;\t\tpq-&gt;tail = newnode;\t}\treturn;}// 删除（头删）void QueuePop(Queue* pq){\tassert(pq);\tassert(pq-&gt;head &amp;&amp; pq-&gt;tail);// 判断是否为空\tif (pq-&gt;head-&gt;next == NULL)\t{\t\tfree(pq-&gt;head);\t\tpq-&gt;head = NULL;\t\tpq-&gt;tail = NULL;\t}\telse\t{\t\tQNode* next = pq-&gt;head-&gt;next;\t\tfree(pq-&gt;head);\t\tpq-&gt;head = next;\t}}// 判断是否为空bool QueueEmpty(Queue* pq){\tassert(pq);\t// 在 C 中 bool 类型和 int 类型可以直接混用\treturn pq-&gt;head == NULL &amp;&amp; pq-&gt;tail == NULL;}// 返回它的长度size_t QueueSize(Queue* pq){\tassert(pq);\tsize_t size = 0;\tQNode* findtail = pq-&gt;head;\twhile (findtail)\t{\t\tsize++;\t\tfindtail = findtail-&gt;next;\t}\treturn size;}// 返回头QDataType QueueFront(Queue* pq){\tassert(pq);\tassert(pq-&gt;head);\treturn pq-&gt;head-&gt;data;}// 返回尾部QDataType QueueBack(Queue* pq){\tassert(pq);\tassert(pq-&gt;tail);\treturn pq-&gt;tail-&gt;data;}\n\n1.3 本题的代码  将上述的队列代码拷贝在题目所给模板之前后，我们就可以开始写这道题需要的代码实现了\n// 创建两个队列typedef struct {\tQueue q1;\tQueue q2;} MyStack;MyStack* myStackCreate() {\tMyStack* pst = (MyStack*)malloc(sizeof(MyStack));    // 因为是在函数中，所以需要使用动态内存管理\tif (pst == NULL)//malloc 可能失败\t\treturn NULL;\tQueueInit(&amp;pst-&gt;q1);// 直接调用队列的函数进行初始化\tQueueInit(&amp;pst-&gt;q2);\treturn pst;}void myStackPush(MyStack* obj, int x) {\tassert(obj);\t// 在 push 的时候，需要找到不为空的队列进行 push\tif (!QueueEmpty(&amp;obj-&gt;q1))\t{\t\tQueuePush(&amp;obj-&gt;q1, x);\t}\telse\t{\t\tQueuePush(&amp;obj-&gt;q2, x);\t}}int myStackPop(MyStack* obj) {\tassert(obj);\t// 通过判断找到为空和不为空的队列\tQueue* empty = &amp;obj-&gt;q1;\tQueue* unempty = &amp;obj-&gt;q2;\tif (!QueueEmpty(&amp;obj-&gt;q1))\t{\t\tempty = &amp;obj-&gt;q2;\t\tunempty = &amp;obj-&gt;q1;\t}\twhile (QueueSize(unempty) &gt; 1)\t{\t\tint top1 = QueueFront(unempty);\t\tQueuePush(empty, top1);\t\tQueuePop(unempty);\t}\t// 先保存 top，再进行出队列操作\tint top = QueueFront(unempty);\tQueuePop(unempty);\treturn top;// 返回报错的 top}int myStackTop(MyStack* obj) {\tassert(obj);\tif (!QueueEmpty(&amp;obj-&gt;q1))\t{\t\treturn QueueBack(&amp;obj-&gt;q1);\t}\telse\t{\t\treturn QueueBack(&amp;obj-&gt;q2);\t}}bool myStackEmpty(MyStack* obj) {\tassert(obj);\t// 只有两个队列都为空的时候，模拟的栈才是空\treturn QueueEmpty(&amp;obj-&gt;q1) &amp;&amp; QueueEmpty(&amp;obj-&gt;q2);}void myStackFree(MyStack* obj) {\tassert(obj);\tQueueDestory(&amp;obj-&gt;q1);\tQueueDestory(&amp;obj-&gt;q2);\tfree(obj);// 因为是动态内存开辟的，所以最后销毁的时候还需要销毁模拟栈的结构体\treturn;}\n\n16 个用例都完美通过了！\n\n\n2. 用栈实现队列\nleetcode: 232. 用栈实现队列\n\n\n有了上一道题目的经验，这道题的实现就不那么困难了。\n2.1 思路\n栈的特点是只能在栈顶删除和插入数据\n\n队列需要在队尾插入数据，在对头删除数据\n\n\n假设现在我们有下面这两个栈，第一个栈里面存放了 1 2 3 4 的数据\n需要进行  队列的 POP操作时，我们需要删除的是最底部的 1\n\n可以先将栈中的  所有数据 pop 并 push 到另外一个空栈  中，再将最后一个数据存放后删除，返回存放的值。\n\n这部分操作与第一题中的操作很像，但是有一个  致命的问题：在新的栈里的数据和我们原本想要的数据是相反的！\n1 2 3 4 删除 1 后原本数据 2 3 4实际数据 4 3 2\n\n解决这个问题的方法只有一个，那就是把这一批数据再复制回原本的栈中，它的顺序就对了\n\n而我自己写的栈是用  数组  实现的，题目要求的 peek 函数可以直接通过访问  非空栈的 0 下标  元素得到\nempty函数同理，只有两个栈中都为空时，模拟的队列才是空的\n\n2.2 栈的代码  栈的实现在本文开头的博客链接中有详细解释，这里不再复述\n\n回到开头\n\n// 支持动态增长的栈typedef int STDataType;typedef struct Stack{    STDataType* a;    int top; // 栈顶    int capacity; // 容量}Stack;// 初始化void StackInit(Stack* ps){    STDataType* new = (STDataType*)malloc(sizeof(STDataType) * 4);    if (new == NULL)    {        exit(-1);    }    else    {        ps-&gt;a = new;        ps-&gt;top = 0;        ps-&gt;capacity = 4;    }}// 销毁栈void StackDestroy(Stack* ps){    assert(ps);    free(ps-&gt;a);    ps-&gt;a = NULL;    ps-&gt;capacity = 0;    ps-&gt;top = 0;}// 入栈void StackPush(Stack* ps, STDataType data){    assert(ps);    if (ps-&gt;top == ps-&gt;capacity)    {        STDataType* new = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * (ps-&gt;capacity) * 2);        if (new == NULL)        {            exit(-1);        }        else        {            ps-&gt;a = new;            ps-&gt;capacity *= 2;        }    }    ps-&gt;a[ps-&gt;top] = data;    ps-&gt;top++;}// 出栈void StackPop(Stack* ps){    assert(ps);    if (ps-&gt;top &gt; 0)        (ps-&gt;top)--;}// 获取栈顶元素STDataType StackTop(Stack* ps){    assert(ps);    assert(ps-&gt;top &gt; 0);    return ps-&gt;a[ps-&gt;top - 1];}// 获取栈中有效元素个数int StackSize(Stack* ps){    assert(ps);    return ps-&gt;top;}// 检测栈是否为空，如果为空返回 true，如果不为空返回 falsebool StackEmpty(Stack* ps){    assert(ps);    if (ps-&gt;top == 0)        return true;    else        return false;}void StackPrint(Stack* ps){    assert(ps);    int n = ps-&gt;top;    for (int i = 0; i &lt; n; i++)    {        printf(\"%d\", ps-&gt;a[i]);    }    printf(\"\\n\");}\n\n2.3 本题的代码typedef struct {    Stack st1;    Stack st2;} MyQueue;MyQueue* myQueueCreate() {    MyQueue* qt = (MyQueue*)malloc(sizeof(MyQueue));    if (qt == NULL)        return NULL;    StackInit(&amp;qt-&gt;st1);    StackInit(&amp;qt-&gt;st2);    return qt;}void myQueuePush(MyQueue* obj, int x) {    assert(obj);    if (!StackEmpty(&amp;obj-&gt;st1))    {        StackPush(&amp;obj-&gt;st1, x);    }    else    {        StackPush(&amp;obj-&gt;st2, x);    }    return;}int myQueuePop(MyQueue* obj) {    assert(obj);    Stack* empty = &amp;obj-&gt;st1;    Stack* nonempty = &amp;obj-&gt;st2;    if (!StackEmpty(&amp;obj-&gt;st1))    {        Stack* empty = &amp;obj-&gt;st2;        Stack* nonempty = &amp;obj-&gt;st1;    }    while (StackSize(nonempty) &gt; 1)    {        int top1 = StackTop(nonempty);        StackPush(empty, top1);        StackPop(nonempty);    }    int top = StackTop(nonempty);    StackPop(nonempty);// 原本不为空的的最后一个 top 被取出    // 需要将数据再倒放一遍，否则访问是反的    while (StackSize(empty) &gt; 0)    {        int top2 = StackTop(empty);        StackPush(nonempty, top2);        StackPop(empty);    }    return top;}int myQueuePeek(MyQueue* obj) {    assert(obj);    Stack* empty = &amp;obj-&gt;st1;    Stack* nonempty = &amp;obj-&gt;st2;    if (!StackEmpty(&amp;obj-&gt;st1))    {        Stack* empty = &amp;obj-&gt;st2;        Stack* nonempty = &amp;obj-&gt;st1;    }    // 这里的栈是用数组实现的，可以直接访问首位元素    return nonempty-&gt;a[0];}bool myQueueEmpty(MyQueue* obj) {    assert(obj);    return StackEmpty(&amp;obj-&gt;st1) &amp;&amp; StackEmpty(&amp;obj-&gt;st2);}void myQueueFree(MyQueue* obj) {    assert(obj);    StackDestroy(&amp;obj-&gt;st1);    StackDestroy(&amp;obj-&gt;st2);    free(obj);    return;}\n\n\n\n3. 设计循环队列\nleetcode：622. 设计循环队列\n\n\n这道题最主要的突破口，就是弄明白题目所说的  循环队列  的意思\n实际上他就是一个下图所示的队列，当 tail 使用完已有空间后，可以跳到前面继续使用之前开辟好的空间，而不需要额外的扩容空间。\n\n为了方便找头以及找尾，本体将使用数组方式来实现它的代码\n\n3.1 思路  确定是数组形式后，我们就要来思考两个问题：什么时候队列为空？什么时候队列是满？\n3.1.1 判断是否为空  这个看起来好像非常简单，只要头指针和尾指针相同，队列不就是空的了嘛！\n\n这个想法对，但有有点瑕疵，即我们怎么界定空和非空的界限？\n3.1.2 判断是否为满  每插入一个数据，tail 指针就会往后 ++ 一次，指向已有数据的下一位\n\n当下一位也被装好了数据之后，tail 就会回到开头，来到 front 指针的位置！\n\n这个时候，tail=front，但是队列实际上已经满了！\n这就让我们不得不思考，如何将这两种情况区分开来？\n\n啊哈哈哈哈，答案来喽：\n\n如果需要的数据为 K 个，为队列的数组开辟 K+1 个空间\n\n这时候，只要 tail+1=front，就代表队列已经满了。多出来的这一个空间不存放数据\n\n注意：这个空间不一定是最末尾的哪一个，它会随着队列的插入、删除操作而移动\n当 tail 在尾部，tail=k（注意 tail 是下标而不是指针）且 front=0 时，队列为满\n\n\n这样就很完美的把  空和满  两种情况给区分开来了！\n\n3.2 本题代码实现  需要注意题目给出的返回值要求，依照题目函数要求来编写\ntypedef struct {    int* data;    int front;    int tail;    int k;} MyCircularQueue;bool myCircularQueueIsEmpty(MyCircularQueue* obj);bool myCircularQueueIsFull(MyCircularQueue* obj);// 为了让这个函数能在它之前使用MyCircularQueue* myCircularQueueCreate(int k) {    MyCircularQueue* qt = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));    if (qt == NULL)        return NULL;    qt-&gt;data = (int*)malloc(sizeof(int) * (k + 1));    qt-&gt;k = k;        qt-&gt;front = 0;    qt-&gt;tail = 0;    return qt;}bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {    assert(obj);    if (myCircularQueueIsFull(obj))        return false;    obj-&gt;data[obj-&gt;tail] = value;    //obj-&gt;tail++;    //obj-&gt;tail %= obj-&gt;k+1;// 保证数据在数组内部    if (obj-&gt;tail == obj-&gt;k)    {        obj-&gt;tail = 0;    }    else    {        obj-&gt;tail ++ ;    }        return true;}bool myCircularQueueDeQueue(MyCircularQueue* obj) {    assert(obj);    if (myCircularQueueIsEmpty(obj))        return false;    if (obj-&gt;front == obj-&gt;k)    {//front 在预先开辟的第 4 个位置上        obj-&gt;front = 0;    }    else    {        obj-&gt;front++;    }    return true;}int myCircularQueueFront(MyCircularQueue* obj) {    assert(obj);    if (myCircularQueueIsEmpty(obj))        return -1;    return obj-&gt;data[obj-&gt;front];}int myCircularQueueRear(MyCircularQueue* obj) {    assert(obj);    if (myCircularQueueIsEmpty(obj))        return -1;    if (obj-&gt;tail == 0)    {        return obj-&gt;data[obj-&gt;k];    }    else    {        return obj-&gt;data[obj-&gt;tail - 1];    }    return -1;}bool myCircularQueueIsEmpty(MyCircularQueue* obj) {    return obj-&gt;tail == obj-&gt;front;}bool myCircularQueueIsFull(MyCircularQueue* obj) {    if ((obj-&gt;tail == obj-&gt;k) &amp;&amp; obj-&gt;front == 0)    {        return true;    }    else    {        return obj-&gt;tail + 1 == obj-&gt;front;    }}void myCircularQueueFree(MyCircularQueue* obj) {    assert(obj);    free(obj-&gt;data);    free(obj);    return;}\n\n\n结语  刷完这 3 道题，有没有感觉数据结构的很多内容都是关系紧密的？🤩\n只要我们把  链表和顺序表的内容  搞得透彻，栈和队列这部分就没那么难了！\n加油！\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","OJ刷题","栈","队列","循环队列"]},{"title":"【C++】凝视 C++ 的第一眼","url":"/posts/1070210667/","content":"从今天开始，正式步入 C++ 学习的大门啦！\n\n\nC++ 的博客主要是我个人学习的  学习笔记，刚开始会记一些比较零碎的小知识点，可能没有之前 C 语言的博客那么系统化😂\n笔记中可能有错误的地方，欢迎大家指出！\n\n感谢你关注  慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n[TOC]\n1.C++ 简介\n你可以通过菜鸟教程网来学习 C++👉传送门\n\nC++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\nC++ 被认为是一种  中级  语言，它综合了高级语言和低级语言的特点。\nC++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的 C，后来在 1983 年更名为 C++。\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n\n2.C++ 关键字C 语言有 32 个关键字，C++ 在它们的基础上进行了扩容，共有 63 个关键字\n\n\n\nasm\nelse\nnew\nthis\nauto\nenum\n\n\n\noperator\nthrow\nbool\nexplicit\nprivate\ntrue\n\n\nbreak\nexport\nprotected\ntry\ncase\nextern\n\n\npublic\ntypedef\ncatch\nfalse\nregister\ntypeid\n\n\nchar\nfloat\nreinterpret_cast\ntypename\nclass\nfor\n\n\nreturn\nunion\nconst\nfriend\nshort\nunsigned\n\n\nconst_cast\ngoto\nsigned\nusing\ncontinue\nif\n\n\ndefault\ninline\nsizeof\nvirtual\nstatic\nvoid\n\n\ndo\nlong\nstruct\nwchar_t\ndelete\nint\n\n\nstatic_cast\nvolatile\ndouble\nmutable\nswitch\nwhile\n\n\ndynamic_cast\nnamespace\ntemplate\n\n\n\n\n\n\n如果你想查看它们的完整介绍，可以参考这篇教程👉传送门\n\n这里只做一个基本的认识，后续会一一学习这些关键字\n\n3. 安装你的 C++ 环境\n如果是 windows 系统，建议使用  微软的 VisualStudio，不要用 dev 这种老式编译器！\n如果是 mac 系统，可以使用 Xcode（我没有 mac 不知道具体情况）\n如果是 linux 系统，需要安装 G++ 编译器\n\n利用我的树莓派，给大家演示一下 linux 环境安装 G++ 编译器\n下面这个语句是显示 g++ 编译器的版本，如果你弹出了和我一样的页面，说明你的 linux 系统里面已经有这个编译器了\ng++ -v\n\n\n如果没有，我们可以使用下面这个语句来整一个g++\nsudo apt-get install g++\n\n你也可以用这个语句来验证你的 G++ 是否已经安装\n\n下载完成后，就可以愉快的使用你的 G++ 编译器了\n\n如果你的下载很慢，可能要考虑换源（即更换一个软件下载源）\n树莓派实验室  详细记录了国内比较好用的源，也有换源教程👉传送门\n\n\n4.C++ 的输入输出 4.1cout 和 cin 样例 老规矩，向这个世界问个好吧！\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;    return 0;&#125;\n\n\n这里出现的 endl 是“end of line”的缩写，结束一行，相当于 C 语言中的\\n\n因为 C++ 的编译器是完成兼容 C 语言的，所以你可以用 &quot;\\n&quot; 来替换endl\n\n\ncout是流提取操作符，对应的，也有流插入操作符cin。你可以理解为它们就是 C++ 中的 printf 和 scanf\n注意这里的  箭头方向，不要弄错了\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;    int a;    cin &gt;&gt; a;    cout &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n\n\n4.2 头文件  使用这两个“库函数”时，必须要要包含 iostream 头文件以及 std 标准命名空间\n在 cplusplus.com 上搜索，可以看到 iostream 是标准输入输出流的库\n\n4.3 和 C 语言的不同  使用 C++ 来输入输出更加方便，因为我们不需要增加  格式控制符 （%d %c %f 这种）\n因为编译器会自己判断它们的类型\n\n同样的，我们可以使用连续的 &gt;&gt; 来输入多个数据\n\n4.4 浮点数默认保留 5 位小数  通过两个程序的测试，我们可以看到 C++ 中默认保留小数是 5 位，而C 语言中是 6 位\n\n\n那么问题来了，如果我想控制输出格式，让它输出  小数点后两位  可以怎么做呢？\n很简单，直接调用 printf 和%.2f不就完事了？\n\nC++ 中也有自己的格式控制方式，但是那个比 printf 更复杂\n\n\n而且在 C++ 中打印低于 5 位的浮点数，并不会像 C 语言一样后补 0\n\n注意注意！如果在 C++ 程序中使用 printf，就不能在 printf 里面写 endl 啦！\n\n5. 命名空间  在输入输出函数中，有这么一个语句\nusing namespace std;\n\n前面已经提到过，std 是”标准命名空间”\n那什么是命名空间呢？\n\n5.1 简单介绍  在 main 函数中，如果出现了两个相同名字的参数，编译器会报错\n\n\n假设一个班级上有两个同名的同学，为了区分他们俩人，我们会使用一些附加的条件来称呼二者。比如性别、家庭住址、甚至是成绩\n\nC++ 中的命名空间就是用来干这个事的\n在  项目合作  的时候，命名空间很有用，可以有效避免两个人写的程序中出现同样名字的变量而导致冲突的情况\n5.2 设置一个命名空间  比如现在我们设置一个命名空间，把 int a 放入其中\nnamespace muxue &#123;\tint a = 1;&#125;\n\n可以看到，这个时候编译程序就不会报错了\n\n但是程序打印的是 main 函数中的 double 类型 a，如果我们想用 muxue 中的 int a 要怎么操作呢？\n只需要在变量名之前用 :: 来指定命名空间就可以了\n\n当然，我们也可以使用 using namespace muxue; 来直接展开这个命名空间中的所有东西\n\n但是这样不太好！后面会提到\n\n如果你定义了  两个相同名字的命名空间，在编译程序的时候，编译器会合并他们\n\n5.2.1 嵌套定义命名空间  定义命名空间就和 C 语言的结构体很类似，是可以嵌套定义另外一个命名空间的\n// 命名空间namespace muxue &#123;\tint a = 1;\t// 嵌套定义命名空间\tnamespace happy &#123;\t\tint b = 2;\t&#125;&#125;int main() &#123;\tdouble a = 3.14;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; muxue::a &lt;&lt;endl;\tcout &lt;&lt; muxue::happy::b &lt;&lt; endl;\treturn 0;&#125;\n\n\n直接展开两个命名空间后，就不需要这样写输出函数了\n\n\n我们还可以在已有命名空间中嵌套定义一个命名空间，里面包含另外一个 a\nnamespace muxue &#123;\tint a = 1;\t// 嵌套定义命名空间\tnamespace happy &#123;\t\tint a = 2;\t&#125;&#125;\n\n这时候如果使用 using namespace muxue;，在 main 函数中会默认打印 外层命名空间  中的 a\n\n但如果你比较喜欢作死，把内层命名空间也展开了，就会出现冲突\nusing namespace muxue;using namespace muxue::happy;\n\n\n\n除了  嵌套定义  中这种  冲突  的情况，我们直接展开命名空间时，还会遇到其他冲突\n5.3 全部展开可能遇到的问题 5.3.1 和库函数冲突 比如下面这个情况，我们在 muxue 里面定义了一个 int 类型叫做 rand，并在之后直接 using namespace 完整展开了这个命名空间\n#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;namespace muxue &#123;\tint a = 1;\tint rand = 0;&#125;using namespace muxue;int main()&#123;\ta += 1;\tcout &lt;&lt; a &lt;&lt; endl;\trand = 10;\tprintf(&quot;%d\\n&quot;, rand);\treturn 0;&#125;\n\n然后你就会发现，程序 boom 了！\n\n这是因为在 &lt;stdlib.h&gt; 头文件中有一个生成随机数的 rand 函数，现在程序不知道你是要用命名空间中的变量 rand，还是想调用这个  库函数  了！\nmuxue::rand = 10;printf(&quot;%d\\n&quot;, muxue::rand);\n\n这时候我们就要选择单独调用命名空间中的 rand 变量，而不是直接使用变量名\n\n同时，顶部的 using namesapce 也需要做相应修改\n//using namespace muxue;using muxue::a;\n\n5.3.2 和其他命名空间冲突namespace muxue &#123;\tint a = 1;\tint rand = 0;&#125;namespace haha &#123;\tint a = 3;&#125;using namespace muxue;using namespace haha;\n\n假设两个命名空间中都有 a 变量，这时候程序也不知道你要调用哪一个 a 了，同样会报错\n\n\n这就好比班级里有俩个叫  李华  的人，本来一个是男的，一个是女的，咱们可以用  性别  区分\n直接完整展开了命名空间，就好比让这两个李华都变成  男生\n这不 BBQ 了吗？还怎么  用性别  判断谁是谁？\n\n所以在很多时候，尽量使用 :: 单独展开某一个变量，而不是展开整个命名空间\n这种冲突的情况，被称为  命名空间污染\n\n5.4 避免命名空间污染  在菜鸟教程上，可以看到有大佬做了一个这样的笔记\n\n是的，有的时候我们自定义的变量类型名会和 std 标准命名空间冲突，这时候直接在最前面 using namespace std; 就会出 5.3 中提到的问题\n可 cout 和 cin 这两个家伙天天要用，总不能每一次使用的时候，都写一个 std:: 吧？那样也太麻烦了！\n别急，我们也可以单独展开这几个小家伙！\nusing std::cin;using std::cout;using std::endl;\n\n\n其他一些问题在之前 5.2 和5.3都已经提到过了，这里就不再说啦！\n个人理解，即便 C++ 有命名空间这个好东西，在定义变量的时候最好还是保持一个良好的编程习惯，不用关键字和库函数名作为变量名\n5.5 ::指定全局作用域  当我们默认使用 :: 而不在前面添加命名空间的名字的时候，默认会指定到全局的命名空间。即便函数被另外一个命名空间所包裹，也是会调用全局作用域下的函数\n// 全局void _print()&#123;    cout &lt;&lt; &quot;global print&quot; &lt;&lt; endl;&#125;// 命名空间namespace muxue&#123;    void _print()    &#123;        cout &lt;&lt; &quot;namespace muxue print&quot; &lt;&lt; endl;    &#125;     void testNamespace()    &#123;        ::_print();// 调用全局作用域的函数    &#125;&#125;int main()&#123;    muxue::_print();// 调用命名空间内的 print    muxue::testNamespace();     return 0;&#125;\n\n打印的结果如下\n\n\n6. 缺省参数  缺省参数是函数在定义的时候，给指定的参数一个默认值，如果没有指定实参，就会使用这个默认值。比如：\n// 缺省参数void Add(int a = 10,int b = 20) &#123;\tcout &lt;&lt; a + b &lt;&lt; endl;&#125;int main() &#123;\tint n = 1, m = 2;\tAdd(n, m);// 指定了实参\tAdd();// 没有指定\treturn 0;&#125;\n\n\n除了这两种方式外，我们还可以  只给该函数传一个实参\n\n但是像下面这样，想给函数中的 b 传一个参数是不可以的\n\n6.1 全缺省和半缺省\n像上面这种，函数中的所有形参都设定了缺省值的，叫做  全缺省\n函数中只有一部分设置了缺省值的，叫做  半缺省\n\n注意：设置缺省参数的时候，必须  从右往左  设置，不能出现中间空一个的情况\n\n6.1.1 全缺省  比如这么一个有 3 个参数的函数，我们全部设置了缺省值，就是  全缺省\nvoid Print(int a = 10, int b = 20,int c=30) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; c &lt;&lt; endl;&#125;\n\n我们可以直接传 3 个值，进行对应的打印，也可以只传两个、一个或者不传形参\n\n这种  中间间隔一个  传参是不允许的\n\n\n6.1.2 半缺省  半缺省是缺省了一部分的函数\nvoid Print2(int a, int b = 20, int c = 30) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; c &lt;&lt; endl;&#125;\n\n在调用的时候，我们就不能不传参数了\n\n至少要传一个参数给我们的 a\n\n半缺省的函数可以是如下形式\nvoid Print2(int a, int b = 20, int c = 30);void Print2(int a, int b, int c = 30);\n\n但不能是这样\nvoid Print2(int a=10, int b, int c = 30);\n\n因为这种情况会出现歧义，编译器不知道你的参数是给 b 还是给 a\n\n6.2 缺省参数的应用  比如在创建一个顺序表的时候，我们可以利用缺省参数来设置  默认长度\n这样就避免了单一默认长度  导致的多次扩容（realloc 扩容是有性能浪费的！）\n\n\n比如我知道我这次需要一个很长的顺序表，直接  改默认长度  不太合适。使用这种方法传一个新的长度值更加方便我们的动态管理！\n\n缺省参数是只有 C++ 才支持的函数定义方式，这也是 C++ 比 C 语言更优的体现\n6.3 多文件编程中的缺省  使用多文件编程的时候，缺省值只需要在头文件中给出即可\n\n不需要在  函数定义的源文件  中给出，编译器会报错\n\n假设函数的声明和定义中设定的缺省值不同，编译器就不知道要用哪一个缺省值\n\n\n调用函数，可以看到函数正确分配了不同的初始值\n\n\n6.3.1 错误情况  但如果我们在  头文件中不包含缺省 ，函数就会报错， 不支持我们只传 1 个参数\nvoid InitArr(Qa* q, int n);\n\n\n只要你的头文件中声明没有缺省， 在函数定义的源文件中加入缺省也是没用的！\n\n因为编译器展开头文件是在 main 函数中之上，在查找函数的时候，只会向上查找声明。所以函数的声明是  以头文件为准！\n\n\n\n结语  第一篇 C++ 的笔记就写这么多（其实已经有几千字了）\n下一篇笔记是  函数重载，可以让你感受到 C++ 的更多花样！\n\n不会有人把博客看完了还不点赞吧？\n\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：vector","url":"/posts/3664653329/","content":"STL 的第二站，便是 vector 了。\n\n\n对于学习 STL，有一个非常大的好处便是，它们有很多函数都是相通的！这也是面向对象的一大好处：背后的函数实现可能不同，但是使用方式相同。\n1. 简单了解 vector\nhttps://m.cplusplus.com/reference/vector/vector/\n\n老样子，打开我们的 cplusplus——然后惊奇的发现，它换 UI 了！终于不再是那个 2000 年初的模样了（虽然这和我们的使用没啥关系）\n\n不摸鱼了，来看看 vector 究竟是何方神圣——其实他就是一个  顺序表\n和 string 不同的是，vector有模板参数，可以存储任何类型的内容。int、double、char、甚至 string。\n这一点在 cplusplus 网站上的第一行便告诉了我们\n\ntemplate &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; // generic template\n\n你还可以看到，标题下方给了一个这样的类模板定义，其中 T 代表的是存放数据类型，allocator&lt;T&gt;也是 STL 库中的一部分，用于向堆申请空间（类似一个内存池）可以提高访问的效率\n前期的学习我们不需要知道 allocator&lt;T&gt; 是怎么实现的，只要知道它有这个功能就 ok 了。\n\n1.1 函数接口  往下滑，你会发现 vector 的函数接口，我们很多都已经学过了！\n\n这些函数的操作和 string 类型都是一样的，这里就不再讲解了！\n\n对比发现，其实 vector 多出来的函数并不多，这便是学习 STL 的好处！\n\n2. 使用 vector因为大部分函数的功能、操作和 string 一样，有问题可以去看看我之前string 的博客\n2.1 构造\n对于 vector 而言，比较常用的构造函数是下面这几个\n\n这里说说最后一个，利用迭代器进行初始化，它的使用如下\nstd::string s1(&quot;hello&quot;);vector&lt;char&gt; v2(s1.begin(),s1.end());for (auto ch : v2)&#123;\tcout &lt;&lt; ch &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;\n\n当我们已经有一个其他的支持迭代器的容器之后，便可以使用该容器的迭代器初始化一个vector\n这里的区间可以自行控制，对应的初始化的内容也会有所不同\n\n\n2.2 迭代器vector 的迭代器和 string 基本相同，都拥有正向和反向两种方式\n\n\n\n迭代器\n说明\n\n\n\nbegin+end\n获取第一个数据位置 iterator&#x2F;const_iterator， 获取最后一个数据的下一个位置 iterator&#x2F;const_iterator\n\n\nrbegin+rend\n获取最后一个数据位置的 reverse_iterator，获取第一个数据前一个位置的 reverse_iterator\n\n\n\nvector&lt;int&gt;::iterator it = v.begin(); while (it != v.end()) &#123;     cout &lt;&lt; *it &lt;&lt; &quot; &quot;;     ++it; &#125;\n\n利用迭代器，我们可以打印 vector 的内容\n2.3 迭代器失效问题  在 vector 中的一些操作会导致迭代器失效，即迭代器指向的内容含义变了。包括但不限于：\n\n因为 erase 导致的数据擦除\n扩容导致的原有空间被释放（此时迭代器依旧指向原有空间）\n所有会导致扩容的操作\n\n这时候我们需要借助函数的返回值对 it 进行重新赋值，比如下图是 erase 和insert的返回参数\n\n\n我们只需要在使用迭代器遍历的时候用 it 来接受返回值（更新迭代器）就可以规避这个问题\nvoid test02()&#123;    vector&lt;int&gt; v1;    v1.push_back(1);    v1.push_back(2);    v1.push_back(3);    v1.push_back(4);    v1.push_back(5);    v1.push_back(6);    v1.push_back(7);    vector&lt;int&gt;::iterator it = v1.begin();    while (it != v1.end())    &#123;        if (*it % 2 == 0)// 在偶数之前插入内容        &#123;            // 不这样写会出现 it 的含义变化而导致的死循环            // 程序内出现了扩容，it 原先指向的空间已经被释放            it = v1.insert(it, 99);\t            it++;        &#125;        it++;    &#125;    for (auto ch : v1)    &#123;        cout &lt;&lt; ch &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n\n\n库里面的其他函数就不进行讲解啦，有问题的可以去看看之前 string 的博客。当然最好的学习办法就是依据 cplusplus 上面的函数定义，尝试自己弄明白这些库函数的使用方法。\n\n3. 模拟实现\n代码详见我的 gitee 仓库【链接 】STL-Vector 的 源码  也在里面！\n\n和 string 类不同的是，在 vector 里面并不是用 size 和 capacity 这两个成员变量来确认有效长度和容量的。\n通过查看 stl 源码可以看到，其使用了 3 个迭代器进行标识\n\nprivate:    iterator _start;// 指向开头（存放数据）    iterator _finish;// 指向结尾的下一个    iterator _endofstorage;// 指向空间尾部\n\n了解结构后，便可以先把无参构造和析构函数写出来待用\n// 无参构造函数vector()    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123; &#125;// 析构~vector()&#123;    if (_start)    &#123;        delete[] _start;        _start = _finish = _endofstorage = nullptr;    &#125;&#125;\n\n那么要怎么知道 size 和 capacity 的大小呢？很简单，通过指针相减即可得出结果\nsize_t size()const&#123;    return _finish - _start;&#125;size_t capacity()const&#123;    return _endofstorage - _start;&#125;\n\n3.0 迭代器  在模拟实现一开始，我们就要用 typdef 定义两个迭代器，方便后面的使用\ntypedef T* iterator;typedef const T* const_iterator;iterator begin()&#123;    return _start;&#125;iterator end() &#123;    return _finish;&#125;const_iterator begin()const &#123;    return _start;&#125;const_iterator end()const &#123;    return _finish;&#125;\n\n3.1 reserve&#x2F;resize现在我们的 vector 内容还是空空的，我们需要先实现一下 push_back 函数，可以基本操作一下我们的数据。但没有构造函数去申请空间，哪来的目标给我们操作呢？\n\n这时候就需要先实现 reserve 来扩容和获取空间了！\n\n在扩容之前，我们需要获取原有  数据的长度 ，再 new 将空间整出来，并给_start。操作结束后，我们需要修改_finish  和_endofstorage，否则这两个迭代器指向的还是  原有空间 ，出现了 迭代器失效问题\nvoid reserve(size_t n)// 扩容&#123;    size_t sz = size();// 计算原有的长度    if(n &gt; capacity())    &#123;        T* tmp = new T[n];        if (_start) // 只有_start 不为空才进行拷贝操作        &#123;            //memcpy 是浅拷贝，当遇到 vector 类型是自定义类型（比如 string 和 vector&lt;T&gt; 这种包含堆区内存的类型）            // 浅拷贝会失效，string 的成员变量拷贝过去了，但是成员变量指向的堆区空间被释放，出现野指针            //memcpy(tmp, _start, size());            for (size_t i = 0; i &lt; size(); i++)            &#123;                tmp[i] = _start[i];// 手动赋值，当成员是自定义类型的时候，会调用 = 重载            &#125;            delete[] _start;// 释放原有空间        &#125;        _start = tmp;    &#125;    // 这里必须要先计算 sz，如果在这里直接调用 sz 的话：finish 已经是野指针了，finish-start 会出现问题    _finish = _start + sz;    _endofstorage = _start + n;&#125;\n\n关于为何拷贝内容的时候需要用 &#x3D; 而不能直接memcpy，后文会提到。\nresize 和 reserve 唯一不同的一点，就是 reserve 会修改原有空间的数据，其余的实现是一样的。所以这里面我们直接复用 reserve 进行扩容即可\n// 在 C++ 中，内置类型也有一个“构造函数”// 这是为了更好的支持模板操作void resize(size_t n,T val = T())&#123;    if (n &gt; capacity())    &#123;        reserve(n);    &#125;    if (n &gt; size())    &#123;        // 初始化        while (_finish &lt; _start + n)        &#123;            *_finish = val;            ++_finish;        &#125;    &#125;    else    &#123;        _finish = _start + n;    &#125;&#125;\n\n注意，T()的含义是用模板参数的  构造函数  作为缺省值。在 C++ 中，内置类型也可以进行这个操作\n\n当你不进行传值的时候，int 类型默认是 0\n\n3.2 插入 &#x2F; 删除  空间拿到了，现在就可以对我们的数据进行插入操作了\nvoid push_back(const T&amp; x)&#123;    if (_finish == _endofstorage)     &#123;        size_t newcapa = capacity() == 0 ? 4 : capacity() * 2;        reserve(newcapa);    &#125;    *_finish = x;    _finish++;&#125;void pop_back()&#123;    if (_finish &gt; _start)     &#123;\t\t_finish--;\t&#125;&#125;\n\n简单测试一下插入和删除功能，没啥问题\n\n更好的办法，其实是写好 insert 和 earse，然后尾插尾删的时候直接复用即可\n//pos 位置插入 valiterator insert(iterator pos, const T x)&#123;    assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);    //assert(pos &gt;= _start &amp;&amp; pos &lt;= _endofstorage);    if (_finish == _endofstorage)    &#123;        size_t n = pos - _start;        size_t newcapa = capacity() == 0 ? 4 : capacity() * 2;        reserve(newcapa);        pos = _start + n;    &#125;    iterator end = _finish - 1;    while (end &gt;= pos)    &#123;        *(end + 1) = *end;        end--;    &#125;    *pos = x;    _finish++;    return pos;&#125;// 删除数据iterator erase(iterator pos)&#123;    assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);    iterator tmp = pos;    iterator end = _finish - 1;    while (tmp &lt; end)    &#123;        *tmp = *(tmp + 1);        tmp++;    &#125;    _finish--;    return pos;&#125;\n\n因为这里我们只需要操作一个元素，所以就不需要担心移动多个数据可能导致的问题，事情也变得简单多了\nvoid push_back(const T&amp; x)&#123;    insert(end(),x);&#125;void pop_back()&#123;    erase(end()-1);&#125;\n\n尾插尾删操作直接复用源码即可\n3.3 重载 [] 操作符  因为 vector 本身只是个顺序表，所以我们需要对它的对象重载一下 [] 操作符，这样就能和数组一样去访问 vector 的数据\n// 重载 [] 操作符T&amp; operator[](size_t pos)&#123;    assert(pos &lt; size());    return _start[pos];&#125;const T&amp; operator[](size_t pos) const&#123;    assert(pos &lt; size());    return _start[pos];&#125;\n\n\n关于构造函数，这里重点介绍一下  迭代器区间的构造函数，因为后面的拷贝构造我们会用上它。\n3.4 迭代器区间构造 &#x2F; 拷贝 &#x2F; 赋值  库里面关于该构造函数的定义如下\ntemplate &lt;class InputIterator&gt;   vector (InputIterator first, InputIterator last,           const allocator_type&amp; alloc = allocator_type());\n\n因为这时候我的水平还很垃，就暂且不管这个  allocator 了\n该函数需要我们传参两个迭代器，因为我们底层就是用指针实现的，所以直接解引用然后将内容尾插即可（如果没有空间，尾插会调用 reserve 来获取空间 &#x2F; 扩容）\ntemplate &lt;class InputIterator&gt;vector(InputIterator first, InputIterator last)    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123;    while (first != last)    &#123;        push_back(*first);        first++;    &#125;&#125;\n\n有了这个构造函数后，拷贝构造就很容易了！\nvoid swap(vector&lt;T&gt;&amp; v)&#123;    std::swap(_start, v._start);    std::swap(_finish, v._finish);    std::swap(_endofstorage, v._endofstorage);&#125;// 拷贝构造vector(const vector&lt;T&gt;&amp; v)    :_start(nullptr),_finish(nullptr),_endofstorage(nullptr)&#123;    vector&lt;T&gt; tmp(v.begin(), v.end());    swap(tmp);&#125;\n\n利用迭代器区间构造出来一个 tmp 对象，再将该对象和我们本身进行交换即可！\n\n你可能会问：欸你这样交换了，原本的内容岂不是没人管了，有内存泄漏啊！\n\n并不是这样的，我们使用库函数里面的 swap 交换了二者的成员变量，在拷贝构造函数完成之后，tmp生命周期结束，会自动调用构造函数处理掉我们的数据！\n这就是让别人帮你干活😂\n赋值重载就跟简单了，我们连 tmp 变量都不需要弄，直接使用传值（会自动调用拷贝构造一个临时变量）就可以啦！\n// 赋值重载（v 没有引用，拷贝构造一个新的传参过来，所以不需要手动再构建一个 tmp）vector&lt;T&gt;&amp; operator=(vector&lt;T&gt; v)&#123;    swap(v);    return *this;&#125;\n\n3.5 用 n 个 value 进行构造  在库中的 vector 还有一个这样的构造函数，用 n 个 val 进行初始化\n\n因为我们之前已经实现了一个相关功能的函数 resize，我们只需要调用resize 就可以完成这个操作！\n// 利用 n 个 val 进行构造vector(size_t n, const T&amp; val = T())    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123;    resize(n, val);&#125;\n\n只实现一个 vector(size_t n, const T&amp; val = T()) 的版本是不可以的，因为我们忽略了一种情况\nvector&lt;char&gt; v1(10,&#x27;x&#x27;)// 可以成功调用vector&lt;int&gt;  v2(10,11) // 不能成功调用！ \n\n\n为啥第二种情况不行呢？再来看看另外一个构造函数，我们之前实现过的迭代器区间构造\ntemplate &lt;class InputIterator&gt;vector(InputIterator first, InputIterator last)\n\n你会发现，当我们传的两个参数都是 int 类型的时候，编译器会直接调用这个模板函数！因为 first 和last就是两个相同类型的参数！\n通过  调试  也可以看到在进行构造的时候，调用了这个迭代器区间构造函数\n\n为了避免这种情况，我们需要对 int 类型单独处理一下，修改一下传参即可\n// 如果不单独重载一个 int 类型版本，就会被识别成上面的模板函数//int 是不能当作迭代器进行解引用的，会报错vector(int n, const T&amp; val = T())    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123;    resize(n,val);&#125;\n\n\n这个问题是怎么发现并解决的？\n\n我们可以直接查看 stl 源码，瞅瞅库里面是怎么实现的\n\n可以看到库里面不但重载了一个 int 类型的版本，还重载了 long 长整型的情况\n到这里，我们的模拟实现就基本完成了！\n\n3.6 关于自定义类型的拷贝问题  为什么在 3.1 的 reserve 实现中，我使用了赋值重载，而没有使用memcpy？\n来看看下面这个 OJ 题目杨辉三角的代码\n\nleetcode118 杨辉三角：https://leetcode.cn/problems/pascals-triangle/submissions/\n\nclass Solution &#123;\tpublic:\t\tvector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;\t\t\tvector&lt;vector&lt;int&gt;&gt; vv;\t\t\tvv.resize(numRows);\t\t\tfor (size_t i = 0; i &lt; vv.size(); ++i)\t\t\t&#123;\t\t\t\t// 杨辉三角，每行个数依次递增\t\t\t\tvv[i].resize(i + 1, 0);\t\t\t\t// 第一个和最后一个初始化成 1\t\t\t\tvv[i][0] = 1;\t\t\t\tvv[i][vv[i].size() - 1] = 1;\t\t\t&#125;\t\t\tfor (size_t i = 0; i &lt; vv.size(); ++i)\t\t\t&#123;\t\t\t\tfor (size_t j = 0; j &lt; vv[i].size(); ++j)\t\t\t\t&#123;\t\t\t\t\tif (vv[i][j] == 0)\t\t\t\t\t&#123;\t\t\t\t\t\t// 中间位置等于上一行 j-1 和 j 个相加\t\t\t\t\t\tvv[i][j] = vv[i - 1][j - 1] + vv[i - 1][j];\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\treturn vv;\t\t&#125;\t&#125;;\n\n在这里面，我们有两层 vector 进行嵌套使用，外层的 vector 存放的是内层 vector 的对象。\n它的结构如下图\n\n这时候如果只用 memcpy 进行浅拷贝，相当于新的空间里面存放的是的确是新的 vector 对象，但这些 vector 对象存放的却是  原有数据的指针，而原本的数据已经被我们 delete 掉了，出现了野指针问题！\n反应到代码上，当我们在  Solution 内部进行一次打印，再在外部进行一次打印，结果就会完全不同\nvoid test05()&#123;    vector&lt;vector&lt;int&gt;&gt; ret = Solution().generate(5);    cout &lt;&lt; &quot; 外部打印 &quot; &lt;&lt; endl;    for (size_t i = 0; i &lt; ret.size(); ++i)    &#123;        for (size_t j = 0; j &lt; ret[i].size(); ++j)        &#123;            cout &lt;&lt; ret[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;\n\n\n使用赋值重载，就可以进行深拷贝，每一个 vector 对象都能获得新的值，也就不会出现这个问题！\n//reserve 代码的一部分for (size_t i = 0; i &lt; size(); i++)&#123;    tmp[i] = _start[i];// 手动赋值，当成员是自定义类型的时候，会调用 = 重载&#125;\n\n\n3.7 emplace_back()和 push_back()的区别emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。\n\npush_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；\n而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。\n\nemplace_back是 C++11 添加的，定义如下\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n而 C++11 中也给 push_back 提供了一个右值引用方式的重载，这时候右值的操作就会调用移动构造了；\nvoid push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); // C++11\n\n测试  在这个自定义类型中，我实现了全缺省的默认构造，以及拷贝构造和移动构造；\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class inclass &#123;public:\tinclass(int a = -10,const string&amp; info = &quot;dft&quot;) :_a(a),_str(info) &#123;\t\tcout &lt;&lt; &quot;init inclass | &quot; &lt;&lt; info &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; endl;\t&#125;\tinclass(const inclass&amp; d):_a(d._a),_str(d._str) &#123;\t\tcout &lt;&lt; &quot;init inclass copy | &quot; &lt;&lt; _str &lt;&lt; &quot; &quot; &lt;&lt;  d._a &lt;&lt; endl;\t&#125;\tinclass(const inclass&amp;&amp; d) :_a(d._a), _str(std::move(d._str)) &#123;\t\tcout &lt;&lt; &quot;init inclass copy&amp;&amp; | &quot; &lt;&lt; _str &lt;&lt; &quot; &quot; &lt;&lt; d._a &lt;&lt; endl;\t&#125;\tint _a;\tstring _str;&#125;;int main()&#123;\tvector&lt;inclass&gt; v;\tv.reserve(15);\tcout &lt;&lt; &quot; -----  &quot; &lt;&lt; endl;\tinclass tmp_copy(-1, &quot;tmp_copy&quot;);\tinclass tmp_move(-2, &quot;tmp_move&quot;);\tcout &lt;&lt; &quot; -----  &quot; &lt;&lt; endl;\tv.push_back(tmp_copy);\tv.push_back(std::move(tmp_copy));\tv.push_back(inclass(3,&quot;push back&quot;));\tv.push_back(std::move(inclass(4, &quot;push back move&quot;)));\tv.push_back(&#123; 10,&quot;push back initializer list&quot; &#125;);\t// v.push_back(15,&quot;push back direct_init&quot;); // 不支持\tcout &lt;&lt; &quot; -----  &quot; &lt;&lt; endl;\tv.emplace_back(tmp_move);\tv.emplace_back(std::move(tmp_move));\tv.emplace_back(inclass(5,&quot;emplace back&quot;));\tv.emplace_back(std::move(inclass(6, &quot;emplace back move&quot;)));\t// v.emplace_back(&#123; 20,&quot;enplace back initializer list&quot; &#125;);// 不支持\tv.emplace_back(30,&quot;enplace back direct_init&quot; );\treturn 0;&#125;\n\n最终输出结果如下，可以看到在这之前，所有的插入操作都会先构建这个临时对象，再调用移动构造来插入到 vector 中，即便采用初始化列表，也是会去构造临时对象的；因为零时对象是将亡值，所以调用的都是  移动构造。\n -----init inclass | tmp_copy -1init inclass | tmp_move -2 -----init inclass copy | tmp_copy -1init inclass copy&amp;&amp; | tmp_copy -1init inclass | push back 3init inclass copy&amp;&amp; | push back 3init inclass | push back move 4init inclass copy&amp;&amp; | push back move 4init inclass | push back initializer list 10init inclass copy&amp;&amp; | push back initializer list 10 -----init inclass copy | tmp_move -2init inclass copy&amp;&amp; | tmp_move -2init inclass | emplace back 5init inclass copy&amp;&amp; | emplace back 5init inclass | emplace back move 6init inclass copy&amp;&amp; | emplace back move 6init inclass | enplace back direct_init 30\n\n而 emplace_back 采用了完美转发，支持直接传入参数作为自定义类型的构造函数的参数，所以可以看到最后一个插入操作中只有一次构造，而没有任何拷贝构造！\n结语  到这里，vector 的模拟实现就完成啦！通过模拟实现可以让我们更好的  理解 vector 容器的结构，也方便后续的使用！\n有任何问题，都可以在评论区提出哦！\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：string","url":"/posts/1606342371/","content":"这是接触 STL 的第一篇博客，让我们以 string 为始，走入 SLT 的世界吧！\n\n\n[TOC]\n1. 何为 STLSTL 是 C++ 标准库的重要组成部分，其作用是为绝大多数数据结构提供轮子，是一个包罗了数据结构和算法的软件框架。\n在之前 C 语言的  数据结构专栏  中，顺序表、链表等等都是需要我们自己造轮子来实现。但在 C++ 中，有 STL 就好比站在了巨人的肩膀上，可以走的更远。当我们需要使用这些内容时，无需自己重新造轮子，从而大大提高了开发效率。\n1.1 STL 版本  这里我直接贴一个 C 语言中文网的链接👉【点我】\n里面详细介绍了 STL 发展历程中出现的几个版本，其中 SGI 因为被 Linux 的 GCC 所使用，可移植性高。之后的博客主要是学习 SGI STL 版本。\n\n1.2 STL 组成  同样是 C 语言中文网的资料👉【链接】，我将它整理为了下面这个思维导图\n\n在面试中，STL 的内容也是 HR 经常考察的。所以我们一定要认真学习这一部分的知识点！\n1.3 STL 的一些吐槽  如果你去 Cplusplus 网站上看过 STL 库的接口，你就会发现 STL 库的设计有些复杂。有很多地方都考虑的过于细致，导致函数接口非常多，想要全记住这些接口是有些困难的\n\n当然，这也是我自己太菜了的缘故。或许以后用的多了，这些就理所应当的记住了吧。\n同时，因为 STL 使用了模板，所以当你多次使用 STL 时（比如 vector 容器）就容易出现  代码冗余\n\n好啦，不 bb 这些没用的了，还是直接进入正题 string 类吧！\n\n\n2.String\n参考 cplusplus 的标准文档：string\n\nstring 类是表示字符串的字符串类，该类的接口和常规的容器基本相同，并添加了一些专门用于操作字符串的常规操作。使用 string 需要包含 &lt;string&gt; 和using namespace std;\n\n这里为什么是 string 而没有 .h 呢？\n其实编译器处理头文件并不会关注头文件的后缀，且 C 语言中已经有一个 string.h 了，为了避免冲突，所以使用了 &lt;string&gt; 作为头文件\n\n下面介绍一些常用的 string 类函数接口，标题中的英文和 cplusplus 网站中的分类对应\n2.1 编码格式  在Class instantiations栏目下，可以看到 string 有很多不同的类，这些类的主要区别在于  编码方式  的不同。我们主要学习的是第一个的 string 类\n\n什么是编码格式呢？在编程学习中，比较常用的便是 ASCii 码，除此之外，还有 utf-8、utf-16 等等。\n\nASII 码表中，英文单词、数字、各类标点符号都有它们对应的值，这样才能在只支持 01 二进制的电脑上显示出对应的内容。当计算机需要显示英文单词的时候，就会去查找这一个表。所以 ASCII 码表是  漂亮国  设计的。\n我们知道，英文中的基础只有 26 个单词，算上大小写也就 52 个。但是我们中华文化博大精深，计算机需要显示中文的时候，一个 char 类型的空间已经不够。所以我们需要整出一个我们自己的编码格式，以此让计算机支持显示中文——GBK就是这样一个编码格式\n\nGBK 使用两个字节来存储一个汉字，一些不常用的生僻字可能需要 3-4 个字节来存储。\n用下面这个简单的函数来测试，我们可以发现，中文中谐音字的编码是相近的\n\n在网络上，我们打某些词汇会被替换成****，就是程序在后台实别了你的编码。同时如果想进行模糊匹配，把谐音字也屏蔽掉的话，就可以把这个词周围的编码全部屏蔽了。\n\n同理，utf-16和 utf-32 为了支持别的国家的语言，就会用更长的字节来存储文字。这里不进行详解。\n\n\nstring 类有非常多的接口，我们并不需要完全掌握所有的函数接口。只需要学会常用的接口，在遇到一些不常用的，在需要使用的时候可以去查找 cplusplus 的文档。\n2.2 构造函数(constructor)\n下面是一些常用的 string 类的构造函数\n\n\n\n构造函数\n功能\n\n\n\nstring()\n空的 string 对象（空的字符串）\n\n\nstring(size_t n,char c)\nstring 类对象中包含 n 个字符 c\n\n\nstring(const char*s)\n利用常量字符串来构造对象\n\n\nstring(const string&amp;s)\n拷贝构造\n\n\n除此之外，在文档中我们还可以看到更多构造函数\n\n除此之外，我们还可以调用  赋值操作符  进行构造。下面是赋值重载的 3 个版本，想必都能看懂，是通过对象、常量字符串和字符进行赋值操作。\n\nstring 类中也重载了流提取和流插入操作符，方便我们直接对对象进行输入输出操作。\n\n\n我们还可以选取一个范围进行构造，比如下面这个\n\n需要注意的是，该构造函数的第三个传参有缺省值npos\nstring (const string&amp; str, size_t pos, size_t len = npos);\n\n查文档可以看到，nops其实是 -1，而它的类型是无符号整型，-1 就代表无符号整形的最大值。即从 pos 位置开始，往后取最大值的长度（实际上压根没有那么长的字符串）\n\n2.3 析构函数(destructor) 析构函数有个好处，就是编译器自己会进行调用，我们只需要简单了解即可。\n\n2.4 遍历 string 对象  我们可以通过下面的 3 种方式来遍历一个 string 对象\nvoid test3()&#123;\t// 尝试遍历一个 string\tstring s1(&quot;hello world!&quot;);\t//1. 重载[]\t// 通过调用成员函数 size 得知长度\tcout &lt;&lt; &quot;operator[] &quot; &lt;&lt; endl;\tfor (int i = 0; i &lt; s1.size(); i++)\t&#123;\t\tcout &lt;&lt; s1[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//2. 范围 for\t// 本质上调用的是迭代器\tcout &lt;&lt; &quot;auto &quot; &lt;&lt; endl;\tfor (auto c : s1)\t&#123;\t\tcout &lt;&lt; c &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//3. 迭代器\t// 在很多容器中是通用的\tstring::iterator it = s1.begin();// 指向开头\t//end 指向最后一个数据的下一个位置（即 &#x27;\\0&#x27;)\tcout &lt;&lt; &quot;string::iterator &quot; &lt;&lt; endl;\twhile (it != s1.end())\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t\tit++;// 使用方法类似指针\t&#125;\tcout &lt;&lt; endl;&#125;\n\n可以看到这三个方式都成功打印出了 s1 对象的完整内容\n\n其中  范围 for编译器在操作的时候是用  迭代器  来实现的，这一点通过查看汇编可以看出来\n\n2.5 operator[]和 at（Element access）上面我们用到了 operator[] 重载，需要了解的是，这个重载返回的是值的引用。也就是说，我们除了可以用这个方式来访问值的内容以外，还可以通过这种方式来改变 string 中某一个位置的值。\n\nconst string s1(&quot;hello&quot;);s1[0]=&#x27;x&#x27;// 此时调用的是 const 版本的重载，不可修改\n\nat 函数的使用方式和 [] 重载类似\n\n区别就是，当 operator[] 遇到越界情况的时候，如果相等和小于长度，都不会报错。但是当下标大于长度时，会引发  未定义行为\n\n而 at() 的处理方式是，只要长度  不小于string 的长度，就抛出异常\n\n2.6 正向和反向迭代器 Iterators除了在 2.2.3 中使用过的正向迭代器以外，string 还有一个反向迭代器rbegin\n// 反向迭代器string::reverse_iterator rit = s1.rbegin();// 指向结尾字符（&#x27;\\0&#x27; 之前）//end 指向开头数据的前一个位置while (rit != s1.rend())&#123;\tcout &lt;&lt; *rit &lt;&lt; &quot; &quot;;\trit++;// 使用方法类似指针&#125;cout &lt;&lt; endl;\n\n这里需要注意的是，虽然这个迭代器是反向的，但是我们使用的时候，依旧会 rit++ 而不是减\n\n注意，基本的迭代器是  可读可写  的。在 string 里面还实现了 const 的迭代器\nconst_iterator begin() const;const_reverse_iterator rbegin() const;\n\n如果你觉得这样写太麻烦，而且容易记不住。可以让 auto 来自动进行推导\nconst string s1(&quot;hello&quot;);auto rit = s1.rbegin();\n\nC++11 中，为了和基本的方式进行区分，新增了以 c 为前缀的 4 个迭代器。其使用和 const_iterator 是没有区别的。\n\n\n2.7 长度和容量操作 Capacity\n2.7.1 size 和 length这其中 size 和 length 的功能完全相同。只是早期 string 设计的时候以 length 作为字符串的长度。在新版本中为了和其他接口比如 List 进行同步，又新增了一个 size 来表示字符串长度。\n\n\n2.7.2 resize 和 reserve\n注意区分 reserve 和 reverse\n\n我们可以通过 reserve 对内存进行扩容操作，容量变大是因为  需要内存对齐\n\n但在实际应用中，当字符串的容量快要写满的时候，程序会自动进行扩容，大概是 1.5 倍\n\n\n而 resize 的操作是修改 string 类的长度 size，并同时进行扩容\nstring s1(&quot;hello&quot;);cout &lt;&lt; s1.capacity() &lt;&lt; endl;s1.resize(100);cout &lt;&lt; s1.capacity() &lt;&lt; endl;\n\n通过调试可以发现，这里会把 size 修改为 100，并将多余内容全部初始化为 0\n\n我们还可以给 resize 进行传参，指定初始化的内容\n\n\n同时，这两个函数一般都不会对容量进行缩容\n\n但是 resize 会修改 size 的大小，即抛弃掉 10 以后的内容，但  保持容量不变\n\n需要注意的是，在 VS2019 中（不同编译器可能不一样），reserve 如果传参小于 15，则会对容量进行缩容到 15（string 对象默认会开辟 15 个字节的 capacity）\n\n\n2.8 修改内容（Modifiers）string 可以通过很多方式来增加、删除内容\n2.8.1 尾插\n它们的基本使用如下，其中最方便的肯定是 += 操作了，又清晰又简单！\n\n2.8.2 中间插入string 并没有提供一个头插的选项，而是提供了一个Insert，可以在任何位置进行插入\n\ninsert函数的时间复杂度相对较高，因为在中间或者开头插入内容需要挪动数据。空间不够的时候还需要执行扩容操作，效率较低。\n\n2.8.3 删除  可以通过 erase 函数删除数据\n\n\n1：默认从 0 开始完全删除，可以选择从 pos 位置开始删除 len 长度的数据\n2：利用迭代器删除 p 位置的内容\n3：删除一个范围的数据，从 first 开始 last 结束\n\n这个很容易理解，在这里就不做演示了\n2.8.4 替换  这个函数使用并不频繁，其修改操作不如使用拷贝复制😂\n\n比如其中第二个函数的作用是将 str 对象 中，从 subpos 位置开始的 sublen 长度内容复制到本对象中。\n2.8.5 交换  在 string 类中有一个交换函数，同时，std 标准库里面也有一个交换函数\ns1.swap(s2);//string 类swap(s1,s2);//std 标准\n\n\n\nstring 类里面的函数是  交换类对象的指针\n而标准库里面的 swap 函数需要进行  深拷贝  交换\n\n所以 string 类里面的 swap 函数在处理对象的时候，比标准库里面的 swap 效率会高一些\n2.9 字符串操作（String operations）2.9.1 c_str这个接口的作用是返回一个字符串的指针，其主要是为了和 C 语言的一些函数对应，比如利用 strcmp 拷贝一个 string 对象到内置字符串 char arr[] 中。\n\n\n2.9.2 find这里可以看到非常多种类的查找函数（偷懒不写示例了）\n\n\nfind函数可以查找 string 中的某一个  字符或者字符串，并返回起始位置的下标\n该函数默认从头开始查找，你也可以单独指定从 pos 位置开始查找\n\n\n\n和迭代器一样，rfind则是从末尾开始找指定内容\n\n有些时候我们需要查找的内容并不是从头开始的，所以就需要从尾部开始找。\n\nsubstr 是从指定 pos 位置开始获取长度为 len 的子串\n\n\n\n2.10 很多操作符重载string 里面有非常多的操作符重载，支持和字符串、字符、对象进行大小对比。虽然看的有点麻了，但实际上它们只是方便我们使用。底层实现了解一下就可以了（我这是不是废话…）\n \n其实一部分内容都是可以通过编译器的隐式类型转化或者临时构造一个 string 类来实现的，但是设计 string 的大佬们显然觉得多即是好，哈哈。\n3. 模拟实现  要想切切实实弄明白 STL 的源码结构，其中一个最好的办法就是尝试模拟实现一个和 std 库里面 string 使用方法 &#x2F; 功能相同的  轮子。\n\n我的 string 模拟实现源码已经托管到 gitee 了【链接】\n\n其实 string 和 vector 就是一个简单的顺序表，其二者的底层差距主要在 string 只能保存字符（串），当然，内部的接口有一些细微的差距，这会在 vector 的博客里面进行讲解。\n大部分函数可以直接在 gitee 上面查看，我写了还算靠谱的注释，有任何问题可以在 gitee 或者本博客下留言。\n\n3.1 利用指针模拟实现迭代器  从 string 开始，我们第一次接触了 stl 中的迭代器这一新鲜玩意。\n// 反向迭代器string::reverse_iterator rit = s1.rbegin();// 指向结尾字符（&#x27;\\0&#x27; 之前）//end 指向开头数据的前一个位置while (rit != s1.rend())&#123;\tcout &lt;&lt; *rit &lt;&lt; &quot; &quot;;\trit++;// 使用方法类似指针&#125;cout &lt;&lt; endl;\n\n看起来很牛，实际上它的操作和我们自己写的指针大差不差。我们大可以直接使用指针来模拟实现出一个相同功能的迭代器！\n// 迭代器相关const_iterator begin() const&#123;    return _a;&#125;const_iterator end() const&#123;    return _a + _size;&#125;iterator begin()&#123;    return _a;&#125;iterator end()&#123;    return _a + _size;&#125;// 以下是 string 模拟实现中私有成员变量private:    char* _a;// 实际存放数据    size_t _size;// 有效长度    size_t _capa;// 容量大小    const static size_t npos;// 声明\n\n看吧，是不是很简单！🌃这个迭代器的使用方法和顺序表中的指针一模一样，这里就不演式啦！感兴趣的伙伴可以把源码考下来自己试试。\n\n3.2 深拷贝  在之前类和对象的博客中，我已经简单实现过一次深拷贝（链接）\n对于 string 来说，深拷贝的操作和博客里面演示的是一样的，都是通过给予新的空间，然后用 strcpy 或者 memset 拷贝内容过去。\n// 拷贝构造string(const string&amp; s)    :_size(s._size),\t_capa(s._capa)&#123;    _a = new char[_capa+1];    strcpy(_a, s._a);&#125;\n\n除了拷贝构造以外，赋值重载同样需要深拷贝操作，但是它的操作和构造函数又有些不同\n\n拷贝构造时，该对象还不存在，通过构造函数构造出内容\n赋值重载时，该对象可能已经有自己的数据，需要先释放已有的才能获取新的\n\n这就需要我们在赋值重载的时候，先 delete 掉原本的内容，再去进行赋值\n// 深拷贝赋值重载string&amp; operator=(const string&amp; s) &#123;    // 和拷贝构造不同的是，赋值重载之前，this 可能已经有自己的内容了    // 所以在执行操作之前，我们需要把 this 自己的内容先释放掉    if (this != &amp;s)// 不要自己拷贝自己     &#123;        delete[] _a;// 删除已有空间        _size = s._size;        _capa = s._capa;        //_a = new char[_capa + 1];// 有一定风险        char* tmp = new char[_capa + 1];        strcpy(tmp, s._a);        _a = tmp;    &#125;&#125;\n\n这样我们的赋值重载便也实现完毕了\n3.3 关于 insert 函数操作字符和字符串的区间问题  当我们使用 insert 来处理字符的时候，需要将插入位置之后的数据往后挪动。\n而 insert 字符串的时候，则需要挪动该字符串长度的数据。\n这时候就非常容易出现挪动不完整 &#x2F; 越界等等问题！\n关于 insert 代码可以看 gitee 代码的 190-237 行，如果你不太能理解这里的移动问题，最好的办法，就是 画图！画图会让你清楚的认识到需要移动多长，指针应该指向哪里进行移动。理清思路后，写代码就会容易很多。\n3.4 关于 push_back 的边界控制问题  之前我实现的代码中，尾插的时候没有加上 \\0 进行边界控制\n这一点需要注意，因为模拟实现的底层用的就是 C 语言的字符串。在每一次尾插之后，都需要用 \\0 来标记字符串的结尾。否在我们拷贝构造和 reserve 的时候使用 strcpy 就会出现越界错误。\n\n越界错误一般都是在析构 delete 的时候检查出来的\n\nvoid push_back(char ch)&#123;\tif (_size + 1 &gt;= _capa)\t&#123;\t\treserve(_capa == 0 ? 4 : _capa * 2);\t\t// 这里的判断是为了辨别是否在空对象尾插\t&#125; \t_a[_size] = ch;\t_size++;\t// 因为 reserve 和基础的拷贝构造用的都是 strcpy\t// 所以必须要有 \\0 来标识结尾！\t_a[_size] = &#x27;\\0&#x27;;&#125;\n\n\n结语  关于 string 类 的介绍到这里就结束啦！\n如果有什么新增内容的话，我会对本篇博客进行修改\n\n如果有什么问题，欢迎评论区提出哦！\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：list","url":"/posts/1456870854/","content":"阿巴阿巴，list 的博客来喽！\n\n\n[TOC]\n1.list 是嘛玩意？之前的 vector 是一个顺序表。总所周知，学完顺序表肯定不能不学链表，所以 list 就来了！\n\nlist 是一个可以在任何地方进行插入删除的序列式容器，可以进行前后双向迭代\n\n说人话就是：list 是一个  双向带头循环链表\n\n这不巧了嘛！之前我写过用 C 语言实现  双向带头循环链表的博客\n其优缺点也很明显\n\n支持快速插入删除O(1)\n支持前后双向迭代访问\n不支持任意位置的随机访问\n\nSTL 中的 list 也满足上面的这些优缺点\n话不多说，来看看 list 的函数接口吧！\n\nhttps://m.cplusplus.com/reference/list/list/\n\n函数接口  大部分接口和前面所学的两个容器都是一样的啦，这里就不贴完整截图了（见上方链接）\n\n这里还多了一个emplace_front，看完函数解释后可知它也是一个头插\n\n2. 简单了解使用2.1 构造list 支持的构造函数如下\n\n这些函数和 vector 完全一致，这里就不过多介绍了\n\n2.2 迭代器\n\n\n迭代器\n说明\n\n\n\nbegin+end\n获取第一个数据位置 iterator&#x2F;const_iterator， 获取最后一个数据的下一个位置 iterator&#x2F;const_iterator\n\n\nrbegin+rend\n获取最后一个数据位置的 reverse_iterator，获取第一个数据前一个位置的 reverse_iterator\n\n\n都是老样子，没有啥好说的\n\n除了迭代器以外，一般的容器都会提供 front 和back两个参数来访问头部 &#x2F; 尾部数据。但是我们并不常用这个，迭代器用的更多一些\n2.3 长度操作  库函数中给我们提供了两个和 list 长度相关的操作，因为是链表，所以也不存在扩容问题，每一个节点都是一个独立的空间\n\n\nempty 判断是否为空，是空返回 true\nsize 计算 list 中有效数据长度\n\n关于插入和删除操作，list 和 vector/string 基本都是一致的，学会一个基本都会用！\n2.4 迭代器失效问题  和 vector 一样，list 也会遇到一定程度的迭代器失效问题。\n因为 list 是一个链表，其在插入操作的时候是在迭代器所指  节点前一个位置  进行插入，不会影响该节点和这个节点之后的结构，也不会导致迭代器失效。\n\n只有在  删除  的时候才会导致迭代器失效\n\n解决办法也很简单，使用迭代器删除数据的时候，接收返回值更新一下迭代器即可！\n\n基本了解了函数接口后，让我们来试试模拟实现吧！\n3. 模拟实现\n模拟实现和 STL-list 源码见我的Gitee\n\n下图是之前 C 语言版本链表博客里，我画的  双向带头循环链表  的结构图\n\nlist 的结构和这个图片是一样的。但因为我们现在所使用的是 C++ 中的类和对象，所以我们的操作都需要尊崇 stl 库的命名规则和使用方法，其结构的实现也会有所不同。\n比如在 STL 源码中可以看到，list 的主结构中只有一个node，即头节点。\n\n3.1 节点结构  在 list 中，我们不直接在 list 主类中放入单个节点的结构，而是使用一个自定义类型作为节点。\n\n复习：在 struct 中，成员默认是共有\n\ntemplate&lt;class T&gt;   struct list_node   &#123;       list_node&lt;T&gt;* _next;       list_node&lt;T&gt;* _prev;       T _data;       list_node(const T&amp; val = T())           :_next(nullptr),       \t_prev(nullptr),       \t_data(val)       &#123;&#125;   &#125;;\n\n这样后面的插入删除操作就可以直接 new 一个新的 node，并调用构造函数完成 _data 的赋值。\n在 list 的主类中，我们遵循库的方法，只用一个头节点的指针作为成员\nprivate:\tNode* _head;// 头节点指针\n\n\n3.2 插入删除  因为之前写过 C 语言的代码，关于插入和删除操作相对较为熟练，代码如下👇\n// 在 pos 之前插入iterator insert(iterator pos, const T&amp; x)&#123;    Node* newnode = new Node(x);    Node* cur = pos._node;    newnode-&gt;_next = cur;    cur-&gt;_prev-&gt;_next = newnode;    newnode-&gt;_prev = cur-&gt;_prev;    cur-&gt;_prev = newnode;    return iterator(newnode);&#125;// 删除 pos 位置iterator erase(iterator pos)&#123;    assert(_head-&gt;_next != _head &amp;&amp; pos._node!=_head);    Node* next = pos._node-&gt;_next;    Node* prev = pos._node-&gt;_prev;    prev-&gt;_next = next;    next-&gt;_prev = prev;    delete pos._node;    return iterator(next);&#125;\n\n而头插 &#x2F; 头删 &#x2F; 尾插 &#x2F; 尾删这类方法，我们直接复用 insert 和 earse 即可！\n\n\n3.3 迭代器（重要）在上面的插入和删除代码中，我已经使用了迭代器作为参数和返回值。由于 list 的主类中并没有直接存放 3.1 节点结构，我们需要自己单独完成一个迭代器的类，来实现迭代器的相关操作\n\nvector&#x2F;string 是顺序表，迭代器可以直接用指针替代，在本类中模拟实现\nlist 是顺序表，迭代器的 + 和 - 操作其实是通过 next 和prev指针往后往前找内容，所以需要单独的模拟实现\n\n在 STL 源码中的 list 也是单独重载了一个迭代器类\n\n其基本结构如下\ntemplate&lt;class T, class Ref, class Ptr&gt;struct __list_iterator&#123;    typedef list_node&lt;T&gt; Node;// 节点结构    typedef __list_iterator&lt;T, Ref, Ptr&gt; self;// 本类    Node* _node;// 存放节点指针        __list_iterator(Node* node)\t\t:_node(node)\t&#123;&#125;&#125;\n\n这里解释一下为何有 3 个模板参数：ref 指代引用，ptr 指代指针\n因为在后续的操作中我们需要传入 T 的引用 T&amp; 和指针T*，如果之传入一个T，编译器无法确认是否为 const 类型，也就无法阻止用户使用迭代器修改值，成员的数据就不够安全，且 const 的成员函数无法调用迭代器。\n重载 3 个模板参数后，我们就可以用传入的模板参数来控制指针和引用是否为 const 类型\ntypedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;typedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n\n基本的结构弄清楚之后，下面一起来看看，迭代器的 ++ 和 --，解引用以及指针-&gt; 分别对应了链表的什么操作呢？\n3.3.1 加减  好吧，前面已经提到过了，我们需要用 \tnext/prev 指针来完成加减操作\n// 前置 ++self&amp; operator++()&#123;    _node = _node-&gt;_next;    return *this;&#125;// 后置 ++self operator++(int)&#123;    //self 是本类的别名，因为没有重载 = 操作符    // 所以不能使用相等，要用构造函数    //self tmp = _node;    self tmp(*this);    _node = _node-&gt;_next;    return tmp;&#125;// 前置 --self&amp; operator--()&#123;    _node = _node-&gt;_prev;    return *this;&#125;// 后置 --self operator--(int)&#123;    self tmp(*this);    _node = _node-&gt;_prev;    return tmp;&#125;\n\n注意前置和后置的区别，后置加减需要先用一个 tmp 变量储存原本的迭代器位置，再让迭代器指向下一个节点\n而当我们解引用迭代器的时候，想获取的其实是 _data 的值，而不是节点的地址（这里迭代器依旧是用指针模拟的）\n3.3.2 解引用和指针操作  所以重载后的解引用操作如下\nRef operator*()&#123;    return _node-&gt;_data;// 返回值的引用&#125;Ptr operator-&gt;()&#123;    return &amp;(_node-&gt;_data);// 返回地址&#125;\n\n3.3.3 判断相等 &#x2F; 不相等  最后判断相等和不相等就很简单了，因为本身就是指针，我们直接调用原生的 != 进行判断即可\nbool operator!=(const self&amp; it)&#123;    return _node != it._node;&#125;bool operator==(const self&amp; it)&#123;    return _node == it._node;&#125;\n\n到这里，一个建议版本的正向迭代器我们就实现啦！\n\n3.3.4 begin&#x2F;end这里我们需要在 List 的本类中获取迭代器的 begin 和end，这里我们是调用了迭代器的构造函数，构造出来一个迭代器并进行返回\nconst_iterator begin() const&#123;    //return _head-&gt;_next;// 不能直接返回指针！！    return const_iterator(_head-&gt;_next);&#125;const_iterator end() const&#123;    return const_iterator(_head);&#125;iterator begin()&#123;    return iterator(_head-&gt;_next);&#125;iterator end()&#123;    return iterator(_head);&#125;\n\n现在就可以愉快的用迭代器进行打印操作了！\n\n\n3.4 构造函数  有了迭代器，现在就可以完成库函数里面的几个构造函数了（主要是迭代器区间的那个函数）\n默认构造函数如下，先创建一个头节点，再让它的前后都指向自己。在 C 语言的初始化函数中，我们也是这么做的\nlist()   \t:_head(nullptr)   &#123;       //_head = new Node;       _head = new Node();       _head-&gt;_next = _head;       _head-&gt;_prev = _head;   &#125;\n\n但其他的构造函数由于 _head 为空，所以我们需要单独实现一个空初始化函数来创建头节点\n// 当使用其他构造函数的时候，head 还不存在，需要手动构造一个void empty_init()&#123;    _head = new Node();    _head-&gt;_next = _head;    _head-&gt;_prev = _head;&#125;\n\n当然，上面那个空的构造函数 list() 也可以复用empty_init()，这样代码更整洁\n迭代器区间构造和 vector 是一样的，其主要是解引用后直接将值进行头插（这里就用上了之前迭代器里重载的解引用操作）\ntemplate &lt;class InputIterator&gt;list(InputIterator first, InputIterator last)&#123;    empty_init();    InputIterator cur = first;    while (cur != last)    &#123;        //push_back(cur._node-&gt;_data);        push_back(*cur);        cur++;    &#125;&#125;\n\n而拷贝构造就可以直接复用迭代器区间构造，赋值重载就直接 swap 即可。这部分的实现和 vector 是一样的，有问题可以在评论区提出哦！\nvoid swap(list&lt;T&gt;&amp; lt)&#123;    std::swap(_head, lt._head);&#125;list(const list&lt;T&gt;&amp; lt)&#123;    empty_init();    list tmp(lt.begin(), lt.end());    swap(tmp);&#125;list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt)&#123;    // 传参没有传引用，lt 已经是拷贝构造之后的结果了    // 完全没必要再用 tmp 拷贝构造一次    //list&lt;T&gt; tmp(lt);    //clear();// 因为 tmp 出了生命周期后会销毁，所以不需要手动 clear    swap(lt);    return *this;&#125;\n\n\n3.5 析构函数  因为链表需要我们一个一个去  删除每一个节点的空间 ，这里需要单独实现一个clear 函数供析构函数使用\nvoid clear()&#123;    //assert(_head-&gt;_next != _head);    iterator it = begin();    while (it != end())    &#123;        // 需要用一个临时变量储存该节点的迭代器，避免迭代器失效        iterator its = it;        it++;        delete its._node;    &#125;&#125;~list()&#123;    clear();    delete _head;&#125;\n\n上面这个函数就有些麻烦，我们其实可以直接复用 erase 进行删除操作 + 更新迭代器！\nvoid clear()&#123;    iterator it = begin();    while (it != end())    &#123;        it = erase(it);    &#125;&#125;\n\n到这里，一个基本的 list 就模拟实现完成了！\n3.6 操作自定义类型  我们刚刚实现的 list 和 STL 库中的一样，都可以存放自定义类型\nstruct TA&#123;\tTA(int a1 = 0, int a2 = 0)\t\t:_a1(a1),\t\t_a2(a2)\t&#123;&#125;\tint _a1;\tint _a2;&#125;;void test03()&#123;\tlist&lt;TA&gt; lt;\tlt.push_back(TA(1, 1));\tlt.push_back(TA(2, 2));\tlt.push_back(TA(3, 3));\tlt.push_back(TA(4, 4));\t// 这里因为 TA 类的流插入没有重载，所以需要我们手动写\tlist&lt;TA&gt;::iterator it = lt.begin();\twhile (it != lt.end())\t&#123;\t\tcout &lt;&lt; it-&gt;_a1 &lt;&lt; &quot;-&quot; &lt;&lt; it-&gt;_a2 &lt;&lt; &quot; &quot;;\t\t++it;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n但在打印和访问自定义类型的时候，我们重载的解引用操作符就不能用了，这就是为啥要重载 -&gt; 操作符，此时我们还可以通过 -&gt; 获取到迭代器  所指的对象的成员，这时候直接打印成员变量即可！\n\n你可能觉得，这不对啊！之前重载的这个操作符不是返回的节点 _data 的地址吗？为啥可以直接访问 _data 的成员？\nPtr operator-&gt;()&#123;    return &amp;(_node-&gt;_data);// 返回地址&#125;\n\n实际上，这里应该是it-&gt;-&gt;_a1，但是编译器在处理的时候直接将两个访问箭头简化成了一个，即增加了代码可读性，也方便使用了！\n\n3.7 反向迭代器（适配问题）关于反向迭代器，这里牵扯到一个更深的适配问题。我用我的笨话稍微解释一下，有问题或者有啥错误的话欢迎在评论区提出！😂\n我们知道，反向迭代器是从后往前走的，它的加减操作和正向迭代器相反。\n那么比起单独实现一个反向迭代器的类，我们可否利用正向迭代器，直接适配出一个反向迭代器呢？毕竟看起来它们只有方向不同！\n3.7.1 显式规定模板参数 Ref 和 Ptrtemplate&lt;class Iterator, class Ref, class Ptr&gt;struct Reverse_iterator&#123;\tIterator _it;\ttypedef Reverse_iterator&lt;Iterator, Ref, Ptr&gt; Self;              Reverse_iterator(Iterator it)\t\t:_it(it)\t&#123;&#125;   &#125;;\n\n说上就上，这里我们先将反向迭代器设定为和正向相似的结构，不过它的模板参数变成了  正向迭代器 ，而不是参数类型 T，这在后续typdef 的时候需要注意（不然会报错）\n除了下面的解引用操作之外，其他只需要吧正向迭代器反过来用，就可以达到我们的目的！\nRef operator*()&#123;    Iterator tmp = _it;    return *(--tmp);// 反向迭代器解引用访问的是前一个位置的数据&#125;Ptr operator-&gt;()&#123;    return &amp;(operator*());&#125;\n\n解引用访问前一个数据的原因是，我们判断结束是用 !=rend()，而rend() 指向的是列表的第一个有效数据，如果直接解引用当前内容，最后一个数据就无法访问到，出现了缺漏\n\n// 前置 ++Self&amp; operator++()&#123;    --_it;    return *this;&#125;// 前置 --Self&amp; operator--()&#123;    ++_it;    return *this;&#125;bool operator!=(const Self&amp; s)&#123;    return _it != s._it;&#125;\n\n更加完整的源码可以去看我的 Gitee 仓库哦！\n\n完成了上面的代码后，我们需要在 list 本类里面进行一波操作，让它能够支持反向迭代器\n// 支持反向迭代器typedef Reverse_iterator&lt;iterator, T&amp;, T*&gt; reverse_iterator;typedef Reverse_iterator&lt;const_iterator, const T&amp;, const T*&gt; const_reverse_iterator;\n\n注意上面的模板参数，第一个模板参数需要传入正向迭代器，而不是T\n// 调用反向迭代器的构造函数reverse_iterator rbegin()&#123;    return reverse_iterator(end());&#125;reverse_iterator rend()&#123;    return reverse_iterator(begin());&#125;const_reverse_iterator rbegin()const&#123;    return const_reverse_iterator(end());&#125;const_reverse_iterator rend()const&#123;    return const_reverse_iterator(begin());&#125;\n\n用一个打印代码便可以测试出我们的操作是否正确！\n可以看到，完美逆向打印出了内容！\n\n利用正向迭代器进行适配的最大好处，那就是其他模拟实现的容器也可以直接调用这个反向迭代器，只要在本类中加入上面的 typedef 和 4 个函数即可！\n就以上篇博客的 vector 为例，加上上述代码后，她也能支持反向迭代器了！（源码也上传到仓库里面了）\n\n3.7.2 调用正向迭代器中的类型  除了在反向迭代器的模板定义中直接定义反向迭代器中 Ref/Ptr 这两个参数类型，还可以从正向迭代器中去取出来这两个参数的类型；\n首先需要在正向迭代器 __list_iterator 中新增如下两个 typedef\n// 为了让反向迭代器能统一获取到 Ref 和 Ptr，标准库中的迭代器都定义了这两个 typedeftypedef Ptr pointer;typedef Ref reference; \n\n能看到 stl 的 list 迭代器源码中同样存在这两个typedef\n\n随后在反向迭代器中，可以按下下面的方式写来取出正向迭代器中的类型\ntemplate&lt;class Iterator, class Ref, class Ptr&gt;struct Reverse_iterator&#123;\tIterator _it;\ttypedef Reverse_iterator&lt;Iterator, Ref, Ptr&gt; Self;\tReverse_iterator(Iterator it)\t\t:_it(it)\t&#123;&#125;\t// 从正向迭代器里面取迭代器中 Ref 和 Ptr 的类型\tIterator::reference operator*()\t&#123;\t\tIterator tmp = _it;\t\treturn *(--tmp);// 反向迭代器解引用访问的是前一个位置的数据\t&#125;\tIterator::pointer operator-&gt;()\t&#123;\t\treturn &amp;(operator*());\t&#125;&#125;\n\n在 list 的主体中，还需要将反向迭代器的定义修改为如下形式\n// 支持反向迭代器typedef Reverse_iterator&lt;iterator&gt; reverse_iterator;typedef Reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;\n\n此时直接执行 g++ 进行编译，会报错如下内容，说让我们在类型前面添加一个typename；\n\n这是我们第二次遇到 typename 关键字，上一次遇见是在模板中的模板参数声明。\n在这里 typename 的作用是告诉编译器 Iterator::reference 是一个类型，需要等正向迭代器 Iterator 的这个模板类成功实例化了之后，再去查看这个参数的类型是什么。如果不加上这个关键字，编译器会立马去康这个参数的类型，结果发现这玩意是个模板参数，压根没办法知道类型是什么，那就只能给你报错了。 \ntypename Iterator::reference operator*()&#123;\tIterator tmp = _it;\treturn *(--tmp);// 反向迭代器解引用访问的是前一个位置的数据&#125;typename Iterator::pointer operator-&gt;()&#123;\treturn &amp;(operator*());&#125;\n\n加上 typename 后重新编译，此时就没有出现报错了。\n\n// 通过迭代器打印链表\tvoid print_list(list&lt;int&gt;&amp; s)\t&#123;\t\tlist&lt;int&gt;::iterator it = s.begin();\t\twhile (it != s.end())\t\t&#123;\t\t\t//*it = 10;// 使用非 const 迭代器的时候可以修改值\t\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t\t\tit++;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;\tvoid R_print_list(list&lt;int&gt;&amp; s)\t&#123;\t\tlist&lt;int&gt;::reverse_iterator it = s.rbegin();\t\twhile (it != s.rend())\t\t&#123;\t\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t\t\tit++;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;\tvoid test01()\t&#123;\t\tlist&lt;int&gt; s1;\t\ts1.push_back(1);\t\ts1.push_back(2);\t\ts1.push_back(3);\t\ts1.push_back(4);\t\tprint_list(s1);\t\tR_print_list(s1);    &#125;\n\n执行一下测试代码，能看到其成功实现了正向迭代器和反向迭代器的使用操作。\n$ ./test1 2 3 4 4 3 2 1 \n\n我们还可以在反向迭代器中再进行一层 typedef，将正向迭代器中的类型改个名字。在typedef 中同样需要加上typename\ntemplate&lt;class Iterator&gt;struct Reverse_iterator&#123;\tIterator _it;\t//typedef Reverse_iterator&lt;Iterator, Ref, Ptr&gt; Self;\ttypedef Reverse_iterator&lt;Iterator&gt; Self;\t// 再进行一层 typedef（同样需要带上 typename）\ttypedef typename Iterator::reference reference;\ttypedef typename Iterator::pointer pointer;\tReverse_iterator(Iterator it)\t\t:_it(it)\t&#123;&#125;\t// https://lsky.musnow.top/l/i/2023/07/64c3793f061fc.png\t// 从正向迭代器里面取迭代器中 Ref 和 Ptr 的类型\treference operator*()\t&#123;\t\tIterator tmp = _it;\t\treturn *(--tmp);// 反向迭代器解引用访问的是前一个位置的数据\t&#125;\tpointer operator-&gt;()\t&#123;\t\treturn &amp;(operator*());\t&#125;       // 其他部分和 3.7.1 是相同的   &#125;\n\n编译成功，无报错\n\n\n3.7.1中的方式 vector 同样可以使用，但 vector 是不能使用 3.7.2 里面的这种方式来进行反向迭代器的适配的。\n这是因为在自主实现 vector 的操作中，我们使用了原生的类型指针来作为迭代器；此时我们是没有办法在指针（内置类型）里面定义 typedef Ptr pointer 的，也就没有办法获取到这个迭代器的指针和引用的类型，自然也就没有办法使用 typename 的方式让编译器来帮我们推测反向迭代器中 Ptr/Ref 的类型了。\ntemplate&lt;class T&gt;\tclass vector\t&#123;\tpublic:\t\ttypedef T* iterator;\t\ttypedef const T* const_iterator;\t\t// 支持反向迭代器\t\ttypedef Reverse_iterator&lt;iterator, T&amp;, T*&gt; reverse_iterator;\t\ttypedef Reverse_iterator&lt;const_iterator, const T&amp;, const T*&gt; const_reverse_iterator;    \t//...    &#125;\n\n要想解决这个问题，有三种解决办法\n\n和 list 的自主实现一样，不使用内置类型，而是再制作一个自定义类型作为 vector 的迭代器\n而 STL 中使用了一个较为复杂的解决办法，即  特化  和萃取（这两个有点难理解，会在模板的进阶博客中说明）\n参考 3.7.1，在反向迭代器的模板参数填入Ref/Ptr 这两个模板参数\n\n3.7.3 typename上文中提到，typename是用于告知编译器该参数名是一个类型，需要在模板实例化之后再去查看具体的类型是什么。下面是一个简单的测试用例来复现这个场景\n#include&lt;iostream&gt;#include&lt;list&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;void print_list(const list&lt;T&gt;&amp; lt)&#123;\tlist&lt;T&gt;::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;template&lt;class Container&gt;void print_container(const Container&amp; lt)&#123;\tContainer::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;void test_print_list()&#123;\tlist&lt;int&gt; lt1;\tlt1.push_back(1);\tlt1.push_back(2);\tlt1.push_back(3);\tlt1.push_back(4);\tprint_list(lt1);\tprint_container(lt1);\tlist&lt;string&gt; lt2;\tlt2.push_back(&quot;a&quot;);\tlt2.push_back(&quot;b&quot;);\tlt2.push_back(&quot;c&quot;);\tlt2.push_back(&quot;d&quot;);\tprint_list(lt2);\tprint_container(lt2);&#125;\n\n上面代码中的两个函数，都尝试直接获取了模板类型中的 const_iterator 迭代器作为 cit 参数的类型，直接编译会出现如下的报错\n$ g++ test.cpp -o test -std=c++11test.cpp: In function ‘void print_list(const std::__cxx11::list&lt;T&gt;&amp;)’:test.cpp:11:2: error: need ‘typename’ before ‘std::__cxx11::list&lt;T&gt;::const_iterator’ because ‘std::__cxx11::list&lt;T&gt;’ is a dependent scope  list&lt;T&gt;::const_iterator cit = lt.begin();  ^~~~~~~test.cpp:11:25: error: expected ‘;’ before ‘cit’  list&lt;T&gt;::const_iterator cit = lt.begin();                         ^~~~                         ;test.cpp:12:9: error: ‘cit’ was not declared in this scope  while (cit != lt.end())         ^~~test.cpp: In function ‘void print_container(const Container&amp;)’:test.cpp:23:2: error: need ‘typename’ before ‘Container::const_iterator’ because ‘Container’ is a dependent scope  Container::const_iterator cit = lt.begin();  ^~~~~~~~~test.cpp:23:27: error: expected ‘;’ before ‘cit’  Container::const_iterator cit = lt.begin();                           ^~~~                           ;test.cpp:24:9: error: ‘cit’ was not declared in this scope  while (cit != lt.end())         ^~~test.cpp: In instantiation of ‘void print_list(const std::__cxx11::list&lt;T&gt;&amp;) [with T = int]’:test.cpp:40:16:   required from heretest.cpp:11:2: error: dependent-name ‘std::__cxx11::list&lt;T&gt;::const_iterator’ is parsed as a non-type, but instantiation yields a type  list&lt;T&gt;::const_iterator cit = lt.begin();  ^~~~test.cpp:11:2: note: say ‘typename std::__cxx11::list&lt;T&gt;::const_iterator’ if a type is meanttest.cpp: In instantiation of ‘void print_container(const Container&amp;) [with Container = std::__cxx11::list&lt;int&gt;]’:test.cpp:41:21:   required from heretest.cpp:23:2: error: dependent-name ‘Container::const_iterator’ is parsed as a non-type, but instantiation yields a type  Container::const_iterator cit = lt.begin();  ^~~~~~~~~test.cpp:23:2: note: say ‘typename Container::const_iterator’ if a type is meanttest.cpp: In instantiation of ‘void print_list(const std::__cxx11::list&lt;T&gt;&amp;) [with T = std::__cxx11::basic_string&lt;char&gt;]’:test.cpp:49:16:   required from heretest.cpp:11:2: error: dependent-name ‘std::__cxx11::list&lt;T&gt;::const_iterator’ is parsed as a non-type, but instantiation yields a type  list&lt;T&gt;::const_iterator cit = lt.begin();  ^~~~test.cpp:11:2: note: say ‘typename std::__cxx11::list&lt;T&gt;::const_iterator’ if a type is meanttest.cpp: In instantiation of ‘void print_container(const Container&amp;) [with Container = std::__cxx11::list&lt;std::__cxx11::basic_string&lt;char&gt; &gt;]’:test.cpp:50:21:   required from heretest.cpp:23:2: error: dependent-name ‘Container::const_iterator’ is parsed as a non-type, but instantiation yields a type  Container::const_iterator cit = lt.begin();  ^~~~~~~~~test.cpp:23:2: note: say ‘typename Container::const_iterator’ if a type is meant\n\n取其精华，能看到最主要的报错是 ‘cit’ was not declared in this scope，意思是 cit 这个变量在当前作用域中没有声明。\n这不就很奇怪了，明明我已经声明了这个参数了呀，还给他赋值了！\n原因前面便提到过了，这是因为编译器没有办法推测出这两个模板参数在未实例化之前的变量类型，此时可以理解为这个模板中的类型是一个虚拟类型，并非真实确定了的参数类型。最终就导致 cit 参数看似实例化了，实际上并没有。\n// cit 变量到底是什么类型？不知道！Container::const_iterator cit = lt.begin();list&lt;T&gt;::const_iterator cit = lt.begin();\n\n我们要做的就是给这两个变量的声明都加上 typename 的关键字\ntemplate&lt;class T&gt;void print_list(const list&lt;T&gt;&amp; lt)&#123;\ttypename list&lt;T&gt;::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;template&lt;class Container&gt;void print_container(const Container&amp; lt)&#123;\ttypename Container::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n此时编译和运行都成功了。\n[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ g++ test.cpp -o test -std=c++11[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ ./test1 2 3 4 1 2 3 4 a b c d a b c d \n\n当然，如果我们类模板的参数类型的确定的，那就不需要有 typename 关键字；比如下方 list 已经确定是 int 类型了，那么迭代器的类型自然也是可以被确定下来的。\nvoid print_list_int(const list&lt;int&gt;&amp; lt)&#123;\tlist&lt;int&gt;::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n编译无报错\n[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ g++ test.cpp -o test -std=c++11[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$\n\n当然，使用 auto 关键字也是可以的的，不会报错，也不需要带上 typename；这是因为auto 已经告诉了编译器这里是一个参数类型，只需要在 lt.begin() 返回的时候，根据返回值的参数来取 cit 变量的参数类型就可以了。\ntemplate&lt;class T&gt;void print_list_auto(const list&lt;T&gt;&amp; lt)&#123;\tauto cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n测试一下\nvoid test_print_list()&#123;\tlist&lt;int&gt; lt1;\tlt1.push_back(1);\tlt1.push_back(2);\tlt1.push_back(3);\tlt1.push_back(4);\tprint_list(lt1);\tprint_list_int(lt1);\tprint_list_auto(lt1);\tprint_container(lt1);&#125;\n\n结果\n[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ g++ test.cpp -o test -std=c++11[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ ./test1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 \n\n我们要记住的是：只要从未实例化的类模板中取参数类型，都需要加上 typename 关键字来指定！\n结语  本次 list 的模拟实现，我们尝试模拟了一个更加详细的迭代器类，并实现了  反向迭代器\n有任何问题，或者本博客有错误，都欢迎在评论区提出哦！\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：stack/queue/priority_queue/deque","url":"/posts/3750929351/","content":"来喽，STL 的栈和队列！\n\n\n[TOC]\n1.Stack栈是一个遵循 LIFO 规则的容器，即后进先出（last in first out）。后放入容器内的数据会先出来。\n\n如果你不太理解栈的性质，可以先看看我写的 C 语言栈的博客【链接】\n\n打开 Cplusplus 一看，栈的函数肉眼可见的少。这和我们 C 语言实现的功能基本是一样的。\n\n它甚至没有拷贝构造！\n\n1.1 容器适配器  等会，这个 container 是什么玩意？\n别急，先让我们来看看栈的类定义👇\nstd::stacktemplate &lt;class T, class Container = deque&lt;T&gt; &gt; class stack;\n\n和之前不同的是，这里出现了container，和一个我们好像没有接触过的deque\n搜索后得知，deque也是一种容器，被称为  双端队列\n\n\n那么栈为什么需要一个容器呢？\n\n实际上，栈不是直接写出来的代码，而是借用了 deque 这个容器，进行封装后的结果。\n意思就是，栈其实是解用了别人的代码！\n比如 deque 有头插头删，尾插尾删。而我们的栈只需要尾插尾删，那么我们包装一下 deque，只提供尾插尾删的函数，不就成了栈了？\n\n1.2 模拟实现  直接这么说可能有点干巴巴，我们直接上代码！\ntemplate&lt;class T, class Container = deque&lt;T&gt;&gt;class stack &#123;public:\tsize_t size()const &#123;\t\treturn _con.size();\t&#125;\t\tconst T&amp; top() &#123;\t\treturn _con.back();\t&#125;\tvoid push(const T&amp; val) &#123;\t\t_con.push_back(val);\t&#125;\tvoid pop() &#123;\t\t_con.pop_back();\t&#125;\tbool empty() &#123;\t\treturn _con.empty();\t&#125;private:\tContainer _con;&#125;;\n\n以上便是栈的模拟实现代码！\nWhat？这就结束了？——甚至写的比我们 C 语言版本的栈更少！\n\n本质上，我们只需要创建一个 Container 的对象 _con，再借助这个对象的函数进行封装，就完成了一个栈！\n因为模板里面默认传入的是 deque，所以这里用的便是deque 的函数了。这就好比函数传入了一个  缺省值 。你可以将deque 换成其他有尾插尾删函数的容器，比如vector\n测试一下，莫得问题！\n\n\n2.queue和栈不同，队列遵循FIFO，即先进先出（first in first out）\n\n同样的，我们只需要包装一下容器，即可完成模拟实现\nstd::queuetemplate &lt;class T, class Container = deque&lt;T&gt; &gt; class queue;\n\n2.1 模拟实现template&lt;class T, class Container = deque&lt;T&gt;&gt;class queue &#123;public:\tsize_t size()const&#123;\t\treturn _con.size();\t&#125;\tconst T&amp; front()&#123;\t\treturn _con.front();\t&#125;\tconst T&amp; back()&#123;\t\treturn _con.back();\t&#125;\tvoid push(const T&amp; val)&#123;\t\t_con.push_back(val);\t&#125;\tvoid pop()&#123;\t\t_con.pop_front();\t&#125;\tbool empty()&#123;\t\treturn _con.empty();\t&#125;private:\tContainer _con;&#125;;\n\n需要注意的是，队列就不能用 vector 来当作容器辣！因为 vector 头插删的效率很低，需要挪动数据。我们可以使用 list 来当作容器\n\n当然，你可以把头插头删改成 insert 和 erase，但是那样没有意义，依旧拖慢了效率\n因为栈和队列压根不支持迭代器，自然也没有迭代器失效问题！\n2.2 关于 queue 的 front学习 linux 课程的时候，突然想到一个问题，如果 queue 里面是空的，那么我直接访问 front 会是什么情况？会出现异常吗？\n#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123;    printf(&quot;hello vscode!\\n&quot;);    queue&lt;int&gt; q;// 不会报错，但是数据无效    cout &lt;&lt; q.front() &lt;&lt; endl;    return 0;&#125;\n\n在 linux 下用 g++ 编译运行，发现获取到的值是 0\n[muxue@bt-7274:~/git/test]$ ./testhello vscode!0\n\n简单概括，如果队列中没有数据，此时调用 front 接口不会报错，但是获取到的数据是无效的。\n个人猜测，这里能否获取到数据也和编译器的优化有关。比如相同的代码，在 vs2019 下，会直接报 assert 错误！\n\n所以，为了代码的兼容性，请严格检查调用 front 的时候队列里面有没有数据，stack 的 top 同理\n\n了解完相对简单的栈和队列之后，我们可以直接来看看优先级队列\n3.priority_queue 优先级队列  优先级队列和 queue 同属于头文件&lt;queue&gt;\ntemplate &lt;class T, class Container = vector&lt;T&gt;,  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;\n\n\n那么它和普通的队列有什么不同呢？\n\n优先级队列是一个  堆，且  默认是大堆\n\n如果你不知道堆是什么，可以看看我之前 C 语言数据结构的博客【链接】\n\n简单说来，堆的堆顶（这里是第一个数据）一直保持着最大值或者最小值。每一次插入、删除操作，都需要向上、向下重新调整容器内元素的位置\n3.1 make_heap这里简单说一下另外一个函数make_heap，这个函数可以通过迭代器区间，将区间内的数据调整为一个堆。\n\n在文档介绍里面可以看到，最后一行提到了优先级队列就是自动调用 make_heap 函数来维护自己堆的属性的\n\n3.2 函数接口  优先级队列本质上还是一个队列，它提供的函数也很少\n不同的是，这里的 top 堆顶指的是容器中首个元素，pop也是移除堆顶元素\n\n3.3 仿函数\n注意这里出现了第三个模板参数，Compare\n这是一个仿函数，其就是一个类，但是仿照了函数的调用方式\n想做到这一点，我们需要重载 () 操作符\n// 仿函数，重载（）操作符\ttemplate&lt;class T&gt;\tstruct less &#123;\t\tbool operator()(const T&amp; a, const T&amp; b)const\t\t&#123;\t\t\treturn a &lt; b;\t\t&#125;\t&#125;;\t// 大于比较\ttemplate&lt;class T&gt;\tstruct greater&#123;\t\tbool operator()(const T&amp; a, const T&amp; b)const\t\t&#123;\t\t\treturn a &gt; b;\t\t&#125;\t&#125;;\n\n比如这里的 less 和greater就是两个仿函数，优先级队列需要用它来进行比较。这样我们就可以快速在大堆和小堆直接进行切换。\n它们的使用方式和函数是一样的！不过在使用之前，我们需要先创建一个对象\nless func;func(1,2);\n\n库函数中的 less 和 greater 都在 &lt;functional&gt; 这个头文件中\n\n\nstd 库中优先级队列默认传的 less 小于比较，为  大堆！\n我们可以手动传入 greater，即可变成小堆\n\n3.4 模拟实现  在3.3中，我们已经实现出了库函数中的 less 和 greater 这两个仿函数，接下来我们只需要包装一下优先级队列的接口，即可使用！\ntemplate &lt;class T, class Container = vector&lt;T&gt;,class Compare = less&lt;T&gt; &gt;\tclass priority_queue\t&#123;\tpublic:\t\tsize_t size()const &#123;\t\t\treturn _con.size();\t\t&#125;\t\tconst T&amp; top() &#123;\t\t\treturn _con[0];\t\t&#125;\t\tbool empty() &#123;\t\t\treturn _con.empty();\t\t&#125;\t\t// 向上调整\t\tvoid AdjustUp(size_t child)\t\t&#123;\t\t\tCompare comFunc;\t\t\twhile (child &gt; 0)\t\t\t&#123;\t\t\t\tsize_t parent = (child - 1) / 2;\t\t\t\tif (comFunc(_con[parent],_con[child]))// 小堆，小的数据往上调\t\t\t\t&#123;\t\t\t\t\tstd::swap(_con[parent], _con[child]);\t\t\t\t\tchild = parent;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t// 向下调整\t\tvoid AdjustDown(size_t parent)\t\t&#123;\t\t\tCompare comFunc;\t\t\tsize_t child = parent * 2 + 1;// 左孩子\t\t\twhile (child &lt; _con.size())\t\t\t&#123;\t\t\t\t// 找左右孩子中小的那一个\t\t\t\tif (child + 1 &lt; _con.size() &amp;&amp; comFunc(_con[child], _con[child + 1]))\t\t\t\t&#123;// 如果左孩子大于右孩子，则选择右孩子\t\t\t\t\tchild++;\t\t\t\t&#125;\t\t\t\tif (comFunc(_con[parent],_con[child]))\t\t\t\t&#123;\t\t\t\t\tstd::swap(_con[parent], _con[child]);\t\t\t\t\tparent = child;\t\t\t\t\tchild = parent * 2 + 1;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t// 因为是优先级队列，所以需要进行调整\t\t// 默认情况下第一个元素始终是最大元素\t\tvoid push(const T&amp; val) \t\t&#123;\t\t\t_con.push_back(val);\t\t\tAdjustUp(_con.size() - 1);\t\t&#125;\t\tvoid pop() \t\t&#123;\t\t\tassert(!_con.empty());\t\t\tswap(_con[0], _con[_con.size() - 1]);\t\t\t_con.pop_back();\t\t\tAdjustDown(0);\t\t&#125;\t\t\tprivate:\t\tContainer _con;\t&#125;;\n\n这里需要注意的便是 adjustdown/up 这两个用来维持堆属性的调整函数，你可以看我之前的博客，里面有关于这部分的详细解释！回到上面\n先来测试一下默认大堆的属性\n\n可以看到，打印出来的数据是按从大到小顺序存放的！\n如果我们显示传入 greatre 仿函数，就会变成从小到大\n\n同时，即便我们 pop 了一部分数据，也不会影响堆的属性\n\n优先级队列在一部分地方可以用于帮我们找到一段数据中的 topK 和第 n 个最大 &#x2F; 小的数据\n比如下面这道 leetcode OJ 题目215. 数组中的第 K 个最大元素\n\n我们只需要 pop 掉前面的 K-1 个元素，这时候的堆顶就是我们需要的第 K 个最大值\n\n4.deque前面已经提到了 deque 这个容器，它拥有的库函数和 vector 很相似，这里我们不关注如何使用这个容器，而是来谈谈这个“双端队列”相比于 vector/list 有没有什么优势\nstd::dequetemplate &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque;\n\n4.1 存储结构deque 最特殊的就是它的存储结构了。它并不是一个连续的结构，也不像链表一样每个数据都有自己的单独节点\n这个是百度百科上找到的一张图片\n\n\nhttps://www.cnblogs.com/yifengs/p/15190416.html\n\n其实 deque 有点类似二维数组，其中有一个头指针指向队列头，一个尾指针指向队列尾部。主数组“中控器”存放的则是这些数组的指针。注：每一个数组的容量大小都是一样的，所以存放在中间的数组一定是满的！\n\n这样我们就避免了 list 节点分散，需要多次开空间，无法随机访问的缺陷；又可以灵活快速地进行头插头删操作，而不需要挪动数据。\n当然，deque的随机访问性能肯定不如数据连续存储的vector，其更适合下面的场景：\n\n需要高性能的头插头删，尾插尾删\n偶尔需要进行随机访问\n\n结语  关于栈和队列的部分到这里就结束辣！\n我们还认识了双端队列deque，以及让其作为容器的模拟实现操作\n\n有任何问题，欢迎评论提出！\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C 语言】什么是堆？堆排序和 TopK 问题又是如何实现的","url":"/posts/3640362579/","content":"[TOC]\n前言  在上一篇数据结构博客中，我带大家一起学习了树以及二叉树这一个全新的数据结构。\n\n【C 语言】什么是树，二叉树又是啥玩意\n\n本篇博客，就让我们一起来看看常被人津津乐道的  堆排序  以及堆这个数据结构是一个什么样的存在吧？\n\n1. 堆的概念  堆的概念是基于  完全二叉树  的\n\n当 k1、k2、k3……kn 的数据按照完全二叉树的方式存放在数组中，且这个完全二叉树满足某个节点的值总是不大于（或不小于）其父节点的值时，称该完全二叉树为堆。\n\n\n将根节点最大的堆叫大根堆\n根节点最小的堆叫做小根堆\n堆中某个节点的值总是不大于（或不小于）其父节点的值\n\n上篇树的博客中已经给大家解释过如何  用数组的方式存放一颗完全二叉树，这里就不再赘述啦！\nleftchild=parent*2+1rightchild=parent*2+2parent=(child-1)/2\n\n接下来这道题目能考察你是否了解了  堆的概念，自测一下吧！\n2. 下列关键字序列中，序列（ ）是堆。A .{16，72，31，23，94，53}B .{94，23，31，72，16，53}C .{16，53，23，94，31，72}D .{16，23，53，31，94，72}   √\n\n简单说来，以 0 下标根为例，下标 1 和 2 为根的左右孩子。如果他们都比根小，代表这是一个  小根堆，反之是大根堆。\n接着我们就需要判断，是不是所有节点的孩子都满足这个特性，如果出现某一个节点的孩子和该节点的父亲之间的关系  不满足根节点和孩子  之间的关系（如根节点的孩子比根节点大，那么该树中所有节点的孩子都应该比该节点大）那么这个就不是一个堆\n2. 堆的实现  先来尝试直接实现一个堆，即将数据以堆的结构存放在数组中\n这里给出一个堆的  头文件 ，里面包含了一个 堆的基本框架\n// 实现一个小堆 #include&lt;stdio.h&gt;#include&lt;assert.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;typedef int HPDataType;typedef struct Heap{\tHPDataType* a;\tsize_t size;\tsize_t capacity;}HP;void HeapInit(HP* php);// 初始化 - 不进行扩容操作void HeapDestroy(HP* php);// 摧毁void HeapPrint(HP* php);// 打印// 交换数组中两个元素的位置void Swap(HPDataType* pa, HPDataType* pb);// 插入后向上调整，保证数据是(大 / 小) 堆//child 为待操作数据的下标 void AdjustUp(HPDataType* a, size_t child);// 插入 x 以后，保持他依旧是(大 / 小) 堆void HeapPush(HP* php, HPDataType x);// 删除后向下调整，保证数组末尾数据位置正确//size 堆的大小；root 待调节数据的位置，0 代表根部（堆顶）void AdjustDown(HPDataType* a, size_t size, size_t root);// 删除堆顶的数据。(最小 / 最大)；// 交换堆顶数据和数组末尾数据void HeapPop(HP* php);// 判断是否为空bool HeapEmpty(HP* php);// 返回堆的大小（节点个数）size_t HeapSize(HP* php);// 返回堆顶，访问数组下标 0HPDataType HeapTop(HP* php);\n\n2.1 向上调整  你会发现，相较于普通数据结构的增加、删除操作，堆有一个额外的操作，就是  调整数据的位置。\n\n本篇博客不再对前面的基础操作进行讲解，如果有不会的可以评论区提出哦\n\n比如下面这幅图里的数组，我们可以直接在数组的末尾插入一个数据 6，因为当前的这个堆是一个  小堆，堆顶的数据是最小的数据，所以我们不需要对这个数据进行处理\n\n但当我们插入一个 0，事情就不一样了。我们必须将  这个 0 调整到堆顶的位置 ，才能让插入数据后的数组依旧是一个 小堆\n\n转换为树的形状，即为下图\n\n我们需要让在叶节点的 0 往上爬，来到 1 的位置\n如何操作呢？\n\n将该节点与它的父节点进行比较，如果父节点大于该节点，则交换两个节点的位置。\n通过循环的来完成一个完整的向上调节工作\n\n在上篇博客  中，我提到了下图所示的计算公式。使用这个公式来进行父节点和孩子节点的查找工作，再单独编写一个 Swap 函数进行交换\n\n代码实现如下\n// 交换数组中两个元素的位置 void Swap(HPDataType* pa, HPDataType* pb) {\tint tmp = *pa;\t*pa = *pb;\t*pb = tmp;}// 向上调整，保证数据是(大 / 小) 堆//child 为待调整数据的下标位置 void AdjustUp(HPDataType* a, size_t child){\tassert(a);// 这里依旧需要断言，因为用户可能单独调用这个函数\twhile (child &gt; 0)\t{\t\tint parent = (child - 1) / 2;\t\tif (a[child] &lt; a[parent])// 小堆，小的数据往上调\t\t{\t\t\tSwap(&amp;a[child], &amp;a[parent]);\t\t\tchild = parent;\t\t}\t\telse\t\t{\t\t\treturn;\t\t}\t}}// 插入 x 以后，保持他依旧是(大 / 小) 堆// O(logN)void HeapPush(HP* php, HPDataType x){\tassert(php);\tif (php-&gt;size == php-&gt;capacity)\t{\t\t// 如果容量为 0，新容量为 4；不为 0，新容量为原本容量的 2 倍\t\tint newcapa = php-&gt;capacity==0 ? 4: php-&gt;capacity*2;\t\tHPDataType* tmp = (HPDataType*)realloc(php-&gt;a, newcapa*sizeof(HPDataType));//realloc 接收空指针，作用与 malloc 相同\t\tif (tmp == NULL)\t\t{\t\t\tprintf(\"realloc failed!\\n\");\t\t\texit(-1);\t\t}\t\tphp-&gt;a = tmp;\t\tphp-&gt;capacity = newcapa;\t}\tphp-&gt;a[php-&gt;size] = x;// 在数组末尾插入新数据\tphp-&gt;size++;\tAdjustUp(php-&gt;a, php-&gt;size - 1);}\n\n下图更加清晰地展示了向上调整函数的作用过程\n\n2.2 向下调整  同理，当我们 pop 掉一个  堆顶  的数据之后，就需要进行一定的调整，来维持堆的结构\n这里需要注意一个问题，栈顶的数据并不能直接 pop 掉，因为会破坏掉堆的结构。\n比如下面的这个堆中，如果我们直接删除掉堆顶的元素 1，那请问谁来当新的爸爸呢？\n\n为了方便这里数据的处理，我们要先将堆顶的元素和数组的最后一个元素进行交换，再进行 pop 操作。\n\n\n因为我们的堆是用顺序表实现的，所以交换后，只需让 size-- 即可达到 pop 的效果\n\n那么如何让 8 往下掉呢？\n同样是利用上面提到过的关系公式👉点我回到之前的公式图\n我们需要将 8 和它的孩子进行比较，如果 8 大于它的孩子，则进行交换。\n代码实现如下👇\n// 删除后向下调整，保证数组末尾数据位置正确void AdjustDown(HPDataType* a, size_t size, size_t root){\tassert(a);\tint parent = root;\tint child = parent * 2 + 1;// 左孩子\twhile (child &lt; size)\t{\t\t\t\t// 找左右孩子中小的那一个\t\tif (child + 1 &lt; size &amp;&amp; a[child] &gt; a[child + 1])\t\t{// 如果左孩子大于右孩子，则选择右孩子\t\t\tchild++;\t\t}\t\tif (a[child] &lt; a[parent])\t\t{\t\t\tSwap(&amp;a[child], &amp;a[parent]);\t\t\tparent = child;\t\t\tchild = parent * 2 + 1;\t\t}\t\telse\t\t{\t\t\treturn;\t\t}\t}}// 删除堆顶的数据。(最小 / 最大)；// 交换堆顶数据和数组末尾数据void HeapPop(HP* php) {\tassert(php);\tassert(php-&gt;size &gt; 0);\tSwap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);\tphp-&gt;size--;\tAdjustDown(php-&gt;a, php-&gt;size, 0);}\n\n这两个函数以外的其他函数就比较简单啦，相信学到这里的你肯定能自己根据  头文件的函数声明  来解决它们。回到头文件\n\n如果你有疑惑，可以去看看之前  顺序表  的实现，或者在评论区提问哦\n\n\n2.3 代码测试  老样子，一定要写完一个模块后，立马测试一个模块！\n\n3. 堆排序  上面我们自己实现了一个堆的代码，接下来我们可以借助这个堆的代码，进行  排序操作。（解析见代码注释）\nvoid HeapSort(int* a, int size){\t// 小堆 - 升序\tHP hp;\tHeapInit(&amp;hp);\tfor (int i = 0; i &lt; size; ++i)\t{\t\tHeapPush(&amp;hp, a[i]);// 往堆内放入数据\t}\tsize_t j = 0;\twhile (!HeapEmpty(&amp;hp))\t{\t\ta[j] = HeapTop(&amp;hp);// 每一次都堆顶数据出来放入数组\t\tj++;\t\tHeapPop(&amp;hp);// 删除堆顶数据，重新排序\t}\tHeapDestroy(&amp;hp);}\n\n可以看到，上述代码成功排序\n\n3.1 为什么要进行堆排序？看到这里，你可能会有一个疑惑：排序的方式有很多种，我们可以直接冒泡排序，也可以利用库函数 qsort 进行排序，为什么要采取堆排序这种方式呢？还需要写一个堆的代码，多麻烦啊！\n\n要想解答这个问题，我们先来看看冒泡排序算法和堆排序算法的时间复杂度\n\n\n冒泡排序：遍历一遍数组是 N，调整一次数据也是 N，时间复杂读是 O(N^2^)\n堆排序：建堆是O(N*logN)，取堆顶数据是 O(N)，时间复杂度是O(N*logN)\n\n如果你不了解什么是时间复杂度，可以看看我的这篇博客👉传送门\n\n对于我示例中这个 10 个元素的数组来说，这两个时间复杂度的差距可能不是很大，但对于海量数据来说，差距就起飞啦！\n\n\n\n数据个数\nO(N*logN)\nO(N^2^)\n\n\n\n1000\n1000×10\n1000×1000\n\n\n100w\n100w×20\n100w×100w\n\n\n这个数据的差距可大的很呢！😱\n\n从上面的解释，你应该能看出来，堆排序是挺优秀！\n但是我们一般并不会写上面的代码，因为它需要另建一个堆来存放数据，空间复杂度是O(N)\n有没有什么办法，能够在原本的数组上建堆，来进行排序呢？\n3.2 在原本数组上建堆  直入主题，我们可以直接在原本的数据上，利用堆的向上 / 下调整算法，建立一个大堆或者小堆来进行排序。\n3.2.1 向上调整 - 插入数据  使用插入数据的思想，我们可以把数组第二个元素当作新的元素进行 push 操作，并利用向上调整算法来调整它们的位置，以此类推，这样就能建成一个堆。\n\n但是这个方法对于  升序  来说不够优化，后续会提到具体原因\n\n3.2.2 向下调整 - 删除数据  假设我们有一个这样的数组（它现在还不算一个堆）\n\n我们可以从第一个非叶子节点（即 8）开始，进行向下调整，如果它的孩子比它小，则进行交换。处理完 8 后，进一步处理 7、2、4……\n最终我们会得到这样的一个小堆\n\n此时再将第一个数据和末尾数据进行交换，pop 掉它，让它成为数组尾部的数据。再进行向下调整操作，依次循环，即可完成一个  降序的排列\n3.2.3 比较时间复杂度  我们来比较一下上面两个方法的时间复杂度。\n\n如果是  向上调整  的话，第二层的 2 个节点要向上调整 1 次，第三层的 4 个节点要向上调整 2 次，最后累积，我们会得到下面这个公式 $$T(h)=2^11+2^22+2^33+……+2^{h-1}(h-1)$$ 数学好的你，估计一眼就能看出来，这是一个  等差×等比  形式的数列，可以利用\n\n错位相减法，高考第 17 题，如果出上面这个式子，属于送分题\n快一年过去了，现在的我看到这个式子，属于送命题\n\n好吧其实也没那么难😂\n\n\n如果是向下调整算法 ，第一层要向下移动 h-1 层，第二层要向下移动 h-2 层，第 h-1 层需要往下移动 1 层，我们能得到下面的公式 最后能得出，需要移动的总步数为  在 N 很大的时候，减去的 log(n+1)可以忽略，时间复杂度为O(N)\n由此可见，向下调整算法是更优的，它的时间复杂度更小\n\n3.3 代码示例  弄明白思路后，写代码就很简单啦！\n// 交换数组中两个元素的位置 void Swap(int* pa, int* pb) {\tint tmp = *pa;\t*pa = *pb;\t*pb = tmp;}// 打印数组void PrintArray(int* a,int n,const char*info){\tprintf(\"[%s]\",info);\tfor(int i=0;i&lt;n;i++)\t{\t\tprintf(\"%d\",a[i]);\t}\tprintf(\"\\n\");}// 堆排序void AdjustDown(int* a, int n, int root){\tassert(a);\tint parent = root;\tint child = parent * 2 + 1;// 左孩子\twhile (child &lt; n){\t\t// 找左右孩子中小(大) 的那一个 \t\tif (child + 1 &lt; n &amp;&amp; a[child] &gt; a[child + 1])\t\t{// 如果左孩子大(小) 于右孩子，则选择右孩子\t\t\tchild++;\t\t}\t\t// 这个也需要根据上方 a[child] &lt; a[child + 1] 大于小于的不同进行修改\t\t// 大堆，将大的往上调\t\t// 小堆，将小的网上调\t\tif (a[child] &lt; a[parent]){\t\t\tSwap(&amp;a[child], &amp;a[parent]);\t\t\tparent = child;\t\t\tchild = parent * 2 + 1;\t\t}\t\telse{\t\t\treturn;\t\t}\t}}// 升序用大堆// 降序用小堆void HeapSort(int* a, int n){\t// 向下调整 -- 建堆 O(N)\tfor (int i = (n - 1 - 1) / 2; i &gt;= 0; --i){\t\tAdjustDown(a, n, i);// 此时建的是一个小堆\t}\tPrintArray(a, n,\"建堆后\");\tsize_t end = n - 1;\twhile (end &gt; 0){\t\tSwap(&amp;a[0], &amp;a[end]);// 前后交换，最大的数放到末尾，不进行下一次调整\t\tAdjustDown(a, end, 0);\t\tend--;\t}}\n\n测试一下代码，完美排序出了  降序\n\n如果你需要升序的话，只需将原本实现的小堆代码中的判断条件改一下就行了。按下图修改，即可改为升序排序（建的大堆）\n\n\n4.TopK 问题 4.1 问题说明TOP-K 问题： 即求数据结合中前 K 个最大的元素或者最小的元素，一般情况下数据量都比较大。\n比如：专业前 10 名、世界 500 强、富豪榜、游戏中前 100 的活跃玩家等\n对于 Top-K 问题，能想到的最简单直接的方式就是  排序。有两个思路\n\n堆排序：时间复杂度O(N*logN)，空间复杂度 O(1)\n在原本的数组上建立 N 个数的大堆，Pop K 次，就能选出最大的前 K 个。时间复杂度O(N+K*logN)，空间复杂度：O(1)\n\n但是，如果数据量非常大，上面这两个方法就不太可取了(可能数据都不能一下子全部加载到内存中，而是存放在硬盘里面)\n\n4.2 如何求解？\n用前 K 个数建立一个 K 个数的小堆，然后剩下的 N-K 个数依次遍历，如果比堆顶的数据大，就替换它进堆（进堆后要进行  向下调整），最后堆里面的 K 个数据就是最大的前 K 个\n\n代码示例如下\nvoid PrintTopK(int* a, int n, int k){\t// 1. 建堆 -- 用 a 中前 k 个元素建堆\tint* kminHeap = (int*)malloc(sizeof(int) * k);\tassert(kminHeap);\tfor (int i = 0; i &lt; k; ++i)\t{\t\tkminHeap[i] = a[i];\t}\t// 利用小堆代码的向下调整，建一个小堆\tfor (int j = (k - 1 - 1) / 2; j &gt;= 0; --j)\t{\t\tAdjustDown(kminHeap, k, j);\t}\t// 堆顶是这个堆里面最小的数据\t//2. 将剩余 n-k 个元素依次与堆顶元素判断，如果大于堆顶，则交换\tfor (int i = k; i &lt; n; ++i)\t{\t\tif (a[i] &gt; kminHeap[0])\t\t{\t\t\tkminHeap[0] = a[i];\t\t\tAdjustDown(kminHeap, k, 0);\t\t}\t}\tfor (int j = 0; j &lt; k; ++j)\t{\t\tprintf(\"%d\", kminHeap[j]);\t}\tprintf(\"\\n\");\tfree(kminHeap);}\n\n\n时间复杂度：O(K+logK*(N-K))\n空间复杂度：O(K)\n\n当 N 非常大，K 很小的时候，这个算法的时间复杂度基本就是 O(N)\n\n4.3 测试代码  通过 time 函数和 srand 函数，我们可以将一个 10000 个数的数组 中的每个元素赋值小于 100w 的随机数，再在随机位置放入 10 个大于 100w 的数字。\n可以看到，上面的代码  巧妙利用堆的知识，帮我们找出了这个 10000 个数的数组中最大的前 K 个数字\n\n\n结语  堆和堆排序的知识到这里就讲解完毕啦！如果你还有什么问题，可以在评论区留言哦~\n\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","堆"]},{"title":"【C++】红黑树的性质和实现","url":"/posts/3503649261/","content":"上篇博客我们了解了 AVL 树，这篇博客就让我们来看看另外一个二叉树：红黑树\n\n使用的编译器：VS2019\n\n\n\n[TOC]\n\n博客里面引用了一些百度搜到的图片（自己懒的画了，呜呜）\n1. 概念AVL 树是一个几乎完全平衡的搜素二叉树，其左右子树的高度差不会超过 1。与之相对应的，是每一次插入都有可能需要旋转多次，插入的效率较低。\n而红黑树则选择了“相对平衡”，并拥有以下的特性：\n\n红黑树可以保证最长路径的小于最短路径的 2 倍\n\n比如最短路径为 30，那么最长路径就不能超过 60\n\n\n对于 cpu 来说，AVL 树遍历 20 次（百万级数据）和红黑树遍历 40 次的时间差距极小。所以红黑树即保持了相对平衡，又减小了 AVL 树多次旋转的消耗。\n\n1.1 性质  其通过下面的几点来维持这一性质：\n\n每一个节点不是红色就是黑色\n根节点一定是黑色\n每一个红节点的左右子树都是黑色\n每一个到叶子（空节点 NIL）的支路上黑节点数量相同\n叶子节点（空节点 NIL）视作黑色\n\n为什么满足了这几个情况，就满足了红黑树的  最长路径的小于最短路径的 2 倍  的性质呢？\n约束 4 和 5，保证了红黑树的大致平衡：根到叶子的所有路径中，最长路径不会超过最短路径的 2 倍。这使得红黑树在最坏的情况下，也能有O(logN) 的查找效率\n\n黑色高度为 3 时，最短路径：黑色→ 黑色 →黑色\n最长路径：黑色→红色 →黑色 →红色 →黑色\n此时最短路径的长度为 2（不算 Nil 的叶子节点），最长路径为 4\n\n这里可以得出一个普遍规律，红黑树最短路径即为全黑路径。而最长路径是  一黑一红  间隔的情况\n1.2 时间复杂度  平衡二叉树（AVL 树）和红黑树都是常用的自平衡二叉搜索树。它们的查询操作的平均时间复杂度都为 O(log n)，其中 n 是树中节点的数量。\n在平衡二叉树中，任意节点的左子树和右子树的高度差不超过 1，通过局部旋转操作可以保持平衡。这样，树的高度始终保持在 O(log n)的水平，从而使得查询操作的时间复杂度为 O(log n)。\n红黑树是一种更加复杂的自平衡二叉搜索树，它通过对节点进行染色（红色或黑色）和旋转操作来保持平衡。红黑树具有以下性质：\n根据上文提到的红黑树性质，红黑树的高度始终保持在 O(log n)的水平，因此查询操作的时间复杂度也为 O(log n)。\n综上所述，平衡二叉树和红黑树的查询平均时间复杂度都是 O(log n)。最差情况中，两个数的节点高度都不会超过 2log(n+1)，所以最坏的时间复杂度还是 O(log N)\n\n2. 设计一颗红黑树  在设计红黑树的时候，我们需要牢记上面的 5 点。其中前 4 点非常重要且不可以被破坏。一旦被破坏，就影响了红黑树的基本性质。\n2.1 设计节点  和 AVL 树一样，我们需要把节点单独成一个类，来存放我们需要的pair\n这里就设计到了颜色的初值应该给什么。红色，还是黑色？\n来看看性质 3 和 4：\n\n红色的左右子树必须是黑色\n每一个到叶子（空节点 NIL）的支路上黑节点数量相同\n\n简单思考，即可发现，插入红节点的时候，更好控制。而插入黑节点极有可能破坏性质 4 且较难修复。\n// 枚举，定义颜色enum Color&#123;\tRED,//0\tBLACK,//1&#125;;// 节点类template&lt;class K, class V&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;K, V&gt;* _left;\tRBTreeNode&lt;K, V&gt;* _right;\tRBTreeNode&lt;K, V&gt;* _parent;\tpair&lt;K, V&gt; _kv;\t//AVL 树的平衡因子，在红黑树中为颜色\tColor _col;\t// 插入节点的时候，默认为红色\t// 因为这个满足性质 3 且不会破坏性质 4\tRBTreeNode(const pair&lt;K, V&gt;&amp; kv)\t\t:_kv(kv),\t\t_left(nullptr),\t\t_right(nullptr),\t\t_parent(nullptr),\t\t_col(RED)\t&#123;&#125;&#125;;\n\n2.2 插入的几种情况  节点设计好了，我们只需要把插入的逻辑搞定，那么红黑树也就完成了！\n前半部分的代码和 AVL 树完全相同，只不过我们需要手动给根节点一个黑色（默认是红色）以维持性质 2\nbool Insert(const pair&lt;K, V&gt;&amp; kv)&#123;\t// 判断 root 为空，即空树\tif (_root == nullptr)\t&#123;\t\t_root = new Node(kv);\t\t_root-&gt;_col = BLACK;// 这里必须要手动给黑色\t\treturn true;\t&#125;\t//kv 树的操作\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;\t\t// 利用 key 来判断，寻找待插入的位置\t\tif (cur-&gt;_kv.first &lt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (cur-&gt;_kv.first &gt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse &#123;\t\t\treturn false;\t\t&#125;\t&#125;\t// 找到位置后插入节点\tcur = new Node(kv);\tif (parent-&gt;_kv.first &lt; kv.first)\t&#123;\t\tparent-&gt;_right = cur;\t&#125;\telse\t&#123;\t\tparent-&gt;_left = cur;\t&#125;\tcur-&gt;_parent = parent;       // 调整       //……  &#125;\n\n2.2.1 情况 1：无需旋转  在下面的这种情况中，我们在 p 的左边插入了一个 cur 新节点。此时违反了性质 3，红节点的孩子必须要是黑节点。\n这种情况  必须满足 p 和 u 都是红节点\n\n随后我们就需要开始向上进行更新，操作如下：\n\n把 p 和 u 都改成黑节点\n把 g 改成红节点\n\n修改之后的结果如下，即不影响性质 3；也保证了黑节点的个数不变，维持了性质 4\n\n需要注意的是，这里的 g 不一定是根节点。所以在操作完这一课子树之后，我们需要继续向上进行操作，避免 g 的父节点是红色的情况。\n\n代码实现如下（以父节点为 g 的左子树为例）\n// 插入之后需要向上更新颜色, 只有出现连续红色之后才需要更新while (parent &amp;&amp; parent-&gt;_col==RED)&#123;    //p 是 g 的左    if (parent == grandpa-&gt;_left)    &#123;        Node* uncle = grandpa-&gt;_right;        // 情况 1：插入后 p 是红，u 存在且是红（不需要旋转）        if (uncle &amp;&amp; uncle-&gt;_col == RED)        &#123;            uncle-&gt;_col = BLACK;            parent-&gt;_col = BLACK;            grandpa-&gt;_col = RED;// 祖父变成红            // 继续向上调整            //cur = cur-&gt;_parent;            //parent = parent-&gt;_parent;            cur = grandpa;            parent = cur-&gt;_parent;        &#125;    &#125;    else&#123;        //....    &#125;&#125;\n\n需要注意的是，这种调整会把 g 改成红节点。如果 G 是根节点，改成红色之后就不符合性质了。所以我们需要在操作完成之后，统一把根节点改成黑色\n// 不管是什么情况，最后都把根改成黑，符合条件 2_root-&gt;_col = BLACK;\n\n2.2.2 情况 2：需要单旋  当我们插入了一个 cur 向上更新的时候，就可能会遇到下图中间的情况。p 是红节点，违反了性质 3，而u 是黑节点，不能简单粗暴的通过把 p 改成红来解决。\n\n这时候我们就需要针对 g 进行一次  单旋（图中是右单旋，可以简单理解为向 u 旋转）。因为 cur 和 p 形成了同侧的连续两个红节点。和 AVL 树的单旋情况相似，只有这两节点在同侧，才可以执行单旋。\n旋转完毕之后，需要把 g 更新为红节点，p 更新为黑节点\n2.2.3 情况 3：需要双旋  在情况 2 中，p 和 cur 都是在它们父亲的同一侧。而情况 3 就是 p 和 cur 在父亲的不同侧。\n\n比如 p 是 g 的左子树，cur 是 p 的右子树\n同时满足 p 是红，u 是黑\n\n这时候就需要进行一次三旋，操作如下：\n\n以 p 作为基点，向 cur 的另外一个方向单旋一次（上图中就是左旋）\n旋转了之后，就会变成情况 2\n这时候再以 g 为基点，向 u 的方向旋转一次（上图中为右旋）\n旋转完成之后，把 g 设置为红，cur 设置为黑即可\n\n\n一下是完整的三种情况代码（p 是 g 的左子树的情况）\n//p 是 g 的左if (parent == grandpa-&gt;_left)&#123;    Node* uncle = grandpa-&gt;_right;    // 情况 1：插入后 p 是红，u 存在且是红（不需要旋转）    if (uncle &amp;&amp; uncle-&gt;_col == RED)    &#123;        uncle-&gt;_col = BLACK;        parent-&gt;_col = BLACK;        grandpa-&gt;_col = RED;// 祖父变成红        // 继续向上调整        //cur = cur-&gt;_parent;        //parent = parent-&gt;_parent;        cur = grandpa;        parent = cur-&gt;_parent;    &#125;    else//(uncle &amp;&amp; uncle-&gt;_col == BLACK)    &#123;        // 情况 2：插入后 p 为红，u 存在且为黑（需要单旋）        if (cur == parent-&gt;_left)        &#123;            RotateR(grandpa);// 因为 p 在 g 的左边，所以右旋            parent-&gt;_col = BLACK;            grandpa-&gt;_col = RED;        &#125;        else//cur == parent-&gt;_right        &#123;            // 情况 3：不是在同一侧，双旋            //   g            // p            //   c            RotateL(parent);            RotateR(grandpa);            grandpa-&gt;_col = RED;// 祖父改成红色            cur-&gt;_col = BLACK;// 自己成为了这里的根，需要改成黑的        &#125;        break;    &#125;&#125;else&#123;    //....&#125;\n\n由于篇幅限制，p 是 g 右子树的情况就不贴出来了，实际上就是把上面的代码全反过来就行了\n\n完整代码请查看我的gitee 仓库\n\n2.3 查找（和 AVL 树完全相同）// 因为 kvl 树我们需要修改 value，所以返回节点的指针Node* _FindR(Node* root, const K&amp; key)&#123;\tif (root == nullptr)\t\treturn nullptr;\tif (root-&gt;_kv.first &lt; key)\t&#123;\t\treturn _FindR(root-&gt;_right, key);\t&#125;\telse if (root-&gt;_kv.first &gt; key)\t&#123;\t\treturn _FindR(root-&gt;_left, key);\t&#125;\telse\t&#123;\t\treturn root;\t&#125;&#125;// 查找是通过 key 来进行的Node* FindR(const K&amp; key)&#123;\treturn _FindR(_root, key);&#125;\n\n2.4 判断是否是红黑树  有两种方案，1 是可以通过计算最大高度 &#x2F; 最小高度进行间接判断，2 是以红黑树性质来验证是否满足最上面提到的 5 点\n2.4.1 计算最小最大高度  这里实现递归即可，最小长度其实就是在最后 return 的判断中，把大于号改成小于号，返回小的那个子树的高度 +1\nint maxHeight()&#123;\treturn _maxHeight(_root);&#125;int minHeight() &#123;\treturn _minHeight(_root);&#125;// 最大长度int _maxHeight(Node* root)&#123;\tif (root == nullptr)\t\treturn 0;\tint lh = _maxHeight(root-&gt;_left);\tint rh = _maxHeight(root-&gt;_right);\treturn lh &gt; rh ? lh + 1 : rh + 1;&#125;// 最小长度int _minHeight(Node* root)&#123;\tif (root == nullptr)\t\treturn 0;\tint lh = _minHeight(root-&gt;_left);\tint rh = _minHeight(root-&gt;_right);\treturn lh &lt; rh ? lh + 1 : rh + 1;&#125;\n\n只要最大长度小于最小长度的 2 倍，那么基本规则就是没有破坏的\n\n但这还不够，我们还需要检查它是否满足红黑树的其余性质\n2.4.2 递归检查性质  这里再次列出 5 点性质\n\n每一个节点不是红色就是黑色\n根节点一定是黑色\n每一个红节点的左右子树都是黑色\n每一个到叶子（空节点 NIL）的支路上黑节点数量相同\n叶子节点（空节点 NIL）视作黑色\n\n然后通过两个函数来实现，其中一个函数需要进行递归\nbool IsRBTree()&#123;    // 检查红黑树几条规则    Node* pRoot = _root;    // 空树也是红黑树    if (nullptr == pRoot)        return true;    // 检测根节点是否满足情况 2    if (BLACK != pRoot-&gt;_col)    &#123;        cout &lt;&lt; &quot; 违反 2：根节点必须为黑色 &quot; &lt;&lt; endl;        return false;    &#125;    // 获取任意一条路径中黑色节点的个数，作为基准值    size_t blackCount = 0;    Node* pCur = pRoot;    while (pCur)    &#123;        if (BLACK == pCur-&gt;_col)            blackCount++;        pCur = pCur-&gt;_left;    &#125;    // 检测是否满足红黑树的性质，k 用来记录路径中黑色节点的个数    size_t k = 0;    return _IsValidRBTree(pRoot, k, blackCount);&#125;\t// 检测是否为 RB 树bool _IsValidRBTree(Node* pRoot, size_t k, const size_t blackCount)&#123;    // 走到 null 之后，判断 k 和 black 是否相等    if (nullptr == pRoot)    &#123;        if (k != blackCount)        &#123;            cout &lt;&lt; &quot; 违反 4：每条路径中黑色节点的个数必须相同 &quot; &lt;&lt; endl;            return false;        &#125;        return true;    &#125;    // 统计黑色节点的个数    if (BLACK == pRoot-&gt;_col)        k++;    // 检测当前节点与其双亲是否都为红色    if (RED == pRoot-&gt;_col &amp;&amp; pRoot-&gt;_parent &amp;&amp; pRoot-&gt;_parent-&gt;_col == RED)    &#123;        cout &lt;&lt; &quot; 违反 3：存在连在一起的红色节点 &quot; &lt;&lt; endl;        return false;    &#125;    return _IsValidRBTree(pRoot-&gt;_left, k, blackCount) &amp;&amp;        _IsValidRBTree(pRoot-&gt;_right, k, blackCount);&#125;\n\n可以看到，不管是随机数还是顺序插入，都通过了检查\n\n3. 红黑树的运用  红黑树在很多地方都有使用，在 C++ 中，最为经典的便是 map 和 set 这两个容器，它们便使用了红黑树作为底层逻辑\n\nhttps://gitee.com/musnow/learn_cpp_code/blob/master/STL-Sourcecode/stl_tree.h\n\n在 stl 源码中，我们可以找到这个tree.h，里面便是一个红黑树的实现。而 map 和 set 就是调用了红黑树，只做了一个简单的封装\n结语  在下篇博客中，我会记录 map 和 set 的基本使用，以及通过红黑树模拟实现 map 和 set\n感谢大家支持！\n","categories":["遇见C++"],"tags":["数据结构","树","C++"]},{"title":"【C++】搜索二叉树 /KVL 树","url":"/posts/1396203902/","content":"暑假已经过去一半了，你的作业写的怎么样了？\n不八八这些没啥用的了，本篇博客让我们来认识一下  搜索二叉树  以及KVL 树，也为后续学习 map 和 set 打下基础。\n\n\n\n在之前，我写过一篇用 C 语言实现的二叉树博客。如果你想了解二叉树的基本定义，可以看看👉 【传送门】\n\n[TOC]\n前言  树是我们生活中非常常见的玩意，其特点便是从下而上有非常多的分叉\n\n\n数据结构中的树便是以该特点命名的，每一个节点会有左右两个分叉来链接左右子树，从而构成一种数据结构。\n1. 搜索二叉树  所谓搜索二叉树（二叉查找树），便是致力于方便搜索的一种数据结构，其具有一下特点：\n\n比该节点大的数存放在右边\n比该节点小的数存放在左边\n\n这样当我们去遍历一颗搜索二叉树的时候，就可以很方便的通过大小比较找到其内部是否包含我们需要搜索的节点。这样在  理想状态  下，搜索的时间复杂度能控制在O(logN)，还是非常快的一个搜索算法！\n因为搜索二叉树主要用于搜索而不是存储数据，所以一般情况下的搜索二叉树是不允许数据冗余的。即相同的值只会存储一次\n\n同时，搜索二叉树可作为排序算法的一种。当我们用中序遍历搜索二叉树，得到的结果是有序的\n\n\n1.1 基本构建  想要构建一个搜索二叉树，首先我们需要一个树的节点的结构\ntemplate&lt;class K&gt;struct BSTreeNode&#123;public:\tBSTreeNode* _left;\tBSTreeNode* _right;\tK _key;// 元素\tBSTreeNode(K key)\t\t:_left(nullptr),\t\t_right(nullptr),\t\t_key(key)\t&#123;&#125;&#125;;\n\n\n为何不直接把这个结构定义在二叉树的 class 里面？\n因为那样会产生数据冗余而且非常不方便调用成员函数\n\n在搜索二叉树的功能实现类中，我们只需要定义一个根部节点即可\ntemplate&lt;class K&gt;class BSTree&#123;typedef BSTreeNode&lt;K&gt; Node;// 方便使用private:    // 成员变量\tNode* _root=nullptr;&#125;\n\n\n1.2 插入  有了基本结构以后，我们就可以写一个插入函数来进行最基本的操作了\n\n当 root 为空的时候，需要给根节点开一个空间\nroot 不为空，定义 prev 和 cur 两个指针进行遍历，通过大小判断来找寻正确的插入位置（左边小，右边大）\n找到正确位置后，构造新节点并进行插入操作\n\n使用 bool 作为返回值是因为我们需要判断是否成功插入。如果成功插入了为true，没有成功插入代表该搜索二叉树内已经包含了相同键值的节点。\nbool Insert(K key)&#123;    if (_root == nullptr)    &#123;        _root = new Node(key);// 根为空，直接开空间插入        return true;    &#125;    Node* prev = nullptr;    Node* cur = _root;    while (cur)    &#123;        if (key &gt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_right;        &#125;        else if (key &lt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_left;        &#125;        else        &#123;            return false;// 有相同元素不执行插入        &#125;    &#125;\t// 创建节点进行插入    cur = new Node(key);    // 保存 prev 指针就是为了操控它的父亲来链接节点    if (key &gt; prev-&gt;_key) &#123;        prev-&gt;_right = cur;    &#125;    else&#123;        prev-&gt;_left = cur;    &#125;    return true;&#125;\n\n除了循环版本，我们还可以写一个递归版本\nbool InsertR(const K&amp; key)// 实际调用的函数&#123;    return _InsertR(_root, key);&#125;\t// 使用引用，这时候的 root 就是上一个节点的左右子树的别名// 修改 root 的同时也会修改上一个子树的左右节点// 也可以用二级指针来完成这个操作，原理相同bool _InsertR(Node*&amp; root, const K&amp; key)&#123;    // 空代表走到叶子了，执行插入    if (root == nullptr) &#123;        Node* newNode = new Node(key);        root = newNode;        return true;    &#125;    if (key &gt; root-&gt;_key) &#123;        _InsertR(root-&gt;_right, key);    &#125;    else if (key &lt; root-&gt;_key) &#123;        _InsertR(root-&gt;_left, key);    &#125;    else &#123;        return false;// 不插入相同值    &#125;&#125;\n\n此类二叉树的递归思路最好用画图来理清。需要明白每一个节点是怎么返回的\n\n关于分支递归思想可以看看【链接】，这有助于你理解本文中的递归实现\n\n上面的递归问题便是将原本利用循环进行左右寻找的操作化为往下调用下一课子树。简单来来说就是老师要班长、班长找小组长、小组长找组员这样分配工作。\n只有走到最后的组员（空节点）我们才执行插入操作\n1.3 中序打印  插入完成了，要怎样才能看到节点中的内容呢？来个中序遍历吧！\n我们需要重写一个递归函数，因为在类外面无法访问到私有成员 root，无法直接给该函数传参。如果想维持类的封装性，也可以把这个函数定义为private 成员\n    void InOrder()// 中序遍历    &#123;        _InOrder(_root);    &#125;//private:    void _InOrder(Node* root)    &#123; // 递归打印        if (root == nullptr)            return ;        _InOrder(root-&gt;_left);        cout &lt;&lt; root-&gt;_key &lt;&lt; &quot; &quot;;        _InOrder(root-&gt;_right);    &#125;\n\n关于前中后序遍历的内容在之前 C 语言的博客中有过讲解，这里就不再赘述\n\n\n1.4 查找  既然是搜索二叉树，那便必须要有查找函数。\n其实在插入操作中，我们便已经把查找函数的思路写出来了（即判断是否是重复节点）\n// 搜索二叉树一般不直接操作节点，不需要返回节点的指针//Node* Find(const K&amp; key)bool Find(const K&amp; key)&#123;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (key &gt; cur-&gt;_key)\t\t&#123;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (key &lt; cur-&gt;_key)\t\t&#123;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn true;\t\t&#125;\t&#125;\treturn false;&#125;\n\n同样，也可以写一个递归版本。当节点的值相等时返回true，如果走到空了代表这棵树里面没有这个节点，返回false\nbool FindR(const K&amp; key)// 实际调用的函数&#123;    return _FindR(_root, key);&#125;// 递归实现bool _FindR(Node* root, const K&amp; key)&#123;    if (root == nullptr) &#123;        return false;    &#125;    if (key &gt; root-&gt;_key) &#123;        _FindR(root-&gt;_right, key);    &#125;    else if (key &lt; root-&gt;_key) &#123;        _FindR(root-&gt;_left, key);    &#125;    else &#123;        return true;    &#125;&#125;\n\n1.5 删除(较难) 在搜索二叉树中删除节点并没有那么容易，因为我们需要保证删除节点后，树还满足搜索二叉树的特征。如果删除了之后破坏树的结构还不管他，那就是 err 了。\n以下面的这棵树为例，它满足搜索二叉树的基本特征\n\n\n假设我们需要删除节点 4，这很容易，只需要让 3 的右子树为空，再 delete 掉 4 的节点即可。\n但如果我们想删除 6，事情就没那么简单了。我们需要找一个节点，来替补它的位置\n\n那么，谁可以胜任这个新的位置呢？\n答：左子树的最大节点 or 右子树的最小节点\n\n在删除 6 的情况下，左子树的最大节点为 4，右子树的最小节点为 7。你会发现，将它们换上这个位置，的确满足搜索二叉树的特性\n\n那么，怎么可以把这两个节点给替换上来呢？\n这一套操作其实挺麻烦的\n\n先找到需要删除的节点，会有下面 3 种情况：\n该节点只有左娃\n该节点只有右娃\n该节点左右都有\n\n\n如果是前两种情况（包括没有孩子的情况），我们只需要删除这个节点之后，让它的父亲指向它的孩子就行了（托管）\n只有左娃，父节点托管左娃\n只有右娃，父节点托管右娃\n\n\n左右都有孩子，需要找到左子树最大节点 &#x2F; 右子树最小节点，进行交换\n\n只是交换还远远不够，我们还需要链接这个最大 &#x2F; 最小节点的孩子（比如上图中 7 的情况）再删除掉被交换过去的指定节点\n\n// 删除去找左子树的最大节点，或者右子树的最小节点// 与需要删除的树进行交换，交换之后删除叶子节点bool Erase(const K&amp; key)&#123;    Node* prev = nullptr;    Node* cur = _root;    while (cur)    &#123;        if (key &gt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_right;        &#125;        else if (key &lt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_left;        &#125;        else        &#123;            if (cur-&gt;_left == nullptr)// 只有右娃            &#123;                if (cur == _root)                &#123;                    _root = _root-&gt;_right;                &#125;                else                &#123;                    if (prev-&gt;_left == cur)                    &#123;                        prev-&gt;_left = cur-&gt;_right;                    &#125;                    else &#123;                        prev-&gt;_right = cur-&gt;_right;                    &#125;                &#125;                delete cur;            &#125;            else if (cur-&gt;_right == nullptr)// 只有左娃            &#123;                if (cur == _root)                &#123;                    _root = _root-&gt;_left;                &#125;                else                &#123;                    if (prev-&gt;_left == cur)                    &#123;                        prev-&gt;_left = cur-&gt;_left;                    &#125;                    else &#123;                        prev-&gt;_right = cur-&gt;_left;                    &#125;                &#125;                delete cur;            &#125;            else // 左右都有孩子            &#123;                // 将 cur 和右子树的最小值节点进行交换                Node* minPrev = cur;                Node* minRight = cur-&gt;_right;                while (minRight-&gt;_left)                &#123;                    minPrev = minRight;                    minRight = minRight-&gt;_left;                &#125;                swap(minRight-&gt;_key, cur-&gt;_key);                if (minPrev-&gt;_left == minRight)                &#123;                    minPrev-&gt;_left = minRight-&gt;_left;                &#125;                else &#123;                    minPrev-&gt;_right = minRight-&gt;_left;                &#125;                delete minRight;            &#125;            return true;        &#125;    &#125;    return false;&#125;\n\n执行之后可以看到，删除之后的树依旧是一个搜索二叉树，中序遍历结果呈有序\n\n递归删除  写完了循环版本，再来个递归吧！\nbool _EraseR(Node*&amp; root, const K&amp; key)&#123;    // 根直接为空，返回 false    if (root == nullptr) &#123;        return false;    &#125;    if (key &gt; root-&gt;_key) &#123;        _EraseR(root-&gt;_right, key);    &#125;    else if (key &lt; root-&gt;_key) &#123;        _EraseR(root-&gt;_left, key);    &#125;    else     &#123;        Node* del = root;// 保存变量用于删除        if (root-&gt;_left == nullptr)// 只有右娃        &#123;            /*if (root == _root) &#123;\t\t\t\t\t_root = _root-&gt;_left;\t\t\t\t&#125;*/            // 这时候 root 是操作节点的别名，不需要单独对根节点进行处理            root = root-&gt;_right;        &#125;        else if (root-&gt;_right == nullptr)        &#123;            root = root-&gt;_left;        &#125;        else // 左右都有孩子        &#123;            // 将 cur 和右子树的最小值节点进行交换            Node* minRight = root-&gt;_right;            //while (minRight) //err            while (minRight-&gt;_left) // 判断的是 left，不然会走到空然后交换            &#123;                minRight = minRight-&gt;_left;            &#125;            swap(minRight-&gt;_key, root-&gt;_key);            return _EraseR(root-&gt;_right, key);        &#125;        delete del;        return true;    &#125;&#125;\n\n在最后一个情况中，我们巧妙地将问题化为了在指定节点的右子再次执行一次删除操作\n\n为什么在递归的操作中我们不需要单独处理 minPrev 呢？\n注意看函数的接口。删除的递归操作需要才用一个很巧妙的做法，使用了  引用参数，充分利用了函数传值时传引用的特点（别名）\nbool _EraseR(Node*&amp; root, const K&amp; key)\n\n这时候的节点 root 不仅是当前递归到的节点，同时也是上一个节点的左右节点的  别名。对该节点的操作会直接改变上一个节点的左右子树，就省去了我们手动操作的步骤！\n\n对 root 的修改会直接同步道上一个节点的孩子上\n\n怎么样，是不是超级赞！\n\n2.KVL 树2.1 概念KV 指代的是两个模板参数 key 和 value。其实现和上面的搜索二叉树完全相同，只需要修改一下模板参数，以及所有操作 key 的位置都需要添加第二个参数 value。\n\n源码实现见我的代码仓库 链接\n\n这么做的好处是，我们可以给一个 key 添加第二个绑定的参数了。一般把这种绑定关系称为 &lt;Key,Value&gt; 键值对\nKVL 树的特点如下：\n\n排序依据 key 来排序，而不是 value\nkey 不可以修改，但是 value 可以修改\n在保存键值关系的同时，去重 + 排序\n\n通过这两个参数的绑定关系，我们可以实现类似字典、水果出现次数等等问题的查找操作，有点类似于数组映射，但这种方法更加便捷\n\n2.2 示例  插入 4 个水果和其数量，中序遍历打印后，可以看到数据是以 key 为排序标准的。\n这里说明的是，string也是可以比较大小的，所以同样适用于搜索二叉树\n\n通过这种类似的绑定关系，我们甚至可以添加更多参数进入搜索二叉树。可以完成类似  学生管理系统 / 车牌管理系统  中学号车牌号和用户的绑定关系\n2.3 允许数据冗余  我们可以简单修改一下插入函数，来达到允许数据冗余的目的。即插入相同 key 的时候，判断 value，如果 value 也是相同则不插入，不同则插入。这样可以让 kvl 树中同一个 key 有多种对应关系，在字典多义词的时候有一定作用\n// 插入，通过传引用避免拷贝bool _InsertR(Node*&amp; root, const K&amp; key, const V&amp; value)&#123;    if (root == nullptr)    &#123;        root = new Node(key, value);        return true;    &#125;    if (root-&gt;_key &lt; key)        return _InsertR(root-&gt;_right, key, value);    else if (root-&gt;_key &gt; key)        return _InsertR(root-&gt;_left, key, value);    else&#123;        if (root-&gt;_value == value)            return false;        else&#123;            // 将相同数据插入在右边            return _InsertR(root-&gt;_right, key, value);        &#125;    &#125;&#125;\n\n插入了之后，我们删除也需要删除两次。\n\n这时候我们 EraseR 返回值为 bool 的价值就体现出来了，我们可以直接写一个循环来删除掉多个冗余键值\n\n\n结语  这两颗树的讲解到这里就结束啦，学习它们是为了后续学习 map/set 打基础哦！\n\n有什么问题欢迎在评论区提出！\n\n","categories":["遇见C++"],"tags":["数据结构","树","C++"]},{"title":"【C++】AVL 树（平衡搜索二叉树）","url":"/posts/3807693015/","content":"在上一篇 C++ 博客中，讲述了关于搜索二叉树以及 KVL 树的实现。也提到了搜索二叉树的最坏情况：插入的数据已经有序。\n而本篇博客涉及到的 AVL 树，又称  平衡搜索二叉树。就是为了解决搜索二叉树的最坏情况而生的。\n\n\n[TOC]\n1. 什么是 AVL 树  二叉搜索树虽然缩短了查找的效率，但是数据有序的时候，就会出现一边非常长的情况，导致原本的 O(logN) 时间复杂度被迫变成了O(N)\n平衡树也是搜索二叉树，其引入了一个  平衡因子  的概念，用于控制搜索二叉树的平衡。它会保证左右子树的高度之差（绝对值）不超过 1。当新插入节点导致高度之差超过 1 时，便会触发旋转，使得树的高度降低。\n\n简单说来：AVL 树能保证两边高度的相对平衡，这样就  稳定  了二叉搜索树的效率\n\n1.1 二叉搜索树的性质  一颗 AVL 树或空树，其有以下性质\n\n它的左右子树是 AVL 树\n左右子树的高度之差的绝对值不超过 1\n\n这里引入  平衡因子  来方便我们控制二叉树的高度。每一个节点都会有一个平衡因子，它的值是1/0/-1。如果平衡因子的值超过了 1，那么说明这个节点的子树已经不平衡，需要进行旋转。\n\n实际上，AVL 树不一定非要用平衡因子。我们可以用  计算树的高度  的方式来确认平衡因子，但是这样需要遍历左右子树，时间复杂度较高\n\n2. 实现一颗 AVL 树 2.1 AVL 树的节点 基本的概念理解之后，我们需要设计出一个节点的结构来。关于各个值的含义，可以参考下方的注释\n\n平衡搜索二叉树是一个“三叉链”。这代表每一个节点都有左右孩子，还有一个 prev 指针指向它的父节点。为了标识树是否平衡，准确来说是某个节点的左右子树是否平衡。我们需要引入一个“平衡因子”来进行判断，方便我们控制平衡\n\n左右子树高度相同  0\n左子树高于右子树  -1\n右子树高于左子树  1\n\n\ntemplate&lt;class K,class V&gt;struct AVLTreeNode&#123;\tpair&lt;K, V&gt; _kv;// 键值对\tAVLTreeNode&lt;K, V&gt;* _left;// 左子树\tAVLTreeNode&lt;K, V&gt;* _right;// 右子树\tAVLTreeNode&lt;K, V&gt;* _parent;// 父节点\t// 右子树 - 左子树的高度差\tint _bf;  // 平衡因子\tAVLTreeNode(const pair&lt;K, V&gt;&amp; kv)\t\t:_kv(kv),\t\t_left(nullptr),\t\t_right(nullptr),\t\t_parent(nullptr),\t\t_bf(0)\t&#123;&#125;&#125;;\n\n关于键值对的内容，在上篇博客的 KVL 树中有提到过 【传送门】\n\n2.2 AVL 树的插入（重要）因为 AVL 需要控制树的高度，其插入的时候就没有 KVL 树那么方便了。我们每次插入之后，都需要向上  更新并判断  树的平衡因子是否正常\n先来理清一下思路:\n\n如果是空树，new 一个新节点交给 root，无需进行后续操作\n插入新节点的时候，利用搜索二叉树的规则（在这里我采用了  左小右大  的规则）来找到新节点应该插入的位置，直接进行插入\n插入之后，需要向上更新平衡因子（利用父节点parent）\n如果该插入节点在父节点的  右边，平衡因子 +1\n如果在该节点的  左边，平衡因子 -1。\n\n\n更新了平衡因子之后，需要及时进行判断。如果平衡因子  等于 0，则不需要继续往上更新。如果平衡因子的  绝对值大于 1，说明当前就需要旋转了\n\n根据这个思路，我们可以先写出  插入  的一个基本框架\nbool Insert(const pair&lt;K, V&gt;&amp; kv)&#123;\t// 判断 root 为空，即空树\tif (_root == nullptr)\t&#123;\t\t_root = new Node(kv);\t\treturn true;\t&#125;\t//kv 树的操作\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;           // 利用 key 来判断，寻找待插入的位置\t\tif (cur-&gt;_kv.first &lt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (cur-&gt;_kv.first &gt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse&#123;\t\t\treturn false;\t\t&#125;\t&#125;\t// 找到位置后插入节点\tcur = new Node(kv);\tif (parent-&gt;_kv.first &lt; kv.first)\t&#123;\t\tparent-&gt;_right = cur;\t&#125;\telse\t&#123;\t\tparent-&gt;_left = cur;\t&#125;\tcur-&gt;_parent = parent;\t// 插入之后需要向上更新平衡因子\twhile (parent)\t&#123;\t\tif (cur == parent-&gt;_left) &#123;\t\t\tparent-&gt;_bf--;// 左 -1\t\t&#125;\t\telse&#123;\t\t\tparent-&gt;_bf++;// 右 +1\t\t&#125;\t\t// 更新了之后，需要判断是否继续更新，还是需要旋转\t\tif (parent-&gt;_bf == 0) &#123;\t\t\tbreak;// 为 0 代表高度没有变化，不需要继续更新\t\t&#125;\t\telse if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)\t\t&#123;\t\t\tcur = cur-&gt;_parent;// 向上更新\t\t\tparent = parent-&gt;_parent;\t\t&#125;\t\telse if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)\t\t&#123;\t\t\t// 旋转\t\t&#125;\t\telse\t\t&#123;\t\t\t// 插入之前 AVL 就存在不平衡子树\t\t\tassert(false);\t\t&#125;\t&#125;\treturn true;&#125;\n\n其中最复杂的部分：旋转，需要拿出来单独讲解一番\n\n下面是一个最简单的二叉树进行插入之后，平衡因子的变化。\n\n因为搜索二叉树需要保证两边的  高度之差不大于 1，所以此时我们的树还没有违背 AVL 树的规则。\n可如果我们继续往  右子树  插入节点呢？\n\n可以看到，最后一颗子树的根节点的平衡因子为 2，超过了 1。此时两边子树的高度差为 2，需要我们进行旋转操作\n2.2.1 左 &#x2F; 右单旋  为了简化，我们把上图的插入情况直接简化为下面的样子\n\n当我们在这棵树高度较高的那一侧的边缘插入的时候，就需要进行单旋。\n\n比如右边高，就是在  最右边的叶子处插入\n\n单旋的思路很好理解，下面以左单旋为例（蓝色代表新增节点）\n\n这里我们设置了 3 个不同的节点，分别是 prev 起始节点（即平衡因子大于 1 的节点）以及它的右子树subR、右子树的左子树subRL（即图中的 b 子树）\n\n需要做的操作，就是把 subRL 链接给 prev 的右，再将 prev 链接到 subR 的左\n因为 subRL 在prev的右侧，其的值肯定大于prev，所以这样链接是不会破坏搜索二叉树的结构的。\n\n旋转完成之后，我们需要把 prev 和subR的平衡因子都更新为 0\n\n右单旋的操作和左单旋的思路完全相同，只不过方向相反\n\n\n思路搞定了，下面就来写一个代码吧！\nvoid RotateL(Node* parent)// 左单旋&#123;    Node* prev = parent;    Node* subR = parent-&gt;_right;    Node* subRL = subR-&gt;_left;    // 用来记录当前 parent 的父亲，最后的链接需要    Node* ppNode = parent-&gt;_parent;    prev-&gt;_right = subRL;    if (subRL != nullptr)    &#123;// 不为空才能进行 parent 操作        subRL-&gt;_parent = prev;    &#125;    subR-&gt;_left = prev;    prev-&gt;_parent = subR;    if (prev == _root)    &#123;// 单独操作为根节点的情况        //subR-&gt;_parent = nullptr;        _root = subR;        _root-&gt;_parent = nullptr;    &#125;    else    &#123;        if (prev == ppNode-&gt;_left) &#123;            ppNode-&gt;_left = subR;        &#125;        else &#123;            ppNode-&gt;_right = subR;        &#125;        subR-&gt;_parent = ppNode;    &#125;    // 默认全都改成 0    subR-&gt;_bf = parent-&gt;_bf = 0;&#125;\n\n右单旋的代码和这个类似，这里就不贴出来了\n\n完整代码可以到我的代码仓库里面看哦！【Gitee】\n\n旋转的代码写好了，我们现在还需要了解的是，什么时候需要进行单旋？\n看图可以得知，当 prev 的平衡因子为 -2，subL 的平衡因子为 -1 的时候，需要进行一次右单旋\n\n同理，我们可以推断出一个结论，那就是当父节点的平衡因子的绝对值超过 1，其左 &#x2F; 右边节点的平衡因子为 1 且和父节点平衡因子的  正负相同  时，需要向另外一个方向进行单旋。\n左单旋  就是父节点为 2，其  右子树为 1，需要向另外一个方向  左进行单旋\n\n需要注意的是，虽然图里面画出来的 prev 是根节点，但实际上进行单旋的时候，prev 可能是另外一棵树的子树。在单旋的处理过程中，我们必须要保存 prev 的  父节点，并重新链接至subR\n// 插入函数的旋转部分else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)&#123;    if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1)    &#123;        RotateL(parent);    &#125;    else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1)    &#123;        RotateR(parent);    &#125;    else    &#123;        //……    &#125;    break;&#125;\n\n我们用下面的代码进行测试\nvoid TestAVLTree1()&#123;\tint a[] = &#123;9,8,7,6,5,4,3,2,1 &#125;;\tAVLTree&lt;int, int&gt; t;\tfor (auto e : a)\t&#123;\t\tt.Insert(make_pair(e, e));\t&#125;\tt.InOrder();\tcout &lt;&lt; endl;&#125;\n\n进行  中序打印，可以获取道下面的结果。可以看到数据已经有序\n\n在 VS2019 的调试窗口中可以看到，我们厂家的这棵树是符合平衡搜索二叉树的性质的\n\n\n2.2.2 左右 &#x2F; 右左双旋  上面的情况还算容易，一次单旋就能解决。那如果我们插入  不有序的数据  呢？\n\n可以看到中序打印的结果已经有序，可它符合平衡二叉树的规则吗？\n再插入一个 25，会发现触发了断言，说明 AVL 树的规则被破坏了\n\n就好比下面的这种情况，我们是以 15 6 7 这种非有序方式插入的，就会出现单旋完全处理不了的情况\n\n如果进行单旋会发生什么呢？\n\n可以看到，毫无变化。旋转了之后的节点依旧是违反 AVL 树的规则\n这时候我们就需要进行  两次循环  了！\n\n概念理解了之后，我们就可以直接来写代码了。\n因为本质上就是两次单旋，所以我们可以直接复用之前写好的单旋代码\nvoid RotateLR(Node* parent)// 左右&#123;    RotateL(parent-&gt;_left);    RotateR(parent);&#125;\n\n但事情远没有这么简单！\n在 2.2.1 单旋 的操作中，我们旋转完毕后会把 prev 和 subL 的平衡因子都改成了 0。在这种双旋的情况下，全改成 0 显然不符合要求。\n下面的情况，我们就需要在旋转之后，把 10 的平衡因子改成 -1，20 和 30 的平衡因子改成 0\n\n双旋的情况分为下面 3 种，我们可以直接用紫色框中所指的这个节点来判断属于哪一种情况，再针对性的处理！\n\n处理之后的结果如下\n\n其代码逻辑如下\n// 这种双旋转的情况，基本如下//   9// 7//   8// 必须要双旋转才能解决问题void RotateLR(Node* parent)// 左右&#123;    Node* prev = parent;    Node* subL = parent-&gt;_left;    Node* subLR = subL-&gt;_right;    int bf = subLR-&gt;_bf;    RotateL(parent-&gt;_left);    RotateR(parent);    if (bf == 0)    &#123;        prev-&gt;_bf = 0;        subL-&gt;_bf = 0;        subLR-&gt;_bf = 0;    &#125;    else if (bf == 1)    &#123;        subL-&gt;_bf = -1;        prev-&gt;_bf = 0;        subLR-&gt;_bf = 0;    &#125;    else if (bf == -1)    &#123;        subL-&gt;_bf = 0;        prev-&gt;_bf = 1;        subLR-&gt;_bf = 0;    &#125;    else &#123;        assert(false);    &#125;&#125;void RotateRL(Node* parent)// 右左&#123;    Node* prev = parent;    Node* subR = parent-&gt;_right;    Node* subRL = subR-&gt;_left;    int bf = subRL-&gt;_bf;    RotateR(parent-&gt;_right);    RotateL(parent);    if (bf == 0)    &#123;        prev-&gt;_bf = 0;        subR-&gt;_bf = 0;        subRL-&gt;_bf = 0;    &#125;    else if (bf == -1)    &#123;        subR-&gt;_bf = 1;        prev-&gt;_bf = 0;        subRL-&gt;_bf = 0;    &#125;    else if (bf == 1)    &#123;        subRL-&gt;_bf = 0;        subR-&gt;_bf = 0;        prev-&gt;_bf = -1;    &#125;    else &#123;        assert(false);    &#125;&#125;\n\n到这里我们就可以把插入函数给补全了！\n\n完整代码可以到我的代码仓库里面看哦！【Gitee】\n\n还是刚刚的测试用例，这一次我们可以看到，它已经没有报错了！\n\n\n2.3 AVL 树的搜索  本质上 AVL 树还是一个平衡二叉树，所以搜索肯定是少不了的！\n它的搜索和 KVL 树完全一致，利用 key 来进行搜索，定位 value。\n所以，我们可以直接搬过来用。\n// 因为 kvl 树我们需要修改 value，所以返回节点的指针Node* _FindR(Node* root, const K&amp; key)&#123;\tif (root == nullptr)\t\treturn nullptr;\tif (root-&gt;_kv.first &lt; key)\t&#123;\t\treturn _FindR(root-&gt;_right, key);\t&#125;\telse if (root-&gt;_kv.first &gt; key)\t&#123;\t\treturn _FindR(root-&gt;_left, key);\t&#125;\telse\t&#123;\t\treturn root;// 返回节点的指针\t&#125;&#125;\n\n上面的这个函数我们定义为私有，在公有里面定义一个下面的函数\n// 查找是通过 key 来进行的Node* FindR(const K&amp; key)&#123;\treturn _FindR(_root, key);&#125;\n\n测试一下可以看到，打印了全 0 的地址值，即nullptr，说明没有找到 34\n\n2.4 如何判断是否符合 AVL 树的性质  如果每一次我们都要用调试去看当前的代码是否符合二叉树的性质，未免有些太麻烦了\n下面我们有两种办法来简洁地判断！\n2.4.1 层序遍历（OJ 题）下面的代码是一道 OJ 题的答案，其要求是让我们把树每一层的节点都插入一个 vector，最后返回的是一个嵌套的vector&lt;vector&lt;int&gt;&gt;\n\n来自 https://leetcode.cn/problems/binary-tree-level-order-traversal/\n\n因为我们当前测试的用例都是 int 类型，所以这里就没有用模板参数。实际上我们应该改成 key 的类型\nvector&lt;vector&lt;int&gt;&gt; levelOrder() &#123;\tvector&lt;vector&lt;int&gt;&gt; vv;\tif (_root == nullptr)\t\treturn vv;\tqueue&lt;Node*&gt; q;\tint levelSize = 1;\tq.push(_root);\twhile (!q.empty())\t&#123;\t\t// levelSize 控制一层一层出\t\tvector&lt;int&gt; levelV;\t\twhile (levelSize--)\t\t&#123;\t\t\tNode* front = q.front();\t\t\tq.pop();\t\t\tlevelV.push_back(front-&gt;_kv.first);\t\t\tif (front-&gt;_left)\t\t\t\tq.push(front-&gt;_left);\t\t\tif (front-&gt;_right)\t\t\t\tq.push(front-&gt;_right);\t\t&#125;\t\tvv.push_back(levelV);\t\tfor (auto e : levelV)\t\t&#123;\t\t\tcout &lt;&lt; e &lt;&lt; &quot; &quot;;\t\t&#125;\t\tcout &lt;&lt; endl;\t\t// 上一层出完，下一层就都进队列\t\tlevelSize = q.size();\t&#125;\treturn vv;&#125;\n测试一下，可以看到每一层的结果，符合我们 AVL 树的性质\n\n2.4.2 检查平衡因子  这里我们用两个递归函数，通过计算子树的高度，来判断是否满足 AVL 树的性质。\n只要两个子树的高度差大于 1，就说明不是 AVL 树\n// 计算高度int _Height(Node* root)&#123;    if (root == nullptr)        return 0;    int lh = _Height(root-&gt;_left);    int rh = _Height(root-&gt;_right);    // 如果左子树高于右子树，就返回左子树 +1（根）    return lh &gt; rh ? lh + 1 : rh + 1;&#125;// 判断是否为平衡二叉树bool _IsBalanceTree(Node* root)&#123;    // 空树也是 AVL 树    if (nullptr == root)        return true;    // 计算 pRoot 节点的平衡因子：即 pRoot 左右子树的高度差    int leftHeight = _Height(root-&gt;_left);    int rightHeight = _Height(root-&gt;_right);    int diff = rightHeight - leftHeight;    // 如果计算出的平衡因子与 pRoot 的平衡因子不相等，或者    // pRoot 平衡因子的绝对值超过 1，则一定不是 AVL 树    if (abs(diff) &gt;= 2)    &#123;        cout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot; 节点平衡因子异常 &quot; &lt;&lt; endl;        return false;    &#125;    if (diff != root-&gt;_bf)    &#123;        cout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot; 节点平衡因子不符合实际 &quot; &lt;&lt; endl;        return false;    &#125;    // pRoot 的左和右如果都是 AVL 树，则该树一定是 AVL 树    return _IsBalanceTree(root-&gt;_left)        &amp;&amp; _IsBalanceTree(root-&gt;_right);&#125;\n\n\n\n2.5 利用随机值和顺序值进行测试  下面我们分别利用随机值和顺序值测试 AVL 树的正确性\nvoid TestAVLTree2()&#123;\tconst size_t N = 1024*1024;\tvector&lt;int&gt; v;\tv.reserve(N);\tsrand(time(0));// 使用随机数\tfor (size_t i = 0; i &lt; N; ++i)\t&#123;\t\tv.push_back(rand());\t\t//v.push_back(i);\t&#125;\tAVLTree&lt;int, int&gt; t;\tfor (auto e : v)\t&#123;\t\tt.Insert(make_pair(e, e));\t&#125;\tcout &lt;&lt; &quot; 是否平衡?&quot; &lt;&lt; t.IsBalanceTree() &lt;&lt; endl;\tcout &lt;&lt; &quot; 高度:&quot; &lt;&lt; t.Height() &lt;&lt; endl;&#125;\n\n利用随机数测试的结果如下\n\n顺序插入的结果如下\n\n没有问题辣！\n2.6 AVL 树的删除AVL 树的删除和 KVL 树是基本相同的，但是我们需要更新平衡因子。\n\n如果删除的是左节点，平衡因子 +1\n如果删除的是右节点，平衡因子 -1\n\n当我们遇到平衡因子错误（绝对值大于 1）就需要进行旋转\n\n因为搜索树中一般不会进行删除，效率很低，所以这里就不写了！（懒）\n\n2.7 二叉树性能  在一些时候，搜索二叉树的性能并不会很高\n\n比如当我们插入的元素已经有序，或者基本有序的时候，二叉树的性能就和普通的容器差距不大了\nAVL 树更适合于插入的元素不会被改变的情况。如果插入的元素需要经常被修改，那么也不太适合。（比如删除的时候，AVL 树的平衡因子可能需要一直向上到根，时间复杂度不亚于二次插入）\n\n结语  那么本篇关于 AVL 树的博客到这里就结束拉！\n有什么问题欢迎在评论区提出哦！\n\n","categories":["遇见C++"],"tags":["数据结构","树","C++"]},{"title":"【C++】STL map_set","url":"/posts/97886566/","content":"本篇博客让我们来了解一下 STL 库里面的 map&#x2F;set 的使用，并尝试用自己写的 红黑树  封装一个类似的 map/set 出来\n\n\n\n所用编译器：VS2019\n\n[TOC]\n1 setset 就是二叉搜索树中只有单个 key 的树，它有下面的函数可供使用\n1.1 构造函数、迭代器  构造函数、迭代器什么的都很简单，在这里就提到了，和其他 STL 基本一致\n\n\n1.2 节点计数 sizeset 自带节点计数，我们可以之间获取二叉树中节点的个数，或判断 set 是否为空\n\n1.3 插入删除  插入删除等函数在这里不过多解释，使用方法和 string、vector 完全一致。如果大家的 stl 是从 string 一路学习过来，那么对于这些函数的使用肯定没有问题！\n\n插入可以插入单个元素，其返回一个键值对包含这个元素的迭代器 + 一个 bool 标识是否插入成功。你还可以用  相同类型set 的迭代器区间进行插入操作\n\nset&lt;int&gt;t1;// 定义 set 对象 t1for (int i = 0; i &lt;= 3; ++i) &#123; // 插入 1 2 3 4 5 6\tt1.insert(i);&#125;\n\n删除可以删除：\n\n指定迭代器位置\n指定元素\n迭代器区间\n\n\n不过对于二叉搜索树而言，删除一直都不是高频操作 + 效率较低。这也是为什么在实现二叉搜索树的时候，我没有去实现删除操作。\n\n其实主要是删除操作比较难理解，特别是在平衡二叉树中\n\n1.4 查找 find作为搜索二叉树，查找才是最重要的一个函数。该函数会返回一个迭代器，指向元素的位置。\n\n如果没有找到这个元素，则返回 end 迭代器\n\n所以我们只需要在使用这个函数的时候，加上对于 end() 迭代器  的判断，只要不等于 end 说明找到了该元素，进行访问\nset&lt;int&gt; v1;v1.insert(1);v1.insert(3);v1.insert(6);set&lt;int&gt;::iterator it = v1.find(3);if (it != v1.end())&#123;\tcout &lt;&lt; &quot; 找到了 &quot;&lt;&lt; *it &lt;&lt; endl;&#125;\n\n因为 set 是只有 key 的搜素二叉树，在获取到迭代器之后，我们直接使用 *it 进行解引用即可得到节点的值\n\n而当我们查找内部不存在的元素，也可以得知没有找到\n\n\n1.5 count这个函数的作用是查找二叉树中 value 值的个数。但由于默认的 set 不支持键值冗余，插入相同的键值会被忽略掉。所以这个 count 在这里只有 0 和 1 两个返回值，也只能用来判断该值是否存在。\n\n但是因为 count 需要遍历所有元素，所以在 set 中，它的效率比 find 是更差的。\nmultiset 支持键值冗余  这个函数真正起作用的地方是在multiset，人如其名，这是一个支持键值冗余的 set，成员函数完全相同。第一个模板变量是 set 的参数类型，第二个是比较函数，第三个是一个空间配置器\ntemplate &lt; class T,                        // multiset::key_type/value_type           class Compare = less&lt;T&gt;,        // multiset::key_compare/value_compare           class Alloc = allocator&lt;T&gt; &gt;    // multiset::allocator_type           &gt; class multiset;\n\n\n\n1.6 lower&#x2F;upper_bound\niterator lower_bound (const value_type&amp; val);   // 返回指向等于或大于指定键值元素的迭代器iterator upper_bound (const value_type&amp; val);   // 返回指向大于指定键值元素的迭代器\n\n这两个函数的作用是返回一个和我们  指定的元素相同 &#x2F; 或者比指定元素更大（第一个更大的键值）的迭代器\n\n\n如果更大的键值或者它本身不存在，就会返回一个 end 迭代器，这一点和 find 一样\n\n\n set 基本用得到的迭代器这里都提了一嘴，接下来康康 map\n2 mapmap 同样有一个支持键值冗余的multimap，后面就不说辣\n\n前面关于构造函数都暂且不提，直接来看 map 和 set 最不一样的地方，插入\n2.1 插入 map 是一个 kvl 二叉搜索树，其所有元素都是一个键值对。这就要求我们插入的时候，需要先make_pair 建立一个键值关系，再插入进 map 中。\n\n也因为迭代器获取到的是一个键值对，所以访问的时候需要指定键值对的 first 和 second。map 是用 first 进行排序的，所以 first 是不能修改的，但是 second 可以\n2.2 下标访问 &#x2F;atmap 相比于 set，最特殊的一点就是它可以用下标直接进行访问\nmap[key]=value;\n\n所以我们可以使用这种方式非常方便的修改 value\n\n和重载了下标的 vector 一样，map 也有一个 at 函数（C++11 新增）在之前 vector 的函数中，我没有提到这两个的区别。在这里说一下\n\noperator[]和 at的主要区别在于 operator[]不做边界检查，而 at 会做边界检查。\n\n由于 operator[] 不做边界检查， 那怕越界了也会返回一个引用，当然这个引用是错误的引用，如何不小心调用了这个引用对象的方法，会直接导致应用退出。\n而由于 at 会做边界检查，如果越界，会抛出异常，应用可以 try/catch 这个异常，进行异常管理，而应用还能继续运行。\n\nat 的使用和下标不太一样，和成员函数的使用方法一致。我们可以来试一试\n\n\n在这里如果我们下标访问第 11 个元素，也不会出问题。因为下标访问会自动创建一个对应的 key，而 value 会调用默认构造函数。int 类型也是有默认构造的，返回一个 0\n\n但如果我们不用下标，直接用 at 访问第 11 个元素，就会报 debug 错误，这便是它们俩的区别所在\n\nmap 和 set 有区别的地方主要就是上面两个函数，其余都是完全相同\n2.3 下标访问自定义类型必须要有默认构造函数  如题，如果你想在 map 里面插入一个自定义类型，使用 emplace 和 insert 的时候不会出现问题，但是使用 [] 重载就会有编译错误。\nclass mytestint&#123;public:    mytestint(uint16_t id, uint16_t pr) : _id(id), _pr(pr) &#123;&#125;    uint16_t get_id() const    &#123;        return _id;    &#125;private:    uint16_t _id;    uint16_t _pr;&#125;;\n\n这里我有一个自定义类型，内部只实现了一个有参构造函数，没有无参构造。\n此时调用下标重载，就会出现问题\nmap&lt;uint16_t, mytestint&gt; _test_map;void test_emplace(uint16_t id, uint16_t pr, const std::string &amp;info)&#123;    mytestint temp = &#123;id, pr&#125;;    auto t = _test_map.emplace(id, temp); // good    auto s = _test_map.insert(&#123;pr, temp&#125;);// good    _test_map[id] = temp; // error    auto h = _test_map[pr]; // error&#125;\n\n编译这个代码，会出现如下报错（如果去掉最后两个下标的访问，只用 insert 和 emplace 是不会有报错的）\n/usr/include/c++/11/tuple:1820:9: error: no matching function for call to ‘mytestint::mytestint()’ 1820 |         second(std::forward&lt;_Args2&gt;(std::get&lt;_Indexes2&gt;(__tuple2))...)      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~In file included from test.cpp:1:src/main.hpp:51:5: note: candidate: ‘mytestint::mytestint(uint16_t, uint16_t)’   51 |     mytestint(uint16_t id, uint16_t pr) : _id(id), _pr(pr) &#123;&#125;      |     ^~~~~~~~~src/main.hpp:51:5: note:   candidate expects 2 arguments, 0 providedsrc/main.hpp:47:7: note: candidate: ‘constexpr mytestint::mytestint(const mytestint&amp;)’   47 | class mytestint      |       ^~~~~~~~~src/main.hpp:47:7: note:   candidate expects 1 argument, 0 providedsrc/main.hpp:47:7: note: candidate: ‘constexpr mytestint::mytestint(mytestint&amp;&amp;)’src/main.hpp:47:7: note:   candidate expects 1 argument, 0 providedmake: *** [makefile:2: test] Error 1\n\n如果给 mytestint 类添加一个默认构造，则不会有编译错误\nmytestint() = default;\n\n3. 模拟实现  这里主要以 KV 键值对的 map 为例，set 只需要修改 keyofValue 和它自己的模板参数即可\n3.1 康康 STL 源码  利用红黑树实现 map 和 set 之前，我们需要先来思考一个问题：我们自己写的红黑树只有一个 KV 键值对，那么要怎么判断封装的是 map 还是只有 key 的 set 呢？\n\n先来看看 STL 库的源码吧！【链接】\n\n在 map.h 的第 68 行可以看到，实际上库函数里面的 map 和 set 都只是封装了红黑树\n\n再去找红黑树的头文件，就能看到其与我们实现的不同。这里面的红黑树总共有 5 个模板参数，除去最后一个用来申请内存空间的 alloc，其余 4 个都有其不同的用处\n\n而其中的 value 是用来构造红黑树节点的参数\n\n看起来好像差不多对吧？可再回头看看 map，其传入的 value 是一个pair！\n\n实际上，库中的红黑树，并不是一个简单的 kvl，其 k 并不是真正用于比较的 k，而是依靠第三个模板参数 keyofvalue，以及我们传入的  比较函数compore 来进行比较的\n\n说人话就是：RBtree 不会判断你是 map 还是 set，而是在 map 和 set 的封装端，根据数据的不同类型，传入对应的比较函数，以及键值。\n\n比如 set 的 keyofvalue 就是它自己的 key\n而 map 的 keyofvalue 是pair.first\n\n因为库函数里面 pair 的比较，是会比较 first 之后，再比较 second 的。\n\n这和我们搜索二叉树的需求不太符合，所以 STL 库里面就需要写一个比较大小的仿函数，只针对 pair 的 first 进行严格比较，以保证稳定性\n\n3.2 模拟实现的基础框架  如果我们自己模拟实现，则可以依据下面的模板进行操作\n// 模板参数 V 决定红黑树存什么数据// set: RBTree&lt;K, K&gt;// map: RBTree&lt;K, pair&lt;K, V&gt;&gt;// KeyOfV: 取出 V 对象中 key 的仿函数template&lt;class K, class V, class KeyOfV&gt;\n\n而节点类也需要进行对应的修改，不再默认创建一个键值对。而是直接用 V 来创建一个基本的类型，这就和最基础的搜索二叉树相同。\ntemplate&lt;class V&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;V&gt;* _left;\tRBTreeNode&lt;V&gt;* _right;\tRBTreeNode&lt;V&gt;* _parent;\tV _data;\t//AVL 树的平衡因子，在红黑树中为颜色\tColor _col;\t// 插入节点的时候，默认为红色\t// 因为这个满足性质 3 且不会破坏性质 4\tRBTreeNode(const V&amp; data)\t\t:_data(data),\t\t_left(nullptr),\t\t_right(nullptr),\t\t_parent(nullptr),\t\t_col(RED)\t&#123;&#125;&#125;;\n\n3.3 修改插入的代码  因为新增了模板参数，所以这里我们也不能通过 kv first 进行键值的比较了。我们需要里利用模板参数中的 KeyOfV 仿函数来进行比较的操作。\n在这里，先给出 map 和 set 两种 KeyOfV 仿函数的实现\nstruct MapKeyOfV&#123;    const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)    &#123;        return kv.first;//map 是键值对，需要提供 kv 的 first 进行比较    &#125;&#125;;struct SetKeyOfV&#123;    const K&amp; operator()(const K&amp; key)    &#123;        return key;//set 只有一个键值    &#125;&#125;;\n\n有了这个仿函数，我们只需要实例化一个对象，然后将原有的比较替换成仿函数在进行比较即可！\npair&lt;iterator,bool&gt; Insert(const V&amp; data)&#123;    // 判断 root 为空，即空树    if (_root == nullptr)    &#123;        _root = new Node(data);        _root-&gt;_col = BLACK;// 这里必须要手动给黑色        return make_pair(iterator(_root),true);    &#125;    //kv 树的操作    Node* parent = nullptr;    Node* cur = _root;    while (cur)    &#123;        // 利用 key 来判断，寻找待插入的位置        if (kov(cur-&gt;_data)&lt; kov(data))        &#123;            parent = cur;            cur = cur-&gt;_right;        &#125;        else if (kov(cur-&gt;_data) &gt; kov(data))        &#123;            parent = cur;            cur = cur-&gt;_left;        &#125;        else &#123;            return make_pair(iterator(cur), false);// 构造一个迭代器返回        &#125;    &#125;    // 找到位置后插入节点    cur = new Node(data);    Node* newnode = cur;    if (kov(parent-&gt;_data) &lt; kov(data))    &#123;        parent-&gt;_right = cur;    &#125;    else    &#123;        parent-&gt;_left = cur;    &#125;    cur-&gt;_parent = parent;    // 插入之后需要向上更新颜色, 只有出现连续红色之后才需要更新    while (parent &amp;&amp; parent-&gt;_col==RED)    &#123;        Node* grandpa = parent-&gt;_parent;// 祖父        assert(grandpa);// 祖父为空不需要进行操作        //p 是 g 的左        if (parent == grandpa-&gt;_left)        &#123;            Node* uncle = grandpa-&gt;_right;            // 情况 1：插入后 p 是红，u 存在且是红（不需要旋转）            if (uncle &amp;&amp; uncle-&gt;_col == RED)            &#123;                uncle-&gt;_col = BLACK;                parent-&gt;_col = BLACK;                grandpa-&gt;_col = RED;// 祖父变成红                // 继续向上调整                //cur = cur-&gt;_parent;                //parent = parent-&gt;_parent;                cur = grandpa;                parent = cur-&gt;_parent;            &#125;            else//(uncle &amp;&amp; uncle-&gt;_col == BLACK)            &#123;                // 情况 2：插入后 p 为红，u 存在且为黑（需要单旋）                if (cur == parent-&gt;_left)                &#123;                    RotateR(grandpa);// 因为 p 在 g 的左边，所以右旋                    parent-&gt;_col = BLACK;                    grandpa-&gt;_col = RED;                &#125;                else//cur == parent-&gt;_right                &#123;                    // 情况 3：不是在同一侧，双旋                    //   g                    // p                    //   c                    RotateL(parent);                    RotateR(grandpa);                    grandpa-&gt;_col = RED;// 祖父改成红色                    cur-&gt;_col = BLACK;// 自己成为了这里的根，需要改成黑的                &#125;                break;            &#125;        &#125;        else &#123;            Node* uncle = grandpa-&gt;_left;            // 情况 1：插入后 p 是红，u 存在且是红（不需要旋转）            if (uncle &amp;&amp; uncle-&gt;_col == RED)            &#123;                uncle-&gt;_col = BLACK;                parent-&gt;_col = BLACK;                grandpa-&gt;_col = RED;// 祖父变成红                // 继续向上调整                cur = grandpa;                parent = cur-&gt;_parent;            &#125;            else//(uncle &amp;&amp; uncle-&gt;_col == BLACK)            &#123;                // 情况 2：插入后 p 为红，u 存在且为黑（需要单旋）                if (cur == parent-&gt;_right)                &#123;                    RotateL(grandpa);// 因为 p 在 g 的左边，所以右旋                    parent-&gt;_col = BLACK;                    grandpa-&gt;_col = RED;                &#125;                else//cur == parent-&gt;_left                &#123;                    // 情况 3：不是在同一侧，双旋                    //   g                    //\t\tp                    //   c                    RotateR(parent);                    RotateL(grandpa);                    grandpa-&gt;_col = RED;// 祖父改成红色                    cur-&gt;_col = BLACK;// 自己成为了这里的根，需要改成黑的                &#125;                break;            &#125;        &#125;    &#125;    // 不管是什么情况，最后都把根改成黑，符合条件 2    _root-&gt;_col = BLACK;    return make_pair(iterator(newnode), true);&#125;\n\n这里说明一下为何要把返回值替换成  键值对 。因为在实际操作的时候，我们需要获取道新插入元素的 迭代器（迭代器的模拟实现会在后面提及），以方便在插入后进行修改 value 的操作。\n\n比如我们默认插入的是一个空字符串，在进行一些判断之后，再重新给这个键值的 value 进行修改（仅限于 map 的情况）\n\n如果不返回一个迭代器，那么想修改这个键值，就只能通过 find 函数查找后再进行修改，相对有些麻烦。\n3.4 迭代器✨这一部分是比较难理解的迭代器操作，主要就是在一个二叉树中应该如何进行迭代器的 ++/-- 操作。\n3.4.1 加减操作  如果你看过我之前的 stl 博客，那么你应该还记得，我们的模拟实现  迭代器  其实就是用  指针  来进行的。迭代器的使用方法也和指针相差无几。\n在此处我们选择使用中序遍历来进行迭代器的操作。中序遍历的基本情况就是  左根右，只不过我们这里不再能使用递归进行操作了，而需要使用迭代的方法。\n\n上图中 cur 遍历到了右子树，其左右子树都为空。这时候我们需要返回到的是根节点，准确来说是祖父节点——吗？要是 cur 的父亲 prev 不是 g 节点的左子树，我们就不能直接返回 g 进行打印！而需要返回 g 的左子树。\n总结出来的规律如下，当我们执行 ++ 操作的时候：\n\n如果右节点为空，当前节点是父亲的右侧，就需要继续往上找（我们需要找到父亲左侧的那个节点）\n如果右子树不为空，找右子树的最左节点。\n\n在上图中，prev就是 g 的左子树，所以我们只需要找到 prev 就行了。然后因为我们的 prev 的右子树已经遍历过，所以这时候就需要往上。因为 g 是根节点，所以就需要返回 g 的右子树的最左节点，也就是下图中的位置\n\n而当我们做到最右侧的节点时，再次 ++ 的时候其实已经遍历完了。这时候右子树为空，开始往上找父亲是祖父左的哪一个。这时候会一直找到根，而根的父亲为空，停止遍历\n\n转换为代码如下\nSelf&amp; operator++()&#123;\tif (_node-&gt;_right == nullptr)\t&#123;\t\tNode* cur = _node;\t\tNode* parent = cur-&gt;_parent;\t\t// 只要当前节点是父亲的右侧，就需要继续往上找\t\t// 我们需要找到是父亲左侧的那个节点。\t\twhile (parent &amp;&amp; parent-&gt;_right == cur)\t\t&#123;\t\t\tcur = cur-&gt;_parent;\t\t\tparent = parent-&gt;_parent;\t\t&#125;\t\t// 如果不符合 while 的条件，就说明\t\t//1 父亲为空（根)\t\t//2 如果 cur 是父亲的左，那就直接将 node 设置为父亲\t\t_node = parent;\t&#125;\telse\t&#123;\t\t// 右子树不为空，找右子树的最左节点\t\tNode* subLeft = _node-&gt;_right;\t\twhile (subLeft-&gt;_left)\t\t&#123;\t\t\tsubLeft = subLeft-&gt;_left;\t\t&#125;\t\t// 最左节点\t\t_node = subLeft;\t&#125;\treturn *this;&#125;\n\n\n进行 -- 操作的时候则是完全相反的情况。我们需要找到父亲是祖父节点右边的那一个。如果父亲是祖父的左，那就继续往上找。\n\nSelf&amp; operator--()&#123;    if (_node-&gt;_left == nullptr)    &#123;        Node* cur = _node;        Node* parent = cur-&gt;_parent;        // 依据中序的顺序，-- 就是和 ++ 反过来。需要找节点是父亲的右边的哪一个        // 如果是父亲的左就继续往上找        while (parent &amp;&amp; cur == parent-&gt;_left)        &#123;            cur = cur-&gt;_parent;            parent = parent-&gt;_parent;        &#125;        // 指向当前的父亲        _node = parent;    &#125;    else    &#123;        // 左子树的最右节点        Node* subRight = _node-&gt;_left;        while (subRight-&gt;_right)        &#123;            subRight = subRight-&gt;_right;        &#125;        _node = subRight;    &#125;    return *this;&#125;\n\n3.4.2 套上完整迭代器模板  完成了迭代器的加减操作后，我们只需要套上之前模拟实现的类似模板，再添加参数到红黑树的类中。即可配套好一个迭代器！\ntemplate&lt;class V, class Ref, class Ptr&gt;struct __RBTreeIterator&#123;\ttypedef RBTreeNode&lt;V&gt; Node;\ttypedef __RBTreeIterator&lt;V, Ref, Ptr&gt; Self;\tNode* _node;// 当前指向的节点\t__RBTreeIterator(Node* node)\t\t:_node(node)\t&#123;&#125;\tRef operator*()\t&#123;\t\treturn _node-&gt;_data;\t&#125;\tPtr operator-&gt;()\t&#123;\t\treturn &amp;_node-&gt;_data;\t&#125;\t// 省略 ++ 和 -- 的代码\tbool operator!=(const Self&amp; s) const\t&#123;\t\treturn _node != s._node;\t&#125;\tbool operator==(const Self&amp; s) const\t&#123;\t\treturn _node == s-&gt;_node;\t&#125;&#125;;\n\n\n完整代码请参考我的Gitee 仓库\n\n3.4.3 添加参数到红黑树类中  我们需要把迭代器写入红黑树的类，并附上普通迭代器和 const 的两个版本，提供 begin 和end函数即可。\n// 迭代器封装，const 和普通版本typedef __RBTreeIterator&lt;V, V&amp;, V*&gt; iterator;typedef __RBTreeIterator&lt;V, const V&amp;, const V*&gt; const_iterator;iterator Begin()&#123;\tNode* subLeft = _root;\twhile (subLeft &amp;&amp; subLeft-&gt;_left)\t&#123;\t\tsubLeft = subLeft-&gt;_left;\t&#125;\treturn iterator(subLeft);&#125;iterator End()&#123;\treturn iterator(nullptr);&#125;const_iterator Begin() const&#123;\tNode* subLeft = _root;\twhile (subLeft &amp;&amp; subLeft-&gt;_left)\t&#123;\t\tsubLeft = subLeft-&gt;_left;\t&#125;\treturn const_iterator(subLeft);&#125;const_iterator End() const&#123;\treturn const_iterator(nullptr);&#125;\n\n\n可以看到，迭代器已经可以正常使用了！\n\n这里的测试环节最好把自己写的 map 套进一个命名空间中，不然就会用到 stl 库里面的 map\n\n迭代器写好之后，范围 for也是可以用的\n\n3.5 重载下标 map 非常特殊的一点就是，可以直接用map[key]=value 来修改 value 的内容。我们模拟实现的时候当然不能落下这个了！\n其实操作起来非常简单。我们只需要直接调用插入，如果键值存在也会返回当前键值的迭代器。键值不存在就能直接插入，返回新插入元素的迭代器。这也是之前为啥 insert 函数没有直接用 bool 做插入的返回值的原因\n// 重载下标V&amp; operator[](const K&amp; key)&#123;    pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));    return ret.first-&gt;second;// 返回的是一个引用，所以可以直接修改&#125;\n\n因为我们返回的是 V 的引用，所以可以直接用 = 进行修改！\n测试一下，咩有问题 OJBK👍\n\nset 的模拟实现更为简单，这里就不贴出来辣！大家可以去我的 gitee 看源码，有啥问题可以评论提出！\n\n4. 更多操作 4.1 用 set 得出两组数据的重合处 假设有两个文件，我们现需要找到这两个文件的重合处\n\n设置两个 set，分别插入两个文件的内容\n同时遍历两个 set（从小到大）\n如果两个 set 的 key 相同，则取出这个相同值，两个 set 一起 ++\n如果不相同，则 ++ 那个小的 key\n\n\n其中一个 set 结束遍历，即代表重合处查找完毕！\n\n结语  最近感觉自己真的很忙，但又不知在忙什么。事情一个接着一个，虽然学校的课不算多，但事情真的没少多少。\n有些事情自己又有拖延症，再加上作息不规律（指下午一睡睡 3h），浪费了好多时间……\n\n","categories":["遇见C++"],"tags":["数据结构","树","C++"]},{"title":"【C++】继承多态详解","url":"/posts/3933786088/","content":"在之前的 CPP 大作业中，为了应付期末（是这样的）关于继承和多态部分的内容只是  草草过了一遍，并没有深挖背后的实现原理，以及使用的时候一些注意事项。\n本篇博客是对类和对象  继承多态  部分的深化！\n\n\n[TOC]\n0. 什么是封装  面向对象的  三大特性：封装、继承、多态\n\n面向对象还有 反射（C++ 中没有）、抽象 等特性\n\n封装：\n\n不想让用户在类外访问的成员设计成私有，允许访问的设计成公有。相比 C 语言没有类和访问管理相比，封装能提高设计的安全性和完整性。\nC 语言中，如果设计的不好，不规范编写的代码容易出现错误访问 struct 结构体中的成员。\n同时，C++ 中的  迭代器  设计，也能给一批容器提供  基本相同的访问接口 ，让用户能使用相同的代码， 在不暴露容器底层结构  的前提下访问容器中的值。\n暴露底层结构会提高容器的使用成本，代码也比较复杂，不同数据结构也不一样。\nstack/queue/prioritiy_queue的适配器形式，能弄出来我们想要的东西，这也算是一种封装\n\n1. 继承派生关系  继承是提高代码复用性的一个重要手段。它允许我们在保持基类原有属性的基础上，对其进行一定的扩张，增加不同的功能以应对实际情况。\n比如对于一个人来说，其都会有性别、年龄、身分证号等等信息。但不同职业就还会包含不同职业的特殊信息。这时候就可以通过继承，在基础一个公民的基本信息的同时，再去处理每一个职业的独立信息。这也实现了类在一定程度上的复用，减少了代码复杂性。\n与其相似的增加代码复用性的语法，还有  模板\n1.1 基本用法  继承和派生是父与子的关系，其中子类拥有父类成员的同时，还会拥有自己的成员\n\n继承是一个特殊的语法，用于多个类有公共部分的时候\n父类：基类\n子类：派生类\n\n// 举例：网站的公共部分class ART &#123;public:\tvoid header()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; &quot; 归档 &quot; &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;\tvoid footer()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 关于我们 &quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot; 网站访问量 &quot; &lt;&lt; endl;\t&#125;\tvoid func()// 文章页面\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; endl;\t&#125;&#125;;class LINK &#123;public:\tvoid header()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; &quot; 归档 &quot; &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;\tvoid footer()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 关于我们 &quot; &lt;&lt; &quot; 网站访问量 &quot; &lt;&lt;endl;\t&#125;\tvoid func()// 友链页面\t&#123;\t\tcout &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n在上面的情况中，ART 和 LINK 类中都有网站的公共部分，这时候就出现了代码的重复。继承的出现就是用于解决这个问题的\n// 下面使用继承的方式来写，WEB 类是网站的公共部分class WEB &#123;public:\tvoid header()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; &quot; 归档 &quot; &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;\tvoid footer()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 关于我们 &quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot; 网站访问量 &quot; &lt;&lt; endl;\t&#125;&#125;;//ART、LINK 是两个子类，继承了 WEB 的公共部分// 这样就减少了代码量class ART : public WEB&#123;public:\tvoid func()// 文章页面\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; endl;\t&#125;&#125;;class LINK : public WEB &#123;public:\tvoid func()// 友链页面\t&#123;\t\tcout &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n测试可以发现，ART 和 LINK 作为派生类，在继承了基类 WEB 的成员的基础上，还拥有了它们独特的单独成员\n\n同一个类可以同时继承多个基类\nclass C : public A,public B&#123;//.....&#125;;\n\n1.2 权限问题  继承有 3 中类型：public、private、protected。这里会显示出类中 protected 权限和 private 权限的区别\nclass A&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\n当我们分别用上面三种方式对类 A 进行继承的时候，得到的结果是不同的\n\n用什么继承方式，派生类中继承的基类成员就变成什么类型\n不管用什么继承方式，都无法访问基类中的  私有  成员\n可以使用 Min(成员在基类中的访问限定符, 继承方式) 来计算某一个成员在子类中的访问限定符是什么。\n\n\n关于权限问题，我们还需要了解下面几点：\n\n基类的私有成员在派生类中不可见，但实际上它也被继承过去了。但是编译器和语法的限制让我们无法访问。\n保护限定符由此出现，如果在基类中的成员不想被外界直接访问，但又需要子类中访问，则可以定义为保护\nclass 默认继承方式为私有，struct 默认继承方式为保护\n实际中我们一般使用 public 继承，保护 &#x2F; 私有方式不利于维护和拓展\n\n1.3 同名问题（作用域）在继承体系中，基类和子类都有自己  独立的作用域\n当基类和派生类中出现同名成员函数或者同名成员变量时，会出现冲突。这时候编译器会做一定的处理：直接访问变量名和函数名的时候，优先访问派生类自己的成员，而屏蔽掉基类的。\n这种情况被称之为  隐藏：\n\n函数名相同构成隐藏（并非重载）\n成员变量名相同构成隐藏\n\n实际操作中，强烈  不建议写同名的成员，不管是成员函数还是成员变量\n// 继承同名成员的处理//\t普通的同名成员class DAD1 &#123;public:\tDAD1()\t&#123;\t\t_a = 100;\t&#125;\tvoid func()// 同名函数\t&#123;\t\tcout &lt;&lt; &quot;DAD func&quot; &lt;&lt; endl;\t&#125;\tvoid func(int i)\t&#123;\t\tcout &lt;&lt; &quot;DAD func int: &quot; &lt;&lt; i &lt;&lt; endl;\t&#125;\tint _a;// 基类中的该变量&#125;;class SON1 : public DAD1&#123;public:\tSON1()\t&#123;\t\t_a = 20;\t&#125;\tvoid Print()\t&#123;\t\tcout &lt;&lt;&quot;SON: &quot; &lt;&lt; _a &lt;&lt; endl;// 优先访问派生类的_a\t\tcout &lt;&lt;&quot;DAD: &quot; &lt;&lt; DAD1::_a &lt;&lt; endl;// 访问基类的_a\t&#125;\tvoid func()// 同名函数\t&#123;\t\tcout &lt;&lt; &quot;SON func&quot; &lt;&lt; endl;\t&#125;\tint _a;// 派生类的同名变量&#125;;\n\n下方的调用测试能看出结果；\n\nclass A&#123;public:    void func()    &#123;        cout &lt;&lt; &quot;A::func&quot; &lt;&lt; endl;    &#125;&#125;;class B : public A&#123;public:    void func(int a)    &#123;        cout &lt;&lt; &quot;B::func &quot; &lt;&lt; a &lt;&lt; endl;    &#125;&#125;;\n\n在这个栗子里面，A::func  B::func两个函数之间是什么关系？\n答案：二者是  隐藏  的关系，并非函数重载！函数重载要求两个函数是处于同一个作用域，才构成重载！\n这点通过编译测试也能看出来\nint main()&#123;    B bt;    bt.func();    bt.func(1);    return 0;&#125;\n\n当我们使用如上函数进行编译的时候，编译器会报错找不到 B::func()，因为 B 的作用域中只有 func(int a) 这个需要传递参数的函数。如果 A::func  B::func 的关系是函数重载的话，那这里应该可以直接调用才对。\ntest.cpp: In function ‘int main()’:test.cpp:24:13: error: no matching function for call to ‘B::func()’     bt.func();             ^test.cpp:15:10: note: candidate: ‘void B::func(int)’     void func(int a)          ^~~~test.cpp:15:10: note:   candidate expects 1 argument, 0 provided\n\n只有指定父类作用域才能调用到A::func\nB bt;bt.A::func();\n\n1.4 静态成员  在继承体系中，基类的静态成员有且  只能有一个 。即所有的子类和他们的对象，都是只有那一个静态成员的。我们可以用这个特性来对继承派生中出现的 对象  进行计数。\nclass Person&#123;public :\tPerson () &#123;++ _count ;&#125;protected :\tstring _name ; // 姓名public :\tstatic int _count; // 统计人的个数。&#125;;int Person :: _count = 0;\n\n如果出现了与静态成员同名，访问方法就有所变化\n// 访问同名的静态成员class DAD2&#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1 &quot; &lt;&lt; endl;\t&#125;\tstatic void Test1(int n)\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1(int)  &quot; &lt;&lt; n &lt;&lt; endl;\t&#125;&#125;;int DAD2::D_a = 100;class SON2 : public DAD2 &#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;SON2 Test1 &quot; &lt;&lt; endl;\t&#125;&#125;;int SON2::D_a = 200;\n\n\n1.5 友元  友元关系  不会被继承 ，基类的友元函数无法访问派生类的 私有 / 保护  成员\n\n1.6 默认成员函数  我们知道，C++ 类和对象中有 6 个默认成员函数\n\n在派生类中，这些默认成员函数有  新的使用方法\n\n派生类的构造函数必须在  初始化列表  中调用基类的构造函数，初始化父类的一部分成员。如果你没有写，编译器会自动调用默认构造函数（先调用基类，在调用子类）\n派生类的拷贝构造同上，必须显式调用基类拷贝构造函数（将子类对象传过去，相当于将子类对象中的父类部分传入父类拷贝构造函数。这部分是编译器自动帮我们实现的切片操作）\n派生类的赋值重载也需要调用基类赋值重载完成操作\n派生类的析构函数编译器会自动调用基类，先析构派生类，再析构基类成员（符合栈后进先出原则）\n在基类析构函数不是  虚析构  的时候，子类析构和父类析构  构成  隐藏  关系；\n因为多态的需要，析构函数会被统一命名为 destructor()，构造函数并 不会  出现重命名。\n\n在下方栗子中，当我们写 B 类的深拷贝的时候，可以通过指定类作用域的方式来调用 A 父类的 operator= 重载（这里必须要指定类的作用域，否则调用的还是 B 类自己的 operator= 重载，相当于无效的递归调用，最终会因为死循环导致栈溢出）\n因为我们是将子类赋值给父类，所以都是编译器自动帮我们进行的切片操作。\nclass A&#123;public:    A(int a)        : _numa(a)    &#123;    &#125;    A(const A &amp;a)    &#123;        _numa = a._numa;    &#125;    A &amp;operator=(const A &amp;a)    &#123;        if (this != &amp;a)        &#123;            _numa = a._numa;        &#125;        return *this;    &#125;    void func()    &#123;        cout &lt;&lt; &quot;A::func&quot; &lt;&lt; endl;    &#125;    ~A()    &#123;        cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;        _numa = 0;    &#125;private:    int _numa;&#125;;class B : public A&#123;public:    B(int a = 1, int b = 1)        : A(a), _numb(b)    &#123;    &#125;    B(const B &amp;b)        : A(b)    &#123;        _numb = b._numb;    &#125;    B &amp;operator=(const B &amp;b)    &#123;        if (this != &amp;b)        &#123;            A::operator=(b); // 指定作用域调用 A 类的赋值重载            _numb = b._numb;        &#125;        return *this;    &#125;    void func(int a)    &#123;        cout &lt;&lt; &quot;B::func &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    ~B()    &#123;        cout &lt;&lt; &quot;~B()&quot; &lt;&lt; endl;        //A::~A();// 显示调用会报错        _numb = 0;    &#125;private:    int _numb;&#125;;\n\n而在析构函数中，子类的析构调用完毕后，会  自动  调用父类的析构，以保证先析构子类，在析构父类。\n所以并不需要我们显式调用；显示调用父类析构的时候会报错\ntest.cpp: In destructor ‘B::~B()’:test.cpp:74:15: error: no matching function for call to ‘B::~B()’         A::~A();// 显示调用会报错               ^test.cpp:32:5: note: candidate: ‘A::~A()’     ~A()     ^test.cpp:32:5: note:   candidate expects 1 argument, 0 provided\n\n\n\n\n构造和析构顺序  子类继承父类后，当创建子类对象，也会调用父类的构造函数\n\n继承中  先调用父类构造函数\n再调用子类构造函数\n\n析构顺序与  构造相反\n显示调用父类构造函数  如何显示调用父类的构造函数呢，下面是一个代码示例\n#include &lt;iostream&gt;using namespace std;class Person&#123;public:    Person(string name, string sex, int age)    &#123;        _name = name;        _sex = sex;        _age = age;    &#125;protected:    string _name;    string _sex;    int _age;&#125;;class Student : public Person&#123;public:    // 在初始化列表中调用父类的构造函数    Student(string name,string sex,int age,int no)        :Person(name,sex,age),        _No(no)    &#123;&#125;    int _No;// 学号&#125;;int  main()&#123;    Student sobj(&quot; 李华 &quot;,&quot; 男 &quot;,18,1000);&#125;\n\n运行结果如下，可见子类正常调用了基类构造函数并进行了初始化\n\n这里也涉及到之前学过的一个小知识：在 CPP 中，类中成员的初始化顺序是依照声明的顺序来初始化的！而基类中的成员声明早于子类成员，自然也是先初始化基类的。\n1.7 基类和派生类赋值问题  派生类成员可以赋值给基类的 对象 &#x2F; 指针 &#x2F; 引用。一般我们把这种情况称为  切片，形象地表示把派生类中父类那部分切来赋值过去。\n但是！反过来是不行的哦，你不能把基类对象赋值给派生类对象。\n\n基类的指针 &#x2F; 引用可以用  强制类型转换  给派生类的指针 &#x2F; 引用。但是这样不够安全，除非基类的指针指向的是对应的派生类。\n如果基类是多态类型，可以使用 RTTI（运行时类型识别）的 dynamic_cast 来进行安全处理\n\n#include &lt;iostream&gt;using namespace std;class Person&#123;protected :    string _name;    string _sex;    int _age;&#125;;class Student : public Person&#123;public :    int _No ;// 学号&#125;;int  main()&#123;    Student sobj ;    // 1. 子类对象可以赋值给父类对象 / 指针 / 引用    Person pobj = sobj ;    Person* p1 = &amp;sobj;    Person&amp; p2 = sobj;    // 2. 基类对象不能赋值给派生类对象    //sobj = pobj;//err    // 3. 基类的指针可以通过强制类型转换赋值给派生类的指针    p1 = &amp;sobj;// 子类对象给基类指针    Student* ps1 = (Student*)p1; // 基类指针指向子类，正常转换    ps1-&gt;_No = 15;    cout&lt;&lt;ps1-&gt;_No &lt;&lt;endl;    p1 = &amp;pobj;// 基类对象给基类指针    Student* ps2 = (Student*)p1; // 转换虽然可以，但是会存在越界访问    ps2-&gt;_No = 10;    cout&lt;&lt;ps2-&gt;_No &lt;&lt;endl;    return 0;&#125;\n\n\n关于最后提到的越界访问问题，我们知道，指针变量的大小都是相同的，其指针类型的区别主要在访问能力的不同。比如 char* 指针解引用只能访问 1 个字节，int*指针解引用可以访问 4 个字节，以此类推，Student*指针解引用可以访问 sizeof(Student) 个字节的空间。\n而子类对象的大小都是大于等于基类对象的大小的。这就导致子类指针访问基类对象内容时，一次解引用访问的空间超长，造成了越界访问\n\n实际上，当我们切片讲子类对象赋值给父类对象的时候，编译器会进行  切片操作，即新的父类对象中的内容只会包含父类的成员。子类多出去的那一部分成员会被剔除。\n这一点我们可以在 VS 的调试中证实\n\n因为基类的成员变量被设置成了保护，所以我们不能直接在外部进行修改。需要显式调用基类的构造函数  来初始化基类的成员。\n1.8 虚继承（菱形继承问题）有的时候，继承会出现下面这种情况：一个子类继承了两个基类，而这两个基类又同时是一个基类的派生类\n\n这时候，D 里面就会有两份 A 的内容，相当于两份公共部分。这是我们不想看到的，因为会造成空间浪费。而且直接访问的时候，编译器会报错“对变量 X 的访问不明确”\n\n比如：intel 和 amd 联合推出的 NUC 小电脑中，有一款 CPU 是他们合作开发的\n如何解决同时继承 AMD 和 INTEL 的问题？\n\n这时候会出现两个同名变量，一个是 AMD 里面有的，另外一个是 INTEL 里面有的  因为他们是从 CPU 里面继承来的。\n虽然我们可以指定作用域来分别修改和访问。但是实际上这个公共部分就出现了浪费（比如是网站的公共部分，多给你一份没有啥意义）\n\n\n和前面说道的同名问题一样，我们可以指定作用域来访问特定的变量，但是这样是治标不治本的方法，并没有解决空间浪费的问题。\n// 解决方法 1（治表不治本）// 用类域来修改和访问cout &lt;&lt; &quot;intel: &quot; &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;cout &lt;&lt; &quot;amd: &quot;   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;\n\n这就需要我们使用  虚继承  来操作：给 B 和 C 对 A 的继承加上 virtural 关键字（对公共基类的继承添加上虚继承关键字）\nclass CPU &#123;public:\tCPU()\t\t:_Structure(&quot;x86&quot;)\t&#123; &#125;\tchar _Structure[100];&#125;;class INTEL : virtual public CPU &#123;public:\tINTEL()\t\t:i_Brand(&quot;intel&quot;)\t&#123;&#125;\tchar i_Brand[10];&#125;;class AMD : virtual public CPU &#123;public:\tAMD()\t\t:a_Brand(&quot;amd&quot;)\t&#123;&#125;\tchar a_Brand[10];&#125;;// 同时继承 AMD 和 INTEL// 相当于有两个_Structure 变量// 实际上我们只需要一个就够了class NUC :public AMD, public INTEL &#123;&#125;;void test1()&#123;\tNUC n1;\t// 对“_Structure”的访问不明确\t//cout &lt;&lt; n1._Structure &lt;&lt; endl;//err\t// 解决方法 1（治表不治本）\t// 用类域来修改和访问\tcout &lt;&lt; &quot;intel: &quot; &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;\tcout &lt;&lt; &quot;amd: &quot;   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;\t// 解决方法 2，在 AMD 和 INTEL 对 CPU 的继承上加 virtual\tcout &lt;&lt; &quot;n1 访问：&quot; &lt;&lt; n1._Structure &lt;&lt; endl;\t// 现在就没有报错了\t// 因为这时候 AMD 和 INTEL 中的_Structure 都会指向同一个地址\tcout &lt;&lt; &quot;&amp;intel: &quot; &lt;&lt; &amp;(n1.INTEL::_Structure) &lt;&lt; endl;\tcout &lt;&lt; &quot;&amp;amd:   &quot; &lt;&lt; &amp;(n1.AMD::_Structure) &lt;&lt; endl;\t// 修改 INTEL 中的_Structure，也会连代修改 AMD 中的_Structure&#125;\n\n这时候直接访问变量就不会报错了。因为这时候，B 和 C 中的该变量指向了  同一个地址，修改操作会同步。\n\n继承模型  普通菱形继承  下图中的继承模型是一个简单的菱形继承，我们能看到 d 中关于两个公共 A._a 的位置是不相同的；\n\n在 cpu 继承模型中也是如此，amd 和 intel 继承的 cpu 类中 X86 字符串的  地址  是不相同的\n\n这里因为  内存对齐  的问题，我们无法看清楚它的全貌。\n但通过这里的继承模型，可以看出来在菱形继承问题中，不使用虚继承会造成两个 CPU 对象的多次继承，导致访问不明确的特性。\n虚继承模型  那换成  虚继承  之后的模型是什么样子的呢？\n先用 d 本身访问d._a，可以看到红色箭头所指区域的内存被初始化为 0\n\n再指定作用域 B:: 进行访问，会发现其修改的依旧是这个地址的数据！\n\n用作用域 C:: 来访问的结果也是如此，依旧修改的是相同内存位置的数据\n\n由此可见，菱形继承了之后，_a变量的地址就被确定为一个地址了。所有作用域中的 _a 指向的都是这个公共地址，修改的都是这个公共地址的值，也就不会出现二义性问题！\n最终运行完毕，内存窗口如图，A 被丢到了最后面\n\n再说回上方提到的 cpu 继承模型，进入调试窗口，可以看到这里分别分为了 3 个模块，保存了不同基类的成员。而它们之中的 _Stucture 成员只有一个（指向 &quot;x86&quot; 字符串的地址是相同的），所以就不会出现异义；\n\n此时我们会发现，不管是上方 ABCD 的继承模型，还是这里的 CPU 继承模型，内存都出现了一定的  空置 ；那这里空着的空间是用来做什么的呢？也是内存对齐吗？ 非也！\n虚基表\n通过在  虚基表  中存放虚基类的偏移量，可以解决菱形继承产生的二义性问题。\n\n下图能帮你了解这个虚继承模型中，内存的区块是怎么划分的；可以看到 B 和 C 这两个父类都会有一个  虚基表的指针，指向虚基表的地址。地址中存放的是 B 和 C 对象跟 A 对象地址的偏移量。\n\nB 和 C 两个对象都有自己独立的虚基表地址，而不是共用一个，是为了方便切片时候的查询。\n\n这样，虚基表就帮我们避免了在访问菱形继承模型时出现异义的问题。不过，因为多了一层间接的偏移量查询，访问公共基类的成员的效率会有所降低。\n\ncpu 的继承模型也是如此，在 amd 和 intel 这两个字符串存储位置上方，存放的就是一个  虚基表的地址 。而虚基表的这个地址之后紧跟着的就是一个 当前对象跟基类对象的偏移量  的数据；\n同时也能总结出一个规律，虚基表的地址中的  数据  以全 0 开头，第二个（准确来说应该是偏移 4 个字节）的地址才是  基类偏移量的数据\n\n这样做就有一个好处，即便我们使用不同的基类指针（比如 amd 或者 intel）来指向 nuc 的子类对象；\nNUC n1;AMD* amd = &amp;n1;INTEL* itl = &amp;n1;\n\n这里的赋值需要对 NUC 对象进行  切片 ，要获取到AMD/INTEL 这两个父类的成员的同时，还需要获取到公共基类 CPU 成员的位置；\n此时因为存在虚基表，它们都可以通过  各自  虚基表里面存放的  偏移量，来计算公共基类 CPU 成员的位置，从而获取到了 CPU 类的成员。\n另外，当 AMD 和 INTEL 采用虚继承来继承 CPU 的时候，他们类内就已经会有虚基表了。跟他们自己是否存在子类无关！这样是为了保证访问时候的统一性。比如如下代码\nNUC n;AMD a;AMD* amd1 = &amp;n;AMD* amd2 = &amp;a;\n\n对于编译器而言，其并不知道 AMD* 指针到底指向的是本类还是子类，而 AMD 对象本身也有虚基表，就能保证不管是本类还是子类，都能通过同样的方式（通过虚基表查询偏移量）来找到虚继承的父类 CPU 的地址，从而访问到父类对象成员。\n\n使用虚基表还可以让开发者灵活控制编译器对内存区块划分的优化。比如上面的两个栗子中，在 VS2019 里面，公共基类一般都是处于最下方的。\n但如果我想设计公共基类放在最上方，也可以通过虚基表中的偏移量来实现。\n而如果 cpp 强制规定公共基类必须要在普通基类的下方，而不使用虚基表来存放基类偏移量，那就限制了编译器的开发，也不方便实际的查找\n\nC++STD 中的 IO 流就使用了菱形继承来进行设计。\n但对于我们而言，由于菱形继承实在过于复杂，一般不建议你这么“作死”；\n1.9 继承和组合\n继承：上述所说。每一个派生类对象都是一个基类对象is-a\n组合：在一个类里面包含另外一个类的对象成员。每一个 B 对象中都包含了一个 A has-a；比如我们在自己的类中使用 std::string，此时我们自己的类和std::string 的关系就是组合\n\n组合是黑盒复用，继承是百盒复用（子类能知道父类的细节，称为白盒）\n实际情况中，建议优先选择组合，而不是继承。\n\n继承增加了代码的复用性，但是在一定程度上破坏了基类的封装性。派生类和基类的关联很强，耦合度高。\n对象组合是另外一种复用的选择，这时候，对象 A 的内部结构是不得而知的。这样就减小了对象之间的关联性，耦合度低，保护了封装，更方便代码的维护\n\n不过，继承还有另外一种用途，那就是多态。我们下边会讲解的！\n在软件设计中，追求  高内聚，低耦合，不同模块之间的关联度应该竟可能的低。在设计类间关系，和不同功能模块的时候，需要考虑具体场景来进行继承和组合的选用。\n比如 A 继承 B，此时两个类就被强关联在一起了，耦合度相对较高。对父类 A 的任何修改 i，都会影响达到 B，甚至导致 B 无法正常运行。\n总结  多继承所导致的菱形继承问题，在一定程度上让 C++ 的语法变得复杂了。比如 java 是没有多继承的。在实际使用情况中，不建议使用多继承。\n\n2. 多态\n静态多态：函数重载\n动态多态：派生类和虚函数组成的多态\n\n多态通俗地讲就是多种形态，当不同的对象去完成相同的事情的时候，会产生不同的状态。\n比如买票这个行为，会衍生出全票、儿童票、学生票等等类型。不同身份的人过来买票，应该调用不同的处理流程。使用多态，就能将这些不同流程的相同类型函数（都是在买票）给拟合成不同子类对象中的同名函数；\n\n注意，多态只是实现这个场景的方式之一；你当然可以封装毫无相干的类，或者是使用函数重载，多个函数，判断语句来解决此类问题。\n\n2.1 虚函数 2.1.1 基本使用以及动态多态 虚函数，并不代表这个函数是虚无的。而表示这个函数在一定情况下会被  替换 （就好比继承中的虚继承问题）。要实现动态多态，就需要借助 虚函数  来实现。\n\n这里顺便提一嘴函数的三种关系：重载、隐藏（继承中同名问题）、覆盖（多态中虚函数被子类覆盖）\n\n虚函数需要满足两个条件\n\n函数名、参数、返回值  都相同\n父类中该函数使用了 virtual 关键字来修饰此函数\n\n而调用的时候，必须是父类  指针 / 引用  指向子类的对象的时候，才会调用子类重写后的虚函数（如果没有重写该函数，则调用的依旧是父类的函数）\n\n以下面这个动物说话的代码为例\n#include &lt;iostream&gt;using namespace std;class Animal &#123;public:\t//void Talk()\tvirtual void Talk()// 虚函数\t&#123;\t\tcout &lt;&lt; &quot;Animal is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class CAT : public Animal&#123;public:\tvoid Talk()// 同名函数\t&#123;\t\tcout &lt;&lt; &quot;CAT is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class DOG : public Animal &#123;public:\tvoid Talk()// 同名函数\t&#123;\t\tcout &lt;&lt; &quot;DOG is talking&quot; &lt;&lt; endl;\t&#125;&#125;;// 基类中不使用虚函数时，该函数的内容已确定// 不管传参什么类，都会调用 Animal 自己的 Talk 函数// 加上虚函数 virtual 后，会调用 CAT 和 DOG 的 Talk 函数void MakeTalk(Animal&amp; it) &#123;\tit.Talk();// 调用对应的 Talk 函数&#125;\n\n当基类 Animal 中的 Talk 函数没有用 virtual 修饰时，不管给这个函数传参什么类的对象，它都会调用 Animal自己  的 Talk 函数\n\n当我们用  虚函数  进行修饰后，就会调用  派生类CAT 和 DOG 的 Talk 函数，这就实现了一个简单的动态多态。\n\n对于虚函数，有几点需要注意：\n\n当基类的  指针或引用  指向派生类的对象时，就会触发动态多态，派生类中的同名函数会覆写基类中的虚函数\n不能定义静态虚函数——因为静态函数是属于整个类的，而不是属于某一个对象\n不能定义虚构造函数——总不能用派生类的构造来覆写基类的构造吧？这不符合继承中对构造函数的要求\n析构函数可以是虚函数\n\n2.1.2 虚析构函数  有的时候，我们需要析构一个子类对象时，往往会给  基类  的析构函数加上 virtual 修饰，这样只要传派生类的对象给基类的指针 &#x2F; 引用，就可以直接调用派生类对应的析构函数，完成不同的析构操作。\n而不是都呆呆的调用基类的析构函数——那样就会产生内存泄漏，因为子类部分的成员并没有被析构！\n这也是为何，类中析构函数会被统一重命名为 destructor()，便是为了让父类和子类的析构函数在设置了virtual 关键字后，函数同名，可以构成多态！\n所以，如果一个类是基类，最好将析构设置成虚析构。\n测试#include &lt;iostream&gt;using namespace std;class Queue&#123;public:    Queue()        : _a(new int[10])    &#123;    &#125;    ~Queue()    &#123;        cout &lt;&lt; &quot;~Queue&quot; &lt;&lt; endl;        delete[] _a;    &#125;private:    int *_a;&#125;;class MyStack : public Queue&#123;public:    MyStack(int capa)        : _a1(new int[capa])    &#123;    &#125;    ~MyStack()    &#123;        cout &lt;&lt; &quot;~MyStack&quot; &lt;&lt; endl;        delete[] _a1;    &#125;private:    int *_a1;&#125;;int main()&#123;    Queue *q1 = new Queue();    delete q1; // 调用父类的析构函数    Queue *q2 = new MyStack(4); // 父类指针指向子类    delete q2;                  // 如果加了虚析构，就会调用子类的析构函数    return 0;&#125;\n\n其中我们将子类 MyStack 的指针赋值给了父类。运行这个函数，会发现父类的析构函数被正常调用了两次，但子类的析构函数并没有被调用。\n这就导致子类对象中的 int *_a1; 指针申请的内存没有被正常释放，从而导致内存泄露；\nvirtual ~Queue()&#123;    cout &lt;&lt; &quot;~Queue&quot; &lt;&lt; endl;    delete[] _a;&#125;\n\n当我们给父类的析构添加上 virtual 关键字后，再次运行这个代码\n~Queue~MyStack~Queue\n\n此时父类和子类的析构都被成功调用了！\n为了更好的观察析构顺序，给两个类都新增了一个成员变量作为标记位，在析构的时候打印。\nclass Queue&#123;public:    Queue(int no)        : _a(new int[10]), _no(no)    &#123;    &#125;    virtual ~Queue()    &#123;        cout &lt;&lt; &quot;~Queue &quot; &lt;&lt; _no &lt;&lt; endl;        delete[] _a;    &#125;private:    int _no;    int *_a;&#125;;class MyStack : public Queue&#123;public:    MyStack(int capa, int no)        : _a1(new int[capa]), Queue(no), _nos(no)    &#123;    &#125;    ~MyStack()    &#123;        cout &lt;&lt; &quot;~MyStack &quot; &lt;&lt; _nos &lt;&lt; endl;        delete[] _a1;    &#125;private:    int *_a1;    int _nos;&#125;;int main()&#123;    Queue *q1 = new Queue(1);    delete q1; // 调用父类的析构函数    Queue *q2 = new MyStack(4, 2); // 父类指针指向子类    delete q2;                     // 如果加了虚析构，就会调用子类的析构函数    return 0;&#125;\n\n运行结果如下，可以看到，第二个指针 q2 被delete释放的时候，先调用了子类的析构函数，后调用了父类的析构函数。\n~Queue 1~MyStack 2~Queue 2\n\n这样就不会出现内存泄露了！\n2.1.3 子类不重写  在这个继承模型中，子类 Stu 并没有重写父类函数，运行的时候，调用的都是父类的成员函数。这是一个普通的继承调用。\nclass Person&#123;public:    virtual A *f()    &#123;        cout &lt;&lt; &quot;virtual A* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;&#125;;class Stu : public Person&#123;public:    int _a;&#125;;int main()&#123;    Stu s;    Person p;    Person* ptr = &amp;p;    ptr-&gt;f();    ptr = &amp;s;    ptr-&gt;f();    return 0;&#125;\n\n输出结果\nvirtual A* f()virtual A* f()\n\n2.1.4 协变  虚函数重写的时候，对返回值还会有一个例外的要求：协变；\n前面提到，虚函数构成重写，必须要保证返回值相同。但协变的存在就新增了一个规定，我们的返回值并不一定要严格相同。\n父类甲中函数返回值是某个父类乙的指针 &#x2F; 引用时，子类丙虚函数重写的时候，返回值可以是  子类丁 &#x2F; 父类乙  的指针 &#x2F; 引用 （对应父子关系即可，在这里， 甲丙 / 乙丁  是两对父子）\n// B 类继承了 A 类class Person&#123;public:    virtual A *f()    &#123;        cout &lt;&lt; &quot;virtual A* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;&#125;;class Stu : public Person&#123;public:    virtual B *f()    &#123;        cout &lt;&lt; &quot;virtual B* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;&#125;;int main()&#123;    Stu s;    Person p;    Person* ptr = &amp;p;    ptr-&gt;f();    ptr = &amp;s;    ptr-&gt;f();    return 0;&#125;\n\n上面的代码中，Stu子类对父类虚函数的重写，返回值就是子类的指针；编译通过并运行，结果如下。可见的确构成了多态。\n$ g++ test.cpp -o test$ ./testvirtual A* f()virtual B* f()\n\n如果带上引用，效果也是一样的\nclass Person&#123;public:    virtual A *f()    &#123;        cout &lt;&lt; &quot;virtual A* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;    virtual A &amp;func_a(A &amp;a, B &amp;b)    &#123;        cout &lt;&lt; &quot;virtual A &amp;func_a(A &amp;a, B &amp;b)&quot; &lt;&lt; endl;        return a;    &#125;&#125;;class Stu : public Person&#123;public:    virtual B *f()    &#123;        cout &lt;&lt; &quot;virtual B* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;    virtual B &amp;func_a(A &amp;a, B &amp;b)    &#123;        cout &lt;&lt; &quot;virtual B &amp;func_a(A &amp;a, B &amp;b)&quot; &lt;&lt; endl;        return b;    &#125;&#125;;int main()&#123;    Stu s;    Person p;    B test_b;    Person *ptr = &amp;p;    ptr-&gt;f();    ptr-&gt;func_a(test_b,test_b);    ptr = &amp;s;    ptr-&gt;f();    ptr-&gt;func_a(test_b,test_b);    return 0;&#125;\n\n这里我给 func_a 设计了两个参数，保证两个函数参数相同；需要注意子类的引用没办法赋值父类的对象。只有父类的引用才能赋值子类对象。（权限只能缩小不能扩大）\nvirtual A* f()virtual A &amp;func_a(A &amp;a, B &amp;b)virtual B* f()virtual B &amp;func_a(A &amp;a, B &amp;b)~B()~A()\n\n下面的这种情况就是不允许的！两个函数的参数不同，虽然满足协变的条件，但不满足虚函数重写的规定；可以看到运行后，两次调用都是父类的 func_a 函数；\n\n2.1.5 重写不带 virtual子类重写该函数的时候，可以不带 virtual 关键字。即便不带，依旧保有虚函数特性，可以被二次重写。这是因为子类继承父类的时候，先继承了虚函数的声明 （相当于从父类中继承了virtual 关键字）\n\n记住这点，后面要考\n\n虽然这个关键字可以被省略，但不建议你省略它。这个关键字能告诉其他开发者，这个函数是一个重写了父类的虚函数（也有可能是一个即将被重写的虚函数）。相当于一个提示。\nclass Person&#123;public:    virtual A *f()    &#123;        cout &lt;&lt; &quot;virtual A* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;    virtual A &amp;func_a(A &amp;a, B &amp;b)    &#123;        cout &lt;&lt; &quot;virtual A &amp;func_a(A &amp;a, B &amp;b)&quot; &lt;&lt; endl;        return a;    &#125;&#125;;class Stu : public Person&#123;public:    B *f()// 可以省略 virtual 关键字    &#123;        cout &lt;&lt; &quot;virtual B* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;    virtual B &amp;func_a(A &amp;a, B &amp;b)    &#123;        cout &lt;&lt; &quot;virtual B &amp;func_a(A &amp;a, B &amp;b)&quot; &lt;&lt; endl;        return b;    &#125;&#125;;class XiaoMing : public Stu&#123;public:    B* f()    &#123;        cout &lt;&lt; &quot;XiaoMing virtual B* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;&#125;;int main()&#123;    Stu s;    Person p;    XiaoMing xiao;    B test_b;    Person *ptr = &amp;p;    ptr-&gt;f();    ptr-&gt;func_a(test_b, test_b);    ptr = &amp;s;    ptr-&gt;f();    ptr-&gt;func_a(test_b, test_b);    ptr = &amp;xiao;    ptr-&gt;f();    return 0;&#125;\n\n输入结果如下\nvirtual A* f()virtual A &amp;func_a(A &amp;a, B &amp;b)virtual B* f()virtual B &amp;func_a(A &amp;a, B &amp;b)XiaoMing virtual B* f()~B()~A()\n\n截图说明\n\n坑人的问题  这个知识点就可以引伸出一个比较坑人的问题了\nclass Dad&#123;public:    virtual void func(int a = 3)    &#123;        cout &lt;&lt; &quot;Dad -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    virtual void test()    &#123;        func();    &#125;&#125;;class Son:public Dad&#123;public:    virtual void func(int a = 1)    &#123;        cout &lt;&lt; &quot;Son -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Son* s = new Son();    s-&gt;test();    return 0;&#125;\n\n请问如上代码的输出结果是什么？它调用的到底是谁的 func 函数呢？打印的 a 的值又是多少呢？\nA   Dad -&gt; 3B   Dad -&gt; 1C   Son -&gt; 1D   Son -&gt; 3E   编译不通过F   以上都不正确\n\n答案揭晓，选择的是D，输出结果是Son -&gt; 3\n$ ./testSon -&gt; 3\n\n刚开始遇到这道题的时候，我也是一脸蒙蔽。直到看了题解才知道这里多坑人。\n\n其中 E 和 F 肯定是不能选的，一般情况下这两个选项都是过来迷惑你的。\n比如有人可能会觉得 new 了之后没有 delete，有语法错误！但实际上你不delete 编译器是不会报错的，要不然也不会存在因为忘记 delete 而出现的内存泄露问题了。\n\n回到 2.1.5 小点  的开头， 提到了子类继承父类函数的时候，会先继承父类函数的 声明；\n对于普通函数而言，声明无伤大雅。但这里，子类和父类函数声明中参数 a 的  缺省值  不相同！\n最终我们通过子类对象调用 test() 函数的时候，是将子类对象的指针交给了父类对象的指针。不要忘记了，类中所有成员函数都会有一个隐藏的 this 指针传参！\n实际上，test 函数的声明应该是下面这个。我们用子类对象掉用的时候，传入的 this 指针是子类对象的指针，自然就出现了将  子类对象赋值给父类指针  的情况。\nvirtual void test(Dad* this) &#123;    this-&gt;func();&#125;\n\n此时就满足了虚函数的两个条件：父类指针指向子类对象；子类重写了父类的虚函数。\n这时候调用的 func() 函数，自然是子类中被重写了的 func() 函数，但由于继承了父类的函数声明 ，a 的缺省值被修改成了父类中func() 函数的 3，最终就打印出了 Son -&gt; 3 的结果；\n为了验证这个结论，我们还可以把子类中 func 函数的缺省值删除\nclass Dad&#123;public:    virtual void func(int a = 3)    &#123;        cout &lt;&lt; &quot;Dad -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    virtual void test()    &#123;        func();    &#125;&#125;;class Son:public Dad&#123;public:    virtual void func(int a)    &#123;        cout &lt;&lt; &quot;Son -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Son* s = new Son();    s-&gt;test();    return 0;&#125;\n\n理论上来说，子类函数重写了父类的 func，此时这个函数没有缺省值，调用一个没有传参的func() 函数应该是会报错的。\n但由于其继承了父类中的函数声明，并没有报错，编译通过了，输出的结果不变\n$ g++ test.cpp -o test$ ./testSon -&gt; 3\n\n\n所以啊，为了避免这种情况，虚函数请不要设计缺省值！\n\n还是上面那道题，如果是直接调用 func，应该输出什么？\nclass Dad&#123;public:    virtual void func(int a = 3)    &#123;        cout &lt;&lt; &quot;Dad -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    virtual void test()    &#123;        func();    &#125;&#125;;class Son:public Dad&#123;public:    virtual void func(int a = 1)    &#123;        cout &lt;&lt; &quot;Son -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Son* s = new Son();    s-&gt;func();    return 0;&#125;\n\n这时候就和什么继承父类函数声明没有关系了，直接调用的就是子类自己重写了的函数，可以理解为是一个普通的函数调用\n$ ./testSon -&gt; 1\n\n多态必须要父类指针 &#x2F; 引用指向子类的时候才能触发！\nint main()&#123;    Son* s = new Son();    s-&gt;func();// 普通调用    // 这个才是多态调用    Dad* dd = s;    dd-&gt;func();    return 0;&#125;\n\n$ ./testSon -&gt; 1Son -&gt; 3\n\n2.2 C++11 override 和 finalC++11 中新增了 override 和 final 这两个关键字\n2.2.1 finalfinal 用于类内成员函数之后，作用是让这个虚函数  无法被重写\nvirtual void Func1() final&#123;&#125;\n\n\n这个关键字的第二个做用，修饰类，被修饰后的类  无法被继承\n// C++11 直接用关键字 final 修饰，B 类就不能被继承了class B final&#123;\t//...&#125;;\n\n\n2.2.2 override该关键字用于子类中，也是丢在函数后，用于验证  是否完成重写\nclass A&#123;public:    virtual void test1()&#123;&#125;&#125;;class B :public A&#123;public:    void test1() &#123;&#125;    void test2() override &#123;&#125;&#125;;\n\n比如在上面的代码中，基类中并没有 test2 存在，此时我们在 test2 后加上了override，编译器就会进行检查并报错。因为 test2 并不是一个对基类中函数的重写\n\n将 override 添加到 test1 函数之后，就不会报错了。\nclass A&#123;public:    virtual void test1()&#123;&#125;&#125;;class B :public A&#123;public:    void test1() override  &#123;&#125;    void test2()  &#123;&#125;&#125;;\n\n但如果将基类 A 的 test1 的虚函数 virtual 属性去掉，则又会报错；\n\n如果基类和子类两个同名函数的  参数不相同，不构成重写，也会报错\n\n这个关键字就可以用于在多态类设计中，比如所有子类都会有一个 buy 的函数重写，那就可以在 buy 函数后添加一个 override， 来检查我的重写是否完成，参数是否与基类中该函数的参数相同，以及函数名是否正确。\n2.3 重载、覆盖（重写）、隐藏（重定义）的对比  常考，要理解并记忆\n\n3. 抽象类  包含纯虚函数的类就是抽象类，抽象类不能实例化对象\n3.1 纯虚函数  在虚函数的基础上，C++ 定义了纯虚函数：有些时候，在基类里面定义某一个函数是没有意义的，这时候我们可以把它定义为  纯虚函数，具体的实现让派生类去同名覆写。\n纯虚函数的基本形式如下\n//virtual 函数返回类型 函数名()=0;virtual void Print()=0;\n\n派生类中，必须重写  基类的纯虚函数，否则该类也是抽象类\nclass A &#123;public:\t//virtual void Print();// 虚函数\tvirtual void Print() = 0;// 纯虚函数&#125;;class B :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;B print &quot; &lt;&lt; endl;\t&#125;&#125;;class C :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;C print &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n当我们在派生类中覆写了该函数后，即可实例化对象并调用该函数\n\n和虚函数一样，使用基类的引用或指针来接收派生类的对象，即可调用对应的函数\n\n纯虚函数内部是可以写函数实现的，但是没有任何意义。因为纯虚函数必须要被子类重写，这个纯虚函数本身是不能被调用的。\n3.2 抽象类  包含纯虚函数的类就是抽象类，抽象类有下面几个特点：\n\n抽象类  无法实例化对象\n抽象类的派生类必须重写基类的纯虚函数，不然派生类也是抽象类\n如果在基类中定义的纯虚函数是 const 修饰的，则派生类中对应的函数也需要用 const 修饰\n\n\n如果我们在子类里面修改了函数的参数，那就不构成重写；此时子类 B 也是抽象类，无法被实例化对象了\nclass A &#123;public:\t//virtual void Print();// 虚函数\tvirtual void Print() = 0;// 纯虚函数&#125;;class B :public A &#123;public:\tvoid Print(int a) &#123; // 新增了一个参数\t\tcout &lt;&lt; &quot;B print &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n4. 实现继承和接口继承  普通函数的进程是一种  实现继承，派生类继承了基类的函数，可以使用这个函数。此时继承的就是函数的实现；\n多态中的虚函数是一种  接口继承，子类继承的是父类中虚函数的接口，目的是为了在子类中进行重写，以达成多态的目的。此时继承的是函数的接口。\n所以，如果不是为了多态，那就不要把父类的函数定义成虚函数。\n4.1 动态绑定和静态绑定\n静态绑定又称前期绑定（早绑定），在程序编译期间确定了程序的行为，也成为静态多态（函数重载）\n动态绑定又称为后期绑定（晚绑定），是在程序运行期间，根据具体拿到的类型来决定程序的行为，调用具体的函数，又称为动态多态。\n\n4.2 父类的构造和析构中虚函数不生效  请记住，在父类的构造和析构中，如果出现虚函数，则只会调用父类自己的函数实现，子类针对该虚函数的重写不会生效！\n具体请参考我的另外一篇关于一道 CPP 选择题目的博客【点我】\n5. 包含虚函数的类的大小  请问下面的代码中，b 和 d 对象的大小分别是什么？\nclass Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func2()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func2()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _b = 1;&#125;;class Derive : public Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func1()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _d = 2;&#125;;int main()&#123;\tBase b;\tDerive d;\tcout &lt;&lt; &quot;b: &quot; &lt;&lt; sizeof(b) &lt;&lt; endl;\tcout &lt;&lt; &quot;d: &quot; &lt;&lt; sizeof(d) &lt;&lt; endl;\treturn 0;&#125;\n\n结果如下，b 的大小是 8，d 的大小是 12\n\n当我们使用了 virtual 关键字修饰函数之后，类中就会出现一个  虚函数表 ，简称 虚表（需要和虚基表区分开来）\n\n\n后文将解释虚函数表的作用，只有虚函数才会存在于虚表中\n\n这个虚函数表是一个指针 _vfptr，指针的大小是4/8 字节，b 类的大小由虚函数表指针和 int 组成，d 类的大小由虚函数表指针和两个 int 组成。\n\n在 32 位下，这两个类的大小分别是 8 和 12；\n在 64 位下，这两个类的大小分别是 16 和 24（除了指针是 8 字节外，还需要内存对齐）；\n\n当我们把 Base 类中的函数修改回普通函数，可以看到类的大小又变成只包含一个 int 的 4 字节了。而 Dervie 类由于依旧有 virtual 的存在，所以大小不变。\n\n6. 虚函数表（虚表）以这个类为示例，让我们来看看虚表的样子\nclass Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func2()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func2()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _b = 1;&#125;;class Derive : public Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func1()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _d = 2;&#125;;\n\n在内存窗口中，可以看到这两个对象的基本模块。子类对象中也存在一个虚表 ，而且可以发现，父子类的虚表中，只有func1 的函数地址是不同的。\n\n这里的 _vfptr 是virtual func pointer的缩写，中文名是虚函数表指针，可以简称为虚表指针\n\n一定要区分虚函数表（多态）和虚基表（菱形继承）！\n\n6.1 虚函数重写和覆盖的概念区别  这里就需要提及重写和覆盖这两个概念的区别了\n\n虚函数重写：语法层的概念，指子类中重写父类中虚函数的函数实现\n虚函数覆盖：原理层的概念，子类对象的序表中，子类拷贝了父类的虚表，重写后的函数的函数指针  覆盖了基类对应虚函数的指针\n\n多态的实现，就依赖于子类虚表中对函数指针的覆盖，运行时，去指定对象的虚表中，调用对应的函数指针。这是一种  运行时决议  调用方法的操作；\n在 VS 的调试窗口中，我们能看到一个完整的父类 Base 对象，这也是父类指针指向子类对象的实现原理。此时父类的指针是完全没有办法知道自己指向的是父类对象，还是某个子类对象；\n虚函数表的存在，帮我们实现了通过相同的函数调用方法，实际却触发了不同函数的流程的操作。\n6.1.1 运行时决议和编译时决议\n多态调用，运行时决议：运行到这里时确定调用函数的地址\n普通调用，编译时决议：在编译时就确定调用的函数的地址\n因为存在一层通过虚函数表的跳转，所以多态调用会比普通调用的速度慢一些。\n\n依旧是上方的两个类，在基类和子类中同时存在一个普通函数Func3()，此时通过父类指针去调用的时候，就会发现二者调用的都是父类的Func3。\n\n这正是因为非虚函数是没有进入虚函数表，此时对 Func3 的调用就是一个普通函数调用；此时 Func3 函数的地址在编译出可执行文件的时候，就已经被确定为了基类中的函数地址。\n而 Func1 因为是虚函数，存在于虚函数表中，所以是通过运行时查询这个虚函数表，来找到父子类不同的函数地址，最终实现多态调用。\n6.1.2 看看汇编  从图中可以看到，对于 Func1 的调用，最终是从虚函数表中提取出来的地址，call eax寄存器中的地址，这便体现了运行时决议；\n而对 Func3 的调用，是编译时决议，直接已经确定了的基类中该函数的地址，直接 call 09511CCh 这个函数地址来调用函数了。\n\n对于指向基类对象的调用也是这样\n\n这里就能很直观的看到，多态中虚函数表，让父类指针不管是指向子类对象、还是指向父类对象，都能通过相同的汇编指令来调用正确的函数。\n6.2 子类对象赋值给父类为何无法实现多态？我们都知道，继承了之后，如果把子类对象赋值给父类，则会产生切片。此时无法构成多态。\n这是为什么呢？\n因为编译器在编译的时候，就已经确定了这些函数的地址。\n\n编译器检查是否符合多态的语法\n不符合多态的语法，则直接确定对类函数调用的成员函数地址\n符合多态的语法，那就编译出运行时决议的汇编语句\n\n此时地址就已经确定了，根本不存在从虚函数表中找函数地址的步骤，自然就不能实现多态调用了。\n\n这时候可能有些人就会有个不成熟的想法：如果将子类对象赋值给父类对象，切片的时候把子类对象的虚表指针也复制到父类中，那不就能实现多态了吗？\n不行！\nDerive dd;Base bb = dd; // 子类对象赋值给父类Base* ptr1 = &amp;bb; // 父类指针指向父类对象Base* ptr2 = &amp;dd; // 父类指针指向子类对象// 引用本质也是指针，这里就不写了\n\n以上面的代码为例，当我们把一个对象赋值给父类的指针时，程序运行的时候并不知道，这个指针指向的到底是父类还是子类对象。\n假设我们在切片的时候，将子类对象 dd 的虚表指针也拷贝复制给父类了，那就会出现一个严重的问题：ptr1在调用函数的时候，调用的也是子类的函数！\n这不就乱套了吗？！\n理论上 bb 是一个父类对象，赋值给 Base* 指针后，我们调用函数的预期是调用父类的函数。但由于 bb 对象是从子类对象  切片  而来的，拷贝了子类的虚表指针，此时找到的也是子类的函数地址，不符合预期地调用了子类重写后的虚函数！\n所以！为了避免这种不符合语法预期的问题，在切片的时候，只会将子类对象中的成员变量拷贝给父类，并不会拷贝虚表指针！切片生成的父类对象，虚表指针依旧是父类自己的虚表指针！\n下图中可见，b3 是切片而来的父类对象，其虚表指针以及虚表中的函数地址和 Base b1 完全相同。一个类的虚表其实只有一张。\n\n所以，对象并不能实现多态。即便理论上可行，但依旧不能这么做！\n6.3 子类中新增虚函数，但监视窗不显示6.3.1 实地探索class Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func2()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func2()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _b = 1;&#125;;class Derive : public Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func1()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func3()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func4()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func4()&quot; &lt;&lt; endl;\t&#125;private:\tint _d = 2;&#125;;\n\n当我们在子类中新增了一个虚函数 Func4 之后，再次打开监视，会发现子类的虚表中依旧只有两个函数指针。这是怎么回事？难道说子类没有被另外一个类继承，它的虚函数就不会进这里的虚表吗？\n\n通过内存窗口，我们可以看到这里的出现了两个监视窗口中已有的函数地址，但后面还有一个和前面两个很接近，但在监视窗口中没有出现的地址。而在这个地址之后是一行全 0（即nullptr）\n\n以 nullptr 做结尾作为 for 循环的判断条件，我们可以把虚函数表中函数的地址都打印出来\n// 重定义函数指针，需要将新的名字放在括号中间typedef void(*V_FUNC)();void PrintVfptrTable(V_FUNC* arr)&#123;\tfor (int i = 0; arr[i] != nullptr; i++)\t&#123;\t\tprintf(&quot;[%d] %p\\n&quot;, i, arr[i]);\t&#125;&#125;int main()&#123;\tBase b1;\tDerive d;    // 因为我们已经知道了，在 VS 中，虚函数表的指针就是对象的前 4 个字节\t// 这里是先将对象的指针强转为 int*，取出前 4 个字节的地址\t// 再将这个地址解引用，相当于将地址转成 int 数字\t// 最后再将这个数字重新强转为 V_FUNC* 函数指针数组的指针，传给我们的打印函数\tPrintVfptrTable((V_FUNC*)(*((int*)&amp;d)));&#125;\n\n运行结果如下， 可以看到成功打印出了 3 个函数的地址，和内存窗口中看到的数据一致\n\ntypedef void(*V_FUNC)();void PrintVfptrTable(V_FUNC* arr)&#123;\tfor (int i = 0; arr[i] != nullptr; i++)\t&#123;\t\tprintf(&quot;[%d] %p -&gt; &quot;, i, arr[i]);\t\tV_FUNC f = arr[i];\t\tf();\t&#125;&#125;\n\n既然是函数指针，最终我们是可以通过函数指针来调用函数的。添加了函数调用部分的代码后，再运行，可以看到最后一个函数的确是子类中新增的虚函数Func4\n\n所以，VS 的监视窗口中不显示 Func4 是因为 VS 认为这个函数没有被子类重写，无关痛痒，于是在监视窗口中隐藏了。\n实际上，只要是虚函数，那就是会进入到这个类中的虚函数表里面的！\n记住，只要是虚函数就一定会进虚表！\n6.3.2 为什么不新增一个子类的虚表？这里我还思考过另外一个问题，既然这个是子类自己的虚函数，那为什么没有多开一个虚表来存放这个函数的指针，而是直接放入到了继承自基类的虚函数表中呢？\n下图是 Derive 在 VS2019 的内存分布模型 ————————————|  _vfptr  | Base|  int _b  | Base|  int _d  | Derive———————————— 假设要新增一个指针，那按 VS 的规则，也是应该放在对象的最前面；此时模型就变成了下面这样 ————————————|  _vfptr  | Derive|  _vfptr  | Base|  int _b  | Base|  int _d  | Derive———————————— 新增了一个指针的内存占用不说，还把原本泾渭分明的内存模型，变成了两面包夹芝士；怎么说都是追加在 Base 的虚表之后更加靠谱，因为原本继承自 Base 的虚表就是子类对象的前 4 个字节！\n\n说明参考代码块中的注释。\n6.4 虚表的存储位置  虚表是存在哪里的？先说答案：虚表是存在常量区里面的\n下图中的 b1 和 b3 是两个不同的 Base 对象，但我们会发现它们的虚表地址包括函数指针的地址都完全相同。毕竟这是两个完全相同的类，虚表里面的内容确实是相同的。\n这就告诉了我们，相同的类，其虚表在内存里面只有一张。初始化的时候，将这个类的虚表找到，并插入到类中。\n\n那么虚表是存在内存中的那个区域里面的呢？\n首先排除栈和堆，栈是随时用随时开辟的，而堆需要动态内存管理，对于这种编译器自己完成的操作，也不应该是这样。\n而  静态区 / 数据段  放的是全局数据或者静态变量，相比之下，常量区 / 代码段  更靠谱。\n有了猜想之后，就要来验证了。\n我们将常用的存在不同位置的数据类型都弄出来，分别打印它们的地址\nint c = 2;int main()&#123;\tBase b1;\tint a = 0;\tstatic int b = 1;\tconst char* str = &quot;hello world&quot;;\tint* p = new int[10];\tprintf(&quot; 栈：%p\\n&quot;, &amp;a);\tprintf(&quot; 静态区 / 数据段：%p\\n&quot;, &amp;b);\tprintf(&quot; 静态区 / 数据段：%p\\n&quot;, &amp;c);\tprintf(&quot; 常量区 / 代码段：%p\\n&quot;, str);\tprintf(&quot; 堆：%p\\n&quot;, p);\tprintf(&quot; 虚表：%p\\n&quot;, (*((int*)&amp;b1)));\tprintf(&quot; 函数地址：%p\\n&quot;, &amp;Derive::Func3);\tprintf(&quot; 函数地址：%p\\n&quot;, &amp;Derive::Func2);\tprintf(&quot; 函数地址：%p\\n&quot;, &amp;Derive::Func1);\treturn 0;&#125;\n\n输出结果如下\n\n这时候可以发现，虚表的地址和常量区 &#x2F; 代码段的地址开头相似，都是00DF9B，说明它更加靠近代码段的区域。\n而虚表的地址 00DF9B34 是小于常量区 &#x2F; 代码段的 00DF9B6C 的，这就表明了在内存中，虚表的地址比这个常量区参数的地址更低。而在内存中，不同区域的分布如下，常量区就是在最低处的。\n栈  堆静态区 / 数据段  常量区 / 代码段\n\n实锤了，虚表就是存在常量区里面的！类的虚函数表是在编译阶段就已经生成了的\n6.5 多继承中的虚表  先说结论，如果出现了多继承，那么子类中会根据继承的父类分别产生  独立的虚表（如果不是独立的，那就没有办法实现某个父类指针指向子类时，对子类的切片）\n以下就是一个最简单的多继承\nclass Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func2()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func2()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _b1 = 1;&#125;;class Base2&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base2::Func1()&quot; &lt;&lt; endl;\t&#125;private:\tint _b2 = 1;&#125;;class Derive : public Base,public Base2&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func1()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func3()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func4()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func4()&quot; &lt;&lt; endl;\t&#125;private:\tint _d = 2;&#125;;\n\n通过监视窗口，能看到这个对象的模型大概是如下图所示\n\n其中能看到子类独有的虚函数 Func4 是存在第一张虚表里面的（VS 监视窗口依旧没有显示出来）\n\n这里还会发现一个问题：Base 和 Base2 这两个基类中都有虚函数Func1，那为什么子类中这两个类的虚表中，这两个被子类重写的 Func1 函数的地址不相同呢？\n通过之前写的打印函数来打印第二章虚表里面的函数\ntypedef void(*V_FUNC)();void PrintVfptrTable(V_FUNC* arr)&#123;\tfor (int i = 0; arr[i] != nullptr; i++)\t&#123;\t\tprintf(&quot;[%d] %p -&gt; &quot;, i, arr[i]);\t\tV_FUNC f = arr[i];\t\tf();\t&#125;&#125;\n\n这里需要注意的是，我们对 d 这个子类的指针 +1 的时候，会直接跳过 sizeof(Derive) 个空间的大小。为了能精准地通过 +sizeof(Base) 找到 Base2 基类的虚表，就需要将子类的指针强转为char*，这样每次 +1 就是移动一个字节的空间。\nPrintVfptrTable((V_FUNC*)(*((int*)((char*)&amp;d+sizeof(Base)))));\n\n运行可以看到，即便内存不同，但实际上调用的依旧是子类的 Func1 函数；也能看到子类单独新增的虚函数只会放在第一个虚表中。\n\n6.5.1 Func1 地址不同？在上面 VS 打印的虚表中，会发现一个问题：Base 和 Base1 父类中的两个 Func1 函数的地址不相同，但最终我们看到的运行结果又都是子类重写后的 Func1\n把相同的代码挪到 liunx 环境下，编译运行，发现出现了段错误\n$ ./test[0] 0x400b74 -&gt; Derive::Func1()[1] 0x400b48 -&gt; Base::Func2()[2] 0x400ba6 -&gt; Derive::Func4()Segmentation fault (core dumped)\n\n\n顺带一提，在 linux 下直接编译本博客中的代码会出现如下警告，因为我们对指针进行了多次强转，不用管他\n&gt;g++ test.cpp -o test -std=c++11&gt;test.cpp: In function ‘int main()’:&gt;test.cpp:92:44: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]    PrintVfptrTable((V_FUNC *)(*((int *)&amp;d)),3);                                           ^&gt;test.cpp:93:69: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]    PrintVfptrTable((V_FUNC *)(*((int *)((char *)&amp;d + sizeof(Base)))),1);                                                                    ^\n\n这是因为我们在打印虚函数表中，判断条件是当前函数指针为空，这是 VS 下对虚函数表的结束规定（以 nullptr 结尾），并不是 linux 下的操作，也不是 C++ 对虚表的统一规定。\n所以，为了能正常打印出虚函数表，我们需要将打印函数的判断条件改成固定值；因为我们已经知道了虚函数表中函数的个数了。\n// 重定义函数指针，需要将新的名字放在括号中间typedef void (*V_FUNC)();void PrintVfptrTable(V_FUNC *arr, size_t size)&#123;    printf(&quot;_vfptr: %p\\n&quot;,arr);    for (int i = 0; i &lt; size; i++)    &#123;        printf(&quot;[%d] %p -&gt; &quot;, i, arr[i]);        V_FUNC f = arr[i];        f();    &#125;&#125;// 如下是修改后的调用PrintVfptrTable((V_FUNC *)(*((int *)&amp;d)),3);PrintVfptrTable((V_FUNC *)(*((int *)((char *)&amp;d + sizeof(Base)))),1);\n\n再次编译运行，也出现了相同的结果，两个基类虚函数表中的 Func1 地址不相同\n$ ./test_vfptr: 0x400d10[0] 0x400b86 -&gt; Derive::Func1()[1] 0x400b5a -&gt; Base::Func2()[2] 0x400bb8 -&gt; Derive::Func4()_vfptr: 0x400d38[0] 0x400bb1 -&gt; Derive::Func1()\n\n再新增一个直接对 Derive::Func1 函数本身地址的打印\nPrintVfptrTable((V_FUNC *)(*((int *)&amp;d)),3);PrintVfptrTable((V_FUNC *)(*((int *)((char *)&amp;d + sizeof(Base)))),1);printf(&quot;\\n&quot;);printf(&quot;Derive::Func1 %p\\n&quot;,(void*)&amp;Derive::Func1);\n\n输出结果如下，可以看到这个函数本身的地址和第一张虚表里面的 Derive::Func1() 地址是吻合的，但是和第二章虚表的地址不相符合\n_vfptr: 0x400cd0[0] 0x400b60 -&gt; Derive::Func1()[1] 0x400b34 -&gt; Base::Func2()[2] 0x400b92 -&gt; Derive::Func4()_vfptr: 0x400cf8[0] 0x400b8b -&gt; Derive::Func1()Derive::Func1 0x400b60\n\n而在 windows 的 vs2019 中，打印的地址就更奇怪了，其和两个虚表中的地址都对不上！\n_vfptr: 002D9B84[0] 002D141F -&gt; Derive::Func1()[1] 002D1393 -&gt; Base::Func2()[2] 002D106E -&gt; Derive::Func4()_vfptr: 002D9B98[0] 002D10B9 -&gt; Derive::Func1()Derive::Func1 002D1122\n\n\n这里我还发现了一个奇怪的问题，相同的代码在 windows 下和 linux 下的效果不同\n// 下面的代码在 windows 下可以正常打印函数地址，linux 下打印出来的是 0x1printf(&quot;Derive::Func1 %p\\n&quot;,(&amp;Derive::Func1));// 下面的函数在 linux 下可以正常打印函数地址，在 windows 下报错“强制类型转换失效”printf(&quot;Derive::Func1 %p\\n&quot;,(void*)&amp;Derive::Func1);\n\n有人知道这是为啥吗？😂\n\n你可以理解这是在不同平台下，对虚表中函数指针的一个处理，其最终还是会调用到正确的函数的。\n在 windows 下查看反汇编，能看到其最终是调用了 ebp-14h 的一个地址，在内存窗口中可以看到，这个地址正是虚表中存放的 Func1 函数地址\n\n使用调试在反汇编窗口中逐条运行，能进到这个 call [ebp-14h] 语句中，可以看到在 002910B9 这个地址上存放的就是子函数中的 Func1 函数地址，这里的汇编指令 jmp 相当于跳转到这个函数地址上\n\n再进一步观察会发现，这里显示的地址和打印出来的 func1 函数的地址还是不相同\n\n再跳转，还是不同\n\n再次跳转，依旧是不同\n\n再一次跳转，就跑到了子类中 Func1 函数的执行流里面了。此时就开始执行这个函数了！\n\n所以，这只是编译器在某些层面上的处理而已。包括第一个基类的虚表，也是这样的函数地址跳转。在 linux 下和 windows 的不同编译器下观察到的情况都不一样，我们没必要过多纠结于这里，只要知道有这类编译器处理的存在就可以了。\n\n最终两个基类对 func1 的函数调用的汇编流程如下图\n\n这其中，我们要发现 Base2 对 Func1 的调用，主要是多了下面这两句非常不同的汇编\n008426B0 83 E9 08             sub         ecx,8008426B3 E9 67 ED FF FF       jmp         Derive::Func1 (084141Fh)\n\n原本走到这一步，ecx 寄存器的值是 0x00849b98。这一步执行完毕后，ecx 的值是 0x00849b90，可以看到更新后的值比原本的值少了 8 字节；正好是Base 类的大小！\n这是因为在当前对象模型中，两个父类对象需要调用的 Func1 都是  子类  的 Func1，此时使用的 this 指针应该是子类 Derive 的 this 指针，处于子类对象地址的起始位置。对于 Base* ptr1 来说，其指向的地址本身就是子类的起始地址，所以不需要进行修正。\n但 Base2* ptr2 指向的位置并不是子类的起始地址，此时就需要 -8 回到起始位置，用修正后的 this 指针来调用子类的 Func1 函数；\n\n这也就能解释为什么两个虚表中存放的函数指针地址不相同，因为调用的流程不一样，Base2 的指针在调用的时候需要对 ecx 寄存器中的 this 指针进行修正。\n6.5.2 指针切片地址不同  当我们用不同的父类指针指向这个子类对象的时候，由于会发生不同位置的切片，最终的地址并不相同。这点我们通过对象模型也能看出来，不同的父类都需要指向自己的那部分，所以切片后的地址不同。\nDerive d;Base* ptr1 =  &amp;d;Base2* ptr2= &amp;d;Derive* ptr3 = &amp;d;printf(&quot;Base: %p\\nBase2: %p\\nDerive: %p\\n&quot;, ptr1, ptr2, ptr3);\n\n\n6.6 菱形虚拟继承中的虚函数表class A&#123;public:\tvirtual void func()\t&#123;\t\tcout &lt;&lt; &quot;A:func&quot; &lt;&lt; endl;\t&#125;\tint _a;&#125;;class B : public A&#123;public:\tint _b;&#125;;class C : public A&#123;public:\tint _c;&#125;;class D : public B, public C&#123;public:\tint _d;&#125;;\n\n使用上图代码进行虚拟继承的时候，内存模型如图，在 B 类和 C 类中都会有一个继承自 A 类的虚表；因为这里没有进行函数重写，所以地址是一样的。\n\n当我们在 B 和 C 类中重写此函数，对象模型如下，B 类和 C 类中虚表的函数指针不同\n\n但如果我们把 B 和 C 对 A 的继承都改成虚继承，此时就会报错了！\n\n在前面的虚继承讲解中，提到了在 VS 下，是将公共基类放在子类的最后面的，此时模型的顺序大概如下\nBCDA\n\n由于 B 和 C 都使用了虚继承，解决了数据二义性问题，但没有解决 A 中的虚表到底是存 B 重写后的 func，还是存 C 重写后的 func 的问题；\n这个时候我们就需要在 D 里面重写 func，这时候就能确定最终使用的是 D 里面对 func 的重写，也就不会有到底是选 B 还是选 C 的分歧问题了。\n\n6.7 虚函数和 inline6.7.1 状态观察  我们先尝试给一个虚函数加上 inline 内联关键字\nclass A&#123;public:\tvirtual inline void f1()\t&#123;\t\tcout &lt;&lt; &quot;f1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void f2();&#125;;// 声明和定义分离就不是内联函数了void A::f2()&#123;\tcout &lt;&lt; &quot;f2()&quot; &lt;&lt; endl;&#125;int main()&#123;\tA aa;\taa.f1();\taa.f2();\treturn 0;&#125;\n\n修改 VS2019 项目的属性\n\n\n转到反汇编，可以看到 f1 函数被展开，f2 函数依旧是 call 地址的调用\n\nclass A&#123;public:\tvirtual inline void f1()\t&#123;\t\tcout &lt;&lt; &quot;f1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void f2()\t&#123;\t\tcout &lt;&lt; &quot;f2()&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n如果不将声明和定义分离，可以观察到两个函数都被编译器认作是内联而展开了。\n\n此时新增一个继承，再来看看反汇编\nclass A&#123;public:\tvirtual inline void f1()\t&#123;\t\tcout &lt;&lt; &quot;f1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void f2();&#125;;// 声明和定义分离就不是内联函数了void A::f2()&#123;\tcout &lt;&lt; &quot;f2()&quot; &lt;&lt; endl;&#125;class B:public A&#123;public:\tvirtual void f1()\t&#123;\t\tcout &lt;&lt; &quot;B f1()&quot; &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tA aa;\taa.f1();\taa.f2();\treturn 0;&#125;\n\n此时我们发现，似乎 f1 函数依旧是有内联的属性\n\n这说明虚函数是可以用 virtual 关键字来修饰的。\n但如果用多态调用呢？\nA* aa = new B();aa-&gt;f1();aa-&gt;f2();\n\n此时就能发现，原本的多态展开，就变回了 call 函数地址的调用\n\n这是因为内联函数是没有地址的！而多态基于虚基表实现，虚基表中必须要存放函数的地址！\n6.7.2 结论  结论就是，在多态中，对虚函数的 inline 修饰不会报错，但会被编译器忽略（不会有内联的属性），依旧是个普通的函数\n7. 静态成员函数不能是虚函数  静态成员函数属于整个类，无法被指定对象重写。\n而且静态成员函数没有 this 指针，可以直接用类名来调用，但这也决定了其无法访问到虚表，自然也无法实现多态。\n所以静态成员函数是不能做虚函数的，在 VS 中这样写会直接报错\n\n8. 构造函数不能是虚函数  通过调试可以发现，虚函数表中的指针原本是随机值，是在构造函数中被初始化为正确的函数地址的\n\n\n既然是在构造函数中初始化的，那么虚函数表就  不能先于构造函数被初始化出来，也就没有办法通过虚表来实现多态。\n所以构造函数是不能为虚函数的！\n9. 菱形继承构造顺序  如下虚菱形继承中，调用构造函数的顺序是什么？\nclass A &#123;public:\tA(const char* s) &#123; cout &lt;&lt; s &lt;&lt; endl; &#125;\t~A() &#123;&#125;&#125;;class B :virtual public A&#123;public:\tB(const char* s1, const  char* s2) :A(s1) &#123; cout &lt;&lt; s2 &lt;&lt; endl; &#125;&#125;;class C :virtual public A&#123;public:\tC(const char* s1, const  char* s2) :A(s1) &#123; cout &lt;&lt; s2 &lt;&lt; endl; &#125;&#125;;class D :public B, public C&#123;public:\tD(const char* s1, const char* s2, const  char* s3, const  char* s4) :B(s1, s2), C(s1, s3), A(s1)\t&#123;\t\tcout &lt;&lt; s4 &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tD* p = new D(&quot;class A&quot;, &quot;class B&quot;, &quot;class C&quot;, &quot;class D&quot;);\tdelete p;\treturn 0;&#125;\n\n我们只需要知道，类的对象在实例化的时候，初始化的顺序就是类声明的顺序\n依照代码中的顺序流程读下来，就是构造函数被初始化的顺序；\n而且 A 的构造函数也是由最终子类 D 直接发起的，而不是 B 或者 C 发起的。\n\n下面这道题也是一个有关于构造顺序和多态调用的问题\n\n在 linux 下测试，最终打印的是\nbarfoob_bar\n\n调用顺序为\n\n父类 A 的构造函数调用父类自己的 bar 函数，因为这时候虚表还没有初始化，所以不存在多态，打印bar\n父类指针指向子类，调用 foo 函数，由于 foo 函数不是虚函数，不在虚表内，所以调用的是父类的 foo 函数，打印foo\n父类指针调用 bar 函数，此函数为多态调用，调用的是子类的 bar 函数，打印b_bar\n\n所以最终的输出结果是barfoob_bar\nThe end内容丰富的继承和多态的博客终于补充完毕了！\n如果有问题还请提出！\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】异常处理","url":"/posts/569709037/","content":"本篇博客让我们来认识一下 C++ 中对于异常的处理机制\n\n\n[TOC]\n1. 概念 1.1 C 语言对于异常的处理 在之前我们遇到一些 bug 的时候，通常会用 if 判断或者 assert 断言等问题进行处理。但这种方式太过暴力，会直接中断程序的运行\n另外一种办法是返回错误码，C 语言的报错大多使用这种方式。不过这需要程序的用户自己去查对应的错误码表格，较为麻烦\n\n1.2 C++ 异常  所谓异常，便是程序运行过程中可能遇到的 bug 或者问题。程序可以有选择地抛出一个异常，告知用户程序运行出现了问题。\nC++ 标准库中便使用了一个 exception 类来进行异常的处理，我们运行程序中遇到的一些报错，其实就是标准库里面抛出了对应的异常\n\n其操作主要借助下面三个关键字\n\nthrow 在出现问题的地方抛出异常\ntry 监控后续代码中出现的异常，后续需要以 catch 作为结尾\ncatch 用于捕获异常，同一个 try 可以用多个不同类型的 catch 进行捕获\n\nthrow 关键字可以抛出  任意类型  的异常\n2. 基本操作  下面用除法函数，以除 0 的情况来做一个最简单的演式\nint Div()&#123;\tint a, b;\tcin &gt;&gt; a &gt;&gt; b;\tif (b == 0)\t\tthrow &quot;div 0 err!&quot;;\treturn a / b;&#125;int main()&#123;\ttry &#123;\t\tcout &lt;&lt; Div() &lt;&lt; endl;\t&#125;\tcatch(const char* s)&#123;\t\tcout &lt;&lt; s &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n\n2.1 需要注意的点  这里有几个需要注意的点：\ncatch 类型对应  当我们进行抛异常的时候，一定需要有对应类型的 catch，否则会报错\n比如我们 throw 的是一个常量字符串，如果用 string 来 catch，就会因为类型不匹配而出现报错\n\n所以当我们使用某一个会抛异常的函数的时候，一定要注意其抛出异常的类型\n\n利用…进行全捕获  假设我们不知道这里面会抛出什么类型的错误呢？总不能把所有类型都 catch 一下吧？\n当然不需要，我们可以使用下面的函数进行全捕获\n\n这就可以用于当我们不知道报错类型的时候。不过一般的使用场景是，在这之前先 catch 已知的错误类型，最后再加上一个全捕或，作为  未知错误  的标识\n不过 catch(...) 有一个缺点，那便是我们不能知道异常的类型\n\n基类捕获派生类的异常  当我们出现异常的时候，如果 throw 了一个子类对象，可以用基类的  引用  来接收！\nclass A &#123;\tint a;&#125;;class B : public A &#123;\tint b;public:\tB()\t\t:b(1)\t&#123;&#125;&#125;;void testab()&#123;\tB bt;\tthrow bt;&#125;int main()&#123;\ttry &#123;\t\ttestab();\t&#125;\tcatch (A&amp; e) &#123;\t\tcout &lt;&lt; &quot;err class A&quot; &lt;&lt; endl;\t&#125;\tcatch (...) &#123;\t\tcout &lt;&lt; &quot;err&quot; &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n\n这个在进行继承多态的错误编写的时候就很有用啦\n2.2 异常和栈帧  抛出异常后，会被离这个异常最近的 catch 捕获，如果没有任何 catch 则会报错\n\n比如我们单独写一个函数，而这个函数体内有 try/catch 的话，那么会直接和这个最近的匹配，并不会和 main 函数里面的匹配\n\n而如果该函数里面没有进行此操作，则会直接到 main 的对应 catch 处\n\n注意！这里是  直接跳转  到对应 catch 语句，并不会出现先跳到 testCatch 函数在跳回 main 的情况！\n2.3 重新抛出异常  假设我们遇到了这种情况\nvoid testab()&#123;\tB bt;\tthrow bt;&#125;void testD()&#123;\tint* arr = new int[10];\ttestab();\tdelete[] arr;&#125;\n\n在 testab() 函数中抛出了异常，导致 testD() 函数提前终止！\n\n可我们 new 的东西还没释放呢！\n这就出现了  内存泄漏！\n\n注意：内存泄漏是一个不能被忽略的问题，即便我们每一次 new 的空间很小，但是积小成多就是大问题！\n\n这时候我们就需要提前进行异常处理，如果出现问题，先释放我们 new 的资源之后，再将异常重新抛出。可以理解为是  提前拦截  异常\n\n3. 异常需要注意的一些问题 3.1 异常安全 当我们操作异常的时候，需要注意一些相关的问题\n\n上面 2.3 中提到的内存泄露问题，在 new 和 delete 之间抛出异常而没有中途处理，导致内存泄漏\n不要在构造或析构函数中抛出异常，否则可能导致对象不完全初始化（对象不完整）或不完全析构（内存泄漏）\n多线程操作中在 lock 与 unlock 之间抛出异常，导致死锁\n\n当然是有解决方案的，C++ 使用 RAII 来解决上述问题，这个待我下一篇智能指针的博客来讲解！\n3.2 异常规范  因为异常都是手动写代码进行处理的，那么就极其需要些代码的老哥拥有很好的编程规范。\n\n在函数后加上 throw(类型 A，类型 B) 可以列出这个函数能抛出的所有异常类型\n\nvoid test() throw(string,vector&lt;int&gt;);\n\n\n如果只跟一个类型，代表该函数只会抛出一种类型的异常\n\nvoid* operator new(size_t size) throw (std::bad_alloc);\n\n\n如果跟的是 throw() 代表这个函数不会抛出异常\n\nvoid* test2(size_t sz, void* p) throw();\n\n在 C++11 中还新增了一个关键字 noexcept 来标识不会抛出异常\nvoid* test2(size_t sz, void* p) noexcept;\n\n但是这些都依赖于用户的编程习惯，C++ 并没有强制用户一定要在函数尾部写上异常抛出的类型。\n那在项目合作中，来了一个“实习生”\n\n写了一个会抛出异常的函数，却没有标识该函数会抛异常，那下面调用该函数的地方没有进行异常处理，那不就蛋糕了，程序提前中止！\n或者说是抛出异常的类型写错了，没有对应的异常处理语句，只能被 catch(...) 捕获\n或者是明明不抛出异常非要写自己抛出，白写了异常处理\n\n以上三种情况都是我们不期望遇到的，所以在写相关函数的时候，最好明确标识相关异常抛出的类型！\n3.3 自定义异常类型  要是在协作中，不同用户抛出了太多不同类型的异常，那还怎么调用函数？\n前面提到了，子类抛出的异常可以用基类接受。所以在项目中一般都是会定义一个  继承  的规范异常体系，用于处理不同的异常。\n这样我们就只需要捕获一个基类对象，就能捕获到所有派生类的异常对象。\n关于基类捕获子类异常的方法在 2.1 中已经提及，这里不再演示\n\n3.4 C++ 标准库中的异常  在 C++ 标准库中，异常是围绕下图组织的\n\ncplusplus：https://legacy.cplusplus.com/reference/exception/exception/?kw=exception\n\n\n标准异常类的成员：\n\n在上述继承体系中，每个类都有提供了构造函数、复制构造函数、和赋值操作符重载。\nlogic_error 类及其子类、runtime_error 类及其子类，它们的构造函数是接受一个 string 类型的形参，用于异常信息的描述\n所有的异常类都有一个 what() 方法，返回 const char*  类型描述异常信息\n\n标准异常类的具体描述：\n\n\n\n异常名称\n描述\n\n\n\nexception\n所有标准异常类的父类\n\n\nbad_alloc\n当 operator new and operator new[]，请求分配内存失败时\n\n\nbad_exception\n这是个特殊的异常。如果函数的  异常抛出列表  里声明了 bad_exception 异常，而函数内部抛出了异常抛出列表中  没有  的异常，不论什么类型，都会被替换为 bad_exception 类型\n\n\nbad_typeid\n使用 typeid 操作符，操作一个 NULL 指针，而该指针是带有虚函数的类，这时抛出 bad_typeid 异常\n\n\nbad_cast\n使用 dynamic_cast 转换引用失败的时候\n\n\nios_base::failure\nio 操作过程出现错误\n\n\nlogic_error\n逻辑错误，可以在运行前检测的错误\n\n\nruntime_error\n运行时错误，仅在运行时才可以检测的错误\n\n\nlogic_error的子类：\n\n\n\n异常名称\n描述\n\n\n\nlength_error\n试图生成一个超出该类型最大长度的对象时，例如很长的 string\n\n\ndomain_error\n参数的值域错误，主要用在数学函数中。例如使用一个负值调用只能操作非负数的函数\n\n\nout_of_range\n超出有效范围，vetor 的 at 抛出了此异常\n\n\ninvalid_argument\n参数不合适。在标准库中，当利用 string 对象构造 bitset 时，而 string 中的字符不是’0’或’1’的时候，抛出该异常\n\n\nfuture_error(C++11)\nThis class defines the type of objects thrown as exceptions to report invalid operations on future objects or other elements of the library that may access a future‘s shared state.\n\n\nruntime_error的子类：\n\n\n\n异常名称\n描述\n\n\n\nrange_error\n计算结果超出了有意义的值域范围\n\n\noverflow_error\n算术计算上溢\n\n\nunderflow_error\n算术计算下溢\n\n\nsystem_error(C++11)\n运行时从操作系统或其他具有关联 error_code 的低级应用程序接口引发的异常\n\n\n以上部分 C++ 标准库异常解释来自https://blog.csdn.net/linxi8693/article/details/90318166\n\n4. 异常优缺点  优点\n\n异常对象定义完备之后，相比于错误码的方式，能让用户更加清楚的了解到自己遇到了什么类型的问题，更好定位程序的 bug\n函数错误码若遇到，需要层层向外返回；而异常则通过 catch 可以直接跳到对应处理位置\n第三方库包含异常，我们在使用类似于 boost/gtest 等第三方库的时候也需要使用对应的异常处理\n对于 T&amp; operator[] 这种操作符重载，我们没办法很好地使用返回值来标识错误（因为不同类型的返回值不一样，没办法统一处理）这时候就可以用异常来抛出越界问题\n\n缺点\n\n异常可能会导致程序到处乱跳（因为会跳到最近的 catch 位置）给观察错误情况增添了一些难度\n异常有一定性能开销（可忽略）\n异常容易导致资源泄漏等等问题\n异常依赖于用户编程规范，否则函数调用容易出现异常没有得到处理的问题\n\n\n结语  总体而言，异常处理利大于弊。很多语言都是用异常来处理错误的，比如python。只要维持一个良好的编程习惯，在函数后声明会抛出的异常类型，针对性进行处理，还是很香的！\n\n","categories":["遇见C++"],"tags":["C++","C++11","异常"]},{"title":"【C++】函数重载的形式及其背后原理","url":"/posts/909882653/","content":"常言道：中国有俩球，谁都赢不了！这句话在不同的语境下有不同的意思\nC++ 中，函数支持在同一作用域下声明几个功能类似的  同名函数，但需要遵守以下规定……\n\n\n\n形参个数不同\n形参类型不同\n形参类型的顺序不同\n只修改函数返回值不构成重载\n\n编译器会在调用这些同名函数的时候，根据具体情况来选择不同的函数\n\n[TOC]\n1. 函数重载的样式\n上面提到了函数重载的 3 个规定，下面让我们来用具体示例认识一下它们\n\n假设我们需要一个 A+B 的代码，如果每次都需要  根据不同数据类型来写不同的函数  去实现这个功能，未免有点太过繁杂。\n在 C++ 中，只需要修改函数的参数，即构成了函数重载，编译器就会自己选择对应的函数进行相加操作\n1.1 形参类型不同// 函数重载int Add(int a, int rb)&#123;\treturn a + b;&#125;long Add(long a, long b)&#123;\treturn a + b;&#125;double Add(double a, double b)&#123;\treturn a + b;&#125;int main()&#123;\tcout &lt;&lt; Add(10, 20) &lt;&lt;endl;     cout &lt;&lt; Add(10L, 20L) &lt;&lt; endl;\tcout &lt;&lt; Add(10.0, 20.0) &lt;&lt; endl;\treturn 0;&#125;\n\n\n1.2 形参个数不同int Add(int a, int b) &#123;\treturn a + b;&#125;// 个数不同int Add(int a, int b, int c) &#123;\treturn a + b + c;&#125;\n\n\n1.3 形参类型顺序不同  这里的顺序并不是 a 和 b 的顺序哈！只把 a 和 b 换一个位置是不构成函数重载的\n这里指的是先传 int 再传 double，和先传 double 再传 int 的  两种函数\n// 形参类型的顺序不同void Add(int  a, double b) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;&#125;void Add(double  a,int b) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;&#125;\n\n\n\n1.4 返回值不同非重载  只修改函数的  返回值类型  是不构成函数重载的\n\n\n2.C++ 实现函数重载的原理\n在看后续内容之前，建议先复习一下  程序运行的 4 个阶段 ，以便理解后面的操作👉 传送门\n\n这里使用我的树莓派在 Linux 系统下给大家演示一下函数重载背后的样式\n首先我创建了 3 个文件，test.c Add.h Add.cpp，文件的内容一并给出\n//Add.h#include&lt;iostream&gt;using namespace std;int Add(int a,int b);double Add(double a,double b);//Add.c#include &quot;Add.h&quot;int Add(int a,int b)&#123;\treturn a+b;&#125;double Add(double a,double b)&#123;\treturn a+b;&#125;//test.cpp#include &quot;Add.h&quot;int main()&#123;\tcout&lt;&lt;Add(1,2)&lt;&lt;endl;\tcout&lt;&lt;Add(1.5,2.5)&lt;&lt;endl;\treturn 0;&#125;\n\n可以看到，这里我们使用 gcc 这个 C 语言编译器编译程序的时候，出现了很多报错，因为 C 语言是不支持函数重载的\n\n2.1 编译生成可执行文件  需要使用 g++ 编译器来编译这个代码\ng++ test.cpp add.cpp -o Tcpp\n\n执行 ./Tcpp 运行该函数，可以看到正常输出了相加后的结果\n\n\n2.2 查看汇编  接下来我们要使用另外一个命令来查看可执行文件 Tcpp 的汇编代码\nobjdump -S Tcpp\n\n在这里面可以找到我们两个 Add 函数的位置，可见它们的地址是不同的，并且一个函数名为_Z3Addii，另外一个是_Z3Adddd\n\n2.2.1 汇编函数名的含义  这两个汇编代码中的函数名，其实包含了  函数名、函数参数  这两个信息\n\n拆分了其中一个，那么另外一个 _Z3Adddd 的意思就很明确了，末尾的两个 d 代表函数参数是(double,double)\n\n我们可以创建另外一个文件，查看它的汇编代码，进一步确认命名规则（其实这个命名规则是反推得出的）\n#include&lt;iostream&gt;using namespace std;void f(int a,int b)&#123;\tcout &lt;&lt;a&lt;&lt;endl;\tcout &lt;&lt;b&lt;&lt;endl;&#125;int main()&#123;\tf(3,4);\treturn 0;&#125;\n\n编译程序后，执行objdump -S，可以看到 f 函数被命名为_Z1fii，代表函数名长度为 1，原本函数名 f，和函数参数(int ,int)\n\n现在我们知道了汇编中这个函数名的命名规则，那它和 C++ 支持函数重载有什么关系呢？\n\n在这之前，我们还需看看 c 语言 程序，汇编代码中函数又是怎么命名的\n2.2.2 查看 C 语言汇编  这里我把之前的函数修改成了 C 语言的样式，gcc编译后再来看看它的汇编\nvoid f(int a,int b)&#123;\tprintf(&quot;%d %d\\n&quot;,a,b);&#125;\n\n\n然后你就会发现，C 语言汇编代码中的函数名，就是函数原本的名字f，没有添加任何东西！\n\n2.3 得出结论  看到这里，你能猜出来为什么 C++ 支持函数汇编，而 C 语言不支持了吗？\n\n没错 ！那是因为 C++ 的汇编代码中， 函数名还保存了函数的形参类型，而 C 语言中并没有保存，自然无法区分两个函数\n\n这个汇编函数名的命名方式也能解释 C++ 函数重载的 3 种样式\n假设我们有一个 fun 函数，那么我们可以推断出它的  汇编函数名\n\n\n\n类型\n形式一\n形式二\n\n\n\n形参个数不同\n_Z3funii(int,int)\n_Z3funiii(int,int,int)\n\n\n形参类型不同\n_Z3funii(int,int)\n_Z3fundd(double,double)\n\n\n形参类型顺序不同\n_Z3funid(int,double)\n_Z3fundi(double,int)\n\n\n同时也能解释为何只修改  函数返回值类型  是不构成重载的，因为汇编代码中没有保存函数的返回值\n\n正因为 C++ 在汇编处理中能够以这种命名方式来区分同名的不同函数，并给它们赋予不同的  地址 ， 编译器在链接符号表  的时候，才能通过  函数传参的不同  找到它需要调用的  对应函数的地址\n\n在 main 函数的汇编中，也能找到对应函数的  调用操作\n\n\n3. 语法 extern”C”因为 C++ 汇编处理中对函数名的修饰和 C 语言不同，所以 C++ 中有这么一个语法，专门用来告诉编译器，某某某函数要用C 语言的规则来修饰\n #include &lt;iostream&gt;using namespace std;extern &quot;C&quot; int fun(int a,int b);int main()&#123;    int sum=fun(1,2);    return 0;&#125;int fun(int a,int b)&#123;     return a+b;&#125;\n\n可以看到，使用这种方式修饰的 fun 函数，在汇编中就  只有函数名，而不是 C++ 形式原本的_Z3funii\n\n这样 C 语言 的代码就可以  链接  这种方式写的C++ 静态库（前提是这个静态库中没有函数重载和 C++ 的语法）\n\n然后我  就想问：这和 C 的静态库有啥区别……\n\n当然有了！一个库里面有很多很多代码，总有些函数接口是 C 语言也能支持的嘛，这些接口就用 C 语言的方式来修饰，这样 C 语言也能调用了，不一举两得？\n3.1C++ 调用 C 语言静态库  除了更改修饰方式外，extern&quot;C&quot;还用于让 C++ 程序来调用 C 语言写的库\n\n比如树莓派要用到的 wiringPi 库，它是用 C 语言实现的，在编程为静态库后，里面汇编对函数的修饰就固定了，并没有 C++ 下的_Z1... 和参数类型修饰。\n\n这时候如果用 C++ 直接来调用这个函数，C++ 程序是找不到对应的函数的。在这种情况下，extern&quot;C&quot;的作用就是让编译器以C 语言的方式去寻找对应函数\n比如下图的代码，调用了 wiringPi 库里面的  初始化函数，是最常用的一个函数\n\n我们用 G++ 编译器编译这个代码，就会发现，欸 tnnd 怎么没有报错啊？\n\n\n其实吧，库函数的开发者早就想到了这一点。在平日编程中，也有办法来解决这个问题——那就是用  条件编译  指令！\n3.2 用条件编译解决问题  前情提要：在 C++ 的编译环境中有一个预定义符号__cplusplus\ncout&lt;&lt; __cplusplus &lt;&lt;endl;\n\n在 linux 环境下，编译器打印出了以下数字\n\n而在 windows 的 VS2019 编译器下打印了下面的数字\n\n咱先不管这个数字是啥意思（看起来是一个日期），至少在 C 语言中是没有这个预定义符号的\n\n这样我们就可以利用这个预定义符号，假设是 C++ 环境，就放出 extern&quot;C&quot; 来声明函数，如果是 C 语言环境，就不用extern&quot;C&quot;\n方法一：批量 extern\n#ifdef __cplusplusextern &quot;C&quot; &#123;#endif    void Add(int a,int b);    int fun(int a,int b);    // 这里可以放多个函数的声明    //……    #ifdef __cplusplus&#125;#endif\n\n方法二：define 一个符号为extern&quot;C&quot;，然后在每一个定义前面单独加\n#ifdef __cplusplus\t#define EXTERN extern &quot;C&quot; #else\t#define EXTERN#endifEXTERN void Add(int a,int b);EXTERN int fun(int a,int b);EXTERN int func(int a,int b);//……\n\n这样不管是 C 语言，还是 C++ 的程序，都能正常建立符号表，找到对应的函数\n\nGithub：wiringPi 库源码仓库\n\n可以看到，大佬当初编写 wiringPi 库的时候就用了这个方法，这也是为什么在我的树莓派上，G++ 编译器也能直接识别出 wiringPi 库的原因\n\n\n在找这部分资料的时候，还发现了一个小故事：wiringPi库现在已经不官方开源了。因为有很多初学者拿代码去烦原作者（于是作者在官网上写了“这不是给初学者玩的”告示）还有很多人倒卖他写的库，所以他就在最后一次公开后，停止了官方开源\n\n3.3C 语言调用 C++ 的库  同理，有的时候我们也会用 C 语言来调用 C++ 的库\n但是！就如我  上头  说的，这个库里面，可以供 C 语言调用的函数  不能有 C++ 的语法和函数重载\n\nGithub：TcMalloc 代码仓库\n\n比较好的一个例子是  谷歌  的 tcmalloc 库：此存储库包含 TCMalloc 的 C++ 代码。 TCMalloc 是谷歌对 C 的 malloc（）和 C++ 运算符的定制实现，用于在我们的 C 和 C++ 代码中分配内存。TCMalloc 是一个快速的多线程 malloc 实现。\n\n整个库的函数入口是在 tcmalloc.cc 中定义的，打开它可以看到，虽然大部分代码都是用 C++ 实现的，但是少部分函数接口因为没有 C++ 的语法，所以使用了 extern &quot;C&quot; 让 C 语言也支持它\n\n但是我还发现，有些带有 C++ 的函数接口，也用了extern &quot;C&quot;，那是不是我们上面的结论错了呢？\n\n实践出真知！\n4 自己整一个静态库 4.1C++ 调用 C 语言静态库 首先创建一个 VS 的空项目，把我之前写的 C 语言单链表代码放进去\n\n右键这里的项目名称 - 属性，然后在  配置属性 - 常规 - 配置类型  中，把项目改成静态库\n\n修改完毕后，编译程序，你会发现 debug 目录下多了静态库文件.lib\n\n然后在我们当前的 C++ 项目中，修改  项目属性 - 链接器 - 常规 - 附加库目录  和项目属性 - 链接器 - 输入 - 附加依赖项\n\n\n最后以 #include &quot;../Slist/Slinklist.h&quot; 的形式引用静态库\n你会发现直接引用是会报错的，因为这个单链表的库是用 C 语言写的，我们没有使用 extern &quot;C&quot; 来引用\n\n使用了之后，程序正常调用了 C 语言的库，并打印出了结果！\n\n4.2C 语言调用 C++ 静态库  接着，我们再写一个简单的 C++ 程序，用上面同样的方法编译成静态库，并在 C 语言的项目中调用它\n\n可以看到，这个  没有任何 C++ 语法  的 C++ 静态库被正常调用并打印出了结果\n\n如果我们不使用extern &quot;C&quot;，C 语言项目就无法正常使用该静态库\n\n而当我们在 C++ 的静态库中包含 C++ 的头文件后，C 语言项目中也报错了！\n#include &lt;iostream&gt;using namespace std;\n\n光是链接库函数头文件和命名空间就报错了，那不能使用带 C++ 语法的函数也是板上钉钉的事情了！\n\n而在具有 extern &quot;C&quot; 属性的路径中，也不能包含函数重载，VS 会报错\n\n在头文件中定义自己的命名空间，在 C 语言项目中也是无法通过编译的\nnamespace muxue &#123;\tint a = 0;&#125;using namespace muxue;\n\n\n现在可以确认我们的结论，只有不包含任何 C++ 的语法和函数重载的 C++ 静态库，才能正常被 C 语言项目调用！\n勘误，上述结论错误\n22-05-06，在同学的提示下，发现了这个错误\n\n之前 C 调用 C++ 的方式有问题，因为我是直接把 C++ 的语法放到了  头文件  中，在展开的时候 C 程序编译会报错\n但如果把 C++ 的语法放入 cpp 文件，头文件中不包含的话，就不会报错了！\n\n可以看到在最后的测试项目中，C 语言程序成功调用了 c++ 的语法并正确输出了内容\n\n这也能解释我关于谷歌 TCmalloc 库的疑惑了，看来 C 和 C++ 真的是互通有无啊！\n\n结语  本篇笔记详细解释了 C++ 中函数重载的类型，以及背后的实现原理。\n这个博客花了我整整 4 小时的时间，感觉很充实！\n\n所以求个赞不过分吧！谢谢大家！\n\n\n","categories":["遇见C++"],"tags":["Linux","C++"]},{"title":"【C++】特殊类设计 | 单例模式","url":"/posts/3618449948/","content":"本篇博客让我们来康康一些特殊类的实现方式！\n\n\n1. 不支持拷贝的类  在一些场景下，比如智能指针、多线程操作、IO 流等是不支持拷贝的。因为它们的拷贝会导致一些问题，秉着  解决不了问题，就解决提出问题的人  的思路，禁止了这些类的拷贝\nC++98中，可以将拷贝构造和 = 重载 只声明不定义，并将其访问权限设置为  私有\n\n设置为私有可以防止其他人在类外定义\n\nC++11中，提供了一个特殊的关键字 delete 来禁止实现拷贝构造和 = 重载\n// 禁止拷贝的类class BanCopy&#123;public:\t// 构造\tBanCopy()\t&#123;\t\t_a = _b = 0;\t&#125;\t\t//C++11\tBanCopy(const BanCopy&amp; c) = delete;\tBanCopy&amp; operator=(const BanCopy&amp; c) = delete;private:\t//C++98 的办法，声明为私有且不定义\t//BanCopy(const BanCopy&amp; c);\t//BanCopy&amp; operator=(const BanCopy&amp; c);\t\tint _a;\tint _b;&#125;;\n\n\n2. 只能在堆上创建的类  操作方法和上面的思路类似，只需要把构造函数私有化就可以了\n\n同时还需要取消拷贝构造，否则可以用拷贝构造在栈上开一个新的对象\n赋值重载不一定需要取消，因为赋值重载无法创建新对象\n\n// 只能在堆上开辟class HeapOnly &#123;public:\tstatic HeapOnly* CreatObj(int a,int b)\t&#123;\t\treturn new HeapOnly(a, b);\t&#125;private:\t// 构造函数私有\tHeapOnly()\t\t:_a(0),\t\t_b(0)\t&#123;&#125;\tHeapOnly(int a,int b)\t\t:_a(a),\t\t_b(b)\t&#123;&#125;\t// 同时拷贝构造也需要私有，禁止拷贝创建对象\tHeapOnly(const HeapOnly&amp; h) = delete;\t// 赋值不一定需要 delete，因为赋值不能创建新对象\t// HeapOnly&amp; operator=(const HeapOnly&amp; h) = delete;\tint _a;\tint _b;&#125;;\n\n这样写了之后，想创建对象就可以调用 static 函数来操作\n\n而且因为我们并没有私有化析构函数，所以析构是可以正常调用的！\n2.1 另类操作  还可以使用 static 函数提供一个接口来专门处理析构，再把  析构函数设计成私有，构造函数公有；\n// 只能在堆上开辟class HeapOnly &#123;public:\tstatic HeapOnly* CreatObj(int a,int b)\t&#123;\t\treturn new HeapOnly(a, b);\t&#125;\tstatic void DelObj(HeapOnly* ptr)\t&#123;\t\tdelete ptr;\t&#125;\t// 因为析构私有了，所以可以把构造公有\tHeapOnly()\t\t:_a(0),\t\t_b(0)\t&#123;&#125;\tHeapOnly(int a, int b)\t\t:_a(a),\t\t_b(b)\t&#123;&#125;private:\t// 构造函数私有\t// ....\t// 同时拷贝构造也需要私有，禁止拷贝创建对象\tHeapOnly(const HeapOnly&amp; h) = delete;\t// 赋值不一定需要 delete，因为赋值不能创建新对象\t// HeapOnly&amp; operator=(const HeapOnly&amp; h) = delete;\t~HeapOnly()\t&#123;\t\t_a = _b = 0;\t&#125;\tint _a;\tint _b;&#125;;\n\n这样设计了之后，直接在  栈上 &#x2F; 全局区  开辟空间会报错，但是 new 不受影响。\n在栈上创建一个对象，编译此代码会报错，因为析构函数无法被正常访问，所以无法编译成功；\n$ g++ test.cpp -o testtest.cpp: In function ‘int main()’:test.cpp:133:14: error: ‘HeapOnly::~HeapOnly()’ is private within this context     HeapOnly h3;              ^~test.cpp:122:2: note: declared private here  ~HeapOnly()  ^\n\n因为析构私有了，所以 delete 不能正确调用析构函数，我们需要使用 static 函数指定指针进行析构\n\n除了 static 函数的这种办法，还有另外一个法子可以不传入对象的指针；\n// 删除自己void DelObj()&#123;    delete this;&#125;\t\n\n直接用对象调用此成员函数即可\nHeapOnly* h6 = new HeapOnly();h6-&gt;DelObj();\n\n只不过这样操作可能有些不太好理解，视具体情况而定喽！\n3. 只能在栈上创建的类  相同的思路，设计一个 static 的创建对象函数，来创建一个栈上的对象return\n// 只能在栈上开辟class StackOnly&#123;public:\tstatic StackOnly CreatObj()\t&#123;\t\treturn StackOnly();// 创建匿名对象返回，编译器直接优化为一个构造\t\t// 这么写的话，就不能禁止拷贝构造\t\t//StackOnly st;\t\t//return st;\t&#125;\t// 不能禁用拷贝构造，因为 return 的时候可能会调用（编译器优化是取决于平台的）private:\tStackOnly()\t&#123;\t\t_a = _b = 0;\t&#125;\tint _a;\tint _b;&#125;;\n\n这里我们必须要有拷贝构造，因为 return 的时候，编译器如果不优化，那就是构造 + 拷贝，优化了之后才能变成直接构造\n这是取决于平台的，如果禁用了拷贝，万一有些平台编译器没有做这种优化，你的代码就跑不动了\n\n另外，还有一个方法便是禁用掉operator new()，以此禁止了在堆上创建空间。如果用这种办法，构造函数就不需要设计为私有了\n\n但是这两个办法都有个缺陷，那就是用户可以用  拷贝构造  在静态区上创建一个对象。这只能算个小瑕疵，可以不用管它\n\n4. 单例模式  单例模式是  设计模式  的其中一种\n\n设计模式是一套被反复使用且较为流行的代码设计经验总结。\n设计模式有非常多，感兴趣的老哥可以去搜专门的博客了解一下\n\n单例模式：一个类只能创建一个对象。该模式可以保证在一个进程中，某一个类只会有  一个实例化的对象\n\n举个例子，比如服务器的配置信息是一个类，这个类就可以设计成单例模式，保证所有人访问到的配置信息完全相同，修改的时候也能同步给所有人。\n\n4.1 饿汉  饿汉模式采用 static 成员来实现单例，思路和上面也是一样的，让构造函数私有而无法创建其他对象\n\n那我们的 static 对象要怎么创建呢？\n\n先来看看下面的代码\n// 单例模式（饿汉）// 饿汉模式采用 static 对象，是在 main 函数之前创建的// 会影响程序启动的速度class Singleton&#123;public:\tstatic Singleton* GetInstance()\t&#123;\t\treturn _sgp;\t&#125;\tvoid Print()\t&#123;\t\tcout &lt;&lt; &quot;----- System Info -----&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;     CPU &quot; &lt;&lt; _cpu &lt;&lt; endl;\t\tcout &lt;&lt; &quot;     GPU &quot; &lt;&lt; _gpu &lt;&lt; endl;\t\tcout &lt;&lt; &quot;     MEM &quot; &lt;&lt; _mem &lt;&lt; endl;\t\tcout &lt;&lt; &quot;-----     End     -----&quot; &lt;&lt; endl;\t&#125;private:\tSingleton()\t\t:_cpu(&quot;i9-12900ks&quot;),\t\t_gpu(&quot;RTX 4090&quot;),\t\t_mem(&quot;128GB&quot;)\t&#123;&#125;    Singleton(const Singleton&amp; s) = delete;    Singleton&amp; operator==(const Singleton&amp; s) = delete;\tstring _cpu;\tstring _mem;\tstring _gpu;\t//static Singleton _sg;// 声明\tstatic Singleton* _sgp;// 声明&#125;;//Singleton Singleton::_sg;// 定义Singleton* Singleton::_sgp = new Singleton();// 定义// 因为这里的 sg 和 sgp 都是属于类里面的成员，不受访问限定符的限制，才可以正常调用构造函数\n\n因为 _sg/_sgp 这两个成员都在类内部声明的，所以它们属于整个类域，可以成功访问到内部的构造函数。\n而在其他地方的对象由于没有办法访问到构造函数，而无法创建\n\n由于饿汉模式是 static 对象，其初始化是在 main 函数之前进行的。如果采用饿汉模式的单例过多，程序迟迟没有运行到 main 处，会导致一个程序启动很慢\n4.2 懒汉  一开始不创建对象，第一调用 GetInstance 再创建对象\n// 懒汉// 一开始不创建对象，第一调用 GetInstance 再创建对象class InfoMgr&#123;public:\tstatic InfoMgr* GetInstance()\t&#123;\t\tif (_sp == nullptr)\t\t&#123;\t\t\t_sp = new InfoMgr;\t\t&#125;\t\treturn _sp;\t&#125;\tvoid SetAddress(const string&amp; s)\t&#123;\t\t_address = s;\t&#125;\tstring&amp; GetAddress()\t&#123;\t\treturn _address;\t&#125;private:\tInfoMgr()\t\t:_address(&quot;bilibili&quot;),\t\t_secretKey(1234)\t&#123;&#125;\tInfoMgr(const InfoMgr&amp;) = delete;\tInfoMgr&amp; operator==(const InfoMgr&amp;) = delete;\tstring _address;\tint _secretKey;\tstatic InfoMgr* _sp; // 声明&#125;;InfoMgr* InfoMgr::_sp = nullptr; // 定义\n\n这里我们将内部的 _sp 定义为了 nullptr，如果谁第一个调用，做一个判断，如果是nullptr 就创建实例\n\n由于懒汉可能会出现多个线程同时第一次访问这个单例，就会导致在两个线程中都在初始化这个单例，而某一次初始化会失败。这是一个线程安全问题，需要我们对单例进行加锁操作\n\n多线程加锁问题，参考 linux 下的操作：C++ 线程操作；C++ 的操作以这个思路，修改为使用 C++ 的 thread 库即可\n\n4.3 二者优缺点  饿汉的优点\n\n简单易用\n因为是在 main 函数前初始化，处于单线程状态，没有线程安全问题\n\n缺点：\n\n但是初始化顺序不确定，如果有其他类的依赖关系，可能会出现依赖项 B 在当前单例 A 后初始化，导致 A 无法完成初始化而程序 boom\n饿汉单例是在 main 函数之前创建的，拖慢程序启动速度\n\n\n懒汉的优点\n\n第一次调用的时候才初始化变量，提高程序启动速度\n可以控制初始化顺序，按顺序来初始化，避免依赖关系问题\n\n缺点：\n\n第一次调用的时候，加载会慢一些\n\n基于这两个的优缺点，让我想出来一个不算办法的办法\n如果想控制饿汉的初始化顺序，可以在 main 一启动的时候，就调用一个初始化函数来初始化这些单例。这样依旧会拖慢进程启动的顺序，但解决了初始化顺序的问题！\n\n实际上，一个单例究竟要不要在 main 之前就初始化需要看具体情况的！\n\n4.4 单例释放资源  一般情况下，单例的类是不需要手动释放的，因为整个进程都需要使用这个单例\n但如果我们的单例和一个文件挂钩，进程结束的时候，需要将单例里面的信息保存到文件里面，要怎么操作？\n可以写一个垃圾回收类，在最后调用析构来回收资源\n// 懒汉 -- 一开始不创建对象，第一调用 GetInstance 再创建对象class InfoMgr&#123;public:\tstatic InfoMgr* GetInstance()\t&#123;\t\t// 还需要加锁，留着后面填坑\t\tif (_spInst == nullptr)\t\t&#123;\t\t\t_spInst = new InfoMgr;\t\t&#125;\t\treturn _spInst;\t&#125;\tvoid SetAddress(const string&amp; s)\t&#123;\t\t_address = s;\t&#125;\tstring&amp; GetAddress()\t&#123;\t\treturn _address;\t&#125;\t// 实现一个内嵌垃圾回收类    \tclass CGarbo &#123;\tpublic:\t\t~CGarbo() &#123;\t\t\tif (_spInst)\t\t\t\tdelete _spInst;\t\t&#125;\t&#125;;\t// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象\tstatic CGarbo Garbo;// 声明private:\tInfoMgr()\t\t:_address(&quot;bilibili&quot;),\t\t_secretKey(1234)\t&#123;&#125;\t~InfoMgr()\t&#123;\t\t// 假设析构时需要信息写到文件持久化\t&#125;\tInfoMgr(const InfoMgr&amp;) = delete;\tstring _address;\tint _secretKey;\tstatic InfoMgr* _spInst; // 声明&#125;;InfoMgr* InfoMgr::_spInst = nullptr; // 定义InfoMgr::CGarbo Garbo;// 定义\n\n4.5 static 单例  有人会采用下面的方式来实现懒汉的单例，其采用 static 对象，让编译器自动帮我们实现单例！\n\n全局 static 变量会在 main 之前初始化\n局部 static 变量会在第一次调用的时候初始化\n\nclass Singleton&#123;public:\tstatic Singleton* GetInstance()\t&#123;\t\t// 局部的静态对象，第一次调用时初始化\t\tstatic Singleton _s;\t\treturn &amp;_s;\t&#125;private:\t// 构造函数私有\tSingleton()&#123;&#125;;\t// 拷贝构造 / 赋值重载取消\tSingleton(Singleton const&amp;) = delete;\tSingleton&amp; operator=(Singleton const&amp;) = delete;&#125;;\n\n但是！这个操作并不通用，其取决于编译器和平台的实现。特别是在 C++11 之前；\nC++11 之后，保证了局部静态变量初始化时的线程安全，我们便可以采用这种办法来实现单例。\n\nC++11 中局部 static 变量的线程安全问题\n\n但是！一定要确认你的代码只在 C++11 的环境下运行！！\n4.6 线程安全  在创建单例的时候，我们需要考虑到线程安全的问题，具体请参考 linux 博客中  线程池单例类  对线程安全的处理。特别是其中进行了两次 nullptr 的判断的原因\n5. 不能被继承的类C++98 中，只需要将构造函数私有，派生类无法调用基类构造函数，也就无法继承\n// c++98, 构造私有class A &#123;public:\t// 额外提供一个获取对象的方式\tstatic A GetInstance()\t&#123;\t\treturn A();\t&#125;private:\tA()\t&#123;\t\t_a = 0;\t&#125;\tint _a;&#125;;\n\n而 C++11 中提供了一个关键字final，用这个关键字修饰类，就无法被继承\n//C++11 直接用关键字 finalclass B final&#123;\t//...&#125;;\n\n结语  几个特殊类到这里就讲解结束辣，其中懒汉多线程加锁还留了一个坑，待后续我会回来更新补上的！\n感谢你看到最后!\n","categories":["遇见C++"],"tags":["C++","类和对象"]},{"title":"【C++】哈希 Hash（未完成）","url":"/posts/593601584/","content":"学习完了红黑树以及 map&#x2F;set，下面让我们来康康另外一种用于查找数据的新方式，那便是哈希表\n\n\n1. 概念  哈希是一种用  下标映射  来查找数据的方式。在 STL 库中，有 map 和 set 的 unordered(即为 stl 库里面的哈希) 版本\n我们可以来对比一下它和红黑树（map/set 的标准版本）的查找时间差距（是通过 for 循环查找所有插入数据来实现的计时）\n\n可以看到，在查找方面，unordered版本查找的速度比正常的 map 和 set 快了一倍有余。之前我已经觉得搜索二叉树的查找已经非常快了，实际上哈希才是真正的快中之快！\n这两种算法的时间复杂度为：\n\n平衡二叉搜索树 O(logN)\n哈希算法 O(1)\n\n因为哈希是直接从对应的下标映射位置找到数据的，这就和我们进行随机访问顺序表里面的数据一样，都是 O(1) 的直接访问\n1.1 下标映射  那么，要怎么对一个数据进行下标映射呢？\n\n假设我们现在有一个长度为 10 的数组\n我们需要存放一组 int 类型的数据，0-9 以内的数字可以直接通过下标映射放入对应位置。而大于 9 的数据则需要进行取模操作，找到对应的下标。比如12%10=2，则放入下标为 2 的位置\n\n那，如果一个下标位置本来就有数据了怎么办? 我们有两种办法来解决这个问题\n1.2 闭散列（开放定址法）当一个下标的位置已经有数据的时候，如果哈希表还没有满，我们可以往这个映射位置的后方插入这个数据\n\n线性探测：依次去找空位置，找到后直接插入\n二次探测：跳跃地找空位置，不会出现太多的拥堵\n\n你可能会问，不对啊。你把别人的位置占了，到时候被人要用这个位置，该怎么去操作啊？\n没错，这个就是闭散列的一大缺点：会占用原本属于其他人的空间。\n1.3 开散列（拉链法）这时候我们就需要用到拉链法。于其在每一个下标映射的位置插入一个数据，我们不如整一个链表。在原有的哈希表中存放链表的头节点。当有相同映射值的数据插入的时候，我们可以执行链表的头插，使其挂载到相同位置的链表上。\n\n这个链表也被称为桶\n\n而没有数据的映射位置，全都为 nullptr 空指针\n\n在这个应用场景下，我们只需要使用单链表即可以完成桶的操作。若使用 list 或者自己写的双链表，则会出现不必要的空间浪费。\n你可能会问，那如果一个映射值挂载了特别多的节点，查找的效率会不会从 O(1) 变成O(N)（即需要遍历一个链表）的时间复杂度呢？\n这就必须要提到哈希表的扩容问题了\n1.4 什么时候需要扩容？在哈希表中，我们一般会定义一个负载因子，用于标记哈希表的数据个数\n负载因子 = 已有元素个数 / 总长度\n\n当负载因子大于一定数量级的时候，也就是哈希表快要满的时候，插入数据遇到冲突的可能性就非常大。即便我们用拉链法挂载了桶，如果冲突很多的话，就容易出现上面说的效率低下问题。\n而如果我们的负载因子不大的时候，大部分情况新插入的节点都能找到它自己独立的没有冲突的映射位置，这样就大大增加了访问效率\n\n需要注意的是，哈希表的映射关系和表的长度相关\n所以当我们扩容之后，需要把当前表内的所有元素拿出来，根据键值重新进行下标映射，插入进新表。\n\n对于开放定址法，负载因子应该限制在 0.8 以下。java的系统库中就以 0.75 作为了负载因子的限制值，超过此值将进行扩容操作\n\n1.5 怎么映射？关于映射的即便理念、冲突、扩容问题我们都已经提到了。现在还有一个重要的问题，那就是怎么映射？\n如果我们插入的数据是 int 或者 char、double 这种可以强转为 int 的类型作为 key，那还算好操作，直接用 int 进行下标映射即可。\n\n那假如我们用 string/ 自定义类型 来作为 key 呢？\n\n这种类型不能直接强制转为 int，虽然 string 我们可以取第一个元素的 ASCII 码作为映射值。但是那么做的冲突会非常多，ABC/ADFC/ASD这些字符串都是以 A 开头，难道我们就要把它放在相同位置下面吗？那样效率也太低了！\n\n可不可以把字符串每一个字符的 ASCII 加起来呢？\n\n这样能解决一定程度上的冲突，但是 ABC/ACB 这种字符串排列不同，但是字符是相同的字符串，就会得出相同的结果造成冲突。\n\n这时候就有一个  不知名的程序猿 [Dennis M. Ritchie](https://baike.baidu.com/item/Dennis M. Ritchie&#x2F;1971171?fromModule&#x3D;lemma_inlink) 想出来了一个超级牛逼的办法：把每一个 char 的 ASCII 都乘上一个数，再进行相加\nsize_t operator()(const string&amp; key)&#123;    size_t hash = 1;    for (auto s : key)    &#123;// 每一次都 *13，避免冲突        hash = hash * 13 + s;    &#125;    return hash;&#125;\n\n因为字符串的排列顺序不相同，所以每一次获得的 hash 值肯定是不同的，再乘上一个数之后，就完美的避免了大部分的冲突问题。\n这个方法可以沿用到所有自定义类型！比如我们之前写的  日期类，就可以把年加入 hash 之后，乘一个数再加月，再乘一个数再加天\n这么牛逼的方法，怎么可能是  不知名程序员  想出来的？咳咳，实际上，Dennis M. Ritchie还有另外一个名字“C 语言之父”\n\n膜拜大佬，大佬牛逼！😍\n\n在本篇博客中就不去讲解 STL 库中 unordered_map/set 的使用办法了，因为它们的使用和基础的 map/set 相差无几。我们直接开始模拟实现\n2. 哈希表 1- 开放定址法 2.1 插入 插入的时候，我们要做的便是遵循哈希表的映射方法，对 key 进行映射，再将 pair 插入进封装好的 vector 中\n插入的思路如下：\n\n首先判断哈希表中是否有相同键值 key 的数据（此时我们写的是不支持键值冗余的哈希表，如果出现相同键值的数据，则不再进行二次插入return false（这里复用了查找函数）\n若没有这个键值，则判断负载因子的占比。这里我设置的负载因子是0.7，超过这个比例的时候，将会执行扩容操作。注意：扩容之后映射的位置会发生变化，所以我们需要对已有的数据进行重新插入。\n扩容（或不需要扩容）结束后，我们利用预先写好的仿函数获取道 key 的 hash 值，找到对应下标位置。这里采用  线性探测  的方法，如果当前的下标位置已经有数据了，则往后查找状态值为 EMPTY/DELETE 的位置，并将我们的数据插入到这个位置上。\n插入成功后，将状态修改为 EXITS，return true 插入结束\n\nbool Insert(const pair&lt;K, V&gt;&amp; kv)&#123;    if (Find(kv.first))// 找到了相同的键值，直接退出（说明已经插入过了）    &#123;        return false;    &#125;    // 负载因子到 0.7 及以上，就扩容（避免冲突）    if (_tables.size() == 0 || _n * 10 / _tables.size() &gt;= 7)    &#123;        size_t newSize = _tables.size() == 0 ? 10 : _tables.size() * 2;        // 扩容以后，需要重新映射        HashTable&lt;K, V, HashFunc&gt; newHT;        newHT._tables.resize(newSize);// 扩容 vector        // 遍历旧表，插入 newHT        for (auto&amp; e : _tables)        &#123;            if (e._state == EXITS)            &#123;                newHT.Insert(e._kv);            &#125;        &#125;        newHT._tables.swap(_tables);        // 利用 vector 的交换，这是一种现代写法的深拷贝    &#125;    HashFunc hf;// 仿函数的实例化    size_t starti = hf(kv.first);    starti %= _tables.size();    size_t hashi = starti;    size_t i = 1;    // 线性探测 / 二次探测    // 线性探测代表是自映射值开始往后依次找为空的位置    // 二次探测指跳着找为空的位置    while (_tables[hashi]._state == EXITS)    &#123;        hashi = starti + i;        ++i;// 依次查找，为线性探测        hashi %= _tables.size();    &#125;    _tables[hashi]._kv = kv;// 插入数据    _tables[hashi]._state = EXITS;// 修改状态码    _n++;// 长度 +1    return true;&#125;\n\n2.2 查找  和之前模拟实现的 map 一样，查找函数我们需要返回一个data，以便用户修改value\n因为这里我们使用的是开放定址法，没有设置桶。所以查找的操作和顺序表的查找没有本质上的区别。\n\n当映射值的位置就是我们需要找的 key，直接返回当前的位置\n当当前映射值的数据不是我们需要找的 key，说明这个地方出现了冲突。这时候我们现需要往后查找（线性探测，依次查找）查找的时候需要判断状态码\n如果状态码为 EMPTY，则代表后面没有这个数据，返回nullptr 代指找不到\n如果状态码为 EXITS 或者DELETE，说明后面还有可能找到这个数据找到数据后返回该数据的引用\n\n\n如果遍历完整个列表，还是没有找到该数据，同样返回nullptr\n\n这里单独说明 DELETE：在 insert 和 find 操作之中，我们可能执行了删除，这时候就有可能导致原本的映射值位置和线性探测后的位置之中出现了状态码为DELETE 的位置。遇到 DELETE 并不代表后面没有这个键值，我们需要继续查找。这点和 insert 的判断不同。\n\n代码实现如下\n// 查找Data* Find(const K&amp; key)&#123;    // 空表    if (_tables.size() == 0)    &#123;        return nullptr;    &#125;    HashFunc hf;// 仿函数的实例    size_t starti = hf(key);// 利用 hash 仿函数算出起始值    starti %= _tables.size();// 进行膜大小，获取道映射值    size_t hashi = starti;    size_t i = 1;    while (_tables[hashi]._state != EMPTY)    &#123;        if (_tables[hashi]._state != DELETE &amp;&amp; _tables[hashi]._kv.first == key)        &#123;            return &amp;_tables[hashi];        &#125;        hashi = starti + i;        ++i;// 线性探测        hashi %= _tables.size();    &#125;    return nullptr;&#125;\n\n2.3 删除  删除操作比较简单，我们利用 find 找到键值后，直接把这个位置的状态码改成 DELETE 即可，并不需要执行释放空间的操作。\n如果没有这个键值，则返回false\n// 删除，找到映射位置之后，直接修改状态码，而不是真的删除这个内容bool Erase(const K&amp; key)&#123;    Data* ret = Find(key);    if (ret)    &#123;        ret-&gt;_state = DELETE;        _n--;        return true;    &#125;    else    &#123;        return false;    &#125;&#125;\n\n\n","categories":["遇见C++"],"tags":["数据结构","C++","哈希"]},{"title":"【C++】文件 IO 流","url":"/posts/520771444/","content":"一起来康康 C++ 中的文件 IO 操作吧\n\n\n[TOC]\n1.operator bool之前写 OJ 的时候，就已经用过上面这种方式来获取多组测试用例\nstring s;while(cin&gt;&gt;s)&#123;\tcout &lt;&lt; s &lt;&lt; endl;&#125;\n\n不过之前一直没有去了解这里的底层原理是什么，借此机会一并说明\nio 流可以进行 while 判断的依据，是因为库的源码中重载了operator bool\n\n没错，operator不仅可以重载一个操作符，它还可以重载一个类型！即将这个类转换为 bool 类型，return 一个 bool 类型的值用于 while 的判断\n同理，重载 int/double 这些类型都是可行的！\n\n另外，要想停止上面的多组输入，在 VS 下可以用 ctrl+z 的方式解决，而不要用 ctrl+c 直接杀掉进程\n\n\n2.C++ 文件 IO 流\nC++ 的文件 io 类设计的较为复杂，其中还出现了菱形继承，也就是我们最常用的iostream\n上面提到的 operator bool 就是基类 IOS 实现的，子类都没有去重写\n\ncout 为标准输出，将数据从内存流中输入到显示器上\ncin 为标准输入，通过键盘输入数据到程序中\ncerr 用于标准错误的输出\nclog 进行日志输出\n\n其中需要注意的一点是，空格和回车  会被当作数据之间的分隔符，所以字符串中不能有空格，回车和空格也不能通过 cin 读入\n如果需要读入带空格的完整一行，可以使用 getline 函数\n\n为什么 cin 和 cout 可以输入输出所有类型？\n\n因为库里面已经将所有类型通过操作符重载 &lt;&lt; 和&gt;&gt; 实现了，达到了  自动类型识别  的效果\n3. 文件操作 C++ 标准库中提供的打开方式如下，我们可以根据不同情况传入不同的值，或者一次性用按位或| 传入多个打开方法\n\n同时因为 C++ 类和对象会自动调用析构函数，所以我们也不需要手动 close 文件\n3.0 关于按位与的说明  这里为何可以用按位与传入多个方法？\n假设这些方法就是简单的数字2/4/8（必须是 2 的倍数）我们可以通过按位与了之后，在按位或，判断某一个数字是否在其中\n\n如果或了之后的数字等于它本身，说明数据在其中！\n\n为什么需要是 2 的倍数呢？\n\n\n\n这种方法在 linux 中常见，比如 linux 系统的文件接口\n\n3.1 ifstream\n这个对象是用于读取文件的，默认情况下，传入的打开方法为in\nvoid test1()&#123;\tifstream ifs(&quot;test.txt&quot;);\twhile (ifs)\t&#123;\t\tchar ch = ifs.get();\t\tcout &lt;&lt; ch;\t&#125;&#125;\n\n\n因为重载了 bool，所以可以很方便的直接用 while 来判断结束，成功输出了文件中的内容\nifstream ifs(&quot;test.txt&quot;);char ch;while (ifs &gt;&gt; ch)&#123;\tcout &lt;&lt; ch;&#125;\n\n第二种读取方法采用了流插入 &gt;&gt; 上面提到过，流提取和插入的时候，会把空格和换行当作数据的分隔符，所以它是不能打印出空格和换行\n\n3.2 ofstream\n写文件的方式同上，用 out 方法打开文件就可以了（默认传的就是 out）\nofstream ifs2(&quot;test1.txt&quot;,ios::out);char str[] = &quot;i love u\\n&quot;;ifs2.write(str,sizeof(str));\n\n\n不过这个和 C 语言的 w 方法一样，写入的时候会覆盖文件中已有的内容。如果想进行追加，则需要在后面加上app；如果是执行二进制读写，则需要与上ios::binary\nofstream ifs2(&quot;test1.txt&quot;,ios::out|ios::app);char str[] = &quot;i love u&quot;;ifs2.write(str,sizeof(str));\n\n\n运行成功后会在文件尾部追加内容\n注意，这里的字符串不能用 string 进行处理，因为 string 内部只存了一个指向字符串空间的指针，写入 string 相当于把指针写入进文件中，是么有用的！\n\n流插入文本  但是，如果我们用 &lt;&lt; 进行提取的时候，就可以用 string 了\nvoid test2()&#123;\tifstream ifs(&quot;test.txt&quot;);\tofstream ofs(&quot;test1.txt&quot;);\tchar ch;\tch = ifs.get();\twhile (~ch)\t&#123;\t\tofs &lt;&lt; ch;\t\tcout &lt;&lt; ch;\t\tch = ifs.get();\t&#125;\tstring s(&quot;i love you&quot;);\tofs &lt;&lt; s;&#125;\n\n程序运行后，会把 test.txt 中的内容输出到控制台，同时写入到test1.txt\n最后还会写入一个 string 的内容\n\n这是因为我们调用 &lt;&lt; 的时候，就和 cin&lt;&lt;s 一样，调用的是 string 重载的流提取操作符\n底层实现的时候会将其转为 C 语言的字符串，从而写入到了文件中\n\n所以当我们需要写入一个自定义类型的时候，可以重载  流提取  操作符，不仅可以更方便的打印，还可以写入到文件中\n\n\n3.3 ostringstream&#x2F;istringstream这个类可以将不同的类型转为字符串\n这种操作被称为  序列化和反序列化，在处理自定义类型的时候非常好用\nstruct Date&#123;public:\tfriend ostream&amp; operator &lt;&lt; (ostream&amp; out, const Date&amp; d);\tfriend istream&amp; operator &gt;&gt; (istream&amp; in, Date&amp; d);\tDate(int y=0, int m=0, int d=0)\t&#123;\t\t_year = y;\t\t_month = m;\t\t_day = d;\t&#125;private:\tint _year;\tint _month;\tint _day;&#125;;istream&amp; operator &gt;&gt; (istream&amp; in, Date&amp; d)&#123;\tin &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;\treturn in;&#125;ostream&amp; operator &lt;&lt; (ostream&amp; out, const Date&amp; d)&#123;\tout &lt;&lt; d._year &lt;&lt; &quot; &quot; &lt;&lt; d._month &lt;&lt; &quot; &quot; &lt;&lt; d._day;\treturn out;&#125;void test4()&#123;\tint i = 123;\tdouble d = 44.55;\tostringstream oss;// 序列化\toss &lt;&lt; i;\tstring stri = oss.str();\toss.str(&quot;&quot;);// 清空 oss\toss &lt;&lt; d;\tstring strd = oss.str();\tcout &lt;&lt; strd&lt;&lt; endl;\toss.str(&quot;&quot;);// 清空 oss\tDate d1(2022, 10, 11);\toss &lt;&lt; d1;\tstring strdt = oss.str();\tcout &lt;&lt; strdt &lt;&lt; endl;\tistringstream iss(strdt);// 反序列\tDate d2;\tiss &gt;&gt; d2;\tcout &lt;&lt; d2 &lt;&lt; endl;&#125;\n\n\n3.4 stringstream这个对象可以用于字符串拼接，也可以用来将其他类型转为 str\nstringstream sstream;// 将多个字符串放入 sstream 中sstream &lt;&lt; &quot;first&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;string,&quot;;sstream &lt;&lt; &quot; second string&quot;;cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;// 清空 sstreamsstream.str(&quot;&quot;);sstream &lt;&lt; &quot;third string&quot;;cout &lt;&lt; endl;cout &lt;&lt; &quot;After clear, strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;\n\n\n3.5 使用 stringstream 的注意事项\nstringstream 实现转换，实际上是维护了一个 string 对象实现的\n\n我们可以使用 str(&quot;&quot;) 清空里面的 string 对象，设置为空字符串\n\n多次数据类型转换的时候，需要用 clear() 来清空，才能正确转换。不过 clear() 不会清空底层的 string 对象\n\n因为使用的是 string 对象，所以使用的时候不需要格式化控制，可以自动推导类型\n\n\nstringstreams在转换结尾时 (即最后一个转换后), 会将其内部状态设置为badbit 因此下一次转换是必须调用 clear() 将状态重置为 goodbit 才可以继续转换\n\n这里在第一次调用 stringstream 操作后，我们没有进行 clear，会发现后续的 double 类型转换失败了\n\n执行了 clear 之后，转换成功！\n结语  关于 C++IO 流操作的基本认识到这里就 over 了。\n因为在实际中用的并不算多，所以这部分的内容大多数是了解一二，知道如何使用，以及 3.0 中提到的按位与操作是怎么实现的就 OK 了！\n","categories":["遇见C++"],"tags":["文件","C++"]},{"title":"【C++】智能指针","url":"/posts/1282431418/","content":"终于来填坑了😂\n2022-10-19 -&gt; 2023-04-01\n\n1. 情景  对于 C&#x2F;C++ 而言，内存泄漏是一个老生常谈的问题。每次进行 new 操作之后，我们都需要对其进行对应的delete，已避免内存泄漏。\n可代码一长，逻辑复杂起来了，想处理就没有那么容易了。\n1.1 代码太长，看不到头int main()&#123;\tint* arr1 = new int[10];\tint* arr2 = new int[10];\t// 中间有超级多行代码    delete arr1[];    delete arr2[];&#125;\n\n我们日常的学习，可能写的代码并不是很多。但如果是一个大型的项目，new 和 delete 之中可能隔了  成千上万  行代码，那时候还想去找这个变量的位置，可就不那么好找了。极其容易出现忘记 delete 的情况\n1.2 异常安全int func(int a,int b)&#123;    if(b==0)    &#123;        throw invalid_argument(&quot; 除 0 错误 &quot;);    &#125;    return a/b;&#125;void test()&#123;    int* arr1 = new int[10];\tint* arr2 = new int[10];\tfunc(1,0);// 抛异常    delete[] arr1;    delete[] arr2;&#125;int main()&#123;\ttry&#123;         test();    &#125;   \tcatch(...)&#123;        cout &lt;&lt;&quot; 出现异常 &quot;&lt;&lt;endl;    &#125;    return 0;&#125;\n\n如上面的代码，在 test 函数中，调用了另外一个会抛出异常的函数。如果这个函数抛出了异常，后续的 delete 操作不会被执行，出现内存泄漏。\n如果操作的堆区变量较少，可以采用如下的方式来解决这个问题\nint func(int a,int b)&#123;    if(b==0)    &#123;        throw invalid_argument(&quot; 除 0 错误 &quot;);    &#125;    return a/b;&#125;void test()&#123;    int* arr1 = new int[10];\tint* arr2 = new int[10];\ttry&#123;        func(1,0);// 抛异常    &#125;    catch(...)&#123;// 接管异常    \t// 销毁        delete[] arr1;    \tdelete[] arr2;        throw;// 原样抛出    &#125;    delete[] arr1;    delete[] arr2;&#125;int main()&#123;\ttry&#123;         test();    &#125;   \tcatch(...)&#123;        cout &lt;&lt;&quot; 出现异常 &quot;&lt;&lt;endl;    &#125;    return 0;&#125;\n\n但是，这样并不能完全解决问题，因为 new 函数本身也有可能抛出异常！\nvoid test()&#123;    int* arr1 = new int[10];\tint* arr2 = new int[10];// 这里抛异常了    // 此时无法被接管！    // arr1 没有被析构，出现内存泄漏    \ttry&#123;        func(1,0);// 抛异常    &#125;    catch(...)&#123;// 接管异常    \t// 销毁        delete[] arr1;    \tdelete[] arr2;        throw;// 原样抛出    &#125;    delete[] arr1;    delete[] arr2;&#125;\n\n把 new 也丢到 try 里面？依旧不行（详见注释）\nvoid test()&#123;    try&#123;        int* arr1 = new int[10];        int* arr2 = new int[10];// 这里抛异常了        int* arr3 = new int[10];\t        func(1,0);// 抛异常    &#125;    catch(...)&#123;    \t// 你不知道哪一个出了异常！        // 假设 arr2 出异常，arr2 和 arr3 都没有申请空间成功        // 怎么进行销毁？        delete[] arr1;    \tdelete[] arr2;        delete[] arr3;        throw;// 原样抛出    &#125;    delete[] arr1;    delete[] arr2;    delete[] arr3;&#125;\n\n而且，如果需要操作的 new 变量很多，那么在 catch 里面就需要加上多个 delete，代码就显得过于重复了。\n为了解决这个问题，C++ 引入了  智能指针\n2. 智能指针2.1 RAIIRAII - Resource Acquisition is Initialization\n\n需要注意的是，RAII 是一种  思想，并不能用它来指代智能指针\nRAII != 智能指针\n\n它是一种利用对象的生命周期来控制程序资源（内存、文件句柄、网络链接、互斥量等）的技术\n\n只要是两步操作的，需要申请 + 释放的资源，都可以使用 RAII 的思想来进行处理。比如自己封装一个自动处理 pthread_mutex 锁的 init 和 destory 的类\n\n说人话就是，在对象  构造  的时候获取资源，析构  的时候释放资源。\n\n在对象生命周期到了之后，会自动释放资源，免去了我们手动释放资源 or 忘记释放的繁琐\n资源在对象的生命周期内始终有效\n\n在大型项目中，一般都会用智能指针来管理堆区空间\n3.demo3.1 基础示例  在认识不同类型的智能指针之前，先来看个最简单的 demo\n#pragma oncenamespace mu &#123;\tusing std::cout;\tusing std::endl;\ttemplate&lt;class T&gt;\tclass SmartPtr\t&#123;\tpublic:\t\tSmartPtr(T* ptr)\t\t\t:_ptr(ptr)\t\t&#123;\t\t\tcout &lt;&lt; &quot;init &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;\t\t&#125;\t\t~SmartPtr()\t\t&#123;\t\t\tcout &lt;&lt; &quot;des  &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;\t\t\tdelete[] _ptr;\t\t&#125;\tprivate:\t\tT* _ptr;\t&#125;;&#125;\n\n上面实现的，就是一个最简单的智能指针。它可以帮助我们管理堆区上的  数组。\n#define _CRT_SECURE_NO_WARNINGS 1//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &quot;demo.hpp&quot;using namespace std;void test1()&#123;\tmu::SmartPtr&lt;int&gt; p1(new int[10]);\tmu::SmartPtr&lt;char&gt; p4(new char[10]);\tmu::SmartPtr&lt;double&gt; p3(new double[10]);\tcout &lt;&lt; &quot;test&quot; &lt;&lt; endl;&#125;int main()&#123;\ttest1();\treturn 0;&#125;\n\n运行后，输出的结果如下\ninit 006697A8init 006724D0init 00668860testdes  00668860des  006724D0des  006697A8\n\n其实现了在构造中托管，在析构中销毁资源的操作。\n\n即便抛出  异常，依旧能正常析构\n#include &lt;iostream&gt;#include &quot;demo.hpp&quot;using namespace std;int func(int a, int b)&#123;\tif (b == 0)\t&#123;\t\tthrow invalid_argument(&quot; 除 0 错误 &quot;);\t&#125;\treturn a / b;&#125;void test1()&#123;\tmu::SmartPtr&lt;int&gt; p1(new int[10]);\tmu::SmartPtr&lt;char&gt; p2(new char[10]);\tmu::SmartPtr&lt;double&gt; p3(new double[10]);\tcout &lt;&lt; &quot;test1&quot; &lt;&lt; endl;\ttry &#123;\t\tfunc(3, 0);\t&#125;\tcatch(...)&#123;\t\tthrow;\t&#125;\t\tcout &lt;&lt; &quot;test2&quot; &lt;&lt; endl;&#125;int main()&#123;\ttry &#123;\t\ttest1();\t&#125;\tcatch (...)\t&#123;\t\tcout &lt;&lt; &quot;mian  出现异常 &quot; &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n注意，如果抛出异常又不进行 catch，程序会被 abort 终止，无法观测到现象。\n以下是运行的结果，可以看到异常出现后，走到了 test1 函数的生命周期末尾，释放了 3 个指针，才被 main 中的 catch 捕获\ninit 012B8F00init 012C3010init 012B8860test1des  012B8860des  012C3010des  012B8F00mian  出现异常\n\n3.2 运算符重载  当然，这个智能指针还是却少很多东西的\n\n写死了delete[]，我只想让她管理单个变量怎么办？\n如何获取指针内的资源？\n\n第一个问题我们暂且不提（后续讲解库中智能指针的时候会说明）第二个问题的答案便是：重载 * 和-&gt;操作符\nT&amp; operator*()&#123;    return *_ptr;&#125;T* operator-&gt;()&#123;    return _ptr;&#125;T&amp; operator[](const T&amp; n)&#123;    return _ptr[n];&#125;\n\n重载了之后，我们就可以操作类内的指针成员了\nvoid test1()&#123;\tmu::SmartPtr&lt;int&gt; p1(new int[10]);\tmu::SmartPtr&lt;char&gt; p2(new char[10]);\tmu::SmartPtr&lt;double&gt; p3(new double[10]);\tcout &lt;&lt; &quot;test&quot; &lt;&lt; endl;\tp2[0] = &#x27;a&#x27;;\tp2[1] = &#x27;b&#x27;;\tp2[2] = &#x27;\\0&#x27;;\tcout &lt;&lt; p2[0] &lt;&lt;&quot; &quot;&lt;&lt; p2[1] &lt;&lt; endl;\tcout &lt;&lt; *p2 + 1 &lt;&lt; endl;&#125;\n\n运行结果如下\ninit 01661C30init 01671748init 016689B8testa b98des  016689B8des  01671748des  01661C30\n\n3.3 拷贝  对于智能指针而言，有一个很重要的问题是针对拷贝的。在一些场景中，我们需要对指针进行拷贝，这时候就会出现异常\nvoid test3()&#123;\tmu::SmartPtr&lt;int&gt; p1(new int[10]);\tmu::SmartPtr&lt;int&gt; p2(p1);&#125;\n\n运行结果如下\ninit 00BBFB20des  00BBFB20des  00BBFB20\n\n编译器报错了\n\n原因就是，默认的拷贝构造使用的是浅拷贝，再析构的时候，两个智能指针对同一个地址析构，相当于析构了两次，肯定是不行的！\n接下来，就让我们看看 cpp 库中是怎么解决这个问题的吧！\n4.auto_ptr为了避免拷贝的时候，导致多次析构，C++98库函数中提供了 auto_ptr。在拷贝的时候，auto_ptr 采用的是  管理权转移  的思路\nauto_ptr&lt;int&gt;  sp1(new int);// 无法继续使用auto_ptr&lt;int&gt;  sp2 = sp1;//sp2 接管了 sp1\n\n当我们这样操作了之后，sp1对象将不能再被使用，其内置指针会被置为nullptr，使用相当于解引用空指针！\n因为这个操作实在太坑人了，如果在某些函数传参的时候，进行值拷贝了，就会导致原有的指针失效，从而引发程序错误。\n所以，在 C++11 之后，应  避免使用auto_ptr（一些公司会明令禁止使用）\n5.unique_ptr\n在 boost 库中，有一个 scpoed_ptr，其就是unique_ptr 的前身\n\nunique 的做法更绝，既然拷贝会出现问题，那我直接  不允许你拷贝  不就行了？\n直接将拷贝构造和赋值重载给 delete 了，即禁止对方使用拷贝。\nunique_ptr(const unique_ptr&lt;T&gt;&amp; n) = delete;unique_ptr&lt;T&gt;&amp; operator=(const unique_ptr&lt;T&gt;&amp; n) = delete;\n\n如果是 C++11 之前，可以采用  只声明不实现  的方式来禁用拷贝构造。为了避免使用者自己写一个拷贝构造，我们需要将其配置为私有。\nprivate:// 只声明不实现  unique_ptr(const unique_ptr&lt;T&gt;&amp; n);  unique_ptr&lt;T&gt;&amp; operator=(const unique_ptr&lt;T&gt;&amp; n);\n\n虽然 unique_ptr 从源头解决了拷贝的问题，但是它有一个小问题：功能不全。\n如果我真的需要拷贝呢？你这个岂不是用不了呀。\n6.shared_ptrshare 即分享，这个智能指针是支持拷贝的。那它应该如何解决同一片空间被释放多次的问题呢？\n6.1 引用计数  为了保证资源只会被释放一次，其采用了引用计数的方式来实现。\n\n初始化的时候，引用计数为 1\n每次拷贝，引用计数都 +1（包括拷贝构造和赋值重载）\n析构的时候，引用计数不为 1，将计数器 -1\n只有引用计数为 1，才在析构的时候释放资源\n\n这样就解决了被析构多次的问题！\n6.2 如何实现？\n直接使用一个成员变量？\n\n不行，一个对象的修改不影响第二个对象的成员，依旧会出现析构多次的问题。\n\n使用 static 成员？\n\nstatic 成员属于整个类，这样弄相当于给这个类加了个已有对象数量的计数器，南辕北辙。\nT* _ptr;int* _pcount;// 计数器\n\n我们只需要在对象中添加一个 int 类型的指针，在第一次初始化对象的时候，给这个指针创建堆区的 int 空间，并初始化为 1\n这样每次拷贝、赋值的时候，都给这个 pcount 指向的 int 给+1\n(*_pcount)++\n\n每次析构的时候都-1，只有为 0 的时候，才进行资源释放。同时释放指针托管的资源，和 pcount\n(*_pcount)--;// 先将自己的 -1if((*_pcount==0))// 如果为 0，则代表自己是最后一个&#123;// 释放自己的资源    delete _ptr;    delete _pcount;&#125;\n\n6.3 赋值  赋值有两种情况\nshared_ptr&lt;int&gt; sp1(new int(1));shared_ptr&lt;int&gt; sp2; sp2 = sp1;// 情况 1shared_ptr&lt;int&gt; sp3(new int(3));sp1 = sp3;// 情况 2shared_ptr&lt;int&gt; sp4 = sp1;// 实际上调用的是拷贝构造 \n\n第一种  是对象没有初始化，调用了默认无参构造函数，其内部托管的指针是nullptr，sp2=sp1，相当于是初始化sp2 对象。\n第二种 是对象已经初始化了，但是我想让他管理另外一份资源。\n\n针对情况 1，操作和拷贝构造相同，我们只需要赋值给 sp2 后，将引用计数加 +1 即可\n针对情况 2，我们就需要判断 sp1 的情况了。如果 sp1 的引用计数为 1，则需要先  销毁 sp1 托管的空间，再进行赋值。并将 sp3 的引用计数赋值给 sp1，并将 sp3 的引用计数 +1\n\n落到代码上，应该如下\nshared_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; p)&#123;    if(p._ptr == _ptr)// 指向的空间相同    &#123;        return *this;// 啥都不做    &#125;    (*_pcount)--;// 先将自己的 -1    if((*_pcount==0))// 如果为 0，则代表自己是最后一个    &#123;// 释放自己的资源        delete _ptr;        delete _pcount;    &#125;    // 赋值对方的资源    _ptr = p._ptr;    _pcount = p._pcount;    (*_pcount)++;// 引用计数 +1        return *this;&#125;\n\n6.4 简单实现  库中的实现更为复杂，其还重载了 &lt;&lt; 操作符，实现了更多成员函数\ntemplate&lt;class T&gt;   class shared_ptr   &#123;       public:           shared_ptr(T* ptr = nullptr)               :_ptr(ptr),           _pcount(new int(1))           &#123;               cout &lt;&lt; &quot;[init] &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;           &#125;           // 拷贝构造           shared_ptr(const shared_ptr&lt;T&gt;&amp; p)           &#123;               cout &lt;&lt; &quot;[copy] &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;               _ptr = p._ptr;               _pcount = p._pcount;               (*_pcount)++;// 引用计数 +1           &#125;           // 赋值重载           shared_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; p)           &#123;               cout &lt;&lt; &quot;[operator=] &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;               if (p._ptr == _ptr)// 指向的空间相同               &#123;                   return *this;// 啥都不做               &#125;               // 释放自己的资源（判断）               _Release();               // 赋值对方的资源               _ptr = p._ptr;               _pcount = p._pcount;               (*_pcount)++;// 引用计数 +1               return *this;           &#125;           T&amp; operator*()           &#123;               return *_ptr;           &#125;           T* operator-&gt;()           &#123;               return _ptr;           &#125;           T&amp; operator[](const T&amp; n)           &#123;               return _ptr[n];           &#125;       \tT* get()           &#123;               return _ptr;           &#125;           ~shared_ptr()           &#123;               _Release();           &#125;       private:           void _Release()           &#123;               (*_pcount)--;               cout &lt;&lt; &quot;[des] pcount:&quot; &lt;&lt; (*_pcount) &lt;&lt; &quot; ptr:&quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;               if ((*_pcount) == 0)               &#123;                   cout &lt;&lt; &quot;[des] delete &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl; // 如果释放了资源，会打印这个                   if(_ptr)//_ptr 不为空的时候才释放它                       delete _ptr;                   // 无论什么时候都需要删除计数器，否则会有内存泄漏                   delete _pcount;               &#125;           &#125;       T* _ptr;       int* _pcount;// 引用计数   &#125;;\n\n6.5 测试  用如下代码进行测试\nvoid test4()&#123;\tmu::shared_ptr&lt;int&gt; p1(new int(10));\tmu::shared_ptr&lt;int&gt; p2(p1);\tmu::shared_ptr&lt;int&gt; p3 = p1;// 实际上调用的是拷贝构造\tcout &lt;&lt; &quot;p1 &quot; &lt;&lt; (*p1) &lt;&lt; endl;\tcout &lt;&lt; &quot;p2 &quot; &lt;&lt; (*p2) &lt;&lt; endl;\tcout &lt;&lt; &quot;p3 &quot; &lt;&lt; (*p3) &lt;&lt; endl;\tmu::shared_ptr&lt;int&gt; p4;\tp4 = p1;\tcout &lt;&lt; &quot;p4 &quot; &lt;&lt; (*p4) &lt;&lt; endl;\tmu::shared_ptr&lt;int&gt; p5(new int(20));\tp1 = p5;\tcout &lt;&lt; &quot;p1 &quot; &lt;&lt; (*p1) &lt;&lt; endl;\tcout &lt;&lt; &quot;p5 &quot; &lt;&lt; (*p5) &lt;&lt; endl;&#125;\n\n运行的结果如下\n[init] 00BE0B10[copy] 00000000[copy] 00000000p1 10p2 10p3 10[init] 00000000[operator=] 00000000[des] pcount:0 ptr:00000000[des] delete 00000000p4 10[init] 00BD8B30[operator=] 00BE0B10[des] pcount:3 ptr:00BE0B10p1 20p5 20[des] pcount:1 ptr:00BD8B30[des] pcount:2 ptr:00BE0B10[des] pcount:1 ptr:00BE0B10[des] pcount:0 ptr:00BE0B10[des] delete 00BE0B10[des] pcount:0 ptr:00BD8B30[des] delete 00BD8B30\n\n可以看到，每次析构，实际上都会先对引用计数进行 -1 的操作，只有引用计数为 0 的情况下，才会真的析构掉对应的值。\n赋值的时候，也没有出现内存泄漏的问题！\nvoid test5()&#123;\tmu::shared_ptr&lt;int&gt; p1(new int(10));\tmu::shared_ptr&lt;int&gt; p2(new int(20));\tcout &lt;&lt; &quot;p1 &quot; &lt;&lt; (*p1) &lt;&lt; endl;\tcout &lt;&lt; &quot;p2 &quot; &lt;&lt; (*p2) &lt;&lt; endl;\tp1 = p2;\tcout &lt;&lt; &quot;p1 &quot; &lt;&lt; (*p1) &lt;&lt; endl;\tcout &lt;&lt; &quot;p2 &quot; &lt;&lt; (*p2) &lt;&lt; endl;&#125;\n\np2 在赋值给 p1 之前，先析构了 p1 维护的变元，才进行了赋值操作\n[init] 014DF1B8[init] 014D89A8p1 10p2 20[operator=] 014DF1B8[des] pcount:0 ptr:014DF1B8[des] delete 014DF1B8p1 20p2 20[des] pcount:1 ptr:014D89A8[des] pcount:0 ptr:014D89A8[des] delete 014D89A8\n\n6.6 线程安全问题  在实际应用场景中，可能会出现多线程对该指针进行拷贝的问题。为了避免引用计数 pcount 在多线程拷贝的时候出现二义性问题，需要对引用计数的操作进行加锁\n详见 https://blog.musnow.top/posts/1249427441/ 的 12.shared_ptr\n6.7 循环引用问题 shared_ptr 的引用计数可能会出现  循环引用  的问题，它需要用 weak_ptr 来解决。后文会提到\n7.weak_ptr7.1 简介  这个指针是专门用来辅助解决 shared_ptr 循环引用问题的，可以认为它是 shared_ptr 的小弟。\n//default (1)\tconstexpr weak_ptr() noexcept;//copy (2)\tweak_ptr (const weak_ptr&amp; x) noexcept;template &lt;class U&gt; weak_ptr (const weak_ptr&lt;U&gt;&amp; x) noexcept;//from shared_ptr (3)\ttemplate &lt;class U&gt; weak_ptr (const shared_ptr&lt;U&gt;&amp; x) noexcept;//copy (1)\tweak_ptr&amp; operator= (const weak_ptr&amp; x) noexcept;template &lt;class U&gt; weak_ptr&amp; operator= (const weak_ptr&lt;U&gt;&amp; x) noexcept;//from shared_ptr (2)\ttemplate &lt;class U&gt; weak_ptr&amp; operator= (const shared_ptr&lt;U&gt;&amp; x) noexcept;\n\n相比于其他智能指针的构造函数，weak_ptr只能进行拷贝，或从一个 shared_ptr 来构造。\n它最大的特点就是：只托管资源，不处理引用计数，析构时也不进行资源释放。可以认为，它只是对指针进行了简单的封装。\n这个特性也决定了，weak_ptr不能使用原生指针来构造！\n7.2 什么是循环引用struct ListNode&#123;\tListNode* _prev;\tListNode* _next;\tT _val;\tListNode(const T&amp; val=T())\t\t:_prev(nullptr),\t\t_next(nullptr),\t\t_val(val)\t&#123;\t\tcout &lt;&lt; &quot;[ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;\t~ListNode()\t&#123;\t\tcout &lt;&lt; &quot;[~ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;&#125;;void test6()&#123;\tmu::shared_ptr&lt;ListNode&lt;int&gt;&gt; p1(new ListNode&lt;int&gt;(10));\tmu::shared_ptr&lt;ListNode&lt;int&gt;&gt; p2(new ListNode&lt;int&gt;(20));\t&#125;\n\n上面这个代码是一个最简单的双链表，在没有给链表内节点赋值之前，它是没有问题的。使用智能指针能成功调用对象的析构，并销毁空间\n[ListNode()] 00DE10E0[init] 00DE10E0[ListNode()] 00DE14D0[init] 00DE14D0[des] pcount:0 ptr:00DE14D0[des] delete 00DE14D0[~ListNode()] 00DE14D0[des] pcount:0 ptr:00DE10E0[des] delete 00DE10E0[~ListNode()] 00DE10E0\n\n\n但如果想要将这两个节点链接起来，那就出 bug 了\n首先，自然是我们没办法将一个智能指针赋值给普通的指针，因为类型不同。我们也不能直接对它们进行强转\n\n解决这个问题，那就是将 listnode 中的指针成员也改成智能指针\n// 链表节点template&lt;class T&gt;struct ListNode&#123;\tmu::shared_ptr&lt;ListNode&lt;T&gt;&gt; _prev;\tmu::shared_ptr&lt;ListNode&lt;T&gt;&gt; _next;\tT _val;\tListNode(const T&amp; val=T())\t\t:_prev(nullptr),\t\t_next(nullptr),\t\t_val(val)\t&#123;\t\tcout &lt;&lt; &quot;[ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;\t~ListNode()\t&#123;\t\tcout &lt;&lt; &quot;[~ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;&#125;;void test6()&#123;\tmu::shared_ptr&lt;ListNode&lt;int&gt;&gt; p1(new ListNode&lt;int&gt;(10));\tmu::shared_ptr&lt;ListNode&lt;int&gt;&gt; p2(new ListNode&lt;int&gt;(20));\tp1-&gt;_next = p2;\tp2-&gt;_prev = p1;&#125;\n\n再次运行，诶，出问题了！\n[init] 00000000[init] 00000000[ListNode()] 00FFF1B8[init] 00FFF1B8[init] 00000000[init] 00000000[ListNode()] 00FF8D78[init] 00FF8D78[operator=] 00000000[des] pcount:0 ptr:00000000[operator=] 00000000[des] pcount:0 ptr:00000000[des] pcount:1 ptr:00FF8D78[des] pcount:1 ptr:00FFF1B8\n\n可以看到，虽然 shared_ptr 的析构函数被调用了，但直到最后，都没有打印出 [des] delete，也没有进入ListNode 的析构函数，即出现了内存泄漏！\nvoid _Release()&#123;    (*_pcount)--;    cout &lt;&lt; &quot;[des] pcount:&quot; &lt;&lt; (*_pcount) &lt;&lt; &quot; ptr:&quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;    if ((*_pcount) == 0)    &#123;        cout &lt;&lt; &quot;[des] delete &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl; // 如果释放了资源，会打印这个        if(_ptr)//_ptr 不为空的时候才释放它            delete _ptr;        // 无论什么时候都需要删除计数器，否则会有内存泄漏        delete _pcount;    &#125;&#125;\n\n画个图，看看到底是为甚\n\np1 管理资源 A，p2 管理资源 B；二者引用计数都为 1\np1-&gt;next&#x3D;p2，p1-&gt;next 也开始管理资源 B，引用计数为 2\np2-&gt;prev&#x3D;p1，p2-&gt;prev 也开始管理资源 A，引用计数为 2\n出作用域，先析构 p2，B 引用计数 -1，此时资源 B 是只由 p1-&gt;next 管理的\n后析构 p1，A 引用计数 -1，此时资源 A 是只由 p2-&gt;prev 管理\n但是 p1-&gt;next 必须要完全析构资源 A 才会被释放；同理，p2-&gt;prev也需要完全析构资源 B 才会释放\n\n这时候就陷入了一个死循环，因为资源 A 和资源 B 实际上已经  没有外人  在使用了，它们也无法被彻底释放掉，内存泄漏了！\n\n7.3 解决循环引用问题  讲到这里，如何解决这个问题，就很明了了。因为 weak_ptr 是不进行引用计数的操作的，其只对资源进行托管。我们只需要将 listnode 之中的指针从 shared_ptr 改为 weak_ptr 即可\ntemplate&lt;class T&gt;struct ListNode&#123;\t/*mu::shared_ptr&lt;ListNode&lt;T&gt;&gt; _prev;\tmu::shared_ptr&lt;ListNode&lt;T&gt;&gt; _next;*/\tstd::weak_ptr&lt;ListNode&lt;T&gt;&gt; _next;\tstd::weak_ptr&lt;ListNode&lt;T&gt;&gt; _prev;\tT _val;\tListNode(const T&amp; val=T())\t\t:_val(val)\t&#123;\t\tcout &lt;&lt; &quot;[ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;\t~ListNode()\t&#123;\t\tcout &lt;&lt; &quot;[~ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;&#125;;void test6()&#123;\tstd::shared_ptr&lt;ListNode&lt;int&gt;&gt; p1(new ListNode&lt;int&gt;(10));\tstd::shared_ptr&lt;ListNode&lt;int&gt;&gt; p2(new ListNode&lt;int&gt;(20));\tp1-&gt;_next = p2;\tp2-&gt;_prev = p1;&#125;\n\n可以看到，这时候就能成功释放节点了！\n[ListNode()] 0117F348[ListNode()] 01171950[~ListNode()] 01171950[~ListNode()] 0117F348\n\n7.4 简单实现  库里面的实现比我们这个复杂很多，实现只是为了理解设计思路\ntemplate&lt;class T&gt;class weak_ptr&#123;public:\tweak_ptr()\t\t:_ptr(nullptr)\t&#123;&#125;\t// 构造\tweak_ptr(const shared_ptr&lt;T&gt;&amp; p)\t\t:_ptr(p.get())\t&#123;\t\t_ptr;\t&#125;\t// 拷贝构造\tweak_ptr(const weak_ptr&lt;T&gt;&amp; p)\t\t:_ptr(p._ptr)\t&#123;&#125;\t// 赋值重载\tweak_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; p)\t&#123;\t\t_ptr = p.get();\t\treturn *this;\t&#125;\tweak_ptr&lt;T&gt;&amp; operator=(const weak_ptr&lt;T&gt;&amp; p)\t&#123;\t\t_ptr = p._ptr;\t\treturn *this;\t&#125;\tT&amp; operator*()\t&#123;\t\treturn *_ptr;\t&#125;\tT* operator-&gt;()\t&#123;\t\treturn _ptr;\t&#125;\tT&amp; operator[](const T&amp; n)\t&#123;\t\treturn _ptr[n];\t&#125;private:\tT* _ptr;&#125;;\n\n自己也实现一个简单的weak_ptr，还是用相同的代码进行测试，可以看到，成功进行了析构\n[ListNode()] 00C903C8[init] 00C903C8[ListNode()] 00C90128[init] 00C90128[des] pcount:0 ptr:00C90128[des] delete 00C90128[~ListNode()] 00C90128[des] pcount:0 ptr:00C903C8[des] delete 00C903C8[~ListNode()] 00C903C8\n\n7.5 成员函数  对库中实现的 weak_ptr的成员函数做一定解释\nvoid swap (weak_ptr&amp; x) noexcept; // 交换两个 weak_ptr 托管的指针void reset() noexcept;// 重置 (相当于恢复成默认构造的对象)long int use_count() const noexcept; // 返回 weak_ptr 管理的空间的引用计数（本身不计入）bool expired() const noexcept; // 判断 weak_ptr 是否已经过期（即用于构造这个 weak_ptr 的 shared_ptr 是否已经释放资源）// 因为 weak_ptr 不参与资源的管理，只进行托管。所以如果 shared_ptr 已经将空间释放，那么 weak_ptr 指向的空间就已经过期了，不能继续使用shared_ptr&lt;element_type&gt; lock() const noexcept;// 如果 weak_ptr 没有过期 / 不为空，则返回其托管的 shared_ptr 对象// 等效于返回 expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this) // 该函数具有原子性// https://legacy.cplusplus.com/reference/memory/weak_ptr/lock/// 说实话，这个函数的作用看的不是很懂。下面这个函数就更看不懂了template &lt;class U&gt; bool owner_before (const weak_ptr&lt;U&gt;&amp; x) const;template &lt;class U&gt; bool owner_before (const shared_ptr&lt;U&gt;&amp; x) const;//https://blog.csdn.net/weixin_45590473/article/details/113040456\n\n8. 定制删除器  对于我们自己写的shared_ptr，有一个问题就是，析构的时候，默认是写死的delete；\n如果用户传入的是一个数组 new int[10]，此时delete 就不对应（需要用delete[])，会出现问题（但不一定会报错）\n还有些情况，我们想给智能指针传入一个文件指针，此时就不能用 delete 来进行资源释放了。为了避免这些情况，智能指针引入了  定制删除器\n8.1 unique_ptr 和 shared_ptr 的不同用法//non-specialized\ttemplate &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;//array specialization\ttemplate &lt;class T, class D&gt; class unique_ptr&lt;T[],D&gt;;\n\n比如库中 unique_ptr 的模板参数中，就有一个模板参数 D 用于接收用户传入的删除器。而 shared_ptr 则是采用在构造函数中传入删除器对象的方式来实现定制删除\n//with deleter (4)\ttemplate &lt;class U, class D&gt; shared_ptr (U* p, D del);template &lt;class D&gt; shared_ptr (nullptr_t p, D del);\n\n库中默认的删除器如下\n//non-specialized\ttemplate &lt;class T&gt; class default_delete;//array specialization\ttemplate &lt;class T&gt; class default_delete&lt;T[]&gt;;\n\n内部采用了重载操作符 () 的办法，来实现仿函数。默认情况下，使用的是delete，如果指定了是数组类型，则会使用delete[]\n\n如果我们要处理的是文件指针或者 malloc 的值，就只需要自己传入一个仿函数（定制删除器）即可\n8.2 使用  这里我定制了一个 free 的删除器，和文件指针 fclose 的删除器\ntemplate&lt;class T&gt;struct Free&#123;\tvoid operator()(T* ptr)\t&#123;\t\tcout &lt;&lt; &quot;[free]  &quot; &lt;&lt; ptr &lt;&lt; endl;\t\tfree(ptr);\t&#125;&#125;;struct Fclose&#123;\tvoid operator()(FILE* ptr)\t&#123;\t\tcout &lt;&lt; &quot;[fclose] &quot; &lt;&lt; ptr &lt;&lt; endl;\t\tfclose(ptr);\t&#125;&#125;;\n\n用如下代码进行测试\nunique_ptr&lt;int, default_delete&lt;int[]&gt;&gt; up1(new int[10]);unique_ptr&lt;ListNode&lt;int&gt;, default_delete&lt;ListNode&lt;int&gt;[]&gt;&gt; up2(new ListNode&lt;int&gt;[2]);unique_ptr&lt;FILE, Fclose&gt; up3((FILE*)fopen(&quot;test.cpp&quot;, &quot;r&quot;));unique_ptr&lt;ListNode&lt;int&gt;, Free&lt;ListNode&lt;int&gt;&gt;&gt; up4((ListNode&lt;int&gt;*)malloc(sizeof(ListNode&lt;int&gt;)));\n\n可以看到，成功进行了 ListNode 数组的销毁，以及 malloc、文件指针的 free、关闭操作\n[ListNode()] 011D5B7C[ListNode()] 011D5B88[free]  011E1070[fclose] 011D89A8[~ListNode()] 011D5B88[~ListNode()] 011D5B7C\n\n需要注意的是，malloc 创建的 ListNode&lt;int&gt; 空间并不会调用 ListNode 的构造函数，free 也不会调用析构函数\n\n因为 shared_ptr 需要采用类对象的方式在构造函数中进行传参。这方面的底层实现有些复杂。随之而来的好处就是我们可以直接传入一个 lambda 表达式来作为删除器，避免了代码冗长之后，找不到想要的删除器的定义的问题。\n// shared_ptr 需要采用传入对象的方式default_delete&lt;ListNode&lt;int&gt;[]&gt; d1;shared_ptr&lt;ListNode&lt;int&gt;&gt; sp1(new ListNode&lt;int&gt;[3], d1);cout &lt;&lt; &quot;###########################&quot; &lt;&lt; endl;shared_ptr&lt;ListNode&lt;int&gt;&gt; sp2(new ListNode&lt;int&gt;[3], [](ListNode&lt;int&gt;* ptr)&#123;delete[] ptr; &#125;);\n\n运行结果如下\n[ListNode()] 0127F1BC[ListNode()] 0127F1C8[ListNode()] 0127F1D4###########################[ListNode()] 01278D4C[ListNode()] 01278D58[ListNode()] 01278D64[~ListNode()] 01278D64[~ListNode()] 01278D58[~ListNode()] 01278D4C[~ListNode()] 0127F1D4[~ListNode()] 0127F1C8[~ListNode()] 0127F1BC\n\n9. 总结\n\n\n智能指针\n拷贝特点\n定制删除器\n\n\n\nauto_ptr(C++98)\n管理权转移。复制后，原有对象失效\n-\n\n\nunique_ptr(scpoed_ptr)\n禁止拷贝\n使用模板参数来传入定制删除器\n\n\nshared_ptr\n支持拷贝，采用引用计数，但是会有循环引用问题\n在构造函数中传入删除器对象\n\n\nweak_ptr\n支持拷贝，只用于托管指针，不参与指针空间的释放，不计入引用计数。用于解决循环引用问题\n-\n\n\nThe end智能指针的基本用法到这里就 over 了，了解智能指针的同时，需要熟知 RAII 思想。在不少类的设计中，都会用到这个思想。\n","categories":["遇见C++"],"tags":["C++","类和对象"]},{"title":"【C++】类型转换方法","url":"/posts/3134809219/","content":"本篇博客让我们来见识一下 C++ 中新增的类型转换方法\n\n\n[TOC]\n1.C 语言中类型转换  在 C 语言中，类型转换有下面两种形式\n\n隐式类型转换\n显示强制类型转换int a=(int)&#39;c&#39;\n\n这两种方式想必各位都很熟悉了，但隐式类型转换在一些场景里面会出现问题\nvoid insert(size_t pos,char c)&#123;\tint end=10;\twhile(end&gt;=pos)\t&#123;\t\tend--;\t&#125;\t//...&#125;\n\n上面的代码中，end 是 int 类型，当进行比较的时候，end 会 -1 直到小于 pos\n如果pos=0，问题就来了！\n隐式类型转换会让 end 在比较的时候被转换为 size_t 无符号整型，而在无符号整型中，-1是一个非常大的正数，从而导致这个函数进入死循环！\n\n\n隐式类型转换可能会丢失数据的精度\n显示类型转换的写法都一样，导致不能很好的区分情况\n\nC++ 委员会也是认识到了这里的问题，当产生隐式类型转换的时候，难以跟踪错误的来源，于是开发了下面的新的类型转换方式\n\n不过，因为 C++ 兼容 C 语言，所以 C 中的转换方式依旧支持\n\n\n2.C++ 中的强制类型转换C++ 中新增了下面四种明明的强制类型转换操作符\nstatic_cast、reinterpret_cast、const_cast、dynamic_cast\n\n2.1 static_cast这个关键字是用于相近类型之间的转换的，比如 double 和 int，char 和 int 之间\ndouble d = 11.4;int a1 = static_cast&lt;int&gt;(d);// 相近类型的转换char ch = &#x27;a&#x27;;int a2 = static_cast&lt;int&gt;(ch);cout &lt;&lt; a1 &lt;&lt; endl;cout &lt;&lt; a2 &lt;&lt; endl;\n\n\n除了以上的类型转换，其还支持将内置类型转自定义类型\nstruct mytest&#123;public:    // explicit mytest(int a = -1)    mytest(int a = -1)    &#123;        _a = a;        cout &lt;&lt; &quot;mytest() &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    mytest(const mytest &amp;st)    &#123;        _a = st._a;        cout &lt;&lt; &quot;mytest(copy) &quot; &lt;&lt; st._a &lt;&lt; endl;    &#125;    mytest &amp;operator=(const mytest &amp;st)    &#123;        _a = st._a;        cout &lt;&lt; &quot;mytest operator= &quot; &lt;&lt; st._a &lt;&lt; endl;        return *this;    &#125;private:    int _a;&#125;;\n\n使用如下代码进行测试，当 mytest 的构造函数没有加 explicit 关键字的时候，下方的两种构造方式都可以成功调用（隐式类型转换）\nint main()&#123;    mytest t1 = static_cast&lt;mytest&gt;(3);    mytest t2 = 5;    return 0;&#125;\n\n$ ./testmytest() 3mytest() 5\n\n加了 explicit 之后，t2 就没有办法成功构造了，因为隐式类型转换被禁用了\n$ g++ test.cpp -o testtest.cpp: In function ‘int main()’:test.cpp:120:17: error: conversion from ‘int’ to non-scalar type ‘mytest’ requested     mytest t2 = 5;                 ^\n\n但 static_cast 在加了 explicit 之后，依旧可以帮我们调用构造函数来创建对象；\n$ ./testmytest() 3\n\n2.2 reinterpret_cast这个关键字用于不相近类型之间的转换，比如指针转成 int\nint* p = &amp;a1;//int x = static_cast&lt;int&gt;(p);// 报错：类型转换无效int x = reinterpret_cast&lt;int&gt;(p);// 非相近类型中的转换cout &lt;&lt; x &lt;&lt; endl;\n\n打印的结果如下（每次运行都不一样）\n2029408\n\n2.3 const_cast如同其名，这个关键字的作用是取消一个变量的 const 属性\nconst int c1 = 3;// 这里定义的变量是在栈上的，可以间接修改int* ptr1 = const_cast&lt;int*&gt;(&amp;c1);// 取消 const 权限*ptr1 = 4;cout &lt;&lt; c1 &lt;&lt; endl;// 修改了地址之后没有变化cout &lt;&lt; *ptr1 &lt;&lt; endl;\n\n\n欸，为什么我们取地址之后，修改为 4 了，变量 c1 本身不会变化呢？\n这是因为编译器做了一些优化，把 c1 放到了某个地方，取的时候并没有直接去内存里面取\nvolatile 关键字  这里我们可以使用 volatile 关键字修饰变量，要求每一次都必须要去内存中取\n//volatile 关键字，每次访问 c 都去内存中取，屏蔽编译器优化volatile const int c2 = 3;int* ptr2 = const_cast&lt;int*&gt;(&amp;c2);// 取消 const 权限*ptr2 = 4;cout &lt;&lt; &quot;volatitle:  &quot;;cout &lt;&lt; c2 &lt;&lt; endl;cout &lt;&lt; *ptr2 &lt;&lt; endl;\n\n\n2.4 dynamic_cast该关键字是用于  继承  中，将一个父类的  指针 / 引用  转换为子类对象的  指针 / 引用\n之前学习继承的时候，我们了解过\n\n向上转型：父类的指针、引用可以直接指向子类对象的指针 &#x2F; 引用（这是一个赋值兼容的规则，不需要进行转换）\n向下转型：反过来之后，可以直接赋值吗？不够安全\n\ndynamic_cast的作用就是判断一个父类指针指向的是不是他的子类\n\n如果是，能够成功转换\n不能则返回 0\n\n这个关键字最大的作用，便是可以帮我们判断这个父类指针 &#x2F; 引用指向的是否为一个子类对象\nclass A&#123;public:\tvirtual void f() &#123;&#125;&#125;;class B : public A&#123;&#125;;void fun(A* pa)&#123;\t// dynamic_cast 会先检查是否能转换成功，能成功则转换，不能则返回 0\tB* pb1 = static_cast&lt;B*&gt;(pa);\tB* pb2 = dynamic_cast&lt;B*&gt;(pa);\tcout &lt;&lt; &quot;pb1:&quot; &lt;&lt; pb1 &lt;&lt; endl;\tif (pb2)\t&#123;\t\tcout &lt;&lt; &quot; 转换成功！pb2:&quot; &lt;&lt; pb2 &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot; 转换失败！pb2:&quot; &lt;&lt; pb2 &lt;&lt; endl;\t&#125;\t&#125;void test2()&#123;\tA a;\tB b;\tfun(&amp;a);\tfun(&amp;b);&#125;\n\n\n这里有个要求，那便是父类中必须要有虚函数（多态），否则无法成功转换\n\n3.C++ 强制类型转换的作用C++ 希望我们规范强制类型转换的情景，针对性的调用不同的关键字\n但是由于它没有强制，在实际情况中用的反而不多\n不过需要注意的是，强制类型转换会关闭 &#x2F; 挂起正常的类型检查，在强制类型转换之前，我们要仔细检查是否还有别的方法来达到目的。最好是避免使用强制类型转换!\n4.RTTI之前学习  智能指针  的时候，我们学过一种思路叫RAII\n这里的 RTTI 全称为Run-time Type identification，即运行时类型识别\nC++ 通过下面几种方式来支持 RTTI：\n\ntypeid\ndecltype\ndyanmic_cast\n\n这个概念只需要了解即可！\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】C++11 的那些新特性","url":"/posts/2016080368/","content":"本篇博客，让我们一起来看看 C++11 的那些新特性！\n\n\n\n所使用的编译器：VS2019\n本篇博客所有的测试源码都可以在我的 GITEE 仓库 找到 \n\n[TOC]\n1. 前言 C++11 是 C++ 的标准委员会在2011 年更新的 C++ 新特性。说白了就是一个升级包。和 JAVA\\PYTHON 这种更新比较频繁的语言相比，C++ 更新的就没有那么顺风顺水了，而且每一次更新虽然修复了一些问题，但也带来了更多的“没太大必要”的更新\n\n比如没啥用的 array 容器，和 int arr[10] 这种内置方式的区别主要在于越界检查\n\n不过咱们这种小菜鸡，只有学习的权力，哪有啥资格评定 C++ 标准呢？我听大佬说，现在最关注的 C++ 更新便是  网络库  的上线了，不过那个貌似得等到 C++23 去了\n话不多说，让我们来康康一些 C++11 的新功能吧！\n\n2. 列表 &#123;&#125; 初始化C++11 更新了初始化方式，不管是什么类型的数据，我们都可以用花括号的方式进行初始化\nstruct TestA&#123;\tint _a;\tint _b;&#125;;void TestInit()&#123;\tint arr1[] = &#123; 1,2,3,4,5 &#125;;\tTestA t1 = &#123; 1,2 &#125;;&#125;\n\n之前我们已经习惯于用这张方式来初始化数组或者结构体，这在 C++98 中已经支持\n而 C++11 则在这种玩法之上，又增添了一部分新操作，那就是直接用花括号初始化，你甚至可以把 = 给省略了\nint arr2[]&#123; 1,2,3,4,5 &#125;;int arr3[5]&#123; 0 &#125;;TestA t2&#123; 1,2 &#125;;\n\n不过上面这种写法没有什么意义，还增加了代码理解的难度，不如直接用原本的写法。\n更多时候，我们是在 new 初始化多个数据的时候使用这种方式。\n2.1 new 初始化多个数据  在动态内存管理  那一章节，我们学习了 new 的两种使用方式，也提到了 ()/[] 这两个括号的区别\nint *p1 = new int(3);// 开辟一个 int 的空间，并初始化为 3 赋值给 p1int *p2 = new int[3];// 开辟 3 个 int 的空间，不进行初始化\n\n在 C++11 中，我们可以直接用花括号，对 new 开拼出来的数组进行批量初始化。打印的时候，可以看到 p2 中的数据都是没有进行初始化（vs 也报了警告）而 p3 中的数据都完成了初始化\n\n对于结构体数据而言，我们可以用花括号直接调用其构造函数\n\n其中 t5 是发生了隐式类型转换 + 调用构造函数进行的初始化\nTestA t5 = &#123; 1, 3 &#125;;// 对类来说，会进行隐式类型转换 + 调用构造函数\n\n通过调试 + 打断点可以看到其调用了构造函数进行初始化\n\n同样的，调用 new 的时候，我们可以用多个花括号的方式进行批量初始化。这在 new 一个对象数组的时候非常方便\n\n2.2 initializer_list2.2.1 STL 容器初始化  不光是我们自己写的类、内置类型可以使用这种方式进行初始化，stl库里面的容器也可以使用相同方式进行初始化\nvector&lt;int&gt; v1 = &#123; 1,2,3,4 &#125;;vector&lt;int&gt; v2&#123; 1,2,3,4 &#125;;// 不建议这么写\n\n\n同样的，我们还可以用类似的方式初始化 vector 内部的对象\n\n作为容器的一份子，map也有一个利用 il 进行初始化的构造函数\n\n使用方式和之前提到的没啥区别，这里就不多讲啦\nmap&lt;int, int&gt; m1 = &#123; &#123;10, 20&#125;,&#123; 30,40&#125;,&#123;50,60&#125; &#125;;for (auto e : m1) &#123;\tcout &lt;&lt; e.first &lt;&lt; &quot;-&quot; &lt;&lt; e.second &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;\n\n\n你可能会好奇，这种初始化的底层是怎么实现的？那么就要提到 c++11 新增的一个容器了\n2.2.2  initializer_list 容器  如果你把 vector 等容器的版本设定为 C++11，看文档的时候便会发现 C++11 新增了一个用initializer_list 进行初始化的操作\n\n\n再来看看initializer_list，这不就是我们刚刚用的花括号嘛？\n\n这个容器的成员函数很少，只有两个迭代器以及size()\n\n它最重要的特性，便是当我们使用 auto 自动推到参数类型的时候，&#123;1,2,3,4&#125;这种类型会被推到成initializer_list\nauto il = &#123; 10, 20, 30 &#125;;cout &lt;&lt; typeid(il).name() &lt;&lt; endl;//initializer_list \n\n因为他有迭代器，所以我们也可以使用范围 for 进行打印操作\n\n个人理解，当其他容器使用 initializer_list 进行初始化的时候，本质上调用的接口和利用迭代器进行初始化是一样的\n2.3.1 插入 il部分容器的 insert 函数也添加了使用 il 进行插入连续数据的操作\n\nset&lt;int&gt; s2 = &#123; 1,2,3,4 &#125;;s2.insert(&#123; 5,6,7,8 &#125;);\n\n\n在 vector 中使用 il 插入的时候，需要指定 pos 位置这个和 vector 的其他几个插入函数是一样的\n\n2.4 模拟实现 il 构造函数  那么，如何让我们自己模拟实现的 vector 也能支持这个功能呢？【模拟实现 vector 源码】\n和 STL 库里面的代码一样，添加上 initializer_list 的构造函数即可\n因为 il 容器已经有了它自己的迭代器，我们完全可以复用迭代器构造的操作，直接进行遍历然后 push_back 即可！\n//initializer_list 构造vector(const initializer_list&lt;T&gt;&amp; il)    :_start(nullptr),    _finish(nullptr),    _endofstorage(nullptr)&#123;    for (auto e : il) &#123;        push_back(e);    &#125;&#125;\n\n\n试试自定义类型，也可以很好的支持！\n\n这里还有一个优化的地方，那便是开始构造的时候，直接给 vector 开对应 il size() 的空间大小，避免后续 push_back 的时候需要多次扩容\n//initializer_list 构造vector(const initializer_list&lt;T&gt;&amp; il)    :_start(nullptr),_finish(nullptr),_endofstorage(nullptr)&#123;    reserve(il.size());// 扩容    for (auto e : il) &#123;        push_back(e);    &#125;&#125;\n\n通过  调试  能发现达成了我们的需求（因为调试步骤太多，截图不方便，这里就不演示了。感兴趣的老哥可以去我的 gitee 仓库下源码自己试试）\n3. 变量声明 C++11 提供了多种简化的 声明 / 定义  方式，比如我们熟悉的 auto\n3.1 auto\nC++98中 auto 是一个存储类型的说明符，表明变量是局部自动存储类型，但是局部域中定义局 部的变量默认就是自动存储类型，所以 auto 就没什么价值了。\n\nC++11 给 auto 上了实现自动类型推断的全新功能，方便我们在定义一个变量的时候直接用 auto 进行类型推导\nauto num = 1;//intauto p = &amp;num;//int*\n\n需要注意的是，如果想用 auto 推到，则必须初始化。只给一个 auto i 是不行的！\nauto还可以用于范围 for 等其他操作，这些都在之前讲解这个  关键字的博客中  有提到，这里就不多说了！\n\n3.2 decltype关键字 decltype 可以把变量声明成我们想要的目标类型；可以理解为和 typedef 的作用有一定的类似，但是它是可以自动推导的！\nint a = 10, b = 20;int sum = a * b;cout &lt;&lt; &quot;type(sum) &quot; &lt;&lt; typeid(sum).name() &lt;&lt; endl;decltype(a * b) num; // 把 a*b 的类型声明为 numdecltype(&amp;sum) ptr;  // 把 &amp;sum 的类型声明为 ptrcout &lt;&lt; &quot;type(a*b)  &quot; &lt;&lt; typeid(num).name() &lt;&lt; endl;cout &lt;&lt; &quot;type(&amp;sum) &quot; &lt;&lt; typeid(ptr).name() &lt;&lt; endl;\n\n\n怎么样，是不是觉得很神奇？很方便？\n需要注意的是，使用 decltype 关键字来指定函数指针的时候，函数名和函数参数之间需要加上&amp;，否则无法正确推导类型\ndecltype(add) &amp;(int, int) // 正确decltype(add) (int, int) // 错误    \n\n\n那让我们来看看另外一个语言声明变量的方式吧！😂 压根不需要变量类型捏（因为 python 是弱类型的语言）\n# Pythona=10sum = a*20print(type(a))print(type(sum))\n\n\n要是 C++ 也有这么方便就好了😭\n3.3 typeid这个关键字上面已经用过好几次了，就是用来打印变量的类型的\nint a = 10;cout &lt;&lt; &quot;type(a) &quot; &lt;&lt; typeid(a).name() &lt;&lt; endl;\n\n\n4. 左 &#x2F; 右值引用  在之前我们学习了引用的基本操作，但那个是  左值引用。当时我们尚未引入左指引用和右值引用的区别。本篇博客里面将会详细讲解~\n4.1 左值 &#x2F; 右值区别  要解答这两种引用的区别，首先我们需要直到  左值 / 右值  分别代指什么\n左值：\n\n可以存在于 = 左边或右边\n可以取地址\n可以对它赋值（const 除外）\n\n右值：\n\n右值是一个表示数据的表达式，比如：函数返回值[不能是左值引用返回的]、表达式返回值A+B、字面常量10\n右指只能出现在 = 的右边，不能出现在左边（俺可没见过 A+B=C 的代码语法）\n右指不能取地址\n\n左值和右值最大的区别便是：左值可以取地址，右值不能取地址\n4.1.1 将亡值（概念）右值  还分为两种情况：\n// 纯右值10;a+b;Add(a,b);// 将亡值string s1(&quot;1111&quot;);//&quot;1111&quot; 是将亡值string s2 = to_string(1234);//to_string 的 return 对象是一个将亡值string s3 = s1+&quot;hello&quot; // 相加重载的 return 对象是一个将亡值move(s1);// 被 move 之后的 s1 也是将亡值\n\n在右值引用的介绍中将用上  将亡值  的概念\n4.2 左值引用  左值引用就是对左值的引用。我们之前学习的就是这一类型\n// a、b、c、*a 都是左值// 对象内部的 *this 也是左值int* a = new int(0);int b = 1;const int c = 2;// 以下是对上面左值的 左值引用int*&amp; rp = a;int&amp; rb = b;const int&amp; rc = c;int&amp; p = *a;// 引用相当于别名，修改引用后的内容相等于修改原本的参数\n\n之前也提到了，其作用主要是在针对出了  作用域不会销毁  的变量进行  引用返回，以节省拷贝的代价。亦或者是引用传参，减少形参拷贝代价\n\n4.3 右值引用  来看看几个比较常见的右值吧，其中 Add 是一个简单的相加函数\ndouble x = 1.1, y = 2.2;// 常见的右值10;x + y;Add(x, y);// 以下都是对右值的右值引用int&amp;&amp; rr1 = 10;double&amp;&amp; rr2 = x + y;double&amp;&amp; rr3 = Add(x, y);// 右值不能出现在 = 的左边//10 = 1;//x + y = 1;//fmin(x, y) = 1;\n\n虽然我们不能直接对右值进行  取地址 / 赋值  操作，但是在右值引用过后，便可以对引用值进行  取地址 / 赋值  操作\n\n这是因为右值引用的时候，会把当前引用的数据放入一个位置存起来。\n存放位置：普通变量在  栈，全局变量 &#x2F; 静态变量在  静态区（没有验证过，可能不对）\n\nint&amp;&amp; rr1 = 10;cout &lt;&lt; rr1  &lt;&lt; endl;rr1 = 3;cout &lt;&lt; rr1 &lt;&lt; endl;int* p = &amp;rr1;*p = 2;cout &lt;&lt; rr1 &lt;&lt; endl;\n\n\n如果你不喜欢右值引用被修改，则可以使用 const 进行修饰\n\n4.4 两个引用的区别  用一个表格来总结二者的区别\n\n\n\n左值引用\n右值引用\n\n\n\n只能引用左值\n只能引用右指\n\n\nconst 可以引用左值 &#x2F; 右值\n可以引用 move 后的左值\n\n\n4.4.1 movemove 可以把左值换成右值，但  不能  把右值转左值\n\n谨慎使用 move，如果当前对象在后续还需要使用，则不能move 将其改为右值，否则可能资源被掠夺导致该对象失效！\n\n\n4.5 右值引用使用场景  右值引用可以提高  移动构造 / 移动赋值  等深拷贝场景的效率\n什么场景可以使用左值引用提高效率?\n\n操作符重载：前置 ++\n操作符重载：+=\n出了作用域后不会销毁的变量，如输出型参数（即传入函数进行处理的参数）\n\n而有一些场景是左值引用无法处理的：\n\n操作符重载：后置 ++（需要返回一个全新变量）\n操作符重载：+（需要返回一个全新变量）\n模拟实现 string 中的 to_string 函数\n\n这些场景大多有一个特性，那就是会生成一个全新的变量（对象）其对象生命周期出了函数作用域便会销毁（将亡值）\n如果使用左值引用返回，就会出现  访问已经销毁了的对象  的错误。\n\n假设我们有一个 vector&lt;vector&lt;int&gt;&gt;，若内部的vector 很大的时候，拷贝构造的代价是很大的！\n\n4.5.1 输出型参数  如果在 C++98 的情况下，我们只能用  输出型参数  来解决这个问题\nvector&lt;vector&lt;int&gt;&gt;&amp; test(vector&lt;vector&lt;int&gt;&gt;&amp;v1,int val)&#123;    //……    //v1 就是一个输出型参数。放入该函数进行操作后原路返回    return v1;&#125;\n\n4.5.2 右值引用 移动构造  在C++11中，我们可以使用右值引用的拷贝构造来解决这个问题\n下方就是一个具体示例\nmuxue::string to_string(int val)&#123;    bool flag = true;    if (val &lt; 0)&#123;        flag = false;        val = 0 - val;    &#125;    muxue::string str;    while (val &gt; 0)&#123;        int x = val % 10;        val /= 10;        str += (&#x27;0&#x27; + x);    &#125;    if (flag == false)&#123;       str += &#x27;-&#x27;;    &#125;    std::reverse(str.begin(), str.end());    return str;&#125;\n\n在默认情况下，如果想使用这个 to_string 函数，就需要进行  深拷贝  进行传值返回。这是无可避免的代价\n如果使用左值引用返回，这里就会有 bug。因为出了函数作用域后，临时对象 str 会被销毁。而如果我们使用左值引用取别名，在进行赋值的时候，便会出现利用 str 的别名进行拷贝构造，而 str 是一个  已经销毁的对象  的问题\n\n而如果我们使用右值引用返回，则不会出现这种问题。前提是我们自己实现了右值引用的构造函数和赋值重载\n\n一般我们把右值引用的构造函数 &#x2F; 赋值重载称作  移动构造 / 移动赋值\n\n为什么叫移动呢？因为右值引用是会直接拿取  对象的资源\nSTL_string我们可以先用库里面的 string 观察一下，当我们使用 move 之后的右值进行构造的时候，会直接拿掉对象的资源！\nstring s1 = &quot;1234134&quot;;string s2(s1);string s3(move(s1));\n\n\n\n而在使用右值进行返回的时候，编译器会进行一波优化，直接使用  移动构造  拿取资源，避免多次  拷贝构造  造成的空间和时间损失\n在处理这种问题的时候，就比输出型参数好太多了。\n\nMY_string不过库里面的 string 涉及到了 buf 之类的高级操作，也不适合我们调试查看调用的具体情况。所以这里我们再使用自己写的 string 来演示一下\n\n这里我还发现了之前模拟实现 string 的一个 bug，在 push_back 操作的时候，没有给末尾加上\\0，导致析构的时候报错了\n\n模拟实现 string 代码见我的 gitee 仓库【传送门】\n\n\n在演示之前，我们先要实现自己的  移动构造 / 移动赋值\n// 移动赋值string&amp; operator=(string&amp;&amp; s)&#123;    swap(s);    return *this;&#125;// 移动拷贝string(string&amp;&amp; s)    :_a(nullptr),    _size(0),    _capa(0)&#123;    swap(s);&#125;\n\n这里我直接复用了之前已经写好的一个 swap 函数，实现了一个“现代写法”的构造，直接  交换  了二者的资源。避免  深拷贝  带来的副作用\n\n接下来用下面的几个来测试一下拷贝构造的操作\nmuxue::string s1 = &quot;1234&quot;;muxue::string s2(s1);// 拷贝构造muxue::string s3 = muxue::to_string(5678);// 移动构造muxue::string s4 = s1 + s3;// 拷贝构造 + 移动构造\n\n通过在构造函数中添加打印，可以看出这几个分别调用了什么构造函数\n\n\ns2 调用了深拷贝构造，因为 s1 是一个左值\ns3 调用了移动构造，因为 to_string 函数中 return 的是一个将亡值\ns4 先是在  运算符 + 重载  中调用深拷贝构建了一个 string 的临时对象，在使用移动构造进行return\n\n运算符 + 重载 的代码如下，和 to_string 一样，都是 return 了一个将亡值\n// 相加重载string operator+(const string&amp; s)&#123;    muxue::string tmp(*this);    tmp += s;    return tmp;&#125;\n\n将一个对象 move 成为右值之后，便可以使用  移动赋值\n\n移动构造直接移动资源  这时候如果调用拷贝构造，就很是浪费：\n\n本来 tmp 的资源就要销毁了，你还得先把他的资源  复制  一份给自己，再销毁 tmp\n那为何不把 tmp 的资源直接拿给自己呢？省去了复制的消耗！\n\n这便是移动构造的优势之处！\n调试体现出来的，便是深拷贝中两个对象 _a 的地址完全不同\n\n而移动构造是直接把 s1 的 _a 资源拿了过来！\n\n其最明显的特征，便是 s3 的 _a 地址就是 s1 的！\n\n\nSTL 的更新  如果我们把自己模拟实现的移动构造删除，那么所有的 return 都会去调用深拷贝，代价就很大了。对象很大的时候，来一次深拷贝有可能可以把整个系统干废😂\n\n所有 STL 的容器，在 C++11 之后，都支持了右值引用的插入、移动构造和移动赋值\n\nC++11的 swap 也提供了一个直接使用右值进行资源替换的版本，效率更高\n\n4.6 编译器优化  在之前有关构造函数的博客里面有提到过，当我们 return 一个对象的时候，编译器会把两次拷贝构造优化成一次\n\n和拷贝构造一样，执行移动构造的时候，编译器也有一定的优化\n\n不过这个优化就取决于编译器的处理了。不排除有些编译器没有做此等处理哦！\n4.7 优化插入效率  有了右值引用，只要我们实现一个右值引用方式的插入，也可以优化插入时的效率\nmuxue::list&lt;muxue::string&gt; t;muxue::string s1(&quot;111&quot;);// 调用拷贝构造，左值t.push_back(s1);// 调用移动构造，右值t.push_back(&quot;222&quot;);t.push_back(std::move(s1));\n\n5. 完美转发(万能引用)c++11 提供了一个万能引用，既可以引用左值，也可以引用右值\nvoid Fun(int&amp; x) &#123;     cout &lt;&lt; &quot; 左值引用 &quot; &lt;&lt; endl; &#125;void Fun(const int&amp; x) &#123;     cout &lt;&lt; &quot;const 左值引用 &quot; &lt;&lt; endl; &#125;void Fun(int&amp;&amp; x) &#123;     cout &lt;&lt; &quot; 右值引用 &quot; &lt;&lt; endl; &#125;void Fun(const int&amp;&amp; x) &#123;     cout &lt;&lt; &quot;const 右值引用 &quot; &lt;&lt; endl; &#125;template&lt;typename T&gt;void test(T&amp;&amp; t)&#123;//T&amp;&amp; 就是一个万能引用\tFun(t);&#125;\n\n通过测试我们会发现，不管是传入一个左值还是传入一个右值，其都会调用左值引用\n\n这是因为右值引用之后，形参 t 就是一个左值，所以调用了左值的函数\n\n我们也不能粗暴的使用 move 来解决这里的问题，因为有时候一些左值对象在后续还是需要使用的，move之后变成右值，资源被拿走了咋办！\n&gt;template&lt;typename T&gt;&gt;void PerfectForward(T&amp;&amp; t)&gt;&#123;   Fun(std::move(t));&gt;&#125;\n\n\n\n而  完美转发  的存在就是为了将右值保持其右值属性，依旧调用右值对应的函数，其语法如下，使用 forward 函数进行完美转发\ntemplate&lt;typename T&gt;void PerfectForward(T&amp;&amp; t)&#123;    Fun(std::forward&lt;T&gt;(t));&#125;\n\n这时候第二种情况就正确掉用了对应的右值引用函数，也没有改变左值的属性\n\n再把函数改成我们自己写的 string，也能看出完美转发的作用\ntemplate&lt;typename T&gt;void PerfectForward(T&amp;&amp; t)&#123;\tmuxue::string s = std::forward&lt;T&gt;(t);&#125;\n\n\n\n5.1 使用场景  有些场景下，我们需要对一个函数传入不同类型的参数，这时候就需要用  万能引用 + 完美转发  来进行不同的处理\n比较典型的便是很多 STL 容器都提供了一个新的尾插函数emplace_back\n\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n这里便使用了  万能引用，以及可变模板参数（后面会写道）\n利用我们自己写的 string 进行打印，即可看出二者的区别\n\n\nemplace_back直接调用了构造函数\npush_back 构造 + 移动构造\n\n因为移动构造的效率是很高的，所以这两种方式的差距并不算很大。不过差距肯定是有的，如果为了兼容性，使用 push_back 肯定更好，因为 emplace 是C++11新增的操作\n\n5.2 将可变模板参数转为 C 语言的可变参数列表\nhttps://segmentfault.com/q/1010000043736187\n\n在我尝试实现一个简单的日志类的时候，遇到了这个问题。最终成功解决\n我想通过 debug,info,warning 这些函数来打印对应等级的日志，它们最终调用的都是 _logging 函数，并在 _logging 函数中  统一  进行vsnprintf，我要怎么才能把可变参数列表传过去？还是说不支持这样的操作？\npublic:void debug(const char *def_name, const char *format, ...)void info(const char *def_name, const char *format, ...)private:void _logging(int level, const char *def_name,  const char *format, ...)\n\n\n如果不这么做，就得把使用 vsnprintf 的几行代码重复写到每一个独立函数中，有点代码重复\nva_list ap;va_start(ap, format);vsnprintf((char *)_log_info.c_str(), _log_size - 1, format, ap);va_end(ap);\n\n目前百度到如下办法，无作用\nvoid warning(const char *def_name, const char *format, ...)&#123;    // 获取可变参数列表    va_list ap;    va_start(ap, format);    _logging(LOG_WARINING, def_name, format,ap);    va_end(ap);&#125;\n直接调用 logging 函数的能正常打印，调用 warning 函数无法正常打印。如下，第一行是直接调用 warning 的，没有打印出消息内容\n[23-04-27 19:59:35] WARN | 1682596775 | test | [23-04-27 19:59:35] WARN | 1682596775 | test | 这是一个测试而已\n\n\n大佬回答中，提到了可以用可变模板参数 + 完美转发，直接将可变参数列表传过去就行了\n// c++ 中我们一般使用 variadic templates，除非你要和 c 库兼容template &lt;typename... Args&gt;void warning(const char *def_name, const char *format, Args &amp;&amp;...args) &#123;    _logging(LOG_WARINING, def_name, format, std::forward&lt;Args&gt;(args)...);&#125;\n\n感谢大佬的回答，在这里贴上完整可用的代码【也可以去我的 github 看】\npublic:    template &lt;typename... Args&gt;    void error(const char *def_name, const char *format, Args &amp;&amp;...args) &#123;        _logging(LOG_ERROR, def_name, format, std::forward&lt;Args&gt;(args)...);    &#125;\t// 其他的都是对这项的 copy，只修改传入的 log levelprivate:\tvoid _logging(size_t level, const char *def_name, const char *format, ...)    &#123;        assert(level &gt;= LOG_DEBUG &amp;&amp; level &lt;= LOG_FATAL);        if (level &lt; _level)        &#123; // 低于定义的等级，不打印            return;        &#125;        va_list ap;        va_start(ap, format);        vsnprintf((char *)_log_info.c_str(), _log_size - 1, format, ap);        va_end(ap);        // 根据日志等级选择打印到 stderr/stdout        // 超过了 error 的日志，要使用 stderr 打印        FILE *out = (level &gt;= LOG_ERROR) ? stderr : stdout;        def_name = def_name == nullptr ? &quot;unknow&quot; : def_name; // 判断 defname 是否为空        // 格式化打印到文件流中        fprintf(out, &quot;%s | %s | %s\\n&quot;,                    log_level[level],                    def_name,                    _log_info.c_str());    &#125;\n\n测试\nvoid LogTest()&#123;    vod::Logger _log;    _log.info(&quot;test&quot;,&quot;%s&quot;,&quot;this in info&quot;);    _log.warning(&quot;test&quot;,&quot;%s %d&quot;,&quot;this is warning&quot;,333);    _log.error(&quot;test&quot;,&quot;%s&quot;,&quot;this is err&quot;);    _log.fatal(&quot;test&quot;,&quot;%s&quot;,&quot;this is fatal!!!&quot;);&#125;\n\nINFO | test | this in infoWARINING | test | this is warning 333ERROR | test | this is errFATAL | test | this is fatal!!!\n\n6. 新增的默认成员函数  在初识类和对象的时候，我便在博客中提到了 C++ 的几个默认成员函数\n\n构造函数 \n析构函数 \n拷贝构造函数 \n拷贝赋值重载 \n取地址重载 \nconst 取地址重载\n\n在 C++11 中也多了两个成员函数，那便是前文所讲述的  移动构造 / 移动赋值\n但是想让编译器默认生成移动构造可没那么容易：只有你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个，编译器才会帮你整一个移动构造出来\n\n编译器默认生成的移动构造：对于内置类型会执行逐成员按字节拷贝；对自定义类型成员，则需要看这个成员是否实现移动构造， 如果实现了就调用移动构造，没有实现就调用拷贝构造。\n\n同样的，移动赋值也需要满足上面的条件，编译器才会帮你生成。\nclass TestB&#123;private:\tmuxue::string _s;\tint _a;public:\tTestB(const muxue::string&amp; s=&quot;&quot;, int a=0)\t\t:_s(s),\t\t_a(a)\t&#123;&#125;&#125;;void DefaultMoveCopy()&#123;\tTestB t1;\tcout &lt;&lt; endl;\tTestB t2 = t1;\tcout &lt;&lt; endl;\tTestB t3 = std::move(t1);\tcout &lt;&lt; endl;\tTestB t4;\tt4 = std::move(t2);\tcout &lt;&lt; endl;&#125;\n\n通过测试可以看出来，编译器默认生成了移动拷贝和移动赋值重载。并调用了自定义类型的  移动拷贝 / 移动赋值\n\n6.1 关键字 default\n这个关键字的作用之前好像记录过? 不记得了\n\ndefault关键字的作用是让编译器强制生成一个指定的成员函数\n还是上面的 TestB 类的代码，如果我们自己写一个拷贝构造，编译器就不再会生成默认的  移动构造 / 移动赋值，而是会去调用 string 里面的拷贝构造、拷贝赋值\n\n这时候我们太懒了，不想自己写  移动  版本了，于是就用 default 强制让编译器干活\n\n现在就正确调用了对应的移动构造和移动赋值了！\n\n7. 可变模板参数  在5.1提到的 emplace_back 函数中，便出现了下面这种语法\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n这就是一个可变的模板参数，允许一个函数有多个参数，且不要求是相同类型\n使用 sizeof 即可查看参数的个数\n\n7.1 递归解参数包  而如果你想查看参数的类型并使用它，则需要进行递归取出参数来\ntemplate &lt;class T&gt;void ShowArgs(const T&amp; val)&#123;\tcout &lt;&lt; val &lt;&lt; &quot;   type: &quot; &lt;&lt; typeid(val).name() &lt;&lt; endl;&#125;template &lt;class T,class... Args&gt;void ShowArgs(const T&amp;val,Args&amp;&amp;... args)&#123;\t//cout &lt;&lt; &quot; 参数个数 &quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;\tcout &lt;&lt; val &lt;&lt; &quot;   type: &quot; &lt;&lt; typeid(val).name() &lt;&lt; endl;\tShowArgs(args...);&#125;void TestArgs()&#123;\tShowArgs(1, &#x27;x&#x27;, 2.3, muxue::string(&quot;123&quot;));&#125;\n\n\n其中 void ShowArgs(const T&amp; val) 函数的作用，是当参数包中只有一个参数的时候，调用对应的单参函数，而不会报错\n另外一种办法便是提供一个无参的同名函数，用作参数包递归的结尾\n\n错误解法  可能有人想使用这样的方法来解包，当参数包里的函数只有一个的时候，结束递归\n\n但是这样是不行的！\n\n递归推参数包是一个  编译时逻辑\n通过 sizeof 判断是一个  运行时逻辑\n\n在  编译  这个函数的时候，已经开始找对应的函数进行调用了。当参数包里面的参数只有 1 个或者 0 个的时候，编译器  编译的时候  发现找不到对应函数，就直接报错了。\n7.2 数组解包  除了上面的递归解包，这里还可以使用  数组  的方式直接来解包\ntemplate &lt;class... Args&gt;void ShowArgs(Args&amp;&amp;... args)&#123;\tcout &lt;&lt; &quot; 参数个数 &quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;\tint arr[] = &#123; args... &#125;;&#125;void TestArgs()&#123;\tShowArgs(1, 2, 3, 4);&#125;\n\n可以看到 arr 数组里面解包出了传入的参数\n\n但是这种方法不通用，只适用于所有参数都是  相同类型  的情况，如果是不同类型则会报错\n\n通用办法是使用一个  逗号表达式，来获取一共有多少个参数以及解包\ntemplate &lt;class T&gt;void PrintArgs(const T&amp; val)&#123;\tcout &lt;&lt; val &lt;&lt; &quot;   type: &quot; &lt;&lt; typeid(val).name() &lt;&lt; endl;&#125;template &lt;class... Args&gt;void ShowArgs(Args&amp;&amp;... args)&#123;\tcout &lt;&lt; &quot; 参数个数 &quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;\t//int arr[] = &#123; args... &#125;;\tint arr[] = &#123; (PrintArgs(args),0)... &#125;;&#125;\n\n一共有多少个参数，那么数组里面就会有多少个 0\n\n7.3 emplace_backstd 容器的库函数中 emplace_back 的参数包还使用了万能引用，这就让它的使用更加灵活\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n可以直接传入两个参数，他会自动解包参数，创建一个键值对\nstd::list&lt;std::pair&lt;int, muxue::string&gt;&gt; t;t.emplace_back(10, &quot;sort&quot;);\n\n而 push_back 则不支持这么干\n\n\n8.lambda 表达式  在之前，我们使用 sort 的时候，如果是内置类型，默认会返回一个升序序列。如果我们需要返回降序，则需要改变比较规则，传入一个仿函数来使用自定义的比较对比\n#include &lt;algorithm&gt;//sort#include &lt;functional&gt;//greaterint main()&#123;\tint arr[]=&#123;1,3,2,5,4&#125;;    int sz=sizeof(arr)/sizeof(arr[0]);    // 默认升序\tstd::sort(arr,arr+sz);    // 降序传入仿函数 greater    std::sort(arr,arr+sz,greater&lt;int&gt;());&#125;\n\n因为 int 是内置类型，库中自带的 greater/less 仿函数即可满足我们的需求。而如果我们排序的是自定义类型，则需要自己实现一个对应的仿函数\n// 价格降序struct CompPriceGreater&#123;\tbool operator()(const Goods&amp; g1, const Goods&amp; g2)\t&#123;\t\treturn g1._price &gt; g2._price;\t&#125;&#125;;// 价格升序struct CompPriceLess &#123;\tbool operator()(const Goods&amp; g1, const Goods&amp; g2)\t&#123;\t\treturn g1._price &lt; g2._price;\t&#125;&#125;;\n\n\n8.1 情景描述  但是如果需要处理的对象有很多不同的成员变量的时候（比如京东淘宝上商品不同的筛选方式）我们就需要实现非常非常多的仿函数\n这样一来，程序的代码行数就会变多\n在 VS 编译器下，这种问题还算好解决，我们可以快速跳转道函数定义。但如果我们没有这个功能可用，在处理大文本代码的时候，怎么很快的找到对应的仿函数呢？\n特别是在项目合作的时候，万一有个家伙编程命名规范很差劲，我们无法从函数名推断函数功能，再加上不能直接跳转定义，那麻烦事可多了。\n\n8.2 lambda 出场  这时候就可以试试用 lambda 表达式拉，以下是 lambda 表达式的书写格式\n[capture-list](parameters)mutable -&gt; return-type&#123;statement&#125;\n\n说明一下各个位置分别写的是啥玩意\n\n[capture-list]捕捉列表，用于编译器判断为 lambda 表达式，同时捕捉该表达式所在域的变量以供函数使用\n(parameters)参数，和函数的参数一致。如果不需要传参则可连带 () 一起省略\nmutable默认情况下  捕捉列表  捕捉的参数是 const 修饰的，该关键字的作用是取消 const 使其可修改\n-&gt; return-type函数返回值类型\n&#123;statement&#125;函数体，和普通函数一样。除了可以使用传入的参数，还可以使用捕捉列表获取的参数\n\n8.3 基本使用  先来写一个最简单的 lambda 表达式试试水吧\nauto Add = [](int a, int b) &#123;return a + b; &#125;;\n\n\n可以看到，这个表达式的使用方法和函数完全一致，也成功提供了结果\n因为我们返回值的类型是明确的，所以这里可以省略类型，让编译器自己来推断。当然也可以显示指定类型，这样可以更精确的控制\n\n\nlambda 表达式还支持复制给相同类型的函数指针，但是一般都不要这么用！\n//f2 是一个 lambdavoid(*PF)();PF = f2;PF();\n\n\n8.4 捕捉列表和 mutable学会了基本使用，我们再来看看捕捉列表是怎么玩的\nvoid TestLambda1()&#123;\tint a = 10, b = 20;\tauto func3 = [a,b](int x, int y)-&gt;int &#123;\t\treturn a+b;\t&#125;;\tcout&lt;&lt;func3(a, b)&lt;&lt;endl;&#125;\n\n\n这里我们捕捉了函数作用域里面的局部变量 a/b，直接在lambda 表达式内部使用👍\n因为不需要传入参数，所以我们可以直接把参数 () 和返回值一并省略掉\n\nmutable默认情况下，我们捕捉到的参数是带 const 的，我们并不能对其进行修改。\n\n这时候就需要使用前面提到的 mutable 关键字来修饰\n\n注意：这个关键字使用的时候必须带上函数参数的()\n\nauto func5 = [a, b]()mutable &#123;    a++;    b++;    return a + b;&#125;;\n\n\n\n8.5 捕获的几种方式  注意，当我们在对象里面以值传递方式捕获参数的时候，还需要捕获 this 指针来调用类内部的函数\n[val]：表示值传递方式捕捉变量 val[=]：表示值传递方式捕获所有父作用域中的变量(包括 this)[&amp;val]：表示引用传递捕捉变量 val[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括 this)[this]：表示值传递方式捕捉当前的 this 指针\n\n其中第一个就是我们上面演式的 [a,b] 这样最直接的值捕获\n而最后一个的 this 指针主要用用于类内部；需要注意，this 指针是不能被引用捕获的！因为函数里面的 this 指针本来也只是个传值参数而已，对于这个指针本身来说，引用捕获的意义其实并不是很大。\nclang++ test.cpp -o test -std=c++17test.cpp:84:18: error: &#x27;this&#x27; cannot be captured by reference        return [&amp;this]                 ^1 error generated.\n\n在 C++17 中新增了一个对 *this 的传值捕获，这部分可以去看 C++17 的博客。\n8.5.1 全捕获 &#x3D;当一个作用域里面的变量很多，而我们又不想一个一个写的时候，可以使用 = 捕捉全部变量\nint a = 10, b = 20;int c = 1, d = 3, e = 5;auto func6 = [=] &#123;    return (a + b + c + d + e);&#125;;cout &lt;&lt; func6() &lt;&lt; endl;\n\n\n8.5.2 引用全捕或  除了基本的全捕或，我们还可以用一个 &amp; 以引用的方式捕获全部参数。\n\nint a = 10, b = 20;int c = 1, d = 3, e = 5;auto func7 = [&amp;] &#123;    return (a + b + c + d + e);&#125;;cout &lt;&lt; func7() &lt;&lt; endl;\n\n引用了过后，我们也可以修改参数了\n\n8.5.3 全捕获 + 单独操作  如果只是仅仅的全捕或还不够，我们还想单独修改某一个参数的时候，可以以不同的方式进行捕获操作\n\nauto func8 = [=,&amp;e] &#123;\te++;\treturn (a + b + c + d + e);&#125;;\n\n\n这样一来就方便多了\n8.6 最终呈现  这样，当我们 sort 的时候，就不再需要用仿函数了，而是可以直接用 lambda 表达式来完成相同的操作，大大增加代码可读性！\n这是因为排序所用的方法直接就在 sort 这里用 lambda 的形式给出了，看代码的时候，也不需要去找定义，更不用担心函数命名规则的问题了。\nvector&lt;Goods&gt; v1 = &#123; &#123;&quot; 牛奶 &quot;,20,100&#125;,&#123;&quot; 杯子 &quot;,10,200&#125;,&#123;&quot; 饼干 &quot;,15,50&#125; &#125;;// 价格升序sort(v1.begin(), v1.end(), [](const Goods&amp; g1, const Goods&amp; g2) &#123;return g1._price &lt; g2._price; &#125;);for (auto&amp; e : v1) &#123;\tcout &lt;&lt; e._name &lt;&lt; &quot;_&quot; &lt;&lt; e._price &lt;&lt; &quot;  &quot;;&#125;cout &lt;&lt; endl;v1 = &#123; &#123;&quot; 牛奶 &quot;,20,100&#125;,&#123;&quot; 杯子 &quot;,10,200&#125;,&#123;&quot; 饼干 &quot;,15,50&#125; &#125;;// 价格降序sort(v1.begin(), v1.end(), [](const Goods&amp; g1, const Goods&amp; g2) &#123;return g1._price &gt; g2._price; &#125;);for (auto&amp; e : v1) &#123;\tcout &lt;&lt; e._name &lt;&lt; &quot;_&quot; &lt;&lt; e._price &lt;&lt; &quot;  &quot;;&#125;cout &lt;&lt; endl;v1 = &#123; &#123;&quot; 牛奶 &quot;,20,100&#125;,&#123;&quot; 杯子 &quot;,10,200&#125;,&#123;&quot; 饼干 &quot;,15,50&#125; &#125;;// 名称字典序sort(v1.begin(), v1.end(), [](const Goods&amp; g1, const Goods&amp; g2) &#123;return g1._name &lt; g2._name; &#125;);for (auto&amp; e : v1) &#123;\tcout &lt;&lt; e._name &lt;&lt; &quot;_&quot; &lt;&lt; e._price &lt;&lt; &quot;  &quot;;&#125;cout &lt;&lt; endl;\n\n\n8.7 lambda 底层：仿函数  实际上，lambda 的底层就是把自己转成了一个仿函数供我们调用。这也是为何 sort 可以以 lambda 来作为排序方法的原因——底层都是仿函数嘛！\n\n8.8 lambda 递归  如果需要用 lambda 写递归函数，那么 lambda 必须用 fuction 明确指定类型，而不能用 auto！\n比如下方是一个最简单的斐波那契的递归\n// 这里必须要引用捕获自身auto fib = [&amp;fib](int a) -&gt; int   &#123;       if ((a == 1) || (a == 2))       &#123;           return 1;       &#125;       else       &#123;           return (fib(a - 1)) + (fib(a - 2)); // n-1 和 n-2 项       &#125;   &#125;;\n\n这个时候编译就会出现如下的报错，因为 auto 是要这个 lambda 表达式的定义完全结束了才能进行类型推断，而我们又在 lambda 的函数体内使用了 fib 本身，那么就出现了声明前使用的问题！\ntest.cpp: In function ‘int main()’:test.cpp:75:18: error: use of ‘fib’ before deduction of ‘auto’     auto fib = [&amp;fib](int a) -&gt; int                  ^~~test.cpp: In lambda function:test.cpp:83:21: error: use of ‘fib’ before deduction of ‘auto’             return (fib(a - 1)) + (fib(a - 2)); // n-1 和 n-2 项                     ^~~test.cpp:83:36: error: use of ‘fib’ before deduction of ‘auto’             return (fib(a - 1)) + (fib(a - 2)); // n-1 和 n-2 项                                    ^~~\n\n正确的写法如下，用 function 明确指明这个 lambda 表达式的类型！而且还需要  引用捕捉自身！\n// 这里必须要引用捕获自身，[&amp;fib]，否则他不知道 fib 是啥玩意std::function&lt;int(int)&gt; fib = [&amp;fib](int a) -&gt; int   &#123;       if ((a == 1) || (a == 2))       &#123;           return 1;       &#125;       else       &#123;           return (fib(a - 1)) + (fib(a - 2)); // n-1 和 n-2 项       &#125;   &#125;;\n\n这时候才能通过编译！\n9. 包装器 functionfunction 包装器，也叫作适配器。C++ 中的 function 本质是一个类模板，也是一个包装器。\n那么这个东西是用来干啥的呢？\n\n把所有的可调用对象封装成统一的格式\n\n什么是可调用对象？\n\n函数\n函数指针\n仿函数对象\nlambda 表达式\n\n9.1 基本使用  我们可以用 function 来包装这些不同的可调用对象，说白了就是产生了另外一个相同的可调用对象。类似于“引用”了这个函数\nclass AddClass&#123;public:\tstatic int Addi(int a, int b)&#123;\t\treturn a + b;\t&#125;\tdouble Addd(double a, double b)&#123;\t\treturn a + b;\t&#125;&#125;;int func(int a,int b)&#123;\treturn a + b;&#125;struct Functor&#123;\tint operator()(int a,int b)&#123;\t\treturn a+b;\t&#125;&#125;;void TestFunction1()&#123;\t// 函数\tfunction&lt;int(int, int)&gt; func1 = func;\tcout &lt;&lt; func1(10, 20) &lt;&lt; endl;\t// 仿函数\tfunction&lt;int(int, int)&gt; func2 = Functor();\tcout &lt;&lt; func2(10, 20) &lt;&lt; endl;\t// 类中 static 成员函数\tfunction&lt;int(int, int)&gt; func3 = AddClass::Addi;\tcout &lt;&lt; func3(100, 200) &lt;&lt; endl;\t// 类中非静态成员函数\tfunction&lt;double(AddClass, double, double)&gt; func4 = &amp;AddClass::Addd;\tcout &lt;&lt; func4(AddClass(), 100.11, 200.11) &lt;&lt; endl;\t// lambda 表达式\tfunction&lt;int(int, int)&gt; func5 = [](int a, int b) &#123;return a + b; &#125;;\tcout &lt;&lt; func5(100, 200) &lt;&lt; endl;&#125;\n\n\n引用类中非 static 成员  需要注意的是，当我们使用静态成员函数的时候，必须要带上一个 this 指针才能很好的访问。所以我们需要穿入一个 AddClass() 的匿名对象来适配包装器\n同时，非静态  的成员函数还必须要进行 &amp; 取地址操作。静态的则可以不加\n\n为了统一，可以给成员函数都加上取地址以防忘记\n\n\n9.2 特殊场景的作用  这个东西呢，看起来好像没啥用，但是在一些地方可以帮大忙\n比如模板函数，假设我们知道在函数 B 里面需要调用一个模板函数 A 多次，而且每次调用都是相同类型的（或者说就只有已知的几个特定类型），那么就可以先用 fuction 对这个模板函数进行指定的实例化，避免每一次调用的时候，后台都需要单独去实例化一个函数，减小模板的性能损耗！\n9.3 改造逆波兰表达式 OJ\nleetcode 逆波兰表达式：https://leetcode.cn/problems/evaluate-reverse-polish-notation/\n\n之前写这个 OJ 的时候，我用的是栈和 switch/case 语句\nclass Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; s;        for(auto&amp; ch : tokens)        &#123;            if(ch==&quot;+&quot;||ch==&quot;-&quot;||ch==&quot;*&quot;||ch==&quot;/&quot;)            &#123;                int right=s.top();                s.pop();                int left=s.top();                s.pop();                switch(ch[0])                &#123;                    case &#x27;+&#x27;:                        s.push(left+right);                        break;                    case &#x27;-&#x27;:                        s.push(left-right);                        break;                    case &#x27;*&#x27;:                        s.push(left*right);                        break;                    case &#x27;/&#x27;:                        s.push(left/right);                        break;                    default:                        break;                &#125;            &#125;            else&#123;                s.push(stoi(ch));            &#125;           &#125;        return s.top();    &#125;&#125;;\n\n现在我们就不需要这么麻烦了，可以使用包装器来改造这个 OJ 题的答案\nclass Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; s;        map&lt;string,function&lt;int(int,int)&gt;&gt; FuncMap = &#123;            &#123;&quot;+&quot;,[](int x,int y)&#123;return x+y;&#125;&#125;,            &#123;&quot;-&quot;,[](int x,int y)&#123;return x-y;&#125;&#125;,            &#123;&quot;*&quot;,[](int x,int y)&#123;return x*y;&#125;&#125;,            &#123;&quot;/&quot;,[](int x,int y)&#123;return x/y;&#125;&#125;        &#125;;        for(auto&amp; ch : tokens)        &#123;            if(ch==&quot;+&quot;||ch==&quot;-&quot;||ch==&quot;*&quot;||ch==&quot;/&quot;)            &#123;                int right=s.top();                s.pop();                int left=s.top();                s.pop();                int ret = FuncMap[ch](left,right);                s.push(ret);            &#125;            else&#123;                s.push(stoi(ch));            &#125;           &#125;        return s.top();    &#125;&#125;;\n\n这里我们还用到了前面提到过的 &#123;&#125; 初始化构造。现在我们只需要从 funcmap 里面取出封装器封装的 lambda 表达式进行操作就可以了！\n代码一下就简洁了许多，但是这也只有学习过 C++11 的人才看得懂，属于一个进阶用法。这种键值对的方式也更方便后续代码的扩展。想添加其他的运算符，就只需要给 map 里面新增运算符字符串和对应的 lambda 表达式就可以了。\n如果用 switch/case 的老办法，就还得自己再写一个判断分支，会产生一定的代码冗余和重复。\n\n测试的时候发现出现了一些问题，int 溢出了。这大概率是因为 leetcode 修改了测试用例。\n\n把所有的 int 都改成 long long 即可。反正逻辑性代码没有 bug 就 OK 啦。\n\n\n10.bind 绑定  在上面我们用 fuction 包装一个对象内部的成员函数时，需要利用匿名对象传入一个 this 指针。这样就很不方便了，明明是两个参数的函数，非要传入第三个参数。\n要是我们再用 9.3 中 map 的方式来封装一个可调用的表，那带 this 指针的函数就没办法一起包装了\nclass AddClass&#123;public:\tstatic int Addi(int a, int b)\t&#123;\t\treturn a + b;\t&#125;\tint Addii(int a, int b)\t&#123;\t\treturn a + b;\t&#125;&#125;;int func(int a,int b)&#123;\treturn a + b;&#125;struct Functor&#123;\tint operator()(int a,int b)\t&#123;\t\treturn a+b;\t&#125;&#125;;map&lt;string, function&lt;int(int, int)&gt;&gt; FuncMap = &#123;    &#123;&quot; 函数 &quot;,func&#125;,    &#123;&quot; 仿函数 &quot;,Functor()&#125;,    &#123;&quot; 静态成员函数 &quot;,AddClass::Addi&#125;,    &#123;&quot; 非静态成员函数 &quot;,&amp;AddClass::Addii&#125;&#125;;\n\n如图，最后 addclass 中的非静态函数，就没有办法一同包装到 map 中\n\n\n这里不能使用可变参数包，因为是实例化操作\n\n这时候我们就可以使用 bind 来进行参数绑定\n10.1 使用bind 可以调整参数的顺序，绑定固有参数；最后形成一个新的可调用对象。\nbind 的第一个参数用于  指定需要绑定的函数，后面就是绑定的参数，和需要自己传入的参数\nfunction&lt;int(int, int)&gt; func7 = bind(&amp;AddClass::Addii,AddClass(), placeholders::_1, placeholders::_2);cout &lt;&lt; func7(100, 200) &lt;&lt; endl;\n\n\n这时候我们就不需要传入 this 指针，因为当我们用 bind 绑定的时候，已经默认传入了第一个参数了！\n10.2 占位符 placeholdersplaceholders是用来占位的，代表这里的参数需要用户手动传入，而 _1 代表传入的第一个参数，_2就是传入的第二个参数，以此类推\nfunction&lt;int(int, int)&gt; func7 = bind(&amp;AddClass::Addii,AddClass(), placeholders::_1, placeholders::_2);\n\n因为有不同的后缀，所以我们还可以调整绑定的参数顺序！\n//Minii 的作用是 a-bfunction&lt;int(int, int)&gt; func8 = bind(&amp;AddClass::Minii, AddClass(), placeholders::_1, placeholders::_2);cout &lt;&lt; func8(100, 200) &lt;&lt; endl;function&lt;int(int, int)&gt; func9 = bind(&amp;AddClass::Minii, AddClass(), placeholders::_2, placeholders::_1);cout &lt;&lt; func9(100, 200) &lt;&lt; endl;\n\n\n我们调整了顺序之后，也得到了不同的结果！\n10.3 异常  以下为 cplusplus 网站上对 bind 函数可能出现异常的描述\nException safety   Basic guarantee: if an exception is thrown, all objects involved are left in a valid state.   This function may only throw if the construction of any of its internal elements (of the decay types of Fn and Args...) throws.\n\nstd::bind 只有在传入的函数的参数  构造  时抛异常，他才会抛出异常。比如在拷贝构造中抛出异常的类。\n\n注意，如果传入的函数内部会抛出异常，和 bind 是没有关系的，这类异常会在函数运行时抛出，而不是 bind 的时候抛出。\n另外，如果 bind 的  目标函数参数  和传入的参数数量 &#x2F; 类型  不一致，会引发编译时错误，而不是运行时异常。\n\n比如下放的示例代码中，myexpclass 的拷贝构造会检测成员变量是否为负数，如果为负数不允许拷贝，会抛出一个异常。在 main 函数中，我们尝试引发这个异常，就能观测到 std::bind 在函数传参进行拷贝构造时抛出这个异常。（因为这里的参数没有使用引用，所以函数传参需要拷贝）\n#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;stdexcept&gt;using namespace std;// bind 测试函数template &lt;typename Callable, typename... Args&gt;void MyExpTestFunc(Callable &amp;&amp;func, Args &amp;&amp;...args)&#123;    try    &#123;        auto function = std::bind(std::forward&lt;Callable&gt;(func), std::forward&lt;Args&gt;(args)...);    &#125; catch (...)    &#123;        std::cout &lt;&lt; &quot;throw exception&quot; &lt;&lt; std::endl;    &#125;&#125;class myexpclass&#123;public:    myexpclass(int32_t a= 10,int32_t b= 20)        :_a(a),_b(b)    &#123;&#125;    myexpclass(const myexpclass&amp; eee)    &#123;        if(eee._a &lt; 0 || eee._b &lt; 0)        &#123;            throw std::runtime_error(&quot;this class cannot be copy&quot;);        &#125;        _a = eee._a;        _b = eee._b;    &#125;private:    int32_t _a;    int32_t _b;&#125;;int main()&#123;    std::function&lt;void(myexpclass)&gt; testFuncInt = [](myexpclass num)    &#123;        std::cout &lt;&lt; &quot;test MyExpTestFuncAgent with params&quot; &lt;&lt; std::endl;    &#125;;    myexpclass test1(1,2);    myexpclass test2(-1,2);    MyExpTestFunc(testFuncInt, test1);    std::cout &lt;&lt; &quot;end test1&quot; &lt;&lt; std::endl;    MyExpTestFunc(testFuncInt, test2);    std::cout &lt;&lt; &quot;end test2&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;exit&quot; &lt;&lt; std::endl;    return 0;&#125;\n\n测试结果如下，test2 参数进行 bind 的时候确抛出了该异常。\n&gt; ./testend test1throw exceptionend test2exit\n\n11.static_assertstatic_assert 是 C++11 引入的一个关键字，用于在编译时进行断言检查。它允许你在代码中添加一些条件，如果这些条件在编译时不满足，编译将会失败并显示错误消息。\nstatic_assert 的主要作用是在  编译  时验证一些常量表达式的真假情况，从而帮助开发人员捕获一些潜在的问题，例如常量值是否符合预期、模板参数是否满足要求等。\n示例：\n#include &lt;iostream&gt;template &lt;typename T, int Size&gt;class Array &#123;    static_assert(Size &gt; 0, &quot;Array size must be greater than zero&quot;);    T data[Size];public:    // ...&#125;;int main() &#123;    Array&lt;int, 0&gt; emptyArray; // 编译时失败，因为 Size 不满足条件    return 0;&#125;\n\n在上面的示例中，Array 类使用 static_assert 来检查数组大小是否大于零。如果在实例化 Array 类时数组大小不满足要求，编译时将会失败，并显示指定的错误消息。\n\nstatic_assert 在  编译时  进行合法性检查\nassert 在  运行时  进行检查\n\n12.constexprconstexpr 是 C++11 引入的关键字，用于声明在编译时可以求值的常量表达式。它可以用于变量、函数、构造函数等上下文，用来告诉编译器在编译时计算表达式的值，从而将其作为常量使用。\nconstexpr 的主要作用包括：\n\n编译时计算： 使用 constexpr 声明的变量或函数可以在编译时计算，而不需要在运行时进行计算。这有助于提高代码的性能，因为在编译时计算的结果可以直接嵌入到生成的机器码中。\n常量表达式： 通过使用 constexpr，你可以声明常量表达式，这些表达式可以用作编译时的常量值，例如数组大小、模板参数等。\n模板元编程： constexpr 可以与模板一起使用，用于在编译时执行一些复杂的操作，从而实现元编程技术。\n\n示例：\nconstexpr int factorial(int n) &#123;    return (n &lt;= 1) ? 1 : n * factorial(n - 1);&#125;int main() &#123;    constexpr int result = factorial(5); // 编译时计算阶乘    static_assert(result == 120, &quot;Factorial of 5 should be 120&quot;); // 编译时断言    return 0;&#125;\n\n在上面的示例中，factorial 函数被声明为 constexpr，这意味着它可以在编译时计算。我们使用 constexpr 函数计算了阶乘，并在 main 函数中使用了 static_assert 进行编译时断言，确保计算的结果是正确的。\n在具体运行到这里的时候，就不再需要实时计算，而是直接沿用了编译过程中生成的结果；提高了代码运行效率，但增加了编译时间。\n总之，constexpr 关键字允许在编译时求值的常量表达式，有助于优化代码并支持一些元编程技术。它在 C++ 中为编译时计算提供了强大的工具。\n13.remove_extent#include &lt;type_traits&gt;template&lt; class T &gt;struct remove_extent;\n\n若 T 是某类型 X 的数组，则提供等于 X 的成员 typedef type ，否则 type 为 T 。\n注意若 T 是多维数组，则只移除第一维。添加 std::remove_extent 的特化的程序行为未定义。\n// C++14 中多了一个辅助类型来使用该类template&lt; class T &gt;using remove_extent_t = typename remove_extent&lt;T&gt;::type;\n\n说人话的，这个东西的作用是获取到数组的  成员的类型；如果传入多维数组，则只会接触第一维；示例：\nvoid test_extend()&#123;    using ArrayType1 = int[5];    using ArrayType2 = int[5][10];    using ArrayType3 = int[5][10][10];    using ElementType1 = std::remove_extent&lt;ArrayType1&gt;::type;    using ElementType2 = std::remove_extent&lt;ArrayType2&gt;::type;    using ElementType3 = std::remove_extent&lt;ArrayType3&gt;::type;    std::cout &lt;&lt; typeid(ElementType1).name() &lt;&lt; std::endl;    std::cout &lt;&lt; typeid(ElementType2).name() &lt;&lt; std::endl;    std::cout &lt;&lt; typeid(ElementType3).name() &lt;&lt; std::endl;&#125;\n\n在 linux 下打印如下，这里就能看出文档里面说的对于多维数组  只移除第一维  的含义\n$ ./testiA10_iA10_A10_i\n\n14.[[nodiscard]]这个关键字的作用，是让编译器警告用户，不要忽略函数的返回值\n[[nodiscard]] int calculateSum(int a, int b) &#123;    return a + b;&#125;int main() &#123;    calculateSum(2, 3);  // 编译器可能会发出警告，提示未使用返回值    return 0;&#125;\n\n即这个函数的返回值必须被接受且使用，否则就会被警告\n$ g++ test.cpp -o test -std=c++11test.cpp: In function ‘int main()’:test.cpp:8:17: warning: ignoring return value of ‘int calculateSum(int, int)’, declared with attribute nodiscard [-Wunused-result]     calculateSum(2, 3);  // 编译器可能会发出警告，提示未使用返回值     ~~~~~~~~~~~~^~~~~~test.cpp:3:19: note: declared here [[nodiscard]] int calculateSum(int a, int b) &#123;                   ^~~~~~~~~~~~\n\n只要你用一个变量接受了这个返回值，就不会收到这个警告了\n[[nodiscard]] int calculateSum(int a, int b) &#123;    return a + b;&#125;int main() &#123;    int i = calculateSum(2, 3);  // 接受了返回值，不会发出警告    return 0;&#125;\n\n使用函数返回值作为判断条件，也算是使用了这个返回值，同样不会发出警告\n[[nodiscard]] int calculateSum(int a, int b) &#123;    return a + b;&#125;int main() &#123;    if(calculateSum(2, 3));  // 接受了返回值，不会发出警告    return 0;&#125;\n\n15.std::begin&#x2F;end 迭代器  这里说的迭代器并不是容器内部的，std 为了一致性，在 C++11 引入了 std::begin/std::end 来进行对原生数组的迭代;\n这两个函数除了可以构造一个原生数组的迭代器，还能获取到 vector 容器的迭代器；\n#include &lt;iterator&gt;// container (1)template &lt;class Container&gt;  auto begin (Container&amp; cont) -&gt; decltype (cont.begin());template &lt;class Container&gt;  auto begin (const Container&amp; cont) -&gt; decltype (cont.begin());// array (2)\ttemplate &lt;class T, size_t N&gt;  T* begin (T(&amp;arr)[N]);\n\n如下是 cplusplus 网站上的示例代码，看了就会好吧；&lt;iterator&gt;头文件会在 &lt;vector&gt; 头文件中被包含，所以这里不需要再包含一次了。\n// std::begin / std::end example#include &lt;iostream&gt;     // std::cout#include &lt;vector&gt;       // std::vector, std::begin, std::endint main () &#123;  int foo[] = &#123;10,20,30,40,50&#125;;  std::vector&lt;int&gt; bar;  // iterate foo: inserting into bar  for (auto it = std::begin(foo); it!=std::end(foo); ++it)    bar.push_back(*it);  // iterate bar: print contents:  std::cout &lt;&lt; &quot;bar contains:&quot;;  for (auto it = std::begin(bar); it!=std::end(bar); ++it)    std::cout &lt;&lt; &#x27; &#x27; &lt;&lt; *it;  std::cout &lt;&lt; &#x27;\\n&#x27;;  return 0;&#125;\n\n而用 typeid 获取变量名字\nint main()&#123;\tvector&lt;int&gt; arrv;\tarrv.push_back(1);\tcout &lt;&lt; typeid(arrv.begin()).name() &lt;&lt; endl;\tcout &lt;&lt; typeid(std::begin(arrv)).name() &lt;&lt; endl;\tint arri[] = &#123; 1,2,3 &#125;;\tcout &lt;&lt; typeid(std::begin(arri)).name() &lt;&lt; endl;\treturn 0;&#125;\n\n得到的结果如下，可见 std::begin 本质上只是对 int* 指针的一个封装。而如果用 begin 函数获取 vector 的迭代器，那么就会去取到 vector 之中封装好的迭代器，和直接使用 arrv.begin() 的效果相同\nclass std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;class std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;int *\n\n16.std::any_of类似的函数还有 std::for_each\n函数定义#include &lt;algorithm&gt;bool any_of (InputIterator start, InputIterator end, UnaryPredicate callback) ;\n\n这个函数的作用是，根据给定的迭代器区间，遍历执行 callback 函数；只要 callback 函数返回了一次 true，整个函数就会退出并返回 true。否则返回 false。\n相当于只有迭代器区间中的  所有值  都不满足回调函数中的判断条件的时候，才会返回 false；\n使用示例  上示例\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;int main()&#123;    // 设立一个相除的 map    unordered_multimap&lt;int,int&gt; divm;    divm.emplace(1,2);    divm.emplace(6,29);    divm.emplace(0,20);    divm.emplace(10,0); // error    divm.emplace(3,2);    divm.emplace(33,234);    // 遍历判断这个 map 里面是否所有的参数都满足相除的条件（即除数不能为 0）    if(std::any_of(divm.begin(),divm.end(),[](const auto&amp; div_pair)-&gt;bool&#123;        return div_pair.second == 0;    &#125;))    &#123;        cout &lt;&lt; &quot;args error&quot; &lt;&lt; endl;    &#125;    else&#123;        cout &lt;&lt; &quot;all good to div&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n\n在上面的代码中，我们通过 any_of 和 lambda 表达式来判断即将要进行批量相除操作的 map 中是否包含不满足相除条件的参数。可以看到，这之中有一对的除数是 0，这是不符合除法的规则的。而判断条件就是判断第二个除数是否为 0，所以 any_of 理应报错；\n运行结果如下，符合预期\nargs error\n\n如果将出错的哪一行注释掉，那么就不会报错\nall good to div\n\n17.std::atomic::compare_exchange_strong1. 说明  之前只接触过 std::atomic ，它是 C++ 内置提供的一个模板类，帮我们封装了访问的原子性。\n一般情况下，我们只会在数字变量上使用 std::atomic ，这时候对数据的修改操作就不需要我们自己加锁解锁了，std 底层会自动封装锁的操作。\n在 std::atomic 中还有两个函数，分别是 compare_exchange_strong 和 compare_exchange_weak ；\n这两个函数的入参和功能都相同，我们主要关注的是前两个入参\n\n和第一个入参 except 进行比较，如果原子量和该参数相同，则将原子量改成第二个参数，并返回 true\n如果原子量和第一个参数不同，则将第一个参数改为当前原子量的值，返回 false\n\n第一个入参是引用传参，是一个输入输出参数。在原子量和第一个参数不同的时候，这个参数会被修改。\nif(!x.compare_exchange_strong(0,10))&#123;  // 这两个参数之间可能会出现第二个执行流来访问并修改 x，导致线程不安全，缺失原子性    auto current_val = x; // x.load()&#125;\n\n为了避免上述情况中的线程安全问题，compare_exchange函数会在原子量和第一个参数不一致的时候，通过第一个参数输出当前的原子量。这样就能保证线程安全。所以如果你需要获取到原子量的当前值，请不要给第一个参数传入右值，传入可修改的左值；\n2.compare_exchange_strong 的使用示例State cur_state = State::Ready;if (engine.state_.compare_exchange_strong(cur_state,State::Closing)&#123;    // 判断当前引擎的状态，如果是就绪状态，就把他关闭    engine.close();&#125;else&#123;    // 如果是其他状态，就将错误输出，并通过输入输出参数获取到当前引擎的状态    cout &lt;&lt; &quot;[cannot close] cur_state: &quot; &lt;&lt; cur_state &lt;&lt; endl;&#125;\n\n3.weak 和 strong 的区别 C++ 中 std::atomic 类型的 compare_exchange 应该选择哪个版本？ - 知乎 (zhihu.com) \n C++11：原子交换函数 compare_exchange_weak 和 compare_exchange_strong-CSDN 博客 \nweak 版本的 CAS 允许偶然出乎意料的返回（比如在字段值和期待值一样的时候却返回了 false），不过在一些循环算法中，这是可以接受的。通常它比起 strong 有更高的性能。\n而 strong 的返回值能保证它是绝对符合预期的。\n结语  本篇超长的博客到这里就结束辣！\n其实 C++11 还有其他的新特性，但是那些我会单开一篇文章来写~\n\n","categories":["遇见C++"],"tags":["数据结构","C++","C++11"]},{"title":"【C++】空间配置器","url":"/posts/281674790/","content":"空间配置器，听起来高大上，那它到底是什么东西呢？\n\n\n1. 什么是空间配置器？空间配置器是 STL 源码中实现的一个小灶，用来应对 STL 容器频繁申请小块内存空间的问题。他算是一个小型的内存池，以提升 STL 容器在空间申请方面的效率 \n\n2. 了解空间配置器STL 以 128 个字节为分界线，将空间配置器分为了一级和二级\n2.1 一级  一级空间配置器中，allocate/deallocate函数实际上就是对 malloc/free 做了一个简单的封装\nstatic void * allocate(size_t n)&#123;    void *result = malloc(n);    if (0 == result) result = oom_malloc(n);    return result;&#125;static void deallocate(void *p, size_t /* n */)&#123;    free(p);&#125;// 这个函数是 malloc 失败的时候才会调用的template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)&#123;    void (* my_malloc_handler)();    void *result;    for (;;) &#123;        my_malloc_handler = __malloc_alloc_oom_handler;        if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;// 抛异常        (*my_malloc_handler)();        result = malloc(n);        if (result) return(result);    &#125;&#125;\n\n当 malloc 失败的时候，一级空间配置器会抛异常\n2.2 二级  在二级空间配置器中，会先判断带申请空间大小是否大于 128 个字节，如果超过了，则会去调用一级空间配置器\n# ifndef __SUNPRO_CCenum &#123;__ALIGN = 8&#125;;enum &#123;__MAX_BYTES = 128&#125;;enum &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;# endif  /* n must be &gt; 0      */static void * allocate(size_t n)&#123;    obj * __VOLATILE * my_free_list;    obj * __RESTRICT result;    if (n &gt; (size_t) __MAX_BYTES) &#123;        return(malloc_alloc::allocate(n));    &#125;    my_free_list = free_list + FREELIST_INDEX(n);    // Acquire the lock here with a constructor call.    // This ensures that it is released in exit or during stack    // unwinding.    #       ifndef _NOTHREADS    /*REFERENCED*/    lock lock_instance;    #       endif    result = *my_free_list;    if (result == 0) &#123;        void *r = refill(ROUND_UP(n));        return r;    &#125;    *my_free_list = result -&gt; free_list_link;    return (result);&#125;;/* p may not be 0 */static void deallocate(void *p, size_t n)&#123;    obj *q = (obj *)p;    obj * __VOLATILE * my_free_list;    if (n &gt; (size_t) __MAX_BYTES) &#123;        malloc_alloc::deallocate(p, n);        return;    &#125;    my_free_list = free_list + FREELIST_INDEX(n);    // acquire lock    #       ifndef _NOTHREADS    /*REFERENCED*/    lock lock_instance;    #       endif /* _NOTHREADS */    q -&gt; free_list_link = *my_free_list;    *my_free_list = q;    // lock is released here&#125;\n\n二级空间配置器中，主要的几个成员变量如下\nstatic obj * __VOLATILE free_list[__NFREELISTS]; // 哈希桶// Chunk allocation state.static char *start_free;static char *end_free;static size_t heap_size;\n\n这里是一个  内存池 + 一个 哈希桶, 内存池的长度为heap_size\n\n哈希桶以 8 字节对齐，分为了 16 个桶。最开始的时候，free_list哈希桶是空的\n\n当我们需要小于 128 个字节空间的时候（以 16 字节为例），二级空间配置器会直接去上面的内存池当中申请 20 个 16 字节的空间，链接到 16 字节对应的哈希桶的位置（1 号桶）\n在下面的 refill 函数中可以看到这一点\ntemplate &lt;bool threads, int inst&gt;void* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n)&#123;    int nobjs = 20;// 一次性申请 20 个    char * chunk = chunk_alloc(n, nobjs);    obj * __VOLATILE * my_free_list;    obj * result;    obj * current_obj, * next_obj;    int i;    if (1 == nobjs) return(chunk);    my_free_list = free_list + FREELIST_INDEX(n);    /* Build free list in chunk */      result = (obj *)chunk;      *my_free_list = next_obj = (obj *)(chunk + n);      for (i = 1; ; i++) &#123;        current_obj = next_obj;        next_obj = (obj *)((char *)next_obj + n);        if (nobjs - 1 == i) &#123;            current_obj -&gt; free_list_link = 0;            break;        &#125; else &#123;            current_obj -&gt; free_list_link = next_obj;        &#125;      &#125;    return(result);&#125;\n\n8 字节对齐的妙处  假设我们的 list 单个节点需要 12 个字节，set单个字节需要 16 个字节\n当 list 需要空间的时候，二级空间配置器也会去申请 16 个字节的空间，而不会去申请 12 个字节。这时候，当 list 将用完的空间还回来之后，就能拿过去给 set 用了！\n关于哈希桶的特殊处理  当我们用完了申请的空间，准备“释放”的时候，二级空间配置器会将释放回来的空间插入进哈希桶（头插）\n这里有一个特殊处理，当用完的空间，或者说是刚申请的空间插入进哈希桶的时候，二及空间配置器会将其强转为一个 obj 类型，这个类型的前 4/8 个字节会用来存放一个  指针 ，指向 下一个空间，以此构成链表\nunion obj &#123;    union obj * free_list_link;    char client_data[1];    /* The client sees this.        */&#125;;\n\n\n当我们再次需要这部分大小的空间的时候，只需要将哈希桶头指针的指向直接修改，就能链接上下一个空间，并将之前头指针指向的空间拿去用\n用的时候也不用管之前在此处存放的指针，毕竟下一次放回来的时候，二级空间配置器会来处理它的\n\n内存池空间不够用了咋办？之前提到了，二级空间配置器里面有一个小内存池。要是这个内存池用完了，要咋整呢？\n二级空间配置器想出来了一种很骚的做法：\n\n假设当前我们需要 24 字节的空间\n对应的桶下面没有空间给我们用\n内存池也用光了\n但是 48 字节的桶下面还有空间可以用\n直接把这个空间拿过来，拆成两个 24 链接到 24 的桶下面！\n\n这样便有效提高了空间利用率，也避免了 realloc 造成的时间消耗。\n当然，要是桶里面也没有多余空间了，那就只能老老实实去扩容了\n\n只能大的拆小的，小的空间不连续无法组成大的\n\n// 二级空间配置器里面的 reallocate 封装template &lt;bool threads, int inst&gt;void*__default_alloc_template&lt;threads, inst&gt;::reallocate(void *p,                                                    size_t old_sz,                                                    size_t new_sz)&#123;    void * result;    size_t copy_sz;    if (old_sz &gt; (size_t) __MAX_BYTES &amp;&amp; new_sz &gt; (size_t) __MAX_BYTES) &#123;        return(realloc(p, new_sz));    &#125;    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);    result = allocate(new_sz);    copy_sz = new_sz &gt; old_sz? old_sz : new_sz;    memcpy(result, p, copy_sz);    deallocate(p, old_sz);    return(result);&#125;\n\n\n2.3 关于单例的说明  在同一个进程里面，空间配置器只会有一个\n但 STL 库中的空间配置器并没有把自己设计成单例类，而是用了一个间接的做法\nstatic obj * __VOLATILE free_list[__NFREELISTS]; // 哈希桶// Chunk allocation state.static char *start_free;static char *end_free;static size_t heap_size;\n\n那就是所有成员变量都是 static 静态的\n我们知道，在类和对象中，静态成员变量是属于整个类的，所以它也是一种单例模式！\n\n2.4 空间配置器的优点\n空间配置器的时间复杂度是O(1)，申请空间的效率很高\n空间配置器能解决频繁申请空间导致的内存碎片问题\n\n当我们使用 STL 容器频繁申请小块空间（比如 list）就容易导致堆区中有非常多的小块空间被使用，而无法申请一个大的空间\n空间配置器提前申请了一个大块空间再私下管理，可以有效解决这个问题\n内存外碎片 &#x2F; 内碎片\n外碎片：多次申请小块空间造成。有足够内存，但是不连续，无法申请大块内存\n内碎片：list 只需要 12 个字节，而空间配置器因为内存对齐而给了它 16 个字节，浪费了 4 个字节造成的内存碎片\n\n3. 容器和空间配置器  之前学习 stl 容器的时候，就在定义中看到过这里的 alloc 默认模板参数\n\n这里默认传的便是 stl 库中的二级空间配置器\n\n只要你自己写的空间配置器符合 stl 的接口需求，你便可以将自己的空间配置器传入此处让容器使用！\n\ntypedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc;typedef __default_alloc_template&lt;false, 0&gt; single_client_alloc;\n\n在 list 中，alloc 又被封装了一层，用来处理节点申请的问题\ntemplate &lt;class T, class Alloc = alloc&gt;class list &#123;protected:  typedef void* void_pointer;  typedef __list_node&lt;T&gt; list_node;  typedef simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;\n\ntemplate&lt;class T, class Alloc&gt;class simple_alloc &#123;public:    static T *allocate(size_t n)                &#123; return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); &#125;    static T *allocate(void)                &#123; return (T*) Alloc::allocate(sizeof (T)); &#125;    static void deallocate(T *p, size_t n)                &#123; if (0 != n) Alloc::deallocate(p, n * sizeof (T)); &#125;    static void deallocate(T *p)                &#123; Alloc::deallocate(p, sizeof (T)); &#125;&#125;;\n\n随后，当创建节点、销毁节点的时候，list 就会调用封装好的 simple_alloc 来处理空间\nlink_type get_node() &#123; return list_node_allocator::allocate(); &#125;void put_node(link_type p) &#123; list_node_allocator::deallocate(p); &#125; link_type create_node(const T&amp; x) &#123;    link_type p = get_node();    __STL_TRY &#123;      construct(&amp;p-&gt;data, x);// 调用节点的构造函数    &#125;    __STL_UNWIND(put_node(p));    return p;  &#125;  void destroy_node(link_type p) &#123;    destroy(&amp;p-&gt;data);// 调用节点的析构函数    put_node(p);  &#125;\n\n\nconstruct通过  定位 new显式调用节点的构造函数\ndestroy通过指针来调用析构函数\n\ntemplate &lt;class T&gt;inline void destroy(T* pointer) &#123;    pointer-&gt;~T();&#125;template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value) &#123;  new (p) T1(value);&#125;\n\n在 stl_tree.h 中可以看到库里面的  红黑树  也对空间配置器进行了类似的封装\ntemplate &lt;class Key, class Value, class KeyOfValue, class Compare,          class Alloc = alloc&gt;class rb_tree &#123;protected:  typedef void* void_pointer;  typedef __rb_tree_node_base* base_ptr;  typedef __rb_tree_node&lt;Value&gt; rb_tree_node;  typedef simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;  typedef __rb_tree_color_type color_type;\n\n结语  关于空间配置器的内容了解这些就差不多啦！\n其实就是通过库里面的这个设计来了解一个提高小空间内存申请效率的方法，感觉还是很 666 的\n\n有啥问题可以在评论提出哦\n\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】thread|mutex|atomic|condition_variable","url":"/posts/1249427441/","content":"本篇博客，让我们来认识一下 C++ 中的线程操作\n\n\n\n所用编译器：vs2019\n阅读本文前，建议先了解线程的概念 👉 线程概念\n\n1. 基本介绍  在不同的操作系统，windows、linux、mac 上，都会对多线程操作提供自己的系统调用接口\n为什么 C++ 需要封装一个线程？直接用系统的接口不好吗？\n在 Linux 文件博客 中，已经谈过了这一点：对于 C++、python、java 这些  跨平台  的语言来说，如果直接用系统的接口，是可以实现对应操作的。但是，这样会导致代码  只能在某一个特定平台，甚至是某一个版本的特定操作系统上才能正常运行，直接与跨平台的特性相违背。\n解决的办法呢，就是对系统的接口套一个语言级别的软件层，封装系统的接口 。并用 条件编译  的方式来识别不同的操作系统，已调用不同操作系统的系统接口，以实现跨平台性\n2.thread 类\nhttps://legacy.cplusplus.com/reference/thread/thread/thread/\n\n2.1 构造 &#x2F; 赋值\n\n线程是不允许拷贝构造和赋值重载的，但是其支持  右值引用  的重载（主要是为了匿名对象构造）也支持空构造\n\n右值：无法进行取地址的变量\n\n2.2 get_id对于线程而言，比较重要的就是这个 id 号了，其用于标识线程的唯一性\n\n2.3 join&#x2F;detach创建好了一个线程，我们需要进行 join 等待或者 detach 分离\n\n如果主线程不需要获取子进程执行的结果，可以直接执行 detach\n如果需要等待子线程执行，则执行 join\n\n为什么会产生这两个分歧呢？是因为 join 等待是有一定消耗的。如果我们不关心线程执行的返回值，应该采用 detach 尽量减小消耗\n2.4 使用示例  相比于 Linux 系统提供的 pthread 接口，C++ 的使用方法更加直接\n#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void Add(int a, int b)&#123;\tcout &lt;&lt; a + b &lt;&lt; endl;;&#125;int main()&#123;\tthread t1(Add, 10, 20);\tthread t2(Add, 10, 30);\tt1.join();\tt2.join();\treturn 0;&#125;\n\n\n2.5 空构造和移动赋值  如果我们只是定义了一个 t1，没有直接调用构造函数指定其要运行的函数（其实是调用了空构造）那么要怎么给这个线程指定函数呢？\nthread t3;// 调用了空构造\n\n别忘了，虽然线程不支持拷贝构造，但他有移动赋值！\nthread&amp; operator= (thread&amp;&amp; rhs) noexcept;\n\n我们要做的，就是采用匿名对象的方式，赋值给 t3\nthread t3;t3 = thread(Add, 20, 30);t3.join();\n\n\n2.6 joinablebool joinable() const noexcept;\n\n这个函数的作用是标识一个线程是否还能进行 join；下面几种情况，线程不能被 join\n\n只调用了空构造（都没有指定需要运行的函数怎么 join 等待？）\n被 move 了（move 会将对象变成将亡值，也就是右值）\n该对象已经调用过 join 或者 detach\n\n如果是在多层函数中调用的线程，那可能 join 之前就可以判断一下当前对象是否还能 join\n2.7 swap&#x2F;movevoid swap (thread&amp; x) noexcept;\n\n该成员函数的作用是将另外一个线程切换给当前线程\n\n其本质就是一个 move 移动赋值\n\n被移动后的线程 t3 不再joinable，不会运行，也不能被 join 或 detach\n\n强行 join 会报错\n\n2.8 linux 下编译  由于 std 是对系统接口进行的封装\n所以在 linux 下编译带 c++ 线程库的代码时，需要带上 pthread 库的选项\ng++ test.cpp -o test -std=c++11 -lpthread\n\n3.std::ref这里有一个特殊的函数 ref，要想知道其作用，我们需要先看下面这个场景\n3.1 引用传参#define _CRT_SECURE_NO_WARNINGS 1//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;functional&gt;using namespace std;void Print(int n,int&amp; a)&#123;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; &quot; &lt;&lt;  a++ &lt;&lt; endl;\t&#125;&#125;int main()&#123;\tint count = 0;\tthread t1(Print,10, count);\tthread t2(Print,10, count);\tt1.join();\tt2.join();\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; count &lt;&lt; endl;\treturn 0;&#125;\n\n在这个场景中，我想达到的目标是让 t1 和 t2 两个线程帮我们对 count 进行 ++，最终在 main 里面打印结果；可编译会发现报错，不给我们这样写\n\n相同的代码在 linux 下也出现了编译错误，所用 g++ 版本如下\ng++ (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9)\n\n\n为了确认具体的报错位置，我们先把 int&amp; a 的引用去掉，再看看情况\n\n能看到，在没有采用  引用传参  的情况下，函数中对 count 进行的操作并不会反馈到 main 中，因为采用的是  传值，会进行拷贝。\n3.2 thread 构造函数  那为什么加上引用之后，会报错呢？这就和 thread 的构造函数有关系了\ntemplate &lt;class Fn, class... Args&gt;explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;... args);\n\n如上，当我们构造一个线程对象的时候，采用的是  可变模板参数 ；在我的博客中写到过，可变模板参数需要采用 递归  来进行参数类型的推测。\n由于底层实现的问题（也只能是这个原因了）在进行构造的完美转发时，所有的参数都采用了  拷贝  而不是引用传参。\n这也就导致我们没有办法将一个参数通过  引用  传入线程需要执行的函数！\n\n用指针肯定是可以的，可 C++ 搞出引用这个东西，就是为了避免使用指针\n\n3.3 ref 出场\nhttps://legacy.cplusplus.com/reference/functional/ref/?kw=ref\n\n于是乎，std 库中就新增了一个库函数ref，来解决这个问题\n// ref 的用法template &lt;class T&gt; reference_wrapper&lt;T&gt; ref (T&amp; elem) noexcept;template &lt;class T&gt; reference_wrapper&lt;T&gt; ref (reference_wrapper&lt;T&gt;&amp; x) noexcept;\ttemplate &lt;class T&gt; void ref (const T&amp;&amp;) = delete;\n\n\nConstructs an object of the appropriate reference_wrapper type to hold a reference to elem.\nIf the argument is itself a reference_wrapper (2), it creates a copy of x instead.\nThe function calls the proper reference_wrapper constructor.\n\n这个函数会构造一个合适的 reference_wrapper 对象，来管理一个变量的  引用 。如果参数本身就是reference_wrapper 类型，则会调用 reference_wrapper 的拷贝构造。\n而 ref 函数不能传递右值，其右值引用的重载是被 delete 的\n\n3.4 ref 使用thread t1(Print,10, ref(count));thread t2(Print,10, ref(count));t1.join();t2.join();\n\n使用了该库函数之后，编译不再报错，main 中的值也成功被修改\n\n通过 ref 传递的参数，也会遵守函数本身的变量规则。如果函数本身没有采用引用传参，则还是调用传值参数，会进行拷贝；\n\n为了避免后续出现这种问题，可以给所有对线程的左值传参都带上 ref😏比如给两个线程函数传入同一把锁的时候，就需要采用 ref 进行引用传参\n4. 指令重排\n谈谈指令重排 - 知乎\n面试官: 有了解过指令重排吗，什么是 happens-before\n\n4.1 什么是重排序  首先，什么是重排序❓计算机在执行过程中，为了提高性能，会对编译器和编译器做  指令重排。\n这么做为啥可以提高性能呢❓\n我们知道计算机在执行的时候都是一个个指令去执行，不同的指令可能操作的硬件不一样，在执行的过程中可能会产生  中断。\n打个比方，两个指令 a 和 b 他们操作的东西各不相同，如果加载 a 的时候停顿了，b 就加载不到，但是实际上它们互补影响，我也可以先加载 b 在加载 a，所以  指令重排  是减少停顿的一种方法，这样大大提高了效率。\n4.1.1 指令重排的方式  指令重排一般分为以下三种\n\n编译器优化 重新安排语句的执行顺序\n指令并行重排 利用指令级并行技术将多个指令并行执行，如果指令之前没有数据依赖，处理器可以改变对应机器指令的执行顺序\n内存系统重排 由于处理使用缓存和读写缓冲区，所以它们是乱序的\n\n指令重排可以保证  串行语义  一致，但是没有义务保证  多线程间的语义  也一致 **。所以在多线程下，指令重排序可能会导致一些问题\n4.2 实际场景  以懒汉的单例模式为例\n// 获取单例对象static InfoMgr* GetInstance()&#123;    if (_sp == nullptr)// 第一次检测保证单例    &#123;        unique_lock&lt;mutex&gt; lock(_mtx);        if (_sp == nullptr)// 第二次检测保证线程安全        &#123;            _sp = new InfoMgr;        &#125;    &#125;    return _sp;&#125;\n\n一般情况下，new一个新对象，执行的顺序应该是这样的\noperator new构造对象  赋值给_sp\n\n但编译器如果进行了指令重排，可能就会变成这样\noperator new赋值给_sp构造对象\n\n如果一个线程执行到第二步  赋值给_sp的时候，因为时间片到了被切换走了；其他线程来获取单例，就会导致 _sp 变量是一个已经被赋值了，但是其指向的是  没有初始化的空对象，这是错误的！\n4.3 可行的解决办法：内存栅栏  所谓内存栅栏，是系统提供的的接口，用于禁止 cpu 对指令的优化；\n\nhttps://blog.csdn.net/qq_16498553/article/details/128030833\n\n但内存栈栏是系统接口，没有跨平台性；这里只做了解，知道有这个问题即可！\n\n在一般情况下，我们不需要担心 4.2 中提到的问题，因为指令优化是有严格规则的，不会对赋值和构造这类指令进行胡乱优化（因为这样优化并不会有效率提升啊）\n但这也需要看具体平台的底层实现了！\n5. 获取线程返回值 5.1 输出型参数 在 C 语言中，想获取线程返回值，需要使用输出型参数（C++ 可以用引用传值）\nint Add(int a, int b,int&amp; out)&#123;\tout = a + b;\treturn out;&#125;void test2()&#123;\tint ret = 0;\tthread t2(Add, 10, 39, ref(ret));\tt2.join();\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; ret &lt;&lt; endl;&#125;\n\n\n5.2 lambda在 C++ 中，还可以使用 lambda 表达式，来在 main 中获取线程的返回值\nint Add(int a, int b)&#123;\treturn a + b;&#125;void test2()&#123;\tint ret = 0;\tthread t1([&amp;ret]() &#123; ret = Add(10, 29); &#125;);\tt1.join();\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; ret &lt;&lt; endl;&#125;\n\n\n6. 函数重载问题  在我测试的时候发现，如果一个函数具有重载，线程是不支持的；\n具体的原因嘛，我猜和线程构造的可变模板参数有关系。\n\n百度了一下，解决办法，是给第一个参数传入一个  函数指针  或者 fuctional 对象，手动指定使用的是哪一个函数。\n当然，还有一个解决办法：线程调用的函数不要有重载😂\nint Add(int a, int b,int&amp; out)&#123;\tout = a + b;\treturn out;&#125;int Add(int a, int b)&#123;\tint tmp = a + b;\tcout &lt;&lt; tmp &lt;&lt; endl;;\treturn tmp;&#125;void test2()&#123;\tint ret = 0;\t// 使用函数指针指定对应的函数\tthread t2(static_cast&lt;int(*)(int a, int b, int&amp; out)&gt;(Add), 10, 39, ref(ret));\tt2.join();\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; ret &lt;&lt; endl;&#125;\n\n\n7.this_threadstd 库中还用命名空间对线程的一些操作进行了封装\n\n\nget_id 获取线程 id 号（其实线程类里面已经有这个东东了，但是为了方便函数中直接调用，又多开了一个函数）\nyield 放弃自己的时间片\nsleep_until 休眠到一个时间点（比如睡到明天早八）\nsleep_for 休眠一定时间（睡 2 分钟）\n\n下面来对后面三个函数做一点解释（第一个就不解释了哈）\n7.1 yieldyield 的作用是让出当前线程的时间片；\n我们知道每一个线程运行时都会有一个自己的时间片，时间片到了，就会进行线程的切换；\n以下面的场景为例\nvolatile bool ready = false;void count1m(int id) &#123;\t// 如果 main 没有设置 ready 信号，线程会一直让出自己的时间片，不会运行\twhile (!ready) \t&#123;            \t\tthis_thread::yield();\t&#125;\t// 开始运行，++ 数据\tvolatile int i = 0;\tfor (i=0; i &lt; 10000000; i++) \t&#123; \t\t; // 循环体啥都不干\t&#125;\tcout &lt;&lt; id;&#125;void test4()&#123;\tthread threads[10];\tcout &lt;&lt; &quot; 创建 10 个线程 计数 \\n&quot;;\tfor (int i = 0; i &lt; 10; ++i) \t&#123;\t\tthreads[i] = thread(count1m, i);\t&#125;\tcout &lt;&lt; &quot; 创建 10 个线程 完毕 \\n&quot;;\tready = true;// 设置状态，让线程开始运行\tcout &lt;&lt; &quot;main set ture: &quot; &lt;&lt; ready &lt;&lt; &quot;\\n&quot;;\tfor (auto&amp; th : threads) \t&#123;\t\tth.join();\t&#125;\tcout &lt;&lt; &quot;\\nmain join 成功 &quot; &lt;&lt; &quot;\\n&quot;;&#125;\n\n执行结果\n创建 10 个线程 计数  创建 10 个线程 完毕main set ture: 13746089215main join 成功\n\n在这个场景中，每一个线程被设置了 task 后，都会先进入一个 while 循环，等待主线程进行 ready 的设置\nwhile (!ready) &#123;            \t;&#125;\n\n此时我们就可以在 while 循环中进行 yield 让线程  让出自己  的时间片。否则这个线程会一直疯狂访问 ready，导致 cpu 占用提高。\n// 如果 main 没有设置 ready 信号，线程会一直让出自己的时间片，不会运行while (!ready) &#123;            \tthis_thread::yield();&#125;\n\n在这种  轮询检测  的场景下，使用 yield 能避免某一个线程长时间占用执行流，解决了其他线程的饥饿问题。\n7.2 sleep_until用 cplusplus 的示例代码来学习使用方法，这里涉及到了多个库函数，详见注释\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;  //std::chrono#include &lt;iomanip&gt; //std::put_time#include &lt;ctime&gt;   //std::time_t, std::tm, std::localtime, std::mktimeusing namespace std;// 直接把 main 当作一个线程void test5()&#123;\ttime_t tt = chrono::system_clock::to_time_t(chrono::system_clock::now()); // 获取当前时间的时间戳\tstruct tm* ptm = localtime(&amp;tt); // 设置一个 tm 结构体，从当前时间戳创建\tcout &lt;&lt; &quot;Current time: &quot; &lt;&lt; put_time(ptm, &quot;%X&quot;) &lt;&lt; &#x27;\\n&#x27;; // 打印当前时间\tcout &lt;&lt; &quot;Waiting for the next minute to begin...\\n&quot;;\t(ptm-&gt;tm_min)++; // 设置 ptm 的 min 为下一分钟\tptm-&gt;tm_sec = 0; // 下一分钟的第 0s\tthis_thread::sleep_until(chrono::system_clock::from_time_t(mktime(ptm))); // 等待下一分钟开始运行\tcout &lt;&lt; put_time(ptm, &quot;%X&quot;) &lt;&lt; &quot; reached!\\n&quot;; // 再次打印当前时间&#125;\n\n运行结果如下，会等到下一分钟的第 0s 继续执行\nCurrent time: 15:13:40Waiting for the next minute to begin...15:14:00 reached!\n\n7.3 sleep_for这个函数的作用和 windows、linux 下都有的 sleep 函数一样，是睡指定的时间\n需要用 std 中的 chrono 模块来指定运行的时间，支持从小时一直到纳秒\n\n示例如下\nvoid test6()&#123;\ttime_t now;\ttime(&amp;now);// 获取当前时间戳\tcout &lt;&lt; now &lt;&lt; endl;\tthis_thread::sleep_for(chrono::seconds(30));// 睡 30s\ttime(&amp;now);// 获取当前时间戳\tcout &lt;&lt; now &lt;&lt; endl;&#125;\n\n可以看到，进程确实休眠了 30s\n\n8.mutex有了线程，那肯定离不开锁；关于线程加锁的问题，详见  我的 linux 博客\n这里只对 C++ 中锁的只用方法做一定演示\n8.1 构造\n锁的构造相对较简单，只有一个无参的构造，其不支持拷贝构造（比如函数传参中，一个锁被拷贝了，就失去了意义）\n8.2 成员函数  其余成员就是一个锁的基本接口，对应的也是 pthread_mutex 中的几个接口\n\nlock 加锁，不能申请锁则阻塞等待\ntry_lock 测试是否能申请锁，不能申请则 return\nunlock 解锁\n\n\n8.3 场景  所谓加锁，保护的就是临界资源；比如在下面的代码示例中，全局变量 count1 就是一个临界资源，其能够被多个执行流访问。\n注意：如果你展开了 std 命名空间，其中有一个 count 函数，会和你自己定义的全局 count 变量冲突。刚开始我就定义了 count，发现报错变量不明确。\n#define TOP 100volatile int count1 = 0;void func()&#123;\twhile(1)\t&#123;\t\tif (count1 == TOP)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; count1++ &lt;&lt; endl;\t\tthis_thread::sleep_for(chrono::milliseconds(10));\t&#125;\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; count1 &lt;&lt; endl;&#125;void test7()&#123;\tthread threading[10];\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tthreading[i] = thread(func);\t&#125;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tthreading[i].join();\t&#125;\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; count1 &lt;&lt; endl;\tthis_thread::sleep_for(chrono::seconds(2));&#125;\n\n测试的时候，就能看到一个很明显的冲突结果。31752 线程已经 ++ 到 100 了，结果它努力的结果被其他两个线程直接复写；\n当然，这里也有可能是显示器乱序打印的结果。要知道，显示器也是一个临界资源\n\nmutex mtx;void func()&#123;\twhile(1)\t&#123;\t\t\t\tif (count1 == TOP)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\t// 加锁的粒度要低\t\tmtx.lock();\t\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; count1++ &lt;&lt; endl;\t\tmtx.unlock();\t\tthis_thread::sleep_for(chrono::milliseconds(10));\t&#125;\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; count1 &lt;&lt; endl;&#125;\n\n给访问 count 的函数添加上锁，就能避免掉上面出现的问题\n\n9.CAS 原子操作  在系统中，提供了一些指令，来实现原子操作！\n9.1 原理 Compare And Set（或 Compare And Swap），简称 CAS。其是解决多线程 并行  情况下使用锁造成性能损耗的一种机制，采用这种  无锁的原子操作  可以实现线程安全，避免加锁的笨重性。\nCAS 操作包含三个操作数：内存位置（V）、预期原值（A）、新值(B)\n具体操作流程请看下图：\n\n如果上面的图看不懂，还可以看下面这个图\n\n文字描述如下：\n\n如果内存位置的值（V）与预期原值（A）相同，处理器会将该位置的值  更新  为新值（B） CAS 操作成功！\n否则，处理器不做任何更改，只需要将  当前位置的值进行返回  即可\n\nCAS 是实现  自旋锁  的基础，CAS 利用 CPU 指令保证了操作的原子性，以达到锁的效果，循环这个指令，直到成功为止。\n9.2 问题CAS 也不是万能的，其在如下场景下可能会出现问题\n1. 有线程 a 和 b2. 有全局变量，初始值为 13. 线程 a 先来访问，拿走了初始值 14. 发生线程切换，线程 b 来访问，拿走初始值 1，更新为 2，又修改回 15. 发生线程切换，线程 a 继续访问，此时值依旧是 1，线程 a 会认为没有问题，写入\n\n你可以看到，在上面的场景中，有一个线程把全局变量修改了之后又改了回去，这时候就没有办法从  取值  判断变量是否还是“原来的那个”了\n\n针对这种情况，java 并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证 CAS 的正确性。\n\nC&#x2F;C++ 中有没有办法解决这个问题呢？我没百度到😂\n10.lock_guard人如其名，这个类是一个守护锁。\ntemplate &lt;class Mutex&gt; class lock_guard;\n\n其运用了 RAII 的思路，能在构造的时候加锁，析构的时候解锁。我们就不需要自己操作了。\n毕竟，代码一长起来，一个锁有没有被解开，是真的搞不清楚😥\nmutex mtx;void test7()&#123;\tint x = 0;\tint n = 0;\tint m = 1000000;\tcin &gt;&gt; n;\tvector&lt;thread&gt; threading(n);\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tthreading[i] = thread([&amp;]() &#123;\t\t\tfor (int i = 0; i &lt; m; i++)\t\t\t&#123;\t\t\t\tlock_guard&lt;mutex&gt; t(mtx);// 自动加锁解锁\t\t\t\tx++;\t\t\t&#125;\t\t&#125;);\t&#125;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tthreading[i].join();\t&#125;\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; x &lt;&lt; endl;&#125;\n\n\n如果 for 循环中需要执行的代码很多，而只有 x 是临界资源的话，那就需要我们  手动控制  一下作用域&#123;&#125;\nfor (int i = 0; i &lt; m; i++)&#123;             // 其他代码             &#123;                 lock_guard&lt;mutex&gt; t(mtx);// 自动加锁解锁\t   x++;             &#125;             // 其他代码&#125;\n\n11.unique_locktemplate &lt;class Mutex&gt; class unique_lock;\n\n如果你学习过智能指针，那肯定就知道这个命名的含义；\nunique_lock是 lock_graud 的增强版本，其在支持自动加锁解锁的前提下，还支持手动加锁解锁；\n11.1 使用示例  下面就是一个标准的使用场景\nthreading[i] = thread([&amp;]() &#123;\tfor (int i = 0; i &lt; m; i++)\t&#123;\t\tunique_lock&lt;mutex&gt; t(mtx);// 自动加锁\t\tx++;\t\tt.unlock(); // 手动解锁\t\t// 模拟其他工作\t\tthis_thread::sleep_for(chrono::milliseconds(100));\t\t// 又需要访问临界资源\t\tt.lock();// 手动解锁\t\tx++;\t&#125;// 出作用域，自动解锁&#125;);\n\n11.2 try_lock除了最基础的 try_lock 之外，这个类还支持 for 和 until，和 this_thread 中的 sleep 是一样的含义\ntry_lockLock mutex if not locked (public member function)try_lock_forTry to lock mutex during time span (public member function)加锁一直到指定时间解锁（加锁到明天早八）try_lock_untilTry to lock mutex until time point (public member function)加锁 xx 时间（加锁 100 秒，时间到了自动解锁）\n\n时间到了之后，这个函数会进行解锁。如果用户在这之前已经手动解锁了，则什么都不会做\n11.3 release这个函数的作用就很独特了，其将自己管理的锁释放掉，不再管理这个锁\nmutex_type* release() noexcept;\n\n调用这个函数会返回托管互斥对象的  指针，释放其所有权。调用后，unique_lock 对象不再管理任何互斥对象（即，它处于与 if 默认构造相同的状态）。\n 注意，此函数不会  锁定或解锁  返回的互斥对象。\n说人话就是，不需要你 RALL 来管理这个锁了，交给用户自己管理！\n12.shared_ptr\nshared_ptr的完整代码请看我的 Gitee\n\n在智能指针中，shared_ptr采用引用计数来判断有多少次拷贝（拷贝构造、赋值重载），只有拷贝计数器为 1 的时候，析构才需要释放资源。\n在 shared_ptr 内部有一个变量进行计数。既然有一个计数变量，那就需要保证多线程执行时的原子性！\n12.1 引用计数加锁void AddRef()// 新增引用&#123;\t_pMutex-&gt;lock();\t++(*_pRefCount);\t_pMutex-&gt;unlock();&#125;\n\n12.2 释放void Release()&#123;\tbool flag = false;// 判断锁是否需要被释放\t_pMutex-&gt;lock();\tif (--(*_pRefCount) == 0 &amp;&amp; _ptr)\t&#123;               // 进入了这个函数，代表引用计数为 0\t\tdelete _ptr;\t\tdelete _pRefCount;\t\t// 标识需要释放锁\t\tflag = true;\t&#125;\t_pMutex-&gt;unlock();// 解锁\t// 释放锁\tif (flag)&#123;\t\tdelete _pMutex;           &#125;&#125;\n\n12.3 注意事项 shared_ptr 的加锁只限于这个类对象本身的安全性，这个锁并  不是  用来保护 shared_ptr 所指向的资源的！\n13.atomic在全局变量中，计数器是很常用的类型。所以 C++ 中还提供了一个可以进行原子操作的类，对这个变量进行的操作是具有原子性的，不需要我们进行加锁解锁\ntemplate &lt;class T&gt; struct atomic;\n\n13.1 基本使用atomic&lt;int&gt; val=0;void test8()&#123;\tcout &lt;&lt; val &lt;&lt; endl;\tval++;\tcout &lt;&lt; val &lt;&lt; endl;\tval = 20;\tcout &lt;&lt; val &lt;&lt; endl;\tval--;\tcout &lt;&lt; val &lt;&lt; endl;&#125;\n\n如果是 int 类型，原子变量和普通的 int 变量的使用没有什么区别！\n\n可以看到，重载了以后，原子变量支持++  --，也支持直接赋值\n\n不过，这些方法标明了，只有整形家族和指针类型可以使用！\n\n13.2 operator &#x3D;原子变量可以直接赋值，是因为其重载了 operator =\n//set value (1)T operator= (T val) noexcept;T operator= (T val) volatile noexcept;//copy [deleted] (2)atomic&amp; operator= (const atomic&amp;) = delete;atomic&amp; operator= (const atomic&amp;) volatile = delete;\n\n13.3 operator T&#x2F;loadoperator T 的作用，是支持  隐式类型  转换，这样原子变量在进行 if 比较的时候，会转换成重载后的类型\noperator T() const volatile noexcept;operator T() const noexcept;\n\n在 vs2019 里面跳转源码，能看到重载后的这两个函数，其实是调用了 load 方法\ntemplate &lt;class _Ty&gt;struct atomic : _Choose_atomic_base_t&lt;_Ty&gt;&#123;    //...\toperator _Ty() const volatile noexcept &#123;        static_assert(_Deprecate_non_lock_free_volatile&lt;_Ty&gt;, &quot;Never fails&quot;);        return this-&gt;load();    &#125;    operator _Ty() const noexcept &#123;        return this-&gt;load();    &#125;&#125;\n\n\n查看 cplusplus 的解释，load 方法就是返回了其内部所包含的值\nT load (memory_order sync = memory_order_seq_cst) const volatile noexcept;T load (memory_order sync = memory_order_seq_cst) const noexcept;\n\n\n这里还特意标注了，load 方法的使用是原子性的\n13.4 exchangeT exchange (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;T exchange (T val, memory_order sync = memory_order_seq_cst) noexcept;\n\nexchange函数的作用是修改原子变量管理的值，其返回值是  修改之前  的变量\nReturn valueThe contained value before the call.T is atomic&#x27;s template parameter (the type of the contained value).\n\n以下面的代码为例\natomic&lt;int&gt; val=0;void test8()&#123;\tcout &lt;&lt; val &lt;&lt; endl;\tint tmp = val.exchange(450);\tcout &lt;&lt; val &lt;&lt; endl;\tcout &lt;&lt; tmp &lt;&lt; endl;&#125;\n\n可以看到 tmp 接收到的结果是 val 的初始值 0，val 本身被修改为 450\n\n13.5 storevoid store (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;void store (T val, memory_order sync = memory_order_seq_cst) noexcept;\n\n这个函数的作用比 exchange 简单，其只修改存储的变量，没有返回值\n\n关于原子变量的介绍就这么多，下面来康康 C++ 中的条件变量\n14.condition_variable\n条件变量的概念，参考 linux 线程同步\n\n14.1 构造和 wait条件变量，是用于线程同步操作的一个接口。在 C++ 中，条件变量只有一个空构造\n//default (1)\tcondition_variable();//copy [deleted] (2)\tcondition_variable (const condition_variable&amp;) = delete;\n\n当我们进行 wait 等待的时候，需要往条件变量内传入一个锁；进入 wait 函数，开始等待前会先解锁（解开你传入的这个锁），退出 wait 函数前会加锁。\n//unconditional (1)\tvoid wait (unique_lock&lt;mutex&gt;&amp; lck);//predicate (2)\ttemplate &lt;class Predicate&gt;  void wait (unique_lock&lt;mutex&gt;&amp; lck, Predicate pred);\n\nwait 函数除了传入锁，还可以传入一个 Predicate pred 可执行函数体，来判断条件变量是否满足；\n如果指定了 pred，则只有当 pred 返回 false 时，该函数才会阻塞；并且只有当它变为 true 时，通知才能解除阻塞线程（这对于检查  虚假唤醒  特别有用）\n\n虚假唤醒，指的是一些代码错误的情况下，另外一个线程在条件尚未真正就绪的时候就唤醒了该线程\n比如一个线程池，我们可以设置一个 is_run 的 bool 值，并在所有线程的条件变量 wait 的地方添加上一个 lambda 表达式来返回这个 is_run。在执行线程池对象中的Run() 函数并唤醒所有线程之前，将 is_run 设置为 true（需要加锁）。那么如果线程被唤醒、is_run 又为假的时候，就代表当前线程池并没有真的启动，是一个虚假唤醒。\n添加上判断条件，能在 wait 中判断条件是否已经真正满足，从而避免虚假唤醒\n\nwait 内部对 pred 的检测是下面这样\nwhile (!pred()) wait(lck);\n\n只有 pred 返回真的时候，才会跳出 while 循环，唤醒线程。\n除了检测虚假唤醒，我们还可以用该执行体，对不同的线程  指定不同的唤醒条件！\n14.2 其他接口  其他接口的使用也很直接，其中 wait_for 和 until 前面已经介绍过了\n\nwait：在条件变量中阻塞等待，等待被唤醒\nnotify_one：唤醒在该条件变量等待下的一个线程\nnotify_all：唤醒在该条件变量下等待的所有线程\n\n\n14.3 实际用例  当下我们有两个线程，我们的目标是让 t1 和 t2 线程共同管理一个变量 i，对其进行 ++，并实现 t1 打印奇数，t2 打印偶数的功能（二者交错打印）\nvoid test9()&#123;\t// 目标：t1 打印奇数，t2 打印偶数，二者交错打印    bool ready = true;\tint i = 0;\tint n = 100;\tmutex mtx;\tcondition_variable cv;\t\t// t1 打印奇数\tthread t1([&amp;]()&#123;\t\twhile (i &lt; n)\t\t&#123;            unique_lock&lt;mutex&gt; lock(mtx);            cout &lt;&lt; &quot;t1 : &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;            i++;\t\t&#125;\t&#125;);\t\t// t2 打印偶数\tthread t2([&amp;]() &#123;\t\twhile (i &lt; n)\t\t&#123;\t\t\tunique_lock&lt;mutex&gt; lock(mtx);\t\t\tcout &lt;&lt;&quot;t2 : &quot;&lt;&lt;this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;\t\t\ti++;\t\t&#125;\t&#125;);\t\tthis_thread::sleep_for(chrono::seconds(3));\t\tcout &lt;&lt; &quot;t1:&quot; &lt;&lt; t1.get_id() &lt;&lt; endl;\tcout &lt;&lt; &quot;t2:&quot; &lt;&lt; t2.get_id() &lt;&lt; endl;\t\tt1.join();\tt2.join();\t&#125;\n\n当下已经实现出了二者的基本操作，但直接运行我们会发现，t1 都已经打印到 99 了，t2 才开始执行，完全不符合交错打印的需求\n\nthread t1([&amp;]()&#123;\twhile (i &lt; n)\t&#123;\t\t&#123;\t\t\tunique_lock&lt;mutex&gt; lock(mtx);\t\t\tcout &lt;&lt; &quot;t1 : &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;\t\t\ti++;\t\t&#125;\t\tthis_thread::sleep_for(chrono::microseconds(100));\t&#125;&#125;);\n\n如果在 t1 的 while 循环中加上一个休眠，t2 的函数体保持不变，则会发现是 t2 直接加到了 99，才让可怜巴巴的 t1 访问了临界资源（饥饿问题）\n\n这时候，我们就可以使用条件变量来实现线程相互唤醒和交错打印，代码如下\n// 条件变量测试void test9()&#123;\t// 目标：t1 打印奇数，t2 打印偶数，二者交错打印\tbool ready = true;\tint i = 0;\tint n = 100;\tmutex mtx;\tcondition_variable cv;\t\t// t1 打印奇数\tthread t1([&amp;]()&#123;\t\twhile (i &lt; n)\t\t&#123;            unique_lock&lt;mutex&gt; lock(mtx);            //ready 为假的时候，唤醒 t1            cv.wait(lock, [&amp;ready]()&#123;return !ready; &#125;);            cout &lt;&lt; &quot;t1 : &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;            i++;            ready = true;            cv.notify_one();\t\t&#125;\t&#125;);\t\t// t2 打印偶数\tthread t2([&amp;]() &#123;\t\twhile (i &lt; n)\t\t&#123;\t\t\tunique_lock&lt;mutex&gt; lock(mtx);             //ready 为真的时候，唤醒 t2\t\t\tcv.wait(lock, [&amp;ready]()&#123;return ready; &#125;);\t\t\t\tcout &lt;&lt;&quot;t2 : &quot;&lt;&lt;this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;\t\t\ti++;\t\t\tready = false;\t\t\t\tcv.notify_one();\t\t&#125;\t&#125;);\t\tthis_thread::sleep_for(chrono::seconds(3));\t\tcout &lt;&lt; &quot;t1:&quot; &lt;&lt; t1.get_id() &lt;&lt; endl;\tcout &lt;&lt; &quot;t2:&quot; &lt;&lt; t2.get_id() &lt;&lt; endl;\t\tt1.join();\tt2.join();\t&#125;\n\n运行一下，可以看到我们成功通过条件变量，使这两个线程交错打印奇偶数！\nt2 : 23208 : 0t1 : 24896 : 1t2 : 23208 : 2t1 : 24896 : 3t2 : 23208 : 4t1 : 24896 : 5t2 : 23208 : 6t1 : 24896 : 7t2 : 23208 : 8t1 : 24896 : 9t2 : 23208 : 10t1 : 24896 : 11//....t2 : 23208 : 90t1 : 24896 : 91t2 : 23208 : 92t1 : 24896 : 93t2 : 23208 : 94t1 : 24896 : 95t2 : 23208 : 96t1 : 24896 : 97t2 : 23208 : 98t1 : 24896 : 99t2 : 23208 : 100\n\n即便在 t1 中额外加上休眠，也不会影响输出结果的准确性！\n\n这便是条件变量对于线程同步控制的用法\n结语  在学习过 linux 的线程基础和系统接口后，理解 C++ 这里的多线程操作还算轻松！\nC++ 语法学习的最后一块拼图也被补上了！\n\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】using 的三种用法 | 转载","url":"/posts/834577958/","content":"C++ using 的三种用法，这个之前还没有接触过\n\n\n示例#include &lt;iostream&gt;using namespace std;class ClassOne &#123;public:\tint w;protected:\tint a;&#125;;class ClassTwo&#123;public:\tusing ModuleType = ClassOne;&#125;;template &lt;typename ClassType&gt;class ClassThree : private ClassType&#123;public:\tusing typename ClassType::ModuleType;\tModuleType m;\tClassThree() = default;\tvirtual ~ClassThree() = default;&#125;;void main()&#123;\tClassThree&lt;ClassTwo&gt;::ModuleType a;&#125;\n\n\n在上面代码中，一共有三处使用了using，分别是第 3,16,22 行，它们的作用为：\n\n引入命名空间\n指定别名\n在子类中引用基类的成员\n\n引入  命名空间  指定命名空间是 C++ using namespace中最常被用到的地方，在第 3 行中的：\nusing namespace std;\n\n\n指定别名 using 的另一个作用是指定别名，一般都是 using a = b; 这样的形式出现，比如在 13 行中：\nusing ModuleType = ClassOne;\n\n\nModuleType 是 ClassOne 的一个别名。using这个作用也比较常见，比如在 vector.h 中就有：\ntemplate&lt;class _Ty,class _Alloc = allocator&lt;_Ty&gt;&gt;class vector: public _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;&#123;public:\tusing value_type = _Ty;\tusing allocator_type = _Alloc;&#125;\n\n即 value_type 是_Ty 的一个别名，value_type a; 和 _Ty a; 是同样的效果。\n\n可以理解为 C++ 中的typedef\n\n在子类中引用  基类  的成员 using 的第三个作用是子类中引用基类的成员，一般都是 using CBase::a; 这样的形式出现，比如在 22 行中：\nusing typename ClassType::ModuleType;\n\n它和一般形式有些区别，就是它加了个 typename 修饰，这是因为类ClassThree 本身是个模板类，它的基类 ClassType 是个模板，这个 typename 和using 其实没有什么关系。如果 ClassType 不是模板的话，这行代码就可以写成：\nusing ClassType::ModuleType;\n\n剩下的就是 using 的作用，它引用了基类中的成员 ModuleType， ModuleType 又是类 ClassOne 的别名，所以后面 ModuleType m; 相当于定义对象 m，对于子类成员 m 来说，这样的效果和下面是相同的：\ntypename ClassType::ModuleType m;\n\n不同之处在于 using 还修改了基类成员的访问权限，子类 ClassThree 私有继承ClassType，所以ClassType 中共有成员 ModuleType 在子类ClassThree 是私有的，它不能被外部访问。但是使用using 后，在 main() 函数中可以使用。\n版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA] 版权协议，转载请附上原文出处链接和本声明。本文链接：https://blog.csdn.net/chaipp0607/article/details/100128842\n\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】C++11 中 R 字符串的作用","url":"/posts/3258704981/","content":"在 C++11 中添加了定义原始字符串的  字面量\n\n\n1. 定义和基本使用  定义方式为：\nR&quot;xxx(原始字符串)xxx&quot;\n\n其中 () 两边的字符串可以省略，R 只会处理括号中的字符串。\n原始字面量 R 可以直接表示字符串的实际含义，而不需要额外对字符串做  转义  等操作。\nR&quot;(&quot;HELLO&quot;)&quot;等同于R&quot;(\\&quot;HELLO\\&quot;)&quot;\n\n可以理解为是忽略所有转义字符的一个字符串格式\n#include &lt;iostream&gt;using namespace std;int main()&#123;\tconst char* s1 = R&quot;(Hello\\\\World)&quot;;\tcout &lt;&lt; s1 &lt;&lt; endl;\tconst char* s2 = &quot;Hello\\\\World&quot;;\tcout &lt;&lt; s2 &lt;&lt; endl;\treturn 0;&#125;\n\n\n2. 实际场景  在进行项目开发，需要用到 Json 字符串时，这个 R 字符串就非常有用\nrsp.body = R&quot;(&#123;&quot;code&quot;:0, &quot;message&quot;:&quot; 更新点踩成功 &quot;&#125;)&quot;;\n\n我们只需要使用 R 字符串，就能正常编写 json 格式的字符串\n如果不使用 R 字符串，就必须给 Json 中的每一个 &quot; 添加用于转义的\\&quot;，大大增加了代码的繁琐性，而且还容易出现漏加转义而导致的 bug\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】C++11 中局部 static 变量的线程安全问题 | 转载","url":"/posts/306129693/","content":"C++11 中局部 static 变量的线程安全问题\n\n\n前言  大家都知道，在 C++11 标准中，要求局部静态变量初始化具有  线程安全  性，所以我们可以很容易实现一个线程安全的单例类：\nclass Foo&#123;public:    static Foo *getInstance()    &#123;        static Foo s_instance;        return &amp;s_instance;    &#125;private:    Foo() &#123;&#125;&#125;;\n\n在 C++ 标准中，是这样描述的（在  标准草案  的 6.7 节中）：\n\nsuch a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization. If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.\n\n分析  标准关于局部静态变量初始化，有这么几点要求：\n\n变量在代码第一次执行到变量声明的地方时初始化。\n初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。\n在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。\n如果初始化过程中发生了对初始化的递归调用，则视为未定义行为。\n\n关于第 4 点，如果不明白，可以参考以下代码：\nclass Bar\n&#123;\npublic:\n    static Bar *getInstance()\n    &#123;\n        static Bar s_instance;\n        return &amp;s_instance;\n    &#125;\nprivate:\n    Bar()\n    &#123;\n        getInstance();\n    &#125;\n&#125;;\n\nGCC 的实现  以 GCC 7.3.0 版本为例，我们来分析 GCC 是如何实现标准的。\nFoo::getInstance()使用 GCC 编译后，我们使用 gdb 将文章开头的 Foo::getInstance() 反汇编：\nDump of assembler code for function Foo::getInstance():\n   0x00005555555546ea &lt;+0&gt;:     push   %rbp\n   0x00005555555546eb &lt;+1&gt;:     mov    %rsp,%rbp\n=&gt; 0x00005555555546ee &lt;+4&gt;:     movzbl 0x20092b(%rip),%eax        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;\n   0x00005555555546f5 &lt;+11&gt;:    test   %al,%al\n   0x00005555555546f7 &lt;+13&gt;:    sete   %al\n   0x00005555555546fa &lt;+16&gt;:    test   %al,%al\n   0x00005555555546fc &lt;+18&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;\n   0x00005555555546fe &lt;+20&gt;:    lea    0x20091b(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;\n   0x0000555555554705 &lt;+27&gt;:    callq  0x5555555545b0 &lt;__cxa_guard_acquire@plt&gt;\n   0x000055555555470a &lt;+32&gt;:    test   %eax,%eax\n   0x000055555555470c &lt;+34&gt;:    setne  %al\n   0x000055555555470f &lt;+37&gt;:    test   %al,%al\n   0x0000555555554711 &lt;+39&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;\n   0x0000555555554713 &lt;+41&gt;:    lea    0x2008fe(%rip),%rdi        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;\n   0x000055555555471a &lt;+48&gt;:    callq  0x555555554734 &lt;Foo::Foo()&gt;\n   0x000055555555471f &lt;+53&gt;:    lea    0x2008fa(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;\n   0x0000555555554726 &lt;+60&gt;:    callq  0x5555555545a0 &lt;__cxa_guard_release@plt&gt;\n   0x000055555555472b &lt;+65&gt;:    lea    0x2008e6(%rip),%rax        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;\n   0x0000555555554732 &lt;+72&gt;:    pop    %rbp\n   0x0000555555554733 &lt;+73&gt;:    retq   \nEnd of assembler dump.\n\n在 +4、+20、+53 出现的 _ZGVZN3Foo11getInstanceEvE10s_instance 使用 c++filt 分析为 guard variable for Foo::getInstance()::s_instance，而+41、+65 位置出现的 _ZZN3Foo11getInstanceEvE10s_instance 则为 Foo::getInstance()::s_instance。后者是s_instance 这个局部静态变量，前者从名字看就知道是个 guard 标志变量，用来指示局部静态变量的初始化状态。\n+4 ~ +18测试 guard 变量的第一个字节，如果为 0，代表s_instance 未初始化，进入 +27；否则代表s_instance 已初始化，进入+65。\n+20 ～ +27以 guard 变量地址作为参数，执行 __cxa_guard_acquire 函数。\n+32 ～ +39测试返回值，如果为 0，代表s_instance 已初始化，进入 +65；否则代表s_instance 未初始化，进入+41。\n+41 ～ +48初始化s_instance\n+53 ～ +60以 guard 变量地址作为参数，执行 __cxa_guard_release 函数。\n+65 ～ +73返回 s_instance 地址\n__cxa_guard_acquire我们来看看 __cxa_guard_acquire 这个函数具体做了什么，该函数代码位于gcc-7-7.3.0/gcc-7.3.0/libstdc++-v3/libsupc++/guard.cc。由于这个函数针对不同平台做了不同的实现，有些我们不需要的代码，以我机器的设置，支持线程和 futex 系统调用，所以删除了一些不相关的代码：\nint __cxa_guard_acquire (__guard *g)&#123;    // If the target can reorder loads, we need to insert a read memory    // barrier so that accesses to the guarded variable happen after the    // guard test.    // 1    if (_GLIBCXX_GUARD_TEST_AND_ACQUIRE (g))        return 0;    // If __atomic_* and futex syscall are supported, don&#x27;t use any global    // mutex.    // 2    if (__gthread_active_p ())    &#123;        int *gi = (int *) (void *) g;        // 3        const int guard_bit = _GLIBCXX_GUARD_BIT;        const int pending_bit = _GLIBCXX_GUARD_PENDING_BIT;        const int waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;        while (1)        &#123;            // 4            int expected(0);            if (__atomic_compare_exchange_n(gi, &amp;expected, pending_bit, false,                                            __ATOMIC_ACQ_REL,                                            __ATOMIC_ACQUIRE))            &#123;                // This thread should do the initialization.                return 1;            &#125;            // 5            if (expected == guard_bit)            &#123;                // Already initialized.                return 0;            &#125;            // 6            if (expected == pending_bit)            &#123;                // Use acquire here.                // 7                int newv = expected | waiting_bit;                // 8                if (!__atomic_compare_exchange_n(gi, &amp;expected, newv, false,                                                 __ATOMIC_ACQ_REL,                                                 __ATOMIC_ACQUIRE))                &#123;                    // 9                    if (expected == guard_bit)                    &#123;                        // Make a thread that failed to set the                        // waiting bit exit the function earlier,                        // if it detects that another thread has                        // successfully finished initialising.                        return 0;                    &#125;                    // 10                    if (expected == 0)                        continue;                &#125;                // 11                expected = newv;            &#125;            // 12            syscall (SYS_futex, gi, _GLIBCXX_FUTEX_WAIT, expected, 0);        &#125;    &#125;    return acquire (g);&#125;\n\n\n\n首先检测 guard 变量，guard变量等于 1 的话，直接返回 0，代表s_instance 已初始化，不需要再次初始化。\n检测是否为多线程环境，如果没有多线程的话，也就没有必要去做额外工作来保证线程安全了。\nguard_bit表示 s_instance 已经初始化成功；pending_bit表示 s_instance 正在初始化；waiting_bit表示有其他线程正在等待 s_instance 的初始化。\n使用一个原子操作来检测 guard 变量是否为 0，如果为0，则由当前线程初始化s_instance，把pending_bit 写入 guard 变量，返回1。如果不为0，则将 guard 当前值写入expected。\n检测 expected 值是否为 guard_bit，如果是，则s_instance 已初始化完成，不再需要初始化，返回0。\n检测 expected 值是否为 pending_bit，如果是，说明s_instance 正在初始化，且没有其他线程等待初始化。\n将 newv 变量设置为 pending_bit | waiting_bit，表示s_instance 正在初始化且有线程正在等待初始化。\n使用一个原子操作来检测 guard 变量是否为 pending_bit，如果不是，说明有其他线程修改了guard 变量，需要做进一步检测；如果是，说明没有其他线程修改 guard 变量，则将 pending_bit | waiting_bit 写入 guard 变量。\n如果 expected 等于 guard_bit，说明s_instance 被初始化成功，不需要再初始化，返回0。\n如果 expected 等于 0，说明s_instance 初始化失败，回到 4 重新开始检测。\n如果在 8 中没有其他线程修改过 guard 变量，将 expected 设置为 pending_bit | waiting_bit，表示s_instance 正在初始化且有线程（也就是当前线程）正在等待初始化。\n如果在 6 处没有进入 if 分支，说明 expected 等于 pending_bit | waiting_bit，如果进入了 if 分支，由11 可得，此时 expected 也被修改为了 pending_bit | waiting_bit。总之，此时s_instance 正在初始化且有线程正在等待初始化。利用 futex 系统调用，再次检测 guard 变量是否发生了变化，如果发生了变化，回到 4 重新开始检测；如果没有发生变化，仍然等于pending_bit | waiting_bit，则挂起当前线程。\n\n总之，__cxa_guard_acquire要么返回 0 要么返回 1，用来指示s_instance 已初始化或未初始化。__cxa_guard_acquire可能会导致当前线程挂起，这发生在 s_instance 正在初始化的时候。\n__cxa_guard_release由于 __cxa_guard_acquire 可能导致当前线程挂起，因此需要在 s_instance 初始化完成后使用将 __cxa_guard_release 线程唤醒。\nvoid __cxa_guard_release (__guard *g) throw ()&#123;    // If __atomic_* and futex syscall are supported, don&#x27;t use any global    // mutex.    // 1    if (__gthread_active_p ())    &#123;        int *gi = (int *) (void *) g;        const int guard_bit = _GLIBCXX_GUARD_BIT;        const int waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;        // 2        int old = __atomic_exchange_n (gi, guard_bit, __ATOMIC_ACQ_REL);        // 3        if ((old &amp; waiting_bit) != 0)            syscall (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);        return;    &#125;    set_init_in_progress_flag(g, 0);    _GLIBCXX_GUARD_SET_AND_RELEASE (g);&#125;\n\n\n\n检测是否为多线程环境\n使用原子操作将 guard 变量置为 guard_bit，同时获取guard 变量原始值。\n如果 guard 变量原始值包含 waiting_bit，说明有线程挂起（或将要调用futex 欲使线程挂起），调用 futex 唤醒挂起的进程。\n\n__cxa_guard_abort由于 s_instance 可能初始化失败（本例中并未体现），因此还有一个 __cxa_guard_abort 函数。\nvoid __cxa_guard_abort (__guard *g) throw ()&#123;    // If __atomic_* and futex syscall are supported, don&#x27;t use any global    // mutex.    if (__gthread_active_p ())    &#123;        int *gi = (int *) (void *) g;        const int waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;        int old = __atomic_exchange_n (gi, 0, __ATOMIC_ACQ_REL);        if ((old &amp; waiting_bit) != 0)            syscall (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);        return;    &#125;    set_init_in_progress_flag(g, 0);&#125;\n\n\n与 __cxa_guard_release 基本一致，不同的地方在于会将 guard 变量置0。\n递归初始化调用  由于在 C++11 标准中，初始化如果发生了递归是未定义行为，所以 GCC 7.3.0 针对是否为  多线程  环境做了不同的处理。如果是多线程环境，不进行额外处理，会发生死锁；如果是单线程环境，则会抛异常。\n// acquire() is a helper function used to acquire guard if thread support is// not compiled in or is compiled in but not enabled at run-time.static intacquire(__guard *g)&#123;    // Quit if the object is already initialized.    if (_GLIBCXX_GUARD_TEST(g))        return 0;    if (init_in_progress_flag(g))        throw_recursive_init_exception();    set_init_in_progress_flag(g, 1);    return 1;&#125;\n\n\n总结  看到了 GCC 如此复杂的实现，我的个人感想是还是不要自己造轮子来保证单例类的线程安全了，想要做到和 GCC 一样的高效还是比较难的，利用 C++11 标准的带来的便利就挺好。\n原文作者：imred原文链接：https://blog.csdn.net/imred/article/details/89069750\n\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】引用和内联函数","url":"/posts/3945540971/","content":"阿巴阿巴，最近搭建好了  腾讯云的 Linux 环境 ，所以本篇 C++ 的博客就尝试在 Linux 环境下来测试代码吧！ 阿巴阿巴，最近搭建好了  腾讯云的 Linux 环境，所以本篇 C++ 的博客就尝试在 Linux 环境下来测试代码吧！\n今天学习了 C++ 的引用和内联函数，一起来瞅瞅它们都是些啥……\n\n\n\n感谢你关注  慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n\n[TOC]\n前言  众所周周知，C 语言之中，有一个叫指针的家伙，它的使用方式如下\nint main()&#123;\tint a=10;\tint*p=&amp;a;//p 是一个指针变量，指向 a        return 0;&#125;\n\n这时候我们就可以通过 *p 对指针解引用访问变量 a\n所以 C++ 之中也有一个类似的东西，叫做  引用，不过它和指针完全不同哦\n\n1. 引用 1.1 基本形式 引用的基本方式如下\nint a=10;int&amp; b=a;int&amp; c=a;// 同一个变量可以有多个别名// 可以用两个不同的变量名引用同一个// 但是引用了之后不可以更改对象\n\n此时的 b 和 c 都是 a 的别名，注意是别名！\n  \n可以  用两个不同的变量名  引用同一个变量，而且引用了之后不可以更改对象\n\n一个变量可以有多个引用\n指针可以更改指向的对象，引用不可以\n引用必须在定义的时候就初始化，不可以int&amp; b;\n\n\n比如你叫李华，有人叫你“小李”，还有人叫你“英语作文人”，这两个外号都是你的别名。\n\n指针并不是别名，指针是通过地址访问某个变量。而引用是给 a 变量起另外的两个名字，实际上 b 和 c 都可以当作 a 来使用\n\n编译运行代码，让编译器打印出这三者的地址，可以看到它们的  地址是一样的，因为它们本来就是同一个变量的不同名字。\n\n\n指针变量的地址  和指针变量  所指向对象的地址  是不同的\n\n引用的类型必须和引用实体的类型相同，不能用 int&amp; 引用 double 类型\n\n\n1.2 引用的权限问题 ①const 常量 引用可以引用常量，但是必须加 const 修饰\n\n基本的思路就是“权限可以缩小，但不可以放大”。\n\n在上面的代码中，a 是一个可以修改的变量，但是 const int&amp;d=a; 中的 d 是不能修改，只可读取 a 的内容。\ne 是不可修改的常量，所以我们不能用 int&amp; 来放大权限\n\n②int 和 double 相互引用  在1.1中有提到，我们不能用 int&amp; 来引用 double 类型的变量，编译器会报错\n\n不过我们可以用 const int&amp; 类型来引用 double，此时引用就不是简单的一个别名了\n先来了解一下把 double 复制给 int 类型，这时候会产生“隐式类型转换”，h 保存的是 z 的整数部分\n\n\n在这个过程中，编译器会产生一个临时变量存放 z 的整数部分，然后赋值给 h\n\n临时变量具有“常性”，可读不可改\n\n而当我们用 const int&amp; 类型来引用 double 时，实际上引用的是编译器产生的临时变量，它是一个常量，所以我们需要用 const int&amp; 来引用\nconst int&amp; i=z;// 这里的 i 是临时变量的别名// 在引用的时候，创建了一个临时变量存放 d 的整数部分//i 的地址和 z 不相同，且临时变量不会销毁，生命周期和 i 同步// 生成的这个临时变量是常量，所以 i 的本质是引用了一个 int 类型cout &lt;&lt;&quot;i= &quot;&lt;&lt;i&lt;&lt;endl;cout &lt;&lt;&quot;&amp;i= &quot;&lt;&lt; &amp;i &lt;&lt;endl; cout &lt;&lt;&quot;&amp;z= &quot;&lt;&lt; &amp;z &lt;&lt;endl;// 在 c++ 中函数主要使用引用传参，后面会进一步学习\n\n一个非常直观的验证方法，就是打印一下，瞅瞅它们的地址是否相同。可以看到，i 的值和 h 是相同的，因为它引用的就是那个  存放了整数部分的临时变量，这个临时变量的地址和 z 不同\n\n1.3 引用的使用场景 ①函数传参 众所周知，在 C 语言中，如果我们想在函数中修改某一个 main 传过来的参数，就必须进行  传址调用。而在 C++ 中，我们可以通过引用来操作\n\n可以看到，我们通过引用实现了在函数中修改 a 的值\n\n更加充分的体现便是 Swap 函数，在 C 语言中必须两个都传  地址  来调用\n在 C++ 中，配合函数重载，我们可以很方便的写出多个交换函数\n\n\n直接测试一下，交换成功！\n\n\n②函数返回值int&amp; Count()&#123;  int n=0;// 现在没有加 static，返回的变量 n 可能会覆盖  n++;  cout&lt;&lt;&quot;&amp;n:&quot;&lt;&lt;&amp;n&lt;&lt;endl;  return n;&#125;int main()&#123;  int&amp; ret = Count();  cout&lt;&lt; ret &lt;&lt;endl;  cout&lt;&lt;&quot;&amp;ret:&quot;&lt;&lt;&amp;ret&lt;&lt;endl;  cout&lt;&lt; ret &lt;&lt;endl;&#125;\n\n当我们把 n 作为 int&amp; 类型来返回时，ret 此时是对 n 的引用。但是函数中的变量 n 在出了函数后销毁了，所以在 main 函数中打印 ret 的时候，可能会打印出随机值（这个要看什么时候 n 的内容会被编译器覆写）\n\n而当我们带上 static 后，多次打印 n 的值都不会出现问题，因为此时 n 的空间并没有被销毁\n\n\n如果函数返回时，出了函数作用域，如果返回对象还未还给系统，则可以使用引用返回\n如果已经还给系统了，则必须使用传值返回，避免出现访问随机值\n\n\n下面用一个简单的 Add 函数来演示一下上面提到的两种情况\n\n如果去掉 static 修饰，编译器会报警告，而且打印的值会在第二次 cout 调用的时候被覆写\n\n当 Add 函数的 c 变量加了 static 修饰后，打印的值都是稳定的，不会被覆写（因为 c 的空间没有被销毁）\n\n③优化函数调用时间  在函数返回传参的时候，其实是  先把返回值存放到寄存器  中，而不是直接返回给 main 函数的变量\n\n当返回值很小（指占用空间）的时候，会用寄存器存放它的值\n当返回值很大的时候，部分编译器会先在 main 函数中预先开辟栈帧用来存放返回值\n\n\n而使用引用作为返回值的时候，就不需要用寄存器来接收临时变量，这时候就  优化了函数返回的时间！\n\n可以看到，用引用返回的时间消耗很小！\n\n再来试试把引用作为参数传参的消耗，和传址、传值进行对比，代码和上面的类似，稍微修改一下测试函数就行了\n\n可以看到，传地址和引用作为参数的传参消耗都是很小的。因为  传值  的时候需要拷贝数据！\n\n\n1.4 引用和指针的汇编代码  用下面的代码来查看引用和指针的汇编区别\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint&amp; ra = a;\tra = 20;\tint* pa = &amp;a;\t*pa = 20;  \treturn 0;&#125;\n\n你可以看到，指针和引用的汇编代码是相同的。因为 C++ 的引用，本质上是用指针实现的！\n\n用 objdump -S 语句，查看 Linux 环境下的汇编👇\n\n1.5 引用和指针的区别\n引用是别名；指针是指向地址\n引用必须在定义的时候初始化；指针无要求\n引用的 sizeof 大小 和引用对象相同；指针无论指向的谁，大小都是 4&#x2F;8\n引用不能为 NULL；指针可以为 NULL\n引用 ++ 即对象数值 +1；指针 ++ 是指向的地址向后偏移\n引用无多级；指针存在二级、三级……\n引用比指针使用起来更加安全（不会出现野指针）\n引用是编译器处理的；指针需要手动解引用\n……\n\n1.6 数组指针引用  笔试的时候遇到了这个纠错题，我感觉这里是错的，但还是没选出来；\nint arr[20];int (&amp;ref1)[20] = arr;// 正确的数组引用int&amp; ref2[20] = arr;  // 错误的引用\n\n2. 内联函数 2.1 基本形式 在函数名前用 inline 修饰的函数是内联函数，编译器在处理此类函数的时候，会将函数在调用它的地方打开。此时内联函数就没有函数压栈的开销，提高了程序运行的效率\n\n这部分和 C 语言学习过的 #define 类似，但 define 是直接替换，内联函数不是\n\n#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;#define ADD(a,b) ((a)+(b))inline int Add(int a,int b)&#123;  return a+b;&#125;int main ()&#123;  int sum=ADD(1+3,2+4);//4+6=10       printf(&quot;%d\\n&quot;, sum);   int ret = 0;  ret=Add(3,4);  return 0;&#125;\n\n2.2 查看预处理文件  使用下面的 Linux 语句可以把源文件生成为  预处理后  的文件\n\n这部分可以看看我之前用树莓派操作的博客哦！【传送门】\n\ng++ -E test.cpp -o test.i\n\n可以看到 define 被替换了，但是内联函数并没有\n\n2.3 查看汇编代码 ①Linux 环境 这时候我们先编译这个文件\ng++ test.cpp\n\n然后使用下面的语句查看汇编代码\nobjdump -S a.out\n\n然后你就发现，这不还是有 call 函数调用嘛？这哪里没有调用呢？\n\n实际上，我们在编译的时候需要  调整编译器的优化操作👉【参考博客】\ng++ -O2 test.cpp\n\n这时候的汇编代码就没有 call 了\n\n②VS2019要想调整 VS2019 的  优化等价 ，需要在项目属性中C/C++ - 常规 中修改  调试信息格式  为“程序数据库”\n\n然后在  优化 - 内联函数扩展  修改成  只适用于 inline(/Ob1)\n\n然后调试，右键转到反汇编，可以看到，no call🕵️‍♂️\n\n\n2.4 内联函数的特性 define 没有传参检查，且不能 debug+ 可读性不高，内联函数解决了这一缺点\n\n内联函数是用空间换时间的做法，省去函数调用的开销\n函数代码很长的时候不适合用内联函数（define 同理）\n在代码行数很长的时候，编译器会自己判断是否使用 inline。如果函数体内有循环 &#x2F; 递归等，编译器优化的时候会取消内联\ninline 不可以声明和定义分离，会导致链接错误\n\n对最后一点展开介绍一下，当我们把内联函数的声明和定义放在不同的源文件和头文件中，编译器会报错找不到函数\n\n这是因为内联函数在调用的时候已经展开了，对应的  函数地址  也没了，所以无法正常链接\n\n结语  引用和内联函数的博客到这就结束啦，如果对你有帮助，还请点个赞再走哦！\n\n笔记难免有错，还请大佬们无情指出！\n\n","categories":["遇见C++"],"tags":["Linux","C++"]},{"title":"【C++】使用 CPP+STMP 发送邮件","url":"/posts/4118547036/","content":"本文转载于 CSDN，找了好久才找到的可用的邮件代码！\n原文标题：c++ 实现 smtp 发送邮件，支持 ssl 的 465 端口发送，支持附件、一次发送多人、抄送等  原文链接：https://blog.csdn.net/weixin_44979075/article/details/131094396原文作者：樱花回忆\n\n前言 c++ 实现smtp 发送邮件，支持 ssl 的 465 端口发送，支持附件、一次发送多人、抄送等。  \n这里只使用了 openssl 库（用来支持 ssl 的 465 端口），其他部分是原生 c++, 支持在 win&#x2F;linux 运行。  \n网上很多都是原始的支持 25 端口，明文发送，这里介绍一下 ssl 思路\n实现思路  使用 sockect 编程和 ssl，使用SMTP 协议。  \n使用了 c++ 的多态语言特性，包括重载和虚函数。  \n文中给出 mail.h 和 mail.cpp 以及 main.cpp 部分测试代码Linux 安装 openssl\nsudo apt install libssl-dev\n\nwin 下自行下载安装\nSMTP 协议简介SMTP 协议的定义1、SMTP 是一种 TCP 协议支持的提供可靠且有效电子邮件传输的应用层协议；2、SMTP 是建立在 TCP 上的一种邮件服务，主要用于传输系统之间的邮件信息并提供来信有关的通知；3、SMTP 独立于特定的传输子系统，且只需要可靠有序的数据流信道支持；4、SMTP 重要特性之一是其能跨越网络传输邮件，即“ SMTP 邮件中继”；5、SMTP 是一个相对简单的基于文本的协议。\nSMTP 基本命令 SMTP 基本命令包括以下几个：HELO﹑EHLO、MAIL﹑RCPT﹑DATA、AUTH LOGIN 和 QUIT1、HELO–发件方问候收件方，后面是发件人的服务器地址或标识。收件方回答 OK 时标识自己的身份。问候和确认过程表明两台机器可以进行通信，同时状态参量被复位，缓冲区被清空。EHLO–申明身份，表示自己身份需要验证，注意这部分需要通过 Telnet 验证一下，是&#117;&#x73;&#x65;&#114;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d; 还是 user，否则会出错。2、MAIL–这个命令用来开始传送邮件，它的后面跟随发件方邮件地址（返回邮件地址）。它也用来当邮件无法送达时，发送失败通知。为保证邮件的成功发送，发件方的地址应是被对方或中间转发方同意接受的。这个命令会清空有关的缓冲区，为新的邮件做准备。3、RCPT –这个命令告诉收件方收件人的邮箱。当有多个收件人时，需要多次使用该命令 RCPT4、TO，每次只能指明一个人。如果接收方服务器不同意转发这个地址的邮件，它必须报 550 错误代码通知发件方。如果服务器同意转发，它要更改邮件发送路径，把最开始的目的地（该服务器）换成下一个服务器。5、DATA–收件方把该命令之后的数据作为发送的数据。数据被加入数据缓冲区中，以单独一行是”.”的行结束数据。结束行对于接收方同时意味立即开始缓冲区内的数据传送，传送结束后清空缓冲区。如果传送接受，接收方回复 OK。6、QUIT–SMTP 要求接收放必须回答 OK，然后中断传输；在收到这个命令并回答 OK 前，收件方不得中断连接，即使传输出现错误。发件方在发出这个命令并收到 OK 答复前，也不得中断连接。7、AUTH LOGIN–登录邮箱，这一部分一般要用 base64 加密。\n头文件 mail.h#pragma once#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;openssl/ossl_typ.h&gt;#ifndef WIN32#include&lt;netdb.h&gt;#endifclass SmtpBase&#123;protected:    struct EmailInfo    &#123;        std::string smtpServer;      //the SMTP server        std::string serverPort;      //the SMTP server port        std::string charset;         //the email character set        std::string sender;          //the sender&#x27;s name        std::string senderEmail;     //the sender&#x27;s email        std::string password;        //the password of sender        std::string recipient;       //the recipient&#x27;s name        std::string recipientEmail;  //the recipient&#x27;s email        std::map&lt;std::string, std::string&gt; recvList; // 收件人列表 &lt;email, name&gt;        std::string subject;         //the email message&#x27;s subject  邮件主题        std::string message;         //the email message body   邮件内容        std::map&lt;std::string, std::string&gt; ccEmail;         // 抄送列表        std::vector&lt;std::string&gt; attachment; // 附件    &#125;;public:    virtual ~SmtpBase() &#123;&#125;    /**     * @brief 简单发送文本邮件     * @param   from 发送者的帐号     * @param   passs 发送者密码     * @param   to 收件人     * @param   subject 主题     * @param   strMessage  邮件内容     */    virtual int SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::string&amp; to, const std::string&amp; subject, const std::string&amp; strMessage) = 0;    /**     * @brief 发送邮件，包括附件以及抄送人和多个收件人     * @param   from 发送者的帐号     * @param   passs 发送者密码     * @param   vecTo 收件人列表     * @param   subject 主题     * @param   strMessage  邮件内容     * @param   attachment  附件列表    附件可以是绝对路径，默认是可执行程序目录下     * @param   ccList  抄送列表     */    virtual int SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::vector&lt;std::string&gt;&amp; vecTo,        const std::string&amp; subject, const std::string&amp; strMessage, const std::vector&lt;std::string&gt;&amp; attachment,const std::vector&lt;std::string&gt;&amp; ccList) = 0;    std::string GetLastError()    &#123;        return m_lastErrorMsg;    &#125;    virtual int Read(void* buf, int num) = 0;    virtual int Write(const void* buf, int num) = 0;    virtual int Connect() = 0;    virtual int DisConnect() = 0;protected:    std::string m_lastErrorMsg;&#125;;class SmtpEmail : public SmtpBase&#123;public:    SmtpEmail(const std::string&amp; emailHost, const std::string&amp; port);    ~SmtpEmail();    int SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::string&amp; to, const std::string&amp; subject, const std::string&amp; strMessage);    int SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::vector&lt;std::string&gt;&amp; vecTo,        const std::string&amp; subject, const std::string&amp; strMessage, const std::vector&lt;std::string&gt;&amp; attachment, const std::vector&lt;std::string&gt;&amp; ccList);protected:    int Read(void* buf, int num);    int Write(const void* buf, int num);    int Connect();    int DisConnect();    virtual std::string GetEmailBody(const EmailInfo &amp; info);private:    //int SMTPSSLComunicate(SSL *connection, const EmailInfo &amp;info);    int SMTPComunicate(const EmailInfo &amp;info);protected:    addrinfo* m_addrinfo;    int m_socketfd;    std::string m_host;    std::string m_port;    bool m_isConnected;&#125;;class SimpleSmtpEmail : public SmtpEmail&#123;public:    using SmtpEmail::SmtpEmail;    virtual std::string GetEmailBody(const EmailInfo &amp; info);&#125;;class SslSmtpEmail : public SmtpEmail&#123;public:    using SmtpEmail::SmtpEmail;    ~SslSmtpEmail();    int Connect();    int DisConnect();protected:    int Read(void* buf, int num);    int Write(const void* buf, int num);private:    SSL_CTX *m_ctx;    SSL *m_ssl;&#125;;class SimpleSslSmtpEmail : public SslSmtpEmail&#123;public:    using SslSmtpEmail::SslSmtpEmail;    virtual std::string GetEmailBody(const EmailInfo &amp; info);&#125;;\n\n\n实现文件 mail.cpp#ifdef WIN32#include &lt;WinSock2.h&gt;#endif#include &quot;mail.h&quot;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;openssl/err.h&gt;#include &lt;openssl/ssl.h&gt;#ifdef WIN32#include &lt;WinSock2.h&gt;#include &lt;WS2tcpip.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)#else #include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;#define INVALID_SOCKET -1#endiftemplate&lt;typename T&gt;std::string join(T&amp; vecData, const std::string&amp; delim)&#123;    if (vecData.size() &lt;= 0)    &#123;        return std::string();    &#125;    std::stringstream ss;    for (auto&amp; item : vecData)    &#123;        ss &lt;&lt; delim  &lt;&lt; item ;    &#125;    return ss.str().substr(delim.length());&#125;const char MimeTypes[][2][128] =&#123;    &#123; &quot;***&quot;,    &quot;application/octet-stream&quot; &#125;,    &#123; &quot;csv&quot;,    &quot;text/csv&quot; &#125;,    &#123; &quot;tsv&quot;,    &quot;text/tab-separated-values&quot; &#125;,    &#123; &quot;tab&quot;,    &quot;text/tab-separated-values&quot; &#125;,    &#123; &quot;html&quot;,    &quot;text/html&quot; &#125;,    &#123; &quot;htm&quot;,    &quot;text/html&quot; &#125;,    &#123; &quot;doc&quot;,    &quot;application/msword&quot; &#125;,    &#123; &quot;docx&quot;,    &quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot; &#125;,    &#123; &quot;ods&quot;,    &quot;application/x-vnd.oasis.opendocument.spreadsheet&quot; &#125;,    &#123; &quot;odt&quot;,    &quot;application/vnd.oasis.opendocument.text&quot; &#125;,    &#123; &quot;rtf&quot;,    &quot;application/rtf&quot; &#125;,    &#123; &quot;sxw&quot;,    &quot;application/vnd.sun.xml.writer&quot; &#125;,    &#123; &quot;txt&quot;,    &quot;text/plain&quot; &#125;,    &#123; &quot;xls&quot;,    &quot;application/vnd.ms-excel&quot; &#125;,    &#123; &quot;xlsx&quot;,    &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot; &#125;,    &#123; &quot;pdf&quot;,    &quot;application/pdf&quot; &#125;,    &#123; &quot;ppt&quot;,    &quot;application/vnd.ms-powerpoint&quot; &#125;,    &#123; &quot;pps&quot;,    &quot;application/vnd.ms-powerpoint&quot; &#125;,    &#123; &quot;pptx&quot;,    &quot;application/vnd.openxmlformats-officedocument.presentationml.presentation&quot; &#125;,    &#123; &quot;wmf&quot;,    &quot;image/x-wmf&quot; &#125;,    &#123; &quot;atom&quot;,    &quot;application/atom+xml&quot; &#125;,    &#123; &quot;xml&quot;,    &quot;application/xml&quot; &#125;,    &#123; &quot;json&quot;,    &quot;application/json&quot; &#125;,    &#123; &quot;js&quot;,    &quot;application/javascript&quot; &#125;,    &#123; &quot;ogg&quot;,    &quot;application/ogg&quot; &#125;,    &#123; &quot;ps&quot;,    &quot;application/postscript&quot; &#125;,    &#123; &quot;woff&quot;,    &quot;application/x-woff&quot; &#125;,    &#123; &quot;xhtml&quot;,&quot;application/xhtml+xml&quot; &#125;,    &#123; &quot;xht&quot;,    &quot;application/xhtml+xml&quot; &#125;,    &#123; &quot;zip&quot;,    &quot;application/zip&quot; &#125;,    &#123; &quot;gz&quot;,    &quot;application/x-gzip&quot; &#125;,    &#123; &quot;rar&quot;,    &quot;application/rar&quot; &#125;,    &#123; &quot;rm&quot;,    &quot;application/vnd.rn-realmedia&quot; &#125;,    &#123; &quot;rmvb&quot;,    &quot;application/vnd.rn-realmedia-vbr&quot; &#125;,    &#123; &quot;swf&quot;,    &quot;application/x-shockwave-flash&quot; &#125;,    &#123; &quot;au&quot;,        &quot;audio/basic&quot; &#125;,    &#123; &quot;snd&quot;,    &quot;audio/basic&quot; &#125;,    &#123; &quot;mid&quot;,    &quot;audio/mid&quot; &#125;,    &#123; &quot;rmi&quot;,        &quot;audio/mid&quot; &#125;,    &#123; &quot;mp3&quot;,    &quot;audio/mpeg&quot; &#125;,    &#123; &quot;aif&quot;,    &quot;audio/x-aiff&quot; &#125;,    &#123; &quot;aifc&quot;,    &quot;audio/x-aiff&quot; &#125;,    &#123; &quot;aiff&quot;,    &quot;audio/x-aiff&quot; &#125;,    &#123; &quot;m3u&quot;,    &quot;audio/x-mpegurl&quot; &#125;,    &#123; &quot;ra&quot;,    &quot;audio/vnd.rn-realaudio&quot; &#125;,    &#123; &quot;ram&quot;,    &quot;audio/vnd.rn-realaudio&quot; &#125;,    &#123; &quot;wav&quot;,    &quot;audio/x-wave&quot; &#125;,    &#123; &quot;wma&quot;,    &quot;audio/x-ms-wma&quot; &#125;,    &#123; &quot;m4a&quot;,    &quot;audio/x-m4a&quot; &#125;,    &#123; &quot;bmp&quot;,    &quot;image/bmp&quot; &#125;,    &#123; &quot;gif&quot;,    &quot;image/gif&quot; &#125;,    &#123; &quot;jpe&quot;,    &quot;image/jpeg&quot; &#125;,    &#123; &quot;jpeg&quot;,    &quot;image/jpeg&quot; &#125;,    &#123; &quot;jpg&quot;,    &quot;image/jpeg&quot; &#125;,    &#123; &quot;jfif&quot;,    &quot;image/jpeg&quot; &#125;,    &#123; &quot;png&quot;,    &quot;image/png&quot; &#125;,    &#123; &quot;svg&quot;,    &quot;image/svg+xml&quot; &#125;,    &#123; &quot;tif&quot;,    &quot;image/tiff&quot; &#125;,    &#123; &quot;tiff&quot;,    &quot;image/tiff&quot; &#125;,    &#123; &quot;ico&quot;,    &quot;image/vnd.microsoft.icon&quot; &#125;,    &#123; &quot;css&quot;,    &quot;text/css&quot; &#125;,    &#123; &quot;bas&quot;,    &quot;text/plain&quot; &#125;,    &#123; &quot;c&quot;,        &quot;text/plain&quot; &#125;,    &#123; &quot;h&quot;,        &quot;text/plain&quot; &#125;,    &#123; &quot;rtx&quot;,    &quot;text/richtext&quot; &#125;,    &#123; &quot;mp2&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpa&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpe&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpeg&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpg&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpv2&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mov&quot;,    &quot;video/quicktime&quot; &#125;,    &#123; &quot;qt&quot;,    &quot;video/quicktime&quot; &#125;,    &#123; &quot;lsf&quot;,    &quot;video/x-la-asf&quot; &#125;,    &#123; &quot;lsx&quot;,    &quot;video/x-la-asf&quot; &#125;,    &#123; &quot;asf&quot;,    &quot;video/x-ms-asf&quot; &#125;,    &#123; &quot;asr&quot;,    &quot;video/x-ms-asf&quot; &#125;,    &#123; &quot;asx&quot;,    &quot;video/x-ms-asf&quot; &#125;,    &#123; &quot;avi&quot;,    &quot;video/x-msvideo&quot; &#125;,    &#123; &quot;3gp&quot;,    &quot;video/3gpp&quot; &#125;,    &#123; &quot;3gpp&quot;,    &quot;video/3gpp&quot; &#125;,    &#123; &quot;3g2&quot;,    &quot;video/3gpp2&quot; &#125;,    &#123; &quot;movie&quot;,&quot;video/x-sgi-movie&quot; &#125;,    &#123; &quot;mp4&quot;,    &quot;video/mp4&quot; &#125;,    &#123; &quot;wmv&quot;,    &quot;video/x-ms-wmv&quot; &#125;,    &#123; &quot;webm&quot;,&quot;video/webm&quot; &#125;,    &#123; &quot;m4v&quot;,    &quot;video/x-m4v&quot; &#125;,    &#123; &quot;flv&quot;,    &quot;video/x-flv&quot; &#125;&#125;;std::string fileBasename(const std::string path) &#123;    std::string filename = path.substr(path.find_last_of(&quot;/\\\\&quot;) + 1);// 解析出文件名字    return filename;&#125;std::string getFileContents(const char *filename)&#123;    std::ifstream in(filename, std::ios::in | std::ios::binary);    if (in)    &#123;        std::string contents;        in.seekg(0, std::ios::end);        contents.resize(in.tellg());        in.seekg(0, std::ios::beg);        in.read(&amp;contents[0], contents.size());        in.close();        return(contents);    &#125;    else &#123;        printf(&quot; 文件读取失败:%s\\n&quot;,filename);        return &quot;&quot;;    &#125;&#125;// 获取文件的后缀名 如 xxx.jpg 获取的是 jpgstd::string GetFileExtension(const std::string&amp; FileName)&#123;    if (FileName.find_last_of(&quot;.&quot;) != std::string::npos)        //find_last_of 逆向查找在原字符串中最后一个与指定字符串（或字符）中的某个字符匹配的字符，返回它的位置。若查找失败，则返回 npos。        return FileName.substr(FileName.find_last_of(&quot;.&quot;) + 1);    return &quot;&quot;;&#125;const char* GetMimeTypeFromFileName(char* szFileExt)&#123;    for (unsigned int i = 0; i &lt; sizeof(MimeTypes) / sizeof(MimeTypes[0]); i++)    &#123;        if (strcmp(MimeTypes[i][0], szFileExt) == 0)        &#123;            return MimeTypes[i][1];        &#125;    &#125;    return MimeTypes[0][1];   //if does not match any,  &quot;application/octet-stream&quot; is returned&#125;char* base64Encode(char const* origSigned, unsigned origLength)&#123;    static const char base64Char[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;    unsigned char const* orig = (unsigned char const*)origSigned; // in case any input bytes have the MSB set    if (orig == NULL) return NULL;    unsigned const numOrig24BitValues = origLength / 3;    bool havePadding = origLength &gt; numOrig24BitValues * 3;    bool havePadding2 = origLength == numOrig24BitValues * 3 + 2;    unsigned const numResultBytes = 4 * (numOrig24BitValues + havePadding);    char* result = new char[numResultBytes + 3]; // allow for trailing &#x27;/0&#x27;    // Map each full group of 3 input bytes into 4 output base-64 characters:    unsigned i;    for (i = 0; i &lt; numOrig24BitValues; ++i)    &#123;        result[4 * i + 0] = base64Char[(orig[3 * i] &gt;&gt; 2) &amp; 0x3F];        result[4 * i + 1] = base64Char[(((orig[3 * i] &amp; 0x3) &lt;&lt; 4) | (orig[3 * i + 1] &gt;&gt; 4)) &amp; 0x3F];        result[4 * i + 2] = base64Char[((orig[3 * i + 1] &lt;&lt; 2) | (orig[3 * i + 2] &gt;&gt; 6)) &amp; 0x3F];        result[4 * i + 3] = base64Char[orig[3 * i + 2] &amp; 0x3F];    &#125;    // Now, take padding into account.  (Note: i == numOrig24BitValues)    if (havePadding)    &#123;        result[4 * i + 0] = base64Char[(orig[3 * i] &gt;&gt; 2) &amp; 0x3F];        if (havePadding2)        &#123;            result[4 * i + 1] = base64Char[(((orig[3 * i] &amp; 0x3) &lt;&lt; 4) | (orig[3 * i + 1] &gt;&gt; 4)) &amp; 0x3F];            result[4 * i + 2] = base64Char[(orig[3 * i + 1] &lt;&lt; 2) &amp; 0x3F];        &#125;        else        &#123;            result[4 * i + 1] = base64Char[((orig[3 * i] &amp; 0x3) &lt;&lt; 4) &amp; 0x3F];            result[4 * i + 2] = &#x27;=&#x27;;        &#125;        result[4 * i + 3] = &#x27;=&#x27;;    &#125;    result[numResultBytes] = &#x27;\\0&#x27;;    return result;&#125;int SmtpEmail::SMTPComunicate(const EmailInfo &amp;info)&#123;    if (Connect() != 0)    &#123;        return -1;    &#125;    char * buffer = new char[1000];    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;220&quot;, 3) != 0) // not equal to 220    &#123;        m_lastErrorMsg = buffer;        return 220;    &#125;    // 向服务器发送 ehlo    std::string command = &quot;ehlo EmailService\\r\\n&quot;;    Write(command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;250&quot;, 3) != 0) // ehlo failed    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    // 进行登录验证    command = &quot;AUTH PLAIN &quot;;    std::string auth = &#x27;\\0&#x27; + info.senderEmail + &#x27;\\0&#x27; + info.password;    command += base64Encode(auth.data(), auth.size());    command += &quot;\\r\\n&quot;;    Write(command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;235&quot;, 3) != 0) // login failed    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    // 设置邮件发送者的邮箱地址    command = &quot;mail FROM:&lt;&quot; + info.senderEmail + &quot;&gt;\\r\\n&quot;;    Write(command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;250&quot;, 3) != 0) // not ok    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    // 设置邮件接收者的邮箱地址    command = &quot;RCPT TO:&lt;&quot; + info.recipientEmail + &quot;&gt;\\r\\n&quot;;    Write(command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;250&quot;, 3) != 0) // not ok    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    // 准备发送邮件    command = &quot;data\\r\\n&quot;;    Write(command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;354&quot;, 3) != 0) // not ready to receive message    &#123;        m_lastErrorMsg = buffer;        return 354;    &#125;    command = std::move(GetEmailBody(info));    Write(command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;250&quot;, 3) != 0) // not ok    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    // 结束发送过程    delete buffer;    Write(&quot;quit\\r\\n&quot;, 6);    DisConnect();    return 0;&#125;std::string SmtpEmail::GetEmailBody(const EmailInfo &amp;info)&#123;    // 设定邮件的发送者名称、接收者名称、邮件主题，邮件内容。    std::ostringstream message;    message &lt;&lt; &quot;From: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.sender.c_str(), info.sender.length()) &lt;&lt; &quot;?= &lt;&quot; &lt;&lt; info.senderEmail &lt;&lt; &quot;&gt;\\r\\n&quot;;    std::vector&lt;std::string&gt; vecToList;    for (auto item : info.recvList)    &#123;        std::string to = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.second.c_str(), item.second.length()) + &quot;?= &lt;&quot; + item.first + &quot;&gt;&quot;;        vecToList.push_back(to);    &#125;    message &lt;&lt; &quot;To: &quot; &lt;&lt; join(vecToList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    message &lt;&lt; &quot;Subject: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.subject.c_str(), info.subject.length()) &lt;&lt; &quot;?=\\r\\n&quot;;    message &lt;&lt; &quot;MIME-Version: 1.0\\r\\n&quot;;    if (info.ccEmail.size() &gt; 0)    &#123;        std::vector&lt;std::string&gt; vecCcList;        for (auto item : info.ccEmail)        &#123;            std::string cc = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.first.c_str(), item.first.length()) + &quot;?= &lt;&quot; + item.second + &quot;&gt;&quot;;            vecCcList.push_back(cc);        &#125;        message &lt;&lt; &quot;Cc:&quot; &lt;&lt; join(vecCcList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    &#125;    message &lt;&lt; &quot;Content-Type:multipart/mixed; boundary=\\&quot;Separator_ztq_000\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: multipart/alternative; boundary=\\&quot;Separator_ztq_111\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; &quot;text/plain&quot; &lt;&lt; &quot;; charset=\\&quot;&quot; &lt;&lt; info.charset &lt;&lt; &quot;\\&quot;\\r\\n&quot;;    message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;    message &lt;&lt; &quot;\\r\\n&quot;;                  // 此处要加，不然邮件正文无内容    message &lt;&lt; base64Encode(info.message.c_str(), info.message.length());    message &lt;&lt; &quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111--\\r\\n&quot;;    //--------------------- 文件部分处理 --------------------------------------    for (auto item : info.attachment)    &#123;        std::string filename = fileBasename(item);        std::string strContext = getFileContents(item.c_str());        if(strContext.empty())        &#123;            std::cerr &lt;&lt; &quot; 请检查传入的文件路径是否正确, 此路径文件添加到附件失败，不发送此文件:&quot; &lt;&lt; std::endl;            std::cerr &lt;&lt; item &lt;&lt; std::endl;        &#125;        else        &#123;            std::string fileContext = base64Encode(strContext.c_str(), strContext.length());            std::string extension = GetFileExtension(filename);            std::string mimetype = GetMimeTypeFromFileName((char*)extension.c_str());            message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;            message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; mimetype &lt;&lt; &quot;; name=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n&quot;;            message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;            message &lt;&lt; &quot;Content-Disposition: attachment; filename=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n\\r\\n&quot;;            message &lt;&lt; fileContext + &quot;\\r\\n\\r\\n&quot;;        // 把读取到的文件内容以二进制形式发送        &#125;    &#125;    //-----------------------------------------------------------    message &lt;&lt; &quot;\\r\\n.\\r\\n&quot;;    return message.str();&#125;SmtpEmail::SmtpEmail(const std::string&amp; emailHost, const std::string&amp; port) :m_host(emailHost), m_port(port)&#123;&#125;SmtpEmail::~SmtpEmail()&#123;&#125;int SmtpEmail::Read(void* buf, int num)&#123;    return recv(m_socketfd, (char*)buf, num, 0);&#125;int SmtpEmail::Write(const void* buf, int num)&#123;    return send(m_socketfd, (char*)buf, num, 0);&#125;int SmtpEmail::Connect()&#123;#ifdef WIN32    //start socket connection    WSADATA wsadata;    WSAStartup(MAKEWORD(2, 2), &amp;wsadata);#endif    m_socketfd = socket(AF_INET, SOCK_STREAM, 0);    if (m_socketfd == INVALID_SOCKET)    &#123;        m_lastErrorMsg = &quot;Error on creating socket fd.&quot;;        return -1;    &#125;    addrinfo inAddrInfo = &#123; 0 &#125;;    inAddrInfo.ai_family = AF_INET;    inAddrInfo.ai_socktype = SOCK_STREAM;    printf(&quot;host:%s port:%s \\n&quot;,m_host.c_str(), m_port.c_str());    if (getaddrinfo(m_host.c_str(), m_port.c_str(), &amp;inAddrInfo, &amp;m_addrinfo) != 0) // error occurs    &#123;        m_lastErrorMsg = &quot;Error on calling getadrrinfo().&quot;;        return -2;    &#125;    if (connect(m_socketfd, m_addrinfo-&gt;ai_addr, m_addrinfo-&gt;ai_addrlen))    &#123;        m_lastErrorMsg = &quot;Error on calling connect().&quot;;        return -3;    &#125;    return 0;&#125;int SmtpEmail::DisConnect()&#123;    freeaddrinfo(m_addrinfo);#ifdef WIN32    closesocket(m_socketfd);#else    close(m_socketfd);#endif    return 0;&#125;/*********************************************************************************/std::string SimpleSmtpEmail::GetEmailBody(const EmailInfo &amp;info)&#123;    // 设定邮件的发送者名称、接收者名称、邮件主题，邮件内容。    std::ostringstream message;    message &lt;&lt; &quot;From: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.sender.c_str(), info.sender.length()) &lt;&lt; &quot;?= &lt;&quot; &lt;&lt; info.senderEmail &lt;&lt; &quot;&gt;\\r\\n&quot;;    std::vector&lt;std::string&gt; vecToList;    for (auto item : info.recvList)    &#123;        std::string to = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.second.c_str(), item.second.length()) + &quot;?= &lt;&quot; + item.first + &quot;&gt;&quot;;        vecToList.push_back(to);    &#125;    message &lt;&lt; &quot;To: &quot; &lt;&lt; join(vecToList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    message &lt;&lt; &quot;Subject: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.subject.c_str(), info.subject.length()) &lt;&lt; &quot;?=\\r\\n&quot;;    message &lt;&lt; &quot;MIME-Version: 1.0\\r\\n&quot;;    if (info.ccEmail.size() &gt; 0)    &#123;        std::vector&lt;std::string&gt; vecCcList;        for (auto item : info.ccEmail)        &#123;            std::string cc = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.first.c_str(), item.first.length()) + &quot;?= &lt;&quot; + item.second + &quot;&gt;&quot;;            vecCcList.push_back(cc);        &#125;        message &lt;&lt; &quot;Cc:&quot; &lt;&lt; join(vecCcList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    &#125;    message &lt;&lt; &quot;Content-Type:multipart/mixed; boundary=\\&quot;Separator_ztq_000\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: multipart/alternative; boundary=\\&quot;Separator_ztq_111\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; &quot;text/plain&quot; &lt;&lt; &quot;; charset=\\&quot;&quot; &lt;&lt; info.charset &lt;&lt; &quot;\\&quot;\\r\\n&quot;;    message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;    message &lt;&lt; &quot;\\r\\n&quot;;                  // 此处要加，不然邮件正文无内容    message &lt;&lt; base64Encode(info.message.c_str(), info.message.length());    message &lt;&lt; &quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111--\\r\\n&quot;;    //--------------------- 文件部分处理 --------------------------------------    for (auto item : info.attachment)    &#123;        std::string filename = fileBasename(item);        std::string strContext = getFileContents(item.c_str());        if(strContext.empty())        &#123;            std::cerr &lt;&lt; &quot; 请检查传入的文件路径是否正确, 此路径文件添加到附件失败，不发送此文件:&quot; &lt;&lt; std::endl;            std::cerr &lt;&lt; item &lt;&lt; std::endl;        &#125;        else        &#123;            std::string fileContext = base64Encode(strContext.c_str(), strContext.length());            std::string extension = GetFileExtension(filename);            std::string mimetype = GetMimeTypeFromFileName((char*)extension.c_str());            message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;            message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; mimetype &lt;&lt; &quot;; name=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n&quot;;            message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;            message &lt;&lt; &quot;Content-Disposition: attachment; filename=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n\\r\\n&quot;;            message &lt;&lt; fileContext + &quot;\\r\\n\\r\\n&quot;;        // 把读取到的文件内容以二进制形式发送        &#125;    &#125;    //-----------------------------------------------------------    message &lt;&lt; &quot;\\r\\n.\\r\\n&quot;;    return message.str();&#125;/***************************************************************************************************/SslSmtpEmail::~SslSmtpEmail()&#123;&#125;int SslSmtpEmail::Connect()&#123;    if (SmtpEmail::Connect() == 0)    &#123;        SSL_library_init();        OpenSSL_add_all_algorithms();        SSL_load_error_strings();        m_ctx = SSL_CTX_new(SSLv23_client_method());        m_ssl = SSL_new(m_ctx);        SSL_set_fd(m_ssl, m_socketfd);        SSL_connect(m_ssl);    &#125;    return 0;&#125;int SslSmtpEmail::DisConnect()&#123;    SSL_shutdown(m_ssl);    SSL_free(m_ssl);    SSL_CTX_free(m_ctx);    SmtpEmail::DisConnect();    return 0;&#125;int SmtpEmail::SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::string&amp; to, const std::string&amp; subject, const std::string&amp; strMessage)&#123;    EmailInfo info;    info.charset = &quot;UTF-8&quot;;    info.sender = from;    info.password = passs;    info.senderEmail = from;    info.recipientEmail = to;    info.recvList[to] = &quot;&quot;;    info.subject = subject;    info.message = strMessage;    return SMTPComunicate(info);&#125;int SmtpEmail::SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::vector&lt;std::string&gt;&amp; vecTo,                         const std::string&amp; subject, const std::string&amp; strMessage, const std::vector&lt;std::string&gt;&amp; attachment, const std::vector&lt;std::string&gt;&amp; ccList)&#123;    std::vector&lt;std::string&gt; recvList;    recvList.insert(recvList.end(), vecTo.begin(), vecTo.end());    recvList.insert(recvList.end(), ccList.begin(), ccList.end());    for (auto&amp; item : recvList)    &#123;        EmailInfo info;        info.charset = &quot;UTF-8&quot;;        info.sender = from;        info.password = passs;        info.senderEmail = from;;        info.recipientEmail = item;        for (auto item : vecTo)        &#123;            info.recvList[item] = &quot;&quot;;        &#125;        info.subject = subject;        info.message = strMessage;        for (auto&amp; item : ccList)        &#123;            info.ccEmail[item] = item;        &#125;        info.attachment = attachment;        if (SMTPComunicate(info) != 0)        &#123;            return -1;        &#125;    &#125;    return 0;&#125;int SslSmtpEmail::Read(void * buf, int num)&#123;    int ret = SSL_read(m_ssl, buf, num);    return ret;&#125;int SslSmtpEmail::Write(const void * buf, int num)&#123;    return SSL_write(m_ssl, buf, num);&#125;std::string SimpleSslSmtpEmail::GetEmailBody(const EmailInfo &amp;info)&#123;    // 设定邮件的发送者名称、接收者名称、邮件主题，邮件内容。    std::ostringstream message;    message &lt;&lt; &quot;From: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.sender.c_str(), info.sender.length()) &lt;&lt; &quot;?= &lt;&quot; &lt;&lt; info.senderEmail &lt;&lt; &quot;&gt;\\r\\n&quot;;    std::vector&lt;std::string&gt; vecToList;    for (auto item : info.recvList)    &#123;        std::string to = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.second.c_str(), item.second.length()) + &quot;?= &lt;&quot; + item.first + &quot;&gt;&quot;;        vecToList.push_back(to);    &#125;    message &lt;&lt; &quot;To: &quot; &lt;&lt; join(vecToList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    message &lt;&lt; &quot;Subject: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.subject.c_str(), info.subject.length()) &lt;&lt; &quot;?=\\r\\n&quot;;    message &lt;&lt; &quot;MIME-Version: 1.0\\r\\n&quot;;    if (info.ccEmail.size() &gt; 0)    &#123;        std::vector&lt;std::string&gt; vecCcList;        for (auto item : info.ccEmail)        &#123;            std::string cc = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.first.c_str(), item.first.length()) + &quot;?= &lt;&quot; + item.second + &quot;&gt;&quot;;            vecCcList.push_back(cc);        &#125;        message &lt;&lt; &quot;Cc:&quot; &lt;&lt; join(vecCcList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    &#125;    message &lt;&lt; &quot;Content-Type:multipart/mixed; boundary=\\&quot;Separator_ztq_000\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: multipart/alternative; boundary=\\&quot;Separator_ztq_111\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; &quot;text/plain&quot; &lt;&lt; &quot;; charset=\\&quot;&quot; &lt;&lt; info.charset &lt;&lt; &quot;\\&quot;\\r\\n&quot;;    message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;    message &lt;&lt; &quot;\\r\\n&quot;;                  // 此处要加，不然邮件正文无内容    message &lt;&lt; base64Encode(info.message.c_str(), info.message.length());    message &lt;&lt; &quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111--\\r\\n&quot;;    //--------------------- 文件部分处理 --------------------------------------    for (auto item : info.attachment)    &#123;        std::string filename = fileBasename(item);        std::string strContext = getFileContents(item.c_str());        if(strContext.empty())        &#123;            std::cerr &lt;&lt; &quot; 请检查传入的文件路径是否正确, 此路径文件添加到附件失败，不发送此文件:&quot; &lt;&lt; std::endl;            std::cerr &lt;&lt; item &lt;&lt; std::endl;        &#125;        else        &#123;            std::string fileContext = base64Encode(strContext.c_str(), strContext.length());            std::string extension = GetFileExtension(filename);            std::string mimetype = GetMimeTypeFromFileName((char*)extension.c_str());            message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;            message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; mimetype &lt;&lt; &quot;; name=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n&quot;;            message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;            message &lt;&lt; &quot;Content-Disposition: attachment; filename=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n\\r\\n&quot;;            message &lt;&lt; fileContext + &quot;\\r\\n\\r\\n&quot;;        // 把读取到的文件内容以二进制形式发送        &#125;    &#125;    //-----------------------------------------------------------    message &lt;&lt; &quot;\\r\\n.\\r\\n&quot;;    return message.str();&#125;\n\n\n测试代码 main.cppSendEmail函数重载，支持基本的简单发送文本邮件，和支持附件、抄送、以及发给多人的发送方式，亲测能够发送成功，默认发送的编码是 utf-8 格式\n#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &quot;mail.h&quot;int main()&#123;    std::string from = &quot;xxxx@163.com&quot;;    std::string passs =&quot;xxxxx&quot;;// 这里替换成自己的授权码    std::string to = &quot;xxx@126.com&quot;;    std::string subject = &quot;hello&quot;;    std::string strMessage = &quot;test&quot;;    std::vector&lt;std::string&gt; vecTo; // 发送列表    vecTo.push_back(&quot;xxx@126.com&quot;);    std::vector&lt;std::string&gt; ccList;    // ccList.push_back(&quot;xxx@xxx.com.cn&quot;);// 抄送列表    std::vector&lt;std::string&gt; attachment;    attachment.push_back(&quot;mail.h&quot;);    attachment.push_back(&quot;/home/soft/Desktop/openwrt-sdk-imx6ul/1/mybuild.sh&quot;);    SmtpBase *base;    SimpleSmtpEmail m_mail(&quot;smtp.163.com&quot;,&quot;25&quot;);    base = &amp;m_mail;    //base-&gt;SendEmail(from, passs, to, subject, strMessage);// 普通的文本发送，明文发送    SimpleSslSmtpEmail m_ssl_mail(&quot;smtp.163.com&quot;,&quot;465&quot;);    base=&amp;m_ssl_mail;    //base-&gt;SendEmail(from, passs, to, subject, strMessage);    base-&gt;SendEmail(from, passs,vecTo,subject,strMessage,attachment,ccList);// 加密的发送，支持抄送、附件等    return 0;&#125;\n\n邮箱收件箱  查看邮件头  \n实际收到的邮件 \n\n参考链接C++ 基于 Smtp 协议发送邮件SMTP 基本原理与 C++ 实现向多人发送邮件\n后记  如果您觉得有帮助的话，请点个赞吧！有问题请留言评论，欢迎指出意见，谢谢。\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++11】future 和 async 等","url":"/posts/2885143113/","content":"C++11 的 future 和 async 等关键字\n\n\n1.async 和 future 的概念std::async 和 std::future 是 C++11 引入的标准库功能，用于实现异步编程，使得在多线程环境中更容易处理并行任务。它们可以帮助你在不同线程中执行函数，并且能够方便地获取函数的结果。\n在之前使用线程的时候，我们没有办法很好的获取到线程所执行函数的返回值。甚至更多时候，我们使用线程执行的都是不关心返回值的函数。如果真的想要获取线程函数的返回值，可以将一个指针作为输出型参数放入线程所执行的函数中。主执行流执行 t.join() 等待线程执行结束，并获取到这个返回值。\n但这样并不是非常方便。于是 C++11 就引入了如上两个关键字来帮助我们获取到线程所执行函数的返回值。适用于异步执行某些耗时的函数，提高程序运行的效率：\n\n异步执行耗时函数\n主执行流干其他事情\n通过 std::future 获取到返回值\n继续向后执行\n\n基本的并行概念在多线程部分都已经讲过了，这里就不多 bb，直接上代码吧！\n2. 使用 2.1 std::launch 在使用 std::async 之前，还需要认识一个枚举类型 launch，在使用 std::async 的函数传参的时候会用到（这里先说一下，std::async是用来帮我们创建线程的）\nenum class launch; // std::launch\n\n在 cplusplus网站上，有这个枚举类型的释义，这里面只有俩值\n\n说一下这俩值的区别\n\nlaunch::async，立即创建一个线程来执行目标函数\nlaunch::deferred，不立即创建线程，而是等待调用 std::future 的get()函数时才调用（这个 get 函数是用来获取返回值的）\n\n好了知道这个就够了哈！\n2.2 std::result_of这里还出现了另外一个关键字，就顺带也说说是干嘛的（其实我自己也不知道，现学现卖）\n#include &lt;type_traits&gt; // 头文件template &lt;class Fn&gt;struct result_of;template &lt;class Fn, class... ArgTypes&gt;struct result_of&lt;Fn(ArgTypes...)&gt;;\n\n以下是 std::result_of 的基本用法和概念：\n\n使用 std::result_of 获取函数调用的返回类型： 你可以通过将函数类型和参数类型传递给 std::result_of 来推导函数调用的返回类型。这使得你可以在编译时获取函数调用的结果类型，而不需要手动指定它。\n用法示例： 假设有一个函数 int add(int a, int b)，你可以使用 std::result_of 来获取该函数在给定参数下的返回类型。\n\n#include &lt;iostream&gt;#include &lt;type_traits&gt;int add(int a, int b)&#123;    return a + b;&#125;int main()&#123;    std::result_of&lt;decltype(add) &amp;(int, int)&gt;::type result = add(3, 5);    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;\n\n运行结果如下\n$ g++ test.cpp -o test -std=c++11$ ./testResult: 8\n\n需要注意的是，使用 decltype 关键字来指定函数指针的时候，函数名和函数参数之间需要加上&amp;，否则无法正确推导类型\ndecltype(add) &amp;(int, int) // 正确decltype(add) (int, int) // 错误    \n\n2.3 async先来看看 async 函数的样本，第一个情况是不显示传入 std::launch，第二个函数重载是传入了 std::launch 作为启动策略\n#include &lt;future&gt; // 头文件// unspecified policy (1)\ttemplate &lt;class Fn, class... Args&gt;  future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;    async (Fn&amp;&amp; fn, Args&amp;&amp;... args);// specific policy (2)\ttemplate &lt;class Fn, class... Args&gt;  future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;    async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);\n\n在 cplusplus 网站上，说到了第一种情况是由编译器  自主决定  到底是采用 std::launch::async 或 std::launch::deferred，这就需要根据平台和编译器实现以及调用逻辑的不同来具体分析了。所以不建议使用第一个，还是直接指定launch policy（翻译过来是启动策略）的会好一点。\n所以只看第二个👇\ntemplate &lt;class Fn, class... Args&gt;  future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;    async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);\n\n这里采用了可变模板参数来接收多个函数参数，类似于可变参数列表。这里还使用了 typename 关键字来告知编译器 result_of&lt;Fn(Args...)&gt;::type 是一个参数类型，需要在模板实例化了之后再去获取确定的类型。而 class Fn 是一个函数指针的模板变量。\n\n第一个参数是std::launch，上文已经提到过两个不同选项的区别了\n第二个参数是函数，直接丢函数名就可以了\n第三个参数是这个函数的参数，也是直接丢参数就可以了\n\n如下是一个简单的调用示例（并非完整示例）\n#include &lt;future&gt; // 头文件// 函数int add(int a, int b) &#123;    return a + b;&#125;// 调用std::async(std::launch::async, add, 3, 5);\n\n调用了这个函数后，CPP 会帮我们创建一个线程来执行函数，并根据第一个启动参数的不同，决定啥时候创建这个线程。最终我们可以通过 future 获取到线程执行函数的返回值。\n2.4 future人如其名，这个类型是用来声明一个  未来  的变量的。因为 std::async 会帮我们创建一个线程来执行函数，此时该线程函数的返回值是未知的，这个未来变量就是提前的一个声明，当线程执行完毕函数并返回值的时候，这个变量的值才真正被初始化为我们真正需要的那个值。\ntemplate &lt;class T&gt;  future;// specialization : T is a reference type (R&amp;)template &lt;class R&amp;&gt; future&lt;R&amp;&gt;;     // specialization : T is voidtemplate &lt;&gt;         future&lt;void&gt;;  \n\n其有如下几个成员函数\n\nget：获取对应 async 所执行函数的返回值，如果函数没有执行完毕则阻塞等待\nvalid：bool，判断当前 future 类型到底有没有和一个 async 函数所对应\nshare：将 future 对象转成一个 std::shared_future 对象\nwait：等待异步任务完成，但不获取结果\nwait_for：等待异步任务完成，但有等待的时长（没等到就返回错误）\nwait_until：等待异步任务完成，直到一个确定的时间（没等到就返回错误）\n\n后面三个 wait 函数和 CPP 线程中的 wait 函数如出一辙。\n2.5 share_futureshare_future就好比 share_ptr 智能指针，其让 future 对象从单一所有权变成了  多人可用。本来是一个只能坐一人的餐桌，现在变成了可以坐很多人的大桌子。\ntemplate &lt;class T&gt;  shared_future;template &lt;class R&amp;&gt; shared_future&lt;R&amp;&gt;;   // specialization : T is a reference type (R&amp;)template &lt;&gt;         shared_future&lt;void&gt;; // specialization : T is void\n\n成员函数和 future 完全一样（只不过么有 share() 函数）这里就不赘述了；\n\nfuture是单人餐桌，一次只能有一个线程执行 get 函数；当 get 被执行后，这个 future 会  失效。\nshare_future是大桌子，所有人一起坐在这个桌子上等服务员上菜，互不干扰；\n\n当一个函数的返回值需要在多个线程中被共享使用的时候，就可以用 shared_future 了。\n2.5 测试 2.5.1 正常测试 如下代码是一个简单的使用示例，并且通过提供不同的 std::launch 启动策略，我们也能观察到不同的现象\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;type_traits&gt; // result_of#include &lt;sys/unistd.h&gt; //sleepint add(int a, int b)&#123;    std::cout &lt;&lt; &quot;Add  Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Sleeping before add...&quot; &lt;&lt; std::endl;    sleep(4);    return a + b;&#125;int main() &#123;    std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Start&quot; &lt;&lt; std::endl;    //std::future&lt;int&gt; futureResult = std::async(std::launch::deferred, add, 3, 5);  // deferred 不会创建新线程    std::future&lt;int&gt; futureResult = std::async(std::launch::async, add, 3, 5); // 创建新线程    sleep(3);     std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Waiting for result...&quot; &lt;&lt; std::endl;    int result = futureResult.get();  // 等待异步任务完成并获取结果    std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    sleep(3);        return 0;&#125;\n\n如果使用 std::launch::async 作为启动策略，可以看到，执行 add 函数的线程 id 和主线程的 id 是不同的，通过 linux 下的 ps -aL 命令也能观察到出现两个线程。可以用如下脚本来实时监控线程状态。\nwhile :; do ps jax | head -1 &amp;&amp; ps -aL |  grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\nstd::launch::async下程序执行的输出结果\nMain Thread 139869475694400 | StartAdd  Thread 139869457655552 | Sleeping before add...Main Thread 139869475694400 | Waiting for result...Main Thread 139869475694400 | Result: 8\n\n如果使用 std::launch::deferred 作为启动策略，则会发现这两个线程的 id 是完全相同的，这代表实际上其执行了并行的策略，程序就是在主执行流上面运行的，并没有新开一个线程来执行。这也符合 deferred 作为“延迟运行”的特性。\nMain Thread 139789724776256 | StartMain Thread 139789724776256 | Waiting for result...Add  Thread 139789724776256 | Sleeping before add...Main Thread 139789724776256 | Result: 8\n\n2.5.2 多线程 get 一个 future在如下代码中，我写了一个 void future_get_func(std::future&lt;int&gt;&amp; fu) 的函数，尝试开一个线程来 get，然后主执行流又 get 一次，看看会发生什么。\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;thread&gt;#include &lt;type_traits&gt; // result_of#include &lt;sys/unistd.h&gt; // sleepint add(int a, int b)&#123;    std::cout &lt;&lt; &quot;Add  Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Sleeping before add...&quot; &lt;&lt; std::endl;    sleep(4);    return a + b;&#125;void future_get_func_shared(std::shared_future&lt;int&gt;&amp; fu)&#123;    int result = fu.get();  // 等待异步任务完成并获取结果    std::cout &lt;&lt; &quot;Func Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    sleep(2);&#125;void future_get_func(std::future&lt;int&gt;&amp; fu)&#123;    int result = fu.get();  // 等待异步任务完成并获取结果    std::cout &lt;&lt; &quot;Func Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    sleep(2);&#125;int main() &#123;    std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Start&quot; &lt;&lt; std::endl;    //std::future&lt;int&gt; futureResult = std::async(std::launch::deferred, add, 3, 5); // 不会创建新线程    std::future&lt;int&gt; futureResult = std::async(std::launch::async, add, 3, 5); // 创建新线程    sleep(3);     std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Waiting for result...&quot; &lt;&lt; std::endl;        // 尝试测试多线程 get 会发生什么        std::thread t1(future_get_func, std::ref(futureResult)); // 开个线程来 get    t1.detach(); // 直接分离线程    sleep(1);    int result = futureResult.get();  // 等待异步任务完成并获取结果    std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    sleep(3);        return 0;&#125;\n\n需要注意的是，如下创建线程的传参必须要用 std::ref 包裹，来告知线程这是一个引用对象，否则编译会报错。因为 std::thread 要求参数可以在  构造函数中被调用，而 std::future 并不能直接传递给 std::thread；\nstd::thread t1(future_get_func, std::ref(futureResult)); // 正确std::thread t1(future_get_func, futureResult); // 错误\n\n编译通过后执行，会发现跑出来了一个 std::future_error 异常，代表我们在一个无效的 future 上调用了 get 函数。\nMain Thread 139869577889600 | StartAdd  Thread 139869559850752 | Sleeping before add...Main Thread 139869577889600 | Waiting for result...Func Thread 139869551458048 | Result: 8terminate called after throwing an instance of &#x27;std::future_error&#x27;  what():  std::future_error: No associated stateAborted\n\n记住了，std::future在调用了一次 get 之后将不再与对应的 std::async 关联，所以才会需要 share_future 的出现！\n改成 share_future 再执行上面这套逻辑，就会发现成功跑起来了。\nMain Thread 140369883957056 | StartAdd  Thread 140369865918208 | Sleeping before add...Main Thread 140369883957056 | Waiting for result...Func Thread 140369857525504 | Result: 8Main Thread 140369883957056 | Result: 8\n\n2.5.3 异常处理int add(int a, int b)&#123;    std::cout &lt;&lt; &quot;Add  Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Sleeping before add...&quot; &lt;&lt; std::endl;    sleep(4);    throw std::runtime_error(&quot;An error occurred&quot;);    return a + b;&#125;\n\n如果 async 执行的函数中抛出了异常，那么这个异常将会被传回主执行流，可以在主执行流中被处理。而如果直接使用线程来执行这个函数，其异常不会被捕捉，而是会导致整个进程退出。\n下图，使用 async 运行，成功打印出异常（捕获成功）\n\n下图，使用线程运行，进程退出\n\n2.6 launch::deferred 的真正意义  如果 std::launch::deferred 是同步执行，这样写不是多此一举吗？为什么不直接在需要的地方调用函数，而是使用 async？\nNONONO 非也非也，和直接调用 Add 函数相比，用 async+deferred 策略这样的方式调用 Add 函数还是有些区别的：\n\n推迟执行：直接调用 Add 函数是立马执行，但是用 async 可以推迟到调用 get 的时候才执行\n延迟计算：有的时候我们并不是需要立马使用这个函数的返回值，所以就可以延迟一会再执行这个函数，先把函数的调用搞起来，后面只需要一个 get 就能获取到结果了（避免两个部位之间的代码较长，后续找不到我们需要的那两个变量的名字了）\n避免线程创建：并不是什么时候多线程都更好，有些时候创建一个线程的消耗还不如直接执行函数来的快（比如函数干的活很小的情况，比如一些 O(1) 的算法）\n\n所以，这个关键字多少还是有点作用了。\n2.7 future_error&#x2F;errc&#x2F;status除了 future 和share_future，还有如下几个类型\n\nstd::future_error： std::future_error 是一个异常类，用于表示与 std::future 相关的错误。当在使用 std::future 时出现错误，例如获取结果时异步任务抛出了异常，就会抛出 std::future_error 异常。它是一个  标准异常类型，通常通过捕获异常对象来处理异步任务执行过程中的问题。\nstd::future_errc： std::future_errc 是一个枚举类型，用于表示 std::future_error 中的不同错误情况。这样的枚举类型是为了在处理异常时更加明确和方便。它包含了一系列可能的错误，如 broken_promise（promise 被破坏，即 promise 对象的 set_value 或 set_exception 被多次调用）和 future_already_retrieved（future 对象已经被获取过一次）等。\nstd::future_status： std::future_status 是一个枚举类型，用于表示 std::future 的状态。它描述了一个 std::future 对象的当前情况，指示异步任务是否已完成、是否有效等。std::future_status 包含三个值：ready（异步任务已完成，可以获取结果）、timeout（等待超时，即异步任务还未完成）、deferred（异步任务延迟执行）。\n\n其中 wait_for 的返回值是 std::future_status，包含三种情况\n\n\n\nvalue\ndescription\n\n\n\nfuture_status::ready\nThe shared state is ready: the producer has set a value or exception.\n\n\nfuture_status::timeout\nThe function waited for rel_time without the shared state becoming ready.\n\n\nfuture_status::deferred\nThe shared state contains a deferred function.\n\n\n第一个情况是 future 的目标函数已经执行完毕，可以去获取返回值了。\n第二个情况是 wait_for 等待超时了。\n第三个情况是 future 中包含的函数使用的策略是 std::launch::deferred，此时wait_for 函数是没有意义的，因为在这种情况下，函数只有在 future.get() 的时候才会被执行，wait_for会被直接返回。\n3. 为什么 C++ 会出现 futrue？为啥要出一个 future？直接用老办法不也可以这么玩吗？\n\n这部分是 GPT 的回答\n\nC++ 标准库引入 std::future 和相关的异步编程机制，是为了更好地支持并发编程和多线程环境。这些机制的出现有几个原因和动机：\n\n并发性和性能提升： 在现代计算机体系结构中，多核处理器已经成为常态。为了充分利用这些多核资源，编写并发代码变得重要。std::future 提供了一种方式，可以在多个线程中同时执行任务，并且可以方便地获取任务的结果，从而允许程序在多核处理器上并行执行，提高性能。\n任务分离： 在很多情况下，我们希望将一个大的任务拆分成多个子任务，在不同的线程中并行执行，然后合并子任务的结果。std::future 允许你在一个线程中等待另一个线程的任务完成，从而支持这种任务分离和并行执行的模式（其实最主要的还是获取线程所执行函数的返回值）。\n避免阻塞： 在传统的同步编程中，如果某个操作需要等待，会导致线程阻塞。而异步编程机制允许线程继续执行其他操作，而不必等待一个潜在的耗时操作完成。std::future 允许你在一个线程中发起异步操作，并在需要的时候获取操作的结果，从而避免了不必要的阻塞。\n异常处理： 在多线程环境中，处理异步任务的异常可能变得复杂，因为异步任务在不同的线程中执行。std::future 引入了异常传递机制，允许异步任务在执行过程中抛出异常，并将这些异常传递到等待结果的线程中。\n\n总之，C++ 的 std::future 和相关的异步编程机制提供了一种更高级别、更方便的方式来处理多线程并发编程。这些机制使得开发者能够更容易地利用多核处理器的性能，并更灵活地设计并发代码，从而在面对并发和异步任务时能够更好地管理资源、提高效率和处理异常。\n4.promise4.1 概念 std::promise 是 C++ 标准库中用于在一个线程中产生结果，然后在 另一个线程中  获取结果的工具。它提供了一些成员函数来设置结果、处理异常以及获取关联的 std::future 对象等。\ntemplate &lt;class T&gt;  promise;template &lt;class R&amp;&gt; promise&lt;R&amp;&gt;;     // specialization : T is a reference type (R&amp;)template &lt;&gt;         promise&lt;void&gt;;   // specialization : T is void\n\n下面是一些常用的 std::promise 成员函数及其用法：\n\nset_value： 用于设置结果值。如果你已经通过 get_future() 获取了一个 std::future 对象，调用 set_value 将会使等待结果的线程被唤醒并获取结果。\nstd::promise&lt;int&gt; promiseObj;std::future&lt;int&gt; futureResult = promiseObj.get_future();// 在某个线程中设置结果值promiseObj.set_value(42);\n\nset_exception： 用于设置异常，将在等待结果的线程中抛出。这允许你在产生结果的线程中处理异常情况。\ntry &#123;    // 产生异常    throw std::runtime_error(&quot;An error occurred&quot;);&#125; catch (...) &#123;    // 将异常设置到 promise 对象中    promiseObj.set_exception(std::current_exception());&#125;\n\nget_future： 返回与 std::promise 关联的 std::future 对象。通过这个 std::future，你可以在另一个线程中等待并获取结果。\nstd::promise&lt;int&gt; promiseObj;std::future&lt;int&gt; futureResult = promiseObj.get_future();\n\nswap： 交换两个 std::promise 对象的状态，包括关联的 std::future 对象和设置的结果。\nstd::promise&lt;int&gt; promise1;std::promise&lt;int&gt; promise2;// 交换两个 promise 对象的状态promise1.swap(promise2);\n\nvalid： 检查 std::promise 对象是否有效，即是否与一个 std::future 对象关联。\nstd::promise&lt;int&gt; promiseObj;if (promiseObj.valid()) &#123;    // promiseObj 有效&#125; else &#123;    // promiseObj 无效&#125;\n\n还有下面这俩个成员函数，看名字也能猜出来它是干嘛的，就不多说了\n\nset_value_at_thread_exit\nSet value at thread exit (public member function)\n\nset_exception_at_thread_exit\nSet exception at thread exit (public member function)\n\n\n这些成员函数允许你在一个线程中产生结果或异常，并在另一个线程中等待和处理这些结果或异常。它们为多线程编程提供了一种可靠的方式来传递数据和控制流。请注意，在使用 std::promise 时，你需要仔细处理异常和线程同步，以确保正确的结果传递。\n4.2 示例  然后下头是一个基本的使用示例；你可以理解为 promise 就是一个用来承担线程所执行函数的参数和异常的一个变量，我们可以通过 set_value 并在主执行流中使用 future.get 来获取到这个值，也可以设置异常，并在主执行流中处理这个异常；\n不过 promise 和future一样，是  一次性  的，设置 value 和异常都只能设置一次，设置完毕后就不能再设置了\n#include &lt;iostream&gt;#include &lt;future&gt;void worker(std::promise&lt;int&gt;&amp; p) &#123;    p.set_value(42); // 设置值&#125;int main() &#123;    std::promise&lt;int&gt; promiseObj;    std::future&lt;int&gt; futureResult = promiseObj.get_future();    std::thread t(worker, std::ref(promiseObj)); // 通过线程执行    t.join();    int result = futureResult.get(); // 主线程中获取值    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;\n\n5.packaged_taskstd::packaged_task 是 C++ 标准库中的一个类模板，用于将一个可调用对象（函数、函数对象或可调用成员函数）封装成一个可以  异步  执行的任务，并且可以通过 std::future 获取任务的返回值。它在多线程编程中起到了连接异步任务和线程间通信的桥梁作用。\nstd::packaged_task 的主要作用有以下几个方面：\n\n封装任务： std::packaged_task 允许你将一个可调用对象封装成一个任务，这个任务可以在另一个线程中异步执行。你可以将函数、函数对象或可调用成员函数封装为一个 std::packaged_task 实例。\n异步执行： 通过将 std::packaged_task 实例传递给一个 std::thread 或其他支持异步执行的机制，你可以在新的线程中执行封装的任务，而不需要显式创建线程函数。\n获取返回值： std::packaged_task 可以与 std::future 一起使用，以获取异步任务的返回值。你可以通过 packaged_task 的 get_future 方法获取一个与任务关联的 std::future 对象，然后在适当的时候使用 std::future 的 get 方法来获取任务的返回值。\n线程池： std::packaged_task 结合线程池的使用，可以更灵活地控制任务的执行方式。线程池可以预先创建一组线程，然后将封装好的任务分配给这些线程执行，避免了频繁创建和销毁线程的开销。\n\n5.1 示例  下面是一个简单示例，演示了如何使用 std::packaged_task 来异步执行一个函数并获取其返回值\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int add(int a, int b) &#123;    return a + b;&#125;int main() &#123;    std::packaged_task&lt;int(int, int)&gt; task(add);    std::future&lt;int&gt; future = task.get_future();    std::thread worker(std::move(task), 3, 5);    worker.join(); // 通过线程异步执行这个 task    int result = future.get(); // 等待返回值    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;\n\n在这个例子中，std::packaged_task 封装了一个函数 add，然后通过 std::thread 异步执行，最后通过 std::future 获取异步任务的返回值。\n5.2 make_ready_at_thread_exitpackaged_task的成员函数中，主要还是这个需要单独说明；先看如下代码\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int main() &#123;    std::packaged_task&lt;int()&gt; task([]()&#123; return 42; &#125;);    std::future&lt;int&gt; future = task.get_future();    std::thread worker([&amp;task]() &#123;        // 模拟一些工作        std::this_thread::sleep_for(std::chrono::seconds(2));        // 设置任务结果值        task.make_ready_at_thread_exit();    &#125;);    worker.detach(); // 分离线程，不等待其结束    // 等待任务结果    int result = future.get();    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;\n\n我们让 packaged_task 执行的是一个 return 42 的函数，而线程里面还会进行其他处理。\n而 make_ready_at_thread_exit() 的作用，就是确认当前的 worker 线程已经干完自己的活了，可以执行 packaged_task 封装的函数了！\n相当于是一个确认 packaged_task 中封装的任务到底在什么时候执行的一个函数。调用这个函数的时候，就会开始执行其包装的异步函数，并返回结果给 future.get() 的执行流\nThe end收工\n","categories":["遇见C++"],"tags":["Linux","C++","C++11"]},{"title":"【C++】构造函数和初始化列表的性能差距","url":"/posts/2628258650/","content":"构造函数和初始化列表的性能差距对比测试\n\n\n1. 说明  在 C++ 类和对象中，你可能听到过更加推荐用初始化列表来初始化类内成员。如果类内成员是自定义类型，则只能在初始化列表中调用自定义类型的构造函数。\n但初始化列表和在构造函数体内直接赋值有无性能差距呢？今天就用一份相对简单的代码来测试一下\n2. 测试 2.1 代码说明 首先是一个自定义类型，实现带缺省值的默认构造，拷贝构造和赋值重载这三个函数，并在内部新增打印来区分不同的函数\nstruct mytest &#123;public:    mytest(int a = -1)    &#123;        _a = a;        cout &lt;&lt; &quot;mytest() &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    mytest(const mytest&amp; st) &#123;        _a = st._a;        cout &lt;&lt; &quot;mytest(copy) &quot; &lt;&lt; st._a &lt;&lt; endl;    &#125;    mytest&amp; operator=(const mytest&amp; st)    &#123;        _a = st._a;        cout &lt;&lt; &quot;mytest operator= &quot; &lt;&lt; st._a &lt;&lt; endl;        return *this;    &#125;private:    int _a;&#125;;\n\n再在另外一个类中使用这个自定义类型\nstruct myclass &#123;public:    myclass(const struct mytest&amp; st, int b)    &#123;        cout &lt;&lt; &quot;myclass() _b:&quot; &lt;&lt; _b &lt;&lt; endl;    &#125;    struct mytest _sa;    int _b;&#125;;\n\n此时构造函数就有两种写法，一种是在初始化列表中初始化这个自定义类型\nmyclass(const struct mytest&amp; st, int b)       :_sa(st),       _b(b)   &#123;       cout &lt;&lt; &quot;myclass() _b:&quot; &lt;&lt; _b &lt;&lt; endl;   &#125;\n\n另外一种是在构造函数体内通过赋值重载来初始化这个自定义类型\nmyclass(const struct mytest&amp; st, int b)&#123;     _sa = st;     _b = b;    cout &lt;&lt; &quot;myclass() _b:&quot; &lt;&lt; _b &lt;&lt; endl;&#125;\n\n需要注意的是，这里的自定义类型传参采用了引用传参，并不会因此产生额外的拷贝！\n主函数体如下，为了区分第一个 mytest 的构造函数，我在其后新增了一行输出作为分割\nint main()&#123;    mytest test_a(1);    cout &lt;&lt; &quot;------&quot; &lt;&lt; endl;    myclass test(test_a, 3);    return 0;&#125;\n\n2.2 测试  先来看看使用赋值初始化的方式，可以看到，虽然我们在初始化列表中什么都没有写，但是这里  依旧调用了默认的构造函数（因为默认构造函数的缺省值给的是-1，这里能通过参数判断出来这并不是我们显式调用的构造）\n调用了默认构造后，又通过赋值重载来初始化了一遍_sa，相当于两次初始化\n\n但如果调用初始化列表，则只会有一次拷贝构造，避免了额外的默认构造调用！\n\n在 linux 下也测试过了，结果和 VS2019 相同\n3. 结论  结论就出来了：初始化列表能节省一次默认构造的调用，优化性能！\n3.1 实际场景  在上面的场景中，性能差距可能并不会特别大，但是在下面的场景中可能就不一样了\nstruct mytest &#123;public:    mytest(int sz = 1)    &#123;        _str = new char[sz];        _sz = sz;        cout &lt;&lt; &quot;mytest() &quot; &lt;&lt; sz &lt;&lt; endl;    &#125;    mytest(const mytest&amp; st) &#123;        delete _str;// 需要先销毁原视的数据        _str = new char[st._sz]; // 再创建一个新的        _sz = st._sz;        // 省略拷贝数据的代码        cout &lt;&lt; &quot;mytest(copy) &quot; &lt;&lt; st._sz &lt;&lt; endl;    &#125;    mytest&amp; operator=(const mytest&amp; st)    &#123;        delete _str;// 需要先销毁原视的数据        _str = new char[st._sz]; // 再创建一个新的        // 省略拷贝数据的代码        cout &lt;&lt; &quot;mytest&amp; operator= &quot; &lt;&lt; st._sz &lt;&lt; endl;        return *this;    &#125;private:    char* _str;    size_t _sz;&#125;;struct myclass &#123;public:    myclass(const struct mytest&amp; st, int b)        :_sa(st),        _b(b)    &#123;         //_sa = st;         //_b = b;        cout &lt;&lt; &quot;myclass() _b:&quot; &lt;&lt; _b &lt;&lt; endl;    &#125;    struct mytest _sa;    int _b;&#125;;\n\n在这个场景中，因为 mytest 自定义类型的拷贝构造涉及到了深拷贝，此时就需要将已有的空间给销毁了，再 new 一片新的空间出来，再将数据给拷贝过去。\n白白多了一层默认构造中的 new 空间的 + 拷贝构造中 delete 原有空间的消耗！\n如果类中需要深拷贝的成员不止一个，那性能差距就更大！\n所以在 C++ 中，一律以初始化列表优先！\n\n这里顺带提一嘴初始化列表的小坑，也算是复习；\n当你使用初始化列表来初始化类内成员的时候，初始化的顺序是类内成员声明的顺序，而  不是初始化列表中的顺序！这点非常重要，如果顺序不对，可能会出现使用未定义（还没有初始化完成）的参数的 bug！\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】空对象指针也能访问成员函数？","url":"/posts/3858168549/","content":"1. 起因  今天写代码的时候遇到一个 bug，一个类中的 set 函数在设置一个 POD 类型的时候出现了异常，直接段错误退出了。\n\n小 tips，POD 类型指的是内置类型。\n\n想了好久，都没发现这里的问题到底是因为什么。后来才知道，原来空的对象指针，也能被解引用访问到函数！\n2. 示例  下面是关于这个情况的示例代码\n#include &lt;iostream&gt;using namespace std;class mytest&#123;public:    mytest() = default;    mytest(int a):_a(0)&#123;&#125;    void set_int(int a)    &#123;        cout &lt;&lt; &quot;set int to &quot; &lt;&lt; a &lt;&lt; endl;        _a = a;    &#125;    void print(int a)    &#123;        cout &lt;&lt; &quot;just a print&quot; &lt;&lt; a &lt;&lt; endl;    &#125;private:    int _a = 0;&#125;;int main()&#123;    mytest* ptr = nullptr;    ptr-&gt;print(20);    ptr-&gt;set_int(10);    return 0;&#125;\n\n运行这个程序，会出现段错误。但你会发现这个段错误并不是因为我们的 ptr-&gt; 里面出现的，而是成功进入了 set_int 函数，执行了打印，最终对成员变量_a 赋值的时候出现的！\n对象指针为空，代表压根不存在一个实际的对象，也没办法对不存在的成员变量操作。\n&gt; ./testjust a print20set int to 10[1]    280362 segmentation fault  ./test\n\n当代码很多的时候，就会因为忽略这个特性（其实我当时是压根不知道）而误以为错误出现在 set_int 函数中。\n没有想到是外层的对象指针为空导致的。\n3. 为什么？在编译过程中，对象就已经绑定了函数地址。一个类的所有对象，使用的函数地址都是一样的。当编译ptr-&gt;set_int(10) 的时候，函数的地址就已经和这个指针绑定了，调用它等价于直接调用 set_int 函数。\n如果这个函数中没有需要用到成员变量的地方，也就不需要解引用 this 指针，是不会出错的。比如上方代码中的 print 函数，就没有出现异常。\n但如果函数内访问了内置成员，那么就会出现解引用空指针导致的段错误！\n","categories":["遇见C++"],"tags":["数据结构","C++"]},{"title":"【C++】C++17 的那些新特性","url":"/posts/3858168547/","content":"学习 C++17 的新特性\n1. 构造函数模板推导  在之前，我们如果想用 stl 容器，都需要用&lt;&gt; 来手动指定参数类型。但在 C++17 中，我们不需要这么做了。\nint main()&#123;    std::vector v1 = &#123;1,2,3,4&#125;;    std::pair p1  = &#123;1,2.4234&#125;;    cout &lt;&lt; typeid(v1).name() &lt;&lt; endl;    cout &lt;&lt; typeid(p1).name() &lt;&lt; endl;    return 0;&#125;\n\n使用 C++11 编译，这个代码会报错。报错的意思是让我们指定参数的模板类型。\n比如 std::pair p1  = &#123;1,2.4234&#125;; 在 C++11 中应该写成 std::pair&lt;int,double&gt; p1  = &#123;1,2.4234&#125;;\ntest.cpp:16:10: error: use of class template &#x27;std::pair&#x27; requires template arguments    std::pair p1  = &#123;1,2.4234&#125;;         ^/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_pair.h:211:12: note: template is declared here    struct pair           ^3 errors generated.make: *** [makefile:3: test] Error 1\n\n在 C++17 中，这样的写法就是可以被通过的了，也能正常推断出参数的类型，分别是一个 int 的 vector，和一个 int+double 的 pair；\n$ makeclang++ test.cpp -o test -std=c++17$ ./testSt6vectorIiSaIiEESt4pairIidE\n\n2. 结构化绑定  我们可以用 auto[变量 1, 变量 2]的方式来接受一个 tuple 或者 pair 的返回值，将其绑定到两个不同的变量上。\ntuple 是 C++11 新增的一个数据结构，它和 pair 的用法类似，不同的是元组支持无数个参数。而 pair 仅支持两个。\nstd::tuple&lt;int, double&gt; func_tuple()&#123;    return std::tuple&lt;int,double&gt;(1, 2.2);&#125;std::pair&lt;int, double&gt; func_pair()&#123;    return &#123;1,2&#125;;&#125;int main()&#123;    auto [i, d] = func_tuple();     cout &lt;&lt; typeid(i).name() &lt;&lt; endl;    cout &lt;&lt; typeid(d).name() &lt;&lt; endl;    cout &lt;&lt; endl;    auto [x,y] = func_pair();    cout &lt;&lt; typeid(x).name() &lt;&lt; endl;    cout &lt;&lt; typeid(y).name() &lt;&lt; endl;    return 0;&#125;\n\n使用 C++11 来编译，编译器会报错，但编译依旧能成功。这是因为我们的编译器是支持 C++17 的，但又被指定了-std=c++11，所以给用户报了个警告，但没有报错（因为这个语法在 C++17 里面是正确的）\nclang++ test.cpp -o test -std=c++11test.cpp:34:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]    auto [i, d] = func_tuple();          ^~~~~~test.cpp:40:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]    auto [x,y] = func_pair();         ^~~~~2 warnings generated.\n\n运行输出结果如下\n$ ./testidid\n\n注意：结构化绑定不能应用于 constexpr！\n结构化绑定不止可以绑定 pair 和 tuple，还可以绑定数组和结构体等。\n// 注意这里的 struct 的成员一定要是 public 的，不然外部无法访问，还怎么绑定？struct Point&#123;    int x;    int y;&#125;;// 返回值是 point 的函数Point func()&#123;    return &#123;1, 2&#125;;&#125;int main()&#123;    int array[3] = &#123;1, 2, 3&#125;;    auto [a, b, c] = array;    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;    // 直接推导出两个成员变量并赋值给变量 x 和 y    const auto [x, y] = func();    return 0;&#125;\n成功编译并输出结果\n$ makeclang++ test.cpp -o test -std=c++17$ ./test1 2 31 2\n\n自定义类型也能实现结构化绑定，这里从网上扒了一个代码下来，就不自己做测试了\n// 需要实现相关的 tuple_size 和 tuple_element 和 get&lt;N&gt; 方法。class Entry &#123;public:    void Init() &#123;        name_ = &quot;name&quot;;        age_ = 10;    &#125;    std::string GetName() const &#123; return name_; &#125;    int GetAge() const &#123; return age_; &#125;private:    std::string name_;    int age_;&#125;;template &lt;size_t I&gt;auto get(const Entry&amp; e) &#123;    if constexpr (I == 0) return e.GetName();    else if constexpr (I == 1) return e.GetAge();&#125;namespace std &#123;    template&lt;&gt; struct tuple_size&lt;Entry&gt; : integral_constant&lt;size_t, 2&gt; &#123;&#125;;    template&lt;&gt; struct tuple_element&lt;0, Entry&gt; &#123; using type = std::string; &#125;;    template&lt;&gt; struct tuple_element&lt;1, Entry&gt; &#123; using type = int; &#125;;&#125;int main() &#123;    Entry e;    e.Init();    auto [name, age] = e;    cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; // name 10    return 0;&#125;\n\n\n3.if 语句新增初始条件  在之前我们都是用 if(判断条件) 来使用 if 语句的，C++17 中给 if 新增了一个类似 for 循环中第一个参数的相同参数\nif(初始化条件, 判断条件)\n\n比如\nif(int i=20;i&lt;39)&#123;    cout &lt;&lt;&quot;i&lt;39!&quot;&lt;&lt;endl;&#125;\n\n运行效果如下\n$ ./testi&lt;39!\n\n4. 内联变量  在之前我们想初始化一个类中的 static 变量，需要在类中定义，类外初始化。但如果是 const 的 static 变量，就能直接在类中通过缺省值的方式来初始化。\n// 在头文件里面这样是能通过编译的，但是不建议在头文件中初始化 static 变量，会产生 ODR 冲突:// Variable &#x27;value&#x27; defined in a header file; variable definitions in header files can lead to ODR violationsstruct A &#123;    static int value;      static const int value_c=10;  // const 可以直接初始化&#125;;int A::value = 10;\n\n在 C++17 中内联变量引入后，我们就可以直接实现在头文件中初始化 static 非 const 变量，或者直接用缺省值来初始化了\nstruct A&#123;    static int value;    static const int value_c = 10;    // static int value = 10;&#125;;inline int A::value = 10;// ========= 或者 ========struct B&#123;    inline static int value = 10;    inline static const int value_c = 10;&#125;;\n\n相比于原本 static 变量初始化需要放到另外一个 cpp 源文件中，这种直接在头文件里面声明 + 初始化的方式能更好的确定变量的初始值。\n5. 折叠表达式C++17 引入了折叠表达式使可变参数模板编程更方便：\ntemplate &lt;typename ... Ts&gt;auto sum(Ts ... ts) &#123;    return (ts + ...);&#125;int a &#123;sum(1, 2, 3, 4, 5)&#125;; // 15std::string a&#123;&quot;hello &quot;&#125;;std::string b&#123;&quot;world&quot;&#125;;cout &lt;&lt; sum(a, b) &lt;&lt; endl; // hello world\n\n实话说，可变模板参数这部分就没有弄明白过，实际上也没有用过，直接跳过！\n6.constexpr+lambda 表达式C++17 前 lambda 表达式只能在运行时使用，C++17 引入了 constexpr lambda 表达式，可以用于在编译期进行计算。\nint main() &#123; // c++17 可编译    constexpr auto lamb = [] (int n) &#123; return n * n; &#125;;    static_assert(lamb(3) == 9, &quot;a&quot;);&#125;\n\n规则和普通的 constexpr 函数相同，参考我的 C++11 和 14 的文章。这里做简单说明：\nconstexpr 修饰的函数体不能包含汇编语句、goto 语句、label、try 块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有 new delete 等，不能虚函数。\n7. 嵌套命名空间  在之前如果需要嵌套命名空间，需要这样写\nnamespace A &#123;    namespace B &#123;        namespace C &#123;            void func();        &#125;    &#125;&#125;\nC++17 中可以直接用类似访问限定符的方式，前面加一个 namespace 来标明嵌套的命名空间。\n// c++17，方便了，可读性也更好namespace A::B::C &#123;    void func();&#125;\n\n8.__has_include 预处理表达式#if defined __has_include // 判断是否支持这个表达式#if __has_include(&lt;charconv&gt;) // 支持，判断是否存在该头文件#define has_charconv 1 // 头文件存在，定义一个宏#include &lt;charconv&gt; // 引用这个头文件#endif#endif\n\n如果一个代码会在多个不同的平台下跑，这个功能就很重要。比如我之前写项目的时候需要使用到 jsoncpp，在 centos 和 deepin 下，安装 jsoncpp 的 include 路径是不同的\n//centos#include &lt;json/json.h&gt;//deepin#include &lt;jsoncpp/json/json.h&gt;\n\n这种场景下就可以使用上面提到的这个预处理表达式进行判断，来确认你的 jsoncpp 路径到底在哪里。注意，这只能解决从 yum 和 apt 安装的 jsoncpp，如果是自己手动安装的，那鬼知道你安装到哪里去了？🤣\n所以很多大型项目如果需要使用 jsoncpp 这种第三方依赖项目，一般都会采用 git submodule 的方式，直接将第三方库下载到当前项目路径下，以避免不同平台的依赖项 include 路径不对而导致无法编译程序的问题。\n9.this 指针捕获（lambda）在 lambda 表达式中，采用 [this] 方式捕获的 this 指针是  值传递  捕获的，但在一些情况下，会出现访问已经被释放了的空间的行为；比如如下代码\n#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;struct Foo&#123;    std::unique_ptr&lt;int&gt; p;    std::function&lt;void()&gt; f()    &#123;        p.reset(new int(10));        return [&amp;]        &#123;            cout &lt;&lt; 5 &lt;&lt; endl;            cout &lt;&lt; *p &lt;&lt; endl; // 实际上是这一步报错的            // 这里对 *p 的访问可以解析为 *(this-&gt;p)，但实际上 this 指针已经被销毁了            // 注意，这里采用了智能指针，不存在内存泄漏，p 指针指向的空间也被销毁了            // 但我们的报错其实是对 this 指针解引用的时候就抛出了            cout &lt;&lt; 6 &lt;&lt; endl;        &#125;;    &#125;&#125;;int main()&#123;    auto foo = new Foo();    cout &lt;&lt; 1 &lt;&lt; endl;    auto f = foo-&gt;f();  // 获取了一个类内成员函数    cout &lt;&lt; 2 &lt;&lt; endl;    delete foo;  // 销毁这个对象    cout &lt;&lt; 3 &lt;&lt; endl;    // 尝试在销毁后继续使用这个对象，我们是通过 lambda 中 = 捕获的 this 指针来访问对象的    f();  // 这里直接报错了 Segmentation fault (core dumped)    cout &lt;&lt; 4 &lt;&lt; endl;    return 0;&#125;\n\n运行这个程序，可以看到是在 *p 的位置报错退出的；具体的原因参考代码中的注释。\n$ ./test1235Segmentation fault (core dumped)\n\n需要注意，lambda 表达式中，使用 &#x3D; 和 &amp; 都会默认采用  传值捕获 this 指针，因为 this 指针是存在于函数作用域中的一个隐藏参数，并不是独立在成员函数外的变量，所以是可以被捕捉到的；另外，this 指针是不能被传引用捕获的，[&amp;this] 的写法是不允许的；\nclang++ test.cpp -o test -std=c++17test.cpp:84:18: error: &#x27;this&#x27; cannot be captured by reference        return [&amp;this]                 ^1 error generated.\n\nC++17 中提供了一个特殊的写法 [*this] 通过传值的方式捕获了当前对象本身，此时 lambda 表达式中存在的就是一个对象的拷贝，即便当前对象被销毁了，我们依旧可以通过这个拷贝访问到目标；\n代码修改如下：\n#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;struct Foo&#123;    std::shared_ptr&lt;int&gt; p; // 不能用 unique_ptr，因为它的拷贝构造函数是被 delete 禁止使用的    std::function&lt;void()&gt; f()    &#123;        p.reset(new int(10));        return [*this]        &#123;            cout &lt;&lt; 5 &lt;&lt; endl;            cout &lt;&lt; *p &lt;&lt; endl;            cout &lt;&lt; 6 &lt;&lt; endl;        &#125;;    &#125;&#125;;int main()&#123;    auto foo = new Foo();    cout &lt;&lt; 1 &lt;&lt; endl;    auto f = foo-&gt;f();  // 获取了一个类内成员函数    cout &lt;&lt; 2 &lt;&lt; endl;    delete foo;  // 销毁这个对象    cout &lt;&lt; 3 &lt;&lt; endl;    // 尝试在销毁后继续使用这个对象，我们是通过 lambda 中 = 捕获的 this 指针来访问对象的    f();  // 这里直接报错了 Segmentation fault (core dumped)    cout &lt;&lt; 4 &lt;&lt; endl;    return 0;&#125;\n\n此时重新编译，就能成功访问到指针 p 指向的对象了，并不受 foo 对象已经被 delete 的影响；\n$ ./test12351064\n\n\n10. 字符串转换\n没看懂这两个函数是干嘛的，找到的代码连编译都过不去，跳过吧\n\n新增 from_chars 函数和 to_chars 函数\nhttps://zh.cppreference.com/w/cpp/utility/from_charshttps://blog.csdn.net/defaultbyzt/article/details/120151801\n\n11.std::variantC++17 增加 std::variant 实现类似 union 的功能，但却比 union 更高级，举个例子 union 里面不能有 string 这种类型，但 std::variant 却可以，还可以支持更多复杂类型，如 map 等，看代码：\nint main() &#123; // c++17 可编译    std::variant&lt;int, std::string&gt; var(&quot;hello&quot;);    cout &lt;&lt; var.index() &lt;&lt; endl;    var = 123;    cout &lt;&lt; var.index() &lt;&lt; endl;    try &#123;        var = &quot;world&quot;;        std::string str = std::get&lt;std::string&gt;(var); // 通过类型获取值        var = 3;        int i = std::get&lt;0&gt;(var); // 通过 index 获取对应值        cout &lt;&lt; str &lt;&lt; endl;        cout &lt;&lt; i &lt;&lt; endl;    &#125; catch(...) &#123;        // xxx;    &#125;    return 0;&#125;\n\n\n注意：一般情况下 variant 的第一个类型一般要有对应的构造函数，否则编译失败：\nstruct A &#123;    A(int i)&#123;&#125;  &#125;;int main() &#123;    std::variant&lt;A, int&gt; var; // 编译失败&#125;\n\n如何避免这种情况呢，可以使用 std::monostate 来打个桩，模拟一个空状态。\nstd::variant&lt;std::monostate, A&gt; var; // 可以编译成功\n\n12.std::optionalhttps://en.cppreference.com/w/cpp/utility/optional\n有的时候，我们想在异常的时候抛出一个异常的对象，亦或者是在出现一些不可预期的错误的时候，返回一个空值。要怎么区分空值和异常的对象呢？\n在 python 中，我们有一个专门的 None 对象可以来处理这件事。在 MySQL 中，我们也有 NULL 来标识空；但在 CPP 中，我们只剩下一个 nullptr，其本质是个 指针，与 Py 中的 None 和 MySQL 中的 NULL 完全不同！如果想用指针来区分空和异常对象，那就需要用到动态内存管理，亦或者是用智能指针来避免内存泄漏。\n说人话就是，在 CPP 中没有一个类似 None 的含义为空的对象，来告诉调用这个程序的人，到底是发生了错误，生成了一个错误的对象，还是说压根什么都没有弄出来。\n于是 std::optional 就出现了，其可以包含一个类型，并有 std::nullopt 来专门标识“空”这个含义。\n#include &lt;optional&gt;std::optional&lt;int&gt; StoI(const std::string &amp;s) &#123;    try &#123;        return std::stoi(s);    &#125; catch(...) &#123;        return std::nullopt;    &#125;&#125;void func() &#123;    std::string s&#123;&quot;123&quot;&#125;;    std::optional&lt;int&gt; o = StoI(s);    if (o) &#123;        cout &lt;&lt; *o &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;    &#125;&#125;\n\n这里我们进行了 if 的判断，首先判断变量 o 本身，为真代表的确返回了一个 int 值，为假代表返回的是nullopt；\n随后再使用 *o 来访问到内部托管的成员。\n需要注意这里是两层的逻辑关系，只有 optional 对象中成功托管了一个指定的参数类型，其本身才是真的。如果想访问它托管的对象，则需要用解引用。\n比如这里，我们的 o 对象托管的是一个 bool 类型的假，但假并不代表空，o 对象本身的判断是真，内部对 *o 的判断才是判断托管的 bool 值到底是真是假。\n#include &lt;optional&gt;int main() &#123;    std::optional&lt;bool&gt; o = false;    cout &lt;&lt; typeid(o).name() &lt;&lt; endl;    if (o) // 这里判断的是 optional 对象是否有托管一个 bool 值    &#123;        if(*o)&#123; // 这里判断的是托管的 bool 值本身            cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;        &#125;        else&#123;            cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;        &#125;    &#125; else &#123; // 这里则代表托管的是 nullopt        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n\n最终运行打印的结果是false；\n13.std::anyhttps://en.cppreference.com/w/cpp/utility/any\n这个类型可以托管任意类型的值，与之对应的还有一个 std::any_cast 来将其托管的值转成我们需要的类型。\n#include &lt;any&gt;int main() &#123; // c++17 可编译    std::any a = 1;    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;int&gt;(a) &lt;&lt; endl;    a = 2.2f;    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;float&gt;(a) &lt;&lt; endl;    if (a.has_value()) &#123;        cout &lt;&lt; a.type().name();    &#125;    a.reset();    if (a.has_value()) &#123;        cout &lt;&lt; a.type().name();    &#125;    a = std::string(&quot;a&quot;);    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;std::string&gt;(a) &lt;&lt; endl;    return 0;&#125;\n\n输出结果如下\ni 1f 2.2fNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE a\n虽然 any 的出现让 cpp 也在一定程度上能实现“弱类型”变量，但在具体的开发中，明确变量的类型依旧比使用 any 好得多。特别是在变量的类型并不可以被直接转换的情况下。\n14.std::apply使用 std::apply 可以将 tuple 展开作为函数的参数传入，见代码：\n#include &lt;tuple&gt;int add(int first, int second) &#123; return first + second; &#125;auto add_lambda = [](auto first, auto second) &#123; return first + second; &#125;;int main() &#123;    std::cout &lt;&lt; std::apply(add, std::pair(1, 2)) &lt;&lt; &#x27;\\n&#x27;;    std::cout &lt;&lt; add(std::pair(1, 2)) &lt;&lt; &quot;\\n&quot;; // error    std::cout &lt;&lt; std::apply(add_lambda, std::tuple(2.0f, 3.0f)) &lt;&lt; &#x27;\\n&#x27;;&#125;\n\n\n15.std::make_from_tuple使用 make_from_tuple 可以将 tuple 展开作为构造函数参数\nstruct Foo &#123;    Foo(int first, float second, int third) &#123;        std::cout &lt;&lt; first &lt;&lt; &quot;, &quot; &lt;&lt; second &lt;&lt; &quot;, &quot; &lt;&lt; third &lt;&lt; &quot;\\n&quot;;    &#125;&#125;;int main() &#123;   auto tuple = std::make_tuple(42, 3.14f, 0);   std::make_from_tuple&lt;Foo&gt;(std::move(tuple));&#125;\n\n\n16.std::string_viewhttps://zhuanlan.zhihu.com/p/166359481\nhttps://en.cppreference.com/w/cpp/string/basic_string_view\n如果我们只需要一个 string 的只读类型的话，可以用 string_view 来托管。其内部只包含一个指向目标字符串的指针，以及字符串的长度。\nstring_view 内部封装了 string 的所有只读接口，本来就是给你读的。\n需要注意的是，因为内部只有一个指针，所以当 string_view 托管的 string 被销毁了，与之关联的所有 string_view 都会失效！同样是因为内部只有一个指针和字符串的长度两个变量，所以在传值拷贝的时候，string_view 的效率会高很多。\n\n这和const string&amp; 类型的传值又有什么区别呢？传引用不是也没有拷贝消耗吗？\n\n这个问题很好，我不知道！百度也没有百度出来……\n我能想到的就是用 string_view 作为参数的时候，如果入参是一个常量字符串，此时不需要构造 string，而使用const string&amp; 接受常量字符串的时候依旧需要构造一个 string 对象。这部分就会有一定的消耗。\n17.as_constC++17 使用 as_const 可以将左值转成 const 类型\nstd::string str = &quot;str&quot;;const std::string&amp; constStr = std::as_const(str);\n\n18.file_systemC++17 正式将 file_system 纳入标准中，提供了关于文件的大多数功能，基本上应有尽有，这里简单举几个例子：\nnamespace fs = std::filesystem;fs::create_directory(dir_path); // 创建文件或者路径fs::copy_file(src, dst, fs::copy_options::skip_existing); // 文件 cpfs::exists(filename); // 文件是否存在fs::current_path(err_code); // 获取当前路径\n\n19.shared_mutex这玩意是个读写锁。简单介绍一下什么是读写锁：\n\n读者可以有多个，写者只能有一个\n写锁是互斥的，如果 A 有锁，B 想拿锁就得阻塞等待\n读锁是共享的，C 有读锁，D 也想读，两个人可以一起看\n读写锁是互斥的，有人写的时候不能读，有人读的时候不能写\n\n换到专业术语上，就是分为独占锁（写锁）和共享锁（读锁）；\n在 C++14 中其实已经有了一个shared_timed_mutex，C++17 中这个锁的操作与其基本一致，只不过多了几个和时间相关的接口\ntry_lock_for(...);try_lock_shared_for(...);try_lock_shared_until(...);try_lock_until(...);\n\n具体使用可以参考 \nhttps://zh.cppreference.com/w/cpp/thread/shared_mutexhttps://zhuanlan.zhihu.com/p/610781321\n\nThe end关于 C++17 常用的基本就是这些了，后续遇到新的再更新本文。\n","categories":["遇见C++"],"tags":["数据结构","C++","C++17"]},{"title":"【C++】C++14 的那些新特性","url":"/posts/1184922698/","content":"学习 C++14 的那些新特性\n\n\n\n为了方便指定使用 C++14 来编译代码，本文的测试都是在 linux 下进行的，g++ 版本如下\n$ g++ --versiong++ (GCC) 8.5.0 20210514 (Red Hat 8.5.0-4)\n\n如果你和我一样，也是使用 VSC 来链接 linux 进行代码编写，那一定要记得修改 C++ 插件里面的 CPP 版本，否则默认以 C++11 来进行语法高亮的话，会把 C++11 不支持的语法标红，影响我们学习\n\n\n本文参考 https://zhuanlan.zhihu.com/p/588826142 进行学习;\n官方文档 https://zh.cppreference.com/w/cpp/14\n\n1.lambda 新特性C++14 给 lambda 表达式添加了两个新功能\n\n参数推断（auto）\n参数初始化后捕获（可以在 [] 对某个新参数进行赋值）\n\n先来复习一下 C++11 中学习的 lambda 捕获的基本方式\n[val]：表示值传递方式捕捉变量 val[=]：表示值传递方式捕获所有父作用域中的变量(包括 this)[&amp;val]：表示引用传递捕捉变量 val[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括 this)[this]：表示值传递方式捕捉当前的 this 指针\n\n在 C++14 中，新增的是下面的这种情况\nint a = 30;// [] 中赋值了一个参数// () 中可以使用 auto 关键字来推断参数类型auto func = [x = 3](auto y) &#123;return x + y; &#125;;cout &lt;&lt; func(a) &lt;&lt; endl;\n\n运行测试，可以看到成功输出了结果\n$ makeg++ test.cpp -o test -std=c++14$ ./test33\n\n修改一下类型，也能正常调用\ndouble a = 30.2;auto func = [x = 3](auto y)&#123; return x + y; &#125;;cout &lt;&lt; func(a) &lt;&lt; endl;\n\n$ ./test33.2\n\n如果想将赋值参数和原本的捕获方式一起使用，则需要将  赋值参数  放在 [] 的最  后面\nvoid test_lambda2()&#123;    int a = 10, b = 20;    int c = 1, d = 3, e = 5;    // 赋值的参数要放在 [] 的最后面，捕获方式放在前面    auto func6 = [=, f = 30, g = 40]    &#123;        return (a + b + c + d + e + f + g);    &#125;;    cout &lt;&lt; func6() &lt;&lt; endl;&#125;\n\n$ ./test109\n\n初始化捕获的好处是可以支持  移动捕获  了；不然在 C++11 中，lambda 就只能使用赋值捕获和引用捕获\nstd::unique_ptr&lt;Item&gt; item(new Item());// std::move 改为右值进行赋值后捕获auto func = [m = std::move(item)] &#123; /* do something */ &#125;;\n\n这个新特性的提出，也让 lambda 成功有了和 bind 比拼的能力。在 C++11 中，bind 的优势就是在于  移动捕获  的支持；如今 lambda 也有了这份能力了，我们可以更灵活地根据场景选用 lambda 或者 bind，而不是只能使用 bind 了。\n2. 变量模板 2.1 示例 看清楚这个名字啊！是  变量模板，可不是什么函数模板哈！\ntemplate&lt;class T&gt;T pi = T(3.1415926535897932385L); // variable template// 数字最后的 L 代表这是一个长浮点型void test_value_template()&#123;    cout &lt;&lt; pi&lt;double&gt; &lt;&lt; endl;    cout &lt;&lt; pi&lt;float&gt; &lt;&lt; endl;    cout &lt;&lt; pi&lt;int&gt; &lt;&lt; endl;&#125;\n\n如上就是一个最最最简单的变量模板，我们在传入对应的类型后，他就会转成我们需要的类型\n$ makeg++ test.cpp -o test -std=c++14$ ./test3.141593.141593\n\n2.2 类中使用  当你需要在类中使用模板变量的时候，这个变量必须定义为static；\n因为它是模板，我们还可以接用模板本身就有的特性，将这个模板针对某一个类型进行  特化\nstruct Limits&#123;    template&lt;typename T&gt;    static const T min; // 声明静态成员模板&#125;; template&lt;typename T&gt;const T Limits::min = &#123; &#125;; // 定义静态成员模板，全部使用默认值// 下面三个是模板变量的特化template&lt;&gt;const float Limits::min&lt;float&gt; = 4.5;template&lt;&gt;const double Limits::min&lt;double&gt; = 5.5;template&lt;&gt;const std::string Limits::min&lt;std::string&gt; = &quot;hello&quot;;int main()&#123;    std::cout &lt;&lt; Limits::min&lt;int&gt; &lt;&lt; std::endl;    std::cout &lt;&lt; Limits::min&lt;float&gt; &lt;&lt; std::endl;    std::cout &lt;&lt; Limits::min&lt;double&gt; &lt;&lt; std::endl;    std::cout &lt;&lt; Limits::min&lt;std::string&gt; &lt;&lt; std::endl;    return 0;&#125;\n\n$ ./test04.55.5hello\n\n2.3 和类型转换的区别  这里我又直接定义了一个变量，使用 static_cast 直接转换变量，看看结果会不会有什么区别\n// 数字最后的 L 代表这是一个长浮点型template&lt;class T&gt;T pi = T(3.1415926535897932385L); // 变量模板long double lpi = 3.1415926535897932385L; // 直接定义长浮点型void test_value_template()&#123;    cout &lt;&lt; pi&lt;double&gt; &lt;&lt; endl;    cout &lt;&lt; pi&lt;float&gt; &lt;&lt; endl;    cout &lt;&lt; pi&lt;int&gt; &lt;&lt; endl;    cout &lt;&lt; &quot; ----- \\n&quot;;    cout &lt;&lt; static_cast&lt;double&gt;(lpi) &lt;&lt; endl;    cout &lt;&lt; static_cast&lt;float&gt;(lpi) &lt;&lt; endl;    cout &lt;&lt; static_cast&lt;int&gt;(lpi) &lt;&lt; endl;&#125;\n\n看上去二者的结果完全相同，那么既然可以直接使用变量类型转换，为什么还要新增一个模板变量呢？\n$ ./test3.141593.141593 ----- 3.141593.141593\n\n\n以下内容来自 GPT，我觉得它说的很对\n\n定义一个变量并使用数据转换（类型转换）是一种常见的编程方式，但与变量模板有一些区别：\n\n通用性： 变量模板允许你通过模板参数来生成多个不同类型的变量，从而在不同的上下文中使用。这使得代码更具通用性和可扩展性，因为你可以为多个类型生成相应的变量。相比之下，直接定义变量并使用数据转换通常只适用于特定的一种数据类型。\n模板化： 变量模板是一种模板化的方式来生成变量，它遵循 C++ 的模板机制，这意味着你可以使用模板  特化、部分特化等技术来定制化生成的变量，以满足不同的需求。而使用数据转换时，你必须显式地执行类型转换，这可能会在代码中引入不必要的重复。\n编译时计算： 变量模板通常用于在编译时生成值，因此可以在编译阶段进行类型检查和计算。这有助于提高代码的性能和安全性。而数据转换可能在运行时进行，可能会引入一些运行时开销和类型错误的风险。\n抽象性： 变量模板可以在更高的抽象层次上操作数据，使代码更具表达力和可读性。它允许你以更自然的方式描述某个值与特定类型之间的关系，而不必显式进行类型转换。\n\n总之，变量模板提供了一种更灵活、通用和模板化的方式来生成变量，适用于需要在不同类型上工作的情况。当你需要为多个类型生成特定的变量或值时，变量模板是一种更优雅和强大的选择。\n3.constexpr 限制放宽  在 C++11 中被引入的 constexpr，可以让编译器在编译程序的期间，就将一部分工作完成，不必等到运行期间再做；在 C++11 中，constexpr 的限制很严格，这导致它并不好用：\n\nconstexpr 修饰变量，要求变量必须可以在编译器推导出来\nconstexpr 修饰函数（返回值），函数内除了可以包含 using 和 typedef 指令以及 static_asssert 断言外，只能包含一条 return 语句\nconstexpr 同时可以修饰构造函数，但也会要求使用这个构造函数的时候，可以在编译器就把相关的内容全推导出来\n\n以下是一个比较基础的 C++11 中的用例，给该函数设置了 constexpr 关键字后，该函数就可以在编译期间被计算出结果，再用 static_assert 在编译期间断言结果是否正确；\nconstexpr int factorial(int n) &#123;    return (n &lt;= 1) ? 1 : n * factorial(n - 1);&#125;int test_constexpr1() &#123;    constexpr int result = factorial(5); // 编译时计算阶乘    static_assert(result == 120, &quot;Factorial of 5 should be 120&quot;); // 编译时断言    cout &lt;&lt; result &lt;&lt; endl;    return 0;&#125;\n\n如果在 C++11 中的 constexpr 函数内包含其他语句，编译的时候会报错，翻译过来是该函数内部不是一个 return 返回语句\n$ g++ test.cpp -o test -std=c++11test.cpp: In function ‘constexpr int FuncNew(int)’:test.cpp:96:1: error: body of ‘constexpr’ function ‘constexpr int FuncNew(int)’ not a return-statement &#125; ^\n\nc++14 中，对 constexpr 的限制放宽了，允许使用  循环、if、switch等等语句，但是主旨还是一样的，需要在编译期间就可以计算出全部内容；限制放宽之后，这个关键字便可以更灵活的使用了。\n// 计算前 n 项和，C++11constexpr int Func(int n)&#123;    return n &gt; 0 ? Func(n - 1) + n : 0;&#125;// 计算前 N 项和，C++14constexpr int FuncNew(int n)&#123;    if (n &lt;= 0)    &#123;        return 0;    &#125;    int sum = 0;    for (int i = 0; i &lt; n; ++i)    &#123;        sum += i;    &#125;    return sum;&#125;\n\n4. 二进制变量  可以使用 0b 或者 0B 开头直接定义二进制变量。\nint main()&#123;        int bit1 = 0b1001;    int bit2 = 0B1011;    std::cout &lt;&lt; bit1 &lt;&lt; &quot; &quot; &lt;&lt; bit2 &lt;&lt; std::endl;&#125;\n\n运行结果如下\n$ g++ test.cpp -o test -std=c++14$ ./test9 11\n\n我在测试中发现，当我用 C++11 编译此代码的时候，似乎也没有引发编译错误，难道说 0b 是在 C++11 里面就支持了吗？\n$ g++ test.cpp -o test -std=c++11$ ./test9 11\n\nGPT 给出了 0B 这种二进制变量是在 C++14 中引入的确认，并提到了为什么会出现上述情况；虽然 C++11 看上去编译和运行都没有问题，但我们还是得遵循版本，选用正确的版本进行编译，才能根本上避免错误\n\nC++ 标准通常是向后兼容的，这意味着较新版本的编译器通常会继续支持较旧版本的标准。例如，如果你在使用支持 C++11 标准的编译器（如 g++）时，使用了 C++14 或更高版本的特性，通常不会引发编译错误，因为这些编译器会尽量向后兼容，以保持现有代码的可编译性。\n在你提到的情况下，即使你使用 g++ 编译器以 C++11 标准编译，它仍然可以理解和接受 C++14 引入的二进制字面量特性。这是编译器开发者的一种设计选择，以便使代码的迁移更加平滑。但是，为了遵循最佳实践和保持代码的可读性，当你在使用特定 C++ 标准的功能时，最好将编译器选项设置为该标准的版本，以确保代码的可移植性。\n\n5. 数字分隔符  在日常生活中使用数字的时候，为了更好的可读性，我们会以 3 个数组或者 4 个数组为分割，打一个点\n1,0000,0000 一亿100,000,000\n\nC++14 中，也支持了这样的打点，以方便我们更好的看出大数字的位数\nvoid test_num_div()&#123;    long long big_num1 = 100000000;    long long big_num2 = 100&#x27;000&#x27;000;    long long big_num3 = 1&#x27;0000&#x27;0000;    cout &lt;&lt; big_num1 &lt;&lt; endl;    cout &lt;&lt; big_num2 &lt;&lt; endl;    cout &lt;&lt; big_num3 &lt;&lt; endl;&#125;\n\n需要注意，这样的操作不会对数字本身有任何影响\n$ ./test100000000100000000100000000\n\n在 C++11 中这种语法是不支持的\n$ g++ test.cpp -o test -std=c++11test.cpp:116:29: warning: multi-character character constant [-Wmultichar]     long long big_num2 = 100&#x27;000&#x27;000;                             ^~~~~test.cpp:117:27: warning: multi-character character constant [-Wmultichar]     long long big_num3 = 1&#x27;0000&#x27;0000;                           ^~~~~~test.cpp: In function ‘void test_num_div()’:test.cpp:116:29: error: expected ‘,’ or ‘;’ before &#x27;\\x303030&#x27;     long long big_num2 = 100&#x27;000&#x27;000;                             ^~~~~test.cpp:117:27: error: expected ‘,’ or ‘;’ before &#x27;\\x30303030&#x27;     long long big_num3 = 1&#x27;0000&#x27;0000;                           ^~~~~~\n\n6. 返回值 auto 推导c++14 新增了函数返回值的推导，当返回值声明为 auto 时，编译器会根据你的 return 语句推导出你的返回值类型。\ntemplate&lt;typename T&gt;auto Func(T x, T y)&#123;    return x + y;&#125;int main()&#123;    std::cout &lt;&lt; Func(3, 4) &lt;&lt; std::endl; // 返回值推导为 int    std::cout &lt;&lt; Func(3.1, 4.2) &lt;&lt; std::endl; // 返回值推导为 double    return 0;&#125;\n\n$ makeg++ test.cpp -o test -std=c++14$ ./test77.3\n\n这个推导是有限制条件的\n1、如果有多个推导语句，那么多个推导的结果必须一致\n// 编译报错，第一个 return 推导为 int，第二个 return 推导为 double，两次推导结果不一致auto Func(int flag)&#123;    if (flag &lt; 0)    &#123;        return 1;    &#125;    else    &#123;        return 3.14;    &#125;&#125;\n\n2、如果没有 return 或者 return 为 void 类型，那么 auto 会被推导为 void。\nauto f() &#123;&#125;              // returns voidauto g() &#123; return f(); &#125; // returns voidauto* x() &#123;&#125;             // error: cannot deduce auto* from void\n\n3、一旦在函数中看到 return 语句，从该语句推导出的返回类型就可以在函数的其余部分中使用，包括在其他 return 语句中。\nauto Sum(int i)&#123;    if (i &lt;= 1)    &#123;        return i; // 返回值被推导为 int    &#125;    else    &#123;        return Sum(i - 1) + i; // sum 的返回值已经被推导出来了，所以这里是没有问题的    &#125;&#125;\n\n但是如果还没被推导出来，那就不能使用。\nauto Sum(int i)&#123;    if (i &gt; 1)    &#123;        return Sum(i - 1) + i;    &#125;    else    &#123;        return i;    &#125;&#125;// 编译报错，因为 Sum 的返回值还没有被推导出来，所以还不能使用error: use of ‘auto Sum(int)’ before deduction of ‘auto’\n\n4、不能推导初始化列表。\nauto func () &#123; return &#123;1, 2, 3&#125;; &#125;// 编译报错error: returning initializer list\n\n5、虚函数不能使用返回值推导\nstruct Item&#123;    virtual auto Func();&#125;;// 编译报错error: virtual function cannot have deduced return type\n\n7.[[deprecated]]标记  这个标记的作用是告知其他人，某个函数被弃用了，不允许继续调用该函数；该字段的好处在于，如果一个方法已经在后续不需要使用了，你可以先给他加上这个关键字，然后再进行其他的代码检查，确认无误后，再将这个函数整体清除；\n别人也不需要去检查函数的实现，因为在编译过程中编译器就会告诉你这个函数被弃用；但是编译依旧是成功的！\n[[deprecated]]int test_return_auto()&#123;    std::cout &lt;&lt; Func(3, 4) &lt;&lt; std::endl; // 返回值推导为 int    std::cout &lt;&lt; Func(3.1, 4.2) &lt;&lt; std::endl; // 返回值推导为 double    return 0;&#125;int main()&#123;    test_return_auto();    return 0;&#125;\n\n在编译的时候，编译器会警告你，这个函数已经被弃用了；但这里只是警告，编译依旧成功了，所以最终还是需要程序猿去瞅一眼各个警告到底是什么意思。\n$ makeg++ test.cpp -o test -std=c++14test.cpp: In function ‘int main()’:test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]     test_return_auto();                      ^test.cpp:132:5: note: declared here int test_return_auto()     ^~~~~~~~~~~~~~~~test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]     test_return_auto();                      ^test.cpp:132:5: note: declared here int test_return_auto()     ^~~~~~~~~~~~~~~~\n\n\nstd 库的新特性  以下是 STD 库的新增内容！\n8.std::make_unique这个东西在 cplusplus 网站上找不到释义，所以就去 cpp 的官网 上找了\n\nhttps://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique\n\n该函数定义在 &lt;memory&gt; 头文件中\ntemplate&lt; class T, class... Args &gt;unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);//(1)\t(C++14 起) (仅对非数组类型)template&lt; class T &gt;unique_ptr&lt;T&gt; make_unique(std::size_t size );//(2)\t(C++14 起) (仅对未知边界数组)template&lt; class T, class... Args &gt;/* unspecified */ make_unique(Args&amp;&amp;... args) = delete;//(3)\t(C++14 起) (仅对已知边界数组)\n\n作用是构造 T 类型对象并将其包装进 std::unique_ptr；\n\n\n\n参数\n说明\n\n\n\nargs\n将要构造的 T 实例所用的参数列表。\n\n\nsize\n要构造的数组大小\n\n\n\n构造非数组类型 T 对象。传递参数 args 给 T 的构造函数。此重载只有在 T 不是数组类型时才会参与重载决议。函数等价于：\n\nunique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...))\n\n\n构造拥有动态大小的数组。值初始化  数组元素。此重载只有在 T 是未知边界数组时才会参与重载决议。函数等价于：\n\nunique_ptr&lt;T&gt;(new std::remove_extent_t&lt;T&gt;[size]())\n\n使用示例\nclass test_class&#123;public:    test_class(int a=-1):_a(a)&#123;&#125;    int _a;&#125;;int main()&#123;    std::unique_ptr&lt;test_class&gt; pt = std::make_unique&lt;test_class&gt;(3);    cout &lt;&lt; pt-&gt;_a &lt;&lt; endl;    return 0;&#125;\n\n$ makeg++ test.cpp -o test -std=c++14$ ./test3\n\n9.std::shared_timed_mutex 与 std::shared_lockc++11 引入了多线程线程的一些库，但是是没有读写锁的，因此在 c++14 引入了读写锁的相关实现（头文件 shared_mutex），其实 c++14 读写锁也还不够完善，直到 c++17 读写锁这块才算是完备起来。\nstd::shared_timed_mutex是带超时的读写锁对象，接口还算比较简洁易懂，和之前接触过的其他锁基本一致；内部成员中 lock() 是写锁，lock_shared()是读锁;\nhttps://zh.cppreference.com/w/cpp/thread/shared_timed_mutex\n\nstd::shared_lock是加锁的 RAII 实现，即构造时加锁，析构时解锁；我们使用 shared_lock/unique_lock 来从 shared_timed_mutex 中获取锁的时候，就会自动获取读锁和写锁；\nstd::shared_timed_mutex mutex;void readOperation() &#123;    // 读锁是多人可以获取的，所以要用 shared_lock (读锁)    std::shared_lock&lt;std::shared_timed_mutex&gt; lock(mutex);    std::cout &lt;&lt; &quot;Read operation: &quot; &lt;&lt; sharedResource &lt;&lt; std::endl;&#125;void writeOperation() &#123;    // 写锁互斥获取，用 unique_lock (写锁)    std::unique_lock&lt;std::shared_timed_mutex&gt; lock(mutex);    sharedResource++;    std::cout &lt;&lt; &quot;Write operation: &quot; &lt;&lt; sharedResource &lt;&lt; std::endl;&#125;\n\n10.std::exchangec++14 新增了一个接口std::exchange（头文件 utility），其实这个也并不算是新增的，因为这个接口其实在 c++11 的时候就有了，只不过在 c++11 中作为一个内部函数，不暴露给用户使用，在 c++14 中才把它暴露出来给用户使用。使用方法也很简单。\nint main()&#123;    std::string s1 = &quot;hello&quot;;    std::string s2 = &quot;world&quot;;    std::exchange(s1, s2);    std::cout &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; s2 &lt;&lt; std::endl;    return 0;&#125;// 输出结果world world\n\n我们可以看到，exchange 会把第二个值赋值给第一个值，但是不会改变第二个值。我们来看下它的实现吧。\n/// Assign @p __new_val to @p __obj and return its previous value. template &lt;typename _Tp, typename _Up = _Tp&gt;  _GLIBCXX20_CONSTEXPR  inline _Tp    exchange(_Tp&amp; __obj, _Up&amp;&amp; __new_val)  noexcept(__and_&lt;is_nothrow_move_constructible&lt;_Tp&gt;,    is_nothrow_assignable&lt;_Tp&amp;, _Up&gt;&gt;::value)  &#123; return std::__exchange(__obj, std::forward&lt;_Up&gt;(__new_val)); &#125;  // C++11 version of std::exchange for internal use.template &lt;typename _Tp, typename _Up = _Tp&gt;  _GLIBCXX20_CONSTEXPR  inline _Tp  __exchange(_Tp&amp; __obj, _Up&amp;&amp; __new_val)  &#123;    _Tp __old_val = std::move(__obj);    __obj = std::forward&lt;_Up&gt;(__new_val);    return __old_val;  &#125;\n\n通过注释我们可以明白含义，它的作用是把第二个值赋值给第一个值，同时返回第一个值的旧值。\n除此之外，我们这里说明一个关键的点。exchange 的第二个参数是万能引用，所以说他是既可以接收左值，也可以接收右值的，所以我们可以这样来使用。\nint main()&#123;    std::string s1 = &quot;hello&quot;;    // 第二个值是纯右值    std::exchange(s1, &quot;world&quot;);    std::cout &lt;&lt; s1 &lt;&lt; std::endl;    std::string s2 = &quot;hello world&quot;;    // 第二个值通过 move 语义转成右值    std::exchange(s1, std::move(s2));    std::cout &lt;&lt; s1 &lt;&lt; &quot; | &quot; &lt;&lt; s2 &lt;&lt; std::endl;    return 0;&#125;// 输出结果，注意这里 s2 为空字符串，因为 s2 的东西已经被移动拷贝给 s1 了worldhello world | \n\n11.std::integer_sequence类模板 std::integer_sequence 表示一个编译时的整数序列。在用作  函数模板  的实参时，能推导  参数包 Ints 并将它用于包展开。\nhttps://zh.cppreference.com/w/cpp/utility/integer_sequence\n这个实在是太难懂了，搞不明白是干嘛的，放弃了😥\n12.std::quotedhttps://zh.cppreference.com/w/cpp/io/manip/quoted\n该函数模板位于 &lt;iomanip&gt; 头文件中，用于在输入输出流中处理被引号包围的字符串。它通常用于处理 CSV（逗号分隔值）文件或其他格式，其中字段被引号括起来以处理包含特殊字符（如逗号、换行符等）的情况。\n对于 cout 而言，quoted 会将字符串包围在双引号中输出\nint test_quorted() &#123;    std::string data = &quot;Hello, \\&quot;world\\&quot;\\n&quot;;        // 输出流中使用 std::quoted，会将字符串在 &quot; 内包围输出    std::cout &lt;&lt; std::quoted(data) &lt;&lt; std::endl;    return 0;&#125;\n\n$ ./test&quot;Hello, \\&quot;world\\&quot;&quot;\n\n以下是官方给的一个示例\n#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt; int main()&#123;    std::stringstream ss;    std::string in = &quot;String with spaces, and embedded \\&quot;quotes\\&quot; too&quot;;    std::string out;     auto show = [&amp;](const auto&amp; what) &#123;        &amp;what == &amp;in            ?   std::cout &lt;&lt; &quot;read in     [&quot; &lt;&lt; in &lt;&lt; &quot;]\\n&quot;                          &lt;&lt; &quot;stored as   [&quot; &lt;&lt; ss.str() &lt;&lt; &quot;]\\n&quot;            :   std::cout &lt;&lt; &quot;written out [&quot; &lt;&lt; out &lt;&lt; &quot;]\\n\\n&quot;;    &#125;;     ss &lt;&lt; std::quoted(in);    show(in);    ss &gt;&gt; std::quoted(out);    show(out);     ss.str(&quot;&quot;); // clear the stream buffer     in = &quot;String with spaces, and embedded $quotes$ too&quot;;    const char delim &#123;&#x27;$&#x27;&#125;;    const char escape &#123;&#x27;%&#x27;&#125;;     ss &lt;&lt; std::quoted(in, delim, escape);    show(in);    ss &gt;&gt; std::quoted(out, delim, escape);    show(out);&#125;\n\n输出\nread in     [String with spaces, and embedded &quot;quotes&quot; too]stored as   [&quot;String with spaces, and embedded \\&quot;quotes\\&quot; too&quot;]written out [String with spaces, and embedded &quot;quotes&quot; too] read in     [String with spaces, and embedded $quotes$ too]stored as   [$String with spaces, and embedded %$quotes%$ too$]written out [String with spaces, and embedded $quotes$ too]\n\n在给定的代码中，delim 和 escape 是用于指定自定义的分隔符和转义字符的参数。这些参数是用于 std::quoted 函数的重载形式，允许你指定不同于默认引号的字符来包围字符串，并指定一个不同于默认转义字符的字符来转义引号字符。以下是关于这两个参数的详细解释：\n\ndelim: 分隔符 在第一个用法中，std::quoted 函数使用了三个参数的重载形式：std::quoted(in, delim, escape)。delim 参数用于指定包围字符串的分隔符。通常情况下，std::quoted 使用双引号作为默认分隔符，但在某些情况下，你可能想要使用其他字符来包围字符串，以避免与字符串本身的字符冲突。在你的代码示例中，分隔符 delim 被设置为 $，这意味着字符串会被包围在 $ 字符内。\nescape: 转义字符 escape 参数允许你指定一个字符，用于转义分隔符字符本身。在默认情况下，std::quoted 使用双引号 &quot; 作为转义字符，以确保在字符串中嵌入的引号不会被解释为结束引号。但如果你选择了自定义的分隔符，你可能还需要指定一个不同于默认转义字符的字符来进行转义。在你的代码示例中，转义字符 escape 被设置为 %，这意味着在字符串中，如果你想要表示分隔符 $ 本身，你需要使用 %$。\n\n这部分也不是很容易搞明白它是干嘛的，如果面试官问道了就说我不会吧😭\n","categories":["遇见C++"],"tags":["数据结构","C++","C++14"]},{"title":"【C++】将浮点数每一位拆分并输出","url":"/posts/398857040/","content":"将浮点数每一位拆分并输出\n\n\n1. 问题\n来源 https://ask.csdn.net/questions/7901417\n\n题目要求如下，将浮点数拆分，不允许使用将浮点数整数倍扩大的办法（那样太简单了）\n\n2. 办法2.1 库函数 modfC 语言有一个库函数 modf，可以将浮点数的整数部分和小数部分拆分开来、\n\nhttps://www.runoob.com/cprogramming/c-function-modf.html\n\ndouble modf(double x, double *integer)\n\n其中参数 x 是原有浮点数，参数 integer 是输出型参数，会存放 x 的整数部分。\n函数的返回值是 x 的小数部分\n2.2 代码  第一版本代码如下\n#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string.h&gt;#include &lt;string&gt;using namespace std;int main() &#123;    double num;    cin &gt;&gt; num;    double int_part;    double frac_part = modf(num, &amp;int_part);    string int_str = to_string((int)int_part);// 获取到整数部分并打印    for (char c : int_str) &#123;        cout &lt;&lt; c &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; &quot;. &quot;;    int i = 0;    int n = 2;// 小数点后 n 位    while (i &lt; n) &#123;        frac_part *= 10;        double int_part;        frac_part = modf(frac_part, &amp;int_part);        cout &lt;&lt; (int)int_part &lt;&lt; &quot; &quot;;        i++;    &#125;    cout&lt;&lt;endl;    return 0;&#125;\n这样已经做到了将整数和小数部分给分离打印了\n2.3 精度缺失问题  但是，测试可以看到，小数的最后一位出现了可能会存在的精度缺失\n\n3. 解决  所以还需要用另外一个办法来处理\n#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string.h&gt;#include &lt;string&gt;using namespace std;//https://ask.csdn.net/questions/7901417int main() &#123;    double num;    cin &gt;&gt; num;    double int_part;    double frac_part = modf(num, &amp;int_part);    cout &lt;&lt; &quot;int_part: &quot;&lt;&lt; int_part &lt;&lt;&quot; | frac_part: &quot; &lt;&lt;frac_part &lt;&lt; endl;    char str[10];    sprintf(str, &quot;%.3f&quot;, frac_part); // 将小数部分打印到字符串中    cout &lt;&lt; &quot;str:  &quot; &lt;&lt; str &lt;&lt; endl;    // 打印整数部分    string int_str = to_string((int)int_part);    for (char c : int_str) &#123;        cout &lt;&lt; c &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; &quot;. &quot;;    // 打印小数部分    int n = 2;// 小数点后 n 位    for(int i=0;i&lt;n;i++)     &#123;        // 因为打印到字符串中的数据包含了最开始的 0.        // 前两个字符就是 0. 应该从第三个字符开始打印        cout &lt;&lt; str[2+i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;\n可以看到，问题已解决，符合题目要求！\n\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C++"]},{"title":"【C++】早绑定、析构与多态 | 一道关于多态的选择题记录","url":"/posts/2254346194/","content":"今天在和群友聊天的时候看到了一道很坑的题目，分享给大家\n\n\n1. 看题！先来看看题目\nstruct Dad&#123;public:    Dad()&#123; echo();&#125;    ~Dad()&#123; echo();&#125;    virtual void echo() &#123;        cout &lt;&lt; &quot;DAD &quot;;    &#125;&#125;;struct Son:Dad&#123;public:    void echo() const override &#123;        cout &lt;&lt; &quot;SON &quot;;    &#125;&#125;;Son ss;\n\n请问这个的输出是什么？\nA  &quot;DAD DAD &quot;B  &quot;DAD SON &quot;C  &quot;SON DAD &quot;D  &quot;SON SON &quot;E  编译出错F  运行出错\n\n\n答案是 E，编译出错！\n\n2. 涉及到的知识点 2.1 知识点 先来说说这道题目里面涉及到了什么知识点\n\n多态调用；\n多态重写函数需要满足什么条件；\n类内函数后加 const 的作用；\n类内函数后加 override 的作用；\n什么是早绑定和晚绑定\n\n一个一个复习吧！\n\n多态调用是父类指针 &#x2F; 引用指向子类时，调用虚函数会调用子类重写后的版本\n多态重写函数的条件：函数名 &#x2F; 参数 &#x2F; 返回值都必须相同（注意还有协变）\n类内函数后加 const 修饰的是这个对象的 this 指针，被修饰的函数中无法修改类内成员变量\n类内函数后加 override 是让编译器来严格检查是否构成重载\n早绑定：静态绑定；晚绑定：动态绑定（具体请看 CPP 多态 的博客）\n\n2.2 分析题目  注意看父类和子类中这两个 echo() 函数的区别\nvirtual void echo()&#123;&#125;// 父类void echo() const override &#123;&#125;// 子类\n\n首先需要说明的是，子类函数中 virtual 关键字是可以省略的，但即便省略了，这个函数依旧是个虚函数。\n这里子类的函数中多了 const 修饰，而这个 const 修饰的就是函数中隐含的 this 指针，此时子类中 echo() 函数的参数就发生了变化！\nvirtual void echo(Son* this) &#123; &#125; // 不加 constvirtual void echo(const Son* this) &#123; &#125; // 加 const\n\n正是因为这里的 this 指针出现了 const 的修饰，所以子类的 echo 和父类 echo 的参数类型不同，不构成虚函数重写！再加上 override 关键字的严格检查，会直接编译报错！\n正确的写法是删除子类 echo 中的 const 或者给父类 echo 函数加上 const\n3. 再来看题  好了，坑人的点看完了，再来看个「常规」的，就是把上面的题干改成能编译通过的。此时又应该选谁呢？\nstruct Dad&#123;public:    Dad()&#123; echo();&#125;    ~Dad()&#123; echo();&#125;    virtual void echo() const&#123;        cout &lt;&lt; &quot;DAD &quot;;    &#125;&#125;;struct Son:Dad&#123;public:    void echo() const override &#123;        cout &lt;&lt; &quot;SON &quot;;    &#125;&#125;;Son ss;\n\nA  &quot;DAD DAD &quot;B  &quot;DAD SON &quot;C  &quot;SON DAD &quot;D  &quot;SON SON &quot;\n\n\n编译运行，可以看到，结果是DAD DAD，应该选 A\n3.1 分析  在给 Son 类定义构造函数和析构函数时，没有指定调用父类的对应构造函数和析构函数。因此，在创建 Son 对象 ss 时，会默认调用 Dad 类的构造函数和析构函数。\n由于 Dad 类中的构造函数和析构函数调用了虚函数 echo()，而这个虚函数在子类 Son 中被重写，所以会根据对象类型调用相应的重写函数。然而，在构造函数和析构函数中，虚函数机制不会按照预期工作。\n构造函数中调用虚函数时，会忽略动态绑定机制，直接调用父类的函数版本。因此，在 Dad 的构造函数中调用 echo()，实际上调用的是 Dad 类中的 echo() 函数，而不是 Son 类中的重写版本。\n同样地，析构函数中也会忽略动态绑定机制，直接调用父类的函数版本。所以，在 Dad 的析构函数中调用 echo()，依然调用的是 Dad 类中的 echo() 函数。\n因此，当创建 Son 对象 ss 并打印输出时，会先调用 Dad 类的构造函数并打印 &quot;DAD &quot;，然后调用 Dad 类的析构函数并再次打印 &quot;DAD &quot;。\n3.2 结论  在父类的构造和析构中，对象的版本都被确定为父类的版本，会采用  早绑定  来调用父类自己的函数，而不是子类的重写后的函数；\n简单记忆：父类的构造和析构中如果出现虚函数，只会调用父类自己的函数！\n\n这是因为编译器需要保证正确的构造和析构顺序，如果父类析构里调用子类的虚函数，可能会出现下面的场景\nstruct Dad&#123;public:    Dad()&#123; echo();&#125;    ~Dad()&#123; echo();&#125;    virtual void echo() const&#123;        cout &lt;&lt; &quot;DAD &quot;;    &#125;&#125;;struct Son:Dad&#123;public:    Son() &#123;        _a = new int(3);    &#125;    ~Son() &#123;        delete _a;    &#125;    void echo() const override &#123;        cout &lt;&lt; &quot;SON &quot;;        delete _a;    &#125;private:    int _a;&#125;;Son ss;\n\n如果父类中的析构 echo() 调用子类重写的函数，此时就会出现子类已经被销毁（子类的析构函数早于父类析构调用）的 _a 被二次 delete，两次delete 同一片空间是会报错的！\n所以为了避免这种情况，父类的析构中采用早绑定，子类重写的虚函数不会生效！\n这种行为是为了确保在对象的构造和析构过程中，按照正确的顺序调用各个类的构造和析构函数，避免在对象处于未完全初始化或已部分销毁状态时调用子类的函数。\n\n包括父类的构造也可以这么理解，如果父类构造里面可以调用子类的虚函数，可能会出现两次对一个子类对象进行 new 空间，会产生内存泄露；\n但构造函数还和虚函数表的初始化有关系，此时虚函数表还没有完全初始化，子类对象尚未构造完成，没有多态调用的条件，所以也不能调用到子类重写后的虚函数。\n\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C++"]},{"title":"【C++】类和对象 1：初识类 +this 指针","url":"/posts/2582381960/","content":"不知你在学习 C 语言和 C++ 的适合，曾否听过老师这么讲述这两个语言之间的区别：\n\nC 语言是面向过程的\nC++ 是面向对象的\n\n\n\n我一直不太理解这二者之间的区别，在查阅了一些博客后，发现了一个比较好的解释👉【传送门】\n\n用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。所谓盖浇饭，北京叫盖饭，东北叫烩饭，广东叫碟头饭，就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜，你就浇上什么菜。\n\n本篇博客，就让我们从类和对象开始，渐渐了解什么是“面向对象编程”\n\n感谢你关注  慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n\n[TOC]\n1. 类的引入 1.1 结构体 在 C 语言中，我们可以定义自定义类型：结构体。在 C++ 中对结构体的语法进行了扩充，结构体内部不仅能定义变量，还能定义函数\nstruct Student&#123;\tvoid Print()    &#123;\t\tcout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;\t&#125;\tchar _name[20];    char _sex[8];    int _age;    char _phone[20];&#125;;\n\n1.2class为了和 C 语言里面的结构体作为区分，我们不再用 struct 来指代这种包含函数的自定义类型，而是使用 class 作为它的名字，称之为  类\nclass className&#123; // 类体：由成员函数和成员变量组成&#125;; // 一定要注意后面的分号\n\nclass 为定义类的关键字，ClassName为类的名字，&#123; &#125;中为类的主体，注意类定义结束时后面分号（这一点和结构体相同）\n类中的元素称为类的成员：\n\n类中的数据称为类的属性或者  成员变量\n类中的函数称为类的方法或者  成员函数\n\n2. 类成员的定义  类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 ::作用域解析符指明成员属于哪个类域。\n2.1 函数声明和定义分离  和普通的函数一样，类同样支持声明和定义分离。下面的代码中，我并没有分离函数的声明和定义\n\n成员函数在类里面定义，编译器会默认处理为  内联函数\n\nclass Student&#123;\tvoid Print()    &#123;\t\tcout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;\t&#125;\tchar _name[20];    char _sex[8];    int _age;    char _phone[20];&#125;;\n\n如果需要在 .h 中写入类的定义，类外面的 .cpp 中编写类里面的函数，就需要用到类似于命名空间的使用方法::\nclass Student&#123;\tvoid Print();// 声明函数\t\tchar _name[20];    char _sex[8];    int _age;    char _phone[20];&#125;;\n\n在另外的源文件中定义函数\n#include &quot;Student.h&quot;void Student::Print()&#123;\tcout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;&#125;\n\n当我们编写大型项目的时候，一般都会采用声明和定义分离的方式来编写源码，这样可以更方便他人快速查阅我们的头文件，理解代码的“大纲”\n\n这样看起来好像和以前的方式没啥区别。但当我们引入  访问权限  的概念后，一切都变啦！\n2.2 访问限定符class 的默认访问权限是私有；struct 默认为公有\n\n你不知道什么是访问权限？那就继续往下看👇\n\n我们可以用 public 和private这两个访问限定符来表明某一个具体类型的共有还是私有。它们的最大区别就是在这个  类的外部  能不能访问\n\n\npublic 成员可以在类外面直接使用\nprotected 和 private 修饰的成员只能在类里面访问\n访问权限的作用域是从该访问限定符出现，到下一个访问限定符出现为止\n访问限定符是在编译过程中处理的，并不影响数据在内存上的存放\n\n在前期学习的时候，我们可以认为 protected 和private是相同作用的\nclass Student&#123;public:    // 函数在类里面定义，编译器默认为内联函数    void Print()    &#123;        cout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;    &#125;    void Init(const char * name,const char*sex, int age,const char* phone)    &#123;        strcpy(_name,name);        strcpy(_sex,sex);        _age=age;        strcpy(_phone,phone);    &#125;    // 函数在类里面声明    void Delet();private:    // 这个是对变量的声明    // 变量的声明：没有开辟空间    // 变量的定义：开辟了空间来存放内容    char _name[20];    char _sex[8];    int _age;    char _phone[20];    // 在创建对象的时候定义&#125;;\n\n\n数据和方法分装到一个类里面\n想给你自用访问的（如函数接口）设置为共有\n不想给你访问的（如通讯录每个用户的信息类型）设置为私有\n\n这样可以做到，当函数定义修改之后，只要不修改函数声明，就不需要修改 main 函数中函数的调用！这叫做：高内聚，低耦合\n2.3 封装  为什么会有权限的出现呢？我们可以细想一下下面这个场景：\n\n假设我们编写了一个  数组栈的代码，里面有一个 top 用来标明栈顶的元素位置。一般可以把 top 定义为 0 或者 1，但是这两种方法的函数使用是不同的！如果有那个铁憨憨跑过来，非要把那个 top 的定义给改掉，那整个代码就废掉不能用辣！\n设立私有和公有的初衷，就是为了避免这种情况。开放一些共有函数供类外面访问，这样对整个代码的访问会变得易于管理。当我们自己修改类里面的代码时，只需要做好处理，就不会影响类外面的函数调用（否则就是直接推翻重写了）\n\n这便是我们常常提到的  封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。\n3. 类的实例化  用类类型创建对象的过程，称为类的实例化\n\n类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它\n一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量\n\n类就好比一个毛坯房，现在毛坯房建好了，要想它变得精致，我们还需要在 main 中调用这个类，不然毛坯房就要变成烂尾楼了\nStudent p1;p1.Init(&quot; 牛爷爷 &quot;,&quot; 男 &quot;,58,&quot;13251341680&quot;);p1.Print(); \n\n4. 计算类的大小  一般有 4 种类：包含函数和变量的、只包含函数的、只包含成员变量的、空类\n\n让我们来康康如何计算这些类的大小，解析见注释哦！\n其实只需要记住，空类和只有函数的类会有 1 个字节的空间。计算类的空间的时候不会计算函数大小，成员变量的大小计算遵循  结构体内存对齐  的计算方法就行了！\n#include&lt;iostream&gt;using namespace std;class A1&#123;public:    void func1()    &#123;        int ret=3;        return ;    &#125;&#125;;class A2&#123;&#125;;class A3&#123;public:    char _a;&#125;;\n\n\n#include &lt;iostream&gt;using namespace std; class A&#123;&#125;; int main(void)&#123;    cout &lt;&lt; sizeof(A) &lt;&lt; endl;// 空类是 1    return 0;&#125;\n\n\n\n5.this 指针 5.1 特点 当你用同样的图纸建了很多个屋子后，有没有想过应该如何区分它们呢？\nC++ 在设计这部分的时候，添加了一个 this 指针来解决这个问题：\n\nC++ 编译器给每个“非静态的成员函数“增加了一个隐藏的指针参 数，让该指针指向当前对象 (函数运行时调用该函数的对象)，在函数体中所有成员变量的操作， 都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。\n\n\nthis 指针的类型：类名 * const \n只能在“成员函数”的内部使用 \nthis 指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给 this 形参。所以对象中不存储 this 指针。 \nthis 指针是成员函数第一个隐含的指针形参，一般情况由编译器通过 ecx 寄存器自动传递，不需要用户传递\n\n5.2 显式使用 this就用下面这个函数举例\nvoid Print()&#123;\tcout&lt;&lt;_name&lt;&lt;endl;\tcout&lt;&lt;_sex &lt;&lt;endl;&#125;\n\n实际上，在调用它的时候，编译器会做如下处理\nvoid Print(Student*const this)&#123;\tcout&lt;&lt;this-&gt;_name&lt;&lt;endl;\tcout&lt;&lt;this-&gt;_sex &lt;&lt;endl;&#125;\n\n因为只有这样，才能完整的区分两个不同的类\n\n进一步看看下面这个代码，可以帮助你理解 this 指针\nbool operator==(const Date&amp; d)&#123;       return _year == d._year           &amp;&amp; _month== d._month           &amp;&amp; _day == d._day;&#125;\n\n这是一个日期的比较函数，是操作符重载（后面会讲到）\n你可以看到，这个函数我们传入了一个Date 类型的引用，这是区别于 this 的另外一个类的对象\n如果没有 this，那就很难区分两个变量的_year，于是编译器会把它优化成下面这样，就不会存在无法区分的问题了\nbool operator==(Date*const this,const Date&amp; d)&#123;       return this-&gt;_year == d._year           &amp;&amp; this-&gt;_month== d._month           &amp;&amp; this-&gt;_day == d._day;&#125;\n\n5.3 空指针问题int main()&#123;    int x=10;    // 在程序中，访问 NULL 不会报错，但是解引用 Null 会报错    int*a=NULL;    int*b=&amp;x;    //a=x;//err    *b=20;    return 0;&#125;\n\n#include&lt;iostream&gt;using namespace std;class ta&#123;public:    void Print()    &#123;        cout&lt;&lt;&quot;print ta&quot;&lt;&lt;endl;        //cout&lt;&lt;_a&lt;&lt;endl;    &#125;private:    int _a;&#125;;int main()&#123;    ta* p=nullptr;    p-&gt;Print();   // 可以去访问空指针的函数   // 因为函数只是去调用了类里面的 Print 函数   // 同时传了一个 p 的 this 指针（空指针传参是不会报错的）   // 但是如果你去访问 p 里面_a 变量，就会报运行错误    return 0;&#125;\n\n6. 类中成员函数的处理  除了 this 指针之外，编译器在链接函数名的时候，也做了相应的处理。在 Linux 里面查看下面这串代码的  汇编  代码\n#include&lt;iostream&gt;class Test&#123;public:    void func1(const int* a1,int* k,const int*a2,char arr)    &#123;        *a1+*a2;        func2(a1,k,a2,arr);    &#125;    private:    void func2(const int* a1,int* k,const int*a2,char arr)    &#123;        *a1+*a2;    &#125;&#125;;int main()&#123;    Test t;    int arr1[10];    int arr2[20];    int a=10;    t.func1(arr1,&amp;a,arr2,&#x27;a&#x27;);        return 0;&#125;\n\n可以找到这两个类的成员函数的地址和函数名\n\n方法参考我的这篇博客👉【末影门】\n\n00000000004006da &lt;_ZN4Test5func1EPKiPiS1_c&gt;:000000000040071a &lt;_ZN4Test5func2EPKiPiS1_c&gt;:\n\n可以发现，这两个函数的地址不同，但函数名中并  没有包含它的公有、私有信息 。这也能证明2.2 中写道的“访问限定符是在编译过程中处理的，并不影响数据在内存上的存放”\n\n下面是一个普通函数（不在类里面）的函数名\n\n观察类里面的函数名，可以看到比起普通函数，它还包含了类名，来标明自己是被封装在某个类里面的。同时前缀也从 _Z 变为了_ZH\n\n\n这里 S1_ 的含义是我多次传相同类型参数，查看汇编代码测试出来的\n\n当我把相同传参的函数放在类外面，重新查看汇编代码\n\n000000000040064d &lt;_Z5func3PKiPiS0_c&gt;:\n\n可以看到它发生了一些变化，比如前缀变为了 _Z，函数名后面的E 不见了，S1_变成了S0_\n虽然我现在还不知道前缀 _Z 和_ZH、函数名后面那个 E 分别代表什么含义，但是我们可以看的出，这是编译器在编译链接过程中为了  区分类中函数和类外函数  做的优化\n\n结语  本篇博客是类和对象的第一篇笔记，不知能否帮到你呢\n\n","categories":["遇见C++"],"tags":["Linux","C++","类和对象"]},{"title":"【C++】auto 关键字、范围 for、nullptr 关键字","url":"/posts/1752517657/","content":"本篇博客一起来继续学习 C++ 的语法\n\n\n\n\n\nauto 关键字\nnullptr 关键字\n\n\n\n范围 for\nlinux 如何使用 C++11 规则\n\n\n[TOC]\n0.linux 设置 c++11在 linux 平台下想使用 C++11 标准有两个办法\n方法 1是在 .cpp 文件的最开头加入下面的这个语句\n#pragma GCC diagnostic error &quot;-std=c++11&quot;\n\n但是这个方法哈，我发现加了它之后使用 nullptr 还是会报错，但是 auto 和 typeid 都可以使用了\n方法 2是在编译的时候在加上-std=c++11\ng++ -std=c++11 test.cpp -o test \n\n使用这个方法比较完美\n1.auto 关键字\n\n在 C++11 中，auto 作为一个新的  类型指示符  来指示编译器，auto 声明的变量必须由编译器在编译时期推导而得\n\n简而言之，这个关键字的作用就是自动给变量设置一个数据类型\n1.1 基本使用#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int TestAuto()&#123;     return 10;&#125;int main()&#123;    int a = 10;    auto b = a;    auto c = &#x27;a&#x27;;    auto d = TestAuto();    auto e = &quot;abc&quot;;    char str[20]=&quot;hello auto!&quot;;    auto f =str;        cout &lt;&lt; typeid(b).name() &lt;&lt; endl;    cout &lt;&lt; typeid(c).name() &lt;&lt; endl;    cout &lt;&lt; typeid(d).name() &lt;&lt; endl;    cout &lt;&lt; typeid(e).name() &lt;&lt; endl;//PKC    cout &lt;&lt; typeid(f).name() &lt;&lt; endl;//Pc    //VS 下会打印完整的类型，返回的是字符串    //linux 下只会打印缩写，其中 PKc 代表 pointer(p) to Const(k) Char(c)    // 而如果是字符串，打印的就是 Pc，pointer to Char    return 0;&#125;\n\n在上面的代码中，我们使用了 typeid().name() 来打印变量的类型，使用这个函数需要引用头文件&lt;typeinfo&gt;\n\n可以看到，编译器正确打印出了每一个变量的数据类型，auto 自动判断并给这些变量赋予了数据类型\n\nVS 下 typeid() 函数会打印完整数据类型\nLinux 下只会打印缩写\n其中 PKc 代表pointer(p) to Const(k) Char(c)，也就是const char*\nPK 代表 const 修饰的指针；P 代表指针，如 Pc 是char*、Pi 是int*\n\nauto e; // 无法通过编译，使用 auto 定义变量时必须对其进行初始化\n\n使用 auto 关键字的时候，必须要在定义的时候初始化变量。\n其实这很好理解，本来 auto 就是一个自动根据初始化内容来赋予数据类型的关键字，如果你不给我初始化内容，我哪知道你需要赋值的类型是谁呢？\n\n因此 auto 并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将 auto 替换为变量实际的类型。\n\n1.2 使用细节 ①和指针 &#x2F; 引用同时使用 如图，auto 在处理指针变量的时候，带不带 * 是不受影响的\n\nPi 是 pointer to int，即 int 的指针\n\n\n②在同一行定义多个变量  如果使用 auto 在同一行定义多个变量的时候，前后定义的变量必须是同一个类型的\nauto a=1,b=3;// 可以auto a=1,b=2.4;// 不可以\n\n1.3auto 不能用的地方 ①auto 不能作为数组的声明 比如下面的这种情况，是不行的\nauto arr[]=&#123;1,2,3,4&#125;;\n\n\n②auto 不能用来作为函数的参数和返回值void test(auto a);auto test(int a);\n\n函数的返回值和传参都不能是 auto\n因为这样会给使用者带来极大的误导，我连你的返回值是什么类型都不知道，我用啥来接收？？再用一次 auto 吗？？😂\n\n\n为了避免与 C++98 中的 auto 发生混淆，C++11 只保留了 auto 作为类型指示符的用法\n\n其实 auto 最大的作用还是在 C++11 提供的新式循环中使用👇\n2. 范围 for 循环 2.1 基本用法 在之前，如果我们想遍历一个数组，一般会使用下面的方式\n这是最经典的 for 循环语句，想必你肯定不陌生\n\n但这方法太麻烦了！每次都要弄一个 sizeof 来计算长度，这不纯纯坐牢吗\n\n于是哈，C++11 就利用 auto 关键字提供了另外一个遍历数组的方法\nfor(auto e : arr)       cout &lt;&lt; e &lt;&lt; &quot; &quot;; \n\n没错！就是这么简单的参数设置，就能让 auto 自己打印出数组内的值！\n这也太省事了👍\n\n这里注意哈，如果在 for 里面设置的 e 没有带 &amp; 引用，其对数据内容的更改是不会改变源数组的。你可以理解为这里是临时传了参数给了 e，然后再打印 e 的值\n\n如果想修改数组的内容，给 e 带上引用即可\n\n编译器会自动判断什么时候数组打印完毕，所以你想打印一个字符数组也是没问题的\n\n我是用的这个 vim 配置好像更加智能，因为他把数组中空着的部分也“打印出来了”。实际上编译器  并不会打印空出来的值\n\n这点可以在 for 循环结束后再打印 EOF 来验证\n\n与普通循环类似，可以用 continue 来结束范围 for 循环，也可以用 break 来跳出整个循环。\n另外，直接使用变量类型来操作范围 for 也是可以的\n\n2.2 使用条件  使用范围 for 的时候，必须给定一个准确的范围\n\n在遍历数组的时候，这个范围就是数组的开头和结尾\n对于类而言，应该提供 begin 和 end 的 方法，begin 和 end 就是 for 循环迭代的范围\n\n也就是说，我们必须给定一个数组名，而不能给定一个指针\nvoid TestFor4(int*ptr)&#123;\tfor(auto e : ptr)\t\tcout&lt;&lt;e&lt;&lt;&quot; &quot;;&#125;\n\n比如这种使用方法就是错误的，因为编译器不知道这个数组到底什么时候结束\n\n即便把传参改成数组的形式也是不行的\n\n至于为什么范围 for 里面用的是冒号嘛，好问题，我不知道\n\n2.3 范围 for 会拷贝数据  同时在测试的时候，我还发现原来 STL 库容器里面的  迭代器  遍历的时候，是会把自定义类型拷贝构造一份的\n\n实际上，auto 在进行范围 for 的时候，是会拷贝一份数据给 e 的。\n用引用避免拷贝的代价  想让他不进行这种拷贝，就需要给 auto&amp; 加上引用才可以\n\n下一个知识点！\n\n3.nullptr 关键字 nullptr 是 C++11 引入的新关键字\n3.1NULL在 C 语言中，NULL代表空指针\nint*p1=NULL;\n\nNULL 实际是一个宏，在 c 语言头文件 stddef.h 中，可以看到如下代码：\n#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endif\n\n可以看到，NULL 可能被定义为字面常量 0，或者被定义为无类型指针 (void*) 的常量\n3.2 问题引出  那么问题就来了，如果我在调用函数的时候传了 NULL，编译器究竟会把它识别成 int 类型，还是识别成指针类型呢？\n\n比如在上面的函数重载代码中，编译器就不知道要调用哪一个函数了，除非你给 NULL 来一个 (int*) 强制转换一下\n编译文件会看到如下报错\ntest.cpp|17 col 5 error| call to &#x27;f&#x27; is ambiguous\n\n小码农英语课堂开课啦！今天学习的是ambiguous\n\n\n所以说！C++ 急需另外一个东西的加入来避免 NULL 的这种模糊传参情况\n3.3 使用 nullptr其他需要介绍的就无啦，你只要知道，nullptr 不再是一个代表 0 的值，而是一个专门的关键字，代指空指针的情况，就 OK 啦！\n\n\n最后是几点注意：\n\n在使用 nullptr 表示指针空值时，不需要包含头文件，因为它是 C++11 的关键字 \n在 C++11 中，sizeof(nullptr)=sizeof((void*)0)\n为了提高代码的稳定性，后续写 C++ 代码的时候一律用 nullptr，不再使用 NULL\n\n\n结语  好啦，本篇 C++ 的笔记到这里就结束喽\n有什么问题大家可以在评论提出哈\n","categories":["遇见C++"],"tags":["Linux","C++"]},{"title":"【C++】动态内存管理","url":"/posts/1688214907/","content":"在之前类和对象的博客里面，已经记录过了 C++ 中动态内存管理函数 new 和delete的基本使用。本篇博客是对 C++ 动态内存管理 的进一步细化\n\n\n[TOC]\n1.C&#x2F;C++ 内存分区  这是一个老生常谈的问题了，直接看下面这个图吧！\n\n这里的数据区其实就是  静态区 ，而代码区是 常量区。这里的 BBS 区先暂时 pass 掉。\n要想辨别上面的几个内存分区，可以现来看下面这个代码，你能分的清楚它们都是存在内存的哪一个区域吗？\nint a = 1;// 数据区static int b = 1;// 数据区int main()&#123;     static int c = 1;// 数据区     int d = 1;// 栈     int arr1[10] = &#123;1, 2, 3, 4&#125;;// 栈     char arr2[] = &quot;abcd&quot;;// 栈     char* arr3 = &quot;abcd&quot;;//&quot;abcd&quot; 存在代码区     int* ptr = (int*)malloc(sizeof (int)*4);// 堆     free (ptr);    // 其中，ptr 指针本身是存在栈区的    // 同理，arr3 指针本身存在栈区    // 但是 arr3 指针指向的对象是存在代码区（静态区）&#125;\n\n2.C++ 动态内存管理  在 C 语言中，基本的动态内存管理通过 malloc 和 free 实现\nint* ptr = (int*)malloc(sizeof (int)*4);// 堆free (ptr);\n\n在 C++ 中，对应产生了 new 和 delete，它们比前者更加高级，具有更多特性\n2.1 基本认识 new 和 delete下面是基本的使用方式，想必大家看了之后，是“有手就行”😂\nint*p1=new int;// 开辟一个 int 类型的空间   int*p2=new int(10);// 开辟一个 int 类型的空间，并初始化为 10   int*p3=new int[10];// 开辟 10 个 int 类型的空间   // 注意后两个的括号区别！      delete p1;// 销毁 p1 指向的单个空间   delete p2;// 同上      //delete p3;// 销毁 p3 指向的第一个空间，不能用于数组   delete[] p3;// 销毁 p3 指向的数组\n\n2.2 操作类对象new 相比于 malloc，最大的区别在于处理自定义类型的时候。类和对象就是 C++ 中与 C 语言完全不同的自定义类型。\n我们知道，当你使用类名创建一个对象的时候，编译器会自动调用这个对象的构造函数。那如果我们用 new 来创建一个自定义类型的对象呢？\nclass Stack&#123;private:    int* _a;&#125;int main()&#123;    Stack* p1=(Stack*)malloc(sizeof(Stack));    Stack* p2=new Stack;        return 0;&#125;\n\n这时候的区别就在于\n\nnew 在创建的对象的时候，会自动调用该对象的构造函数\nmalloc 在创建对象的时候，不会调用构造函数\n\n这样就能解释，为什么 C++ 要单独弄出一个 new，而不是继续沿用 C 语言的 malloc 了。因为我们在 class 中定义成员变量的时候，大多数是定义成  私有  的。如果对象在创建的时候没有进行构造，我们很难从外部访问类内部的  私有成员  进行初始化操作。\n所以 new 的出现，让我们能够在堆上开辟对象空间的同时，初始化这个对象。\n不难理解，delete 和 free 的区别也是如此：\n\n当你调用 delete 的时候，编译器会调用类的析构函数\n使用 free 不会调用析构函数，可能造成内存泄漏\n\n\n2.3 对象数组// 申请单个 Test 类型的对象 Test* p1 = new Test; delete p1;  // 申请 10 个 Test 类型的对象 Test* p2 = new Test[10]; delete[] p2;\n\n和内置类型一样，我们也可以方便的使用 new 来实现开辟对象数组\n注意，在 delete 操作的时候，一定要注意匹配问题，不能直接用 delete p2 来释放开辟的数组空间\n\n2.4 给构造函数传参  如果这个类的构造函数是包含参数的话，还可以使用下面这种方式在开辟空间，调用构造函数时传参（注意括号区别）\nTest* p3 = new Test(10);// 给对象 Test 的构造函数传参delete p3;\n\n\n3.operator new&#x2F;delete 函数  看到这个名字，估计你和我一样，会下意识的认为这个是 c++ 中对 new 和 delete 操作符的重载。nope！这两个实际上是 C++ 中实现 new 和 delete 的一部分函数\n为啥说是一部分呢，让我们来康康它的源码\noperator new (std::size_t sz) _GLIBCXX_THROW (std::bad_alloc)&#123;  void *p;  /* malloc (0) is unpredictable; avoid it.  */  if (sz == 0)    sz = 1;  while (__builtin_expect ((p = malloc (sz)) == 0, false))    &#123;      new_handler handler = std::get_new_handler ();      if (! handler)    _GLIBCXX_THROW_OR_ABORT(bad_alloc());      handler ();    &#125;  return p;&#125;\n\n你回复下，这个函数最终使用了 malloc 来开辟空间，只是在这之上，new 还引入了  抛异常  机制\n\nC 语言中，malloc 错误会返回 null 指针\nC++ 中，new 错误会执行抛 bad_alloc 异常操作\n\n不知抛异常是什么？我们可以暂且不用理解它。只需要知道，当 new 失败的时候，控制台会直接报错终止程序，而不是和 malloc 一样，将指针变空指针，从而导致可能出现的解引用空指针操作。\n实际上，当我们 new 一个对象的时候，会执行下面两个函数\noperator new对象的构造函数\n\n在 VS 中打开调试，转到反汇编，你便可以看到编译器 call 这两个函数的操作\n\n再来看看 operator delete 的代码\n\nhttps://cplusplus.com/reference/new/operator%20delete/\n\nvoid operator delete(void *pUserData)&#123;\t_CrtMemBlockHeader * pHead;\tRTCCALLBACK(_RTC_Free_hook, (pUserData, 0));\tif (pUserData == NULL)\t\treturn;\t_mlock(_HEAP_LOCK); /* block other threads */\t__TRY\t/* get a pointer to memory block header */\tpHead = pHdr(pUserData);\t/* verify block type */\t_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));\t_free_dbg(pUserData, pHead-&gt;nBlockUse);\t__FINALLY\t_munlock(_HEAP_LOCK); /* release other threads */\t__END_TRY_FINALLY\treturn;&#125;\n\n我们发现，delete 最终也是通过调用 free 实现的\n\n但是这里的反汇编，我就有点看不懂了。看起来也调用了一个 Stack 函数，姑且认为那个就是 Stack 的析构函数吧\n\n3.1 new 和 delete 的实现原理  看到这里，让我们来总结一下 new 和 delete 的实现原理。\nnew 的原理：\n\n调用 opeartor new 申请空间，错误时抛异常\n如果操作的是自定义类型，则调用构造函数\n\nnew int[N]原理:\n\n调用operator new[]（没错库里面还有一个这个函数）\n在 operator new[] 中实际调用 N 个 operator new 来申请空间\n如果操作的是自定义类型，则还会分别调用 N 次构造函数\n\ndelete 的原理：\n\n在原始空间上调用析构函数，清楚内容\n调用 operator delete 执行对象空间的 free 操作\n\ndelete int[N]的原理：\n\n调用 N 次析构函数\n调用 operator delete[]，实际调用 N 个 operator delete 来释放 N 个对象的空间\n\n编译器在分配内存时通常会在分配的内存块  前面存储一些额外的信息 ，以便在释放内存时 正确计算要释放的空间大小 。这些额外的信息可能包括分配的内存块大小、指向析构函数的指针等。因此，当调用delete 操作符时，编译器可以从所分配的内存块中提取这些信息，并使用它来确定要释放的空间大小。\n3.2 delete 加 [] 和不加的区别\n 1、delete 释放 new 分配的单个对象指针指向的内存\n\n​     2、delete[] 释放 new 分配的对象数组指针指向的内存\n​     3、delete 处理单个类类型，先会调用析构函数，释放它所占资源，然后释放它所占内存空间。\n​     4、delete 处理数组类类型的时候，会对每一个数组对象都调用它们的析构函数，然后再释放它们所占用的内存空间。所以对于类类型的数组如果不调用 delete[], 那就只调用了下标为 0 的对象的析构函数，可能会产生问题。\n​     5、两个都会释放所占内存，对于内置类型不管是数组还是单个对象，都可以混用，没有关系，因为对于内置类型，它只干一件事，就是释放它们所占内存\n​     6、如果对于单个类对象，delete 和 delete[]都可以，因为 delete 是知道它要释放多大空间的，加不加 [] 括号的区别是对不对每个对象调用析构函数，如果只有一个的话，它就调用一次，所以没有关系。\n4. 定位 new定位 new 表达式会在已  分配的原始内存空间  中调用  构造函数初始化  对象\n\n啊嘞，new 不是会自己调用构造函数吗？这个定位 new 有是来干什么的？\n\n查阅了一些我现在看不懂的资料后，了解到，定位 new 的操作多半是配合自己写的  内存池  来进行操作。在之前博客中出现的 Tcmalloc 就是谷歌写的一个内存池\n4.1 什么是内存池？当我们使用 new 或者 malloc 时，是通过编译器向操作系统申请空间\n而内存池就是一个我们写的预先申请内存空间的模块\n这个模块会在执行后，先预先向操作系统要一个相对较大的空间。我们后续的操作就是在这个已经开辟好的空间中再次申请空间来实现的\n因为这样就是从自己的口袋里面拿东西，没有中间商赚差价，效率就会提高不少。\n但是这样就没有了 new 本身自动调用构造函数的优势，需要我们自己来调用构造函数\n4.2 定位 new 的使用  定位 new 的英文叫 placemaent new，要知道，别看到这个英文不知道它啥意思；\nnew(place_address) type或者new(place_address) type(initializer-list)\n\n以下面这个类为例\nclass Stack &#123;public:    Stack(int num = 5)    &#123;        _a = new int[num];        _capa = num;        cout &lt;&lt; &quot;Stack(int)&quot; &lt;&lt; endl;    &#125;    ~Stack()    &#123;        delete[] _a;        _capa = 0;        cout &lt;&lt; &quot;~Stack()&quot; &lt;&lt; endl;    &#125;private:    int* _a;    int _capa;&#125;;\n\n我们先使用 malloc 来模拟没有调用构造函数的情况，再使用定位 new 来调用构造函数\nint main()&#123;    Stack* p= (Stack*)malloc(sizeof(Stack));\tnew(p) Stack; // 如果类的构造函数有参数时，此处需要传参&#125;\n\n可以看到，编译器成功调用了构造函数\n\n\n5. 更多知识点 5.1 malloc 和 new 的区别malloc&#x2F;free 和 new&#x2F;delete 的共同点是：都是从堆上申请空间，并且 需要用户手动释放\n不同的地方是： \n\nmalloc 和 free 是函数，new 和 delete 是操作符\nmalloc 申请的空间不会初始化，new 可以初始化（通过new int(10))\nmalloc 申请空间时，需要手动计算空间大小并传递，new 只需在其后跟上空间的类型即可（其实就是省略了 sizeof 这一步的操作）\nmalloc 的返回值为 void*, 在使用时必须强转，new 不需要，因为 new 后跟的是空间的类型\nmalloc 申请空间失败时，返回的是 NULL，因此使用时必须判空，new 不需要，但是 new 需要捕获异常\n申请自定义类型对象时，malloc&#x2F;free 只会开辟空间，不会调用构造函数与析构函数，而 new 在申请空间后会调用构造函数完成对象的初始化，delete 在释放空间前会调用析构函数完成空间中内存的清理\n\n5.2 内存泄漏  我们知道，当堆区申请的空间没有进行释放的时候，就会出现  内存泄漏，造成内存的浪费，甚至导致操作系统 boom！\n\n\n堆内存泄漏\n\n堆内存指的是程序执行中依据须要分配通过 malloc / calloc / realloc / new 等从堆中分配的一块内存， 用完后必须通过调用相应的 free 或者 delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生堆内存泄漏\n\n系统资源导致的泄漏\n\n系统资源泄漏 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统 资源的浪费，严重可导致系统效能减少，系统执行不稳定。\n\n除了忘记 free 或者 delete 之外，另外的一些情况导致程序提前终止，也会出现内存泄漏\nint main()&#123;    Stack* p1 = (Stack*)malloc(sizeof(Stack));    Stack* p2 = new Stack;            free(p1);    return 1;// 只是做个示例，实际上哪有人这么写代码啊！        delete p2;    return 0;&#125;\n\n比如上面这个函数中，free 之后执行了 return，跳过了 delete 的操作，即导致 p2 的内存没有被释放，出现了内存泄漏\n解决内存泄漏有很多办法，其中最好的办法就是维持一个良好的代码风格，避免出现忘记释放内存的情况！\n5.3 深拷贝  这个麻烦大家移步之前类和对象的博客啦\n\nhttps://blog.csdn.net/muxuen/article/details/124881928?spm=1001.2014.3001.5501\n\n\n结语  本篇博客到这里就结束了\n期末考试其实已经结束 5 天了，我还在摸鱼……呜呜\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【面经】230331 模拟面试记录","url":"/posts/3461978244/","content":"参加了一次模拟面试，是已经工作的学长面试我的。\n记录一下问了哪些问题，括号中为我的回答。\n说起来真该打，我竟然没有录屏 😥 以下基于我自己的回忆，顺序和实际问的顺序并不同\n1. 做了什么项目？因为我还没来得及写 cpp 的项目，于是就说了自己的 python 项目，valorant 游戏商店查询机器人\ngithub.com&#x2F;Valorant-Shop-CN&#x2F;Kook-Valorant-Bot\n\n项目功能描述（主要还是基于 riot 的 api 获取用户信息，对于机器人而言，更多的工作是在展示数据上。刚开始使用的是纯文字的商店结果，后续改成了用 pil 库进行画图）\n有没有参考其他项目（这里我说了和我 bot 功能相同的discord 机器人，表示自己写的没有他的好）\n有没有进行压力测试（我描述了早八是用户高峰期，此时机器人对用户的响应会慢上 1-2s）\n你觉得有什么优化的空间（类对象封装问题，命名规则问题）\n如果把这个项目从 python 改成 cpp，需要做什么\n\n现在想来，我应该提到自己采用了缓存机制，会避免对重复的商店图片二次画图。数据是存在 leancloud 上的。\n2. 智能指针\n种类（我忘记了 weak_ptr）\n特性（主要回答了 RAII，以及不同种类智能指针的特点）\n引用计数怎么实现的\n\n由于我忘记了 weak_ptr，所以也忘记了循环引用问题……\n3. 大文件数据查询问题\n如果有一个 100g 的文件，我需要将文件中内容和已有数据库中进行对比，怎么做？\n我答了采用归并进行外排序，但是没能讲出实际的处理办法（因为我压根没学）\n\n4. 红黑树和 AVL\n原理特性\n红黑树是怎么实现的（这里红黑树我只记住了最长的时间复杂度，平均的忘记了😶‍🌫️）\n平均时间复杂度\n\n5. 排序算法\n说说你知道的排序算法\n时间复杂度\nstd 的 sort 是用什么实现的？（小区间采用插入排序，大区间采用堆排）\n\n6.tcp 三次握手和四次挥手\n三次握手和四次挥手是干嘛的\n讲述这两个过程中的 tcp 链接状态\n为什么不能是 2 次握手\n\n这里因为我刚刚才学习到，所以回答的还算完整\n7. 跳表  没了解过（甚至没听过这个东西），直接跳过了😥学长建议我去学习一下\n8. 多态\n静态多态（函数重载，注意只改返回值不构成重载）\n动态多态（继承和虚函数）\n能不能有虚构造？（不能）能不能有虚析构？（可）\n虚析构的作用（父类指针释放子类对象时，调用子类析构，避免内存泄漏）\n虚函数是怎么实现的？（虚函数表，这部分记不太清了，我瞎编的🤣）\n虚函数表中的地址我可以强制修改吗？（不会）\n\n9. 类\nC 语言 struct 和 C++ class 的区别（C++ 的对象有成员函数，方便调用。我还回答了 C++ 中 struct 默认公有，class 默认私有）\n默认成员函数有几个，作用\n如何实现一个能够在类外访问类内成员的函数？（友元）\n\n10. 模板\n用来干嘛（避免多次重复写一个类，简洁代码）\ntemplate 中 class 和 typename 有什么区别（我回答的是没区别）\n\n11. 进程控制\n操作系统是如何控制进程的（进程 pcb 相关知识，进程地址空间）\n父子进程基本操作\n\n12. 原子性\n什么是原子性\n什么是锁，锁怎么保证原子性\n锁就绪了之后，怎么通知等待的线程（我不确定，回答的是用条件变量）\n\n最后写了一道 OJ\nhttps://leetcode.cn/problems/longest-palindromic-substring/description/\n给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。输入：s = &quot;cbbd&quot;输出：&quot;bb&quot;\n\n我用的是最简单的暴力办法，在面试环节，这么做肯定要扣分的（\nclass Solution &#123;public:    bool isReverse(const string&amp; s,int begin,int end)    &#123;        while(begin&lt;end)        &#123;            if(s[begin]!=s[end])            &#123;                return false;            &#125;            begin++;            end--;        &#125;        return true;    &#125;    string longestPalindrome(string s) &#123;        if(s.size()&lt;2)        &#123;            char a = s[0];            string tmp=&quot;&quot;;            tmp+=a;            return tmp;        &#125;        int i=0,j=0;        int max = 0;        int index[2];        for(i=0;i&lt;s.size()-1;i++)        &#123;            for(j=i+1;j&lt;s.size();j++)            &#123;                bool ret = isReverse(s,i,j);                if(ret &amp;&amp; (j-i)&gt;max)                &#123;                    max = j-i;                    index[0]=i;                    index[1]=j;                    cout&lt;&lt; &quot;i &quot; &lt;&lt; i &lt;&lt; &quot; j &quot; &lt;&lt; j &lt;&lt; endl;                &#125;            &#125;        &#125;        cout&lt;&lt; &quot;index &quot; &lt;&lt;  index[0] &lt;&lt; &quot; - &quot; &lt;&lt;  index[1] &lt;&lt; endl;        string tmp(s,index[0],max+1);        return tmp;    &#125;&#125;;\n\n总结和建议  由于模拟面试只有 1h，写完 oj 之后时间就到了。我感觉我答的挺差的，有好多都记不住了。\n我咨询了学长要不要自己去了解以下 C++17 和 C++23 的新增内容\n学长建议看看《STL 源码剖析》和《c++primer》这两本书，精进一下已有知识\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【面经】230816 云账房一面","url":"/posts/1199148787/","content":"230816 云账房一面\n\n\n1. 什么是移动构造 2. 循环链表如何实现3. 用了那些 stl 容器4. 树的类型 这里问了我 mysql 用的是什么，我答了红黑树。但其实是 B+ 树（没学）\n5.C++11 新特性 6.C++11future 没听说过，得学\n7.linux 进程通信的方式  管道 共享内存  信号量 socket 本地文件\n\n全答出来了，还问了谁最快（共享内存最快）\n然后又问了进程之间如何同步（不会）\ntnnd 现在才想起来。进程同步直接用信号量就可以啊！！！！！我怎么信号量答出来了不知到这玩意是干嘛的呢……说白了还是学艺不精\n8.git 的基本命令  我说了下面这些\ngit add git pushgit commit git loggit reset git rebasegit merge\n\n9. 版本号管理  我答我用了 3 个版本号\n大版本. 功能版本.bug 修复版本\n\n谢谢惠顾  泻药，太多东西没答上来，已经发了感谢信了\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【面经】230913 上海零念科技 CPP 实习生","url":"/posts/2719794733/","content":"230913 上海零念科技 CPP 实习生面试记录\n\n\n上来先做了个自我介绍，然后面试官介绍了他们是做系统进程调度的；\nCPP题目顺序并非实际问的顺序\n1. 类的大小  类的大小和什么东西有关系？\n我答了成员变量和虚函数表\n2. 多态怎么实现的  顺着虚函数表问的，就说了一下动态多态的基本实现方式\n3. 只能在栈上的类  禁止拷贝构造和赋值，构造函数私有化，提供单独函数在栈上开辟空间；\n顺便问了一下动态内存管理的基础形式\n4. 智能指针  哪些类型？有啥区别？weak ptr 怎么解决循环引用问题的？\nweak ptr 的 lock 函数用过吗？有没有办法获取到 shared ptr 的引用计数？\nunique_ptr 可以转成 share_ptr 吗？\n如果要用 C++11 的类型转换，要使用哪一个来进行 unique_ptr 和 share_ptr 的转换？（这个不会，应该是 static_cast）\n定制删除器是干嘛的？\n智能指针线程安全吗？\n拷贝构造 share_ptr 会不会有内存泄漏？\n5. 类型转换C++11 的类型转换，几个，区别是什么？\n指针之间转换要用什么？（不会，答的 static）\ndynamic_cast 父子转换的时候，向上还是向下是安全的？（子转成父是安全的，即向上安全）\n6. 单例  几种类型，怎么实现？\n7. 模板  模板的声明和定义为啥不能分离？（忘记了）\n模板特化是什么？函数模板支持半特化吗？（不支持）\n8.C++ 线程和 async 有啥区别？thread 是类，aysnc 是函数\nasync 有两种用法，一个是立马异步执行，会开一个线程；第二个是延迟同步执行，在使用 future.get 的时候才会执行。\n这部分是在云账房面试的时候问道的，得亏我专门去学了，开心！\n9.C++14 新特性  知道的全说了，auto，lambda 新特性，constexpr（和 c++11 的区别），变量模板，二进制变量，然后还说了最后几个 std 的函数看不明白；面试官人很好，一直说没关系；\n专门问了 constexpr 声明变量和 const 有啥区别（不知道）\n\nGPT 的回答\n\n时间点：constexpr 是在编译时确定值的，而 const 是在运行时确定值的。\n编译期计算：constexpr 变量可以用于编译时期间的计算，比如数组大小、模板参数等需要在编译阶段确定大小的场景。而 const 变量只是表示它的值不可以修改，在编译阶段无法使用 const 变量进行编译期计算。\n初始化：constexpr 变量必须在声明时进行初始化，并且只能使用常量表达式初始化；const 变量可以在声明时初始化，也可以稍后赋值，但赋值后就不能再修改。\n地址：constexpr 变量往往会被编译器优化，可能不会占用内存空间，并且在编译期间被消除。const 变量在运行时分配内存，并且有相应的内存地址。\n但是这两个关键字声明的变量都具有常量属性，不可修改；\n\n\n对 C++17 有没有了解？（无）\n10.stl 用过什么？把常用的 stl 都说了一遍\nstl 线程安全吗？当然不\n11.vector 和 array 区别array 是定长数组，vector 动态开辟\narray 可以使用迭代器，保证代码风格统一\n这里顺便提到了 [] 的重载，面试官问了 vector 里面 at 函数和 [] 重载的区别（at 会抛异常，[]不会）\n12.emplace_back 和 push_back 区别  我说了 emplace_back 能节省一次拷贝的消耗；\n面试官问要怎么使用才能节省这个消耗？使用方式（不会）\nemplace_back 既然高效，为啥没有取代 push_back？（不会，这里我就说了一下设计考虑兼容性的问题）\n13. 初始化列表、构造函数体内初始化、成员变量给缺省值  那个更好？有啥区别？\n引用是没有办法使用缺省值的，只有常量 &#x2F; 普通变量可以用缺省值；\n在 VS2019 里面调试测试了一下运行顺序：\n\n缺省值（会优化成初始化列表）&#x2F; 初始化列表\n函数体内\n\n具体的测试参考 CPP 类和对象默认成员函数，里面详细注明了构造顺序；\n14. 默认构造函数  什么时候可以不自己写构造函数？\n这里没有答全，感觉自己已经被绕晕了\n15.function 和 bind 的作用  如题\n16.final&#x2F;overide&#x2F;explicit作用\nexplicit 忘记了，面试官说没关系，反正也不用🤣\nLinux1. 进程通信  有哪些，这里主要问了共享内存和管道的优劣，使用谁的资源消耗更优（这里问的是资源消耗，不是通信速度）\n\n我答的是因为管道是文件描述符，操作系统需要维护文件和进程之间的关系，所以消耗会高一点；然后共享内存是直接在页表上操作，没有额外的消耗；\n咱也不知道对不对，感觉答案应该是下面这个\n\n\n问有没有用过消息队列（知道这玩意，没用过）\n2. 进程和线程区别  说了资源消耗区别，功能比较隔离的时候适合用进程，还举了个 epoll 的 reactor 模式的例子（我瞎编的，说实话，也不知道对不对）\n3. 开发环境  前期用 vs2019，后期用 vscode+remote ssh；\n面试官问我很多个文件怎么进行编译和管理，我说了 makefile；问有没有用过 cmake（无）\n4. 编译链接过程  这个其实是第一个问的问题，就简单地说了一下；\n5. 动静态库  有啥区别？优缺点？\nThe end没有问网络，也没有写 OJ，也没有问项目；\n这次的面试官很耐心，会引导你回答问题。爱了；\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【面经】230915 上海戎磐网络科技 C/LINUX 实习生","url":"/posts/2553205100/","content":"10 分钟就面完了，堪称急速，面试官说我答的不错；而且上来自我介绍完毕后就问问题，不多比比🤣\n\n\n知识点 1.Linux 下线程互斥怎么实现 加锁，pthread，然后我还提到了 cpp 的原子变量\nhttps://blog.musnow.top/posts/1309150756/\n2.CPP 多态怎么实现  虚函数表，巴拉巴拉\nhttps://blog.musnow.top/posts/3933786088/\n3.CPP 为啥要引入模板  代码更高复用\nhttps://blog.musnow.top/posts/2940029419/\n4.NAT 怎么实现的？转化表，IP 地址替换，巴拉巴拉吧说一大堆\nhttps://blog.musnow.top/posts/3482559497/\n5. 进程通信  老问题了\n6.inet_ntoa 函数知道吗？连续调用会有什么问题？\n这是最后一个问题，面试官说我答的挺好的\n\n我先说了这个函数是用于 16 位 IP 地址和字符串的转换的；\n然后面试官这里问了一个业务上的问题\nprintf(&quot;%s %s\\n&quot;,inet_ntoa(x),inet_ntoa(y));// x 和 y 是两个 ip 地址\n\n这个函数会不会有什么错误的地方？\n\n请注意，这里是面试时候的描述，面试官肯定只能给你描述个大概的，并不会细致到具体的传参应该传什么类型的变量，所以传参 x 和 y 也只是个伪代码，想问的地方不在这里！\n\n这里我说了 inet_ntoa 是采用 static 变量来返回 ip 字符串的，线程不安全，有可能两个调用最终返回了一个相同的 IP 地址，又明说了我不确定；（肯定有问题，不然问你干嘛？）\n\n面试结束了，来测试一下到底是啥情况吧！\n#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123;    struct in_addr ip1;    struct in_addr ip2;    inet_aton(&quot;192.168.3.1&quot;,&amp;ip1);    inet_aton(&quot;10.161.33.42&quot;,&amp;ip2);        printf(&quot;%s %s\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));    return 0;&#125;\n\n运行结果如下，两个 IP 地址返回了同一个，我猜对了；\n$ ./test192.168.3.1 192.168.3.1\n\n为什么呢？打印一下地址，会得到如下输出，两次调用返回了相同的地址，自然打印出来的结果相同；\nprintf(&quot;%x %x\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));//68db1ef0 68db1ef0\n\n对于这个函数而言，它需要给我们返回一个字符串，又必须保证这个字符串能在函数外被正常访问（不能被释放），再加上这是一个 C 语言接口，那么就只有三种方案了\n\n函数里面 malloc，需要用户手动 free\nstatic 变量\n让用户传入一个有效的地址，将数据写入作为输出型参数\n\n第一个方案肯定是不可行的！这相当于官方提供了一个  极其容易导致内存泄漏  的接口！这不得被开发者喷死？比如本题提到的场景里面就是两次 printf 而已，除此之外没有保存这个返回值，更别提 free 了，这里就直接两次内存泄漏了！\nprintf(&quot;%s %s\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));// 如果用 malloc 后的字符串地址做返回值，这里就是两个内存泄漏\n\n第三个方案也不方便，系统依赖用户传入一个数组的入参，我们知道 ipv4 的 IP 地址字符串最长是 3*4+3=15 位，那么如果用户只传入一个 char arr[12] 呢？越界访问的问题怎么解决？相当于系统之中依旧会出现参数不匹配而可能导致的地址访问错误！\n而这个函数本身的工作很简单，完全没必要弄那么复杂；\n最终 linux 系统采用了 static 变量的方式，来返回这个 IP 地址的字符串；man 手册里面是这么说的，直接看最后一句，翻译过来的意思是  后续的调用会覆盖掉前面的值；\n The inet_ntoa() function converts the Internet host address in,  given in network byte order, to a string in IPv4 dotted-decimal notation.   The string  is returned in a statically allocated buffer,which subsequent calls will overwrite.\n\n所以最终我们看到的结果就是两次打印出了相同的 IP 地址；\n这里还涉及到第二个知识点，printf 的传参顺序;\n简单说来就是 printf 是从右往左执行的（其实所有函数的传参都是这样，这也是为什么缺省值要从右边往左给）\nprintf(&quot;%s %s\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));\n\n这里的执行顺序如下\n\nip2 结构体传给函数，转成 ip 地址字符串后存在 static 变量中\nip1 结构体传给函数，转成 ip 地址字符串后存在了 static 变量中，覆盖了 ip2 的结果\n\n最终打印出来的两个字符串都是 ip1 的地址！\n对于 inet_aton 函数而言，正确的调用  办法是每次调用后都取走返回的 IP 地址字符串，可以用 std::string 接收，也可以用 strcmp 拷贝到一个自己定义的字符串数组变量中；\n你学会了吗，骚年？\n\ninet_aton这个函数最早出现于本站的此博客：【Linux】来写一个 udp 的服务端 + 客户端\n\n项目  因为是 cpp 的岗位，所以没有问 python 的机器人项目问题；\n1. 视频点播传一半关闭了怎么解决  两次面试都问到了这个问题，我提到了将新的文件和本地已有文件进行校验，跳过已有数据\n2. 传一半剩下的数据后端怎么处理，什么时候删除？我提到了前后端用 md5 验证来确认视频文件无误，如果有问题，可以设置一个定时器，一小时后删除错误的数据\n3. 用户修改了视频后上传怎么处理？同第一个，进行一定的数据校验，然后再复写没有的数据；\n\n然而这些功能我一个都没有实现🤣\n\n效率  面经还没写完，结果已经出啦，过了初试！但是要线下复试；\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【C++】类和对象 2：默认成员函数 + 操作符重载","url":"/posts/2894176175/","content":"本篇是类和对象的第二站🚌\n主要讲述类的几个默认成员函数，以及  操作符重载\n本篇博客会涉及到很多之前 C++ 专栏里面提到的知识点，建议  连起来观看。\n\n\n\n感谢你关注  慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n\n[TOC]\n默认成员函数  当我们创建一个类的时候，即便类里面啥都不放，都会自动生成下面 6 个默认成员函数\n\n它们都有啥功能呢？且听我一一道来\n1. 构造函数  众所周周知，当我们写 C 语言 的顺序表、链表等代码的时候，一般都会写一个 Init 函数来初始化内容。\nvoid Init()&#123;\ta=(int*)malloc(sizeof(int)*4);\tsize=0;\tcapa=4;&#125;\n\n但是这样有一个缺点，就是不够智能，需要我们自己来调用它进行初始化。\n于是 C++ 就整出来了一个构造函数来解决这个问题\n1.1 特性  构造函数：名字和类名相同，创建类对象的时候编译器会自动调用，初始化类中成员变量，使其有一个合适的初始值。构造函数在对象的生命周期中只调用一次\n构造函数有下面几个特性：\n\n函数名和类名相同\n无返回值\n构造函数可以重载\n对象实例化的时候，编译器会  自动调用  对应的构造函数\n如果你自己不写构造函数，编译器会自己创建一个默认的构造函数\n\n1.2 基本使用  下面用一个队列来演示一下构造函数\nclass Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;// 测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n可以看到，在创建对象 q1 的时候，编译器就自动调用了类中的构造函数，帮我们初始化了这个队列\n\n\n除了上面这种最基本的  无参  构造函数以外，一般写构造函数的时候，我们都会带一个有缺省值的参数，这样可以更好地灵活使用这个队列\nQueue(int Capacity=4)&#123;    _a=(int*)malloc(sizeof(int)*Capacity);    _size=0;    _capa=Capacity;&#125;\n\n调用这种构造函数也更加灵活，我们可以根据数据类型的长度，来创建不同容量的队列，避免多次 realloc 造成的内存碎片\nQueue q1;// 调用无参的构造函数Queue q2(100);// 调用带参的构造函数\n\n多种构造函数是可以同时存在的，不过！它们需要满足函数重载的基本要求\n当你调用一个  无参  的函数，和一个  全缺省  的函数的时候，编译器会懵逼！\nQueue();Queue(int Capacity=4);// 这两个函数不构成重载，会报错\n\n正确的重载应该是下面的情况\nQueue();Queue(int Capacity);\n\n编译器在创建对象的时候，就会智能选择这两个构造函数其中之一进行调用。但是同一个对象  只会调用一个构造函数\n1.3 编译器默认生成的构造函数  上面提到过，如果我们不写构造函数，编译器会自己生成一个。\n但测试过以后，你会发现，这个默认生成的构造函数，好像啥事都没有干——或者说，它把_a _b _c 都初始化成了随机值！\n\n实际上，编译器默认生成的构造函数是不会处理内置类型的\n\n内置类型：int、char、float、double……\n外置类型：自定义类型（其他的类）\n\n在处理的时候，编译器忽略内置类型；外置类型会调用它的构造函数\nclass Date&#123;public:    // 默认构造函数：不传参就能调用的    //1. 全缺省 2. 无参 3. 编译器自动生成    // 可以是半缺省的，但是不实用    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;        _A.Print();    &#125;private:    // 编译器会自动生成构造函数（如果你没有自己写的话）    // 自动生成的构造函数是不会初始化内置类型的    // 内置类型：int,char,double 等等    int _year;    int _month;    int _day;    // 外置类型：自定义类型    // 外置类型会调用它自己的默认构造函数    Queue _A;&#125;;\n\n可以看到，编译器调用了自己的构造函数的同时，还调用了外置类型 Queue 的构造函数，搞定了它的初始化\n\n如果我们去掉 Date 的构造函数，就能看到下面的情况。Queue成功初始化，但是内置类型的年月日都是随机值\n\n一般情况下一个 C++ 类都需要自己写构造函数，下面这两个情况除外\n\n类里面的成员都是自定义类型成员（且有自己的构造函数）\n如果还有内置类型成员，声明时给了缺省值\n\n注：只有类在声明变量的时候才可以给缺省值\n// 下面的情况就不需要写class MyS&#123;    private:      Queue q1;// 自定义类型      Queue q2;      int a=1;// 内置类型声明的时候给了缺省值&#125;;\n\n\n\n1.4 初始化列表  除了上面的方式之外，还有一种构造函数的使用方式为初始化列表\nDate(int year=2022,int month=2,int day=30)    :_year(year),\t_month(month),\t_day(day)&#123;&#125;\n\n\n每个成员变量只能在初始化列表中出现一次\n类中包含以下成员必须在初始化列表中进行初始化\n引用\nconst 成员\n自定义类型成员\n\n\n\n一般情况下，建议使用初始化列表进行初始化。因为对于自定义类型的成员变量，初始化列表的优先级是高于 &#123; &#125; 里面的内容的。\n这里还有非常重要的一点！\n成员变量在类中声明的顺序就是初始化列表的顺序，而并非初始化列表自己的顺序！\n\n怎么理解呢？看下面这个代码\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(month)\t&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n即便我们把 _day 放在了初始化列表的首位，但由于它是在最后声明的。所以构造函数走初始化列表的时候，会依据声明顺序，依次初始化年、月、日。\n\n这会引起什么问题？再来看看一个错误示例\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(_day)&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n当我们用上面这个初始化列表的时候，我们本意是想在初始化完 _day 以后，将 _day 的值赋给 _month。但由于_month 的声明顺序在 _day 之前，所以 _month(_day) 会先执行，此时的 _day 尚为随机值，这就导致月份变成随机值了！\n\n这只是一个示例，实际上肯定不会用天数初始化月数，范围不一样\n\n最好的办法，就是声明顺序和初始化列表的顺序保持一致！\n\n1.5 explicit 关键字  构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有隐式类型转换的作用。\nclass Date&#123;public:    // 正常的构造函数    //Date(int year)    //    :_year(year)    //    &#123;&#125;\t    explicit Date(int year)        :_year(year)        &#123;&#125;private:    int _year;    int _month:    int _day;&#125;；void TestDate()&#123;    Date d1(2018);    // 用一个整形变量给日期类型对象赋值    // 实际编译器背后会用 2019 构造一个无名对象，最后用无名对象给 d1 对象进行赋值    d1 = 2019;&#125;\n\n当我们调用赋值的时候，实际上编译器会先用 2019 构造出一个 date 类型对象，再调用赋值重载（这里还没有写）赋值给 d1。这就是一个隐式类型转换\n如果我们用 explicit 修饰了这个构造函数，那么编译器将不会进行此类隐式类型转换！\n1.6 规范命名类的成员变量  为了更好的使用构造函数，以及区分类内外的函数类型\n一般我们定义类中的成员变量的时候，都会使用一个下划线进行标明_YEAR\n在一些地方，你会看到函数名前面也带了一个_，这一般表明该函数是另外一个函数的子函数，同样是用于区分的。\n\n不同人的代码风格不同，你可以选择你自己喜欢的风格，但不能影响我们程序的正常使用\n\n比如下面这种情况，就会影响类的构造了\nclass Date&#123;public:    Date(int year=2022)    &#123;        year=year;    &#125;private:    int year;&#125;;\n\n请问 year=year 里面的这个 year，到底是成员变量，还是构造函数的传参呢？编译器又双懵逼了\n实际上，编译器在找 year 的时候，会先在当前 &#123; &#125; 中找，找到了传参的 year，就不会去找其他地方的 year 了。所以这个语句实际上是传参过来的 year 自己给自己赋值，编译器会报错。\n1.7 初始化列表 &#x2F; 函数体 &#x2F; 缺省值  在 VS2019 里面测试了一下运行顺序\n\n缺省值 &#x2F; 初始化列表（缺省值会被处理成初始化列表）\n函数体内\n\n在下面的测试用例中，我用注释标出了初始化的顺序\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class inclass &#123;public:\tinclass(int a = -10,const string&amp; info = &quot;dft&quot;) :_a(a) &#123;\t\tcout &lt;&lt; &quot;init class | &quot; &lt;&lt; info &lt;&lt; endl;\t&#125;\tinclass(const inclass&amp; d) &#123;\t\t_a = d._a;\t\tcout &lt;&lt; &quot;init class copy&quot; &lt;&lt; endl;\t&#125;\tint _a;&#125;;class myclass &#123;public:\tmyclass(int c)\t\t:_c(c),// 3    // 6 这里给变量_f 调用了默认构造函数\t\t_g(5,&quot;_g&quot;)// 7\t&#123;\t\t\t_d = 2; // 8\t\t_f = inclass(6,&quot;_f&quot;);// 9 _f 实际上构造了两次\t\tcout &lt;&lt; &quot;init myclass&quot; &lt;&lt; endl;\t&#125;private:\tint _a = -1;// 1\tconst int _b = -3;// 2\tint _c;\tint _d;    int _dd = -5;// 4 \tinclass _e = inclass(4,&quot;_e&quot;); // 5 初始化列表中直接构造\tinclass _f; \tinclass _g;&#125;;int main()&#123;\tmyclass b(50);\treturn 0;&#125;\n\n运行输出如下，其中第二行的 dft 是编译器在初始化列表阶段给变量 _f 调用的默认构造函数（因为 inclass 的构造函数写了全缺省）\ninit class | _einit class | dftinit class | _ginit class | _finit myclass\n\n而且这里我们能看出，即便采用 inclass _e = inclass(4,&quot;_e&quot;); 这种形式给自定义类型赋值，最终编译器也会优化成在初始化列表阶段直接调用构造函数；\n2. 析构函数  和构造函数相对应，析构函数是对象在  出了生命周期  后自动调用的函数，用来爆破对象里的成员（如进行 free 操作）\n生命周期是离这个对象最近的 &#123; &#125; 括号\n2.1 特性\n析构函数名是在类名前加~\n无参数，无返回值\n一个类只能有一个析构函数\n如果你没有自己写，编译器会自动生成一个析构函数\n\n和构造函数一样，编译器自己生成的析构函数不会处理内置类型；会调用外置类型的析构函数\n2.2 基本使用  析构函数的定义和我们在外部写的 Destroy 函数一样，主要执行 free 操作\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue&quot;&lt;&lt;endl;// 测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;    ~Queue()    &#123;        // 析构函数        free(_a);        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;// 测试调用    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n假设我们在 main 函数里面定义了两个对象，你能说出 q1 和 q2 谁先进行析构函数的调用吗？\n\n可以看到，先调用的是 q2 的析构函数\n\n因为在底层操作中，编译器会给 main 函数开辟栈帧\n栈遵从后进先出的原则，q2 是后创建的，所以在析构的时候会先析构\n\n3. 拷贝构造 3.1 特性和使用 拷贝构造是一个特殊的构造函数，它的参数是另外一个 Date 类型。在用已有的类类型对象来创建新对象的时候，由编译器自动调用\n因为拷贝的时候我们不会修改 d 的内容，所以传的是const\n另外，我们必须进行传引用调用！\n\n这里补充说明一下，下面的这个函数，在传参的时候，编译器会去调用 Date 的拷贝构造\nvoid func(Date d);\n\n如果你没有写拷贝构造，或者拷贝构造里面不是  传引用 ，编译器会就递归不断创建新的 对象  进行值拷贝构造，程序就死循环辣\n// 拷贝构造，如果不写的时候，编译器会默认生成一个    // 对内置类型进行值拷贝(浅拷贝)    Date(const Date&amp; d)    &#123;        _year=d._year;        _month=d._month;        _day=d._day;        // 外置类型会调用外置类型的拷贝构造        Queue b(_A);    &#125;\n\n和构造、析构不同的是，编译器自己生成的拷贝构造终于有点用了\n\n它会对内置类型进行按  内存存储的字节序  完成拷贝，这种称为值拷贝（又称  浅拷贝）\n对外置类型会调用它的构造函数\n\n\n3.2 外置类型拷贝问题  但是！如果你使用了外置类型，该类型中包含 malloc 的时候，编译器默认生成的构造函数就不能用辣！\n因为这时候，编译器默认生成的拷贝构造会进行值拷贝，拷贝完了之后，就会出现 q1 和 q2 指向同一个空间的情况。修改 q2 会影响 q1，free 的时候多次释放同一个空间会报错，不符合我们的拷贝构造的要求\n\n注意注意，malloc 不行的原因是，数据是存在堆区里面，拷贝的时候，q2 的 _a 得到的是一个地址，而不是拷贝了新的数据内容。\n\n如果你在类里面定义了一个 int arr[10] 数组，这时候拷贝构造就相当于 memcpy，是可以完成拷贝的工作的。\n\n如何解决这个问题呢？我们需要使用深拷贝\n这里我还没有学到那个地方，后续写深浅拷贝的博客的时候，再来填上这个坑\n\n黑马 16 分钟视频速成完毕，前来填坑\n\n3.3 深拷贝 3.3.1new 和 delete 这里先给大家从 C 语言转到 C++，讲解一下 new 和 delete 关键字，它们分别对应 malloc 和 free\n非常简单！比 malloc 的使用简单多了！\nint main()&#123;    int*p1=new int;// 开辟一个 int 类型的空间    int*p2=new int(10);// 开辟一个 int 类型的空间，并初始化为 10    int*p3=new int[10];// 开辟 10 个 int 类型的空间    // 注意后两个的括号区别！        delete p1;// 销毁 p1 指向的单个空间    delete p2;// 同上        //delete p3;// 销毁 p3 指向的第一个空间，不能用于数组    delete[] p3;// 销毁 p3 指向的数组        return 0;&#125;\n\n怎么样？是不是超级简单！\n\n\n3.3.2 深拷贝实现  在上面写道过，编译器会自动生成拷贝构造函数，完成值拷贝工作。但是队列的代码里面包含  堆区  的空间，需要我们正确释放。这时候就需要自己写一个拷贝构造完成深拷贝👇\n// 拷贝构造Queue(const Queue&amp; q)&#123;    _a=new int[q._capa];// 注意解引用    memcpy(_a, q._a, q._capa*sizeof(int));// 拷贝内容    _size=q._size;    _capa=q._capa;&#125;\n\n用下面这个  队列的代码  来测试深拷贝\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;// 测试是否调用        //_a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;        _a=new int[_capa];    &#125;    // 拷贝构造    Queue(const Queue&amp; q)    &#123;        cout&lt;&lt;&quot;Queue Copy&quot;&lt;&lt;endl;        _a=new int[q._capa];        memcpy(_a, q._a, q._capa*sizeof(int));        _size=q._size;        _capa=q._capa;    &#125;    void Set()    &#123;        for (int i = 0; i &lt; _capa; i++)        &#123;            _a[i] = i + 1;        &#125;    &#125;    void Print()    &#123;        cout&lt;&lt;&quot;this:&quot;&lt;&lt;this&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;_a:&quot;&lt;&lt;_a&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;        for(int i=0;i &lt; _capa;i++)        &#123;            cout&lt;&lt;_a[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    ~Queue()    &#123;        // 析构函数        //free(_a);        delete[] _a;        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;int main()&#123;     Queue q1;    q1.Set();    q1.Print();    cout&lt;&lt;endl;    Queue q2=q1;     q2.Print();    cout&lt;&lt;endl;    return 0;&#125;\n\n3.3.3 深拷贝效果  先注释掉 Queue 的拷贝构造函数析构函数（不然会报错）\n看一看，发现在不写拷贝构造函数的时候，q2 和 q1 的 _a 指向了同一个地址\n\n取消析构函数的注释，可以看到两次释放同一片空间，发生了报错\n\n如果我们把写好的  深拷贝构造  加上，就不会出现这个问题\n\n当你加上给 _a 里面初始化一些数据，以及打印 _a 数据的函数后，就可以看到，不仅 q2 的 _a 有了自己全新的地址，其内部的值也和 q1 一样了\n\n这样写出来的拷贝构造，即便把队列中的 int* _a 修改为 char* 或者其他类型，都能正确完成拷贝工作\n\n这里有一个小点哈，就是打印 char* _a 的地址的时候，咱需要用 printf 而不是 cout，因为 cout 会把_a 直接当作字符串打印了，效果就变成了下面这样\n\n用 printf 来控制输出格式为 %x 即可\nprintf(&quot;_a:%x &quot;,_a);\n\n\n4. 运算符重载 4.1 定义 在讲解赋值运算符重载之前，我们可以来认识一下完整的运算符重载\n\nC++ 为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。\n\n函数名为：关键字 operator运算符，如operator=\n函数原型：返回值类型 operator 操作符(参数列表)，如Date operator=();\n下面有几点注意：\n\n重载操作符必须有一个自定义类型的操作数（即操作符重载对内置类型无效）\n不能通过其他符号来创建新的操作符\n对于类类型的操作符重载，形参比操作数少一个传参（因为有一个默认的形参 this 指针）\n这 5 个操作符是不能重载的：.*、::、sizeof、? :、.\n\n4.2 基本使用  以下是在全局定义的操作符重载，用于判断日期是否相等\nbool operator==(const Date&amp; d1, const Date&amp; d2)&#123;    return d1._year == d2._year;    &amp;&amp; d1._month == d2._month    &amp;&amp; d1._day == d2._day;&#125;\n\n当我们在 main 函数中使用 d1==d2 的时候，编译器就会自动调用该操作符重载\n当然，你也可以自己来传参使用，如if(operator==(d1,d2))\n但是这样非常不方便，和调用一个而普通函数没啥区别，压根算不上操作符重载。所以我们一般是  在类里面  定义操作符重载的\n\n\n当我们把它放入类 Date 中间，就需要修改成下面这样\nbool operator==(const Date&amp; d2)&#123;    return _year == d2._year;    &amp;&amp; _month == d2._month    &amp;&amp; _day == d2._day;&#125;\n\n编译器在调用的时候，会优化成下面这样\nbool operator==(Date* this, const Date&amp; d2)// 显示调用为 d1.operator==(d2);\n而在 main 里面使用的时候，这个重载后的操作符和原本的使用方法完全相同\nDate d1(2022,6,1)Date d2(2022,5,1)d1==d2;// 自动调用操作符重载 d1.operator==(d2);\n\n后续会以  日期类  为样板，实现更多的操作符重载\n\n4.3 赋值运算符重载  因为每一个类都有不同的成员，编译器不可能智能的进行赋值操作。这时候就需要我们自己写一个赋值运算符重载来进行赋值操作了\n以日期类为例，赋值操作其实就是把内置类型成员一一赋值即可\nDate&amp; operator=(const Date&amp; d)&#123;    if(this != &amp;d)// 避免自己给自己赋值    &#123;        _year=d._year;        _month=d._month;        _day=d._day;    &#125;    return *this;&#125;\n\n编写赋值重载代码的时候，需要注意下面己点：\n\n返回值和参数类型（注意要引用传参，不然会调用拷贝构造）\n检测是否自己给自己赋值（避免浪费时间）\n因为返回的是*this，出了函数后没有销毁，所以可以用传引用返回\n一个类如果没有显式定义赋值运算符重载，编译器也会自己生成一个，完成对象按字节序的值拷贝。\n\n如果类中有  自定义类型，编译器会默认调用它的赋值运算符重载（这里也会涉及到深浅拷贝的问题，后面会在深浅拷贝的博客里详解）\n4.4 拷贝构造和赋值重载的调用问题  当赋值操作符和拷贝构造同时存在的时候，什么时候会调用赋值，什么时候会调用拷贝构造呢？\n\n在这两个函数中添加 cout 进行打印提示，可以看到：\n\n如果对象在之前已经存在，就会调用赋值重载\n如果是一个全新的变量在定义的时候初始化，就调用的是拷贝构造\n\n\n5.const 成员5.1 用 const 修饰类的成员函数\n将 const 修饰的类成员函数称之为const 成员函数，const 修饰类成员函数，实际修饰的是该成员函数隐含的this 指针，表明在该成员函数中不能对类的任何成员进行修改。\n\n基本的修饰方法如下，在函数的括号后加 const 即可\nvoid Print()const&#123;\tcout&lt;&lt;_year&lt;&lt;endl;&#125;\n\n实际修饰的是该函数隐含的 this 指针\nthis 指针本身是 Date*const 类型的，修饰后变为 const Date* const 类型\nvoid Print(const Date* const this)&#123;\tcout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;&#125;\n\n\n①实例 - 权限问题  这么说好像有点迷糊，我们用实例来演示一下为什么需要 const 修饰成员函数\nclass Date&#123;public:    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;    &#125;private:    int _year;    int _month;    int _day;&#125;;\n\n假设我们需要在函数中调用 Print 函数，在 main 中是可以正常调用的\nint main()&#123;\tDate d1(2022,5,10);    d1.Print();    return 0;&#125;\n\n但当你用一个函数来进行这个操作的时候，事情就不一样了\nvoid TEST(const Date&amp; d)&#123;\td.Print();//d.Print(&amp;d) --&gt;const Date*&#125;int main()&#123;\tDate d1(2022,5,10);    d1.Print();//d1.Print(&amp;d1) --&gt;Date*    TEST(d1);        return 0;&#125;\n\n这时候我们进行了引用调用，因为在 TEST 中我们不会修改 d1 的内容，所以用 const 进行了修饰\n\n这时候 TEST 中的 d.Print() 函数调用，传入的是 const Date* 指针，指针指向的内容不能被修改\nmain 中的 d1.Print(); 函数调用，传入的是 Date* 指针\n\n于是就会发生权限冲突问题👇\n\n这时候如果我们在函数后面加了 const，就可以避免此种权限放大问题。这样不管是 main 函数还是 TEST 函数中对 Print() 函数  的调用，就都可以正常打印了！\n\n总结一下：\n\nconst 对象  不可以  调用非 const 成员函数（权限放大）\n非 const 对象  可以  调用 const 成员函数（权限缩小）\nconst 成员函数内  不可以  调用其他非 const 成员函数（权限放大）\n非 const 成员函数  可以  独调用其他 const 成员函数（权限缩小）\n\n\n\n\n②什么时候需要使用？众所周周知，const 修饰指针有下面两种形式\n\n在 * 之前修饰，代表该指针指向  对象的内容  不能被修改（地址里的内容不能改）\n在 * 之后修饰，代表该指针  指向的对象  不能被修改（指向的地址不能改）\n\nthis 指针本身就是  类型名 * const类型的，它本身不能被修改。加上 const 之后，this 指向的内容，既类里面的成员变量也不能被修改了。\n知道了这一点后，我们可以合理的判断出：只要是需要修改类中成员变量的函数 ，就不需要在() 后面加 const 修饰\n如果一个函数中不需要修改成员变量，就可以加 const 进行修饰\n注意：如果你用了声明和定义分离的写法，那么声明和定义的函数  都需要加上 const 修饰\n\n③出错提醒  这里有一点需要提醒的是，如果你对某一个函数进行了 const 修饰，那么这个函数里面包含的其他类里面的函数，都需要进行 const 修饰。不然就会报错\n\n出现该报错的情况如下\n\n这个情况也提醒我们，不能在 const 修饰的函数中，调用非 const 修饰的成员函数\n\n5.2 取地址及对 const 取地址重载  最后两个默认成员函数，编译器会自动生成。这两个函数一般都不需要重载，毕竟返回的本身就是一个 this 指针，没有什么奇怪的地方\nclass Date&#123; public :     Date* operator&amp;()     &#123;         return this ;     &#125;         const Date* operator&amp;()const     &#123;     \treturn this ;     &#125;private :     int _year ;      int _month ;     int _day ;&#125;;\n\n只有特殊情况，我们需要让 &amp; 只获取特定内容的时候，才需要手动重载这两个函数\n6. 构造，析构顺序  下面这个代码是一个很好的示例（22.12.31）\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; class A&#123;public:    A(int count)    &#123;        c = count;        cout &lt;&lt; c &lt;&lt; &quot; init this:: &quot; &lt;&lt; this &lt;&lt; endl;    &#125;     ~A()    &#123;        cout &lt;&lt; c &lt;&lt; &quot; des this:: &quot; &lt;&lt; this &lt;&lt; endl;    &#125;private:    int c;&#125;; A a1(1);// 全局 int main()&#123;    A* p = new A(2);// 堆区    A a2(3);// 栈区    static A a3(4);// 静态区     cout &lt;&lt; &quot;#####&quot; &lt;&lt; endl;    delete p;// 堆区被主动释放，肯定是第一个析构的&#125;\n\n最终打印的结果如下\n1 init this:: 00D4E4642 init this:: 0160F5583 init this:: 0133F9D84 init this:: 00D4E46C#####2 des this:: 0160F5583 des this:: 0133F9D84 des this:: 00D4E46C1 des this:: 00D4E464\n\n总结：\n\n构造顺序和写代码的运行顺序一致\n析构时候，堆区若手动 delete，那么肯定是按 delete 的顺序析构的\n自动析构的时候，遵循  栈 - 静态 - 全局  的顺序析构\n\n\n日期类的实现  类和对象第一站🚌中提到过，在项目协作的时候，我们一半要用定义和声明分离的形式来些一个项目。\n\n下面就让我们用日期类来演示这样的操作\n\n在类中定义的函数会被默认设置为内联，我们的目标就是：短小函数在 .h 中定义，长函数在 .h 中声明，在 .cpp 中定义\n至于源码和解析嘛……大家直接来我的 gitee 仓库看吧！【传送门】\n注释写的很详细了⏲有啥问题可以在下面留言哦\n\n特殊：对 &lt;&lt; 和 &gt;&gt; 的重载  这里的 &lt;&lt; 和 &gt;&gt; 主要是在使用 cin 和 cout 的时候需要使用\n①简单了解 io在 cplusplus 网站 上，你可以看到下面这一副图。在使用 cin 和 cout 的时候，我们其实分别调用了不同头文件的内容。\n\ncin：istream\ncout、cerr、clog：ostream\n\n\n实际上，流是一个类型的对象，这个对象完成了输入和输出的操作\n\n流操作是系统 GUI 支持的（了解一下就行，我也不懂）\n\n在 cout 的定义中，你可以看到，实际上 cout 为了完成自动识别类型进行输出操作的工作，对各种类型进行了操作符重载operator&lt;&lt;\n\n显然，这部分重载中不包含自定义类型，所以我们需要来仿照这里的函数，进行重载操作\n这里涉及到了友元函数，在类和对象的下一篇博客中我会写道。不过现在你只需要知道，友元函数是某一个类的朋友，目的是在  类外访问类里面的成员变量\n\n友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加 friend 关键字。\n\n②实现  最后实现的效果如下，头文件中在最前面进行声明\n\n// 这两个是友元函数(因为需要在类外面访问类里面的成员变量)// 注意 cin 和 cout 的不同实现// 因为我们没有完全展开 std namepace，所以写这个函数的时候需要自己指定 std::// 返回值为 ostream 是为了保证多次 coutstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Date&amp; d)&#123;\tout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day &lt;&lt; endl;\treturn out;&#125;//cin 使用的是 istreamstd::istream&amp; operator&gt;&gt;(std::istream&amp; in, Date&amp; d)&#123;\tint year,month,day;    in &gt;&gt; year &gt;&gt; month &gt;&gt; day;    // 这里应该添加一个对日期的正确性判断     if(year&gt;=0        &amp;&amp;(month&gt;=1&amp;&amp;month&lt;=12)        &amp;&amp;(day&gt;=1&amp;&amp;day&lt;=d.GetMonthDay(year,month)) )    &#123;// 判断日期正确性        d._year=year;        d._month=month;        d._day=day;    &#125;    else    &#123;        cout&lt;&lt;&quot;Date err!&quot;&lt;&lt;endl;        exit(0);// 日期错误直接终止程序    &#125;\treturn in;&#125;\n\n程序运行的效果如下，和我们直接使用 cout、cin 是一样的！\n\n当你写了一个离谱日期后，程序也会进行正确的报错\n\n③疑惑解答  你可能会想，干嘛用友元啊，直接在类里面定义这个函数重载不就可以了？\n之所以在外头定义该函数，是因为类里面定义的函数，默认会带有一个隐含的 this 指针传参，作为操作符的左操作数。\n然后你的函数使用就得变成下面这样😱\nd1&lt;&lt;cout;\n\n虽然也能跑起来并完成工作，但这样写也太怪了！\n结语  最后的最后，今天是 5 月 20 日，用下图给大家送上祝福😂\n\n","categories":["遇见C++"],"tags":["Linux","C++","类和对象"]},{"title":"【面经】C++ 面筋记录 (一) 231021","url":"/posts/721187015/","content":"记录部分从牛客网上看到的面筋\n\n\n1. 声明一个 vector，当 vector 过大时会栈溢出吗？答案是会。\n默认申请的 vector 是放在栈区的，栈区的大小 &lt;&lt; 堆区的大小。所以如果我们在栈区中开辟的 vector 中插入巨量的数据，是会导致栈溢出的。\n解决办法是将数据存放到堆区上（使用 new 来创建 vector，而不是直接创建）\n2. 如何实现多次运行程序但只有一个后台进程？使用命名互斥锁，程序启动前申请锁。\n\n如果锁没有被申请，代表是第一个进程，可以正常运行\n如果锁已经被占用，代表已经有进程了，直接退出当前进程（这里要使用 try_lock 避免阻塞等待）\n\n在 Linux 下可以用命名信号量来实现类似进程共享锁的操作。这部分可以去学习进程通信中信号量的部分。\n咨询了发这篇面筋的大佬，说是用文件保存之前进程的 PID，读取出来将之前的进程 kill 掉。\n3. 二分法的前提是什么？\n数据有序\n数据结构支持随机访问\n\n4. 互斥锁和自旋锁有什么区别\n互斥锁是在内核态进行阻塞等待\n自旋锁是在用户态不断循环沦陷检测锁的状态\n\n如果使用场景是较长运行的共享资源，那么就使用互斥锁。避免自旋锁不断沦陷检测消耗大量 CPU 资源。\n如果使用场景的共享资源访问速度快，那么可以使用自旋锁。避免互斥锁频繁进行用户、内核态的转换而造成消耗（这里指其他需要获取锁的进程得进入内核态阻塞等待）\n5.TCP 三次握手除了序列号还发了什么其他东西？\nSYN 和 ACK 这些表记位（具体复习三次握手每个阶段的发送）\n双方服务进程的端口号\n起始序列号和对对方发送的 SYN 报文的应答序列号\nTCP 校验和\nTCP 窗口大小\n\n后续建立连接后，就会根据双方的窗口大小和数据的序列号开始相互通信。\n6. 子类重写父类函数，子类中该函数声明为 private，能否重写成功？用下面这个毛坯房来进行测试，在默认情况下，我们子类的重写函数都和父类有相同的作用域声明符。\nclass A&#123;public:\tvirtual void test()\t&#123;\t\tfoo1();\t\tfoo2();\t\tfoo3();\t&#125;\tvirtual void foo1()\t&#123;\t\tcout &lt;&lt; &quot;A::foo1&quot; &lt;&lt; endl;\t&#125;protected:\tvirtual void foo2()\t&#123;\t\tcout &lt;&lt; &quot;A::foo2&quot; &lt;&lt; endl;\t&#125;private:\tvirtual void foo3()\t&#123;\t\tcout &lt;&lt; &quot;A::foo3&quot; &lt;&lt; endl;\t&#125;&#125;;class B : public A&#123;public:\tvoid test()\t&#123;\t\tfoo1();\t\tfoo2();\t\tfoo3();\t&#125;\tvirtual void foo1() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo1&quot; &lt;&lt; endl;\t&#125;protected:\tvirtual void foo2() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo2&quot; &lt;&lt; endl;\t&#125;private:\tvirtual void foo3() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo3&quot; &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tB b;\tb.test();\tcout &lt;&lt; &quot;----&quot; &lt;&lt; endl;\tA *bb = &amp;b;\tbb-&gt;test();\treturn 0;&#125;\n\n直接运行，结果也符合预期，目前调用的是子类重写后的虚函数，所有函数都重写成功。\nB::foo1B::foo2B::foo3----B::foo1B::foo2B::foo3\n\nclass B : public A&#123;public:\tvoid test()\t&#123;\t\tfoo1();\t\tfoo2();\t\tfoo3();\t&#125;\tvirtual void foo2() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo2&quot; &lt;&lt; endl;\t&#125;protected:\tvirtual void foo3() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo3&quot; &lt;&lt; endl;\t&#125;private:\tvirtual void foo1() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo1&quot; &lt;&lt; endl;\t&#125;&#125;;// 编译能通过，运行输出和上方没区别\n\n我尝试了各种修改作用域的方式，包括将子类中 foo3 函数改成公有，foo1 函数改成私有，都能正常完成重写。这里的作用域声明符只是会改变  子类外是否能调用这个函数，和能否完成虚函数重写无关！\n请注意，如果你将  继承方式由 public 改成 private，那么就无法在类外使用父类指针指向子类对象了\n╰─ g++ test2.cpp -o testtest2.cpp: In function ‘int main()’:test2.cpp:316:11: error: ‘A’ is an inaccessible base of ‘B’  A *bb = &amp;b;\n\n但这依旧不影响子类函数重写父类函数（我的依据是 override 关键字没有报错）\n7.pthread_create 能传入类成员函数的指针吗  可以，但是必须是静态成员函数。\n如果是普通成员函数，那就需要用中间函数来处理，比如下面的示例代码。\n#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;pthread.h&gt;void* threadFunc(void* arg) &#123;    std::function&lt;void()&gt; func = *reinterpret_cast&lt;std::function&lt;void()&gt;*&gt;(arg);    func();    return nullptr;&#125;int main() &#123;    std::function&lt;void()&gt; myFunc = []() &#123;        std::cout &lt;&lt; &quot;Hello from thread!&quot; &lt;&lt; std::endl;    &#125;;    pthread_t thread;    pthread_create(&amp;thread, nullptr, &amp;threadFunc, reinterpret_cast&lt;void*&gt;(&amp;myFunc));    // 等待线程结束    pthread_join(thread, nullptr);    return 0;&#125;\n\n我们可以用 std::function 包装一个类的成员函数，并用 std::bind 将对象的 this 指针绑定到第一个参数上。外层再套上一个用于执行该函数的 void 函数，就能传给pthread_create。\nstd::function的对象不能直接传给 C 语言的函数指针，即便参数对应。会报错。\n8. 函数内 static 变量的作用  在函数内定义一个 static 变量，该变量只会在进入这个函数的时候初始化一次。\n// 计算某一月的 1 号是一年的第几天(不考虑闰年)int DayOfYear(int month)&#123;    static int day_array = &#123;0,31,59,90,120,151,181,212,243,273,304,334&#125;;    return day_array[month];&#125;\n\n比如上面的函数，我们定义的 day 数组就只会在第一次进入这个函数的时候初始化。之后进入这个函数将不在初始化，就节省了初始化一个数组的消耗。出了这个函数后，该数组变量依旧存在。\n请注意，这个 static 语句并不只是变量只初始化一次，实际上这一行语句在该函数中都只会进行一次\nbool checkFlag()&#123;\tstatic bool flag = false;    if(!flag)&#123;        // .. 进行对应修改    &#125;&#125;\n\n比如上面的代码中，如果用正常思维来理解，你会觉得这个 if 语句每次都会判断为真而进入其中。但实际上 flag 的定义只会被定义一次，只要我们在 if 中将其改成了 true，那么下一次进入该函数的时候，flag 依旧会是 true，static bool flag = false;语句会被直接跳过，并不会再次执行赋值！\n我之前理解的就是 flag 变量只会被创建一次，但 static 后的赋值依旧会执行。这个理解是  错误  的！\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【C++】模板：了解泛型编程","url":"/posts/2940029419/","content":"本篇是 C++模板  学习的一些笔记\n\n\n[TOC]\n1. 了解泛型编程  泛型编程，故如其名，是一个泛化的编程方式。其实现原理为程序员编写一个函数 &#x2F; 类的代码示例，让编译器去填补出不同的函数实现\n就好比  活字印刷术，可以灵活调整印刷的板块和内容，比只能固定印刷某一个内容的雕版印刷术效率更高，也让印刷术由此得到了更广泛的应用。\n\n在 C++ 中，函数重载和模板  的出现，让泛型编程得到了实际的应用。其中模板，就是类似活字印刷术一样的存在。\n我们写一个模板，编译器帮我们按照我们写的模板的方式，实例化成不同的函数。相当于替代了一部分操作，节省了代码量。\n2. 函数模板  八八了那么多没用的，让我们来看看函数模板的语法实现吧\n2.1 简单示例  下面是一个最简单的交换函数的例子，通过标明模板参数T，让编译器自动识别函数传参，推测并实例化出不同的函数，供程序来调用。\ntemplate&lt;typename T&gt;void Swap(T&amp; left,T&amp; right)&#123;    T temp = left;    left = right;    right = temp;&#125;\n\n其中，typename是定义模板的  关键字 ，我们可以使用class 来替代，但  不能  使用struct\n\n据我查询到的资料，在模板的定义中使用 typename/class 是没有区别的\n\n\n可以看到，编译器成功调用了 Swap 函数，成功交换了 int 类型和 double 类型；\n2.2 多个模板参数  如果我们尝试把 int 和 double 同时传参给这个函数，会发生什么呢？\n\n编译器会报错，表示  模板参数 T 不明确 ，因为我们在函数模板里面对两个参数的说明都是 T，编译器就认为这两个参数必须是 相同的类型，而传入的 int 和 double 并不相同，于是就报错了。\n这时候我们有几种解决方法：\n\n首先是将 double 强转为 int（反过来亦可）\n\n\n你会发现还是不行，那是因为强转并不支持用 double 引用 int。所以我们把函数传参中的引用去掉，即可正常调用这个函数（暂且不提  传引用和传值  的区别）\n\n\n使用多个模板参数\n\n和函数传参类似，我们也可以设置多个模板参数\n在下图中，我使用 typeid 关键字来打印模板参数 T1 和 T2 的类型。\n\n使用 typeid 需要包含头文件#include &lt;typeinfo&gt;\n\n\n可以看到，实际上函数在调用这个模板的时候，已经实例化了这个函数（即替换模板参数为正确参数类型）这时候在后台处理的时候，其实 Show 函数已经实例化为了下面这个样子\nvoid Show(int left, double right)&#123;    cout &lt;&lt; typeid(left).name() &lt;&lt; endl;    cout &lt;&lt; typeid(right).name() &lt;&lt; endl;&#125;\n\n2.3 模板实例化  上面的方式，是编译器自动帮我们实例化模板参数。在实际使用中，我们还可以自己指定实例化为什么类型\n\n利用强制类型转换\n使用 &lt;int&gt; 直接指定实例化为 int 类型（显式实例化）\n\n\n使用第二种方式的时候，编译器会对另外一个不匹配的参数进行  隐式类型转换。如果转换不成功，或者该参数不支持转换，则会报错。\n另外注意的是，函数模板参数 T 同样可以用来作为返回值，但是  不能通过返回值来推断参数 T 的类型 。比如下面这个函数，我们在使用的时候就需要 直接 &lt;int&gt; 指定  模板参数 T，而不能写一个 int* ptr=test(10)，让编译器通过 “返回值是 int* 接收的，所以函数模板参数 T 是 int”来推断。\ntemplate&lt;typename T&gt;T* test(int num)&#123;\treturn new T[num];&#125;int main()&#123;    int* p = test(10);// 错误    int* p = test&lt;int&gt;(10);// 正确    return 0;&#125;\n\n函数模板支持给予类型缺省值  当一个参数不确定的时候，函数模板的参数是支持给予缺省值的\n// 传递一个类型做为缺省值template&lt;typename T=char&gt;T* test(int num)&#123;\treturn new T[num];&#125;\n\n比如这样，当我们没有直接指定的时候，编译器就会将 T 作为 char 类型，返回一个 num 大小的 char（一个字节）的空间\n注意：当有多个模板参数时，缺省值需要从右往左给，否则会出现类型匹配不上而无法调用的问题；这点和函数参数缺省值相同。\n函数模板中函数的传参也支持缺省值template&lt;typename T1&gt;void Add(T1 left, T1 right=10)&#123;    cout &lt;&lt; &quot;Add temp &quot;&lt;&lt; typeid(left).name() &lt;&lt; &quot; &quot; &lt;&lt; typeid(right).name() &lt;&lt; endl;    cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;&#125;int main()&#123;    int a=1;    Add(a);&#125;\n\n在这种情况下，编译器会正确调用该函数模板\n\n2.4 模板和普通函数同时存在（重载）以 Add 函数为例，在函数模板存在的同时，我们还可以单独写一个 int 类型的 add 函数。这都归功于  函数重载  的存在。\n同时，我们还可以使用 &lt;int&gt; 来指定函数模板重载为已存在的 Add 函数。因为本质上这两个函数是不同的，并不会冲突。\n\n函数在调用的时候，首先会去调用已经存在的函数。当参数和已存在的函数不匹配时，才会调用函数模板；\n而有 &lt;int&gt; 直接指定了模板参数类型的函数调用，自然也是会调用函数模板实例化出来的函数。\n2.5 函数模板不支持定义和声明分离  一般情况下，我们都会在  头文件  中声明函数，在  另外一个源文件  中定义函数。\n但是模板是不支持这么做的！严谨来说，是不支持在不同文件中声明和定义分离，同一个文件是可以的。\n分了两个文件的时候，编译器会报错 链接错误，比如如下 VS2019 的报错\nerror LNK2019: 无法解析的外部符号……\n\n所以我们需要将函数模板的声明和定义放在一个头文件中。在部分使用场景，会使用 .hpp 后缀，来表示这个头文件是包含了函数定义的（即 .h 和 .cpp 的集合体）。\n\nc&#x2F;cpp 中对头文件的包含并没有硬性的后缀要求，我们设置为 .h/.hpp 只是一个约定。\n\n需要注意，这并不是一个硬性要求，你也可以直接使用.h，并将声明和定义放入其中。\n\n模板为什么不支持定义和声明分离？\n\n因为单独的 .h/.hpp 声明会在源文件顶部被编译器展开，而此时函数模板就会开始正常推演参数，并call 函数名；\n但编译器并没有找到这个函数名所对应函数的具体实现，而在另外一个文件中（实现在另外一个函数里面），编译器又不知道你这个函数模板的声明需要  实例化成什么类型的函数，那也没有办法成功进行实例化。\n最终就导致 call 了一个  没有地址  的函数，链接的时候肯定就找不到函数的地址，产生了符号表的  链接错误；\n\n有无解决办法？\n\n其实是有的，我们可以在  模板函数定义  的.cpp中对我们需要使用的函数进行显式  实例化指定.\n // 头文件// 声明template&lt;typename T1&gt;void Add(T1 left, T1 right);// 源文件// 定义//template 不能被省略！每次都须写上template&lt;typename T1&gt;void Add(T1 left, T1 right)&#123;    cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;&#125;// 在源文件中显式实例化// 这就相当于告诉编译器这两个碗需要装什么菜// 编译器才能正确帮我们实例化这个函数，并成功编译链接templatevoid Add&lt;int&gt;(int left, int right);templatevoid Add&lt;double&gt;(double left, double right);\n\n模板  显式实例化  需要对我们要用的所有类型的函数模板进行实例化，比如你需要用 double 类型，只显示实例化了 int 类型是不行的，依旧会报错。\n这就好比你只告诉厨子做 10 个人的饭，结果来了 20 个人。那剩下的 10 个人肯定是吃不上饭的。因为你没有告诉厨子（编译器）到底要来多少个人干饭。\n这样感觉非常多余……对吧？写多了还容易眼花。所以还是老老实实把声明和定义放在  同一个文件  里面吧！\n3. 类模板  类模板的基本形式如下，这里作为一个小区分，我用 class 来当作模板参数名。实际上 typename 也是可以的\ntemplate&lt;class T1, class T2, ...&gt;class 类模板名&#123;// 类内成员定义&#125;;     \n\n3.1 简单示例  下面用一个非常简单的  顺序表  代码来演示一下类模板\ntemplate&lt;class T&gt;class List&#123;public:    List(int capacity = 10)        : _a(new T[capacity])        , _size(0)        , _capa(capacity)    &#123;&#125;     ~List();    T&amp; operator[](int pos)    &#123;        assert(pos &lt; _size);        return _a[pos];    &#125;private:    T* _a;    int _size;    int _capa;&#125;;// 类模板中函数放在类外进行定义时，需要加模板参数列表// 还必须要指定类的声明作为函数的作用域template &lt;class T&gt;List&lt;T&gt;::~List()&#123;    delete[] _a;    _size = _capa = 0;&#125;\n\n可以看到，通过显式实例化类模板的方式，我们成功让这个类模板变成了两个不同类型的顺序表\n\n3.2 成员函数声明和定义分离  其中需要注意的是析构函数，声明和定义分离的时候（同一文件），在定义的时候也需要加上模板参数\n// 类模板中函数放在类外进行定义时，需要加模板参数列表template &lt;class T&gt;List&lt;T&gt;::~List()&#123;    delete[] _a;    _size = _capa = 0;&#125;\n\n个人觉得这样也非常麻烦，既然模板最好是声明和定义放在  同一个文件，那还不如直接将类的成员函数直接定义到类内部。多省事！\n\n如果是类的声明和定义放在  不同文件  中，显式实例化方式如下\n\ntemplateclass List &lt;int&gt;;templateclass List &lt;double&gt;;\n\n需要什么类型的类，就得实例化这个类型。\n\n以下是模板进阶的内容，源码仓库  GITEE\n\n4. 非类型模板参数  上面我们接触到的，都是类型模板参数。还有另外一种模板参数是非类型模板参数。\n\n类型模板参数：给的模板参数是一个类型\n非类型模板参数：给的模板参数是一个常量\n\n比如看看stl 中的 array 容器，它的声明是下面这样的\ntemplate &lt; class T, size_t N &gt; class array;\n\n其中第二个参数 size_t N就是一个非类型模板参数\n4.1 什么场景需要非类型模板参数？用一个栈来作为栗子，不考虑动态内存管理 。我们可以通过define 一个栈的空间大小，来实例化一个 int 类型的栈\n#define STACK_SIZE 100// 静态栈class Stack1&#123;    int _st[STACK_SIZE];    int _top;&#125;;\n\n为了让这个栈能自适应的实例化出不同  成员类型  的栈，C++ 提供了类型模板参数\n#define STACK_SIZE 100// 模板栈template &lt;class T&gt;class Stack2&#123;    T _st[STACK_SIZE];    int _top;&#125;;\n\n这两个栈实例化的方式是下面这样，其中第一个栈是已经确定了是 int 类型，而第二个栈可以被实例化出任何我们想要的类型。\nint main()&#123;    Stack1 st1;    Stack2&lt;int&gt; st2;    Stack2&lt;double&gt; st3;    return 0;&#125;\n\n不过，即便已经有了模板参数，我们还是没有办法做到，让其中一个栈是 100 个成员的空间，另外一个栈是 30 的空间；这是因为空间在初始化的时候就已经被 define 替换了，并开辟了定长的空间。\n动态内存管理  的时候，是可以通过构造函数来解决到底实例化多少空间的问题。但现在假设我们需要的就是一个定长的栈，那么动态内存管理就无能为力了。\n这时候，非类型模板参数  就出场了，在这种场景下，我们可以通过模板 l 传递参数，来确定栈内空间的大小；\n// 动态栈template &lt;class T, size_t N&gt;class Stack3&#123;    T _st[N];    int _top;&#125;;\n\n这就给了我们在使用模板实例化对象的时候，将一些参数像函数传参一样提供给这个类，作为其实例化的地基的能力\nStack3&lt;int, 30&gt; st4;Stack3&lt;double, 100&gt; st5;\n\n编译通过无报错\ng++ test.cpp -o test -std=c++11\n\n将成员变量设置成公有，用 sizeof 能观察到这两个数组的大小和预期相符\ncout &lt;&lt; sizeof(st4._st) &lt;&lt; endl;cout &lt;&lt; sizeof(st5._st) &lt;&lt; endl;\n\n输出结果\n120800\n\n非类型模板参数不可被修改template &lt;class T, size_t N&gt;class Stack3&#123;public:    void modify_n(int n = 10)    &#123;        N = n; // 尝试修改模板参数    &#125;    T _st[N];    int _top;&#125;;\n\n当我们添加了一个修改 N 的函数，并尝试调用它的时候，编译会报错\ng++ test.cpp -o test -std=c++11test.cpp: In instantiation of ‘void Stack3&lt;T, N&gt;::modify_n(int) [with T = int; long unsigned int N = 30]’:test.cpp:45:21:   required from heretest.cpp:28:11: error: lvalue required as left operand of assignment         N = n; // 尝试修改模板参数         ~~^~~make: *** [makefile:2: test] Error 1\n\n报错的意思是 = 操作符需要一个可被修改的左值。这便告诉我们，非类型模板参数是一个 const 常量，是不能被修改的。\n4.2 STL 的 Array回过头来看 stl 的 array，此时就能理解这个非类型模板参数的作用了；\n在声明中，第二个模板参数已经指定了参数类型为size_t，此时需要给 N 传入的值就是一个确定的无符号整数，作为 array 容器的空间大小；\ntemplate &lt; class T, size_t N &gt; class array;\n\n因为 array 是一个固定大小的数组容器，并不像 vector 那样可以实现扩容操作。\n而且 array 开辟的空间在栈上，vector在堆上（堆的空间大小远大于栈）\nArrays are fixed-size sequence containers\n\n那么 array 这个容器的作用是什么呢？\n\n我们确定知道需要使用多少长度的场景\narray对标的应该是原生数组，和 vector 相比，其优势基本没有。\narray相比直接使用定长数组，其封装了迭代器，能使用迭代器来进行参数的访问。能保证 array 和其他 STL 容器访问的代码的统一性。\narray因为有封装operator[]，所以有预先写好的越界检查；而直接使用 a[100] 原生数组，越界检查是不确定的。\n\n不过，这类封装和 vector 相比就尽显颓势了，所以在日常编码中 array 使用的频率很低\n4.3 非类型模板参数类型限制// 非类型模板参数只能用整数template &lt;class T, double N&gt;class Stack4&#123;public:    T _st[N];    int _top;&#125;;\n\n如果你想使用除了整数以外的类型作为非类型模板参数，包括浮点数和字符串，都是不可以的；\n但是 char 类型都是可以的（字符底层是 1 个字节的整数）\n\n\n5. 模板的特化  在绝大多数场景中，模板提供的这两个特性已经可以帮助我们完成很多工作。但在一些特殊情形下，模板的特化就没有我们想象中的那么美好了。\n5.1 问题引出template &lt;class T&gt;bool Less(T left, T right)&#123;    return left &lt; right;&#125;int main()&#123;    double t1 = 33.23;    double t2 = 26.32;    cout &lt;&lt; Less(t1, t2) &lt;&lt; endl;    cout &lt;&lt; Less(3, 4) &lt;&lt; endl;    return 0;&#125;\n\n比如上面的代码中，我们使用一个模板参数来进行两个相同类型之间的比较，输出的结果与预期相符\n01\n\n引入我们自己写的日期类（类中封装了对大小比较的重载）也是可以使用的\n   Date d1(2023,3,1);   Date d2(2023,6,4);// 输出为 1   cout &lt;&lt; Less(d1,d2) &lt;&lt; endl;\n\n但如果用指针呢？问题就出现了！\nint main()&#123;    Date d1(2023,3,2);    Date d2(2023,3,1);    // 正确判断，输出 0    cout &lt;&lt; Less(d1,d2) &lt;&lt; endl;    Date* pd1 = new Date(2023,3,2);    Date* pd2 = new Date(2023,3,1);    // 错误判断，输出 1    cout &lt;&lt; Less(pd1,pd2) &lt;&lt; endl;    return 0;&#125;\n\n编译运行后，发现指针处输出的结果是 1，即 pd1&lt;pd2成立！\n$ ./test01\n\n这是因为，在内部的比较是直接比较的这两个 date* 的指针，其比较的是这两个指针的地址大小！\nDate* pd2 = new Date(2023,3,1);Date* pd1 = new Date(2023,3,2);// Date* pd2 = new Date(2023,3,1);cout &lt;&lt; Less(pd1,pd2) &lt;&lt; endl;\n\n如果让 pd2 这个更小的日期在 pd1 之前被 new，那输出的结果又变成 0 了；我们也能确认这个输出的结果，并非预期的日期比较结果\n$ ./test0\n\n5.2 模板特化 5.3.1 函数模板特化 针对这种情况，我们需要进行一些特殊化的处理；\ntemplate &lt;class T&gt;bool Less(T left, T right)&#123;    return left &lt; right;&#125;// 对 Less 函数针对 Date* 的指针进行特殊化处理template &lt;&gt;bool Less&lt;Date*&gt;(Date* left, Date* right)&#123;    return (*left) &lt; (*right); // 使用类内大小比较的重载    // 这里可以做任何处理，可以理解为是专门写的函数&#125;\n\n处理之后的函数再进行比较，输出的结果就是正确的了\nDate* pd1 = new Date(2023,3,2);Date* pd2 = new Date(2023,3,1);cout &lt;&lt; Less(pd1,pd2) &lt;&lt; endl; // 输出为 0\n\n可以将这样的特化当作一种特殊的函数重载；\n\n那么函数模板是否支持后文中类模板一样的半特化呢？\ntemplate &lt;class T&gt;bool Less&lt;T*&gt;(T *left, T *right)&#123;    cout &lt;&lt; &quot;T*&quot; &lt;&lt; endl;    return (*left) &lt; (*right);&#125;\n\n并不支持！vscode 就会报错告知我们，编译也无法通过\n\ng++ test.cpp date/date.cpp -o test -std=c++11test.cpp:81:32: error: non-type partial specialization ‘Less&lt;T*&gt;’ is not allowed bool Less&lt;T*&gt;(T *left, T *right)                                ^make: *** [makefile:2: test] Error 1\n\n要像实现对指针的操作，反而得单独写一个像下面一样的模板；\n需要注意，这个并不是模板特化，而是一个和原本的模板完全独立的函数模板，二者构成函数重载关系了（将原本的函数模板删除后，依旧可以编译通过并正常运行，就可以证明这个函数模板和原有函数模板无关）\ntemplate &lt;class T&gt;bool Less(T *left, T *right)&#123;    cout &lt;&lt; &quot;T*&quot; &lt;&lt; endl;    return (*left) &lt; (*right);&#125;\n\n此时 date 和 int 的指针都会走这个模板，而不会关注原本对 Date* 特化后的模板\n#include &quot;date/date.h&quot;template &lt;class T&gt;bool Less(T left, T right)&#123;    return left &lt; right;&#125;// 对 Less 函数针对 Date* 的指针进行特殊化处理template &lt;&gt;bool Less&lt;Date *&gt;(Date *left, Date *right)&#123;    cout &lt;&lt; &quot;date*&quot; &lt;&lt; endl;    return (*left) &lt; (*right); // 使用类内大小比较的重载    // 这里可以做任何处理，可以理解为是专门写的函数&#125;template &lt;class T&gt;bool Less(T *left, T *right)&#123;    cout &lt;&lt; &quot;T*&quot; &lt;&lt; endl;    return (*left) &lt; (*right);&#125;void test_less()&#123;    Date *pd1 = new Date(2023, 3, 2);    Date *pd2 = new Date(2023, 3, 1);    cout &lt;&lt; Less(pd1, pd2) &lt;&lt; endl;    int* pi1 = new int(3);    int* pi2 = new int(1);    cout &lt;&lt; Less(pi1,pi2) &lt;&lt; endl;&#125;\n\n输出结果\nT*0T*0\n\n在遇到特殊情况的时候，函数模板直接实现一个特定类型的特化，或者实现一个完全不同的函数模板就可以了。函数模板是不支持使用 T* 和 T&amp; 的偏特化的。\n\n调用时候指定模板参数类型的行为叫  显式实例化，并非特化\n\n5.3.2 类模板特化template&lt;class T1, class T2&gt;class Data&#123;public:\tData() &#123; cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl; &#125;private:\tT1 _d1;\tT2 _d2;&#125;;\n\n没有特化之前，两个函数都是调用的模板本身\n$ ./testData&lt;T1, T2&gt;Data&lt;T1, T2&gt;\n\n全特化  添加了一个针对 &lt;int, double&gt; 特化之后（这种特化被称为  全特化）\ntemplate&lt;&gt;class Data&lt;int, double&gt;&#123;public:\tData() &#123; cout &lt;&lt; &quot;Data&lt;int, double&gt;&quot; &lt;&lt; endl; &#125;&#125;;\n\n调用的就是我们特化后的类模板了\n$ ./testData&lt;T1, T2&gt;Data&lt;int, double&gt;\n\n半特化 &#x2F; 偏特化  偏特化的第一种形式，将模板参数中的一部分特化。比如下面的代码中，我们将模板参数的 T2 修改为 char\n// 1、将模板参数类表中的一部分参数特化。template &lt;class T1&gt;class Data&lt;T1, char&gt;&#123;public:    Data() &#123; cout &lt;&lt; &quot;Data&lt;T1, char&gt;&quot; &lt;&lt; endl; &#125;&#125;;\n\n那么修改了之后，只要第二个参数是 char 的实例化类，都会走偏特化后的模板\nData&lt;int,char&gt; d3;Data&lt;char,char&gt; d4;\n\n测试结果，走的都是偏特化后的版本\nData&lt;T1, char&gt;Data&lt;T1, char&gt;\n\n除了这种偏特化某个特定类型的，我们还可以针对指针和引用进行偏特化\n// 2、偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本。template &lt;class T1, class T2&gt;class Data&lt;T1 *, T2 *&gt;&#123;public:    Data() &#123; cout &lt;&lt; &quot;Data&lt;T1*, T2*&gt;&quot; &lt;&lt; endl; &#125;&#125;;template &lt;class T1, class T2&gt;class Data&lt;T1 &amp;, T2 &amp;&gt;&#123;public:    Data() &#123; cout &lt;&lt; &quot;Data&lt;T1&amp;, T2&amp;&gt;&quot; &lt;&lt; endl; &#125;&#125;;\n\n测试代码\nData&lt;char*,char*&gt; d5;Data&lt;char*,double*&gt; d6;Data&lt;int*,char*&gt; d7;\n\n输出如下\nData&lt;T1*, T2*&gt;Data&lt;T1*, T2*&gt;Data&lt;T1*, T2*&gt;\n\n而  只有一个指针  的情况，会匹配原生的\n// 只有一个指针，会匹配原生的Data&lt;int*,int&gt; d8;\n\n输出结果\nData&lt;T1, T2&gt;\n\n\n引用的结果也是一样的，两个引用就会调用我们对引用特化了的类模板\nData&lt;int&amp;,char&amp;&gt; d9;Data&lt;int&amp;,double&amp;&gt; d10;\n\n输出\nData&lt;T1&amp;, T2&amp;&gt;Data&lt;T1&amp;, T2&amp;&gt;\n\n但是引用如果只有一个（不管是在前面还是后面），那就会报错了！\nData&lt;char&amp;,double&gt; d11;\n\n这是因为它会去调用没有特化后的基础版本，但在默认版本中，我们使用了模板参数来定义了一个变量，这时候就出错了（因为引用必须要在定义的时候赋值！）\ng++ test.cpp date/date.cpp -o test -std=c++11test.cpp: In instantiation of ‘Data&lt;T1, T2&gt;::Data() [with T1 = char&amp;; T2 = double]’:test.cpp:160:24:   required from heretest.cpp:104:5: error: uninitialized reference member in ‘char&amp;’ [-fpermissive]     Data() &#123; cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl; &#125;     ^~~~test.cpp:107:8: note: ‘char&amp; Data&lt;char&amp;, double&gt;::_d1’ should be initialized     T1 _d1;        ^~~make: *** [makefile:2: test] Error 1\n\n如果将基础模板中的这两个变量定义删除，那就不会报错了\ntemplate &lt;class T1, class T2&gt;class Data&#123;public:    Data() &#123; cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl; &#125;// private://     T1 _d1;//     T2 _d2;&#125;;\n\n\n运行，输出的结果也是默认的模板\nData&lt;T1, T2&gt;\n\n小结  偏特化的适用范围一般高于全特化。\n偏特化和全特化同时存在时，优先调用全特化！\n5.3 使用场景  当我们使用 CPP 库函数 sort 的时候， 需要传入一个仿函数来进行排序的操作。\ntemplate &lt;class T&gt;struct Less&#123;    bool operator()(const T &amp;x, const T &amp;y) const    &#123;        return x &lt; y;    &#125;&#125;;void test_less_sort()&#123;    Date d1(2023, 3, 2);    Date d2(2023, 4, 6);    Date d3(2023, 6, 3);    vector&lt;Date&gt; v;    v.push_back(d2);    v.push_back(d1);    v.push_back(d3);    sort(v.begin(), v.end(), Less&lt;Date&gt;());    for (auto e : v)    &#123;        cout &lt;&lt; e ;    &#125;    cout &lt;&lt; endl;&#125;\n\n在栈上创建的 Date 是可以直接进行仿函数排序，并获取到正确结果\n2023-3-22023-4-62023-6-3\n\n但如果是 new 出来的Date，就会因为是比较的指针而无法正常进行排序\nDate *pd1 = new Date(2023, 3, 2);    Date *pd2 = new Date(2023, 7, 1);    Date *pd3 = new Date(2023, 5, 1);    vector&lt;Date*&gt; vptr;    vptr.push_back(pd1);    vptr.push_back(pd2);    vptr.push_back(pd3);    sort(vptr.begin(), vptr.end(), Less&lt;Date*&gt;());    for (auto e : vptr)    &#123;        cout &lt;&lt; (*e) ;    &#125;    cout &lt;&lt; endl;\n\n输出结果无序\n2023-7-12023-3-22023-5-1\n\n这时候就需要对 Less 这个仿函数的类进行特化了，我们可以使用全特化，也可以使用偏特化，二者效果相同；而针对指针的偏特化显然适用范围更广\n// 仿函数类特化template &lt;class T&gt;struct Less&#123;    bool operator()(const T &amp;x, const T &amp;y) const    &#123;        return x &lt; y;    &#125;&#125;;// 全特化template&lt;&gt;struct Less&lt;Date*&gt;&#123;\tbool operator()(Date* x, Date* y) const\t&#123;\t\treturn *x &lt; *y;\t&#125;&#125;;// 偏特化template &lt;class T&gt;struct Less&lt;T *&gt;&#123;    bool operator()(T *x, T *y) const    &#123;        return *x &lt; *y;    &#125;&#125;;\n\n再次测试，成功打印出有序结果\n2023-3-22023-5-12023-7-1\n\n5.4 迭代器萃取 5.4.1 iterator_traits 这个问题在 STL-LIST 的博客中已经涉及到了一部分；但那时候还没还有了解模板中的特化，没有办法详细地去观察底层的实现机制。\n在 STL 源码中的 stl_iterator.h 文件中，可以看到反向迭代器中的如下实现。其使用了 iterator_traits 模板类，来获取正向迭代器中的成员类型（暂时只关注pointer/reference）\ntemplate &lt;class Iterator&gt;class reverse_iterator &#123;protected:  Iterator current;public:  typedef typename iterator_traits&lt;Iterator&gt;::iterator_category          iterator_category;  typedef typename iterator_traits&lt;Iterator&gt;::value_type          value_type;  typedef typename iterator_traits&lt;Iterator&gt;::difference_type          difference_type;  typedef typename iterator_traits&lt;Iterator&gt;::pointer          pointer;  typedef typename iterator_traits&lt;Iterator&gt;::reference          reference;\n\n再看看这个类的实现，能看到如下的内容，其针对正向迭代器，同时刻画了关于 T* 指针和 const T* 引用的两个偏特化版本。\n因为在 list 中，我们的正向迭代器是自主封装实现的。但是在 vector 中，正向迭代器直接用的就是  指针 。提供了这两个特化版本，就能保证即便是用指针这一内置类型实现的特化版本，能成功地获取到一个正确的数据类型（同时也使用了typename 告诉编译器这是数据类型）的typedef\ntemplate &lt;class Iterator&gt;struct iterator_traits &#123;  typedef typename Iterator::iterator_category iterator_category;  typedef typename Iterator::value_type        value_type;  typedef typename Iterator::difference_type   difference_type;  typedef typename Iterator::pointer           pointer;  typedef typename Iterator::reference         reference;&#125;;template &lt;class T&gt;struct iterator_traits&lt;T*&gt; &#123;  typedef random_access_iterator_tag iterator_category;  typedef T                          value_type;  typedef ptrdiff_t                  difference_type;  typedef T*                         pointer;  typedef T&amp;                         reference;&#125;;template &lt;class T&gt;struct iterator_traits&lt;const T*&gt; &#123;  typedef random_access_iterator_tag iterator_category;  typedef T                          value_type;  typedef ptrdiff_t                  difference_type;  typedef const T*                   pointer;  typedef const T&amp;                   reference;&#125;;\n\n5.4.2 distance除了反向迭代器这里需要用到特化，在 STL 提供的 distance 函数中也会用到（用于计算两个迭代器之间的距离）\ntemplate &lt;class InputIterator, class Distance&gt;inline void __distance(InputIterator first, InputIterator last, Distance&amp; n,                        input_iterator_tag) &#123;  while (first != last) &#123; ++first; ++n; &#125;&#125;template &lt;class RandomAccessIterator, class Distance&gt;inline void __distance(RandomAccessIterator first, RandomAccessIterator last,                        Distance&amp; n, random_access_iterator_tag) &#123;  n += last - first;&#125;template &lt;class InputIterator, class Distance&gt;inline void distance(InputIterator first, InputIterator last, Distance&amp; n) &#123;  __distance(first, last, n, iterator_category(first));&#125;\n\n如果是一个单项迭代器，其就需要用过 ++ 来计算出两个迭代器之间的长度。如果是一个随机迭代器，那就可以直接通过二者相减计算出距离。\n这时候就需要通过  萃取来获取迭代器的类型（在迭代器类构造的时候，迭代器类型就已经通过萃取确认了），并通过这个迭代器的类型，确定使用的算法；\n6. 模板的显示实例化 6.1 说明 请注意，模板的显示实例化和模板的特化不是一个东西，需要注意区分开来。\n所谓模板显示实例化，就是让编译器给你指定的模板类型生成对应的代码，这样在后续的编译过程中不再需要多次生成。\n在上文中其实已经出现过函数模板实例化的示例 👉 点我跳转到上文. 我们在函数模板定义的源文件中，显示实例化我们需要的类型的函数模板，这样后续编译器在生成对应函数的时候，就可以正常从模板生成出我们需要的函数，而避免编译时找不到目标函数的问题。\n6.2 语法  模板显示实例化的方式是 template+ 函数模板的原本声明。\n比如显示实例化一个函数，就需要用 template 带上这个函数原本的定义和具体的模板参数类型。\ntemplate&lt;typename T1&gt;void Add(T1 left, T1 right)&#123;   cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;&#125;// 在源文件中显式实例化templatevoid Add&lt;int&gt;(int left, int right);\n\n如果是显示实例化一个 class，那么操作如下\ntemplate &lt;typename T&gt;class MyTemplateClass &#123;public:    void print()     &#123;        std::cout &lt;&lt; &quot;MyTemplateClass: &quot;  &lt;&lt; typeid(T).name() &lt;&lt; std::endl;    &#125;&#125;;// 显式实例化 MyTemplateClass 类模板// 生成专门针对 int 类型的实例化代码template class MyTemplateClass&lt;int&gt;;\n\n6.3 显示实例化的作用域  请注意，如果使用显示实例化，那么它的实例化后的模板类 &#x2F; 函数的声明都只会存在于当前源文件中，其他源文件中无法调用该函数！\n下面给出 4 个文件中的内容，作为测试。文件名参考开头注释。\n// head.h#include &lt;iostream&gt;using namespace std;// 头文件 head.h 中，模板函数声明template &lt;typename T&gt;T Add(T a,T b);// 定义普通函数，尝试在 a.cpp 中实现int test_add_a(int a,int b);// 定义普通函数，尝试在 b.cpp 中实现int test_add_b(int a,int b);\n\n上为 head.h 文件，下为 a.cpp 文件。\n// a.cpp#include &quot;head.h&quot;// A.cpp 中定义函数模板template &lt;typename T&gt;T Add(T a,T b)&#123;    return a+b;&#125;int test_add_a(int a,int b)&#123;    return a+b;&#125;\n\n下为 b.cpp 文件和 test.cpp 文件.\n// b.cpp#include &quot;head.h&quot;int test_add_b(int a,int b)&#123;    return Add&lt;int&gt;(a,b);&#125;\n\n尝试在 main 函数中调用分别在 a 和 b 中定义的两个相加函数.\n// test.cpp#include &quot;head.h&quot;int main()&#123;    cout &lt;&lt; &quot;a &quot; &lt;&lt; test_add_a(10,3) &lt;&lt; endl;    cout &lt;&lt; &quot;b &quot; &lt;&lt; test_add_b(10,30) &lt;&lt; endl;    return 0;&#125;\n\n\n执行编译后的报错如下，在 b.cpp 中找不到对应的 Add&lt;int&gt; 函数实例化之后的函数体实现，无法调用该函数模板！\n╰─ g++ test.cpp a.cpp b.cpp -o test/tmp/ccCFOnFc.o: In function `test_add_b(int, int)&#x27;:b.cpp:(.text+0x19): undefined reference to `int Add&lt;int&gt;(int, int)&#x27;collect2: error: ld returned 1 exit status\n\n这是因为函数模板的实现只存在于 a.cpp 中, 所以只有 a.cpp 中的其他函数能正常调用到这个函数模板.\n所以, 如果想在 b.cpp 中也能调用到这个函数模板, 解决办法只有在其中也带上函数模板的定义! 不然是不行的! (只在 b.cpp 中显示实例化是无效的, 编译会报错.)\n\n小结: 不管是什么时候, 遇到函数模板和类模板, 还是老老实实声明定义不分离最好!\n\n模板总结  优点：模板复用了代码，节省了资源和开发效率，C++ 的模板标准库也因此产生。增强了代码的灵活性；\n缺点：模板会导致代码膨胀问题，也会增加编译时间（模板在编译过程中实例化出具体的函数和类）。而且出现模板编译失败的错误时，错误信息凌乱不方便定位问题。\nThe end关于模板的基本知识和进阶关于特化的知识就基本结束辣！\n其实模板还有  模板元编程  这种更深层的东西，但那些使用的频率并不高，具体在工作中如果用到了，可能就需要更深入的学习了。\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【MySQL】复合查询 | 内外链接（未完成）","url":"/posts/2529084145/","content":"各类复合查询和笛卡尔积、内外链接的操作\n\n\n1. 基础查询  在之前的 MySQL 的 CURD 基本操作博客中，讲述了一部分查询的语法，但是在实际的生产活动中，那种最基础的查询方式不足以满足复杂查询条件时的要求，所以在普通查询的基础上，MySQL 还提供了功能更强大的复合查询，本文就让我们一起来学学复合查询的操作吧！\n\n依旧是使用 scott 提供的这张表，来进行复合查询的操作。\n\n在那之前，先复习一下普通查询的基本操作吧！\n\n查询工资高于 500 或者岗位为 MANAGER 的成员，同时他们的姓名首字母为大写 J\n\nselect * from emp where (sal &gt; 500 or job = &#x27;MANAGER&#x27;) and ename like &#x27;J%&#x27;;\n\n\n按照部门号升序、雇员的工资降序排序\n\nselect * from emp order by deptno, sal desc;\n\n\n显示工资高于平均工资的员工信息\n\nselect * from emp where sal &gt; (select avg(sal) from emp);\n\n\n显示每个部门的平均工资和最高工资\n\nselect deptno, avg(sal), max(sal) from emp group by deptno;\n\n\n显示每种岗位的雇员数量和平均工资\n\nselect job,count(*),avg(sal) from emp group by job;-- 默认情况下会保留 6 位小数，可以用 format 函数保留到 2 位select job,count(*),format(avg(sal),2) from emp group by job;-- 格式化后的输出结果如下+-----------+----------+--------------------+| job       | count(*) | format(avg(sal),2) |+-----------+----------+--------------------+| ANALYST   |        2 | 3,000.00           || CLERK     |        4 | 1,037.50           || MANAGER   |        3 | 2,758.33           || PRESIDENT |        1 | 5,000.00           || SALESMAN  |        4 | 1,400.00           |+-----------+----------+--------------------+5 rows in set (0.000 sec)\n\n2. 多表查询  基础查询的操作就复习上面几个就差不多了，接下来我们先看复合查询的第一个大点，多表查询。\n所谓多表查询，就是将一个表和另外一个表合并，再在这个合并了之后的表里面进行查询；\n\n比如：显示雇员名、雇员工资以及所在部门的名字\n\n因为雇员名是在 emp 表里面，部门名字是在 dept 表里面，所以我们就需要进行多表的联合查询才能一次取到结果（一次查询的效率优于两次独立查询）\n其基本语句就是在 from 后面添加多个表，并使用  表名. 表中字段名  来指定某一个表中的字段；如果这个字段只有一个表中有，那就可以不用指定表名（但依旧建议指定表名避免出错）\nselect * from 表1, 表2,...;\n\n2.1 笛卡尔积  先来一个全列查询，看看效果\nselect * from emp,dept;\n\n可以看到，dept 表直接拼接在了 emp 表之后，而且 emp 表中的每一个值都被根据 dept 中不同的部门 ID 重复了 4 次。这是因为在 MySQL 中，他并不知道你需要什么数据，所以进行数据拼接的时候，是采用穷举的方式来拼接的！\n这个不加任何过滤条件，穷举拼接得到的结果被称为  笛卡尔积！\n\n2.2 指定条件  接下来再回到上面提到的问题：显示雇员名、雇员工资以及所在部门的名字；\nselect emp.ename,emp.sal,dept.dname from emp,dept;\n\n虽然我们选中了我们需要的列来显示，但依旧没有解决笛卡尔积中穷举出来的无效数据；\n\n这时候就需要添加上筛选条件，来剔除掉无效的数据。\n和当前员工的部门编号不同的部门数据就是无效的，我们添加上员工部门编号和部门表中的部门编号相同的条件，就可以剔除掉无效的数据。\nselect emp.ename,emp.sal,dept.dname from emp,dept where emp.deptno = dept.deptno;\n\n这时候筛选出来的数据，才是正确的每个员工和其对应的部门名字的数据；每个员工也不在会重复 4 次了。\nMariaDB [scott]&gt; select emp.ename,emp.sal,dept.dname from emp,dept where emp.deptno = dept.deptno;+--------+---------+------------+| ename  | sal     | dname      |+--------+---------+------------+| SMITH  |  800.00 | RESEARCH   || ALLEN  | 1600.00 | SALES      || WARD   | 1250.00 | SALES      || JONES  | 2975.00 | RESEARCH   || MARTIN | 1250.00 | SALES      || BLAKE  | 2850.00 | SALES      || CLARK  | 2450.00 | ACCOUNTING || SCOTT  | 3000.00 | RESEARCH   || KING   | 5000.00 | ACCOUNTING || TURNER | 1500.00 | SALES      || ADAMS  | 1100.00 | RESEARCH   || JAMES  |  950.00 | SALES      || FORD   | 3000.00 | RESEARCH   || MILLER | 1300.00 | ACCOUNTING |+--------+---------+------------+14 rows in set (0.004 sec)\n\n再来做两个小练习\n-- 显示部门号为 10 的部门名字，员工名字和员工工资；MariaDB [scott]&gt; select emp.ename,emp.sal,dept.dname from emp,dept where emp.deptno = dept.deptno and dept.deptno = 10;+--------+---------+------------+| ename  | sal     | dname      |+--------+---------+------------+| CLARK  | 2450.00 | ACCOUNTING || KING   | 5000.00 | ACCOUNTING || MILLER | 1300.00 | ACCOUNTING |+--------+---------+------------+3 rows in set (0.001 sec)-- 显示各个部门员工的姓名，工资，工资级别MariaDB [scott]&gt; select emp.ename,emp.sal,salgrade.grade from emp,salgrade where emp.sal between losal and hisal;+--------+---------+-------+| ename  | sal     | grade |+--------+---------+-------+| SMITH  |  800.00 |     1 || ALLEN  | 1600.00 |     3 || WARD   | 1250.00 |     2 || JONES  | 2975.00 |     4 || MARTIN | 1250.00 |     2 || BLAKE  | 2850.00 |     4 || CLARK  | 2450.00 |     4 || SCOTT  | 3000.00 |     4 || KING   | 5000.00 |     5 || TURNER | 1500.00 |     3 || ADAMS  | 1100.00 |     1 || JAMES  |  950.00 |     1 || FORD   | 3000.00 |     4 || MILLER | 1300.00 |     2 |+--------+---------+-------+14 rows in set (0.001 sec)\n\n3. 自链接  所谓自连接，是在同一张表中进行链接和查询\n比如显示员工 FORD 上级领导的员工编号和姓名\n-- 使用子查询select empno,ename from emp where emp.empno=(select mgr from emp whereename=&#x27;FORD&#x27;);-- 使用多表查询（其实是给 emp 表起两个不同的别名）select leader.empno,leader.ename from emp leader, emp worker whereleader.empno = worker.mgr and worker.ename=&#x27;FORD&#x27;;\n\n这种在一张表里面进行笛卡儿积的查询操作，就叫做自链接。最终都可以获取到正确结果\n+--------+-------+| empno  | ename |+--------+-------+| 007566 | JONES |+--------+-------+1 row in set (0.001 sec)\n\n4. 子查询  子查询值得是，将一个查询语句作为子操作，嵌入到一个 sql 语句中；\n我们可以把子查询的结果也当作是一张表来进行处理，这样一想就能理解子查询是怎么玩的了。\n4.1 单行子查询  显示和 SMITH 同一个部门的员工\nselect * from emp where deptno = (select deptno from emp where ename=&#x27;smith&#x27;);\n\n在这个查询中，子查询语句是(select deptno from emp where ename=&#39;smith&#39;)，这个语句返回的结果只有一行，所以被称为单行子查询；\n4.2 多行子查询  有单行查询，自然也有多行查询。但是如果一个语句返回了多条结果，将其直接作为判据肯定是不行的，这会导致判据不唯一，MySQL 不知道你到底想要比较的是那一部分的数据。这时候就需要用下面几个关键字来帮忙了\n\nin：查询存在于某某结果里面的数据\nall：查询比这个结果中所有值都大 &#x2F; 小的数据\nany：查询比这个结果中某一个值大 &#x2F; 小的数据\n\n以下是几个示例\n-- 查询和 10 号部门工作岗位相同的员工名字、岗位、工资、部门号，但是不包含 10 号部门自己的员工select ename,job,sal,deptno from emp where job in (select job from emp where deptno=10) and deptno &lt;&gt; 10;+-------+---------+---------+--------+| ename | job     | sal     | deptno |+-------+---------+---------+--------+| SMITH | CLERK   |  800.00 |     20 || JONES | MANAGER | 2975.00 |     20 || BLAKE | MANAGER | 2850.00 |     30 || ADAMS | CLERK   | 1100.00 |     20 || JAMES | CLERK   |  950.00 |     30 |+-------+---------+---------+--------+5 rows in set (0.001 sec)\n\n-- 显示部门工资比 30 号部门所有员工工资都高的员工姓名、工资、部门号select ename,sal,deptno from emp where sal &gt; all(select sal from emp where deptno = 30);+-------+---------+--------+| ename | sal     | deptno |+-------+---------+--------+| JONES | 2975.00 |     20 || SCOTT | 3000.00 |     20 || KING  | 5000.00 |     10 || FORD  | 3000.00 |     20 |+-------+---------+--------+4 rows in set (0.001 sec)\n\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】安装和基础环境配置","url":"/posts/577382991/","content":"在本地安装 mysql，以 mariadb 为例。\n所有命令都需要在 root 下面执行 or 使用 sudo\n\n本文基于系统 CentOS 8\n\n1. 安装 mariadb 开发包  在 CentOS8 下用如下命令\nyum updateyum install -y mariadbyum install -y mariadb-serveryum install -y mariadb-devel\n\n在 Ubuntu 22.04 系统上用如下命令\nsudo apt updatesudo apt install -y mariadb-server mariadb-client\n\n\n注意，后文没有强调处的操作全都基于 CentOS8，但在 Ubuntu 上的配置操作应类似。可供参考\n\n2. 修改配置文件中的编码  为了保证对中文的支持，我们需要修改几个配置文件。他们都在如下目录中\n$ ls /etc/my.cnf.d/auth_gssapi.cnf  client.cnf  enable_encryption.preset  mariadb-server.cnf  mysql-clients.cnf\n\n需要修改的是如下 3 个，修改之前，建议使用 cp 命令进行备份，避免修改错了无法复原。\n/etc/my.cnf.d/client.cnf/etc/my.cnf.d/mysql-clients.cnf/etc/my.cnf.d/mariadb-server.cnf\n\n我的已经是修改好的了，需要修改的配置看中文注释就 ok\n$ cat /etc/my.cnf.d/client.cnf## These two groups are read by the client library# Use it for options that affect all clients, but not the server#[client]# 新增下边一行配置，设置客户端默认字符集为 utf8default-character-set = utf8# This group is not read by mysql client library,# If you use the same .cnf file for MySQL and MariaDB,# use it for MariaDB-only client options[client-mariadb]\n\n$ cat /etc/my.cnf.d/mysql-clients.cnf## These groups are read by MariaDB command-line tools# Use it for options that affect only one utility#[mysql]# 新增字符配置default-character-set = utf8[mysql_upgrade]\n\n$ cat /etc/my.cnf.d/mariadb-server.cnf## These groups are read by MariaDB server.# Use it for options that only the server (but not clients) should see## See the examples of server my.cnf files in /usr/share/mysql/## this is read by the standalone daemon and embedded servers[server]# this is only for the mysqld standalone daemon# Settings user and group are ignored when systemd is used.# If you need to run mysqld under a different user or group,# customize your systemd unit file for mysqld/mariadb according to the# instructions in http://fedoraproject.org/wiki/Systemd[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.socklog-error=/var/log/mariadb/mariadb.logpid-file=/run/mariadb/mariadb.pid# 新增以下字符集的配置collation-server = utf8_general_ciinit-connect = &#x27;SET NAMES utf8&#x27;character-set-server = utf8sql-mode = TRADITIONAL\n\n3. 测试3.1 启动 &#x2F; 关闭systemctl start mariadb\n\n看看状态\nsystemctl status mariadb\n\n显示如下，那就是正常运行中的\n● mariadb.service - MariaDB 10.3 database server   Loaded: loaded (/usr/lib/systemd/system/mariadb.service; disabled; vendor preset: disabled)   Active: active (running) since Tue 2023-04-04 14:10:00 CST; 2 days ago     Docs: man:mysqld(8)           https://mariadb.com/kb/en/library/systemd/  Process: 633453 ExecStartPost=/usr/libexec/mysql-check-upgrade (code=exited, status=0/SUCCESS)  Process: 633289 ExecStartPre=/usr/libexec/mysql-prepare-db-dir mariadb.service (code=exited, status=0/SUCCESS)  Process: 633265 ExecStartPre=/usr/libexec/mysql-check-socket (code=exited, status=0/SUCCESS) Main PID: 633422 (mysqld)   Status: &quot;Taking your SQL requests now...&quot;    Tasks: 31 (limit: 75691)   Memory: 67.4M   CGroup: /system.slice/mariadb.service           └─633422 /usr/libexec/mysqld --basedir=/usr\n\n\n用 ps 命令也能看到相关的进程\n$ ps jax | grep mysql      1  633422  633422  633422 ?             -1 Ssl     27   4:10 /usr/libexec/mysqld --basedir=/usr 625302  634104  634104  625302 pts/48    634104 S+    1000   0:00 mysql -uroot 642521  642555  642554  642521 pts/51    642554 S+    1000   0:00 grep --color=auto mysql\n\n如果想关闭，使用如下命令即可\nsystemctl stop mariadb\n\n使用如下命令进行  开机自启  的配置\nsystemctl enable mariadb\n\n执行效果如下\n$ systemctl enable mariadbCreated symlink /etc/systemd/system/mysql.service → /usr/lib/systemd/system/mariadb.service.Created symlink /etc/systemd/system/mysqld.service → /usr/lib/systemd/system/mariadb.service.Created symlink /etc/systemd/system/multi-user.target.wants/mariadb.service → /usr/lib/systemd/system/mariadb.service.\n\n取消开机自启，将 enable 改成 disable 就可以了\nsystemctl disable mariadb\n\n3.2 进入 mysql 命令行  因为我们没有设置 root 用户的密码，所以不需要指定密码就能进入数据库\nmysql -uroot\n\n会显示出如下信息，包括 mariadb 的版本\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.Your MariaDB connection id is 11Server version: 10.3.28-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.MariaDB [(none)]&gt;\n\n\n\n3.3 看看字符编码是否修改成功  输入如下命令 (记得要输入末尾的分号)\nshow variables like &quot;%chara%&quot;;\n\n看看是否都配置为了 utf-8，如下图，除了 filesystem 是二进制，其他都是utf8，那就是 ok 的\n修改之前的是这样的\n\n修改后\n\n到这里，就 ok 菈！\n3.4 端口 mysql 服务的默认端口为3306，::: 代表它是采用 ipv6 协议在本地进行访问的。但这不影响我们的使用\n\n4. 彻底卸载  有的时候，一个环境中已有 mysql，但不是我们需要的版本。就需要将其删除后重新安装新的 mysql。\nrpm -qa | grep mysqlrpm -qa | grep mariadb\n\n使用这两个命令，可以查看当前系统中安装的 mysql（mariadb）的包\n[root@1c2261732150:~]# rpm -qa | grep mysql[root@1c2261732150:~]# rpm -qa | grep mariadbmariadb-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-server-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-common-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-errmsg-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-connector-c-3.1.11-2.el8_3.x86_64mariadb-backup-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-server-utils-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-devel-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-connector-c-config-3.1.11-2.el8_3.noarchmariadb-gssapi-server-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-connector-c-devel-3.1.11-2.el8_3.x86_64\n\n可以看到，我的系统中安装的是 mariadb（而不是 mysql）\n这时候就可以用一条命令，快速进行批量卸载\nrpm -qa | grep mariadb | xargs yum -y remove\n\n这条命令中 xargs 的作用就是把前面这个 grep 命令的结果，按行喂给 yum 进行删除。\n删除之后，再次执行。\nrpm -qa | grep mariadb\n\n如果没有软件，那就是卸载完毕了！👌👌\n[root@1c2261732150:~/package]# rpm -qa | grep mariadb[root@1c2261732150:~/package]#\n\n注意，卸载 mysql 并不会连带删除数据文件\n5. 安装特定版本的5.1 查看系统版本$ cat /etc/system-releaseCentOS Linux release 8.5.2111\n\n当前我使用的系统为CentOS 8.5，使用 yum 安装的 mariadb 的版本比较高\n# mysql --versionmysql  Ver 15.1 Distrib 10.3.28-MariaDB, for Linux (x86_64) using readline 5.1\n\n假设我需要一个老版本的 mysql，就需要去安装特定的 rpm 版本\n5.2 获取 yum 源http://repo.mysql.com/\n\n找到 el8 后缀的包，el指代的就是 CentOS\nmysql80-community-release-el8-3.noarch.rpm\n\n如上，就是一个 mysql 8.0 版本的 CentOS8 的 rpm 源。\n在很多教程中，使用的都是 5.7 版本的 mysql，可惜 CentOS8 已经不支持这个旧版本了（找不到对应的 mysql57 的包）\n5.3 安装 yum 源  可以使用 windows 下载了 rpm 文件后，上传到服务器中。或者用如下命令在 linux 内部下载。\n如下目录是我们系统源的路径，一般情况下，内部不会带有和 mysql 相关的源。\nls -al /etc/yum.repos.d/\n\ntotal 92drwxr-xr-x 1 root root 4096 Apr  6 19:14 .drwxr-xr-x 1 root root 4096 Apr  6 19:14 ..-rw-r--r-- 1 root root 2590 Feb 24 08:08 CentOS-Base.repo-rw-r--r-- 1 root root  966 Feb 24 08:00 CentOS-Linux-AppStream.repo-rw-r--r-- 1 root root  710 Feb 24 07:56 CentOS-Linux-BaseOS.repo-rw-r--r-- 1 root root 1136 Feb 24 07:56 CentOS-Linux-ContinuousRelease.repo-rw-r--r-- 1 root root  318 Feb 24 07:56 CentOS-Linux-Debuginfo.repo-rw-r--r-- 1 root root  738 Feb 24 07:56 CentOS-Linux-Devel.repo-rw-r--r-- 1 root root  710 Feb 24 07:56 CentOS-Linux-Extras.repo-rw-r--r-- 1 root root  725 Feb 24 07:56 CentOS-Linux-FastTrack.repo-rw-r--r-- 1 root root  746 Feb 24 07:56 CentOS-Linux-HighAvailability.repo-rw-r--r-- 1 root root  693 Feb 24 07:56 CentOS-Linux-Media.repo-rw-r--r-- 1 root root  712 Feb 24 07:56 CentOS-Linux-Plus.repo-rw-r--r-- 1 root root  730 Feb 24 07:56 CentOS-Linux-PowerTools.repo-rw-r--r-- 1 root root 1124 Feb 24 07:56 CentOS-Linux-Sources.repo-rw-r--r-- 1 root root    0 Feb 24 08:05 epel-8.repo-rw-r--r-- 1 root root 1698 Oct  4  2022 epel-modular.repo-rw-r--r-- 1 root root 1332 Oct  4  2022 epel.repo-rw-r--r-- 1 root root 1417 Jun  8  2021 epel.repo.rpmnew-rw-r--r-- 1 root root 2318 Feb 24 08:08 epel.repo.rpmsave-rw-r--r-- 1 root root 1797 Oct  4  2022 epel-testing-modular.repo-rw-r--r-- 1 root root 1431 Oct  4  2022 epel-testing.repo-rw-r--r-- 1 root root  164 Feb 27 12:21 vscode.repo\n\n将数据传到云服务器后，使用如下命令，进行源安装\nrpm -Uvh mysql80-community-release-el8-3.noarch.rpm\n\n输出如下\nwarning: mysql80-community-release-el8-3.noarch.rpm: Header V4 RSA/SHA256 Signature, key ID 3a79bd29: NOKEYVerifying...                          ################################# [100%]warning: Unable to get systemd shutdown inhibition lock: Unit systemd-logind.service is masked.Preparing...                          ################################# [100%]Updating / installing...   1:mysql80-community-release-el8-3  ################################# [100%]\n\n安装完毕，再次查看 yum 源路径，可以看到比原来多了两个 mysql 的包\n# ls -al /etc/yum.repos.d/total 100drwxr-xr-x 1 root root 4096 Apr  7 16:12 .drwxr-xr-x 1 root root 4096 Apr  6 19:14 ..-rw-r--r-- 1 root root 2590 Feb 24 08:08 CentOS-Base.repo-rw-r--r-- 1 root root  966 Feb 24 08:00 CentOS-Linux-AppStream.repo-rw-r--r-- 1 root root  710 Feb 24 07:56 CentOS-Linux-BaseOS.repo-rw-r--r-- 1 root root 1136 Feb 24 07:56 CentOS-Linux-ContinuousRelease.repo-rw-r--r-- 1 root root  318 Feb 24 07:56 CentOS-Linux-Debuginfo.repo-rw-r--r-- 1 root root  738 Feb 24 07:56 CentOS-Linux-Devel.repo-rw-r--r-- 1 root root  710 Feb 24 07:56 CentOS-Linux-Extras.repo-rw-r--r-- 1 root root  725 Feb 24 07:56 CentOS-Linux-FastTrack.repo-rw-r--r-- 1 root root  746 Feb 24 07:56 CentOS-Linux-HighAvailability.repo-rw-r--r-- 1 root root  693 Feb 24 07:56 CentOS-Linux-Media.repo-rw-r--r-- 1 root root  712 Feb 24 07:56 CentOS-Linux-Plus.repo-rw-r--r-- 1 root root  730 Feb 24 07:56 CentOS-Linux-PowerTools.repo-rw-r--r-- 1 root root 1124 Feb 24 07:56 CentOS-Linux-Sources.repo-rw-r--r-- 1 root root    0 Feb 24 08:05 epel-8.repo-rw-r--r-- 1 root root 1698 Oct  4  2022 epel-modular.repo-rw-r--r-- 1 root root 1332 Oct  4  2022 epel.repo-rw-r--r-- 1 root root 1417 Jun  8  2021 epel.repo.rpmnew-rw-r--r-- 1 root root 2318 Feb 24 08:08 epel.repo.rpmsave-rw-r--r-- 1 root root 1797 Oct  4  2022 epel-testing-modular.repo-rw-r--r-- 1 root root 1431 Oct  4  2022 epel-testing.repo-rw-r--r-- 1 root root 1265 Jan 10  2022 mysql-community.repo-rw-r--r-- 1 root root 1321 Jan 10  2022 mysql-community-source.repo-rw-r--r-- 1 root root  164 Feb 27 12:21 vscode.repo\n\n这时候，yum 源就已经安装成功了\nyum list | grep mysql\n\n执行后，可以看到，列在最前面的就是el8-3，即为刚刚我们添加的的 yum 源中的 mysql 版本\nRepository AppStream is listed more than once in the configurationRepository extras is listed more than once in the configurationmysql80-community-release.noarch                                  el8-3                                                  @Systemanope-mysql.x86_64                                                2.0.12-1.el8                                           epelansible-collection-community-mysql.noarch                         3.5.1-1.el8                                            epelapr-util-mysql.x86_64                                             1.6.1-6.el8                                            AppStream\n\n\n5.4 卸载旧版本的  如果需要安装新版本的，那就需要依照第四步的操作，彻底卸载旧版本的 mysql\n5.5 安装指定版本  此时我们指定 mysql 进行安装，就肯定能安装到刚刚添加的 mysql8.0 版本\nyum install -y mysqlyum install -y mysql-serveryum install -y mysql-devel\n\n\n可以看到，版本就是 8.0 的，不再是之前安装的Ver 15.1\n$ mysql --versionmysql  Ver 8.0.26 for Linux on x86_64 (Source distribution)\n\n共安装了下面的这些包\n# rpm -qa | grep mysqlmysql-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql-errmsg-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql-server-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql-devel-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql-common-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql80-community-release-el8-4.noarchmysql-libs-8.0.26-1.module_el8.4.0+915+de215114.x86_64# rpm -qa | grep mariadbmariadb-connector-c-config-3.1.11-2.el8_3.noarch\n\n5.6 启动报错（未解决）但是这次启动的时候，却遇到了下面的报错\n# systemctl start mysqldJob for mysqld.service failed because the control process exited with error code.See &quot;systemctl status mysqld.service&quot; and &quot;journalctl -xe&quot; for details.\n\n查看报错信息也看不出个所以然\n# systemctl status mysqld.service● mysqld.service - MySQL 8.0 database server   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; disabled; vendor preset: disabled)   Active: failed (Result: exit-code) since Fri 2023-04-07 16:39:51 CST; 7s ago  Process: 648073 ExecStopPost=/usr/libexec/mysql-wait-stop (code=exited, status=0/SUCCESS)  Process: 648059 ExecStart=/usr/libexec/mysqld --basedir=/usr (code=exited, status=1/FAILURE)  Process: 648023 ExecStartPre=/usr/libexec/mysql-prepare-db-dir mysqld.service (code=exited, status=0/SUCCESS)  Process: 647999 ExecStartPre=/usr/libexec/mysql-check-socket (code=exited, status=0/SUCCESS) Main PID: 648059 (code=exited, status=1/FAILURE)   Status: &quot;Data Dictionary upgrade from MySQL 5.7 in progress&quot;Apr 07 16:39:50 1c2261732150 systemd[1]: Starting MySQL 8.0 database server...Apr 07 16:39:51 1c2261732150 systemd[1]: mysqld.service: Main process exited, code=exited, status=1/FAILUREApr 07 16:39:51 1c2261732150 systemd[1]: mysqld.service: Failed with result &#x27;exit-code&#x27;.Apr 07 16:39:51 1c2261732150 systemd[1]: Failed to start MySQL 8.0 database server.\n\n百度了一下，这个问题是因为 mysql 的路径权限不足\n\nhttps://blog.csdn.net/Shockang/article/details/118061120\nhttps://blog.csdn.net/weixin_44198965/article/details/104145043\n\n但是我修改了之后还是没有用，百度了另外几个操作，都没有办法正常启动 mysqld，那能咋办，放弃了。\n用回最开始安装的 mariadb 了😥\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【C++】快速学习类和对象，看这一篇就够了","url":"/posts/3040822590/","content":"本篇博客是学校大一下 C++ 期末考察的要求，包含了 C++ 中  类和对象  的大部分内容，适合学习类和对象的你观看。最后还有两个小项目，综合了绝大部分类和对象的知识，很适合练手 + 深化学习。\n\n\n为了避免被同校 copy，本篇博客只在我的 HEXO个人博客  上发布\n第一章 绪论 1.1 面向对象程序特点与目标 面向对象有下面几个特征：\n\n类与对象：把现实世界中的某一类东西，提取出来，用代码表示；\n封装性：把过程和数据封装到一个包裹里面，对数据的访问只能通过公开权限的函数接口来进行操作；\n继承性：一种联结类的层次模型，类似树状结构；\n多态性：允许不同类的对象对同一消息做出响应，用不同的方法来解决一个问题。\n\n其中 封装、继承、多态 被称为面向对象的三大特性\n通过这些特征，我们可以看得到，其实面向对象的程序也是在 C 语言的面向过程的基础上得来的。其目的也是为了更好的服务某一个具体的问题，并通过这个问题衍生出不同的解题方法，并用代码来表示解决一个问题对象的过程。\n1.2 面向对象程序知识架构\n\n第二章 面向程序对象关键支撑技术 2.1 类和对象 类和对象与命名空间类似，都是存在一种封装。不同的是，类是对 C 语言 struct 结构体类型的拓。除了变量以外，类里面还可以定义成员函数，并设置它们的权限，实现了对一个接口的完整封装。\n2.1.1 构造函数  众所周周知，当我们写 C 语言 的顺序表、链表等代码的时候，一般都会写一个 Init 函数来初始化内容。\nvoid Init()&#123;\ta=(int*)malloc(sizeof(int)*4);\tsize=0;\tcapa=4;&#125;\n\n但是这样有一个缺点，就是不够智能，需要我们自己来调用它进行初始化。\n于是 C++ 就整出来了一个构造函数来解决这个问题\n特性\n构造函数：名字和类名相同，创建类对象的时候编译器会自动调用，初始化类中成员变量，使其有一个合适的初始值。构造函数在对象的生命周期中只调用一次\n构造函数有下面几个特性：\n\n函数名和类名相同\n无返回值\n构造函数可以重载\n对象实例化的时候，编译器会  自动调用  对应的构造函数\n如果你自己不写构造函数，编译器会自己创建一个默认的构造函数\n\n2.1.1.1 基本使用  下面用一个队列来演示一下构造函数\nclass Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;// 测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n可以看到，在创建对象 q1 的时候，编译器就自动调用了类中的构造函数，帮我们初始化了这个队列\n\n\n除了上面这种最基本的  无参  构造函数以外，一般写构造函数的时候，我们都会带一个有缺省值的参数，这样可以更好地灵活使用这个队列\nQueue(int Capacity=4)&#123;    _a=(int*)malloc(sizeof(int)*Capacity);    _size=0;    _capa=Capacity;&#125;\n\n调用这种构造函数也更加灵活，我们可以根据数据类型的长度，来创建不同容量的队列，避免多次 realloc 造成的内存碎片\nQueue q1;// 调用无参的构造函数Queue q2(100);// 调用带参的构造函数\n\n多种构造函数是可以同时存在的，不过！它们需要满足函数重载的基本要求\n当你调用一个  无参  的函数，和一个  全缺省  的函数的时候，编译器会懵逼！\nQueue();Queue(int Capacity=4);// 这两个函数不构成重载，会报错\n\n正确的重载应该是下面的情况\nQueue();Queue(int Capacity);\n\n编译器在创建对象的时候，就会智能选择这两个构造函数其中之一进行调用。但是同一个对象  只会调用一个构造函数。\n除了在构造函数内部初始化参数，我们还可以在  初始化列表  处进行操作\nQueue(int Capacity=4)\t:_a(new int[Capacity]),    _size(0),    _capa(Capacity)&#123; &#125;\n\n2.1.1.2 编译器默认生成的构造函数  上面提到过，如果我们不写构造函数，编译器会自己生成一个。\n但测试过以后，你会发现，这个默认生成的构造函数，好像啥事都没有干——或者说，它把_a _b _c 都初始化成了随机值！\n\n实际上，编译器默认生成的构造函数是不会处理内置类型的\n\n内置类型：int、char、float、double……\n外置类型：自定义类型（其他的类）\n\n在处理的时候，编译器忽略内置类型；外置类型会调用它的构造函数\nclass Date&#123;public:    // 默认构造函数：不传参就能调用的    //1. 全缺省 2. 无参 3. 编译器自动生成    // 可以是半缺省的，但是不实用    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;        _A.Print();    &#125;private:    // 编译器会自动生成构造函数（如果你没有自己写的话）    // 自动生成的构造函数是不会初始化内置类型的    // 内置类型：int,char,double 等等    int _year;    int _month;    int _day;    // 外置类型：自定义类型    // 外置类型会调用它自己的默认构造函数    Queue _A;&#125;;\n\n可以看到，编译器调用了自己的构造函数的同时，还调用了外置类型 Queue 的构造函数，搞定了它的初始化\n\n如果我们去掉 Date 的构造函数，就能看到下面的情况。Queue成功初始化，但是内置类型的年月日都是随机值\n\n一般情况下一个 C++ 类都需要自己写构造函数，下面这两个情况除外\n\n类里面的成员都是自定义类型成员（且有自己的构造函数）\n如果还有内置类型成员，声明时给了缺省值\n\n注：只有类在声明变量的时候才可以给缺省值\n// 下面的情况就不需要写class MyStack&#123;private:      Queue q1;// 自定义类型      Queue q2;      int a=1;// 内置类型声明的时候给了缺省值&#125;;\n2.1.1.3 初始化列表  除了上面的方式之外，还有一种构造函数的使用方式为初始化列表\nDate(int year=2022,int month=2,int day=30)    :_year(year),\t_month(month),\t_day(day)&#123;&#125;\n\n\n每个成员变量只能在初始化列表中出现一次\n类中包含以下成员必须在初始化列表中进行初始化\n引用\nconst 成员\n自定义类型成员\n\n\n\n一般情况下，建议使用初始化列表进行初始化。因为对于自定义类型的成员变量，初始化列表的优先级是高于 &#123; &#125; 里面的内容的。\n这里还有非常重要的一点！\n成员变量在类中声明的顺序就是初始化列表的顺序，而并非初始化列表自己的顺序！\n\n怎么理解呢？看下面这个代码\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(month)\t&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n即便我们把 _day 放在了初始化列表的首位，但由于它是在最后声明的。所以构造函数走初始化列表的时候，会依据声明顺序，依次初始化年、月、日。\n\n这会引起什么问题？再来看看一个错误示例\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(_day)&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n当我们用上面这个初始化列表的时候，我们本意是想在初始化完 _day 以后，将 _day 的值赋给 _month。但由于_month 的声明顺序在 _day 之前，所以 _month(_day) 会先执行，此时的 _day 尚为随机值，这就导致月份变成随机值了！\n\n这只是一个示例，实际上肯定不会用天数初始化月数，范围不一样\n\n最好的办法，就是声明顺序和初始化列表的顺序保持一致！\n2.1.1.4 explicit 关键字  构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有隐式类型转换的作用。\nclass Date&#123;public:    // 正常的构造函数    //Date(int year)    //    :_year(year)    //    &#123;&#125;\t    explicit Date(int year)        :_year(year)        &#123;&#125;private:    int _year;    int _month:    int _day;&#125;；void TestDate()&#123;    Date d1(2018);    // 用一个整形变量给日期类型对象赋值    // 实际编译器背后会用 2019 构造一个无名对象，最后用无名对象给 d1 对象进行赋值    d1 = 2019;&#125;\n\n当我们调用赋值的时候，实际上编译器会先用 2019 构造出一个 date 类型对象，再调用赋值重载（这里还没有写）赋值给 d1。这就是一个隐式类型转换\n如果我们用 explicit 修饰了这个构造函数，那么编译器将不会进行此类隐式类型转换！\n\n2.1.2 拷贝构造函数 2.1.2.1 特性和使用 拷贝构造是一个特殊的构造函数，它的参数是另外一个 Date 类型。在用已有的类类型对象来创建新对象的时候，由编译器自动调用\n因为拷贝的时候我们不会修改 d 的内容，所以传的是const。另外，我们必须进行传引用调用！\n如下面的这个函数，在传参的时候，编译器会去调用 Date 的拷贝构造\nvoid func(Date d);\n\n如果你没有写拷贝构造，或者拷贝构造里面不是  传引用 ，编译器会就递归不断创建新的 对象  进行值拷贝构造，程序就死循环辣\n// 拷贝构造，如果不写的时候，编译器会默认生成一个    // 对内置类型进行值拷贝(浅拷贝)    Date(const Date&amp; d)    &#123;        _year=d._year;        _month=d._month;        _day=d._day;        // 外置类型会调用外置类型的拷贝构造        Queue b(_A);    &#125;\n\n和构造、析构不同的是，编译器自己生成的拷贝构造终于有点用了\n\n它会对内置类型进行按  内存存储的字节序  完成拷贝，这种称为值拷贝（又称  浅拷贝）\n对外置类型会调用它的构造函数\n\n2.1.2.2 深拷贝  外置类型拷贝问题\n但是！如果你使用了外置类型，该类型中包含 malloc 的时候，编译器默认生成的构造函数就不能用辣！\n因为这时候，编译器默认生成的拷贝构造会进行值拷贝，拷贝完了之后，就会出现 q1 和 q2 指向同一个空间的情况。修改 q2 会影响 q1，free 的时候多次释放同一个空间会报错，不符合我们的拷贝构造的要求\n\n注意注意，malloc 不行的原因是，数据是存在堆区里面，拷贝的时候，q2 的 _a 得到的是一个地址，而不是拷贝了新的数据内容。\n\n如果你在类里面定义了一个 int arr[10] 数组，这时候拷贝构造就相当于memcpy，是可以完成拷贝的工作的\n但是 malloc 和 new 创造的空间是在堆区上的，无法直接拷贝\n\n如何解决这个问题呢？我们需要使用深拷贝\n\n了解 new 和 delete\n从 C 语言转到 C++，多了 new 和 delete 关键字，它们分别对应 malloc 和 free\nint main()&#123;    int*p1=new int;// 开辟一个 int 类型的空间    int*p2=new int(10);// 开辟一个 int 类型的空间，并初始化为 10    int*p3=new int[10];// 开辟 10 个 int 类型的空间    // 注意后两个的括号区别！        delete p1;// 销毁 p1 指向的单个空间    delete p2;// 同上        //delete p3;// 销毁 p3 指向的第一个空间，不能用于数组    delete[] p3;// 销毁 p3 指向的数组        return 0;&#125;\n\n深拷贝实现\n在上面写道过，编译器会自动生成拷贝构造函数，完成值拷贝工作。但是队列的代码里面包含  堆区  的空间，需要我们正确释放。这时候就需要自己写一个拷贝构造完成深拷贝\n// 拷贝构造Queue(const Queue&amp; q)&#123;    _a=new int[q._capa];// 注意解引用    memcpy(_a, q._a, q._capa*sizeof(int));// 拷贝内容    _size=q._size;    _capa=q._capa;&#125;\n\n用下面这个  队列的代码  来测试深拷贝\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;// 测试是否调用        //_a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;        _a=new int[_capa];        for(int i=0;i &lt; _capa;i++)        &#123;            _a[i]=i+1;        &#125;    &#125;    // 拷贝构造    Queue(const Queue&amp; q)    &#123;        cout&lt;&lt;&quot;Queue Copy&quot;&lt;&lt;endl;        _a=new int[q._capa];        memcpy(_a, q._a, q._capa*sizeof(int));        _size=q._size;        _capa=q._capa;    &#125;    void Print()    &#123;        cout&lt;&lt;&quot;this:&quot;&lt;&lt;this&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;_a:&quot;&lt;&lt;_a&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;        for(int i=0;i &lt; _capa;i++)        &#123;            cout&lt;&lt;_a[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    ~Queue()    &#123;        // 析构函数        //free(_a);        delete[] _a;        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;int main()&#123;     Queue q1;    q1.Print();    cout&lt;&lt;endl;    Queue q2=q1;     q2.Print();    cout&lt;&lt;endl;    return 0;&#125;\n\n深拷贝效果\n先注释掉 Queue 的拷贝构造函数析构函数（不然会报错）\n看一看，发现在不写拷贝构造函数的时候，q2 和 q1 的 _a 指向了同一个地址\n\n取消析构函数的注释，可以看到两次释放同一片空间，发生了报错\n\n如果我们把写好的  深拷贝构造  加上，就不会出现这个问题\n\n当你加上给 _a 里面初始化一些数据，以及打印 _a 数据的函数后，就可以看到，不仅 q2 的 _a 有了自己全新的地址，其内部的值也和 q1 一样了\n\n这样写出来的拷贝构造，即便把队列中的 int* _a 修改为 char* 或者其他类型，都能正确完成拷贝工作\n\n\n2.1.3 析构函数  和构造函数相对应，析构函数是对象在  出了生命周期  后自动调用的函数，用来爆破对象里的成员（如进行 free 操作）\n生命周期是离这个对象最近的 &#123; &#125; 括号\n特性\n\n析构函数名是在类名前加~\n无参数，无返回值\n一个类只能有一个析构函数\n如果你没有自己写，编译器会自动生成一个析构函数\n\n和构造函数一样，编译器自己生成的析构函数不会处理内置类型；会调用外置类型的析构函数\n基本使用\n析构函数的定义和我们在外部写的 Destroy 函数一样，主要执行 free（delete）操作\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue&quot;&lt;&lt;endl;// 测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;    ~Queue()    &#123;        // 析构函数        free(_a);        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;// 测试调用    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n假设我们在 main 函数里面定义了两个对象，你能说出 q1 和 q2 谁先进行析构函数的调用吗？\n\n可以看到，先调用的是 q2 的析构函数\n\n因为在底层操作中，编译器会给 main 函数开辟栈帧\n栈遵从后进先出的原则，q2 是后创建的，所以在析构的时候会先析构\n\n2.2 静态成员 2.2.1 静态数据成员 和普通的成员变量不同，静态成员变量不属于某一个对象，而是属于整一个类\nclass A&#123;// 定义一个静态成员变量\tstatic int _a  &#125;;\n\n也因为这个特性，静态成员变量是不会被 sizeof 计入的\n什么时候会用到静态成员变量？比如当我们需要计算一个类究竟开辟了多少个对象的时候。如果使用普通成员变量，它的值是属于某一个对象的，无法完成正确的 count 计数。使用静态成员变量后，该变量的值不会因为定义多个对象而被重置。这时候，我们就可以在构造函数和拷贝构造函数里面，使用 count++，来实现 对类开辟对象个数的统计。\nclass STU&#123;public:    STU()    &#123;        count++;        //...    &#125;    STU(const STU&amp; d)    &#123;        count++;        //...    &#125;\t// 声明一个静态成员变量\tstatic int count;  &#125;;int STU::count=0;// 必须要在类外定义\n\n这时候，每次对象创建都会让 conunt+1，我们可以通过下面两种方式访问来得到count 的值\n\n通过指定类域来访问，STU::count\n通过对象来访问，STU s1; s1.count;\n\n如果想在类外直接访问静态成员变量，就不能用private，必须是公有权限\n\n2.2.2 静态成员函数  如果把静态成员变量定义为公有，那么外部的所有函数都可以通过类域或者对象来访问这个静态成员变量，这时候就不利于我们程序的封装。所以我们可以借助静态成员函数来  访问私有的静态成员变量\n#include &lt;iostream&gt;using namespace std;class STU&#123;public:    STU() &#123;        count++;    &#125;    STU(const STU&amp; d)&#123;        count++;    &#125;    static int GetCount() &#123;        return count;    &#125;private:    static int count;&#125;;int STU::count=0;int main()&#123;    STU s1;        cout&lt;&lt;&quot; 通过对象 s1 访问    &quot;&lt;&lt;s1.GetCount()&lt;&lt;endl;    cout&lt;&lt;&quot; 通过类域 STU:: 访问 &quot;&lt;&lt;STU::GetCount()&lt;&lt;endl;        return 0;&#125;\n\n静态成员函数有下面几个特点\n\n类静态成员即可用类名 :: 静态成员或者对象. 静态成员来访问\n静态成员函数没有隐藏的 this 指针，不能访问任何非静态成员\n静态成员和类的普通成员一样，也有 public、protected、private 三种访问级别\n静态成员函数可以具有返回值\n\n\n2.3 常成员 2.3.1 常数据成员 有一部分数据成员，是一个定值。比如我们定义了某一个学科的类class MATH\nclass MATH&#123;  int piont=6.0;// 数学的学分  &#125;;\n\n可以看到，作为一个学科，它的考试学分 &#x2F; 绩点是固定的。这时候我们不需要在后续修改这个学分的定义，就可以将它设置为 const 属性，避免被其他成员误修改\nclass MATH&#123;  const int piont=6.0;// 数学的学分  &#125;;\n\n和普通成员和静态成员变量不同的是\n\n常成员变量必须在声明的时候初始化\n常成员变量不能在类外定义\n常成员变量只能在构造函数的  初始化列表阶段  进行定义\n\nclass MATH&#123;public:    MATH()        :score(6.0)// 初始化列表处定义    &#123;        cout&lt;&lt;score&lt;&lt;endl;// 打印测试    &#125;private:    const double score=0;// 必须在声明的时候定义初值&#125;;\n\n2.3.2 常成员函数const 修饰的类成员函数称之为const 成员函数，即常成员函数。const 修饰类成员函数，实际修饰的是该成员函数隐含的this 指针，表明在该成员函数中不能对类的任何成员进行修改。\n基本的修饰方法如下，在函数的括号后加 const 即可\nvoid Print()const&#123;\tcout&lt;&lt;_year&lt;&lt;endl;&#125;\n\n实际修饰的是该函数隐含的 this 指针\nthis 指针本身是 Date*const 类型的，修饰后变为 const Date* const 类型\nvoid Print(const Date* const this)&#123;\tcout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;&#125;\n\n2.3.2.1 实例 - 权限问题  这么说好像有点迷糊，我们用实例来演示一下为什么需要 const 修饰成员函数\nclass Date&#123;public:    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;    &#125;private:    int _year;    int _month;    int _day;&#125;;\n\n假设我们需要在函数中调用 Print 函数，在 main 中是可以正常调用的\nint main()&#123;\tDate d1(2022,5,10);    d1.Print();    return 0;&#125;\n\n但当你用一个函数来进行这个操作的时候，事情就不一样了\nvoid TEST(const Date&amp; d)&#123;\td.Print();//d.Print(&amp;d) --&gt;const Date*&#125;int main()&#123;\tDate d1(2022,5,10);    d1.Print();//d1.Print(&amp;d1) --&gt;Date*    TEST(d1);        return 0;&#125;\n\n这时候我们进行了引用调用，因为在 TEST 中我们不会修改 d1 的内容，所以用 const 进行了修饰\n\n这时候 TEST 中的 d.Print() 函数调用，传入的是 const Date* 指针，指针指向的内容不能被修改\nmain 中的 d1.Print(); 函数调用，传入的是 Date* 指针\n\n于是就会发生权限冲突问题：\n\n这时候如果我们在函数后面加了 const，就可以避免此种权限放大问题。这样不管是 main 函数还是 TEST 函数中对 Print() 函数  的调用，就都可以正常打印了！\n总结一下：\n\nconst 对象  不可以  调用非 const 成员函数（权限放大）\n非 const 对象  可以  调用 const 成员函数（权限缩小）\nconst 成员函数内  不可以  调用其他非 const 成员函数（权限放大）\n非 const 成员函数  可以  独调用其他 const 成员函数（权限缩小）\n\n2.3.2.2 什么时候需要使用？众所周周知，const 修饰指针有下面两种形式\n\n在 * 之前修饰，代表该指针指向  对象的内容  不能被修改（地址里的内容不能改）\n在 * 之后修饰，代表该指针  指向的对象  不能被修改（指向的地址不能改）\n\nthis 指针本身就是  类型名 * const类型的，它本身不能被修改。加上 const 之后，this 指向的内容，既类里面的成员变量也不能被修改了。\n知道了这一点后，我们可以合理的判断出：只要是需要修改类中成员变量的函数 ，就不需要在() 后面加 const 修饰\n如果一个函数中不需要修改成员变量，就可以加 const 进行修饰（最好加上，告知调用者该函数中不会修改成员变量）\n注意：如果你使用了声明和定义分离的写法来实现一个 const 成员函数，那么声明和定义的成员函数  都需要加上 const 修饰\n2.3.2.3 出错情况  这里有一点需要提醒的是，如果你对某一个函数进行了 const 修饰，那么这个函数里面包含的其他类里面的函数，都需要进行 const 修饰。不然就会报错\n\n出现该报错的情况如下\n\n这个情况也提醒我们，不能在 const 修饰的函数中，调用非 const 修饰的成员函数\n\n2.4 常对象和常引用 2.4.1 常对象 可以用 const 来修饰一个对象，称为常对象\nconst &lt;classname&gt; s1;&lt;classname&gt; const s1;\n\n在初始化设置完常对象后，该对象的内容就不能进行修改。我们可以通过这个对象来访问内部被const 修饰的函数，且只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）\n\n常对象调用非 const 修饰函数会报错\n不能修改常对象中成员变量的值\n\nconst STU s1(&quot; 小明 &quot;, 15, 90.6);\n\n如果你想在定义 const 对象后依旧可以修改某一个成员变量的值，可以用 mutable 来修饰该成员变量，这样依旧可以修改这个值\nclass STU&#123;    mutable char *m_name;//mutable 修饰的成员变量，在 const 对象中仍然可以被修改    int m_age;    float m_score;&#125;;\n\n如上面的 name 变量，即便定义了 const 对象，也可以对它进行修改\n\n\n2.4.2 常引用 2.4.2.1 引用基本形式 引用的基本方式如下\nint a=10;int&amp; b=a;int&amp; c=a;// 同一个变量可以有多个别名// 可以用两个不同的变量名引用同一个// 但是引用了之后不可以更改对象\n\n此时的 b 和 c 都是 a 的别名，注意是别名！\n  \n可以  用两个不同的变量名  引用同一个变量，而且引用了之后不可以更改对象\n\n一个变量可以有多个引用\n指针可以更改指向的对象，引用不可以\n引用必须在定义的时候就初始化，不可以int&amp; b;\n\n\n比如你叫李华，有人叫你“小李”，还有人叫你“英语作文人”，这两个外号都是你的别名。指针并不是别名，指针是通过地址访问某个变量。而引用是给 a 变量起另外的两个名字，实际上 b 和 c 都可以当作 a 来使用\n编译运行代码，让编译器打印出这三者的地址，可以看到它们的  地址是一样的，因为它们本来就是同一个变量的不同名字。\n\n指针变量的地址  和指针变量  所指向对象的地址  是不同的，引用的类型必须和引用实体的类型相同，不能用 int&amp; 引用 double 类型\n\n\n2.4.2.2 引用的权限问题const 常量\n引用可以引用常量，但是必须加 const 修饰\n\n基本的思路就是“权限可以缩小，但不可以放大”。\n\n在上面的代码中，a 是一个可以修改的变量，但是 const int&amp;d=a; 中的 d 是不能修改，只可读取 a 的内容。\ne 是不可修改的常量，所以我们不能用 int&amp; 来放大权限\n\nint 和 double 相互引用\n在 1.1 中有提到，我们不能用 int&amp; 来引用 double 类型的变量，编译器会报错\n\n不过我们可以用 const int&amp; 类型来引用 double，此时引用就不是简单的一个别名了。\n先来了解一下把 double 复制给 int 类型，这时候会产生“隐式类型转换”，h 保存的是 z 的整数部分\n\n\n在这个过程中，编译器会产生一个临时变量存放 z 的整数部分，然后赋值给 h\n\n临时变量具有“常性”，可读不可改\n\n而当我们用 const int&amp; 类型来引用 double 时，实际上引用的是编译器产生的临时变量，它是一个常量，所以我们需要用 const int&amp; 来引用\nconst int&amp; i=z;// 这里的 i 是临时变量的别名// 在引用的时候，创建了一个临时变量存放 d 的整数部分//i 的地址和 z 不相同，且临时变量不会销毁，生命周期和 i 同步// 生成的这个临时变量是常量，所以 i 的本质是引用了一个 int 类型cout &lt;&lt;&quot;i= &quot;&lt;&lt;i&lt;&lt;endl;cout &lt;&lt;&quot;&amp;i= &quot;&lt;&lt; &amp;i &lt;&lt;endl; cout &lt;&lt;&quot;&amp;z= &quot;&lt;&lt; &amp;z &lt;&lt;endl;// 在 c++ 中函数主要使用引用传参，后面会进一步学习\n\n一个非常直观的验证方法，就是打印一下，瞅瞅它们的地址是否相同。可以看到，i 的值和 h 是相同的，因为它引用的就是那个  存放了整数部分的临时变量，这个临时变量的地址和 z 不同\n\n2.5 this 指针及工作原理 2.5.1 特点 当你用同样的图纸建了很多个屋子后，有没有想过应该如何区分它们呢？\nC++ 在设计这部分的时候，添加了一个 this 指针来解决这个问题：C++ 编译器给每个“非静态的成员函数“增加了一个隐藏的指针参 数，让该指针指向当前对象 (函数运行时调用该函数的对象)，在函数体中所有成员变量的操作， 都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。\n\nthis 指针的类型：类名 * const \n只能在“成员函数”的内部使用 \nthis 指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给 this 形参。所以对象中不存储 this 指针。 \nthis 指针是成员函数第一个隐含的指针形参，一般情况由编译器通过 ecx 寄存器自动传递，不需要用户传递\n\n2.5.2 显式使用 this就用下面这个函数举例\nvoid Print()&#123;\tcout&lt;&lt;_name&lt;&lt;endl;\tcout&lt;&lt;_sex &lt;&lt;endl;&#125;\n\n实际上，在调用它的时候，编译器会做如下处理。因为只有这样，才能完整的区分两个不同的类。\nvoid Print(Student*const this)&#123;\tcout&lt;&lt;this-&gt;_name&lt;&lt;endl;\tcout&lt;&lt;this-&gt;_sex &lt;&lt;endl;&#125;\n\n进一步看看下面这个代码，可以帮助你理解 this 指针\nbool operator==(const Date&amp; d)&#123;       return _year == d._year           &amp;&amp; _month== d._month           &amp;&amp; _day == d._day;&#125;\n\n这是一个日期的比较函数，是操作符重载（后面会讲到）。你可以看到，这个函数我们传入了一个Date 类型的引用，这是区别于 this 的另外一个类的对象。\n如果没有 this，那就很难区分两个变量的_year，于是编译器会把它优化成下面这样，就不会存在无法区分的问题了\nbool operator==(Date*const this,const Date&amp; d)&#123;       return this-&gt;_year == d._year           &amp;&amp; this-&gt;_month== d._month           &amp;&amp; this-&gt;_day == d._day;&#125;\n\n2.5.3 空指针问题  在程序中，访问 NULL 不会报错，但是解引用 Null 会报错\n#include&lt;iostream&gt;using namespace std;class ta&#123;public:    void Print()    &#123;        cout&lt;&lt;&quot;print ta&quot;&lt;&lt;endl;        //cout&lt;&lt;_a&lt;&lt;endl;//err    &#125;private:    int _a;&#125;;int main()&#123;    ta* p=nullptr;    p-&gt;Print();   // 可以去访问空指针的函数   // 因为函数只是去调用了类里面的 Print 函数   // 同时传了一个 p 的 this 指针（空指针传参是不会报错的）   // 但是如果你去访问 p 里面_a 变量，就会报运行错误    return 0;&#125;\n\n2.6 类间关系 2.6.1  友元关系 友元分为友元函数和友元类。友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。\n2.6.1.1 友元函数  友元函数相当于这个类的好朋友，它并不是类的成员函数，但是可以访问这个类的私有成员。友元函数没有 this 指针，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部明，声明时需要加 friend 关键字。\nclass DATE&#123; // 友元函数friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Date&amp; d);                                      friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Date&amp; d);&#125;;\n\n以 &lt;&lt; 和 &gt;&gt; 操作符重载为例，如果我们直接在类里面定义的话，使用这个重载的方式就会变成下面这样\nDATE d1;d1&lt;&lt;cout;d1&gt;&gt;cin;\n\n因为对于双目操作符，重载的时候，编译器是将第一个参数作为操作符的左值的。在类里面定义时，第一个操作数是隐含的 this 指针。即必须用对象名作为左操作数来进行使用。这样虽然也能完成既定任务，但这个使用方式未免太过奇葩了。\n定义为友元后，没有隐含的 this 指针，就可以使用 cout&lt;&lt;d1 这种正常的方式来调用这个操作符重载了\n\n一个函数可以是多个类的友元函数\n友元函数不能用 const 修饰\n友元函数可以在类定义的任何地方声明，不受类访问限定符限制\n友元函数的调用与普通函数的调用和原理相同\n\n\n2.6.1.2 友元类  友元类的所有成员函数都可以是另一个类的友元函数，都可以访问  另一个类中的非公有成员。 \n\n友元关系是单向的，不具有交换性：比如有 A 类和 B 类，在 A 类中声明 B 类为其友元类，那么可以在 B 类中直接访问 A 类的私有成员变量，但想在 A 类中访问 B 类中私有的成员变量则不行。 \n友元关系不能传递：如果 B 是 A 的友元，C 是 B 的友元，则不能说明 C 时 A 的友元。\n\nclass B;// 前置声明class A&#123;\t// 声明友元类\tfriend class B;    private:    int _n;&#125;;class B&#123;public:    // 可以在类里面通过对象访问 A 的非公有成员\tvoid Print()    &#123;        cout&lt;&lt;_a1._n&lt;&lt;endl;    &#125;private:    A _a1;&#125;;\n\n2.6.2 整体部分关系 2.6.2.1 内嵌对象 内嵌对象：在一个类中定义另外一个类的对象\n在一些应用场景中，我们会需要在一个类里面定义另外一个类的对象。如下面这道 OJ 题中，我们需要用两个队列的类来实现这里的MyStack。\n\nclass Queue&#123;  // 队列的实现 &#125;;class MyStack &#123;public:    MyStack() &#123;    &#125;   //.....private:\tQueue q1;     Queue q2;&#125;;\n\n对于内部对象 Queue，需要注意的有以下几点：\n\n内部对象属于外置类型，在对象实例化的时候，编译器会去调用 Queue 的构造函数\n不能在 MyStack 类中直接对 Queue 进行初始化\n\n如果在 Queue 中定义了有参的构造函数，需要在 MyStack 构造函数中的  初始化列表处  进行初始化操作\n2.6.2.2 组合聚合问题  当一个类的对象拥有另一个类的对象时，就会发生类聚合：\n\n母类 A 的每一个对象中都会包含一个或多个 B 类的对象\n类组合是一种特殊的聚合形式，其中拥有者类控制被拥有者类对象的生命周期。\n\n依旧以上面的 MyStack 代码为例，当我们在里面定义了 Queue 对象 q1 和 q2 后，它们的生命周期和 MyStack 类对象的生命周期同步。MyStack 类会先构造，然后构造 q1 和 q2；q1 和 q2 分别析构后，才会析构 MyStack 的类对象。\n2.6.2.3 内部类  当定义内部类时，内部类默认为外部类的友元，可以直接访问外部类的非公有成员。但是内部类是一个独立的类，外部类不能访问内部类的非私有成员，也不能通过外部类的对象来访问内部类的成员。\nclass A&#123;public:    class B&#123;      void Prin(const A&amp; a1)      &#123;          cout&lt;&lt; a1._a &lt;&lt;endl;// 可以直接通过对象来访问私有成员          cout&lt;&lt; count&lt;&lt;endl;// 外部的静态成员可以直接访问          cout&lt;&lt; _b &lt;&lt;endl;      &#125;      int _b;      &#125;;private:    int _a;    static int count;&#125;;int A::count=0;\n\n2.6.3 继承派生关系 2.6.3.1 基本用法 继承和派生是父与子的关系，其中子类拥有父类成员的同时，还会拥有自己的成员\n\n继承是一个特殊的语法，用于多个类有公共部分的时候\n父类：基类\n子类：派生类\n\n// 举例：网站的公共部分class ART &#123;public:\tvoid header()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; &quot; 归档 &quot; &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;\tvoid footer()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 关于我们 &quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot; 网站访问量 &quot; &lt;&lt; endl;\t&#125;\tvoid func()// 文章页面\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; endl;\t&#125;&#125;;class LINK &#123;public:\tvoid header()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; &quot; 归档 &quot; &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;\tvoid footer()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 关于我们 &quot; &lt;&lt; &quot; 网站访问量 &quot; &lt;&lt;endl;\t&#125;\tvoid func()// 友链页面\t&#123;\t\tcout &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n在上面的情况中，ART 和 LINK 类中都有网站的公共部分，这时候就出现了代码的重复。继承的出现就是用于解决这个问题的\n// 下面使用继承的方式来写，WEB 类是网站的公共部分class WEB &#123;public:\tvoid header()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; &quot; 归档 &quot; &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;\tvoid footer()// 所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot; 关于我们 &quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot; 网站访问量 &quot; &lt;&lt; endl;\t&#125;&#125;;//ART、LINK 是两个子类，继承了 WEB 的公共部分// 这样就减少了代码量class ART : public WEB&#123;public:\tvoid func()// 文章页面\t&#123;\t\tcout &lt;&lt; &quot; 文章 &quot; &lt;&lt; endl;\t&#125;&#125;;class LINK : public WEB &#123;public:\tvoid func()// 友链页面\t&#123;\t\tcout &lt;&lt; &quot; 友链 &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n测试可以发现，ART 和 LINK 作为派生类，在继承了基类 WEB 的成员的基础上，还拥有了它们独特的单独成员\n\n同一个类可以同时继承多个基类\nclass C : public A,public B&#123;//.....&#125;;\n\n2.6.3.2 权限问题  继承有 3 中类型：public、private、protected。这里会显示出类中 protected 权限和 private 权限的区别\nclass A&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\n当我们分别用上面三种方式对类 A 进行继承的时候，得到的结果是不同的\n\n用什么继承方式，派生类中继承的成员就变成什么类型\n不管用什么继承方式，都无法访问基类中的私有成员\n\n\n2.6.3.3 同名问题  当基类和派生类中出现同名成员函数或者同名成员变量时，会出现冲突。这时候编译器会做一定的处理：直接访问变量名和函数名的时候，优先访问派生类自己的成员\n// 继承同名成员的处理//\t普通的同名成员class DAD1 &#123;public:\tDAD1()\t&#123;\t\t_a = 100;\t&#125;\tvoid func()// 同名函数\t&#123;\t\tcout &lt;&lt; &quot;DAD func&quot; &lt;&lt; endl;\t&#125;\tvoid func(int i)\t&#123;\t\tcout &lt;&lt; &quot;DAD func int: &quot; &lt;&lt; i &lt;&lt; endl;\t&#125;\tint _a;// 基类中的该变量&#125;;class SON1 : public DAD1&#123;public:\tSON1()\t&#123;\t\t_a = 20;\t&#125;\tvoid Print()\t&#123;\t\tcout &lt;&lt;&quot;SON: &quot; &lt;&lt; _a &lt;&lt; endl;// 优先访问派生类的_a\t\tcout &lt;&lt;&quot;DAD: &quot; &lt;&lt; DAD1::_a &lt;&lt; endl;// 访问基类的_a\t&#125;\tvoid func()// 同名函数\t&#123;\t\tcout &lt;&lt; &quot;SON func&quot; &lt;&lt; endl;\t&#125;\tint _a;// 派生类的同名变量&#125;;\n\n\n如果是静态成员，访问方法就有所变化\n// 访问同名的静态成员class DAD2&#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1 &quot; &lt;&lt; endl;\t&#125;\tstatic void Test1(int n)\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1(int)  &quot; &lt;&lt; n &lt;&lt; endl;\t&#125;&#125;;int DAD2::D_a = 100;class SON2 : public DAD2 &#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;SON2 Test1 &quot; &lt;&lt; endl;\t&#125;&#125;;int SON2::D_a = 200;\n\n\n2.6.3.4 虚继承  有的时候，继承会出现下面这种情况：一个子类继承了两个基类，而这两个基类又同时是一个基类的派生类\n\n这时候，D 里面就会有两份 A 的内容，相当于两份公共部分。这是我们不想看到的，因为会造成空间浪费。而且直接访问的时候，编译器会报错“对变量 X 的访问不明确”\n\n和前面说道的同名问题一样，我们可以指定作用域来访问特定的变量，但是这样是治标不治本的方法，并没有解决空间浪费的问题。\n// 解决方法 1（治表不治本）// 用类域来修改和访问cout &lt;&lt; &quot;intel: &quot; &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;cout &lt;&lt; &quot;amd: &quot;   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;\n\n这就需要我们使用  虚继承  来操作：给 B 和 C 对 A 的继承加上 virtural 关键字\nclass CPU &#123;public:\tCPU()\t\t:_Structure(&quot;x86&quot;)\t&#123; &#125;\tchar _Structure[100];&#125;;class INTEL : virtual public CPU &#123;public:\tINTEL()\t\t:i_Brand(&quot;intel&quot;)\t&#123;&#125;\tchar i_Brand[10];&#125;;class AMD : virtual public CPU &#123;public:\tAMD()\t\t:a_Brand(&quot;amd&quot;)\t&#123;&#125;\tchar a_Brand[10];&#125;;\n\n这时候直接访问变量就不会报错了。因为这时候，B 和 C 中的该变量指向了同一个地址，修改操作会同步。\n\n2.7 多态性\n静态多态：运算符重载\n动态多态：派生类和虚函数组成的多态\n\n2.7.1 运算符重载 2.7.1.1 定义 在讲解赋值运算符重载之前，我们可以来认识一下完整的运算符重载：C++ 为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。\n函数名为：关键字 operator运算符，如operator=\n函数原型：返回值类型 operator 操作符(参数列表)，如Date operator=();\n下面有几点注意：\n\n重载操作符必须有一个自定义类型的操作数（即操作符重载对内置类型无效）\n不能通过其他符号来创建新的操作符\n对于类类型的操作符重载，形参比操作数少一个传参（因为有一个默认的形参 this 指针）\n这 5 个操作符是不能重载的：.*、::、sizeof、? :、.\n\n2.7.1.2 基本使用  以下是在全局定义的操作符重载，用于判断日期是否相等\nbool operator==(const Date&amp; d1, const Date&amp; d2)&#123;    return d1._year == d2._year;    &amp;&amp; d1._month == d2._month    &amp;&amp; d1._day == d2._day;&#125;\n\n当我们在 main 函数中使用 d1==d2 的时候，编译器就会自动调用该操作符重载\n当然，你也可以自己来传参使用，如if(operator==(d1,d2))\n但是这样非常不方便，和调用一个而普通函数没啥区别，压根算不上操作符重载。所以我们一般是  在类里面  定义操作符重载的\n\n当我们把它放入类 Date 中间，就需要修改成下面这样\nbool operator==(const Date&amp; d2)&#123;    return _year == d2._year;    &amp;&amp; _month == d2._month    &amp;&amp; _day == d2._day;&#125;\n\n编译器在调用的时候，会优化成下面这样\nbool operator==(Date* this, const Date&amp; d2)// 显示调用为 d1.operator==(d2);\n而在 main 里面使用的时候，这个重载后的操作符和原本的使用方法完全相同\nDate d1(2022,6,1)Date d2(2022,5,1)d1==d2;// 自动调用操作符重载 d1.operator==(d2);\n\n\n2.7.1.3 赋值运算符重载  因为每一个类都有不同的成员，编译器不可能智能的进行赋值操作。这时候就需要我们自己写一个赋值运算符重载来进行赋值操作了\n以日期类为例，赋值操作其实就是把内置类型成员一一赋值即可\nDate&amp; operator=(const Date&amp; d)&#123;    if(this != &amp;d)// 避免自己给自己赋值    &#123;        _year=d._year;        _month=d._month;        _day=d._day;    &#125;    return *this;&#125;\n\n编写赋值重载代码的时候，需要注意下面几点：\n\n返回值和参数类型（注意要引用传参，不然会调用拷贝构造）\n检测是否自己给自己赋值（避免浪费时间）\n因为返回的是*this，出了函数后没有销毁，所以可以用传引用返回\n一个类如果没有显式定义赋值运算符重载，编译器也会自己生成一个，完成对象按字节序的值拷贝。\n\n如果类中有  自定义类型，编译器会默认调用它的赋值运算符重载\n2.7.1.4 拷贝构造和赋值重载的调用问题  当赋值操作符和拷贝构造同时存在的时候，什么时候会调用赋值，什么时候会调用拷贝构造呢？\n\n在这两个函数中添加 cout 进行打印提示，可以看到：\n\n如果对象在之前已经存在，就会调用赋值重载\n如果是一个全新的变量在定义的时候初始化，就调用的是拷贝构造\n\n\n2.7.2 虚函数 2.7.2.1 基本使用以及动态多态 虚函数，并不代表这个函数是虚无的。而表示这个函数在一定情况下会被替换（就好比继承中的虚继承问题）。要实现动态多态，就需要借助虚函数来实现。以下面这个动物说话的代码为例\n#include &lt;iostream&gt;using namespace std;class Animal &#123;public:\t//void Talk()\tvirtual void Talk()// 虚函数\t&#123;\t\tcout &lt;&lt; &quot;Animal is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class CAT : public Animal&#123;public:\tvoid Talk()// 同名函数\t&#123;\t\tcout &lt;&lt; &quot;CAT is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class DOG : public Animal &#123;public:\tvoid Talk()// 同名函数\t&#123;\t\tcout &lt;&lt; &quot;DOG is talking&quot; &lt;&lt; endl;\t&#125;&#125;;// 基类中不使用虚函数时，该函数的内容已确定// 不管传参什么类，都会调用 Animal 自己的 Talk 函数// 加上虚函数 virtual 后，会调用 CAT 和 DOG 的 Talk 函数void MakeTalk(Animal&amp; it) &#123;\tit.Talk();// 调用对应的 Talk 函数&#125;\n\n当基类 Animal 中的 Talk 函数没有用 virtual 修饰时，不管给这个函数传参什么类的对象，它都会调用 Animal 自己的 Talk 函数\n\n当我们用虚函数进行修饰后，就会调用派生类 CAT 和 DOG 的 Talk 函数，这就实现了一个简单的动态多态。\n\n对于虚函数，有几点需要注意：\n\n当基类的指针或引用指向派生类的对象时，就会触发动态多态，派生类中的同名函数会覆写基类中的虚函数\n不能定义静态虚函数——因为静态函数是属于整个类的，而不是属于某一个对象\n不能定义虚构造函数——总不能用派生类的构造来覆写基类的构造吧？\n析构函数可以是虚函数\n\n2.7.2.2 虚析构函数  有的时候，我们需要析构一个对象时，往往会给基类的析构函数加上 virtual 修饰，这样只要传派生类的对象给基类的指针 &#x2F; 引用，就可以直接调用派生类对应的析构函数，完成不同的析构操作。而不是都呆呆的调用基类的析构函数——那样就会产生内存泄漏\n#include&lt;iostream&gt;using namespace std;class Queue &#123;public:\tQueue()\t\t:_a(new int[10])\t&#123;\t&#125;\tvirtual ~Queue() &#123;\t\tcout &lt;&lt; &quot;~Queue&quot; &lt;&lt; endl;\t\tdelete[] _a;\t&#125;private:\tint* _a;&#125;;class MyStack :public Queue &#123;public:\tMyStack(int capa)\t\t:_a1(new int[capa])\t&#123;&#125;\t~MyStack() &#123;\t\tcout &lt;&lt; &quot;~MyStack&quot; &lt;&lt; endl;\t\tdelete[] _a1;\t&#125;private:\tint* _a1;&#125;;int main()&#123;\tQueue* q1=new MyStack(4);// 父类指针指向子类\tdelete q1;// 调用子类的析构函数，再调用父类析构\treturn 0;&#125;\n\n运行之后，可以看到，我们成功通过父类的指针，调用了子类的析构函数。子类的析构函数中本身就会自动调用父类析构函数。这样一来，子类和父类都被成功析构，不会出现内存泄漏\n$ ./test~MyStack~Queue\n\n如果去掉父类析构函数的 virtual 关键字，则只析构父类\n$ ./test~Queue\n\n\n2.7.3 纯虚函数  在虚函数的基础上，C++ 定义了纯虚函数：有些时候，在基类里面定义某一个函数是没有意义的，这时候我们可以把它定义为  纯虚函数，具体的实现让派生类去同名覆写。\n纯虚函数的基本形式如下\n//virtual 函数返回类型 函数名()=0;virtual void Print()=0;\n\n派生类中必须重写基类的纯虚函数，否则该类也是抽象类\nclass A &#123;public:\t//virtual void Print();// 虚函数\tvirtual void Print() = 0;// 纯虚函数&#125;;class B :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;B print &quot; &lt;&lt; endl;\t&#125;&#125;;class C :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;C print &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n当我们在派生类中覆写了该函数后，即可实例化对象并调用该函数\n\n和虚函数一样，使用基类的引用或指针来接收派生类的对象，即可调用对应的函数\n\n2.7.4 抽象类  包含纯虚函数的类就是抽象类，抽象类有下面几个特点：\n\n抽象类无法实例化对象\n抽象类的派生类必须重写基类的纯虚函数，不然派生类也是抽象类\n如果在基类中定义的纯虚函数是 const 修饰的，则派生类中对应的函数也需要用 const 修饰\n\n\n第三章  面向对象应用3.1 矩阵类设计及应用\n矩阵类要求：设计一个矩阵类，要求能够根据用户需求构建 row 行、column 列的矩阵，并灵活接受反馈矩阵元素信息（如：某行、某列、某行某列元素）。实现矩阵的相关运算，包括矩阵加（+）、矩阵乘（*）、矩阵输出（&lt;&lt;）、矩阵赋值（&#x3D;）、获取矩阵指定位置元素值（[]）\n\n设计该程序的时候，需要注意下面几点：\n\n重载矩阵类必须使用二维数组，不能用一维数组 + 公式判断的方法（因为这样无法重载 [] 操作符）\n重载矩阵加减和相乘的运算符时候需要注意矩阵运算的规则（第一行 x 第一列 &#x3D; 第一个）\n\n\n\n对于 + 和 - 的重载不应该修改原本的矩阵，应该创建临时对象 tmp 后，修改 tmp 的值并返回\n\nint a1=1,a2=2;a1+a2;// 这样相加并不会影响 a1 和 a2 的值\n\n如果需要修改原本的矩阵，应该重载的操作符是 +&#x3D; 和 -&#x3D;\n\n对于矩阵输出 &lt;&lt; 的重载，必须使用友元函数，否则使用会变成  对象 &lt;&lt;cout，不是正常使用的方法\n对于获取矩阵指定位置元素值 [] 的重载，应该返回 int* 类型。在最开始设计的时候我错误写成了 int 类型，无法正确地连续使用两个[]\n\n// 重载 [] 操作符 int* operator[](int row)&#123;    return arr[row];&#125;// 使用该操作符a1[1][3];// 第一个[] 是操作符重载 a1[1];// 返回了第二行的数组名// 第二个[] 是普通的操作符本身，访问返回的数组名找到对应列的值\n\n矩阵类完整代码实现见附录。\n3.2 银行账户管理系统设计及应用\n银行账号管理系统要求：管理不同用户在银行的金融资产，每个用户可以拥有多种银行账户（如：定期储蓄、活期储蓄、信息卡、电子账户、贷款账户等）。账户包括账号、余额、利率等基本信息，用户可以进行账户信息查询、存款、取款、结算利息等操作。银行需统计所有账户的总金额、验证银行系统收支平衡，并能够及时预警反馈。设计 Account 抽象类作为所有银行账户顶层祖先，根据实际应用需求合理设置派生层次及相应子类。结合银行利息结算、用户贷款申请等实际应用需求，适当添加辅助类协同操作。合理定义虚基类、虚函数、纯虚函数、抽象类完成银行账号管理系统的稳定可靠运行。\n\n3.2.1 基本思路  以下是我设计该管理系统的思路：\n\n设计了 Account 类的主框架，作为后续类的基类\n通过多态，实现了活期储蓄、定期储蓄类、信用卡类、贷款账户的功能\n实现了简易菜单，通过 switch case 语句和 do while 语句实现多次调用不同函数接口的操作\n与  日期类  结合，实时计算天数差距并结算利息\n\n在设计该菜单的过程中，我发现了很多问题需要注意，这些问题也加深了我对编程知识点的理解。\n完整代码实现见附录。\n3.2.2 设计系统时遇到的问题  在设计贷款账户的时候，容易出现 double 浮点数存放精度的问题。用户贷款额度和余额直接若直接判断相等，很难得到正确结果（因为浮点数后面会跟着很多没有打印出来的小数）\n\n这就会出现，即便你根据程序接口中“查看待还金额”来得到自己的待还金额，并执行还款操作后，还是会有一部分小数位的数据并没有完整还完，这一部分的处理是非常困难的。为了避免用户永远都还不完自己的贷款，我设置了 double 的修约规则，即当用户余额和贷款 &#x2F; 透支额度的差值小于 0.2 时，不再处理后续的小数位\nif (_Max - _money &lt; 0.2)// 浮点数精度问题&#123;    cout &lt;&lt; &quot; 无需还款 &quot; &lt;&lt; endl;    return -1;&#125;\n\n同时在余额计算中进行取零修约，保证“剩余待还”打印值和“查看待还金额”函数的打印值同步。用这种方式间接解决了精度问题。\n// 待还金额为透支额度 + 利息double money = (_Max - _money) + Income(tmp);if (money &lt; 0.02) &#123;\tmoney = 0;// 修约浮点数，解决精度问题&#125;\n\n在设计销户接口时，为了避免用户在销户后仍然能操作该账户，不能只是简单的使用 break 跳出单层循环，而是需要用 return 直接终止该程序。\ncase 8:&#123;    cout &lt;&lt; &quot; 销户后，账户内的一切信息都会被清空 &quot; &lt;&lt; endl;    cout &lt;&lt; &quot; 请问您确认销户吗？Y/N&quot; &lt;&lt; endl;    char a;    cin &gt;&gt; a;    if (a == &#x27;Y&#x27;) &#123;        delete A;        A = nullptr;        cout &lt;&lt; &quot; 销户完成 &quot; &lt;&lt; endl;        return;// 终止程序    &#125;    break;&#125;\n\n3.2.3 一些缺陷1. 文件操作\n该银行管理类还可以添加文件操作，来保存用户的信息。原先想法是在 Account 类中定义 static 全局变量进行count++，以此得出所有派生类构造对象的总和。再利用 for 循环进行读取文件操作，这样就能在下一次打开程序的时候，通过用户的账户来定位用户的某一个特定账户对象，进行后续的操作。\n但是 Account 类作为抽象类是  无法实例化对象  的，如果用各个派生类来进行文件管理操作，该程序就会变得很臃肿。且由于本人能力问题，没能设计出循环读取文件内容，并进行定位下一个对象位置的操作，故在最终的设计中没有实现文件操作。\n2. 时间问题\n为了代码测试需要，每一次操作都需要用户手动输入日期。在实际应用中，这项工作应该由银行用户终端自动化承担。可以设计读取预定义宏 __TIME__ 来获取每一次操作的时间，从而实现和现实中的时间对照，去除每一次都需要手动输入代码的繁琐\n第四章  面向对象程序设计学习总结  学习代码需要有一个持之以恒的心，再学习知识点的基础上要同时坚持写代码的练习。我在 Gitee 码云上创建了自己的学习仓库，坚持每天托管代码，作为自己学习编程打卡的一个记录\n\n和其他科目不同，CPP 的学习是不能只停留在书籍和纸笔上的，只有你上手自己敲代码了，才能认识到一些光是听讲和看书学习不到的知识。比如一些程序出现 bug 之后的 VS调试技巧，都是我在练习中学会的。\n\n同时还需要学会利用工具，如在 cplusplus 网站 上查找函数的定义，根据给出的代码示例尝试自己使用这个函数，并做到能在后面的程序设计中活学活用。\n个人认为，不管学习的编程语言是什么，只有综合以上几点，才能真正学好编程。\n附录\n矩阵类和银行管理系统完整代码👉【传送门】\n部分资料参考 C 语言中文网👉http://c.biancheng.net/\n\n","categories":["遇见C++"],"tags":["Linux","C++","类和对象"]},{"title":"【MySQL】索引","url":"/posts/3474107655/","content":"1. 索引 1.1 为啥需要索引？ 对于数据库而言，查询始终是一个高频的操作；假设在数据量到百万级的时候，查询一个用户信息就要花 5 秒中，那用户肯定不愿意等待你的系统响应，这就造成了用户流失。\n所以，MySQL 必须使用某种方式来保证查询的高速可靠，索引就诞生了；\n对于使用者而言，索引是很香的，因为你只需要执行 create index 给指定的列，那么 MySQL 就会自动帮你维护一系列索引创建的操作，查询嘎嘎快！\n但，查询速度的提高是以插入、更新、删除等操作的速度为代价的，这些写操作会增加大量的 IO；索引的价值在于提高海量数据的查询速度；\n常见的索引\n\n主键索引\n唯一键索引\n普通索引\n复合索引\n全文索引\n\n1.2 索引的效果  通过如下的大数据用例，我们能看到索引的效果几何\ndrop database if exists `bit_index`;create database if not exists `bit_index` default character set utf8;use `bit_index`;-- 构建一个 8000000 条记录的数据-- 构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解-- 产生随机字符串delimiter $$create function rand_string(n INT)returns varchar(255)begindeclare chars_str varchar(100) default&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;declare return_str varchar(255) default &#x27;&#x27;;declare i int default 0;while i &lt; n doset return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1));set i = i + 1;end while;return return_str;end $$delimiter ;-- 产生随机数字delimiter $$create function rand_num()returns int(5)begindeclare i int default 0;set i = floor(10+rand()*500);return i;end $$delimiter ;-- 创建存储过程，向雇员表添加海量数据delimiter $$create procedure insert_emp(in start int(10),in max_num int(10))begindeclare i int default 0;set autocommit = 0;repeatset i = i + 1;insert into EMP values ((start+i),rand_string(6),&#x27;SALESMAN&#x27;,0001,curdate(),2000,400,rand_num());until i = max_numend repeat;commit;end $$delimiter ;-- 雇员表CREATE TABLE `EMP` (  `empno` int(6) unsigned zerofill NOT NULL COMMENT &#x27; 雇员编号 &#x27;,  `ename` varchar(10) DEFAULT NULL COMMENT &#x27; 雇员姓名 &#x27;,  `job` varchar(9) DEFAULT NULL COMMENT &#x27; 雇员职位 &#x27;,  `mgr` int(4) unsigned zerofill DEFAULT NULL COMMENT &#x27; 雇员领导编号 &#x27;,  `hiredate` datetime DEFAULT NULL COMMENT &#x27; 雇佣时间 &#x27;,  `sal` decimal(7,2) DEFAULT NULL COMMENT &#x27; 工资月薪 &#x27;,  `comm` decimal(7,2) DEFAULT NULL COMMENT &#x27; 奖金 &#x27;,  `deptno` int(2) unsigned zerofill DEFAULT NULL COMMENT &#x27; 部门编号 &#x27;);-- 执行存储过程，添加 8000000 条记录call insert_emp(100001, 8000000);\n\n在这个表里面，有大量的数据，其默认状态下，并没有配置索引\nMariaDB [bit_index]&gt; desc EMP;+----------+--------------------------+------+-----+---------+-------+| Field    | Type                     | Null | Key | Default | Extra |+----------+--------------------------+------+-----+---------+-------+| empno    | int(6) unsigned zerofill | NO   |     | NULL    |       || ename    | varchar(10)              | YES  |     | NULL    |       || job      | varchar(9)               | YES  |     | NULL    |       || mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       || hiredate | datetime                 | YES  |     | NULL    |       || sal      | decimal(7,2)             | YES  |     | NULL    |       || comm     | decimal(7,2)             | YES  |     | NULL    |       || deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |+----------+--------------------------+------+-----+---------+-------+8 rows in set (0.001 sec)\n\n此时如果你直接全列查询，进程就会阻塞在这里\n\n进 MySQL 的文件路径看看，会发现这张表的大小已经到了惊人的 564mb，虽然我们的内存也许能存的下这么大的数据，但实际 IO 读写这么大量的数据是非常耗时的\n[root@vm-cnt8:/var/lib/mysql/bit_index]# ll -htotal 565M-rw-rw----. 1 mysql mysql   61 Sep  6 05:36 db.opt-rw-rw----. 1 mysql mysql  770 Sep  6 05:36 EMP.frm-rw-rw----. 1 mysql mysql 564M Sep  6 05:39 EMP.ibd\n\n在之前的查询操作中提到过，对于这种大数据表的时候，我们应该避免使用全列查询，而应该设置 limit 只查询出少量用例数据，来判断这个表的数据结构和作用\nMariaDB [bit_index]&gt; select * from EMP limit 3;+--------+--------+----------+------+---------------------+---------+--------+--------+| empno  | ename  | job      | mgr  | hiredate            | sal     | comm   | deptno |+--------+--------+----------+------+---------------------+---------+--------+--------+| 100002 | FNXAKX | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    327 || 100003 | rQbLBy | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    394 || 100004 | wRVdDF | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    195 |+--------+--------+----------+------+---------------------+---------+--------+--------+3 rows in set (0.001 sec)\n\n在没有索引的情况下进行一个查询，用时大约在 1.6 秒左右\n\n这时候我们来对 empno 列创建一个主键索引\nalter table EMP add primary key(empno);\n\n因为表中的数据很多，所以设置主键索引也需要耗费一定时间，这个时间内，其实就是 MySQL 在后台帮我们创建索引所需要的数据结构的过程\nMariaDB [bit_index]&gt; alter table EMP add primary key(empno);Query OK, 0 rows affected (17.184 sec)              Records: 0  Duplicates: 0  Warnings: 0\n\n再来查询一下刚刚查询的数据，可以看到，用时只有0.000 sec，直接秒回！\n\n这便是索引在提升性能方面的重大作用！\n1.3 MySQL 和文件系统 1.3.1 Linux 文件系统 在之前对 Linux 文件系统 的学习中，我们知道在磁盘中，一个区块是 512KB，在 Linux 系统中，为了提高效率，会采用 4KB 的分块对数据进行读取。哪怕你只是修改 1KB，也是需要将 4KB 完整读取，再写入回去的。\n\n因为机械硬盘物理结构的限制，随机读取的性能不佳，一次性读取 100KB 数据，远远优于 100 次读取 1KB。因为一次性读取的时候，只需要一次寻道就能将磁头摆到正确的位置，往里面写数据就完事了。但多次读取小数据的时候，尽管相邻的两次 IO 操作在同一时刻发出，但如果它们的请求的扇区地址相差很大的话也只能称为随机访问，而非连续访问。\n随机访问就要多次寻道，每次写入的量又很少，大大增加了 IO 的负担。\n1.3.2 MySQL 和磁盘交互基本单位 16KB而 MySQL 中，为了更好的实现对数据 IO 量的缩减和控制，其内部将 16KB 作为一次 IO 的基本单位，这个大小我们叫做 MySQL 的文件 Page；\n\nMySQL 中的数据文件，都是以 Page 为基本单位保存至磁盘里面的；\nMySQL 中的 CURD 操作，都需要通过计算来定位到需要修改和访问的数据的位置；\n涉及到计算的操作都需要 CPU 参与，CPU 只能处理内存中的数据，这就要求 MySQL 需要提前将一部分数据加载到内存中；\n所以在 MySQL 运行的这段时间内，其操作的数据会同时存在于内存和磁盘中，需要以特定的策略将内存中的数据刷新到磁盘中；这个操作就是 IO，基本单位是 Page；\n为了更好的管理这些操作，MySQL 会自己维护一个 buffer pool 的内存空间，来进行缓存。\nMySQL 是一个应用程序，它的所有文件 IO 操作都需要通过操作系统提供的接口来实现！但内部的刷盘逻辑是可以由 MySQL 来调用系统接口来自主控制的，而不需要呆板地遵守操作系统的自动策略；（MySQL 创建 buffer pool 也是基于更高的自主性来考虑的）\n最终目标是尽可能地减少 IO 操作，提高运行效率；\n\n运行如下命令可以看到 MySQL 中关于 Page 设置的全局变量，即 16KB\nMariaDB [bit_index]&gt; SHOW GLOBAL STATUS LIKE &#x27;innodb_page_size&#x27;;+------------------+-------+| Variable_name    | Value |+------------------+-------+| Innodb_page_size | 16384 |+------------------+-------+1 row in set (0.001 sec)\n\n1.3.3 为什么要用 Page 为单位进行交互？为何 MySQL 和磁盘进行 IO 交互的时候，要采用 Page 的方案进行交互呢？用多少，加载多少不香吗？\n先来个测试用例看看吧，这是一个非常简单的用户表\n-- 主键默认生成主键索引create table if not exists user (    id int primary key,     age int not null,    name varchar(16) not null);-- 插入多条记录，主键没有按顺序插入mysql&gt; insert into user (id, age, name) values(3, 18, &#x27; 杨过 &#x27;);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into user (id, age, name) values(4, 16, &#x27; 小龙女 &#x27;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into user (id, age, name) values(2, 26, &#x27; 黄蓉 &#x27;);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into user (id, age, name) values(5, 36, &#x27; 郭靖 &#x27;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into user (id, age, name) values(1, 56, &#x27; 欧阳锋 &#x27;);Query OK, 1 row affected (0.00 sec)-- 最终发现数据是有序的mysql&gt; select * from user; +----+-----+-----------+| id | age | name      |+----+-----+-----------+| 1  | 56  | 欧阳锋     || 2  | 26  | 黄蓉       || 3  | 18  | 杨过       || 4  | 16  | 小龙女     || 5  | 36  | 郭靖       |+----+-----+-----------+5 rows in set (0.00 sec)\n\n在上面的 5 条记录中，如果 MySQL 要查找 id&#x3D;2 的记录，第一次加载 id&#x3D;1，第二次加载 id&#x3D;2，一次一条记录，那么就需要 2 次 IO。如果要找 id&#x3D;5，那么就需要 5 次 IO。\n但，如果这 5 条 (或者更多) 都被保存在一个 Page 中 (16KB，能保存很多记录)，那么第一次 IO 查找 id&#x3D;2 的时候，整个 Page 会被加载到 MySQL 的Buffer Pool 中，这里完成了一次 IO。但是往后如果在查找 id&#x3D;1,3,4,5 等，完全不需要进行 IO 了，而是直接在内存中进行了。所以，就在单 Page 里面，大大减少了 IO 的次数！\n虽然我们不能保证后续的几次 IO 一定在这次加载的 Page 中，但根据  局部性原理，其访问相近的几条数据的概率是很大的！所以这样最终是能提升 IO 效率的！\n往往 IO 效率低下的最主要矛盾不是 IO 单次数据量的大小，而是 IO 的次数。\n1.4 B+ 树和 Page有了对 Page 的认识，接下来就需要用一个数据结构来维护这些加载到 Buffer Pool 当中的 Page 了。这时候，我们的 B+ 树就登场了。\n1.4.1 单个 Page单个 Page 里面存放的肯定是一部分的数据，我们可以加上前后指针，以双链表的形式将所有 Page 连起来，这样就能实现数据的遍历；在 MySQL 中，就是这么操作的。\n\n因为存在主键，MySQL 还会给单个 Page 中的数据依照主键进行排序，从上图就能看出阿里，单个 Page 中数据是依照主键按序排列的；且每一个数据都会链接到下一个数据上；\n这样排序后，数据库在进行数据筛选的时候，就能更好的定位到数据的位置，减少查询耗时。插入时排序也能让后续在进行数据降序 &#x2F; 升序输出的时候，无需二次对数据进行排序了；\n1.4.2 多个 Page既然一个 Page 是如此，那多个 Page 呢？\n\n前面提到了，当 MySQL 需要加载数据的时候，会将和这个数据相邻近的其他数据，以 16KB 为单位一起加载到一个 Page 里面，并连接到这个双向链表上；\n这样，我们就可以通过多个 Page 的遍历来进行数据的定位\n可链表是一个线性结构，MySQL 肯定不可能用线性结构来维护数据吧？那样查询的效率也太低了，每次都需要 O(N)的遍历，数据一多就慢慢慢！\n\n\n所以，我们肯定要在双向链表的基础上添加其他的结构来进行查找的优化！这时候就可以引入  目录  了\n页目录  在我们看书的时候，就会有目录来帮助我们快速查找到某一个章节。比如我们想看第九章的内容，那就可以先看目录，找到第九章的页码，再进行阅读。\n对于 MySQL 中的数据，这个情景也是适用的，我们给数据上一个目录，查询的时候先根据目录定位到具体的 page，我们可以知道 1-10 号数据都在这个 page 里面，那就直接去里面找就行了；这时候查找的效率就比单纯的从链表开头进行遍历快多了！\n当然，和书籍的目录需要消耗纸张一样，在 MySQL 中对数据设置目录也是需要消耗空间的，这就是一种用空间换时间的做法，而在生产环境中，时间显然更加宝贵！\n单页目录  在单个 Page 里面，我们可以安如下的方式设定一个目录，嗝一定间隔就设置一个新的节点作为目录。在数据量小的时候，这个目录的作用不算大，但数据量一大，目录对搜索效率的提升是非常可观的！\n\n比如，我们要查找 id&#x3D;4 记录，之前必须线性遍历 4 次，才能拿到结果。现在直接通过目录 2[3]，直接进行定位新的起始位置，只需要遍历 3 次就能找到结果，提高了效率。\n\n即便在单个 Page 中添加目录会导致这个 Page 实际存放的数据变少，但这是必要的牺牲！\n\n多页目录  前面提到，MySQL 会自动把新的数据加载到一个 Page 中，并链接到已有链表上；但是线性遍历需要大量的 IO，每次遇到新的 Page 的时候，就需要将其加载到内存里面，进行遍历，这就使得单个 Page 中的目录不那么实用了；\n\n单个 Page 的目录是小节目录\n多个 Page 的目录是章节目录\n\n所以我们必须给多个 Page 也加上一个顶层的章节目录，进一步优化效率！\n\n使用一个 Page 来指向多个 Page，存放每个 Page 的起始 key 值（假设每个 Page 中的 key 都有序且为升序）；这个 Page 中不存放实际的数据，只有目录值；\n遍历的时候，先通过多 Page 的目录找到我们要去的 Page，再去访问该实际存储数据的 Page 中的单 Page 目录，最终查找到目标数据；\n所以，每个多 Page 的目录项中就是一个键值 + 对应普通 Page 的指针\n\n\n一层目录 Page 不够，我们还可以再加一层。这样就实现了一个类似于二叉树的结构，只不过每一个节点 Page 中都包含多个 Page 的 key+ 指针，最终只有叶子节点是实际存储数据的！\n\n这个数据结构就叫做 B+ 树（注意，不是 B 树！）而整个上图中的数据接就是 MySQL 中对 user 表做的索引！\n此时的查询，需要经过的节点肯定变少了，比如我们需要查询 id=12 的用户：\n\n顶层判断，12&gt;11&gt;1，向右走【2 次比较】\n第二层判断，12&gt;11 且 12&lt;16，向左走，来到具体的 Page【2 次比较】\n查找单页目录，12&gt;11 且 12&lt;13；【2 次比较】\n从 11 开始遍历，走一步就能找到【1 次比较】\n\n最终，我们查找 12 的操作只用了 7 次就成功了。而从投开始遍历需要 12 次才能找到它；\n遍历次数的减少，就等同于 IO 次数的减少，最终查询的效率就变高了！\n\n这里的分析可能有误，不过结论是没有问题的，分页肯定能增加查找的效率！\n\n另外，MySQL 还可以根据访问的频率，定期的释放一些 Page；比如在 B+ 树中，可能树的右半部分很少被访问，那就可以暂时释放这部分 Page 的空间，给其他表使用，真到遇到访问的时候，再去读盘去除这部分数据。这是由 MySQL 的缓存策略来自主决定的；\n毕竟当一个表非常大的时候，将其全部加载到内存里面是不可行的！必须要用缓存策略和局部性原理来加载频繁使用的数据到内存中，才能在效率和负载上达到平衡；\n不然你的 MySQL 无脑缓存 Page 导致占用过多内存，操作系统看不下去直接给你 KILL 了，那业务就完蛋了！🤣\n1.4.3 小结\nPage 分为目录页和数据页。目录页只放各个下级 Page 的最小键值和该 Page 的指针。\n查找的时候，自顶向下找，只需要加载部分目录页到内存，即可完成算法的整个查找过程，大大减少了 IO 次数\n范围查询的时候，可以找到区间边界的两个节点的位置，然后直接通过叶子节点的链表进行遍历，取出数据即可！\nMySQL 可以根据访问频率，适当地预先加载或者释放一些 Page 的空间，并不是说一张表的所有数据都必须全部加载到内存里面；\n\n后续我还会学习 B 树和 B+ 树数据结构在 CPP 中的实现，敬请关注我的博客！\n1.5 为什么其他数据结构不适合索引？在认识这个问题之前，我们首先要记住上文提到的一个结论：真正影响索引性能的，是和硬盘 IO 的次数，IO 次数越少，性能越高；\n\n链表、线性表：都是线性遍历，压根没有索引的功能\n二叉搜索树：在极端场景下会退化成普通二叉树，还是线性遍历\nAVLTree/RBTree：虽然相对平衡，但二叉结构会导致树的整体过高，自顶向下查询的时候，需要经过多层的多次 IO，才能找到目标数据（B+ 树的层数更少，在这种情况下 B+ 树更优秀）\nHASH：虽然查找的时候很快，基本能做到 O(1)，但范围查询的效果不佳；在 MySQL 中也是支持 HASH 索引的，比如 MEMOY/HEAP/NDB 存储引擎；\n\n\n那 B 树为什么不适合呢？作为一个多叉树结构，B 树的同层能比红黑树存储更多信息，看上去也是可以做索引的呀？\n牵扯到 B 树和 B+ 树的区别了，来看看二者的结构图\n\n文字说明如下：\n\nB 树的每一个节点都会存放一定的数据和 page 指针；\nB+ 树只有叶子节点会存放数据，非叶子节点只有 page 的目录；\nB+ 树的叶子节点全部相连；\n\n这就引出了 B+ 树的两个优点：\n\n因为 B+ 树的非叶子节点只需要存储 page 目录，所以在一个非叶子节点中就能存放较多的目录索引，使得树整体更矮；\nB+ 树的叶子节点全部相连，方便进行范围遍历，比如 where sal&gt;100 and sal &lt; 300 的这种范围条件，就可以直接通过叶子节点的链表向后遍历来解决；\n\n最终的效率问题依旧落到了如何让树更矮来  减少 IO 次数，因为在整体上 B+ 树都能做到较矮，查询效率优秀，方便范围查询；所以 MySQL 主要选用了 B+ 树作为索引结构。\n1.6 聚簇 &#x2F; 非聚簇索引 1.6.1 说明InnoDB 的数据是和 B+ 树一起存放的，叶子节点里面有数据；这种数据和索引在一起的形式，叫做 聚簇索引。\n\nMyISAM 的叶子中没有数据，而是存放的指向数据表对应位置的指针，有额外的一张表来存放所有数据；这种数据和索引分离的形式，叫做  非聚簇索引；\n\n对于 MyISAM 存储引擎来说，其很适合进行查询，特别是大文本查找和全文索引（后文会提到）；\n1.6.2 实机演示\n在 MySQL 中，我们可以通过实际文件的数量看出 InnoDB 和 MyISAM 存储引擎的区别；其也反映了聚簇 &#x2F; 非聚簇索引的性质。\n\n这里我们新建一个数据库，创建 user1 表，默认采用的是 InnoDB 作为存储引擎\nMariaDB [hello_mysql]&gt; create table user1(id int unsigned primary key, name varchar(200) NOT NULL );Query OK, 0 rows affected (0.008 sec)\n\n在 MySQL 的文件存储路径中，可以查看到 user1 表对应了两个文件，其中 .ibd 后缀指的就是 InnoDB，其内部同时包含了该表中的数据和索引值；\n[root@vm-cnt8:/var/lib/mysql/hello_mysql]# lltotal 104-rw-rw----. 1 mysql mysql    61 Sep  7 02:59 db.opt-rw-rw----. 1 mysql mysql  1545 Sep  7 03:00 user1.frm-rw-rw----. 1 mysql mysql 98304 Sep  7 03:00 user1.ibd\n\n再来创建一个属性完全相同的 user2 表，但采用 MyISAM 存储引擎\nMariaDB [hello_mysql]&gt; create table user2(id int unsigned primary key, name varchar(200) NOT NULL ) engine=MyISAM;Query OK, 0 rows affected (0.002 sec)\n\n此时能看到，MyISAM 对应的存储文件有 3 个，.MYI包含的是索引，.MYD包含的是实际数据；\n[root@vm-cnt8:/var/lib/mysql/hello_mysql]# lltotal 112-rw-rw----. 1 mysql mysql    61 Sep  7 02:59 db.opt-rw-rw----. 1 mysql mysql  1545 Sep  7 03:00 user1.frm-rw-rw----. 1 mysql mysql 98304 Sep  7 03:00 user1.ibd-rw-rw----. 1 mysql mysql  1545 Sep  7 03:03 user2.frm-rw-rw----. 1 mysql mysql     0 Sep  7 03:03 user2.MYD-rw-rw----. 1 mysql mysql  1024 Sep  7 03:03 user2.MYI\n\n两表都有一个占用空间完全相同的 .frm 文件，这个文件中存储的就是该表的结构属性信息，因为两个表的结构完全相同，所以这个文件的大小也相同；\n1.7 回表查找  创建  辅助索引  的时候，MyISAM 依旧创建一个 B+ 树，叶子节点也是指向对应位置的指针；所以在 MyISAM 中，主键 &#x2F; 非主键索引区别不大，无非是是否允许冗余数据的问题。\n\nInnoDB 的辅助索引中，不再直接存放节点数据，而是存放  主键 key 值 ，查询的时候根据 key 值回到 主键索引表  中进行查询，需要  查询两次  才能获取到结果。\n\n如果辅助索引中还保存数据，就会造成极大的空间浪费，一份数据被保存两次甚至更多次，显然是不合理的。\n\nInnoDB 这个先查辅助索引表，再回到主键表中查询的动作，叫做  回表查询；\n话虽是这么说，但也并不是每次查询我们都需要回表的。比如下图是一个复合键的索引表，假设数字是用户 ID（主键），文字是用户姓名，在这种情况下，我们通过用户姓名查询用户 ID 的时候，就不需要回到主键表也能获取到结果。\n\n另外，在一般的数据库中，B+ 树并不会很深，所以即便需要进行回表的两次查询，效率也不会受到较大影响；（但肯定会有一定损失）\n2. 索引操作2.1 创建索引的原则\n比较频繁作为查询条件的字段应该创建索引\n唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件\n更新非常频繁的字段不适合作创建索引（因为每次更新都得重置索引，增加 IO 压力）\n不会出现在 where 子句中的字段不该创建索引（不作为查询条件的字段）\n\n另外，如果在创建表的时候么有指定主键，那么 MySQL 会自动帮我们创建一个隐藏的自增主键 ID（不然就没办法支持其他索引和其本身的快速查找了）\n2.2 创建主键索引  创建表的时候指定primary key，默认就会创建主键索引\ncreate table user1(id int unsigned primary key, name varchar(200) NOT NULL );\n\n创建表的最后，指定某列为主键索引，这个和第一种方式本质上没区别\ncreate table user1(id int unsigned , name varchar(200) NOT NULL, primary key(id) );\n\n创建表了之后再添加主键\n-- 创建表create table user1(id int unsigned , name varchar(200) NOT NULL);-- 添加主键alter table user1 add primary key(id);\n\n主键索引的特点：\n\n一个表里面本来就只能有一个主键，所以主键索引也只有一个（复合主键也只算一个主键）\n主键索引的效率高（主键列不可重复）\n主键列不能为 NULL，所以也不存在无法被索引的值\n一般都会用数字来作为主键，在索引中方便数据比较\n\n2.3 唯一键索引  当你给某一列设置为唯一键的时候，MySQL 就会自动创建唯一键索引；唯一键索引其实就是普通的辅助索引，只不过其和主键一样都包含唯一的键值约束；\n-- 直接指定唯一键create table user2(id int primary key, name varchar(200) unique);-- 创建语句末尾指定唯一键create table user2(id int primary key, name varchar(200),unique(name));-- 创建后再添加唯一键create table user2(id int primary key, name varchar(200));alter table user2 add unique(name);\n\n唯一索引的特点：\n\n一个表中，可以有多个唯一索引，包括复合唯一键的索引；\n查询效率高；\n如果在某一列建立唯一索引，必须保证这列不能有重复数据；\n如果一个唯一索引上指定not null，等价于主键索引；\n如果删除唯一键索引，也会同时删除唯一的约束属性；\n\n2.4 普通键索引  创建普通索引依旧有 3 种方式\n-- 在表的定义最后，指定某列为索引create table user3(id int primary key,    name varchar(20),    email varchar(30),    index(name));-- 创建完表以后指定某列为普通索引create table user3(id int primary key, name varchar(20), emailvarchar(30));alter table user3 add index(name);-- 创建索引的时候指定名字create table user3(id int primary key, name varchar(20), emailvarchar(30));create index idx_name on user3(name); -- 创建一个索引名为 idx_name 的索引\n\n普通索引的特点：\n\n一个表中可以有多个普通索引\n普通索引中的键值可以重复，但不要在大量重复的键值上建立索引（比如性别）\n\n2.5 复合 &#x2F; 联合索引  给多个键值创建索引，操作如下\ncreate index 索引名字 on 表名(字段1, 字段2);-- 如果需要索引按不同的规则排序，可以在字段后加 DESC 和 ASCcreate index 索引名字 on 表名(字段1 DESC, 字段2 ASC);\n\n此时我们创建的索引，在字段 1 和字段 2 上会共用一个索引的Key_name，索引名字是相同的。\n复合索引有一个好处，如果使用 InnoDB 时，需要查询的结果包含在索引字段中，那就可以节省一次返还到主键索引中查询的回表步骤，可以在一定程度上提高效率（在上文中已经提及此事）\n\n上面这种操作叫做  索引覆盖（覆盖索引），直接从普通索引表中查询到结果；\n建立复合索引相比于建立多个单列索引，还能在一定程度上减少空间消耗，提高效率；\n\n另外，在进行复合索引的查询的时候，我们只能使用用户名来查询用户 ID，返过来是不行的（不会使用索引）。因为在 MySQL 对索引进行匹配的时候，只会匹配最左侧的索引值；\n比如下图中，充当判断条件的是用户名字，通过用户名字查用户 ID 是 OK 的，反过来就不行；这种情况下 MySQL 不会使用索引，依旧是全表遍历；\n\n这种叫做 MySQL 索引的  最左匹配原则\n\n详解：联合索引 - 最左匹配原则\n\nMySQL 在创建复合索引的时候，首先会  对最左边字段排序，也就是第一个字段，然后再在保证第一个字段有序的情况下，再排序第二个字段，以此类推。所以联合索引最左列是绝对有序的，其他字段无序。\n举个例子：可以把联合索引看成“电话簿”，姓名作为联合索引，姓是第一列，名是第二列，当查找人名时，是先确定这个人姓再根据名确定人。只有名没有姓就查不到。\n2.6 全文索引  如果对文章或者大量文字的字段进行检索的时候，就会使用到全文索引。MySQL 提供全文索引机制，但是要求表的存储引擎必须是MyISAM；而且默认的全文索引只支持英文，不支持中文。如果对中文进行全文检索，可以使用 sphinx 的中文版(coreseek)。\n-- 创建表，FULLTEXT 设置全文索引CREATE TABLE articles (    id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,    title VARCHAR(200),    body TEXT,    FULLTEXT (title,body) )engine=MyISAM;-- 插入测试数据INSERT INTO articles (title,body) VALUES    (&#x27;MySQL Tutorial&#x27;,&#x27;DBMS stands for DataBase ...&#x27;),    (&#x27;How To Use MySQL Well&#x27;,&#x27;After you went through a ...&#x27;),    (&#x27;Optimizing MySQL&#x27;,&#x27;In this tutorial we will show ...&#x27;),    (&#x27;1001 MySQL Tricks&#x27;,&#x27;1. Never run mysqld as root. 2. ...&#x27;),    (&#x27;MySQL vs. YourSQL&#x27;,&#x27;In the following database comparison ...&#x27;),    (&#x27;MySQL Security&#x27;,&#x27;When configured properly, MySQL ...&#x27;);\n\n创建好表之后，查询表中索引信息，可以看到 title 和 body 字段都用上了索引名字为 title 的全文索引\n\n假设我们查询这个表中有没有包含 database 的文字数据，虽然成功查询了结果，但是并没有使用到全文索引\nselect * from articles where body like &#x27;%database%&#x27;;+----+-------------------+------------------------------------------+| id | title             | body                                     |+----+-------------------+------------------------------------------+|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             ||  5 | MySQL vs. YourSQL | In the following database comparison ... |+----+-------------------+------------------------------------------+2 rows in set (0.000 sec)\n\n使用 explain 语句可以看出是否有使用全文索引，这里的 key 为 NULL 就代表么有使用上索引；这个工具的作用是  预执行 ，并不会实际上运行这个语句，但是会告诉你我想 怎么运行它；\nexplain select * from articles where body like &#x27;%database%&#x27;\\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: articles         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 6        Extra: Using where1 row in set (0.000 sec)\n\n要想使用全文索引，得这么写\nSELECT * FROM articles WHERE MATCH (title,body) AGAINST (&#x27;database&#x27;);\n\n再用 explain 工具看看，此时就可以看到 key 里面显示的是 title，成功使用上了全文索引\nexplain SELECT * FROM articles WHERE MATCH (title,body) AGAINST    -&gt; (&#x27;database&#x27;)\\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: articles         type: fulltextpossible_keys: title          key: title      key_len: 0          ref:          rows: 1        Extra: Using where1 row in set (0.000 sec)\n\nexplain 工具  这里对 explain 工具显示的列作一个说明。这个工具的作用是  预执行 ，并不会实际上运行这个语句，但是会告诉你我想 怎么运行它；输出结果包含如下列：\n\nid — 选择标识符，id 越大优先级越高，越先被执行；\nselect_type — 表示查询的类型；\ntable — 输出结果集的表；\npartitions — 匹配的分区；\ntype — 表示表的连接类型；\npossible_keys — 表示查询时，可能使用的索引；\nkey — 表示实际使用的索引；\nkey_len — 索引字段的长度；\nref—  列与索引的比较；\nrows — 大概估算的行数；\nfiltered — 按表条件过滤的行百分比；\nExtra — 执行情况的描述和说明。\n\n2.7 查询 &#x2F; 删除索引  如果需要删除主键索引，直接把主键删了就行了\nalter table 表名 drop primary key;\n\n删除普通索引语句如下\nalter table 表名 drop index 索引名字;\n\n注意，索引的名字不一定和字段名相同（在创建索引的时候可以指定索引名字），需要使用如下语句查看\nshow keys from 表名;\n\n比如 user2 表中包含 id 主键索引和 name 的主键索引，其结果查询如下；其中的 Key_name 才是索引的名字，不一定和字段名相同！删除索引的时候需要使用索引名字！\n\n还可以用如下语句来更加清楚的看到每个索引的相关属性\nshow index from 表名 \\G;\n\n我给 user2 表添加一个键值，并设置普通索引\nalter table user2 add qq varchar(40); -- 添加一个键值alter table user2 add index(qq); -- 添加普通索引\n\n使用 show index from 表名 \\G; 语句查看 user2 表的索引属性；在这里可以看到，唯一键索引的属性和普通索引是完全相同的，所以才说唯一键的索引本质上还是普通索引。\n这里还写明了索引的类型是 BTREE，其就是 B+ 树；\nMariaDB [hello_mysql]&gt; desc user2;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(200)     | NO   | UNI | NULL    |       || qq    | varchar(40)      | YES  | MUL | NULL    |       |+-------+------------------+------+-----+---------+-------+3 rows in set (0.001 sec)MariaDB [hello_mysql]&gt; show index from user2\\G;*************************** 1. row ***************************        Table: user2   Non_unique: 0     Key_name: PRIMARY Seq_in_index: 1  Column_name: id    Collation: A  Cardinality: 0     Sub_part: NULL       Packed: NULL         Null:    Index_type: BTREE      Comment: Index_comment: *************************** 2. row ***************************        Table: user2   Non_unique: 0     Key_name: name Seq_in_index: 1  Column_name: name    Collation: A  Cardinality: 0     Sub_part: NULL       Packed: NULL         Null:    Index_type: BTREE      Comment: Index_comment: *************************** 3. row ***************************        Table: user2   Non_unique: 1     Key_name: qq Seq_in_index: 1  Column_name: qq    Collation: A  Cardinality: NULL     Sub_part: NULL       Packed: NULL         Null: YES   Index_type: BTREE      Comment: Index_comment: 3 rows in set (0.000 sec)ERROR: No query specified\n\n2.8 什么时候索引会失效？\nhttps://cloud.tencent.com/developer/article/2035778\nhttps://zhuanlan.zhihu.com/p/361172794\n\n2.8.1 如果条件中有 or&#x2F;and如果条件中有 or&#x2F;and，即使其中  有部分条件带索引  也不会使用；\n先说结论：如果在使用 and 和 or 进行查询的时候，只有两列都包含了索引才会使用；\n-- 创建示例表，其中 id 是主键，user_id 没有创建索引create table user3(\tid int unsigned primary key,\tuser_id int unsigned not null,    name varchar(30) not null);-- 插入示例数据insert into user3 values \t(1,10,&#x27; 甲 &#x27;),\t(2,20,&#x27; 丙 &#x27;),\t(3,30,&#x27; 乙 &#x27;),\t(4,40,&#x27; 丁 &#x27;),\t(5,50,&#x27; 尼斯 &#x27;),(6,23,&#x27; 企鹅 &#x27;),(7,14,&#x27; 倪浩 &#x27;),(9,21,&#x27;test&#x27;);\n\n这时候如果用如下语句进行查询，那就不会使用索引\nselect * from user3 where id=3 or user_id=40;\n\n使用 explain 命令来查看运行过程，可以看到 key 一列为空，代表没有使用索引\nMariaDB [hello_mysql]&gt; explain select * from user3 where id=3 or user_id=40\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: ALLpossible_keys: PRIMARY          key: NULL      key_len: NULL          ref: NULL         rows: 4        Extra: Using where1 row in set (0.000 sec)ERROR: No query specifiedMariaDB [hello_mysql]&gt; explain select * from user3 where id=2 and user_id=30\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: NULL         type: NULLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: NULL        Extra: Impossible WHERE noticed after reading const tables1 row in set (0.001 sec)ERROR: No query specified\n\n直接查询 id，有使用索引\nMariaDB [hello_mysql]&gt; explain select * from user3 where id=2\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 4          ref: const         rows: 1        Extra: 1 row in set (0.000 sec)ERROR: No query specified\n\n此时如果给 user_id 列加上索引后重新操作，那结果就不一样了\nalter table user3 add unique(user_id); -- 唯一键索引\n\n可以看到，有使用索引（在我的测试中，并不是每次都会使用索引，这大概是因为我的内容列太少了，不如直接遍历？）\nMariaDB [hello_mysql]&gt; explain select * from user3 where id=2 and user_id=20\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: constpossible_keys: PRIMARY,user_id          key: PRIMARY      key_len: 4          ref: const         rows: 1        Extra: 1 row in set (0.000 sec)ERROR: No query specified\n\n2.8.2 复合索引没有使用最左列  使用 sn + name + age 创建复合索引，我们假设它们的顺序是 A + B + C，以下联合索引的使用情况如下：\n\n从结果可以看出，只有 A+B+C 或者 A+B&#x2F;A+C 才能触发索引，而使用 B+C 无法触发索引，因为没有使用最左列；\n2.8.3  错误模糊查询  模糊查询的时候，只有  关键字 %才能用到索引，使用 % 关键字 或者 % 关键字 % 都是无法使用索引的；\n测试表结构如下，其中 ename 是用户名，我给他添加了一个普通索引\nMariaDB [bit_index]&gt; desc EMP;+----------+--------------------------+------+-----+---------+-------+| Field    | Type                     | Null | Key | Default | Extra |+----------+--------------------------+------+-----+---------+-------+| empno    | int(6) unsigned zerofill | NO   | PRI | NULL    |       || ename    | varchar(10)              | YES  |     | NULL    |       || job      | varchar(9)               | YES  |     | NULL    |       || mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       || hiredate | datetime                 | YES  |     | NULL    |       || sal      | decimal(7,2)             | YES  |     | NULL    |       || comm     | decimal(7,2)             | YES  |     | NULL    |       || deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |+----------+--------------------------+------+-----+---------+-------+8 rows in set (0.001 sec)MariaDB [bit_index]&gt; alter table EMP add index(ename);Query OK, 0 rows affected (11.911 sec)              Records: 0  Duplicates: 0  Warnings: 0\n\n然后进行测试。注意看下方 3 次查询的 like 条件区别，以及是否使用了索引；可以看到，只有第一次使用 FN% 作为查询条件的时候，才使用了索引\nMariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;FN%&#x27;\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: EMP         type: rangepossible_keys: ename          key: ename      key_len: 33          ref: NULL         rows: 22000        Extra: Using index condition1 row in set (0.000 sec)ERROR: No query specifiedMariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;%FN%&#x27;\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: EMP         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 7968250        Extra: Using where1 row in set (0.000 sec)ERROR: No query specifiedMariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;%FN&#x27;\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: EMP         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 7968250        Extra: Using where1 row in set (0.000 sec)ERROR: No query specified\n\n2.8.4 列运算  如果包含索引的列进行了运算，也不会使用索引；\n比如下方，直接进行 id=5 查询的时候，可以使用索引，但用 id+2=5 进行查询的时候无法使用索引；\nMariaDB [hello_mysql]&gt; explain select * from user3 where id=5\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 4          ref: const         rows: 1        Extra: 1 row in set (0.000 sec)ERROR: No query specifiedMariaDB [hello_mysql]&gt; explain select * from user3 where id+2=5\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 8        Extra: Using where1 row in set (0.000 sec)ERROR: No query specified\n\n2.8.5 使用函数  查询列如果使用任意 MySQL 提供的函数就会导致索引失效，这一点的情况和上一点进行运算其实是类似的，毕竟函数也是一种内置的运算；\nMariaDB [hello_mysql]&gt; explain select * from user3 where ifnull(id,0)=5\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 8        Extra: Using where1 row in set (0.001 sec)ERROR: No query specified\n\n2.8.6 类型转换  当查询的条件和其本身的数据类型不同时，不会触发索引；\n比如 address 为字符串类型，而查询的时候设置了 int 类型的值就会导致索引失效，如下图所示：\n\n2.8.7 使用 is not null当在查询中使用了 is not null 也会导致索引失效，而 is null 则会正常触发索引的，如下图所示：\n\n3. 索引优化 3.1 关联查询优化 保证被驱动表的 JOIN 字段已经创建了索引，需要 JOIN 的字段，数据类型保持绝对一致。\n\nLEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。\nINNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表 。\n\n选择相信 MySQL 优化策略。能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数）\n\n不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 JOIN 来代替子查询，参考第二点；\n\n另外，衍生表建不了索引。这点也需要注意\n3.2 子查询优化MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，即一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。 \n子查询可以一次性完成很多逻辑上需要多个步骤才能完成的 SQL 操作，子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。\n但是，子查询的执行效率不高。原因： \n\n执行子查询时，MySQL 需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。 \n子查询的结果集存储的  临时表 ，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会受到一定的影响。\n对于返回结果集比较大的子查询，其对查询性能的影响也就越大。 在 MySQL 中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表 ，其速度比子查询要快 ，如果查询中使用索引的话，性能就会更好。\n\n结论：尽量不要使用 NOT IN 或者 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL 替代；\n3.3 排序优化\nSQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 避免全表扫 描 ，在 ORDER BY 子句 避免使用 FileSort 排序 。当然，某些情况下全表扫描，或者 FileSort 排 序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。\n尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。\n无法使用 Index 时，需要对 FileSort 方式进行调优。\n\n3.4 GROUP BY 优化 group by 使用索引的原则几乎跟order by 一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。\n\ngroup by 先排序再分组，遵照索引建的  最佳左前缀法则；\n当无法使用索引列事，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置；\nwhere 效率高于 having，能写在 where 限定的条件就不要写在 having 中了！\n减少使用 order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的。\n包含了 order by、group by、distinct 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行 以内，否则 SQL 会很慢。\n\n3.5 索引覆盖  这一点在上文的回表查找中已经提及了，即使用复合索引，并将你需要查询的目标字段以最左匹配原则设置到复合索引中，减少回表操作。\n当然，这依旧需要遵循索引创建的原则，即如果某列数据重复量过多，则不应该作为索引列（如果真的需要，可以放在复合索引的最后面，这样能减少以之为查询判据的场景）\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】字节跳动 MySQL 连环 40 问","url":"/posts/3873856211/","content":"字节 MySQL 连环 40 问，网图\n\n\n\n虽然感觉这玩意和字节跳动没关系，但是管他的？直接开始回答！\n1.MySQL 中有哪几种锁？\n会的不全，所以查的 GPT\n\nMySQL 中有多种类型的锁，主要包括以下几种：\n\n共享锁（Shared Lock）：也称为  读锁，多个会话可以同时持有共享锁，并且不互斥。共享锁适用于读取操作，多个会话可以并发读取同一份数据而不会产生冲突。\n排他锁（Exclusive Lock）：也称为  写锁，排他锁与其他任何锁都互斥，只有一个会话可以持有排他锁。排他锁适用于写入或修改操作，确保在某个会话持有排他锁的时候，其他会话无法同时进行写入操作。\n记录锁（Record Lock）：记录锁（行锁）是针对某条记录的锁定，用于保护特定记录的完整性。在使用 InnoDB 存储引擎时，读取或修改某条记录时会自动给该记录加上记录锁，其他会话则无法对该记录进行并发写入或删除操作。\nGap 锁：Gap 锁是 InnoDB 引擎的一种锁机制，用于防止幻读。它锁定了一个范围，但不包含实际的记录，用于防止其他会话在这个范围内插入新记录，以避免幻读现象的发生。\n表锁（Table Lock）：表锁是对整个表格进行锁定，可以在某些特殊情况下使用，但会阻塞其他会话的读取和写入操作。在需要并发读写的情况下，表锁的性能较低，因此一般不推荐使用。\n\n除此之外，还有一个 NEXT-KEY 锁：\nNEXT-KEY 锁是 InnoDB 存储引擎中的一种锁机制，用于  解决幻读  问题。它是通过将 Gap 锁和 记录锁 组合而成的。\n具体来说，当一个事务在 InnoDB 表中执行范围查询时，如使用 &lt;、&lt;=、&gt;、&gt;= 等操作符，InnoDB 引擎会为查询涉及到的范围加上 NEXT-KEY 锁。这个 NEXT-KEY 锁包含两部分：\n\nGap 锁：锁定了查询范围内的间隙（Gap），防止其他事务向该范围内插入新的记录。\n记录锁：锁定了满足查询条件的记录，防止其他事务对这些记录进行并发修改或删除。\n\n通过使用 NEXT-KEY 锁，InnoDB 可以有效地避免幻读现象的发生。它保证了在一个事务读取一个范围的数据时，其他事务无法并发地在该范围内插入新的记录，从而保证了读取的一致性。\n需要注意的是，NEXT-KEY 锁只在事务隔离级别为  可重复读（REPEATABLE READ）或更高级别时使用（MySQL 默认隔离级别为可重复读）。在较高的并发环境下，使用 NEXT-KEY 锁可能会增加锁冲突的概率，因此在设计数据库和查询时需要考虑到锁的开销和事务的隔离级别。\n2.MySQL 中有哪些不同的表格？\n这个也是 GPT 回答的，注意，表格和存储引擎不是同一个概念！\n\n在 MySQL 中，有以下几种不同的表格类型：\n\nMyISAM：MyISAM 是旧版本 MySQL 的默认表格类型。它提供了快速的读取速度，适用于大量的并发读取操作。不过，MyISAM 不支持事务处理和崩溃恢复功能。\nInnoDB：InnoDB 是一种支持事务处理和崩溃恢复功能的表格类型。它提供了行级锁定和外键约束等高级功能，适用于需要数据完整性和并发写入操作的场景。InnoDB 是 MySQL 5.5 版本后 的默认表格类型。\nMemory：Memory（也称为 Heap）表格是将数据存储在内存中的临时表格类型。它在读取和写入方面非常快速，但它的数据是临时的，当数据库服务器重启时，表格中的数据将会丢失。\nArchive：Archive 表格是一种高度压缩的表格类型，适用于存储大量历史数据和归档数据。它对于读取操作不太有效，但在大量写入和存储空间方面具有优势。\nCSV：CSV 表格允许将数据以 CSV（逗号分隔值）格式存储在文件中，支持导入和导出数据。它不支持索引，事务处理和其他高级特性。\n\n除了以上列举的几种常见的表格类型外，MySQL 还支持其他一些特殊用途的表格类型，如 Partitioned（分区表格）和 Federated（联合表格）等。\n\n表格和存储引擎是同一个东西吗？并  不是！\n\n在关系型数据库中，表格（Table）是指一个逻辑上的数据结构，用来组织和存储数据。一张表格由若干列（Column）和若干行（Row）组成，每列定义了一种数据类型和一个字段名，表格中的每一行则代表一个实体或记录，每个单元格存储着对应列的一个数值或字符串。\n存储引擎（Storage Engine）则是指实现了数据库的表格和索引等功能的底层软件模块，它负责将表格数据存储到磁盘、跟踪并处理事务、执行查询语句等任务。不同的存储引擎具有各自的特点和优缺点，在不同场景下选择合适的存储引擎可以提高数据库的性能和可靠性。\n3.MyISAM 和 InnoDB 的区别？MyISAM\n\n不支持事务；\n采用非聚簇索引，普通索引和主键索引的形式相同；\n一张表包含三个本地文件；\n\nInnoDB\n\n支持事务；\n采用聚簇索引，普通索引存放的是主键索引中的 key 值，需要回表查询；可以用索引覆盖来优化；\n一张表包含两个本地文件；\n\n4.InnoDB 支持的四种事务隔离级别和区别  四种隔离级别：读未提交，读已提交，可重复读，串行化；\n这部分直接去看我的 MySQL 索引 博客，里面详细介绍了区别，这里就不重写一遍了；\n5.CHAR 和 VARCHAR 的区别\nchar 是定长字符串，最长 255；varchar 是变长字符串，最长 65535；\n这就意味着 varchar 需要更多空间来存放当前字符串长度等信息，并且会根据当前字符串长度动态开辟空间大小，不会有额外的存储空间浪费；\n而 char 是定死的空间，char(8)里面即便只有一个字符也会占用八个的空间（会用空格进行补齐）；\n在字符串长度确定的情况下，比如计算长度确定的 MD5，那就可以用 char 定长存储；长度不确定的情况下，比如人名、邮箱等信息，可以采用 varchar；\n\n顺带说一下 varchar 和 text 的区别；需要进行索引的长文可以用 TEXT 进行存储（注意，只有 MyISAM 支持全文索引）\n\n存储空间：VARCHAR 列存储的内容长度是可变的，而 TEXT 列可以存储大量的可变长度的文本数据。VARCHAR 在存储时会根据实际存储的内容长度进行调整，而 TEXT 没有固定的最大长度限制，可以用来存储非常长的文本。由于 TEXT 可以存储更大的数据量，因此它通常占用更多的存储空间。\n查询性能：由于 VARCHAR 具有固定的最大长度限制，数据库可以更好地优化和管理存储空间，这可能会在某些情况下提升查询性能。而 TEXT 由于其可变长度和大容量，可能会对某些查询操作稍有影响。\n索引和排序：VARCHAR 可以被索引和排序，这意味着可以根据这些列进行快速搜索和排序操作。而 TEXT 类型通常不直接支持索引和排序，需要额外的配置和处理才能实现类似的功能。\n\n如下 user1 表做测试，会发现我们无法给 TEXT 类型上普通索引。给出的提示是，BLOG/TEXT类型不能在没有指定长度的时候上索引；因为你的长度不确定，如果 MySQL 将一个几万字的 TEXT 存到内存里面作为索引节点，那么就会占用过多的内存空间。\nMariaDB [hello_mysql]&gt; desc user1;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(200)     | NO   |     | NULL    |       || info  | text             | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+3 rows in set (0.001 sec)MariaDB [hello_mysql]&gt; alter table user1 add index(info);ERROR 1170 (42000): BLOB/TEXT column &#x27;info&#x27; used in key specification without a key length\n\n即便在创建列的时候给定了 TEXT 的长度，依旧不能创建索引。\nMariaDB [hello_mysql]&gt; alter table user1 add info1 TEXT(20) NOT NULL;Query OK, 0 rows affected (0.002 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello_mysql]&gt; desc user1;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(200)     | NO   |     | NULL    |       || info  | text             | NO   |     | NULL    |       || info1 | tinytext         | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+4 rows in set (0.001 sec)MariaDB [hello_mysql]&gt; alter table user1 add index(info1);ERROR 1170 (42000): BLOB/TEXT column &#x27;info1&#x27; used in key specification without a key length\n\n正确的写法如下，需要在创建索引的时候，括号指定索引的长度；比如 index(info1(10)) 含义就是给 info1 列的前 10 个字符建立索引。只要 TEXT 里面存放的文本前 10 个字符重复率低，那么这个索引就是有意义的！\nMariaDB [hello_mysql]&gt; alter table user1 add index(info1(10));Query OK, 0 rows affected (0.007 sec)Records: 0  Duplicates: 0  Warnings: 0\n\n6. 主键和候选键 (码) 有啥区别？候选键是一些可以选用（备选）为主键或者唯一键的类型；\n比如一个学生表里面，包含学生主键的 INT 自增 ID，学生学号，学生身份证，学生姓名，学生性别等等信息；在这个表里面，除了主键这个 INT 的 ID，我们还可以把学生的学号和学生的身份证作为主键或者唯一键，因为他们都包含唯一性！\n这时候，这些可以作为主键的列，就叫做候选键；\n\n候选键也需要保持唯一性\n候选键需要遵循最小原则，不能是某一个聚合唯一标识的子集；（比如我需要用  部门 ID 和部门内员工 ID来唯一标识一个员工，此时部门 ID 就不能作为这个员工表的候选键，因为在整个表中部门 ID 会重复）\n\n在《数据库系统概率》这门课里面，会把键称作为码，本质上是一个东西。\n\n到底是谁把 key 翻译成码的？真无语😒\n\n7.myisamchk 是用来干什么的  一个命令行工具（在 bash 下使用，不是在 MySQL 命令行使用）\n\nMyisamchk 是 MyISAM 表维护的一个非常实用的工具。可以使用 myisamchk 实用程序来获得有关数据库表的信息或检查、修复、优化他们。myisamchk 适用 MyISAM 表(对应.MYI 和.MYD 文件的表)。\n\n这个命令了解即可，下面是两篇使用博客。有需要再去深入学习用法\nhttp://www.4u4v.net/myisamchk-gadgets-manual.html\nhttps://www.cnblogs.com/analyzer/articles/1381538.html\n8. 如果表中有一列定义为 TIMESTAMP 会发生什么TIMESTAMP 底层一般是 4 个字节，在 MySQL 里面进行查询的时候，会根据系统时区，转成可读时间进行输出。包括使用 cpp devel 包获取到的也是可读时间；\n因为只有 4 个字节，所以 TIMESTAMP 最多能表示 1970-01-01 00:00:01到2038-01-19 03:14:07，这也是一个 2038 年问题，需要改成 8 字节存储才能存放更长的时间。\n另外，如果你想更加精确的标识时间，而不依赖于 MySQL 对时间戳的自动转换，那么就可以用 BIGINT 或者 DECIMAL 类型来存放时间戳数字，再在应用层进行时间戳和可读时间之间的转换。\n9. 怎么看到表格定义的所有索引  两种方式都可以\nshow index from 表名;show keys from 表名;\n\n10.LIKE 声明中的 % 是什么意思  代表通配符，匹配所有字符串。下面举几个例子\n查询 &#x27; 张 %&#x27;    张丽丽     张扣扣    张三    张阿斯顿 查询 &#x27;% 张 %&#x27;\t里张里     十大张撒打发 查询 &#x27;% 张 &#x27;\txx 张\txxxxx 张\n\n需要注意，只有  关键字 %的使用方式才能用上索引，另外两种匹配方式无法使用索引！\n11. 列对比运算符是什么  等于 =不等于 &lt;&gt; !=大于和大于等于  &gt; &gt;=小于和小于等于  &lt; &lt;=区间 BETWEEN .. AND ...是否在列表中 IN模糊匹配 LIKENULL 比较 IS NULL, IS NOT NULL\n\n12.BLOB 和 TEXT 有什么区别？GPT 说的：\n\n存储容量：BLOB 可以存储二进制数据，而 TEXT 只能存储纯文本数据。\n字符集排序规则：BLOB 没有字符集排序规则，而 TEXT 有，默认为字符集的排序规则。\n数据排序和比较：BLOB 会按二进制方式进行排序和比较，而 TEXT 会按字符排序规则进行排序和比较。\n存储方式：BLOB 数据以二进制形式存储，没有字符集转换；而 TEXT 数据会根据字符集进行转换和存储。\n索引：在 MySQL 中，BLOB 和 TEXT 列可以有索引，但有一些限制。BLOB 列或前缀索引的最大长度是 768 字节，对于 UTF-8 字符集是 255 个字符。而 TEXT 列或前缀索引的最大长度是 3072 字节，在 UTF-8 字符集中是 1024 个字符。\n默认值：BLOB 和 TEXT 列不能具有默认值。\n\n总的来说，BLOB 适合存储二进制数据，例如图像、音频或视频文件等。而 TEXT 适合存储纯文本数据，如长文本、文章内容等。根据具体的需求，你可以选择适当的数据类型来存储相应的数据。\n\n实际上，把图片、音频这些静态资源存入数据库是不合理的……\n\n13.MySQL_fetch_array 和 MySQL_fetch_obj 有什么区别？PHP 里面的函数，不学，直接跳过\n14.MyISAM 表格将在那里存储？并且还提供其存储格式？在 linux 下，MyISAM 表格以文件形式存储在数据目录下的对应数据库目录中。每个表格对应一个.MYD 数据文件（用于存储表格数据）和一个.MYI 索引文件（用于存储表格索引），以及一个.frm 表格定义文件（包含表格定义信息，如字段名、数据类型等）\nMyISAM 使用一种称为“静态行格式”的存储格式来存储表格数据。这种格式用于在磁盘上保存由定长行组成的表格，每个行定长，占用相同的存储空间，以便更快地读取和写入数据。MyISAM 表格还支持动态行格式，这种格式允许可变行长度，因此可以更有效地存储可变长度的数据类型（如 VARCHAR，TEXT 等）。\n15.MySQL 如何优化 DISTINCT?使用索引，减少查询行数来优化去重操作\n16. 如何显示前 50 行？查询语句后带上 limit 就可以\nselect * from 表名 limit 50;\n\n17. 可以使用多少列创建索引？根据实际使用场景来确定用几列，并没有固定限制。理论上来说需要保持最小原则，不要包含多余的无效列（除非你需要用来进行索引优化，减少回表操作）\n18.now 和 current_date 有什么区别？now 会返回一直到时分秒的信息，current_date 只会返回当日日期\n19. 什么是非标准字符串类型\nGPT\n\n非标准字符串类型是指在数据库中没有明确定义或标准化的字符串数据类型。这些类型通常是特定数据库管理系统（DBMS）或应用程序开发框架所支持的扩展。由于不同的 DBMS 和框架有各自的特性和需求，可能会引入额外的非标准字符串类型以满足特定的数据存储和操作需求。\n举例来说，MySQL 数据库在其标准字符串类型中包含了 CHAR、VARCHAR、TEXT 等。而非标准字符串类型可能是根据具体需求和扩展开发的，如 JSON、XML、BLOB、CLOB 等。这些非标准类型在一些特定场景中使用广泛，例如存储非结构化的文本数据、大型二进制数据、以及存储和查询复杂的结构化数据等。\n需要注意的是，非标准字符串类型在不同的 DBMS 和开发框架之间可能存在差异，并且在跨平台和迁移时可能会出现兼容性问题。因此，在使用非标准字符串类型时，建议仔细了解相关的文档和规范，并评估其对应用程序的影响和可移植性。\n20. 什么是通用 SQL 函数  以下列举了一些常见的通用 SQL 函数：\n\n聚合函数：如 SUM、AVG、COUNT、MIN、MAX 等，用于对数据进行统计和聚合计算。\n字符串函数：如 CONCAT、SUBSTRING、UPPER、LOWER、LENGTH 等，用于处理和操作字符串数据。\n数值函数：如 ABS、ROUND、CEILING、FLOOR 等，用于执行数值计算和转换。\n日期和时间函数：如 DATE, TIME, YEAR, MONTH, DAY 等，用于处理日期和时间数据的计算和格式化。\n条件函数：如 IF, CASE WHEN, COALESCE 等，用于根据条件执行不同的逻辑和返回不同的结果。\n类型转换函数：如 CAST、CONVERT 等，用于在不同的数据类型之间进行转换。\n\n这只是一小部分通用 SQL 函数的例子，实际上还有很多其他的函数可用于不同的数据处理和查询需求。需要注意的是，尽管这些函数在大多数 DBMS 中都存在，但某些特定的 DBMS 可能会提供额外的函数或有稍微不同的语法，因此在使用函数时应查阅相应的文档和规范以确保兼容性和正确性。\n21.MySQL 支持事务吗？肯定支持，这个问题第四点就已经详细问了\n22.MySQL 里面记录货币用什么类型好？因为浮点数的精度问题，可以用 BIGINT 来存放以  分为单位的货币，实际调用的时候再加上小数点，来保证数据准确。\n如果不用 BIGINT，那就需要用 DECIMAL 来存放货币。\n\nB 站冲浪看到的\n\n23.MySQL 有关权限的表有那几个  在 MySQL 中，有几个与权限相关的系统表和视图，用于管理用户、角色和权限。以下是一些常见的权限相关的表和视图：\n\nmysql.user：这个表包含了 MySQL 实例上的所有用户账户信息，包括用户名、密码等。该表记录了每个用户的全局权限。\nmysql.db：这个表记录了用户对数据库级别的权限。它指定了哪个用户对哪个数据库具有什么样的权限。\nmysql.tables_priv：这个表记录了用户对表级别的权限。它存储了用户对某个具体表的权限信息（如 SELECT、INSERT、UPDATE、DELETE 等）。\nmysql.columns_priv：这个表记录了用户对列级别的权限。它存储了用户对表中某个具体列的权限信息。\nmysql.procs_priv：这个表记录了用户对存储过程和函数的权限。\nmysql.roles：这个表存储了角色的相关信息，包括角色名、角色的创建者等。\n\n除了上述的表之外，MySQL 还提供了一些权限相关的视图，这些视图可以方便地查看用户、角色和权限的信息，如：\n\ninformation_schema.USER_PRIVILEGES：显示所有用户的权限信息。\ninformation_schema.SCHEMA_PRIVILEGES：显示所有数据库的权限信息。\ninformation_schema.TABLE_PRIVILEGES：显示所有表的权限信息。\ninformation_schema.COLUMN_PRIVILEGES：显示所有列的权限信息。\n\n如下是个使用示例\nselect * from information_schema.USER_PRIVILEGES;\n\n这些表和视图可以通过查询相应的系统表或视图来查看和管理用户、角色和权限。请注意，具体的系统表和视图名称可能因 MySQL 版本和配置而有所不同。为了确保准确性，请参考 MySQL 官方文档或特定版本的文档。\n24. 列的字符串类型可以是什么TEXT CHAR VARCHAR，详见第五点\n25.MySQL 作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？\n没见过这种业务，只能问 GPT\n\n对于一个 MySQL 作为发布系统存储的场景，处理每天超过五万条增量数据并且需要保持三年的数据，以下是一些优化建议：\n\n数据库硬件和配置优化：\n硬件性能：确保数据库服务器具备足够的计算、内存和存储资源，以处理高负载的写入和读取操作。\n存储设备：使用高性能的存储设备（如 SSD）来提高写入和读取速度。\nMySQL 参数调优：根据实际情况调整 MySQL 的配置参数，例如设置合理的缓冲区大小、并发连接数、查询缓存等。\n\n\n数据库架构优化：\n分库分表：考虑将数据进行分库分表来分担单个数据库的负载压力。根据数据的特点和访问模式，合理划分数据到不同的库表中。\n索引优化：根据查询需求创建合适的索引，以加快查询速度。避免过多的索引和冗余索引，以减少维护成本。\n分区表：如果数据的时间范围有明显的界限，可以考虑使用 MySQL 的分区表功能，将数据按时间范围进行分区，提高查询性能和维护效率。\n\n\n数据写入优化：\n批量插入：使用批量插入方式（如 INSERT INTO … VALUES (), (), ()…）来减少单条插入的开销，提高写入性能。\n事务处理：将多个写入操作放在一个事务中，确保数据的一致性和完整性，减少 IO 开销。\n\n\n数据归档和压缩：\n数据归档：对于历史数据，可以将其归档到独立的存储介质中，例如将旧数据迁移到归档数据库或者离线存储系统中以减轻主数据库的负载。\n数据压缩：对于不频繁查询的历史数据，可以考虑使用压缩算法（例如 MySQL 的压缩表功能或者第三方压缩库）进行存储，以减少存储空间占用。\n\n\n监控和优化工具：\n使用监控工具实时监测数据库的性能指标，如查询速度、磁盘使用、锁等情况，及时发现潜在的性能瓶颈并进行调优。\n使用性能优化工具，如 Explain 分析、慢查询日志等，来找出慢查询和低效的 SQL 语句，并进行优化。\n\n\n\n以上是一些常见的优化建议，具体优化方案还需要根据实际场景和需求进行调整。同时，建议在进行优化前，充分了解应用的读写特征、数据访问模式和业务需求，以便有针对性地进行优化工作。\n26. 锁的优化策略？27. 索引的底层实现和优化？底层用 B+ 实现，优化索引方式见索引博客 https://blog.musnow.top/posts/3474107655/\n28. 什么情况下有索引但是无法使用  索引失效，见索引博客 https://blog.musnow.top/posts/3474107655/\n29. 实践中如何优化 MySQL太宽泛了，不好回答\n\n索引优化\n分表\n事务隔离性选择\n\n30. 优化数据库的办法？和 29 题重合，不做回答\n31. 简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）见索引博客 https://blog.musnow.top/posts/3474107655/\n32. 数据库的事务是什么  见事务博客 https://blog.musnow.top/posts/2200233148/\n33.SQL 注入漏洞的产生和原因，如何防止SQL 注入漏洞是一种常见的安全漏洞，它可以使攻击者通过构造恶意的 SQL 语句来绕过应用程序的输入验证，进而执行非法的数据库操作或获取敏感信息。以下是 SQL 注入漏洞产生的原因和一些防止方法：\n\n原因：\n不正确的输入验证：当应用程序没有对用户的输入进行充分验证和过滤时，攻击者可以通过输入特定的字符或语句来修改 SQL 语句的结构，从而执行恶意操作。\n拼接字符串构造 SQL 语句：如果应用程序使用拼接字符串的方式构造 SQL 查询语句，并且未对用户输入进行正确的转义处理，就容易受到 SQL 注入攻击。\n\n\n防止方法：\n使用参数化查询或预编译语句：参数化查询将用户输入作为参数传递给 SQL 语句，而不是直接拼接字符串。这样可以通过数据库驱动程序自动处理转义和编码，有效防止 SQL 注入攻击。\n输入验证和过滤：对用户的输入数据进行验证和过滤，只接受符合规范的数据。可以使用白名单、黑名单、正则表达式等方法进行输入验证和过滤。\n最小权限原则：在数据库中为应用程序使用的账号设置最小权限，即只授予应用程序完成必要操作所需的最低权限，避免攻击者利用注入漏洞进行更危险的操作。\n不要直接暴露数据库错误信息：在生产环境中，不要将详细的数据库错误信息返回给用户，以防止攻击者从中获取关键信息。可以记录错误日志并给用户一个友好的错误提示。\n定期更新和修补数据库和应用程序：及时安装数据库和应用程序的安全补丁，以修复已知的漏洞，并确保使用最新的安全措施。\n\n\n\n总之，为了防止 SQL 注入漏洞，关键是要对用户输入数据进行合理验证、过滤和转义处理，并使用参数化查询或预编译语句来构造 SQL 语句。同时，保持应用程序和数据库的安全性，并及时更新和修补已知的安全漏洞。\n34. 如何为表中字段选择合适数据类型  肯定是根据具体情况回答\n35. 存储时期？感觉这道题有问题，不管他\n36. 索引相关问题？和 31 重合，不回答\n37. 解释 MySQL 中外连接、内连接、自连接的区别\n内连接（INNER JOIN）：\n内连接返回两个表中满足连接条件的记录，即只返回两个表中能够匹配的行。\n内连接使用一个连接谓词（JOIN）或者在 FROM 子句中使用逗号（,）来表示。\n内连接可以根据指定的连接条件将两个表中的列进行匹配。如果未提供连接条件，则会返回两个表的笛卡尔积。\n语法示例：SELECT * FROM 表 1 INNER JOIN 表 2 ON 表 1. 列 &#x3D; 表 2. 列;\n\n\n外连接（OUTER JOIN）：\n外连接将返回两个表中满足连接条件的记录，并且还包括不满足连接条件的记录。\n外连接分为左外连接（LEFT JOIN）和右外连接（RIGHT JOIN）。\n左外连接返回左表中的所有记录，以及右表中与左表满足连接条件的记录。如果右表中没有匹配的记录，则会返回 NULL 值。\n右外连接返回右表中的所有记录，以及左表中与右表满足连接条件的记录。如果左表中没有匹配的记录，则会返回 NULL 值。\n语法示例：\n左外连接：SELECT * FROM 表 1 LEFT JOIN 表 2 ON 表 1. 列 &#x3D; 表 2. 列;\n右外连接：SELECT * FROM 表 1 RIGHT JOIN 表 2 ON 表 1. 列 &#x3D; 表 2. 列;\n\n\n\n\n自连接（SELF JOIN）：\n自连接是指将表视为两个独立的实例，使用别名来区分它们，然后根据某些条件将它们连接在一起。\n自连接通常用于在同一个表中根据某种关系进行数据查询。\n语法示例：SELECT 别名 1. 列, 别名 2. 列 FROM 表 别名 1, 表 别名 2 WHERE 别名 1. 列 &#x3D; 别名 2. 列;\n\n\n\n总结：\n\n内连接返回两个表中匹配的记录，外连接返回满足连接条件的记录以及不满足连接条件的记录，而自连接是对同一个表进行连接操作。\n内连接和外连接需要使用 JOIN 关键字，而自连接使用同一个表的别名进行连接。\n内连接和外连接可以根据连接条件将两个表进行关联，而自连接可以根据表中的某些条件进行关联。\n\n38.MySQL 中事务回滚机制描述  见事务博客 https://blog.musnow.top/posts/2200233148/\n39.SQL 语言包含哪几部分？每部分都有哪些操作关键字  包括 DQL 数据查询语言，DML 数据操作语言（增删改），数据控制语言 DCL 用来管理数据库，事务控制语言 TCL 用来控制事务，数据定义语言 DDL 用来创建删除表\n\n数据查询语言（Data Query Language，DQL）：用于从数据库中查询和检索数据。常用的操作关键字包括：\nSELECT：用于从一个或多个表中选择数据列以进行查询。\nFROM：指定要查询的表。\nWHERE：用于指定查询的条件。\nGROUP BY：按照指定的列对结果进行分组。\nHAVING：用于指定对分组后的结果进行筛选的条件。\nORDER BY：指定结果集的排序方式。\n\n\n数据操作语言（Data Manipulation Language，DML）：用于对数据库中的数据进行增加、修改和删除操作。常用的操作关键字包括：\nINSERT INTO：向表中插入新的行或数据。\nUPDATE：更新表中已有的数据。\nDELETE FROM：从表中删除指定的行或数据。\n\n\n数据定义语言（Data Definition Language，DDL）：用于创建、修改和删除数据库和表结构。常用的操作关键字包括：\nCREATE DATABASE：创建新的数据库。\nCREATE TABLE：创建新的数据表。\nALTER TABLE：修改已存在的数据表结构。\nDROP DATABASE：删除现有的数据库。\nDROP TABLE：删除现有的数据表。\n\n\n数据控制语言（Data Control Language，DCL）：用于管理数据库中的用户权限和访问权限。常用的操作关键字包括：\nGRANT：授予用户特定的权限。\nREVOKE：撤销用户的权限。\n\n\n事务控制语言（Transaction Control Language，TCL）：用于管理数据库的事务处理。常用的操作关键字包括：\nCOMMIT：提交一个事务，使其永久生效。\nROLLBACK：回滚一个事务，撤销之前的操作，使其不生效。\nSAVEPOINT：在事务中设置保存点，以便在需要时进行回滚。\n\n\n\n40. 完整性的约束包括那些？原子性、隔离性、持久性；这里说的完整性应该就是一致性；\n具体的解释依旧是去看事务的博客 https://blog.musnow.top/posts/2200233148/\n","categories":["学习sql"],"tags":["mysql"]},{"title":"【MySQL】C/C++ 代码操作数据库","url":"/posts/2109090511/","content":"简单尝试使用 c 语言的库对 mysql 的数据进行增删改查。\n\n\n1. 新增数据库和表  刚开始数据库没有设定密码和用户，直接用 root 用户登录\nmysql -uroot;\n\n创建一个 hello 数据库，并进入这个数据库\ncreate database hello;use hello;\n\n创建一个 stu_student 数据表\ncreate table stu_test( id int primary key auto_increment, name varchar(30), age int, score decimal(4,2));\n\n其中第一个 id 的类型是 int，并设置为了auto_increment，每次插入数据的时候它都会自增。\nname 是字符串类型，age 是 int 类型，score 分数是浮点类型\ndecimal(4,2)         表示的范围是 -99.99 ~ 99.99decimal(4,2)unsigned 表示的范围是 0 ~ 99.99\n\n到这里，前期的准备就完成了\n2. 接口简单认识  依照注释，简单认识一下 mysql 库的一些接口\n// 头文件#include &lt;mysql/mysql.h&gt;//MySQL 操作句柄初始化MYSQL *mysql_init(MYSQL *mysql)；// 参数为空则动态申请句柄空间进行初始化// 失败返回 NULL// 连接 mysql 服务器MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user,  const char *passwd,const char *db, unsigned int port,  const char *unix_socket, unsigned long client_flag); //mysql-- 初始化完成的句柄//host--- 连接的 mysql 服务器的地址//user--- 连接的服务器的用户名//passwd- 连接的服务器的密码//db ---- 默认选择的数据库名称//port--- 连接的服务器的端口： 默认 0 是 3306 端口//unix_socket--- 通信管道文件或者 socket 文件，通常置 NULL //client_flag--- 客户端标志位，通常置 0 // 返回值：成功返回句柄，失败返回 NULL// 设置当前客户端的字符集int mysql_set_character_set(MYSQL *mysql, const char *csname) //mysql-- 初始化完成的句柄//csname-- 字符集名称，通常：&quot;utf8&quot; // 返回值：成功返回 0， 失败返回非 0    // 选择操作的数据库int mysql_select_db(MYSQL *mysql, const char *db) //mysql-- 初始化完成的句柄//db----- 要切换选择的数据库名称// 返回值：成功返回 0， 失败返回非 0    // 执行 sql 语句int mysql_query(MYSQL *mysql, const char *stmt_str) //mysql-- 初始化完成的句柄//stmt_str-- 要执行的 sql 语句// 返回值：成功返回 0， 失败返回非 0    // 保存查询结果到本地MYSQL_RES *mysql_store_result(MYSQL *mysql) //mysql-- 初始化完成的句柄// 返回值：成功返回结果集的指针， 失败返回 NULL    // 获取结果集中的行数与列数uint64_t mysql_num_rows(MYSQL_RES *result)；//result-- 保存到本地的结果集地址// 返回值：结果集中数据的条数；unsigned int mysql_num_fields(MYSQL_RES *result) //result-- 保存到本地的结果集地址// 返回值：结果集中每一条数据的列数；    // 遍历结果集MYSQL_ROW mysql_fetch_row(MYSQL_RES *result) //result-- 保存到本地的结果集地址// 返回值：实际上是一个 char ** 的指针，将每一条数据做成了字符串指针数组 row[0]- 第 0 列 row[1]- 第 1 列// 并且这个接口会保存当前读取结果位置，每次获取的都是下一条数据// 释放结果集void mysql_free_result(MYSQL_RES *result) //result-- 保存到本地的结果集地址// 返回值：void  // 关闭数据库客户端连接，销毁句柄：void mysql_close(MYSQL *mysql)  // 获取 mysql 接口执行错误原因const char *mysql_error(MYSQL *mysql)\n\n因为 mysql 是一个动态库，所以编译的时候，需要加上库名的链接\ng++ test.cpp -o test -lmysqlclient\n\n在我的系统下，MySQL 的库是在 /usr/lib64 目录下的，所以我不需要额外指定库的路径。如果你的系统该目录下没有 libmysqlclient.so ，则需要找到库安装的路径，使用-L 命令指定该路径\ng++ test.cpp -o test -L/path/to/mysql/lib -lmysqlclient\n\n3. 代码  开始写代码，一步一步认识 mysql 的各个接口\n3.1 连接数据库  因为我的数据库都是默认的环境，所以不需要账户的密码，按如下宏定义一下我们需要操作的数据库信息，方便后续的修改\n#include &lt;mysql/mysql.h&gt;#define HOST &quot;127.0.0.1&quot;#define PORT 3306#define USER &quot;root&quot;#define PASSWD &quot;&quot;#define DBNAME &quot;hello&quot;\n\n第一步，是用 init 来初始化一个 MYSQL 的结构体，并用一个指针来接收；\n第二步，用 mysql_real_connect 函数来进行数据库的连接，填入我们刚刚的宏定义即可。\n第三步，因为在最初配置 mariadb 的环境时，为了更好的支持中文，我们将数据库的字符集设置为了 utf8，代码中也需要同步修改，避免因为编码问题产生的数据乱码\n最后一步，销毁 mysql 结构体\nint main()&#123;    // 连接数据库    // 初始化    MYSQL *mysql = mysql_init(nullptr);    if (mysql == nullptr) // 返回值为空代表 init 失败    &#123;         cerr &lt;&lt; &quot;[ERR] init mysql handle failed!\\n&quot;;         return -1;     &#125;    // 连接    cout &lt;&lt; &quot;[INFO] connect to &quot; &lt;&lt; HOST &lt;&lt; &quot;:&quot; &lt;&lt; PORT &lt;&lt; &quot; &quot; &lt;&lt; USER &lt;&lt; &quot; &quot; &lt;&lt; DBNAME &lt;&lt; endl;    // 第一个参数为输出型参数。返回值为 MYSQL 的起始地址，如果错误返回 NULL    if (mysql_real_connect(mysql, HOST, USER, PASSWD, DBNAME, PORT, nullptr, 0) == nullptr)     &#123;        cerr &lt;&lt; &quot;[ERR] mysql connect error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;         return -1;    &#125;    // 配置为和数据库同步的 utf8 字符集    mysql_set_character_set(mysql, &quot;utf8&quot;);    // 到这里就已经成功了    cout &lt;&lt; &quot;[INFO] mysql database connect success!&quot; &lt;&lt; endl;         // 关闭连接    mysql_close(mysql);     return 0;&#125;\n\n编译执行，成功链接上了数据库\n$ makeg++ test.cpp -o test -lmysqlclient$ ./test[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success!\n\n3.2 增加键值  下面要做的，就是给已有表新增一个键值\n需要注意的是，mysql 的代码操作，实际上也是需要使用 sql 语句的（这点我觉得好麻烦）\n插入语句如下，括号中的键值应该和数据库中表的键值一一对应\ninsert into stu_test value (null,&#x27; 牛爷爷 &#x27;,50,64.6);\n\n所以我们要做的，就是写一个函数，将传入的参数合并成一个 sql 语句，传入 mysql 进行处理\n// 将 double 转为 stringstd::string double2string(const double&amp; d)&#123;    std::stringstream s_tmp;    s_tmp &lt;&lt; d;      std::string s = s_tmp.str();    return s;&#125;int add_key_to_stu(MYSQL *mysql,const std::string&amp; name,int age,double score)&#123;    // 1. 将传入的参数处理为一个完整的 sql 语句    // 因为第一个编号参数，配置的是自增，所以需要传入 null    std::string sql_cmd = &quot;insert into stu_test value (null,&#x27;&quot;;    sql_cmd+= name;    sql_cmd+= &quot;&#x27;,&quot;;    sql_cmd+= std::to_string(age);    sql_cmd+= &quot;,&quot;;    sql_cmd+= double2string(score);    sql_cmd+= &quot;);&quot;;    cout &lt;&lt; &quot;[INFO] &quot; &lt;&lt; sql_cmd &lt;&lt; endl;        // 2. 执行语句    int ret = mysql_query(mysql,sql_cmd.c_str());    if(ret!=0)    &#123;        cerr &lt;&lt; &quot;[ERR] mysql insert error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;     &#125;    return ret;&#125;\n\n如下代码测试\n// 添加一个数据add_key_to_stu(mysql,&quot; 牛爷爷 &quot;,50,64.6);add_key_to_stu(mysql,&quot; 小图图 &quot;,5,72.8);\n\n可以看到，成功运行！\n$ ./test[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success![INFO] insert into stu_test value (null,&#x27; 牛爷爷 &#x27;,50,64.6);[INFO] insert into stu_test value (null,&#x27; 小图图 &#x27;,5,72.8);\n\n进入 mysql 命令行，使用如下命令，即可查询到已有的键值\nselect * from stu_test;\n\n可以看到，处理成功！\n+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  1 | 牛爷爷    |   50 | 64.60 ||  2 | 小图图    |    5 | 72.80 |+----+-----------+------+-------+2 rows in set (0.001 sec)\n\n3.3 修改已有键值 sql 语句如下，修改当前数据库中，stu_test 表中 name 为  牛爷爷  的条目的成绩为 70\nupdate stu_test set score=70 where name=&#x27; 牛爷爷 &#x27;;\n\n// 修改已有学生的成绩int mod_score_in_stu(MYSQL *mysql,const std::string&amp; name,double score)&#123;    std::string sql_cmd = &quot;update &quot;;    sql_cmd += TABLENAME;    sql_cmd += &quot; set score=&quot;;    sql_cmd += double2string(score);    sql_cmd += &quot; where name=&#x27;&quot;;    sql_cmd += name;    sql_cmd += &quot;&#x27;;&quot;;    cout &lt;&lt; &quot;[INFO] &quot; &lt;&lt; sql_cmd &lt;&lt; endl;        // 2. 执行语句    int ret = mysql_query(mysql,sql_cmd.c_str());    if(ret!=0)    &#123;        cerr &lt;&lt; &quot;[ERR] mysql mod_score error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;     &#125;    return ret;&#125;\n\n可以看到，执行成功了之后，牛爷爷的成绩发生了变化\n$ ./test[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success![INFO] update stu_test set score=70 where name=&#x27; 牛爷爷 &#x27;;\n\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  1 | 牛爷爷    |   50 | 64.60 ||  2 | 小图图    |    5 | 72.80 |+----+-----------+------+-------+2 rows in set (0.001 sec)MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  1 | 牛爷爷    |   50 | 70.00 ||  2 | 小图图    |    5 | 72.80 |+----+-----------+------+-------+2 rows in set (0.000 sec)\n\n如果想修改其他键值，也是依照此步骤进行。\n在实际场景中，一个数据条目肯定会有一个键值是不变的。比如在我的学生表中，假定每一个学生的名字都不变，我们就可以根据 name 字段来查找键值，对之进行其他值的修改。\n如果真要严肃起来，用名字来查找肯定是不行的，我们应该给每一个学生都生成一个学号或 UID，用这个 id 来进行检索。修改数据之前，都需要知道目标数据的 uid 值，才能修改。\n3.4 删除键值  如下语句，在 test_tb 表中，删除名字为张三的键值\ndelete from test_tb where name=&#x27; 张三 &#x27;;\n\n在删除之前，我又给数据库新增了一个键值\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  1 | 牛爷爷    |   50 | 70.00 ||  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 |+----+-----------+------+-------+3 rows in set (0.001 sec)\n\n下面我要用代码，删除掉牛爷爷\n// 删除键值(根据名字)int del_key_in_stu(MYSQL *mysql,const std::string&amp; name)&#123;    std::string sql_cmd = &quot;delete from &quot;;    sql_cmd += TABLENAME;    sql_cmd += &quot; where name=&#x27;&quot;;    sql_cmd += name;    sql_cmd += &quot;&#x27;;&quot;;    cout &lt;&lt; &quot;[INFO] &quot; &lt;&lt; sql_cmd &lt;&lt; endl;        // 执行语句    int ret = mysql_query(mysql,sql_cmd.c_str());    if(ret!=0)    &#123;        cerr &lt;&lt; &quot;[ERR] mysql mod_score error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;     &#125;    return ret;&#125;\n\n// 删除已有键值del_key_in_stu(mysql,&quot; 牛爷爷 &quot;);\n\n编译执行\n$ ./test[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success![INFO] delete from stu_test where name=&#x27; 牛爷爷 &#x27;;\n\n牛爷爷被删掉了\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 |+----+-----------+------+-------+2 rows in set (0.000 sec)\n\n3.4.1 关于自增的 id此时再插入一个新的键值，可以看到 id 并么有把空余的 1 给补上，而是从 4 开始继续往后增加\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 ||  4 | 乐迪      |   32 | 99.00 |+----+-----------+------+-------+3 rows in set (0.001 sec)\n\n知道这一点就行\n3.5 查询  对于数据库而言，查询也是一个高频操作\nselect * from  tb  where name=key;\n\n上面的语句，是在数据库表 tb 中查找键值 name 为 key 的的数据\n// 返回用户的所有信息,name 为空返回所有void get_all_in_stu(MYSQL *mysql,const std::string&amp; name=&quot;&quot;)&#123;    std::string sql_cmd = &quot;select * from &quot;;    sql_cmd += TABLENAME;    if(name.size()!=0)    &#123;        sql_cmd += &quot; where name=&#x27;&quot;;        sql_cmd += name;        sql_cmd += &quot;&#x27;&quot;;    &#125;    sql_cmd += &quot;;&quot;;    cout &lt;&lt; &quot;[INFO] &quot; &lt;&lt; sql_cmd &lt;&lt; endl;    int ret = mysql_query(mysql,sql_cmd.c_str());    if(ret!=0)    &#123;        cerr &lt;&lt; &quot;[ERR] mysql query error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;         return ;    &#125;    // 获取结果    MYSQL_RES *res = mysql_store_result(mysql);    if (res == nullptr)     &#123;         cerr &lt;&lt; &quot;[ERR] mysql store_result error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;         return ;     &#125;        int row = mysql_num_rows(res); // 行    int col = mysql_num_fields(res); // 列    printf(&quot;%10s%10s%10s%10s\\n&quot;, &quot;ID&quot;, &quot; 姓名 &quot;, &quot; 年龄 &quot;, &quot; 成绩 &quot;);     for (int i = 0; i &lt; row; i++)     &#123;         MYSQL_ROW row_data = mysql_fetch_row(res);         for (int i = 0; i &lt; col; i++)         &#123;            printf(&quot;%10s&quot;, row_data[i]);         &#125;        printf(&quot;\\n&quot;);     &#125;     // 释放结果    mysql_free_result(res);&#125;\n\nget_all_in_stu(mysql);\n\n执行结果如下，显示出了表中所有的值\n[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success![INFO] select * from stu_test;        ID    姓名    年龄    成绩         2 小图图         5     72.80         3 大司马        42     87.30         4    乐迪        32     99.00\n\n传入特定名字，则只返回改名字所有值\nget_all_in_stu(mysql,&quot; 乐迪 &quot;);\n\n[INFO] select * from stu_test where name=&#x27; 乐迪 &#x27;;        ID    姓名    年龄    成绩         4    乐迪        32     99.00\n\n这样便实现了查询操作。\n\n3.5.1 模糊匹配  除了使用 name=，还可以使用name like % 名字 % 这条语句进行模糊匹配，即不在乎名字前后的内容，只要有包含名字的数据，就筛选出来。\nselect * from %s where name like &#x27;% 牛 %&#x27;;\n\n这样就能将名字里面包含牛的所有数据都筛选出来\n3.5.2 查询接口操作注意事项  因为查询的返回值是一个字符串二维数组，并不能通过字段名字获取到对应字段的内容。这要求程序猿知晓这个表中字段的顺序，才能通过下标获取到正确的字段对其进行处理。\n因为 cpp 并不像 python 那样支持可变变量类型，所以要想筛选出对应类型的数据，还需要我们自行调用对应的函数进行数据的转换。\n比如用 atoi 函数将字符串转为整型。\nThe end基本的操作到这里就 OVER 了，后续的其他操作会更新本博客；\n详细的用例可以看我的  视频点播项目  内部中和 mysql 相关的代码\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】事务","url":"/posts/2200233148/","content":"学习了之后，你会对 MySQL 如何进行数据的访问控制有更深刻的了解；\n\n\n本文中有大量截图，如果出现 404 的图片，请评论告知，谢谢；\n1. 什么是事务？1.1 场景举例 1.1.1 转账 当 A 需要给 B 转账 50 元的时候，后台应该进行如何处理？\n-- 先判断用户还有多少余额（这里的 user_id=A 只是一个示例，知道什么意思就行）select money from user where user_id=A;-- 如果余额充足，那就给 A 扣 50update user set money = money - 50 where user_id=A;-- 然后给 B 加 50update user set money = money + 50 where user_id=B;\n\n这一个操作，需要 3 个 SQL 语句才能完成，但很明显，我们即便在当前的服务器端对这 3 条语句的操作进行加锁，也没有办法避免如下的情况\n\n服务器负载过高，进程被 kill 了\n服务器断电了\nMySQL 服务器抽风挂掉了\n等等不可抗力\n\n这时候，如果在执行第一条查询语句后就挂掉了，那还不会有啥问题；但如果是在执行完毕第二条扣钱的语句之后挂掉了，那问题就大了！\n\nA 给 B 转钱，A 的钱扣了，B 的钱没有加，这怎么可以？\n\n最终还需要程序员通过 MySQL 的日志一个个核对到底是谁出现了这样的情况，给人家把钱加回去，那太过麻烦；在数据量大的时候，这种工作更是不应该由人工手动完成的！\n所以，MySQL 就需要提供一种方法，让我们能够实现类似原子性的操作。在执行这 3 条语句的时候，只能出现两种情况：\n\n成功执行，A 扣了钱，B 也加了钱，转账成功；\n执行失败，但是 A 和 B 的钱都没有变化，并告知用户转账失败；\n\n这样才是靠谱的结果！\n1.1.2 卖票  另外  一个场景  就是卖票，其也包含了多条 SQL\nselect * from ticket where tid=?; -- 查询某某车次高铁的票还有没有余量-- 有余量，进行售卖流程；这里可能要操作另外一张表来添加买票者的用户信息update ticket set num=num-1 where tid=?; -- 售卖流程结束，扣去这张票\n\n如果有两个客户端都同时来执行这两条 SQL 语句，那么就会出现问题；\n\n只剩一张票\n客户端 A 进行查询，发现有票，开始执行卖票流程\n客户端 B 进行查询，也发现有票，开始执行卖票流程\n此时 A 执行完毕，将票的数量 -1，卖完票了；\n随后 B 执行完毕，也将票的数量 -1，此时就会出现票数是负数的情况！\n更难受的是，同一张票被错误地卖给了两个用户！\n\n这时候在客户端里面加锁是不顶用的，两个客户端都不是同一个进程，锁无法共享；需要 MySQL 解决这个问题，就还得提供更加严格的访问控制，在 A 没有完成整个卖票逻辑，票数没有扣掉的情况下，B 不可以来查询票数；\n1.2 事务的介绍  事务（transaction）就是一组 DML 语句的集合，这些语句在逻辑上是一个整体；执行这组语句，必须全部成功，亦或者是全部失败。\n在执行这组 SQL 的时候，MySQL 需要将其视作一个原子性的操作；这个操作不能被其他事务打断，出现问题的时候还需要回滚到开始执行之前的初始状态；事务还能使不同客户端看到的数据是不同的，不同事务之间的操作不会相互影响；只有事务结束后，双方才能看到对方的操作（根据隔离级别不同，这点也会有区别）；\n正如上面的两个场景所提到的操作，同一个时刻对于 MySQL 的一个数据库来说，其可能有多个客户端进行不同业务的操作，如果都在访问同一个表，在不加访问控制的情况下，一定会出现访问临界资源的数据二义性问题。\n\n事务的出现，是客户端在实际应用场景下的需要，\n\n所以，一个完整的事务，除了是多条 DML 语句的集合，还需要满足下面 4 个特性\n\n原子性：一个事务中的所有操作，要么全部完成，要么全部失败；如果事务在执行过程中发现错误，那就需要回滚（Rollback）到事务开始之前的状态，就好比这个事务并没有执行过一般\n一致性：事务开始之前和结束后，数据库的完整性没有被破坏。进行的操作复合我们预设的要求；这包含数据的准确度、串联性以及后续数据库可以自发完成预定的工作；\n隔离性：数据库允许多个并发事务同时对数据库中的数据进行 CURD 操作，隔离性保证这些事务之间的操作并不会由于并发的交叉运行而出现不一致的情况。事务隔离性分为不同级别，具体的区别会在后文详解\n读未提交（Read Uncommitted）\n读已提交（Read Committed）\n可重复读（Repeatble Read）\n串行化（Serializable）\n\n\n持久性：事务处理完毕后，对事务的修改是永久的，即便系统宕机了也不会丢失（除非硬盘坏了）\n\n上面的四个属性，简称为 ACID；\n原子性（Atomicity，或称不可分割性）一致性（Consistency）隔离性（Isolation，又称独立性）持久性（Durability）\n\n其中，一致性是由原子性、隔离性、持久性来保证的，只要满足了这三个性质，自然能实现一致性。简单记忆，AID 来保证 C；\n1.3 事务的存储引擎支持  在 MySQL 中，只有 Innodb 支持事务，MyISAM是不支持事务的；\n我们可以用如下语句来查询 MySQL 的引擎和支持的特性\nMariaDB [hello_mysql]&gt; show engines \\G*************************** 1. row ***************************      Engine: MEMORY     Support: YES     Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 2. row ***************************      Engine: MRG_MyISAM     Support: YES     Comment: Collection of identical MyISAM tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 3. row ***************************      Engine: CSV     Support: YES     Comment: Stores tables as CSV filesTransactions: NO          XA: NO  Savepoints: NO*************************** 4. row ***************************      Engine: BLACKHOLE     Support: YES     Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO          XA: NO  Savepoints: NO*************************** 5. row ***************************      Engine: MyISAM     Support: YES     Comment: Non-transactional engine with good performance and small data footprintTransactions: NO          XA: NO  Savepoints: NO*************************** 6. row ***************************      Engine: ARCHIVE     Support: YES     Comment: gzip-compresses tables for a low storage footprintTransactions: NO          XA: NO  Savepoints: NO*************************** 7. row ***************************      Engine: FEDERATED     Support: YES     Comment: Allows to access tables on other MariaDB servers, supports transactions and moreTransactions: YES          XA: NO  Savepoints: YES*************************** 8. row ***************************      Engine: PERFORMANCE_SCHEMA     Support: YES     Comment: Performance SchemaTransactions: NO          XA: NO  Savepoints: NO*************************** 9. row ***************************      Engine: SEQUENCE     Support: YES     Comment: Generated tables filled with sequential valuesTransactions: YES          XA: NO  Savepoints: YES*************************** 10. row ***************************      Engine: InnoDB     Support: DEFAULT -- 默认引擎     Comment: Supports transactions, row-level locking, foreign keys and encryption for tables -- 描述Transactions: YES  -- 支持事务          XA: YES    Savepoints: YES  -- 支持事务中的保存点*************************** 11. row ***************************      Engine: Aria     Support: YES     Comment: Crash-safe tables with MyISAM heritageTransactions: NO          XA: NO  Savepoints: NO11 rows in set (0.000 sec)\n\n1.4 保存点  所谓保存点，就是在事务执行过程中，给当前的数据设置一个 savepoint，这样在出现问题的时候，可以回退到当前的数据中；就好比之后的操作没有进行一样；\n游戏中的保存点其实也是这样的功能，让玩家回退到打某个 BOSS 之前，包括当时你收集的材料，都会回退到打这个 BOSS 之前的状态；\n你可以理解为，是给当前的数据拍了张照片，出现问题的时候，用这个照片里面的东西复写掉新的东西。这便是保存点的作用；\n1.5 基础命令操作  先提一下事务的开启和结束方式，以及如何设置保存点和回滚吧\n-- 开启，这两种方式是一样的begin;start transaction;-- 设置保存点（名字可以自由更改，但不能有重复）savepoint save1; -- 创建一个保存点 save1rollback to save1; -- 回滚到保存点 save1rollback; -- 回滚到事务开始-- 结束commit; -- 提交事务\n\n2. 使用  了解了事务为什么存在，下面就是来使用一下事务了；\n2.1 提交方式  事务的提交方式有两种方式\n\n自动提交\n手动提交\n\n默认情况下，MySQL 的自动提交是处于开启状态的\nMariaDB [hello_mysql]&gt; show variables like &#x27;autocommit&#x27;;+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | ON    |+---------------+-------+1 row in set (0.001 sec)\n\n我们可以用下面的语句来设置是否开启自动提交（只对当前会话生效）\nset autocommit = 0; -- 关闭自动提交set autocommit = 1; -- 开启\n\n这两个提交方式有啥区别呢？是不是开了自动提交就什么都不用管了？后文我们再通过实测来说明；\n2.2 场景演示  最开始测试的时候，先将事务隔离级别设置为读未提交；请注意，不要在有生产环境的 MySQL 中进行此项操作；\n-- 设置全局隔离级别为读未提交set global transaction isolation level READ UNCOMMITTED; -- 重启 mysql 终端后查看隔离级别select @@tx_isolation; +------------------+| @@tx_isolation   |+------------------+| READ-UNCOMMITTED |   -- 成功设置读未提交的隔离级级别+------------------+1 row in set (0.000 sec)\n\n2.2.1 数据回滚演示  设置完毕后，进入测试数据库，创建如下测试表\ncreate table test_ruc(\tid int unsigned primary key,\tuser_id int unsigned not null,    name varchar(30) not null);\n\n先给表里面插入几个基本的数据：\ninsert into test_ruc values (1,10,&#x27; 李华 &#x27;),(2,20,&#x27; 王五 &#x27;);\n\n插入后，我们在两侧的终端中都可以看到已有的数据\n\n随后在两个终端中都开启一个事务，左侧终端插入一个数据，右侧终端查看\ninsert into test_ruc values (3,30,&#x27; 左侧终端插入 &#x27;);\n\n可以看到，两侧的终端都可以看到这份数据\n\n此时将左侧终端强制退出（使用 CTRL+\\），右侧再次查询，会发现新插入的数据没有了；这里便是事务的 原子性  的体现，左侧的终端所执行的事务没有 commit 就因为异常退出了，MySQL 自动将数据回滚到了这个事务执行之前，即没有插入这份新数据；\n\n左侧重新链接 MySQL，开启一个事务；在右侧插入一个数据，随后创建保存点save1；插入第二个数据，创建保存点save2；\n在左侧查询，我们可以看到右侧插入的两条新数据；\n\n在右侧回滚到保存点 save1，会发现插入的数据 2 没有了；这与保存点的预期操作相符合；\n\n将右侧终端强制退出，再次查询数据，可以看到第一次插入的数据也没有了，数据又回到了右侧终端事务开始之前的样子。\n\n这里能得出一个结论：如果终端异常退出，MySQL 会将数据回滚到事务开始时；你可以理解为，我们使用 begin; 的时候就已经创建了一个隐藏的保存点，MySQL 在异常的时候只会将数据回退到这个  事务开始之时  的隐藏保存点，无论中途用户有没有设置其他保存点！\n即：在异常退出的时候，MySQL 会自动帮我们执行 rollback 命令回退到事务开头！\nrollback; -- 回退到事务开头\n\n这样就能避免最开始提到的，转账系统中给 A 扣了钱但是没有给 B 加钱的问题！\n2.2.2 数据持久化演示  接着我们再来看看，如果执行了 commit 之后又会是什么情况；\n右侧提交了事务后退出，左侧依旧能查询倒已经提交的数据。代表数据已经被持久化写入到了磁盘（当然这个时候也不一定立刻刷盘了，但是这已经能代表 MySQL 将我们的数据加入到了持久化策略中，并不需要我们管啥时候刷盘的问题！）\n\n2.2.3 自动提交  前面提到了，MySQL 的自动提交默认是开启的；那么这个自动提交有什么作用呢？是不是开启了自动提交，就不需要手动创建事务了？\n并不是 ！在之前的测试中，autocommit 是开启的；我们已经证明了，手动 begin 创建的事务，在没有手动 commit 的时候不会被写入磁盘（不进行持久化）；这代表我们手动创建的事务，不会受到 autocommit 是否开关的影响；（开着的时候都没有自动提交，关闭的时候肯定更不会自动提交了）\n\n那么这个 autocommit 会影响谁呢？\n\n开启两个终端，左侧将自动提交关闭，随后插入一个数据；插入后会发现右侧看不到左侧新插入的数据！\n\n备注：set autocommit = 0;语句只会影响当前终端，不会影响另外的终端。\n\n\n此时手动进行commit，右侧就看得到数据了！\n\n而如果我们不手动执行 commit 就把左侧终端 CTRL+\\ 退出，那么新插入的这一条数据会丢失！\n2.2.4 单条 SQL 和事务的关系  欸？我们明明没有 begin 开启事务，为什么可以执行 commit 呢？\n这是因为，在 MySQL 中，每一个不主动使用事务的单条 SQL 语句，都会视作一个事务进行操作！既我们之前没学习事务时，执行的所有单条 SQL 也是一个个各自独立的事务！\n知道了这一点，你就能理解  自动提交的作用  了：在执行单条 SQL 的时候，是否自动提交该 SQL 语句的事务。\n将 autocommit 重新开启，再进行测试；会发现左侧插入的数据右侧可以立马看到，无需手动commit。这便是自动提交的作用的体现！\n\n2.3 结论  经过上面的这些简单测试，我们可以看到事务的原子性和持久性，做一个总结\n\n输入了 begin/start transaction 手动创建的事务，必须通过 commit 手动挡提交，才会持久化；这一点和 autocommit 无关！\n事务可以设置保存点和手动回滚，出现异常的时候，MySQL 会自动回退到事务开头；\n对于 InnoDB 存储引擎而言，所有的单条 SQL 语句都会被视作一个事务，自动提交；\nselect语句会有一些差别，因为 MySQL 有 MVCC 访问控制（后文讲解）\n\n操作事务的一些注意事项\n\n只有 InnoDB 才支持事务，MyISAM不支持;\n一个事务被提交了之后，不可以执行rollback;\n创建了保存点后，可以选择回退到哪一个保存点，亦或者是回退到事务开头；\n\n3. 事务隔离级别 3.1 基本说明 事务的隔离级别和事务的隔离性息息相关\n\nMySQL 的单个数据库可能被多个进程 &#x2F; 线程同时进行访问和事务操作；\n一个事务是由多个 SQL 语句组成的，任何一个事务，都会存在执行前 &#x2F; 中 &#x2F; 后的阶段。所谓原子性，就是 MySQL 要保证各个客户端要么只能看到事务执行前或者执行后的数据；执行中的事务，对于其他用户来看是原子的，出现异常会被自动回滚；\n但事务毕竟还是存在执行中的概念，其他客户端是有可能看到某个事物执行中的状态的，这就需要隔离性来介入了；\n隔离性：保证事务在执行过程中尽量不受干扰；\n隔离级别：允许事务受不同程度的干扰；\n\n开头就提到了，MySQL 的事务有 4 种隔离级别\n\n读未提交（Read Uncommitted）：在这个隔离级别中，所有事务都可以看到其他事物还没有提交的内容（你可以理解为压根没有隔离性，之前的测试使用的就是这个隔离级别）这种情况下就容易引起并发和读取数据的不一致问题，还有  脏读  问题（对方没有 commit 的数据就叫做脏数据），生产环境中是打死不能用这个隔离级别的！\n读已提交（Read Committed）：在这个隔离级别中，事务只可以看到其他事务已经提交了的内容。这已经满足了隔离的基本定义：只能看到其他事务开始前或者开始后的内容；但是这种隔离模式会产生  不可重复读  的问题（相同 select 会出现不同结果）；\n可重复读（Repeatable Read）：为了解决不可重复读的问题，这个隔离级别保证了事务在运行过程中多次读取相同数据时会得到相同结果；但是这个隔离级别在某些数据库中可能会出现  幻读  问题；MySQL 默认采用此隔离级别；\n串行化（Serializable）：所谓串行化，就是 MySQL 给数据库的所有操作都上锁，必须要排队运行。一个事务在运行时，另外一个事务得等它运行完毕了才能进来运行，这样能最大程度保证隔离性；但是会降低效率；\n\n隔离级别是由 MySQL 进行各种类型的加锁来实现的，比如表锁、行锁、读写锁、间隙锁（GAP）、NEXT-KEY 锁（GAP+ 行锁）等等；\n\n这里还需要验证另外一件事，MySQL 如果开启了串行化，客户端 c&#x2F;cpp 操作还需要加锁吗？mysqlquery的操作是会阻塞还是直接错误退出？\n\n在 MySQL 中，事务的隔离级别可以分别设置全局的隔离级别和当前客户端的隔离级别；如果没有主动设置客户端的隔离级别，则会继承全局的隔离级别。顾名思义，会话隔离级别只会影响当前的会话，不会影响另外的客户端；\n另外，全局的隔离级别会在数据库服务重启后，被重置为配置文件中默认的隔离级别（一般是 RR）\n-- 设置 会话 / 全局 隔离级别set [session | global] transaction isolation level [read uncommitted | read committed | repeatable read | serializable ]-- 查看当前会话的隔离级别select @@session.tx_isolation;-- 查看全局的隔离级别select @@tx_isolation;\n\n3.2 读未提交  这个隔离级别在第二大点里面就已经测试过了，左侧终端插入的数据，即便没有 commit，在右侧终端中也能看得到，这里就不二次演示了\n\n清楚已有的数据，来测试一下会话隔离级别的作用；默认情况下，全局和会话的隔离级别都是 RR；\nMariaDB [hello_mysql]&gt; select @@tx_isolation;+-----------------+| @@tx_isolation  |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.000 sec)MariaDB [hello_mysql]&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| REPEATABLE-READ        |+------------------------+1 row in set (0.000 sec)\n\n将左侧的终端中的会话隔离级别设置为读未提交\nset session transaction isolation level read uncommitted;\n\n插入数据之前 ，执行一次select 全列查询，两侧都是空；\n在左侧插入数据后，右侧查看会发现依旧是 empty set 没有结果；只有左侧 commit 之后，右侧才能看到数据；这是因为在之前测试的时候，我们将自动提交关闭了；右侧看不到我们还没有提交的事务；\n\n右侧手动开启事务后，即便没有进行commit，但是左侧因为设置了读未提交，所以可以直接看到右侧还没有提交的事务中的修改。这便是这个隔离级别的特性；\n\n3.3 读已提交  接下来再将全局隔离级别设置为读已提交，重新开启两个终端进行测试；\nset global transaction isolation level read committed;\n\n设置完毕，重启终端后，可以看到两侧的隔离级别都是读已提交，自动提交都是开启的；\n\n两侧都开启一个事务，左侧插入数据，右侧查看，发现没有内容；\n\n左侧 commit 之后，右侧才可以看到这个数据；\n\n这符合我们对  读已提交  这个隔离级别的字面理解，但是这并不代表这个隔离级别没有问题！\n3.3.1 出问题的场景  来看看下面这个场景：\n\n公司需要根据员工工资，分发不同级别的奖金：\n2000-4000 级别一\n4001-8000 级别二\n8001-15000 级别三\n\n\n甲开启了一个客户端，开始用 MySQL 筛选不同工资区间的员工，记录下来；\n乙开启了一个客户端，想要给员工丁加工资\n丁原本的工资是 3000\n乙给丁加了 2000 工资，丁的工资变成了 5000，跳到了工资级别二；\n乙提交修改（commit）\n\n\n假设甲已经完成了对 2000-4000 级别工资的员工筛选，此时乙过来给丁加了工资，丁跳到了工资级别二；\n因为隔离级别是读已提交，甲在筛选工资级别二的人员时，会把刚刚被修改过的丁也给纳入进去；\n这时候，对于甲而言，丁就同时出现在了工资级别一和二的人员中，这明显是不合理的！\n\n这个场景被称为  不可重复读 ，即在一个事务中，同一个查询语句，可能会因为其他事务的提交而产生不同的结果；换做 SQL 语句来描述，在读已提交的隔离级别中，同一个 select 语句只能执行一次，第二次执行的时候，可能会获取到和第一次不同的结果，所以这个问题才被称作 不可重复读（不可以重复执行 select）问题；\n\n来实际演示一下，两侧都开启一个新的事务，左侧终端更新表中的用户 id，只要它不提交，右侧就看不到修改。\n\n但是提交了之后，右侧就能看到这个用户 id 的改变，在进行数据筛选的时候，这种情形就会出现问题！\n\n3.4 可重复读  所以，为了避免上面提到的这个问题，MySQL 还提供了一个可重复读的隔离级别，且默认采用的就是这个隔离级别；\nset global transaction isolation level  repeatable read;\n\n可重复读就解决了上面提到的问题，即便其他事务提交了修改，当前事务也看不到这份修改，只有当前事务结束后，才能看到最新的数据；\n看下图，两侧都开启一个事务，不管左侧是否有提交事务，右侧都看不到左侧新插入的数据；\n\n只有右侧也提交了自己的事务，才能看到左侧插入的新数据；\n\n这就保证了，右侧这个事务在运行的始终，它执行的相同 select 语句的结果永远都是一样的，不会出现不可重复读的问题！\n而如果在 RR 级别中，同时访问相同数据，会出现  加锁  的情况，下图中，右侧插入了主键为 6 的数据，此时左侧如果也尝试插入一个主键为 6 的数据，会进入阻塞状态；\n\n如果很久都不继续操作，就会因为等待超时，跳出等待\nMariaDB [hello_mysql]&gt; insert into test_ruc values (6,60,&#x27; 天数 &#x27;);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n\n但当前事务中插入的数据依旧是存在的，当前事务也没有结束\n\n再次尝试插入这个主键为 6 的数据，依旧会陷入阻塞态，只有右侧的事务被提交了之后，左侧才会出现主键冲突的提示，禁止插入；\n\n左侧 commit 了之后，右侧才能看到左侧新插入的主键为 5 的数据；\n\n3.5 串行化  这个就比较简单了，一个事务没结束，另外一个就阻塞等待；\n串行化是最高的隔离级别，但其并发性能很低，实际上用的也不多；\nset global transaction isolation level  serializable;\n\n两侧终端都开始事务，查询的时候是不会加锁的，但是左侧执行 update 的时候，阻塞了（可以通过左侧 update 的执行时间观察到阻塞现象，截图看的不是很明显）；右侧也执行一次update，左侧的 update 就立马成功了，右侧显示报错检测到死锁，建议尝试重启事务；\n\n再来试试，两侧都开启事务，左侧尝试插入一个数据，会阻塞 ；右侧commit 之后，左侧的插入就立马成功了！\n\n这便是串行化的表现：两个事务如果都是在执行 select 的读取操作，则不会被阻塞，但如果有一个事务要执行  增删改，那么就必须等待其他事务都结束了，这个操作才能被执行；\n3.5.1 串行化的适用场景  回到 1.1.2 卖票 的场景，在这个场景下，如果你需要保证客户端 A 的卖票逻辑完全执行完毕了，客户端 B 才能过来查询票数，那就需要使用串行化；\n但是，串行化中，我们是可以执行查询操作的！那么在 A 没有结束的情况下，B 不还是会查询到有剩余票数？\n\n实际上，我们的卖票操作并不是直连数据库实现的，而是有一个服务端进程来提供 API，供客户端来查询剩余票数，剩下的卖票操作其实都是服务端来实现的（让客户端直连 MySQL 来执行 SQL 是非常不可靠的，很有可能出现 SQL 注入攻击）\n\n所以，这个问题得在服务端进程中加锁解决！MySQL 本身即便使用串行化也是没有办法解决这个问题的；\n但是，别忘了，MySQL 还有另外一个东西——约束 ；你可以设置一个触发器，更新剩余票数的时候，拒绝将票数设置为负数；这样客户端 B 即便进入了卖票业务，最终将剩余票数的数据设置为负数的时候， 也会被 MySQL 阻止插入，这个卖票的事务 B 就相当于错误退出了，所有操作都会被回滚！而隔离级别就是避免 A 和 B 同时修改一个数据而导致的错误；\n二者相辅相成，就能解决这个问题；当然，在服务端 API 处理逻辑中加锁是更好的解决办法，既可以保证数据一致性，又能隔离客户端和 MySQL 服务；\n\n后文讲到的当前读也能在某种程度上解决这个问题，反正解决的办法多多！\n\n3.5.2 串行化和 CPP如果将 MySQL 的隔离级别（isolation level）设置为最高级别的串行化（SERIALIZABLE），那么并发的多线程操作可能会遇到以下情况之一：\n\n阻塞：当一个线程正在使用某个数据时，其他线程需要等待该线程释放锁才能继续进行操作。这会导致其他线程在获得所需锁之前被阻塞。\n错误退出：如果多个线程同时操作相同的数据，并且它们无法同时持有访问该数据的锁，就会引发死锁。在这种情况下，某些线程会被系统终止，从而导致错误退出。\n\n所以，并不是说你将 MySQL 的隔离级别设置好了，那么客户端就啥事不用干了；最好的操作依旧是在客户端就加锁进行一定的访问控制，因为 MySQL Query 函数的错误退出 + 退出情况识别，相比于客户端进行访问控制更难以操作；\n3.6 总结\n隔离级别越高，安全性越高，数据库的并发性能就越低；我们需要根据业务逻辑，选用合适的隔离级别；\n不可重复读的问题在于其他客户端的修改和删除，同样的 select 语句会查出不同的结果，是不合理的；\n幻读的重点在于新增，其他客户端新增的记录可能被我们当前的客户端查询到；但是在 MySQL 中，这个问题是不存在的，因为 InnoDB 通过 NEXT-KEY 锁解决了幻读问题；\n事务也分为长短事务的概念，事务之间互相影响，主要指的是事务在并行阶段（都没有 commit 的时候）产生的影响；\n一般情况下，我们使用 MySQL 默认的 RR 的事务级别就可以了；\n\n下面给出一个不同事务级别之间的区别的表格，Y 代表会出现这个问题，N 代表不会出现这个问题\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n加锁读\n\n\n\n读未提交\nY\nY\nY\n不加锁\n\n\n读已提交\nN\nY\nY\n不加锁\n\n\n可重复读\nN\nN\nN\n不加锁\n\n\n串行化\nN\nN\nN\n加锁\n\n\n3.7 一致性\n事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务 成功提交的结果时，数据库处于一致性状态。\n如果系统运行发生中断，某个事务尚未完成而被迫中 断，而改未完成的事务对数据库所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性是通过  原子性  来保证的。\n其实一致性和用户的业务逻辑强相关，一般 MySQL 提供技术支持，但是一致性还是要用户业务逻辑做支撑（比如客户端如果不使用事务，那 MySQL 也没有办法帮助维护），所以说，一致性是由用户决定是否维护的。 \n技术上，通过 AID 保证 C\n\n4. 隔离性的理解  说完了隔离级别，接下来再深入理解一下隔离性\n4.1 MVCC数据库并发的场景一共有下面三种\n\n读 - 读：不存在任何问题，不需要访问控制\n读 - 写：有线程安全问题，可能会遇到隔离性中的脏读、幻读、不可重复读问题；\n写 - 写：有线程安全问题，还有可能出现更新丢失问题；\n\n我们主要关注的是读写并发的情况，这也是数据库最常遇到的处理场景；\n再 MySQL 中，采用了 MVCC（多版本并发控制）来解决读写冲突，这是一种无锁的并发控制机制；\n在了解 MVCC 之前，我们需要了解几个前置知识：\n\n三个隐藏列字段\nUNDO 日志\nREAD VIEW\n\n4.1.1 隐藏列字段  在 MySQL 中，每一个表都存在三个隐藏的列字段\n\nDB_TRX_ID：6 byte，最近修改 (修改 &#x2F; 插入) 事务 ID，记录创建这条记录 &#x2F; 最后一次修改该记录的事务 ID；\nDB_ROLL_PTR: 7 byte，回滚指针，指向这条记录的上一个版本（简单理解成，指向历史版本就 行，这些数据一般在 undo log 中） \nDB_ROW_ID: 6 byte，隐含的自增 ID（隐藏主键），如果数据表没有主键， InnoDB 会自动以 DB_ROW_ID 产生一个  聚簇索引；\n补充：实际还有一个删除 flag 隐藏字段，既记录被更新或删除并不代表真的删除，而是删除 flag 变了；\n\n假设有如下表结构\ncreate table if not exists student(    name varchar(11) not null,    age int not null);-- 插入一条记录insert into student (name, age) values (&#x27; 张三 &#x27;, 19);\n\n那么这个表中的实际数据是这样的\n\n\n\nname\nage\nDB_TRX_ID(创建这个记录的事务 ID)\nDB_ROW_ID（隐藏主键）\nDB_ROLL_PTR（回滚指针）\n\n\n\n张三\n19\nNULL\n1\nNULL\n\n\n我们并不知道创建这个记录的事务 ID，所以设置为 NULL；因为是第一条记录，所以隐藏主键是 1；因为是第一条记录，所以没有回滚的地方，回滚指针也是 NULL（换句话说，如果回滚指针为 NULL，代表这个就是这个表中的第一条记录了）\n4.1.2 undo 日志 MySQL 是以服务进程的方式在内存中运行的，我们对数据的 CURD 操作，都需要通过 MySQL 将其刷入到硬盘上进行持久化，MySQL 为这些操作会提供一个专门的buffer pool 内存缓冲区；而 undo log/redo log 也是内存中的一块区域，对于 MySQL 而言\n\n日志需要立刻刷盘（有一个专门的线程来管理日志）\n数据根据运行策略，选择合适的时间刷盘（因为数据量一般比较大，如果实时刷盘会造成较大 IO 负载，影响进程运行）\n\n先来说说 redo log，这里包含了 MySQL 中的所有尚未落盘的 CURD 操作；如果 MySQL 还没有写入数据的时候就挂了，那么下次启动的时候就会从redo log 里面恢复数据，来确保数据的一致性和完整性；\n在 MySQL 存储路径 /var/lib/mysql 中的 ib_logfile0/ib_logfile1 就是redo log；\n-rw-rw----. 1 mysql mysql  50331648 Sep 11 03:16 ib_logfile0-rw-rw----. 1 mysql mysql  50331648 Sep  9 21:03 ib_logfile1\n\n而 undo log 主要用于以下功能\n\n回滚事务\nMVCC（多版本控制 &#x2F; 隔离性和隔离级别）\n\n假设我们来了一个 update 操作，将刚刚插入的张三的年龄改成 30 岁，对于 MySQL 而言就会在 undo log 里面做如下处理；\n\n该 update 操作对应的事务 DB_TRX_ID 是 10；\n将旧数据放入 undo log 中，并将当前数据的 DB_ROLL_PTR 指向旧数据的地址；\n如果需要回滚，那么就通过 DB_ROLL_PTR 找到旧数据，复写回去；\n\n\n如果再来一次修改，将张三的名字改成李四，也是依照这个逻辑在 undo log 中新增旧数据，并链接 DB_ROLL_PTR 指针；\n\n事务 11 修改这条数据，先申请锁；\n将现有数据复制到 undo log 中（头插），并将 DB_ROLL_PTR 指针指向旧数据的地址；\n修改记录中的 name，并且将 DB_TRX_ID 改成当前事务的 ID 11；\n事务 11 提交，释放锁；\n\n\n这样，我们就有了一个类似于链表的历史版本链；每次回退的时候，都可以找到历史数据，覆盖当前的数据。这些版本我们称之为  快照；\n而插入和删除都可以写入undo log，但是只有更新和删除能形成历史版本链；\n\n删除是将删除 flag 置为真，旧数据依旧可以写入到 undo log 中，如果需要回滚，将这行记录恢复；\n插入并没有历史版本，但也需要将其放入 undo log 中，事务回滚的时候需要将新插入的数据删除；\n事务提交了之后，已有的历史记录可以被删除；\n\n增删改都说了，那么 select 呢？\n一般而言，查询不会产生数据写入操作，也不需要设置历史版本链；\n但是在之前关于 RR 级别隔离性的验证中，我们看到了 select 无法看到另外一个事务已经提交了的数据，这说明 select 有时候读取的是  历史版本  的数据，而并非当前最新的数据！\n读取历史数据我们称之为  快照读，在 RR 级别中默认采用的就是快照读；读取最新数据叫做当前读（增删改都是当前读）；还有一种读取是为了更新而查询；\nselect ... -- 在 RR 级别下，默认是快照读select ... for update; -- 为了更新而查询-- MySQL 会将当前行上排他锁，上锁了之后，其他客户端只能查询该行，无法修改select ... lock in share mode; -- 查询最新数据（当前读）-- 是串行化的，只有其他事务完成了，才能查询到最新结果；\n\n除了手动指定 select 的查询方式以外，隔离级别会影响 select 的默认行为，比如在串行化隔离级别的场景下，默认执行的就是  当前读；\n在 RR 模式下进行测试，会发现当前读会阻塞当前的客户端（右侧客户端阻塞）；\n\n只有左侧的事务在提交了之后，右侧的查询才会返回最新的结果；\n\n这是因为  当前读 ，包括增删改操作，是需要加锁的；如果要在 RR 模式下实现当前读，那么整个系统就需要 串行化  执行；\n而快照读不需要加锁，因为它可以读取历史版本，而历史版本是不会被其他线程修改的，也就不需要维护访问控制，提高了并发效率；\n那么，MySQL 是如何实现快照读的呢？\n4.1.3 Read ViewRead View就是 MySQL 为快照读生成的一个  读视图 ；在事务执行快照读的时候（即执行select 的时候）将当前数据拍一张照，这样在这个事务中，后续的所有 select 都只会看到这个照片里面的结果，看不到其他事务最新的修改（不管其他事务是否 commit）。\n\n快照读的现象我们已经在本文 3.4 可重复读 中演示过了，这里就不再二次演示了；\n\nRead View在 MySQL 的源码中其实就是一个类，该类中包含一些可读性判断的信息，内部有条件，来标明当前事务能够看到那个版本的数据，即有可能是当前最新的数据，也有可能是 undo log 中的某个历史版本；\nclass ReadView &#123;// 省略...private:    /** 高水位，大于等于这个 ID 的事务均不可见 */    trx_id_t m_low_limit_id    /** 低水位：小于这个 ID 的事务均可见 */    trx_id_t m_up_limit_id;    /** 创建该 Read View 的事务 ID*/    trx_id_t m_creator_trx_id;    /** 创建视图时的活跃事务 id 列表，是一个位图 */    ids_t m_ids;    /** 配合 purge，标识该视图不需要小于 m_low_limit_no 的 UNDO LOG，    * 如果其他视图也不需要，则可以删除小于 m_low_limit_no 的 UNDO LOG*/    trx_id_t m_low_limit_no;    /** 标记视图是否被关闭 */    bool m_closed;    // 省略...&#125;;\n\n单独说明一下这里的 4 个重要的变量；其中需要注意，在这里面up 是低水位，low 是高水位，这是由他们保存的数据的性质决定的，请不要和这两个单词的本意混淆！\nm_ids; // 一张位图，用来保存 Read View 生成时，系统正活跃（没有结束的）的事务 IDup_limit_id; // 记录 m_ids 列表中事务 ID 最小的 ID low_limit_id; // ReadView 生成时刻系统尚未分配的下一个事务 ID，也就是目前已出现过的事务 ID 的最大值 +1creator_trx_id // 创建该 ReadView 的事务 ID\n\n要知道，当前事务是知道自己的事务 ID 的（DB_TRX_ID），那么我们手中就有快照读中最大最小的事务 ID，以及当前活跃中的事务 ID；那么在读取版本链的时候，就进行如下匹配，设当前开启的这个  事务为 A:\n\n版本链中的事务 ID 不存在于 m_ids 中，代表  事务 A 开启  的时候，这个事务已经提交了，所以我们可以读取这个事务操作的结果；\n版本链中的事务 ID 存在于 m_ids 中，代表事务 A 开启的时候，这个事务是  活跃状态，那么我就不应该读到这个事务的操作结果；\n版本链的中的事务 ID 大于low_limit_id，代表事务 A 开启的时候，这个事务还不存在，所以也不应该看到这个在 A 之后来的事务的操作结果；（A 还没操作完毕，这个新事务就来了）\n版本链中的事物 ID 小于 up_limit_id，代表事物 A 开启的时候，这个事物都不知道是是它的父亲辈还是爷爷辈了， 长辈给你留下的东西肯定得好好收着；说人话：这个是 A 来之前的之前就已经结束了的事物，肯定是可以读取其结果的；\n\n在 MySQL 中我们可以看到如下源码，链接也贴出来了，github 上可以查看源码；这个函数就是用来判断当前事务应该能看到那些版本链的，具体的判断逻辑参考中文注释（英文注释是官方留的）\n// 这个函数是 ReadView 类的成员函数 ReadView::changes_visible // 源码链接 https://github.com/mysql/mysql-server/blob/ea1efa9822d81044b726aab20c857d5e1b7e046a/storage/innobase/include/read0types.h#L162  // [[nodiscard]] 代表这个函数的返回值不能被忽略，一定需要使用该返回值；否则编译器会爆警告；即告知程序员必须关注这个函数的返回值！// 函数的返回值是当前事务能否看到某一个事务 id 值的版本链，入参是目标事务 id/** Check whether the changes by id are visible.  @param[in]    id      transaction id to check against the view  @param[in]    name    table name  @return whether the view sees the modifications of id. */  [[nodiscard]] bool changes_visible(trx_id_t id,                                     const table_name_t &amp;name) const &#123;    ut_ad(id &gt; 0);\t    // 小于最小的事务 id 或者等于当前事务 id，则代表这个事务我们可以看到     if (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;      return (true);    &#125;    check_trx_id_sanity(id, name);\t// 如果这个 id 比当前事务中的高水位还大，说明这个 id 是后来者，不应该看到    if (id &gt;= m_low_limit_id) &#123;      return (false);    &#125;\t// 如果当前事务创建时，没有活跃事务    // 且 m_up_limit_id &lt;= id &lt; m_low_limit_id     // 那么这个事务 ID 就可以被看到，返回真     else if (m_ids.empty()) &#123;      return (true);    &#125;    const ids_t::value_type *p = m_ids.data();\t// 如果上面都没有匹配到，那就检查这个 id 是否在活跃列表 m_ids 中    // std::binary_search 的返回值：是否在位图中，true 代表在，false 代表不在    // 如果在，那么这个事务是活跃状态，不能被看到    // 如果不在，那么这个事务是已经提交了，可以被看到    return (!std::binary_search(p, p + m_ids.size(), id));  &#125;\n\n如果查到不应该看到当前版本，接下来就是遍历下一个版本，直到符合条件，即可以看到。这便是我们 select 当前读的时候，会自动产生的 ReadView 结构体的作用；\n根据这份源码，我们也能知道 m_ids 位图中，并不需要存放当前事务 ID，因为会有额外的判断来处理当前事务 ID！\n4.2 快照读实操 4.2.1 快照是什么时候生成的？ 假设当前的事务流程如下，事务 2 能看到事务 1 的操作结果吗？\n\n\n\n事务 1\n事务 2\n\n\n\n事务开始\n事务开始\n\n\n插入数据 1 并提交事务\n\n\n\n\n第一次查询\n\n\n重开一个新事务，插入数据 2 并提交\n\n\n\n\n第二次查询\n\n\n来实操一下，开两个 MySQL 终端，隔离级别设置为 RR；图中黄字标出了每一个 SQL 的执行顺序；我们会发现，当左侧终端提交了第一个插入的数据后，右侧才查询，是可以看到这条新插入的数据的！\n而左侧插入的第二条数据右侧就看不到了，很明显，此时访问的就是快照中的旧数据，而不是新数据了；\n\n这就告诉我们：快照读的  快照  是在事务中第一次执行 select 语句的时候生成的！并不是事务开始的时候生成的！\n这也非常合理，如果你的当前事务压根没有进行 select 语句，那我也就没有必要生成快照了，毕竟快照的底层是 ReadView 对象，也是会占用内存空间的！而增删改操作本身就是当前读，无需生成快照！\n4.2.2 实例解释 ReadView 的成员变量  用实际例子来解释一下 ReadView 里面的 4 个成员变量到底应该存放什么值；\n假设有下面这个数据\n\n\n\nname\nage\nDB_TRX_ID(创建这个记录的事务 ID)\nDB_ROW_ID（隐藏主键）\nDB_ROLL_PTR（回滚指针）\n\n\n\n张三\n19\nNULL\n1\nNULL\n\n\n一共有 4 个事务同时运行，事务序号就是事务 ID\n\n\n\n事务 2\n事务 3\n事务 4\n事务 5\n\n\n\n事务开始\n事务开始\n事务开始\n事务开始\n\n\n……\n……\n……\n修改张三的年龄并提交\n\n\n运行\n快照读\n运行\n……\n\n\n……\n……\n……\n……\n\n\n在这种情况下，事务 3 对某行数据进行了快照读，MySQL 就会在这时候生成一个ReadView，内部变量赋值如下\nm_ids; // 2,4 (当前事务 5 已经提交了，所以除了自己就只有 2 和 4 活跃中)up_limit_id; // 2 (m_ids 中最小事务 ID)low_limit_id; // 5 + 1 = 6 (当前已经出现的最大事务 ID+1)creator_trx_id // 3 (当前事务 ID)\n\n当事务 3 进行快照读的时候，就会拿事务 5 的这份数据进行比较，最终得到的结果是，事务 3 的快照是  可以  看到事务 5 对数据进行的修改的！\n而且对于全局来说，事务 5 提交的这份数据也是当前最新的数据！\n// 比较流程（依照上方 MySQL 的源码）5 &lt; up_limit_id || 5 == 3; // 不小于最小的，且也不等于当前的事务 ID 35 &gt; low_limit_id; // 不大于最大的// 判断 5 是否在 m_ids 里面m_ids.contains(5); // 不在// 结论：return true;\n\n4.3 当前读实操  快照读的场景基本搞明白了，再来试试当前读（这里小提一嘴，写 - 写并发  可以理解为所有操作都是当前读，需要串行化）\nselect ... lock in share mode;\n\n下面是两个不同的操作流程，最终会得到不同的结果；操作之前，先执行如下两个 sql\ndelete from test_ruc;insert into test_ruc values (1,20,&#x27; 张三 &#x27;);\n\n在第一次测试中，我们在左侧终端更新数据之前就执行了一次快照读，此时 MySQL 会生成快照，即便在左侧终端的事务 commit 了之后，右侧也无法看到最新的 user_id=18 的数据；此时使用当前读，就可以读取到最新的数据！\n\n而在第二次测试中，我们让左侧终端完成所有操作，右侧终端再去查询，会发现快照读和当前读都能查询到最新的修改；\n\n由此可见\n\n快照读的快照是第一次 select 查询的时候生成的\n当前读能绕过快照查看到最新数据！\n\n4.4 RR 和 RC 的区别\n正是 Read View 生成时机的不同，从而造成 RC,RR 级别下快照读的结果的不同\n在 RR 级别下的某个事务的对某条记录的第一次快照读会创建一个快照及 Read View, 将当前系统活 跃的其他事务记录起来\n此后在调用快照读的时候，还是使用的是同一个 Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个 Read View，所以对之后的修改不可见；\n即 RR 级别下，快照读生成 Read View 时，Read View 会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于 Read View 创建的事务所做的修改均是可见；\n而在 RC 级别下的，事务中，每次快照读都会  新生成一个快照  和 Read View, 这就是我们在 RC 级别下的事务中可以看到别的事务提交的更新的原因；\n总之在 RC 隔离级别下，是每个快照读都会生成并获取最新的 Read View；而在 RR 隔离级别下，则是同一个事务中的第一个快照读才会创建 Read View，之后的快照读获取的都是同一个 Read View。 \n正是 RC 每次快照读，都会形成 Read View，所以，RC 才会有不可重复读问题。\n\nThe end关于 MySQL 事务的内容到这里基本就 OVER 了，内容多多，也需要多多理解和复习！\n可以深入阅读如下文章https://blog.csdn.net/SnailMann/article/details/94724197https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.htmlhttps://blog.csdn.net/chenghan_yang/article/details/97630626\n\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【Sqlite3】maraidb 和 sqlite3 部分命令操作区别","url":"/posts/2259981507/","content":"maraidb 和 sqlite3 部分命令操作区别记录\n\n\n1. 安装 sqlite3在实现我的视频点播系统项目时，我尝试封装了两种数据库的调用逻辑\n\nmysql（maraidb）\nsqlite3\n\n这里封装 sqlite3 的原因是，sqlite3 主要针对的就是  嵌入式  数据库，其性能可能不如 mysql，但是就好在可以  带着走。安装也很方便，内存占用相对于 mariadb 来说也降低了很多。\n\n教程：安装 maraidb\n\n在上面的博客中，安装 maraidb 需要很多步骤，还需要修改  配置文件  中的默认字符集为 UTF8。\n而安装 sqlite3 就要多方便有方便了，而且 sqlite3 默认采用的就是 uft8 字符集，完全不需要修改！\nsudo yum install sqlite-devel\n\n就这一行命令就搞定了！\nsqlite3 --version # 查看当前安装的版本\n\n安装完成后，可以看看 sqlite3 的版本（如果没有安装，执行这个命令会告知 command not found）\n[root@1c2261732150:~]# sqlite3 --version3.26.0 2018-12-01 12:34:55 bf8c1b2b7a5960c282e543b9c293686dccff272512d08865f4600fb58238alt1\n\n安装新版本 sqlite3默认安装的版本可以看到已经是 2018 年的老东西了，可以尝试用下面的办法安装最新版本，需要修改以下命令中的链接和文件名，最新版本的 sqlite 去官网上找 https://www.sqlite.org/download.html\nsudo yum remove sqlite-develwget https://www.sqlite.org/2019/sqlite-autoconf-3280000.tar.gztar -xzf sqlite-autoconf-3280000.tar.gzcd sqlite-autoconf-3280000./configuremakesudo make install\n\n选择官网上名字为 sqlite-autoconf 的 tar.gz 下载就行了。请注意安装之前一定要卸载原有的 sqlite。\n请注意，如果你需要用 python 操作 sqlite，在更新 sqlite 版本后需要重新编译安装 python。\n依照如上命令，我成功更新 sqlite 到 2023 年的最新版本了\n# sqlite3 --version3.44.0 2023-11-01 11:23:50 17129ba1ff7f0daf37100ee82d507aef7827cf38de1866e2633096ae6ad81301 (64-bit)\n\n\n更新参考博客 https://number1.co.za/upgrading-sqlite-on-centos-to-3-8-3-or-later/\n\n2. 基本操作的区别  如下列出一些基本操作在 mariadb 命令行中，和在 sqlite3 命令行中的区别\n为了方便，注释中 m 指代 mysql，s 指代 sqlite3\nshow databases; -- 查看所有数据库 mariadb.database       -- 查看当前数据库 sqlite3use db_name;      -- 进入数据库 m.open db_name.db; -- 提供.db 文件的路径，进入数据库 sshow tables;    -- 查看数据库中所有表 m.tables         -- 查看数据库中所有表 squit  -- 退出数据库命令行 m.quit -- 退出数据库命令行 s\n\n这便是基础操作的一些区别，更深入的操作我暂时还没有学到。\n其中进入数据库的操作就能看出来 sqlite 的特性，只要有这个 .db 文件，你就可以很轻松的在另外一个主机上恢复之前的数据（或者进行备份），这也是  带着走  的体现。\n3. 创建表mysql 和 sqlite3 所支持的数据类型也有区别\n\n\n\nsqlite3 数据类型\n描述\n\n\n\nNULL\n值是一个 NULL 值。\n\n\nINTEGER\n值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。\n\n\nREAL\n值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。\n\n\nTEXT\n值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。\n\n\nBLOB\n值是一个 blob 数据，完全根据它的输入存储。\n\n\n在 sqlite3 中，没有 varchar 类型。但我们依旧可以使用 TEST(8) 来限制字符串类型的长度\n以我的视频点播项目所用数据库为例，以下是 mariadb 创建数据表的 sql 语句\ncreate table tb_video(    id VARCHAR(8) NOT NULL DEFAULT (substring(UUID(), 1, 8)) comment &#x27; 视频 id&#x27;,    name VARCHAR(50) comment &#x27; 视频标题 &#x27;,    info text comment &#x27; 视频简介 &#x27;,    video VARCHAR(255) comment &#x27; 视频链接 &#x27;,    cover VARCHAR(255) comment &#x27; 视频封面链接 &#x27;,    insert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP comment &#x27; 视频创建时间 &#x27;);\n\n在这里我采用了 mariadb 自带的 uuid 函数来生成 uuid 字符串，并使用 substring 函数截取了 uuid 前 8 位的内容，作为视频的唯一 id\n而如果想让 mariadb 来保证 id 字段唯一，可以使用如下命令进行约束\ncreate table tb_video(    id VARCHAR(8) NOT NULL DEFAULT (substring(UUID(), 1, 8)) comment &#x27; 视频 id&#x27;,    name VARCHAR(50) comment &#x27; 视频标题 &#x27;,    info text comment &#x27; 视频简介 &#x27;,    video VARCHAR(255) comment &#x27; 视频链接 &#x27;,    cover VARCHAR(255) comment &#x27; 视频封面链接 &#x27;,    insert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP comment &#x27; 视频创建时间 &#x27;,    UNIQUE (id));\n\n\n以下是 sqlite3 的操作，sqlite3 中并不支持 comment 对字段进行注释。\n这里要想让 id 字段唯一，直接在字段类型后面跟着 UNIQUE 就可以了\n-- sqlite3 中不支持 uuid 函数，所以需要用 randomblob 函数生成一个随机数，再用 hex 转成 16 进制作为视频的 id-- sqlite3 默认的时间是 utc，所以需要用 datetime 函数将其转化为东八区的时间CREATE TABLE IF NOT EXISTS tb_video(    id TEXT(8) UNIQUE NOT NULL DEFAULT (lower((hex(randomblob(4))))),    name TEXT NOT NULL,    info TEXT,    video TEXT NOT NULL,    cover TEXT NOT NULL,    insert_time TIMESTAMP DEFAULT (datetime(&#x27;now&#x27;, &#x27;+8 hours&#x27;)));\n\n查看表结构  在 msyql 中可以用 desc 快捷查看表结构，但是 sqlite3 中不支持此功能。\n在 sqlite3 数据库中用如下语句查看数据库中的建表语句，依此可以看到表结构。\nSELECT sql FROM sqlite_master WHERE type=&quot;table&quot;;\n\n4. 插入删除数据  在我项目所用字段中，二者插入 &#x2F; 删除数据的操作完全相同，这里就不记录了\n-- 删除表drop table tb_video;-- 插入数据insert into tb_video (name, info, video, cover) values (&#x27; 名字 1&#x27;,&#x27; 说明信息 1&#x27;,&#x27;test1&#x27;,&#x27;testc1&#x27;);-- 查看所有字段select * from tb_video;select * from tb_video where id=&#x27;45f78a68&#x27;; -- 删除数据delete from tb_video where id = &#x27;D81382A8&#x27;;\n\n5. 使用 cpp 操作的时候\nmysql 必须要进行 init，此时就需要指定目标数据库了\n而 sqlite3 并不需要进行数据库的连接操作，我们就可以实现在 cpp 中进行数据库的创建、数据表的创建等操作。\n\nc 语言操作 sqlite3 的方法，可以查看  菜鸟教程。上面的用例很详细（虽然没有写注释，但还是能看懂的）我就不写博客了~\n5.1 查询时的回调  这里只对 select 命令操作进行说明，在 sqlite3 中，所有命令都是用下面这个函数来执行的\nSQLITE_API int sqlite3_exec(  sqlite3*,                                  /* An open database */  const char *sql,                           /* SQL to be evaluated */  int (*callback)(void*,int,char**,char**),  /* Callback function */  void *,                                    /* 1st argument to callback */  char **errmsg                              /* Error msg written here */);\n\n如果你执行的是插入、更新等等 sql 语句，sqlite_callback函数不会被调用（我测试过了）。目前我只发现 select 语句会调用这个 callback 函数。\n比如我的数据库 tb_video 中有如下两行数据\ndf65c8c5| 名字 1| 说明信息 1|test1|testc1|2023-05-04 16:57:1080cd3f51| 名字 1| 说明信息 1|test1|testc1|2023-05-04 19:02:05\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt;// 每当有结果返回的时候，用这个函数来处理结果// 第一个参数可以从 sqlite3_exec 中主动传入// argc 是结果的行数（二维数组行数）// argv 是存放数据的二维数组// azColName 是存放字段名称的二维数组static int callback(void *NotUsed, int argc, char **argv, char **azColName)&#123;\tint i;\tfor (i = 0; i &lt; argc; i++)\t&#123;\t\tprintf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;);\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;// sqlite3 数据库打开测试void SqliteTest()&#123;\tsqlite3 *db;// 数据库指针\tchar *zErrMsg = 0;\tstd::string sql;\tint ret;\t// 打开数据库文件\tif (sqlite3_open(&quot;test.db&quot;, &amp;db))\t&#123;\t\tfprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db));\t\texit(0);\t&#125;\telse\t&#123;\t\tfprintf(stderr, &quot;Opened database successfully\\n&quot;);\t&#125;\tsql = &quot;select * from tb_video;&quot;;\t// 执行 sql 语句\tret = sqlite3_exec(db, sql.c_str(), callback, 0, &amp;zErrMsg);\tif (ret != SQLITE_OK)\t&#123;\t\tfprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg);\t\tsqlite3_free(zErrMsg);\t&#125;\telse\t&#123;\t\tfprintf(stdout, &quot;SQL successfully\\n&quot;);\t&#125;\tsqlite3_close(db);&#125;\n\n用这个函数来查询，会打印如下的结果。从这个结果中，就能推测出 callback 函数 4 个参数分别的作用，已经在代码的注释中说明了。\nOpened database successfullyid = df65c8c5name = 名字 1info = 说明信息 1video = test1cover = testc1insert_time = 2023-05-04 16:57:10id = 80cd3f51name = 名字 1info = 说明信息 1video = test1cover = testc1insert_time = 2023-05-04 19:02:05\n\n其中，第四个参数是给 callback 函数传入的第一个入参。\n5.2 通过回调插入数据到 Json 字符串  我的视频点播项目在查询的时候，需要将结果保存为 json 字符串，如果使用 mysql 的 c++ 操作，就可以直接在遍历结果的二维数组时，将结果放入到 Json::Value 中\n// 查询所有 - 输出所有视频信息（视频列表）bool SelectAll(Json::Value *video_s)&#123;    #define SELET_ALL &quot;select * from %s;&quot;    std::string sql;    sql.resize(512);    sprintf((char*)sql.c_str(),SELET_ALL,_video_table.c_str());    // 这里加锁是为了保证结果集能被正常报错（并不是防止修改原子性问题,mysql 本身就已经维护了原子性）    // 下方执行语句后，如果不保存结果集 而又执行一次搜索语句，之前搜索的结果就会丢失    // 加锁是为了保证同一时间只有一个执行流在进行查询操作，避免结果集丢失    _mutex.lock();    // 语句执行失败了    if (!MysqlQuery(_mysql, sql)) &#123;        _mutex.unlock();        _log.error(&quot;Video SelectAll&quot;,&quot;query failed&quot;);        return false;    &#125;    // 保存结果集到本地    MYSQL_RES *res = mysql_store_result(_mysql);    if (res == nullptr) &#123;        _mutex.unlock();        _log.error(&quot;Video SelectAll&quot;,&quot;mysql store result failed&quot;);        return false;    &#125;    // 遍历结果集，存到 json 中    int num_rows = mysql_num_rows(res);// 获取结果集的行数    for (int i = 0; i &lt; num_rows; i++) &#123;        MYSQL_ROW row = mysql_fetch_row(res);// 获取每一行的列数        Json::Value video;        video[&quot;id&quot;] = row[0];        video[&quot;name&quot;] = row[1];        video[&quot;info&quot;] = row[2];        video[&quot;video&quot;] = row[3];        video[&quot;cover&quot;] = row[4];        video[&quot;insert_time&quot;] = row[5]; //mysql 中存放的就是可读时间 （其实存时间戳更好）        //json list        video_s-&gt;append(video);    &#125;    mysql_free_result(res);// 释放结果集    _mutex.unlock();    _log.info(&quot;Video SelectAll&quot;,&quot;select all finished&quot;);    return true;&#125;\n\n而在 sqlite3 中，就需要使用 callback 函数的第一个参数来进行 json 字符串的保存；这里因为 sqlite3 会给我们返回字段名字，我们就可以直接用字段明作为 json 的字段名，将参数作为 json 字段的对应参数。更省事了！\nstatic int callback(void *json_videos, int argc, char **argv, char **azColName)&#123;\tJson::Value* video_s =  (Json::Value*)json_videos;// 转为原本的类型\tJson::Value video;// 单个视频\tfor (int i = 0; i &lt; argc; i++)\t&#123;\t\tvideo[azColName[i]] = argv[i] ? argv[i] : &quot;NULL&quot;;// 存入数据\t\tprintf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;);\t&#125;\tprintf(&quot;\\n&quot;);\tvideo_s-&gt;append(video);// 插入到 json 数组中\treturn 0;&#125;\n\n在主函数中，创建一个 Json::Value 对象，将其强转为 void* 的指针，传给 callback 函数\n// 查询Json::Value videos;sql = &quot;select * from tb_video;&quot;;// 执行 sql 语句ret = sqlite3_exec(db, sql.c_str(), callback, (void*)&amp;videos, &amp;zErrMsg);if (ret != SQLITE_OK)&#123;\tfprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg);\tsqlite3_free(zErrMsg);&#125;else&#123;\tfprintf(stdout, &quot;Table created successfully\\n&quot;);&#125;sqlite3_close(db);std::string json_str;vod::JsonUtil::Serialize(videos,&amp;json_str);std::cout &lt;&lt; json_str &lt;&lt; std::endl;\n\n编译执行，最终打印的 json 字符串如下（完整代码见 Github）\n[        &#123;                &quot;cover&quot; : &quot;testc1&quot;,                &quot;id&quot; : &quot;df65c8c5&quot;,                &quot;info&quot; : &quot;\\u8bf4\\u660e\\u4fe1\\u606f1&quot;,                &quot;insert_time&quot; : &quot;2023-05-04 16:57:10&quot;,                &quot;name&quot; : &quot;\\u540d\\u5b571&quot;,                &quot;video&quot; : &quot;test1&quot;        &#125;,        &#123;                &quot;cover&quot; : &quot;testc1&quot;,                &quot;id&quot; : &quot;80cd3f51&quot;,                &quot;info&quot; : &quot;\\u8bf4\\u660e\\u4fe1\\u606f1&quot;,                &quot;insert_time&quot; : &quot;2023-05-04 19:02:05&quot;,                &quot;name&quot; : &quot;\\u540d\\u5b571&quot;,                &quot;video&quot; : &quot;test1&quot;        &#125;]\n\n5.3 对表的查询  除了使用 sqlite3_exec 针对数据库进行操作，还可以用下面这个函数，对指定的表进行查询\nint sqlite3_get_table(  sqlite3* db,              /* 数据库连接 */  const char *zSql,         /* 查询语句 */  char ***pazResult,        /* 查询结果 */  int *pnRow,               /* 查询结果的行数 */  int *pnColumn,            /* 查询结果的列数 */  char **pzErrmsg           /* 错误信息 */);\n\n参数说明如下，这里就比较类似 mysql 的查询函数了，其会给我们返回结果集，以及结果的行数、列数，让我们自己遍历进行操作。\n\ndb: 数据库连接对象，是已经打开的数据库连接。\nzSql: 执行的 SQL 查询语句。\npazResult: 一个 char 类型的  指针数组（二维，每一行是一个指针，指向一个字符串），用于存储查询结果。每个元素都指向一个表示每行数据的字符串数组。最后一个元素为 NULL。\npnRow: 用于存储查询结果的行数。\npnColumn: 用于存储查询结果的列数。\npzErrmsg: 用于存储错误信息。\n\nsqlite3_get_table 函数执行查询语句时，结果集中的每个单元格都被解释为一个字符串。查询结果将被存储在指针数组 pazResult 中，每行数据占用一个字符串数组（除了最后一个元素为 NULL）。表格的第一行包含列名，后面的每行则为查询结果中的一条记录。\nsqlite3_get_table 函数的作用是执行一条 SQL 查询语句，并将其结果存储在一个表格中，以便后续处理和分析。\n调用完毕这个函数，处理完结果集后，需要调用如下函数  释放结果集。\nchar **pazResult; /* 二维指针数组，存储查询结果 */int nRow = 0, nColumn = 0;/* 获得查询结果的行数和列数 */sqlite3_get_table(db, &quot;SELECT * FROM tb_video;&quot;, &amp;pazResult, &amp;nRow, &amp;nColumn, NULL);// 遍历处理结果集// ....sqlite3_free_table(pazResult);// 处理完毕结果集后释放\n\n\n5.3.1 错误示例  如下是一个示例的  错误  代码！\nchar **pazResult; /* 二维指针数组，存储查询结果 *//* 获得查询结果的行数和列数 */int nRow = 0, nColumn = 0,index=0;sqlite3_get_table(db, &quot;SELECT * FROM tb_video;&quot;, &amp;pazResult, &amp;nRow, &amp;nColumn, NULL);std::cout &lt;&lt; nRow &lt;&lt; &quot; &quot; &lt;&lt;  nColumn &lt;&lt; std::endl;for (int i = 0; i &lt; nRow; i++)&#123;\tfor (int j = 0; j &lt; nColumn; j++)\t&#123;\t\tprintf(&quot;%-8s : %-8s\\n&quot;, pazResult[j],pazResult[i][j]);\t&#125;   &#125;sqlite3_free_table(pazResult);\n\n编译不会出错，但是执行的时候，直接会出现段错误\nOpened database successfully2 6Segmentation fault\n\n这是因为我们的 pazResult 只是一个二级指针，我们并没有给他初始化为多少行多少列的模式，导致最终 ++ 的时候，会出现访问错位的情况。\n如果改成下面这样的打印\ncout &lt;&lt;  pazResult[j] &lt;&lt; endl;cout &lt;&lt; &quot;--&quot; &lt;&lt; endl;cout &lt;&lt; pazResult[i][j] &lt;&lt; endl;cout &lt;&lt; &quot;---&quot; &lt;&lt; endl;\n\n打印的结果就是这样的，合计是在遍历每一个字符串！\nid--i---name--d---info-----video-----cover-----insert_time--后面重复的就省略掉了\n\n为什么不行呢？这是因为 pazResult 实际上的结构是这样的\nidnameinfovideocoverinsert_timedf65c8c5名字 1说明信息 1test1testc12023-05-04 16:57:10\n\n使用 pazResult[i][j] 进行访问：\n\n当 i 是 0 的时候，访问的是 id 字符串\n此时 j 就变成 id 字符串里面的下标了\n而 nColumn 远大于 id 字符串的长度（id 只有两个字符，而在我这里nColumn=6）\n所以就出现了段错误 Segmentation fault！\n\n我还是学艺不精呀！🤣\n\n5.3.2 正确操作  正确的办法应该是这样的\nJson::Value videos;char **pazResult; /* 二维指针数组，存储查询结果 *//* 获得查询结果的行数和列数 */int nRow = 0, nColumn = 0,index=0;sqlite3_get_table(db, &quot;SELECT * FROM tb_video;&quot;, &amp;pazResult, &amp;nRow, &amp;nColumn, NULL);std::cout &lt;&lt; nRow &lt;&lt;&quot; &quot; &lt;&lt;  nColumn &lt;&lt; std::endl;index = nColumn;// 从第二列开始，跳过第一行（第一行都是字段名）for (int i = 0; i &lt; nRow; i++)&#123;\tfor (int j = 0; j &lt; nColumn; j++)\t&#123;            // 前 nColumn 个数据都是字段名，所以可以用 pazResult[j] 来打印\t\tprintf(&quot;%-8s : %-8s\\n&quot;, pazResult[j],pazResult[index]);\t\tindex++;\t&#125;&#125;sqlite3_free_table(pazResult);\n\n成功打印出了数据库中两行的数据\nOpened database successfully2 6id       : df65c8c5name     : 名字1 info     : 说明信息1video    : test1   cover    : testc1  insert_time : 2023-05-04 16:57:10id       : da6d27bename     : 名字2 info     : 说明信息2video    : test2   cover    : testc2  insert_time : 2023-05-04 19:59:38\n\n和从数据库命令行中读取到的结果相同\nsqlite&gt; select * from tb_video;df65c8c5| 名字 1| 说明信息 1|test1|testc1|2023-05-04 16:57:10da6d27be| 名字 2| 说明信息 2|test2|testc2|2023-05-04 19:59:38\n\n最终的完整代码如下\nvoid SqliteTest()&#123;\tsqlite3 *db; // 数据库指针\tchar *zErrMsg = 0;\tstd::string sql;\tint ret;\t// 打开数据库文件\tif (sqlite3_open(&quot;test.db&quot;, &amp;db))\t&#123;\t\tfprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db));\t\texit(0);\t&#125;\telse\t&#123;\t\tfprintf(stderr, &quot;Opened database successfully\\n&quot;);\t&#125;\t// 查询\tJson::Value videos;\tchar **pazResult; /* 二维指针数组，存储查询结果 */\t/* 获得查询结果的行数和列数 */\tint nRow = 0, nColumn = 0;\tsqlite3_get_table(db, &quot;SELECT * FROM tb_video;&quot;, &amp;pazResult, &amp;nRow, &amp;nColumn, NULL);\tstd::cout &lt;&lt; nRow &lt;&lt;&quot; &quot; &lt;&lt;  nColumn &lt;&lt; std::endl;\tint index = nColumn;// 从第二列开始，跳过第一行（第一行都是字段名）\tfor (int i = 0; i &lt; nRow; i++)\t&#123;\t\tJson::Value video;\t\tfor (int j = 0; j &lt; nColumn; j++)\t\t&#123;\t\t\t// 前 nColumn 个数据都是字段名，所以可以用 pazResult[j] 来打印\t\t\t// printf(&quot;%-8s : %-8s\\n&quot;, pazResult[j],pazResult[index]);\t\t\tvideo[pazResult[j]] = pazResult[index] ?pazResult[index] : &quot;NULL&quot;; // 存入数据\t\t\tindex++;\t\t&#125;\t\t// json list\t\tvideos.append(video);\t&#125;\tstd::string json_str;\tvod::JsonUtil::Serialize(videos, &amp;json_str);\tstd::cout &lt;&lt; json_str &lt;&lt; std::endl;\t\tsqlite3_free_table(pazResult);\tsqlite3_close(db);&#125;\n\n完整输出如下，json 字符串内的数据是正确的！\nOpened database successfully2 6[        &#123;                &quot;cover&quot; : &quot;testc1&quot;,                &quot;id&quot; : &quot;df65c8c5&quot;,                &quot;info&quot; : &quot;\\u8bf4\\u660e\\u4fe1\\u606f1&quot;,                &quot;insert_time&quot; : &quot;2023-05-04 16:57:10&quot;,                &quot;name&quot; : &quot;\\u540d\\u5b571&quot;,                &quot;video&quot; : &quot;test1&quot;        &#125;,        &#123;                &quot;cover&quot; : &quot;testc2&quot;,                &quot;id&quot; : &quot;da6d27be&quot;,                &quot;info&quot; : &quot;\\u8bf4\\u660e\\u4fe1\\u606f2&quot;,                &quot;insert_time&quot; : &quot;2023-05-04 19:59:38&quot;,                &quot;name&quot; : &quot;\\u540d\\u5b572&quot;,                &quot;video&quot; : &quot;test2&quot;        &#125;]\n\nsqlite3 在返回数据的时候也会给我们返回表中的字段名。我们可以将 json 字段的 key 设置成字段名，这样就实现了字段的统一\n\n个人认为，为了避免出现同一 value 而 key 不同的情况，最好是将应用层和数据库中的字段统一。否则出现二义性问题不好排查。特别是当一个表中的字段较多的时候。\n\n结语  需要注意的是，二者只是适用范围的区别，并没有孰强孰弱的差距。\n以下是 gpt3.5 对二者区别的总结：\n\nSQLite3 和 MySQL 都是流行的关系型数据库管理系统，但它们有不同的用途和设计重点。\n\nSQLite3 的主要目标是作为嵌入式数据库使用，包括在移动设备和桌面应用程序中，也可以作为轻量级数据库使用。相比之下，MySQL 的主要重点是支持大型企业级应用程序和高负载服务器。\nSQLite3 是一个服务器不需要客户端的完全独立的自包含数据库，MySQL 是一个客户端 &#x2F; 服务器模型的数据库，需要一个专用的服务器端。\nSQLite3 支持 SQL-92 标准的基本功能，而 MySQL 支持更广泛的 SQL 标准以及许多扩展功能。\nSQLite3 的数据存储在单个文件中，而 MySQL 的数据通常存储在多个文件或分布式系统中。\n\n\n就记录这么多吧！\n","categories":["学习sql"],"tags":["Linux","mysql","sqlite3"]},{"title":"【MySQL】数据类型","url":"/posts/3544156851/","content":"mysql 的数据类型老多了，单开一篇博客记录一下吧\n\n\nmysql  Ver 15.1 Distrib 10.3.28-MariaDB, for Linux (x86_64) using readline 5.1\n\n1. 数值类型\n\n\n数据类型\n说明\n字节\n\n\n\nBIT(M)\n位类型，M 指定位数，默认位 1，可 1-64\n\n\n\nTINYINT [UNSIGNED]\n有符号-127 ~ 128；无符号 0 ~ 255\n1\n\n\nBOOL\n用 0 和 1 表示真假（实际为tinyint(1))\n1\n\n\nSMALLINT [UNSIGNED]\n有符号-2^15 ~ 2^15 -1; 无符号2^16 -1\n2\n\n\nMEDIUMINT [UNSIGNED]\n有符号-2^23 ~2^23 -1; 无符号 2^24 -1\n3\n\n\nINT [UNSIGNED]\n有符号-2^31 ~ 2^31 -1; 无符号2^32 -1\n4\n\n\nBIGINT [UNSIGNED]\n有符号-2^63 ~ 2^63 -1; 无符号2^64 -1\n8\n\n\nFLOAT [(M,D)] [UNSIGNED]\nM 指定显示长度，D 指定小数位数\n4\n\n\nDOUBLE [(M,D)] [UNSIGNED]\n同上，精度更高\n8\n\n\nDECIMAL (M,D) [UNSIGNED]\n同上，M 和 D 必须给出\n\n\n\n1.1 插入超范围数据  和编译器中会对数据进行  截断  不同，mysql 中的数据范围必须严格遵守其定义的范围\nMariaDB [hello]&gt; create table test(    -&gt; id TINYINT UNSIGNED);Query OK, 0 rows affected (0.021 sec)\n\n这里我创建了一个使用 TINYINT 类型的表，向里面插入如下的正确数据\nMariaDB [hello]&gt; insert into test value (3);Query OK, 1 row affected (0.040 sec)MariaDB [hello]&gt; insert into test value (0);Query OK, 1 row affected (0.040 sec)MariaDB [hello]&gt; insert into test value (10);Query OK, 1 row affected (0.007 sec)\n\n再尝试插入负数和超过范围的数\nMariaDB [hello]&gt; insert into test value (-1);ERROR 1264 (22003): Out of range value for column &#x27;id&#x27; at row 1MariaDB [hello]&gt; insert into test value (300);ERROR 1264 (22003): Out of range value for column &#x27;id&#x27; at row 1MariaDB [hello]&gt; \n\n可以看到，mysql 阻止了我们的插入。\n1.2 约束  这就是 mysql 对应用层的约束，你必须遵守先前对表中对字段类型的定义和范围的要求，才能将数据插入到数据库中。\n这样就保证了，我们在 mysql 中看到的数据，是能保证范围正确的！\n并不会出现这个数据是因为截断而被存入的缺省值，从而造成的非精确问题。\n\n当然，你要是在代码中强转数据插入，mysql 肯定看不出来。但那样就是程序云的锅了，和 mysql 本身无关！\n\n注意，当一个无符号数据无法被 int 类型存放的时候，我们不要用无符号 int 来存放这个数据，而应该使用 bigint。这样才能保证数据一定能被存入。\n而我们要存放的数据没有负数的时候（比如年龄、当前时间戳）则建议使用无符号数来存放。因为这样能显式告知其他需要操作这个数据库的人，当前字段是没有负数的。\n1.3 BIT 类型BIT 类型就是用比特位来表示一些 0&#x2F;1 的信息\n\n用户在线状态\n用户性别（不考虑不选择的情况下）\n用户是否已经验证邮箱\n用户是否绑定了手机\n用户一系列权限位\n…\n\n这些数据都是只有真假区分的，使用 bit 来保存的时候，就能节省一定的空间。\n1.4 浮点数FLOAT [(M,D)] [UNSIGNED]\n\n浮点数这里的 M 和 D 是什么意思呢？\nalter table test add ft float(4,2) after id;\n\n这里我先往之前已有的 test 表中插入一个浮点数，来测试一下情况\nMariaDB [hello]&gt; desc test;+-------+---------------------+------+-----+---------+-------+| Field | Type                | Null | Key | Default | Extra |+-------+---------------------+------+-----+---------+-------+| id    | tinyint(3) unsigned | YES  |     | NULL    |       || ft    | float(4,2)          | YES  |     | NULL    |       |+-------+---------------------+------+-----+---------+-------+2 rows in set (0.002 sec)\n\n当插入一个整数时，会自动后补 0\nMariaDB [hello]&gt; insert into test values (1,99);Query OK, 1 row affected (0.007 sec)MariaDB [hello]&gt; select * from test;+------+-------+| id   | ft    |+------+-------+|    3 |  NULL ||    0 |  NULL ||   10 |  NULL ||    1 | 99.00 |+------+-------+4 rows in set (0.000 sec)\n\n插入负数也是没问题的\nMariaDB [hello]&gt; insert into test values (1,-99.3);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; select * from test;+------+--------+| id   | ft     |+------+--------+|    3 |   NULL ||    0 |   NULL ||   10 |   NULL ||    1 |  99.00 ||    1 | -99.30 |+------+--------+5 rows in set (0.001 sec)\n\n但当你想插入如下数字的时候，就开始报错了\nMariaDB [hello]&gt; insert into test values (1,-99.99542);ERROR 1264 (22003): Out of range value for column &#x27;ft&#x27; at row 1MariaDB [hello]&gt; insert into test values (1,100.99542);ERROR 1264 (22003): Out of range value for column &#x27;ft&#x27; at row 1MariaDB [hello]&gt; insert into test values (1,100.9942);ERROR 1264 (22003): Out of range value for column &#x27;ft&#x27; at row 1MariaDB [hello]&gt; insert into test values (1,100.99);ERROR 1264 (22003): Out of range value for column &#x27;ft&#x27; at row 1\n\n简单总结\n\n浮点数的 M 代表浮点数总共的位数（包括整数部分和小数部分）\n后续的 D 代表小数点之后的位数\n如果 D 为 2，则可以插入0.994，不可以插入0.995（临界数据只能四舍，不支持五入，因为五入了之后就相当于超限了）\n插入 30.945 会被四舍五入为30.95\nfloat(4,2)的范围就是 -99.99 ~ 99.99; 如果是无符号，则为 0 ~ 99.99\n\nMariaDB [hello]&gt; insert into test values (1,30.945);Query OK, 1 row affected (0.003 sec)MariaDB [hello]&gt; select * from test;+------+--------+| id   | ft     |+------+--------+|    3 |   NULL ||    0 |   NULL ||   10 |   NULL ||    1 |  99.00 ||    1 | -99.30 ||    1 | -99.34 ||    1 |  30.95 |+------+--------+7 rows in set (0.000 sec)\n\n1.5 decimalDECIMAL (M,D) [UNSIGNED]\n\n这个数据类型和 float 的区别也是精度上的\n\nfloat 最大精度约 7 位\ndecimal 最大 M 为 65，D 为 30；省略时 D 默认为 0，M 默认为 10\n\n在我当前的 mariadb 中进行测试，同样是插入10.123456789，float 显示的是10.12345695，decimal 显示的是10.12345679 \n很明显，decimal 的精准度更高，正确对 10.123456789 进行四舍五入了。而 float 就把数据给搞坏了。\nMariaDB [hello]&gt; drop table test;Query OK, 0 rows affected (0.046 sec)MariaDB [hello]&gt; create table test (    -&gt; f1 float(10,8),    -&gt; f2 decimal(10,8));Query OK, 0 rows affected (0.058 sec)MariaDB [hello]&gt; insert into test values (10.123456789,10.123456789);Query OK, 1 row affected, 1 warning (0.010 sec)MariaDB [hello]&gt; select * from test;+-------------+-------------+| f1          | f2          |+-------------+-------------+| 10.12345695 | 10.12345679 |+-------------+-------------+1 row in set (0.001 sec)\n\n所以，如果需要存储小数，最好使用 decimal\n1.6 浮点数取整的几种方式  这个和 mysql 无关，只是记录一下\n\n零向取整：丢弃小数部分\n向上取整：2.1 视作 3，-2.5 视作 -2（2.0 不变）\n向下取整：2.1 视作 2，-2.5 视作 -3（2.0 不变）\n四舍五入（刚刚的测试能看到，mysql 采用的是这个）\n\n2. 文本、二进制类型\n\n\n数据类型\n说明\n\n\n\nCHAR (SIZE)\n定长字符串，最大 255\n\n\nVARCHAR (SIZE)\n可变长度字符串，最大长度 65535\n\n\nBLOB\n二进制数据\n\n\nTEXT\n大文本，支持全文索引\n\n\nTEXT 和 VARCHAR 都是支持全文索引的！\nMariaDB [hello_mysql]&gt; CREATE TABLE articles (    -&gt;     id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,    -&gt;     title VARCHAR(200),    -&gt;     body TEXT DEFAULT &#x27;&#x27;,    -&gt;     FULLTEXT (title,body)     -&gt; )engine=MyISAM;Query OK, 0 rows affected (0.003 sec)\n2.1 char在 mysql 中，size 并不是字节，而是字符数量。\nchar(2)\n\n它可以存放两个英文字母，两个符号，也可以是两个中文。但实际上两个中文占用的字节数并非 2。\n比如下方 c1 和 c2 分别是char(3) varchar(3)，可以插入 3 字的中文\nMariaDB [hello]&gt; select * from test;+---------+-----------+| c1      | c2        |+---------+-----------+| 1ca     | 23a       || 123     | 234       || 3       | 23        || 你好   | 我在呢    |+---------+-----------+4 rows in set (0.001 sec)\n\n超过 2 个字符的数据会被拒绝插入；\nMariaDB [hello]&gt; insert into test values (&#x27;1ca&#x27;,&#x27;23a3&#x27;);ERROR 1406 (22001): Data too long for column &#x27;c2&#x27; at row 1\n\n2.2 char 和 varchar 的区别  表中提到，这两个除了最大长度的限制，还有一个区别是  定长 / 变长\n简单理解为，char 是 C 语言中的 char* 类型的字符串，如果定义为 CHAR(3)，就无论如何都会开 3 个 字符  的空间来存放数据，不管你的字符串是 1 个字符还是 2 个字符；\n而 varchar 是 C++ 的 string，它可以动态开辟长度，如果 VARCHAR(20)，当字符串只有 3 个的时候，只会占用 3 字节的空间。既然是 string，那就需要有额外空间来存放字符串的长度。在 mysql 中，varchar 会采用1-3 字节的空间来存放 VARCHAR 数据类型的当前长度。\n\n当我需要一个长度固定的 8 位 uuid，可以选择 char 来节省空间（不需要额外空间存放长度）\n当我需要存放名字、地址等信息的时候，选择 varchar（但要保证长度不超过 varchar 的上限）\n\n3. 时间类型\n\n\n数据类型\n说明\n\n\n\nDATE\nyyyy-mm-dd\n\n\nDATETIME\nyyyy-mm-dd hh:mm:ss\n\n\nTIMESTAMP\n时间戳\n\n\n这个应该很好看明白，时间类型可以很方便的表示一些时间\n\n数据更新时间\n数据插入的时间\n当前数据关联的操作时间\n…\n\n3.1 示例  在我的视频点播项目中，就是用了如下语句设置了一个 TIMESTAMP 字段，做为视频的上传时间\ninsert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP comment &#x27; 视频创建时间 &#x27;,\n\n但我发现，即便是用了TIMESTAMP，查询的时候依旧显示的是可读时间\n\n需要使用如下的语句进行查询，才会显示  时间戳  的数字\nSELECT UNIX_TIMESTAMP(insert_time) AS timestamp FROM tb_video;\n\n效果如下\nMariaDB [vod_system]&gt; SELECT UNIX_TIMESTAMP(insert_time) AS timestamp FROM tb_video;+------------+| timestamp  |+------------+| 1683213543 || 1683256245 |+------------+2 rows in set (0.001 sec)\n\n一般情况下，保存时间戳  是更好的选择，因为不管你是在那个时区，时间戳都是统一的。我们可以在应用层将时间戳通过函数（一般都有专门的库函数来转化）成对应时区的可读时间。\n但如果你能  特别确定  你的应用只会在当前时区使用，比如我写了一个数据纯本地化的应用，在哪里部署就使用那个地方的时间。这时候就可以选择使用 date 类型来存放 str 字符串，省去了在应用层重新对时间操作的繁琐。\n而且，像 python 这样的语言，也是支持将特定格式的 str 时间转回时间戳的。\n3.2 timestamp 和 datetime 的区别  在 MySQL 中，TIMESTAMP类型和 DATETIME 类型都用于存储日期和时间信息，但它们之间有几个重要的区别：\n\n存储范围：\nTIMESTAMP类型：使用 4 个字节进行存储，可以表示的范围为 1970-01-01 00:00:01 到2038-01-19 03:14:07。因为使用较少的字节，所以 TIMESTAMP 类型在存储上更加节省空间。\nDATETIME类型：使用 8 个字节进行存储，可以表示的范围为 1000-01-01 00:00:00 到9999-12-31 23:59:59。由于使用更多的字节，DATETIME类型可以表示的时间范围更广。\n\n\n自动更新功能：\nTIMESTAMP类型：可以设置为自动更新（DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP），这意味着如果这个列有变化，在每次更新数据时会自动将其设置为当前的时间。\nDATETIME类型：没有内置的自动更新功能。如果你需要在 DATETIME 类型列上实现类似的自动更新行为，你需要在应用程序中进行相应的处理。\n\n\n时区处理：\nTIMESTAMP类型：存储的值是  相对于时区  的，即它会根据数据库会话的时区进行自动调整。当从数据库中检索 TIMESTAMP 类型的值时，MySQL 会将其转换为客户端连接的时区。因此，TIMESTAMP类型适用于存储基于时区的日期时间信息。\nDATETIME类型：不受时区影响，它表示一个特定的日期和时间，不会随时区变化而变化。当从数据库中检索 DATETIME 类型的值时，它会保持存储的原始日期时间值。\n\n\n\n通常情况下，如果你需要存储未来较远的时间或者需要进行跨时区的时间操作，你可能更倾向于选择 DATETIME 类型。而如果你对存储空间敏感或只需要存储近期时间范围内的数据，并且希望利用 ON UPDATE CURRENT_TIMESTAMP 功能，那么 TIMESTAMP 类型可能更合适。选择使用哪种类型取决于你的具体需求和应用场景。\n如果为了数据的长远考虑，使用 bigint 来直接存储毫秒级时间戳数字是更好的选择\n4.String 类型\n\n\n数据类型\n说明\n\n\n\nENUM\nENUM 是一个字符串对象，其值来自表创建时在列中规定的枚举变量其中之一的值\n\n\nSET\nSET 可以有 0 个或多个值，其值来之表创建时规定允许的一列值。指定包括多个 set 成员的 set 列值时，各成员之间需要用逗号风格。set 成员值本身不能有逗号\n\n\n需要注意的是，虽然插入的是我们预先设定的枚举值，但后台存放的时候，依旧是以 数字 的方式存放的（节省空间）\n4.1 enum枚举类型和我们在 C 语言中定义的类似，可以作为一种数据的选项\nweekday ENUM(&#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Wednesday&#x27;, &#x27;Thursday&#x27;, &#x27;Friday&#x27;, &#x27;Saturday&#x27;, &#x27;Sunday&#x27;) NOT NULL\n\n比如我们可以定义一个 weekday 的枚举类型，来表示星期几\n这样就能保证，这一列的数据，就只能是这个枚举类型之中的数据，而不会出现 mon、wed 这样的缩写星期\n相当于对使用这个数据库所有开发者的约束，必须要遵守枚举内部的数据要求。\n4.1.1 通过数字插入  除了通过直接指定元素来插入，还可以通过数字来插入\n\n我通过数字 3 来指定 weekday 里面的值，可以看到插入后的结果为wednesday，即枚举中的第三个值\nMariaDB [hello]&gt; insert into test  values (&#x27; 游泳 &#x27;,3);Query OK, 1 row affected (0.001 sec)MariaDB [hello]&gt; select * from test;+------------------------------------------+-----------+| hobby                                    | weekday   |+------------------------------------------+-----------+| 跑步, 游泳                                | Monday    || 跑步                                     | Monday    || 羽毛球                                   | Monday    || 跑步, 羽毛球                              | Monday    || 乒乓球                                   | Monday    ||                                          | Monday    || 跑步, 羽毛球, 乒乓球, 游泳, 跳绳             | Monday    ||                                          | Monday    || 游泳                                     | Wednesday |+------------------------------------------+-----------+9 rows in set (0.000 sec)\n\n再试试数字 6，插入的是周六，也是第六个值\nMariaDB [hello]&gt; insert into test  values (&#x27; 游泳 &#x27;,6);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; select * from test;+------------------------------------------+-----------+| hobby                                    | weekday   |+------------------------------------------+-----------+| 跑步, 游泳                                | Monday    || 跑步                                     | Monday    || 羽毛球                                   | Monday    || 跑步, 羽毛球                              | Monday    || 乒乓球                                   | Monday    ||                                          | Monday    || 跑步, 羽毛球, 乒乓球, 游泳, 跳绳             | Monday    ||                                          | Monday    || 游泳                                     | Wednesday || 游泳                                     | Saturday  |+------------------------------------------+-----------+10 rows in set (0.000 sec)\n\n通过以上测试，我买可以知道，枚举值用数字指定的时候，使用的是实际的第 n 位，而并不是使用下标。比如我想插入 0 是会报错的，要想往 weekday 里面插入数据，正确的数字范围是1-7\nMariaDB [hello]&gt; insert into test  values (&#x27; 游泳 &#x27;,0);ERROR 1265 (01000): Data truncated for column &#x27;weekday&#x27; at row 1\n\n但是，使用数字会大大降低代码可读性，不符合我们使用枚举的初衷。还是更推荐大家直接指定枚举中的元素值！\n\n4.2 setset 和 enum 是类似的，但是可以  多选\nhobby set(&#x27; 跑步 &#x27;,&#x27; 羽毛球 &#x27;,&#x27; 乒乓球 &#x27;,&#x27; 游泳 &#x27;,&#x27; 跳绳 &#x27;)\n\n4.2.1 插入多个  当我们插入数据的时候，可以用逗号插入多个  预定义 set中的值\ninsert into test values (&#x27; 跑步, 游泳 &#x27;);\n\nMariaDB [hello]&gt; select * from test;+---------------+| hobby         |+---------------+| 跑步, 游泳     |+---------------+1 row in set (0.000 sec)\n\n如果尝试插入 set 中不包含的值，则会报错\nMariaDB [hello]&gt; insert into test values (&#x27; 跑步, 游泳, 代码 &#x27;);ERROR 1265 (01000): Data truncated for column &#x27;hobby&#x27; at row 1MariaDB [hello]&gt; \n\n这个 set 就可以用于收集表来统计用户固定的爱好的情况，让用户来  多选，再插入数据库。\n\n4.2.2 元素不能有,因为 set 可以插入多个，这就要求 set 中每一个元素本身不能包含, （不能和 mysql 的关键字冲突，就好比 c 语言中你不能将关键字定义为成员变量一样。）\n比如，如下的设置就是不允许的\nhobby set(&#x27; 跑步 &#x27;,&#x27; 羽毛球 &#x27;,&#x27; 乒乓球 &#x27;,&#x27; 游泳 &#x27;,&#x27; 跳, 绳 &#x27;)\n\n这张表会被拒绝创建，报错也告诉你 跳, 绳 是不合法的 set 值\nMariaDB [hello]&gt; create table test (    -&gt; hobby set(&#x27; 跑步 &#x27;,&#x27; 羽毛球 &#x27;,&#x27; 乒乓球 &#x27;,&#x27; 游泳 &#x27;,&#x27; 跳, 绳 &#x27;));ERROR 1367 (22007): Illegal set &#x27; 跳, 绳 &#x27; value found during parsingMariaDB [hello]&gt; \n\n4.2.3 用数字插入？除了用 set 中的数据，我们还可以用数字来插入这些元素\nMariaDB [hello]&gt;  insert into test values (1);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; select * from test;+---------------+| hobby         |+---------------+| 跑步, 游泳     || 跑步          |+---------------+2 rows in set (0.001 sec)\n\n多尝试几个，会发现结果很  奇怪 ，并不是当时定义表中，set 元素的 下标\nMariaDB [hello]&gt; insert into test values (2);Query OK, 1 row affected (0.009 sec)MariaDB [hello]&gt; insert into test values (3);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; insert into test values (4);Query OK, 1 row affected (0.003 sec)MariaDB [hello]&gt; select * from test;+------------------+| hobby            |+------------------+| 跑步, 游泳        || 跑步             || 羽毛球           || 跑步, 羽毛球      || 乒乓球           |+------------------+5 rows in set (0.001 sec)\n\n比如你打算插入 0 的时候，会发现是一个空（但不是 NULL）\nMariaDB [hello]&gt; insert into test values (0);Query OK, 1 row affected (0.041 sec)MariaDB [hello]&gt; select * from test;+------------------+| hobby            |+------------------+| 跑步, 游泳        || 跑步             || 羽毛球           || 跑步, 羽毛球      || 乒乓球           ||                  |+------------------+6 rows in set (0.001 sec)\n\n4.2.3 位图  实际上，这里是用  位图  来表示每一个数据的位置的\nhobby set(&#x27; 跑步 &#x27;,&#x27; 羽毛球 &#x27;,&#x27; 乒乓球 &#x27;,&#x27; 游泳 &#x27;,&#x27; 跳绳 &#x27;)\n\n这里一共有 5 个数据，对应就是 5 个字节。需要注意，其将 set 中的第一个元素放置在了二进制的低位。比如 跑步 对应的是二进制数码最右侧的（低位）的第一个二进制位\n0 0 0 0 0 # 啥都不插入0 0 0 0 1 # 插入跑步0 0 0 1 0 # 插入羽毛球0 0 0 1 1 # 插入跑步, 羽毛球0 0 1 0 1 # 插入跑步, 乒乓球# 以此类推\n\n但当我们尝试插入一个超过 5 个比特能表示的数据（0~31）时，会发生什么呢？\nMariaDB [hello]&gt; insert into test values (1000);ERROR 1265 (01000): Data truncated for column &#x27;hobby&#x27; at row 1MariaDB [hello]&gt; insert into test values (32);ERROR 1265 (01000): Data truncated for column &#x27;hobby&#x27; at row 1\n\n不给插入辣！\n而插入 31 是可以的，也就是 5 个爱好都带上\nMariaDB [hello]&gt; insert into test values (31);Query OK, 1 row affected (0.042 sec)MariaDB [hello]&gt; select * from test;+------------------------------------------+| hobby                                    |+------------------------------------------+| 跑步, 游泳                                || 跑步                                     || 羽毛球                                   || 跑步, 羽毛球                              || 乒乓球                                   ||                                          || 跑步, 羽毛球, 乒乓球, 游泳, 跳绳             |+------------------------------------------+7 rows in set (0.001 sec)\n\n这样我们也可以理解为什么插入 0 是一个空值了。这便代表用户在提供的选项中谁都没有选择（相当于弃权）\n4.2.4 查询  既然能用数字插入，就能用数字查询\nMariaDB [hello]&gt; select * from test where hobby=31;+------------------------------------------+| hobby                                    |+------------------------------------------+| 跑步, 羽毛球, 乒乓球, 游泳, 跳绳             |+------------------------------------------+1 row in set (0.001 sec)\n\n4.2.5 条件查询 find_in_setselect find_in_set(&#x27;a&#x27;,&#x27;a,b,c&#x27;);\n\n这个函数能帮我们查看一个数据是否在定义的 set 中，上面这个语句的意思是查询a 是否在 set a,b,c 中。控制台中测试，结果输出为 1（代表True）\n如果不在，返回的是 0（代表 False）\nMariaDB [hello]&gt; select find_in_set(&#x27;a&#x27;,&#x27;a,b,c&#x27;);+--------------------------+| find_in_set(&#x27;a&#x27;,&#x27;a,b,c&#x27;) |+--------------------------+|                        1 |+--------------------------+1 row in set (0.000 sec)\n\n而在查询的时候，就可以用这个来筛选出爱好有其中一项的人\nMariaDB [hello]&gt; select * from test where find_in_set(&#x27; 游泳 &#x27;,hobby);+------------------------------------------+| hobby                                    |+------------------------------------------+| 跑步, 游泳                                || 跑步, 羽毛球, 乒乓球, 游泳, 跳绳             |+------------------------------------------+2 rows in set (0.001 sec)\n\n这样就成功把爱好中有游泳的人给筛选出来了！\n而且我们还可以用 or (and) 来连接两个条件，实现更大范围的查询。\nMariaDB [hello]&gt; select * from test where find_in_set(&#x27; 游泳 &#x27;,hobby) or find_in_set(&#x27; 羽毛球 &#x27;,hobby);+------------------------------------------+| hobby                                    |+------------------------------------------+| 跑步, 游泳                                || 羽毛球                                   || 跑步, 羽毛球                              || 跑步, 羽毛球, 乒乓球, 游泳, 跳绳             |+------------------------------------------+4 rows in set (0.001 sec)\n\nThe endOver！\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【leetcode】001. 两数之和（C 语言，超详细）","url":"/posts/2927049053/","content":"这是初学 C 时候写的题解，可能有思维漏洞，后面重新刷题的时候会更改！\n\n\n\nPS：已重新更正并添加了 C++ 的哈希解法\n\n[toc]\n\n题目来源  两数之和 leetcode-001\n如下图所示\n\n右侧给出了题目的基本模板\n/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;&#125;\n\n\n题目要求  做题之前，我们需要梳理出题目的各项要求\n算法题目需要我们非常细致，因为一个小要求的未完成，就会导致格式出问题或者结果出问题，无法通过系统的测试\n题目要求如下：\n\n在给定数组 nums 中找出相加为 target 的两个数字\n同一个数字不能重复\n假设每一个 target 只对应一种答案\n找到数字后返回元素的下标\n不能更改摸板里的代码\n\n这里还有一个容易被忽略的  隐藏条件！\n\n相加的两个数字在数组中是连续的\n\n这个条件是观察 3 个示例得出的，如果没有这个条件，这道题目就需要我们在数组中进行完全搜索！\n我做这道题目的时候就卡在了这个地方！\n\n实现步骤 1. 模板中四个值的意义 首先我们要弄明白摸板里的 4 个值分别代表什么东西\nint* twoSum(int* nums, int numsSize, int target, int* returnSize)\n\n\nint* nums——nums 数组（ 此形式等同于 int nums[])\nnumsSize——数组元素的个数\ntarget——需要求和的结果\nint* returnSize——返回值的个数（这个不可以省略！）\n\n再来看题目的要求\n\n需要在给定数组中找到相加 &#x3D;target 的两个  连续的  数字\n\n2. 在数组中找到两个连续的元素  一般在数组里面查找一个数字，我们都会想到使用 for 循环\n这里需要查找两个连续的数字，可以使用两个嵌套的 for 循环以及两个循环变量来实现\n\n更新：实际上这两个数字不一定是连续的，用双循环的暴力写法，非连续数字其实也是能搞定的\n\nint i=0；int j=i+1;\n\n需要注意的是，j 比 i 大了 1，为了防止数组越界访问\nfor 循环里面的判断变量也要相应的差 1\nfor(int i = 0; i &lt; numsSize - 1; i++) &#123;     for(int j = i+1; j &lt; numsSize; j++)     &#123;              &#125; &#125;\n\n3. 判断相加是否等于 target在数组中找到元素后，需要判断它们两个相加是否等于 target\nif(nums[i] + nums[j] == target)\n\n4. 返回元素下标  当代码成功找到了两个相加等于 target 的元素后，我们要返回这两个元素的下标\n这里就需要一个新的  数组  来接收这两个下标，这比单纯的使用两个变量更方便\n创建这个数组有两种方法\n\n使用 arr[2]来创建\n使用 malloc 函数来创建\n\n其中方法二，是题目所给提示里的函数，后续将提及\n/* Note: The returned array must be malloced, assume caller calls free(). */\n\n\n代码示例 1\n注：leetcode 的函数题目只需要补全自定义函数，无需写 main 函数\n\n在示例 1 里面，使用普通的方式创建 result[2]数组\nint* twoSum(int* nums, int numsSize, int target,int* returnSize) &#123;    static int result[2] = &#123;0&#125;;//static 修饰后，return 的地址才能被 main 接收    for(int i = 0; i &lt; numsSize - 1; i++)    &#123;        for(int j = i+1; j &lt; numsSize; j++)        &#123;            if(nums[i] + nums[j] == target)            &#123;                result[0] = i;                result[1] = j;                *returnSize = 2;// 这个不能删除                return result;            &#125;        &#125;    &#125;    return NULL;&#125;\n\n因为我们需要在 main 函数里面使用 result 数组的值，所以需要用 static 来修饰这个数组\n不用 static 修饰的话，出了自定义函数后，result 数组的内存空间将被释放\n即便我们 return 了这个数组，它也不能被主函数接收\n\nstatic 的作用\n修饰函数\n修饰全局变量\n修饰局部变量\n\n这里使用的是 static 的第 3 个作用，将局部变量数组 result，变成  静态局部变量\n即数组 result不会在出自定义函数后销毁\n\n*returnSize 是什么？\n屏幕前的你是否和我有一样的疑惑，此 *returnSize 在自定义函数里面没有意义\n那为什么不能删除？\n\n要知道，这里的 *returnSize 是题目的模板给我们的\n而且题目没有要求我们书写 main 函数\n其实这里的 *returnSize 在 main 函数是有变量传过来的\n删除后自定义函数里缺少变量来接受传过来的数据，自然会报错\n*returnSize = 2;\n\n同时，我们需要在 if 语句中将它定义为 2，即为返回值的个数\n具体的分析参考这篇博客 &#x3D;&#x3D;&gt; 链接\n\n代码示例 2说第二种方法前，我们必须先弄明白 malloc 函数是什么\n\n什么是 malloc 函数？在 cplusplus 网站，我们可以查看到malloc 函数的定义\n该函数对应的头文件为 cstdlib，即 c 语言中的 &lt;stdlib.h&gt;\n\n它的作用，简单来说就是在内存中开辟对应字节的空间，赋予给一个指针变量\nint *pa = malloc(sizeof(int));\n\n上面这个语句的意义是，开辟一个 int 类型（即 4 个字节）的空间，赋给  指针变量 *pa\n\n其中的 sizeof(int) 可以换成 (4)；也可以在后面乘上一个数sizeof(int)*2 表示 8 个字节\n\n本题  需要的是存放两个 int 整形的数组，malloc 函数可以这么写\nint *num = malloc(sizeof(int)*2);\n\ncplusplus 对 malloc 函数中的定义里有一句话\n\nIf the function failed to allocate the requested block of memory, a null pointer is returned.\n\n如果指针分配错误，函数将返回一个 NULL，空指针\n\nmalloc 使用后 free 释放  在使用完 malloc 函数后\n\n需要用 free 函数来释放 malloc 创建的内存空间\n需要将创建的指针变量指向空指针，以防程序错误调用\n\nfree(pa);pa = NULL;\n\n这两个函数是配对的\n\n如果申请后不释放，会  内存泄露\n\n如果无故释放，那就是什么也没有做\n\n\n内存泄漏参考这篇博客 &#x3D;&#x3D;&gt; 链接\n\n以下就是方法 2 的完整代码\n/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;    int *num = malloc(sizeof(int)*2);    for(int i = 0; i &lt; numsSize - 1; i++)    &#123;        for(int j = i + 1; j &lt; numsSize; j++)        &#123;            if(nums[i] + nums[j] == target)            &#123;                num[0] = i;                num[1] = j;                *returnSize = 2;                return num;            &#125;        &#125;    &#125;    return NULL;&#125;\n\n为什么本题使用完 malloc 函数后没有 free 呢？\n原因还是在本题的提示里\n/*Note: The returned array must be malloced, assume caller calls free()*/\n\n这个语句的大概意思应该是：假设 main 函数里面已有一个 free 函数来释放内存\n所以我们不需要自己加上 free 函数;\n\n自己写代码的时候一定别忘了加哦！\n\n\n初学总结  虽然这只是 leetcode 的第一题，网站打上的难度是“简单”\n但对于我这个学艺不精的初学者来说，还是费了一番功夫去完成这道题并理解它\n本片博客就是我求解这道题的过程，希望对你有帮助\n\n小声吐槽：csdn 太多繁杂的东西了，有的博客代码不贴代码块，有的答案代码都是错的。\n还有些人就这么一道题的答案都给你上传一个付费文件（无头像无 id 无简介，上传几千个资源，怀疑是机器人爬虫）\n\n不管怎么样，至少我弄懂这道题啦！\n感谢引用的两篇博客的作者，若不是他们，我也弄不明白这道题！\n点个👍再走吧，球球了！这对我真的很重要啊！\n回顾  已经是 2023 年的 2 月份了，距离我写下这篇文，已经过去了一年多的时光。回顾看来，当时写的教程着实不太好，于是返回来更正一番\n代码示例 3此题最佳的解决方案是哈希思想。哈希就是一个映射关系。\n\n如果你不知道什么是哈希，建议暂时先采用上面的双循环暴力解法。等后续学习了哈希思想以及实现之后，再回头来重做此题\n\n我们可以将数组中的数据和其对应的下标插入到哈希表中，由于哈希表的搜索效率接近O(1)，查找的速度是很快的，此题的整体时间复杂度就变成了O(N)\n思路如下：\n\n查找哈希表中，是否有和（目标 - 当前值）相同的元素\n如果有，那么得到答案。返回当前遍历到的下标，以及查找到的元素的下标\n如果没有，那就把当前  元素 - 元素下标  作为键值对，插入到哈希表中\n\n因为本题是一定有解的，这样一次循环之后，一定能找到我们需要的那两个数的下标\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int,int&gt; m;// 哈希表 数据 - 下标        vector&lt;int&gt; ret;// 返回值        for(int i=0;i&lt;nums.size();i++)        &#123;\t        // 找有没有和（目标 - 当前值）相同的元素            auto it = m.find(target-nums[i]);            if(it!=m.end())// 找到了            &#123;                ret.push_back(it-&gt;second);// 插入哈希表中下标                ret.push_back(i);// 插入当前下标                break;// 退出循环            &#125;            else            &#123;                m.insert(&#123;nums[i],i&#125;);// 插入元素和下标            &#125;        &#125;        return ret;    &#125;   &#125;;\n\n\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","leetcode"]},{"title":"【MySQL】windows11 安装 mysql","url":"/posts/1951514193/","content":"本文是找到的不错的 windows 下安装 mysql 的教程，在我的 windows11 笔记本上成功安装并能正常使用。在此转载下来\n\n\n原文链接：https://blog.csdn.net/ouyangzhenxin/article/details/125514255\n一、提前认知  要想在 windows 中运行 mysql，需要32 位或者 64 的windows操作系统，例如：windows10、windows11等；\nwindows平台下提供了两种安装方式：\n\nmysql二进制分发版本（.msi安装文件）；\n\n免安装版（.zip压缩文件）\n\n\n一般我们使用二进制分发版本来安装。\n我这里使用的环境是：\nwindows11-64 位\nmysql 二进制分发版本\n\n​    \n二、下载 mysql 安装包 1、打开浏览器，访问mysql 官网中的下载地址https://dev.mysql.com/downloads/installer/\n\n​    \n2、点击下载按钮，下载安装包到本地  装程序有两个版本，分别为 mysql-installer-web-community 和mysql-installer-communityl，其中 mysql-installer-web-community 为在线安装版本，mysql-installer-communityl为离线安装版本。在这里我们是当然是选择离线安装版本了。\n\n然后在下面的界面中点击（No thanks, just start my download.）意思是说，我们不登录也不注册，仅仅是下载一个安装包。\n\n然后就会启动我们的下载了，当我们下载结束之后，会得到下面的 mysql 软件安装包；\n\n三、安装 mysql双击 mysql 安装包，稍等一会儿之后，出现如下安装界面；\n\n可以看到有 5 中安装类型，分别是：\n\nDeveloper Default：默认安装类型\n\nServer only：仅作为服务器\n\nClient only：仅作为客户端\n\nFull：完全安装\n\nCustom：自定义安装\n\n\n在这里我们选择Custom，也就是自定义安装，然后点击Next；\n\n出现如下界面；\n\n我们进行选择性的安装；\n我们选装 MySQL Server 8.0.29-X64、MYSQL Documentation 8.0.29-X86 和Samples and Examples 8.0.29-X86即可。\n\n然后点击 Next 界面，出现下图，我们点击Execute（执行）：\n\n然后就会执行安装了，如下图：\n\n然后我们耐心等待，直至出现如下界面，我们点击Next；\n\n出现下图，我们依旧点击Next；\n\n四、配置 mysql出现服务器类型配置窗口，如图：\n\n当我们点击 Config Type 的时候，可以看到出现几个选项；\n\n上面几个含义分别是：\n\nDevelopment Machine（开发机器）：该选项代表典型个人用桌面工作站。假定机器上运行着多个桌面应用程序，将 MySQL 服务器配置成使用最少的系统资源。\n\nServer Machine（服务器）：该选项代表服务器，MySQL服务器可以同其他应用程序一起运行，例如 FTP、Email 和Web服务器。MySQL服务器配置成使用适当比例的系统资源。\n\nDedicated Machine（专用服务器）：该选项代表只运行 MySQL 服务的服务器。假定没有运行其他服务程序，MySQL服务器配置成使用所有可用系统资源。\n\n\n在这里我们使用Development Machine（开发机器），方便使用，别的默认配置都不动，直接点击Next。\n出现如图的  权限设置方式  窗口，第一个单选项的含义是 MySQL 8.0 提供的新的授权方式，采用 SHA256 基础的密码加密方法；第二个单选项的含义是传统授权方法（保留 5.x 版本兼容性）。这里选择第二个单选项。\n\n点击 Next 之后，我们就在新弹出的界面中，配置 mysql 数据库的 root 用户名登录信息了，这里我设置的是Yunweijia0909，我们需要输入两遍哈；\n当然，我们也可以在这个界面中新添加其他用户，这个根据实际情况来配置即可；\n\n配置完毕之后，我们继续点击 Next 按钮；\n然后就可以配置数据库名字了，这里我们配置成MySQL；\n\n点击Next，然后再点击Execute，如图：\n\n系统自动配置 MySQL 服务器。配置完成后，单击Finish（完成）按钮，弹出新对话框;\n\n接下来界面中点击 Next 之后，出现如下界面：\n\n在这里我们输入之前配置的用户信息，即 Yunweijia0909，然后点击Check 按钮，就会发现他右上角的 Status 变成了Connection succeeded，表示连接成功了。确定无误之后，点击Next;\n新界面中点击Execute；\n\n运行完毕之后会出现 Finish 按钮，点击即可；\n\n然后在新界面中点击右下角的Next，出现：\n\n我们的 MySQL 就安装完成了。\n五、验证 1、任务管理器 打开任务管理器也会发现有一个 mysql.exe 的进程，如图：\n\n2、命令行PS C:\\Users\\22768&gt; mysql -uroot -p\nEnter password: *************\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 18\nServer version: 8.0.29 MySQL Community Server - GPL\n\nCopyright (c) 2000, 2021, Oracle and/or its affiliates.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n\nmysql&gt;\n\n​    \n至此，本文结束。\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【leetcode】006 N 字形变换","url":"/posts/3624744626/","content":"写了一下午终于写出来了\n\n\n题目\n leetcode 6. N 字形变换\n\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：\nP   A   H   NA P L S I I GY   I   R\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n\n示例 1：\n输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot;\n\n示例 2：\n输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4输出：&quot;PINALSIGYAHRPI&quot;\n\n解释：\nP     I    NA   L S  I GY A   H RP     I\n\n示例 3：\n输入：s = &quot;A&quot;, numRows = 1输出：&quot;A&quot;\n\n提示：\n1 &lt;= s.length &lt;= 1000s 由英文字母（小写和大写）、&#x27;,&#x27; 和 &#x27;.&#x27; 组成1 &lt;= numRows &lt;= 1000\n\n分析  刚开始我想的过于简单了，所以写的代码下标控制有严重问题，弄了这么久，其实一直都是在改下标……\n1. 写几个例子  如下是 n 从 3 到 7 的例子，能基本满足题目需要的情况\n\n\n题目的要求是，给你一个 ABCDEFG...这样的字符串，再给一个行数 n，让你按上面这种 N 的形式排列出来，再  按行  读出一个新的字符串。\n我们肯定不可能真的用二维数组给她摆出来一个这样的图像再去遍历，哪样效率太低了。而是用 n 次遍历，利用下标的规律，以下标访问拼出新的字符串。\n2. 分析规律  按行号写出每一个的间隔，能的出来一个基本规律（最左列是行下标）\n\n\n首先，我们能发现，每一个 N 型的  第一行和最后一行  的间隔（步长）是相同的，且和行数符合一个公式\n(行数 - 1) * 2\n\n除了这两个边界行，中间的行数都是简单的递减 2\n\n3. 步长翻转  但除了  只有三行  的示例之外，其余都有一个 步长翻转 的问题\n如下，比如第 1 行（这里说的是下标）B-&gt;H符合从第 0 行开始递减 2 的步长 6，但下一次查找的步长H-&gt;J 就变成了 2 了\n同理，看第 3 行，D-&gt;F的步长为 2，而 F-&gt;L 的步长为 6，两者正好和第 1 行相反。\n而第 1 行和第 3 行，正好是两个对称的\n\n这便是第二个规律\n除了首末两行，和奇数行数的中间行（比如行数为 5，第 2 行即为中间行 0 1 [2] 3 4 ）其余行数按上下分，其步长每走一次需要切换一次\n\n以上图中的第 1 行为例\n\n第一步，B-&gt;H，走的是正常的 6 步（由 8-2 得来）\n第二步，H-&gt;J，走的是第三行的正常步 2（由 8-2*3 得来）\n\n由此往后，每走一步都需要在 6 和 2 之间切换。\n\n复盘的时候才发现一个更简单的翻转，其实每一行的几次查找的步长最终加起来和首末两行是相同的\n\n4. 循环解释  找到了这个规律之后，写代码就好写了！下面解释一下完整代码中 while 循环中的判断部分，一共分为三种情况\n\n首末行和奇数中间行，不需要翻转，正常进行步长的相加\n需要翻转的行数，分为中间行上面的和下面的两种情况。该行第一次进入 while，不需要加上翻转步长，而是加上由上一行步长sep-2 得来的正常步长 cur_sep。此时需要对翻转步长reverFlag 进行初始化：\n中间行上面，翻转步长为对称行步长的负数（比如第一行和第三行对称，此时第一行的翻转步长就是第三方的正常步长取负数。）\n中间行下面，翻转步长为对称行步长的正数（同上）\n\n\n该行第二次进入 while，需要加上翻转步长reverFlag 后，并对翻转步长取  负数（对称行两个步长之间差值相同，取负数相当于恢复原始步长）\n直到 index 大于 string 的长度，一行遍历完毕，sep-=2\n\n完整代码  注意啊，如果你和我一样，写题的时候喜欢用 print 来找 bug，那么写完了之后，一定要把这些题目需求中没有的打印给删除掉。不然会影响性能，甚至有可能因此超时无法通过题目。\nclass Solution &#123;public:    // 奇数行，最中间的    // 5 -&gt; 2 | 7 -&gt; 3    bool isMidRow(int n,int numRows)    &#123;        return (numRows%2!=0) &amp;&amp; n == numRows/2;    &#125;    bool isFirstEnd(int n,int numRows)    &#123;        return n==0 || n==numRows-1;    &#125;    string convert(string s, int numRows) &#123;        if(numRows&lt;=1)        &#123;            return s;        &#125;        string ret;        int begin_sep = (numRows-1)*2;        int sep = begin_sep;// 第一行和最后一行都是这个长度        // 中间的是从第一行开始，每次 -2                // 开始遍历，排除最后一行        for(int i=0;i&lt;numRows;i++)        &#123;            if(i==numRows-1)&#123;                sep = begin_sep;// 最后一行的长度分割            &#125;            int index = i;            int reverFlag = 1;            int cur_sep = sep;            while(index&lt;s.size())&#123;                ret+=s[index];                // 是否是单数行中间的，如果是那就不需要反转                if(isMidRow(i,numRows) || isFirstEnd(i,numRows))&#123;                    index+=sep;                    //cout &lt;&lt; i &lt;&lt; &quot; continue&quot; &lt;&lt; endl;                    continue;                &#125;                else if(reverFlag == 1)&#123;// 本行第一次进来                    index+=sep;                    //cout &lt;&lt; i &lt;&lt; &quot; 1r-sped &quot;&lt;&lt;sep&lt;&lt;endl;                    //int reverNum = abs((numRows/2-1)*2);                    //cout &lt;&lt; i &lt;&lt; &quot; 1r-rever &quot;&lt;&lt;reverNum &lt;&lt;endl;                    // 4 行，上对称行 1 第一次翻转是 -2                    // 5 行，上对称行 1 第一次反转是 -4                    int k = numRows - i - 1;                    if(i&lt;(numRows/2))// 上对成行                    &#123;                        // 获取对称的行号的 sep，并计算两者差值                        reverFlag = - abs((begin_sep - k*2) - cur_sep);                    &#125;                    else                    &#123;                        reverFlag = abs((begin_sep - k*2) - cur_sep);                    &#125;                    //cout &lt;&lt;i &lt;&lt;&quot; 1r-flag &quot;&lt;&lt;reverFlag&lt;&lt;endl;                &#125;                else// 第二次以上，开始反转                &#123;                    cur_sep += reverFlag;                    index+= cur_sep;                    //cout &lt;&lt;i &lt;&lt;&quot; sepd &quot;&lt;&lt;(cur_sep)&lt;&lt;endl;                    reverFlag = -reverFlag;// 逆置                    //cout &lt;&lt;i &lt;&lt;&quot; flag &quot;&lt;&lt;reverFlag&lt;&lt;endl;                &#125;            &#125;            // 一行走完了，更新 sep            sep-=2;        &#125;        return ret;    &#125;&#125;;\n\n通过截图  让我很不理解的是，自己有时候搜一些网上题解，有些文章竟然能做到将无法通过的代码当作题解发出来，浪费读者的时间。实在不知道他们是怎么做到的……所以，为了避免自己的文章被人误解，我尽量每次 oj 刷题都附上通过截图\n\nThe end最后附上一张当时泄题用的乱七八糟的草稿图\n\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C++","leetcode"]},{"title":"【MySQL】deepin 安装 mysql 的 cpp 开发包","url":"/posts/971003431/","content":"在 deepin 下安装好 mysql 后，发现在 c 语言中没有 &lt;mysql.h&gt; 的头文件。\n而根据 ubuntu 的办法直接按照 mysql 的开发包，会出现这种情况：\n~/Desktop$ sudo apt-get install libmysqlclient-dev正在读取软件包列表… 完成  正在分析软件包的依赖关系树  正在读取状态信息… 完成  没有可用的软件包 libmysqlclient-dev，但是它被其它的软件包引用了。这可能意味着这个缺失的软件包可能已被废弃，或者只能在其他发布源中找到E: 软件包 libmysqlclient-dev 没有可安装候选\n\n首先使用命令sudo apt install default-libmysqlclient-dev，会出现如下：\n~/Desktop$ sudo apt install default-libmysqlclient-dev正在读取软件包列表… 完成  正在分析软件包的依赖关系树  正在读取状态信息… 完成  将会同时安装下列软件：libmariadbclient-dev libmariadbclient-dev-compat下列【新】软件包将被安装：………\n\n安装好后在运行一次，此时已经是最新版\n第二步使用如下命令安装 mariadb 的开发包，和 mysql 是一样的；这样执行了之后，那么你在 linux 中就应该能引入头文件 &lt;mysql/mysql.h&gt; 了。\nsudo apt-get install libmariadbclient-dev\n\n\n此时 /usr/include里面已经有 mysql 的文件夹了！\n\n这是我在找到方法的链接：\nhttps://blog.csdn.net/guyspring/article/details/104302131\nhttps://stackoverflow.com/questions/5178292/pip-install-mysql-python-fails-with-environmenterror-mysql-config-not-found#\n希望有用！\n版权声明：本文为 CSDN 博主「衣兜」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/wu___hao/article/details/113257493\n\n该方法慕雪在 deepin 20.9 虚拟机上实测有效！\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】基础命令操作","url":"/posts/2109090510/","content":"mysql 的基础命令\n\n\n本文演示所用 mariadb 版本\nmysql  Ver 15.1 Distrib 10.3.28-MariaDB, for Linux (x86_64) using readline 5.1\n\nSQL 语句的分类  学习 MySQL 之前，我们先了解一下 MySQL 中 SQL 的分类\n\nDDL【data definition language】 数据定义语言，用来维护存储数据的结构。代表指令: create, drop, alter \nDML【data manipulation language】 数据操纵语言，用来对数据进行操作。代表指令： insert，delete，update \nDML 中又单独分了一个DQL，数据查询语言，代表指令： select \n\n\nDCL【Data Control Language】 数据控制语言，主要负责权限管理和事务。 代表指令： grant，revoke，commit\n\n0. 连接 mysql默认情况下，我们的 mysql 没有密码，直接使用如下命令，就能链接上 mysql\nmysql -uroot\n\nmysql 数据库文件路径\n/var/lib/mysql\n\nmysql 的语句是大小写不敏感的，大小写都可以。\n如果你的 MySQL 有密码，那就是用如下命令进入 MySQL 命令行\nmysql -uroot -p123456 # 示例mysql -u 用户名 -p 密码  # 基本操作\n\n0.1 查看有谁连接了show processlist;\n\n该命令可以查看当前有谁连接了 MySQL 服务，所在数据库是什么，正在执行的 cmd 是什么\n\n0.2 查看支持的存储引擎 mysql 支持多种 存储引擎\n\n存储引擎是：数据库管理系统如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。\n\n每个引擎各有其优势。可以用下面的语句查询当前支持的引擎\nshow engines;\n\n\n1. 数据库1.1 创建create database 数据库名字;create database if not exists 数据库名字; # 如果不存在才创建create database hello;\n\n上面的命令创建了一个名为 hello 的数据库。对于 mysql 服务端而言，其实际上是在数据文件路径中，帮我们创建了一个对应的文件夹\n\n如果是 mysql5.7，在创建语句之前新增一个show，可以看到当前执行语句的详细信息。我当前使用的是高版本的 mariadb， 不支持这个操作\nshow create database hello;\n\n创建数据库或者表的时候，我们还可以给名称带上如下符号作为分割符\ncreate database ` 数据库名称 `;\n\nMariaDB [(none)]&gt; create database `test2`;Query OK, 1 row affected (0.001 sec)\n\n带上该符号后，可以用于区分你的表名和数据库的内置语句。建议创建、删除操作的时候，都给名字带上这个符号。\n当然，创建的数据库、表名最好  不要  和mysql内置语句冲突，这和写代码的时候不要用编程语言的关键字 &#x2F; 库函数名来命名变量一样。\n1.2 查看已有show databases;\n\n查看当前已有数据库\n+--------------------+| Database           |+--------------------+| hello              || information_schema || mysql              || performance_schema |+--------------------+4 rows in set (0.001 sec)\n\n1.3 进入  进入这个数据库\nuse hello;\n\n1.4 删除drop database [if exists] 名字;\n\n如下，我先是创建了一个 test1 数据库\nMariaDB [(none)]&gt; create database test1;Query OK, 1 row affected (0.001 sec)MariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| hello              || information_schema || mysql              || performance_schema || test1              |+--------------------+5 rows in set (0.000 sec)\n\n用下面这个命令删除该数据库\ndrop database test1;\n\n成功删除\nMariaDB [(none)]&gt; drop database test1;Query OK, 0 rows affected (0.035 sec)MariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| hello              || information_schema || mysql              || performance_schema |+--------------------+4 rows in set (0.001 sec)\n\n数据文件路径中，test1 文件夹也被对应删除\n\n1.5 字符集和校验规则  字符集会有自己对应的校验规则\n\n字符集用于将数据以特定编码  存入  数据库\n校验规则用于  取数据时对数据进行校验\n\n修改字符集的时候，mysql 会为我们自动指定对应的校验规则\n1.5.1 字符集  一个数据被存放的时候，是会有其所用的编码的。编码不相同，会导致数据在不同软件中显示出不同的结果。\n\n比如 我们使用 VS 写的 C 语言代码，文件内的中文注释放入 devc++ 之中，有可能会乱码，这就是字符编码不匹配的原因\n\nshow variables like 语句可以查看 mysql 的内置变量，其中如下变量就是数据库字符集的编码格式\nshow variables like &#x27;character_set_database&#x27;;\n\n可以看到，为utf-8\n+------------------------+-------+| Variable_name          | Value |+------------------------+-------+| character_set_database | utf8  |+------------------------+-------+1 row in set (0.002 sec)\n\n在配置 mariadb 的时候，就已经修改过了配置文件中数据库的编码规则，所以所有相关字符集编码都是utf-8\nshow variables like &#x27;character_set_%&#x27;;\n\nMariaDB [(none)]&gt; show variables like &#x27;character_set_%&#x27;;+--------------------------+------------------------------+| Variable_name            | Value                        |+--------------------------+------------------------------+| character_set_client     | utf8                         || character_set_connection | utf8                         || character_set_database   | utf8                         || character_set_filesystem | binary                       || character_set_results    | utf8                         || character_set_server     | utf8                         || character_set_system     | utf8                         || character_sets_dir       | /usr/share/mariadb/charsets/ |+--------------------------+------------------------------+8 rows in set (0.002 sec)\n\n使用如下命令可以查看数据库支持的所有编码\nshow charset;\n\nMariaDB [(none)]&gt; show charset;+----------+-----------------------------+---------------------+--------+| Charset  | Description                 | Default collation   | Maxlen |+----------+-----------------------------+---------------------+--------+| big5     | Big5 Traditional Chinese    | big5_chinese_ci     |      2 || dec8     | DEC West European           | dec8_swedish_ci     |      1 || cp850    | DOS West European           | cp850_general_ci    |      1 || hp8      | HP West European            | hp8_english_ci      |      1 || koi8r    | KOI8-R Relcom Russian       | koi8r_general_ci    |      1 || latin1   | cp1252 West European        | latin1_swedish_ci   |      1 || latin2   | ISO 8859-2 Central European | latin2_general_ci   |      1 || swe7     | 7bit Swedish                | swe7_swedish_ci     |      1 || ascii    | US ASCII                    | ascii_general_ci    |      1 || ujis     | EUC-JP Japanese             | ujis_japanese_ci    |      3 || sjis     | Shift-JIS Japanese          | sjis_japanese_ci    |      2 || hebrew   | ISO 8859-8 Hebrew           | hebrew_general_ci   |      1 || tis620   | TIS620 Thai                 | tis620_thai_ci      |      1 || euckr    | EUC-KR Korean               | euckr_korean_ci     |      2 || koi8u    | KOI8-U Ukrainian            | koi8u_general_ci    |      1 || gb2312   | GB2312 Simplified Chinese   | gb2312_chinese_ci   |      2 || greek    | ISO 8859-7 Greek            | greek_general_ci    |      1 || cp1250   | Windows Central European    | cp1250_general_ci   |      1 || gbk      | GBK Simplified Chinese      | gbk_chinese_ci      |      2 || latin5   | ISO 8859-9 Turkish          | latin5_turkish_ci   |      1 || armscii8 | ARMSCII-8 Armenian          | armscii8_general_ci |      1 || utf8     | UTF-8 Unicode               | utf8_general_ci     |      3 || ucs2     | UCS-2 Unicode               | ucs2_general_ci     |      2 || cp866    | DOS Russian                 | cp866_general_ci    |      1 || keybcs2  | DOS Kamenicky Czech-Slovak  | keybcs2_general_ci  |      1 || macce    | Mac Central European        | macce_general_ci    |      1 || macroman | Mac West European           | macroman_general_ci |      1 || cp852    | DOS Central European        | cp852_general_ci    |      1 || latin7   | ISO 8859-13 Baltic          | latin7_general_ci   |      1 || utf8mb4  | UTF-8 Unicode               | utf8mb4_general_ci  |      4 || cp1251   | Windows Cyrillic            | cp1251_general_ci   |      1 || utf16    | UTF-16 Unicode              | utf16_general_ci    |      4 || utf16le  | UTF-16LE Unicode            | utf16le_general_ci  |      4 || cp1256   | Windows Arabic              | cp1256_general_ci   |      1 || cp1257   | Windows Baltic              | cp1257_general_ci   |      1 || utf32    | UTF-32 Unicode              | utf32_general_ci    |      4 || binary   | Binary pseudo charset       | binary              |      1 || geostd8  | GEOSTD8 Georgian            | geostd8_general_ci  |      1 || cp932    | SJIS for Windows Japanese   | cp932_japanese_ci   |      2 || eucjpms  | UJIS for Windows Japanese   | eucjpms_japanese_ci |      3 |+----------+-----------------------------+---------------------+--------+40 rows in set (0.001 sec)\n\n1.5.2 校验规则show variables like &#x27;collation_%&#x27;;\n\n如下可以看到，当前的校验规则都是 utf-8 相关的\nMariaDB [(none)]&gt; show variables like &#x27;collation_%&#x27;;+----------------------+-----------------+| Variable_name        | Value           |+----------------------+-----------------+| collation_connection | utf8_general_ci || collation_database   | utf8_general_ci || collation_server     | utf8_general_ci |+----------------------+-----------------+3 rows in set (0.001 sec)\n\n查看系统中所有校验集\nshow collation;\n\n结果很长，就不全贴出来了。能看到每一个编码集都对应了一个字符集\n\n1.5.3 创建库时指定CREATE DATABASE [IF NOT EXISTS] db_name [create_specification [,create_specification] ...]create_specification:    [DEFAULT] CHARACTER SET charset_name    [DEFAULT] COLLATE collation_name\n\n其中 [] 代表是可选项\n\nCHARACTER SET  指定数据库采用的字符集 \nCOLLATE  指定数据库字符集的校验规则\n\n如果在创建数据库时没有指定字符集和校验规则，则会采用数据库默认的。\n在数据库的文件夹中，有一个 db.opt 文件，其中就包含了当前数据库使用的字符集和校验规则\n[root@1c2261732150:/var/lib/mysql]# ls hellodb.opt  stu_test.frm  stu_test.ibd[root@1c2261732150:/var/lib/mysql]# cat hello/db.optdefault-character-set=utf8default-collation=utf8_general_ci\n\n如果在创建的时候指明字符集编码\ncreate database `test1` character set gbk; create database `test1` charset=gbk; # 两种写法相同 \n\n查看db.opt，可以看到系统自动指定了 gbk 字符集对应的校验和\n[root@1c2261732150:/var/lib/mysql]# ls test1db.opt[root@1c2261732150:/var/lib/mysql]# cat test1/db.optdefault-character-set=gbkdefault-collation=gbk_chinese_ci\n\n同时指定字符集和编码\ncreate database `test2` charset=utf8 collate utf8_bin;\n\n执行成功后，查看本地文件\n[root@1c2261732150:/var/lib/mysql]# cat test2/db.optdefault-character-set=utf8default-collation=utf8_bin\n\n成功设置了字符集和编码规则\n\n虽然在创建的时候可以这么做，但我们保持默认配置的 utf8 即可\n1.5.4 校验的影响  通过指定不同的编码，我创建了两个校验规则不同的数据库\nMariaDB [(none)]&gt; create database test_ci charset=utf8;Query OK, 1 row affected (0.001 sec)MariaDB [(none)]&gt; create database test_bin charset=utf8 collate utf8_bin;Query OK, 1 row affected (0.000 sec)\n\n其中一个的校验规则是utf8_general_ci，另外一个是utf8_bin\n[root@1c2261732150:/var/lib/mysql]# cat test_bin/db.optdefault-character-set=utf8default-collation=utf8_bin[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=utf8default-collation=utf8_general_ci\n\nutf8_bin先进入 test_bin 数据库\nuse test_bin;\n\n创建一个 student 表，只有一个字符串类型的 name 字段\ncreate table student(name varchar(30));\n\n插入如下数据\nMariaDB [test_bin]&gt; insert into student value (&#x27;a&#x27;);Query OK, 1 row affected (0.042 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;A&#x27;);Query OK, 1 row affected (0.008 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;b&#x27;);Query OK, 1 row affected (0.003 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;B&#x27;);Query OK, 1 row affected (0.004 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;c&#x27;);Query OK, 1 row affected (0.009 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;C&#x27;);Query OK, 1 row affected (0.007 sec)\n\n查看已有数据，分别是大小写的 abc\nMariaDB [test_bin]&gt; select * from  student;+------+| name |+------+| a    || A    || b    || B    || c    || C    |+------+6 rows in set (0.001 sec)\n\n查询数据，可以看到，返回的结果是只有小写 a 的\nMariaDB [test_bin]&gt; select * from student where name=&#x27;a&#x27;;+------+| name |+------+| a    |+------+1 row in set (0.001 sec)\n\n执行排序（升序）后输出，得到如下结果。我们知道，小写字母的 ASCII 是在大写字母的之后的，所以这个排序结果是正确的。\nMariaDB [test_bin]&gt; select * from student order by name;+------+| name |+------+| A    || B    || C    || a    || b    || c    |+------+6 rows in set (0.001 sec)\n\nutf8_general_ciuse test_ci;\n\n在这个数据库中进行相同的插入工作，创建表，插入大小写 abc（命令同上不再重复）\nMariaDB [test_ci]&gt; select * from  student;+------+| name |+------+| a    || A    || b    || B    || c    || C    |+------+6 rows in set (0.000 sec)\n\n执行查询语句，发现当我们查询小 a 的时候，同时返回了 A 和 a 的结果\nMariaDB [test_ci]&gt; select * from student where name=&#x27;a&#x27;;+------+| name |+------+| a    || A    |+------+2 rows in set (0.001 sec)\n\n排序的时候，大小 a 没有按 ASCII 码顺序排，而是放到了一起\nMariaDB [test_ci]&gt; select * from student order by name;+------+| name |+------+| a    || A    || b    || B    || c    || C    |+------+6 rows in set (0.001 sec)\n\n结论\nutf8_bin：查询的时候区分大小写\nutf8_general_ci：查询时忽略大小写\n\n在实际场景中，我们就可以根据需求，选择这两个校验规则中的其一作为我们数据库的校验规则。\n这两个只是众多校验规则之一，更多编码的区别，还得等后续慢慢探寻。在一般场景中，使用 utf8 是完全足够的。\n1.6 修改alter database 数据库名 [create_specification [,create_specification] ...];\n\n一般情况下，我们修改的是数据库的字符集和校验规则。\n示例如下，修改数据库 test_ci 的字符集为 gbk\nMariaDB [test_ci]&gt; alter database test_ci charset=gbk;Query OK, 1 row affected (0.006 sec)\n\n修改后查看配置文件，字符集和校验规则确实变化了（系统自动查找对应的校验规则）\n[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=utf8default-collation=utf8_general_ci[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=gbkdefault-collation=gbk_chinese_ci\n\n也可以同时修改校验规则，这里和新建数据库时的操作是一样的\nalter database test_ci charset=utf8 collate utf8_bin;\n\n[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=gbkdefault-collation=gbk_chinese_ci[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=utf8default-collation=utf8_bin\n\n1.7 备份数据库 1.7.1 备份一个数据库 如下操作是在 linux 命令行中执行的\nmysqldump -P3306 -u root -p 密码 -B 数据库名 &gt; 数据库备份存储的文件路径\n\n示例\nmysqldump -P3306 -u root -B hello &gt; hello.bak.sql\n\n这会在当前路径中出现了一个 sql 文件，其内容如下。\n-- MySQL dump 10.19  Distrib 10.3.28-MariaDB, for Linux (x86_64)---- Host: localhost    Database: hello-- -------------------------------------------------------- Server version       10.3.28-MariaDB/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;/*!40101 SET NAMES utf8 */;/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;---- Current Database: `hello`--CREATE DATABASE /*!32312 IF NOT EXISTS*/ `hello` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `hello`;---- Table structure for table `stu_test`--DROP TABLE IF EXISTS `stu_test`;/*!40101 SET @saved_cs_client     = @@character_set_client */;/*!40101 SET character_set_client = utf8 */;CREATE TABLE `stu_test` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(30) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `score` decimal(4,2) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;/*!40101 SET character_set_client = @saved_cs_client */;---- Dumping data for table `stu_test`--LOCK TABLES `stu_test` WRITE;/*!40000 ALTER TABLE `stu_test` DISABLE KEYS */;INSERT INTO `stu_test` VALUES (2,&#x27; 小图图 &#x27;,5,72.80),(3,&#x27; 大司马 &#x27;,42,87.30),(4,&#x27; 乐迪 &#x27;,32,99.00);/*!40000 ALTER TABLE `stu_test` ENABLE KEYS */;UNLOCK TABLES;/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;-- Dump completed on 2023-04-15 15:20:25\n\n我们会发现这里面的内容其实都是 sql 语句，如果将这个备份导入到另外一个数据库中，实际上就是将历史的所有 sql 语句全部执行一遍！\n\n除此之外，复制 /var/lib/mysql 下的数据库文件也是可行的一种备份方案。但并不推荐这么做！\n\n1.7.2 备份数据库中的多张表mysqldump -u root -p 数据库名 表名 1 表名 2 &gt; 备份文件名\n\n1.7.3 同时备份多个数据库mysqldump -u root -p -B 数据库名 1 数据库名 2  &gt; 备份文件名\n\n1.7.4 还原  如下命令需要在 mysql 中执行\nsource 备份文件路径# 示例source /root/hello.bak.sql;\n\n\n数据库中的内容和原有数据库是完全相同的\nMariaDB [hello]&gt; show tables;+-----------------+| Tables_in_hello |+-----------------+| stu_test        |+-----------------+1 row in set (0.001 sec)MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 ||  4 | 乐迪      |   32 | 99.00 |+----+-----------+------+-------+3 rows in set (0.001 sec)\n\n1.7.5 化简  如果你看过了上面对校验影响的验证，其中我往 test_bin 数据库中使用 6 条语句插入了大小写的 abc。\n但当我们执行备份的时候，可以看到备份出来的 sql 文件，六个语句被合并了！\nINSERT INTO `student` VALUES (&#x27;a&#x27;),(&#x27;A&#x27;),(&#x27;b&#x27;),(&#x27;B&#x27;),(&#x27;c&#x27;),(&#x27;C&#x27;);\n\n这也是 mysql 备份的智能之处之一！\n1.8 清空屏幕  在 MySQL 中，可以通过system 来执行 linux 系统命令\nsystem clear\n\n比如使用如上命令可以清空屏幕\n2. 表  如下命令需要先进入特定 database 才能执行\n2.1 创建表  基础的创建操作如下。其中末尾的字符集、校验规则、存储引擎的设置项可以留空不填\n\nfield 列名\ndatatype 列的类型\n\ncreate table 表名 (    field1 datatype,    field2 datatype,    field3 datatype) character set 字符集 collate 校验规则 engine 存储引擎;\n\n示例如下，创建了一个 student 表，并配置了两个键值 name 和 age，类型分别为字符串和 int\ncreate table student(    name varchar(30),    age int);\n\n除了基础操作之外，我们还可以给这个表新增一个 comment 作为列备注\ncreate table student(    name varchar(30) comment &#x27; 学生名字 &#x27;,    age int comment &#x27; 学生年龄 &#x27;);\n\n用下面的语句可以查看创建表时候的操作\nshow create table 表名;\n\n\n这部分和备份的时候的 sql 也是一样的，mysql 会帮我们自动规整语句，使其语法规则更规整；\n如下语句也能看到创建表时所用命令\nshow create table stu_test\\G\n\n在数据库帮我们创建这张表的时候，如果没有手动指定引擎和字符集，则会使用数据库的默认设置；\nMariaDB [hello]&gt; show create table stu_test\\G*************************** 1. row ***************************       Table: stu_testCreate Table: CREATE TABLE `stu_test` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(30) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `score` decimal(4,2) DEFAULT NULL,  `avatar` varchar(100) NOT NULL DEFAULT &#x27;default-avatar.png&#x27; COMMENT &#x27; 头像图片路径 &#x27;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf81 row in set (0.000 sec)\n\n这两个 show 命令的结果是类似的\n\n如果想在建立表的时候，设置数据库所用引擎和字符集，可以在 create 语句的括号之后，依照格式添加配置项\nCREATE TABLE xxx() ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n2.2 查看已有表show tables;\n\n+-----------------+| Tables_in_hello |+-----------------+| student         |+-----------------+1 row in set (0.001 sec)\n\n2.3 查看表的属性 &#x2F; 结构desc 表名;\n\nMariaDB [hello]&gt; desc stu_test;+-------+--------------+------+-----+---------+----------------+| Field | Type         | Null | Key | Default | Extra          |+-------+--------------+------+-----+---------+----------------+| id    | int(11)      | NO   | PRI | NULL    | auto_increment || name  | varchar(30)  | YES  |     | NULL    |                || age   | int(11)      | YES  |     | NULL    |                || score | decimal(4,2) | YES  |     | NULL    |                |+-------+--------------+------+-----+---------+----------------+4 rows in set (0.002 sec)\n\n还可以使用如下命令，输出的结果包括更多信息\nSHOW FULL COLUMNS FROM 表名;\n\n\n2.4 删除该表drop table student;\n\n2.5 修改表的结构  注意，这里是对表的属性的修改，并不是对数据的修改！\n比如我想新增字段，或者修改已有字段的属性，或者删除字段\n-- 新增字段ALTER TABLE tablename ADD (column datatype [DEFAULT expr][,columndatatype]...);-- 修改字段ALTER TABLE tablename MODIfy (column datatype [DEFAULT expr][,columndatatype]...);-- 删除字段ALTER TABLE tablename DROP (column);\n\n2.5.0 注意事项  请注意：修改表的字段是一个很麻烦的操作，其可能会涉及到已有数据的有效性问题\n\n请在生产环境上线前的测试阶段，完成表字段的定义！\n\n说人话就是，前期设计要想的尽量到位，避免后期表中已有数据的时候修改表的属性！\n2.5.1 新增字段  比如我给上方 2.5 中出现过的 stu_test 表新增一列，可以用如下的命令\n alter table stu_test add avatar varchar(100) comment &#x27; 头像图片路径 &#x27; after score;\n\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 ||  4 | 乐迪      |   32 | 99.00 ||  5 | dc872458  |   25 |  NULL |+----+-----------+------+-------+4 rows in set (0.000 sec)MariaDB [hello]&gt; alter table stu_test add avatar varchar(100) comment &#x27; 头像图片路径 &#x27; after    -&gt; score;Query OK, 0 rows affected (0.005 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------+| id | name      | age  | score | avatar |+----+-----------+------+-------+--------+|  2 | 小图图    |    5 | 72.80 | NULL   ||  3 | 大司马    |   42 | 87.30 | NULL   ||  4 | 乐迪      |   32 | 99.00 | NULL   ||  5 | dc872458  |   25 |  NULL | NULL   |+----+-----------+------+-------+--------+4 rows in set (0.000 sec)\n\n此时可以看到，已有数据都多了一个 avatar 字段，且这些已有数据的新字段都为NULL\n说明新增字段并不会影响旧数据的旧字段。我们可以在新增字段之后，给旧的数据修改默认值\n2.5.2 删除字段\n如果表中的数据只剩一列（只有一个字段）是不能删除这个字段的（只能删除这个表）\n\n使用如下命令，删除刚刚新增的 avatar 字段\nalter table stu_test drop avatar;\n\n可以看到 avatar 列被删除了\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------+| id | name      | age  | score | avatar |+----+-----------+------+-------+--------+|  2 | 小图图    |    5 | 72.80 | NULL   ||  3 | 大司马    |   42 | 87.30 | NULL   ||  4 | 乐迪      |   32 | 99.00 | NULL   ||  5 | dc872458  |   25 |  NULL | NULL   |+----+-----------+------+-------+--------+4 rows in set (0.000 sec)MariaDB [hello]&gt; alter table stu_test drop avatar;Query OK, 0 rows affected (0.034 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 ||  4 | 乐迪      |   32 | 99.00 ||  5 | dc872458  |   25 |  NULL |+----+-----------+------+-------+4 rows in set (0.000 sec)\n\n在具体场景中，如果需要给已有用户新增  头像，一般存放的是头像的文件路径（而不是图片），此时我们就可以设计一个默认头像，并在新增字段的时候将默认值（默认的头像文件路径）修改为这个默认头像图片的路径。\n比如我现在的头像存储的文件路径是\n./images/\n\n此时存放的用户头像文件就应该放到这个目录中，而 mysql 中只需要存放文件的路径。\n比如用户上传了一个头像图片，我们将头像图片保存到这个路径，再往 sql 中的 avatar 字段插入路径\n./images/test-img.pngsql 中只需要保存 test-img.png，取图片的时候拼接上前方的文件路径\n\n设计一个默认头像，也是放在这个路径中\n./images/test-img.png./images/default-avatar.png\n\n这时候新增 avatar 字段的时候，就可以指定默认值\nalter table stu_test add avatar varchar(100) not null default &#x27;default-avatar.png&#x27;  comment &#x27; 头像图片路径 &#x27; afterscore;\n\n这时候就能看到，旧数据的头像都是默认头像了！\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------------------+| id | name      | age  | score | avatar             |+----+-----------+------+-------+--------------------+|  2 | 小图图    |    5 | 72.80 | default-avatar.png ||  3 | 大司马    |   42 | 87.30 | default-avatar.png ||  4 | 乐迪      |   32 | 99.00 | default-avatar.png ||  5 | dc872458  |   25 |  NULL | default-avatar.png |+----+-----------+------+-------+--------------------+4 rows in set (0.000 sec)\n\n默认头像总好过没有图片嘛！\n2.5.3 修改字段类型  在设计 stu_test 表的时候，只给 name 分配了 30 个字节的空间。此时如果来了个名字特别特别长的新同学（有些地方的人名确实很长）\n我们发现 30 个字节存不下这个名字了，就可以考虑将名字字段的长度增加\nalter table stu_test modify name varchar(60);\n\n如下，成功修改！\nMariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+----------------+| Field  | Type         | Null | Key | Default            | Extra          |+--------+--------------+------+-----+--------------------+----------------+| id     | int(11)      | NO   | PRI | NULL               | auto_increment || name   | varchar(30)  | YES  |     | NULL               |                || age    | int(11)      | YES  |     | NULL               |                || score  | decimal(4,2) | YES  |     | NULL               |                || avatar | varchar(100) | NO   |     | default-avatar.png |                |+--------+--------------+------+-----+--------------------+----------------+5 rows in set (0.001 sec)MariaDB [hello]&gt; alter table stu_test modify name varchar(60);Query OK, 0 rows affected (0.013 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+----------------+| Field  | Type         | Null | Key | Default            | Extra          |+--------+--------------+------+-----+--------------------+----------------+| id     | int(11)      | NO   | PRI | NULL               | auto_increment || name   | varchar(60)  | YES  |     | NULL               |                || age    | int(11)      | YES  |     | NULL               |                || score  | decimal(4,2) | YES  |     | NULL               |                || avatar | varchar(100) | NO   |     | default-avatar.png |                |+--------+--------------+------+-----+--------------------+----------------+5 rows in set (0.001 sec)\n\n因为是增加字段的长度，所以也不影响已有数据\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------------------+| id | name      | age  | score | avatar             |+----+-----------+------+-------+--------------------+|  2 | 小图图    |    5 | 72.80 | default-avatar.png ||  3 | 大司马    |   42 | 87.30 | default-avatar.png ||  4 | 乐迪      |   32 | 99.00 | default-avatar.png ||  5 | dc872458  |   25 |  NULL | default-avatar.png |+----+-----------+------+-------+--------------------+4 rows in set (0.000 sec)\n\n如果是减小字段长度，就需要确认已有数据是否有超过新长度的内容了！比如从 60 减小到 30，那么长度为 40 的数据就会出现错误！\n那如果是将 varchar 直接改成 int，或者将 int 改成 char，会发生什么呢？\n表中的 id 字段是一个 int，尝试将其修改成 char\nalter table stu_test modify id varchar(32);\n\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------------------+| id | name      | age  | score | avatar             |+----+-----------+------+-------+--------------------+| 2  | 小图图    |    5 | 72.80 | default-avatar.png || 3  | 大司马    |   42 | 87.30 | default-avatar.png || 4  | 乐迪      |   32 | 99.00 | default-avatar.png || 5  | dc872458  |   25 |  NULL | default-avatar.png |+----+-----------+------+-------+--------------------+4 rows in set (0.001 sec)MariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+-------+| Field  | Type         | Null | Key | Default            | Extra |+--------+--------------+------+-----+--------------------+-------+| id     | varchar(32)  | NO   | PRI | NULL               |       || name   | varchar(60)  | YES  |     | NULL               |       || age    | int(11)      | YES  |     | NULL               |       || score  | decimal(4,2) | YES  |     | NULL               |       || avatar | varchar(100) | NO   |     | default-avatar.png |       |+--------+--------------+------+-----+--------------------+-------+5 rows in set (0.002 sec)\n\n可以看到，其不仅成功变成了字符串类型，已有的值也没有出错。毕竟 int 数字改成字符串是可行的。那反过来呢？\nMariaDB [hello]&gt; insert into stu_test (id,name,age,score,avatar) values (&#x27;kb&#x27;,&#x27; 你好 &#x27;,30,60,&#x27; 测试图片.png&#x27;);Query OK, 1 row affected (0.007 sec)MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------------------+| id | name      | age  | score | avatar             |+----+-----------+------+-------+--------------------+| 2  | 小图图    |    5 | 72.80 | default-avatar.png || 3  | 大司马    |   42 | 87.30 | default-avatar.png || 4  | 乐迪      |   32 | 99.00 | default-avatar.png || 5  | dc872458  |   25 |  NULL | default-avatar.png || kb | 你好      |   30 | 60.00 | 测试图片.png       |+----+-----------+------+-------+--------------------+5 rows in set (0.000 sec)\n\n此时我往表中插入了一个 id 为 kb 的数据，再尝试将 id 从 varchar 改回 int 类型\nMariaDB [hello]&gt; alter table stu_test modify id int;ERROR 1292 (22007): Truncated incorrect INTEGER value: &#x27;kb&#x27;MariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+-------+| Field  | Type         | Null | Key | Default            | Extra |+--------+--------------+------+-----+--------------------+-------+| id     | varchar(32)  | NO   | PRI | NULL               |       || name   | varchar(60)  | YES  |     | NULL               |       || age    | int(11)      | YES  |     | NULL               |       || score  | decimal(4,2) | YES  |     | NULL               |       || avatar | varchar(100) | NO   |     | default-avatar.png |       |+--------+--------------+------+-----+--------------------+-------+5 rows in set (0.001 sec)\n\n此时就会报错，kb不符合 int 类型；修改失败了！\n所以，修改字段的类型，需要保证原有类型和目标类型之间是可以正常双向转换的！\n2.5.4 修改字段名字  如下使用 change 修改字段id -&gt; num，同时还需要注明属性（也可以修改属性）\nalter table stu_test change id num varchar(32);\n\n这里可以看到 0 rows affected，因为我们修改的是字段名字而已，所以不会影响到数据\nMariaDB [hello]&gt; alter table stu_test change id num varchar(32);Query OK, 0 rows affected (0.008 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+-------+| Field  | Type         | Null | Key | Default            | Extra |+--------+--------------+------+-----+--------------------+-------+| num    | varchar(32)  | NO   | PRI | NULL               |       || name   | varchar(60)  | YES  |     | NULL               |       || age    | int(11)      | YES  |     | NULL               |       || score  | decimal(4,2) | YES  |     | NULL               |       || avatar | varchar(100) | NO   |     | default-avatar.png |       |+--------+--------------+------+-----+--------------------+-------+5 rows in set (0.001 sec)\n\n2.6 修改表名alter table stu_test rename stu;\n\n可以看到修改成功了\nMariaDB [hello]&gt; alter table stu_test rename stu;Query OK, 0 rows affected (0.015 sec)MariaDB [hello]&gt; show tables;+-----------------+| Tables_in_hello |+-----------------+| stu             || tb_video        |+-----------------+2 rows in set (0.000 sec)\n\n2.7 新增自增主键且不影响原有数据  新增了一个自增的 int id 主键到表内，可以使用如下命令\nALTER TABLE 表名 ADD id INT NOT NULL AUTO_INCREMENT PRIMARY KEY FIRST;\n\n2.8 表字段的约束  参考 【mysql 字段约束 】一文！建议看了这个之后再往下看。\n3. 数据记录  下方学习的都是数据操控语言DML；主要针对的就是表的增加删除修改和查询，简称 CRUD（增查改删）\nCreate   创建Retrieve 读取Update   更新Delete   删除\n\n在 MySQL 中，我们将一行新增的数据，称为  一条记录\n3.1 新增 Create要想往一个表里面插入数据，首先需要创建表（好像是一句废话）\n先使用如下表进行测试\nCREATE TABLE students (\tid INT UNSIGNED PRIMARY KEY AUTO_INCREMENT comment &#x27; 主键序号 &#x27;,\tsn INT NOT NULL UNIQUE COMMENT &#x27; 学号 &#x27;,\tname VARCHAR(20) NOT NULL COMMENT  &#x27; 学生名字 &#x27;,\tqq VARCHAR(20) COMMENT &#x27; 学生 QQ&#x27;);\n\n在学习插入之前，我们首先要会最基本的查询语句\nselect * from  表名; -- 显示表中的所有数据\n\n3.1.1 单行全列插入  所谓单行，代表一次只插入一条记录；\n所谓全列插入，代表插入这条数据的时候，将全部列的数据都手动指定。\ninsert into students values (1,1000,&#x27; 小明 &#x27;,&#x27;123124&#x27;);insert into students values (2,1001,&#x27; 小红 &#x27;,NULL);\n\n如上就是两个全列插入的示例；执行完毕这条 sql 的时候，MySQL 会显示 1 row affected，代表只有一行收到了影响（新增了一条记录）\nMariaDB [hello_mysql]&gt; insert into students values (1,1000,&#x27; 小明 &#x27;,&#x27;123124&#x27;);Query OK, 1 row affected (0.007 sec)MariaDB [hello_mysql]&gt; insert into students values (2,1001,&#x27; 小红 &#x27;,NULL);Query OK, 1 row affected (0.002 sec)\n\n查询表中数据，可以看到我们刚刚插入的记录\nMariaDB [hello_mysql]&gt; select * from students;+----+------+--------+--------+| id | sn   | name   | qq     |+----+------+--------+--------+|  1 | 1000 | 小明   | 123124 ||  2 | 1001 | 小红   | NULL   |+----+------+--------+--------+2 rows in set (0.001 sec)\n\n3.1.2 多行指定列插入  所谓多行插入，就是一次插入多条数据。指定列是在插入的时候，明确告诉 MySQL 我们想插入的列数是哪几个。\n需要注意的是，只要某一列没有 DEFAULT 值，如果不指定此列，则会被默认为 NULL；如果某一列设置了NOT NULL 并且没有设置 DEFAULT 值，那就必须要指定值，否则会报错。\n另外，指定的列的个数和 values 中数据的个数需要对应上。\nINSERT INTO students (id, sn, name) VALUES    (102, 20001, &#x27; 曹孟德 &#x27;),    (103, 20002, &#x27; 孙仲谋 &#x27;);\n\n执行效果如下\nMariaDB [hello_mysql]&gt; INSERT INTO students (id, sn, name) VALUES    -&gt;     (102, 20001, &#x27; 曹孟德 &#x27;),    -&gt;     (103, 20002, &#x27; 孙仲谋 &#x27;);Query OK, 2 rows affected (0.013 sec)Records: 2  Duplicates: 0  Warnings: 0MariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 |  1000 | 小明      | 123124 ||   2 |  1001 | 小红      | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)\n\n3.1.3 插入否则更新  如果我们往表里面插入一个已经存在的主键 &#x2F; 唯一键的值，就会出现主键 &#x2F; 唯一键冲突而导致的拒绝插入。\nMariaDB [hello_mysql]&gt; insert into students values (1,1003,&#x27; 李华 &#x27;,&#x27;12354&#x27;);ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;MariaDB [hello_mysql]&gt; insert into students values (5,1000,&#x27; 小可 &#x27;,&#x27;53134&#x27;);ERROR 1062 (23000): Duplicate entry &#x27;1000&#x27; for key &#x27;sn&#x27;\n\n此时我们可以根据具体情况，将插入改成  插入否则更新，即如果主键和唯一键冲突，则更新已有记录。不冲突则正常插入；\n这样就可以把插入和更新的语句给统一成一个。但需要避免出现明明是要插入一个新的，但却因为主键设置错误而更新了旧值，导致记录丢失，那样就不好了。\n插入否则更新的语法是下面这样\nINSERT ... ON DUPLICATE KEY UPDATE column = value [, column = value] ...\n\n示例如下，这个语句的意思是，如果唯一键和主键没有冲突，则插入 (100, 10010, &#39; 唐大师 &#39;)的记录，如果 id 和 sn 冲突了，则将 sn 更新为 10010，name 更新为唐大师。\nINSERT INTO students (id, sn, name) VALUES (1, 10010, &#x27; 唐大师 &#x27;)\tON DUPLICATE KEY UPDATE sn = 10010, name = &#x27; 唐大师 &#x27;;\n\n执行的效果如下，执行后，可以看到第一行记录因为主键冲突，而更新了这条记录的 sn 和 name\nMariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 |  1000 | 小明      | 123124 ||   2 |  1001 | 小红      | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; INSERT INTO students (id, sn, name) VALUES (1, 10010, &#x27; 唐大师 &#x27;)    -&gt; ON DUPLICATE KEY UPDATE sn = 10010, name = &#x27; 唐大师 &#x27;;Query OK, 2 rows affected (0.001 sec)MariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 ||   2 |  1001 | 小红      | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)\n\n唯一键冲突的时候，也是一样的效果，下图中是唯一键 sn 与原有的第二条记录冲突，最终将第二条记录的 sn 和 name 做了更新。\nMariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 ||   2 |  1001 | 小红      | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; INSERT INTO students (id, sn, name) VALUES (3, 1001, &#x27; 唐大师 2&#x27;) ON DUPLICATE KEY UPDATE sn = 1005, name = &#x27; 唐大师 &#x27;;Query OK, 2 rows affected (0.001 sec)MariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 ||   2 |  1005 | 唐大师    | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)\n\n需要注意的是，在 UPDATE 语句之后的 sn 也不能和已有的 sn 冲突，不然会因为唯一键冲突（因为你需要更新到这个值，而这个值已有了）而拒绝更新\nMariaDB [hello_mysql]&gt; INSERT INTO students (id, sn, name) VALUES (3, 1001, &#x27; 唐大师 2&#x27;) ON DUPLICATE KEY UPDATE sn = 10010, name = &#x27; 唐大师 &#x27;;ERROR 1062 (23000): Duplicate entry &#x27;10010&#x27; for key &#x27;sn&#x27;\n\n3.1.4 替换 Replace除了上面那种更新的方式，我们还有一个替换语句可以用来  替换  值\n\n如果没有冲突则直接插入\n如果已经冲突了则删除原有的记录，然后再插入\n\n这里要注意替换和  插入否则更新  的区别！插入否则更新  是需要你指定要更新那些列的数据，而替换是会直接将原视数据删除的！\n下面给出两条 sql 语句，其中第一条没有冲突，第二条的 sn 冲突\n-- 无冲突REPLACE INTO students (sn,name) VALUES (20000,&#x27; 闰土 &#x27;);-- 有冲突REPLACE INTO students (sn,name) VALUES (1005,&#x27; 周树人 &#x27;);\n\n先执行第一个 sql，可以看到返回的是 1 行受到影响，代表数据被插入\nMariaDB [hello_mysql]&gt; REPLACE INTO students (sn,name) VALUES (20000,&#x27; 闰土 &#x27;);Query OK, 1 row affected (0.001 sec)\n\n再执行有冲突的，可以看到是 2 行受影响，因为这条语句会删除原有的再插入，相当于执行了一次删除和一次插入，影响了两行的数据。\nMariaDB [hello_mysql]&gt; REPLACE INTO students (sn,name) VALUES (1005,&#x27; 周树人 &#x27;);Query OK, 2 rows affected (0.001 sec)\n\n3.2 查询 Retrieve查询的基础语法如下\nSELECT    [DISTINCT] &#123;* | &#123;column [, column] ...&#125;    [FROM table_name]    [WHERE ...]    [ORDER BY column [ASC | DESC], ...]    LIMIT ...\n\n3.2.1 全列查询  用通配符 * 表示查询整个表的数据\nselect * from  students;\n\n该语句会查表中的所有值，在前面我们已经接触过了\nMariaDB [hello_mysql]&gt; select * from  students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   || 104 | 20000 | 闰土      | NULL   || 105 |  1005 | 周树人    | NULL   |+-----+-------+-----------+--------+5 rows in set (0.000 sec)\n\n  不过一般情况下不建议用全列查询：\n\n查询的列越多，意味着需要传输的数据量越大； \n可能会影响到索引的使用（后续会学习到）\n\n3.2.2 指定列查询  所谓指定列，就是在查询的时候返回特定的列，比如如下就是在学生表里面返回 sn 和 name 这两列的数据\nselect sn,name from  students;\n\n执行效果如下，最终只显示了我们指定的两个列，并没有把 id 和 qq 列也给展示出来\nMariaDB [hello_mysql]&gt; select sn,name from  students;+-------+-----------+| sn    | name      |+-------+-----------+| 10010 | 唐大师    || 20001 | 曹孟德    || 20002 | 孙仲谋    || 20000 | 闰土      ||  1005 | 周树人    |+-------+-----------+5 rows in set (0.000 sec)\n\n3.2.3 表达式查询  为了进行后续的学习，我们先来构造一个测试表\n-- 表创建CREATE TABLE exam_result (    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20) NOT NULL COMMENT &#x27; 同学姓名 &#x27;,    chinese float DEFAULT 0.0 COMMENT &#x27; 语文成绩 &#x27;,    math float DEFAULT 0.0 COMMENT &#x27; 数学成绩 &#x27;,    english float DEFAULT 0.0 COMMENT &#x27; 英语成绩 &#x27;);-- 插入多行测试数据INSERT INTO exam_result (name, chinese, math, english) VALUES    (&#x27; 唐三藏 &#x27;, 67, 98, 56),    (&#x27; 孙悟空 &#x27;, 87, 78, 77),    (&#x27; 猪悟能 &#x27;, 88, 98, 90),    (&#x27; 曹孟德 &#x27;, 82, 84, 67),    (&#x27; 刘玄德 &#x27;, 55, 85, 45),    (&#x27; 孙权 &#x27;, 70, 73, 78),    (&#x27; 宋公明 &#x27;, 75, 65, 30);\n\n在前面两种查询中，我们都只是查询表里面已经有的数据，但实际上我们在查询结果展示的时候，还可以让 MySQL 帮我们完成一定的表达式计算\nselect id,name,english,10 from exam_result;\n\n比如如上的 sql，我们在原本的指定列查询后新增了一个 10，这个 10 就是一个表达式，它并不包含表中已经有的字段，所以会拼接在表的原有数据之后展示出来\nMariaDB [hello_mysql]&gt; select id,name,english,10 from exam_result;+----+-----------+---------+----+| id | name      | english | 10 |+----+-----------+---------+----+|  1 | 唐三藏    |      56 | 10 ||  2 | 孙悟空    |      77 | 10 ||  3 | 猪悟能    |      90 | 10 ||  4 | 曹孟德    |      67 | 10 ||  5 | 刘玄德    |      45 | 10 ||  6 | 孙权      |      78 | 10 ||  7 | 宋公明    |      30 | 10 |+----+-----------+---------+----+7 rows in set (0.000 sec)\n\n在这里写个算式，MySQL 也会帮我们计算并展示出来\nMariaDB [hello_mysql]&gt; select id,name,english,10+20 from exam_result;+----+-----------+---------+-------+| id | name      | english | 10+20 |+----+-----------+---------+-------+|  1 | 唐三藏    |      56 |    30 ||  2 | 孙悟空    |      77 |    30 ||  3 | 猪悟能    |      90 |    30 ||  4 | 曹孟德    |      67 |    30 ||  5 | 刘玄德    |      45 |    30 ||  6 | 孙权      |      78 |    30 ||  7 | 宋公明    |      30 |    30 |+----+-----------+---------+-------+7 rows in set (0.001 sec)\n\n这时候我们就可以在返回结果的时候，对原视的数据做一些处理，比如将数学和英语成绩给加起来返回\nMariaDB [hello_mysql]&gt; select id,name,english+math from exam_result;+----+-----------+--------------+| id | name      | english+math |+----+-----------+--------------+|  1 | 唐三藏    |          154 ||  2 | 孙悟空    |          155 ||  3 | 猪悟能    |          188 ||  4 | 曹孟德    |          151 ||  5 | 刘玄德    |          130 ||  6 | 孙权      |          151 ||  7 | 宋公明    |           95 |+----+-----------+--------------+7 rows in set (0.000 sec)\n\n3.2.4 为表达式设置别名  在表达式查询的时候，我们可以给表达式设置一些别名来提高可读性，基础语法如下\nSELECT column [AS] alias_name [...] FROM table_name;\n\n比如当我们将三科总分加起来返回的时候，就可以将其设置一个总分别名来返回\nMariaDB [hello_mysql]&gt; select id,name,chinese+english+math as &#x27; 总分 &#x27; from exam_result;+----+-----------+--------+| id | name      | 总分   |+----+-----------+--------+|  1 | 唐三藏    |    221 ||  2 | 孙悟空    |    242 ||  3 | 猪悟能    |    276 ||  4 | 曹孟德    |    233 ||  5 | 刘玄德    |    185 ||  6 | 孙权      |    221 ||  7 | 宋公明    |    170 |+----+-----------+--------+7 rows in set (0.000 sec)\n\n此时 MySQL 展示的是总分，而不是原视表达式，可读性更好！\n3.2.5 结果去重 distinct有的时候我们想知道班里同学的成绩都有那些分段，并不想看到底是谁考出来的。此时就可以使用 distinct 去重查询过滤出不重复的一个集和并展示出来\nselect distinct math from exam_result;\n\n如上语句就是在展示 math 列的结果的时候对结果进行去重，原本的数据中 98 分是重复的，添加上这个关键字后，重复的 98 就被去掉了。\nMariaDB [hello_mysql]&gt; select math from exam_result;+------+| math |+------+|   98 ||   78 ||   98 ||   84 ||   85 ||   73 ||   65 |+------+7 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; select distinct math from exam_result;+------+| math |+------+|   98 ||   78 ||   84 ||   85 ||   73 ||   65 |+------+6 rows in set (0.001 sec)\n\n3.2.6 where 条件查询  运算符  说完了基本的查询，就得来看大头条件查询了，基本用法是在表名后用 where 带上具体条件。在那之前，先来看看 where 支持什么比较运算符吧\n\n\n\n比较运算符\n说明\n\n\n\n&gt;,&gt;=,&lt;,&lt;=\n这个应该不需要说吧\n\n\n=\n等于，NULL 不安全，NULL=NULL的结果是 NULL\n\n\n&lt;=&gt;\n等于，NULL 安全，NULL&lt;=&gt;NULL的结果是 TRUE(1)\n\n\n!=,&lt;&gt;\n不等于\n\n\nBETWEEN a AND b\n范围匹配，闭区间，如果 a&lt;=value&lt;=b返回 TRUE(1)\n\n\nIN (option,...)\n如果是 option 中的任意一个，则返回 TRUE(1)\n\n\nIS NULL\n是 NULL\n\n\nIS NOT NULL\n不是 NULL\n\n\nLIKE\n模糊匹配，%表示任意多个（包括 0 个）字符；_表示任意一个字符；\n\n\n除了比较的运算符，还有  逻辑  运算符\n\n\n\n逻辑运算符号\n说明\n\n\n\nAND\n与，相当于 cpp 中的&amp;&amp;，全真为 1，有假为 0\n\n\nOR\n或，相当于 cpp 中的 &#96;\n\n\nNOT\n逻辑取反，条件为 TRUE(1) 的时候结果为FALSE(0)\n\n\n大于小于和区间筛选  比如最基础的，查询成绩表里面某科成绩低于多少分的用户\nselect name,english from exam_result where english &lt; 60;\n\n运行结果如下，成功展示出来了英语成绩小于 60 分的人\nMariaDB [hello_mysql]&gt; select name,english from exam_result where english &lt; 60;+-----------+---------+| name      | english |+-----------+---------+| 唐三藏    |      56 || 刘玄德    |      45 || 宋公明    |      30 |+-----------+---------+3 rows in set (0.000 sec)\n\n我们还可以用 and 进行拼接多个条件\nselect name,chinese,english from exam_result where english &lt; 60 and chinese &lt; 60;\n\n比如如上 sql 是查询英语和语文都不及格的人\nMariaDB [hello_mysql]&gt; select name,chinese,english from exam_result where english &lt; 60 and chinese &lt; 60;+-----------+---------+---------+| name      | chinese | english |+-----------+---------+---------+| 刘玄德    |      55 |      45 |+-----------+---------+---------+1 row in set (0.000 sec)\n\n还有查询语文成绩在 [30,60] 区间的人\nMariaDB [hello_mysql]&gt; select name,chinese from exam_result where chinese between 30 and 65;+-----------+---------+| name      | chinese |+-----------+---------+| 刘玄德    |      55 |+-----------+---------+1 row in set (0.000 sec)\n\n当然，大于小于的比较也可以用于两个字段之间的比较，比如如下筛选出语文比英语好的同学\nMariaDB [hello_mysql]&gt; SELECT name, chinese, english FROM exam_result WHERE chinese &gt; english;+-----------+---------+---------+| name      | chinese | english |+-----------+---------+---------+| 唐三藏    |      67 |      56 || 孙悟空    |      87 |      77 || 曹孟德    |      82 |      67 || 刘玄德    |      55 |      45 || 宋公明    |      75 |      30 |+-----------+---------+---------+5 rows in set (0.000 sec)\n\n相等筛选select name,math from exam_result where math = 50 or math = 59 or math = 98 or math = 99;\n\n如上语句可以帮我们筛选出数学成绩等于 50、59、98、99 其中一个的学生\nMariaDB [hello_mysql]&gt; select name,math from exam_result where math = 50 or math = 59 or math = 98 or math = 99;+-----------+------+| name      | math |+-----------+------+| 唐三藏    |   98 || 猪悟能    |   98 |+-----------+------+2 rows in set (0.000 sec)\n\n和这个语句相同效果的，还有如下的 in 运算符\nMariaDB [hello_mysql]&gt; select name,math from exam_result where math in (50,59,98,99);+-----------+------+| name      | math |+-----------+------+| 唐三藏    |   98 || 猪悟能    |   98 |+-----------+------+2 rows in set (0.001 sec)\n\n字符匹配 LIKE-- % 匹配多个字符，如下语句代表匹配名字为孙开头的人select name from exam_result where name LIKE &#x27; 孙 %&#x27;;-- _ 匹配单个字符，如下语句代表匹配名字开头为孙，但只有两个字的人select name from exam_result where name LIKE &#x27; 孙_&#x27;;\n\n效果如下，可以看到在第二个单字匹配的时候，就没有将孙悟空也匹配进去\nMariaDB [hello_mysql]&gt; select name from exam_result where name LIKE &#x27; 孙 %&#x27;;+-----------+| name      |+-----------+| 孙悟空    || 孙权      |+-----------+2 rows in set (0.013 sec)MariaDB [hello_mysql]&gt; select name from exam_result where name LIKE &#x27; 孙_&#x27;;+--------+| name   |+--------+| 孙权   |+--------+1 row in set (0.000 sec)\n\n如下语句可以筛选出语文成绩大于 80 分且不姓孙的同学，同时用到了 and 和 not\nMariaDB [hello_mysql]&gt; SELECT name, chinese FROM exam_result    -&gt; WHERE chinese &gt; 80 AND name NOT LIKE &#x27; 孙 %&#x27;;+-----------+---------+| name      | chinese |+-----------+---------+| 猪悟能    |      88 || 曹孟德    |      82 |+-----------+---------+2 rows in set (0.000 sec)\n\n计算后筛选  上面我们筛选的都是字段本身，但我们还可以将一些字段加起来之后再进行筛选；\nMariaDB [hello_mysql]&gt; SELECT name, chinese + math + english 总分 FROM exam_result WHERE chinese + math + english &lt; 200;+-----------+--------+| name      | 总分   |+-----------+--------+| 刘玄德    |    185 || 宋公明    |    170 |+-----------+--------+2 rows in set (0.000 sec)\n\n需要注意的是，这里虽然我们给三科分数加起来设置了别名，但是别名是不能在 where 条件中使用的！你可以理解为别名其实只是最终显示结果的时候被修改了，在查询的过程中别名实际上并没有生效！\nMariaDB [hello_mysql]&gt; SELECT name, chinese + math + english 总分 FROM exam_result WHERE 总分 &lt; 200;ERROR 1054 (42S22): Unknown column &#x27; 总分 &#x27; in &#x27;where clause&#x27;\n\nNULL 的查询  在之前的 students 表中，我们有些记录的 qq 号是 NULL，这时候应该使用 IS NULL/IS NOT NULL来进行针对 NULL 的查询\n-- qq 号不是空的人MariaDB [hello_mysql]&gt; select * from students where qq is not null;+----+-------+-----------+--------+| id | sn    | name      | qq     |+----+-------+-----------+--------+|  1 | 10010 | 唐大师    | 123124 |+----+-------+-----------+--------+1 row in set (0.000 sec)-- qq 号是空的人MariaDB [hello_mysql]&gt; select * from students where qq is null;+-----+-------+-----------+------+| id  | sn    | name      | qq   |+-----+-------+-----------+------+| 102 | 20001 | 曹孟德    | NULL || 103 | 20002 | 孙仲谋    | NULL || 104 | 20000 | 闰土      | NULL || 105 |  1005 | 周树人    | NULL |+-----+-------+-----------+------+4 rows in set (0.000 sec)\n\n这里我们还可以试验一下 =和 &lt;=&gt; 的不同，前文提到，=是 NULL 不安全的，这是因为NULL=NULL 为 NULL，而我们预期的结果应该是TRUE(1)。\n从测试可以看出，使用 = 筛选出来的是空的，因为 NULL 在 MySQL 中认为是假，无法正常进行判断，而使用 &lt;=&gt;的成功筛选出了正确的结果\nMariaDB [hello_mysql]&gt; select * from students where qq = null;Empty set (0.000 sec)MariaDB [hello_mysql]&gt; select * from students where qq &lt;=&gt; null;+-----+-------+-----------+------+| id  | sn    | name      | qq   |+-----+-------+-----------+------+| 102 | 20001 | 曹孟德    | NULL || 103 | 20002 | 孙仲谋    | NULL || 104 | 20000 | 闰土      | NULL || 105 |  1005 | 周树人    | NULL |+-----+-------+-----------+------+4 rows in set (0.000 sec)\n\n同时我们可以将 NULL 和 01 进行一下对比，也能看出来 NULL 的特殊性；NULL 和我们认识的真 1 与假 0 没有关系，其为一个独立的特殊值，NULL 只能用来和 NULL 进行比较。\nMariaDB [hello_mysql]&gt; SELECT NULL &lt;=&gt; NULL, NULL &lt;=&gt; 1, NULL &lt;=&gt; 0;+---------------+------------+------------+| NULL &lt;=&gt; NULL | NULL &lt;=&gt; 1 | NULL &lt;=&gt; 0 |+---------------+------------+------------+|             1 |          0 |          0 |+---------------+------------+------------+1 row in set (0.000 sec)MariaDB [hello_mysql]&gt; SELECT NULL = NULL, NULL = 1, NULL = 0;+-------------+----------+----------+| NULL = NULL | NULL = 1 | NULL = 0 |+-------------+----------+----------+|        NULL |     NULL |     NULL |+-------------+----------+----------+1 row in set (0.000 sec)\n\n查询条件不一定需要显示  如下，我们使用了 math 作为查询的条件，但最终展示的结果里面并没有 math，这也是被允许的。\nMariaDB [hello_mysql]&gt; select name,chinese from exam_result where math &gt; 70;+-----------+---------+| name      | chinese |+-----------+---------+| 唐三藏    |      67 || 孙悟空    |      87 || 猪悟能    |      88 || 曹孟德    |      82 || 刘玄德    |      55 || 孙权      |      70 |+-----------+---------+6 rows in set (0.012 sec)\n\n3.2.7 结果排序  在很多时候，我们除了想获取到指定的结果，还希望对结果进行一定的排序，以筛选出更加精细的数据\n-- ASC  为升序（从小到大）-- DESC 为降序（从大到小）-- ORDER BY 默认为 ASCSELECT ... FROM table_name [WHERE ...]\tORDER BY column [ASC|DESC], [...];\n\n注意：没有 ORDER BY 子句的查询，返回的顺序是  未定义  的（乱序）；\n如果某个值是 NULL，那它比任何值都  小！\n单字段升序 &#x2F; 降序显示SELECT name, math FROM exam_result ORDER BY math; -- 默认升序SELECT name, math FROM exam_result ORDER BY math DESC; -- 降序\n\n使用这个语句，可以让结果以某个字段的升序或者降序来显示；\nMariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result ORDER BY math;+-----------+------+| name      | math |+-----------+------+| 宋公明    |   65 || 孙权      |   73 || 孙悟空    |   78 || 曹孟德    |   84 || 刘玄德    |   85 || 唐三藏    |   98 || 猪悟能    |   98 |+-----------+------+7 rows in set (0.012 sec)MariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result ORDER BY math DESC;+-----------+------+| name      | math |+-----------+------+| 唐三藏    |   98 || 猪悟能    |   98 || 刘玄德    |   85 || 曹孟德    |   84 || 孙悟空    |   78 || 孙权      |   73 || 宋公明    |   65 |+-----------+------+7 rows in set (0.000 sec)\n\nNULL 比所有字段都小，比如下方排序的时候，NULL 会显示在已有数据的下面；\nMySQL 对字符串的排序是按  字典序  的！会根据字符的 Unicode 值进行字典顺序的比较；\nMariaDB [hello_mysql]&gt; select name,qq from students order by qq desc;+-----------+--------+| name      | qq     |+-----------+--------+| 唐大师    | 123124 || 曹孟德    | NULL   || 孙仲谋    | NULL   || 闰土      | NULL   || 周树人    | NULL   |+-----------+--------+5 rows in set (0.001 sec)\n\n排序的键值不一定需要出现在 select 的指定列中，如下我们最终返回的结果并没有 qq，但依旧可以通过 qq 进行排序\nMariaDB [hello_mysql]&gt; select name from students order by qq desc;+-----------+| name      |+-----------+| 唐大师    || 曹孟德    || 孙仲谋    || 闰土      || 周树人    |+-----------+5 rows in set (0.000 sec)\n\n多字段排序  多字段排序中，排序的优先级依照这里的  书写顺序；\n比如下面的语句就会先按数学进行降序排序，再按英语进行升序排序，最后按语文进行升序排序\nSELECT name, math, english, chinese FROM exam_result\tORDER BY math DESC, english, chinese;\n\n效果如下\nMariaDB [hello_mysql]&gt; SELECT name, math, english, chinese FROM exam_result    -&gt; ORDER BY math DESC, english, chinese;+-----------+------+---------+---------+| name      | math | english | chinese |+-----------+------+---------+---------+| 唐三藏    |   98 |      56 |      67 || 猪悟能    |   98 |      90 |      88 || 刘玄德    |   85 |      45 |      55 || 曹孟德    |   84 |      67 |      82 || 孙悟空    |   78 |      77 |      87 || 孙权      |   73 |      78 |      70 || 宋公明    |   65 |      30 |      75 |+-----------+------+---------+---------+7 rows in set (0.000 sec)\n\n求和后排序  在 ORDER BY 里面是支持表达式的，也支持别名\n-- 表达式SELECT name, chinese + english + math FROM exam_result\tORDER BY chinese + english + math DESC;-- 别名SELECT name, chinese + english + math 总分 FROM exam_result\tORDER BY 总分 DESC;\n\n效果如下\nMariaDB [hello_mysql]&gt; SELECT name, chinese + english + math FROM exam_result    -&gt; ORDER BY chinese + english + math DESC;+-----------+--------------------------+| name      | chinese + english + math |+-----------+--------------------------+| 猪悟能    |                      276 || 孙悟空    |                      242 || 曹孟德    |                      233 || 唐三藏    |                      221 || 孙权      |                      221 || 刘玄德    |                      185 || 宋公明    |                      170 |+-----------+--------------------------+7 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; SELECT name, chinese + english + math 总分 FROM exam_result    -&gt; ORDER BY 总分 DESC;+-----------+--------+| name      | 总分   |+-----------+--------+| 猪悟能    |    276 || 孙悟空    |    242 || 曹孟德    |    233 || 唐三藏    |    221 || 孙权      |    221 || 刘玄德    |    185 || 宋公明    |    170 |+-----------+--------+7 rows in set (0.000 sec)\n\nwhere+orderbywhere 条件语句和排序语句联合使用\nSELECT name, math FROM exam_result\tWHERE name LIKE &#x27; 孙 %&#x27; OR name LIKE &#x27; 曹 %&#x27;\tORDER BY math DESC;\n\nMariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result    -&gt; WHERE name LIKE &#x27; 孙 %&#x27; OR name LIKE &#x27; 曹 %&#x27;    -&gt; ORDER BY math DESC;+-----------+------+| name      | math |+-----------+------+| 曹孟德    |   84 || 孙悟空    |   78 || 孙权      |   73 |+-----------+------+3 rows in set (0.001 sec)\n\n3.2.8 筛选分页结果  对表的筛选结果进行分页的语句格式如下\n-- 起始下标为 0-- 从 0 开始，筛选 n 条结果SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n;-- 从 s 开始，筛选 n 条结果SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT s, n;-- 从 s 开始，筛选 n 条结果，比第二种用法更明确，建议使用SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n OFFSET s;\n\n为什么需要分页？\n假设一个表里面有上千万条数据，如果你使用 select * from 表 进行全列查询，那可能 MySQL 数据库就会因为要一次性给你返回大量数据而卡死，直接影响其他应用使用该数据库，导致服务宕机！\n所以，在查询一个未知表的时候，建议先使用 desc 查看表结构，在再加上一个LIMIT 1，来查看很少的几条数据，并对数据进行人为分析，确定这个表的功能；\n\n当然，在项目合作中，肯定需要有人编写文档来说明这些表的作用，遇到这种情况，应该先去查项目文档再进行操作。\n\nSELECT id, name, math, english, chinese FROM exam_result\tORDER BY id LIMIT 3 OFFSET 0;\n\n上面的语句的意思是，从偏移量为 0 的未知（即表开头）筛选出 3 个数据；最终展示的就只有 3 条数据\nMariaDB [hello_mysql]&gt; SELECT id, name, math, english, chinese FROM exam_result    -&gt; ORDER BY id LIMIT 3 OFFSET 0;+----+-----------+------+---------+---------+| id | name      | math | english | chinese |+----+-----------+------+---------+---------+|  1 | 唐三藏    |   98 |      56 |      67 ||  2 | 孙悟空    |   78 |      77 |      87 ||  3 | 猪悟能    |   98 |      90 |      88 |+----+-----------+------+---------+---------+3 rows in set (0.000 sec)\n\n修改 offset，可以通过 id 看到数据的变化\nMariaDB [hello_mysql]&gt; SELECT id, name, math, english, chinese FROM exam_result    -&gt; ORDER BY id LIMIT 3 OFFSET 4;+----+-----------+------+---------+---------+| id | name      | math | english | chinese |+----+-----------+------+---------+---------+|  5 | 刘玄德    |   85 |      45 |      55 ||  6 | 孙权      |   73 |      78 |      70 ||  7 | 宋公明    |   65 |      30 |      75 |+----+-----------+------+---------+---------+3 rows in set (0.001 sec)\n\n如果 offset 后并没有 3 个数据，也不会出问题，能正常显示出来\nMariaDB [hello_mysql]&gt; SELECT id, name, math, english, chinese FROM exam_result ORDER BY id LIMIT 3 OFFSET 6;+----+-----------+------+---------+---------+| id | name      | math | english | chinese |+----+-----------+------+---------+---------+|  7 | 宋公明    |   65 |      30 |      75 |+----+-----------+------+---------+---------+1 row in set (0.001 sec)\n\n如果 offset 大于表中已有数据数量，那就会显示空，并不会执行出错！\nMariaDB [hello_mysql]&gt; SELECT id, name, math, english, chinese FROM exam_result ORDER BY id LIMIT 3 OFFSET 10;Empty set (0.001 sec)\n\n3.2.9 执行顺序  在执行这些 sql 语句中的语法的时候，MySQL 是会有一个执行顺序的\n\n先通过 from 表从表中  拿到数据\n再通过 where 的条件  筛选  数据\n根据 SELECT 子句中指定的列，MySQL 最终确定要返回的数据；\n筛选完毕最终需要显示的数据后，根据 order by 对数据进行  排序 ； 排序可以使用别名；排序的字段不一定需要出现在 select 指定的列中；\n如果查询包含 DISTINCT 关键字，MySQL 会进行去重操作，确保结果集中的行是唯一的；\n\n在后文讲到聚合语句的时候，还会重谈一遍执行顺序\n3.3 更新 UpdateUPDATE 表名 SET 字段名 = 新值 WHERE 查询条件...;\n\n3.3.1 更新单个记录-- 查看原视数据MariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result WHERE name = &#x27; 孙悟空 &#x27;;+-----------+------+| name      | math |+-----------+------+| 孙悟空    |   78 |+-----------+------+1 row in set (0.000 sec)-- 更新数据MariaDB [hello_mysql]&gt; UPDATE exam_result SET math = 80 WHERE name = &#x27; 孙悟空 &#x27;;Query OK, 1 row affected (0.019 sec)Rows matched: 1  Changed: 1  Warnings: 0-- 再次查看结果，成功更新MariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result WHERE name = &#x27; 孙悟空 &#x27;;+-----------+------+| name      | math |+-----------+------+| 孙悟空    |   80 |+-----------+------+1 row in set (0.000 sec)\n\n3.3.2 一次更新多列MariaDB [hello_mysql]&gt; SELECT name, math, chinese FROM exam_result WHERE name = &#x27; 曹孟德 &#x27;;+-----------+------+---------+| name      | math | chinese |+-----------+------+---------+| 曹孟德    |   84 |      82 |+-----------+------+---------+1 row in set (0.001 sec)-- 一次更新多列 MariaDB [hello_mysql]&gt; UPDATE exam_result SET math = 60, chinese = 70 WHERE name = &#x27; 曹孟德 &#x27;;Query OK, 1 row affected (0.001 sec)Rows matched: 1  Changed: 1  Warnings: 0MariaDB [hello_mysql]&gt; SELECT name, math, chinese FROM exam_result WHERE name = &#x27; 曹孟德 &#x27;;+-----------+------+---------+| name      | math | chinese |+-----------+------+---------+| 曹孟德    |   60 |      70 |+-----------+------+---------+1 row in set (0.000 sec)\n\n3.3.3 将总成绩倒数前三的数学成绩加上 30 分-- 查看元数据SELECT name, math, chinese + math + english 总分 FROM exam_result\tORDER BY 总分 LIMIT 3;-- 更新，需要注意不支持 += 这种运算符UPDATE exam_result SET math = math + 30\tORDER BY chinese + math + english LIMIT 3;-- 查看更新后结果SELECT name, math, chinese + math + english 总分 FROM exam_result\tWHERE name IN (&#x27; 宋公明 &#x27;, &#x27; 刘玄德 &#x27;, &#x27; 曹孟德 &#x27;);-- 按总成绩排序后结果SELECT name, math, chinese + math + english 总分 FROM exam_result\tORDER BY 总分 LIMIT 3;\n\n结果如下\nMariaDB [hello_mysql]&gt; SELECT name, math, chinese + math + english 总分 FROM exam_result    -&gt; ORDER BY 总分 LIMIT 3;+-----------+------+--------+| name      | math | 总分   |+-----------+------+--------+| 宋公明    |   65 |    170 || 刘玄德    |   85 |    185 || 曹孟德    |   60 |    197 |+-----------+------+--------+3 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; UPDATE exam_result SET math = math + 30    -&gt; ORDER BY chinese + math + english LIMIT 3;Query OK, 3 rows affected (0.043 sec)Rows matched: 3  Changed: 3  Warnings: 0MariaDB [hello_mysql]&gt; SELECT name, math, chinese + math + english 总分 FROM exam_result    -&gt; WHERE name IN (&#x27; 宋公明 &#x27;, &#x27; 刘玄德 &#x27;, &#x27; 曹孟德 &#x27;);+-----------+------+--------+| name      | math | 总分   |+-----------+------+--------+| 曹孟德    |   90 |    227 || 刘玄德    |  115 |    215 || 宋公明    |   95 |    200 |+-----------+------+--------+3 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; SELECT name, math, chinese + math + english 总分 FROM exam_result    -&gt; ORDER BY 总分 LIMIT 3;+-----------+------+--------+| name      | math | 总分   |+-----------+------+--------+| 宋公明    |   95 |    200 || 刘玄德    |  115 |    215 || 唐三藏    |   98 |    221 |+-----------+------+--------+3 rows in set (0.000 sec)\n\n3.3.4 将所有同学的语文成绩更新为原有的 2 倍MariaDB [hello_mysql]&gt; SELECT * FROM exam_result;+----+-----------+---------+------+---------+| id | name      | chinese | math | english |+----+-----------+---------+------+---------+|  1 | 唐三藏    |      67 |   98 |      56 ||  2 | 孙悟空    |      87 |   80 |      77 ||  3 | 猪悟能    |      88 |   98 |      90 ||  4 | 曹孟德    |      70 |   90 |      67 ||  5 | 刘玄德    |      55 |  115 |      45 ||  6 | 孙权      |      70 |   73 |      78 ||  7 | 宋公明    |      75 |   95 |      30 |+----+-----------+---------+------+---------+7 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; UPDATE exam_result SET chinese = chinese * 2;Query OK, 7 rows affected (0.001 sec)Rows matched: 7  Changed: 7  Warnings: 0MariaDB [hello_mysql]&gt; SELECT * FROM exam_result;+----+-----------+---------+------+---------+| id | name      | chinese | math | english |+----+-----------+---------+------+---------+|  1 | 唐三藏    |     134 |   98 |      56 ||  2 | 孙悟空    |     174 |   80 |      77 ||  3 | 猪悟能    |     176 |   98 |      90 ||  4 | 曹孟德    |     140 |   90 |      67 ||  5 | 刘玄德    |     110 |  115 |      45 ||  6 | 孙权      |     140 |   73 |      78 ||  7 | 宋公明    |     150 |   95 |      30 |+----+-----------+---------+------+---------+7 rows in set (0.000 sec)\n\n更新语句的基本操作就只有这些！\n3.4 删除 Delete语法\nDELETE FROM table_name [WHERE ...] [ORDER BY ...] [LIMIT ...]\n\n3.4.1 删除孙悟空的考试成绩DELETE FROM exam_result WHERE name = &#x27; 孙悟空 &#x27;;\n\n效果\nMariaDB [hello_mysql]&gt; SELECT * FROM exam_result;+----+-----------+---------+------+---------+| id | name      | chinese | math | english |+----+-----------+---------+------+---------+|  1 | 唐三藏    |     134 |   98 |      56 ||  2 | 孙悟空    |     174 |   80 |      77 ||  3 | 猪悟能    |     176 |   98 |      90 ||  4 | 曹孟德    |     140 |   90 |      67 ||  5 | 刘玄德    |     110 |  115 |      45 ||  6 | 孙权      |     140 |   73 |      78 ||  7 | 宋公明    |     150 |   95 |      30 |+----+-----------+---------+------+---------+7 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; DELETE FROM exam_result WHERE name = &#x27; 孙悟空 &#x27;;Query OK, 1 row affected (0.043 sec)MariaDB [hello_mysql]&gt; SELECT * FROM exam_result;+----+-----------+---------+------+---------+| id | name      | chinese | math | english |+----+-----------+---------+------+---------+|  1 | 唐三藏    |     134 |   98 |      56 ||  3 | 猪悟能    |     176 |   98 |      90 ||  4 | 曹孟德    |     140 |   90 |      67 ||  5 | 刘玄德    |     110 |  115 |      45 ||  6 | 孙权      |     140 |   73 |      78 ||  7 | 宋公明    |     150 |   95 |      30 |+----+-----------+---------+------+---------+6 rows in set (0.000 sec)\n\n3.4.2 删除表中所有数据（不是删除表）慎用！不然就是从删库到跑路了！\nDELETE FROM 表名;\n\n注意，这个语句是删除表中所有数据，表不会被删除， AUTO_INCREMENT 项也不会被重置，会在原有基础上继续增加\n3.4.3 截断表  语法如下，这个操作更要慎用。\nTRUNCATE [TABLE] table_name\n\n\n只能对整表操作，不能像 DELETE 一样针对部分数据操作； \n实际上 MySQL 不对数据操作，所以比 DELETE 更快，但是 TRUNCATE 在删除数据的时候，并不经过真正的  事务，所以无法回滚；\n会重置 AUTO_INCREMENT 项；\n\n-- 准备测试表CREATE TABLE for_truncate (id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(20));Query OK, 0 rows affected (0.16 sec)-- 插入测试数据INSERT INTO for_truncate (name) VALUES (&#x27;A&#x27;), (&#x27;B&#x27;), (&#x27;C&#x27;);Query OK, 3 rows affected (1.05 sec)Records: 3 Duplicates: 0 Warnings: 0-- 查看测试数据SELECT * FROM for_truncate;+----+------+| id | name |+----+------+| 1 | A || 2 | B || 3 | C |+----+------+3 rows in set (0.00 sec)\n\n截断整表数据，注意影响行数是 0，所以实际上没有对数据真正操作\n-- 截断表TRUNCATE for_truncate;Query OK, 0 rows affected (0.10 sec)-- 查看删除结果SELECT * FROM for_truncate;Empty set (0.00 sec)\n\n截断数据是会重置自增键值的当前值的，新插入的数据会从 1 开始重新自增；\n-- 再插入一条数据，自增 id 在重新增长INSERT INTO for_truncate (name) VALUES (&#x27;D&#x27;);Query OK, 1 row affected (0.00 sec)-- 查看数据SELECT * FROM for_truncate;+----+------+| id | name |+----+------+| 1 | D     |+----+------+1 row in set (0.00 sec)\n\n在 linux 的文件操作里面，也有一个 O_TRUNC 标记位，作用是打开文件的时候，将文件原有内容清空；\n3.5 插入查询结果INSERT INTO table_name [(column [, column ...])] SELECT ...\n\n这个语法的作用有两个\n\n将表 1 的数据移植一部分到  完全相同的表 2（表结构要完全一致）\n将表 1 的数据拷贝一部分到自己，相当于新增一部分冗余数据\n\n比如我们想将一个表中的重复数据给删除，但是 delete 语句并没有直接与之相关的语法，这时候我们就可以采取如下措施\n\n创建与表 1 完全相同的表 2（名字改一下）\n从表 1 中查询目标数据，并带上 distinct 对查询结果去重\n将表 1 查询到的这个去重后的数据插入到表 2\n删除表 1\n重命名表 2 为表 1 的名字\n\n以下是一个示例操作\n-- 创建原数据表CREATE TABLE duplicate_table (id int, name varchar(20));Query OK, 0 rows affected (0.01 sec)-- 插入测试数据，有重复INSERT INTO duplicate_table VALUES    (100, &#x27;aaa&#x27;),    (100, &#x27;aaa&#x27;),    (200, &#x27;bbb&#x27;),    (200, &#x27;bbb&#x27;),    (200, &#x27;bbb&#x27;),    (300, &#x27;ccc&#x27;);Query OK, 6 rows affected (0.002 sec)Records: 6  Duplicates: 0  Warnings: 0-- 创建一张空表 no_duplicate_table，结构和 duplicate_table 一样CREATE TABLE no_duplicate_table LIKE duplicate_table;Query OK, 0 rows affected (0.00 sec)-- 将 duplicate_table 的去重数据插入到 no_duplicate_tableINSERT INTO no_duplicate_table SELECT DISTINCT * FROM duplicate_table;Query OK, 3 rows affected (0.002 sec)Records: 3  Duplicates: 0  Warnings: 0-- 重命名表RENAME TABLE duplicate_table TO old_duplicate_table,no_duplicate_table TO duplicate_table;Query OK, 0 rows affected (0.00 sec)-- 查看最终结果，数据没有重复SELECT * FROM duplicate_table;+------+------+| id | name |+------+------+| 100 | aaa || 200 | bbb || 300 | ccc |+------+------+3 rows in set (0.00 sec)\n\n4. 聚合函数  聚合统计是间接或者直接统计列方向上的某些数据\n\n\n\n函数\n说明\n\n\n\nCOUNT([DISTINCT] expr)\n返回查询到的数据的 数量\n\n\nSUM([DISTINCT] expr)\n返回查询到的数据的 总和，不是数字没有意义\n\n\nAVG([DISTINCT] expr)\n返回查询到的数据的 平均值，不是数字没有意义\n\n\nMAX([DISTINCT] expr)\n返回查询到的数据的 最大值，不是数字没有意义\n\n\nMIN([DISTINCT] expr)\n返回查询到的数据的 最小值，不是数字没有意义\n\n\n4.1 统计班级有多少人select count(*) from students;+----------+| count(*) |+----------+|        5 |+----------+1 row in set (0.000 sec)\n\n也可以使用表达式进行统计，你会发现这里虽然是 count1，但是结果依旧是 5；这是因为当我们在 select 的目标列里面添加一个常数或者一个表达式的时候，他会  追加到原有表的末尾。这里我们直接写个 1，就会把 1 追加到表中每一行的末尾，所以最终统计出来的结果依旧是表中记录的个数！\nSELECT COUNT(1) FROM students;+----------+| COUNT(1) |+----------+|        5 |+----------+1 row in set (0.000 sec)\n\n4.2 统计班级有多少人有 qq 号  这里能看出来 NULL 是不计入 count 的\nselect * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   || 104 | 20000 | 闰土      | NULL   || 105 |  1005 | 周树人    | NULL   |+-----+-------+-----------+--------+5 rows in set (0.000 sec)SELECT COUNT(qq) FROM students;+-----------+| COUNT(qq) |+-----------+|         1 |+-----------+1 row in set (0.000 sec)\n\n但  空串  是会被正常统计的，这里又一次展现出了空字符串和 NULL 的区别！NULL 表达的意思就是这条记录的这个字段是没有数据的！\nMariaDB [hello_mysql]&gt; insert into students values (2,10123,&#x27; 胡图图 &#x27;,&#x27;&#x27;);Query OK, 1 row affected (0.001 sec)MariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 ||   2 | 10123 | 胡图图    |        || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   || 104 | 20000 | 闰土      | NULL   || 105 |  1005 | 周树人    | NULL   |+-----+-------+-----------+--------+6 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; SELECT COUNT(qq) FROM students;+-----------+| COUNT(qq) |+-----------+|         2 |+-----------+1 row in set (0.000 sec)\n\n4.3 统计数学成绩分数的个数-- COUNT(math) 统计的是全部成绩SELECT COUNT(math) FROM exam_result;+-------------+| COUNT(math) |+-------------+|           6 |+-------------+1 row in set (0.000 sec)-- COUNT(DISTINCT math) 统计的是去重成绩数量-- 这里的 DISTINCT 一定要放在括号里，不然是无效的，这点从语义上也能理解；SELECT COUNT(DISTINCT math) FROM exam_result;+----------------------+| COUNT(DISTINCT math) |+----------------------+|                    5 |+----------------------+1 row in set (0.001 sec)\n\n4.4 统计数学成绩总分MariaDB [hello_mysql]&gt; SELECT SUM(math) FROM exam_result;+-----------+| SUM(math) |+-----------+|       569 |+-----------+1 row in set (0.000 sec)-- 没有结果的时候，返回 NULLMariaDB [hello_mysql]&gt; SELECT SUM(math) FROM exam_result WHERE math &lt; 60;+-----------+| SUM(math) |+-----------+|      NULL |+-----------+1 row in set (0.042 sec)\n\n4.5 统计平均分SELECT AVG(chinese + math + english) 平均总分 FROM exam_result;+--------------+| 平均总分      |+--------------+| 297.5        |+--------------+\n\n你也可以将 sum 和 count 连用来达到这个效果\nSELECT SUM(chinese + math + english)/COUNT(1) 平均总分 FROM exam_result;+--------------+| 平均总分     |+--------------+|        297.5 |+--------------+1 row in set (0.001 sec)\n\n4.6 统计最高 &#x2F; 最低  返回英语的最高分\nSELECT MAX(english) FROM exam_result;+--------------+| MAX(english) |+--------------+|          90  |+--------------+1 row in set (0.00 sec)\n\n返回大于七十分以上的数学最低分\nSELECT MIN(math) FROM exam_result WHERE math &gt; 70;+-----------+| MIN(math) |+-----------+|        73 |+-----------+1 row in set (0.001 sec)\n\n5.group by基本语法如下，含义是在 select 的时候对结果进行一定的分组\nselect column1, column2, .. from table group by column;\n\n5.0 测试表  这里给大家准备了一个比较经典的测试表，来自 oracle 9i，你可以在我的Gitee 仓库 找到他；\n使用 ftp 将这个 sql 传到 linux 里面，进入 mysql 的命令行，使用 source 文件路径 的语句，就可以将这个表里面的数据导入到 mysql 中；\nsource /root/scott_data.sql\n\n这个 sql 里面包含 EMP 员工表、DEPT 部门表、SALGRADE 工资等级表三张表结构，很方便我们进行测试；表结构如下\nMariaDB [scott]&gt; desc dept;+--------+--------------------------+------+-----+---------+-------+| Field  | Type                     | Null | Key | Default | Extra |+--------+--------------------------+------+-----+---------+-------+| deptno | int(2) unsigned zerofill | NO   |     | NULL    |       || dname  | varchar(14)              | YES  |     | NULL    |       || loc    | varchar(13)              | YES  |     | NULL    |       |+--------+--------------------------+------+-----+---------+-------+3 rows in set (0.001 sec)MariaDB [scott]&gt; desc salgrade;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| grade | int(11) | YES  |     | NULL    |       || losal | int(11) | YES  |     | NULL    |       || hisal | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+3 rows in set (0.001 sec)MariaDB [scott]&gt; desc emp;+----------+--------------------------+------+-----+---------+-------+| Field    | Type                     | Null | Key | Default | Extra |+----------+--------------------------+------+-----+---------+-------+| empno    | int(6) unsigned zerofill | NO   |     | NULL    |       || ename    | varchar(10)              | YES  |     | NULL    |       || job      | varchar(9)               | YES  |     | NULL    |       || mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       || hiredate | datetime                 | YES  |     | NULL    |       || sal      | decimal(7,2)             | YES  |     | NULL    |       || comm     | decimal(7,2)             | YES  |     | NULL    |       || deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |+----------+--------------------------+------+-----+---------+-------+8 rows in set (0.001 sec)\n\n\n\n5.1 如何显示每个部门的平均工资和最高工资select deptno,avg(sal),max(sal) from emp group by deptno;+--------+-------------+----------+| deptno | avg(sal)    | max(sal) |+--------+-------------+----------+|     10 | 2916.666667 |  5000.00 ||     20 | 2175.000000 |  3000.00 ||     30 | 1566.666667 |  2850.00 |+--------+-------------+----------+3 rows in set (0.012 sec)\n\n需要注意的是，这里的聚合函数是无法用作 where 的条件的，因为 where 的执行顺序早于聚合函数，你连数据都还没有筛选出来，怎么聚合呢？\nselect deptno,avg(sal),max(sal) from emp where avg(sal)&gt;200 group by deptno;\n\n执行的时候会报错\nMariaDB [scott]&gt; select deptno,avg(sal),max(sal) from emp where avg(sal)&gt;200 group by deptno;ERROR 1111 (HY000): Invalid use of group function\n\n另外，在老版本的 mysql 中，当你使用了 group by 之后，select 的结果指定列就只能包含 group by 里面出现过的列，以及聚合函数；但在我当前使用的 mariadb 中并没有出现这个报错；\n\n5.2 显示每个部门的每种岗位的平均工资和最低工资select avg(sal),min(sal),job, deptno from emp group by deptno, job;+-------------+----------+-----------+--------+| avg(sal)    | min(sal) | job       | deptno |+-------------+----------+-----------+--------+| 1300.000000 |  1300.00 | CLERK     |     10 || 2450.000000 |  2450.00 | MANAGER   |     10 || 5000.000000 |  5000.00 | PRESIDENT |     10 || 3000.000000 |  3000.00 | ANALYST   |     20 ||  950.000000 |   800.00 | CLERK     |     20 || 2975.000000 |  2975.00 | MANAGER   |     20 ||  950.000000 |   950.00 | CLERK     |     30 || 2850.000000 |  2850.00 | MANAGER   |     30 || 1400.000000 |  1250.00 | SALESMAN  |     30 |+-------------+----------+-----------+--------+9 rows in set (0.000 sec)\n\n5.3 显示平均工资地域 2000 的部门和他的平均工资-- 统计各个部门的平均工资select avg(sal) from emp group by deptno-- 通过 having 筛选出结果select avg(sal) as myavg from emp group by deptno having myavg&lt;2000;\n\n因为聚合函数的结果无法作为 where 的条件，所以 MySQL 额外提供了一个 having 关键字，用于在聚合查询中对数据进一步进行筛选；这里可以看到它是可以支持  别名  的，所以 having 的语句是  晚于 select 指定列 执行的；\nselect avg(sal) as myavg from emp group by deptno having myavg&lt;2000;+-------------+| myavg       |+-------------+| 1566.666667 |+-------------+1 row in set (0.042 sec)\n\n总结\ngroup by 是通过分组这样的手段，为未来进行聚合统计提供基本的功能支持\ngroup by 后跟随的是分组的字段依据，只有在 group by 后面出现过的字段，未来在聚合统计时，才能在 select 中出现（新版本 mysql 似乎取消了此限制）\nwhere 语句是在表中数据初步被筛选的时候，来起效果的\nhaving 语句是在完成整个分组聚合统计后再进行筛选\n\n6.SQL 各个语句执行顺序  面试的时候常考，建议记住\nfrom &gt; on &gt; join &gt; where &gt; group by &gt; with &gt; having &gt; select&gt; distinct &gt; order by &gt; limit\n\n以如下的语句为例，执行顺序参考我的圆圈数字标记\nselect deptno, avg(sal) as myavg ④ from emp ① \twhere sal &gt; 1000 ②\tgroup by deptno ③\thaving myavg &lt; 2000 ⑤; \n\n7. 视图  在 MySQL 中还有一个特殊的虚拟表，被称作视图；其可以将一个 select 语句的查询结果视作一个新表，供我们使用；\n请注意！这里的视图要和事务中的 ReadView 做区分，两者毫无关系！\ncreate view 视图名 as select ...;\n\n比如在 scott 的测试表 中，包含如下 3 个表；\nMariaDB [scott]&gt; show tables;+-----------------+| Tables_in_scott |+-----------------+| dept            || emp             || salgrade        |+-----------------+3 rows in set (0.001 sec)\n\n我们可以用如下语句创建一个视图\ncreate view v_ename_dname as \tselect ename, dname\tfrom emp,dept \twhere emp.deptno=dept.deptno;\n\n创建了之后，这个视图会以一个新表的形式出现在 tables 中\nMariaDB [scott]&gt; show tables;+-----------------+| Tables_in_scott |+-----------------+| dept            || emp             || salgrade        || v_ename_dname   |+-----------------+4 rows in set (0.000 sec)\n\n这个表的查询结果和直接执行原有的 select 语句是完全一致的；\n我们把视图涉及到的数据原有表叫做基表；\nMariaDB [scott]&gt; select * from v_ename_dname;+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || JONES  | RESEARCH   || MARTIN | SALES      || BLAKE  | SALES      || CLARK  | ACCOUNTING || SCOTT  | RESEARCH   || KING   | ACCOUNTING || TURNER | SALES      || ADAMS  | RESEARCH   || JAMES  | SALES      || FORD   | RESEARCH   || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.001 sec)\n\n进入 MySQL 的存储路径，你会发现视图只有一个 .frm 文件，是不会有保存数据的 .ibd 文件的；这也代表视图是一个变相的数据链接，并不会拷贝数据；\n[root@vm-cnt8:/var/lib/mysql/scott]# lsdb.opt  dept.frm  dept.ibd  emp.frm  emp.ibd  salgrade.frm  salgrade.ibd  v_ename_dname.frm\n\n如果修改视图，会对基表数据有影响；修改基表，也会对视图有影响；\n删除视图不会影响基表中的数据；\ndrop view 视图;\n\n7.1 视图的规则和限制\n与表一样，必须唯一命名（不能出现同名视图或表名） \n创建视图数目无限制，但要考虑复杂查询创建为视图之后的性能影响\n视图不能添加索引，也不能有关联的触发器或者默认值\n视图可以提高安全性，必须具有足够的访问权限；\norder by 可以用在查询视图的数据中，但是如果从该视图检索数据 select 中也含有 order by，那么该视图查询中的 order by 将被覆盖 \n视图可以和表一起使用\n\n8. 从文件中加载数据到对应表mariadb 支持通过 load 命令命令加载文件中的数据到对应表。命令格式如下\nLOAD DATA INFILE &#x27;/path/to/data/file&#x27; INTO TABLE my_tableFIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;&quot;&#x27;LINES TERMINATED BY &#x27;\\n&#x27;;\n\n其中 /path/to/data/file 是数据文件的路径，my_table 是要插入数据的表名。FIELDS TERMINATED BY &#39;,&#39; 指定字段之间的分隔符为逗号，ENCLOSED BY &#39;&quot;&#39; 表示字段值被双引号包围，LINES TERMINATED BY &#39;\\n&#39; 则表示行以换行符结束。\n\n比如我有一个 pc.txt 文件, 文件中的格式如下，每一行都是对齐的，每一列用空格作为分割，和字段要求对应。\n1001 2.66 1024 250 21141002 2.10 512  250 9551003 1.42 512  80  478\n\n那么在创建出来一个对应的表后，可以用如下命令来加载文件中的数据\ncreate table PC(    model integer unsigned primary key,    speed float(4,2),    ram integer unsigned,    hd integer unsigned,    price integer unsigned);\n\nLOAD DATA INFILE &#x27;/root/pc.txt&#x27;INTO TABLE PCFIELDS TERMINATED BY &#x27;\\t&#x27;(model,speed,ram,hd,price);\n\n执行后的效果如下，成功加载\nMariaDB [products]&gt; LOAD DATA INFILE &#x27;/root/pc.txt&#x27;    -&gt; INTO TABLE PC    -&gt; FIELDS TERMINATED BY &#x27;\\t&#x27;    -&gt; (model,speed,ram,hd,price);Query OK, 13 rows affected, 12 warnings (0.015 sec)  Records: 13  Deleted: 0  Skipped: 0  Warnings: 12MariaDB [products]&gt; select * from PC;+-------+-------+------+------+-------+| model | speed | ram  | hd   | price |+-------+-------+------+------+-------+|  1001 |  2.66 | 1024 |  250 |  2114 ||  1002 |  2.10 |  512 |  250 |   995 ||  1003 |  1.42 |  512 |   80 |   478 ||  1004 |  2.80 | 1024 |  250 |   649 ||  1005 |  3.20 |  512 |  250 |   630 ||  1006 |  3.20 | 1024 |  320 |  1049 ||  1007 |  2.20 | 1024 |  200 |   510 ||  1008 |  2.20 | 2048 |  250 |   770 ||  1009 |  2.00 | 1024 |  250 |   650 ||  1010 |  2.80 | 2048 |  300 |   770 ||  1011 |  1.86 | 2048 |  160 |   959 ||  1012 |  2.80 | 1024 |  160 |   649 ||  1013 |  3.06 |  512 |   80 |   529 |+-------+-------+------+------+-------+13 rows in set (0.002 sec)\n\n请注意，该命令不是万能的，很有可能出错！在加载之前，请在一个空的数据库中进行测试！\nThe end基本知识就这些了!\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【leetcode】102. 二叉树的层序遍历（C 语言 + 队列）","url":"/posts/2026576418/","content":"这道二叉树的题目相对来说毕竟难，所以又单独拿出来发一篇题解\n\n\n[TOC]\n102 层序遍历（较难😥）\nleetcode：102. 二叉树的层序遍历\n\n\n这道题相对来说就么有那么容易了，你可能和我一样，压根没看明白题目要求中的后两个参数是用来干嘛的\n\n/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes)&#123;&#125;\n\n看了一些题解，这才算理解了这道题的要求\n\n*returnSize：存放的是二叉树的层数\n**returnColumnSizes：存放的是二叉树每一层的节点个数\n返回值要求是 int**：需要返回一个 指针数组 ，该数组中的每一个元素是一个 数组 A，数组 A 保存了二叉树每一层的节点值\n\n\n0. 错误思路  最开始我的想法是，用单独的函数计算出树的节点个数和层级，再进行一次层序遍历来得到树的值。\n但很显然，这一思路在本题是搞不通的！🤔\n1. 数组队列初始化  在链式二叉树博客  中，我讲述了利用队列来实现层序遍历的思路。这道 OJ 题目我们也是这么干的。不同的是，在我自己写的队列实现里，使用的是链式队列 。而本题使用 数组队列  会好一点！\n#define MAX 2000int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) &#123;    if (root == NULL)        return;    struct TreeNode* Queue[MAX];// 队列，存放节点的地址    int front = 0, tail = 0;// 指向队头和队尾\n\n2. 初始化数组  这部分会毕竟绕，先一步一步来理解\n*returnSize = 0;// 将二叉树层级初始化为 0// 存放二叉树的每一层节点的值int** ret = (int**)malloc(sizeof(int*) * MAX);// 开辟一个数组来存放每一层的节点个数*returnColumnSizes = (int*)malloc(sizeof(int*) * (MAX / 2));\n\n\nret是一个指针数组，存放的是数组 A，数组 A 里面是每一层的节点值。ret 也就是题目要求的返回值\n*returnColumnSizes开辟一个数组来保存每一层的节点数\n\n这里其实 returnColumnSizes 没有啥二级指针的必要，但是既然题目给了是 int**，我们就需要先* 解引用再 malloc 开辟数组\n3. 队列操作思路\n先让根节点入队列，tail++\n外层循环判断队列是否非空，如果非空就停止操作\n内层循环进行每一层的入队操作，这样才能得到每一层的节点值和  节点个数\n在内层循环中创建 ret 数组的  子数组，单独存放每一层的节点值\n最后将每一层的节点个数赋值给 *returnColumnSizes 数组，*returnSize++一次\n\n   struct TreeNode* head;   Queue[tail++] = root;// 根节点入队   while (front != tail)   &#123;       int Csize = 0;// 每一层的节点个数       int end = tail;       //end 是每一层最末一个节点的指针。在后续的入队列操作中 tail 会改变，所以需要保存 tail 的值       ret[*returnSize] = (int*)malloc(sizeof(int*) * (end - front));       // 为每一层开辟一个单独的数组来存放值       while (front &lt; end)       &#123;           head = Queue[front++];           ret[*returnSize][Csize++] = head-&gt;val;           // 数组赋值，同时每一层的节点个数 Csize++           if (head-&gt;left != NULL)               Queue[tail++] = head-&gt;left;           if (head-&gt;right != NULL)               Queue[tail++] = head-&gt;right;       &#125;       (*returnColumnSizes)[*returnSize] = Csize;// 赋值每一层的节点个数       (*returnSize)++;// 层数 +1   &#125;return ret;\n\n外层循环结束后，此时 ret 数组就是题目要求的结果了，返回 ret 就可以了！\n\n这里有一个小问题，当树为  空树  时，层级应该是 0。所以我们需要在第一行赋值 *returnSize = 0; 不然会执行出错\n\n\n这道题的思路是我看过题解之后才搞明白的，所以上面的只是一个思路的复现😭还是太菜了！\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","leetcode"]},{"title":"【leetcode】150. 逆波兰表达式求值","url":"/posts/3211822811/","content":"题目来源\n150. 逆波兰表达式求值\n\n\n思路  逆波兰表达式又称为后缀表达式\n\n中缀 1 + 2 * 3\n后缀 1 2 3 + *\n\n我们需要将逆波兰表达式化为正常可计算的中缀表达式，再进行计算。题目所给的参数是后缀表达式，其操作的思路如下：\n\n遇到操作数，入栈\n遇到运算符，取栈顶两个连续数据进行计算，再将计算结果入栈\n\n看起来不难，是因为这道题已经是简化后的版本，其所给后缀表达式中没有出现 () 这种特殊优先级的操作。下面说一下把中缀转后缀的思路（本题没有涉及）\n中缀表达式转为后缀  手工做法：\n以例 2 给出的中缀表达式为例，中缀表达式转换为后缀表达式的手工做法为：\n按照运算符的优先级对所有的运算单位加括号。例： ((a/b) + (((c*d) - (e*f))/g))把运算符号移动到对应括号的后面，然后去掉括号。例：((ab)/ (((cd)*(ef)*)-g)/+，去掉括号ab/cd*ef*-g/+\n\n以这个中缀表达式为例\n1 + 2 * 3 / 2 -5\n\n我们都知道，运算顺序应该是先计算 2*3 然后在计算 6/2，最后计算1+3-5 得出结果-1\n因为 * / 操作符的优先级高于加减，这里就需要注意这种情况。我们需要用一个栈来存放操作符\n\n遇到操作数的时候 先输出\n遇到操作符，和栈顶进行比较\n如果栈为空 &#x2F; 操作符优先级高于栈顶，入栈\n操作符优先级低于栈顶或和栈顶相同，出栈顶操作符\n\n\n最后将栈中的操作符全部出栈，就可以获得后缀表达式\n\n用上面这个思路走一遍，即为下面的情况（不知道这样写的大家能不能看明白）\n\n最终得到的结果如下\n1 2 3 * 2 / + 5 -\n\n即需要的后缀表达式\n我们可以用本题代码测试一下这个用例，得出的结果也是-1，正确！\n\n后缀转中缀https://blog.csdn.net/qq_29462849/article/details/93652583\n\n完整代码//https://leetcode.cn/problems/evaluate-reverse-polish-notation/submissions///150 逆波兰表达式class Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; s;        for(auto&amp; ch : tokens)        &#123;            if(ch==&quot;+&quot;||ch==&quot;-&quot;||ch==&quot;*&quot;||ch==&quot;/&quot;)            &#123;                int right=s.top();                s.pop();                int left=s.top();                s.pop();                switch(ch[0])                &#123;                    case &#x27;+&#x27;:                        s.push(left+right);                        break;                    case &#x27;-&#x27;:                        s.push(left-right);                        break;                    case &#x27;*&#x27;:                        s.push(left*right);                        break;                    case &#x27;/&#x27;:                        s.push(left/right);                        break;                    default:                        break;                &#125;            &#125;            else&#123;                s.push(stoi(ch));            &#125;           &#125;        return s.top();    &#125;&#125;;\n\n\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C++","leetcode"]},{"title":"【leetcode】189. 轮转数组（C 语言）","url":"/posts/2445477159/","content":"问题来源\nleetcode 189. 轮转数组\n\n给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n输入: nums = [1,2,3,4,5,6,7], k = 3输出: [5,6,7,1,2,3,4]解释:向右轮转 1 步: [7,1,2,3,4,5,6]向右轮转 2 步: [6,7,1,2,3,4,5]向右轮转 3 步: [5,6,7,1,2,3,4]\n\n这道题的底部有一个进阶要求：\n\n进阶：\n\n尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。\n你可以使用空间复杂度为 O(1) 的 原地   算法解决这个问题吗\n\n\n正好最近学习了  空间复杂度和时间复杂度，这里可以用于练习\n\n方法 1- 基本方法  最基本的方法就是直接旋转，把最后一位数字移动到数组的第一位，然后将第二位开始的每一位往前移动一位\n\n需要先执行移动操作再替换第一个数\n\nvoid rotate(int* nums, int numsSize, int k) &#123;    k %= numsSize;    for (int i = 0; i &lt; k; i++)    &#123;        int tmp = nums[numsSize - 1];        for (int j = numsSize - 1; j &gt;0; j--)        &#123;            nums[j] = nums[j-1];        &#125;        nums[0] = tmp;    &#125;    return;&#125;\n\n这种算法的时间复杂度是 O(k*N)，空间复杂度是 O(1)\n这道题的 k 是常数，可以省略\n\n但很不幸，它在跑 leetcode 中非常长的测试用例的时候，还是没有跑过去，超时了\n\n方法 2- 额外开一个数组  这种方法也非常简单，额外开辟一个数组，存储需要旋转的几个数字，然后将它们之前的数据存储到该数组的后半部分\n最后再把新数组复制回原来的数组中\nvoid rotate(int* nums, int numsSize, int k) &#123;    k %= numsSize;    int* num1 = (int*)malloc(sizeof(int) * numsSize);    int h = 0;    for (int i = numsSize - k; i &lt; numsSize; i++)    &#123;        num1[h++] = nums[i];    &#125;    for (int i = 0; i &lt; numsSize - k; i++)    &#123;        num1[i + k] = nums[i];    &#125;    memcpy(nums, num1, sizeof(int) * numsSize);    return;&#125;\n\n这个算法的时间复杂度是 O(N)，空间复杂度是 O(N)\n可以看到，最后的执行结果只打败了 leetcode 很小一部分人\n\n同时这个算法也不符合进阶要求中的“原地”\n\n方法 3- 三旋法（最优）和上面两个方法相比，三旋法相对来说较优，而且符合题目的进阶要求\n但是它需要一定的理解能力：\n假设我们需要旋转 3 个数字\n\n先将前 SZ-K 个数字逆置\n再将后 k 个数字逆置\n最后整体逆置\n\n这样就能得到我们想要的结果！\n1 2 3 4 5 6 7 // 旋转 3 个4 3 2 1 5 6 7 // 先逆置前 7-3=4 个4 3 2 1 7 6 5 // 再逆置后 3 个5 6 7 1 2 3 4 // 最后整体逆置，即为结果\n\n代码如下\nvoid Swap(int* nums, int sz)&#123;    int i = 0;    while (i &lt;  (sz/2))    &#123;        int tmp = *(nums+i);        *(nums + i) = *(nums + sz - i-1);        *(nums + sz - i - 1) = tmp;        i++;    &#125;&#125;void rotate(int* nums, int numsSize, int k)&#123;    k%=numsSize;    Swap(nums,numsSize-k);    Swap(nums+numsSize-k,k);    Swap(nums,numsSize);    return ;&#125;\n\n这个算法的时间复杂度是 O(N)，空间复杂度是 O(1)，符合题目进阶要求\n可以看到，最终执行结果比之前优秀多了！\n\n230219重写此题，相同思路；旋转三次。注意一定要处理 k，否则会有栈溢出的问题\n// 旋转参数的位置（下标）void ReverseArr(int* arr,int begin,int end)&#123;    while(begin&lt;end)    &#123;        int tmp = arr[end];        arr[end] = arr[begin];        arr[begin] = tmp;        end--;        begin++;    &#125;&#125;void rotate(int* nums, int numsSize, int k) &#123;    k%=numsSize;    ReverseArr(nums,numsSize-k,numsSize-1);    ReverseArr(nums,0,numsSize-k-1);    ReverseArr(nums,0,numsSize-1);    return;&#125;\n\n\n\n结语  如果这对你有帮助，还请点个👍支持一下！\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","leetcode"]},{"title":"【MySQL】sql 字段约束","url":"/posts/4138950838/","content":"在 MySQL 中，我们需要存储的数据在特定的场景中需要不同的约束。当新插入的数据违背了该字段的约束字段，MySQL 会直接禁止插入。\n\n数据类型也是一种约束，但数据类型这个约束太过单一；\n比如我需要存储的是一个序号，那就不可能会有负数，这时候就要用  无符号  来对整形进行约束；\n如果我要存储的是一个日期，且这个日期每个字段都必须要有，那就需要用 NOT NULL 不为空来进行约束；\n如果我要存储的是一个用户 ID，在整个用户系统中这个值肯定是唯一的，就可以使用 UNIQUE 来约束唯一性\n\n本文主要介绍下面几种约束的类型，这依旧是 MySQL 中 ddl 类型的语句操作。\nnull/not nulldefaultcommentzerofillprimary keyauto_incrementunique key\n\n\n顺带一提，在 MySQL 中，每一列的值可以称之为  列或者  字段 ；一般不称之为 键值。\n而表中的每一行被称作  一条记录\n\n1. 空属性 1.1 说明 空属性包含两个值，NULL/NOT NULL，分别对应为空和不为空\n在数据库中，如果我们在插入一行时没有指定某一列的值，那么数据库就会把这个值设置为 NULL；\n\n这里要注意区分 NULL 和空字符串，空字符串并不是 NULL！\n\n但实际使用数据的时候，假设这是一个整形的数据，我们需要取出来后对其进行运算。此时 NULL 取出来的结果就不是一个数字，没有办法进行运算。所以在很多时候，我们都会把一个字段的约束设置为 NOT NULL 并添加上一个默认值（比如 0 或者空字符串）\nMariaDB [hello]&gt; select null;+------+| NULL |+------+| NULL |+------+1 row in set (0.000 sec)MariaDB [hello]&gt; select not null;+----------+| not null |+----------+|     NULL |+----------+1 row in set (0.001 sec)\n\n由下可见空属性是没办法参与运算的，不管如何运算其结果都是 NULL\n在 Python 中，NULL 直接对应的就是 None，当你尝试用 None 和 int 类型进行运算的时候，Python 就会报错了。CPP 中也是如此。\nMariaDB [hello]&gt; select 1+null;+--------+| 1+null |+--------+|   NULL |+--------+1 row in set (0.001 sec)\n\n1.2 案例  假设我们有一个楼层中的班级和教室对应的表，其中包含班级编号和教室编号这两个字段\n\n如果班级编号为空，那就不知道在这间教室上课的是那个班级\n如果教室编号为空，那就不知道某个班级到底是在哪里上课\n\n由实际场景可见，这两个字段都不可以为空，所以在建表的时候就需要考虑到这一点\ncreate table if not exists myclass(\tclass_name varchar(30) not null,    class_room varchar(30) not null)default charset=utf8;\n\n创建了表之后，当我们尝试将一个 NULL 的字段插入，会出现如下的提示，标识某一列不能为空\nMariaDB [hello]&gt; insert into myclass values (&#x27;510&#x27;,NULL);ERROR 1048 (23000): Column &#x27;class_room&#x27; cannot be null\n\n而空字符串是可以被插入的，这里又一次说明了我们认为的  空和 NULL 并不相同，空字符串不是 NULL\nMariaDB [hello]&gt; insert into myclass values (&#x27;510&#x27;,&#x27;&#x27;);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from myclass;+------------+------------+| class_name | class_room |+------------+------------+| 510        |            |+------------+------------+1 row in set (0.000 sec)\n\n2. 默认值 default当我们注册某些网站的时候，一些信息不填，就会被系统设置为默认值。\n比如你不选择年龄的时候，系统可能就会显示你为 0 岁；其他用户看到你的个人主页上显示的 0 岁，就知道你并没有填写自己的真实年龄。（而前端开发的时候也可以将 0 认作没有填写，显示成”隐藏年龄“）\n再比如我们的网站上有一个用户积分的数值，当用户注册的时候，积分肯定是 0（暂时不考虑新人送积分什么的操作），这时候就可以把积分那一列的默认值设置成 0，在插入的时候就可以不显式插入这列的数据；\n在 MySQL 中，某一列设置了默认值后。在 insert 时候如果没有指定这一列的数据，那就会采用默认值。\ncreate table if not exists web_user(    name varchar(30) not null default &#x27; 默认用户名 &#x27;,    age tinyint not null default 0,    gender char(2) not null default &#x27; 男 &#x27; );\n\n创建完毕这个表，当我们查看表结构的时候，就能看到是否为空，以及默认直的相关属性\nMariaDB [hello]&gt; desc web_user;+--------+-------------+------+-----+-----------------+-------+| Field  | Type        | Null | Key | Default         | Extra |+--------+-------------+------+-----+-----------------+-------+| name   | varchar(30) | NO   |     | 默认用户名      |       || age    | tinyint(4)  | NO   |     | 0               |       || gender | char(2)     | NO   |     | 男              |       |+--------+-------------+------+-----+-----------------+-------+3 rows in set (0.004 sec)\n\n由于这个表里面的 3 个字段我们都设置了初始值，你甚至可以直接啥都不指定地插入一个数据；下方可以看到，所有列都被设置成了该列的初始值。\nMariaDB [hello]&gt; insert into web_user values ();Query OK, 1 row affected (0.001 sec)MariaDB [hello]&gt; select * from web_user;+-----------------+-----+--------+| name            | age | gender |+-----------------+-----+--------+| 默认用户名      |   0 | 男     |+-----------------+-----+--------+1 row in set (0.000 sec)\n\n当我们想不设置某一列的值的时候，默认值就能帮上忙。\n这里先给一个错误的演示，我们只在 values 里面设置了两个值，目的是让新插入的这个用户的性别采用默认值。但 MySQL 报错了，报错的信息提示是 value 的个数和列的数量不一致\nMariaDB [hello]&gt; insert into web_user values (&#x27; 李华 &#x27;,16);ERROR 1136 (21S01): Column count doesn&#x27;t match value count at row 1\n\n这是因为我们在插入的时候，没有显示的告诉 MySQL 我们这两个值到底是哪两列的值。李华是给 name 列还是给 gender 列？MySQL 没有办法自主决定！所以干脆拒绝插入。\n所以，当我们想让某一列使用缺省值的时候，就需要告诉 MySQL，我们当前指定的 values 到底是哪几列的数据\ninsert into web_user (name,age) values (&#x27; 李华 &#x27;,16);\n\n这样才能插入成功\nMariaDB [hello]&gt; insert into web_user (name,age) values (&#x27; 李华 &#x27;,16);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from web_user;+-----------------+-----+--------+| name            | age | gender |+-----------------+-----+--------+| 默认用户名      |   0 | 男     || 李华            |  16 | 男     |+-----------------+-----+--------+2 rows in set (0.001 sec)\n\n因为这里做了对列名的显示指定，所以顺序并不一定需要依照表中列名的顺序，比如下方我们反过来也是可以插入的。但并不建议这么做，在插入的时候的列名顺序应该和表中列顺序保持一致！\nMariaDB [hello]&gt; insert into web_user (age,name) values (18,&#x27; 小李 &#x27;);Query OK, 1 row affected (0.001 sec)MariaDB [hello]&gt; select * from web_user;+-----------------+-----+--------+| name            | age | gender |+-----------------+-----+--------+| 默认用户名      |   0 | 男     || 李华            |  16 | 男     || 小李            |  18 | 男     |+-----------------+-----+--------+3 rows in set (0.001 sec)\n\n如果想让 age 列采用初始值，那就是如下的插入；\nMariaDB [hello]&gt; insert into web_user (name,gender) values (&#x27; 菲菲公主 &#x27;,&#x27; 女 &#x27;);Query OK, 1 row affected (0.005 sec)\n\n2.1 默认值和 NULL需要注意的是，默认值和 NOT NULL 并不是必须一起使用的\n\n当我们设置了默认值，但是没有设置NOT NULL，我们可以显式地插入 NULL\n默认值也可以设置成 NULL\n\ncreate table if not exists test_user(    name varchar(30) not null default &#x27; 默认用户名 &#x27;,    age tinyint not null default 0,    gender char(2) default null);\n\n使用如上 sql 创建表，数据库没有报错，即代表我们的语法是被支持的。因为性别并不需要参与运算，所以我们可以认为当性别列为空的时候，就是  未选择性别  的选项。不过，也可以通过空字符串作为默认值来解决这一问题，相比之下用空字符串更好，因为这样能保证这个字段的值始终是个字符串，而不需要对 null 进行特殊处理\n\ndefault null 和 not null不能一起使用，这是肯定的！\n3. 列描述 comment需要注意，在 sqlite 中是不支持 comment 的，不同的数据库对 sql 字段的支持会有些许的差距，请根据你使用的数据库为准。本文所述基于 MySQL 和 MariaDB。\n所谓的列描述，就是对这列到底是干嘛的一个说明信息，相当于代码的注释。其本身没有任何含义；\n列注释的主要作用，就是让所有使用这个数据库，使用这张表的人都能理解这个字段的作用。其中还可以添加额外的注释说明，来让程序员统一在不同模块的上传代码中进行额外的处理。\n比如我们将第二点中出现过的用户表改成如下形式，每个字段都添加上注释\ncreate table if not exists web_user(    name varchar(30) not null default &#x27; 默认用户名 &#x27; comment &#x27; 用户名 &#x27;,    age tinyint not null default 0 comment &#x27; 用户年龄 &#x27;,    gender char(2) not null default &#x27; 男 &#x27; comment &#x27; 用户性别 &#x27; );\n\n当我们使用这个 sql 创建了这个表后，如果想查询字段的注释，可以用如下命令查看创建表时使用的命令（其中就包含了表的注释）\nSHOW CREATE TABLE web_user;\n\n显示如下\nMariaDB [hello]&gt; SHOW CREATE TABLE web_user;+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table    | Create Table                                                                                                                                                                                                                                                               |+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| web_user | CREATE TABLE `web_user` (  `name` varchar(30) NOT NULL DEFAULT &#x27; 默认用户名 &#x27; COMMENT &#x27; 用户名 &#x27;,  `age` tinyint(4) NOT NULL DEFAULT 0 COMMENT &#x27; 用户年龄 &#x27;,  `gender` char(2) NOT NULL DEFAULT &#x27; 男 &#x27; COMMENT &#x27; 用户性别 &#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8                  |+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.000 sec)\n\n也可以用如下命令来展示所有列和列的属性，其中包括注释\nSHOW FULL COLUMNS FROM web_user;\n\nMariaDB [hello]&gt; SHOW FULL COLUMNS FROM web_user;+--------+-------------+-----------------+------+-----+-----------------+-------+---------------------------------+--------------+| Field  | Type        | Collation       | Null | Key | Default         | Extra | Privileges                      | Comment      |+--------+-------------+-----------------+------+-----+-----------------+-------+---------------------------------+--------------+| name   | varchar(30) | utf8_general_ci | NO   |     | 默认用户名      |       | select,insert,update,references | 用户名       || age    | tinyint(4)  | NULL            | NO   |     | 0               |       | select,insert,update,references | 用户年龄     || gender | char(2)     | utf8_general_ci | NO   |     | 男              |       | select,insert,update,references | 用户性别     |+--------+-------------+-----------------+------+-----+-----------------+-------+---------------------------------+--------------+3 rows in set (0.002 sec)\n\n需要注意，desc 命令显示的结果中是不包含列注释的\nMariaDB [hello]&gt; desc web_user;+--------+-------------+------+-----+-----------------+-------+| Field  | Type        | Null | Key | Default         | Extra |+--------+-------------+------+-----+-----------------+-------+| name   | varchar(30) | NO   |     | 默认用户名      |       || age    | tinyint(4)  | NO   |     | 0               |       || gender | char(2)     | NO   |     | 男              |       |+--------+-------------+------+-----+-----------------+-------+3 rows in set (0.001 sec)\n\n\n4.zerofill4.1 测试结果  先来用如下命令创建一个表\ncreate table if not exists test_int(\ta int not null,\tb int unsigned not null);\n\n创建完成后，我们查看创建这个表时使用的语句，会发现在 int 之后多了一个括号，里面跟了一个数字。\n我们知道在 char 和 varchar 里面，这个括号是用来限制字符串字符长度的，那么在整形这里的括号是干嘛的呢？\nMariaDB [hello]&gt; show create table test_int;+----------+------------------------------------------------------------------------------------------------------------------------+| Table    | Create Table                                                                                                           |+----------+------------------------------------------------------------------------------------------------------------------------+| test_int | CREATE TABLE `test_int` (  `a` int(11) NOT NULL,  `b` int(10) unsigned NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+----------+------------------------------------------------------------------------------------------------------------------------+1 row in set (0.001 sec)\n\n先往这个表内插入一个数据，并查询显示出来\nMariaDB [hello]&gt; insert into test_int values (3,1);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from test_int;+---+---+| a | b |+---+---+| 3 | 1 |+---+---+1 row in set (0.000 sec)\n\n如果我们把 a 列的属性进行修改为如下的字段类型\nalter table test_int change a a int(5) unsigned zerofill;\n\n再去查看创建表的命令，此时结果如下，a 列已经被修改成了信的属性\nMariaDB [hello]&gt; alter table test_int change a a int(5) unsigned zerofill;Query OK, 1 row affected (0.005 sec)               Records: 1  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; show create table test_int;+----------+---------------------------------------------------------------------------------------------------------------------------------------------+| Table    | Create Table                                                                                                                                |+----------+---------------------------------------------------------------------------------------------------------------------------------------------+| test_int | CREATE TABLE `test_int` (  `a` int(5) unsigned zerofill DEFAULT NULL,  `b` int(10) unsigned NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+----------+---------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.000 sec)\n\n那么这个括号里面的数字，和 zerofill 有什么作用呢？\n再次查询此表，会发现刚刚插入的数据，a 列的 3 变成了00003！\nMariaDB [hello]&gt; select * from test_int;+-------+---+| a     | b |+-------+---+| 00003 | 1 |+-------+---+1 row in set (0.000 sec)\n\n4.2 前补 0此时这个属性的作用就很明确了，其用于给数字进行前补 0；而 5 就是规定的前补 0 的长度，而不是数字的长度；当数字的位数小于 5 位，就会触发前补 0；\n可以看到，即便表结构中出现了int(5)，我们依旧可以往这个表里面插入长度大于 5 位的数字\nMariaDB [hello]&gt; insert into test_int values (12345678,1);Query OK, 1 row affected (0.005 sec)\n\n所以这个括号并不是用来限制 int 的长度的，而是当一个数字小于 5 位的时候，会给这个数字前补 0\nMariaDB [hello]&gt; insert into test_int values (18,3);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from test_int;+----------+---+| a        | b |+----------+---+|    00003 | 1 || 12345678 | 1 ||    00018 | 3 |+----------+---+3 rows in set (0.001 sec)\n\n如果再把 int(5) zerofill 改成更长的数值，前补 0 的长度就会变化\nalter table test_int change a a int(7) unsigned zerofill;\n\nMariaDB [hello]&gt; alter table test_int change a a int(7) unsigned zerofill;Query OK, 0 rows affected (0.007 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; select * from test_int;+----------+---+| a        | b |+----------+---+|  0000003 | 1 || 12345678 | 1 ||  0000018 | 3 |+----------+---+3 rows in set (0.001 sec)\n\n需要注意，int(n)的属性只有和 zerofill 一起使用，才会触发前补 0 的操作。这便能解释为何最初创建的表里面是int(11)，但数字并没有被前补 0；\n而这里的前补 0，只是一个在 MySQL 内部  显示的优化，实际上存储的依旧是数字本身；比如我们在上表中查询 3，是可以直接查出来的。\nMariaDB [hello]&gt; select * from test_int where a = 3;+---------+---+| a       | b |+---------+---+| 0000003 | 1 |+---------+---+1 row in set (0.001 sec)\n\n比如我要存储的数字都是 5 位的，设置了前补 0，查询整表时看到的格式化输出的结果会比没有前补 0 的结果看上去舒服很多。\n4.3 为什么 int 是 11，无符号是 10？在前面查询默认的创建表 i 语句的时候，会发现 MySQL 系统默认给 int 了 11 位，无符号 int 是 10 位\n\n这是因为 10 位的长度已经能标识 int 范围内的所有值了，而有符号整数多了一位，是用来显示正负号的。\n5. 主键 primary key主键是用于约束字段里面的数据，不能重复，不能为空；一张表只有一个主键（或者没有），一般都是用整形作为主键。\n主键是用于确定表中每一条记录的唯一性的，其告知了使用者，要想往这个表中插入数据，就必须保证主键的值不冲突。\n5.1 主键的设计类型  以一个用户系统为例\n\n我们可以把用户名设置为主键，当用户选择了一个已经存在的用户名时，拒绝此用户名并告知用户；\n我们可以使用另外一个无关的数字作为主键，比如 QQ 中就使用了 QQ 号来标识用户唯一性，并不要求用户的用户名不能相相同（现在绝大部分聊天软件都使用了这种方式，比如 QQ 和 KOOK，微信虽然没有 QQ 那样的唯一标识，但后台肯定也是有主键作为唯一性标识的）、\n我们可以将多列组成复合主键\n\n5.2 删除和添加主键  在创建表的时候，可以用两种方式来指定主键\n-- 方法 1，在字段后指明create table test_pri_1(\tid int unsigned not null primary key,    name varchar(30) not null);-- 方法 2，在表的最后指明create table test_pri_2(\tid int unsigned not null,    name varchar(30) not null,    primary key(id));\n\n二者都能执行成功。\n另外，主键本身就是不能为空的，所以我们定义主键列的时候可以不用写not null\nMariaDB [hello]&gt; create table test_pri_1(    -&gt; id int unsigned not null primary key,    -&gt;     name varchar(30) not null    -&gt; );Query OK, 0 rows affected (0.017 sec)MariaDB [hello]&gt; create table test_pri_2(    -&gt; id int unsigned not null,    -&gt;     name varchar(30) not null,    -&gt;     primary key(id)    -&gt; );Query OK, 0 rows affected (0.019 sec)\n\n而且表结构相同，在 id 列的 Key 处可以看到 PRI，就是 Primary 的缩写，代表 id 列是主键\nMariaDB [hello]&gt; desc test_pri_1;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(30)      | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.001 sec)MariaDB [hello]&gt; desc test_pri_2;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(30)      | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.001 sec)\n\n如果是一个已经存在的表，我们也可以往里面追加主键或者删除主键\nalter table 表名 drop primary key;-- 用于删除主键列的主键属性，因为主键列只能有一个-- 注意，这个语句不会删除该列alter table 表名 add primary key(id);-- 给 id 列加上主键属性（但是 ID 列里面不能有重复值）\n\n测试一下，可以看到 id 列的 PRI 属性没有了\nMariaDB [hello]&gt; alter table test_pri_1 drop primary key;Query OK, 0 rows affected (0.010 sec)              Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; desc test_pri_1;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   |     | NULL    |       || name  | varchar(30)      | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.002 sec)\n\n当我们往表里面插入数据的时候，如果想往主键列插入一个相同的记录，MySQL 会拒绝插入\nMariaDB [hello]&gt; insert into test_pri_2  values (1,&#x27; 李华 &#x27;);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into test_pri_2  values (1,&#x27; 李明 &#x27;);ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;\n\n5.3 复合主键  一张表只有一个主键，但是主键可以不止一列；\n以我自己写的活跃度统计机器人为例，机器人处在不同服务器中，会收到不同的服务器 ID，和不同用户的操作；为了记录不同服务器的不同用户的活跃度情况，在用户统计表中，需要同时有服务器 ID 和用户 ID；此时就会出现  一个用户加入了两个服务器，而这两个服务器都使用了我这个机器人的情况。反馈到表中，就是一个用户 ID 出现了两次，但对应的服务器 ID 不同；\n在这种情形下，肯定是不能把用户 ID 或服务器 ID 单独设置成主键的。我们就可以把用户 ID 和服务器 ID 统一设置成符合主键；\n设置了复合主键后，我们可以出现相同的服务器 ID，和相同的用户 ID。但只能是  某个服务器的某个用户 ，不能存在两条 服务器 ID 和用户 ID 都相同  的记录。这便是复合主键的作用！\ncreate table user(\tguild_id int unsigned comment &#x27; 服务器 ID&#x27;,\tuser_id int unsigned not null comment &#x27; 用户 ID&#x27;,\tscore tinyint unsigned not null default 0 comment &#x27; 用户积分 &#x27;,\tprimary key(guild_id, user_id) -- guild_id + user_id 为复合主键);\n\n此时查看表结构，会发现服务器 id 和用户 id 的两个键值，在 Key 里面都有 PRI 属性，即他们都是主键；\n而且，即便我们的 guild_id 没有指定 not null，其的NULL 属性依旧是 NO。因为主键是不允许为 NULL 的！\nMariaDB [hello]&gt; create table user(    -&gt; guild_id int unsigned comment &#x27; 服务器 ID&#x27;,    -&gt; user_id int unsigned not null comment &#x27; 用户 ID&#x27;,    -&gt; score tinyint unsigned not null default 0 comment &#x27; 用户积分 &#x27;,    -&gt; primary key(guild_id, user_id) -- guild_id + user_id 为复合主键    -&gt; );Query OK, 0 rows affected (0.011 sec)MariaDB [hello]&gt; desc user;+----------+---------------------+------+-----+---------+-------+| Field    | Type                | Null | Key | Default | Extra |+----------+---------------------+------+-----+---------+-------+| guild_id | int(10) unsigned    | NO   | PRI | NULL    |       || user_id  | int(10) unsigned    | NO   | PRI | NULL    |       || score    | tinyint(3) unsigned | NO   |     | 0       |       |+----------+---------------------+------+-----+---------+-------+3 rows in set (0.003 sec)\n\n当我们插入时，服务器 id 和用户 id 可以在各自列中重复。\nMariaDB [hello]&gt; insert into user values (1,1,0);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; insert into user values (1,2,0);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; insert into user values (2,1,0);Query OK, 1 row affected (0.001 sec)\n\n但如果你想在已经有  服务器 id 为 1，用户 id 为 1的记录的基础上再插入一条这样的记录，那就会报错拒绝插入\nMariaDB [hello]&gt; select * from user;+----------+---------+-------+| guild_id | user_id | score |+----------+---------+-------+|        1 |       1 |     0 ||        1 |       2 |     0 ||        2 |       1 |     0 |+----------+---------+-------+3 rows in set (0.000 sec)MariaDB [hello]&gt; insert into user values (1,1,10);ERROR 1062 (23000): Duplicate entry &#x27;1-1&#x27; for key &#x27;PRIMARY&#x27;\n\n6. 自增 auto_increment自增，人如其名，就是 MySQL 会自动帮我们往这个列添加数据。比如一个序号，新增一条记录就会将序号加一；自增属性只能添加给整形！\n自增的列必须是主键！\n6.1 使用  自增的使用办法是在创建表的键值后添加这个约束\ncreate table test_pri_3(\tid int unsigned auto_increment,    name varchar(30) not null,    primary key(id));\n\n查看表结构，可以看到 id 列是主键，非空，且具有自增属性\nMariaDB [hello]&gt; desc test_pri_3;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(30)      | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.003 sec)\n\n由于自增的列必须是主键，所以我们不能将其和主键分开来使用；\n如果在设置自增的时候没有将这列同时设置为主键，那么创建表的时候就会报错\nMariaDB [hello]&gt; create table test_pri_4(    -&gt; id int unsigned auto_increment,    -&gt;     name varchar(30) not null    -&gt; );ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key\n\n设置了自增之后，我们同样可以显示的指定该列的值；也可以不指定，直接插入其他列的数据。MySQL 会自动帮我们把当前记录 +1。\nMariaDB [hello]&gt; insert into test_pri_3 values (1,&#x27; 李华 &#x27;);Query OK, 1 row affected (0.007 sec)MariaDB [hello]&gt; select * from test_pri_3;+----+--------+| id | name   |+----+--------+|  1 | 李华   |+----+--------+1 row in set (0.001 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27; 小明 &#x27;);Query OK, 1 row affected (0.001 sec)MariaDB [hello]&gt; select * from test_pri_3;+----+--------+| id | name   |+----+--------+|  1 | 李华   ||  2 | 小明   |+----+--------+2 rows in set (0.000 sec)\n\n多插入几条数据，可以看到 id 列都成功自增了\nMariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27; 小明 3&#x27;);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27; 小明 5&#x27;);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from test_pri_3;+----+---------+| id | name    |+----+---------+|  1 | 李华    ||  2 | 小明    ||  3 | 小明 3   ||  4 | 小明 5   |+----+---------+4 rows in set (0.000 sec)\n\n6.2 自增是怎么判断当前所处序号位置的？自增的长度是按最大的那个数字开始自增的？还是说有其他处理流程？\n先尝试往表里面主动插入一个 1000 为 id 的键值，然后再不指定 id 的情况下再插入两行记录\nMariaDB [hello]&gt; insert into test_pri_3 values (1000,&#x27;test&#x27;);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27;test1&#x27;);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27;test2&#x27;);Query OK, 1 row affected (0.001 sec)\n\n查询列表，会发现在这 1000 之后的的记录，全都是从 1000 开始增加的。\nMariaDB [hello]&gt; select * from test_pri_3;+------+---------+| id   | name    |+------+---------+|    1 | 李华    ||    2 | 小明    ||    3 | 小明 3   ||    4 | 小明 5   || 1000 | test    || 1001 | test1   || 1002 | test2   |+------+---------+7 rows in set (0.000 sec)\n\n莫非是依照最大的 id 来进行自增的吗？我们再来试试。\n先把最大 id 的记录删除，再插入一个新数据\nMariaDB [hello]&gt; delete from test_pri_3 where id = 1002;Query OK, 1 row affected (0.007 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27;test3&#x27;);Query OK, 1 row affected (0.006 sec)\n\n再次查询，会发现自增的 id 是 1003。可见其内部记录过一个 id 的最大值，是按内部一个额外的记录来进行自增的，而不是判断表中 id 列的最大值！\nMariaDB [hello]&gt; select * from test_pri_3;+------+---------+| id   | name    |+------+---------+|    1 | 李华    ||    2 | 小明    ||    3 | 小明 3   ||    4 | 小明 5   || 1000 | test    || 1001 | test1   || 1003 | test3   |+------+---------+7 rows in set (0.001 sec)\n\n那这个额外的记录在哪里呢？\nshow create table test_pri_3;\n\n使用如上命令查看创建表的 sql 语句，你会发现紧跟在表之后的，就有一个自增的字段AUTO_INCREMENT=1004\nMariaDB [hello]&gt; show create table test_pri_3;+------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table      | Create Table                                                                                                                                                                              |+------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| test_pri_3 | CREATE TABLE `test_pri_3` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(30) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1004 DEFAULT CHARSET=utf8 |+------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.000 sec)\n\n这就是 MySQL 中对自增字段当前值的定义，这里存放的就是下一个插入的记录，其 id 的自增值。每次插入一个信的记录，这里的自增值就会对应变换为下一个记录应该是多少的数值；\n举个例子，如果我们想让一个系统的 ID 从 10001 开始自增，那么我们就可以在创建了表之后，直接往表里面插入一个 id 为 10000 的记录。在这之后创建的其他记录，id 就会从 10001 开始自增了！\n\n6.3 索引  讲到这里，顺带一提 MySQL 中索引的概念\n索引 ： 在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构。它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的 逻辑指针清单。 \n索引的作用相当于  图书的目录，可以根据目录中的页码快速找到所需的内容。索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。 数据库使用索引以找到特定值，然后顺指针找到包含该值的行。\n这样可以使对应于表的 SQL 语句执行得更快，可快速访问数据库表中的特定信息。\n索引本质上就是一个用空间换时间的套路。在当前多并发的业务中，执行速度远比占用内存、磁盘多少来的更重要！\n7. 唯一键 unique唯一键对字段的约束，那就是这一列的数据都不能出现相同的。\n看起来和主键有点相似，但实际上其是独立于主键之外的一种唯一性的约束。和主键的区别在于：唯一键可以为 NULL\n要知道，一个表里面的主键只能设置一个。复合主键在某些时候并不能满足我们的需求。于是 MySQL 就在主键之外，额外提供了唯一键的约束，让我们可以给其他列设置唯一性。\n至于为什么要这么做？就好比一个免责声明：我这列的数据设置了唯一，那么就不可能接受两个相同的记录（比如用户表中两个人却有相同手机号，是不应该的）如果你的业务中出现了拒绝插入的报错，那么就应该去看业务处理代码中是哪里有 BUG，而不应该怪罪 MySQL 没有维护唯一性或者拒绝记录的插入。\n7.1 单独唯一键  假设我有一个平台，类似于 qq 一样使用了一个 qq 号作为用户的主键；但为了实名认证，我们又要求一个身份证只能注册一个账户。此时就无法用复合主键来解决这个问题，因为复合主键是允许其中某一列有重复的 ；而我们需要的是 用户账户编号和用户身份证号  都不能重复！\n\n同时，在用户的联系方式中，两个用户的电话号码、微信号也不应该出现相同，如果要添加电话号码的键值，也可以将其设置为unique！\n\n此时就可以将用户编号作为主键，用户身分证号设置 unique 作为唯一键；\ncreate table test_unique_1(\tno int unsigned not null primary key,\tname varchar(30) not null,    id_card varchar(30) not null unique );\n\n查看表结构，唯一键的列，Key 的约束是 UNI，即 unique 的缩写\nMariaDB [hello]&gt; desc test_unique_1;+---------+------------------+------+-----+---------+-------+| Field   | Type             | Null | Key | Default | Extra |+---------+------------------+------+-----+---------+-------+| no      | int(10) unsigned | NO   | PRI | NULL    |       || name    | varchar(30)      | NO   |     | NULL    |       || id_card | varchar(30)      | NO   | UNI | NULL    |       |+---------+------------------+------+-----+---------+-------+3 rows in set (0.001 sec)\n\n当我们往这个表中的主键列或者 id_card 列插入相同记录时，MySQL 都会拒绝插入\nMariaDB [hello]&gt; insert into test_unique_1 values (1,&#x27; 李华 &#x27;,123456);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into test_unique_1 values (1,&#x27; 李华 &#x27;,1234567);ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;MariaDB [hello]&gt; insert into test_unique_1 values (3,&#x27; 小明 &#x27;,123456);ERROR 1062 (23000): Duplicate entry &#x27;123456&#x27; for key &#x27;id_card&#x27;\n\n7.2 复合唯一键  唯一键也能设置多列，效果和复合主键相同；这里不再说明\ncreate table user(\tuser_no int unsigned primary key auto_increment comment &#x27; 用户编号 主键 &#x27;,\tguild_id int unsigned comment &#x27; 服务器 ID&#x27;,\tuser_id int unsigned not null comment &#x27; 用户 ID&#x27;,\tscore tinyint unsigned not null default 0 comment &#x27; 用户积分 &#x27;,\tunique(guild_id, user_id) -- guild_id + user_id 为复合唯一键);\n\n表中对 guild_id 和 user_id 的约束就变成了MUL，如下图所示；\n其中能观察到，guild_id因为没有设置not null，其 NULL 一栏为 YES，代表这列可以为 NULL（唯一键可以为 NULL，主键不能）\n而 MUL 则代表目前允许多行在此列具有相同的值，但 guild_id 和 user_id 都相同的两行是不允许存在的\nMariaDB [hello]&gt; desc user;+----------+---------------------+------+-----+---------+----------------+| Field    | Type                | Null | Key | Default | Extra          |+----------+---------------------+------+-----+---------+----------------+| user_no  | int(10) unsigned    | NO   | PRI | NULL    | auto_increment || guild_id | int(10) unsigned    | YES  | MUL | NULL    |                || user_id  | int(10) unsigned    | NO   |     | NULL    |                || score    | tinyint(3) unsigned | NO   |     | 0       |                |+----------+---------------------+------+-----+---------+----------------+4 rows in set (0.001 sec)\n\n如下，最后的插入和第一次的插入中的 guild_id 和 user_id 相同，于是就出现了拒绝插入的报错\nMariaDB [hello]&gt; insert into user values (1,1,1,20);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into user values (2,1,2,21);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; insert into user values (3,2,3,22);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into user values (4,1,1,23);ERROR 1062 (23000): Duplicate entry &#x27;1-1&#x27; for key &#x27;guild_id&#x27;\n\n7.3 在 MySQL 中 MUL、PRI 和 UNI 是什么？从 Mysql 5.7 官网文档可知：\n\n如果键是 PRI，则列是主键或多列主键中的列之一；\n如果键是 UNI，则该列是唯一索引的第一列(唯一索引允许多个空值，但可以通过检查 NULL 字段来判断该列是否允许空)；\n如果键为 MUL，则该列是非唯一索引的第一列，其中允许在列中多次出现给定值；\n\n8. 外键 8.1 说明 外键是用来定义两张表中某些字段的关系，并来约束记录的；\n基础语法如下，在创建表的时候使用。设置外键的表是从表！\nforeign key (字段名) references 主表(列)\n\n比如下图中，学生表中每个学生的班级编号都对应了班级表中班级的 id，此时我们就可以将班级表的 id 设置为学生表中 class_id 的外键；\n虽然我们可以将 class 表中的数据直接插入到学生表里面，但是这样并不合理。如果我们针对一个班级，或者针对一个学生的字段有非常多的话，将这两张表合起来是非常不方便的。因为同一个班级会有很多学生，合并表之后，就相当于同一个班级的学生，他们的班级列的信息全是相等的，这就存在了无意义的资源占用（冗余）。\n相比之下，分表了之后，再采用外键的方式来  绑定两个字段，是更好的选择！\n\n在上图的情况中，myclass 是主表，stu 是一个从表；\n-- 主表 班级create table myclass (\tid int primary key comment &#x27; 班级号 &#x27;,\tname varchar(30) not null comment &#x27; 班级名 &#x27;);-- 从表 学生create table stu (\tid int primary key,\tname varchar(30) not null comment &#x27; 学生名 &#x27;,\tclass_id int,\tforeign key (class_id) references myclass(id) -- 设置从表外键约束);\n\n8.2 测试  创建好表之后，先来看看学生表 i 的属性，可以看到 class_id 表的 key 是一个 MUL，和前面设置复合唯一键的时候相同。\nMariaDB [hello]&gt; desc stu;+----------+-------------+------+-----+---------+-------+| Field    | Type        | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id       | int(11)     | NO   | PRI | NULL    |       || name     | varchar(30) | NO   |     | NULL    |       || class_id | int(11)     | YES  | MUL | NULL    |       |+----------+-------------+------+-----+---------+-------+3 rows in set (0.001 sec)\n\n当我们尝试往学生表里面插入一个数据的时候，会报错\nMariaDB [hello]&gt; insert into stu values (1,&#x27; 李华 &#x27;,2);ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`hello`.`stu`, CONSTRAINT `stu_ibfk_1` FOREIGN KEY (`class_id`) REFERENCES `myclass` (`id`))\n\n这是因为你设置的这个记录中，学生的班级编号 2 压根在班级表里面不存在。一个不存在的班级怎么可以有学生呢？所以自然就拒绝了你的插入。\n所以，要想插入学生，我们需要保证这个学生的记录所在班级，是存在于班级表里面的！这样就实现了学生和班级 N 对 1 的绑定。\nMariaDB [hello]&gt; insert into myclass values (1,&#x27; 少华班 &#x27;);Query OK, 1 row affected (0.002 sec)MariaDB [hello]&gt; insert into stu values (1,&#x27; 李华 &#x27;,1);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from myclass;+----+-----------+| id | name      |+----+-----------+|  1 | 少华班    |+----+-----------+1 row in set (0.001 sec)MariaDB [hello]&gt; select * from stu;+----+--------+----------+| id | name   | class_id |+----+--------+----------+|  1 | 李华   |        1 |+----+--------+----------+1 row in set (0.000 sec)\n\n这里我又多插入了几个数据\nMariaDB [hello]&gt; select * from stu;+----+-----------+----------+| id | name      | class_id |+----+-----------+----------+|  1 | 李华      |        1 ||  2 | 小明      |        1 ||  3 | 小流      |        1 ||  4 | 小流 2     |        2 ||  5 | 猪猪侠    |        2 ||  6 | 苗条俊    |        2 |+----+-----------+----------+6 rows in set (0.000 sec)MariaDB [hello]&gt; select * from myclass;+----+-----------+| id | name      |+----+-----------+|  1 | 少华班    ||  2 | 你好班    |+----+-----------+2 rows in set (0.000 sec)\n\n此时还有另外一个问题：如果这个班级有学生，我们可以把这个班级删掉吗？\n考虑看来，肯定是不行的：既然没有这个班级，你不能插入对应的学生。那么这个班级有学生的时候，你也不应该把班级删除。二者是相互的逻辑；在 MySQL 里面也是如此，当一个班级有对应的学生的时候，是不允许删除的。\nMariaDB [hello]&gt; delete from myclass where id = 1;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`hello`.`stu`, CONSTRAINT `stu_ibfk_1` FOREIGN KEY (`class_id`) REFERENCES `myclass` (`id`))\n\n只有当这个班级没有学生了，才能从班级表中被删除！\nMariaDB [hello]&gt; delete from stu where class_id = 2;Query OK, 3 rows affected (0.005 sec)MariaDB [hello]&gt; delete from myclass where id = 2;Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; \n\n更新班级 id 同样是不允许的，因为在学生表中有学生绑定了这个班级。MySQL 并不能做到帮我们直接更新所有学生的班级号。\nMariaDB [hello]&gt; update  myclass set id = 3 where name = &#x27; 你好班 &#x27;; ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`hello`.`stu`, CONSTRAINT `stu_ibfk_1` FOREIGN KEY (`class_id`) REFERENCES `myclass` (`id`))\n\n8.3 外键约束  在上面的情况中，我们完全可以  建立两个没有外键关系的独立表，在代码层进行两者关系的维护。\n但是这样，这两个表的操作依旧是  独立  的，MySQL 是不知道这两个表之间有毛线关联的；此时你就可以往不存在的班级里面插学生，把还有学生的班级删掉，最终就乱了套了；\n\n自己维护：两个表的信息有关联\n加上外键：MySQL 直接进行约束\n\n两者合一，才是外键的完全体！\n\n如果只在上层代码中约束，特别是多端协作公用数据库的时候，极有可能因为双方程序猿沟通不到位而导致数据库中产生无效记录。外键的存在帮我们避免了这个在协作中的沟通问题。\n\n所以我们才需要在 MySQL 中，将这两个表之间定义外键的约束，让 MySQL 协助我们维护两张表中的数据关系。\n注意：虽然此时 MySQL 会约束我们的操作，但实际上的业务流程还是需要程序袁在代码中处理。比如不要往 MySQL 中插入班级不存在的学生（MySQL 只会拒绝插入，并不能帮你把班级给修正）\nThe end基础的约束操作就是这些了，有其他会用到的，日后再新增！\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【项目】视频点播项目的记录","url":"/posts/4231483510/","content":"1. 用户密码加密算法  在最开始的时候，我打算用 md5 加盐来存放用户的密码；在查找资料的时候，发现了 MD5 算法不再适用于用户密码加密的言论，于是问起了 GPT。\n感觉这部分面试的时候可能会涉及，干脆记录下来吧！\n1.1 什么是 MD5？MD5（Message Digest Algorithm 5）是一种常用的哈希算法，用于将任意长度的数据转换为固定长度（128 位或 16 字节）的哈希值。\nMD5 哈希值通常以十六进制字符串的形式表示。由于每个字节可以用两个十六进制字符表示，因此 MD5 哈希值的长度为 32 个字符（16 字节 * 2）。\n需要注意的是，尽管 MD5 哈希值固定为 128 位（16 字节），但并不意味着输入数据的长度与哈希值长度相同。无论输入数据的长度是多少，MD5 哈希值始终是固定的 128 位长度。\n1.2 MD5 的缺陷？MD5 算法存在安全漏洞主要是由于其设计和性质的限制。\n首先，MD5 算法是一个单向哈希函数，即无法从哈希值逆推出原始输入数据。然而，研究人员发现，通过对不同的输入数据计算相同的 MD5 哈希值（也称为哈希碰撞），可以导致安全问题。这意味着攻击者可以通过寻找具有相同 MD5 哈希值的两个不同输入，来伪造数据或绕过验证机制。\n其次，MD5 的输出长度较短，只有 128 位（16 字节）。这种较短的哈希值使得碰撞的可能性更高。随着计算能力的提升，通过穷举计算或使用专门的碰撞攻击算法，更容易找到两个不同的输入数据产生相同的 MD5 哈希值。\n因此，基于这些安全漏洞，MD5 已被证实不再适用于诸如密码存储等关键安全场景。相反，应该选择更强大且抗碰撞性更好的哈希算法，例如 SHA-256 或 SHA-3 等算法，以提供更高级别的数据完整性和安全性保护。\n1.3 SHA256 的优势SHA-256 相对于 MD5 具有以下几个主要的优势：\n\n安全性：MD5 已经被证实存在安全漏洞，容易受到碰撞攻击和预映像攻击。相反，SHA-256 是一种更为安全的哈希算法，目前没有已知的有效攻击方法，能够从哈希值逆推出原始输入数据或找到碰撞。\n哈希长度：MD5 的哈希长度为 128 位（16 字节），而 SHA-256 的哈希长度为 256 位（32 字节），明显更长。更长的哈希长度增加了哈希碰撞的难度，使得找到两个不同的输入产生相同的哈希值的概率大大降低。\n抗碰撞性：SHA-256 提供了更强大的抗碰撞性，即输入数据的微小变化也会导致输出哈希值的较大变化。这意味着无法通过微小的修改来生成具有相同哈希值的不同输入数据。\n\n综上所述，SHA-256 相对于 MD5 具有更高的安全性和抗碰撞性，因此在安全敏感的场景中，应该使用 SHA-256 或其他更强大的哈希算法来保护数据的完整性和安全性。\n\n然而，对于非安全相关的简单校验和一些非关键应用，MD5 仍然是一个快速且有效的哈希算法选择。\n\n2. 前端错位230810 下午改了一整个下午的前端，一直用的火狐。图标和输入框的样式都是直接手撸的，耗时较长。\n\n原以为大功告成了。结果把 url 往 edge 一粘贴，完蛋了，图标直接全部错位\n\n后来咨询了前端大佬才知道，不同浏览器对相同代码的渲染处理可能有所不同。如果用前端框架 bootstrap 就能较好的解决这个问题。\n而我的项目所使用的模板里面，也确实引入了bootstrap，但我不太会使用……\n","categories":["项目开发记录"],"tags":["Linux","mysql","C++"]},{"title":"【树莓派开发】使用树莓派在 Linux 环境下编写 C 语言代码","url":"/posts/3611814801/","content":"\n\n\n\n前言  如何使用树莓派编译 C 语言代码呢？\n\n\n21 年暑假的时候，学习编程的劲头高涨，然后冲动消费买了个树莓派 4B……结果压根不会用，吃灰了半年\n\n不过现在已经学完了 C 语言，也接触了一丢丢 Linux 系统下的 gcc 指令，可以尝试用它来编写 C 语言代码了！\n\n1. 创建 test.c 文件  首先我们需要在一个文件夹里创建一个 test.c 文件\n\n点击 test.c 文件后，树莓派会用自带的 Geany 编辑器 打开它\n然后我们可以往里写入 C 语言最经典的 helloword 代码\n#include &lt;stdio.h&gt;int main(void)&#123;\tprintf(&quot;hello wordl!\\n&quot;); \treturn 0;&#125;\n\n2. 编译运行该文件  保存文件后，打开顶部的命令行\n\n输入以下代码\n\n注意 cd 后需要空格，填写的是刚刚创建的 test1.c 文件的路径\n\ncd /home/pi/code\n\n填写完毕后，可以看到命令行前面多出了一个文件地址\n\n这代表目前我们操作的是 code 文件夹里面的内容\n输入ls，可以看到当下文件夹里的文件\n\n输入以下指令，可以生成一个可执行文件\ngcc test1.c -o test1\n\n\n最后输入以下指令，可以运行该文件！\n./test1\n\n可以看到，程序已经成功运行了！\n\n\n3. 编译并链接两个源文件  接下来我们再尝试一个相对来说更复杂的代码\n分开两个源文件，一个是test.c，包含了 main 函数\n另外一个是Add.c，包含了 Add 函数\n因为是在不同的源文件里面，我们需要用 extern 来声明外部函数\n#include &lt;stdio.h&gt; extern int Add(int x,int y); int main(void)&#123;\tint a=3;\tint b=5;\tprintf(&quot;%d&quot;,Add(a,b); \treturn 0;&#125;\n\n\n接下来我们使用 -c 指令来生成 .o 目标文件\n\n在 vs 下，目标文件的后缀是.obj\n.i文件为  预编译  文件\n\n可以看到，我的代码里面 extern 写错了（很是尴尬），编译器报了警告\n更改了以后就编译成功了\n\n这一步是把 C 语言代码转换成机器认识的二进制指令\n\n\n然后输入以下指令，链接这两个文件，生成可执行文件test\ngcc test1.c Add.c -o test\n\n\n最后还是使用 ./test 指令来运行可执行文件\n可以看到我们的结果已经输出了！\n\n结语  第一次尝试用 linux 的 gcc 指令来编译 C 语言代码，还有点小激动\n吃灰的树莓派终于有用了！😍\n\n如果有写的不对的地方，还请大佬无情指出！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【C 语言】蓝桥杯 /ACM 竞赛入门 A+B for Input-Output Practice","url":"/posts/2420712993/","content":"[TOC]\n【C 语言】蓝桥杯 &#x2F;ACM 竞赛 &#x2F;A+B上次参加了学校的蓝桥杯校队选拔“集训”\n第一次“测试”就直接被考傻了，虽然都是我“好像”学过的内容，但我里里外外真的看不出来到底怎么写，太离谱了！\n而且学长用的都是 C++，我只学了 c 语言，后面的题目完全看不懂了。\n当然，归根结底还是我太菜了\n在这里把我搞了好久终于弄懂的 A+B 题目分享给大家\n\n开始集训：A+B 不有手就行？\n结束后：我手呢?\n\n\n注：题目是英文的！！！！\n\n\nA+B for Input-Output Practice (I)Problem Description \nYour task is to Calculate a + b. \nToo easy?! Of course! I specially designed the problem for acm beginners.  \nYou must have found that some problems have the same titles with this one, yes, all these problems were designed for the same aim.  \nInput \nThe input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line.  \nOutput \nFor each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input.     \nSample Input \n1 510 20\n\nSample Output \n630 \n\n\n\n这道题看起来非常简单，我一上来就打上了两行 scanf，啪的一下就提交了\n然后系统啪的一下给我返回了  一个大大的红色 WRONG ANSWER\n正确做法如下：\n#include&lt;stdio.h&gt;  int main()  &#123;    int a,b;    while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF)       printf(&quot;%d\\n&quot;,a+b);  &#125;   \n\n不能直接使用两行 scanf 的原因是\n题目需要的是这串代码能  完整地使用多次，而不是简单的只执行两次\n在 while 里使用 EOF 的原因  这里使用 eof，可以让程序在未输入错误的情况下一直进行循环计算 a+b\nscanf 函数的返回值\nscanf 函数返回成功读入的数据项数，读入数据时遇到了“文件结束”则返回 EOF。\n如：scanf(“%d %d”,&amp;a,&amp;b);\n函数返回值为 int 型。如果 a 和 b 都被成功读入，那么 scanf 的返回值就是 2；\n如果只有 a 被成功读入，返回值为 1；\n如果 a 和 b 都未被成功读入，返回值为 0；\n如果遇到错误或遇到 end of file，返回值为 EOF。end of file 为 Ctrl+z 或者 Ctrl+d。\n[摘自百度知道用户 @纵横竖屏  的回答]\n\nEOF 的值为 -1，但不能简单的用 -1 代替 EOF\n\nA+B for Input-Output Practice (II)Problem Description \nYour task is to Calculate a + b. \nInput \nInput contains an integer N in the first line, and then N lines follow. Each line consists of a pair of integers a and b, separated by a space, one pair of integers per line.  \nOutput \nFor each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input.  \nSample Input \n21 510 20\n\nSample Output \n630\n\n\n\n这道题的意思其实就是在键入需要相加的数字之前，先键入需要相加的数字组数（也可以理解为行数）\n要求我们用  循环的方式  完成“相加数字行数”的操作\n完成 n 行后需要跳出该 a+b 的循环\n#include&lt;stdio.h&gt;int main()&#123;    int a, b;    int i, j;    int n;    scanf(&quot;%d&quot;, &amp;n);//n 即为行数    int sum[20] = &#123; 0 &#125;;    for (i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);        sum[i] = a + b;    &#125;    for (j = 0; j &lt; n; j++)    &#123;        printf(&quot;%d\\n&quot;, sum[j]);    &#125;&#125;\n\n\nA+B for Input-Output Practice (III)Problem Description \nYour task is to Calculate a + b. \nInput \nInput contains multiple test cases. Each test case contains a pair of integers a and b, one pair of integers per line. A test case containing 0 0 terminates the input and this test case is not to be processed.  \nOutput \nFor each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input.  \nSample Input \n1 5 10 200 0 \n\nSample Output \n630\n\n这道题的要求是 a+b 的程序在读取到两个 0 0 的时候会退出循环\n且代码不会处理这两个 0 0（把它们当作循环结束标志）\n#include&lt;stdio.h&gt;int main()&#123;\tint a = 0, b = 0, c;\twhile (1)\t&#123;\t\tscanf(&quot;%d%d&quot;, &amp;a, &amp;b);\t\tif (a == 0 &amp;&amp; b == 0)// 判断键入的是否为 0 0\t\t&#123;\t\t\tbreak;// 是 0 0，退出循环\t\t&#125;\t\telse// 不是 0 0，继续运行 a+b\t\t&#123;\t\t\tc = a + b;\t\t\tprintf(&quot;%d\\n&quot;, c);\t\t&#125;\t\t\t&#125;\treturn 0;&#125;\n\n\nA+B  for  Input-Output  Practice (IV)Description:\nYour task is to Calculate the sum of some integers.\nInput:\nInput contains multiple test cases. Each test case contains a integer N, and then N integers follow in the same line. A test case starting with 0 terminates the input and this test case is not to be processed.\nOutput:\nFor each group of input integers you should output their sum in one line, and with one line of output for each line in input.\nSample Input:\n4 1 2 3 45 1 2 3 4 50 \n\nSample Output:\n1015\n\n与前面的两个数字相加不同，这道题的要求是，先输入你需要相加的数字的个数，再依次键入数字\n遇到 0 的时候停止循环\n\n这个 0 必须是第一个数字，即代表需要“0 个数字相加”\n如果是需要相加的数字里有 0，不应退出循环\n\n#include&lt;stdio.h&gt;int main() &#123;\tint n, sum, i, t;\twhile (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0) // 判断是否等于 0\t&#123;\t\tsum = 0;\t\tfor (i = 0; i &lt; n; i++) \t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;t);\t\t\tsum = sum + t;// 不断往 sum 里面加数字\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, sum);\t&#125;&#125;\n\n\nA+B  for  Input-Output  Practice (V)Description:\nYour task is to calculate the sum of some integers.\nInput:\nInput contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line.\nOutput:\nFor each group of input integers you should output their sum in one line, and with one line of output for each line in input.\nSample Input:\n24 1 2 3 45 1 2 3 4 5\n\nSample Output:\n1015\n\n这道题和上一道题的要求差不多，结合了第二题的内容，即我们在键入需要相加的数字之前，要先键入“行数”\n当然它也少了在遇到 0 的时候退出循环\n#include&lt;stdio.h&gt;int main() &#123;\tint n, a, b, i, j, sum;\tsum = 0;\twhile (scanf(&quot;%d\\n&quot;, &amp;n) != EOF) \t&#123;\t\tfor (i = 0; i &lt; n; i++) \t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;b);\t\t\tfor (j = 0; j &lt; b; j++) \t\t\t&#123;\t\t\t\tscanf(&quot;%d&quot;, &amp;a);\t\t\t\tsum += a;\t\t\t&#125;\t\t\tprintf(&quot;%d\\n&quot;, sum);\t\t\tsum = 0;\t\t&#125;\t&#125;&#125;\n\n\nA+B  for  Input-Output  Practice (VI)Description:\nYour task is to calculate the sum of some integers.\nInput:\nInput contains multiple test cases, and one case one line. Each case starts with an integer N, and then N integers follow in the same line.\nOutput:\nFor each test case you should output the sum of N integers in one line, and with one line of output for each line in input.\nSample Input:\n4 1 2 3 45 1 2 3 4 5\n\nSample Output:\n1015\n\n这道题和第四题很像，就缺少了遇到 0 停止\n#include&lt;stdio.h&gt;int main() &#123;\tint n, sum, i, t;\twhile (scanf(&quot;%d&quot;, &amp;n) != EOF) \t&#123;\t\tsum = 0;\t\tfor (i = 0; i &lt; n; i++) \t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;t);\t\t\tsum = sum + t;\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, sum);\t&#125;&#125;\n\n\nA+B  for  Input-Output  Practice (VII)Description:\nYour task is to Calculate a + b.\nInput:\nThe input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line.\nOutput:\nFor each pair of input integers a and b you should output the sum of a and b, and followed by a blank line.\nSample Input:\n1 510 20\n\nSample Output:\n630\n\n这道题多了一个要求，“followed by a blank line.”\n需要我们在代码完成后，跟着打印一个空行，也就是 \\n\n#include&lt;stdio.h&gt;int main()&#123;    int a, b;    while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) != EOF)        printf(&quot;%d\\n&quot;, a + b);        printf(&quot;\\n&quot;);// 打印空行    return 0;&#125;\n\n\nA+B  for  Input-Output  Practice (VIII)Description:\nYour task is to calculate the sum of some integers.\nInput:\nInput contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line.\nOutput:\nFor each group of input integers you should output their sum in one line, and you must note that there is a blank line between outputs.\nSample Input:\n34 1 2 3 45 1 2 3 4 53 1 2 3\n\nSample Output:\n10156\n\n这道题的要求结合了上面的题目\n\n需要先键入“行数”\n需要在相加之前键入 需要相加的数字的个数\n打印答案后需要再打印一个 空行\n\n也不怕大家笑话，这道题是我抄的，原博客在这 [点我]\n\n原博客中在 for 循环的 scanf 前多了一个 if(i&#x3D;&#x3D;0)的代码，我实在没看懂这句代码的意义，去掉之后系统依旧判对！\n\n#include&lt;stdio.h&gt;int main()&#123;    int test,t=0;     scanf(&quot;%d&quot;,&amp;test);// 行数    while(test--)// 每执行一次，减少一行    &#123;    int s=0,i;    int n,a[1000];// 用数组的方式完成相加    scanf(&quot;%d&quot;,&amp;n);// 需要相加的数字的个数    for(i=0;i&lt;n;i++)    &#123;            scanf(&quot;%d&quot;,&amp;a[i]);            s+=a[i];    &#125;    t++;    if(t&gt;1)        printf(&quot;\\n&quot;);    printf(&quot;%d\\n&quot;,s);    &#125; return 0;&#125;\n\n\n呼！终于写完这篇博客了\n如果这对你有帮助，还请点赞关注收藏吧！\n这对我真的很重要！\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题"]},{"title":"【树莓派开发】出现报错 pragama once in main file","url":"/posts/3252921223/","content":"\n\n前言  众所周知，#pragma once语句是  防止头文件重复包含  非常常用的一条语句 VS 编译器在创建.h 文件的时候会自动帮你在开头添加这个语句 但是在 gcc 编译器下，这个语句就可能会出现一些问题\n\n所使用编译器：\n\nVS2019（windows10）\n树莓派（linux-gcc）\n\n\nwarning: #pragma once in main file在我尝试在 linux 环境下使用 #pragma once 语句时，遇到了这个报错\n\n解决这个问题的办法很简单，就是不要编译头文件\n\n编译器会自动展开头文件，无需手动编译\n\n\n\n出现问题原因  网上查了查：出现这个问题的原因是编译器在编译头文件的时候，#pragma once本身是没有含义的语句，所以报错了。\n\n也有人说是  因为 linux 不支持这个语句，我们来试试\n\n右侧代码中包含了两个 test.h 的引用，在预处理中只包含了一次\n\n去掉头文件中的#pragma once，再次编译，可以看到预处理文件中出现了两次头文件的内容\n\n这说明 linux-gcc 编译器是支持该语句的，并非网上说的不支持！\n其他解决方法  如果你的 gcc 编译器不管咋弄都有这个报错，咱可以不用它嘛！使用  条件编译指令 ifndef也可以达成防止头文件重复包含的效果\n#ifndef __TEST_H__// 如果没有定义过这个符号#define __TEST_H__// 定义该符号// 头文件内容#endif\n\n\n查资料查到外网去了~刚刚写预处理博客的时候，查有关这个问题的资料，百度都给我推了外网的论坛\n\n参考：https://bbs.csdn.net/topics/395771733?page=1\n\n\n网上有关这个报错的信息的确不多，特此写篇博客记录一下\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【树莓派开发】树莓派 GeanyIDE 和控制台下 C/C++ 中文乱码问题解决方法","url":"/posts/330726760/","content":"\n\n\n\n情况说明  之前使用树莓派的时候，遇到了中文乱码的问题。\n\nVS2019 编译器下写的.c 文件，里面的中文注释在树莓派 ide 上乱码\n树莓派控制台上，C 语言代码输出中文时乱码\n\n这里需要调整三个设置来解决该问题\n1. 设置 VS，将文件保存为 UTF8 编码VS2019 默认用的是 GBK 编码，而不是一般中文需要的 UTF8 编码\n这里我们可以安装一个 Force UTF-8(No BOM) 插件来解决该问题\n\n在 VS 顶部工具栏里找到“拓展”- 管理拓展\n\n\n\n搜索 Force UTF-8(No BOM)，找到该插件并安装\n\n\n这个插件的作用，是让 VS 保存文件都使用 UTF8 编码保存\n安装完毕后，可以在原本文件中打一个注释并保存，这时候.c 文件就已经是 UTF8 编码了\n\n\n\n树莓派中可以更改文件编码，但这个更改并不会对已经乱码了的中文生效\n\n更新 22.03.01：使用该插件可能会导致报错  该文件包含不能在当前代码页 (936) 中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失  出现这种情况需要禁用插件，重启 VS 才能解决。否则程序有中文注释就无法运行\n2. 更改 Geany IDE 编码设置  更改完 VS 的设置后，我们需要更改树莓派下 IDE 的设置\n在  编辑 - 首选项  里面选择  文件，将两个设置选项都改为 UTF8\n\n\n3. 更改树莓派系统设置  前面两个设置完之后，我们还需要在树莓派的控制系统中输入一串命令\nsudo raspi-config\n\n\n选择第 4 个，区域语言设定，进入后选择第一个，来到如下界面\n\n找到zh_cn.UTF8\n\n选择后，会进入设置界面，提示 complete 就完成设置了\n\n再次进入树莓派，用控制台运行我们的代码，可以看到中文已经正常显示了！\n\n\n\n如果这篇博客对你有帮助，还请点赞支持一下，谢谢！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【leetcode】151. 翻转字符串中的单词","url":"/posts/4154393368/","content":"题目链接 https://leetcode.cn/problems/reverse-words-in-a-string/\n方案 1class Solution &#123;public:    // 从 begin 开始找到下一个空格的下标，不包括 begin 本身    int find_space(string&amp;s,int begin=0)    &#123;        int i=0;        for(i=begin+1;i&lt;s.size();i++)        &#123;            if(s[i]==&#x27; &#x27;)&#123;                return i;            &#125;        &#125;        return s.npos;    &#125;    string reverseWords(string s) &#123;        int i=0;        vector&lt;string&gt; v;// 用来存放单词        for(i=0;i&lt;s.size();i++)        &#123;            // 跳过前导空格            while(s[i]==&#x27; &#x27;)&#123;                i++;            &#125;            // 如果已经到最后面了，就直接跳出            if(i&gt;=s.size())&#123;                break;            &#125;            int index = find_space(s,i);            int sz = index-i;// 单词长度            //cout &lt;&lt; i &lt;&lt; &quot; | &quot; &lt;&lt; index &lt;&lt; &quot; | &quot;&lt;&lt; sz &lt;&lt; endl;            string temp(s,i,sz);            //cout &lt;&lt; temp &lt;&lt; &quot;-&quot; &lt;&lt; endl;            v.push_back(temp);// 插入单词            i = index-1;// 跳过当前单词        &#125;        // 反向迭代器        auto it = v.rbegin();        string ret = &quot;&quot;;        while(it!=v.rend())        &#123;            ret+=*it;            // 不是倒数第一个才加空格            if(++it!=v.rend())&#123;                ret+=&quot; &quot;;            &#125;        &#125;        cout &lt;&lt; ret &lt;&lt; endl;        return ret;    &#125;&#125;;\n\n上面的办法中，新增了一个 vector 来拼接字符串，空间复杂度 O(N)\n测试 4MS 7.2MB\n版本 2进阶要求：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\n// 版本 2，原地算法吗？class Solution &#123;public:    #define SEP &#x27;|&#x27;    // 从 begin 开始找到下一个空格的下标，不包括 begin 本身    int find_space(string&amp;s,int begin=0)    &#123;        int i=0;        for(i=begin+1;i&lt;s.size();i++)        &#123;            if(s[i]==&#x27; &#x27;)&#123;                break;            &#125;            else if(s[i]==SEP)            &#123;// 用一个特殊字符作为原字符串结尾                break;            &#125;        &#125;        // 如果是因为找到空格跳出，判断该字符串后面还有没有有效字符        int k = i;// 不能改 i        if(s[k]!=SEP)        &#123;            while(s[k]==&#x27; &#x27;)            &#123;                k++;                // 一直走到了 |，代表没有有效字符了                if(s[k]==SEP)&#123;                    return s.npos;                &#125;            &#125;            // 走到这里代表有            return i;        &#125;        return s.npos;    &#125;    string reverseWords(string s) &#123;        int i=0,end_word=0,index=0;        int begin_sz = s.size();// 起始大小        s+=SEP;// 用一个特殊字符作为原字符串结尾        int sep_index = s.size()-1;// 最后一个字符的位置就是分隔符                for(i=0;i&lt;begin_sz;i++)        &#123;            // 跳过前导空格            while(s[i]==&#x27; &#x27;)&#123;                i++;            &#125;            // 如果已经到最后面了，就直接跳出            if(i&gt;=begin_sz)&#123;                break;            &#125;            index = find_space(s,i);            // 如果找不到下一个空格了，代表当前是原字符串最后一个单词            // 跳过            if(index == s.npos)&#123;                end_word=i;                break;            &#125;            int sz = index-i;// 单词长度            string temp(s,i,sz);            temp+=&quot; &quot;;            // 不能尾插，应该在 sep 之后插入            //s += temp;            s.insert(sep_index+1,temp);            // cout &lt;&lt; i &lt;&lt; &quot; | &quot; &lt;&lt; index &lt;&lt; &quot; | &quot;&lt;&lt; sz &lt;&lt; endl;            // cout &lt;&lt; temp &lt;&lt; &quot;-&quot; &lt;&lt; endl;            // 构造了之后，把原 str 这部分删了(错误！删了之后下标变了，循环无意义)            //s.erase(i,sz);            i = index-1;// 跳过当前单词            //index-1 是因为本次循环过了之后会被 for 给 +1        &#125;        cout &lt;&lt;&quot;[end]&quot;&lt;&lt; s &lt;&lt; endl;        // 字符串中添加的 | 替换为空格        index = s.find(SEP);                // 删除 index 之前,end_word 之后的空格        int k = s.find(&quot; &quot;,end_word);        //cout &lt;&lt; &quot;k:&quot; &lt;&lt;k&lt;&lt;&quot; endw:&quot; &lt;&lt; end_word &lt;&lt;endl;        if(k!=s.npos&amp;&amp;k&lt;index)&#123;            s.replace(k,1,&quot;&quot;);            index--;            //cout &lt;&lt;&quot;[while1]k:&quot;&lt;&lt;k &lt;&lt;&quot; str:&quot;&lt;&lt; s &lt;&lt; endl;            // 因为替换过了之后，k 的位置变成了原有 k 的下一位            // 此时如果 k 还是空格，代表原字符串末尾有多个空格            // 继续删除，但是每次删除都需要让 sep 的位置 -1            while(s[k]==&#x27; &#x27;)&#123;                s.replace(k,1,&quot;&quot;);                index--;            &#125;            // 跳出这个循环的时候，代表碰到 sep 分隔符了, 字符串已经处理完毕            //cout &lt;&lt;&quot;[while2]k:&quot;&lt;&lt;k &lt;&lt;&quot; str:&quot;&lt;&lt; s &lt;&lt; endl;        &#125;        s.replace(index,1,&quot; &quot;);        s.erase(0,end_word);// 删掉前面的原有单词        s.erase(s.size()-1,1);// 删除最后单词带的空格        return s;    &#125;&#125;;\n\n结果 4MS 7MB\n方案 3上面的办法看起来很对，实际上还是不是原地算法！\n因为我每次都是在后面尾随字符串，而没有把原字符串删掉。如果源字符串很长，我这么做就相当于把源字符串的长度变为原有俩倍\n\n依旧是 O(N)的空间复杂度\n\n要想做到真原地，就需要在插入到指定位置的同时，将其原本的字符串给删除了\n// 方案 3class Solution &#123;public:    #define SEP &#x27;|&#x27;    // 从 begin 开始找到下一个空格的下标，不包括 begin 本身    int find_space(string&amp;s,int begin=0)    &#123;        int i=0;        for(i=begin+1;i&lt;s.size();i++)        &#123;            if(s[i]==&#x27; &#x27;)&#123;                break;            &#125;            else if(s[i]==SEP)            &#123;// 用一个特殊字符作为原字符串结尾                break;            &#125;        &#125;        // 如果是因为找到空格跳出，判断该字符串后面还有没有有效字符        int k = i;// 不能改 i        if(s[k]!=SEP)        &#123;            while(s[k]==&#x27; &#x27;)            &#123;                k++;                // 一直走到了 |，代表没有有效字符了                if(s[k]==SEP)&#123;                    return s.npos;                &#125;            &#125;            // 走到这里代表有            return i;        &#125;        return s.npos;    &#125;    string reverseWords(string s) &#123;        int i=0,end_word=0,index=0;        int begin_sz = s.size();// 起始大小        s+=SEP;// 用一个特殊字符作为原字符串结尾        int sep_index = s.size()-1;// 最后一个字符的位置就是分隔符                for(i=0;i&lt;begin_sz;i++)        &#123;            // 跳过前导空格            while(s[i]==&#x27; &#x27;)&#123;                i++;            &#125;            // 如果已经到最后面了，就直接跳出            if(i&gt;=begin_sz)&#123;                break;            &#125;            index = find_space(s,i);            // 如果找不到下一个空格了，代表当前是原字符串最后一个单词            // 跳过            if(index == s.npos)&#123;                end_word=i;                break;            &#125;            int sz = index-i;// 单词长度            string temp(s,i,sz);            temp+=&quot; &quot;;            // 不能尾插，应该在 sep 之后插入            //s += temp;            s.insert(sep_index+1,temp);            //printf(&quot;[%d-%d-1]%s\\n&quot;,i,sep_index,s.c_str());            // cout &lt;&lt; i &lt;&lt; &quot; | &quot; &lt;&lt; index &lt;&lt; &quot; | &quot;&lt;&lt; sz &lt;&lt; endl;            // cout &lt;&lt; temp &lt;&lt; &quot;-&quot; &lt;&lt; endl;            // 构造了之后，把原 str 这部分删了(错误！删了之后下标变了，循环无意义)            s.erase(i,sz);            sep_index-=sz;            //printf(&quot;[%d-%d-2]%s\\n&quot;,i,sep_index,s.c_str());            // i = i;// 跳过当前单词            //index-1 是因为本次循环过了之后会被 for 给 +1        &#125;        //cout &lt;&lt;&quot;[end]&quot;&lt;&lt; s &lt;&lt; endl;        index = s.find(SEP);        // 删除 index 之前,end_word 之后的空格        int k = s.find(&quot; &quot;,0);        //cout &lt;&lt; &quot;k:&quot; &lt;&lt;k&lt;&lt;&quot; endw:&quot; &lt;&lt; end_word &lt;&lt;endl;        while(k!=s.npos&amp;&amp;k&lt;index)&#123;            s.replace(k,1,&quot;&quot;);            index--;            //cout &lt;&lt;&quot;[while1]k:&quot;&lt;&lt;k &lt;&lt;&quot; str:&quot;&lt;&lt; s &lt;&lt; endl;            // 因为替换过了之后，k 的位置变成了原有 k 的下一位            // 此时如果 k 还是空格，代表原字符串末尾有多个空格            // 继续删除，但是每次删除都需要让 sep 的位置 -1            while(s[k]==&#x27; &#x27;)&#123;                s.replace(k,1,&quot;&quot;);                index--;            &#125;            // 跳出这个循环的时候，代表碰到 sep 分隔符了, 字符串已经处理完毕            //cout &lt;&lt;&quot;[while2]k:&quot;&lt;&lt;k &lt;&lt;&quot; str:&quot;&lt;&lt; s &lt;&lt; endl;            k = s.find(&quot; &quot;,0);        &#125;        //cout &lt;&lt;&quot;[end2]&quot;&lt;&lt; s &lt;&lt; endl;        s[index]=&#x27; &#x27;;        //s.erase(0,end_word);// 删掉前面的原有单词        s.erase(s.size()-1,1);// 删除最后单词带的空格        //cout &lt;&lt;&quot;[return]&quot;&lt;&lt; s &lt;&lt; endl;        return s;    &#125;&#125;;\n\n思路 4，来自代码随想录 P92详见注释\n// 思路 4，来自代码随想录 P92class Solution &#123;public:    // 删除空格，时间复杂度 O(N)    void removeSpace(string&amp; s)    &#123;        int slow=0,fast=0;        // 这个循环结束后，fast 会走到第一个不为空格的字符上         while(s.size()&gt;0 &amp;&amp; fast&lt; s.size()&amp;&amp;s[fast]==&#x27; &#x27;)&#123;            fast++;        &#125;        // 此时开始复写（也会将字符串开头的空格给替换掉）        for(/* 不写第一个，fast 的位置没有变动 */;fast&lt;s.size();fast++)        &#123;               //fast 要大于 1 才能判断 fast 上一位            // 上一位和这一位不相等（判端连续空格）            // 当前位是否位空格（是就代表是连续空格）            //continue 会找到一段空格之后的第一个非空格字符            if(fast&gt;1 &amp;&amp; s[fast-1] == s[fast]                        &amp;&amp; s[fast]==&#x27; &#x27;)                continue;            else            &#123;// 复写                s[slow]=s[fast];                slow++;            &#125;        &#125;        // 复写结束后，此时 slow 所在位置是原有字符串的末尾，且会有一个多余的空格        // 因为在上面替换的时候，已经将多余的空格跳过了，所以只会有一个空格        // 只需要判断有没有空格，将其去掉就行        // 注意，此时 slow 所在位置可能是源字符串中的字母上，并不一定是空格        if(slow&gt;1 &amp;&amp; s[slow-1]==&#x27; &#x27;)        &#123;            s.resize(slow-1);        &#125;        else        &#123;            s.resize(slow);        &#125;    &#125;        // 逆置字符串    // 每次逆置的时间复杂度为 O((START-END)/2)    void revserseString(string&amp;s,int start,int end)    &#123;        // 等于的情况也是可以的，只不过此时压根不做交换        assert(end&lt;s.size()&amp;&amp;start&lt;=end);        int i=start,j=end;        for(;i&lt;j;i++,j--)        &#123;            swap(s[i],s[j]);        &#125;    &#125;    // 思路有点类似 `189 轮转数组 ` 中的三旋法    // 先去掉冗余空格    // 把整个字符串逆置    // 再单独逆置所有单词    string reverseWords(string s) &#123;        // 删多余空格        removeSpace(s);        // 逆置字符串        revserseString(s,0,s.size()-1);        //printf(&quot;|%s|\\n&quot;,s.c_str());        // 扫描出单词，逆置每个单词        // 因为已经删除多余空格了，所以 s[0] 肯定是单词        int begin=0,cur=1;        while(cur&lt;s.size() &amp;&amp; begin&lt;s.size())        &#123;            // 当前不是空格 ++            while(cur!=begin&amp;&amp;s[cur]!=&#x27; &#x27;&amp;&amp;cur&lt;s.size())            &#123;                //cout &lt;&lt; begin &lt;&lt; &quot;-&quot; &lt;&lt; cur&lt;&lt; &quot;-&quot; &lt;&lt; s[cur]&lt;&lt;endl;                cur++;            &#125;            // 停下来代表是空格, 逆置            // 如果是最后一个单词，停下来的时候是因为 cur==s.size()            // 此时 cur-1 就正好是倒数第一个字符            //cout &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; cur &lt;&lt;endl;            revserseString(s,begin,cur-1);            // 更新下标            begin= cur+1;            cur+=2;// 保证 cur 是 begin 的下一位        &#125;        return s;    &#125;&#125;;\n\n测试 4MS 6.8MB\n一定要记得删除 printf以后写 oj 的时候，一定要记得删除用来 debug 的 printf，否则用时特别特别长！\n如下相同代码，删除 pirntf 之后快了十倍\n\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C++","leetcode"]},{"title":"【树莓派开发】树莓派安装 vim 编辑器（附带排错流程）","url":"/posts/919850587/","content":"\n\n前言Linux 自带的编辑器有 nano 和 vi，但 vi 编辑器使用起来很不方便。\n我们要先在树莓派上  下载 vim 编辑器，它是 vi 编辑器的升级版本，使用更加人性化\n\n但实际上安装 vim 编辑器 并没有网上写的那么简单，在安装过程中出现了种种问题😭\n\n1. 用 putty 软件链接树莓派Putty 软件想必把玩树莓派的你应该是很熟悉的。\n输入 ip 后即可链接到你的树莓派，方便我们进行后续的操作\n\n2. 下载 vim首先更新索引源\nsudo apt-get update \n\n安装 vim 编辑器\nsudo apt-get install vim\n\n2.1 错误：404 无法下载  安装过程中可能会有错误提示，比如我这里就显示无法连接到服务器404，且软件包下载失败\n\n\n解决方法参考这篇博客👉传送门 1\n\n因为树莓派默认的软件源是国外的，国内可能链接不少，所以我们要把下载源修改为国内清华的\n需要修改两个文件来进行这个操作\nsudo nano /etc/apt/sources.list\n\n在句首加上 #注释掉第一行的语句后，在后面加上下面这两行语句\n注意：这里不能  复制粘贴，老老实实敲吧😥\ndeb 空格 http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ 空格 stretch 空格 main 空格 contrib 空格 non-free 空格 rpideb-src 空格 http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ 空格 stretch 空格 main 空格 contrib 空格 non-free 空格 rpi\n\n\n编辑好后，按 CTRL+X 保存，再按 y 确认，最后按  回车  回到命令行\n\n\n再运行下面这条指令，打开另外一个文件\nsudo nano /etc/apt/sources.list.d/raspi.list\n\n依旧要 #注释掉第一行的语句，在末尾加上 上面的两个 deb 语句\ndeb 空格 http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ 空格 stretch 空格 main 空格 contrib 空格 non-free 空格 rpideb-src 空格 http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ 空格 stretch 空格 main 空格 contrib 空格 non-free 空格 rpi\n\n编辑好后，按 CTRL+X 保存，再按 y 确认，最后按  回车  回到命令行\n\n两个文件都编辑完后，使用 sudo apt-get update 查看有没有报错，如果有什么奇怪的报错，建议回去检查一下是不是写错了。\n我这里是这样的情况，实际上它已经搞定了\n\n这时候就可以再次使用下面的语句安装 vim 了\nsudo apt-get install vim\n\n2.2 错误：下列软件包有未满足的依赖关系  但很快我就出现了第二个问题👇\n下列软件包有未满足的依赖关系： vim : 依赖: vim-common (= 2:8.0.1453-1ubuntu1) 但是 2:8.0.1453-1ubuntu1.4 正要被安装 E: 无法修正\n\n这是因为我们第一次没有正常下载 vim 的时候，留下了一个旧版本的安装包\n\n解决方法参考这篇博客👉传送门 2\n\n依次运行下面的语句，卸载 vim-common\nsudo apt-get purge vim-commonsudo apt-get updatesudo apt-get upgrade\n\n\n完成上述操作后，再次尝试安装 vim\nsudo apt-get install vim\n\n这一次我才成功把 vim 安装下来\n\n\n3. 查看 vim 是否安装成功  用下面这个最简单的方法查看 vim 有没有安装成功\nvim test.txt\n\n如果安装失败，会出现这个报错。尝试跟着上面的步骤再走一遍，如果还不行我也不知道咋办😂\n-bash: vim: 未找到命令\n\n出现这个界面就代表安装完毕了，可以输入 :q 退出\n\n先来配置一下 vim 编辑器\nsudo nano /etc/vim/vimrc\n\n在打开的文件中，用方向键⬇来到最后，输入下面的三句话（可以不加注释）\nset nu   # 显示行号syntax on   # 语法高亮set tabstop=4 # tab 退四格, 默认是 8 格set softtabstop=4  set shiftwidth=4  # 设置缩进的空格数set autoindent # 每行的缩进值与上一行相等\n\n4.vim 的基本操作  前人栽树，后人乘凉\n\n基本操作参考这篇博客👉博客园、\n\n其实只是我  懒，不想写而已😥\n5. 用 vim 编写一个 C 语言代码  到这里，你的 vim 就基本配置完毕啦！让我们来试试用它写一个代码\nvim test.c\n\n这个会在当前目录下创建一个 test.c 文件，我们来一个最简单的 printf 代码\n\n编辑完毕后，按 ESC 退出编辑状态，回到初始模式\n\n输入 :wq 保存并退出当前文件\n\nls之后可以看到，已经多出来了一个 test.c 的文件，后面的操作就是 gcc 指令了\n\ngcc test.c -o TEST\n\n再次 ls 可以看到多出了一个可执行文件 TEST，执行该文件，程序成功运行\n\n结语  到这里，咱们的 vim 编辑器的初始学习就结束啦！后续进阶的指令学习，大家可以看第 4 点中博主的讲解偶！\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【树莓派开发】使用 cpolar 实现内网穿透，远程连接在家里的树莓派","url":"/posts/412631379/","content":"众所周知，一般我们远程连接树莓派，需要它和我们的电脑在同一局域网下。如果出门要用树莓派的话，只能把它一并带出门。\n可如果我们想偷懒，把树莓派连上网线或 wifi 丢家里，然后在另外一个网络下远程连接树莓派的话，就需要借助 cpolar 来实现内网穿透，把树莓派变为  联网的远程 LINUX 服务器\n\n\n\n如果你还没有配置好树莓派的基本使用环境，可以参考我的博客🚪【传送门】\n\n\n关于 cpolar 在树莓派上的基本配置，官方有很详细的帮助文档，但是里面有一些问题介绍的并不算清楚【官方文档连接】\n本文是对官方帮助文档的细化（很多我搜到的博客基本就是照搬官方帮助文档）\n在开始之前，请先注册一个你的 cpolar 账户\n\nhttps://www.cpolar.com/\n\n1. 修改树莓派密码  注意 ：使用cpolar 共享的 SSH 接口，主机地址都是一样的，只是端口号不一样\n为了避免有小人，随机生成端口号，偷偷摸摸连接我们的树莓派搞破坏\n这里建议大家一定要先修改你的初始密码！\nsudo passwd pi\n\n2. 在树莓派上初始化 cpolar2.1 下载  用这个语句安装cpolar（国内用户）\ncurl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash\n\n或者这个语句（适用于国外用户）\ncurl -sL https://git.io/cpolar | sudo bash\n\n软件不是很大，一下子就下好了\n\n使用这个语句查看版本信息\ncpolar version\n\n如果出现下图代表已经安装 OK 了\n\n2.2token 验证  注册账号后，选择了免费界面，你就可以进入后台管理系统\n点击  验证 ，可以找到你的 隧道 Authtoken\n\n复制它，然后在树莓派上用下面的语句设置 token\ncpolar authtoken xxxxxxxxxxxxxxxxxx\n\n\n2.3 设置 cpolar 开机自启和系统保护  开机自启动\nsudo systemctl enable cpolar\n\n守护进程方式，启动 cpolar（类似于把 cpolar 设置成了白名单应用）\nsudo systemctl start cpolar\n\n查看守护进程状态\nsudo systemctl status cpolar\n\n\n如图，状态为active, 说明启动状态成功\n2.4 查看隧道端口 cpolar 会默认安装两个样例隧道，一个是 Website 隧道指向 http 8080 端口，一个是 ssh 隧道，指向tcp 22 端口\n为了不暴露我自己的 SSH 连接地址，这里直接丢官方帮助文档里面的图\n\n和官方这里不同，我的后台管理中只有两个 website 地址和一个 ssh 地址\n2.5 使用 putty 或者 Xshell 远程连接树莓派  确认你的 ssh 连接后，需要在树莓派本地设置一下\nssh pi@1.tcp.vip.cpolar.cn -p 20013\n\n这里会让你填写  树莓派的密码 ，并不是cpolar 的密码\n填写完毕后，到这里已经设置完毕啦！是不是很简单？\n\n下面来试试远程使用树莓派\n假设我们的 SSH 地址是下面这个\ntcp://1.tcp.vip.cpolar.cn:20013\n\n那么在 Xshell 中的主机和端口分别就要填写\n\n主机1.tcp.vip.cpolar.cn\n端口20013\n\n然后就能连接上你的树莓派\n这里需要你输入  你树莓派的用户名和密码，输入完毕后，就和局域网使用树莓派没啥区别啦！\n\n我搜资料的时候，就是这里填错了，导致一直没连上树莓派\n\n结语  如果对于初始化设置 cpolar 有啥问题，可以在评论区留言\n复杂问题别问，我不会！！！！！😂\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【树莓派】实验 05- 激光传感器","url":"/posts/3386580555/","content":"\n\n前言  我手头的资料上，又说了一堆和本实验相关但又毫不相关的内容\n还是得自己找资料才能确认我的“猜想”，具体是啥，且往下细看！\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\n激光传感器模块（其实只是一个  发射器）\n跳线若干\n\n2. 实验原理  激光传感器常见于测距用途。它由  激光发射器、激光检测器和测量电路组成。它的优点是能够实现无接触远距离测量，速度快，精度高，量程大。\n激光传感器模块由一个 650nm 红色激光二极管头 和一个  电阻器  组成\n\n激光传感器工作时，先由激光发射二极管对准目标发射激光脉冲。经目标反射后激光向各方向散射。部分散射光返回到  传感器接收器 ，被光学系统接收后成像到雪崩光电二极管上。 雪崩光电二极管  是一种内部具有放大功能的光学传感器，因此它能检测极其微弱的光信号，并将其转化为相应的电信号。\n\n书上介绍了这么一堆，弄的好像这个小家伙就集成了上面 3 个传感器一样。我刚看书的时候，一脸懵逼 ，这么小一个玩意就能测距？自己找了资料才能 勉强确认 ，它就是一个 单纯的激光发射器  罢了。\n\n作为一个萌新，书上的内容的确对我产生了误导，还需要自己查阅资料，有点浪费时间。\n\n\n2.1 电路图\n2.2 接线图\n\n\n树莓派\nT 型转接板\n激光传感器模块\n\n\n\nGIPO 0\nGPIO 17\nSIG(S)\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND(-)\n\n\n\n实物接线图如下，本实验接线比较简单\n\n右上角的  红黑线  是接给树莓派散热风扇的，和本实验无关\n\n\n\n3. 代码示例  老样子，给出 C 语言代码。\n#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_LaserPin 0  // 定义激光传感器管脚int main()&#123;\t// 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\t\tpinMode(makerobo_LaserPin, OUTPUT); // 激光传感器设置为输出模式\t\tint k=2;\twhile(k--)\t&#123;\t\tdigitalWrite(makerobo_LaserPin, HIGH); // 打开激光传感器\t\tdelay(1000); // 延时 1s                           \t\tdigitalWrite(makerobo_LaserPin, LOW);  // 关闭激光传感器\t\tdelay(1000); // 延时 1s    \t&#125;\t\tdigitalWrite(makerobo_LaserPin, LOW); // 循环结束后，恢复关闭状态\tdelay(500); \t\treturn 0;&#125;\n\n\n代码中的两个 wiringPi 函数 在上篇实验博客中有讲解👉传送\n\n3.1Genay 编译器  老样子，三板斧（其实这句话都是从之前的博客复制过来的😂）\n\n\n在 Geany 里面用  生成命令  引用 wiringPi 库\n在 Geany 的 build(生成)--&gt;set build commands(设置生成命令）中输入以下指令gcc -Wall -c &quot;%f&quot; -lwiringPi\n\n效果如下，激光发射器在延时后  不断开关\n请不要将激光发射器对准任何人！伤眼！！！\n\n\n3.2LinuxGcc 编译器\n为了防止 Linux-Gcc 环境中无法正常终止程序，建议不要使用 while(1) 死循环。你可以将 k 设置得  大一点，方便观察实验结果\n\ncd打开对应文件路径，ls显示当前路径下的文件\n输入以下指令编译代码，生成可执行文件 TEST\ngcc -Wall 05laser.c -o TEST -lwiringPi\n\n./TEST运行可执行文件\n\n如果没有报错，那就是编译成功了，你可以观察到相同的实验结果\n结语  欸这博客都看到这里了，怎么不点关注啊？\n就算你不想关注我，那就关注一下专栏嘛！👉传送门\nTNND！关注，为什么不关注！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 00- 配置你的树莓派","url":"/posts/4174630598/","content":"\n\n前言  为了完善本专栏的内容，这次我把树莓派的初始化配置也给大家加上。\n干货满满，跟着我一步一步配置，从无到有玩转树莓派！😋\n\n当然前提是你要有一个树莓派，2022 年的树莓派价格可太魔幻了，涨价 1 倍，堪比显卡市场……\n\n不扯这些没用的了，本篇博客，带你走入树莓派这款小电脑的世界！\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1. 什么是树莓派？Raspberry Pi(中文名为“树莓派”, 简写为 RPi，或者 RasPi &#x2F; RPI\n它为学习计算机编程教育而设计，是一个只有信用卡大小的  微型电脑 ，其系统基于Linux。 自问世以来，受众多 计算机发烧友和创客  的追捧，曾经一“派”难求。别看其外表“娇小”，内“芯”却很强大，视频、音频等功能通通皆有，可谓是“麻雀虽小，五脏俱全”。\n\n它是一款基于 ARM 的微型电脑主板，以 SD&#x2F;MicroSD 卡为内存硬盘，卡片主板周围有 1&#x2F;2&#x2F;4 个 USB 接口和一个 10&#x2F;100 以太网接口（A 型没有网口），可连接键盘、鼠标和网线，同时拥有视频模拟信号的电视输出接口和 HDMI 高清视频输出接口，以上部件全部整合在一张仅比信用卡稍大的主板上，具备所有 PC 的基本功能只需接通电视机和键盘，就能执行如电子表格、文字处理、玩游戏、播放高清视频等诸多功能。\n Raspberry Pi B 款只提供电脑板，无内存、电源、键盘、机箱或连线。\n\n这种历史啥的就不说太多啦，想必大家都懒得看这种东西😂\n\n1.1 什么用户适合购买树莓派学习编程？\n在淘宝搜索树莓派，你会发现绝大部分商家都挂着“0 基础学习的”幌子，大肆宣传。而且宣传集中于最近挺火的 python 语言，对 C 和 C++ 只是提一嘴。\n\n作为 C&#x2F;C++ 方向的编程学习者，我个人建议，购买树莓派之前，需要先学习完  初阶的 C 语言 。如何量化呢，大概就是要把目前 b 站最火的这个 C 语言视频看到P24👉  传送门\n\n如果你和我一样购买的是带各类电子元件的套件。在树莓派基础实验中，主要利用的是 wiringPi 库，这个库和 C 语言自己的框架其实是没啥关系的，即便你把这个库全学完了，也不一定能精通 C 语言。相反，如果 C 语言什么都不会的话，肯定也整不明白这个库里面的函数是怎么用的。\n\n说的可能有点绝对，我的意思主要是：如果你之前没有学过编程，得先把某一个语言学完了，再来谈购买树莓派进行  进阶学习  的事\n\nPython 同理，肯定要把基础的语法什么都学会了，再考虑购买树莓派进行进一步的学习。\n商家玩的多半也是文字游戏，“零基础学习”代表你可以零基础上手树莓派，而不能利用树莓派从 0 开始学习编程，这是很难的。\n\n2. 如何初始化一个树莓派  首先准备好咱们需要的东西\n\n树莓派开发板\n5V3A 电源\nmicroSD 卡（16G 起步，建议 32GB）\n一台能上网的 windows 电脑\n\n然后，我们要下好下面的一些软件\n\nPutty (SSH 远程连接工具)\nAdvanced_IP_Scanner （局域网 ip 查找工具）\nbalenaEtcher（镜像烧录工具）\nFileZilla（文件传输工具）\nVNC-Viewer（远程桌面软件）\nnotepad++（编辑文本）\n\n树莓派的系统可以去官方下载👉官方下载站\n但是官方下载下来的系统  非常纯净，几乎所有东西都要我们自己安装，包括中文输入法，编译器，以及各类需要用到的软件\n\n为方便大家的使用，这里我整理了一些要用到的软件，以及一个已经搭建好基本环境的树莓派系统，大家直接下载我这里的集合包就行了！某度云\n\n如果你想从 0 开始配置一个树莓派系统，可以看这个专栏学习👉传送门\n\n\n2.1 烧录系统  首先将 SD 卡插入 windows 电脑，右键，格式化它\n\n很多博主这里都说要用特别的格式化软件，实际上大可不必，直接用 win 自带的格式化就行了\n\n然后打开balenaEtcher，选择树莓派系统镜像文件.img，然后再选择你的 sd 卡\n\n\n然后这个软件就会自动开始 flash 你的系统，你要做的就是等它自己搞定，这期间不要插拔 SD 卡\n\n\n搞定以后，你的 SD 卡会变成一个只有 256mb 的 boot 启动盘，不要担心，这是  树莓派的系统  已经将另外一部分磁盘给自己了\n\n右键我的电脑 - 管理 - 磁盘管理，即可看到  消失的那部分容量\n\nwin10 可能会提示你  使用前要先格式化磁盘 G，一定不要格式化！！！不然你的系统就寄了\n\n这时候我们就可以配置我们的树莓派了\n2.2 测试开机  将 sd 卡插入树莓派（注意方向），接通电源，如果树莓派的  红灯常亮，绿灯闪烁  的话，那就是系统正在运行了。这时候先断开电源，进行后面的操作\n\n2.3 设置树莓派显示输出的分辨率  不管你是直接让树莓派接显示器，还是用 VNC 来远程链接树莓派，我们都可以通过更改 config 文件来设置树莓派的分辨率\n\n滑倒最底部，找到hdmi_vct，它后面紧跟着的 3 个参数分别是分辨率的长宽，以及输出的刷新率\n\n为了减小树莓派的运算负担，我把分辨率设置的比标准 1080p（1920x1080）低了一点。实际上树莓派是支持 4k60 输出的。\n如果你使用 hdmi 直接接显示器，请根据你的  显示器参数  来设置树莓派的输出，以防接上后  无画面输出  的情况\n\n其实哪怕有显示器也建议你直接使用 VNC，每次都连线太麻烦了\nVNC 的使用后面会讲到\n\n\n2.4 网络链接  如果你有  网线，直接将树莓派用网线接入网络即可。这里介绍没有网线的方法，即 将树莓派接入 wifi。\n我分享的配置文件里面，有这两个 WiFi 配置文件\n\n使用 notepad++ 打开 wpa_supplicant.conf 文件，可以看到下面的这些东西。依照图中的注释填写 wifi 信息即可！wifi 名字和密码不要设置成中文的\n\n如果你有多个 wifi，可以在原有 network 之后继续添加 network，填写方法是一样的\ncountry=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;\tssid=&quot;zhulin&quot;\tpsk=&quot;12345678&quot;\tpriority=5&#125;network=&#123;\tssid=&quot;zadf&quot;\tpsk=&quot;12345678&quot;\tpriority=3&#125;\n\n搞定了之后，将这两个文件都放入  树莓派的 boot 盘\n注意：树莓派开机后这两个文件会消失，如果需要更改 wifi 配置，写好新的文件放入 boot 盘即可\n\n\n如果是你家里的 wifi，可以在 wifi 的管理后台（一般比较新的 wifi 都有自己的 app 可以管理，旧的 WiFi 也有网页端管理页面）找到  树莓派的 ip\n如果是笔记本 &#x2F; 手机开的热点，可以直接在热点管理里面看到已连接设备的 ip。如果是手机开热点的话，需要将电脑也接入同一热点。\n校园网不算局域网，建议开热点进行操作\n\n如果你不知道怎么找树莓派的 ip，直接使用之前提到的 ip 扫描软件 Advanced_IP_Scanner 就可以了！\n\n记下树莓派的 ip，后续所有操作都要通过它来实现\n注意：即便是连同一个 WiFi，树莓派的 ip 也不是一直不变的，如果在某次使用时出现无法链接的情况，请检查 ip 是否已经改变了\n\n2.5 Putty 链接树莓派  比起 windows 电脑的图形桌面，树莓派是一个 linux 小主机，使用 linux 的时候我们更应该学习linux 命令行的使用，而不过度依赖于树莓派系统本身\nputty 的使用也很简单，直接输入树莓派的 ip 即可，默认的端口都是 22，无需更改\n\n在弹出来的界面输入用户名 pi，输入密码的时候要  盲打，它不会显示你输入了啥\n\n当输入完密码后，会弹出下面的界面，这就代表你的树莓派已经链接上了\n\n输入 sudo raspi-config 可以进入树莓派的系统设置，我们需要将 VNC 的服务开启，这样才能使用 VNC 远程链接树莓派的桌面\n\n用方向键选择5 Interfacing Options，找到 VNC 服务，回车选择它，会提示你是否开启（enable）VNC 服务，我们选择是就可以了\n\n选择完毕后回到初始菜单，要选择下面的 finish 使得设置生效\n操作方法是来到 P8 后按方向键的左右，才能选择底部的Select 和Finish\n随后输入 sudo reboot 重启树莓派，使得设置生效。\n到这里，putty 的初始化设置就完成了\n\n2.6 VNC 链接树莓派  因为我的树莓派烧录的是提前搭建好基本环境的系统，所以这里面我们直接用 VNCviewer 来远程链接树莓派的桌面\n操作很简单，输入树莓派的 ip\n\n然后在弹出的界面上输入默认用户名 pi 和密码 raspberry 即可\n\n现在你看到的就是树莓派的桌面啦，是不是和一个普通的 windows 电脑差不了太多呢？\n\n右键桌面可以更改壁纸\n\n\n这里的操作和使用一台电脑没啥区别，就留给大家自己尝试啦！\n\n2.7 使用 filezilla 软件传输文件到树莓派  安装 filezilla 软件，它可以通过 wifi 在我们的 windows 电脑和树莓派之间传输文件\n\n链接树莓派后，这里出现了两个界面，其中左边是我们电脑里面的文件，右边是树莓派里面的文件，我们直接进行  拖动操作  即可\n传输完毕后，filezilla 会弹出系统通知\n\n注意：这里新建文件夹的操作叫“创建目录”\n\n\n恭喜你，你的树莓派已经初始化完毕啦！可以愉快的用它学习代码了！\n不过别急着关闭本篇博客，后面还有东西呢！\n\n3. 使用 Xshell 将树莓派作为 linux 主机  有这么一个软件，它集成了 putty 和 filezilla 的功能，界面更好看，使用也更方便\n没错，他就是Xshell！\n\n它同样可以使用 sudo raspi-config 进入树莓派的系统设置，同时借助该公司的 Xftp 软件，它也能实现一样的传输文件功能！\n\n\n今天刚下载 Xshell 软件，当我把它连上树莓派的时候，感觉自己从本世纪初穿越到了 2022 年。这界面，终于不再是那个古早的模样了，太感动了！\n\n3.1 下载 Xshell点进官网的下载界面，一看，我去，只有 30 天试用，玩球啊！\n要是这么想，你就  太年轻了\n让我们来康康右下角这里写着啥，“免费授权”！\n\n只要你填写你的  姓名和邮箱号，官方就会把这两个软件的下载链接发到你的邮箱。\n\n个人用户（非商用）的话，这两个软件都是免费的！\n\n唯一的缺点就是在你关闭页面的时候，它会弹出来这样一个页面，不过这也不影响啦！\n\n3.2 链接树莓派  安装的步骤直接无脑下一步\n打开 Xshell，这时候我们还没有设置过服务器，所以是空\n\n点击新建，进入设置服务器的界面，写入你的树莓派 IP，并给这个会话起个名\n\n点击链接，会弹出来让你输入你的树莓派用户名和密码，和之前一样操作就行\n\n\n然后，他就建立链接啦！\n\n3.3 编码设置  点击这里的属性\n\n选择终端，找到右下角的编码，确认它是 UTF-8 的状态，不然中文会乱码\n\n3.4 打开 Xftp点击上面这个绿色的文件夹就会打开 Xftp，快捷键是CTRL+ALT+F\n\n后续的操作也是直接拖动文件，没什么好说的~~\n\n4. 树莓派连接面包板  树莓派上有 40 个 IO 口，为了方便实验，一般会采用一个转接板把树莓派的 IO 信号转接出来，使用面包板进行 GPIO 外接。我们需要以下 3 个部件：\n\n40p 软排线\nT 型转接板\n面包板\n\n\n安装 40p 软排线的时候，要注意软排线上有一个小三角，它要对准树莓派 USB 接口的另一侧的接口，依照这个方向插入软排线。请平均用力，不要大力出奇迹！\n\n40p 排线的另一端就是链接 T 型转接板了，链接这个就很简单，T 型转接板上会有一个凹槽，对准凹槽方向插入即可\n\n然后将 T 型转接板对准面包板中央的孔位插入即可！G17 G18对准行号 1 的孔位\n\n5. 进阶操作  用上Xshell 和面包板，你的树莓派已经是一个完全体啦！\n其他的一些操作，可以看看我的  另外一个树莓派的专栏 👉 传送门\n\n如果本篇博客对你有帮助的话，还请点赞支持一下哦！\n\n有什么问题，欢迎在评论区提出！看到了就会回复的\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 01- 双色 LED","url":"/posts/3585041582/","content":"\n\n前言  今晚上没啥事（其实作业没写完），就开始折腾  树莓派  了\n我当初买的是  树莓派 4B(4GB)版本的  套件，东西还是非常全的，店家还送了全套学习资料 + 指导视频，加上一本还算不错的书。\n本篇博客，让我们一起来完成第一个实验：双色 LED\n\n学习资料来源于：湖南创乐博智能科技有限公司\n本博客仅供参考，请勿转载！\n\n\n1. 实验器材\n装好系统的树莓派开发板 + 电源适配器\n面包板 +T 型转接板\n40p 软排线\n双色 LED\n若干跳线\n\n\n2. 实验原理  将引脚 S（绿色）和中间管脚（红色）链接到面包板的接口上，对树莓派进行编程控制，使 LED 的颜色由红变绿。并利用 PWM 混合成其他颜色。\n\n对应接线表格\n\n\n\n树莓派\nT 型转接板\n双色 LED\n\n\n\nGPI01\nGPI018\nS\n\n\nGPI00\nGPI017\nR\n\n\nGND\nGND\nGND\n\n\n实际接线图如下（手机画质也太渣了）\n\n3. 控制代码  当树莓派需要与外部元件相接时，要用到一些写好的库。如  树莓派 wiringPi 库\n\n树莓派 wiringPi 库：wiringPi 是一个很棒的树莓派 IO 控制库，使用 C 语言开发，提供了丰富的接口：GPIO 控制，中断，多线程，等等\n\n还有 softPwm.h 库：GitHub 链接\n\n本次双色 LED 实验需要用到的就是这两个库，以及 C 语言自带的库函数stdio.h\n代码如下：\n#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt;#include &lt;stdio.h&gt;#define uchar unsigned char#define makerobo_Led_PinRed    0 // 红色 LED 管脚#define makerobo_Led_PinGreen  1 // 绿色 LED 管脚// LED 初始化void makerobo_led_Init(void)&#123;\tsoftPwmCreate(makerobo_Led_PinRed,  0, 100);\tsoftPwmCreate(makerobo_Led_PinGreen,0, 100);&#125;// 设置 LED 亮度 PWM 调节范围是 0x00-0xffvoid makerobo_led_ColorSet(uchar r_val, uchar g_val)&#123;\tsoftPwmWrite(makerobo_Led_PinRed,   r_val);\tsoftPwmWrite(makerobo_Led_PinGreen, g_val);&#125;int main()&#123;    // 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\tmakerobo_led_Init(); // LED 初始化\twhile(1)&#123;\t\tmakerobo_led_ColorSet(0xff,0x00);   // 红色\t\t\tdelay(500);                         // 延时 500ms\t\tmakerobo_led_ColorSet(0x00,0xff);   // 绿色\t\tdelay(500);\t\tmakerobo_led_ColorSet(0xff,0x45);\t\t\tdelay(500);\t\tmakerobo_led_ColorSet(0xff,0xff);\t\t\tdelay(500);\t\tmakerobo_led_ColorSet(0x7c,0xfc);\t\t\tdelay(500);\t&#125;\treturn 0;&#125;\n\n在 wiringPi 库中，可以看到两个函数的使用说明\n\nCreate 函数相当于初始化针脚\nWrite 函数会更改该管脚的 pwm 值，以达到控制 LED 亮度的目的\n\n\n3.1 显示器的 PWM 调光和 DC 调光  如果你有了解过显示器的选购知识，估计听说过显示器的 PWM 调光和 DC 调光。\n使用 DC 调光的显示器，屏幕背光将  常亮 ；使用 PWM 调光的显示器，屏幕背光将 高速开关  来点亮屏幕。只要 PWM 高于一定值，人眼就分辨不出该屏幕的闪烁 。当一块显示器使用 高频 PWM调光时，我们认为它与 DC 调光没有太大的区别。\n但总的来说，使用 DC 调光技术的显示器更加“护眼”，而使用  低频 PWM 调光  的显示器就是极度辣眼睛（这也是有些屏幕在摄像头中会  屏闪  的原因）\n目前主流手机都上了 OLED 屏幕，该屏幕材质普遍使用的是 PWM 调光。部分手机厂家在屏幕设置中推出了“类 DC 调光选项”，其原理就是用高频 PWM 来模拟 DC 调光。\n\n如果你想了解这方面的知识，可以看看这个视频👉链接\n\n好像 bb 了一些和这个实验没啥关系的内容，赶快回到正题！\n\n3.2 编译代码  树莓派中有两种方式编译运行我们的代码\n3.2.1 直接使用 Geany 编译器内部选项\n\n3.2.2 使用 linux 语言  树莓派的系统是基于 linux 的，我们可以使用 linux 中的 gcc 语言来编译这个 .c 文件\n\n在本专栏之前的博客中，有介绍过这种方式👉链接\n\n\n输入指令，你会发现系统报错显示 delay 函数未定义\nundefined reference to `delay`\n\n\n这是因为 delay 函数并不是一个 C 语言的库函数我，我们可以在前面自己整一个 delay 函数的原型\n\n第一次使用 Geany 编译的时候并没有报错，这是因为在 Geany 里面已经用  生成命令  引用了 wiringPi 库\n在 Geany 的 build(生成)--&gt;set build commands(设置生成命令）中输入以下指令gcc -Wall -c &quot;%f&quot; -lwiringPi\n\n// 延时 z 毫秒的 delay 函数void delay(unsigned int z)&#123;    unsigned int i,j;    for(i=z;i&gt;0;i--)        for(j=110;j&gt;0;j--)            ;// 利用无意义的 for 循环来进行延时&#125;\n\n我们在 linux 控制台中用 cd 打开文件路径后，输入如下指令\n1. gcc 01DuoColorLED.c -o GPIO -lwiringPi2. -lwiringPi 选项，链接 WiringPi 库。\n\n第一条指令是编译程序，生成可执行文件GPIO\n\n使用 ./GPIO 指令来执行此文件\n\n需要注意的是，用这种方法运行程序不太方便终止，你可以去掉 main 函数中的 while 循环，让变色只执行一次。\n\n所以在进行此类开发时，建议直接使用 Geany 编译器，因为它会生成一个前台控制面板，我们可以直接用ctrl+c 停止程序\n\n奇怪的是，当我运行第一个 Geany 编译器 生成的可执行文件时，LED 会正常变色。\n但是运行第二个在 linux 控制台 生成的 GPIO 文件时，却不能变色。不知道是什么原因\n\n而当我重新用 Geany 编译器编译这份加了 delay 函数定义的代码时，发现这个 delay 函数还是不太行啊！这灯都闪的飞快，真的有 500ms 吗\n\n不过这也不算什么大问题，咱们可以通过调整 delay 函数的定义，和调用参数来控制\n\n4. 如何在使用面包板的同时使用散热小风扇  原本不使用面包板的时候，小风扇可以插在板载针脚的2、3 位\n\n但是现在使用了面包板，这整个针脚都被占用了，风扇往哪里插呢？\n很简单，使用两根跳线，将风扇与面包板上的 5v 和 GND 链接 就行了！\n\n红线接 5V\n黑线接 GND\n\n\n\n结语  不管如何，这次实验算是完美完成啦！\n这也是我在树莓派上做的第一个实验\n\n如果你想和我一起学习树莓派，那就关注  本专栏  吧！\n欢迎 star 本专栏代码仓库：GITEE 链接\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 03- 七彩 LED","url":"/posts/2363440807/","content":"\n\n\n\n前言  学习太累，那就玩玩树莓派“陶冶情操”吧！\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1. 实验器材\n树莓派 4B 开发板\n40p 软排线 +T 型转接板 + 面包板\n七彩 LED 模块\n跳线若干\n\n\n2. 实验接线  七彩 LED 模块  内置了 IC 芯片，因此无需编写代码，只需通电就能看到 LED 闪烁。\n不同型号的七彩 LED 模块，内置的闪烁情况会有所区别，如闪烁快慢和亮度等\n\n七彩 LED 模块只需串联一个限流电阻即可构成控制电路，示意图如下\n\n所以我们接线的时候，只需接上 VCC 和 GND 即可\n\n\n\n树莓派\nT 型转接板\n七彩 LED 模块\n\n\n\nGND\nGND\nGND(中间管脚)\n\n\n5V\n5V\nVCC(一旁标有 S)\n\n\n\n前两次实验中，我对每次都需要接 5v 线却并没有连接设备感到疑惑\n本次实验正好印证了我在 02RGBled 实验 博客里做出的猜测！\n实物接线图如下👇\n\n3. 实验效果  将电路接通，可以看到 LED 闪烁了 7 种颜色，且有不同的闪烁方式！\n\n这不比自己写代码控制的更帅？（bushi）\n如果你想知道如何  用代码控制一个 LED 模块 ，可以看看我的前两篇 树莓派实验  的博客\n\n实验 02：RGB 小灯 \n实验 01：双色 LED\n\n结语  本次实验的内容不多撒，咱也见识了内置小芯片的快乐（指不需要自己写控制代码）\n下一次的实验是  继电器实验，这部分涉及到一些原理，看来要秃头了\n\n如果你觉得本篇博客挺有意思，那就点个赞，顺便收藏一下我的  树莓派专栏  吧！\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 02-RGB 小灯","url":"/posts/178546113/","content":"\n\n前言  又到了树莓派学习的时候！\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n上一次的  实验 001- 双色 LED中，虽然我把博客展示了出来，写的好像有模有样的，实际上我对一些函数可谓是丝毫不懂。\n但这次不一样了，我把一些函数的基本使用给整明白了！\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板\n跳线一堆\nRGB 小灯\n\n通过这次试验，我们可以基本了解一下  让电脑性能提升 200% 的 RGB的底层控制\n\n1.1 树莓派运行库准备  当树莓派需要与外部元件相接时，要用到一些写好的库。如  树莓派 wiringPi 库\n\n\n树莓派 wiringPi 库：下载 &#x2F; 安装教程\n\n下载 softPwm.h 库：GitHub 链接，安装教程见README\n\n\n\n\n2. 元件接线RGBled 模块的电路图如下，其与实物图是对应关系\n\n\n以下是本次实验的  接线图\n\n其实这里我没搞懂这个 5V 是用来干什么的，因为不接好像也没有关系\n\n让我无语的是，去问店家，客服回复是“原理需要自己学习”\n看来还是得靠自己\n\n大胆猜测一下，后续的实验需要更多接 5V 的设备，这个 5V 引线就好比我们每次编写 C 语言都需要用 stdio.h 一样，是一个习惯。\n同时解释一下面包板左右两条线的作用：\n\n当你把 GND 用引线接到  蓝色 -线上，此时那一排都是 GND\n当你把 5V 用引线接到  红色 +上，红色一排都是 5V 了\n\n这就相当于  串联线路\n\n\n3. 函数解释  这里需要用到两个函数： softPwmCreate和softPwmWrite\n上篇博客中我只给出了这两个函数的解释文档（偷懒），这篇博客让我们来真切认识一下这两个函数的作用\n\n以下是函数原型，以及官方解释的翻译\nint softPwmCreate (int pin, int initialValue, int pwmRange) ;\n\n这将创建一个软件控制的 PWM 引脚。您可以使用任何 GPIO 引脚，引脚编号将与您使用的 wiringPiSetup() 函数相同。\ninitialValue是初始值，如果 pwmRange 使用 100，那么给定引脚的值可以是 0（关闭）到 100（完全打开）之间的任何值。 返回值为 0 表示成功，-1 代表失败。\n如果还有其他情况，您应该检查全局 errno 变量，看看哪里出了问题。\nvoid softPwmWrite (int pin, int value) ;\n\n更新给定引脚 pin 上的 PWM 值。该值将被检查是否在范围 pwmRange 内\n未通过 softPwmCreate 初始化的管脚将被忽略\n后续还有一个 Note：\n\n\n\nPWM 输出的每个“周期”需要 10 毫秒，默认范围值为 100，因此尝试每秒更改 PWM 值超过 100 次将是徒劳的\n\n在 softPWM 模式下激活的每个引脚使用大约 0.5% 的 CPU\n\n目前无法在程序运行时禁用引脚上的softPWM\n\n您需要保持程序运行以保持 PWM 输出！\n\n\n\n3.1 关于 softPwmWrite 的使用问题，大大的疑惑  这里我产生了一个巨大的疑惑，就是 softPwmWrite 函数的第二个参数究竟应该如何使用\n\n这个问题我在 CSDN 的问答区提问了，22.04.01 的 17:00 目前还没有回复👉点我\n\n可以看到下面这位大佬的程序中，是将第二个参数设置到超过了 100\n\n引用自博客https://www.cnblogs.com/demo-lv/p/14017488.html\n\n\n而参考资料中，提供的代码也是将 pwm 值设置超过了 100\n\n在查询过一些资料（是真的没有博客提到过这个问题），我找到了 RGB 颜色对照表\n这个代码中提供的参数设置，其实是  参照 RGB 表  来设置的\n\n\n也就是说，如果想达到混色的效果，你需要利用 softPwmWrite 函数将  红绿蓝  针脚与 RGB 表中的数值对应进行输出。\n但这不就和  官方的 pwm 值应该在范围内，且超过 100 的 pwm 值都是无效的，冲突了吗？\n\n这个问题先暂时放在这里，蹲一个大佬解释\n\n4. 代码样例4.1 初始化针脚#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt;#include &lt;stdio.h&gt;#define makerobo_Led_PinRed    0 // 红色 LED 管脚#define makerobo_Led_PinGreen  1 // 绿色 LED 管脚#define makerobo_Led_PinBlue   2 // 蓝色 LED 管脚// LED 初始化void makerobo_led_Init()&#123;// 第三个参数是 range，将 pwm 设置成 100（全开）\tsoftPwmCreate(makerobo_Led_PinRed,  0, 100);\tsoftPwmCreate(makerobo_Led_PinGreen,0, 100);\tsoftPwmCreate(makerobo_Led_PinBlue, 0, 100);&#125;\n\n你可能会想，为什么这里要把红绿蓝的管脚设置成 0、1、2，实际上这里和面包板的接线是对应的\n\n可以看到，GPIO 0/1/2分别对应的是 17/18/27，同我们第 2 点中 接线图  上的针脚位置对应\n\n4.2 颜色参数设置  初始化针脚之后，我们就来设置各个针脚的参数\n// LED 颜色设置void makerobo_led_Color_Set(uchar r_val, uchar g_val, uchar b_val)&#123;// 对应不同颜色针脚的设置，如果需要红色，就只给红色 r_val 传对应值 // 给不同颜色输入不同值，达成混色的效果！\tsoftPwmWrite(makerobo_Led_PinRed,   r_val);\tsoftPwmWrite(makerobo_Led_PinGreen, g_val);\tsoftPwmWrite(makerobo_Led_PinBlue,  b_val);&#125;// 函数使用如下makerobo_led_Color_Set(0xff,0x00,0x00);   // 红色\tdelay(500);   // 延时 500ms，使更改便于观察makerobo_led_Color_Set(0x00,0xff,0x00);   // 绿色delay(500);                makerobo_led_Color_Set(0x00,0x00,0xff);   // 蓝色delay(500);\n\n4.3 完整代码及效果演示  下面给出完整代码，以及最终的效果、\n#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt;#include &lt;stdio.h&gt;#define uchar unsigned char#define makerobo_Led_PinRed    0 // 红色 LED 管脚#define makerobo_Led_PinGreen  1 // 绿色 LED 管脚#define makerobo_Led_PinBlue   2 // 蓝色 LED 管脚// LED 初始化void makerobo_led_Init()&#123;// 第三个参数是 range，将 pwm 设置成 100（全开）\tsoftPwmCreate(makerobo_Led_PinRed,  0, 100);\tsoftPwmCreate(makerobo_Led_PinGreen,0, 100);\tsoftPwmCreate(makerobo_Led_PinBlue, 0, 100);&#125;// LED 颜色设置void makerobo_led_Color_Set(uchar r_val, uchar g_val, uchar b_val)&#123;// 对应不同颜色针脚的设置，如果需要红色，就只给红色 r_val 传对应值 // 给不同颜色输入不同值，达成混色的效果！\tsoftPwmWrite(makerobo_Led_PinRed,   r_val);\tsoftPwmWrite(makerobo_Led_PinGreen, g_val);\tsoftPwmWrite(makerobo_Led_PinBlue,  b_val);&#125;int main()&#123;    // 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123;\t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\tmakerobo_led_Init();\t\tint n=0;\tprintf(&quot; 请输入循环周期的次数 &gt;&quot;);\tscanf(&quot;%d&quot;,&amp;n);// 输入循环周期的次数\twhile(n--)\t&#123;\t\tmakerobo_led_Color_Set(0xff,0x00,0x00);   // 红色\t\t\tdelay(500);   // 延时 500ms，使更改便于观察\t\tmakerobo_led_Color_Set(0x00,0xff,0x00);   // 绿色\t\tdelay(500);                   \t\tmakerobo_led_Color_Set(0x00,0x00,0xff);   // 蓝色\t\tdelay(500);\t\tmakerobo_led_Color_Set(0xff,0xff,0x00);   // 黄色\t\tdelay(500);                 \t\tmakerobo_led_Color_Set(0xff,0x00,0xff);   // 粉色\t\tdelay(500);     \t\tmakerobo_led_Color_Set(0xff,0xff,0xff);   // 白色\t\tdelay(500);       \t\tmakerobo_led_Color_Set(0x94,0x00,0xd3);   // 紫色\t\tdelay(500);\t\tmakerobo_led_Color_Set(0x76,0xee,0x00);   // 偏黄色\t\tdelay(500);\t\tmakerobo_led_Color_Set(0x00,0xc5,0xcd);\t  // 淡蓝色\t\tdelay(500);\t&#125;\t\t// 最后循环结束时，关闭 LED（如果不这么设置，LED 灯会停留在最后一个颜色）\tmakerobo_led_Color_Set(0x00,0x00,0x00);\t// 参数都为 0, 相当于关灯\tdelay(500);// 如果不延时，效果无法展示出来\t\treturn 0;&#125;\n\n使用树莓派 Geany 编译器，三板斧点起来\n\n最后的结果如下图~~RGB 小灯变色循环成功！\n\n\n4.4 Linux-GCC 编译器指令Geany 已经可以很好地执行我们的程序了，但它未免有点太 easy 了，点几下按钮就能搞定\n我们来试试需要  敲语句的 GCC 编译器\n首先依旧是用 cd 打开源文件的目录\ncd 打开源文件存放的目录ls 列出当前文件路径下的所有文件\n\n使用 wiringPi 库和 softPWM 库需要加上两个指令\n\nwiringPi 库对应：-lwiringPi\nsoftPWM 库对应：-lpthread\n\n在 linux 的 gcc 中使用 delay 函数 需要调用另外一个头文件&lt;unistd.h&gt;\ngcc -Wall 02rgbled.c -o TEST -lwiringPi -lpthread\n\n如果没有报错的话，那就是编译成功了，再次 ls 可以看到多出来了一个 TEST 可执行文件\n\n./TEST 执行 TEST 文件\n\n可以看到程序正常运行了！\n\n\n结语  第二个树莓派实验也做完啦！\n虽然还有问题没有解决，但我还是  很开心的\n\n如果对你有帮助，还请点个大大的👍！有什么问题可以评论区提出来哦\n\n通往大佬的路非常漫长……\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 04- 继电器","url":"/posts/3764013947/","content":"\n\n\n\n前言  学习树莓派的时候经常要查找前辈们留下的资料\n\n但我发现，有一些博客，写的真的不敢恭维。\n无注释源码  一贴，电路图  一贴，什么解释都没有，就发出来了。\n这是写给谁看的？恐怕自己过几个月回头看自己都不知道那是什么意思。这样的学习有啥意义呢？\n\n有的人可能觉得我是想抄作业，的确！嵌入式学习需要了解各个元件的工作原理，我的资料单有电路图远远不够啊……即便有源码，也需要自己去  弄明白每个函数  的作用，不然这样的学习依旧没有意义😥\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\n继电器模块 + 十字  螺丝刀\n双色 LED 模块（实验 1使用过）\n跳线一堆\n\n2. 实验原理 2.1 继电器模块 继电器模块是一种电控制期间，当输入量的变化达到规定要求时，在电气输出电路中使被控制量发生预定阶跃变化的一种电器。它具有  控制系统和被控制系统  之间的互动关系，通常运用于自动化的控制电路中。它实际上是用小电流去控制大电流运作的一种“自动开关”，在电路中起到自动调节、安全保护、转换电路等作用。\n\n说人话就是，继电器是一个电动开关，通过接收外部源的电信号来  打开和关闭电路。\n例如：按下电视机遥控器的开启按钮，它向电视节内部的“继电器”发出电信号，从而打开电视机的主电源开关。不过电视机内部还有另外的信号接收器，继电器本身不一定能接收红外信号（个人理解）\n\n2.2 继电器工作\n当继电器供电时，电流开始经过控制线圈\n电磁体开始通电，将上部衔铁吸附到线圈上，带动触点向右移动，从而与常开触点链接\n带负载的电路通电\n继电器断开供电，弹簧会将触头复位，电路断开\n\n\n\n3. 电路图和接线图 3.1 电路图 继电器模块的电路图如下\n\n模块实物图如下\n\n\n引用另外一篇博客对各个接口的介绍👉原文链接\n\n\n3.2 接线图  继电器的主控制型号源接在 GPIO17，和端口 0 对应（后面代码会用到）\n\n\n\n\n树莓派\nT 型转接板\n继电器模块\n\n\n\nGPIO 0\nGPIO 17\nIN\n\n\n5V\n5V\nDC+\n\n\nGND\nGND\nDC-\n\n\n5V\n5V\nCOM\n\n\n\n\n\n双色 LED\nT 型转接板\n继电器\n\n\n\n中间（R）\n*\nNC\n\n\nGND\nGND\n*\n\n\nS(G)\n*\nNO\n\n\n由于双色 LED 模块的 G 接口 (Green) 接到了继电器的常闭端口NC（即继电器未接通时默认接上的端口）\n所以在接线完毕后，LED 模块会亮绿灯\n\n这里需要注意的是，在对继电器接线的时候，需要用  螺丝  锁住各条线位，不然它们是接不稳的\n\n\n4. 代码示例  这里给出 C 语言的代码\n#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_RelayPin 0 // 设置继电器 GPIO 管脚，0 对应 G17int main()&#123;    // 初始化连接失败时，将消息打印到屏幕\t\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\t\t// 将继电器管脚设置为输出模式\tpinMode(makerobo_RelayPin, OUTPUT);\t\tint k=2;\twhile(k--)\t&#123;\t\t\tdigitalWrite(makerobo_RelayPin, HIGH); // 打开继电器\t\t\tdelay(1000);                           // 延时 1s\t\t\t\t\tdigitalWrite(makerobo_RelayPin, LOW);  // 关闭继电器\t\t\t\t\t\tdelay(1000);                           // 延时 1s\t&#125;\treturn 0;&#125;\n\n4.1 部分函数解释 4.1.1pinMode 该函数的作用是设置针脚当前的模式\n\n4.1.2digitalWrite可以看到，这里提到了在使用该函数之前，需要用 pinMode 函数将针脚设置为 OUTPUT 模式\n\n0 代表 low 值\n非 0 都代表 high\n\n\n4.2Geany 编译器运行代码  老样子，三板斧\n\n\n在 Geany 里面用  生成命令  引用 wiringPi 库（后续的博客不再说明）\n在 Geany 的 build(生成)--&gt;set build commands(设置生成命令）中输入以下指令gcc -Wall -c &quot;%f&quot; -lwiringPi\n\n最终运行的效果如下，当 digitalWrite 写入 high 时，继电器接通，红灯电路亮起\n写入 low 时继电器关闭，恢复原本绿灯常亮状态\n\n使用 ctrl+c 关闭程序运行面板，停止程序运行\n\n4.3Linux-gcc 编译器  在 linux 控制台里面，用 cd 打开你的文件夹后，输入如下编译指令\ngcc -Wall 04relay.c -o TEST -lwiringPi\n\n如果编译没有报错，那就是成功编译了，ls 会发现多出了 TEST 可执行文件，使用 ./TEST 执行它\n执行结束后，会显示下一行的待定输入\n\n为了避免 linux-gcc 中程序  运行后无法终止 ，请不要使用while(1) 死循环！\n使用结束后请先断开 5V 跳线 后，再断开其他跳线\n\n结语  本实验只是简单演示了继电器的使用，再后续更复杂的实验中，我们可以使用它控制更复杂的模块\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 07- 倾斜开关","url":"/posts/2803202558/","content":"\n\n前言  昨天补全了  树莓派初始化  的博客，本专栏的模块就算是全啦！\n欢迎大家把本专栏推荐给其他有兴趣学习树莓派的朋友！\n\n从本博客开始，将不再讲述 Geany 编译器的简单操作，所有操作都用linux 命令行 解决\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\n倾斜传感器模块\n双色 LED 模块\n跳线一堆\n\n\n上：倾斜传感器；下：双色 LED\n\n2. 实验原理  在倾斜开关中，有一个金属球，它用于检测小角度的倾斜。倾斜开关模块的结构为双向传到的球形倾斜该关。只要倾斜度的力满足条件，开关就会通电，从而输出  低电平  信号。\n\n2.1 实验接线\n\n\n树莓派\nT 型转接板\n倾斜开关\n\n\n\nGPIO 0\nGPIO 17\nDo\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT 型转接板\n双色 LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n\n2.2 实物接线图\n接上排线后，倾斜开关模块的 PWR-LED 指示灯亮起\n\n当检测到倾斜角度改变时，DO-LED也会亮起，这时 Do 管脚将输出低电平，对应值为 0。后续程序的编写将用到这个原理\n\n\n3. 代码示例  下面给出 C 语言的示例代码\n// 倾斜传感器实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_TiltPin\t0 // 倾斜传感器管脚定义#define makerobo_Rpin\t\t1 // 红色 LED 模块管脚定义#define makerobo_Gpin\t\t2 // 绿色 LED 模块管脚定义// 双色 LED 控制函数void double_colorLED(char* color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); // 设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); // 设置为输出模式\tif (color == &quot;makeroboRED&quot;)     // 点亮红色 LED 灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (color == &quot;makeroboGREEN&quot;) // 点亮绿色 LED 灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;Double color LED Error&quot;);&#125;int main(void)&#123;\t// 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123;\t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    // 倾斜传感器 Pin 设置为输入模式\tpinMode(makerobo_TiltPin, INPUT);\tdouble_colorLED(&quot;makeroboGREEN&quot;);\t\twhile(1)&#123;\t\t// 如果没有检测到倾斜，输出高电平 1\t\t// 检测到了之后，输出高电平 0\t\tif(0 == digitalRead(makerobo_TiltPin))\t\t&#123;     // 倾斜传感器发生倾斜\t\t\tdelay(10); // 倾斜传感器去除抖动处理\t\t\tif(0 == digitalRead(makerobo_TiltPin))&#123;\t\t\t\tdouble_colorLED(&quot;makeroboRED&quot;); // 点亮红色 LED 灯\t\t\t\tprintf(&quot;Tilt!\\n&quot;);   // 打印出出现倾斜\t\t\t&#125;\t\t&#125;\t\telse if(1 == digitalRead(makerobo_TiltPin))\t\t&#123; // 倾斜传感器没有发生倾斜\t\t\tdelay(10);\t\t\tif(1 == digitalRead(makerobo_TiltPin))&#123;\t\t\t\twhile(!digitalRead(makerobo_TiltPin));\t\t\t\tdouble_colorLED(&quot;makeroboGREEN&quot;);  // 点亮绿色 LED 灯\t\t\t\tprintf(&quot;No Tilt!\\n&quot;);  // 打印没有出现倾斜\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.1 部分代码解释  去抖动操作  因为  倾斜开关和轻触开关  都是物理结构，需要有一定的延时来进行去抖动操作\n\n直接用 == 比较字符串(color == &quot;makeroboGREEN&quot;) \n\n这里用到了 == 直接比较字符串，之前我以为这样写是错误的，因为 Linux-gcc 报错了（但是可以编译出可执行文件，也能正常运行）\n\n实际上这个在 VS 下是可以正常运行的，不会报错\n\n个人理解，这样直接传入字符串的操作，实际上是在函数中创建了一个形参 color，接收了传过来的常量字符串，随后的== 比较的其实是内存中的字符串的地址，而不是直接比较字符串本身\n\n这个代码里面包含的 wiringPi 函数，在之前的博客中已经讲解过了，详情可以看实验 06👉传送门\n如果有不懂的，可以在评论区提出！\n\n\n3.2 Linux 编译运行代码  输入以下语句编译这个代码，生成可执行文件 TEST\ngcc -Wall 07tiltswitch.c -o TEST -lwiringPi\n\n./TEST运行这个文件，按 CTRL+C 终止程序\n\n3.3 运行效果  抬起倾斜开关，LED 亮绿灯。放下它后，变成默认的红灯\n\n结语  本次实验到这里就结束啦！感觉这个倾斜开关就是手机中  陀螺仪的青春版。\n目前我设想的是，以后的小车实验中可以通过它来判断小车现在是在上坡还是在平地，如果在上坡，就加大马达的输出。嗯，应该是这样！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 08- 震动开关","url":"/posts/2318722711/","content":"\n\n前言  今天折腾 vim 编辑器折腾了老久，我只是想实现在 vim 编辑器中可以复制代码到 windows 电脑下，方便我写博客，但是咋弄都搞不定，放弃了，还是用树莓派的系统来复制吧\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\n振动传感器模块\n双色 LED 模块\n跳线一堆\n\n\n上：双色 LED 模块；下：震动传感器模块\n振动传感器模块和倾斜传感器模块很像，都是通过物理结构来判断当前的状态。而且它也有 PWR-LED 和DO-LED两个指示灯\n\n2. 实验原理  振动开关传感器用的是常闭型  振动传感器 ，可用于跟踪振动触发作用，如防盗报警，地震报警和智能小车。与 常开型  振动传感器相比，常闭型振动传感器触发时间长，可以用于驱动继电器模块\n\n该模块采用常开高灵敏度震动开关。开关在静止時为开路 OFF 状态，当受到外力碰触而达到相应震动力时，或移动速度达到适当离 (偏) 心力时，导电接脚会产生瞬间导通呈瞬间 ON 状态；当外力消失時，开关恢复为开路 OFF 状态。可用于各种震动触发作用，报盗报警，智能小车，电子积木等。传感器特设 M3 固定安装孔，调节方向与固定方便易用，使用宽电压 LM393 比较器，信号干净，波形好，驱动能力强，超过 15mA，配可调精密电位器调节灵敏度。在此实验中，将双色 LED 模块连接到 Raspberry Pi 作为指示作用。敲击或敲击振动传感器时，它将打开双色 LED 将闪烁红色。再次点击它，LED 将变为绿色 - 每次敲击或敲击两种颜色之间交替闪烁。\n2.1 电路图\n2.2 接线图\n\n\n树莓派\nT 型转接板\n振动开关\n\n\n\nGPIO 0\nGPIO 17\nDo\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT 型转接板\n双色 LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n因为接口和倾斜开关一模一样，所以接线方式也是一样的\n\n实物接线图这里就不放了，和倾斜开关不同的是，振动开关在接上后，两个指示灯都会亮起，振动该传感器，DO-LED会闪动\n\n\n3. 代码示例  老样子，给出 C 语言的代码示例\n\n这里的 wiringPi 库函数在上两次的实验中都有使用过，详情请查看  实验 6里的解释\n\n#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_VibratePin\t0   // 震动传感器#define makerobo_Rpin\t\t1   // 红色 LED PIN #define makerobo_Gpin\t\t2   // 绿色 LED PINint clb_tmp = 0;// 全局变量用于比较// 双色 LED 控制函数void double_colorLED(int color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); // 设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); // 设置为输出模式\tif (0 == color)             // 点亮红色 LED 灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (1 == color)       // 点亮绿色 LED 灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;Makerobo Double color LED Error\\n&quot;); // 双色 LED 错误&#125;// 打印信息, 打印出振动传感器的状态\tvoid makerobo_Print(int x)&#123;\tif (x != clb_tmp)\t&#123;\t\tif (x == 0)\t\t\tprintf(&quot;...Makerobo ON\\n&quot;);\t\tif (x == 1)\t\t\tprintf(&quot;Makerobo OFF..\\n&quot;);\t\tclb_tmp = x;// 复位 x\t&#125;&#125;int main()&#123;\tint clb_status = 0;  // 状态值\tint clb_tmp = 0;     // 比较值\tint clb_value = 1;   // 当前值\t//wiringPi 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    // 振动传感器 Pin 设置为输入模式\tpinMode(makerobo_VibratePin, INPUT);\t\twhile(1)&#123;\t\tclb_value = digitalRead(makerobo_VibratePin); // 获取振动传感的值\t\tif (clb_tmp != clb_value)\t\t&#123;\t// 振动传感器的输出值发生改变\t\t\tclb_status ++;   // 振动传感器状态加 1\t\t\tif (clb_status &gt; 1)\t\t\t&#123;\t\t\t\t\t\t\t\tclb_status = 0; // 状态发生改变判断，如果变成 2 了复位成 0\t\t\t&#125;\t\t\tdouble_colorLED(clb_status);  // 控制双色 LED 模块\t\t\tmakerobo_Print(clb_status);   // 打印出状态\t\t\tdelay(1000);                  // 延时 1s\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.1 代码思路讲解 clb_value 接收振动传感器的返回值，每次振动，返回值都会改变\n\nvalue 初始值为 1，振动时，接收了返回值为 0，和 tmp 不同，所以 status++，双色 LED 的颜色改变\n如果没有检测到振动，返回值为 1，和 tmp 相同，status 不改变，双色 LED 的颜色不变\n\n参数 clb_tmp 问题 void makerobo_Print(int x) 函数中调用的其实是全局变量下的clb_tmp\n而 main 函数中调用的是 int clb_tmp = 0;// 比较值 这个单独定义的局部变量，和全局中的 tmp 没有关系，所以 makerobo_Print 函数中对 clb_tmp 函数的操作不影响 main 中和状态码的比较\n为了不搞混全局变量和局部变量，建议将 main 函数中的 tmp 更名为clb_tmp1\n\n3.2linux 运行代码gcc -Wall 08vibrationswitch.c -o TEST -lwiringPi\n\n\n每次晃动传感器，双色 LED 就会变色，屏幕上打印出 on 和 off（每晃动一次，打印一次）\n按 CTRL+C 终止程序运行\n\n和倾斜开关的实时改变不同，振动开关的改变不是实时的，而是需要新的振动来触发它（类似一个按钮）\n\n假设我们要用它来做一个报警装置，假设在某一段时间内检测到振动状态多次改变，就可以发出信号报警，代表你的门（或者某个东西）被移动了\n\n\n结语  这次实验的代码比上一次的倾斜开关相比，更复杂了一些。希望我的讲解对你有帮助！\n\n感谢你看到最后！如果对你有帮助，还请点个👍，万分感谢！\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 06- 轻触开关实验","url":"/posts/854191546/","content":"\n\n前言  书上的代码示例可太牛了，不仅没用字符串比较函数strcmp，还是指针直接和字符串对比😥\n\n学习还得帮书本纠错，问店家客服也是一问三不知。\n不多说了，一起开始本次的实验吧！👍\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1. 实验器材\n树莓派\n40P 软盘线 +T 型转接板 + 面包板\n轻触开关按键模块\n双色 LED 模块\n一堆跳线\n\n\n上：双色 LED 模块；下：轻触开关模块\n\n2. 实验原理 2.1 电路图 使用轻触开关作为树莓派的输入设备，按下开关时，树莓派 GPIO 端口检测到低电平(0v)，表示按键被按下。松开按键时，树莓派检测到高电平(3.3v)\n在本次实验中，将通过  打印信息  提示按键是否被按下。\n轻触开关模块电路图如下：\n\n2.2 接线\n\n\n树莓派\nT 型转接板\n轻触开关\n\n\n\nGPIO 0\nGPIO 17\nSIG(S)\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND(-)\n\n\n\n\n\n树莓派\nT 型转接板\n双色 LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n在  实验 2的博客中，已经提到过树莓派针脚编号和 T 型转接板上编号的对应关系\n在树莓派系统控制栏中，我们可以输入以下指令查看树莓派的 GPIO 接口\ngpio readall\n\n可以看到，17 对应 0，18 对应 1，27 对应 2。和我们的接线方式和初始化针脚的编号是对应的\n\n本次实验的接线图如下，注意各个端口的接线关系\n\n右上角红黑线是树莓派的散热风扇，和实验无关\n\n\n\n3. 程序示例  以下给出 C 语言的示例代码\n// 轻触开关按键实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define makerobo_BtnPin\t\t0   // 轻触按键 PIN 口#define makerobo_Rpin\t\t1   // 红色 LED 灯模块 PIN#define makerobo_Gpin\t\t2   // 绿色 LED 灯模块 PIN// 双色 LED 控制函数void double_colorLED(char* color)&#123;\tpinMode(makerobo_Rpin, OUTPUT);  // 设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT);  // 设置为输出模式    \tif (!strcmp(color,&quot;RED&quot;))     // 点亮红色 LED 灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH); \t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (!strcmp(color,&quot;GREEN&quot;)) // 点亮绿色 LED 灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;makerobo Double color LED Error\\n&quot;);&#125;int main()&#123;\t// 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed!\\n&quot;);\t\treturn 1; \t&#125;    // 轻触按键 Pin 设置为输入模式\tpinMode(makerobo_BtnPin, INPUT);\tdouble_colorLED(&quot;GREEN&quot;);\t\twhile(1)\t&#123;\t\t// 轻触按键去除抖动处理\t\tif(0 == digitalRead(makerobo_BtnPin))\t\t&#123;   // 按键有按下\t\t\tdelay(10);   // 延时去抖动\t\t\tif(0 == digitalRead(makerobo_BtnPin))\t\t\t&#123;\t\t\t\tdouble_colorLED(&quot;RED&quot;);\t   // 点亮红色 LED 灯\t\t\t\tprintf(&quot;Button is pressed\\n&quot;); // 打印出有按键按下\t\t\t&#125;\t\t&#125;\t\telse if(1 == digitalRead(makerobo_BtnPin))\t\t&#123; // 没有按键按下亮绿灯\t\t\tdelay(10);\t\t\tif(1 == digitalRead(makerobo_BtnPin))\t\t\t&#123;\t\t\t\tdouble_colorLED(&quot;GREEN&quot;);   // 点亮绿色 LED 灯\t\t\t\tprintf(&quot;No Button is pressed\\n&quot;); // 没有按键按下\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.1 部分函数解析  一些函数在之前的博客中已具体介绍过，这里简单列出它们的功能\n\n\n\n函数\n作用\n\n\n\nvoid pinMode(int pin, int mode)\n设置针脚模式（输入、输出、脉冲输出、GPIO 时钟）\n\n\nvoid digitalWrite(int pin, int value);\n向指定管脚写入高 &#x2F; 低电平信号，使用前需要设置管脚为输出模式\n\n\n这里有个新的函数，作用是读取管脚的值\n在本实验中用于接收  轻触开关的按钮信号\n\n3.2 Geany 编译器运行  运行程序，代码会循环打印“没有按键按下”，LED 亮  绿灯\n\n按下按键后，打印显示“按键已按下”，LED 亮  红灯\n\n实验效果如下\n\n3.3Linux-Gcc 编译器  在命令行中输入以下编译指令，生成可执行文件\ngcc -Wall 06Button.c -o TEST -lwiringPi\n\n运行可执行文件后，可以观测到相同结果\n\n3.4 程序优化  我个人觉得这个程序用 while(1) 死循环并不是那么的优，程序需要手动 CTRL+C 终止，且终止后无法关闭 LED 灯。\n下面对程序做出一些优化\n\n依旧可以试试判断按键按下情况\n在程序运行后，关闭小灯\n\n只需更改循环体和延时函数即可，在循环结束后，使用 digitalWrite 输入低电平关闭小灯的红 &#x2F; 绿管脚，即完全关闭双色 LED\nint k=40;while(k--)&#123;\t// 轻触按键去除抖动处理\tif(0 == digitalRead(makerobo_BtnPin))\t&#123;   // 按键有按下\t\tdelay(500);   // 延时去抖动\t\tif(0 == digitalRead(makerobo_BtnPin))\t\t&#123;\t\t\tdouble_colorLED(&quot;RED&quot;);\t   // 点亮红色 LED 灯\t\t\tprintf(&quot;Button is pressed\\n&quot;); // 打印出有按键按下\t\t&#125;\t&#125;\telse if(1 == digitalRead(makerobo_BtnPin))\t&#123; // 没有按键按下亮绿灯\t\tdelay(500);\t\tif(1 == digitalRead(makerobo_BtnPin))\t\t&#123;\t\t\tdouble_colorLED(&quot;GREEN&quot;);   // 点亮绿色 LED 灯\t\t\tprintf(&quot;No Button is pressed\\n&quot;); // 没有按键按下\t\t&#125;\t&#125;&#125;// 关闭 LEDdigitalWrite(makerobo_Rpin, LOW);digitalWrite(makerobo_Gpin, LOW);delay(500);// 延时查看关闭情况return 0;\n\n\n结语  本次实验学习了轻触开关的使用方法，在未来的实验中，可以使用它来控制一些更复杂电路的开合\n\n你学费了吗？\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 11-U 型光点传感器","url":"/posts/816458215/","content":"\n\n前言  本篇实验和上篇博客的实验相似，我们要学习用 U 型光电传感器 来控制双色 LED\n\n这都是基础实验中不可或缺的内容，因为后续我们需要学会交叉使用不同的传感器来控制更复杂的电路。那些才是学习  树莓派基础实验  真正的意义\n不管怎样，还是继续努力吧！\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1. 实验器材\n树莓派\n40p 软排线 +T 型转接板 + 面包板\nU 型光电传感器模块\n双色 LED 模块\n跳线一堆\n\n\n上：U 型光电传感器；下：双色 LED\n\n2. 实验原理 U 型光电传感器是一种红外感应光点产品。其有 红外发射管和接收管，分别位于 U 型槽的两侧，以此形成一光轴。当检测到物体经过 U 型槽并阻断光轴时，就能产生对应的电信号。\n2.1 电路图  以下是 U 型光电传感器模块的电路图\n\n无障碍物阻挡时，D1\\D2-LED都亮起，OUT 管脚检测到低电平 0\n有障碍物阻挡时，D1-LED熄灭，OUT 管脚检测到高电平 1\n\n\n2.2 接线图\n\n\n树莓派\nT 型转接板\nU 型光电传感器\n\n\n\nGPIO 0\nGPIO 17\nOUT\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT 型转接板\n双色 LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n\n\n不过我手上的这个传感器并没有两个指示灯。只有一个，该指示灯在传感器被阻隔的时候会  变暗\n\n\n3. 代码示例//U 型光电传感器实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_LBPin\t\t0  // U 型光电传感器管脚定义#define makerobo_Rpin\t\t1  // 红色 LED 模块管脚定义#define makerobo_Gpin\t\t2  // 绿色 LED 模块管脚定义// 双色 LED 控制函数void double_colorLED(int color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); // 红色 LED 管脚设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); // 绿色 LED 管脚设置为输出模式\t\tif (color == 0)&#123;                // 点亮红色 LED 灯\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (color == 1)&#123;          // 点亮绿色 LED 灯\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;&#125;// 有物体挡住时，打印出提示信息void makerobo_Print(int x)&#123;\tif (x == 0 )&#123;\t\tprintf(&quot;makerobo Light was blocked!\\n&quot;);\t&#125;\telse&#123;\t\tprintf(&quot;clear!\\n&quot;);// 没有挡住\t&#125;&#125;// 主函数int main()&#123;       // 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    //U 型光电传感器 Pin 设置为输入模式\tpinMode(makerobo_LBPin, INPUT);\tint clb_temp=0;\twhile(1)&#123;\t\t//U 型光电传感器有无物体挡住信息检测\t\tif (digitalRead(makerobo_LBPin) == 0 )&#123;  \t\t\tclb_temp = 1;// 低电平，代表没有阻挡\t\t&#125;\t\tif (digitalRead(makerobo_LBPin) == 1 )&#123;\t\t\tclb_temp = 0;// 高电平，代表被阻挡\t\t&#125;\t\tdouble_colorLED(clb_temp); // 控制双色 LED 灯显示\t\tmakerobo_Print(clb_temp);  // 信息打印\t&#125;\treturn 0;&#125;\n\n3.1LinuxGCC 编译代码  在控制台输入以下指令，编译出可执行文件TEST\ngcc -Wall 11photoeletricsensor.c -o TEST -lwiringPi\n\n执行该文件，当传感器被阻挡时，双色 LED 变红，屏幕打印makerobo Light was blocked!\n不被阻挡时，双色 LED 亮绿灯，屏幕打印clear\n\n3.2 效果\n\n结语  本次实验到这里就结束啦！如果有什么问题，欢迎在评论区提出哦！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 09- 蜂鸣器模块","url":"/posts/2377108764/","content":"\n\n前言  最近学习激情不是很高，虽然代码学了很多，但是高数和大物直接摆烂了，呜呜呜呜\n\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\n有源蜂鸣器\n无源蜂鸣器\n一堆跳线\n\n\n下：有源蜂鸣器；上：无源蜂鸣器\n它们的外观几乎一样。如果是没有装配好的单独模块，无源蜂鸣器底部的电路引脚带有绿色 pcb，而有源蜂鸣器底部是黑色塑料外壳。因为模块已经焊接到了电路板上，所以我们看不到它们的底部引脚。\n\n2. 实验原理  蜂鸣器属于声音模块。有源蜂鸣器常用于发出单一的提示性报警声音，没有频率变  化，内置振荡器；无源蜂鸣器的驱动方式为频率脉冲驱动，可以发出各种有频率的信号声  音。\n\n有源蜂鸣器内部有一个简单的振荡电路，能将恒定的直流电转化成一定频率的脉冲信号，程序控制方便但频率固定，单片机一个高低电平就可以让其发出声音。\n无源蜂鸣器和电磁扬声器一样没有内部驱动电路，需要接在音频输出电路中才能发声。如果给直流信号是不响的，因为磁路恒定，必须用 2K-5K 的方波去驱动它。声音频率可控，可以做出“多来米发索拉西”的效果。\n在一些特例中，可以和 LED 复用一个控制口。\n\n它们的电路原理图是一样的，只是控制方式不同\n\n因为有两个不同的模块，所以下文将分开讲解\n3. 有源蜂鸣器模块  有源蜂鸣器有内置振荡源，只需要接线就会发出蜂鸣声，但它的  发声是固定频率  的。这点和内置了控制芯片的  七彩 LED 模块  很相似。\n\n\n\n树莓派\nT 型转接板\n有源蜂鸣器\n\n\n\nGPIO 0\nGPIO 17\nI&#x2F;O\n\n\n3.3V\n3.3V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n在连接上电路后，有源蜂鸣器就会哔哔哔叫。我们可以通过控制输入电平的高低，来控制它的开关\n3.1 代码示例// 有源蜂鸣器#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_BuzzerPin  0  // 有源蜂鸣器管脚定义int main()&#123;    // 初始化连接失败时，将消息打印到屏幕    if(wiringPiSetup() == -1)&#123;         printf(&quot;setup wiringPi failed !&quot;);        return 1;      &#125;       pinMode(makerobo_BuzzerPin,  OUTPUT); // 有源蜂鸣器设置为输出模式    // 无限循环    while(1)    &#123;               digitalWrite(makerobo_BuzzerPin, LOW);        \t// 蜂鸣器为低电平触发，所以使能蜂鸣器让其发声            delay(100);           // 延时 100ms            digitalWrite(makerobo_BuzzerPin, HIGH);         \t// 蜂鸣器设置为高电平，关闭蜂鸣器            delay(100);           // 延时 100ms    &#125;       return 0;&#125;\n\n3.2 编译代码  第一次编译这个代码的时候，出现了下面的报错。意思其实很简单，就是 wiringPi 库 没有连接上，因为我忘记在最末尾加上 -lwiringPi 了\n\n正确的编译指令如下\ngcc 09activebuzzer.c -o ACTIVE -lwiringPi\n\n编译成功\n\n3.3 实验效果  改变 delay 函数的参数，就能听到蜂鸣器声音的变换。设置成 delay(1000) 可以延长声音效果\n\n第一次接线的时候，我不小心把它接在了 5v 的管脚上，导致输入高电平并不能关闭蜂鸣器，而是近似于改变了蜂鸣器的频率（我听不出是音量变了还是频率变了）\n修正错误，接线在 3.3v 管脚上后，有源蜂鸣器可以正常关闭\n\n总所周知，图片是没有声音的。所以我把  两个情况的录音文件  都放在了 gitee 仓库👉传送门\n\n4. 无源蜂鸣器  无源蜂鸣器可以通过  输入 pwm来  控制发声频率\n它的接线方式和有源蜂鸣器相同\n\n\n\n树莓派\nT 型转接板\n无源蜂鸣器\n\n\n\nGPIO 0\nGPIO 17\nI&#x2F;O\n\n\n3.3V\n3.3V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n4.1 代码示例// 无源蜂鸣器#include &lt;wiringPi.h&gt;#include &lt;softTone.h&gt;#include &lt;stdio.h&gt;#define makerobo_BuzPin    0 // 有源蜂鸣器管脚定义// 音谱定义// 低 C 音符的频率#define  Tone_CL1  131#define  Tone_CL2  147#define  Tone_CL3  165#define  Tone_CL4  175#define  Tone_CL5  196#define  Tone_CL6  221#define  Tone_CL7  248// 中 C 音的频率#define  Tone_CM1  262#define  Tone_CM2  294#define  Tone_CM3  330#define  Tone_CM4  350#define  Tone_CM5  393#define  Tone_CM6  441#define  Tone_CM7  495// 高 C 音符的频率#define  Tone_CH1  525#define  Tone_CH2  589#define  Tone_CH3  661#define  Tone_CH4  700#define  Tone_CH5  786#define  Tone_CH6  882#define  Tone_CH7  990// 第一首歌音谱int makerobo_song_1[] = &#123;Tone_CM3,Tone_CM5,Tone_CM6,Tone_CM3,Tone_CM2,Tone_CM3,Tone_CM5,Tone_CM6,Tone_CH1,Tone_CM6,Tone_CM5,Tone_CM1,Tone_CM3,Tone_CM2,                         Tone_CM2,Tone_CM3,Tone_CM5,Tone_CM2,Tone_CM3,Tone_CM3,Tone_CL6,Tone_CL6,Tone_CL6,Tone_CM1,Tone_CM2,Tone_CM3,Tone_CM2,Tone_CL7,                         Tone_CL6,Tone_CM1,Tone_CL5&#125;;// 第一首歌节拍int makerobo_beat_1[] = &#123;1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,                         1,1,1,1,1,1,3&#125;;// 第二首歌音谱int makerobo_song_2[] = &#123;Tone_CM1,Tone_CM1,Tone_CM1,Tone_CL5,Tone_CM3,Tone_CM3,Tone_CM3,Tone_CM1,Tone_CM1,Tone_CM3,Tone_CM5,Tone_CM5,Tone_CM4,Tone_CM3,Tone_CM2,                         Tone_CM2,Tone_CM3,Tone_CM4,Tone_CM4,Tone_CM3,Tone_CM2,Tone_CM3,Tone_CM1,Tone_CM1,Tone_CM3,Tone_CM2,Tone_CL5,Tone_CL7,Tone_CM2,Tone_CM1                        &#125;;// 第二首歌节拍int makerobo_beat_2[] = &#123;1,1,1,3,1,1,1,3,1,1,1,1,1,1,3,1,1,1,2,1,1,1,3,1,1,1,3,3,2,3&#125;;int main()&#123;    int i;    // 初始化连接失败时，将消息打印到屏幕    if(wiringPiSetup() == -1)&#123;        printf(&quot;makerobo setup wiringPi failed !&quot;);        return 1;    &#125;    // 软件模拟 Tone 库初始化识别，将消息打印到屏幕    if(softToneCreate(makerobo_BuzPin) == -1)&#123;        printf(&quot;makerobo setup softTone failed !&quot;);        return 1;    &#125;    while(1)&#123;        printf(&quot;makerobo music is being played...\\n&quot;);  // 开始播放音乐        // 播放第一首歌音乐        for(i=0;i&lt;sizeof(makerobo_song_1)/4;i++)&#123;            softToneWrite(makerobo_BuzPin, makerobo_song_1[i]);             // 第一首歌音谱            delay(makerobo_beat_1[i] * 500);   // 第一首歌节拍        &#125;        // 播放第二首歌音乐        for(i=0;i&lt;sizeof(makerobo_song_2)/4;i++)&#123;            softToneWrite(makerobo_BuzPin, makerobo_song_2[i]);             // 第二首歌音谱            delay(makerobo_beat_2[i] * 500);     // 第二首歌节拍        &#125;    &#125;    return 0;&#125;\n\n音符频率对照表\n\n音阶   音阶是音乐必不可少的要素，主要由声音的频率决定。通过给蜂鸣器不同频率的音频脉冲，可以产生不同的音阶，而要产生某频率的音频脉冲，最简单的办法是以该音频的频率除以 2 的值，函数使用该值为参数改变蜂鸣器输入方波信号的频率，蜂鸣器上就可发出该频率的声音。   若想改变音阶，只需要改变频率即可。下表为各音调音符频率对照表，据此可产生不同音阶的音符。“#”表示半音，用于上升或下降半个音，乘以 2 就提升该声音一个 8 度音阶，减半则降一个 8 度。\n\n节拍   若要构成音乐，光有音阶是不够的，还需要节拍，也就是音符持续时间的长短，一般用拍数表示。至于 1 拍是多少秒，没有严格的规定，只要节拍适宜，声音悦耳即可。假如某首歌曲的节奏是每分钟 120 拍，那么 1 拍为0.5s，1&#x2F;4 拍为0.125s，以此类推可得到其他节拍对应的时长。这样，利用不同的频率，加上与拍数对应的延时，就构成了乐曲。\n\n\n以上引用自这位大佬的博客👉原文链接\n\n我找来了一章音符与频率的对照表，供大家参考\n\nsoftTone 软件音频库  类似于softPWM，wiringPi 库中还包含了一个软件音频库，通过输入不同的音频频率来使无源蜂鸣器发出不同的声音\n\n这里提到了需要在编译文件时加入 -lpthread 选项，实测不需要加入也可以正常编译出来\n4.2 编译代码gcc 09passivebuzzer.c -o PASSIVE -lwiringPi\n\n\n4.3 实验效果  蜂鸣器的确发出了不同频率的声音，但是我感觉它并没有唱歌，哈哈😂\n录音文件也放在 gitee 仓库里面啦！👉传送门\n\n结语  这两个传感器和之前实验中出现的双色 LED 很像，不过一个是以声音为媒介，一个是以光为媒介来传递信息\n本篇博客到这里就结束啦，如果有什么问题，欢迎在评论区提出哦！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 10- 干簧管传感器实验","url":"/posts/722925156/","content":"\n\n前言  好像没啥可以说的，直接开始进入今天的实验内容吧\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\n干簧管传感器模块\n双色 LED\n跳线若干\n\n\n上：干簧管传感器；下：双色 LED\n\n2. 实验原理  干簧管传感器也是一种用于  检测磁场  的传感器。在常用的程控交换机、复印机、洗衣机、电冰箱、照相机、消毒碗柜、门磁、窗磁、电磁继电器、电子衡器、液位计、煤气表、水  表等产品中都得到了很好的应用。\n\n个人理解：干簧管传感器的效果和霍尔元件很像，不过后者的体积更小\n笔记本电脑中就有  霍尔元件 ，用于检测笔记本屏幕的开关，实现 合盖休眠的功能\n\n\n干簧管是  干式舌簧管  的简称，是一种有触点的无源电子开关元件，具有结构简单，体积小便于控制等优点。\n\n其外壳一般是一根密封的玻璃管，管中装有两个铁质的弹性簧片电板，还灌有一种叫金属的惰性气体。平时，玻璃管中的两个簧片是分开的。\n\n当有磁性物质靠近玻璃管时，在磁场磁力线的作用下，管内的两个簧片被磁化而互相吸引接触，簧片就会吸合在一起，使结点所接的电路连通。\n外磁力消失后，两个簧片由于本身的弹性而分开，线路也就断开了。\n因此，作为一种利用磁场信号来控制的线路开关器件，干簧管可以作为传感器用于计数、限位等等场景(在安防系统中主要用于门磁、窗磁的制作)，同时还被广泛使用于各种通信设备中。\n在实际运用中，通常用磁铁控制这两根金属片的接通与否，所以又被称为“磁控管”\n\n\n2.1 电路图  电路图中 Reed Switch(干簧管) 部分，其实就是原理部分提到的密封玻璃管，内部有两个铁片\n\n当干簧管部分接触到磁性物体时，两个铁片吸附在一起，电路接通，DO管脚输出低电平。同时电路接通，D2 LED点亮\n没有检测到磁性物体，两个铁片断开，电路断开，DO管脚直连VCC，输出高电平\n\n\n2.2 接线图  类似这种通过  一个传感器模块来控制双色 LED的实验我们已经做过好几个了。它们的接线方式基本是一样的👍\n\n\n\n树莓派\nT 型转接板\n干簧管\n\n\n\nGPIO 0\nGPIO 17\nDO\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT 型转接板\n双色 LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n\n\n当接线完毕后，PWM-LED指示灯常亮\n\n即便没有开启控制程序，当干簧管检测到磁性物体时，DO-LED指示灯也会亮起\n\n3. 代码示例  和之前控制双色 LED 的代码相同，我们使用 pinMode 设置干簧管传感器为输入模式，将红绿 LED 的管脚都设置成输出模式\n\n当 digitalRead 检测到 0（低电平）时，将双色 LED 设置为  红色\n当 digitalRead 检测到 1（高电平）时，将双色 LED 设置成  绿色\n\n// 干簧管控制双色 LED 实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_ReedPin\t0 // 干簧管传感器管脚定义#define makerobo_Rpin\t\t1 // 红色 LED 模块管脚定义#define makerobo_Gpin\t\t2 // 绿色 LED 模块管脚定义// 双色 LED 控制函数void double_colorLED(char* color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); // 红色 LED 管脚设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); // 绿色 LED 管脚设置为输出模式\tif (color == &quot;makeroboRED&quot;)       // 点亮红色 LED 灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (color == &quot;makeroboGREEN&quot;) // 点亮绿色 LED 灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;Double color LED Error&quot;);&#125;int main()&#123;\t// 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    // 干簧管传感器 Pin 设置为输入模式\tpinMode(makerobo_ReedPin, INPUT);\tdouble_colorLED(&quot;makeroboGREEN&quot;);  // 点亮绿色 LED 模块\t\twhile(1)&#123;\t\t// 干簧管传感器去除抖动处理\t\tif(0 == digitalRead(makerobo_ReedPin))        &#123; // 干簧管传感器检测到磁性物质\t\t\tdelay(10);       // 延时去抖动\t\t\tif(0 == digitalRead(makerobo_ReedPin))&#123;\t\t\t\tdouble_colorLED(&quot;makeroboRED&quot;);\t   // 点亮红色 LED 灯\t\t\t\tprintf(&quot;Detected Magnetic Material!\\n&quot;);// 打印出检测到磁性物质\t\t\t&#125;\t\t&#125;\t\telse if(1 == digitalRead(makerobo_ReedPin))        &#123; // 干簧管传感器没有检测到磁性物质\t\t\tdelay(10);        // 延时去抖动\t\t\tif(1 == digitalRead(makerobo_ReedPin))&#123;\t\t\t\twhile(!digitalRead(makerobo_ReedPin));\t\t\t\tdouble_colorLED(&quot;makeroboGREEN&quot;);   // 点亮绿色 LED 灯\t\t\t\tprintf(&quot;No Detected Magnetic Material!\\n&quot;); // 打印出没有检测到磁性物质\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n\n更详细的函数解释，可以参考之前  实验 6~8的博客👉专栏链接\n\n3.1 编译代码  在 linux 控制台下输入以下语句，编译生成可执行文件TEST\ngcc -Wall 10reedswitch.c -o TEST -lwiringPi\n\n3.1.1 GCC 中 -Wall 指令的作用  上一篇博客中，我在编译代码的时候就没有使用 -Wall 指令，但程序依旧编译成功了\n实际上，-Wall指令的作用是让 GCC 编译器显示程序的警告\n\n编译器在程序中检查出  错误  时，会终止编译\n编译器在程序中检查出  警告  时，依旧能编译生成可执行文件\n\nwindows 系统中的 VS 编译器下，也有错误 &#x2F; 警告两种报错方式\n\n之前我就没有弄明白 Linux 环境下这两个之间的区别，导致我认为 gcc 编译器中不支持用 == 直接比较常量字符串（然后就把它改成了 strcmp，当然这样也没错哈）\n\n如果我们在编译的时候去掉 -Wall 指令，就不会显示这两个警告\n\n\n更多关于 -Wall 指令的知识，大家可以参考这位 dalao 的博客学习一二👉传送门\n\n\n3.2 实验效果 ./TEST 运行可执行文件，查看实验结果\n\n检测到磁性物质时，屏幕打印 Detected Magnetic Material!\n没有检测到的时候，打印 No Detected Magnetic Material!\n\n\n结语  本次实验到这里就结束啦，希望对你学习树莓派的操作有一些帮助\n\n学校高数和大物欠下的学习债终于补上了，可以摸🐟了\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 14-PS2 游戏手柄摇杆","url":"/posts/423245526/","content":"本次实验还是需要用到PCF8591 模数转换器，莫非它要取代双色 LED 成为新的常驻嘉宾吗？\n\n\n\n本次实验是摇杆实验。这个玩意可以用于操控机器人或者是树莓派的遥控小车。当然，生活中最常见的用途还是在  游戏手柄  上。不知道你打不打游戏，有没有用过手柄玩游戏呢？\n\n本人有一个游戏手柄，玩 3a 还是挺爽的，哈哈\n\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\nPS2 手柄模块\nPCF8591 模数转换器模块（实验 12）\n一些跳线\n一个  一字螺丝刀\n\n\n2. 实验原理\n手柄模块通过以 90 度角安装两个电位计来判断当前的 X 值和 Y 值，从而计算出手柄的方向。再加上一个按钮，来判断手柄被按下（也就是游戏手柄上的 L3 和 R3 键的原理）\n\n处于静止位置时，此模块从 X 和 Y 产生约 2.5V 的输出。移动操纵杆将导致输出在 0v 到 5V 之间变化，具体取决于其方向。如果将此模块连接到微控制器，则可能会在其静止位置读取大约 512 的值(由于弹簧和机构的微小误差而引起的细微变化)。移动操纵杆时，应该看到该值从 0 变为到 1023，具体取决于其位置。\n该模块有两个模拟输出 (对应 X 和 Y 坐标) 和一个数字输出，表示是否在 Z 轴上按下。\n在本实验中，我们将引脚 X 和 Y 连接到 PCF8591A&#x2F;D 转换器的模拟输入端口，以便将模拟量转换为数字量。然后在树莓派上编程以检测操纵杆的移动方向\n2.1 电路图\n2.2 接线图\n\n\n树莓派\nT 型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\nPS2 手柄模块\nT 型转接板\nPCF8591\n\n\n\nVRY\n*\nAIN 0\n\n\nVRX\n*\nAIN 1\n\n\nSW\n*\nANI 2\n\n\n5V\n5V\n5V\n\n\nGND\nGND\nGND\n\n\n\n这个是我的接线图，其实可以直接用双母头跳线直接连接 PCF8591 和手柄模块，不过还是借助了 T 型转接板来连接二者。\n\n3. 效果演示3.1 代码示例//PS2 操作杆实验#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;#define makerobo_PCF       120   // 基础管脚 120#define uchar\tunsigned charint pcf_AIN0 = makerobo_PCF + 0; // AIN0 端口int pcf_AIN1 = makerobo_PCF + 1; // AIN1 端口int pcf_AIN2 = makerobo_PCF + 2; // AIN2 端口// 方向状态信息 char *state[7] = &#123;&quot;home&quot;, &quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;, &quot;pressed&quot;&#125;;// 方向判断函数int makerobo_direction()&#123;\tint ain_x, ain_y, ain_b;       // X 方向，Y 方向，B 是否按下\tint makerobo_tmp=0;            // 状态值\tain_x = analogRead(pcf_AIN1);  // X 为 AIN1 端口\tain_y = analogRead(pcf_AIN0);  // Y 为 AIN0 端口\tain_b = analogRead(pcf_AIN2);  // B 按下为 AIN2 端口\t\tif (ain_y &lt;= 30)\t\tmakerobo_tmp = 1;\t\t// up\tif (ain_y &gt;= 225)\t\tmakerobo_tmp = 2;\t\t// down\t\tif (ain_x &gt;= 225)\t\tmakerobo_tmp = 4;\t\t// left\tif (ain_x &lt;= 30)\t\tmakerobo_tmp = 3;\t\t// right\tif (ain_b == 0)\t\tmakerobo_tmp = 5;\t\t// button 按下\tif (ain_x-125&lt;15 &amp;&amp; ain_x-125&gt;-15 &amp;&amp; ain_y-125&lt;15 &amp;&amp; ain_y-125&gt;-15 &amp;&amp; ain_b &gt;= 60)\t\tmakerobo_tmp = 0;\t\t// home 位置\t\treturn makerobo_tmp;&#125;// 主函数int main (void)&#123;\tint makerobo_tmp=0;       // 当前值\tint makerobo_status = 0;  // 状态值\twiringPiSetup ();\t// 在基本引脚 120 上设置 pcf8591，地址 0x48\tpcf8591Setup (makerobo_PCF, 0x48);\t// 无线循环\twhile(1) \t&#123;\t\tmakerobo_tmp = makerobo_direction(); // 调用方向判断函数\t\tif (makerobo_tmp != makerobo_status) // 判断状态是否发生改变\t\t&#123;\t\t\tprintf(&quot;%s\\n&quot;, state[makerobo_tmp]); // 打印出方向位\t\t\tmakerobo_status = makerobo_tmp;                  // 把当前状态赋给状态值，以防止同一状态多次打印\t\t&#125;\t&#125;\treturn 0 ;&#125;\n\n这部分比较好理解，代码也很直观。只有 home 位置需要我们单独进行计算（即手柄处于正中心区域且没有按下的情况，才是 home 的情况）\n3.2 效果翻车  不过轮到实际测试的时候，翻大车了。在我还没有动摇杆的时候，它就会显示出左和按钮被按下的提示。我尝试修改代码来修复这个错误，发现并不可行\n\n于是我直接把代码给注释掉，加了一个打印 X\\Y\\B 当前值的代码\n\n结果呢，在我没动摇杆的时候，打印出来的 X 和 Y 都是乱七八糟的。只有按下摇杆的 B&#x3D;0 可以被正常检测到，其他的方位啥的都是毫无反应。\n\n直接给这个模块下达了死亡通知书，拜拜了您嘞！\n结语  通过学习这个模块的代码，可以看到实际上一些零部件的基本原理并不是非常难掌握。不过你想把一个摇杆变成一个完整的游戏手柄，那就需要更复杂的控制代码和手柄的内部芯片来转义这些数字值了。\n\n有什么问题的话，可以在评论区提出呢\n\n还是有所收获的，要是摇杆没坏就好了\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 13- 雨滴传感器","url":"/posts/2014251014/","content":"好久没玩树莓派了，今天上手来做一个实验\n\n\n\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\n雨滴传感器模块\nLM393 模块\nPCF8591 模数转换器模块（实验 12）\n一些跳线\n一个  一字螺丝刀\n\n\n2. 实验原理 2.1 基本说明 雨滴传感器的控制模块具有 4 个输出，其中 VCC 连接到 5V 电源，模块的 GND 引脚接地。DO 引脚连接到微控制器的数字引脚以进行数字输出，也可以使用模拟引脚。要使用模拟输出，可以将 A0 引脚连接到微控制器的 ADC 引脚。\n在雨滴 &#x2F; 雨水器系统中 ，用雨滴传感器检测降雨量并转换控制器检测到的信号。然后根据这些信号自动设置雨刮器的间隔，以方便地控制雨刮器的电机； 在智能照明系统中 ，自动检测驾驶环境并调整照明模式，提高恶劣环境下的行车安全； 在智能天窗系统中，检测是否下雨，如果检测到雨滴，则自动关闭天窗。\n传感器模块包括一个电位计，LM393 比较器，LED，电容器和电阻器。雨板模块由铜轨组成，铜轨用作可变电阻器。它的阻力随雨板上的湿度而变化。\n2.2 电路图\n2.3 接线图\n\n\n树莓派\nT 型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\nLM393 模块\nT 型转接板\nPCF8591\n\n\n\nDO\nGPIO 17\n*\n\n\nAO\n*\nAIN 0\n\n\nVCC\n3.3V\n*\n\n\nGND\nGND\n*\n\n\n\n在连接 LM393 和雨滴传感器的时候，发现雨滴传感器上并没有明确标出正负极，但是在  正极  的管脚下方用小点做了标识（负极无该白点）\n\n本次实验需要接的线非常多，注意不要接错了。其中 PCF8591 模块 在接线时需要将所有跳线帽拔出\n\n\n3. 代码效果 3.1 代码示例 因为需要使用pcf8591 模数转换器，所以需要引用头文件&lt;pcf8591.h&gt;\n// 雨滴探测传感器实验#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;#include &lt;math.h&gt;#define\tmakerobo_PCF    120 // 基础管脚 120#define\tmakerobo_DOpin\t 0   // 雨滴传感器管脚// 打印雨滴传感器提示信息void makerobo_Print(int x)&#123;\tswitch(x)\t&#123;\t\tcase 1:            // 没有雨滴\t\t\tprintf(&quot;\\n************************\\n&quot;  );\t\t\tprintf(&quot;* makerobo Not Raining *\\n&quot;  );\t\t\tprintf(&quot;************************\\n\\n&quot;);\t\t\tbreak;\t\tcase 0:             // 有雨滴\t\t\tprintf(&quot;\\n**********************\\n&quot;  );\t\t\tprintf(&quot;* makerobo Raining!! *\\n&quot;  );\t\t\tprintf(&quot;**********************\\n\\n&quot;);\t\t\tbreak;\t\tdefault:         // 打印数据错误\t\t\tprintf(&quot;\\n**********************\\n&quot;  );\t\t\tprintf(&quot;* Print value error. *\\n&quot;  );\t\t\tprintf(&quot;**********************\\n\\n&quot;);\t\t\tbreak;\t&#125;&#125;int main()&#123;\tint makerobo_analogVal;           // 定义模拟量存储变量\tint makerobo_tmp, makerobo_status;// 定义状态信息    // 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123;\t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1;\t&#125;\t// 在基本引脚 120 上设置 pcf8591，地址 0x48\tpcf8591Setup(makerobo_PCF, 0x48);    // 设置雨滴传感器管脚为输入模式\tpinMode(makerobo_DOpin, INPUT);    // 默认状态值设置为 0\tmakerobo_status = 0; \t// 无限循环\twhile(1) \t&#123;\t\tmakerobo_analogVal = analogRead(makerobo_PCF + 0);\t\t// 获取 AIN0 上的值\t\tprintf(&quot;%d\\n&quot;, makerobo_analogVal); // 打印出该值 \t\tmakerobo_tmp = digitalRead(makerobo_DOpin); \t\t// 读取数字 IO 口电平，读取数字雨滴传感器 DO 端口\t\tif (makerobo_tmp != makerobo_status) // 状态发生改变\t\t&#123;\t\t\tmakerobo_Print(makerobo_tmp); // 打印出雨滴传感器检测信息\t\t\tmakerobo_status = makerobo_tmp;  // 状态值重新赋值\t\t&#125;\t\tdelay (200);   // 延时 200ms\t&#125;\treturn 0;&#125;\n\n注意：雨滴传感器  其实是 LM393 和雨滴感应模块的集合体，所以代码注释中说的设置管脚为 input 模式，实际上设置的是 LM393 模块的管脚（毕竟只有它连上了 T 型转接板）\n\n本次博客的代码和之前的实验很相似，其中 PCF8591 在上篇  实验 12 博客  中已经有过讲解，所以在这里就不 bb 啦\n\n3.2 运行效果  当你把湿纸巾印在雨滴传感器上，屏幕上会打印出makerobo Raining!!，数值会随着雨滴量的大小变化（我这里测试的是，水多的时候打印的值小）但最后会趋于稳定，打印 128\n\n如果没有水，屏幕上打印makerobo Not Raining，数值打印 255\n\n在 LM393 模块上有两个 LED 指示灯，在传感器探测到水后，DO-LED会亮起\n\n如果你的 DO-LED 没有亮起，可以通过该传感器上蓝色的模块，用十字螺丝调节 LM393 模块的灵敏度（这个蓝色模块调节的是电阻）\n结语  有了这个东西，你可以把雨滴传感器丢到窗台上，在不在家的时候，就可以运行代码，看看家里有无下雨了（毕竟时候工作上学的地方和家里隔了十几公里，天气就可能完全不同）\n\n配合cpolar 实现内网穿透，效果更佳哦😀\n\n不过知道自己家下雨了，被子还没收，是不是徒增焦虑？\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【Curl】通过 curl 模拟 referer 获取到有防盗链的图片","url":"/posts/2721043914/","content":"本文所描述操作仅供学习 curl 命令，请勿用于盗刷他人图床等违规操作！🙅‍♀️\n\n\n1. 说明  当我想把 51la 添加到我的导航站点，却发现它的 icon 图标有防盗链，禁止空 referer 访问的；\n这点完全可以理解，为了防止他人盗刷本站的图片，通常我们都需要给图片地址加上防盗链。\n\n其实 51la 提供了自己的 icon，但这里提供的 icon 像素特别低，只有 16*16，在我的导航站点上的显示就没有那么友好了\n\n\n所以我才想把稍微清晰一点的 icon 图标下载下来\n2.curl 使用\n参考 https://www.ruanyifeng.com/blog/2019/09/curl-reference.html\n\n要避开这个 403 访问权限，需要做的就是给请求头给定一个 referer 字段，告诉 51la 的服务器，我是通过他自己的域名访问图标文件\ncurl \\-H &#x27;Referer: https://v6.51.la/&#x27; \\https://v6-static.51.la/v6-static/202302161047/favicon.ico \\-o favicon.ico\n\n对上面提到的几个参数做一定解释\n\n-H 设定请求头，需要符号 http 协议的标准key: value\n-o 将获取到的内容保存为文件，在后面指定文件名（这里我指定为了favicon.ico）\n\n在 linux 下用这个命令，就能成功拉取到 51la 的站点图片\n\n如果不加 referer 字段，则还是会返回 403\n$ curl https://v6-static.51.la/v6-static/202302161047/favicon.ico &lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;\n\n备注：windows 下使用这个 curl 命令会报错，因为 windows 下的 curl 参数和 linux 下是不同的。\n","categories":["差生文具多"],"tags":["Linux","curl"]},{"title":"【树莓派】实验 12-PCF8591 模数转换器","url":"/posts/2733996002/","content":"\n\n前言  由于树莓派不能直接读取模拟信号，所以我们需要本篇博客中提到的模数转换器来  替代实现读取模拟信号的功能。\n本篇博客的  这个模数转换器  比之前的模块复杂很多，我们需要一步一步弄明白它的  原理 ，才能 真正理解  如何使用这个小东西\n\n关注本专栏，和我一起学习树莓派开发板30+ 经典实验！\nC 语言代码，0 基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\n双色 LED 模块（元老级朋友）\nPCF8591 模数转换器模块\n一些跳线\n一字或者十字  螺丝刀🛠\n\n\n上：PCF8591 模数转换器模块；下：双色 LED\n\n2. 实验原理2.0 元件介绍PCF8591 是一个单片集成、单独供电、低功耗、8-bit CMOS 数据采集元件。\n\nPCF8591 具有 4 个模拟输入、1 个模拟输出和 1 个串行 I2C 总线接口。\n它的 3 个地址引脚 A0, A1 和 A2 可用于硬件地址编程，从而允许使用多达 8 个链接到 I2C 总线的设备，而无需额外的硬件。\n在 PCF8591 器件上输入输出的地址、控制和数据信号都是通过双线双向 I2C 总线以串行的方式进行传输。\n\n该元件的功能包括  模拟输入多路复用 ，片上跟踪和保持功能，8 位 模数  转换和 8 位  数模  转换。最大转换率由 I2C 总线的最大速度决定。\n2.1 i2c 总线\ni2c 总线是由  飞利浦公司  开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。\n\n飞利浦官方有一个关于 PCF8591 的详细介绍文档，不过它是英语的。我会上传到 gitee 仓库里面分享给大家，仓库链接在开头介绍过了🤦‍♂️回到开头\n\n\ni2c 总线系统中的每个 PCF8591 设备通过向该设备发送有效地址而被激活。地址由固定部分和可编程部分组成。可编程部分必须按照地址引脚 A0，A1，A2 进行设置。地址必须以邮寄方式发送。\n在 i2c 总线协议中，在启动条件之后的第一个字节，地址字节的最后一个位是  读 &#x2F; 写位 ，它设置了下列数据 传输的方向。\n\n2.2 第一字节PCF8591 采用典型的 I2C 总线接口器件寻址方法，即总线地址由器件地址、引脚地址和方向位组成。\n飞利浦公司规定 A&#x2F;D 器件地址为 1001，引脚地址为 A2A1A0，其值由用户选择。因此 I2C 系统中最多可接 2^3^ 个具有 I2C 总线接口的 A&#x2F;D 器件。地址的最后一位为方向位 R&#x2F;L，当主控器对 A&#x2F;D 器件进行写操作时为 0，进行读操作时为 1。\n总线操作时，由器件地址、引脚地址和方向位组成的从地址为主控器发送的  第一字节。\n2.3 控制字节  发送到 PCF8591 器件的  第二个字节  将被存储在  其控制寄存器  中，并且需要控制器件来实现功能。\n\n\n\nD1、D0 两位是 A&#x2F;D 通道编号：00 通道 0，01 通道 1，10 通道 2，11 通道 3\nD2 自动增量选择（0 为禁止自动增量，1 为允许自动增量），如果允许自动增量，则在每次 A&#x2F;D 转换后，通道编号会自动递增。\nD3 特征位：固定值为：0。\nD5、D4 模拟量输入选择：00 为四路单端输入、01 为三路差分输入、10 为两路单端与一路差分输入、11 为两路差分输入。\nD6 使能模拟输出 AOUT 有效（1 为有效，0 为无效）。\nD7 特征位：固定值为：0。\n\n上述内容参考 @Maker 张 大佬的博客👉传送门\n\n控制寄存器的高半字节用于模拟输出，并将模拟输入  编程为单端或差分输入。下半字节选择由上半字节定义的一个模拟输入通道。如果设置了自动增加标志，则在每次 A&#x2F;D 转换后，通道编号会自动递增。\n\n\n更多关于 i2c 总线的知识，可以查看百度百科的词条👉某度\n\n2.4 模块电路  在本次实验中，AIN0（模拟输入 0）端口用于接收来自电位计模块的模拟信号，AOUT（模拟输出）用于将模拟信号输出到双色 LED 模块，用于改变 LED 的  亮度\n\n如果你有注意看电路图的话，你会发现 AOUT 上链接了一个D4-LED，它也会接收模拟输出信号，同步改变亮度\n\n而在我手头上的模块，D2-LED就是会同步改变亮度的，后文会提到\n\n\n在实验之前，我们可以把 AIN 上的电位帽拔掉\n\n2.5 电路接线\n\n\n树莓派\nT 型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n双色 LED\nT 型转接板\nPCF8591\n\n\n\nR(中间)\n*\nAOUT\n\n\nGND(-)\nGND\nGND\n\n\nG(S)\n*\n*\n\n\n\n拍出来的接线图好像有亿点点乱😂\n\n正常接线后，主板上的 D1-LED 会亮起\n\n我们可以根据原理图利用 T 型转接板 来连接模数转换器和双色 LED，也可以用这种双母头的线直接连接 AOUT 端口和双色 LED 的中间管脚\n\n\n3. 程序控制 3.1 在树莓派中开启 I2C 通过 VNC 打开树莓派的桌面，点击  开始 - 首选项 -Raspberry Pi Configuration-Interfaces，打开 I2C 的开关 enable\n\n3.2 代码示例//PCF8591 模数转换器#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;// 这个头文件是包含在库中的#define makerobo_PCF  120  // 基础管脚 120// 主函数int main ()&#123;\tint pcf_value ;// 定义一个变量存储 AIN 的输入值\t// 初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\tpcf8591Setup (makerobo_PCF, 0x48);    // 在基本引脚 120 上设置 pcf8591，地址 0x48\twhile(1)\t&#123;\t\tpcf_value = analogRead  (makerobo_PCF + 0);\t\t// 获取 AIN0 上的值，插上跳线帽之后，采用的是内部的电位器；\t\tprintf(&quot;%d\\n&quot;, pcf_value);        // 打印出该值            \t\tanalogWrite (makerobo_PCF + 0, pcf_value);         // 控制 AOUT 输出电平控制 LED 灯\t\tdelay (10) ; // 延时 10ms\t&#125; \treturn 0 ;&#125;\n\n头文件 &lt;pcf8591.h&gt;在 wiringPi 的官方库中，可以查找到关于 PCF8591 使用的相关函数👉点我\n\n\n3.3 编译代码  在控制台输入以下指令，编译出可执行文件TEST\ngcc -Wall 12pcf8591.c -o TEST -lwiringPi\n\n3.4 运行结果  在运行程序之前，我们需要先把 AIN0 和INPUT0之间的跳线帽装上\n随后 ./TEST 运行可执行文件，屏幕上会打印出 AIN0 管脚上获取的值\n\n但是不管我咋拧模块上的  白蓝电位计，这个数字都不动\n后面发现这个代码必须要在树莓派的 OS 里面跑，才能实现控制功能，应该和 3.1 中的 I2C 总线功能有关\n\n于是在 Geany 编译器中编译代码，开始执行\n\n拧动白蓝电位计，屏幕上接收到的值会不断变化，同时 LED 小灯 和主板上的 D2-LED 红色  亮度  也会产生变化\n\n\n结语  本次实验对于我这个模电小白来说就晕乎乎的，虽然查找了一些 I2C 相关的文档和博客，但还是没太弄明白这个模块的具体原理和进阶使用。\n\n不过通过本次这个简单的控制双色 LED 的实验，至少我知道了可以通过电位计来调节 AOUT 值，想必在更复杂的实验中，这个模块可以扮演不一样的角色！\n那就只能期待未来我会用到它啦！（我怎么感觉不会呢？）\n\n\n纯小白，本篇博客可能有很大的纰漏，还请各位大佬无情指正！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验 15- 电位计传感器","url":"/posts/1509681384/","content":"今天的这个实验需要用上两位常驻嘉宾！\n它们就是 PCF8591 和双色 LED！\n\n\n\n\n\n\n1. 实验器材\n树莓派开发板\n40p 软排线 +T 型转接板 + 面包板\n双色 LED 模块（元老级朋友）\nPCF8591 模数转换器模块（长老级朋友）\n电位计传感器\n一些跳线\n\n\n上：电位计传感器；下：双色 LED\n\n2. 实验原理2.1 基本原理\n电位计是一种用于测量电路中电势 (电压) 的仪器。通过电流计将来自电阻式滑动导线的已知电压的一部分与未知电压进行比较。调节电位器的滑动触点或游标。然后将检流计短暂地连接在滑动触点和未知电压之间，观察检流计的挠度，并调节滑动分接头，直到检流计不再从零偏斜为止。\n此时，检流计不再从未知源汲取电流，并且可以从滑动触点的位置计算出电压的幅值。\n\n电位器，又称 POT，是可变电阻器。他们可以通过简单地改变其头部顶部的旋钮来提供可变的电阻。可以基于两个主要参数对其进行分类。一个是电阻 (R-ohms) 本身，另一个是功率 (P-Watts) 额定值。\n\n在本实验中，PCF8591 用于读取电位计的模拟值并将值输出到双色 LED。\n将电位器的引脚SIG（电位器上的 OUT 管脚）连接到 PCF8591 的引脚 AINO。将双色 LED 的引脚 R 或引脚 G 连接到 PCF8591 的引脚 AOUT，以观察 LED 的变化。\n\n2.2 接线图  有了前两次接线的经验，这一次就只需要复刻就行了\n\n\n\n树莓派\nT 型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n电位计\nT 型转接板\nPCF8591\n\n\n\nOUT\n*\nAIN 0\n\n\nVCC\n5v\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n双色 LED\nT 型转接板\nPCF8591\n\n\n\nR(中间)\n*\nAOUT\n\n\nGND(-)\nGND\nGND\n\n\nG(S)\n*\n*\n\n\n\n实物图一如既往的乱，哈哈哈\n\n\n3. 实验效果 3.1 代码示例 本次实验使用上了AOUT 的接口，用于接收电位计的信号而改变双色 LED 亮度\n// 电位器模块实验#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;#define makerobo_PCF  120 // 基础管脚 120// 主函数int main ()&#123;\tint pcf_value ;     // 定义一个变量存储 AIN 的输入值\twiringPiSetup () ;   // 调用初始化函数\t// 在基本引脚 120 上设置 pcf8591，地址 0x48\tpcf8591Setup (makerobo_PCF, 0x48) ;\twhile(1) // 无限循环\t&#123;\t\tpcf_value = analogRead  (makerobo_PCF + 0) ;        // 获取 AIN0 上的值，读取电位器模拟量值；\t\tprintf(&quot;Potentiometer Value: %d\\n&quot;, pcf_value);         // 打印出该值    \t\tanalogWrite (makerobo_PCF + 0, pcf_value) ;            // 控制 AOUT 输出电平控制 LED 灯\t\tdelay (200) ;  // 延时 200ms\t&#125;\treturn 0 ;&#125;\n\n\n这里先用 Read 函数读取电位计的值，然后再用 Write 函数写入到PCF8591，它用 AOUT 输出到双色 LED，来控制它的亮度\n\n3.2 实验效果  如果你看过实验 12 的博客的话，你应该还记得，PCF8591 上也有一个电位计，他也能实现本次实验的效果。\n\n但不同的是，本次实验使用的是单独的电位计模块，调节更加方便，不需要使用螺丝刀\n\n运行程序，屏幕上会打印出电位计接收到的值，通过调节旋钮，值在 0-255 之间波动\n\n效果如图，还是很明显的\n\n结语  本篇博客到此结束，感谢你的阅读\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【微机】DOSBox 在 windows 上的安装和 masm 的配置","url":"/posts/2839269095/","content":"最近学校学习微型计算机原理与接口技术，需要用到 DOSBox 来模拟 DOS 环境进行汇编编程的学习。\n本文记录了如何在 windows11&#x2F;10 上安装 DOSBox0.74 并配置masm5\n1. 安装  这两个软件我打包上传到了百度云盘。放心，加起来也就 2mb，下载应该不会很久\n链接: https://pan.baidu.com/s/1vjbSL7iwP8WpMVA9K505ZA提取码: kr4x\n\n1.1 DOSBox点击 DOSBox0.74 的安装包，无脑下一步安装即可\n\n安装出来的图标如下\n\n1.2 masm5找一个空的文件夹，文件路径中不能包含空格、特殊字符和中文，将 masm5.zip 中的文件全部解压到这个文件夹中，如下图\n\n随后修改 DOSBox 软件的配置文件，右键桌面上 Dosbox 软件的快捷图标，选择  打开文件所在位置  找到 DOSBox 软件的安装路径，点击 DOSBox 0.74 Options.bat 文件，稍等片刻，会以记事本的方式打开配置文件。\n\n拉到配置文件最底下，新增如下配置。你只需要修改 D:\\GAME\\masm 为你的 masm5 文件的解压目录就行了。这个文件路径中不能有空格，也不能有特殊字符和中文！\nMOUNT C D:\\GAME\\masmpath=%path%; \\masmC: cd \\asm\n\n配置完成后，启动 DOSbox，查看 masm 命令是否能正常使用。如图所示，没有报错 masm 命令不存在，那么就是配置好了。\n\n2. 修改 DOSBox 窗口大小  默认情况下 DOSBox 的命令行窗口是非常非常非常小的，我们需要将其改大。同样是修改 DOSBox 的配置文件，如何打开配置文件参考上文。\n按下图所示修改\n\n请注意，这里的 1280 和 1080 中间的是大写的 X，并不是乘号\nwindowresolution=1280X1080output=opengl\n\n修改了之后保存，再重新打开 DOSBox，界面就应该会变大了。如果你觉得还是小了，可以修改这里的分辨率，继续让他变大一点。\n3. 编译一个汇编程序  用下面最简单的汇编程序做测试，将如下内容写入到 test.asm 中，并放入和 masm 的同一目录下（必须要是同一目录）\nCODE SEGMENT ;USE16     ASSUME CS:CODEBEG: MOV DL,&#x27;H&#x27;     MOV AH, 2 ; 调用 2 号 DOS 系统调用输出字符到屏幕上     INT 21H     MOV AH, 4CH     INT 21HCODE  ENDS        END BEG\n\n打开 DOSBox，输入如下命令\nmasm test.asmlink test.obj\n\n输出如下图所示，第一个命令的作用是编译源文件（注意看有没有编译报错）；第二个命令的作用是链接 obj 文件，最终会弹出来一个警告，不用管他。\n\n最终执行 test，成功输出字符 H 到终端上。\n\n能走到这一步，就代表你的 masm 基本环境已经配置好了。可以用来编译运行汇编代码了\n","categories":["差生文具多"],"tags":["win"]},{"title":"【工具】复制网页为 markdown 的浏览器插件","url":"/posts/4128600186/","content":"说明  如果您需要转载或者想保存他人的文章。可以使用一个油猴插件，快速将网站页面复制为 markdown（以下简称 md）。\n只要目标网站是支持 md 语法（大部分博客站点都是支持的）那么复制下来的效果基本没问题（已知有问题的是 md 中  表格  的复制）\n\n再次提醒：转载他人文章一定要注明出处，并尽量在得到原作者许可后转载。\n\n\n安装浏览器油猴扩展edge 和 chome 都可以安装此插件，以 edge 为例，在如下位置可进入插件配置页\n\n或者直接输入 url 也可进入插件页面\nedge://extensions/\n\n进入页面后，点击获取商店中的扩展\n\n搜索 tampermonkey，下载下图中绿色的这个插件（下载量最多的那个）\n\n安装复制为 markdown 插件  随后进入 https://greasyfork.org/zh-CN 网站，搜索一个插件\n复制为 markdown 格式\n\n\nhttps://greasyfork.org/zh-CN/scripts/370299-%E5%A4%8D%E5%88%B6%E4%B8%BAmarkdown%E6%A0%BC%E5%BC%8F\n\n安装完毕后，右上角的油猴图标会多出此插件。在这里也可以选择开关此插件，一般在需要的时候打开就行了。以免日常访问网站的时候误触复制按钮\n\n使用  这里随便找了一个 csdn 文章【链接】\n在右上角可以看到一个蓝色的 copy 按钮\n\n点击按钮，会出现  蓝色虚线选择框。我们直接放到文章正文部分，点击一下，就复制成功了。\n目前已知的问题是这个插件无法处理表格，其他都还 ok\n\n本教程结束~\n\n再次提醒：转载他人文章一定要注明出处，并尽量在得到原作者许可后转载。\n\n","categories":["差生文具多"]},{"title":"【Python】selenium 遇到 ActionChains.move_to_element() takes 2 positional arguments but 4 were given 报错","url":"/posts/2142561511/","content":"刚开始学的时候，用火绒的 selenium 插件录制了一个操作，导出为了 python 文件；\n\n\n使用如下的命令运行这个文件（如果没有 pytest 用 pip 安装一下就行）\npip install pytestpip install selenium\n\n用如下命令执行导出的文件\npytest test_test01.py\n\n会得到这个报错\n      actions = ActionChains(self.driver)&gt;     actions.move_to_element(element, 0, 0).perform()E     TypeError: ActionChains.move_to_element() takes 2 positional arguments but 4 were giventest_test1.py:42: TypeError\n\n可我压根没有修改过导出的文件，这个报错是怎么来的呢？\n目测是高低版本的 python 的 selenium 包中，报错的 ActionChains.move_to_element() 这个函数的传参被修改过；而插件生成的代码中，上方的这个就是正确的传参，下方的这个带 0,0 的传参是错误的\n# 3 | mouseOver | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget | element = self.driver.find_element(By.CSS_SELECTOR, &quot;.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget&quot;)actions = ActionChains(self.driver)actions.move_to_element(element).perform()  # 正确# 4 | mouseOut | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget | element = self.driver.find_element(By.CSS_SELECTOR, &quot;body&quot;)actions = ActionChains(self.driver)actions.move_to_element(element, 0, 0).perform() # 错误\n\n\n可以查看函数定义，只接受一个参数\n\n把这里的两个 0,0 删除掉就行了，运行的结果和我录制的效果相同，没有问题！\n\n顺带附上本次 debug 的版本号\npython             3.10.5pytest             7.4.0selenium           4.11.2火狐浏览器版本 116.0.2（64 位）火狐浏览器 Selenium IDE 插件版本 3.17.4\n\n如果帮到了你，还请评论支持我一下，谢谢！\n","categories":["速通Python"],"tags":["Python","selenium"]},{"title":"【Python】自动化测试 selenium","url":"/posts/192617188/","content":"学习自动化测试 selenium 的笔记。\n贪多嚼不烂，当时就是为了面试零时抱佛脚学的，既然现在用不到了，那没必要继续记录博客了。所以请不要看本文！\n\n\n1. 什么是自动化测试  自动化测试指软件测试的自动化，在预设状态下运行应用程序或者系统，预设条件包括正常和异常，最后评估运行结果。将人为驱动的测试行为转化为机器执行的过程。\n说白了就是编写一系列代码来实现自动帮我们测试某一个功能是否有啥问题。比起自己弄，自动化测试能覆盖到更多情况，特别是某些在实际情况中不好通过人工模拟出的问题。\n下图是自动化测试的金字塔模型，从下往上代表测试需要的时间和投入，单元测试应该是投入最大的测试。\n\n1.1 单元测试  所谓单元测试，就是我们代码中每一个函数、程序模块的测试。\n单元测试通常遵循以下步骤：\n\n编写测试用例：为每个函数、方法或类编写测试用例，这些用例包括输入数据、预期输出以及对应的函数调用。\n运行测试：使用单元测试框架运行编写的测试用例。测试框架会执行测试并报告每个测试的结果。\n断言测试结果：测试框架会自动比较实际输出与预期输出，如果不匹配则会产生错误报告。\n修复错误：如果测试失败，开发人员需要检查代码并修复问题，确保代码按预期工作。\n重复测试：在每次代码更改后，都需要重新运行相应的单元测试，以确保新的更改没有破坏现有的功能。\n\n单元测试的目标，就是保证我们写出来的函数是依照我们的预期运行的，能得到我们需要的结果。而最终目的，就是避免当一个函数已经投入使用了，才发现这个函数的运行与预期结果不符合。\n1.2 接口测试  目前一般采用后端提供 API 接口，前端使用静态页面的方式来实现前后端分离。\n而接口测试，就是保证我们后端提供的 API 接口能正确分离我们预期的参数，并提供与之相符合的返回结果。\n当我们完成了后端接口的编写后，就能在产品前期进行接口测试，避免产品已经上线了才发现接口有问题的情况。\n\n产品前期接口完成后介入\n用例维护量小\n适合接口变动较小，界面变动频繁的项目\n\n常见的接口自动化测试工具有：RobotFramework，JMeter，SoapUI，TestNG+HttpClient，Postman 等。\n1.3 UI 测试  对于用户来说，他们接触到的其实还是 UI（前端），在完成了接口测试后，我们需要对前端界面的操作进行测试。特点：\n\n用例维护量大\n页面相关性强，需要完成后期项目开发后才介入\n由于前端界面相对来说比较复杂，UI 测试适合界面变动较小的项目\n\nUI 自动化测试的好处\n\n减少重复测试的时间，实现快速回归测试\n创建可靠的测试过程，避免测试过程中的人为错误\n可以实现很多更加繁琐的测试，或者难以用人工实现的测试，减少人力成本\n更好的利用资源和测试脚本\n\nUI 层的测试框架比较多，比如 Windows 客户端测试的 AutoIT，web 测试的 selenium 以及 TestPlant eggPlant，Robot framework，QTP 等。\n1.4 自动化测试适用对象\n产品型项目。产品型的项目，新版本是在旧版本的基础上进行改进，功能变不大的项目，但项目的新老功能都必须重复的进行回归测试。回归测试是自动化测试的强项，它能够很好的验证你是否引入了新的缺陷，老的缺陷是否修改过来了。在某种程度上可以把自动化测试工具叫做回归测试工具。\n机械频繁的测试。每次需要输入大量用例，并且在一个项目中运行的周期比较长。 比如兼容性测试。\n\n以下情况就不适用于自动化测试：\n\n需求变动频繁，自动化脚本不能很好的复用（写个测试脚本的时间都够人工测试了，自然不适合自动化测试）\n项目周期短，自动化脚本编写完毕后使用次数不多（没啥时间写脚本）\n交互性较强，需要人工干预的项目，自动化无法实施\n\n1.5 如何实施自动化测试？单纯的讲，自动化测试的具体实现，应该是包含下面七个过程的。\n\n分析：总体把握系统逻辑，分析出系统的核心体系架构。\n设计：设计测试用例，测试用例要足够明确和清晰，覆盖面广而精\n实现：实现脚本，有两个要求一是断言，二是合理的运用参数化。\n执行：执行脚本远远没有我们想象中那么简单。脚本执行过程中的异常需要我们仔细的去分析原因。\n总结：测试结果的分析，和测试过程的总结是自动化测试的关键。\n维护：自动化测试脚本的维护是一个难以解决但又必须要解决的问题。\n分析：在自动化测试过程中深刻的分析自动化用例的覆盖风险和脚本维护的成本。\n\n\n2. 安装 Selenium 环境  本文使用各个软件的版本号\npython             3.10.5pytest             7.4.0selenium           4.11.2火狐浏览器版本   116.0.2（64 位）火狐浏览器 Selenium IDE 插件版本 3.17.4\n\n\n2.1 火狐安装 Selenium IDE打开火狐，点击右上角选择框，进入  扩展和主题\n\n点击左侧扩展，搜索 Selenium IDE\n\n第一个就是我们要的，图标是蓝色的，中间有一个 Se 字母\n\n进入后，点击获取插件（这里我已经安装了，所以显示的是  移除）\n\n2.2 windows 安装 python在 windows 上 python 安装的基础步骤参考我的这篇博客：【Python】在你的云服务 &#x2F; 电脑上搭建 Python 环境\n\n初次安装 python 的时候，一定要勾选 ADD PYTHON TO PATH 这个选项，这个在上文中有提及。因为非常重要所以多说几次！\n\n安装好 python 后，使用 pip 安装如下两个包\npip install pytestpip install selenium\n\n如果按照的很慢可以加上镜像源\npip install pytest -i https://pypi.tuna.tsinghua.edu.cn/simplepip install selenium  -i https://pypi.tuna.tsinghua.edu.cn/simple\n\nwindows 下如何配置 pip 镜像源参考：【Python】pip 下载使用国内镜像源\n2.3 安装火狐驱动 geckodriver如果你尝试直接运行 selenium 的代码，极有可能会遇到如下报错，这是因为你没有安装火狐对应的驱动\nWebDriverException: Message: &#x27;geckodriver&#x27; executable needs to be in PATH.\n\n火狐驱动下载地址：https://github.com/mozilla/geckodriver/releases\n\nchrome 驱动下载地址：https://registry.npmmirror.com/binary.html?path=chromedriver/\n因为本文操作用的都是火狐，所以不提及 chrome 的操作。请自行查阅其他文章\n\n下载好了之后，将其中的 geckodriver.exe 解压到 windows 下 python 的安装路径的 Scripts 文件夹下；\n\n如果你用的是上面提到那片博客里面的安装方式，那么在 windows 平台下 python 默认的安装路径如下\nC:\\Users\\moth\\AppData\\Local\\Programs\\Python\\Python310\n\n如果你不知道你电脑上 python 的安装路径，可以在 vscode 的解析器中找到；当你在 vscode 中打开一个 test.py 文件，右下角就会显示当前使用的解析器\n\n点击它，就能看到你安装的 python 的路径\n\n注意：如果你的 python 是用 windows 商店安装的，那路径里面是没有 Scripts 文件夹的！所以强烈不推荐使用 windows 商店来安装 python（虽然确实方便）\n你可以在 windows 设置 - 软件里面找到微软商店安装的 python，将其卸载，然后再用上面提到的办法重新安装你需要的版本的 python！\n\n2.4 尝试录制一段操作  上面的安装都完成后，就可以来尝试录制一段操作了。这里我使用了我自己的导航页来测试，打开火狐后，点击右上角的这个拼图图标\n\n选择 selenium IDE 运行扩展\n\n点击第一个，在新项目中录制一个新操作\n\n随便输入一个项目名字\n\n选择你需要录制的页面 url，这里我填了我自己的主页 web.musnow.top，填写好了之后点击 START RECORDING 开始录制\n\n开始录制后，右下角会出现正在录制的提示；以下是我录制了的操作。\n这里我在我主页的输入框中输入了你好，点击回车\n\n然后我又点击了第一个搜索结果，录制到这里就结束了\n\n进入 selenium IDE 的页面，点击右上角的红色方框停止录制（下图中是已经停止录制后的样子）中间会显示你这次录制做了什么\n\n将本次录制保存，随便起个名字，然后右键左侧的录制名，选择 export 导出\n\n选择 python 代码，点击导出；弹出的框会让你选择导出路径\n\n下面就是我导出后的代码，Selenium IDE 会将文件命名为  项目名_录制名.py\n# Generated by Selenium IDEimport pytestimport timeimport jsonfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.action_chains import ActionChainsfrom selenium.webdriver.support import expected_conditionsfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesclass TestTest1():  def setup_method(self, method):    self.driver = webdriver.Firefox()    self.vars = &#123;&#125;  def teardown_method(self, method):    self.driver.quit()  def wait_for_window(self, timeout = 2):    time.sleep(round(timeout / 1000))    wh_now = self.driver.window_handles    wh_then = self.vars[&quot;window_handles&quot;]    if len(wh_now) &gt; len(wh_then):      return set(wh_now).difference(set(wh_then)).pop()  def test_test1(self):    # Test name: test1    # Step # | name | target | value    # 1 | open | / |    self.driver.get(&quot;https://web.musnow.top/&quot;)    # 2 | setWindowSize | 1721x935 |    self.driver.set_window_size(1721, 935)    # 3 | mouseOver | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget |    element = self.driver.find_element(By.CSS_SELECTOR, &quot;.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget&quot;)    actions = ActionChains(self.driver)    actions.move_to_element(element).perform()    # 4 | mouseOut | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget |    element = self.driver.find_element(By.CSS_SELECTOR, &quot;body&quot;)    actions = ActionChains(self.driver)    actions.move_to_element(element, 0, 0).perform()    # 5 | click | id=txt |    self.driver.find_element(By.ID, &quot;txt&quot;).click()    # 6 | type | id=txt | 你好    self.driver.find_element(By.ID, &quot;txt&quot;).send_keys(&quot; 你好 &quot;)    # 7 | sendKeys | id=txt | $&#123;KEY_ENTER&#125;    self.vars[&quot;window_handles&quot;] = self.driver.window_handles    # 8 | selectWindow | handle=$&#123;win5784&#125; |    self.driver.find_element(By.ID, &quot;txt&quot;).send_keys(Keys.ENTER)    # 9 | click | css=.\\_paragraph_5yh6i_2 &gt; span &gt; span |    self.vars[&quot;win5784&quot;] = self.wait_for_window(2000)    # 10 | selectWindow | handle=$&#123;win5879&#125; |    self.driver.switch_to.window(self.vars[&quot;win5784&quot;])    self.vars[&quot;window_handles&quot;] = self.driver.window_handles    self.driver.find_element(By.CSS_SELECTOR, &quot;.\\\\_paragraph_5yh6i_2 &gt; span &gt; span&quot;).click()    self.vars[&quot;win5879&quot;] = self.wait_for_window(2000)    self.driver.switch_to.window(self.vars[&quot;win5879&quot;])\n\n使用如下命令运行这个文件\npytest 文件名\n\n直接运行会遇到如下的报错\n      actions = ActionChains(self.driver)&gt;     actions.move_to_element(element, 0, 0).perform()E     TypeError: ActionChains.move_to_element() takes 2 positional arguments but 4 were giventest_test1.py:42: TypeError\n\n报错的意思是 ActionChains.move_to_element()函数只需要接受两个参数，但却提供了 4 个参数，出错的是第四十二行的位置\n\n解决办法是将这里的 ,0,0 给删除，类似 38 行，只传入 element 参数就可以了\nactions.move_to_element(element).perform()\n\n完整解决办法参考：【Python】selenium 遇到 ActionChains.move_to_element() takes 2 positional arguments but 4 were given 报错\n修改好了之后，再用 pytest 运行这个文件，其会弹出一个火狐的浏览器窗口，并在窗口里面复现我们刚刚录制的操作了！\n3. 代码学习  只会录制是不够的，我们还需要学会这个库的 webdriver API 基本使用；\n\n需要注意是，不同版本的 python selenium包其内部函数有所区别，请确认您的版本和本文所使用的版本相同！否则会出问题的😶‍🌫️\nselenium   4.11.2\n\n3.1 小试牛刀  在百度主页，用 F12 打开开发者模式，选中搜索框，能定位到如下 html 代码\n&lt;input id=&quot;kw&quot; name=&quot;wd&quot; class=&quot;s_ipt&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt;\n\n先来看看如下的示例代码吧，这个代码的作用是在百度里面搜索 selenium；\n这里我们选择了 webdriver.Firefox() 火狐作为驱动；随后使用了 By.ID 定位到了 kw 的位置，即这个搜索框，并在内部 send_keys 输入了 selenium 文字。\n休眠了 2 秒后，又通过 ID 找到了 su 的 html 标签（这是确认搜素的按钮），并使用 click() 方法点击了这个按钮；\n# coding = utf-8from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timebrowser = webdriver.Firefox()  # 使用火狐的浏览器驱动（必须在 python 安装目录里面安装对应驱动）time.sleep(2)browser.get(&quot;http://www.baidu.com&quot;)  # 打开网页time.sleep(2)browser.find_element(By.ID,&quot;kw&quot;).send_keys(&quot;selenium&quot;)  # 找到网页中的 id 为 kw 的地方，输入 &quot;selenium&quot;time.sleep(2)browser.find_element(By.ID,&quot;su&quot;).click()  # 点击 id 为 su 的按钮time.sleep(2)browser.quit()  # 退出网页\n\n除了 quit()，还有close() 办法也能关闭网页\nbrowser.close() # 也可以关闭窗口。# 两者的区别是：# close 方法关闭当前的浏览器窗口，quit 方法不仅关闭窗口，还会彻底的退出 webdriver，释放与 driver# server 之间的连接。所以简单来说 quit 是更加彻底的 close，quit 会更好的释放资源。\n\n最终运行的效果如下（录制的动图，效果可能不咋地）\n\n3.2 元素的定位 3.2.1 基本说明 在 html 中元素的定位是自动化测试的核心，脚本必须要知道你需要操作的是什么页面的元素，才能正常进行自动化处理；\n而在 html 中，一个对象可以用不同的办法来定位到\nidnameclass namelink textpartial link texttag namexpathcss selector\n\n前面提到过，百度的输入框 html 是下面这样的。光是在这一行 html 代码中，就包含了 id、name、class 这三个可以用于我们来定位的元素，还有“看不到”的 css 也能定位到这里。\n&lt;input id=&quot;kw&quot; name=&quot;wd&quot; class=&quot;s_ipt&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt;\n\n浏览器开发者模式中，右侧就能看到和 kw 相关的 css 是#kw\n\n需要注意的是，要想定位到  唯一元素 ，必须要保证这个元素的标识符在整个页面是唯一的！假设百度的主页有两个id=&quot;kw&quot; 的元素，那就没有办法通过 id 来定位到输入框！这就要求写前端的朋友们，尽可能地为每一个需要测试的页面元素留下一个唯一的 id 或者 name，保证自动化脚本能正常运行！\n不同定位方式，我们只需要修改 By. 来自什么，以及传入对应的参数就可以了！\n#  通过 id 方式定位browser.find_element(By.ID,&quot;kw&quot;).send_keys(&quot;selenium1&quot;) # 找到网页中的 id 为 kw 的地方，输入 &quot;selenium&quot;#  通过 name 方式定位browser.find_element(By.NAME,&quot;wd&quot;).send_keys(&quot;selenium2&quot;)#  通过 tag name 方式定位browser.find_element(By.TAG_NAME,&quot;input&quot;).send_keys(&quot;selenium3&quot;) # 不能成功，因为 input 元素太多了，不唯一！#  通过 class name 方式定位browser.find_element(By.CLASS_NAME,&quot;s_ipt&quot;).send_keys(&quot;selenium4&quot;)#  通过 CSS 方式定位browser.find_element(By.CSS_SELECTOR,&quot;#kw&quot;).send_keys(&quot;selenium5&quot;)#  通过 XPATH 方式定位browser.find_element(By.XPATH,&quot;//*[@id=&#x27;kw&#x27;]&quot;).send_keys(&quot;selenium6&quot;)\n\n当运行到 input 定位的时候，由于定位不唯一，就会出现如下报错\nselenium.common.exceptions.ElementNotInteractableException: Message: Element &lt;input name=&quot;ie&quot; type=&quot;hidden&quot;&gt; is not reachable by keyboardStacktrace:RemoteError@chrome://remote/content/shared/RemoteError.sys.mjs:8:8WebDriverError@chrome://remote/content/shared/webdriver/Errors.sys.mjs:187:5ElementNotInteractableError@chrome://remote/content/shared/webdriver/Errors.sys.mjs:347:5webdriverSendKeysToElement@chrome://remote/content/marionette/interaction.sys.mjs:631:13interaction.sendKeysToElement@chrome://remote/content/marionette/interaction.sys.mjs:605:11sendKeysToElement@chrome://remote/content/marionette/actors/MarionetteCommandsChild.sys.mjs:535:29receiveMessage@chrome://remote/content/marionette/actors/MarionetteCommandsChild.sys.mjs:152:31\n\n这是因为有一个 &lt;input name=&quot;ie&quot; type=&quot;hidden&quot;&gt; 标签被隐藏了，我们的send_keys 函数（相当于键盘）是没有办法往这个标签里面输入信息的，整个进程也就此退出了。\n3.2.2 Xpath这里对 XPATH 做一个小小的解释\n\nXPath（XML Path Language）是一种用于在 XML 文档中定位元素和节点的语言。它是一种基于树结构的表达式语言，通常用于在 XML 文档中进行导航和搜索操作。XPath 可以帮助您根据元素的层次结构、属性和文本内容来精确定位特定的元素或节点。因为 HTML 可以看做 XML 的一种实现，所以我们可以用 XPath 来定位 HTML 中的元素。\n你可以理解位 Xpath 类似于正则表达式，可以通过特定的表达式来匹配到我们想要的位置。这里只做了解即可，后续有需要再深入学习；\n\n说明  贪多嚼不烂，当时就是为了面试零时抱佛脚学的，既然现在用不到了，那没必要继续记录博客了。\n","categories":["速通Python"],"tags":["Python","selenium"]},{"title":"【网络】CDN/PCDN/SDN 详解","url":"/posts/292924834/","content":"朴实的学习原因：京东实习生招聘条目上写了这些技术，那就给他学了！\n\n\n\n参考https://blog.csdn.net/baidu_41651554/article/details/122218513\n\n嗨嗨嗨，直接上菜！\n1.CDNCDN 的全程是 content delivery network，内容分发网络；说人话就是把网站产生的内容分发到各个用户请求的网络里去，具有 分布式 网络的特点！\n1.1 前置声明  当代网络形势错综复杂，特别是视频、音频类网络服务的兴起，给互联网的贷款造成了很大的压力啊！\n以之前很火的“延禧攻略”为例，当时曾经在某视频 APP 实现了 1 千万用户同时在线观看。如果大家观看的是 1080p 清晰度的视频（理论上需要 4Mbps 带宽），那么，累计需要的流量带宽是 $$10,000,000×4Mbps&#x3D;40,000,000Mbps&#x3D;40Tbps$$ 这个数字老恐怖了！对于优酷、爱奇艺这样的互联网视频内容提供商来说，这无疑是非常巨大的流量压力。\n如果按服务器用的 10Gbps 的万兆网卡来算，那也需要四千块万兆网卡才能顶得住这么大的流量消耗，更别提压根没有那么多地方给你插这么多网卡的事情了；\n有这么一个说法：当用户打开一个页面，等待超过 4 秒，他就会关闭这个页面。也就是说，这个用户就会流失。用户流失对于公司来说可就是金钱流失！\n所以，没有任何一家互联网服务提供商原因因为网络的问题而流失客户，那么我们就得像个办法来解决这种流量短时间暴发的问题！\n而 CDN，就是一项非常有效的  缩短时延  的技术。\n1.2 技术主体CDN 缩短用户延时的办法也非常“简单”，其实就是将云服务部署到用户身边。在访问的时候，根据 DNS 的多线解析能力（即为不同地区提供不同的 IP 解析）选择离用户最近的服务器来为用户提供服务。\n\n因为这样，CDN 就在内容层面上进行了一定的筛选和分发，所以他就叫内容分发网络；\n具体来说，CDN 就是采用更多的缓存服务器（CDN 边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓）\n大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而 CDN，是部分内容的缓存，智能程度更高。\n确切地说，CDN&#x3D; 更智能的镜像 + 缓存 + 流量导流\n而且还需要注意的是，CDN 并不是只能缓存视频内容，它还可以对网站的静态资源（例如各类型图片、html、css、js 等）进行分发，对移动应用 APP 的静态内容（例如安装包 apk 文件、APP 内的图片视频等）进行分发。\nCDN 的具体工作流程。举个例子，如果某个用户想要访问优酷的视频点播内容，那么：\n\n具体步骤如下\n\n当用户点击对应资源内容，应用根据域名地址到底层触发 DNS 请求；\n先是请求的本地运营商的 DNS，再转发到 CDN 域名服务的 DNS；\nCDN 域名服务的 DNS 会将 CDN 的  全局均衡负载服务器  的 IP 地址返回给用户；\n用户向 CDN 的负载均衡设备发起 URL 的访问请求；\nCDN 的负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域（离用户越近越好）的  缓存服务器；\n负载均衡设备告诉用户这台缓存服务器的 IP 地址，让用户向所选择的缓存服务器发起请求；\n用户向缓存服务器发起请求，缓存服务器响应，将用户请求内容发送给用户\n如果这台服务器上没有用户想要的内容，那就根据 CDN 设置的  回源服务器（又称源站）来请求该 URL\n缓存服务器从  源站  拉取内容缓存到本地，并传输给用户；并根据用户设置的缓存策略来判断是否需要保留该资源到本地，是则进行缓存。\n\n在 CDN 工作的整个流程中，源站的服务器 IP 是对用户不可见的；CDN 服务在实现了一定的资源访问加速的基础上，还附带了隐藏源站 IP 的功能，避免源站直接遭受火力打击（指服务器被攻击）\n1.3 静态加速  所谓静态加速，是只加速源站所提供服务中的静态资源，包括 js、html、css、图片、音视频等不会出现变动的资源文件。将这些资源在 CDN 云服务器内进行缓存，用户访问静态资源的时候从 CDN 传输给用户，访问 asp、php、jsp 等动态资源的时候，从源站抓取，既保证了数据的及时性，又提高了静态资源的加载速度。\n相比于动态资源文件，静态资源，特别是图片，是访问过程中消耗流量较大的部分；使用静态资源加速能大大减轻源站的网络贷款和资源负载的压力，又减少了用户的加载速度，使得网络服务能更快的展现在用户面前；\n1.4 动态加速  动态加速是指 CDN 的 DNS 解析中通过动态链路探测，监控网络环境的变化，监控各地网络延迟，寻找到一条最  稳定、最高效、最快速  的路径，回源动态资源，从而实现动态资源（如 asp、php、jsp 等）加速。然后构成链路列表，绑定到 DNS 解析上，更新到 CDN 的本地域名服务器上。简单架构见下图所示。\n\n1.5 数据节点的更新和同步cdn 分为推拉两种方式\n\n推是服务器将内容推到 cdn 节点上\n拉是 cdn 在第一次接受请求的时候从服务器拉取资源进行响应并保存\n\n当资源在 cdn 缓存之后，如果服务器上的资源发生变化，cdn 节点是不会知道的，除非缓存时间到期重新拉取或者修改新资源的访问。\n动态资源的话，一般都是无延迟的。静态对于 css 和 js 来说，建议在编译生成的阶段，为文件名加上时间戳。而且最好是在文件名里面，而不是 querystring 里面加。这是最方便的方案，因为一旦发生了更新，每次去取的一定是新文件，不涉及缓存刷新的问题。\n1.6 CDN 的好处 1.6.1 对服务商 采用 CDN 技术，最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。\n而且，分发至不同线路的缓存服务器，也让  跨运营商  之间的访问得以加速。例如中国移动手机用户访问中国电信网络的内容源，可以通过在中国移动假设 CDN 服务器，进行加速。效果是非常明显的。\n此外，CDN 还有安全方面的好处。内容进行分发后，源服务器的 IP 被隐藏，受到攻击的概率会大幅下降。而且，当某个服务器故障时，系统会调用临近的健康服务器，进行服务，避免对用户造成影响。\n正因为 CDN 的好处很多，所以，目前所有主流的互联网服务提供商，都采用了 CDN 技术。所有的云服务提供商，也都提供了 CDN 服务（价格，按流量计费）\n1.6.2 对通信行业\n互联网服务提供商  采用 CDN，是以存储换时延。花钱购置 CDN 服务器或云计算服务，以此换取更好的用户体验。\n通信运营商  也追捧 CDN，但它们的目的，是以存储换带宽 ——通过服务“下沉”，减轻上层骨干网络的流量压力，避免硬件扩容，降低网络建设成本。\n\n以上文提到的爱奇艺看视频的高带宽问题为例，如果不采用 CDN，那就是巨大的流量流入同一个机房，这会导致这个机房入网 &#x2F; 出网的线路被拥塞，影响其他业务的进行！\n同样的，如果大量的业务流量数据在骨干网跑来跑去，骨干网肯定吃不消，要拼命扩容。如果这些业务流量数据在底层就被解决了，那么，骨干网的带宽压力自然就减轻了。\n很多运营商已经将 CDN 下沉到地市级，以此减轻压力，同时可以提升用户体验！可谓是一举两得的美事！\n\n2.PCDNPCDN 技术是 P2P 技术 +CDN 技术的集和，在认识 PCDN 之前，我们首先要简单了解一下 P2P 技术\n2.1 P2PP2P 即Peer to Peer，是一种对等连接方式，纯 P2P 架构包含如下内容\n\n没有总是在线的服务器\n任意端之间直接通信\n对等方之间可以间断链接，并可以动态改变 IP 地址\n\n实际的用例如下\n\n文件分发（BT 下载）\n流媒体\nVolP\n内网穿透式访问（建立 P2P 链接，直接和内网主机通信）\n\n\n关于 P2P 想了解更多信息可以查看此文：详解 P2P 技术\n2.2 PCDN2.2.1 流程  前面提到了，PCDN 是 P2P+CDN，那么其是如何将 P2P 技术和 CDN 结合起来的呢？\n在阿里云官网上可以看到对 PCDN 的介绍：一篇文章解读提速、降费黑科技：PCDN 定义、功能、架构、场景和优势；本文是对这篇文章的个人理解。\n\nPCDN 产品是与传统 CDN 互补协作的关系，以 P2P 技术为核心的分布式 PCDN 系统可与传统 CDN、云 CDN 无缝集成，形成互补协作，相对于 CDN 拥有成本更低、质量更好两方面的核心优势。\n\nP2P 内容分发网络（英文名：P2P CDN，以下简称 PCDN）是以 P2P 技术为基础，通过挖掘利用边缘网络海量碎片化闲置资源而构建的低成本高品质内容分发网络服务。你可以通过集成 PCDN SDK（以下简称 SDK）接入该服务后能获得等同（或略高于）CDN 的分发质量，同时显著降低分发成本。适用于  视频点播、直播、大文件下载  等业务场景。\n使用 PCDN 后的 http 请求处理流程如下图：\n\nP2P 的加入，就是将一些数据  预先留存在部分终端设备（比如家用路由器，个人电脑，个人 NAS）等产品上，再通过 P2P 技术，从这些 Peer 做种端获取到一部分数据，以此为周边用户提供服务。\n使用 PCDN 的 SDK 后，在请求 DNS 之后，还会去请求 PCDN 的调度系统，PCDN 同时会返回可用的 CDN 服务器，和可用的 P2P 做种端，用户能同时从 多端  获取到数据（根据文件分块，从不同地方获取同一文件不同分块的数据，提高文件下载速度）\n比如一个文件有 1MB，那么使用 PCDN，我们可能服务商的从 CDN 服务器 拉取了 500KB，再从上图中所示的两个 peerid 端获取到了 500KB 数据；\n因为 p2p 使用的是个人的 peer 终端节点，不仅数量多，且分布比 CDN 服务器更广 ，理论上来说至少能获得 等同于  仅使用 CDN 技术的速度优势，如果用户可以连接到的 peer 较多，则速度就会  大于  仅使用 CDN 技术！\n而这些作为 peer 的做种端，会定期从 CDN 缓存一部分热门数据到本地，并为其他与自己建立 P2P 链接的终端提供服务。\n\n京东云路由器、迅雷的网心云、百度云盘 PC 客户端的闲时带宽上传，其实都是使用了 PCDN 技术的终端产品，其会在占用一小部分用户带宽的基础上，给用户提供京豆 &#x2F; 现金奖励；但是 PCDN 似乎和运营商的政策冲突，具体的就不了解了，本文只是来学习技术的。\n\n2.2.2 优点  以下优点来自阿里云那篇文章\n\n价格低：通过 P2P 技术可为客户提供更低成本的内容分发服务，（以峰值带宽计价）为云 CDN 价格的 1&#x2F;2，为传统 CDN 价格的 1&#x2F;4，可显著降低客户的分发成本；\n因为使用了更多 P2P 节点，减轻了 CDN 服务器、源站服务器的网络带宽压力，所以 PCDN 能在一定程度上起到降本增效的作用。\n\n质量好：通过 CDN+P2P 多级节点调度，一个请求可由 CDN 和多个 P2P 源同时提供内容，通过资源冗余提高了服务可用性，播放流畅率高于纯 CDN，在大文件下载场景中更是能极大提高下载速度；通过调用海量分布式 P2P 节点， 平均播放流畅率 &gt; 97%，平均首播时间小于 1 秒，用户体验得到有效提升。\n\n成熟稳定：多年为优酷土豆提供优质的视频播放、下载等加速服务，接入带宽超 10T，经历了海量用户规模的  长时间验证。拥有内网穿透、缓存处理、种子管理、传输策略等各方面的核心技术和专利；（这是阿里云给自己打的广告）\n\n\n\n2.3 常见名词  以下是 PCDN 中常见的名词；这里面漏了的一级节点指的应该是 CDN 服务器；\n\n由此可见，上文提到的京东云路由器、迅雷的网心云，这些客户端在用户的电脑启动后，其就是作为 PCDN 的  三级节点  接入整个 PCDN 的网络的，其提供的也是三级带宽；\n2.4 基础架构  关键组件\n\nindex 服务：全局调度，把用户请求调度到最佳的机房\nZooKeeper (Global&amp;Local)：服务活动情况汇报给调度服务，动态配置更新\nNignx Proxy：支持私有协议的 Nginx 代理服务，针对不同文件一致性 Hash 到不同的 Channel 服务\nChannel 服务：记录文件和拥有文件的端点地址信息，为下载提供就近的端点地址\nRealy 服务：服务 P2P 建立连接和通讯\nHot 服务：hot 文件发现和推送\n\n以下是 PCDN 技术的架构图\n\n整个技术的流程在上文已经讲解过了。这里的架构图阿里云的文章并没有提供更多的说明，具体的就得在真正需要开发 PCDN 的时候在公司内部深入学习了。\n2.5 适用范围PCDN 产品适用于视频点播、直播、大文件下载等业务领域。\n\n视频点播：长视频点播，热度集中的短视频点播。\n视频直播：大型晚会赛事直播、地方网台直播、秀场互动直播。\n大文件下载：超过 1MB 且热度集中的的文件分发，如应用市场分发、在线音频分发。\n\n3.SDNSDN 全称 Software Defined Network，概念最早由斯坦福大学的Nick McKeown 教授于 2009 年提出；谷歌于 2010 到 2012 年建立的数据中心网络 B4 是 SDN 的成功案例；\n该技术学习于 b 站【408 计算机网络新增考点—软件定义网络 SDN（字幕版）】\n3.1 看看路由器的功能  路由器具备如下功能\n\n报文转发\n路由选择\n\n在当前的路由器架构中，分为数据层面和控制层面。\n\n为了构建出自己的路由表，路由器必须要和周边的其他路由器定期通信，才能通过自己的路由算法设置出路由表，并选择正确的路由路径（这个耗时较长）\n在数据层面，路由器采用硬件，查表进行转发（耗时低）\n\n\n\n分组  是网络专有名词。大多数  计算机网络  都不能连续地传送任意长的数据，所以实际上网络系统把  数据分割  成小块，然后逐块地发送，这种小块就称作分组（packet）。也有些书籍把分组定义为网络层的  协议数据单元。\n说白了分组就是一个报文！\n\n3.2 SDN 核心思想\nSDN 这种新型  网络体系结构  的核心思想，是将网络的控制层和数据层面玻璃，让控制层可以通过软件来控制数据层的较多设备\n\n在 SDN 体系中，路由器的路由软件被剥离开，路由器之间也不再需要交换路由信息。\n\n控制层面：有一个逻辑上集中的远程控制器，对多个交换机进行控制；该远程控制器可以由多台物理主机组成\n\n远程控制器会掌握各个主机和整个网络体系的状态，并为每一个路由分组计算出最佳的路由，和生成正确的转发表；这时候，底层的路由器硬件就仅仅需要进行查表转发，而不需要进行耗时的路由表生产和算法计算了，大大减轻了底层交换机和路由器硬件的压力。\n\n3.3 OpenFlow 协议OpenFlow 协议是一个受到高度认可的标准，其一般在 SDN 中进行使用，但 SDN 并不一定要用 OpenFlow；\n\nOpenFlow 协议由  开放网络基金会 ONF负责指定，该基金会致力于 SDN 的发展和标准化；OpenFlow 协议目前较为成熟的是 1.3 版本\n\nOpenFlow 协议是 SDN 体系结构中，控制层面和数据层面之间的通信接口，该协议可以允许控制层面的控制器对数据层面的物理设备进行直接的访问和控制。\n\n3.4 路由转发的区别 3.4.1 传统路由表 传统的路由转发是查询路由表，根据地址掩码计算目的网络，判断是否与当前条目匹配，如果匹配，则从对应的「下一条」中发送出去。\n路由转发这部分内容在我的 IP 协议详解博客中有所涉及：点我\n\n3.4.2 SDN 广义转发 SDN 在这基础上新增了更多的内容，称为 广义转发：\n\n进行匹配：能够对网络体系结构中的各层（数据链路层，网络层，传输层）首部中的字段进行匹配\n执行动作：不仅转发分组，还可以实现负载均衡、重写 IP 首部（类似 NAT 中的路由地址转换）、人为阻挡或丢弃一些分组（类似防火墙）\n\n在 SDN 广义转发中，完成这一操作的设备不再称为路由器，而是叫做 OpenFlow 交换机（或分组交换机），也可以简称为交换机。\n3.4.3 流表  在 SDN 中替代 了传统路由表的是「流表（Flow Table）」\n\n一个流就是整个网络中的一组分组序列，在此序列中的每个分组都是  共享分组首部某些字段的值，例如，某个流可以是共享相同的源 IP 和目的 IP 地址的一连串分组\nOpenFlow 交换机中的刘表是由 SDN 远程控制器来管理的，SDN 远程控制器通过一个安全信道，通过 OpenFlow 协议来管理 OpenFlow 交换机中的流表\n\n\n\n每个 OpenFlow 交换机必须有一个或者多个流表\n每一个流表包含多个流表项目\n每个流表项包含三个字段：首部字段值（匹配字段）、计数器、动作（类似下一跳）\n\nOpenFlow 的首部字段值跨越了三个层次的首部，既可以处理数据链路层的 MAC 帧，又可以处理 IP 报文，或者是 TCP&#x2F;UDP 的端口\n\n计数器字段包含一组计数器\n\n记录已经与该流表项匹配的分组数量的计数器；\n记录该流表项上次更新到现在经历的时间的计数器\n\n动作字段是一族动作，当分组匹配到某个流表项时，执行下方的一个或者多个动作\n\n把分组转发到指定的端口\n丢弃分组\n把分组进行复制后，从多个端口转发出去\n重写分组中的首部字段\n\n3.4.4 VLAN\n关于该报文中 VLAN 部分可以查看此博客：https://blog.csdn.net/LawssssCat/article/details/127204720\n\nVLAN 是一种用于进一步虚拟化划分局域网的方式，假如一台路由器有 4 个网口，其可以通过将 LAN1 和 LAN2 设置成 VLAN10，LAN3 和 LAN4 设置成 VLAN20 来模拟出两个局域网\n\nvlan（virtual lan）技术提供了一种灵活的解决方案；将交换机的接口根据业务需要添加到不同的 vlan 中，从而实现二层隔离。\n\n隔离广播域，即广播包只在本 vlan 中传播，从而在一定程度上可以提高整个网络的处理能力；\n提高安全性，一个 vlan 内的用户和其他 vlan 内的用户不能互访，提高了网络的安全性；\n增加带宽利用 &#x2F; 降低延迟 &#x2F; 管理作用\n\n3.5 举例 3.5.1 简单转发 通过不同的流表项来设置转发路径和转发动作，动作中的  转发 (3) 代表从该交换机的 3 号端口转发出去。端口号在图中有标注；\n\n3.5.2 负载均衡  第二个栗子是负载均衡的栗子，在下面的场景中，我们想要 H3 发送的分组通过S2-S1-S3-H5/H6，要 H4 发送的分组通过S2-S3-H5/H6；以达到负载均衡的目的。\n\n使用传统的源 IP 和目的 IP 的转发方式，无法实现这样的负载均衡。在传统场景下，当 S2 在数据链路层发现目的 MAC 地址是 S3 的 MAC 地址的时候，无论如何都会直接发送给 S3，而不是从 S1 处绕路。\n但在 SDN 场景中，就可以通过两个不同的流表项来规定不同转发动作，实现这样的负载均衡（这里的  转发 (4) 代表从 S2 的 4 号端口转发出去）\n\n3.5.3 防火墙  如果我们想让 S2 主机只接收来自 S1 的数据而不接受 S3 的数据，就可以通过只设置 S1 的源 IP 地址的流表项，来丢弃 S3 发送的数据（匹配不上的数据就会被丢弃）\n\n3.6 SDN 体系结构的特征  下图中包含了 SDN 的体系结构一览图和 SDN 的四个关键特征\n\n基于流的转发\n数据层面与控制层面分离\n位于数据层面分组交换机之外的网络控制功能\n可编程的网络\n\n其中，SDN 控制器是这个架构中最复杂的设备，其通过南向 API 控制底层的 OpenFlow 交换机，通过北向 API 接受其他网络控制器的策略配置。\n\n3.6.1 SDN 控制器SDN 控制器可以分成三个层次\n\n其通信层通过 OpenFlow 协议与交换机通信\n中间间来根据各种策略管理各个交换机\n北向 API 接收来自其他控制策略发起端的配置\n\n\n这里使用的 RESTful API  是基于 HTTP 的 API，也是我们较常见的 API 接口；\n3.6.2 开源 SDN 控制器  常用的开源 SDN 控制器有 OPEN DAYLIGHT 和 ONOS；\n3.6.3 SDN 的优势\n原文链接：https://blog.csdn.net/as12138/article/details/131273381\n\nSDN 相比于传统网络架构，有许多优点和优势。\n\n高度可编程性：SDN 架构中的控制器负责管理交换机和路由器，使得网络更加可编程、可配置。管理员可以通过控制器实现灵活调整网络拓扑、管理流量和配置流调度策略，提升网络的可演变性、可定制化和可伸缩性。\n\n网络智能集中化：在 SDN 中，网络智能被集中在控制器中，通过控制器进行集中式管理和控制。这种分离的模式避免了网络设备中任务的复杂，提升了网络的可管理性和可控制性。此外，集中化的管理方式也可以在网络中间件和应用中实现智能控制，如分布式存储、云计算等。\n\n可扩展性：SDN 中的网络设备是通用的硬件设备，不需要特定的功能区分，同时也不需要更新硬件，只需更新控制器即可实现拓扑可伸缩和灵活的网络管理。\n\n自动化和提高效率：SDN 中可以实现网络的自动化，通过控制器进行自动化的网络管理，可以避免手动管理网络的局限性和不确定性，从而提高网络的效率和稳定性，同时，自动化网络管理也可以降低网络维护的成本和时间。\n\n安全可靠性提升：网络安全和可靠性是企业网络中最基本的需求。传统的网络安全往往需要通过一些特定设备和协议来实现。相比之下，SDN 中的控制器可以根据网络实时状态自动优化管理策略，安全可靠的方式来提高网络的安全性。\n\n\n总之，SDN 的优势在于其灵活的可编程性、集中式智能管理、高效的自动化网络管理和增强网络安全性。以上优势也是 SDN 技术应用广泛的主要原因，越来越多的企业和组织将 SDN 技术应用到自己的网络架构中，以满足未来网络的需求和挑战。\n3.6.4 SDN 应用前景SDN 技术目前已经实现了基础网络配置、流控制、网络安全等功能。在未来，SDN 技术还会面临更多的挑战和机遇。\n\n5G 时代：5G 技术将会改变网络的面貌，加速物联网应用的普及。SDN 作为架构灵活、可编程的网络方式，将会在 5G 网络中发挥重要作用，实现网络的自动化和智能化管理。\n\nIoT 设备：物联网技术带来大量设备的连接，SDN 技术的价值在于自动化了物联网设备的管理、安全和监控。未来，SDN 技术将会成为物联网管理的重要工具。\n\nAI：随着人工智能的发展，SDN 的业界应用已经开始大规模落地。这将加速智能交通、智能城市和自动驾驶等领域的发展。\n\n集成新技术：SDN 可以很容易地与其他技术相结合，例如 NFV（网络功能虚拟化）和 AI（人工智能），以提高网络的效率和适应性。\n\n云计算：SDN 技术的灵活性和可编程性，也使得 SDN 与云计算等新技术的结合变得更加自然。在未来，SDN 技术将与云技术紧密结合，实现业务流程的自动化、快速应用部署和弹性云资源管理。\n\n\n总而言之，SDN 技术将为未来网络的发展和实现各种应用提供支撑。在日益增长的网络需求和复杂的网络技术背景下，SDN 的灵活性和高可用性将会带来更大的发展空间和市场需求。SDN 技术应当继续研究和发展，以满足更多的网络需求和挑战。\n3.7 总结\n","categories":["差生文具多"],"tags":["CDN","SDN","P2P"]},{"title":"【VMware】VMware 安装 CentOS8-Stream 虚拟机","url":"/posts/3903366745/","content":"VMware 安装 CentOS8-Stream 虚拟机\n\n\n1. 安装 VMware由于最新版的 vm 要钱，这里提供一个VMware16pro 的安装包；我知道度盘下载速度慢，但确实没啥其他选择，见谅。\n\n后文将用 vm 来简称 VMware\n\n提取嘛: gdt9  亚索包解押: 8888\n\n下载安装包后，右键以管理员身份运行 ，在弹出的提示框中选择 是\n\n在第一个选择框，点击下一步\n\n第二个界面，勾选接受协议中条款，继续下一步；\n第三个页面见下图，此页将控制台工具  添加到系统 PATH必须要勾选，安装位置自行选择\n\n备注：我保留的是默认的 C 盘安装路径没有改动，所以修改到其他盘是否会印发其他问题，暂且不知。如果你的 C 盘空间足够，就安在 C 盘吧！这里的安装路径是 vmware 软件的安装路径，不是虚拟机的安装路径，所以不需要担心会占用很多空间\n\n\n将检查产品更新和加入体验计划的钩都去掉，下一步\n\n快捷方式默认就行，后续你可以自己改。这个想必都会吧！\n此页点击下一步后，点击安装，等待安装完成。\n\n安装完成后，会出现如下页面，点击  许可证，填入许可证密钥。\n许可证密钥你可以百度，搜索 vmware pro 16 的密钥就可以了，有很多都可以用的，我分享的压缩包里面就有一个许可证码，填那个就行了。\n网上有很多密钥，我这里贴几个，都是 vmware pro 16 的。\nZF3R0-FHED2-M80TY-8QYGC-NPKYF  YF390-0HF8P-M81RQ-2DXQE-M2UT6  ZF71R-DMX85-08DQY-8YMNC-PPHV8  110L3-9135J-M807A-08ARK-84V7L  FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA  CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD\n\n\n这一步操作完毕后，点击完成，虚拟机软件 vmware 就安装成功了。\n2. 下载 centos8 系统 iso 镜像  可以去两个地方下载，推荐跟随本文的操作用阿里云的镜像\n\ncentos 官网：https://www.centos.org/download/\n阿里云镜像：http://mirrors.aliyun.com/centos/8-stream/isos/x86_64/\n\n本文安装的是 centos8-stream 的 iso，本站所写的绝大部分 linux 博客，都兼容这个系统上的操作！这里我选择的是图中箭头所指的 CentOS-Stream-8-x86_64-latest-boot.iso 镜像。\n为了避免后续的其他操作和本文不符，这里顺便也把 iso 镜像给上传了一个  直接去阿里云官网下载就可以了，应该大差不差，百度云的速度还是太慢了 https://pan.baidu.com/s/1jleRo4mxILq2RwSU-rxaaA  提取嘛: t7ay\n\n\n这里我直接贴出上图中箭头所指的 iso 镜像阿里云下载链接\nhttp://mirrors.aliyun.com/centos/8-stream/isos/x86_64/CentOS-Stream-8-x86_64-latest-boot.iso?spm=a2c6h.25603864.0.0.59013584oRJVrF\n\n3. 安装 Centos3.1 创建虚拟机  先在你电脑硬盘的其他位置，创建一个空目录\n\n打开 vm 软件主界面，点击创建新虚拟机\n\n自定义\n\n这里保持默认的，不需要修改\n\niso 选择iso 选择刚刚下载的 centos8-stream 虚拟机\n\n操作系统  操作系统选择 linux 和 centos8\n\n安装盘  选择刚刚创建的空文件夹（这里是虚拟机文件的安装路径，所以建议选择你电脑上  比较空的那个盘，来创建文件夹）\n\n核数选择  核数请根据你的 CPU 来选择，比如我的笔记本 CPU 是 8 核 16 线程的（ctrl+alt+delete打开你电脑的  任务管理器  来查看）\n\n这里我选择了 4 核，内核数量选择 2\n\n注意，这里需要和你电脑的 CPU 匹配，8 核 16 线程就代表每个处理器内核有 2 个，所以就应该选择 2。如果是 intel 新的大小核设计的 CPU，也可以选择 2。部分老款的 CPU 是 1 核只有 1 线程的那种 (比如 n5105 是 4 核 4 线程的)\n\n\n内存  根据你电脑的内存选择，建议选择低于总  内存  一半的\n比如电脑是 16G，建议只选到 8G，否则虚拟机运行占用太多内存，容易弄得笔记本也卡卡的，干不了啥其他事情。\n\n这里还需要纠正小白的一部分错误认识，内存是指运行内存 ，不是你电脑的硬盘容量！！！右键你电脑桌面上的 此电脑 ，点击 属性，就能看到你电脑有多少内存。\n\n\nCentOS8 本身占用内存并不多，但如果你想深入学习 linux 的编程操作，后续可能会用到 vscode 远程连接虚拟机，这时候内存太低就容易卡卡卡。所以建议  至少选择 2GB\n现在的电脑都是 8G 内存打底了，主流价位的笔记本也普及了 16GB，所以大家笔记本运行虚拟机都是没问题的。\n\n网络  选择桥接\n\nIO 和磁盘  选择推荐的，不用修改\n\n磁盘类型选择 vm 推荐的就行（不同电脑推荐的可能不一样）\n\n\n磁盘最少选择 20GB，根据自己电脑硬盘容量自行选择。选择的硬盘容量并不会立马占满，而是随着使用时长慢慢增加的；\n虚拟磁盘勾选  单个文件\n\n磁盘文件名字不用修改\n完成  看看有没有设置错误的，点击完成即可\n\n点击开启虚拟机，即启动了 centos\n3.2 初始化 CentOS8点击虚拟机的屏幕，使用  键盘  方向键选第一个 install\n\n会弹出一大堆文字，等待其跑完安装进程，会到下面的界面\n语言  可以选择语言为中文，但为了方便后续和其他工具的学习接轨（大部分工具都没有中文），依旧推荐选择英语！而且这在系统里面是可以改的，问题不大\n\n网络配置  点击网络\n\n点击左上角按钮为 ON 打开连接，将 hostName 修改为下图所示，apply后点击左上角的Done\n\n时区  我们是东八区，得选择对应时区为 Asia/Shanghai，即上海市的时区。\n\n这里还可以选择 ntp 授时服务器（就是一个用来广播当前时间的服务器）点击 help 下面的那个齿轮，我们可以选择一个在国内的服务器，方便接收到时间更新\ncn.pool.ntp.org\n\n\n软件选择  随后选择software selection，这里是选择安装的软件和系统的操作方式的。\n由于 linux 大部分时间我们都是学习的命令行操作 ，命令行安装方式对主机的负载也更小，这里选择server 即可；右侧的都不勾选。\n选好后点左上角 done\n\nroot 密码  接着再点击 root password 设置，默认 root 账户是被关闭的，这对我们学习不利。设置密码方便后续连接！\n\n依照顺序，上述操作完毕后，右下角的 installation 就不是灰色的了，而可以点击\n\n如果出现 installation destination是红的，点进去然后退出就 ok\n\n\n点击后等待其安装完毕！耐心等待，耗时挺久的。\n\n这里还会下载一些系统的内容，我选择的是没有 gui 的server，所以只需要下 720MB 即可，带 gui 的肯定更大\n\n完成  点右下角重启系统\n\n3.3 启动  这里选择第一个（长时间不选会自己开始）\n\n出现如下页面后，填入用户名 root 和刚刚初始化界面设置的密码，就成功登录了！\n\n需要注意的是，在 Linux 中，输入密码的操作是不会有任何回显的，所以你需要盲打。只要密码是对的，就一定能成功。\n4.ssh 连接  先下载 ssh 连接软件，如 tabby、xshell、putty 等；推荐使用开源的 tabby，这里贴出 tabby 的下载地址：\nhttps://github.com/Eugeny/tabby/releases\n4.1 安装并启动 sshd先在虚拟机里面操作，下载 ssh 服务端软件\nyum install -y openssh-server\n\n当前使用的 CentOS8 系统已经自带了这个软件\n\n启动 sshd\nsystemctl start sshd\n\n4.2 查看 ipifconfig\n\n使用这个命令，能看到当前虚拟机的 ip 为192.168.6.172\n\n4.3 ssh 连接  以 tabby 为例，点击设置，配置与连接，新配置\n\n选择 ssh 连接\n\n填入刚刚看到的 ip，端口 22 默认不需要动，用户名 root\n\n创建完毕后，在配置与链接页面，点击启动键（就和视频的播放键一样的按钮）开始连接\n\n会出现如下让你输入密码的页面，在这里填入 root 的密码，并勾选 remember 记住密码\n\n主机密钥校验  是每次 ssh 第一次连接新主机时都会出现的，勾选  接受并记住  就可以了；\n\n到这里就成功连上虚拟机里面的 linux 了。日常使用，也更推荐在 ssh 软件上操作，而不是 vm 的虚拟机界面里面操作 linux 命令行。\n\n这样 vm 的窗口就可以收起来，让虚拟机在后台运行了！\n\nOver！大功告成，一个 linux 学习环境就搭建好啦。\n顺带看看下面的内容吧\n\ncentos8 安装 python3.10 https://blog.musnow.top/posts/847195816/\ncentos7 云服务器学习环境初始化 https://blog.musnow.top/posts/656771008/\n\n","categories":["玩上Linux"],"tags":["Linux","centos","虚拟机"]},{"title":"【VMware】VM 中虚拟机设置的处理器数量和每个处理器内核数量到底是什么？","url":"/posts/3252027724/","content":"\n原出处：VMWare 中的处理器数量和每个处理器的内核数量概念及查询方法\n慕雪对原文进行了一定修改和细化\n\n一、概念：当我们使用 vm 来创建虚拟机的时候，一定会经历下面的选项。那就是给虚拟机配置分配的 cpu 核心数量。但 vm 这里的说法和我们日常生活中对 CPU 的 X 核 X 线程 的说法并不统一。就容易混淆一些概念。\n\n先来说说这里三个选项的含义吧\n\n处理器数量 ：虚拟的 CPU 颗数。\n每个处理器的内核数量：虚拟的 CPU 内核数。\n处理器内核总数：处理器内核总数 &#x3D; 处理器数量 * 每个处理器的内核数量。\n\n处理器内核总数 对应的是 物理 CPU 的线程数（逻辑处理器数量）。 \n所以配置虚拟机时，我们只需要关心 CPU 实际的线程数 是多少就行了，即配置的 处理器内核总数 &lt; CPU 实际的线程数 就行了。\n注：我们电脑上的一个 CPU，一般都会有多个内核（单核 &#x2F; 双核 &#x2F; 四核 &#x2F; 六核 &#x2F; 八核 &#x2F; 十六核），而一个内核一般对应一个线程。但通过 Intel 的  超线程技术，一个核心可以对应两个线程，即可以同时运行两个线程，并行处理两个任务。\n大小核怎么办？不过，现在的新 intel cpu 又出现了  大小核  的说法。不过这并不影响我们来判断到底应该怎么配置。比如下图是  不带  大小核设计的 8 代 i7 CPU 在官网上的详细参数\n\n而下图是最新的带大小核的 13 代 i9 在官网上的详细参数\n\n我们可以看到，即便新的出现了性能核（大核）、能效核（小核）这样的设计，但其依旧没有脱离内核数和线程数这两个参数。\n我们依旧可以依照传统的办法，通过  线程数  来判断应该给虚拟机的 CPU 上的配置\n虚拟机的处理器内核总数 &lt; 实际 CPU 的线程数\n\n而 AMD 的 Cpu 暂时还没有出现大小核的设计，也是按照这个办法进行 VM 虚拟机的配置就 OK 了！\n二、查看电脑配置参数方法：1、网上查询对应的 CPU 参数，一般可以去官网查询得到\n\nintel 产品规范\namd 官网\n\n\n\n2、打开 windows 的任务管理器，先  展开视图，再找到“性能”界面。\n\n内核：即 CPU 核心数。\n逻辑处理器：即线程数。\n\n\n\n3、右键 “我的电脑”–“管理”–“设备管理器”\n“处理器”项下面显示几条记录即代表有几个逻辑处理器（线程数）。\n\n\n三、配置论证参考  知道了自己的 CPU 线程数，就可以来验证一下我们的理论是否正确了\n虚拟机的处理器内核总数 &lt; 实际 CPU 的线程数\n\n实际硬件参数： 6 核 12 线程\n配置成功\n\n\n\n配置失败\n\n\n\n四、linux 查看 cpu 核心数 &#x2F; 线程数  我使用下图的配置了一个 deepin 的虚拟机\n\n进了虚拟机，打开终端后，可以用下方的几个命令来查询你的 cpu 数量是否和上文所述一致\n# 查看 cpu 核心数# 对应 vm 处理器数量cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l# 查看每个 cpu 的内核数量# 对应 vm 每个处理器的内核数量cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq# 查看线程数# 对应 vm 的处理器内核总数cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l\n\n可以看到，在 deepin 里面执行这些命令的结果和预期完全一致！是 4 核心 8 线程的系统！\n$ cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l4$ cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniqcpu cores       : 2$ cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l8\n\n总结  根据上面的操作，可以确定，只要你配置的  处理器内核总数  小于你 CPU 的实际线程数，就不会出现问题。但一般情况下，我们还是遵循最常用的  一个核心两个线程  配置，将每个  处理器的内核数量  设置为 2，再去对应设置  处理器数量，比如\n\n处理器数量 2，每个处理器的内核数量 2（2 核 4 线程）\n处理器数量 4，每个处理器的内核数量 2（4 核 8 线程）\n处理器数量 6，每个处理器的内核数量 2（6 核 12 线程）\n以此类推\n\n处理器数量最好设置为 2 的倍数，毕竟你也没听说过 3 核和 5 核的 CPU 吧？😂不过 vm 似乎也不允许选择奇数。\n在我的使用场景中，vm 是用来装 linux 进行学习和开发的。对于不带 GUI 的 linux 来说，2 核 4 线程都是杠杠的了。更吃紧的还是内存！如果是不带 GUI 的 linux，建议 2G 起步，4G 往上足够用。\n需要注意的是，如果你和我一样，需要用 vscode 的 remote-ssh 功能连接 linux 进行代码编写，那最好是 4G 内存起步！（2G 实测有点卡，1G 根本没法用）\n","categories":["玩上Linux"],"tags":["Linux","deepin","虚拟机"]},{"title":"【VMware】ssh 连接 deepin 虚拟机","url":"/posts/1211975221/","content":"ssh 连接 linux 虚拟机，以 deepin20.3 为例\n\n\n\n1.VMWare 虚拟网卡配置VMWare 虚拟机常用的网络链接方式有下面这 3 种\n\n桥接（最方便）\nnat（需要设置端口映射）\n仅主机（无法联网）\n\n在我的测试中，不管用上面哪种方式安装，都是  可以直接查询 IP 后，进行 ssh 连接的。\n需要注意是，如果你所在的环境没有你可以直接管理的路由器（比如校园网）那就不要选择桥接模式，不然你的 Linux 虚拟机可能因为没有登陆校园网而无法上网；这时候建议选择 NAT 模式！\n\n桥接模式：以当前主机为桥，直接接入上级路由器；此时虚拟机会作为一个普通设备接入局域网，可以被局域网内的其他电脑直接访问；\nNAT 模式：借用当前主机的端口进行互联网访问，此时虚拟机并没有直接接入局域网，如果其他局域网内设备想访问虚拟机，必须设置端口映射；当前主机可以正常通过虚拟机的 IP 访问到虚拟机。\n仅主机模式：只有当前主机能访问到虚拟机，且该虚拟机无法上网；\n\n如下便是我安装（创建）虚拟机时，选择桥接网络的截图。\n\n顺带提一嘴，安装 deepin 虚拟机的时候，环境选择 ubuntu 64 位 就可以了，并不需要去搜 deepin 基于 debain 的版本号（而且我也没搜到）\n2. 安装 openssh在 虚拟机 中执行：\nsudo apt install openssh-client openssh-server\nsudo /etc/init.d/ssh restart\n\n我安装的是deepin20.3，自带了这两个软件包，所以只需要执行重启一下 ssh，保证服务正常就行了\n$ sudo apt install openssh-client openssh-server请输入密码:验证成功  正在读取软件包列表... 完成  正在分析软件包的依赖关系树       正在读取状态信息... 完成       openssh-client 已经是最新版 (1:7.9p1.10-deepin1)。openssh-server 已经是最新版 (1:7.9p1.10-deepin1)。升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。\n\n而在 centos8 中，openssh-server也是自带了，不需要安装，启动就行了\nsystemctl start sshd\n\n3. 查询虚拟机 IP在 Linux 虚拟机 中执行：\nifconfig\n\n找到 ens33 下的 IPv4 地址，记下来（你的虚拟机里面可能不是 33，这不重要）\n\n4. 设置端口转发\n咳咳，我发现原来 NAT 在虚拟机里面查询到的那个 IP 也是可以直接链接的，所以设置端口转发也是没有必要的🤣！除非你想要让局域网内的其他机器链接到你这个虚拟机里面的服务。\n所以这一步是可以跳过的；不过记录下来，如果你有这个需求就可以根据教程设置一下。\n\n在 VMWare Workstation 中：\n菜单栏 → 编辑 → 虚拟网络编辑器 → VMNet8 -&gt; 更改设置 → NAT 设置 → 添加端口转发\n\n需要提供管理员权限，在弹出的窗口中选确定\n\n确定了管理员权限后，再选择 VMnet8，点击 NAT 设置\n\n点击添加端口转发\n\n\n进入  映射传入端口  界面后，按下面填写\n\n主机端口：是你当前宿主机的本机端口，可以随便填一个；但要保证不要和 windows 已有的本地端口冲突。端口号范围是0~65535，建议选用 5 位数的不常用端口！\n虚拟机 IP 地址：使用 ifconfig 查到的虚拟机 ip\n虚拟机端口：22（ssh 默认端口）\n\n确定，并点击  虚拟网络编辑器  中的  应用（或者确定）按钮；\n5. 开放防火墙  在 deepin 虚拟机 中执行：\nsudo ufw allow ssh\n\n如果 ufw 命令找不到，那就安装一下这个命令\n$ sudo ufw allow sshsudo: ufw：找不到命令\n\n$ sudo apt-get install ufw正在读取软件包列表... 完成  正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列【新】软件包将被安装：  ufw升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 164 kB 的归档。解压缩后会消耗 852 kB 的额外空间。获取:1 https://community-packages.deepin.com/deepin apricot/main amd64 ufw all 0.36-1 [164 kB]已下载 164 kB，耗时 0 秒 (1,316 kB/s)正在预设定软件包 ...正在选中未选择的软件包 ufw。(正在读取数据库 ... 系统当前共安装有 251044 个文件和目录。)准备解压 .../archives/ufw_0.36-1_all.deb  ...正在解压 ufw (0.36-1) ...正在设置 ufw (0.36-1) ...Creating config file /etc/ufw/before.rules with new versionCreating config file /etc/ufw/before6.rules with new versionCreating config file /etc/ufw/after.rules with new versionCreating config file /etc/ufw/after6.rules with new versionCreated symlink /etc/systemd/system/multi-user.target.wants/ufw.service → /lib/systemd/system/ufw.service.正在处理用于 rsyslog (8.1901.0.10-1+dde) 的触发器 ...正在处理用于 man-db (2.8.5-3) 的触发器 ...\n\n再执行一下，显示的结果如下。此时就已经 ok 了\n$ sudo ufw allow sshRules updatedRules updated (v6)\n\n6. 连接测试  这是 ssh 连接的通用格式，默认的 ssh 端口是 22\nssh 用户名 @虚拟机 ip\n\n如果是 nat 端口映射，需要指定 ip，就在后方添加 -p 选择端口；假设你设置了 NAT 虚拟机 22 端口到主机 2222 端口的 NAT 映射，那就可以使用如下命令进行链接，因为映射到了本地，所以 IP 我们可以填 localhost 或者 127.0.0.1 代表本机的本地 IP，二者是等价的\nssh 用户名 @localhost -p 2222ssh 用户名 @127.0.0.1 -p 2222\n\n在 windows 的 cmd 中执行如下命令，就能连上你的虚拟机\nPS C:\\Users\\moth&gt; ssh mothra@192.168.6.113The authenticity of host &#x27;192.168.6.113 (192.168.6.113)&#x27; can&#x27;t be established.ED25519 key fingerprint is SHA256:ZFGdOP9rRgV3SA0V1W3yikrTWDd8V+8sYxTPgyQu5WQ.This key is not known by any other namesAre you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#x27;192.168.6.113&#x27; (ED25519) to the list of known hosts.mothra@192.168.6.113&#x27;s password: 验证成功Welcome to Deepin 20.9 GNU/Linux    * Homepage:https://www.deepin.org/    * Bugreport:https://bbs.deepin.org/mothra@mothra-PC:~$\n\n当然，你也可以选择使用其他 ssh 终端来链接，具体方法根据终端软件百度教程就行了。\n7. 生成 ssh 密钥对（选做）在 宿主机 (Windows) 执行：\nssh-keygen\n\n敲回车直到执行完成（已有公钥可跳过此步）\n在 宿主机 (Windows) 中用 Powershell 执行：\ncat ~/.ssh/id_rsa.pub | ssh 虚拟机用户名 @虚拟机 IP &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot;\n\n命令中的  虚拟机用户名  用你在虚拟机中创建的 linux 用户名替换；\n虚拟机 IP用刚刚第 3 步中查到的虚拟机 IP 替换（刚刚背诵的）；\n输入密码即可！\n\n配置了 ssh 密钥后，无需键入密码即可连接（如果你使用 vscode 来 ssh 链接虚拟机，这点很重要，非常省事）\nssh 虚拟机用户名 @虚拟机 IP\n\n\n参考博客：https://www.cnblogs.com/BinarySong/p/16244415.html\n\n","categories":["玩上Linux"],"tags":["Linux","deepin","虚拟机"]},{"title":"【deepin】deepin 安装新字体","url":"/posts/1504301137/","content":"感觉 deepin 默认的字体并不是很好用，虽然也是等宽字体，但是太细了。不是我喜欢的类型。于是打算给 deepin 整一个个人比较喜欢的 JetBrainsMono 字体\n\n\n下载字体  字体自然是去官网下载，这里就不多说了，丢个链接\nhttps://blog.jetbrains.com/zh-hans/2020/03/08/jetbrains-mono/https://github.com/JetBrains/JetBrainsMono\n\n安装字体  但是让我没想到的是，光是一个安装字体的教程，就能出这么多烂文。什么啊个性化里面可以选择字体，设置里面可以选择字体之类的无关事项（都用带 GUI 的 linux 了肯定会去看看个性化设置啊……还需要你教？）\n找了一小会，总算是找到了一个正常的文章。\ndeepin 里面自带了一个字体管理器，在开始菜单里面搜索  字体  就能出来\n\n先把下载的压缩包里面的 fonts 解压到桌面\n\n进入字体管理器，点击加号，选中 fonts 里面 tff 文件夹内的字体文件，就可以安装了！\n\n\n点击  打开，即安装完毕！\n后续其他软件的字体配置就不写啦！\n","categories":["玩上Linux"],"tags":["Linux","deepin","虚拟机"]},{"title":"【虚拟机】WIN11 的 WSL 安装 CentOS8Stream 虚拟机","url":"/posts/4065446782/","content":"本人所使用的系统是 win11 22H2 家庭版，如果你不是非 CentOS 不可，强烈建议直接去微软应用商店里面下载 Ubuntu，全自动安装到 WSL，啥都不用管。(就是好像没办法选择安装路径)\n1. 启用 WSL刚开始安装 WSL 的时候，参考的是  这个博客。说实话，我个人并不喜欢这篇博客。因为里面遗漏了很多东西，并且在不恰当的位置贴出了命令，导致读者会误以为是需要执行这些命令。\n比如我就理解错误，先执行了设置 wsl 默认版本为 2 的命令，这个命令先不要执行！后文会告诉你为什么。\n这篇博客中对开启 wsl 的设置的位置描述也不完全，看上去像从网上哪里抄过来的 win10 的设置逻辑（win11 的位置完全不一样）\n该博客原文：在 windows 设置中打开【启用或关闭 Windwos 功能】，勾选【适用于 Linux 的 Windwos 子系统】，点击确定后会系统会提示重启，选择确认即可\n\n实际上在 win11 中，需要多点好几个地方才能找到这个设置的位置\n右键桌面 - 个性化 - 进入 win11 设置界面 - 应用 - 可选功能 - (往下滑)更多 windows 功能\n\n\n\n这都是我对一个  不完善博客  的吐槽，但并没有贬低这个教程的意思啊！至少他告诉我基本步骤应该做哪些。\n为什么我要吐槽呢？因为这种写的不全的博客经常会让读者得去重新搜索某些设置的位置，而作者明明是已经走过这个流程的。博客里面作者的截图明显是 windows11，但他提供的设置却是 win10 中的旧位置。多花 30 秒写清楚位置并带上截图，不知道能节省读者多少时间……如果你体会过查资料的时候阅读这些「断头短尾」的博客，应该也能体会到我的心情。\n\n回到正题。在更多 windows 功能选项框中（win10&#x2F;11 的这个选项框基本相同），勾选上下面的几个选项，三个都要勾选上！\n\n适用于 Linux 的 Windows 子系统\n虚拟机平台\nwindows 虚拟机监控程序平台\n\n点击确定，就成功启用了 WSL。系统会弹出一个进度条，下载一些东西。\n\n处理完毕后，WIN+R 输入 cmd，打开命令行工具，在命令行工具中输入 wsl -l -v 命令，有相关输出就是启用成功了！\n初始化情况下，执行这个命令，应该会提示你当前什么虚拟机都没有安装。\n2. 安装 Centos82.1 下载系统 zip去 github&#x2F;wsldl-pg&#x2F;CentWSL 上下载适用于 wsl 的 CentOS8 系统的 zip\n\n这个也可以：https://github.com/mishamosher/CentOS-WSL\n\n\n把 zip 解压到你想安装虚拟机的位置（一定要是一个空文件夹），然后右键CentOS8.exe，以管理员身份运行。\n\n2.2 报错 HRESULT:0x80370102 解决  安装 CentOS8 的时候，就遇到了这个 issue 中的问题👇\ngithub.com&#x2F;wsldl-pg&#x2F;CentWSL&#x2F;issues&#x2F;36\n用管理员身份运行 CentOS8.exe 之后，弹出的终端会输出如下内容\nERROR:Installation Failed!HRESULT:0x80370102\n\n根据  该 issue 中最后一个回复的解决办法，我先将 wsl 版本设置回了 1（这就是为什么前文说不要先设置为默认 wsl2）\n\nwsl --set-default-version 1\n\n重复如上安装步骤（以管理员身份运行CentOS8.exe），就成功安装了虚拟机。在 win11 的文件管理器左侧会多出来一个 Linux 图标，里面有 CentOS8 的系统里面的文件。\n\n在 windows 的 powershell 或者 cmd 中，输入wsl，就可以进入 CentOS8 的 bash；见下图，我们已经成功安装好了一个 CentOS8 的虚拟机。内部的文件就是 CentOS8 系统的默认文件。\n在内部执行 exit 命令，就可以退出 wsl 虚拟机，回到 windows 的终端下。\n\n而且 WSL 有个最大的好处，就是它能自动挂载 windows 下的文件到 /mnt 目录下，这个目录里面可以看到我的 win11 宿主机的 3 个硬盘分区；windows 的文件资源管理器里面也可以看到 Linux 中的文件，方便我们在 windows 和 linux 下互传文件（就不需要用 sftp 工具了）\n特别是如果你需要写带 Doxygen 文档的项目，在生成 Doxygen 的 html 后，就能直接从这里在 windows 的浏览器中打开网页，而不需要用 sftp 或者其他工具传到 windows 下再打开了！\n\n当然，你也可以用带 GUI 的 Linux 系统来解决这个问题。\n\n2.3 更新为 WSL2使用 wsl -l -v 命令，可以看到当前运行的 wsl 虚拟机，版本是 1\nPS C:\\Users\\S2522\\Desktop&gt; wsl -l -v  NAME       STATE           VERSION* CentOS8    Running         1\n\n我们可以将其升级为 WSL2 版本，但是这里会告诉你需要更新内核组件\nPS C:\\Users\\S2522\\Desktop&gt; wsl --set-version CentOS8 2正在进行转换，这可能需要几分钟时间...有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2WSL 2 需要更新其内核组件。有关信息，请访问 https://aka.ms/wsl2kernel\n\n那就更新呗！微软官方文档  中会告诉你需要 wsl.exe --install 或 wsl.exe --update 命令。\n这里我执行了 wsl --update 命令，执行后会弹窗要你提供管理权限，并出现一个进度条，等他跑完就行。\nPS C:\\Users\\S2522\\Desktop&gt; wsl --update正在安装: 适用于 Linux 的 Windows 子系统  已安装 适用于 Linux 的 Windows 子系统。\n\n更新好了，再重新执行 wsl --set-version CentOS8 2 升级命令，会提示你正在执行转换，需要等待一会。\n\n最终成功转换了，使用命令 wsl -l -v 里面显示的版本也是 2 了。\nPS C:\\Users\\S2522\\Desktop&gt; wsl --set-version CentOS8 2有关与 WSL 2 关键区别的信息，请访问 https://aka.ms/wsl2正在进行转换，这可能需要几分钟时间。操作成功完成。PS C:\\Users\\S2522\\Desktop&gt; wsl -l -v  NAME       STATE           VERSION* CentOS8    Stopped         2\n\n搞定！现在我们就有一个方便的 CentOS8 的 WSL 环境啦！\n可以用如下命令，将当前的 CentOS8 设置为默认的 wsl 虚拟机。这样在 windows 命令行中执行 wsl 或者 bash 命令，就能直接进入 CentOS8 中。\nwslconfig /setdefault CentOS8\n\n重启电脑后，在 powershell 的下拉栏中会自动出现 CentOS8 的选项，点击它也能进入 wsl 虚拟机环境中。\n\n3. 解决 yum 报错问题  因为这个 CentOS 的镜像是最小安装版本（类似于 Docker 安装的 CentOS），所以内部的 yum 源都是坏掉的。执行 yum update 会出现如下报错。\n[root@7945R9P ~]# yum -y updateFailed to set locale, defaulting to C.UTF-8CentOS-8 - AppStream                                                                     68  B/s |  38  B     00:00Failed to download metadata for repo &#x27;AppStream&#x27;Error: Failed to download metadata for repo &#x27;AppStream&#x27;\n\n这时候需要进行 yum 源的重新设置，参考本站博客解决这个问题就行\n 【Docker】配置 CentOS 容器时出现 Error Failed to download metadata for repo ‘appstream’ Cannot prepare internal mirrorlist | 转载\n搞定 yum 之后，就可以正常安装你想要的开发软件了。这个系统很轻量，sudo 和 passwd 等很多完整系统会自带的命令都没有，需要自行安装一些。\n另外，我写过一个 CentOS8 的初始化脚本，可以自动化安装一些软件，这里安装的软件并不一定是你想要的，请酌情参考：https://gitee.com/musnows/centos8-init\n\n而且，默认情况下的 ls 命令也没有颜色输出，需要修改 bash 配置来设置命令别名\nalias ls=&#x27;ls --color=auto&#x27;\n\n你也可以根据自己的喜好，改成 zsh 或者其他终端。\n4.vscode 连接  普通的虚拟机我们需要用 vscode 的 remote ssh 插件来连接，但是 WSL 主机我们直接用 vsc 的 WSL 插件 来连接就行了，使用的效果和 remote ssh 插件是相同的\n\n在左侧这个远程连接控制器中（和 Remote ssh 是同一个位置），找到上方的下拉条，改成 WSL 目标，就能看到我们的 CentOS8 虚拟机。点击连接它就可以了。\n\n但是 vscode 默认链接的是 root 用户，一般情况下肯定不会在 root 下写代码的。所以需要配置一下子用户\n修改虚拟机中的 /etc/wsl.conf 文件，添加下面两行\n[user]default= 用户名\n\n然后回到 windows 的命令行，重启 wsl\nwsl --shutdown CentOS8\n\n再次启动 wsl，这样 vsc 就能默认链接你的子用户了。\n5. 修改 wsl 资源限制  默认情况下，wsl2 的虚拟机能访问到完整的系统资源，包括所有 CPU 核心和内存。\n这就会导致如果 Linux 下对一些东西进行了缓存而没有及时清理，Windows 是没办法回收这部分内存的。最终就导致我们 Windows 宿主机没有足够的内存可用了，这怎么行？\n\n这种情况下，一般 windows 系统会把 wsl 直接给干掉，那我们虚拟机里面跑的活也没办法完成了。要知道，Linux 可是很喜欢 cache 内存的，很容易会把宿主机的内存给干没。\n\n为了解决这个问题，我们需要设置 wsl 的虚拟机内存 &#x2F;CPU 限制。\n在 Linux 下 可以用这两个命令来查看 cpu 和内存的配置信息，刚开始的时候应该是和你的宿主机的 CPU 和内存一样。\ncat /proc/cpuinfo | grep processor # 查看 cpu 核心数量cat /proc/meminfo | grep Total     # 查看内存信息\n\n在 windows 的 C 盘 的用户文件夹  下，创建一个 .wslconfig 文件，并在内部写入限制\n\nprocessors 是 cpu 核数限制\nmemory 和 swap 都是内存限制\n\n顶多设置为宿主机内存的一半，避免宿主机卡顿。\n[wsl2]processors=8memory=8GBswap=8GB\n\n这个配置文件的路径是（windows 下）\nC:\\Users\\ 你的用户名 \\.wslconfig\n\n随后在 windows 的终端中使用如下命令，终止这个 wsl 虚拟机\nPS C:\\Users\\S2522\\Desktop&gt; wsl --shutdown CentOS8PS C:\\Users\\S2522\\Desktop&gt; wsl -l -v  NAME       STATE           VERSION* CentOS8    Stopped         2\n\nwsl 命令中并没有 --start 选项，我们直接用 wsl 命令，就会自动重启并进入这个虚拟机。\n这时候再在虚拟机内部看看 CPU 和内存信息，就可以看到你刚刚配置的性能限制结果了。\n[root@7945R9P ~]# cat /proc/cpuinfo | grep processorprocessor       : 0processor       : 1processor       : 2processor       : 3processor       : 4processor       : 5processor       : 6processor       : 7[root@7945R9P ~]# cat /proc/meminfo | grep TotalMemTotal:        8136640 kBSwapTotal:       8388608 kBVmallocTotal:   34359738367 kBHugePages_Total:       0\n\n删除 wsl 主机  删除虚拟机的命令如下\nwsl --unregister &lt;DistributionName&gt;\n\n更多命令参考微软官网 https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands\n6. 启用 systemctl我们的系统里面有 systemctl 命令，但是没有办法使用。网上有些教程说用 service 命令来替代，但 CentOS 中是没有 service 命令的。\n[root@7945R9P bison-3.8]# systemctlSystem has not been booted with systemd as init system (PID 1). Can&#x27;t operate.Failed to connect to bus: Host is down\n\n6.1 distrod 第三方工具  我们需要用 distrod 来安装 systemctl 的组件，才能成功启用它。具体教程参考 github 仓库的 README 中的介绍。不是很难\n\nhttps://github.com/nullpo-head/wsl-distrod\n\n先下载一个自动安装的脚本（连不上 github 会报 ssl 或者 timeout 错误，请使用其他办法下载这个脚本再丢到虚拟机里面去就行）\ncurl -L -O &quot;https://raw.githubusercontent.com/nullpo-head/wsl-distrod/main/install.sh&quot;chmod +x install.shsudo ./install.sh install\n\n然后用下面两个命令之一来启动（第一个命令是会在 windows 开机自动启动的）\n/opt/distrod/bin/distrod enable --start-on-windows-boot/opt/distrod/bin/distrod enable\n\n更多内容相见  该仓库 README；\n请注意，执行第一个自启动命令的时候需要 windows 的管理员权限，此时需要输入的是系统登录的微软账户的密码（不是你的 PIN），看下面，我第一次输入密码输入的就是 PIN，显示错误，第二次输入了微软账户的密码才成功。\n[root@7945R9P pkg]# /opt/distrod/bin/distrod enable --start-on-windows-boot[Distrod] Distrod has been enabled. Now your shell will start under systemd.[Distrod] Enabling atuomatic startup of Distrod. UAC dialog will appear because schedulinga task requires the admin privilege. Please hit enter to proceed.ErrorIt seems the task has not been scheduled successfully. You may have typed a wrong password, or you may not have thenecessary administrative privileges. Do you want to retry?[Y] Yes  [N] No  [?] 帮助 (默认值为“Y”): yEnabling autostart has succeeded.[Distrod] Distrod will now start automatically on Windows startup.\n\n操作完成后，需要重启虚拟机。用如下命令将对应的 wsl 虚拟机关闭就行了，再次执行 wsl 就会重启这个虚拟机。\nwsl --terminate CentOS8\n\n如图，我的 systemctl 命令已经生效。\n\n也能正常通过 systemctl 命令启动 mariadb 数据库\n\n6.2 微软官方（推荐）\n参考 https://zhuanlan.zhihu.com/p/569883693\n\n查看 wsl 版本号命令为： wsl --version，如果此命令未正常回显版本号，或版本号低于0.67.6，那么你安装的 wsl 还不支持 systemd。如下，我的 wsl 版本已经是支持的了。\nPS C:\\Users\\S2522\\Desktop&gt; wsl --versionWSL 版本： 1.2.5.0内核版本： 5.15.90.1WSLg 版本： 1.0.51MSRDC 版本： 1.2.3770Direct3D 版本： 1.608.2-61064218DXCore 版本： 10.0.25131.1002-220531-1700.rs-onecore-base2-hypWindows 版本： 10.0.22621.2134\n\n进入 wsl 的 CentOS 虚拟机，执行如下命令\necho -e &quot;[boot]\\nsystemd=true&quot; | sudo tee -a /etc/wsl.conf\n\n随后 exit 退出虚拟机，回到 windows 终端命令行，重启 wsl\nwsl --shutdown\n\n随后再次在 windows 命令行下执行 wsl 命令，重启这个虚拟机；\n重启 wsl 虚拟机后，在  虚拟机内部  执行如下命令\nps --no-headers -o comm 1\n\n\n如果这个命令返回结果是 systemd，则代表我们的systemctl 命令已经可以使用。\n如果返回的是init，则设置失败\n\n如下图，我已经设置成功了！\n\n微软官方支持的 systemd 还是有一点是优于 distrod 的，那就是启用了官方 systemd 的 wsl2 实例，在用户停止操作后，会自动关闭，和未启用 systemd 时的特性一样，这有利于节约电脑的计算资源。\n","categories":["玩上Linux"],"tags":["Linux","虚拟机"]},{"title":"【Linux】wsl 安装的 ubuntu 不支持 POSIX 消息队列 | 已解决","url":"/posts/4006913293/","content":"wsl 安装的 ubuntu 不支持 POSIX 消息队列的解决办法\n\n\n问题\n如题，我的 win10 上安装了 wsl 的 ubuntu 后（微软商店下载的 wsl 的 Ubuntu）这个系统内部不支持 POSIX 的消息队列，虽然有 &lt;mqueue.h&gt; 头文件，但是没有实现，会报错。\n如果想找个简单的办法呢，那就是用 systemV 的消息队列，可这是个  虚拟机本地环境问题，我用 virtualbox 安装的虚拟机就能正常使用。所以肯定得解决这个问题，换成 systemV 的消息队列就有点「掩耳盗铃」的意味了。\n测试  下面是一个 POSIX 消息队列的 demo\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;mqueue.h&gt;using namespace std;int main()&#123;    mqd_t mqID;    mqID = mq_open(&quot;/testmQueue&quot;, O_RDWR | O_CREAT, 0666, NULL);    if (mqID &lt; 0)    &#123;        cout&lt;&lt;&quot;open message queue error...&quot;&lt;&lt;strerror(errno)&lt;&lt;endl;        return -1;    &#125;    mq_attr mqAttr;    if (mq_getattr(mqID, &amp;mqAttr) &lt; 0)    &#123;        cout&lt;&lt;&quot;get the message queue attribute error&quot;&lt;&lt;endl;        return -1;    &#125;    cout&lt;&lt;&quot;mq_flags:&quot;&lt;&lt;mqAttr.mq_flags&lt;&lt;endl;    cout&lt;&lt;&quot;mq_maxmsg:&quot;&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;endl;    cout&lt;&lt;&quot;mq_msgsize:&quot;&lt;&lt;mqAttr.mq_msgsize&lt;&lt;endl;    cout&lt;&lt;&quot;mq_curmsgs:&quot;&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;endl;&#125;\n\n如果编译后运行出现了下面的报错，代表当前系统不支持 POSIX 消息队列。当前系统下有 mqueue 头文件，但并没有函数的实现体\nroot@DESKTOP-5SQO6N0:~# ./testopen message queue error...No such file or directoryopen message queue error...Function not implemented\n解决  需要将 wsl 版本 1 改成版本 2，否则无完整 Linux 内核支持，无法使用 POSIX 消息队列。这也是 WSL 版本 1 和 2 的重大区别之一。\n用如下命令将当前虚拟机改成 wsl2 版本，就可以使用了。\nwsl -l -v # 用这个命令查看当前虚拟机的 version 是不是 1wsl --update # 更新 wslwsl --set-version 虚拟机名 2  # 把指定虚拟机改成 wsl 版本 2\n再次测试  正常情况下，上面的消息队列代码应该输出如下内容\nroot@DESKTOP-5SQO6N0:~# ./testmq_flags:0mq_maxmsg:10mq_msgsize:8192mq_curmsgs:0\n\n\n绑定目录  除了上面这个问题，在使用消息队列之前还可以 monut 一下路径，参考 man 手册中的教程（似乎不是必须要做的，mount 了这个路径之后能更好地看到现有的消息队列）\nmkdir /dev/mqueuemount -t mqueue none /dev/mqueue","categories":["玩上Linux"],"tags":["Linux","虚拟机"]},{"title":"【Linux】修改腾讯云轻量应用服务器的 hostname","url":"/posts/4130440541/","content":"今天想修改云主机的 hostname，但是腾讯云的控制台里面好像不能直接改这个名字\n需要  在 root 用户里面  修改！\n\n\n\n参考https://cloud.tencent.com/developer/article/1190061\n\n\n修改前：修改后：\n1. 查看当前的主机名称hostname\n\n2 . 临时修改主机名称  不建议使用，重启之后又会还原\n//hostname 主机名称hostname XXX\n\n3. 永久修改主机名称//hostnamectl set-hostname 主机名称hostnamectl set-hostname XXX\n\n4. 重启服务  重启后效果就出现了\nreboot\n谢谢你，BT7274\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】比 Xshell 更爽，用 vscode 连接云服务器进行开发","url":"/posts/3215059456/","content":"本篇博客教你如何用 VScode 的 remote ssh 插件连接上 linux 云服务器进行代码开发~\n\n\n[TOC]\n1. 下载 vscodevscode 是微软官方的一款多语言代码编辑器，其因为丰富而强大的插件而被非常多用户选中使用！\n\n官网下载：https://code.visualstudio.com/\n\n在这里可以直接下载 windows 上的 VSC，但是默认的下载链接下载是非常慢的！\nhttps://az764295.vo.msecnd.net/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n\n我们要做的就是把这个默认的下载链接改成国内的镜像源，下载速度就可以起飞！\n将下载地址中的 az764295.vo.msecnd.net 更换为 vscode.cdn.azure.cn 更改后：https://vscode.cdn.azure.cn/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n\n这速度岂不爽炸了！\n\n1.1 安装一些插件\n在开始之前，我们需要安装一些必要的插件：\n\nChinese (Simplified) (简体中文) Language Pack for Visual Studio Code\nRemote - SSH\n\n\n如果你没有其他的开发需求的话，默认安装这两个就可以让我们愉快地登陆上 linux 服务器了！\n1.2 连接云服务器  安装完 remote ssh 之后，你的左侧应该会出现这样一个按钮\n\n在最上面的链接模式我们选择ssh targets，在这里可以点击 + 号添加 linux 服务器\n\n这里填写的格式为 shh 用户名 @公网 ip。比如我的用户名是user，公网 ip 是114.514.20.22，那么需要填写的便是\nssh user@114.514.20.22\n\n\n输入完后会让我们选择一个路径，我们选第一个就可以了，方便日后管理\n\n这时候右下角会弹窗告诉你host add，成功添加了一个远程终端\n打开 user 路径下的 .ssh/config 文件，可以看到下面关于 host 的信息。其中我们可以把 Host 改成和 user 同名，注意不要修改hostname 哦！\n\n重启 vsc，然后你应该就可以在左侧看到刚刚添加的 linux 云服务器。我们右键这个终端，会出现一个选项卡询问你是在  当前 vsc 界面打开该终端，还是新建一个 vsc 界面。这个根据自己喜好选一个就 OK！\n\n初次链接会让你选择该终端的平台，我们选择 linux 即可！\n\n\n注意：这里我发现直接链接 root 会出现错误，可能是  安全性考虑阻止了 vscode 在远程服务器的环境安装，后文改为我自己的子账户进行演示！\n\n1.3 关于修改 host现在发现了问题，其实是因为 host 需要修改成和 user 一样才能正常访问，否则会报错\n\n同时下面 ssh 显示的是 host 名字，而不是公网 ip\n\n\n这里我改成自己的子账户进行演示！\n\n输入咱们  账户的密码\n\n这里 vscode 会在你的云服务器上装一些环境，当左下角出现你的  公网 ip（这里显示的是 host，为公网 ip 是因为我没有改）那就代表链接成功了！\n\n到这里我们就已成功连上云服务器了！\n\n2. 常用插件推荐vscode 连接的好处就是我们可以直接在云服务器环境里面安装插件！这里给大家推荐几个非常棒的插件：\n\nChinese (Simplified) (简体中文) Language Pack for Visual Studio Code\nTerminal Here（超级好用，必装！！）\nC&#x2F;C++\nC&#x2F;C++ Extension Pack\n\n如果你还学习 python，可以安装下面的插件：\n\nPython\nPylance\nPip Manager\n\n安装这些插件的时候，会有一些附属插件被同时安装，我们不需要管它，交给 vsc 自己处理就行拉！注意安装的时候一定是选择  安装在你的云服务器  里面，如果安装在本地，对于云服务器来说是没有用的哦~\n\n3. 开启终端 Linux 最常用的当然还是终端了，我们使用快捷键ctrl+shift+p 打开 vsc 的命令选择界面，搜索终端，选择下面这个  视图：切换终端\n\n可以看到下面会出现一个熟悉的界面~linux 的命令行有啦！\n\n但是，如果只用 linux 的命令行可完全没必要折腾 vscode，这里介绍如何更方便的用 vsc 开发\n4. 打开文件夹  在左侧最上面的分区中，我们可以选择打开一个文件夹\n\n这时候，你便可以选择你常用的工作文件夹，比如我的代码都在 GIT 文件夹里面，选择后 vscode 会打开它\n\n\n这里 vscode 会让你在输入一次 linux 用户的密码，后文会提到如何免密登录\n\n现在我已经打开了 GIT 文件夹，可以看到里面的几个子文件夹，这里创建一个新的 test 文件夹来作为演示\n\nvscode 非常棒的一点是，他会帮你  保存上一次  打开本文件夹的命令行操作信息，不像 Xshell 打开一个新的之前的命令行操作就看不到了😂\n\n咱们直接右键创建一个新的 test 文件夹，在里面创建一个 test.c 文件\n\n随便写一个喜闻乐见的 hello 代码，vscode 的代码补全比 vim 的插件好了不知道多少（个人感受）\n\n这时候之前安装的几个插件就派上用场了！C&#x2F;C++ 插件会为我们的代码提供高亮\n4.1 Terminal Here 插件  而Terminal Here这位更是重量级，我们可以方便的直接打开当前目录下的命令行，不需要自己 cd 进入文件夹！\n还是用 ctrl+shift+p 打开 vsc 的命令面板，搜索 terminal，找到下面这个选项\n\n直接回车选择它，你会发现，它自动帮我们创建了一个 test.c 所处文件夹下的终端！当你的文件目录层级很多的时候，这能帮上大忙！\n\n这里用 gcc 编译一下，没啥好说的，非常  尝龟  的操作\n\n这里你能看到 vscode 的另外一个好处，他会给你把运行正常的命令标蓝，而运行不正常的则标红。\n比如我们在代码里面写个 bug 在尝试编译，可以看到前面的小点变红了！\n\n同时在右边的滚动条上也能清楚地看到那个地方的命令是  运行失败标红  的！\n\n而 Terminal Here 插件牛逼的地方还不止这个，如果你的代码是在 Python-vnev 的虚拟环境工作目录下，该插件还会自动帮你打开虚拟环境！省得我们自己敲这一行代码了\n\n如果你不知道 vnev 虚拟环境是啥，简单说一下：python 有很多第三方软件包，我们可以通过 pip 下载安装。为了避免不同的项目中的包都直接安装在用户目录下造成环境污染，便可以创建一个 vnev 虚拟环境，在这个虚拟环境下安装包。\n只有在虚拟环境开启，且在它的工作目录下，才可以访问到这个包！\n\n\n\n咳咳，扯远啦！有了上面的引导，想必你已经可以愉快的用 vscode 在 linux 环境上开发了。\n下面介绍一下如何通过 ssh 密钥来免密登录，不需要每一次都输入密码\n5. ssh 免密登录\n参考https://blog.csdn.net/weixin_42907822/article/details/125237307\n\n如果你之前配置过 gitee&#x2F;github 的 ssh 连接，那么肯定对下面的步骤有些熟悉\n\n5.1 生成 ssh 密钥  我们打开 windows 的 cmd，输入下面这个语句\nssh-keygen -t rsa -b 4096\n\n出现的提示信息全部回车跳过，不进行任何操作！\n\n第一行是让你填一个文件名，可以根据自己需要填写，也可以不填直接回车跳过\n\n随后系统会创建一个 isa 公钥和密钥，我们将其复制到 c/ 用户 / 用户名 /.ssh 文件夹中，也就是最初配置 vscode 的 ssh 那个文件夹\n\n随后我们用 Xshell 里面的 xtfp 连接到云服务器，将有 .pub 后缀的文件拷贝到云服务器用户目录下的 .ssh 文件夹，并将其改名为authorized_keys\n\n\n设置.ssh 文件权限～/.ssh\n\nchmod 700 ~/.ssh\n\n\n设置 authorized_keys 文件权限\n\nchmod 600 ~/.ssh/authorized_keys\n\n修改完后可以用 ll 命令看看是否正常修改成功，700 对应的是 dxrw-------，600 对应的是-rw--------\n还要注意当前文件的所属用户是谁，必须要是当前用户，才能正常 ssh 连接！否则会提示无权限！（有的时候 ftp 传上去的文件是 root 用户的）\n\n5.2 修改 root 下的配置文件（慎重)友情提示：当你修改任何 linux 环境下的文件之前，都要记得 cp 一份出来作为备份！\n进入你云服务器的 root 用户 下，修改下面的文件\nvim /etc/ssh/sshd_config \n\n把  PubkeyAuthentication 前的 # 号去掉，这样公钥验证才生效。\n\n修改后保存退出\n用下面的语句重启 ssh 服务\nsystemctl restart sshd.service \n\n如果无效，则尝试直接重启云服务器\nreboot\n\n5.3 修改本机 ssh config 文件  随后我们再次打开本机 (就你现在用的 windows 电脑).ssh 路径下的 config 文件，注意  是本机  不是云服务器！\n在原本的配置信息后面追加下面两个，其中 IdentityFile 指代的是你刚刚生成的那个密钥的文件名，请根据你的  实际文件名  进行填写！\nPreferredAuthentications publickeyIdentityFile ~/.ssh/id_linux\n\n如果你的主机 ssh 端口端口不是 22，这里还可以继续添加一个 Port 选项选项来设置 ssh 的端口。\n\n前面创建 sshkey 的时候，第一个对话框是让你填写一个名字，在多终端配置的时候，名字可以方便我们管理不同的 ssh 密钥，如下是我的配置，Linux 服务器和 gitee&#x2F;github 用的是不同的密钥（也必须用不同的，因为 gitee&#x2F;github 密钥需要指定邮箱）\n\n这里配置好之后，你应该就可以免密登录云服务器而不需要输入密码了！\n\n这一步可能会出现很多问题，这里建议大家查更多资料作为补充。不要在评论问我，因为我大概率也不会😥当初配置的时候也折腾了一会，也不知道自己是怎么搞定的（真的不知道）\n第一次配置好 ssh 后可能会连不上，需要重启 vscode 再试试！\n\n结语  不知道这篇博客有没有帮到你呢？\n如果你根据本教程  成功配置好了 vscode，还请在下面评论说一声哦！\n万分感谢！\n","categories":["玩上Linux"],"tags":["Linux","vscode"]},{"title":"【工具】centos7 系统下使用 vimplus 配置 vim 的 C++ 环境","url":"/posts/274956107/","content":"centos7 系统下使用 vimplus 配置 vim 的 C++ 环境  开源项目  请参考：https://gitee.com/chxuan/vimplus\n配置好的界面如下：\n\n\n1. 准备工作：ubuntu 或者 centos7 系统 \n因为默认下载都是从 github 拉的，很容易就下载不下来，建议提前下载 vim.zip 插件安装包 vim.zip - 蓝奏云 (lanzouj.com)\n也可以到慕雪的 Gitea 去下载这个压缩包 https://gitea.musnow.top/musnow/vimplus/src/branch/master/vim-plugins.zip\n2. 具体实现：# 1.1 centos 下安装 git，sz/rz:yum -y install gityum install -y lrzsz    # 1.2 ubuntu 下安装 git,sz/rz:sudo apt-get install gitsudo apt-get install lrzsz    # 2. 克隆最新版本git clone https://gitee.com/chxuan/vimplus.git# 3. 完成后当前路径下出现 vimplus 文件夹，cd vimplus, 并且执行脚本 ./install.shcd vimplus./install.sh\n\n\n\n下载过程中询问：选择python2/3，这里选择 3\n3\n\n\n当前这一步包含许多 github 上面的项目插件，如果网速允许，就  已经结束安装；\n如果网速慢，则可以退出当前加载界面：\n# 进程挂起，中断下载，或者命令模式输入 esc + :q 退出CTRL+z    # 切换目录, 然后把开始下载的 vim.zip 拖进来, 然后解压： cd  /root/.vim/plugged unzip vim.zip    # 询问时否替换，依次输入 y  A，结束安装yA# vim 进入界面，命令模式下，输入 PlugInstall 检验是否安装完毕:PlugInstall# vim 进入依然报错：YouCompleteMe 插件有问题, 进入该目录下：cd  /root/.vim/plugged/YouCompleteMe# 输入./install.sh --clang-completer\n\n如果插件都安装好了，执行 :PlugInstall 应该显示如下界面\n\n至此 vimplus 配置安装已经结束！参考视频：Vim 快速配置 C++ 环境_哔哩哔哩_bilibili\nNoExtraConfDetected: No .ycm_extra_conf.py file detected 问题：解决传送门：https://blog.csdn.net/xiaozhidian/article/details/118340118\n","categories":["差生文具多"],"tags":["Linux","vim"]},{"title":"【Linux】设置系统防火墙，解决控制台开了防火墙依旧无法访问问题","url":"/posts/3168515672/","content":"今天在  控制台  开放了腾讯云服务器的防火墙，发现用 ip: 端口 还是不能访问，查询了之后，才知道需要设置  系统里面  的防火墙\n\n\n1. 命令firewall-cmd --zone=public --add-port=30100/tcp --permanentfirewall-cmd --reload\n\n语句的意思是开放 30100 的 tcp 端口，随后重新加载防火墙。\n如果要开放 udp 端口，吧 tcp 改成 udp 就可以了\n2. 使用示例# firewall-cmd --zone=public --add-port=30100/tcp --permanentsuccess# firewall-cmd --reloadsuccess\n\n调用完上面两个命令，还可以看看当前开了什么端口\n# firewall-cmd --list-ports30100/tcp\n\n出现这个就是 ok 了\n3. 关闭端口  开启了，也得学会关闭\nfirewall-cmd --zone=public --remove-port=3000/tcp --permanentfirewall-cmd --reload\n\n4.tx 云防火墙  注意啊，默认腾讯云控制台的防火墙开放的是 tcp 的，如果你需要测试 udp 服务，那就需要单独开放一下 udp 的端口！\n5. 绑定端口问题  如果你启动的服务是自己写的服务端代码，那么绑定 ip 的时候一定要绑定0.0.0.0，否则无法外网访问！\n127.0.0.1 #绑定这个端口是无法外网访问的！只能在机器内部访问\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】CentOS7.6 升级 gcc/g++","url":"/posts/3646248503/","content":"CentOS 7.6 升级 gcc&#x2F;g++ 的方法，不一定适用于其他 linux 系统\n\n\n1. 查看版本g++ -vgcc -v\n\n当前查看版本，发现是 4.8.5，这已经是 2015 年的旧版本了，对c++11 的支持不是很完善，为了方便学习和编写新版本的代码，升级一下还是可以的\n如果你的系统上没有 gcc&#x2F;g++，则尝试用下面的方法安装\nyum install -y gcc gcc-c++\n\n示例\n[root@bt-7274:~]# yum install -y gcc gcc-c++Loaded plugins: fastestmirror, langpacks, product-id, search-disabled-repos, subscription-managerThis system is not registered with an entitlement server. You can use subscription-manager to register.Repository epel is listed more than once in the configurationLoading mirror speeds from cached hostfile * centos-sclo-rh: ftp.sjtu.edu.cn * centos-sclo-sclo: ftp.sjtu.edu.cnPackage gcc-4.8.5-44.el7.x86_64 already installed and latest versionPackage gcc-c++-4.8.5-44.el7.x86_64 already installed and latest versionNothing to do\n\n2. 升级yum list dev\\*gcc\n\n用这个命令查看可以安装的版本有哪些\n\n可以看到最新版本已经是 11 了，那我们就直接安装最新版本的吧\nyum install devtoolset-11-gcc devtoolset-11-gcc-c++\n\nInstalled:  devtoolset-11-gcc.x86_64 0:11.2.1-9.1.el7                                                     devtoolset-11-gcc-c++.x86_64 0:11.2.1-9.1.el7                                                    Dependency Installed:  devtoolset-11-binutils.x86_64 0:2.36.1-1.el7.2                 devtoolset-11-libstdc++-devel.x86_64 0:11.2.1-9.1.el7                 devtoolset-11-runtime.x86_64 0:11.1-2.el7                Complete!\n\n看到 complete 就代表安装 over 了\n3. 生效  现在要做的就是让新安装的版本生效\nsource /opt/rh/devtoolset-11/enable\n\n\n不过这样做，只能在当前 bash 生效，新建一个 bash 就会发现还是4.8.5。要做的就是吧这个语句写入 bashrc 的配置文件中，让每次新建 bash 的时候自动执行一次就 OK 了\n要修改的是/etc/bashrc，强烈建议修改之前先备份一下\ncp /etc/bashrc ~/bashrc.bak\n\n随后执行下面俩命令\necho &quot;source /opt/rh/devtoolset-11/enable&quot; &gt;&gt; /etc/bashrcsource /etc/bashrc\n\n现在就 OK 了，新建一个 bash，再gcc -v，发现已经是新版本了\n\n4. 关于 man 失效问题  升级了版本后，可能导致 man 手册失效。这是因为 man 的环境变量被修改了\n# echo $MANPATH/opt/rh/devtoolset-11/root/usr/share/man\n\n\n如果你需要使用 man 命令，则还需要重新修改一下 MANPATH 环境变量\nexport MANPATH=/usr/share/man\n\n解决参考 man 什么都搜不了的解决方案\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】修改 linux 下的时区和系统时间","url":"/posts/809108065/","content":"用配置文件，修改 linux 系统下的时区（所用系统 CentOS8）\n\n\n1. 问题来源  在 linux 上使用 python 的 logging 模块的时候，发现了一个问题，那就是模块里面的 %(asctime)s 打印的时间并非东八区的时间，而是格林尼治时间，比东八区的时间少了 8 小时\n对于日志来说，这怎么行？总不能每次看日志的时候，自己手动给时间加 8 小时吧！那样对 debug 来说可不是什么方便事！\n2. 解决  百度了一下后，发现是我系统的时区问题。这个 Centos 系统是用 docker 安装的，内部的时区没有正常设置\ndate\n\n通过 date 命令可以查看系统当前的时间\nSat Mar  4 01:29:59 UTC 2023\n\n会发现是 3 月 4 日的凌晨 1 点，但实际上我是在上午 9 点写下的这篇博客\n\n这就需要我们修改时区了！\n\n刚开始，我尝试用 tzselect 命令进行时区的选择，再选择了上海时区后，系统的时间还是有问题。然后发现，需要修改文件配置，才能让时间生效\n/etc/timezone # 时区的配置/etc/localtime # 时间/usr/share/zoneinfo/Asia # 这里边放着亚洲主要城市的时间\n\n而我的系统中，第一个文件压根不存在！\n要用下面的两个命令来修改配置文件（root 下执行）\necho &quot;Asia/Shanghai&quot; &gt; /etc/timezone\n\nrm -rf /etc/localtimeln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n修改完毕，再次执行 date 命令，可以看到时间已经正常了\nSat Mar  4 09:31:33 CST 2023\n\npython 的 logging 模块中打印的时间也正常了\n[23-03-04 09:31:39] DEBUG:log.py:debug:9 | test in main[23-03-04 09:31:39] ERROR:log.py:exception:24 | Exception occurredTraceback (most recent call last):  File &quot;/home/kook/code/py-test/log.py&quot;, line 32, in test    a = 10/0ZeroDivisionError: division by zero\n\n3.python-logging 优化  虽然如此，但 logging 本身其实是可以设置时区的，提供一份简单的模板代码;\n在下面的代码中，用了 beijing 这个函数来获取东八区的时间，这样这份代码在任何系统上执行，都将会打印东八区的时间了。\nimport loggingfrom datetime import datetime,timezone,timedeltaLOGGER_NAME = &quot;bot-log&quot; # 日志对象名字，这个没啥用LOGGER_FILE = &quot;bot.log&quot; # 如果想修改 log 文件的名字和路径，修改此变量&quot;&quot;&quot; 日志文件路径 &quot;&quot;&quot;def beijing(sec, what):    &quot;&quot;&quot; 日志返回北京时间的处理 &quot;&quot;&quot;    utc_dt = datetime.now(timezone.utc) # 获取当前时间    beijing_time = utc_dt.astimezone(timezone(timedelta(hours=8))) # 转换为北京时间    return beijing_time.timetuple()# 日志时间改为北京时间logging.Formatter.converter = beijing # type:ignore# 只打印 info 以上的日志（debug 低于 info）logging.basicConfig(level=logging.INFO,                    format=&quot;[%(asctime)s] %(levelname)s:%(filename)s:%(funcName)s:%(lineno)d | %(message)s&quot;,                    datefmt=&quot;%y-%m-%d %H:%M:%S&quot;)# 获取一个 logger 对象_log = logging.getLogger(LOGGER_NAME)&quot;&quot;&quot; 自定义的 logger 对象 &quot;&quot;&quot;# 实例化控制台 handler 和文件 handler，同时输出到控制台和文件# cmd_handler = logging.StreamHandler() # 默认设置里面，就会往控制台打印信息; 自己又加一个，导致打印俩次file_handler = logging.FileHandler(LOGGER_FILE, mode=&quot;a&quot;, encoding=&quot;utf-8&quot;)fmt = logging.Formatter(fmt=&quot;[%(asctime)s] %(levelname)s:%(filename)s:%(funcName)s:%(lineno)d | %(message)s&quot;,                    datefmt=&quot;%y-%m-%d %H:%M:%S&quot;)file_handler.setFormatter(fmt)_log.addHandler(file_handler)\n\n针对 replit 这类  不支持自定义时区  的平台，这样也更方便。\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】man 什么都搜不了，No manual entry for xxx 的解决方案","url":"/posts/1013893765/","content":"man 什么都搜不了，No manual entry for xxx的解决方案\n\n\n\n系统 CentOS 7.6\n\n1. 问题描述  今天查手册的时候，发现 man 什么都查不了。不管是系统接口还是函数，都显示没有入口文档（No manual entry for）\n[muxue@bt-7274:~/git]$ man pthread_createNo manual entry for pthread_create[muxue@bt-7274:~/git]$ man bindNo manual entry for bind[muxue@bt-7274:~/git]$ man manNo manual entry for man[muxue@bt-7274:~/git]$ man lsNo manual entry for ls\n\n这可得难受了，要知道，我的博客里面关于接口定义的说明，很多都是从 man 手册里面复制出来的。\n在 root 下尝试了安装，并 yum update 更新之后，还是无法使用\n\n于是我就去 stackoverflow 提了个问题 【点我】 然后又自己解决了这个问题😂\n2. 解决  感谢 kook 频道的大佬，一眼就看出来这个是  环境变量  的问题\n2.1 重装 man先试试 reinstall 重装\nyum reinstall man-pages\n\n\n2.2 查看环境变量  安装完毕，查看 MANPATH 的环境变量，可以看到当前指向的是 devtoolset-11 里面的 man\n# echo $MANPATH/opt/rh/devtoolset-11/root/usr/share/man\n\n罪魁祸首就找到了！几天前，我升级了云服务器的 gcc 版本【教程】当时安装的就是devtoolset-11；\n所以，情况就是升级的过程中，man 的环境变量被修改了！\n我们要做的就是给他改回来\n2.3 修改成正确的环境变量  先用 whereis man 找一下 man 的安装路径，一般都是/usr/share/man\n# whereis manman: /usr/bin/man /usr/share/man /usr/share/man/man7/man.7.gz /usr/share/man/man1/man.1.gz /usr/share/man/man1p/man.1p.gz\n\n将 /usr/share/man 导入到环境变量\nexport MANPATH=/usr/share/man\n\n此时再 man，发现已经活过来了\nman man\n\n\n2.4 永久生效 export MANPATH=/usr/share/man 只是暂时修改当前 bash 的环境变量，要想完全生效，需要修改 bash 的配置文件\n注意：修改配置文件之前，一定要 cp 进行备份，避免修改 boom！\n\n用户目录下的.bashrc\n\n在里面添加如下命令\nMANPATH=/usr/share/man\n\n然后再 source 使其生效\nsource .bashrc\n\n此时，当前用户的 bash 就能正常使用 man 了，但是其他用户还是不行。这就需要我们修改系统的配置文件\n\n系统配置文件/etc/bashrc\n\n注意，系统的配置文件需要输入的是命令。在新建 bash 的时候会执行。如下\nexport MANPATH=/usr/share/man\n\n同样的，source使其生效\nsource /etc/bashrc\n\n现在就 OK 了！此时其他用户也能正常使用 man 了\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】记录 vscode 连 linux 遇到的奇怪报错，附带解决办法","url":"/posts/643136798/","content":"今天 vscode 连上 Linux 准备写 python 代码的时候遇到了下面的这个问题\n\n好家伙，只是用个 python 虚拟环境而已，怎么 ls 命令都用不了了？\n百度了一下，说是本地主机缺少 grep 命令\n直接用 ssh 连试了试，命令全都是好的。\n所以解决办法就很明了了：把用户家目录下的 .vscode-server 文件夹给删除了。这个文件夹是 vscode 使用 remote-ssh 插件连上 linux 的时候会自动创建的  配置文件夹。\n删除了之后需要重新连 vscode 并重新安装插件。问题不大，解决了！\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】centos8 安装 cmake3.27.4","url":"/posts/343476194/","content":"第一步，去  官网  下安装包，一定不要下错了\n\n下好了之后，用 ftp 软件传到云服务器或者虚拟机上，也可以用 wget 直接下载\nwget https://github.com/Kitware/CMake/releases/download/v3.27.4/cmake-3.27.4.tar.gz\n\n我用的是 centos8 系统，安装之前先准备好这些依赖项\nyum install -y gcc gcc-c++ make automakeyum install -y openssl  openssl-devel\n\n把下载好的安装包传上去后，解压（在 root 用户下操作）\ntar -zxvf cmake-3.27.4.tar.gz \n\n解压完毕后进入文件夹\ncd cmake-3.27.4\n\n执行命令\n./bootstrap\n\n耐心等候完成后，依次运行下面两个命令\ngmakegmake install\n\n最终判断是否安装成功\ncmake --version\n\n出现如下信息就是搞定了\n# cmake --versioncmake version 3.27.4CMake suite maintained and supported by Kitware (kitware.com/cmake).\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】root 和子用户都能执行的命令，sudo 无法执行（已解决）","url":"/posts/2473452644/","content":"\n全流程帖子 https://ask.oceanbase.com/t/topic/35604437/7\n\n1. 问题  如题，在编译 miniob 的时候遇到如下错误\n[mu@vm-cnt8:~/code/miniob]$ sudo bash build.sh initbuild.sh initHEAD is now at 5df3037d Merge branch &#x27;release-2.1.12-stable-pull&#x27; into patches-2.1build.sh: line 83: cmake: command not foundbuild.sh: line 91: cmake: command not foundbuild.sh: line 99: cmake: command not foundbuild.sh: line 107: cmake: command not found\n根据字面意思，是 cmake 命令找不到，但是我的系统里面已经有了符合条件的环境；以下是 gihub&#x2F;miniob 仓库中 docs 里面 how_to_build.md 的内容\n\nMiniOB 需要使用：\n\ncmake 版本 &gt;&#x3D; 3.13\ngcc&#x2F;clang gcc 建议 8.3 以上，编译器需要支持 c++20 新标准\nflex (2.5+), bison (3.7+) 用于生成词法语法分析代码\n\n\n我使用的系统是 centos8-steam 的 vmware 虚拟机；当前使用的 miniob 的 commit 为\n76221e46e66ef408771ce886aa0c586a09374b0d\n\n以下是我的系统中各个依赖项的版本号，可以看到在子用户中，依赖项的所有命令都可以正常执行\n[mu@vm-cnt8:~/code/miniob]$ gcc --versiongcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-20)Copyright (C) 2018 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.[mu@vm-cnt8:~/code/miniob]$ cmake --versioncmake version 3.27.4CMake suite maintained and supported by Kitware (kitware.com/cmake).[mu@vm-cnt8:~/code/miniob]$ flex --versionflex 2.6.1[mu@vm-cnt8:~/code/miniob]$ bison --versionbison (GNU Bison) 3.8Written by Robert Corbett and Richard Stallman.Copyright (C) 2021 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n在 root 中，也可以正常执行这些命令\n[root@vm-cnt8:~]# cmake --versioncmake version 3.27.4CMake suite maintained and supported by Kitware (kitware.com/cmake).[root@vm-cnt8:~]# flex --versionflex 2.6.1[root@vm-cnt8:~]# bison --versionbison (GNU Bison) 3.8Written by Robert Corbett and Richard Stallman.Copyright (C) 2021 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n但是 sudo 执行 miniob 的安装脚本的时候，却找不到 cmake 命令\n2.debug 过程  经过大佬的教学，知道了一个新的 sudo 用法：sudo -E\n\nsudo -E 是继承当前用户的环境变量运行 sudo 后面的命令，否则环境变量会被清理掉；\n\n但是在初次使用的时候，依旧无法成功编译 miniob，也找不到 cmake 命令\n[mu@vm-cnt8:~/code/miniob]$ sudo -E bash build.sh init[sudo] password for mu: build.sh initHEAD is now at 5df3037d Merge branch &#x27;release-2.1.12-stable-pull&#x27; into patches-2.1build.sh: line 83: cmake: command not foundbuild.sh: line 91: cmake: command not foundbuild.sh: line 99: cmake: command not foundbuild.sh: line 107: cmake: command not found[mu@vm-cnt8:~]$ sudo -E cmake --version[sudo] password for mu: sudo: cmake: command not found\n\n3. 最终解决：PATH 环境变量  最终的解决办法是我自己想出来的（大佬也回复了我这个解决方案）\n当前在子用户使用 sudo -E是找不到 cmake 命令的。\n[mu@vm-cnt8:~]$ sudo -E cmake --version[sudo] password for mu: sudo: cmake: command not found\n\n我的系统里面的 PATH 环境变量如下。\n[mu@vm-cnt8:~]$ sudo env | grep PATHPATH=/sbin:/bin:/usr/sbin:/usr/bin\n\n而 cmake 的路径如下\n[mu@vm-cnt8:~]$ type cmakecmake is /usr/local/bin/cmake[mu@vm-cnt8:~]$ whereis cmakecmake: /usr/local/bin/cmake /usr/share/cmake\n\n有没有可能，是因为 cmake 不在 PATH 环境变量里面，导致 sudo 的时候找不到命令呢？虽然在 root 和 mu 用户下都可以直接执行 cmake。\n于是我就去 root 里面执行了一下软连接\n[root@vm-cnt8:~]# ls /usr/bin | grep cmake[root@vm-cnt8:~]# ln -s /usr/local/bin/cmake /usr/bin/cmake[root@vm-cnt8:~]# ll /usr/bin | grep cmakelrwxrwxrwx. 1 root root          20 Sep  1 05:57 cmake -&gt; /usr/local/bin/cmake\n\n再来试试\n$ sudo -E cmake --versioncmake version 3.27.4CMake suite maintained and supported by Kitware (kitware.com/cmake).\n\n最后再来试试编译，应该是 OK 了，init 成功执行，编译也通过了，没有报错\n\n感谢 miniob 社区大佬们的帮助！\n4. 结论  如果出现一个命令，root 和子用户都可以执行，但是子用户中 sudo 却找不到此命令，可以尝试检查一下该命令所在路径是否与当前系统的 PATH 环境变量不符合！\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】valgrind 检测程序内存泄漏","url":"/posts/565285228/","content":"valgrind 是一个用于检测 debug 内存泄漏的命令行工具\n安装遵循如下命令  下载wget https://sourceware.org/pub/valgrind/valgrind-3.21.0.tar.bz2\n解压tar -xf valgrind-3.21.0.tar.bz2cd valgrind-3.21.0\n\n配置 &#x2F; 安装，需要有 root 权限sudo ./configuresudo makesudo make install\n\n使用 mencheckmencheck 是 valgrind 的一个模块，其还拥有其他功能，但是我们在这里不做使用 –tool&#x3D;memcheck  选择 memcheck 工具 –log-file&#x3D;log.txt  指定日志输出文件到 log.txt  –leak-check&#x3D;no|summary|full  指定输出日志的详细程度\n基本使用命令的一个示例，最后的 ./test 是一个可执行文件\nvalgrind --tool=memcheck --log-file=log.txt --leak-check=full ./test\n\n说明memcheck 模块检测的范围包括 \n\n使用未初始化的内存\n使用已经被释放的内存\n使用超出 malloc 分配空间的内存\n对堆栈的非法访问\n是否有释放申请的空间\nmemcpy 中 src 和 dst 的重叠（参数的内存空间有重合部分）\n\n注意，对于某些 new 和 malloc 出来的常驻对象（比如全局的某个对象，单例模式中就会遇到）并不能算作内存泄漏，因为它是需要被使用的。\n测试  整了个最简单的代码\n \n#include &lt;cstddef&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;using namespace std;​void test_leak()&#123;    int *p = (int *)malloc(sizeof(int));    *p = 1;    return;&#125;​int main()&#123;    int *p1 = (int *)malloc(sizeof(int));    *p1 = 2;​    int *p2 = (int *)malloc(sizeof(int));    *p2 = 3;    // 只析构一个，看看能不能检查出报错    free(p2);    test_leak();// 只有调用的模块出现内存泄漏才能被检测到    // 如果不调用这个函数，则不会检测到这里的问题    // 因为 valgrind 是操作监看可执行文件的，并不是来扫描代码的​    return 0;&#125;\n\n这里面有 3 个 malloc，其中有两个是没有 free 的，那么用 valgrind 可以检测出来吗？\n答案是肯定的:\n==24089== Memcheck, a memory error detector==24089== Copyright (C) 2002-2022, and GNU GPL&#x27;d, by Julian Seward et al.==24089== Using Valgrind-3.21.0 and LibVEX; rerun with -h for copyright info==24089== Command: ./test==24089== Parent PID: 24056==24089== ==24089== ==24089== HEAP SUMMARY:==24089==     in use at exit: 8 bytes in 2 blocks==24089==   total heap usage: 4 allocs, 2 frees, 72,716 bytes allocated==24089== ==24089== 4 bytes in 1 blocks are definitely lost in loss record 1 of 2==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)==24089==    by 0x1091F8: main (in /home/lyk/ub-vm/test)==24089== ==24089== 4 bytes in 1 blocks are definitely lost in loss record 2 of 2==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)==24089==    by 0x1091C1: test_leak() (in /home/lyk/ub-vm/test)==24089==    by 0x10922C: main (in /home/lyk/ub-vm/test)==24089== ==24089== LEAK SUMMARY:==24089==    definitely lost: 8 bytes in 2 blocks==24089==    indirectly lost: 0 bytes in 0 blocks==24089==      possibly lost: 0 bytes in 0 blocks==24089==    still reachable: 0 bytes in 0 blocks==24089==         suppressed: 0 bytes in 0 blocks==24089== ==24089== For lists of detected and suppressed errors, rerun with: -s==24089== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)\n\n在最后的 summry 里面可以看到，这里提示 definitely lost 了 8 个字节，而且是在两个不同的区块中丢失的。和我们的代码吻合。\n如果你不调用  test_leak()  函数，那么就不会出现第二次的内存泄漏，报告会变成只有  4 bytes in 1 blocks ，因为 valgrind 是通过可执行文件来检测是否有内存泄漏的，他不会扫描你的代码（那样的成本太高了而且不一定准确！）\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】centos8 安装 bison3.8","url":"/posts/1067381808/","content":"centos8 安装 bison3.8 的教程，感觉这个软件包很  小众  啊，百度找不到安装教程，最终还是在起脚旮旯里面翻出来了很久之前的文档，好在没有过时；\n\n\n\nhttps://linux.cn/lfs/LFS-BOOK-7.7-systemd/chapter06/bison.html\n\n\n虽然 centos8 中你可以使用 yum 直接安装，但是哪个安装的版本太低了，达不到如今的需求\nyum install -y bison\n\n我这边直接用 yum 安装的是 3.0.4 的版本，已经是 2015 年的东西了，最新的版本已经到 3.8 了，而且我正在使用的新项目 miniob 就要求更高的版本，所以老版本肯定是不行的；\nbison (GNU Bison) 3.0.4Written by Robert Corbett and Richard Stallman.Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n先用 yum 把安装好了的删掉\nyum remove bison\n\n\n我看有的文章说需要先安装前置依赖项flex，这里带上吧。因为我的系统里面不知道什么时候就已经安装好了这个东西了\nyum install flex\n\n去官网 http://ftp.gnu.org/gnu/bison/ 下载最新的压缩包\nwget http://ftp.gnu.org/gnu/bison/bison-3.8.tar.gz\n\n解压并进入文件夹\ntar -zxvf bison-3.8.tar.gzcd bison-3.8\n\n配置安装路径，这里我使用了 /usr/local 这个目录，如果你查看过安装后的 bison，你会发现它的安装包的逻辑是和 /usr/local 目录一致的，当然你也可以修改成你自己想要的目录\n# ls /usr/local/bin  doc  etc  games  include  lib  lib64  libexec  openssl-1.1.1  sbin  share  src\n\n使用如下命令配置安装路径为/usr/local\n./configure -prefix=/usr/local/\n\n目录配置好了之后，make 安装\nmake install\n\n\n如果要卸载，用make uninstall\n\n安装好了之后执行bison --version，你会得到如下输出\n-bash: /usr/bin/bison: No such file or directory\n\n这是因为我们在 /usr/local 里面安装的东西没有在 path 中，没有办法直接执行，需要我们将其软链接到 /usr/bin 里面；\n如果你的安装正确了，应该可以在 /usr/local/bin 里面找到 bison; 如果你安装的路径不同，那就去你安装路径下找bison 的可执行文件；\n# ls /usr/local/bin2to3-3.10  bison  cmake  cpack  ctest  docker-compose  idle3.10  pip3.10  pydoc3.10  python3.10  python3.10-config  yacc\n\n将其软连接一下就 ok 了\n# ln -s /usr/local/bin/bison /usr/bin/bison# ls /usr/bin/bison/usr/bin/bison\n\n再次检查版本，安装 3.8 成功！\n# bison --versionbison (GNU Bison) 3.8Written by Robert Corbett and Richard Stallman.Copyright (C) 2021 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】lcov2.0 安装和 perl 修改镜像源","url":"/posts/1274282021/","content":"安装 lcov 2.0你可能不知道 lcov 是什么，简而言之，它是一个代码单元测试覆盖率的显示工具，基于 gcov。\n\n什么是单元测试覆盖率？\n\n我们需要对项目中的每个函数编写单元测试，其实就是测试函数的功能。通过 gcc&#x2F;g++ 的相关编译选项，可以得到一个 gcda 文件，内部包含某个 cpp 文件中相关函数被执行了多少次，以及某些 if&#x2F;switch 中的多分支是否覆盖上了；\nlcov 就可以解析这些 gcda 文件，得到如下图所示的函数  测试覆盖率  的报告\n\n包括单元测试在内，这部分对代码函数测试的操作一般被称之为  功能安全，这里就不多说了。\nlcov 2.0 的安装命令相对来说很简单，就是下面这些\nwget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gztar -zxvf lcov-2.0.tar.gzcd lcov-2.0sudo make install\n\nperl使用 lcov 的时候需要 perl，此时就需要修改镜像源。默认的 perl module 的源是在国外的，国内基本上是完全用不了。\n# centos8 安装 perlsudo yum install perl\n\n如果你的 lcov 运行的时候遇到下面类似的错误，那么就是因为 perl 缺少对应 module 导致的，比如如下报错是因为缺少 Capture::Tiny 这个 module；\nCan&#x27;t locate Capture/Tiny.pm in @INC (you may need to install the Capture::Tiny module) (@INC contains: /usr/local/lib/lcov /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5) at /usr/local/lib/lcov/lcovutil.pm line 14.BEGIN failed--compilation aborted at /usr/local/lib/lcov/lcovutil.pm line 14.Compilation failed in require at /usr/local/bin/lcov line 102.BEGIN failed--compilation aborted at /usr/local/bin/lcov line 102.make: *** [makefile:6: lcov] Error 2\n\nperl 使用清华源  使用清华源就行了 https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/\n因为我用的 centos 的系统，安装的 perl 版本很老，v5.26.3，所以这里记录一个手动修改镜像源的办法\nperl --version\n\n在 root 用户下执行如下命令，会进入一个 perl 的命令行\nperl -MCPAN -e shell\n\n在 perl 的命令行中执行如下命令\no conf init\n\n最终展现的结果应该如下，会自动往当前用户的家目录下创建一个配置文件\n\n这里创建的配置文件是在 root 用户下，输入 quit 退出 perl 的命令行后，我们直接 vim 打开这个配置文件\nvim /root/.cpan/CPAN/MyConfig.pm\n\n在里面找到 urllist 选项，根据已有格式添加一个新的镜像路径就可以了\n\n我这里添加后的 urllist 配置项如下，第一项是镜像源就 OK\n&#x27;urllist&#x27; =&gt; [q[https://mirrors.tuna.tsinghua.edu.cn/CPAN/], q[http://www.cpan.org/]],\n\n但是要注意一下，在我这边的网络环境中，清华源在 perl 安装包的时候也容易抽风，我试出来比较稳定的 ip 如下，将其写入 /etc/hosts 文件中，这样安装 perl 包的时候就不会 timeout 了\n101.6.15.130 mirrors.tuna.tsinghua.edu.cn\n\n这个 ip 后续可能会有变化啊，请以你的实际情况为准！\nperl 安装 module后续安装包的时候，就可以用上镜像源了，安装包的语句如下，请注意这个安装语句最后还有个英文的单引号，一定不要把他删了！\nsudo perl -MCPAN -e &#x27;install &quot; 包名 &quot;&#x27;\n\n我需要用 perl 是因为要用到 lcov，在 lcov 仓库的 readme 里面提到了 lcov 需要的 perl 包，一个一个安装就行了（以下节选自 lcov2.0 的仓库 README）\nThese perl packages include:  - Capture::Tiny  - DateTime  - Devel::Cover  - Digest::MD5  - File::Spec  - at least one flavor of JSON module.    In order of performance/preference:       - JSON::XS       - Cpanel::JSON::XS       - JSON::PP       - JSON - Memory::Process - Module::Load::Conditional - Scalar::Util - Time::HiResIf your system is missing any of these, then you may be able to install themvia:   $ perl -MCPAN -e &#x27;install &quot;packageName&quot;&#x27;\n\n比如我需要安装 Capture::Tiny 包，就用如下命令\nsudo perl -MCPAN -e &#x27;install &quot;Capture::Tiny&quot;&#x27;\n\n正常安装的命令输出结果如下图所示\n\nubuntu 安装 perl module如果是 ubuntu，安装 perl 的包会方便一点，因为 apt 源里面是有 perl 的 module\n# ubuntu 22.04 可以直接安装下面的依赖项，就可以使用 lcov 2.0 了sudo apt install -y perl libcapture-tiny-perl libdatetime-perl\n\n你可以根据 perl 的包名中的  关键字 ，尝试在apt list 里面找找有没有对应的包\nsudo apt list | grep 包名\n\n使用 lcov对于 lcov2.0 的命令使用，可以参考我的 linux 仓库中的测试\nhttps://gitee.com/musnows/raspberry-practice/tree/master/lcov_test\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】ubuntu/centos8 安装 zsh 终端","url":"/posts/2565866661/","content":"根据这篇知乎文章进行 https://zhuanlan.zhihu.com/p/514636147\n1. 安装 zsh先安装 zsh 并设置为默认的终端\n# ubuntusudo apt install zsh# centos sudo yum install zsh util-linux-user# 通用chsh -s /bin/zsh\n\n\n如果 centos 下找不到 chsh 命令，参考此博客：https://blog.csdn.net/FungLeo/article/details/99448425\n\n然后安装 oh-my-zsh，这是一个大佬在 github 上开源的一个 zsh 配置项，相对方便点\nwget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh \n\n如果 github 连不上就用 gitee，如果你用的是子用户，那么  这个命令不要用 sudo 权限执行！否则后续子用户会因为权限问题没办法使用。\nsh -c &quot;$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)&quot;\n\n最终出现如图所示的界面就是安装成功了。\n\n2. 安装 zsh 插件  安装这两个最常用的插件就可以了\n# zsh-autosuggestions 命令行命令键入时的历史命令建议git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions# zsh-syntax-highlighting 命令行语法高亮插件git clone https://gitee.com/Annihilater/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting\n\n这个历史命令建议的插件是用方向键👉来进行补全的，不要和我一样傻乎乎按 tab。\n3. 配置文件和主题  原文中的配置文件有很多地方都不对劲，需要我们修改；\n首先是 oh-my-zsh 的安装路径，需要改成你的用户家目录下，然后需要先安装一下 powerlevel10k 主题，这个主题很好用！\ngit clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k\n\n配置文件 ~/.zshrc 改成如下内容（建议将原本的配置文件 cp 备份一下）其中的 zsh 安装路径一定要修改，否则无法正常配置！\n# 防止中文乱码export LC_ALL=en_US.UTF-8export LANG=en_US.UTF-8# oh-my-zsh 的安装路径（zsh 的配置路径）ZSH=&quot;/home/ 你的用户名 /.oh-my-zsh&quot;# ZSH_THEME=&quot;robbyrussell&quot;# 设置字体模式以及配置命令行的主题POWERLEVEL9K_MODE=&#x27;nerdfont-complete&#x27;# ZSH_THEME=&quot;agnoster&quot;ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; # 主题推荐这个，需要进行安装# 启动错误命令自动更正ENABLE_CORRECTION=&quot;true&quot;# 在命令执行的过程中，使用小红点进行提示COMPLETION_WAITING_DOTS=&quot;true&quot;# 配置要使用的插件plugins=(        git        extract        zsh-autosuggestions        zsh-syntax-highlighting)source $ZSH/oh-my-zsh.shsource $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh# python 虚拟环境相关设置if [-f /usr/local/bin/virtualenvwrapper.sh];then    export WORKON_HOME=$HOME/.virtualenvs    export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3    source /usr/local/bin/virtualenvwrapper.shfi\n\n改好了之后，启用他，然后就可以了；执行下方命令后，就会自动弹出 powerlevel10k 主题的配置引导过程。\nsource ~/.zshrc\n\n\n如果设置完毕后，你对 powerlevel10k/powerlevel10k 的配置又不满意了，可以执行如下命令重新配置\np10k configure\n\n你可能也会遇到如下报错，原因未知，但似乎不影响使用\n❯ ls_p9k_worker_stop:zle:4: No handler installed for fd 12_p9k_worker_stop:5: failed to close file descriptor 12: bad file descriptor\n\n如上报错解决办法参考 github 的 issue 内的说明\nhttps://github.com/romkatv/powerlevel10k/issues/1554\n在配置文件 .zshrc 的末尾加上下面这一行，然后 source 让其生效就可以了\nunset ZSH_AUTOSUGGEST_USE_ASYNC\n4. 使用小技巧  输入命令的时候键入 tab，会弹出一些命令的提示\n\n输入之前写过的命令的时候，会出现历史命令提示，使用方向键右👉就可以补全这个命令\n\nzsh 主要就是这一点非常的方便，至于会不会和默认的 /bin/bash 有性能差异，那就不知道了。\n另外，在 zsh 终端中直接重定向会卡住，如下命令就会阻塞掉。\n&gt; 文本文件\n\n所以要用 echo（一般我是用来清空某个文本文件）\necho &gt; 文本文件\n\n5.zsh 安装后 git 中文乱码  安装 zsh 后用 git log 查看提交信息的时候发现中文乱码。\n5.1 修改 zsh 配置文件  其实上文中提到的配置文件里面已经有这两个配置项了，说明问题不在这里\n# 防止中文乱码export LC_ALL=en_US.UTF-8export LANG=en_US.UTF-8\n\n5.2 执行 git 配置  一篇博客说要执行下面的 git 命令，也没有用\ngit config --global core.quotepath false git config --global gui.encoding utf-8 git config --global i18n.commit.encoding utf-8 git config --global i18n.logoutputencoding utf-8 set LESSCHARSET=utf-8\n\n5.3 修改系统字符配置  另外一篇博客说要修改系统的字符集配置，如下环境变量\nexport LESSCHARSET=utf-8\n\n执行后确实 ok 了，可以编辑 /etc/profile 文件，在该文件末尾追加如下内容让其始终生效\nexport LESSCHARSET=utf-8\n\n随后用 source 命令刷新这个配置文件即可。\n6. 粘贴文本很慢的问题  参考 zsh-users&#x2F;zsh-autosuggestions&#x2F;issues&#x2F;238 解决这个问题\n在 .zshrc 之后添加如下配置项\n# This speeds up pasting w/ autosuggest# https://github.com/zsh-users/zsh-autosuggestions/issues/238pasteinit() &#123;  OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125;  zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?&#125;pastefinish() &#123;  zle -N self-insert $OLD_SELF_INSERT&#125;zstyle :bracketed-paste-magic paste-init pasteinitzstyle :bracketed-paste-magic paste-finish pastefinish\n\n配置了之后，source 使其生效。\n这时候在终端里面粘贴内容的时候，就不会一个一个字符地打印出来了。那样实在是太慢了。\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【leetcode】1137. 第 N 个泰波那契数","url":"/posts/563921472/","content":"今天是学习动归的第一天，先来一道简单题练练手吧！\n1. 题目\nleetcode 1137. 第 N 个泰波那契数\n\n泰波那契序列 Tn 定义如下： \nT0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2\n给你整数 n，请返回第 n 个泰波那契数 Tn 的值。\n需要注意的是，这里的不是我们常用的斐波那契数列，哪个是 Tn = Tn-1 + Tn-2，而这里是三个；\n2. 动归解法  动态递归的思路是需要找到一个递归方程，本题中的递归方程已经给出来了。但是需要注意的是，当 n 小于 3 的时候，这个递归方程是不可用的（因为我们没有办法计算 T负数  的值）\n2.1 解法 1- 递归  如下是我的第一个解法，通过递归函数计算数值，并提前写入 0、1、2 这三个数值到数组里面。\n如果数组里面有值，直接取出来，如果没有值，在计算了之后再赋值到数组里面。这样就能保证在整个递归流程中，相同下标处的数据只会被计算一次（不这么做会超时）\n#define DEF -1 // 默认值    // 直接用递归会超时    // 想法是将数据存到 vector 里面，避免针对某一个数的二次递归运算    long long fib(int n,vector&lt;int&gt;&amp; _map)&#123;        if(_map[n] != DEF)&#123;            return _map[n];        &#125;        long long ans = fib(n-1,_map) + fib(n-2,_map)+fib(n-3,_map);        _map[n] = ans;        return ans;    &#125;    int tribonacci(int n) &#123;        vector&lt;int&gt; _map(40,DEF);        _map[0] = 0;        _map[1] = 1;        _map[2] = 1;        // 初始化并传引用给递归函数        return fib(n,_map);    &#125;\n\n使用该方法的通过率如图\n\n2.2 方法 2- 迭代  还是相同的思路，只不过这次我们不用递归，而是用迭代来计算出数组里面对应下标的值，最后再返回给用户\nint tribonacci(int n) &#123;    if(n&lt;=1)&#123;        return n;    &#125;    vector&lt;int&gt; _map(n+1,DEF);    _map[0] = 0;    _map[1] = 1;    _map[2] = 1;    for(int i=3;i&lt;_map.size();i++)&#123;        _map[i] = _map[i-3] +_map[i-2]+_map[i-1];    &#125;    return _map[n];&#125;\n\n该办法的通过率如图，时间复杂度和空间复杂度都是O(N)\n\n2.3 迭代 + 变量  既然在计算的时候我们只需要用到当前数据和该数据之前的 3 个变量，所以我们完全可以用固定的几个变量来实现这个操作，每次计算之后，都对变量进行一次轮换就 ok 了，官方的题解就是这么操作的\nint tribonacci(int n) &#123;    if (n == 0) &#123;        return 0;    &#125;    if (n &lt;= 2) &#123;        return 1;    &#125;    int p = 0, q = 0, r = 1, s = 1;    for (int i = 3; i &lt;= n; ++i) &#123;        p = q;        q = r;        r = s;        s = p + q + r;    &#125;    return s;&#125;\n\n这样操作，时间复杂度还是 O(N)，但是空间复杂度就降到 O(1)了！\n\n3. 矩阵计算  如果不用递归，还可以用矩阵乘法运算，该方法的时间复杂度是O(LogN)\nhttps://leetcode.cn/problems/n-th-tribonacci-number/solutions/921898/di-n-ge-tai-bo-na-qi-shu-by-leetcode-sol-kn16/\n\n奈何本人线代知识忘记了，完全看不懂\nclass Solution &#123;public:    int tribonacci(int n) &#123;        if (n == 0) &#123;            return 0;        &#125;        if (n &lt;= 2) &#123;            return 1;        &#125;        vector&lt;vector&lt;long&gt;&gt; q = &#123;&#123;1, 1, 1&#125;, &#123;1, 0, 0&#125;, &#123;0, 1, 0&#125;&#125;;        vector&lt;vector&lt;long&gt;&gt; res = pow(q, n);        return res[0][2];    &#125;    vector&lt;vector&lt;long&gt;&gt; pow(vector&lt;vector&lt;long&gt;&gt;&amp; a, long n) &#123;        vector&lt;vector&lt;long&gt;&gt; ret = &#123;&#123;1, 0, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, 0, 1&#125;&#125;;        while (n &gt; 0) &#123;            if ((n &amp; 1) == 1) &#123;                ret = multiply(ret, a);            &#125;            n &gt;&gt;= 1;            a = multiply(a, a);        &#125;        return ret;    &#125;    vector&lt;vector&lt;long&gt;&gt; multiply(vector&lt;vector&lt;long&gt;&gt;&amp; a, vector&lt;vector&lt;long&gt;&gt;&amp; b) &#123;        vector&lt;vector&lt;long&gt;&gt; c(3, vector&lt;long&gt;(3));        for (int i = 0; i &lt; 3; i++) &#123;            for (int j = 0; j &lt; 3; j++) &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];            &#125;        &#125;        return c;    &#125;&#125;;\n\n测了一下效果，好像效率和使用 2.3 的办法没啥区别，那我还是用动归吧😭\n\n以后有时间了再来纠结这个答案的思路\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C++","leetcode"]},{"title":"【Nginx】nginx 通过配置文件阻止海外 ip 访问","url":"/posts/2029711168/","content":"nginx 通过配置文件阻止海外 ip 访问\n说明  因为最近发现有不少刷评论的脚本，在 nginx 请求日志里面看了眼，都是海外的 ip，反正我的博客也是全中文。所以干脆把海外 ip 禁止 artalk 评论。\n在 /etc/nginx/nginx.conf 中可以看到默认的日志路径，在里面能找到每一个转发的请求和其源 IP。其中 artak 新增评论的请求是 /api/add 路径\naccess_log  /var/log/nginx/access.log  main;\n\n考虑到添加海外 ip 屏蔽可能会阻止一些真的在国外的朋友，如果你在阅读本站博客时，遇到相关问题无法直接评论与我交流，可以移步 github 随便找个我的仓库开个 issue 提问！\n解决 APNIC 介绍 后文出现的网站是来自APNIC (Asia Pacific Network Information Center)，其是 IP 地址管理机构之一，负责亚洲、太平洋地区。\nAPNIC 提供了每日更新的亚太地区 IPv4，IPv6，AS 号分配的信息表：http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest该文件的格式与具体内容参见：http://ftp.apnic.net/pub/apnic/stats/apnic/README.TXT\n\n脚本获取 ip初步解决方法参考：https://www.cnblogs.com/guoyabin/p/14263732.html\n原博主提供的脚本如下，可以下载所有海外 ip 列表并生成一个 nginx 配置，写入 /etc/nginx/blackip.conf 中\n#!/bin/bashrm -f legacy-apnic-latest black_`date +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/legacy-apnic-latestawk -F &#x27;|&#x27; &#x27;&#123;if(NR&gt;2)printf(&quot;%s %s/%d%s\\n&quot;,&quot;deny&quot;,$4,24,&quot;;&quot;)&#125;&#x27; legacy-apnic-latest &gt; black_`date +%F`.conf &amp;&amp; \\rm -f /etc/nginx/blackip.conf &amp;&amp; \\ln -s $PWD/black_`date +%F`.conf /etc/nginx/blackip.conf \n\n脚本执行后的效果如下\n[root@bt-7274:/etc/nginx]# lltotal 88lrwxrwxrwx 1 root root   34 Dec  9 16:03 blackip.conf -&gt; /root/docker/black_2023-12-09.conf\n\n文件内容如下\n[root@bt-7274:/etc/nginx/conf.d]# cat ../blackip.confdeny 128.134.0.0/24;deny 128.184.0.0/24;deny 128.250.0.0/24;deny 129.60.0.0/24;deny 129.78.0.0/24;... 后面的省略了\n\nnginx 屏蔽海外 ip参考原博主的做法，你可以将这个 blackip.conf 在/etc/nginx/nginx.conf中的 http 模块 里面 include，这样会阻止当前服务器所有反代的海外的请求。\ninclude /etc/nginx/blackip.conf;\n\n还可以在单个配置文件的location 里面引用\n  location / &#123;      proxy_redirect off; # artalk 的 nginx 配置中必须有这个      proxy_set_header X-Real-IP $remote_addr;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_set_header Upgrade-Insecure-Requests 1;      proxy_set_header X-Forwarded-Proto https;      include /etc/nginx/blackip.conf; # 引用配置      proxy_pass http://127.0.0.1:14722;&#125;\n\n修改后重启 nginx，没有报错就是 ok 了\nsystemctl restart nginx\n\n用海外的服务器试试能不能请求 artalk，用 artk.musnow.top&#x2F;sidebar&#x2F;… 这个管理员登录页面来进行测试。\n国内服务器请求结果如下，和浏览器打开的结果基本是一样（管理员登录界面）\n[root@bt-7274:/etc/nginx/conf.d]# curl https://artk.musnow.top/sidebar/#/login&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Artalk Sidebar&lt;/title&gt;    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\n\n海外服务器请求结果也是上面这样……然后发现是因为我的海外服务器 ip 压根不在那个 black 的 deny 列表里面\n尝试把 ip 的网段给加进去，重启 nginx 再试试。完美处理！添加前能正常请求到，添加后就变成 403 了\n[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Artalk Sidebar&lt;/title&gt;    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;      &lt;/body&gt;&lt;/html&gt;[root@RainYun-8aNbbsmA:~]# [root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;[root@RainYun-8aNbbsmA:~]# \n\nnginx 屏蔽非国内 ip我前文提到了我的海外服务器的 ip 不在这个 deny 的 ip 列表里面，没有被屏蔽。\n考虑到网上搜不到 legacy-apnic-latest 文件存放的是什么 ip 的信息，我决定换一个思路：allow 国内的 ip，拒绝所有非国内的 ip\n\n获取国内 ip 列表 https://www.cnblogs.com/sentangle/p/13201770.html\n\n下面这个 url 里面的 ip 地址标明了地区，我们只需要将其提取出来即可\nhttp://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest\n\n这个文件里面的内容结构如下\n等级机构 | 获得该 IP 段的国家 / 组织 | 资源类型 | 起始 IP|IP 段长度 | 分配日期 | 分配状态\n\n我们只需要提取 CN 的所有 IP，然后允许他们，再 deny all 阻止其他 ip 就可以了\n#!/bin/bashrm -f delegated-apnic-latest blackcn_`date +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latestawk -F\\| &#x27;/CN\\|ipv4/ &#123; printf(&quot;%s %s/%d%s\\n&quot;,&quot;allow&quot;,$4, 32-log($5)/log(2), &quot;;&quot;) &#125;&#x27; delegated-apnic-latest &gt; blackcn_`date +%F`.conf &amp;&amp; \\rm -f /etc/nginx/blackcn.conf &amp;&amp; \\ln -s $PWD/blackcn_`date +%F`.conf /etc/nginx/blackcn.conf\n\n执行这个脚本后，会生成 /etc/nginx/blackcn.conf 文件\n[root@bt-7274:/etc/nginx]# lltotal 88lrwxrwxrwx 1 root root   42 Dec  9 16:54 blackcn.conf -&gt; /root/docker/nginx/blackcn_2023-12-09.conflrwxrwxrwx 1 root root   40 Dec  9 16:56 blackip.conf -&gt; /root/docker/nginx/black_2023-12-09.conf\n\n内容如下\nallow 223.248.0.0/14;allow 223.252.128.0/17;allow 223.254.0.0/16;allow 223.255.0.0/17;allow 223.255.236.0/22;allow 223.255.252.0/23;....\n\n还是修改 nginx 单个站点配置文件的 location 中的内容\n  location / &#123;      proxy_redirect off;  \tproxy_set_header X-Real-IP $remote_addr;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_set_header Upgrade-Insecure-Requests 1;      proxy_set_header X-Forwarded-Proto https;# 允许所有国内 ip  \tinclude /etc/nginx/blackcn.conf;  \tdeny all; # 阻止其他 ip  \tproxy_pass http://127.0.0.1:14722;      &#125;\n\n先来试试不修改配置文件（不做任何 deny 和 allow 操作的情况下）海外 ip 请求结果\n[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Artalk Sidebar&lt;/title&gt;    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;      &lt;/body&gt;&lt;/html&gt;\n\n符合预期，正常请求出了登录页面的 html 文件。\n添加如上修改后，重启 nginx，再次进行测试。这一次已经 403 阻止了，完美！\n[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;\n\nThe end你可以写个 crontab 让其定时执行脚本并重启 nginx，我个人还是选择人工处理了（什么时候想起来就去更新一下 ip 列表）\n感谢本文中出现的博客的博主。没有他们的帮助，我无法编写出 shell 脚本。\n","categories":["玩上Linux"],"tags":["Linux","Nginx"]},{"title":"【Nginx】NGINX 配置避免 IP 访问时证书暴露域名","url":"/posts/3528013149/","content":"本文转载自：https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/\n原文TL;DRNGINX 配置避免 IP 访问时证书暴露域名\n利用 NGINX 1.19.4 后的新特性 ssl_reject_handshake on;，将其置于默认访问时配置中，IP 访问时会终止 TLS 握手，也就不会暴露域名了。\n使用如下命令查看你的 nginx 版本\n# nginx -vnginx version: nginx/1.20.1\n\n细说CDN 是建站时常用的工具，在自己的主机外面套一层 CDN 是常见操作，一般这样认为自己的主机就安全了，有人来攻击也会先到 CDN 服务器，攻击者根本无法获取到自己主机的 IP，但事实真的是这样吗？\n我们先来看看一般配置后会出现什么问题。\nserver &#123;    listen 80 default_server;    # Redirect all HTTP requests to HTTPS.    return 301 https://$host$request_uri;&#125;server &#123;    listen 443 default_server;    server_name _;    include conf.d/ssl.config;    return 444;&#125;\n\n\n上面是一个很常用的 NGINX 配置，HTTP 访问全部重定向到 HTTPS 的 443 端口上，没有配置过的域名返回 444 终止连接。\n好了，现在尝试用 IP 和 HTTPS 访问你的网站，你应该能够看到预想中访问失败、证书无效等连接失败的提示。\n但是！注意下浏览器左上角提示的不安全，点开查看证书信息，你就会发现你的域名其实随着证书发送了过来。此时如果你是攻击者，那么其实就可以知道该域名背后的源主机 IP 就是这个。\n\n上图即为用 IP 访问后，依旧能看到证书内容。这是因为返回 444 是 HTTP 层面的事情，意味着到达这一步下层的 TLS 握手已经完成。证书不被信任是一回事，但说明已经拿到了服务器的证书。\nCDN 确实避免了直接 DNS 查询暴露 IP 的问题，但攻击者通过扫描全网 IP，用上述方式依旧可以知道每个 IP 对应的域名是什么，这也是为什么很多站长用了 CDN 后并且反复更换 IP 却依旧被攻击者迅速找到 IP 的原因。\n\nCensys 就一直在干这件事，全网扫描 IP 并找到其对应的域名\n\n那该怎么办呢？问题根源出在 client 在 TLS 握手时发送了 ClientHello 后，NGINX 在 ServerHello 中带着含有域名的默认证书返回了，因为 NGINX 期望可以完成握手，这可能可以算是 NGINX 的一个缺陷。\n\n如果你不熟悉 TLS 握手流程，那么可以看看 这篇文章\n\n笨办法  既然 NGINX 默认提供了带有域名的证书，那么想不暴露也很简单，提供一个不含有正确域名的证书即可。\nNGINX 设置中 HTTPS 访问如果没有设置证书，那么就会报错。但反正 IP 访问也不需要提供服务，那么直接自签一个 IP 证书，或者随便一个域名的证书都可。当然，如果能搞定合法的 IP 证书也不是不行。\n搞定证书后，添加一个配置，让 IP 访问返回错误证书就完事了。\nserver &#123;    listen 443 ssl default_server;    server_name your_ip;    ssl_certificate    xxxx.pem;    // and more ssl config ...    return 444;&#125;\n\n\n好方法  这种方法还得自己搞个证书，如果服务器多每个都得这么搞也挺麻烦的，好在这个问题 NGINX 这已经有了很完美的解决方案。\nClientHello 中是带着 SNI 的，所以其实握手阶段是可以知道访问的域名是否合法的，NGINX 1.19.4 中添加了一个新的配置项 ssl_reject_handshake 用于拒绝握手，也就不会提供证书。\n使用方法也很简单，将原本默认配置中的 return 444 替换成 ssl_reject_handshake on 即可。\nserver &#123;    listen 443 default_server;    server_name _;    include conf.d/ssl.config;        # 不用返回 444 了，直接拒绝握手    ssl_reject_handshake on;    # return 444;&#125;\n\n\n配置后，再尝试 IP 访问，会发现浏览器报了 ERR_SSL_UNRECOGNIZED_NAME_ALERT 的错误，也看不到证书信息，目标达成！\n\n其实还没完  上述方法是通过 ClientHello 中的 SNI 确定访问是否合法的，那如果 SNI 就是正确的域名呢？\n这种场景发生于攻击者已经确定要攻击某个域名，那么他就可以将带着该域名的握手信息遍历所有 IP，握手成功就找到，这样访问其实与正常访问并无区别，唯一解决方法  就是白名单只允许 CDN 服务器访问。\n\n例如攻击者用 hosts 直接硬写 IP，将域名强行指向某个 IP\n或者用这种方式 curl https://example.com --resolve &#39;example.com:443:172.17.54.18&#39;\n\n如下，在 nginx 里面的 location 配置添加上 allow 的 IP 段，只允许 CDN 运营商的 IP 访问你的服务，就能避免绕过 CDN 造成的攻击\nlocation / &#123;    allow   172.1.2.0/24; # 允许 CDN 运营商的 IP    allow   1.2.3.4/32;    deny    all; # 阻止其他任何 IP&#125;\n\n上述 IP 段只能向 CDN 服务提供商询问，一般文档中都是有相关信息的。\n慕雪的测试  上面这篇文章我第一次看的时候还没有理解他说的是什么内容。后来测试了一下，明白了。\n说明  以我的服务器举例，我是 centos 7.2 的服务器，直接用 yum 安装的 nginx，版本nginx/1.20.1，配置路径是/etc/nginx；\n在默认情况下，你会有个 nginx.conf，和/etc/nginx/conf.d 里面的用户配置文件\n/etc/nginx\t- nginx.conf\t- conf.d\t\t- server1.conf\t\t- server2.conf\n\n在 nginx.conf 里面除了加载用户配置文件，还会有一个默认的 server，指向一个  静态文件路径。\n# 用户配置文件   include /etc/nginx/conf.d/*.conf;   server &#123;       listen       80;       listen       [::]:80;       server_name  _;       root         /usr/share/nginx/html; # 默认的静态文件路径       # Load configuration files for the default server block.       include /etc/nginx/default.d/*.conf;       error_page 404 /404.html;       location = /404.html &#123;       &#125;       error_page 500 502 503 504 /50x.html;       location = /50x.html &#123;       &#125;   &#125;\n\n在我的服务器上，这个路径里面是如下内容\n[root@bt-7274:/etc/nginx]# ls /usr/share/nginx/html404.html  50x.html  en-US  icons  img  index.html  nginx-logo.png  poweredby.png\n\n此时直接在浏览器访问你的 ip，会展示这个默认路径里面的index.html，是 centos 的一个介绍页面。\n\n但是，这并不代表你当前没有解析到任何  用户自定义文件 ！nginx 默认情况下会使用第一个用户自定义 conf 来作为 ip 访问的结果（这是因为对用户自定义 conf 的 include 是在 defualt server 之前的，你可以理解为用户自定义文件会像 C 语言的头文件一样在nginx.conf 中被展开）\n当前实际上是访问了 /etc/nginx/conf.d 里面按字典排序的  第一个用户 conf 配置！\n/etc/nginx\t- nginx.conf\t- conf.d\t\t- server1.conf # 直接访问 ip，使用了这个配置文件\t\t- server2.conf\n\n为什么在我这里依旧展示了  默认的静态文件路径呢 ？是因为我的第一个配置文件a.conf 中没有配置location /，全都是其他路径（比如/a/）的反代！所以 nginx 就往后采用了最末尾的 default server 里面提供的默认静态文件。\n而浏览器链接左侧的红色  不安全  就告诉我们，当前其实收到了一个 ssl 证书，这便是上面原文中提到的 ip 访问会因为 ssl 证书泄漏域名 的问题。\n\n我们可以点击  不安全  提示，再点击右上角那个  带徽章的小按钮，查看当前收到的证书\n\n如下图，当前收到的这证书，正是我的 /etc/nginx/conf.d 中第一个用户配置里面的 ssl 证书；内部包含了该证书对应的域名，我们的域名因此泄漏！\n\n思路回顾  再来缕一缕思路\n\nnginx 会先加载用户配置文件，末尾才是默认指向 /usr/share/nginx/html 静态路径的配置\n当你使用 ip 访问当前服务器，nginx 会给浏览器发送 /etc/nginx/conf.d 中按  字典序  排在第一位的  用户配置文件  中的 ssl 证书（即上图所示证书）\n恶意访问人员可以通过遍历访问所有 IP 地址，当访问你的服务器 IP 地址时，他拿到一个 ssl 证书，其中包括了一个域名 A；\n假设你的域名 A 是按  域名 A-&gt;CDN-&gt; 服务器 IP来进行解析的，此时恶意访问人员就通过这个 ssl 证书直接得到了  域名 A-&gt; 服务器 IP的对应关系，完全绕过了 CDN\n此时他就可以通过修改 hosts 强制让  域名 A指向  服务器 IP，绕过 CDN 直接攻击你的源站\n\n套了 CDN 还暴露源站 IP 肯定不是我们想要的结果，所以我们需要解决这个问题！\n解决办法  在/etc/nginx/conf.d中直接添加一个 a.conf，让其排序在 字典序的第一位 ，里面写入如下内容，其中server_name _ 的含义是除了我们配置过的域名外的其他访问\nserver &#123;    listen 80 default_server;    server_name _;    # Redirect all HTTP requests to HTTPS.    return 301 https://$host$request_uri;&#125;server &#123;    listen 443 default_server;    server_name _;        # 不用返回 444 了，直接拒绝握手    ssl_reject_handshake on;    # return 444;&#125;\n\n配置后直接重启 nginx，没有报错就是 ok 了\n[root@bt-7274:/etc/nginx/conf.d]# systemctl restart nginx[root@bt-7274:/etc/nginx/conf.d]# lltotal 28-rw-r--r-- 1 root root  193 Dec  9 17:52 a.conf\n\n此时直接访问就会报错 ssl 的 alert 了，但是 edge 中估计是因为  缓存的问题，依旧能看到证书\n\n换火狐看一下，无法连接，没有证书，目标达成！\n\n这里顺带贴一下火狐中一个正常 ssl 网站会显示成什么样子。在锁的按钮里面能看到证书的颁发者是谷歌，而  上图中  没有看到证书颁发者，即我们的证书并没有泄漏，目的达成。\n\n另外，我试了试我另外一个服务器使用的 1panel 安装的 OpenResty，这个比较好，在默认情况下直接访问 IP 地址返回的是 404，且没有暴露证书。不需要自己额外做配置了。\n","categories":["玩上Linux"],"tags":["Linux","Nginx"]},{"title":"【牛客网】HJ92 在字符串中找出连续最长的数字串","url":"/posts/3879460729/","content":"HJ92 在字符串中找出连续最长的数字串\n题目来源 牛客网 HJ92\n\n描述  输入一个字符串，返回其最长的数字子串，以及其长度。若有多个最长的数字子串，则将它们全部输出（按原字符串的相对位置）\n本题含有多组样例输入。\n数据范围：字符串长度 1 \\le n \\le 200 \\1≤n≤200 ， 保证每组输入都至少含有一个数字\n输入描述：输入一个字符串。1&lt;&#x3D;len(字符串)&lt;&#x3D;200\n输出描述：输出字符串中最长的数字字符串和它的长度，中间用逗号间隔。如果有相同长度的串，则要一块儿输出（中间不要输出空格）\n输入：abcd12345ed125ss123058789a8a72a6a5yy98y65ee1r2输出：123058789,9729865,2说明：样例一最长的数字子串为 123058789，长度为 9样例二最长的数字子串有 72,98,65，长度都为 2    \n\n\n题解代码  这道题的思路很简答，从前往后遍历一遍，遇到字符串就开始计算 count，并记录 起始  位置。最后再把起始位置和子串长度插入一个 pair 里面。\n需要注意的是，这里必须要用pair，因为题目要求中提到了，如果有多个相同长度的数字串，就需要一并输出，并加上最后位的, 长度\n#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;// 给定一个 256 字符的字符串，输出内部最长数字子串bool isNumStr(const char&amp; c)&#123;    return (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;);&#125;int main()&#123;    string s;// 来源    while(getline(cin, s))    &#123;        //cout&lt;&lt;s&lt;&lt;endl;        //string ret_s;// 结果        vector&lt;pair&lt;int,int&gt;&gt; v;// 用来存放数字子串的位置        int begin = 0;// 标记数字串的开始        int count = 0;// 标记长度        int max = 0, mbegin;// 上一次获取到的数据串长度和起始位置        int flag = 0;// 标记位        for (int i = 0; i &lt; s.size(); i++)        &#123;            if (i &lt; s.size() - 1 &amp;&amp; isNumStr(s[i]) &amp;&amp; isNumStr(s[i + 1]))            &#123;                count++;                if (flag != 1) &#123;                    begin = i;// 说明开始计算了                    flag = 1;                &#125;                //cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;&quot; c&quot;&lt;&lt;count&lt;&lt;&quot; b&quot;&lt;&lt;begin&lt;&lt;endl;            &#125;            else if (isNumStr(s[i]))// 自己还是数字，但是下一位不是            &#123;                count++;                //cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;&quot; c&quot;&lt;&lt;count&lt;&lt;&quot; b&quot;&lt;&lt;begin&lt;&lt;endl;            &#125;            else &#123;                if (count &gt;= max) &#123;                    max = count;// 最大的长度                    mbegin = begin;// 最大长度的起始位置                    v.push_back(make_pair(count, begin));                &#125;                count = 0;// 置零                flag = 0;            &#125;        &#125;                            if (count &gt;= max)        &#123;// 循环结束后还需要一次判断，避免最后一个字符依旧是数字的情况            max = count;            mbegin = begin;            v.push_back(make_pair(count, begin));        &#125;                for(auto e:v)        &#123;            if(e.first==max)            &#123;                for(int i = e.second;i&lt;e.second+e.first;i++)                &#123;                    cout&lt;&lt;s[i];                &#125;            &#125;        &#125;        cout&lt;&lt;&quot;,&quot;&lt;&lt;max&lt;&lt;endl;// 结束后统一输出 max    &#125;    return 0;&#125;// 通过全部用例  运行时间 4ms 占用内存 448KB\n\n做这道题的起因 - 另外一道题  咳咳，在  学校上课  的时候遇到了另外一道题目，这道题目只需输出一个最长数字子串就可以了，不需要关心长度相同的问题。\n\n我的思路和 HJ92 一样，就是遍历找到数字子串的长度和起始位置，然后插入一个新的 string 再 cout 进行输出。其中 s 和 ret_s 这两个变量都是 string\n然后我就遇到了“奇葩情况”\n\n我还在本地测试了两次，发现 “应该” 是不会多打印空格什么的\n\n上图 Linux G++，下图 VS2019\n\n而我通过了上面的 HJ92 那道题，说明代码的思路是完全没有问题的，问题就出在输出这里\n\n在结束之后（这道题限时，我没能解决这个问题）我才发现自己是个大笨蛋！\n解决方法 1：加斜杠 0注意，加 endl 的方法我已经试过了，也不行\n其实在这里，我是有想过加 \\0 的，但是  我 - 加 - 错 - 位 - 置  了！！！应该给 ret_S 加，哼哼啊啊啊啊\n\n\n解决方法 2：直接 for 打印  这个方法我也没想到，既然我都已经知道  起始位置和子串长度  了，为啥不直接打印原本 string 里面的内容呢？直接 for 打印一下不就行了???\n只能说自己对容器的使用还不是很熟悉，知识没学到位啊，哭\n\n把自己挂在这里告诫后来者\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C++","牛客网"]},{"title":"【leetcode】LCR177：撞色搭配，数组中数字出现的次数","url":"/posts/2188918016/","content":"[TOC]\n题目说明\n来源：剑指 Offer 56 - I. 数组中数字出现的次数  另外，260 只出现以此的数字 3这道题和本题是一样的。2023 年再回头看，剑指 offer 在 leatcode 上改名成 lcr 了。所以本文标题也更新一下。\n\n难度：中等\n一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O(n)，空间复杂度是 O(1)。\n示例 1：\n输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]\n\n示例 2：\n输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]\n\n\n限制：2 &lt;= nums.length &lt;= 10000\n\n方法 1：常规做法  最容易想到的常规做法：\n\n先对该数组进行 qsort 排序，再用 for 循环遍历，找到数组中下标 i 和i+1不相等的哪一项，这一项 i 即为只出现了一次的数字。\n\n若最末尾的数是目标数，需要进行判断并 break，防止越界访问数组\n\n\n\n如果你不了解 qsort，可以看这篇博客学习一下👉点我\n\n// 方法 1，太过简单，不够高级cmp(const void* e1, const void* e2)&#123;    return *(int*)e1 - *(int*)e2;&#125;int* singleNumbers(int* nums, int numsSize, int* returnSize) &#123;    int* result = (int*)calloc(2, sizeof(int));    int k = 0;    qsort(nums, numsSize, sizeof(int), cmp);// 对原数组进行排序    int i = 0;    for (i = 0; i &lt; numsSize; i++)    &#123;        if (i == numsSize-1)// 如果 i 是末尾数，需要进行判断        &#123;            result[k] = nums[i];            break;        &#125;        if (nums[i] == nums[i + 1])        &#123;            i ++;        &#125;        else        &#123;            result[k] = nums[i];            k++;        &#125;    &#125;    *returnSize = 2;    return result;&#125;\n\n\n\n方法 2：异或求解  复习一下位操作符  很尬尴的是，本人对位操作符和移位操作符并不熟悉。经常把它们记混。几次测试的时候，涉及到这两个操作符的题目就是瞎蒙。\n后来发现位操作符和移位操作符似乎是测试中经常考察的对象，这里建议大家一定要把它们弄懂！\n\n\n\n语句\n操作符\n对应结果\n\n\n\nc &#x3D; a &amp; b\n&amp; 按位与\n全 1 为 1，否则 0\n\n\nc &#x3D; a | b\n| 按位或\n有 1 为 1，否则 0\n\n\nc &#x3D; a ^ b\n^ 按位异或\n相同为 0，不同为 1\n\n\n\n题解  异或有一个特点，a^a=0，a^0=a\n\n案例 1输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]\n\n以题目所给参考 2 为例\n1^2^10^4^1^4^3^3 = 2^10\n\n可以看到，当我们把所给数据全部异或在一起的时候，其结果正好是我们需要的两个数相异或。\n但是我们好像并没有什么好的办法把已经异或了的两个数拆开\n这时候就需要对待查找的数据进行分组\n\n分组的目的：让两个单身狗分开到两组数据中\n这两组数据，除两个单身狗外，其他数字都出现了两次\n\n1 1 3 3 4 4 210\n\n为什么是这么分的呢？\n10: 10102:  001010^2=1000\n\n可见单身狗 10 和 2 之间，源码第四位才有差别\n1： 00012： 00103： 00114： 010010：1010\n\n这时候我们就可以通过第 4 位的差距，将数据分为两组\n\n第一组是1~4，它们的第 4 位都是 0\n\n第二组是10，只有它的第四位是 1\n\n\n再根据前面异或的特点，对这两组数字进行异或操作，即可得到单生狗 10 和 2\n1^1^3^3^4^4^2 = 210 = 10\n\n\n案例 2上面这组数据有些特殊，第二组里面只有 10 一个数字\n我们再来看一组数据\n1 2 3 4 5 1 2 3 4 6\n\n这一组数据中，单身狗是 5 和 6\n5：01016：01105^6 = 0011\n\n可见 5 和 6 的源码中，第一、二位都有区别\n这里我们取第一位来分类即可\n1：00012：00103：00114：01005：01016：0110\n\n二进制第一位为 1 的数，放入一组\n1 1 3 3 52 2 4 4 6\n\n对它们进行异或操作，就可以得到单身狗 5 和 6\n\n敲代码// 方法 2- 异或int* singleNumbers(int* nums, int numsSize, int* returnSize) &#123;\t//1. 全部异或在一起    int i = 0;    int k = 0;    for (i = 0; i &lt; numsSize; i++)    &#123;        k ^= nums[i];        //4^1^4^6 = 1^6    &#125;    //2. 判断 k 的二进制第几位是 1    int set = 0;    for (i = 0; i &lt; 32; i++)    &#123;        if (((k &gt;&gt; i) &amp; 1) == 1)// 注意操作符优先级        &#123;            set = i;// 第 i 位为 1            break;        &#125;    &#125;    //3. 以第 set 位为 1 进行分组，可以将这两个数分开    int n = 0;    int m = 0;    for (i = 0; i &lt; numsSize; i++)    &#123;        if (((nums[i] &gt;&gt; set) &amp; 1) == 1)        &#123;            n ^= nums[i];        &#125;        else        &#123;            m ^= nums[i];        &#125;    &#125;    int* result = (int*)calloc(2, sizeof(int));    // 返回的数组必须用动态内存管理来创建    result[0] = n;    result[1] = m;    *returnSize = 2;    return result;&#125;\n\n验证  自己整一个 main 函数来测试一下代码是否能达到要求，成功！\n\n做接口题的时候，如果出现输出错误的情况，可以自己写一个 main 函数并调试来找出错误\n\n\n可以看到，运行的用时远远小于  方法 1的用时\n击败了 92.9% 的用户！\n\n你学会了吗😍\n\n如果这篇博客对你有帮助，点个👍再走呗~\n\n摸鱼之发现另外一道一样的题\nhttps://leetcode.cn/problems/single-number-iii/submissions/\n\nclass Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        //1. 全部异或在一起        int numsSize=nums.size();        int i = 0;        int k = 0;        for (i = 0; i &lt; numsSize; i++)        &#123;            k ^= nums[i];            //4^1^4^6 = 1^6        &#125;        //2. 判断 k 的二进制第几位是 1        int set = 0;        for (i = 0; i &lt; 32; i++)        &#123;            if (((k &gt;&gt; i) &amp; 1) == 1)// 注意操作符优先级            &#123;                set = i;// 第 i 位为 1                break;            &#125;        &#125;        //3. 以第 set 位为 1 进行分组，可以将这两个数分开        int n = 0;        int m = 0;        for (i = 0; i &lt; numsSize; i++)        &#123;            if (((nums[i] &gt;&gt; set) &amp; 1) == 1)            &#123;                n ^= nums[i];            &#125;            else            &#123;                m ^= nums[i];            &#125;        &#125;        vector&lt;int&gt; retV;        retV.push_back(n);        retV.push_back(m);        return retV;    &#125;&#125;;\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","leetcode"]},{"title":"【牛客网】JZ65: 不用四则运算符实现两数相加","url":"/posts/1481999994/","content":"[TOC]\n问题来源\n牛客网数据结构题目👉JZ65\n\n题目要求如图\n\n\n思考  不能使用四则运算，根据过往的学习经历，我唯一能想到的就是  位操作符和移位操作符\n例：使用位操作符进行 int 变量交换\n\n位操作符的使用  先来回顾一下位操作符的作用\n位操作符操作的是整形的二进制位，它的操作数是 2，比较两个整型的二进制位\n\n&amp; 按位与：对应的二进制 全为 1 才是 1，否则 0\n| 按位或：对应的二进制 有 1 为 1，全为 0 才为 0\n^ 按位异或：相同为 0，不同为 1\n\n\n比较一下正常的二进制相加和按位异或，发现按位异或是没有进位的相加\n\n\n原本应该是 010，但是按位异或后是 000\n1+1 需要进位的 1 并没有进到下一位里去\n\n而使用  按位与  操作符，我们可以得到这两个数相加需不需要进位\n0 0 10 0 1// 按位与 - 全 1 为 10 0 1//&lt;&lt; - 左移 1 位0 1 0\n\n这时候将按位与之后的结果和按位异或相加，就是我们的答案了\n但是题目要求  不能使用加减\n\n再将按位与的结果 0 1 0 与 按位异或结果 0 0 0 进行  按位与\n得到0 0 0 ，代表无需进位\n这时候将 0 1 0 与0 0 0 进行按位异或，即得出相加后的结果0 1 0\n\n\n这个例子比较简单，我们可以再用复杂一点的例子再证明它的可行性\n3：0011 和5：0101\n\n\n\n操作\n结果\n\n\n\n\n1：按位与和左移\n0 0 1 0\n需要进位\n\n\n2：按位异或\n0 1 1 0\n\n\n\n3：1 和 2 按位与，左移\n0 1 0 0\n需要进位\n\n\n4：1 和 2 按位异或\n0 1 0 0\n\n\n\n5：3 和 4 按位与，左移\n1 0 0 0\n需要进位\n\n\n6：3 和 4 按位异或\n0 0 0 0\n\n\n\n7：5 和 6 按位与，左移\n0 0 0 0\n无需进位\n\n\n8：5 和 6 按位异或\n1 0 0 0\n得到结果为 8\n\n\n根据这个思路，我们成功地完成了 3 和 5 的相加\n\n代码实现  本题是  接口型  题目，我们只需要完成一个函数，实现相加的功能\n/** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * *  * @param num1 int 整型  * @param num2 int 整型  * @return int 整型 * * C 语言声明定义全局变量请加上 static，防止重复定义 */int Add(int num1, int num2) &#123;    while(num2)    &#123;        int t = (num1 &amp; num2) &lt;&lt; 1;        num1 ^= num2;        num2 = t;    &#125;    return num1;&#125;\n\n不过我们可以自己写一个主函数来测试它的可行性\n如图，函数正确算出了两个数的和\n\n\n如果这篇博客帮到了你，还请点个赞啦~\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","牛客网"]},{"title":"【教程】Typora+PicGo+ 阿里云 OSS 搭建博客图床（超详细）","url":"/posts/1825409965/","content":"如果你想搭建一个和本站类似的个人博客，那就需要图床来辅助\n\n\n[TOC]\n为什么要搭建博客图床?以 CSDN 为例，我们可以选择使用大部分 blog 平台通用的 markdown 语法 进行博客创作\n虽然 CSDN 自带的编辑器已经能满足我们 95% 的  写作需求\n但是 Typora 在 markdown 语法编辑上能给你提供更好的  写作体验\n所以我选择了以 Typora+Picgo+ 图床 的方式来进行博客创作\n\n而在本地的 markdown 文件.md 中，图片是以“外链”这一形式存在的\n\nOffice word 中，图片是直接插入 docx 文件里面\nMarkdown 中，图片只是一个本地 &#x2F; 联网的地址\n\n如图，在 markdown 里面，图片显示的其实是一个本地的地址\n\n也就是说，如果我们使用  本地 markdown 编译器（如 typora）来编辑 MD 文件的时候，如果 MD 里面插入的图片的源文件被移动或者删除了，我们的 MD 文档里面对应的图片也无法显示出来。\n\n同时，如果我们用本地编辑器写好了一篇博客，想把它上传到 CSDN 上。CSDN 是无法自动转存文件里面的图片  的。因为这个图片只是一个你硬盘里面的文件路径，他也没办法  越权  跑到你电脑里面找文件呀！\n[外链图片转存失败, 源站可能有防盗链机制, 建议将图片保存下来直接上传(img-i1aotHJh-1679223552739)(./Snipaste_2023-03-19_18-58-37.png)]\n\n什么是图床？在我们往 typora 里插入图片的时候，PicGO 自动上传图片到  图床 ，并返回一个图片的 链接\n\n这时候你的图片就是一个 ** 网络的链接 (网址)**，不再是本地路径。 你也可以在任何有网络的地方、用任何设备访问这张图片了！\n\n即便是本地的那张图片  移动 or 删除，也不会影响图床里的这张图片。\n同理，typora 里面的图片也就不会失效了，CSDN 也能正常从网络上将你的图片下载下来，我们的博客也能很方便的从 typora 拷贝到 CSDN 上发布。\n\n接下来就是如何搭建  阿里云 OSS 图床  的教学了！\n前排提醒，阿里云图床需要  付费💴，但价格非常便宜！ \n\n如果你想白嫖，也可以考虑用 gitee 作为你的图床。但是 gitee 有单仓库文件大小限制(600mb)。后续图片多了，转移图床的成本更高。还不如一开始就选个好的平台，不是嘛？\ntypora+picgo+gitee 图床配置方法，看这个👉【链接】\n\n22.03.26更新：果然“免费的才是最贵的”，经过多个朋友的反馈，确认 gitee 图床已经崩溃，图片在 gitee 仓库内没有问题，但是 typora/picgo/obsidian 内都无法正常预览图片，CSDN 也无法转存！可能是 gitee 更新了外链机制，新增了防盗链。\n还是建议大家更着本篇博客使用阿里云 OSS 吧！\n1. 准备软件1.1Typora\nTypora：【中文官网】\n\n想必各位应该听很多博主安利过 Typora 这款软件，这里就不展开描述了\n新版本 typora 需要付费买断。可以考虑支持  正版 ，也可以去找找 旧版本安装包\n\n参考这个视频👉【链接】\n如果你找到了旧版本安装包，需要确认 typora 版本  高于 0.9.86\n\n1.2Picgo\nPicGo：【Github 地址】\n\n找到对应安装包，下载安装即可\n\n2. 配置阿里云 OSS在浏览器搜索  阿里云 OSS，即可找到官网\n\nhttps://www.aliyun.com/product/oss\n\n\n2.1 注册, 开通对象储存  注册账户并实名后，进入你的  控制台\n\n选择  对象储存  并开通\n\n2.2 创建 bucket在左侧选择概览，然后在右侧创建一个新的 bucket\n\n注意： \n\nBucket 名字  不能  有大写字母\n服务器就近选择\n图床选择  标准存储\n读写权限  公共读\n\n\n创建完成后，你的 bucket 应该就出现在了左侧\n2.3 找到你的地域节点  点击你的bucket 名\n\n然后点击 bucket 下的  概览\n\n在  访问域名  一栏找到你的地域节点，后面会用到\n\n如图，只需要复制 oss-cn-shenzhen 即可，不需要后面的.aliyuncs.com\n\n\n2.4 找到你的 Key来到右上角，鼠标放在你的头像上，在弹出的框里选择 AccessKey 管理\n\n在弹出的选项框里，选择“继续使用”\n\n进入后，创建一个AccessKey\n\n在弹出的界面里，记住你的 accessKeyId 和accessKeySecret\n\n2.5 给你的阿里云账户充值 2.5.1 收费问题 阿里云 OSS 的各项收费是  独立  的！\n对于  图床  而言，有两种收费形式\n\n以  充值的方式  使用  储存容量  以及  流量(默认状态)\n按年 &#x2F; 月收费，购买一定存储包。流量额外收费\n\n也就是说，即便你购买了下图的存储包，你依旧要为  访问图床的流量  付钱！\n\n\n下图是在默认状态下，容量和流量收费的价格\n\n图床使用的是  标准型，请勿购买其他类型\n\n\n储存容量：0.12 元 &#x2F;GB&#x2F; 月\n图片  上传  到阿里 OSS 流量：免费\n外网流出  流量 (如 typora 访问图床图片)：闲时 0.25 元 &#x2F;GB， 忙时 0.50 元 &#x2F;GB\n\n\n\n仔细算算，我们图床的数据量其实很小的\n\n0.12 元 &#x2F;1GB&#x2F;1 个月，一年就是 1.44 元，远低于 40GB 的 9 元收费！\n截图 &#x2F; 照片以平均 0.5mb&#x2F; 张估算，1gb 可存放超过 1600 张图片！\n数据低于 7GB 的情况下直接充值，以 GB 付费其实比  购买储存包  更加值得！\n\n2.5.2 注意事项\n记得给阿里云账户充值！！别到时候欠费停用了！！\n刚开始作图床的时候，直接充值使用即可，无需购买容量包！\n\n\n到这里，我们阿里云 OSS 基本配置完毕了😎\n\n3. 配置 picgo打开 picgo 后，在你 windows 的  状态栏  里找到 picgo 的图标，打开 picgo 的主界面\n\n3.1 图床设置  在图床设置里面选择  阿里云 OSS，依照以下步骤填写信息\n\n设定 Keyld：填写刚刚获得的AccessKeyID\n\n设定 KeySecret：填写AccessKeyIDSecret（注意，直接从 OSS 控制台中复制 keysecret 有概率会出现空格 or 回车，建议先复制到记事本中，再复制到 picgo 中）\n\n设定储存空间名：填写bucket 名称。不是浏览器里的域名\n\n指定存储路径 ：其实就是自定义一个 文件夹  的名字，以 / 结尾. 它会  自动  在你的 bucket 里面创建一个文件夹，并把图片上传进去\n\n\n\n弄完之后，记得“确定”，并点击“设置为默认图床”！\n\n3.2picgo 设置  在设置里打开  时间戳重命名  和上传后自动复制 URL\n\n时间戳重命名：以上传时间来重命名图片，避免同名的图片无法上传（该设置不影响本地图片名）\n\n\n4. 配置 typora进入 typora 主界面，点击左上角的“文件 - 偏好设置”\n\n选择  图像\n插入图片时  上传图片\n下面的选项全勾上（第二项对网络位置的图片可钩可不钩，主要是避免同一张图片被多次上传）\n上传服务选择PicGo(app)\nPicGo 路径：找到 picgo 的安装路径，不是安装包的路径！！！！\n\n\n\n5. 测试是否成功 5.1 typora 自带上传测试 设置完毕后，我们点击  验证图片上传选项，如果弹出以下弹窗，我们的图床就搞定了！😀\n\n如果出错了，建议先自己看看 picgo 的日志里面为什么报错，检查一下配置有没有出错。\n如果看不明白日志的报错，就去 picgo 的 github 仓库开一个 issue 问。对于 picgo 的错误我也不是很清楚，来问我是浪费你的时间🙅‍♀️\n如果你在  检查过 picgo 配置内容和阿里云 OSS 设置 、重启 picgo、重启电脑后仍然无法成功上传。还可以参考这篇博客的配置方法👉  很不幸，原文已被删除\n\n5.2 复制图片测试上传  最后新建一个文件，验证图片是否正常上传。\n日常写作的时候，我们只需要  复制  图片，在 typora 里面  粘贴  即可，无需拖动！\n当你的图片链接显示为  阿里云的网络链接，而不是本地路径时\n\n6. 大功告成！到这里，我们的图床就大获全胜！开始你的创作吧！🧐\n","categories":["差生文具多"],"tags":["图床","typora"]},{"title":"【日志】又拍云 CDN 被恶意请求","url":"/posts/1758576550/","content":"自 23.03.23 起，图床 CDN 遭到了持续一周的恶意请求！\n\n\n说明  请求来自同一个 ip，请求的是同一张图片，每秒请求约 15 次，高峰期都是在凌晨，白天每秒也只请求 4 次（怕不是白天要用电脑，给爬虫限流……），最终导致日请求量上了 100w，日均扣费 4 元😒\n在我禁掉他的移动 ip 后，他换了另外一个电信的 ip 继续请求同一张图片。\n因为两个 ip 的属地相同，都是  家宽 ，无法被 ping， 所以我认为是同一个人！\n我发现的已经有点晚了，对方已经恶意请求了将近一周。虽然又拍云 OSS 配置了 IP 访问限制，但咨询了客服后，得知即便被 403 挡掉的请求（在日志中，一个小时就有 4w 个请求被 403 阻止），依旧会计入 https 费用。\n在此提醒大家，又拍云的日扣费提醒最低只能设置为 10 元，建议隔 1-2 天上控制台查看一下统计信息，及时发现并阻止对方的恶意请求\n几种反制策略1. 禁止他的 ip2. 删除源站图片，清空 cdn 缓存，将原有 url 配置 444 访问规则（见下方截图）3. 严重的时候直接关闭 CDN 的域名解析\n\n截图  下图中请求迅速降低是因为我关闭了该 cdn 的域名解析\n\n昨天上午就请求了 44w 次，3.28 一整天请求了 101w 次\n\n扣费，心疼啊！\n\n个人觉得 https 请求如果被 403 了还进行相同价格的扣费是不太合理的（\n\n\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【Picgo】正确重命名文件，避免重复上传","url":"/posts/373497921/","content":"picgo 正确设置重命名文件，避免同文件重复上传\n\n\n1. 问题来源  在之前配置 picgo+ 阿里云 oss 图床的博客中，我提到了需要开启 picgo 的  时间戳重命名  功能，以避免同名文件冲突。\n\n阿里云 OSS 默认策略：同名文件会被覆盖\n\n现在看来，这个方法还是有一个缺点：那就是没有办法避免  同一个文件的多次上传\n说白了就是，我有一个图片，结果因为自己不小心多复制了几次，导致 picgo 多次上传了这个文件。再加上时间戳不同，之前上传的图片并不会被覆盖，而是留在那儿无人问津；\n亦或者是开启了 typora 下图中  对于网络位置的图片应用上述规则，同一个图片需要在一篇文章中出现两次，复制的时候，因为开启了该策略，typora 自动帮你又上传了一遍；\n\n1.1 说明  阿里云 OSS 的空间是要付费的！对于个人博客图床而言，或许并不需要多少空间（本人使用阿里云 OSS 做图床已有 1 年，才用了 980mb）\n今天为了迁移其中一个 bucket，发现了里面有非常非常多的重复文件，文件大小内容完全一致，这就是无意义的空间浪费，对于容量计费的 oss 来说，这可都是💴啊！\n所以我们需要一个标识文件的方法，避免同一个文件的多次上传。\n比较好的办法，那就是用文件的 hash 值来命名这个文件。此时，同一文件的 hash 值是一样的，上传到 oss 里面之后会直接覆盖，并不会多占用一份空间！我们的目的也就达到了\n2. 使用 picgo 插件解决\n插件开源地址 liuwave&#x2F;picgo-plugin-rename-file\n\n2.1 安装  我的 picgo 是 2.3.1 版本的，能直接在插件市场安装\n\n安装好了之后，在这里配置\n\n2.2 配置  遵循仓库 readme 里面的配置方法\n\n这里我选择了比较简单的配置方法，年 + 月 + 哈希值\n&#123;y&#125;/&#123;m&#125;/&#123;hash&#125;\n\n这么做是为了避免 hash 值碰撞，虽然同一人能人工弄出两个 hash 碰撞的图片的可能性及其低，但加上一个年份和月份，可能性就更低了😂\n这样就能保证在  同一月  上传的图片中，如果有相同图片会直接覆盖，不会多占用一份空间。\n\n至于其他选项，参考文档。个人觉得没有太大必要，毕竟都上传到图床了，谁还管这个文件的原名和本地存储路径是什么呢？\n\n3. 收工  设置完毕之后，现在上传的图片命名格式如下\n20234d48b94bd1054488005eb239741c807d.png\n\n再次手动上传一遍这个文件，发现返回的 url 是相同的\n我们的目的就达到了！\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【七牛云】artalk 表情遇到跨域访问问题","url":"/posts/489538601/","content":" 如题，当我在我自己编写的文档站点 https://khl-py.eu.org/ 访问我的 artalk 服务时，其中包含一个 artalk 表情的请求，被浏览器的跨域策略给挡住了。这会导致 artalk 评论中无法发送表情（虽然无伤大雅）\nAccess to fetch at &#x27;https://img.musnow.top/i/artalk-emoji.json&#x27; from origin &#x27;https://khl-py.eu.org&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. If an opaque response serves your needs, set the request&#x27;s mode to &#x27;no-cors&#x27; to fetch the resource with CORS disabled.\n\n 百度了一下，我们需要在七牛云的 CDN 策略中进行配置（我的七牛云 KODO 是绑定到 CDN 上，通过 CDN 进行访问的）\n 找到 CDN 界面中的 HTTP 响应头配置 \n\n 点击修改配置，添加如下两点 \n\n 保存后过一会，就不会出现这个跨域访问问题了。至于这部分设置会不会导致有人盗刷你的 CDN 流量，仍待更多的观察。\n 另外，如果你的 CDN 还开启了防盗链，还需要把对应域名填入防盗链的白名单中！\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【教程】Typora+PicGo+ 又拍云 uss 搭建博客图床","url":"/posts/3648256488/","content":"Typora+PicGo+ 又拍云 UOS 搭建博客图床\n\n\n1. 又拍云 uos 配置 1.1 创建 进入控制台后，点击云存储，创建云存储服务。配置你的服务名称，操作员名称，和操作员的权限。\n请保存操作员的密码，后续配置 picgo 用得到\n\n1.2 加速域名  点击如下图齿轮进入配置页面\n\n在下图绑定你的域名（需要已备案域名）\n\n1.3 https随后在下图所示处配置域名的证书。如果你没有 ssl 证书，可以在又拍云的控制台主页申请一个免费的 let’s encrpy 证书\n\n1.4 访问控制  在访问控制里面可以配置各种形式的控制。\n对于博客图床而言，referer 防盗链  是一定  要打开的，其余根据自己的需求进行配置\nIP 黑白名单 # 白名单：允许的 ip, 黑名单：不允许的 ip# 如果发现某一个 ip 的请求次数过多，有恶意请求嫌疑，可以暂时将这个 ip 设置为黑名单 CORS 跨域共享 # 参考 http://ruanyifeng.com/blog/2016/04/cors.html 地区访问限制 # 禁止或允许特定地区的限制 Referer 防盗链 # 重点，建议开启白名单，只将自己的域名添加到白名单中（建议开启）User-Agent 防盗链 # 限制只有某种类型的客户端、浏览器可以访问资源Token 防盗链 # 有些麻烦，请自行了解。对于静态博客而言，并不方便 回源鉴权 # 如果源站服务器有鉴权操作，可以在这里配置IP 访问限制 # 对单个 ip 的请求速率进行限制（建议开启）CC 防护 # 防护 cc 攻击WAF 保护 # Web Application Firewall\n\n2.picgo 配置  相比于阿里云 oss，这里的 picgo 配置就挺明了了\n\n在 picgo 的  上传区  测试一下是否能正常上传\n3.typoratypora 的偏好设置中，图像一栏选择上传图片，勾选如下几项。\n上传服务设置为picgo(app)，路径填写为你 picgo 的安装路径。\n\n随后点击左下角验证图片上传，出现如下所示代表配置成功\n\n此时我们的图床就已经配置好了\n","categories":["差生文具多"],"tags":["图床","typora"]},{"title":"【Typora+Lsky】在 deepin 使用 YGXB-net/lsky-upload 上传图片","url":"/posts/4106816943/","content":"在 win 和 deepin 上使用 lsky-upload 上传图片\n\n\n1. 说明  先前使用 lsky 图床的时候，我一直用的是 picgo 的插件来上传图片。\n但最近 picgo 总是遇到卡上传的问题 https://github.com/Molunerfinn/PicGo/issues/1060\n后来在 gitee 上面搜到了这个项目，其能将 typora 的图片上传到 lsky，缺点就是只支持 lsky 图床。不过我正好要的就是这个！\nhttps://github.com/YGXB-net/lsky-upload/releases\n\n进 releases 下载作者 build 好的 windows 包，按作者的 README 进行操作，就能在 windows 下成功上传图片。\n经过了一天的使用，没有出现 picgo 的卡上传问题。开心！\n\n于是尝试在 deepin 下面也 build 一个 go 的包\n2. 安装 go 环境和遇到的问题sudo apt-get install golang\n\nbuild 的时候遇到了如下问题\nmothra@mothra-PC: ~/Downloads/lsky-upload$ go buildinternal/config/config.go:4:2: package embed is not in GOROOT (/usr/lib/go-1.15/src/embed)\n\n百度到的解决办法说要修改一个 go 的环境变量\nmothra@mothra-PC:~/Downloads/lsky-upload$ go env -w GO111MODULE=offmothra@mothra-PC:~/Downloads/lsky-upload$ go installmain.go:7:2: cannot find package &quot;github.com/tidwall/gjson&quot; in any of:        /usr/lib/go-1.15/src/github.com/tidwall/gjson (from $GOROOT)        /home/mothra/go/src/github.com/tidwall/gjson (from $GOPATH)main.go:9:2: cannot find package &quot;lsky-upload/internal/config&quot; in any of:        /usr/lib/go-1.15/src/lsky-upload/internal/config (from $GOROOT)        /home/mothra/go/src/lsky-upload/internal/config (from $GOPATH)main.go:10:2: cannot find package &quot;lsky-upload/internal/httpapi&quot; in any of:        /usr/lib/go-1.15/src/lsky-upload/internal/httpapi (from $GOROOT)        /home/mothra/go/src/lsky-upload/internal/httpapi (from $GOPATH)main.go:11:2: cannot find package &quot;lsky-upload/internal/utils&quot; in any of:        /usr/lib/go-1.15/src/lsky-upload/internal/utils (from $GOROOT)        /home/mothra/go/src/lsky-upload/internal/utils (from $GOPATH)\n\n但修改了之后问题更多了……来来回回搞了半小时，没解决\n3. 解决构建问题  看了一堆没用的博客，说要改环境变量，配置项什么的……最终还是字最少的最有用。其实就是我的 go 版本太低了，更新一下新版本就行了\nhttps://blog.csdn.net/qq_35633748/article/details/129436192\n\n我在 deepin 下的 go 是用 apt-get 安装的，版本是 1.15，而最新版已经是1.20.4 了\nhttps://golang.google.cn/dl/\n\n去这上面下载了 linux 下的安装包\nwget https://golang.google.cn/dl/go1.20.4.linux-amd64.tar.gz\n\n操作之前，先将旧的 golang 给卸载了\nsudo apt-get remove golangsudo apt autoremove\n\n输出结果如下\n~/Downloads$ sudo apt-get remove golang请输入密码:验证成功  正在读取软件包列表... 完成  正在分析软件包的依赖关系树       正在读取状态信息... 完成       软件包 golang 未安装，所以不会被卸载  下列软件包是自动安装的并且现在不需要了：  golang-1.15 golang-1.15-doc golang-1.15-go golang-1.15-src golang-doc golang-go golang-src使用 &#x27;sudo apt autoremove&#x27; 来卸载它 (它们)。 升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。~/Downloads$ sudo apt autoremove正在读取软件包列表... 完成  正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包将被【卸载】：进度：[93%] [#############################################################################################.......] 升级了 0 个软件包，新安装了 0 个软件包，要卸载 7 个软件包，有 0 个软件包未被升级。解压缩后将会空出 363 MB 的空间。您希望继续执行吗？ [Y/n] y\n\n卸载旧版本后，解压刚刚下载的新版本包\nsudo tar -C /usr/local -xzf go1.20.4.linux-amd64.tar.gz\n\n然后修改环境变量\nsudo vim /etc/profile\n\n在末尾添加，:wq保存并退出\nexport PATH=$PATH:/usr/local/go/bin\n\n但是不知道为什么 source 找不到命令，于是重启了机器（我用的虚拟机）\nsudo source /etc/profile\n\n$ sudo source /etc/profilesudo: source：找不到命令\n\n重启之后，看看版本\ngo version\n\n已经是最新的了\n$ go versiongo version go1.20.4 linux/amd64\n\n克隆作者的仓库\nhttps://github.com/YGXB-net/lsky-upload.git\n\n或者用 gitee 的\nhttps://gitee.com/YGXB-net/lsky-upload.git\n\n克隆后进入仓库路径\ncd lsky-upload\n\n进行构建\ngo build\n\n一切正常，不会有输出。ls -l查看文件，会多一个 lsky-upload 可执行文件\n-rwxr-xr-x 1 mothra mothra 8060493 5 月   7 12:12 lsky-upload\n\n\n先执行一下这个文件，会有初始配置文件的输出。也是根据仓库的 README 配置成你的图床 url 和 token 就行了\n./lsky-upload\n\n4. 配置 typora这时候就只需要将 typora 的上传命令修改为这个可执行文件，就可以了！\n\nPS: deepin 上的 typora 是我在 deepin 的软件商店里面下载的typora- 免费版，版本是0.11.18\n\n\n点击验证测试一下能否正常上传，没问题！\n\n","categories":["差生文具多"],"tags":["图床","Typora"]},{"title":"【图床】gitee 图床寄了，批量转存文件到阿里云 OSS","url":"/posts/2474096396/","content":"本篇博客将教您如何转移 gitee 图床到阿里云 OSS\n\n\n\nGitee 的问题  最近不知道大家的 gitee 图床 是否出现了抽风现象\n简单的说来就是，gitee 仓库里面的图片都能正常访问，picgo 也能正常上传\n但是本地 typora&#x2F;obsidian 都无法渲染出图片，甚至出现了图片全变成了 gitee 的 logo 的情况\n\n虽然不知道它现在恢复没有（因为我已经全部转移到阿里云 OSS 了），但还是建议大家不要用 gitee 作为图床了！因为我之前使用的时候就出现了好几次  无法渲染图片  的情况\n\n当时我去问了一个大佬，大佬的回复是：“不提倡用代码仓库做图床”\n\n在我的另外一篇博客里面也提到了这个问题\n\n阿里云 OSS 我已经用了 3 个月了，它比 gitee 稳定很多，目前没有遇到过无法加载图片的问题。\n\n下面给大家提一个 gitee 转阿里云图床的解决方案，理论上来说这个方案是所有图床都能通用的\nGitee 批量转阿里云 OSS\n思路来自于 CSDN 用户@1nnoh\n\n1. 配置阿里云 OSS既然要转阿里云图床，第一步肯定是配置图床了\n这个我之前写过博客，比较详细，大家直接点击下面的链接阅读即可！\n\nTypora+PicGo+ 阿里云 OSS 搭建博客图床（超详细）\n\n\n2. 批量上传  将 gitee 的  图床仓库  全部下载下来\n\n建议把图片文件夹打包备份一下，以免出现问题\n以下是我之前作为图床的代码仓库，图片全部存放在 img 文件夹里面\n\n你可以在阿里云 OSS 的 bucket 里面创建一个同名文件夹（不同名也没关系）\n然后把这些图片都上传进去\n\n阿里云 oss 支持多文件上传，建议大家在已有 bucket 中创建一个新文件夹，避免出现覆盖 bucket 已有文件的情况\n\n如果是新 bucket，随便创一个文件夹就 OK 了，之前的博客里面都有提到\n\n\n在配置阿里云 OSS 的教程中，我建议大家打开 picgo 的  时间戳重命名，因为这个可以防止同名文件的冲突\n\n不管你有没有开启这个功能，都不影响后续的操作（没开的建议开一下）\n3. 比较链接区别  上传完毕后，我们来比较一下阿里云和 gitee 的链接差别\n\n你的链接可能和我的不同，请以实际为准\n\n# giteehttps://gitee.com/ 你的 gitee 名 / 仓库名 /raw/master/ 文件夹名字 /202108160849879.png# 阿里云 osshttps:// 你的 bucket 名字.oss-cn- 地域.aliyuncs.com/bucket 下文件夹的名字 /202108160849879.png\n\n可以发现，其实 gitee 和阿里云 OSS 的链接都是以  图片的文件名结尾  的\n也就是说，我们只需要扫描我们本地的 md 文件，将原本 gitee 图床链接的前面部分，整体替换成阿里云链接就可以了！\n即：将 gitee 链接\nhttps://gitee.com/ 你的 gitee 名 / 仓库名 /raw/master/ 文件夹名字 /\n\n替换成\nhttps:// 你的 bucket 名字.oss-cn- 地域.aliyuncs.com/bucket 下文件夹的名字 /\n\n后面的文件名无需更改\n\n4. 批量修改\n我们需要用到文本编辑神器 notepad++\n这个工具非常实用，除了可以修改文件编码格式外，还可以完成批量查找文件内容等很多事情，本文的情况就可以用它来完成\n\n打开 notepad++ 后，在顶部的  搜索  按钮中，选择在文件中查找，然后选择你的 markdown 文件路径\n\n打开这个面板后，想必已经不需要我教你怎么修改了吧？😂\n再次提示，修改前请先备份一遍你的文件！\n\n\n你还可以用 VSC 来批量修改文件中的内容  参考  软通达的博客👉https://cyddgh.github.io/post/20220304175458/\n\n\nThe end到这里，操作就完成了，不出意外的话，所有的链接都被替换了\n你可以愉快地继续使用阿里云 OSS 作为你的图床了！\n\n如果这对你有帮助，还请在下方评论说一下哦！\n\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【MD】用 Obisidian 的你一定不能忽略的图片保存问题","url":"/posts/4288058497/","content":"[TOC]\n问题来源😥今天在 obsidian 使用 kanban 插件 的时候，发现 obsidian 其实是可以把插入的图片自动保存在本地库文件夹里面的。\n\n这一点其实非常重要！\n之前我  从 gitee 图床转到阿里云 OSS，最大的原因就是上学期期末  复习高数  的时候，自己写的高数笔记里的图，因为 gitee 的短暂更新导致无法加载！最后过了差不多 1h 图片才能正常加载出来，相当于白白浪费复习时间！\n\nTypora+PicGo+ 阿里云 OSS 搭建博客图床\n\n你想想，这还是在学校里，耽误点时间总归不会出现什么“要人命”的大事。但如果是工作中你写的一些日志笔记，因为图床网站的无法访问而暂时看不见，那不就寄了吗？\n更别提图床是保存在网络中的，总归会有些  隐私问题。就连百度网盘都扫用户文件，我们用户又怎能知道阿里云有没有干这种事呢？\n\n如何解决？🕵️‍♂️1.typora 设置图片保存  查找网络资料，看到了这篇博客\n\ntypora 设置图片根目录_用 Obsidian 一定要注意的图片和笔记问题！\n\n里面讲到了可以用 typora 来解决这个问题\n打开 typora 左上角的  文件 - 偏好设置\n依照下图设置\n\n可以看到，复制进去的这个图片（其实就是上面这个截图）显示出了它的  相对路径，并正常渲染。\n\n打开本地文件夹，可以看到 typora 在你当前这个 md 文件的目录下创建了一个 photo 文件夹，将你贴的图复制进了这个文件夹中\n\n\n同时如果我们在 obsidian 打开这个 md 文件，可以看到图片是能正常显示出来的\n\n到这里，其实我们的问题已经解决了！\n\n2. 博客问题  但是！这好像和我们当初使用图床的目标冲突\n再来看看下面这个图片，当我把这篇博客从 typora 复制到 CSDN 上的时候，它肯定会保存失败\n\n\n\n因为图片本身是在本地硬盘里，CSDN 无法原力读取你硬盘里的文件，自然无法转存这张图片了！\n解决这个问题又有两个新的方法~\n2.1 每次编写不同文件的时候，进 typora 设置进行更改  当我写  博客  的时候，typora 需要这样设置，即可借助 picgo 自动上传我复制进去的图片到  图床  里，也能正常复制到 CSDN 中（教程在博客开头的链接里）\n\n而当我写  个人随笔 / 日记 / 学习笔记  这类并不打算上传到博客里的内容时，就可以把它改成上面提到的本地存储方式\n但是这样非常不方便！万一哪一次写博客的时候忘记改回来了，上传博客的时候就想  马良  了（我是觉得我肯定会忘，这个亏吃不得）\n\n2.2 分开两个软件进行写作  别急，刚开头不是提到了，我是在 obsidian 里面发现这个功能的嘛？\n现在我们要做的，就是将 obsidian 也设置为同样的保存方式，让复制进去的图片自动保存在本地目录里。\n这样用 typora 写博客，obsidian 写自己的东西，两全其美！\n\n3.obsidian 设置图片保存  在1.typora 方式  提到的那篇博客里面，作者发现了 obsidian 复制图片的时候使用的是自己的格式![[]]\n这种格式并不是所有 markdown 编辑器都认识！\n\n所以我们需要更改 obsidian 的设置，让它变成大部分 markdown 编辑器通用的 ![]() 形式\n\n先看看你的 obsidian 用的是不是最新版本0.13.33，如果不是，先更新一下\n\n\n打开 obsidian设置 - 文件与链接，找到下图的这几个设置。如果你没有更改过，默认的设置和图片里面应该是一样的\n\n我们需要改成以下的样子\n\n再次尝试插入图片，可以看到新插入的这个图片已经变成了 md 通用的 ![]() 形式\n\n再次用 typora 打开这个文件，可以看到第一个图片链接依旧不认识，但是第二个图片已经被正常加载出来了！\n\nobsidian 的设置也搞定了！\n今后写作的时候，就可以分开两个软件进行写不同的内容啦！\n\n一些提升 obsidian 编辑体验的插件  最后，你可能会想，obsidian 的使用体验没有 typora 好呀！\n\ntypora 可以实时渲染，obsidian 需要单独切换\ntypora 有打字机模式，obsidian 需要滚来滚去\n\n欸，别急，这里给大家推荐几个提升写作体验的插件，装了之后，上面这俩功能就都有啦！\n\n\n更新：发现这个功能其实 obsidian 已经自带了，但是我在  编辑器  中选择了  旧版编辑器  导致没看到这个功能。既然自带了就没必要下插件啦！但是问题又来了，下面这个打字机插件只有  旧版编辑器  才有效。如果你需要这个模式，那就使用上面的渲染插件 + 这个打字机插件来创作吧（本人现在就是这么做的）你觉得事情真的有那么简单吗？并不是的！更新了打字机插件到 0.2.1 以后，发现他已经支持了新版本编辑器了，芜湖起飞！\n\n下面还有 picgo 上传图床的插件\n以及一个自动粘贴链接的插件\n\n\n最后还有这个插件，可以优化 obsidian 选中中文句子的分词功能\n\n安装完这些，使用体验就很接近 typora 啦！\n当然我还是更喜欢用 typora 来编辑\n\n结语😋依照这篇博客设置完后，就能更好地  分开写作 私人内容和博客文件啦\n以后也可以放心地往 md 文件中加图片了，毕竟在本地里，谁都看不到\n\n不过也要考虑到本地文件大小问题，别把你的 OneDrive 塞满图片导致空间不够用了。那就得掏💴升级容量了，我现在只有免费的 5GB\n有些图片可以考虑用  光影魔术手  等软件来减小文件体积，比如手机拍的笔记图，没必要那么高清，6mb 降到 500kb 都还能看清楚\n\n你学废了吗？\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["差生文具多"],"tags":["图床","typora","obsidian"]},{"title":"【Git】提交信息规范 | 转载","url":"/posts/998453050/","content":"git 代码提交规范的那些事\n\n\n1. 提交格式type(scope): message\n\n\n2. 参数介绍2.1 typetype：指的代码的提交类型，不同的提交类型表示对应不同的代码改动，比如：\n\nfeat：新功能的开发\nfix：bug 的修复\ndocs：文档格式的改动\nstyle：代码格式改变\nrefactor：对已有的功能进行重构\nperf：性能优化\ntest：增加测试\nbuild：改变了 build 工具\nrevert：撤销上一次的 commit 提交\nchore：构建过程或辅助工具的变动\n\n2.2 scopescope：用于说明 commit 影响的范围，比如：权限模块、还是首页\n2.3 messagemessage：对提交的代码做一个简短的说明，不能过长。\n\n需要注意的是，提交格式并没有一个固定的规范，不管你最后采取了什么格式，一定要遵守一个理念：那就是  同一仓库  的所有代码提交需要采用一个固定的格式。不能出现一个仓库里面用两个风格的 git commit 的情况\n作者：听书先生  链接：https://www.jianshu.com/p/2ab3a991d1f9  来源：简书  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Linux】如何使用 ssh 密钥配置 git","url":"/posts/3625274788/","content":"之前的  腾讯云搭建 Linux 环境博客  中包含了本文，但是由于在我的环境下 SSH 配置 git 无法多次生效。\n为了避免误导，所以把这一部分单独成文，并删除原文中相关部分\n\n22-06-19 更新：问题已解决，可放心阅读本文！\n\n\n\n[TOC]\n1. 创建 SSH 密钥 ①本地创建 ssh 密钥 输入这个语句（github 啥的都是同理）\nssh-keygen -t rsa -C &quot; 你的 gitee 账户邮箱 &quot;\n\n然后会弹出来让你输入一个  文件名 ，直接连按 3 次回车 跳过\nEnter file in which to save the key (/home/muxue/.ssh/id_rsa): id_rsa_用户名Enter passphrase (empty for no passphrase): Enter same passphrase again: \n\n后面出现的 passphrase 语句直接回车跳过，出现下面这个就是配置好了\nYour identification has been saved in id_rsa_用户名……# 后面还有很多，还出现了一个文字组成的图片\n\n②把 SSH 公钥添加到 gitee&#x2F;github 账户上  直接 cd .ssh 进入隐藏文件夹，cat你刚刚生成的 pub 文件，将内容复制\ncd .sshcat id_rsa.pub\n\n你还可以使用 Xftp 打开刚刚创建的密钥文件，把里面生成的内容复制一份\n\n\n在 gitee 账户设置中找到 SSH 公钥，添加即可\n\ngithub 同理（github 中文页面是用了油猴插件）\n\n同一个密钥是可以在多个平台用的，但是同一个密钥不能在多个设备用。\n否则 push 的时候，远端服务器会禁止并提示你当前密钥有另外一台设备在使用。\n为了安全性，建议一台主机一个 ssh 密钥，并定时轮换（重新生成新的，替换掉旧的）\n③测试 ssh 连接  搞定密钥后，测试是否可以用 ssh 访问我们的远程仓库\nssh -T git@gitee.com//github 只需要把 gitee 改成 github 就行了\n\n出现下面的就是成功了\n\n\n④该方式有错误（已解决）SSH 方式不知为何，在我的云主机上，只有当次设置有效，重新打开终端连接云服务器（云服务器没有重启）SSH 就会失效。在我的 Linux 用户目录下以及我朋友的用户目录下都出现了这个问题！\n\n如果你也出现了这个问题，请直接使用  账户密码方式，而不是 SSH\n\n22-06-19 更新：在原先博客中，提到了下面这个本地添加 ssh 密钥的步骤（该步骤错误，请不要执行）\n\n执行下面两个语句，添加你的 ssh 密钥到设置中。注意，生成的密匙应该是在\nssh-agent bashssh-add ~/.ssh/id_rsa_用户名\n\n\n\n实际上，出现无法多次使用的问题，就是因为这莫须有的一步操作！\n正确方法是：别执行这一步，就 OK 了！\n如果你之前做了这一步，那就重新创建一个 ssh 密钥\n\n2. 克隆远程仓库  使用 mkdir 文件夹名 创建一个文件夹，CD进去后，克隆我们的远程仓库\ngit clone 远程仓库的 ssh 链接\n\n因为现在我们配置的是 SSH 方式，所以要使用 SSH 链接而不是https\n\n\n克隆成功后，cd进入该目录，git status查看 git 仓库当前状态，应该是 up-to-date 的。\n3. 上传代码  随便创建一个新的文件，测试能否正常 PUSH 到远程仓库\n\n这部分设计到 git 命令行操作，如果你不会，可以搜几篇 git 的博客学习一下\n\ngit add 文件夹 # 添加需要上传的文件路径git commit -m &quot; 输入 push 信息 &quot; #git push 的信息git push # 和远程仓库同步\n\n\n因为我们没有设置用户名和邮箱，所以出现了下面的报错\n\n用下面的两行命令，可以  单独设置  当前仓库的用户邮箱和用户名。如果需要  全局设置 ，则依照上图中的操作，使用git config --global 语句即可\ngit config  user.email &quot;you@example.com&quot;git config  user.name &quot;Your Name&quot;\n\n同时我们需要用下面的这个命令，设置让 git 默认 push 到当前分支上\ngit config --global push.default current\n\n\n再次测试git push，成功！\n\n\n有任何问题都可以在评论区提出哦！\n","categories":["玩上Linux"],"tags":["Linux","git"]},{"title":"【Git】如何修改本地仓库的用户名和邮箱","url":"/posts/3842037185/","content":"最近我修改了我 gitee 和 github 的用户名还有邮箱，所以需要对本地仓库配置的用户名和邮箱进行更改\n\n\n1. 命令 刚开始我使用的是如下命令\ngit config --global user.email &quot; 邮箱 &quot;git config --global user.name &quot; 用户名 &quot;\n\n但是很不辛，这个命令没有用，因为它是用来初始化你的 git 环境的，对已有的 git 仓库不起作用\n但是我们在 linux 下可以添加上另外一个参数来实现\ngit config --global --replace-all user.email &quot; 邮箱 &quot; git config --global --replace-all user.name &quot; 用户名 &quot;\n\n这样就修改成功了\n\n\n这个命令在 windows 下似乎无法识别，会弹出 git 的命令行帮助\n\n\n但是，修改成功后的提交，只对未来的提交有效；这里必须得吐槽一下 gitee 和 github 统计提交的不同之处\n\ngitee 统计提交依据的是用户名 + 邮箱，只要有一个不对就无法统计\ngithub 统计提交只依据邮箱，只要你邮箱对了，用户名是不管你的\n\n所以要想让 gitee 的统计能生效，那就必须要修改之前所有提交信息中的用户名和邮箱\n\n2. 修改之前提交中的用户名和邮箱\n参考博客\n\n复制如下代码到一个本文编辑器里面，将内部的邮箱和用户信息修改\ngit filter-branch -f --env-filter &#x27;OLD_EMAIL=&quot; 原来的邮箱 &quot;CORRECT_NAME=&quot; 现在的名字 &quot;CORRECT_EMAIL=&quot; 现在的邮箱 &quot;if [&quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot;]then    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [&quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot;]then    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&#x27; --tag-name-filter cat -- --branches --tags\n\n随后将其粘贴到 git 命令行中，回车执行\n\n\n执行完毕，就能看到所有 git 提交的用户名和邮箱都修改成功了！接下来要做的就是强制提交\ngit push -f\n\n强制提交了之后，之前显示不出来的信息和小绿点，现在也能正常显示了\n\n如果用上面的命令修改失败的话，那就尝试执行下面的命令\ngit filter-branch -f --index-filter &#x27;git rm --cached --ignore-unmatch Rakefile&#x27; HEAD\n\n随后再重试上面的命令，应该就 OK 了\n","categories":["差生文具多"],"tags":["Linux","git"]},{"title":"【Git】解决 git status 中文乱码问题 | 转载","url":"/posts/3422840311/","content":"解决 windows 下命令行中 git status 中文乱码问题\n\n\n起因  在项目下输入 git status 之后，出现如下情况：\n\n在线搜索了一下，发现是 git 添加了如下特性：\n\ngit 参考文档：https://git-scm.com/docs/git-config\n问题  根据上面的文档得知，git 对超过 0x80 的字符都会以八进制输出，由于中文以 UTF-8 保存，所以上面的文件路径输出了一堆的八进制  转义  代码，这对用户极其不友好。\n文档给出的方案是 -z，通过 -z 选项的确可以输出正确的中文，但是却缺少了详细信息：\n\n所有的输出全在一行，对用户也不好友。\n查阅 git status 命令文档可知：\n\n该选项会以 NUL 为一行的几位，但是终端不能识别 NUL 结尾，所以终端不会  自动换行。\n解决  那么最终的解决办法：关闭这个特性。\ngit config --global core.quotePath false\n\n\n再次执行 git status：\n\n一切回归正常。\n然后 git add python 添加所有修改过的文件：\n\n更多  默认情况下，git 会将入库的文件的行尾符替换为 LF，这是因为 git 原生的工作环境是 linux&#x2F;unix，而我目前工作环境是 windows，所以这个也挺正常的。当下次在 windows 下检出分支的时候，会自动将 LF 替换为CRLF。\n这个警告并不会带来什么问题，完全可以忽略。\n版权声明：本文为 CSDN 博主「lengye7」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/lengye7/article/details/129208899\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】解决 kex_exchange_identification 错误","url":"/posts/1015332822/","content":"kex_exchange_identification: Connection closed by remote host\n\n\n今天在 windows 命令行下准备上传文件到 github 的时候，ssh 出现了如下问题\n$ ssh -T git@github.comkex_exchange_identification: Connection closed by remote hostConnection closed by 20.205.243.166 port 22\n\n按照  老办法，重新生成了 ssh-key 并添加到了 github\n再次测试，依旧是此报错，可奇怪了\n\n于是百度了一下\nssh -Tv git@github.com\n\n用了这个命令，没想到就好了\nHi musnows! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.debug1: channel 0: free: client-session, nchannels 1Transferred: sent 3136, received 2936 bytes, in 0.7 secondsBytes per second: sent 4251.8, received 3980.7debug1: Exit status 1\n\n不过，也可能不是这个命令的作用，恐怕就是玄学网络问题罢了\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】解决 push 时遇到的 RPC 413 和 520 错误","url":"/posts/89600062/","content":"解决 git push 遇到 413 和 510RPC 错误\n\n\n说明  如题，在使用 git 上传我的 hexo 配置仓库到我自己搭建的 gitea 上时，遇到了这个报错。\n说明：该仓库已在 gitea 中存在，但是很久没有更新过（数个月），一次 push 的更新量较大\n所以就遇到了这个报错！下面给出两个报错的完整输出\nPS D:\\HEXO\\blog&gt; git push nasEnumerating objects: 30332, done.Counting objects: 100% (30332/30332), done.Delta compression using up to 16 threadsCompressing objects: 100% (12271/12271), done.Writing objects: 100% (30332/30332), 54.44 MiB | 127.27 MiB/s, done.Total 30332 (delta 10987), reused 29639 (delta 10321), pack-reused 0error: RPC failed; HTTP 520 curl 22 The requested URL returned error: 520send-pack: unexpected disconnect while reading sideband packetfatal: the remote end hung up unexpectedly\n\nPS D:\\HEXO\\blog&gt; git push nasEnumerating objects: 30332, done.Counting objects: 100% (30332/30332), done.Delta compression using up to 16 threadsCompressing objects: 100% (12271/12271), done.Writing objects: 100% (30332/30332), 54.45 MiB | 135.99 MiB/s, done.Total 30332 (delta 10984), reused 29639 (delta 10321), pack-reused 0error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413send-pack: unexpected disconnect while reading sideband packetfatal: the remote end hung up unexpectedly\n\n解决思路  第一步当然是百度了，百度到了这篇知乎文章\n\n知乎文章 https://zhuanlan.zhihu.com/p/359316694\n\n先依照第一个步骤，设置本地的 buffer 大小，再去尝试 push\ngit config --global http.postbuffer 524288000\n\n配置完毕这个命令后，原本是 520 的报错，变成了 413 报错\nerror: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413\n\n再看文章内的分析\n\n413 Request Entity Too Large服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。\n\n考虑到我的云服务器是用 nginx 来反代 gitea 的，所以就采用文章中的第三步，修改 nginx 配置；\n在 gitea 的 nginx 配置文件中的 server 体内新增了如下限制\nclient_max_body_size 200m;\n\n重新启动 nginx，就搞定了！\nPS D:\\HEXO\\blog&gt; git push nasEnumerating objects: 30332, done.Counting objects: 100% (30332/30332), done.Delta compression using up to 16 threadsCompressing objects: 100% (12271/12271), done.Writing objects: 100% (30332/30332), 54.44 MiB | 136.63 MiB/s, done.Total 30332 (delta 10987), reused 29638 (delta 10321), pack-reused 0remote: Resolving deltas: 100% (10987/10987), done.remote:remote: Create a new pull request for &#x27;hexo&#x27;:remote:   https://gitea.musnow.top/musnow/HexoBlog/compare/main...hexoremote:remote: . Processing 1 referencesremote: Processed 1 references in totalTo https://gitea.musnow.top/musnow/HexoBlog.git * [new branch]        hexo -&gt; hexo\n\n成功 push 到 gitea 的远程仓库！\n","categories":["差生文具多"],"tags":["git","nginx"]},{"title":"【Git】如何同步 Gitee 和 Github 的仓库（超简单）","url":"/posts/2629909823/","content":"本篇博客的设置方法同样可以适用于 gitlab 等其他平台\n不多 bb，直入主题⏲\n\n\n实现两个仓库的同步 1. 准备两个仓库 分别在两个平台创建一个相同名字的仓库，当然，你也可以在 a 平台上导入 b 平台已有的仓库，github 和 gitee 目前都支持从别的平台  导入仓库\n这部分操作想必大家都会，就不演示了\n2. 克隆到本地  需要注意的是，你要保证其中一个是主仓库。如果是  多人合作仓库  的话，想两个平台的远程仓库同时多人合作并保持同步是相对困难的。\n\nhttps://gitee.com/musnow/LetsOJ\n\n\n以我创立的这个多人 OJ 打卡仓库为例，现在我想得到的效果是，我和朋友们在 gitee 上面进行打卡协作，然后我通过 git 操作将这个仓库同步到 github 上面，仅供展示\n\n当然如果有小伙伴愿意用 github 进行 fork 和 pull request 操作那我也是举双手双脚赞同 + 欢迎的\n\n需要做的是，既然 gitee 是主战场，那就对 gitee 进行克隆操作\ngit clone https://gitee.com/musnow/LetsOJ.git\n\n\n3. 设置第二个仓库的 url克隆完毕后，直接进入该仓库的 .git 文件夹，修改 config 文件\n\n在原本 gitee 的 url 后面，添加 github 的仓库 url\n\n执行 git remote -v，你可以看到 github 链接的仓库也显示了出来，后面带有push 后缀，代表我们只能往这个仓库上传，并不能执行 git pull 操作\n\n这时候的设置已经完成了，你可以进行一次修改文件后的 git push 操作，两个仓库都可以同步！而且上传的编号都是相同的！\n\n\n这时候的基本设置就已经完毕了！如果你还想做到能从 github 仓库中进行 pull 操作，那就接着往下看\n4. 关于 pull 操作  前面提到，github 仓库的 url 后面有一个 push 后缀，代表我们不能从这个仓库里面获取更新\n你如果修改了 github 的仓库，执行 git pull 操作，会显示 Already up-to-date. 因为系统检索的是 gitee 仓库的修改，并不知道你的 github 仓库有无修改\n\n这时候可以执行下面的语句\ngit remote add github git@github.com:musnows/Lets_OJ.git\n\n再次 git remote -v，可以看到在远程仓库中多出来了一个 github 为名字的仓库类型，而且这一次的仓库是可以fetch 也就是获取内容的\n\n这时候你可以执行\ngit pull github\n\n即可获取 github 仓库的最新更新\n这样就实现了 gitee 仓库和 github 仓库的多端同步啦！\n5. 效果演示  现在我让朋友在 gitee 的仓库中上传一个内容\n\n执行git pull，可以看到系统从 gitee 的仓库中更新了内容\n\n这时候你执行git status，理论上来说会出现新文件对吧？并不会\n\n毕竟这时候系统检查的还是 gitee 主仓库，内容都是完全同步的\n我们也不需要写 git add 和 git commit，直接执行git push 即可！\n\n再打开 github 瞅瞅，你会发现已经同步成功了！\n\n\n提醒  强烈建议：如果是多人合作仓库，请确保在某一个平台作为主战场，另外一个平台仅作展示（留档）使用！\n不过我发现了一个好事，那就是当我从 gitee 导入这个仓库到 github 的时候，github 不仅会自动同步小绿点，还会将这个仓库的协作者同样显示出来（前提是协作者在 github 上面有  同邮箱注册  的账户）\n\n一些问题的解决 1. 关于 github 克隆网络访问问题 关于克隆 &#x2F; 上传 github 问题，很多都是因为使用 https 链接导致的\n我们需要使用 ssh 私钥来实现 github 仓库的免密操作\nssh-keygen -t rsa -C &quot; 你的 gitee/github 账户邮箱 &quot;\n\ncd进入 .ssh 隐藏文件夹，找到生成的密钥 pub 文件\ncat查看该文件里面的内容，将其复制\n在 github&#x2F;gitee 的个人设置页面，你都能找到 ssh 密钥的添加处\n\n\n添加 ssh 密钥后，你就可以通过 ssh 链接来对 github 进行操作了，这时候一般就不会出现网络问题了！\n2……还没遇到……😂\n结语  关于这项操作，网络上有很多相似内容，但总有些货不对板，不符合我的需求。所以就自己写了个博客\n有任何问题都可以在评论区提出！\n","categories":["玩上Linux"],"tags":["Linux","git"]},{"title":"【Git】如何修改本地仓库的用户名和邮箱","url":"/posts/3842037186/","content":"如果你想在 gitea 上面加密存储一些数据（比如个人的密码）之类私密的东西，可以尝试用 git-crypt 加密文件后再上传\n\n\n\n比如有些老哥担心 git 托管服务商会偷看自己的文件，额……咱也不能完全否认这可能性吧\n\n如何使用  以下演示的只有 windows 系统能用\n1. 安装\noholovko&#x2F;git-crypt-windows\n\n在上面的项目中下载 exe 文件，放入你电脑 git 安装路径的 git/cmd 目录中，即可使用\n在电脑的任意位置使用 git 的命令行输入 git-crypt 确认正确安装\n2. 使用  在需要加密的仓库中输入以下命令\ngit-crypt init\n\n然后输入 status 命令查看状态\nPS D:\\Program Files\\nas\\MyPWD&gt; git-crypt statusnot encrypted: .gitignorenot encrypted: README.mdPS D:\\Program Files\\nas\\MyPWD&gt;\n\n添加 .gitattributes 文件，键入以下格式的内容\n需要加密的文件路径或者文件名 filter=git-crypt diff=git-crypt\n\n此时先将需要加密的文件移出本仓库，commit上传 .gitattributes 文件，再将需要加密的文件移动回来\n此时再查看状态，会发现已经加密了\nPS D:\\Program Files\\nas\\MyPWD&gt; git-crypt statusnot encrypted: .gitattributesnot encrypted: .gitignore    encrypted: PWD/napd.mdnot encrypted: README.mdPS D:\\Program Files\\nas\\MyPWD&gt;\n\n此时再使用 git 三板斧，此时被添加到远端的文件就已经是加密过后的了\n3. 解密  使用下面的命令导出密钥\ngit-crypt export-key 文件 key 的名字\n\n因为是个人使用，为了避免以后无法打开此文件，应在多处存放此 key（但是不要存云盘里面）\n只有同时获得  仓库文件 +key才能解密出此项目中的内容！\n\n当然，最初的本地项目也是明文的\n\n使用 key 解密仓库文件，即可看到明文内容\ngit-crypt unlock /path/to/key\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】在 Windows CMD 中和 VScode 中配置已经安装好的 git","url":"/posts/932852149/","content":"本篇博客将教您如何将 sourcetree 下载好的 git 导入到 windows 的 cmd 进行使用\n\n\n问题引出\n我使用系统为win11。win10 的操作理应相同，只不过设置的位置可能有差异\n\n我现在使用 git 主要用的是 sourcetree 的可视化界面，可以清楚地看到每一次提交的 diff 和提交历史，非常好用，也强烈推荐大家使用 【使用教程】\n\n不过当你初次安装 sourcetree 的时候，他会帮你下载一个 git\n如果系统中已有 git，也  可能  会被移动到 sourcetree 自己的内置使用目录中\n\n这样就会对我们在其他地方使用 git-cmd 造成一定的不便。\n对于 git 仓库，sourcetree 会提供一个命令行的选项。但是需要从这里面打开肯定不如直接右键选择 windows cmd 方便！\n\n不过对于我来说，一个非常棒的优点就是——干掉了右键菜单的两个按钮😂\n所以现在我们想做到的就是让 windows 自带的 cmd 也可以直接用上 git，这样就不担心单独使用 git-cmd 不方便了\n\n1. 设置新的终端路径  依据上面 sourcetree 给出的路径，找到被藏起来的 git\nC:\\Users\\ 用户名 \\AppData\\Local\\Atlassian\\SourceTree\\git_local\n\n注：AppData 文件夹是隐藏的，需要打开文件资源管理器中的  查看隐藏文件  选项\n\n在随便一个地方右键，打开 cmd\n\n右键上方边栏，选择  设置\n\n划到最底下，选择添加一个新的配置文件\n\n这样设置即可，git 的图标也是在我们刚刚打开的 git 目录中可以找到的\n\n注意，命令行要选择 bin 中的 bash.exe 而不是git-bash，后者会打开 git 自己那个老旧的命令行终端\n\n\n这时候，我们就可以在顶部的小三角图标中选择 git bash 进行使用了！\n\n\n不过！这时候如果你在 windows powershell 里面打出 git，还是会提示找不到 git 命令。如果每一次都需要在下拉菜单中选择，那还是很麻烦呀！\n\n2. 设置环境变量  打开  电脑设置 - 系统 ，拉到最底下，找到 系统信息\n\n选择  高级系统设置\n\n在  高级  面板中打开  环境变量\n\n在下方系统变量中找到 path，选择 编辑\n\n在里面新建一个 git 的环境变量，填入 cmd 文件夹的路径，注意是 cmd 文件夹！\n\nC:\\Users\\ 用户名 \\AppData\\Local\\Atlassian\\SourceTree\\git_local\\cmd\n\n\n填入后确定保存，再次打开windows power shell，输入 git\n出现下方的 git 命令帮助，那就大功告成！\n\n\nvscode 中 git 路径配置  来都来了，顺便说一嘴 vsc 中的 git 路径配置吧！\n在设置中搜索 git path，点击 在 settings.json 中编辑\n\n在 git.path 中填入路径即可！\n注意 ：因为有转义，所以路径分隔符\\ 需要改成两个\\\\\n\n点击左侧 git 管理页面，看到正常显示出仓库就 OK 啦！\n\n","categories":["差生文具多"],"tags":["git"]},{"title":"【教程】Gitee 如何下载单个文件","url":"/posts/2829756684/","content":"本篇博客将教您如何在 gitee 上下载单个文件\n\n\n引出问题  不知使用 gitee 的你，有没有遇到过需要下载某个仓库文件的情况？\n\n比如下面这个仓库，是 @宏沉一笑 大佬转载 obsidian 的插件的仓库  链接\n\n\n点击下载，你会发现 gitee 开始给你打包整个仓库文件，一个几百 m 的仓库怎么说也要几分钟才能下完。可是，我只是需要某一个主题或者插件，gitee 却不能单文件或者单文件夹下载，这个时候又要怎么弄呢？\n\n解决问题  解决这个问题的方法非常简单！\n只需要用 chome 或者  新版 edge 浏览器，就能使用一个插件，来解决这个难题！\n我们可以在 edge 设置里面打开扩展商店，搜索GITEE\n\n下载 gitee 助手即可！\n\n安装这个扩展以后，重启浏览器，再次打开 gitee\n\n可以看到，每个文件之后出现了单独的下载图标，点击它即可下载单个文件了\n\ngitee 助手的代码也是开源的，主页链接👉点我\n\n大佬的提交绿点就是不一样\n\n\n结语  个人也建议大家直接用 edge 浏览器和微软自带的输入法（这两个现在已经做的很好了）\n避免其他国产流氓污染自己的电脑\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["差生文具多"],"tags":["git","图床"]},{"title":"【js】用 html+javascript 静态页面实现伪重定向","url":"/posts/1472038549/","content":"javascript 代码实现一个伪重定向\n\n\n1. 前言  本站的域名之前有修改过，但一些朋友的友链，和开往里面的链接尚未更新。旧的域名又米有备案，不能解析到国内服务器上用 nginx 进行 30x 转发。\n这时候我就想到了一招，用 js 的代码来实现一个 url 的切换，相当于一个伪重定向。因为是静态文件，能直接部署到 netlify 等平台上。\n百度了一下 js 是否支持这种语法，嘿，支持！\n那不直接开整！\n2. 代码  关于 http 的 30x 状态码，其代表站点域名或路径更改\n\n301 重定向：永久\n302 重定向：临时\n\nhtml 代码部分很简单，设置 body 和站点标题都为 301 重定向，告诉访问者，站点已经换了新的域名\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;\n\nscript部分，通过 window 获取当前的域名，判断域名是否为目标域名（下文代码中的  旧域名）\n如果不是，则什么都不做。如果是，则覆盖 url 到新域名。\n&lt;!-- 放在 head 后，body 前 --&gt;&lt;script&gt;var path = window.location.href;    console.log(&quot;current path:&quot;,path)// 打印到控制台    // 睡眠函数    function sleep (time) &#123;      return new Promise((resolve) =&gt; setTimeout(resolve, time));    &#125;    // 睡 500ms, 之后执行下面的内容    sleep(500).then(() =&gt; &#123;        // 如果 url 不是预先设定好的这个，则啥都不做        if (path!=&quot; 旧域名 1&quot; &amp;&amp; path!=&quot; 旧域名 2&quot;) &#123;          console.log(&quot;url not match, do nothing&quot;)        &#125;        else&#123;// 否则重定向          window.location.replace(&quot;https://blog.musnow.top/&quot;);        &#125;    &#125;)&lt;/script&gt;\n\n这里我还用 sleep 函数休眠了 500ms，否则切换很快，访客不注意的话，还不一定能发现 301 重定向。\n\n如果你不需要 sleep，那代码更少\n&lt;script&gt;var path = window.location.href;    console.log(&quot;current path:&quot;,path)    // 如果 url 不是预先设定好的这两个，则啥都不做    if (path!=&quot; 旧域名 &quot;) &#123;        console.log(&quot;url not match, do nothing&quot;)    &#125;    else&#123;// 否则重定向       window.location.replace(&quot;https://blog.musnow.top/&quot;);    &#125;&lt;/script&gt;\n\n但是，使用过程中，我就发现访问的 path 有的时候并不是严格等于我的域名的，后面可能会新增一些尾随参数。为了避免有尾随参数而导致无法重定向的问题。我去掉了 if 的判断\n&lt;script&gt;// 301 Moved Permanentlyvar path = window.location.href;    console.log(&quot;current path:&quot;,path)    // 睡眠函数    function sleep (time) &#123;      return new Promise((resolve) =&gt; setTimeout(resolve, time));    &#125;    // 睡 2000ms, 之后执行下面的内容    sleep(2000).then(() =&gt; &#123;      window.location.replace(&quot;https://blog.musnow.top/&quot;);    &#125;)&lt;/script&gt;\n\n3.netlify 部署  将刚刚写好的代码写入一个 index.html 文件，再放入一个文件夹（netlify 的上传只能上传文件夹）\n如果你想，还可以在文件夹里面放一个 favicon.ico 作为临时的站点 logo\n打开 netlify，找到 Add new site，选择手动部署\n\n在这里上传文件夹\n\n部署好了之后，可以在 domain settings 里面配置域名为你的旧域名\n\n4. 测试  先访问旧域名，显示 301 重定向的信息\n\n休眠的时间到了之后，就会被重定向到当前的站点\n\n目的达成！\n5. 添加上尾随参数  如果你的站点有部署 umami 或者百度统计等  访问统计  服务，则可以在源码中跳转的链接里面加上来源\nwindow.location.replace(&quot;https://blog.musnow.top/?utm_source= 旧域名 &quot;);\n\n这样，在访问统计中，就能得知有多少用户用了旧域名访问了你的站点\n\n","categories":["差生文具多"],"tags":["hexo"]},{"title":"【Git】Sourcetree 的初始化与使用","url":"/posts/2410861413/","content":"[TOC]\n前言  还在用小乌龟管理你的 git 本地代码吗？\n为何不来尝试一下，这款界面更加直观的 git 可视化 工具！\n\nsorcetree 官网👉https://www.sourcetreeapp.com/\n\n别看到英文官网就跑了，软件本身是  中文界面！\n\n\n注：本博文只讲述 sourcetree 初始化方式，并不讨论其与 TortoiseGit 的功能强弱\n\n什么？你还不知道 git 是啥？\n那还不赶快点击这篇博客了解一二！👇\n\n实习生 Git 不熟练，还没脸去问是种什么体验…\n\n\n1. 初始化  下载安装以后，你会看到以下界面\n若不需要用 bitbucket，选择跳过即可\n\n第二步，sourcetree 会让你下载这两个工具\n\n如果你的电脑里已经有了，它能检测出来安装位置\n如果你的电脑里没有这两个工具，它会自动帮你下载\n\n\n第三步，它会让你填写你的用户名和邮箱\n建议这里和你的 gitee 或 github 上的  用户名 &#x2F; 邮箱  同步！\n\n填写好后，点击下一步，会弹出这个界面\n选择 “否” 即可\n\n2. 克隆仓库  初始化完成后，会变成以下界面\n\n源路径：填写你的 gitee&#x2F;github 仓库链接\n目标路径：选择一个本地的  空文件夹，注意路径不要有中文\n名字：填写一个会在 Sourcetree 里显示的仓库名字\n\n\n 那么问题来了，要怎么找到你的仓库链接呢？👇\n\n\n填写完毕后，sourcetree 会开始下载，并在你选择的路径下创建本地仓库的文件夹\n\n如果你有多个远程仓库，点击 + 号重复上述步骤即可\n\n\n添加已有本地仓库  已有本地仓库的情况下，可直接点击 Add 添加\nsourcetree 会检测出来  这是一个 git 仓库\n\n3. 提交代码  回到主界面，这里会出现你的仓库 push 历史，以及操作的日期\n如果你的本地仓库里面做出了更改，和网络仓库不一致的时候，软件内会在第一行显示有  未提交的更改\n\n点击  文件状态，这里会显示你本地仓库的那些文件做出了更改\n\n未暂存文件：本地文件做出了更改，但并没有确认\n已暂存文件：保存了本地文件的副本，等待 push 到远程仓库\n底部白框：填写 push 说明\n\n\n依照下图操作即可\n\n如果你不选择“立即推送变更，就需要在左上角的“推送”选项内进行二次操作，才会上传到远程仓库\n\n\n如果你之前没有使用过 git，在这一步点击提交之后，会弹出一个框让你填写你的  账号密码\n填写对应网络仓库（gitee&#x2F;github）的  账号密码  即可！\n\n用户名：填写注册邮箱\n\n\n由于本人已经填写过，且不知为何无法在  账户 &#x2F;web 凭据  中找到并删除它，故无法复现这一步\n\n所以我帮同学也弄了一个 gitee 账户，顺便嫖来了这张填写  账户密码  的截图\n\n填写完账户密码后，sourcetree 就开始上传你的代码了！\n\n如果上传错误，这里会显示对于的 git 报错信息，根据报错信息  百度查找解决方案  即可！\n\n\n上传成功后回到 History 界面，可以看到我们最新的提交\n\n刷新网络仓库页面，可以看到推送成功了！\n\n这 2 个月的使用下来，只要 sourcetree 在上传的时候没有报错，那代码是铁定上传成功了。\n无需打开网络仓库再确认一下，还是挺方便的！\n\n如果你的本地仓库并没有做出更改，打开文件状态栏目的时候会显示“没有什么可提交的”\n\n\n\n4. 回滚提交 git 最重要的一个功能，就是保存我们 代码的历史版本\n如果你最新 push 的代码中  写了一堆 bug，或者  不小心删掉了一些代码，就可以在 git 里面找到你的历史版本\n在 sourcetree 的主界面中，右键一个之前的提交信息，可以看到两个选项\n\n这两个选项的区别，简单描述如下：\n\n回滚：将改动的代码提交到本地仓库，但未推送到远端仓库的时候\n重置当前分支到此次提交：将改动的代码提交到本地仓库后，并已推送到远端仓库的时候\n\n具体的区别及操作方法，大家可以参考这篇博客👇\n\nsourceTree 回滚提交和重置当前分支到此次提交的区别\n\n重置分支演示  在这里我简单演示一次重置分支的方法\n假设我们不小心删除了本地文件里面的代码\n\n比如想复制其他代码到此文件，却在复制的时候 ctrl+a 全选，覆盖了之前的代码\n\n\n而在提交代码的时候，我们又忘记检查，直接上传到了远程仓库\n\n\n这时候，就可以选择我们上一次的 push，选择  重置当前分支到此次提交\n这里会出现 3 个选项，我们可以选择最后一个“强行合并”\n\n确认后，打开之前被我们删除了内容的代码文件，发现删除了的代码已经回来了！\n\n由于之前的更改已经提交到了远程桌面，sourcetree 发现  本地仓库落后于远程仓库，需要我们进行拉取操作\n但拉取之后，我们错误的更改就又回来了，这并非我们的目的\n这时候可以在 souretree工具 - 选项  中开启 git 的强制推送\n\n注：强制推送具有风险，建议提前备份  分支内容\n\n\n选择我们重置的分支，并选择  推送\n\n勾选上左下角的强制推送\n\nsourcetree 会开始上传，上传完毕后，可以看到，之前的那次推送已经消失了！\n\n打开 gitee 检查一下，可以看到这里显示了“强制推送”\n\n找到我们之前更改过的那个文件，发现它已经回到了我们  删除之前的内容\n\n我们的目的也就完美达成了！\n\n还是建议大家上传的时候多多检查，之前我就干过一次这样的蠢事。\n第二次编写那个文件的时候，才发现之前的代码无了。还好可以回退版本！\n\n\n结语  个人理解，Sourcetree相比TortoiseGit，最大的优点就是它的界面更美观！\n\n还有另外一个我很喜欢的点：使用 sourcetree 不会让你的  右键菜单  多一堆选项！\n\n使用什么样的工具是大家各自的选择，一起进步才是我们共同的目的！加油😋\n\n如果有说的不明白的地方，欢迎在评论区提出！\n\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】git 仓库 code review 行话 | 转载","url":"/posts/2882797349/","content":"程序员这个行业，不管你是大佬还是小弟，代码 code review 是必不可少的。那么在 git 上，大家日常交流的缩写语，往往一下就能看出你道行的深浅，至少是入行时间，哈哈，不要露怯，勇敢的跟大佬过招拆招。\n\n\n收集了一些实用的缩写，方便大家日常交流(装 B)  \nLGTM  —  Looks good to me，表示认可这次 PR，同意 merge 合并代码到远程仓库  ASAP -— as soon as possible! 尽快  ACK  —  acknowledgement, i.e. agreed/accepted change  NACK/NAK — negative acknowledgement, i.e. disagree with change and/or concept  RFC  —  request for comments, i.e. I think this is a good idea, lets discuss  WIP：Work In Progress 「进展中」，常见词汇，这里做为 Best Practice 单独提出来，主要针对改动较多的 PR，可以先提交部分，标题或 Tag 加上 WIP，表示尚未完成，这样别人可以先 review 已提交的部分  AFAIK/AFAICT  —  as far as I know / can tell  IIRC  —  if I recall correctly  IANAL  — “ I am not a lawyer ”, but I smell licensing issues  IMO  — （In my opinion），在我看来  TL;DR  —  Too Long; Didn&#x27;t Read 「太长懒得看」，README 文档常见。  PR  —  Pull request「合并请求」  CR  —  Code Review 「代码审查」  PTAL  —  Please Take A Look. 你来瞅瞅？用来提示别人来看一下  TBR  —  To Be Reviewed. 提示维护者进行 review  TBD  —  To Be Done(or Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思。  TBH  —  To be honest 「老实说」  atm  —  at the moment 「现阶段」，\n\n站长注：其实主要还是在看别人 pr 的时候用，比如别人给你发了一个 pull rq，你检查了之后，感觉没有什么问题，就可以发一个 LGTM 表示你认可了这个 pr 贡献！\n作者：前端大飞  链接：https://www.jianshu.com/p/238a1e1f4037  来源：简书  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","categories":["差生文具多"],"tags":["git"]},{"title":"【MD】Markdown 如何插入视频、mp3 和 gif","url":"/posts/27591397/","content":"总所周知，鄙人有一个专栏叫做【差生文具多】，里面记录了一些工具的使用方法，以及使用工具时会遇到的一些问题。\n于是乎，之前就有一个朋友在群里问道“markdown 如何插入视频”，当时的我不会弄，然后就出现了下面这一幕👇\n\n明天就弄😂开整！（然而这篇博客是在 5.1 劳动节写的）\n[TOC]\n首先你要知道，markdown 语法其实是兼容 html 语法的，这也是为什么我们可以很方便地把 markdown 转换为 html，放置到博客网站上\n所以我们可以用 html 代码来  插入视频和 mp3 音乐\n1.md 插入视频  对应语法如下，这两个都可以\n&lt;video src=&quot; 视频链接 &quot;&gt;&lt;/video&gt;\n\n&lt;iframe height=498 width=510 src=&quot; 视频链接 &quot;&gt;\n\n如果我们插入一个 B 站视频的链接，在 typora 中的显示如下\n\n实际上它就是把一个网站插入到了我们的 markdown 文件中，形成了一个简易的浏览器\n其实你如果复制一个视频，直接在 typora 里面粘贴的话，typora 是会自动生成对应的 html 链接的\n&lt;video src=&quot;../../../../Desktop/md.mp4&quot;&gt;&lt;/video&gt;\n\n但这个链接和一个本地的图片链接相同，如果需要上传到 CSDN 网站上的话，CSDN 无法正常转存你的视频\n我们要做的，就是把这个视频也上传到我们的  图床  里面\n\n如果你不知道什么是图床，那就看看我吧：【图床搭建教程】\n\n图床并不是只能保存图片，它可以保存任何格式的文件。将视频拖入 picgo，即可上传我们的视频到图床\n\n点击箭头所指按钮，复制我们视频的链接\n\n然后把视频链接填入上面  两种形式其中之一  的 html 代码中，即可显示出视频！\n\n\n1.2CSDN 博客插入视频  然后我就发现 CSDN 不支持上面两种样式，不过我们可以在 markdown 编辑器的顶部选择视频\n\n然后这里会让你填写视频的地址，目前只支持 tx 优酷还有 bilibili 的已上传视频\n\n或者你可以选择“插入已有视频”，这会把视频上传到 CSDN 上\n\n\n2.md 插入 MP3 文件 2.1 网易云音乐外链 插入 MP3 文件的方式很简单，我们可以使用网易云音乐，选择一个非 VIP 歌曲，点击生成  外链播放器\n\n然后复制这里的 html 代码即可！\n\n&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=33367876&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;\n\n\n\n上面就生成了一个网易云音乐的外链播放器\n\n2.2 自己的 MP3 音频文件  根据上面 html 插入视频的代码，就可以猜出来音频的代码是啥\n把 vedio 改成 audio 就可以啦！\n&lt;audio src=&quot;mp3 文件链接地址 &quot;&gt;&lt;/audio&gt;\n\n下面就是一个我上传的 MP3 音乐文件\n\n在 typora 中的样式如下👇\n\n3.md 插入 gif这个就没有什么特殊的格式了\ngif 图片也是一个图片，直接用 ![]() 这种标准的 markdown 插入图片的样式就可以了\n\n结语  这个  新文具  的博客到这里就结束啦！\n希望对你有帮助！😍\n虽然我感觉在 markdown 中插入视频的使用场景不是很多\n","categories":["差生文具多"],"tags":["图床","typora"]},{"title":"【win】windows 磁盘管理分区, 实现整数容量","url":"/posts/2962575673/","content":"windows 磁盘管理分盘分出整数容量\n\n\n1. 问题  不知道各位在使用 windows 电脑分区的时候，有没有遇到一个抓狂的问题：那就是 windows 的分区总是分不出整数！\n不是299.9gb，就是300.1gb\n对于强迫症而言，看着那多出来的小数点，别提有多难受了！\n\n2. 解决  于是，我就百度了一下，到底要怎么设置分区的容量，才能让它分出一个整数 gb 的盘来？\n最后，我查到了下面这个办法\n想要整数 GB 的分区，只需要在原数字上 +1 就行了N*1024+1\n\n比如，我想要把 c 盘分出去 70GB 作为数据盘，那我应该在 windows 磁盘管理  压缩卷  里设置的数字如下\n70*1024+1\n\n看，完美的 70gb，强迫症有救了！\n\n\n关注本寒舍，分享更多 windows 电脑使用的小 tips！\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【win】windows 初次开机和使用的注意事项","url":"/posts/1529306954/","content":"首次开机和使用一台 windows 电脑需要注意的那些事\n\n\n本文所言仅为本人个人观点，且只作为建议和图一乐的素材。电脑归根结底只是个工具，不同人使用习惯不同，按自己熟悉的来用即可。大可无需因为本文而改变你使用电脑的习惯。\n1. 跳过联网windows11 的年代，这已是一个过去式了，还是记录一下吧。\n给不知道的人说一下，大部分笔记本厂家的策略，都是 windows 激活之后，就不允许退款了。\n在 windows10 的时代，首次开机的时候，在联网阶段，会有一个跳过联网的选项，我们只需要选择这个选项，就能跳过联网，继续我们的验机过程。这样，发现了电脑有各种各样的的问题或者不满意，还能以电脑没有激活为筹码，直接七天无理由退货。\n可微软的阿三工程师不知道怎么想的，windows11 一出来，直接把这个按钮干没了。\n起初，还能通过快捷键 or 命令行的方式，强行跳过联网，但现在，似乎都不行了。\n\n可能还有跳过联网的方式，但相比 win10 的一个按钮，显然任何方法都麻烦多了，对小白也不够友好\n\n哎，谁知道微软是怎么想的呢？\n2. 用户名  刚开始使用电脑的时候，电脑的用户名  一定一定一定  要设置成英文的！哪怕你设置成拼音或一串数字，都不要设置成非英文的其他语言！\n软件安装路径不要有中文  虽然现在，大部分软件对中文的支持都足够友好，但依旧有部分软件（以游戏据多）不支持中文路径的安装目录！\n说人话就是，如果你想安装这些软件，它要求你的安装目录是全英文的\nC:\\Progarm Files\\test\\\n\n如果你的安装路径里面带有中文，可能安装不会报错，但是软件打不开、崩溃、报错误，一堆 bug 就来了\nC:\\Progarm Files\\ 你好 \\\n\n为了避免这种 bug，我们安装软件的时候，最好都要选择全英文的安装路径。\n多一事不如少一事。你可以赌对很多个支持中文路径的软件，但只要来一个你需要的而不支持中文安装路径软件，就足够让你抓狂。如果你使用的是某些小众软件，恐怕报错贴到百度上都查不到为什么。\n那这又和用户名有啥关系呢？windows 在初始化的时候，会以你的用户名，在 C 盘如下路径创建一个文件夹\nC:\\Users\\ 用户名\n\n注意啊，虽然你打开文件管理器，会发现这个文件夹叫做  用户 ，但实际上他还是英文的，显示为 用户  是微软对界面做的汉化处理而已。\n\n右键这个路径，选择将地址复制成文本，你就会发现用户是汉化处理了\nC:\\Users\\moth\n\n在用户文件夹下，除了会有一些软件的配置文件（如 git、vscode、pip）还会有一个隐藏文件夹 AppData，这里面存放了大部分软件的缓存文件，甚至有一些软件的安装路径就是在AppData 里的！\n如果你的用户名设置成了中文，那很不幸，上面提到的  软件安装路径不能有中文  的大忌，你将不可避免地遇到了！\nC:\\Users\\ 慕雪\n\n因为软件会在你的用户目录下创建缓存文件夹，如果一个软件对中文的支持不好，那它就可能因此崩溃！\n在我周边的同学里面，就出现过不少个 windows 用户名是中文的\n\n好消息是，目前为止，我们专业学习需要的软件都支持中文路径\n坏消息是，这都大二下了，我们还没有学过一个专业课，还在学基础公共课……来大学快两年了，我还连自己的专业是干嘛的都不知道（事先为何不了解？问就是调剂来的！😒）所用的软件，也不过是编程 ide 罢了\n\n3. 保持一个良好的文件存放习惯  可笑的是，这件事，知道的人不需要你告诉他；不在乎的人你告诉他也没用。\n有太多太多的用户（包括我的父母）他们的电脑都中了一个病毒，导致整台电脑只有一个分区，叫做  桌面\n\n并不是说文件丢桌面不可以，但是丢在桌面上有一个致命的问题：重装的时候，需要格式化 C 盘。\nwindows 重装，是对付软件问题的最好方式。重装的时候，大概率是要格式 C 盘的，而桌面的文件就是存放在 C 盘上面的。\n\n虽然可以用 PE 来取走电脑中的数据，但这很麻烦！\n相比于微软官方的系统安装盘，PE 盘安装系统更麻烦（个人在很久之前的体验，没有试过近期的 PE，此言欠妥）\n\n所以，为了在电脑出奇怪的软件问题，快速重装让电脑恢复工作状态，最好的办法还是不要在 C 盘放  任何数据  文件！\n4.windows11 右键菜单设置win11 的右键菜单设计就是让人很无语的降级，也不知道开发者有没有自己用过系统。和不玩游戏的开发者和策划一样。\n恢复 win10 旧版命令（在 windows11 的命令行里面执行）\nreg.exe add &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\\InprocServer32&quot; /f\n\n重新启用新版：\nreg.exe delete &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;&quot; /f\n\n\n\n未完待续  想起来啥了就给本文加点料\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【win】Windows 下 C 盘里面的 WindowsApps 文件夹权限怎么获取","url":"/posts/3712817486/","content":" 避免原文失效，转载此文 \n 原文 https://www.bkqs.com.cn/content/kn928o443.html\n\n\n\nWin 下 WindowsApps 权限怎么获取 2023-01-31 14:32:17\nWin10 下 WindowsApps 权限怎么获取？WindowsApps 安装的是 Windows 应用商店的应用程序，访问此文件夹需要获取权限才能进入。具体怎么设置呢？一起来了解下吧！\n\n 操作方法 \n01\n1、在计算机中，打开此电脑。点击查看选项，并勾选选项框中的“隐藏的项目”。如图所示；\n\n\n02\n2、在此电脑窗口中，找到系统盘下的“WindowsApps”（隐藏的文件夹），具体路径为“C:\\Program Files\\WindowsApps”。如图所示；\n\n\n03\n3、选中 WindowsApps 文件夹，并点击鼠标右键，在弹出的选项框中点击“属性”选项。如图所示；\n\n\n04\n4、点击属性选项后，这个时候会打开“WindowsApps 属性”对话框。如图所示；\n\n\n05\n5、在 WindowsApps 属性对话框中，切换到“安全”选项卡。如图所示；\n\n\n06\n6、在安全选项卡下，看到提示“必须具有读取权限才能查看对象属性”，并点击“高级”选项按钮。如图所示；\n\n\n07\n7、点击高级选项后，这个时候会打开“WindowsApps 的高级安全设置”对话窗口。如图所示；\n\n\n08\n8、在 WindowsApps 的高级安全设置对话窗口中，点击所有者后的“更改”按钮。如图所示；\n\n\n09\n9、点击更改后，这个时候会打开“选择用户或组”对话框。如图所示；\n\n\n10\n10、在输入要选择的对象名称输入框中，输入“Everyone”，并点击“确定”按钮。如图所示；\n\n\n11\n11、点击确定后，这个时候会跳转到 WindowsApps 的高级安全设置对话窗口。如图所示；\n\n\n12\n12、接着勾选所有者下的“替换子容器和对象的所有者”，并点击“确定”按钮。如图所示；\n\n\n13\n13、点击确定后，这个时候会弹出 Windows 安全对话框，进行更改所有权。如图所示；\n\n\n14\n14、更改所有权完成后，这个时候就能正常访问“WindowsApps”文件夹了。如图所示；\n\n\n\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【win】Windows 下 MSI Afterburner 如何让其不在某个软件中显示帧数","url":"/posts/4160666395/","content":"Windows 下 MSI Afterburner 如何让其不在某个软件中显示帧数\n\n\n1. 问题说明  总所周知，MSI Afterburner这个软件可以在游戏里面展示你当前电脑的各项生命体征，包括 GPU&#x2F;CPU 功耗频率温度，内存占用，当前帧数等等数据，不管是用来监看电脑运行是否正常，还是用来小超一下显卡，都是很好用的东西，再加上毫无广告 + 免费，几乎是人手必备的 PC 良药\n\n但总有时候这个软件会抽风，比如我的电脑里面，最新版本的这个软件，就会把照片莫名其妙的也识别成了一个游戏，在里面显示帧数，最离谱的是，最下方的预览其他图片的小框框里面，也给你显示了帧数\n\n这肯定很恼火，我们要怎么样才能让他不在这里面显示呢？\n2. 配置  和MSI Afterburner捆绑下载的有这么一个软件，其实它才是负责将数据投屏到你的屏幕上的软件，在这里面，我们就可以设置在某个软件中不显示帧数\n\n对于正常安装的软件，我们都可以找到软件的安装路径，选中它的 exe 可执行文件，再设置一下把帧数器关闭，就可以避免错误地显示帧数影响软件自身的使用\n\n但是 windows 自带的相册就有点恼火了，我们压根不知道它的可执行文件在哪里！\n3.windows 系统应用的可执行文件windows 绝大部分的系统自带软件都在这里面，你需要打开显示隐藏文件夹才能看到此文件夹\nC:\\Program Files\\WindowsApps\\\n\n而  照片软件路径  如下（我的 win11 版本是22H2 22621.963）\nC:\\Program Files\\WindowsApps\\Microsoft.Windows.Photos_2023.11080.4003.0_x64__8wekyb3d8bbwe\n\n这里面有一个PhotosApp.exe，就是 windows 自带照片的可执行文件了；\n但是！你会发现你压根没有 C:\\Program Files\\WindowsApps\\这个文件夹的进入权限，更别提找到这个照片软件的 exe 了！\n百度了一下，找到了一个教程 Win10 下 WindowsApps 权限怎么获取；顺带一提，为了避免原文失效，这篇文章也转载到了本站。\n\n注意！毕竟这算是系统底层文件夹了，我不确定这样修改文件夹权限是否会出现问题！如果你担心出现问题，请不要操作，在不打游戏的时候不要启动 MSI Afterbuner 是更好的选择！\n如果出现问题，参考 【WindowsApps 权限问题导致 Microsoft Store 及其下载的应用不能启动（闪退）的解决办法】 复原权限！实在不行就恐怕要重装系统了 🤣\n\n目前我这边还么有出现异常情况，毕竟我修改为了 everyone 理论上来说是并不会出现权限不够而导致某个程序无法执行的问题的\n\n根据教程里面的步骤一步一步来，就可以获取到这个文件夹的进入权限\n\n4. 禁用照片中的帧数显示  找到这个 PhotosApp.exe 之后，在 RivaTuner 这个软件里面选中这个可执行文件，将其的 display 关闭\n\n好了，这下没有胡乱显示帧数了！\n\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【数据备份】谈谈如何进行有效数据备份，3+2+1","url":"/posts/3543423459/","content":"谈谈如何进行有效数据备份，以及什么是 3+2+1\n\n\n前言  数据备份已经是一个老生常谈的问题了\n今天在群里看到一位群友就出现了数据丢失的问题，两次跳闸后，台式机的固态硬盘无法被识别，在 bios 中看不到，群友说自己换了电脑依旧识别不出来（可以确定是固态挂了）\n\n于是就有了写这篇博客的想法，来谈谈我对数据备份的看法以及简单的做法\n数据只有丢了才会知道珍惜，请不要在丢了重要数据的时候后悔。\n工作文件、学习资料（严肃正经的）、家庭照片等信息，还有一切你觉得多少有点价值，想留下来的资源。\n\n说句题外话，小时候的我不喜欢拍照，可长大了，发现自己小时候半点照片都没有。脑海里对儿时的记忆，也早已模糊。上了大学之后，我拍照虽然依旧不多，但总归还是比儿时多了几倍。老了之后，这些东西就是你一辈子的回忆了。\n\n须知  在备份前，我们首先需要知道的事情如下\n\n任何硬盘都有自我嗝屁（指在正常工况下他就坏了）的风险，不要认为自己买了个很贵的品牌固态硬盘就可以高枕无忧了\n同样，便宜的固态硬盘也不一定很容易坏，在重视数据备份的同时，也没必要提心吊胆\n固态硬盘由于其物理结构和设计原理，数据恢复的可能性极低。如果你的固态硬盘坏了，那就当数据全丢了处理。\n不要存有数据坏了可以去  数据恢复  的侥幸心理 。即便最终可以数据恢复出来，成本比你多买几个硬盘高多了（这位群友去问了，数据恢复要800-1600，这个价格都可以买6t 的固态硬盘 /16t 的机械硬盘 了）\n\n\n什么是 3+2+1 备份  你可能在别处看到有人提到这个名词：3+2+1 备份原则\n\n三个存储设备（一份数据在 3 块不同的硬盘中存放）\n两个不同主机（这三块硬盘中，至少要有 2 块是位于不同主机上的）\n一个异地备份（数据要在异地备份一份，比如你家里着火了设备全挂了，那么异地的备份就有用了）\n\n前面两个条件，如果家里有两个电脑的用户还能勉强达成，最后一个条件可能很多人就没办法达成了\n但这并不重要，我们眼前就有一个最简单易用的异地备份介质——网盘\n最简单的做法  手机电脑各一份  对于普通用户来说，备份重要数据的最简单办法，那就是将重要数据往  手机和电脑  各拷贝一份；\n如果你有两台电脑，那就在  两台电脑  上都拷贝一份，这样就已经满足了 3+2+1 中的 2 了；\n单个电脑多硬盘同步  如果你的电脑有多个硬盘（一定要是物理硬盘，而不是你 Windows 里面的磁盘分区）\n建议将重要数据在两个硬盘中都存一份！\n这里推荐一个特别好用的同步软件 freefilesync， 下载地址\n\n界面使用很简单，左侧和右侧分别设置文件夹，右上角的绿色齿轮里面可以设置同步的类型为  更新、镜像，还有带版本管理的同步方式。除了设置本地，还支持 google drive 和 frp，你也可以把 nas 的硬盘通过 smb 或 webdav 映射为本地硬盘，使用此软件进行同步\n和这个软件一起的还有个红色图标的  实时同步，在绿色软件里面配置好了之后，将配置文件导入这个红色软件，设置监看间隔，就能做到数据的实时同步。\n\n\n完整使用教学可以查看这个 B 站视频：【14001】FreeFileSync：差异同步、镜像备份、增量备份 全能的同步软件 文件同步 本地同步\n\n\n比如一份数据，你可以以某块固态为主力，然后将软件的同步模式改成镜像（同步删改）到另外一个硬盘里面。这样两边的数据就能保持一致了。就算一个硬盘坏了，另外一个硬盘还能祝你一臂之力。\n要知道，除非你的电脑主板挂了，或者你买的  电源有点劣质（这里也提醒一下，省什么钱都不要省电源，买个相对大瓦数的品牌电源，比如振华或者海韵，比某些淘宝的低价烂货好的多），不然两个硬盘一起挂的概率是极低极低的，远远低于一个硬盘坏掉的概率。\n网盘  除了在本地备份，特别特别特别重要的数据也强烈建议在云盘也存一份\n主流的云盘：百度云盘，阿里云盘。如果你注册的比较早，容量应该都是上 T 了的，对于  家用备份  来说完全够用了。\n虽然云盘的  下载都限速 ，前期宣传不限速的阿里，现在也只能跑 3mb 的下载了（不过还是比百度好多了）；一般 上传都是不限速的，如果真的有需要了，大不了开个会员下回来，总比数据救援的要价靠谱。\n将重要数据  打个压缩包，必要的时候设置个密码（防止被网盘误封），如果你担心忘记压缩包密码，可以直接找个文件名改成密码，一起丢到压缩包里面。这里我们要防止的是网盘的 AI 误封你的文件，而不是保障数据安全。\n\n什么时候想起来就弄一下，根据你对数据重要性的敏感度来决定备份频率吧！\n\n网盘和隐私？https://zhuanlan.zhihu.com/p/94763454\n虽然很多人说网盘不安全容易泄漏什么的，但实际上哪怕是天天被骂的百度网盘也并没有出现过  主动  泄漏用户文件的情况；\n很多时候都是一些不会用软件的人，启用了  自动备份  功能，还把自动备份的文件夹开了分享，甚至直接把分享链接发网上，导致有些爬虫机器人把你的分享链接给收集起来了。后续你的东西肯定被人家看光喽。\n隐私的守护权始终是在你自己手上，在分享文件的时候，请仔细检查文件里面的东西是不是完全和你自己的隐私没有关系，最好的分享是只  分享文件 ，而 不要分享文件夹（因为对这个文件夹的后续修改，原有的那个分享链接都能看得到），别到时候分享一个盗版游戏顺便把自己身份证的照片也分享给别人了。\n现在网盘的用户页面都能看到自己的分享链接，时不时去检查一下，把过时的、不需要的分享链接给他们删掉。\n\n如果有些资源你不希望被网盘 ban 掉，还有个小办法是将资源压缩了之后，放入另外一个文件夹，在文件夹里面随便丢几个文件来混淆视听（主要是为了让你这个压缩包的 md5 和其他相同资源的压缩包不一样）再加上解压密码，能大大减小被 ban 的概率！\n另外，请一定不要在任何网盘软件里面使用  在线解压功能，他会记录你解压密码然后去算内部文件的 md5，然后给你 ban 掉。（逛贴吧的时候看到过这种情况，属实无语）\n\nNASnas 说白了就是另外一台小电脑，只不过这台电脑上有很多硬盘位，其主要的目标就是管理硬盘里面的文件，方便我们将其他设备的数据备份上去。\n既然谈到备份，那就顺便说说什么时候你需要买一台 nas 吧？\n首先要说明的是，nas 本身已经不贵了。尝鲜款可以买海康的 h99pro，有基础的 nas 管理功能。一般日用可以买海康的 mega20，双盘位的价格是 500（PDD）要知道，这个价格已经比某些硬盘柜都便宜了；\n先不要管 nas 附属的 docker 等功能，这些功能海康是没有的。但 NAS 本身要做到的其实只是存储，在数据备份这点，海康的 NAS 是完全够用的！\n\n我当初买 nas 的原由是：方便下好电电影在手机上看；电脑看屏幕大确实爽，但远没有躺着看舒服😂\n\nnas 这东西，特别是带 docker 的 nas 基本都上 1k 了，其本身的价格已经能顶上多年的网盘会员了。更别提 nas 在家里面的访问速度绝对不会有网盘会员快，除非你家能弄到 ipv4 的公网 IP（要折腾很多东西的，很麻烦）\n\n什么是  带 docker 的 nas？简单来说就是 docker 可以理解为是 nas 上的一个软件商店，我们可以利用各种开源的 docker 软件，来实现资源下载、文件管理、照片管理、在线看视频等等的功能。\n而没有 docker 的 nas 只能局限于厂家给你提供的基本功能。而且那些不带 docker 的 nas 的系统大概率是不会有什么好的功能性升级的。能给你推个修系统 bug 的更新都谢天谢地了。毕竟还是一分钱一分货的。\n\n如果你只是为了  数据备份，完全可以不用买 nas。给自己电脑加个硬盘、或者买个移动硬盘来冷备份，都是更好的选择。甚至网盘开个多年会员，自己手动备份内容到云盘都会比 nas 的维护更加方便。\n但如果想尝试附属的影音管理、资源下载、远程开发等功能，或者像我一样宁愿数据在自己的本地存也不想丢网盘的话，那就可以在自己经济条件允许的情况下买个带 docker 的 nas，来备份数据、下点资源什么的。\nThe end就说这么多吧，希望对你有帮助。不过应该没人看，大概率只是我自己碎碎念（阿巴阿巴阿巴）\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【牛客网】BM1：翻转链表","url":"/posts/3018206681/","content":"今天打算开启新一轮刷题了，必须得刷了，再不刷就得成废物了。\n也希望看我博客的老哥能监督一下我，一起进步嘛！\n\n\n题目 BM001打算从  牛客网的面试 top101开始刷起来，今天是BM001 反转链表\n\n给定一个单链表的头结点 pHead(该头节点是有值的，比如在下图，它的 val 是 1)，长度为 n，反转该链表后，返回新链表的表头。\n数据范围： 0≤n≤1000\n要求：空间复杂度 O(1) ，时间复杂度 O(n) 。\n\n解法 1：循环  最简单的办法就是用指针来一个一个修改链接，每次都将当前节点的 next 链接为上一个节点，最终再将开头的节点（单独存一下原本的开头）的 next 链接为空，返回最后一个节点即可。\n很常规的写法，参考注释\nclass Solution&#123;public:    ListNode *ReverseList(ListNode *head)    &#123;        // 因为需要 O(1)空间复杂度，所以我们不能用很蠢的将数据遍历出来后倒序放回的办法        // 时间复杂度是 O(N) 也要求我们写的代码相对来说效率需要高一些        if (head == nullptr || head-&gt;next == nullptr)        &#123;            return head; // 只有一个或者为空的情况下，直接跳过        &#125;        ListNode *old_head = head; // 单独存头        ListNode *A, *B, *C;       // 三个指针        A = head;        B = head-&gt;next;        C = head-&gt;next-&gt;next;        while (C != nullptr)        &#123;            // B 修改链接为 B 的前一个（A 在原视链表中是 B 的前一个）            B-&gt;next = A;            A = B;       // A 变成 B（也相当于 A 在原视链表中，往后走一步）            B = C;       // B 往后走一步            C = C-&gt;next; // C 往后走一步        &#125;        // 走到这里是 B 的下一个 C 已经为 nullptr，代表 B 是最后一个节点        B-&gt;next = A; // 依旧是链接        old_head-&gt;next = nullptr;        return B; // B 是原视链表的最后一个节点，新链表的第一个节点    &#125;&#125;;\n\n解法 2：递归  一般面试的时候，面试官更希望看到递归的办法，因为这样的代码更加简洁，思路也更加有挑战性（反正你就要往难的办法想）\n递归的思路也是让下一个节点的 next 链接为当前节点。主要在于递归的末端条件应该是 head-&gt;next==nullptr 的时候就需要退出了，因为此时 head-&gt;next-&gt;next是无效的，没有办法进行链接。\n整个过程大概就是下面这个简图了，其中方框代表的是节点，圆形代表每一步\n\n上代码，这里将 head-&gt;next = NULL;是为了操作第一个节点（原视链表的首节点）的时候，将下一位改成空。而在中间节点的时候，因为当前节点的 next 会在  上一层递归  的时候被修改回去，所以设置为空不会出现问题。\nListNode *ReverseList(ListNode *head)&#123;    // 特判：注意不要漏掉 head-&gt;next==NULL 的情况    if (head == NULL || head-&gt;next == NULL)    &#123;        return head;    &#125;    // 递归调用    ListNode *ans = ReverseList(head-&gt;next);    // 让当前结点的下一个结点的 next 指针指向当前节点    head-&gt;next-&gt;next = head;    // 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转    head-&gt;next = NULL;    return ans;&#125;\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","牛客网"]},{"title":"【npm】error:03000086:digital envelope routines::initialization error","url":"/posts/2800051647/","content":"error:03000086:digital envelope routines::initialization error 问题解决\n\n\n慕雪是在使用 vuepress 的时候遇到了这个错误。根据官方的描述，vuepress 应该使用 node.js 14 版本即可，但我的电脑上是18.x。\n完整报错如下\nPS D:\\Git_repo\\hexo\\khl.py.docs&gt; npm run docs:dev &gt; docs:dev&gt; vuepress dev docswait Extracting site metadata...tip Apply theme @vuepress/theme-default ...tip Apply plugin container (i.e. &quot;vuepress-plugin-container&quot;) ...tip Apply plugin @vuepress/register-components (i.e. &quot;@vuepress/plugin-register-components&quot;) ...tip Apply plugin @vuepress/active-header-links (i.e. &quot;@vuepress/plugin-active-header-links&quot;) ...tip Apply plugin @vuepress/search (i.e. &quot;@vuepress/plugin-search&quot;) ...tip Apply plugin @vuepress/nprogress (i.e. &quot;@vuepress/plugin-nprogress&quot;) ...* Client █████████████████████████ building (40%) 1/2 modules 1 active node_modules\\webpack-dev-server\\client\\index.jsi ｢wds｣: Project is running at http://0.0.0.0:8081/i ｢wds｣: webpack output is served from /i ｢wds｣: Content not from webpack is served from D:\\Git_repo\\hexo\\khl.py.docs\\docs\\.vuepress\\publici ｢wds｣: 404s will fallback to /index.htmlnode:internal/crypto/hash:71  this[kHandle] = new _Hash(algorithm, xofLen);                  ^Error: error:0308010C:digital envelope routines::unsupported    at new Hash (node:internal/crypto/hash:71:19)    at Object.createHash (node:crypto:133:10)    at module.exports (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\util\\createHash.js:135:53)    at NormalModule._initBuildHash (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\NormalModule.js:417:16)            at handleParseError (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\NormalModule.js:471:10)    at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\NormalModule.js:503:5    at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\NormalModule.js:358:12    at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\loader-runner\\lib\\LoaderRunner.js:373:3    at iterateNormalLoaders (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\loader-runner\\lib\\LoaderRunner.js:214:10)    at Array.&lt;anonymous&gt; (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\loader-runner\\lib\\LoaderRunner.js:205:4)    at Storage.finished (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\enhanced-resolve\\lib\\CachedInputFileSystem.js:55:16)      at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\enhanced-resolve\\lib\\CachedInputFileSystem.js:91:9    at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\graceful-fs\\graceful-fs.js:123:16    at FSReqCallback.readFileAfterClose [as oncomplete] (node:internal/fs/read_file_context:68:3) &#123;  opensslErrorStack: [&#x27;error:03000086:digital envelope routines::initialization error&#x27;],  library: &#x27;digital envelope routines&#x27;,  reason: &#x27;unsupported&#x27;,  code: &#x27;ERR_OSSL_EVP_UNSUPPORTED&#x27;&#125;Node.js v18.15.0\n\n使用原文中的  方法 3，成功解决此问题\n\n以下为原文\n版权声明：本文为 CSDN 博主「忙碌的菠萝」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_21271511/article/details/127996193\n\n问题描述  问题背景  更换新机器的时候下载使用了最新版的 nodejs，部署老项目的时候启动报错了\n错误描述  跑了一下 ruoyi 的项目试试，就直接给报了 Error: error:0308010C:digital envelope routines::unsupported\nError: error:0308010C:digital envelope routines::unsupported\n    at new Hash (node:internal/crypto/hash:71:19)\n    at Object.createHash (node:crypto:133:10)\n    at module.exports (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\util\\createHash.js:135:53)\n    at NormalModule._initBuildHash (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\NormalModule.js:417:16)\n    at handleParseError (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\NormalModule.js:471:10)\n    at D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\NormalModule.js:503:5\n    at D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\NormalModule.js:358:12\n    at D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\loader-runner\\lib\\LoaderRunner.js:373:3\n    at iterateNormalLoaders (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\loader-runner\\lib\\LoaderRunner.js:214:10)\n    at Array.&lt;anonymous&gt; (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\loader-runner\\lib\\LoaderRunner.js:205:4)\n    at D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\graceful-fs\\graceful-fs.js:123:16\n    at FSReqCallback.readFileAfterClose [as oncomplete] (node:internal/fs/read_file_context:68:3) &#123;\n  opensslErrorStack: [&#39;error:03000086:digital envelope routines::initialization error&#39;],\n  library: &#39;digital envelope routines&#39;,\n  reason: &#39;unsupported&#39;,\n  code: &#39;ERR_OSSL_EVP_UNSUPPORTED&#39;\n\n问题解决  原因分析1、原项目是在 nodejs 16 版本上跑，目前升级为 nodejs 18，可能是由于升级影响的2、具体错误原因：ERR_OSSL_EVP_UNSUPPORTED 错误 SSL 数字信封不支持\n解决措施1、set NODE_OPTIONS=--openssl-legacy-provider\n这个亲测并没有什么软用\nPS D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui&gt; set NODE_OPTIONS=--openssl-legacy-provider\nPS D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui&gt; npm run dev\n\n&gt; ruoyi@3.8.4 dev\n&gt; vue-cli-service serve\n\n INFO  Starting development server...\n10% building 2/2 modules 0 activeError: error:0308010C:digital envelope routines::unsupported\n\n2、降级 nodejs\n升级再降级也没有道理，虽然也是可以的，最后总是要升级的，不推荐\nnvm ls availablenvm install 16.13.0\n\n\n或者卸载当前的 nodejs 重新下载安装即可\n3、修改环境变量问题解决\n$env:NODE_OPTIONS=&quot;--openssl-legacy-provider&quot;\n\n输出如下\nPS D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui&gt; $env:NODE_OPTIONS=&quot;--openssl-legacy-provider&quot; PS D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui&gt; npm run dev&gt; ruoyi@3.8.4 dev&gt; vue-cli-service serve INFO  Starting development server...98% after emitting CopyPlugin DONE  Compiled successfully in 18898ms     \n","categories":["差生文具多"]},{"title":"【牛客网】BM3：链表中的节点每 k 个一组翻转","url":"/posts/3391123821/","content":"BM3 链表中的节点每 k 个一组翻转\n\n\n1. 题目BM3 链表中的节点每 k 个一组翻转\n将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表  如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样  你不能更改节点中的值，只能更改节点本身。\n\n2. 解析 2.1 链表逆置 其他部分其实很好解决，基于链表逆置的代码（即逆置整个链表的代码）\n我们只需要将每一个需要逆置的小区间的开头给记下来，交付给链表逆置就可以了。\n// 无差别逆置ListNode* reverseNode(ListNode* head) &#123;    if (head == nullptr || head-&gt;next == nullptr) &#123;        return head;    &#125;    ListNode* ans = reverseNode(head-&gt;next);    head-&gt;next-&gt;next = head;    head-&gt;next = nullptr;    return ans;&#125;\n\n2.2 记录每个需要逆置的区间  比如如下部分代码，为了方便进行遍历和指针控制，我创建了一个头节点放置在了原本链表开头\n// 头节点和遍历指针ListNode phead(0);phead.next = head;ListNode* cur = &amp;phead;// 把每 k 个节点单独取出来，分别逆置后链接起来std::vector&lt;ListNode*&gt; begin_node_v,begin_node_prev_v;int index = k-1; // 初始化为 k-1(忽略头节点)，原有链表第一个节点始终入栈int node_count = 0;// 节点总数（包含头节点）while (cur != nullptr) &#123; // 不知道有多长，得死循环    if(index+1 == k &amp;&amp; cur != &amp;phead)&#123;        begin_node_prev_v.push_back(cur);    &#125;    else if (index == k) &#123;        begin_node_v.push_back(cur);        index = 0;    &#125;    cur = cur-&gt;next;    index++;    node_count ++;&#125;\n\n这里还创建了两个 vector 数组\n\nbegin_node_v：待逆置区间的开头\nbegin_node_prev_v：待逆置区间的开头的上一个\n\n下面是对这两个数组的说明，如果给出的示例是如下形式\n&#123;1,2,3,4,5&#125;,2\n\n那么两个数组分别存储了如下值\nbegin_node_v:     &#123;1,3,5&#125;begin_node_prev_v: &#123;2,4&#125;\n\n这样一来，第一个数组实际上存放的是每个区间的  开头 ，第二个数组存放的则是每个区间的 结尾 。 逆置了之后:\n\n第二个数组就是新区间的开头\n第一个数组就是新区间的结尾\n\n方便我们将逆置后的链表重新连起来！\n2.3 抛弃无需逆置的区间  在上面的循环中，用了 node_count 来计算了整个链表的长度，减 1 剔除我自己添加的头节点，就是原始链表的长度。\n题目有个特殊要求：如果原始链表的长度并非 k 的整数倍，那么最后一段区域的链表是不需要逆置的\n1 - 2 - 3 - 4 - 5当 k=3 的时候，只需要逆置 1-2-3            4-5 不需要逆置3 - 2 - 1 - 4 - 5\n\n在这种情况，用例和两个数组存放的节点如下\n用例 &#123;1,2,3,4,5&#125;,3begin_node_v:     &#123;1,4&#125;begin_node_prev_v: &#123;3&#125;\n\n如果我们直接将 begin_node_v 里面的节点交付给链表逆置函数，就会将 4-5 这一段夜给逆置，最终返回的结果是3-2-1-5-4，不符合题目要求！\n所以在这种情况下，我们需要将 4 从第一个数组中删除！如果原视链表的节点数量已经小于 k 了，则也不需要逆置，直接返回即可。\n// 如果节点总数量小于 k 则不逆置直接返回node_count --;// 减 -1 头节点if(node_count &lt;k)&#123;    return head;&#125;// 不是整数倍，代表最后一个是不要处理的ListNode* last_link = nullptr;if((node_count %k) != 0) &#123;    last_link = begin_node_v[begin_node_v.size()-1];// 最后一个    begin_node_v.pop_back();// 删除最后一个&#125;\n\n另外，为了最终将这段么有逆置的链表和新链表连起来，我们还需用一个指针记录下这一段的开头；last_link初始化为空是方便后续的判断，如果为空代表不存在这一段链表，不需要链接。\n2.4 区间结束标识  为了标识每次逆置的结束符，我们还需要将待逆置的每一个小区间的末尾都改成nullptr\n// 将每个区间的末尾节点的 next 链接为 Null 作为递归标识for(auto&amp;n:begin_node_prev_v)&#123;    n-&gt;next = nullptr;&#125;\n\n2.5 逆置和重新链接  上面的步骤都敲定了之后，我们就可以将第一个数组 begin_node_v 的节点喂给链表逆置函数了，该逆置函数的返回值是新链表的开头。\n// 将每个区间交付给递归开始逆置，并将逆置的返回值与上一个区间的开头连起来cur = &amp;phead;for(auto&amp; n:begin_node_v)&#123;    ListNode* ptr=reverseNode(n);    cur-&gt;next = ptr;    cur = n;&#125;\n\n这里说一下 cur 指针的作用，以用例 &#123;1,2,3,4,5&#125;,2 为栗子，此时 begin_node_v 数组中存放的是&#123;1,3,5&#125;\n\n初始化为 phead\n第一次循环，n 指向的是 1，cur 指向的是 phead；逆置结束后，ptr 指向的是 2，刚好就是新链表的开头，将 cur 的 next 链接为它，并将 cur 更新为 1\n第二次循环，n 指向的是 3，cur 指向的是 1；逆置结束后，ptr 指向的是 4，此时 cur 的 next 指向它，就是将 1 的 next 链接为 4，再次更新 cur 为 3。\n第三次循环，n 指向的是 5，cur 指向的是 3；逆置结束后，将 3 的 next 链接为 5，cur 更新为 5\n循环结束\n\n结束时，这个链表就已经完工了！我们只需要判断一下还没有剩下的没有逆置的节点，将其链接给 begin_node_v 数组中的最后一个节点（也是逆置部分的最后一个节点）的 next 就可以了\n// 判断是否还有剩下的节点if(last_link !=nullptr)&#123;    begin_node_v[begin_node_v.size()-1]-&gt;next = last_link;&#125;\n\n3. 完整代码class Solution &#123;  public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *     * @param head ListNode 类     * @param k int 整型     * @return ListNode 类     */    // 无差别逆置    ListNode* reverseNode(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) &#123;            return head;        &#125;        ListNode* ans = reverseNode(head-&gt;next);        head-&gt;next-&gt;next = head;        head-&gt;next = nullptr;        return ans;    &#125;    void cout_vector(std::vector&lt;ListNode*&gt;&amp; begin_node_v) &#123;        for (auto&amp; e : begin_node_v) &#123;            cout &lt;&lt; e-&gt;val &lt;&lt; &quot; &quot; ;        &#125;        cout &lt;&lt; endl;    &#125;    ListNode* reverseKGroup(ListNode* head, int k) &#123;        // 只有一个节点，或者逆置区间为 1 的都不需要操作        if (head == nullptr || head-&gt;next == nullptr || k &lt;= 1) &#123;            return head;        &#125;        // 头节点和遍历指针        ListNode phead(0);        phead.next = head;        ListNode* cur = &amp;phead;        // 把每 k 个节点单独取出来，分别逆置后链接起来        std::vector&lt;ListNode*&gt; begin_node_v,begin_node_prev_v;        int index = k-1; // 初始化为 k-1(忽略头节点)，原有链表第一个节点始终入栈        int node_count = 0;// 节点总数（包含头节点）        while (cur != nullptr) &#123; // 不知道有多长，得死循环            if(index+1 == k &amp;&amp; cur != &amp;phead)&#123;                begin_node_prev_v.push_back(cur);            &#125;            else if (index == k) &#123;                begin_node_v.push_back(cur);                index = 0;            &#125;            cur = cur-&gt;next;            index++;            node_count ++;        &#125;        // 走到这里已经把每个需要逆置的开头节点给记录下来了        // 如果节点总数量小于 k 则不逆置直接返回        node_count --;// 减 -1 头节点        if(node_count &lt;k)&#123;            return head;        &#125;        // 不是整数倍，代表最后一个是不要处理的        ListNode* last_link = nullptr;        if((node_count %k) != 0) &#123;            last_link = begin_node_v[begin_node_v.size()-1];// 最后一个            begin_node_v.pop_back();// 删除最后一个        &#125;        // cout_vector(begin_node_v);        // cout_vector(begin_node_prev_v);        // 将每个区间的末尾节点的 next 链接为 Null 作为递归标识        for(auto&amp;n:begin_node_prev_v)&#123;            n-&gt;next = nullptr;        &#125;        // 将每个区间交付给递归开始逆置，并将逆置的返回值与上一个区间的开头连起来        cur = &amp;phead;        for(auto&amp; n:begin_node_v)&#123;            ListNode* ptr=reverseNode(n);            cur-&gt;next = ptr;            cur = n;        &#125;        // 判断是否还有剩下的节点        if(last_link !=nullptr)&#123;            begin_node_v[begin_node_v.size()-1]-&gt;next = last_link;        &#125;        return phead.next;    &#125;&#125;;\n\n通过截图\n\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C++","牛客网"]}]