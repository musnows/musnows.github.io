[{"title":"【公告】2023-10-06 宣传一下我的wiki站点","url":"/posts/955376979/","content":"考虑到hexo博客对技术博客的归档和展示并不是以最好的排版呈现出来的，我又不想换vuepress这些框架，于是自己部署了一个MrDoc项目，打算将我所学的Cpp&#x2F;Linux后端知识给系统性的整理到这个网站上。\n网站可以在线编辑，也方便我跨平台操作。个人感觉这个开远光项目比一些动态博客系统都好用（只不过缺少评论，那是专业版的功能）\n目前网站刚刚搭建，只更新了少部分文档。大家感兴趣地可以收藏一下这个网站：https://wiki.musnow.top/\n首页截图如下\n\n如果有java或其他方向的老哥愿意共建文档站，也可以联系我，我可以给你编辑权限，创建一个属于你的文档集。\n2023-06-06 尝试使用qexo作为博客后端尝试使用qexo作为博客后端，还挺好玩的！\n项目地址 https://github.com/Qexo/Qexo\n\n2023-03-30 本站更新为butterfly主题本站更新为butterfly主题，keep主题留档站点👉点我\n2023-03-28 图床被攻击自一周之前起，图床CDN遭到了恶意请求（同一个ip，同一张图片，每秒请求15次，日扣费5元。在我禁掉他的ip后，他换了另外一个ip继续请求同一张图片，因为两个ip的属地相同，都是家宽，所以我认为是同一个人）\n详细信息见日志文章\n2023-03-25 url替换使用了 hexo-abbrlink插件，将所有post文章的链接配置为固定连接.\n评论和之前文章中引用的连接都已更新\nnpm install hexo-abbrlink --save\n\n\nhttps://blog.csdn.net/Mculover666/article/details/103137719\n\n2023-02-03 域名更换域名更换为 blog.musnow.top, 更有个人标识度\n2023-02-01 关于页面藏起来了我把关于页面藏起来啦，看看你能不能找到它的位置呢？\n2023-01-18 之前valine的评论已导入已从leancloud国内版本导入了之前valine的评论到waline，并修改了数据库中有变动的url\n2023-01-13 站点更新keep版本，使用git管理主题现在使用git的submodule 来管理keep主题文件\nhttps://zhuanlan.zhihu.com/p/87053283\n今天发现 jsdelivr 的 cdn挂掉了，导致很多资源都加载不出来，转为用nmpkg了。同时我缓存了 2.4.16 版本的waline文件，全都放在阿里云了。\n2023-01-09 站点页脚添加网站运行时间今天给站点页脚添加了网站运行时间，同时注释掉了底部的hexo提示框；还添加了一些shields.io的图标，感觉很不错！\n参考博客 hexo+yilia添加网站运行时间，ICP备案信息，设定站点建立时间\n\n\n今天加入了萌ICP备，和真的ICP备案没有关系，其本质和开往是一个类型的项目。\n2023-01-08 更新博客邮箱提醒的模板根据教程更新了vecrel中waline所使用的评论提醒模板，响应速度还是很快的，而且配置没有leancloud的邮箱提醒那么麻烦；\n不过我发现vercel的访问可能没有那么快速，有的时候会出现评论加载不出来的情况，需要多刷新几次！\n更详细的内容请看👉7-2-使用-Waline评论系统\n2023-01-07 加入开往这个也是在逛别人的主页的时候看到的，感觉很不错！那就加入吧！\n\n开往链接 https://www.travellings.cn/\n开往是一个以跳转功能为主的友链接力项目，其名字“开往”取自“开放的网络”。\n将开往放入您的网页，表示您乐于分享并支持开放的网络。\n每当有人访问加入开往的网页时，点击“开往“会随机跳转到另一个加入开往的网页。之后，再次点击网页上的”开往“或后退网页，将继续随机跳转到另一个加入开往的网页。\n\n2023-01-06 更新keep版本啊呀呀，今天折腾了一整天，才把keep从 3.4.5 -&gt; 3.5.2，因为我之前站点的个性化配置都是修改的npm包，结果发现一更新，包里面修改过的内容全没了！😥😥\n于是又根据自己写的教程，重新修改了一番，并给自定义过的背景添加了根据明暗自动变化颜色的功能（之前是没有的）\n而且评论系统也从 valine -&gt; waline，其主要的好处就是，waline 支持上传图片，用来在评论区回答一部分问题的时候，还是很方便的，不需要用户还去找个图床了。\n我通过替换keep主题cdn导入的 waline.js 文件的方式，修改了 waline 默认的图片上传限制 128KB -&gt; 1024KB\n\n我这种修改办法肯定非常非常不规范，但是的确生效了🤣？就是不知道后续会不会出现bug，希望不要有😶‍🌫️\n\n虽然折腾了非常非常久，还做了一些无用功，但是真的搞定的时候，还是很开心哒！\n2022-04-16 建站今天，基于 HEXO + KEEP 主题的站点终于建立起来啦！\n搭建这个站点的灵感来源于我在逛CSDN时候遇到的一个博主的个人站点，并发现了HEXO这个开源的博客搭建框架\n首个版本是基于 Gitee Pages 的，感觉还不错！\n使用hexo和keep主题搭建个人博客\n"},{"title":"【Linux】使用腾讯云搭建CentOS的Linux编程学习环境，实现多用户使用同一个云服务器","url":"/posts/656771008/","content":"为了帮助自己系统地学习Linux系统和命令行操作，我购入了腾讯云的轻量云服务器，预装了CentOS7.6系统\n\n\n本篇博客是一个笔记，记录了创建过程中遇到的一些问题，包括：\n\n云服务器多用户隔离使用（因为我的服务器是和同学一起拼购的）\ngit仓库ssh密匙设置\n设置Xshell用户名的显示颜色\n\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n以下是一个导读。其实不管是服主还是个人用户，都推荐使用以下阅读顺序\n\n如果你是服主，看本文的顺序是1→2(其中2.1跳过)→6→8→4.1\n配置好环境并下载好git后，服主就不需要做其他什么的了，就和其他人一起看完本文👇\n如果你不是服主，只需要看2.2.4连接上你的账户，即可开始操作第3、4、5、7点，可跳过4.2和4.3\n\n如果你的linux是虚拟机安装的，也可以根据本文所教知识，进行ssh的连接和系统一些简单的配置的操作\n\n[TOC]\n1.云服务器初始化这部分tx云其实是有帮助文档的，但是它就是不在一个文档里面从头到尾写全，导致你需要翻来翻去找具体的操作，很恼火\n1.1购买云服务器\n23.02.16更新：当前学生优惠已经无了，请以官网实际价格为准，本文仅供参考\n\n选择腾讯云的理由很简单，现在它比阿里云便宜，2核心4GB的版本只需要168一年（作为对比，同时期阿里云没有打折，1核2GB的版本99一年）\n\n腾讯云校园计划https://cloud.tencent.com/act/campus\n\n注意：如果你只买一年，请不要购买下面的校园服务器！！！！购买校园服务器的资格只有一次，只买一年就花掉这个资格太不划算了！！！\n而且校园云服务器因为是“首单特惠”，是不支持同价续费的，续费价格也是天价！！！（续费要900多一年）\n\n在轻量应用服务器里面还有一个便宜的版本，2核2GB只要58一年，但是那个只能买一年，续费的价格很贵！！！\n\n如果要买2-3年，请购买上面的校园服务器\n如果只买一年，请购买下面的这个58/年的版本【链接】\n\n\n230312更新：现在校园服务器似乎已经不支持购买多年了😂\n\n注册腾讯云账户并实名认证后，就可以正常购买。这里不赘述了。\n我选择的系统是CentOS7.6，这个系统非常适合我们初学Linux\n\n\n1.2控制台管理创建完实例后，你应该就能在控制台里面看到你的云服务器了，右下角显示的是公网IP，我们后续使用Xshell链接的时候需要它\n\n进入后做的第一件事，就是充值你的root账户密码。建议设置的稍微复杂一点，一定要用小本本记下来！\n\n1.3下载Xshell我们需要用Xshell和Xftp作为我们的linux链接终端，点击官网链接下载\n\nhttps://www.xshell.com/zh/free-for-home-school/\n\n家庭和校园使用是免费的（个人用户）填了邮箱就可以了，官方会往你的邮箱里面发一个下载软件的链接\n完成上面三步后，现在已经可以连接我们的云服务器了！\n2.连接云服务器2.0直接连接root账户你可以先使用root的账户密码以及公网ip连接服务器\n\n输入公网IP，端口号22不要改\n\n然后点击确认，系统会让你输入用户名和密码，使用用户名root和你刚刚设置的root密码就可以登录了\n\n还可以在tx云这里直接点登录，会使用tx云的默认账户lighthouse连接你的云主机\n\n\n\n这个方法只适合基础使用，下面讲解两个不同的方法\n\n\n2.1使用SSH密钥因为Xshell比较聪明，会帮我们记住账户密码，自动输入。但是在很多软件（比如putty）每次开启连接都需要输入账户和密码。这时候我们可以使用更加安全的加密SSH方式连接我们的终端\n\n如果你想达到多人一机的目的，请跳过本步骤，直接看2.2\n\n2.1.1创建本地密钥在Xshell的选项卡中，新建一个密匙\n\n无需修改默认参数\n\n这里会让你输入密匙名称和密码，请记住这里的密码！如果忘记了就只能重新生成一个密匙了\n\n\n生成完毕后，点击用户密匙管理者\n\n找到刚刚生成的密匙，点击属性-公钥，把这里的内容复制下来\n\n2.1.2绑定实例然后来到tx云控制台，密钥，点击创建密钥\n\n选择已有公钥，把刚刚复制的内容丢进去并起个名字。注意这里的地域必须和云服务选择的相同！\n\n搞定后，在云服务器的密钥对界面中绑定密钥（需要先把云服务器关机）\n\n绑定成功后，重启云服务器\n2.1.3Xshell会话设置新建一个会话，这里同样填公网ip\n\n然后需要设置用户身份验证，这里很重要！Xshell提示“密钥没有和云服务器绑定”都是因为这里没有设置！\n\n选择你创建的本地密匙，输入创建密匙时的密码！\n\n不出意外，设置完毕后，你就可以免登录连接到云服务器的root用户了\n\n这个方案只适用于单用户使用，如果多个用户想用这个方法连接同一个云服务器，就会出现大家一起用一个文件路径的问题（就比如我和同学拼，大家都用SSH连接了root用户，白搞）\n\n目前我没找到如何用SSH密匙连接到云服务器指定用户下\n\n2.2使用账户密码登录实现多人一机Linux系统是可以实现多用户管理的，首先我们要创建一个新的用户\n\n参考https://cloud.tencent.com/developer/ask/24465\n\n2.2.1创建新用户先用root连接终端，输入下面的命令\nuseradd 用户名\n\n上面这个命令会建立一个新的用户和同名用户组，用户名自定义;\nuseradd -g root 用户名\n\n这个命令的含义是在root分组下（这个是root用户默认的分组）创建一个用户。如果没有什么特殊的需求，没必要指定用户组为root，用第一条命令直接添加用户就可以了\n\n使用下面的命令设置刚刚创建的用户的密码\npasswd 用户名\n\n随后，使用下面命令测试进入另外一个用户\nsu - 用户名\n\n因为我们是从具有最高权限的root用户进入子用户，所以是不需要输入密码的，但是如果你从子用户往root跑，就需要输入root用户的密码！\n\n你可以在root用户和子用户终端下用mkdir 文件夹名字创建两个不同的文件夹，ls查看当前路径下的文件夹\n你会发现，root和另外一个用户直接是相互看不到对方的文件夹的，这就是我们要达到的隔离效果！相当于互不干扰！\n从子用户A跑到子用户B中，需要输入子用户B的密码。\n这需要root用户在里面创建新的用户。在root里面设置过子用户密码密码后，后续可以修改子用户密码👇\n2.2.2修改密码实际上，在自己的用户名下，是可以更改当前用户名的密码的\npasswd\n\n\n所以可以让服主创建好用户后，自己登陆进去，把自己的密码改掉\n\n注意：Linux学习中有时候会有一些指令只有root用户能干，所以最好是不要那么在乎这些“隐私问题”，root也公开给大家使用就行了\n\n一般情况下，直接在某一个语句之前加sudo，就会用上root权限\n2.2.3腾讯云多用户管理另外，腾讯云支持多用户管理，你可以在用户组这里邀请其他人，他们就能在自己的控制台里面看到你的云服务器了\n\n\n2.2.4Xshell使用账户密码连接这时候我们就不能使用2.1所用的ssh密钥登录了，而是使用账户和密码\n\n使用这个方式前，需要在云服务器控制台解绑所有SSH密钥\n\n刚开始直接连接会显示“SSH服务器拒绝了密码”，这是因为我们没有开启允许密码登录\n\n\n参考https://cloud.tencent.com/developer/article/1909909\n\n在root用户下，使用vim打开下面这个文件。如果你不会使用vim编辑器，请见本文的第三点\nvim /etc/ssh/sshd_config\n\n在最后添加下面的这个语句，:wq!保存并退出\nPasswordAuthentication=yes\n\n\n搞定后，重启云主机，即可用账号密码登录其他账户\n\n如果设置了这个还是不行，可以在控制台中直接重置root密码。重置密码的时候会自动帮你设置好这个（如果没有就再手动设置一下，哈哈）\n\n\n系统内配置好后，在xshell中新建会话，填入如下的内容\n\n在Xshell中直接用对应的账户和密码登录，就可以打开每个单独的账户\n\nX11警告是正常现象，请忽略它\n\n到这里，你就可以和好基友分享这个服务器了！成本大大降低\n2.3查看当前使用云服务器的用户在Xshell终端中输入who，可以查看当前有谁连接了云服务器\n这里会显示连接云服务器的时间，pts代表远程连接，/2代表不同的远程连接窗口\n\n\n3.一些基本的Linux指令之前写博客的时候，忽略了大家可能都是第一次上手linux，对linux命令行一窍不通的。有朋友反应后面的git操作，很多部分都搞不明白怎么用\n这里列出本篇博客需要用到的一些linux指令和vim编辑器的指令。注意，这个只是帮助你完成本篇博客向导后续的git设置，并不是一个完整的命令行教学。建议自行搜索git命令行以及Linux命令行进行学习\n3.1Linux指令ls #显示当前路径下的所有文件ls -a #显示当前路径下包括隐藏文件的所有文件cd 文件路径   #打开对应文件路径cd ..   #回到上一个文件目录cd ~   #回到用户的根目录touch 文件名  #创建对应的文件mkdir 文件夹名字 #创建一个文件夹mv 源路径 目标路径 #移动文件夹或者文件#mv语句还用于重命名文件，操作是mv 原来的名字 新名字cat 文件名字  #显示对应文本文件的内容#如cat .gitconfig，会显示.gitconfig文件中的所有内容\n\n下图演示了部分语句，能帮助你理解这些命令的作用\n\n如果你不小心输错了某些指令或者指令没输入完毕就按了回车，可以使用ctrl+c终止当前操作，linux会另起一个新的入口给你输入命令\n\n3.2vim编辑器操作vim 文件名 #打开对应的文件进行写入\n\n这里我直接以编辑一个C++程序为例，演示vim的操作\n\n打开后是这样的，因为你的vim编辑器还没有设置（见本文第5点），所以和我的不一样，但是这不影响我们的操作。\n注意左下角是vim指令输入的位置以及vim当前模式的提示位置\n\n现在往这个文件中键入内容，你会发现无法键入，这是因为vim是查看模式，我们需要在英文模式下按键盘上的的i（中文模式按i是没有反应的）开启vim的插入模式（也就是insert模式）\n\n开启插入模式后，你就可以往这个文件里面写入内容了。注意vim编辑器是基于键盘的，你需要用键盘方向键定位位置，而不是用鼠标\n\n我往文件中新增了c++语法的内容，现在我想保存这个文件，并退出vim编辑器\n操作是先在英文模式下按键盘的ESC退出插入模式，然后输入:wq保存并退出文件\n\n这就回到了之前的linux命令行界面\n\n下面给出一些常用的vim指令，后续配置git的时候会用到\n:w  #保存文件，相当于windows的ctrl+s:q  #退出文件，前提是这个文件没有被更改#如果你不想保存刚刚的更改，可以使用:q! #强制退出文件:wq #保存并退出文件:wq! #因为部分文件是配置文件，系统权限不够，所以需要加!绕开#后续在编辑gitconfig文件的时候，就需要使用:wq!\n\n\n如果你想从windows中复制内容，粘贴到终端中，需要使用shift+ins键而不是使用ctrl+v\n复制ctrl+ins，粘贴 shift+ins\n如果你不小心习惯性地按了ctrl+s并发现系统卡住了，那是因为这个快捷键在Linux中是暂停终端，可以按ctrl+q复原\n\n上面讲述了vim的一些操作，下面让我们来尝试一下编一个代码\n3.3尝试编译代码C++需要使用g++编译器来编译代码，如果是C语言内容，则使用gcc来编译，操作是一样的\n以下面的指令编译我们刚刚写的代码文件，生成可执行文件TEST\ng++ test.cpp -o TEST\n\n可以看到编译器报错了，我们再vim回去修改代码\n\n修改完毕后，重新编译我们的代码，可以看到没有报错，生成了可执行文件TEST\n\n使用./TEST语句运行可执行文件TEST，即可看到程序输出结果\n\n好了，学会这些后，你应该就能完成后面git的配置操作了！😋\n\n4.Linux的git设置这里我们使用账户密码方式来配置我们的git，因为ssh密钥的方式出现了些许bug\n4.1下载git输入下面的指令查看git的版本，如果没有出现，那说明git没有被安装\ngit --version\n\nCentOS使用下面的指令安装，必须使用root用户。其他LINUX系统（比如ubuntu）需要把yum改成apt-get\nsudo yum install git\n\n\n因为我之前用了树莓派，使用的是apt-get。在这上面不管用，我还去搜了好久为啥sudo: apt-get: command not found😥\n后面才知道CentOS使用的方法不一样\n4.2创建SSH密匙使用SSH的方式操作git存储库，参考👉【Linux】如何使用ssh密钥配置git\n\n注：如果你是github用户，且使用https的git仓库链接时，多次遇到各种各样的无法连接问题，则需要切换使用ssh方式与github通信！这能解决https链接时部分类似time out的网络问题；\n不管用gitee还是github，都更加推荐ssh来操作git。\n\n4.3使用账户密码方式操作git其实在配置云服务器之前，我也不知道git config可不可以实现多用户独立上传到自己的仓库，但是我知道SSH肯定是可以，这点也验证过了。\n后来才明白， git的配置文件是存在当前用户家目录下的，不同用户的git配置相互不会干扰，单个git仓库也可以设置独立的配置项。前期的担心多余了！\n不过，我还是更推荐你使用4.2所提到的ssh的方式操作git，这样会更方便！\n4.3.1 配置全局git设置直接使用下面3个语句来设置某个Linux用户下的全局git邮箱和用户名\ngit config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;git config --global push.default current\n\n测试了一下--global指令后，发现它保存的文件是我们用户家路径下的，而不是root下的全局目录。经过我和同学的测试，这个配置会一直保留，并不会因为终端关闭而失效，不同用户的配置也不会相互干扰。\n在用户的~家目录，使用下面这个指令可以查看git配置文件的内容，每个不同的Linux用户中，配置文件互不影响！\ncat .gitconfig \n\n\n使用SSH的好处是不需要输入密码，不过我们可以用git配置来让git保存你的密码，这样也能在之后使用https方式的上传中不需要输入git远程仓库的用户名和密码。\n操作是编辑.gitconfig 文件，在最后加上下面这两行。其作用是在下一次执行git push操作的时候，保存用户名和密码，后续对相同git远程仓库平台进行push操作的时候都不需要输入密码了。\n[credential]          helper = store\n\n使用vim .gitconfig修改后的配置文件应该和我这个相同\n[user]\temail = 你的gitee/github邮箱\tname = 用户名[push]\tdefault = current[credential]\thelper = store\n\n\n4.3.2 克隆和上传操作使用mkdir 文件夹名创建一个文件夹，cd进去后，执行clone工作，这时候需要使用的是HTTPS链接\n\ngit clone 远程仓库的https链接\n\n\n如果你之前使用了SSH克隆了仓库，可以考虑重新克隆，也可以使用下面的语句更改仓库URL，注意这里的URL是新的仓库git地址\ngit remote set-url origin URL \n\ncd进入仓库目录，即可修改仓库中的文件\n\n修改完毕后，先用git status查看当前状态\n\n可以看到这里列出来我们的README文件被修改了，下面执行一次git push操作。这部分涉及到git命令行操作，如果你不会，可以搜几篇git的博客学习一下\ngit add 文件夹 #添加需要上传的文件路径git commit -m &quot;输入push信息&quot; #git push的信息\n\n这里的git add可以添加单个文件，也可以添加整个文件夹\n\ngit push # 推送本地修改到远程仓库\n\n最后git push的时候，会提示让你输入远程仓库的用户名和密码。\n我同学尝试的时候，这里出现了报错。本来我们以为是用户名或者密码有问题，一直在找到底是哪里出错了\nfatal: Authentication failed for &#x27;https://gitee.com/……&#x27;\n\n实际上是因为我们填错了用户名！！！链接\n\n正确的填写方法应该是下面这样！！！我们错误的把第一个填了gitee的用户名，应该要填写的是gitee账户的邮箱，而不是用户名。\nUsername for &#x27;https://gitee.com&#x27;: 你的gitee邮箱Password for &#x27;https://xxxxx@gitee.com&#x27;: 填gitee密码\n\n注：这里填写密码的时候是不会显示内容的，直接盲打就可以了\n修改正确之后就可以正常PUSH代码了\n\n经过我和同学的测试，这个方法不会因为终端关闭而重置，可以多次复用且不需要每次都输入git的账户和密码，计划通！\n你还可以看看git命令行语句的进阶学习👉传送门\n4.4 git status中文乱码一条命令解决\ngit config --global core.quotepath false\n\n修复前，中文会乱码\n&quot;project/Library_c/Student - \\345\\211\\257\\346\\234\\254.txt&quot;\n\n修复后\nproject/Library_c/Student - 副本.txt\n\n\n5.vim编辑器配置腾讯云的CentOS已经默认安装了vim编辑器，但是vim编辑器本身的默认设置和我们的习惯不同，比如tap它默认是8个空格（windows下是4个）以及缩进的一些问题，这就需要我们自己设置一下vim编辑器\nvim  ~/.vimrc\n\n用上面的语句打开vim编辑器后，用i开启vim的插入模式，输入下面的命令\nsyntax on #开启语法高亮set nu  #显示行号set tabstop=4 #设置tap为4个空格set softtabstop=4 set shiftwidth=4 set autoindent #自动对齐\n\n写完后，:wq!保存即可\n这里我给出了注释，实际写入配置文件的时候，请去掉注释\n6.将Linux命令行设置为中文以CentOS为例，默认的命令行显示是全英文的（但这不代表你不能在里面设置中文的文件夹名字）我也更推荐大家采用英语的终端来学习linux，因为绝大多数linux下的终端工具，都是以英语作为工具的命令教程的。\n\n实在看不懂，就用翻译软件读读，后来看得多了，就熟悉了！\n\n下面介绍如何将Linux的命令行改成中文的（其实就是修改系统语言为中文）\n我们打开云服务器的root账户（必须是root账户）\nlocale\n\n使用上面的这个指令查看现在的语言，发现是en英文\n\nlocale -a\n\n使用上述命令查看当前支持的语言，会显示一大堆，滑到最底部，可以看到我这个系统里面已经有了zh-CN，支持中文！\n\n\n如果locale -a发现没有出现zh，那就下载中文支持包\n&gt;yum install kde-l10n-Chinese\n\n腾讯云的CentOS里面已经有中文了，所以不需要进行这一步操作\n\n找到语言包后，使用如下命令，修改系统语言为中文\nlocalectl set-locale LANG=zh_CN.utf8\n\n重启Xshell连接的ssh终端（不是重启云服务器），再次使用locale指令查看，发现已经设置成了中文语言包\n\n重启Xshell终端（不是重启云服务器），就可以看到，git这里的提示已经变成了中文。不然就是上文出现过的的英文页面👉回到上头康康\n\n修改Xshell中文显示字体如果你觉得默认的中文字体很难看，可以在Xshell中修改一下，点击左上角的文件-当前会话属性\n\n找到外观，把亚洲字体改成黑体，看起来就舒服多了\n\n这里还可以更改游标的样式，我改成了在windows中更熟悉的竖线样式\n7.设置命令行用户名的显示颜色\n参考 https://blog.csdn.net/nmb_jiang/article/details/105195981\n\n默认情况下，bash显示的服务器用户名和名字都是白色的\n\n敲的命令多了之后，就分不清啥是啥了，眼睛都得瞎掉！\n我们可以设置一下回显的颜色，以CentOS为例，需要用vim编辑器打开.bashrc文件\nvim .bashrc\n\n在打开的文件中，键入i开启vim的编辑模式，在文件的末尾输入\nPS1=&#x27;[\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]]\\$ &#x27;\n\n输入完毕后，按esc退出插入模式，输入:wq!保存该文件\n\n顺带一提，如果你和我一样用的是tabby这个ssh终端，则还可以在末尾追加如下内容实现检测工作路径（方便sftp传文件）\n&gt;PS1=&quot;$PS1\\[\\e]1337;CurrentDir=&quot;&#x27;$(pwd)\\a\\]&#x27;\n\n修改好退出后运行下面的指令使其生效\nsource .bashrc\n\n\n看起来就舒服多了！\n另外，建议把root改成黄色+绿色的组合，和子用户区分开来。修改的方法是一样的，内容替换成如下配置。\nPS1=&#x27;[\\[\\033[01;33m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;32m\\]\\w\\[\\033[00m\\]]\\$ &#x27;\n\n如果不想显示host主机的名字，可以把中间的主机名部分给删除了\nPS1=&#x27;[\\[\\033[01;33m\\]\\u\\033[00m\\]:\\[\\033[01;32m\\]\\w\\[\\033[00m\\]]\\$ &#x27;\n\n这样配置后的显示效果如下，更简洁\n[muxue:~]$\n\n8.出现is not in the sudoers file解决方法\n当我们使用sudo命令切换用户的时候可能会遇到提示以下错误：用户名 is not in the sudoers file.\n\n我们需要把当前用户加入sudo的配置文件中，否则用户没有权限执行sudo命令。\n在root用户下，打开sudo的配置文件\nvim /etc/sudoers\n\n打开这个文件，你会发现腾讯云的默认用户lighthouse已经添加过这个语句了。我们在最后加上xxx ALL=(ALL) ALL，其中xxx代表用户名\n比如需要添加KK用户，就这么填\nKK ALL=(ALL) ALL\n\n\n9.删除用户如果有用户的名设置错了，或者想彻底删除掉某一个用户，可以用下面的命令\nuserdel -r 用户名\n\n结语看到这里，云Linux编程学习环境就搭建好啦！\n速速开始学习Linux命令行吧！👍\n\n\n有什么问题可以在评论区提出哦！\n\n","categories":["玩上Linux"],"tags":["Linux","git"]},{"title":"【Linux】权限管理","url":"/posts/3787294814/","content":"Linux部分的内容，我以权限管理作为起始。\n\n\n关于Linux命令行操作的部分，大家可以去网上搜搜，教程很多，且全面：【链接】。这里我就不再把相同的东西复述一遍了，毕竟Linux命令这种东西，你不会的时候可以去查，常见的命令敲多了肯定忘不掉\n不多说，开始Linux权限操作的内容吧！\n\n本篇博客所有演示均在CentOS7.6下进行\n\n\n[TOC]\n1.什么是权限？权限是用于对用户进行约束的。正好比视频网站的vip一样，没有vip权限，你就看不到只有vip才能观看的影片。\n1.1 root和user在linux中，用户分为两种\n\nroot：超级用户\n其他：普通用户\n\n其中root用户的权限最高，可以在系统里面为所欲为。其所作操作在一定程度上会影响用户的使用环境。比如你在root里面安装了某个程序，那么所有子用户都可以使用这个程序，反之不行。\n在root用户中，你还可以通过su user这个命令切换到任何子用户而不用输入密码。但是从子用户切换到root则需要输入root用户的密码。所以，保证你的root用户密码不被他人知道是很重要的！\n\n2.权限管理本篇博客主要关注Linux中的文件权限\n2.1 文件访问者在Linux中，文件访问者分3类，对于文件的权限也分3类\n\n\n\n访问者\n文件权限\n\n\n\n拥有者 owner\nr 读\n\n\n所属组 grouper\nw 写\n\n\n其他用户 other\nx 执行\n\n\n我们要怎么看一个文件对于这三位不同的访问者的权限有什么不同呢？\n使用ll或者ls -l命令即可看到区别\n\n这里文件的前缀，即标识了一个文件的对于3个角色的权限。\n其中muxue是文件的拥有者，root代表所属组。\n2.1.1 linux的组这里需要说明一下，在我之前的腾讯云多人一机的博客中，是用下面这种方式创建子用户的👇\n\n这里就把子用户分到了root组下面，作用是让子用户可以通过su获得root权限\n如果你在创建用户的时候没有指定组的话，系统会自动创建一个与用户名同名的组。\n\n组有什么用？\n\n当在一个公司中，多人使用同一台服务器进行开发的时候，就需要通过组来对子用户进行进一步分类。即A组中其他用户（grouper）可以查看到子用户A1的代码，但是B组的用户（other）都看不到A组内的东西。\n这样就能实现多个小组开发不同的板块，而互不干扰。\n\n2.1.2 学会看文件前缀说回正题，我们要怎么看一个文件夹&#x2F;文件的前缀呢？\ndrwxr-xr-x 5 muxue root    4096 7月   3 11:56 code-rw-r--r-- 1 muxue root 1908226 2月  23 2021 get-pip.pydrwxr-xr-x 7 muxue root    4096 6月  26 08:10 GIT\n\n\n关于第一列的文件类型，有下面几种\n\n现在我们知道了文件权限的查看方式，要如何修改一个文件的特定权限呢？\n2.2 chmod修改权限我们可以使用chmod命令来修改文件权限\nchmod u-r test.txt\n\n上面这个命令的作用是，给拥有者去掉test.txt文件的r权限。可以用下面这个命令把权限加回去\nchmod u+r test.txt\n\n同理，如果你需要修改所属组和其他人的权限的话，指定g和o即可\nchmod g-r test.txt //去掉所属组的r权限chmod o-rwx test.txt //去掉其他用户的所有权限\n\n除了上面这种依次修改的方式，我们还可以用逗号隔开，用一条命令搞定\nchmod u+rwx,g+rwx,o-rwx test.txt //给拥有者，所属组加上所有权限。去掉other的所有权限\n\n如果你想批量修改成同一个权限，还可以使用a来指定all\nchmod a=rw test.txt\n\n\n2.2.1 以八进制修改文件权限除了上面这个+和-比较好辩认的方式以外，我们还可以通过“八进制”的方式来修改文件权限。\n对于一个用户来说，拥有所有权限rwx，如果我们将它与二进制进行对应，就会得到下面的结果\nrwx111二进制对应7\n\n注意，这里的八进制并不是要通过八进制来读写权限的编码，而是用二进制来读取后，可得到最高权限7（不会超过7，所以是八进制）\n了解上面这个方式后，你便可以写出所有权限类型对应的编号\n\n\n\n权限\n二进制\n对应编号\n\n\n\nrwx\n111\n7\n\n\nrw-\n110\n6\n\n\nr-x\n101\n5\n\n\nr–\n100\n4\n\n\n-w-\n010\n2\n\n\n-wx\n011\n3\n\n\n–x\n001\n1\n\n\n当我们修改一个文件的权限的时候，就不需要用a=这种相对古板的方式。而可以通过编码来直接指定3类用户的不同权限\nchmod 777 test.txt //给所有用户为rwx权限chmod 664 test.txt //给u和g用户为rw-，o用户为r--//……\n\n2.3 rwx权限区别修改完这些文件后有什么区别呢？\n当我们创建一个文件夹和一个常规文件时，作为拥有者，默认有文件夹的所有权限和文本文件的rw权限。\n\n2.3.1 常规文件先来看看test.c的各种权限有什么不同吧！\n我们可以通过cat读取test.c文件的内容，这便是读权限r\n\n而通过vim、nano等编辑器修改这个文件，就是写权限w\n如果我们去掉r和w权限，就无法读，也无法写\n\n使用nano打开test.c文件，会有以下报错\n\n那么对于一个常规文件而言，x权限有什么用呢？\n我们知道，当我们使用gcc等编译器编译代码文件时，会出现一个a.out可执行文件。这里的x便是可执行文件的标识。同时，这个文件也是用绿色标明出来了。\n\n如果我们给test.c也加上x权限，则它也会变成绿色，可以直接用./test.c来执行。当然，直接执行一个.c文件是没有意义的\n\n2.3.2 文件夹（目录）\n在Linux下，一切皆文件。我们所说的目录也是一个文件\n文件=内容+属性\n在目录中保存的是文件的属性（包括文件名）我们想访问一个文件，首先要通过路径去找到这个文件。\n\n那么对于一个文件夹而言，rwx权限又是什么呢？\n\n当我们使用ls的时候，其实是可以指定路径的，默认为.（当前路径）\n可以看到，现在显示出了Mytest中的my.txt文件。\n如果我们去掉文件夹的r权限，在执行ls。就会报错权限不够\n\n得出结论，ls查看某一个文件夹中的文件，需要拥有文件夹的r权限。即便你进入这个文件夹，如果没有r权限，依旧无法用ls显示文件夹里面的内容。\n但是这时候，我们还拥有文件夹的w权限，我们可以把其他文件拷贝到Mytest文件夹中\n\n把r权限加回来，可以看到test.c文件已经被拷贝进去了\n\n这便是w权限的作用，修改文件夹中间的内容。比如拷贝另外一个文件到文件夹中\n\n去掉w权限后，我们也无法删除文件夹中的内容\n\n最后，对于文件夹而言，x权限代表的是能否cd进入该文件夹\n\n\n此时虽然我们无法cd进入，但我们拥有rw权限，可以直接从外部修改这个文件夹里面的内容，并进行访问吗？\n\n答案是nope！不可以\n\n因为在Linux中，所有的操作都要通过路径来进行。路径也是访问文件夹的一个方式（需要x权限）此时因为无法cd进入该文件夹，也就无法通过路径访问这个文件夹的内容。所以没了x权限之后啥事都干不了\n当我们把x权限加回来之后，就可以这么做了\n\n\n如果对于目录只没有r权限，允许进入，可创建文件并写入内容，但不可读取其中内容\n如果对于目录只没有w权限，允许进入，允许在目录下ls查看文件列表，但不可以修改里面的文件\n如果目录没有rw权限，允许进入，但是不能修改也不能查看目录下的文件内容\n如果没有x权限，无法进入，也无法修改&#x2F;查看其中内容\n\n关于最后一点，不同系统的实现可能不一样。我的系统是CentOS7.6，请以你的实际情况为准！\n\n2.4 chown&#x2F;chgrp2.4.1 chown修改拥有者我们可以通过这个指令，把一个文件的拥有者修改为指定用户\nchown [参数] 用户名 文件名\n\n注意，在默认情况下，系统是不允许你修改文件的拥有者的。不过我们可以通过在语句前面加sudo的方式，短暂获取root权限，对文件拥有者进行修改\n\n这里如果提示不在sudoer flis里面，可以参考博客里面第八点的解决方案\n\n\n注意，这里我修改为了root用户，root用户拥有最高权限！即便这是子用户的文件，root用户也可以为所欲为进行修改和删除，不受任何权限的约束。\n如果我们把用户改成其他子用户，其实这个子用户依旧访问不到这个文件。\n\n这就好比你告诉你的朋友，我要送你一个键盘。这个键盘的拥有者即将变成你的朋友。但是你没有把键盘给你朋友，键盘还在你家里，你的朋友依旧用不了这个键盘。\n\n换到Linux环境中，就是在A的用户路径下有一个B用户的文件。但由于B用户无法访问A的用户路径，所以依旧无法访问到这个“属于B的文件”\n2.4.2 chgrp修改所属组chgrp [参数] 用户名 文件名\n\n这里因为我的环境里面没有其他组，所以就不演示该功能的成果了\n\n\n2.5 关于默认权限Linux中有一个默认权限：\n\n默认目录权限777\n默认常规文件666\n\n可为什么我创建的目录文件的权限是755，而常规文件的权限是644呢？\n\n这里我们可以用umask命令查看权限掩码\n\n这个权限掩码是什么意思呢？\n抛弃首位不看，后面的是022。根据2.2.1中提到的八进制方式，我们可以解读出这个权限为\n--- -w- -w-\n\n权限掩码的作用就是，在权限掩码中出现的权限，在实际创建文件的时候不会出现！\n仔细观察你就可以发现，这里我的文件夹权限如下，正好和掩码相反！\nrwx rwx rwx //默认权限777--- -w- -w- //掩码022rwx r-x r-x //实际创建755\n\n而常规文件的默认权限666是rw-rw-rw-，实际创建的结果也和掩码相反！\nrw- rw- rw- //默认权限666--- -w- -w- //掩码022rw- r-- r-- //实际权限644\n\n如何计算？这里的权限并不是简单的相减得出来的，其是通过默认权限&amp;(~umask)得出的\n\n先对默认权限的umask进行按位取反\n再将取反后的结果和默认权限（目录777，常规文件666）按位与得出\n\n2.5 file命令除了用文件属性的第一位来查看我们文件的属性之外，我们还可以用file命令来查看更加详细的文件属性\n\n当我们创建了一个C语言文件，并对他进行编译后，可以得到一个C的源文件和一个可执行文件\n\n常用选项如下\n-c 详细显示指令执行过程，便于排错或分析程序执行的情形-z 尝试去解读压缩文件的内容\n\n2.6 粘滞位简单介绍，粘滞位就相当于给一个目录上了胶水，其他人无法删除被黏住的目录（和目录下的文件）！\nchmod +t test\n\n前面提到了，作为other，你可以去访问别人的目录（只要other有对应的权限）\n比如这里我用\tmuxue用户创建了一个test1.c文件，另外一个用户可以读取这个文件，但是不能写入\n\nvim打开该文件会报错\n\n但这里有一个bug就是，即便你没有那个目录内文件的权限，你依旧可以删除这个目录下的文件！\n\n粘滞位的存在就是保护整个目录，不允许被其他用户删除！\n\n添加粘滞位后，可以看到在Other的权限处出现了一个大写的T\n这时候我们再尝试用另外一个账户删除，就会报错——吗？\n\n以上就是一个明显的错误示范，粘滞位保护只能在root下进行操作，而且粘滞位只能给目录上，并不能单独给一个文件上！\n\n给目录上了粘滞位后，再尝试删除，系统会报警告\n\n被保护后的目录，该目录和目录下的文件只能被下面的用户删除：\n\n超级用户root\n目录的所有者\n该文件的所有者\n\n关于最后一点，虽然粘滞位保护了目录下的其他人的文件不能被你删除。但这不影响你在这个目录下创建&#x2F;写入&#x2F;删除你自己的文件\n\n结语关于linux权限管理到这就结束啦！\nlinux操作在未来找工作的时候非常重要，也是我们学习的时候和其他童鞋拉开差距的一环。\n\n因为很多人可能上完本科4年都不知道企业招聘的时候会考linux操作😥\n\n有什么问题可以在下面留言！看到了就会回复的\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】一些工具的简单使用，vim/gcc/gdb/make","url":"/posts/1451721896/","content":"本篇博客将介绍linux下面一些简单工具的使用\n\n\n[TOC]\n1.vim编辑器1.1 安装vim# centossudo yum install vim# debiansudo apt-get install vim\n\n需要注意的是，vim编辑器下不能使用CTRL+S来保存文件，因为在linux中这个快捷键的作用是暂停该终端，整个系统都会卡住，这时候使用CTRL+Q取消暂停就可以了。\n1.2 文本操作vim一共有三种模式：命令模式，编辑模式，底行模式；\n\n进入vim时就是默认的命令模式，此状态下敲击键盘会被识别为命令\n按i进入编辑模式，此时的输入是正常写入文本\n在命令模式中，按英文半角下的 : 进入底行模式，此时输入的是底行模式的特殊命令与配置\n\n以下是命令模式下的一些文本批量化操作\nyy 复制当前行，nyy复制n行p  粘贴再当前行的后面，np粘贴n次剪贴板的内容dd 剪切（删除）当前行，ndd操作n行u  撤销ctrl+r  重做shift+g 光标快速定位到文本末尾gg 光标快速移动到文本头n+shift+g 光标定位到文本的第n行shift+4 光标定位到该行末尾shift+6 光标定位到该行开头w,b   以单词为单位进行移动光标h,j,k,l  左、下、上、右shift+`  大小写快速切换r   替换光标所在处的字符，支持nrshift+r  批量化替换x  删除光标所在处的字符，nx删除n个\n\nvim进入插入模式的快捷键有a i o，分别对应不同的功能\n1.3 底行模式的操作vim编辑器中底行模式的一些操作如下。在其他模式下按esc即退出到底行模式\n:w   &quot;只保存:q   &quot;不保存退出:wq  &quot;保存并退出:reg &quot;打开vim的寄存器面板:syntax on &quot;开启语法高亮:set nu    &quot;显示行号:set nonu  &quot;取消行号显示:set tabstop=4 &quot;设置tab的缩进，默认为8:set softtabstop=4 &quot;softtabstop是“逢8空格进1制表符”,前提是你tabstop=8:set shiftwidth=4 &quot;设置程序自动缩进所使用的空格长度:set autoindent &quot;自动对齐上一行（这个选项会导致复制的时候代码排版混乱，可以考虑关闭，或者开启粘贴模式）:set paste &quot;开启粘贴模式:set mouse=a &quot;设置鼠标模式，默认是a:%s/A/B/g 将当前文件中的A全部替换成B\n上面的一些配置，写入.vimrc配置文件即可长时生效。\n如果需要写入.vimrc配置文件，需要先把:和注释都去掉\n2.gcc&#x2F;g++编译器g++操作和gcc是一样的，这里我们使用gcc作为演示\n2.1linux下使用不同命令执行程序的几个阶段第一步是预处理，只做文本操作\ngcc -E test.c -o tset.i\n在这个阶段会\n\n展开头文件\n对define等等操作进行替换\n处理条件编译指令\n同时删除所有注释\n\n编译操作\ngcc -S test.i -o test.s\n\n汇编操作\ngcc -c test.s -o test.o\n形成可执行程序\ngcc test.o -o mytest\n这三个命令的顺序就是ESc其中只有-c选项是小写的\n正好就是键盘左上角esc按键的顺序\n2.2代码和库这里我们操作&#x2F;编译的都是自己的代码。比如printf我是调用的c语言库中的函数，并没有自己完成一个打印的实现。\n这时候就需要和系统的c语言库产生关联\nc标准库的位置ls /lib64/libc*\n上面的最后一步形成可执行程序mytest时，系统会自动帮我们把这里的代码和库里面的方法连接起来，形成一个最终的可执行程序，并使用./mytest来执行输出结果\n所以我们平时说的装环境就是需要安装语言的静态和动态库，这样才能正常利用库里面的函数进行代码的编译处理\n同时我们在编译器里面写代码时的代码补全功能也是通过在库函数的头文件里面搜索来完成的。\n\n2.3动态&#x2F;静态链接&amp;库\n动态：linux(.so) windows(.dll)\n静态：linux(.a)  windows(.lib)\n\n网吧是全校所有同学共享的，你在网吧开的机子是和别人一起用的。从学校去网吧（库），然后获得一台机子（库函数），打游戏（执行方法）.这就是一个动态的编译链接的过程，即为动态库。\n如果学校允许带电脑，当你想打游戏的时候用的是自己的电脑，用的是自己的方法，这种情况就是用的静态库。每一个人拥有自己的电脑，这个电脑的功能和网吧里面的功能是一样的，当我们把库中的相关代码直接拷贝到自己的可执行程序中，即为静态链接\n\n动态链接：所有人共享同一个资源\n优点：可以节省资源；\n缺点：一旦库丢失，会导致所有程序失效\n\n\n静态链接：都用的是自己的方法，将库里面的代码拷贝到自己的文件中\n优点：不依赖任何库，程序可以独立运行\n缺点：浪费资源\n\n\n\n查看链接状态，默认是动态链接\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ ldd mytest    linux-vdso.so.1 =&gt;  (0x00007ffc0dd8b000)    /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f89bd66c000)    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f89bd185000)    libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f89bcf81000)    /lib64/ld-linux-x86-64.so.2 (0x00007f89bd553000)\n\n查看可执行程序的构成\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ file mytestmytest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7cf0ffacfdaeadf8de9b4c0fea379b2a15c37e4c, not stripped\n\n2.3.1手动指定进行静态链接gcc test.c -o mytest1 -static\n静态链接生成的可执行程序大小很大，动态链接的默认是8040左右的体积。\n-rwxrwxr-x 1 muxue muxue   8416 Aug  7 07:34 mytest-rwxrwxr-x 1 muxue muxue 861288 Aug  7 07:44 hello\n所以一般情况下我们都推荐使用动态链接，避免占用太大的空间\n\n当我首次尝试这种方式的时候，出现了下面的报错\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ gcc hello.c -o hello -static/usr/bin/ld: cannot find -lccollect2: error: ld returned 1 exit status\n因为系统里面默认不会带.a的静态库，所以会报错。这时候需要我们手动安装一下。\nsudo yum install -y glibc-staticsudo yum install -y libstdc++-static\n安装成功！\nInstalled:  glibc-static.x86_64 0:2.17-326.el7_9                                                          Complete!\n这时候执行就不会报错了！\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ gcc hello.c -o hello -static[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ \n\n3.gdb调试默认生成的可执行程序是无法调试的！在linux里面发布的可执行程序默认是release版本的，无法debug\n需要添加一个-g选项进行编译\ngcc test.c -o test_g -g\n同时debug版本的可执行文件也会比release版本大一些，这大的空间里面存放的就是调试信息\n-rwxrwxr-x 1 muxue muxue 8360 Aug  7 07:50 test-rwxrwxr-x 1 muxue muxue 9376 Aug  7 07:53 test_g\n\n利用下面这个语句可以查看可执行程序的调试信息\nreadelf -S test | grep debug\n可以看到debug版本包含了很多调试信息，而release版本里面没有\n[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ readelf -S test | grep debug[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ readelf -S test_g | grep debug  [27] .debug_aranges    PROGBITS         0000000000000000  00001061  [28] .debug_info       PROGBITS         0000000000000000  00001091  [29] .debug_abbrev     PROGBITS         0000000000000000  00001122  [30] .debug_line       PROGBITS         0000000000000000  00001164  [31] .debug_str        PROGBITS         0000000000000000  0000119f\n3.1尝试调试一个简单的代码以下是一些简单的gdb操作\nb 行号：打断点info b：查看断点d 断点编号：取消断点l 行号：显示代码l main：显示包含main的那一行r：run，开始运行程序,跳到第一个断点r 参数1 参数2：运行程序的时候给程序传入命令行参数，跳到第一个断点s：step，逐语句，对应vs的F11（进入函数）n：next，逐过程，对应vs的F10c：continue，跳转道下一个断点p：查看变量display / undisplay：常显示 或 取消常显示until 行号：跳转到指定行finish：执行完一个函数后停下bt：查看函数调用堆栈signal 信号名：给当前正在调试的程序发送信号\n\n提醒：编译的时候记得加上-g选项指定debug版本\n下面是一个用于演式的示例代码\n#include &lt;stdio.h&gt;int Add(int a,int b)&#123;    printf(&quot;Add(a,b)\\n&quot;);    return a+b;&#125;int main()&#123;    printf(&quot;hello wolrd！\\n&quot;);    int ret=Add(1,20);    printf(&quot;ret: %d\\n&quot;,ret);    return 0;&#125;\n\ndebug操作演示如下，命令是gdb 可执行文件名；\n[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ gdb test_gGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/muxue/GIT/raspi/vim/TestGdb/test_g...done.(gdb) l23       int Add(int a,int b)4       &#123;5           printf(&quot;Add(a,b)\\n&quot;);6           return a+b;7       &#125;89       int main()10      &#123;11          printf(&quot;hello wolrd！\\n&quot;);(gdb) b 11Breakpoint 1 at 0x4005a7: file test.c, line 11.(gdb) llUndefined command: &quot;ll&quot;.  Try &quot;help&quot;.(gdb) l 105           printf(&quot;Add(a,b)\\n&quot;);6           return a+b;7       &#125;89       int main()10      &#123;11          printf(&quot;hello wolrd！\\n&quot;);12          int ret=Add(1,20);13          printf(&quot;ret: %d\\n&quot;,ret);14          return 0;(gdb) b 13Breakpoint 2 at 0x4005c3: file test.c, line 13.(gdb) rStarting program: /home/muxue/GIT/raspi/vim/TestGdb/test_g Breakpoint 1, main () at test.c:1111          printf(&quot;hello wolrd！\\n&quot;);Missing separate debuginfos, use: debuginfo-install glibc-2.17-326.el7_9.x86_64(gdb) shello wolrd！12          int ret=Add(1,20);(gdb) sAdd (a=1, b=20) at test.c:55           printf(&quot;Add(a,b)\\n&quot;);(gdb) p retNo symbol &quot;ret&quot; in current context.(gdb) finishRun till exit from #0  Add (a=1, b=20) at test.c:5Add(a,b)0x00000000004005c0 in main () at test.c:1212          int ret=Add(1,20);Value returned is $1 = 21(gdb) sBreakpoint 2, main () at test.c:1313          printf(&quot;ret: %d\\n&quot;,ret);(gdb) p ret$2 = 21(gdb) p &amp;ret$3 = (int *) 0x7fffffffdf3c(gdb) sret: 2114          return 0;(gdb) s15      &#125;(gdb) qA debugging session is active.        Inferior 1 [process 5932] will be killed.Quit anyway? (y or n) y[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ \n整体的操作并不是特别复杂，大家可以自己尝试一番，有问题可以评论提出\n\n4.make&#x2F;makefile这是一个批量处理工具，我们可以通过make来批量编译一些代码，避免手动敲打命令行的出错问题。这在大型项目中非常重要。\nmakefile是当前路径下的一个普通文件，存放了如下内容：\n\n依赖关系\n依赖方法\n\n假设我们需要形成一个c语言的可执行文件\n依赖关系：test -&gt; test.c依赖方法：gcc test.c -o test\n其对应的makefile如下\ntest:test.c    gcc test.c -o mytest\n注意，第二行的依赖方法必须tab缩进，不然无法正常调用！\n编写好makefile后，直接在当前路径下执行make。系统会自动查找名称为makefile&#x2F;Makefile的文件执行\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ makegcc test.c -o test[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ ./testhello wolrd！Add(a,b)ret: 21\n\n我们还可以写一个清除指令，用于在编译后删除大量临时出现的可执行程序\n.PHONY:cleanclean:    rm -f test\n在原本的makefile后追加这部分内容即可\n通过make clean来清理文件\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ make cleanrm -f test[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test.c\n4.1出现missing separator解决方案当我执行make clean的时候出现了这个报错\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ make cleanmakefile:4: *** missing separator.  Stop.\n这是因为在我的makefile中，依赖方法前面的缩进是4个空格，而不是1个tab\n注意需要使用tab进行缩进，而不能手动打空格！\n4.2make如何判断需不需要重新生成？当我们在一个文件夹内执行过make之后，再次make，系统会提示当前的可执行程序test已经是最新版本，无需更新。\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ makegcc test.c -o test[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ makemake: `test&#x27; is up to date.[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ \n\n那么系统是如何实别出来我们的原代码是否有过更改的呢？\n4.2.1 stat时间戳我们可以使用stat命令查看一个文件的时间戳\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test  File: ‘test’  Size: 8440            Blocks: 24         IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450818     Links: 1Access: (0775/-rwxrwxr-x)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-08-07 17:18:40.463120772 +0800Modify: 2022-08-07 17:18:40.463120772 +0800Change: 2022-08-07 17:18:40.463120772 +0800 Birth: -[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test.c  File: ‘test.c’  Size: 201             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450788     Links: 1Access: (0664/-rw-rw-r--)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-08-07 09:30:39.043992599 +0800Modify: 2022-08-07 09:30:38.544992699 +0800Change: 2022-08-07 09:30:38.544992699 +0800 Birth: -\n\n这里可以看到，一个文件的时间戳分为3个，分别是Access查看、modify修改，Change更改。\n第一个查看很好理解，那么modify和change有什么区别呢？\n我们可以手动修改一个程序看看情况\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ vim test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test.c  File: ‘test.c’  Size: 207             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450788     Links: 1Access: (0664/-rw-rw-r--)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-08-07 17:25:12.958082845 +0800Modify: 2022-08-07 17:25:12.808082859 +0800Change: 2022-08-07 17:25:12.808082859 +0800 Birth: -\n\n这里我通过vim进入该文件，添加了一行注释，可以看到，相比于之前的时间，3个时间戳都被修改成了最新的时间。这是因为我们修改文件的时候一定会查看，也有modify和change\n而如果我只是修改这个文件的权限，并不修改它的内容，会发生什么？\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ chmod o-r test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test.c  File: ‘test.c’  Size: 207             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450788     Links: 1Access: (0660/-rw-rw----)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-08-07 17:25:12.958082845 +0800Modify: 2022-08-07 17:25:12.808082859 +0800Change: 2022-08-07 17:27:34.378068762 +0800 Birth: -\n\n可以看到，只有change发生了变化。\n文件=内容+属性，在这里的modify对应的就是内容修改，而change对应的是属性修改。而当我们修改文件内容的时候，会引起文件大小的变化，也是属性变化，所以修改内容也可能会引起change的变化！\n\n了解了这个时间戳，那么系统是怎么判断是否需要重新生成就很简单了：比较依赖关系中左边的目标文件和右边源文件的modify时间，如果源文件的modify时间早于目标文件，那么说明目标文件生成之后，源文件并没有发生更改，那么也无需再次生成\n4.2.2  PHONY关键字的作用在前面提到的clean代码中，我们使用了.PHONY关键字来修饰clean。\n这个关键字让clean作为一个伪目标，且总是被执行\n\n怎么理解这个总是被执行？\n\n当我们的源文件没有发生更改的时候，make不会重新生成，这个叫做总是不被执行\n\nPHONY关键字的作用就是屏蔽系统对于modify时间的检查，每一次都会强制执行该语句的依赖方法。\n\n一般情况下我们只有在clean的时候才会使用.PHONY关键字来修饰\n4.3 $@ $^ 高级用法makefile中如果某个项目有多个依赖项文件，可以用这种方式来写。\nmytest:test1.c test2.c\tgcc -o $@ $^\n\n第一个$@代表是左边的目标文件，$^代表是源文件，这样写可以实现全匹配，不需要自己一个一个写源文件了\n[muxue@bt-7274:~/git/linux/code/22-08-07_make_gdb]$ cat makefiletest:test.c add.c\tgcc $^ -o $@[muxue@bt-7274:~/git/linux/code/22-08-07_make_gdb]$ makegcc test.c add.c -o test[muxue@bt-7274:~/git/linux/code/22-08-07_make_gdb]$ ./test4\n\n4.4 定义变量直接使用等于号即可，而且不需要添加引号。\nCC = g++FLAGS = -std=c++11\n\n\n4.5 命令行提供变量makefile除了可以帮我们快速编译项目，有的时候我们还可以把一些常用的命令给写进去。\n比如打包压缩某一个目录的文件（备份），用了makefile后，我们想备份、打包某个文件夹的时候，只需要make一下，不需要写一长串的tar命令了。\ntar -zcvf ./.bak/code.tar.gz ./code\n\n上面这个命令的作用是，将code目录打包生成一个code.tar.gz压缩文件，放入到当前路径的.bak文件夹中。\n此时我的需求是给这个命令传一个参数日期，让生成的压缩包文件名能带上日期，makefile可以这么写\n.PHONY:tartar:\ttar -zcvf ./.bak/code$&#123;d&#125;.tar.gz ./code\n\n这里留下了d作为一个参数，可以在执行make命令的时候指定\nmake d=230128\n\n这样操作了之后，打包压缩出来的文件名就会是code230128.tar.gz ，完美达成目的！\n\n5.尝试编写一个简单的linux进图条当我们在linux系统上下载一些软件的时候，总是可以看到用文字组成的进度条，这些进图条是怎么做出来的呢？\n下面我们可以尝试用C语言写出一个简单的进度条。在这之前，我们需要了解一些概念\n5.1 缓冲区在我之前的C语言文件操作博客中，提到了一个缓冲区的概念。简单来说，当我们printf一道字符串的时候，系统是先把这个字符串写入缓冲区，再把缓冲区的内容输出到屏幕上\n比如下面这个代码，再linux环境中，\\n会自动刷新缓冲区。\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123;\twhile (1)\t&#123;\t\tprintf(&quot;hehe\\n&quot;);\t\t//在linux环境中，不带&#x27;\\n&#x27;的时候，并不会打印（没有刷新缓存区）\t\t//而在VS环境中，带不带都会正常打印\t\tsleep(1);//linux环境中，sleep函数的参数，单位是秒（VS是毫秒）        //             linux环境下，sleep函数需要小写，VS下是Sleep\t&#125;\treturn 0;&#125;\n\n如果我们去掉\\n，系统则不会立即打印内容。\n\n这时候需要我们手动用fflush(stdout)刷新一下缓冲区，现在程序会在一行中打印了\nfflush(stdout);//手动刷新缓冲区\n\n\n5.2 回车和换行在我们日常生活中提到的换行一般指的是回车+换行\n实际上，回车和换行是有区别的：\n\n回车：光标回到该行的最前面\n换行：光标去到下一行，但是位置不变\n\n在C语言中，\\n执行的就是回车+换行，而\\r是回车\n那么我们就可以利用这个特性，来实现一个简单的倒计时\n#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main()&#123;    int i=9;\twhile (i&gt;=0)\t&#123;\t\tprintf(&quot;%d\\r&quot;,i);\t\t//在linux环境中，不带&#x27;\\n&#x27;的时候，并不会打印（没有刷新缓存区）\t\t//而在VS环境中，带不带都会正常打印         fflush(stdout);//手动刷新缓冲区\t\tsleep(1);//linux环境中，sleep函数的参数，单位是秒（VS是毫秒）        //             linux环境下，sleep函数需要小写，VS下是Sleep        i--;\t&#125;\treturn 0;&#125;\n\n\n\n5.3 进度条做好前面的准备工作后，现在我们就可以来打印一个简单的进度条了！\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define NUM 102#define STYLE &#x27;#&#x27;void process()&#123;    char bar[NUM];    memset(bar, &#x27;\\0&#x27;, sizeof(bar));    const char *lable = &quot;|/-\\\\&quot;;//在末尾打印一个转动的“小圆圈”    int cnt = 0;    while(cnt &lt;= 100)    &#123;        //默认是右对齐，使用-改位左对齐        printf(&quot;加载中:%-100s[%d\\%][%c]\\r&quot;, bar, cnt, lable[cnt%4]);        fflush(stdout);        bar[cnt++] = STYLE;//打印预定义的符号        usleep(200000);    &#125;    printf(&quot;\\n&quot;);&#125;int main()&#123;    process();    return 0;&#125;\n\n\n这样一个简单的进度条就搞定辣！\n后记linux中一些工具的使用可能不会有windows的编译器那么方便，比如GDB调试。但是在后续编写一些只有linux平台才能运行的代码的时候，我们必须学会使用这些工具，否则操作起来会非常麻烦！\n感谢你看到最后，有任何问题都欢迎在评论区提出哦！\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】进程概念","url":"/posts/3785030062/","content":"本文演示所用系统为CentOS 7.6\n\n\n1.操作系统操作系统是不会直接对用户提供服务的。因为这样会暴露自己的底层实现，对系统稳定性造成了威胁\n\n操作系统是通过系统调用层的方式对外提供接口服务的。\n\n这就好比你是通过前端按钮来使用一个网站的功能，而通常你是看不到网页的后端实现的。\n\nLinux系统的底层是用C语言写的，所以这些接口服务本质上就是一些C语言的函数。这些函数用于操作系统的各种管理。\n我们学习Linux的系统编程，本质上是在学习这些和系统对接的函数。\n1.1 编程语言和系统对接不同的操作系统，其提供的各种管理硬件的函数是不同的。这时候我们的C&#x2F;C++等其他语言想和系统对接（如printf打印到屏幕上）就需要在底层帮用户管理好这些系统接口的调用。当我们使用这些语言的时候，就不需要自己手动去调用\n1.2 描述进程-PCB\nPCB并不是那些绿油油的电路板，这里指的是process control block\n\n进程是有一个担当分配系统资源（CPU时间，内存）的实体\n\n进程信息被放在一个叫做进程控制模块的数据结构中，可以理解为进程属性的集合\n在Linux中的PCB其实就是一个结构体task strcut，包含了这个进程的各种信息。\n\ntask_struct的内容大家可以上网搜搜，能力强的朋友可直接去看Linux的源码。\n1.3 组织进程我们可以在Linux的源码中找到组织进程的方式。所有运行在系统里面的进程都是以task_struct为成员的链表形式存在内核中。下面是关于这个结构体的一部分解析\n\n\n标示符: 描述本进程的唯一标示符，用来区别其他进程\n状态: 任务状态，退出代码，退出信号等。\n优先级: 相对于其他进程的优先级。 \n程序计数器: 程序中即将被执行的下一条指令的地址。 \n内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针\n上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。\nI／O状态信息: 包括显示的I&#x2F;O请求,分配给进程的I／O设备和被进程使用的文件列表。 \n记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。 \n其他信息\n\n\n相关解析可以看看这篇博客【传送门】\n1.4 查看进程1.4.1 ps命令可以用ps命令来查找进程信息。下面这个指令是显示所有的进程\nps axj\n\n系统会打印下面的很多进程信息，这就好比windows下的任务管理器\n\n如果我们使用一个while(1)的死循环函数，运行的时候就变成了一个进程了。我们可以用下面的命令来查找特定的进程信息\nps axj | grep test\n\n\n上图中我们搜索test，出现了两个进程。第一个进程很明显是我们运行的可执行程序。那么第二个是什么呢？\n\n实际上，所有的指令都是一个进程。只不过ls这种类型的命令很快就能执行完毕。\n\n这样一来，我们便可以确认，出现的第二个进程实际上是我们执行这条搜索语句出现的。可以用下面的这个指令来屏蔽grep的结果，只显示我们自己的那个程序。\nps axj | grep test | grep -v grep\n\n最后一个指令的意思是忽略掉包含grep的结果，现在就不会显示第二个grep的进程了\n\n1.4.2 proc目录还可以通过/proc系统文件夹来查看系统进程信息。这里面的内容都是一个实时的进程信息\n\n每一个进程都有一个自己的PID(process id)，用来标识唯一的进程\n可以用下面的这个指令来显示一个提示信息，其中的&amp;&amp;代表逻辑与，只有第一个命令执行成功，才会执行第二个命令\nps ajx | head -1 &amp;&amp; ps ajx | grep test | grep -v grep\n\n\n这里就告诉我们了这个命令的PID是什么，即第2位数字\n\n如果你需要查看PID为1的进程，则打开对应进程的文件夹\n\n上面我们搜到的进程PID为5408，查看对应文件夹可以看到下面的内容\n\n当我们关闭了./test进程在去查找，会发现没有这个路径了\n\n在每一个进程文件夹中都有一个cwd和exe\n\ncwd其指向的是进程当前的工作路径\nexe指向的是进程对应可执行程序的磁盘文件\n\n比如现在我使用ps命令查找到了下面这个python代码进程\n\n使用ls -l /proc/19423命令打开对应文件夹，便可以看到cwd和exe的指向\n\n这代表该进程是用python3.10进行执行的，其工作目录为cwd指向的路径\n\npid、工作路径等等信息都存放在进程的task_struct中\n\n1.4.3 C语言代码获取ppid和pid除了在命令行中输入命令以外，我们还可以通过C语言代码中和系统通信的库函数来获取当前进程的ppid和pid\n#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123;    printf(&quot;pid: %d\\n&quot;, getpid());    printf(&quot;ppid: %d\\n&quot;, getppid());    return 0;&#125;\n\n\n使用一个while(1)循环，我们就可以看看这个进程是否和我们用ps搜出来的结果相同\n\n\n可以看到，搜寻出来的结果和该程序自己打印的结果是一样的\n实际上，我们所有在命令行上执行的程序，都是bash（即当前命令行）的子进程\n\n1.5 fork 通过系统调用创建父子进程如果你用过gitee或者github，想必对fork并不陌生。在git托管网站上，我们fork别人的仓库，便会在自己的账户中出现一个别人仓库的“子仓库”。我们可以在这个“子仓库”里面修改一部分信息，再创建一个pull request合并入被fork的仓库\n而在Linux系统中，fork的作用便是可以创建一个父子进程，这两个进程相互独立，且有很多特殊的地方等着我们的探索\n比如：fork具有两个不同的返回值！\n下面是一个示例代码\n#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123;    pid_t id = fork();    //id=0 子进程；&gt;0为父进程    if(id == 0)    &#123;        //child        while(1)        &#123;            printf(&quot;子进程，pid: %d, 父进程是: %d\\n&quot;, getpid(), getppid());            sleep(1);        &#125;    &#125;    else&#123;        //parent        while(1)        &#123;            printf(&quot;父进程，pid: %d, 父进程是: %d\\n&quot;, getpid(), getppid());            sleep(1);        &#125;    &#125;&#125;\n\n运行上面的代码，你会发现父子进程竟然交叉运行了！而且这两个进程都有不同的pid。其中子进程的ppid即为父进程的pid！\n\n奇怪，我们的while循环明明是写在if里面的啊？为什么else里面的while也被正常执行了呢？\n1.5.1 man fork这便需要我们了解一下fork到底是何方神圣了。\nman fork\n\n\n如果你出现No manual entry for fork的报错，在CentOS下请尝试执行下面的命令\nsudo yum install -y man-pages\n\n\n同时可以看到关于fork的返回值的描述\n\n这便能告诉我们，为啥fork下方同一个id值使用打印会返回不同的结果；以及if else被交叉运行的原因。\n\nfork之后，父子进程共享代码，都会执行后面的if else语句\nfork之后，父子进程的返回值不相同，所以if else语句进入的模块也不相同\n\nfork进程给父进程返回子进程pid，方便父进程管理自己的子进程。这是因为父进程必须要有标识子进程的方法！\n\n一个父亲可以有多个孩子，需要pid来进行管理\n一个子进程只能有1个父亲，所以用0来标识子进程创建成功即可。它可以用ppid方便的找到自己的父进程。\n\n1.5.2 fork做了什么fork会调用系统的OS system call，创建一个子进程\n\ntask_struct + 父进程代码和数据\ntask_struct + 子进程代码和数据\n\n子进程的代码和数据大多数都是从父进程继承下来的，不过pid和ppid肯定不会继承。其内部的变量/数据和父进程独立（这个后续的博客会涉及）\n\n当fork创建好子进程并进行return的时候，它的功能就已经完成了\n此时还会将子进程放入运行队列\n\n了解了这个之后，再来理解一下进程是如何被运行的👇\n2. 如何理解进程被运行在我们的系统中，每一个CPU都有一个运行队列\n这个运行队列之中存放的便是task_struct，系统会依次运行每一个进程。\n\n在上面我们的fork创建子进程之后，便会把子进程放入运行队列\n\n所以实际上，fork并不是有两个返回值，而是在先运行了父进程后，又创建了一个子进程。这两个进程共享代码，而且它们都是挂载在同一个bash命令行上，才会出现上述交替打印的情况。\n\n结语下篇博客是有关进程状态的内容，阿巴阿巴，好久没写博客了\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】进程概念","url":"/posts/3785030063/","content":"本篇博客是有关进程状态的，好久没有写Linux的博客了，一起来看看吧！\n\n\n\n实验系统：CentOS 7.6\n\n1.系统进程的运行状态当我们想到进程的时候，一定要首先想到task_struct结构体。该结构体内部有一个state状态码，用于标识当前进程处于什么状态\n\n1.1 运行态CPU会有一个进程队列（双链表），队列的每一个成员都是一个task_struct结构体，用来维护即将运行的进程。当轮到某个进程运行的时候，CPU就会将这个进程的数据和代码放入内存和自己的寄存器，并开始运行\n只要进入了运行队列的进程，就是运行态的进程\n\n所以运行态并不是正在运行的进程\n\n为什么我们对这件事的感知不大呢？那是因为现代的CPU的运行速度非常快，这些运行队列的轮转周期很短\n1.2 终止态终止态：进程还在，但是永远不会运行，在队列中等待被释放\n为什么进程都终止了，不立马释放对应的资源，而需要维护一个终止态？\n\n这是因为当前CPU&#x2F;操作系统正在忙着干其他的事情，没时间过来释放你。所以会将不运行的进程放入终止态的队列（将该进程task_struct结构体插入该队列）\n当操作系统空闲的时候，便会取终止态队列里面的进程进行释放\n\n1.3 阻塞态一个进程使用资源的时候，不仅仅会申请CPU的计算资源，还有可能申请其他更多的资源，比如网络/硬盘/网卡/显卡等等\n如果申请这些资源的时候得不到满足，就需要排队\n\nCPU资源：运行队列\n其他资源：也需要进行排队\n\n 下面用伪代码的方式来描述一下进程为何会阻塞 \nstruct cpuinfo&#123;    //……    //运行队列    task_struct *queue;&#125;struct disk_div&#123;   \t//磁盘的等待队列    task_struct *queue;&#125;struct net_div&#123;   \t//网卡的等待队列    task_struct *queue;&#125;\n\n当我们的进程访问某种资源，特别是外存（磁盘）这种慢设备资源的时候，如果磁盘暂时还没有准备好，操作系统就会把当前进程从运行队列剥离，插入到对应需要访问的设备下的等待队列中\n\nDDR4内存的读写大约是40GB&#x2F;S，即便是现在市面上较快的pcie4.0固态硬盘其读写速度也只有7GB&#x2F;S左右，这个差距还是很大的。所以才说磁盘是“慢设备”资源\n\n操作系统移动task_struct到对应的队列下，就是起了它管理进程的作用。同时将进程剥离运行队列，也能让等待慢设备资源的进程不至于把整个系统卡死。当我们电脑上运行的进程很多的时候，就有可能遇到当前的进程在等待过程中出现了阻塞，此时进程的代码不会运行。最直观的反应便是当前进程卡住不动了。\n\n1.4 进程挂起进程挂起和进程阻塞很类似，但也有不同。\n\n进程挂起和阻塞不同的是，阻塞只是单纯地在等待慢资源。而挂起则是该进程的数据被放入回了磁盘，进程本身依旧在排队等待。操作系统会有一个专门的swap分区，用来存放挂起进程的代码和数据。\n操作系统这么管理，是为了不让内存在多进程运行的时候不够用了。这也是为什么，当我们内存不够用的时候，往往伴随着磁盘的频繁读取。\n\n当然，内存不够也有可能是某一个进程需要一次性加载的代码数据已经超过了内存的大小😂\n\n下图中左下角的部分便演示了操作系统在处理阻塞和挂起态的操作循环\n\n\n2.Linux下的进程状态描述在linux下进程的状态是存放在一个数组里面的\n\n2.1 S和R状态的说明其中R对应的是运行态，S对应的就是阻塞态（linux下为休眠）\n我们可以运行一个程序看看它处于什么状态\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    while(1)&#123;        printf(&quot;%d\\n&quot;,getppid());        sleep(1);    &#125;    return 0;&#125;\n\n运行发现，左侧打印出了当前进程PID，而右侧当我们使用ps命令查询该进程的时候，发现该进程的状态是S+也就是休眠状态\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test32080 30455 30455 32080 pts/0    30455 S+    1001   0:00 ./test\n\n\n这是为什么？程序不是一直都在运行吗？\n首先需要知道的是，printf需要将数据打印输出到屏幕上，屏幕作为外设，同样属于慢资源。所以我们的进程绝大部分时间都是处于sleep(1)以及等待屏幕刷新的过程中。而CPU只需要执行printf一个操作，这个操作几乎是瞬间就进行，当然也看不到该进程处于运行态了\n即便我们把sleep(1)去掉，进程也是需要等待屏幕刷新，同样处于S+状态\n那要怎样才能让进程处于运行态呢？很简单，我们写一个不和外设交互的死循环即可\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    while(1)&#123;\t\tint a = 10;    &#125;    return 0;&#125;\n\n可以看到现在进程的状态是R+，处于运行态！\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test32080 32489 32489 32080 pts/0    32489 R+    1001   0:06 ./test\n\n\n2.2 D状态disk sleep除了基本的S状态，linux下还有一个专门的disk sleep状态。如同它的名字一样，这个状态是专门为访问硬盘的进程设计的\n假设有下面这样一个场景\n1.进程A需要访问磁盘资源，写入1GB的数据2.磁盘很忙，进程A进入S状态等待读写3.操作系统发现这里有个进程没干活，内存又不够了，于是把进程A干掉了4.轮到进程A独写的时候，磁盘发现进程A已经被干掉了，于是没管它的1GB数据5.结果：这个1GB数据丢失了\n\n出现这种数据丢失，谁都不想的嘛。所以Linux就设置了一个D状态，\n\nS 浅度睡眠\nD 深度睡眠\n\n处于D状态的进程不能被操作系统kill掉。要想杀掉一个D状态的进程，只有下面三种办法\n\n等硬盘读写完毕，给进程返回结果之后，进程从D状态变成其他状态，操作系统进行处理\n关机重启\n拔掉电脑的电源\n\n\n\nlinux下可以用DD命令直接对硬盘进操作\n\n\n3.僵尸进程Z僵尸进程对应的状态码是Z，而X是1.2提到的终止态\n3.1 为什么会存在僵尸进程?当Linux中的一个进程退出的时候，一般不会进入X状态（终止态，可以回收资源），而是进入Z状态\n\n进程运行了一定的程序，可以理解为这个进程的任务\n当该进程退出的时候，需要知道这个进程是如何结束的（可以理解为终止的原因）\n一般是将执行结果交还给操作系统或者父进程\n\n维护一个状态Z，就是为了维护进程的退出信息，可以让父进程/操作系统读取\n\n父进程/操作系统是通过进程等待来读取进程的退出信息的\n\n在task_struct里面就有一个专门的成员来维护退出信息\n\n3.2 如何复现僵尸状态？我们创建子进程的时候，只要父进程不搭理子进程，一直运行父进程，提前终止子进程，就可以观察到子进程进入僵尸状态\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    int ret = fork();    if(ret == 0)    &#123;        int i = 6;        while(i)        &#123;            printf(&quot;我是子进程，我的ppid是%d,pid是%d\\n我还有%i秒终止&quot;,getppid(),getpid(),i--);            sleep(1);        &#125;        printf(&quot;子进程进入僵尸状态\\n&quot;);        exit(0);    &#125;    else&#123;        printf(&quot;我是父进程，我的ppid是%d,pid是%d\\n&quot;,getppid(),getpid());        while(1)        &#123;            int a = 10;           &#125;    &#125;           return 0;&#125;\n\n\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test1 | grep -v grep32080 30962 30962 32080 pts/0    30962 R+    1001   0:05 ./test130962 30963 30962 32080 pts/0    30962 S+    1001   0:00 ./test1[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test1 | grep -v grep32080 30962 30962 32080 pts/0    30962 R+    1001   0:06 ./test130962 30963 30962 32080 pts/0    30962 Z+    1001   0:00 [test1] &lt;defunct&gt;\n\n英语小课堂：defunct\n\n一般我们都会要求父进程回收子进程，不过这个得后续才能学到了！\nps循环监控脚本我们可以使用一个监控脚本来更方便的监控结果\nwhile :; do ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\n上面这个语句的作用是，每一秒执行一次ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep命令，直到我们使用ctrl+c终止进程\n需要注意分隔符，while后面的是:;不要写成双冒号！\n3.3 长时间僵尸状态的弊端如果一个僵尸进程长时间不被处理，就容易出现内存泄漏！\n子进程的状态是用数据维护的，如果父进程一直不回收子进程，该子进程的task_struct就一直留存在内存中，这就是一定的内存泄漏。\n3.4 孤儿进程当一个进程的父进程先退出的时候，子进程就会变成孤儿进程\n\n为什么这里我们没有看到父进程进入Z或者X状态呢？那是因为这里父进程的父进程是bash，命令行回收了我们的父进程。\n可子进程为何还在这里呢？\n\n父进程退出之后，子进程并不会不见，而是会被1号进程（操作系统）领养。\n这时候我们可以把子进程称为孤儿进程\n\n注：1号进程又称init进程\n\n\n而操作系统领养之后的子进程，即便你使用ctrl+c也干不掉这个进程\n\n仔细观察，可以看到子进程被操作系统领养后，运行状态上的+不见了\n PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND32080  2842  2842 32080 pts/0     2842 S+    1001   0:00 ./test2 2842  2843  2842 32080 pts/0     2842 S+    1001   0:00 ./test2################################################################ PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND    1  2843  2842 32080 pts/0    32080 S     1001   0:00 ./test2\n\n前台和后台进程状态码上带有+号，代表进程是一个前台进程\n\n能被CTRL+C终止的都是前台进程\n后台进程一直在运行，会影响我们的命令行输入\n\n我们可以使用kill -9干掉该进程，干掉进程之后，就可以使用CTRL+C恢复正常的命令行了\n\n3.5 守护进程和精灵进程守护进程&amp;精灵进程：这两种是同一种进程的不同翻译，是特殊的孤儿进程，不但运行在后台，最主要的是脱离了与终端和登录会话的所有联系，也就是默默的运行在后台不想受到任何影响\n\n4.进程暂停T暂停一共有两种状态，一种是stopped，第二种是tarcing stop\n\n一般linux系统是用大T指代stopped，用小t指代tarcing stop\n4.1 T-stoppedkill发信号在之前的操作中，我们已经学过使用kill -9 pid来干掉一个进程，实际上kill命令能干的事情远不止这一个\nkill -l\n\n使用这个命令可以查看到kill命令支持什么操作\n\n其中我们要用到的是第19和第18，分别用于暂停/恢复一个进程\n#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;start!\\n&quot;);    while(1)&#123;        ;    &#125;    return 0;&#125;\n\n写一个啥事不干的死循环用于测试，可以看到该进程处于R+状态\n\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ kill -19 9503\n\n执行kill -19命令之后，我们可以看到该进程被终止，状态码变为大T\n\n进程暂停并不代表进程结束，这就好比我们看视频的时候暂停一样。你暂停了播放，但是播放器这个进程并不会直接终止！\n要想让这个进程重新运行，执行kill -18即可，进程恢复为R状态。此时也没有了+，代表这是一个后台进程\n\n PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND32080  9503  9503 32080 pts/0    32080 T     1001   0:55 ./test3######################## PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND32080  9503  9503 32080 pts/0    32080 R     1001   0:55 ./test3\n\n使用kill -9干掉该后台进程即可\n4.2 t-tarcing stoptarcing一词意为追踪，最简单的情况便是我们使用的gdb调试打断点\n\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test30493 12333 12333 30493 pts/1    12333 S+    1001   0:00 gdb test_g12333 12412 12412 30493 pts/1    12333 t     1001   0:00 /home/muxue/GIT/raspi/code/22-09-24_?程/test_g\n\n这时候test_g进程就是一个处于小t状态的进程\n\n5. 进程优先级\n权限：能还是不能的问题，决定进程能不能访问某种特定的资源\n优先级：进程可以访问该资源，但有先后顺序（运行队列）\n\n进程在排队获取资源的本质就是在确认优先级。这是因为系统的某些慢资源不够多个进程同时使用，这时候就需要让进程进入排队来先后访问。\n而优先级越高的进程，操作系统执行它的响应就会更快。其会把它插入到优先级低于它的进程之前，先运行这个“vip进程”，再运行那些“普通进程”\n5.1 linux进程优先级可以用下面的ps -la命令查看当前bash下的进程\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps -lF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 27595 30493  0  80   0 - 38587 -      pts/1    00:00:00 ps0 S  1001 30493 30492  0  80   0 - 29576 do_wai pts/1    00:00:00 bash[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD1 S  1001 27546     1  0  80   0 -  1833 hrtime pts/0    00:00:00 test20 R  1001 27598 30493  0  80   0 - 38595 -      pts/1    00:00:00 ps\n\n其中的PRI和NI就是我们进程优先级的数据\n\nlinux的进程优先级&#x3D;priority_old+nice\nlinux下进程的默认优先级是80，PRI值越低，优先级越高\nNI值是进程优先级的修正数据，我们修改进程优先级，修改的是NI值而不是PRI\n\n这两个值允许的范围如下，Linux系统并不支持用户无节制的修改优先级\n-20 &lt;= NI &lt;= 1960 &lt;= PRI &lt;= 99\n\n5.2 使用top命令进行修改优先级linux下修改优先级的操作如下，运行test1程序后，先查看它的优先级信息\n[muxue@bt-7274:~]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 29632 30493 98  80   0 -  1833 -      pts/1    00:00:42 test11 Z  1001 29633 29632  0  80   0 -     0 do_exi pts/1    00:00:00 test1 &lt;defunct&gt;0 R  1001 30732 29713  0  80   0 - 38595 -      pts/0    00:00:00 ps\n\n在使用sudo top后，进入界面按r，输入需要设置的进程pid后，再输入需要调整的nice值\n\n\n[muxue@bt-7274:~]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 29632 30493 99  70 -10 -  1833 -      pts/1    00:02:41 test11 Z  1001 29633 29632  0  80   0 -     0 do_exi pts/1    00:00:00 test1 &lt;defunct&gt;\n\n这里可以看到，test1进程的优先级已经被我们改成了70\n再来尝试第二次，这次nice设置为20看看\n\n[muxue@bt-7274:~]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 30697 30493 98  99  19 -  1833 -      pts/1    00:00:16 test11 Z  1001 30698 30697  0  80   0 -     0 do_exi pts/1    00:00:00 test1 &lt;defunct&gt;\n\n诶，pid设置成20之后，为啥NI值变成了19，而PRI变成了99呢？\n\n依据我们以往的惯性思维，既然进程优先级&#x3D;priority_old+nice，那么修改了之后不应该是原本的70+20&#x3D;90吗？为什么是99呢？\n\n这是因为每一次设置的时候，priority_old都会被重置成80。所以可以直接记住，Linux下进程的优先级&#x3D;80+Ni值\nThe End感谢你看到最后，如果本篇博客有啥问题，欢迎在评论区提出！\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】环境变量","url":"/posts/977518181/","content":"本篇博客记录了Linux下一些概念的解释，以及环境变量的相关操作\n\n\n\n所用系统：CentOS 7.6\n\n1.概念解释1.1 进程竞争性系统进程的数目较多。而CPU资源等其他资源不够用，所以进程之间存在竞争性，也就出现了优先级，这在上篇博客中有过介绍\n1.2 进程独立性进程运行具有独立性，不会因为某个进程出错，而影响其他进程的运行\n我们知道，一个进程是内核结构task_truck+代码和数据组成的。而linux系统是通过进程地址空间方式来保证进程的独立性，那是下篇博客会讲到的内容\n1.3 并行并行：多个进程在多个CPU下分割，同时运行\n\n我们一般的电脑都是只有1个cpu，那是怎么做到多个进程运行的？\n注意：多个进程都在系统中运行≠多个进程在系统中同时运行。要想知道这是怎么做到的，需要了解并发的概念\n1.4 并发大部分操作系统都是分时的，操作系统会给每一个进程赋予一个时间片，这样在一个调度周期中，可以调用到每一个需要运行的进程。\n这样，在一个时间段内，多个进程会通过交叉运行的方式，让每一个进程的代码，在这段时间内都能得到运行\n\n比如每一个进程运行10ms，假设有10个进程需要运行，那么在1s内，这10个进程都会被运行10次。1s=1000ms\n\ncpu进行多个进程的快速交替运行，以实现我们看到的单cpu运行多个进程的情况\n这种情况就叫做并发\n\n1.5  进程优先级管理操作系统正在运行一个低优先级进程的时候，突然来了一个高优先级数据怎么办？\n\n操作系统支持不同优先级进程的存在\n同一个优先级的进程可以存在多个\n操作系统是用队列来管理进程的，队列只支持支持尾删尾插\n\n这种情况要怎么处理呢？如果给队列头插，那不就破坏了队列的属性了？\n实际上，操作系统并不是用单一队列来进行管理的，而是用了一个哈希桶来进行处理\n\n可以理解为哈希桶是一个数组，后面链接了不同优先级的进程\n当一个更高优先级的进程需要运行的时候，操作系统只需要改变cpu当前运行队列在哈希桶里面的指向，即可马上完成高低优先级进程之间的切换\n操作系统还会管理一个位图，用于标识某一个优先级内是否存在进程\n\n哈希和位图这两个数据结构都会在C++的博客中讲解\n\n除了位图和哈希表之外，操作系统还会管理一个结构体，用于标识目前正在使用的进程哈希桶active，以及新进程的管理桶old\nstruct runqueue&#123;\thash_queue* active;\thash_queue* old;&#125;;\n\n当出现新进程的时候，操作系统不会把它直接链接到active里面，而是放入old中；\nactive内部的进程运行完了之后，只需要swap一下active/old指针，即可完成新进程表和运行完的旧表之间的交换！\n\n这种调度算法也被称为大O(1)调度法\n\n1.6 进程间切换CPU存在寄存器，这些寄存器储存了进程的临时数据\n\n寄存器分为可见寄存器（eax&#x2F;ebx）和不可见寄存器\n\n当进程在运行过程中，会产生各种临时数据\nint test()&#123;\tint a = 10;\treturn a;&#125;int main()&#123;    int b = test();    return 0;&#125;\n\n我们知道，定义在函数test中的a是一个局部变量，出了作用域就会销毁，那么main函数里面的b是怎么拿到test的返回值的？\n这里就用到了寄存器：a的值会先放入寄存器中，销毁了之后，再把寄存器里面的值赋值给b\n和内存一样，CPU只有一套寄存器。这一套寄存器在运行不同进程的时候，可以保存不同的临时数据\n\n这时候如果来了一个高优先级进程A，直接覆盖了正在运行的进程B及其寄存器中的数据，就可能导致进程B存在寄存器中的数据丢失，导致B无法继续运行\n\n所以，在进程的task_struct结构体中，就有一个专门的成员用于保存进程的上下文数据\n\n上下文数据：进程在运行中产生的各种临时数据\n当进程被剥离的时候，需要保存上下文数据\n当进程恢复运行的时候，需要重新加载上下文数据\n\n\n关于进程pcb和task_struct的内容可以看我之前的博客 进程概念\n\n2.环境变量2.1 引入环境变量当我们运行自己编译的一个可执行文件的时候，需要带上./指定路径\n\n使用file命令查看系统的相关指令，你会发现它们和我们自己写的mytest本质上是一样的，都是一个executable的可执行文件\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ file /bin/ls/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=c8ada1f7095f6b2bb7ddc848e088c2d615c3743e, stripped[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ file /bin/gcc/bin/gcc: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=84ea48c51fa70f8cd586b7801bc655487156db7b, stripped[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ file mytestmytest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=db352023d208d9f48899641c3536a8c13b7bc7bf, not stripped\n\n那为何运行诸如ls pwd gcc等等系统命令的时候，不需要在前面带上./路径来运行呢？\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ mytest-bash: mytest: command not found[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ lsmakefile  mytest  mytest.c\n\n这是因为：指向一个可执行程序，前提是需要找到它！\nlinux系统只能找到它自己预设好的命令，找不到我们的mytest\n在linux命令行中，输入env即可查看当前系统的环境变量\n\n其中PATH就是可执行程序存放的路径！系统就是通过环境变量来查找可执行程序的\n2.2 添加删除环境变量别急，我们先来学习一下怎么添加环境变量。实际上，我们的bash命令行里面是可以定义变量的，变量分为两种类型\n\n本地变量（局部）\n环境变量（全局）\n\n直接使用变量名=值的方式，就可以定义一个本地变量。使用echo命令可以查看这个本地变量。这时候我们用env | grep 变量名在环境变量里面查找，会发现当前的环境变量里面没有这个东西\n[muxue@bt-7274:~]$ aaaa=1234[muxue@bt-7274:~]$ echo $aaaa1234[muxue@bt-7274:~]$ env | grep aaaa[muxue@bt-7274:~]$\n\n这时候需要用export命令，创建一个环境变量\n[muxue@bt-7274:~]$ export bbbb=4321[muxue@bt-7274:~]$ env | grep bbbbbbbb=4321\n\n或者可以导入当前的本地变量\n[muxue@bt-7274:~]$ export aaaa[muxue@bt-7274:~]$ env | grep aaaaaaaa=1234\n\n删除的时候则使用unset命令取消环境变量\n[muxue@bt-7274:~]$ unset bbbb[muxue@bt-7274:~]$ env | grep bbbb[muxue@bt-7274:~]$ \n\n查看环境变量\necho: 显示某个环境变量值\nexport: 设置一个新的环境变量\nenv: 显示所有环境变量\nunset: 清除环境变量\nset: 显示本地定义的shell变量和环境变量\n\necho $环境变量名 #查看环境变量set | less #查看所有的shell变量和环境变量\n\n认识一些环境变量\nUSER：当前登录的用户\nHOME：当前用户的工作路径\nLANG：当前的语言和编码设定\nPATH：可执行命令的路径\nSHELL：当前使用的命令行是啥\nLOGNAME：当前登录的用户名\nPWD：当前所处路径\nOLDPWD：上一个路径，使用cd -跳回上一个路径\nHISTSIZE：系统会记录的历史命令条数\n\n我们可以用history命令查看之前运行过的命令，这里面保存的正好是3000条，和环境变量HISTSIZE的设置一致！\n[muxue@bt-7274:~]$ env | grep $HISTSIZEHISTSIZE=3000[muxue@bt-7274:~]$ history | wc --l3000\n\n需要注意的是，系统预载的环境变量都是在配置文件里面的。当前我们对环境变量做的任何操作都只会临时保存。关闭当前的命令行重新开一个，之前设置的环境变量就会消失\n[muxue@bt-7274:~]$ cat /etc/bashrc\n\n系统的环境变量配置文件为/etc/bashrc，用户的则为工作目录下的.bashrc以及.bash_profile\n查看上个进程退出状态码在linux下有一个特殊的环境变量?，这个环境变量存放的是上一个进程的退出码。比如我们进程中return 0退出，那么查询到的就是0\necho $?\n\n\n\n2.3 环境变量PATH使用echo $PATH查看当前系统可执行文件的路径\n这里的路径都以:作为分割，linux查找命令的时候，就会在下面的这些路径里面查找\n[muxue@bt-7274:~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin\n\n除了直接使用ls，我们也可以使用路径的方式来调用ls\n[muxue@bt-7274:~]$ /usr/bin/ls bin  git  install.sh  kook  mon\n\n而如果想让系统能找到自己的可执行程序，就可以直接把可执行程序复制到这些路径中！\n给PATH中添加可执行文件[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ cp mytest ~/bin[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ mytesthello world!hello world!\n\n比如现在，我把mytest这个可执行程序复制到了~/bin也就是/home/muxue/bin的路径下，此时直接使用mytest就能找到对应的命令了！\n除了这种办法以外，我们还可以把当前的路径写入PATH环境变量中\n[muxue@bt-7274:~]$ export PATH=$PATH:/home/muxue/git/raspi/code/test#这样写是在原本的path后面追加内容。不能直接path=自己的路径，会直接覆盖[muxue@bt-7274:~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin:/home/muxue/git/raspi/code/test\n\n这时候直接执行mytest也成功了！\n[muxue@bt-7274:~]$ mytesthello world!hello world!hello world!\n\n前面提到了我们设置的这个环境变量都是临时的，所以重启了之后，自己设置的这个路径也会消失\n[muxue@bt-7274:~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin\n\n注意：一般情况下不建议在linux系统路径中安装自己的可执行程序，因为这样会污染系统的命令环境！\n3.C&#x2F;C++获取环境变量3.1 main函数的参数之前一直没有了解过这个知识点，C&#x2F;C++的main函数是可以带参数的！\n#include&lt;stdio.h&gt;//第一个参数指代命令个数，执行该可执行文件时传入的几个命令//第二个参数是一个指针数组，存放了每一个命令的常量字符串int main(int arg,char* argv[])&#123;    printf(&quot;arg: %d\\n&quot;,arg);    for(int i =0;i&lt;arg;i++)    &#123;        printf(&quot;argv[%d]: %s\\n&quot;,i,argv[i]);    &#125;    return 0;&#125;\n\n\n有了这两个参数，我们就可以利用它写一个命令行版本的计算器\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//main函数可以带参数//第一个参数指代命令个数，执行该可执行文件时传入的几个命令//第二个参数是一个指针数组，存放了每一个命令的常量字符串int main(int arg,char* argv[],char *envs[])&#123;    if(arg != 4)    &#123;        printf(&quot;Usage: %s [-a|-s|-m|-d] first second\\n&quot;, argv[0]);        return 0;    &#125;    int x = atoi(argv[2]);    int y = atoi(argv[3]);    if(strcmp(&quot;-a&quot;, argv[1]) ==0)    &#123;        printf(&quot;%d+%d=%d\\n&quot;,x, y, x + y);    &#125;    else if(strcmp(&quot;-s&quot;, argv[1]) ==0)    &#123;        printf(&quot;%d-%d=%d\\n&quot;,x, y, x - y);    &#125;    else if(strcmp(&quot;-m&quot;, argv[1]) ==0)    &#123;        printf(&quot;%d*%d=%d\\n&quot;,x, y, x * y);    &#125;    else if(strcmp(&quot;-d&quot;, argv[1]) ==0 &amp;&amp; y != 0)    &#123;        printf(&quot;%d/%d=%d\\n&quot;,x, y, x / y);    &#125;    else    &#123;        printf(&quot;Usage: %s [-a|-s|-m|-d] first second\\n&quot;, argv[0]);    &#125;    return 0;&#125;\n\n实现非常简单，其使用方法如下👇\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ gcc test.c -o test -std=c99[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -a 10 2010+20=30[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -s 10 2010-20=-10[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -m 10 3010*30=300[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -d 30 1030/10=3[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test 1 1 1 1 Usage: ./test [-a|-s|-m|-d] first second\n\n上面这个小程序演示了main函数的参数的作用。\n看到这里，想必你应该不难理解linux系统的命令是如何使用参数的，诸如ls -l等等选项，其实都是通过main函数的参数实现的！\n通过main函数的参数，可以让同一个可执行文件依据命令输出不同的结果！\n3.2 使用第三个参数获取环境变量除了上面提到的main函数前两个参数，实际上main函数还可以带第三个参数！\n//第一个参数指代命令个数，执行该可执行文件时传入的几个命令//第二个参数是一个指针数组，存放了每一个命令的常量字符串//第三个参数用于导入环境变量！int main(int arg,char* argv[],char *envs[])&#123;    for(int i =0;envs[i];i++)    &#123;        printf(&quot;envs[%d]: %s\\n&quot;,i,envs[i]);    &#125;\treturn 0;&#125;\n\n因为envs是一个指针数组，所以可以通过判空来终止for循环\n\n在这个数组的最后，可以看到我们刚刚执行的命令也被写入了环境变量\n\n除了上面这个办法，我们还可以用下面两种方式来获取环境变量\nenviron外部导入环境变量C语言提供了一个environ来导入环境变量，其作用和main函数第三个参数是一样的\n\nextern char ** environ;printf(&quot;get env from [environ]\\n&quot;);for(int i = 0; environ[i]; i++)&#123;    printf(&quot;%d: %s\\n&quot;, i, environ[i]);&#125;\n\n\n其输出的结果也是一样的\ngetenv函数man getenv\n\n\n这个函数就能实现一些骚操作，比如写一个只有我自己可以运行的可执行文件\nint main(int arg,char* argv[],char *envs[])&#123;    char* user = getenv(&quot;USER&quot;);    if(strcasecmp(user,&quot;muxue&quot;)!=0)//strcasecmp忽略大小写    &#123;        printf(&quot;权限禁止！\\n&quot;);        return -1;    &#125;    printf(&quot;成功执行！\\n&quot;);    return 0;&#125;\n\n通过getenv函数获取到环境变量中的USER，判断其与我自己设定的user是否相同。如果不同就拒绝执行，相同才成功执行\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test成功执行！[root@bt-7274:/home/muxue/git/raspi/code/22-10-04_环境变量]# ./test权限禁止！\n\n可以看到，哪怕是root用户也搞不来这个可执行程序！\n\n4.关于本地变量的说明在2.2中提到了本地变量和环境变量的区别\n\n本地变量（局部）\n环境变量（全局）\n\n所谓的本地变量，其实是bash内部定义的变量。\n我们首先需要了解的是，linux下大部分的进程或命令都是以子进程方式运行的，其父进程都是当前打开的bash\n由此可知，bash内部的本地变量，并不会被这些子进程所继承\n而环境变量具有全局属性，可以被子进程继承并获取！\n\n那么问题来了，export/echo也是命令。如果它们也是子进程，那它们是怎么获取到bash内部的本地变量，并将其导入到环境变量中的呢？\nnope！实际上，这两个命令都是由bash自己执行的（调用自己的对应的函数完成功能）我们把这种命令称作内建命令\n结语关于环境变量的基本认识到这里就OVER啦。本博客是我的课堂笔记，难免会有问题，还请各位大佬指出~\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】进程地址空间","url":"/posts/1845419185/","content":"本篇博客来认识一下linux下程序地址空间的概念\n\n\n\n演示所用系统：CentOS 7.6\n\n[TOC]\n1.引入程序地址空间之前学习C/C++的时候，多少应该都听过栈区&#x2F;堆区&#x2F;静态区&#x2F;全局区的概念，还有一张很经典的演示图，大部分讲解这几个内存区域的图片都和下图类似\n\n但是有一个问题，这里的程序地址空间，是我们的物理内存上的东西吗？\n并不是！\n\n程序&#x2F;进程地址空间是操作系统上的概念，它和我们物理内存本身不是一个东西\n\n\n1.1 验证不同区域用下面这个代码来简单验证一下不同区域上的区别\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int un_global_val;//未初始化全局变量int global_val=100;//已初始化全局变量//main函数的参数int main(int argc, char *argv[], char *env[])&#123;    printf(&quot;code addr         : %p\\n&quot;, main);    printf(&quot;init global addr  : %p\\n&quot;, &amp;global_val);    printf(&quot;uninit global addr: %p\\n&quot;, &amp;un_global_val);    char *m1 = (char*)malloc(100);    char *m2 = (char*)malloc(100);    char *m3 = (char*)malloc(100);    char *m4 = (char*)malloc(100);    int a = 100;    static int s = 100;    printf(&quot;heap addr         : %p\\n&quot;, m1);    printf(&quot;heap addr         : %p\\n&quot;, m2);    printf(&quot;heap addr         : %p\\n&quot;, m3);    printf(&quot;heap addr         : %p\\n&quot;, m4);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m1);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m2);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m3);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m4);    printf(&quot;stack addr a      : %p\\n&quot;, &amp;a);    printf(&quot;stack addr s      : %p\\n&quot;, &amp;s);    printf(&quot;\\n&quot;);    for(int i = 0; i &lt; argc; i++)    &#123;        printf(&quot;argv addr         : %p\\n&quot;, argv[i]);    &#125;    printf(&quot;\\n&quot;);    for(int i =0 ; env[i];i++)    &#123;        printf(&quot;env addr          : %p\\n&quot;, env[i]);    &#125;    return 0;&#125;\n\n\n通过上面的测试，可以看到其结果和文章最开始的那张图相同。这里解释一下向上/向下的含义\n\n向上增长：向地址增大的方向增长\n向下增长：向地址减小的方向增长\n\n不过那个图片内部还少了一些东西，比如命令行参数和环境变量其实是存放在栈区之上的。补全之后的图片如下\n\n其中我们还可以发现，栈区和堆区之间有非常大的内存空隙\nheap addr         : 0x1a140f0heap addr         : 0x1a14160stack addr        : 0x7ffe6671ec60stack addr        : 0x7ffe6671ec58\n\n因为在C&#x2F;C++中定义的变量都是在栈上保存的，栈向下增长，先定义的变量地址较高！\nint a = 100;static int s = 100;\n\n关于函数中static修饰的变量，可以看到其地址空间属于全局静态区。虽然在函数中用static修饰是限制其只能在该函数内访问，但是该变量的声明周期是跟随整个程序的！\nstack addr a      : 0x7ffe6671ec44stack addr s      : 0x601048\n\n说了这么多，我们也没看看出来程序地址空间在哪儿啊？\n1.2 fork感知地址空间的存在下面可以用一个简单的fork代码来确认程序地址空间的存在！\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    int test = 10;    int ret = fork();    if(ret == 0)    &#123;        while(1)        &#123;            printf(&quot;我是子进程%d,ppid:%d,test:%d,&amp;test: %p\\n\\n&quot;,getpid(),getppid(),test,&amp;test);            sleep(1);        &#125;    &#125;    else    &#123;            while(1)        &#123;            printf(&quot;我是父进程%d,ppid:%d,test:%d,&amp;test: %p\\n\\n&quot;,getpid(),getppid(),test,&amp;test);            sleep(1);        &#125;    &#125;           return 0;&#125;\n\n依旧是最简单的一个fork代码，正常情况下，二者打印的结果应该是一样的！\n\n可如果我们在子进程中修改一下test呢？\n\n这时候就会发现一个离谱的现象：子进程和父进程打印的test值不一样，但是其地址却完全相同！\n如果我们在C/C++中使用的地址就是物理地址，是不可能出现这种情况的！怎么可能在物理内存的同一个地址访问出两个不同的结果呢？\n\n就好比张三和李四在同一天的同一时间去了AA路30号这个地址，不可能会出现张三去了发现是超市，而李四去了发现是医院的情况\n\n这便告诉我们了程序地址空间的存在，亦或者说，我们在编程中使用的地址都是虚拟地址\n2.简述程序地址空间每一个进程在启动的时候，都会让操作系统给其分配一个地址空间，这就是进程地址空间\n\n以先描述再组织的理念，进程地址空间其实是操作系统内核的一个数据结构struct mm_struct\n之前提到过进程具有独立性，在多进程运行的时候，需要独享各种资源。而进程地址空间的作用，就是让进程认为自己是独占操作系统中的所有资源！\n\n这个操作，其实就是操作系统给该进进程画了一个假的内存（虚拟地址）进程需要内存的时候，操作系统就会在页表里面画一个地址给他，再将该地址映射到物理内存上面\n\n问题：一个分页存储管理系统中，地址长度为 32 位，其中页号占 8 位，则页表长度是？\n解析：页号即页表项的序号，总共占8个二进制位，意味着页表项的个数就是2^8\n\n\n而当进程需要申请内存的时候，本质就是操作系统在mm_strcut中修改不同区域的end罢了！\n在Linux源码中可以看到这玩意的存在，其中的struct vm_area_struct * mmap;就是一个我们的虚拟地址管理的内核\n\n这里就能看到虚拟地址空间的start和end了！\n\n2.1 程序地址空间和代码编译\n程序地址空间不仅是操作系统需要考虑，我们用的编译器也会考虑这部分的内容\n\n我们知道，C语言代码需要经过预处理-编译-链接-汇编这几个步骤\n\n程序编译出来，没有被加载的时候，程序内部有地址（如果没有地址，无法进行链接）\n程序编译出来，没有被加载的时候，程序内部有区域（readelf -s 可执行文件可以查看区域）\n\n[muxue@bt-7274:~/git/raspi/code/22-10-07_程序地址空间]$ readelf -S testThere are 30 section headers, starting at offset 0x19f8:Section Headers:  [Nr] Name              Type             Address           Offset       Size              EntSize          Flags  Link  Info  Align  [ 0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0  [ 1] .interp           PROGBITS         0000000000400238  00000238       000000000000001c  0000000000000000   A       0     0     1  [ 2] .note.ABI-tag     NOTE             0000000000400254  00000254       0000000000000020  0000000000000000   A       0     0     4  [ 3] .note.gnu.build-i NOTE             0000000000400274  00000274       0000000000000024  0000000000000000   A       0     0     4  [ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298       000000000000001c  0000000000000000   A       5     0     8  [ 5] .dynsym           DYNSYM           00000000004002b8  000002b8       00000000000000c0  0000000000000018   A       6     1     8  [ 6] .dynstr           STRTAB           0000000000400378  00000378       0000000000000059  0000000000000000   A       0     0     1  [ 7] .gnu.version      VERSYM           00000000004003d2  000003d2       0000000000000010  0000000000000002   A       5     0     2  [ 8] .gnu.version_r    VERNEED          00000000004003e8  000003e8       0000000000000020  0000000000000000   A       6     1     8  [ 9] .rela.dyn         RELA             0000000000400408  00000408       0000000000000018  0000000000000018   A       5     0     8  [10] .rela.plt         RELA             0000000000400420  00000420       00000000000000a8  0000000000000018  AI       5    23     8  [11] .init             PROGBITS         00000000004004c8  000004c8       000000000000001a  0000000000000000  AX       0     0     4  [12] .plt              PROGBITS         00000000004004f0  000004f0       0000000000000080  0000000000000010  AX       0     0     16  [13] .text             PROGBITS         0000000000400570  00000570       00000000000001e2  0000000000000000  AX       0     0     16  [14] .fini             PROGBITS         0000000000400754  00000754       0000000000000009  0000000000000000  AX       0     0     4  [15] .rodata           PROGBITS         0000000000400760  00000760       000000000000005e  0000000000000000   A       0     0     8  [16] .eh_frame_hdr     PROGBITS         00000000004007c0  000007c0       0000000000000034  0000000000000000   A       0     0     4  [17] .eh_frame         PROGBITS         00000000004007f8  000007f8       00000000000000f4  0000000000000000   A       0     0     8  [18] .init_array       INIT_ARRAY       0000000000600e10  00000e10       0000000000000008  0000000000000008  WA       0     0     8  [19] .fini_array       FINI_ARRAY       0000000000600e18  00000e18       0000000000000008  0000000000000008  WA       0     0     8  [20] .jcr              PROGBITS         0000000000600e20  00000e20       0000000000000008  0000000000000000  WA       0     0     8  [21] .dynamic          DYNAMIC          0000000000600e28  00000e28       00000000000001d0  0000000000000010  WA       6     0     8  [22] .got              PROGBITS         0000000000600ff8  00000ff8       0000000000000008  0000000000000008  WA       0     0     8  [23] .got.plt          PROGBITS         0000000000601000  00001000       0000000000000050  0000000000000008  WA       0     0     8  [24] .data             PROGBITS         0000000000601050  00001050       0000000000000004  0000000000000000  WA       0     0     1  [25] .bss              NOBITS           0000000000601054  00001054       0000000000000004  0000000000000000  WA       0     0     1  [26] .comment          PROGBITS         0000000000000000  00001054       000000000000002d  0000000000000001  MS       0     0     1  [27] .symtab           SYMTAB           0000000000000000  00001088       0000000000000648  0000000000000018          28    46     8  [28] .strtab           STRTAB           0000000000000000  000016d0       000000000000021e  0000000000000000           0     0     1  [29] .shstrtab         STRTAB           0000000000000000  000018ee       0000000000000108  0000000000000000           0     0     1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),  L (link order), O (extra OS processing required), G (group), T (TLS),  C (compressed), x (unknown), o (OS specific), E (exclude),  l (large), p (processor specific)\n\n需要注意的是，程序内部的地址，和内存的地址没有关系\n可以理解为，我们程序内部都存放的是一个相对地址。编译程序的时候，认为程序是按照0000~FFFF进行编址的。\n当程序被加载到内存当中时，假设系统将该程序的代码从内存0x100开始加载，就可以依照程序编址的数据加上这个偏移量，从而存放在内存中。\n比如程序中有一个代码段的位置是0x1F，这时候在加载程序的时候，就会把这个代码段加上偏移量来加载\n\n\n\n代码地址\n虚拟地址\n\n\n\n0x1f\n0x11f\n\n\n0x20\n0x120\n\n\n大概就是这样，吧哩吧啦……\n2.2 写时拷贝现在就可以来解答一下1.2中出现的问题了\n\n当子进程尝试修改test变量的时候，操作系统就会开始一个写时拷贝，开辟一个新的空间，将对应的值考入该空间，再重新映射页表。\n这时候，虽然页表左侧的虚拟地址没有变化，但是映射的物理地址已经不一样了！\n\n这样就能保证父子进程的独立性，谁修改变量都互不影响！\n\n类似C++中实现的深拷贝！\n\n2.2.1 fork两个返回值的解释pid_t id这个变量属于父进程栈空间中定义的变量，但是fork内部，return会被执行两次（return的本质是通过寄存器将返回值写入到接收返回值的变量中）\n当id = fork()的时候，谁先返回，谁就会发生一次写时拷贝。所以同一个变量有不同的内容值，本质上也是同一个虚拟地址，对应了不同物理地址的体现！\n\n打印fork的返回值，即可观察到和1.2中一样的情况，虚拟地址相同，但是ret的值不同\n\n\n3.程序地址空间的作用需要注意的是，内存作为一个硬件，没有办法拒绝你的读写！内存是不带控制功能的！\n直接让用户修改物理内存风险极大：\n\n野指针问题\n用户可能直接修改操作系统需要用到的内存地址，导致系统boom\n\n程序地址空间让访问内存时添加了一层软硬件层，可以对转化过程进行审核，拦截非法的访问\n\n比如操作系统检测到进程在往虚拟地址的常量区读取数据的时候，不做阻拦；但是往常量区写入数据的时候，会进行拦截。这才是无法修改常量数据的真正原理\n\n\n保护内存\n可以使用进程管理更好的对功能模块进行解耦（linux内存管理）\n让程序&#x2F;进程可以用统一的方式&#x2F;视角来看待内存，以统一的方式编译加载所有可执行程序，简化程序本身的设计和实现\n\n同时，程序地址空间还可以延迟用户的内存使用。比如我们现在malloc了100个字节的空间，实际上操作系统并不会立马给你申请空间，而是操作你的mm_struct让进程以为自己已经申请成功了。当程序真正使用这个空间的时候，操作系统才会去物理内存中进行映射！\n\n申请的时候，是通过linux的内存管理模块进行操作的。同时，写时拷贝也是通过操作系统的内存管理模块来完成的！\n\n这种“延迟访问”，可以避免某些程序申请了内存而在一段时间内没有使用的问题！避免了内存资源的无效占用（也是一种浪费）\n4.页表前面只是对页表做了一个基本的解释，但页表并不单纯进行虚拟地址和物理地址的映射，其还会增添权限，是否命中的判断，以及U/K权限的标识\n\n\n权限：避免你修改const属性的数据\n是否命中：如果对于物理内存处没有数据，则没有命中；需要从硬盘中加载数据到内存中，将是否命中更改为是\nU&#x2F;K权限：用户级和内核级的差别，参考 linux信号 5.1中关于用户态和内核态的描述；避免用户态的进程执行内核态的源码\n\n前面提到，每一个进程都有一个独立的程序地址空间。要是页表只有一张的话，会发生什么事呢？\n以32位系统为例：\n\n内存一共有2^32次方个字节，也就是4Gb\n假设页表每一个字节的条目需要8个字节的空间，那就需要32G的空间来存放页表！\n页表肯定不能存在硬盘里面，但这么大的空间一般电脑的内存可放不下\n这也就告诉我们，页表并不是只有一张！\n\n页表实际上是有多张的👌\n4.1 分页存储当cpu访问进程地址空间的时候，其访问的其实是虚拟地址\n32位环境下，为了保证地址能覆盖到所有位置，每一个地址都有32个比特位；当MMU拿到虚拟地址的时候，其实会将虚拟地址拆分\n10     +    10     +    1201010101 00 01000111 11 00001011 1001xxxxxxxx xx yyyyyyyy yy zzzzzzzz zzzz\n\n\n这里面的前10位会用于在页目录中，用于查找二级页表\n中间10位会在二级页表中查找页，指向的是页在物理内存中的起始地址\n最后的12字节，一共是2^12=4kb，可以覆盖单个页的大小，是单个页中的偏移量\n\n这里又涉及到了一个知识点，那便是Linux下IO的基本单位是4kb\n有了这两级的页表后，第一级页表只需要2^10个条目，第二级页表有多个，每一个也是2^10个条目，最后再指向4kb的页\nlinux下有专门的结构体来描述单个页，和其他系统一样，有了对单个页的描述后，我们就可以用一个数组将页给管理起来。此时对内存的管理，就转换成了对数组的增删查改\nstruct page&#123;&#125;;\n\n页表实现了分离之后，就可以按需创建，不会出现一次性创建一个非常大的页表，导致内存空间都被占满的情况！\n\n最初的算法其实是有问题的，因为页表的映射并不需要对每一个字节进行映射。只需要映射到4kb这一块即可，总共的条目是2^32 / 2^12 = 2^20个，所占用空间也没那么大了\n\n4.2 加载如果在寻址的时候，发现二级页表中所对应的page是NULL，那么代表该代码的数据没有被加载到内存中\n此时就可以从硬盘中加载，并把page的首地址给映射进二级页表中\n\n结语关于这部分的理解其实并不算十分透彻，或许在日后的项目实践中能加深理解呢~\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】简易shell的实现","url":"/posts/2663421239/","content":"本篇博客，来教大家用C写一个简易的linux shell，帮助理解之前学习的进程控制相关知识\n\n\n\n演示系统：CentOS7.6\n\n[TOC]\n前言之所以说是简易的shell，是因为我们现在的水平肯定写不出来linux系统里面那么复杂的shell。\n我们的目的仅仅是为了学习父子进程、进程替换、内建命令等等知识，并把这些知识的作用通过这个小shell体现出来\n\n源码仓库：gitee\n\n\n1.基础框架之前的学习中有提到过，我们在linux命令行内运行的很多进程，都是以子进程的方式运行的。说白了就是bash进程里面给我们fork创建了其他子进程，再用子进程进行进程替换，指向对应的可执行文件\n而需要做到这一点，我们要一步一步来\n\nbash首先要显示命令行的提示符用户名@主机名 路径（参考之前vim博客中的进度条程序）\n获取用户的输入内容\n从用户的输入中，以&quot; &quot;空格为分割，分离出命令和参数\nfork创建子进程，子进程执行进程替换，父进程等待子进程结束\n\n这一切都是在一个while(1)的死循环里面执行的，bash本质上就是一个死循环的父进程\n2.开整一个2.1 打印命令行提示符先来试试打印出命令行的提示符吧！\nprintf(&quot;[慕雪@FS-1041 当前路径]# &quot;);fflush(stdout); //刷新缓冲区，达到不换行的效果\n\n\n\n为何要使用fflush？\n\n如果不这么弄，而使用\\n换行，就会出现命令行提示符一直在闪动打印。这不是我们想要的结果\n光是打印一个基本的路径可不太够哦，我们还可以试着获取环境变量的PWD得到当前的路径，再打印出来\nchar cur_pwd[SIZE] = &quot;~&quot;;int sz_pwd = strlen(getenv(&quot;HOME&quot;));strcat(cur_pwd, getenv(&quot;PWD&quot;) + sz_pwd);printf(&quot;[慕雪@FS-1041 %s]# &quot;, cur_pwd);fflush(stdout); //刷新缓冲区，达到不换行的效果\n\n这里我们必须要去掉PWD前面/home/用户名的内容，将其替换成~\n打印出来的效果如下，是不是和我们linux的命令行很像啦！\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n你还可以从环境变量中获取HOSTNAME和USER来替换掉前面的内容\n这里为了和linux自己的shell区分一下，我就不替换了\n\n2.2 获取用户输入C语言获取用户输入，我们一般用的是scanf\n但是这个函数在现在这个地方可不那么好用喽！我们输入命令的时候需要用空格分开命令行参数。scanf会因为空格而停止接受\n我们可以用gets函数来解决这个问题！\n#define NUM 1024char cmd_line[NUM]; //命令行输入// 2.获取用户的输入内容memset(cmd_line, &#x27;\\0&#x27;, sizeof(cmd_line) * sizeof(char));fgets(cmd_line, NUM, stdin);           //标准输入stdin获取键盘输入内容\n\n获取了之后先打印一下cmd_line，可以看到成功获取了我们输入的结果\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# test i k dtest i k d[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]#\n\n但为什么多打了一个换行呢？\n这是因为fgets在接受输入的时候，把我们输入结束的回车也给收起来辣\ncmd_line[strlen(cmd_line) - 1] = &#x27;\\0&#x27;; // 去掉\\n回车\n\n光是去掉回车还是有点问题，如果我们只敲了一个回车，后续我们分离参数的时候，总不能对一个空的字符串进行处理吧？\n所以还需要单独判断strlen(cmd_line)==1的情况，直接continue\nif(strlen(cmd_line)==1)&#123;    continue;//等于1的情况只能是敲了一个回车&#125;// 其他情况去掉\\n回车cmd_line[strlen(cmd_line) - 1] = &#x27;\\0&#x27;; \n\n这样我们的bash就和linux自己的bash一样，敲回车会直接新起一行，不做任何操作\n\n如果不这么处理，就会引发段错误导致bash直接终止\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# Segmentation fault\n\n2.3 分离参数获取好用户输入啦，下一步就是分离参数了！\n这里面我们直接使用strtok这个函数即可！\nchar * strtok ( char * str, const char * sep );\n\n它的作用是根据分隔符返回这个分隔符在字符串里面的起始位置；如果传入的是一个NULL，则从上一次处理的位置继续往后处理。\n\nstrtok函数找到str中的下一个标记，并将其用\\0结尾，返回一个指向这个标记的指针\n如果字符串中不存在更多的标记，则返回 NULL 指针\n\n\n该函数的详解参考我的博客 点我 \n\n😥最开始的时候我忘记了这个函数，直接自己写了一个分离算法，debug了好久才勉强搞出来，太笨蛋了\n#define SEP &quot; &quot; //分隔符size_t cmd_args_num = 0;  //分离出来的参数个数char *cmd_args[SIZE];     //分离参数cmd_args[0] = strtok(cmd_line, SEP);cmd_args_num = 1;while (cmd_args[cmd_args_num++] = strtok(NULL, SEP));cmd_args_num--;//这里-1是因为while循环最后会多++ 1次\n\n注意！=赋值操作符是有返回值的！它的返回值是我们的左值，也就是每一次获取到的strtok的结果，这个结果被cmd_args[cmd_args_num]所接受\n那么，当strtok返回NULL的时候，while就会接受到=的返回值，从而停止循环\nfor(int j=0;j&lt;cmd_args_num;j++)&#123;    printf(&quot;args[%d] %s\\n&quot;,j,cmd_args[j]);&#125;\n\n通过打印，可以看到它成功分离出来了我们的参数\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# ls -largs[0] lsargs[1] -l\n\n单独处理ls在linux的bash下，我们执行的ls都是带颜色的。这是因为centos的配置文件中，将ls设置成了ls --color=auto的别名，要想我们自己bash里面的ls也带上颜色，则需要单独处理一下ls\n// 3.分离出命令和参数cmd_args[0] = strtok(cmd_line, SEP);cmd_args_num = 1;// 给ls命令添加颜色if (strcmp(cmd_args[0], &quot;ls&quot;) == 0)    cmd_args[cmd_args_num++] = (char *)&quot;--color=auto&quot;;while (cmd_args[cmd_args_num++] = strtok(NULL, SEP));cmd_args_num--;//这里-1是因为while循环最后会多++一次\n\n最终ls -l分离出来的参数如下\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# ls -largs[0] lsargs[1] --color=autoargs[2] -l\n\n2.4 进程替换参数分离出来了，下一步要做的，便是进程替换了\n我们需要使用的是exec函数里面的哪一个呢？\n\n带p的exec函数，它会自动去PATH里面查找可执行文件\n带v的，函数，因为我们的传参已经分离在了一个字符指针数组里面\n\n基本的代码如下，父进程打印内容是为了测试，实际的bash肯定是没有这个打印的~\n// 6.创建程序 替换pid_t ret_id = fork();if (ret_id == 0) //子进程&#123;    execvp(cmd_args[0], cmd_args); //程序替换    exit(134);                     //执行到这里，子进程一定替换失败&#125;// 父进程int status = 0;pid_t ret = waitpid(ret_id, &amp;status, 0);printf(&quot;\\n&quot;);if (ret &gt; 0)&#123;    printf(&quot;bash等待子进程成功！code: %d, sig: %d\\n&quot;, WEXITSTATUS(status), WTERMSIG(status));&#125;\n\n运行成功！\n\n执行python3的文件也是ok的\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# python3 test.pyargs[0] python3args[1] test.pyhello pythonbash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]#\n\n3.内建命令完成了上面的几步后，一个基础的bash就搞定了\n但是这样还不够，不信cd试一下？\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lsmakefile  myshell  myshell.c  myshell_err.c  test  test.cpp  test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# cd testbash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lsmakefile  myshell  myshell.c  myshell_err.c  test  test.cpp  test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n 诶，为什么cd了之后，再次ls，路径没有变化呢？\n这是因为我们的cd是被子进程执行的，切换的是子进程的工作目录。可子进程执行完cd之后就结束运行了，它根本没有影响到父进程bash！\n\n之前学习的时候，我们提到过内建命令这一个概念。有一些命令不应该是子进程执行的，而应该是bash自己执行的，比如这里的cd，还有导入环境变量的export\n其实说白了就是bash检测到内建命令，就执行他自己的一个函数呗\n3.1 cd和export命令cd/export命令，c语言中都有现成的函数供我们使用，还是很方便的\n//这里导入环境变量之后，不会影响linux的shell//而是从我们的myshell开始所有子进程都会继承int PutEnvIn(char *new_env)&#123;    putenv(new_env);    return 0;&#125;//不使用内建命令，则不会生效int ChangeDir(const char *new_path)&#123;    chdir(new_path);    return 0; // 调用成功&#125;\n\n以下是main函数里面的内容，完整代码请去我的代码仓库查看\n// 5.内建命令if (strcmp(cmd_args[0], &quot;cd&quot;) == 0 &amp;&amp; cmd_args[1] != NULL)&#123;    ChangeDir(cmd_args[1]); //让调用方进行路径切换, 父进程    continue;&#125;// 目前，环境变量信息在cmd_line,会被清空// 此处我们需要自己保存一下环境变量内容char env_buffer[SIZE][NUM];size_t env_num = 0; //环境变量的数量if (strcmp(cmd_args[0], &quot;export&quot;) == 0 &amp;&amp; cmd_args[1] != NULL)&#123;    strcpy(env_buffer[env_num], cmd_args[1]);    PutEnvIn(env_buffer[env_num]);    env_num++;    continue;&#125;\n\n这时候cd就能正常执行了，不过pwd还没有修改，我没想好要怎么操作捏\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lsmakefile  myshell  myshell.c  myshell_err.c  test  test.cpp  test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# cd test[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lsbash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n试一试export，也没问题呢\n//test.cpp#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;ts= &quot; &lt;&lt; getenv(&quot;ts&quot;) &lt;&lt;endl;    return 0;&#125;\n\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# make testg++ test.cpp -o test -std=c++11bash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# export ts=12341[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# ./testts= 12341bash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n3.2 alias别名设置上面两个命令有现成的，alias的设置就需要我们手写啦\n#define NUM 1024#define SIZE 128//变量名别名typedef struct alias_cmd&#123;    char _cmd[SIZE];    char _acmd[SIZE];&#125; alias;alias cmd_alias[SIZE]; //缓存别名键值对(结构体)size_t alias_num = 0;  //已缓存的别名个数\n\n这里我先定义了一个结构体，用来存放变量别名的键值对，方便我们进行替换\n然后就是漫长的替换步骤，这部分我debug了非常久才写出来，都带了注释，大家可以看看\n//设置别名(新命令，原命令)void set_alias(char *cmd, char *acmd)&#123;    //查找别名里是否已经有了这个    for (int i = 0; i &lt; alias_num; i++)    &#123;        if (strcmp(cmd_alias[i]._cmd, cmd) == 0) //是已有的别名        &#123;            strcpy(cmd_alias[i]._acmd, acmd);            // printf(&quot;set cmd %s acmd %s\\n&quot;,cmd_alias[i]._cmd,cmd_alias[i]._acmd);            return;        &#125;    &#125;    //没有提前退出，说明是新增别名    strcpy(cmd_alias[alias_num]._cmd, cmd);    strcpy(cmd_alias[alias_num]._acmd, acmd);    alias_num++;&#125;//判断一个命令是否有别名bool is_alias(char *cmd_args[], int sz)&#123;    int i = 0;    for (i = 0; i &lt; alias_num; i++)    &#123;        if (strcmp(cmd_alias[i]._cmd, cmd_args[0]) == 0) //是别名        &#123;            size_t index = 1, j;            char *cmd_args_temp[SIZE];                                           //临时数组用于分离别名里面的命令            memset(cmd_line_alias, &#x27;\\0&#x27;, sizeof(cmd_line_alias) * sizeof(char)); //清空别名命令缓存            //先把别名中的命令分开            strcpy(cmd_line_alias, cmd_alias[i]._acmd); //不能直接使用_acmd，不然会影响下次别名使用            cmd_args_temp[0] = strtok(cmd_line_alias, SEP);            //别名的时候也需要设置ls的颜色（需要保证原本命令的第一个不是ls，不然本来就已经有&quot;--color=auto&quot;了）            if (strcmp(cmd_args_temp[0], &quot;ls&quot;) == 0 &amp;&amp; strcmp(cmd_args[0], &quot;ls&quot;) != 0)                cmd_args_temp[index++] = (char *)&quot;--color=auto&quot;;            while (cmd_args_temp[index++] = strtok(NULL, SEP))                ;            index--; // while会多+1，需要重新操作一下            //从原本数组的第二位开始往后设置            for (j = 1; j &lt; cmd_args_num; j++)            &#123;                cmd_args_temp[index++] = cmd_args[j];            &#125;            //替换掉原本的数组            cmd_args_num = index;              //此时的index长度正确，不需要-1            for (j = 0; j &lt; cmd_args_num; j++) //因为while最后会多++一次，所以需要-1            &#123;                //原本的位置没有那么大空间，放不下，不能拷贝                // strcpy(cmd_args[j],cmd_args_temp[j]);                cmd_args[j] = cmd_args_temp[j];                // printf(&quot;temp[%d] %s   args[%d] %s\\n&quot;,j,cmd_args_temp[j],j,cmd_args[j]);            &#125;            cmd_args[j] = NULL; //最后一个位置设置成NULL            return true;        &#125;    &#125;    return false;&#125;\n\n其实肯定是有更好的方案的，但是我还没想出来咋弄。现在这个能跑就OK，哈哈\n以最基本的ll命令来测试以下，替换成功！修改已有的别名也是没有问题的\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# alias ll=&#x27;ls -l&#x27;[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lltotal 60-rw-rw-r-- 1 muxue muxue   136 Oct 15 23:21 makefile-rwxrwxr-x 1 muxue muxue 14040 Oct 16 17:05 myshell-rw-rw-r-- 1 muxue muxue  8217 Oct 16 16:59 myshell.c-rw-rw-r-- 1 muxue muxue  6942 Oct 15 22:38 myshell_err.c-rwxrwxr-x 1 muxue muxue  9072 Oct 16 17:08 test-rw-rw-r-- 1 muxue muxue   130 Oct 15 23:22 test.cpp-rw-rw-r-- 1 muxue muxue    21 Oct 16 00:11 test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# alias ll=&#x27;ls -l -a&#x27;[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lltotal 68drwxrwxr-x  2 muxue muxue  4096 Oct 16 17:08 .drwxrwxr-x 13 muxue muxue  4096 Oct 15 17:31 ..-rw-rw-r--  1 muxue muxue   136 Oct 15 23:21 makefile-rwxrwxr-x  1 muxue muxue 14040 Oct 16 17:05 myshell-rw-rw-r--  1 muxue muxue  8217 Oct 16 16:59 myshell.c-rw-rw-r--  1 muxue muxue  6942 Oct 15 22:38 myshell_err.c-rwxrwxr-x  1 muxue muxue  9072 Oct 16 17:08 test-rw-rw-r--  1 muxue muxue   130 Oct 15 23:22 test.cpp-rw-rw-r--  1 muxue muxue    21 Oct 16 00:11 test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n结语就这样，一个最基本的bash或者说shell就被我们搞定啦\n其实内建命令远不止3里面提到的那几个，不过我们学习的目的已经达到了~也没必要死磕在这里\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】进程控制","url":"/posts/2395550697/","content":"阿巴阿巴，进程概念结束了，现在该学习如何控制一个进程了\n\n\n\n所用系统：CentOS 7.6\n\n[TOC]\n1.进程创建1.1 fork关于linux下的进程创建其实我们已经接触过了，那便是使用fork函数来进行操作\npid_t ret = fork();\n\nfork的返回值：子进程返回0、父进程返回子进程pid；出错返回-1\n\n小tips，其实pid_t就是int类型！\ntypedef __pid_t pid_t;\n\n在上篇程序地址空间的博客中已经提到，当一个进程调用fork函数的时候\n\n操作系统会给子进程分配一个新的内存块mm_struct+页表和内核数据结构task_strcut给子进程\n将父进程的部分数据结构拷贝自子进程（写时拷贝）\n将子进程添加系统进程列表当中\nfork返回，开始调度器调度\n\n简单说来，便是fork之前只有父进程单独运行。fork之后父子进程的执行流会分别执行，且相互独立\n\nfork之后，是父进程先执行还是子进程先执行依赖于调度器的调度。并非一定是父进程先执行！\n\n需要注意的是，子进程虽然共享父进程的所有代码，但是它只能从fork之后开始执行\n这里涉及到了cpu的eip程序计数器（又称pc指针）这玩意的作用就是保存当前正在执行的指令的下一条指令！\n\n注意，这里说的是CPU执行的指令，并非linux下bash里面的命令\n\neip程序计数器会把下一个指令拷贝给子进程，子进程就会从该eip所指向的代码处（即fork之后的代码）开始运行\nfork啥时候会出错如果你写一个循环代码一直创建子进程，那么就有可能创建失败！\n能够创建的子进程个数依赖于代码的复杂度\n1.2 写时拷贝之前已经提到过写时拷贝的概念，这里再次说明一番\n\n\n为什么要写时拷贝，创建子进程的时候直接把数据分开不行吗\n\n答，这样会存在内存浪费！\n\n一般情况下，父进程创建子进程之后，会出现下面的一些情况\n\n父进程的代码和数据，子进程不一定全部都会使用。即便使用、也不一定会进行修改\n理想状态下，可以把父子进程会修改的内容进行分离，不会修改的部分共享即可。但是这样的实现非常复杂\n如果fork的时候，就直接分离父子进程的数据，会增加fork运行的时间复杂度和空间复杂度\n\n所以最终linux采用了写时拷贝的方式，只会在需要的时候，拷贝父子需要修改的数据。这样延迟拷贝，变相提高了内存的使用率\n2.进程终止2.1 程序退出码在之前学习C&#x2F;C++的时候，我们知道main函数是一个程序的入口函数，那么你知道main函数内部的返回有何用，又被谁接收了吗？\nint main()&#123;\treturn 0;&#125;\n\n使用echo $?命令查看环境变量，可以看到我们进程的推出码\n\nint main()&#123;\treturn 10;&#125;\n\n修改对应的返回值，再次运行程序，可以看到不同的结果\n\n知识点：?环境变量存放的是上一次运行的程序的退出码\n[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ echo $?10[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ echo $?0\n\n比如这里我们连续两次访问这个环境变量，可以看到第一次的结果是我们自己运行的程序返回的10，第二次的结果是0（echo命令的返回值）\n\n2.1.1 strerror那么，这个程序退出码有什么含义呢？\n这里我们使用for循环打印一下库函数中strerrror函数内记录的错误码\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;    int i=0;    for(i=0;i&lt;100;i++)    &#123;        printf(&quot;[%d] %s\\n&quot;,i,strerror(i));    &#125;    return 0;&#125;\n\n可以看到，100个错误码被打印了出来\n\n进一步加大循环的次数，能看到C语言中定义的错误码一共是134个。后续全部打印unknown error\n\n我们设计程序的退出码的时候，可以参照C语言库函数的错误码来进行设置，这样能更好地和库内部进行对接，或用strerror函数来获取到错误信息\n\n这就是用错误码来实现的异常管理\n\n2.2 程序退出的几种状态一般情况下，程序有下面的几种退出状态：\n\n代码跑完，结果与预期相符\n代码跑完，结果有问题\n代码没有跑完，提前出现异常终止，或者被外部关闭\n\n一般情况下，我们不会去在乎一个进程为何会成功；而更在乎一个错误的进程到底哪儿有bug。所以就需要想办法获取到这个进程的错误码\n错误码表征了程序退出的信息，交由父进程进行读取\n上面我们在bash中能通过echo读取上一个进程的退出码，那是因为我们自己运行的可执行程序，其父进程就为当前的bash。bash接受了我们进程的退出码，放入到了环境变量中\n\n2.3 终止的常见做法一般情况下，我们可以在main函数中return，或者在任何地方使用exit()来终止程序\n这里还需要提及另外一个版本的exit()，即_exit\n\n最可见的区别便是，exit会刷新缓冲区，而_exit不会\nvoid test2()&#123;    printf(&quot;i&#x27;m good, exit&quot;);    exit(0);&#125;void test3()&#123;    printf(&quot;i&#x27;m good, _exit&quot;);    _exit(0);&#125;\n\n这里我先调用test2函数，输出的结果是这样的👇\n[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ gcc test_strerror.c -o test &amp;&amp; ./testi&#x27;m good, exit[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ \n\n如果调用的是test3，则会出现下面的情况\n[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ gcc test_strerror.c -o test &amp;&amp; ./test[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ \n\n程序什么都没有打印！\n缓冲区这部分是基础IO的知识\nlinux下有一个输入输出的缓冲区，当我们调用printf的时候，系统不会立马打印，而是会将待打印的内容先写入缓冲区，直到我们输出\\n或者调用fflush函数手动刷新缓冲区。\nfflush(stdout);//手动刷新缓冲区\n\nexit和_exit在_exit的man手册中也能看到，该函数会立即干掉这个进程；而exit还会做一些其他的操作\n\n2.4 终止的时候，内核做了什么？我们知道，进程&#x3D;内核结构task/mm_struct等+进程代码、数据\n操作系统可能并不会释放该进程的task_struct/mm_struct，而是留给下一个进程使用！\n要知道，如果想使用一个结构体，就需要对它进行开空间和初始化操作。而在操作系统中，创建、终止进程是一个非常高频的操作。如果总是不断的创建内核结构再释放，其内存利用率就很低，而且拖慢系统运行速度。\n这时候系统就会使用内核的数据结构缓冲池，又称slab分派器，来管理这些仍待使用的内核结构。当有新进程出现的时候，更新内核结构的信息，并将其插入到运行队列中\n\n3.进程等待之前讲过子进程退出，父进程如果不管不顾，就会造成僵尸进程的问题，从而导致内存泄漏等一系列问题\n\n另外，僵尸进程一旦出现，即便是kill -9也无法杀掉这个进程\n\n所以父进程需要监看子进程的退出状态，并进行相应的操作\n父进程通过进程等待的方式回收子进程资源，获取子进程的退出信息\n\n3.1 如何等待进程等待这里我们需要用到两个函数\npid_t wait(int*status);pid_t waitpid(pid_t pid, int *status, int options);\n\n它们的头文件是\n#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;\n\n3.2 wait先来康康第一个，其作用是等待子进程退出，status是一个输出型参数，子进程退出后，我们可以从中获取到子进程的退出信息\n\nstatus是从子进程的task_struct中拿出来的，子进程会将自己的退出码写入task_struct\n如果我们不关心子进程的退出状态，则可以给status传一个NULL空指针\n若等待失败，则返回-1\n\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 5;        while(i--)        &#123;            printf(&quot;我是子进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);            sleep(1);        &#125;        printf(&quot;子进程退出\\n&quot;);        exit(0);    &#125;    else    &#123;            printf(&quot;我是父进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(5);        int status = 0;        pid_t st = wait(&amp;status);        printf(&quot;等待成功,子进程pid:%d, 状态信息：%d\\n&quot;,st,status);        sleep(5);    &#125;           return 0;&#125;\n\n\n嗯，看起来没啥问题，我们成功获取了子进程的pid以及退出码0\n那如果我们修改一下子进程中exit的值呢？\nexit(11);\n\n\n呀，出问题了，为何状态码变成2816了？\n3.2.1 关于status实际上，输出型参数中status的值并非是完整的退出状态信息，其分为下面两种情况\n\n所以说，正确访问状态码的方式，是先将status右移8位，再用按位与取出状态码\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 5;        while(i--)        &#123;            printf(&quot;我是子进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n&quot;,getpid(),getppid(),ret,&amp;ret);            //i++;            sleep(1);        &#125;        printf(&quot;子进程退出\\n&quot;);        exit(11);    &#125;    else    &#123;            printf(&quot;我是父进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(5);        int status = 0;        pid_t st = wait(&amp;status);        //printf(&quot;等待成功,子进程pid:%d, 状态信息：%d\\n&quot;,st,status);//直接打印status是错误的！        //status的低16位才有效，其中这16位的高8位是状态码        printf(&quot;等待成功,子进程pid:%d, 状态信息：%d\\n&quot;,st,(status&gt;&gt;8)&amp;0xFF);//0xff是8个1        sleep(5);    &#125;           return 0;&#125;\n\n\n再来修改一下exit的值为200，依旧正确！\n子进程退出等待成功,子进程pid:770, 状态信息：200\n\n\n3.3 waitpid该函数的原型如下\npid_t waitpid(pid_t pid, int *status, int options);\n\n\npid：&gt;0指定等待子进程pid；-1等待所有子进程\nstatus：同wait，为输出型参数\noptions：若设置为0，则进行阻塞等待；其余选项见下图\n\n\n返回值：\n\n正常等待，返回子进程的pid\n如果设置了options，而waitpid发现没有已退出的子进程可收集，返回0\n调用中出错，返回-1。此时errno会被设置成相对应的值来显示错误\n\nwait(): on success, returns the process ID of the terminated child; on error, -1 is returned.waitpid(): on success, returns the process ID of the child whose state has changed; if WNOHANG  was  specified  and  one  or  more child(ren) specified by pid exist, but have not yet changed state, then 0 is returned.  On error, -1 is returned.\n\n代码示例\nint main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 4;        while(i--)        &#123;            printf(&quot;我是子进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n&quot;,getpid(),getppid(),ret,&amp;ret);            //i++;            sleep(1);        &#125;        printf(&quot;子进程退出\\n&quot;);        exit(0);    &#125;    else    &#123;            printf(&quot;我是父进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(5);        int status = 0;        pid_t st = waitpid(ret,&amp;status,0);//指定等待上面创建的子进程        //status的低16位才有效，其中这16位的高8位是状态码        printf(&quot;等待成功,子进程pid:%d, 状态信息：%d\\n&quot;,st,(status&gt;&gt;8)&amp;0xFF);//0xff是8个1        sleep(5);    &#125;          return 0;&#125;\n\n\n3.4 信号终止目前linux支持的信号如下，在后续信号的章节会单独讲解！\n\n\n前面提到了，除了正常的终止，status中还可以保存信号终止的信息\n\n这里的core dump标志是用来干嘛的我们暂且不提（后续信号部分会有讲解）先来试试用kill来干掉子进程！\n这里我们要取出的是status中最低7位的数据，就需要按位与一个二进制末尾是7个1的数字\n注意：如果子进程是因为信号退出，那么我们不需要关注退出码，其没有意义！\nint main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 20;        while(i--)        &#123;            printf(&quot;我是子进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n&quot;,getpid(),getppid(),ret,&amp;ret);            //i++;            sleep(1);        &#125;        printf(&quot;子进程退出\\n&quot;);        exit(0);    &#125;    else    &#123;            printf(&quot;我是父进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(30);        int status = 0;        pid_t st = waitpid(ret,&amp;status,0);//指定等待上面创建的子进程        //status的低16位才有效，其中这16位的高8位是状态码        printf(&quot;等待成功,子进程pid:%d, 状态：%d，信号：%d\\n&quot;,st,(status&gt;&gt;8)&amp;0xFF,status&amp;0x7F);//0xff是8个1        sleep(10);    &#125;          return 0;&#125;\n\n 程序最开始的时候，子进程正常创建，父进程等待子进程结束\n\n这里使用kill给子进程发信号，干掉了子进程\n[muxue@bt-7274:~/git/c_code]$ kill -9 5952[muxue@bt-7274:~/git/c_code]$ \n\n父进程sleep结束后执行waitpid获取到了子进程的结束信息以及信号9\n\n同时通过之前写的检测脚本\nwhile :; do ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\n能看到子进程进入z僵尸状态\n\n父进程回收子进程的过程\n\n换一个kill的信号，父进程也能正确获得其结果\n[muxue@bt-7274:~/git/c_code]$ kill -30 7607[muxue@bt-7274:~/git/c_code]$ \n\n我是子进程7607 , ppid:7606 , ret:0    , &amp;ret:0x7ffccf2aeb20我是子进程7607 , ppid:7606 , ret:0    , &amp;ret:0x7ffccf2aeb20等待成功,子进程pid:7607, 状态：0，信号：30\n\n除了我们可以手动使用kill 给进程发信号，一些错误也会让进程自己退出。比如信号8就是浮点数错误，可以用除0来复现这个错误\n操作系统是怎么知道我们除0了？\n\n在CPU内有一个状态寄存器，当cpu进行运算的时候出错了，会更新状态寄存器。操作系统检测到CPU用状态寄存器给他报了个错，就会识别错误类型，并通过信号干掉当前运行的进程\n我们运行的进程中的软件错误，部分是会在硬件层面上体现的\n\n3.5 库里面提供的宏自己写按位与多麻烦呀，库里面提供了几个宏供我们使用\n\nWIFEXITED(status)  查看子进程是否是正常退出的，正常退出为真\nWIFSIGNALED(status)查看子进程是否为信号终止，信号终止返回真\nWEXITSTATUS(status) 提取子进程退出码\nWTERMSIG(status) 提取子进程退出信号\n\n//其余部分代码和上面相同，子进程exit(11)int status = 0;pid_t st = waitpid(ret,&amp;status,0);//指定等待上面创建的子进程if(WIFEXITED(status))//子进程正常退出返回真&#123;       printf(&quot;等待成功,子进程pid:%d, 状态：%d，信号：%d\\n&quot;,st,WEXITSTATUS(status),WTERMSIG(status));&#125;else&#123;    printf(&quot;非正常退出,子进程pid:%d, 状态：%d，信号：%d\\n&quot;,st,WEXITSTATUS(status),WTERMSIG(status));&#125;\n\n下图为子进程正常exit\n\n下图为子进程被kill -9干掉\n\n3.6 阻塞等待和非阻塞等待前面的waitpid函数中的option参数就和阻塞&#x2F;非阻塞等待有关\n0       阻塞WNOHANG 非阻塞\n\n3.6.1 阻塞等待当我们调用某些函数的时候，因为条件不就绪，需要我们进行阻塞等待\n\n本质：当前程序自己变成阻塞状态，当一切就绪的时候再被唤醒。\n这时候我们等待的不是硬件资源，而是等待子进程运行结束（软件资源）\n\n阻塞等待时，将父进程放入子进程task_struct中的等待队列。当操作系统检测出子进程退出，就从等待队列中唤醒父进程，阻塞等待成功！\n\n给waitpid的option传入0，即为阻塞等待\npid_t st = waitpid(-1,&amp;status,0);//阻塞等待\n\n在子进程被信号干掉或者执行完毕退出之前，父进程不会向后执行代码。在用户层面看来，就是一个程序卡住了\n3.6.2 非阻塞等待给waitpid的option传入WNOHANG，即为非阻塞等待\n等待期间，父进程可以干其他的事情\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int add(int a,int b)&#123;    return a+b;&#125;int pls(int a,int b)&#123;    return a*b;&#125;int main()&#123;    pid_t id = fork();    if(id == 0)    &#123;        // 子进程        int i =5;        while(i--)        &#123;            printf(&quot;我是子进程, 我的PID: %d, 我的PPID:%d\\n&quot;, getpid(), getppid());            sleep(2);        &#125;        exit(0);    &#125;    else if(id &gt;0)    &#123;        // 父进程        // 基于非阻塞的轮询等待方案        int status = 0;        int i = 1, j=2;        while(1)        &#123;            pid_t ret = waitpid(-1, &amp;status, WNOHANG);            if(ret &gt; 0)            &#123;                printf(&quot;等待成功, %d, exit code: %d, exit sig: %d\\n&quot;, ret, WIFEXITED(status), WTERMSIG(status));                break;            &#125;            else if(ret == 0)            &#123;                //等待成功了，但子进程没有退出                printf(&quot;子进程好了没？没有，父进程做其他事情\\n&quot;);                printf(&quot;add %d  &quot;,add(i++,j++));                printf(&quot;pls %d\\n&quot;,pls(i++,j++));                sleep(1);            &#125;            else&#123;                //err                printf(&quot;父进程等待出错！\\n&quot;);                break;            &#125;        &#125;    &#125;    return 0;&#125;\n\n这里我们给父进程写了一个死循环，一直等待子进程退出。每一次循环都会调用一次waitpid的接口，直到成功获取了子进程的退出信息\n这种多次调用waitpid接口的方式又被称为轮询检测\n\n举个具体例子，当我们使用一个聊天软件需要加载图片的时候，父进程（聊天框）可以先显示一个图片的加载图，告诉你图片正在加载（子进程）。而你还是可以正常浏览其他人的发言。等图片加载完毕（子进程退出）之后，父进程就可以把那个临时的加载图替换成获取到的图片本身，这就是一次成功的非阻塞等待\n\n4.进程替换在之前的fork中，我们的子进程都是运行的已经预先写好的代码，或者说是继承了父进程的代码继续向后执行。\n进程替换就是让子进程可以执行磁盘里面其他的可执行文件，包括Linux系统的命令、其他语言写的代码py c++ php等等……\n4.1 原理其实就是让子进程通过调用操作系统的接口，来执行一个已有的可执行程序\n\n这个过程中并没有创建新的子进程，本质上还是当前子进程\n\n程序替换的过程\n\n将磁盘中的程序加载进入内核结构\n重新建立页表映射，因为是子进程调用的程序替换，那么就会修改子进程的页表映射\n效果：子进程代码和父进程彻底分离，子进程执行了一个全新的程序\n\n\n4.2 如何替换系统提供了非常多的函数接口，供我们在一个程序中调用系统中其他的可执行程序\n\n\n要想调用，首先要找到这个程序在那儿，以及要用什么办法执行这个程序（命令行参数）下面以具体的例子来了解一下吧\n\n需要注意的是：我们需要先用fork创建子进程，再调用上面这些函数接口来使用其他可执行文件。这些函数接口本身并不会创建新的子进程！\n\n4.3 execlint execl(const char *path, const char *arg, ...);\n\n\npath是需要运行程序的路径\narg代表需要执行的程序\n...是可变参数，可以传入不定量的参数。这里我们填入的是命令行的参数\n\n说起来学到了这里我才知道原来C语言支持可变参数……\n#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;    printf(&quot;开始测试\\n\\n&quot;);    int ret = execl(&quot;/usr/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);    printf(&quot;执行结束 %d\\n&quot;,ret);    return 0;&#125;\n\n需要注意的是，当我们填入命令行参数的时候，必须要以NULL作为参数的结尾\n\n我们会发现，调用了其他可执行程序之后，在后面的printf函数并没有被执行！\n这是因为，当我们用这个函数来调用其他可执行程序，本质上已经把当前的代码和数据替换掉了！既然是替换，那么原本的printf(&quot;执行结束 %d\\n&quot;,ret);肯定也不会执行\n返回值问题那execl不是有一个int类型的返回值吗？如果程序替换了之后不会执行后面的代码，那这个返回值还有什么用呢？\n\n查手册可以看到，这个返回值只有出错的时候才会返回-1，同时会更新ERRNO\nint main()&#123;    printf(&quot;开始测试\\n\\n&quot;);    int ret = execl(&quot;/usr/bin/&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return 0;&#125;\n\n现在我们把执行文件改成usr/bin/这个错误文件，那么就会调用失败，同时可以看到调用失败的原因是，我们没有权限去执行/usr/bin\n\nint ret = execl(&quot;/usr/erqer/&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);\n\n如果改成一个乱七八糟的路径，也会打印出错误结果为“文件或路径不存在”\n\n根据这个特效，我们在执行exec这些替换函数的时候，其实没有必要去判断返回值。因为这些函数只有出错的时候，才会执行后面的代码！\n\n无需判断返回值，直接打印errno找出错误原因即可\n\n替换别的代码之前说过，替换不仅可以替换系统的命令，还可以替换成其他语言的代码\n比如下面是一个最简单的py代码\nprint(&quot;我是一个python程序！&quot;)#python中print会默认换一行\n\n我们在C中利用execl来调用这个自己写的python程序。如果你不知道你系统中有没有python，或者不知道它的路径，可以用which来查看位置\n\nint main()&#123;    printf(&quot;开始测试\\n\\n&quot;);    int ret = execl(&quot;/usr/local/bin/python3&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);    //int ret = execl(&quot;/usr/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return 0;&#125;\n\n可以看到，python程序被成功执行！\n\n子进程替换了解了替换程序的基本方法了之后，可以先来试试写一个父子进程\n这里让父进程进行3.6.2里面的轮询检测\nint add(int a,int b)&#123;    return a+b;&#125;int pls(int a,int b)&#123;    return a*b;&#125;int main()&#123;    pid_t id = fork();    if(id == 0)    &#123;        // 子进程        int i = 3;        while(i--)        &#123;            printf(&quot;我是子进程, 我的PID: %d, 我的PPID:%d\\n&quot;, getpid(), getppid());            sleep(2);//便于观察            int ret = execl(&quot;/usr/local/bin/python3&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);            printf(&quot;子进程执行出错: %d\\n&quot;,ret);            printf(&quot;子进程错误原因: %s\\n&quot;,strerror(errno));            exit(-1);        &#125;    &#125;    else if(id &gt;0)    &#123;        // 父进程        // 基于非阻塞的轮询等待方案        int status = 0;        int i = 1, j=2;        printf(&quot;我是父进程, 我的PID: %d, 我的PPID:%d\\n&quot;, getpid(), getppid());        while(1)        &#123;            pid_t ret = waitpid(-1, &amp;status, WNOHANG);            if(ret &gt; 0)            &#123;                printf(&quot;等待成功, %d, exit code: %d, exit sig: %d\\n&quot;, ret, WIFEXITED(status), WTERMSIG(status));                break;            &#125;            else if(ret == 0)            &#123;                //等待成功了，但子进程没有退出                printf(&quot;子进程好了没？没有，父进程做其他事情\\n&quot;);                printf(&quot;add %d  &quot;,add(i++,j++));                printf(&quot;pls %d\\n&quot;,pls(i++,j++));                sleep(1);            &#125;            else&#123;                //err                printf(&quot;父进程等待出错！\\n&quot;);                break;            &#125;        &#125;    &#125;    return 0;&#125;\n\n\n可以看到，子进程替换了python程序成功了之后，不会执行后面的printf\n这里的exit code也被设置成了1\n\n这里我自己想出来了一个问题，这里的exit code和我们python程序里面设置的有没有关系呢？来试试~\nprint(&quot;我是一个python程序！&quot;)exit(10)#execl父进程接收到的退出码和这里没有关系\n\nemm结果没变，说明没有关系\n我是一个python程序！等待成功, 20333, exit code: 1, exit sig: 0\n\n即便我们python程序里面有bug，这里也不会有啥变化\nprint(&quot;我是一个python程序！&quot;)a =10/0\n\n我是一个python程序！Traceback (most recent call last):  File &quot;/home/muxue/git/linux/code/22-10-13_exec/test.py&quot;, line 3, in &lt;module&gt;    a =10/0ZeroDivisionError: division by zero等待成功, 21179, exit code: 1, exit sig: 0\n\n同时我们也可以看到，子进程执行程序替换，是不会影响父进程的（进程具有独立性）\n这是因为数据发生了写时拷贝，程序替换的时候可以理解为代码和数据都通过写时拷贝进行了父子的分离（注意分离的是代码和数据，并非父子关系！）\n4.4 execv学会了前面的execl，再来看看这个\nint execv(const char *path, char *const argv[]);\n\n可以看到这个函数莫得可变参数，而是需要我们用一个指针数组来传入命令行参数！其余都是一样的！\n\n复习一下，const修饰指针有下面两种形式\n\n在*之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）\n在*之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）\n\n\nvoid testExecv()&#123;    printf(&quot;开始测试\\n\\n&quot;);    char*const arg[]=&#123;        &quot;ls&quot;,        &quot;-l&quot;,        &quot;-a&quot;,        NULL    &#125;;    int ret = execv(&quot;/usr/bin/ls&quot;,arg);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n调用成功！\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试total 36drwxrwxr-x  2 muxue muxue  4096 Oct 14 13:36 .drwxrwxr-x 12 muxue muxue  4096 Oct 13 15:19 ..-rw-rw-r--  1 muxue muxue    69 Oct 13 15:24 makefile-rwxrwxr-x  1 muxue muxue 13192 Oct 14 13:36 test-rw-rw-r--  1 muxue muxue  2402 Oct 14 13:37 test.c-rw-rw-r--  1 muxue muxue   111 Oct 14 13:23 test.py[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n\n4.5 execlpint execlp(const char *file, const char *arg, ...);\n\n注意，这里参数的说明从path变成了file\n这个函数和execl的区别在于，它会自己去系统环境变量的PATH里面查找可执行程序\n[muxue@bt-7274:~/git]$ echo $PATH/home/muxue/.vscode-server/bin/d045a5eda657f4d7b676dedbfa7aab8207f8a075/bin/remote-cli:/usr/local/bin:/usr/bin:/usr/local/python3/bin:/usr/local/python3/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin:/usr/local/python3/bin:/usr/local/python3/bin[muxue@bt-7274:~/git]$ \n\n只有找不到这个程序的时候，才会报错！\nvoid testExeclp()&#123;    printf(&quot;开始测试\\n\\n&quot;);    int ret = execlp(&quot;python3&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n结果如下，成功调用\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试我是一个python程序！[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n随意指定一个程序，就会报错\nint ret = execlp(&quot;python3300&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);\n\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试执行结束: -1错误原因: No such file or directory[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n4.6 execvpint execvp(const char *file, char *const argv[]);\n\n知道了execv/excel之间的区别，那么execvp/execlp之间的区别也就很明显辣！\n同样也是只有传参的区别，其他的操作完全一样\nvoid testExecvp()&#123;    printf(&quot;开始测试\\n\\n&quot;);    char*const arg[]=&#123;        &quot;ls&quot;,        &quot;-l&quot;,        &quot;-a&quot;,        NULL    &#125;;    int ret = execvp(&quot;ls&quot;,arg);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试total 36drwxrwxr-x  2 muxue muxue  4096 Oct 14 13:48 .drwxrwxr-x 12 muxue muxue  4096 Oct 13 15:19 ..-rw-rw-r--  1 muxue muxue    69 Oct 13 15:24 makefile-rwxrwxr-x  1 muxue muxue 13368 Oct 14 13:48 test-rw-rw-r--  1 muxue muxue  2994 Oct 14 13:48 test.c-rw-rw-r--  1 muxue muxue   112 Oct 14 13:45 test.py[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n4.7 execle&#x2F;execvpe&#x2F;execve这几个函数放在一起了，因为它们的使用方法很相似\nint execle(const char *path, const char *arg,                  ..., char * const envp[]);int execvpe(const char *file, char *const argv[],                   char *const envp[]);int execve(const char *filename, char *const argv[],           char *const envp[]);\n\n首先它们的函数名中都有个e，这个e代表的是环境变量，代表我们可以把特定的环境变量传入其中进行处理。它们的环境变量都是在最末尾传的\n\n\n\n函数\n参数\n说明\n\n\n\nexecle\n可执行文件的完整路径，命令行参数，环境变量\n利用可变参数传入命令行参数\n\n\nexecve\n可执行文件的完整路径，命令行参数，环境变量\n利用数组传入命令行参数\n\n\nexecvpe\n可执行文件名字，命令行参数，环境变量\n利用数组传入命令行参数；只需要传入可执行文件的名字，会自动在PATH里面搜索\n\n\n测试这里我先用C++写一个打印程序，来打印我们的环境变量\n#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;hello c++&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;-------------------------------------------\\n&quot;;    cout &lt;&lt; &quot;PATH:&quot; &lt;&lt; getenv(&quot;PATH&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;-------------------------------------------\\n&quot;;    cout &lt;&lt; &quot;MYPATH:&quot; &lt;&lt; getenv(&quot;MYPATH&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;-------------------------------------------\\n&quot;;        return 0;&#125;\n\n利用g++将其编译为可执行文件mytest\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ lsmakefile  mytest  test  test.c  test.cpp  test.py\n\n下面开始测试\nvoid testExecve()&#123;    extern char ** environ;//引入外部环境变量    printf(&quot;开始测试\\n\\n&quot;);    char*const arg[]=&#123;        &quot;./mytest&quot;,        NULL    &#125;;    int ret = execve(&quot;/home/muxue/git/linux/code/22-10-13_exec/mytest&quot;,arg,environ);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n\n从cpp文件的打印结果可以到，我们传入了完整的环境变量，PATH成功打印，但是MYPATH没有打印出来。这是因为环境变量里面没有这个\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ echo $MYPATH[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n利用export导入环境变量\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ export MYPATH=4321[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ echo $MYPATH4321[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n再次测试，可以看到两个环境变量都被打印出来了\n\n自己传入环境变量上面我们是直接引入外部环境变量\nextern char ** environ;//引入外部环境变量\n\n我们还可以自己整一个数组来传入环境变量\nvoid testExecve()&#123;    extern char ** environ;    printf(&quot;开始测试\\n\\n&quot;);    char*const arg[]=&#123;        &quot;./mytest&quot;,        NULL    &#125;;    char*const env[]=&#123;        &quot;MYPATH=this is c test&quot;,        NULL    &#125;;    int ret = execve(&quot;/home/muxue/git/linux/code/22-10-13_exec/mytest&quot;,arg,env);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n诶，怎么连PATH都打印不出来了？？这不是系统里面有的环境变量吗？\n\nchar*const env[]=&#123;    &quot;PATH=path test&quot;,    &quot;MYPATH=this is c test&quot;,    NULL&#125;;\n\n重新设置传入的环境变量，PATH才能成功打印\n\n这说明这几个函数的环境变量参数，在传入的时候，是会覆盖掉系统的环境变量的！\n关于环境变量参数的问题实际上，其余不带e的函数，也是能获取到系统的环境变量的（直接继承父进程BASH的环境变量）\n而带e的函数允许我们单独控制环境变量\n\n直接传入extern char ** environ;的系统环境变量\n将特定的环境变量传入\n临时自定义一部分环境变量\n\n\n注意PATH和自己的可执行程序这里只对execvpe说明一下，如果想用它调用我们自己写的mytest，那么就需要把mytest放入系统PATH里面，不然是找不到的！\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试执行结束: -1错误原因: No such file or directory\n\n所以还是用它来调用系统的命令吧\nchar*const arg_[]=&#123;    &quot;ls&quot;,    &quot;-l&quot;,    &quot;-a&quot;,    NULL&#125;;int ret = execvpe(&quot;ls&quot;,arg_,env);\n\n4.8 execve是系统接口如果你有注意看，应该会发现execve的man手册是单独拎出来的，左上角的编号也不一样\n\n这是因为，实际上只有execve是Linux系统提供的接口\n而其他函数都是C语言库中对execve的二次封装，来适应不同的使用场景！\n4.9 函数命名总结\nl(list)：使用可变参数列表\nv(vector)：用数组传参\np(path)：自动在环境变量PATH中搜索\ne(env)：表示自己维护环境变量\n\n\n结语进程控制章节的内容到这里就基本结束啦，后续有补充的内容会在本博客里面新增！\n感谢你看到最后，有啥问题可以在评论区提出哦\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】文件IO","url":"/posts/2864480005/","content":"让我们来认识一下linux下的文件接口吧！\n\n\n\n演示所用系统：CentOS7.6\n本文所有代码都可以在我的gitee仓库查看【链接】\n\n[TOC]\n1.什么是文件？\n文件=文件内容+文件属性，文件属性也是数据，即便我们创建一个空文件，也是会占用磁盘空间的\n文件操作=文件内容的操作+文件属性的操作，在之前linux权限的博客里面就提到过，文件操作有可能即改变内容，又改变属性\n文件打开操作其实是把文件的属性和内容加载到内存中，没有被打开的文件依旧处于磁盘当中\n当前路径为当前进程所处的工作路径\n\n我们的打开文件操作需要和磁盘这个硬件打交道，只有操作系统才能直接操作硬件。所以我们的文件操作其实都是调用的系统接口。\n实际上，所有编程语言都对操作系统接口进行了封装，这样才能保证他们的跨平台性。因为不同操作系统的各种接口各不相同，如果不进行封装，直接调用系统接口，则该代码只能在指定系统上跑！\n1.2 C语言文件操作在学习Linux下文件相关内容之前，我们先来复习一下C语言的文件接口\nvoid writetest()&#123;    char*file=&quot;test.txt&quot;;    FILE* f=fopen(file,&quot;w&quot;);    for(int i =0;i&lt;10;i++)    &#123;        fprintf(f,&quot;hello linux! %d\\n&quot;,i);    &#125;        fclose(f);    f=NULL;&#125;void readtest()&#123;    char*file=&quot;test.txt&quot;;    FILE* f=fopen(file,&quot;r&quot;);    char buff[128];//将读取到的数据写入buff数组里面    for(int i =0;i&lt;10;i++)    &#123;        fgets(buff,20,f);        printf(&quot;%s&quot;,buff);    &#125;    fclose(f);    f=NULL;&#125;\n\n这里用循环先往test.txt内输入10行数据，再读取并打印到屏幕上\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test1hello linux! 0hello linux! 1hello linux! 2hello linux! 3hello linux! 4hello linux! 5hello linux! 6hello linux! 7hello linux! 8hello linux! 9[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n\n除了w和r方法外，C语言还提供了w+ r+ a以及带b的二进制读写\n\n这部分内容可以去看看我之前的C语言文件操作博客！\n\nC语言默认打开了三个输入输出流，都是一个FILE*的指针，分别为stdin/stdout/stderr，记住这个点，后面会用到哦\n\n2.初识Linux系统的文件接口Linux下的文件操作用的接口为open/write/read，都需要先用open打开文件并指定打开方式后，再用write/read操作进行读写\n\n注：man查询的时候需要指定man 2 open，否则查询到的是命令不是函数接口\n\n\n这里open一共有两个函数接口，没错，就是函数重载！这是因为linux下的C语言标准和我们之前在win下学习所用的标准是不一样的！\n\n第一个参数为pathname，文件路径\n第二个参数为flags，打开文件的方式\n\n打开文件的方式并不像C语言用w/r等等代替，而是需要我们传入多个flag进行按位与，这一点和C++中的文件类一样！\n\n这里的flag其实是一种位图结构。每一个flag只需要在一个比特位上为1（十进制2的倍数）其余位为0，保证互不影响。这样在按位与的时候，才能正确凑到一起，并通过按位或进行flag的取出\n\n flag的参数中，下面这三个值，必须指定一个且只能指定一个\n\nO_RDONLY: 只读打开\nO_WRONLY: 只写打开\nO_RDWR: 读，写打开\n\n剩余的参数是用作额外操作的\n\nO_CREAT: 若文件不存在，则创建；需要传入mode参数，来指明新文件的访问权限\nO_APPEND: 追加写\nO_TRUNC: 清空文件\n……\n\n常用的参数就上面这些，更多参数可以使用man 2 open查看完整flag列表\n\n这种大写+下划线的命名方式告诉我们，它其实就是系统中预先定义好的宏！\n\n需要注意的是，open函数的返回值是一个int类型，它被称为文件描述符，后面会有详解\n\n2.1 读文件\n读文件的操作和fgets类似，需要指定文件描述符，以及用于保存文件内容的buf，和数据长度count\n#define SIZE 256void test1()&#123;    char buf[SIZE];    int fd1 = open(&quot;test.txt&quot;, O_RDONLY);    read(fd1,buf,strlen(buf)-1);    ssize_t s = read(fd1, buf, sizeof(buf)-1);    if(s &gt; 0)    &#123;       buf[s] = &#x27;\\0&#x27;;       printf(&quot;%s&quot;, buf);    &#125;    close(fd1);&#125;\n\nssize_t是有符号整型，其实就是int\ntypedef int ssize_t\n\n这里我们打开了刚刚测试C语言用的test.txt文件，成功读出了里面的内容\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testhello linux! 0hello linux! 1hello linux! 2hello linux! 3hello linux! 4hello linux! 5hello linux! 6hello linux! 7hello linux! 8hello linux! 9[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n2.2 写文件\n注意的是，默认情况下，如果我们不在open的时候指定第三个参数，其创建的新文件，权限是乱掉的。而单给第三个参数传入0666还不够，我们需要先把系统的umask在当前进程中设置为0，以避免系统umask的默认值对我们创建文件的权限造成影响\nvoid test2()&#123;    umask(0);//先把umask设置为0，保证权限值设置正确，不受系统umask影响    int fd = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);\t//这里我们指定了0_CREAT，所以需要指定0666作为权限值    const char *str = &quot;bbbbbb\\n&quot;;    write(fd, str, strlen(str));    close(fd);&#125;\n\n执行上述代码后，可以看到数据被成功写入\n\n这里我们还指定了O_TRUNC，所以每一次执行的时候，文件内部的内容都会被清空。修改str后重新进行测试，可以看到原有的内容不见了\n\n如果不指定，其不会清空已有内容。而是会从开头进行写入，覆盖开头已有的内容（左边为写入后，右边为写入前）\n\n实际上，C语言的文件操作，调用的就是linux的文件接口\nfopen(&quot;test.txt&quot;, &quot;w&quot;); //底层调用open，O_WRONLY | O_CREAT | O_TRUNCfopen(&quot;test.txt&quot;, &quot;a&quot;); //底层调用open，O_WRONLY | O_CREAT | O_APPEND\n\n写方式覆盖？在测试的时候，我发现了一个神奇的情况\nvoid test2()&#123;    umask(0);//先把umask设置为0，保证权限值设置正确，不受系统umask影响    int fd1 = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT, 0666);    int fd2 = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fd1: %d  fd2: %d\\n&quot;,fd1,fd2);    const char *str = &quot;bbadsfasdfasdfa23123bbbb&quot;;    write(fd1, str, strlen(str));    close(fd1);&#125;\n\n这里我分别用fd1/fd2打开了test.txt文件，打印它们的文件描述符可以看到，结果不一样\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testfd1: 3  fd2: 4[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n但是，执行的写入，却是 O_TRUNC的覆盖方法！\n\n实际上，并不是fd2的写入方法覆盖了fd1的，而是当我们使用 O_TRUNC方法打开文件的时候，文件里面的内容就已经被清空了！\n\n\n可以看到，刚刚才begin fd2的时候，test.txt的文件大小就已经变成0了\n为了避免这种情况，建议不要在同一个进程里面多次打开一个之前已经打开过的文件！\n3.文件描述符3.1 为什么是从3开始？这里我们一次性打开多个文件，打印他们的文件描述符\nvoid test3()&#123;    int fda = open(&quot;loga.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdb = open(&quot;logb.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdc = open(&quot;logc.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdd = open(&quot;logd.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fde = open(&quot;loge.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fda: %d\\n&quot;, fda);    printf(&quot;fdb: %d\\n&quot;, fdb);    printf(&quot;fdc: %d\\n&quot;, fdc);    printf(&quot;fdd: %d\\n&quot;, fdd);    printf(&quot;fde: %d\\n&quot;, fde);&#125;\n\n\n会发现打印的文件是从3开始的。这和我们之前是否有打开过文件没关系，任何进程open的自己的文件都是从3开始的！\n还记得前面C语言部分提到的stdin/stdout/stderr吗？\nlinux系统下一切皆文件，这三个家伙也不例外！既然C语言的文件操作封装了系统的接口，那么其内部肯定是有文件描述符的存在的，我们只需要找到它就行了。\n这一点，代码补全就可以帮忙了\n\nvoid test4()&#123;    //c语言中的FILE是一个结构体，里面管理了linux系统的文件描述符    printf(&quot;stdin %d\\n&quot;,stdin-&gt;_fileno);//  0    printf(&quot;stdout %d\\n&quot;,stdout-&gt;_fileno);// 1    printf(&quot;stderr %d\\n&quot;,stderr-&gt;_fileno);// 2    FILE* f1 = fopen(&quot;test.txt&quot;,&quot;w&quot;);    printf(&quot;f1 %d\\n&quot;,f1-&gt;_fileno);//3&#125;\n\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./teststdin 0stdout 1stderr 2f1 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n打印之后我们发现，其0 1 2就是被C语言的这三个默认打开的文件流占用了，而我们用C语言fopen打开的文件，其文件描述符也是从3开始的！\n\n用文件描述符调用stdin&#x2F;out既然stdout对应的文件描述符是1，那我们可不可以直接调用系统的接口往屏幕上输出东西呢？\nvoid test5()&#123;    char buf[SIZE]=&quot;12345678910\\n&quot;;    write(1,buf,strlen(buf));&#125;\n\n当然是可以的！\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test12345678910[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n同理，我们还可以这样来接收用户输入\nvoid test6()&#123;    char buf[SIZE];    ssize_t s = read(0,buf,sizeof(buf));    if(s&gt;0)    &#123;        buf[s]=&#x27;\\0&#x27;;        printf(&quot;stdin: %s\\n&quot;,buf);    &#125;&#125;\n\n\n运行的时候，程序会挂起等待用户输入，由此可以打印获取输入的结果👇\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ makegcc test.c -o test -std=c99[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testasdfasdfadfadfstdin: asdfasdfadfadf[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n\n3.2 从0开始？数组下标！\n既然stdin/stdout/stderr分别对应的是0/1/2，而我们打开的自己的文件对应的是3开始，有没有可能，这些数字是一个数组的下标呢？\n\n一个进程打开的文件，其数据是在内存中的。操作系统内核肯定需要管理一个进程已经打开的文件！万一有“大聪明”忘记close文件了，而操作系统又没去管理已有文件，其不就会造成内存泄漏吗？\n在操作系统中，有一个struct file，其管理的就是已经打开了的文件\nstruct file&#123;    //包含了文件的内容+属性&#125;\n\n同时，这个文件内核还会被插入到进程的task_struct中，因为一个进程是可以同时打开多个文件的。操作系统在对已打开文件进行管理的同时，还需要对一个进程打开的文件进行管理（知道某个文件是谁打开的）\n\n下载的linux源码中，task_strcut的位置如下\nlinux-2.6.32.12/include/linux/sched.h\n\n\n\n而我们文件描述符，其实就是进程中管理文件的一个数组的下标。\n\nstruct files_struct &#123;  /*   * read mostly part   */\tatomic_t count;\tstruct fdtable *fdt;\tstruct fdtable fdtab;  /*   * written part on a separate cache line in SMP   */\tspinlock_t file_lock ____cacheline_aligned_in_smp;\tint next_fd;\tstruct embedded_fd_set close_on_exec_init;\tstruct embedded_fd_set open_fds_init;\tstruct file * fd_array[NR_OPEN_DEFAULT];//文件数组&#125;;\n\n这样对进程打开的文件的管理，就被转化为了对这个数组的增删查改\n3.3 Linux下一切皆文件最初学习Linux的时候，就提到了Linux下一切皆文件\n现在我们知道了内核中是用file结构体来管理文件的，那么，它是怎么用文件来管理键盘、鼠标、显示器、磁盘、网卡的呢？\n这时候就可以来“浅浅”的看一下源码了！不求看懂代码实现，只求理解理念\n\nstruct file位于include/linux/fs.h中\n\nstruct file &#123;\t/*\t * fu_list becomes invalid after file_free is called and queued via\t * fu_rcuhead for RCU freeing\t */\tunion &#123;\t\tstruct list_head\tfu_list;\t\tstruct rcu_head \tfu_rcuhead;\t&#125; f_u;\tstruct path\t\tf_path;#define f_dentry\tf_path.dentry#define f_vfsmnt\tf_path.mnt\tconst struct file_operations\t*f_op;\tspinlock_t\t\tf_lock;  /* f_ep_links, f_flags, no IRQ */\tatomic_long_t\t\tf_count;\tunsigned int \t\tf_flags;\tfmode_t\t\t\tf_mode;\tloff_t\t\t\tf_pos;\tstruct fown_struct\tf_owner;\tconst struct cred\t*f_cred;\tstruct file_ra_state\tf_ra;\tu64\t\t\tf_version;#ifdef CONFIG_SECURITY\tvoid\t\t\t*f_security;#endif\t/* needed for tty driver, and maybe others */\tvoid\t\t\t*private_data;#ifdef CONFIG_EPOLL\t/* Used by fs/eventpoll.c to link all the hooks to this file */\tstruct list_head\tf_ep_links;#endif /* #ifdef CONFIG_EPOLL */\tstruct address_space\t*f_mapping;#ifdef CONFIG_DEBUG_WRITECOUNT\tunsigned long f_mnt_write_state;#endif&#125;;\n\n其余内容用来干哈子的咱暂且不管，目光聚焦于这一个结构体\nconst struct file_operations\t*f_op;\n\n翻译过来，这个成员的名字为文件操作。再来复习一下const修饰指针的知识点\n\nconst修饰指针有下面两种形式（关键字：const和指针，const常量指针，const指针）\n\n在*之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）\n在*之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）\n\n\n在这个结构体中，就有read/write方法，它们是两个函数指针\nstruct file_operations &#123;\tstruct module *owner;\tloff_t (*llseek) (struct file *, loff_t, int);\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\tssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);\tssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);\tint (*readdir) (struct file *, void *, filldir_t);\tunsigned int (*poll) (struct file *, struct poll_table_struct *);\tint (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\tint (*mmap) (struct file *, struct vm_area_struct *);\tint (*open) (struct inode *, struct file *);\tint (*flush) (struct file *, fl_owner_t id);\tint (*release) (struct inode *, struct file *);\tint (*fsync) (struct file *, struct dentry *, int datasync);\tint (*aio_fsync) (struct kiocb *, int datasync);\tint (*fasync) (int, struct file *, int);\tint (*lock) (struct file *, int, struct file_lock *);\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\tint (*check_flags)(int);\tint (*flock) (struct file *, int, struct file_lock *);\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\tint (*setlease)(struct file *, long, struct file_lock **);&#125;;\n\nlinux操作系统内的文件系统以统一的方式看待所有的设备。\n特定的设备的read/write方法是不一样的，只需要在这些硬件的驱动程序中给操作系统提供读写这个设备的函数实现，操作系统则将函数指针指向对应的函数，便能实现对某一个硬件设备的操作！\n比如调用显示器驱动的write刷新显示器的画面，调用网卡的read/write来下载/上传数据等等！\n\n\n3.4 分配规则分配文件描述符的时候，会从头开始遍历fd_array[]，找到第一个没有被使用的下标，分配给新的文件！\nvoid test7()&#123;    int fda = open(&quot;loga.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdb = open(&quot;logb.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);        printf(&quot;fda: %d\\n&quot;, fda);    printf(&quot;fdb: %d\\n&quot;, fdb);    close(fda);    printf(&quot;\\n&quot;);    int fdc = open(&quot;logc.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fdc: %d\\n&quot;, fdc);&#125;\n\n上述代码中，我们先打开了两个文件，打印可以看到其文件描述符为3/4；关掉第一个文件后，再打开一个新的文件，会发现文件描述符还是3（第一个为空的文件描述符）\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testfda: 3fdb: 4fdc: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n输出重定向同理，如果我们在打开文件之前，就关闭掉C语言打开的stdout，那么此时打开文件的fd就为1，我们的printf则会把数据打印到该文件当中！\nvoid test8()&#123;    //文件描述符分配的时候，会在数组里面找第一个为空的描述符    printf(&quot;start test!\\n&quot;);//打印到屏幕上    close(1);//关闭stdout    int fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fd: %d\\n&quot;,fd);//打印到文件中    close(fd);&#125;\n\n可以看到，运行./test之前，文件里面没有内容。执行之后，就把我们printf的数据输出到文件当中了！\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./teststart test![muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtfd: 1[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n这种操作就叫做输出重定向！\n另外一种情况下，如果我们在关闭stdout之前不进行printf，则不会立马刷新到log.txt而是需要我们刷新了缓冲区之后，才会写入到文件中\nclose(1);//关闭stdoutint fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);printf(&quot;fd: %d\\n&quot;,fd);fflush(stdout);close(fd);\n\n这里有个小技巧&gt;log.txt可以用来清空文件的内容\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ &gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$\n\n\n3.5 dup2上面是我们手动进行的输出重定向操作。操作系统提供了一个接口，可以让我们很方便地进行输出重定向\nint dup2(int oldfd, int newfd);\n\n\n这里我们要用的是dup2函数，它的作用如下\ndup2() makes newfd be the copy of oldfd, closing newfd first if necessary, but note the following:*  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.*  If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.\n\n一定要看清楚，是将newfd变成oldfd的一个拷贝，在执行完毕之后，就只剩oldfd了！\n如果newfd原本已经打开了一个文件，该操作会先将newfd给关掉\nRETURN VALUEOn success, these system calls return the new descriptor.  On error, -1 is returned, and errno is set appropriately.\n\n该函数成功的时候会返回newfd，否则返回-1\n\n下面为一个示例代码，假设我们想将输出的内容重定向到一个文件中，则可以使用dup2将1替换为我们自己的fd，此时oldfd=fd,newfd=1\nvoid test9()&#123;    int fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    dup2(fd, 1);    int ret = dup2(fd, 1);    if(ret &gt; 0)         close(fd);    printf(&quot;ret: %d\\n&quot;, ret);//ret为newfd    //本来往显示器打印，最终变成向指定文件打印 -&gt; 重定向    fprintf(stdout, &quot;打开文件成功，fd: %d\\n&quot;, fd);    fflush(stdout);//刷新缓冲区    close(fd);&#125;\n\n结果如下，我们成功的将内容printf到了指定文件中\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ &gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n\n为什么这里可以用stdout来输出到文件中呢？\n\n因为当我们使用dup2的时候，stdout所指向的文件描述符1已经被替换成了log.txt，此时对stdout的操作就是对我们自己的文件操作\n\n为什么这里我们已经把fd关掉了，但是替换掉的文件描述符1不受影响呢？\n\n同一个文件是可以被打开多次的！执行dup2的时候，可以理解为操作系统又一次打开了fd指向的文件，在文件底层，则有一个计数来判断该文件被打开了几次。当我们close(fd)的时候，只是让该文件底层struct file的打开计数-1，并非完全关闭了该文件！此时1还能正确指向log.txt呢\n追加重定向这里只需要我们改变fd打开的方式，加上O_APPEND即可！\nvoid test9()&#123;    int fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_APPEND, 0666);    dup2(fd, 1);    int ret = dup2(fd, 1);//    if(ret &gt; 0)         close(fd);    printf(&quot;ret: %d\\n&quot;, ret);//ret为newfd    //本来往显示器打印，最终变成向指定文件打印 -&gt; 重定向    fprintf(stdout, &quot;打开文件成功，fd: %d\\n&quot;, fd);    fflush(stdout);//刷新缓冲区    close(fd);&#125;\n\n运行可以看到，成功在后面追加\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3ret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n输入重定向//输入重定向void test11()&#123;    int fd = open(&quot;log.txt&quot;,O_RDONLY);    if(fd&lt;0)    &#123;        perror(&quot;open&quot;);        return ;    &#125;    int ret = dup2(fd,0);//重定向stdin    if(ret &gt; 0)         close(fd);    char buf[128];    while(fgets(buf,sizeof(buf),stdin)!=NULL)    &#123;        printf(&quot;%s&quot;,buf);    &#125;&#125;\n\n此时我们的stdin被dup2替换成了log.txt，其获取输入的操作转为了读取文件\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3ret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testret: 1打开文件成功，fd: 3ret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n3.6 标准输出&#x2F;标准错误之前写代码的时候，我们常常直接使用了printf来打印一些错误信息，而没有怎么用过perror/cerr这两个库函数\n那么它们和printf/cout又有什么区别呢？\nint main()&#123;    // stdout    printf(&quot;hello printf\\n&quot;);    fprintf(stdout, &quot;hello fprintf to stdout\\n&quot;);    fputs(&quot;hello fputs to stdout\\n&quot;, stdout);    cout &lt;&lt; &quot;hello cout&quot; &lt;&lt; endl;    // stderr    perror(&quot;hello perror&quot;);    fprintf(stderr, &quot;hello fprintf to stderr\\n&quot;);    fputs(&quot;hello fputs to stderr\\n&quot;, stderr);    cerr &lt;&lt; &quot;hello cerr&quot; &lt;&lt; endl;    return 0;&#125;\n\n测试发现，似乎没有啥区别啊，不都打印到屏幕上了吗？\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./testhello printfhello fprintf to stdouthello fputs to stdouthello couthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n非也！当我们使用重定向的时候，就出现问题了\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &gt;log.txthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello printfhello fprintf to stdouthello fputs to stdouthello cout[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n欸？不是使用了重定向吗，为什么还在屏幕上输出了内容呢？\n仔细一看，输出的都是stderr的内容，而没有stdout。cat文件一看，stdout的内容都在文件里面嘞！\n还记得吗？stdout/stderr对应的文件描述符是1/2，而在默认情况下，它们都指向的是显示器。\n\n注意：虽然它们两个指向都是显示器，但它们是通过两个不同的文件描述符，独立地往显示器上打印内容的！\n\n我们重定向的时候，其实省略了一个1，默认情况下，重定向只对1号描述符，也就是stdout有效！\n./test &gt;log.txt./test 1&gt;log.txt\n\n如果我们把这里的1换成2，结果就不一样了\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test 2&gt;log.txthello printfhello fprintf to stdouthello fputs to stdouthello cout[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n可以看到，stderr的内容进了文件，而stdout的内容输出到了屏幕上\n区分错误和正常输出这么设计的意义，就是为了方便我们定位问题。将错误和正常的打印输出写道不同的文件中。如果我们像只关注错误，就只需要去查找记录了错误信息的文件即可\n混合输出2&gt;&amp;1如果我们就是不听不听，非要把他俩打一个文件里面，应该怎么弄呢？\n./test &gt;log.txt 2&gt;&amp;1\n\n这个2&gt;&amp;1的操作需要我们理解：\n\n./test运行可执行程序\n&gt;log.txt代表重定向，默认只重定向了1\n现在指向log.txt的是1号文件描述符，代表stdout\n2&gt;&amp;1代表将2重定向到1，可以理解为dup2(1,2);\n执行结束后，2就成了1的一份拷贝，现在只剩下了1\n因为1指向的是log.txt，所以2也指向的是相同文件\n\n而这个语句必须写在&gt;log.txt的后面， 否则意义就错误了👇\n./test 2&gt;&amp;1 &gt;log.txt #错误写法\n\n\n2&gt;&amp;1代表将2重定向到1，此时1指向的是屏幕，所以2也指向了屏幕\n&gt;log.txt代表将1指向文件，此时1指向了文件，但是2还是指向屏幕\n白写！\n\n执行了正确的命令后，来看看结果吧！\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &gt;log.txt 2&gt;&amp;1[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello printfhello fprintf to stdouthello fputs to stdouthello couthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n标准错误和标准输出的内容都被写入到文件中了！\n上面的整法实在有点太长了，而且还有可能记不住写反了。所以有一种简写的方式\n#简写方式&amp;&gt;log.txt#上面的写法等同于&gt;log.txt 2&gt;&amp;1\n\n测试一下，没问题！\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ &gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &amp;&gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello printfhello fprintf to stdouthello fputs to stdouthello couthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n\n关于2&gt;&amp;1的详解参考👉 传送门\n\n\n4.C语言缓冲区4.1 观察现象先来看看下面的代码，分别调用C语言的printf和操作系统的write接口，往屏幕上打印内容。结束后sleep(3)\nvoid test1()&#123;    printf(&quot;test printf &quot;);    const char*msg = &quot;test write &quot;;    write(stdout-&gt;_fileno,msg,strlen(msg));    sleep(3);&#125;\n\n\n我们惊奇的发现，第一个打印出来的竟然是write，而不是在它之前的printf接口！\nvoid test1()&#123;    printf(&quot;test printf &quot;);    fflush(stdout);    const char*msg = &quot;test write &quot;;    write(stdout-&gt;_fileno,msg,strlen(msg));        sleep(3);&#125;\n\n只有在printf后立马调用fflush刷新缓冲区，才能按正确的“顺序”打印出内容来\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest printf test write [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n在调用其他C语言的函数，往屏幕上输出信息。我们会发现结果相同！都是先打印出来write结果，才一次性打印出所有C语言函数的结果\nvoid test2()&#123;    printf(&quot;test printf &quot;);    fprintf(stdout,&quot;test fprintf &quot;);    fputs(&quot;test fputs &quot;,stdout);    const char*msg = &quot;test write &quot;;    write(stdout-&gt;_fileno,msg,strlen(msg));        sleep(3);&#125;\n\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest write test printf test fprintf test fputs [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n由此可见，之前我们一直提到的缓冲区，其实是C语言提供的！\n\n注意：缓冲区不止C语言内部有，操作系统内也有。本文只讨论C语言提供的缓冲区\n\n\n4.2 缓冲区在哪?printf(&quot;test printf &quot;);fprintf(stdout,&quot;test fprintf &quot;);fputs(&quot;test fputs &quot;,stdout);\n\n上面这几个函数都有一个共同的特点：它们都往stdout里面打印了内容！\n\nprintf虽然没有显示指定stdout，但是底层是有的\n\n我们知道，C语言的文件是一个FILE类型的结构体。该结构体内封装了很多属性，其中stdout的_fileno文件描述符，就是该FILE对应的语言级别的缓冲区！\n关闭文件描述符如果我们在数据刷新之前，关闭了stdout对应的文件描述符，会发生什么？\nprintf(&quot;test printf &quot;);fprintf(stdout,&quot;test fprintf &quot;);fputs(&quot;test fputs &quot;,stdout);const char*msg = &quot;test write &quot;;write(stdout-&gt;_fileno,msg,strlen(msg));sleep(3);close(stdout-&gt;_fileno);\n\n结果就是，啥都没有刷新！\n缓冲区都被关闭了，其内部的数据都无了，肯定不会刷新啦~\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest write [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n而在输出重定向中，打印的内容没有直接被显示的，也是因为我们没有在关闭fd之前刷新stdout（此时指向的是fd）中的缓冲区\nclose(1);//关闭stdoutint fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);printf(&quot;fd: %d\\n&quot;,fd);fflush(stdout);close(fd);\n\nFILE既然stdout的缓冲区在FILE内部，推而广之，所有用C语言打开的文件，FILE中都会有一个文件描述符和它自己的语言级别缓冲区\ntypedef struct _IO_FILE FILE;\n\n库函数中的FILE是一个struct _IO_FILE类型的结构体，其定义如下\nstruct _IO_FILE &#123;  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  //下面这些就是它的缓冲区  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;\t/* Current read pointer */  char* _IO_read_end;\t/* End of get area. */  char* _IO_read_base;\t/* Start of putback+get area. */  char* _IO_write_base;\t/* Start of put area. */  char* _IO_write_ptr;\t/* Current put pointer. */  char* _IO_write_end;\t/* End of put area. */  char* _IO_buf_base;\t/* Start of reserve area. */  char* _IO_buf_end;\t/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;//文件描述符#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;\n\n我们可以看到有多个变量用于维护该文件的缓冲区，也证实了缓冲区是由C语言提供的这一结论。\n4.3 缓冲区的作用C语言提供缓冲区的理由很简单，相对于内存而言，其余硬件都是满设备。\n\n为代码提供缓冲区，可以提高该程序&#x2F;进程输出的效率\n缓冲区可以集中处理数据刷新，减少IO的次数，提高了整机运行效率\n\n4.4 什么时候刷新缓冲区？什么时候刷新缓冲区，对应的是刷新策略问题\n常规的刷新策略\n\n无缓冲（立即刷新）\n行缓冲（逐行刷新）\n全缓冲（缓存区满，刷新）\n\n特殊情况\n\n进程退出（刷新）\n用户调用函数，强制刷新\n\n刷新与子进程void test3()&#123;    const char*str1=&quot;test printf\\n&quot;;    const char*str2=&quot;test fprintf\\n&quot;;    const char*str3=&quot;test fputs\\n&quot;;    const char*str4=&quot;test write\\n&quot;;    //C语言    printf(str1);//这样写也是ok的    fprintf(stdout,str2);    fputs(str3,stdout);    //系统接口    write(stdout-&gt;_fileno,str4,strlen(str4));    //子进程创建    fork();&#125;\n\n上面的代码，会出现两种运行情况\n\n如果直接打印到屏幕上，打印的顺序和内容都是正确的\n如果重定向到文件中，却发现C语言打印的内容都多打了一次！\n\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest printftest fprintftest fputstest write[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test &gt; log.txt[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txttest writetest printftest fprintftest fputstest printftest fprintftest fputs[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n刷新的本质，其实就是把缓冲区中数据，调用write接口通过操作系统写入到文件中。而FILE内部的缓冲区，是属于父进程内部的数据。\n当我们在刷新之前fork创建子进程的时候，会发生一次写时拷贝\n结果就是父进程、子进程各刷新一次。于是就出现了上面的C语言的内容多了一份的现象！\n\n4.5 简单模拟实现缓冲区，本质就是C语言在文件的结构体中维护的一个数组。同时维护了多种刷新策略，在不同的时刻将该数组的内容调用系统接口write写入文件\n这里我们提供了一个简单的MyFILE结构体，内部封装文件描述符、刷新策略、缓冲区\n#define NONE_FLUSH 0x0 //无刷#define LINE_FLUSH 0x1 //行刷#define FULL_FLUSH 0x2 //全缓存typedef struct MyFILE&#123;    int _fileno;    char _buffer[NUM];    int _end;//缓冲区结尾    int _fflags; //刷新策略&#125;MyFILE;\n\n有了自己的文件结构体，对应的也需要分装一下系统的open/read/write/close等接口，还有fflush用于强制刷新\n\n封装接口为了做到尽量简单，这里暂时只封装r/w/a三种打开方法\nMyFILE *my_fopen(const char *filename, const char *method)&#123;    assert(filename);    assert(method);    int flags = O_RDONLY;    if(strcmp(method, &quot;r&quot;) == 0)    &#123;        flags = O_RDONLY;    &#125;    else if(strcmp(method, &quot;w&quot;) == 0)    &#123;        flags = O_WRONLY | O_CREAT | O_TRUNC;    &#125;    else if(strcmp(method, &quot;a&quot;) == 0)    &#123;        flags = O_WRONLY | O_CREAT | O_APPEND;    &#125;    int fileno = open(filename, flags, 0666);    if(fileno &lt; 0)    &#123;        return NULL;    &#125;    MyFILE *fp = (MyFILE *)malloc(sizeof(MyFILE));    if(fp == NULL) return fp;    memset(fp, 0, sizeof(MyFILE));    fp-&gt;_fileno = fileno;    fp-&gt;_fflags |= LINE_FLUSH;//默认行缓冲    fp-&gt;_end = 0;    return fp;&#125;\n\n这里暂时只用行缓冲和全缓冲来体验一下缓冲区的作用。同时只对字符串结尾的\\n进行了判断，情况不够全面。\n\n这里其实我很好奇，C库里面是怎么处理\\n的捏；总不能用遍历吧？那样效率也太低了。个人猜测是和预先设置的特殊字符有关系。\n\nvoid my_fwrite(MyFILE *fp, const char *start, int len)&#123;    assert(fp);    assert(start);    assert(len &gt; 0);    //先写入到缓冲区里面    strncpy(fp-&gt;_buffer+fp-&gt;_end, start, len); //将数据写入到缓冲区了    fp-&gt;_end += len;    if(fp-&gt;_fflags &amp; NONE_FLUSH)    &#123;&#125;    else if(fp-&gt;_fflags &amp; LINE_FLUSH)    &#123;        //这里的判断只是测试，实际上还需要判断中间有无\\n        if(fp-&gt;_end &gt; 0 &amp;&amp; fp-&gt;_buffer[fp-&gt;_end-1] == &#x27;\\n&#x27;)        &#123;            //写入到内核中            write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);            fp-&gt;_end = 0;            syncfs(fp-&gt;_fileno);        &#125;    &#125;    else if(fp-&gt;_fflags &amp; FULL_FLUSH)    &#123;//满了刷新        if(fp-&gt;_end &gt; 0 &amp;&amp; fp-&gt;_end==NUM)        &#123;            //写入到内核中            write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);            fp-&gt;_end = 0;            syncfs(fp-&gt;_fileno);        &#125;    &#125;&#125;\n\n这里有一个新接触的函数syncfs\nint syncfs(int fd);\n\n该函数是一个系统调用接口，用于将文件内核缓冲区内的数据写入到指定文件中。\n前面我们提到的缓冲区，一直说的都是C语言内部维护的。从这个接口也能看出，操作系统同样对文件进行了缓冲区的维护。\n\nvoid my_fflush(MyFILE *fp)&#123;    assert(fp);    if(fp-&gt;_end &gt; 0)    &#123;        write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);        fp-&gt;_end = 0;        syncfs(fp-&gt;_fileno);    &#125;&#125;void my_fclose(MyFILE *fp)&#123;    my_fflush(fp);    close(fp-&gt;_fileno);    free(fp);&#125;\n\n运行测试int main()&#123;    MyFILE *fp = my_fopen(&quot;log.txt&quot;, &quot;w&quot;);    if(fp == NULL)    &#123;        printf(&quot;my_fopen error\\n&quot;);        return 1;    &#125;        const char *a = &quot;hello my 111\\n&quot;;    my_fwrite(fp, a, strlen(a));    printf(&quot;消息立即刷新\\n&quot;);    sleep(3);    const char *b = &quot;hello my 222 &quot;;    my_fwrite(fp, b, strlen(b));    printf(&quot;写入了一个不满足刷新条件的字符串\\n&quot;);    sleep(3);    const char *c = &quot;hello my 333 &quot;;    my_fwrite(fp, c, strlen(c));    printf(&quot;写入了一个不满足刷新条件的字符串\\n&quot;);    sleep(3);    const char *d = &quot;end\\n&quot;;    my_fwrite(fp, d, strlen(d));    printf(&quot;写入了一个满足刷新条件的字符串\\n&quot;);    sleep(3);    my_fclose(fp);    printf(&quot;程序结束\\n&quot;);&#125;\n\n刚开始的时候，我们写入了一个\\n结尾的字符串，其立马写入到了文件中\n\n随后写入了两个不满足刷新条件的字符串，文件中没有出现结果\n\n\n而当我们写入一个满足刷新条件的字符串后，缓冲区的内容就同时被写入到文件中了！\n\n子进程测试除此之外，我们还可以测试一下子进程是否会出现刷新两次的情况\nvoid test2(MyFILE * fp)&#123;    const char *s = &quot;-test &quot;;    my_fwrite(fp, s, strlen(s));    printf(&quot;写入了一个不满足刷新条件的字符串\\n&quot;);    fork();&#125;int main()&#123;    MyFILE *fp = my_fopen(&quot;log.txt&quot;, &quot;w&quot;);    if(fp == NULL)    &#123;        printf(&quot;my_fopen error\\n&quot;);        return 1;    &#125;    //test1(fp);    test2(fp);    //模拟进程退出    my_fclose(fp);    printf(&quot;程序结束\\n&quot;);&#125;\n\n结果如我们所料，文件中出现了两个-test  ，原因在4.4中已做解释\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test1写入了一个不满足刷新条件的字符串程序结束程序结束[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txt-test -test [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n\n5.文件系统之前我们提到的这些数据，都是存放在内存中的。接下来我们便要来了解一下操作系统是如何管理磁盘上的文件。\n\n5.1 磁盘的物理结构以机械硬盘为例，其内部主要由盘片和磁头组成。\n\n当我们改变磁盘上某一个位置的NS极，就好比更改了此处保存的数据0/1\n\n在机械硬盘中，一个盘片对应一个磁头\n\n每个盘片被分为诺干个同心圆，每一个同心圆就是一个磁道\n每个磁道被划分为诺干段（扇区）\n每个扇区的存储容量为512字节\n\n由此可见，当我们读写机械硬盘的时候，需要去找某一个盘面、某一个磁道的某一片扇区，就能找到该扇区的数据！\n\n盘面（磁面）有自己对应的磁头\n磁道是由距离圆心的半径决定的\n扇区是由盘面旋转决定的\n\n而操作系统的文件系统所作的工作，便是将文件和其对应的扇区联系起来。用上面提到的办法，便可以查找到每一个扇区！\n\n这种查找数据位置的操作，被称为CHS寻址，CHS分别对应磁柱、磁面、扇区\n5.2 CHS和LBA\n更详细的解析参考：https://blog.csdn.net/jadeshu/article/details/89072512\n\n假设我们把一个磁道的数据“拉直”，其就变成了一条直线。依此类推，可以把每一个盘面上的每一条磁道都“拉直”\n\n最终，其不就变成了和上图类似的“长条状”了吗？我们学过的什么数据结构也是线性长条的捏？\n没错！就是数组！\n此时，对磁盘文件的修改，就可以抽象成对内核中一个数组的增删查改操作！\n这种抽象之后的磁盘，被称为LBA逻辑块地址，他们之中有一个转换关系👇\n用C表示当前柱面号，H表示当前磁头号，S表示当前扇区号，CS表示起始柱面号，HS表示起始磁头号，SS表示起始扇区号，PS表示每磁道有多少个扇区，PH表示每柱面有多少个磁道，计算公式如下：$$LBA &#x3D; ( C – CS ) * PH * PS + ( H – HS ) * PS + ( S – SS )$$通过这个公式，我们就能将磁盘中的一个区块的数据，转为数组中的一个下标，来方便操作系统访问$$C &#x3D; LBA &#x2F; ( PH * PS ) + CS$$\n$$H &#x3D; ( LBA &#x2F; PS ) % PH + HS$$\n$$S &#x3D; LBA &#x2F; PS + SS$$修改了数组中的数据之后，操作系统将LBA对应的CHS地址算出来交给磁盘，让磁盘来修改指定扇区的数据，便实现了保存数据到磁盘中的操作\n\n5.3 IO的基本单位对于操作系统而言，一次IO的基本单位是4kb，也就是8个扇区8*512字节\n\n磁盘的基本单位：扇区（一般为512字节)\n文件系统访问磁盘的基本单位：4kb\n\n在操作系统中，会对前面提到的那个“数组”进一步抽象，8个扇区会被合并成一个4KB的区块，用于单次IO。为了方便管理每一个区块，又将多个区块合并，作为一个分区进行管理\n这便是我们电脑上同一块物理硬盘可以对应不同分区的来源了！\n\n为什么？为什么操作系统要以4kb作为IO的基本单位呢？\n\nhttps://www.51cto.com/article/617936.html\n\n在上文中提到，Linux选择4KB作为“页操作”（即读取内存，以及从内存写入磁盘）的基本单位算是一个历史遗留问题了。\n\n过小的页大小会带来较大的寻址开销\n过大的页大小浪费内存空间，造成内存碎片\n\n而当初这么选择，肯定是有其功用的！\n\n能提高IO效率，不需要多次写入512字节的数据\n不让文件系统的设计和磁盘有强相关性，解耦合\n\n对于第二点进行说明，如果文件系统不在扇区外额外选择一个空间作为IO的基本单位，那么其设计必定会依赖于磁盘扇区大小。\n如果某一天，所有磁盘的扇区大小都从512字节变成了1024字节，那就必须要修改操作系统的源码，才能正确访问新的硬盘。同时还需要对旧盘做优化，可谓事倍功半。\n而提前设定好一个更大的IO基本单位，便是避免了磁盘变动而造成的无法访问。有了这个更大的IO基本单位，我们只需要把磁盘的扇区组成一个4kb大小的空间进行IO，不用管其磁盘扇区大小到底是多少了。\n\n当然，如果哪天扇区大小大于4kb了，恐怕就得改源码了？\n这部分我也不是很懂呢，以上只是个人浅显的理解\n\n\n5.4 系统结构下图向我们展示了一个磁盘是如何被文件系统“拆分”的\n首先是分区，每一个分区都有一个BootSector和文件系统。我们主要关注文件系统中，单个Block Group里面的内容\n\nlinux采用的是文件内容、文件属性分开存放的存储方式\n\n文件的属性是稳定的\n文件的内容在不断增多\n\ndata blocks：保存数据内容inode table：保存文件的inodeinode bitmap：位图结构，指示inode是否被使用GDT：全称group descriptor table，保存了inode个数、起始inode编号、多少inode被使用、多少data blocks被使用……Super Blocks：该Block Group文件系统的顶层数据结构\n\ninode这里提到的inode是linux下每一个文件的独立编号。linux并不以文件名来识别文件，而是用文件编号来识别唯一的文件的。\ninode保存了一个文件的基本信息\n\n文件的属性\nrwx权限\n所属用户、所属组\n硬链接个数\n文件访问、修改、创建的时间\n指向data blocks中文件的内容\n\n\nstruct inode的位置在/include/linux/fs.h\n\n\n查看inode编号的方法为ls -i，其中这串数字便是该文件的inode编号\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -i1453833 makefile  1453832 test.cpp\n\n我们也可以看到，.和..这两个文件夹也是有自己的inode编号的，印证了linux下一切皆文件，包括目录\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -ilatotal 161453831 drwxrwxr-x  2 muxue muxue 4096 Nov  2 09:58 .1443736 drwxrwxr-x 16 muxue muxue 4096 Nov  2 09:20 ..1453833 -rw-rw-r--  1 muxue muxue   81 Nov  2 09:58 makefile1453832 -rw-rw-r--  1 muxue muxue  437 Nov  2 09:35 test.cpp\n\nstat命令还可以用stat命令来查看单个文件的inode信息\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ stat test.cpp  File: ‘test.cpp’  Size: 437             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1453832     Links: 1Access: (0664/-rw-rw-r--)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-11-02 09:35:07.684160444 +0800Modify: 2022-11-02 09:35:04.328161202 +0800Change: 2022-11-02 09:35:04.328161202 +0800 Birth: -\n\ninode内部有一个结构，指向data blocks。前面提到过，文件系统IO的基本单位是4KB，对应的，一个blocks的大小就是4KB\n每一个文件都对应一个inode，至少对应一个data blocks（inode中储存了blocks编号）\n因为inode所能保存的编号有限，所以对data blocks的保存分为两种情况\n\n部分data blocks直接保存了文件的内容。如果是小文件，inode中保存的block就足够存下所有文件内容了\n如果是大文件，inode中一部分blocks会用来保存该文件剩余data blocks的编号\n\n在内核中，文件系统会对这两种情况进行区分\n注意\n\n因为每一个文件都肯定有一个inode与之对应，所以创建空文件也是占用磁盘空间的\n可能会出现inode被用完了，磁盘空间却没有满的情况。但这时候也已经无法创建新文件了\n\n😂你可以尝试写一个while1循环，不断往系统中创建新文件，看看能不能达到这个临界值（咳咳，虽然好玩，但并不推荐你这么做）\n\n文件名存在哪儿？前面提到过，inode保存了文件的属性，文件名是否为文件的属性呢？也算！\n但inode中并不保存文件名字！\n实际上，文件名是存在该文件所在目录的文件内容中的\n\n目录也是文件，文件就有文件属性+文件内容\n\n可以理解为，目录的内容保存的是一个键值对，其中key为文件名，value为inode编号\n这便是为何一个目录中不能出现同名文件，这是一个不支持键值冗余的map(cpp-stl)\n目录权限既然目录也是文件，那么它就也有自己的文件权限\n\nhttps://blog.csdn.net/muxuen/article/details/125776348\n\n在我之前关于linux文件权限的讲解中，就提到了和目录有关的权限问题\n\n进入目录需要x权限\n创建文件需要w权限\n查看文件名需要r权限\n\n了解文件系统了之后，现在我们知道为什么目录的操作需要这些权限了。在目录下创建文件，本质就是在修改目录所对应的文件内容！\n\n5.5 创建&#x2F;删除文件当我们创建一个文件的时候，文件系统做了什么捏？\n\n创建一个新的文件结构体，和对应的inode编号\n根据目录的inode，找到该目录的data blocks\n将文件名和inode编号的对应关系写入到目录的数据块中\n\n当我们删除一个文件的时候：\n\n操作系统只需要删除当前目录下inode和文件名的对应关系\n同时在inode bitmap中将对应的inode置为0（代表没有使用）\n\n这样就算是删除该文件了！好比我们操作线性表进行尾删操作，只是对size-1，并没有真的把该位置的数据删除\n\n这便能解释为什么复制粘贴一个文件的速度远慢于删除文件的速度\n因为没有将文件的inode和data block清空，所以给我们恢复数据带来了可能。只要该文件之前使用的inode/data block并没有被复写，我们就有可能还原出该文件的数据！\n\n\n6.软硬链接在最初学习linux命令行的时候，就已经学习过了ln创建文件链接的操作\n\n 这部分我没有写博客，因为网上的教程实在是太多啦\n\n但是当时并不知道软链接/硬链接到底有什么区别，学习了文件系统之后，回头再来看看\n\n6.1 查看文件硬链接个数ls -li\n\n当我们执行上面这个命令的时候，可以看到每一个文件的完整属性\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -liatotal 161453831 drwxrwxr-x  2 muxue muxue 4096 Nov  2 09:58 .1443736 drwxrwxr-x 16 muxue muxue 4096 Nov  2 09:20 ..1453833 -rw-rw-r--  1 muxue muxue   81 Nov  2 09:58 makefile1453832 -rw-rw-r--  1 muxue muxue  437 Nov  2 09:35 test.cpp\n\n可之前一直没有去了解，这个第三列的2  16   1  1 到底是什么玩意呢？\n不卖关子，前面提到inode会保存文件的硬链接个数，第三列的数字，代表的便是该文件的硬链接个数！\n这里我们创建一个新的文件夹，和一个新的文件\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ mkdir test_r[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ touch test_f[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -litotal 121453833 -rw-rw-r-- 1 muxue muxue   81 Nov  2 09:58 makefile1453832 -rw-rw-r-- 1 muxue muxue  437 Nov  2 09:35 test.cpp1453836 -rw-rw-r-- 1 muxue muxue    0 Nov  2 16:07 test_f1449813 drwxrwxr-x 2 muxue muxue 4096 Nov  2 16:07 test_r[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n你会发现，文件夹默认的硬链接数是2，而文件默认的硬链接数是1\n为什么？当我们cd进入目录的时候，linux便会找到底层的inode，进入该inode所对应的文件中。\n如果想知道一个目录的目录名，我们必须要去该目录的上级找。\n为了方便查找当前目录以及其上级目录的inode，每一个目录下面，默认都会有..和.这两个目录文件！\n进入刚刚我们新创的文件夹看看，你会发现，.文件的inode就是该文件夹的inode！\n\n从这里便引出了软连接和硬链接的区别\n6.2 软硬链接区别这里我创建了一个新文件夹，在里面创建了一个test.c文件\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -litotal 41453842 -rw-rw-r-- 1 muxue muxue 78 Nov  2 16:13 test.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ \n\n同时对该文件夹创建一个硬链接和软连接\nln -s 源 目标 #创建软连接ln 源 目标 #创建硬链接\n\n康康结果👇\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ln -s test.c testSoft.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -litotal 41453842 -rw-rw-r-- 1 muxue muxue 78 Nov  2 16:13 test.c1453843 lrwxrwxrwx 1 muxue muxue  6 Nov  2 16:14 testSoft.c -&gt; test.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ln test.c testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -litotal 81453842 -rw-rw-r-- 2 muxue muxue 78 Nov  2 16:13 test.c1453842 -rw-rw-r-- 2 muxue muxue 78 Nov  2 16:13 testHard.c1453843 lrwxrwxrwx 1 muxue muxue  6 Nov  2 16:14 testSoft.c -&gt; test.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ \n\n你能看出区别吗？\n\n软链接的inode和源文件不相同，是一个全新的文件\n硬链接的inode和源文件相同！同时它们的硬链接数+1\n\n把这些文件都以指针理解，会更方便一些\n\n\n软连接的文件内容是所指向文件的路径\n硬链接只是在当前目录下新增文件名和inode编号的映射关系，并对inode中硬链接个数+1\n\n如果我们删除了test.c，软连接就会失效，但硬链接并不会，因为硬链接本身和test.c是一个东西！\n\n而inode中对硬链接的计数，就好比C++中智能指针的引用计数，如果该计数为0，就代表这个文件需要删除了！\n\n解答！知道了区别，我们也便知道为何一个新目录的默认硬链接个数是2了，其便是每一个目录都默认带的.文件，用于标识当前目录的inode；另外一个是该文件本身\n\n每一个新创建的文件，默认都和自己映射，所以硬链接个数为1\n\n同时，我们也可以通过..文件的硬链接个数，快速知道上级目录中有多少个文件夹（除去默认的.和..）\n上级目录内的文件夹个数 = 当前目录..文件的硬链接个数 - 2某一个目录内的文件夹个数 = 该目录..文件的硬链接个数 - 2\n\n6.3 unlink命令我们可以通过unlink命令来取消链接\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ lstestHard.c  testSoft.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ unlink testSoft.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -liatotal 121453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:39 .1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..1453842 -rw-rw-r--  1 muxue muxue   78 Nov  2 16:13 testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ \n\nunlink也可以用来删除正常文件，但一般只用它来删除链接文件！\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -liatotal 121453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:39 .1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..1453842 -rw-rw-r--  1 muxue muxue   78 Nov  2 16:13 testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ unlink testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -liatotal 81453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:40 .1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..\n\n\n结语linux文件系统的内容，到这里就over辣！后续如果有什么新增知识，会来这里添加！\n\n感谢你看到最后，如果有什么问题，可以在评论区提出哦\n","categories":["玩上Linux"],"tags":["Linux","文件"]},{"title":"【Linux】动静态库","url":"/posts/2737580475/","content":"在最初学习GCC的使用的时候，提到了动态、静态库的创建办法。今天就让我们来详细了解一番，它们之间究竟有何不同吧！\n\n\n\n演示所用系统：centos7.6\n\n[TOC]\n1.动态库和静态库先来了解一下动态库和静态库的基本概念吧！\n\n静态库.a 程序编译链接的时候，把静态库的代码连接到自己的可执行程序中，程序运行的时候将不再需要静态库\n动态库.so 程序在运行的时候才去链接动态库的代码，多个程序共享库的代码\n\n2.生成\n测试所用代码 👉 点我\n\n我写好了两个头文件和两个源文件，为了减少博客篇幅，此处只贴出.c的函数实现\n//myMath.c#include&quot;myMath.h&quot;int Add(int a,int b)&#123;    return a+b;&#125;//myPrint.c#include &quot;myPrint.h&quot;void Print(const char* msg)&#123;    printf(&quot;time: %d, msg: %s\\n&quot;,(unsigned int)time(NULL),msg);&#125;\n\n2.1 静态库生成静态库所用命令为ar -rc，对应的完整make操作如下\nlibMytest.a:myMath.o myPrint.o\tar -rc libMytest.a myMath.o myPrint.omyMath.o:myMath.c\tgcc -c myMath.c -o myMath.omyPrint.o:myPrint.c\tgcc -c myPrint.c -o myPrint.o\n\n生成好静态库后，我们可以用 ar -tv命令来查看该库的目录列表\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ ar -tv libmytest.arw-rw-r-- 1001/1001   1240 Nov  3 09:28 2022 myMath.orw-rw-r-- 1001/1001   1632 Nov  3 09:28 2022 myPrint.o[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ \n\n2.2 动态库动态库的生成无需额外的命令，只需要在gcc编译的时候，指定-shared即可\n同时，依赖的.o文件也需要用-fPIC来编译\n-fPIC 与位置无关码，和动态库的特性有关-shared 代表需要编译一个动态库\n\n其make操作如下\nlibmytest.so:myMath.o myPrint.o\tgcc -shared -o libmytest.so myMath.o myPrint.omyMath.o:myMath.c\tgcc -fPIC -c myMath.c -o myMath.omyPrint.o:myPrint.c\tgcc -fPIC -c myPrint.c -o myPrint.o\n\n2.3 一并发布这里我写了一个更加完整的makefile，可以同时编译生成动静态库，并将其打包到一个指定的文件夹内\n.PHONY:allall:libmytest.so libmytest.a.PHONY:liblib:\tmkdir -p lib-static/lib\tmkdir -p lib-static/include\tcp *.a lib-static/lib\tcp *.h lib-static/include\tmkdir -p lib-dynamic/lib\tmkdir -p lib-dynamic/include\tcp *.so lib-dynamic/lib\tcp *.h lib-dynamic/includelibmytest.so:myMath.o myPrint.o\tgcc -shared -o libmytest.so myMath.o myPrint.omyMath.o:myMath.c\tgcc -fPIC -c myMath.c -o myMath.omyPrint.o:myPrint.c\tgcc -fPIC -c myPrint.c -o myPrint.olibmytest.a:myMath.o myPrint.o\tar -rc libmytest.a myMath.o myPrint.omyMath_s.o:myMath.c\tgcc -c myMath.c -o myMath_s.omyPrint_s.o:myPrint.c\tgcc -c myPrint.c -o myPrint_s.o.PHONY:cleanclean:\trm -rf *.o *.a *.so lib-static lib-dynamic\n\n3.使用#include &quot;myPrint.h&quot;#include &quot;myMath.h&quot;#include &quot;stdio.h&quot;int main()&#123;    printf(&quot;ret %d\\n&quot;,Add(1,2));    Print(&quot;这是一个测试&quot;);    return 0;&#125;\n\n当我们使用了动静态库后，就没有办法直接编译这个可执行程序了\nmuxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ gcc test.c/tmp/ccKHwYHv.o: In function `main&#x27;:test.c:(.text+0xf): undefined reference to `Add&#x27;test.c:(.text+0x2a): undefined reference to `Print&#x27;collect2: error: ld returned 1 exit status[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n这是因为，gcc没办法找到我们对应的头文件\n\n&quot;&quot;是在当前路径下找\n&lt;&gt;是在库目录下面找\n\n因为我们的头文件既不在当前路径，也不在系统的库中，所以gcc就没有办法找到头文件和函数声明\n3.1 静态库链接静态库的方法如下\ngcc test.c -L../lib-static/lib/ -I../lib-static/include/ -lmytest -o test\n\n\n-L选项后带的是库的路径\n-I选择后带的是头文件的搜索路径\n-l(小写的L)选项带的是库的名字，需要去掉库文件名前面的lib和后缀.a\n-o test代表生成可执行文件名为test\n\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ gcc test.c -L../lib-static/lib/ -I ../lib-static/include/ -lmytest -o test[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testret 3time: 1667441311, msg: 这是一个测试[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n特点静态库的特点便是，其库的实现已经被编译链接进入了可执行程序，即便我们将库给删除，也不影响可执行程序的运行\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ make cleanrm -rf *.o *.a *.so lib-static lib-dynamic[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ lltotal 24-rw-rw-r-- 1 muxue muxue  702 Nov  3 09:28 makefile-rw-rw-r-- 1 muxue muxue   60 Nov  3 08:52 myMath.c-rw-rw-r-- 1 muxue muxue   35 Nov  3 08:51 myMath.h-rw-rw-r-- 1 muxue muxue  117 Nov  3 09:01 myPrint.c-rw-rw-r-- 1 muxue muxue   77 Nov  3 09:01 myPrint.hdrwxrwxr-x 2 muxue muxue 4096 Nov  3 09:50 test[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ ./test/./testret 3time: 1667440486, msg: 这是一个测试[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ \n\n如果我们把自己的库的实现丢入了系统的库目录下（一般是/lib64/）编译的时候就不需要带-L选项了，只需要用-l指定库名即可\ngcc test.c -lmytest\n\n但是将自己的库丢入系统库路径下的操作并不推荐，就和你将自己的可执行程序丢入/usr/bin路径里面一样，会污染系统的环境\n\n3.2 动态库动态库和静态库链接的基本方式是一样的\ngcc test.c -L../lib-dynamic/lib/ -I ../lib-dynamic/include/ -lmytest -o testd\n\n这里选项的含义和上面完全一致，不同的是运行的时候\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testd./testd: error while loading shared libraries: libmytest.so: cannot open shared object file: No such file or directory[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n直接运行，你会发现报错了！这个报错的大概意思就是找不到动态库文件\nldd命令使用ldd命令查看testd可执行文件的动态库结构，会发现我们自己的库是没有找到的\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ldd testd        linux-vdso.so.1 =&gt;  (0x00007ffd051fe000)        /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f7de6d19000)        libmytest.so =&gt; not found        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f7de6832000)        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f7de662e000)        /lib64/ld-linux-x86-64.so.2 (0x00007f7de6c00000)[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n这是因为，动态库的特点便是运行的时候也需要指定！这是一个动态链接的过程！\n动态链接动态库需要执行动态链接：在可执行程序开始运行之前，外部函数的机器码由操作系统从磁盘上的该动态库复制到内存中\n刚刚我们的指定只是告诉了gcc编译器库路径在哪儿，但是可执行程序运行的时候并不知道！\n那么如何让可执行程序找到我们的动态库呢？\n\n将动态库拷贝到系统的/lib64文件夹中\n通过修改环境变量的方式，类似于PATH，可执行程序运行的时候，会自动到LD_LIBRARY_PATH里面找动态库\n修改系统配置文件\n\n3.3 找到动态库3.3.1 环境变量LD_LIBRARY_PATH和修改PATH的环境变量一样，我们可以通过修改环境变量的方式增加动态库的查找路径\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/\n\n修改了之后的环境变量如下\nLD_LIBRARY_PATH=:/home/muxue/.VimForCpp/vim/bundle/YCM.so/el7.x86_64:/home/muxue/.VimForCpp/vim/bundle/YCM.so/el7.x86_64:/home/muxue/.VimForCpp/vim/bundle/YCM.so/el7.x86_64:/home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/\n\n再次运行./testd 成功执行！\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testdret 3time: 1667443224, msg: 这是一个测试\n\n修改配置文件的办法，便是将该路径永久写入环境变量（修改环境变量的操作只对当前bash有效）这里就不演示辣！\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ldd testd        linux-vdso.so.1 =&gt;  (0x00007ffde04ea000)        /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007fe9000bc000)        libmytest.so =&gt; /home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/libmytest.so (0x00007fe8ffda1000)        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fe8ff9d3000)        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fe8ff7cf000)        /lib64/ld-linux-x86-64.so.2 (0x00007fe8fffa3000)\n\nldd命令的结果也显示出了我们自己写的动态库的路径\n3.3.2 &#x2F;etc&#x2F;ld.so.conf.d除了修改环境变量，我们还可以修改/etc/ld.so.conf.d下的文件\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ls /etc/ld.so.conf.dbind-export-x86_64.conf  kernel-3.10.0-1160.62.1.el7.x86_64.conf  kernel-3.10.0-1160.76.1.el7.x86_64.confdyninst-x86_64.conf      kernel-3.10.0-1160.71.1.el7.x86_64.conf  mariadb-x86_64.conf[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n这里的操作非常简单，我们只需要在该目录下新增一个.conf文件，并在里面写入动态库的绝对路径即可！\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ls /etc/ld.so.conf.dbind-export-x86_64.conf  kernel-3.10.0-1160.62.1.el7.x86_64.conf  kernel-3.10.0-1160.76.1.el7.x86_64.conf  mytest.confdyninst-x86_64.conf      kernel-3.10.0-1160.71.1.el7.x86_64.conf  mariadb-x86_64.conf[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ cat /etc/ld.so.conf.d/mytest.conf/home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n设置了之后，第一次运行，还是显示找不到动态库\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testd./testd: error while loading shared libraries: libmytest.so: cannot open shared object file: No such file or directory[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n我们只需要执行下面的命令让配文件生效，就OK了！\nsudo ldconfig #子用户权限不够，需要加sudo\n\n执行完该命令后，可执行程序也能成功运行了1\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ sudo ldconfig[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testdret 3time: 1667448942, msg: 这是一个测试[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n测试完毕之后，建议将配置文件删除，并重新加载动态库配置文件\nsudo rm /etc/ld.so.conf.d/mytest.confsudo ldconfig\n\n这样做是避免污染\n3.3.3 在lib64下创建一个软连接ln -s /home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/libmytest.so /lib64/libmytest.so\n\n创建软连接的方式和将我们的文件复制进去本质是一样的，只不过软连接只是一个快捷方式，如果我们把源给删了，软连接也会失效\n这部分就不做演示了\n\n4.优劣4.1 静态库静态库编译之后的可执行程序可以脱离静态库运行，也不需要知道库的路径。\n即便这个库被删除，也丝毫不影响我们的可执行程序\n4.2 动态库动态库的代码只需要一份，所有的可执行程序便都可以使用\n在运行期间，动态库可以被多个进程所共享。但前提是，可执行程序需要知道该动态库的路径，以便将其加载到内存中（或者找到它在内存中的位置）\n\n这样就保证了多个进程同时使用同一个库，节省了内存的消耗，也节省了磁盘空间\n\n这里动态库的可执行文件大小，小于静态库的可执行文件\n\n因为测试的代码不多，所以差距尚不明显\n\n5.动态库-fPIC的作用\n参考https://blog.csdn.net/itworld123/article/details/117587091\n\ngcc -fPIC -c myMath.c -o myMath.o\n\nfPIC 的全称是 Position Independent Code， 用于生成位置无关代码\n\n什么是位置无关代码？\n个人理解是代码无绝对跳转，跳转都为相对跳转\n\n如果我们的静态库中，不使用其他库的代码（比如stdio.h）\nint fuc(int a)&#123;\treturn ++a;&#125;\n\n这时候，就可以再编译的时候不带-fPIC 否则会报错\n/usr/bin/ld: /tmp/ccCViivC.o: relocation R_X86_64_32 against `.rodata&#x27; can not be used when making a shared object; recompile with -fPIC/tmp/ccCViivC.o: could not read symbols: Bad value\n\n但显然，这种情况是非常少见的，所以我们一般编译动态库的时候，都需要带上这个参数，来实现真正意义上的动态库编译\n\n\n加 fPIC 选项生成的动态库，显然是位置无关的，这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针的值，加上一个偏移得到全局变量 &#x2F; 函数的地址。\n加 fPIC 选项的源文件对于它引用的函数头文件编写有很宽松的尺度。比如只需要包含个声明的函数的头文件，即使没有相应的 C 文件来实现，编译成 so 库照样可以通过。\n对于不加 fPIC，则加载 so 文件时，需要对代码段引用的数据对象需要重定位，重定位会修改代码段的内容，这就造成每个使用这个 .so 文件代码段的进程在内核里都会生成这个 .so 文件代码段的 copy。每个 copy 都不一样，取决于这个 .so 文件代码段和数据段内存映射的位置。这种方式更消耗内存，优点是加载速度可能会快一丢丢，弊大于利\n\n\n结语动静态库的基本认识到这里就OVER辣，大家也可以去尝试下载一些第三方的库来使用，比如在树莓派上最常用的wiringPi库，还有C++的boost库等等\nsudo yum install -y boost-devel\n\n有什么问题，可以在评论区提出哦！\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】进程通信 | 共享内存 | 信号量","url":"/posts/3323274806/","content":"上篇Linux的博客是有关管道的，今日就让我们继续康康进程间通信的另外一种方法：共享内存\n\n\n完整代码详见我的gitee仓库 👇\n\nhttps://gitee.com/musnow/raspberry-practice/tree/master/code/22-11-12_systemV\n\n[TOC]\n1.啥是共享内存？进程间通信的基本方式，就是让两个进程看到同一份资源。\n共享内存(shm)实现进程间通信的方式，通过系统接口开辟一段内存，再让多个进程去访问这块内存，就能同时看到一份资源。\n\n这里贴出之前动态库博客中的图，共享内存的方式和该图展示的方式类似。进程需要调用系统接口，将已经开辟好的共享内存映射到自己的页表中，以实现访问。\n这里就出现了一个问题：\n\n操作系统的接口怎么知道进程要的是那一块共享内存？即共享内存是怎么标识的？\n\n要知道，之前我们打开文件、开辟管道等等，都是具有唯一的文件路径来标识文件的。如果按以前的想法：打开文件-&gt;系统返回文件的文件描述符，共享内存则应该是开辟共享内存-&gt;系统返回共享内存的编号\n\n这就出现了问题！\n\n假设进程A开辟了一段共享内存，系统返回了编号123，那么进程A要怎么让其他想使用这块共享内存进行通信的进程，知道它开辟的共享内存编号是123呢？总不能开个管道告诉它吧？那岂不是多此一举😂\n\n所以，共享内存的编号其实和命名管道一样，是由用户手动在代码中指定的。只要进程使用这个编号去获取共享内存，他们就能获取到同一份！\n\n2.相关接口说完了基本概念，现在让我们来康康它的使用\n2.1 ftokftok - convert a pathname and a project identifier to a System V IPC key\n#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;key_t ftok(const char *pathname, int proj_id);\n\n前面提到了，共享内存的key是我们自己指定的。Linux系统给定了ftok接口，将用户提供的pathname工作路径，以及proj_id项目编号转换为一个共享内存的key（其实就是int类型）\n\n只要我们的工作路径和项目编号传的是一样的，那么它返回的key就是一样的！\n这个函数也能用于信号量的key的创建！\n2.2 shmgetshmget - allocates a System V shared memory segment\n#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg);\n参数分别为key值，共享内存的大小，以及创建共享内存的方式。\nkey值需要通过 ftok函数获取；\n其中共享内存的大小最好设置为4kb的整数倍，因为操作系统IO的基本单位是4KB。如果你申请了不是4的整数倍的字节，比如15个字节，其还是会申请16个字节(4个页)交给你，而其中有1kb的内存你是无法使用的，即造成了内存浪费😥\n创建共享内存的shmflg:\n\nIPC_CREAT：创建共享内存。如果存在则获取，如果不存在则创建后获取\nIPC_EXCL：必须配合IPC_CREAT使用，如果不存在指定的共享内存，就进行创建；如果该共享内存存在，则出错返回（即保证获取到的共享内存一定是当前进程创建的，是一个新的共享内存）\n\n返回值是一个共享内存的标识符\nRETURN VALUE       On success, a valid shared memory identifier is returned.  On errir, -1 is returned, and errno is set to indicate the error.\n\n这些工作都是操作系统做的。其内核中有专门的管理单元来判断一个共享内存是否存在，以及何时被创建、被使用、被什么进程绑定等等…\n命令行键入man shmctl，可以看到下面的内核结构\nstruct shmid_ds &#123;    struct ipc_perm shm_perm;    /* Ownership and permissions */    size_t          shm_segsz;   /* Size of segment (bytes) */    time_t          shm_atime;   /* Last attach time */    time_t          shm_dtime;   /* Last detach time */    time_t          shm_ctime;   /* Last change time */    pid_t           shm_cpid;    /* PID of creator */    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */    shmatt_t        shm_nattch;  /* No. of current attaches */    ...&#125;;struct ipc_perm &#123;    key_t          __key;    /* Key supplied to shmget(2) */    uid_t          uid;      /* Effective UID of owner */    gid_t          gid;      /* Effective GID of owner */    uid_t          cuid;     /* Effective UID of creator */    gid_t          cgid;     /* Effective GID of creator */    unsigned short mode;     /* Permissions + SHM_DEST and                                           SHM_LOCKED flags */    unsigned short __seq;    /* Sequence number */&#125;;\n\n共享内存要被管理，其内核结构中一定有一个唯一的key值来标识该共享内存，即和文件的inode一样\nkey_t     __key; //共享内存的唯一标识符，由用户在shmget中提供\n\n关于key为何要让用户提供，已经在上面做出过解释👉 回顾一下\n\n2.3 shmat&#x2F;shmdtat其实是attach绑定的缩写，这个接口的作用是将一个共享内存和我们当前的进程绑定。\n其实就是将这个共享内存映射到进程的页表中（堆栈之间）\nshmat, shmdt - System V shared memory operations\n#include &lt;sys/types.h&gt;#include &lt;sys/shm.h&gt;void *shmat(int shmid, const void *shmaddr, int shmflg);int shmdt(const void *shmaddr);\n\n一共有两个函数，分别为at和dt，用于绑定&#x2F;解绑共享内存\nshmat的三个参数如下\n\nshmid：为shmget的返回值\nshmaddr：指定共享内存连接到当前进程中的地址位置。通常为空，表示让系统来选择共享内存的地址。\nshmflg：如果指定了SHM_RDONLY位，则以只读方式连接此段；否则以读写的方式连接此段；通常设置为0\n\n调用成功的时候，返回指向共享内存第一个字节的指针；出错返回-1\n\nshmdt的参数为shmat正确调用时的返回值\n\n以下是man手册中对这两个函数返回值的描述👇\nRETURN VALUE       On success shmat() returns the address of the attached shared memory segment; on error (void *) -1 is returned, and errno is set  to       indicate the cause of the error.       On success shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.\n\n2.4 shmctl这个函数可以用于操作我们的共享内存\n#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmctl(int shmid, int cmd, struct shmid_ds *buf);\n\n其中cmd的参数有下面几种\n\nIPC_RMID  删除该共享内存\n\nIPC_STAT  把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值\n\nIPC_SET 如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值\n\n\n最后一个buf参数是一个指向shmid_ds结构的指针，一般设为NULL\nThe buf argument is a pointer to a shmid_ds structure\n\nshmid_ds的基本结构如下\nstruct shmid_ds&#123;    uid_t shm_perm.uid;    uid_t shm_perm.gid;    mode_t shm_perm.mode;&#125;;\n\n以删除为例，其操作如下\nshmctl(shmid, IPC_RMID, NULL);//删除shmid的共享内存\n\n2.5 ipcs命令先来康康几个ipcs命令的选项，这些命令可以帮助我们查看共享资源。其中我们要用到的是-m查看共享内存\nipcs -c #查看消息队列/共享内存/信号量ipcs -s #单独查看信号量ipcs -q #单独查看消息队列ipcs -m #单独查看共享内存\n\n执行了之后，会列出当前操作系统中开辟的共享内存，以及它们的基本信息\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m ------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 1          muxue      0          1024       0    \n\n这里的key和我们使用ftok获取到的key值是一样的，只不过我们打印的时候是十进制，操作系统列出来的为十六进制。\nipcrm 删除进程通信资源这个命令可以用与删除ipc资源，包括共享内存\nipcrm -m shmid #删除共享内存\n\n我们可以使用ipcrm -m 共享内存的shmid来删除共享内存\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 1          muxue      0          1024       0                       [muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcrm -m 1[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       \n\n可以看到我们自己创建的共享内存已经被删除了。\n\n但是，当我们尝试用该命令删除一个正在被使用的共享内存时，它并不会被立即删除（立即删除会影响进程运行）\n此时执行删除，在共享内存的status列会出现dest；观察结果，当进程结束的时候，这个共享内存会被直接删除（进程内部并没有调用shmctl接口）\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 21         muxue      666        1024       2                       [muxue@bt-7274:~/git]$ ipcrm -m 21[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x00000000 21         muxue      666        1024       2          dest         [muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                 \n\n相比之下，如果不执行ipcrm命令+进程内部不调用shmctl接口，这个共享内存就会一直存在\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 22         muxue      666        1024       0                       \n\n结论：使用ipcrm -m命令删除共享内存之后，其共享内存不一定会立即释放。如果有进程关联了该共享内存，则会在进程去关联之后释放；\n2.6 共享内存和管道的对比面试的时候问道了这个问题！\n\n2.7 消息队列mq&#x2F;信号量的接口消息队列和信号量的接口和共享内存很相似\n消息队列用的不多，信号量的难度很高！😂 后文会介绍信号量。\n//消息队列相关接口msgget //获取msgctl //操作msgsnd //发送信息msgrcv //信号量semgetsemctlsemop\n\n3.使用3.1 创建并获取//头文件实在太多，为了博客篇幅，这里省略了#define NUM 1024#define PROJ_ID 0x20#define PATH_NAME &quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;key_t CreateKey()&#123;    key_t key = ftok(PATH_NAME, PROJ_ID);    if(key &lt; 0)    &#123;        cerr &lt;&lt;&quot;ftok: &quot;&lt;&lt; strerror(errno) &lt;&lt; endl;        exit(1);//key获取错误直接退出程序    &#125;    return key;&#125;int main()&#123;    key_t key = CreateKey();    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    return 0;&#125;\n\nFile exists这里会发现，第一次运行代码的时候，程序成功获取了共享内存；但是第二次运行的时候，却报错说File exists(文件存在)\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./testshmget: 1[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./testshmget err: File exists\n\n这是因为共享内存的声明周期是随内核的。即只要这个共享内存不被删除，他就会一直存在，直到内核因为某种原因释放掉它，亦或者操作系统关机\n通过上面提到的ipcrm -m shmid 命令删除共享内存，才能重新运行代码获取新的共享内存\n\n为了避免这个问题，应该在进程结束后使用shmctl接口删除共享内存\n\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./testshmget success: 2[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 2          muxue      0          1024       0                       \n\n设置权限值默认情况下，我们创建的共享内存的perms是0，代表没有用户能访问这个共享内存。所以在创建的时候，我们需要在flag里面直接或上这个共享内存的权限值       \n代码如下👇\nint main()&#123;    key_t key = CreateKey();    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | 0666);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    sleep(5);    shmctl(id,IPC_RMID,nullptr);    return 0;&#125;\n\n这时候创建的共享内存就有正确的权限值了\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 4          muxue      666        1024       0    \n\n3.2 挂接&#x2F;取消挂接//关联共享内存char *str = (char*)shmat(id, nullptr, 0);\n\n因为shmat函数的返回值是一个void*指针，我们可以以使用malloc一样的方式使来挂接共享内存。随后对这个内存的操作就是正常的指针操作了！\n同样的，另外一个进程也需要用同样的方式挂接共享内存，才能读取到相同的数据\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 4          muxue      666        1024       1   \n\n挂接成功后，可以发现nattch的值从0变为1\n取消&#x2F;删除取消挂接的方式很简单，直接把shmat的返回值传入即可\nshmdt(str);//取消挂接\n\n如果是服务端，则还需要在取消挂接之后，删除共享内存。避免下次程序运行的时候，无法通过key获取到新的共享内存\nshmctl(id,IPC_RMID,nullptr);//删除共享内存\n\n3.3 写入内容因为共享内存本质就是一个内存，其和malloc出来的内存都是一样的，直接使用即可\n这里还是用一个服务端和一个客户端来进行演示\n//server.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    //获取key值    key_t key = CreateKey();    //创建共享内存    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | 0666);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    sleep(2);    //关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[server] shmat success\\n&quot;);    //读取数据，sleep(1)    int i=0;    while(i&lt;=40)    &#123;        printf(&quot;[%03d] %s\\n&quot;,i,str);        i++;        sleep(1);    &#125;    //去关联    shmdt(str);//shmat的返回值    printf(&quot;[server] shmdt(str)\\n&quot;);    //删除共享内存    shmctl(id,IPC_RMID,nullptr);    printf(&quot;[server] exit\\n&quot;);    return 0;&#125;//client.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    //获取key值    key_t key = CreateKey();    //获取共享内存    int id = shmget(key, NUM, IPC_CREAT);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    sleep(2);    //关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[client] shmat success\\n&quot;);    //写入数据    int i=0;    while(i&lt;26)    &#123;        char base = &#x27;A&#x27;;        str[i] = base+i;        str[i+1] = &#x27;\\0&#x27;;        printf(&quot;write times: %02d\\n&quot;,i);        i++;        sleep(1);    &#125;    //去关联    shmdt(str);//shmat的返回值    printf(&quot;[client] shmdt &amp; exit\\n&quot;);    return 0;&#125;\n\n跑起来之后，客户端向共享内存中写入数据（注意控制\\0）服务端进行读取。这便实现了我们进程之间的通信\n\n不过我们发现，客户端已经停止写入之后，服务端还是在不停的读取。如果我们不控制while循环的话，其会一直这么读取下去\n\n这便牵扯出共享内存的一个特性了\n共享内存没有访问控制在管道的博客中提到，管道是有访问控制的进程通信方式，写端没有写入数据的时候，读端会在read中进行等待。\n而共享内存因为我们是直接像操作一个malloc出来的空间一样访问，没有使用任何系统接口（相比之下管道需要使用read/write）所以操作系统没有办法帮我们进行访问控制！\n也正是因为没有阻塞等待就能直接访问这块内存空间，共享内存是进程中通信中最快的一种方式。\n通过管道进行共享内存的控制既然共享内存没有访问控制，那么我们可以利用管道来让控制共享内存的读写\n\n写端写完后，将完成信号写入管道，由读端读取\n读端从管道中获取到信号后，访问共享内存读出内容\n如果写端没有写好，读端就会在管道read内部等待\n\n你可能会说，那为何不直接用管道通信呢？\n\n管道仅作访问控制，只需要一个int乃至一个char类型即可；\n相比直接管道通信，共享内存的方式更好控制（毕竟使用内存的方式和使用指针一样，我们比较熟悉，管道还需要文件操作；）\n读取很长一串数据的时候，共享内存的速度优势能体现出来；\n\n以下是完整代码👇\n//mykey.hpp#pragma once#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;using namespace std;#define NUM 1024#define PROJ_ID 0x20#define PATH_NAME &quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;#define FIFO_FILE &quot;sc.pipe&quot;key_t CreateKey()&#123;    key_t key = ftok(PATH_NAME, PROJ_ID);    if(key &lt; 0)    &#123;        cerr &lt;&lt;&quot;ftok: &quot;&lt;&lt; strerror(errno) &lt;&lt; endl;        exit(1);//key获取错误直接退出程序    &#125;    return key;&#125;void CreateFifo()&#123;    umask(0);    if(mkfifo(FIFO_FILE, 0666) &lt; 0)    &#123;        cerr &lt;&lt; &quot;fifo: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(2);    &#125;&#125;//打开管道文件int Open(int flags)&#123;    return open(FIFO_FILE, flags);&#125;//让读端通过管道等待ssize_t Wait(int fd)&#123;    char val = 0;    //如果写端没有写入，其就会在read中等待    ssize_t s = read(fd, &amp;val, sizeof(val));    return s;&#125;//发送完成信息int Signal(int fd)&#123;    char sig = &#x27;g&#x27;;    write(fd, &amp;sig, sizeof(sig));&#125;//server.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    //创建管道    CreateFifo();    //获取key值    key_t key = CreateKey();    //创建共享内存    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | 0666);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    //获取管道    int fd = Open(O_RDONLY);    cout &lt;&lt; &quot;open fifo success: &quot; &lt;&lt; fd &lt;&lt; endl;    sleep(2);    //关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[server] shmat success\\n&quot;);    //读取数据    int i=0;    while(i&lt;=40)    &#123;        ssize_t ret = Wait(fd);//通过管道等待        if(ret!=0)        &#123;            printf(&quot;[%03d] %s\\n&quot;,i,str);            i++;            sleep(1);        &#125;        else        &#123;            cout&lt;&lt;&quot;[server] wait finish, break&quot; &lt;&lt; endl;            break;        &#125;    &#125;    //去关联    shmdt(str);//shmat的返回值    printf(&quot;[server] shmdt(str)\\n&quot;);    //删除共享内存    shmctl(id,IPC_RMID,nullptr);    close(fd);    unlink(FIFO_FILE);    printf(&quot;[server] exit\\n&quot;);    return 0;&#125;//client.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    //获取key值    key_t key = CreateKey();    //获取共享内存    int id = shmget(key, NUM, IPC_CREAT);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    //获取管道    int fd = Open(O_WRONLY);    cout &lt;&lt; &quot;open fifo success: &quot; &lt;&lt; fd &lt;&lt; endl;    sleep(2);    //关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[client] shmat success\\n&quot;);    //写入数据    int i=0;    while(i&lt;26)    &#123;        char base = &#x27;A&#x27;;        str[i] = base+i;        str[i+1] = &#x27;\\0&#x27;;        printf(&quot;write times: %02d\\n&quot;,i);        i++;        Signal(fd);        sleep(1);    &#125;    //去关联    shmdt(str);//shmat的返回值    printf(&quot;[client] shmdt &amp; exit\\n&quot;);    close(fd);    printf(&quot;[client] close fifo\\n&quot;);    return 0;&#125;\n\n运行结果管道控制了之后，当客户端退出的时候，管道也不会继续读取，而是在read内等待\n\n如果客户端最后关闭了管道的写段，服务器端就会直接退出。这样我们就实现了通过管道控制共享内存的读写👍\n\n\n4.相关概念4.0 临界资源能被多个进程看到的资源，被称为临界资源\n如果不对临界资源进行访问控制，进程对该资源的访问就是乱序的（比如父子进程向显示器打印内容）可能会因为数据交叉导致乱码、数据不可用等情况；\n以此可见，显示器、管道、共享内存都是临界资源。\n\n管道是有访问控制的临界资源\n\n进程访问临界资源的代码，称为临界区\n\n一个进程中，并不是所有的代码都在访问临界资源。如管道中，其实只有read/write接口在访问临界资源。\n\n互斥：任何时刻，只允许一个进程访问临界资源。\n原子性：一件事情只有做完/没做两种状态，没有中间状态。\n下面对信号量的概念进行讲解~ 只用基本理解即可；\n4.1 信号量4.1.1 概念信号量是对临界资源的控制方式之一，其本质是一个计数器；准确来说，是一个拥有原子性的计数器。\n\n信号量保证不会有多余的进程连接到这份临界资源\n还需要保证每一个进程的能够访问到临界资源的不同位置（根据上层业务决定）\n\n信号量根据情况的不同分为两种：\n\n二元信号量（互斥状态，当进程使用的时候为1，没有进程使用的时候为0）\n多元信号量（常规的计数器）\n\n如果一个进程想访问由信号量控制的临界资源，必须先申请信号量才能进行访问。但是只要我申请成功了，就一定能访问到这个临界资源中的一部分（或者全部）\n4.1.2 原子性的说明先来想想，我们对一个变量+1/-1需要做什么工作：\n\n将这个变量从内存中拿到CPU的寄存器中\n在寄存器中完成加减操作\n放回内存\n\n这其中是有很多个中间状态的，设该变量初始值为100\n\n假设一个进程A拿走了这个变量，放入CPU的寄存器\n另外一个进程B也来拿走了这个变量\n此时A和B拿到的都是100\nA对该变量进行了循环--操作，最终该变量变成了50，将其放回内存\nB对该变量-1，将其放回内存\n最终导致A对变量的操作被B覆盖，出现了变量不统一的情况\n\n而我们的信号量为了保证能够正确的控制进程的访问，其就必须维护自身的原子性！不能有中间状态\n\n说人话就是，如果进程A在访问信号量，进程B来了，信号量应该拒绝B的访问，直到A访问结束。不能让B中途插入访问，从而导致可能的数据不统一；\n\n共享内存同样可以通过信号量进行访问控制\n\n4.1.3 接口创建信号量 semget使用如下函数获取一个信号量，或者创建一个新的信号量；\n调用这个函数之前，我们需要使用 ftok 函数创建一个 key_t 值作为信号量的标识符。\nint semget(key_t key, int nsems, int semflg);\n\n\nkey 是一个唯一标识符，用于标识信号量集。\nnsems 是信号量集中信号量的数量。\nsemflg 是标志位，用于指定信号量的权限。\n\n一般情况下，我们将semflg写为 IPC_CREAT | 权限值，这里的权限值和linux中文件权限值是相同的，比如需要所有人都有一切权限，就可以写 777；一般写成 666就行了，这代表所有用户，所属组和其他用户都拥有读写权限。\n指定了 IPC_CREAT 标志位，则表示如果该信号量不存在，则创建它；如果存在，则返回已存在的信号量的标识符。\n初始化信号量 semctlint semctl(int semid, int semnum, int cmd, ...);\n\n\nsemid 是信号量集的标识符。\nsemnum 是信号量在信号量集中的索引。\ncmd 是操作指令，可以是 SETVAL、GETVAL 等。\n对于 SETVAL 操作指令，需要通过可变参数 ... 来设置初始化的值。\n\n对于该函数的第三个参数cmd，有如下类型的选项\n\nIPC_STAT：获取信号量的状态信息，包括信号量的当前值、最后一次修改时间等。\nIPC_SET：设置信号量的状态信息，比如设置信号量的权限、所有者等。\nIPC_RMID：删除信号量，释放占用的系统资源。\nGETVAL：获取信号量的当前值。\nSETVAL：设置信号量的当前值。\n\n除了上述常见的操作类型，还有其他一些操作类型用于更具体的操作，例如：\n\nGETPID：获取最后一次操作信号量的进程 ID。\nGETNCNT：获取当前正在等待信号量解锁的进程数量。\nGETZCNT：获取当前等待信号量解锁的进程数量。\n\n根据我们的需要选择对应的操作符来进行信号量的操作即可；\n如下是一个获取信号量当前值的操作。\nint semid;  // 信号量集标识符// 需要初始化int sem_num = 0;  // 信号量索引，如果信号量集里面只有一个信号量，就用0int cmd = GETVAL;  // 获取信号量的命令，GETVAL表示获取当前值// 执行这个函数时，返回值就是信号量当前值// 如果返回-1就代表获取失败了int sem_value = semctl(semid, sem_num, cmd);\n\n修改信号量 semopint semop(int semid, struct sembuf *sops, size_t nops);\n\n功能： 操作信号量，P V 操作\n参数： \n\nsemid 为信号量集的标识符；\nsops 指向进行操作的结构体数组的首地址；\nnsops 指出将要进行操作的信号的个数；\n\n返回值： 成功返回0，出错返回-1\nRETURN VALUE       If successful semop() and semtimedop() return 0; otherwise they return -1 with errno indicating the error.\n\n结构体 sembuf这里我们会用到 struct sembuf这个结构体来操作信号量，在系统中这个结构体的声明如下\nstruct sembuf&#123;  unsigned short int sem_num;\t/* semaphore number */  short int sem_op;\t\t/* semaphore operation */  short int sem_flg;\t\t/* operation flag */&#125;;\n\n\nsem_num：表示要操作的信号量在信号量集中的索引，如果信号量集只有一个信号量，则为 0。\nsem_op：表示进行的操作类型，可以是正数、负数或零。正数表示增加（释放）信号量的值，负数表示减少（获取）信号量的值，零表示检查信号量的值。\nsem_flg：表示操作的标志位，用于指定额外的操作选项。一般用的是两个：\nSEM_UNDO 表示异常时撤回对信号量的操作\nIPC_NOWAIT 表示如果信号量没有就绪，不进行阻塞等待，直接错误退出\n\n\n\n比如如下操作，就是给信号量新增值的处理（如果sem_op为负数，那就是减去值）需要注意的是，信号量的值不能为负数。如果你想减去值，请保证信号量里面有足够的值给你减，否则进程会在semop中阻塞等待。\nstruct sembuf semaphore;semaphore.sem_num = 0;semaphore.sem_op = 1;  // 新增信号量1semaphore.sem_flg = SEM_UNDO; // SEM_UNDO 标记位代表异常的时候还原（撤销）操作\n\n如下操作是等待信号量变成0\nstruct sembuf semaphore;semaphore.sem_num = 0;    // 操作的信号量索引semaphore.sem_op = 0;     // 检查信号量的值semaphore.sem_flg = 0;    // 操作标志位为0semop(semid, &amp;semaphore, 1);  // 等待信号量变成0// 如果没有变成0，就会阻塞等待// 如果sem_flg设置了IPC_NOWAIT，那就不会阻塞等待，而是直接返回EAGAIN\n\n在man手册里面是这么描述的\nIf  sem_op is zero, the process must have read permission on the semaphore set.  This is a &quot;wait-for-zero&quot; operation: if semval is zero,the operation can immediately proceed.  Otherwise, if IPC_NOWAIT is specified in sem_flg, semop() fails with errno set  to  EAGAIN  (andnone  of  the  operations  in sops is performed).  Otherwise, semzcnt (the count of threads waiting until this semaphore&#x27;s value becomeszero) is incremented by one and the thread sleeps until one of the following occurs:·  semval becomes 0, at which time the value of semzcnt is decremented.·  The semaphore set is removed: semop() fails, with errno set to EIDRM.·  The calling thread catches a signal: the value of semzcnt is decremented and semop() fails, with errno set to EINTR.\n\n翻译一下，如果 sem_op设置为了0，且没有设置 IPC_NOWAIT，那么进程就会在 semop函数中等待，直到出现下面的情况：\n\n信号量变成0，等待成功\n信号量被销毁\n执行流接收到信号退出（信号是下一章要学习的内容，和信号量没关系）\n\n示例如下是单个进程操作信号量的示例代码\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/unistd.h&gt;int main() &#123;    int semid;    key_t key;    struct sembuf semaphore;    // 创建或获取信号量集    key = ftok(&quot;.&quot;, &#x27;S&#x27;);    semid = semget(key, 1, IPC_CREAT | 0666);    if (semid == -1) &#123;        perror(&quot;Failed to create semaphore\\n&quot;);        exit(1);    &#125;    printf(&quot;1\\n&quot;);    // 初始化信号量的值为1    if (semctl(semid, 0, SETVAL, 1) == -1) &#123;        perror(&quot;Failed to initialize semaphore value\\n&quot;);        exit(1);    &#125;    printf(&quot;12\\n&quot;);    // 对信号量进行操作    semaphore.sem_num = 0;    semaphore.sem_op = 34;  // 新增信号量值    semaphore.sem_flg = SEM_UNDO;    if (semop(semid, &amp;semaphore, 1) == -1) &#123;        perror(&quot;Failed to perform semaphore operation\\n&quot;);        exit(1);    &#125;    printf(&quot;13\\n&quot;);    // 获取信号量的当前值    int cmd = GETVAL;  // 获取信号量的命令，GETVAL表示获取当前值    int sem_value = semctl(semid, 0, cmd);    if(sem_value == -1)    &#123;        perror(&quot;Failed to perform semaphore operation\\n&quot;);        exit(1);    &#125;    else&#123;        printf(&quot;current val for sem: %d\\n&quot;,sem_value);    &#125;    printf(&quot;14\\n&quot;);    // 释放信号量    semaphore.sem_op = -34;  // 减少信号量值    if (semop(semid, &amp;semaphore, 1) == -1) &#123;        perror(&quot;Failed to release semaphore\\n&quot;);        exit(1);    &#125;    printf(&quot;15\\n&quot;);    // 删除信号量集    if (semctl(semid, 0, IPC_RMID) == -1) &#123;        perror(&quot;Failed to remove semaphore\\n&quot;);        exit(1);    &#125;    printf(&quot;16\\n&quot;);    return 0;&#125;\n\n运行结果如下，这里的printf是我用来标识进程跑到那个阶段的，没有啥实际意义。\n11213current val for sem: 35141516\n\n4.2 扩展 mmap\n这部分仅供参考，可能有错误😥部分资料参考\n\n 前面贴出过IPC资源的内核结构，它们都有一个共同的特点：第一个成员都相同\nstruct shmid_ds &#123;    struct ipc_perm shm_perm;    /* Ownership and permissions */    size_t          shm_segsz;   /* Size of segment (bytes) */    time_t          shm_atime;   /* Last attach time */    time_t          shm_dtime;   /* Last detach time */    time_t          shm_ctime;   /* Last change time */    pid_t           shm_cpid;    /* PID of creator */    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */    shmatt_t        shm_nattch;  /* No. of current attaches */    ...&#125;;struct semid_ds &#123;    struct ipc_perm sem_perm;  /* Ownership and permissions */    time_t          sem_otime; /* Last semop time */    time_t          sem_ctime; /* Last change time */    unsigned long   sem_nsems; /* No. of semaphores in set */&#125;;struct msqid_ds &#123;    struct ipc_perm msg_perm;     /* Ownership and permissions */    time_t          msg_stime;    /* Time of last msgsnd(2) */    time_t          msg_rtime;    /* Time of last msgrcv(2) */    time_t          msg_ctime;    /* Time of last change */    unsigned long   __msg_cbytes; /* Current number of bytes in                                                queue (nonstandard) */    msgqnum_t       msg_qnum;     /* Current number of messages                                                in queue */    msglen_t        msg_qbytes;   /* Maximum number of bytes                                                allowed in queue */    pid_t           msg_lspid;    /* PID of last msgsnd(2) */    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */&#125;;\n\n它们的第一个成员都是一个struct ipc_perm，其中包含了一个信号量的基本信息\nstruct ipc_perm &#123;    key_t          __key;    /* Key supplied to shmget(2) */    uid_t          uid;      /* Effective UID of owner */    gid_t          gid;      /* Effective GID of owner */    uid_t          cuid;     /* Effective UID of creator */    gid_t          cgid;     /* Effective GID of creator */    unsigned short mode;     /* Permissions + SHM_DEST and                                           SHM_LOCKED flags */    unsigned short __seq;    /* Sequence number */&#125;;\n\n而内核中对IPC资源的管理，是通过一个数组进行的。我们所获取的shmid，和文件描述符一样，都是一个数组的下标\n其中我在测试的时候，便发现了一点：我们每一次获取的新的共享内存，它的编号都会+1，而不像文件描述符一样，提供第一个没有被使用的下标\nstruct ipc_ids &#123;    int in_use;//说明已分配的资源个数    int max_id;//在使用的最大的位置索引    unsigned short seq;//下一个分配的位置序列号    unsigned short seq_max;//最大位置使用序列    struct semaphore sem; //保护 ipc_ids的信号量    struct ipc_id_ary nullentry;//如果IPC资源无法初始化，则entries字段指向伪数据结构    struct ipc_id_ary* entries;//指向资源ipc_id_ary数据结构的指针&#125;;\n\n在内核中，struct ipc_id_ary* entries是一个指向所有ipc_perm的指针数组。其能够通过该数组找到我们对于id（下标）的资源，对其进行访问\nstruct ipc_id_ary&#123;        int size;        struct kern_ipc_perm *p[0];//指针数组&#125;;\n\n\n那你可能想问了，这里只是第一个元素啊？那如果我想访问shmid_ds结构的其他成员，岂不是没有办法访问了？\n要是这么想，就还是太年轻了😂\n(strcut shmid_ds*)\n\n我们只需要对这个指针进行强转，就能直接访问其他成员！\n这是因为：C语言中，结构体第一个元素的地址，和结构体整体的地址是一样的！\n指针的类型会限制这个指针访问元素的能力，只要我们进行强转，其就能直接访问父结构体的其他成员！\n\n这是一种切片的思想\n\n用这种办法，可以用统一的规则在内核中管理不同的IPC资源，没有必要再为每一个IPC资源建立一个单独的数组来管理。\n\n不得不说，linus大佬是真的牛逼！\n\n4.3 多进程共享锁 mutex共享内存因为缺少访问控制，常常需要借助其他具有访问控制的进程通信手段来间接实现访问控制。\n但实际上有一个更加符合我们使用习惯的写法，那就是使用 pthread_mutex 锁的 PTHREAD_PROCESS_SHARED 多进程共享属性，让这把锁可以在多个进程中被使用。在每个进程中，我们都可以像使用自己的锁一样使用它，以此实现了一把能同时管多个进程的一把互斥锁！\n#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main()&#123;    // 共享内存的名字必须以/开头    int shared_mem_fd = shm_open(&quot;/my_shared_memory&quot;, O_CREAT | O_RDWR, 0666);    // 创建了一个mutex大小的共享内存(这个函数的作用是将fd文件给截断/扩展为第二个参数的大小)    ftruncate(shared_mem_fd, sizeof(pthread_mutex_t));    // 用mmap挂载到本地    // addr：指定映射的虚拟地址，通常设置为NULL，让系统自动分配。    // length：指定映射的长度，以字节为单位。    // prot：指定映射区域的保护权限，可选值为PROT_READ（可读权限）、PROT_WRITE（可写权限）、PROT_EXEC（可执行权限）以及它们的组合。    // flags：指定映射的类型和其他标志位，常见的标志位有MAP_SHARED（共享映射）、MAP_PRIVATE（私有映射）、MAP_ANONYMOUS（匿名映射）等。    // fd：如果要映射文件，则为文件描述符；如果映射的是匿名内存区域，则传入-1。    // offset：从文件开始处的偏移量，通常设置为0。    //    // 返回值：成功时，返回映射区域的起始地址指针；    //        失败时，返回MAP_FAILED，并设置errno来指示错误类型。    void *shared_mem_ptr = mmap(NULL, sizeof(pthread_mutex_t), PROT_READ | PROT_WRITE, MAP_SHARED, shared_mem_fd, 0);    pthread_mutexattr_t attr;    pthread_mutexattr_init(&amp;attr);    pthread_mutexattr_setpshared(&amp;attr, PTHREAD_PROCESS_SHARED); // 设置锁的属性为共享锁    // 如果删除上面这一行，那么当下这个锁就是父进程的私有锁，不具有公有属性    // 即便我们使用共享内存将锁映射到了父子进程的页表中    // 观察到的现象是，即便父进程已经释放锁了，但是子进程依旧是在阻塞状态中    // 个人猜测：因为这个锁是父进程独有的，所以子进程在调用lock函数访问mutex的时候，实际上是将mutex进行了一次写时拷贝；    //          拷贝的时候，这个锁是被占用的，拷贝过去之后也是一个被占用中的锁。    //          但实际上压根没有进程在占用这个被子进程拷贝出去的独立的锁，父进程的解锁操作也不会在进程间同步，这就是一种死锁。    pthread_mutex_t *mutex = (pthread_mutex_t *)shared_mem_ptr;    pthread_mutex_init(mutex, &amp;attr); // 指定使用共享内存的地址来初始化锁    pid_t pid = fork();    if (pid &lt; 0)    &#123;        fprintf(stderr, &quot;Fork failed.\\n&quot;);        return 1;    &#125;    else if (pid == 0)    &#123;        // Child process        sleep(1); // 子进程先休眠1秒，等待夫进程获取锁        printf(&quot;Child trying to acquire the mutex... %p\\n&quot;, mutex);        pthread_mutex_lock(mutex); // 子进程获取锁，这时候父进程在休眠，无法获取        printf(&quot;Child acquired the mutex.\\n&quot;);        // Do some work...        sleep(2);        pthread_mutex_unlock(mutex);        printf(&quot;Child released the mutex.\\n&quot;);    &#125;    else    &#123;        // Parent process        printf(&quot;Parent trying to acquire the mutex... %p\\n&quot;, mutex);        pthread_mutex_lock(mutex);        printf(&quot;Parent acquired the mutex.\\n&quot;);        // Do some work...        sleep(2);        pthread_mutex_unlock(mutex); // 父进程释放锁后，观察到的情况是子进程成功获取锁        printf(&quot;Parent released the mutex.\\n&quot;);        wait(NULL); // 等待子进程执行完毕        pthread_mutexattr_destroy(&amp;attr); // 父进程来销毁相关资源        pthread_mutex_destroy(mutex);        munmap(shared_mem_ptr, sizeof(pthread_mutex_t));        shm_unlink(&quot;/my_shared_memory&quot;);    &#125;    return 0;&#125;\n\n\n结语关于共享内存的操作到这里就OVER了！\n最后还了解了一些内核设计上的小妙招，不得不说，真的牛批~\n如果本文有什么问题，欢迎在评论区提出\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】进程通信 | 管道","url":"/posts/3971907787/","content":"今天让我们来认识如何使用管道来进行进程间通信\n\n\n[TOC]\n1.何为管道？在最初学习linux的基础命令时，接触过用|来连接多个命令的操作。当时便提到了这是一个管道操作，但没有详解管道到底是什么。\n1.1 管道是进程间通信的一种方式管道管道，如同其名，是一个可以让数据在内部流动的东西。创建管道，就好比在两个阀门（进程）之间搭了一根水管，我们可以自由控制管道中水的流向\n不过，在Linux系统中提供的管道接口，只支持单项流动。一个管道只支持从A-&gt;B，不支持B-&gt;A\n要想进行双向通信，则需要创建两个管道\n1.2 进程通信既然管道是用来进程通信的，那进程通信又是什么，它有何用呢？\n进程通信的目的是让两个进程可以相互交流，包括以下几种情况：\n\n数据传输，从进程A发送数据道进程B\n资源共享，多个进程使用同一个资源\n通知事件，进程A向进程B发送消息，告知进程B发生了什么事件\n进程控制，父进程通过管道来控制子进程的执行，进程A控制进程B的执行等等\n\n除了管道，我们还可以通过systemV/POSIX来实现进程通信\n进程通信的核心思想：让两个进程获取到同一份资源\n1.3 管道分类管道分为两种\n\n匿名管道，pipe\n命名管道，管道文件\n\n且听我慢慢道来\n2.匿名管道匿名管道主要用于父子进程之间的通信，其使用pipe接口来进行创建\n\n\n类似于fork，我们只需要在创建了之后判断函数的返回值就可以了\n其中pipefd[2]是一个输出型参数，我们要预先创建好一个2个空间的数组，传入该函数。pipe会创建一个匿名管道（可以理解为一个只属于该进程的临时文件）并将读端赋值给pipefd[0]，写端赋值给pipefd[1]\n\n如果我们需要父进程写，子进程读，就在父进程关闭读端，子进程关闭写端\n如果我们需要父进程读，子进程写，就在父进程关闭写段，子进程关闭读端\n\n通过这种方式，我们就在父子进程中打通了一个管道，可以让父子进程进行一定的交流\n而fd正是我们之前学习过的Linux下文件描述符，其管道的读写操作和调用系统接口读写文件完全相同！\n\n博客：linux文件操作\n\n2.0 康康源码/include/linux/pipe_fs_i.h中可以找到管道操作的源码\nstruct pipe_buffer &#123;\tstruct page *page;\tunsigned int offset, len;\tconst struct pipe_buf_operations *ops;\tunsigned int flags;\tunsigned long private;&#125;;\n\n其中我们的管道文件拥有一个缓冲区，这个缓冲区有一个专门的struct pipe_buf_operations结构体用来处理它的输入输出方法，以及flags用来标识当前缓冲区的装态\n2.1 创建首先，我们需要用pipe接口创建一个匿名管道，使用并不难\n// 1.创建管道int pipefd[2] = &#123;0&#125;;if(pipe(pipefd) != 0)&#123;    cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;    return 1;&#125;\n\n因为pipe是通过pipefd这个输出型参数来创建管道的，所以我们并不需单独定义一个变量来接受该函数的返回值，直接在if语句中进行判断即可\nvoid TestPipe2()&#123;     // 1.创建管道    int pipefd[2] = &#123;0&#125;;    if(pipe(pipefd) != 0)    &#123;        cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;        return ;    &#125;    cout &lt;&lt; pipefd[0] &lt;&lt; &quot; &quot; &lt;&lt; pipefd[1] &lt;&lt; endl;&#125;\n\n先来个小测试，打印这两个值可以发现，它其实是两个不同的文件描述符。系统分别用读方法和写方法打开了同一个文件，供我们使用\n\n0为读端；1为写端\n\n[muxue@bt-7274:~/git/linux/code/22-11-04_pipe]$ ./test3 4[muxue@bt-7274:~/git/linux/code/22-11-04_pipe]$ \n\n我们自己打开的文件描述符是从3开始的，012对应的是stdin/stdout/stderr\n2.2 父子通信有了匿名管道，接下来就可以尝试在父子进程中进行通信了\n以父写子读为例，我们需要在子进程关闭写段，父进程关闭读端\npipefd是父进程的资源，fork创建子进程之后，该资源会发生一次写时拷贝，以供父子进程共享\n// 2.创建子进程pid_t id = fork();if(id &lt; 0)&#123;    cerr &lt;&lt; &quot;fork error&quot; &lt;&lt; endl;    return 2;&#125;else if (id == 0)&#123;    // 3.子进程管道    // 子进程读取, 关掉写端    close(pipefd[1]);    //...&#125;else&#123;    // 4.父进程管道    // 父进程写入，关掉读端    close(pipefd[0]);    //...&#125;\n\n处理完之后，后续的操作便是linux的文件操作了\n完整代码以下是完整代码，通过文件接口对pipefd进行read/write，就能让父进程发送的字符串被子进程读取道\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;using namespace std;#define NUM 1024//匿名管道int TestPipe()&#123;    // 1.创建管道    int pipefd[2] = &#123;0&#125;;    if(pipe(pipefd) != 0)    &#123;        cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;        return 1;    &#125;    // 2.创建子进程    pid_t id = fork();    if(id &lt; 0)    &#123;        cerr &lt;&lt; &quot;fork error&quot; &lt;&lt; endl;        return 2;    &#125;    else if (id == 0)    &#123;        // 3.子进程管道        // 子进程来进行读取, 子进程就应该关掉写端        close(pipefd[1]);        char buffer[NUM];        while(1)        &#123;            cout &lt;&lt; &quot;time_stamp: &quot; &lt;&lt; (size_t)time(nullptr) &lt;&lt; endl;            // 子进程没有带sleep，为什么子进程你也会休眠呢？？            memset(buffer, 0, sizeof(buffer));            ssize_t s = read(pipefd[0], buffer, sizeof(buffer) - 1);            if(s &gt; 0)            &#123;                //读取成功                buffer[s] = &#x27;\\0&#x27;;                cout &lt;&lt; &quot;子进程收到消息,内容是: &quot; &lt;&lt; buffer &lt;&lt; endl;            &#125;            else if(s == 0)            &#123;                cout &lt;&lt; &quot;父进程写完了，我也退出啦&quot; &lt;&lt; endl;                break;            &#125;            else&#123;                cerr &lt;&lt; &quot;err while chlid read pipe&quot; &lt;&lt; endl;            &#125;        &#125;        close(pipefd[0]);        exit(0);    &#125;    else    &#123;        // 4.父进程管道        // 父进程来进行写入，就应该关掉读端        close(pipefd[0]);        const char *msg = &quot;你好子进程，我是父进程, 这次发送的信息编号是&quot;;        int cnt = 0;        while(cnt &lt; 10)        &#123;            char sendBuffer[1024];            sprintf(sendBuffer, &quot;%s : %d&quot;, msg, cnt);//格式化控制字符串            write(pipefd[1], sendBuffer, strlen(sendBuffer));            cnt++;            cout &lt;&lt; &quot;cnt: &quot; &lt;&lt; cnt &lt;&lt; endl;            sleep(1);        &#125;        close(pipefd[1]);        cout &lt;&lt; &quot;父进程写完了&quot; &lt;&lt; endl;    &#125;    // 父进程等待子进程结束    pid_t res = waitpid(id, nullptr, 0);    if(res &gt; 0)    &#123;        cout &lt;&lt; &quot;等待子进程成功&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;父进程退出&quot; &lt;&lt;endl;    return 0;&#125;\n\n运行成功，可以看到父进程每次写入之后，子进程读取\n\n父进程休眠的时候，子进程看起来啥事没有做\n实际上，子进程是在等待父进程对管道的写入\n2.3 等待之前我们学习过进程等待相关的知识点，其中提到了进程有时候需要等待另外一个进程的执行。比如父进程等待子进程执行完成（上面的代码也用了waitpid等待）\n而管道，就是进程需要等待的资源之一\n\n如果管道为空，读端必须要等待写端写入，否则无法执行后面的代码\n如果管道满了，写段必须等待读端取走数据，否则不能写入。因为此时写入会覆盖之前的数据\n\n那么，进程是在执行到什么函数的时候开始等待的呢？\n答案是：进程将在read/write中进行阻塞等待！\n\n执行到read的时候，操作系统判断匿名管道中没有有效数据，让执行read的进程等待管道写入\n执行到write的时候，操作系统判断管道已经满了，就让执行write的进程等待管道被读取（而且需要管道被清空了才能继续写入）\n这个判断机制是管道文件中自带的，是一种同步和互斥机制\n相比之下，我们向显示器输出的时候，就没有访问控制，父子进程向显示器输出内容的顺序是完全随机的\n\n本质就是将该进程的task_strcut放入等待队列中，并将状态从R设置为S/D/T\n写入等待对第二点进行一个测试，我们把父进程改成死循环，子进程每休眠3s读取一次管道\n\n执行后会发现，父进程几乎是在一瞬间写入了1226次数据，随后子进程开始读取，此时我们会发现，尽管子进程已经开始读取了，但是父进程却米有动静。\n\n子进程需要将管道内的数据读取一部分，父进程才能继续执行写入。\n此时父进程就是在write里面进行等待的\n\n进一步观察会发现，当子进程读取到77次消息的时候，父进程又开始往管道里面写入了\n\n嘿，你猜怎么着？父进程刚好写入了74次消息！而子进程继续读取之前的管道信息\n\n这便告诉我们，父进程需要等待子进程将管道内容读取一部分（清理掉一部分）之后，才能继续往管道内部写入。\n\n但在读端，这一切都不一样了\n读取等待我们让父进程直接睡上20s在进行写入，可以看到，子进程是执行到read开始等待的\n\n当父进程第一次写入之后，子进程立马打印出了消息的内容。随后父进程又进入了休眠，子进程开始了新一次等待\n\n简而言之，就是只要你不往管道里面写东西，子进程就需要一直等下去！\n源码中的体现源码中有一个单独的结构体，用来标识管道文件。其中inode便是Linux下的文件描述符\nstruct pipe_inode_info &#123;\twait_queue_head_t wait;\tunsigned int nrbufs, curbuf;\tstruct page *tmp_page;\tunsigned int readers;\tunsigned int writers;\tunsigned int waiting_writers;\tunsigned int r_counter;\tunsigned int w_counter;\tstruct fasync_struct *fasync_readers;\tstruct fasync_struct *fasync_writers;\tstruct inode *inode;\tstruct pipe_buffer bufs[PIPE_BUFFERS];&#125;;\n\n在这里我们可以看到一个wait结构体，其为一个等待队列，维护写入和读取的等待\nstruct __wait_queue_head &#123;\tspinlock_t lock;\tstruct list_head task_list;&#125;;typedef struct __wait_queue_head wait_queue_head_t;\n\nspinlock是何方神圣我们暂且不知，但list_head结构体告诉我们，这是一个等待队列的链表\nstruct list_head &#123;\tstruct list_head *next, *prev;&#125;;\n\n\n2.4 控制多个子进程上面只是实现了父进程和一个子进程的通信，在实际场景中这远远不够用。接下来就来实现一个父进程和多个子进程之间的通信，通过管道给子进程分配不同的任务！\n具体的操作在注释中有所标明，如果有什么问题欢迎评论提出！\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;using namespace std;//提供三个lambda表达式auto func1 = []() &#123;cout &lt;&lt; &quot;this is func1,run by &quot; &lt;&lt; getpid() &lt;&lt;endl;&#125;;auto func2 = []() &#123;cout &lt;&lt; &quot;this is func2,run by &quot; &lt;&lt; getpid() &lt;&lt;endl;&#125;;auto func3 = []() &#123;cout &lt;&lt; &quot;this is func3,run by &quot; &lt;&lt; getpid() &lt;&lt;endl;&#125;;//通过func存在数组中vector&lt;function&lt;void()&gt;&gt; func_v;void LoadFunc()&#123;    func_v.push_back(func1);    func_v.push_back(func2);    func_v.push_back(func3);&#125;//有一种概念叫做”负载均衡”，在多线程/多进程操作中较多使用//其理念就是每一个进程/线程分到的任务应该是平均的，避免出现某一个进程干的活比别人多的情况void BalanceDivide(const vector&lt;pair&lt;int,int&gt;&gt;&amp; processMap)&#123;    //设置初始化    srand((size_t)time(nullptr));    int total = 15;//分配20次任务    while(total&gt;0)    &#123;        sleep(1);        // 选择一个进程, 选择进程是随机的，没有压着一个进程给任务        // 较为均匀的将任务给所有的子进程 --- 负载均衡        int pick = rand() % processMap.size();        // 选择一个任务        int task = rand() % func_v.size();        // 把任务给一个指定的进程        write(processMap[pick].second, &amp;task, sizeof(task));        // 打印对应的提示信息        cout &lt;&lt; &quot;父进程指派任务-&gt;&quot; &lt;&lt; task &lt;&lt; &quot; 给进程: &quot; &lt;&lt; processMap[pick].first &lt;&lt; &quot; 编号: &quot; &lt;&lt; pick &lt;&lt; endl;        total--;    &#125;    //结束后，写入0代表进程终止    for(int i=0;i&lt;processMap.size();i++)    &#123;        int end = -1;        write(processMap[i].second, &amp;end, sizeof(end));        cout &lt;&lt; &quot;stopping process pid = &quot; &lt;&lt; processMap[i].first &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;assign task end!&quot; &lt;&lt; endl;&#125;//子进程工作，参数为pipefd[0]void Working(int pfd)&#123;    cout &lt;&lt; &quot;chlid [&quot; &lt;&lt; getpid() &lt;&lt; &quot;] start working&quot; &lt;&lt; endl;    while(1)    &#123;        int optCode = 0;//读取任务下标        ssize_t s = read(pfd, &amp;optCode, sizeof(optCode));        if(s == 0)        &#123;            break;//读取了0个字节代表错误        &#125;        else if(optCode == -1)        &#123;            break;//读取到-1，代表终止        &#125;           assert(s == sizeof(int));//判断是否为正确的size        // 执行父进程提供的任务        if(optCode &lt; func_v.size())         &#123;            func_v[optCode]();        &#125;    &#125;    cout &lt;&lt; &quot;chlid [&quot; &lt;&lt; getpid() &lt;&lt; &quot;] end working&quot; &lt;&lt; endl;&#125;int main()&#123;       LoadFunc();//加载    vector&lt;pair&lt;int,int&gt;&gt; assignMap;    int processNum = 5;    for(int i=0;i&lt;processNum;i++)    &#123;        int pipefd[2];        if(pipe(pipefd)!=0)        &#123;            cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;            continue;        &#125;        int pid = fork();        if(pid==0)//子进程        &#123;            close(pipefd[1]);//关闭写            //开始工作            Working(pipefd[0]);            close(pipefd[0]);            exit(0);//退出子进程        &#125;        close(pipefd[0]);//父进程关闭读        pair&lt;int,int&gt; p = &#123;pid, pipefd[1]&#125;;//进程pid和pipefd写端的键值对        assignMap.push_back(p);        sleep(1);    &#125;    cout &lt;&lt; &quot;create all process success!&quot; &lt;&lt; endl;    BalanceDivide(assignMap);//分配任务    //结束分配后，等待子进程停止运行    for (int i = 0; i &lt; processNum; i++)    &#123;        if (waitpid(assignMap[i].first, nullptr, 0) &gt; 0)        &#123;            cout &lt;&lt; &quot;wait for pid = &quot; &lt;&lt; assignMap[i].first &lt;&lt; &quot; wait success! &quot;                 &lt;&lt; &quot;num: &quot; &lt;&lt; i &lt;&lt; endl;        &#125;        close(assignMap[i].second);    &#125;        return 0;&#125;\n\n先是父进程创建了5个子进程\n\n再开始用生成随机数的方式，为每一个进程指派相应的“任务”（其实就是一个函数）\n\n15次任务指派完毕之后，以一个循环，通过管道写入-1作为停止符，让子进程停止工作。同时main函数中进行waitpid等待子进程运行成功！\n\n2.5 命令行 |命令行中输入的|命令，其实就是一个匿名管道\n\n这里我们用|运行两个sleep命令，再查看这两个进程，可以看到这两个进程是属于同一个父进程的，这说明这两个sleep进程是一对兄弟~\n\n当父进程创建一对管道的时候，它可以创建两个子进程，并将管道交付给子进程进行使用\n\n父进程创建管道，创建子进程AB\n父进程关闭pipefd[0]和[1]\n子进程A关闭读端，执行写入\n子进程B关闭写段，执行读取\n\n而|就是将信息转给两个子进程使用的一种匿名管道！这也能解释为什么我们可以先ps ajx，再用| grep在内部搜索内容并打印出来。其就是通过匿名管道实现了几个命令中的信息共享\n\n3.命名管道和匿名管道不同的是，命名管道是通过一个管道文件来实现的，其有一个文件的“实体”，支持多个进程打开同一个管道文件，执行读写操作，实现管道的交流\n\n我们通过mkfifo接口创建一个FIFO(front in front out/先进先出)的管道文件，这里的注释也表明他是一个命名管道a named pipe\n除了可以用函数调用，mkfifo同时也是一个命令\nmkfifo 管道名字\n\n3.1 创建管道文件操作方法和创建一个文件的方法是一样的，指定一个路径，并指定该文件的权限。为了避免受系统的权限掩码值的影响，我们要用umask将权限掩码值置零\numask(0);if(mkfifo(&quot;test.pipe&quot;, 0600) != 0)&#123;//当返回值不为0的时候，代表出现了错误    cerr &lt;&lt; &quot;mkfifo error&quot; &lt;&lt; endl;    return 1;&#125;\n\n运行之后可以看到，出现了一个新的文件。其文件权限值的开头为p，代表它是一个管道文件\n\n之后的操作同样是文件操作，因为管道文件本质上就是一个文件\n\n先使用open方法，指定用读、写方法\n再分别在读写端read/write操作文件\n操作完成之后，close文件，并删除该文件\n因为管道文件有唯一的路径，其能够完成让两个进程看到同一份资源，也就实现了进程通信的功能！\n\n3.2 实现两个进程之间的通信下面通过一个服务端和客户端的代码，来演示多进程通信。\n\n服务端负责创建管道文件，以读方式打开该管道文件\n客户端以写方式打开管道文件，向服务端发送消息\n\n完整代码如下，包含一个头文件和两个源文件\n//MyPath.h#pragma once#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;using namespace std;#define NUM 1024#define FILE_PATH &quot;test.pipe&quot;//server.cpp#include&quot;MyPath.h&quot;int main()&#123;    //创建管道文件    umask(0);    if(mkfifo(FILE_PATH, 0600) != 0)    &#123;        cerr &lt;&lt; &quot;mkfifo error&quot; &lt;&lt; endl;        return 1;    &#125;    //打开管道文件    int pipeFd = open(FILE_PATH, O_RDONLY);    if(pipeFd &lt; 0)    &#123;        cerr &lt;&lt; &quot;open fifo error&quot; &lt;&lt; endl;        return 2;    &#125;    //开始通信    cout &lt;&lt; &quot;服务器启动&quot; &lt;&lt; endl;    char buffer[NUM];    while(1)    &#123;        //服务端执行读        ssize_t s = read(pipeFd, buffer, sizeof(buffer)-1);        if(s &gt; 0)        &#123;            buffer[s] = &#x27;\\0&#x27;;            cout &lt;&lt; &quot;客户端-&gt;服务器# &quot; &lt;&lt; buffer &lt;&lt; endl;        &#125;        else if(s == 0)        &#123;            cout &lt;&lt; &quot;客户端退出，服务器终止接收&quot; &lt;&lt; endl;            break;        &#125;        else        &#123;            cout &lt;&lt; &quot;read: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;            break;        &#125;    &#125;    close(pipeFd);    cout &lt;&lt; &quot;服务器关闭&quot; &lt;&lt; endl;    unlink(FILE_PATH);    return 0;&#125;//client.cpp#include&quot;MyPath.h&quot;int main()&#123;    int pipeFd = open(FILE_PATH, O_WRONLY);    if(pipeFd &lt; 0)    &#123;        cerr &lt;&lt; &quot;open: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        return 1;    &#125;    //客户端执行管道写入    char line[NUM];    while(true)    &#123;        printf(&quot;请输入你的消息# &quot;);        fflush(stdout);        memset(line, 0, sizeof(line));        //fgets的结尾会自动添加\\0        if(fgets(line, sizeof(line), stdin) != nullptr)        &#123;            //这里的意义是去掉接收到的回车\\n            //如：abcde\\n\\0 通过下面的代码去掉\\n            line[strlen(line) - 1] = &#x27;\\0&#x27;;            write(pipeFd, line, strlen(line));//管道写入        &#125;        else        &#123;            break;        &#125;    &#125;    close(pipeFd);    cout &lt;&lt; &quot;客户端退出&quot; &lt;&lt; endl;    return 0;&#125;\n\n通过头文件中的文件路径，我们能保证客户端和服务端处于同一个工作目录下，以便他们正确打开同一个管道文件\n先运行server，会发现并没有出现服务器启动的打印\n\n客户端启动了之后，服务器端才打印出服务器启动\n\n这时候，我们就可以在客户端输入消息，转到服务端读取\n\n这就完成了两个进程之间的通信。这两个进行并非父子进程，也不是兄弟关系！\n客户端CTRL+C终止的时候，服务端也会退出！\n\n等待前面提到了，当客户端没有启动的时候，服务端的打印没有被执行\n进一步测试发现，当我们同时用写方式打开管道文件的时候，这两个进程都会在open中等待，而不执行cout\n\n23776 31027 31027 23776 pts/23   31027 S+    1001   0:00 ./server23952 31043 31043 23952 pts/24   31043 S+    1001   0:00 ./client\n\n这说明，管道文件必须要同时以读写方式打开，才能正常执行后续代码。如果一个进程以写方式打开了一个管道，而该管道没有读端（反过来也是一样的），该进程就会进行阻塞等待\n\n4.管道的特性\n单个管道只支持单向通信，这是内核实现决定的。半双工的一种特殊情况\n管道自带同步机制，能够判断管道的状态，是否写满，是否没有写入等等\n管道是面向字节流的，先写的字符一定是先被读取的，在2.3中有所体现。需要用户来定义区分内容的边界（比如网络tcp协议）\n管道是一个文件，管道的生命周期跟随进程\n\n4.1 什么是半双工？半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；\n管道就是一种半双工的特殊情况，因为管道本身是支持任意进程读写的。对于进程A，它既可以成为管道的读端，又可以成为管道的写端。但一旦确认之后，管道的读写方向就不能被改变。\n所以管道是属于半双工的一种特殊情况\n4.2 拓展：单工&#x2F;半双工&#x2F;双工参考资料来源：博客园\n\n单工数据传输只支持数据在一个方向上传输；\n半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；\n全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。\n\n结语阿巴阿巴，关于管道的内容到这里就基本over了，我们通过匿名管道实现了控制多个子进程。通过命名管道实现了两个不相干进程之间的通信\n\n下篇博客是关于共享内存的\n\n如果有啥问题，可以在评论区提出哦！\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】tar命令打包 | 查看压缩文件 | 打包时忽略文件","url":"/posts/4159326627/","content":"tar命令打包 | 查看压缩文件 | 打包时忽略文件 等操作\n\n\n1.起因今天下午写阿狸bot的代码的时候，写错了aiofiles的保存操作\n# 正确写法async def write_file_aio(path:str, value):    async with aiofiles.open(path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:        await f.write(json.dumps(value, indent=2, sort_keys=True,ensure_ascii=False))        # 错误写法# 前面是一样的await f.write(json.dump(value, indent=2, sort_keys=True,ensure_ascii=False))\n\n注意这两个函数，一个是json.dump；一个是json.dumps\n就是因为这里写错了，导致bot执行全局变量保存的时候，所有文件都没有成功保存——还直接把本地文件清空了！！！\n\n当时的我是真的欲哭无泪啊，都不知道如何是好\n\nvscode的时间线功能帮我保存了一部分文件，可是绝大部分文件都是程序生成的，没有经过vscode，其自然也就没有保存历史版本，这可给我整难受了\n\n\n要不是之前有一个val-bot-test目录用于代码测试，那就几乎等同于阿狸bot的用户信息全部丢失，最最最最难受的，还是我bot记录了好久的服务器日志啊，本来有3w多cmd的，现在恢复的文件还是几个月前的，数据量少了好多……\n\n唉，不说这些玩意了，今天我们要来康康怎么在linux下用tar命令打包和压缩文件夹，留作备份！\n2.tar命令打包参考 https://blog.csdn.net/catoop/article/details/40651947\n2.1 将整个目录打包以当前目录下的code文件夹为例\ntar -cvf ./code.tar ./code #仅打包不压缩tar -zcvf ./code.tar.gz ./code #打包，gzip压缩tar -jcvf ./code.tar.bz2 ./code #打包，bzip2压缩\n\n注意，这里的./code.tar是生成的目标文件，./code是源路径；目标文件的命名没有要求，命名成tar.gz/tar.bz2只是一个用于标明的好习惯\n2.2 查看压缩包里面的文件下面的命令是分别查看不同压缩格式的压缩包里面的文件目录的，其会直接在bash打印出来\ntar -tvf ./code.tar tar -ztvf ./code.tar.gz tar -jtvf ./code.tar.bz2 \n\n2.3 解压文件解压的文件会默认存在当前目录\ntar -xvf ./code.tar tar -zxvf ./code.tar.gz tar -jxvf ./code.tar.bz2 \n\n2.4 解压一部分文件假设我们需要解压code.tar里面test目录的文件，可以用下面的命令\ntar -xvf ./code.tar test\n\n知道这几个用法，就基本够用了！\n2.5 打包的时候忽略一些文件现在我需要压缩的是code里面的python运行代码，其中会有一个没有用的__pycache_，我们应该将其忽略，以减小压缩包体积\n下面的命令就是忽略code路径下所有__pycache__文件或者文件目录\ntar -zcvf code.tar.gz --exclude=*__pycache__ code\n\n注意，忽略的路径后面不需要带/，否则还是会被打包。比如下面的用法就是错的\ntar -zcvf code.tar.gz --exclude=*__pycache__/ code #错误\n\n3.一定要多多备份像我今天出现这样的情况，实在是不应该！\n阿狸bot是有vip业务的，vip信息文件的丢失，也很有可能会导致vip用户的丢失。更别提还有广大的普通用户在使用阿狸呢。\n平时我知道要在云盘、nas备份自己的代码、笔记、学习资料等等个人文件，却忘记了云服务器上的bot同样需要备份\n\n这下可算是吸取教训了，一次性把所有bot都给备份了！\n","categories":["玩上Linux"],"tags":["Linux","阿狸开发日志","Python"]},{"title":"【Linux】线程概念 | 互斥","url":"/posts/1309150756/","content":"千呼万唤始出来，终于到多线程方面的学习了！\n\n\n\n所用系统Centos7.6  本文的源码👉【传送门】\n\n[TOC]\n1.线程的概念在之前的linux学习中，已经接触过了进程的概念，进程由一个task_struct结构体在操作系统中进行描述，CPU在执行的时候，会依照进程时间片进行轮询调度，让每一个进程的代码都得以推进，实现多个进程的同时运行\n而线程，可以理解为是一种轻量化的进程，每一个进程都可以创建多个线程，并行执行不同的代码\n进程:线程 = 1:N\n\n在之前的多进程操作中，我们使用fork接口创建子进程，通过if/else语句判断，实现对特定执行流的划分\n\n创建子进程时，需要拷贝一份task_struct/mm_struct并创建页表\n当子进程修改了一部分变量，会发生写时拷贝，修改页表在物理内存上的映射\n\n可以看到，当我们需要创建一个新进程的时候，操作系统需要做不少的工作\n\n1.1 执行流让我们康康执行流这一概念：\n\n单执行流进程：内部只有一个执行流的进程\n多执行流进程：内部有多个执行流的进程\n\n进程=内核数据结构+代码和数据，在内核视角中，进程是承担分配系统资源的基本实体（进程的基座属性）\n\n进程：向系统申请资源的基本单位（系统分配）\n线程：系统调度的基本单位\n\n\n1.2 线程创建时做了什么？那线程的创建需要做什么呢？\n\n不同操作系统的实现不同，一般用tcb指代描述线程的结构体\n\n在linux中，没有进程和线程在概念上的区分，其以执行流为基础，线程只是简单的对task_strcut进行了二次封装；线程是在进程内部运行的执行流\n\n说人话：linux下的线程是用进程模拟的\n换句话：linux下的进程也是一种线程，但是其只有一个执行流\n对于CPU而言，其看到的task_struct都是一个执行流\n\n而创建线程时也有说法，线程隶属于某一个进程下，并不是独立的子进程，所以不需要创建新的mm_struct和页表映射，创建的效率高于子进程。只需要将task_struct指向原有进程的mm_struct和页表即可。\n\n同样的，CPU在推行多线程操作的时候，无须执行pcb切换，就能实现单进程多个线程操作的同时进行，执行效率变高！\n\n线程是一种 Light weight process 轻量级进程，简称LWP；是现代linux对线程提供的原生支持\n\n1.3 内核源码中的体现在task_strcut结构体中，有这么一个字段\n/* CPU-specific state of this task */\tstruct thread_struct thread;\n\n转到定义，其内部都是一些寄存器信息，用于标识这个线程的基本信息。这也是linux中没有单独实现线程tcb的体现，而是用task_struct来模拟的（task_struct中包含线程的信息）\nstruct thread_struct &#123;\t/* Cached TLS descriptors: */\tstruct desc_struct\ttls_array[GDT_ENTRY_TLS_ENTRIES];\tunsigned long\t\tsp0;\tunsigned long\t\tsp;#ifdef CONFIG_X86_32\tunsigned long\t\tsysenter_cs;#else\tunsigned long\t\tusersp;\t/* Copy from PDA */\tunsigned short\t\tes;\tunsigned short\t\tds;\tunsigned short\t\tfsindex;\tunsigned short\t\tgsindex;#endif#ifdef CONFIG_X86_32\tunsigned long\t\tip;#endif#ifdef CONFIG_X86_64\tunsigned long\t\tfs;#endif\tunsigned long\t\tgs;\t/* Hardware debugging registers: */\tunsigned long\t\tdebugreg0;\tunsigned long\t\tdebugreg1;\tunsigned long\t\tdebugreg2;\tunsigned long\t\tdebugreg3;\tunsigned long\t\tdebugreg6;\tunsigned long\t\tdebugreg7;\t/* Fault info: */\tunsigned long\t\tcr2;\tunsigned long\t\ttrap_no;\tunsigned long\t\terror_code;\t/* floating point and extended processor state */\tunion thread_xstate\t*xstate;#ifdef CONFIG_X86_32\t/* Virtual 86 mode info */\tstruct vm86_struct __user *vm86_info;\tunsigned long\t\tscreen_bitmap;\tunsigned long\t\tv86flags;\tunsigned long\t\tv86mask;\tunsigned long\t\tsaved_sp0;\tunsigned int\t\tsaved_fs;\tunsigned int\t\tsaved_gs;#endif\t/* IO permissions: */\tunsigned long\t\t*io_bitmap_ptr;\tunsigned long\t\tiopl;\t/* Max allowed port in the bitmap, in bytes: */\tunsigned\t\tio_bitmap_max;/* MSR_IA32_DEBUGCTLMSR value to switch in if TIF_DEBUGCTLMSR is set.  */\tunsigned long\tdebugctlmsr;\t/* Debug Store context; see asm/ds.h */\tstruct ds_context\t*ds_ctx;&#125;;\n\n当我们创建一个线程时，Linux内核会为该线程分配一个唯一的线程标识符（TID），并在内部维护线程相关的数据结构。然而，每个线程在内核中仍然被视为独立的进程，并且共享同一个进程地址空间、文件描述符表以及其他进程资源。\n通过使用进程模拟线程的方式，Linux实现了以下优势：\n\n轻量级：相比于传统意义上的进程，线程的创建和销毁更加高效，占用的系统资源更少。\n\n并发性：线程之间可以并发执行，通过共享相同的地址空间，线程可以直接访问进程的内存区域，简化了线程间的通信和同步操作。\n\n兼容性：由于早期版本的Linux内核并不直接支持线程，使用进程模拟线程的方式使得老旧的代码可以无缝迁移到新的内核版本中运行。\n\n\n现代的Linux内核已经提供了对线程的原生支持，称为轻量级进程（Lightweight Process，LWP）。通过使用LWP，每个线程都可以在内核中独立地进行调度和管理，而无需依赖进程资源。这种方式更加高效，并且更符合线程概念的定义。然而，为了保持向后兼容性，Linux仍然保留了使用进程模拟线程的机制。\n1.4 线程的私有物我们知道，一个进程是完全独立的。但是线程并不是，因为线程只是进程的一个执行流分支，它从进程继承了绝大部分属性（也可以理解为是共享的）\n\n用户id和组id\n进程id\n进程工作目录\n文件描述符表\n信号的处理方式（如果进程有对某个信号进行自定义捕捉，那么线程会共用这个自定义捕捉）\n和进程共用一个堆\n\n但线程也会有自己的私有物！\n\n线程id\n线程独立的寄存器（因为线程也需要执行代码，有上下文数据）\n栈（线程运行函数时也需要压栈和出栈，必须独立否则执行流会出问题）\nerrno（单独的报错信息）\n信号屏蔽字（可以单独针对某个信号处理）\n线程调度优先级\n\n1.5.3 线程结构体在Linux内核中的struct thread_struct结构体中包含了如下字段，这些字段有助于模拟线程。因为我们对linux内核代码的了解并不多，这里只做基本认识，可以和上方的struct thread_struct结构体源码对照着看\n\ntls_array: 这个字段表示线程的TLS（Thread Local Storage）描述符数组。TLS是一种机制，允许线程在其单独的存储区域中存储和访问变量。每个线程都可以有自己的TLS数组。\n\nsp0和sp: 这些字段表示线程的栈指针，用于管理线程的函数调用栈。\n\nsysenter_cs, usersp, es, ds, fsindex, gsindex: 这些字段用于保存与线程相关的段寄存器信息，例如代码段选择子、用户栈指针以及各种段寄存器的索引。\n\nip, fs, gs: 这些字段记录线程的指令指针和段寄存器的值。\n\ndebugreg0, debugreg1, debugreg2, debugreg3, debugreg6, debugreg7: 这些字段用于保存硬件调试寄存器的值，用于调试目的。\n\ncr2, trap_no, error_code: 这些字段记录了发生异常或中断时的相关信息。\n\nxstate: 这个字段用于保存浮点数和扩展处理器状态。\n\n\n1.5 线程优缺点1.5.1 缺点\n线程是缺乏保护的（不具备进程的独立性）这也被称为健壮性；线程的健壮性低\n\n当进程被停止的时候，其下线程也会被停止\n当有一个线程出bug了，会让整个进程退出\n多线程中的全局变量问题\n\n\n线程缺乏访问控制，在一个线程中调用某些操作系统的接口会影响整个进程\n\ndebug多线程较麻烦\n\n如果同一个进程所用线程太多，可能会无法充分利用cpu性能而造成性能损失\n\n\n1.5.2 优点\n线程开辟的消耗低于进程，占用的资源低于进程\n切换线程无须切换页表等结构，速度快！\n等待慢IO设备时，进程可以继续执行其他操作；将部分IO操作重叠，能让进程同时等待多个IO操作；\n能充分利用处理器的可并行数量；\n\n1.6 linux下线程和进程的区别在Linux系统中，进程和线程是两个并发执行的基本单位。它们之间有以下区别：\n\n资源占用：每个进程都有独立的地址空间、文件描述符、堆栈等资源，而线程共享进程的资源，包括地址空间、文件描述符等。因此，创建线程比创建进程更加轻量级。在线程直接切换也比进程切换效率更高。\n调度：进程是由操作系统进行调度和分配资源的基本单位，而线程是进程的执行单元，由操作系统进行调度和分配CPU时间片。\n通信和同步：进程间通信需要使用操作系统提供的机制，如管道、消息队列、共享内存等。而线程之间可以通过共享内存的方式直接进行通信。此外，线程之间的同步更加方便，可以使用互斥锁、条件变量等机制。\n独立性：进程之间相互独立，一个进程的崩溃不会影响其他进程。而线程共享进程的资源，一个线程的崩溃会导致整个进程的崩溃。\n\n总结来说，进程是资源分配的基本单位，线程是执行的基本单位。进程之间相互独立，线程之间共享部分资源。\n在实际应用中，需要根据情况的不同，选择使用进程或线程来实现并发执行。\n\n2.基础函数linux下提供了pthread库来实现线程操作\n2.1 pthread_create人如其名，这个函数的作用是来创建新进程的\n#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr,\t\t\t\t\tvoid *(*start_routine) (void *), void *arg);//Compile and link with -pthread.\n\n\n第一个参数是一个输出型参数，为该线程的id\n第二个参数是用于指定线程的属性，暂时设置为NULL使用默认属性\n第三个参数是让该进程执行的函数，这是一个函数指针，参数和返回值都为void*\n第四个参数是传给第三个执行函数的参数\n\n创建正常后返回0，否则返回错误码\n注意，使用了pthread库后，需要在编译的时候指定链接，-lpthread\ntypedef unsigned long int pthread_t;//线程id\n\n创建线程后打印可以发现，线程id是一个非常大的值，并不像进程PID那么小\n//cout &lt;&lt; &quot;pthread_create &quot;&lt;&lt; t1 &lt;&lt; &quot; &quot; &lt;&lt; t2 &lt;&lt; endl;pthread_create 140689524995840 140689516603136\n\n可以通过printf %x的方式打印十六进制，来减少打印长度\n//printf(&quot;0x%x  0x%x\\n&quot;,t1,t2);0x393d0700  0x38bcf700\n\n2.2 pthread_join光是创建进程还不够，我们还需要对进程进行等待\n#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);//Compile and link with -pthread.\n\n这里第一个参数是线程的id，第二个参数是进程的退出状态\n等待成功后返回0，否则返回错误码\n\njoin可以在线程退出后，释放线程的资源\n同时获取线程对应的退出码\njoin还能保证是新创建的线程退出后，主线程才退出\n\n2.2.1 基础的多线程操作有了这两个，我们就能写一个简单的多线程操作了\n#include&lt;iostream&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;using namespace std;void* func1(void* arg)&#123;    while(1)    &#123;        cout &lt;&lt; &quot;func1 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;&#125;void* func2(void* arg)&#123;    while(1)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;&#125;int main()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    while(1)    &#123;        cout &lt;&lt; &quot;this is main::&quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);    &#125;    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);    return 0;&#125;\n\n执行会发现，多线程操作成功启动，且打印的进程pid都是一样的，代表其隶属于同一个进程\n\n我们可以用下面的语句来查看轻量级进程\nps -aL\n\n可以看到，执行了程序之后，出现了3个PID相同，LWP不同的轻量级进程，这就代表我们的多线程操作成功了；\n同时也能看到，在多线程操作时，谁先运行是不确定的。这是由系统调度随机决定的\n\n2.2.2 C++的多线程操作C++11也支持了多线程操作，其封装了操作系统的pthread接口，基本的操作很相似\nvoid test2()&#123;    thread t1(func1,(char*)&quot;test1&quot;);    thread t2(func2,(char*)&quot;test2&quot;);       while(1)    &#123;        cout &lt;&lt; &quot;this is main:: &quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);    &#125;    t1.join();    t2.join();&#125;\n\n执行后的效果是一样的，C++的thread库还可以传入functional封装的可调用函数，和lambda表达式\n\n2.3 线程退出2.3.1 retvalint pthread_join(pthread_t thread, void **retval);\n\n我们可以使用该函数的第二个参数来获取线程所执行方法的返回值。retval是一个二级指针，是一个输出型参数\n#include&lt;iostream&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;using namespace std;void* func1(void* arg)&#123;    int a = 5;    while(a--)    &#123;        cout &lt;&lt; &quot;func1 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func1 exit&quot; &lt;&lt; endl;    return (void*)100;&#125;void* func2(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func2 exit&quot; &lt;&lt; endl;    return (void*)10;&#125;void test3()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    int a = 15;    while(a--)    &#123;        cout &lt;&lt; &quot;this is main:: &quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);    &#125;    void* r1;    void* r2;    pthread_join(t1,&amp;r1);    pthread_join(t2,&amp;r2);    sleep(2);    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;&#125;int main()&#123;        test3();    return 0;&#125;\n\n可以看到，当两个线程退出之后，主函数中成功打印出了他们的返回值\n\n注意，因为我们是将void*的指针强转为int，如果在打印的时候强转为int，会出现精度丢失的报错，需要使用long long来规避报错\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ makeg++ test.cpp -o test -lpthread -std=c++11.test.cpp: In function ‘void test3()’:test.cpp:88:35: error: cast from ‘void*’ to ‘int’ loses precision [-fpermissive]     cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (int)r1 &lt;&lt; endl;                                   ^make: *** [test] Error 1\n\n2.3.2 pthread_exit除了直接return，线程还可以调用pthread_exit函数实现退出\n#include &lt;pthread.h&gt;void pthread_exit(void *retval);//Compile and link with -pthread.\n\n效果完全一样\n//return (void*)10;pthread_exit((void*)10);\n\n注意，主线程main中调用该函数，并不会导致进程退出\nvoid* func2(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; &quot; tid: &quot; &lt;&lt; syscall(SYS_gettid) &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func2 exit&quot; &lt;&lt; endl;    pthread_exit((void*)10);&#125;void test5()&#123;    pthread_t t1,t2;\t//func2会执行10s    pthread_create(&amp;t1,nullptr,func2,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    sleep(1);    pthread_detach(t1);    pthread_detach(t2);    sleep(1);&#125;int main()&#123;        test5();    pthread_exit(0);//主线程提前退出    cout &lt;&lt; &quot;main exit&quot; &lt;&lt; endl;    return 0;&#125;\n\n可以看到，主函数已经调用了pthread_exit退出了，但是线程还在跑\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc2 thread:: 1 :: 9474 tid: 9475func2 thread:: 2 :: 9474 tid: 9476func2 thread:: 1 :: 9474 tid: 9475func2 thread:: 2 :: 9474 tid: 9476main exitfunc2 thread:: 1 :: 9474 tid: 9475func2 thread:: 2 :: 9474 tid: 9476\n\n2.3.3 ptrhead_cancel除了上面俩种方式，我们还可以在main里面直接把某一个线程给关掉\n#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);//Compile and link with -pthread.\n\nvoid test3()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    int a = 15;    while(a--)    &#123;        cout &lt;&lt; &quot;this is main:: &quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);        if(a==11)        &#123;            pthread_cancel(t1);            pthread_cancel(t2);            break;        &#125;    &#125;    void* r1;    void* r2;    pthread_join(t1,&amp;r1);    pthread_join(t2,&amp;r2);    sleep(2);    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;&#125;\n\n被提前终止的进程，返回值都为-1\n\n2.3.4 为什么进程退出不会向主进程发送信号？要理清楚这个问题，还是需要深知一个概念：线程是进程中的一个执行流，它并不是一个独立的进程。\n先来回顾一下进程退出的几种情况：\n\n代码跑完，结果正确\n代码跑完，结果有问题\n代码出错了，异常\n\n线程退出的情况也是这样，但线程如果因为某些异常退出，进程也会同步退出！\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testthis is main:: 13845Floating point exception[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ \n\n由此可见，线程异常 = 进程异常\n这里也就涉及到1.5.1中提到的线程健壮性问题，线程的异常会影响其他线程的运行，会导致进程整体异常退出。\n所以在join等待线程退出的时候，我们只需要考虑线程正常退出的情况；\n\n异常退出的时候恐怕也等不了😂因为进程也挂了\n\n2.3.5 exit任何一个线程执行exit()函数，都会导致整个进程退出\n\n2.4 pthread_detach等待是有性能损失的！默认创建的进程是joinable，也就是可以被主线程进行pthread_join等待的；\n这个函数的作用是让主线程不管创建出来的子线程，也不用去等待它，相当于取消了它的joinable属性；\n就好比父进程不想管子进程的时候，将SIGCHLD设置为SIG_IGN\n#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread);//Compile and link with -pthread.\n\n一个线程是否应该等待，取决于是否需要获取该线程的返回值；如果无须获取返回值，则使用分离能提高运行效率\n\n即便线程所运行的函数return是无效的，但我们可以用输出型参数来获取返回值\n\n2.4.1 实操使用也很简单，只需要指定线程的id就行了\nvoid test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    while(1)    &#123;        cout &lt;&lt; &quot;this is main - global: &quot; &lt;&lt; global &lt;&lt; &quot; - &amp;global: &quot; &lt;&lt; &amp;global &lt;&lt; endl;        sleep(1);    &#125;    pthread_detach(t1);    pthread_detach(t2);&#125;\n\n运行上也不会有什么区别，但是我们已无法获取到该线程的返回值\n\n\n2.4.2 detach后join但如果我们在detach之后又进行pthread_join会发生什么呢？\nvoid* func3(void* arg)&#123;    pthread_detach(pthread_self());    int a = 7;    while(a--)    &#123;        printf(&quot;func thread:%s - global:%d - &amp;global:%p\\n&quot;,(char*)arg,global,&amp;global);        global++;        sleep(1);    &#125;    cout &lt;&lt; &quot;func exit&quot; &lt;&lt; endl;    return (void*)10;&#125;void test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    void* r1=nullptr;    void* r2=nullptr;    pthread_join(t1,&amp;r1);    pthread_join(t2,&amp;r2);    sleep(2);    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;&#125;\n\n诶，这不还是获取到了返回值吗？这么说，他这个detach岂不是没用？\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc thread:1 - global:103 - &amp;global:0x7fb5648b06fcfunc thread:2 - global:103 - &amp;global:0x7fb5640af6fcfunc thread:1 - global:104 - &amp;global:0x7fb5648b06fcfunc thread:2 - global:104 - &amp;global:0x7fb5640af6fcfunc exitfunc exitretval 1 : 10retval 2 : 10[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ \n\n实际上，当我们create一个线程的时候，它会先去执行线程创建的相关代码，此时main又直接去执行后面的代码了；此时pthread_join的调用是成功的，因为线程自己的detach代码还没有被执行！\n\n而如果我们在create之后，等线程开始运行了在执行detach，此时join就会失败\nvoid test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    sleep(2);    pthread_detach(t1);    pthread_detach(t2);    sleep(1);    void* r1=nullptr;    void* r2=nullptr;    int ret = pthread_join(t1,&amp;r1);    cout &lt;&lt; ret &lt;&lt; &quot;:&quot; &lt;&lt; strerror(ret) &lt;&lt; endl;    ret = pthread_join(t2,&amp;r2);    cout &lt;&lt; ret &lt;&lt; &quot;:&quot; &lt;&lt; strerror(ret) &lt;&lt; endl;    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;    sleep(20);&#125;\n\n打印错误码也能看到，系统提示我们给join传入了一个无效的参数，线程依旧在正常运行\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc thread:1 - global:101 - &amp;global:0x7f2d439136fcfunc thread:2 - global:101 - &amp;global:0x7f2d431126fcfunc thread:2 - global:102 - &amp;global:0x7f2d431126fcfunc thread:1 - global:102 - &amp;global:0x7f2d439136fc22:Invalid argument22:Invalid argumentretval 1 : 0retval 2 : 0func thread:2 - global:103 - &amp;global:0x7f2d431126fcfunc thread:1 - global:103 - &amp;global:0x7f2d439136fc\n\n所以正确的做法，应该是在主线程中分离线程，不要在线程自己的代码中执行detach，否则就会出现上面的分离失败的情况\n2.4.3 线程分离后，主线程先退出如果执行完毕pthread_detach后，主线程提前退出了，会发生什么？\nvoid test5()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    sleep(1);    pthread_detach(t1);    pthread_detach(t2);    sleep(2);    cout &lt;&lt; &quot;main exit&quot; &lt;&lt; endl;&#125;\n\n显而易见，线程也跟着一并退出了\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc thread:1 - global:100 - &amp;global:0x7f01cd49a6fcfunc thread:2 - global:100 - &amp;global:0x7f01ccc996fcfunc thread:2 - global:101 - &amp;global:0x7f01ccc996fcfunc thread:1 - global:101 - &amp;global:0x7f01cd49a6fcfunc thread:2 - global:102 - &amp;global:0x7f01ccc996fcfunc thread:1 - global:102 - &amp;global:0x7f01cd49a6fcmain exit[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ \n\n因为线程没有独立性，完全属于这个进程。不可能出现你家房子塌了，你自己的房间还在的情况😂\n\n进程退出的时候，操作系统就回收了这个进程的程序地址空间，连资源都被释放了，线程就没有办法继续运行，自然就退出了。\n\n所以，为了避免这种问题，一般我们分离线程的时候，都倾向于让主线程保持在后台运行（常驻内存的程序）\n2.5 gettid&#x2F;syscall该函数是一个系统接口，但它并不能直接运行\nNAME       gettid - get thread identificationSYNOPSIS       #include &lt;sys/types.h&gt;       pid_t gettid(void);       Note:  There  is  no  glibc wrapper for this system call; see       NOTES.\n\n我们需要用syscall函数来调用该接口，这也是第一次接触到syscall函数\n#define _GNU_SOURCE         /* See feature_test_macros(7) */#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;   /* For SYS_xxx definitions */int syscall(int number, ...);\n\n在syscall的man手册中，我们就能看到获取线程id相关的示例\n//EXAMPLE#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;int main(int argc, char *argv[])&#123;    pid_t tid;    tid = syscall(SYS_gettid);    tid = syscall(SYS_tgkill, getpid(), tid);&#125;\n\n用下面的代码进行测试\nvoid* func2(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; &quot; tid: &quot; &lt;&lt; syscall(SYS_gettid) &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func2 exit&quot; &lt;&lt; endl;    pthread_exit((void*)10);&#125;void test1()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func2,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);       while(1)    &#123;        printf(&quot;tis is main - pid:%d - tid:%d\\n&quot;,getpid(),syscall(SYS_gettid));        sleep(1);    &#125;    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;\n\n运行可以看到进程打印出了相同的PID和不同的TID，其TID对应的就是ps -aL中显示的LWP编号\n\n3.相关概念3.1 线程id是什么？前面提到过，pthread_t是线程独立的id，本质上是一个无符号长整形，打印出来后，是一个很大的数字。这个数字有什么特别的含义吗？\n先来回顾一下线程的基本概念：\n\n线程是一个独立的执行流\n线程在运行过程中，会产生自己的临时数据\n线程调用函数的压栈出栈操作，有自己独立的栈结构\n\n因此，既然有一个独立的栈结构，其就需要有一个标识符来指向这个栈结构，方便程序运行的时候进行调用！\n所以，pthread_t本质上是一个地址！其指向的就是这个线程的控制块，其内部包含了这个线程的独立栈结构。\n//printf(&quot;0x%x  0x%x\\n&quot;,t1,t2);0x393d0700  0x38bcf700 //打印出来的结果也很像地址\n\n3.2 pthread库pthread库并不是一个内核级的接口库，其实际上是封装了系统的clone/vfork等接口，从而为我们提供的用户级的线程库。\n使用pthread库创建的进程，和内核中的LWP是1:1的\n\npthread是一个动态库，所以在编译的时候需要加上链接选项\ng++ test.cpp -o test -lpthread\n\n在我的 动静态库 的博客中有讲述过，动态库是在运行的时候动态链接的，其会将库中的代码映射到进程地址空间的共享区，从而调用动态库中的代码\n\n举个例子，当我们调用pthead_create的时候，进程会跳到共享区中，执行动态库中的代码，创建成功后返回自己的代码区，完成一个线程的创建\n\n而线程所用的独立栈，也是pthread库帮我们管理的。因为有共享区的存在，我们能通过pthread_t直接访问到动态库中管理的线程的控制模块，从而完成线程的压栈、出栈等等操作\n\n下为linux的pthreadtypes.h中的部分内容\n# define __SIZEOF_PTHREAD_ATTR_T 36typedef unsigned long int pthread_t;union pthread_attr_t&#123;  char __size[__SIZEOF_PTHREAD_ATTR_T];  long int __align;&#125;;#ifndef __have_pthread_attr_ttypedef union pthread_attr_t pthread_attr_t;# define __have_pthread_attr_t\t1#endif\n\n3.3 线程的局部存储假设我们有一个全局变量，我们想让创建出来的每一个线程，都能独立的使用这个全局变量，那就需要用到线程的局部存储\nint global = 10;//全局变量void* func3(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func thread &quot; &lt;&lt; (char*)arg &lt;&lt;  &quot; - global: &quot; &lt;&lt; global &lt;&lt; &quot; - &amp;global: &quot; &lt;&lt; &amp;global &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func exit&quot; &lt;&lt; endl;&#125;void test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    while(1)    &#123;        cout &lt;&lt; &quot;this is main - global: &quot; &lt;&lt; global &lt;&lt; &quot; - &amp;global: &quot; &lt;&lt; &amp;global &lt;&lt; endl;        sleep(1);    &#125;    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;\n\n执行，不管是主线程还是线程，都打印的是相同的值和地址\n\n如果在执行的函数func3中添加一个global++，则能观察到所有线程都是公用的一个变量，这里的+是同步的。\n\n如果我们想让int global变成局部变量，则需要在它之前加上一个__thread\n__thread int global = 100;//可以让线程独立使用的全局变量\n\n此时可以看到，两个线程和主线程打印的global变量地址不同，他们的++操作是独立的，变量的值也是独立的\n\n这就实现了将某一个变量划分给线程进行局部存储\n4.线程互斥问题4.1 临界资源在先前共享内存 信号量的博客中，已经涉及到了这部分的内容；即关于操作原子性和访问临界资源&#x2F;临界区的相关问题。\n\n能被多个进程&#x2F;线程看到的资源，被称为临界资源\n进程&#x2F;线程访问临界资源的代码，被称为临界区\n\n在线程中，同样存在访问临界资源而导致的冲突：\n\n线程A对一个全局变量val进行了-1操作，当操作执行到放回内存那一步的时候，发生了线程切换，线程B开始工作\n线程B同样访问了该全局变量val，对它进行了-10操作，此时因为线程A的-1操作尚未写回内存，全局变量val还是保持初值。线程b将-10之后的全局变量val写回了内存\n又发生了线程切换，跳转到线程A停止的线程上下文数据中开始执行，将全局变量写入内存\n这时候，线程B的-10操作就被A的写入覆盖了！\n\n举个实际点的例子，以100为全局变量的初始值\n\n线程A执行-1，100-1=99，还未写入内存时，就线程切换\n线程B取到的全局变量还是100，对其执行-10，并写入内存， 此时全局变量为90\n返回线程A继续执行写入内存操作，全局变量又被复写成了99；相当于B的操作是无效的\n\n这种条件下会产生很多问题，也是我们不希望看到的！\n4.2 原子&#x2F;互斥性这种时候，我们就需要保证访问该全局变量的操作是原子的，不能出现中间状态；\n也应该是互斥的，不能出现两个线程同时访问一份资源的情况\n\n互斥性：任何时候都只有一个执行流在访问某一份资源\n\n\n操作系统维护原子性，就必须保证该操作只用一条汇编语句执行（这样才不会出现进程&#x2F;线程切换导致的问题）这个在后面会详细介绍\n为了达成这一目的，我们需要给线程的操作加锁\n4.3 线程加锁线程加锁涉及到几个操作：\n\n提供一把锁\n在需要维持原子性（临界区）的位置加上锁\n访问临界区结束后，打开锁\n进程结束后，把锁丢了\n\n接下来就让我们一一解决这些问题\n4.3.1 pthread_mutex_initpthread线程库在设计之初就考虑到了线程安全问题，所以它便给我们提供了加锁相关的操作。\n#include &lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex);int pthread_mutex_init(pthread_mutex_t *restrict mutex,                       const pthread_mutexattr_t *restrict attr);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\n首先我们需要定义一把锁，类型是pthread_mutex_t\n\n如果我们需要的是一把全局变量的锁，则可以直接使用赋值PTHREAD_MUTEX_INITIALIZER给这把锁初始化\n如果是一把局部的锁，则使用函数pthread_mutex_init进行初始化\n\n初始化的方法很简单，传入锁和对应的属性就行。此时我们忽略属性问题，设置为NULL使用默认属性\n//使用默认属性的全局锁or静态static锁//无须调用函数初始化，可以直接用pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//使用函数进行初始化局部的锁（当然也可以初始化全局锁）pthread_mutex_t mutex;//定义一把锁pthread_mutex_init(&amp;mutex, nullptr);//初始化pthread_mutex_destroy(&amp;mutex);//销毁\n\n4.3.2 加锁&#x2F;解锁有了锁，那么就可以在需要的位置加上这把锁\n#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);\n\n其中lock是阻塞式加锁，如果你调用这个接口的时候，锁正在被别人使用，则会在这里等待；trylock是非阻塞加锁，如果你调用该接口时锁正被使用，则直接return返回（相当于看看锁能否被获取）\nThe pthread_mutex_trylock() function shall be equivalent to pthread_mutex_lock(), except that if the mutex object referenced  by  mutex  is  currently locked (by any thread, including the current thread), the call shall return immediately. \n\n加了锁之后，在需要的位置unlock解锁；\n\n加锁和解锁操作本身是原子的，不会出现冲突\n加了锁之后，可以理解为加锁解锁操作中间的代码也是原子性的，必须要运行到解锁位置才能让另外一个线程&#x2F;进程执行这里的代码\n加锁的本质是让线程执行临界区的代码串行化\n\n4.3.3 加锁的注意事项\n只对临界区加锁；锁保护的就是临界区\n加锁的粒度越细越好（即加锁的区域越小越好。如果访问的不是临界区，则可以不考虑加锁）\n加锁是编程的一种规范；在实际问题中，我们要保证访问某一临界资源的所有操作都要加上锁。不能出现函数A加锁了，但是B没有加锁的情况（这样会导致A的加锁也没有意义）\n\n4.4 示例-倒水问题\n以倒水为示例，假设杯子容量为10000，装满了水就会溢出。我们使用多个线程对这个杯子加水，直到满了之后线程退出\n#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;signal.h&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/syscall.h&gt;using namespace std;//临界资源int water = 0;//全局变量int cup = 10000;//杯子的容量void* func(void* arg)&#123;    while(1)    &#123;        if(water&lt;cup)//临界区        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            water++;        &#125;        else        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水已经满了 &quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            break;        &#125;    &#125;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 线程退出&quot; &lt;&lt; &quot;\\n&quot;;    return (void*)0;&#125;int main()&#123;    pthread_t t1,t2,t3,t4;//创建4个线程    pthread_create(&amp;t1,nullptr,func,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func,(void*)&quot;t2&quot;);    pthread_create(&amp;t3,nullptr,func,(void*)&quot;t3&quot;);    pthread_create(&amp;t4,nullptr,func,(void*)&quot;t4&quot;);    //直接分离线程    pthread_detach(t1);    pthread_detach(t2);    pthread_detach(t3);    pthread_detach(t4);    while(1)    &#123;        ;//啥都不干    &#125;    return 0;&#125;\n\n输出的结果如下，明明水已经满了，但还是会有部分线程报告水还没有满，且数字有很严重的偏差\nt3 水没有满：9993t3 水没有满：9994t3 水没有满：9995t3 水没有满：9996t3 水没有满：9997t3 水没有满：9998t3 水没有满：9999t3 水已经满了t3 线程退出 水没有满：2723t4 水已经满了t4 线程退出0t2 水已经满了t2 线程退出t1 水没有满：9668t1 水已经满了t1 线程退出\n\n多运行几次，也能发现相同的问题\nt2 水没有满：9997t2 水没有满：9998t2 水没有满：9999t2 水已经满了 10000t2 线程退出t4 水没有满：1889t4 水已经满了 10001t4 线程退出t3 水没有满：0t3 水已经满了 10002t3 线程退出t1 水没有满：0t1 水已经满了 10003t1 线程退出\n\n4.4.1 只有一个线程在工作？除了偏差外，还有一个小问题，往前翻打印记录，会发现一直都是某一个线程在倒水，其他线程似乎啥事没有干？\nt3 水没有满：9786t3 水没有满：9787t3 水没有满：9788t3 水没有满：9789t3 水没有满：9790\n\n这是因为当运行t3的时候，t3在while循环中继续运行的消耗，小于切换到其他线程的消耗。所以控制块就让t3一直运行，直到它break退出循环\n此时我们只需要加上一个usleep，增加每一个while循环中需要处理的负担，就能让所有线程都来倒水\n//usleep功能把进程挂起一段时间， 单位是微秒（百万分之一秒）#include &lt;unistd.h&gt;int usleep(useconds_t usec);\n\n这是因为线程切换同样也是时间片到了，从内核返回用户态的时候做检测，切换至其他线程。\n添加usleep能创造更多内核&#x2F;用户的中间态，从而增多切换线程的次数\nvoid* func(void* arg)&#123;    while(1)    &#123;        if(water&lt;cup)        &#123;            usleep(100);//休息100微秒            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            water++;        &#125;        else        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水已经满了&quot; &lt;&lt; &quot;\\n&quot;;            break;        &#125;    &#125;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 线程退出&quot; &lt;&lt; &quot;\\n&quot;;    return (void*)0;&#125;\n\n但是这还是没有解决数字出错的问题\nt4 水没有满：9995t3 水没有满：9996t1 水没有满：9997t2 水没有满：9998t4 水没有满：9999t4 水已经满了 10000t4 线程退出t3 水没有满：10000t3 水已经满了 10001t3 线程退出t1 水没有满：10001t1 水已经满了 10002t1 线程退出t2 水没有满：10002t2 水已经满了 10003t2 线程退出\n\n4.4.2 加锁-问题解决这时候就需要请出我们的锁了\n//省略头文件int water = 0;//全局变量int cup = 10000;//杯子的容量pthread_mutex_t mutex;void* func(void* arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;mutex);        if(water&lt;cup)        &#123;            usleep(100);            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            water++;            pthread_mutex_unlock(&amp;mutex);            usleep(100);//假装喝水        &#125;        else        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水已经满了 &quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            pthread_mutex_unlock(&amp;mutex);            //此处也需要加锁，否则break出去之后其他线程会因为没有解锁而挂起            break;        &#125;    &#125;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 线程退出&quot; &lt;&lt; &quot;\\n&quot;;    return (void*)0;&#125;// 如果遇到2号信号，就在销毁锁后退出进程void des(int signo)&#123;    //销毁锁    pthread_mutex_destroy(&amp;mutex);    cout &lt;&lt; &quot;pthread_mutex_destroy, exit&quot; &lt;&lt; endl;    exit(0);&#125;int main()&#123;    signal(SIGINT,des);//自定义捕捉2号信号    pthread_mutex_init(&amp;mutex,nullptr);//初始化锁    pthread_t t1,t2,t3,t4;//创建4个线程    pthread_create(&amp;t1,nullptr,func,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func,(void*)&quot;t2&quot;);    pthread_create(&amp;t3,nullptr,func,(void*)&quot;t3&quot;);    pthread_create(&amp;t4,nullptr,func,(void*)&quot;t4&quot;);    //直接分离线程    pthread_detach(t1);    pthread_detach(t2);    pthread_detach(t3);    pthread_detach(t4);    while(1)    &#123;        ;//啥都不干    &#125;    return 0;&#125;\n\n运行可见，数字错误问题就没有出现了；但又出现了只有一个线程工作的问题\nt1 水没有满：9996t1 水没有满：9997t1 水没有满：9998t1 水没有满：9999t1 水已经满了 10000t1 线程退出t3 水已经满了 10000t3 线程退出t4 水已经满了 10000t4 线程退出t2 水已经满了 10000t2 线程退出^Cpthread_mutex_destroy, exit\n\n这还是因为线程切换的效率问题；也有可能是因为其它线程申请锁的时候，发现t1在用，就进行了阻塞等待而挂起\n\n只需要在解锁之后添加一个usleep模拟其他工作，就能让所有线程都跑起来\npthread_mutex_lock(&amp;mutex);if(water&lt;cup)&#123;    usleep(100);    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;    water++;    pthread_mutex_unlock(&amp;mutex);    usleep(100);//假装喝水&#125;\n\n没有出现数据错误，加锁的目的成功达到！\nt1 水没有满：9993t3 水没有满：9994t4 水没有满：9995t2 水没有满：9996t1 水没有满：9997t3 水没有满：9998t4 水没有满：9999t2 水已经满了 10000t2 线程退出t1 水已经满了 10000t1 线程退出t3 水已经满了 10000t3 线程退出t4 水已经满了 10000t4 线程退出^Cpthread_mutex_destroy, exit\n\n4.5 加锁的进一步解释在这个代码示例中，我们给中间的几行代码加了锁；但这并不意味着执行中间这部分代码的时候，就不会发生线程切换\npthread_mutex_lock(&amp;mutex);//加锁if(water&lt;cup)&#123;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;    water++;&#125;pthread_mutex_unlock(&amp;mutex);//解锁\n\n事实上，代码执行的任何地方，都可能发生进程&#x2F;线程的切换。但因为我们加了锁，切换的时候，其他线程要来访问这里的资源，就必须先申请锁\n此时锁在被切走的进线程手上，所以其他线程无法访问临界区的资源，也就不会发生数据不一致的问题。\n\n\n换言之，只要张三拿到了锁，那么它也就不担心自己的工作会被别人覆盖的问题；\n而对其他线程而言，张三访问临界区的工作，只有还没进入临界区和访问完毕临界区两种状态\n\n因此会导致一个问题，那就是线程切换的效率较低，其他线程出现了阻塞等待的情况；为了避免此问题，我们应该让访问临界区的操作快去快回，尽量不要在临界区里面干啥耗时的事情\n4.5.1 加锁原子性的保证\n备注：这部分仅供学习参考，若有错误，还请指出！\n\n那么加锁这个操作，是如何保证其自身的原子性呢？在加锁的途中不会发生线程切换吗？\n\n我找到了一张能大概说明汇编加锁过程的图片，其中movb的操作就是将al寄存器写为0，xchgb的操作是将al寄存器的内容和内存中mutex锁的值进行交换\n\n开始的时候，锁被正常初始化，内存中mutex的值为1（锁只会被初始化一次）\n线程A开始加锁，al寄存器和mutex的值发生交换，此时内存中的mutex为0，al为1\n判断al不为0，代表获取锁成功，线程A加锁成功\n线程B也来申请锁了，movb将al寄存器写为0，再和内存中的mutex交换后，发现还是0，则代表锁在别人手上，此时就需要挂起等待\n\n前面一直强调，线程是有自己独立的栈结构和上下文数据的，在加锁的这部分汇编操作中，同样可能会在任何地方发生线程切换。切换的时候，线程的上下文数据（图中寄存器的状态）会被保留下来，随这个线程一起被切换走\n所以线程A被切换的时候，属于它上下文中那个值为1的al寄存器也被切走了（注意，这里切走的是数据，al寄存器本身作为硬件，有且只有一个）\n由此看来，真正获取锁的操作，其实只有xchgb一条交换指令来完成，保证加锁操作只由一条汇编语句实现，就能保证该操作的原子性！\n解锁的方法就很简单了，movb将1写回mutex变量即可，也是一条汇编完成；而且一般情况下，解锁是不会有执行流和你抢的。\n\n其实加锁远不止一种方法，锁的种类有非常多，还有总线锁、旋转锁等等，每一个锁的实现都不太一样！上面提到的为互斥锁\n\n4.5.2 总线锁现在的CPU一般都有自己的内部缓存，根据一些规则将内存中的数据读取到内部缓存中来，以加快频繁读取的速度。现在服务器通常是多 CPU，更普遍的是，每块CPU里有多个内核，而每个内核都维护了自己的缓存，那么这时候多线程并发就会存在缓存不一致性，这会导致严重问题。\n\n总线锁就是将cpu和内存之间的通信锁住，使得在锁定期间，其他cpu处理器不能操作其他内存中数据，故总线锁开销比较大！\n总线锁的实现是采用cpu提供的LOCK#信号，当一个cpu在总线上输出此信号时，其他cpu的请求将被阻塞，那么该cpu则独占共享内存，相当于锁住了\n\n何为总线？\n\nCPU总线是所有CPU与芯片组连接的主干道，负责CPU与外界所有部件的通信，包括高速缓存、内存、北桥，其控制总线向各个部件发送控制信号、通过地址总线发送地址信号指定其要访问的部件、通过数据总线双向传输\n\n5.死锁死锁就是一种因为两放都不会释放对方需要的资源，从而陷入的永久等待状态\n5.1 死锁情况演示举个例子，张三拿了锁A，申请锁B的时候，发现锁B无法申请，而进入等待；李四拿了锁B，接下来他想申请锁A，结果发现张三拿着锁A，那就只能进入等待。这就陷入了一个僵局，张三想要李四的，李四想要张三的，谁都不让谁\n#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;signal.h&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/syscall.h&gt;using namespace std;pthread_mutex_t m1;//锁1pthread_mutex_t m2;//锁2void* func1(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m1);        pthread_mutex_lock(&amp;m2);        cout &lt;&lt; &quot;func1 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;void* func2(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m2);        pthread_mutex_lock(&amp;m1);        cout &lt;&lt; &quot;func2 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;int main()&#123;    pthread_mutex_init(&amp;m1,nullptr);    pthread_mutex_init(&amp;m2,nullptr);    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;t2&quot;);    //分离    pthread_detach(t1);    pthread_detach(t2);    while(1)    &#123;        cout &lt;&lt; &quot;main running...&quot; &lt;&lt;endl;        sleep(1);    &#125;    pthread_mutex_destroy(&amp;m1);    pthread_mutex_destroy(&amp;m2);    return 0;&#125;\n\n上面的这个代码便能模拟出这个情况，线程1先要了锁1，再要锁2；线程2先要锁2再要锁1，他们俩就容易打起来，造成死锁。\n运行代码的时候我们却发现，似乎并不是这样的，线程1好像还是成功拿到了俩把锁，并运行了起来\n[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./testmain running...func1 is running... t1func1 is running... t1main running...func1 is running... t1main running...func1 is running... t1main running...\n\n那是因为我们没有执行其他一些工作，从而将线程1和2申请锁的时间错开\n将代码改成下面这样，利用usleep让两个线程休眠不同时间，结果就不同了\nvoid* func1(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m1);        usleep(200);        pthread_mutex_lock(&amp;m2);        cout &lt;&lt; &quot;func1 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;void* func2(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m2);        usleep(300);        pthread_mutex_lock(&amp;m1);        cout &lt;&lt; &quot;func2 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;\n\n可以看到，此时只有主线程在运行，线程t1和t2出现了死锁！\n[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./testmain running...main running...main running...main running...\n\n\n5.2 死锁的条件\n互斥条件：某份资源同一时间只能由一个执行流访问\n请求与保持：一个执行流因请求某种资源进入阻塞等待，而不释放自己的资源（好比上面代码例子中两个线程都不释放自己的锁，又想要别人的锁）\n不剥夺条件：一个执行流已获得的资源，在未使用之前不能被剥夺（部分锁是允许被剥夺的）\n循环等待：若干执行流之间形成一种头尾相接的循环等待资源的状态\n\n一把锁也能造成死锁吗？答案是肯定的！\npthread_mutex_lock(&amp;m1);pthread_mutex_lock(&amp;m1);//两次申请同一把锁\n\n如果有人写出这种bug代码，那就会出现一把锁把自己死锁了；死锁本来就是代码的bug，所以这种低级错误也是死锁的情况之一😂\n5.3 避免死锁避免死锁，其中最简单明了的办法，就是破坏上面提到的死锁的4个条件；其中互斥条件没啥好办法破坏（除非你不加锁），更主要的是看另外3个条件是否能破坏！\n\n保持加锁顺序一致：不要出现上面代码中的线程a先申请锁1，线程b先申请锁2的情况。在不同的执行流中，按相同的顺序申请锁（比如线程a和b都是按锁1&#x2F;2的顺序申请的）一定程度上能破坏请求与保持条件\n降低加锁的粒度：锁保护的区域变小，加锁的粒度减小，能一定程度上避免锁未释放\n资源一次性分配：减少临时资源分开给的情况\n允许抢占：线程之间依靠优先级抢夺锁，这种情况就是锁允许被剥夺\n\n\n6.线程安全线程安全：多个线程并发执行同一段代码的时候，不会出现不同的结果\n线程不安全的情况：\n\n不保护临界资源\n在多线程操作中调用不可重入函数（概念见linux信号部分）\n返回指向静态变量的指针的函数\n\n线程安全：\n\n每个线程只操作局部变量，或者只对全局、静态变量只读不写\n接口对线程来说是原子操作（被锁保护）\n多个线程切换不会使函数接口的结果出现二义性\n多线程操作不调用不可重入函数\n\n注意，绝大多数的系统自带的库（比如C++的STL库）都是不可重入的\n\n不可重入是函数的一种性质，并不是它的缺点！如果一个库函数明明告知你了我是不可重入的，你还不加保护的在多线程操作中调用它，那么这段代码是有bug的，并不是库函数本身有问题\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】进程通信 | 信号","url":"/posts/2620423276/","content":"本篇博客让我们一起来康康信号部分的内容\n\n系统为CentOS7.6，完整代码见 Gitee\n\n\n\n[TOC]\n1.什么是信号在进程运行过程中，会出现各种各样的情况。操作系统需要用一套机制，来管理进程的事件\n\n进程退出\n进程停止\n进程恢复运行\n……\n\n同时，这套管理机制是异步的，属于一种软（件）中断\n\n和硬件中断打断处理器类似，软件中断打断进程的执，让其执行对应代码进行响应\n\n1.1 何为异步?\n以网购物品为例：当商品寄到自提点的时候，会给你发送一条取件的短信（信号）。此时我正在打游戏，没时间去处理这个快递（即取快递的行为并不是必须立马执行）\n但这个时候，我已经知道有一个快递到了（知道自己获取到了一个信号）本质上就是知道了一会要去取快递（一会要处理信号）\n当游戏一把打完了，我们就去取快递了（处理信号）\n\n这就是一种异步的过程。因为你不知道你的快递什么时候会到站点，进程也不知道自己什么时候会收到一个信号\n1.2 信号的种类使用kill -l命令，我们可以看到目前linux系统下64种不同的类型。\n其中前32为标准（Standard）信号，后32为实时（Real-time）信号；本篇博客只关注标准信号\n\n这些信号，都是linux系统中预定义的宏\n\n其中最常用的便是9号信号，来中断进程。平时我们最常用的CTRL+C，也是通过向进程发2号信号让进程退出的\n[muxue@bt-7274:~/git]$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX\n\n在include/linux/signal.h中，我们可以看到对信号的解释，以及其默认处理方法 default action\n/* * In POSIX a signal is sent either to a specific thread (Linux task) * or to the process as a whole (Linux thread group).  How the signal * is sent determines whether it&#x27;s to one thread or the whole group, * which determines which signal mask(s) are involved in blocking it * from being delivered until later.  When the signal is delivered, * either it&#x27;s caught or ignored by a user handler or it has a default * effect that applies to the whole thread group (POSIX process). * * The possible effects an unblocked signal set to SIG_DFL can have are: *   ignore\t- Nothing Happens *   terminate\t- kill the process, i.e. all threads in the group, * \t\t  similar to exit_group.  The group leader (only) reports *\t\t  WIFSIGNALED status to its parent. *   coredump\t- write a core dump file describing all threads using *\t\t  the same mm and then kill all those threads *   stop \t- stop all the threads in the group, i.e. TASK_STOPPED state * * SIGKILL and SIGSTOP cannot be caught, blocked, or ignored. * Other signals when not blocked and set to SIG_DFL behaves as follows. * The job control signals also have other special effects. * *\t+--------------------+------------------+ *\t|  POSIX signal      |  default action  | *\t+--------------------+------------------+ *\t|  SIGHUP            |  terminate\t| *\t|  SIGINT            |\tterminate\t| *\t|  SIGQUIT           |\tcoredump \t| *\t|  SIGILL            |\tcoredump \t| *\t|  SIGTRAP           |\tcoredump \t| *\t|  SIGABRT/SIGIOT    |\tcoredump \t| *\t|  SIGBUS            |\tcoredump \t| *\t|  SIGFPE            |\tcoredump \t| *\t|  SIGKILL           |\tterminate(+)\t| *\t|  SIGUSR1           |\tterminate\t| *\t|  SIGSEGV           |\tcoredump \t| *\t|  SIGUSR2           |\tterminate\t| *\t|  SIGPIPE           |\tterminate\t| *\t|  SIGALRM           |\tterminate\t| *\t|  SIGTERM           |\tterminate\t| *\t|  SIGCHLD           |\tignore   \t| *\t|  SIGCONT           |\tignore(*)\t| *\t|  SIGSTOP           |\tstop(*)(+)  \t| *\t|  SIGTSTP           |\tstop(*)  \t| *\t|  SIGTTIN           |\tstop(*)  \t| *\t|  SIGTTOU           |\tstop(*)  \t| *\t|  SIGURG            |\tignore   \t| *\t|  SIGXCPU           |\tcoredump \t| *\t|  SIGXFSZ           |\tcoredump \t| *\t|  SIGVTALRM         |\tterminate\t| *\t|  SIGPROF           |\tterminate\t| *\t|  SIGPOLL/SIGIO     |\tterminate\t| *\t|  SIGSYS/SIGUNUSED  |\tcoredump \t| *\t|  SIGSTKFLT         |\tterminate\t| *\t|  SIGWINCH          |\tignore   \t| *\t|  SIGPWR            |\tterminate\t| *\t|  SIGRTMIN-SIGRTMAX |\tterminate       | *\t+--------------------+------------------+ *\t|  non-POSIX signal  |  default action  | *\t+--------------------+------------------+ *\t|  SIGEMT            |  coredump\t| *\t+--------------------+------------------+ * * (+) For SIGKILL and SIGSTOP the action is &quot;always&quot;, not just &quot;default&quot;. * (*) Special job control effects: * When SIGCONT is sent, it resumes the process (all threads in the group) * from TASK_STOPPED state and also clears any pending/queued stop signals * (any of those marked with &quot;stop(*)&quot;).  This happens regardless of blocking, * catching, or ignoring SIGCONT.  When any stop signal is sent, it clears * any pending/queued SIGCONT signals; this happens regardless of blocking, * catching, or ignored the stop signal, though (except for SIGSTOP) the * default action of stopping the process may happen later or never. */\n\n这也意味着：即便没有接收到信号，进程也具备有识别和处理这个信号的能力！因为在系统中，已经给每一个进程和信号指定了默认动作！\n1.3 信号产生有很多情况会产生信号\n\n系统接口（kill命令）\n键盘产生（CTRL+R  CTRL+\\)\n软件条件（进程停止，进程运行完退出）\n硬件异常（比如除0错误）\n\n1.4 信号动作既然有默认动作，那肯定也有非默认的了。实际上，一个进程对信号的处理分为三种不同的方式\n\n默认动作\n自定义动作\n忽略\n\n前面提到，一个进程并不一定需要立刻处理一个信号。那么它一定需要有一个办法来记住自己收到的信号。\n而存储信号，是由进程的PCB来完成的！\n细心的你可能会发现，进程中的信号一共是64个，刚好是8个字节！我们可以通过位图结构，用两个int类型来存放一个进程收到的各种信号。\n\n在系统内核中，分别有三个表，用来存放进程的信号。而这些信号在位图中的位置，就是在handler方法集中处理动作的下标\nblock - 1表示该进程屏蔽这个信号pending - 表示进程收到了什么信号，1代表收到且未处理handler - 每一个信号所对应的处理方法，默认/忽略/自定义\n\n这一切都是处于进程PCB中的，只有操作系统能为我们管理。所以操作系统提供了相关的接口，方便我们对进程信号进行自定义设置。\npending表中的信号只能保存一个，如果一个信号尚未处理，该位图为1；另外一个相同信号到来的时候，会被直接丢弃掉。（pending表只能记住一个信号）\nhandler表中的两个宏如下：\n\nSIG_DFL 默认方法\nSIG_IGN 忽略\n忽略是信号处理的一种方式，我们能正常收到这个信号，处理方法是不管他\n\n\n2.系统接口2.1 signal#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler);\n\n这个函数可以用于设置某个信号的处理方法。如果设置成功，则返回值为这个信号的旧处理动作；不过我们一般不关心这个函数的返回值。\nRETURN VALUE   signal()  returns the previous value of the signal handler, or SIG_ERR on error. In the event of an error, errno is set to indicate the cause.\n\n比如我们将键盘退出的2号自定义一个回调函数，那么就不能用ctrl+c终止这个进程；\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;int main()&#123;    //将二号信号设置一个回调，其余信号不做处理    signal(2, handler);    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);    while (true)    &#123;        cout &lt;&lt; &quot;进程正在运行: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    return 0;&#125;\n\n因为是系统调用接口，所以我们的当前进程处于什么状态，都不会影响这个回调办法的调用。\n比如CTRL+C的默认策略是终止某个前台进程，但在我们之前的测试中，即便这个进程在sleep或者是在某些共享资源中进行阻塞等待，它依旧能被CTRL+C所发送的2号信号终止。\n同理，在设置了自定义的信号捕捉函数后，我们发送信号的时候，操作系统也能根据当初设置的回调函数（底层有对应的结构体来存储和这个进程相关的信号处理函数）成功将其调用。\n2.1.1 前台进程和后台进程这里对ctrl+c的作用进一步描述，它只能用来中断一个前台进程\n./test #我们直接运行一个进程，就是前台进程\n\n之前这种直接运行进程，在bash上打印内容的方式，都是一个前台进程，可以用ctrl+c终止；我们可以在后面加上&amp;设置为一个后台进程\n\n&amp;只是临时在后台运行，bash关闭后会终止；如果想持久在后台运行，需要在命令最前面加上nohup\n\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./test &amp;[1] 8898[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898^C[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898^C[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898\n\n这时候这个进程会一直在当前bash的后台打印，期间我们可以执行其他的命令，但是它依旧会不停的打印。ctrl+c无法终止这个进程，因为它并没有在前台运行！\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ps jax | grep test22965  8898  8898 22965 pts/22   22965 S     1001   0:00 ./test\n\nps命令查看，可以看到其运行态为S；而前台进程，运行态为S+\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ps jax | grep test22965  9664  9664 22965 pts/22    9664 S+    1001   0:00 ./test\n\n不过，虽然我们不能用CTRL+C终止这个进程，但使用kill -2发送2号信号，是可以终止掉这个进程的（前提是没有自定义2号信号的方法）\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程信号已经设置完了进程正在运行: 10464进程正在运行: 10464进程正在运行: 10464进程正在运行: 10464进程正在运行: 10464[1]+  Interrupt               ./test[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n2.1.2 循环捕捉所有信号我们可以用一个for循环，捕捉所有的信号；所有信号的列表可以通过kill -l命令获取到。\n//.....//其余代码同上int main()&#123;    //对所有的进程信号都设置一个回调    for (int sig = 1; sig &lt;= 31; sig++)    &#123;        signal(sig, handler);    &#125;    //signal(2, handler);//将二号信号设置一个回调，其余信号不做处理    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);    while (true)    &#123;        cout &lt;&lt; &quot;进程正在运行: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    return 0;&#125;\n\n设置了之后，对应的信号都会调用我们自己写的函数。但有一个例外，那便是kill -9，九号信号是不能被自定义捕获的！\n\n2.1.3 信号9&#x2F;19在LINUX下，9号信号是一个管理员信号，具有杀死进程的最高权限，不能被自定义捕捉！\n\n你想啊，要是linux不对9号进行限制，那我把所有信号都捕捉了，岂不是这个进行没有办法被外部中止了？小病毒啊！😂\n\n和9号信号一样不能被屏蔽的，还有19号信号SIGSTOP\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process running: 7779process running: 7779process running: 7779process running: 7779process running: 7779[1]+  Stopped                 ./tsig[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n而6号信号可以被捕捉，自定义捕捉方法执行后，进程依旧会退出。参考2.4 abort\n2.2 killkill不仅是一个系统命令，同时还有一个系统接口；\n\n一般这种情况，用man kill查看命令的文档，man 2 kill查看接口函数\n\n之前我以为它只是一个用来干掉进程的命令（毕竟kill就是这个意思）现在才知道原来它的作用是给进程发信号\n//kill - send signal to a process#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;int kill(pid_t pid, int sig);\n\n它的返回值很简单，如果成功发送信号，则返回0，否则返回-1并且更新errno\nRETURN VALUE       On success (at least one signal was sent), zero is returned.  On error, -1 is returned, and errno is set appropriately\n\n所以我们可以写一个简单的函数实现，来制作一个自己的kill命令\nvoid mykill(int argc,char *argv[])&#123;    if(argc != 3)    &#123;        cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; signo-id process-id&quot; &lt;&lt;endl;        exit(1);    &#125;    if(kill(static_cast&lt;pid_t&gt;(atoi(argv[2])), atoi(argv[1])) == -1)    &#123;        cerr &lt;&lt; &quot;kill: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(2);//出现错误    &#125;    exit(0);//正常执行&#125;//argc和argv是命令行参数//argc传入命令个数，包括./test//argv传入命令的字符串地址int main(int argc, char *argv[])&#123;    mykill(argc,argv);    return 0;&#125;\n\n成功发送了信号！\n\n如果我们使用错误的时候，则会发送提示信息👍\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./mkillUsage: ./mkill signo-id process-id\n\n2.2.1 killall这个接口可以通过进程名向所有这个名字的进程发信号\n[muxue@bt-7274:~/git]$ killall tsig\n\n通过测试可以发现，它发送的是第15号信号\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process running: 5846process running: 5846process 5846 get signal: 15process running: 5846process running: 5846\n\n\n2.3 raise这个系统接口的作用是给自己发信号\n#include &lt;signal.h&gt;int raise(int sig);\n\n返回0代表调用成功，非0代表失败\nRETURN VALUE       raise() returns 0 on success, and nonzero for failure.\n\n用下面的代码进行测试，进程会不断的给自己发送2号信号\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;void TestSignal()&#123;    signal(2, handler);//将二号信号设置一个回调，其余信号不做处理    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);&#125;int main(int argc, char *argv[])&#123;    TestSignal();//设置对进程信号的屏蔽    while(1)    &#123;        raise(2);        sleep(1);    &#125;    return 0;&#125;\n\n此时能看到每一秒会调用我们自己写的handler方法，打印收到2号信号\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process get signal: 2process get signal: 2process get signal: 2process get signal: 2process get signal: 2\n\n2.4 abort向自己发送6) SIGABRT信号\n#include &lt;stdlib.h&gt;void abort(void);\n\n还是2.3中的代码，将raise(2)修改为abort()，同时捕捉6号信号。\n此时能观察到我们自己写的handler方法的确被调用了，但是进程依旧终止了\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process get signal: 6Aborted[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n这说明6号信号有一个特性：可以被捕捉执行自定义方法，但执行完毕之后需要退出！\n相比之下，9号信号是不能被捕捉\n\n2.5 alarm这个接口的作用是一个定时器，设定秒数，时间到了之后，会收到14) SIGALRM信号\n#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);\n\nRETURN VALUE    alarm()  returns  the number of seconds remaining until any previously scheduled alarm was due to be delivered, or zero if there was no previously scheduled alarm.\n\n用下面的代码进行测试\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;void TestSignal()&#123;    //对所有的进程信号都设置一个回调    for (int sig = 1; sig &lt;= 31; sig++)    &#123;        signal(sig, handler);    &#125;    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);&#125;int main(int argc, char *argv[])&#123;    TestSignal();//设置对进程信号的屏蔽    alarm(4);//4s后向自己发送14信号    cout &lt;&lt; &quot;set alarm, sleep&quot; &lt;&lt; endl;    sleep(8);    cout &lt;&lt; &quot;sleep finish&quot;&lt;&lt;endl;    return 0;&#125;\n\n可以看到在休眠期间，进程收到了14号信号。此时进程并没有退出，而是继续休眠\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了set alarm, sleepprocess get signal: 14sleep finish[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n如果我们不对14号信号自定义捕捉，则会直接退出进程\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigset alarm, sleepAlarm clock[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n另外需要注意的是，alarm信号本身不会让进程休眠。如果进程在alarm信号设定秒数之前结束，则什么事情都不会发生\n2.6 sigset_t信号集这是一个数据类型，其为block&#x2F;pending位图的存储结构，被称作信号集/信号屏蔽字\n虽然我们能直接使用这个类型， 但是对这个信号集中的位图操作必须要调用系统接口来完成\n#include &lt;signal.h&gt;int sigemptyset(sigset_t *set);//初始化位图(清空)int sigfillset(sigset_t *set);//全部置为1int sigaddset(sigset_t *set, int signum);//设置位图中某一位的数据int sigdelset(sigset_t *set, int signum);//删除位图中某一位的数据//判断某一位信号是否在该集合中int sigismember(const sigset_t *set, int signum);\n\n2.7 sigprocmask更改或则获取当前进程的信号屏蔽字\n#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n\n其中第一个参数为处理方法，分别有下面三种\n\nSIG_BLOCK 将set参数中包含的位数设置为屏蔽\nSIG_UNBLOCK 将set参数中包含的位数解除屏蔽\nSIG_SETMASK 将当前的信号屏蔽字设置为set（覆盖）\n\n第三个参数是一个输出型参数。如果传入了oldset，那么旧的信号屏蔽字会被放入oldset中\nSIG_BLOCK  The set of blocked signals is the union of the current set and the set argument.SIG_UNBLOCK  The signals in set are removed from the current set of blocked signals.  It is permissible to attempt  to  unblock  a  signal which is not blocked.SIG_SETMASK   The set of blocked signals is set to the argument set.If oldset is non-NULL, the previous value of the signal mask is stored in oldset.RETURN VALUE       sigprocmask() returns 0 on success and -1 on error.  In the event of an error, errno is set to indicate the cause.\n\n如果用该接口接触了对某一个信号的阻塞，那么在该函数return前，至少其中一个消息被送达\n2.8 sigpending获取当前进程的pending信号集\n#include &lt;signal.h&gt;int sigpending(sigset_t *set);\n\n参数为一个输出型参数。正确获取返回0，否则-1\n这时候我们就可以写一个简单的函数来打印当前进程的信号集了\n//打印信号集的内容void showPending(sigset_t* pdg_ptr)&#123;    for(int i=1;i&lt;32;i++)    &#123;        if(sigismember(pdg_ptr,i))        &#123;            cout &lt;&lt; &quot;1&quot;;        &#125;        else        &#123;            cout &lt;&lt; &quot;0&quot;;        &#125;    &#125;    cout &lt;&lt; endl;&#125;int main()&#123;    sigset_t pdg;    while(1)    &#123;        sigemptyset(&amp;pdg);//初始化信号集        if(sigpending(&amp;pdg)==0)//获取        &#123;            showPending(pdg);//获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    return 0;&#125;\n\n运行之后可以看到，程序一直在打印当前进程的信号集\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigstart process: 30981000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n不过此时我们并没有对信号进行屏蔽，所以给这个进程发信号会被立即处理（递达）不能在pending表中观察到现象\n2.8.1 屏蔽2号信号此时尝试使用sigprocmask来屏蔽某一个信号，再来观察情况\nint main(int argc, char *argv[])&#123;    //block掉2号信号    sigset_t nsig,osig;    sigemptyset(&amp;nsig);    sigemptyset(&amp;osig);    sigaddset(&amp;nsig,2);//在nsig中设置2为1    sigprocmask(SIG_BLOCK,&amp;nsig,&amp;osig);//添加屏蔽    cout &lt;&lt; &quot;start process: &quot; &lt;&lt; getpid() &lt;&lt; endl;    sigset_t pdg;    while(1)    &#123;        sigemptyset(&amp;pdg);//初始化信号集        if(sigpending(&amp;pdg)==0)//获取        &#123;            showPending(&amp;pdg);//获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    return 0;&#125;\n\n可以看到当我们键入CTRL+C的时候，2号信号被block了没有处理，pending表上的2号信号就会变为1，且多次CTRL+C不会有变化\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigstart process: 360800000000000000000000000000000000000000000000000000000000000000^C0100000000000000000000000000000010000000000000000000000000000001000000000000000000000000000000100000000000000000000000000000^C01000000000000000000000000000000100000000000000000000000000000\n\n2.8.2 屏蔽所有信号可以用一个循环设置所有的信号位，让当前进程屏蔽掉所有信号\nint main(int argc, char *argv[])&#123;    //block掉所有信号    sigset_t nsig,osig;    sigemptyset(&amp;nsig);    sigemptyset(&amp;osig);    for(int i=1;i&lt;32;i++)    &#123;        sigaddset(&amp;nsig,i);//在nsig中设置2为1    &#125;    sigprocmask(SIG_BLOCK,&amp;nsig,&amp;osig);//添加屏蔽    cout &lt;&lt; &quot;start process: &quot; &lt;&lt; getpid() &lt;&lt; endl;    sigset_t pdg;    while(1)    &#123;        sigemptyset(&amp;pdg);//初始化信号集        if(sigpending(&amp;pdg)==0)//获取        &#123;            showPending(&amp;pdg);//获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    return 0;&#125;\n\n运行之后可以观察到，不管给这个进程发几号信号，都会被屏蔽显示在pending集中；9号信号依旧是老大哥，不受影响，依旧能干掉这个进程\n\n2.8.3 解除屏蔽如果在设置屏蔽之后，休眠15s（在此期间接收信号）再接触对信号的屏蔽\nint main(int argc, char *argv[])&#123;    //block掉所有信号    sigset_t nsig,osig;    sigemptyset(&amp;nsig);    sigemptyset(&amp;osig);    for(int i=1;i&lt;32;i++)    &#123;        sigaddset(&amp;nsig,i);//在nsig中设置2为1    &#125;    sigprocmask(SIG_BLOCK,&amp;nsig,&amp;osig);//添加屏蔽    TestSignal();//设置信号自定义处理    cout &lt;&lt; &quot;start process: &quot; &lt;&lt; getpid() &lt;&lt; endl;    sigset_t pdg;    int k=15;    while(k--)    &#123;        sigemptyset(&amp;pdg);//初始化信号集        if(sigpending(&amp;pdg)==0)//获取        &#123;            showPending(&amp;pdg);//获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    //利用osig恢复之前的block表    sigprocmask(SIG_SETMASK,&amp;osig,nullptr);    sigemptyset(&amp;pdg);//初始化信号集    if(sigpending(&amp;pdg)==0)//获取    &#123;        showPending(&amp;pdg);//获取成功，打印    &#125;    sleep(10);    cout &lt;&lt; &quot;process quit&quot;&lt;&lt;endl;    return 0;&#125;\n\n此时就能观察到，信号被立马处理，pending表变为全0\n\n2.9 sigaction#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *act,\t\t\tstruct sigaction *oldact);\n\n这个函数的参数和signal函数很相似，不过都变为了一个结构体。这个接口也可以用来处理实时信号（不在文本考虑范围内）\n\n第一个参数是需要处理信号的编号\n第二个参数是自定义的action\n第三个参数是输出型参数，可以获取到旧的处理方法；如果你不关心旧的处理方法，可以将它置为NULL空指针；\n\n设置成功后返回0，出错返回-1；\n这个结构体的成员如下：\nstruct sigaction &#123;    void     (*sa_handler)(int);//对信号的处理方法    void     (*sa_sigaction)(int, siginfo_t *, void *);//可忽略    sigset_t   sa_mask;//参考2.8中的处理方法    int        sa_flags;//设为0    void     (*sa_restorer)(void);//可忽略&#125;;\n\n2.9.1 基本使用#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;using namespace std;//打印收到的信号void handler(int signo)&#123;    cout &lt;&lt; &quot;process &quot; &lt;&lt; getpid() &lt;&lt; &quot; get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;int main(int argc, char *argv[])&#123;    struct sigaction nact,oact;    nact.sa_flags = 0;    nact.sa_handler = handler;    sigemptyset(&amp;nact.sa_mask);//初始化    sigaction(2,&amp;nact,&amp;oact);    while(1)    &#123;        cout &lt;&lt; &quot;process running: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(2);    &#125;    return 0;&#125;\n\n运行之后，我们自定义捕捉了2号信号，成功调用自己的handler方法！\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigprocess running: 15029process running: 15029^Cprocess 15029 get signal: 2process running: 15029process running: 15029^Cprocess 15029 get signal: 2process running: 15029process running: 15029process running: 15029^\\Quit[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n请注意，信号处理函数在自定义捕获后，进程接收到信号，会调用自定义捕捉的函数，再继续往后运行。所以如果你捕获了2号信号，用ctrl+c来退出的时候，理论上也是会调用对象的析构函数的（前提是你的进程里面没有死循环）。\n信号2终止后是否会调用析构函数？上面的代码中，我们有死循环，所以再接受到信号处理后，调用完毕函数，就会自动回到死循环的位置。\n在下面的函数中，我们的main是直接在sleep里面阻塞等待的，那么在获取到ctrl+c的信号后，会先调用信号处理函数，再回到main函数中继续往后执行，最终调用对象的析构。\n// 上面的代码省略了// mytest和myclass是两个类，类中的构造和析构都添加了打印// mytest中用智能指针包裹了一个myclass对象class mytest&#123;public:    mytest(int a):_ptr(make_shared&lt;myclass&gt;(a))    &#123;        cout &lt;&lt; &quot;init mytest&quot; &lt;&lt; endl;    &#125;    ~mytest()    &#123;        cout &lt;&lt; &quot;destroy mytest&quot; &lt;&lt; endl;    &#125;private:    shared_ptr&lt;myclass&gt; _ptr;&#125;;int main()&#123;    RegisterSigTermHandler(); // 捕捉2号信号    mytest t1(1);    map&lt;int,mytest&gt; tmap;    for(int i=0;i&lt;6;i++)    &#123;        tmap.emplace(i,t1);    &#125;    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;    tmap.clear();    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;    sleep(10); // 在这里ctrl+c，接收到信号，运行完毕信号处理函数后，会继续往后运行。    cout &lt;&lt; &quot;-- end --&quot; &lt;&lt; endl;    return 0;&#125;\n这个程序的终端输出如下，在接收到信号后，会先调用信号处理函数，打印singal字符串，再返回到main函数，打印-- end --字符串，最终退出main函数，析构掉两个对象。\n&gt; ./testinit myclassinit mytest----destroy mytestdestroy mytestdestroy mytestdestroy mytestdestroy mytestdestroy mytest----^Csingal-- end --destroy mytestdestroy myclass\n\n记录这一点，是因为GPT告诉我如果是接收到信号退出是不会执行析构函数的。然而情况并非如此。析构函数依旧会被正常执行！\n那如果有死循环的话，应该如何保证对象的析构能被正常执行呢？\n\n在死循环中加上if(全局变量)的判断逻辑，并在信号处理函数中设置变量\n在信号处理函数中手动调用一个shutdown函数，为了避免一个函数写两次，可以在析构函数中也调用这个shutdown函数。\n\n但是，如果你的进程中是多层嵌套循环的话，最终的退出可能没有完全退出，会导致析构函数不被正常调用的资源泄漏问题！如果你需要使用的资源中包含IPC（进程间通信）这些必须要被删除的对象的话，这个问题就需要注意了。\n\n比如你进程退出的时候析构函数没有调用，没有删除掉消息队列，下一次启动的时候，消息队列读端如果先启动，有可能会读取到上次冗余的脏数据。\n所以我们要保证IPC资源能被正常释放。\n\n2.9.2 sa_mask这个成员是一个sigset_t类型，用于当处理一个信号的时候，连带屏蔽其他信号；\n\n当一个进程正在处理A信号的时候，操作系统会把A信号自动添加入Block表，屏蔽该信号（不允许同时处理两个A信号，避免信号A的递归式处理）\n\n如果你想在处理2号信号的时候，阻塞掉3、4、5号信号，就可以对sa_mask进行设置，设置方法参考2.8的操作\n因为现在我演示的自定义方法只是一个再简单不过的示例，实际上进程收到信号的时候需要根据不同情况进行不同的自定义处理，这些自定义处理的过程可能会很长。此时就可以block掉其他的信号，不让它们影响当前进程运行的自定义方法\n3.软件崩溃的本质之前我们经常会遇到软件出错奔溃的情况，那么奔溃的本质是什么呢？\n3.1 情景演示用下面的一个除零错误作为演示\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process &quot; &lt;&lt; getpid() &lt;&lt; &quot; get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;void TestSignal()&#123;    //对所有的进程信号都设置一个回调    for (int sig = 1; sig &lt;= 31; sig++)    &#123;        signal(sig, handler);    &#125;    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);&#125;int main(int argc, char *argv[])&#123;    TestSignal();    int a = 10;    int b = 0;    try    &#123;        int c = a / b; // C++的除0不是异常，不会抛出        //所以会直接linux系统运行报错    &#125;    catch (const exception &amp;e)    &#123;        cerr &lt;&lt; &quot;a/0 err&quot; &lt;&lt; endl;        abort();    &#125;    catch (...)    &#123;        cout &lt;&lt; &quot;base catch&quot; &lt;&lt; endl;        abort();    &#125;    return 0;&#125;\n\n运行了之后，该进程会一直收到8号信号，直到我们手动kill掉这个进程\nprocess 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8Killed\n\n你可能会觉得奇怪，不是用try/catch进行了异常处理吗？为什么没有用呢？\n那是因为，在C++中，并不会将除零错误当作一个异常进行处理！\n\n\n我们自定义捕捉了8号信号，没能让进程终止。但此时这个进程已经出现了一个严重的bug，操作系统就会一直给进程发这个信号\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigFloating point exception[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n相比之下，如果不自定义捕捉，则会直接报错+终止进程；\n8号信号是SIGFPE，FPE即为Floating point exception的缩写！\n3.2 说明崩溃的本质，是该进程收到了异常信号，从而终止。\n以除零错误为例，CPU内部会有一个状态寄存器，检测到用户进行除零计算的时候，会将状态寄存器设置为浮点数错误。当操作系统检测到这个错误的时候，便会向当前正在运行的进程发送8号信号。而我们的进程在收到信号的时候，会处理这个信号，默认的处理方法就是终止进程！\n同理，当我们访问一个野指针的时候，操作系统能在虚拟地址转换的时候发现这个问题，向我们的进程发送11号信号\nint main(int argc, char *argv[])&#123;    TestSignal();    int *p;    *p=20;    return 0;&#125;\n\n11) SIGSEGV 代表段错误，写OJ题目的时候这个报错很常见😂\nprocess 6754 get signal: 11process 6754 get signal: 11process 6754 get signal: 11process 6754 get signal: 11process 6754 get signal: 11Killed\n\n4.coredump在进程控制的博客中，提到当进程因为信号终止的时候，其status中的0-7位会是对应的终止信号，而第8位是该进程的core dump标记位\n\n在1.2贴出来的源码注释中可以看到，有不少信号的默认动作是进行core dump，比如8号信号。那么这个东西到底是什么玩意呢？\n\n通过fork创建子进程，让子进程除零产生8号信号，子进程退出\nint main(int argc, char *argv[])&#123;    int status;    int id = fork();    if(id == 0)    &#123;        //子进程        int b=0;        int a = 10/b;    &#125;    int ret = waitpid(id,&amp;status,0);    //打印子进程的退出信息    printf(&quot;exitcode:%d signo:%d coredump: %d\\n&quot;,(status&gt;&gt;8)&amp;&amp;0xff,status&amp;0x7f,(status&gt;&gt;7)&amp;0x1);    return 0;&#125;\n\n此时可以观察到，coredump标记位为0\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigexitcode:0 signo:8 coredump: 0\n\n4.1 开启该功能默认情况下，我们云服务器的core dump功能是被关闭的，需要我们手动开启；\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -acore file size          (blocks, -c) 0  #coredump功能被关闭了data seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 14691max locked memory       (kbytes, -l) unlimitedmax memory size         (kbytes, -m) unlimitedopen files                      (-n) 100002pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) 14691virtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n使用ulimit -a命令指定core file的大小\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -c 10000[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -acore file size          (blocks, -c) 10000\n\n再次运行刚刚的代码，可以看到标记位为1，并且产生了一个core.27908文件，这个文件的后缀是产生coredump文件的进程pid\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigexitcode:0 signo:8 coredump: 1[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ lltotal 292-rw------- 1 muxue muxue 593920 Nov 20 12:34 core.27908-rw-rw-r-- 1 muxue muxue    194 Nov 20 10:31 makefile-rw-rw-r-- 1 muxue muxue    601 Nov 20 09:57 mkill.cc-rw-rw-r-- 1 muxue muxue    203 Nov 20 09:56 test.cc-rwxrwxr-x 1 muxue muxue  13768 Nov 20 12:34 tsig-rw-rw-r-- 1 muxue muxue   1772 Nov 20 12:34 tsignal.cpp[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\nvscode告诉我们这个不是一个普通的文本文件\n\n这个现象告诉我们，默认动作是coredump的信号，会让进程退出，将coredump标记位置为1并且产生一个core.文件\n4.2 使用coredump这个功能会将进程在运行中产生异常的上下文数据，执行core dump（核心转储）为一个文件，方便我们debug\n如下所示，使用-g命令以debug模式编译test.cc,运行的时候可以看到除零错误之后跟了一个(core dumped)提示我们进行了core dump操作，对应产生了一个core.文件\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ g++ test.cc -g -o test[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./testFloating point exception (core dumped)\n\n这时候打开gdb，输入core-file 文件名加载文件，就可以直接定位到出错代码的位置！\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ gdb testGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/muxue/git/linux/code/22-11-16_signal/test...done.(gdb) core-file core.31997[New LWP 31997]Core was generated by `./test&#x27;.Program terminated with signal 8, Arithmetic exception.#0  0x000000000040065c in main () at test.cc:1313          int a=10/0;Missing separate debuginfos, use: debuginfo-install glibc-2.17-326.el7_9.x86_64 libgcc-4.8.5-44.el7.x86_64(gdb)(gdb)\n\n这可比我们手动debug找错误方便多了\n\n4.3 为什么默认关闭？你可能会觉得，这个功能不挺好的吗，为啥默认没有开启呢？\n先来看看这个文件的大小，足足有580KB\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ls -lhttotal 292K-rw-rw-r-- 1 muxue muxue 1.8K Nov 20 12:37 tsignal.cpp-rw------- 1 muxue muxue 580K Nov 20 12:34 core.27908\n\n一般而言，服务端运行的一些进程，都需要保持稳定性。比如B站的服务器挂了，第一时间要做的是重启服务进程（并不是重启服务器机器）\n如果设置了这个coredump，当服务器进程因为错误退出的时候，会生成一个core.文件；这时候有一个守护进程（用来监视并及时重启服务器进程）发现服务器进程退出了，就会重启它。\n这时候又遇到了刚刚那个bug，服务器进程又退出了，守护进程又来重启它……\n如此往复，就会生成非常非常多的core.文件，塞满我们的硬盘。\n对于求稳为主的服务器而言，这可不是一个好事。所以云服务器上默认禁止了这个功能。\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -c 0[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -acore file size          (blocks, -c) 0\n\n用umlimit -c 0指定大小为0关闭该功能\n\n5.进程处理信号前面八八了这么一大堆，进程到底是什么时候来处理信号的呢？\n\n开门见山：进程从内核态切换成用户态的时候，处理信号\n\n5.1 内核态&#x2F;用户态在程序地址空间的博客中，提到了每一个进程都有1gb的内核空间；该内核空间用于内核级页表的映射，即映射操作系统的物理内存！\n\n有内核级页表的存在，无论进程怎么切换，都能找到操作系统内核的代码和数据，前提是有权限访问。\n\nCPU中的CR3状态寄存器会标识当前进程处于内核态还是用户态\n内核态可以访问所有代码和数据，权限最高\n用户态只能访问当前进程自己的数据\n\n当我们进程需要执行内核接口的时候，就需要将进程切换为内核态；运行完毕之后，切换回用户态。\n当我们进程出现了异常，会从用户态切换成内核态，由操作系统检测相关异常并向进程发送对应信号。\n当我们进程的时间片到了（需要切换进程）也会从用户态转为内核态，由操作系统来进行进程切换。\n5.2 信号检测当进程从内核态切换回用户态的时候，会进行信号的检测和处理。此时判断pending表中是否有未处理信号，以及该信号是否有被block。如果一个信号没有被block，则将该信号递达给进程，执行对应的处理方法\n\n执行用户的自定义方法时，应该以什么身份执行？\n\n注意，当我们给一个信号指定了自定义处理方法，就代表该信号的处理方法是用户提供的。此时需要以用户的身份去执行这个代码，才能正确访问用户级页表。\n这么做也能避免恶意代码的注入。如果有人在自定义方法中写一个修改系统内核的恶意代码，也能被操作系统发现并阻止。\n这个过程可以用下面这张图来解释（并非完整过程，仅供参考理解）\n\n每次处理完信号后，会返回用户进程，从上一次中断的位置开始继续往后运行\n6.可重入函数//头插void insert(Node* p)&#123;\tp-&gt;next=head;\thead=p;&#125;\n\n上面这个函数是一个非常简单的链表头插函数\n如果我们这个头插函数处理的是一个全局的链表，就可能会因为用户态、内核态的切换，函数重入造成错误\n\n所以insert就是一个不可重入函数！除了这个头插，还有一些其他的函数也符合这个特效：\n\n调用了malloc或者free（可能会多次malloc和多次free）\n调用了I&#x2F;O库的函数\n绝大多数库函数都是不可重入的，比如C++的STL库\n\n依此类推，如果一个函数只访问他自己的局部变量，不会影响其他参数。那么他就是一个可重入函数\n6.1 原子操作所谓原子操作是指不会被 线程调度 机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）\n\n如果一个函数进行了对全局变量的原子操作，那么它也是可重入的函数。因为原子操作不包含中间态\n如果一个函数对全局变量进行了非原子操作（比如上面的链表头插）那么他就是一个不可重入函数\n\n7.volatile之前的学习中就已经知道，这个关键字的作用是每一次访问变量的时候，都必须要去内存中取。\n\n假设我们进程中需要通过一个全局变量进行条件判断\nint flag=0;int main()&#123;    if(flags)    &#123;        //..    &#125;    else    &#123;        //..    &#125;    return 0;&#125;\n\n如果我们自定义捕捉了一个信号，收到该信号的时候，会修改flag，执行if&#x2F;else语句中对应的代码。\n由于编译器的优化问题，每一次访问flag的时候，它可能不会每次都去内存中取，就会出现一个问题\n\n寄存器中 flag&#x3D;0\n经过自定义捕捉函数处理，内存中 flag&#x3D;1\n\n这两个flag在if条件中会导向不同的结果！\n为了避免这种可能因为平台、编译器、优化问题导致的代码bug，我们需要告诉所有编译器，不准对flag变量做任何优化处理，必须要老老实实的去内存中拿这个变量的数据！\n//volatile保持内存的可见性volatile int flag = 0;\n\n7.1 示例\ngcc编译器可以通过-O2指定较高的优化等级\n\n以下面的代码为例\n#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;// 保持内存的可见性int flag = 0;void handler(int signo)&#123;    flag = 1;    printf(&quot;\\n更改flags: 0-&gt;1\\n&quot;);&#125;int main()&#123;    printf(&quot;process start %d\\n&quot;,getpid());    signal(2, handler);//自定义捕捉2号信号    while (!flag)        ;//啥事不干的循环   \tprintf(&quot;process exit!\\n&quot;);    return 0;&#125;\n\n运行之后，键入CTRL+C，你会发现进程依旧没有退出！理论上来说flags=1，!flags为假，应终止循环，退出进程才对！\n[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test -O2[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./testprocess start 22333^C更改flags: 0-&gt;1^C更改flags: 0-&gt;1^C更改flags: 0-&gt;1^C更改flags: 0-&gt;1^\\Quit[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$\n\n如果我们加上volatile关键字，则不会出现这个问题，进程能够正常退出\n[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test -O2[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./testprocess start 23086^C更改flag: 0-&gt;1process exit![muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$\n\n去掉gcc编译器的优化参数，去掉volatile关键字，会发现进程也能正常退出\n[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./testprocess start 23224^C更改flag: 0-&gt;1process exit![muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$\n\n这就是编译器优化不同的影响！加上volatile关键字能避免这个问题，使代码运行能有唯一结果！\n8.子进程发送信号当子进程的状态变化的时候，会向父进程发送17号信号\nvoid testfork()&#123;    int status;    int id = fork();    if(id == 0)    &#123;        //子进程        cout &lt;&lt; &quot;chlid process: &quot; &lt;&lt;getpid()&lt;&lt;endl;        int b=0;        int a = 10/b;    &#125;    TestSignal();    int ret = waitpid(id,&amp;status,0);    //打印子进程的退出信息    printf(&quot;exitcode:%d signo:%d coredump: %d\\n&quot;,(status&gt;&gt;8)&amp;&amp;0xff,status&amp;0x7f,(status&gt;&gt;7)&amp;0x1);&#125;\n\n观察结果，可以看到父进程收到了子进程的17号信号，此时子进程因为错误退出\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了chlid process: 25319process 25318 get signal: 17exitcode:0 signo:8 coredump: 0[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n除了退出时会发送信号，子进程暂停、继续运行的时候，都会向父进程发送信号\n\n8.1 父进程回收子进程既然父进程能收取到子进程发送的信号，那么我们自定义捕捉17号信号，在其中调用waitpid，即可在子进程出错或执行完毕需要退出的时候，进行父进程回收\n\n这样就不需要在main函数中进行主动wait了\n\n操作并不难，我们只需要将17号信号进行自定义捕捉，在捕捉函数中执行waitpid进行等待即可\n\n注意：这里的waitpid必须使用WNOHANG进行非阻塞等待\n当父进程正在阻塞等待子进程A的时候，它在处理17号信号，新的17号信号无法收到\n这就会导致在A之后种子的子进程，无法向父进程发送有效的17号信号\n从而出现了僵尸进程（未回收的子进程）\n\n使用非阻塞等待，即可以避免此问题，又能让父进程在等待的过程中处理自己的其他工作，一举两得。\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;cassert&gt;using namespace std;void FreeChld(int signo)&#123;    assert(signo == SIGCHLD);    while (true)    &#123;        //如果没有子进程了，waitpid就会调用失败        pid_t id = waitpid(-1, nullptr, WNOHANG); // 非阻塞等待        if (id &gt; 0)        &#123;            cout &lt;&lt; &quot;父进程等待成功, child pid: &quot; &lt;&lt; id &lt;&lt; endl;        &#125;        else if(id == 0)        &#123;            //还有子进程没有退出            cout &lt;&lt; &quot;尚有未退出的子进程，父进程继续运行&quot; &lt;&lt; endl;            break;//退出等待子进程        &#125;        else        &#123;            cout &lt;&lt; &quot;父进程等待所有子进程结束&quot; &lt;&lt; endl;            break;        &#125;    &#125;&#125;int main()&#123;    signal(SIGCHLD, FreeChld);    for (int i = 0; i &lt; 5; i++)    &#123;        pid_t id = fork();        if (id == 0)        &#123;            //子进程            int cnt = 8;            while (cnt)            &#123;                cout &lt;&lt; &quot;子进程 pid: &quot; &lt;&lt; getpid() &lt;&lt; &quot; cnt: &quot; &lt;&lt; cnt-- &lt;&lt; endl;                sleep(1);            &#125;            cout &lt;&lt; &quot;子进程退出，进入僵尸状态: &quot; &lt;&lt; i &lt;&lt; endl;            exit(0);        &#125;        sleep(2);    &#125;    while (true)    &#123;        cout &lt;&lt; &quot;父进程正在运行: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    return 0;&#125;\n\n如下右图中，第0个子进程退出进入将是状态，父进程收到17号信号，就开始回收子进程。此时还有4个子进程没有运行完毕，父进程会继续运行，等待其他子进程结束\n\n当所有子进程都等待结束了，waitpid返回-1让父进程退出回收子进程的循环，现在就只有父进程自己在干活了\nwhile :; do ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\n反应到监控信息上，父进程先是创建了5个子进程\n\n随后当第一个子进程退出的时候，父进程开始回收子进程。这里也能观测到，回收成功，并没有出现僵尸状态的子进程。\n\n8.2 父进程忽略子进程前面提到过，SIG_IGN的作用是忽略这个子进程；你可能会想，这不对啊，忽略了子进程的信号，那岂不是父进程不想搭理子进程了吗？\n*\t|  SIGCHLD           |\tignore   \t|\n\n查1.2表你还会发现，SIGCHLD的默认动作不就是忽略吗？自己设置一下是不是多此一举？\nsignal(SIGCHLD, SIG_IGN);\n\n然并不是这样，对于SIGCHLD17号信号而言，我们给父进程设置了手动忽略后，子进程退出的时候将自动被回收\n这么做的前提，是父进程不需要和子进程在回收资源的时候进行处理，说人话就是，只要父进程不想管任何子进程的工作，那就可以直接把17号信号手动设置成SIG_IGN\n\n结语进程信号到这里就基本over了，干货满满！\n如果对你有帮助，还请点个赞吧！！！\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】线程实例 | 简单线程池","url":"/posts/1969264863/","content":"今天来写一个简单版本的线程池\n\n\n1.啥是线程池池塘，顾名思义，线程池就是一个有很多线程的容器。\n我们只需要把任务交到这个线程的池子里面，其就能帮我们多线程执行任务，计算出结果。\n与阻塞队列不同的是，线程池中内有一个队列用于任务管理，并帮我们封装了线程创建的工作。我们不再需要在主执行流里面创建线程（创建线程也是有时间消耗的），而是只关注于任务的创建，交给线程池来运行并产生结果就OK了\n前面已经学习过阻塞队列了，此时再来写线程池，就没有那么困难了！\n本次线程池的设计还会采用单例模式，同一个模板类型的任务，只需要一个线程池即可\n1.1 简单复习单例模式单例模式分为两种设计方式，一个是懒汉，一个是饿汉\n\n懒汉：刚开始先不创建单例，等第一次使用的时候在创建；缺点是第一次获取单例需要等待，优点是程序启动快\n饿汉：main函数执行前，就将单例创建起来；缺点是程序启动会比较慢，优点是启动之后获取单例会快\n\n2.代码示例-处理task2.1 成员变量因为是线程池，需要在内部创建出线程来运行，所以我们需要一个num来标识需要创建的线程的数量\ntemplate &lt;class T&gt;class ThreadPool&#123;private:\tbool _isStart;  // 线程池子是否启动    int _threadNum; // 线程数量    queue&lt;T&gt; _tq;   // 任务队列    pthread_mutex_t _mutex;// 锁    pthread_cond_t _cond;  // 条件变量    static ThreadPool&lt;T&gt; *instance; // 单例模式需要用到的指针&#125;\n\n这里我们并不需要弄一个数组来存放已经创建的线程，因为我们并不关心线程的退出信息，也不需要对线程进行管理。在创建好线程之后，直接detach即可\nstatic变量我们需要在类外初始化，因为是模板类型，所以还需要带上template关键字\n// 初始化static变量template &lt;class T&gt;ThreadPool&lt;T&gt; *ThreadPool&lt;T&gt;::instance = nullptr;\n\n2.2 构造&#x2F;析构（单例）本次使用的是懒汉模式的单例，提供一个指针作为单例，不开放构造函数（构造函数私有化）\n同时，利用delete关键字，禁止拷贝构造和赋值重载；析构依旧保持公有\nprivate:    ThreadPool(int num = DEFALUT_NUM)        : _threadNum(num),          _isStart(false)    &#123;        assert(num &gt; 0);        pthread_mutex_init(&amp;_mutex, nullptr);        pthread_cond_init(&amp;_cond, nullptr);    &#125;    ThreadPool(const ThreadPool&lt;T&gt; &amp;) = delete;//取消拷贝    void operator=(const ThreadPool&lt;T&gt; &amp;) = delete;//取消赋值\n\n析构函数并不需要进行过多处理，将锁和条件变量销毁即可\n~ThreadPool()&#123;    pthread_mutex_destroy(&amp;_mutex);    pthread_cond_destroy(&amp;_cond);&#125;\n\n这种情况下，我们还需要有一个static成员函数来获取单例；在之前的单例模式博客中，提到当初实现的懒汉模式是线程不安全的，因为没有对线程进行加锁，避免多个执行流同时获取单例，导致单例对象冲突的问题。\n现在学习了linux的加锁操作，就可以避免掉这个bug了\n两次nullptr判断其中关于两次nullptr判断的原因，详见注释\n\n第一个判断是为了保证单例，只要单例存在了，就不再创建单例\n第二个判断是保证线程安全，可能会出现线程a在创建单例，线程b在锁中等待的情况；此时如果不进行第二次nullptr判断，线程b从锁中被唤醒后，又会继续执行，多创建了一个单例！\n\npublic:    static ThreadPool&lt;T&gt; *getInstance()    &#123;        static pthread_mutex_t mt;//使用static，锁只会创建一次；避免多次实例化，一个执行流一个锁就失去效果了        pthread_mutex_init(&amp;mt,nullptr);        if (instance == nullptr) // 第一次判断        &#123;            pthread_mutex_lock(&amp;mt);// 加锁，保证只有一个执行流走到这里            if (instance == nullptr)// 第二次判断是来确认的，避免出现在加锁前，被其他执行流获取过实例了            &#123;                instance = new ThreadPool&lt;T&gt;();// 确认是null，创建单例            &#125;        &#125;        pthread_mutex_unlock(&amp;mt);        pthread_mutex_destroy(&amp;mt);        return instance;    &#125;\n\n2.3 启动线程池有了线程池，接下来要做的就是启动它😁\n启动之前，我们需要assert判断一下该线程池是否已经启动了，避免多次启动线程池出现问题。启动完成之后，更新isStart的状态值\nvoid start()&#123;    assert(!_isStart);//如果开启了，那么就不能执行该函数    for (int i = 0; i &lt; _threadNum; i++)    &#123;        pthread_t temp;        pthread_create(&amp;temp, nullptr, threadRoutine, this);//把this当参数传入        usleep(100);        pthread_detach(temp);//分离线程    &#125;    _isStart = true;//标识状态，代表线程池已经启动了&#125;\n\n这里还有另外一个函数threadRoutine，这是每一个线程需要执行的函数，其为static函数。这里我们获取到的都是单例的this指针，访问成员都需要通过this指针来访问\nstatic void *threadRoutine(void *args)&#123;    ThreadPool&lt;T&gt; *tp = static_cast&lt;ThreadPool&lt;T&gt; *&gt;(args);//c++强转    while (1)    &#123;        tp-&gt;lockQueue();        while (!tp-&gt;haveTask())        &#123;            tp-&gt;waitForTask();        &#125;        // 任务被拿到了线程的上下文中        T t = tp-&gt;pop();        tp-&gt;unlockQueue();        // 规定每一个封装的task对象都需要有一个run函数        t.resultPrint(t.run());//运行并打印结果    &#125;&#125;\n\n2.4 封装的加锁&#x2F;解锁&#x2F;通知操作这部分操作比较简单，就不多提了。其实就是把已有的函数改个名字，变成无参可直接调用的函数罢了。\nprivate:    void lockQueue() &#123; pthread_mutex_lock(&amp;_mutex); &#125;    void unlockQueue() &#123; pthread_mutex_unlock(&amp;_mutex); &#125;    bool haveTask() &#123; return !_tq.empty(); &#125;    void waitForTask() &#123; pthread_cond_wait(&amp;_cond, &amp;_mutex); &#125;    void singalThread() &#123; pthread_cond_signal(&amp;_cond); &#125;    T pop()    &#123;        T temp = _tq.front();        _tq.pop();        return temp;    &#125;\n\n其中pop()函数设置为了私有，因为线程池会自己开始处理任务，所以不需要外部pop\n\n2.5 插入任务最后就只剩下任务的插入了，插入一个任务后，使用条件变量，唤醒线程池中的一个线程来执行这个任务！\n//往线程池中给任务void push(const T &amp;in)&#123;    lockQueue();    _tq.push(in);//插入任务    singalThread();//任务插入后，唤醒一个线程来执行    unlockQueue();&#125;\n\n到这里，线程池就大功告成了！\n3.测试本次测试依旧使用了在线程博客中提到过的task.hpp，完整代码详见我的gitee仓库\n因为使用了线程池，主执行流只需要来派发任务即可；\n#include &quot;threadpool.hpp&quot;#include &quot;task.hpp&quot;#include &lt;string&gt;#include &lt;time.h&gt;int main()&#123;    const string operators = &quot;+/*/%&quot;;    ThreadPool&lt;Task&gt;*tp = ThreadPool&lt;Task&gt;::getInstance();    tp-&gt;start();    srand((unsigned long)time(nullptr) ^ getpid() ^ pthread_self());    // 派发任务的线程    while(1)    &#123;        int one = rand()%50;        int two = rand()%10;        char oper = operators[rand()%operators.size()];        cout &lt;&lt; &quot;[&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] 主线程派发计算任务: &quot; &lt;&lt; one &lt;&lt; oper &lt;&lt; two &lt;&lt; &quot;=?&quot; &lt;&lt; &quot;\\n&quot;;        Task t(one, two, oper);        tp-&gt;push(t);        sleep(1);    &#125;    &#125;\n\n此时线程池就会帮我们运行，并将结果输出！\n[muxue@bt-7274:~/git/linux/code/23-01-18 threadpool]$ ./test[140202992179008] 主线程派发计算任务: 14/8=?[140202973767424] 新线程完成计算任务: 14/8=1[140202992179008] 主线程派发计算任务: 43*2=?[140202965374720] 新线程完成计算任务: 43*2=86[140202992179008] 主线程派发计算任务: 10/9=?[140202956982016] 新线程完成计算任务: 10/9=1[140202992179008] 主线程派发计算任务: 25*9=?[140202948589312] 新线程完成计算任务: 25*9=225[140202992179008] 主线程派发计算任务: 8/0=?div zero, abort[140202940196608] 新线程完成计算任务: 8/0=-1[140202992179008] 主线程派发计算任务: 38%1=?[140202973767424] 新线程完成计算任务: 38%1=0[140202992179008] 主线程派发计算任务: 23/7=?[140202965374720] 新线程完成计算任务: 23/7=3[140202992179008] 主线程派发计算任务: 4%4=?[140202956982016] 新线程完成计算任务: 4%4=0[140202992179008] 主线程派发计算任务: 44*8=?[140202948589312] 新线程完成计算任务: 44*8=352[140202992179008] 主线程派发计算任务: 4/2=?\n\n3.1 修改轻量级进程的名字Linux提供了一个有趣的接口，可以允许我们修改轻量级进程的名字；\n没有修改的时候，默认的名字都是该进程的可执行程序的名字\n[muxue@bt-7274:~/git/linux/code/23-01-18 threadpool]$ ps -aL  PID   LWP TTY          TIME CMD 6592  6592 pts/7    00:00:00 test 6592  6593 pts/7    00:00:00 test 6592  6594 pts/7    00:00:00 test 6592  6595 pts/7    00:00:00 test 6592  6596 pts/7    00:00:00 test 6592  6597 pts/7    00:00:00 test 6730  6730 pts/8    00:00:00 ps\n\n我们使用prctl接口，修改名字；这个接口的作用是对一个进程进行操作。\n#include &lt;sys/prctl.h&gt;int prctl(int option, unsigned long arg2, unsigned long arg3,\t\tunsigned long arg4, unsigned long arg5);\n\n其中修改线程名字的操作如下\nprctl(PR_SET_NAME, &quot;handler&quot;);//修改线程名字为handler\n\n分别修改主执行流和线程池中线程的名字，即可获得不一样的结果\n[muxue@bt-7274:~/git/linux/code/23-01-18 threadpool]$ ps -aL  PID   LWP TTY          TIME CMD 7793  7793 pts/7    00:00:00 master 7793  7794 pts/7    00:00:00 handler 7793  7795 pts/7    00:00:00 handler 7793  7796 pts/7    00:00:00 handler 7793  7797 pts/7    00:00:00 handler 7793  7798 pts/7    00:00:00 handler 7828  7828 pts/8    00:00:00 ps\n\n这样可以用于标识线程的属性，还是有些用的！\nThe end本篇博客到这里就over啦，有啥问题欢迎评论区提出哦！\n\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】线程概念 | 同步","url":"/posts/2186356144/","content":"除了线程互斥，我们还有线程同步，来康康吧\n\n\n[TOC]\n1.为什么需要同步在部分条件下，互斥是正确的，但是不合理。比如食堂打饭的时候，食堂阿姨一次只能给一个人打饭，于是就选择通过竞争来获得打饭的权利。此时就会出现有些线程因为优先级过低或者CPU调度问题，一直打不到饭，于是就出现了饥饿问题。\n这是因为我们对多线程访问同一个资源没有进行限制，全靠CPU调度来决定运行顺序；所以我们需要对线程进行一定的控制，这就是线程同步的概念\n\n饥饿问题：某一个线程一直无法申请到某种资源（比如因为优先级过低）\n同步：保证数据安全（临界资源访问）的前提下，让线程根据一定条件和顺序访问临界资源，从而避免饥饿问题\n竞态条件：因为时序问题（CPU调度）而导致程序异常；\n\n2.生产消费模型这个模型其实很简单，消费者去超市购买东西，生产者把商品投放到超市中。\n\n这时候就不需要消费者直接去找工厂问他xx东西又没有生产，他需要购买；而是转去超市里面购买xx东西；\n如果xx东西没有货了，超市就会通知生产者进行补货。如果超市里面的货架已经满了，就通知生产者不需要继续生产了；\n当商品没货了，超市会告知消费者这个东西没货，消费者会停止消费行为；而生产者补货了之后，超市就会通知消费者让他来购买\n\n\n在基础模式中，消费者要想知道一个东西有没有货，需要去超市里面看（相当于轮循检测）\n我们可以引入一个通知方式，比如超市开放一个微信公众号，告知消费者xx物品是否有货，以及告知消费者什么时候需要补货，此时就不需要消费者和生产者不断询问超市关于一个商品的情况了！这就相当于线程同步！\n2.1 生产者和消费者的关系下面提到的是普适情况\n\n消费者有多个，他们之间是竞争关系（互斥）竞争商品的购买\n生产者有多个，他们之间是竞争关系（互斥）竞争超市的货架\n消费者和生产者之间，既有互斥关系，也是同步关系（需要生产者供货了之后，消费者才能消费）这两个关系并不冲突！\n\n除了上面提到的3种生产关系，还有下面俩点\n在实际程序中，消费者和生产者都是由线程承担的（2种角色）\n超市是内存中特定的一个数据结构，也是临界资源（1个交易场所）\n\n我们可以用321原则来快速记住这几条，这样就记住了生产消费模型！👍\n\n2.2 以简单代码为例在旧模式中，main函数调用另外一个函数，想获得返回值，需要等这个函数运行完毕；好比消费者购买东西，需要去找厂家并等待厂家生产……\n\n而在生产消费者模型中，main作为主线程，只需要把待处理的数据丢进缓冲区；而线程B从缓冲区中取出数据，处理完毕后放回缓冲区。main可以先执行其他代码，过一会再过来拿线程B处理好的结果。\n这就实现了生产和消费的解耦！\n\n2.3 并发生产消费模型的并发，更多的体现在消费者在处理任务的同时，生产者可以生产任务；\n线程切换的成本低于进程，由此便提高了数据处理的效率\n\n接下来我们就要解决下面这些问题😁\n1.如何让多个消费者线程等待呢? 又如何让消费者线程被唤醒呢?2.如何让多个生产者线程等待呢? 又如何让生产者线程被唤醒呢?3.如何衡量消费者和生产者所关心的条件是否就绪呢?\n\n而前面提到的通知方式，在linux系统中，就是条件变量了！\n3.条件变量接口3.1 init&#x2F;destroy基本的接口和pthread库的其他接口很相似，都是一样的用法；其中attr也是设置条件变量的属性，这里置为nullptr即可\n#include &lt;pthread.h&gt;int pthread_cond_destroy(pthread_cond_t *cond);int pthread_cond_init(pthread_cond_t *restrict cond,                      const pthread_condattr_t *restrict attr);pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\n3.2 pthread_cond_wait这两个接口都是让线程在一个条件变量下进行等待，其中timewait接口可以设置等待的时间（超时了就不等了）\n条件变量也是临界资源，所以这里需要一个mutex锁来保证条件变量读写的原子性\n#include &lt;pthread.h&gt;int pthread_cond_timedwait(pthread_cond_t *restrict cond,                           pthread_mutex_t *restrict mutex,                           const struct timespec *restrict abstime);int pthread_cond_wait(pthread_cond_t *restrict cond,                      pthread_mutex_t *restrict mutex);\n\n3.3 pthrea_cond_signal&#x2F;broadcast这个接口的作用是给在条件变量下等待的线程发信号\n#include &lt;pthread.h&gt;int pthread_cond_broadcast(pthread_cond_t *cond);int pthread_cond_signal(pthread_cond_t *cond);\n\n其中broadcast是给在当前条件变量等待的所有线程发信号，而signal是发送信号，只唤醒一个线程；\n如果调用成功，这两个函数都会返回0；否则返回错误码\nRETURN VALUE       If  successful, the pthread_cond_broadcast() and pthread_cond_signal() functions shall return zero; otherwise, an error number shall       be returned to indicate the error.\n\n3.4 代码示例下面这个代码可以很好的演示上面提到的多个接口\n#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;signal.h&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/syscall.h&gt;using namespace std;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//锁pthread_cond_t cond;//条件变量volatile bool quit = false;void*func(void* arg)&#123;    while(!quit)//这里有bug，后续会提到    &#123;        pthread_cond_wait(&amp;cond,&amp;mutex);        cout &lt;&lt; &quot;thread is running... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;thread quit... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;&#125;int main()&#123;    pthread_cond_init(&amp;cond,nullptr);    pthread_t t1,t2,t3;    pthread_create(&amp;t1,nullptr,func,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func,(void*)&quot;t2&quot;);    pthread_create(&amp;t3,nullptr,func,(void*)&quot;t3&quot;);    char c;    while(1)    &#123;        cout &lt;&lt; &quot;[a/b]$ &quot;;        cin &gt;&gt; c;        if(c==&#x27;a&#x27;)        &#123;            pthread_cond_signal(&amp;cond);        &#125;        else if(c==&#x27;b&#x27;)        &#123;            pthread_cond_broadcast(&amp;cond);        &#125;        else        &#123;            quit = true;            break;        &#125;        usleep(500);    &#125;    cout &lt;&lt; &quot;main break: &quot; &lt;&lt; quit &lt;&lt; endl;    sleep(1);    pthread_cond_broadcast(&amp;cond);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);    pthread_join(t3,nullptr);    return 0;&#125;\n\n每次输入a，就signal会唤醒一个线程；每次输入b，会调用broadcast，唤醒当前所有线程\n[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test[a/b]$ athread is running... t1[a/b]$ athread is running... t2[a/b]$ athread is running... t3[a/b]$ bthread is running... t1thread is running... t2thread is running... t3\n\n3.4.1 小bug上面的代码示例，会出现下面的问题，即我们输入除了a和b以外的所有字符，都应该会把全局变量quit改成true，让三个线程都退出\n但观察到的现象却是只有一个线程退出了，其他线程阻塞等待了\n[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test[a/b]$ qmain break: 1thread is running... t3thread quit... t3\n\n这是因为pthread_cond_wait里面进行了独特的操作，即等待之前，它会释放锁，等待之后，他会重新申请锁\nint pthread_cond_wait(pthread_cond_t *restrict cond,                      pthread_mutex_t *restrict mutex)&#123;\tpthread_mutex_unlock(mutex);//先解锁    //避免因为该线程拿着锁去休眠了，导致其他线程无法申请该锁    \t//条件变量相关代码\t    pthread_mutex_lock(mutex);//条件满足后，再加锁&#125;\n\n第一个退出的线程，退出之前申请了锁却没有释放，于是就导致其他线程在条件满足后，没有办法申请锁，只能阻塞等待！\n3.4.2 修正修正的方法很简单，我们只需要在while(!quit)循环的退出条件满足之后，释放一下锁，就OK了！\nvoid*func(void* arg)&#123;    while(!quit)    &#123;        pthread_cond_wait(&amp;cond,&amp;mutex);        cout &lt;&lt; &quot;thread is running... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;            &#125;    pthread_mutex_unlock(&amp;mutex);//正确操作：需要在条件满足后，解锁    cout &lt;&lt; &quot;thread quit... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;&#125;\n\n此时就能看到，所有线程都正常退出了！\n[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test[a/b]$ qmain break: 1thread is running... t1thread quit... t1thread is running... t2thread quit... t2thread is running... t3thread quit... t3[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$\n\n3.4.3 典型错误在我们的正常思路中，申请条件变量之前应该解锁，申请完毕后再加锁；根据这点，就能引出一个比较典型的死锁错误。\n因为，实际上pthread_cond_wait(&amp;cond); 这个函数是会主动帮我们处理加锁和解锁的操作的。所以我们并不需要自己来处理。否则会出现死锁！正常使用的时候，我们应该把锁传入这个函数，让它来帮我们处理。\npthread_mutex_lock(&amp;mutex);while (condition_is_false) &#123;    pthread_mutex_unlock(&amp;mutex);    pthread_cond_wait(&amp;cond);//解锁和加锁的操作，该函数会帮我们完成    pthread_mutex_lock(&amp;mutex);//二次申请同一把锁，出现死锁！&#125;pthread_mutex_unlock(&amp;mutex);\n\n两次申请同一把锁，就好比自己把自己绊倒了😂我们要避免写出这样的错误代码！\n\n4.阻塞队列-生产消费模型实例这个队列的作用，就是提供一个超市，供生产者和消费者进行数据的交换\n\n生产者，往队列里面push数据\n消费者，从队列里面pop数据\n\n看起来有些类似于管道，同样的，生产者和消费者在读取阻塞队列的时候，不仅需要保证自己的操作是原子操作，还需要做到一定的访问控制；即消费者在队列空的时候不能继续pop，生产者在队列满的时候不能继续push\n此时，我们还可以引入一个微信公众号，也就是一定的通知方式：不要让生产者、消费者疯狂检测阻塞队列，而是引入条件变量，在队列不为空的时候，通知消费者；在队列不为满的时候，通知生产者；这样就达到了线程之间的同步。\n4.1 成员变量要实现阻塞队列，我们首先需要理清楚需要什么成员变量，来保护该队列\n\n用于访问控制的锁，同一时刻只能有一个线程访问队列\n用户线程同步的条件变量，因为我们需要在不同的条件下通知不同的人，所以需要2个条件变量\n一个队列，为了方便，采用std::queue，这样就不用自己造轮子了\n\n理清楚了之后，就可以来写成员变量啦；我采用了模板类型，这样阻塞队列就可以用来存放任何我们想要的类型了\ntemplate&lt;class T&gt;class BlockQueue&#123;private:    queue&lt;T&gt; _bq;//队列    size_t _size;//大小    pthread_mutex_t _mutex;//锁    pthread_cond_t _proInf;//通知生产者    pthread_cond_t _conInf;//通知消费者public:    BlockQueue(int sz=5)        :_size(sz)    &#123;        pthread_mutex_init(&amp;_mutex,nullptr);        pthread_cond_init(&amp;_proInf,nullptr);        pthread_cond_init(&amp;_conInf,nullptr);    &#125;    ~BlockQueue()    &#123;        pthread_mutex_destroy(&amp;_mutex);        pthread_cond_destroy(&amp;_proInf);        pthread_cond_destroy(&amp;_conInf);    &#125;&#125;;\n\n你可能想问，queue不是有封装size吗？哪这里我们还定义一个大小变量，会不会有些多余？\nnope！实际上，这里的这个_size 就好比我们在C语言写顺序表的时候，成员capacity；其作用是来判断我们的队列有没有满的。\n\n4.2 push和pop对于一个队列，最重要的操作就是在队头出数据，队尾入数据\n简单说来，就是需要在处理队列数据的时候进行加锁，保证原子性；\n除此以外，生产者和消费者有不同的操作逻辑：\n\n生产\n判断是否符合生产条件（队列没有满）\n满，不生产；不满，生产；\n满了的时候，生产者应在条件变量中等待（等待消费者消费）\n不满的时候，生产者生产，并通知消费者来消费\n\n\n消费\n判断是否满足消费条件（队列不为空）\n空，不消费；不空，消费；\n空了的时候，消费者应该在条件变量中等待（等待生产者生产）\n不空的时候，消费者消费，并通知生产者继续生产\n\n\n\n这样就实现了阻塞队列push和pop的基本逻辑；由此可以写出下面的代码\n//消费者消费T pop()&#123;    //加锁    pthread_mutex_lock(&amp;_mutex);    //判断条件    if(_size)//空，不消费    &#123;        pthread_cond_wait(&amp;_conInf,&amp;_mutex);    &#125;    //消费并通知生产者    T tmp = _bq.front();    _bq.pop();    pthread_cond_signal(&amp;_proInf);    //解锁    pthread_mutex_unlock(&amp;_mutex);    return tmp;&#125;//生产者生产void Push(const T&amp; in)&#123;    //加锁    pthread_mutex_lock(&amp;_mutex);    //判断条件    if(bq.size()&gt;=_size)//满，不生产    &#123;        pthread_cond_wait(&amp;_proInf,&amp;_mutex);    &#125;    //生产并通知消费者    _bq.push(in);    pthread_cond_signal(&amp;_conInf);    //解锁    pthread_mutex_unlock(&amp;_mutex);&#125;\n\n4.2.1 运行测试有了这个基本框架，我们就可以来测试一下代码啦！\n先来一个生产者和消费者康康吧\n#include &quot;blockqueue.hpp&quot;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;void *consume(void *args)&#123;    BlockQueue&lt;int&gt; *bqp = (BlockQueue&lt;int&gt; *)args;    while(1)    &#123;        // 消费        int ret = bqp-&gt;pop();        cout &lt;&lt; &quot;consume &quot; &lt;&lt; pthread_self() &lt;&lt; &quot; 消费：&quot; &lt;&lt; ret &lt;&lt; endl;        sleep(1);    &#125;&#125;void *produce(void *args)&#123;    BlockQueue&lt;int&gt; *bqp = (BlockQueue&lt;int&gt; *)args;    while (1)    &#123;        // 制作        cout &lt;&lt; &quot;########↓&quot; &lt;&lt; endl;        int a = rand()%100;        // 投放到超市        bqp-&gt;push(a);        cout &lt;&lt; &quot;produce &quot; &lt;&lt; pthread_self() &lt;&lt; &quot; 生产：&quot; &lt;&lt; a &lt;&lt; endl;        sleep(2);    &#125;&#125;int main()&#123;    srand((unsigned int)time(nullptr));    pthread_t t1,t2;    BlockQueue&lt;int&gt; bq(5);    pthread_create(&amp;t1,nullptr,produce,(void*)&amp;bq);    pthread_create(&amp;t2,nullptr,consume,(void*)&amp;bq);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);    return 0;&#125;\n\n可以看到，刚开始消费者并没有运行，而是等待生产者生产出数据了之后，再开始消费！我们的目的成功达成！\n[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./test########↓produce 139716365768448 生产：41########↓produce 139716365768448 生产：11consume 139716357375744 消费：41########↓produce 139716365768448 生产：19consume 139716357375744 消费：11########↓produce 139716365768448 生产：19consume 139716357375744 消费：19########↓produce 139716365768448 生产：25consume 139716357375744 消费：19########↓produce 139716365768448 生产：63consume 139716357375744 消费：25\n\n如果增加线程到2生产2消费，则会看到下面的情况\n[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./test########↓produce 140483816179456 生产：51consume 140483807786752 消费：51########↓produce 140483799394048 生产：38consume 140483791001344 消费：38########↓produce 140483816179456 生产：37consume 140483807786752 消费：37\n\n每次被唤醒的生产者和消费者都是不一样的，交替唤醒\n4.2.2 进一步封装为了代码的可读性，我们可以对阻塞队列进一步封装\n#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;using namespace std;template&lt;class T&gt;class BlockQueue&#123;private:    queue&lt;T&gt; _bq;//队列    size_t _size;//大小    pthread_mutex_t _mutex;//锁    pthread_cond_t _proInf;//通知生产者    pthread_cond_t _conInf;//通知消费者public:    BlockQueue(int sz=5)        :_size(sz)    &#123;        pthread_mutex_init(&amp;_mutex,nullptr);        pthread_cond_init(&amp;_proInf,nullptr);        pthread_cond_init(&amp;_conInf,nullptr);    &#125;    ~BlockQueue()    &#123;        pthread_mutex_destroy(&amp;_mutex);        pthread_cond_destroy(&amp;_proInf);        pthread_cond_destroy(&amp;_conInf);    &#125;    //消费者消费    T pop()    &#123;        //加锁        lock();        //判断条件        if(isEmpty())//空，不消费        &#123;            ConWait();        &#125;        //消费并通知生产者        T tmp = _bq.front();        _bq.pop();        WakeUpPro();        //解锁        unlock();        return tmp;    &#125;    //生产者生产    void push(const T&amp; in)    &#123;        //加锁        lock();        //判断条件        if(isFull())//满，不生产        &#123;            ProWait();        &#125;        //生产并通知消费者        _bq.push(in);        WakeUpCon();        //解锁        unlock();    &#125;private:    void lock()    &#123;        pthread_mutex_lock(&amp;_mutex);    &#125;    void unlock()    &#123;        pthread_mutex_unlock(&amp;_mutex);    &#125;    //唤醒消费者    void WakeUpCon()    &#123;        pthread_cond_signal(&amp;_conInf);    &#125;    //唤醒生产者    void WakeUpPro()    &#123;        pthread_cond_signal(&amp;_proInf);    &#125;    //消费者等待    void ConWait()    &#123;        pthread_cond_wait(&amp;_conInf,&amp;_mutex);    &#125;    //生产者等待    void ProWait()    &#123;        pthread_cond_wait(&amp;_proInf,&amp;_mutex);    &#125;    //判断条件    bool isFull()    &#123;        return _size == _bq.size();    &#125;    bool isEmpty()    &#123;        return _bq.empty();    &#125;&#125;;\n\n4.2.3 使用task分配运算任务因为阻塞队列是用模板类型的，我们可以自己实现一个仿函数，来给生产者消费者分配任务\n#pragma once#include &lt;iostream&gt;using namespace std;class Task&#123;public:    Task(int one=0, int two=0, char op=&quot;+&quot;)         : _elem1(one), _elem2(two), _operator(op)    &#123;&#125;    // 仿函数    int operator() ()    &#123;        return run();    &#125;    // 运行仿函数    int run()    &#123;        int result = 0;        switch (_operator)        &#123;        case &#x27;+&#x27;:            result = _elem1 + _elem2;            break;        case &#x27;-&#x27;:            result = _elem1 - _elem2;            break;        case &#x27;*&#x27;:            result = _elem1 * _elem2;            break;        case &#x27;/&#x27;:        &#123;            if (_elem2 == 0)            &#123;                cout &lt;&lt; &quot;div zero, abort&quot; &lt;&lt; endl;                result = -1;            &#125;            else            &#123;                result = _elem1 / _elem2;            &#125;            break;        &#125;         case &#x27;%&#x27;:        &#123;            if (_elem2 == 0)            &#123;                cout &lt;&lt; &quot;mod zero, abort&quot; &lt;&lt; endl;                result = -1;            &#125;            else            &#123;                result = _elem1 % _elem2;            &#125;            break;        &#125;        default:            cout &lt;&lt; &quot;unknown: &quot; &lt;&lt; _operator &lt;&lt; endl;            break;        &#125;        return result;    &#125;    // 获取元素，方便打印    void get(int *e1, int *e2, char *op)    &#123;        *e1 = _elem1;        *e2 = _elem2;        *op = _operator;    &#125;private:    int _elem1;    int _elem2;    char _operator;&#125;;\n\n测试一下\n#include &quot;blockqueue.hpp&quot;#include &quot;task.hpp&quot;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;string&gt;string ops =&quot;+-*/%&quot;;void *consumer(void *args)&#123;    BlockQueue&lt;Task&gt; *bqp = (BlockQueue&lt;Task&gt; *)args;    while (1)    &#123;        Task t = bqp-&gt;pop();        int result = t();    //处理任务        int one, two;        char op;        t.get(&amp;one, &amp;two, &amp;op);        cout &lt;&lt; &quot;consumer [&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 消费了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = &quot; &lt;&lt; result &lt;&lt; endl;    &#125;&#125;void *producer(void *args)&#123;    BlockQueue&lt;Task&gt; *bqp = (BlockQueue&lt;Task&gt; *)args;    while (1)    &#123;        // 制作任务        int one = rand() % 50;        int two = rand() % 20;        char op = ops[rand() % ops.size()];        Task t(one, two, op);        // 投放给消费者生产        bqp-&gt;push(t);        cout &lt;&lt; &quot;producter[&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 生产了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = ?&quot; &lt;&lt; endl;        sleep(1);    &#125;&#125;void test2()&#123;    pthread_t t1,t2;    BlockQueue&lt;Task&gt; bq(5);    pthread_create(&amp;t1,nullptr,producer,(void*)&amp;bq);    sleep(1);    pthread_create(&amp;t2,nullptr,consumer,(void*)&amp;bq);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;int main()&#123;    srand((unsigned long)time(nullptr));//乘一个数字添加随机性    test2();    return 0;&#125;\n\n运行，可以看到生产者生产了问题之后，消费者会去解答。此时我们只需要在线程中取回运算好的结果，就OK了！\n[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./testproducter[140703422265088] 1673319321 生产了一个任务: 43-16 = ?consumer [140703413872384] 1673319322 消费了一个任务: 43-16 = 27producter[140703422265088] 1673319322 生产了一个任务: 45/12 = ?consumer [140703413872384] 1673319322 消费了一个任务: 45/12 = 3producter[140703422265088] 1673319323 生产了一个任务: 17/7 = ?consumer [140703413872384] 1673319323 消费了一个任务: 17/7 = 2producter[140703422265088] 1673319324 生产了一个任务: 49-14 = ?consumer [140703413872384] 1673319324 消费了一个任务: 49-14 = 35producter[140703422265088] 1673319325 生产了一个任务: 4%4 = ?consumer [140703413872384] 1673319325 消费了一个任务: 4%4 = 0\n\n\n5.阻塞队列-循环队列5.0 为啥用循环队列上面的队列是封装了queue，下面我们要利用环形队列的方式来实现一个功能相同的环形队列。\n所谓循环队列，就是在一个一维数组中，通过头尾两个指针，来标识队列的头尾。如果数据数量超出空间末尾，则在空间的开头放入，并移动尾指针\n\n这部分可以看我的博客 循环队列\n\n用上循环队列，就有一个显著的优势：因为我们访问的（假设是数组）是不同下标位置，其并非同一块内存空间，所以是可以同时访问的！这样就进一步显现了生产消费的并发属性\n这就相当于把循环队列这个临界资源分成了一小块一小块；只有满&#x2F;空的时候，头尾指针会指向同一块空间，其余时间都是不冲突的！\n注意：这需要程序猿来保证，获取了信号量之后，访问的肯定是临界资源中的不同区域，否则如果访问到了同一块区域，还是会出问题的！\n5.1 POSIX信号量这里又要重新认识一下信号量了，在先前的博客中，简单提到了信号量的概念，其本质上是一个计数器。\n\np操作：申请资源\nv操作：归还资源\n\n对信号量的操作是原子的，不会因为线程切换而发生错误和冲突。\n循环队列需要有两个标识符，来标识当前数据的头尾。注意，信号量可不能做下标使用，这里我们可以用int类型，加锁来解决原子性问题；\n\n信号量在环形队列中的作用，还是用于标识 空间剩余/数据数量\n因为这是一个阻塞队列：\n\n生产者放入数据，对应的是空间信号量，只有有空间的时候，才能往环形队列里面放入\n消费者取出数据，对应的是数据信号量，没有数据也就不能取了\n\n此时，先前介绍的semop函数在此环节不太适合，在此介绍两个来自pthread库的新接口；这些接口在编译的时候都需要带上-lpthread\n5.1.1 sem_init&#x2F;destroy#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value);int sem_destroy(sem_t *sem);\n\n因为都是pthread库的，其使用方法还是很相似的，我们需要对信号量进行初始化，并给定一个value作为信号量的初始值；\n对init函数的pshared参数做一定讲解，在man手册中的介绍是这样的\n\n如果我们的信号量需要在线程中共享，那就将该参数设置为0；\n如果信号量需要在进程中共享，其就应该处在共享内存区域，可以对添加了共享内存的进程之间共享；\n阻塞队列是给线程使用的，所以我们设置成0就可以了。\n5.1.2 sem_wait这个接口和锁&#x2F;条件变量的wait是一样的，其作用是申请一个信号量，如果信号量为0，则在此处等待，直到信号量非0\nNAME       sem_wait, sem_timedwait, sem_trywait - lock a semaphoreSYNOPSIS       #include &lt;semaphore.h&gt;       int sem_wait(sem_t *sem);       int sem_trywait(sem_t *sem);       int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);       Link with -pthread.\n\n可以简单理解为，这个接口的作用就是让信号量-1\ntrywait则是非阻塞检测；timewait是设置等待的时间，超时就不等了。这点和条件变量的接口是一样的\n5.1.3  sem_post这个接口的作用就是释放一个信号量，相当于给这个信号量+1\nNAME       sem_post - unlock a semaphoreSYNOPSIS       #include &lt;semaphore.h&gt;       int sem_post(sem_t *sem);\n\n5.1.4 在循环队列里面使用知道了这几个接口，对于我们环形队列的使用就比较明了了\n\n当生产者开始生产的时候，申请一个空间信号量（剩余空间-1）生产完毕后，释放一个数量信号量（剩余数量+1）\n当消费者开始消费的时候，申请一个数量信号量（剩余数量-1）生产完毕后，释放一个空间信号量（剩余空间+1）\n\n除了这两个信号量，生产消费的时候，还需要操作头尾指针，指向队列正确的位置\n5.2 成员变量前面铺垫了那么多，现在就可以来试试水了！\nvector&lt;T&gt; _rq;//队列sem_t _spaceSem;//空间信号量sem_t _valueSem;//数据信号量pthread_mutex_t _proMutex;//生产者的锁pthread_mutex_t _conMutex;//消费者的锁size_t _rear;//尾指针size_t _front;//头指针\n\n因为信号量就可以充当条件变量的角色，所以这里就不需要条件变量来通知生产者&#x2F;消费者了\n5.3 构造&#x2F;析构接下来要做的，就是写构造&#x2F;析构了\nRingQueue(int capa = 5)    :_rq(capa),    _rear(0),    _front(0)&#123;    sem_init(&amp;_spaceSem,0,capa);//空间    sem_init(&amp;_valueSem,0,0);//数量为0    pthread_mutex_init(&amp;_proMutex,nullptr);    pthread_mutex_init(&amp;_conMutex,nullptr);&#125;~RingQueue()&#123;    sem_destroy(&amp;_spaceSem);    sem_destroy(&amp;_valueSem);    pthread_mutex_destroy(&amp;_proMutex);    pthread_mutex_destroy(&amp;_conMutex);&#125;\n\n5.4 生产消费首先我们需要知道，当队列满&#x2F;空的时候，分别对应啥情况\n\n满：生产太多了，生产者得休息\n空：消费太多了，消费者得缓缓\n\n因为有信号量帮我们做了访问控制，所以我们不需要判断循环队列什么时候为满，什么时候为空：\n\n满的时候：数量&#x3D;队列容量，空间信号量&#x3D;0，无法申请空间，无法生产\n此时生产者会在空间信号量里面等待，不会继续生产；消费者继续消费\n空的时候：空间&#x3D;队列容量，数量信号量&#x3D;0，没有可以消费的\n此时消费者会在数量信号量里面等待，不会继续消费；生产者继续生产\n\n这也是信号量作为访问控制的一大特征，当你申请成功了，就代表你肯定有临界资源的访问权限了；再加上我们给访问临界区加了锁，自然也不会出现被其他线程抢了的情况🎉\n//生产者void Push(T&amp; in)&#123;    sem_wait(&amp;_spaceSem);//获取空间    pthread_mutex_lock(&amp;_proMutex);    _rq[_rear] = in; //生产    _rear++;         // 写入位置后移    _rear %= _rq.size(); // 更新下标，避免越界    pthread_mutex_unlock(&amp;_proMutex);    sem_post(&amp;_valueSem);//释放数量&#125;//消费T pop()&#123;    sem_wait(&amp;_valueSem);    pthread_mutex_lock(&amp;_conMutex);    T tmp = _rq[_front];    _front++;    _front %= _rq.size();// 更新下标，保证环形特征    pthread_mutex_unlock(&amp;_conMutex);    sem_post(&amp;_spaceSem);    return tmp;&#125;\n\n5.5 测试string ops =&quot;+-*/%&quot;;void *consumer(void *args)&#123;    RingQueue&lt;Task&gt; *bqp = (RingQueue&lt;Task&gt; *)args;    while (1)    &#123;        Task t = bqp-&gt;pop();        int result = t();    //处理任务        int one, two;        char op;        t.get(&amp;one, &amp;two, &amp;op);        cout &lt;&lt; &quot;consumer [&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 消费了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = &quot; &lt;&lt; result &lt;&lt; endl;    &#125;&#125;void *producer(void *args)&#123;    RingQueue&lt;Task&gt; *bqp = (RingQueue&lt;Task&gt; *)args;    while (1)    &#123;        // 制作任务        int one = rand() % 50;        int two = rand() % 20;        char op = ops[rand() % ops.size()];        Task t(one, two, op);        // 投放给消费者生产        bqp-&gt;push(t);        cout &lt;&lt; &quot;producter[&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 生产了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = ?&quot; &lt;&lt; endl;        sleep(1);    &#125;&#125;void test2()&#123;    pthread_t t1,t2;    RingQueue&lt;Task&gt; bq(5);    pthread_create(&amp;t1,nullptr,producer,(void*)&amp;bq);    sleep(1);    pthread_create(&amp;t2,nullptr,consumer,(void*)&amp;bq);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;int main()&#123;    srand((unsigned long)time(nullptr));//乘一个数字添加随机性    test2();    return 0;&#125;\n\n刚开始运行的时候，发现了这个错误\n\n这是因为在task中，我们重写了构造函数，编译器就不会生成默认构造了\nTask(int one, int two, char op)     : _elem1(one), _elem2(two), _operator(op)&#123;&#125;\n\n而创建环形队列的时候，会自动调用构造函数。此时发现没有匹配的构造函数（无参），就会报错！\n解决办法是，添加上一个无参构造，直接使用default关键字即可\nTask() = default;//使用系统默认生成的无参构造\n\n运行，可以看到生产消费稳定跑起来了！\n[muxue@bt-7274:~/git/linux/code/23-01-17 ringqueue]$ ./testproducter[139758380586752] 1673936332 生产了一个任务: 24-8 = ?producter[139758380586752] 1673936333 生产了一个任务: 34/19 = ?consumer [139758372194048] 1673936333 消费了一个任务: 24-8 = 16consumer [139758372194048] 1673936333 消费了一个任务: 34/19 = 1producter[139758380586752] 1673936334 生产了一个任务: 18*16 = ?consumer [139758372194048] 1673936334 消费了一个任务: 18*16 = 288producter[139758380586752] 1673936335 生产了一个任务: 48+15 = ?consumer [139758372194048] 1673936335 消费了一个任务: 48+15 = 63\n\n增多线程，也能正常运行！\n[muxue@bt-7274:~/git/linux/code/23-01-17 ringqueue]$ ./testproducter[140344921630464] 1673936659 生产了一个任务: 44-15 = ?consumer [140344913237760] 1673936660 消费了一个任务: 44-15 = 29producter[140344921630464] 1673936660 生产了一个任务: 33+14 = ?consumer [140344913237760] 1673936660 消费了一个任务: 33+14 = 47producter[140344904845056] 1673936661 生产了一个任务: 14/12 = ?consumer [140344896452352] 1673936661 消费了一个任务: 14/12 = 1producter[140344921630464] 1673936661 生产了一个任务: 24-16 = ?consumer [140344913237760] 1673936661 消费了一个任务: 24-16 = 8producter[140344904845056] 1673936662 生产了一个任务: 3-3 = ?consumer [140344896452352] 1673936662 消费了一个任务: 3-3 = 0producter[140344921630464] 1673936662 生产了一个任务: 36*7 = ?consumer [140344913237760] 1673936662 消费了一个任务: 36*7 = 252producter[140344904845056] 1673936663 生产了一个任务: 28+8 = ?consumer [140344896452352] 1673936663 消费了一个任务: 28+8 = 36producter[140344921630464] 1673936663 生产了一个任务: 26-5 = ?consumer [140344913237760] 1673936663 消费了一个任务: 26-5 = 21\n\n结语关于线程同步的知识点，大概就是这些了。博客写的满满当当，在理解了接口的基本命名和使用逻辑后，感觉就没有那么难了\n加油哦！\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】网络原理","url":"/posts/4145270627/","content":"本篇博客让我们一起来了解一下网络的基本原理\n\n\n1.网络发展背景关于网络发展的历史背景这种东西就不多bb了，网上很容易就能找到参考资料，我的专业性欠缺，文章参考意义也不大。这里只做简单说明。\n网络发展经过了如下几个模式：\n\n独立模式：计算机之间相互独立，靠人移动数据\n互联模式：多台计算机连接到一起，实现数据共享\n局域网LAN：计算机数量增多，通过交换机&#x2F;路由器连接到一起\n广域网WAN：将相隔距离非常远的计算机连在一起\n\n交换机是啥？简单来说就是一个有很多网口的设备，将设备插上去后（一般用的都是RJ45网线）就能相互交流信息。我们家用的WIFI路由器其实已经集成了交换机的功能！\n1983年，TCP&#x2F;IP协议成为ARPANET上的标准协议，人们把1983年称为互联网的诞生时间。\n1.1 计算机设备之间是怎么交流的？计算机内部有非常多的设备，在设备和设备之间一定要用“线”进行连接。这样这些设备才能相互通信。比如主板上的总线，链接硬盘的sata线等等。\n而这个计算机的结构本质上也能被看作一个小型网络。\n此时我们将计算机A和B用数据线连接起来，就能在物理层面上，让A和B相互通信（此时暂且不考虑通过何种方式通信，只要用数据线连起来了，那就一定能通信）\n\n在主机内，线短\n跨主机，线长\n\n当数据线长了之后，线路和线路之间就容易产生信号的干扰，导致数据的错误&#x2F;丢失。此时我们就需要一个更可靠、高效的方式来实现远距离计算机之间的通信，这就是网络的意义\n1.2 集群进一步扩大，实际上，还可以用多台主机相连，实现单一的功能。这时候，这一堆主机被称为集群\n\n存储集群：硬盘\n缓存集群：内存\n计算集群：Cpu&#x2F;Gpu\n\n不同的集群干不同的事，再用数据线连起来，就成了一台由多个主机共同构成的“电脑”\n\n在大型的数据中心里面，就是用这种方式来处理海量的数据的。\n1.3 因特网当前我们主要在计算机上使用的是Internet，官方名称为因特网，日常说的互联网就是因特网。\n但还有另外一个互连网，其概念是互相连接的网络，英文名是internet（小写的i），互联网 ≠ 互连网！\n1.4 ISP&#x2F;IXPISP的中文名是互联网服务提供者，在我们国内说的就是三大运营商\nIXP是狐狸那我交换点，允许两个网络直接相连并快速提供分组的转发。\n2.协议协议是一种约定，约定好两台设备要用什么方式来交流。\n比如我们都是中国人，可以用普通话这个协议来交流；而广东地区的人，可以用粤语来交流。\n计算机之间想交流，肯定也需要确定好一个行业通用的协议！\n否则不同计算机的架构/操作系统/硬件设备不一样，若协议不统一，也就无法正常交流。这就好比一个说英语的人听不懂普通话一样。\n2.1 分层网络的协议是分层的\n2.1.1 为什么要分层软件分层，就好比将主代码和功能代码给分开\n\n此时只要功能代码提供的接口不变，主代码的调用方式就不变\n主代码无须关心功能代码是如何处理的，只关心其处理的结果（返回值）\n工程师修改代码的时候，只需要定位到具体模块进行修改，不会出现牵一发动全身的情况\n\n这样，就实现了主模块和功能模块的解耦\n\n由于网络涉及到了软件到硬件各种层面的设备操作，所以其必须采用分层的协议。不同设备采用不同的协议，才能最大层面的保证网络系统整体不出bug\n\n网络协议有一个特点：同层设备都可以认为自己在直接和对方通信\n2.1.2 电话机例子以下图为例，当俩个人用座机打电话的时候，他们会认为自己在直接和对方交流，而不会认为自己是在和电话机交流\n\n此时，就可以把这个系统分3层：分别是两人之间的语言协议，电话机和电话机之间读取数据的协议，以及最底层用于传输信号的通信协议\n\n用户不会去关心电话机用的是什么协议，而是关心自己应该用什么语言和对方交流\n电话机不会去关心用户是用什么语言交流的，其只负责把收到的声音转换成电信号\n通信协议不管电话机是怎么封装的，其只负责传输数据\n\n这里就能看出来，不仅同层的设备可以认为自己是直接和对方交流，而且它还不需要管其他层用的是什么协议！\n\n电话机不会因为你说英语而用不了\n\n这就是分层实现解耦的效果，也算是每一层都实现了自己的封装\n2.2 OSI七层模型\nOSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型， 是一个逻辑上的定义和规范; \n它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机;\nOSI 七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输;\n它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整。 通过七 个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯\n\n\n可以用下面的这个表格来简单了解一下每一层的功能\n\n\n\n分层名称\n功能\n概览\n\n\n\n应用\n针对特定应用的协议\nSTMP邮件&#x2F;远程登录&#x2F;文件传输\n\n\n表示\n数据固有格式和网络标准格式的转换\n接收不同表现形式的信息\n\n\n会话\n通信管理，负责建立&#x2F;断开通信连接，维持不同应用程序的通信\n何时建立&#x2F;何时断开&#x2F;建立多久\n\n\n传输\n两个节点之间的数据传输\n维持传输可靠性\n\n\n网络\n地址管理&#x2F;路由选择（逻辑寻址\n确定最佳路径\n\n\n数据链路\n互联设备之间传送和识别数据\n将数据组合成字节\n\n\n物理\n以01二进制进行数据传输\n网线\n\n\n但是OSI七层模型相对比较复杂，我们主要关注的还是TCP/IP模型\n2.3 TCP&#x2F;IPTCP&#x2F;IP是一组协议的代名词，它其中包括很多协议，组成了一个整体。为了方便使用，TCP&#x2F;IP协议将OSI的上方3层统一称为应用层，由用户字节决定如何进行数据的序列化&#x2F;反序列化，什么时候建立连接，什么时候断开连接\n\nTCP&#x2F;IP模型可以认为是4&#x2F;5层，每一层也有自己不同的功能。每一层都会调用另外一层，来实现自己的需求\n\n物理层: 负责光&#x2F;电信号的传递方式。 比如现在以太网通用的网线(双绞 线)、早期以太网采用的的同轴电缆 (现在主要用于有线电视)、光纤, 现在的wifi无线网使用电磁波等都属于物理层的概念。物理层的能力决 定了最大传输速率、传输距离、抗干扰性等。集线器(Hub)工作在物理层\n数据链路层: 负责设备之间的数据帧的传送和识别。 例如网卡设备的驱动、帧同步(就是说从网线上检测 到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作。 有以太 网、令牌环网, 无线LAN等标准。交换机(Switch)工作在数据链路层\n网络层: 负责地址管理和路由选择。 例如在IP协议中, 通过IP地址来标识一台主机, 并通过路由表的方式规 划出两台主机之间的数据传输的线路(路由)。路由器(Router)工作在网路层\n传输层: 负责两台主机之间的数据传输。 如传输控制协议 (TCP)， 能够确保数据可靠的从源主机发送到目标 主机\n应用层: 负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问 协议（Telnet）等。 我们的网络编程主要就是针对应用层。\n\n为啥这里有5层，却有时候又说是4层呢？😏\n因为物理层关注的较少，所以一般都只注重于剩下的4层\n3.网络和操作系统之间的关系用户的网络请求要想成功发送给对方，那就一定要经过网卡这个硬件；而要经过网卡，那就肯定要经过操作系统——只有操作系统能直接访问硬件！\n所以，数据在主机内流动的时候，就一定会从用户走到内核，再最终走到物理层进行传输！\n\n因为计算机的体系结构决定了数据流动的时候，一定要经过操作系统，所以肯定会是自顶向下&#x2F;自底向上进行流动的！\n\n这就引出了二者的关系\n\n网络协议栈是属于操作系统的：在操作系统中，有一个模块就是专门来处理tcp&#x2F;ip协议的。\n\n前面提到，每一层都可以认为自己是在和对方同层的用户直接通信。这样做是有一定代价的，且听我细细道来。\n3.1 快递例子当我们网购商品的时候，我们作为用户，是直接和商家联系的。下了订单后，商家要去做一系列的操作，最终我们从快递小哥处拿到了商品\n\n\n\n客户\n商家\n\n\n\n在商家处下订单\n接收到用户订单\n\n\n从快递员处收到货物\n将货物交给快递员\n\n\n货物运输到集散点\n货物运输到集散点\n\n\n但，我们收到的快递并不是只有我们要的商品，往往这里面都会多出一些东西\n\n如图，我们的商品被一个盒子包裹着，外头还多了一个快递单\n\n\n\n客户\n商家\n\n\n\n\n在商家处下订单\n接收到用户订单\n给出收件地址\n\n\n从快递员处收到货物\n将货物交给快递员\n添加外箱并填写邮寄单\n\n\n货物运输到集散点\n货物运输到集散点\n开始运输\n\n\n在这个例子中，每一层其实都给出了自己的独有协议。我们可以把最下面的运输当作物理层。\n快递小哥在包装快递的时候，就会给快递增加一个外箱，并填写好邮寄单。当另外一边的快递小哥收到这个货物的时候，就可以更具邮寄单上的信息，将快递送到用户手上。\n3.2 报头&#x2F;解包此过程中，为了维护快递的出发地/终点地信息，快递员给货物添加上了客户不需要的东西。\n\n在网络协议中，每一层协议，都会给我们要传输的数据添加上独有的协议信息，再交付给下一层；这些信息是用来维护数据的（就好比快递单号上的地址）\n多出来的协议数据被称为：报头\n\n\n收到信息后，同层协议会取出自己的那份协议信息进行分析，再交付给上一层\n拆开数据的过程被称为：解包\n\n\n\n\n不知道快递的例子能否帮助你理解这个过程\n\n3.3 报头的作用数据会有不同的应用，也对应了不同的协议。在封包的时候，添加的报头信息里面就应包含目标的协议信息\n\n比如我的信息是SMTP邮箱信息，那么在目标主机接收到进行解包了以后，也需要将这个信息交给支持SMTP的邮箱软件进行处理\n报头属性里面就需要包含支持分用👆的属性（还有一些公共属性）\n报头属性里面还需要包含区分有效载荷和报头的属性，也就是将要发送的数据，和这一层的报头给拆开，不能到时候分不出来，无法正常解包了\n\n这个过程就是一个分用的过程，我们传送的信息，被称为有效载荷\n\n快递点也是一样，如果快递点收到的都是商品而没有快递单，快递小哥也就无法知道快递应该送给谁了\n4.局域网以太网的命名来自物理学中的以太，这部分的故事可以百度😶‍🌫️大学物理课上也讲过。\n\n如果两台主机，处于同一局域网中，他们之间能通信吗？\n和同学开手机热点联机MC的经历告诉我😏，是可以的\n\n4.1 MAC地址局域网就好比一个餐厅，里面有很多人在聊天。当你在餐厅里面和张三聊天的时候，旁边的人也能听到你们俩交流的内容。局域网内也是如此。\n要想在局域网内准确地找到一个设备，那就需要一个唯一标识码。就好比想在教室里面找到一个人，需要知道名字一样（排除同名问题）\n每台主机唯一的标识码，就是该主机对应的MAC地址\n\nMAC地址用来识别数据链路层中相连的节点\n长度为48位, 及6个字节。 一般用16进制数字加上冒号的形式来表示(例如: 08:01:27:04:fb:19) \nMAC地址在网卡出厂时就确定了，不能修改！ 且mac地址通常是唯一的（虚拟机中的mac地址不是真实的mac地址，可能会冲突；也有些网卡支持用户配置mac地址）\n\n局域网内没有发送限制，任何一台主机随时都可发送消息。此时还需要引入碰撞检测机制，在没有人发送信号的时候，本设备再发送信号。避免多台主机通信时，出现信号撞到一起（碰撞域）而导致的信息丢失。\n以系统编程的角度来看，此时的局域网可以认为是一个临界资源。保证数据不被碰撞，就是保护临界资源的一致性！😛\n4.2 通信原理和前面提到的报头&#x2F;解包一样，局域网内的数据，也是自顶向下、自底向上流动的。\n每一层都有自己的协议，也需要加上自己的报头\n\n5.广域网在广域网内通信就没有那么简单了。这就好比唐僧去西天取经，不是直接走到西天的，而是需要经过多个驿站（中途地点）\n在广域网内通信，我们则是通过ip地址来做驿站，来查找目标主机的\n\n在局域网内用的是mac来标识目标的唯一性\n广域网内采用ip来标识目标的唯一性\n\n5.1 IP地址IP协议有两个版本，IPv4和IPv6（本文只关注v4）\nIP地址是在IP协议中，用来标识网络中不同主机的地址；\n对于IPv4来说，IP地址是一个4字节，32位的整数。通常使用 “点分十进制” 的字符串表示IP地址, 例如 192.168.0.1；用点分割的每一个数字表示一个字节, 范围是 0 - 255；\n因ipv4的规定的局限性，ipv4的ip现在已经逐渐枯竭，很多地方的运营商已经不提供家用宽带的公网IP地址。\n5.2 通信过程在广域网通信的时候，每次都需要提供源IP和目标IP，这就是从哪儿来/到哪儿去；同时，还需要提供源MAC和目标MAC进行标识。\n在通信过程中，会有路由器来告诉你应该去哪儿。在这期间，我们的数据会在不同的局域网内进行切换。\n\n在切换过程中，路由器会更新你的源IP&#x2F;MAC（目标IP不变）并提供目标的MAC地址\n\n唐僧去西天取经，他的目的地是不会变的，但是上一站&#x2F;下一站会不断变化\n\n以下图为例，当我们的数据走到IP这一层时，就会加上IP协议的报头。并在路由器内进行解包，再换上新的IP报头。\n\n此时IP一层就可以和其他层区分开，因为在IP层之上，发送/接收主机收到的数据是完全一样的！\n\nIP层是一个软件层，任何底层的差异，都可以通过加一层软件层来解决。这是一种软件虚拟化技术，linux的文件系统也使用了这种技术\n\n也就是说，通过IP层，可以屏蔽底层网络的差距。在通过ip通信的时候，不需要关注底层的路由等硬件信息以及数据传输的实现。\n5.3 端口一台主机里面有非常多的进程，每一个进程都能访问网络发送信息。\n光用IP地址，我们实际上只能找到对应的主机，却无法确定是这台主机里面的xx应用发出的信息。\n此时，就需要利用端口号来确定我们要访问的进程是什么了。\n\nIP：确保主机唯一性\n端口port：确保该主机上的进程唯一性\n\n如果你有用过docker，那肯定就知道端口号这一存在。大部分docker都需要映射一个端口以对外提供服务。\n网络间的通信，本质上是不同主机上的进程通信\n\n端口号是一个2字节的整数，限定了端口范围（1-65,536）\n端口号用于标识一个进程，告诉系统，当前的数据应交给哪一个进程去运行\n同一个进程可以使用多个端口号\n但是一个端口号只能对应一个进程\n\n网络通信中，有源IP和目标IP，也有源端口和目标端口。我们把这一对IP+端口被称为socket对\n5.3.1 端口&#x2F;PID的关系在一台主机里面，PID也可以用于标识唯一的进程。但是，端口号和PID是属于两个完全不同的概念。\n\n假设餐厅里有一个扫把，餐厅雇了个保洁员A，让他来打扫餐厅的卫生。此时就可以把扫把认为是端口，保洁员A是一个进程。\n有一天，保洁员A生病了，请假一周。于是老板又请了一个保洁员B，让他来打扫一周的卫生。此时，保洁员B也能使用餐厅里面已有的扫把，来进行打扫工作\n\n保洁员A&#x2F;保洁员B干的工作是完全一致的\n他们使用的是同一个扫把\n\n\n我们知道，在linux中，一个同一个可执行程序，每一次执行的时候，它的进程PID都是不同的；但同一个可执行程序，干的活肯定是一样的。\n保洁员A和B就可以看作是同一个可执行程序，他们用的也是同一个端口（扫把），但保洁员A和B的进程PID是不一样的！\n所以，在网络通信的时候，采用了端口这个扫把来标识需要进行网络通信的进程，而不是继续采用PID来标识👻\n\n操作系统只需要维护一个端口号和进程的哈希表，就能快速地通过端口号找到对应的进程\n\n5.4 TCP&#x2F;UDPTCP（Transmission Control Protocol 传输控制协议）\n\n传输层协议\n有链接（必须要和目标建立连接，才能开始数据传输）\n可靠传输（检查是否有丢包，需要保证数据完全被传输到目标主机）\n面向字节流\n\nUDP（User Datagram Protocol 用户数据报协议）\n\n传输层协议\n无连接（无须建立连接，比如所有人都能给你的电子邮箱发送邮件）\n不可靠传输（不检查丢包）\n面向数据报\n\n6.网络字节序在之前学习int类型的存储的时候，提到过大端/小端的概念\n6.1 说明在网络中，数据流同样有大端小端之分。TCP/IP协议规定，网络数据流应该采用大端字节序（低地址高字节）后发出的数据是高地址\n\n如上图的1为例，当网络中发送这个数字1的时候，会先发送00 00 00，最后发送的是01。这样能够方便数据的拼接\n\n发送主机将缓冲区中的数据按内存地址从低到高的顺序发出\n接受主机把数据依次保存到缓存区中，也是按地址从低到高的顺序保存\n\n这个规定更重要的意思是，如果不对网络字节数据的大小端做出限制，那么网络里面就会出现既有大端又有小端的情况，得写俩套代码来处理这个问题。\n而限制为大端之后，小端机器就需要在发送信息之前将数据转为大端，在接收到数据之后，将数据转换为小端。此时的处理就是操作系统的工作了，和TCP/IP协议本身没有关系了😛\n6.2 转换接口为了提高可以移植性，有以下的这个接口将网络字节序和主机字节序进行转换\n#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t hostlong);uint16_t ntohs(uint16_t hostshort);\n\n在命名中，n代表network，h代表host，l代表long，s代表short。\n如果主机就是大端，这些函数什么都不会做。如果主机是小端，则会将主机字节序转换成网络字节序（或反之）\n更多…关于网络原理的前置知识暂时就记录这么多，后续有新增会来更新本文\n","categories":["玩上Linux"],"tags":["Linux","网络"]},{"title":"【Linux】旋转锁 | 读写锁","url":"/posts/822375107/","content":"在之前的线程学习中，用到的锁都是挂起等待锁，如果申请不到锁，那就会在锁中等待；\n自旋锁则不大相似\n\n\n[TOC]\n1.自旋锁1.1 概念自旋锁是一个轮询检测锁，其检测机制并不是挂起等待，而是不断的询问锁有没有空闲；类似于一个while(1)循环的trylock()\n由于其需要不断的轮询检测，所以会占用一定的CPU资源；如果线程较多，就容易给cpu造成负荷。\n但是自旋锁无须唤醒挂起等待状态的线程，其消耗较小。\n总结一下：\n\n自旋锁适合竞争不激烈，且临界区较小（呆的时间短）的情况\n自旋锁不适合大量线程，临界区长的情况\n\n自旋锁的优缺点反过来，便是挂起等待锁的优缺点了。我们要根据不同场景，正确选择锁的类型\n1.2 接口相关接口和mutex都是很相似的，这里就不演示使用的效果了\n1.2.1 pthread_spin_init&#x2F;destroy#include &lt;pthread.h&gt;int pthread_spin_destroy(pthread_spinlock_t *lock);int pthread_spin_init(pthread_spinlock_t *lock, int pshared);\n\n1.2.2 pthread_spin_lock自旋锁同样有trylock接口，用于判断锁是否就绪\n#include &lt;pthread.h&gt;int pthread_spin_lock(pthread_spinlock_t *lock);int pthread_spin_trylock(pthread_spinlock_t *lock);\n\n1.2.3 pthread_spin_unlock#include &lt;pthread.h&gt;int pthread_spin_unlock(pthread_spinlock_t *lock);\n2.读写锁有的时候，我们会有一份config配置文件，这个配置文件会有非常多的线程进行读取，但是很少进行修改和写入。\n此时我们如果对配置文件的读取进行加锁，就容易导致效率问题，众多线程不断被阻塞，产生性能损失。\n此时，就可以用一个专门的读写锁，对读者和写者加不同的锁，在提升读取性能的同时，保证写入不冲突\n2.1 读者写者的关系写着和写着之间不用多说，肯定是互斥关系；\n读者和写者之间也是互斥关系，在写入的时候，不能进行读取，否则容易出现二义性问题；\n\n写者写入了一个a，线程甲来读取，得到的结果是a\n写者继续写入了b，线程乙来读取，得到的结果是ab\n\n这是因为写者的写入还没有完成，导致甲乙读者会获取到完全不同的结果，这是不对的；\n读者和读者之间没有关系，因为读者并不会修改数据，也不会取走数据，其存在对临界资源没有影响。\n\n2.2 接口2.2.1 init&#x2F;destroy读写锁只需要初始一个锁就行了，无须对读者写者初始化两个不同的锁\n#include &lt;pthread.h&gt;int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,\t\t\t\t\tconst pthread_rwlockattr_t *restrict attr);\n\n2.2.2 读者加锁读写锁的读者锁&#x2F;写者锁是分开的，我们要针对不同的线程调用不同的锁\n#include &lt;pthread.h&gt;int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n\n但是解锁的接口是一样的\n#include &lt;pthread.h&gt;int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n\n2.2.3 写者加锁#include &lt;pthread.h&gt;int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n\n2.2.4 设置锁的属性\n参考 PTHREAD_RWLOCKATTR_SETKIND_NP - Linux手册页\n\n读写锁可以允许我们设置是读者优先还是写者优先。如果采用默认的属性，可能会出现读者一直在读，写者没有办法写入的情况（打印错位是正常情况）\n[muxue@bt-7274:~/git/linux/code/23-01-20 rwlock]$ ./testreader [140484801697536]reader [140484801697536] 0reader [140484793304832]reader [reader [140484784912128140484793304832]reader [140484784912128] 0] 0reader [140484759734016]reader [140484759734016] 0reader [140484776519424]\n\n此时就出现了写者饥饿问题，写者无法访问临界资源，饿死了😂\n我们可以根据自己的需求进行设置读写锁的属性\nint pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *attr, int pref); /* pref 共有 3 种选择PTHREAD_RWLOCK_PREFER_READER_NP (默认设置) 读者优先，可能会导致写者饥饿情况PTHREAD_RWLOCK_PREFER_WRITER_NP 写者优先，目前有 BUG，导致表现行为和 PTHREAD_RWLOCK_PREFER_READER_NP 一致PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP 写者优先，但写者不能递归加锁，避免死锁*/\n\n下面是一个示例\npthread_rwlock_t rwlock;//锁pthread_rwlockattr_t attr;//属性pthread_rwlockattr_init(&amp;attr);//初始化属性pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);//设置锁的属性为写者优先pthread_rwlock_init(&amp;rwlock, &amp;attr);//初始化并设置读写锁的属性\n\n2.3 代码#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;using namespace std;volatile int board = 0;//临界资源pthread_rwlock_t rw;//全局读写锁void *reader(void* args)&#123;    const char *name = static_cast&lt;const char *&gt;(args);    cout &lt;&lt; &quot;reader [&quot;&lt;&lt;pthread_self() &lt;&lt;&quot;]&quot;&lt;&lt; endl;    //sleep(1);    while(true)    &#123;        pthread_rwlock_rdlock(&amp;rw);        cout &lt;&lt; &quot;reader [&quot;&lt;&lt;pthread_self() &lt;&lt;&quot;] &quot; &lt;&lt; board &lt;&lt; endl;        pthread_rwlock_unlock(&amp;rw);        usleep(110);    &#125;&#125;void *writer(void *args)&#123;    const char *name = static_cast&lt;const char *&gt;(args);    //sleep(1);    while(true)    &#123;        pthread_rwlock_wrlock(&amp;rw);        board++;        cout &lt;&lt; &quot;writer [&quot; &lt;&lt; pthread_self() &lt;&lt;&quot;]&quot;&lt;&lt; endl;        pthread_rwlock_unlock(&amp;rw);        usleep(100);    &#125;&#125;int main()&#123;    pthread_rwlock_init(&amp;rw, nullptr);    pthread_t r1,r2,r3,r4,r5,r6, w1,w2;    pthread_create(&amp;r1, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r2, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r3, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r4, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r5, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;r6, nullptr, reader, (void*)&quot;reader&quot;);    pthread_create(&amp;w1, nullptr, writer, (void*)&quot;writer&quot;);    pthread_create(&amp;w2, nullptr, writer, (void*)&quot;writer&quot;);    pthread_join(r1, nullptr);    pthread_join(r2, nullptr);    pthread_join(r3, nullptr);    pthread_join(r4, nullptr);    pthread_join(r5, nullptr);    pthread_join(r6, nullptr);    pthread_join(w1, nullptr);    pthread_join(w2, nullptr);    pthread_rwlock_destroy(&amp;rw);    return 0;&#125;\n\n运行结果如下\nreader [140067523458816] 7086reader [140067548636928] 7086writer [140067515066112]writer [140067506673408]reader [140067540244224] 7088reader [140067565422336] 7088reader [140067557029632] 7088reader [140067531851520] 7088reader [140067523458816] 7088writer [140067515066112]writer [140067506673408]reader [140067548636928] 7090writer [140067515066112]reader [140067523458816] 7091writer [140067506673408]reader [140067548636928] 7092reader [140067557029632] 7092\n\n可以看到读者的线程较多，且能够正确读取数据。\n如果在读者的whiile中加上sleep(10)\nvoid *reader(void* args)&#123;    const char *name = static_cast&lt;const char *&gt;(args);    cout &lt;&lt; &quot;reader [&quot;&lt;&lt;pthread_self() &lt;&lt;&quot;]&quot;&lt;&lt; endl;    while(true)    &#123;        pthread_rwlock_rdlock(&amp;rw);        cout &lt;&lt; &quot;reader [&quot;&lt;&lt;pthread_self() &lt;&lt;&quot;] &quot; &lt;&lt; board &lt;&lt; endl;        sleep(10);//睡        pthread_rwlock_unlock(&amp;rw);        usleep(110);//避免出现只有一个线程工作    &#125;&#125;\n\n能够看到多个读者之间不冲突，不会出现读者A申请锁后，读者B就无法访问临界区的情况。如果是互斥锁，读者A申请之后进入休眠，B就无法申请该锁。\n\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】来写一个tcp的服务端+客户端","url":"/posts/2171263616/","content":"今天让我们来写一个tcp的服务器&#x2F;客户端代码\n\n\n\n完整代码见我的gitee 连接\n阅读本文前，建议先阅读👉 udp服务器\n\n1.基本框架tcp的服务器和udp服务器初始化接口是非常相似的，区别就在于要选择字节流进行初始化\n但是到运行状态就不同了\n\ntcp是需要连接的\nudp不需要连接\n\n所以就会出现分歧：udp可以用sendto和receve来发送&#x2F;接收信息，服务端只需要监听特定端口收到了什么信息；\n但tcp并不能这么做，在通信之前，tcp服务器必须要和客户端建立链接。\n举个不恰当的例子，udp服务器好比一个水盆，等待水的注入；而tcp服务器是个水管，必须要两头连通了，才能开始注水\n1.1 类成员类的成员变量和udp很相似，都是需要服务器的ip、端口、sockfd这些信息。为了更容易区分，将tcp服务器的socket fd改为_listenSock，意为监听端口\nclass TcpServer&#123;private:    // 服务器端口号    uint16_t _port;    // 服务器ip地址    string _ip;    // 服务器socket fd信息    int _listenSock;&#125;;\n\n1.2 头文件这里对头文件进行一定的说明，因为服务器代码中的头文件实在太多了\n当你需要使用一个接口的时候，可以去采用man手册来获取该接口的头文件信息\n#pragma once// 头文件太多了，所以新起一个文件#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cassert&gt;#include &lt;ctype.h&gt;//判断字符串大写小写接口需要的库#include &lt;unistd.h&gt; #include &lt;strings.h&gt;// 忽略大小写比较strcasecmp#include &lt;sys/types.h&gt;  //很多liunx系统接口都需要这个#include &lt;sys/socket.h&gt; // 网络#include &lt;netinet/in.h&gt; // 网络#include &lt;arpa/inet.h&gt; // 网络using namespace std;#define SOCKET_ERR 1#define BIND_ERR   2#define LISTEN_ERR 3#define USAGE_ERR  4#define CONN_ERR   5#define BUFFER_SIZE 1024\n\n2.初始化接口的介绍就跟随实现一步一步来吧\n2.1 构造sock这里出现了tcp和udp第一个不同之处，tcp是面向字节流的，udp面向的是数据报\nTcpServer(uint16_t port,const string&amp; ip=&quot;&quot;) :_port(port), _ip(ip), _listenSock(-1)&#123;    // 1.创建socket套接字,采用字节流（即tcp）    _listenSock = socket(AF_INET, SOCK_STREAM, 0); //本质是打开了一个文件    if (_listenSock &lt; 0)    &#123;        logging(FATAL, &quot;socket:%s:%d&quot;, strerror(errno), _listenSock);        exit(1);    &#125;    logging(DEBUG, &quot;socket create success: %d&quot;, _listenSock);&#125;\n\n2.2 初始化sockaddr_in继续，初始化sockaddr_in的操作和udp是完全一致的\n// 2. 绑定网络信息，指明ip+port// 2.1 先填充基本信息到 struct sockaddr_instruct sockaddr_in local;memset(&amp;local,0,sizeof(local));//初始化// 协议家族，设置为ipv4local.sin_family = AF_INET; // 端口，需要进行 本地-&gt;网络转换local.sin_port = htons(_port);// 配置ip// 如果初始化时候的ip为空，则调用INADDR_ANY代表任意ip。否则对传入的ip进行转换后赋值local.sin_addr.s_addr = _ip.empty() ? htonl(INADDR_ANY) : inet_addr(_ip.c_str());\n\n2.3 bind也是一样，绑定服务器的ip和端口\n// 2.2 绑定ip端口if (bind(_listenSock,(const struct sockaddr *)&amp;local, sizeof(local)) == -1)&#123;    logging(FATAL, &quot;bind: %s:%d&quot;, strerror(errno), _listenSock);    exit(2);&#125;logging(DEBUG,&quot;socket bind success: %d&quot;, _listenSock);\n\n2.4 监听listen对于tcp服务器来说，成员变量的_listenSock是用来监听的，即找个老哥一直盯着云服务器的这个端口，看看有没有需要连接它的客户端\n#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);\n\n其中第一个参数是我们的_listenSock，第二个参数是用于限制在阻塞等待连接的数量\nThe backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.   If  a connection  request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt  at  con‐nection succeeds.\n\n翻译过来就是，backlog参数限制了能被阻塞等待连接的数量。如果超过这个数量，则会返回一个ECONNREFUSED错误。亦或者如果协议支持重传，多余的请求会被忽略，后续可以重传\nman手册下面的notes还有更多解释\nThe behavior of the backlog argument on TCP sockets changed with Linux 2.2.  Now it specifies  the  queue  length  for completely  established  sockets waiting to be accepted, instead of the number of incomplete connection requests.  The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog.  When syn‐cookies are enabled there is no logical maximum length and this setting is ignored.  See tcp(7) for more information. If  the  backlog  argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128.  In kernels before 2.4.25, this  limit  was  a  hard  coded  value,SOMAXCONN, with the value 128.\n\n如果backlog参数高于/proc/sys/net/core/somaxconn中的默认值128，则会被截断为128\n\n在我们这里，将其设置为5即可，反正也是做测试嘛，问题不大\n// 3.监听// tcp服务器是需要连接的，连接之前要先监听有没有人来连if (listen(_listenSock, 5) &lt; 0)&#123;    logging(FATAL, &quot;listen: %s&quot;, strerror(errno));    exit(LISTEN_ERR);&#125;logging(DEBUG, &quot;listen: %s, %d&quot;, strerror(errno), _listenSock);\n\n3.运行初始化到这就完毕了，下面就是开跑了\n3.1 accept#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n\n这个接口的作用就相当于tcp中的recevefrom，传参是完全相同的；与之不同的是，该函数的返回值是一个全新的sockfd\n\ntcp需要和客户端建立链接\n链接需要用socket fd 来管理\n所以accept必须返回新的socket fd，让服务端有办法管理新的链接和已有链接\n原有的socket fd不受影响\n如果没有客户端来连接，进程会在accept内阻塞等待\n\n下为man手册中的描述\nThe  accept()  system  call  is  used  with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).  It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected  socket,  and  returns  a  new  file descriptor referring to that socket.  The newly created socket is not in the listening state.  The original socket sockfd is unaffected by this call.\n\n举个例子，tcp服务器自身的socket fd只会用来监听端口上有没有消息，当监听到有消息并通过accept建立连接后，就会让另外一位服务员来对这个连接提供服务。\nwhile(1)&#123;    struct sockaddr_in peer;    socklen_t len = sizeof(peer);    // 获取连接    int conet = accept(_listenSock,(struct sockaddr*)&amp;peer,&amp;len);    if(conet&lt;0)    &#123;        logging(FATAL, &quot;accept: %s&quot;, strerror(errno));        exit(CONN_ERR);//连接错误    &#125;    //。。。&#125;\n\n注意这里len的参数是socklen_t，其本质上是一个无符号整形\ntypedef __socklen_t socklen_t;__STD_TYPE __U32_TYPE __socklen_t;#define __U32_TYPE\t\tunsigned int\n\n3.2 获取连接信息这部分和udp是完全相同的，通过accept返回的socket fd，获取用户的ip和端口耨\n// 获取连接信息string senderIP = inet_ntoa(peer.sin_addr);// 来源ipuint16_t senderPort = ntohs(peer.sin_port); // 来源端口logging(DEBUG, &quot;accept: %s | %s[%d], socket fd: %d&quot;, strerror(errno), senderIP.c_str(), senderPort, conet);\n\n其实到这里，我们就可以运行服务器进行测试了。因为tcp的特性，我们不需要写客户端，直接用浏览器就能连上服务端\nint main(int argc,char* argv[])&#123;    //参数只有两个（端口/ip）所以参数个数应该是2-3    if(argc!=2 &amp;&amp; argc!=3)    &#123;        cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; port [ip]&quot; &lt;&lt; endl;        return 1;    &#125;        string ip;    // 3个参数，有ip    if(argc==3)    &#123;        ip = argv[2];    &#125;    TcpServer t(atoi(argv[1]),ip);    t.start();    return 0;&#125;\n\n先编译后执行代码，让tcp服务器运行起来\n\n随后在浏览器的地址栏输入公网ip:端口（先要开启防火墙内的端口）\n\n此时会发现什么都加载不出来，这是对的，因为我们并没有写前端，也没有提供任何服务。但是来到后台，可以看到出现了一个新的连接，并显示出了ip+端口\n\n3.3 提供服务（线程）接下来要做的，就是写一个简单的服务了，这里我写的是字符串转ASCII码，会将发出去的字符串的ascii码加加起来后返回\n3.3.1 问题1 如何通信此时问题就来了，tcp服务器不能使用recevefrom和sendto，那么获取到socket之后要怎么进行通信呢？\n答案是：用linux的文件读写接口，read和write。别忘了，socket fd本质上就是一个linux下的文件描述符！\n3.3.2 问题2 多客户端tcp服务器要想给多个客户端提供服务，就必须采用多线程&#x2F;多进程的方式来实现操作。否则会出现一个严重的问题，服务端因为提供服务而没有accept，无法链接上下一个客户端\nwhile(1)&#123;    //accept 获取到链接上的客户端        while(1)    &#123;         //如果在这里提供服务，则会其他连接会在listen里面阻塞    \t//只有当前服务终止了，其他客户端的其中之一才能连上服务器    &#125;&#125;\n\n3.3.3 问题3 线程传参既然需要采用多线程服务，那就需要设定好给线程传的参数。理论上来说，我们只需要传入accept的返回值socket fd即可进行read/write\n但实际上，我们还需要打印debug消息，要知道当前是谁向你发送了这条消息，ip和端口是什么。\n为了方便操作，这里封装一个结构体，将socket fd，客户端的ip+端口封装成一个参数进行传参（线程的函数只能传入一个参数）\nstruct ClientData&#123;    int _fd;    uint16_t _port;    string _ip;    TcpServer* _this;    ClientData(int fd,uint16_t port,const string&amp; ip,TcpServer* this1)        :_fd(fd),_port(port), _ip(ip),_this(this1)    &#123;&#125;&#125;;\n\n你可能会想到另外一个办法，那就是在tcp服务器的class中新增一个map成员变量，用于映射socket fd和客户端信息的键值对，但是这无法实现。\n因为在类中设计的多线程函数，为了去掉默认传入的this指针，必须要设置成static静态的，此时该静态函数无法访问类内成员！\n// 因为需要取消this指针，所以需要设置成静态的static void* threadRoutine(void*args)&#123;       pthread_detach(pthread_self()); //设置线程分离    ClientData* data=(ClientData*)args;    // 通过预先设置的this指针来访问类内成员，并进行传参    data-&gt;_this-&gt;transService(data-&gt;_fd,data-&gt;_ip,data-&gt;_port);    delete data;    return nullptr;&#125;\n\n3.3.4 服务代码解决了上面的问题，就可以继续往下看看服务端的代码了\n// 提供服务pthread_t service;// 因为这个成员使用范围极小，所以采用new/delete，避免占用太多空间ClientData* data = new ClientData(conet,senderPort,senderIP,this);pthread_create(&amp;service,nullptr,threadRoutine,(void*)data);\n\n在accept之后，通过线程操作用线程来提供服务\nstatic void* threadRoutine(void*args)&#123;       pthread_detach(pthread_self()); //设置线程分离    ClientData* data=(ClientData*)args;    // 通过预先设置的this指针来访问类内成员，并进行传参    data-&gt;_this-&gt;transService(data-&gt;_fd,data-&gt;_ip,data-&gt;_port);    delete data;    return nullptr;&#125;\n\nthreadRoutine的作用就是把线程的单参数转为多参数，传给真正用来服务的函数。函数的操作很简单，就是Linux下文件操作的读写。\n读写成功后，将客户端发来的信息转成ASCII码的和发回给客户端\nvoid transService(int sockfd, const string &amp;clientIp, uint16_t clientPort)&#123;    assert(sockfd &gt;= 0);    assert(!clientIp.empty());    assert(clientPort&gt;0);    // 开始服务    char buf[BUFFER_SIZE];    while(1)    &#123;        // 读取客户端发来的信息,s是读取到的字节数        ssize_t s = read(sockfd, buf, sizeof(buf)-1);        if(s&gt;0)        &#123;            buf[s]=&#x27;\\0&#x27;;//手动添加字符串终止符            if(strcasecmp(buf,&quot;quit&quot;)==0)            &#123;//客户端主动退出                break;            &#125;            // 服务            string tmp = buf;            int ret = str2ascii(tmp);//获取字符串的ascii总和            cout &lt;&lt; ret &lt;&lt; endl;            string retS =  to_string(ret);//转字符串            cout &lt;&lt; retS &lt;&lt; endl;            write(sockfd,retS.c_str(),retS.size());//写入        &#125;        else if (s == 0)        &#123;//s == 0代表对方关闭,客户端退出            logging(DEBUG, &quot;client quit: %s[%d]&quot;, clientIp.c_str(), clientPort);            break;        &#125;        else        &#123;            logging(DEBUG, &quot;read err: %s[%d] -  %s&quot;, clientIp.c_str(), clientPort, strerror(errno));            continue;        &#125;    &#125;    close(sockfd);    logging(DEBUG,&quot;server quit %d&quot;,sockfd);&#125;private:    // 服务函数可以不暴露    int str2ascii(const string&amp; str)    &#123;        int ret = 0;        for(auto e:str)        &#123;            ret += e;        &#125;        return ret;    &#125;\n\n3.4 提供服务（子进程）上面的代码采用的是线程来提供服务，除了线程，我们还有父子进程的方式，也能避免阻塞\n需要注意的是，父子进程都需要关闭掉对方使用的文件描述符，避免出现文件描述符在服务结束后还没有关闭的情况\npid_t id = fork();if(id == 0)&#123;    close(_listenSock);//因为子进程不需要监听，所以关闭掉监听socket    //子进程    transService(conet, senderIP, senderPort);    exit(0);// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收&#125;// 父进程close(conet); // 因为此时是子进程提供服务，conet会有拷贝，相当于有两个进程打开了该文件// 如果父进程不关闭，即便子进程结束服务了，该文件描述符也会保持开启pid_t ret = waitpid(id, nullptr, 0);\n\n直接这样写有一个很大的问题，那就是父进程没有办法正常释放子进程的资源\n\n如果进行阻塞等待，那就违背了初衷，完全没有意义\n如果进行非阻塞等待，在waitpid结束之后，父进程直接去干其他事了，完全忘记了这里的这个子进程\n\n所以我们要做的，就是在子进程退出，向父进程发送信号的时候回收子进程\n3.4.1 信号回收子进程通过自定义捕捉系统信号，来回收子进程\nsignal(SIGCHLD, FreeChild);//自定义捕捉\n\n// 回收子进程void FreeChild(int signo)&#123;    assert(signo == SIGCHLD);    while (true)    &#123;        //如果没有子进程了，waitpid就会调用失败        pid_t id = waitpid(-1, nullptr, WNOHANG); // 非阻塞等待        if (id &gt; 0)        &#123;            cout &lt;&lt; &quot;父进程等待成功, child pid: &quot; &lt;&lt; id &lt;&lt; endl;        &#125;        else if(id == 0)        &#123;            //还有子进程没有退出            cout &lt;&lt; &quot;尚有未退出的子进程，父进程继续运行&quot; &lt;&lt; endl;            break;//退出等待子进程        &#125;        else        &#123;            cout &lt;&lt; &quot;父进程等待所有子进程结束&quot; &lt;&lt; endl;            break;        &#125;    &#125;&#125;\n\n除了自定义捕捉，我们还可以设置成ignore不搭理子进程，这样子进程退出的时候就会被系统自动释放\nsignal(SIGCHLD, SIG_IGN);\n\n3.4.2 爷爷进程这里还有另外一个骚操作，那就是在创建子进程之后，再创建一个子进程\n// 提供服务（孙子进程）-2pid_t id = fork();if(id == 0)&#123;    close(_listenSock);//因为子进程不需要监听，所以关闭掉监听socket    //又创建一个子进程，大于0代表是父进程，即创建完子进程后父进程直接退出    if(fork()&gt;0)&#123;        exit(0);    &#125;    // 孙子进程执行    transService(conet, senderIP, senderPort);    exit(0);// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收&#125;// 爷爷进程close(conet); pid_t ret = waitpid(id, nullptr, 0); //此时就可以直接用阻塞式等待了assert(ret &gt; 0);//ret如果不大于0，则代表等待发生了错误\n\n采用这种办法以后，由于父进程退出了，孙子进程会直接被操作系统接管。下图中能看到这些进程的父进程都是1，即操作系统。这时候我们也不需要担心子进程的释放问题了\n\n4.客户端客户端部分的代码和udp也很相似，只不过将sendto改成了write\n下方提供了客户端的代码，都写了注释😁\n#include &quot;utils.h&quot;// ./clientTcp serverIp serverPortint main(int argc, char *argv[])&#123;    if (argc != 3)//客户端必须要有3个参数    &#123;        cerr &lt;&lt; &quot;Usage:\\n\\t&quot; &lt;&lt; argv[0] &lt;&lt; &quot; serverIp serverPort&quot; &lt;&lt; endl;        cerr &lt;&lt; &quot;Example:\\n\\t&quot; &lt;&lt; argv[0] &lt;&lt; &quot; 127.0.0.1 8080\\n&quot;                &lt;&lt; endl;        exit(USAGE_ERR);    &#125;    // 解析服务端的ip和端口    string serverIp = argv[1];    uint16_t serverPort = atoi(argv[2]);    // 1. 创建tcp的socket SOCK_STREAM    int sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock &lt; 0)    &#123;        cerr &lt;&lt; &quot;socket: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(SOCKET_ERR);    &#125;    // 2. connect，发起链接请求，你想谁发起请求呢？？当然是向服务器发起请求喽    // 2.1 先填充需要连接的远端主机的基本信息    struct sockaddr_in server;    memset(&amp;server, 0, sizeof(server));    server.sin_family = AF_INET;    server.sin_port = htons(serverPort);    inet_aton(serverIp.c_str(), &amp;server.sin_addr);    // 2.2 发起请求，connect 会自动bind    if (connect(sock, (const struct sockaddr *)&amp;server, sizeof(server)) != 0)    &#123;        cerr &lt;&lt; &quot;connect: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(CONN_ERR);    &#125;    cout &lt;&lt; &quot;connect success: &quot; &lt;&lt; sock &lt;&lt; endl;    // 客户端发现的消息    string message;    while (1)    &#123;        message.clear();//每次循环开始，都清空一下msg        cout &lt;&lt; &quot;请输入你的消息# &quot;;        getline(cin, message);//获取输入        // 如果客户端输入了quit，则退出        if (strcasecmp(message.c_str(), &quot;quit&quot;) == 0)            break;        // 向服务端发送消息        ssize_t s = write(sock, message.c_str(), message.size());        if (s &gt; 0) // 写入成功        &#123;            message.clear();//清空输入的消息            message.resize(BUFFER_SIZE);            // 因为string的c_str本质上是返回地址，所以强转后是可以往里面写入的            s = read(sock, (char *)(message.c_str()), BUFFER_SIZE);// 获取服务端的结果            if (s &gt; 0)// 读取成功            &#123;                message[s] = &#x27;\\0&#x27;;//追加\\0            &#125;            // 打印返回值            cout &lt;&lt; &quot;Server Echo# &quot; &lt;&lt; message &lt;&lt; endl;        &#125;        else if (s &lt;= 0) // 写入失败        &#123;            break;        &#125;    &#125;    // 关闭文件描述符    close(sock);    return 0;&#125;\n\n4.1 运行测试先运行服务端，再运行客户端，客户端输入后，服务短会返回字符串的ascii码总和\n\n而客户端输入quit后，在服务端可以看到客户端退出，但服务端并没有推出，正在等待下一个连接\n\n5.线程池在上面的操作中，每次提供服务都需要当场新建一个线程。对于tcp这种要求高性能的网络服务器而言，其实是不太合适的。理论上来说，我们希望越早给客户建立联系越好，而不是食客都来了老板才去买菜。\n这时候，就可以把我们写的线程池和tcp服务器给联系起来！\n\n线程池的代码见我的gitee，此处只说明task类的编写\n\n5.1 task先前编写线程池的时候，将线程池要处理的任务写成了一个task类，并规定所有task类都需要提供一个()操作符重载，即仿函数。这样线程池就可以一视同仁的处理这些工作，我们只需要将新增的工作添加到线程池的任务队列里面\nclass Task&#123;    using callback_t = std::function&lt;void (int, std::string, uint16_t)&gt;;//相当于typedefpublic:    Task() = default;    // 将需要调用的函数传入，相当于通用    Task(int sockfd, const std::string &amp;clientIP, uint16_t clientPort,callback_t func)        : _sockfd(sockfd), _ip(clientIP), _port(clientPort),_func(func)    &#123;    &#125;    // 仿函数    void operator()()    &#123;        logging(DEBUG, &quot;TID[%p] = %s:%d START&quot;,\\            pthread_self(), _ip.c_str(), _port);        _func(_sockfd, _ip, _port);        logging(DEBUG, &quot;TID[%p] = %s:%d END  &quot;,\\            pthread_self(), _ip.c_str(), _port);    &#125;private:    int _sockfd;    std::string _ip;    uint16_t _port;    callback_t _func;&#125;;\n\n这里，我又将task队列给封装成了一个可以接收函数指针的方式。这样一来，只要我们任务的函数参数为(SOCKET,IP,PROT)，就能传入给这个task类，让线程池来运行\n5.2 tcpServer的处理因为需要线程池，我们在tcpserver中添加一个线程池的指针，通过线程池的类名来获取单例，赋值给成员变量。并让获取到的单例线程池开始运行\n// 4.获取线程池 单例_tpool = ThreadPool&lt;Task&gt;::getInstance(4);_tpool-&gt;start();//开始运行\n\n在start函数中，则将之前的任务函数实例化为一个task，并将其push到线程池的任务队列中\n// 提供服务（通过线程池）Task t(conet,senderIP,senderPort,transService);_tpool-&gt;push(t);\n\n这样，就能通过线程池来提供服务了！\n5.3 运行测试可以看到，我们的线程池正确运行了任务，给客户端提供了ascii返回值\n\n使用ps -aL命令查看轻量级进程，可以看到有4个线程在为我们服务\n PID   LWP TTY          TIME CMD7288  7288 pts/8    00:00:00 tcpServer7288  7289 pts/8    00:00:00 handler7288  7290 pts/8    00:00:00 handler7288  7291 pts/8    00:00:00 handler7288  7292 pts/8    00:00:00 handler7441  7441 pts/9    00:00:00 tcpClient7632  7632 pts/7    00:00:00 ps\n\n此时，即便我们多开几个终端，tcp服务器也能正常提供服务\n\n但是！如果出现了一个尴尬的情况，线程池中的线程&lt;当前需要连接的客户端数量，会发生什么呢？\n5.4 task等待问题为了测试，我们将线程池单例中的线程个数初始化为2个\n\n此时，我们发现第三个客户端会进入阻塞状态，但实际上它已经成功链接上了服务器，task也被插入到了任务队列里面，只不过当前没有空闲的线程来运行它\n\n如果我们把左侧其中一个客户端退出，最右侧的客户端就能正常收到服务器返回的结果了\n\n要解决这个问题，我们就需要让线程池有能力判断是否出现了阻塞问题，并扩容线程来解决阻塞。\n可是这又引出了另外一个问题：如果空闲了很久都没有任务过来，多出来的线程不就是在白白消耗资源吗？\n实际上，线程池适合处理的，应该是短小的任务，而不是一个while(1)循环；\n\n但是我还没有学习到如何将其修改为服务于短小任务的线程池，仍待后续的精进\n\n","categories":["玩上Linux"],"tags":["Linux","线程","网络"]},{"title":"【Linux】来写一个udp的服务端+客户端","url":"/posts/368672249/","content":"来写一个udp的代码\n\n\n1.socket编程接口#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)int socket(int domain, int type, int protocol);// 绑定端口号 (TCP/UDP, 服务器)      int bind(int socket, const struct sockaddr *address,         socklen_t address_len);// 开始监听socket (TCP, 服务器)int listen(int socket, int backlog);// 接收请求 (TCP, 服务器)int accept(int socket, struct sockaddr* address,         socklen_t* address_len);// 建立连接 (TCP, 客户端)int connect(int sockfd, const struct sockaddr *addr,         socklen_t addrlen);\n\nlinux下一切皆文件，socket接口也不例外。其返回值本质上就是一个fd文件描述符，这样我们对网络的发送&#x2F;接收操作，就转换成了对文件的写入&#x2F;读取操作了\n在这里面有一个比较重要的结构sockaddr需要说明一番\n1.1 sockaddrsocket是一层抽象的网络编程接口，适用于各种底层网络协议，如IPv4&#x2F;IPv6。同时，这个接口还可以用于系统内部的通信。这就实现了用一个接口来干两件事。\n为此，就必须要在传值中进行一些修改。该接口新增了一个sockaddr，用来接收目标信息。这个值的参数可以是sockaddr_in/scokaddr_un/sockadd_in6之中的任意一个（需要强转指针）\nsockaddr本身不存放任何信息。\n这个参数可接收的结构体中，固定前16位就是用于标识符的。传到处理函数中，就会判断前16位中的标识符的类型，以确定传入参数的类型，再执行不同的实现\n\n比如传入的scokaddr_un，前16位是AF_UNIX，那么当前使用的就是本地通信\nsockaddr_in是ipv4通信，sockaddr_in6是ipv6通信\n\n\n你可能会有疑惑，既然sockaddr不存放信息，那为何不把这个参数设置为一个void*的指针？反正最后都是进了函数之后判断参数类型，void*指针也能达成目标呀🧐\n这个问题的答案很简单：当初设计这套接口的时候，C语言还不支持void*😂\n\n1.2 存放位置因为sockaddr_in这类的结构体，最终都需要被操作系统载入并实现网络操作。所以它们肯定是需要载入内核中的\n但这并不意味着这类结构体是存放在内核里面的，而是存放在用户栈，用户态和内核态交换的时候，通过接口传值载入到内核的空间进行使用\n2.server了解了上面的信息，接下来，认识一下如果想建立一个udpserver，需要怎么操作吧！\n以下是一个server的类，包含了端口、ip、socker fd三个基本信息\nclass UdpServer&#123;public:    UdpServer(uint16_t port,const string&amp; ip=&quot;&quot;)     : _port((uint16_t)port), _ip(ip), _sockfd(-1)    &#123;&#125;private:    // 服务器端口号    uint16_t _port;    // 服务器ip地址    string _ip;    // 服务器socket fd信息    int _sockfd;&#125;;\n\n2.1 创建套接字这里需要用的是下面这个接口\nint socket(int domain, int type, int protocol);\n\n\n第一个参数domain标识该socker的作用域\n\n可以设置为本地，也可以设置为网络。支持如下参数\nName                Purpose                          Man pageAF_UNIX, AF_LOCAL   Local communication              unix(7)AF_INET             IPv4 Internet protocols          ip(7)AF_INET6            IPv6 Internet protocols          ipv6(7)AF_IPX              IPX - Novell protocolsAF_NETLINK          Kernel user interface device     netlink(7)AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)AF_AX25             Amateur radio AX.25 protocolAF_ATMPVC           Access to raw ATM PVCsAF_APPLETALK        Appletalk                        ddp(7)AF_PACKET           Low level packet interface       packet(7)\n\n因为我们要创建的是一个网络服务器，所以这里设置为AF_INET，也就是IPV4的服务\n\n第二个参数type指代套接字的类型，决定了通信时的报文类型\n\n这里支持流式（TCP）或者用户数据报（UDP），以及RAW原始格式（能够直接访问协议，方便debug）\nSOCK_STREAM   Provides sequenced, reliable, two-way, connection-based byte streams. An out-of-band data  transmission  mechanism  may  be supported.SOCK_DGRAM    Supports datagrams (connectionless, unreliable messages of a fixed maximum length). SOCK_RAW        Provides raw network protocol access.\n\n更多支持的参数参考man手册\n\n第三个参数指代协议，在网络应用中，设置为0即可\n\n返回值是一个linux系统的文件描述符\nRETURN VALUE       On success, a file descriptor for the new socket is returned.  On error, -1 is returned, and errno is set appropriately.\n\n\n这样，我们就能写出第一行代码，以及对这个代码的返回值判断\n_sockfd = socket(AF_INET, SOCK_DGRAM, 0);if (_sockfd &lt; 0)&#123;    logging(FATAL, &quot;socket:%s:%d&quot;, strerror(errno), _sockfd);    exit(1);&#125;\n\n因为socket是文件描述符，为了规范，我们还可以在析构函数里面调用一下close\n~UdpServer()&#123;    close(_sockfd);&#125;\n\n2.2 配置sockaddr_in// 2. 绑定网络信息，指明ip+portstruct sockaddr_in local;memset(&amp;local,0,sizeof(local));//配置为 0\n\n因为用的是ipv4的网络通信，所以这里需要初始化一个sockaddr_in类型\n此时在vscode的代码补全中，可以看到4个成员，需要对它们赋值以配置服务器信息\n\n首先是把协议家族设置为IPV4，端口配置为函数参数中的端口\n// 协议家族，设置为ipv4local.sin_family = AF_INET; // 端口，需要进行 本地-&gt;网络转换local.sin_port = htons(_port);\n\n随后配置ip\n// 如果初始化时候的ip为空，则调用INADDR_ANY代表任意ip。否则对传入的ip进行转换后赋值local.sin_addr.s_addr = _ip.empty() ? htonl(INADDR_ANY) : inet_addr(ip_.c_str());\n\n这里采用了?:三目操作符，如果类构造的时候传入的ip是空（没有配置ip）那就直接设置为任意ip，否则传入成员变量；\n这样对sockaddr_in的配置就完成了。\n2.2.1 inet_addr这里需要使用inet_addr函数对传入的字符串类型的ip（如192.168.0.1）进行转换\nin_addr_t inet_addr(const char *cp);//对字符串ip进行转换\n\n因为对于网络来说，它并不认识字符串类型的ip，而是要用网络字节流规定的类型。\n/* Internet address.  */typedef uint32_t in_addr_t;struct in_addr  &#123;    in_addr_t s_addr;  &#125;;\n\n对于该接口的底层做一个简单的说明：其实就是利用位段，将数据转换为一个特殊的类型\n//示例，非底层实现struct ip&#123;    uint32_t part1:8;    uint32_t part2:8;    uint32_t part3:8;    uint32_t part4:8;&#125;\n\n2.2.2 inet_ntoa同样的，如果我们作为客户端接受到了网络请求中的ip，可以用inet_ntoa将其转换为字符串类型。\nchar *inet_ntoa(struct in_addr in);\n\n这里就引申出了一个问题：返回值的char*是存在哪里的？是静态区还是malloc？\n\nThe inet_ntoa() function converts the Internet host address in, given in network byte order, to a string in IPv4 dotted-decimal notation.  The string  is returned in a statically allocated buffer, which subsequent calls will overwrite.\n\n手册告诉我们，这个函数是维护了一个static变量来存放返回的ip的。\n因此，该函数并不是一个线程安全的函数，在APUE中明确标明了这一点；后续的调用会覆盖掉这个IP地址；\n2023.09.15的面试问道了这个问题，感兴趣的可以看看我的面经里面的题目和解释，这里把题目贴出来；如下的函数调用会不会有什么问题？\nprintf(&quot;%s %s\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));\n\n说结论：对于inet_aton函数而言，正确的调用办法是每次调用后都立即取走返回的IP地址字符串，可以用std::string接收，也可以用strcmp拷贝到一个自己定义的字符串数组变量中；\n具体的介绍请移步面经哦！\n\n2.3 bind绑定ip端口#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr,         socklen_t addrlen);\n\n这个接口的作用就是指定socket和sockaddr进行绑定。第三个参数是addr元素的大小（不是指针大小，别搞错了）\n// 2.2 绑定ip端口if (bind(_sockfd,(const struct sockaddr *)&amp;local, sizeof(local)) == -1)&#123;    logging(FATAL, &quot;bind: %s:%d&quot;, strerror(errno), _sockfd);    exit(2);&#125;logging(DEBUG,&quot;socket bind success: %d&quot;, _sockfd);\n\n绑定了之后，我们的服务器就配置成功了\n测试一下，可以看到编译没有报错，也能正常运行！\n[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ make udpServerg++ -o udpServer udpServer.cpp -std=c++11[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ ./udpServerDEBUG | 1675326460 | muxue | socket create success: 3DEBUG | 1675326460 | muxue | socket bind success: 3\n\n在使用UDP进行通信的时候，我们不一定需要绑定具体的IP地址，可以用INADR_ANY来代替具体的本机IP地址，但是端口号一定要进行绑定。（不然系统没办法让你的进程和某个端口关联来接收信息）\n2.3.1 main现在先来简单写一下main函数中启动服务的命令行参数吧\nint main(int argc,char* argv[])&#123;    //参数只有两个（端口/ip）所以参数个数应该是2-3    if(argc!=2 &amp;&amp; argc!=3)    &#123;        cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; port [ip]&quot; &lt;&lt; endl;        return 1;    &#125;        string ip;    // 3个参数，有ip    if(argc==3)    &#123;        ip = argv[2];    &#125;    UdpServer s(atoi(argv[1]),ip);    s.start();    return 0;&#125;\n\n为了测试，先把start()函数设置为一个死循环\nvoid start()&#123;    while(1)    &#123;        cout &lt;&lt; &quot;running &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;&#125;\n\n编译运行，可以看到错误提示是可以用的。正确添加参数之后，也能绑定并开始运行\n[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ make udpServerg++ -o udpServer udpServer.cpp -std=c++11[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ ./udpServerUsage: ./udpServer port [ip][muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ ./udpServer 8080DEBUG | 1675327610 | muxue | socket create success: 3DEBUG | 1675327610 | muxue | socket bind success: 3running 4467running 4467running 4467^C\n\n注意，bind这个函数是不允许你绑定云服务器的公网ip的。因为云服务器并不是直接暴露在公网上的，而是由提供商的入口服务器进入内网，在进入你的服务器。所以他不允许你绑定公网ip；\n$ ./udpServer 8080 云服务器公网ipDEBUG | 1675327690 | muxue | socket create success: 3FATAL | 1675327690 | muxue | bind: Cannot assign requested address:3\n\n一般情况下，可以选择不绑定ip，或者绑定本地端口127.0.0.1\n\n如果绑定了127.0.0.1，那么服务只有本地可以访问。不绑定端口，就会默认绑定成0.0.0.0，允许本地和远程端口连接\n\n$ ./udpServer 8080 127.0.0.1DEBUG | 1675327757 | muxue | socket create success: 3DEBUG | 1675327757 | muxue | socket bind success: 3running 5067running 5067\n\n2.3.2 netstat可以用netstat -lnup命令查看当前开放的端口信息\n\n可以看到，第一行就是我们的udp服务器，本地端口是我们绑定的127.0.0.1:8080，远程端口是0.0.0.0:*，代表允许任何远程ip的任何端口来访问\n2.4 开始运行上面的操作只是初始化了这个udp服务器的信息，并没有让它真正的运行起来；\n接下来要做的就是让服务器开始接收信息，并在屏幕上打印出来\n2.4.1 recvfrom这个接口的作用是来接收信息\n#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,                 struct sockaddr *src_addr, socklen_t *addrlen);\n\n\n第一个参数是前面创建的套接字\n第二个参数是用来接收信息的缓冲区\n第三个参数是缓冲区的大小\n第四个参数是标识符，设置为0，代表阻塞等待\n第五个参数，输出型参数，获取发送方的信息\n第六个参数，输入输出型参数，需要初始化为sizeof(src_addr)\n\n函数的返回值是接收到的数据的长度，没有接收到或者接受失败，则为-1\n示例如下\nchar inBuf[BUF_SIZE];struct sockaddr_in peer;      //输出型参数socklen_t len = sizeof(peer); //输入输出型参数// peer和len都是输出型参数，用于获取发送方的信息// len是输入输出型参数，需要以sizeof(peer)初始化后传入// 第三个参数0为默认等待方式（阻塞等待）ssize_t s = recvfrom(_sockfd, inBuf, sizeof(inBuf)-1,0,(struct sockaddr *)&amp;peer, &amp;len);if (s &gt; 0) // s代表获取到的数据长度，不为0代表成功获取&#123;    inBuf[s] = &#x27;\\0&#x27;; //末尾追加&#x27;\\0&#x27;&#125;else if (s == -1) // -1没有收到信息，错误&#123;    logging(WARINING, &quot;recvfrom: %s:%d&quot;, strerror(errno), _sockfd);    continue;&#125;\n\n这样就能在inBuf中直接获取到发送信息的内容\n2.5 服务端start以下是服务端运行的完整代码\nvoid start()&#123;    char inBuf[BUF_SIZE];//接收到信息的缓冲区    while(1)    &#123;        struct sockaddr_in peer;      //输出型参数        socklen_t len = sizeof(peer); //输入输出型参数        // peer和len都是输出型参数，用于获取发送方的信息        // len是输入输出型参数，需要以sizeof(peer)初始化后传入        // 第三个参数0为默认等待方式（阻塞等待）        ssize_t s = recvfrom(_sockfd, inBuf, sizeof(inBuf)-1,0,(struct sockaddr *)&amp;peer, &amp;len);        if (s &gt; 0) // s代表获取到的数据长度，不为0代表成功获取        &#123;            inBuf[s] = &#x27;\\0&#x27;; //末尾追加&#x27;\\0&#x27;        &#125;        else if (s == -1) // -1没有收到信息，错误        &#123;            logging(WARINING, &quot;recvfrom: %s:%d&quot;, strerror(errno), _sockfd);            continue;        &#125;        string senderIP = inet_ntoa(peer.sin_addr);// 来源ip        uint16_t senderPort = ntohs(peer.sin_port); // 来源端口        logging(NOTICE, &quot;[%s:%d]# %s&quot;, senderIP.c_str(),senderPort, inBuf);//打印信息    &#125;&#125;\n\n如果你想让另外一台主机访问这个服务，则需要在云服务器控制台和linux系统中同时开放对应的udp端口\n\n参考 【Linux】设置系统防火墙\n\n3.client有了服务端，也要有对应的客户端来发送消息；除了发送消息的部分，其余操作和服务端基本一致。\n3.1 sendto#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,               const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);\n\n这里我们要用的是sendto接口\n\n第一个参数是socket套接字\n第二个参数是用于输入的缓冲区\n第三个参数是缓冲区的类型\n第四个参数是标识符，也设置为0\n第五个参数和第六个参数与recvfrom一致，为目标服务器的信息\n\n关于flag参数，man手册中有更多选项，这里我们依旧传入0采用默认策略\nThe flags argument is the bitwise OR of zero or more of the following flags.\n\n3.2 客户端需不需要手动bind?首先我们要明确一点，bind函数并没有规定一定要是服务端才能使用。也就是说，要不要使用bind是程序猿自己的选择。\n答案其实很简单：那就是不需要手动bind\n首先我们要知道一点：如果一个网络进程在启动的时候没有手动bind端口，系统是会自动分配一个未使用的端口给它的\n\n对于服务器来说，IP:端口必须固定，否则没有办法给客户端提供稳定的服务。客户又不能拆了你的应用程序修改源码中的端口！\n而对于客户端来说，端口应该让系统自动分配。因为这样能避免冲突问题。不然如果有另外一个应用占用了客户端bind的端口，那这个程序就会因为端口冲突而一直打不开！\n\n所以，客户端不需要我们调用bind函数，只需要配置好服务端的目标ip和目标端口就行了\n3.3 代码示例#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cassert&gt;#include &lt;unistd.h&gt;#include &lt;strings.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;using namespace std;struct sockaddr_in server;// ./udpClient server_ip server_port// 客户端要连接server，必须知道server对应的ip和portint main(int argc, char *argv[])&#123;    if (argc != 3)    &#123;        cout &lt;&lt; &quot;Usage:\\n\\t&quot; &lt;&lt; argv[0] &lt;&lt; &quot; server_ip server_port&quot; &lt;&lt; endl;        return 1;    &#125;    // 1. 根据命令行，设置要访问的服务器IP    string server_ip = argv[1];    uint16_t server_port = atoi(argv[2]);    // 2. 创建客户端    // 2.1 创建socket    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);    if(sockfd&lt;0)    &#123;        cout &lt;&lt; &quot;socket 创建失败&quot; &lt;&lt; endl;        return 2;    &#125;    bzero(&amp;server, sizeof(server));//这个函数相当于memset全0    server.sin_family = AF_INET;//ipv4    server.sin_port = htons(server_port);//目标服务器端口    server.sin_addr.s_addr = inet_addr(server_ip.c_str());//目标ip    // 3. 通讯过程    string buffer;    while (true)    &#123;        cerr &lt;&lt; &quot;Please Enter# &quot;;        getline(cin, buffer);        // 发送消息给server        sendto(sockfd, buffer.c_str(), buffer.size(), 0,               (const struct sockaddr *)&amp;server, sizeof(server));         // 首次调用sendto函数的时候，client会自动bind自己的ip和port        // 客户端不应该自己绑定端口，否则端口被占用=客户端不能用    &#125;    close(sockfd);    return 0;&#125;\n\n3.4 运行测试这里提供一个makefile，来快速编译服务端&#x2F;客户端的源码\n.PHONY:allall:udpClient udpServerudpClient: udpClient.cpp\tg++ -o $@ $^ -std=c++11 -lpthreadudpServer:udpServer.cpp\tg++ -o $@ $^ -std=c++11.PHONY:cleanclean:\trm -f udpClient udpServer\n\n运行服务器，指定8080端口启动。再运行客户端，指定127.0.0.1本地ip和8080端口\n\n可以看到，右侧我们收到的信息，都在左侧被打印了出来，同时显示了来源ip和端口\n3.5 windows客户端让我没想到的是，windows上网络的接口和linux很相似；这里提供一个windows下的udp客户端，向我们的云服务器发送信息\n注：进行测试前，一定要在防火墙里面开放云服务器对应的udp端口\n#define _WINSOCK_DEPRECATED_NO_WARNINGS 1//屏蔽报错#include&lt;winsock2.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;#pragma comment(lib,&quot;ws2_32.lib&quot;)#define BUFFER_SIZE  1024    //缓冲区大小int main() &#123;    WSADATA WSAData;    //初始化    if (WSAStartup(MAKEWORD(2, 2), &amp;WSAData) != 0)     &#123;        printf(&quot;初始化失败!&quot;);        return -1;    &#125;        //创建客户端用于通信的Socket    SOCKET sock_Client = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    //服务器的地址数据结构    SOCKADDR_IN addr_server;       addr_server.sin_family = AF_INET;    addr_server.sin_port = htons(10000);// 目标端口    addr_server.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); //目标公网ip(需要改成你自己的)    string sendBuf;    while (true)     &#123;        cout &lt;&lt; &quot;请输入要传送的数据: &quot;;        getline(cin,sendBuf);        sendto(sock_Client, sendBuf.c_str(),sendBuf.size(), 0, (const SOCKADDR*)&amp;addr_server, sizeof(addr_server));        cout &lt;&lt; sendBuf.size() &lt;&lt; &quot;: &quot; &lt;&lt; sendBuf &lt;&lt; endl;    &#125;    closesocket(sock_Client);    WSACleanup();    return 0;&#125;\n\n测试一下，可以看到云服务器成功收到了信息，但因为windows和linux的文字编码问题，没能正确显示出中文\n\n发送英文信息是没有问题的！\n\n4.更进一步4.1 记录用户有用户给你发送信息，理论上来说，服务端应该记录下用户，以备debug;\n这部分并不难，我们记录下用户的ip和端口，还有用户的peer结构体，在服务器里面维护一个map来存放就可以了\nvoid CheckUser(struct sockaddr_in peer)&#123;    string tmp = inet_ntoa(peer.sin_addr);// 来源ip    tmp += &#x27;:&#x27;;    tmp += to_string(ntohs(peer.sin_port));// 来源端口    // 在map中用ip端口来标识用户    auto it = _usrMap.find(tmp);    if(it == _usrMap.end())// 没找到    &#123;        _usrMap.insert(&#123;tmp,peer&#125;);    &#125;&#125;\n\n4.2 客户端接收回信客户端发送信息给服务器后，可以来接收一下服务器的回信。比如在日常生活中，我们发邮件的时候，需要等待对方回信，这才表明你的信对方确实收到了，而不是丢在半路上了\n// 使用多线程操作，来获取服务器传回的信息pthread_t t;pthread_create(&amp;t, nullptr, recverAndPrint, (void *)&amp;sockfd);\n\n为了方便，这里采用多线程的方式来操作；客户端在接收到服务器的回信后，会打印出来\nvoid *recverAndPrint(void *args)&#123;    while (true)    &#123;        int sockfd = *(int *)args;        char buffer[1024];        struct sockaddr_in temp;        socklen_t len = sizeof(temp);        ssize_t s = recvfrom(sockfd, buffer, sizeof(buffer), 0, (struct sockaddr *)&amp;temp, &amp;len);        if (s &gt; 0)        &#123;            buffer[s] = 0;//将接收到的信息打印出来（服务器返回的）            cout &lt;&lt; &quot;server echo# &quot; &lt;&lt; buffer &lt;&lt; &quot;\\n&quot;;        &#125;    &#125;&#125;\n\n4.3 消息路由所谓消息路由，就是把接收到的消息广播给所有用户。可以理解为一个简单的聊天室。\n上面我们已经获取并记录了信息，下面要做的就是把信息重新发给其他用户；操作和客户端的发送是一样的\nvoid MsgRoute(const char* inBuf,size_t len)&#123;    struct sockaddr_in user;    for(auto e:_usrMap)    &#123;        user.sin_family = AF_INET;//ipv4        user.sin_port = e.second.sin_port;//用户端口        user.sin_addr.s_addr = e.second.sin_addr.s_addr;//用户ip        // 向用户发送信息        sendto(_sockfd, inBuf, len, 0,               (const struct sockaddr *)&amp;user, sizeof(user));     &#125;&#125;\n\n测试，可以看到，服务端把收到的消息发送给了用户\n\n再新增一个客户端进行测试，可以看到两个客户都收到了服务器的回信\n\n这里对于聊天室来说还有一个小问题，那就是聊天框里面并不会二次出现你的消息。也就是服务器不会把你发送的消息再转发给你。\n我们在消息路由函数里面进行判断即可！\nvoid MsgRoute(struct sockaddr_in peer,const char* inBuf,size_t len)&#123;    struct sockaddr_in user;    for(auto e:_usrMap)    &#123;        // 如果ip和端口都相等，就代表是发送消息的用户        if(e.second.sin_port != peer.sin_port || e.second.sin_addr.s_addr != peer.sin_addr.s_addr)        &#123;            user.sin_family = AF_INET;//ipv4            user.sin_port = e.second.sin_port;//用户端口            user.sin_addr.s_addr = e.second.sin_addr.s_addr;//用户ip            // 向用户发送信息            sendto(_sockfd, inBuf, len, 0,                   (const struct sockaddr *)&amp;user, sizeof(user));         &#125;    &#125;&#125;\n\n因为乱序打印的问题，所以看的可能不是很明显。但是我们的目的已经达到了！\n\n这样打印看的不是很清楚，可以使用管道文件来实现输出重定向\nmkfifo fifo #创建一个fifo管道文件\n\n运行客户端的时候，指定输出\n./udpClient 127.0.0.1 1000 &gt; fifo\n\n在另外一个bash里面，用cat来获取输出\ncat &lt; fifo\n\n这就不会出现乱序打印的问题了。\nfifo是一个管道文件，需要执行cat后（读端），客户端（写端）才能运行\n5.关于什么时候需要bind本文以下内容建议学习了UDP底层报文和相关网络协议栈的知识后再来看，会方便理解一些。\n参考文章：socket 通信关于bind IP地址\n5.1 情况一情况一：若有客户端和服务器之分的程序，创建sock后即可在该socket上用recvfrom/sendto方法发送接受数据了。\n因为客户端只需要用sendto发送数据到指定的地址，所以不需要bind本地的ip和端口。当然若是bind了，程序也没什么问题，区别就是不bind的时候，系统会自动bind()指定本机的socket参数地址来进行发送数据库。\n而服务器因为必须要有一个显式的、固定的IP端口供客户端连接，所以接收方是必须要进行bind的。\n那UDP服务器是怎么知道客户端的IP地址和UDP端口？一般来说有两种方式：\n\n一种是客户端发消息显式地告诉服务器IP地址和端口，消息内容就包括IP地址和UDP端口。\n另外一种就是隐式的，服务器从收到的包的报文头部中得到包的源IP地址和端口。\n\n5.2 情况二若是没有客户端和服务器之分的程序，即自己指定特定端口的UDP对等通信（双向对等通信），则客户端和服务器都需要bind() IP地址和端口了。因为双方都需要知道对方的IP和端口才能进行数据收发。\n5.3 多播但UDP中更常用的是广播分发，服务端socket设定一个X.X.X.255的广播地址并始终向它发送，每个客户端建立的socket只需要加入这个广播地址便可以收到，这个行为称为加入多播组。这便是多播的概念。\n一个多播组可以被多个进程加入，加入了这个多播组后，所有进程将收到相同的消息。这样就实现了一对多通信。\n请注意，多播地址是不能进行bind的，我们需要用相关的接口将自己的fd加入目标多播组，才能从这个多播组中收到信息。发送方是不需要加入多播组的，直接往多播组的ip地址里面发就行了。\n\n接收方需要调用接口加入指定多播组\n发送方不需要加入多播组\n\n\n重点: 加入了多播组后，将无法收到原本bind的ip地址的消息！比如一个udp的socket，原本bind了0.0.0.0:5000，在加入多播组之前，我能正常从5000端口中收到信息；但是加入了多播组后，我就只能从多播组里面收信息了。\n\n接收方加入多播组的接口如下，在接收方的bind之后调用就行了\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#define MCAST_GROUP &quot;224.0.0.1&quot;#define MCAST_PORT 5007int main() &#123;    int sockfd;    struct sockaddr_in addr;    socklen_t addrlen = sizeof(addr);    char buffer[1024];    // 创建UDP套接字    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) &#123;        perror(&quot;socket&quot;);        exit(EXIT_FAILURE);    &#125;    // 设置接收端地址和端口    memset(&amp;addr, 0, sizeof(addr));    addr.sin_family = AF_INET;    addr.sin_addr.s_addr = htonl(INADDR_ANY);    addr.sin_port = htons(MCAST_PORT);    // 绑定接收端地址和端口    if (bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1) &#123;        perror(&quot;bind&quot;);        exit(EXIT_FAILURE);    &#125;    // 加入多播组    struct ip_mreq mreq;    mreq.imr_multiaddr.s_addr = inet_addr(MCAST_GROUP);    mreq.imr_interface.s_addr = htonl(INADDR_ANY);    if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)) == -1) &#123;        perror(&quot;setsockopt&quot;);        exit(EXIT_FAILURE);    &#125;    // 接收数据    if (recvfrom(sockfd, buffer, sizeof(buffer), 0, (struct sockaddr*)&amp;addr, &amp;addrlen) == -1) &#123;        perror(&quot;recvfrom&quot;);        exit(EXIT_FAILURE);    &#125;    // 打印接收到的数据    printf(&quot;Received: %s\\n&quot;, buffer);    // 关闭套接字    close(sockfd);    return 0;&#125;\n\n因为多播通常需要绑定特殊的IP地址（例如 224.0.0.0 到 239.255.255.255），这些IP地址是无法在公网上使用的，所以多播是只存在于局域网中的概念。要想实现多播，发送端和接受端必须处于同一局域网。\n5.4 直播推流\n以下都是我根据自己的理解瞎逼逼的，有问题还请指出。\n\n公网上，也有使用UDP进行“多播”的例子，比如我们常用的直播就是使用的UDP（因为直播是一个视频流推送给N个用户，如果每个用户都建立一个tcp连接会有巨大的消耗，服务器压根顶不住。再加上tcp需要等待用户发回ack，在一对多的大型推流场景下，等待ack的消耗也不容忽视）\n直播推流情况下，其实并不是用局域网内的多播实现的，而是用UDP模拟实现一个类似“多播”的一对多通信。\n下面举个例子，我们暂时认为客户机也是拥有公网IP的，后续学习到IP层，会提到NAT技术，到时候就能理解家宽是怎么和服务器通信的了\n\n客户机想看主播的直播，直播app会发送一个请求到特定的IP:端口，请求建立一个直播推流的连接。这个请求中就会包含客户机自己的IP地址和端口号\n服务端接受请求，解析出客户机的IP和端口号，并将其加入到推流队列中\n服务端每一次推流视频，都遍历全部连接到这个直播上的客户机的IP端口，通过UDP向他们发送视频数据。\n这样就实现了一个服务端向多个客户机“广播”直播推流数据的通信。\n\n需要注意的是，这和前文提到的局域网内的多播完全不同！这里我们依旧是用公网IP和端口进行一对一通信的，只不过服务器端进行了处理，会向所有客户机发送视频流数据罢了。\n你可能会有疑惑，现在的直播那么多人看，一个热门的直播间几万人甚至上十几万人，服务器用遍历发送的方式来得及吗？如果遍历发送一次所有客户机的耗时超过了每次发送的数据大小，岂不是大家都卡顿了吗？\n\n如果你了解UDP报文的结构的话，就知道UDP一次发送最多只能发送64KB的数据，对于直播推流&#x2F;视频来说，64KB的数据恐怕只有1秒的视频。\n\n其实我们直播出现卡顿，就是这么个原因。服务端没有办法推流那么多用户了，就会出现卡顿乃至中断的情况。而且，只用同一台服务器对所有用户进行广播肯定是不够的，这时候就会引入不同线路来进行优化：\n\n主播连接一个主服务器，推流自己的直播视频数据\n主服务器将该直播视频流数据发送给全国各地的子服务器\n用户A进入直播间，将请求主服务器，发送自己的IP和端口号\n主服务器将用户A的IP和端口号解析，根据IP属地，发送给一个距离用户A最近的子服务器B，让子服务器B来给用户A进行直播的推流\n此时用户A收到的视频数据：主播-&gt;主服务器-&gt;子服务器B-&gt;用户A；\n\n这样，推流的压力就能分散给不同的子服务器线路。\n我们看直播的时候可以选择线路切换，其实也就是在不同的子服务器中进行切换，如果某个子服务器压力较低，此时在这个子服务器的线路上接收直播推流，用户的观看体验就比较流畅了。\n\nmore…关于udp编程的操作到这里就Over啦，现在我们认识了大部分的网络接口，下一步的目标，就是实现tcp服务器啦！\n\n","categories":["玩上Linux"],"tags":["Linux","线程","网络"]},{"title":"【Linux】实现守护进程 | 以tcpServer为例","url":"/posts/2887088349/","content":"本文将以tcp服务器代码为基本，讲述如何将进程守护进程化，后台运行\n\n\n1.守护进程所谓守护进程，就是和其他进程没有关系的进程；其独立运行于系统后台，除非自己退出或收到信号终止，否则会一直运行下去\n1.1 进程组在我们使用的bash中，同一时刻只会有一个前台进程组\n\n如图，当一个前台进程开始运行之后，我们没有办法在当前终端开启第二个前台进程。\n在运行的命令后面加&amp;，临时让当前进程在后台运行。注意，此时tcp虽然在后台运行了， 但对于它而言，stdin/stdout/stderr的文件描述符依旧指向的是当前bash的输入输出，所以它的日志依旧会打印到当前终端上。\n用ps命令查看当前进程的信息，其中ppid是当前进程的父进程，也就是当前bash，pid是进程编号，pgid是进程的组编号，可以看到这个组编号和grep命令的组编号是不同的。\n\n我们用这个c语言的代码调用两次fork，相当于创建了3个子进程。\n#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123;    fork();    fork();    sleep(100);    return 0;&#125;\n\n此时再来查看进程信息，能看到这4个进程的进程组pgid是相同的，而且和第一个test的pid相同；这说明第一个test就是父进程，后面的3个都是子进程。\n\n1.2 进程会话这里还有一个我们之前没有太多了解的信息，进程的sid是什么？\n还是上面的例子，在图中能看到，我们执行的test和grep的sid都是相同的，而且都等于第一个test进程的ppid（bash的pid）\n\n这表明图中的5个进程同属于一个进程会话，这个会话就是我们当前打开的bash，并用sid来表示进程会话；\n\n这也是为什么我们登录linux的时候一定会有一个终端，linux系统就是创建会话并加载bash，来给用户提供服务的。\n\n既然存在会话，那就肯定会有会话的资源上限。一旦满了，就会开始杀掉一些进程。\n./test &amp;\n\n即便我们用&amp;让进程在后台运行，其也有可能收到会话的创建/关闭的影响而被操作系统干掉🧐比如我们将当前正在运行进程的bash关掉，其前台进程会被直接终止，后台进程也会受到影响（有可能终止有可能不终止，取决于系统）\n这和我们对tcp服务器的需求不一致：我们需要的是让tcp服务器的进程能一直稳定的在后台运行，让操作系统别去管它；除非系统内存满了，负载重到实在没有办法的时候，操作系统才能过来把他刀了。\n为了不让守护进程受到进程会话的影响，我们就必须让其能够独立出来，自成一个进程组和一个新会话\n👆这种独立的进程，就可以被称为守护进程/精灵进程\n2.实现2.1 自己写别以为写这个很难哦，实际特别简单！\n2.1.1 setsid这里需要用到的setsid接口，其作用如名字一般，是设置当前进程的进程会话组\n#include &lt;unistd.h&gt;pid_t setsid(void);\n\n但是调用这个函数有一个要求：调用的进程不能是进程组的组长！\n比如下图中，第一个test就是进程组的组长，它不能调用这个函数。会报错\n\n那要怎么让自己不成为进程组的组长呢？很简单，创建一个子进程就ok了！\nif (fork() &gt; 0)    exit(0);//父进程直接退出\n\n2.1.2 重定向到dev&#x2F;null\n如果你不知道什么是/dev/null，简而言之，这是一个linux下的数据垃圾桶。和windows的回收站会存放删除的资料不同，这个垃圾桶是个黑洞，丢进去的东西不会被存放，是直接丢弃的！\n\n守护进程需要把默认的0.1.2文件描述符都重定向到dev/null，是因为设置成独立的进程组和进程会话了之后，当前进程是没有和bash关联的。\n此时，默认这个0 1 2所指向的bash是无效的！如果不重定向，使用cout打印的时候，就会引发异常（可以理解为往一个不存在的文件中写内容），服务器直接退出了，无法实现守护进程。\n重定向了之后，所有的打印输出都会被丢到/dev/null这个文件垃圾桶中，也就不需要担心上述的问题。\nif ((fd = open(&quot;/dev/null&quot;, O_RDWR)) != -1) // fd == 3&#123;    dup2(fd, STDIN_FILENO);    dup2(fd, STDOUT_FILENO);    dup2(fd, STDERR_FILENO);    // 6. 关闭掉不需要的fd    // 因为fd只是临时用于重定向，操作完毕了就可以关掉了    if(fd &gt; STDERR_FILENO)         close(fd);&#125;\n\n你可能会疑惑，那日志信息也被丢到垃圾桶里面了，怎么办？\n很简单，因为我们服务器的日志都统一使用了log.hpp里面的logging函数，所以只需要对logging函数的输出重定向到日志文件里面，就ok了！\n2.1.3 chdir（选做）这个操作的目的是修改工作路径。作为服务器进程，很多日志信息是存放在/etc/目录而不是当前路径下的，为了安全，也应该使用绝对路径而不用相对路径，避免出现工作目录切换而导致的无法读写文件的问题\n不过，如果使用绝对路径，即便我们不修改工作目录，也是能正常访问的；所以这个操作是选做的\n2.1.4 信号捕捉自己写这个函数有个好处，那就是我们可以在里面自定义捕捉一些信号，给这些信号 加上自己的自定义方法；\n比如SIGPIPE就是管道的信号，当管道的读端关闭的时候，写端会被终止；此时写端就会收到这个信号。如果不对这个信号进行SIG_IGN忽略，我们的服务器会直接终止！\nsignal(SIGPIPE, SIG_IGN);\n\n除了这个信号，我们还可以对2号或者3号信号进行自定义捕捉，设定退出信号，让服务器能够安全退出（保存日志信息到磁盘，释放资源等；虽然进程退出之后操作系统会帮我们干这些事，但我们这么写能让项目更规范）\n2.1.5 完整代码#pragma once#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; // O_RDWR 需要void daemonize()&#123;    int fd = 0;    // 1. 忽略SIGPIPE (管道读写，读端关闭，写端会收到信号终止)    signal(SIGPIPE, SIG_IGN);    // 2. 更改进程的工作目录    // chdir(); // 可以改，可以不改    // 3. 让自己不要成为进程组组长    if (fork() &gt; 0)        exit(0);    // 4. 设置自己是一个独立的会话    setsid();    // 5. 重定向0,1,2    if ((fd = open(&quot;/dev/null&quot;, O_RDWR)) != -1) // fd == 3    &#123;        dup2(fd, STDIN_FILENO);        dup2(fd, STDOUT_FILENO);        dup2(fd, STDERR_FILENO);        // 6. 关闭掉不需要的fd        // 因为fd只是临时用于重定向，操作完毕了就可以关掉了        if(fd &gt; STDERR_FILENO)             close(fd);    &#125;    // 这里还有另外一种操作，就是把stdin/stdout/stderr给close了    // 但是这样会导致只要有打印输出的代码，进程会就异常退出&#125;\n\n没错，就这一点点代码，就能让我们的tcp服务器变成守护进程！\n\n此时我们的客户端依旧能正常连接服务端，获取结果\n\n2.2 nohupno hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。用nohup命令执行一个进程，就能让这个进程成为不受终端退出影响的进程\nnohup ./test &amp;\n\n此时，nohup会在当前目录下创建一个nohup.out文件，用于记录test进程的输出信息（如果通过了&gt;或&gt;&gt;执行了重定向，则不会创建）\n\n通过ps可已看到，当前test进程的进程会话还是和bash相同，但我们关闭当前bash，这个test进程依旧能正常运行，只不过父进程会变成操作系统1，我们的目的也算是达到了\n\n2.3 deamon接口linux系统中有一个接口daemon，可以帮我们实现守护进程\n#include &lt;unistd.h&gt;int daemon(int nochdir, int noclose);\n\n了解过守护进程的写法了之后，这两个参数的作用就很明显了\n\n第一个参数nochdir表明是否需要修改工作目录；如果设置为0，则切换工作目录到/系统根目录\n第二个参数noclose表明是否需要重定向基础io到/dev/null；设置为0则重定向\n\n以下是man手册中的说明\nIf nochdir is zero, daemon() changes the calling process&#x27;s current working directory to the root directory (&quot;/&quot;); otherwise, the  cur‐rent working directory is left unchanged.If noclose is zero, daemon() redirects standard input, standard output and standard error to /dev/null; otherwise, no changes are madeto these file descriptors.\n\n我们直接用一个简单代码来演示\n#include &lt;unistd.h&gt;int main()&#123;    //不需要修改工作目录，第一个参数设为1    //因为没有进行打印，重定向设置成1，不进行重定向    int ret = daemon(1,1);    sleep(100);    return 0;&#125;\n\n运行之后可以看到，这个进程的父id是操作系统，其自成一个进程组和进程会话；和我们自己写的函数作用相同\n\n3.重定向log因为守护进程把输入输出丢到了垃圾捅里面，所以我们就需要重定向日志的输出\n#define LOG_PATH &quot;./log.txt&quot; //工作路径下的log.txt// 这个类只用于重定向，不需要在里面加其他东西class Logdup&#123;public:    Logdup()        :_fdout(-1),_fderr(-1)    &#123;&#125;    Logdup(const char* pout=LOG_PATH,const char* perr=&quot;&quot;)        :_fdout(-1),_fderr(-1)    &#123;        //如果只传入了第一个pout，则代表将perr和pout重定向为一个路径        umask(0);        int logfd = open(pout, O_WRONLY | O_CREAT | O_APPEND, 0666);        assert(logfd != -1);        _fdout = _fderr = logfd;//赋值可以连等        //判断是不是空串        if(strcmp(perr,&quot;&quot;)!=0)//不相同，代表单独设置了err的路径        &#123;            logfd = open(perr, O_WRONLY | O_CREAT | O_APPEND, 0666);            assert(logfd != -1);            _fderr = logfd;        &#125;        dup2(_fdout, 1);//重定向stdout        dup2(_fderr, 2);//重定向stderr    &#125;    ~Logdup()    &#123;        if(_fdout!= -1)        &#123;            fsync(_fdout);            fsync(_fderr);            // 先写盘再关闭            close(_fdout);            close(_fderr);        &#125;    &#125;private:    int _fdout;//重定向的日志文件描述符    int _fderr;//重定向的错误文件描述符&#125;;c\n\n做完这一切之后，我们运行服务器，的确创建了log.txt文件，可里面空空如也\n\n这是因为我们的数据其实都被写道了缓冲区里面，我们需要在logging里面添加一个刷新机制，才能让数据尽快写入到硬盘中，避免日志丢失\nfflush(out); // 将C缓冲区中的数据刷新到OSfsync(fileno(out));// 将OS中的数据写入硬盘\n\n此时再运行服务器，就能看到日志很快被写入文件里面了。\n\nover搞定啦！\n","categories":["玩上Linux"],"tags":["Linux","网络"]},{"title":"【Linux】popen pclose接口介绍","url":"/posts/2190670283/","content":"本篇文章简单讲述了c语言接口popen/pclose的用法\n\n\n\n1.函数作用函数定义如下\n#include &lt;stdio.h&gt;FILE *popen(const char *command, const char *type);int pclose(FILE *stream);\n\npopen函数会创建一个管道，fork一个子进程，关闭管道的不使用端，通过exec函数执行一个shell命令，等待命令终止。并将命令的输出结果通过管道返回给当前的进程；\n1.1 popenpopen函数会创建一个管道，fork后调用shell来打开进程。由于管道的定义是单向的，第二个参数type只能指定读或写，不能同时指定读和写；\n所得到的管道相应地是只读或只写的\n   The  popen()  function opens a process by creating a pipe, forking, and invoking the shell.  Since a pipe is by definition unidirectional, the type argument may specify only reading or writing, not both; the resulting stream is correspondingly read-only or write-only.\n\n简单说来，popen会自动帮我们fork创建子进程和一个管道，将我们传入的参数command在shell中执行后，将返回值以管道文件的形式发送给调用方。\n如果调用fork或pipe失败，或者不能分配内存，将返回NULL；否则返回标准I&#x2F;O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL\n1.2 pclose\n这个函数没有什么好说的，是用来关掉popen打开的文件的（即popen的返回值）\n\n但是，它的返回值可有说到了，其返回值就是我们终端操作的退出状态，以标识命令是否成功执行\n但是这个返回是通过wait4得到的，如果wait4出现错误，就会返回-1并设置errno\nThe pclose() function returns -1 if wait4(2) returns an error, or some other error is detected.  In the event of an error, these functions set errnro to indicate the cause of the error.\n\n这里还出现了一个新的错误码errnro，但是经过我的一番百度，没有发现任何地方有对errnro的说明，man手册下方又变成了errno\nIf pclose() cannot obtain the child status, errno is set to ECHILD.\n\n而且编译执行的时候，errnro是会报错的，所以姑且认为这里是man手册出错了！\n\nerrno才是正确的\nint ret = pclose(f);printf(&quot;pclose: %d | %s\\n&quot;,ret,strerror(errno));\n\n\n2.代码示例2.1 popen读以下方最简单的ls命令为例，我们以读方式打开，popen就会将ls的执行结果写到文件里面返回给我们\n#include &lt;stdio.h&gt; int main()&#123;    FILE *f;    char readBuf[1024] = &#123;0&#125;;    f = popen(&quot;ls&quot;,&quot;r&quot;);    fread(readBuf,1024,1,f);    printf(&quot;%s\\n&quot;,readBuf);    pclose(f);    return 0;&#125;\n\n编译后执行结果如下\n$ ./testtesttest.cpp    \n\n2.2 popen写和读不同，如果用写方式执行popen，命令的输出结果会直接打印到屏幕上\nvoid test2(FILE* f)&#123;    f = popen(&quot;ls&quot;,&quot;w&quot;);    int ret = pclose(f);    printf(&quot;pclose: %d | %s\\n&quot;,ret,strerror(errno));&#125;\n\nmakefile  test  test.cpppclose: 0 | Success\n\n这里我还以为后续可以接着往管道里面写数据，让他继续执行命令\nvoid test2(FILE* f)&#123;    f = popen(&quot;ls&quot;,&quot;w&quot;);    // 缓冲区中写入数据    strcpy(readBuf,&quot;ls -l&quot;);    printf(&quot;cmd: %s\\n&quot;,readBuf);    // 写道管道文件中    fwrite(readBuf,1024,1,f);    int ret = pclose(f);    printf(&quot;pclose: %d | %s\\n&quot;,ret,strerror(errno));&#125;\n\n可测试的结果告诉我，并不行\ncmd: ls -lmakefile  test  test.cpppclose: 0 | Success\n\n网上的资料大多数都是只演示了r方法，我不确定这里是不是我写的代码有问题，还是说本来就是这样的。暂且停留在这里吧！\n3.优缺点优点是：由于所有类Unix系统中参数扩展都是由shell完成的，所有它运行我们通过popen完成非常复杂的shell命令。而其他一些创建进程的函数（如execl）调用起来就复杂的多，因为调用进程必须自己完成shell扩展。\n缺点是：针对每个popen调用，不仅要启动一个被请求的程序，还要启动一个shell,即每个popen调用将启动两个进程。从节省系统资源的角度来看，popen函数的调用成本略高，并且对目标命令的调用比正常方式慢一些（通过pipe改进）。\nend关于popen和pclose的简单介绍到这里就结束了，欢迎评论区交流\n","categories":["玩上Linux"],"tags":["Linux","C语言"]},{"title":"【网络】自定义协议 | 序列化和反序列化 | 以tcpServer为例","url":"/posts/4225991450/","content":"以tcpServer的计算器服务为例，实现一个自定义协议\n\n\n\n阅读本文之前，请先阅读 tcpServer\n本文完整代码详见 Gitee\n\n1.重谈tcp注意，当下所对tcp的描述都是以简单、方便理解起见，后续会对tcp协议进行深入解读\n1.1 链接我们知道，tcp是面向连接的，客户端和服务端要先建立链接，才能开始通信\n\n在链接过程中，tcp采用三次握手\n在断线过程中，tcp采用四次挥手\n\n举个日常生活中的栗子，帮助理解3次握手和4次挥手\n\n1.2 信息发送\n假如我们现在需要发送结构化数据，那应该怎么办？\n\n我们知道，tcp是面向字节流的，也就是其能够发送任意数据。也能够发送C语言结构体的二进制数据；\n\n但能发送，就代表我们可以这么干吗？\n答案自然是不行！\n\n不同平台，对结构体对齐的配置不同，大小端不同，其最终对我们字节流的解析也就不一样。如果采用直接发送结构体数据的方式来通信，适配性极低，我们的客户端和服务端都会被限制在当前的系统环境中运行；\n可是，哪怕是同一个系统，其内部对大小端的配置也有可能改变！到时候我们的代码恐怕就无法运行了！\n同理，在当初编写C语言通讯录的代码的时候，也不能采用直接将结构体数据写入文件的方式。后续代码升级、环境改变，都可能导致我们存在文件中的数据失效，这肯定是我们不希望看到的情况。\n所以，为了解决这个问题，我们就应该将数据进行序列化之后再发送，客户端接收到信息后，进行反序列化解析出数据！\n2.序列化和反序列化2.1 简介所谓序列化，就是将结构化的数据（可以暂时理解为c的结构体）转换成字符串的方式，发送出去\nstruct date&#123;    int year;    int month;    int day;&#125;;\n\n比如上面这个日期结构体，我们要想将其序列化，就可以用一个很简单的方式拼接成一个字符串（序列化）\nyear-month-day\n\n客户端收到这个字符串之后，就可以通过查找分隔符-的方式，取出三个变量，将其转成int后存放回结构体（反序列化）\n这样，我们就算是规定了一个序列化和反序列化的方式，也就是一个简单的协议！\n\n2.2 编码解码这里还会出现另外一个问题，我要怎么知道我已经读取完毕了一个序列化后的数据呢？\n2000-12-1010000-01-01\n\n如上，假设有一天，我们的年变成了五位数；这时候，服务端要怎么知道自己是否读取完毕了一个完整的序列化数据呢？\n这就需要我们做好规定，将前n字节作为标识长度的数据。接收到数据后，先取出前n个字节，读取道此次消息的长度m，再往后读取m个字节的数据，成功取出完整的字符串;\n\n这个过程可以称作编码和解码的过程\n\n为了区分标识长度的数据和实际需要的序列化内容，我们可以在之中加上分隔符\\t；但这也需要我们确认，传输的数据本身不能带上\\t，否则会产生一系列的问题\n10\\t2000-12-10\\t11\\t10000-01-01\\t\n\n以上的这一系列工作，都是协议定制的一部分！我们给服务端和客户端规定了一个序列化和反序列化的方式，让二者通信规避掉了平台的限制。毕竟任何平台对字符串解码出来的数据都会是相同的！\n下面就用一个计算器的服务，来演示一下吧😏\n3.计算器服务因为本文的重心是对协议定制的演示，所以这里的计算器不考虑连续操作符的情况，\n3.1 协议定制要想实现一个计算器，我们首先要搞明白计算器有几个成员\nx+yx/yx*y...\n\n一般情况下，一个计算器只需要3个成员，分别是两个操作数和一个运算符，就能开始计算。所以我们需要将这里的三个字段设计成一个字符串，实现序列化；\n比如我们应该规定序列化之后的数据应该是如下的，两个操作数和操作符之间应该要有空格\na + b\n\n再在开头添加上数据长度的标识\n数据长度\\t公式\\t7\\t10 + 20\\t8\\t100 / 30\\t9\\t300 - 200\\t\n\n对于服务端，我们需要返回两个参数：状态码和结果\n退出状态 结果\n\n如果退出状态不为0，则代表出现错误，结果无效；只有退出结果为0，结果才是有效的。\n同样的，也需要给服务器的序列化字符串添加上数据的长度\n数据长度\\t退出状态 结果\\t\n\n这样就搞定了一个计算器的自定义协议；\n3.2 成员依照如上的协议，先把请求和返回的成员变量写好\nclass Request&#123;    int _x;    int _y;    char _ops;&#125;;\n\nclass Response&#123;\tint _exitCode; //计算服务的退出码\tint _result;  // 结果&#125;;  \n\n这些成员变量都设置为公有，方便在task里面进行处理（否则就需要写get函数，很麻烦）\n同时，最好还是把协议中的分隔符给定义出来，方便后续统一使用or更改\n#define CRLF &quot;\\t&quot;   //分隔符#define CRLF_LEN strlen(CRLF) //分隔符长度#define SPACE &quot; &quot;   //空格#define SPACE_LEN strlen(SPACE) //空格长度#define OPS &quot;+-*/%&quot; //运算符\n\n3.3 编码解码对于请求和回应来说，编解码的操作是一样的，都是往字符串的开头添加上长度和分隔符\n长度\\t序列化字符串\\t\n\n解码就是将长度和分隔符去掉，只解析出序列化字符串\n序列化字符串\n\n编码解码的整个过程在注释里面都写明了😁为了方便请求和回应去使用，直接放到外头，不做类内封装\n//参数len为in的长度，是一个输出型参数。如果为0代表errstd::string decode(std::string&amp; in,size_t*len)&#123;    assert(len);//如果长度为0是错误的    // 1.确认in的序列化字符串完整（分隔符）    *len=0;    size_t pos = in.find(CRLF);//查找分隔符    //查找不到，err    if(pos == std::string::npos)&#123;        return &quot;&quot;;//返回空串    &#125;       // 2.有分隔符，判断长度是否达标    // 此时pos下标正好就是标识大小的字符长度    std::string inLenStr = in.substr(0,pos);//提取字符串长度    size_t inLen = atoi(inLenStr.c_str());//转int    size_t left = in.size() - inLenStr.size()- 2*CRLF_LEN;//剩下的字符长度    if(left&lt;inLen)&#123;        return &quot;&quot;; //剩下的长度没有达到标明的长度    &#125;    // 3.走到此处，字符串完整，开始提取序列化字符串    std::string ret = in.substr(pos+CRLF_LEN,inLen);    *len = inLen;    // 4.因为in中可能还有其他的报文（下一条）    // 所以需要把当前的报文从in中删除，方便下次decode，避免二次读取    size_t rmLen = inLenStr.size() + ret.size() + 2*CRLF_LEN;    in.erase(0,rmLen);    // 5.返回    return ret;&#125;//编码不需要修改源字符串，所以const。参数len为in的长度std::string encode(const std::string&amp; in,size_t len)&#123;    std::string ret = std::to_string(len);//将长度转为字符串添加在最前面，作为标识    ret+=CRLF;    ret+=in;    ret+=CRLF;    return ret;&#125;\n\n3.4 request编码解码写好了，先来处理比较麻烦的请求部分；说麻烦吧，其实大多数也是c++的string操作，要熟练运用string的各类成员函数，才能很好的实现\n3.4.1 构造比较重要的是这个构造函数，我们需要将用户的输入转成内部的三个成员\n用户可能输入x+y，x+ y，x +y,x + y等等格式\n\n这里还需要注意，用户的输入不一定是标准的X+Y，里面可能在不同位置里面会有空格。为了统一方便处理，在解析之前，最好先把用户输入内的空格给去掉！\n对于string而言，去掉空格就很简单了，直接一个遍历搞定\n// 删除输入中的空格void rmSpace(std::string&amp; in)&#123;    std::string tmp;    for(auto e:in)    &#123;        if(e!=&#x27; &#x27;)        &#123;            tmp+=e;        &#125;    &#125;    in = tmp;&#125;\n\n完成的构造如下，这里涉及到C语言的函数strtok，要复习复习\n// 将用户的输入转成内部成员// 用户可能输入x+y，x+ y，x +y,x + y等等格式// 提前修改用户输入（主要还是去掉空格），提取出成员Request(std::string in,bool* status)    :_x(0),_y(0),_ops(&#x27; &#x27;)&#123;    rmSpace(in);    // 这里使用c的字符串，因为有strtok    char buf[1024];    // 打印n个字符，多的会被截断    snprintf(buf,sizeof(buf),&quot;%s&quot;,in.c_str());    char* left = strtok(buf,OPS);    if(!left)&#123;//找不到        *status = false;        return;    &#125;    char*right = strtok(nullptr,OPS);    if(!right)&#123;//找不到        *status = false;        return;    &#125;    // x+y, strtok会将+设置为\\0    char mid = in[strlen(left)];//截取出操作符    //这是在原字符串里面取出来，buf里面的这个位置被改成\\0了    _x = atoi(left);    _y = atoi(right);    _ops = mid;    *status=true;&#125;\n\n3.4.2 序列化解析出成员以后，我们要做的就是对成员进行序列化，将其按指定的位置摆成一个字符串。这里采用了输出型参数的方式来序列化字符串，也可以改成用返回值的方式来操作。\n这里需要注意的是，操作符本身就是char不能使用to_string来操作，会被转成ascii码，不符合我们的需求\n// 序列化 （入参应该是空的）void serialize(std::string&amp; out)&#123;    // x + y    out.clear(); // 序列化的入参是空的    out+= std::to_string(_x);    out+= SPACE;    out+= _ops;//操作符不能用tostring，会被转成ascii    out+= SPACE;    out+= std::to_string(_y);    // 不用添加分隔符（这是encode要干的事情）&#125;\n\n3.4.3 反序列化注意，思路不能搞错了。刚开始我认为request的反序列化应该针对的是服务器的返回值，实际并非如此！\n在客户端和服务端都需要使用request，客户端进行序列化，服务端对接收到的结果利用request进行反序列化。request只关注于对请求的处理，而不处理服务器的返回值。\n// 反序列化bool deserialize(const std::string &amp;in)&#123;    // x + y 需要取出x，y和操作符    size_t space1 = in.find(SPACE); //第一个空格    if(space1 == std::string::npos)    &#123;        return false;    &#125;    size_t space2 = in.rfind(SPACE); //第二个空格    if(space2 == std::string::npos)    &#123;        return false;    &#125;    // 两个空格都存在，开始取数据    std::string dataX = in.substr(0,space1);    std::string dataY = in.substr(space2+SPACE_LEN);//默认取到结尾    std::string op = in.substr(space1+SPACE_LEN,space2 -(space1+SPACE_LEN));    if(op.size()!=1)    &#123;        return false;//操作符长度有问题    &#125;    //没问题了，转内部成员    _x = atoi(dataX.c_str());    _y = atoi(dataY.c_str());    _ops = op[0];    return true;&#125;\n\n3.5 response3.5.1 构造返回值的构造比较简单，因为是服务器处理结果之后的操作；这些成员变量都设置为了公有，方便后续修改。\nResponse(int code=0,int result=0)    :_exitCode(code),_result(result)&#123;&#125;\n\n3.5.2 序列化// 入参是空的void serialize(std::string&amp; out)&#123;    // code ret    out.clear();    out+= std::to_string(_exitCode);    out+= SPACE;    out+= std::to_string(_result);    out+= CRLF;&#125;\n\n3.5.3 反序列化响应的反序列化只需要处理一个空格，相对来说较为简单\n// 反序列化bool deserialize(const std::string &amp;in)&#123;    // 只有一个空格    size_t space = in.find(SPACE);    if(space == std::string::npos)    &#123;        return false;    &#125;    std::string dataCode = in.substr(0,space);    std::string dataRes = in.substr(space+SPACE_LEN);    _exitCode = atoi(dataCode.c_str());    _result = atoi(dataRes.c_str());    return true;&#125;\n\n3.6 客户端之前写的客户端，并没有进行序列化操作，所以我们需要添加上序列化操作，并对服务器的返回值进行反序列化。这期间需要加上一系列判断；\n为了限制篇幅，下面只贴出来客户端的循环操作；详情参考注释。\n// 客户端发现的消息string message;while (1)&#123;    message.clear();//每次循环开始，都清空一下msg    cout &lt;&lt; &quot;请输入你的消息# &quot;;    getline(cin, message);//获取输入    // 如果客户端输入了quit，则退出    if (strcasecmp(message.c_str(), &quot;quit&quot;) == 0)        break;    // 向服务端发送消息    // 1.创建一个request（分离参数）    bool reqStatus = true;    Request req(message,&amp;reqStatus);    if(!reqStatus)&#123;        cout &lt;&lt; &quot;make req err!&quot; &lt;&lt; endl;        continue;    &#125;    // 2.序列化和编码    string package;    req.serialize(package);//序列化    package = encode(package,package.size());//编码    // 3.发送给服务器    ssize_t s = write(sock,package.c_str(), package.size());    if (s &gt; 0) // 写入成功    &#123;        // 4.获取服务器的结果        char buff[BUFFER_SIZE];        size_t s = read(sock, buff, sizeof(buff)-1);        if(s &gt; 0)&#123;            buff[s] = &#x27;\\0&#x27;;        &#125;        std::string echoPackage = buff;        Response resp;        size_t len = 0;        // 5.解码和反序列化        std::string tmp = decode(echoPackage, &amp;len);        if(len &gt; 0)//解码成功        &#123;            echoPackage = tmp;            if(resp.deserialize(echoPackage))//反序列化并判断            &#123;                printf(&quot;ECHO [exitcode: %d] %d\\n&quot;, resp._exitCode, resp._result);            &#125;            else            &#123;                cerr &lt;&lt; &quot;server echo deserialize err!&quot; &lt;&lt; endl;            &#125;        &#125;        else        &#123;            cerr &lt;&lt; &quot;server echo decode err!&quot; &lt;&lt; endl;        &#125;    &#125;    else if (s &lt;= 0) // 写入失败    &#123;        break;    &#125;&#125;\n\n3.7 服务端服务端无须修改代码，需要修改的是task消息队列中处理的任务；这就是之前做好封装的好处，因为只需要修改task里面传入的函数指针，就算是修改了服务器所进行的服务\n// 提供服务（通过线程池）Task t(conet,senderIP,senderPort,CaculateService);_tpool-&gt;push(t);\n\n如下是计算器服务的代码\nvoid CaculateService(int sockfd, const std::string &amp;clientIP, uint16_t clientPort)&#123;    assert(sockfd &gt;= 0);    assert(!clientIP.empty());    assert(clientPort &gt; 0);    std::string inbuf;    while(1)    &#123;        Request req;        char buf[BUFFER_SIZE];        // 1.读取客户端发送的信息        ssize_t s = read(sockfd, buf, sizeof(buf) - 1);        if (s == 0)        &#123;   // s == 0代表对方发送了空消息，视作客户端主动退出            logging(DEBUG, &quot;client quit: %s[%d]&quot;, clientIP.c_str(), clientPort);            break;        &#125;        else if(s&lt;0)        &#123;            // 出现了读取错误，打印日志后断开连接            logging(DEBUG, &quot;read err: %s[%d] = %s&quot;, clientIP.c_str(), clientPort, strerror(errno));            break;        &#125;        // 2.读取成功        buf[s] = &#x27;\\0&#x27;; // 手动添加字符串终止符        if (strcasecmp(buf, &quot;quit&quot;) == 0)        &#123; // 客户端主动退出            break;        &#125;        // 3.开始服务        inbuf = buf;        size_t packageLen = inbuf.size();        // 3.1.解码和反序列化客户端传来的消息        std::string package = decode(inbuf, &amp;packageLen);//解码        if(packageLen==0)&#123;            logging(DEBUG, &quot;decode err: %s[%d] status: %d&quot;, clientIP.c_str(), clientPort, packageLen);            continue;//报文不完整或有误        &#125;        logging(DEBUG,&quot;package: %s[%d] = %s&quot;,clientIP.c_str(), clientPort,package.c_str());        bool deStatus = req.deserialize(package); // 反序列化        if(deStatus) // 获取消息反序列化成功        &#123;            req.debug(); // 打印信息            // 3.2.获取结构化的相应            Response resp = Caculater(req);            // 3.3.序列化和编码响应            std::string echoStr;            resp.serialize(echoStr);            echoStr = encode(echoStr,echoStr.size());            // 3.4.写入，发送返回值给客户端            write(sockfd, echoStr.c_str(), echoStr.size());        &#125;        else // 客户端消息反序列化失败        &#123;            logging(DEBUG, &quot;deserialize err: %s[%d] status: %d&quot;, clientIP.c_str(), clientPort, deStatus);            continue;        &#125;    &#125;    close(sockfd);    logging(DEBUG, &quot;server quit: %s[%d] %d&quot;,clientIP.c_str(), clientPort, sockfd);&#125;\n\n其中有一个计算函数，比较简单，通过switch case语句，计算结果，并判断操作数是否有问题。\nResponse Caculater(const Request&amp; req)&#123;    Response resp;//构造函数中已经指定了exitcode为0    switch (req._ops)    &#123;    case &#x27;+&#x27;:        resp._result = req._x + req._y;        break;    case &#x27;-&#x27;:        resp._result = req._x - req._y;        break;    case &#x27;*&#x27;:        resp._result = req._x * req._y;        break;    case &#x27;%&#x27;:    &#123;        if(req._y == 0)        &#123;            resp._exitCode = -1;//取模错误            break;        &#125;        resp._result = req._x % req._y;//取模是可以操作负数的        break;    &#125;    case &#x27;/&#x27;:    &#123;        if(req._y == 0)        &#123;            resp._exitCode = -2;//除0错误            break;        &#125;        resp._result = req._x / req._y;//取模是可以操作负数的        break;    &#125;    default:        resp._exitCode = -3;//操作符非法        break;    &#125;    return resp;&#125;\n\n这样，我们的序列化处理就成功了！测试一下吧\n4.测试运行服务器，可以看到，服务器能成功处理客户端的计算，并返回结果\n\n输入quit，服务器会打印信息，并退出服务\n\n","categories":["玩上Linux"],"tags":["Linux","网络"]},{"title":"【网络】http(s)协议 | content-length详解 | 转载","url":"/posts/1805390619/","content":"本文通过一个线上实例，详细介绍http协议中的content-length字段。\n\n\n前言http协议是互联网中最重要的协议之一，虽然看上去很简单，但是实际中经常遇到问题，我们就已经遇到好几次了。有长连接相关的，有报文解析相关的。对http协议不能一知半解，必须透彻理解才行。\n本文通过一个线上实例，详细介绍http协议中的content-length字段。\n问题我们的手机App在做更新时会从服务器上下载的一些资源，一般都是一些小文件，更新的代码差不多是下面这样的：\nstatic void update() throws IOException &#123;    URL url = new URL(&quot;http://172.16.59.129:8000/update/test.so&quot;);    HttpURLConnection conn = (HttpURLConnection) url.openConnection();    if(conn.getResponseCode() == 200) &#123;        int totalLength = conn.getContentLength();\tBufferedInputStream in = new BufferedInputStream(conn.getInputStream());\tbyte[] buffer = new byte[512];\tint readLength = 0;\tint length = 0;\twhile((length=in.read(buffer)) != -1) &#123;\t\treadLength += length;\t\t//进度条\t\tSystem.out.println(((float)readLength) /((float)(totalLength)));\t&#125;    &#125;&#125;\n\n比如上面的代码更新一个so文件，先通过content-length获取文件的总大小，然后读Stream，每读一段，就计算出当前读的总大小，除以content-length，用来显示进度条。\n结果weblogic从10升级到12后，content-length一直返回-1，这样就不能显示进度条了，但是文件流还能正常读。把weblogic重启了，一开始还能返回content-length，一会又是-1了。\n原因分析Http协议的请求报文和回复报文都有header和body，body就是你要获取的资源，例如一个html页面，一个jpeg图片，而header是用来做某些约定的。例如客户端与服务端商定一些传输格式，客户端先获取头部，得知一些格式信息，然后才开始读取body。\n\n客户端： Accept-Encoding:gzip （给我压缩一下，我用的是流量，先下载下来我再慢慢解压吧）\n服务端1：Content-Encoding:null(没有Content-Encoding头。 我不给压缩，CPU没空，你爱要不要）\n服务端2：Content-Encoding:gzip (给你节省流量，压缩一下）\n\n\n客户端：Connection: keep-alive (大哥，咱好不容易建了个TCP连接，下次接着用）\n服务端1: Connection: keep-alive （都不容易，接着用）\n服务端2: Connection: close (谁跟你接着用，我们这个TCP是一次性的，下次再找我还得重新连)\n\nhttp协议没有三次握手，一般客户端向服务端请求资源时，以服务端为准。还有一些header并没有协商的过程，而是服务端直接告诉客户端按什么来。例如上述的Content-Length，是服务端告诉客户端body的大小有多大。但是！服务端并不一定能准确的提前告诉你body有多大。服务端要先写header，再写body，如果要在header里把body大小写进去，就得提前知道body大小。如果这个body是动态生成的，服务端先生成完，再开始写header，这样需要很多额外的开销，所以header里不一定有content-length。\n那客户端怎么知道body的大小呢？服务器有三种方式告诉你。\n1.服务器已经知道资源大小，通过content-length这个header告诉你。\nContent-Length:1076(body的大小是1076B，你读取1076B就可以完成任务了）Transfer-Encoding: null\n\n2.服务器没法提前知道资源的大小，或者不愿意花费资源提前计算资源大小，就会把http回复报文中加一个header叫Transfer-Encoding:chunked，就是分块传输的意思。每一块都使用固定的格式，前边是块的大小，后面是数据，然后最后一块大小是0。这样客户端解析的时候就需要注意去掉一些无用的字段。\nContent-Length:nullTransfer-Encoding:chunked (接下来的body我要一块一块的传，每一块开始是这一块的大小，等我传到大小为0的块时，就没了）\n\n3.服务器不知道资源的大小，同时也不支持chunked的传输模式，那么就既没有content-length头，也没有transfer-encoding头，这种情况下必须使用短连接，以连接结束来标示数据传输结束，传输结束就能知道大小了。这时候服务器返回的header里Connection一定是close。\nContent-Length:null Transfer-Encoding:null Connection:close(我不知道大小，我也用不了chunked，啥时候我关了tcp连接，就说明传输结束了）\n\n实验我通过nginx在虚拟机里做实验，默认nginx是支持chunked模式的，可以关掉。\n使用的代码如下，可能会调整参数。\nstatic void update() throws IOException &#123;    URL url = new URL(&quot;http://172.16.59.129:8000/update/test.so&quot;);    HttpURLConnection conn = (HttpURLConnection) url.openConnection();    //conn.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);    //conn.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;);    conn.connect();    if(conn.getResponseCode() == 200) &#123;        System.out.println(conn.getHeaderFields().keySet());        System.out.println(conn.getHeaderField(&quot;transfer-encoding&quot;));        System.out.println(conn.getHeaderField(&quot;Content-Length&quot;));        System.out.println(conn.getHeaderField(&quot;Content-Encoding&quot;));        System.out.println(conn.getHeaderField(&quot;Connection&quot;));    &#125;&#125;\n\n1.nginx在开启chunked_transfer_encoding的时候(1) 在reqeust header里不使用gzip，也就是不加accept-encoding: gzip\n\n\n\ntest.so文件大小\n结果\n\n\n\n100B\n能正常返回content-length,没有transfer-encoding头\n\n\n69M\n能正常返回content-length,没有transfer-encoding头\n\n\n3072M\n能正常返回content-length,没有transfer-encoding头\n\n\n可以发现nginx不管资源多大，如果客户端不接受gzip的压缩格式，就不会使用chunked模式，而且跟是否使用短连接没关系。\n(2)在request header里加入gzip，accepting-encoding: gzip\n\n\n\ntest.so文件大小\n结果\n\n\n\n100B\n没有content-length,transfer-encoding&#x3D;trunked\n\n\n69M\n没有content-length,transfer-encoding&#x3D;trunked\n\n\n3072M\n没有content-length,transfer-encoding&#x3D;trunked\n\n\n可以看到nginx在开启chunked_transfer_encoding，并且客户端接受gzip的时候，会使用chunked模式，nginx开启gzip后不会计算资源的大小，直接用chunked模式。\n2.nginx关闭chunked_transfer_encoding(1) 在reqeust header里不使用gzip，也就是不加accept-encoding:gzip\n\n\n\ntest.so文件大小\n结果\n\n\n\n100B\n能正常返回content-length,没有transfer-encoding头\n\n\n69M\n能正常返回content-length,没有transfer-encoding头\n\n\n3072M\n能正常返回content-length,没有transfer-encoding头\n\n\n因为能很容易的知道文件大小，所以nginx还是能返回content-length。\n(2)在request header里加入gzip，accepting-encoding:gzip\n\n\n\ntest.so文件大小\n结果\n\n\n\n100B\n没有content-length和transfer-encoding头，不论客户端connection为keep-alive还是close，服务端返回的connection头都是close\n\n\n69M\n没有content-length和transfer-encoding头，不论客户端connection为keep-alive还是close，服务端返回的connection头都是close\n\n\n3072M\n没有content-length和transfer-encoding头，不论客户端connection为keep-alive还是close，服务端返回的connection头都是close\n\n\n这就是上面说的第三种情况，不知道大小，也不支持trunked，那就必须使用短连接来标示结束。\n问题解决方案咨询了中间件组的同事，以前也遇到类似的问题，因为升级了Weblogic导致客户端解析XML出错，因为使用了chunked模式，中间有一些格式化的字符，而客户端解析的代码并没有考虑chunked模式的解析，导致解析出错。\n因为我们客户端必须用content-length展示进度，因此不能用chunked模式，Weblogic可以把chunked模式关闭。用下面的方法：\n#!java weblogic.WLSTconnect(&#x27;username’,&#x27;password&#x27;, &#x27;t3://localhost:7001&#x27;)edit()startEdit()cd(&quot;Servers/AdminServer/WebServer/AdminServer&quot;)cmo.setChunkedTransferDisabled(true)save()activate()exit()\n\n改了之后，确实不返回chunked了，但是也没有content-length，因为Weblogic就是不提前获取文件大小，而是强制加了connection:close，也就是前边说的第三种，通过连接结束标识数据结束。最后只能把这些资源放倒apache里了。\n总结一个好的http客户端，必须充分实现协议，不然就可能出问题，浏览器对于服务端可能产生的各种情况都很好的做了处理，但是自己实现http协议的解析时一定得注意考虑多种情况。\n文章作者：牛立新原文链接：https://www.cnblogs.com/nxlhero/p/11670942.html\n","categories":["玩上Linux"],"tags":["网络","nginx","http"]},{"title":"【网络】自定义协议 | 序列化和反序列化 | Jsoncpp","url":"/posts/4060787526/","content":"以tcpServer的计算器服务为例，实现用jsoncpp来进行序列化和反序列化\n\n\n\n阅读本文之前，请先阅读 自定义协议 | 序列化和反序列化 | 以tcpServer为例\n\n1.安装jsoncpp我所用的系统是centos7.6，先用下面的命令查找相关的包\nsudo yum list | grep jsoncpp-devel\n\n显示出来的包如下\nRepository epel is listed more than once in the configurationjsoncpp-devel.x86_64                0.10.5-2.el7           @epel \n\n随后安装这个包\nsudo yum install jsoncpp\n\n不知道为什么，安装jsoncpp-devel.x86_64显示找不到相关包\n或者采用下面的两个命令\nsudo yum install epel-releasesudo yum install jsoncpp-devel\n\n如果执行完毕后显示找不到jsoncpp，尝试重新安装epel-release\n\n刚开始我显示epel已经安装，但是找不到jsoncpp这个包，我在重新安装了epel后就能正常安装了\nsudo yum rm epel-releasesudo yum install epel-releasesudo yum install jsoncpp-devel\n\n如下图，正常查找到并安装完毕\n\n在centos8下，安装完毕后路径如下\n$ ls /usr/include/jsonallocator.h  assertions.h  autolink.h  config.h  features.h  forwards.h  json.h  reader.h  value.h  version.h  writer.h\n\n1.1 什么是json？json是一个kv键值对的序列化方式，每一个key都对应了一个value\n&#123;\t&quot;data&quot;: &quot;value&quot;&#125;\n\n这就有点类似c++中的map，不过json能做的更多\n&#123;\t&quot;data1&quot;: &quot;value&quot;,\t&quot;data2&quot;: &#123;\t\t&quot;key1&quot;:&quot;value1&quot;,\t\t&quot;key2&quot;:&quot;value2&quot;,         &quot;key3&quot;:0,         &quot;key4&quot;:true\t&#125;&#125;\n\njson可以在里面嵌套添加更多的内容，不管是字符串还是整形，还能是bool类型的true/false；\n因为json对反序列化序列化的控制很是不错，可读性也很好，所以被广泛使用！\n相比于自己写一个序列化方式，直接用别人的轮子，也不错👻\n类似的序列化框架还有xml\n2.代码示例2.1 序列化相比我们自己写的序列化方式，json的使用简单多了\nvoid serialize(std::string&amp; out)&#123;     //使用jsoncpp的代码    Json::Value root;    root[&quot;x&quot;] = _x;    root[&quot;y&quot;] = _y;    root[&quot;op&quot;] = _ops;    Json::FastWriter fw; // 这个是写成一行，对于计算机来说处理的负担小    // Json::StyledWriter fw; // 这个会进行格式化，更好看（但是内容没差距）    out = fw.write(root);&#125;\n\n对于fw.write(root)，其返回值是一个string，也方便我们接收\n\n其中FastWriter和StyledWriter有一点区别，如下\n//FastWriter&#123;&quot;data&quot;: &quot;value&quot;&#125;//StyledWriter&#123;\t&quot;data&quot;: &quot;value&quot;&#125;\n\n简单来说，StyledWriter会对我们的kv键值对进行格式化，更方便人类的阅读。而FastWriter是直接写成一整行，在传输的时候会方便一点（因为不需要\\n）\n2.2 反序列化反序列化需要一个Reader来读取字符串，并将其内容根据键值隐射给成员变量\nbool deserialize(const std::string &amp;in)&#123;    //json    Json::Value root;    Json::Reader rd;    rd.parse(in, root);    _x = root[&quot;x&quot;].asInt();    _y = root[&quot;y&quot;].asInt();    _ops = root[&quot;op&quot;].asInt();&#125;\n\n3.测试因为jsoncpp是一个第三方库，我们链接的时候需要加上命令-ljsoncpp\ntcpServer:tcpServer.cpp\tg++ -o $@ $^ -std=c++11 -lpthread -ljsoncpp\n\n发送消息后，可以看到，json帮我们格式化为如下形式的字符串\n&#123;&quot;op&quot;:43,&quot;x&quot;:1,&quot;y&quot;:200&#125;&#123;&quot;op&quot;:43,&quot;x&quot;:333,&quot;y&quot;:234&#125;\n\n\n4.gcc给予宏定义为了方便对序列化采用的方式进行控制，这里我使用了预处理指令ifdef/endif来进行判断，只要我们在文件头定义了MYPROTOCOL，这里就会采用我们自己的写的序列化方式，否则采用json\n#define MYPROTOCOL 1  //如果define了这个，那就使用自己的代码\n\n\n4.1 命令行但是在文件里面修改define还是不太方便，我们可以直接采用gcc的命令行参数的方式，进行define的插入（这么做之前，要先删除文件中对MYPROTOCOL的define）\ng++ -DMYPROTOCOL tcpServer.cpp -o tcpServer -lpthread -ljsoncppg++ -DMYPROTOCOL tcpClient.cpp -o tcpClient -lpthread -ljsoncpp\n\n可以看到，不加编译指令编译出来的服务器，采用的是json的方式来序列化\n\n添加了之后，就是用我们自己写的序列化方式来序列化了\n\n4.2 makefile因此，我们可以修改makefile来实现这一点\n.PHONY:allall:tcpClient tcpServerMYSELF=-DMYPROTOCOLtcpClient: tcpClient.cpp\tg++ $(MYSELF) -o $@ $^ -std=c++11 -lpthread -ljsoncpptcpServer:tcpServer.cpp\tg++ $(MYSELF) -o $@ $^ -std=c++11 -lpthread -ljsoncpp.PHONY:cleanclean:\trm -f tcpClient tcpServer\n\n当我们需要用自己协议的时候，就在最前面加上\nMYSELF=-DMYPROTOCOL\n\n否则直接删除这个定义，或者注释掉后面的内容，就能采用jsoncpp\nMYSELF=#-DMYPROTOCOL\n\n这样就方便一些了\n\n","categories":["玩上Linux"],"tags":["Linux","网络"]},{"title":"【网络】http(s)协议 | 介绍","url":"/posts/2885791654/","content":"已经学习过自己定制一个协议了，现在就来看看当下广泛使用的http协议吧\n\n\n1.介绍\n超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。\n\nhttp和https是当下最通用的协议之一，我们访问的大部分网页用的都是这个协议；\nhttps://www.bilibili.com/\n\n这两个协议主要的差别，那就是http是用明文传输数据的，我们的数据在互联网裸奔，可能有安全问题；相比之下，https传输数据的过程会对数据进行加密，但这也不代表https是完全安全的。\n1.1 url要认识这两个协议，我们要从url的认识开始；\nHTTP(S) 不允许使用用户名或密码，一个合法的 HTTP(S) URL 格式如下：\nhttp(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;\n\n\n开头为协议名：http 或 https 协议； \n&lt;host&gt;：主机名。一个 URL 中，既可以使用域名也可以使用 IP 表示主机地址\n&lt;port&gt;：端口。主机名和端口之间使用冒号分隔。端口是可选的，如果省略将采用默认端口，http 默认端口是 80，https 默认端口 443；\n&lt;path&gt;：资源路径。资源在网络主机上的路径，路径也是可选的，缺省访问默认资源； \n&lt;query&gt;：查询参数。格式为 key&#x3D;value，多个参数使用 &amp; 分隔；参数也是可选的； \n&lt;frag&gt;：片段。从 # 开始到最后，一般用于定位到资源内的一个片段，比如文档的一个章节；片段也是可选的。\n\n1.1.1 栗子 ①接下来举一个具体的例子\nhttps://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile\n\n如上是我的个人博客中的一篇文章\n\n协议是https\n域名是blog.musnow.top，对应的就是&lt;host&gt;:&lt;port&gt;；这里隐藏了端口，会在下面说明。\n/2022/08/07/note_linux/6gdb_g++_make_vim/这一长串都是文件的路径，其标示了文件在服务器上存放的位置\n这个url内没有带&lt;query&gt;参数\n#4-make-x2F-makefile对应的是&lt;frag&gt;片段，标识了我当前浏览的位置\n\n当你把这个url粘贴道浏览器，其会直接跳转到对应的标题位置，而不是这篇文章的页首；这就是&lt;frag&gt;片段的作用\n\n1.1.2 栗子 ②https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=test\n\n当我们在百度搜索单词test的时候，百度的url中就会出现&lt;query&gt;参数；\n其中?是参数的开头，后续的一串以&amp;分隔的kv键值对，就是参数的内容。在这里面我们能看到word=test，我们查询的单词test就在这个参数后；\n我们的搜索访问，就是将这些参数传送给服务器，再由百度的服务器返回搜素结果的。\n1.2 域名和端口隐藏但我们日常访问的网页中，很少见到过ip:端口的形式，而大多是用域名为我们提供服务的\nhttps://www.bilibili.com/\n\n这并不代表其背后不需要端口号。而是因为如果我们的访问不指定端口的时候，http(s)协议会采用默认端口号80或443，从而实现隐藏端口号提供服务\n\nhttp 默认端口是 80，https 默认端口 443\n\n毕竟对于用户而言，记住一个域名已经不容易了，还要记住你的服务是在哪一个端口，那就更难了；\n而域名也不是凭空给我们提供服务的，每一个域名都需要绑定一个具体的公网ip（域名解析），才能为用户提供服务。在域名的背后，都是一个ip，每一个ip也就是一台服务器。\n域名的作用，就是来隐藏掉ip这个无规律的长数字，方便用户访问；\n\n你觉得是记住baidu.com容易，还是记住114.514.77.58容易呢？\n\n在命令行使用ping工具，我们能知道一个网站服务器的ip是什么\nping www.bilibili.com\n\n比如我们ping一下b站的域名，可以看到其公网ip是183.131.147.29\n正在 Ping a.w.bilicdn1.com [183.131.147.29] 具有 32 字节的数据:来自 183.131.147.29 的回复: 字节=32 时间=10ms TTL=55来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55183.131.147.29 的 Ping 统计信息:    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 10ms，最长 = 12ms，平均 = 11ms\n\n1.3 ip:端口我们可以用ip:端口来访问自己的服务（以下ip纯属虚构，如有撞车，纯属巧合）\n114.514.77.58:8080\n\n当我们把这个粘贴道浏览器，再复制粘贴出来的时候，我们会发现前面多了一个http\nhttp://114.514.77.58:8080\n\n这是因为当我们使用ip访问一个服务的时候，浏览器会默认采用http的协议去访问，所以在前面加了一个我们看不到的http://\n1.4 协议作用http协议的作用，就是向服务器申请特定的资源，再将资源拉取到本地进行展示or使用。\n资源都是存在我们的服务器上的，当用户请求的时候，服务器必须要知道资源的路径，将其read打开读取，再write写给我们的客户端。\n/2022/08/07/note_linux/6gdb_g++_make_vim/\n\n所以http的请求中才会带上资源的路径，这是方便服务器进行资源文件的读取；同时，文件的路径也是对一个文件的唯一标识，在告诉服务器文件路径的同时，也保证了我们请求的文件的唯一性，不会出现二义性；\n\n这时候又会出现一个问题，当我们访问网站的根目录的时候，没有提供文件的路径呀，那这时候，访问的什么文件呢？\nhttps://www.baidu.com/\n\n实际上，我们访问的是服务器根目录的index.html文件\nhttps://www.baidu.com/https://www.baidu.com/index.html\n\n你可以试着打开这两个链接，其出现的页面是完全一致的；\n\n类似于端口号隐藏，http协议也确定了当下使用的网页文件的命名为index.html，当我们访问一个网站的时候，就会默认访问根目录下的index.html文件（既然是默认的，那就可以直接隐藏）如果这个文件不存在，那就不会渲染出我们看到的网页！\nindex.html是用前端语言编写的网页代码\n\n同理，当我们访问博客的时候，读取道的也不是目录，而是目录下的index.html文件\nhttps://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/\n\n\n我的博客使用的是hexo框架，其网页的源路径在github上开源了，可以帮助你理解url中的文件路径。\n当前你看到的文件目录，就是博客服务的根目录。访问的博客首页，就是根目录下的index.html\n\n用作示例的linux工具使用博客，也可以根据它的路径，找到index.html文件\n/2022/08/07/note_linux/6gdb_g++_make_vim/\n\n\n这便是http协议url中文件路径的作用！\n这里的/根目录是服务端设置的，并不一定是（大概率不是）服务端linux服务器的根目录\n\nhexo博客已更新为绝对数字路径，本文中演示的路径已经无法访问\n\n1.5 编码解码在url中，还会对一些特殊字符进行编解码，比如中文，和一些特殊的符号\nhttps://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile\n\n比如在作为示例的url中，这里出现了x2F，而原文中是4.make/makefile;这里的编码就是为了避免make/makefile被识别成路径的标识符，从而出现错误。\nhttps://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=%E4%BD%A0%E5%A5%BD\n\n当url路径中有中文的时候，也会被转码成特定的格式\n\n我们在浏览器上看到的依旧是中文，这是因为浏览器这段帮我们进行了解码\n\n将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY格式\n\n2.http协议请求格式了解了http协议中的url网址，现在就可以进一步了解http协议的报头和报文了;\n一个http request/response的基本格式如下\n\n在请求中，客户端会提供自己的请求方法（GET&#x2F;POST&#x2F;PUT等等），并提供url来标识自己需要的文件路径；这个url可能是短链接（截取根目录之后的部分），也有可能是完整的链接。\n随后，就会跟上一大堆的请求参数，注意，这里的请求参数并不是url中的&lt;query&gt;参数，而是http协议自身的请求参数。每一个请求参数都用了\\r\\n作为分隔，这和我们写的自定义协议中采用\\t进行分割是相同的原理！\n这几个部分中，请求的正文可以不带（为空）\n2.1 读取多长？为了让协议读取的时候，能够知道什么时候读取完毕了报头，http协议提供了一个\\r\\n的空行，读取道这个空行，就代表报头读取完毕了，剩下的内容都是报文。\n而为了标识报文的长度，http协议会在发送的时候提供一个参数content-length，用于标识报文的长度。在读取完毕报头后，肯定是读取到了这个content-length参数的，也就知道后续应该继续读取多长，才能读完整个协议字段！\n关于这部分的介绍，可以查看另外一篇博客 http协议content-length详解\n2.2 响应的状态码和我们进程的退出状态一样，http也表明了一部分响应的状态码，其中我们日常最常见到的，是404/403这两个状态码\n\nhttp状态码-百度百科\n\n状态码就是标识服务器提供的服务状态，告诉客户端它的请求是否成功了。如果状态码是200，代表请求是成功的。其余状态码会有各自的使用场景，比如404状态码，代表请求的资源不存在，所以才叫 404 not found!\n3.实例完整代码详见 Gitee\n3.1 前端页面由于本人并没有学习过前端语法，这里采用 菜鸟教程 提供的前端示例代码来演示\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n我们日常所访问的网页都是这样的代码，经由浏览器进行渲染，再展示出来\n3.2 服务端代码由于http是基于tcp的，这里直接把之前写的tcpServer搬过来就能用！具体的代码解析请看注释，想必说的是很清楚的\n#define CRLF &quot;\\r\\n&quot;#define CRLF_LEN strlen(CRLF)#define SPACE &quot; &quot;#define SPACE_LEN strlen(SPACE)#define HOME_PAGE &quot;index.html&quot; // 首页文件#define ROOT_PATH &quot;web&quot; // 网址根目录地址// 获取http请求中的路径string getPath(string http_request)&#123;    size_t pos = http_request.find(CRLF);//找到第一行的分隔符    if(pos == string::npos)         return &quot;&quot;;    string request_line = http_request.substr(0, pos);//取出第一行    //请求的第一行：GET /a/b/c http/1.0    size_t first = request_line.find(SPACE);// 找到第一个空格    if(pos == string::npos)         return &quot;&quot;;    size_t second = request_line.rfind(SPACE); // 从后往前找空格    if(pos == string::npos)         return &quot;&quot;;    // 找到两个空格了，两个空格之间的就是请求的路径    string path = request_line.substr(first+SPACE_LEN, second - (first+SPACE_LEN));    // 对path进行判断，如果path是以/结尾的，则在path中追加index.html文件名    if(path[path.size()-1] == &#x27;/&#x27;) &#123;        path += HOME_PAGE; //加上被隐藏的index.html文件名    &#125;    return path;&#125;// 读取文件string readFile(const string &amp;recource)&#123;    ifstream in(recource, ios::binary);    if(!in.is_open()) //文件打开失败    &#123;        return &quot;404&quot;;    &#125;    // 内容    string content;    string line;    while(getline(in, line))    &#123;        content += line;    &#125;    in.close();    return content;&#125;void handlerHttpRequest(int sock)&#123;    cout &lt;&lt; &quot;###########start#############&quot; &lt;&lt; endl;//打印一个分隔线    char buffer[10240];    ssize_t s = read(sock, buffer, sizeof(buffer));    if(s &gt; 0)&#123;        cout &lt;&lt; buffer &lt;&lt; endl;        cout &lt;&lt; &quot;###########end############&quot; &lt;&lt; endl;    &#125;    string path = getPath(buffer);    // 假设用户请求的是 /a/b 路径    // 那么服务端处理的时候，就需要添加根目录位置和默认的文件名    // &lt;root&gt;/a/b/index.html    // 在本次用例中，根目录为 ./web文件夹，所以完整的文件路径应该是    // ./web/a/b/index.html    string resources = ROOT_PATH; // 根目录路径    resources += path; // 文件路径    logging(DEBUG,&quot;[sockfd: %d] filePath: %s&quot;,sock,resources.c_str()); // 打印用作debug    string html = readFile(resources);// 打开文件    // 开始响应    string response = &quot;HTTP/1.0 200 OK\\r\\n&quot;;    //如果readFile返回的是404，代表文件路径不存在    if(strcmp(html.c_str(),&quot;404&quot;)==0)    &#123;        response = &quot;HTTP/1.0 404 NOT FOUND\\r\\n&quot;;    &#125;    // 追加后续字段    response += &quot;Content-Type: text/html\\r\\n&quot;;    response += (&quot;Content-Length: &quot; + to_string(html.size()) + &quot;\\r\\n&quot;);    response += &quot;\\r\\n&quot;;    response += html;    // 发送给用户    send(sock, response.c_str(), response.size(), 0);&#125;\n\n3.3 测试启动服务器之前，请先打开你的云服务器防火墙中的对应端口；这里我绑定的是端口10000，在浏览器中用ip:端口的方式可以正常访问！\n\n这里标识的不安全是因为我们没有采用带加密的https协议，这不是当下需要考虑的问题。不管他就可以了。\n按F12打开开发者页面，可以看到下方出现了完整的html代码，我们成功提供了服务！\n\n3.4 后端打印的报文在服务器后端，我们看到其打印出来了一个基本的http请求，和上面说明的格式是一样的。这里简单的进行一部分说明：\n\nGET：请求方式为获取数据\n/：请求的是根路径\nHTTP/1.1：使用的http协议版本\nConnection：代表我们和服务器的链接方式，keep-alive代表保持连接\nUser-Agent：客户端信息，可以看到是windows系统、Chrome内核的浏览器（我是用的是edge浏览器）\nAccept: 支持接收的信息类型\nAceept-Encoding: 对信息进行压缩\nAccept-Language：支持的语言\nCookie：身份信息，后面会详细介绍\n\n其中出现了一个空行，代表报文结束；\n\n往下滑，会发现浏览器还发出了第二个请求，路径是/favicon.ico，这是默认的站点头像文件的命名。因为我们的html文件中没有写明站点头像的路径，所以浏览器就尝试请求默认的头像文件\n但是，当前我们的站点根目录web下并没有该文件，应该返回一个404状态码。\n\n请求中出现了一个新的参数Referer，代表是从当前网页请求头像的。相比之下，请求网页的报文中没有Referer参数\n\n\n此时可以随便找个图片做头像，看看能不能加载出来；为了方便，我随便找了一张纯绿色的图片，并将其在线转换为ico，放入了站点的根目录。\n重启服务器进程，刷新浏览器再次请求，可以看到成功出现了站点的头像；\n\n3.5 常见参数表\n4.请求方法一般我们获取一个网页，用的都是GET方法。接下来用一个带按钮的表单创建请求，尝试向服务端发送&lt;query&gt;参数\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;form action=&quot;/a/index.html&quot; method=&quot;get&quot;&gt;    Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;    Password: &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.1 GET在method里面，我们指定了get方法，此时\n&lt;form action=&quot;/a/index.html&quot; method=&quot;get&quot;&gt;    Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;    Password: &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;\n\n此时页面中出现了两个输入框，供我们输入密码，且密码会显示为****而不是明文\n\n点击按钮，会跳转到一个404页面，这是因为我们的a/index.html路径并不支持参数请求，所以发送了404错误码\n\n不过这不重要，我们看看后端打印的内容。其中参数是追加到url中，以明文传输过来的；正文部分为空，并没有携带参数\n\n4.2 POST将请求方法改成post，再次尝试\n&lt;form action=&quot;/a/index.html&quot; method=&quot;post&quot;&gt;    Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;    Password: &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;\n\n这时候能正常显示出a/index.html页面，url中不再带有参数\n\n此时查看后端中的信息，能看到请求方法变为POST，参数出现在了正文部分，而不是url中\n\n4.3 GET&#x2F;POST区别这也是GET和POST方法的区别之一：\n\nGET方法通过url传参\nPOST方法会将url参数提取出来，拼接到正文部分\n\n由此能推出二者的安全性区别\n\nGET方法相对不安全，因为参数直接以明文贴在了url上\nPOST方法以正文传参，使用https协议的时候能进行加密，相对较安全\n\n4.4 更多方法http请求还支持更多方法，如下\n\n5.状态码5.1 状态码表下面是一个响应状态码的总表\n\n5.2 404&#x2F;403状态码我们能看到404和403都是客户端状态码，为什么说是客户端错误呢？这是因为你向服务器请求了一个服务器没有的资源，这个问题不应该是服务器的问题。\n这就好比你去西瓜摊买肉，人家压根不卖肉。问题出在你身上，你不应该找西瓜摊老板买肉。所以404状态码，应该是客户端的问题！\n而403状态码的含义是403 forbidden，服务器拒绝了你的请求（你没有权限访问）这也是客户端的问题。你不能去超市买东西，然后问老板能不能让你看看老板的钱罐子。老板肯定不给你看啊！所以才会告诉你403，不给你访问。\n5.3 5xx状态码什么时候会出现服务器错误的5xx状态码呢？\n当你请求一个服务，服务端需要处理之后给你返回结果。此时服务器在处理过程中，可能因为程序有bug提前退出，这时候就应该给客户端发送一个5xx状态码，标识服务器在处理你的请求的过程中，出现了错误，无法返回结果。\n5.4 301&#x2F;302重定向关于3开头的状态码，主要谈谈下面这两个\n301 永久重定向302 临时重定向\n\n为何一个是永久，一个是临时呢？\n在http进行响应的时候，服务端可以发送一个location参数，发送一个新的url给客户端；我们的浏览器在收到这个参数后，会自动打开对应的页面\nLocation: https://www.baidu.com/\n\n我们可以用上面的代码来测试一下\n// 尝试进行302重定向string response = &quot;HTTP/1.1 302 Temporarily moved\\r\\n&quot;;response+= &quot;Location: https://www.baidu.com/\\r\\n&quot;;response+= &quot;\\r\\n&quot;;// 发送给用户send(sock, response.c_str(), response.size(), 0);\n\n此时访问我们自己的IP:端口，会跳转到百度的页面。这就是重定向的作用\n\n\n那临时重定向和永久重定向有什么区别呢?\n\n假如我设立了一个公开站点，域名是test.com，这几年一直提供服务，积累了一部分的用户。过了一会，我不想要这个域名了，想换一个test.cn；可用户已经有那么多，大家都只记得你的test.com，如果直接更换域名，就会导致用户无法访问test.com，以为你跑路了，就放弃使用你的网页。\n这样的结果显而易见：严重的客户流失！\n所以，为了避免这个问题，我可以先将服务迁移到test.cn新域名，在旧域名test.com中设置一个301重定向到test.cn，告诉用户我换新域名了。这样持续一段时间后，等到test.com的使用者不多了，就可以考虑彻底取消test.com的解析，关停此域名了。\n在上面的场景中，我是需要更换域名，是永久更换。我们就应该把状态码设置为301，告诉客户端这个域名将被永久重定向到另外一个域名上\n\n另外的情况是，我有一个example.com域名，我的服务需要进行维护；此时就将example.com重定向到另外一个域名example.cn，指向另外一个服务器，让这个服务器临时提供服务。\n服务维护完毕后，就将重定向取消，继续使用当前的服务器。\n这个场景中，重定向只是维护期间的一个临时策略，所以状态码设置成302，告诉客户端我只是临时进行重定向，我还会回来的。\n6.cookie&#x2F;session日常生活中，当我们在一个web页面中登录了（如github&#x2F;gitee&#x2F;csdn）这个网页在很长一段时间内都会保持登录，直到超时亦或者是出现了异地访问。\n假如你现在有个网页，但是每次用户访问的时候，都需要重新输入用户名和密码，刚刚输入过了，换一个页面又不行了。这样一来，用户还会想用你这个服务吗？\n为了避免此类问题，http协议就需要引入其他的参数，来维持用户的登录会话。cookie&#x2F;session便是因此而来的。\n6.1 set cookie服务端可以在响应头中带上Set-Cookie字段，给客户端设置上cookie\nresponse += &quot;Set-Cookie: This is my cookie test\\r\\n&quot;;\n\n打开f12开发者界面，能在其中看到我们设置的cookie\n\n再次刷新网页，可以看到在之后的请求中，浏览器都会发送一次服务器设置的cookie。这样服务端在收到cookie后，就能解析到自己设置的cookie，确定了指定的用户\n\n在服务器端也能看到这个字段\n\n6.1.1 cookie path对于cookie来说，其还有一个路径的配置项。见下图，我在实现我的视频点播系统的时候，在/usr/login处直接用了如下header来set-cookie\nrsp.set_header(&quot;Set-Cookie&quot;,&quot;sid=123456&quot;);// 如上语句是httplib，等价于// Set-Cookie: sid=123456\\r\\n\n\n\n这就导致我对我的视频点播其他界面中的操作并没有携带上我自己set的这个cookie，也就没有办法实现后续的seesion识别（这里我写死了是因为还在初始测试阶段）\n我们要做的就是在cookie后面携带一个path，来告诉浏览器这个cookie应该是全局的\nSet-Cookie: sid=123456; path=/\n\n这样才能实现后续整个网站的请求都会带上这个cookie，否则只有请求 /usr开头的路径才能带上这个cookie\n\n如上图，这样设置了后，cookie path已经是/ 代表根路径了\n\n6.2 什么是cookie所谓cookie，其实就是浏览器帮我们存取了一定的身份信息在本地（内存or磁盘）\n下一次打开特定的网页的时候，就能显示对应的身份信息（不一定是你的账户密码），并告诉服务器，服务器就识别到了你当前的用户，并为你保持登陆状态。\n既然是保存在用户本地的，那就有可能被窃取。一些恶意软件就会去扫描你浏览器本地缓存中的cookie信息，对于一些安全性不高的网站而言，有了这个cookie，就相当于他有了你的账户，可以直接登录你的账户进行操作。\n因此，引入了另外一种身份认证的方式 cookie+session\n6.3 cookie+session比起将身份信息存到客户端，存至服务端更为安全（攻击企业服务器的成本，比在用户端植入木马程序的成本更高）\n\n用户使用账户密码请求登录，服务器收到登录请求，验证成功后，给客户端返回一个唯一字符串session_id来标识用户\n客户端下一次请求的时候，带上了这个唯一字符串\n服务器收到请求，在本地的session_id库中查找这个id，找到后，就将用户信息匹配给客户端，相当于客户端登录成功了\n\n这样，就将原本存在用户本地的身份认证信息，存到了服务端中。客户端就只剩下一个孤零零的字符串id，不会有用户的私密信息。即便丢失，也不会影响用户的隐私。\n\n你可能会说，那我偷走这个id不也是一样的效果？\n\n其实没有那么简单，服务端可以将session_id和用户的ip或者终端User-Agent绑定，这样只要用户切换设备或者换了登录的地点（比如从三亚跑到了哈尔滨）就直接让session_id失效，要求用户重新登录。\n7.长短链接在早期的http协议中，采用的都是短链接，一次连接只能处理1次http请求。当时的网页大多以文字为主，数据量很小，一起请求也能够满足需求。\n但现在时代已经变了，一个网页里面有图片，文字，音频，视频。这些文件的体积打起来之后，短链接的方式就不适用了。此时就出现了长链接，一次tcp链接，可以持续传输数据。\n相比短链接，长链接连上之后，能持续传输数据，避免了tcp3次握手的消耗，提高了数据传输的效率！\n7.1 Connection在本文的3.4中，便出现了这个参数，一般情况下，会有下面两种情况\nConnection: keep-aliveConnection: closed\n\n其中keep-alive就是长链接，closed代表当前端口只支持短链接。\n当客户端发送的请求头中包含Connection: keep-alive字段，如果服务器支持长链接，就需要在响应头中也带上Connection: keep-alive\t，这样双方协商成功，大家都可以使用长链接。\n如果服务器的响应头中没有带Connection: keep-alive，那么客户端就会认为服务器不支持长链接，下次请求的时候，会重新向服务器链接，再获取资源。\n如果客户端和服务端任意一方的响应头中包含Connection: closed，那么就会认为当前的会话只支持短链接，下次请求会重新建立链接。\n7.2 http和tcp的关系http虽然是基于tcp的，但http本身是无链接的。\n\n举个最明显的栗子，在你打开一个网页之后，你关闭掉自己的wifi，你的网页并不会因此消失。只是无法进行后续操作而已。\n\nhttp是一个无链接的应用层协议，其借助tcp进行数据的流式传输，但不一定需要客户端和服务端保持连接。\n所以，http就可以借助单个tcp套接字持续的传输数据，也就天然地支持了长链接通信。\n总结一下，http只是借用了tcp的能力，其无连接的特性和tcp没有关系！\n7.3 pipeline这其中会牵扯到一个pipeline，其维护了http长链接请求时的响应顺序。\n比如人家需要加载一个网页，服务端应该先把网页的整体框架给用户加载出来，再给用户加载图片、视频、音频等资源。下图B站的加载就是一个很好的栗子。\n\n否则乱序了，比如只出现了一个孤零零的图片，就会让人感觉非常奇怪。\n8.https因为http的数据是无加密明文发送的，相对来说并不是非常的安全；为了实现数据加密，https在http的下层添加了一个SSL/TLS软件层，来进行数据加解密工作\n\n8.1 为啥要加密？要知道，所有的加密工作，都是为了防止数据在中间传输的过程，被窃取或修改。如果我们请求一个网站登录的时候，数据包中就会包含我们的账户密码。如果被窃取，我们的隐私就泄露了。这是很难受的一件事！\n\n这也是为什么，我们经常能听到免费公共wifi不安全这一说法，因为我们在这个wifi上进行的所有数据交换，都会走这个wifi的路由器，很容易被中间人窃取并获取到我们的数据包。\n这种情况下，https的加密就更有必要了！\n\n但是，加密解密是需要时间的，所以https响应的速度会稍慢于http。不过当下cpu的执行速度已经非常快，这点时间差距很小，不会特别影响我们的日常使用！\n不过，加密并不是一个万金油，并不是说加密了之后的数据就一定能避免被窃取。但加密可以大大提高窃取破解的成本，无形中降低了数据被窃取的概率，保证了一定的数据安全。\n8.2 常见加密方式8.2.1 对称加密所谓对称加密，好比有一个带锁的盒子，客户端和服务器都有一把钥匙。客户端先把信息丢进盒子里，再用🔑锁上盒子，发送给服务端。服务端用🔑打开盒子，取出数据。\n因为客户端和服务器持有的钥匙是完全一致的，所以被称为对称加密。在加密的场景下，钥匙一般被称为密钥\n在网络场景里，对称加密是不可取的。只要客户端和服务端传输密钥的时候被窃取，那么双方的加密就失效了。因为是用同一个密钥来加密解密，我拿走了你的钥匙，自然就能打开你这把锁。\n也就是说，密钥的传输也需要加密。但是这又引出一个问题，我都没有你的密钥，我怎么解密你发过来的密钥信息？这是一个先有蛋还是先有鸡的死循环！\n8.2.2 非对称加密非对称加密场景下，会有一个公钥和私钥\n\n私钥对数据加密，变成密文\n公钥对数据解密，变成明文\n\n二者也可以反过来\n\n私钥对数据解密\n公钥对数据加密\n\n其中最常用的非对称加密，也就是我们在git的ssh操作中使用过的rsa密钥，其中就有一个.pem公钥和一个私钥。我们将公钥提供给github，私钥保存到本地，就能实现无密码上传数据到git仓库。\n\n但是非对称加密还是会存在中间人攻击的问题。先看如下图，你应该能发现，其中有一个重要的环节，就是服务端要把公钥发送给客户端\n\n在这个场景中，公钥是公开传输给客户端的，也就是后续服务器发送给客户端的所有信息，都可以被其他人用这个公钥解析出来；\n整个环节中，只做到了客户端发送给服务器的信息安全，因为只有服务器拥有私钥，能解密出数据。（单项数据安全）\n8.2.3 双非对称这时候，我们可以采用双非对称密钥加密的方式！既然非对称只能保证单方的数据安全，那使用两个非对称，不就能保证双方数据安全了嘛！\n\n客户端和服务端交换公钥a&#39; 和 b&#39;\n客户端给服务端发信息：先用a&#39;对数据加密，再发送；只能由服务器解密，因为只有服务器有私钥a\n服务端给客户端发信息：先用b&#39;对数据加密，再发送；只能由客户端解密，因为只有客户端有私钥b\n\n\n因为两份私钥都只有客户端和服务器自己拥有，所以黑客没有办法进行数据的窃取，也就保证了数据的安全。\n即便中间人替换了交换的公钥，也会因为后续的通信，客户端or服务端本地的私钥无法正常解密，而发现数据被窃取！\n但是但是，这样左还算有很大的缺点\n\n效率太低（非对称加密解密负载太高，效率低下，特定场景下无法满足要求）\n依旧可能存在安全问题\n\n8.2.4 非对称+对称\n服务端具有非对称公钥S和私钥S’\n客⼾端发起请求，获取服务端公钥S\n客⼾端在本地生成对称密钥C, 通过公钥S加密, 发送给服务器.\n由于中间人没有私钥，即使截获了数据，也无法还原出内部的原文，也就无法获取到对称密钥\n服务器通过私钥S&#39;解密，还原出客户端发送的对称密钥C，并且使用这个对称密钥加密给客户端发送的响应数据\n后续客户端和服务端都采用密钥C来进行对称加密通信\n\n因为对称密钥C在传输过程中是加密的，只有客户端和服务端知道密钥是什么，也就实现了数据的安全通信！\n8.3 数据摘要（指纹）数字指纹(数据摘要)， 其基本原理是利⽤单向散列函数(Hash函数)对信息进行运算，生成⼀串固定长度的数字摘要。\n常见的摘要算法有MD5/SHA1/SHA256/SHA512等；\n数字指纹并不是⼀种加密机制，但可以用来判断数据有没有被窜改，亦或者是下载的数据包有没有出现损坏。\n\n同一个数据文件，用同一个方法生成的数据摘要是一致的\n不同文件生成的数据摘要可能会撞车，但几率极低，可以认为具有唯一性！\n我们无法用数据摘要反推出数据内容（怎么可能用一个字符串推测出原本的内容呢？那样还存放源文件干哈？😂）\n\n数据摘要在网盘产品中也有使用，当我们使用百度云盘、阿里云盘的时候，会遇到一个大的资源文件只用了短短几秒就成功上传到服务器的情况。此时，我们并不是真的用几秒就把数据传输上去了，而是经历了以下阶段\n\n网盘客户端对本地文件生成数据摘要\n生成后，判断服务器端已有文件中，是否有同该数据摘要相同的文件\n如果有，代表该文件已经存在了云盘的服务器中\n服务器将该文件给你的账户建立一个软链接&#x2F;硬链接，就实现了&quot;妙传&quot;\n如果没有，则老老实实的从本地上传文件到云盘\n\n云盘厂家这么做的原因很简单：避免同一份文件被多次存储。当下网盘给用户的免费空间动则上T，如果所有文件都重复保存，那对于云服务器厂家来说，资源消耗太大了。\n这个做法并不会产生数据隐私问题，一般只有电影等资源文件才有可能妙传成功。你可以使用一些“其他手段”，比如把资源打个压缩包，并在压缩包中随便丢另外一个文件，让文件的数据指纹和已有资源不相同，就不会进行妙传了。\n\n这样做还有另外一个好处，那就是原资源因为违规被ban的时候，你的资源不会被连坐😂\n\n8.4 数字签名对数据摘要进行加密，生成的内容被称为数字签名\n8.5 中间人攻击中间人攻击（Man-in-the-MiddleAttack），简称MITM攻击\n以8.2.2的单非对称加密为例，中间人可以在整个过程中进行偷梁换柱，窃取双方的信息。如下图：\n\n透过这个栗子🌰，实际上，如果中间人在客户端和服务端开始通信之前就来窃听并准备换柱了，他就有可能替换双方密钥，从而解密双方发送的信息！\n最重要的一点，是客户端or服务端都没有办法证明，当前的公钥是直接从服务端or客户端发来的，它们没有办法检验公钥的权威性，只能被动接受。由此给中间人偷梁换柱提供了可能。\n这时候，就需要引入CA机构和CA证书了👇\n8.6 CA证书所谓CA证书，是由CA机构颁发的权威证书。CA机构在颁发证书时，会在证书中附带上该站点的域名，以及申请人（企业）的相关信息\n\nCA机构会有一个自己的私钥和公钥，其公钥向所有人公开\nCA机构的私钥由其自己保存（私钥一定不能泄露）\n当下的浏览器、操作系统都会内置认可的CA；只有被认可的CA，才能为站点提供ssl证书服务\n\n在我们windows本地就能看到当前操作系统认可的CA机构其公钥；在edge浏览器中，点击右上角选择，进入设置，在选择隐私页面，找到管理证书\n\n点击它，就能看到当前本地认可的CA\n\n8.6.1 ssl证书加密原理当一个站点获取了ssl证书后，在向用户发送ssl证书中包含的公钥的同时，还会发送一个由CA机构对ssl证书公钥做的数字签名\n\nssl证书公钥的数字签名A，通过CA机构的私钥进行加密\nssl证书的公钥B\n\n当客户端收到这份信息之后，会采用hash函数对收到的ssl证书公钥进行数字签名，得到一个本地生成的数字签名C\n再用CA机构的公钥对传输过来的数字签名A进行解密，得到数字签名A的明文；判断由CA机构生成的ssl公钥数字签名A是否和本地生成的数字签名C相同；\n\n如果相同，则代表证书正确！\n不相同，代表证书出现错误！\n\n画个图，大概就是下面这样\n\n由于当下发送的数据包中，同时存在ssl公钥的明文+由CA机构加密后的数字签名，中间人无法进行任何攻击修改！\n\n若修改ssl公钥，由于中间人没有CA机构的私钥，无法对修改后的ssl公钥生成对应的加密后数字签名\n若使用CA公钥解密数字签名后修改……依旧会因为没有CA机构私钥，无法把修改后的签名加密回去\n如果中间人用自己的私钥生成一个数字签名，但我不认识你这个CA，也不知道你的公钥是什么，怎么解密你的信息呢？\n\n综上，中间人要想偷梁换柱，只有一个办法了，那就是拿一个真的证书整体替换掉这个数据包。\n可是ssl证书中还包含了域名、站点主体等各类信息，我当下访问的是baidu.com，结果收到的证书是qq.com的，那肯定有问题啊！浏览器会直接拒绝访问！😂\n当我们访问一些网站，浏览器报ssl证书过期，也是会出现一定的安全问题的！如果一个网站没有使用https，那么在这个网站上进行用户登录等敏感操作的时候，一定不要设置和你其他平台相同的密码！\n\n当然，如果某个网页本来就只是提供文件公开下载功能的，比如下载linux系统的iso镜像，那么它不套用https也是情有可原的，因为压根没有必要！\n\n8.6.2 ssl证书+非对称+对称有了上面这个不能被篡改的ssl证书公钥，下面我们就可以利用非对称+对称加密的方式进行通信了\n\n客户端收到ssl证书，向服务器发送一个本地生成的密钥D（使用ssl证书公钥进行加密）\n服务端收到密钥D的加密信息，使用ssl证书的私钥进行解密，获取到密钥D\n客户端和服务端使用密钥D进行对称加密通信\n\n这样即解决了安全问题，又规避了非对称加密的效率问题，一举多得！\n9.Content-Type9.1 问题之前写的http服务器有一个很大的弊端，就是Content-Type没能做到根据文件的格式进行自定义修改\n默认情况下，如果index.html中没有指定icon的路径，浏览器会自动请求根路径下的favicon.ico，如果没有这个文件，则不显示站点图标。\n如果在index.html有指定站点icon的路径，则会请求对应路径的图片。\n如下图，我在index中指定了icon的路径\n&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;http协议学习&lt;/title&gt;&lt;link rel=&quot;shortcut icon&quot; href=&quot;https://img.musnow.top/i/2022/12/icon.png&quot;&gt;&lt;/head&gt;\n\n但是浏览器去请求的时候，返回的文件类型依旧是text（因为已经写死了）\n\n最终结果就是，配置的icon无效，依旧不显示站点图标\n\n所以，我们应该在服务端给返回的文件添加上正确的Content-Type\n9.2 代码为了访问支持多种文件类型，我在tcpServer的类中新增了一个map，用于文件后缀和图标类型的对照。每每看到这个场景，我都想感慨一下：Python的dict还是方便多了🤣\nvoid initMap()&#123;    _fileTypeMap.insert(&#123;&quot;html&quot;,&quot;text/html&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;jpg&quot;,&quot;image/jpeg&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;jpeg&quot;,&quot;image/jpeg&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;png&quot;,&quot;image/png&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;gif&quot;,&quot;image/gif&quot;&#125;);    _fileTypeMap.insert(&#123;&quot;ico&quot;,&quot;image/x-icon&quot;&#125;);&#125;// 文件类型和http响应头的对照表map&lt;string,string&gt; _fileTypeMap;\n\n在设置Content-Type的时候，先从path中分离出客户端请求的文件类型\n// 获取文件的后缀string getFileType(const string&amp; path)&#123;    size_t i = path.rfind(&#x27;.&#x27;);    if(i!=string::npos)//找到了    &#123;        string filetype(path,i+1);//获取出文件类型        logging(DEBUG,&quot;Path: %s | fileType: %s&quot;,path.c_str(),filetype.c_str()); // 打印用作debug        return filetype;    &#125;    return &quot;&quot;; //没有后缀&#125;\n\n需要注意的是，一些http请求是这样的\nhttps://web.musnow.top/about/\n\n后端会收到这样的path\n/about/\n\n这个path里面并没有文件名，而本文前面提到过，如果请求的链接中没有指明文件，那就给客户返回对应路径下的index.html文件。如果这个路径下没有html文件，则返回404。这一步在分离请求头中的path时已经做了\n// 对path进行判断，如果path是以/结尾的，则在path中追加index.html文件名if(path[path.size()-1] == &#x27;/&#x27;) &#123;    path += HOME_PAGE; //加上被隐藏的index.html文件名&#125;\n\n回到正题，在获取到文件后缀后，就可以在map里面查找对应的content-type了\n// 追加正确的文件类型Content-Typeresponse += &quot;Content-Type: &quot;;string contentType = &quot;text/plain&quot;;auto it = fileTypeMap.find(fileType);if(it != fileTypeMap.end())&#123;    contentType = (*it).second;&#125;response += contentType;response += &quot;\\r\\n&quot;;\n\n但是，这样还是出现了问题，图片没办法正常加载\n\nF12打开开发者面板，可以看到服务器返回的响应头是正确的，但是依旧无法显示出图片\n\n这是因为读取图片和读取html文件的操作是不一样。在读取html文件的时候，采用的是按行读取的策略\n// 读取txt文件string readTxtFile(const string&amp; file_path)&#123;    // 如果是文件存在但是打开失败了，应该返回50x代表服务器处理错误    // tcp是面向字节流的，文件需要用二进制打开    ifstream in(file_path, ios::binary);    if(!in.is_open()) //文件打开失败    &#123;        return &quot;503&quot;;//文件打开失败    &#125;    // 内容    string content;    string line;    while(getline(in, line))    &#123;        content += line;    &#125;    in.close();    return content;&#125;\n\n但是图片文件应该需要一个完整的二进制流，而不是按行读取\n// 读取图片文件string readImgFile(const string&amp; file_path)&#123;    ifstream file(file_path, ios::binary);    // 打开失败，503    if (!file.is_open()) &#123;        return &quot;503&quot;;    &#125;    ostringstream ss;    ss &lt;&lt; file.rdbuf();    string content = ss.str();    file.close();    return content;&#125;\n\n为了区别图片和html文件，我新增了一个用于判断文件后缀的函数\nconst string imageType[] = &#123;&quot;png&quot;,&quot;jpg&quot;,&quot;gif&quot;,&quot;jpeg&quot;&#125;; // 图片类型// 判断请求头中文件类型是否为图片bool isImg(const string&amp; fileType)&#123;    for(auto&amp; t: imageType)    &#123;        // 如果完全一致        if(fileType == t)        &#123;            return true;        &#125;    &#125;    return false;&#125;\n\n最终合并成同一个函数\nstring readFile(const string &amp;file_path,bool is_img = false)&#123;    //其实这里应该分两种情况，一种是文件不存在，一种是文件打开失败了    //如果是文件不存在，应该返回404    if(access(file_path.c_str(),0)!=0)//判断文件是否存在，存在返回0    &#123;//windows下相同作用的接口为_access，头文件io.h        return &quot;404&quot;;//文件不存在    &#125;    // 读取对应的文件    if(!is_img)&#123;        return readTxtFile(file_path);    &#125;    else&#123;        return readImgFile(file_path);    &#125;&#125;\n\n在服务函数里面，也做出了区别\n// 获取文件的后缀string fileType = getFileType(path);// 打开文件string content = readFile(resources,isImg(fileType));\n\n再次测试，成功！\n\n主页html文件中配置的log也正常显示出来了！（和原来的颜色不一样）\n\n","categories":["玩上Linux"],"tags":["Linux","网络","http"]},{"title":"【Linux】buff cache的真相","url":"/posts/2377102236/","content":"1.表现现象在Linux系统中，我们经常用free命令来查看系统内存的使用状态。在一个 CoreOS 的系统上，free命令的显示内容大概是这样一个状态：\ncore@localhost ~ $ free\n              total        used        free      shared  buff/cache   available\nMem:        8145320      391200     333888      204616      7420232     311660\nSwap:             0           0           0\n\n这里的默认显示单位是kb，我们可以通过添加-h参数，来让free 命令显示的更为友好一些。\ncore@localhost ~ $ free -h\n              total        used        free      shared  buff/cache   available\nMem:          7.8Gi       381Mi       0.3Gi       199Mi       7.4Gi       0.3Gi\nSwap:            0B          0B          0B\n\n新版linux相对来说已经好很多了，在老版的时候，是没有available字段的。\n所以放当时来说，大家可能会有下面几种反应：\n\n对于不太了解linux系统的人来说，看到 free 之后，会觉得内存用了好多，我都没跑什么程序，内存就用完了！Linux好占内存！\n稍微了解linux，并在百度搜索过相关知识的人也许会说，嗯，看起来free是没有多少了，但是真实内存才用了 400Mi 不到，还有很多剩余内存可用。buff&#x2F;cache 占用比较多，说明系统中有进程曾经读写过文件，但是不要紧，这部分内存在系统内存吃紧的时候会释放出来的。\n\n但是，上面两种说法都有些片面了，都不是很正确。接下来让我们重新来认识一下buff和cache。\n2.什么是 buff&#x2F;cache？在Linux 2.4的内存管理中，buffer指Linux内存的：Buffer cache。cache指Linux内存中的：Page cache。一般呢，是这么解释两者的。\n\nA buffer is someting that has yet to be ‘written’ to disk.\nA cache is someting that has been ‘read’ from the disk and stored for later use.\n\n翻译过来就是说：\n\nbuffer(buff) 是用来缓存尚未“写入”磁盘的内容。\ncache 是用来缓存从磁盘“读取”出来的东西。\n\n所以 buffer 被用来当成对io设备写的缓存。而 cache 被用来当作对io设备的读缓存。这里的io设备，主要指的是块设备文件和文件系统上的普通文件。\n但是在 Linux 2.6 以后，它们的意义不一样了。\n在Linux 2.6之后Linux将他们统一合并到了Page cache作为文件层的缓存。而buffer则被用作block层的缓存。block层的缓存是什么意思呢，你可以认为一个buffer是一个physical disk block在内存的代表，用来将内存中的pages映射为disk blocks，这部分被使用的内存被叫做buffer。\n\nbuffer里面的pages，指的是Page cache中的pages，所以，buffer也可以被认为Page cache的一部分。\n\n或者简单来说，buffer负责裸设备相关的缓存，cache负责文件系统的缓存。\nBuffer 的具体职责在当前的系统实现里，buffer主要是设计用来在系统对块设备进行读写时作为缓存来使用。这意味着对块的操作会使用buffer进行缓存，比如我们在格式化文件系统的时候。\n但是一般情况下两个缓存系统是一起配合使用的，比如当我们对一个文件进行写操作的时候，cache的内容会被改变，而buffer则用来将cache的page标记为不同的缓冲区，并记录是哪一个缓冲区被修改了。\n这样，内核在后续执行脏数据的回写（writeback）时，就不用将整个page写回，而只需要写回修改的部分即可。\nCache 的具体职责cache主要用来作为文件系统上的文件数据的缓存来用，当进程对文件有read/write操作的时候。包括将文件映射到内存的系统调用mmap，就会用到cache。\n因为cache被作为文件类型的缓存来用，所以事实上也负责了大部分的块设备文件的缓存工作。\n3.怎么回收 buff&#x2F;cache？Linux内核会在内存将要耗尽的时候，自动触发内存回收的工作，以便释放出内存给急需内存的进程使用。\n但是这种回收的工作也并不是没有成本。\n理解cache是干什么的就知道，cache中存在着一部分write操作的数据。所以必须保证cache中的数据跟对应文件中的数据一致，才能对cache进行释放。\n于是伴随着cache清除的行为的，一般都是系统IO飙高。这是因为内核要将cache中缓存的write数据进行回写。\n我们可以使用下面这个文件来人工触发缓存清除的操作，Linux 提供了三种清空方式：\n\necho 1 &gt; /proc/sys/vm/drop_caches # 仅清除页面缓存\necho 2 &gt; /proc/sys/vm/drop_caches # 清除目录项和inode\necho 3 &gt; /proc/sys/vm/drop_caches # 清除页面缓存、目录项以及inode\n\n但是这种放时只能在执行的当时起作用，过一段时间之后又会发现内存被占满，怎么办呢？\n实际上内核提供了vm.vfs_cache_pressure参数用来控制缓冲区的回收频率，我们可以调整它。\n这个参数是用来控制内核回收VFS缓存的频率。修改这个值会提高或者降低回收VFS缓存的频率。值可以设置为0-200中的任意值。越大回收频率越快，可以把vm.vfs_cache_pressure赋值为200来获得最快的回收频率。这个值默认值一般为100。\n另外也可以使用slabtop分析内存使用情况。一般情况下，dentry和*_inode_cache值越高回收的效果越好。\n为什么是dentry和*_inode_cache呢，这是因为当读写文件时内核会为该文件对象建立一个dentry，并将其缓存起来，方便下一次读写时直接从内存中取出提高效率。至于*_inode_cache我就不是很清楚了，只知道是为了加快对索引节点的索引，如果有清楚的可以告诉我一下。\n4.测试一下\n首先，我们先看一下目前的内存使用量\ncore@localhost ~ $ free -h              total        used        free      shared  buff/cache   availableMem:          7.8Gi       383Mi       7.1Gi       199Mi       291Mi       7.0GiSwap:            0B          0B          0B\n\n生成一个文件测试一下\ncore@localhost ~ $ dd if=/dev/zero of=testfile bs=1M count=10001000+0 records in1000+0 records out1048576000 bytes (1.0 GB, 1000 MiB) copied, 1.39192 s, 753 MB/s\n\n检查一下内存的使用情况，是否和上面介绍的一样\ncore@localhost ~ $ free -h              total        used        free      shared  buff/cache   availableMem:          7.8Gi       383Mi       6.1Gi       199Mi       1.3Gi       7.0GiSwap:            0B          0B          0B\n\n手动执行一下释放，看能否将内存释放出来\ncore@localhost ~ $ echo 1 | sudo tee /proc/sys/vm/drop_caches1\n\n检查一下内存是否被释放掉\ncore@localhost ~ $ free -h              total        used        free      shared  buff/cache   availableMem:          7.8Gi       383Mi       7.1Gi       199Mi       291Mi       7.0GiSwap:            0B          0B          0B\n\n继续测试一下读取文件\ncore@localhost ~ $ time -p cat testfile &gt; /dev/nullreal 0.39user 0.00sys 0.27\n\n可以看到用时 0.39s，我们看下内存使用\ncore@localhost ~ $ free -h              total        used        free      shared  buff/cache   availableMem:          7.8Gi       382Mi       6.1Gi       199Mi       1.3Gi       7.0GiSwap:            0B          0B          0B\n\n然后我们再次执行一下读取文件\ncore@localhost ~ $ time -p cat testfile &gt; /dev/nullreal 0.17user 0.00sys 0.17\n\n可以看到用时缩短到了 0.17s，这里需要说明一下的时由于我这边是固态硬盘，所以差距没这么大，如果是机械硬盘的话差距会进一步扩大。毕竟内存缓存肯定是更快的！\n\n\n版权声明：本文为CSDN博主「kunyus」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/kunyus/article/details/104617426\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【图床】博客表情包","url":"/posts/4215614474/","content":"这里是博客中可以用到的表情包列表，一并上传，避免多次上传占用阿里云空间;\n大家觉得不错的可以保存下来😁但是不要恶意使用！\n\n\n表情包\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["图床"]},{"title":"【建站】hexo搭建博客+建站相关教程","url":"/posts/1888648770/","content":"关于HEXO建站相关博客汇总\n\n\n1.hexo部署和主题自定义【教程】hexo搭建博客+keep主题美化\n2.配置图床以下为typora+picgo配置图床的教程\n【Picgo】正确重命名文件，避免重复上传\n2.1 阿里云oss【教程】Typora+PicGo+阿里云OSS搭建博客图床\n2.2 又拍云uos相比于阿里云oss的bucket只有防盗链，又拍云的uos还有ip黑白名单，cc防护，单ip访问限制等等功能。对于博客图床防盗刷而言，很有用。\n但又拍云uos需要域名已备案才能自定义域名，否则只能使用官方提供的测试域名。如果你的域名已备案，个人更推荐使用又拍云uos作为博客图床。\n【教程】Typora+PicGo+又拍云USS搭建博客图床\n2.3 自建图床lsky自建图床的优势在于，图片都在你服务器的本地，可以直接tar打包进行备份，或者手动从服务器下载到电脑作为备份。\n个人不太喜欢oss的一点，就是大多数oss服务商都没有提供批量下载oss内部文件的选项。估计是考虑到存储服务器的负载问题，所以没有提供这个功能。毕竟批量下载大量文件，是很耗资源的。\n虽然可以用python代码来实现批量下载，但服务商能直接提供批量下载的功能，还是更方面嘛！\n兰空图床是自建图床中比较方便的一个，且支持picgo上传\n【Docker】配置lsky pro兰空图床\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【Linux】高级IO和多路转接 | select/poll/epoll","url":"/posts/3390191280/","content":"多路转接和高级IO\n\n\n咳咳，写的时候出了点问题，标点符号全乱了（批量替换了几次），干脆就把全文的逗号和句号都改成英文的了（不然代码块里面的代码都是中文标点就跑不动了）\n\nIO多路复用和本文提到的多路转接是一个东西！\n\n1.高级IO1.1 五种IO模型用钓鱼佬的栗子, 来看看五种不同的IO模型吧\n\nA, 拿着鱼竿去钓鱼, 一直盯着鱼漂, 鱼漂有动静就收钩\nB, 拿着鱼竿去钓鱼, 时不时看看鱼漂, 有动静就收购\nC, 拿着鱼竿去钓鱼, 在鱼漂上弄个铃铛, 然后干其他的事情, 听到铃铛的声音就收钩\nD, 拿了一大堆鱼竿过来, 都摆弄好, 只要有一个鱼漂有动静, 就收钩\nE是大老板, 直接叫人帮忙钓鱼, 钓到一定数量的🐟后通知自己, 自己过来取🐟（没有参与钓鱼过程）\n\n这五种钓鱼方式, 就对应了五种IO模型\n\nA, 阻塞等待, 等待到数据就立即读取\nB, 轮询检测, 检测到数据的时候读取\nC, 利用铃铛来作为通知方式, 听到了信号之后, 就去读取数据（信号驱动）\nD, 一次性检测多个文件描述符（多路转接）\nE, 没有自己参与钓鱼过程, 有别人帮忙监控文件描述符, 自己只关心拿走数据（异步IO）\n\n在这五种IO模式中, D的效率是最高的。因为它一次性监控了多个文件描述符, 这些文件描述符的IO在一定程度上重合了, 更容易等到数据。\n要知道, D是过来钓鱼的, 他只要能钓到鱼就够了, 并不用关心到底是哪个鱼钩钓上来的鱼。同理, 我们的IO服务器也并不需要关心到底是哪个文件描述符在给自己传递信息, 我们只要每时每刻都在处理信息（都能钓到鱼）才是最高效率的体现。\n换句话说, 在钓鱼（处理IO）的时候, 等的时间比例越低, 效率越高！\n1.2 阻塞和非阻塞这两个概念我们在先前对IO的学习中已经见过了\n\n阻塞：进程会在函数调用中卡住, 在没有成功调用之前不会继续向后运行\n非阻塞：不管能否获取到数据, 函数都是直接返回结果;\n\n1.3 异步与同步通信\n异步通信：在调用发出后, 这个调用直接返回, 并没有携带结果;类似std::async/future, 在调用发出后, 被调用着通过状态或通知来告知调用者, 亦或者是用回调函数来处理这个异步调用\n同步通信：在发出调用后, 没有得到结果前, 该调用不返回;一旦返回就表明该调用成功获取到了返回值（调用者主动等待调用结果）\n\n这里的同步和线程&#x2F;进程同步并不是一个概念：\n\n线程和进程的同步指的是线程和进程之间有相互制约的关系, 需要在某些情况中协调他们的工作次序而进行等待\n\n\n了解完IO模型和上方的知识后, 下面就让我们来认识一下第一个接口吧！\n2.fcntl这个是一个系统调用, 可以给文件描述符进行不同的策略设置。\n当我们在linux中创建一个文件描述符的时候, 默认创建的都是阻塞的文件描述符。我们可以使用fcntl来将文件描述符设置成非阻塞的。\n2.1 接口该函数的原型如下\n#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* arg */ );\n\n其中cmd是我们需要执行的策略, 下面是常见的几种选项\n\n复制一个现有的描述符（cmd&#x3D;F_DUPFD）\n获得&#x2F;设置文件描述符标记(cmd&#x3D;F_GETFD或F_SETFD)\n获得&#x2F;设置文件状态标记(cmd&#x3D;F_GETFL或F_SETFL)\n获得&#x2F;设置异步I&#x2F;O所有权(cmd&#x3D;F_GETOWN或F_SETOWN)\n获得&#x2F;设置记录锁(cmd&#x3D;F_GETLK, F_SETLK或F_SETLKW)\n\n这里我们使用的是第三个功能, 来获取和设置文件的状态标记, 就可以将文件描述符设置为非阻塞（这里要注意, 不是用第二种）\n2.2 设置非阻塞我们需要先将文件描述符原本的属性给取出来, 然后再加上非阻塞的状态, 使用fcntl设置属性。\nvoid SetNoBlock(int fd)&#123;    int fl = fcntl(fd, F_GETFL);  // 先获取文件已有状态    if (fl &lt; 0) &#123;       perror(&quot;fcntl error&quot;);       return;    &#125;    // 在已有状态的基础上, 设置O_NONBLOCK非阻塞    fcntl(fd, F_SETFL, fl | O_NONBLOCK);&#125;\n\n2.3 stdin测试然后, 我们还需要一个会出现阻塞的文件描述符来作为测试。但是, 如果是直接打开一个本地文件, 并不会出现阻塞态（因为文件流会被一次性读取出来）\n不过, 在我们最常用的3个默认文件描述符中, 就有一个是能够实现进程阻塞的, 它就是stdin, 因为在控制台里面等待用户输入的时候, 进程就是处于阻塞状态的！\n$ ./test请输入：\n\n所以我们就可以尝试将stdin设置为非阻塞, 来观察一下结果\nint main()&#123;    SetNoBlock(stdin-&gt;_fileno);    char buf[1024];    while(true)    &#123;        ssize_t read_size = read(stdin-&gt;_fileno, buf, sizeof(buf) - 1);        if(read_size &lt; 0)        &#123;            perror(&quot;read err&quot;);            sleep(2);            continue;        &#125;        printf(&quot;input:%s\\n&quot;, buf);        buf[0] = &#x27;\\0&#x27;;    &#125;    return 0;&#125;\n\n编译运行, 当没有读取到输入内容的时候, 并不会在stdin中阻塞, 而是会通过perror打印出资源暂时不可用的警告信息。\n$ ./testread err: Resource temporarily unavailableasdlfjklafinput:asdlfjklafread err: Resource temporarily unavailableadslfkjaldfjklasjfainput:adslfkjaldfjklasjfaaread err: Resource temporarily unavailableewqrqreqqrwerinput:ewqrqreqqrwerasjfaaread err: Resource temporarily unavailableqweioruqoruioqewurinput:qweioruqoruioqewuraread err: Resource temporarily unavailableweqioruqoieuotqitqwertqinput:weqioruqoieuotqitqwertq����aread err: Resource temporarily unavailable^C\n\n3.多路转接之select接下来就要进入我们的正题了, 关于多路转接的知识。\n在之前的时候, 我们如果想在一个进程里面维护多个tcp链接, 就需要用到子线程或者子进程来单独为每一个用户提供服务。但一个进程可以开的线程是有数量限制的, 在32位系统中, 这个数字大概是2000。\n对于一个高并发的服务器来说, 这点线程数是完全不够用的！如果你的网站一次性有2000个人访问, 你的服务器就会因为开不出更多的线程而无法为更多的用户提供服务！\n所以, 多路转接就出现了, 他能帮我们实现单个进程监控多个文件描述符, 同时为多个socket链接提供服务的操作！\n\n普通的本地文件描述符也是可以托管给多路转接的！\n\n3.1 认识selectselect的函数原型和我们之前接触过的linux系统调用接口都不大相似, 它的所有参数都是输入输出型参数, 而且还用到了一个我们平时较少接触的数据结构——位图\n/* According to POSIX.1-2001, POSIX.1-2008 */#include &lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds,           fd_set *exceptfds, struct timeval *timeout);\n\n先来依次说明一下每一个参数的作用吧\n\nnfds：需要select帮我们监视的最大文件描述符+1\nreadfds/writefds/exceptfds, 需要select帮我们检测的读&#x2F;写&#x2F;异常文件描述符（通过位图来设定）\ntimeout：阻塞监控的时长, 用来设置select单次阻塞等待的时间\n\n3.1.1 timeval首先来看看timeout的这个参数的struct timeval结构体框架, 内部包含两个成员变量, 一个表示秒数, 一个表示微秒数。最终select等待的时间是这两个参数的和\nstruct timeval &#123;    long    tv_sec;         /* seconds */    long    tv_usec;        /* microseconds */&#125;;\n\n\n如果设置成0, 则仅检测文件描述符的状态, 不管什么情况都会立即返回（完全非阻塞）\n如果设置成指定的时间, 则会阻塞等待这端时间, 如果有文件事件则返回;如果没有等到文件时间, 那么时间到了就会返回\n如果将timeout参数设置成nullptr, 则会阻塞等待\n\n这个参数也是一个输入输出型参数, 返回值为剩余的秒数（如果等待成功的话）\n3.1.2 fd_set函数中有3个参数都是用到了这个fd_set结构, 它是一个位图结构, 同时也是一个输入输出参数\n\n输入：用户告诉操作系统, 需要帮我监控那几个文件描述符, 在需要监控的文件描述符上置1\n输出：系统告诉用户, 那些文件描述符的相关事件就绪了\n\n虽然这是一个位图结构, 但其并不需要我们手动去设置, 操作系统顺便帮我们封装了相关的设置“函数”, 只需要传入fd和该结构体即可\nvoid FD_CLR(int fd, fd_set *set);  // 清空位图中对该文件描述符的设置int  FD_ISSET(int fd, fd_set *set);// 判断是否被设置了void FD_SET(int fd, fd_set *set);  // 设置对应位置的文件描述符void FD_ZERO(fd_set *set);         // 清空整个位图\n\n你可能回觉得奇怪, 为什么这些“函数”是大写的呢？Linux中大写的应该是宏才对吧？\n答对了！这里的设置函数其实都是宏定义！\n/* Access macros for `fd_set&#x27;.  */#define\tFD_SET(fd, fdsetp)\t__FD_SET (fd, fdsetp)#define\tFD_CLR(fd, fdsetp)\t__FD_CLR (fd, fdsetp)#define\tFD_ISSET(fd, fdsetp)\t__FD_ISSET (fd, fdsetp)#define\tFD_ZERO(fdsetp)\t\t__FD_ZERO (fdsetp)\n\n既然是一个预定义好的位图, 那么它的长度就会收到操作系统底层的一定限制, 以下为源代码中fd_set结构体的定义\n// 路径 usr/include/sys/select.h/* The fd_set member is required to be an array of longs.  */typedef long int __fd_mask;/* Some versions of &lt;linux/posix_types.h&gt; define this macros.  */#undef\t__NFDBITS/* It&#x27;s easier to assume 8-bit bytes than to get CHAR_BIT.  */#define __NFDBITS\t(8 * (int) sizeof (__fd_mask))#define\t__FD_ELT(d)\t((d) / __NFDBITS)#define\t__FD_MASK(d)\t((__fd_mask) (1UL &lt;&lt; ((d) % __NFDBITS)))/* fd_set for select and pselect.  */typedef struct  &#123;    /* XPG4.2 requires this member name.  Otherwise avoid the name       from the global namespace.  */#ifdef __USE_XOPEN    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];# define __FDS_BITS(set) ((set)-&gt;fds_bits)#else    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];# define __FDS_BITS(set) ((set)-&gt;__fds_bits)#endif  &#125; fd_set;\n\n在另外一个头文件中, 可以找到__FD_SETSIZE这个宏的定义, 是1024;也就是说, fd_set这个位图最大的长度只有1024个比特位, 我们也只能监看这么多文件描述符！\n// 路径 usr/include/bits/typesizes.h/* Number of descriptors that can fit in an `fd_set&#x27;.  */#define __FD_SETSIZE\t\t1024\n\n这也是select的缺点之一, 同时监看的文件描述符数量是有限制的！\n3.1.3 nfds这个参数是select需要帮我们监看的最大文件描述符+1, 这是因为select在监看的过程中需要用循环来进行检测, 这个最大文件描述符+1相当于是一个循环的边界条件;\n你只需根据当前已有的文件描述符号, 计算出最大文件描述符, 再加一传给这个函数即可。\n3.1.4 返回值man手册中对返回值的描述如下\n\n成功的时候, 返回事件就绪的文件描述符数量\n失败的时候返回-1, 并设置errno\n如果已经timeout了还没有事件就绪, 返回0\n\nRETURN VALUE       On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor  sets  (that  is,  the total  number  of  bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens.  On error, -1 is returned, and errno is set to indicate the error; the file descriptor sets are unmodified, and  timeout becomes undefined.\n\n3.2 实例函数原型看完了, 得从实例出发来试试了\n3.2.1 socket这里先对socket做了一个简单的封装, 包括初始化, 绑定相关的接口, 只需要在另外一个文件里面调用这个头文件即可 !\n//Sock.hpp#pragma once#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/stat.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;pthread.h&gt;#include &lt;cerrno&gt;#include &lt;cassert&gt;class Sock&#123;public:    static const int gbacklog = 20;    static int SocketInit()    &#123;        int listenSock = socket(PF_INET, SOCK_STREAM, 0);        if (listenSock &lt; 0)        &#123;            exit(1);        &#125;        // 设置端口复用, 避免timewait阻塞端口        int opt = 1;        setsockopt(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, sizeof(opt));        return listenSock;    &#125;    static void Bind(int socket, uint16_t port)    &#123;        struct sockaddr_in local; // 用户栈        memset(&amp;local, 0, sizeof local);        local.sin_family = PF_INET;        local.sin_port = htons(port);        local.sin_addr.s_addr = INADDR_ANY;        // 2.2 本地socket信息, 写入sock_对应的内核区域        if (bind(socket, (const struct sockaddr *)&amp;local, sizeof(local)) &lt; 0)        &#123;            exit(2);        &#125;    &#125;    static void Listen(int socket)    &#123;        if (listen(socket, gbacklog) &lt; 0)        &#123;            exit(3);        &#125;    &#125;    static int Accept(int socket, std::string *clientip, uint16_t *clientport)    &#123;        struct sockaddr_in peer;        socklen_t len = sizeof(peer);        int serviceSock = accept(socket, (struct sockaddr *)&amp;peer, &amp;len);        if (serviceSock &lt; 0)        &#123;            // 获取链接失败            return -1;        &#125;        if(clientport) *clientport = ntohs(peer.sin_port);        if(clientip) *clientip = inet_ntoa(peer.sin_addr);        return serviceSock;    &#125;&#125;;\n\n另外重点说明一下这两行, 在之前学习tcp服务器的时候就提到过, 这里的SO_REUSEADDR是让端口可以被复用, 不会因为存在TIME_WAIT的链接而无法绑定端口。适用于服务器快速重启的情况。\n// 设置端口复用, 避免timewait阻塞端口int opt = 1;setsockopt(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, sizeof(opt));\n\n3.2.2 初始化还是老一套, 通过命令行参数获取到端口号, 创建socket_fd并绑定端口和开始listen\nint main(int argc, char *argv[])&#123;    if (argc != 2) &#123;        cmd_usage(argv[0]);        exit(1);    &#125;    // 初始化socket, 获取socket fd并绑定端口    int listensock = Sock::SocketInit();    Sock::Bind(listensock, atoi(argv[1]));    Sock::Listen(listensock); // 开始监听&#125;\n\n需要注意的是, 在select中的文件描述符都只剩位图了, 所以我们必须要有一个单独的文件描述符数组来协助我们管理正在维护的文件描述符。\n这里为了方便, 我设立了一个全局的数组变量, 长度为sizeof(fd_set) * 8, 是fd_set这个位图结构体能够支持的最大socket数量\nint fdsArray[sizeof(fd_set) * 8] = &#123;0&#125;; // 保存历史上所有的合法fdint fdsArraySz = sizeof(fdsArray) / sizeof(fdsArray[0]);#define DFL_FD -1 // 数组中默认值\n\n在main函数中, 我们需要通过遍历来将这个数组设置为默认的文件描述符-1来表明当前位置没有被使用, 并将0下标处设置为listensock;如果你使用的是vector, 则可以直接用构造函数来初始化;\n// 将数组里面的文件描述符都初始化为默认值, 并将第一个下标设置为listensocketfor (int i = 0; i &lt; fdsArraySz; i++)&#123;    fdsArray[i] = DFL_FD;&#125;fdsArray[0] = listensock;\n\n3.2.3 监听初始化完毕数组后, 就可以开始循环调用select来进行监听了。\n需要注意的是, 因为select的fd_set是一个位图, 而且是输入输出参数。每次的select调用之后, 这些位图就会被操作系统修改为已经就绪的文件描述符（即参数本身会被修改）所以我们下一次调用之前, 需要重新设置位图参数！\n// 开始监听fd_set readfds;while(true)&#123;    int maxFd = DFL_FD;    FD_ZERO(&amp;readfds); // 清空位图    struct timeval timeout = &#123;5, 0&#125;; // 设置超时时间为5秒    // 遍历全局数组, 将有效的fd都添加进去, 并更新maxfd    for (int i = 0; i &lt; fdsArraySz; i++)    &#123;        // 1. 过滤不合法的fd        if (fdsArray[i] == DFL_FD) continue;        // 2. 添加所有的合法的fd到readfds中, 方便select统一进行就绪监听        FD_SET(fdsArray[i], &amp;readfds);        if (maxFd &lt; fdsArray[i]) &#123;            maxFd = fdsArray[i]; // 3. 更新出fd最大值        &#125;    &#125;    // 调用select开始监听    int sret = select(maxFd+1, &amp;readfds, nullptr, nullptr, &amp;timeout);    switch (sret)    &#123;    case 0: // 等待超时        cout &lt;&lt; &quot;time out ... : &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; endl;        break;    case -1:// 等待失败        cerr &lt;&lt; errno &lt;&lt; &quot; : &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        break;    default:        // 等待成功        cout &lt;&lt; &quot;wait success: &quot; &lt;&lt; sret &lt;&lt; endl;        break;    &#125;&#125;\n\n基本框架搭起来了, 我们这时候就只需要实现等待成功后取出链接和IO信息的操作了;\n先来测试一下当前的手脚架吧\n3.2.4 手脚架测试编译启动, 使用命令行参数来绑定端口, 在没有收到数据之前, 进程会在select中阻塞等待5秒, 随后因为超时跳出阻塞态, 返回0并打印当前时间戳\n$ g++ main.cpp -o test$ ./test 10000time out ... : 1692955522time out ... : 1692955527time out ... : 1692955532time out ... : 1692955537time out ... : 1692955542\n\n使用telnet命令来链接当前服务, select检测到listensock文件描述符就绪, 会立刻返回（对于listensock来说, 来了新链接就是读IO就绪）但因为我们没有写取走新socket的代码, 所以这里会一直打印事件就绪;\n返回值为1, 代表有一个文件描述符的事件就绪。\n\n3.2.5 处理新连接在select事件就绪后, 使用如下函数来处理新的链接\nstatic void HandlerEvent(int listensock, fd_set &amp;readfds);\n\n这里额外写了一个打印数组中元素的函数, 方便我们观察结果。\n/// @brief 打印数组中的文件描述符static void ShowArray(int arr[], int num)&#123;    cout &lt;&lt; &quot;当前合法sock list: &quot;;    for (int i = 0; i &lt; num; i++)    &#123;        if (arr[i] == DFL_FD )            continue;        else            cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n首先我们需要遍历整个链接数组, 并判断当前位置是否是有效的文件描述符。无效直接跳过。\nfor (int i = 0; i &lt; fdsArraySz; i++)&#123;    if (fdsArray[i] == DFL_FD)        continue;    // 处理新连接和已有链接&#125;\n\n遍历的时候, 我们需要对listensock做单独的处理, 毕竟获取新连接和维护已有链接的流程是完全不同的。下面说说流程\n\n判断是否有在select中监听该文件描述符\n有监听, 继续往后执行, 开始进行accept获取新的链接\n获取失败, 直接跳出该函数, 结束该轮处理\n获取成功, 不能直接read&#x2F;write, 而是应该通过数组交付给select帮我们监听事件\n下一轮循环中, select便会帮我们监听该新链接的事件是否就绪\n\n因为走到这里的时候, 我们的listensocket里面是一定有新连接的, 所以对accept的调用是不会阻塞线程的！\nif (i == 0 &amp;&amp; fdsArray[i] == listensock)&#123;    // 判断listensocket有没有事件监听    if (!FD_ISSET(listensock, &amp;readfds))&#123;        cerr &lt;&lt; &quot;listensocket not set in readfds&quot; &lt;&lt; endl;        continue;    &#125;    // 具有了一个新链接    cout &lt;&lt; &quot;get new connection&quot; &lt;&lt; endl;    string clientip;    uint16_t clientport = 0;    int sock = Sock::Accept(listensock, &amp;clientip, &amp;clientport); // 不会阻塞    if (sock &lt; 0)        return; // 出错了, 直接返回    // 成功获取新连接    cout &lt;&lt; &quot;new conn:&quot; &lt;&lt; clientip &lt;&lt; &quot;:&quot; &lt;&lt; clientport &lt;&lt; &quot; | sock: &quot; &lt;&lt; sock &lt;&lt; endl;    // 这里我们不能直接对这个socket进行独写, 因为新链接来了并不代表新数据一并过来了    // 所以需要将新的文件描述符利用全局数组, 交付给select    // select 帮我们监看socket上的读事件是否就绪    int i = 0;    for (i = 0; i &lt; fdsArraySz; i++)    &#123;        if (fdsArray[i] == DFL_FD)            break;    &#125;    // 达到上限了    if (i == fdsArraySz)    &#123;        cerr &lt;&lt; &quot;reach the maximum number of connections&quot; &lt;&lt; endl;        close(sock);    &#125;    else // 没有达到    &#123;        fdsArray[i] = sock; // 新的链接, 插入到数组中, 下次遍历就会添加到select监看中        ShowArray(fdsArray, fdsArraySz);    &#125;&#125;\n\n3.2.6 处理已有链接这里暂时只做了对读的操作, 当读事件就绪的时候, 我们通过read读取已有的数据。这里因为socket中肯定是有数据的, 所以也不会出现阻塞的情况。\n// end if (i == 0 &amp;&amp; fdsArray[i] == listensock)else&#123;    // 处理普通sock的IO事件    if (FD_ISSET(fdsArray[i], &amp;readfds))    &#123;        // read、recv读取即可        char buffer[1024];        ssize_t s = recv(fdsArray[i], buffer, sizeof(buffer), 0); // 不会阻塞        if (s &gt; 0)        &#123;            buffer[s] = 0;            cout &lt;&lt; &quot;client[&quot; &lt;&lt; fdsArray[i] &lt;&lt; &quot;]# &quot; &lt;&lt; buffer &lt;&lt; endl;        &#125;        else if (s == 0) // 对端关闭        &#123;            cout &lt;&lt; &quot;client[&quot; &lt;&lt; fdsArray[i] &lt;&lt; &quot;] quit, server close &quot; &lt;&lt; fdsArray[i] &lt;&lt; endl;            close(fdsArray[i]);            fdsArray[i] = DFL_FD; // 去除对该文件描述符的select事件监听            ShowArray(fdsArray, fdsArraySz);        &#125;        else // 异常了        &#123;            cout &lt;&lt; &quot;client[&quot; &lt;&lt; fdsArray[i] &lt;&lt; &quot;] error, server close &quot; &lt;&lt; fdsArray[i] &lt;&lt; endl;            close(fdsArray[i]);            fdsArray[i] = DFL_FD; // 去除对该文件描述符的select事件监听            ShowArray(fdsArray, fdsArraySz);        &#125;    &#125;&#125;\n\n这里我单次读取的时候, 最多只能读出1024字节的数据;如果想一次性读取完毕, 则需要使用循环+设置非阻塞来进行读取。后续在epoll的代码示例中会展示这种写法。\n3.2.7 实测到这里, 我们这套代码就基本完成了, 可以来测试一下能否实现单线程监听多个链接;\n在本地使用telnet+多个终端进行测试, 可以看到我们成功实现了同时监听两个链接, 并接受这两个链接给自己发送的信息的功能。当telnet退出的时候, 也能成功回收文件描述符。\n\nselect的小实现暂时先看到这里, 如果想用select实现同时读+写, 其实是很复杂的。需要一套完整的逻辑。这就留着到最后epoll的时候再统一展现吧！\n3.3 socket就绪条件socket不同事件的就绪有各自的条件\n3.3.1 读就绪\nsocket内核中, 接收缓冲区中的字节数, 大于等于低水位标记SO_RCVLOWAT, 此时可以无阻塞的读该文件描述符, 并且返回值大于0;\nsocket在TCP通信中, 对端关闭连接, 此时对该socket读, 则返回0;\n监听的socket上有新的连接请求;\nsocket上有未处理的错误;\n\n3.3.2 写就绪\nsocket内核中,  发送缓冲区中的可用字节数(发送缓冲区的空闲位置大小),  大于等于低水位标记 SO_SNDLOWAT,  此时可以无阻塞的写,  并且返回值大于0;\nsocket的写操作被关闭(close或者shutdown). 对一个写操作被关闭的socket进行写操作,  会触发 SIGPIPE 信号;\nsocket使用非阻塞connect连接成功或失败之后;\nsocket上有未读取的错误;\n\n3.3.3 异常就绪socket上收到带外数据（TCP报头中的URG和紧急指针）\n3.4 select的特点\n可监控的文件描述符有上限, 取决于fd_set位图结构体的配置\n在监控文件描述符的时候, 需要用户额外的数组来维护文件描述符\n每次循环都得遍历整个数组, 效率较低（可以优化为保证有效文件描述符都在数组的前方）\n\n一下是它在效率上的一些缺点\n\n每次调用select都得手动设置一边fd集和（因为fd_set也是输出型参数, 在内核中会被修改）\n每次调用select, 都需要把所有fd从用户态拷贝到内核态, 小陆地\n每次调用, 内核都须遍历传递进来的位图, 效率低\n监控的文件描述符有上限, 数量小\n\n4.多路转接之poll4.1 函数原型接下来我们要了解的是另外一个多路转接方案, poll\n#include &lt;poll.h&gt;int poll(struct pollfd *fds,  nfds_t nfds,  int timeout);\n\n4.1.1 参数这里的参数就和select完全不同了, 出现了另外一个结构体\nstruct pollfd &#123;    int   fd;         /* file descriptor */    short events;     /* requested events */    short revents;    /* returned events */&#125;;\n\n这一个结构体分别包含了三个成员\n\n文件描述符fd;\n用户告诉内核需要监看的事件events;\n内核返回的就绪事件revents;\n\n但是从这个函数的参数上看来, 貌似它是一个只有一个元素的输入输出型参数, 难道说poll只能监看一个文件描述符吗？🧐\n非也, 我们将函数原型改一下就能看明白了, 实际上, 第一个参数是一个结构体数组, 第二个参数是该结构体数组的长度！\nint poll(struct pollfd fds[],  nfds_t nfds,  int timeout);\n\n第三个参数和select中的timeout的功能相同, 如果到达一定时间还没有获取到参数, 则直接返回;如果设置为-1则阻塞等待, 设置为0为完全非阻塞。\n这里的timeout并非输入输出型号参数, 其只是一个输入参数, 单位为毫秒（记住, 不是秒, 是毫秒）\n4.1.2 返回值\n小于0, 出错\n等于0, 等待超时\n大于0, 文件描述符已经就绪的数量\n\n4.1.3 事件这里需要了解一下poll包含的事件类型了, 我们需要根据不同情况来选择想要的事件, 并设置到结构体的event中;对于select&#x2F;poll&#x2F;epoll来说, 这些socket的就绪条件都是相同的。详见 3.3 socket就绪条件;\n\n4.2 poll优缺点4.2.1 优点在poll中, 使用的是一个结构体数组来表示需要监听的文件描述符, 以及事件就绪的文件描述符\n\n因为结构体中用户需要监听的event和内核返回的就绪event并不在一个变量上, 所以只需要设置一次即可（如果需求没有变动的话）, 无需像select每次都得重新遍历来设置位图\npoll没有最大文件描述符限制\npoll无需用户额外维护一个单独的文件描述符数组, 直接沿用该结构体数组即可\n\n4.2.2 缺点\n和select一样, poll也需要轮询检测就绪的fd和相关事件\n每次调用poll需要把pollfd结构体从用户态拷贝到内核态\n虽然poll没有最大文件描述符限制, 但是监看的多了后性能会线性下降\n\n4.3 看看示例代码poll的代码部分的主机结构和select基本相同，这里我们主要来说一下不同的地方\n#define NUM 1024#define DFL_FD -1struct pollfd fdsArray[NUM];\n\n首先是全局的数组，这时候不需要自己维护一个int文件描述符数组了，直接使用这个结构体作为全局数组就OK了；在main函数里面还是老样子，我们得把整个数组的fd都设置成默认的fd作为标识\nfor (int i = 0; i &lt; NUM; i++)&#123;    fdsArray[i].fd = DFL_FD;    fdsArray[i].events = 0;    fdsArray[i].revents = 0;&#125;fdsArray[0].fd = listensock;fdsArray[0].events = POLLIN;\n\n在main函数的主循环中，也是用poll来依次监听事件，并判断poll函数的返回值\nint timeout = 5;while (true)&#123;    int n = poll(fdsArray, NUM, timeout);    switch (n)    &#123;        case 0:            cout &lt;&lt; &quot;time out ... : &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; endl;            break;        case -1:            cerr &lt;&lt; errno &lt;&lt; &quot; : &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;            break;        default:            HandlerEvent(listensock);            break;    &#125;&#125;\n\n在HandlerEvent函数中，我们通过判断结构体内部的revent来得知是否有事件就绪\nif (fdsArray[i].revents &amp; POLLIN)&#123;&#125; // 读事件是否就绪\n\n对于listensocket来说，就绪了就执行accept；并将新的文件描述符添加到数组中\nint j = 0;for (j = 0; j &lt; NUM; j++)&#123;    if (fdsArray[j].fd == DFL_FD)        break;&#125;// 通过for循环找到当前位置是默认的结构体下标if (j == NUM) // 如果达到上限才break&#123;    cerr &lt;&lt; &quot;我的服务器已经到了最大的上限了，无法在承载更多同时保持的连接了&quot; &lt;&lt; endl;    close(sock);&#125;else&#123;    fdsArray[j].fd = sock; // 将sock添加到数组中    fdsArray[j].events = POLLIN;    fdsArray[j].revents = 0;    ShowArray(fdsArray, NUM);&#125;\n\n对于其他链接来说，就绪了就开始read。如果read异常或者对端关闭，那就将对应位置的结构体全部初始化（清空），相当于将这个链接从监听中去掉！\nfdsArray[i].fd = DFL_FD;fdsArray[i].events = 0;fdsArray[i].revents = 0;\n\n其余的操作和select完全一致，在这里就不展示代码了！\n5.epollman手册中提到, epoll是为了处理大量socket文件描述符句柄而进行了一定改进的poll;\n5.1 接口epoll就不是只有一个函数接口了, 而是有3个相关的函数，使用过程就是三部曲：\n\nepoll_create 创建epoll文件句柄\nepoll_ctl 将需要监控的文件描述符进行注册\nepoll_wait 等待文件描述符就绪\n\n5.1.1 epoll_create#include &lt;sys/epoll.h&gt;int epoll_create(int size);int epoll_create1(int flags);\n\nepoll在使用的时候, 我们需要用create函数创建一个epoll的句柄（本质上也是文件描述符）, 来管理当前进程需要操作系统帮我们监看的文件描述符\n\n自从linux 2.6.8 后, 这里的size参数是被忽略的\nepoll的句柄在使用完毕后也需要用close()函数关闭\n错误的时候返回-1并设置errno, 正确的时候返回文件描述符\n\n5.1.2 epoll_ctl该函数是对epoll中需要监看的文件描述符进行设置\n#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd,  int op,  int fd,  struct epoll_event *event);\n\n\n第一个参数是epoll_create的返回值\n第二个参数是动作, 包含三个不同的选项\nEPOLL_CTL_ADD：将新的文件描述符添加到epfd中\nEPOLL_CTL_MOD：修改已有文件描述符的监听事件\nEPOLL_CTL_DEL：删除已有文件描述符\n\n\n第三个参数是目标文件描述符\n第四个参数是一个epoll_event结构体\n\n这个结构体的定义如下\ntypedef union epoll_data &#123;    void        *ptr;    int          fd;    uint32_t     u32;    uint64_t     u64;&#125; epoll_data_t;struct epoll_event &#123;    uint32_t     events;      /* Epoll events */    epoll_data_t data;        /* User data variable */&#125;;\n\n事件事件events可以是下面的这些选项\n\n\n\n事件\n说明\n\n\n\nEPOLLIN\n表示对应的文件描述符可以读 (包括对端SOCKET正常关闭);\n\n\nEPOLLOUT\n表示对应的文件描述符可以写;\n\n\nEPOLLPRI\n表示对应的文件描述符有紧急的数据可读 (这里应该表示有带外数据到来);\n\n\nEPOLLERR\n表示对应的文件描述符发生错误;\n\n\nEPOLLHUP\n表示对应的文件描述符被挂断;\n\n\nEPOLLET\n将EPOLL设为边缘触发 (Edge Triggered)模式,  这是相对于水平触发(Level Triggered) 来说的；\n\n\nEPOLLONESHOT\n只监听一次事件,  当监听完这次事件之后,  如果还需要继续监听这个socket的话,  需要手动再次把这个socket加入到EPOLL队列里；\n\n\n5.1.3 epoll_wait#include &lt;sys/epoll.h&gt;int epoll_wait(int epfd,  struct epoll_event *events,               int maxevents,  int timeout);int epoll_pwait(int epfd,  struct epoll_event *events,                int maxevents,  int timeout,                const sigset_t *sigmask);\n\n改函数的作用是收集在epoll监控的事件中，已经就绪的事件\n\n第一个参数是epoll的文件描述符句柄\n参数events是epoll_events结构体数组，是一个输出型参数。epoll会将就绪的事件赋值到events数组里面；\nmaxevents 告诉内核这个events的大小，其不可以超过epoll_create的size；\n参数timeout是超时时间，也是毫秒（0非阻塞，-1永久阻塞）\n返回值：成功返回IO事件就绪的文件描述符数目，0代表超时，负数代表失败\n\n5.2 工作原理5.2.1 从源码看流程我们知道，select通过位图来告诉操作系统需要管理的文件描述符，poll通过结构体数组来告诉操作系统需要管理的文件描述符。\n但epoll里面，却变成了一个epfd文件句柄，我们只是给这个特定的句柄交付文件描述符。这说明底层肯定需要其他的数据结构，来管理某个进程的某个epfd交付给操作系统的文件描述符，以及需要监看的事件！\n在Linux 2.6.32.16源码fs/eventpoll.c中，可以找到如下这个结构体\n// linux源码文件路径：fs/eventpoll.c/* * This structure is stored inside the &quot;private_data&quot; member of the file * structure and rapresent the main data sructure for the eventpoll * interface. */struct eventpoll &#123;\t/* Protect the this structure access */\tspinlock_t lock;\t/*\t * This mutex is used to ensure that files are not removed\t * while epoll is using them. This is held during the event\t * collection loop, the file cleanup path, the epoll file exit\t * code and the ctl operations.\t */\tstruct mutex mtx;\t/* Wait queue used by sys_epoll_wait() */\twait_queue_head_t wq;\t/* Wait queue used by file-&gt;poll() */\twait_queue_head_t poll_wait;\t/* List of ready file descriptors */\tstruct list_head rdllist;\t/* RB tree root used to store monitored fd structs */\tstruct rb_root rbr;\t/*\t * This is a single linked list that chains all the &quot;struct epitem&quot; that\t * happened while transfering ready events to userspace w/out\t * holding -&gt;lock.\t */\tstruct epitem *ovflist;\t/* The user that created the eventpoll descriptor */\tstruct user_struct *user;&#125;;\n\n在这里面，我们既可以看到熟悉的mutex锁，又可以看到一个wait_queue等待队列，一个双链表，和一个rb_root红黑树节点。\nstruct list_head &#123;\tstruct list_head *next, *prev;&#125;; // 内核中的双链表\n\n抽象出来之后，其大概的结构图如下\n\n当某一个进程调用epoll_create创建epoll的文件描述符句柄的时候，操作系统就会帮我们在底层创建一个struct eventpoll结构体，内部包含了就绪队列和一个红黑树（主要关注这两个成员）\n\n调用epoll_ctl的时候，操作系统就会将我们配置的文件描述符和对于的事件添加到红黑树节点中；\n重复添加的事件也可以通过红黑树的键值唯一性检查出来（避免冗余）\n所有添加到epoll中的事件都会与设备的网卡驱动程序建立回调消息，当某个文件描述符对应的链接有信息传来的时候，就会调用回调函数，告知epoll\n网卡收到消息\n驱动程序处理，并调用对应的回调机制\nepoll通过回调消息收到事件就绪，将其链入rdllist双链表中\n上层只需要调回epoll_wait从该双链表中获取就绪事件\n\n\n该回调办法在底层为ep_poll_callback，它会将就绪的事件插入到rdllist双链表中\nepoll中每一个事件都会建立一个对应的epitem结构体\n当调用epoll_wait有事件发生的时候，只需要检查eventpoll对象的rdllist双链表中是否有epitem元素即可，有则取出；\n如果rdllist不为空，则将发生的事件复制到用户态，并将事件数量返回给用户；对比需要遍历的select/poll，这个获取就绪事件的时间复杂度是O(1)的（直接判断并取出就可以了）\n\n这一大圈操作都是操作系统自行完成的，对于用户来说是无感知的！\n关于epitem结构体，可以瞅一眼下面的注释，他也是在源码的fs/eventpoll.c文件中\nstruct epitem &#123;\t/* RB tree node used to link this structure to the eventpoll RB tree */\tstruct rb_node rbn; // 这个事件对应的红黑树节点\t/* List header used to link this structure to the eventpoll ready list */\tstruct list_head rdllink; // 这个事件对应的双链表节点\t/*\t * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the\t * single linked chain of items.\t */\tstruct epitem *next;\t/* The file descriptor information this item refers to */\tstruct epoll_filefd ffd; // 事件句柄信息\t/* Number of active wait queue attached to poll operations */\tint nwait;\t/* List containing poll wait queues */\tstruct list_head pwqlist;\t/* The &quot;container&quot; of this item */\tstruct eventpoll *ep; // 指向其所属的epollevent对象\t/* List header used to link this item to the &quot;struct file&quot; items list */\tstruct list_head fllink;\t/* The structure that describe the interested events and the source fd */\tstruct epoll_event event; // 该fd关注的事件&#125;;\n\n5.2.2 PSH标记位在学习TCP的时候，我们了解过PSH这个标记位，它的作用是告诉对端的应用层，尽快取走缓冲区中的数据。\n对于epoll而言，这个PSH的作用就是让epoll在rdllist里面新建一个就绪节点，这样上层就能知道这个文件描述符的事件就绪了（至于读不读取依旧是上层的问题）\n\n你可能会问，既然对方都发消息来催你取数据了，那不应该你的数据并没有被取走吗？这时候该文件描述符的就绪节点不应该已经存在了吗？为什么还需要额外创建一个就绪事件的节点来通知用户呢？\n\n这就涉及到epoll的两种工作策略LT&#x2F;ET了，后文会讲解；\n\n需要注意的是，epoll并没有对URG进行特殊处理，而是视之为正常的可读事件连入就绪队列，但是事件类型有所不同，可以用EPOLLPRI来关注紧急事件\n（存疑，但是没有找到相关资料，暂且这么认为）\n\n5.2.3 epoll优点一下是epoll相比poll和select的优点\n\n接口使用方便，虽然拆分了3个函数，但是每个函数的功能非常明确；不需要每次使用都重新设置文件描述符，也实现了输入和输出参数的分离\n数据拷贝轻量：在需要的时候调用epoll_ctl来处理文件描述符和事件，并不会每次调用都得大批量在用户和内核态之间拷贝数据（poll和select都需要）\n事件回调机制：使用事件回调来替代遍历，回调函数将就绪的文件描述符结构加入到就绪队列中；epoll_wait直接使用就绪队列，就能知道那些文件描述符就绪；即便文件描述符较多的时候，也能快速知道就绪的文件描述符（省去了遍历的时间消耗）\n无上限：文件描述符没有数量限制\n线程安全：在eventpoll结构体里面，我们可以看到有一个mutex锁，在linux底层已经帮我维护了epoll相关操作的线程安全性！\n\n在有些博客里面说epoll使用了内存映射机制，这种说法是错误的！因为epoll_event结构体是在用户态创建的，我们势必还是需要进行一定的用户态到内核态的拷贝。\n\n内存映射机制：linux内核直接将就绪队列通过mmap的方式映射到用户态，避免拷贝消耗（你可以理解为用户态和内核态之间的共享内存）\n\n5.3 工作模式在epoll的工作模式中，我们可以选择水平触发和边缘触发，这就好比物理实验中示波器的两种触发模式；\n假设有这样一个tcp通信的栗子：\n\n对方给我发送了2kb数据\n我通过epoll_wait成功获取到这个文件描述符的读事件就绪\n我取出文件描述符，通过recv读取了1kb的数据\n但缓冲区里面还有1kb……\n\n5.3.1 水平触发 LT所谓水平触发，就是只要fd的缓存区里面有数据，那么epoll就会一直认为这个fd的读事件是就绪的，并一直通知用户；\n\n上面的栗子中，因为用户只拿走了1kb数据，缓冲区里面还有1kb，在第二次调用epoll_wait的时候，epoll还是会报告该文件描述符的读事件就绪，让用户取走剩下的数据\n只有所有的数据都被处理完毕，epoll才不会继续通知\nLT支持阻塞和非阻塞读写\n\n因为LT模式只要缓冲区中还有剩余数据，epoll就会一直通知我们，这就允许上层不需要一次性取走所有数据，或者说不立刻处理当前缓冲区的数据。\n因此，在LT模式中，只要是事件就绪，那么缓冲区里面一定会有数据。所以它是即支持阻塞，也支持非阻塞的文件读写的！\n\nselect&#x2F;poll都是默认的LT模式，且不可以切换模式；epoll默认是LT，但可以切换到ET\n\n5.3.2 边缘触发 ET边缘触发的含义，是只有某个文件描述符的数据变动的时候，才会通知用户；反应到读事件上，只有缓冲区数据增多了，才会通知用户；\n\n在上面的tcp通信栗子中，epoll会在数据到来的时候通知用户；但即便用户没有一次性读取完毕所有数据，epoll并不会继续通知了（除非有PSH信息到来）\n在ET模式下，文件描述符的事件就绪后，只有一次处理机会。第二次你就无法得知这个文件描述符上是否还有没有读完的数据了\n因为ET模式下epoll_wait返回的次数更少，所以ET的性能远高于LT（nginx默认采用ET模式的epoll）\n因为我们只有一次机会，所以收到事件后必须立即处理\n只支持非阻塞\n\n5.3.3 LT和ET的区别因为ET模式下，epoll只会提示你一次事件就绪，所以就倒逼程序猿在收到这个事件之后，一次性处理完数据；\n当然，LT模式下你也可以这么做（如果每次都能一次性取走数据，那么LT和ET的性能差距就不大了）。但ET模式就相当于告诉所有使用者，必须这么做，减少了容错率；\n但ET的代码复杂度会增加；\n5.3.4 ET和非阻塞为什么ET必须要将文件描述符设置成非阻塞呢？\n假设下面这个场景，客户端C给服务端S发送10kb数据，在没有收到服务端对这个数据的响应之前，不会继续发送数据；\n\n但服务器一次性只读取了1KB，剩下了9KB数据在缓冲区中；因为数据没有读完，所以不会给客户端发送响应。\n\n因为epoll设置了ET模式，所以并不会认为此时的文件描述符读就绪；epoll_wait不会针对这个文件描述符返回，剩下的9KB数据会一直留在缓冲区中；\n\n注意，服务端的代码逻辑是收到就绪事件就读取一次；并不存在再次读取的可能\n\n问题就来了！\n\n服务端必须要收到就绪事件才会把剩下的9kb数据给读取完毕\n服务端想要收到就绪事件，就必须收到客户端C发来的新数据\n但客户端C认为服务器没有给自己发送响应，不会继续发送数据\n\n这就相当于一个死循环了！\n\n因此，服务端为了保证一次性能将数据全部取出，必须要采用循环读取+非阻塞的方式来将缓冲区读完！\n如果采用阻塞式，那么在轮询读取的时候，就有可能因为缓冲区已经空了而阻塞！因为我们这个是一个单线程的模型，这样会直接导致整个服务器宕机了。\n而LT则不会出现此问题，因为只要缓冲区中有数据就会通知你，所以我们可以一次读取定长，再将读到的数据拼接起来。\n5.3.5 epoll的使用场景epoll的高性能是有一定特殊场景的，如果场景不适合，epoll的性能可能表现不佳；\n\n对于多链接且链接中有一部分活跃的时候，适合使用epoll\n\n比如各种互联网APP的入口服务器，就很适合使用epoll来处理上万客户端的请求；\n如果是系统内部处理服务器和服务器之间的通信，链接数较少的情况，这种时候使用epoll并不方便。得根据具体需要选择更加适合的IO模型。\n5.4 惊群效应\n参考 https://zhuanlan.zhihu.com/p/359774959\n\n5.4.1 概念在多线程环境下，可能会遇到epoll的惊群效应；\n\n那么什么是惊群效应呢。其产生的原因是什么呢？\n\n惊群效应的具体情况是，当有多个线程或进程在 epoll 上等待某个事件（如套接字可读事件），当该事件发生时，所有等待的线程或进程都会被唤醒。然而，只有一个线程或进程可以成功地处理这个事件，而其他的线程或进程会进行不必要的竞争，可能会导致额外的上下文切换、锁竞争等问题，从而降低系统性能。\n\n以下是一个具体场景的说明\n\n在多线程或者多进程环境下，有些人为了提高程序的稳定性，往往会让多个线程或者多个进程同时在epoll_wait监听的socket描述符。当一个新的链接请求进来时，操作系统不知道选派那个线程或者进程处理此事件，则干脆将其中几个线程或者进程给唤醒，而实际上只有其中一个进程或者线程能够成功处理accept事件，其他线程都将失败，且errno错误码为EAGAIN。这种现象称为惊群效应。\n结果是肯定的，惊群效应肯定会带来资源的消耗和性能的影响，因为你无端地多唤醒了几个线程，这些线程&#x2F;进程却没有活干。\n5.4.2 多线程环境下解决办法\n专门的线程负责等待：在多线程场景下，不建议让多个线程进行epoll_wait，而用单个线程进行wait，并由该线程调用accept建立新链接，并将就绪的文件描述符交付给其他线程，来处理后续的读写操作。\n使用线程池：不为每个链接都创立一个专门的线程，而是根据读写事件，将其交付给线程池中已有线程来处理；\n使用ET模式：该模式下读写就绪的时候只会通知一次，再加上epoll本身是线程安全的，所以只会有一个线程可以拿到这个就绪事件，从而避免惊群现象；\n互斥锁：同一时间只有一个线程进行等待和事件处理；\n\n5.4.3 多进程下解决办法目前很多开源软件，如lighttpd和nginx等都采用master/workers的模式提高软件的吞吐能力及并发能力，在nginx中甚至还采用了负载均衡的技术，在某个子进程的处理能力达到一定负载之后，由其他负载较轻的子进程负责·的调用，那么nginx和Lighttpd是如何避免epoll_wait的惊群效用的呢？\n\nlighttpd的解决思路是无视惊群效应\n\n仍然采用master/workers模式，每个子进程仍然自己在监听的socket上调用epoll_wait，当有新的链接请求发生时，操作系统仍然只是唤醒其中部分的子进程来处理该事件，仍然只有一个子进程能够成功处理此事件，那么其他被惊醒的子进程捕获EAGAIN错误，并无视。\n\nnginx的解决思路是互斥锁\n\n在同一时刻，永远都只有一个子进程在监听的socket上epoll_wait，其做法是，创建一个全局的pthread_mutex_t，在子进程进行epoll_wait前，则先获取锁。当epoll_wait返回之后，nginx会调用accept把连接取出来，然后释放文件锁，让别的进程去监听。\n这是一种折衷的办法，并没有很完美，首先进程间争抢锁会有性能开耗（即使是非阻塞的锁），中间可能会有小段时间没有进程去获取锁，比如A进程拿到锁，其他进程将会过一小段时间尝试再去获取锁，而这小段时间里面如果请求量很大，A仅接受一小部分请求就让出锁，则中间过程会有一些连接事件被hang住；\n5.4.4 内核解决了惊群效应了吗惊群的根本原因在于epoll的默认行为是对于多进程监听同一文件不会设置互斥，进而将所有进程唤醒，后续的内核版本主要提供了两种解决方案\n\n既然默认不会设置互斥，那就加一个互斥功能好了，linux 4.5内核之后给epoll添加了一个EPOLLEXCLUSIVE的标志位，如果设置了这个标志位，那epoll将进程挂到等待队列时将会设置一下互斥标志位，这时实现跟内核原生accept一样的特性，只会唤醒队列中的一个进程\n第二种方法：linux 3.9内核之后给socket提供SO_REUSEPORT标志，这种方式解决得更彻底，他允许不同进程的socket绑定到同一个端口，取代以往需要子进程共享socket监听的方式，这时候，每个进程的监听socket将指向open_file_tables下的不同节点，也就是说不同进程是在自己的设备等待队列下被挂起的，不存在共享fd的问题，也就不存在被同时唤醒的可能。而内核则在驱动中将设置了SO_REUSEPORT并且绑定同一端口的这些socket分到同一个group中，当有tcp连接事件到达的时候，内核将会对源IP+源端口取hash然后指定这个group中其中一个进程来接受连接，相当于在内核级别中实现了一个负载均衡\n\n基于以上两种方法，其实epoll生态在目前来说不存在所谓的惊群效应了。而新版本的nginx也采用了 SO_REUSEPORT来解决此问题。\n除非你溢用epoll，比如多进程之间共享了同一个epfd（父进程创建epoll由多个子进程来调用），那就不能怪epoll了，因为这时候多个进程都被挂到这个epoll下，这种情况下，已经不是仅仅是惊群效应的问题了；比如说，A进程在epoll挂了socket1的连接事件，B进程调用了epoll_wait，由于属于同一个epfd，当socket1产生事件的时候，进程B也会被唤醒，而更严重的事情在于，在B进程的空间下并不存在socket1这个fd，从而把问题搞得很复杂。\n总结：千万不要在多线程&#x2F;多进程之间共享epfd！\n6.Reactor模型接下来就让我们来用epoll编写一个基于Reactor模式的服务器吧！\n6.1 什么是Reactor？\nReactor模型是基于事件驱动的，通过一个或者多个输入同时传递给服务端进行处理\n服务端请求程序处理传入的多个请求，并分发到相应的处理线程\n基于IO多路转接（多路复用）模型：多个链接通用一个阻塞对象，引用程序只需要在一个阻塞对象等待，无需阻塞等待所有链接；当有新链接或者事件就绪的时候，由操作系统通知应用程序，开始进行业务处理\n基于线程池复用线程资源：不必给每个链接单独创建线程，而是将链接完成后的业务处理交付给已有线程池中的线程进行处理，一个线程在生命周期中可以处理多个链接的业务。\n\nreactor模式有下面3种方式，参考博客 @顽石九变\n6.1.1 主从Reactor多线程模型第一种是多线程模式的，有不同的从属reactor来进行事件监控和处理\n\nReactor主线程负责监听事件并进行链接的accept\naccpet获取到链接后，分配给某一个从Reactor进行读写事件的监听\n从Reactor进行事件监听，当有新事件发生的时候，创建Handler进行事件处理\nHeadler通过read读取数据，并处理数据（这里还可以将读取数据后的响应操作分发给线程池进行处理，线程池处理完毕后返回给Handler），通过send返回给客户端\nReactor主线程可以对应多个子线程\n\n\n\n6.1.2 单Reactor多线程\nReactor通过多路转接监听客户端事件，收到事件后，进行分发\n如果是建立链接的请求，则执行accept，建立链接后，创建一个Handler完成链接建立后的各个操作\n如果不是链接请求（读写就绪）则由Reactor分发调用链接对应的读写Handler来进行处理\nHandler只负责响应具体的事件，而不进行具体的业务处理\n通过Handler中的read读取到数据后，分发给线程池子中的线程处理，处理完毕后返回Handler，再通过写方法发送给客户端\n\n\n6.1.3 单Reactor单线程第三种是单线程模式下的（半异步半同步模型），当收到某个客户端的就绪事件，就去处理这个客户端的请求。此时Handler会完成read到业务处理到send的全流程；\n本次主要写的是该模式下的操作，因为它基本是串行运行的，思路比较容易理解。但需要注意的是，这种模式支持的客户端量不应过多，否则会极大影响性能。\n\n\n6.1.4 总结三种模式用生活案例来理解\n\n单Reactor单线程，前台接待员和服务员是同一个人，全程为顾客服务\n\n单Reactor多线程，1个前台接待员，多个服务员，接待员只负责接待\n\n主从Reactor多线程，多个前台接待员，多个服务员\n\n\nReactor模型具有如下优点\n\n响应快，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的\n\n可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销\n\n扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源\n\n复用性好，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性\n\n\n6.2 代码分析话不多说，直接上代码吧！本次将所有处理模块都给拆分开来，一一进行说明\n6.2.1 Epoller.hpp首先是将对epoll的三个系统调用函数进行一定的封装，统一进行错误的判断处理。方便了其他模块的调用用；\n这部分的代码非常简单，就只在注释里写一下解析吧！\n#pragma once#include &lt;iostream&gt;#include &lt;cerrno&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;#include &lt;sys/epoll.h&gt;#include &quot;Log.hpp&quot;class Epoller&#123;public:    static const int gsize = 128;public:    static int CreateEpoller()    &#123;        int epfd = epoll_create(gsize); // 创建对应size的epfd        if (epfd &lt; 0) // 错误判断        &#123;            logMessage(FATAL, &quot;epoll_create : %d : %s&quot;, errno, strerror(errno));            exit(3);        &#125;        return epfd; // 正确返回epfd    &#125;    static bool AddEvent(int epfd, int sock, uint32_t event)    &#123;        struct epoll_event ev;        ev.events = event; // 设置event        ev.data.fd = sock;        // 给对应的socket添加到epoll中        int n = epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &amp;ev);        return n == 0; // 返回值是是否调用成功    &#125;    static bool ModEvent(int epfd, int sock, uint32_t event)    &#123;        struct epoll_event ev;        ev.events = event;        ev.data.fd = sock;        // 修改已有scoket的event        // 该socket必须先用ADD添加，否则无法修改，会返回ENOENT错误        int n = epoll_ctl(epfd, EPOLL_CTL_MOD, sock, &amp;ev);        return n == 0;    &#125;    static bool DelEvent(int epfd, int sock)    &#123;        // 删除指定socket        int n = epoll_ctl(epfd, EPOLL_CTL_DEL, sock, nullptr);        return n == 0;    &#125;    static int LoopOnce(int epfd, struct epoll_event revs[], int num)    &#123;        // 单次wait的调用，从数组里面取回就绪的文件描述符        int n = epoll_wait(epfd, revs, num, -1);        if(n == -1)        &#123;            logMessage(FATAL, &quot;epoll_wait : %d : %s&quot;, errno, strerror(errno));        &#125;        return n;    &#125;&#125;;\n\n6.2.2 Sock.hpp同select，见上文 3.2.1 socket 部分；\n6.2.3 Log.hpp一个巨简单的日志类\n#pragma once#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;cstdarg&gt;#include &lt;cassert&gt;#include &lt;cassert&gt;#include &lt;cstring&gt;#include &lt;cerrno&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define DEBUG 0#define NOTICE 1#define WARNING 2#define FATAL 3const char *log_level[] = &#123;&quot;DEBUG&quot;, &quot;NOTICE&quot;, &quot;WARINING&quot;, &quot;FATAL&quot;&#125;;#define LOGFILE &quot;serverTcp.log&quot;class Log&#123;public:    Log():logFd(-1)    &#123;&#125;    void enable()    &#123;        umask(0);        logFd = open(LOGFILE, O_WRONLY | O_CREAT | O_APPEND, 0666);        assert(logFd != -1);        dup2(logFd, 1);        dup2(logFd, 2);    &#125;    ~Log()    &#123;        if(logFd != -1)        &#123;            fsync(logFd);            close(logFd);        &#125;    &#125;private:    int logFd;&#125;;// logMessage(DEBUG, &quot;%d&quot;, 10);void logMessage(int level, const char *format, ...)&#123;    assert(level &gt;= DEBUG);    assert(level &lt;= FATAL);    char *name = getenv(&quot;USER&quot;);    char logInfo[1024];    va_list ap;    va_start(ap, format);    vsnprintf(logInfo, sizeof(logInfo) - 1, format, ap);    va_end(ap); // ap = NULL    FILE *out = (level == FATAL) ? stderr : stdout;    fprintf(out, &quot;%s | %u | %s | %s\\n&quot;,            log_level[level],            (unsigned int)time(nullptr),            name == nullptr ? &quot;unknow&quot; : name,            logInfo);    fflush(out); // 将C语言缓冲区中的数据刷新到OS    fsync(fileno(out));   // 将OS中的数据尽快写入硬盘&#125;\n\n6.2.4 TcpServer这是我们reactor模型的重点\n1.Connection类这里先定义了一个Connection链接类，比较重要的是类里面有3个回调方法的指针。在Reactor中，我们用回调方法来替代了主执行流直接调用函数的方式。线程只需要接收到这个Connection对象，就可以用回调方法来实现对链接的数据处理\nusing func_t = std::function&lt;int(Connection *)&gt;;using callback_t = std::function&lt;int(Connection *, std::string &amp;)&gt;;class Connection&#123;public:    // 文件描述符    int sock_;    TcpServer *R_;// 主服务器的类指针    // 自己的接受和发送缓冲区    std::string inbuffer_;    std::string outbuffer_;    // 读、写、异常的回调函数    func_t recver_;    func_t sender_;    func_t excepter_;public:    Connection(int sock, TcpServer *r) : sock_(sock), R_(r)    &#123;&#125;    void SetRecver(func_t recver) &#123; recver_ = recver; &#125;    void SetSender(func_t sender) &#123; sender_ = sender; &#125;    void SetExcepter(func_t excepter) &#123; excepter_ = excepter; &#125;    ~Connection() &#123;&#125;&#125;;\n\n2.TcpServer成员变量再来看看tcpserver的成员变量有什么\nprivate:\t// 接收队列的长度    static const int revs_num = 64;    // 1. 网络socket    int listensock_;    // 2. epoll的fd    int epfd_;    // 3. 将epoll和上层代码进行结合，已有链接    std::unordered_map&lt;int, Connection *&gt; connections_;    // 4. 就绪事件列表    struct epoll_event *revs_;    // 5. 设置完整报文的处理回调方法    callback_t cb_;\n\n3.构造随后便是在构造函数中初始化这些成员变量，先是从Sock.hpp中获取到监听文件描述符，然后再通过Epoller类获取到epfd句柄，最后是将listensocket放入epoll的监听中；\n这里的std::bind的作用，是将当前TcpServer的this指针绑定到TcpServer::Accepter函数的第一个参数上，否则在类外没有办法通过Connection类的回调指针来调用这个类的成员函数\nTcpServer(callback_t cb, int port = 8080) : cb_(cb)&#123;    // 当前监听的文件描述符及其事件    revs_ = new struct epoll_event[revs_num];    // 网络功能    listensock_ = Sock::SocketInit();    Util::SetNonBlock(listensock_);    Sock::Bind(listensock_, port);    Sock::Listen(listensock_);    // 多路转接    epfd_ = Epoller::CreateEpoller();    // 添加listensock匹配的connection    AddConnection(listensock_, EPOLLIN | EPOLLET,                  std::bind(&amp;TcpServer::Accepter, this, std::placeholders::_1), nullptr, nullptr);&#125;\n\n4.添加链接在AddConnection函数中，我们会将socket给添加到epfd中；如果这个epfd是使用了EPOLLET的ET模式，则还需要设置非阻塞；\nvoid AddConnection(int sockfd, uint32_t event, func_t recver, func_t sender, func_t excepter)&#123;    if (event &amp; EPOLLET)        Util::SetNonBlock(sockfd);    // 添加sockfd到epoll    Epoller::AddEvent(epfd_, sockfd, event);    // 将sockfd匹配的Connection也添加到当前的unordered_map中    Connection *conn = new Connection(sockfd, this);    conn-&gt;SetRecver(recver);    conn-&gt;SetSender(sender);    conn-&gt;SetExcepter(excepter);    connections_.insert(std::make_pair(sockfd, conn));    logMessage(DEBUG, &quot;添加新链接到connections成功: %d&quot;, sockfd);&#125;\n\n设置非阻塞的代码很简单，在前文已经演示过了\nclass Util&#123;public:    static void SetNonBlock(int fd)    &#123;        int fl = fcntl(fd, F_GETFL);        fcntl(fd, F_SETFL, fl | O_NONBLOCK);    &#125;&#125;;\n\n5.析构在析构函数中，我们需要将listensocket和epfd两个文件描述符关闭，并析构掉链接数组\n~TcpServer()&#123;    if (listensock_ != -1)        close(listensock_);    if (epfd_ != -1)        close(epfd_);    delete[] revs_;    // 还需要析构掉连接池中尚存在的connection对象    for(auto&amp;c:connections_)&#123;        delete c.second;    &#125;&#125;\n\n6.获取新连接Accept在获取新连接这里，我们采用了一个死循环来获取。这是因为对于listensocket文件描述符而言，只要来了一个新链接，在ET模式下就会提示我们。但有可能会出现我们还没有来得及取走这个链接，就又来了一个新链接的情况（可以简化理解为一次性来了两个链接）\n这时候因为ET的特性，我们就需要一次性取走所有链接；为了避免在Accept的时候，因为链接已经都被取走了而阻塞住，我们需要将listensocket设置为非阻塞；\n\n关于新链接为什么只关注读事件，在注释中有说明；\n\n对于listensocket来说，这个Accepter函数就是它的读事件回调，所以这个函数的参数也是一个Connection *conn对象，其是为了与其他事件处理函数统一（因为这个事件处理函数不在Connection类中，所以我们必须要获取一个对象才能访问到它的成员变量）\nint Accepter(Connection *conn)&#123;    while (true)    &#123;        std::string clientip;        uint16_t clientport = 0;        int sockfd = Sock::Accept(conn-&gt;sock_, &amp;clientip, &amp;clientport);        if (sockfd &lt; 0)        &#123;            // 接收函数被事件打断了            if (errno == EINTR)                continue;            // 本次数据没有准备好，可以理解为接收缓冲区空了            else if (errno == EAGAIN || errno == EWOULDBLOCK)                break;            else            &#123;                logMessage(WARNING, &quot;accept error&quot;);                return -1;            &#125;        &#125;        logMessage(DEBUG, &quot;get a new link: %d&quot;, sockfd);        // 注意：默认我们只设置了让epoll帮我们关心读事件，没有关心写事件        // 为什么没有关注写事件：因为最开始的时候，写空间一定是就绪的！        // 运行中可能才会存在写条件不满足 -- 写空间被写满了        AddConnection(sockfd, EPOLLIN | EPOLLET,                      std::bind(&amp;TcpServer::TcpRecver, this, std::placeholders::_1),                      std::bind(&amp;TcpServer::TcpSender, this, std::placeholders::_1),                      std::bind(&amp;TcpServer::TcpExcepter, this, std::placeholders::_1));    &#125;    return 0;&#125;\n\nEAGAIN or EWOULDBLOCK\tThe socket is marked nonblocking and the receive operation would block, or a receive timeout had been set and the timeout expired before data was received.  POSIX.1 allows either error to be returned for this case, and does not require these constants to have the same value, so  a  portable application should check for both possibilities.\n\n7.链接的事件处理函数其他链接的三个处理函数分别是TcpRever/TcpSender/TcpExcepter;\n首先，在处理某一个链接的时候，我们必须要保证这个链接在已有的map里面，否则代表这个链接已经被关闭或者异常退出了；同理，在异常和关闭链接的处理流程中，我们也需要将链接从map中删除\nbool IsExists(int sock)&#123;    auto iter = connections_.find(sock);    if (iter == connections_.end())        return false;    else        return true;&#125;\n\n读对于读事件而言我们也是进行循环读取，该文件描述符也需要被设置为非阻塞。读取的内容拼接到该Connection对象的输入缓冲区string中；\n在读取完毕后，我们需要在协议里面定义一个根据应用层协议字段来分离报文的函数（避免tcp的粘包问题），最终会得到一个string的数组，每个数组成员都是一个完整的报文；\n最后，我们直接一个for循环，通过该tcpserver对象在初始化时候设置的cb_函数回调指针，来处理每一个报文（为每一个报文提供服务）\nint TcpRecver(Connection *conn)&#123;    while (true)    &#123;        char buffer[1024];        ssize_t s = recv(conn-&gt;sock_, buffer, sizeof(buffer) - 1, 0);        if (s &gt; 0)        &#123;            buffer[s] = 0;            conn-&gt;inbuffer_ += buffer;        &#125;        else if (s == 0)        &#123;            logMessage(DEBUG, &quot;client quit&quot;);            conn-&gt;excepter_(conn);            break;        &#125;        else        &#123;            if (errno == EINTR) // 接收事件被打断                continue;            // 接收缓冲区空了            else if (errno == EAGAIN || errno == EWOULDBLOCK)                break; // 跳出循环            else            &#123;                // 出错了                logMessage(DEBUG, &quot;recv error: %d:%s&quot;, errno, strerror(errno));                conn-&gt;excepter_(conn);                break;            &#125;        &#125;    &#125;    // 将本轮全部读取完毕    std::vector&lt;std::string&gt; result;    PackageSplit(conn-&gt;inbuffer_, &amp;result);    for (auto &amp;message : result)    &#123;        cb_(conn, message);    &#125;    return 0;&#125;\n\n这个框架的好处就在于，你可以单独实现不同协议的报文分离函数和数据服务函数，而不需要重写TcpServer的实现，相当于解耦；\n写int TcpSender(Connection *conn)&#123;    while(true)    &#123;        ssize_t n = send(conn-&gt;sock_, conn-&gt;outbuffer_.c_str(), conn-&gt;outbuffer_.size(), 0);        if(n &gt; 0)        &#123;            // 去除已经成功发送的数据            conn-&gt;outbuffer_.erase(0, n);        &#125;        else        &#123;            // 写入操作被打断            if(errno == EINTR) continue;            // 写入缓冲区满了，没办法继续写            else if(errno == EAGAIN || errno == EWOULDBLOCK) break;            else // 异常            &#123;                conn-&gt;excepter_(conn);                logMessage(DEBUG, &quot;send error: %d:%s&quot;, errno, strerror(errno));                break;            &#125;        &#125;    &#125;    return 0;&#125;\n\n注意，这里的写入如果遇到(errno == EAGAIN || errno == EWOULDBLOCK) 这两种情况，并不能确保输出缓冲区中的数据已经被全部写入了；有可能是写入缓冲区满了导致无法继续写入；\n这种i情况下，我们需要判断outbuffer是否为空，如果不为空，则还是需要设置EPOLLOUT标记位，告知epoll继续帮我们关注写事件（这样epoll就会发信息告知Reactor，Reactor会重新调用写入函数，继续写入缓冲区的剩下数据）这个操作会在主执行流中进行统一判断\n// 主执行流conn-&gt;sender_(conn); // 主执行流调用发送函数// 判断本次是否发完毕了，没有发完毕还需要继续关心读写if(conn-&gt;outbuffer_.empty()) conn-&gt;R_-&gt;EnableReadWrite(conn-&gt;sock_, true, false);else conn-&gt;R_-&gt;EnableReadWrite(conn-&gt;sock_, true, true);\n\n// 打开或者关闭对于特定socket是否要关心读或者写//- EnableReadWrite(sock, true, false); //只关心读//- EnableReadWrite(sock, true, true);  //同时关心读写void EnableReadWrite(int sock, bool readable, bool writeable)&#123;    uint32_t event = 0;    event |= (readable ? EPOLLIN : 0);    event |= (writeable ? EPOLLOUT : 0);    Epoller::ModEvent(epfd_, sock, event);&#125;\n\n异常为了统一进行异常处理，在上文中当我们遇到读写出错的时候，都会调用这个函数；\n在这个函数体内，会将链接从epoll中删除、关闭链接、释放connection对象、将文件描述符从map里面剔除；\n需要注意的是，一定要先将socket从epoll里面剔除掉，再关闭socket！\nint TcpExcepter(Connection *conn)&#123;    // 0. 判断有效性    if(!IsExists(conn-&gt;sock_)) return -1;    // 所有的服务器异常，都会被归类到这里    // 1. 删除epoll的监看    Epoller::DelEvent(epfd_, conn-&gt;sock_);    logMessage(DEBUG, &quot;remove epoll event!&quot;);    // 2. close    close(conn-&gt;sock_);    logMessage(DEBUG, &quot;close fd: %d&quot;, conn-&gt;sock_);    // 3. delete conn;    delete connections_[conn-&gt;sock_];    logMessage(DEBUG, &quot;delete connection object done&quot;);    // 4. erase conn;    connections_.erase(conn-&gt;sock_);    logMessage(DEBUG, &quot;erase connection from connections&quot;);    return 0;&#125;\n\n8.运行对于TcpServer而言，一次的运行就是调用一次epoll_wait，再根据事件就绪的文件描述符，调用不同的事件处理函数\nvoid Dispatcher()&#123;    int n = Epoller::LoopOnce(epfd_, revs_, revs_num);    for (int i = 0; i &lt; n; i++)    &#123;        int sock = revs_[i].data.fd;        uint32_t revent = revs_[i].events;        // 判断是否出现错误，如果出现了错误，那就把EPOLLIN和OUT都加上        // 这样这个链接会进入下面的处理函数，并在处理函数中出现异常        // 处理函数中出现异常回统一调用TcpExcpter函数        if(revent &amp; EPOLLHUP) revent |= (EPOLLIN|EPOLLOUT);        if(revent &amp; EPOLLERR) revent |= (EPOLLIN|EPOLLOUT);        if (revent &amp; EPOLLIN)        &#123;            if (IsExists(sock) &amp;&amp; connections_[sock]-&gt;recver_)                connections_[sock]-&gt;recver_(connections_[sock]);        &#125;        // 当链接的写事件被激活的时候，在这里就会触发写事件的处理        // 所以并不需要在recv里面主动调用写事件处理函数        // 只需要告诉epoll让它帮我们监控写事件，那么就会在这里触发写操作        if (revent &amp; EPOLLOUT)        &#123;            if (IsExists(sock) &amp;&amp; connections_[sock]-&gt;sender_)                connections_[sock]-&gt;sender_(connections_[sock]);        &#125;    &#125;&#125;\n\n整个服务器运行起来，就一直调用分发函数就OK啦~\nvoid Run()&#123;    while (true)    &#123;        Dispatcher();    &#125;&#125;\n\n6.2.5 主执行流对于主执行流而言，要做的就是获取到命令行参数的端口，然后创建tcpserver对象并绑定事件处理函数\n#include &quot;TcpServer.hpp&quot;#include &quot;Service.hpp&quot;#include &lt;memory&gt;using namespace std;static void usage(std::string process)&#123;    cerr &lt;&lt; &quot;\\nUsage: &quot; &lt;&lt; process &lt;&lt; &quot; port\\n&quot;         &lt;&lt; endl;&#125;int main(int argc, char *argv[])&#123;    if (argc != 2)    &#123;        usage(argv[0]);        exit(0);    &#125;    TcpServer svr(HandlerRequest, atoi(argv[1]));    svr.Run();    return 0;&#125;\n\n事件处理函数可以做任意封装，来实现你自己想要的功能\nint HandlerRequest(Connection *conn, std::string &amp;message)&#123;    // beginhandler里面是具体的调用逻辑，calculator是本次事务处理函数    return BeginHandler(conn, message, calculator);&#125;\n\n这里就是我们单个完整报文的处理函数，在tcprecver方法里面被调用了；\n根据上文描述的调用方法，我们可以确定，这里传入来的message肯定是一个完整的应用层报文，我们只需要创建一个属于我们自己的协议和协议中的数据处理函数就OK了！\nint BeginHandler(Connection *conn, std::string &amp;message, service_t service)&#123;    // message一定是一个完整的报文，因为我们已经对它进行了解码    Request req;    // 反序列化，进行处理的问题    if (!Parser(message, &amp;req))    &#123;        // 写回错误消息        return -1;        // 可以直接关闭连接        // conn-&gt;excepter_(conn);    &#125;    // 业务逻辑    Response resp = service(req);    std::cout &lt;&lt; req.x &lt;&lt; &quot; &quot; &lt;&lt; req.op &lt;&lt; &quot; &quot; &lt;&lt; req.y &lt;&lt; std::endl;    std::cout &lt;&lt; resp.code &lt;&lt; &quot; &quot; &lt;&lt; resp.result &lt;&lt; std::endl;    // 序列化    std::string sendstr;    Serialize(resp, &amp;sendstr);    // 处理完毕的结果，发送回给client    conn-&gt;outbuffer_ += sendstr;    conn-&gt;sender_(conn);    if(conn-&gt;outbuffer_.empty()) conn-&gt;R_-&gt;EnableReadWrite(conn-&gt;sock_, true, false);    else conn-&gt;R_-&gt;EnableReadWrite(conn-&gt;sock_, true, true);    std::cout &lt;&lt; &quot;--- end ---&quot; &lt;&lt; std::endl;    return 0;&#125;\n\n6.2.6 协议和数据处理下面提供一个最基础的计算器协议，这个协议的好处是我们可以用telnet就模拟出请求，无需写一个tcp客户端。\nx 操作符 y#\n\n这个协议中，每个有效数据中都会带上一个空格，并以#作为单个报文的结尾；\n响应和请求的结构体格式也非常简单，响应里面是状态码和计算结果；我们在协议中添加序列化和反序列化函数就可以将响应和请求结构体转成字符串\nstruct Request&#123;    int x;    int y;    char op;&#125;;struct Response&#123;    int code;    int result;&#125;;\n\n完整代码\n#pragma once#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#define SEP &#x27;#&#x27;#define SEP_LEN sizeof(SEP)#define CRLF &quot;\\r\\n&quot;#define CRLF_LEN strlen(CRLF)#define SPACE &quot; &quot;#define SPACE_LEN strlen(SPACE)// 分离独立报文void PackageSplit(std::string &amp;inbuffer, std::vector&lt;std::string&gt; *result)&#123;    while (true)    &#123;        std::size_t pos = inbuffer.find(SEP);        if (pos == std::string::npos)            break;        result-&gt;push_back(inbuffer.substr(0, pos));        inbuffer.erase(0, pos + SEP_LEN);    &#125;&#125;struct Request&#123;    int x;    int y;    char op;&#125;;struct Response&#123;    int code;    int result;&#125;;bool Parser(std::string &amp;in, Request *req)&#123;    // 1 + 1, 2 * 4, 5 * 9, 6 *1    std::size_t spaceOne = in.find(SPACE);    if (std::string::npos == spaceOne)        return false;    std::size_t spaceTwo = in.rfind(SPACE);    if (std::string::npos == spaceTwo)        return false;    std::string dataOne = in.substr(0, spaceOne);    std::string dataTwo = in.substr(spaceTwo + SPACE_LEN);    std::string oper = in.substr(spaceOne + SPACE_LEN, spaceTwo - (spaceOne + SPACE_LEN));    if (oper.size() != 1)        return false;    // 转成内部成员    req-&gt;x = atoi(dataOne.c_str());    req-&gt;y = atoi(dataTwo.c_str());    req-&gt;op = oper[0];    return true;&#125;void Serialize(const Response &amp;resp, std::string *out)&#123;    std::string ec = std::to_string(resp.code);    std::string res = std::to_string(resp.result);    *out = ec;    *out += SPACE;    *out += res;    *out += CRLF;&#125;\n\n在service.hpp里面则是数据处理的计算函数，通过我们传入的请求，计算出结构并构造响应返回给用户\n#pragma once#include &quot;Protocol.hpp&quot;#include &lt;functional&gt;using service_t = std::function&lt;Response (const Request &amp;req)&gt;;static Response calculator(const Request &amp;req)&#123;    Response resp = &#123;0, 0&#125;;    switch (req.op)    &#123;    case &#x27;+&#x27;:        resp.result = req.x + req.y;        break;    case &#x27;-&#x27;:        resp.result = req.x - req.y;        break;    case &#x27;*&#x27;:        resp.result = req.x * req.y;        break;    case &#x27;/&#x27;:    &#123; // x_ / y_        if (req.y == 0)            resp.code = -1; // -1. 除0        else            resp.result = req.x / req.y;    &#125;    break;    case &#x27;%&#x27;:    &#123; // x_ / y_        if (req.y == 0)            resp.code = -2; // -2. 模0        else            resp.result = req.x % req.y;    &#125;    break;    default:        resp.code = -3; // -3: 非法操作符        break;    &#125;    return resp;&#125;\n\n6.2.7 测试可以看到，我们的服务启动了之后，成功接收了一个链接，并计算出了我们发送的结果\n\n多个链接也不在话下！\n\nThe end多路转接这部分是linux服务器最重要的一部分知识，因为大部分服务器都抛弃了最传统的一个线程维护一个链接这样的方式，而采用了多路转接来实现对大量进程的维护；\n本文是学习阶段的产物，有错误在所难免，请大佬们指教！\n\n","categories":["玩上Linux"],"tags":["Linux","nginx"]},{"title":"【博客】折腾记录","url":"/posts/1486215141/","content":"最近几天，折腾了一下halo和typecho，结果都不尽如人意，总感觉有哪里不舒服。兜兜转转，最终还是回到了现有的hexo解决方案上来。为了避免自己被服务器“绑架”，又把lsky的部署给下了，图床全部迁移到了对象存储上。\n\n\n1.为什么放弃了halo和typecho？本来，想更换到动态博客，就是为了避免自己再去部署一个图床。采用以大包小的想法，避免自己服务器上部署太多“我自己觉得有用的”docker容器，白白增加自己的维护成本。\n可真正了解了这两个框架后，才知道它们距离我心中的完美还有一定差距。\n1.1 服务器首先，最主要的原因还是因为动态博客框架都得需要一个服务器。\n当下我活力旺盛，也有点闲钱来维护自己的爱好。但根据入坑以来浏览个人博客社群得到的经验，再加上对自己的了解，我估计到某个时间段，我加入放弃大军，让自己的博客陷入不维护的黑洞。\n这时候，免费的解决方案就很有必要了。\n这也是hexo这类静态博客框架的最大优势之一，光是可免费部署的平台，我个人知道的就有5个以上，这其中还包含了不太可能会停止免费的github pages。这么多平台，足够你将hexo部署多个备份，哪怕最终不维护博客了，旧的博文也不至于失联。\n1.2 编辑器typecho和halo1的编辑器还算可以，但halo2就让人很是无语，它竟然只有一个富文本编辑器，而且还不支持导入MD文件，复制进去的MarkDown内容也无法正常识别！\n这给我惊住了，作为个人博客的框架，难道不应该第一时间考虑 MD 编辑器而不是富文本吗？难道大伙自己部署博客框架，有一点不就是为了避免被某个单一平台无法转换的格式绑定吗？\n虽然 halo2路线图中明确表明了会加上 md 编辑器，但现在没有就是没有……我几百篇文章，总不能一个个重新敲一遍吧?\n这里就要表扬 halo1了，其自带了一个可以导入 hexo 的 md 文件并自动识别 md 文件头部的 frontmatter 里面信息的工具，还算是给迁移提供了一点方便。\n编辑器的问题暂且不谈，毕竟这是一个可以克服的困难，下面来说说更新问题；\n1.3 更新文章问题使用 hexo 的时候，我可以将自己本地的更新 push 到 github 上，由 vercel/netlify/github-action 自动部署为 hexo 博客。\ngit 上传一次，就能够更新多篇本地有更改的文章。\n而使用动态博客，包括 CSDN，如果对旧的博文有修改，就必须要去博客后台的编辑器修改……而我个人对任何博客，准确来说是任何平台的 在线编辑器 都不报信任。一次网络波动，就可能让你几小时的心血清空。除非其能提供类似 金山文档 的自动保存多份历史版本的功能，不然看上去人畜无害的 自动保存草稿 功能，也照样会欺骗你。😭 这点就不深入展开了，体验过的人自然懂我在说什么。\n自那以后，我就把自己的所有博客从在线编辑迁移到了本地md，并配置了自己的图床（刚开始用的阿里OSS）。\nHEXO 能直接和本地 MD 对接，我想修改什么，只需要修改本地，push 到云端。很多人喜欢 Obsidian 的原因也是如此，本地直接保存的就是 markdown 的文档，想用什么打开就用什么打开，不会被单一软件捆绑。\n而使用动态博客，就会出现我很不喜欢的 多端同步 问题（指本地编写好的 md 文件得想各种办法在不同设备中同步）。\n而 halo 和 typecho 编辑器的不突出，会让这个问题更严重。其让我还是想用本地编辑器去写文章再上传，而这又得让我去部署图床\n\n不在博客框架的编辑器里面写，图片还是不能上传到部署博客系统的服务器本地，不用图床就没办法访问了，我也查过halo的picgo插件，似乎早就停止更新了\n\n那这样下来，感觉和用 CSDN 没啥区别了…… 那我还部署个人博客干嘛？\n上面说的感觉不是很清晰，列个表吧。\n动态博客更新流程理想流程如下：\n\n在动态博客后台写博客，写完即更新\n图片上传到博客服务器后台\n出现需要修改的，也是直接在后台修改\n不需要在本地额外维护 md 文件和其他图床\n\n实际由于动态博客后台编辑器体验实在是大不如本地，导致我还是想用本地编辑器写文，这就导致流程变成了下面这样\n\n在本地typora编辑\n图片通过picgo等工具上传到图床（然鹅并不能上传到博客后台）\n写完后，打开博客后台，复制粘贴更新\n\n看上去并没有特别麻烦，但这样会出现一个附加的问题：\n\n由于图片不能直接上传到博客后台，你需要额外配置一个图床\n自建图床？服务器内存 -300mb 起步；本来1h1g 就能跑博客后台，这下被迫升级2g 甚至 4g，钱包空空\n使用 OSS 对象存储？得提防恶意刷流。\n\n图床并不是我讨厌的问题，我讨厌的实际上是下面这种情况：\n\n假设我有一篇文章A，该文章引用了文章B\n由于发现 A 有误，我来修改 A（在本地修改）\n修改A的过程中，发现引用的B过时了或者也有问题，顺便修改了B\n此时我需要更新到博客\n上博客后台，我需要 搜索A和B，然后复制粘贴本地的文档来更新\n\n整个步骤一下就多起来了，麻烦的要死！\n最终可能我就会因为麻烦不想去更新某些改动不大的文章，导致我的博客上的文章落后于本地，多来几次就不知道那些文章落后了，直接进入懒人死循环。\nHEXO博客更新然而，如果用HEXO，此时就只需要执行两个命令，就能立马更新博客\nhexo clhexo g --d\n\n这其中，如果没有修改博客配置文件，hexo cl都可以不用执行；\n在同时本地修改了多篇博客的情况下，显然是HEXO更方便一键更新博客；\n目前我的博客 md 文件都是存在 obsidian 的库中的。每次使用 ob 或者 typora 编写完毕后，我会用 freefilesync 软件直接将 ob 中博客文件夹（ob 中还有非博客的其他笔记）同步到 hexo 本地库的 source/_post 文件夹中去，再执行一下 git push，就能用 netlify 或者 vercel 自动化部署 hexo。\n全程最麻烦的事情就是 git push，但还是比上文中自本地更新动态博客的方式方便了许多！\n如果你不想写提交信息，还可以用 python 或者其他语言写个自动执行 git 三板斧的 exe 脚本放到 HEXO 的 git 仓库路径下，需要更新的时候点击一下就可以了。这样下来更加方便。\nThe end剩下的下次有时间再写吧……\n本文记录的仅为本人的观点，不同人使用习惯不同，并没有抨击动态博客的意思，请不要误解！欢迎在评论区提出你的建议，友善交流！\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【网络】IP网络层和数据链路层","url":"/posts/3482559497/","content":"IP协议详解\n\n\n1.概念1.1 四层模型\n应用层：解决如何传输数据（依照什么格式&#x2F;协议处理数据）的问题\n传输层：解决可靠性问题\n网络层：数据往哪里传，怎么找到目标主机\n数据链路层（物理层）：数据在物理硬件层面上传输\n\n网络层的IP协议，就是让网络，拥有将数据从A主机发送到B主机的能力。\n\n注意：拥有此能力，并不代表每次都能成功送达！（即可靠性非100%）\n\n而失败的时候，就需要传输层来获取发生错误的原因，并进行错误重传或者超时重传等操作。\n所以，在从网络层获取到信息成功送达到对方的反馈之前，传输层需要暂时保留已经发送的数据。如果网络层发送失败了，传输层需要进行重发操作，以保证可靠性。\n\n1.2 主机、路由器、节点\n主机：拥有IP地址，但不进行路由控制的设备\n路由器：拥有IP地址，并进行路由控制的设备\n节点：主机和路由器的统称\n\n2.IP报文2.1 报文结构IP协议的报文与TCP的报文有一定程度上的相似\n下图为IPV4中报文的格式（IPV6的报文和下图是不同的）\n\n\n四位版本号：指定IP协议的版本，IPV4来说就是4\n四位首部长度：IP报头的长度（和TCP的定义一样，标准长度需要用四位首部长度 * 4字节，即最大报头长度为15*4=60字节）\n八位服务类型：包含3位优先权字段（已经弃用）、4位TOS字段和1位保留字段（必须置为0）四位TOS分别表示：最大吞吐量、最高可靠性、最小成本、最小延时。只能四选一，需要根据具体传输层的协议要求进行选择。\n十六位总长度：包括报头的整个报文的长度，减去四位首部长度就能得出报文中数据字段的长度。\n十六位首部校验和：使用CRC校验来判断报头是否有数据损坏\n八位协议：上层协议类型（比如tcp、udp、ssh等）解决如何向上层交付的问题\n八位生存时间（TTL）：用于控制IP报文能在网络层传输的时间（生命周期的限制）比如有些报文由于路由时出现了错误，陷入了路由的死循环；亦或者是路由程序出现了BUG，导致没办法被正常转发到正确的主机上；还有路由超时的问题。此时这个出错的报文就会在路由里面长时间游离而没办法抵达目的地（好比内存泄露）。规定了TTL之后，可以在IP报头中中记录报文的生命周期时间，当报文转发的耗时已经大于这个TTL之后，就将这个报文丢弃。\n三十二位源地址和三十二位位目标地址：表示发送端IP和接收端IP\n选项字段：不定长，最多40字节（这是因为首部默认是20字节，再加上首部长度最多只能表示60个字节，所以选项字段就是 60-20=40）\n此处省略了几个字段，会在后文的分片中说明……\n\nIP协议的报文中没有端口号，因为端口号是传输层应该解决的事情（UDP和TCP的报头中才有端口号的字段）IP层只关注如何将报文发送给目标主机。也就是两个主机之间如何正常通信的问题。\n2.2 分片2.2.1 认识MTUMTU相当于发快递时对包裹尺寸的限制，这个限制是不同的数据链路层对应的物理层产生的限制。\n\n以太网帧中的数据长度规定最小46字节，最大1500字节；\nARP数据包的长度不够46字节。要在后面补填充位；\n最大值1500称为以太网的最大传输单元(MTU)，不同的网络类型有不同的MTU；\n如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU了，则需要对数据包进行分片(fragmentation)；\n不同的数据链路层标准的MTU是不同的；\n\n所以，数据链路层不支持过大的数据，这就需要在网络层对数据进行分片。\n而网络层IP协议会自动帮我们分片，并在接收端组装。这个行为对传输层来说是不需要关注的，在四层模型中，每一层之间的功能需要进行解耦。\n分片之后，只要有一个分片报文丢失，这个报文的整体就会认为丢失了（因为没有办法拼出完整的报文数据）\n\n但这样就引出了一个问题：分片会提高丢包的概率，影响传输速率（发一次快递和发三次快递，明显三次快递丢东西的可能性更高）\n对于具有可靠性机制的TCP而言，丢包问题不大，我们可以在传输层进行重传。但UDP没有可靠性，此时出现分片后丢包了就没办法找回了。\n所以，网络层进行分片并不是主流！相比之下，在传输层就进行分片才是更好的选择。\n2.2.2 如何分片在IP报头中，如下字段就是用于分片和组装操作的\n\n\n十六位标识 (id): 唯一的标识主机发送的报文。如果IP报文在数据链路层被分片了，那么每一个片里面的这个id都是相同的\n三位标志字段: \n第一位保留 (保留的意思是现在不用， 但是还没想好说不定以后要用到)。 \n第二位置为1表示“禁止分片”， 这时候如果报文长度超过MTU， IP模块就会丢弃报文。 \n第三位表示”更多分片”， 如果分片了的话， 最后一个分片置为0， 其他分片报文都是1；0就类似于一个分片的结束标记\n\n\n十三位分片偏移 (framegament offset): 是分片相对于原始IP报文开始处的偏移。 其实就是在表示当前分片在原完整报文中处在哪个位置。实际偏移的字节数是这个值 * 8 得到的。因此， 除了最后一个报文之外， 其他报文的长度必须是8的整数倍 (否则报文就不连续了)\n\n这一点非常重要！一定要记住：除了最后一个报文之外， 其他报文的长度必须是8的整数倍。\n此时，只要将三位标志字段中的更多分片置为1，就代表当前报文并不是一个完整的报文，而是已经被分片后的报文。\n\n\n更多分片为0，且分片偏移为0，代表当前报文没有进行分片；\n更多分片为1，且分片偏移为0，代表当前是分片后报文中的第一个；\n更多分片为0，且分片偏移不为0，代表当前是分片报文中的最后一个；\n\n\n此时就需要根据十六位标识来确定当前分片属于哪一个“组”，再将当前报文和后续收到的ID相同的报文集合在一起，通过十三位片偏移来进行排序，组装成完整数据！\n比如，第一个报文的起始偏移量是0，第二个是1000，第三个是2000，这时候就根据片偏移排序进行拼接就可以了。（这只是个栗子）\n\n如何保证收完了？\n\n根据十六位标识，按照片偏移进行排序，排序后发现缺失了部分的报文，那就代表没有被收完。因为每一个报文的偏移量+该报文长度，就是下一个报文的偏移量！只要数据对不上，那就代表丢东西了。\n而开头和结尾的报文，就能通过上面提到的根据更多分片标记位+分片偏移来确定有没有丢。\n2.2.3 如何减少分片虽然说IP网络层会自动帮我们分片，但是否分片是可以通过传输层来进行控制的\n只要传输层一次交付的数据没有超过需要分片的阈值，那网络层在传输的时候就不会进行分片了！\n减少分片的方式，那就是在传输层就进行一定的分片，这样能更好将丢分片报文这件事在传输层进行处理。而不是在网络层丢包后，没办法在传输层失败并处理。\n\n传输层进行限制如果是TCP协议，在三次握手的时候，就会协商双方单词传输数据的大小。从而避免网络层对数据进行分片，以规避数据链路层的MTU限制。同时也维护了滑动窗口，如果网络层的传输出现了丢包，由传输层来进行重传操作，以实现可靠传输。\n\n限制成多少好呢？\n\n一般建议将该大小设置为比网络中的最小MTU值小一些，以防止出现分片\n\n后续会补上更多信息\n\n2.2.4 分片的限制在上文中提到，MTU的限制是最大1500字节，这个数据长度是包含IP协议的报头的（数据是从IP网络层向下交付给数据链路层的）\n假设我们有一个网络层的3000字节的数据，此时网络层要进行分片，并不是简单的3000/1500=2就能搞定了的。而是要计算上IP报头的长度（20字节）\n每一个分片都是一个独立的IP报文，都会有自己独立的IP报头！否则缺少报头，在接收端没有办法进行数据组装操作。\n20+148020+148020+20\n\n一共需要分3片，才能将这网络层的3000字节的数据成功传输！\n但是这里就有一个问题了，明明1480+1480+20 = 2980，并不是3000字节啊？\n注意！上面提到的是网络层的3000字节数据。实际上，传输层只向下交付了2980字节，加上IP报头20字节才是网络层的3000字节数据。因为要进行分片，原本这3000字节的统一报头肯定是要丢弃的，我们需要操作的是传输层向下交付的2980字节数据，将其正确分片并添加上每一个分片的报头，再交给数据链路层。\n2.3 TTL上文提到TTL是用来控制报文的生命周期的，其为了避免报文在路由中出现死循环。\n比如下图中，假设有一个报文路由到了路由器D，原本他应该被正常交付给主机C，但路由器D出现了一些问题，将这个报文交付给了路由器I，路由器I给J，J给H，H给C，路由器C又给D，路由器D还是有bug，又转发给了路由器I。\n这时候，就出现了一个报文路由的死循环。\n如果没有TTL来控制生命周期，报文就会一直在这个死循环中跑，白白浪费路由器的性能！\n\n规定了TTL之后，当报文的生命周期已经到了，但却还没有发送到目的地，那就需要将这个报文丢弃了。（即超了TTL的时间就认为报文无效）\n3.网段划分3.1 IP如何找到对方主机？IP如何找到对方主机呢？\n\nIP &#x3D; 目的网络 + 目的主机\n由此还衍生出网段划分\n\n以IPV4的ip为例，其格式为1.1.1.1，可以认为是下面的划分\n1.1.1  .1网段   .主机\n\n这就好比你的学号，前X位里面是学院的代码，最后才是班级+班级内编号。先找到你所在学院，再找到班级，最后再找到你。\n反馈到IP里面，就是先找到网段，再找到主机。\n3.1.1 发送数据的本质IP就是先找到目的的网段，再找这个网段中的目的主机。（先根据目的网段进行路由，找到目的网络，再通过主机号找到目的主机）\n而查找目的主机的过程，本质是一个排除的过程。\n先通过网段排除一个大类，再通过主机号来排除该网段中的单个主机。这样就能避免我们一个一个遍历在全网中查找主机，提高了查找的效率\n\n子网划分的目的：就是提高查找目标主机的效率\n\n这也是学校里面用学号的原因，除了为了给每个学生提供一个唯一标识，还能通过学号来提高查找到某一个学生的效率。\n在全球互联网上，同样是通过IP地址的网段来划分国家，再划分到每个国家内部的不同区。这时候就会有一定IP地址资源的竞争。比如米国互联网发展早，下图中谷歌的服务器IP就老整齐了😂（不过这些服务器都在同一个地域，IP很接近是合理的）\n\n3.1.2 网络号和主机号\n网络号：保证相互连接的两个网段具有不同的标识\n主机号：在同一网段中，主机之间具有相同的网络号，但是主机号不同以进行区分\n\n具体框架可以查看下图，192.168.128就是这个局域网的网段 ，而最后的10和11是不同主机的两个主机标识。一般情况下，网段中的1号主机就是这个网段中的路由器。\n\n我们家里的路由器除了进行路由转发，还有子网划分的功能。\n\n如果出现了一个开头并非192.168.128的IP，主机就能知道这不是当前局域网的IP，于是就会将报文直接转发给192.168.128.1，让路由器去找这个IP的目标主机（进行跨局域网的下一层转发）\n\n就好比我们的学号是学校的教务系统派发给每一位同学的，IP中的网段也被“某人”在一定程度上根据地区进行了划分。\n3.2 IP地址类别划分3.2.1 ABCDE通过A到E类不同的划分，会衍生出不同范围的IP号，然后再分配给不同的国家或地区\nA类 0.0.0.0到127.255.255.255 B类 128.0.0.0到191.255.255.255 C类 192.0.0.0到223.255.255.255 D类 224.0.0.0到239.255.255.255 E类 240.0.0.0到247.255.255.255\n\n\n依照上面的划分，如果我是一个大型企业，申请了一个B类的IP地址。此时就能支持我的局域网内2^16台主机的ip分配。但实际上我顶多会有2w个主机，此时就出现了IP地址的浪费！\n3.2.2 CIDR和子网掩码为了避免上文中出现的IP浪费问题，CIDR（Classless Interdomain Routing）就出现了\n\n引入一个额外的子网掩码(subnet mask)来区分网络号和主机号；\n子网掩码也是一个32位的正整数. 通常用一串 0 来结尾，一串 1 开头；\n将IP地址和子网掩码进行 按位与 操作, 得到的结果就是网络号；\n网络号和主机号的划分与这个IP地址是A类、B类还是C类无关\n\n如果我们需要更多主机，就可以将子网掩码中最后一个1置0，就能适配更多局域网主机。\n所以，现在已经不用ABCDE的类别划分方式了，都采用了子网掩码方式。\n\n根据上图可见，IP地址与子网掩码做与运算可以得到网络号，主机号的二进制位从全0到全1就是子网的地址范围； \nIP地址和子网掩码还有一种更简洁的表示方法：例如140.252.20.68/24,表示IP地址为140.252.20.68, 子网掩码的高24位是1，也就是子网掩码255.255.255.0\n3.3 基础设施有了网段划分，给不同国家和地区划分了IP之后，就需要有人来建设网络的基础设施\n在我们国家，搞基础设施就是三大运营商（移动 电信 联通）\n比如几年前做的“光纤入户”就是基础设施建设的一部分。\n基础设施搭建好了后，再通过子网掩码和已经获取到的IP的网段来划分不同省份、不同市区；最终再落到每个入网用户的头上。\n3.4 缓解IP地址不够用的办法有人肯定会问了，现在公网IPV4的资源那么匮乏，大部分家宽都是没有公网ip的，那我们平时的上网是怎么实现的？\n换句话说，如何缓解IP地址的匮乏？\n\n可以使用动态IP分配技术，只给直接接入公网的设备分配IP地址，每一个设备接入网络时，其获取到的IP地址不一定和上次相同。\nNAT技术（重点）\nIPV6（但是现在普及率有待提高）\n\nIPV6使用16字节（128位）来标识一个IP地址，目前看来，2^128 位能给“地球上每一粒沙子”都分配一个IP地址了。虽然迟早也会有不够用的那一天，但至少是一个很不错的解决方案。我们国家就在大力推广IPV6\n通过前文的报文结构图可知，IPV4的IP地址只有4字节（32位）\n\n4.私有IP4.1 特殊的IP地址但是，直接采用CIDR的方式作为局域网控制的方式，就容易出现混乱。而且即便是采用了子网掩码的方式，依旧可能出现IP不够用的情况（一位网民很可能有多个设备， 再加上各类智能终端，现在需要上网的设备只会越来越多）\n需要注意的是CIDR只能提高IP地址的利用率，并不能提高IP地址的上限。\n所以，就衍生出了部分特殊的IP地址。这些IP地址被规定只能用于局域网，由此来减少对公网IP的地址消耗。\n\n将IP地址中的主机地址全设为0，就是该地址的网络号，代表当前局域网\n将IP地址中的主机地址全设为1，就是广播地址，用于给同一个链路中相互连接的所有主机发送数据包。\n127.*的IP地址用于本机回环。我们通常使用127.0.0.1来进行本地服务的访问和测试，该IP地址是IPv4回环地址的标准规定，IPv6的回环地址为::1。\n\n我们在计算一个局域网中有多少设备的时候，需要减掉上文提到的网络号和广播地址。\n\n以下是特殊的只能用于局域网的私有IP地址，包含在这个范围中的， 都称为私有IP， 其余的则称为全局IP (或公网IP)\n\n10.*, 前8位是网络号，共16,777,216个地址 \n172.16.到172.31.，前12位是网络号，共1,048,576个地址 \n192.168.*，前16位是网络号，共65,536个地址\n\n这里要记住2的16次方为65536，在网络的知识点里面经常会接触到这个数字。\n4.2 loopback环回上文提到了127.*是用于本地环回的。下图是环回驱动程序针对IP地址的判断\n\n在云服务器上执行ifconfig，也能看到本地环回的配置项；这里我们能发现，本地环回的MTU是远高于网络的1500。毕竟是自己和自己通信，基本不会出现丢包，传输速度也是飞快，也就不用担心数据包太大的问题\n同时也能发现，我们的云服务器被分配到的ip地址并不是云服务器的公网ip，这也就表明了我们的云服务器并没有被直接暴露在公网上，而是通过了云服务器厂家的入网服务器（或者也叫路由器）来进行公网ip的映射和数据包的转发操作。\neth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 10.0.12.2  netmask 255.255.252.0  broadcast 10.0.15.255        inet6 fe80::5054:ff:fec9:274f  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 52:54:00:c9:27:4f  txqueuelen 1000  (Ethernet)        RX packets 277674393  bytes 80031748700 (74.5 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 302405663  bytes 162670581730 (151.4 GiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 111135687  bytes 27644436547 (25.7 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 111135687  bytes 27644436547 (25.7 GiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\n4.2.1 环回上图中的环回驱动程序会直接和IP协议的接收端（即IP输入函数）相连，当检测到 127.0.0.1 的IP访问请求的时候，会直接把这个报文转发给IP输入函数，而不将其插入到以太网中。\n就相当于你知道 127.0.0.1 这个IP地址代表的就是你自己，你想访问自己电脑上8080端口的程序，即便么有接入互联网的状况下也是能正常访问的！\nLoopback环回接口对于测试和诊断本地主机上的网络服务和应用程序非常有用，因为它可以模拟网络通信而不涉及实际的网络传输。\n4.2.2 ARPARP是一个在局域网数据链路层通过IP获取到局域网主机MAC地址的协议，具体请参考后文中的解析\n\n4.3 访问广域网的步骤4.3.1 说明下图中能看到我们家用主机是怎么来进行广域网的访问的基本流程；\n我们家里的路由器除了进行路由转发，还有子网划分的功能。可以看到左下角虽然是两个不同的家庭，但其可以分配出完全一样的局域网的子网ip 192.168.1.1，和不同的WAN口IP（WAN口就是路由器连接互联网的口）\n这是因为我们的设备是直接和当前路由器相连的，访问的时候也只能通过当前路由器来进行局域网IP的转发。不可能会出现我访问一个局域网IP，却跑到了别人家里的设备上的情况。因为这个局域网IP访问的报文并不会被转发到上层路由器上，也就不可能凭空飞到其他局域网中\n\n图中的 122.77.241.3 就是一个公网IP的服务器，当我们需要访问这个主机的时候，局域网的家用路由器在检测到这个目的IP的时候，发现其并不是局域网的IP地址，于是就会将这个报文给转发给上层的运营商路由器。\n运营商路由器是直接接入了公网IP的，其就能通过网段划分+主机编号来查找目标主机，将报文转发给 122.77.241.3  服务器，再将服务器返回的信息转发给你的家用路由器，再转发到你的主机上。\n这也告诉我们，想绕过运营商直接获得公网IP是不可能的，因为从物理层面上，我们的家用路由器就不是接在公网IP上的！即便是可以申请到的家用公网IP，也和云服务器的入网服务器一样，是运营商的路由器分配给你的。\n\n你会发现，家用申请的公网ip，很多端口都是被屏蔽的（比如 80/443/8080）这些端口的屏蔽操作，以及海外网站的「墙」也是运营商的路由器进行检测和屏蔽的！\n\n4.3.2 内网访问公网的流程假设我们的模型如下\n广域网  ↓运营商路由器C （公网IP是122.77.241.4）  ↓家用路由器B （运营商路由器分配私有IP 10.1.1.2）  ↓家用主机A （家用路由器分配私有IP 192.168.1.201）\n\n下面是一个家用主机A，访问公网IP的主机 122.77.241.10 的具体步骤；\n本地主机A发送IP报文给家庭路由器B————————————————————————| 源IP：192.168.1.201   || 目的IP：122.77.241.10 |————————————————————————路由器B收到报文后，检测目的IP，发现并不似局域网的IP于是交付给上层的运营商路由器C；报文的源IP被修改为家用路由器B的wan口IP————————————————————————| 源IP：10.1.1.2        || 目的IP：122.77.241.10 |————————————————————————运营商路由器C收到报文后，发现其也不是自己所在内网 10.1.1.* 的局域网IP于是开始执行广域网IP寻址操作，找到目标公网IP的主机，再将报文发送给该主机；此时发送的报文又被改成了————————————————————————| 源IP：122.77.241.4    || 目的IP：122.77.241.10 |————————————————————————\n\n4.3.3 NAT技术这种不断替换源IP来进行路由转发的过程，就是NAT技术！\n也正是NAT技术的存在，让我们能通过多级局域网来让更多的设备上网，大大缓解了公网IP的不足。\n也正是因为IPV4地址不足的问题被大大缓解，推广IPV6就没有我们想象中的那么顺利了。毕竟IPV6的IP格式和V4完全不同，需要每个层级的路由器都进行功能升级，这可是一个巨大的工程！\n\n4.3.4 NAT怎么回来？NAPT当目标主机收到这个报文后，他的反馈报文如下\n————————————————————————| 源IP：122.77.241.10   || 目的IP：122.77.241.4  |————————————————————————\n\n同样是先到达运营商路由器，运营商路由器需要缓存每一个转发到公网的报文的来源信息；为此路由器会维护一个转换表，记录着局域网主机的私有IP地址:端口号与对应的公网IP地址:NAT端口号的映射关系。\n比如此次TCP链接中，我将路由器公网IP的122.77.241.4:30000映射给了局域网10.1.1.2:40000；当从公网收到服务器的响应报文后，从转换表里面就能够查到这个映射（一次通信中这个NAT映射是不会变的）从而确定该报文的局域网流向。\n\n需要注意的是，NAT技术在端口映射的时候不一定会映射到和内网主机相同的端口，此时不仅需要修改IP报文中的来源IP，还需要进一步修改传输层（比如TCP和UDP）中的源端口号\n\n确定局域网IP后，就修改当前报文的目的IP，继续往局域网转发；后面的子路由器也是如此，不再赘述。\n————————————————————————| 源IP：122.77.241.10   || 目的IP：10.1.1.2      |————————————————————————\n\n这种IP:端口的关联关系表，就是由支持NAT技术的路由器来维护的，这个转换表被称为NAPT；当这次链接结束后，这对映射关系就会从转换表中被删除。\n\n4.3.5 NAT和代理服务器代理服务器看上去和NAT设备有一定类似，客户端向代理服务器发送请求，代理服务器将请求转发给真正需要请求的服务器；服务器返回结果后，代理服务器把结果传回客户端。\n4.3.5.1 NAT和代理服务器的区别？\n从应用来说，NAT是属于网络基础设置，解决的是公网IP不足的问题；代理服务器更贴近具体应用，比如通过代理服务器进行“翻墙”和游戏加速；\n从底层来讲，NAT在网络层工作，对IP地址进行替换；代理服务器是在应用层工作；\n从使用范围来讲，NAT一般部署在局域网出口，代理服务器既可以在局域网又可以在广域网部署\n从部署位置来看，NAT集成在路由器或者防火墙的硬件上；代理服务器本质上是一个应用层软件，部署在服务器上\n\n代理服务器应用相对来说也比较广\n\n翻墙：广域网代理\n负载均衡：局域网代理\n\n4.3.5.2 反向代理代理服务器分为正向代理和反向代理，这里来说说反向代理，反向代理处于目标服务器和客户端之间，客户端通过反向代理访问目标服务器，而不会直接连接到目标服务器\n\n通过反向代理服务器作为一个云服务器主机集群的入网服务器\n举例，一个网站拥有10台提供服务的服务器和一台反向代理服务器\n域名解析到反向代理服务器\n反向代理服务器通过服务器监控程序，获取到10台服务器中负载最低的那个，并将报文转发给它\n反向代理服务器还会识别10台服务器中是否有宕机的服务器，如果有，则会告警给维护人员，并不再给这个宕机的服务器转发报文\n反向代理服务器还可以设置黑白名单，当遇到DDOS攻击的时候，将来源IP放入黑名单进行屏蔽，避免过多的访问让所有服务器都宕机影响业务；将本公司的其他服务器放入白名单（一般白名单都很短）\n\n反向代理的作用\n\n通过反向代理服务器实现了负载均衡\n便于统一管理服务器集群，提供统一入网服务器\n避免了直接将提供服务的主机IP暴露在公网上而被直接攻击的问题，提高了安全性。\n反向代理还能对网页内容进行一定的缓存，从而减轻后端服务器的负担（比如缓存网页前端的静态资源，当用户访问的时候，由代理服务器直接返回资源，而不需要去请求实际提供服务的服务器）\n\n总之好处多多！\n4.3.5.3 正向代理正向代理是位于客户端和目标服务器之间的中间服务器。客户端通过正向代理来访问互联网上的资源，而不是直接连接到目标服务器。正向代理的作用主要有以下几点：\n\n访问控制和过滤： 正向代理可以用于限制用户访问特定网站或资源，以实施访问控制策略。它可以过滤不良内容，提供更好的安全性和隐私保护。\n隐藏客户端身份： 正向代理可以隐藏客户端的真实 IP 地址，从而保护用户的隐私和匿名性。目标服务器只能看到代理服务器的 IP 地址，而无法获取到真正的客户端信息。\n缓存和加速： 正向代理服务器可以缓存常用的内容，从而减少对目标服务器的请求，提高访问速度。\n突破防火墙限制： 在一些网络环境中，访问特定网站可能受到限制或封锁。使用正向代理可以绕过这些限制，访问被封锁的资源。\n\n4.4 ISP检测宽带账户\n下文中的部分内容来自chatgpt，我对里面的内容进行了补充和修改\n\n运营商的路由器还会检测我们的账户是否还有余额。我们的家用路由器一般是通过光猫登录了自己的宽带账户；也可以将光猫设置成桥接模式，将接入光猫的路由器设置为宽带帐号（PPPoE）上网方式，登录运营商提供的宽带账户和密码，来接入网络。\nISP的路由器检测你的宽带账户通常是通过以下步骤来完成的：\n\n设备连接与识别： 当你的计算机或其他网络设备连接到ISP提供的路由器时，路由器会分配一个私有IP地址给你的设备。这个IP地址是由路由器动态分配的，并且通常处于特定的私有IP地址范围，比如10.11.1.0/16或10.11.1.0/24等。此时，你的设备与路由器建立了一个大局域网内的连接。（运营商并不会直接给你分配192.168.*这样的私有IP，因为这个IP一般是用于最底层局域网的，给你分配了，那家庭局域网的就没IP用了）\n认证过程： 在你尝试访问互联网时，ISP的路由器会引导你的设备进行认证过程。这通常涉及向ISP服务器发送你的宽带账户的登录凭据（例如，用户名和密码）。\n账户验证： ISP的服务器会验证你提供的登录凭据是否与其记录中的账户匹配。如果验证成功，说明你的宽带账户是有效的，路由器会为你的设备分配一个公共IP地址，这个IP地址是可供互联网访问的。\nIP地址分配： 一旦认证成功，ISP的路由器会为你的设备分配一个公共IP地址。这个IP地址是在互联网上唯一标识你的设备的地址，使你的设备可以与其他互联网设备进行通信。\n数据传输： 一旦有了公共IP地址，你的设备就可以与互联网上的其他设备进行通信，发送和接收数据。\n\n这样，通过认证和IP地址分配的过程，ISP的路由器可以检测并识别你的宽带账户，从而让你的设备能够访问互联网。\n人话就是，登录了宽带账户以后，当我们路由器发送的报文交付到运营商路由器的时候，该路由器就会检测你这个宽带账户的余额。如果没有余额了，就会直接丢弃掉你的IP报文。我们看到的结果就是无法上网！\n\n这个操作并不是每次都会执行的，只要你的路由器能稳定的接入到运营商的路由器上，那就不会每次都进行宽带账户的验证，否则会增加网络的负担。\n具体的验证流程都是运营商路由器和你的本地光猫自动完成的。\n\n而手机没有话费余额的时候，我们依旧能拨通诸如120、119等紧急号码，这也是运营商的服务对这些特殊的电话号码做了类似于免费白名单的操作（手机号码可以类比公网IP来理解）\n5.域名5.1 DNS服务器上文讲述的都是关于IP协议的事情。但实际上我们日常生活中，一般都不会直接使用IP地址+端口号的方式来访问某一个服务，而是使用域名来访问。比如\nwww.baidu.comwww.google.com\n\n所谓域名，就是这些英文字符串和IP的映射。\n比如baidu.com就是一个域名，而www.baidu.com是该域名下的三级域名（几级域名可以看有几个点）\n实际访问的时候，是百度在域名注册商哪里，将www.baidu.com指向了自己的服务器的地址(假设指向的是1.1.1.1) 我们访问百度，实际上访问的就是 IP地址 1.1.1.1；\n\nDNS是应用层协议，底层使用的是UDP\n系统会缓存一部分DNS的结果\n\n在主机本地，有一个hosts文件，也可以用于设置主机到域名的映射，在linux里面就是/etc/hosts这个文件。 在访问域名的时候，操作系统会先检查自己本机器的hosts，如果本地没有，就请求DNS服务器来获取解析结果。\n5.2 域名访问主机流程当我们访问一个域名的时候，首先会去请求特殊的DNS服务器\n8.8.8.8 谷歌公司的DNS服务器119.29.29.29 腾讯提供的公共DNS\n\n先请求这些DNS服务器，服务器内会针对域名查询对应的DNS解析，最后再访问该解析对应的IP地址\n而使用域名的时候，默认访问的是该主机的 80(HTTP)/443(HTTPS) 端口 ，我们也可以像IP一样，在域名之后用:端口 来指定特定端口号进行访问，即域名:端口。\n一般情况下，我们的主机都可以通过自动配置DNS从上层路由器中获取到DNS服务器的地址（比如运营商会在路由器基站中内置DNS服务器）\n5.2.1 DNS劫持所谓DNS污染和DNS劫持，就是因为我们访问的DNS服务器的时候，获取到的结果和预期不同，从而导致无法访问目标网站，或者访问了假的目标网站\nwww.baidu.com 明明应该指向 1.1.1.1但被坏蛋劫持了DNS解析，变成了指向 1.1.1.3\n\n坏蛋可以在 1.1.1.3 服务器上，搭建一个和百度「看起来」一模一样的页面，并将你的报文给转发到百度服务器上。此时他就通过中间转发，获取到了你报文中的用户信息、密码等等参数；\n这时候因为这个假的服务器是直接给你提供服务了，使用的HTTPS证书也是这个假服务器的证书，对方可以直接通过自己的证书解密获取到你的信息，再转发给百度。\n5.2.2 DNS和负载均衡对于大公司而言，DNS解析还有一个重要的作用，就是通过不同区域的设置来实现负载的均衡。\n假设百度在每一个省份都设立了一个自己的机房，那么它就可以通过DNS服务器，当不同省份的用户请求服务器的时候，返回他当前所处省份的机房地址。这时候就实现了每个机房的负载均衡。\n在现实中，就是将你的请求转接到离你最近的拥有机房的省份，这样既能保证所有服务器的负载均衡，又能保证你的访问能较快地获取到响应（广东访问广州的服务器，肯定比访问北京服务器的延迟低一些）\n5.3 DNS分层DNS服务器不会存放所有已知域名的IP解析，因为互联网上存在大量的域名，数量庞大且不断增长，单一DNS服务器无法存储和处理所有域名的IP映射。\n实际上，DNS服务器通过分层的架构来解决这个问题。在根DNS服务器层级，有一组全球性的顶级DNS服务器，它们存储顶级域名（例如.com、.org、.net等）的IP地址。然后，在每个顶级域名下，有其他DNS服务器，负责管理该顶级域名下的子域名（例如，google.com、facebook.com等）。这个过程继续向下，形成了一个层级结构。\n当你的设备需要解析某个域名时，它首先会向本地DNS服务器（通常由你的ISP，即互联网服务提供商，人话就是国内的三大运营商提供）发起请求。如果本地DNS服务器知道所需域名的IP地址，它会直接返回该IP地址给你的设备。但如果本地DNS服务器不知道该域名的IP地址，它会向根DNS服务器发起请求。\n根DNS服务器将指导本地DNS服务器转向相应的顶级DNS服务器。然后，顶级DNS服务器可能会进一步将请求转发给负责该特定域名的授权DNS服务器。最终，这个授权DNS服务器将返回所需域名的IP地址给本地DNS服务器，本地DNS服务器再将其返回给你的设备。\n这个层级结构允许DNS系统更高效地处理大量的域名解析请求，并确保及时更新和管理域名与IP地址的映射。所以，单个DNS服务器并不会存放所有已知域名的IP解析，而是通过层级结构来分散和管理这些信息。\n\n5.4 dig工具分析DNS解析过程yum install bind-utils\n\n安装了之后就可以使用dig命令来查看域名解析过程了\ndig 域名\n\n6.路由路由的过程，就是下图这样一跳一跳(Hop by Hop) “问路” 的过程\n所谓 “一跳” 就是数据链路层中的一个区间。具体在以太网中，指从源MAC地址到目的MAC地址之间的帧传输区间。\n\n6.1 问路栗子（帮助理解）拿日常生活中问路来举例子（请屏蔽现在有导航这件事）一般问路，会得到三种结果：\n\n我不知道\n我知道XXX知道\n我不知道，但是给你乱指（在路由寻址的过程中，这个情况是不存在的）\n\n比如张三要去南京大学的仙林校区，他飞机落地南京后，不知道怎么走；他找了个机场的保安，问他“我是从xx省新来的大学生，应该怎么去南京大学？” 保安让他先坐xx路公交车去仙林大学城，到哪里再去问其他人。\n张三到了仙林大学城后，又找到了路边的环卫工，又问“我从机场过来，应该怎么去南京大学。” 环卫工给他指了条明路，那里就是南京大学的教学楼，入口就在这附近。这时候张三获取了两个人（路由器）的帮助，成功递达了南京大学的仙林校区（目标主机）。\n可以看到，问路和上面图示中IP报文的路由是很相似的，都是一个路由一个路由的“问路”，最终找到目标主机。\n\n6.2 路由表报文在各个路由器之间路由也是如此。当一个路由器遇到一个IP报文\n\n他首先检测这是不是自己分配的局域网中的IP，是则可以直接转发到目标主机；\n不是则查看自己的路由表，看看自己是否保存了这个IP应该往哪里走；\n如果它自己不知道，则可以和其他与自己相连的路由器通信（信息同步），问他们这个IP应该给谁（就好比你在公司里面问某一个工作应该交给谁去做）\n如果周边的路由（旁边的路人）都不知道该往哪里去，则路由器会将其交付给自己的默认路由，报文继续转发，去下一个人那里问路了。\n\n这样的跳跃都会有一个前提条件：相邻的两个主机（或路由器）一定是在物理上相连，处于同一局域网之中。每次的跳跃，本质上是从一个子网跳到另外一个子网；广域网可以认为是最大的“子网”\n\n6.3 route命令\n在windows电脑上可以使用  route print 命令打印路由表，本文不关注windows平台。\n\n在linux平台里面，可以通过route命令查看当前主机的路由表，在Centos8主机上，命令显示如下。\n可以看到，路由表的名字叫做 内核IP路由表，这也是linux系统中的一个内核数据结构。内部维护了路由表的目的地、Gateway网关、Genmask掩码、Flags标志位、Metric、Ref、Use、Iface接口\nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         _gateway        0.0.0.0         UG    100    0        0 eth0172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-96d69eeef1ac172.19.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-fa4aff4c583e\n\n\nFlags中，U代表当前路由表的条目是有效的，G代表其是一个路由器。\nGateway中，_gateway以及0.0.0.0代表的都是默认网关\nIface中，只有eth0是一个真正的物理网络接口，而docker0/br-*都是docker容器虚拟出来的桥接网络接口\n\n假设我我们有一个目的IP是 172.16.0.2，获取到这个IP后，系统就会将其和路由表中的子网掩码依次进行按位与；\n在linux环境下，可以使用如下代码来进行这两个IP的按位与操作。其中inet_addr 和 inet_ntoa是linux下的两个系统调用接口。用于IP字符串到无符号整数之间的转换，具体的介绍可以阅读我的 UDP博客\n#include &lt;iostream&gt;#include &lt;arpa/inet.h&gt;int main() &#123;    // 将点分十进制的IP地址和子网掩码转换为无符号整数    unsigned int ipAddress = inet_addr(&quot;172.16.0.2&quot;);    unsigned int subnetMask = inet_addr(&quot;255.255.0.0&quot;);    // 进行按位与操作得到网络地址    unsigned int networkAddress = ipAddress &amp; subnetMask;    // 将网络地址转换回点分十进制表示法并输出结果    struct in_addr addr;    addr.s_addr = networkAddress;    std::cout &lt;&lt; &quot;IP地址: &quot; &lt;&lt; &quot;172.16.0.2&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;子网掩码: &quot; &lt;&lt; &quot;255.255.0.0&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;网络地址: &quot; &lt;&lt; inet_ntoa(addr) &lt;&lt; std::endl;    return 0;&#125;// 非linux环境可以使用下方的代码进行处理void ip_and_gmask_test() &#123;    unsigned int ipAddress = 172 &lt;&lt; 24 | 16 &lt;&lt; 16 | 0 &lt;&lt; 8 | 2; // 将 IP 地址转换为 32 位无符号整数    unsigned int subnetMask = 255 &lt;&lt; 24 | 255 &lt;&lt; 16 | 0 &lt;&lt; 8 | 0; // 将子网掩码转换为 32 位无符号整数    unsigned int networkAddress = ipAddress &amp; subnetMask; // 按位与    std::cout &lt;&lt; &quot;IP地址:  172.16.0.2&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;子网掩码: 255.255.0.0&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;网络地址: &quot; &lt;&lt; (networkAddress &gt;&gt; 24) &lt;&lt; &quot;.&quot; &lt;&lt; ((networkAddress &gt;&gt; 16) &amp; 255) &lt;&lt; &quot;.&quot; &lt;&lt; ((networkAddress &gt;&gt; 8) &amp; 255) &lt;&lt; &quot;.&quot; &lt;&lt; (networkAddress &amp; 255) &lt;&lt; std::endl;&#125;\n\n二者输出结果都是172.16.0.0\n得到输出结果后，再和路由表中该项的Destination进行对比，二者相等，代表当前IP就是需要通过该项进行路由，那就将这个报文通过Iface接口eth0发送出去就OK了\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0\n\n如果按位与的结果与Destination匹配不上，那就继续往下一个条目的子网掩码进行按位与。如果整个表都按位与完毕了，还没找到该去的地方，那就将其通过default默认路由发送出去。\n7.数据链路层前面谈了一大堆将数据从一个主机到路由器再跨越多个路由器递达目标主机的流程。\n要想实现这一点，我们还需要数据链路层的帮助，即实现同一局域网内两台主机在物理层面上的相互通信。\n\nIP网络层：提供跨网络找到正确路由路径，并传输数据的能力\n数据链路层：提供将数据在同一网络中传输的能力\n物理层：实际上的数据在物理（网线）上传输\n\n数据链路层也有不同的传输方式，本文主要关注当前主流的以太网；\n需要注意的是，以太网不是一种具体的网络，而是一种技术标准。它即包含了数据链路层的内容，也包含了一些物理层的规定，比如拓扑结构和访问控制方式，传输速率等。\n\n7.1 认识局域网的基本情况7.1.1 局域网认识不过在认识以太网之前，我们需要先知道局域网通信的一个基本情况；假设下图中就是一个局域网，其中包含了不同的主机\n\n首先，如果想要两台主机能够通信，我们就需要先将其链接到同一根网线上（在这里暂且不管WIFI，其实本质上也是连在了这根网线上）；这就好比进程间通信的时候，你需要先能看到同一份资源，才能实现对这份资源的共享访问。\n虽然我们认为在局域网里面通信的时候，是两台主机直接交流，但实际上你可以把局域网当作一个教师，当张三和李四沟通的时候，其实会有很多其他的吃瓜群众都能接收到你发送的这个信息。\n反馈到以太网报文上，因为每个主机都是知道自己的地址的，所以只要检测到以太网报头中的目的地址不是自己的时候，就可以丢弃掉这个报文。因为目标并不在和你说话。这就好比在教室里面，你隔壁有俩人在聊天，他们并没有和你交谈，所以你可以不用管他们聊了什么。\n\n这也反馈出了为什么某些公共WIFI会不安全，因为只要接入了这个WIFI，你就有办法检测到其他用户通过这个局域网发送了什么信息！\n\n因为局域网内的主机是通过目的地址判断有没有人和自己聊天的，所以即便我们的电脑开机后什么事情都没有干，在操作系统底层（数据链路层）其实一直都在从局域网中拿到新的数据链路层报文，并检测是否是发给自己的报文：\n\n是，向上交付\n否，丢掉\n\n7.1.2 碰撞域由于数据链路层向下是直接交付给物理层的，在物理层（网线）中光电信号传输是不能同时传输多个数据的，这就要求我们同一个局域网的多台主机不能同时往局域网中发数据。为了解决这个问题，主机引入了休眠机制，通过不同时间的错开休眠，来避免两台主机同时往局域网中发数据的情况。\n\n理想情况：同一时间只有一台主机在局域网中发送数据\n碰撞问题：如果出现了同时发送，数据出现冲突，就需要剔除掉这部分数据\n\n通过碰撞域解决数据冲突问题，尽量达到理想情况；\n比如我们的交换机就有划分碰撞域的功能。接到交换机上的设备，除了通过交换机进行路由转发，如果在交换机的这部分设备中出现了数据碰撞，那么交换机就能把碰撞控制在当前这个小的碰撞域内，而不会向更大的局域网中传播。\n\n如果一个局域网里面只有一个交换机（路由器）那么这整个局域网共享碰撞域\n\n所以大公司内为了避免局域网因为碰撞问题而导致的网络卡顿，一般都会将几台电脑接入一个小的交换机中来划分碰撞域。\n如上是物理层面的事情，软件层面上，一个MAC帧不要太大，否则会大大增加碰撞的概率。所以MAC帧必须要对上层交付的数据大小提一个要求，不能交付太大的数据，这就是MTU的由来（一般都是1500字节，至于为什么是1500，那就是学术层面的事情了）\n7.1.3 链路和数据链路链路是一条物理的链路，中间没有任何交换节点；\n数据链路是基于链路上的，需要有协议来实现数据的传输；将这些协议和硬件加入到链路上，就行程了数据链路；\n7.2 以太网帧格式\n\n这里需要知道一个小知识，虽然MAC地址在一定程度上可以认为是全球唯一的，但实际上只需要保证同一个局域网内的MAC地址是唯一的，就OK了\n\n目的地址&#x2F;源地址：48位的MAC地址，MAC是每个主机在局域网内唯一的身份标识\n帧协议类型有三种值，分别对应IP、ARP、RARP，所以只需要2个字节\n帧末尾是CRC校验码，4个字节\n\n这三个就是以太网固定添加的报头，在进行解包的时候，我们只需要取走数据最前面的14个字节（6+6+2），再丢弃末尾的4个字节，就能取到上层的原始数据。\nhttps://blog.csdn.net/sugelantianxin/article/details/117930398\n请注意，我们说的MTU是1500，其实就是IP可以交付的（包括IP报头）的长度是1500，这个1500是不包含以太网帧的报头的！\n以太网帧的报头是18字节，如上图所示。实际上能传输的数据大小是  [64 -18, 1518 - 18] = [46, 1500]\n7.3 认识MAC地址\nMAC地址用来识别数据链路层中相连的节点；\nMAC地址长度为48位（6个字节）一般用十六进制加上冒号的方式来表示，例如08:00:27:03:fb:19\nMAC地址在网卡出场的时候就确定了，不能被修改。虚拟机中的MAC地址并不是真实的MAC地址，可能会和已有的冲突（但虚拟机会检测冲突并及时修改，不然虚拟机就上不了网了）也有很少部分网卡支持用户配置MAC地址\n\n7.3.1 MAC地址和IP协议的区别MAC地址和IP地址的区别如下：\n\nIP地址描述的是路途总体的起点和终点\nMAC地址描述的是路途上每一个小路由区间的起点和终点\n\n因为我们的主机不可能知道一个很远的内网主机的MAC地址，所以就需要MAC地址在小路由区间来标识起点和终点，并实现正确的数据传输。\n7.4 MTU对上层的影响7.4.1 MTU对IP的影响在前文提到过，为了避免光电信号在物理层传输的时候出现冲突，需要限制网络层给数据链路层传输的单次的数据大小，MTU的具体说明可以参考本文 2.2.1 认识MTU；\n因为MTU的存在，网络层IP协议中需要对较大的数据包进行分包（IP分片和组装问题在上文也谈过了，这里就不重复了）\n但因为IP协议层分片和组装对于传输层来说是不可见的，如果IP分片后出现丢包导致数据丢失，那么传输层就必须得重传。所以传输层为了避免这种不受自己控制的事情，最终分片的操作应该是由传输层来进行处理才是最好的；\n7.4.2 MTU对UDP的影响UDP最大可以传输数据是 2^16字节，也就是64KB，而1500字节是1.5KB；也就是说，只要UDP携带的数据超过 1472 (1500 - 20 IP首部 - 8 UDP首部)，那么就会在网络层被分为多个IP数据报。\n一旦这个数据报中有一个IP报文丢失了，那么整个UDP报文就会丢失。再加上UDP并没有超时重传机制（不过可以根据具体的协议来定制应答和重传机制来保证数据可靠性），UDP的报文在IP层中被分片后丢包的概率远大于TCP\n7.4.3 MTU对TCP的影响\nTCP的一个数据报也不能无限大，还是受制于MTU\nTCP的单个数据报的最大消息长度，称为MSS(Max Segment Size); \nTCP在建立连接的过程中，通信双方会进行MSS协商。最理想的情况， MSS的值正好是在IP不会被分片处理的最大长度(这个长度仍然是受制于数据链路层的 MTU)。\n双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值。然后双方得知对方的MSS值之后，选择较小的作为最终MSS，进行数据传输；\nMSS的值在TCP首部的40字节变长选项中 (kind=2)；\n\n\n\n7.5 ARP协议7.5.1 说明\nARP协议属于数据链路层，是MAC帧协议的上层\n\n因为在局域网内的传输时，我们是用mac地址来作为不同主机的标识符的，所以就必须存在一个IP地址到MAC地址的转换。\nARP协议也是包含在以太网帧格式中的，其中属于他自己的正文只有28个字节；因为MTU限制最小的数据长度是46字节，所以在发送ARP报文的时候，需要给这个28字节后面填补空位。\n\n先来看看ARP请求&#x2F;应答中的各个字段的含义吧\n\n硬件类型：标定底层使用的是以太网还是其他帧格式，1为以太网\n协议类型：指要转换的地址类型，0X0800为IP地址\n硬件地址长度：对于以太网来说为6字节（这里填的是数字6，所以只需要占用1个字节）；\n协议地址长度：对于IP地址来说为4字节（同上）；\nop字段为1表示ARP请求，2表示ARP应答\n\n当我们的主机开始发送报文之前，我们的主机是不知道某一个IP对于的目标主机的MAC地址的。所以就需要用ARP协议向局域网内发送一个请求，并得到目标主机的ARP响应，响应中就包含了该主机的MAC地址\n7.5.2 ARP请求&#x2F;响应的流程主机A需要给主机B发送数据，但是不知道主机B的MAC地址，它就需要发起一个ARP请求：\n\n以太网目的地址填为全F，代表广播；源地址填自己的MAC地址\n帧类型填0806代表ARP协议；\nARP中的OP填为1，代表是ARP请求；\n发送端以太网地址和IP地址填为主机A自己的MAC地址和自己的IP地址；\n目的以太网地址填为全F，IP地址填为目的的IP地址（注意我们是知道对方IP地址的）；\n向下交付给以太网的MAC帧，然后送入局域网；\n\n这个ARP请求的报文就开始在局域网内进行广播\n\n收到这个ARP请求的主机在MAC帧收到，并向上交付给自己的ARP层；\nARP层先通过OP为1判断是ARP的请求；\n取出请求中的目的IP地址，判断是否为本机IP地址，不是则丢弃；\n是本机的IP地址，代表这个报文是发给自己的ARP请求，需要构造ARP响应；\n\n于是主机B就收到了这个ARP请求，并开始构造ARP响应\n\n以太网目的地址填为ARP请求中的发送端MAC地址，源MAC地址填自己的\n帧类型填0806代表ARP协议\nARP中的OP填2，代表ARP响应\n发送端以太网地址和IP地址填为主机B自己的MAC地址和自己的IP地址\n目的以太网地址填为A的MAC地址（在ARP请求中得知的）IP地址填为目的主机A的IP地址\n向下交付给以太网的MAC帧，然后送入局域网\n\n此时这个ARP的响应就开始在局域网中传输，因为此时以太网的目的地址不再是全F，所以各个收到这个报文的主机，就可以直接通过MAC地址来判断是否是发给自己的MAC帧。如果不是就直接丢弃，不交付给上层；\n主机A判断目的MAC帧是自己的，交付给上层的ARP协议\n\n判断ARP中的OP为2，代表是ARP响应\n因为前面已经判断过目的MAC地址是自己的了，所以这时候不需要判断ARP中的目的MAC和目的主机IP了\n直接取出发送端主机MAC和主机IP，就能得到主机B的IP和MAC地址的映射关系\n\n这时候主机A就得到了主机B的MAC地址，可以正常进行数据的发送了！\n7.5.3 ARP缓存与更新\n任何一台主机发出的一定是ARP的请求；\n接收到的ARP可能是对方向往发送的ARP请求，也可能是我发送的ARP请求的响应；\n\n但如果每台主机都不知道IP和MAC的映射关系，岂不是每次发送数据之前，都需要来个ARP请求和响应来获取对方MAC地址？这样整个局域网内就得被ARP请求和响应给塞满了。\n所以，当我们发送了一个ARP请求后，应该需要将ARP响应给暂时缓存到本机上，避免下次发送的时候不知道对方的MAC地址。操作系统中就有一张ARP缓存表，保存了局域网内部分主机的IP和MAC地址的映射关系。\n\n如果一个主机想获取到局域网内所有的MAC地址，就可以写个循环，把局域网内的所有IP都发送一次ARP请求，再将收集到的ARP响应给缓存起来（因为局域网内的主机网络号都是相同的，主机号都是是从1到254，并不多，写个循环就行了）\n\n但这里会有一个问题：如果某台主机B离开了你这个局域网，主机C接入后，路由器给主机C分配了原本是给主机B用的IP，这时候主机A里面的ARP缓存表没有更新，还是填了主机B的MAC地址（但主机B其实已经不在局域网里面了），这时候这个报文岂不是找不到目标主机了？\n所以ARP不仅仅需要缓存，还需要保有一定的更新机制：可以设置一个定时器，定时向缓存表中已有IP的主机发送一条ARP请求，并得到对方的ARP响应。这时候就可以比对返回的MAC地址是否有变动，有变动则更新。\n如果一个ARP请求长时间没有得到响应，则可以认为该IP地址目前没有对应的主机，将其从缓存表中删除。\n7.5.4 中间人攻击上文讲述了ARP的请求和响应的格式，假设出现了下面的这个情况：\n\n主机A想获取主机B的MAC，发送ARP请求并获取到了响应\n主机D把自己的IP伪装成主机B的IP，又给主机A发送了ARP响应\n此时主机A更新了ARP缓存表，将主机B的IP B映射给了MAC D\n主机D用同样的办法，将主机B的ARP缓存表中的IP A映射给了MAC D\n此时主机A给B发送消息，填的是MAC D；B给A发消息，填的也是MAC D；\n主机D在收到A和B双方通信的报文后，先交付给自己的上层，再转发给对方；\nA和B的双方通信就出现了一个中间人D，此时如果你的信息不是加密的，那就可以被主机D所窃取！\n\n这也是为啥出现了https来避免中间人攻击！\n7.5.5  RARPRARP（Reverse Address Resolution Protocol，逆地址解析协议）是一种网络协议，用于在局域网（LAN）中通过已知的物理地址查找相应的IP地址。\n与前面讲述的ARP（Address Resolution Protocol，地址解析协议）不同，ARP用于通过已知的IP地址查找相应的物理地址，通常用于将网络层（IP）地址映射到链路层（MAC）地址。RARP则执行相反的操作，它允许主机在启动时使用其物理地址来请求分配给它的IP地址。\nRARP协议在过去的计算机网络中用于在没有人工配置的情况下为计算机分配IP地址。当计算机启动时，它会向网络发送一个RARP请求包，其中包含它的物理地址（MAC地址），以请求分配一个IP地址。网络中的RARP服务器会接收这个请求并回复包含IP地址的RARP响应包。\n然而，随着时间的推移，RARP的使用逐渐减少，主要是因为它的局限性，例如不太适用于大型网络，以及需要特定的服务器来管理地址分配。现代的网络通常使用DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）来实现类似的功能，它更灵活且易于管理，可以自动分配IP地址以及其他网络配置参数给主机。\n总结数据链路层\n数据链路层的作用：两个设备(同一种数据链路节点)之间进行传递数据；\n以太网是一种技术标准；既包含了数据链路层的内容， 也包含了一些物理层的内容。 例如: 规定了网络拓扑结构, 访问控制方式, 传输速率等；\n以太网帧格式\n理解mac地址\n理解arp协议\n理解MTU\n\n网络层\n网络层的作用: 在复杂的网络环境中确定一个合适的路径. \n理解IP地址, 理解IP地址和MAC地址的区别\n理解IP协议格式\n了解网段划分方法\n理解如何解决IP数目不足的问题, 掌握网段划分的两种方案\n理解私有IP和公网IP\n理解网络层的IP地址路由过程\n理解一个数据包如何跨越网段到达最终目的地\n理解IP数据包分包的原因\n了解NAT设备的工作原理\n\n传输层\n传输层的作用: 负责数据能够从发送端传输接收端\n理解端口号的概念\n认识UDP协议, 了解UDP协议的特点。\n认识TCP协议，理解TCP协议的可靠性\n理解TCP协议的状态转化\n掌握TCP的连接管理，确认应答, 超时重传, 滑动窗口, 流量控制, 拥塞控制, 延迟应答, 捎带应答特性\n理解TCP面向字节流, 理解粘包问题和解决方案\n能够基于UDP实现可靠传输\n理解MTU对UDP&#x2F;TCP的影响\n\n应用层\n应用层的作用: 满足我们日常需求的网络程序, 都是在应用层\n能够根据自己的需求，设计应用层协议\n了解HTTP协议\n理解DNS的原理和工作流程\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【教程】netlify或vercel完全自动部署hexo","url":"/posts/3433631517/","content":"教你用netlify或vercel完全自动部署hexo\n\n\n1.完全自动？在 【教程】hexo搭建博客+keep主题美化 里面，就提到过使用netlify或者vercel来部署hexo。但是那个是部署的静态页面\n\n部署静态页面仓库，类似github pages，需要主动hexo d才会有更新\n直接帮你从hexo配置文件部署，只需要git push更新源文件仓库\n\n之前的博客中，提到的是第一种方式。本文中是第二种方式的教程。直接从配置文件部署，有以下几大好处\n\n任何地方，只要有网，你都可以通过修改github仓库中的source/_post里面的md文件，实现更新博客\n如果你更换了电脑，无须再为了hexo配置node.js等环境。这对于不写前端的我来说很棒\n\n话不多说，直接开始！\n2.github仓库要做到这一点，先需要准备一个存放hexo配置文件的仓库。本地的如下文件夹，就是hexo的配置文件\n\n准备配置仓库，需要保证node_modules和public文件夹不要上传到仓库中，否则后续部署会失败。这是我的gitignore文件，仅供参考\n*.deploy_git/db.json*public/.git/node_modules/\n\n最终仓库的文件层级如下，为了防止文章被过容易的盗走（因为仓库里面有md文件，盗文章太容易了。虽然html也能被爬走），我将其设置为私有仓库了\n\n有了这个仓库之后，就可以进行后续操作了\n3.netlify先新增一个site，选择从existing project中import\n\n这需要你的netlify账户有github的授权。我是直接用github登录的，所以已经有授权了\n\n选择hexo配置文件的仓库\n\nbuild命令修改为npm run build，其余不动\n\n到这里就可以deploy了！就这么简单！过一会成功了之后，就会显示出你的站点链接了！\n\n需要注意的是，nelify默认提供的二级域名，国内极有可能无法访问\n\n不用担心，你只需要在domain settings里面添加你自己的域名，访问速度就能起飞了\n4.vercel和netlify的操作很像，选择git仓库\n\n模板选择hexo，其他设置都没必要动。其中build需要进行的命令操作，已经在我们选择hexo目标的时候就选择上了\n\nvercel会开始部署\n\n如果没有报错，那就是部署成功了（否则请检查你的仓库里面hexo配置文件是不是少了或者多了什么）\n\n完美，也部署好了！\n\nvercel提供的子域名也有无法访问的问题，同样的，绑定了自己的域名就能在国内访问了。\n\n对于我来说，这两个平台都很不错，但是vercel有个很大的“缺点”，就是干了什么都要给你邮箱发个信息，还找不到地方关闭。对于我这种强迫症来说很不友好！！！\n\n5.遇到的问题文章更新时间不准确？我部署之后，遇到了vercel和netlify自动部署时会将所有文章的更新时间给重置为最新commit的时间的问题。说人话就是所有博客的更新时间都变成了你最后一次提交git的时间\n\n这是因为其实netlify和vercel的自动部署，都是主动去git clone你的仓库的，此时它创建的文件夹肯定是全新的一个文件夹，所有文件的修改时间都是刚刚clone的时间，默认情况下hexo用的就是文件的修改时间来做更新时间，所以就会出现这种问题。\n\n这样肯定不是很好，违背了更新时间的本意，用如下博客里面的办法就能解决这个问题；\nhttps://blog.im0o.top/posts/c6d9de72.html\n我采用的是在所有md文件的front-matter里面添加updated字段的方式（这是hexo支持的更新时间字段，格式和date字段完全相同）\ndate: 2023-12-08 20:32:14updated: 2023-12-08 21:32:14\n\n我使用了博客中提到的powershell脚本的方式来批量修改md文件，它会根据git log中的commit记录来获取当前md文件最后一次修改的时间，并写入front-matter的updated字段中。\n将如下内容写入一个update.ps1文件，然后直接用windows的powershell中./update.ps1执行它就可以了\n$fileEncoding = &quot;UTF8&quot;;Function Convert-FromUnixDate ($UnixDate) &#123;    [timezone]::CurrentTimeZone.ToLocalTime(([datetime]&#x27;1/1/1970&#x27;).AddSeconds($UnixDate))&#125;$fileNum = 0;Get-ChildItem -Path &quot;./source/_posts&quot; -recurse *.md | ForEach-Object -Process&#123;    $fileNum = $fileNum + 1;    if ($_ -is [System.IO.FileInfo]) &#123;        $filePath = $_.FullName;        Write-Host(&#x27;&#123;0&#125;. &#123;1&#125;&#x27; -f $fileNum, $filePath);        $lineNum = 0; # yaml 格式占据行数        $yamlStartEndNum = 0;        $existUpdated = $false;        $updatedNum = 0;        $newstreamreader = New-Object System.IO.StreamReader($filePath);        while (($readeachline = $newstreamreader.ReadLine()) -ne $null) &#123;            $lineNum = $lineNum + 1;            $temp = $readeachline -replace &quot; &quot;,&quot;&quot; -replace &quot;\\n&quot;,&quot;&quot;            if ($temp -match &quot;---&quot;) &#123;                $yamlStartEndNum = $yamlStartEndNum + 1;            &#125;            if ($readeachline.Contains(&quot;updated:&quot;)) &#123;                $existUpdated = $true;                $updatedNum = $lineNum;            &#125;            if ($yamlStartEndNum -ge 2) &#123;                # yaml end                break;            &#125;        &#125;        $newstreamreader.Dispose();        $filedata = Get-Content -Path $filePath -Encoding $fileEncoding;        $oldYamlStr = $filedata | Select-Object -First $lineNum        # git log format: https://www.cnblogs.com/ckAng/p/11205055.html https://git-scm.com/docs/git-log        # 此文件 最后一次 commit 的 Unix时间戳        $dateUpdated = git log -1 --format=&#x27;%ct&#x27; $filepath        $dateUpdated = Convert-FromUnixDate $dateUpdated        $dateUpdated = $dateUpdated.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;);        $newUpdated = &quot;updated: &quot; + $dateUpdated;        #Write-Host(&quot;newUpdated: &quot; + $newUpdated)        $newYamlStr = &quot;&quot;        # 注意: yamlStr 是一个数组, 每一个元素为一行字符串        $tempOldYamlStr = $oldYamlStr;        if ($existUpdated) &#123;            #Write-Host($yamlStr[$updatedNum-1])            $oldUpdated = $oldYamlStr[$updatedNum-1];            $tempOldYamlStr[$updatedNum-1] = $oldYamlStr[$updatedNum-1] -replace $oldUpdated,$newUpdated        &#125;else &#123;            # 修改 yaml 结束行            # TODO: 好像取到的这一行不包括 最后的换行符, 导致加一个 换行 反而多了, 不过为了保险, 还是加上一个换行            $tempOldYamlStr[$lineNum-1] = $newUpdated + $([System.Environment]::NewLine) + &quot;---&quot; + $([System.Environment]::NewLine)        &#125;        $newYamlStr = $tempOldYamlStr        Write-Output $newYamlStr        $newFiledata = $newYamlStr + $filedata[$lineNum..$filedata.count]        $newFiledata | Set-Content -Path $filePath -Encoding $fileEncoding    &#125;&#125;#Write-Host(&quot;更新 updated 完成&quot;);\n\n使用该脚本过程中，我还遇到了一个文件编码导致的问题，记录在了如下issue中 https://github.com/Qexo/Qexo/issues/395\n主要问题如下图所示，其实就是md文件编码不一致，导致出现了一些奇怪的红点。用python来批量修改一下文件编码格式就能解决这个问题。\n\nThe end有问题可以在评论区提出~\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【教程】hexo搭建博客+keep主题美化","url":"/posts/138502038/","content":"感谢你来到本小站，如果这篇博客对你有帮助，欢迎在下方评论😘！\n\n\n折腾了一整天，算是把基本的博客环境给搭建好了，页面效果还是挺不错的！后续对寒舍有什么新操作会对本文进行更新，可以多多关注一下哦\n\n\n本博客修改过的 keep 主题文件可以在这里查看👉 musnows&#x2F;hexo-theme-keep\n本博客修改后的 keep 主题预览站点为 keep-hexo.musnow.top\n\n1.基本配置我最开始使用的平台是HEXO+Gitee，参考这篇博客👉基于Gitee+Hexo搭建个人博客\n现在我不建议你使用 gitee pages，具体请看本文 4.1；\n可以根据本文向导配置 github pages，有问题可以评论提出哦╰(*°▽°*)╯\n\n操作之前，需要下载两个软件；先下载安装好node.js后再进行git操作\nnode.js：官网https://nodejs.org/zh-cn/git：官网https://git-scm.com/\n\n1.1 安装hexo\n如果是Centos云服务器，安装hexo可以参考https://www.myfreax.com/how-to-install-node-js-on-centos-8/\n\n安装好这两个工具后，我们先打开git bash（一般右键菜单里面就会有，如果找不到该软件请全局搜索）如果你安装的时候有选择添加到命令行，那么是可以直接用windows的cmd来操作git的。这里避免你安装的时候没有选择此项，均用git bash来演示\n\n【Git】在Windows CMD中和VScode中配置已经安装好的git\n\n打开之后的界面应该是这样的\n\n我们cd进入你想要创建hexo本地文件的路径，比如我想在D盘里面创建我的hexo博客，那么就cd进入你想要的路径；如果你不知道如何填写路径，可以右键顶栏将路径复制为文本\n\n然后在git bash中，使用 shift+insert(ins) 进行粘贴\ncd D:\\example\n\n这样我们就成功进入我们想要的文件夹了\n\n输入 node -v 命令，测试 node.js 是否安装成功且可用；如果出现版本号，就是安装成功了（请确认node.js的版本大于v16）\n$ node -vv16.13.1\n\n随后在这里执行以下命令\nnpm -g install npm #安装npm包管理器# 如果安装npm失败，则使用镜像源安装淘宝的cnpmnpm -g install cnpm --registry=https://registry.npm.taobao.org# 如果安装了cnpm，注意后续所有npm命令要用cnpm代替\n\n安装成功后，安装hexo\nnpm install -g hexo-cli\n\n测试是否成功安装\nmoth@LAPTOP-R9S2524B MINGW32 /d/example$ hexo versionhexo-cli: 4.3.0os: win32 10.0.22000node: 16.13.1v8: 9.4.146.24-node.14uv: 1.42.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1l+quiccldr: 39.0icu: 69.1tz: 2021aunicode: 13.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV\n\n出现上面的字样，就是安装成功了；因为我是2022年4月操作的，这里安装的版本有点老，不过不影响使用，那就不升级了😶‍🌫️\n\n温馨提示：这些都是依赖项，如果不影响你的使用，那就不要升级！\n不要升级！不要升级！！不要升级！！！\n\n1.1.1 报错本系统不支持运行脚本在另外一台电脑上部署hexo的时候，安装完毕hexo，遇到了这个报错\nhexo : 无法加载文件 C:\\Users\\moth\\AppData\\Roaming\\npm\\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。\n\n\n解决办法，是进入windows11的设置页面，在隐私-开发者设置-终端中，允许本地powershell脚本在未签名的情况下运行\n\n勾上选项后，点击应用。之后运行hexo就没有报错了\n\n\n1.1.2 初始化博客文件夹输入以下命令，我们会在当前文件夹创建一个blog文件夹，hexo会在里面克隆基础hexo需要用的文件\n$ hexo init blogINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitfatal: unable to access &#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054WARN  git clone failed. Copying data insteadINFO  Install dependenciesINFO  Start blogging with Hexo!\n\n使用cd命令进入blog文件夹\ncd blog\n\n执行以下命令，安装一下依赖项\nnpm install\n\n\n随后输入下面三个命令\nhexo cl #hexo clean的缩写hexo g #生成文件hexo s #开启本地预览\n\n输出的结果如下\nmoth@LAPTOP MINGW32 /d/example/blog$ hexo clINFO  Validating configmoth@LAPTOP MINGW32 /d/example/blog$ hexo gINFO  Validating configINFO  Start processingINFO  Files loaded in 94 msINFO  Generated: archives/index.htmlINFO  Generated: archives/2023/index.htmlINFO  Generated: archives/2023/01/index.htmlINFO  Generated: index.htmlINFO  Generated: fancybox/blank.gifINFO  Generated: fancybox/helpers/fancybox_buttons.pngINFO  Generated: fancybox/fancybox_loading@2x.gifINFO  Generated: css/fonts/fontawesome-webfont.ttfINFO  Generated: fancybox/fancybox_loading.gifINFO  Generated: js/script.jsINFO  Generated: fancybox/fancybox_overlay.pngINFO  Generated: fancybox/fancybox_sprite@2x.pngINFO  Generated: fancybox/fancybox_sprite.pngINFO  Generated: css/fonts/FontAwesome.otfINFO  Generated: fancybox/jquery.fancybox.cssINFO  Generated: fancybox/helpers/jquery.fancybox-buttons.cssINFO  Generated: css/images/banner.jpgINFO  Generated: css/style.cssINFO  Generated: fancybox/helpers/jquery.fancybox-buttons.jsINFO  Generated: fancybox/jquery.fancybox.jsINFO  Generated: fancybox/helpers/jquery.fancybox-media.jsINFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.cssINFO  Generated: fancybox/jquery.fancybox.pack.jsINFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.jsINFO  Generated: 2023/01/10/hello-world/index.htmlINFO  Generated: css/fonts/fontawesome-webfont.svgINFO  Generated: css/fonts/fontawesome-webfont.woffINFO  Generated: css/fonts/fontawesome-webfont.eotINFO  28 files generated in 232 msmoth@LAPTOP MINGW32 /d/example/blog$ hexo sINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n\n浏览器打开 http://localhost:4000，看到下面的预览，那就OK了！\n\n1.2 部署到github pages在Github创建一个新仓库，名字为 用户名.github.io\n找到blog目录下会有一个_config.yml 文件，这是hexo的配置文件。在里面找到下面的字段，填入你的github仓库地址\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: https://github.com/musnows/musnows.github.io.git  branch: master\n\n如果你想同时部署到 gitee&#x2F;github，可以这样写\ndeploy:  type: git  repo:\t  github: https://github.com/musnows/musnows.github.io.git\t  gitee: git@gitee.com:musnow/musnow.git  branch: master\n\n随后，我们执行hexo d 部署到远程仓库\nhexo d #部署hexo g --d #生成文件的同时部署，推荐使用这个\n\n如果出现下面的错误，那是很正常的，因为我们没有安装部署的依赖项\nERROR Deployer not found: git\n\n安装 hexo-deployer-git\nnpm install hexo-deployer-git --save\n\n再次执行hexo g --d，输入你的github账户（邮箱）和密码，进行部署。\n可以看到github仓库多了一个master分支，其内部就是我们的远端文件。\n进入仓库的设置，找到github pages的设置，选择master分支部署，按下图配置\n\n等待部署成功后，就可以打开 https://你的名字.github.io 就可以访问了！\n做完上面的步骤，此时就可以来安装一个主题了。毕竟默认的landscape主题还是不够好用的😘\n\nssh免密部署操作，参考第4点\n\n1.2 keep主题Hexo下keep主题初始化操作是根据开发者大哥的帮助文档进行的\n本文是对相关踩坑操作的一点说明，建议你先粗略浏览完本文，看看有啥坑🕳（挺多的）再进行keep主题的配置\n\nKeep快速开始\n\n如果你想使用其他hexo主题，建议选择有中文帮助文档的HEXO主题，不然就得啃英语了。\n后面本站样式可能会做其他的更改，待我搞清楚进阶操作再说。毕竟咱对CSS和HTML代码是完全不懂（这是前端的内容，目前没有自学计划）\n\n前人栽树后人乘凉，在keep开发者博客的友链中找到了魔改了主题的老哥，直接学习起来😍！hexo主题魔改汇总和总结\n更多内容详见本文 第8点\n\n当前你看到的主页已经是修改keep主题过后的啦！感觉如何？\n1.3 keep主题安装目录在哪？如果你更具keep的官方文档用npm安装，你可能发现在themes里面没有keep主题的文件夹，那它到哪儿去了呢？\n\n找一找就能发现，其实在这里 blog\\node_modules\\hexo-theme-keep。这是因为我的主题是用npm安装的，node_modules是在当前目录安装的包的位置，所以会出现这种情况\n\n需要注意，后续修改_comfig.yml的时候，有的时候需要修改的是主题的配置文件，有些是HEXO官方的配置文件，不要把二者弄混了！\n建议在hexo更目录的source/_data 文件夹中创建一个keep.yml，修改配置文件只需要修改这里的keep.yml即可，方便以后进行平滑升级\n1.4 主题页面设置成中文keep主题默认的页面是英文的按钮，需要在HEXO配置文件_comfig.yml中修改语言为zh-CN然后页面就变成中文啦！\n\n2.如何添加博客文章HEXO采用的是markdown语法，只需要在本地的source/_posts文件夹添加md源文件，就能在个人博客中显示\n以keep模板为例，我们需要在md源文件的正文之前添加如下语句，来设置博客的标题、上传时间、tag、分类，以及是否置顶\n\n如果要设置多个tag，样式为[Hexo,typora,博客]\n多个分类categories同理\n\n---title: 使用hexo+gitee搭建个人博客date: 2022-04-23 13:30:14tags: [Hexo]categories: [差生文具多]sticky: 999---\n\n2.1 首页置顶比如本文件的sticky我设置成了999，你看到的就是本文在我的首页置顶了。如果不设置sticky，首页默认是以时间降序排列文章（后发布的在前头）\n\n\n2.2 搭建图床（必做）本操作必做！为了保证你上传的md文件中的图片能在个人博客上正常显示，请先配置你的个人图床👉图床搭建教程\n如果你开启了阿里云OSS的bucket防盗链，还需要将你的站点加入白名单！\n2.3 如何导出CSDN的博客如果你之前的博客是在CSDN上写的，可以在markdown编辑器的文章管理面板中导出为md文件\n\n为了避免图片后续无法访问，建议上传一下csdn的图片到自己的图床（可以通过obsidian的插件快捷上传全文图片）\n\n3.图片无法显示问题3.1 解决：设置空referrer我们的博客网站向其他站点访问图片的时候，会发送一个 referrer 。有些站点是会block掉你的博客访问的，比如CSDN的图片链接。\n这部分是我在设置友链的时候发现的，有些朋友给我的头像链接是CSDN的图片链接，但是设置完毕后头像图片不显示。\n包括你的图床图片不显示，也可能是因为 referrer 问题；比如我就发现我的阿里云OSS图片，在本地 HEXO S 的时候，博客中的图片无法加载\n\n解决办法参考这篇博客👉Hexo博客不显示图床图片的解决方法\n\n具体操作是打开HEXO主题中包含全局网页head信息的文件（不同主题可能不一样，需要你找到主题的安装路径）keep主题是hexo-theme-keep\\layout\\_partial\\head.ejs\n\n打开后在里面添加这个语句，设置referrer为空\n&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;\n\n\n设置完毕后，应该就可以正常访问图床图片和CSDN的图片外链了\n3.2 关于oss安全(CDN)设置空referrer需要在oss的防盗链设置中开启 允许空referrer，这能让用户直接在浏览器中访问你的图片资源，某种意义上来说，是不安全的！\n但是关闭允许空referrer的功能，无法让typora显示出图片。这是因为markdown软件在请求的时候不会带上referrer的，本质上和直接用浏览器请求是一样的。\n所以，为了避免被人“一晚上抓走一套房”的oss流量盗用问题，建议为你的阿里云oss添加上cdn（或者使用又拍云oss作为图床，又拍云的oss自带访问控制）\n\n以又拍云cdn为例，在cdn设置里面，可以配置访问控制\n\n这里有如下一些配置项，注释里面说明了它们对应的作用\nIP黑白名单 # 白名单：允许的ip,黑名单：不允许的ip# 如果发现某一个ip的请求次数过多，有恶意请求嫌疑，可以暂时将这个ip设置为黑名单CORS 跨域共享 # 参考http://ruanyifeng.com/blog/2016/04/cors.html地区访问限制 # 禁止或允许特定地区的限制Referer 防盗链 # 重点，建议开启白名单，只将自己的域名添加到白名单中（建议开启）User-Agent 防盗链 # 限制只有某种类型的客户端、浏览器可以访问资源Token 防盗链 # 有些麻烦，请自行了解。对于静态博客而言，并不方便回源鉴权 # 如果源站服务器有鉴权操作，可以在这里配置IP 访问限制 # 对单个ip的请求速率进行限制（建议开启）CC 防护 # 防护cc攻击WAF 保护 # Web Application Firewall\n\n对于hexo静态博客而言，建议配置Referer的防盗链，和IP的访问限制。同一个ip如果访问速率过高，直接禁止其访问。\n如果你的hexo站点是部署在自己的服务器上，cdn还有一个非常棒的功能，那就是隐藏你服务器的真实ip，避免被打\n4.ssh免密部署hexo cl //清除已有格式hexo g --d //将更改更新 并push到git仓库\n\ngit本地用命令行操作的时候，可能每一次hexo g --d操作都会让你输入一次账户和密码，我们只需要生成一个SSH公钥给git仓库，就能跳过这个操作\n\n具体生成操作可以查看这个博客👉如何使用ssh密钥配置git\n\n在设置好后，记得把hexo的_config文件中的https链接更换为ssh链接！\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:musnow/musnows.github.io.git  branch: master\n\n\n\n4.1 关于gitee和github的优劣咳咳，gitee的一些ex操作让我不得不换到了github！而且说句实话，虽然gitee服务器在国内，其gitee pages的访问速度真不见得比github快多少\n\ngithub无审查（光是这一点已经赢了😂）gitee说我写的技术博客有问题，不给我部署。又不告诉用户问题在哪，只能是一脸懵逼😥\ngithub在hexo g --d部署了之后能自动更新；gitee还需要你自己点一下更新按钮，很烦\ngithub可以免费绑定你自己的域名；gitee只有企业版才行\n\nhexo切换到github非常方便，在github中创建一个用户名.github.io的仓库，将你的hexo中_config.yml的远端仓库路径一改，部署了之后，直接就能正常访问！\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:musnows/musnows.github.io.git  branch: master\n\n对事不对人，平台只是一个载体，分享技术才是重要的！\n4.2 netlifynetlify的部署非常容易，其访问速度比 github pages 快多了！实测netlify的延迟只有80ms，而 github pages 是200ms\n\n部署参考🦋Hexo+Github+Netlify部署个人博客\n\n最最最棒的一点是，netlify的部署速度很快，几乎是你 hexo d 刚刚上传到仓库，没过几秒他就部署成功了！\n你可以主要使用netlify，将 github.io 作为镜像站；不过这样的话，评论系统可能会出现一些问题，要注意设置主站的url，别把评论系统弄boom了！\n\n操作很简单，github登陆后，选择你的github仓库\n\n再选择对应的分支，点击底部的deploy site，就大功告成了！\n\n等待这里出现published的字样，就可以访问你的站点了。域名在domain settings里面设置就OK\n\n4.3 vercelvercel同理，也是选择musnows.github.io，注意模板不能选择hexo，否则会部署失败。\n模板选择other，过一会就能部署成功；这样就相当于一个站点有3个备份了，完美！\n\n5.关于hexo文内toc问题keep模板已经自带了边栏toc，可以在右上角打开\n\n实际上，我们可以通过hexo-toc插件实现类似CSDN和typora的文章内toc（这个功能很多markdown编辑器都不支持，比如obsidian）\n\n\n文内toc插件安装参考了这篇知乎文章👉传送门\n\n在git里面输入以下命令\nnpm install hexo-toc --save\n\n插件安装完毕后，就可以在md文件的头部插入&lt;!-- toc --&gt; 来生成目录（在typora和csdn中是[TOC]格式）\n但是这个插件有一个问题，就是无法和keep模板的边栏toc同时使用。即使用了该插件后，边栏toc无法跳转，就只能二选一了。\n无奈只能卸载这个插件了，个人感觉还是边栏toc重要一点\nnpm remove hexo-toc --save\n\n6.自定义首页文章预览内容hexo本身支持自定义文件预览格式，在md文件中添加&lt;!-- more --&gt;就可以自定义文章预览显示的内容\n效果如下👇 建议不要在需要预览的内容中设置标题，不然看起来会非常怪异\n\n7.评论系统7.1 Valine评论系统后台如何查看评论在配置好Valine评论系统后，可以在leancloud后台管理中看到评论的html源码。\n但默认的排序的问题是，看不到用户是在那一篇文章下面评论的。我们可以通过调整内容排序（右上角那个带橙色圆点的按钮），把url往前移动，这样就能更方便地看到是谁评论了自己的博客，以及评论文章的位置\n\n7.1.1 leancloud邮箱提醒你可以利用valine插件admin来实现邮箱提醒\n\nGithub项目地址：DesertsP&#x2F;Valine-Admin\n\n但是这个插件需要你有一个备案过的域名！！！！\n然后我就在22-04-27这天发现，其实我设置的邮箱提醒已经生效了！😂真是一波三折（然后又挂了，参看 7.2 😥）\n大家根据这篇博客的教程进行邮件提醒的配置就OK了！valine评论系统使用\n\n7.1.2 关于云引擎500报错本部分更新于2023-01-05，今天更新了博客的url地址，然后就发现leancloud的邮箱提醒挂掉了，看后台会有一个这样的报错\n[2023-01-06T03:20:03.518063400Z][instance:web1] LeanEngine: /self_wake: 500: Error: undefined is not a valid uri or options object.[2023-01-06T03:20:03.518111500Z][instance:web1]     at request (/home/leanengine/app/node_modules/request/index.js:44:11)[2023-01-06T03:20:03.518117400Z][instance:web1]     at /home/leanengine/app/cloud.js:54:5[2023-01-06T03:20:03.518121000Z][instance:web1]     at /home/leanengine/app/node_modules/leanengine/lib/leanengine.js:202:14[2023-01-06T03:20:03.518124500Z][instance:web1]     at processTicksAndRejections (internal/process/task_queues.js:97:5)\n\n最终我百度到了这个issue，里面提到的和我的情况一模一样：邮件提醒报错，不知道为什么Error: undefined is not a valid uri or options object. #138\n简单说来，就是云引擎需要绑定域名\n而我最开始选择的leadcould是在国内，域名必须要ipc备案才能正常绑定；如果需要用独立IP，那还得额外掏钱，50一个月实在是负担不起😥\n\n至于之前为啥邮箱提醒能用呢？我也不知道；我猜是leancloud最近更新了策略，就需要强制绑定才能用了……\n\n解决方法，使用国际版leancloud！\n7.2 使用 Waline评论系统这部分可以参考Waline的帮助文档，本站的评论系统也于 2023-01-06 从 valine 更换为了 waline，keep版本3.4.5-&gt;3.5.2\n\nWaline.js.org\nkeep使用waline\n\n配置好了 vercel 的自定义的域名之后，就可以通过下面两个方式来快捷管理\n评论系统：example.yourdomain.com评论管理：example.yourdomain.com/ui\n\n下图为更新前的valine评论界面\n\n以下为更新后的waline 界面，其支持上传图片！可惜默认只支持128kb，暂时还没有找到修改该限制的办法；对于我来说，waline最大的优势就是邮箱提醒功能可以很方便地用vecel的环境变量搞定，效果也很不错！\n\n7.2.1 自定义waline邮箱提醒模板\n参考👉waline 邮件通知模板样式一览\n\n为了避免源站无法访问，这里贴出当前我使用的邮件通知模板;\n注意，我是用vercel部署的，所以只需要修改环境变量就行了。如果你是其他部署方式，请参考上面博客中的详细教程!\nMAIL_SUBJECT\n&#123;&#123;parent.nick | safe&#125;&#125;，您在『&#123;&#123;site.name | safe&#125;&#125;』上的评论收到了来自  &#123;&#123;self.nick | safe&#125;&#125; 的回复\n\nMAIL_SUBJECT_ADMIN\n『&#123;&#123;site.name | safe&#125;&#125;』 上有新评论了\n\nMAIL_TEMPLATE\n&lt;div style=&quot;border-radius: 10px 10px 10px 10px;font-size:14px;color: #555555;width: 666px;font-family:&#x27;Century Gothic&#x27;,&#x27;Trebuchet MS&#x27;,&#x27;Hiragino Sans GB&#x27;,微软雅黑,&#x27;Microsoft Yahei&#x27;,Tahoma,Helvetica,Arial,&#x27;SimSun&#x27;,sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffffff repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);&quot;&gt;&lt;div style=&quot;width:100%;background:#49BDAD;color:#ffffff;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));background-image: -webkit-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;&quot;&gt;&lt;p style=&quot;font-size:15px;word-break:break-all;padding: 23px 32px;margin:0;background-color: hsla(0,0%,100%,.4);border-radius: 10px 10px 0 0;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #ffffff;&quot; href=&quot;&#123;&#123;site.url&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123;site.name&#125;&#125;&lt;/a&gt;上的留言有新回复啦！&lt;/p&gt;&lt;/div&gt;&lt;div style=&quot;margin:40px auto;width:90%&quot;&gt;&lt;p&gt;Hi, &#123;&#123;parent.nick&#125;&#125;，您曾在文章上发表评论：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;&#123;&#123;parent.comment | safe&#125;&#125;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;&#123;&#123;self.nick&#125;&#125;&lt;/strong&gt; 给您的回复如下：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;&#123;&#123;self.comment | safe&#125;&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;&#123;&#123;site.postUrl&#125;&#125;&quot; target=&quot;_blank&quot;&gt;查看回复的完整內容&lt;/a&gt;，欢迎再次光临&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;&#123;&#123;site.url&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123;site.name&#125;&#125;&lt;/a&gt;。&lt;hr /&gt;&lt;p style=&quot;font-size:12px;color:#b7adad&quot;&gt;本邮件为系统自动发送，请勿直接回复邮件哦，可到博文内容回复。&lt;/p&gt;&lt;/p&gt;&lt;style type=&quot;text/css&quot;&gt;a:link&#123;text-decoration:none&#125;a:visited&#123;text-decoration:none&#125;a:hover&#123;text-decoration:none&#125;a:active&#123;text-decoration:none&#125;&lt;/style&gt;&lt;/div&gt;&lt;/div&gt;\n\nMAIL_TEMPLATE_ADMIN\n&lt;div style=&quot;background-image: url(https://npm.elemecdn.com/sarakale-assets@v1/Article/email/bg.jpg);;padding:20px 0px 20px;margin:0px;background-color:#ded8ca;width:100%;&quot;&gt;&lt;div style=&quot;background: url(https://npm.elemecdn.com/sarakale-assets@v1/Article/email/leisi-714x62.png) repeat-y scroll top;&quot;&gt;&lt;div style=&quot;border-radius: 10px 10px 10px 10px;font-size:14px;color: #555555;width: 666px;font-family:&#x27;Century Gothic&#x27;,&#x27;Trebuchet MS&#x27;,&#x27;Hiragino Sans GB&#x27;,微软雅黑,&#x27;Microsoft Yahei&#x27;,Tahoma,Helvetica,Arial,&#x27;SimSun&#x27;,sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffe8dd61;box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);margin:auto&quot;&gt;&lt;img class=&quot;headerimg no-lightbox entered loaded&quot;src=&quot;https://npm.elemecdn.com/sarakale-assets@v1/bg/bg3.jpg&quot;style=&quot;width:100%;overflow:hidden;pointer-events:none&quot;data-ll-status=&quot;loaded&quot;&gt;&lt;div style=&quot;width:100%;color:#9d2850;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;background: url(https://npm.elemecdn.com/sarakale-assets@v1/Article/email/line034_666x66.png) left top no-repeat;&quot;&gt;&lt;p style=&quot;font-size:16px;font-weight: bold;text-align:center;word-break:break-all;padding: 23px 32px;margin:0;border-radius: 10px 10px 0 0;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #9d2850;&quot;href=&quot;&#123;&#123;site.url&#125;&#125;&quot;target=&quot;_blank&quot;&gt;&#123;&#123;site.name&#125;&#125;&lt;/a&gt;上的文章有了新的评论&lt;/p&gt;&lt;/div&gt;&lt;div style=&quot;margin:40px auto;width:90%;&quot;&gt;&lt;p&gt;&lt;strong&gt;&#123;&#123;self.nick&#125;&#125;&lt;/strong&gt;回复说：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:15px;color:#555555;&quot;&gt;&#123;&#123;self.comment|safe&#125;&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#cf5c83&quot;href=&quot;&#123;&#123;site.postUrl&#125;&#125;&quot;target=&quot;_blank&quot;&gt;查看回复的完整內容&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n\n7.2.2 163邮箱自定义发件人名字这里需要注意，官方给出了两个自定义邮箱发件人和发件邮箱的环境变量，其对于网易的163和126邮箱来说，你必须要设置成你的登录邮箱才可以，否则会报错，没办法发送邮箱\nSENDER_EMAIL 用来自定义发件邮箱，但是网易邮箱不支持SENDER_NAME  自定义发件人\n\n而且还有一点，就是这两个环境变量需要都加上，邮箱自定义发件人才能生效；\n如果你只设置了 SENDER_NAME 环境变量，而没有设置 SENDER_EMAIL，那么发件人是不会生效的，此时发件人会是你的邮箱，很难看；\n\n7.2.3 强制用户填写昵称和邮箱在waline的组件里面，可以配置用户必须填写的信息。比如为了让我对用户的回复能通过邮箱提醒到对方，我需要开启强制用户填写邮箱的功能\n\nhttps://waline.js.org/reference/client/props.html#requiredmeta\n\n如果你用的hexo主题有对这一项进行定制化，那就可以直接在主题配置文件里面加上（具体请参考你所用hexo主题的文档）\nkeep主题并没有对此项进行配置，修改配置文件是没有用的。需要我们修改源码\nthemes/keep/layout/_partial/comment/waline.ejs\n\n找到下面的部分（第37行左右）\nWaline.init(&#123;    el: &#x27;#waline-comment&#x27;,    serverURL: &#x27;&lt;%= waline_env_server_url %&gt;&#x27;,    lang: &#x27;&lt;%= config.language %&gt;&#x27; || &#x27;zh-CN&#x27;,    comment: &#x27;.post-comments-count&#x27;,    reaction: &#x27;&lt;%= waline_reaction %&gt;&#x27; === &#x27;true&#x27; &#125;)\n\n在最后加上\nrequiredMeta: [&#x27;nick&#x27;,&#x27;mail&#x27;]\n\n添加之后的完整代码如下\nWaline.init(&#123;    el: &#x27;#waline-comment&#x27;,    serverURL: &#x27;&lt;%= waline_env_server_url %&gt;&#x27;,    lang: &#x27;&lt;%= config.language %&gt;&#x27; || &#x27;zh-CN&#x27;,    comment: &#x27;.post-comments-count&#x27;,    reaction: &#x27;&lt;%= waline_reaction %&gt;&#x27; === &#x27;true&#x27;,    requiredMeta: [&#x27;nick&#x27;,&#x27;mail&#x27;]&#125;)\n\n此时，用户想评论的时候，就必须填写昵称和邮箱了\n\n8.部分keep魔改记录目前本博客已经修改为butterfly主题。为了保证以下教程的可用性，我部署了一个不再更新的keep主题博客，大家可以查看该站点，参考keep主题魔改后的效果\nkeep-hexo.musnow.top\n\n突出的就是一个可持续性发展👻\n8.0 开始除了本文第一点里面提到的魔改keep参考教程，我还修改了其他一些内容，并对keep v3.5.2更新了的配置文件进行说明；以下是各个框的标号\n\n\n以下是不同框对应的配置文件路径和对应的类，帮助你找到他们的配置文件路径；更详细的介绍参考 hexo-keep首页样式自定义\n1  Hexo\\themes\\keep\\source\\css\\layout\\_partial\\header.styl   .header-wrapper &#123;&#125;2  Hexo\\themes\\keep\\source\\css\\layout\\page.styl   .page-container &#123;&#125;3  Hexo\\themes\\keep\\source\\css\\layout\\_partial\\first-screen.styl   .description &#123;&#125;4  Hexo\\themes\\keep\\source\\css\\layout\\_partial\\first-screen.styl   .s-icon-list &#123;&#125;5  Hexo\\themes\\keep\\source\\css\\layout\\page.styl   .page-main-content &#123;&#125;6  Hexo\\themes\\keep\\source\\css\\layout\\home-content.styl   .home-content-container &#123;&#125;7  Hexo\\themes\\keep\\source\\css\\layout\\home-content.styl   .home-article-item &#123;&#125;\n\n版本基于KEEP V3.5.2，基本兼容V3.6.1，如果你发现配置文件位置有变动，请在下方留言告知。\n备注：keep不支持深层次的自定义页面，所有的修改都是针对 npm 包进行的，会在你更新keep的时候丢失！所以想折腾，建议做好不再更新keep的准备哦（除非你愿意每次都改一遍）🤣\n\nblog&#x2F;node_modules&#x2F;hexo-theme-keep\n\n如果觉得本站修改过后的样式很不错，那可以去我的Github仓库，直接把keep的模组下载后放到你的本地就可以了；这样就只需要修改 keep/source/css/layout/page.styl里面的两个背景图url就可以了！\n\n8.1 雪花飘飘我的主页有飘动的雪花，想知道怎么弄的？那就往下看吧！\n\n雪花代码来自博客👉hexo+next添加雪花飘落背景效果\n\n在Hexo-themes-keep\\source\\js下新建文件snow.js\n/*样式二*//* 控制下雪 */function snowFall(snow) &#123;    /* 可配置属性 */    snow = snow || &#123;&#125;;    this.maxFlake = snow.maxFlake || 200; /* 最多片数 */    this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */    this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.msRequestAnimationFrame ||    window.oRequestAnimationFrame ||    function (callback) &#123;        setTimeout(callback, 1000 / 60);    &#125;;cancelAnimationFrame = window.cancelAnimationFrame ||    window.mozCancelAnimationFrame ||    window.webkitCancelAnimationFrame ||    window.msCancelAnimationFrame ||    window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function () &#123;    /* 创建画布 */    snowCanvas.apply(this);    /* 创建雪花形状 */    createFlakes.apply(this);    /* 画雪 */    drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123;    /* 添加Dom结点 */    var snowcanvas = document.createElement(&quot;canvas&quot;);    snowcanvas.id = &quot;snowfall&quot;;    snowcanvas.width = window.innerWidth;    snowcanvas.height = document.body.clientHeight;    snowcanvas.setAttribute(&quot;style&quot;, &quot;position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;&quot;);    document.getElementsByTagName(&quot;body&quot;)[0].appendChild(snowcanvas);    this.canvas = snowcanvas;    this.ctx = snowcanvas.getContext(&quot;2d&quot;);    /* 窗口大小改变的处理 */    window.onresize = function () &#123;        snowcanvas.width = window.innerWidth;        /* snowcanvas.height = window.innerHeight */    &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123;    this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */    this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */    this.size = Math.random() * flakeSize + 2; /* 形状 */    this.maxSize = flakeSize; /* 最大形状 */    this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */    this.fallSpeed = fallSpeed; /* 坠落速度 */    this.velY = this.speed; /* Y方向速度 */    this.velX = 0; /* X方向速度 */    this.stepSize = Math.random() / 30; /* 步长 */    this.step = 0 /* 步数 */&#125;flakeMove.prototype.update = function () &#123;    var x = this.x,        y = this.y;    /* 左右摆动(余弦) */    this.velX *= 0.98;    if (this.velY &lt;= this.speed) &#123;        this.velY = this.speed    &#125;    this.velX += Math.cos(this.step += .05) * this.stepSize;    this.y += this.velY;    this.x += this.velX;    /* 飞出边界的处理 */    if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123;        this.reset(canvas.width, canvas.height)    &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function (width, height) &#123;    this.x = Math.floor(Math.random() * width);    this.y = 0;    this.size = Math.random() * this.maxSize + 2;    this.speed = Math.random() * 1 + this.fallSpeed;    this.velY = this.speed;    this.velX = 0;&#125;;// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function (ctx) &#123;    var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);    snowFlake.addColorStop(0, &quot;rgba(255, 255, 255, 0.9)&quot;); /* 此处是雪花颜色，默认是白色 */    snowFlake.addColorStop(.5, &quot;rgba(255, 255, 255, 0.5)&quot;); /* 若要改为其他颜色，请自行查 */    snowFlake.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;); /* 找16进制的RGB 颜色代码。 */    ctx.save();    ctx.fillStyle = snowFlake;    ctx.beginPath();    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);    ctx.fill();    ctx.restore();&#125;;/* 创建雪花-定义形状 */function createFlakes() &#123;    var maxFlake = this.maxFlake,        flakes = this.flakes = [],        canvas = this.canvas;    for (var i = 0; i &lt; maxFlake; i++) &#123;        flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed))    &#125;&#125;/* 画雪 */function drawSnow() &#123;    var maxFlake = this.maxFlake,        flakes = this.flakes;    ctx = this.ctx, canvas = this.canvas, that = this;    /* 清空雪花 */    ctx.clearRect(0, 0, canvas.width, canvas.height);    for (var e = 0; e &lt; maxFlake; e++) &#123;        flakes[e].update();        flakes[e].render(ctx);    &#125;    /*  一帧一帧的画 */    this.loop = requestAnimationFrame(function () &#123;        drawSnow.apply(that);    &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;    maxFlake: 60&#125;);snow.start();\n\n添加完成后，在 hexo-theme-keep\\layout\\layout.ejs 中添加如下引用\n&lt;script type = &quot;text/javascript&quot; src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;\n\n添加完成后的 layout.ejs 文件示例如下\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&lt;%= config.language %&gt;&quot;&gt;&lt;%- partial(&#x27;_partial/head&#x27;) %&gt;&lt;body&gt;&lt;%- body %&gt;&lt;%- partial(&#x27;_partial/scripts&#x27;) %&gt;&lt;script type = &quot;text/javascript&quot; src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n重新部署，就OK啦！\n8.2 首页描述字体的背景框和透明度这里对应的是3号框的文字\n修改hexo-theme-keep\\source\\css\\layout\\_partial\\first-screen.styl中以下部分，有注释的地方就是我修改了的地方\n.description &#123;  /*color $first-screen-font-color*/  color: rgb(255 250 250) /*字体颜色*/  font-weight bold  font-size $first-screen-font-size  line-height 1.8  text-align center  background: rgba(50,50,50,0.3); /*字体背景颜色和透明的*/  padding: 3px 15px; /*字体背景框的大小*/  border-radius: 5px; /*圆角*/  .desc-item &#123;    /*color $first-screen-font-color*/    color: rgb(255 250 250) /*字体颜色*/  &#125;  +keep-tablet() &#123;    font-size $first-screen-font-size * 0.9  &#125;&#125;\n\n修改了之后，首页居中的介绍文字就会变成当前的模样（之前的样式没有背景框，在自定义背景后很容易就看不清）\n\n同时我们还需要修改4号框，给它添加一个能够让它看得清的背景框（图标颜色没有办法修改，只能修改背景框颜色）\n\n4号框所在配置文件和3号框相同，找到.s-icon-list字段，添加以下内容\n.s-icon-list &#123;  background: rgba(220 220 220,0.3); /*字体背景颜色和透明的*/  padding:4px 11px 4px 11px; /*字体背景框的大小*/  border-radius: 5px; /*圆角*/  ...&#125;\n\n8.3 顶部字体加粗\nhexo顶部底部透明度渐变\n\n参考这篇博客的 1-2, 修改 keep\\source\\css\\layout\\_partial\\header.styl\n找到以下代码\n.menu-item &#123;\tfloat: left;\tposition: relative;\tmargin-left: 30px;\tfont-size: 1rem;\tcursor: pointer;\tcolor: var(--default-text-color);\t......\n\n加一条font-weight: bold，修改结果：\n.menu-item &#123;\tfloat: left;\tposition: relative;\tmargin-left: 30px;\tfont-size: 1rem;\tfont-weight: bold;\tcursor: pointer;\tcolor: var(--default-text-color);\t......\n\n顶栏和底栏透明度渐变修改参考 8.5，我更新过后的方法可以让顶栏和底栏的透明度渐变随着明暗模式变化\n8.4 文章侧边栏toc更新了之后的侧边栏变到了页面的右边，且默认下是没有背景的（因为默认在文章页面也是纯白的，没有背景也能看得清）\n但是当下我已经设置了全局背景，所以就需要修改一下！\nkeep更新3.5.2之后的侧边栏配置文件变了,现在是在keep/source/css/layout/_partial/中的toc.styl\n.post-toc-wrap &#123;  position relative  box-sizing border-box  width 100%  height 100%  overflow-y auto  font-size 0.92rem  font-weight: bold /*字体加粗*/  border-radius: 5px; /*圆角*/  ...&#125;\n\n添加我注释了的这几项就OK了，如果你想要旧版样式（固定在左侧）可以尝试将position修改为fixed\n8.5 明暗模式适配修改完背景颜色和背景图之后，就会出现下面的情况：如果有用户的电脑是暗色模式，进入博客的时候，就会发现字完全看不清，整个界面都很难看\n\n解决办法那就是需要让我们的背景颜色能根据明暗自动切换！\n我们要做的，就是在 hexo-theme-keep\\source\\css\\ 中添加一个 my 文件夹，并在内部添加一个 user-style.styl\n// 全局背景的的颜色切换.dark-mode&#123;    --content-background-color:#37383fe6;&#125;.light-mode&#123;    --content-background-color:#ffffffe6;&#125;// toc栏大小.post-toc-wrap .post-toc .nav&#123;  padding:21px&#125;// 使toc能够更具明暗模式自动切换颜色.light-mode .post-toc-wrap &#123;    background-color: #ffffffe6;&#125;.dark-mode .post-toc-wrap &#123;    background-color: #37383fe6;&#125;// 顶部背景透明度渐变，明暗变化.light-mode .header-wrapper &#123;    background: linear-gradient(to bottom, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0.4));&#125;.dark-mode .header-wrapper &#123;    background: linear-gradient(to bottom, rgba(30, 30, 30, 1), rgba(30, 30, 30, 0.4));&#125;// 底部背景透明度渐变，明暗变化.light-mode .page-main-content-bottom &#123;  background: linear-gradient(to top, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4))/*透明度设置*/&#125;.dark-mode .page-main-content-bottom &#123;  background: linear-gradient(to top, rgba(30, 30, 30, 0.9), rgba(30, 30, 30, 0.4));&#125;\n\n写完后，在 css/style.styl 中引用这个文件就可以了\n@import &quot;my/user-style.styl&quot;\n\n刚开始我用的办法太蠢了，浪费了好多时间，而且经常失效。后来请教了一位会前端的朋友，他一下就帮我搞定了，呜呜呜呜😫\n\n按照上面修改了顶栏和底栏样式后，请不要开启keep配置文件中的header_transparent，否则两个效果叠加，主页顶栏会变得有些难看\n# Set transparent background for header.header_transparent: false  # Option values: true | false\n\n8.6 页脚自定义8.6.1 添加站点运行时间2023-01-09 添加了站点运行时间，删除了hexo主题的提示。\n要想添加网站运行时间，keep主题修改 keep/layout/_partial/footer.ejs，找到如下代码\n&lt;% if (f_upyun) &#123; %&gt;    &lt;div class=&quot;ypyun-info info-item&quot;&gt;        &lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;&lt;%= f_upyun %&gt;&quot;&gt;        &lt;%- __(&#x27;footer_upyun&#x27;, &#x27;&lt;img src=&quot;/images/upyun.png&quot; height=&quot;20&quot;&gt;&#x27;) %&gt;        &lt;/a&gt;    &lt;/div&gt;&lt;% &#125; %&gt;\n\n在下方添加如下代码，来自👉hexo+yilia添加网站运行时间\n源站的代码有点问题，详见该页面评论（有人指出，但作者没有更新正文）\n&lt;!-- 添加网站运行时间 --&gt;        &lt;% if (theme.running_time &amp;&amp; theme.running_time.enable &amp;&amp; theme.running_time.create_time) &#123; %&gt;            &lt;div class=&quot;timerun-info info-item&quot;&gt;                &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;                &lt;script&gt;                var now = new Date();                function createtime() &#123;                    //此处修改你的建站时间或者网站上线时间                    var create_time = &#x27;&lt;%- theme.running_time.create_time %&gt;&#x27;;                    var grt = new Date(create_time);                    now.setTime(now.getTime() + 250);                    days = (now - grt) / 1000 / 60 / 60 / 24;                    dnum = Math.floor(days);                    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);                    hnum = Math.floor(hours);                    if (String(hnum).length == 1) &#123;                        hnum = &quot;0&quot; + hnum;                    &#125;                    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);                    mnum = Math.floor(minutes);                    if (String(mnum).length == 1) &#123;                        mnum = &quot;0&quot; + mnum;                    &#125;                    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);                    snum = Math.round(seconds);                    if (String(snum).length == 1) &#123;                        snum = &quot;0&quot; + snum;                    &#125;                    document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot; + dnum + &quot; 天 &quot;;                    document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;                &#125;                setInterval(&quot;createtime()&quot;, 250);                &lt;/script&gt;            &lt;/div&gt;        &lt;% &#125; %&gt;        &lt;!-- 添加网站运行时间 --&gt;\n\n这里修改完毕后，还需要在keep的配置文件里面添加下面这一项；如果后续不想要了，可以直接设置为false禁用这一栏\n# 网站运行时间，格式形如：“本站已安全运行 101 天 12 小时 13 分 41 秒”# Runing Timerunning_time:  enable: true  create_time: &#x27;01/01/2021 00:00:00&#x27; #此处修改你的建站时间\n\n如果你想删除hexo的提示，那就注释掉 footer.ejs 的这些代码\n&lt;!--注释掉这里的代码，就可以取消底部的hexo标识--&gt;&lt;!-- &lt;div class=&quot;theme-info info-item&quot;&gt;    &lt;%- __(&#x27;powered_by&#x27;, &#x27;&lt;a target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) %&gt;&amp;nbsp;|&amp;nbsp;&lt;%- __(&#x27;theme&#x27;) %&gt;&amp;nbsp;&lt;a class=&quot;theme-version&quot; target=&quot;_blank&quot; href=&quot;https://github.com/XPoet/hexo-theme-keep&quot;&gt;Keep v3.5.2&lt;/a&gt;&lt;/div&gt; --&gt;\n\n8.6.2 修改页脚内容到底部的距离如图，这个页脚到底部的距离实在有点宽，弄得背景图都被挡住了好大一部分；对于强迫症来说，这谁受得了，改了！\n\n找到 hexo-theme-keep\\source\\css\\layout\\_partial 修改 footer.styl 的 padding-bottom\n.info-container &#123;  padding-bottom 1rem  text-align center&#125;\n\n默认是 1rem，这里我直接改成 0 看看是不是修改对地方了；hexo s 一看，直接靠底了，说明我们改对地方了！\n\n随后我就修改成了 0.3rem，还是需要留一点边距的\n8.6.3 修改页脚字体颜色\n配置了背景图之后，页脚的字体颜色不那么容易看清楚，这时候应该怎么办？改他丫的！\n在浏览器按F12进入开发者模式，用截图软件（qq截图或者sanipaste）选取到这个框上，就能看到颜色的色值\n\n复制该色值，在F12所打开的开发者面板中的页面一栏，粘贴搜索，可以看到 --text-color-4 正好就对应了这个颜色\n\n改成黑夜模式，重复上述步骤，可以看到，此时颜色依旧对应的是 --text-color-4 那么就实锤了该变量即为页脚字体颜色的变量\n\n直接在 8.5 中配置好的 user-style.styl 里面添加，自定义一个颜色；我们的需求是让黑夜模式的字体更亮，白天模式的字体更黑\n.dark-mode&#123;    --content-background-color:#37383fe6;    --text-color-4:\t#F5F5F5; //黑夜模式底部字体颜色&#125;.light-mode&#123;    --content-background-color:#ffffffe6;    --text-color-4: #242424; //白天模式底部字体颜色&#125;//...\n\n大功告成！\n\n8.6.4 页脚添加shields.io的图标为了更好的展示一部分内容，我们可以在页脚加上一些图标，并让这些图标可以点击跳转到指定页面！\n\nhttps://shields.io/\n\n修改 hexo-theme-keep\\source\\css\\layout\\_partial\\footer.ejs，在中间部分添加如下代码（直接跟在 8.6.1 配置的站点运行时间之后）\n如果你不知道具体的位置，还请移步我的Github仓库查看更改后的文件\n&lt;div class=&quot;shields-info info-item&quot;&gt;\t&lt;a href=&quot;link for click&quot; &gt;        &lt;img src=&quot;img url&quot; height=&quot;20px&quot;&gt;     &lt;/a&gt;&lt;/div&gt;\n\n这里的href后跟随的是点击图标会跳转的网页，img src后面跟随的是图片的url；\n\n比如我这样配置了之后，页脚就会出现一个这样的图标，用于标识我的hexo主题版本\n\n点击这个图标，会跳转到keep 主题的Github仓库；\n\n为了方便配置，写成下面的循环+if判断的形式；并且将图标的搞定锁定为20px，避免不同图标大小导致不统一，很难看\n&lt;!-- 添加底部的shields io图片 --&gt;      &lt;% if (theme.shields &amp;&amp; theme.shields.enable) &#123; %&gt;          &lt;div class=&quot;shields-info info-item&quot;&gt;              &lt;% for (var i in theme.shields.data)&#123; %&gt;                  &lt;% if (theme.shields.data[i].img) &#123; %&gt;                      &lt;a href=&quot;&lt;%= theme.shields.data[i].link%&gt;&quot; &gt;                          &lt;img src=&quot;&lt;%= theme.shields.data[i].img%&gt;&quot; height=&quot;20px&quot;&gt;                      &lt;/a&gt;                  &lt;% &#125; %&gt;              &lt;% &#125; %&gt;          &lt;/div&gt;      &lt;% &#125; %&gt;\n\n这样就可以直接在配置文件中添加新的图标和url，不需要来这里修改源码了！😁\n转到我们keep.yml配置文件，在最底部添加如下代码\n# Add shields.io in footershields:  enable: true # Option values: true | false  data:    hexo:      link: https://github.com/XPoet/hexo-theme-keep      img: https://img.shields.io/badge/hexo-keep%20v3.5.2-brightgreen\n\n这样就能在底部添加一个上面提到过的hexo主题图标\n要想追加，那就继续在后面以相同格式填写\n# Add shields.io in footershields:  enable: true # Option values: true | false  data:    hexo:      link: https://github.com/XPoet/hexo-theme-keep      img: https://img.shields.io/badge/hexo-keep%20v3.5.2-brightgreen    travelling:      link: https://www.travellings.cn/go.html      img: https://img.musnow.top/i/2023/05/647563ddab0fb.gif\n\n代码会自动判断img是否为空，如果img为空，则不会添加该模块；link项可以为空，此时点击图标不会跳转到其他页面。\n效果还是不错哒！您可以在本页页脚查看😶‍🌫️\n8.7 点击头像跳转关于页面这个操作就是把没有多少人看的关于页面给藏起来，这样就不需要占用顶栏的一个menu了\n修改方法很简单，在keep主题中，默认点击头像的操作是跳转到当前页面（可以理解为啥都不做）\n我们只需要把链接改成跳转到关于页面就行了！\nthemes/keep/layout/_partial/header.ejs\n\n修改以下字段\n&lt;% if (s_logo || bi_logo_img) &#123; %&gt;    &lt;a class=&quot;logo-image&quot; href=&quot;/&quot;&gt;        &lt;%- image_tag(s_logo || bi_logo_img) %&gt;    &lt;/a&gt;&lt;% &#125; %&gt;\n\n修改之后\n&lt;% if (s_logo || bi_logo_img) &#123; %&gt;    &lt;a class=&quot;logo-image&quot; href=&quot;/about/&quot;&gt;        &lt;%- image_tag(s_logo || bi_logo_img) %&gt;    &lt;/a&gt;&lt;% &#125; %&gt;\n\n如果你想让点击网站标题也跳转到关于页面，那就把下面的logo-title也给改掉\n&lt;a class=&quot;logo-title&quot; href=&quot;/about/&quot;&gt;   &lt;%= bi_title || config_title || &#x27;Keep Theme&#x27; %&gt;&lt;/a&gt;\n\n随后进入keep的config文件，注释掉memu中的about页面，这并不代表about页面会被删除，只是不显示在menu上\nmenu:  Home: /  Archives: /archives  Categories: /categories  Tags: /tags  留言: /qa  Links: /links  #About: /about\n\n搞定！\n未完待续…期待后续的更新，亦或者是我能从折腾中走出来，别再瞎搞了……\n今天的升级部署就花了几乎一整天的时间😥\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【图床】删除对象存储桶前一定要检查！","url":"/posts/3595872827/","content":"我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。\n什么情况？我在博客尚有引用某个对象存储bucket中图片的情况下，删除了那个bucket（因为这个bucket很久没有用，算是弃用的）\n还好今天看旧笔记的时候，突然发现了这个问题，立马去重新搜索了一下这个旧bucket的图片链接，还好还好，受影响的只有两篇文章\n\n一篇之前导出过PDF，图片还能找到\n另外一篇文章以文字为主，内部丢失的图片可有可无\n\n我恢复了第一篇里面的图片，然后修改了第二篇中和图片相关的文字说明，算是解决了这个问题。\n又重写检查了一下笔记目录，算是彻底没有这个被我删除的bucket里面的图片了。\n这一次还好，算是没有丢东西，不然数据不备份就删除的笑料又要多一个了……🤣\n以此为戒删除bucket之前一定要检查自己到底还有没有使用这个bucket中的文件或者图片！\n删除图床本地目录前，一定要检查自己还有没有这个本地目录里面的图片！\n最佳方案：不要管那个bucket，将其访问权限改成私有后，使用备注功能将其标记为弃用。以后不再使用该bucket即可。\n因为对于我个人使用来说，一个bucket里面不会有太多文件，目前最大的图床bucket也不过2GB而已，把它留在那里花不了几个钱！不然把bucket删了，哪天发现需要去里面找旧文件的时候无从下手就麻烦了！\n\n至于我为什么要删……其实是因为我有点强迫症，不用还留在那里看着有点不爽……\n\n当然还有另外一个解决方案：使用rclone等工具，将s3中的所有文件下载到本地，打包多地备份后，删除云端bucket\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【博客】hexo配置sitemap和百度|必应|谷歌收录","url":"/posts/3595872826/","content":"最近没事找事，又看了会关于博客主题的东西，之前的sitemap一直没有弄上去，现在有时间就弄一下。\n1.hexo安装sitemap插件在你的hexo路径下执行如下命令，安装sitemap生成插件\nnpm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save\n\n实测在windows11的node v16.20.2和npm  9.8.1下可以正常安装，但是安装baidu-sitemap插件的时候可能会有警告（不影响使用）\n安装完毕插件后，在你的hexo配置文件_config.yml中添加如下内容，指定站点地图的文件名字即可。\n# 百度和谷歌的sitemap# npm install hexo-generator-baidu-sitemap --save# npm install hexo-generator-sitemap --savebaidusitemap:    path: baidusitemap.xmlsitemap:    path: sitemap.xml\n\n请注意，需要修改的是hexo的配置文件，并非主题配置文件！\n2.如何修改hexo主题生成的index.html文件？一般情况下，站点平台都会让你在index.html的&lt;head&gt;里面加一个html语句，来验证站点的所有权。比图百度的验证html语句如下\n&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;验证码&quot; /&gt;\n\n部分hexo主题可能提供了自定义&lt;head&gt;的选项（比如butterfly主题就有）\n如果你使用的主题没有提供自定义&lt;head&gt;，可以尝试在主题文件夹下搜索index或者head关键字，来找到当前主题使用的index.html生成源文件\n\n该方法仅适用于将主题文件直接下载到themes文件夹下的情况，因为如果你用的是npm安装的主题，那么修改的主题文件是不会对其他地方的部署生效的，下一次更新主题还会覆盖掉。\n\n比如下图是keep主题v3.6.1版本中的head.ejs，你只需要把提供的meta标签加到这里面，下一次部署的时候的index.html中就会带上这个标头了。\nthemes\\keep\\layout\\_partial\\head.ejs\n\n\n3.站长平台添加sitemap百度百度资源搜索平台 https://ziyuan.baidu.com/site/index#/\n百度实在是无语，之前安装了hexo-baidu-url-submit插件，主动调用百度api给他推送url，结果弄了已经快一年了，还没有收录我的站点。\n\n实话说，百度不收录站点，网站看的人就很少。百度我自己博客的关键词，结果是一堆被百度收录的爬虫站点用我的文章赚流量。唉……\n\n在资源搜索平台的站点管理中添加你的站点，用第二点提到的方式进行验证\n\n添加完毕后，在普通收录中可以找到sitemap提交的区域。但是不知道为什么我这里的提交配额是0，搜索了一下也没有找到原因。\n\n百度资源平台提交sitemap是取消了还是我被限制了？\n有人说是站点质量太低被百度屏蔽了，但是这个情况也是很多人都遇到过的。估计是百度策略更新什么的，不允许你添加了吧！\n如果你已经添加了sitemap，请不要将其删除，免得到时候又没有办法添加了。\nbingbing的站长平台直接搜就行：https://www.bing.com/webmasters/about?setlang=zh-cn\n\n国内裸连可能不稳定，需要用点方法。\n不过bing即便不提交sitemap也咔咔收录了我的博客，主打一个主动+来者不拒。\n\n进去之后，用微软账户登录，然后点击新增站点，输入你博客的域名\n\nbing会让你验证站点所有权，根据下面三种方式的指引，选择一种就行了。如果你不知道如何修改hexo的源文件，使用CNAME验证方式是最简单的（只要你有域名有权就行了）。\n\n不过估计有很多老哥都是白嫖的github pages或者netlify&#x2F;vercel的二级域名，在没有域名所有权的情况下，你可以用前两种方式来验证。\n\nXML文件方式：将bing提供的XML文件下载，然后放到你hexo源目录的source文件夹下，就可以了。\nHTML MATE标记验证：部分hexo主题可能提供了自定义header的选项（比如butterfly主题就有）其他主题可以参考上文第二点操作\n\n域名验证完毕后，在左侧可以提交网站地图（即sidemap）\n直接点击按钮提交你的站点地图的url就可以了。bing会自动进行处理，如下图我的第一个sitemap已经成功处理出来了383个链接，非常完美。\n\n谷歌实话说，一个纯中文且面向国内读者的站点，在谷歌上面收录了估计也没多大用处，但是可以没用，但不能没有。也给他弄一下吧。\nhttps://search.google.com/search-console/welcome\n首先是输入站点网址，因为我不需要验证所有站点，只把博客收录了就行，所以这里我选的是网址前缀。输入站点的时候需要把http也带上\n\n谷歌的验证方式也有很多种，这里的操作和bing是一样的，把它发给你的文件直接放到hexo的source路径下就可以了，或者采用html标签的方式验证。\n\n验证成功后，选择前往资源界面，即前往当前站点的控制台。\n如果你不小心点了完成，站点资源界面在站长工具的左侧边栏里面，在里面可以找到你已经添加了的站点。\n\n在左侧选择站点地图，点击添加即可\n\n\n搞定！有什么问题，欢迎评论区提出！\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【Hexo】在中英文之间添加空格","url":"/posts/3894841472/","content":"说明和插件安装如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找hexo有没有对应的插件，还是有的\nnpm install hexo-filter-auto-spacing --save\n\n安装了之后，在hexo的_config.yml里面添加配置项\n# hexo 中英文之间自动加空格# npm install hexo-filter-auto-spacing --saveauto_spacing:  enable: true\n\n随后hexo s就能看到插件启用后的结果了\n\n请注意，该插件仓库 https://github.com/hexojs/hexo-filter-auto-spacing 已经被设置为公共归档，且最后一次代码提交是2022年6月。\n2023年12月10日实测该插件依旧有用，但不保证hexo更新后依旧有效。慕雪使用的hexo和主题版本如下。\nhexo 6.2.0hexo-butterfly 4.9.0\n\n暂时没有搜到其他仍在更新的插件。\nbuffterfly主题自带配置感谢评论区老哥的提醒，buffterfly主题其实自带了这个配置项 https://butterfly.js.org/posts/ceeb73f/#Pangu\n使用如下命令卸载上方提到的插件。\nnpm uninstall hexo-filter-auto-spacing --save\n\n在hexo-butterfly主题中pangu配置项就是中英文之间添加空格的配置。\n其中site是对全站生效，post是只对文章生效（对其他页面不生效）\n# https://github.com/vinta/pangu.js# Insert a space between Chinese character and English character (中英文之間添加空格)pangu:  enable: false  field: site # site/post\n\n将enable改成true即可启用，效果也很好，不仅中英文之间会添加空格，数字和中文之间也添加了空格。完美啦！\n\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【C语言】传值调用和传址调用","url":"/posts/2967424184/","content":"今天学习C语言的时候，接触到了两个全新的概念话不多说，就此和大家分享一下c语言中函数的传值调用和传址调用，希望有所帮助欢迎dalao无情指正！\n\n\n引子 : 交换函数我们先来写一个简单的函数\n目的是交换a和b\n#include&lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint b = 20;\tint tmp = 0;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);//显示a和b最初的值\ttmp = a;\ta = b;\tb = tmp;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);//查看交换结果\treturn 0;&#125;\n\n运行的结果如图\n\n需要注意的是，这是在主函数main里面直接进行的交换程序，而我们想要的其实是一个可以在任何地方使用的交换函数\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint b = 20;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\tswap1(a, b);\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\treturn 0;&#125;\n\n若想达成以上目的，我们要先把上述代码优化成以下形式。其中swap1就是我们即将要写的自定义函数\nvoid swap1(int x, int y)&#123;\tint tmp = 0;\ttmp = x;\tx = y;\ty = tmp;&#125;\n\n\nvoid表示自定义函数无返回类型\n\n这个自定义函数看起来没什么问题对吧！\n但是结果却告诉我们a和b并没有被交换\n\n这是为什么？\n查错方法这里给大家介绍一个老师教授的查错方法。虽然我估计大家都知道（小声bb）\n那就是用vs编译器自带的监视器了（快捷键f10，我用的是最新的vs2019，官网即可免费下载使用）\n\n\n左边有个很Q的黄色小箭头，告诉你正在监视那一步\n每按一次f10代码就会往下走一行\n当遇到swap此类函数时，按f11进入函数，f10会直接跳过函数\n\n\n可以看到代码在第25行的时候，x和y已经获得了a和b的值，tmp此时为0\n\n下一行继续，tmp变成10\n\n再下一行，x获得y的值，x&#x3D;20\n\n然后y获得tmp里面保存的x的值，y&#x3D;10\n\n可当我们下一步跳出函数，回到主函数的时候\n会发现a和b仍然是10和20，并没有发生交换\n\n聪明的你肯定已经想到这是为什么了\n函数中的x和y与主函数的a和b是独立的，x和y的变化无法影响a和b\n那怎么样函数中的x和y才能影响函数外的a和b，从而达到我们交换的目的呢?\n这里需要涉及一个新的大家都知道的概念\n&amp; 取地址操作符先用一个简单的例子让大家了解&amp;取地址操作符的作用\n在我们的c语言中，每个字符都对应了一个它独自的地址\n而&amp;符号就是取出这个字符的地址\nint main()&#123;\tint a = 10;\tint* pa = &amp;a;//pa指针变量\t*pa = 20;//解引用操作\tprintf(&quot;%d\\n&quot;, *pa);\treturn 0;&#125;\n\n这里面的*pa获取了a的地址，在打印的时候会顺着地址找到a，显示a的结果\n让我们继续\n我们将上述交换函数代码的主函数改成如下形式\nint main()&#123;\tint a = 10;\tint b = 20;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);    //swap1(a, b);\tswap2(&amp;a, &amp;b);\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\treturn 0;&#125;\n\n比较swap1和swap2，会发现swap2括号中的a和b前面都多了一个**&amp;操作符**\n这个操作符会让swap2不再读取a和b的数值，即10和20\n而是会读取a和b在内存中的地址\n相对应的，swap2函数也要改成如下形式\n其实形式和swap1基本一样，只是x和y被替换成了**pa 与 pb\nvoid swap2(int* pa, int* pb)&#123;\tint tmp = 0;\ttmp = *pa;\t*pa = *pb;\t*pb = tmp;&#125;\n\n\n表明 pa和pb都是*指针变量\npa和pb保存的是a和b的地址\n\n这时候我们再运行代码，a和b被很好的调换了\n我们的目的也达成了\n\n实参和形参要想了解为什么两个函数会有这样的不同\n我们需要学习实参（实际参数）和形参（形式参数）\n\nvoid swap1(int x, int y)&#123;\tint tmp = 0;\ttmp = x;\tx = y;\ty = tmp;&#125;void swap2(int* pa, int* pb)&#123;\tint tmp = 0;\ttmp = *pa;\t*pa = *pb;\t*pb = tmp;&#125;int main()&#123;\tint a = 10;\tint b = 20;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\t//swap1(a, b);\tswap2(&amp;a, &amp;b);\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\treturn 0;&#125;\n\n\n在这串代码中，a和b是实参\nx、y、*pa、 *pb都是形参\n\n可以借用另外一个代码的例子进一步给大家了解实参\nint get_max(int x, int y)&#123;\tif (x &gt; y)\t\treturn x;\telse\t\treturn y;&#125;int main()&#123;\tint a = 10;\tint b = 20;\tint max = get_max(a, b); \tprintf(&quot;max= %d\\n&quot;, max);    max = get_max(100,300);    max = get_max(100,300+1);//实参可以是表达式\tmax = get_max(100, get_max(3, 5));//也可以是函数\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n在这串代码中，抛去上面的a和b\n max &#x3D; get_max(100,300);是我们使用这个函数的基本方式\n\n这里面的100和300是实参\n同时**300+1和get_max(3, 5)**也是实参\n对应的函数中的x和y就是形参\n\n\n当实参传给形参的时候形参其实是实参的一份临时拷贝对形参的改变是不会改变实参的\n\n这样解释大家应该对实参和形参有一定的认识了\n接下来就有请我们的标题人物隆重登场\n传值调用，传址调用这两个调用方式十分重要，而且两个字从读音到长相（bushi）都十分相似\n所以大家一定要注意区分！\n\n简而言之\n\n当我们需要在函数内部操作函数外部的变量的时候→传址调用\n如果我们只需要外部变量的值，不需要改变外部变量→传值调用\n\n以上面的交换函数为例子\nvoid swap1(int x, int y)//传值调用&#123;\tint tmp = 0;\ttmp = x;\tx = y;\ty = tmp;&#125;void swap2(int* pa, int* pb)//传址调用&#123;\tint tmp = 0;\ttmp = *pa;\t*pa = *pb;\t*pb = tmp;&#125;\n\n因为swap1里面的x和y是传值调用，x和y只获取了a和b的值，自然无法影响函数外面的a和b\n而swap2中的*pa 和 *pb获取的是a和b的地址（址→地址）所以可以影响函数外的a和b，实现它们的交换\n\n注：x，y，*pa ， *pb 都是局部变量，它们在出了函数外之后就无法使用，也失去了使用它们的意义\n\n结束语本篇小博客到这里也结束啦，感谢你看到最后！\n如果感觉看完之后仍有不明白的地方\n可以去观看这期视频里面的讲解，swap函数的讲解在1小时17分【点我跳转】\n我也是刚学C语言的小白，博文有错在所难免，请各位大佬无情指正\n这篇博文虽然字不多，但依旧花了我2小时的时间，如果觉得不错就点个赞再走吧！\n求求了，跪谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】数组名是什么？","url":"/posts/4234112012/","content":"数组名是什么？@[TOC]\n在我们敲代码的过程中，经常要遇到使用数组的地方\n提到使用数组，就离不开数组名\nint arr[10] = &#123; 0 &#125;;//arr就是数组名\n\n同时我们也经常要用到使用sizeof计算数组元素个数的情况\nint sz = sizeof(arr) / sizeof(arr[0]);\n\n所以了解数组名的概念对于我们的c语言学习十分重要\n数组名是数组首元素的地址如题，这个概念在我们创建自定义函数的时候尤为重要\n最经常犯的错误就是在自定义函数内部求主函数中arr数组的元素个数\nvoid sp1(int arr[])&#123;\tint sz = sizeof(arr) / sizeof(arr[0]);//放在此处sz计算为1，err    for (i = 0; i &lt; sz; i++)&#125;\n\n这时从主函数传过来的arr只有首元素的地址，使用sizeof计算得到的sz只有1\n对后续要进行的操作如for循环中的 i&lt;sz来说是无效的\n这是因为int arr传到自定义函数中的是形参\n而形参arr是无法计算内部元素大小的\n（具体的代码示例将在下篇博客的冒泡排序中展示）\n代码示例1 sz我们可以用简单的代码来了解不同arr的书写方式得到的结果\n#include &lt;stdio.h&gt;int main()&#123;    int arr[10] = &#123; 0 &#125;;\tint sz = sizeof(arr);//数组名表示整个数组\tprintf(&quot;%d\\n&quot;, sz);\treturn 0;&#125;\n\n可以看到结果是40，这表明数组中10个元素所占用的字节是40\n在这个代码里面，arr表示的是整个数组，sizeof求的自然也是整个数组所占字节的长度\n\n我们可以用下面这串代码得到数组内的元素个数，结果为10\n#include &lt;stdio.h&gt;int main()&#123;    int arr[10] = &#123; 0 &#125;;    int sz = sizeof(arr) / sizeof(arr[0]);\tprintf(&quot;%d\\n&quot;, sz);\treturn 0;&#125;\n\n\n代码示例2下面这串代码中，我们使用三种不同的方式键入arr\n#include &lt;stdio.h&gt;int main()&#123;\tint arr[10] = &#123; 0 &#125;;\tprintf(&quot;%p\\n&quot;, &amp;arr);//1\tprintf(&quot;%p\\n&quot;, arr);//2\tprintf(&quot;%p\\n&quot;, &amp;arr[0]);//3\treturn 0;&#125;\n\n\n我们会发现三次打印的结果是一样的\n\n&amp;arr取出的是整个数组的地址\narr作为数组名–&gt;数组首元素的地址\n&amp;arr[0]取出的是数组首元素的地址\n\n但实际上三者的本质是完全不同的\n可以用+1的方式来找出它们的不同之处\nint main()&#123;\tint arr[10] = &#123; 0 &#125;;\tprintf(&quot;%p\\n&quot;, &amp;arr);//1  &amp;arr取出的是数组的地址\tprintf(&quot;%p\\n&quot;, &amp;arr+1);\tprintf(&quot;%p\\n&quot;, arr);//2\tprintf(&quot;%p\\n&quot;, arr+1);\treturn 0;&#125;\n\n\n可以看到&amp;arr+1之后的结果和arr+1的结果是不一样的\n\n\n\n&amp;arr+1与&amp;arr之间相差40\narr+1与arr之间相差4\n\n这是因为&amp;arr代表的整个数组的地址，加1即跳过了整个数组\n而arr只代表首元素地址，加1表示第二位的地址\n总结c语言中有很多这样的小知识点，需要我们记录并加以了解\n只有理解了为什么，我们才能在后续的学习、代码创作中写出更好的代码\n点个赞再走呗，求求了！\n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【方法分享】准大学生如何自学C语言","url":"/posts/4266945915/","content":"【方法分享】准大学生如何自学C语言\n\n\n[TOC]\n准大学生如何自学C语言虽说现在已经接近我们最长的且无忧无虑的暑假的尾声\n但我估摸着很多小伙伴还是和我一样整天摸鱼，不知不觉就浪费了一天\n（其实只有我在摸鱼对吗，流下了不争气的泪水）\n不扯这些没用的，进入今天的正题\n本篇博客和大家分享一下我是如何自学C语言的，以及如何做学习笔记\n学习方法各不相同，请以自身情况为准\n一、找寻一个优质教学视频好的教学资源永远是我们学习的第一步!\n在这里我建议以视频为主，书本为辅助\nC语言的书籍繁多而杂，有很多热销书籍并非出自名门大家，有纰漏在所难免。作为初学者的我们肯定看不出这些纰漏，但它可能会把我们的学习引入死胡同。\n视频同样也会有错误的地方，这也是为何我们需要寻找优质教学视频\n在看视频的基础上，复以书本练习为辅助，方为学习妙计（个人观点）\n在这里强烈推荐b站比特鹏哥的C语言教学视频 连接\n\n讲的非常非常非常详细，比我之前在某堂在线找到的不知名视频好太多了（那个视频里老师就对着你念ppt，枯燥乏味无干货）\n这里推荐大家直接去看最新版本的视频，画质更好。内容新旧基本是一样的\n找完视频之后请立马开动，收进收藏夹只会让你开学了进度还是0%\n不过想必来csdn看博客的你已经不是小菜鸡了（doge）\n二、使用优质编译器拒绝devc++学习C语言\n当然，它肯定能用，我也推荐你在电脑里面下一个devc++\n但是它不适合日用学习！！\n理由非常简单，让我们看看VS2019和devc++在同一个代码下的界面\n\n请问那边更容易让你眼花缭乱？视觉疲劳？\n(你要说vs颜色太多眼花缭乱，那我无力反驳)\n\nvs2019同样可以改成白色背景，但深色对比度更高推荐深色\n\n同样的，当我们输入库函数的时候，vs可以帮你补充剩下函数\n而devc++就需要看你背单词的功力了\n\n而且在遇到代码错误的时候，vs2019能更准确地报出错误的地方，\n有些中英文半角错误的符号，如分号、逗号。vs2019都会用一个小波浪线标出，而devc++莫得提示\n（讲道理初学的我最常犯的错误就是打错中英文半角+打错函数名……）\n\n前面提到建议在电脑里面下个devc++，因为vs2019不能直接运行.c文件，必须要把它放在一个“项目”里面才行\n对于单个文件的运行来说devc++更方便，可以把它当作一个简易的.cpp和.c的运行器\nVS2019可以直接在官网下载社区版本，请不要下载VS code，对于初学者来说它的初始化设置非常麻烦！\n官网链接&#x3D;&gt;visualstudio.microsoft.com\n(由于微软的土豆服务器，我打不开官网，自然截不到图……太棒了微软)\n\n博客写到一半回去瞅了一眼，终于打开了\n我们需要下载的是2019的社区版本\n\n其次我们还需要收藏几个用于学习时查找资料的网站\n它们主要是用于查找函数定义的，具体方法我在之前的博客中已有过分享 [链接]网站推荐：\ncplusplus.com - The C++ Resources Network \ncppreference.com\n三、安排一个电子笔记初学c语言时的知识繁多而杂，不记笔记的话很多知识点都是左耳进右耳出（至少我是这样）\n纸质笔记本在这种需要大量代码练习的学习中效率太低\n这时候就得请出我们的电子笔记本了\n在这里给大家推荐个人认为最好用的OneNote\n\n如果你是笔记本用户，有出厂赠送的OneNote2016\\2019，直接用即可\n台式机用户OneNote多半是装系统就自带了的。没有的话可以去微软商店下一个OneNote for WIN10，或微软官网下载OneNote2019\n\n\n优点：IOS\\安卓\\WIN\\MAC全平台同步，免费！\n缺点：微软土豆服务器，有时候跨平台同步极慢。\n\n同时建议大家下载一个snipaste，作为截图软件辅助我们的电子笔记\n\nOneNote自带的截图会自动给你添加一个截图时间，有点影响界面观感\n\n\n新建一个笔记本，命名为c语言\n\n\nOneNote主要的界面就是这种三段式的笔记夹。大家可以参照我的分类，把大类知识点放在第一个分区，小类放在第二个\n这样我们后期复习or回看遗忘知识点也会更加方便\n这里建议大家给每个小类知识点都做上数字序号，且不要重复\n这样就可以在已有的笔记内表明这个知识点和另外一个知识点的联系\n\nOneNote的插入链接功能同样可以插入笔记本内页的连接\n如图，我们右击16EOF，点击”复制指向页面的链接“\n\n然后在我们想插入这个链接的位置插入\n\n\n随后点击它，就能直接跳转到指定的笔记本页面\n在复习和知识点联动的时候非常方便实用\nOneNote还有其他非常丰富的功能，在这里推荐大家看这个视频学习OneNote的用法，博客里就不再展开了\n岷|你不得不知道的OneNote功能|电子笔记能有多强！bilibili\n需不需要一个ipad来辅助学习？提到电子笔记，很多人都会想到用平板来做笔记\n这里我的建议是\n-有ipad或其他平板的用户可以购入平替笔尝试\n\n不要直接买高贵的原装笔，对于做笔记来说无济于事，特别是ipad\n发现不合适的时候你想二手出or吃灰就是浪费钱了，平替笔90一支不想用了也可以留着\n最好在购入七天内使用并判断这种方式适不适合你，这样不适合还能无理由退了\n\n\nipad用户推荐益b思的5代青春版平替笔，98一支，真的不是广告，我个人觉得还行顺便提一句而已！\n\n-如果你没有平板，请不要给自己创造需求然后喜加一，因为平板联网激活后就不给退货的！\n在我两周的win电脑+平板做笔记的学习中，有如下问题需要注意\n\nOneNote同步需要一定时间，在电脑截图后ipad端OneNote同步至少20秒。服务器抽风的话就祝自己好运了\n在ipad做笔记可能会让你漏掉老师所讲知识点，因为注意力不在电脑屏幕上，导致回退视频\n请不要在ipad打开你的qq，不然可能做着做着就去聊天了……\n\n当我尝试丢掉平板直接用电脑做笔记的时候，发现效率直线上升！\n所以说用平板做笔记也是我自己给自己创造的需求（笑哭.jpg）\n四、除工具以外的学习方法上述三点都是围绕学习工具来展开的，现在说说其他的一些个人经验\n1.专心致志，不要让其他东西分心现在这个阶段，我们的身心是很放松的，自学c语言其实是在给暑假生活的末尾加料\n这种放松会让你我觉得C语言的学习并不是什么必须要做的、非做不可的事情\n所以手机就会成为你学习路上最大的阻碍……（以下均为本人情况，请勿对号入座）\n\n消息来了看一眼\n\n这部分好像我会，刷会手机\n\n\n虽然我知道这万万不可，可就是控制不住自己这双手\n\n好吧，既然打不过，那我们就跑啊！\n手机关闭WiFi，放在你不能直接够到的地方\n同样的，电脑也不要登录qq，wx，保持无线电静默，专心看视频学习\n\n我觉得咱们这个年纪应该没有非回不可的消息，父母找自己多半直接打电话\n\n2.多练习，多练习，多练习学C语言和学数学一样，一定要多刷题（写代码）\n在看视频的同时，跟着教学内容自己尝试着写写那些代码\n别觉得视频里都打了没必要自己再打一遍\n实际上照着打都会有一堆错误……\n买了书本的小伙伴可以照着书本上的示例代码练习\n在练习的途中更容易发现自己的问题，从而获取更多知识\n3.复习！前面提到了做笔记之事，笔记最主要的目的就是为了方便我们日后的复习。\n这里建议平时多去看看记录下来的操作符、字符类型、转义字符等等极其容易遗忘又经常用的上的知识点\n不然有时候就真的只能看着代码蒙蔽\n遇到新的小知识点的时候也要及时对笔记进行补充\n\n结语以上就是本c语言初学者+准大一同大家的学习方法的分享\n这方法可能不适合你，有些朋友可能更偏爱纸笔笔记，这都是OK的\n学习方法各有异同，但我们都有一个为通向未来大道而努力的心\n这就够了~\n感谢你看到这里，点赞+关注再走呗！万分感谢！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】sizeof操作符","url":"/posts/4048071056/","content":"@[toc]\nsizeof操作符上篇博客提到了一个知识点  【链接】\n\nsizeof操作符括号内的表达式是不会真正计算的\n\n这个是为什么呢？\n我们先来看看sizeof的基本用法\n基本用法#include&lt;stdio.h&gt;int main()&#123;\tint a=10;\tprintf(&quot;%d\\n&quot;,sizeof(a));\tprintf(&quot;%d\\n&quot;,sizeof(int));\t\tprintf(&quot;%d\\n&quot;,sizeof a);\treturn 0; &#125; \n\n打印结果为3个4\n但当我们以这种方式书写的时候，编译器就会报错\nprintf(&quot;%d\\n&quot;,sizeof int);\n\n\n\n在使用sizeof的时候，变量a的括号可以省略\n\n但直接计算int的时候，括号不能省略\n\n\n\n 这说明sizeof是一个操作符，而不是函数\n\nint arr[10]=&#123;0&#125;;printf(&quot;%d\\n&quot;,sizeof  (arr));printf(&quot;%d\\n&quot;,sizeof  (int[10]));\n\n这两句代码打印的都是40，其中int[10]是arr数组的类型\n\n 冷知识，我们可以用9[arr]来访问数组元素\n 但这么做会降低代码的可读性，所以我们还是采取arr[9]的形式更好\n\nint arr[10]=&#123;0&#125;;arr[9]=1;printf(&quot;%d\\n&quot;,9[arr]);\n\n\n\nsizeof和函数传参先来看看下面这个代码\n#include&lt;stdio.h&gt;void test1(int arr[])&#123;\tprintf(&quot;%d\\n&quot;,sizeof(arr));//4&#125;void test2(char ch[])&#123;\tprintf(&quot;%d\\n&quot;,sizeof(ch));//4&#125;int main()&#123;\tint arr[10]=&#123;0&#125;;\tchar ch[10]=&#123;0&#125;;\tprintf(&quot;%d\\n&quot;,sizeof(arr));//40\tprintf(&quot;%d\\n&quot;,sizeof(ch));//10\ttest1 (arr);\ttest2 (ch);\t\t\treturn 0; &#125; \n\n32位平台，打印结果如下\n\n\nVS编译器下\nx86–32位–int 4\nx64–64位–int 8\n\n为什么在main函数里面打印的是40和10\n到了函数里面就只有4了呢？\n数组传参数组在传参的时候，传过去的只是首元素的地址\n\n数组名代码数组首元素的地址\n\n问：为什么字符变量只占一个字节，但这里打印的是4呢？\n答：这里传入的是char数组的指针，指针变量都是4个字节\n\nsiezof和表达式现在就到我们的重点了\n为什么sizeof括号里的表达式没有真正地运算？\nshort s=5;int a=10;printf(&quot;%d\\n&quot;,siezof(s=a+2));printf(&quot;%d\\n&quot;,s);\n\n\n这里就牵扯到C语言程序运行的几个步骤了\n\n编译–test.c\n链接\n运行–test.exe\n\n简单地说，只有在链接之后运行的代码，才会真正给a赋值\n而sizeof括号中的语句，是在编译中运行的\n程序会先计算这个表达式，推断出它的长度，再返回给printf打印\n所以，sizeof括号内的表达式不会真的给S赋值\n你明白了吗？\n\nsizeof和strlen的区别再求字符串的长度的时候，我们可以使用sizeof，也可以使用strlen\n这两个的主要区别如下\n\nsizeof会计算整个数组内字符串的长度，包括字符串暗藏的’\\0’\nstrlen计算长度的时候，遇到’\\0’后停止\n\n在使用的时候，我们需要注意sizeof在计算长度的时候是会比strlen多算一个的\n根据具体情况选择sizeof或者strlen\n\n结语这篇博客迟到太久了，最近实在是有点忙\n如果有错误，还请各位dalao指出！万分感谢！\n高数太难了啊啊啊啊啊！（哭唧唧）\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】如何产生数组最大值","url":"/posts/3186646925/","content":"产生数组最大值@[TOC]\n今日风和日丽，是个写（水 ）博客的绝佳时机\n和大家分享一串C语言中产生数组中的元素的最大值的代码\n实现方式很简单，我们需要用到for循环和if语句\n#include &lt;stdio.h&gt;int main()&#123;\tint arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;//数组初始化\tint max = 0;//设置一个最大值\tint i = 0;\tint sz = sizeof(arr) / sizeof(arr[0]);//计算数组元素个数\tfor (i = 0; i &lt; sz; i++)    &#123;\t\tif (arr[i] &gt; max)\t\t&#123;\t\t\tmax = arr[i];\t\t&#125;\t&#125;\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n当我们运行代码的时候，输出的结果是10\n\n看样子我们成功输出了数组的最大值，这串代码已经完成了，对不对？\n但实际上这串代码是有问题的\n先别往下滑，想想它的问题出在那里了呢？\n——————————————————\n正负性当我们把数组里面的数字全部改成负数的时候\n你会发现输出的结果等于0，并不是数组内的最大值-1\n\n出现这个情况的原理十分简单，我们设定的int max &#x3D; 0，而0&gt;-1，输出的结果也自然是0了\n解决这个问题的方法也非常简单\n如果我们数组内的数全部小于0，那我们就设定MAX&#x3D;数组内的某个数字，然后再进行比较，输出最大值不就行了？\nint main()&#123;\tint arr[] = &#123; -1,-2,-3,-4,-5,-6,-7,-8,-9,-10 &#125;;\tint max = arr[0];//arr[0]对应数组中第一个数的下标\tint i = 0;\tint sz = sizeof(arr) / sizeof(arr[0]);\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tif (arr[i] &gt; max)\t\t&#123;\t\t\tmax = arr[i];\t\t&#125;\t&#125;\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n\n避免不同数组的元素个数不同，max应该设置为arr[0]而不是arr[3]或者arr[5]\n\n这时候再次运行我们的代码，可以看到结果已经正确的显示为-1了\n\n进阶玩法以自定义函数的形式实现此功能使用自定义函数的时候，我们需要注意一个问题\n那就是我博客之前写到过的 《传址调用和传值调用》\n先把我们的主函数改造一番\nint main()&#123;    int arr[] =&#123; -1,-2,-3,-4,-5,-6,-7,-8,-9,-10 &#125;;\tint max = arr[0];\tint sz = sizeof(arr) / sizeof(arr[0]);\tsp(arr, sz,&amp;max);\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n其中sp就是我们要编写的自定义函数\n\n因为自定义函数中的步骤需要改变我们主函数中的max，这里我们需要用取地址符，也就是传址调用\n\nsp(arr, sz,&amp;max);//&amp;max是传址调用\n\n同样的，我们的自定义函数也需要使用int*来接收max的地址\nvoid sp(int arr[], int sz,int* pm)&#123;\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tif (arr[i] &gt; *pm)\t\t&#123;\t\t\t*pm = arr[i];\t\t&#125;\t&#125;&#125;\n\n运行结果正确\n\n结语在制作自定义函数的时候，需要注意传址调用和传值调用的区别。具体介绍参考我之前的博客 [链接]\n感谢你看到最后，如果对你有帮助的话，点个赞再走呗！\n（没有帮助也可以点点赞~）\n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C语言】冒泡排序","url":"/posts/1953150880/","content":"冒泡排序@[TOC]\n无内鬼，直入主题！\n冒泡排序的思想核心是：比较两两相邻的元素，并且可能的话需要交换\n说人话就是\n把原本是9，8，7，6，5，4，3，2，1，0的数组\n变成0 ，1，2，3，4，5，6，7，8，9\n也可以把无序的数组排列为有序（从小到大or从大到小）\n基本的流程如下图：\n\n同时我们可以计算出，0·9这十个数字，重新排列完需要循环9次\n也就是N个数字需要N-1趟的排列\n代码实现说完了原理，还是需要敲代码来实现\n“老铁们int main return 0走一波！”\n#include&lt;stdio.h&gt;int main()&#123;\tint arr[] = &#123; 9,8,7,6,5,4,3,2,1,0 &#125;；//排序为升序 - 冒泡排序    int sz = sizeof(arr) / sizeof(arr[0]);\tbubble_sort(arr, sz);//冒泡排序的自定义函数\treturn 0;&#125;\n\n\n一维数组[]中的元素个数可以省略\n\nSZ的位置问题这里必须要注意的一点是\nsizeof必须在主函数中计算元素个数\n因为如果在自定义函数中计算的话\nvoid bubble_sort(int arr[])&#123;\tint sz = sizeof(arr) / sizeof(arr[0]);//放在此处sz计算为1，err    for (i = 0; i &lt; sz; i++)&#125;\n\nSZ计算出来的结果是1\n\narr数组名，传送的是数组首元素的地址\narr作为形参，无法计算内部元素个数\n对后续要进行的操作如for循环中的 i&lt;sz来说自定义函数中计算的sz是无效的\n\n更具体的原因在上一篇博客《什么是数组名？》中有介绍\n排除此问题后，sz计算出的元素个数就是我们的N\n这里以i为趟数，i&lt;sz指趟数需小于元素个数\nvoid bubble_sort(int arr[], int sz)//形参arr本质是指针&#123;\t//确定趟数\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;        //\t&#125;&#125;\n\n接着书写第二环的for循环，即每一趟冒泡排序的操作\n       //一趟冒泡排序int j = 0;for (j = 0; j &lt; sz - 1 - i; j++)&#123;\tif (arr[j] &gt; arr[j + 1] )\t&#123;              //\t&#125;&#125;\n\n这里需要注意的是j与sz的大小关系\n按照前面的流程图，每运行一趟冒泡序列，就会有一个数字被移动到数组的最后面\nN个元素需要进行N-1次冒泡排序，同时经过一趟后，新的最后一个元素无需重新比对排序\n所以 j&lt;sz-1-i \n比较&amp;交换因为int arr传入的是指针变量，如果想要自定义函数影响函数外的内容，也必须使用指针变量\n          //交换int tmp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = tmp;\n\n实际进行两个数字之间的比较和交换的是上述代码\ntmp这个空盒子也是我们的老朋友了\n总结起来完整的自定义函数如下\nvoid bubble_sort(int arr[], int sz)//因为在主函数中计算sz，这里需要加上int sz&#123;\t//确定趟数\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\t//一趟冒泡排序\t\tint j = 0;\t\tfor (j = 0; j &lt; sz - 1 - i; j++)\t\t&#123;\t\t\tif (arr[j] &gt; arr[j + 1] )\t\t\t&#123;\t\t\t\t//交换\t\t\t\tint tmp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = tmp;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n接下来我们可以用F10的监视器查看代码运行情况\n\narr数组初始化完成，sz计算得出为10\n继续进行下一步，arr数组中的内容成功被排列\n\n冒泡排序完成！\n结语冒泡排序是对循环语句、自定义函数、下标以及数组的综合运用\n了解它的原理有助于我们写出更为复杂的排列组合代码\n点个赞再走呗，谢谢了！\n","categories":["初识C语言"],"tags":["C语言","算法","排序"]},{"title":"【C语言】变量的作用域和生命周期","url":"/posts/134934297/","content":"变量的作用域和生命周期[TOC]\n\n1.全局变量和局部变量定义在代码块外部的是全局变量\n定义在代码块内部的是局部变量\n什么是代码块？\n//这是代码快外部int main()&#123;//这是代码块内部&#125;\n\n实际上用int main来演示是不太对的,实际使用的时候我们定义变量是在int main内部定义的\n下面这个例子更加清晰明了\nint main()&#123;\tint i = 0;//这是代码块外部-i全局变量\tfor(i=0;i&lt;10;i++)\t&#123;//代码块开始\t\tint j=0;//这是代码块内部-j局部变量        for(j=0;j&lt;10;j++)\t&#125;//代码块结束&#125;\n\n需要注意的是：\n同一个变量a可以在全局，局部变量中间同时使用，局部变量优先\n\n这里是指同时存在，同时使用，但不能同时定义\n在局部的代码块中重新定义一个全局变量是错误的\n\n下面这种形式就是 同时使用一个变量\nint main()&#123;    int sz = 8;\tint i = 0;\tif(i&lt;sz)\t&#123;\t\ti=1;\t&#125;&#125;\n\n\n在我们定义变量的时候，变量的名字不能相同\n\n同时变量的名字也不应和库函数名相同\n\n\n简单的说就是变量不要重复，也别和库函数冲突\n2.变量的作用域变量的作用域-&gt;变量的生效区域\n\n局部变量只在它自己的代码块中生效\n全局变量的作用域是整个代码\n\n注：在VS中全局变量的作用域是整个工程\n作用域的规定了变量生效区域\n如果你在局部变量的代码块外部使用这个局部变量\n这样是无效的，无法使用\n2-1.声名外部变量的方法在vs中全局变量的作用域是整个工程\n但是如果源文件不同，我们需要打一串声明来应用工程文件中另外一个源文件的全局变量\nextern int a\n\n以下是声名变量和定义变量的代码示例\n　　extern int a;//声明全局变量a　　int a; //定义全局变量a　　extern int a =0 ;//定义全局变量a 并给初始值　　int a =0;//定义全局变量a,并给初始值\n\n3.变量的生命周期生命周期这个概念和作用域十分相似\n\n局部变量的生命周期从进入”{“开始，离开”}”结束\n全局变量的生命周期是整个程序（VS项目）\n\n4. 局部变量&amp;自动变量局部变量又称自动变量\nauto int a = 0;\n\n实际使用的时候我们一般都是省略auto的\n\n以上就是C语言中有关变量的一些概念，希望对你有帮助\n点个赞再走呗，万分感谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】童年经典游戏-三字棋","url":"/posts/2819542311/","content":"@toc\n问题引入 - 什么是三子棋？想必大家儿时都玩过：#字棋\n\n如图，即一个3x3的格子，玩家需要在横、竖、斜三条线上布下自己的棋子\n先连成一条线上3个棋子的玩家获胜\n如果格子填满后还未有胜者，即为平局\n今天就让我们用c语言代码来完成一个基础的三子棋小游戏\n\n涉及知识点：\n二维数组、循环语句、自定义函数、自定义头文件\n关联博客：扫雷游戏\n\n\n自定义头文件本次三子棋代码实现中，我们需要使用到自定义头文件\n使用自定义函数前，需要先对函数进行声明\n头文件就是一堆声明的集合\n\n问：为什么不把函数声明直接main函数前面？\n\n\n答：因为这样更方便团队进行同一个项目的分工制作\n\n如何创建自定义头文件？\n在vs编译器的“解决资源管理器”里，我们能看到头文件的文件夹\n右键它，新建项\n\n选择头文件进行新建，后缀是.h\n\n创建完后，我们可以在另外一个源文件中引用头文件\n#include &quot;game.h&quot;\n\n另外，因为我们使用的两个源文件（下面会提到）都需要使用c语言的库函数\n所以我们可以在自定义头文件中引用库函数的头文件\n\n这样只用在其他源文件中引用我们的自定义头文件\n就无需再引用C语言的库函数头文件了\n\n项目中不同源文件之间的连接在三子棋代码中，我们需要编写两个源文件\n\n一个源文件为main函数所在的源文件\n另一个是自定义函数的定义部分所在的头文件\n\n在实际项目合作中，这种方式可以将不同的自定义函数（实现不同功能）的内容分工给每个人\n同样是为了方便团队合作\n在两个源文件中编写自定义函数的方式和在一个源文件中编写是一样的\n如在头文件game.h中声明了初始化棋盘的函数\n//初始化棋盘void Intboard(char board[ROW][COL], int row, int col);\n\n在实现自定义函数的game.c文件中只需要引用头文件game.h\n就能正常编写自定义函数的实现部分\n#include &quot;game.h&quot;//初始化棋盘void Intboard(char board[ROW][COL], int row, int col)&#123;   &#125;\n\n\n代码实现1.打印菜单&amp;初始化棋盘游戏嘛，肯定需要一个最基本的初始菜单了\n玩家通过输入1或0来选择进入游戏还是退出游戏\nvoid menu()&#123;\tprintf(&quot;**********************\\n&quot;);\tprintf(&quot;********1.play********\\n&quot;);\tprintf(&quot;********0.exit********\\n&quot;);\tprintf(&quot;**********************\\n&quot;);&#125;\n\n接下来我们需要弄一个初始化的函数\n三子棋一共是3x3的格子，所以我们需要一个二维数组来存放棋盘\n然后要先把这个棋盘中的每一个棋子都初始化为空格\ngame.h\n#define ROW 3//行#define COL 3//列//初始化棋盘void Intboard(char board[ROW][COL], int row, int col);\n\ntest.c\nchar ret = 0;//存储数据-二维数组char board[ROW][COL] = &#123; 0 &#125;;//初始化棋盘 - 初始化空格Intboard(board, ROW, COL);//自定义函数传参\n\ngame.c\n//初始化棋盘void Intboard(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tboard[i][j] = &#x27; &#x27;;//将每个棋盘都初始化为空格\t\t&#125;\t&#125;&#125;\n\n2.打印棋盘玩家&#x2F;电脑每走一步，游戏都需要打印一次棋盘，告诉玩家自己下在了哪里，以及对手（电脑）落子的位置\n和简单打印二维数组不同\n我们需要在每个元素之间打印一个分割线，达到以下效果\n//   |   |   //---|---|---//   |   |  //---|---|---//   |   |   \n\ngame.h和test.c文件中写法同上，重点来看game.c文件中函数的实现\n//打印棋盘void Display(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tprintf(&quot; %c &quot;, board[i][j]);//打印数组元素\t\t\tif (j &lt; col - 1)\t\t\t\tprintf(&quot;|&quot;);//竖分割线\t\t&#125;//效果  a | b | c  \t\tprintf(&quot;\\n&quot;);//换行\t\tif (i &lt; row - 1)\t\t&#123;\t\t\tfor (j = 0; j &lt; col; j++)\t\t\t&#123;\t\t\t\tprintf(&quot;---&quot;);//横分割线\t\t\t\tif (j &lt; col - 1)\t\t\t\t\tprintf(&quot;|&quot;);//竖分割线\t\t\t&#125;//效果---|---|---\t\t\tprintf(&quot;\\n&quot;);\t\t&#125;\t&#125;&#125;\n\n这样我们就能输出一个如图所示的棋盘\n\n你可能注意到，这里多了两行提示\n这是我们test.c函数中的内容\n三子棋游戏需要以函数返回值来判断是否胜利（平局）\n不过这里的test函数主要用于玩家最开始1和0的选择（是否开始游戏）\nvoid test()&#123;\tint input = 0;\tsrand((unsigned int)time(NULL));\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出游戏\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误，请重新选择!\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);&#125;int main()&#123;\ttest();\treturn 0;&#125;\n\n这里的srand以及time函数是用来生成随机数，作为电脑落子坐标的\n在猜数字游戏的博客里也有提到这两个函数  [链接]\nsrand((unsigned int)time(NULL));\n\n3.游戏基本流程打印完棋盘后，开始编写玩家落子、电脑落子以及判断谁最终胜利的函数\n在日常编写代码的时候，我们也最好使用这种方式\n\n先想好游戏的具体流程\n写出流程需要的函数名和判断过程\n最后补齐自定义函数的实现\n\ntest.c\nvoid game()&#123;\tchar ret = 0;\t//存储数据-二维数组\tchar board[ROW][COL] = &#123; 0 &#125;;\t//初始化棋盘 - 初始化空格\tIntboard(board, ROW, COL);\t//打印棋盘\tDisplay(board, ROW, COL);\twhile (1)\t&#123;\t\t//玩家走\t\tPlayerMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t//判断玩家是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\t//电脑走\t\tBotMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t//判断电脑是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t//判断状态\tif (ret == &#x27;*&#x27;)\t&#123;\t\tprintf(&quot;玩家赢了\\n&quot;);\t&#125;\telse if (ret == &#x27;#&#x27;)\t&#123;\t\tprintf(&quot;电脑赢了\\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;平局\\n&quot;);\t&#125;&#125;\n\n代码中的Iswin函数用于判断谁胜利\n因为每走一步的结果有4种情况\n\n玩家赢\n电脑赢\n平局\n继续\n\n所以这里我们不再使用数字（也是避免和原有menu选择弄混）\n以字符的形式来表达这4种情况\n//在游戏进行的过程中--Iswin判断//1.玩家赢了 -*//2.电脑赢了 -#//3.平局 -Q//4.继续 -C\n\n4.玩家走棋玩家走棋的时候，我们需要注意以下几点\n\n玩家应以[1,3]的数字作为落子坐标，而不应从0开始（下标从0开始）\n玩家是人，可能输错。在坐标出错的时候应给予提示，并让玩家重新输入\n落子前需要判断该坐标是否已有子。若有，提示玩家该处已下子\n\n//玩家走void PlayerMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot;玩家走:&gt; \\n&quot;);\twhile (1)\t&#123;\t\tprintf(&quot;请输入下棋的坐标:&gt; &quot;);\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\tif (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)\t\t&#123;\t\t\t//下棋 \t\t\t//判断坐标是否被占用\t\t\tif (board[x - 1][y - 1] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\tboard[x - 1][y - 1] = &#x27;*&#x27;;\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;坐标已被占用，请重新输入\\n&quot;);\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;坐标错误，请重新输入\\n&quot;);\t\t&#125;\t&#125;&#125;\n\n细心的你肯定发现了，这里的玩家落子使用的是*，也正是玩家胜利时的返回字符\n下面电脑落子的时候用的就是#\n\n5.电脑落子电脑落子比玩家落子相对较简单\n我们只需要让生成的两个随机数在1-3之间即可\nvoid BotMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot;电脑走: \\n&quot;);//提示玩家此处是电脑落子\twhile (1)\t&#123;\t\tx = rand() % row;\t\ty = rand() % col;\t\tif (board[x][y] == &#x27; &#x27;)\t\t&#123;\t\t\tboard[x][y] = &#x27;#&#x27;;\t\t\tbreak;\t\t&#125;\t&#125;&#125;\n\n6.判断是否胜利上面提到，每走一步，我们都需要用Iswin函数判断是否有人胜利\n三子棋胜利有3种方式：行、列、对角线\n这里我们需要分别予以判断，是否存在某一个行、列、对角线上的子全为玩家或电脑所下\n//判断胜利char Iswin(char board[ROW][COL], int row, int col)&#123;\t//判断行\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tif (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[i][1];\t\t&#125;\t&#125;\t//判断列\tfor (i = 0; i &lt; col; i++)\t&#123;\t\tif (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[1][i];\t\t&#125;\t&#125;\t//判断对角线\tif (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\tif (board[2][0] == board[1][1] &amp;&amp; board[1][1] == board[0][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\t//判断平局\t//满了返回1，不满返回2\tif (1 == IsFull(board, row, col))\t&#123;\t\treturn &#x27;Q&#x27;;\t&#125;\t//继续\treturn &#x27;C&#x27;;&#125;\n\n这里又出现了一个新的函数，IsFull\n\n7.判断是否平局当上面的判断胜利的语句走完后，若还没出现返回的情况\n我们就要判断是否是平局，即判断棋盘的9个棋子是否都已落下\nint IsFull(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tif (board[i][j] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 1;//棋盘满了&#125;\n\n如果的判断胜利和平局的语句都走完后，还没出现返回的情况\n即说明游戏并未停止，我们需要继续游戏\n\n游戏效果到这里，我们的三子棋游戏就完成了！\n跑一下看看效果吧！\n\n\n完整代码这里贴出三子棋函数的完整代码供大家参考\ngame.c#define _CRT_SECURE_NO_WARNINGS 1#include &quot;game.h&quot;//初始化棋盘void Intboard(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tboard[i][j] = &#x27; &#x27;;\t\t&#125;\t&#125;&#125;//打印棋盘void Display(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tprintf(&quot; %c &quot;, board[i][j]);\t\t\tif (j &lt; col - 1)\t\t\t\tprintf(&quot;|&quot;);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t\tif (i &lt; row - 1)\t\t&#123;\t\t\tfor (j = 0; j &lt; col; j++)\t\t\t&#123;\t\t\t\tprintf(&quot;---&quot;);\t\t\t\tif (j &lt; col - 1)\t\t\t\t\tprintf(&quot;|&quot;);\t\t\t&#125;\t\t\tprintf(&quot;\\n&quot;);\t\t&#125;\t&#125;&#125;//玩家走void PlayerMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot;玩家走:&gt; \\n&quot;);\twhile (1)\t&#123;\t\tprintf(&quot;请输入下棋的坐标:&gt; &quot;);\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\tif (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)\t\t&#123;\t\t\t//下棋 \t\t\t//判断坐标是否被占用\t\t\tif (board[x - 1][y - 1] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\tboard[x - 1][y - 1] = &#x27;*&#x27;;\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;坐标已被占用，请重新输入\\n&quot;);\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;坐标错误，请重新输入\\n&quot;);\t\t&#125;\t&#125;&#125;void BotMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot;电脑走: \\n&quot;);\twhile (1)\t&#123;\t\tx = rand() % row;\t\ty = rand() % col;\t\tif (board[x][y] == &#x27; &#x27;)\t\t&#123;\t\t\tboard[x][y] = &#x27;#&#x27;;\t\t\tbreak;\t\t&#125;\t&#125;&#125;int IsFull(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tif (board[i][j] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 1;//棋盘满了&#125;//判断胜利char Iswin(char board[ROW][COL], int row, int col)&#123;\t//判断行\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tif (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[i][1];\t\t&#125;\t&#125;\t//判断列\tfor (i = 0; i &lt; col; i++)\t&#123;\t\tif (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[1][i];\t\t&#125;\t&#125;\t//判断对角线\tif (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\tif (board[2][0] == board[1][1] &amp;&amp; board[1][1] == board[0][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\t//判断平局\t//满了返回1，不满返回2\tif (1 == IsFull(board, row, col))\t&#123;\t\treturn &#x27;Q&#x27;;\t&#125;\t//继续\treturn &#x27;C&#x27;;&#125;\n\ntest.c#define _CRT_SECURE_NO_WARNINGS 1#include &quot;game.h&quot;void menu()&#123;\tprintf(&quot;**********************\\n&quot;);\tprintf(&quot;********1.play********\\n&quot;);\tprintf(&quot;********0.exit********\\n&quot;);\tprintf(&quot;**********************\\n&quot;);&#125;void game()&#123;\tchar ret = 0;\t//存储数据-二维数组\tchar board[ROW][COL] = &#123; 0 &#125;;\t//初始化棋盘 - 初始化空格\tIntboard(board, ROW, COL);\t//打印棋盘\tDisplay(board, ROW, COL);\twhile (1)\t&#123;\t\t//玩家走\t\tPlayerMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t//判断玩家是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\t//电脑走\t\tBotMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t//判断电脑是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t//判断状态\tif (ret == &#x27;*&#x27;)\t&#123;\t\tprintf(&quot;玩家赢了\\n&quot;);\t&#125;\telse if (ret == &#x27;#&#x27;)\t&#123;\t\tprintf(&quot;电脑赢了\\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;平局\\n&quot;);\t&#125;&#125;void test()&#123;\tint input = 0;\tsrand((unsigned int)time(NULL));\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出游戏\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误，请重新选择!\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);&#125;int main()&#123;\ttest();\treturn 0;&#125;\n\ngame.h#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define ROW 3#define COL 3//初始化棋盘void Intboard(char board[ROW][COL], int row, int col);//打印棋盘void Display(char board[ROW][COL], int row, int col);//玩家走void PlayerMove(char board[ROW][COL], int row, int col);//电脑走void BotMove(char board[ROW][COL], int row, int col);//判断是否胜利char Iswin(char board[ROW][COL], int row, int col);//判断是否有空位#pragma once\n\n\n结语本篇三子棋的博客到此结束了\n感谢你看到最后！\n下篇博客会教大家，如何打包我们的代码为dll文件（此文件无法编译）\n点个赞再走吧，球球了！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】数组练习题分享","url":"/posts/2092077457/","content":"好久没记录（氵）博客了，今天记录一下昨天学习的数组练习题中的内容\n\n\n数组练习题[TOC]\n\n昨天学习的练习题挺多的，下面只记录了几个我个人认为比较重要和典型的内容\n（1）错误的引用数组题目：\nint arr[10]=&#123;0&#125;;\n\n下面错误的引用方式是：\n\nA. arr[0]&#x3D;1        B.arr[0]&#x3D;5*2          C.   arr[10]&#x3D;2               D.arr[1]&#x3D;arr[2]*arr[0]\n\narr[10]代表数组中有10个元素，但是arr[10]的引用是下标，指第11个元素\n这超出了数组10个元素的范围\n答案是 C\n\n（2）数组中的逗号表达式请问以下代码输出的结果是什么？\n#include&lt;stdio.h&gt;int main()&#123;\tint arr[]=&#123;1,2,(3,4),5&#125;;    printf(&quot;%d\\n&quot;, sizeof(arr));    return 0;&#125;\n\n首先，arr数组中的每个元素都是一个整型元素，占用的字节是4个bit位\n所以sizeof计算数组中的元素个数，将它们所占空间相加\n\n其中逗号表达式(3,4)  —–&gt; 只产生一个结果，4\n\n以防万一，这里提一下逗号表达式的概念\n逗号表达式逗号表达式中的内容可以是数字，也可以是表达式\n#include&lt;stdio.h&gt;int main()&#123;\tint a =3;    int b=5;    int c=0;    //逗号表达式    int d=(c=1,a=c+3,b=a-4,c+=b);    printf(&quot;%d\\n&quot;,d);    return 0;&#125;\n\n这个代码的结果是1\n运算过程如下\n\nc&#x3D;1\na&#x3D;c+3&#x3D;1+3&#x3D;4\nb&#x3D;a-4&#x3D;4-4&#x3D;0\nc+&#x3D;b  —-&gt; c&#x3D;c+b&#x3D;1+0&#x3D;1\n\n逗号表达式会从左到右依次计算里面的每个表达式\n输出的结果是逗号表达式中最后一个表达式的结果\n所以上面数组中(3,4)这个逗号表达式产生的结果是4\nprintf输出的结果是16（4个元素）\n\n（3）数组中字符串和字符元素的区别int arr1[]=&#123;&quot;abcdef&quot;&#125;;int arr2[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;;\n\n\n数组arr1和arr2等价  ×\n\n一个是字符串，一个是字符元素，它们的含义是不同的\n\n数组arr1和arr2的长度相同   ×\n\n这两个的长度实际上是不同的\n因为“abcdef”这个字符串的后面，是有一个字符串结束标志\\0的\n\n数组arr1的长度大于arr2的长度  √\n\n（这里我可能有错的地方，还请dalao无情指正）\n\n（4）自定义函数与数组的简单练习题题目如下\n\n创建一个整形数组，实现以下操作\n1.实现函数init()初始化数组为全0\n2.实现print()打印数组中的每个元素\n3.实现reverse()函数完成数组元素的逆置\n\n前两个自定义函数的实现形式非常相似\n我们只需要用一个for循环，利用i依次访问数组中的每个元素，将它们打印出来或者赋值为0实现初始化\nvoid print(int arr[], int sz)//打印数组中的每个元素&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)    &#123;        printf(&quot;%d &quot;, arr[i]);    &#125;    printf(&quot;\\n&quot;);&#125;void init(int arr[], int sz)//将数组中的每个元素都初始化为0&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)    &#123;        arr[i] = 0;    &#125;&#125;\n\n这里需要注意的一个点是sz（数组元素个数）我们必须在主函数main中计算，不能在自定义函数中计算\n因为传过来的数组是首元素的地址，这时候用sizeof计算的数组元素长度是不准确的\n主函数main如下\nint main()&#123;    int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;    int sz = sizeof (arr)/sizeof( arr[0]);    printf(&quot;%d\\n&quot;, sz);    print(arr, sz);    reverse(arr, sz);    print(arr, sz);    init(arr, sz);    print(arr, sz);    return 0;&#125;\n\nreverse函数的基本理念和另外两个函数其实是相似的\n这里我们依旧会用到“空盒子”tmp来完成我们的交换\n同时我们需要使用循环来确认什么时候停止交换\n即左右两个数组元素的下标一样的时候（或者值一样）就停止交换\nvoid reverse(int arr[], int sz)//数组元素的逆置&#123;    int left = 0;    int right = sz - 1;    while(left &lt; right)    &#123;        int tmp = arr[left];        arr[left] = arr[right];        arr[right] = tmp;        left++;        right--;    &#125;&#125;\n\n当我们进行两个数组之间的元素调换的时候，也需要用for循环+tmp空盒子的方式一一交换每个数组对应下标的元素\n\n前提，两个数组的元素个数相同\n\n下面这种代码是错误的\nint tmp=arr1arr1=arr2arr2=tmp\n\n实现形式和上面打印和初始化的自定义函数的思路是一样的，这里不再赘述！\n\n如果本博客对你有帮助，还请点赞支持一下！这是对我的最大鼓励\n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C语言】剔除最大最小值后，计算数组元素的平均值","url":"/posts/3219014309/","content":"双11也不能阻挡我学习的心！\n\n\n[TOC]\n问题引入\n题目内容：\n定义一个含10个整型元素的一维数组,从键盘上输入10个元素值,求去掉最大值和最小值之后的元素平均值.\n输入格式:\n用循环控制依次输入10个元素值，scanf语句中的格式控制串为: “%d”\n输出格式：\n输出平均值, printf中的格式控制串为 “%lf\\n”\n\n输入样例：\n2 3 4 5 6 2 4 6 4 3\n\n输出样例：\n3.833333\n\n\n理解1一般人看到这种题目，下意识会认为是去掉一个最大值一个最小值，再计算数组其他元素的最大值\n毕竟很多体育赛事都是这么计算选手的得分的\n实际上这道题并不是这么要求的，这点我们后面再提\n先来看看如何去掉数组中的一个最大值、一个最小值吧！\n去除一个最大&#x2F;最小值先理清思路\n\n需要找到数组中的最大值和最小值\n在计算平均值的时候需要剔除这两个值\n\n想清楚这两点后，方法就很明确了\n之前我写过一篇博客，有关如何查找数组中最大值的 [链接]\n这里我们就能用上那个博客里面的方法，不过是以自定义函数的方式实现\nint sp1(int arr[], int sz, int* pm)&#123;\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tif (arr[i] &gt; *pm)//找出最大值\t\t&#123;\t\t\t*pm = arr[i];\t\t&#125;\t&#125;\tfor (int k = 0; k &lt; sz; k++)\t&#123;\t\tif (arr[k] == *pm)//确认最大值的数值\t\t&#123;\t\t\treturn k;//返回该最大值的下标\t\t&#125;\t&#125;&#125;\n\n找出最小值的代码同上，只需要将其中的&gt;更改为&lt;\n在main函数中，我们需要设立两个变量来接收得到的最大值和最小值的下标\nint main()&#123;\tint arr[10] = &#123; 0 &#125;;\tint a, b = 0;\tdouble ave,sum= 0;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;arr[i]);\t&#125;\tint sz = sizeof(arr) / sizeof(arr[0]);\ta =sp1(arr, sz, &amp;max);\tb =sp2(arr, sz, &amp;min);\tfor (int k = 0; k &lt; 10; k++)\t&#123;\t\tif (k != a &amp;&amp; k != b)\t\t&#123;\t\t\tsum = sum + arr[k];\t\t&#125;\t&#125;\tave = sum / 8;\tprintf(&quot;%lf\\n&quot;, sum);\tprintf(&quot;%lf\\n&quot;, ave);\treturn 0;&#125;\n\n在最后计算sum的时候，只需要用if语句让K不等于最大值和最小值的下标，就能剔除这两个值\n同时，我们的平均数也只需要除以8即可\n运行结果键入数组中元素1-10，程序成功的输出了剔除1和10之后8个元素的平均值\n\n但当我们把题目示例输进去时，得出的答案却和题目要求不同\n\n\n题目实际要求上面提到，这道题的要求并不是只剔除一个最大值和最小值\n而是剔除所有的最大值和最小值\n2 3 4 5 6 2 4 6 4 3\n\n观察输入样例可以发现，这10个数字的最大值是6，最小值是2\n但是不管是最小值2和最大值6，都不止一个\n题目要求的就是要将这里面的所有2和6剔除掉，再计算剩余数据的平均值\n解题思路1&amp;2对上面的代码进行优化，以循环的方式继续寻找最大值的下标\n\n缺点：此方法可能会出现多删的情况\n\n或\n更改代码，在找到最大值下标后，查找数组中有几个元素同这个最大值相同，再返回他们的下标\n\n此方法需要用数组来存放找到的元素的下标，较为麻烦\n\n\n解题思路3 -冒泡排序先对数组进行冒泡排序，再剔除两边的最大值和最小值\n这里我选择的就是解题思路3\n\n冒泡排序的方式可以参考我之前的博客 [链接]\n这里只贴出主函数内需要编写的内容\n计数器因为需要剔除多个最大（小）值\n所以这里我们需要用一个变量进行计数\n每当我们找到和已知最大值相同的数字的时候，count都会++（初值为1）\n当循环走到第一个小于最大值的数后，循环就会终止\nint count2 = 1;for (int k = 8; k &gt;0 ; k--)\t&#123;\t\tif (arr[k] == arr[9])\t\t&#123;\t\t\tarr[k] = 0;//令最大值为0\t\t\tcount2 ++;\t\t&#125;\t\telse \t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\n\n查找最小值的代码同上，但是for循环中的条件需要更改\n注意，这里的下标k必须从8开始而不是从9\n因为经过冒泡排序后，arr[9]本身就是数组中的最大值\n若从它开始循环判断，就会直接把最大值赋值为0\n程序就出bug了\n\n主函数代码int main()&#123;\tint arr[10] = &#123; 0 &#125;;\tint a, b = 0;\tdouble ave, sum = 0;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;arr[i]);\t&#125;\tint sz = sizeof(arr) / sizeof(arr[0]);\t//先对数组进行冒泡排序\tbubble_sort(arr, sz);\t//此时下标0和9即为最大最小值\tint max = arr[0];\tint min = arr[9];\tint count1 = 1;\tint count2 = 1;\tfor (int j = 1; j &lt; 10; j++)\t&#123;\t\tif (arr[j] == arr[0])\t\t&#123;\t\t\tarr[j] = 0;//令最小值为0\t\t\tcount1 ++;\t\t&#125;\t\telse\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\tfor (int k = 8; k &gt;0 ; k--)\t&#123;\t\tif (arr[k] == arr[9])\t\t&#123;\t\t\tarr[k] = 0;//令最大值为0\t\t\tcount2 ++;\t\t&#125;\t\telse \t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t//令前后两个最大最小值为0\tarr[0] = 0;\tarr[9] = 0;\tfor (int k = 0; k &lt; 10; k++)\t&#123;\t\t\tsum = sum + arr[k];\t&#125;\t//除去已知的所有最大最小值，计算平均数\tave = sum / (10- count1- count2);\t//printf(&quot;%lf\\n&quot;, sum);\tprintf(&quot;%lf\\n&quot;, ave);\treturn 0;&#125;\n\n在最后计算平均数的时候，我们需要剔除count1和count2（10减去后即为剩余元素的个数）\n这时候得出的答案就和题目所给示例相同了\n\n你学废了嘛？反正我是废了 \n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C语言】野指针是什么？指针在什么情况下会出错？","url":"/posts/2226629578/","content":"@toc\n什么是野指针？概念︰野指针就是指针指向的位置是不可知的（如：随机的、不正确的、没有明确限制的)\n说人话就是：野指针是错误的指针引用形式，通常有以下几种情况\n\n指针未初始化\n越界访问\n指针指向的空间已释放\n\n悬垂指针（dangling pointer）：是指在程序中仍然存在，但不再指向有效内存地址的指针。当指针指向的对象被释放或销毁后，指针仍然保留着先前所指向的内存地址，这时指针就成为悬垂指针。\n1.指针未初始化这个概念非常容易理解，同变量一样，指针同样需要我们的初始化\n//初始化指针int a = 10;int*p = &amp;a;\n\n指针未初始化 通常是以下情况\nint main()&#123;\tint*p;\t*p=20;&#125;\n\n这里的指针并没有指向某个内存地址，即便我们更改它的内容也是无效的\n\n指针会默认赋予一个随机值，属于非法访问内存\n\n当然，编译器遇到这种情况会直接报错\n\n2.越界访问越界访问的情况通常出现在数组中\nint arr[10]=&#123;1,2,3,4,5&#125;;int* p=arr;\n\n我们知道，数组名代表是首元素的地址\n我们可以利用 for循环和指针++ 的方式，使指针访问数组中的每个元素\nint main()&#123;\tint arr[5]=&#123;1,2,3,4,5&#125;;\tint* p = arr;    int i =0;    for(i=0;i&lt;=5;i++)    &#123;        *p=0;        p++;    &#125;&#125;\n\n我们知道，数组中的元素访问都是通过下标的方式。5个元素的数组，下标是从0-4\n而在此代码中，p++第五次的时候，下标已经变成了5，对应的是第六个元素\n但数组中并没有第六个元素，此时指针访问的就是一个空的地址了\n同样属于非法访问\n这就是越界访问的一种\n3.指针指向的空间已释放每当我们定义一个变量时，系统都会赋予这个变量一个内存的地址空间\n这时候我们把这个地址赋予给指针p，指针便记录下了这个地址\n用图来给大家演示一下什么叫指向的空间已释放\n\n代码示例如下\nint* test()&#123;\tint a = 10;\treturn &amp;a;&#125;int main()&#123;\tint* p = test();\t*p = 20;\treturn 0;&#125;\n\n\n\n如何避免野指针？1.指针初始化在使用指针的时候，我们要像创建变量一样初始化指针\n如果不知道把指针初始化为什么，那就赋值为NULL(代表0)\n\n 1 int main() 2 &#123; 3     //当前不知道p初始化为什么的时候 4     //直接初始化为NULL(空指针--&gt;0) 5     int* p = NULL; 6     //明确知道初始化的值 7     int a = 10; 8     int* ptr = &amp;a; 9     10     return 0;11 &#125;\n\n2.小心指针越界在使用指针的时候，我们要注意不能让指针越界\n如遇到数组的情况，一定要注意下标和元素个数的区别\n\n注意：C语言本身是不会检查数据的越界行为的！\n\n3.指针指向空间释放就置之为NULL在我们指针使用完毕之后，为了避免指针指向的空间被系统释放\n我们可以将指针初始化为空指针,NULL\n4.指针使用之前检查有效性什么是有效性?\nNULL的空指针就是无效的\n为了避免我们引用这种无效的空指针，我们可以在使用指针之前用if语句判断一下它是否为空\nif(p!=NULL)\t*p=10;\n\n判断为有效指针，我们再使用它\n做到以上4点，就能基本避免我们的代码出错。这只能避免，并不能杜绝\n“你永远叫不醒一个想写bug的人”\n\n结语以上就是野指针的基本解释，希望对你有帮助\n点个赞再走吧！万分感谢！\n","categories":["初识C语言"],"tags":["C语言","指针"]},{"title":"【Linux】udp | tcp | 协议详解","url":"/posts/4287572457/","content":"本文带你详细了解tcp协议的相关知识\n\n\n\n本文中部分截图为手写，字丑见谅\n\n1.linux下常用网络命令cat /etc/servcies # 系统常用服务和端口\n\n我们自己写网络服务器进程时，绑定的端口不能和系统端口冲突。尽量绑定1024以上的端口，推荐绑定不常用的5位数端口。\n绑定低于1024的端口，会出现权限不足的报错\n$ ./tcpServer 100DEBUG | 1679473830 | muxue | socket create success: 3FATAL | 1679473830 | muxue | bind: Permission denied:3\n\n1.1 netstat命令netstatnetstat -l # 只列出listen状态服务netstat -n # 将显示的信息用数字（id）代替netstat -p # 显示端口和进程pid的关联netstat -t # tcpnetstat -u # udpnetstat -a # 显示所有服务\n\n1.2 pidof获取某个进程名的进程pid\npidof 进程名\n\n比如我想查看sshd的进程id\n$ pidof sshd20706 20703 10775 6067 6009 3339 3338 3272 3269 1340\n\n2.udp协议一下为udp报文格式的结构图\n\nudp采用了定长报文，这也是udp 面向数据报 的\n\nudp采用16位作为ip+端口的存放，源端口和目的端口用于数据的解包分用（系统需要知道当前的数据包应该丢给上层的哪一个端口）\n16位udp长度，表示整个数据报 udp首部+udp数据 的最大长度\n16位校验和用于校验报文是否出现错误。如果校验和出错，就会直接丢弃报文\n\n由于udp的长度标志位只有16位，所以一个udp报文能传输的最大数据是64kb (216)\n如果需要用udp传输大于64kb的数据，则需要在应用层进行拆分，在接收方的应用层进行合并。\n2.1 理解报头所谓报头，其实就是操作系统内核中的一个C语言的结构体。\n//示例，不代表真实情况//udp报头采用了位段struct udp_hdr&#123;    unsigned int src_port:16;    unsigned int dst_port:16;    unsigned int udp_len:16;    unsigned int udp_check:16;&#125;\n\n添加报头的本质，其实就是给数据的头部添加上一个struct udp_hdr结构体；\n而解包的时候，也是将指针移动固定长度（8个字节）的空间，将指针强转为struct udp_hdr，即获取到了当前报文的udp报头\n2.2 udp的特点udp传输的过程类似于飞鸽传书\n\n无连接：知道对方的ip:端口就能直接传输数据，不需要建立连接\n面向数据报：定长报文，不能灵活控制报文的读取次数和数量\n一次必须要读取完毕一个完整的udp报文\n假设报文100字节，不能通过10次每次读10字节来获取报文。必须一次读完100字节\n\n\n不可靠：没有确认机制和重传机制，如果因为各种原因，鸽子在路上出事了，那传输的信息也直接丢失了。udp也不会给应用层返回错误信息。\n\n2.3 udp缓冲区udp支持全双工，udp的socket即可写也可读\nudp没有发送缓冲区，应用层调用sendto会直接将数据交给OS内核（其实就是拷贝），内核再交由网络模组进行后续传输。\n\n由于udp采用了定长报头，其报头较为简单，OS只需要添加上报头即可发送。这个过程很快，所以缓冲区的作用不大。\n\nudp有接收缓冲区，这个接收缓冲区只是一味地接收，并不能保证报文的顺序\n\n因为不保证顺序，所以有可能乱序，也是udp不可靠的体现\n\n若缓冲区满，新到达的udp数据就会被丢弃。\n2.4 丢包一个数据包丢包可能有多种情况\n\n数据包内容出错（比特位翻转等）\n数据包延迟到达（延迟过久视为丢包）\n数据包在路上被阻塞（到不了）\n数据包在路上由于网络波动而丢失（网络突然抽风了，报文直接不见了）\n\nudp的报文也是如此，但udp不可靠并不是一个贬义词，应该是一个中性词。\n\nudp不可靠是他的特点，由于udp简单，其不需要进行连接，报头添加的效率快，由此性能消耗小于tcp。\n带来的缺点就是udp不可靠\n\n在直播场景中，udp的使用很多。同一场直播观看的人数会很多，如果每一个用户都维持一个tcp连接，服务器的负载就太大了。用udp就能直接向该用户广播数据，负载小。\n2.5 基于udp的应用层协议\nNFS: 网络文件系统\nTFTP: 简单文件传输协议\nDHCP: 动态主机配置协议\nBOOTP: 启动协议（用于无盘设备启动）\nDNS: 域名解析协议\n\n\n本文往下都是tcp的内容了哦！\n3.tcp协议下图为tcp协议报头的一个基本结构图，我们需要了解整个结构，以及每一个部分的作用\n\n3.1 源和目的端口号这部分和udp相同，tcp也需要源端口和目的端口号，以用于找到报文要去的目的地。\n3.2 4位首部长度相比于udp的定长报头，tcp采用了不定长的方式。但tcp的报头有标准的20字节，所有报头都至少有20字节。\n在这20字节中，有一个4位首部长度，用于标识tcp报文的真实长度。\n我们知道，4位二进制可以表示0~15，这不比固定的20字节还少吗？难道说，这4位首部长度标识的是比20字节多余的内容？\n并不是！这4位首部长度的标识是有单位的，每一位首部长度，实际上代表的是4字节，即tcp报头的最大长度为 15*4=60 字节。\n由于标准长度也记入4位首部长度，所以4位首部长度的最小值为 0101\n\n读取tcp报文的时候，只需要先读取20字节，再从这20字节中取出4位首部长度，获得报头的实际长度；再重新读取，即获得了完整的tcp报头。剩下的部分就是报文携带的数据了（有效载荷）\n3.2.1 TCP报文完整长度一个TCP报文段的最大长度为65495字节.\nTCP封装在IP内，IP报头有一个最大长度字段是16位，即65535 (2^16 - 1)，IP头部最小20，TCP头部长度最小20，所以最大封装数据长度为 65535-20-20=65495；\n3.3 32位序号&#x2F;确认序号3.3.1 如何确认信息被对方收到？\ntcp具有确认应答的机制\n\n当我们和对方微信交流的时候，怎么样才能确认自己的信息被对方看到了？\n\nA发：吃饭了吗？\nB回应：吃了\n\n在这个场景中，只有B给A发出回应，A才能确认自己的消息被B看到了。\ntcp通信也是如此，只有给对方发送的报文收到了对方的应答，发送方才能确认自己的报文被对方收到了。\n为此，tcp引入了32位 序号/确认序号\n\n3.3.2 确认应答用于确认自己和对方的通信，究竟收到了哪一个报文（序号）以及确认信息发出的顺序。\n比如客户端会向服务器发 吃了吗？吃的什么？好吃吗？晚上想去干什么？，如果没有对报头带上序号，服务器接收到的可能就会是下面这样 好吃吗？晚上想去干什么？吃的什么？吃了吗？，看起来是不是十分怪异？\n所以，为了保证tcp报文的顺序性，以及保证报文被送达到对方。tcp引入了以序号为基础的确认应答机制：\n\n客户端向服务器发送一个报头，并将序号设置为1\n服务端收到信息后，回复客户端一个报头，将确认序号设置为2（为已经收到了的客户端消息的序号+1。确认序号为2，代表1号报文收到，期望收到2号报文）\n此时客户端就能确认服务器收到了自己刚刚发出的序号为1的消息\n下次发送消息，客户端会从2号开始发送\n\n以上是一次通信的过程，如果是多次通信呢？\n\n客户端连续向服务器发送了n个消息，服务器应答：1、2、3、4……\n服务器的每次应答会设置确认序号，代表n之前的报文（不包括n自己）被全部收到\n比如假设客户端发送了1-10的报文，而第6个报文出现了丢失，那么服务端就应该设置确认序号为6，代表6之前的报文都被正常收到。\n此时客户端发现，明明自己已经都发到10了，服务端还在回应6。这就代表发送过程中，6号报文丢失了！于是客户端从6号报文开始，重发报文：6、7、8……\n\n不管是服务端给客户端发信息，还是客户端给服务器发信息，收方都需要对信息进行回应。tcp通信中，通信双方地位是对等的！\n重点：TCP确认序号应该设置为已经成功收到的报文的下一位序号\n3.3.3 为什么有两组确认序号？tcp是全双工的，通信一方在发送响应信息的同时，可能也会携带新的报文给对方。\n\n客户端给服务器发了一条消息 吃了吗？\n服务器在回复的同时，也带上了新的请求 吃了，你呢？\n服务器的这种策略叫做：捎带应答\n\n此时服务端就需要在填充客户端消息的确认序号的同时，填充自己所发消息的序号。这样才能保证tcp在双向交流中的可靠性！\n所以在tcp报头中，序号和确认序号缺一不可！\n3.3.4 没有完美的协议！经过上面的过程，我们会发现，总有一条报文，在收到对方回应之前，是无法得知对方是否收到信息的。\n这也说明：没有一定可靠的协议！\n3.3.5 按序到达\n序号除了用于确认应答，还有多个功能\n\n保证数据的顺序收发问题\n\n比如一个http的报头，原本的格式应该是下面这样\nGET / HTTP/1.1\n\n结果由于传输的过程中乱序了，变成了下面这样\nHTTP/1.1 GET /\n\n这种情况，是不能被应用层所正常解析的！数据全都乱了，原本写好的代码也没用了。\n所以，为了避免数据在传输中乱序，tcp的序号就有了新的功能——保证数据的按序到达。\n1.客户端发送了1-5号报文2.服务端收到了1 3 4 2 5（乱序）3.服务端在tcp的接收缓冲区中，将报文重排序为1-54.将重排序后的正确数据交付给应用层\n\n但是，如果只按顺序来接收数据，那就无法处理优先级问题。这部分将在后文6个标记位详解。\n序号除了可以用于排序，还能用于去重，这部分也将在后文超时重传部分解析。\n3.4 16位窗口大小3.4.1 发送和接收缓冲区tcp同时拥有发送和接收缓冲区。\n\n我们在应用层调用的read/write函数，实际上只是将数据从接收缓冲区中拷贝出来/发送的数据拷贝到发送缓冲区。\n\n如果write包含将数据发送给对方的过程，那么这个函数的调用效率就太低了，影响应用层执行其他代码。\n\n数据并没有被立即送入网络传输，而是由tcp协议自主决定发送数据的长度和发送的时间！这一切，都是由操作系统来决定的。这就是为什么tcp又称为传输控制协议！\n3.4.2 接收缓冲区满了咋办既然有缓冲区，就肯定会存在缓冲区被写满的问题。\n\n发送缓冲区满，由操作系统告知应用层，不再往发送缓冲区中写入数据\n接受缓冲区满\n直接丢弃数据？\n告诉对方，不再给自己发信息？\n\n\n\n在实际的tcp收发过程中，由于接收方缓冲区满而丢弃数据，是不可接受的。因为数据跨过了茫茫网络，都已经到你机器上了，结果因为你缓冲区满了给它丢掉了，这不是坑人吗？\n虽然出现这种情况，我们可以让发送方重传报文，但这样效率太低！\n\n所以，我们应该让收发双方知晓对方的缓冲区大小，从而避免这个问题！\n这就是tcp报头中16位窗口大小的作用了！\n3.4.3 告知对方收缓大小如下图，在客户端和服务端互通有无的时候，假设服务端的接收缓冲区满了，应该告知客户端，让他别再给自己发消息了。\n此时，服务端设置自己的16位窗口大小，以此告知客户端自己的缓冲区剩余容量。\n如果对方发来的报文中，16位窗口大小所表示的缓冲区剩余容量已经不足了，发送方就不应该继续发送，而应该等待对方从缓冲区中取走数据。\n\n这是已经开始通讯的情况，但如果是第一次通讯呢？如果客户端一来就发送了一个巨大的数据，直接塞满了服务端的缓冲区，那不是出事了？\n这便是tcp在三次握手中要做的事情了，简单来说就是在通信开始前就互相告知自己缓冲区的大小。后文会讲解。\n3.4.4 缓冲区是否独立？\n进程的tcp缓冲区是独立的吗？\n\n每个进程都有自己的内核空间，内核空间里有tcp缓冲区，所以每个进程都有自己独立的tcp缓冲区\n\n线程的tcp缓冲区是独立的吗？\n\n是的！虽然这些线程共享同一个内核TCP缓冲区，但是每个线程使用的缓冲区是独立的，互相之间不会产生冲突。每个线程对自己的缓冲区进行读写操作时，会使用内核提供的同步机制，如互斥锁、信号量等来确保线程之间的缓冲区不会互相干扰，从而实现数据的安全读写。\n3.5 六个标记位在4位首部长度右侧，有一块保留长度，和6个标记位。这六个标记位是所有设备都支持的标记位。\n\n\nSYN: 连接标记位，用于建立连接（又称同步报文）\nFIN: 表示请求关闭连接，又称为结束报文\nACK：响应报文，代表本次报文中包含对之前报文的确认应答\nPSH：要求对方立马从tcp缓冲区中取走数据\nURG：紧急指针标记位，用于紧急数据的传输\nRST：要求重置连接（双方重新建立一次新的tcp连接）\n\n3.5.1 8个标记位？在部分书籍中，还会出现8个标记位与4位保留长度的说法（下图源自《图解tcp&#x2F;ip第五版》）\n\n\nCWR（Congestion Window Reduced）：该标志位用于通知对方自己已经将拥塞窗口缩小。在TCP SYN握手时，发送方会将CWR标志位设置为1，表示它支持ECN（Explicit Congestion Notification）拥塞控制，并且接收到的TCP包的IP头部的ECN被设置为11。如果发送方收到了一个设置了ECE（ECN Echo）标志位的TCP数据包，则它将调整自己的拥塞窗口，就像它从丢失的数据包中快速恢复一样。然后，发送方会在下一个数据包中设置CWR标志位，向接收方表明它已对拥塞做出反应。发送方在每个RTT（Round Trip Time）间隔最多做出一次这种反应。\nECE（ECN Echo）：该标志位用于通知对方从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时，TCP首部中的ECE会被设置为1。接收方会在所有数据包中设置ECE标志位，以便通知发送方网络发生了拥塞。\n\n而我百度到的文章提到，tcp给多出来的两个标记位新增了功能：\n\n除了以上6个标志位，还有一个实验性的标志位NS（Nonce Sum），用于防止TCP发送者的数据包标记被意外或恶意改动。NS标志位仍然是一个实验标志，用于帮助防止发送者的数据包标记被意外或恶意更改。3 4\nTCP标志位中还有两个标志位后来加的一个功能：显式拥塞通知（ECN）。ECN允许拥塞控制的端对端通知而避免丢包。但是，ECN在某些老旧的路由器和操作系统（例如：Windows XP）上不受支持。在TCP连接上使用ECN也是可选的；当ECN被使用时，它必须在连接创建时通过SYN和SYN-ACK段中包含适当选项来协商。 2 3\n\n诸如tcp的标记位到底是6个还是8个? 这种摸棱两可的问题，在考试中不会问道。\n在学习中，我们只需要掌握所有设备都支持的6个标记位即可\n\n3.5.2 ACK该标记位用于标识本条报文是对之前的报文的确认应答。设置了改标记位，那么接收方就应该去查看该报文中的确认应答序号。\nACK标记位的设置和其他标记位并不冲突，在捎带应答的时候，可以同时设置包括ACK在内的多个标记位，而不影响当前报文的原本功能\n3.5.3 SYN&#x2F;FIN\nSYN：表示请求建立连接，并在建立连接时用于同步序列号，所以又称为同步报文；\nFIN：表示请求关闭连接，又称为结束报文。设置为1时，代表本方希望断开连接。此时双方要交换FIN（四次挥手）才能真正断开tcp连接。\n\n\n3.5.3.1 三次握手在三次握手的时候，经历了如下过程\n\n连接发方A向对方主机B发送SYN报文，请求建立连接（A进入SYN-SENT状态）\n主机B在收到报文后，回应ACK+SYN的报文，在确认应答的同时，请求建立连接（B进入SYN-RCVD状态）\nA收到这条报文后，发送确认应答ACK（A认为连接成功建立 ESTABLISHED）\nB收到A发送的ACK，三次握手完成（B认为连接成功建立  ESTABLISHED）\n\nA     SYN-&gt;      BA(SYN_SENT)      BA   &lt;-SYN+ACK    BA      (SYN_RCVD)BA     ACK-&gt;      BA(ESTABLISHED)   BA   (ESTABLISHED)B 收到ACK\n\n为什么接收方要发送ACK+SYN\n为什么接收方要发送ACK+SYN，而不是只发送ACK？\n\n接收方发送带有ACK+SYN标志的数据包，是为了确认收到了发送方的SYN，并向发送方表明自己也同意建立连接。ACK字段用于确认收到了之前的数据包，而SYN字段用于表示接收方也希望建立连接。\n若接收方只发送ACK而不带SYN标志，这可能会导致混淆。因为TCP中的ACK字段表示确认收到之前的数据包，而在初始握手阶段，双方都还没有进行数据传输，所以ACK字段无法明确指示是在确认SYN还是确认其他数据包。因此，发送方在收到只带ACK标志的数据包时，无法准确知道接收方是否同意建立连接。\n通过在握手过程中同时发送ACK+SYN标志，接收方可以在一个数据包中明确表示两个信息：确认收到发送方的SYN，并表示自己也愿意建立连接。这样就能够确保双方在握手过程中能够准确理解对方的意图，并建立起可靠的连接。\n3.5.3.2 四次挥手在断开连接，四次挥手的时候，经历了如下过程\n\nA要断开连接，发送FIN（A进入FIN WAIT 1状态）\nB收到了FIN，发送ACK（B进入CLOSE-WAIT半关闭状态）\nA收到了ACK（A进入FIN WAIT 2状态)\n此时只是A要和B单方面分手，A-&gt;B的路被切断了，但是B-&gt;A的还没有，B还能继续给A发数据\nB发完数据了，也和A分手了，B发送FIN（B进入LAST ACK状态）\nA收到FIN，发送回应ACK（A进入TIME WAIT状态，将在一段时间后进入CLOSE断连状态）\nB收到了ACK（B进入CLOSE状态）\n连接关闭\n\n我们不仅需要知道3次握手和4次挥手的过程，还需要知道每一次的状态变化！\n\n3次握手和4次挥手对于应用层而言，都只有1个对应的函数。这些操作都是由tcp自主完成的。\n3.5.4 PSHPSH标记位的作用是：要求对方立马取走缓冲区中数据\n如下图，S在接收缓冲区满了之后过了很久，还没有取走缓冲区中的数据，C实在忍不住了，给S发一个PSH标记位的报文，要求S立马取走这些数据！\n\ntcp在收到此报文后，将由操作系统告知应用层，取走缓冲区中的数据。\n如果应用层不听操作系统的咋办？那就代表应用层写的有bug！人家给你发了那么多东西了你还不处理，有点过分了！\n3.5.5 URGURG是紧急指针标记位。\n在3.3.5 按序到达部分提到过，如果只关注序号，则无法处理优先级问题。有一些数据对于应用层来说，优先级较高。如果tcp只会老老实实的按顺序把数据交付给应用层，那在高优先级的数据也搞不过操作系统对tcp的处理。\n所以，为了能操作优先级，tcp提供了URG标记位，设置了此标记位的报文具有较高优先级。\n应用层有专门的接口可以优先读取带有URG标记位的报文。\n3.5.5.1 16位紧急指针为了能标识这个紧急数据在报文中的位置，tcp还提供了16位紧急指针；这个指针的指向便是紧急数据在tcp报文中的偏移量。紧急数据规定只有1个字节！\n由于紧急指针的数据可以被提前读取，不受tcp缓冲区的约束，所以又被称为带外数据\n下图就举了一个紧急指针使用的场景：\n\nTCP 在传输数据时是有顺序的，它有字节号，URG配合紧急指针，就可以找到紧急数据的字节号。\n紧急数据的字节号公式如下：\n紧急数据字节号(urgSeq) = TCP报文序号(seq) + 紧急指针(urgpoint) −1\n\n比如图中的例子，如果 seq = 10,urgpoint = 5，那么字节序号 urgSeq = 10 + 5 -1 = 14\n\n知道了字节号后，就可以计算紧急数据字位于所有传输数据中的第几个字节了。如果从第0个字节开始算起，那么紧急数据就是第urgSeq - ISN - 1个字节（ISN 表示初始序列号），减1表示不包括第一个SYN段，因为一个SYN段会消耗一个字节号。\n3.5.6 RSTRST为复位报文，即RESET。\n如下图，如果A给B发送的ACK在传输路途上丢失了，咋办？\n\n这时候，就会出现A认为连接已经建立，而B由于没收到A的ACK而处于SYN-RCVD状态。\n\n此时A开始给B发送数据，B一看，不是说好了要建立连接才能发送数据的吗，你这是在干嘛？\n于是B告知A，发送RST标志位的报文，要求和A重新建立连接（重新进行三次握手）\n重新建立连接成功后，AB再正常发送信息。\n\n以上只是RST使用的情况之一。我们使用浏览器访问一些网页时，F5刷新就可以理解为浏览器向服务器发送了一个带有RST标记位的报文。\n3.6 为什么是3次握手？为什么握手的次数是3次，不是1次、2次、4次、5次？\n在讨论这个问题之前，我们要知道：连接建立是有消耗的！需要维护其缓存区、连接描述符（linux下为文件描述符）等等数据。基于这点认识，我们接着往下看\n\n如果是一次握手？\n\n一次握手，即A给B发送一个SYN，双方就认为连接建立了。\n那么我们直接拿个机器，写个死循环，一直给对方发送SYN，自己直接丢弃文件描述符（不做维护）\n由于服务器并不知道你（发送方）直接丢弃了文件描述符，其还是要为此次连接维护相关数据，这样会导致服务器的资源（为了维护tcp链接）在短时间内被大量消耗，最后直接dead了\n\n这种攻击叫做SYN洪水\n\n\n如果是二次握手？\n\nA给B发送一个SYN，B给A发送一个ACK，即认为连接建立。\n这和一次握手其实是相似的，服务器发送完毕ACK之后，就认为连接已经建立，需要维护相关资源。而我们依旧可以直接丢弃，不进行任何维护，最后还是服务器的资源被消耗完了\n\n三次握手\n\n三次握手了之后，双方都必须维护连接的相关资源；这样，哪怕你攻击我的服务器，你也得付出同等的资源消耗。最后就是比谁资源更多呗！\n相比于前两种情况，三次握手能在验证全双工的同时，一定程度上避免攻击。\n三次握手还将最后一次ACK丢失的成本嫁接给了客户端（连接发起方）如果最后一次ACK丢失，要由客户端重新发起和服务器的连接。\n注意，三次握手只是一定程度上避免攻击。我们依旧可以用很多宿主机“堆料”来和服务器硬碰硬，这是无可避免的情况。\n\n更多次握手？\n\n由于三次握手已经满足了我们的要求，更多次握手依旧有被攻击的可能，还降低了效率，完全没必要！\n\n3.7 超时重传为了保证可靠性，如果一个报文长时间未收到对方的ACK回应，则需要进行超时重传。\nlinux下每一次尝试的时间间隔为500ms，若500ms内尚未收到对方的ACK，则重发报文，再等待1000ms……以此类推。\n\n超时重传还可能遇到下面的情况：\n\n服务器收到了消息，也发送了ACK，但是ACK在路上丢失了\n客户端没有收到ACK，于是进行超时重传\n服务器再次收到了消息，此时接收缓冲区里出现了两个一样的数据\n\n但是，我们的报文是有序号的，tcp就可以直接根据序号去重，所以，tcp交给应用层的数据是去重+排序之后的数据！\n\n如果同一个报文超时重传了好几次，还没有收到对方的应答，就会认为对方的服务挂掉了，此时本端会强制断连。\n此时客户端就可以发送一个带有RST标记位的报文，要求和对方重新建立连接。如果重连失败，则可以认为对方确实挂掉了，这便是我们在浏览器中有时会看到的 SERVICE_UNAVALIABLE 服务不可用\n3.8 出现了很多CLOSE-WAIT状态的连接？在上面提到过，当客户端向服务器发送FIN之后，服务器回复ACK，会进入CLOSE-WAIT状态。此时服务器还能给客户端发送消息，双方都还在维护连接的相关资源。\n如果一个服务出现了很多个处于CLOSE-WAIT状态的连接，就必须要检查一下，应用层的代码里面是不是没有调用close(fd)函数来关闭对应的文件描述符。\n\n一方的close(fd)就对应了两次挥手\n\n对方明明都要和你分手了，你还挂着对方当备胎，还要找对方要钱，也太不像话了😂\n3.8.1 活学活用🤣230322下午，正准备通过之前写的tcp代码来验证tcp握手和挥手的各个状态的，没想到用命令一看，全是CLOSE-WAIT状态，填满了整个屏幕，这完全没办法写博客啊\n\n而且这些状态清一色来自python3.10的程序，看到它的时候，我已经基本猜到了是啥进程引发的了——我的两个valorant机器人。查了查pid，坐实了这一点\n\n我将数据写入到一个文件里面，统计了一下，一共1200多个CLOSE-WAIT\nnetstat -ntp &gt; log # 将统计结果写入文件lognetstat -antp | grep CLOSE_WAIT # 只统计CLOSE_WAIT状态的链接\n\n\n这些状态值的远程ip来源虽然有多个，但一个ip出现了多次，于是我就使用 itdog 看了一下其中几个ip的来源，是Anycast/cloudflare.com，也就是很出名的cloudflare-cdn。\n在我的kook-valorant-bot里面，有一项业务是方便开发者使用的valorant登录和商店查询的api（使用aiohttp库编写）\n为了统计其上线状态，我使用了uptimerobot定时请求，每5分钟获取一次api的在线情况\nhttps://stats.uptimerobot.com/Wl4KwU6Bzz\n\n嗯，运行状态倒是蛮好的，100%在线\n\n前面提到过，系统是需要消耗资源来维护tcp链接的。如下图，机器人占用了将近400mb的内存，其中肯定有一部分就是被这些没有关闭的tcp链接所占用的\n\n大量CLOSE-WAIT，只可能是一个原因：uptimebot的请求已经结束并发送了FIN，而我的api代码作为服务端，并没有在收到FIN后，对链接进行close，于是链接一直处于CLOSE-WAIT半关闭状态。只有程序关闭（机器人下线）才会被操作系统清空。\n\n后来又研究了一下，经过他人点醒，才发现上面的结论都是错的\n\nhttps://segmentfault.com/q/1010000043572705/a-1020000043573118\n\n其实在netstat里面很明显的一点，表示这一切和uptimebot以及我写的api没有任何关系\n\n那就是这里面Local Address的端口，每一个都是不一样的。如果是我写的api导致的，那么他们的端口都应该是api绑定的端口，且固定才对！\n后来就找到了一个2014年的issue，大概情况就是，python的requests库会维护一个连接池（类似于线程池）。这些处于close-wait状态的连接，都是requests库维护的。\nhttps://github.com/psf/requests/issues/1973\n好嘛，原来是自己学艺不精，闹了个大笑话。当时找处理aiohttp的web状态的资料找了老半天都没找到……原来一开始方向就错了😶‍🌫️\n3.9 异常情况\n进程终止：进程终止会释放文件描述符，仍然可以发送FIN。和正常关闭没有什么区别\n机器重启&#x2F;关机：和进程终止的情况相同，操作系统会在重启&#x2F;关机前释放TCP文件描述符。\n机器断电&#x2F;网络断开：接收端认为连接还在，一旦接收端有写入操作，接收端发现连接已经不在了，就会进行reset。即使接收端没有写入操作，TCP内置了一个保活定时器，会定期询问对方是否还在。如果对方不在，也会把连接释放。\n\n除了TCP本身，应用层的某些协议，也会有这样的重连检测机制。\n3.10 校验和\n这部分并不是重点。\n\n校验和能保证TCP双方发送的数据不会出现数据对不上的问题\n校验和是一种简单的数据验证机制，它通过对数据进行数学运算得到一个校验值，并将该校验值与原始数据一起传输。接收方收到数据后，会再次计算数据的校验和，并将结果与传输过来的校验值进行比较。如果两个校验和相匹配，那么说明数据在传输过程中没有发生错误或损坏。但如果校验和不匹配，接收方会认为数据发生了错误或损坏，于是会请求发送方重新传输数据。\nTCP在数据包的头部添加了一个16位的校验和字段，该字段包含了数据段的校验和值。在发送端，TCP将数据段中的所有字节（包括TCP头部和数据部分）加起来，然后取其反码作为校验和。接收端也采用同样的方式计算校验和，并与接收到的校验和进行比较，以验证数据的完整性。\n\n举个简单的栗子，我们可以把发送的数据体当作一个字符串，对其进行MD5计算，再将计算后的MD5同数据体一同发送给对方。这时候接受方收到信息后，同样进行相同算法的MD5计算，得出来的MD5和对方发送过来的MD5进行对比，如果相同，代表数据没有问题。不相同代表数据发送错误，该数据包被丢弃。\n如果发送的MD5在传输过程中出现了损坏，那么最终计算出来的MD5字符串依旧是不相同的，也会当作无效报文被丢弃;\n实际TCP使用的并不是MD5，上面的这个栗子只是为了方便理解。\n\n校验和不仅用于TCP协议，在许多其他协议中也有类似的机制，用于确保数据传输的可靠性。\n通过使用校验和，网络协议可以帮助确保数据在传输过程中不会因为噪声、干扰或其他错误而变得损坏。然而，需要注意的是，校验和并不能提供绝对的数据完整性保证，因为一些复杂的错误模式可能会导致校验和匹配，但数据仍然损坏。\n为了进一步增强数据的可靠性，TCP协议还使用了序列号（按序到达）、确认应答（确认收到）和超时重传（避免丢包）等机制。\n3.11 快重传TCP快重传（Fast Retransmit）是TCP协议中的一种拥塞控制机制，用于加快数据包的重传，以减少数据传输的延迟和提高网络性能。\n在TCP协议中，当发送方发送数据包到接收方后，会启动一个定时器，等待接收方发送确认应答（ACK）回来。如果发送方在定时器超时前收到了相应的ACK，说明数据包已经成功接收，发送方会将定时器停止，并继续发送下一个数据包。\n\n这个默认的定时器策略，是用于TCP的超时重传的。\n\n然而，如果发送方在定时器超时前没有收到ACK，通常会认为数据包丢失了，因此会重新发送该数据包。但有时候，接收方实际上已经收到了数据包，只是ACK因为某种原因没有及时发送回来，这可能是由于网络延迟、拥塞等造成的。\n\n而TCP快重传的思想是，当发送方收到连续的相同的ACK时，不等待定时器超时，而是立即重传对应的数据包。\n这是因为连续收到相同的ACK，表明接收方已经收到了一系列的数据包，并且正在等待接收下一个数据包。通过立即重传，可以避免等待定时器超时的延迟，从而更快地恢复数据传输。\n具体来说，TCP快重传的步骤如下：\n\n发送方发送一个数据包，并启动定时器。\n接收方收到数据包后，发送对应的ACK回去。\n如果发送方收到三个连续的相同ACK（即收到三个对同一个数据包的确认应答），就立即重传该数据包，而不等待定时器超时。\n\n需要注意的是，快重传只适用于可靠传输的TCP连接，而不适用于无连接的UDP协议。TCP快重传是TCP协议中的一种优化措施，它能够在一定程度上改善网络性能，减少不必要的传输延迟，提高数据传输的效率。\n4.验证状态下面可以用代码来实地查看tcp在传输过程中的各种状态。之前写过一个简单的http服务器，现在为了方便，直接拿来使用。\n采用如下命令进行netstat的循环监测\nwhile :; do netstat -ntp | grep 端口号;sleep 1; echo &quot;########################&quot;; done\n\n4.1 TIME-WAIT在浏览器访问，可以看到服务器返回的html页面\n\n后台可以看到，服务器接收到了请求的报头\n\n并按如下返回response\nDEBUG | 1679717397 | muxue | [sockfd: 4] filePath: web/index.html######### response header ##########HTTP/1.0 200 OKContent-Type: text/htmlContent-Length: 362Set-Cookie: This is my cookie test######### response end ##########\n\n使用netstat命令查看，当前多出了一个处于time wait状态的连接\n\n这代表四次挥手的第一个FIN是由服务器发出的，这一点在代码中也能体现，服务器accpet到连接后，会交由孙子进程来执行handlerHttpRequest(conet)服务\n// 提供服务（孙子进程）pid_t id = fork();if(id == 0)&#123;    close(_listenSock);//因为子进程不需要监听，所以关闭掉监听socket    //又创建一个子进程，大于0代表是父进程，即创建完子进程后父进程直接退出    if(fork()&gt;0)&#123;        exit(0);    &#125;    // 父进程推出后，子进程被操作系统接管    // 孙子进程执行    handlerHttpRequest(conet);    exit(0);// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收&#125;// 爷爷进程close(conet); //这个close并不会影响孙子进程内部的，因为有写时拷贝pid_t ret = waitpid(id, nullptr, 0); //此时就可以直接用阻塞式等待了assert(ret &gt; 0);//ret如果不大于0，则代表等待发生了错误\n\n这个服务函数并不是while(1)的死循环，内部也没有进行socket的close操作，而是发送完毕客户端请求的文件后，直接退出了\nvoid handlerHttpRequest(int sock)&#123;    cout &lt;&lt;     &quot;########### header-start ##########&quot; &lt;&lt; endl;//打印一个分隔线    char buffer[10240];    ssize_t s = read(sock, buffer, sizeof(buffer));    if(s &gt; 0)&#123;        cout &lt;&lt; buffer &lt;&lt; endl;        cout &lt;&lt; &quot;########### header-end   ##########&quot; &lt;&lt; endl;    &#125;    fflush(stdout);    string path = getPath(buffer);    // 假设用户请求的是 /a/b 路径    // 那么服务端处理的时候，就需要添加根目录位置和默认的文件名    // &lt;root&gt;/a/b/index.html    // 在本次用例中，根目录为 ./web文件夹，所以完整的文件路径应该是    // ./web/a/b/index.html    string resources = ROOT_PATH; // 根目录路径    resources += path; // 文件路径    logging(DEBUG,&quot;[sockfd: %d] filePath: %s&quot;,sock,resources.c_str()); // 打印用作debug    string html = readFile(resources);// 打开文件    // 开始响应    string response = &quot;HTTP/1.0 200 OK\\r\\n&quot;;    //如果readFile返回的是404，代表文件路径不存在    if(strcmp(html.c_str(),&quot;404&quot;)==0)    &#123;        response = &quot;HTTP/1.0 404 NOT FOUND\\r\\n&quot;;    &#125;    // 追加后续字段    response += &quot;Content-Type: text/html\\r\\n&quot;;    response += (&quot;Content-Length: &quot; + to_string(html.size()) + &quot;\\r\\n&quot;);    response += &quot;Set-Cookie: This is my cookie test\\r\\n&quot;;    response += &quot;\\r\\n&quot;;    cout &lt;&lt; &quot;######### response header ##########\\n&quot; &lt;&lt; response &lt;&lt; &quot;######### response end ##########\\n&quot;;    fflush(stdout);    response += html;    // 发送给用户    send(sock, response.c_str(), response.size(), 0);&#125;\n\n函数退出了之后，文件描述符就交由了操作系统。一个没有进程使用的文件描述符，会被操作系统直接close关掉。相当于操作系统帮我们发出了FIN，就出现了TIME WAIT状态。\n4.1.1 为啥要有这个状态？知道了4次挥手的过程后，我们就能知道，TIME-WAIT是4次挥手的发起方才有的状态。\n既然对方已经给我发了FIN，这不就代表对方也想和我分手吗？那我为啥还留着好友不删，非要等等呢？\n这是因为，我们发出的最后一次ACK是否被对方收到，是未知的！\n\nA给B发送最后一次ACK，B没有收到\nA不TIME-WAIT直接退出，A已经断开连接了，但是B还在维护这个连接\n如果有TIME-WAIT状态，B没有收到ACK，会对FIN进行超时重传\nA再次收到FIN，代表上一次ACK丢了，那就再次发送ACK\n如果A在TIME-WAIT状态什么信息都没有收到，那就代表自己的ACK被B收到了，便可以放心断连\n\n此时，TIME-WAIT状态保证了最后一次ACK的正常递达\n还有第二种情况：\n\nC给S发送FIN，准备断连\nS给C发送data，发送完毕后，立马发送FIN\ndata和FIN都在路由传输的过程，可能会出现FIN比data早到的情况\nC收到FIN，返回ACK，进入TIME-WAIT状态，期间收到了S发送的data\nC成功接收data，继续等待到计时器结束，释放链接\n\n此时，TIME-WAIT状态保证了二者之间的消息能都被收到\n4.1.2 等多久？这里引入一个新概念：一个报文在双方之间传输花费的时间，被称为这个消息的 MSL（maximun segment lifetime 最大生存时间）\nTIME-WAIT等待的时间需要适中，不同的操作系统，默认等待的时间都是不同的。CentOS下，这个时间是60s\n$ cat /proc/sys/net/ipv4/tcp_fin_timeout60\n\n一般情况下，设置为MSL*2是最好的，这样能保证双方数据的递达，和最后ACK的递达\n4.2 CLOSE-WAIT如果我们在handlerHttpRequest(conet);向客户端发送了html文件后，服务端休眠几秒钟；客户端打开网页后关闭网页，是否就能看到其他状态呢？\n// 发送给用户send(sock, response.c_str(), response.size(), 0);// 休眠几秒钟作为测试sleep(20);\n\n如下，情况又不同了。这次出现的是CLOSE-WAIT状态，代表第一个FIN请求是客户端发出的\n\n这是因为当前的进程没有进行长链接的维护，如果想维护长连接，则服务器应该给客户也返回一个http协议报头 Connection: keep-alive\n如下图，可以看到客户端发来的http-header里面，是有该字段的。而服务器并没有返回相同的字段，客户端就认为服务器不支持长链接，从而主动发出了FIN\n\n进一步看tcp的状态，当前是有两个父进程为1（采用了孙子进程的写法，父进程退出后会被操作系统接管）的进程在进行休眠，它们同属于295942这个tcp服务器主进程的进程组（PGID相同）\n当这两个进程结束休眠的时候，CLOSE-WAIT状态的连接立马消失了。因为操作系统接管了文件描述符后，进行了close，服务端也发出了fin，四次挥手成功，连接终止。\n\n4.3 ESTABLISHED如果我们给response加上长链接的报头，是否可以看到ESTABLISHED状态呢？\nresponse += &quot;Connection: keep-alive\\r\\n&quot;;\n\n可以看到，确实出现了这个状态，这代表双方成功维护起了长链接（虽然当前情况下，这个长链接并没有起到应有的作用）\n\n进一步轮换，将处理函数改为while(1)的死循环调用，我们应该可以通过一个socket实现多个报文的发送\n// 孙子进程执行logging(DEBUG, &quot;new child process&quot;);//打印一个新进程的提示信息，方便观察结果while(1)&#123;    handlerHttpRequest(conet);&#125;\n\n可以看到，只出现了一个子进程，对客户端进行服务\n\n查看日志，能看到，成功实现了长链接通信\n\n如果不采用while(1)死循环进行服务，则客户端的每一次请求，都需要一个新的子进程来服务\n\n即便response中带有长链接标识，也会因为fd被操作系统回收而进入TIME-WAIT状态\n\n4.4 端口不能被bind之前在tcp服务器的学习中，出现了如果立马把tcp服务器关了后开，同一个端口无法被bind的情况\n$ ./tcpServer 50000 &gt; logFATAL | 1679720482 | muxue | bind: Address already in use:3$ ./tcpServer 50000 &gt; logFATAL | 1679720491 | muxue | bind: Address already in use:3\n\n经过对tcp协议的学习，现在能知道为何这个端口不能被bind了。使用netstat -ntp命令查看，能看到这个端口上还有处于TIME-WAIT状态的链接，所以系统认为这个端口上还有tcp链接在运行，不允许我们二次bind这个端口。这是操作系统在默认状态下的行为。\n\n前面提到过，centos默认的TIME-WAIT等待时间是60s。只要等待60s，操作系统释放了这个端口上的冗余链接，就能被bind了！\n但是，这样会有很大的问题！请接着往下看\n4.4.1 问题假设我现在的服务器进程是直接bind 80端口对外进行服务的，这样他人就能直接通过我服务器的ip，以http协议与我的服务进程进行通信。\n以http网页服务为例，经过了很久很久的运行时间\n\n服务器进程出了恶性bug，导致进程退出了\n服务器压力过大，操作系统为了释放资源，直接把服务进程给kill了\n\n这时候，由于第一个FIN是由服务端发出的，服务器会进入TIME-WAIT状态。\n假设服务进程崩溃的时候，有数个用户正在访问你的网页。对于他们而言，崩溃的表现就是，刷新网页，直接白屏，显示不出来后续的页面了。\n此时就需要运维老哥赶快ssh连上服务器，重启服务进程\n为了关照运维老哥的头发，让出错的服务进程快速重启，一般情况下，我们会给这个服务进程增加一个监视进程\n\n监视进程是个死循环，其要做的功能很单一，所以负载并不大\n监视进程实时查看，每几秒就看一眼服务进程的状态\n服务进程挂掉了，监视进程在下一轮监视时会立马发现，通过 exec系列函数 直接重启服务进程\n\n这时候，TIME-WAIT的问题就出现了：服务进程想绑定的是80端口，也只能绑定80端口（不然客户端无法知道服务器端口改变，也依旧无法访问服务）但是80端口还有没有清理的tcp链接，操作不给你bind啊！\n如果等操作系统60s后清除链接再bind，那也太晚了🙅‍♀️\n大型服务进程启动时要干的活很多，所以启动会较慢。等待系统释放TIME-WAIT的链接后再bind，相当于多给服务进程启动增加了60s\n\n对于一些客户量级巨大的服务，时间就是生命呀！\n用户的耐心都不咋地，拿我自己举栗子吧！当我去访问一些网站时，如果5s之内网页没有加载出来，我就准备x掉那个网页了\n\n所以，为了避免由于TIME-WAIT/CLOSE-WAIT未释放而无法bind端口的问题，操作系统提供了端口复用的接口。让进程可以忽略冗余连接，直接bind这个端口！\n4.4.2 端口复用端口复用，复用的是有TIME-WAIT/CLOSE-WAIT这种冗余链接的端口，而不是处于服务状态的端口哈！一个端口只能对应一个服务，老规矩可不能破坏了。\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);\n\n默认情况下，端口有冗余链接，无法bind\n\n只需要在bind函数之前添加上如下代码，就能实现端口复用。\n// 1.1 允许端口被复用（即便还有TIME-WAIT的链接）int optval = 1;setsockopt(_listenSock, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));\n\n如下图，即便50000端口存在time-wait的链接，我们依旧可以正常bind这个端口！\n\n除了这种形式的端口复用，其实还有一个SO_REUSEPORT，它允许多个进程绑定同一个的端口；在nginx中就是采用这样的方式，让多个worker线程进行链接的竞争的。\n4.5 accpet不影响tcplinux给我们提供的接口accpt，并不参与3次握手的阶段\n将http服务的accpet给去掉，来观察这一情况。如下图，服务器直接是一个啥事不干的死循环，不对新来的连接进行accept，此时浏览器访问该服务，依旧会出现两个处于ESTABLISHED的连接\n\n这便证实了我们的结论：accpet不参与tcp3次握手的过程\n4.6 listen的第二个参数4.6.1 概念之前学习tcp服务器写法的时候，粗略提到了listen函数第二个参数的作用。\n#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);//backlog参数限制了能被阻塞等待连接的数量//如果超过这个数量，则会返回一个ECONNREFUSED错误。亦或者如果协议支持重传，多余的请求会被忽略，后续可以重传\n\n这里的阻塞等待连接是什么意思？还是用前面用到的http服务，以实际情况来看看\n\n什么情况下，一个连接会被阻塞？\n\n这一点就涉及到服务器的承受能力了。假设服务器现在很忙，压根没时间去accept一个新的连接，那这个连接就一直存在操作系统的tcp连接中，而没有进程对它服务。这种状态，就可以被称为连接的阻塞等待\n4.6.2 看看具体情况假设我将listen的第二个参数设置为了2，服务器是个啥事不干的死循环\nif (listen(_listenSock, 2) &lt; 0)&#123;    logging(FATAL, &quot;listen: %s&quot;, strerror(errno));    exit(LISTEN_ERR);&#125;\n\n在浏览器内直接开5个窗口请求这个连接，加上我的手机，一共是6个请求\n\n但后台可以看到，再继续增加浏览器请求的数量，依旧都只有两个连接是处于ESTABLISHED状态，和listen的第二个参数正好相同！这两个连接因为没有被服务进程accept，它们就是处于阻塞等待状态的！\n\n4.6.3 为什么？为什么操作系统要给一个进程维护阻塞等待的连接呢？既然这个进程不进行新连接的accept，操作系统为何不直接把这个连接丢弃呢？\n拿生活中非常场景的餐厅排队举例子吧。大家应该都见过一个餐馆在中晚餐高峰期时，门口有人在排队等位吧？特别是河海底捞，每次想去都得提前预定，不然排队的时间吃门口的小零食都要吃饱了。\n\n那么，餐馆为什么要提供排队等位呢？为何服务员不直接告诉新来的客人，馆子里没空位了，请另寻他处呢？\n\n原因很简单：为了上桌率。\n\n一个餐馆的上桌率越高，就代表其生意越好。如果餐馆内部没桌了，但是外头有人排队，这样就能让有客人离开（空出桌子后）立马有新的客人上桌。\n\n对于我们的服务进程也是一样！\n\n假设这个服务进程有10个线程对外进行服务，此时来了第11位需要服务的客人。服务的10个线程（桌子）都被坐满了，没人能给11号客人服务。那这时候，操作系统就告诉11位客人：“你在这里稍作等待，我去给你买个橘子取个排队单号”，这时候11号客人就在操作系统为服务进程提供的等候位置上坐了下来，等待服务进程腾出空位来给他服务（链接阻塞等待）\n这时候，有一个用户断开了连接，空出来了一个进程，那么服务进程（餐馆）内的服务员就跑出来，和11号客户说，他可以上桌了（accept）这时候，服务进程就开始给11号客户提供服务了。\n这样一来，只要服务进程有空闲，就能立马有新的进程入座，让服务进程不至于摸鱼。提高了服务器资源的利用效率。\n我买了一个服务器，我肯定是希望它在不崩溃的前提下为越多客户服务越好，资源最大化嘛！\n4.6.4 该参数应该设置成多少？既然我们已经知道了这个参数的作用，那么应该把它设置为多少呢？\n\n餐馆也需要面临这个问题\n\n如果自己设置的排队等位太少，那么可能会有想排队的客户没有位置坐。\n如果设置的太多，那新来的客户压根不打算排队了，因为他们知道，轮到自己的时候，已经饿扁了。\n\n服务器也是如此\n\n第二个参数设置的低了，排队的空位太少，超过该参数的链接直接被os拒绝，错过了本来可以提供服务的用户\n第二个参数设置的高了，用户过来排队，等了好久都没等到，于是就报错连接超时了。\n而且，打开一个网页的响应速度，也会直接影响用户对你的服务的满意度。每次点开你的网页都需要加载个十几秒的，久而久之，用的人只会越来越少！\n设置的太高了，维护的连接也会占用系统资源，服务进程可用资源变少了！\n与其增长队列，还不如增加服务进程的服务能力（扩大店面）\n\n所以，我们应该根据自己服务的面向用户数量级，设置一个合适的等位数量！这个应该根据具体情况来看的！\n4.6.5 listen和accept如下图，我让服务进程只对一个链接进行accept，相当于餐厅里面只有两张桌子。此时新来的链接就会处于等待状态，数量正好是listen的第二个参数（但是我的第二个参数是2，我也不知道为啥会是3个🤣）\n\n5.滑动窗口tcp中引入了滑动窗口的操作\n5.1 概念在实际通信中，如果真的只是让双方一发一答，那效率也太低了。所以，一般都是直接一次性发送多条消息，对方也是对多条报文进行ACK的，而且只需要ACK一次（这点在前面序号部分已经讲过原理了）\n\n一次性可以发送多条报文，但前提是对方有能力收那么多\n窗口大小：一次性可以发送的数据数量（无需等待前面已发报文的ACK，就可以发送这么多）\n窗口大小是由对方的接收能力决定的\ntcp报头中，16位窗口大小就是滑动窗口的大小\nS给C所发报头中的窗口大小，既代表S接收缓冲区的大小，又代表C可以一次发送的数据大小\nS接收缓冲区的大小变化，也会导致S给C所发报文中，窗口大小的变化\n\n\n窗口越大，代表双方通信的吞吐率就越大\n发送的数据会保留在发送缓冲区中，发送缓冲区以如下区域构成\n已发，收到了ACK的报文（可删）\n已发，未收到ACK的报文\n未发，准备发送的报文\n\n\n\n5.2 看图滑动窗口可以用下图来形象的理解，对图中的文字就不复述了（如果图片404了请及时告知我，谢谢）\n\n本人字丑，用pad写就更丑了，请谅解\n6.流量控制所谓流量控制，就是发送方根据对方的接收能力来选择发送数据的多少。\n如果B的接收缓冲区满了，会通过报文中的窗口大小告知A，A不再继续发送数据。\n此时，A会在过一会后，向B发送一个窗口探测报文，该报文没有有效载荷，所以不会过多占用接收缓冲区；\nB在收到该报文后，会回应报文，告知A自己的窗口大小，被称为窗口更新\n\n7.拥塞控制前面提到的tcp处理措施，都是为了保证通信双方的主机不会出什么错误，导致数据的丢失。\n但是一直么有提到一点，网络出错了咋办？\n你和对方打电话，结果电线都断了，那还咋电话呢？\n为了避免通信给网络造成太大的负担，tcp除了考虑对方的接受能力以外，还需要考虑网络的承载能力。\n7.1 如何确认网络出问题？如果双方通信的时候，出现了丢包，我们真的能确认网络出现问题了吗？\n\n答案是否定的。\n\n你和朋友之间打电话，突然对方的声音卡了一下，你就能下结论，是的电话线断了吗？\n\n实际上，只有你完全听不到对方声音了，又确认双方的手机都没有问题，才能认为是通信出了问题。\n\n网络也是一样，只有出现大面积丢包，才能认为是网络出了问题。\n我们知道，tcp基于字节流，一次性可以发送大量的信息。要是一个进程的tcp连接一建立，就开始往网络里面塞一大堆的信息，把网络给整堵塞了，那好吗？\n一个进程这么干，那多几个进程加入，网络直接雪上加霜。卡死了，谁都别想用！\n7.2 慢启动所以，为了避免这种情况，tcp添加了慢启动机制。\n说白了就是：刚开始发送的少，逐渐增多！\n\n\n整个过程如下：\n\n拥塞窗口从一个段的大小开始（约1kb）\n拥塞窗口有一个阈值ssthresh，默认为对方的窗口大小，这在3次挥手的时候已经确定了\n收到一次ACK，且拥塞窗口&lt;阈值，直接将现有拥塞窗口大小加倍【指数增长】\n也可以理解为，一个ACK（注意是一个ACK，并非一个报文）就加1\n比如第一次发送了1000个消息，那么收到对方的ACK为1000后，直接将拥塞窗口大小加倍，此时为2000，下一次发送就发2000的消息\n\n\n收到ACK，拥塞窗口&gt;=阈值，窗口值+1【线性增长】\n如果出现了发送超时，阈值ssthresh设置为拥塞窗口/2，拥塞窗口置为1（从头开始，避免大面积的重传）\n拥塞窗口始终小于接收器窗口\n\n实际传输的数据大小 = min(拥塞窗口,对方窗口大小)\n\n这便是慢启动的机制，上面贴的图能形象的展示数据慢慢增长到指数级增长的过程。\n8.延迟应答8.1 问题\n如何在保证不拥塞网络的前提下，传输更多数据？\n\n要知道，网络环境复杂多变，一次性发送更多数据，是优于多次发送少量数据的\n记住：窗口越大，网络吞吐量越大，传输效率就越高！\n这时候，如何提高网络传输效率的问题，就被转换成了：上层如何尽快取走缓冲区中的数据的问题。\n\n8.2 概念所谓延迟应答，即收到消息后，等一会再给对方应答；\n此时等待的是应用层取走接收缓冲区中的数据。这样在回应ACK的时候，缓冲区的容量更富裕，ACK中携带的窗口大小也就更大，下次对方就能发送更多数据，提高了tcp通信的效率！\n\n需要注意的是，窗口大小的增加，是与网络拥塞无关的。二者是tcp在传输中都要考虑的两个独立的问题。\n\n我们只要多等一等，就能给出时间让应用层取走一些数据，再给对方ACK，就能让自己的滑动窗口大小更大！\n比如下面这个栗子：\n\n假设接收端缓冲区为1MB，一次收到了500KB的数据；如果立刻应答，此时返回的窗口大小就是500KB；\n但实际上，接收端处理的很快，在30ms后，应用层就取走了收到的这500KB的数据\n这时候，接收端在等待发送端给自己发来的500KB数据的时候，缓冲区就已经恢复成1MB了\n但发送端并不能知晓这件事，它依旧是按500KB给接收端发送的信息。这时候，接收端的缓冲区就出现了闲置\n如果我们让接受端晚一点（比如晚200ms）再给发送端进行应答，此时应用层就已经取走缓冲区中的数据了，缓冲区大小恢复为1MB，接收端发送的应答中滑动窗口的大小也增加为1MB，发送端可以一次发送更多数据，缓冲区利用率提高！\n\n注意，接收端缓冲区提高，能让发送端一次发送数据量的上限提高。实际发送多少数据，还是由双方通信的内容决定的。\n\n8.3 策略延迟应答的时间需要注意，不能太长（否则发送端会因为超时没有收到ACK而触发重传）；也不能太短，否则应用层还没来得及取走数据\n一般延迟应答有如下两个策略\n\n隔N个包应答一次\n隔一定时间应答一次（要在延迟的同时，避免对方进行超时重传）\n\n延迟应答的策略根据不同平台而不同，一般N取2，间隔时间取200ms\n9.捎带应答在tcp报文的ACK应答的时候，如果采用一问一答的方式，会导致双方通信效率较低\nA -&gt; B 吃了吗B -&gt; A 吃了B -&gt; A 你呢？A -&gt; B 我还没有\n\n如果采用下面这种方式，就节省了一次收发的时间，提高了通信效率\nA -&gt; B 吃了吗B -&gt; A 吃了,你呢？A -&gt; B 我还没有\n\nTCP的捎带应答就是如此，在回答对方的消息(ACK)的同时，携带上自己要发送给对方的信息。\n要知道，所谓的ACK报文，只是需要将报头中的ACK标记位置为1即可，并不影响这个报文其他部分的功能！\n\n10.面向字节流调用write时，数据会先写入发送缓冲区中，并不是立马发送给对方\n\n如果一次性发送的字节数太长，会被拆分成多个TCP的数据包发出\n如果发送的字节数太短，可能会在缓冲区中等待，到一定数据量后，再发出\n\n这两个操作都是TCP自主帮我们完成的\n\n接收数据时，数据从网卡（数据一定是先被网卡收到的），被驱动程序读取后，流入操作系统的接收缓冲区\n应用层调用 read 从接收缓冲区中拿到数据\n\n因为同时拥有接收和发送缓冲区（全双工），所以TCP程序的读写不需要完全同步\n\n写100个字节，可以调用 write 写入100个字节，也可以调用100次 write 写入1个字节\n读100个字节，也可以多次读取，或一次性读取完毕\n二者都不需要考虑对方的写入是如何写入的！\n\n因为数据在缓冲区中都是没有严格分界的字节数据，TCP不关心这些数据的组成，所以TCP是面向字节流的。我们只需要读取之后，依照应用层的协议进行数据的处理即可。\n这也是为什么使用TCP时，应用层的协议需要规定一个协议中数据的边界（比如报文中数据字节的长度，或者用特殊字符来做边界，参考HTTP协议）\n11.粘包问题前面提到了，tcp在读写数据的时候，并没有严格的读取字节的要求，那么就可能会遇到下面的问题（C代表发送端，S代表接收端）\n假设应用层定义的协议一个报文是100KB大小；C -&gt; 100KB SC -&gt; 100KB SS 一次性读取了150KB的数据；此时，它读取了1.5个应用层的报文，并不完整！\n\n这种情况，被称为粘包问题\n解决粘包问题最好的办法，就是要明确报文和报文之间的边界，其通过应用层的协议来明确，必须要在应用层来处理；\n\n定长报文，要求双方都必须读写特定长度的报文，多的拆包，少的补空\n变长报文，可以采用在报文开头写明本条报文长度的方式，告知对方应读取多少字节\n变长报文，还可以采用数据分隔符的方式作为边界（需要保证正文中不能出现分隔符，比如http中的\\r\\n）\n\n对于UDP而言，并不存在粘包问题。因为UDP采用的是定长报文（面向数据报），应用层只会读取到一个完整的报文。\n如果UDP的一个报文不完整，代表数据在传输过程中出现了丢失。\n12.UDP可靠传输有的时候，会遇到这个问题。解决这个问题的思路就是：借鉴！\ntcp就是可靠的传输机制，我们只需要在tcp里面选择一部分tcp协议的特性，加到udp中，就能在一定程度上实现udp的可靠传输\n\n报文中添加序号，保证按序到达\n引入确认应答，确认对方收到了信息\n引入按序到达，保证数据包发送的顺序正确\n引入超时重传，如果一段时间对方没有应答，则重发\n…\n\n这些操作就需要程序猿在应用层去实现了。\nThe endUDP&#x2F;TCP协议的基本知识如上，后续还会继续补充\n","categories":["玩上Linux"],"tags":["Linux","nginx","tcp","udp"]},{"title":"【C语言】童年经典游戏-扫雷","url":"/posts/2375006677/","content":"想必屏幕前的你，肯定玩过windows XP系统自带的那个游戏，扫雷\n\n\n回想当年，我根本没看懂这个游戏是怎么玩的\n\n比起扫雷，三维弹球对我更有吸引力\n跑题了\n本篇博客就让我们一起来试试，如何通过C语言代码，制作出一个“扫雷游戏se”\n1.游戏程序主函数在编写这类游戏代码时，我们要用到的主函数基本是一致的\n扫雷游戏的主函数和猜数字游戏的主函数相差很小\n小白必学！简单的C语言应用&#x3D;&#x3D;＞猜数字游戏\nvoid menu()//简易目录&#123;\tprintf(&quot;***************************\\n&quot;);\tprintf(&quot;**** 1. play   0. exit*****\\n&quot;);\tprintf(&quot;***************************\\n&quot;);&#125;int main()&#123;\tint input = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();//实现游戏的函数\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出游戏\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;输入错误\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n2.游戏实现原理想写好一串代码，首先我们要知道扫雷游戏需要通过什么方式来实现\n\n我们需要一个9x9的棋盘，用于生成我们的雷以及玩家的游玩\n在c语言中当然无法直接产生这样的画面\n但我们可以同符号*或者#来代替网格，用1和0来表示有无雷\n如果我们只生成一个棋盘，那1和0会直接显示出来，达不到隐藏的效果\n所以我们需要用二维数组生成两个棋盘，一个用于存放雷，一个用于玩家的游玩\nchar mine[ROWS][COLS];//雷区布置char show[ROWS][COLS];//玩家看到的界面\n\n扫雷游戏我们使用头文件+源文件的形式撰写代码\n\n这样写代码的优点在于后续我们可以直接通过更改.h文件中的数组，从而更改我们的格子大小\n如: 改成12x12的游玩界面，改变雷区布雷个数等等\n\n所以我们需要在game.h中定义这些符号\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define ROW 9#define COL 9#define ROWS ROW+2#define COLS COL+2\n\n同时我们要在主函数的最上面引用这个自己写的头文件\n只要把库函数头文件放入game.h文件，在其他源文件中只需引用game.h\n不需要再次引用&lt;stdio.h&gt;、&lt;stdlib.h&gt;之类\n#include &#x27;game.h&#x27;\n\n棋盘大小为什么需要11x11？你可能注意到了，在生成数组的时候，我使用了ROWS，其值为ROW+2\n我们最终展示的只是9x9的游戏界面，但生成的棋盘其实是11x11的\n这是因为我们需要在mine数组中实现扫描雷区的操作\n\n玩过扫雷游戏的你肯定知道：在你点击一个格子的时候，如果这个格子不是雷\n它会显示一个数字，告诉你它周围的8个格子中有几颗雷\n\n如图所示：\n\n在C语言中，我们可以用函数统计周围8个格子中雷’1’的个数\n但是如果你来到边缘，那就出现问题了\n\n如果我们想统计边缘的格子周边有几颗雷，就会遇到这种溢出数组的情况\n此时代码会报错\n为了避免这个问题，我们可以在原来9x9的基础上在周围加一圈空白的格子\n也就是代码所示的ROW(行)COL(列)都要+2的情况\n#define ROW 9#define COL 9#define ROWS ROW+2#define COLS COL+2\n\n游戏过程这里简单梳理一下我们的游戏过程\n\n玩家选择开始游戏\n生成两个棋盘，一个放置雷\\扫描雷，一个向玩家展示游戏界面\n玩家输入坐标，选择排雷位置\n有雷–&gt;玩家被炸死，游戏结束；无雷–&gt;显示周边有几颗雷，游戏继续\n所有雷被排出，游戏胜利\n\n\n3.游戏代码实现接下来就进入我们的游戏代码部分\n3-1.初始化和打印//初始化扫雷InitBoard(mine, ROWS, COLS, &#x27;0&#x27;);InitBoard(show, ROWS, COLS, &#x27;*&#x27;);//打印扫雷DisplayBoard(mine, ROW, COL);DisplayBoard(show, ROW, COL);\n\n我们需要初始化两个棋盘，其中雷区初始化为0（0代表无雷），展示区初始化为’*’，用✳代替界面\n同时我们打印这两个棋盘，查看初始化效果\n因为这是我们的自定义函数，所以需要在.h文件中定义函数，在另外一个.c文件中包含函数的实现\n\n//初始化棋盘void InitBoard(char board[ROWS][COLS], int rows, int cols, char set);//打印void DisplayBoard(char board[ROWS][COLS], int row, int col);\n\n初始化函数和打印函数比较简单，使用for语句达成我们的需求\nvoid InitBoard(char board[ROWS][COLS], int rows, int cols, char set)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; rows; i++)\t&#123;\t\tfor (j = 0; j &lt; cols; j++)\t\t&#123;\t\t\tboard[i][j] = set;\t\t&#125;\t&#125;&#125;void DisplayBoard(char board[ROWS][COLS], int row, int col)&#123;\tint i = 0;\tint j = 0;\tprintf(&quot;------扫雷游戏------\\n&quot;);\t//打印列号\tfor (i = 0; i &lt;= col; i++)\t&#123;\t\tprintf(&quot;%d &quot;, i);\t&#125;\tprintf(&quot;\\n&quot;);\tfor (i = 1; i &lt;= row; i++)//只打印中心的99方格\t&#123;\t\tprintf(&quot;%d &quot;, i);//打印行号\t\tfor (j = 1; j &lt;= col; j++)//只打印中心的99方格\t\t&#123;\t\t\tprintf(&quot;%c &quot;, board[i][j]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\tprintf(&quot;--------------------\\n&quot;);&#125;\n\n需要注意的是我们的最后打印棋盘的时候是从i&#x3D;1开始的，这样就能避开添加的空白边缘区域，只打印中心的99方格\n同时我们添加了列号和行号，这样能让玩家清除的知道自己应该输入什么坐标\n\n3-2.布置雷区//布置雷SetMine(mine, ROW, COL);\n\n这部分代码我在学习的时候就有点力不从心了\n同样的，我们需要在game.h中定义这个函数\n//布置地雷void SetMine(char mine[ROWS][COLS], int row, int col);\n\n在game.c中写入自定义函数的实现\n//放置雷void SetMine(char  mine[ROWS][COLS], int row, int col)&#123;\tint count = EASY_COUNT;\twhile (count)\t&#123;\t\tint x = rand() % row + 1;\t\tint y = rand() % col + 1;\t\tif (mine[x][y] ==&#x27;0&#x27;)\t\t&#123;\t\t\tmine[x][y] = &#x27;1&#x27;;\t\t\tcount--;\t\t&#125;\t&#125;&#125;\n\n这里面出现了一个前面没有提到的变量，EASY_COUNT\n本来这个位置只是个10\n但如果我们想更改布雷个数，那每次都需要更改这里的10，后面的代码中也需要更改，非常麻烦\n所以我们改为使用一个自定义变量，在game.h中定义这个变量的值\n#define EASY_COUNT 10\n\n这个值就代表我们布置雷的个数了\n3-3.玩家排查雷//在主函数中引用这个函数\tFindMine(mine,show, ROW, COL);//需要把mine数组中排查的雷放入show//在game.h中定义这个函数void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS],int row, int col);\n\n因为我们需要把mine数组中排查出的雷的个数放入show数组中打印出来\n所以这里我们需要把两个数组都传送过去\n\n1.输入排查的坐标2.检查坐标处是不是雷(1)是雷 -boom！炸死 -游戏结束(2)不是雷 -统计坐标周围有几个雷-存储排雷的信息到show数组，游戏继续\n\nvoid FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)&#123;\tint x = 0;\tint y = 0;    \twhile (1)\t&#123;\t\tprintf(&quot;请输入排雷坐标:&gt; &quot;);\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\t//判断坐标是否正确\t\tif (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)\t\t&#123;\t\t\tif (mine[x][y] == &#x27;1&#x27;)\t\t\t&#123;\t\t\t\tprintf(&quot;很遗憾，你被炸死了\\n&quot;);\t\t\t\tDisplayBoard(mine, ROW, COL);\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//不是雷的情况下，统计坐标周围有几个雷\t\t\t\tint count = get_mine_count(mine, x, y);\t\t\t\tshow[x][y] = count + &#x27;0&#x27;;\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;坐标错误，请重新输入 \\n&quot;);\t\t&#125;\t&#125;&#125;\n\n注意，这里面我们需要添加一个代码来判断坐标合法性\n我们的棋盘是9x9，玩家要是输入一个(99,99)的坐标，那肯定不在数组中的，是无效的\n我们需要提醒玩家他输错了\n‘0’的作用show[x][y] = count + &#x27;0&#x27;;\n\n你可能会对这行代码感到疑惑\n为什么要在count后面+上一个‘0’？\n这里就和我们ascii码表有关了\n\n因为我们初始化数组和布置雷的时候，我们给数组传入的都是1和0这两个符号，并不是数字！\n但是在show数组中我们需要给玩家显示一个数字的字符\n\n这里面我们提供的是1的字符，并不是1它本身\n而我们在计算周边雷的个数的时候，传回来的是一个具体的数字\n观察表格，你会发现数字和对应的字符中间，都差了48\n而48恰好是字符’0’对应的ASCII码值\n所以我们需要用count加上字符’0’，以此在界面中向玩家展示周边8格有几颗雷\n3-4. 系统扫描雷如何把玩家选择的格子周边的雷扫描出来呢？\n设玩家的选择的坐标为x和y\n\n\n\nx-1,y-1\nx-1,y\nx-1,y+1\n\n\n\nx,y-1\nx,y\nx,y+1\n\n\nx+1,y-1\nx+1,y\nx+1,y+1\n\n\n我们只需要把这些坐标全部在二维数组中键入，就能逐个扫描出雷的个数\n//统计雷的个数static int get_mine_count(char mine[ROWS][COLS], int x, int y)&#123;\treturn mine[x - 1][y - 1] +\t\tmine[x - 1][y] +\t\tmine[x - 1][y + 1] +\t\tmine[x][y - 1] +\t\tmine[x][y + 1] +\t\tmine[x + 1][y - 1] +\t\tmine[x + 1][y] +\t\tmine[x + 1][y + 1] - 8 * &#x27;0&#x27;;&#125;\n\n这里因为我们扫描出来的也是‘1’的字符，系统中是字符1的ascii码值49\n所以我们需要减去8个字符‘0’，这样就能得到雷的个数的数字\n（然后在之前的那个函数中接受，count+‘0’，在show数组中显示）\n\n这个函数是在玩家排查雷的函数之前的\n因为在主函数中我们不需要使用这个自定义函数，所以不需要在game.h中定义\n我们想让它只在game.c中生效，所以用static修饰它\n\n\nstatic的作用\n1.修饰局部变量2.修饰全局变量3.修饰函数\n\n\n上面的代码其实还少了一个东西\n我们需要判断玩家什么时候胜利——雷区的0（无雷方块）全部被玩家找出，玩家就胜利了\nint win = 0;while (win&lt; row * col - EASY_COUNT)\n\n这里我们需要更改的是whlie函数\n其中 row * col - EASY_COUNT  指方格总数减去雷的个数，得到的是无雷方块的个数\n玩家每成功排除一个无雷方块，win就会加一个数字\nelse&#123;\t//不是雷的情况下，统计坐标周围有几个雷\tint count = get_mine_count(mine, x, y);\tshow[x][y] = count + &#x27;0&#x27;;\t//显示排查出来的信息\tDisplayBoard(show, ROW, COL);       win++;&#125;\n\n当win达到无雷方块个数的时候，whlie循环就会停止\n随后我们判断玩家是否胜利，如果胜利，就打印棋盘，让玩家知道雷的位置\nif (win == row * col - EASY_COUNT)&#123;\tprintf(&quot;恭喜你，游戏胜利！\\n&quot;);\tDisplayBoard(mine, ROW, COL);&#125;\n\n这里必须要判断，因为你失败了也是会跳出循环的！\n到此，我们的扫雷代码就是完成了\n4.查看结果这里我作弊，将雷的个数设置为80并打印出布置雷之后的棋盘\n输入最后一个雷的位置，系统提示我们游戏胜利\n\n输入雷的坐标后，也会提示你被炸死了\n\n到这里我们可以确认代码是编写成功了！\n完整代码获取 &#x3D;&#x3D;&gt;  [DAY018 扫雷]\n\n感谢你看到最后，写这个博客用了我2个小时，点个赞再走吧！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】二级指针","url":"/posts/1209573309/","content":"二级指针什么是二级指针？我们通常使用的int*p就是一个一级指针，而二级指针存放的变量就是一个一级指针代码示例如下：\nint main()&#123;\tint a =10;    int*pa= &amp;a;                    //有两个*号 的原因    int ** ppa= &amp;pa;//int*是代表变量pa的类型，*ppa表明这是一个指针变量        return 0；&#125;\n\n这里面pa是指针变量，一级指针\nppa是二级指针变量，&amp;pa取出pa在内存中的起始地址\n如图所示\n小结简单的说，指针变量也是变量，变量就有属于它的地址，而二级指针就是用来存放指针变量的地址的\n希望这对你有帮助！\n","categories":["初识C语言"],"tags":["C语言","指针"]},{"title":"【VS】如何解决VS编译器scanf报错问题","url":"/posts/4009185516/","content":"[toc]\n问题来源当我们使用vs编译器编译c语言代码，并需要用到一些非常常用的库函数的时候（如scanf）\nvs编译器通常会报出如下错误\n\n\n有的时候即便报错了，程序也可以正常运行\n\n但有的时候就会同图中一样，程序无法运行\n\n\n出现这个错误的原因是vs编译器认为这些库函数是“不安全的”（我可真谢谢你，担duo心guan那xian么shi多，微软）\n解决方法解决这个报错问题的方法有两种\n1.使用_S下标如图所示，我们可以在库函数后面加一个_s，这时候vs就会把它认为是“安全的函数”，程序就可以正常运行了\n\n方法一的致命缺点但是这么做有一个非常大的弊端——该代码只能在vs编译器里运行\n如图，如果我们将这一串带_S的代码复制到**devc++**这款编译器里面\ndevc++编译器会报错，无法运行这串代码\n同样的，如果你需要在mooc、牛客网或者其他刷题网站上填写代码的时候\n系统也无法运行这种带了_s的c语言代码\n这时候代码的“可移植性” （即通用性）就变差了！\n\n这时候就需要我们的解决方法2了\n2.使用防报错语句只需要在这个源文件的第一行添加这样一串代码\n#define _CRT_SECURE_NO_WARNINGS 1\n\n这串代码的作用就是屏蔽掉vs编译器对函数危险性的排查报错\n如图所示，我们的代码就能正常运行了\n\n这样操作，即便是将这一行防报错代码移植到另外一个编译器里，这串代码仍然能正常运行而且有的时候即便加上_s，还是会出现一些和scanf无关的奇怪报错使用方法二就能解决这个问题，这里建议大家还是使用方法二啦！\n\n方法二的缺点？你可能会说，那我岂不是每次写代码之前都需要打上这么一个define语句，那样也太麻烦了吧！\n再说了，我也背不下来啊！\n别急，下面我就会告诉你怎么让vs编译器每次创建源文件的时候自动带上这么一串代码\n如何在vs编译器里加上默认语句这里我们需要用到另外一款同样很经典的软件——Notepad++  \n如果你还没安装这款软件，这里是下载链接——&gt; [点我]\n\n安装完成后，我们点击左上角的 文件\n\n打开如下路径里，箭头所指的new++file文件\n\nvs编译器默认安装路径是c盘\n如果你的vs编译器不在c盘，可以通过右键桌面vs编译器的快捷方式，打开文件所在的位置，找到你vs编译器的安装路径\n\n\n打开以后是空白的\n我们只需要讲这行define语句加入这个文件，ctrl+s保存\n\n由于vs编译器处于c盘，修改这个文件需要申请管理员权限，点击同意即可！\n\n#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;\n\n\n这时候你创建的新的源文件，就会默认带上这串代码啦！\n由于&lt;stdio.h&gt;这个头文件实在是太常用了，所以我把它也加入了这个文件里。\n如果你愿意，也可以把int main()加入这个文件，方法同上\n\n这样就不用每次创建新的源文件的时候自己手打啦！\n一劳永逸！\n\n结语如果这篇文章对你有帮助的话，还请点个赞！\n万分感谢！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】printf函数的执行顺序，涉及函数传参","url":"/posts/3888883052/","content":"问题产生偶然在c语言学习交流群看到了这么一串让人费解的代码\n\n#include &lt;stdio.h&gt;int main()&#123;\tint i = 0;\tint j = 0;\tscanf(&quot;%d&quot;, &amp;i);\tj = -i++;\tprintf(&quot;%d %d %d&quot;, i, j, i++);\treturn 0;&#125;\n\n这里让我疑惑的是，为什么打印的第一个i是6而不是5？\n\nprintf语句的执行顺序这里要涉及到一个之前我并不清楚的知识点\nscanf(&quot;%d&quot;, &amp;i);j = -i++;printf(&quot;%d %d %d&quot;, i, j, i++);\n\n按照以往我的理解，代码的运行顺序是这样的\n\n1.用scanf将数字赋值给i\n2.将-i赋值给j，然后i++ （注：后置++是先使用再++）\n3.printf函数依次打印5，-4，6\n\n可代码君它并不想这么跑\n这里要涉及到函数内数据传参的问题\n函数内数据传参函数的传参是从右往左开始传参的\n所以这串代码在运行到printf的时候，会先执行第二个i++语句，此时i&#x3D;6\n然后再从左往右依次打印i，j，和后置++之前的i\n\n“首先-i++，是把-i的值-4给了j，然后i++变成了5，接下来就是函数的传参了，一般是从右3向左传参的”\n\n打印是从左往右打印，但是括号内部从右往左计算\n\n总结这里送给大家一张图，总结这个问题的原理\n如果对你有帮助，还请点个赞再走吧！\n\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】简单的printf递归","url":"/posts/4128252829/","content":"简单的Print递归\n说句题外话，很多时候单词我是认识的，但是如果它全大写了，我总要反应老一会才能想出来它的意思\n有和我一样的人吗?\n\n今天的c语言课讲到了一道非常经典的递归题目\n代码如下：\n#include &lt;stdio.h&gt;void Print(int n)&#123;\tif (n &gt; 9)\t\tPrint(n / 10);\tprintf(&quot;%d &quot;, n % 10);&#125;int main()&#123;\tint num = 0;\tscanf(&quot;%d&quot;, &amp;num);\tPrint(num);\treturn 0;&#125;\n\n结果如下\n\n运行顺序谈到递归的时候，最重要的就是要弄明白它究竟是怎么运行的\n老师上课讲的方法非常直观的表示了它的运算顺序\n这里我用粘贴代码块的方式来展示\n刚开始执行的是scanf输入，这里不再赘述\nvoid Print(int n)&#123;\tif (n &gt; 9)\t\tPrint(n / 10);\tprintf(&quot;%d &quot;, n % 10);&#125;\n\n这一块是我们递归的主体\nvoid Print(int n)&#123;\tif (n &gt; 9)\t  Print(3578 / 10);    \t\tif (n &gt; 9)\t\t\tPrint(357 / 10);    \tprintf(&quot;%d &quot;, 357 % 10);//7    \t\t\tif (n &gt; 9)\t\t\t\tPrint(35 / 10);    \t\tprintf(&quot;%d &quot;, 35 % 10);//5    \t\t\t\tif (n &gt; 9)//这时候值为3，已经不满足条件\t\t\t\t\t\tPrint(3 / 10);//该语句不执行    \t\t\tprintf(&quot;%d &quot;, 3 % 10);//3\tprintf(&quot;%d &quot;, 3578 % 10);//8&#125;\n\n看起来可能有点乱，在这基础上加上一些箭头就会清晰了\n\n起初我的想法是，在进行if判断之后，会先执行下面的printf，即先打印最后一位数8，再向前打印\n\n实际上，if语句后的Print函数的嵌套调用是在下一行printf之前的、\n也就是说它需要像图中这样完全调用完，直到if判断为假后，才会从后往前运行printf语句\n这才有了最开始我贴的结果\n程序依次打印了每一位的数字\n\n\n如果这篇博客对你有帮助，还请点赞收藏支持一下！万分感谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】如何将输入的数字逆序打印","url":"/posts/2746269565/","content":"﻿这个问题是我在做学校的作业时候看到的。只隐约有印象讲过，但是忘记了怎么操作。听同学的点通才回想起来，特此写个博客留记\n\n\n[toc]\n逆序打印目的：输入“789”，打印“987”\n\n注：本博客的数字逆序只涉及 十进制\n\n代码实现有两种方式：1.利用if语句进行大小判断，直到选出从大到小的数字排序这个方法十分复杂，稍不留意就会弄错，所以在实际应用中不推荐这样操作这里就不赘述具体代码了。(才不是懒，压根没试过）2.使用%10的方法直接打印代码如下：\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 0;\tscanf(&quot;%d&quot;, &amp;a);\tprintf(&quot;%d&quot;, a % 10);\tprintf(&quot;%d&quot;, a/10 % 10);\tprintf(&quot;%d&quot;, a/100 % 10);\treturn 0;&#125;\n\n代码结果如下\n\n这个代码成功达到了我们的目的，但是有一个比较明显的弊端如果我们需要更多位的数字的逆序数时，这个代码就会变得很长，而且每次都需要我们手动添加一个新的printf\n\n代码优化1想要逆序比较长的数字，就需要用到循环语句，我使用的是for循环主要需要解决的问题是，a每%10一次后就需要除以10再%10一次\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 0;\tint n = 0;\tint i = 0;\tprintf(&quot;请输入需要逆序的数字：&quot;);\tscanf(&quot;%d&quot;, &amp;a);\tprintf(&quot;请输入该数字的位数：&quot;);\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\t\tprintf(&quot;%d&quot;, a % 10);\t\ta /= 10;\t\t\t&#125;\treturn 0;&#125;\n\n代码运行结果如下\n我们的目的成功达成！\n\n代码优化2上面的代码虽然完成了我们设想的目的，但它还是有一个缺点\n需要用户手动输入数字的位数\n\n设想一下，系统需要你填写你的手机号，你输入自己的手机号后，系统还要再问问你“你的手机号有几位数”\n这换谁都血压飙升，怒m代码猿了吧！\n\n那怎样让代码自动逆转我们需要的数字呢？\n\n注：这串代码是我在b站看到的，顿时联想到了自己的博客，于是又跑过来更新了! 原视频链接\n\n\n图里while后面的不等于符号应该是一个vscode的插件，我们需要将它改成!&#x3D;\n#include &lt;stdio.h&gt;int main()&#123;\tint num;\tprintf(&quot;请输入一个数；&quot;);\tscanf(&quot;%d&quot;, &amp;num);\tint reverse = 0;\twhile (num != 0)\t&#123;\t\treverse = reverse * 10 + num % 10;\t\tnum /= 10;\t\t\t&#125;\t//输出反转后的数字\tprintf(&quot;反转后的数字是：%d\\n&quot;, reverse);\treturn 0;&#125;\n\n\n这串代码就是完美的了吗？\n并不是，如果我们键入1000，结果就会发生一些细微的变化\n\n输出的结果竟然是1，但我们需要的应该是0001\n\n代码优化3这里涉及到了%d时左补0的问题\nprintf打印时%d左补0假设下面这串代码是需要输出1000逆序后数字0001的printf语句\n因为1000只有4位，所以我们可以在%和d之间加上04\n即满4位不补，不满4位左补0\nint n =1;pirntf(&quot;%04d&quot;,n);\n\n但在逆序数字里面，我们需要打印的数字长度是不可控的\n这里需要用到左补0的另外一种代码\n\n用另外一个变量来表示数的位数\n\nint n=1;int m=3;//代表数的位数，同%03d里面3的意义一样pirntf(&quot;%0*d&quot;,m,n);\n\n这样下来就简单了，我们只需要在原有的while循环里面加上另外一个变量\n每次逆序循环完成后，这个变量都++一次，就能达到我们的目的\n#include &lt;stdio.h&gt;int main()&#123;\tint num;\tint j = 0;\tprintf(&quot;请输入一个数；&quot;);\tscanf(&quot;%d&quot;, &amp;num);\tint reverse = 0;\twhile (num != 0)\t&#123;\t\treverse = reverse * 10 + num % 10;\t\tnum /= 10;\t\tj++;\t&#125;\t//输出反转后的数字\tprintf(&quot;反转后的数字是：%0*d\\n&quot;,j, reverse);\treturn 0;&#125;\n\n运行结果如下：\n\n这下我们的目的才真正完成了，既可以不用自己多输入一遍数字的个数\n又能在输入10000这类数字的时候，逆序后自动左补0\n\n希望这对你有帮助！","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C语言】验证哥德巴赫猜想","url":"/posts/3088418740/","content":"问题来源这是学校的一个作业，原题如下\n\n题目先给出了哥德巴赫猜想的背景知识（我还真不知道）\n2000以内的正偶数都能分解成两个质数（素数）之和\n题目要求下面来梳理一下题目的要求：\n\n输出样式为a&#x3D;b+c，使用%4d&#x3D;%4d+%4d输出\n每行输出4个，每行最后一个输出无空格\n每个偶数只需要一个结果即可（后续较大的偶数有很多种解）\n\n弄懂了题目要求，下面就来一步一步写代码\n\n如何判断素数？在上篇博客里面提到了如何判断素数&#x3D;&#x3D;&gt;【链接】，这里不再赘述 \n我们需要搞定的是判断是那两个素数b、c相加等于我们需要的那个数a\n因为需要多次判断，这里我们使用自定义函数\nint SuShu(int a)&#123;\tif (a == 2)\t&#123;\t\treturn 1;\t&#125;\tint j = 0;\tfor(j = 2; j &lt;=sqrt(a); j++)\t&#123;\t\tif (a % j == 0)\t\t&#123;\t\t\treturn 0;\t\t&#125;\t&#125;\treturn 1;&#125;\n\n为什么是return1和0呢？\n因为在写这段代码的时候，我本来是想判断之后返回一个素数，但是这个方法效率太低\n而且写到后面我自己都不会写了，遂放弃。\n\n主函数\n最终实现形式：n&#x3D;a+(n-a)\n\n在自定以函数里面返回的值是1和0\n主函数里面就需要内容来接收\nif (SuShu(a) &amp;&amp; SuShu(n - a))//判断a和n-a是否都是素数\n\n同时我们需要完成打印4行换一行，以及每行最后一个不能有空格的要求\n这时候直接在printf语句里面加空格已经不够了\n需要用到判断语句，判断已经打印了几个等式\nif (SuShu(a) &amp;&amp; SuShu(n - a))&#123;\tprintf(&quot;%4d=%4d+%4d&quot;, n, a, n - a);\tcount++;//每打印一次就++一次\tif (count % 4 == 0)\t&#123;  //打印4次后打印一个换行符\tprintf(&quot;\\n&quot;);\t&#125;\telse\t&#123;  //不够4次，需要打印空格\tprintf(&quot; &quot;);\t&#125;&#125;\n\n素数判断的部分我们已经写完了\n接下来要写的是一个for循环，让n从4开始一直+到2000\n另外，同【如何判断素数】博客中的开平方法一样\n在验证哥德巴赫猜想的时候，若a&#x3D;b+c，b和c中肯定有一个数小于或等于a&#x2F;2\n在写a的for循环的时候，我们可以让判断条件a&lt;&#x3D;n&#x2F;2，而不是a&lt;n\nfor (n = 4; n &lt;= 2000; n+=2)&#123;\tfor (int a = 2; a &lt;= n/2 ; a++)\t&#123;  //在之前我们并没有定义a，需要在for循环里加上int\t\tif (SuShu(a) &amp;&amp; SuShu(n - a))\t\t&#123;\t\t\tprintf(&quot;%4d=%4d+%4d&quot;, n, a, n - a);\t\t\tcount++;\t\t\tif (count % 4 == 0)\t\t\t&#123;\t\t\t\tprintf(&quot;\\n&quot;);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot; &quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t&#125;\n\n到这里，我们的主函数也完成啦！\n完整代码+效果演示#include &lt;stdio.h&gt;#include &lt;math.h&gt; int SuShu(int a)&#123;\tif (a == 2)\t&#123;\t\treturn 1;\t&#125;\tint j = 0;\tfor(j = 2; j &lt;=sqrt(a); j++)\t&#123;\t\tif (a % j == 0)\t\t&#123;\t\t\treturn 0;\t\t&#125;\t&#125;\treturn 1;&#125;//验证哥德巴赫猜想，输出4到2000的偶数//每个偶数的结果只输出一次int main()&#123;\tint n = 0;\tint count = 0;\tfor (n = 4; n &lt;= 2000; n+=2)\t&#123;\t\tfor (int a = 2; a &lt;= n/2 ; a++)\t\t&#123;\t\t\tif (SuShu(a) &amp;&amp; SuShu(n - a))\t\t\t&#123;\t\t\t\tprintf(&quot;%4d=%4d+%4d&quot;, n, a, n - a);\t\t\t\tcount++;\t\t\t\tif (count % 4 == 0)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\n&quot;);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot; &quot;);\t\t\t\t&#125;\t\t\t\tbreak; //只打印一种情况\t\t\t&#125;\t\t&#125;\t\t\t&#125;\treturn 0;&#125;\n\n细心的你肯定注意到，在main函数中判断素数的语句里多了一个break，它的作用是什么呢？\n如果没有break，结果如下：\n代码会将符合条件的素数相加全部打印出来\n这显然不符合每个偶数的结果只输出一次的要求\n\n但在加了break这个断点之后\n代码的结果就和题目要求的一样了\n\n\n写代码中的误解在最终提交代码的时候，我的代码格式出错了\n原因是我在printf语句里面加多了两个空格，如下：\nprintf(&quot;%4d= %4d+ %4d&quot;, n, a, n - a);\n\n为什么我会想当然的多加两个空格呢？\n因为题目所给的输出样例，让我误以为&#x3D;和+之间都有两个空格\n\n实际上这里并没有空格，它的“空格”是printf中的%4d造成的\n代码给这里留了4个数字的位置，但是大多都只有一个数字和两个数字\n于是它们前面就会有3或者2个留给数字的空，让我误以为这里有空格\n基础不牢，地动山摇！\n\n总结通过这道题，我复习了循环和自定义函数的写法，也获得了哥德巴赫猜想的新知识\n多刷刷题总是好的\n希望这篇博客对你有帮助！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】用递归和非递归，求第n个斐波那契数","url":"/posts/1174654848/","content":"[toc]\n问题引入 - 什么是斐波那契数列？斐波那契数列中，第n项为n-1和n-2项之和\n\n1，1，2，3，5，8，13，21，34，55……\n\n这个数列非常经典，经常用于编程语言初学者的练习\n接下来让我们用非递归和递归两种方式来实现这个数列\n并了解两种方法的优缺点！\n\n1.非递归方法（迭代）什么是迭代？\n迭代其实和循环的意义差不多（个人理解）\n\n我们计算斐波那契数列的时候，需要从第一项和第二项1、1开始计算\n没后一项数字都是前两项数字之和\n这样我们就可以利用循环，从第一项开始不断相加，再使其中一个加数等于得到的和\n以此迭代，就能得到我们需要的第n个数字\n\n代码实现#include&lt;stdio.h&gt;//非递归int fo1(int a)&#123;\tint tmp = 0;\tint num1 = 1;\tint num2 =1;\tif (a &lt; 3) //前两项都为1\t&#123;\t\treturn 1;\t&#125;\telse//从第三项开始迭代\t&#123;\t\tfor (int i = 0; i &lt;= a - 3; i++)\t\t&#123;\t\t\ttmp = num1 + num2;\t\t\tnum1 = num2;\t\t\tnum2 = tmp;\t\t&#125;\t\treturn tmp;\t&#125;&#125;int main()&#123;\tint a,b = 0;\tscanf(&quot;%d&quot;, &amp;a);\tb=fo1(a);\tprintf(&quot;%d\\n&quot;, b);\treturn 0;&#125;\n\n结果如图：\n\n迭代的缺点这种方法有个缺点，即数字很大的时候，容易栈溢出\n如果栈溢出没有影响，迭代的方法就非常适合\n\n比如：\n\n题目规定了不考虑栈溢出\n\n题目设定了数字范围\n\n\n\n\n2.递归使用递归的基本方法，和迭代其实是一样的\n最大的不同是：递归的核心是函数自己调用自己\n\n代码实现#include&lt;stdio.h&gt;//递归int fo2(int a)&#123;\tif ((a == 1) || (a == 2))\t&#123;\t\treturn 1;\t&#125;\telse\t&#123;\t\treturn (fo2(a - 1) )+( fo2(a- 2));//n-1和n-2项\t&#125;&#125;int main()&#123;\tint a,b = 0;\tscanf(&quot;%d&quot;, &amp;a);\tb=fo2(a);\tprintf(&quot;%d\\n&quot;, b);\treturn 0;&#125;\n\n最终执行的效果是一样的\n递归的缺点递归的实现方式是函数不停地自己调用自己\n\n如图所示，当我们需要第50个斐波那契数列中的数时\n函数需要从50开始，49、48，再48、47……\n这么一直递归到第3个斐波那契列数，才能逐级返回每项的数字，得出最终答案\n这就大大增加了程序运行的时间！\n\n你可能会发现程序依旧很快运行完了，那是因为现在电脑cpu的运行速度已经非常快了\n但在有运行时间要求的题目中，这样浪费时间是万万不可的\n\n\n总结递归和迭代两种方法各有优劣，我们需要在具体情境中选择是使用递归还是迭代\n计算斐波那契数列只是这其中的一部分\n如果这篇博客对你有帮助，那就点个赞再走吧！\n","categories":["初识C语言"],"tags":["C语言","数组"]},{"title":"【C语言】unsigned无符号类型运用的两个实例","url":"/posts/26306730/","content":"@[toc]\n前排提醒😂本篇博客是对下一篇博客《char类型在内存中的存放》的拓展\n并非对unsigned类型的详解！\n\n示例1#include &lt;stdio.h&gt;int main()&#123;\tint i=-20;\tunsigned int j=10;\t\tprintf(&quot;%d\\n&quot;,i+j);\treturn 0; &#125; \n\n当有符号类型和无符号类型相加的时候，编译器是怎么处理的呢？\n10000000 00000000 00000000 00010100  -20的原码11111111 11111111 11111111 11101011   反码11111111 11111111 11111111 11101100   补码\n\n00000000 00000000 00000000 00001010   10的补码\n\n-20的补码和10的补码 相加\n11111111 11111111 11111111 11110110 得到的补码11111111 11111111 11111111 11110101 反码10000000 00000000 00000000 00001010 原码 -10\n\n得到的结果为-10\n\n当我们把j改为-10的时候，编译器依然能给出正确的答案-30\n这是因为在计算的时候，编译器先按照补码的形式进行运算，最后%d打印，格式化为有符号整数\n\n数据的存储和类型无关，只有读取的时候有区别\n\n\n示例2 第二个示例可以让我们了解无符号数在应用时候存在的限制\n#include&lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123;\tunsigned int i;\tfor(i=9;i&gt;=0;i--)\t&#123;\t\tprintf(&quot;%u\\n&quot;,i);\t\tSleep(1000);//更好的观察数据的打印\t&#125;\treturn 0;&#125;\n\n因为这里我们使用的是%u打印无符号数\n而无符号数i中不可能出现负数，也就没有小于0的情况（i永远大于等于0）\n当i&#x3D;0后继续–，二进制补码变成如下形式\n11111111 11111111 11111111 11111111\n\n因为是无符号数，直接将补码视作原码进行计算\n就得出了在窗口中打印的非常大的数字\n\n\n小结本篇博客展示了两种无符号数调用的情况\n下篇博客讲述char类型在数据中的存储的时候会用到！\n\n最近事情真的挺多的，英语4级、期末考试\n高数和线代真的太难了，两座大山压着我😥\n希望期末不挂科\n\n感谢你看到最后，求点赞关注！\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【C语言】如何判断素数","url":"/posts/2649139425/","content":"如何判断素数\n题目要求：输出100-200的素数\n\n首先我们要知道什么是素数（质数），以防有人忘记（比如刚学开始学c的我就忘记了）\n素数（质数）只能被1和它自己整除\n\n\n7只能被1和7整除，是素数\n9能被3整除，不是素数\n\n\n方法1—试除法#include&lt;stdio.h&gt;int main()&#123;    int i=0;    int count=0;    for(i=100;i&lt;=200;i++)    &#123;        int j=0;        for(j=2;j&lt;i;j++)        &#123;             if(i%j==0)//i可以整除j，i不是素数             &#123;                 break;             &#125;        &#125;        if(j==i)//i只能整除它自己，是素数        &#123;            count++;            printf(&quot;%d &quot;,i);        &#125;    &#125;    printf(&quot;\\ncount=%d\\n&quot;,count);//计算100-200之间有几个素数    return 0;&#125;\n\n\n这个代码比较死，只是输出了100到200之间的素数，完成了题目的要求\n我们可以把它改造成输入一个数字，判断是否是素数的形式\n\n代码改造1-1\n用户输入一个数字\n代码判断是否为素数\n是，输出“是素数”以及用户输入的值\n不是，输出“不是素数”\n\n#include&lt;stdio.h&gt;int main()&#123;    int i=0;    int j=0;    scanf(&quot;%d&quot;,&amp;i);    for(j=2;j&lt;i;j++)    &#123;    \tif(i%j==0)        &#123;            printf(&quot;不是素数\\n&quot;);            break;    \t&#125;\t&#125;    if(j==i)    &#123;        printf(&quot;是素数,i=%d\\n&quot;,i);    &#125;      &#125;\n\n结果如下：\n\n\n\n上面的这串代码能很好地完成我们的需求，但它还有优化的空间\n方法2—开平方法方法1中的for循环为j&lt;i\n如果数字很大的话，要循环非常多次才能出现j&#x3D;&#x3D;i的情况\n这就拖慢了我们程序运行的速度\n这里我们引入一个概念\n\n若i&#x3D;a*b\na和b中至少有一个数字 &lt;&#x3D; 开平方i\n\n\n如16&#x3D;2x8&#x3D;4x4\n其中2&lt;4\n\n这样就能得到一个结论：\n在根号i之前一定有一个数字n是非素数的除数\n如果找不到这个数字n，说明该数字为质数\n\n利用开平方法，我们可以将需要查找的数字范围缩小很多\n以下是用该方法完成开头题目要求的代码示例\n#include&lt;stdio.h&gt;int main()&#123;\tint i=0;\tfor(i=101;i&lt;=200;i+=2)\t&#123;\t\tint j=0;\t\tfor(j=2;j&lt;=sqrt(i);j++)\t\t&#123;\t\t\tif(i%j==0)\t\t\t&#123;\t\t\t\tbreak;             &#125;\t\t&#125;\t\tif(j&gt;sqrt(i))\t\t&#123;\t\t\tprintf(&quot;%d &quot;,i);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n\n将这个代码改造成1-1那种形式也不难，自己试试吧！\n两个方法分别的弊端试除法该方法会错过1\n开平方法该方法会错过2\n\n感谢你看到最后如果这篇博客对你有帮助，请点赞支持一下，万分感谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】整型数据在内存中的存储(详解)","url":"/posts/3848679385/","content":"[toc]\n数据类型我们知道，C语言中有很多不同的数据类型\n在cppreference.com网站上可以找到C语言中的不同类型【链接】\n\n先来认识一个不那么常见的类型\n布尔类型C99中引入了布尔类型  _Bool实质：把1和0变成ture和false\n#include&lt;stdbool.h&gt;int main()&#123;\t_Bool flag = true;\tif(flag)\t&#123;\t\tprintf(&quot;hehe\\n&quot;);\t&#125;\treturn 0;&#125;\n\n代码的效果如下：\n\n因为布尔类型和以1-0来判断正误的作用是相同的\n所以这个类型我们一般不会使用\n\n无符号数据的打印Unsigned无符号数用%u打印\n\n\n用%d打印的时候，认为是有符号数\n用%u打印无符号数的时候，负数会乱码\n\n\n我们知道，整型数据在内存中占用4个字节（32位），double类型是8个字节\n不同数据占用的字节\n在之前的学习中，我们已经知道了如何使用这些不同的数据类型\n但是你知道，数据在内存中是怎么存储的吗？\n这篇博客将带你认识整型在内存中的存储\n\n整型在内存中的存储先来认识一下整型家族都有谁吧！\n整型家族\n\nchar\n​\tunsigned char\n​\tsigned char\n\nshort\n​\tunsigned short [int]\n​\tsigned short [int]\n\nint\n​\tunsigned int\n​\tsigned int\n\nlong\n​\tunsigned long [int]\n​\tsigned long [int]\n\n\n\n我们平时用的最频繁的int其实是signed int\n\nchar到底是signed char还是unsigned char，取决于编译器的实现\n常见的编译器下，char就是signed char\n\n在知道整型在内存中的存储方式之前\n我们需要先认识一下三个好朋友“原 反 补”\n“原反补”三兄弟正整数：原反补码相同\n负整数：\n\n\n\n原码\n按照一个数的正负直接写出来的二进制\n\n\n\n反码\n符号位不变，其他位按位取反\n\n\n补码\n反码的二进制序列+1，得到补码\n\n\n二进制要怎么写出来呢？下面以15为例（前面省略了24位）\n每一个1都是2的权重\n\n这就是二进制和十进制转换的方式\n而15作为正数，原反补码都是这个二进制数\n\n00000000 00000000 00000000 00001111\n正数的原反补码相同\n\n\n什么是符号位？每一个整型都有4个字节，由32个bit位组成\n其中原码的第一位，就是该二进制的符号位\n正数为0，负数为1\n\n最高位为符号位，后面的是有效位\n\n再举个-15的例子\n\n\n\n10000000 00000000 00000000 00001111\n原码\n\n\n\n11111111 11111111 11111111 11110000\n反码\n\n\n11111111 11111111 11111111 11110001\n补码\n\n\n为了进一步了解数据在内存中的存储方式，我们将15的&#x3D;&#x3D;补码&#x3D;&#x3D;转化为十六进制\n每4个二进制比特位对应一个十六进制数，转换结果如下\n\n\n\n00000000\n00000000\n00000000\n00001111\n\n\n\n00\n00\n00\n0F\n\n\n\n可当我们在VS编译器-监视-内存窗口里面查看15数据的时候\n展示的是以下的16进制形式\n\n可以看到，内存中存储的十六进制，和我们计算出来的是&#x3D;&#x3D;反着的&#x3D;&#x3D;\n这又是为什么呢？\n\n大小端问题高位低位来自于人类从左到右的阅读习惯。所以一串二进制数，左侧为高位，右侧为低位\n大端字节序存储：\n当一个数据的低字节的数据存放在高地址处，高字节序的内容放在了低地址处，这种存储方式就是大端字节序存储\n小端字节序存储：\n当一个数据的低字节数据存放在低地址处，高字节序的内容放在了高地址处，这种存储方式就是小端字节序存储\n\n简称：小同大异\n\n而我们图中VS内存窗口显示的这种“反着放”的方式，是因为：\n\nVS编译器下，内存窗口显示的是左低右高\n二进制码是高00000000 00000000 00000000 00001111低\n\n所以VS编译器是小端存储的\n\n而如果是以低00 00 00 0f高的方式放入内存，则是大端字节序存储\n\n负数示例\nint b=-10；\n\n\n\n\n原码10000000\n00000000\n00000000\n00001010\n\n\n\n反码11111111\n11111111\n11111111\n1110101\n\n\n补码11111111\n11111111\n11111111\n11110110\n\n\nf    f\nf    f\nf    f\nf    6\n\n\n\n了解了大小端的机制之后，我们可以来写一个简单的函数\n判断当前编译器是大端还是小端\n#include &lt;stdio.h&gt;int check_sys()&#123;\tint a=1;\tchar*p=(char*)&amp;a;\tif(1==*p)\t\treturn 1;\telse\t\treturn 0;\t\t&#125;int main()&#123;\tint b=check_sys(); \tif(1==b)\t\tprintf(&quot;小端\\n&quot;);\telse\t\tprintf(&quot;大端\\n&quot;);    \treturn 0; &#125; \n\n这串代码的自定义函数部分可以进行优化\n\n因为*p&#x3D;1时返回1\n其他情况返回0\n所以可以选择直接返回*p\n\n//代码优化2 int check_sys()&#123;\tint a=1;\tchar*p=(char*)&amp;a;\treturn *p;\t&#125;\n\n进一步优化，我们可以把(char*)&amp;a直接进行解引用并返回他的值\n这样就能跳过中间变量p\n//代码优化3int check_sys()&#123;\tint a=1;\treturn *(char*)&amp;a;\t&#125;\n\n这里有两个问题需要注意：\n不能直接对a进行强制类型转换，这种方式是错的\n大小端是把数据放在内存之后才有的现象\n\n大小端讲的是以字节为单位的顺序\nchar类型只有一个字节，没有大小端问题\n\n\n为什么整型在内存中存放的是补码呢？\n在计算机系统中，数值一般用补码来表示和存储，原因在于，试用补码，可以将符号位和数值域统一处理；\n同时，加法和减法也可以统一处理(CPU只有加法器)\n此外，补码与反码相互转换，其运算过程是相同的，不需要额外的硬件电路。\n\n计算机中只有加法器，减法用加法来模拟\n1-1→1+(-1)\n如果用原码的计算：\n\n\n\n00000000 00000000 0000000 00000001\n+\n\n\n\n10000000 00000000 0000000 00000001\n&#x3D;\n\n\n10000000 00000000 0000000 00000010\n-2 错误\n\n\n补码：\n\n\n\n00000000 00000000 0000000 00000001\n1原\n\n\n\n10000000 00000000 0000000 00000001\n-1原\n\n\n它们的补码\n\n\n\n00000000 00000000 00000000 00000001   +\n1的补码\n\n\n\n11111111 11111111 1111111 11111111   &#x3D;\n-1的补码\n\n\n00000000 00000000 0000000 00000000\n结果为0\n\n\n 其中第一个1为符号位\n\n结语到这里，整型在内存中存储的基本知识就已经讲完啦\n如果对你有帮助，还请不要吝啬手里的赞👍！\n能留下个评论就更好了\n这对我真的很重要！！！\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【C语言】浮点数在内存中的存储（详解）","url":"/posts/3650400098/","content":"[TOC]\n引言\n本文首发于 ❄️慕雪的寒舍\n\nmarkdown语法小知识点写在前面，markdown语法的小知识点\n如何实现文字变红且加上了底色？如hello world\nmarkdown语法如下即可！\n`hello world`\n\n以及页内跳转\n&lt;span id=\"jump\"&gt;这一句话没啥用&lt;/span&gt;[回到开头](#jump)\n\n正题之前学习完了整形、字符类型在内存中的存储，今天让我们来看看float类型！\n\n整数类型👉【int】\n字符类型👉【char】\n\n常见的浮点数3.141591E10\n\n浮点数家族包括float、double、long double 类型。\n而浮点数表示的范围是在头文件&lt;float.h&gt;里面定义的。\n需要了解的是\n\n如果你打出3.14，编译器默认是double类型的。若想让他为float类型，则要在前面加f；\n1E10是科学计数法，代表1.0×10^10\n\n代码引例先来看看下面这串代码\nint main(){\tint n = 9;\tfloat* pfloat = (float*)&amp;n;\tprintf(\"n的值为：%d\\n\", n);\tprintf(\"*pfloat的值为：%f\\n\", *pfloat);\t*pfloat = 9.0;\tprintf(\"num的值为：%d\\n\", n);\tprintf(\"*pfloat的值为：%f\\n\", *pfloat);\treturn 0;}\n\n运行的结果如下\n\n指针pfloat保留的是强制转换为float类型的int变量n\n\n准确来说，是将int指针类型强制转换为了float指针类型\n\n那打印的结果不应该是9吗？为什么是0.000000呢？\n再来看看后面的代码，我们让*pfloat=9.0，用%d打印的时候，却打印出了一串不知道怎么来的很大的数字。这又是为什么呢？\n一个涉及到的小知识点\n不管是double类型，还是float类型，默认小数点后都有6位\n我们可以用%.f的方式来控制打印，如%.3f就是只打印到小数点后3位\n\n\n答案只有一个：浮点型在内存中的存储方式和int类型完全不同！\n浮点型如何在内存中存放？根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：\n\n\n(-1)^S表示符号位，当S=0，V为正数；当S=1，V为负数。\n\nM表示有效数字，大于等于1，小于2。\n\n2^E表示指数位。\n\n\n\n\n十进制&amp;二进制的科学计数法我们在小学就学到过，1.234×10^2=123.4\n而二进制中，其实就是把底数的10变成了2，1.011*2^2=101.1\n记住以下这个结论即可\n\n二进制码M乘以2的n次方，相当于将二进制码M的小数点向右移动n位\n\nS\\M\\E如何判断？\n二进制的小数部分0.1表示十进制的0.5，即2的-1次方。根据小数点开始往右数的位数，依次为十进制2的-1、-2、-3…次方\n\n我们以5.5为例，它的二进制是101.1，带入上方提到的公式，相当于 \n\n和上面的公式比对，我们可以读出来 S=0，M=1.011，E=2\n在之前的学习中，我们知道float类型占用4个字节的空间，而double类型则是8个字节\n浮点类型的内存空间示意图\nfloat类型的S\\E\\M被分区存放在这4个字节的内存空间中\n同理，double类型的S\\E\\M也是分区存放，它的有效数字长于float类型\n对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M\n\nIEEE754对M的特殊规定因为是二进制数，1≤M&lt;2，而M可以写成 1.xxxxxx 的形式，其中xxxxxx是小数部分\nIEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分\n\n比如保存1.01的时候，只保存小数点后的01，等到读取的时候，再把第一位的1加上去\n这样做的目的是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。\n\n我在学习的时候，关于这个24位有效数字曾产生了疑惑。\n实际上它并不难理解：\n在内存中，32位浮点数的M有23位的空间，如果我们保存了小数点前面的1，就只能保存小数点后22位的内容。\n但如果我们省略1，只保留小数点后的内容，那不就能保存到小数点后第23位了吗？再加上原来小数点前的1，不就是24位有效数字了！\nIEEE754对指数E的特殊规定E是一个无符号整数(unsigned int)\n\n如果E为8位，它的取值范围是0-255\n如果E为11位，它的取值范围是0-2047\n\n可是科学计数法里面的E是可以出现负数的。\n所以IEEE754规定，存入内存时E的真实值必须再加上一个中间数\n\n8位的E，中间数是127\n11位的E，中间数是1023\n\n\n例：2^10的E是10，所以保存为32位浮点数的时候，E必须保存为10+127=137，即10001001。\n保存为64位浮点数的时候，E保存为10+1023=1033，即10000001001\n\n①当E不为全0或全1时浮点数采用下面的规则来进行存放：\n\n内存中指数E的计算值减去127(或1023)，得到E的真实值，再将有效数字M前面加上第一位的1\n\n以32位浮点数举例：\n0.5的二进制形式为0.1。科学计数法中整数部分必须为1，小数点应右移一位。\n则为1.0*2^(-1)，E的真实值为-1，存放在内存中为-1+127=126(01111110)\nM存放小数点后的0，补全23位，全为0\n这时候0.5的二进制表现形式就是\n0 01111110 00000000000000000000000\n\n对应S、E、M的部分如下表所示\n\n\n\nS\nE\nM\n\n\n\n0\n01111110\n00000000000000000000000\n\n\n②当E为全0时\n这时，浮点数的指数E等于1-127（或者1-1023）即为真实值\n有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数\n这样做是为了表示±0，以及接近于0的很小的数字\n\n③当E为全1时当E为全1时，原E为128，数字非常大，相当于无穷大\n\n这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）\n\n解释开篇代码回到开头\n整形9的原码如下\n00000000 00000000 00000000 00001001\n\n当我们将它强制存放到float类型的指针中时\n\n\n\nS\nE\nM\n\n\n\n0\n00000000\n0000000 00000000 00001001\n\n\n解码出来就是$$(-1)^00.0000000 00000000 000010012^{-126}$$这是一个很小的数字，远小于float类型默认的小数点后六位，所以printf打印的是0.000000\nint n;float* pfloat = (float*)&amp;n;*pfloat = 9.0; // 以浮点数形式存入了整形n的地址空间printf(\"num的值为：%d\\n\", n);printf(\"*pfloat的值为：%f\\n\", *pfloat);\n\n这里9.0就是以浮点数的形式存入float指针的\n\n9.0  十进制\n1001.0 二进制\n\nS=0, M=1.001, E=3二进制码0100 0001 0001 0000 0000 0000 0000 0000\n\n开启调试，在内存框中查看n的地址如下\n\n\n\n\n41\n10\n00\n00\n\n\n\n0100 0001\n0001 0000\n0000 0000\n0000 0000\n\n\n正好对应了浮点数9.0在内存中存放的二进制码\n最后n以%d整形的方式打印出来，就是我们看到的1091567616\n结语考试周快要结束啦！寒假将开始新的代码学习\n\n终于补上了之前欠下的博客了，当作是一种复习吧，的确有不少东西已经忘记的差不多了😥\n\n感谢你看到最后，点个赞再走吧！\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【C语言】整型提升和算术转换","url":"/posts/3918217186/","content":"[toc]\n整型提升要想知道什么是整型提升，那就要从表达式求值说起\n表达式求值\n表 达 式 求 值 的 顺 序 一 部 分 是 由 操 作 符 的 优 先 级 和 结 合 性 决 定\n同 样，有 些 表 达 式 的 操 作 数 在 求 值 的 过 程 中 可 能 需 要 转 换 为 其 他 类 型 \n\n什么是表达式？ 举个最简单的例子\nint main()&#123;\tint a=3;\tint b=5;\tint c = a + b * 7;\t//c的式子即为表达式\treturn 0;&#125;\n\n而C的整个式子就是一个表达式求值\n在这之中，参与计算的两个变量以及结果变量都是int类型，并不需要进行整型提升\n在我们日常编写代码的时候，编译器经常会有隐式类型转换\n\n隐式类型转换\nC的整型算术运算总是至少以缺省整型类型的精度来进行的\n为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转化为普通整型，这种转换称为整型提升\n\nfloat f =3.14int num =f;\n\n在上面这个代码中就有隐式类型转换，由float型转换为int型\n但是会有精度的丢失\n\n此时num为3\n\n\n我们知道，不同数据类型的数据大小如下\n数据类型及大小\n\n\nchar\n字符数据类型\n4byte\n\n\n\nshort\n短整型\n2byte\n\n\nint\n整型\n4byte\n\n\nlong\n长整型\n4(32), 8(64)\n\n\nlong long\n长长整型\n8byte\n\n\nfloat\n单精度浮点型（实型）\n4byte\n\n\ndouble\n双精度浮点型（实型）\n8byte\n\n\n可以看到，short类型和char类型的字节数都是小于int类型的\n当我们将一个int类型的数据存放到char中时，会发生截断\n截断&amp;提升\n把四个字节放在1个字节的内容中，截断，只保留一个字节\n把数字5放入char类型中，5的4个字节的内容会被截断\n\n示例\nchar a = 3;   //00000000000000000000000000000011 为3的二进制   //00000011 -a\n\n在char类型a中，只存放了3的后8位(1个字节)的内容\n这就是截断的表现形式\n\n在char类型数据的表达式求值中，就会发生整型提升\n规则如下：\n\n把最高位视为符号位进行提升，在a和b的8位码前加24个0或1\n\n代码示例1#include &lt;stdio.h&gt;int main()&#123;    char a = 3;    //00000000000000000000000000000011 为3的二进制    //00000011 -a    char b = 127;    //00000000000000000000000001111111 为127的二进制    //01111111 -b    char c = a + b;    //把最高位视为符号位进行提升    //在a和b的8位码前加24个0    //00000000000000000000000000000011    //00000000000000000000000001111111    //00000000000000000000000010000010    //10000010 为char c    //11111111111111111111111110000010  -补码    //11111111111111111111111110000001  -反码    //10000000000000000000000001111110  -原码    // -126    //发现a和b都是char类型的，都没有达到一个int的大小    //这里就会发生整型提升    printf(&quot;%d\\n&quot;, c);//%d是有符号数，打印原码    return 0;&#125;\n\n编译器中，负数是以补码的形式存放的\n但在使用的时候，要先转换成原码再计算其数值\n代码示例2再来看一个比较大小的示例\nint main()&#123;\tchar a = 0xb6;\tshort b = 0xb600;\tint c = 0xb6000000;\t\tif(a==0xb6)\t\tprintf(&quot;a&quot;);\tif(b==0xb600)\t\tprintf(&quot;b&quot;);\tif(c==0xb6000000)\t\tprintf(&quot;c&quot;);        return 0;&#125;\n\n猜猜打印结果是什么？\n是这个吗？\nabc\n\n错！\n\n运行后，我们会发现编译器只打印了c这个字符\n\n因为if只会比较整型\n而char和short类型都不足4个字节，在比较的时候需要进行整型提升\n提升之后的结果与原数据不同\n\n而int c本身就是整型，无须进行整型提升\nint c = 0xb6000000;\n\n所以代码只打印了字符c\n\n代码示例3再来看下面的这个代码，打印的结果是几呢？\n#include &lt;stdio.h&gt;int main() &#123;    int a = 3;   int b = 5;    short s = 5;   printf(&quot;%u\\n&quot;, sizeof(s = a + 3));        return 0;&#125;\n\n结果为2\n因为最后的s是短整型，推断出来的长度为2\n\n代码示例4 -sizeofint main()&#123;\tchar c=1;\tprintf(&quot;%u\\n&quot;,sizeof(c));//1    printf(&quot;%u\\n&quot;,sizeof(+c));//4    printf(&quot;%u\\n&quot;,sizeof(-c));//4    printf(&quot;%u\\n&quot;,sizeof(!c));//4        return 0;&#125;\n\n当+c和-c参与计算的时候，就会进行整型提升\n\n这里涉及到了另外一个重要的知识点，sizeof括号中表达式的问题\n下篇博客会详细介绍!\n\n\n算术转换说完整型提升，接下来就是和隐式类型转换很像的算术转换\n\n如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转换为另外一个操作数的类型，否则操作就无法进行。\n\n下面的层次体系称为寻常算术转换\n\n\n\nlong double\n\n\n\ndouble\n\n\nfloat\n\n\nunsigned long int\n\n\nlong int\n\n\nunsigned int\n\n\nint\n\n\n具体是怎么转换的呢?\n在进行运算的时候，如果某个操作数的类型在上表中排名较低，那么首先要转换为另外一个操作数的类型后，再执行运算。\n简单地说，就是从下往上转换\n\n注意：算术转换要合理，不然会有潜在的问题\n\n\n代码示例1下面的是一个简单算术转换的示例\n在int型和float类型一起计算的时候\nint类型会转换为float类型进行计算\n#include&lt;stdio.h&gt; int main()&#123;\tint a=3;\tfloat f =5.5;\tfloat ra =a+f;\t//算术转换，int--&gt;float \t\treturn 0;&#125;\n\n\n表达式属性这里可以引出另外一个知识点，表达式的属性\n表达式的两个属性：\n\n值属性\n类型属性\n\n如以下代码中\n\na+b的结果30就是这个表达式的指属性\n\n类型属性是int\n\n\nint main()&#123;\tint a =10;\tint b=20;\ta+b;//表达式2个属性：值属性，类型属性\t//30 值属性 \t//int 类型属性 \treturn 0;&#125;\n\n\n结语本篇博客到这里就结束了\n如果对你有帮助的话，还请点个赞再走吧！\n这对我非常重要！\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【C语言】char类型如何在内存中存储？","url":"/posts/4229898968/","content":"@[toc]\n引子上篇博客向大家介绍了int类型在内存中的存储方式【链接】\n本篇博客我们继续往后，看看整形家族里的char类型是如何在内存中存储的吧！\n\nchar类型字符类型包括以下两种形式\n\nunsigned char 无符号\n\nsigned char 有符号\n\n\n用一个简单的printf来看看它们在打印上的区别\n#include&lt;stdio.h&gt;int main()&#123;\tchar a=-1;\tsigned char b=-1;\tunsigned char c=-1;    printf(&quot;a=%d b=%d c=%d\\n&quot;,a,b,c);    \treturn 0;&#125;\n\n打印结果为\na=-1 b=-1 c=255\n\n这里我们可以得出两个结论\n\n1.在VS编译器下，char默认为signed char\n2.unsigned char的处理方式和signed不同\n\n无符号数的处理可以看我之前写的这一篇博客👉【链接】\n\n存放和提升例一：-1先写出-1的原反补码\n10000000 00000000 00000000 00000001  -1原码11111111 11111111 11111111 11111110   反码11111111 11111111 11111111 11111111   补码\n\n在内存中存放的时候，a、b、c存放的都是补码的最后一个字节，即11111111\n而当我们用%d打印的时候，会发生整型提升\n\n整型提升的概念我写过另外一篇博客👉【点我】\n\n这里就是有符号和无符号处理不同的地方了\n因为a、b都是有符号的char，所以编译器会将最高位视为符号位进行提升\n所以a、b进行整型提升后的结果如下\n11111111 11111111 11111111 11111111//提升后a、b的补码\n\n而c是无符号char类型，编译器会在最高位补0\n00000000 00000000 00000000 11111111//提升后c的补码\n\n此时最高位为0，编译器将其视为正数，此时补码就是原码，打印255\n\n符号位 0为正，1为负\n正数的原码、反码、补码相同\n\n例二：-128#include &lt;stdio.h&gt;int main()&#123;\tchar a=-128;\tprintf(&quot;%u\\n&quot;,a);\treturn 0;&#125;\n\n打印的结果并不是-128\n4294967168\n\n-128的原反补码\n10000000 00000000 00000000 10000000  -128原码11111111 11111111 11111111 01111111   反码11111111 11111111 11111111 10000000   补码\n\na中存放的是1000 0000\n最高位视为符号位，整型提升后\n11111111 11111111 11111111 10000000//新的补码\n\n但因为这里是**%u打印，视作无符号数**\n此时原反补码一致，直接视作原码进行计算\n打印结果即为4294967168\n\n如果我们让a等于128，结果相同\n\nchar变量中存放数值的范围先来看看这样一串代码\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar a[1000];\tint i;\tfor (i = 0; i &lt; 1000; i++)\t&#123;\t\ta[i] = -1 - i;\t&#125;\tprintf(&quot;%d&quot;, strlen(a));\treturn 0;&#125;\n\n代码的结果如下：255\n\n在初始化的时候，我们设定了a[1000]，a数组里面理应有1000个元素\n那strlen函数求得的结果为何是255，而不是1000呢？\n\n实际char类型中的数据范围分为有符号和无符号两种\n\nsigned char  1byte-8bit，取值范围-128~127\nunsigned char 1byte-8bit，取值范围0~255\n\n以二进制表示，如下图所示\n\n因为无符号char类型中，八位补码视作原码进行计算\n而有符号char类型中，在计算的时会将首位视为符号位\n11111111 //补码11111110 //反码，补码减110000001 //源码，读出-1\n\n10000001//补码10000000//反码11111111//首位符号位不读，其他位读出-127\n\n10000000//补码这个二进制位不能-1，直接视作源码计算不能忘记这是个负数！10000000//源码读出128，加上负号为-128\n\n下面这幅图可以形象地表示出char类型数据范围\n\nchar a[1000];int i;for (i = 0; i &lt; 1000; i++)&#123;\ta[i] = -1 - i;&#125;printf(&quot;%d&quot;, strlen(a));\n\n上面那串代码里面的for循环，实则是一直给数组a中从-1开始赋值到-128，再从127赋值到1，0……如此循环赋值，直到i&#x3D;1000跳出循环。\n而我们的strlen函数在计算数组长度的时候，遇到第一个0就会停止计算\n这样我们就得出了答案为255！\n如何查询范围定义？\n我们可以通过头文件&lt;limits.h&gt;来查找范围定义\n\n在VS2019里面右键该头文件，点击“转到文档”\n\n这里我们就能看到各种数据类型的数据范围\n\n我们还可以看看其他的数据类型\n以有符号short为例，它的范围是-32678到32767\n\n\n\n结语以一串代码示例结束本篇博客吧！\n\n感谢你看到最后！\n点个赞呗，这对我灰常重要！！😘\n","categories":["初识C语言"],"tags":["C语言","数据存储"]},{"title":"【VS】如何下载VS2019并初始化C/C++环境","url":"/posts/2731112594/","content":"1.下载，百度vs2019，去官网下载即可一定要认准官网，官网，官网！\n作为初学者的我们，下载第一个免费的community社区版本即可！\n\n2.基本配置下载CPP开发包选择适用C++的桌面开发就可以了，右侧弹出的选项不需要修改。\n\n视图开发设置选择常规，主题建议选择黑色\n\n创建项目创建项目选择空项目即可，随后键入你的项目名字，选择项目的存放路径。\n为了让你写的项目能更好的被管理，请使用一个新的空文件夹来存放你的VS项目，且该文件夹不要用中文命名。\n\n\n项目名字推荐使用日期+项目内容的全英文名，这样能看到代码是什么时候写的，以及内容是什么\n\n创建新源文件进入编辑页面后，在解决方案资源管理器中右键源文件，选择新建源文件，即可新增一个c&#x2F;cpp的代码源文件。\n\n\n\n到这里，你的vs2019就配置完成了！可以愉快地写代码了！\n3.安装插件推荐安装下面几个插件， 在vs的扩展-管理扩展里面安装\n\nCopyAsHtml 将代码内容以html格式粘贴，这样粘贴到word里面的代码是有高亮的）\nGitDiffMargin git修改将会显示在滚动栏上，vscode就自带了这个功能，vs2019装了这个插件后就也有这个功能了\nForceAllUtf8(but java) with BOM 该插件必装！否则你的代码里面的中文在其他编译器、平台里面可能会乱码！\n\n如果你的扩展商店一直加载不出来，可以去vs的官网里面下插件的.vsix文件，然后通过本地文件安装。\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】指针进阶第四站，数组/指针的传参问题","url":"/posts/3023563339/","content":"[TOC]\n朋友们，到站啦！\n指针进阶第四站🚏，传参问题\n\n0.引例自定义函数里形参的类型，要和函数调用中传过去的实参类型相对应\n\n在初阶C语言的学习里面，我们了解到传参分为传址和传值两种类型\n一起来复习一下吧👉【链接】\n\ntest函数里的是int类型，我们传过去的参数a也是int类型\nvoid test(int n)&#123;&#125;int main()&#123;    int a=1    test(a);    return 0;&#125;\n\n\n\n好了，现在你已经知道了函数传参的基本概念了😁\n那么就来分析一下数组传参、指针传参的代码吧！\n1.一维数组传参看看以下函数的代码示例\n你觉得谁是正确的，谁是错误的呢？\ninclude &lt;stdio.h&gt;void test(int arr[])&#123;&#125;void test(int arr[10])&#123;&#125;void test(int *arr)&#123;&#125;void test2(int *arr[20])&#123;&#125;void test2(int **arr)&#123;&#125;int main()&#123;\tint arr[10] = &#123;0&#125;;\tint *arr2[20] = &#123;0&#125;;\ttest(arr);\ttest2(arr2);    return 0;&#125;\n\n\nNO.1 形参使用数组的形式来接收，正确\n\nNO.2 同样是数组的形式，正确\n需要注意的是，数组传参并不会开辟一个新的数组\n所以函数[ ]里的数字是多少并不影响\n\nNO.3 数组名是首元素的地址，用指针接收，正确\n\nNO.4 arr2是一个指针数组，(int *arr[20])和原数组对应，正确\n\nNO.5 数组名是首元素地址，arr2的首元素是一个int*类型\n可以用二级指针来接收，正确！\n\n\n\n2.二维数组传参了解完一维数组了，那就来看看二维数组\n以下的函数传参，哪些是对的，哪些是错的呢？\nvoid test(int arr[3][5])//一一对应，正确！&#123;&#125;void test(int arr[][])//省略列，错误！&#123;&#125;void test(int arr[][5])//可以省略行，正确！&#123;&#125;void test(int *arr)//二维数组的首元素是第一行&#123;&#125;//第一行是int(*)[5]类型，错误！void test(int* arr[5])//指针数组，错误！&#123;&#125;void test(int (*arr)[5])//数组指针，正确！&#123;&#125;void test(int **arr)//arr不是一级指针的地址，错误！&#123;&#125;int main()&#123;\tint arr[3][5] = &#123;0&#125;;    test(arr);    return 0;&#125;\n\n根据二维数组传参的代码，复习以下知识点\n\n二维数组的首元素是第一行\n二维数组在定义的时候可以省略行，不能省略列\n\n第一行的类型是int[5]，应该放进数组指针里！\n\n3.一级指针传参#include &lt;stdio.h&gt;void print(int *p, int sz)//用int*来接受&#123; int i = 0; for(i=0; i&lt;sz; i++) &#123; printf(&quot;%d\\n&quot;, *(p+i)); &#125;&#125;int main()&#123; int arr[10] = &#123;1,2,3,4,5,6,7,8,9&#125;; int *p = arr; int sz = sizeof(arr)/sizeof(arr[0]);  print(p, sz);//一级指针p，传给函数 return 0;&#125;\n\n4.二级指针传参\n什么是二级指针？👉点我\n\n以下是二级指针传参的基本形式\npp是int**类型，而&amp;p是指针变量的地址，要用二级指针来接收\n#include &lt;stdio.h&gt;void test(int** ptr)&#123; \tprintf(&quot;num = %d\\n&quot;, **ptr); &#125;int main()&#123; \tint n = 10; \tint*p = &amp;n; \tint **pp = &amp;p;\ttest(pp);\ttest(&amp;p);\treturn 0;&#125;\n\n再来看如下代码\n&amp;p、pp、arr这三个参数的类型都是二级指针\ntest函数里面要用char**来接收\nvoid test(char** p)&#123;&#125;int main()&#123;\tchar ch = &#x27;w&#x27;;\tchar* p = &amp;ch;\tchar** pp = &amp;p;\tchar* arr[5];\ttest(&amp;p);\ttest(pp);\ttest(arr);\t\treturn 0;&#125;\n\narr是指针数组的数组名，数组名是数组首元素的地址\n数组的首元素是char*类型，所以要用二级指针来接收\n\n5.如何判断参数类型如果我们在写代码的时候，不缺定应该用什么类型来接收的时候\n可以写一个测试代码，VS编译器会报错“类型不一致”\n\n\n结语传参问题并不算非常难，但我们仍要熟练掌握\n这样才能避免在写自定义函数的时候出现参数类型不同的bug！\n\n站稳了，马上驶往下一站🚌：函数指针\n\n","categories":["初识C语言"],"tags":["C语言","数组","指针"]},{"title":"【C语言】指针进阶第三站，数组指针","url":"/posts/2538395833/","content":"[TOC]\n\n上一站🚏我们学习了指针数组\n今天来到我们的第三站🚌\n寒假也不能落下学习！\n\n今天学到了一个新的markdown语法\n我是红色\n&lt;font color=red&gt;我是红色&lt;/font&gt;\n\n\n数组指针整型指针：指向整型的指针\n字符指针：指向字符的指针\n数组指针：指向数组的指针\n1基本概念下面哪个是数组指针呢？\n\n指针数组和数组指针的概念很容易混淆，一定要分清楚哦！\n\nint *p1[10];int (*p2)[10];\n\n\np1是指针数组，每个元素的类型是int*\np2是数组指针，每个元素的类型是int(*)[10]\n\nint (*p2)[10];//p2先和*结合，表示p2是一个指针变量//指向一个大小为10个整型的数组//所以p2是数组指针\n\n注：[ ]的优先级高于*，所以必须加上()来保证p2先和*结合\n\n1.1代码示例int* parr[6];int* (*pp)[6] = &amp;parr;\n\npp是一个数组指针，类型是int*(*)[6],存放的是int*类型的数组，该数组有6个元素\n\n\n一般情况下，去掉变量名，剩下的即为变量类型\n如：int* (*pp)[6]去掉变量名pp，变量类型为int*(*)[6]\n\nchar arr[5];char (*pa)[5] = &amp;arr;\n\npa也是一个数组指针，变量类型为char(*)[5]，指向char类型的数组，该数组元素个数为5\n1.2错误示范你肯定会有一个疑问，变量类型为int(*)[5]的数组指针，能否指向数组元素为3或者6的数组呢？\n\n程序能够正常编译，但是会报出如下警告\nwarning C4048: “int (*)[5]”和“int (*)[3]”数组的下标不同\n\n在正常编写代码的时候，我们还是得保证数组指针和原数组的元素个数一致！\n2arr和&amp;arr的区别在进一步了解数组指针之前，我们需要了解arr和&amp;arr的区别\n当我们用%p打印arr和&amp;arr时，会发现它们的结果是相同的\n\n但这能说明arr和&amp;arr等价了吗？ \n并不能！\n再来看看下面这串代码\n\n\narr+1跳过4个字节，一个元素int的大小\n&amp;arr+1跳过40个字节，整个数组的大小\n\n其实&amp;arr和arr虽然指向的地址值相同，但是意义不同！\n\n&amp;arr表示的是数组的地址，是int(*)[10]类型\narr表示数组首元素的地址，是int*类型\n\n数组的地址+1，跳过整个数组的大小\n所以&amp;arr+1和&amp;arr的差值为40\n对应的int(*p)[5]和int* p1也有不同\n\np接收的是&amp;arr，整个数组的地址\np1接收arr，数组首元素的地址\n\n\n3数组指针的使用3.1打印一维数组下面这串代码是用整型指针打印数组元素的情况\n\n除了整型指针外，我们可以利用数组指针打印元素\nint main()&#123;\tint arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\tint (*p)[10] = &amp;arr;\tint i = 0;\tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, *((*p) + i));        //*p--&gt;arr\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;\n\n*p等价于arr，arr+i等价于&amp;arr[i]，对arr+i解引用就是arr[i]\n\n但是这种方式实际上是把简单问题复杂化了：我们本来就可以用int*指针来打印数组元素，为何要利用数组指针来多此一举呢？\n所以在一维数组里面，我们一般不会这么写\n\n3.2打印二维数组假设我现在需要一个print函数来打印二维数组\n在之前，我们一般会想到用这张方式传入二维数组\nvoid print(int a[3][5], int r, int c);\n\n当我们想用数组指针的时候，情况就有些变化了\n\n数组名是数组首元素的地址\n二维数组的首元素是第一行\n二维数组的数组名表示第一行的地址\n\n//main函数中print(arr,3,5);\n\n这里prinf里面的arr就需要用数组指针来接收\n该二维数组是3行5列，每一行都有5个元素，是一个int[5]的数组\n对应的数组指针为int(*)[5]类型\nvoid print(int(*p)[5], int r, int c)\n\n这里的p指针指向的是二维数组第一行的地址\n\n*p：对p直接解引用\n相当于拿道了第一行元素的地址（把第一行看作数组，也就是数组的地址）\n相当于是二维数组第一行首元素的地址\n\n\n\n对(p+i)解引用，就能拿到第i行第一个元素的地址\n*(p+i)+j第i行第j个元素的地址\n*(*(p+i)+j)第i行第j个元素\n\n\n这一部分和上篇博客指针数组的内容相似\n\n最终的函数实现如下\nvoid print(int(*p)[5], int r, int c)&#123;\tint i = 0;\tfor (i = 0; i &lt; r; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; c; j++)\t\t&#123;\t\t\tprintf(&quot;%d &quot;, *(*(p + i) + j));\t\t\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;int main()&#123;\tint arr[3][5] = &#123; &#123;1,2,3,4,5&#125;,&#123;2,3,4,5,6&#125;,&#123;3,4,5,6,7&#125; &#125;;\tprint(arr,3,5);\treturn 0;&#125;\n\n\n3.3 关于二维数组传参void fun2(int **p)&#123;    return;&#125;void test03()&#123;    int a[4]=&#123;1,2,3,4&#125;;    int b[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;    int *q[3]=&#123;b[0],b[1],b[2]&#125;;    //fun2(a);    //fun2(&amp;a);    //fun2(b);    fun2(q);&#125;\n在2022的暑假作业day02中有这么一道题目，问的是上面4种调用方式谁位合法。经过测试，只有最后一个是不报错的。\n这里涉及到了一个我之前从来没注意过的点：二维数组不能直接用二级指针接受。在上面的2.2中其实有提到，二维数组的接受需要用对应的数组指针来接受。比如 int b[3][4]对应的数组指针就是int (*p)[4]类型的。不能直接简单粗暴地用二级指针int**来接收二维数组\nvoid fun3(int (*p)[4])&#123;    return;&#125;int main()&#123;\tint b[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;\tfunc3(b);//这样才是正确的&#125;\n\n4练习：判断这一站最重要的就是区别指针数组和数组指针\n4.1 int arr[5]int arr[5];\n\narr是一个整型数组，有5个元素，每个元素是int类型的\n4.2 int*parr[10]int*parr1[10];\n\nparr1是一个数组，数组有10个int*类型的元素\n所以parr1是指针数组\n\n4.3 int (*parr2)[10]int(*parr2)[10];\n\nparr2和*结合，表示parr2是一个指针\n去掉parr2即为它的变量类型int(*)[10]\n所以parr2是一个数组指针\n\n4.4 int(*parr3[10])[5]int(*parr3[10])[5];\n\n[]的优先级高于*\nparr3先和[]结合，说明parr3是一个数组\n该数组有10个元素，每一个元素都是一个数组指针，类型是int(*)[5]\n该数组指针指向的数组有5个int类型的元素\n\n结语第三站数组指针到这里就结束啦！\n下一站🚌是：数组传参和指针传参\n敬请期待哦~\n\n如果这篇博客对你有帮助，点个赞再走吧😘\n\n","categories":["初识C语言"],"tags":["C语言","数组","指针"]},{"title":"【C语言】指针进阶第五站，函数指针","url":"/posts/2864366636/","content":"[TOC]\n\n指针进阶第五站🚏：函数指针\n点进我的主页，可以回顾前四站的内容哦~\n\n1函数指针函数也有自己的地址，函数名&#x2F;&amp;函数名 就是函数的地址\n \n1.1基本形式在数组指针的学习中我们了解到\nint arr[5];int (*pa)[5] = &amp;arr;//pa是数组指针\n\n\n指针变量pa的类型是int(*)[5]\n\n那么函数指针的形式是怎样的呢？\nvoid test(char* str)&#123;&#125;int main()&#123;\tvoid (*pt)(char*) = test;    //pt是一个函数指针\treturn 0;&#125;\n\n\npt的类型是void (*)(char*)\n\n下面哪个代码有能力存放函数的地址呢？\nvoid (*pfun1)();void *pfun2();\n\n答：pfun1可以存放\n\n\npfun1先和*结合，说明pfun1是指针，指针指向的是一个函数，指向的函数无 参数，返回值类型为void\n\npfun2先和()结合，判断为一个返回值为int*类型的函数\n\n\n\n那么，如何书写一个函数指针呢？\nint Add(int x, int y)&#123;\treturn x + y;&#125;\n\n以Add函数为例，它有两个int类型的形参，返回类型是int\n所对应的函数指针就是int(*)(int,int)类型\nint (*pf)(int, int) = Add;\n\n依据以下几步就能正确写出函数指针\n\n确定函数的返回类型\n\n确定函数的参数类型和个数\n\n把函数参数类型里的变量名去掉，放入括号里\n(int x,int y)去掉x、y，即(int,int)\n\n在前面加上函数的返回类型\n\n最后加上(*)，以及函数指针变量名\n\n\n需要注意的是，(*pf)的括号不能省略，否则编译器会报错\n\n去掉括号之后就相当于函数声明，无法赋值\n\n\n1.2用函数指针来调用函数如下图所示，当我们定义了一个函数指针后\n就可以通过指针来访问原函数\n这时候(*pf)其实就相当于my_test\n\n我们可以通过函数指针来调用上面提到过的Add函数\nint Add(int x, int y)&#123;\treturn x + y;&#125;int main()&#123;\tint (* pf)(int, int) = Add;\tint sum = (*pf)(2,3);\tint sum1 = pf(2, 3);\tint sum2 = Add(2, 3);\tprintf(&quot;%d\\n&quot;, sum);\tprintf(&quot;%d\\n&quot;, sum1);\tprintf(&quot;%d\\n&quot;, sum2);\treturn 0;&#125;\n\n可以看到，sum和sum1两种形式都正确调用了该函数\n\n因为我们已经把Add的地址转给了pf指针，函数名Add和指针pf实际上是等价的\n所以在使用函数指针的时候，可以不带*使用。但是带*的时候一定要加括号！\n1.3两个奇葩的代码奇葩代码1(*(void (*)())0)();\n\n\n这里的0仅为示例，我们在正常使用的时候并不能访问0的地址\n\n看到这个代码的时候，是不是有点懵？\n别急，让我们来慢慢分析一波！\n\n奇葩代码2void (*signal(int , void(*)(int)))(int);\n\n\n说人话就是，signal函数内传入了一个void(*)(int)的函数指针，返回值也是一个void(*)(int)的函数指针！\nvoid fun(int num)&#123;\tprintf(&quot;fun--&gt;%d\\n&quot;, num);&#125;void ( *signal( int, void(*)(int) ) )(int);int main()&#123;\tvoid(*pf)(int);//定义一个函数指针\tpf = signal(100, fun);    //为signal函数传参，并用pf指针接收\treturn 0;&#125;\n\n“这个代码2是真的奇葩，就没有什么办法把他变成人话吗？(简化一下)”\n当然有！那就是用typedef函数来给void(*)(int)指针起一个新名字！\ntypedef void(*pf_t)(int);//把void(*)(int)命名为pf_t\n\nvoid(*p)(int);//p是函数指针变量的名字typedef void(*pf_t)(int);//pf_t是一个新的类型名\n\n这样我们的代码就能得到简化\nvoid ( *signal( int, void(*)(int) ) )(int);//源代码//简化后pf_t siganal(int,pf_t);\n\n这样是不是就更容易分辨了？\n\n2函数指针数组2.1基本形式既然函数指针也是一个指针类型，那我们就可以用指针数组来存放它\n\n前提：这些函数的参数类型、返回类型一致\n\nint Add(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125;//函数指针数组int (*pfArr[4])(int, int) = &#123;Add, Sub, Mul, Div&#125;;\n\n相比于分开写多次函数调用\n//多次函数调用int (*pf1)(int,int) = Add;int (*pf2)(int, int) = Sub;int (*pf3)(int, int) = Mul;int (*pf4)(int, int) = Div;\n\n函数指针数组可以让我们以使用数组的形式来访问每个函数\nint Add(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125;int main()&#123;\tint (*pfArr[4])(int, int) = &#123;Add, Sub, Mul, Div&#125;;//函数指针数组\tint i = 0;\tfor (i = 0; i &lt; 4; i++)\t&#123;\t\t//int ret = (*pfArr[i])(8, 4);\t\tint ret = pfArr[i](8, 4);\t\tprintf(&quot;%d\\n&quot;, ret);\t&#125;\treturn 0;&#125;\n\n这样也简化了我们的代码\n2.2计算器实现2.2.1switch语句\n目的：实现一个计算器\n菜单：用数字来选择运算类型\n方法：以switch&#x2F;case语句来实现函数调用\n结束：用do&#x2F;while实现多组输入，以及结束程序\n\nint Add(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125;void menu()&#123;\tprintf(&quot;**********************************\\n&quot;);\tprintf(&quot;*****  1. add     2. sub     *****\\n&quot;);\tprintf(&quot;*****  3. mul     4. div     *****\\n&quot;);\tprintf(&quot;*****  0. exit               *****\\n&quot;);\tprintf(&quot;**********************************\\n&quot;);&#125;int main()&#123;\tint input = 0;\tint x = 0;\tint y = 0;\tint ret = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Add(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 2:\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Sub(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 3:\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Mul(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 4:\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Div(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出计算器\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n这种方式需要写非常多的重复代码，而且代码长度很长😵\n我们可以使用函数指针对它进行优化\n\n2.2.2函数指针形式int main()&#123;\tint input = 0;\tint x = 0;\tint y = 0;\tint ret = 0;\tint (*pfArr[5])(int, int) = &#123;0, Add, Sub, Mul, Div&#125;;    //pfArr是一个函数指针的数组，也叫转移表\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tif (input == 0)\t\t&#123;\t\t\tprintf(&quot;退出计算器\\n&quot;);\t\t\tbreak;\t\t&#125;\t\telse if (input &gt;= 1 &amp;&amp; input &lt;= 4)\t\t&#123;\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = pfArr[input](x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;选择错误\\n&quot;);\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n这样就避免了我们在每个case语句里都写上输入提示、scanf和不同的函数调用所导致的代码冗余了\n运行试试吧！\n\n2.3指向函数指针数组的指针函数指针数组是一个数组，数组可以用数组指针来存放地址\n\n指向函数指针数组的指针：是一个指针\n该指针指向一个数组，数组的每个元素都是一个函数指针\n\nint Add(int x, int y)&#123;\treturn x + y;&#125;int main()&#123;\tint (*pa)(int, int) = Add;//函数指针\tint (* pfA[4])(int, int);//函数指针的数组\tint (* (*ppfA)[4])(int, int) = &amp;pfA;    //ppfA 是一个指针，该指针指向了一个存放函数指针的数组\treturn 0;&#125;\n\n\n3.相关练习题\n定义一个函数指针，指向的函数有两个int形参并且返回一个函数指针，返回的指针指向一个有一个int形参且返回int的函数？下面哪个是正确的？\n&gt;A. int (*(*F)(int, int))(int)&gt;B. int (*F)(int, int)&gt;C. int (*(*F)(int, int))&gt;D. *(*F)(int, int)(int)\n\n一步步分析题目的要求\n\n该函数指针指向的函数有两个int类型，即(int,int)，ABCD都有，无法排除\n\n仔细看看，D的类型没有写全，直接排除\n\n返回一个函数指针，该指针指向一个有一个int形参且返回int的函数\nB是一个函数指针，返回类型是int，错误\nC的返回值是int*类型，错误\n\nA选项去掉函数指针F后，剩下int (*)(int)，符合题意\n\n\n\n结语函数指针的知识点是第一次接触到🧐\n你学废了吗？😂\n\n下一站🚃：回调函数\n\n","categories":["初识C语言"],"tags":["C语言","函数","指针"]},{"title":"【C语言】指针进阶终点站，回调函数和qsort","url":"/posts/175319279/","content":"[TOC]\n\n嘟嘟嘟，指针进阶的公交车到终点站🚏啦！\n这一站我们将学习回调函数、qsort的使用以及模拟实现\n\n1.回调函数\n定义：\n回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一 个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该 函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或 条件进行响应。\n\n在上篇博客函数指针数组里，提到了一个计算器的代码\n在这里就能用到我们的回调函数，通过一个新的calc函数来调用计算函数，同样达到了避免switch&#x2F;case语句重复的目的\n\n不过今天我们的学习重点的内容不在这里，而是一个全新的函数：qsort\n\n2.qsort函数qsort函数又称 快速排序函数\n2.1void*指针void* p = &amp;a;\n\n\nvoid* 是一种无类型的指针，无具体类型的指针\nvoid* 的指针变量可以存放任意类型的地址\nvoid* 的指针不能直接进行解引用操作\nvoid* 的指针不能直接进行加减整数\n\n了解了这个之后，我们再来看看qsort函数的定义\n2.2qsort函数定义\nvoid qsort (void* base, size_t num, size_t size,            int (*compar)(const void*,const void*));\n\n这些参数分别代表什么意义呢？\n\nvoid*base 是待排序数据的起始地址\n\nsize_t num 是待排序数据的个数\n\nsize_t size 是待排序数据中每个数据的大小\n\nsiez_t是专为sizeof函数的返回值设计的\n它是一个无符号整型\n\n\n\n\n\nint (*compar)(const void*,const void*)是一个函数指针\n该函数的参数为(const void*,const void*)，返回值为int\n\n在qsort的应用中，需要我们自己来编写这样一个compar函数，来判断待排序数据谁大谁小\nqsort库函数对compar函数做出了如下规定：\n\np1&gt;p2时 返回&gt;0的数\np1&#x3D;p2时 返回0\np1&lt;p2时 返回&lt;0的数\n\n\n\n\n\n为什么比较函数用的void*类型的指针?\n\n因为qsort函数并不知道你需要排序什么类型的数据，但是作为使用者，我们知道待排序的数据类型以及如何比较待排序的数据，这时候就可以将void*指针强制类型转换，变为所需要的指针！\n\n\n2.3利用qsort函数来排序int&#x2F;char首先我们建立一个待排序的整型数组，依照qsort函数的定义，将参数填入该函数\nint main()&#123;\tint arr[10] = &#123; 3,4,7,9,0,1,2,5,8,6 &#125;;\tint sz = sizeof(arr) / sizeof(arr[0]);\tint* ptr = arr;//此处可以直接用arr来代替\tqsort(ptr, sz, sizeof(arr[0]), cmp_int);        return 0;&#125;\n\n接着，我们需要来编写这个cmp_int函数，用于判断两个整型的大小\n然后把这个函数名写入qsort\n//编写一个函数比较整型int cmp_int(const void* e1, const void* e2)&#123;\treturn *(int*)e1 - *(int*)e2;&#125;\n\n运行，可以看到数据已经按照升序重新排序了！\n\n如果你想降序排序，只需要将比较函数参数里的e1和e2对调位置\n\n\n再来试试排序char字符类型吧！\n//比较字符int cmp_char(const void* e1, const void* e2)&#123;\tchar a = *(char*)e1;\tchar b = *(char*)e2;\tif (a == b)\t\treturn 0;\telse if (a &gt; b)\t\treturn 1;\telse\t\treturn -1;&#125;int main()&#123;\tchar arr1[5] = &#123; &#x27;d&#x27;,&#x27;i&#x27;,&#x27;a&#x27;,&#x27;c&#x27;,&#x27;k&#x27;&#125;;\tint sz1 = sizeof(arr1) / sizeof(arr1[0]);\tint* pc = arr1;\tqsort(pc, sz1, sizeof(arr1[0]), cmp_char);\tfor(int i = 0; i &lt; sz1; i++)\t&#123;\t\tprintf(&quot;%c &quot;, arr1[i]);\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;\n\n\n2.4用qsort排序结构体定义一个结构体，内容分别代表姓名、年龄、成绩\nstruct Stu&#123;\tchar name[20];\tint age;\tfloat score;&#125;;\n\n该结构体有char、int、float三种类型的数据，需要我们写三种对应的排序函数\n//排序成绩int cmp_stu_by_socre(const void* e1, const void* e2)&#123;\tif (((struct Stu*)e1)-&gt;score &gt; ((struct Stu*)e2)-&gt;score)\t&#123;\t\treturn 1;\t&#125;\telse if (((struct Stu*)e1)-&gt;score &lt; ((struct Stu*)e2)-&gt;score)\t&#123;\t\treturn -1;\t&#125;\telse\t&#123;\t\treturn 0;\t&#125;&#125;//按年龄排序int cmp_stu_by_age(const void* e1, const void* e2)&#123;\treturn ((struct Stu*)e1)-&gt;age - ((struct Stu*)e2)-&gt;age;&#125;//按名字排序int cmp_stu_by_name(const void* e1, const void* e2)&#123;   //用strcmp函数比较字符串\treturn strcmp(((struct Stu*)e1)-&gt;name, ((struct Stu*)e2)-&gt;name);&#125;\n\n再写一个函数来打印结构体变量\nvoid print_stu(struct Stu arr[], int sz)&#123;\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tprintf(&quot;%s %d %.2f\\n&quot;, arr[i].name, arr[i].age, arr[i].score);\t&#125;\tprintf(&quot;\\n&quot;);&#125;\n\n最后在主函数里定义结构体类型并写入qsort函数\nint main()&#123;\tstruct Stu arr[] = &#123; &#123;&quot;zhangsan&quot;,20,87.5f&#125;,&#123;&quot;lisi&quot;,22,99.0f&#125;,&#123;&quot;wangwu&quot;, 10, 68.5f&#125;,&#123;&quot;niuyeye&quot;,30,95.0f&#125; &#125;;\tint sz = sizeof(arr) / sizeof(arr[0]);\tqsort(arr, sz, sizeof(arr[0]), cmp_stu_by_name);\tprint_stu(arr,sz);\treturn 0;&#125;\n\n可以看到，我们的数据已经按照姓名排序了！\n\n\n3.模拟实现qsort函数那么，qsort函数的原理是什么呢？\n之前我们写过用于排序整型的冒泡排序\n其原理是比较数组内的a元素以及a的下一位元素，如果a大于a+1的元素，则将它们互换位置\nvoid bubble_sort(int arr[], int sz)//形参arr本质是指针&#123;\t//确定趟数\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\t//一趟冒泡排序\t\tint j = 0;\t\tfor (j = 0; j &lt; sz - 1 - i; j++)\t\t&#123;\t\t\tif (arr[j] &gt; arr[j + 1] )\t\t\t&#123;\t\t\t\t//交换\t\t\t\tint tmp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = tmp;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n有没有办法将冒泡排序给改写成通用的排序函数呢？\n思考：\n\n冒泡排序的时候，使用是int类型，int类型是4个字节，无法排序比4个字节小的数据类型\n结构体类型的大小不一定是4的整数倍，也无法用int来排序\nchar类型是1个字节，能否通过char类型来更改所有类型？\n\n答案当然是肯定的！\n在之前的指针学习里，我们了解到，尽管char*和int*类型的指针都占4个字节，但是char*类型只能访问1个字节的数据。\n我们可以利用char*指针的这个特点，对数据进行一个字节一个字节的交换，交换4次不就能交换完一个int类型了吗？同理也能通过char*的多次访问，交换其他类型的数据！\n\n既然是模拟实现qsort函数，那函数的参数应该和qsort相同\n直接把qsort函数改成my_qsort，开整！\n\n利用冒泡排序的基本框架，我们可以写出以下的代码\n//模拟实现qsortvoid my_qsort(void* base, int sz,int width, int(*cmp)(const void* e1, const void* e2))&#123;\tfor (int i = 0; i &lt; sz - 1; i++)\t&#123;\t\tfor (int j = 0; j &lt; sz - i - 1; j++)\t\t&#123;\t\t\tif (cmp((char*)base + j * width , (char*)base + (j + 1) * width)&gt;0)\t\t\t&#123;\t\t\t\tmy_swap((char*)base + j * width, (char*)base + (j+1) * width ,width);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n你可能对if里面的语句感到很懵，别急，看图！\n\ncmp就是一个回调函数，利用函数指针来调用比较函数\n\n\n再来写一个swap函数，实现字节的交换\n//用char类型的指针来一个一个地访问void my_swap(char* e1, char* e2,int sz)&#123;        //sz是待排序数据的宽度:width\tfor (int k = 0; k &lt; sz; k++)\t&#123;\t\tchar tmp = *e1;\t\t*e1 = *e2;\t\t*e2 = tmp;\t\te1++;\t\te2++;\t&#125;&#125;\n\n测试一下，成功按照成绩来排序！\n\n结语指针进阶的行程到这里就圆满结束啦！是不是感觉收获满满呢？\n\n学有余力的朋友们可以看看这一类指针笔试题👉点我\n\n到站，下车！🚍\n","categories":["初识C语言"],"tags":["C语言","函数","指针"]},{"title":"【C语言】指针进阶第一站，字符指针&typedef关键字","url":"/posts/3113579721/","content":"[TOC]\n\n紧张刺激的寒假学习开始啦！\n\n简单回顾一下指针的概念\n\n内存会划分以字节为单位的空间，每一个字节都有一个编号（地址&#x2F;指针）\n\n指针变量可以存放这个地址&#x2F;指针\n\n\n注：我们日常所说的指针，一般是指针变量\n\n下面让我们坐上指针进阶的🚌，来到第一站！字符指针\n1字符指针1.1代码示例1int main()&#123;\tchar ch = &#x27;w&#x27;;\tchar* p= &amp;ch;\t\tchar* pa = &quot;abcdef&quot;;\treturn 0;&#125;\n\n\n字符变量ch里面存放了字符w\n字符指针p里面存放了ch的地址\n\n指针变量pa里面存放了abcdef字符串的地址，我们并没有对这个字符串进行初始化。而是直接把它放进了指针变量pa里面。\n和前两行的字符w不同，abcdef是存储在内存中的只读数据区，无法修改，即便通过指针也无法修改。\n为了避免理解出错，我们一般会加上const修饰\nconst char* pa = &quot;abcdef&quot;;\n\n\n\nconst放在*的左边\n表示const修饰的指针指向的内容，表示指针指向的内容不能通过指针来改变\n但是指针变量本身是可以改变的\n\nconst放在*的右边\n表示const修饰的是指针变量本身，指针变量的内容不能被修改\n但是*pa指针指向的内容是可以通过指针来修改的\n\n\n\n\n1.2代码示例2int main()&#123;\tchar arr1[] = &quot;abcdef&quot;;\tchar arr2[] = &quot;abcdef&quot;;\tconst char* str1 = &quot;abcdef&quot;;\tconst char* str2 = &quot;abcdef&quot;;\tif (arr1 == arr2)\t\tprintf(&quot;arr1==arr2\\n&quot;);\telse\t\tprintf(&quot;arr1!=arr2\\n&quot;);\tif (str1 == str2)\t\tprintf(&quot;str1==str2\\n&quot;);\telse\t\tprintf(&quot;str1!=str2\\n&quot;);\treturn 0;&#125;\n\n它的结果如下：\n\n在例子1里面我们提到过，str1和str2这种情况都指向一个常量字符串\n既然字符串abcdef无法被改变，编译器也没有必要创建两个独立的内存空间来存放两个相同的字符串\n所以str1和str2的地址是完全一样的\n而arr1和arr2是完全不同的数组，它们的首元素地址不一样，打印的结果是不相等\n\n\n🚍第一站的距离比较短\n在站台上，我们发现了一个无人认领的袋子，里面装着一个关键字\ntypedef\n\n2typedef关键字2.1如何使用在MSDN中，我们可以查找到typedef的定义\n\n简单地说，typedef的作用就是把一个已有的类型名换一个新的名字\ntypedef int* pint;\n\n这句代码的意思是：将int*命名为pint\n\npint在使用的时候和int*完全一致\n我们仍然可以使用int*\n\n在结构体里面，我们可以用typedef来缩短原有结构体定义的语句\n如：将struct Stu命名为Stu\ntypedef struct Stu&#123;\tint ID[10];\tchar name[10];\tint age;&#125;Stu;\n\n2.2typedef和#define的区别我们同样可以使用#define语句，进行这项操作\n#define PINT int*\n\n👆定义语句PINT为int*\n2.2.1指针连续定义先来了解一下如何正确连续定义两个指针\nint*pa,*pb;//正确的连续定义int*pa，pb;//错误//pa是int*类型，而pb是int类型\n\n因为这两个的情况非常容易搞混，所以我们不建议连续定义指针\ntypedef int* pint;#define PINT int*int main()&#123;    pint pa,pb;//可连续定义指针    //pa--&gt;int*    //pb--&gt;int*    PINT pa,pb;//等同于int*pa，pb    //pa--&gt;int*    //pb--&gt;int&#125;\n\n\ntypedef会产生一个新的变量类型\n#define只是在对应位置进行替换\n\n因为typedef产生了一个新的类型，pint为int*，但与int*也有不同\nint pa,pb;//pa,pb都是int类型pint pa,pb;//pa,pb都是int*类型\n\n而我们直接用int*进行连续定义指针变量是错误的\nint*pa，pb;//错误//pa是int*类型，而pb是int类型\n\n\n你学会了吗？我反正是学废了\n嘟嘟嘟，去下一站！🚌\n","categories":["初识C语言"],"tags":["C语言","指针"]},{"title":"【C语言】转义字符","url":"/posts/3193284021/","content":"前排提醒，这不算是转义字符的教学算是个我个人学习的记录\n\n\n我们先来看下面这个代码\n#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;c:\\test\\32\\test.m&quot;);\treturn 0;&#125;\n\n问：printf中的c:\\test\\32\\test.m包含几个字符？\n\n大家可以先思考一下这个问题我们直接数的话，会得出这里面包括了17个字符如果真的有那么简单也不需要这篇博客了对吧\n这里就要引入转义字符的概念了常用的转义字符有以下几个\n比较常规的我们可以看表格中的定义\n需要注意的是”\\?”这个是用于连续问号的情况？？+（某个符号）  称为三字母词如：？？） 显示出来是 ]\\？就让？不被识别为三字母词，而显示问号这个字符同时\\\\也是让“\\”这个字符能以本身形式出现而不是被识别成转义字符同时我们要知道的是\n“\\0”这个转义字符是字符串的结束，在我们输入字符串的时候后面会默认跟着一个隐藏的“\\0”  （如图）\n我们使用strlen计算字符串abc的长度的时候需要在后面-1同时“\\0”也会有自己对应的下标3\n\n\n说回我们的c:\\test\\32\\test.m通过查表，我们能轻易地发现这里面出现了两个\\t转义字符每个转义字符在数字符长度的时候是记作一个的除了这两个\\t,这里还藏有另外一个转义字符\\32\\32这个转义字符正是图表中的\\ddd格式的转义字符代表32是一个八进制数字\n而\\32在正常代码中 是指\n32作为八进制数字对应的十进制数字，在ASCII表上对应的字符。如：八进制32是十进制的26；那么\\32就代表十进制数26在ASCII码表上对应的符号，查表可知26是替代符号\n\n\n当然，在这里我们的\\32只是一个我们想要打印出来的字符，并没有实际作用\n所以答案就很明朗了。\nint main()&#123;\tprintf(&quot;c:\\test\\32\\test.m&quot;);\treturn 0;&#125;\n在这个代码中，(“c:\\test\\32\\test.m“)一共包含的字符数量是13\n\n本篇不走心博客到这里也结束了\n\n介绍了部分转义字符的作用\n明确在计算字符数量的时候转义字符应视为同一个字符计数\n\n感谢你看到最后还是求dalao无情指正啊！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】常用的字符串函数和内存函数","url":"/posts/2065508655/","content":"[TOC]\n今天我们来学习一些新的字符串函数和内存函数，了解它们背后运行的原理，并完成部分函数的自我实现😘\n1.字符串函数1.1 strlen这个函数我们已经很熟悉了，它的作用是计算字符串的大小，以\\0作为结尾\n模拟实现如下：\n//1.strlen模拟实现int my_strlen(char* p)&#123;\tassert(p);\tint count = 0;\twhile (*p)\t&#123;\t\tcount++;\t\tp++;\t&#125;\treturn count;&#125;int main()&#123;\tchar arr[] = &#123; &quot;abcdef&quot; &#125;;\tint sz = my_strlen(arr);\tprintf(&quot;sz=%d\\n&quot;, sz);\treturn 0;&#125;\n\nassert：断言，库函数，用于判断指针是否为空，若为空会报错\n\n1.2 strcpy该函数用于拷贝字符串，将arr2里的内容拷贝到arr1里\nchar* strcpy(char * destination, const char * source );//日常使用strcpy(arr1,arr2);\n\n它有以下几个特点\n\nCopies the C string pointed by source into the array pointed by destination, including the  terminating null character (and stopping at that point).\n\n\n源字符串必须以 ‘\\0’ 结束\n会将源字符串中的 ‘\\0’ 拷贝到目标空间。\n目标空间必须足够大，以确保能存放源字符串。\n目标空间必须可修改\n\n如果源字符串里没有\\0，该函数就无法正确进行拷贝\n\nstrcpy拷贝的时候是复制而不是剪贴，源空间里的内容不会消失\n\n以下模拟实现\n需要注意的就是strcpy会将源字符串的’\\0’一并拷贝，所以在编写判断条件的时候就要考虑到这个情况\n//2.strcpy模拟实现，拷贝char* my_strcpy(char* a2, const char* a1)&#123;\tchar* dest = a2;\tassert(a1 &amp;&amp; a2);\tdo\t&#123;\t\t*a2++ = *a1;\t&#125; while (*a1++);\treturn dest;&#125;int main()&#123;\tchar arr1[] = &#123; &quot;abcdef&quot; &#125;;\tchar arr2[15]=&quot;xxxxxxxxx&quot;;\tmy_strcpy(arr2, arr1);\tputs(arr2);\treturn 0;&#125;\n\n\n1.3 strcatstrcat函数用于追加字符串，简单来说就是把两个字符串接在一起\n其函数返回值为dest\nchar * strcat ( char * destination, const char * source );//以下是使用char arr1[10] = &quot;hello&quot;;char arr2[] = &quot;bit&quot;;strcat(arr1,arr2);puts(arr1);//结果为&quot;hellobit&quot;\n\n\n源字符串必须以 ‘\\0’ 结束。\n目标空间必须有足够的大，能容纳下源字符串的内容。\n目标空间必须可修改。\n\n注意，使用strcat函数的时候不能自己追加自己，程序会死循环\n\n以下是模拟实现\n\n先让dest找到目的地字符串里的\\0\n然后进行追加，注意源字符串里的\\0同样会被追加过去\n\n//3,strcat函数char* my_strcat(char* dest, const char* sour)&#123;\tassert(dest &amp;&amp; sour);\tchar* ptr = dest;\twhile (*dest)\t&#123;\t\tdest++;\t&#125;\tdo\t&#123;\t\t*dest++ = *sour;\t&#125; while (*sour++);\treturn ptr;&#125;int main()&#123;\tchar arr1[10] = &quot;hello&quot;;\tchar arr2[] = &quot;bit&quot;;\tmy_strcat(arr1, arr2);\tputs(arr1);\treturn 0;&#125;\n\n\n1.4 strcmpstrcmp我们也是经常使用的，用于比较字符串\nint strcmp ( const char * str1, const char * str2 );\n\n该函数在比较字符串的时候，实际上是一个字符一个字符地比较的\n\n\n第一个字符串大于第二个字符串，则返回大于0的数字\n第一个字符串等于第二个字符串，则返回0\n第一个字符串小于第二个字符串，则返回小于0的数字\n\n模拟实现\n在VS编译器下，如果字符串s1大于s2，返回的是1。若小于返回的是-1。但C语言只要求大于的时候返回大于0的数字，小于的时候返回小于0的数字，所以我们可以直接用字符相减得出返回值\n//4.strcmp函数int my_strcmp(const char* str1, const char* str2)&#123;\tassert(str1 &amp;&amp; str2);\twhile(*str1 == *str2)\t&#123;\t\tif (*str1 == &#x27;\\0&#x27;)\t\t&#123;\t\t\treturn 0;\t\t&#125;\t\tstr1++;\t\tstr2++;\t&#125;\treturn *str1 - *str2;&#125;int main()&#123;\tchar arr1[] = &#123; &quot;abcdef&quot; &#125;;\tchar arr2[] = &#123; &quot;abcd&quot; &#125;;\t\tprintf(&quot;%d\\n&quot;,my_strcmp(arr2, arr1));\treturn 0;&#125;\n\n\n1.5 strncpy&#x2F;cat&#x2F;cmp以上4个库函数，都对操作数没有要求。\n而strncpy、strncat、strncmp这三个库函数，对操作数有要求\n\nstrncmp，最后一个参数4，代表只对比前4个字符的大小\n\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;\tchar arr1[] = &quot;abcwef&quot;;\tchar arr2[] = &quot;abcqqqqqq&quot;;\tint ret = strncmp(arr1, arr2, 4);\tprintf(&quot;%d\\n&quot;, ret);    return 0;&#125;\n\n\n\nstrncat，最后一个参数3，代表只追加前3个字符到目的地\nstrncpy，最后一个参数5，代表只拷贝前5个字符到目的到底\n\n\n这三个函数的用法非常简单，这里不多赘述！\n\n1.6 strstrconst char * strstr ( const char * str1, const char * str2 );      char * strstr (       char * str1, const char * str2 );\n\n这个函数就是第一次见了，它的作用是在字符串s1里面查找是否有字符串s2\n\n如果有，返回字符串s2在字符串s1里的起始地址\n如果没有，返回NULL\n\n\n模拟实现\nstr函数的模拟实现相对来说比较复杂\n最重要的就是遇到多个字符相同而最后不同的情况\n\n需要用另外一个指针C来遍历字符串，找寻C和ptr2所指元素相等的第一个字符\n然后用ptr1来和ptr2比较，C保持不变\n如果匹配成功，返回C指针\n如果匹配失败，C++后赋值给ptr1，继续进行查找\n\n\n//5.strstr 判断str1里面有没有str2//如果有，返回str1里str2的起始地址//如果str1不包含str2，返回nullchar* my_strstr(const char* str1, const char* str2)&#123;\tconst char* s1 = str1;\tconst char* s2 = str2;\tconst char* cur = str1;\tassert(str1 &amp;&amp; str2);\tif (*str2 == &#x27;\\0&#x27;)\t&#123;\t\treturn (char*)str1;\t&#125;\twhile (*cur)\t&#123;\t\ts1 = cur;\t\ts2 = str2;\t\twhile (*s1 &amp;&amp; *s2 &amp;&amp; *s1 == *s2)\t\t&#123;\t\t\ts1++;\t\t\ts2++;\t\t&#125;\t\tif (*s2 == &#x27;\\0&#x27;)\t\t\treturn (char*)cur;\t\tcur++;\t&#125;\treturn NULL;\t\t&#125;int main()&#123;\tchar arr1[15] = &#123; &quot;helloworld&quot; &#125;;\tchar arr2[] = &#123; &quot;owo&quot; &#125;;\tchar* p=strstr(arr1, arr2);\tif (p == NULL)\t&#123;\t\tprintf(&quot;找不到\\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;%s\\n&quot;, p);\t&#125;\treturn 0;&#125;\n\n\n1.7 strtok该函数用于查找一个字符串中的分隔符\nchar * strtok ( char * str, const char * sep );\n\n\nsep参数是个字符串，定义了用作分隔符的字符集合(可以包含多个分隔符)\n\n第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记\n\nstrtok函数找到str中的下一个标记，并将其用\\0结尾，返回一个指向这个标记的指针\n\n\n\n注：strtok函数会改变被操作的字符串（把分隔符改为\\0），所以在使用strtok函数切分的字符串一般都是临时拷贝的内容，并且可修改\n\n\nstrtok函数的第一个参数不为 NULL，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置\nstrtok函数的第一个参数为 NULL，函数将在同一个字符串中被保存的位置开始，查找下一个标记\n如果字符串中不存在更多的标记，则返回 NULL 指针\n\n如下如所示，在后续调用的时候，我们可以往strtok函数里传入buf，也可以直接传入NULL，因为传入NULL的时候该函数会在上一次操作的字符串里继续查找分隔符\n\n这样写很多行太麻烦，我们可以尝试用for循环的方式来简化代码\n\nfor循环的第一个表达式只会执行一次，让str&#x3D;strtok第一次查找的返回值\n如果该返回值为空（没找到更多的分隔符），停止循环\n如果该返回值不为空，就让str=strtok(NULL, p)，继续查找并打印下一部分\n\nint main()&#123;\tconst char* p = &quot;@.&quot;;\tchar arr[] = &quot;zpengwei@yeah.net&quot;;\tchar buf[50] = &#123; 0 &#125;;//&quot;zpengwei@yeah.net&quot;\tstrcpy(buf, arr);\tchar* str = NULL;\tfor (str = strtok(buf, p); str != NULL; str=strtok(NULL, p))\t&#123;\t\tprintf(&quot;%s\\n&quot;, str);\t&#125;    return 0;&#125;\n\n\n\n1.8 strerrorchar * strerror ( int errnum );\n\n\nC语言中规定了一部分错误码，这些错误码有他们对应的错误信息\n\n这个函数的作用比较特殊：将错误代码翻译成提示信息\n\nerrno是C语言提供的一个全局变量，可以直接使用，放在errno.h文件中\n当库函数使用发生错误时，会把errno这个全局的错误变量设置为本次执行库函数产生的错误码\n这时候可以用strerror函数将errno错误码翻译成错误信息\n#include &lt;errno.h&gt;//需要调用errno.h头文件printf(&quot;%s\\n&quot;, strerror(errno));\n\n\n1.9 strcasecmp这个函数的作用是比较的时候忽略大小写，注意头文件是strings.h\n#include &lt;strings.h&gt;int strcasecmp(const char *s1, const char *s2);int strncasecmp(const char *s1, const char *s2, size_t n);\n\n这里还有一个strncasecmp，作用相同，但是比较的是前n个字符\nThe strncasecmp() function is similar, except it compares the only first n bytes of s1.\n\n可以通过代码测试看出strcmp和strcasecmp两个函数的区别\nvoid test_cmp()&#123;    char str1[] = &quot;abc&quot;;    char str2[] = &quot;ABC&quot;;    printf(&quot;strcmp:     %d\\n&quot;, strcmp(str1, str2));    printf(&quot;strcasecmp: %d\\n&quot;, strcasecmp(str1, str2));&#125;\n\n运行\nstrcmp:     32strcasecmp: 0\n\n因为小写英文字母的ascii码大于大写英文字母，所以strcmp的结果大于0，而strcasecmp忽略了大小写，返回0代表二者相同\n\n2.内存函数2.1 memcpy这个函数的作用也是拷贝内容，和strcpy不同，memcpy可以拷贝任意类型\nvoid * memcpy ( void * destination, const void * source, size_t num );\n\n\n函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置\n该函数在遇到 ‘\\0’ 的时候并不会停下来\n如果source和destination有任何的重叠，复制的结果都是未定义的\n\n使用方法如下\n\n模拟实现\n在之前的qsort快速排序函数的模拟实现里面，我们接触到了void*指针，以及用char*指针来进行单个字节访问的模拟方法\n在这里我们使用void*指针进行数据的拷贝\n\n要注意的是我们不能直接对void*指针进行++，而要将其强制类型转换成char*指针后+1\n\n////1.memcpy模拟实现void* my_memcpy(void* dest, const void* sour, int num)&#123;\tassert(dest &amp;&amp; sour);\tvoid* ptr = dest;\twhile (num--)\t&#123;\t\t*(char*)dest = *(char*)sour;\t\tdest = (char*)dest + 1;\t\tsour = (char*)sour + 1;\t&#125;\treturn ptr;&#125;int main()&#123;\tint arr1[10] = &#123; 1,2,4,5,9,7,8 &#125;;\tint arr2[10] = &#123; 0 &#125;;\tmy_memcpy(arr2, arr1, 5 * sizeof(int));\tfor (int i = 0; i &lt; 5; i++)\t&#123;\t\tprintf(&quot;%d &quot;, arr2[i]);\t&#125;\treturn 0;&#125;\n\n\n2.2 memmovevoid * memmove ( void * destination, const void * source, size_t num );\n\n这个函数和memcpy的功能基本一致，只有一点不同\n\nmemmove在拷贝的时候，源地址和目的地可以重叠\n\n如图所示，我们可以将arr1数组的一部分拷贝回该数组里面\n\n但如果你测试一下，就会发现vs编译器下memcpy也是能够拷贝内存重叠的数据的\n\nC语言并没有对memcpy函数做出如下要求，部分编译器的memcpy可能就不支持这样操作\n为了避免出错，我们在拷贝内存重叠数据的时候最好使用memmove函数\n\n\n模拟实现\n在编写该函数的时候，我们需要注意拷贝的顺序\n如果重叠部分还是从前向后拷贝的时候，就会出现后面的内容被前面拷贝来的数据篡改，结果不符合要求的情况\n\n\n如果我们的目的地在源地址的后面，就应该从后向前拷贝，避免数据被改写\n\n如果我们的目的地在源地址的前面，就应该从前向后拷贝\n\n这里的前&#x2F;后都是指有重叠的情况，如果没有重叠，从前往后&#x2F;从后往前都不影响\n\n\n\n最终的函数模拟如下\nvoid* my_memmove(void* dest, const void* sour, int num)&#123;\tassert(dest &amp;&amp; sour);\tvoid* ptr = dest;\tif (dest &lt; sour)\t&#123;\t\twhile (num--)\t\t&#123;\t\t\t*(char*)dest = *(char*)sour;\t\t\tdest = (char*)dest + 1;\t\t\tsour = (char*)sour + 1;\t\t&#125;\t&#125;\telse\t&#123;\t\twhile (num--)\t\t&#123;\t\t\t*((char*)dest+num) = *((char*)sour+num);\t\t&#125;\t&#125;\treturn ptr;&#125;int main()&#123;\tint arr1[10] = &#123; 1,2,4,5,9,7,8,3,0,6&#125;;\t//1 2 4 1 2 4 5 9 0 6\tmy_memmove(&amp;arr1[3], arr1, 5 * sizeof(int));\t\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, arr1[i]);\t&#125;\treturn 0;&#125;\n\n\n2.3 memcmpint memcmp ( const void * ptr1,            const void * ptr2,  \t\t\tsize_t num );\n\n这个函数的作用是：以字节为单位进行比较\n\n模拟实现\nint my_memcmp(const void* ptr1, const void* ptr2, int num)&#123;\tassert(ptr1 &amp;&amp; ptr2);\twhile (num--)\t&#123;\t\tif (*(char*)ptr1 == *(char*)ptr2)\t\t&#123;\t\t\tptr1 = (char*)ptr1 + 1;\t\t\tptr2 = (char*)ptr2 + 1;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn *(char*)ptr1 - *(char*)ptr2;\t\t&#125;\t&#125;\treturn 0;&#125;int main()&#123;\tint arr1[5] = &#123; 1,3,5,6,8 &#125;;\tint arr2[5] = &#123; 2,4,7,9,0 &#125;;\tint arr3[5] = &#123; 1,3,4,7,9 &#125;;\tint ret1 = my_memcmp(arr1, arr3, 9);\tint ret2 = memcmp(arr1, arr3, 9);\tprintf(&quot;my_memcmp:%d\\n&quot;, ret1);\tprintf(&quot;memcmp:%d\\n&quot;, ret2);\treturn 0;&#125;\n\n运行结果\n\n\n2.4 memsetvoid * memset ( void * ptr, int value, size_t num );\n\n这个函数的作用是把内存中ptr所在位置的num个字节的内容改为value\n\n示例代码如下图所示\n\n2.5 bzero这个函数的作用是将一个地址的前n个字节设置为0，可以理解为memset的简化版本。其需要使用的头文件是strings.h，范围广于string.h\n#include &lt;strings.h&gt;void bzero(void *s, size_t n);\n\n使用方法也很简单\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;    char str[]=&quot;1234567890&quot;;    int sz = strlen(str);    printf(&quot;%s\\n&quot;,str);    bzero(str,3);//将前三个字节写为0    for(int i=0;i&lt;sz;i++)    &#123;        printf(&quot;%c&quot;,str[i]);    &#125;    printf(&quot;\\n&quot;);    return 0;&#125;\n\n可以看到，代码运行后，前三个字符没有被打印出来。这是因为0在ASCII码中是\\0，对于字符来说什么都不会打印\n\n\n3.字符串打印下面的函数都是对printf的变种，用法和printf是一样的，只不过打印的目标位置不同\n3.1 sprintfint sprintf(char *str, const char *format, ...)\n\n和printf的使用一样，只不过多了第一个参数，将printf的内容打印到一个字符数组str中\n3.2 snprintfint snprintf ( char * str, size_t size, const char * format, ... );\n\n将printf的目标设置为str字符数组，并限定size，超过size的部分会被截断（也就是最多只能打印size字节到str里面）\n3.3 fprintfint fprintf(FILE *stream, const char *format, ...)\n\n这个函数也是多了一个FILE文件指针，将printf的内容输出到文件指针中\n结语🍑今天的内容有点小多，这些函数以后我们就会经常接触啦~\n熟能生巧！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】自定义类型（详解）","url":"/posts/313651598/","content":"[TOC]\n在C语言中，有几个比较特殊的自定义类型：结构体、枚举、联合\n本篇博客，就让我们来认识一下这些自定义类型吧！😶\n1.结构体结构体是一些值的集合，结构体的每个成员可以是不同类型的变量\n1.1结构体的声明以个人信息为例，有姓名、性别、年龄、身高等几个元素。可以定义结构体如下\nstruct Stu&#123;\tchar name[20];\tchar sex[5];\tint age;\tint hight;&#125;s2, s3, s4;//s2,s3,s4全局变量\n\n1.2特殊声明在声明结构体的时候，可以不完全声明\nstruct&#123;\tchar c;\tint a;\tdouble d;&#125;sa;struct&#123;\tchar c;\tint a;\tdouble d;&#125;*ps;\n\n这两个结构体就是两个匿名结构体类型，省略了结构体标签。\n\n匿名结构体类型只能定义一次，后续无法使用\n\n这两个结构体的内容是完全一样的。\n在第二个结构体里面，定义了一个结构体指针*ps，请问这个指针能存放&amp;sa吗？\nint main()&#123;\t//编译器认为等号两边是不同的结构体类型，所以这种写法是错误的\tps = &amp;sa;\treturn 0;&#125;\n\n1.3结构体的自引用在定义结构体的时候，可以包含一个该结构体本身的成员\n//代码1-错误struct Node&#123; int data; struct Node next;&#125;;//正确的自引用方式struct Node&#123; int data; struct Node* next;&#125;;\n\n在很多时候，我们会使用typedef函数来为结构体重命名\n\ntypedef函数不能重命名匿名结构体\n\ntypedef struct&#123; int data;` Node* next;&#125;Node;//不能重命名匿名结构体//正确写法typedef struct Node&#123; int data; struct Node* next;&#125;Node;\n\n\n1.4结构体变量的定义和初始化struct Point&#123; int x; int y;&#125;p1; //声明类型的同时定义变量p1struct Point p2; //定义结构体变量p2\n\n//初始化：定义变量的同时赋初值。struct Point p3 = &#123;x, y&#125;;struct Stu        //类型声明&#123; char name[15];//名字 int age;      //年龄&#125;;struct Stu s = &#123;&quot;zhangsan&quot;, 20&#125;;//初始化struct Node&#123; int data; struct Point p; struct Node* next; &#125;n1 = &#123;10, &#123;4,5&#125;, NULL&#125;; //结构体嵌套初始化struct Node n2 = &#123;20, &#123;5, 6&#125;, NULL&#125;;//结构体嵌套初始化\n\n\n1.5结构体内存对齐结构体在内存中的存储方式比较特殊\nstruct S1&#123;\tchar c1;//1\tint i;//4\tchar c2;//1&#125;;\n\n结构体里面一共存放了6个字节的内容，按理来说，它所占的空间应该也是6个字节。\n但当我们用sizeof计算它的长度的时候，却得到了12个字节。\n\n这是为什么呢？\n\n结构体在内存中存放的时候，为了保证内存读取效率，需要进行内存对齐\n\n\n第一个成员在与结构体变量偏移量为0的地址处。 \n\n其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处\n\n\n 对齐数 &#x3D; 编译器默认的一个对齐数 与 该成员大小的较小值\n VS中默认的值为8 \n\n结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。 \n\n如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处。结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。\n\n\n\n\noffsetof函数：查看结构体成员变量相对于首地址的偏移量\n\n\n\ni变量是int类型，4个字节，默认对齐数是8，对齐数是4。C2变量是1个字节，对齐数就是1。\n\n所以int i就要从内存的4的整数倍的位置开始存放，也就是第5个字节的位置。c2在int后，在对齐数1的整数倍的位置进行存放，也就是第9个字节的位置。\n\n而结构体的总大小应该是最大对齐数（这里就是4）的整数倍，9并不是4的整数倍，所以结构体的总大小应为12个字节\n\n\n\n如图，结构体的3个成员在内存中存放并不是完全连续的。char c1和int i之间相隔了3个字节，char c2后还空出了3个字节。\n\n特殊情况：数组\nstruct Stu &#123;\tint i;    //4  4,8 - 4    char c[5];\t//5  1,8 - 1&#125;;\n\n数组在计算对齐数的时候，是看单个元素的大小，而不是看整个数组的大小。\n\nchar c[5]数组占5个字节\n计算对齐数的时候，用char类型的1个字节和8对比，对齐数是1\n\n （请忽略图中char数组的下标）\n\n\n那么为什么需要内存对齐呢？\n\n平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。\n\n性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访 问。\n\n\n\n在设计结构体的时候，我们可以把占用空间小的结构体成员尽量放在一起，这样可以减小结构体所占的空间\n\n\n1.6修改默认对齐数我们可以利用#pragma预处理指令来更改默认对齐数\n#pragma pack(1)//设置默认对齐数为1struct S2&#123; char c1; int i; char c2;&#125;;#pragma pack()//取消设置的默认对齐数，还原为默认\n\n\n\n1.7结构体传参struct S&#123; int data[1000]; int num;&#125;;struct S s = &#123;&#123;1,2,3,4&#125;, 1000&#125;;//结构体传参void print1(struct S s)&#123; printf(&quot;%d\\n&quot;, s.num);&#125;//结构体地址传参void print2(struct S* ps)&#123; printf(&quot;%d\\n&quot;, ps-&gt;num);&#125;int main()&#123; print1(s);  //传结构体 print2(&amp;s); //传地址 return 0;&#125;\n\n在结构体传参的时候，我们最好传结构体的地址。\n\n函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。\n\n\n\n2.位段位端是一种特殊的结构体\n2.1什么是位段?\n位段的声明和结构是类似的，有两个不同：\n1.位段的成员必须是 int、unsigned int 或signed int \n2.位段的成员名后边有一个冒号和一个数字。\n\nstruct A&#123; int _a:2; int _b:5; int _c:10; int _d:30;&#125;;\n\n成员名后的数字表示，该成员需要几个比特的空间来存储\n\n在结构体内，最小的成员char类型都需要1个字节的空间。但有些数据并不需要1个字节来存储，这时候就可以用位段来减少空间占用\n\nint _a:2;//2bit - 00 01 10 11 -四种情况\n\n位端的大小如下：先是开辟4个字节的空间，进行a、b、c的连续存放。存放完毕后还剩15个bit的空间，不够存放d的30个bit，所以开辟了第二个4个字节的空间，用来存放成员d\n\n\n2.2位段在内存中的存储\n位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型 \n\n位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的\n\n位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段\n\n\n\n//一个例子struct S&#123; char a:3; char b:4; char c:5; char d:4;&#125;;struct S s = &#123;0&#125;;s.a = 10;//1010-截断-010s.b = 12;//1100-完整保存-1100s.c = 3;//0011-前补0-00011s.d = 4;//0100-完整保存-0100\n\n\na和b占一个字节\nc占独立的一个字节\nd占一个字节\n\n它在内存中的存储如下图所示：\n\n2.3位段的跨平台问题在不同编译器下，位段的存储方式会有很大的不同\n\n\nint 位段被当成有符号数还是无符号数是不确定的。\n位段中最大位的数目不能确定（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题）\n位段中的成员在内存中从左向右分配，还是从右向左分配 标准尚未定义\n当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的\n\n\n跟结构体相比，位段可以达到同样的效果，还能很好的节省空间，但是有跨平台的问题存在。\n2.4位段的应用在互联网中，数据在服务器和服务器之间传递的时候，会参照以下的范式。\n图里的4位(4bit)版本号和首部长度，以及3位标志，都没有达到1个字节的大小。这时候如果用结构体来保存，就会存在较大的空间浪费，从而加大服务器的压力。\n这时候就适合采用位段来存储这样的内容，节省空间。\n\n\n3.枚举\n枚举的意思是一一列举\n\n在生活中有一些事物的类型是可以一一列举出来的（有限的）。\n比如：人的性别、星期、12个月。\n在C语言中，就可以用枚举类型来定义这种有限的元素\n3.1枚举类型的定义enum Day//星期&#123; Mon, Tues, Wed, Thur, Fri, Sat, Sun&#125;;enum Sex//性别&#123; MALE, FEMALE, SECRET&#125;；\n\n需要注意的是，枚举类型和结构体是不同的。\n\n&#123; &#125;中的内容是枚举类型的可能取值，也叫枚举常量 \n\n枚举类型代表具体的数值。默认是从0开始，以1递增。\n\n枚举类型可以用来替代数值\n\n\n比如在day的枚举类型里面，每一个元素分别代表一个数字。默认是从0开始，以1递增。\nenum Day//星期&#123; Mon,//0 Tues,//1 Wed,//2 Thur,//3 Fri,//4 Sat,//5 Sun//6&#125;;\n\n我们在定义的时候也可以赋初值\nenum Color//颜色&#123; RED=1, GREEN=2, BLUE=4&#125;;\n\n如果你只对其中一个常量赋值了，后面的常量也是以1递增的\nenum Day//星期&#123; Mon,//0 Tues,//1 Wed=5,//5 Thur,//6 Fri,//7 Sat,//8 Sun//9&#125;;\n\n3.2枚举的优点我们可以使用 #define 定义常量，为什么非要使用枚举？ \n枚举的优点： \n\n增加代码的可读性和可维护性 \n和#define定义的标识符比较枚举有类型检查，更加严谨。 \n防止了命名污染（用了&#123; &#125;封装） \n便于调试\n使用方便，一次可以定义多个常量\n\n其中第四点的内容见下图：\n\n\n3.3枚举的使用enum Color//颜色&#123; RED=1, GREEN=2, BLUE=4&#125;;//在定义完枚举常量之后，无法在外部进行更改！RED=3,//errenum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。clr = 5; //err\n\n\nenum Color里面的内容是枚举常量\nenum Color clr是一个枚举变量\n\n需要注意的是，如果你用数字给枚举变量赋值，在.c文件下不会报错，但是在.cpp文件下会报错\n\nCPP文件的语法检查更严格！\n\n\n\n那么，如何日常使用中应用枚举类型呢？\n\n在计算器的代码中👉【博客链接】\n我们可以使用枚举常量来替代干巴巴的case 0、case 1等等\n//这只是个示例//详细代码见之前的博客enum Options&#123; \tEXIT,//0 \tADD,//1    SUB,//2    MUL,//3    DIV//4&#125;;void menu()&#123;\tprintf(&quot;**********************************\\n&quot;);\tprintf(&quot;*****  1. add     2. sub     *****\\n&quot;);\tprintf(&quot;*****  3. mul     4. div     *****\\n&quot;);\tprintf(&quot;*****  0. exit               *****\\n&quot;);\tprintf(&quot;**********************************\\n&quot;);&#125;int main()&#123;\tint input = 0;\tint x = 0;\tint y = 0;\tint ret = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase ADD:         //用枚举类型代替原本的数字，增强代码可读性\t\t\tbreak;\t\tcase SUB:\t\t\tbreak;\t\tcase MUL:\t\t\tbreak;\t\tcase DIV:\t\t\tbreak;\t\tcase EXIT:\t\t\tprintf(&quot;退出计算器\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n\n4.联合体4.1联合类型的定义联合也是一种特殊的自定义类型\n这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）\n//联合类型的声明union Un&#123; char c; int i;&#125;;//联合变量的定义union Un un;\n\n当我们计算这个联合体的大小的时候，发现它只有4个字节，并不是5个字节。\n而且char c和int i元素的起始地址相同，这说明它们是公用这4个字节的空间的。\n\n4.2联合体的特点\n联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小\n（因为联合至少得有能力保存最大的那个成员）\n\nunion Un&#123; int i; char c;&#125;;union Un un;//下面输出的结果是什么？un.i = 0x11223344;un.c = 0x55;printf(&quot;%x\\n&quot;, un.i);\n\n\n4.3用联合体判断大小端\n在之前数据存储的学习中，我们了解到了什么是编译器的大小端，并写了一个函数来判断当前编译器的大小端👉链接\n\n#include &lt;stdio.h&gt;int check_sys()&#123;\tint a=1;\tchar*p=(char*)&amp;a;\tif(1==*p)\t\treturn 1;\telse\t\treturn 0;\t\t&#125;int main()&#123;\tint b=check_sys(); \tif(1==b)\t\tprintf(&quot;小端\\n&quot;);\telse\t\tprintf(&quot;大端\\n&quot;);    \treturn 0; &#125; \n\n\n将int类型地址强制转换成char*类型\n\n如果是小端，第一个地址是01\n如果是大端，第一个地址是00\n\n\n今天我们就利用联合体的成员在内存中共享同一空间的特点，来改进这个代码。\nint cheak_sys()&#123;\tunion\t&#123;\t\tchar c;\t\tint i;\t&#125;u;\tu.i = 1;//将int类型改成1\treturn u.c;//返回该类型的第一个字节&#125;int main()&#123;\tint ret = cheak_sys();\tif (1 == ret)\t\tprintf(&quot;小端\\n&quot;);\telse\t\tprintf(&quot;大端\\n&quot;);\t//如果返回1，表示小端\t//如果返回0，表示大端\treturn 0;&#125;\n\n\n使用联合体，就无需进行指针类型的强制转换\n对char c类型的定义可以覆盖掉int i的第一个字节\n\n\n4.4联合体在内存中的存储和结构体一样，联合体也需要进行内存对齐\n\n联合的大小至少是最大成员的大小\n当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍\n\nunion Un1&#123;\tchar c[5];//5  1,8 - 1\tint i;    //4  4,8 - 4&#125;;union Un2&#123;\tshort c[7];//14  2,8-2\tint i;     //4   4,8-4&#125;;\n\n需要注意的是，联合体在计算对齐数的时候，数组是按一个元素的大小进行计算，而不是以整个数组的大小进行计算！（这一点和结构体是一样的）\n\nUn2中short数组的对齐数：\n\nshort c[7]一共14个字节\n每个元素是2个字节\n默认对齐数是8\n所以它的对齐数是2\n\n\n\n以Un1为例，它在内存里的存储方式如图 (请忽略图中char数组的下标)\n\nchar c[5]和int i类型共用前5个字节（其中int i占4个字节）\n因为需要对齐到最大对齐数的整数倍，所以大小是8\n\n\n\n结语自定义类型的内容非常丰富\n你学会了吗？\n\n码字不易，若有帮助，点个赞呗！\n\n","categories":["初识C语言"],"tags":["C语言","自定义类型"]},{"title":"【C语言】文件操作（详解）","url":"/posts/1752111627/","content":"[TOC]\n好久没有更新C语言学习的博客了，今天带来的是文件部分的知识点！😋\n1.为什么需要文件？之前学习过通讯录的代码实现，可以给通讯录中增加、删除联系人。但是这个通讯录在你exe文件关闭的同时就被销毁了，它的内容并不能顺延到下一次打开这个通讯录，这对我们的使用产生了不便。\n而文件可以帮助我们实现数据的持久化：将数据保存在磁盘文件中，下次打开通讯录的时候，之前保存的联系人不会消失。\n\n\n2.什么是文件？文件就是存放在磁盘上的带特定格式的数据。\n2.1文件分类在程序设计中，一般讨论两种文件：程序文件、数据文件\n\n程序文件：代码源文件如.c，目标文件.obj/.o，可执行文件.exe\n数据文件：程序在使用过程中读写的数据，比如读取内容的文件，以及数据输出的文件\n\n这篇博客我们了解的是数据文件\n2.2文件名文件名包含3个部分：文件路径+文件名主干+文件后缀\n如：c:\\code\\test.txt\n文件标识常被称为文件名\n3.文件的使用3.1文件指针在文件操作中，非常重要的一个知识点就是文件类型指针，简称文件指针\n每个文件在开辟的时候都有一个对于的文件信息区，用于保存文件的名字、状态、当前的位置等相关信息。这些信息保存在了一个结构体中，该结构体系统声明为FILE\n不同的C语言编译器都有不同的FILE类型，但是大同小异。\n打开一个文件的时候，系统会根据文件的内容，自动创建FILE结构体变量，并填充它的信息。\n\n我们需要使用文件的时候，就可以通过一个FILE类型的指针来访问这个结构体变量\n\n3.2打开和关闭文件文件在读写之前需要打开文件，使用结束后需要关闭文件\n\n这一点和动态内存管理很相似\n\nANSIC规定用fopen函数来打开文件，fclose来关闭文件。\n打开文件的同时，会返回一个FILE*的指针变量指向该文件。\n\n关闭文件后，文件指针就变成了野指针，需要置为NULL防止错误调用\n\nfopen函数打开文件失败，会返回空指针\n#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main()&#123;    //打开文件\tFILE* pf = fopen(&quot;test.txt&quot;, &quot;r&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));//用该函数打印错误信息\t\treturn 0;\t&#125;\t//1.读文件    \t//关闭文件\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main()&#123;\t//打开文件\tFILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));//用该函数打印错误信息\t\treturn 0;\t&#125;\t//2.写文件        //关闭文件\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n\nstrerror函数在这篇博客里面有讲解👉点我\n\n3.2.1文件使用方式通过这张表格，我们可以了解一下文件使用方式的不同类型\n\n注意：使用它们用的都是双引号，而不是单引号！\n\n\n用w写入的时候，会覆盖原本已有内容。如果需要在已有内容后面追加，需要使用a\n\n3.2.2标准输入输出流\n输出：内存→文件\n输入：文件→内存\n\n\n这里还有一个小知识点：C语言程序，运行的时候会默认打开3个流\n\nstdin：标准输入流\nstdout：标准输出流\nstderr：标准错误流\n\n在执行输入输出操作的时候，之前我们是直接将内存中的数据printf打印到屏幕上\n现在我们可以通过文件指针，将数据输入到标准输出流，达到类似printf的效果\n\n3.3文件输入输出函数上述代码中，用到了fputc函数，这个函数的作用是将一个字符输入到文件中\n下表列出了一些我们会用到的文件函数\n\n3.3.1字符输入输出fputc函数：向文件中写入单个字符\n\nfgetc函数：从文件中读取单个字符\n可以看到，我们把刚刚文件中写入的字符全部打印出来了\n\n实现文件拷贝将一个文件的内容拷贝到另外一个文件中\nint main()&#123;\t//实现一个代码将data.txt 拷贝一份 生成data2.txt\tFILE* pr = fopen(&quot;data.txt&quot;, &quot;r&quot;);\tif (pr == NULL)\t&#123;\t\tprintf(&quot;open for reading: %s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\tFILE* pw = fopen(&quot;data2.txt&quot;, &quot;w&quot;);\tif (pw == NULL)\t&#123;\t\tprintf(&quot;open for writting: %s\\n&quot;, strerror(errno));\t\tfclose(pr);\t\tpr = NULL;\t\treturn 0;\t&#125;\t//拷贝文件\tint ch = 0;\twhile ((ch = fgetc(pr)) != EOF)\t&#123;\t\tfputc(ch, pw);\t&#125;\tfclose(pr);\tpr = NULL;\tfclose(pw);\tpw = NULL;\treturn 0;&#125;\n\n\n\n3.3.2文本行输入输出fputs函数：将字符串写入到文件中\n//写一行#include &lt;stdio.h&gt;int main()&#123;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;w&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\tfputs(&quot;hello world\\n&quot;, pf);\tfputs(&quot;hehe\\n&quot;, pf);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n运行代码，可以看到两行字符串已经被写入到了项目路径下的data.txt文件中\n\nfgets函数：从文件中读取规定长度的字符串\n该函数在使用的时候具有第3个参数，用于限制读取字符串的长度\n////读文件-读一行int main()&#123;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;r&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\tchar buf[1000] = &#123;0&#125;;\t//读文件\tfgets(buf, 3, pf);\tprintf(&quot;%s\\n&quot;, buf);\tfgets(buf, 3, pf);\tprintf(&quot;%s\\n&quot;, buf);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n运行程序，可以看到我们设置的是3，却只读取了2个字符出来\n\n将buf[2]更改为1，调试查看\n\n可以看到，在执行第一个fgets函数后，原本的1被写入成了\\0\n\n这就证实：fgets函数在读取字符的时候，会以\\0作为结尾\n如果我们需要读取3个字符，就需要将限制设置为4\n\n3.3.3格式化输入输出这里的“格式化”指的是结构体这种具有特定格式的数据内容\nfprintf函数：将格式化数据写入文件中\n#include&lt;stdio.h&gt;//……struct Stu&#123;\tchar name[20];\tint age;\tdouble d;&#125;;int main()&#123;\tstruct Stu s = &#123; &quot;张三&quot;, 20, 95.5 &#125;;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;w&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t//写格式化的数据\tfprintf(pf, &quot;%s %d %lf&quot;, s.name, s.age, s.d);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n\nfscanf函数：从文件中读取格式化数据，存放到对应结构体变量s中\n\n\n3.3.4二进制输入输出\nfread、fwrite可以操作任意类型的数据\n正如它的名字，二进制输入函数是将内容以二进制的方式输入到文件中\n\n\n使用该函数的时候需要使用**”rb”,”wb”**来打开文件\n\n\nfwrite(s, sizeof(struct Stu), 2, pf);//s 来源//sizeof 需要写入元素的大小//2 需要写入元素的个数//pf 写入的目标文件指针\n\n以下是写入结构体变量的例子\nstruct Stu&#123;\tchar name[20];\tint age;\tdouble d;&#125;;//二进制的写int main()&#123;\tstruct Stu s[2] = &#123; &#123;&quot;张三&quot;, 20, 95.5&#125; , &#123;&quot;lisi&quot;, 16, 66.5&#125;&#125;;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;wb&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t//按照二进制的方式写文件\tfwrite(s, sizeof(struct Stu), 2, pf);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n可以看到，此时写入的数据已经部分成了乱码。这时候它的内容已经是用二进制存放的了，txt阅读器无法正确读出这些数据\n\n二进制的读取就是复现这一步，将文本中的二进制数据以特定格式读取出来，并放入对应变量\nfread(s, sizeof(struct Stu), 2, pf);//s 存放文件内容的变量//sizeof 需要读取元素的大小//2 需要读取元素的个数//pf 读取的目标文件指针\n\n\n3.3.5 sscanf&#x2F;sprintf函数这两个函数比较特殊，它们的作用是将文件里面的格式化数据（如结构体）以字符串的形式拷贝到字符数组里面\n\n见下图\n\n\n\n3.4.其他文件函数3.4.1 fseek\nhttps://cplusplus.com/reference/cstdio/fseek/?kw=fseek\n\n该函数的作用是：将文件指针移动到相对于某个位置的特定偏移量的位置\n\n听起来有点绕口，举例说明就知道了\n\n给定一个字符串“abcdef”\n每次使用一次fgetc，文件指针就会往后进一位。使用两次，文件指针指向的是字符c\n如果我们需要指向f，就让指针\n\n从开始位置向后进5位\n从当前位置向后进3位\n从结束位置向前进1位\n\n\n我们可以用该函数，定位文件指针，将其更改到我们需要的位置，进行字符替换等操作\nint main()&#123;    FILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);    if (pf == NULL)    &#123;        printf(&quot;%s\\n&quot;, strerror(errno));        return 0;    &#125;    //写文件    int ch = 0;    for (ch = &#x27;a&#x27;; ch &lt;= &#x27;z&#x27;; ch++)    &#123;        fputc(ch, pf);    &#125;    //定位文件指针        fseek(pf, -2, SEEK_END);    fputc(&#x27;#&#x27;, pf);//将当前字符替换成#    fclose(pf);    pf = NULL;    return 0;&#125;\n\n\n3.4.2 ftell返回文件指针当前的偏移量（相对于文件开头）\n\n3.4.3 rewind\nhttps://cplusplus.com/reference/cstdio/rewind/?kw=rewind\n\n让文件指针的位置回到文件的起始位置\nfseek(pf, 0, SEEK_SET);//rewind函数与该fseek函数操作等价//但是rewind更方便\n\nint main()&#123;    FILE* pf = fopen(&quot;test.txt&quot;, &quot;r&quot;);    if (pf == NULL)    &#123;        printf(&quot;%s\\n&quot;, strerror(errno));        return 0;    &#125;    //读文件    int ch = fgetc(pf);    printf(&quot;%c\\n&quot;, ch);//a    ch = fgetc(pf);    printf(&quot;%c\\n&quot;, ch);//b        int ret = ftell(pf);    printf(&quot;%d\\n&quot;, ret);//2    rewind(pf);    //fseek(pf, 0, SEEK_SET);    ret = ftell(pf);    printf(&quot;%d\\n&quot;, ret);//0    fclose(pf);    pf = NULL;    return 0;&#125;\n\n4.文本文件和二进制文件我们现在已经知道了fread&#x2F;fwrite函数可以实现二进制的输入输出，它们是怎么具体实现的呢？\n\n根据数据的组织形式，数据文件被称为文本文件或者二进制文件。 数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。\n如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。\n在内存中，字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。\n对于数字10000，可以用下面两种方式存储\n\n1 0 0 0 0 作为5个字符来存储–占用5个字节\n以数字本身的二进制形式存储–占用4个字节\n\n这时候使用二进制的方式，就能节省空间\n\n用如下代码，将10000以二进制方式写入文件中\n\n在VS中我们可以以特定打开方式二进制编辑器打开test.txt文档\n\n可以看到10000是以二进制码的形式存放在文件中的\n\n\n这里涉及到了大小端的问题👉点我\n\n\n5.文件读取结束的判定在一般情况下，我们可以直接判断fgets/fgetc的返回值来判断文件是否读取结束。但这两个函数在文件读取错误的时候，也会返回和文件读取结束一样的结果，此时就需要判断文件是因为什么情况结束的了\n此时就需要用到两个函数，ferror和feof\n5.1 ferrorferror函数：判断文件是否出现了读取错误。\n// 来自https://cplusplus.com/reference/cstdio/ferror/int ferror ( FILE * stream );\n\n\n在函数描述里面可以看到，该函数会判断传入的文件流最近的一次文件读写是否出现了错误。其判断的是文件流中的errror indicator错误描述符。\n\n如果有，返回为真 (非0值)\n如果没有，返回0\n\n同时在函数释义里面，提到了错误会被clearerr/rewind/freopen这三个函数清除\n5.2 feof此函数用于判断文件流是否读取到了文件末尾\n// https://cplusplus.com/reference/cstdio/feof/int feof ( FILE * stream );\n\n\n\n如果遇到了文件末尾，返回非0值（真）\n如果没有遇到，返回0\n\n在函数的描述处，提到了流的内部指针可能指向的是文件结尾。但在尝试读取文件结尾之前，不一定会设置EOF指示符。这句话不是很好理解，看下图\n\n指针只有读取了文件末尾，才能知道自己已经走到了文件末尾，从而设置EOF标识符\n5.3 二者使用场景feof/ferror的先后顺序并没有特定的要求，因为它们两个的判断功能是不同的\n\nferror判断的是读取是否出现了错误\nfeof判断的是读取是否到了文件尾部\n\n依照读取退出的不同情况，可以分为下面几种类型\n\n读取成功，文件指针走到文件尾部，属于正常退出；feof能够判断出文件指针是否走到了文件尾部。\n读取失败，出现了一些错误，此时应该用ferror查看错误原因\n\n理论上而言，我们应该先用feof判断：因为读取到文件尾退出是没有问题的；\n只有feof判断没有到文件尾部，而读取函数又退出了，才需要我们用ferror进行错误的判断。\nif(feof(fp))    printf(&quot;EOF reach&quot;);else if(ferror(fp))    printf(&quot;error while readfile&quot;);\n\n实际上，这两个函数的返回值是互斥的\n\n成功读取到了文件尾部，那肯定是没出错的\n出错了，肯定没能走到文件尾部并设置EOF标识符（注意，文件指针可能已经指向了文件尾部，但出错了）\n\n所以，这两个函数的先后顺序并不会相互影响😂\n5.4 不推荐只用feof判断读取是否结束上课时，老师告诉我们，并不推荐在读取文件过程中，使用feof函数的返回值来判断文件是否读取结束，如下\nwhile(!feof(fp))//用feof的返回值判断文件是否读取结束&#123;    c = fgetc(fp);    printf(&quot;%c&quot;,c);&#125;\n\nfgetc函数本身的返回值就拥有此功能，更推荐在fgetc的循环结束后，用feof函数判断是读取失败结束，还是遇到文件结尾正常结束\n//1. 文件打开操作//2. fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOFwhile ((c = fgetc(fp)) != EOF) // 标准C I/O读取文件循环&#123;    putchar(c);&#125;printf(&quot;\\n&quot;);//3. 判断是什么原因结束的if (ferror(fp))    puts(&quot;I/O error when reading&quot;);else if (feof(fp))    puts(&quot;End of file reached successfully&quot;);\n\n但在我查阅资料的时候，看到C语言中文网站上使用了feof来判断文件是否读取结束。我感觉C语言中文网里面说的并没有啥问题，单看feof的函数作用，也确实能用来判断文件是否读取完毕。\n后来经过询问，得知老师的意思是：不能只用feof来判断文件是否正常读取结束。必须要将feof和ferror结合起来。包括上面提供的示例代码中步骤3也是同时使用了ferror和feof！\n\n5.5 文件读取判错流程5.5.1 文本文件文本文件读取是否结束，判断读取函数fgetc/fgets的返回值\n\nEOF  (fgetc)\nNULL (fgets)\n\n退出读取文件的循环后，用feof和ferror判断是否出现了错误\n\n5.5.2 二进制文件二进制文件的读取结束，则需要判断返回值是否小于实际要读的个数：\n\nfread的返回值是成功读取数据的个数，判断返回值是否小于实际要读取的个数\n如果不等于（实际上只会是小于），有两种情况\n读取失败，遇到错误\n读取完毕文件，文件中的内容没有SIZE大小\n\n\n此时的场景，适合先用feof判断是否已到文件尾部，再用ferror判断是否为文件错误\n如果feof判断已经读到文件尾部，说明是文件中的内容少于SIZE大小，应该提示文件中的数据不足SZIE字节\n如果feof判断未走到文件尾部，说明出现了错误，用ferror判断，并提示文件读取遇到错误\n\n\n\n再次说明，feof和ferror使用的先后顺序没有明确区别和硬性要求，我们只需要根据自己的场景，给错误判断加上对应的提示信息即可！\n\n6.文件缓冲区\nANSIC 标准采用“缓冲文件系统”处理数据文件。\n\n所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。\n\n这就和git一样，是先将需要push的文件放入缓存区，确认文件无误后再push到远程仓库中\n\n如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓 冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小是C编译系统（编译器）决定的。\n\n因为有缓冲区的存在，C语言在操作文件的时候，需要做刷新缓冲区或者在文件操作结束的时候关闭文 件。 如果不做，可能导致读写文件的问题。\n代码示例1#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main()&#123;\tFILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);\tfputs(&quot;abcdef&quot;, pf);//先将代码放在输出缓冲区\tprintf(&quot;睡眠10秒-已经写数据了，打开test.txt文件，发现文件没有内容\\n&quot;);\tSleep(10000);\tprintf(&quot;刷新缓冲区\\n&quot;);\tfflush(pf);//刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘）\t\tprintf(&quot;再睡眠10秒-此时，再次打开test.txt文件，文件有内容了\\n&quot;);\tSleep(10000);\tfclose(pf);\t//注：fclose在关闭文件的时候，也会刷新缓冲区\tpf = NULL;\treturn 0;&#125;\n\n运行程序，通过sleep函数暂停程序，可以看到刚开始字符串并没有存入文件中\n\n而是先写入输入缓存区，刷新缓存区后，才写入txt文件\n\n代码示例2\n#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main()&#123;\twhile (1)\t&#123;\t\tprintf(&quot;hehe\\n&quot;);\t\t//在linux环境中，不带&#x27;\\n&#x27;的时候，并不会打印（没有刷新缓存区）\t\t//而在VS环境中，带不带都会正常打印\t\tSleep(1000);//linux环境中，sleep函数的参数，单位是秒（VS是毫秒）        //             linux环境下，sleep函数需要小写，VS下是Sleep\t&#125;\treturn 0;&#125;\n\n\n在Linux环境下（树莓派）测试这个代码\n可以看到，去掉\\n后，代码并不会打印hehe\n\n编译的时候，遇到报错👇，但是程序依旧编译出来了\nimplicit declaration of function ‘sleep’\n\nCSDN查了查，发现是需要引用头文件#include &lt;unistd.h&gt;\n重新编译，没有报错了（此处hehe已经加了\\n，程序正常打印）\n\n\n结语文件章节的内容非常丰富，你学费了吗！😁\n大多数内容还是需要我们多多操作来熟悉它的真正作用\n\n如果内容有误，还请大佬无情指正！\n\n","categories":["初识C语言"],"tags":["文件","C语言","函数"]},{"title":"【C语言】动态内存管理（详解malloc/calloc/realloc）","url":"/posts/1456051952/","content":"[TOC]\n直入主题，动态内存管理！🕵️‍♂️\n1.为什么会有动态内存分配？我们一般使用以下两种方式开辟内存\nint a = 20;//在栈空间上开辟四个字节char arr[10] = &#123;0&#125;;//在栈空间上开辟10个字节的连续空间\n\n但是上述的开辟空间的方式有两个特点： \n\n空间开辟大小是固定的。 \n数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。\n\n但是对于空间的需求，不仅仅是上述的情况。有些时候，我们并不能提前知道需要的空间大小，而部分编译器并不支持变长数组。这时候以数组的方式开辟连续空间的方法就有点不适用了。\n其次，全局变量&#x2F;局部变量是存放在栈区里面的。如果存放的变量太多，就会出现栈溢出的错误\n\n这时候就轮到动态内存上场了！\n\n2.动态内存函数2.1 malloc#include &lt;stdlib.h&gt;//malloc的头文件void* malloc (size_t size);\n\n这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。\n\n如果开辟成功，则返回一个指向开辟好空间的指针。 \n如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。 \n返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。 \n如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。\n\n#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t//开辟10个整型的空间\t//int arr[10];\tint* p = (int*)malloc(40);\tif (NULL == p)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));        //这个函数在之前介绍过，用于转义错误代码\t\treturn 0;\t&#125;\t//使用\tint  i = 0;\tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\t//释放\tfree(p);\tp = NULL;\t\treturn 0;&#125;\n\n2.2 free上述代码里面出现了另外一个重要的函数，free\nfree函数用来释放动态开辟的内存，头文件是&lt;stdlib.h&gt;\n\n如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的\n如果参数ptr是NULL指针，则函数什么事都不做。\n\nfree函数不能用来释放栈区里面的空间，栈区的空间由编译器进行自动创建和自动释放\n重点！\n被free之后的指针p指向的空间已经不属于我们的应用程序了。最好在free之后立马把指针置为NULL避免访问野指针。\nfree(p);p = NULL;\n\n\n2.3 callocvoid* calloc (size_t num, size_t size);\n\ncalloc函数的功能和malloc基本一致，但是有一点不同：\n\ncalloc函数的功能是为num个大小为size的元素开辟一块空间，并且把空间的每个字节初始化为0。\n与malloc的区别只在于calloc会在返回地址之前把申请的空间的每个字节初始化为全0\n\n#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t//开辟10个整型的空间\t//int arr[10];\tint* p = (int*)calloc(10, sizeof(int));\tif (NULL == p)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t//使用\tint  i = 0;             \tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\t//释放\tfree(p);\tp = NULL;\treturn 0;&#125;\n\n添加断点并调试，可以看到calloc函数把这一块内存都初始化为0了\n\n如果这块空间需要初始化，使用calloc函数比malloc更好\n\n\n\n2.4 realloc\n该函数用于更改已经创建好的动态内存空间（可改大可改小）\n\nvoid* realloc (void* ptr, size_t size);\n\n\nptr 是要调整的内存地址 \nsize 调整之后新大小\n返回值为调整之后的内存起始地址\n这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间\n如果开辟失败，返回空指针NULL\n\n在进行扩容操作的时候，会出现两种情况：\n\n原动态内存空间之后有足够空间进行扩容\n原动态内存空间之后无足够空间\n\n如果是第一种情况，realloc函数会在这之后增添空间，分配给ptr指针。原来空间的数据不发生变化。\n如果是第二种情况，realloc会找一块新的空间，开辟好后返回给ptr指针，并把原空间里的数据移动到新空间的对应位置。\n\n情况2的时候，开辟完新空间之后，会把原来的空间给free掉(只有开辟成功才会释放原来的空间)\n\n\n#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t//开辟10个整型的空间\t//int arr[10];\tint* p = (int*)calloc(10, sizeof(int));\tif (NULL == p)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t//使用\tint  i = 0;\tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\t//需要增容 - 80\tint*ptr = (int*)realloc(p, 80);\tif (NULL != ptr)\t&#123;\t\tp = ptr;\t\tptr = NULL;\t&#125;\t//继续使用了\t\t//释放\tfree(p);\tp = NULL;\treturn 0;&#125;\n\n几点注意：\n\nrealloc(p, 80) 80指的是开辟之后新的空间大小为80，而不是增加80的空间\nrealloc函数可能开辟失败，这时候如果将开辟失败的返回值NULL赋值给了原有指针p，就很危险。\n采用中间指针变量ptr，先判断realloc函数是否开辟成功，若成功，则赋值给p指针。\n赋值给p之后ptr指针就没用了，置为空指针。\n\n\n最后我们不需要对ptr进行free，因为ptr的指向和p是一样的\nfree(p)的时候，ptr所指向的空间也被free掉了\n\n\nrealloc缩小空间的时候，会把原来空间后面的内容都剔除\n\n\n3.常见错误3.1对NULL指针的解引用void test()&#123;  int *p = (int *)malloc(INT_MAX/4);  *p = 20;//如果p的值是NULL，就会有问题  free(p);&#125;\n\nINT_MAX是int类型的最大值，可以在头文件limits.h里面查询并使用\n3.2对动态内存空间的越界访问和数组一样，动态内存空间也是不能越界访问的！\nvoid test()&#123; int i = 0; int *p = (int *)malloc(10*sizeof(int)); if(NULL == p) &#123; exit(EXIT_FAILURE); &#125; for(i=0; i&lt;=10; i++)//应该是i&lt;10 &#123; *(p+i) = i;//当i是10的时候越界访问 &#125; free(p);&#125;\n\n3.3对非动态内存空间进行freevoid test()&#123; int a = 10; int *p = &amp;a; free(p);//err&#125;\n\n3.4使用free释放动态内存空间的一部分void test()&#123; int *p = (int *)malloc(100); p++; free(p);//p不再指向动态内存的起始位置&#125;\n\n\n需要用一个指针来记住起始地址，用另外一个指针来进行赋值等操作\n\n3.5对一个空间进行重复释放void test()&#123; int *p = (int *)malloc(100); free(p); free(p);//重复释放&#125;\n\n在free之后立马把p置为空指针，就能避免这个问题\n\nfree函数接收空指针，不做任何操作\n\n3.6内存泄漏如果忘记释放动态内存开辟的空间，就会导致内存泄漏\nvoid test()&#123; \tint *p = (int*)malloc(100); \tif(NULL != p) \t&#123; \t\t*p = 20; \t&#125;    //没有释放p的空间&#125;int main()&#123; \ttest();\twhile(1);&#125;\n\n一般情况下，谁使用就谁释放。函数里使用就在函数里释放，除非需要传回主函数进行操作。\n\n如果没有传回主函数，也没在函数里进行释放，该指针变量已经被销毁了，无法进行释放操作！\n\n如果主函数里程序没有结束，就造成了内存浪费\n\n4.C&#x2F;C++程序中内存区域划分\n栈区（stack）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。\n\n堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。\n\n数据段（静态区）（static）存放全局变量、静态数据。程序结束后由系统释放。\n\n代码段：存放函数体（类成员函数和全局函数）的二进制代码。\n\n\n\n有了这幅图，我们就可以更好的理解在《初识C语言》中讲的static关键字修饰局部变量的例子了。实际上普通的局部变量是在栈区分配空间的，栈区的特点是在上面创建的变量出了作用域就销毁。但是被static修饰的变量存放在数据段（静态区），数据段的特点是在上面创建的变量，直到程序结束才销毁，所以生命周期变长\n\n\n\n结语动态内存其实就是数组的高级形式，它能让我们更方便的管理开辟的连续的空间。\n你学废了吗？🤤\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】程序运行过程：预处理/编译/汇编/链接","url":"/posts/4253775162/","content":"[TOC]\n哈喽啊，盆友们。一起来看看C语言中编译预处理的内容吧！😜\n1.程序运行的几个阶段众所不周知，C语言的程序运行分为几个阶段。\n咱们可以看看下面这个图，简单了解一二👇\n\n细分开来，编译还分为3个小阶段：预编译（预处理）、编译、汇编\n\n这三个阶段又分别做了什么事情呢？这就需要我们用linux下的gcc编译器来验证了\n1.1预编译现在我们编写了一个这样的代码\n\n\n在运行窗口中输入以下指令，进行预编译操作，得到test.i文件\ngcc -E test.c -o test.i\n\n\n打开该文件，滑倒最底部，查看它与源代码的不同\n\n可以发现以下几点：\n\n头文件消失：实际上被展开了\n注释被删除\ndefine定义的符号被替换\n\n这就是预编译阶段做的3件事，实际上都是一些文本操作，并没有运行该代码\n1.2编译输入以下指令，生成test.s文件\ngcc -S test.i -o test.s\n\n\n打开该文件，发现我们好像看不太懂它里面写了些什么\n\n实际上，mov、sub都是汇编语言，这一步就是把C语言代码转变成了汇编代码。 进行了以下几步操作：\n\n语法分析\n词法分析\n语义分析\n符号汇总\n\n\n\n这一部分内容可以阅读《程序员的自我修养》这本书，记录一下\n\n1.3汇编gcc -c test.s -o test.o\n\n\n这个指令会生成一个test.o目标文件\n\nLinux：目标文件后缀为.o\nWindows：目标文件后缀为.obj\n\n\n.o目标文件和可执行成句的文件格式elf\nreadelf工具可以解析elf格式的文件\n\n用文本编辑器打开这个文件，可以看到里面的东西都是乱码\n\n实际上这个文件里面存放的是二进制内容。\n汇编操作就是将汇编代码转换成二进制指令\n其中有非常重要的一部：形成符号表\n1.4符号表和链接这个代码中其实包含了两个源文件：test.c 、Add.c\n\n里面出现了两个符号，main和Add\n编译器会先对每个源文件创立一个符号表，为它们添加一个类似地址的参数。在链接阶段的时候，相同符号的地址参数会被设置为一样的\n\n这里编译会查看Add函数的定义在哪里\n如main函数中只是extern，并没有Add的具体实现，最后链接之时，Add符号的地址会被设置为Add.c中该符号的地址\n\n这个操作又叫：符号表的合并和重定位\n链接阶段还会执行另外一个操作：合并段表\ngcc test.o add.o -o test//生成可执行程序test\n\n\n使用./TEST操作执行该文件，可以看到程序成功输出了Add后的答案\n\n\n2.运行环境程序执行的过程中：\n\n程序先载入内存。在操作系统中，这个操作由系统完成；在独立环境中，程序的载入必须手动完成，也可以是通过可执行代码置入只读内存来完成\n程序执行开始。调用main函数\n开始执行代码。这时将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时使用静态内存，存储于静态内存中的变量在程序的整个执行过程中保留它们的值\n终止程序。正常终止main函数，也可能是意外终止\n\n\n结语本篇博客中，我们认识了解了程序运行的几个阶段。这里面还有很多更深层次的问题待我去探究。\n\n下篇博客：预处理详解\n\n点个赞再走呗，谢谢！\n","categories":["初识C语言"],"tags":["C语言","编译"]},{"title":"【C语言】指针进阶第二站，指针数组","url":"/posts/2460304186/","content":"[TOC]\n嘟嘟嘟🚌，指针进阶的第二站指针数组到了！\n上车上车！\n\n回顾一下第一站🚍的内容：字符指针\n\n\n指针数组数组是一种类型的数的集合\n\n整型数组的元素都是int类型\n指针数组的元素都是指针变量\n\nint* arr1[10];//整型指针的数组char*arr2[10];//一级字符指针的数组char** arr3[5];//二级字符指针的数组\n\n参考这一份示意图\n\n示例1:定义多个字符指针在上一站的字符指针里面，提到了可以直接用指针来创建一个常量字符串\n同理，我们可以将多个指针放在一块，凑成指针数组，一次性创建多个指向常量字符串的指针\n\nint main()&#123;\tchar* arr[] = &#123; &quot;abcdef&quot;, &quot;qwer&quot;, &quot;zhangsan&quot; &#125;;\tint i = 0;\tint sz = sizeof(arr) / sizeof(arr[0]);\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tprintf(&quot;%s\\n&quot;, arr[i]);\t&#125;\treturn 0;&#125;\n\n示例2:存放数组名的数组在之前的学习中，我们知道：数组名代表数组首元素的地址\n可以说，数组名本质上也是一个指针\n既然是指针，就能放进指针数组里面\nint main()&#123;\tint arr1[] = &#123; 1,2,3,4,5 &#125;;\tint arr2[] = &#123; 2,3,4,5,6 &#125;;\tint arr3[] = &#123; 3,4,5,6,7 &#125;;\tint* arr[] = &#123;arr1, arr2, arr3&#125;;\t//arr是指针数组\tint i = 0;\tfor (i = 0; i &lt; 3; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; 5; j++)\t\t&#123;\t\t\tprintf(&quot;%d &quot;, arr[i][j]);//*(*(arr+i)+j)\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\treturn 0;&#125;\n\n这串代码中，我们需要了解的是arr[i][j]和*(*(arr+i)+j)之间的关系\n\n以下内容，我的理解可能有偏差。若有错误，还请大佬们无情指正！\n\n\narr[i][j]和*(*(arr+i)+j)\n它们都是访问数组的形式，用到了不同的操作符\n但表达的含义相同：下标为i、j的元素\n\n在内存中，数据的存储是连续的\n创建一个二维数组，可以看到两行的数据是连续存放在数组里面的\nint arr4[2][2]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;\n\n\n既然是连续的，我们就可以用指针++的形式来访问二维数组里面的所有元素\n\n\n*(arr+i)指向第i行元素\n*(arr+i)+j指向第i行下标为j的元素的地址\n*(*(arr+i)+j)再次解引用，得到j元素\n\n\n数组名的本质是地址，是该数组首元素的地址\n二维数组的首元素是第一行，数组名arr就是第一行的地址\n我们可以把二维数组的每一行理解为独立的一个一维数组\n这时候，二维数组的形式和上述代码中int* arr[]数组的形式就相同了\nint arr1[] = &#123; 1,2,3,4,5 &#125;;int arr2[] = &#123; 2,3,4,5,6 &#125;;int arr3[] = &#123; 3,4,5,6,7 &#125;;//arr1 arr2 arr3是二维数组里面的每一行int* arr[] = &#123;arr1, arr2, arr3&#125;;//arr等价于一个二维数组，但有不同\n\n因此，我们可以用二维数组访问的形式来访问int* arr[]数组\n\nint* arr[]和二维数组的不同int*arr数组里的元素arr1，arr2，arr3的地址是连续存放的\n\n这里设计到一个新概念：数组指针\n将在下一站🚌讲解！\n\n\n但是它们对应的各自的数组内数据并不连续\n如：arr1和arr2这两个数组各自元素的地址并不连续\n\n\n示例3：存放二级指针的数组既然一级指针可以放进数组里，二级指针也是指针，同样也能塞进数组里\n下面这串代码里面的arr2就是一个存放二级指针的数组\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint* p = &amp;a;\tint** pp = &amp;p;\tint** arr2[4] = &#123;pp&#125;;\treturn 0;&#125;\n\n\n结语🚍第二站的路程到这里就结束了！\n敬请期待下一站的数组指针航程吧！\n\n如果你对博客内容有疑问，欢迎在评论区提出哦，万分感谢！\n\n","categories":["初识C语言"],"tags":["C语言","数组","指针"]},{"title":"【C语言】函数调用的参数压栈（详解）","url":"/posts/3810457843/","content":"[TOC]\n前言在早期的学习中，我们已经了解到当函数传值调用参数的时候，用的是形参。\n形参是实参的一份临时拷贝，对形参的改变不会影响实参里的值。\n\n传值调用和传址调用👉点我\n\n今天让我们以汇编语言来了解函数调用的参数压栈这一知识点\n所用编译器：VS2019\n\n不同编译器的实现可能略有不同，以实际为准\n\n\n1.什么是栈区？栈，是一种数据结构。\n在学习C语言的过程中，我们一般只关注内存中的3个区域，分别是栈区、堆区和静态区。\n其中堆区主要用于动态内存管理，在之前的博客中已经和大家介绍过。\n\n详解动态内存管理👉点我\n\n\n而栈区就是编译器给函数运行分配的空间了。\n和堆区空间需要手动分配不同，这一部分空间是编译器自动管理的，函数的栈帧会自动创建，自动销毁。\n1.1栈区小知识点\n栈区的使用是从高地址到低地址\n栈区的使用遵循先进后出，后进先出\n栈区的放置是从高地址往低地址放置：push压栈\n删除是从低往高删除：pop出栈\n\n\n2.知识点//本次使用的代码#include &lt;stdio.h&gt;int Add(int x, int y)&#123;\tint z = 0;\tz = x + y;\treturn z;&#125;int main() &#123;\tint a = 10;\tint b = 20;\tint c = Add(a, b);\tprintf(&quot;%d\\n&quot;, c);\t\treturn 0;&#125;\n\n2.1 寄存器常见寄存器有eax、ebx、ecx、edx，其中ebp和esp较为特殊\n\nebp、esp这两个寄存器中存放的是地址，这两个地址是用来维护函数栈帧的\n\n\neax&#x2F;ebx&#x2F;ecx&#x2F;edx：通用寄存器，保留临时数据\nebp：栈低指针\nesp：栈顶指针\neip：指令寄存器，保存当前指令的下一条指令的地址\n\n\n2.2 主函数调用每一个函数调用，都要在栈区创建一个空间\n我们知道main函数是程序的入口\n实际上，main函数也是被其他函数调用的\n\nmainCRTStartup函数调用__tmainCRTStartup\n__tmainCRTStartup函数调用main函数\n\n编译器会先在内存高地址处开辟一部分空间给mainCRTStartup和__tmainCRTStartup函数，它们进行调用main函数的操作。\n\n在VS2019中，按F10进行调试，出现黄色小箭头后，右键-转到反汇编，即可打开调试中汇编语言的显示界面\n\n3. 逐条解释3.1 从main开始先来看第一部分代码，逐条语句进行解释\npush  ebp//在栈顶开辟存放ebp这一寄存器对应值的空间mov  ebp,esp//将esp的值传入ebp中（即将ebp指针移动到原本esp指向的位置）sub  esp,0E4h//将esp的内容减去0E4h（将esp移动到原esp-0E4h的位置）push ebx//在栈顶放入ebxpush esi//在栈顶放入esipush edi//在栈顶放入edi\n\n\n\nlea：load effecticve address 加载有效地址\ndword：double word – 4个字节\n\nlea  edi,[ebp-24h]//将ebp-24h的地址放入edimov  ecx,9//将9放入ecx，对应十进制36mov  eax,0CCCCCCCCh//将0CCCCCCCCh放入eaxrep stos  dword ptr es:[edi]//将edi往下ecx个地址的数据全部初始化为0CCCCCCCCh\n\n按F10往下运行，过rep那一步后，可以看到36个字节的数据都被初始化为0CCCCCCCCh\n\n\n继续往下运行，可以看到编译器初始化a、b变量的过程\n\n\n\nVS2019下是小端存储\n\n\n\n\tint c =Add(a,b);mov    eax,dword ptr [b]//把b的内容放入eaxpush   eax  //在栈顶放入eaxmov    ecx,dword ptr [a]//把a的内容放入ecxpush   ecx  //在栈顶放入ecxcall   _Add (01A10B4h) //在栈顶放入该地址（call指令下一条指令的地址） \n\n最后这一步call很关键，后续会用到\n\n3.2 调用Add按F11，进入Add函数\n\n\npush    ebp//将ebp上移mov     ebp,esp//将esp内容放入ebp（移动ebp）sub     esp,0CCh//esp+0CCh（为Add开辟空间）push    ebx//在栈顶放入ebxpush    esi//在栈顶放入esipush    edi//在栈顶放入edi\n\nlea      edi,[ebp-0Ch]//ebp-0Ch的空间  mov      ecx,3//3存入ecx  mov      eax,0CCCCCCCCh//存入eax  rep stos  dword ptr es:[edi]//esp往下0ch的空间初始化mov      ecx,offset _6A27082D_test@c (024C003h)  call     @__CheckForDebuggerJustMyCode@4 (024131Bh)\n\n\n\n继续往下，寄存器初始化了Z地址处的数据 为0\n\nmov    eax,dword ptr [x]//将x的值放入eaxadd    eax,dword ptr [y]//将y的值加道eax中，即x+y   mov    dword ptr [z],eax//将eax的值放入变量z\n\n\n\treturn z;mov    eax,dword ptr [z]//将形参z的值放入eax \n\n\npop     edi//出栈，删除为edi创建的栈区pop     esi//pop指令会将esi的值放入esi（等于没变）  pop     ebx//每pop一次，esp就往高位移动一次      add     esp,0CCh//为esp地址+0CCh，即退出Add程序的栈区空间 cmp     ebp,esp//将esp的值与ebp进行比较\n\n\ncall        __RTC_CheckEsp (0241244h)  mov         esp,ebp//ebp的值赋给esp，此时esp和ebp相同\n\n\npop         ebp//弹出ebp  \n\n这里执行弹出指令时\n\n将ebp所指向的main函数的起始地址赋值给了ebp指针\nesp指针向高位移动一位\n\n最后的结果如下图所示，esp和ebp重新开始维护main函数的栈区空间\n\n3.3 回到main函数ret  \n\n前面提到call   _Add (01A10B4h)这条指令非常重要，实际上，在执行ret指令时，esp指针就指向了栈顶存放的call指令的下一条指令的地址，同时，这个地址也被pop掉了\n\n回到调试界面，可以看到黄色小箭头的确指向了call指令的下一条\n\n而这一条指令的意思，是往esp里加8，即向高位移动8个字节。\n实际上这条指令就是在销毁我们的形参\n\nmov      dword ptr [c],eax//将eax中的值放入变量c  \n\n此时eax中存放的就是Add函数的返回值\n\n这里我们可以得出一个结论：\n自定义函数的返回值是通过寄存器这一中间“变量”，返回主函数中的。\n\n先把返回值放入寄存器A\n主函数从寄存器A中取出返回值，放入接受返回值的变量\n\n\n继续往下，可以看到printf(&quot;%d\\n&quot;, c);语句后，编译器又一次将变量c的值放回了eax\n实际上这里是printf函数的运行：\n\n先把待打印变量放入eax\n在栈顶压入eax\noffset string &quot;%d\\n&quot;（猜测是数据类型检查）\n_printf ：执行printf函数\n\n\nadd  esp,8//给esp+8个字节\n\n我对这一部分产生了疑惑，重新调试发现\n\npush eax这一指令让esp往低地址处走了4个字节\noffset string &quot;%d\\n&quot;这一指令也让esp往低走了4个字节\n\n\n执行完这一指令后，esp回到了执行printf之前的地址处\n\n3.4 结束程序\treturn 0;xor    eax,eax//xor指令是异或--在这里的作用不清楚&#125;pop    edi//出栈--esp对应移动  pop    esi//  pop    ebx//  \n\n\nadd    esp,0E4h//esp+0E4h（退出为main函数开辟的空间） cmp    ebp,esp//比较ebp和esp  \n\n\n\ncall   __RTC_CheckEsp (0241244h)  mov    esp,ebp//将ebp的值复制给esp //此时esp和ebp的值依旧相同    \n\n\npop    ebp//ebp出栈--esp和ebp分离ret//main函数结束  \n\n\n\n4.本篇博客中的汇编语言总结\nmov：数据转移指令\n\npush：数据入栈，同时esp栈顶寄存器往低位走\n\npop：数据弹出至指定位置，同时esp栈顶寄存器往高位走\n\nsub：减法\n\nadd：加法\n\ncall：函数调用。1.压入返回地址；2.转入目标函数\n\njump：通过修改eip，转入目标函数，进行调用\n\nret：回复返回地址，压入eip，类似pop eip指令\n\ncmp（比较）：执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数\n\nxor：在两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，并将结果存放在目标操作数中\n\n\n\n部分汇编指令参考：C语言中文网\n\n\n5.结语\n完成这篇博客的时候，已经是周六的00:54🌛\n从周五的19:20开始，不知不觉中写了这么久\n\n函数调用堆栈这一部分的知识有些晦涩难懂，写下这篇博客也算是理清了一些思路吧。\n加油！\n顶不住了，睡觉去了\n\n说来讽刺，几个舍友还在打某3亿鼠标的枪战梦想……\n\n","categories":["初识C语言"],"tags":["C语言","编译"]},{"title":"【C语言】预处理操作（详解）","url":"/posts/3942304404/","content":"[TOC]\n前言😜上篇博客，我们提到了C语言程序运行的几个环节。\n本篇博客中提到的预处理指令，就是在预处理阶段运行的一些代码。\n\n本篇博客使用的编译器🎰\n\nVS2019（win10）\n树莓派（linux-gcc）\n\n\n\n1.预定义符号__FILE__ //进行编译的源文件__LINE__ //文件当前的行号__DATE__ //文件被编译的日期__TIME__ //文件被编译的时间__STDC__ //测试编译器是否遵循ANSI C，遵循值为1，不遵循则该符号未定义\n\n\n2.#define2.1定义标识符#define name stuff\n\n#define MAX 1000#define reg register   //为 register这个关键字，创建一个简短的名字#define do_forever for(;;)  //用更形象的符号来替换一种实现#define CASE break;case    //在写case语句的时候自动把 break写上//如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。#define DEBUG_PRINT printf(&quot;file:%s\\tline:%d\\t \\                           date:%s\\ttime:%s\\n&quot; ,\\                        __FILE__,__LINE__ ,       \\                        __DATE__,__TIME__ )  \n\n加分号问题define定义标识符的时候，最好不要在结尾加上;\n#define MAX 1000;#define MAX 1000\n\n\n2.2定义宏\n除了定义标识符以外，define还可以定义一个语句为标识符，允许把参数替换到文本中。这种机制叫做定义宏\n\n下面是宏的申明方式： \n#define name(parament-list)  stuff \n\n其中的parament-list是一个由逗号隔开的符号表，它们可能出现在stuff中\n\n参数列表的左括号必须与name紧邻。 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分\n\n//如#define DOUBLE(x) x+x\n\n宏需要注意的问题这个宏有一个问题👇\n#define DOUBLE(x) x+xint main()&#123;\tprintf(&quot;%d\\n&quot;, 10*DOUBLE(3));\treturn 0;&#125;\n\n这个式子输出的结果是什么呢？是60吗？\n答案是否定的：#define宏在使用的时候执行的是直接替换\n这个语句就相当于10*3+3，根据操作符优先级可知，结果为30+3&#x3D;33\n\n想解决这个问题，我们需要记住这个原则：\n\n给变量加上括号以确保优先级\n给整个宏再加上一个括号防止外部数据影响\n\n#define DOUBLE(x) ((x)+(x))\n\n再运行程序，发现答案变成了60\n\n\n用于对数值表达式进行求值的宏定义，都应该用这种方式加上括号。避免在使用宏时，参数中的操作符或邻近操作符之间产生不可预料的相互作用\n\n2.3define替换规则\n2.4使用#和##2.4.1#将字符串插入字符串int main()&#123;\tint a = 3;\tint b = 5;\tprintf(&quot;the num of a is %d\\n&quot;, a);\tprintf(&quot;the num of b is %d\\n&quot;, b);\tprintf(&quot;\\n&quot;);        return 0;&#125;\n\n\n在这个代码里面，打印的前置内容a和b需要根据打印的变量进行更改\n有没有一种办法，可以让他自己进行更改？\n#define PRINT(X) printf(&quot;the num of &quot;#X&quot; is %d\\n&quot;, X)int main()&#123;\tint a = 3;\tint b = 5;\tprintf(&quot;the num of a is %d\\n&quot;, a);\tprintf(&quot;the num of b is %d\\n&quot;, b);\tprintf(&quot;\\n&quot;);\tPRINT(a);\tPRINT(b);\treturn 0;&#125;\n\n可以看到，#X处的内容被替换成了我们需要打印的变量\n\n实际上，这里#X旁边的双引号，是将整个字符串拆分成了3份进行打印\n\n“the num of”\n#X\n“is %d\\n”\n\n字符串在打印的时候具有自动拼接的特性，所以我们可以通过这种方式将一个需要更改的字符插入到字符串中\n2.4.2## 将两个符号合并\n##可以把位于它两边的符号合成一个符号。 \n它允许宏定义从分离的文本片段创建标识符。\n\n如图，这个宏将Class和10两个分离的符号合并成了Class10，printf识别出来并打印的了Class10的值\n\n当我们同名变量有很多的时候，就可以利用这种宏来给不同的变量增加数据。\n#define ADD_TO_SUM(num, value) sum##num += value;int sum1,sum2,sum3,sum4;ADD_TO_SUM(3, 10);//给sum3增加10.\n\n这样的连接必须产生一个合法的标识符，否则其结果就是未定义的。\n\n2.5带副作用的宏参数当宏在定义中出现超过一次时，如果参数带有副作用，使用这个宏的时候就有可能出现危险，导致无法预测的结果\n\n副作用指表达式求值时出现的一些附带效果，如前置++和后置++\n\nx+1//不带副作用x++//有副作用\n\n以下这个宏可以体现上面描述的问题\n#define MAX(x,y) ((x)&gt;(y)?(x):(y))\n\n如果是一个函数封装，我们的理解是，a和b原来的值3和5被传入MAX，然后再各自++一次\n但实际上并不是这样，可以看到a++了一次，但是b++了两次\n\n这是为什么呢？\n\n宏执行的是直接替换\n\n#define MAX(x,y) ((x)&gt;(y)?(x):(y))//上述宏被替换后的结果int m=((a++)&gt;(b++)?(a++):(b++))\n\n这个表达式中，执行比较的时候，a和b各++一次，但是在最后返回b的时候，末尾b++被执行了一次\n得到的结果就是a=4，b=7\n2.6宏和函数对比宏经常被用作执行简单的计算（如上面提到多次的MAX）\n这时候宏对比函数有几个优点\n\n函数的调用需要压栈出栈，比实际执行这个小型代码需要的时间更长。宏比函数在程序的执行速度方面更胜一筹\n函数的参数必须声明位特定的类型，只适用于特定类型的表达式上。反之，宏可以用整型、长整型、浮点型等可以用&gt;来比较的类型。宏的调用与类型无关\n\n除了MAX这个简单宏语句外，宏的参数还可以出现数据类型\n如下图中我们调用的这个宏，就可以做到用一种更简单的方式来调用malloc函数。此时的调用只需要写入待开辟数据个数和数据类型，不需要再写强制类型转换等语句，方便使用\n\n有得就有失，宏当然也有缺点：\n\n每次使用宏，执行的是直接替换。如果此时宏比较长，则会增加程序的长度\n宏在预处理阶段执行了替换，无法进行调试\n宏与类型无关，不够严谨\n宏会出现操作符优先级问题，容易出错\n\n2.7命名约定一般来讲函数的宏的使用语法很相似，所以语言本身没法帮我们区分二者。 \n那我们平时的一个习惯是： \n\n把宏名全部大写：MAX\n\n函数名不要全部大写：Max\n\n\n#define MAX(x, y) ((x)&gt;(y)?(x):(y))int Max(int x, int y)&#123;\treturn x &gt; y ? x : y;&#125;\n\n2.7 #undef这条指令用于移除一个宏定义\n#undef NAME\n\n如果不移除，就无法重复定义同名宏\n\n\n3.命令行定义一些C语言的编译器提供了一个功能，允许我们在命令行中定义一个符号，用于启动编译过程\n当我们需要一个程序的不同版本时，可以使用该指令\n\n如：在不同情况下需要不同长度的数组\n\n\n如果我们直接编译这部分代码，编译器会报错，SZ未定义\n\n但当我们写上这么一行命令\ngcc test.c -D SZ=10\n\n可以看到编译器没有报错，再次ls，发现多了一个a.out文件\n\n执行该文件，可以看到SZ被定义成10并成功打印\n4.条件编译在编译一个程序的时候，我们可以通过条件编译指令来控制一组语句的使用与否\n4.1if&#x2F;endif#define M 1int main()&#123;\tint i = 0;\tint n = 10;\tfor (i = 0; i &lt; 10; i++)\t&#123;#if M\t\tprintf(&quot;%d\\n&quot;, i);#endif\t\t//其他代码\t&#125;\treturn 0;&#125;\n\n#if语句后为真即执行，为假不执行\n\n该语句之后只能跟随常量表达式，不能跟随定义的变量\n\n#define M 1#if M//正确#if 3&gt;5#if M==1//正确int a=1;#if a//err\n\n\n在linux环境下，使用编译语句执行预处理操作，可以看到生成的test.i文件中，printf代码是被包含进去的\n\n如果把M更改为0，再次执行预处理操作。printf语句并没有包含在for循环中\n\n\n如果这里放入变量n，不起作用\n\n\n你可能想问，如果这一行代码我不需要，直接注释掉不就ok了吗？\n并不然。\n有些时候我们为了验证之前写的程序是否正确，会编写一些测试代码，用于debug。这些代码在测试完成后可以删除，但是如果我们下次还需要测试同一个函数的时候，就有需要重新写一遍，很是不方便。\n有了条件编译指令，我们就可以在程序的最上方#define定义一个常量，来控制是否进行测试。\n\n4.2多个分支的调节编译#define M 150int main()&#123;#if M&lt;100\tprintf(&quot;less\\n&quot;);#elif M==100\tprintf(&quot;==\\n&quot;);#elif M&gt;100&amp;&amp;M&lt;200\tprintf(&quot;more\\n&quot;);#else\tprintf(&quot;hehe\\n&quot;);#endif\treturn 0;&#125;\n\n和之前一样，不运行的代码，VS2019会显示为灰色\n\n4.3判断符号是否已被定义#define M 0int main()&#123;#if defined(M)\tprintf(&quot;hehe\\n&quot;);#endif#ifdef M\tprintf(&quot;haha\\n&quot;);#endif//这两条语句等价       return 0;&#125;\n\n\n如果想把条件改为未定义的时候执行，可以使用下面这两种方式\n\n!：逻辑反操作符\n\n\n4.4嵌套指令和其他语句一样，条件编译语句也可以嵌套使用\n#define M 0#define N 1#if defined(M)     #ifdef OPTION1     \tM_option1();     #endif     #ifdef OPTION2     \tM_option2();     #endif#elif defined(N)     #ifdef OPTION2     \tN_option2();     #endif#endif\n\n\n5.文件包含我们知道，#include指令可以使另外一个文件被编译。它同时也是一个替换：\n\n编译器在预处理阶段删除这条指令，用包含文件的内容替换\n一个源文件被包含10次，就会被编译10次\n\n5.1包含方式#include &quot;test.h&quot;//本地文件#include &lt;stdio.h&gt;//库文件\n\n你可能会有这个疑问，这两种包含方式之间有什么区别呢？\n双引号方式\n现在源文件（项目文件）所在目录下查找。\n如果该头文件未找到，编译器就会像查找库函数头文件一样在标准位置查找头文件。\n如果找不到就提示编译错误\n\nVS2019标准位置（去VS的安装目录找）\nC:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.29.30133\\include\n\nLinux环境标准位置\n/usr/include\n\n\n库文件方式\n只在标准路径下查找，如果找不到就提示编译错误\n\n既然双引号方式也会去标准路径下查找，那是不是说我们可以用双引号方式包含库函数的头文件？\n答案是肯定的\n但是这么做，会让我们难以分辨头文件到底是库函数还是自定义头文件。两次查找也会影响程序编译效率\n\n5.2嵌套文件包含问题假如在项目合作中，出现了这种情况\n\n\ncomm.h和.c是公共文件\ntest1.h和test1.c使用了公共模块\ntest2.h和test2.c也使用了公共模块\ntest.h和test.c最终使用了test1和2模块\n\n这种情况下，就相当于有两份comm.h的内容被拷贝到最终的程序中\n假如comm.h中有define或者全局变量的定义，这就相当于一个定义语句写了两遍，出现了重复定义\n如何解决？我们可以在每个头文件的开头写\n#ifndef __TEST_H__#define __TEST_H__//头文件的内容#endif\n\n这样，如果__TEST_H__符号已经被定义过，编译器就不会二次展开头文件中的代码，也就避免了这个问题\n如果你使用的是VS编译器，在创建.h文件的时候，VS会自己包含一个语句\n#pragma once\n\n这个语句也有相同的作用\n\nwarning: #pragma once in main file在我尝试在linux环境下使用#pragma once语句时，遇到了这个报错\n\n解决这个问题的办法很简单，就是不要编译头文件\n\n编译器会自动展开头文件，无需手动编译\n\n\n\n网上查了查：出现这个问题的原因是编译器在编译头文件的时候，#pragma once本身是没有含义的语句，所以报错了。\n\n也有人说是因为linux不支持这个语句，我们来试试\n\n右侧代码中包含了两个test.h的引用，在预处理中只包含了一次\n\n去掉头文件中的#pragma once，再次编译，可以看到预处理文件中出现了两次头文件的内容\n\n这说明linux-gcc编译器是支持该语句的，并非网上说的不支持！\n还有更多……其实预处理指令还远不止本博客中包含的这些\n#error#pragma#line\n\n这些预处理指令还等待我的学习~记录在小本本上了\n\n如果这篇博客对你有帮助，还请点个👍吧！\n","categories":["初识C语言"],"tags":["C语言","编译"]},{"title":"【C语言】clock_gettime函数的使用","url":"/posts/107825263/","content":"函数的基本信息如下\n\n其中第一个参数是配置你想获取什么类型的时间\n第二个参数是一个输出型参数，会将当前时间存放到一个结构体里面给你返回。\n返回值标识是否获取成功\n\n//头文件#include &lt;time.h&gt;//函数原型int clock_gettime( clockid_t clock_id,struct timespec * tp );// timespec 结构体struct timespec &#123;     __time_t tv_sec; /* 秒 */     __syscall_s long_t tv_nsec; /* 纳秒 */&#125;;\n\n第一个参数有下面几种选项\nCLOCK_REALTIME: 是指系统时间，随着系统时间的改变而改变。系统时钟会被用户而改变。并非不变的时间戳。CLOCK_MONOTONIC: 指从系统启动时开始计时。不受系统设置影响，也不会被用户改变。CLOCK_PROCESS_CPUTIME_ID: 指这个进程运行到当前代码时，CPU花费的时间。CLOCK_THREAD_CPUTIME_ID: 指这个线程运行到当前代码时，CPU花费的时间。\n\n使用例子\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;int main()&#123;    struct timespec now;    clock_gettime(CLOCK_MONOTONIC,&amp;now);    printf(&quot;Seconds = %ld \\t Nanoseconds = %ld\\n&quot;,, now.tv_sec, now.tv_nsec);    return 0;&#125;\n\n输出结果\nSeconds = 29642          Nanoseconds = 751516090\n\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】数组竟然还可以这样调用？慕雪学艺不精了！","url":"/posts/842609448/","content":"数组竟然还可以这样调用？只能说慕雪学艺不精了！\n\n\n上代码！起因是群里的一个图，本来以为只是个开玩笑的bug图，谁知道其他群友说了，我才发现是自己毛都不懂\n\n代码就大概是下面这样，请问你的第一印象，这个代码是否有语法错误呢？\n#include &lt;stdio.h&gt;int main()&#123;    int a[10] = &#123;1,3,4,5,6,7&#125;;    printf(&quot;%d &quot;,a[4]);    printf(&quot;%d\\n&quot;,4[a]);    return 0;&#125;\n\n问题肯定是第二个printf中的4[a]，直接上编译运行结果，可以看到不但没有出错，二者的打印的数据也完全相同\n[muxue:~/code/c/c_cpp]$ gcc test.cpp -o test[muxue:~/code/c/c_cpp]$ ./test6 6\n\n为啥？如果你对C语言的指针有过了解，应该知道a[n]实际上在访问的时候，会被转成 *(a+n)来访问具体的地址\n既然是这样，那我们把a和n的顺序倒过来，访问的不就是 *(n+a)了吗？\n学过加法交换律的都知道，这两个访问的结果肯定是相同的\n所以这个代码是没有语法错误的，只不过看着很让人迷惑而已。\n不过，要是真有人在实际项目里面这样写代码，那就可以去“问候”一下他了。代码可读性极低。\n顺带一提C++中的操作符[]的重载是不支持你这么玩的哦！因为和operator[]函数的参数的顺序不一样了\n#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; a = &#123;1,3,4,5,6,7&#125;;    printf(&quot;%d &quot;,a[4]);    printf(&quot;%d\\n&quot;,4[a]);//err    return 0;&#125;\n\n编译报错\n[muxue:~/code/c/c_cpp]$ g++ test.cpp -o testtest.cpp: In function ‘int main()’:test.cpp:10:20: error: no match for ‘operator[]’ (operand types are ‘int’ and ‘std::vector&lt;int&gt;’)     printf(&quot;%d\\n&quot;,4[a]);                    ^\n\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】可变参数列表","url":"/posts/2099966635/","content":"本篇博客让我们来认识一下C语言学习过程中往往被忽略的可变参数列表\n\n\n所谓可变参数，就是一个不限定参数数量的函数，我们可以往里面传入任意个数的参数，以达成某些目的。\n关联：C++11可变模板参数\n1.函数#include &lt;stdarg.h&gt;void va_start(va_list ap, last);type va_arg(va_list ap, type);void va_end(va_list ap);void va_copy(va_list dest, va_list src);\n\n1.1 va_startvoid va_start(va_list ap, last_arg);\n\n\nap: 这是一个 va_list 类型的对象，它用来存储通过 va_arg 获取额外参数时所必需的信息\n这个函数的作用是初始化 ap 变量，它与 va_arg 和 va_end 函数一起使用。\n\n\nlast_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。\n\n要想设置一个带可变参数的函数，函数声明是下面这样的\nvoid test(int a,int b, ...);\n\n这里出现的省略号就是可变参数的特征，而变量b就是va_start函数需要的last_arg\n1.2 va_argtype va_arg(va_list ap, type);\n\n这个函数的作用是来提取可变参数列表中的参数。注意，每次提取的参数是直接返回的，并没有放到变量ap中。\n每次对va_arg的调用都会修改ap，以便下次调用时，返回下一个参数；推断参数的时候需要指定type，如果当前参数类型和type不统一，就会发生不可预知的错误（man手册里面说的）\nIf ap is passed to a function that uses va_arg(ap,type) then the value of ap is undefined after the return of that function.\n\n如果ap被传递给va_arg(ap,type)，则在该函数返回后，ap的值未定义。\n1.3 va_endvoid va_end(va_list ap);\n\n每一个va_start都需要有一个配套的va_end，其用于清空ap\n可以把他俩的关系理解为malloc/free，记得加上就行\n1.4 va_copy这个函数的作用是将可变参数列表从第二个参数src拷贝到第一个参数dest\nvoid va_copy（va_list dest，va_list src）;\n\n其也能够初始化dest。调用了va_copy后，无须调用va_start初始化dest，但va_end还是需要的。\n2.简单示例2.1 打印多个参数#include&lt;stdarg.h&gt;#include&lt;stdio.h&gt;int print(int num_args,...)&#123;    va_list ap;    va_start(ap,num_args);//初始化可变参数    for(int i=0;i&lt;num_args;i++)    &#123;        printf(&quot;%d &quot;,va_arg(ap,int));    &#125;    printf(&quot;\\n&quot;);    va_end(ap);//结束对ap的使用&#125;int main()&#123;    print(5,1,2,3,4,5,6,7,8,9);    return 0;&#125;\n\n运行该函数，会打印如下结果\n$ ./test1 2 3 4 5 \n\n这就表明了，...省略号之前的参数，和va_arg返回可变参数其实是没有关系的。\nint print(int num_args,...)&#123;    va_list ap;    va_start(ap,num_args);//初始化可变参数    for(int i=0;i&lt;8;i++)    &#123;        printf(&quot;%d &quot;,va_arg(ap,int));    &#125;    printf(&quot;\\n&quot;);    va_end(ap);//结束对ap的使用&#125;int main()&#123;    print(5,1,2,3,4,5,6,7,8,9,10);    return 0;&#125;\n\n即便在最后都没有使用num_args，也不会影响结果的正确性。va_start需要这个参数，其实是用来标识可变参数的起点。\n$ ./test1 2 3 4 5 6 7 8 \n\n2.2 多参数求和#include&lt;stdarg.h&gt;#include&lt;stdio.h&gt;// 采用可变参数，第一个参数用于标识参数数量int sum(int num_args, ...)&#123;   int val = 0;   va_list ap;   int i;   va_start(ap, num_args);   for(i = 0; i &lt; num_args; i++)   &#123;      val += va_arg(ap, int);   &#125;   va_end(ap);    return val;&#125;void test1()&#123;    printf(&quot;10、20 和 30 的和 = %d\\n&quot;,  sum(3, 10, 20, 30) );    printf(&quot;4、20、25 和 30 的和 = %d\\n&quot;,  sum(4, 4, 20, 25, 30) );&#125;\n\n运行如下\n$ ./test10、20 和 30 的和 = 604、20、25 和 30 的和 = 79\n\n3.利用可变参数实现log类现在有了可变参数，我们就可以接用这个参数来进行日志的打印了\n#pragma once#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;cstdarg&gt;#include &lt;cassert&gt;#include &lt;cstring&gt;#include &lt;cerrno&gt;#include &lt;stdlib.h&gt;#define DEBUG 0#define NOTICE 1#define WARINING 2#define FATAL 3const char *log_level[]=&#123;&quot;DEBUG&quot;, &quot;NOTICE&quot;, &quot;WARINING&quot;, &quot;FATAL&quot;&#125;;// 采用可变参数列表void logging(int level, const char *format, ...)&#123;    assert(level &gt;= DEBUG || level &lt;= FATAL);    char *name = getenv(&quot;USER&quot;);// 获取环境变量中的用户（执行命令的用户）    char logInfo[1024];    // 获取可变参数列表    va_list ap; // ap -&gt; char*    va_start(ap, format);    vsnprintf(logInfo, sizeof(logInfo)-1, format, ap);    va_end(ap); // ap = NULL    // 根据日志等级选择打印到stderr/stdout    FILE *out = (level == FATAL) ? stderr:stdout;    // 格式化打印到文件中    fprintf(out, &quot;%s | %u | %s | %s\\n&quot;, \\        log_level[level], \\        (unsigned int)time(nullptr),\\        name == nullptr ? &quot;unknow&quot;:name,\\        logInfo);&#125;\n\n3.1 vsnprint作用：使用vsnprintf()用于向一个字符串缓冲区打印格式化字符串，且可以限定打印的格式化字符串的最大长度。\n此函数需要C99或者C++11及以上版本才能支持。\nint vsnprintf(char* sbuf, size_t n, const char* format, va_list arg);\n\n\n第一个参数：目标缓冲区（字符数组）\n第二个参数，限定最多打印到缓冲区的字符数量为n-1个（留位置给\\0）\n第三个参数，打印的格式（如%d:%s）\n第四个参数，可变参数arg，需要用va_start初始化\n\n返回：成功打印到sbuf中的字符的个数，不包括末尾追加的\\0。如果格式化解析失败，则返回负数。\n用这个函数，就能把我们的来源字符串给输入到缓冲区char logInfo[1024];中\n3.2 fprintf使用fprintf，将printf的输出打印到指定文件中；用法和printf是一样的\nint fprintf(FILE *stream, const char *format, ...);\n\n这样是为了区分stderr/stdout。同时添加上执行命令的用户信息，以及当前的时间戳\nfprintf(out, &quot;%s | %u | %s | %s\\n&quot;, \\    log_level[level], \\    (unsigned int)time(nullptr),\\    name == nullptr ? &quot;unknow&quot;:name,\\    logInfo);\n\n3.3 运行结果int main()&#123;    logging(DEBUG, &quot;socket create success: %d&quot;, 114514);    logging(FATAL, &quot;socket:%s:%d&quot;, strerror(errno), 11234);    return 0;&#125;\n\n$ ./testDEBUG | 1675322313 | muxue | socket create success: 114514FATAL | 1675322313 | muxue | socket:Success:11234\n\nThe end对于可变参数的简单介绍就到这里！基本的使用能看懂久OK啦！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】猜数字游戏 | 首篇博客","url":"/posts/2820557606/","content":"这是一初学c语言的新人的第一篇博客，尝试使用Markdown的方式写入\n\n\n这是一初学c语言的新人的第一篇博客尝试使用Markdown的方式写入(本来用的51cto，发现人好少，于是跑过来了）\n什么是MarkdownMarkdown是现在普遍使用的一种文档书写语言格式，只需用一些非常简单易记的符号，如#*/&gt;[]0\\，就可以轻松写出一篇具有良好的排版和可读性的文.接下来进入我们的正题\n猜数字游戏这是一非常经典的代码应用基本逻辑如下：\n\n1．计算机生成一个随机数2．玩家输入一个猜想的数字3．计算机提示“猜大了”或者“猜小了”并在玩家猜测正确时提示“恭喜你，猜对了”\n先来看看游戏最终是什么样子的吧\n\n玩家运行，可以看到一个菜单以及选择\n\n\n键入1即为开始游戏\n\n系统在玩家猜小或者猜大之后都会有对应的提示，猜对之后程序也会再次运行，玩家可以选择退出或者再来一次\n那么这个猜数字游戏是怎么实现的呢？\n首先我们制作一个简易的menu\nvoid menu()&#123;\tprintf(&quot;*****************************\\n&quot;);\tprintf(&quot;****  1.play   0.exit    ****\\n&quot;);\tprintf(&quot;*****************************\\n&quot;);&#125;\n光是这个menu还不够，我们需要写一个代码串来实现在1.play和0.exit之间选择的功能\nswitch case语句为了实现这个功能，我使用的是switch语句\nmenu();printf(&quot;请选择&gt;:&quot;);scanf(&quot;%d&quot;, &amp;input);switch (input)&#123;case 1:\tgame();//猜数字游戏\tbreak;case 0:\tprintf(&quot;退出游戏\\n&quot;);\tbreak;default:\tprintf(&quot;选择错误\\n&quot;);\tbreak;&#125;\n是不是觉得少了点什么？别急！\n\n玩家肯定想多次游玩这个猜数字游戏，总不能是一个一次性游戏吧\n所以我们需要给这个switch加上循环语句\n这里我用的是do whlie循环\n\nint main()&#123;\tint input = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择&gt;:&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();//猜数字游戏\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出游戏\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n因为我们这里用到了scanf库函数，所以我们需要引用头文件 #include &lt;stdio.h&gt;\n注意这里我们的game()函数是接下来要编写的猜数字游戏的主要函数\n我们可以先屏蔽掉game()来测试目前代码是否正确\n\n如果你能复现和我一样的运行框，说明目前编译的选择程序是没问题的\n接下来便是重头戏如何编写我们的game()程序？\n这里我们要先引入一个rand函数：rand是一个生成随机数字的函数 点击查看rand函数定义\n\n从定义我们可以得知，rand能生成的是0到RAND_MAX的整数\n\n通过查询百度百科我们可以知道RAND_MAX最小为7FFF\n使用WIN10自带的计算器中的程序员计算器，可以得知7FFF(16进制)即为32767(十进制)接下来我们可以编译一个简单的程序查看rand会生成什么数字\nvoid game()&#123;\tint ret = 0;\tint guess = 0;\tret = rand()%100+1; //生成1-100的随机数\tprintf(&quot;%d\\n&quot;, ret);&#125;\n程序很好的生成了1-100的数字，但是真的有这么简单吗？如果你再次运行程序，就会发现两次运行每次生成的结果都一模一样玩家即便是重新进行游戏，猜的还是上一次猜的数字，那怎么行？这里我们就要引入和rand相关的另外一个小知识点\n生成随机数起始点如果你在上面提到的rand定义的网站继续往下滑，便能看到srand\n\n这就是我们接下来要用到的函数\nvoid game()&#123;\tint ret = 0;\tint guess = 0;\tret = rand()%100+1;//生成1-100的随机数\tsrand(1);\tprintf(&quot;%d\\n&quot;, ret);&#125;\n我们先添加srand(1)查看效果\n\n这时每次生成的随机数字变成统一的42\n如果我们改成srand(2)的话\n会发现除了第一个数字是42之外，其他的数字都是46这是因为rand函数需要另外一个随机数作为它生成随机数的起点如果我们想要rand每次都能生成不一样的随机数的话就必须用srand(这里需要一个随机数)这不是套娃吗？我们需要随机数来生成一个随机数，程序不会死循环？那什么样的数字是会一直变化的呢？\n时间函数这里又要引入另外一个time函数\nsrand((unsigned)time(NULL));\n\n\n同时我们需要了解时间戳的定义\n当前计算机的时间 - 计算机的起始时间(1970.01.01 00:00:00) = (xxxx) 秒 \n\n这个数字便是我们最易得的随时在变化的数字。我们同样可以在刚才查询rand定义的网站找到time的定义 [点我查看]\n\n我们把刚才是srand(2)改成如下格式，再次调试代码\n\ntime函数需要引用头文件#include&lt;time.h&gt;\n\n\n这一次我们终于生成了完全随机的1-100的数字\n\n但是有另外一个问题，这个game函数是处在main函数循环语句中的\n\n也就是每次游戏的时候，game函数都会重新生成一个新的随机数\n玩家猜测的并不是一个固定的数字，那也永远猜不到答案\n所以我们应该把srand添加到main主函数中，这样每一次游戏只会生成一个固定的随机数，这才是我们最终想要的效果!\n\n接下来我们需要编写if、else if语句来实现游戏的猜测以及提示\nwhile (1)\t&#123;\t\tprintf(&quot;猜数字:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;guess);\t\tif (guess&gt;ret)\t\t&#123;\t\t\tprintf(&quot;猜大了\\n&quot;);\t\t&#125;\t\telse if (guess&lt;ret)\t\t&#123;\t\t\tprintf(&quot;猜小了\\n&quot;);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;恭喜你，猜对啦\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125;\n同时我们要屏蔽掉刚才放入game函数中的srand以及会告诉玩家答案的printf\n\n这样我们的猜数字游戏就大功告成了！来试玩一下吧！\n\n可以看到游戏正是我们需要的样子！玩家也可以重复游戏\n这篇小博客到这里也就结束了第一次尝试的时候，手贱不小心按了F5，写了一半的博客直接无了\n不管怎样，感谢你看到最后\n还请dalao们对我的博客进行指正\n如果能点个赞什么的就最好了\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】关机程序","url":"/posts/2689863829/","content":"不知不觉就摸了几天鱼，及时醒悟，开始码之前在goto语句中提到的关机小程序\n\n\n@[TOC]\n关机程序在介绍这个程序之前，我们要了解win10系统的一些系统指令\nwindows系统指令用win+r打开系统的运行框（这个从xp，win7到win10都有）\n在弹出的运行框中输入shutdown -s -t 7200（后面跟着的数字是时间，单位是秒）\n\n\n系统将在右下角提示你定时关机的时间，届时还会在定时关机时间提前60s提醒你要关机\n想要取消定时关机，可以在运行中输入shutdown -a\n\n\n定时关机就被取消了\n了解了这个之后，我们就要知悉C语言中可以帮我们在系统的运行中输入指令的函数\nsystem函数首先，让我们在之前和大家分享过的网站cplusplus上查询该函数的定义\n\n简单地说，这个函数就是来帮我们execute执行系统命令的。\n同时，cpluscplus网站告诉我们：这个函数的头文件是stdlib.h\n先写一个简单的关机程序来实操一下system函数\n#incldue &lt;stdlib.h&gt;int main()&#123;\tsystem(&quot;shutdown -s -t 60&quot;);//system() -执行系统命令的\treturn 0;&#125;\n\n\n循环指令和关机程序接下来让我们用一个有点损的方式写一个关机程序\n运行这个程序后，只有输入“我是🐖”才能取消关机\nint main()&#123;\tchar input[20] = &#123; 0 &#125;;\tsystem(&quot;shutdown -s -t 60&quot;);\twhile(1)\t&#123;\t\tprintf(&quot;请注意，你的电脑将在1分钟内关机，如果输入:我是猪，就取消关机\\n请输入&gt;:&quot;);\t\tscanf(&quot;%s&quot;, input);\t\tif (strcmp(input, &quot;我是猪&quot;) == 0)//头文件#include &lt;string.h&gt;\t\t&#123;\t\t\tsystem(&quot;shutdown -a&quot;);\t\t\tbreak;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n这里我们还用到了strcmp函数，用于比较你输入的字符和“我是🐖”是否一致\n\n要注意“&#x3D;&#x3D;”不能用于比较字符\n\n这里用到的是十分基础的while+if的语句组合。\n运行结果如下\n\n\n输入我是🐖后注销会取消，如果输入错误会再次弹出提示\ngoto语句写关机程序当然，如果看过上一篇的你肯定知道这篇博客的重点是goto\n主要是演示一下again在goto所在代码行之前的情况\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar input[20] = &#123; 0 &#125;;\tsystem(&quot;shutdown -s -t 60&quot;);//头文件&lt;stdlib.h&gt;again:\tprintf(&quot;请注意，你的电脑将在1分钟内关机，如果输入:我是猪，就取消关机\\n请输入&gt;:&quot;);\tscanf(&quot;%s&quot;, input);\tif (strcmp(input, &quot;我是猪&quot;) == 0)//比较两个字符 -strcmp() 头文件&lt;string.h&gt;\t&#123;\t\tsystem(&quot;shutdown -a&quot;);\t&#125;\telse\t&#123;\t\tgoto again;\t&#125;\treturn 0;&#125;\n\n运行的结果和上面的whlie语句一样，这里就不截图了\n这个代码可以用来整蛊你的损友，或者在春节的时候阻止熊孩子“借”用你的女朋友（指电脑）\n询问框里的问题和对应的回答都可以随意更改，当然你也可以把时间改成10秒让人压根来不及反应\n如果你用的是devc++，每次运行代码的时候都会自动生成一个exe文件\n\n把logo改改，就能去糊弄人了\n（话说vs2019要怎么生成exe啊，得去研究一下）\n郑重警告！\n\n娱乐一下即可\n\n若使用该程序导致电脑关机且未保存重要文件\n\n\n本博主不负任何责任！\n点个赞再走呗，谢谢！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C语言】排序三个输入的数字","url":"/posts/3460916609/","content":"如何将输入的3个数字排序并打印出来@[TOC]\n承接上篇博客中输出数组内元素最大值的内容\n本篇博客向大家分享如何将我们输入的三个数字进行大小排序并打印出来\n1.scanf函数int main()&#123;\tint a = 0;\tint b = 0;\tint c = 0;\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);&#125;\n\n既然需要输入，那就要用到scanf函数来接受我们输入的数字\n\n要使用指针变量，因为这里的scanf需要改变我们的a，b，c\nscanf的头文件是 &lt;stdio.h&gt;\n\n2.tmp盒子相信大家在自己的学习中已经接触过使用tmp来进行大小比较的代码了\n什么？没有？\n那也没关系，基本实现的原理易懂的很！\nif (a &lt; b)\t&#123;\t\tint tmp = a;\t\ta = b;\t\tb = tmp;\t&#125;\n\n\n把a的值赋给tmp\n因为a小于b，所以我们让a等于更大的值\n再使用tmp把原来是a的值赋给b\n\n这样就写好了一个大小比较和交换的语句了\n我们只需要CTRL+C然后+V\n稍微改改里面的abc\n就能写出下面的完整代码\n#include&lt;stdio.h&gt;int main()&#123;\tint a = 0;\tint b = 0;\tint c = 0;\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\tif (a &lt; b)\t&#123;\t\tint tmp = a;\t\ta = b;\t\tb = tmp;\t&#125;\tif (a &lt; c)\t&#123;\t\tint tmp = a;\t\ta = c;\t\tc = tmp;\t&#125;\tif (b &lt; c)\t&#123;\t\tint tmp = b;\t\tb = c;\t\tc = tmp;\t&#125;\tprintf(&quot;%d&gt;%d&gt;%d&quot;, a, b, c);\treturn 0;&#125;\n\n运行一下\n\n这里需要注意，我们输入数字的时候需要用空格隔开两个数字\n因为这串代码实现的是从大到小排列\n所以我们可以打印的时候在每个数字之间加个&gt;号\n这里显示的内容和下面这行代码%d中间的内容是一致的\nprintf(&quot;%d&gt;%d&gt;%d&quot;, a, b, c);\n\n比如我把中间的&gt;改成#号，打印出来也是一致的\n\n注意的点在编写这个3个数字比较的代码的时候，我们要先将a和b、c比较，再比较b和c下面的这个代码是一个错误的代码\nif (a &lt; b)&#123;\tint tmp = a;\ta = b;\tb = tmp;&#125;if (b &lt; c)&#123;\tint tmp = b;\tb = c;\tc = tmp;&#125;if (a &lt; c)&#123;\tint tmp = a;\ta = c;\tc = tmp;\n\n因为我们需要先确定a里面装的是最大的那个数字，然后才能让b和c比较决出“季军”如果这样说你还是没太明白，可以尝试将这串代码输入vs编译器，用ctrl+f10调试，查看运行一个if语句之后a，b，c的赋值的变化\n\n结语这串代码如果继续复制粘贴的话可以实现不止3个数字的大小排列并打印\n不知道能不能用自定义函数实现这个功能？\n点个赞再走呗，万分感谢！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】goto语句","url":"/posts/3474605456/","content":"这是初识c语言的第五篇文章了\n虽然看的人不多，但我不会放弃哒\n毕竟这也是给我自己的一个学习记录，不想写日记就用这个代替了！\n\n\ngoto语句c语言中提供了可以随意使用的goto语句和标记跳转的标号\n理论上来说，goto语句没什么必要，因为我们可以用whlie等循环语句来替代它\n\ngoto是类循环语句，其本身是关键字\n\n\ngoto语句在某些场景下用的到，如终止程序在某些深度嵌套的结构的处理过程，例如一次跳出两次或者多层的循环\n这种情况下break达不到我们的目的。break只能从最内层循环退出到上一层的循环\n\ngoto语句真正适合的场景如下：\nfor(...) \tfor(...)\t&#123;\t\tfor(...)        &#123;        \tif(disaster)         \t\tgoto error;          &#125;    &#125;\t...error:     if(disaster)//处理错误情况\n\n用下面这个例子来给大家简单地演示一下goto的作用\n#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;hello world\\n&quot;);\tgoto again;\tprintf(&quot;你好\\n&quot;);again:\tprintf(&quot;hehe\\n&quot;);\treturn 0;&#125;\n\n结果如下\n\n可以看到，程序跳过了printf(“你好\\n”);，直接到下一步打印hehe\n代码的执行流程图如下：\n\n其实goto的作用方式非常容易理解，即：走到again\n这时候程序会直接跳到again后面的代码，不管这个again是在goto的后面还是前面\n需要注意的是，again在前面必须在特定的循环\\条件代码中使用\n如果你将上述的代码改成这样\nint main()&#123;again:    printf(&quot;hello world\\n&quot;);\tgoto again;\tprintf(&quot;你好\\n&quot;);\tprintf(&quot;hehe\\n&quot;);\treturn 0;&#125;\n\n那么代码就会一直打印hello world，进入死循环\n那goto就不是没有必要了，是毫无意义\n\n想知道goto在前面的时候要怎么书写代码吗\n且听下回分解\n（因为这个代码是个关机小程序，我感觉重新写一篇博客会更好）\n点个赞再走吧，求求了！\n","categories":["初识C语言"],"tags":["C语言"]},{"title":"【C语言】猜数字游戏","url":"/posts/2820557607/","content":"函数是什么?数学中我们常见到函数的概念，但是你了解C语言中的函数吗？维基百科中对函数是如下定义的。\n\n可以说函数function是计算机变成语言中非常重要的一环。如果我们想学好c语言，就必须学会如何使用库函数，以及如何创建自定义函数。\n回溯在我的【猜数字游戏】博客中，已经有讲述过如何查询库函数的定义。在上一篇【传值调用和传址调用】中也有与自定义函数相关的内容。本篇博客将更细致地向初学c的伙伴们分享如何使用库函数。\n库函数库函数，是c语言库中已经包含了的函数。这些函数的作用不一，但他们都有一个共同点——所有人都用的上。\n\n当你写出一串代码，肯定会想知道它运行的结果，这时候要用到 printf 来打印大家第一个学习的hello world代码中就用到了 printf库函数\n在编程过程中我们需要频繁地做字符串的拷贝 strcpy\n\n既然所有人都用的上，那为什么不让这些函数变成编程语言中预设的功能，让后来者更方便的使用编程语言呢？这样效率倍增，可移植性和易用性也大大增强，何乐而不为。库函数由此诞生\nC语言常用的库函数\nIO函数\n字符串操作函数\n字符操作函数\n内存操作函数\n时间&#x2F;日期函数\n数学函数\n其他库函数\n在【猜数字游戏】中使用到的time函数是时间函数的一种\n\n\n\n接下来我用两个函数的具体案例，和大家分享如何查找库函数定义以及如何尝试使用库函数分别是 strcpy函数 和 memset函数\n查询库函数定义在这里给大家分享两个超棒的网站！\n\ncppreference 中文\ncplusplus 英文\n\n如果要查询库函数定义，cplusplus是我们的不二之选。它虽然只有英文，但是这难不倒我们代码人，实在不行就网页翻译一下嘛！\n夹带私货时间如果你用的是chrome或者微软最新的edge浏览器，可以尝试安装侧边翻译这个插件非常好用，强力推荐！\n\nmemset函数打开cplusplus，输入我们需要查询的函数\n\n看不懂？没关系。只要了解下面几个简单的单词，我们就能尝试去读库函数的定义了\n\nfunction →函数\nParameters →参数\nReturn Value →返回值\nExample →例子\n\n在页面的左边我们可以看到函数的头文件\n\n需要注意的是，是c++语言里的头文件，而左边的&lt;string.h&gt;才是我们c语言要用的头文件\n\ncplusplus真正强大的地方，在于它可以让你直接在网页端编辑给出的代码例子\n\nmemset其实是由两个单词组成的，memeory内存 + set设置\n\n读函数定义的文档的时候，最好是逐字解读，不要整句翻译。\n\n注意每个函数下面绿色的这一行以memset为例，void*表示它是指针变量，int表示整型，size_t表示大小\n\nFill block of memory 填充内存块\nSets the first num bytes 设置前num个字节\nSets the first num bytes of the block of memory 设置内存块中的前num个字节\npointed by ptr 由ptr指引的\nto the specified value 设置成特殊的value\n\n\n连起来就是：\n\n把由ptr指引的内存块的前num个字节设置成特殊的value\n\n让我们继续解读\n\n\nptr 要被填充的内存块的pointer指示器\nvalue 要被设定的特殊值，它是int整型\nnum 有多少字节的内存要被设定成value\nsize_t 无符号整型\n\n读到这里，关于memset的定义我们就能大概了解了接下来就要进入实践了\n#include&lt;string.h&gt;//memset头文件#include &lt;stdio.h&gt;//printf头文件int main()&#123;\tchar arr[] = &quot;hello world&quot;;\tmemset(arr, &#x27;*&#x27;, 5);\tprintf(&quot;%s\\n&quot;, arr);\treturn 0;&#125;\n在使用memset的时候，我们遵循定义中的 ( void * ptr, int value, size_t num )方式\nmemset(arr, &#x27;*&#x27;, 5);\n\narr是我们要更改的内容\n‘*’ 指我们把arr中的内容最终改成  ‘*‘\n5 表示我们想更改5个字符的内容\n用 printf 打印最终更改后的结果\n\n运行的结果如下图所示\n\n可以看到，hello world中的前五个字符，也就是hello被改成了*****和memset的定义的描述完全一致！\n怎样，是否有点小激动？（反正我当时学到这里的时候是有的）让我们继续！\nstrcpy函数比起memset函数，strcpy函数的使用频率更高我们同样在cplusplus中查询strcpy函数的定义\n我们依旧用上述说的逐步解读法来查阅strcpy的定义\n\nCopies the C string 拷贝内容\npointed by source 由source指示的的内容\ninto the array pointed by destination 到目标数组中\n\n\n拷贝由source指示的内容到目标数组中\n\n照样实践一下\n#include &lt;string.h&gt;//strcpy函数头文件#include &lt;stdio.h&gt;int main()&#123;\tchar arr1[] = &quot;bit&quot;;\tchar arr2[20] = &quot;##########&quot;;\tstrcpy(arr2, arr1);\tprintf(&quot;%s\\n&quot;, arr2);\treturn 0; &#125;\n(arr2, arr1)  其中arr2是我们的目标，arr1是我们要拷贝的内容\nstrcpy(arr2, arr1);\n\n运行结果如下\n\n当你看到这里的时候，肯定会有和我一样的疑惑：为什么拷贝到2中的内容只有bit三个字节，但是后续的#######没有打印出来呢？这里就涉及到转义字符里面的内容了\n字符结束标志\\0是字符串的结束标志，默认跟在我们输入的字符后面\n\n“bit” 字符实际为 ”bit\\0“\n\n打印的时候遇到”\\0“会自动停止\nchar arr1[] = &quot;bit&quot;;char arr2[20] = &quot;##########&quot;;              // bit\\0遇到\\0认为字符串结束，所以不打印后面的#\n与strcpy长得很像的还有另外一个库函数strlen    strcpy - string copy - 字符串拷贝    strlen - string length - 字符串长度有关\n对于strcpy函数 和 memset函数 的介绍到这里就结束了\n结语到这里，对于查询库函数以及使用库函数的方法应该已经很清晰了（自我感觉 ）希望对大家有所帮助c语言新人，有所纰漏在所难免，欢迎各路dalao无情指正！\n纯手打，4k多字，今天效率比昨天高，2小时就搞定了点个赞再走吧，谢谢大家！\n","categories":["初识C语言"],"tags":["C语言","函数"]},{"title":"【C++】凝视C++的第一眼","url":"/posts/1070210667/","content":"从今天开始，正式步入C++学习的大门啦！\n\n\nC++的博客主要是我个人学习的学习笔记，刚开始会记一些比较零碎的小知识点，可能没有之前C语言的博客那么系统化😂\n笔记中可能有错误的地方，欢迎大家指出！\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n[TOC]\n1.C++简介\n你可以通过菜鸟教程网来学习C++👉传送门\n\nC++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\nC++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。\nC++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n\n2.C++关键字C语言有32个关键字，C++在它们的基础上进行了扩容，共有63个关键字\n\n\n\nasm\nelse\nnew\nthis\nauto\nenum\n\n\n\noperator\nthrow\nbool\nexplicit\nprivate\ntrue\n\n\nbreak\nexport\nprotected\ntry\ncase\nextern\n\n\npublic\ntypedef\ncatch\nfalse\nregister\ntypeid\n\n\nchar\nfloat\nreinterpret_cast\ntypename\nclass\nfor\n\n\nreturn\nunion\nconst\nfriend\nshort\nunsigned\n\n\nconst_cast\ngoto\nsigned\nusing\ncontinue\nif\n\n\ndefault\ninline\nsizeof\nvirtual\nstatic\nvoid\n\n\ndo\nlong\nstruct\nwchar_t\ndelete\nint\n\n\nstatic_cast\nvolatile\ndouble\nmutable\nswitch\nwhile\n\n\ndynamic_cast\nnamespace\ntemplate\n\n\n\n\n\n\n如果你想查看它们的完整介绍，可以参考这篇教程👉传送门\n\n这里只做一个基本的认识，后续会一一学习这些关键字\n\n3.安装你的C++环境\n如果是windows系统，建议使用微软的VisualStudio，不要用dev这种老式编译器！\n如果是mac系统，可以使用Xcode（我没有mac不知道具体情况）\n如果是linux系统，需要安装G++编译器\n\n利用我的树莓派，给大家演示一下linux环境安装G++编译器\n下面这个语句是显示g++编译器的版本，如果你弹出了和我一样的页面，说明你的linux系统里面已经有这个编译器了\ng++ -v\n\n\n如果没有，我们可以使用下面这个语句来整一个g++\nsudo apt-get install g++\n\n你也可以用这个语句来验证你的G++是否已经安装\n\n下载完成后，就可以愉快的使用你的G++编译器了\n\n如果你的下载很慢，可能要考虑换源（即更换一个软件下载源）\n树莓派实验室详细记录了国内比较好用的源，也有换源教程👉传送门\n\n\n4.C++的输入输出4.1cout和cin样例老规矩，向这个世界问个好吧！\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;    return 0;&#125;\n\n\n这里出现的endl是“end of line”的缩写，结束一行，相当于C语言中的\\n\n因为C++的编译器是完成兼容C语言的，所以你可以用&quot;\\n&quot;来替换endl\n\n\ncout是流提取操作符，对应的，也有流插入操作符cin。你可以理解为它们就是C++中的printf和scanf\n注意这里的箭头方向，不要弄错了\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;    int a;    cin &gt;&gt; a;    cout &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n\n\n4.2头文件使用这两个“库函数”时，必须要要包含iostream头文件以及std标准命名空间\n在cplusplus.com上搜索，可以看到iostream是标准输入输出流的库\n\n4.3和C语言的不同使用C++来输入输出更加方便，因为我们不需要增加格式控制符（%d %c %f这种）\n因为编译器会自己判断它们的类型\n\n同样的，我们可以使用连续的&gt;&gt;来输入多个数据\n\n4.4浮点数默认保留5位小数通过两个程序的测试，我们可以看到C++中默认保留小数是5位，而C语言中是6位\n\n\n那么问题来了，如果我想控制输出格式，让它输出小数点后两位可以怎么做呢？\n很简单，直接调用printf和%.2f不就完事了？\n\nC++中也有自己的格式控制方式，但是那个比printf更复杂\n\n\n而且在C++中打印低于5位的浮点数，并不会像C语言一样后补0\n\n注意注意！如果在C++程序中使用printf，就不能在printf里面写endl啦！\n\n5.命名空间在输入输出函数中，有这么一个语句\nusing namespace std;\n\n前面已经提到过，std是”标准命名空间”\n那什么是命名空间呢？\n\n5.1简单介绍在main函数中，如果出现了两个相同名字的参数，编译器会报错\n\n\n假设一个班级上有两个同名的同学，为了区分他们俩人，我们会使用一些附加的条件来称呼二者。比如性别、家庭住址、甚至是成绩\n\nC++中的命名空间就是用来干这个事的\n在项目合作的时候，命名空间很有用，可以有效避免两个人写的程序中出现同样名字的变量而导致冲突的情况\n5.2设置一个命名空间比如现在我们设置一个命名空间，把int a放入其中\nnamespace muxue &#123;\tint a = 1;&#125;\n\n可以看到，这个时候编译程序就不会报错了\n\n但是程序打印的是main函数中的double类型a，如果我们想用muxue中的int a要怎么操作呢？\n只需要在变量名之前用::来指定命名空间就可以了\n\n当然，我们也可以使用using namespace muxue;来直接展开这个命名空间中的所有东西\n\n但是这样不太好！后面会提到\n\n如果你定义了两个相同名字的命名空间，在编译程序的时候，编译器会合并他们\n\n5.2.1嵌套定义命名空间定义命名空间就和C语言的结构体很类似，是可以嵌套定义另外一个命名空间的\n//命名空间namespace muxue &#123;\tint a = 1;\t//嵌套定义命名空间\tnamespace happy &#123;\t\tint b = 2;\t&#125;&#125;int main() &#123;\tdouble a = 3.14;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; muxue::a &lt;&lt;endl;\tcout &lt;&lt; muxue::happy::b &lt;&lt; endl;\treturn 0;&#125;\n\n\n直接展开两个命名空间后，就不需要这样写输出函数了\n\n\n我们还可以在已有命名空间中嵌套定义一个命名空间，里面包含另外一个a\nnamespace muxue &#123;\tint a = 1;\t//嵌套定义命名空间\tnamespace happy &#123;\t\tint a = 2;\t&#125;&#125;\n\n这时候如果使用using namespace muxue;，在main函数中会默认打印外层命名空间中的a\n\n但如果你比较喜欢作死，把内层命名空间也展开了，就会出现冲突\nusing namespace muxue;using namespace muxue::happy;\n\n\n\n除了嵌套定义中这种冲突的情况，我们直接展开命名空间时，还会遇到其他冲突\n5.3全部展开可能遇到的问题5.3.1和库函数冲突比如下面这个情况，我们在muxue里面定义了一个int类型叫做rand，并在之后直接using namespace完整展开了这个命名空间\n#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;namespace muxue &#123;\tint a = 1;\tint rand = 0;&#125;using namespace muxue;int main()&#123;\ta += 1;\tcout &lt;&lt; a &lt;&lt; endl;\trand = 10;\tprintf(&quot;%d\\n&quot;, rand);\treturn 0;&#125;\n\n然后你就会发现，程序boom了！\n\n这是因为在&lt;stdlib.h&gt;头文件中有一个生成随机数的rand函数，现在程序不知道你是要用命名空间中的变量rand，还是想调用这个库函数了！\nmuxue::rand = 10;printf(&quot;%d\\n&quot;, muxue::rand);\n\n这时候我们就要选择单独调用命名空间中的rand变量，而不是直接使用变量名\n\n同时，顶部的using namesapce也需要做相应修改\n//using namespace muxue;using muxue::a;\n\n5.3.2和其他命名空间冲突namespace muxue &#123;\tint a = 1;\tint rand = 0;&#125;namespace haha &#123;\tint a = 3;&#125;using namespace muxue;using namespace haha;\n\n假设两个命名空间中都有a变量，这时候程序也不知道你要调用哪一个a了，同样会报错\n\n\n这就好比班级里有俩个叫李华的人，本来一个是男的，一个是女的，咱们可以用性别区分\n直接完整展开了命名空间，就好比让这两个李华都变成男生\n这不BBQ了吗？还怎么用性别判断谁是谁？\n\n所以在很多时候，尽量使用::单独展开某一个变量，而不是展开整个命名空间\n这种冲突的情况，被称为命名空间污染\n\n5.4避免命名空间污染在菜鸟教程上，可以看到有大佬做了一个这样的笔记\n\n是的，有的时候我们自定义的变量类型名会和std标准命名空间冲突，这时候直接在最前面using namespace std;就会出5.3中提到的问题\n可cout和cin这两个家伙天天要用，总不能每一次使用的时候，都写一个std::吧？那样也太麻烦了！\n别急，我们也可以单独展开这几个小家伙！\nusing std::cin;using std::cout;using std::endl;\n\n\n其他一些问题在之前5.2和5.3都已经提到过了，这里就不再说啦！\n个人理解，即便C++有命名空间这个好东西，在定义变量的时候最好还是保持一个良好的编程习惯，不用关键字和库函数名作为变量名\n5.5 ::指定全局作用域当我们默认使用::而不在前面添加命名空间的名字的时候，默认会指定到全局的命名空间。即便函数被另外一个命名空间所包裹，也是会调用全局作用域下的函数\n//全局void _print()&#123;    cout &lt;&lt; &quot;global print&quot; &lt;&lt; endl;&#125;//命名空间namespace muxue&#123;    void _print()    &#123;        cout &lt;&lt; &quot;namespace muxue print&quot; &lt;&lt; endl;    &#125;     void testNamespace()    &#123;        ::_print();//调用全局作用域的函数    &#125;&#125;int main()&#123;    muxue::_print();//调用命名空间内的print    muxue::testNamespace();     return 0;&#125;\n\n打印的结果如下\n\n\n6.缺省参数缺省参数是函数在定义的时候，给指定的参数一个默认值，如果没有指定实参，就会使用这个默认值。比如：\n//缺省参数void Add(int a = 10,int b = 20) &#123;\tcout &lt;&lt; a + b &lt;&lt; endl;&#125;int main() &#123;\tint n = 1, m = 2;\tAdd(n, m);//指定了实参\tAdd();//没有指定\treturn 0;&#125;\n\n\n除了这两种方式外，我们还可以只给该函数传一个实参\n\n但是像下面这样，想给函数中的b传一个参数是不可以的\n\n6.1全缺省和半缺省\n像上面这种，函数中的所有形参都设定了缺省值的，叫做全缺省\n函数中只有一部分设置了缺省值的，叫做半缺省\n\n注意：设置缺省参数的时候，必须从右往左设置，不能出现中间空一个的情况\n\n6.1.1全缺省比如这么一个有3个参数的函数，我们全部设置了缺省值，就是全缺省\nvoid Print(int a = 10, int b = 20,int c=30) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; c &lt;&lt; endl;&#125;\n\n我们可以直接传3个值，进行对应的打印，也可以只传两个、一个或者不传形参\n\n这种中间间隔一个传参是不允许的\n\n\n6.1.2半缺省半缺省是缺省了一部分的函数\nvoid Print2(int a, int b = 20, int c = 30) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; c &lt;&lt; endl;&#125;\n\n在调用的时候，我们就不能不传参数了\n\n至少要传一个参数给我们的a\n\n半缺省的函数可以是如下形式\nvoid Print2(int a, int b = 20, int c = 30);void Print2(int a, int b, int c = 30);\n\n但不能是这样\nvoid Print2(int a=10, int b, int c = 30);\n\n因为这种情况会出现歧义，编译器不知道你的参数是给b还是给a\n\n6.2缺省参数的应用比如在创建一个顺序表的时候，我们可以利用缺省参数来设置默认长度\n这样就避免了单一默认长度导致的多次扩容（realloc扩容是有性能浪费的！）\n\n\n比如我知道我这次需要一个很长的顺序表，直接改默认长度不太合适。使用这种方法传一个新的长度值更加方便我们的动态管理！\n\n缺省参数是只有C++才支持的函数定义方式，这也是C++比C语言更优的体现\n6.3多文件编程中的缺省使用多文件编程的时候，缺省值只需要在头文件中给出即可\n\n不需要在函数定义的源文件中给出，编译器会报错\n\n假设函数的声明和定义中设定的缺省值不同，编译器就不知道要用哪一个缺省值\n\n\n调用函数，可以看到函数正确分配了不同的初始值\n\n\n6.3.1错误情况但如果我们在头文件中不包含缺省，函数就会报错，不支持我们只传1个参数\nvoid InitArr(Qa* q, int n);\n\n\n只要你的头文件中声明没有缺省， 在函数定义的源文件中加入缺省也是没用的！\n\n因为编译器展开头文件是在main函数中之上，在查找函数的时候，只会向上查找声明。所以函数的声明是以头文件为准！\n\n\n\n结语第一篇C++的笔记就写这么多（其实已经有几千字了）\n下一篇笔记是函数重载，可以让你感受到C++的更多花样！\n\n不会有人把博客看完了还不点赞吧？\n\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：string","url":"/posts/1606342371/","content":"这是接触STL的第一篇博客，让我们以string为始，走入SLT的世界吧！\n\n\n[TOC]\n1.何为STLSTL是C++标准库的重要组成部分，其作用是为绝大多数数据结构提供轮子，是一个包罗了数据结构和算法的软件框架。\n在之前C语言的数据结构专栏中，顺序表、链表等等都是需要我们自己造轮子来实现。但在C++中，有STL就好比站在了巨人的肩膀上，可以走的更远。当我们需要使用这些内容时，无需自己重新造轮子，从而大大提高了开发效率。\n1.1 STL版本这里我直接贴一个C语言中文网的链接👉【点我】\n里面详细介绍了STL发展历程中出现的几个版本，其中SGI因为被Linux的GCC所使用，可移植性高。之后的博客主要是学习SGI STL版本。\n\n1.2 STL组成同样是C语言中文网的资料👉【链接】，我将它整理为了下面这个思维导图\n\n在面试中，STL的内容也是HR经常考察的。所以我们一定要认真学习这一部分的知识点！\n1.3 STL的一些吐槽如果你去Cplusplus网站上看过STL库的接口，你就会发现STL库的设计有些复杂。有很多地方都考虑的过于细致，导致函数接口非常多，想要全记住这些接口是有些困难的\n\n当然，这也是我自己太菜了的缘故。或许以后用的多了，这些就理所应当的记住了吧。\n同时，因为STL使用了模板，所以当你多次使用STL时（比如vector容器）就容易出现代码冗余\n\n好啦，不bb这些没用的了，还是直接进入正题string类吧！\n\n\n2.String\n参考cplusplus的标准文档：string\n\nstring类是表示字符串的字符串类，该类的接口和常规的容器基本相同，并添加了一些专门用于操作字符串的常规操作。使用string需要包含&lt;string&gt;和using namespace std;\n\n这里为什么是string而没有.h呢？\n其实编译器处理头文件并不会关注头文件的后缀，且C语言中已经有一个string.h了，为了避免冲突，所以使用了&lt;string&gt;作为头文件\n\n下面介绍一些常用的string类函数接口，标题中的英文和cplusplus网站中的分类对应\n2.1 编码格式在Class instantiations栏目下，可以看到string有很多不同的类，这些类的主要区别在于编码方式的不同。我们主要学习的是第一个的string类\n\n什么是编码格式呢？在编程学习中，比较常用的便是ASCii码，除此之外，还有utf-8、utf-16等等。\n\nASII码表中，英文单词、数字、各类标点符号都有它们对应的值，这样才能在只支持01二进制的电脑上显示出对应的内容。当计算机需要显示英文单词的时候，就会去查找这一个表。所以ASCII码表是漂亮国设计的。\n我们知道，英文中的基础只有26个单词，算上大小写也就52个。但是我们中华文化博大精深，计算机需要显示中文的时候，一个char类型的空间已经不够。所以我们需要整出一个我们自己的编码格式，以此让计算机支持显示中文——GBK就是这样一个编码格式\n\nGBK使用两个字节来存储一个汉字，一些不常用的生僻字可能需要3-4个字节来存储。\n用下面这个简单的函数来测试，我们可以发现，中文中谐音字的编码是相近的\n\n在网络上，我们打某些词汇会被替换成****，就是程序在后台实别了你的编码。同时如果想进行模糊匹配，把谐音字也屏蔽掉的话，就可以把这个词周围的编码全部屏蔽了。\n\n同理，utf-16和utf-32为了支持别的国家的语言，就会用更长的字节来存储文字。这里不进行详解。\n\n\nstring类有非常多的接口，我们并不需要完全掌握所有的函数接口。只需要学会常用的接口，在遇到一些不常用的，在需要使用的时候可以去查找cplusplus的文档。\n2.2 构造函数(constructor)\n下面是一些常用的string类的构造函数\n\n\n\n构造函数\n功能\n\n\n\nstring()\n空的string对象（空的字符串）\n\n\nstring(size_t n,char c)\nstring类对象中包含n个字符c\n\n\nstring(const char*s)\n利用常量字符串来构造对象\n\n\nstring(const string&amp;s)\n拷贝构造\n\n\n除此之外，在文档中我们还可以看到更多构造函数\n\n除此之外，我们还可以调用赋值操作符进行构造。下面是赋值重载的3个版本，想必都能看懂，是通过对象、常量字符串和字符进行赋值操作。\n\nstring类中也重载了流提取和流插入操作符，方便我们直接对对象进行输入输出操作。\n\n\n我们还可以选取一个范围进行构造，比如下面这个\n\n需要注意的是，该构造函数的第三个传参有缺省值npos\nstring (const string&amp; str, size_t pos, size_t len = npos);\n\n查文档可以看到，nops其实是-1，而它的类型是无符号整型，-1就代表无符号整形的最大值。即从pos位置开始，往后取最大值的长度（实际上压根没有那么长的字符串）\n\n2.3 析构函数(destructor)析构函数有个好处，就是编译器自己会进行调用，我们只需要简单了解即可。\n\n2.4 遍历string对象我们可以通过下面的3种方式来遍历一个string对象\nvoid test3()&#123;\t//尝试遍历一个string\tstring s1(&quot;hello world!&quot;);\t//1.重载[]\t//通过调用成员函数size得知长度\tcout &lt;&lt; &quot;operator[] &quot; &lt;&lt; endl;\tfor (int i = 0; i &lt; s1.size(); i++)\t&#123;\t\tcout &lt;&lt; s1[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//2.范围for\t//本质上调用的是迭代器\tcout &lt;&lt; &quot;auto &quot; &lt;&lt; endl;\tfor (auto c : s1)\t&#123;\t\tcout &lt;&lt; c &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//3.迭代器\t//在很多容器中是通用的\tstring::iterator it = s1.begin();//指向开头\t//end指向最后一个数据的下一个位置（即&#x27;\\0&#x27;)\tcout &lt;&lt; &quot;string::iterator &quot; &lt;&lt; endl;\twhile (it != s1.end())\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t\tit++;//使用方法类似指针\t&#125;\tcout &lt;&lt; endl;&#125;\n\n可以看到这三个方式都成功打印出了s1对象的完整内容\n\n其中范围for编译器在操作的时候是用迭代器来实现的，这一点通过查看汇编可以看出来\n\n2.5 operator[]和at（Element access）上面我们用到了operator[]重载，需要了解的是，这个重载返回的是值的引用。也就是说，我们除了可以用这个方式来访问值的内容以外，还可以通过这种方式来改变string中某一个位置的值。\n\nconst string s1(&quot;hello&quot;);s1[0]=&#x27;x&#x27;//此时调用的是const版本的重载，不可修改\n\nat函数的使用方式和[]重载类似\n\n区别就是，当operator[]遇到越界情况的时候，如果相等和小于长度，都不会报错。但是当下标大于长度时，会引发未定义行为\n\n而at()的处理方式是，只要长度不小于string的长度，就抛出异常\n\n2.6 正向和反向迭代器Iterators除了在2.2.3中使用过的正向迭代器以外，string还有一个反向迭代器rbegin\n//反向迭代器string::reverse_iterator rit = s1.rbegin();//指向结尾字符（&#x27;\\0&#x27;之前）//end指向开头数据的前一个位置while (rit != s1.rend())&#123;\tcout &lt;&lt; *rit &lt;&lt; &quot; &quot;;\trit++;//使用方法类似指针&#125;cout &lt;&lt; endl;\n\n这里需要注意的是，虽然这个迭代器是反向的，但是我们使用的时候，依旧会rit++而不是减\n\n注意，基本的迭代器是可读可写的。在string里面还实现了const的迭代器\nconst_iterator begin() const;const_reverse_iterator rbegin() const;\n\n如果你觉得这样写太麻烦，而且容易记不住。可以让auto来自动进行推导\nconst string s1(&quot;hello&quot;);auto rit = s1.rbegin();\n\nC++11中，为了和基本的方式进行区分，新增了以c为前缀的4个迭代器。其使用和const_iterator是没有区别的。\n\n\n2.7长度和容量操作Capacity\n2.7.1 size和length这其中size和length的功能完全相同。只是早期string设计的时候以length作为字符串的长度。在新版本中为了和其他接口比如List进行同步，又新增了一个size来表示字符串长度。\n\n\n2.7.2 resize和reserve\n注意区分reserve和reverse\n\n我们可以通过reserve对内存进行扩容操作，容量变大是因为需要内存对齐\n\n但在实际应用中，当字符串的容量快要写满的时候，程序会自动进行扩容，大概是1.5倍\n\n\n而resize的操作是修改string类的长度size，并同时进行扩容\nstring s1(&quot;hello&quot;);cout &lt;&lt; s1.capacity() &lt;&lt; endl;s1.resize(100);cout &lt;&lt; s1.capacity() &lt;&lt; endl;\n\n通过调试可以发现，这里会把size修改为100，并将多余内容全部初始化为0\n\n我们还可以给resize进行传参，指定初始化的内容\n\n\n同时，这两个函数一般都不会对容量进行缩容\n\n但是resize会修改size的大小，即抛弃掉10以后的内容，但保持容量不变\n\n需要注意的是，在VS2019中（不同编译器可能不一样），reserve如果传参小于15，则会对容量进行缩容到15（string对象默认会开辟15个字节的capacity）\n\n\n2.8修改内容（Modifiers）string可以通过很多方式来增加、删除内容\n2.8.1 尾插\n它们的基本使用如下，其中最方便的肯定是+=操作了，又清晰又简单！\n\n2.8.2 中间插入string并没有提供一个头插的选项，而是提供了一个Insert，可以在任何位置进行插入\n\ninsert函数的时间复杂度相对较高，因为在中间或者开头插入内容需要挪动数据。空间不够的时候还需要执行扩容操作，效率较低。\n\n2.8.3 删除可以通过erase函数删除数据\n\n\n1：默认从0开始完全删除，可以选择从pos位置开始删除len长度的数据\n2：利用迭代器删除p位置的内容\n3：删除一个范围的数据，从first开始last结束\n\n这个很容易理解，在这里就不做演示了\n2.8.4 替换这个函数使用并不频繁，其修改操作不如使用拷贝复制😂\n\n比如其中第二个函数的作用是将str对象中，从subpos位置开始的sublen长度内容复制到本对象中。\n2.8.5 交换在string类中有一个交换函数，同时，std标准库里面也有一个交换函数\ns1.swap(s2);//string类swap(s1,s2);//std标准\n\n\n\nstring类里面的函数是交换类对象的指针\n而标准库里面的swap函数需要进行深拷贝交换\n\n所以string类里面的swap函数在处理对象的时候，比标准库里面的swap效率会高一些\n2.9字符串操作（String operations）2.9.1 c_str这个接口的作用是返回一个字符串的指针，其主要是为了和C语言的一些函数对应，比如利用strcmp拷贝一个string对象到内置字符串char arr[]中。\n\n\n2.9.2 find这里可以看到非常多种类的查找函数（偷懒不写示例了）\n\n\nfind函数可以查找string中的某一个字符或者字符串，并返回起始位置的下标\n该函数默认从头开始查找，你也可以单独指定从pos位置开始查找\n\n\n\n和迭代器一样，rfind则是从末尾开始找指定内容\n\n有些时候我们需要查找的内容并不是从头开始的，所以就需要从尾部开始找。\n\nsubstr是从指定pos位置开始获取长度为len的子串\n\n\n\n2.10 很多操作符重载string里面有非常多的操作符重载，支持和字符串、字符、对象进行大小对比。虽然看的有点麻了，但实际上它们只是方便我们使用。底层实现了解一下就可以了（我这是不是废话…）\n \n其实一部分内容都是可以通过编译器的隐式类型转化或者临时构造一个string类来实现的，但是设计string的大佬们显然觉得多即是好，哈哈。\n3.模拟实现要想切切实实弄明白STL的源码结构，其中一个最好的办法就是尝试模拟实现一个和std库里面string使用方法&#x2F;功能相同的轮子。\n\n我的string模拟实现源码已经托管到gitee了【链接】\n\n其实string和vector就是一个简单的顺序表，其二者的底层差距主要在string只能保存字符（串），当然，内部的接口有一些细微的差距，这会在vector的博客里面进行讲解。\n大部分函数可以直接在gitee上面查看，我写了还算靠谱的注释，有任何问题可以在gitee或者本博客下留言。\n\n3.1 利用指针模拟实现迭代器从string开始，我们第一次接触了stl中的迭代器这一新鲜玩意。\n//反向迭代器string::reverse_iterator rit = s1.rbegin();//指向结尾字符（&#x27;\\0&#x27;之前）//end指向开头数据的前一个位置while (rit != s1.rend())&#123;\tcout &lt;&lt; *rit &lt;&lt; &quot; &quot;;\trit++;//使用方法类似指针&#125;cout &lt;&lt; endl;\n\n看起来很牛，实际上它的操作和我们自己写的指针大差不差。我们大可以直接使用指针来模拟实现出一个相同功能的迭代器！\n//迭代器相关const_iterator begin() const&#123;    return _a;&#125;const_iterator end() const&#123;    return _a + _size;&#125;iterator begin()&#123;    return _a;&#125;iterator end()&#123;    return _a + _size;&#125;//以下是string模拟实现中私有成员变量private:    char* _a;//实际存放数据    size_t _size;//有效长度    size_t _capa;//容量大小    const static size_t npos;//声明\n\n看吧，是不是很简单！🌃这个迭代器的使用方法和顺序表中的指针一模一样，这里就不演式啦！感兴趣的伙伴可以把源码考下来自己试试。\n\n3.2 深拷贝在之前类和对象的博客中，我已经简单实现过一次深拷贝（链接）\n对于string来说，深拷贝的操作和博客里面演示的是一样的，都是通过给予新的空间，然后用strcpy或者memset拷贝内容过去。\n//拷贝构造string(const string&amp; s)    :_size(s._size),\t_capa(s._capa)&#123;    _a = new char[_capa+1];    strcpy(_a, s._a);&#125;\n\n除了拷贝构造以外，赋值重载同样需要深拷贝操作，但是它的操作和构造函数又有些不同\n\n拷贝构造时，该对象还不存在，通过构造函数构造出内容\n赋值重载时，该对象可能已经有自己的数据，需要先释放已有的才能获取新的\n\n这就需要我们在赋值重载的时候，先delete掉原本的内容，再去进行赋值\n//深拷贝赋值重载string&amp; operator=(const string&amp; s) &#123;    //和拷贝构造不同的是，赋值重载之前，this可能已经有自己的内容了    //所以在执行操作之前，我们需要把this自己的内容先释放掉    if (this != &amp;s)//不要自己拷贝自己     &#123;        delete[] _a;//删除已有空间        _size = s._size;        _capa = s._capa;        //_a = new char[_capa + 1];//有一定风险        char* tmp = new char[_capa + 1];        strcpy(tmp, s._a);        _a = tmp;    &#125;&#125;\n\n这样我们的赋值重载便也实现完毕了\n3.3 关于insert函数操作字符和字符串的区间问题当我们使用insert来处理字符的时候，需要将插入位置之后的数据往后挪动。\n而insert字符串的时候，则需要挪动该字符串长度的数据。\n这时候就非常容易出现挪动不完整&#x2F;越界等等问题！\n关于insert代码可以看gitee代码的190-237行，如果你不太能理解这里的移动问题，最好的办法，就是画图！画图会让你清楚的认识到需要移动多长，指针应该指向哪里进行移动。理清思路后，写代码就会容易很多。\n3.4 关于push_back的边界控制问题之前我实现的代码中，尾插的时候没有加上\\0进行边界控制\n这一点需要注意，因为模拟实现的底层用的就是C语言的字符串。在每一次尾插之后，都需要用\\0来标记字符串的结尾。否在我们拷贝构造和reserve的时候使用strcpy就会出现越界错误。\n\n越界错误一般都是在析构delete的时候检查出来的\n\nvoid push_back(char ch)&#123;\tif (_size + 1 &gt;= _capa)\t&#123;\t\treserve(_capa == 0 ? 4 : _capa * 2);\t\t//这里的判断是为了辨别是否在空对象尾插\t&#125; \t_a[_size] = ch;\t_size++;\t//因为reserve和基础的拷贝构造用的都是strcpy\t//所以必须要有\\0来标识结尾！\t_a[_size] = &#x27;\\0&#x27;;&#125;\n\n\n结语关于string类的介绍到这里就结束啦！\n如果有什么新增内容的话，我会对本篇博客进行修改\n\n如果有什么问题，欢迎评论区提出哦！\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：stack/queue/priority_queue/deque","url":"/posts/3750929351/","content":"来喽，STL的栈和队列！\n\n\n[TOC]\n1.Stack栈是一个遵循LIFO规则的容器，即后进先出（last in first out）。后放入容器内的数据会先出来。\n\n如果你不太理解栈的性质，可以先看看我写的C语言栈的博客【链接】\n\n打开Cplusplus一看，栈的函数肉眼可见的少。这和我们C语言实现的功能基本是一样的。\n\n它甚至没有拷贝构造！\n\n1.1 容器适配器等会，这个container是什么玩意？\n别急，先让我们来看看栈的类定义👇\nstd::stacktemplate &lt;class T, class Container = deque&lt;T&gt; &gt; class stack;\n\n和之前不同的是，这里出现了container，和一个我们好像没有接触过的deque\n搜索后得知，deque也是一种容器，被称为双端队列\n\n\n那么栈为什么需要一个容器呢？\n\n实际上，栈不是直接写出来的代码，而是借用了deque这个容器，进行封装后的结果。\n意思就是，栈其实是解用了别人的代码！\n比如deque有头插头删，尾插尾删。而我们的栈只需要尾插尾删，那么我们包装一下deque，只提供尾插尾删的函数，不就成了栈了？\n\n1.2 模拟实现直接这么说可能有点干巴巴，我们直接上代码！\ntemplate&lt;class T, class Container = deque&lt;T&gt;&gt;class stack &#123;public:\tsize_t size()const &#123;\t\treturn _con.size();\t&#125;\t\tconst T&amp; top() &#123;\t\treturn _con.back();\t&#125;\tvoid push(const T&amp; val) &#123;\t\t_con.push_back(val);\t&#125;\tvoid pop() &#123;\t\t_con.pop_back();\t&#125;\tbool empty() &#123;\t\treturn _con.empty();\t&#125;private:\tContainer _con;&#125;;\n\n以上便是栈的模拟实现代码！\nWhat？这就结束了？——甚至写的比我们C语言版本的栈更少！\n\n本质上，我们只需要创建一个Container的对象 _con，再借助这个对象的函数进行封装，就完成了一个栈！\n因为模板里面默认传入的是deque，所以这里用的便是deque的函数了。这就好比函数传入了一个缺省值。你可以将deque换成其他有尾插尾删函数的容器，比如vector\n测试一下，莫得问题！\n\n\n2.queue和栈不同，队列遵循FIFO，即先进先出（first in first out）\n\n同样的，我们只需要包装一下容器，即可完成模拟实现\nstd::queuetemplate &lt;class T, class Container = deque&lt;T&gt; &gt; class queue;\n\n2.1 模拟实现template&lt;class T, class Container = deque&lt;T&gt;&gt;class queue &#123;public:\tsize_t size()const&#123;\t\treturn _con.size();\t&#125;\tconst T&amp; front()&#123;\t\treturn _con.front();\t&#125;\tconst T&amp; back()&#123;\t\treturn _con.back();\t&#125;\tvoid push(const T&amp; val)&#123;\t\t_con.push_back(val);\t&#125;\tvoid pop()&#123;\t\t_con.pop_front();\t&#125;\tbool empty()&#123;\t\treturn _con.empty();\t&#125;private:\tContainer _con;&#125;;\n\n需要注意的是，队列就不能用vector来当作容器辣！因为vector头插删的效率很低，需要挪动数据。我们可以使用list来当作容器\n\n当然，你可以把头插头删改成insert和erase，但是那样没有意义，依旧拖慢了效率\n因为栈和队列压根不支持迭代器，自然也没有迭代器失效问题！\n2.2 关于queue的front学习linux课程的时候，突然想到一个问题，如果queue里面是空的，那么我直接访问front会是什么情况？会出现异常吗？\n#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123;    printf(&quot;hello vscode!\\n&quot;);    queue&lt;int&gt; q;//不会报错，但是数据无效    cout &lt;&lt; q.front() &lt;&lt; endl;    return 0;&#125;\n\n在linux下用g++编译运行，发现获取到的值是0\n[muxue@bt-7274:~/git/test]$ ./testhello vscode!0\n\n简单概括，如果队列中没有数据，此时调用front接口不会报错，但是获取到的数据是无效的。\n个人猜测，这里能否获取到数据也和编译器的优化有关。比如相同的代码，在vs2019下，会直接报assert错误！\n\n所以，为了代码的兼容性，请严格检查调用front的时候队列里面有没有数据，stack的top同理\n\n了解完相对简单的栈和队列之后，我们可以直接来看看优先级队列\n3.priority_queue 优先级队列优先级队列和queue同属于头文件&lt;queue&gt;\ntemplate &lt;class T, class Container = vector&lt;T&gt;,  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;\n\n\n那么它和普通的队列有什么不同呢？\n\n优先级队列是一个堆，且默认是大堆\n\n如果你不知道堆是什么，可以看看我之前C语言数据结构的博客【链接】\n\n简单说来，堆的堆顶（这里是第一个数据）一直保持着最大值或者最小值。每一次插入、删除操作，都需要向上、向下重新调整容器内元素的位置\n3.1 make_heap这里简单说一下另外一个函数make_heap，这个函数可以通过迭代器区间，将区间内的数据调整为一个堆。\n\n在文档介绍里面可以看到，最后一行提到了优先级队列就是自动调用make_heap函数来维护自己堆的属性的\n\n3.2 函数接口优先级队列本质上还是一个队列，它提供的函数也很少\n不同的是，这里的top堆顶指的是容器中首个元素，pop也是移除堆顶元素\n\n3.3 仿函数\n注意这里出现了第三个模板参数，Compare\n这是一个仿函数，其就是一个类，但是仿照了函数的调用方式\n想做到这一点，我们需要重载()操作符\n//仿函数，重载（）操作符\ttemplate&lt;class T&gt;\tstruct less &#123;\t\tbool operator()(const T&amp; a, const T&amp; b)const\t\t&#123;\t\t\treturn a &lt; b;\t\t&#125;\t&#125;;\t//大于比较\ttemplate&lt;class T&gt;\tstruct greater&#123;\t\tbool operator()(const T&amp; a, const T&amp; b)const\t\t&#123;\t\t\treturn a &gt; b;\t\t&#125;\t&#125;;\n\n比如这里的less和greater就是两个仿函数，优先级队列需要用它来进行比较。这样我们就可以快速在大堆和小堆直接进行切换。\n它们的使用方式和函数是一样的！不过在使用之前，我们需要先创建一个对象\nless func;func(1,2);\n\n库函数中的less和greater都在&lt;functional&gt;这个头文件中\n\n\nstd库中优先级队列默认传的less小于比较，为大堆！\n我们可以手动传入greater，即可变成小堆\n\n3.4 模拟实现在3.3中，我们已经实现出了库函数中的less和greater这两个仿函数，接下来我们只需要包装一下优先级队列的接口，即可使用！\ntemplate &lt;class T, class Container = vector&lt;T&gt;,class Compare = less&lt;T&gt; &gt;\tclass priority_queue\t&#123;\tpublic:\t\tsize_t size()const &#123;\t\t\treturn _con.size();\t\t&#125;\t\tconst T&amp; top() &#123;\t\t\treturn _con[0];\t\t&#125;\t\tbool empty() &#123;\t\t\treturn _con.empty();\t\t&#125;\t\t//向上调整\t\tvoid AdjustUp(size_t child)\t\t&#123;\t\t\tCompare comFunc;\t\t\twhile (child &gt; 0)\t\t\t&#123;\t\t\t\tsize_t parent = (child - 1) / 2;\t\t\t\tif (comFunc(_con[parent],_con[child]))//小堆，小的数据往上调\t\t\t\t&#123;\t\t\t\t\tstd::swap(_con[parent], _con[child]);\t\t\t\t\tchild = parent;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t//向下调整\t\tvoid AdjustDown(size_t parent)\t\t&#123;\t\t\tCompare comFunc;\t\t\tsize_t child = parent * 2 + 1;//左孩子\t\t\twhile (child &lt; _con.size())\t\t\t&#123;\t\t\t\t//找左右孩子中小的那一个\t\t\t\tif (child + 1 &lt; _con.size() &amp;&amp; comFunc(_con[child], _con[child + 1]))\t\t\t\t&#123;//如果左孩子大于右孩子，则选择右孩子\t\t\t\t\tchild++;\t\t\t\t&#125;\t\t\t\tif (comFunc(_con[parent],_con[child]))\t\t\t\t&#123;\t\t\t\t\tstd::swap(_con[parent], _con[child]);\t\t\t\t\tparent = child;\t\t\t\t\tchild = parent * 2 + 1;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t//因为是优先级队列，所以需要进行调整\t\t//默认情况下第一个元素始终是最大元素\t\tvoid push(const T&amp; val) \t\t&#123;\t\t\t_con.push_back(val);\t\t\tAdjustUp(_con.size() - 1);\t\t&#125;\t\tvoid pop() \t\t&#123;\t\t\tassert(!_con.empty());\t\t\tswap(_con[0], _con[_con.size() - 1]);\t\t\t_con.pop_back();\t\t\tAdjustDown(0);\t\t&#125;\t\t\tprivate:\t\tContainer _con;\t&#125;;\n\n这里需要注意的便是adjustdown/up这两个用来维持堆属性的调整函数，你可以看我之前的博客，里面有关于这部分的详细解释！回到上面\n先来测试一下默认大堆的属性\n\n可以看到，打印出来的数据是按从大到小顺序存放的！\n如果我们显示传入greatre仿函数，就会变成从小到大\n\n同时，即便我们pop了一部分数据，也不会影响堆的属性\n\n优先级队列在一部分地方可以用于帮我们找到一段数据中的topK和第n个最大&#x2F;小的数据\n比如下面这道leetcode OJ题目215. 数组中的第K个最大元素\n\n我们只需要pop掉前面的K-1个元素，这时候的堆顶就是我们需要的第K个最大值\n\n4.deque前面已经提到了deque这个容器，它拥有的库函数和vector很相似，这里我们不关注如何使用这个容器，而是来谈谈这个“双端队列”相比于vector/list有没有什么优势\nstd::dequetemplate &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque;\n\n4.1存储结构deque最特殊的就是它的存储结构了。它并不是一个连续的结构，也不像链表一样每个数据都有自己的单独节点\n这个是百度百科上找到的一张图片\n\n\nhttps://www.cnblogs.com/yifengs/p/15190416.html\n\n其实deque有点类似二维数组，其中有一个头指针指向队列头，一个尾指针指向队列尾部。主数组“中控器”存放的则是这些数组的指针。注：每一个数组的容量大小都是一样的，所以存放在中间的数组一定是满的！\n\n这样我们就避免了list节点分散，需要多次开空间，无法随机访问的缺陷；又可以灵活快速地进行头插头删操作，而不需要挪动数据。\n当然，deque的随机访问性能肯定不如数据连续存储的vector，其更适合下面的场景：\n\n需要高性能的头插头删，尾插尾删\n偶尔需要进行随机访问\n\n结语关于栈和队列的部分到这里就结束辣！\n我们还认识了双端队列deque，以及让其作为容器的模拟实现操作\n\n有任何问题，欢迎评论提出！\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：vector","url":"/posts/3664653329/","content":"STL的第二站，便是vector了。\n\n\n对于学习STL，有一个非常大的好处便是，它们有很多函数都是相通的！这也是面向对象的一大好处：背后的函数实现可能不同，但是使用方式相同。\n1.简单了解vector\nhttps://m.cplusplus.com/reference/vector/vector/\n\n老样子，打开我们的cplusplus——然后惊奇的发现，它换UI了！终于不再是那个2000年初的模样了（虽然这和我们的使用没啥关系）\n\n不摸鱼了，来看看vector究竟是何方神圣——其实他就是一个顺序表\n和string不同的是，vector有模板参数，可以存储任何类型的内容。int、double、char、甚至string。\n这一点在cplusplus网站上的第一行便告诉了我们\n\ntemplate &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; // generic template\n\n你还可以看到，标题下方给了一个这样的类模板定义，其中T代表的是存放数据类型，allocator&lt;T&gt;也是STL库中的一部分，用于向堆申请空间（类似一个内存池）可以提高访问的效率\n前期的学习我们不需要知道allocator&lt;T&gt;是怎么实现的，只要知道它有这个功能就ok了。\n\n1.1函数接口往下滑，你会发现vector的函数接口，我们很多都已经学过了！\n\n这些函数的操作和string类型都是一样的，这里就不再讲解了！\n\n对比发现，其实vector多出来的函数并不多，这便是学习STL的好处！\n\n2.使用vector因为大部分函数的功能、操作和string一样，有问题可以去看看我之前string的博客\n2.1构造\n对于vector而言，比较常用的构造函数是下面这几个\n\n这里说说最后一个，利用迭代器进行初始化，它的使用如下\nstd::string s1(&quot;hello&quot;);vector&lt;char&gt; v2(s1.begin(),s1.end());for (auto ch : v2)&#123;\tcout &lt;&lt; ch &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;\n\n当我们已经有一个其他的支持迭代器的容器之后，便可以使用该容器的迭代器初始化一个vector\n这里的区间可以自行控制，对应的初始化的内容也会有所不同\n\n\n2.2迭代器vector的迭代器和string基本相同，都拥有正向和反向两种方式\n\n\n\n迭代器\n说明\n\n\n\nbegin+end\n获取第一个数据位置iterator&#x2F;const_iterator， 获取最后一个数据的下一个位置iterator&#x2F;const_iterator\n\n\nrbegin+rend\n获取最后一个数据位置的reverse_iterator，获取第一个数据前一个位置的 reverse_iterator\n\n\n\nvector&lt;int&gt;::iterator it = v.begin(); while (it != v.end()) &#123;     cout &lt;&lt; *it &lt;&lt; &quot; &quot;;     ++it; &#125;\n\n利用迭代器，我们可以打印vector的内容\n2.3迭代器失效问题在vector中的一些操作会导致迭代器失效，即迭代器指向的内容含义变了。包括但不限于：\n\n因为erase导致的数据擦除\n扩容导致的原有空间被释放（此时迭代器依旧指向原有空间）\n所有会导致扩容的操作\n\n这时候我们需要借助函数的返回值对it进行重新赋值，比如下图是erase和insert的返回参数\n\n\n我们只需要在使用迭代器遍历的时候用it来接受返回值（更新迭代器）就可以规避这个问题\nvoid test02()&#123;    vector&lt;int&gt; v1;    v1.push_back(1);    v1.push_back(2);    v1.push_back(3);    v1.push_back(4);    v1.push_back(5);    v1.push_back(6);    v1.push_back(7);    vector&lt;int&gt;::iterator it = v1.begin();    while (it != v1.end())    &#123;        if (*it % 2 == 0)//在偶数之前插入内容        &#123;            //不这样写会出现it的含义变化而导致的死循环            //程序内出现了扩容，it原先指向的空间已经被释放            it = v1.insert(it, 99);\t            it++;        &#125;        it++;    &#125;    for (auto ch : v1)    &#123;        cout &lt;&lt; ch &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n\n\n库里面的其他函数就不进行讲解啦，有问题的可以去看看之前string的博客。当然最好的学习办法就是依据cplusplus上面的函数定义，尝试自己弄明白这些库函数的使用方法。\n\n3.模拟实现\n代码详见我的gitee仓库【链接】STL-Vector的源码也在里面！\n\n和string类不同的是，在vector里面并不是用size和capacity这两个成员变量来确认有效长度和容量的。\n通过查看stl源码可以看到，其使用了3个迭代器进行标识\n\nprivate:    iterator _start;//指向开头（存放数据）    iterator _finish;//指向结尾的下一个    iterator _endofstorage;//指向空间尾部\n\n了解结构后，便可以先把无参构造和析构函数写出来待用\n//无参构造函数vector()    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123; &#125;//析构~vector()&#123;    if (_start)    &#123;        delete[] _start;        _start = _finish = _endofstorage = nullptr;    &#125;&#125;\n\n那么要怎么知道size和capacity的大小呢？很简单，通过指针相减即可得出结果\nsize_t size()const&#123;    return _finish - _start;&#125;size_t capacity()const&#123;    return _endofstorage - _start;&#125;\n\n3.0 迭代器在模拟实现一开始，我们就要用typdef定义两个迭代器，方便后面的使用\ntypedef T* iterator;typedef const T* const_iterator;iterator begin()&#123;    return _start;&#125;iterator end() &#123;    return _finish;&#125;const_iterator begin()const &#123;    return _start;&#125;const_iterator end()const &#123;    return _finish;&#125;\n\n3.1 reserve&#x2F;resize现在我们的vector内容还是空空的，我们需要先实现一下push_back函数，可以基本操作一下我们的数据。但没有构造函数去申请空间，哪来的目标给我们操作呢？\n\n这时候就需要先实现reserve来扩容和获取空间了！\n\n在扩容之前，我们需要获取原有数据的长度，再new将空间整出来，并给_start。操作结束后，我们需要修改_finish 和_endofstorage，否则这两个迭代器指向的还是原有空间，出现了迭代器失效问题\nvoid reserve(size_t n)//扩容&#123;    size_t sz = size();//计算原有的长度    if( n &gt; capacity())    &#123;        T* tmp = new T[n];        if (_start) //只有_start不为空才进行拷贝操作        &#123;            //memcpy是浅拷贝，当遇到vector类型是自定义类型（比如string和vector&lt;T&gt;这种包含堆区内存的类型）            //浅拷贝会失效，string的成员变量拷贝过去了，但是成员变量指向的堆区空间被释放，出现野指针            //memcpy(tmp, _start, size());            for (size_t i = 0; i &lt; size(); i++)            &#123;                tmp[i] = _start[i];//手动赋值，当成员是自定义类型的时候，会调用=重载            &#125;            delete[] _start;//释放原有空间        &#125;        _start = tmp;    &#125;    //这里必须要先计算sz，如果在这里直接调用sz的话：finish已经是野指针了，finish-start会出现问题    _finish = _start + sz;    _endofstorage = _start + n;&#125;\n\n关于为何拷贝内容的时候需要用&#x3D;而不能直接memcpy，后文会提到。\nresize和reserve唯一不同的一点，就是reserve会修改原有空间的数据，其余的实现是一样的。所以这里面我们直接复用reserve进行扩容即可\n//在C++中，内置类型也有一个“构造函数”//这是为了更好的支持模板操作void resize(size_t n,T val = T())&#123;    if (n &gt; capacity())    &#123;        reserve(n);    &#125;    if (n &gt; size())    &#123;        //初始化        while (_finish &lt; _start + n)        &#123;            *_finish = val;            ++_finish;        &#125;    &#125;    else    &#123;        _finish = _start + n;    &#125;&#125;\n\n注意，T()的含义是用模板参数的构造函数作为缺省值。在C++中，内置类型也可以进行这个操作\n\n当你不进行传值的时候，int类型默认是0\n\n3.2插入&#x2F;删除空间拿到了，现在就可以对我们的数据进行插入操作了\nvoid push_back(const T&amp; x)&#123;    if (_finish == _endofstorage)     &#123;        size_t newcapa = capacity() == 0 ? 4 : capacity() * 2;        reserve(newcapa);    &#125;    *_finish = x;    _finish++;&#125;void pop_back()&#123;    if (_finish &gt; _start)     &#123;\t\t_finish--;\t&#125;&#125;\n\n简单测试一下插入和删除功能，没啥问题\n\n更好的办法，其实是写好insert和earse，然后尾插尾删的时候直接复用即可\n//pos位置插入valiterator insert(iterator pos, const T x)&#123;    assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);    //assert(pos &gt;= _start &amp;&amp; pos &lt;= _endofstorage);    if (_finish == _endofstorage)    &#123;        size_t n = pos - _start;        size_t newcapa = capacity() == 0 ? 4 : capacity() * 2;        reserve(newcapa);        pos = _start + n;    &#125;    iterator end = _finish - 1;    while (end &gt;= pos)    &#123;        *(end + 1) = *end;        end--;    &#125;    *pos = x;    _finish++;    return pos;&#125;//删除数据iterator erase(iterator pos)&#123;    assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);    iterator tmp = pos;    iterator end = _finish - 1;    while (tmp &lt; end)    &#123;        *tmp = *(tmp + 1);        tmp++;    &#125;    _finish--;    return pos;&#125;\n\n因为这里我们只需要操作一个元素，所以就不需要担心移动多个数据可能导致的问题，事情也变得简单多了\nvoid push_back(const T&amp; x)&#123;    insert(end(),x);&#125;void pop_back()&#123;    erase(end()-1);&#125;\n\n尾插尾删操作直接复用源码即可\n3.3重载[ ]操作符因为vector本身只是个顺序表，所以我们需要对它的对象重载一下[]操作符，这样就能和数组一样去访问vector的数据\n//重载[]操作符T&amp; operator[](size_t pos)&#123;    assert(pos &lt; size());    return _start[pos];&#125;const T&amp; operator[](size_t pos) const&#123;    assert(pos &lt; size());    return _start[pos];&#125;\n\n\n关于构造函数，这里重点介绍一下迭代器区间的构造函数，因为后面的拷贝构造我们会用上它。\n3.4迭代器区间构造&#x2F;拷贝&#x2F;赋值库里面关于该构造函数的定义如下\ntemplate &lt;class InputIterator&gt;   vector (InputIterator first, InputIterator last,           const allocator_type&amp; alloc = allocator_type());\n\n因为这时候我的水平还很垃，就暂且不管这个 allocator了\n该函数需要我们传参两个迭代器，因为我们底层就是用指针实现的，所以直接解引用然后将内容尾插即可（如果没有空间，尾插会调用reserve来获取空间&#x2F;扩容）\ntemplate &lt;class InputIterator&gt;vector(InputIterator first, InputIterator last)    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123;    while (first != last)    &#123;        push_back(*first);        first++;    &#125;&#125;\n\n有了这个构造函数后，拷贝构造就很容易了！\nvoid swap(vector&lt;T&gt;&amp; v)&#123;    std::swap(_start, v._start);    std::swap(_finish, v._finish);    std::swap(_endofstorage, v._endofstorage);&#125;//拷贝构造vector(const vector&lt;T&gt;&amp; v)    :_start(nullptr),_finish(nullptr),_endofstorage(nullptr)&#123;    vector&lt;T&gt; tmp(v.begin(), v.end());    swap(tmp);&#125;\n\n利用迭代器区间构造出来一个tmp对象，再将该对象和我们本身进行交换即可！\n\n你可能会问：欸你这样交换了，原本的内容岂不是没人管了，有内存泄漏啊！\n\n并不是这样的，我们使用库函数里面的swap交换了二者的成员变量，在拷贝构造函数完成之后，tmp生命周期结束，会自动调用构造函数处理掉我们的数据！\n这就是让别人帮你干活😂\n赋值重载就跟简单了，我们连tmp变量都不需要弄，直接使用传值（会自动调用拷贝构造一个临时变量）就可以啦！\n//赋值重载（v没有引用，拷贝构造一个新的传参过来，所以不需要手动再构建一个tmp）vector&lt;T&gt;&amp; operator=(vector&lt;T&gt; v)&#123;    swap(v);    return *this;&#125;\n\n3.5用n个value进行构造在库中的vector还有一个这样的构造函数，用n个val进行初始化\n\n因为我们之前已经实现了一个相关功能的函数resize，我们只需要调用resize就可以完成这个操作！\n//利用n个val进行构造vector(size_t n, const T&amp; val = T())    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123;    resize(n, val);&#125;\n\n只实现一个vector(size_t n, const T&amp; val = T())的版本是不可以的，因为我们忽略了一种情况\nvector&lt;char&gt; v1(10,&#x27;x&#x27;)//可以成功调用vector&lt;int&gt;  v2(10,11) //不能成功调用！ \n\n\n为啥第二种情况不行呢？再来看看另外一个构造函数，我们之前实现过的迭代器区间构造\ntemplate &lt;class InputIterator&gt;vector(InputIterator first, InputIterator last)\n\n你会发现，当我们传的两个参数都是int类型的时候，编译器会直接调用这个模板函数！因为first和last就是两个相同类型的参数！\n通过调试也可以看到在进行构造的时候，调用了这个迭代器区间构造函数\n\n为了避免这种情况，我们需要对int类型单独处理一下，修改一下传参即可\n//如果不单独重载一个int类型版本，就会被识别成上面的模板函数//int是不能当作迭代器进行解引用的，会报错vector(int n, const T&amp; val = T())    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123;    resize(n,val);&#125;\n\n\n这个问题是怎么发现并解决的？\n\n我们可以直接查看stl源码，瞅瞅库里面是怎么实现的\n\n可以看到库里面不但重载了一个int类型的版本，还重载了long长整型的情况\n到这里，我们的模拟实现就基本完成了！\n\n3.6关于自定义类型的拷贝问题为什么在3.1的reserve实现中，我使用了赋值重载，而没有使用memcpy？\n来看看下面这个OJ题目杨辉三角的代码\n\nleetcode118杨辉三角：https://leetcode.cn/problems/pascals-triangle/submissions/\n\nclass Solution &#123;\tpublic:\t\tvector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;\t\t\tvector&lt;vector&lt;int&gt;&gt; vv;\t\t\tvv.resize(numRows);\t\t\tfor (size_t i = 0; i &lt; vv.size(); ++i)\t\t\t&#123;\t\t\t\t// 杨辉三角，每行个数依次递增\t\t\t\tvv[i].resize(i + 1, 0);\t\t\t\t// 第一个和最后一个初始化成1\t\t\t\tvv[i][0] = 1;\t\t\t\tvv[i][vv[i].size() - 1] = 1;\t\t\t&#125;\t\t\tfor (size_t i = 0; i &lt; vv.size(); ++i)\t\t\t&#123;\t\t\t\tfor (size_t j = 0; j &lt; vv[i].size(); ++j)\t\t\t\t&#123;\t\t\t\t\tif (vv[i][j] == 0)\t\t\t\t\t&#123;\t\t\t\t\t\t// 中间位置等于上一行j-1 和 j个相加\t\t\t\t\t\tvv[i][j] = vv[i - 1][j - 1] + vv[i - 1][j];\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\treturn vv;\t\t&#125;\t&#125;;\n\n在这里面，我们有两层vector进行嵌套使用，外层的vector存放的是内层vector的对象。\n它的结构如下图\n\n这时候如果只用memcpy进行浅拷贝，相当于新的空间里面存放的是的确是新的vector对象，但这些vector对象存放的却是原有数据的指针，而原本的数据已经被我们delete掉了，出现了野指针问题！\n反应到代码上，当我们在 Solution内部进行一次打印，再在外部进行一次打印，结果就会完全不同\nvoid test05()&#123;    vector&lt;vector&lt;int&gt;&gt; ret = Solution().generate(5);    cout &lt;&lt; &quot;外部打印&quot; &lt;&lt; endl;    for (size_t i = 0; i &lt; ret.size(); ++i)    &#123;        for (size_t j = 0; j &lt; ret[i].size(); ++j)        &#123;            cout &lt;&lt; ret[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;\n\n\n使用赋值重载，就可以进行深拷贝，每一个vector对象都能获得新的值，也就不会出现这个问题！\n//reserve代码的一部分for (size_t i = 0; i &lt; size(); i++)&#123;    tmp[i] = _start[i];//手动赋值，当成员是自定义类型的时候，会调用=重载&#125;\n\n\n3.7 emplace_back()和push_back()的区别emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。\n\npush_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；\n而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。\n\nemplace_back是C++11添加的，定义如下\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n而C++11中也给push_back提供了一个右值引用方式的重载，这时候右值的操作就会调用移动构造了；\nvoid push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); // C++11\n\n测试在这个自定义类型中，我实现了全缺省的默认构造，以及拷贝构造和移动构造；\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class inclass &#123;public:\tinclass(int a = -10,const string&amp; info = &quot;dft&quot;) :_a(a),_str(info) &#123;\t\tcout &lt;&lt; &quot;init inclass | &quot; &lt;&lt; info &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; endl;\t&#125;\tinclass(const inclass&amp; d):_a(d._a),_str(d._str) &#123;\t\tcout &lt;&lt; &quot;init inclass copy | &quot; &lt;&lt; _str &lt;&lt; &quot; &quot; &lt;&lt;  d._a &lt;&lt; endl;\t&#125;\tinclass(const inclass&amp;&amp; d) :_a(d._a), _str(std::move(d._str)) &#123;\t\tcout &lt;&lt; &quot;init inclass copy&amp;&amp; | &quot; &lt;&lt; _str &lt;&lt; &quot; &quot; &lt;&lt; d._a &lt;&lt; endl;\t&#125;\tint _a;\tstring _str;&#125;;int main()&#123;\tvector&lt;inclass&gt; v;\tv.reserve(15);\tcout &lt;&lt; &quot; -----  &quot; &lt;&lt; endl;\tinclass tmp_copy(-1, &quot;tmp_copy&quot;);\tinclass tmp_move(-2, &quot;tmp_move&quot;);\tcout &lt;&lt; &quot; -----  &quot; &lt;&lt; endl;\tv.push_back(tmp_copy);\tv.push_back(std::move(tmp_copy));\tv.push_back(inclass(3,&quot;push back&quot;));\tv.push_back(std::move(inclass(4, &quot;push back move&quot;)));\tv.push_back(&#123; 10,&quot;push back initializer list&quot; &#125;);\t// v.push_back(15,&quot;push back direct_init&quot; ); // 不支持\tcout &lt;&lt; &quot; -----  &quot; &lt;&lt; endl;\tv.emplace_back(tmp_move);\tv.emplace_back(std::move(tmp_move));\tv.emplace_back(inclass(5,&quot;emplace back&quot;));\tv.emplace_back(std::move(inclass(6, &quot;emplace back move&quot;)));\t// v.emplace_back(&#123; 20,&quot;enplace back initializer list&quot; &#125;);// 不支持\tv.emplace_back( 30,&quot;enplace back direct_init&quot; );\treturn 0;&#125;\n\n最终输出结果如下，可以看到在这之前，所有的插入操作都会先构建这个临时对象，再调用移动构造来插入到vector中，即便采用初始化列表，也是会去构造临时对象的；因为零时对象是将亡值，所以调用的都是移动构造。\n -----init inclass | tmp_copy -1init inclass | tmp_move -2 -----init inclass copy | tmp_copy -1init inclass copy&amp;&amp; | tmp_copy -1init inclass | push back 3init inclass copy&amp;&amp; | push back 3init inclass | push back move 4init inclass copy&amp;&amp; | push back move 4init inclass | push back initializer list 10init inclass copy&amp;&amp; | push back initializer list 10 -----init inclass copy | tmp_move -2init inclass copy&amp;&amp; | tmp_move -2init inclass | emplace back 5init inclass copy&amp;&amp; | emplace back 5init inclass | emplace back move 6init inclass copy&amp;&amp; | emplace back move 6init inclass | enplace back direct_init 30\n\n而emplace_back采用了完美转发，支持直接传入参数作为自定义类型的构造函数的参数，所以可以看到最后一个插入操作中只有一次构造，而没有任何拷贝构造！\n结语到这里，vector的模拟实现就完成啦！通过模拟实现可以让我们更好的理解vector容器的结构，也方便后续的使用！\n有任何问题，都可以在评论区提出哦！\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：list","url":"/posts/1456870854/","content":"阿巴阿巴，list的博客来喽！\n\n\n[TOC]\n1.list是嘛玩意？之前的vector是一个顺序表。总所周知，学完顺序表肯定不能不学链表，所以list就来了！\n\nlist是一个可以在任何地方进行插入删除的序列式容器，可以进行前后双向迭代\n\n说人话就是：list是一个双向带头循环链表\n\n这不巧了嘛！之前我写过用C语言实现双向带头循环链表的博客\n其优缺点也很明显\n\n支持快速插入删除O(1)\n支持前后双向迭代访问\n不支持任意位置的随机访问\n\nSTL中的list也满足上面的这些优缺点\n话不多说，来看看list的函数接口吧！\n\nhttps://m.cplusplus.com/reference/list/list/\n\n函数接口大部分接口和前面所学的两个容器都是一样的啦，这里就不贴完整截图了（见上方链接）\n\n这里还多了一个emplace_front，看完函数解释后可知它也是一个头插\n\n2.简单了解使用2.1构造list支持的构造函数如下\n\n这些函数和vector完全一致，这里就不过多介绍了\n\n2.2迭代器\n\n\n迭代器\n说明\n\n\n\nbegin+end\n获取第一个数据位置iterator&#x2F;const_iterator， 获取最后一个数据的下一个位置iterator&#x2F;const_iterator\n\n\nrbegin+rend\n获取最后一个数据位置的reverse_iterator，获取第一个数据前一个位置的 reverse_iterator\n\n\n都是老样子，没有啥好说的\n\n除了迭代器以外，一般的容器都会提供front和back两个参数来访问头部&#x2F;尾部数据。但是我们并不常用这个，迭代器用的更多一些\n2.3长度操作库函数中给我们提供了两个和list长度相关的操作，因为是链表，所以也不存在扩容问题，每一个节点都是一个独立的空间\n\n\nempty 判断是否为空，是空返回true\nsize 计算list中有效数据长度\n\n关于插入和删除操作，list和vector/string基本都是一致的，学会一个基本都会用！\n2.4迭代器失效问题和vector一样，list也会遇到一定程度的迭代器失效问题。\n因为list是一个链表，其在插入操作的时候是在迭代器所指节点前一个位置进行插入，不会影响该节点和这个节点之后的结构，也不会导致迭代器失效。\n\n只有在删除的时候才会导致迭代器失效\n\n解决办法也很简单，使用迭代器删除数据的时候，接收返回值更新一下迭代器即可！\n\n基本了解了函数接口后，让我们来试试模拟实现吧！\n3.模拟实现\n模拟实现和STL-list源码见我的Gitee\n\n下图是之前C语言版本链表博客里，我画的双向带头循环链表的结构图\n\nlist的结构和这个图片是一样的。但因为我们现在所使用的是C++中的类和对象，所以我们的操作都需要尊崇stl库的命名规则和使用方法，其结构的实现也会有所不同。\n比如在STL源码中可以看到，list的主结构中只有一个node，即头节点。\n\n3.1 节点结构在list中，我们不直接在list主类中放入单个节点的结构，而是使用一个自定义类型作为节点。\n\n复习：在struct中，成员默认是共有\n\ntemplate&lt;class T&gt;   struct list_node   &#123;       list_node&lt;T&gt;* _next;       list_node&lt;T&gt;* _prev;       T _data;       list_node(const T&amp; val = T())           :_next(nullptr),       \t_prev(nullptr),       \t_data(val)       &#123;&#125;   &#125;;\n\n这样后面的插入删除操作就可以直接new一个新的node，并调用构造函数完成_data的赋值。\n在list的主类中，我们遵循库的方法，只用一个头节点的指针作为成员\nprivate:\tNode* _head;//头节点指针\n\n\n3.2 插入删除因为之前写过C语言的代码，关于插入和删除操作相对较为熟练，代码如下👇\n//在pos之前插入iterator insert(iterator pos, const T&amp; x)&#123;    Node* newnode = new Node(x);    Node* cur = pos._node;    newnode-&gt;_next = cur;    cur-&gt;_prev-&gt;_next = newnode;    newnode-&gt;_prev = cur-&gt;_prev;    cur-&gt;_prev = newnode;    return iterator(newnode);&#125;//删除pos位置iterator erase(iterator pos)&#123;    assert(_head-&gt;_next != _head &amp;&amp; pos._node!=_head);    Node* next = pos._node-&gt;_next;    Node* prev = pos._node-&gt;_prev;    prev-&gt;_next = next;    next-&gt;_prev = prev;    delete pos._node;    return iterator(next);&#125;\n\n而头插&#x2F;头删&#x2F;尾插&#x2F;尾删这类方法，我们直接复用insert和earse即可！\n\n\n3.3 迭代器（重要）在上面的插入和删除代码中，我已经使用了迭代器作为参数和返回值。由于list的主类中并没有直接存放3.1节点结构，我们需要自己单独完成一个迭代器的类，来实现迭代器的相关操作\n\nvector&#x2F;string是顺序表，迭代器可以直接用指针替代，在本类中模拟实现\nlist是顺序表，迭代器的+和-操作其实是通过next和prev指针往后往前找内容，所以需要单独的模拟实现\n\n在STL源码中的list也是单独重载了一个迭代器类\n\n其基本结构如下\ntemplate&lt;class T, class Ref, class Ptr&gt;struct __list_iterator&#123;    typedef list_node&lt;T&gt; Node;//节点结构    typedef __list_iterator&lt;T, Ref, Ptr&gt; self;//本类    Node* _node;//存放节点指针        __list_iterator(Node* node)\t\t:_node(node)\t&#123;&#125;&#125;\n\n这里解释一下为何有3个模板参数：ref指代引用，ptr指代指针\n因为在后续的操作中我们需要传入T的引用T&amp;和指针T*，如果之传入一个T，编译器无法确认是否为const类型，也就无法阻止用户使用迭代器修改值，成员的数据就不够安全，且const的成员函数无法调用迭代器。\n重载3个模板参数后，我们就可以用传入的模板参数来控制指针和引用是否为const类型\ntypedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;typedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n\n基本的结构弄清楚之后，下面一起来看看，迭代器的++和--，解引用以及指针-&gt;分别对应了链表的什么操作呢？\n3.3.1 加减好吧，前面已经提到过了，我们需要用\tnext/prev指针来完成加减操作\n//前置++self&amp; operator++()&#123;    _node = _node-&gt;_next;    return *this;&#125;//后置++self operator++(int)&#123;    //self是本类的别名，因为没有重载=操作符    //所以不能使用相等，要用构造函数    //self tmp = _node;    self tmp(*this);    _node = _node-&gt;_next;    return tmp;&#125;//前置--self&amp; operator--()&#123;    _node = _node-&gt;_prev;    return *this;&#125;//后置--self operator--(int)&#123;    self tmp(*this);    _node = _node-&gt;_prev;    return tmp;&#125;\n\n注意前置和后置的区别，后置加减需要先用一个tmp变量储存原本的迭代器位置，再让迭代器指向下一个节点\n而当我们解引用迭代器的时候，想获取的其实是_data的值，而不是节点的地址（这里迭代器依旧是用指针模拟的）\n3.3.2 解引用和指针操作所以重载后的解引用操作如下\nRef operator*()&#123;    return _node-&gt;_data;//返回值的引用&#125;Ptr operator-&gt;()&#123;    return &amp;(_node-&gt;_data);//返回地址&#125;\n\n3.3.3 判断相等&#x2F;不相等最后判断相等和不相等就很简单了，因为本身就是指针，我们直接调用原生的!=进行判断即可\nbool operator!=(const self&amp; it)&#123;    return _node != it._node;&#125;bool operator==(const self&amp; it)&#123;    return _node == it._node;&#125;\n\n到这里，一个建议版本的正向迭代器我们就实现啦！\n\n3.3.4 begin&#x2F;end这里我们需要在List的本类中获取迭代器的begin和end，这里我们是调用了迭代器的构造函数，构造出来一个迭代器并进行返回\nconst_iterator begin() const&#123;    //return _head-&gt;_next;//不能直接返回指针！！    return const_iterator(_head-&gt;_next);&#125;const_iterator end() const&#123;    return const_iterator(_head);&#125;iterator begin()&#123;    return iterator(_head-&gt;_next);&#125;iterator end()&#123;    return iterator(_head);&#125;\n\n现在就可以愉快的用迭代器进行打印操作了！\n\n\n3.4 构造函数有了迭代器，现在就可以完成库函数里面的几个构造函数了（主要是迭代器区间的那个函数）\n默认构造函数如下，先创建一个头节点，再让它的前后都指向自己。在C语言的初始化函数中，我们也是这么做的\nlist()   \t:_head(nullptr)   &#123;       //_head = new Node;       _head = new Node();       _head-&gt;_next = _head;       _head-&gt;_prev = _head;   &#125;\n\n但其他的构造函数由于_head为空，所以我们需要单独实现一个空初始化函数来创建头节点\n//当使用其他构造函数的时候，head还不存在，需要手动构造一个void empty_init()&#123;    _head = new Node();    _head-&gt;_next = _head;    _head-&gt;_prev = _head;&#125;\n\n当然，上面那个空的构造函数list()也可以复用empty_init()，这样代码更整洁\n迭代器区间构造和vector是一样的，其主要是解引用后直接将值进行头插（这里就用上了之前迭代器里重载的解引用操作）\ntemplate &lt;class InputIterator&gt;list(InputIterator first, InputIterator last)&#123;    empty_init();    InputIterator cur = first;    while (cur != last)    &#123;        //push_back(cur._node-&gt;_data);        push_back(*cur);        cur++;    &#125;&#125;\n\n而拷贝构造就可以直接复用迭代器区间构造，赋值重载就直接swap即可。这部分的实现和vector是一样的，有问题可以在评论区提出哦！\nvoid swap(list&lt;T&gt;&amp; lt)&#123;    std::swap(_head, lt._head);&#125;list(const list&lt;T&gt;&amp; lt)&#123;    empty_init();    list tmp(lt.begin(), lt.end());    swap(tmp);&#125;list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt)&#123;    //传参没有传引用，lt已经是拷贝构造之后的结果了    //完全没必要再用tmp拷贝构造一次    //list&lt;T&gt; tmp(lt);    //clear();//因为tmp出了生命周期后会销毁，所以不需要手动clear    swap(lt);    return *this;&#125;\n\n\n3.5 析构函数因为链表需要我们一个一个去删除每一个节点的空间，这里需要单独实现一个clear函数供析构函数使用\nvoid clear()&#123;    //assert(_head-&gt;_next != _head);    iterator it = begin();    while (it != end())    &#123;        //需要用一个临时变量储存该节点的迭代器，避免迭代器失效        iterator its = it;        it++;        delete its._node;    &#125;&#125;~list()&#123;    clear();    delete _head;&#125;\n\n上面这个函数就有些麻烦，我们其实可以直接复用erase进行删除操作+更新迭代器！\nvoid clear()&#123;    iterator it = begin();    while (it != end())    &#123;        it = erase(it);    &#125;&#125;\n\n到这里，一个基本的list就模拟实现完成了！\n3.6 操作自定义类型我们刚刚实现的list和STL库中的一样，都可以存放自定义类型\nstruct TA&#123;\tTA(int a1 = 0, int a2 = 0)\t\t:_a1(a1),\t\t_a2(a2)\t&#123;&#125;\tint _a1;\tint _a2;&#125;;void test03()&#123;\tlist&lt;TA&gt; lt;\tlt.push_back(TA(1, 1));\tlt.push_back(TA(2, 2));\tlt.push_back(TA(3, 3));\tlt.push_back(TA(4, 4));\t//这里因为TA类的流插入没有重载，所以需要我们手动写\tlist&lt;TA&gt;::iterator it = lt.begin();\twhile (it != lt.end())\t&#123;\t\tcout &lt;&lt; it-&gt;_a1 &lt;&lt; &quot;-&quot; &lt;&lt; it-&gt;_a2 &lt;&lt; &quot; &quot;;\t\t++it;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n但在打印和访问自定义类型的时候，我们重载的解引用操作符就不能用了，这就是为啥要重载-&gt;操作符，此时我们还可以通过-&gt;获取到迭代器所指的对象的成员，这时候直接打印成员变量即可！\n\n你可能觉得，这不对啊！之前重载的这个操作符不是返回的节点_data的地址吗？为啥可以直接访问_data的成员？\nPtr operator-&gt;()&#123;    return &amp;(_node-&gt;_data);//返回地址&#125;\n\n实际上，这里应该是it-&gt;-&gt;_a1，但是编译器在处理的时候直接将两个访问箭头简化成了一个，即增加了代码可读性，也方便使用了！\n\n3.7 反向迭代器（适配问题）关于反向迭代器，这里牵扯到一个更深的适配问题。我用我的笨话稍微解释一下，有问题或者有啥错误的话欢迎在评论区提出！😂\n我们知道，反向迭代器是从后往前走的，它的加减操作和正向迭代器相反。\n那么比起单独实现一个反向迭代器的类，我们可否利用正向迭代器，直接适配出一个反向迭代器呢？毕竟看起来它们只有方向不同！\n3.7.1 显式规定模板参数Ref和Ptrtemplate&lt;class Iterator, class Ref, class Ptr&gt;struct Reverse_iterator&#123;\tIterator _it;\ttypedef Reverse_iterator&lt;Iterator, Ref, Ptr&gt; Self;              Reverse_iterator(Iterator it)\t\t:_it(it)\t&#123;&#125;   &#125;;\n\n说上就上，这里我们先将反向迭代器设定为和正向相似的结构，不过它的模板参数变成了正向迭代器，而不是参数类型T，这在后续typdef的时候需要注意（不然会报错）\n除了下面的解引用操作之外，其他只需要吧正向迭代器反过来用，就可以达到我们的目的！\nRef operator*()&#123;    Iterator tmp = _it;    return *(--tmp);//反向迭代器解引用访问的是前一个位置的数据&#125;Ptr operator-&gt;()&#123;    return &amp;(operator*());&#125;\n\n解引用访问前一个数据的原因是，我们判断结束是用!=rend()，而rend()指向的是列表的第一个有效数据，如果直接解引用当前内容，最后一个数据就无法访问到，出现了缺漏\n\n//前置++Self&amp; operator++()&#123;    --_it;    return *this;&#125;//前置--Self&amp; operator--()&#123;    ++_it;    return *this;&#125;bool operator!=(const Self&amp; s)&#123;    return _it != s._it;&#125;\n\n更加完整的源码可以去看我的Gitee仓库哦！\n\n完成了上面的代码后，我们需要在list本类里面进行一波操作，让它能够支持反向迭代器\n//支持反向迭代器typedef Reverse_iterator&lt;iterator, T&amp;, T*&gt; reverse_iterator;typedef Reverse_iterator&lt;const_iterator, const T&amp;, const T*&gt; const_reverse_iterator;\n\n注意上面的模板参数，第一个模板参数需要传入正向迭代器，而不是T\n//调用反向迭代器的构造函数reverse_iterator rbegin()&#123;    return reverse_iterator(end());&#125;reverse_iterator rend()&#123;    return reverse_iterator(begin());&#125;const_reverse_iterator rbegin()const&#123;    return const_reverse_iterator(end());&#125;const_reverse_iterator rend()const&#123;    return const_reverse_iterator(begin());&#125;\n\n用一个打印代码便可以测试出我们的操作是否正确！\n可以看到，完美逆向打印出了内容！\n\n利用正向迭代器进行适配的最大好处，那就是其他模拟实现的容器也可以直接调用这个反向迭代器，只要在本类中加入上面的typedef和4个函数即可！\n就以上篇博客的vector为例，加上上述代码后，她也能支持反向迭代器了！（源码也上传到仓库里面了）\n\n3.7.2 调用正向迭代器中的类型除了在反向迭代器的模板定义中直接定义反向迭代器中Ref/Ptr这两个参数类型，还可以从正向迭代器中去取出来这两个参数的类型；\n首先需要在正向迭代器__list_iterator中新增如下两个typedef\n// 为了让反向迭代器能统一获取到Ref和Ptr，标准库中的迭代器都定义了这两个typedeftypedef Ptr pointer;typedef Ref reference; \n\n能看到stl的list迭代器源码中同样存在这两个typedef\n\n随后在反向迭代器中，可以按下下面的方式写来取出正向迭代器中的类型\ntemplate&lt;class Iterator, class Ref, class Ptr&gt;struct Reverse_iterator&#123;\tIterator _it;\ttypedef Reverse_iterator&lt;Iterator, Ref, Ptr&gt; Self;\tReverse_iterator(Iterator it)\t\t:_it(it)\t&#123;&#125;\t// 从正向迭代器里面取迭代器中Ref和Ptr的类型\tIterator::reference operator*()\t&#123;\t\tIterator tmp = _it;\t\treturn *(--tmp);//反向迭代器解引用访问的是前一个位置的数据\t&#125;\tIterator::pointer operator-&gt;()\t&#123;\t\treturn &amp;(operator*());\t&#125;&#125;\n\n在list的主体中，还需要将反向迭代器的定义修改为如下形式\n//支持反向迭代器typedef Reverse_iterator&lt;iterator&gt; reverse_iterator;typedef Reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;\n\n此时直接执行g++进行编译，会报错如下内容，说让我们在类型前面添加一个typename；\n\n这是我们第二次遇到typename关键字，上一次遇见是在模板中的模板参数声明。\n在这里typename的作用是告诉编译器Iterator::reference是一个类型，需要等正向迭代器Iterator的这个模板类成功实例化了之后，再去查看这个参数的类型是什么。如果不加上这个关键字，编译器会立马去康这个参数的类型，结果发现这玩意是个模板参数，压根没办法知道类型是什么，那就只能给你报错了。 \ntypename Iterator::reference operator*()&#123;\tIterator tmp = _it;\treturn *(--tmp);//反向迭代器解引用访问的是前一个位置的数据&#125;typename Iterator::pointer operator-&gt;()&#123;\treturn &amp;(operator*());&#125;\n\n加上typename后重新编译，此时就没有出现报错了。\n\n//通过迭代器打印链表\tvoid print_list(list&lt;int&gt;&amp; s)\t&#123;\t\tlist&lt;int&gt;::iterator it = s.begin();\t\twhile (it != s.end())\t\t&#123;\t\t\t//*it = 10;//使用非const迭代器的时候可以修改值\t\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t\t\tit++;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;\tvoid R_print_list(list&lt;int&gt;&amp; s)\t&#123;\t\tlist&lt;int&gt;::reverse_iterator it = s.rbegin();\t\twhile (it != s.rend())\t\t&#123;\t\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t\t\tit++;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;\tvoid test01()\t&#123;\t\tlist&lt;int&gt; s1;\t\ts1.push_back(1);\t\ts1.push_back(2);\t\ts1.push_back(3);\t\ts1.push_back(4);\t\tprint_list(s1);\t\tR_print_list(s1);    &#125;\n\n执行一下测试代码，能看到其成功实现了正向迭代器和反向迭代器的使用操作。\n$ ./test1 2 3 4 4 3 2 1 \n\n我们还可以在反向迭代器中再进行一层typedef，将正向迭代器中的类型改个名字。在typedef中同样需要加上typename\ntemplate&lt;class Iterator&gt;struct Reverse_iterator&#123;\tIterator _it;\t//typedef Reverse_iterator&lt;Iterator, Ref, Ptr&gt; Self;\ttypedef Reverse_iterator&lt;Iterator&gt; Self;\t// 再进行一层typedef（同样需要带上typename）\ttypedef typename Iterator::reference reference;\ttypedef typename Iterator::pointer pointer;\tReverse_iterator(Iterator it)\t\t:_it(it)\t&#123;&#125;\t// 可以查看下面这个截图里面的说明\t// https://img.musnow.top/i/2023/12/65785f40a03b4.png\t// 从正向迭代器里面取迭代器中Ref和Ptr的类型\treference operator*()\t&#123;\t\tIterator tmp = _it;\t\treturn *(--tmp);//反向迭代器解引用访问的是前一个位置的数据\t&#125;\tpointer operator-&gt;()\t&#123;\t\treturn &amp;(operator*());\t&#125;       // 其他部分和3.7.1是相同的   &#125;\n\n编译成功，无报错\n\n\n3.7.1中的方式vector同样可以使用，但vector是不能使用3.7.2里面的这种方式来进行反向迭代器的适配的。\n这是因为在自主实现vector的操作中，我们使用了原生的类型指针来作为迭代器；此时我们是没有办法在指针（内置类型）里面定义typedef Ptr pointer的，也就没有办法获取到这个迭代器的指针和引用的类型，自然也就没有办法使用typename的方式让编译器来帮我们推测反向迭代器中Ptr/Ref的类型了。\ntemplate&lt;class T&gt;\tclass vector\t&#123;\tpublic:\t\ttypedef T* iterator;\t\ttypedef const T* const_iterator;\t\t//支持反向迭代器\t\ttypedef Reverse_iterator&lt;iterator, T&amp;, T*&gt; reverse_iterator;\t\ttypedef Reverse_iterator&lt;const_iterator, const T&amp;, const T*&gt; const_reverse_iterator;    \t//...    &#125;\n\n要想解决这个问题，有三种解决办法\n\n和list的自主实现一样，不使用内置类型，而是再制作一个自定义类型作为vector的迭代器\n而STL中使用了一个较为复杂的解决办法，即特化和萃取（这两个有点难理解，会在模板的进阶博客中说明）\n参考3.7.1，在反向迭代器的模板参数填入Ref/Ptr这两个模板参数\n\n3.7.3 typename上文中提到，typename是用于告知编译器该参数名是一个类型，需要在模板实例化之后再去查看具体的类型是什么。下面是一个简单的测试用例来复现这个场景\n#include&lt;iostream&gt;#include&lt;list&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;void print_list(const list&lt;T&gt;&amp; lt)&#123;\tlist&lt;T&gt;::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;template&lt;class Container&gt;void print_container(const Container&amp; lt)&#123;\tContainer::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;void test_print_list()&#123;\tlist&lt;int&gt; lt1;\tlt1.push_back(1);\tlt1.push_back(2);\tlt1.push_back(3);\tlt1.push_back(4);\tprint_list(lt1);\tprint_container(lt1);\tlist&lt;string&gt; lt2;\tlt2.push_back(&quot;a&quot;);\tlt2.push_back(&quot;b&quot;);\tlt2.push_back(&quot;c&quot;);\tlt2.push_back(&quot;d&quot;);\tprint_list(lt2);\tprint_container(lt2);&#125;\n\n上面代码中的两个函数，都尝试直接获取了模板类型中的const_iterator迭代器作为cit参数的类型，直接编译会出现如下的报错\n$ g++ test.cpp -o test -std=c++11test.cpp: In function ‘void print_list(const std::__cxx11::list&lt;T&gt;&amp;)’:test.cpp:11:2: error: need ‘typename’ before ‘std::__cxx11::list&lt;T&gt;::const_iterator’ because ‘std::__cxx11::list&lt;T&gt;’ is a dependent scope  list&lt;T&gt;::const_iterator cit = lt.begin();  ^~~~~~~test.cpp:11:25: error: expected ‘;’ before ‘cit’  list&lt;T&gt;::const_iterator cit = lt.begin();                         ^~~~                         ;test.cpp:12:9: error: ‘cit’ was not declared in this scope  while (cit != lt.end())         ^~~test.cpp: In function ‘void print_container(const Container&amp;)’:test.cpp:23:2: error: need ‘typename’ before ‘Container::const_iterator’ because ‘Container’ is a dependent scope  Container::const_iterator cit = lt.begin();  ^~~~~~~~~test.cpp:23:27: error: expected ‘;’ before ‘cit’  Container::const_iterator cit = lt.begin();                           ^~~~                           ;test.cpp:24:9: error: ‘cit’ was not declared in this scope  while (cit != lt.end())         ^~~test.cpp: In instantiation of ‘void print_list(const std::__cxx11::list&lt;T&gt;&amp;) [with T = int]’:test.cpp:40:16:   required from heretest.cpp:11:2: error: dependent-name ‘std::__cxx11::list&lt;T&gt;::const_iterator’ is parsed as a non-type, but instantiation yields a type  list&lt;T&gt;::const_iterator cit = lt.begin();  ^~~~test.cpp:11:2: note: say ‘typename std::__cxx11::list&lt;T&gt;::const_iterator’ if a type is meanttest.cpp: In instantiation of ‘void print_container(const Container&amp;) [with Container = std::__cxx11::list&lt;int&gt;]’:test.cpp:41:21:   required from heretest.cpp:23:2: error: dependent-name ‘Container::const_iterator’ is parsed as a non-type, but instantiation yields a type  Container::const_iterator cit = lt.begin();  ^~~~~~~~~test.cpp:23:2: note: say ‘typename Container::const_iterator’ if a type is meanttest.cpp: In instantiation of ‘void print_list(const std::__cxx11::list&lt;T&gt;&amp;) [with T = std::__cxx11::basic_string&lt;char&gt;]’:test.cpp:49:16:   required from heretest.cpp:11:2: error: dependent-name ‘std::__cxx11::list&lt;T&gt;::const_iterator’ is parsed as a non-type, but instantiation yields a type  list&lt;T&gt;::const_iterator cit = lt.begin();  ^~~~test.cpp:11:2: note: say ‘typename std::__cxx11::list&lt;T&gt;::const_iterator’ if a type is meanttest.cpp: In instantiation of ‘void print_container(const Container&amp;) [with Container = std::__cxx11::list&lt;std::__cxx11::basic_string&lt;char&gt; &gt;]’:test.cpp:50:21:   required from heretest.cpp:23:2: error: dependent-name ‘Container::const_iterator’ is parsed as a non-type, but instantiation yields a type  Container::const_iterator cit = lt.begin();  ^~~~~~~~~test.cpp:23:2: note: say ‘typename Container::const_iterator’ if a type is meant\n\n取其精华，能看到最主要的报错是 ‘cit’ was not declared in this scope，意思是cit这个变量在当前作用域中没有声明。\n这不就很奇怪了，明明我已经声明了这个参数了呀，还给他赋值了！\n原因前面便提到过了，这是因为编译器没有办法推测出这两个模板参数在未实例化之前的变量类型，此时可以理解为这个模板中的类型是一个虚拟类型，并非真实确定了的参数类型。最终就导致cit参数看似实例化了，实际上并没有。\n// cit 变量到底是什么类型？不知道！Container::const_iterator cit = lt.begin();list&lt;T&gt;::const_iterator cit = lt.begin();\n\n我们要做的就是给这两个变量的声明都加上typename的关键字\ntemplate&lt;class T&gt;void print_list(const list&lt;T&gt;&amp; lt)&#123;\ttypename list&lt;T&gt;::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;template&lt;class Container&gt;void print_container(const Container&amp; lt)&#123;\ttypename Container::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n此时编译和运行都成功了。\n[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ g++ test.cpp -o test -std=c++11[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ ./test1 2 3 4 1 2 3 4 a b c d a b c d \n\n当然，如果我们类模板的参数类型的确定的，那就不需要有typename关键字；比如下方list已经确定是int类型了，那么迭代器的类型自然也是可以被确定下来的。\nvoid print_list_int(const list&lt;int&gt;&amp; lt)&#123;\tlist&lt;int&gt;::const_iterator cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n编译无报错\n[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ g++ test.cpp -o test -std=c++11[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$\n\n当然，使用auto关键字也是可以的的，不会报错，也不需要带上typename；这是因为auto已经告诉了编译器这里是一个参数类型，只需要在lt.begin()返回的时候，根据返回值的参数来取cit变量的参数类型就可以了。\ntemplate&lt;class T&gt;void print_list_auto(const list&lt;T&gt;&amp; lt)&#123;\tauto cit = lt.begin();\twhile (cit != lt.end())\t&#123;\t\tcout &lt;&lt; (*cit) &lt;&lt; &quot; &quot;;\t\tcit++;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n测试一下\nvoid test_print_list()&#123;\tlist&lt;int&gt; lt1;\tlt1.push_back(1);\tlt1.push_back(2);\tlt1.push_back(3);\tlt1.push_back(4);\tprint_list(lt1);\tprint_list_int(lt1);\tprint_list_auto(lt1);\tprint_container(lt1);&#125;\n\n结果\n[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ g++ test.cpp -o test -std=c++11[muxue:~/code/c/c_cpp/cpp/22-07-14 list/reverse_iterator]$ ./test1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 \n\n我们要记住的是：只要从未实例化的类模板中取参数类型，都需要加上typename关键字来指定！\n结语本次list的模拟实现，我们尝试模拟了一个更加详细的迭代器类，并实现了反向迭代器\n有任何问题，或者本博客有错误，都欢迎在评论区提出哦！\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】搜索二叉树/KVL树","url":"/posts/1396203902/","content":"暑假已经过去一半了，你的作业写的怎么样了？\n不八八这些没啥用的了，本篇博客让我们来认识一下搜索二叉树以及KVL树，也为后续学习map和set打下基础。\n\n\n\n在之前，我写过一篇用C语言实现的二叉树博客。如果你想了解二叉树的基本定义，可以看看👉 【传送门】\n\n[TOC]\n前言树是我们生活中非常常见的玩意，其特点便是从下而上有非常多的分叉\n\n\n数据结构中的树便是以该特点命名的，每一个节点会有左右两个分叉来链接左右子树，从而构成一种数据结构。\n1.搜索二叉树所谓搜索二叉树（二叉查找树），便是致力于方便搜索的一种数据结构，其具有一下特点：\n\n比该节点大的数存放在右边\n比该节点小的数存放在左边\n\n这样当我们去遍历一颗搜索二叉树的时候，就可以很方便的通过大小比较找到其内部是否包含我们需要搜索的节点。这样在理想状态下，搜索的时间复杂度能控制在O(logN)，还是非常快的一个搜索算法！\n因为搜索二叉树主要用于搜索而不是存储数据，所以一般情况下的搜索二叉树是不允许数据冗余的。即相同的值只会存储一次\n\n同时，搜索二叉树可作为排序算法的一种。当我们用中序遍历搜索二叉树，得到的结果是有序的\n\n\n1.1 基本构建想要构建一个搜索二叉树，首先我们需要一个树的节点的结构\ntemplate&lt;class K&gt;struct BSTreeNode&#123;public:\tBSTreeNode* _left;\tBSTreeNode* _right;\tK _key;//元素\tBSTreeNode(K key)\t\t:_left(nullptr),\t\t_right(nullptr),\t\t_key(key)\t&#123;&#125;&#125;;\n\n\n为何不直接把这个结构定义在二叉树的class里面？\n因为那样会产生数据冗余而且非常不方便调用成员函数\n\n在搜索二叉树的功能实现类中，我们只需要定义一个根部节点即可\ntemplate&lt;class K&gt;class BSTree&#123;typedef BSTreeNode&lt;K&gt; Node;//方便使用private:    //成员变量\tNode* _root=nullptr;&#125;\n\n\n1.2 插入有了基本结构以后，我们就可以写一个插入函数来进行最基本的操作了\n\n当root为空的时候，需要给根节点开一个空间\nroot不为空，定义prev和cur两个指针进行遍历，通过大小判断来找寻正确的插入位置（左边小，右边大）\n找到正确位置后，构造新节点并进行插入操作\n\n使用bool作为返回值是因为我们需要判断是否成功插入。如果成功插入了为true，没有成功插入代表该搜索二叉树内已经包含了相同键值的节点。\nbool Insert(K key)&#123;    if (_root == nullptr)    &#123;        _root = new Node(key);//根为空，直接开空间插入        return true;    &#125;    Node* prev = nullptr;    Node* cur = _root;    while (cur)    &#123;        if (key &gt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_right;        &#125;        else if (key &lt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_left;        &#125;        else        &#123;            return false;//有相同元素不执行插入        &#125;    &#125;\t//创建节点进行插入    cur = new Node(key);    //保存prev指针就是为了操控它的父亲来链接节点    if (key &gt; prev-&gt;_key) &#123;        prev-&gt;_right = cur;    &#125;    else&#123;        prev-&gt;_left = cur;    &#125;    return true;&#125;\n\n除了循环版本，我们还可以写一个递归版本\nbool InsertR(const K&amp; key)//实际调用的函数&#123;    return _InsertR(_root, key);&#125;\t//使用引用，这时候的root就是上一个节点的左右子树的别名//修改root的同时也会修改上一个子树的左右节点//也可以用二级指针来完成这个操作，原理相同bool _InsertR(Node*&amp; root, const K&amp; key)&#123;    //空代表走到叶子了，执行插入    if (root == nullptr) &#123;        Node* newNode = new Node(key);        root = newNode;        return true;    &#125;    if (key &gt; root-&gt;_key) &#123;        _InsertR(root-&gt;_right, key);    &#125;    else if (key &lt; root-&gt;_key) &#123;        _InsertR(root-&gt;_left, key);    &#125;    else &#123;        return false;//不插入相同值    &#125;&#125;\n\n此类二叉树的递归思路最好用画图来理清。需要明白每一个节点是怎么返回的\n\n关于分支递归思想可以看看【链接】，这有助于你理解本文中的递归实现\n\n上面的递归问题便是将原本利用循环进行左右寻找的操作化为往下调用下一课子树。简单来来说就是老师要班长、班长找小组长、小组长找组员这样分配工作。\n只有走到最后的组员（空节点）我们才执行插入操作\n1.3 中序打印插入完成了，要怎样才能看到节点中的内容呢？来个中序遍历吧！\n我们需要重写一个递归函数，因为在类外面无法访问到私有成员root，无法直接给该函数传参。如果想维持类的封装性，也可以把这个函数定义为private成员\n    void InOrder()//中序遍历    &#123;        _InOrder(_root);    &#125;//private:    void _InOrder(Node* root)    &#123; //递归打印        if (root == nullptr)            return ;        _InOrder(root-&gt;_left);        cout &lt;&lt; root-&gt;_key &lt;&lt; &quot; &quot;;        _InOrder(root-&gt;_right);    &#125;\n\n关于前中后序遍历的内容在之前C语言的博客中有过讲解，这里就不再赘述\n\n\n1.4 查找既然是搜索二叉树，那便必须要有查找函数。\n其实在插入操作中，我们便已经把查找函数的思路写出来了（即判断是否是重复节点）\n//搜索二叉树一般不直接操作节点，不需要返回节点的指针//Node* Find(const K&amp; key)bool Find(const K&amp; key)&#123;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (key &gt; cur-&gt;_key)\t\t&#123;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (key &lt; cur-&gt;_key)\t\t&#123;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn true;\t\t&#125;\t&#125;\treturn false;&#125;\n\n同样，也可以写一个递归版本。当节点的值相等时返回true，如果走到空了代表这棵树里面没有这个节点，返回false\nbool FindR(const K&amp; key)//实际调用的函数&#123;    return _FindR(_root, key);&#125;//递归实现bool _FindR(Node* root, const K&amp; key)&#123;    if (root == nullptr) &#123;        return false;    &#125;    if (key &gt; root-&gt;_key) &#123;        _FindR(root-&gt;_right, key);    &#125;    else if (key &lt; root-&gt;_key) &#123;        _FindR(root-&gt;_left, key);    &#125;    else &#123;        return true;    &#125;&#125;\n\n1.5 删除(较难)在搜索二叉树中删除节点并没有那么容易，因为我们需要保证删除节点后，树还满足搜索二叉树的特征。如果删除了之后破坏树的结构还不管他，那就是err了。\n以下面的这棵树为例，它满足搜索二叉树的基本特征\n\n\n假设我们需要删除节点4，这很容易，只需要让3的右子树为空，再delete掉4的节点即可。\n但如果我们想删除6，事情就没那么简单了。我们需要找一个节点，来替补它的位置\n\n那么，谁可以胜任这个新的位置呢？\n答：左子树的最大节点or右子树的最小节点\n\n在删除6的情况下，左子树的最大节点为4，右子树的最小节点为7。你会发现，将它们换上这个位置，的确满足搜索二叉树的特性\n\n那么，怎么可以把这两个节点给替换上来呢？\n这一套操作其实挺麻烦的\n\n先找到需要删除的节点，会有下面3种情况：\n该节点只有左娃\n该节点只有右娃\n该节点左右都有\n\n\n如果是前两种情况（包括没有孩子的情况），我们只需要删除这个节点之后，让它的父亲指向它的孩子就行了（托管）\n只有左娃，父节点托管左娃\n只有右娃，父节点托管右娃\n\n\n左右都有孩子，需要找到左子树最大节点&#x2F;右子树最小节点，进行交换\n\n只是交换还远远不够，我们还需要链接这个最大&#x2F;最小节点的孩子（比如上图中7的情况）再删除掉被交换过去的指定节点\n\n//删除去找左子树的最大节点，或者右子树的最小节点//与需要删除的树进行交换，交换之后删除叶子节点bool Erase(const K&amp; key)&#123;    Node* prev = nullptr;    Node* cur = _root;    while (cur)    &#123;        if (key &gt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_right;        &#125;        else if (key &lt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_left;        &#125;        else        &#123;            if (cur-&gt;_left == nullptr)//只有右娃            &#123;                if (cur == _root)                &#123;                    _root = _root-&gt;_right;                &#125;                else                &#123;                    if (prev-&gt;_left == cur)                    &#123;                        prev-&gt;_left = cur-&gt;_right;                    &#125;                    else &#123;                        prev-&gt;_right = cur-&gt;_right;                    &#125;                &#125;                delete cur;            &#125;            else if (cur-&gt;_right == nullptr)//只有左娃            &#123;                if (cur == _root)                &#123;                    _root = _root-&gt;_left;                &#125;                else                &#123;                    if (prev-&gt;_left == cur)                    &#123;                        prev-&gt;_left = cur-&gt;_left;                    &#125;                    else &#123;                        prev-&gt;_right = cur-&gt;_left;                    &#125;                &#125;                delete cur;            &#125;            else //左右都有孩子            &#123;                //将cur和右子树的最小值节点进行交换                Node* minPrev = cur;                Node* minRight = cur-&gt;_right;                while (minRight-&gt;_left)                &#123;                    minPrev = minRight;                    minRight = minRight-&gt;_left;                &#125;                swap(minRight-&gt;_key, cur-&gt;_key);                if (minPrev-&gt;_left == minRight)                &#123;                    minPrev-&gt;_left = minRight-&gt;_left;                &#125;                else &#123;                    minPrev-&gt;_right = minRight-&gt;_left;                &#125;                delete minRight;            &#125;            return true;        &#125;    &#125;    return false;&#125;\n\n执行之后可以看到，删除之后的树依旧是一个搜索二叉树，中序遍历结果呈有序\n\n递归删除写完了循环版本，再来个递归吧！\nbool _EraseR(Node*&amp; root, const K&amp; key)&#123;    //根直接为空，返回false    if (root == nullptr) &#123;        return false;    &#125;    if (key &gt; root-&gt;_key) &#123;        _EraseR(root-&gt;_right, key);    &#125;    else if (key &lt; root-&gt;_key) &#123;        _EraseR(root-&gt;_left, key);    &#125;    else     &#123;        Node* del = root;//保存变量用于删除        if (root-&gt;_left == nullptr)//只有右娃        &#123;            /*if (root == _root) &#123;\t\t\t\t\t_root = _root-&gt;_left;\t\t\t\t&#125;*/            //这时候root是操作节点的别名，不需要单独对根节点进行处理            root = root-&gt;_right;        &#125;        else if (root-&gt;_right == nullptr)        &#123;            root = root-&gt;_left;        &#125;        else //左右都有孩子        &#123;            //将cur和右子树的最小值节点进行交换            Node* minRight = root-&gt;_right;            //while (minRight) //err            while (minRight-&gt;_left) //判断的是left，不然会走到空然后交换            &#123;                minRight = minRight-&gt;_left;            &#125;            swap(minRight-&gt;_key, root-&gt;_key);            return _EraseR(root-&gt;_right, key);        &#125;        delete del;        return true;    &#125;&#125;\n\n在最后一个情况中，我们巧妙地将问题化为了在指定节点的右子再次执行一次删除操作\n\n为什么在递归的操作中我们不需要单独处理minPrev呢？\n注意看函数的接口。删除的递归操作需要才用一个很巧妙的做法，使用了引用参数，充分利用了函数传值时传引用的特点（别名）\nbool _EraseR(Node*&amp; root, const K&amp; key)\n\n这时候的节点root不仅是当前递归到的节点，同时也是上一个节点的左右节点的别名。对该节点的操作会直接改变上一个节点的左右子树，就省去了我们手动操作的步骤！\n\n对root的修改会直接同步道上一个节点的孩子上\n\n怎么样，是不是超级赞！\n\n2.KVL树2.1 概念KV指代的是两个模板参数key和value。其实现和上面的搜索二叉树完全相同，只需要修改一下模板参数，以及所有操作key的位置都需要添加第二个参数value。\n\n源码实现见我的代码仓库 链接\n\n这么做的好处是，我们可以给一个key添加第二个绑定的参数了。一般把这种绑定关系称为&lt;Key,Value&gt;键值对\nKVL树的特点如下：\n\n排序依据key来排序，而不是value\nkey不可以修改，但是value可以修改\n在保存键值关系的同时，去重+排序\n\n通过这两个参数的绑定关系，我们可以实现类似字典、水果出现次数等等问题的查找操作，有点类似于数组映射，但这种方法更加便捷\n\n2.2 示例插入4个水果和其数量，中序遍历打印后，可以看到数据是以key为排序标准的。\n这里说明的是，string也是可以比较大小的，所以同样适用于搜索二叉树\n\n通过这种类似的绑定关系，我们甚至可以添加更多参数进入搜索二叉树。可以完成类似学生管理系统/车牌管理系统中学号车牌号和用户的绑定关系\n2.3 允许数据冗余我们可以简单修改一下插入函数，来达到允许数据冗余的目的。即插入相同key的时候，判断value，如果value也是相同则不插入，不同则插入。这样可以让kvl树中同一个key有多种对应关系，在字典多义词的时候有一定作用\n//插入，通过传引用避免拷贝bool _InsertR(Node*&amp; root, const K&amp; key, const V&amp; value)&#123;    if (root == nullptr)    &#123;        root = new Node(key, value);        return true;    &#125;    if (root-&gt;_key &lt; key)        return _InsertR(root-&gt;_right, key, value);    else if (root-&gt;_key &gt; key)        return _InsertR(root-&gt;_left, key, value);    else&#123;        if (root-&gt;_value == value)            return false;        else&#123;            //将相同数据插入在右边            return _InsertR(root-&gt;_right, key, value);        &#125;    &#125;&#125;\n\n插入了之后，我们删除也需要删除两次。\n\n这时候我们EraseR返回值为bool的价值就体现出来了，我们可以直接写一个循环来删除掉多个冗余键值\n\n\n结语这两颗树的讲解到这里就结束啦，学习它们是为了后续学习map/set打基础哦！\n\n有什么问题欢迎在评论区提出！\n\n","categories":["遇见C++"],"tags":["C++","数据结构","树"]},{"title":"【C++】红黑树的性质和实现","url":"/posts/3503649261/","content":"上篇博客我们了解了AVL树，这篇博客就让我们来看看另外一个二叉树：红黑树\n\n使用的编译器：VS2019\n\n\n\n[TOC]\n\n博客里面引用了一些百度搜到的图片（自己懒的画了，呜呜）\n1.概念AVL树是一个几乎完全平衡的搜素二叉树，其左右子树的高度差不会超过1。与之相对应的，是每一次插入都有可能需要旋转多次，插入的效率较低。\n而红黑树则选择了“相对平衡”，并拥有以下的特性：\n\n红黑树可以保证最长路径的小于最短路径的2倍\n\n比如最短路径为30，那么最长路径就不能超过60\n\n\n对于cpu来说，AVL树遍历20次（百万级数据）和红黑树遍历40次的时间差距极小。所以红黑树即保持了相对平衡，又减小了AVL树多次旋转的消耗。\n\n1.1 性质其通过下面的几点来维持这一性质：\n\n每一个节点不是红色就是黑色\n根节点一定是黑色\n每一个红节点的左右子树都是黑色\n每一个到叶子（空节点NIL）的支路上黑节点数量相同\n叶子节点（空节点NIL）视作黑色\n\n为什么满足了这几个情况，就满足了红黑树的最长路径的小于最短路径的2倍的性质呢？\n约束4和5，保证了红黑树的大致平衡：根到叶子的所有路径中，最长路径不会超过最短路径的2倍。这使得红黑树在最坏的情况下，也能有O(logN) 的查找效率\n\n黑色高度为3时，最短路径：黑色→ 黑色 →黑色\n最长路径：黑色→红色 →黑色 →红色 →黑色\n此时最短路径的长度为2（不算Nil的叶子节点），最长路径为4\n\n这里可以得出一个普遍规律，红黑树最短路径即为全黑路径。而最长路径是一黑一红间隔的情况\n1.2 时间复杂度平衡二叉树（AVL树）和红黑树都是常用的自平衡二叉搜索树。它们的查询操作的平均时间复杂度都为O(log n)，其中n是树中节点的数量。\n在平衡二叉树中，任意节点的左子树和右子树的高度差不超过1，通过局部旋转操作可以保持平衡。这样，树的高度始终保持在O(log n)的水平，从而使得查询操作的时间复杂度为O(log n)。\n红黑树是一种更加复杂的自平衡二叉搜索树，它通过对节点进行染色（红色或黑色）和旋转操作来保持平衡。红黑树具有以下性质：\n根据上文提到的红黑树性质，红黑树的高度始终保持在O(log n)的水平，因此查询操作的时间复杂度也为O(log n)。\n综上所述，平衡二叉树和红黑树的查询平均时间复杂度都是O(log n)。最差情况中，两个数的节点高度都不会超过 2log(n+1)，所以最坏的时间复杂度还是O(log N)\n\n2.设计一颗红黑树在设计红黑树的时候，我们需要牢记上面的5点。其中前4点非常重要且不可以被破坏。一旦被破坏，就影响了红黑树的基本性质。\n2.1 设计节点和AVL树一样，我们需要把节点单独成一个类，来存放我们需要的pair\n这里就设计到了颜色的初值应该给什么。红色，还是黑色？\n来看看性质3和4：\n\n红色的左右子树必须是黑色\n每一个到叶子（空节点NIL）的支路上黑节点数量相同\n\n简单思考，即可发现，插入红节点的时候，更好控制。而插入黑节点极有可能破坏性质4且较难修复。\n//枚举，定义颜色enum Color&#123;\tRED,//0\tBLACK,//1&#125;;//节点类template&lt;class K, class V&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;K, V&gt;* _left;\tRBTreeNode&lt;K, V&gt;* _right;\tRBTreeNode&lt;K, V&gt;* _parent;\tpair&lt;K, V&gt; _kv;\t//AVL树的平衡因子，在红黑树中为颜色\tColor _col;\t//插入节点的时候，默认为红色\t//因为这个满足性质3且不会破坏性质4\tRBTreeNode(const pair&lt;K, V&gt;&amp; kv)\t\t:_kv(kv),\t\t_left(nullptr),\t\t_right(nullptr),\t\t_parent(nullptr),\t\t_col(RED)\t&#123;&#125;&#125;;\n\n2.2 插入的几种情况节点设计好了，我们只需要把插入的逻辑搞定，那么红黑树也就完成了！\n前半部分的代码和AVL树完全相同，只不过我们需要手动给根节点一个黑色（默认是红色）以维持性质2\nbool Insert(const pair&lt;K, V&gt;&amp; kv)&#123;\t//判断root为空，即空树\tif (_root == nullptr)\t&#123;\t\t_root = new Node(kv);\t\t_root-&gt;_col = BLACK;//这里必须要手动给黑色\t\treturn true;\t&#125;\t//kv树的操作\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;\t\t//利用key来判断，寻找待插入的位置\t\tif (cur-&gt;_kv.first &lt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (cur-&gt;_kv.first &gt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse &#123;\t\t\treturn false;\t\t&#125;\t&#125;\t//找到位置后插入节点\tcur = new Node(kv);\tif (parent-&gt;_kv.first &lt; kv.first)\t&#123;\t\tparent-&gt;_right = cur;\t&#125;\telse\t&#123;\t\tparent-&gt;_left = cur;\t&#125;\tcur-&gt;_parent = parent;       //调整       //……  &#125;\n\n2.2.1 情况1：无需旋转在下面的这种情况中，我们在p的左边插入了一个cur新节点。此时违反了性质3，红节点的孩子必须要是黑节点。\n这种情况必须满足p和u都是红节点\n\n随后我们就需要开始向上进行更新，操作如下：\n\n把p和u都改成黑节点\n把g改成红节点\n\n修改之后的结果如下，即不影响性质3；也保证了黑节点的个数不变，维持了性质4\n\n需要注意的是，这里的g不一定是根节点。所以在操作完这一课子树之后，我们需要继续向上进行操作，避免g的父节点是红色的情况。\n\n代码实现如下（以父节点为g的左子树为例）\n//插入之后需要向上更新颜色,只有出现连续红色之后才需要更新while (parent &amp;&amp; parent-&gt;_col==RED)&#123;    //p是g的左    if (parent == grandpa-&gt;_left)    &#123;        Node* uncle = grandpa-&gt;_right;        //情况1：插入后p是红，u存在且是红（不需要旋转）        if (uncle &amp;&amp; uncle-&gt;_col == RED)        &#123;            uncle-&gt;_col = BLACK;            parent-&gt;_col = BLACK;            grandpa-&gt;_col = RED;//祖父变成红            //继续向上调整            //cur = cur-&gt;_parent;            //parent = parent-&gt;_parent;            cur = grandpa;            parent = cur-&gt;_parent;        &#125;    &#125;    else&#123;        //....    &#125;&#125;\n\n需要注意的是，这种调整会把g改成红节点。如果G是根节点，改成红色之后就不符合性质了。所以我们需要在操作完成之后，统一把根节点改成黑色\n//不管是什么情况，最后都把根改成黑，符合条件2_root-&gt;_col = BLACK;\n\n2.2.2 情况2：需要单旋当我们插入了一个cur向上更新的时候，就可能会遇到下图中间的情况。p是红节点，违反了性质3，而u是黑节点，不能简单粗暴的通过把p改成红来解决。\n\n这时候我们就需要针对g进行一次单旋（图中是右单旋，可以简单理解为向u旋转）。因为cur和p形成了同侧的连续两个红节点。和AVL树的单旋情况相似，只有这两节点在同侧，才可以执行单旋。\n旋转完毕之后，需要把g更新为红节点，p更新为黑节点\n2.2.3 情况3：需要双旋在情况2中，p和cur都是在它们父亲的同一侧。而情况3就是p和cur在父亲的不同侧。\n\n比如p是g的左子树，cur是p的右子树\n同时满足p是红，u是黑\n\n这时候就需要进行一次三旋，操作如下：\n\n以p作为基点，向cur的另外一个方向单旋一次（上图中就是左旋）\n旋转了之后，就会变成情况2\n这时候再以g为基点，向u的方向旋转一次（上图中为右旋）\n旋转完成之后，把g设置为红，cur设置为黑即可\n\n\n一下是完整的三种情况代码（p是g的左子树的情况）\n//p是g的左if (parent == grandpa-&gt;_left)&#123;    Node* uncle = grandpa-&gt;_right;    //情况1：插入后p是红，u存在且是红（不需要旋转）    if (uncle &amp;&amp; uncle-&gt;_col == RED)    &#123;        uncle-&gt;_col = BLACK;        parent-&gt;_col = BLACK;        grandpa-&gt;_col = RED;//祖父变成红        //继续向上调整        //cur = cur-&gt;_parent;        //parent = parent-&gt;_parent;        cur = grandpa;        parent = cur-&gt;_parent;    &#125;    else//(uncle &amp;&amp; uncle-&gt;_col == BLACK)    &#123;        //情况2：插入后p为红，u存在且为黑（需要单旋）        if (cur == parent-&gt;_left)        &#123;            RotateR(grandpa);//因为p在g的左边，所以右旋            parent-&gt;_col = BLACK;            grandpa-&gt;_col = RED;        &#125;        else//cur == parent-&gt;_right        &#123;            //情况3：不是在同一侧，双旋            //   g            // p            //   c            RotateL(parent);            RotateR(grandpa);            grandpa-&gt;_col = RED;//祖父改成红色            cur-&gt;_col = BLACK;//自己成为了这里的根，需要改成黑的        &#125;        break;    &#125;&#125;else&#123;    //....&#125;\n\n由于篇幅限制，p是g右子树的情况就不贴出来了，实际上就是把上面的代码全反过来就行了\n\n完整代码请查看我的gitee仓库\n\n2.3 查找（和AVL树完全相同）//因为kvl树我们需要修改value，所以返回节点的指针Node* _FindR(Node* root, const K&amp; key)&#123;\tif (root == nullptr)\t\treturn nullptr;\tif (root-&gt;_kv.first &lt; key)\t&#123;\t\treturn _FindR(root-&gt;_right, key);\t&#125;\telse if (root-&gt;_kv.first &gt; key)\t&#123;\t\treturn _FindR(root-&gt;_left, key);\t&#125;\telse\t&#123;\t\treturn root;\t&#125;&#125;//查找是通过key来进行的Node* FindR(const K&amp; key)&#123;\treturn _FindR(_root, key);&#125;\n\n2.4 判断是否是红黑树有两种方案，1是可以通过计算最大高度&#x2F;最小高度进行间接判断，2是以红黑树性质来验证是否满足最上面提到的5点\n2.4.1 计算最小最大高度这里实现递归即可，最小长度其实就是在最后return的判断中，把大于号改成小于号，返回小的那个子树的高度+1\nint maxHeight()&#123;\treturn _maxHeight(_root);&#125;int minHeight() &#123;\treturn _minHeight(_root);&#125;//最大长度int _maxHeight(Node* root)&#123;\tif (root == nullptr)\t\treturn 0;\tint lh = _maxHeight(root-&gt;_left);\tint rh = _maxHeight(root-&gt;_right);\treturn lh &gt; rh ? lh + 1 : rh + 1;&#125;//最小长度int _minHeight(Node* root)&#123;\tif (root == nullptr)\t\treturn 0;\tint lh = _minHeight(root-&gt;_left);\tint rh = _minHeight(root-&gt;_right);\treturn lh &lt; rh ? lh + 1 : rh + 1;&#125;\n\n只要最大长度小于最小长度的2倍，那么基本规则就是没有破坏的\n\n但这还不够，我们还需要检查它是否满足红黑树的其余性质\n2.4.2 递归检查性质这里再次列出5点性质\n\n每一个节点不是红色就是黑色\n根节点一定是黑色\n每一个红节点的左右子树都是黑色\n每一个到叶子（空节点NIL）的支路上黑节点数量相同\n叶子节点（空节点NIL）视作黑色\n\n然后通过两个函数来实现，其中一个函数需要进行递归\nbool IsRBTree()&#123;    //检查红黑树几条规则    Node* pRoot = _root;    //空树也是红黑树    if (nullptr == pRoot)        return true;    //检测根节点是否满足情况2    if (BLACK != pRoot-&gt;_col)    &#123;        cout &lt;&lt; &quot;违反2：根节点必须为黑色&quot; &lt;&lt; endl;        return false;    &#125;    //获取任意一条路径中黑色节点的个数，作为基准值    size_t blackCount = 0;    Node* pCur = pRoot;    while (pCur)    &#123;        if (BLACK == pCur-&gt;_col)            blackCount++;        pCur = pCur-&gt;_left;    &#125;    //检测是否满足红黑树的性质，k用来记录路径中黑色节点的个数    size_t k = 0;    return _IsValidRBTree(pRoot, k, blackCount);&#125;\t//检测是否为RB树bool _IsValidRBTree(Node* pRoot, size_t k, const size_t blackCount)&#123;    //走到null之后，判断k和black是否相等    if (nullptr == pRoot)    &#123;        if (k != blackCount)        &#123;            cout &lt;&lt; &quot;违反4：每条路径中黑色节点的个数必须相同&quot; &lt;&lt; endl;            return false;        &#125;        return true;    &#125;    //统计黑色节点的个数    if (BLACK == pRoot-&gt;_col)        k++;    //检测当前节点与其双亲是否都为红色    if (RED == pRoot-&gt;_col &amp;&amp; pRoot-&gt;_parent &amp;&amp; pRoot-&gt;_parent-&gt;_col == RED)    &#123;        cout &lt;&lt; &quot;违反3：存在连在一起的红色节点&quot; &lt;&lt; endl;        return false;    &#125;    return _IsValidRBTree(pRoot-&gt;_left, k, blackCount) &amp;&amp;        _IsValidRBTree(pRoot-&gt;_right, k, blackCount);&#125;\n\n可以看到，不管是随机数还是顺序插入，都通过了检查\n\n3.红黑树的运用红黑树在很多地方都有使用，在C++中，最为经典的便是map和set这两个容器，它们便使用了红黑树作为底层逻辑\n\nhttps://gitee.com/musnow/learn_cpp_code/blob/master/STL-Sourcecode/stl_tree.h\n\n在stl源码中，我们可以找到这个tree.h，里面便是一个红黑树的实现。而map和set就是调用了红黑树，只做了一个简单的封装\n结语在下篇博客中，我会记录map和set的基本使用，以及通过红黑树模拟实现map和set\n感谢大家支持！\n","categories":["遇见C++"],"tags":["C++","数据结构","树"]},{"title":"【C++】继承多态详解","url":"/posts/3933786088/","content":"在之前的CPP大作业中，为了应付期末（是这样的）关于继承和多态部分的内容只是草草过了一遍，并没有深挖背后的实现原理，以及使用的时候一些注意事项。\n本篇博客是对类和对象继承多态部分的深化！\n\n\n[TOC]\n0.什么是封装面向对象的三大特性：封装、继承、多态\n\n面向对象还有 反射（C++中没有）、抽象 等特性\n\n封装：\n\n不想让用户在类外访问的成员设计成私有，允许访问的设计成公有。相比C语言没有类和访问管理相比，封装能提高设计的安全性和完整性。\nC语言中，如果设计的不好，不规范编写的代码容易出现错误访问struct结构体中的成员。\n同时，C++中的迭代器设计，也能给一批容器提供基本相同的访问接口，让用户能使用相同的代码，在不暴露容器底层结构的前提下访问容器中的值。\n暴露底层结构会提高容器的使用成本，代码也比较复杂，不同数据结构也不一样。\nstack/queue/prioritiy_queue的适配器形式，能弄出来我们想要的东西，这也算是一种封装\n\n1.继承派生关系继承是提高代码复用性的一个重要手段。它允许我们在保持基类原有属性的基础上，对其进行一定的扩张，增加不同的功能以应对实际情况。\n比如对于一个人来说，其都会有性别、年龄、身分证号等等信息。但不同职业就还会包含不同职业的特殊信息。这时候就可以通过继承，在基础一个公民的基本信息的同时，再去处理每一个职业的独立信息。这也实现了类在一定程度上的复用，减少了代码复杂性。\n与其相似的增加代码复用性的语法，还有模板\n1.1 基本用法继承和派生是父与子的关系，其中子类拥有父类成员的同时，还会拥有自己的成员\n\n继承是一个特殊的语法，用于多个类有公共部分的时候\n父类：基类\n子类：派生类\n\n//举例：网站的公共部分class ART &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;网站访问量&quot; &lt;&lt; endl;\t&#125;\tvoid func()//文章页面\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; endl;\t&#125;&#125;;class LINK &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们 &quot; &lt;&lt; &quot; 网站访问量&quot; &lt;&lt;endl;\t&#125;\tvoid func()//友链页面\t&#123;\t\tcout &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n在上面的情况中，ART和LINK类中都有网站的公共部分，这时候就出现了代码的重复。继承的出现就是用于解决这个问题的\n//下面使用继承的方式来写，WEB类是网站的公共部分class WEB &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;网站访问量&quot; &lt;&lt; endl;\t&#125;&#125;;//ART、LINK是两个子类，继承了WEB的公共部分//这样就减少了代码量class ART : public WEB&#123;public:\tvoid func()//文章页面\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; endl;\t&#125;&#125;;class LINK : public WEB &#123;public:\tvoid func()//友链页面\t&#123;\t\tcout &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n测试可以发现，ART和LINK作为派生类，在继承了基类WEB的成员的基础上，还拥有了它们独特的单独成员\n\n同一个类可以同时继承多个基类\nclass C : public A,public B&#123;//.....&#125;;\n\n1.2 权限问题继承有3中类型：public、private、protected。这里会显示出类中protected权限和private权限的区别\nclass A&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\n当我们分别用上面三种方式对类A进行继承的时候，得到的结果是不同的\n\n用什么继承方式，派生类中继承的基类成员就变成什么类型\n不管用什么继承方式，都无法访问基类中的私有成员\n可以使用 Min(成员在基类中的访问限定符,继承方式) 来计算某一个成员在子类中的访问限定符是什么。\n\n\n关于权限问题，我们还需要了解下面几点：\n\n基类的私有成员在派生类中不可见，但实际上它也被继承过去了。但是编译器和语法的限制让我们无法访问。\n保护限定符由此出现，如果在基类中的成员不想被外界直接访问，但又需要子类中访问，则可以定义为保护\nclass默认继承方式为私有，struct默认继承方式为保护\n实际中我们一般使用public继承，保护&#x2F;私有方式不利于维护和拓展\n\n1.3 同名问题（作用域）在继承体系中，基类和子类都有自己独立的作用域\n当基类和派生类中出现同名成员函数或者同名成员变量时，会出现冲突。这时候编译器会做一定的处理：直接访问变量名和函数名的时候，优先访问派生类自己的成员，而屏蔽掉基类的。\n这种情况被称之为隐藏：\n\n函数名相同构成隐藏（并非重载）\n成员变量名相同构成隐藏\n\n实际操作中，强烈不建议写同名的成员，不管是成员函数还是成员变量\n//继承同名成员的处理//\t普通的同名成员class DAD1 &#123;public:\tDAD1()\t&#123;\t\t_a = 100;\t&#125;\tvoid func()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;DAD func&quot; &lt;&lt; endl;\t&#125;\tvoid func(int i)\t&#123;\t\tcout &lt;&lt; &quot;DAD func int: &quot; &lt;&lt; i &lt;&lt; endl;\t&#125;\tint _a;//基类中的该变量&#125;;class SON1 : public DAD1&#123;public:\tSON1()\t&#123;\t\t_a = 20;\t&#125;\tvoid Print()\t&#123;\t\tcout &lt;&lt;&quot;SON: &quot; &lt;&lt; _a &lt;&lt; endl;//优先访问派生类的_a\t\tcout &lt;&lt;&quot;DAD: &quot; &lt;&lt; DAD1::_a &lt;&lt; endl;//访问基类的_a\t&#125;\tvoid func()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;SON func&quot; &lt;&lt; endl;\t&#125;\tint _a;//派生类的同名变量&#125;;\n\n下方的调用测试能看出结果；\n\nclass A&#123;public:    void func()    &#123;        cout &lt;&lt; &quot;A::func&quot; &lt;&lt; endl;    &#125;&#125;;class B : public A&#123;public:    void func(int a)    &#123;        cout &lt;&lt; &quot;B::func &quot; &lt;&lt; a &lt;&lt; endl;    &#125;&#125;;\n\n在这个栗子里面，A::func  B::func两个函数之间是什么关系？\n答案：二者是隐藏的关系，并非函数重载！函数重载要求两个函数是处于同一个作用域，才构成重载！\n这点通过编译测试也能看出来\nint main()&#123;    B bt;    bt.func();    bt.func(1);    return 0;&#125;\n\n当我们使用如上函数进行编译的时候，编译器会报错找不到 B::func()，因为B的作用域中只有func(int a)这个需要传递参数的函数。如果A::func  B::func的关系是函数重载的话，那这里应该可以直接调用才对。\ntest.cpp: In function ‘int main()’:test.cpp:24:13: error: no matching function for call to ‘B::func()’     bt.func();             ^test.cpp:15:10: note: candidate: ‘void B::func(int)’     void func(int a)          ^~~~test.cpp:15:10: note:   candidate expects 1 argument, 0 provided\n\n只有指定父类作用域才能调用到A::func\nB bt;bt.A::func();\n\n1.4 静态成员在继承体系中，基类的静态成员有且只能有一个。即所有的子类和他们的对象，都是只有那一个静态成员的。我们可以用这个特性来对继承派生中出现的对象进行计数。\nclass Person&#123;public :\tPerson () &#123;++ _count ;&#125;protected :\tstring _name ; // 姓名public :\tstatic int _count; // 统计人的个数。&#125;;int Person :: _count = 0;\n\n如果出现了与静态成员同名，访问方法就有所变化\n//访问同名的静态成员class DAD2&#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1 &quot; &lt;&lt; endl;\t&#125;\tstatic void Test1(int n)\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1(int)  &quot; &lt;&lt; n &lt;&lt; endl;\t&#125;&#125;;int DAD2::D_a = 100;class SON2 : public DAD2 &#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;SON2 Test1 &quot; &lt;&lt; endl;\t&#125;&#125;;int SON2::D_a = 200;\n\n\n1.5 友元友元关系不会被继承，基类的友元函数无法访问派生类的私有/保护成员\n\n1.6 默认成员函数我们知道，C++类和对象中有6个默认成员函数\n\n在派生类中，这些默认成员函数有新的使用方法\n\n派生类的构造函数必须在初始化列表中调用基类的构造函数，初始化父类的一部分成员。如果你没有写，编译器会自动调用默认构造函数（先调用基类，在调用子类）\n派生类的拷贝构造同上，必须显式调用基类拷贝构造函数（将子类对象传过去，相当于将子类对象中的父类部分传入父类拷贝构造函数。这部分是编译器自动帮我们实现的切片操作）\n派生类的赋值重载也需要调用基类赋值重载完成操作\n派生类的析构函数编译器会自动调用基类，先析构派生类，再析构基类成员（符合栈后进先出原则）\n在基类析构函数不是虚析构的时候，子类析构和父类析构构成隐藏关系；\n因为多态的需要，析构函数会被统一命名为destructor()，构造函数并不会出现重命名。\n\n在下方栗子中，当我们写B类的深拷贝的时候，可以通过指定类作用域的方式来调用A父类的operator=重载（这里必须要指定类的作用域，否则调用的还是B类自己的operator=重载，相当于无效的递归调用，最终会因为死循环导致栈溢出）\n因为我们是将子类赋值给父类，所以都是编译器自动帮我们进行的切片操作。\nclass A&#123;public:    A(int a)        : _numa(a)    &#123;    &#125;    A(const A &amp;a)    &#123;        _numa = a._numa;    &#125;    A &amp;operator=(const A &amp;a)    &#123;        if (this != &amp;a)        &#123;            _numa = a._numa;        &#125;        return *this;    &#125;    void func()    &#123;        cout &lt;&lt; &quot;A::func&quot; &lt;&lt; endl;    &#125;    ~A()    &#123;        cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;        _numa = 0;    &#125;private:    int _numa;&#125;;class B : public A&#123;public:    B(int a = 1, int b = 1)        : A(a), _numb(b)    &#123;    &#125;    B(const B &amp;b)        : A(b)    &#123;        _numb = b._numb;    &#125;    B &amp;operator=(const B &amp;b)    &#123;        if (this != &amp;b)        &#123;            A::operator=(b); // 指定作用域调用A类的赋值重载            _numb = b._numb;        &#125;        return *this;    &#125;    void func(int a)    &#123;        cout &lt;&lt; &quot;B::func &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    ~B()    &#123;        cout &lt;&lt; &quot;~B()&quot; &lt;&lt; endl;        //A::~A();//显示调用会报错        _numb = 0;    &#125;private:    int _numb;&#125;;\n\n而在析构函数中，子类的析构调用完毕后，会自动调用父类的析构，以保证先析构子类，在析构父类。\n所以并不需要我们显式调用；显示调用父类析构的时候会报错\ntest.cpp: In destructor ‘B::~B()’:test.cpp:74:15: error: no matching function for call to ‘B::~B()’         A::~A();//显示调用会报错               ^test.cpp:32:5: note: candidate: ‘A::~A()’     ~A()     ^test.cpp:32:5: note:   candidate expects 1 argument, 0 provided\n\n\n\n\n构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数\n\n继承中先调用父类构造函数\n再调用子类构造函数\n\n析构顺序与构造相反\n显示调用父类构造函数如何显示调用父类的构造函数呢，下面是一个代码示例\n#include &lt;iostream&gt;using namespace std;class Person&#123;public:    Person(string name, string sex, int age)    &#123;        _name = name;        _sex = sex;        _age = age;    &#125;protected:    string _name;    string _sex;    int _age;&#125;;class Student : public Person&#123;public:    // 在初始化列表中调用父类的构造函数    Student(string name,string sex,int age,int no)        :Person(name,sex,age),        _No(no)    &#123;&#125;    int _No;//学号&#125;;int  main()&#123;    Student sobj(&quot;李华&quot;,&quot;男&quot;,18,1000);&#125;\n\n运行结果如下，可见子类正常调用了基类构造函数并进行了初始化\n\n这里也涉及到之前学过的一个小知识：在CPP中，类中成员的初始化顺序是依照声明的顺序来初始化的！而基类中的成员声明早于子类成员，自然也是先初始化基类的。\n1.7 基类和派生类赋值问题派生类成员可以赋值给基类的 对象&#x2F;指针&#x2F;引用。一般我们把这种情况称为切片，形象地表示把派生类中父类那部分切来赋值过去。\n但是！反过来是不行的哦，你不能把基类对象赋值给派生类对象。\n\n基类的指针&#x2F;引用可以用强制类型转换给派生类的指针&#x2F;引用。但是这样不够安全，除非基类的指针指向的是对应的派生类。\n如果基类是多态类型，可以使用RTTI（运行时类型识别）的dynamic_cast来进行安全处理\n\n#include &lt;iostream&gt;using namespace std;class Person&#123;protected :    string _name;    string _sex;    int _age;&#125;;class Student : public Person&#123;public :    int _No ;//学号&#125;;int  main()&#123;    Student sobj ;    // 1.子类对象可以赋值给父类对象/指针/引用    Person pobj = sobj ;    Person* p1 = &amp;sobj;    Person&amp; p2 = sobj;    // 2.基类对象不能赋值给派生类对象    //sobj = pobj;//err    // 3.基类的指针可以通过强制类型转换赋值给派生类的指针    p1 = &amp;sobj;//子类对象给基类指针    Student* ps1 = (Student*)p1; //基类指针指向子类，正常转换    ps1-&gt;_No = 15;    cout&lt;&lt;ps1-&gt;_No &lt;&lt;endl;    p1 = &amp;pobj;//基类对象给基类指针    Student* ps2 = (Student*)p1; //转换虽然可以，但是会存在越界访问    ps2-&gt;_No = 10;    cout&lt;&lt;ps2-&gt;_No &lt;&lt;endl;    return 0;&#125;\n\n\n关于最后提到的越界访问问题，我们知道，指针变量的大小都是相同的，其指针类型的区别主要在访问能力的不同。比如char*指针解引用只能访问1个字节，int*指针解引用可以访问4个字节，以此类推，Student*指针解引用可以访问sizeof(Student)个字节的空间。\n而子类对象的大小都是大于等于基类对象的大小的。这就导致子类指针访问基类对象内容时，一次解引用访问的空间超长，造成了越界访问\n\n实际上，当我们切片讲子类对象赋值给父类对象的时候，编译器会进行切片操作，即新的父类对象中的内容只会包含父类的成员。子类多出去的那一部分成员会被剔除。\n这一点我们可以在VS的调试中证实\n\n因为基类的成员变量被设置成了保护，所以我们不能直接在外部进行修改。需要显式调用基类的构造函数来初始化基类的成员。\n1.8 虚继承（菱形继承问题）有的时候，继承会出现下面这种情况：一个子类继承了两个基类，而这两个基类又同时是一个基类的派生类\n\n这时候，D里面就会有两份A的内容，相当于两份公共部分。这是我们不想看到的，因为会造成空间浪费。而且直接访问的时候，编译器会报错“对变量X的访问不明确”\n\n比如：intel和amd联合推出的NUC小电脑中，有一款CPU是他们合作开发的\n如何解决同时继承AMD和INTEL的问题？\n\n这时候会出现两个同名变量，一个是AMD里面有的，另外一个是INTEL里面有的因为他们是从CPU里面继承来的。\n虽然我们可以指定作用域来分别修改和访问。但是实际上这个公共部分就出现了浪费（比如是网站的公共部分，多给你一份没有啥意义）\n\n\n和前面说道的同名问题一样，我们可以指定作用域来访问特定的变量，但是这样是治标不治本的方法，并没有解决空间浪费的问题。\n//解决方法1（治表不治本）//用类域来修改和访问cout &lt;&lt; &quot;intel: &quot; &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;cout &lt;&lt; &quot;amd: &quot;   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;\n\n这就需要我们使用虚继承来操作：给B和C对A的继承加上virtural关键字（对公共基类的继承添加上虚继承关键字）\nclass CPU &#123;public:\tCPU()\t\t:_Structure(&quot;x86&quot;)\t&#123; &#125;\tchar _Structure[100];&#125;;class INTEL : virtual public CPU &#123;public:\tINTEL()\t\t:i_Brand(&quot;intel&quot;)\t&#123;&#125;\tchar i_Brand[10];&#125;;class AMD : virtual public CPU &#123;public:\tAMD()\t\t:a_Brand(&quot;amd&quot;)\t&#123;&#125;\tchar a_Brand[10];&#125;;//同时继承AMD和INTEL//相当于有两个_Structure变量//实际上我们只需要一个就够了class NUC :public AMD, public INTEL &#123;&#125;;void test1()&#123;\tNUC n1;\t//对“_Structure”的访问不明确\t//cout &lt;&lt; n1._Structure &lt;&lt; endl;//err\t//解决方法1（治表不治本）\t//用类域来修改和访问\tcout &lt;&lt; &quot;intel: &quot; &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;\tcout &lt;&lt; &quot;amd: &quot;   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;\t//解决方法2，在AMD和INTEL对CPU的继承上加virtual\tcout &lt;&lt; &quot;n1访问：&quot; &lt;&lt; n1._Structure &lt;&lt; endl;\t//现在就没有报错了\t//因为这时候AMD和INTEL中的_Structure都会指向同一个地址\tcout &lt;&lt; &quot;&amp;intel: &quot; &lt;&lt; &amp;(n1.INTEL::_Structure) &lt;&lt; endl;\tcout &lt;&lt; &quot;&amp;amd:   &quot; &lt;&lt; &amp;(n1.AMD::_Structure) &lt;&lt; endl;\t//修改INTEL中的_Structure，也会连代修改AMD中的_Structure&#125;\n\n这时候直接访问变量就不会报错了。因为这时候，B和C中的该变量指向了同一个地址，修改操作会同步。\n\n继承模型普通菱形继承下图中的继承模型是一个简单的菱形继承，我们能看到d中关于两个公共A._a的位置是不相同的；\n\n在cpu继承模型中也是如此，amd和intel继承的cpu类中X86字符串的地址是不相同的\n\n这里因为内存对齐的问题，我们无法看清楚它的全貌。\n但通过这里的继承模型，可以看出来在菱形继承问题中，不使用虚继承会造成两个CPU对象的多次继承，导致访问不明确的特性。\n虚继承模型那换成虚继承之后的模型是什么样子的呢？\n先用d本身访问d._a，可以看到红色箭头所指区域的内存被初始化为0\n\n再指定作用域B::进行访问，会发现其修改的依旧是这个地址的数据！\n\n用作用域C::来访问的结果也是如此，依旧修改的是相同内存位置的数据\n\n由此可见，菱形继承了之后，_a变量的地址就被确定为一个地址了。所有作用域中的_a指向的都是这个公共地址，修改的都是这个公共地址的值，也就不会出现二义性问题！\n最终运行完毕，内存窗口如图，A被丢到了最后面\n\n再说回上方提到的cpu继承模型，进入调试窗口，可以看到这里分别分为了3个模块，保存了不同基类的成员。而它们之中的_Stucture成员只有一个（指向&quot;x86&quot;字符串的地址是相同的），所以就不会出现异义；\n\n此时我们会发现，不管是上方ABCD的继承模型，还是这里的CPU继承模型，内存都出现了一定的空置；那这里空着的空间是用来做什么的呢？也是内存对齐吗？非也！\n虚基表\n通过在虚基表中存放虚基类的偏移量，可以解决菱形继承产生的二义性问题。\n\n下图能帮你了解这个虚继承模型中，内存的区块是怎么划分的；可以看到B和C这两个父类都会有一个虚基表的指针，指向虚基表的地址。地址中存放的是B和C对象跟A对象地址的偏移量。\n\nB和C两个对象都有自己独立的虚基表地址，而不是共用一个，是为了方便切片时候的查询。\n\n这样，虚基表就帮我们避免了在访问菱形继承模型时出现异义的问题。不过，因为多了一层间接的偏移量查询，访问公共基类的成员的效率会有所降低。\n\ncpu的继承模型也是如此，在amd和intel这两个字符串存储位置上方，存放的就是一个虚基表的地址。而虚基表的这个地址之后紧跟着的就是一个当前对象跟基类对象的偏移量的数据；\n同时也能总结出一个规律，虚基表的地址中的数据以全0开头，第二个（准确来说应该是偏移4个字节）的地址才是基类偏移量的数据\n\n这样做就有一个好处，即便我们使用不同的基类指针（比如amd或者intel）来指向nuc的子类对象；\nNUC n1;AMD* amd = &amp;n1;INTEL* itl = &amp;n1;\n\n这里的赋值需要对NUC对象进行切片，要获取到AMD/INTEL这两个父类的成员的同时，还需要获取到公共基类CPU成员的位置；\n此时因为存在虚基表，它们都可以通过各自虚基表里面存放的偏移量，来计算公共基类CPU成员的位置，从而获取到了CPU类的成员。\n另外，当AMD和INTEL采用虚继承来继承CPU的时候，他们类内就已经会有虚基表了。跟他们自己是否存在子类无关！这样是为了保证访问时候的统一性。比如如下代码\nNUC n;AMD a;AMD* amd1 = &amp;n;AMD* amd2 = &amp;a;\n\n对于编译器而言，其并不知道AMD*指针到底指向的是本类还是子类，而AMD对象本身也有虚基表，就能保证不管是本类还是子类，都能通过同样的方式（通过虚基表查询偏移量）来找到虚继承的父类CPU的地址，从而访问到父类对象成员。\n\n使用虚基表还可以让开发者灵活控制编译器对内存区块划分的优化。比如上面的两个栗子中，在VS2019里面，公共基类一般都是处于最下方的。\n但如果我想设计公共基类放在最上方，也可以通过虚基表中的偏移量来实现。\n而如果cpp强制规定公共基类必须要在普通基类的下方，而不使用虚基表来存放基类偏移量，那就限制了编译器的开发，也不方便实际的查找\n\nC++STD中的IO流就使用了菱形继承来进行设计。\n但对于我们而言，由于菱形继承实在过于复杂，一般不建议你这么“作死”；\n1.9 继承和组合\n继承：上述所说。每一个派生类对象都是一个基类对象is-a\n组合：在一个类里面包含另外一个类的对象成员。每一个B对象中都包含了一个A has-a；比如我们在自己的类中使用std::string，此时我们自己的类和std::string的关系就是组合\n\n组合是黑盒复用，继承是百盒复用（子类能知道父类的细节，称为白盒）\n实际情况中，建议优先选择组合，而不是继承。\n\n继承增加了代码的复用性，但是在一定程度上破坏了基类的封装性。派生类和基类的关联很强，耦合度高。\n对象组合是另外一种复用的选择，这时候，对象A的内部结构是不得而知的。这样就减小了对象之间的关联性，耦合度低，保护了封装，更方便代码的维护\n\n不过，继承还有另外一种用途，那就是多态。我们下边会讲解的！\n在软件设计中，追求高内聚，低耦合，不同模块之间的关联度应该竟可能的低。在设计类间关系，和不同功能模块的时候，需要考虑具体场景来进行继承和组合的选用。\n比如A继承B，此时两个类就被强关联在一起了，耦合度相对较高。对父类A的任何修改i，都会影响达到B，甚至导致B无法正常运行。\n总结多继承所导致的菱形继承问题，在一定程度上让C++的语法变得复杂了。比如java是没有多继承的。在实际使用情况中，不建议使用多继承。\n\n2.多态\n静态多态：函数重载\n动态多态：派生类和虚函数组成的多态\n\n多态通俗地讲就是多种形态，当不同的对象去完成相同的事情的时候，会产生不同的状态。\n比如买票这个行为，会衍生出全票、儿童票、学生票等等类型。不同身份的人过来买票，应该调用不同的处理流程。使用多态，就能将这些不同流程的相同类型函数（都是在买票）给拟合成不同子类对象中的同名函数；\n\n注意，多态只是实现这个场景的方式之一；你当然可以封装毫无相干的类，或者是使用函数重载，多个函数，判断语句来解决此类问题。\n\n2.1 虚函数2.1.1 基本使用以及动态多态虚函数，并不代表这个函数是虚无的。而表示这个函数在一定情况下会被替换（就好比继承中的虚继承问题）。要实现动态多态，就需要借助虚函数来实现。\n\n这里顺便提一嘴函数的三种关系：重载、隐藏（继承中同名问题）、覆盖（多态中虚函数被子类覆盖）\n\n虚函数需要满足两个条件\n\n函数名、参数、返回值都相同\n父类中该函数使用了virtual关键字来修饰此函数\n\n而调用的时候，必须是父类指针/引用指向子类的对象的时候，才会调用子类重写后的虚函数（如果没有重写该函数，则调用的依旧是父类的函数）\n\n以下面这个动物说话的代码为例\n#include &lt;iostream&gt;using namespace std;class Animal &#123;public:\t//void Talk()\tvirtual void Talk()//虚函数\t&#123;\t\tcout &lt;&lt; &quot;Animal is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class CAT : public Animal&#123;public:\tvoid Talk()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;CAT is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class DOG : public Animal &#123;public:\tvoid Talk()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;DOG is talking&quot; &lt;&lt; endl;\t&#125;&#125;;//基类中不使用虚函数时，该函数的内容已确定//不管传参什么类，都会调用Animal自己的Talk函数//加上虚函数virtual后，会调用CAT和DOG的Talk函数void MakeTalk(Animal&amp; it) &#123;\tit.Talk();//调用对应的Talk函数&#125;\n\n当基类Animal中的Talk函数没有用virtual修饰时，不管给这个函数传参什么类的对象，它都会调用Animal自己的Talk函数\n\n当我们用虚函数进行修饰后，就会调用派生类CAT和DOG的Talk函数，这就实现了一个简单的动态多态。\n\n对于虚函数，有几点需要注意：\n\n当基类的指针或引用指向派生类的对象时，就会触发动态多态，派生类中的同名函数会覆写基类中的虚函数\n不能定义静态虚函数——因为静态函数是属于整个类的，而不是属于某一个对象\n不能定义虚构造函数——总不能用派生类的构造来覆写基类的构造吧？这不符合继承中对构造函数的要求\n析构函数可以是虚函数\n\n2.1.2 虚析构函数有的时候，我们需要析构一个子类对象时，往往会给基类的析构函数加上virtual修饰，这样只要传派生类的对象给基类的指针&#x2F;引用，就可以直接调用派生类对应的析构函数，完成不同的析构操作。\n而不是都呆呆的调用基类的析构函数——那样就会产生内存泄漏，因为子类部分的成员并没有被析构！\n这也是为何，类中析构函数会被统一重命名为destructor()，便是为了让父类和子类的析构函数在设置了virtual关键字后，函数同名，可以构成多态！\n所以，如果一个类是基类，最好将析构设置成虚析构。\n测试#include &lt;iostream&gt;using namespace std;class Queue&#123;public:    Queue()        : _a(new int[10])    &#123;    &#125;    ~Queue()    &#123;        cout &lt;&lt; &quot;~Queue&quot; &lt;&lt; endl;        delete[] _a;    &#125;private:    int *_a;&#125;;class MyStack : public Queue&#123;public:    MyStack(int capa)        : _a1(new int[capa])    &#123;    &#125;    ~MyStack()    &#123;        cout &lt;&lt; &quot;~MyStack&quot; &lt;&lt; endl;        delete[] _a1;    &#125;private:    int *_a1;&#125;;int main()&#123;    Queue *q1 = new Queue();    delete q1; // 调用父类的析构函数    Queue *q2 = new MyStack(4); // 父类指针指向子类    delete q2;                  // 如果加了虚析构，就会调用子类的析构函数    return 0;&#125;\n\n其中我们将子类MyStack的指针赋值给了父类。运行这个函数，会发现父类的析构函数被正常调用了两次，但子类的析构函数并没有被调用。\n这就导致子类对象中的int *_a1;指针申请的内存没有被正常释放，从而导致内存泄露；\nvirtual ~Queue()&#123;    cout &lt;&lt; &quot;~Queue&quot; &lt;&lt; endl;    delete[] _a;&#125;\n\n当我们给父类的析构添加上virtual关键字后，再次运行这个代码\n~Queue~MyStack~Queue\n\n此时父类和子类的析构都被成功调用了！\n为了更好的观察析构顺序，给两个类都新增了一个成员变量作为标记位，在析构的时候打印。\nclass Queue&#123;public:    Queue(int no)        : _a(new int[10]), _no(no)    &#123;    &#125;    virtual ~Queue()    &#123;        cout &lt;&lt; &quot;~Queue &quot; &lt;&lt; _no &lt;&lt; endl;        delete[] _a;    &#125;private:    int _no;    int *_a;&#125;;class MyStack : public Queue&#123;public:    MyStack(int capa, int no)        : _a1(new int[capa]), Queue(no), _nos(no)    &#123;    &#125;    ~MyStack()    &#123;        cout &lt;&lt; &quot;~MyStack &quot; &lt;&lt; _nos &lt;&lt; endl;        delete[] _a1;    &#125;private:    int *_a1;    int _nos;&#125;;int main()&#123;    Queue *q1 = new Queue(1);    delete q1; // 调用父类的析构函数    Queue *q2 = new MyStack(4, 2); // 父类指针指向子类    delete q2;                     // 如果加了虚析构，就会调用子类的析构函数    return 0;&#125;\n\n运行结果如下，可以看到，第二个指针q2被delete释放的时候，先调用了子类的析构函数，后调用了父类的析构函数。\n~Queue 1~MyStack 2~Queue 2\n\n这样就不会出现内存泄露了！\n2.1.3 子类不重写在这个继承模型中，子类Stu并没有重写父类函数，运行的时候，调用的都是父类的成员函数。这是一个普通的继承调用。\nclass Person&#123;public:    virtual A *f()    &#123;        cout &lt;&lt; &quot;virtual A* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;&#125;;class Stu : public Person&#123;public:    int _a;&#125;;int main()&#123;    Stu s;    Person p;    Person* ptr = &amp;p;    ptr-&gt;f();    ptr = &amp;s;    ptr-&gt;f();    return 0;&#125;\n\n输出结果\nvirtual A* f()virtual A* f()\n\n2.1.4 协变虚函数重写的时候，对返回值还会有一个例外的要求：协变；\n前面提到，虚函数构成重写，必须要保证返回值相同。但协变的存在就新增了一个规定，我们的返回值并不一定要严格相同。\n父类甲中函数返回值是某个父类乙的指针&#x2F;引用时，子类丙虚函数重写的时候，返回值可以是子类丁&#x2F;父类乙的指针&#x2F;引用（对应父子关系即可，在这里，甲丙/乙丁是两对父子）\n// B类继承了A类class Person&#123;public:    virtual A *f()    &#123;        cout &lt;&lt; &quot;virtual A* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;&#125;;class Stu : public Person&#123;public:    virtual B *f()    &#123;        cout &lt;&lt; &quot;virtual B* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;&#125;;int main()&#123;    Stu s;    Person p;    Person* ptr = &amp;p;    ptr-&gt;f();    ptr = &amp;s;    ptr-&gt;f();    return 0;&#125;\n\n上面的代码中，Stu子类对父类虚函数的重写，返回值就是子类的指针；编译通过并运行，结果如下。可见的确构成了多态。\n$ g++ test.cpp -o test$ ./testvirtual A* f()virtual B* f()\n\n如果带上引用，效果也是一样的\nclass Person&#123;public:    virtual A *f()    &#123;        cout &lt;&lt; &quot;virtual A* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;    virtual A &amp;func_a(A &amp;a, B &amp;b)    &#123;        cout &lt;&lt; &quot;virtual A &amp;func_a(A &amp;a, B &amp;b)&quot; &lt;&lt; endl;        return a;    &#125;&#125;;class Stu : public Person&#123;public:    virtual B *f()    &#123;        cout &lt;&lt; &quot;virtual B* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;    virtual B &amp;func_a(A &amp;a, B &amp;b)    &#123;        cout &lt;&lt; &quot;virtual B &amp;func_a(A &amp;a, B &amp;b)&quot; &lt;&lt; endl;        return b;    &#125;&#125;;int main()&#123;    Stu s;    Person p;    B test_b;    Person *ptr = &amp;p;    ptr-&gt;f();    ptr-&gt;func_a(test_b,test_b);    ptr = &amp;s;    ptr-&gt;f();    ptr-&gt;func_a(test_b,test_b);    return 0;&#125;\n\n这里我给func_a设计了两个参数，保证两个函数参数相同；需要注意子类的引用没办法赋值父类的对象。只有父类的引用才能赋值子类对象。（权限只能缩小不能扩大）\nvirtual A* f()virtual A &amp;func_a(A &amp;a, B &amp;b)virtual B* f()virtual B &amp;func_a(A &amp;a, B &amp;b)~B()~A()\n\n下面的这种情况就是不允许的！两个函数的参数不同，虽然满足协变的条件，但不满足虚函数重写的规定；可以看到运行后，两次调用都是父类的func_a函数；\n\n2.1.5 重写不带virtual子类重写该函数的时候，可以不带virtual关键字。即便不带，依旧保有虚函数特性，可以被二次重写。这是因为子类继承父类的时候，先继承了虚函数的声明（相当于从父类中继承了virtual关键字）\n\n记住这点，后面要考\n\n虽然这个关键字可以被省略，但不建议你省略它。这个关键字能告诉其他开发者，这个函数是一个重写了父类的虚函数（也有可能是一个即将被重写的虚函数）。相当于一个提示。\nclass Person&#123;public:    virtual A *f()    &#123;        cout &lt;&lt; &quot;virtual A* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;    virtual A &amp;func_a(A &amp;a, B &amp;b)    &#123;        cout &lt;&lt; &quot;virtual A &amp;func_a(A &amp;a, B &amp;b)&quot; &lt;&lt; endl;        return a;    &#125;&#125;;class Stu : public Person&#123;public:    B *f()//可以省略virtual关键字    &#123;        cout &lt;&lt; &quot;virtual B* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;    virtual B &amp;func_a(A &amp;a, B &amp;b)    &#123;        cout &lt;&lt; &quot;virtual B &amp;func_a(A &amp;a, B &amp;b)&quot; &lt;&lt; endl;        return b;    &#125;&#125;;class XiaoMing : public Stu&#123;public:    B* f()    &#123;        cout &lt;&lt; &quot;XiaoMing virtual B* f()&quot; &lt;&lt; endl;        return nullptr;    &#125;&#125;;int main()&#123;    Stu s;    Person p;    XiaoMing xiao;    B test_b;    Person *ptr = &amp;p;    ptr-&gt;f();    ptr-&gt;func_a(test_b, test_b);    ptr = &amp;s;    ptr-&gt;f();    ptr-&gt;func_a(test_b, test_b);    ptr = &amp;xiao;    ptr-&gt;f();    return 0;&#125;\n\n输入结果如下\nvirtual A* f()virtual A &amp;func_a(A &amp;a, B &amp;b)virtual B* f()virtual B &amp;func_a(A &amp;a, B &amp;b)XiaoMing virtual B* f()~B()~A()\n\n截图说明\n\n坑人的问题这个知识点就可以引伸出一个比较坑人的问题了\nclass Dad&#123;public:    virtual void func(int a = 3)    &#123;        cout &lt;&lt; &quot;Dad -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    virtual void test()    &#123;        func();    &#125;&#125;;class Son:public Dad&#123;public:    virtual void func(int a = 1)    &#123;        cout &lt;&lt; &quot;Son -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Son* s = new Son();    s-&gt;test();    return 0;&#125;\n\n请问如上代码的输出结果是什么？它调用的到底是谁的func函数呢？打印的a的值又是多少呢？\nA   Dad -&gt; 3B   Dad -&gt; 1C   Son -&gt; 1D   Son -&gt; 3E   编译不通过F   以上都不正确\n\n答案揭晓，选择的是D，输出结果是Son -&gt; 3\n$ ./testSon -&gt; 3\n\n刚开始遇到这道题的时候，我也是一脸蒙蔽。直到看了题解才知道这里多坑人。\n\n其中E和F肯定是不能选的，一般情况下这两个选项都是过来迷惑你的。\n比如有人可能会觉得new了之后没有delete，有语法错误！但实际上你不delete编译器是不会报错的，要不然也不会存在因为忘记delete而出现的内存泄露问题了。\n\n回到 2.1.5小点 的开头， 提到了子类继承父类函数的时候，会先继承父类函数的声明；\n对于普通函数而言，声明无伤大雅。但这里，子类和父类函数声明中参数a的缺省值不相同！\n最终我们通过子类对象调用test()函数的时候，是将子类对象的指针交给了父类对象的指针。不要忘记了，类中所有成员函数都会有一个隐藏的this指针传参！\n实际上，test函数的声明应该是下面这个。我们用子类对象掉用的时候，传入的this指针是子类对象的指针，自然就出现了将子类对象赋值给父类指针的情况。\nvirtual void test(Dad* this) &#123;    this-&gt;func();&#125;\n\n此时就满足了虚函数的两个条件：父类指针指向子类对象；子类重写了父类的虚函数。\n这时候调用的func()函数，自然是子类中被重写了的func()函数，但由于继承了父类的函数声明，a的缺省值被修改成了父类中func()函数的3，最终就打印出了 Son -&gt; 3 的结果；\n为了验证这个结论，我们还可以把子类中func函数的缺省值删除\nclass Dad&#123;public:    virtual void func(int a = 3)    &#123;        cout &lt;&lt; &quot;Dad -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    virtual void test()    &#123;        func();    &#125;&#125;;class Son:public Dad&#123;public:    virtual void func(int a)    &#123;        cout &lt;&lt; &quot;Son -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Son* s = new Son();    s-&gt;test();    return 0;&#125;\n\n理论上来说，子类函数重写了父类的func，此时这个函数没有缺省值，调用一个没有传参的func()函数应该是会报错的。\n但由于其继承了父类中的函数声明，并没有报错，编译通过了，输出的结果不变\n$ g++ test.cpp -o test$ ./testSon -&gt; 3\n\n\n所以啊，为了避免这种情况，虚函数请不要设计缺省值！\n\n还是上面那道题，如果是直接调用func，应该输出什么？\nclass Dad&#123;public:    virtual void func(int a = 3)    &#123;        cout &lt;&lt; &quot;Dad -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    virtual void test()    &#123;        func();    &#125;&#125;;class Son:public Dad&#123;public:    virtual void func(int a = 1)    &#123;        cout &lt;&lt; &quot;Son -&gt; &quot; &lt;&lt; a &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Son* s = new Son();    s-&gt;func();    return 0;&#125;\n\n这时候就和什么继承父类函数声明没有关系了，直接调用的就是子类自己重写了的函数，可以理解为是一个普通的函数调用\n$ ./testSon -&gt; 1\n\n多态必须要父类指针&#x2F;引用指向子类的时候才能触发！\nint main()&#123;    Son* s = new Son();    s-&gt;func();//普通调用    // 这个才是多态调用    Dad* dd = s;    dd-&gt;func();    return 0;&#125;\n\n$ ./testSon -&gt; 1Son -&gt; 3\n\n2.2 C++11 override和finalC++11中新增了override和final这两个关键字\n2.2.1 finalfinal用于类内成员函数之后，作用是让这个虚函数无法被重写\nvirtual void Func1() final&#123;&#125;\n\n\n这个关键字的第二个做用，修饰类，被修饰后的类无法被继承\n// C++11直接用关键字final修饰，B类就不能被继承了class B final&#123;\t//...&#125;;\n\n\n2.2.2 override该关键字用于子类中，也是丢在函数后，用于验证是否完成重写\nclass A&#123;public:    virtual void test1()&#123;&#125;&#125;;class B :public A&#123;public:    void test1() &#123;&#125;    void test2() override &#123;&#125;&#125;;\n\n比如在上面的代码中，基类中并没有test2存在，此时我们在test2后加上了override，编译器就会进行检查并报错。因为test2并不是一个对基类中函数的重写\n\n将override添加到test1函数之后，就不会报错了。\nclass A&#123;public:    virtual void test1()&#123;&#125;&#125;;class B :public A&#123;public:    void test1() override  &#123;&#125;    void test2()  &#123;&#125;&#125;;\n\n但如果将基类A的test1的虚函数virtual属性去掉，则又会报错；\n\n如果基类和子类两个同名函数的参数不相同，不构成重写，也会报错\n\n这个关键字就可以用于在多态类设计中，比如所有子类都会有一个buy的函数重写，那就可以在buy函数后添加一个override，来检查我的重写是否完成，参数是否与基类中该函数的参数相同，以及函数名是否正确。\n2.3 重载、覆盖（重写）、隐藏（重定义）的对比常考，要理解并记忆\n\n3.抽象类包含纯虚函数的类就是抽象类，抽象类不能实例化对象\n3.1 纯虚函数在虚函数的基础上，C++定义了纯虚函数：有些时候，在基类里面定义某一个函数是没有意义的，这时候我们可以把它定义为纯虚函数，具体的实现让派生类去同名覆写。\n纯虚函数的基本形式如下\n//virtual 函数返回类型 函数名()=0;virtual void Print()=0;\n\n派生类中，必须重写基类的纯虚函数，否则该类也是抽象类\nclass A &#123;public:\t//virtual void Print();//虚函数\tvirtual void Print() = 0;//纯虚函数&#125;;class B :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;B print &quot; &lt;&lt; endl;\t&#125;&#125;;class C :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;C print &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n当我们在派生类中覆写了该函数后，即可实例化对象并调用该函数\n\n和虚函数一样，使用基类的引用或指针来接收派生类的对象，即可调用对应的函数\n\n纯虚函数内部是可以写函数实现的，但是没有任何意义。因为纯虚函数必须要被子类重写，这个纯虚函数本身是不能被调用的。\n3.2 抽象类包含纯虚函数的类就是抽象类，抽象类有下面几个特点：\n\n抽象类无法实例化对象\n抽象类的派生类必须重写基类的纯虚函数，不然派生类也是抽象类\n如果在基类中定义的纯虚函数是const修饰的，则派生类中对应的函数也需要用const修饰\n\n\n如果我们在子类里面修改了函数的参数，那就不构成重写；此时子类B也是抽象类，无法被实例化对象了\nclass A &#123;public:\t//virtual void Print();//虚函数\tvirtual void Print() = 0;//纯虚函数&#125;;class B :public A &#123;public:\tvoid Print(int a) &#123; // 新增了一个参数\t\tcout &lt;&lt; &quot;B print &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n4.实现继承和接口继承普通函数的进程是一种实现继承，派生类继承了基类的函数，可以使用这个函数。此时继承的就是函数的实现；\n多态中的虚函数是一种接口继承，子类继承的是父类中虚函数的接口，目的是为了在子类中进行重写，以达成多态的目的。此时继承的是函数的接口。\n所以，如果不是为了多态，那就不要把父类的函数定义成虚函数。\n4.1 动态绑定和静态绑定\n静态绑定又称前期绑定（早绑定），在程序编译期间确定了程序的行为，也成为静态多态（函数重载）\n动态绑定又称为后期绑定（晚绑定），是在程序运行期间，根据具体拿到的类型来决定程序的行为，调用具体的函数，又称为动态多态。\n\n4.2 父类的构造和析构中虚函数不生效请记住，在父类的构造和析构中，如果出现虚函数，则只会调用父类自己的函数实现，子类针对该虚函数的重写不会生效！\n具体请参考我的另外一篇关于一道CPP选择题目的博客【点我】\n5.包含虚函数的类的大小请问下面的代码中，b和d对象的大小分别是什么？\nclass Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func2()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func2()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _b = 1;&#125;;class Derive : public Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func1()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _d = 2;&#125;;int main()&#123;\tBase b;\tDerive d;\tcout &lt;&lt; &quot;b: &quot; &lt;&lt; sizeof(b) &lt;&lt; endl;\tcout &lt;&lt; &quot;d: &quot; &lt;&lt; sizeof(d) &lt;&lt; endl;\treturn 0;&#125;\n\n结果如下，b的大小是8，d的大小是12\n\n当我们使用了virtual关键字修饰函数之后，类中就会出现一个虚函数表，简称虚表（需要和虚基表区分开来）\n\n\n后文将解释虚函数表的作用，只有虚函数才会存在于虚表中\n\n这个虚函数表是一个指针_vfptr，指针的大小是4/8字节，b类的大小由虚函数表指针和int组成，d类的大小由虚函数表指针和两个int组成。\n\n在32位下，这两个类的大小分别是8和12；\n在64位下，这两个类的大小分别是16和24（除了指针是8字节外，还需要内存对齐）；\n\n当我们把Base类中的函数修改回普通函数，可以看到类的大小又变成只包含一个int的4字节了。而Dervie类由于依旧有virtual的存在，所以大小不变。\n\n6.虚函数表（虚表）以这个类为示例，让我们来看看虚表的样子\nclass Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func2()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func2()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _b = 1;&#125;;class Derive : public Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func1()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _d = 2;&#125;;\n\n在内存窗口中，可以看到这两个对象的基本模块。子类对象中也存在一个虚表，而且可以发现，父子类的虚表中，只有func1的函数地址是不同的。\n\n这里的_vfptr是virtual func pointer的缩写，中文名是虚函数表指针，可以简称为虚表指针\n\n一定要区分虚函数表（多态）和虚基表（菱形继承）！\n\n6.1 虚函数重写和覆盖的概念区别这里就需要提及重写和覆盖这两个概念的区别了\n\n虚函数重写：语法层的概念，指子类中重写父类中虚函数的函数实现\n虚函数覆盖：原理层的概念，子类对象的序表中，子类拷贝了父类的虚表，重写后的函数的函数指针覆盖了基类对应虚函数的指针\n\n多态的实现，就依赖于子类虚表中对函数指针的覆盖，运行时，去指定对象的虚表中，调用对应的函数指针。这是一种运行时决议调用方法的操作；\n在VS的调试窗口中，我们能看到一个完整的父类Base对象，这也是父类指针指向子类对象的实现原理。此时父类的指针是完全没有办法知道自己指向的是父类对象，还是某个子类对象；\n虚函数表的存在，帮我们实现了通过相同的函数调用方法，实际却触发了不同函数的流程的操作。\n6.1.1 运行时决议和编译时决议\n多态调用，运行时决议：运行到这里时确定调用函数的地址\n普通调用，编译时决议：在编译时就确定调用的函数的地址\n因为存在一层通过虚函数表的跳转，所以多态调用会比普通调用的速度慢一些。\n\n依旧是上方的两个类，在基类和子类中同时存在一个普通函数Func3()，此时通过父类指针去调用的时候，就会发现二者调用的都是父类的Func3。\n\n这正是因为非虚函数是没有进入虚函数表，此时对Func3的调用就是一个普通函数调用；此时Func3函数的地址在编译出可执行文件的时候，就已经被确定为了基类中的函数地址。\n而Func1因为是虚函数，存在于虚函数表中，所以是通过运行时查询这个虚函数表，来找到父子类不同的函数地址，最终实现多态调用。\n6.1.2 看看汇编从图中可以看到，对于Func1的调用，最终是从虚函数表中提取出来的地址，call eax寄存器中的地址，这便体现了运行时决议；\n而对Func3的调用，是编译时决议，直接已经确定了的基类中该函数的地址，直接call 09511CCh这个函数地址来调用函数了。\n\n对于指向基类对象的调用也是这样\n\n这里就能很直观的看到，多态中虚函数表，让父类指针不管是指向子类对象、还是指向父类对象，都能通过相同的汇编指令来调用正确的函数。\n6.2 子类对象赋值给父类为何无法实现多态？我们都知道，继承了之后，如果把子类对象赋值给父类，则会产生切片。此时无法构成多态。\n这是为什么呢？\n因为编译器在编译的时候，就已经确定了这些函数的地址。\n\n编译器检查是否符合多态的语法\n不符合多态的语法，则直接确定对类函数调用的成员函数地址\n符合多态的语法，那就编译出运行时决议的汇编语句\n\n此时地址就已经确定了，根本不存在从虚函数表中找函数地址的步骤，自然就不能实现多态调用了。\n\n这时候可能有些人就会有个不成熟的想法：如果将子类对象赋值给父类对象，切片的时候把子类对象的虚表指针也复制到父类中，那不就能实现多态了吗？\n不行！\nDerive dd;Base bb = dd; // 子类对象赋值给父类Base* ptr1 = &amp;bb; // 父类指针指向父类对象Base* ptr2 = &amp;dd; // 父类指针指向子类对象// 引用本质也是指针，这里就不写了\n\n以上面的代码为例，当我们把一个对象赋值给父类的指针时，程序运行的时候并不知道，这个指针指向的到底是父类还是子类对象。\n假设我们在切片的时候，将子类对象dd的虚表指针也拷贝复制给父类了，那就会出现一个严重的问题：ptr1在调用函数的时候，调用的也是子类的函数！\n这不就乱套了吗？！\n理论上bb是一个父类对象，赋值给Base*指针后，我们调用函数的预期是调用父类的函数。但由于bb对象是从子类对象切片而来的，拷贝了子类的虚表指针，此时找到的也是子类的函数地址，不符合预期地调用了子类重写后的虚函数！\n所以！为了避免这种不符合语法预期的问题，在切片的时候，只会将子类对象中的成员变量拷贝给父类，并不会拷贝虚表指针！切片生成的父类对象，虚表指针依旧是父类自己的虚表指针！\n下图中可见，b3是切片而来的父类对象，其虚表指针以及虚表中的函数地址和Base b1完全相同。一个类的虚表其实只有一张。\n\n所以，对象并不能实现多态。即便理论上可行，但依旧不能这么做！\n6.3 子类中新增虚函数，但监视窗不显示6.3.1 实地探索class Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func2()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func2()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _b = 1;&#125;;class Derive : public Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func1()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func3()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func4()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func4()&quot; &lt;&lt; endl;\t&#125;private:\tint _d = 2;&#125;;\n\n当我们在子类中新增了一个虚函数Func4之后，再次打开监视，会发现子类的虚表中依旧只有两个函数指针。这是怎么回事？难道说子类没有被另外一个类继承，它的虚函数就不会进这里的虚表吗？\n\n通过内存窗口，我们可以看到这里的出现了两个监视窗口中已有的函数地址，但后面还有一个和前面两个很接近，但在监视窗口中没有出现的地址。而在这个地址之后是一行全0（即nullptr）\n\n以nullptr做结尾作为for循环的判断条件，我们可以把虚函数表中函数的地址都打印出来\n//重定义函数指针，需要将新的名字放在括号中间typedef void(*V_FUNC)();void PrintVfptrTable(V_FUNC* arr)&#123;\tfor (int i = 0; arr[i] != nullptr; i++)\t&#123;\t\tprintf(&quot;[%d] %p\\n&quot;, i, arr[i]);\t&#125;&#125;int main()&#123;\tBase b1;\tDerive d;    // 因为我们已经知道了，在VS中，虚函数表的指针就是对象的前4个字节\t// 这里是先将对象的指针强转为int*，取出前4个字节的地址\t// 再将这个地址解引用，相当于将地址转成int数字\t// 最后再将这个数字重新强转为V_FUNC*函数指针数组的指针，传给我们的打印函数\tPrintVfptrTable((V_FUNC*)(*((int*)&amp;d)));&#125;\n\n运行结果如下， 可以看到成功打印出了3个函数的地址，和内存窗口中看到的数据一致\n\ntypedef void(*V_FUNC)();void PrintVfptrTable(V_FUNC* arr)&#123;\tfor (int i = 0; arr[i] != nullptr; i++)\t&#123;\t\tprintf(&quot;[%d] %p -&gt; &quot;, i, arr[i]);\t\tV_FUNC f = arr[i];\t\tf();\t&#125;&#125;\n\n既然是函数指针，最终我们是可以通过函数指针来调用函数的。添加了函数调用部分的代码后，再运行，可以看到最后一个函数的确是子类中新增的虚函数Func4\n\n所以，VS的监视窗口中不显示Func4是因为VS认为这个函数没有被子类重写，无关痛痒，于是在监视窗口中隐藏了。\n实际上，只要是虚函数，那就是会进入到这个类中的虚函数表里面的！\n记住，只要是虚函数就一定会进虚表！\n6.3.2 为什么不新增一个子类的虚表？这里我还思考过另外一个问题，既然这个是子类自己的虚函数，那为什么没有多开一个虚表来存放这个函数的指针，而是直接放入到了继承自基类的虚函数表中呢？\n下图是Derive在VS2019的内存分布模型————————————|  _vfptr  | Base|  int _b  | Base|  int _d  | Derive————————————假设要新增一个指针，那按VS的规则，也是应该放在对象的最前面；此时模型就变成了下面这样————————————|  _vfptr  | Derive|  _vfptr  | Base|  int _b  | Base|  int _d  | Derive————————————新增了一个指针的内存占用不说，还把原本泾渭分明的内存模型，变成了两面包夹芝士；怎么说都是追加在Base的虚表之后更加靠谱，因为原本继承自Base的虚表就是子类对象的前4个字节！\n\n说明参考代码块中的注释。\n6.4 虚表的存储位置虚表是存在哪里的？先说答案：虚表是存在常量区里面的\n下图中的b1和b3是两个不同的Base对象，但我们会发现它们的虚表地址包括函数指针的地址都完全相同。毕竟这是两个完全相同的类，虚表里面的内容确实是相同的。\n这就告诉了我们，相同的类，其虚表在内存里面只有一张。初始化的时候，将这个类的虚表找到，并插入到类中。\n\n那么虚表是存在内存中的那个区域里面的呢？\n首先排除栈和堆，栈是随时用随时开辟的，而堆需要动态内存管理，对于这种编译器自己完成的操作，也不应该是这样。\n而静态区/数据段放的是全局数据或者静态变量，相比之下，常量区/代码段更靠谱。\n有了猜想之后，就要来验证了。\n我们将常用的存在不同位置的数据类型都弄出来，分别打印它们的地址\nint c = 2;int main()&#123;\tBase b1;\tint a = 0;\tstatic int b = 1;\tconst char* str = &quot;hello world&quot;;\tint* p = new int[10];\tprintf(&quot;栈：%p\\n&quot;, &amp;a);\tprintf(&quot;静态区/数据段：%p\\n&quot;, &amp;b);\tprintf(&quot;静态区/数据段：%p\\n&quot;, &amp;c);\tprintf(&quot;常量区/代码段：%p\\n&quot;, str);\tprintf(&quot;堆：%p\\n&quot;, p);\tprintf(&quot;虚表：%p\\n&quot;, (*((int*)&amp;b1)));\tprintf(&quot;函数地址：%p\\n&quot;, &amp;Derive::Func3);\tprintf(&quot;函数地址：%p\\n&quot;, &amp;Derive::Func2);\tprintf(&quot;函数地址：%p\\n&quot;, &amp;Derive::Func1);\treturn 0;&#125;\n\n输出结果如下\n\n这时候可以发现，虚表的地址和常量区&#x2F;代码段的地址开头相似，都是00DF9B，说明它更加靠近代码段的区域。\n而虚表的地址00DF9B34是小于常量区&#x2F;代码段的00DF9B6C的，这就表明了在内存中，虚表的地址比这个常量区参数的地址更低。而在内存中，不同区域的分布如下，常量区就是在最低处的。\n栈堆静态区/数据段常量区/代码段\n\n实锤了，虚表就是存在常量区里面的！类的虚函数表是在编译阶段就已经生成了的\n6.5 多继承中的虚表先说结论，如果出现了多继承，那么子类中会根据继承的父类分别产生独立的虚表（如果不是独立的，那就没有办法实现某个父类指针指向子类时，对子类的切片）\n以下就是一个最简单的多继承\nclass Base&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func2()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func2()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Base::Func3()&quot; &lt;&lt; endl;\t&#125;private:\tint _b1 = 1;&#125;;class Base2&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Base2::Func1()&quot; &lt;&lt; endl;\t&#125;private:\tint _b2 = 1;&#125;;class Derive : public Base,public Base2&#123;public:\tvirtual void Func1()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func1()&quot; &lt;&lt; endl;\t&#125;\tvoid Func3()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func3()&quot; &lt;&lt; endl;\t&#125;\tvirtual void Func4()\t&#123;\t\tcout &lt;&lt; &quot;Derive::Func4()&quot; &lt;&lt; endl;\t&#125;private:\tint _d = 2;&#125;;\n\n通过监视窗口，能看到这个对象的模型大概是如下图所示\n\n其中能看到子类独有的虚函数Func4是存在第一张虚表里面的（VS监视窗口依旧没有显示出来）\n\n这里还会发现一个问题：Base和Base2这两个基类中都有虚函数Func1，那为什么子类中这两个类的虚表中，这两个被子类重写的Func1函数的地址不相同呢？\n通过之前写的打印函数来打印第二章虚表里面的函数\ntypedef void(*V_FUNC)();void PrintVfptrTable(V_FUNC* arr)&#123;\tfor (int i = 0; arr[i] != nullptr; i++)\t&#123;\t\tprintf(&quot;[%d] %p -&gt; &quot;, i, arr[i]);\t\tV_FUNC f = arr[i];\t\tf();\t&#125;&#125;\n\n这里需要注意的是，我们对d这个子类的指针+1的时候，会直接跳过sizeof(Derive)个空间的大小。为了能精准地通过+sizeof(Base)找到Base2基类的虚表，就需要将子类的指针强转为char*，这样每次+1就是移动一个字节的空间。\nPrintVfptrTable((V_FUNC*)(*((int*)((char*)&amp;d+sizeof(Base)))));\n\n运行可以看到，即便内存不同，但实际上调用的依旧是子类的Func1函数；也能看到子类单独新增的虚函数只会放在第一个虚表中。\n\n6.5.1 Func1地址不同？在上面VS打印的虚表中，会发现一个问题：Base和Base1父类中的两个Func1函数的地址不相同，但最终我们看到的运行结果又都是子类重写后的Func1\n把相同的代码挪到liunx环境下，编译运行，发现出现了段错误\n$ ./test[0] 0x400b74 -&gt; Derive::Func1()[1] 0x400b48 -&gt; Base::Func2()[2] 0x400ba6 -&gt; Derive::Func4()Segmentation fault (core dumped)\n\n\n顺带一提，在linux下直接编译本博客中的代码会出现如下警告，因为我们对指针进行了多次强转，不用管他\n&gt;g++ test.cpp -o test -std=c++11&gt;test.cpp: In function ‘int main()’:&gt;test.cpp:92:44: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]    PrintVfptrTable((V_FUNC *)(*((int *)&amp;d)),3);                                           ^&gt;test.cpp:93:69: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]    PrintVfptrTable((V_FUNC *)(*((int *)((char *)&amp;d + sizeof(Base)))),1);                                                                    ^\n\n这是因为我们在打印虚函数表中，判断条件是当前函数指针为空，这是VS下对虚函数表的结束规定（以nullptr结尾），并不是linux下的操作，也不是C++对虚表的统一规定。\n所以，为了能正常打印出虚函数表，我们需要将打印函数的判断条件改成固定值；因为我们已经知道了虚函数表中函数的个数了。\n// 重定义函数指针，需要将新的名字放在括号中间typedef void (*V_FUNC)();void PrintVfptrTable(V_FUNC *arr, size_t size)&#123;    printf(&quot;_vfptr: %p\\n&quot;,arr);    for (int i = 0; i &lt; size; i++)    &#123;        printf(&quot;[%d] %p -&gt; &quot;, i, arr[i]);        V_FUNC f = arr[i];        f();    &#125;&#125;// 如下是修改后的调用PrintVfptrTable((V_FUNC *)(*((int *)&amp;d)),3);PrintVfptrTable((V_FUNC *)(*((int *)((char *)&amp;d + sizeof(Base)))),1);\n\n再次编译运行，也出现了相同的结果，两个基类虚函数表中的Func1地址不相同\n$ ./test_vfptr: 0x400d10[0] 0x400b86 -&gt; Derive::Func1()[1] 0x400b5a -&gt; Base::Func2()[2] 0x400bb8 -&gt; Derive::Func4()_vfptr: 0x400d38[0] 0x400bb1 -&gt; Derive::Func1()\n\n再新增一个直接对Derive::Func1函数本身地址的打印\nPrintVfptrTable((V_FUNC *)(*((int *)&amp;d)),3);PrintVfptrTable((V_FUNC *)(*((int *)((char *)&amp;d + sizeof(Base)))),1);printf(&quot;\\n&quot;);printf(&quot;Derive::Func1 %p\\n&quot;,(void*)&amp;Derive::Func1);\n\n输出结果如下，可以看到这个函数本身的地址和第一张虚表里面的Derive::Func1()地址是吻合的，但是和第二章虚表的地址不相符合\n_vfptr: 0x400cd0[0] 0x400b60 -&gt; Derive::Func1()[1] 0x400b34 -&gt; Base::Func2()[2] 0x400b92 -&gt; Derive::Func4()_vfptr: 0x400cf8[0] 0x400b8b -&gt; Derive::Func1()Derive::Func1 0x400b60\n\n而在windows的vs2019中，打印的地址就更奇怪了，其和两个虚表中的地址都对不上！\n_vfptr: 002D9B84[0] 002D141F -&gt; Derive::Func1()[1] 002D1393 -&gt; Base::Func2()[2] 002D106E -&gt; Derive::Func4()_vfptr: 002D9B98[0] 002D10B9 -&gt; Derive::Func1()Derive::Func1 002D1122\n\n\n这里我还发现了一个奇怪的问题，相同的代码在windows下和linux下的效果不同\n// 下面的代码在windows下可以正常打印函数地址，linux下打印出来的是0x1printf(&quot;Derive::Func1 %p\\n&quot;,(&amp;Derive::Func1));// 下面的函数在linux下可以正常打印函数地址，在windows下报错“强制类型转换失效”printf(&quot;Derive::Func1 %p\\n&quot;,(void*)&amp;Derive::Func1);\n\n有人知道这是为啥吗？😂\n\n你可以理解这是在不同平台下，对虚表中函数指针的一个处理，其最终还是会调用到正确的函数的。\n在windows下查看反汇编，能看到其最终是调用了ebp-14h的一个地址，在内存窗口中可以看到，这个地址正是虚表中存放的Func1函数地址\n\n使用调试在反汇编窗口中逐条运行，能进到这个call [ebp-14h]语句中，可以看到在002910B9这个地址上存放的就是子函数中的Func1函数地址，这里的汇编指令jmp相当于跳转到这个函数地址上\n\n再进一步观察会发现，这里显示的地址和打印出来的func1函数的地址还是不相同\n\n再跳转，还是不同\n\n再次跳转，依旧是不同\n\n再一次跳转，就跑到了子类中Func1函数的执行流里面了。此时就开始执行这个函数了！\n\n所以，这只是编译器在某些层面上的处理而已。包括第一个基类的虚表，也是这样的函数地址跳转。在linux下和windows的不同编译器下观察到的情况都不一样，我们没必要过多纠结于这里，只要知道有这类编译器处理的存在就可以了。\n\n最终两个基类对func1的函数调用的汇编流程如下图\n\n这其中，我们要发现Base2对Func1的调用，主要是多了下面这两句非常不同的汇编\n008426B0 83 E9 08             sub         ecx,8008426B3 E9 67 ED FF FF       jmp         Derive::Func1 (084141Fh)\n\n原本走到这一步，ecx寄存器的值是 0x00849b98。这一步执行完毕后，ecx的值是0x00849b90，可以看到更新后的值比原本的值少了8字节；正好是Base类的大小！\n这是因为在当前对象模型中，两个父类对象需要调用的Func1都是子类的Func1，此时使用的this指针应该是子类Derive的this指针，处于子类对象地址的起始位置。对于Base* ptr1来说，其指向的地址本身就是子类的起始地址，所以不需要进行修正。\n但Base2* ptr2指向的位置并不是子类的起始地址，此时就需要-8回到起始位置，用修正后的this指针来调用子类的Func1函数；\n\n这也就能解释为什么两个虚表中存放的函数指针地址不相同，因为调用的流程不一样，Base2的指针在调用的时候需要对ecx寄存器中的this指针进行修正。\n6.5.2 指针切片地址不同当我们用不同的父类指针指向这个子类对象的时候，由于会发生不同位置的切片，最终的地址并不相同。这点我们通过对象模型也能看出来，不同的父类都需要指向自己的那部分，所以切片后的地址不同。\nDerive d;Base* ptr1 =  &amp;d;Base2* ptr2= &amp;d;Derive* ptr3 = &amp;d;printf(&quot;Base: %p\\nBase2: %p\\nDerive: %p\\n&quot;, ptr1, ptr2, ptr3);\n\n\n6.6 菱形虚拟继承中的虚函数表class A&#123;public:\tvirtual void func()\t&#123;\t\tcout &lt;&lt; &quot;A:func&quot; &lt;&lt; endl;\t&#125;\tint _a;&#125;;class B : public A&#123;public:\tint _b;&#125;;class C : public A&#123;public:\tint _c;&#125;;class D : public B, public C&#123;public:\tint _d;&#125;;\n\n使用上图代码进行虚拟继承的时候，内存模型如图，在B类和C类中都会有一个继承自A类的虚表；因为这里没有进行函数重写，所以地址是一样的。\n\n当我们在B和C类中重写此函数，对象模型如下，B类和C类中虚表的函数指针不同\n\n但如果我们把B和C对A的继承都改成虚继承，此时就会报错了！\n\n在前面的虚继承讲解中，提到了在VS下，是将公共基类放在子类的最后面的，此时模型的顺序大概如下\nBCDA\n\n由于B和C都使用了虚继承，解决了数据二义性问题，但没有解决A中的虚表到底是存B重写后的func，还是存C重写后的func的问题；\n这个时候我们就需要在D里面重写func，这时候就能确定最终使用的是D里面对func的重写，也就不会有到底是选B还是选C的分歧问题了。\n\n6.7 虚函数和inline6.7.1 状态观察我们先尝试给一个虚函数加上inline内联关键字\nclass A&#123;public:\tvirtual inline void f1()\t&#123;\t\tcout &lt;&lt; &quot;f1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void f2();&#125;;// 声明和定义分离就不是内联函数了void A::f2()&#123;\tcout &lt;&lt; &quot;f2()&quot; &lt;&lt; endl;&#125;int main()&#123;\tA aa;\taa.f1();\taa.f2();\treturn 0;&#125;\n\n修改VS2019项目的属性\n\n\n转到反汇编，可以看到f1函数被展开，f2函数依旧是call地址的调用\n\nclass A&#123;public:\tvirtual inline void f1()\t&#123;\t\tcout &lt;&lt; &quot;f1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void f2()\t&#123;\t\tcout &lt;&lt; &quot;f2()&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n如果不将声明和定义分离，可以观察到两个函数都被编译器认作是内联而展开了。\n\n此时新增一个继承，再来看看反汇编\nclass A&#123;public:\tvirtual inline void f1()\t&#123;\t\tcout &lt;&lt; &quot;f1()&quot; &lt;&lt; endl;\t&#125;\tvirtual void f2();&#125;;// 声明和定义分离就不是内联函数了void A::f2()&#123;\tcout &lt;&lt; &quot;f2()&quot; &lt;&lt; endl;&#125;class B:public A&#123;public:\tvirtual void f1()\t&#123;\t\tcout &lt;&lt; &quot;B f1()&quot; &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tA aa;\taa.f1();\taa.f2();\treturn 0;&#125;\n\n此时我们发现，似乎f1函数依旧是有内联的属性\n\n这说明虚函数是可以用virtual关键字来修饰的。\n但如果用多态调用呢？\nA* aa = new B();aa-&gt;f1();aa-&gt;f2();\n\n此时就能发现，原本的多态展开，就变回了call函数地址的调用\n\n这是因为内联函数是没有地址的！而多态基于虚基表实现，虚基表中必须要存放函数的地址！\n6.7.2 结论结论就是，在多态中，对虚函数的inline修饰不会报错，但会被编译器忽略（不会有内联的属性），依旧是个普通的函数\n7.静态成员函数不能是虚函数静态成员函数属于整个类，无法被指定对象重写。\n而且静态成员函数没有this指针，可以直接用类名来调用，但这也决定了其无法访问到虚表，自然也无法实现多态。\n所以静态成员函数是不能做虚函数的，在VS中这样写会直接报错\n\n8.构造函数不能是虚函数通过调试可以发现，虚函数表中的指针原本是随机值，是在构造函数中被初始化为正确的函数地址的\n\n\n既然是在构造函数中初始化的，那么虚函数表就不能先于构造函数被初始化出来，也就没有办法通过虚表来实现多态。\n所以构造函数是不能为虚函数的！\n9.菱形继承构造顺序如下虚菱形继承中，调用构造函数的顺序是什么？\nclass A &#123;public:\tA(const char* s) &#123; cout &lt;&lt; s &lt;&lt; endl; &#125;\t~A() &#123;&#125;&#125;;class B :virtual public A&#123;public:\tB(const char* s1, const  char* s2) :A(s1) &#123; cout &lt;&lt; s2 &lt;&lt; endl; &#125;&#125;;class C :virtual public A&#123;public:\tC(const char* s1, const  char* s2) :A(s1) &#123; cout &lt;&lt; s2 &lt;&lt; endl; &#125;&#125;;class D :public B, public C&#123;public:\tD(const char* s1, const char* s2, const  char* s3, const  char* s4) :B(s1, s2), C(s1, s3), A(s1)\t&#123;\t\tcout &lt;&lt; s4 &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tD* p = new D(&quot;class A&quot;, &quot;class B&quot;, &quot;class C&quot;, &quot;class D&quot;);\tdelete p;\treturn 0;&#125;\n\n我们只需要知道，类的对象在实例化的时候，初始化的顺序就是类声明的顺序\n依照代码中的顺序流程读下来，就是构造函数被初始化的顺序；\n而且A的构造函数也是由最终子类D直接发起的，而不是B或者C发起的。\n\n下面这道题也是一个有关于构造顺序和多态调用的问题\n\n在linux下测试，最终打印的是\nbarfoob_bar\n\n调用顺序为\n\n父类A的构造函数调用父类自己的bar函数，因为这时候虚表还没有初始化，所以不存在多态，打印bar\n父类指针指向子类，调用foo函数，由于foo函数不是虚函数，不在虚表内，所以调用的是父类的foo函数，打印foo\n父类指针调用bar函数，此函数为多态调用，调用的是子类的bar函数，打印b_bar\n\n所以最终的输出结果是barfoob_bar\nThe end内容丰富的继承和多态的博客终于补充完毕了！\n如果有问题还请提出！\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】哈希Hash（未完成）","url":"/posts/593601584/","content":"学习完了红黑树以及map&#x2F;set，下面让我们来康康另外一种用于查找数据的新方式，那便是哈希表\n\n\n1.概念哈希是一种用下标映射来查找数据的方式。在STL库中，有map和set的unordered(即为stl库里面的哈希)版本\n我们可以来对比一下它和红黑树（map/set的标准版本）的查找时间差距（是通过for循环查找所有插入数据来实现的计时）\n\n可以看到，在查找方面，unordered版本查找的速度比正常的map和set快了一倍有余。之前我已经觉得搜索二叉树的查找已经非常快了，实际上哈希才是真正的快中之快！\n这两种算法的时间复杂度为：\n\n平衡二叉搜索树 O(logN)\n哈希算法 O(1)\n\n因为哈希是直接从对应的下标映射位置找到数据的，这就和我们进行随机访问顺序表里面的数据一样，都是O(1)的直接访问\n1.1 下标映射那么，要怎么对一个数据进行下标映射呢？\n\n假设我们现在有一个长度为10的数组\n我们需要存放一组int类型的数据，0-9以内的数字可以直接通过下标映射放入对应位置。而大于9的数据则需要进行取模操作，找到对应的下标。比如12%10=2，则放入下标为2的位置\n\n那，如果一个下标位置本来就有数据了怎么办?我们有两种办法来解决这个问题\n1.2 闭散列（开放定址法）当一个下标的位置已经有数据的时候，如果哈希表还没有满，我们可以往这个映射位置的后方插入这个数据\n\n线性探测：依次去找空位置，找到后直接插入\n二次探测：跳跃地找空位置，不会出现太多的拥堵\n\n你可能会问，不对啊。你把别人的位置占了，到时候被人要用这个位置，该怎么去操作啊？\n没错，这个就是闭散列的一大缺点：会占用原本属于其他人的空间。\n1.3 开散列（拉链法）这时候我们就需要用到拉链法。于其在每一个下标映射的位置插入一个数据，我们不如整一个链表。在原有的哈希表中存放链表的头节点。当有相同映射值的数据插入的时候，我们可以执行链表的头插，使其挂载到相同位置的链表上。\n\n这个链表也被称为桶\n\n而没有数据的映射位置，全都为nullptr空指针\n\n在这个应用场景下，我们只需要使用单链表即可以完成桶的操作。若使用list或者自己写的双链表，则会出现不必要的空间浪费。\n你可能会问，那如果一个映射值挂载了特别多的节点，查找的效率会不会从O(1)变成O(N)（即需要遍历一个链表）的时间复杂度呢？\n这就必须要提到哈希表的扩容问题了\n1.4 什么时候需要扩容？在哈希表中，我们一般会定义一个负载因子，用于标记哈希表的数据个数\n负载因子=已有元素个数/总长度\n\n当负载因子大于一定数量级的时候，也就是哈希表快要满的时候，插入数据遇到冲突的可能性就非常大。即便我们用拉链法挂载了桶，如果冲突很多的话，就容易出现上面说的效率低下问题。\n而如果我们的负载因子不大的时候，大部分情况新插入的节点都能找到它自己独立的没有冲突的映射位置，这样就大大增加了访问效率\n\n需要注意的是，哈希表的映射关系和表的长度相关\n所以当我们扩容之后，需要把当前表内的所有元素拿出来，根据键值重新进行下标映射，插入进新表。\n\n对于开放定址法，负载因子应该限制在0.8以下。java的系统库中就以0.75作为了负载因子的限制值，超过此值将进行扩容操作\n\n1.5 怎么映射？关于映射的即便理念、冲突、扩容问题我们都已经提到了。现在还有一个重要的问题，那就是怎么映射？\n如果我们插入的数据是int或者char、double这种可以强转为int的类型作为key，那还算好操作，直接用int进行下标映射即可。\n\n那假如我们用string/自定义类型来作为key呢？\n\n这种类型不能直接强制转为int，虽然string我们可以取第一个元素的ASCII码作为映射值。但是那么做的冲突会非常多，ABC/ADFC/ASD这些字符串都是以A开头，难道我们就要把它放在相同位置下面吗？那样效率也太低了！\n\n可不可以把字符串每一个字符的ASCII加起来呢？\n\n这样能解决一定程度上的冲突，但是ABC/ACB这种字符串排列不同，但是字符是相同的字符串，就会得出相同的结果造成冲突。\n\n这时候就有一个不知名的程序猿[Dennis M. Ritchie](https://baike.baidu.com/item/Dennis M. Ritchie&#x2F;1971171?fromModule&#x3D;lemma_inlink)想出来了一个超级牛逼的办法：把每一个char的ASCII都乘上一个数，再进行相加\nsize_t operator()(const string&amp; key)&#123;    size_t hash = 1;    for (auto s : key)    &#123;//每一次都*13，避免冲突        hash = hash * 13 + s;    &#125;    return hash;&#125;\n\n因为字符串的排列顺序不相同，所以每一次获得的hash值肯定是不同的，再乘上一个数之后，就完美的避免了大部分的冲突问题。\n这个方法可以沿用到所有自定义类型！比如我们之前写的日期类，就可以把年加入hash之后，乘一个数再加月，再乘一个数再加天\n这么牛逼的方法，怎么可能是不知名程序员想出来的？咳咳，实际上，Dennis M. Ritchie还有另外一个名字“C语言之父”\n\n膜拜大佬，大佬牛逼！😍\n\n在本篇博客中就不去讲解STL库中unordered_map/set的使用办法了，因为它们的使用和基础的map/set相差无几。我们直接开始模拟实现\n2.哈希表1-开放定址法2.1 插入插入的时候，我们要做的便是遵循哈希表的映射方法，对key进行映射，再将pair插入进封装好的vector中\n插入的思路如下：\n\n首先判断哈希表中是否有相同键值key的数据（此时我们写的是不支持键值冗余的哈希表，如果出现相同键值的数据，则不再进行二次插入return false（这里复用了查找函数）\n若没有这个键值，则判断负载因子的占比。这里我设置的负载因子是0.7，超过这个比例的时候，将会执行扩容操作。注意：扩容之后映射的位置会发生变化，所以我们需要对已有的数据进行重新插入。\n扩容（或不需要扩容）结束后，我们利用预先写好的仿函数获取道key的hash值，找到对应下标位置。这里采用线性探测的方法，如果当前的下标位置已经有数据了，则往后查找状态值为EMPTY/DELETE的位置，并将我们的数据插入到这个位置上。\n插入成功后，将状态修改为EXITS，return true插入结束\n\nbool Insert(const pair&lt;K, V&gt;&amp; kv)&#123;    if (Find(kv.first))//找到了相同的键值，直接退出（说明已经插入过了）    &#123;        return false;    &#125;    // 负载因子到0.7及以上，就扩容（避免冲突）    if (_tables.size() == 0 || _n * 10 / _tables.size() &gt;= 7)    &#123;        size_t newSize = _tables.size() == 0 ? 10 : _tables.size() * 2;        // 扩容以后，需要重新映射        HashTable&lt;K, V, HashFunc&gt; newHT;        newHT._tables.resize(newSize);// 扩容vector        // 遍历旧表，插入newHT        for (auto&amp; e : _tables)        &#123;            if (e._state == EXITS)            &#123;                newHT.Insert(e._kv);            &#125;        &#125;        newHT._tables.swap(_tables);        //利用vector的交换，这是一种现代写法的深拷贝    &#125;    HashFunc hf;// 仿函数的实例化    size_t starti = hf(kv.first);    starti %= _tables.size();    size_t hashi = starti;    size_t i = 1;    // 线性探测/二次探测    // 线性探测代表是自映射值开始往后依次找为空的位置    // 二次探测指跳着找为空的位置    while (_tables[hashi]._state == EXITS)    &#123;        hashi = starti + i;        ++i;//依次查找，为线性探测        hashi %= _tables.size();    &#125;    _tables[hashi]._kv = kv;//插入数据    _tables[hashi]._state = EXITS;//修改状态码    _n++;//长度+1    return true;&#125;\n\n2.2 查找和之前模拟实现的map一样，查找函数我们需要返回一个data，以便用户修改value\n因为这里我们使用的是开放定址法，没有设置桶。所以查找的操作和顺序表的查找没有本质上的区别。\n\n当映射值的位置就是我们需要找的key，直接返回当前的位置\n当当前映射值的数据不是我们需要找的key，说明这个地方出现了冲突。这时候我们现需要往后查找（线性探测，依次查找）查找的时候需要判断状态码\n如果状态码为EMPTY，则代表后面没有这个数据，返回nullptr代指找不到\n如果状态码为EXITS或者DELETE，说明后面还有可能找到这个数据找到数据后返回该数据的引用\n\n\n如果遍历完整个列表，还是没有找到该数据，同样返回nullptr\n\n这里单独说明DELETE：在insert和find操作之中，我们可能执行了删除，这时候就有可能导致原本的映射值位置和线性探测后的位置之中出现了状态码为DELETE的位置。遇到DELETE并不代表后面没有这个键值，我们需要继续查找。这点和insert的判断不同。\n\n代码实现如下\n//查找Data* Find(const K&amp; key)&#123;    //空表    if (_tables.size() == 0)    &#123;        return nullptr;    &#125;    HashFunc hf;//仿函数的实例    size_t starti = hf(key);//利用hash仿函数算出起始值    starti %= _tables.size();//进行膜大小，获取道映射值    size_t hashi = starti;    size_t i = 1;    while (_tables[hashi]._state != EMPTY)    &#123;        if (_tables[hashi]._state != DELETE &amp;&amp; _tables[hashi]._kv.first == key)        &#123;            return &amp;_tables[hashi];        &#125;        hashi = starti + i;        ++i;//线性探测        hashi %= _tables.size();    &#125;    return nullptr;&#125;\n\n2.3 删除删除操作比较简单，我们利用find找到键值后，直接把这个位置的状态码改成DELETE即可，并不需要执行释放空间的操作。\n如果没有这个键值，则返回false\n//删除，找到映射位置之后，直接修改状态码，而不是真的删除这个内容bool Erase(const K&amp; key)&#123;    Data* ret = Find(key);    if (ret)    &#123;        ret-&gt;_state = DELETE;        _n--;        return true;    &#125;    else    &#123;        return false;    &#125;&#125;\n\n\n","categories":["遇见C++"],"tags":["C++","数据结构","哈希"]},{"title":"【C++】AVL树（平衡搜索二叉树）","url":"/posts/3807693015/","content":"在上一篇C++博客中，讲述了关于搜索二叉树以及KVL树的实现。也提到了搜索二叉树的最坏情况：插入的数据已经有序。\n而本篇博客涉及到的AVL树，又称平衡搜索二叉树。就是为了解决搜索二叉树的最坏情况而生的。\n\n\n[TOC]\n1. 什么是AVL树二叉搜索树虽然缩短了查找的效率，但是数据有序的时候，就会出现一边非常长的情况，导致原本的O(logN)时间复杂度被迫变成了O(N)\n平衡树也是搜索二叉树，其引入了一个平衡因子的概念，用于控制搜索二叉树的平衡。它会保证左右子树的高度之差（绝对值）不超过1。当新插入节点导致高度之差超过1时，便会触发旋转，使得树的高度降低。\n\n简单说来：AVL树能保证两边高度的相对平衡，这样就稳定了二叉搜索树的效率\n\n1.1 二叉搜索树的性质一颗AVL树或空树，其有以下性质\n\n它的左右子树是AVL树\n左右子树的高度之差的绝对值不超过1\n\n这里引入平衡因子来方便我们控制二叉树的高度。每一个节点都会有一个平衡因子，它的值是1/0/-1。如果平衡因子的值超过了1，那么说明这个节点的子树已经不平衡，需要进行旋转。\n\n实际上，AVL树不一定非要用平衡因子。我们可以用计算树的高度的方式来确认平衡因子，但是这样需要遍历左右子树，时间复杂度较高\n\n2. 实现一颗AVL树2.1 AVL树的节点基本的概念理解之后，我们需要设计出一个节点的结构来。关于各个值的含义，可以参考下方的注释\n\n平衡搜索二叉树是一个“三叉链”。这代表每一个节点都有左右孩子，还有一个prev指针指向它的父节点。为了标识树是否平衡，准确来说是某个节点的左右子树是否平衡。我们需要引入一个“平衡因子”来进行判断，方便我们控制平衡\n\n左右子树高度相同  0\n左子树高于右子树  -1\n右子树高于左子树  1\n\n\ntemplate&lt;class K,class V&gt;struct AVLTreeNode&#123;\tpair&lt;K, V&gt; _kv;//键值对\tAVLTreeNode&lt;K, V&gt;* _left;//左子树\tAVLTreeNode&lt;K, V&gt;* _right;//右子树\tAVLTreeNode&lt;K, V&gt;* _parent;//父节点\t// 右子树-左子树的高度差\tint _bf;  // 平衡因子\tAVLTreeNode(const pair&lt;K, V&gt;&amp; kv)\t\t:_kv(kv),\t\t_left(nullptr),\t\t_right(nullptr),\t\t_parent(nullptr),\t\t_bf(0)\t&#123;&#125;&#125;;\n\n关于键值对的内容，在上篇博客的KVL树中有提到过 【传送门】\n\n2.2 AVL树的插入（重要）因为AVL需要控制树的高度，其插入的时候就没有KVL树那么方便了。我们每次插入之后，都需要向上更新并判断树的平衡因子是否正常\n先来理清一下思路:\n\n如果是空树，new一个新节点交给root，无需进行后续操作\n插入新节点的时候，利用搜索二叉树的规则（在这里我采用了左小右大的规则）来找到新节点应该插入的位置，直接进行插入\n插入之后，需要向上更新平衡因子（利用父节点parent）\n如果该插入节点在父节点的右边，平衡因子+1\n如果在该节点的左边，平衡因子-1。\n\n\n更新了平衡因子之后，需要及时进行判断。如果平衡因子等于0，则不需要继续往上更新。如果平衡因子的绝对值大于1，说明当前就需要旋转了\n\n根据这个思路，我们可以先写出插入的一个基本框架\nbool Insert(const pair&lt;K, V&gt;&amp; kv)&#123;\t//判断root为空，即空树\tif (_root == nullptr)\t&#123;\t\t_root = new Node(kv);\t\treturn true;\t&#125;\t//kv树的操作\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;           //利用key来判断，寻找待插入的位置\t\tif (cur-&gt;_kv.first &lt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (cur-&gt;_kv.first &gt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse&#123;\t\t\treturn false;\t\t&#125;\t&#125;\t//找到位置后插入节点\tcur = new Node(kv);\tif (parent-&gt;_kv.first &lt; kv.first)\t&#123;\t\tparent-&gt;_right = cur;\t&#125;\telse\t&#123;\t\tparent-&gt;_left = cur;\t&#125;\tcur-&gt;_parent = parent;\t//插入之后需要向上更新平衡因子\twhile (parent)\t&#123;\t\tif (cur == parent-&gt;_left) &#123;\t\t\tparent-&gt;_bf--;//左-1\t\t&#125;\t\telse&#123;\t\t\tparent-&gt;_bf++;//右+1\t\t&#125;\t\t//更新了之后，需要判断是否继续更新，还是需要旋转\t\tif (parent-&gt;_bf == 0) &#123;\t\t\tbreak;//为0代表高度没有变化，不需要继续更新\t\t&#125;\t\telse if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)\t\t&#123;\t\t\tcur = cur-&gt;_parent;//向上更新\t\t\tparent = parent-&gt;_parent;\t\t&#125;\t\telse if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)\t\t&#123;\t\t\t//旋转\t\t&#125;\t\telse\t\t&#123;\t\t\t//插入之前AVL就存在不平衡子树\t\t\tassert(false);\t\t&#125;\t&#125;\treturn true;&#125;\n\n其中最复杂的部分：旋转，需要拿出来单独讲解一番\n\n下面是一个最简单的二叉树进行插入之后，平衡因子的变化。\n\n因为搜索二叉树需要保证两边的高度之差不大于1，所以此时我们的树还没有违背AVL树的规则。\n可如果我们继续往右子树插入节点呢？\n\n可以看到，最后一颗子树的根节点的平衡因子为2，超过了1。此时两边子树的高度差为2，需要我们进行旋转操作\n2.2.1 左&#x2F;右单旋为了简化，我们把上图的插入情况直接简化为下面的样子\n\n当我们在这棵树高度较高的那一侧的边缘插入的时候，就需要进行单旋。\n\n比如右边高，就是在最右边的叶子处插入\n\n单旋的思路很好理解，下面以左单旋为例（蓝色代表新增节点）\n\n这里我们设置了3个不同的节点，分别是prev起始节点（即平衡因子大于1的节点）以及它的右子树subR、右子树的左子树subRL（即图中的b子树）\n\n需要做的操作，就是把subRL链接给prev的右，再将prev链接到subR的左\n因为subRL在prev的右侧，其的值肯定大于prev，所以这样链接是不会破坏搜索二叉树的结构的。\n\n旋转完成之后，我们需要把prev和subR的平衡因子都更新为0\n\n右单旋的操作和左单旋的思路完全相同，只不过方向相反\n\n\n思路搞定了，下面就来写一个代码吧！\nvoid RotateL(Node* parent)//左单旋&#123;    Node* prev = parent;    Node* subR = parent-&gt;_right;    Node* subRL = subR-&gt;_left;    //用来记录当前parent的父亲，最后的链接需要    Node* ppNode = parent-&gt;_parent;    prev-&gt;_right = subRL;    if (subRL != nullptr)    &#123;//不为空才能进行parent操作        subRL-&gt;_parent = prev;    &#125;    subR-&gt;_left = prev;    prev-&gt;_parent = subR;    if (prev == _root)    &#123;//单独操作为根节点的情况        //subR-&gt;_parent = nullptr;        _root = subR;        _root-&gt;_parent = nullptr;    &#125;    else    &#123;        if (prev == ppNode-&gt;_left) &#123;            ppNode-&gt;_left = subR;        &#125;        else &#123;            ppNode-&gt;_right = subR;        &#125;        subR-&gt;_parent = ppNode;    &#125;    //默认全都改成0    subR-&gt;_bf = parent-&gt;_bf = 0;&#125;\n\n右单旋的代码和这个类似，这里就不贴出来了\n\n完整代码可以到我的代码仓库里面看哦！【Gitee】\n\n旋转的代码写好了，我们现在还需要了解的是，什么时候需要进行单旋？\n看图可以得知，当prev的平衡因子为-2，subL的平衡因子为-1的时候，需要进行一次右单旋\n\n同理，我们可以推断出一个结论，那就是当父节点的平衡因子的绝对值超过1，其左&#x2F;右边节点的平衡因子为1且和父节点平衡因子的正负相同时，需要向另外一个方向进行单旋。\n左单旋就是父节点为2，其右子树为1，需要向另外一个方向左进行单旋\n\n需要注意的是，虽然图里面画出来的prev是根节点，但实际上进行单旋的时候，prev可能是另外一棵树的子树。在单旋的处理过程中，我们必须要保存prev的父节点，并重新链接至subR\n//插入函数的旋转部分else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)&#123;    if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1)    &#123;        RotateL(parent);    &#125;    else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1)    &#123;        RotateR(parent);    &#125;    else    &#123;        //……    &#125;    break;&#125;\n\n我们用下面的代码进行测试\nvoid TestAVLTree1()&#123;\tint a[] = &#123;9,8,7,6,5,4,3,2,1 &#125;;\tAVLTree&lt;int, int&gt; t;\tfor (auto e : a)\t&#123;\t\tt.Insert(make_pair(e, e));\t&#125;\tt.InOrder();\tcout &lt;&lt; endl;&#125;\n\n进行中序打印，可以获取道下面的结果。可以看到数据已经有序\n\n在VS2019的调试窗口中可以看到，我们厂家的这棵树是符合平衡搜索二叉树的性质的\n\n\n2.2.2 左右&#x2F;右左双旋上面的情况还算容易，一次单旋就能解决。那如果我们插入不有序的数据呢？\n\n可以看到中序打印的结果已经有序，可它符合平衡二叉树的规则吗？\n再插入一个25，会发现触发了断言，说明AVL树的规则被破坏了\n\n就好比下面的这种情况，我们是以15 6 7这种非有序方式插入的，就会出现单旋完全处理不了的情况\n\n如果进行单旋会发生什么呢？\n\n可以看到，毫无变化。旋转了之后的节点依旧是违反AVL树的规则\n这时候我们就需要进行两次循环了！\n\n概念理解了之后，我们就可以直接来写代码了。\n因为本质上就是两次单旋，所以我们可以直接复用之前写好的单旋代码\nvoid RotateLR(Node* parent)//左右&#123;    RotateL(parent-&gt;_left);    RotateR(parent);&#125;\n\n但事情远没有这么简单！\n在2.2.1单旋的操作中，我们旋转完毕后会把prev和subL的平衡因子都改成了0。在这种双旋的情况下，全改成0显然不符合要求。\n下面的情况，我们就需要在旋转之后，把10的平衡因子改成-1，20和30的平衡因子改成0\n\n双旋的情况分为下面3种，我们可以直接用紫色框中所指的这个节点来判断属于哪一种情况，再针对性的处理！\n\n处理之后的结果如下\n\n其代码逻辑如下\n//这种双旋转的情况，基本如下//   9// 7//   8//必须要双旋转才能解决问题void RotateLR(Node* parent)//左右&#123;    Node* prev = parent;    Node* subL = parent-&gt;_left;    Node* subLR = subL-&gt;_right;    int bf = subLR-&gt;_bf;    RotateL(parent-&gt;_left);    RotateR(parent);    if (bf == 0)    &#123;        prev-&gt;_bf = 0;        subL-&gt;_bf = 0;        subLR-&gt;_bf = 0;    &#125;    else if (bf == 1)    &#123;        subL-&gt;_bf = -1;        prev-&gt;_bf = 0;        subLR-&gt;_bf = 0;    &#125;    else if (bf == -1)    &#123;        subL-&gt;_bf = 0;        prev-&gt;_bf = 1;        subLR-&gt;_bf = 0;    &#125;    else &#123;        assert(false);    &#125;&#125;void RotateRL(Node* parent)//右左&#123;    Node* prev = parent;    Node* subR = parent-&gt;_right;    Node* subRL = subR-&gt;_left;    int bf = subRL-&gt;_bf;    RotateR(parent-&gt;_right);    RotateL(parent);    if (bf == 0)    &#123;        prev-&gt;_bf = 0;        subR-&gt;_bf = 0;        subRL-&gt;_bf = 0;    &#125;    else if (bf == -1)    &#123;        subR-&gt;_bf = 1;        prev-&gt;_bf = 0;        subRL-&gt;_bf = 0;    &#125;    else if (bf == 1)    &#123;        subRL-&gt;_bf = 0;        subR-&gt;_bf = 0;        prev-&gt;_bf = -1;    &#125;    else &#123;        assert(false);    &#125;&#125;\n\n到这里我们就可以把插入函数给补全了！\n\n完整代码可以到我的代码仓库里面看哦！【Gitee】\n\n还是刚刚的测试用例，这一次我们可以看到，它已经没有报错了！\n\n\n2.3 AVL树的搜索本质上AVL树还是一个平衡二叉树，所以搜索肯定是少不了的！\n它的搜索和KVL树完全一致，利用key来进行搜索，定位value。\n所以，我们可以直接搬过来用。\n//因为kvl树我们需要修改value，所以返回节点的指针Node* _FindR(Node* root, const K&amp; key)&#123;\tif (root == nullptr)\t\treturn nullptr;\tif (root-&gt;_kv.first &lt; key)\t&#123;\t\treturn _FindR(root-&gt;_right, key);\t&#125;\telse if (root-&gt;_kv.first &gt; key)\t&#123;\t\treturn _FindR(root-&gt;_left, key);\t&#125;\telse\t&#123;\t\treturn root;//返回节点的指针\t&#125;&#125;\n\n上面的这个函数我们定义为私有，在公有里面定义一个下面的函数\n//查找是通过key来进行的Node* FindR(const K&amp; key)&#123;\treturn _FindR(_root, key);&#125;\n\n测试一下可以看到，打印了全0的地址值，即nullptr，说明没有找到34\n\n2.4 如何判断是否符合AVL树的性质如果每一次我们都要用调试去看当前的代码是否符合二叉树的性质，未免有些太麻烦了\n下面我们有两种办法来简洁地判断！\n2.4.1 层序遍历（OJ题）下面的代码是一道OJ题的答案，其要求是让我们把树每一层的节点都插入一个vector，最后返回的是一个嵌套的vector&lt;vector&lt;int&gt;&gt;\n\n来自 https://leetcode.cn/problems/binary-tree-level-order-traversal/\n\n因为我们当前测试的用例都是int类型，所以这里就没有用模板参数。实际上我们应该改成key的类型\nvector&lt;vector&lt;int&gt;&gt; levelOrder() &#123;\tvector&lt;vector&lt;int&gt;&gt; vv;\tif (_root == nullptr)\t\treturn vv;\tqueue&lt;Node*&gt; q;\tint levelSize = 1;\tq.push(_root);\twhile (!q.empty())\t&#123;\t\t// levelSize控制一层一层出\t\tvector&lt;int&gt; levelV;\t\twhile (levelSize--)\t\t&#123;\t\t\tNode* front = q.front();\t\t\tq.pop();\t\t\tlevelV.push_back(front-&gt;_kv.first);\t\t\tif (front-&gt;_left)\t\t\t\tq.push(front-&gt;_left);\t\t\tif (front-&gt;_right)\t\t\t\tq.push(front-&gt;_right);\t\t&#125;\t\tvv.push_back(levelV);\t\tfor (auto e : levelV)\t\t&#123;\t\t\tcout &lt;&lt; e &lt;&lt; &quot; &quot;;\t\t&#125;\t\tcout &lt;&lt; endl;\t\t// 上一层出完，下一层就都进队列\t\tlevelSize = q.size();\t&#125;\treturn vv;&#125;\n测试一下，可以看到每一层的结果，符合我们AVL树的性质\n\n2.4.2 检查平衡因子这里我们用两个递归函数，通过计算子树的高度，来判断是否满足AVL树的性质。\n只要两个子树的高度差大于1，就说明不是AVL树\n//计算高度int _Height(Node* root)&#123;    if (root == nullptr)        return 0;    int lh = _Height(root-&gt;_left);    int rh = _Height(root-&gt;_right);    //如果左子树高于右子树，就返回左子树+1（根）    return lh &gt; rh ? lh + 1 : rh + 1;&#125;//判断是否为平衡二叉树bool _IsBalanceTree(Node* root)&#123;    // 空树也是AVL树    if (nullptr == root)        return true;    // 计算pRoot节点的平衡因子：即pRoot左右子树的高度差    int leftHeight = _Height(root-&gt;_left);    int rightHeight = _Height(root-&gt;_right);    int diff = rightHeight - leftHeight;    // 如果计算出的平衡因子与pRoot的平衡因子不相等，或者    // pRoot平衡因子的绝对值超过1，则一定不是AVL树    if (abs(diff) &gt;= 2)    &#123;        cout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot;节点平衡因子异常&quot; &lt;&lt; endl;        return false;    &#125;    if (diff != root-&gt;_bf)    &#123;        cout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot;节点平衡因子不符合实际&quot; &lt;&lt; endl;        return false;    &#125;    // pRoot的左和右如果都是AVL树，则该树一定是AVL树    return _IsBalanceTree(root-&gt;_left)        &amp;&amp; _IsBalanceTree(root-&gt;_right);&#125;\n\n\n\n2.5 利用随机值和顺序值进行测试下面我们分别利用随机值和顺序值测试AVL树的正确性\nvoid TestAVLTree2()&#123;\tconst size_t N = 1024*1024;\tvector&lt;int&gt; v;\tv.reserve(N);\tsrand(time(0));//使用随机数\tfor (size_t i = 0; i &lt; N; ++i)\t&#123;\t\tv.push_back(rand());\t\t//v.push_back(i);\t&#125;\tAVLTree&lt;int, int&gt; t;\tfor (auto e : v)\t&#123;\t\tt.Insert(make_pair(e, e));\t&#125;\tcout &lt;&lt; &quot;是否平衡?&quot; &lt;&lt; t.IsBalanceTree() &lt;&lt; endl;\tcout &lt;&lt; &quot;高度:&quot; &lt;&lt; t.Height() &lt;&lt; endl;&#125;\n\n利用随机数测试的结果如下\n\n顺序插入的结果如下\n\n没有问题辣！\n2.6 AVL树的删除AVL树的删除和KVL树是基本相同的，但是我们需要更新平衡因子。\n\n如果删除的是左节点，平衡因子+1\n如果删除的是右节点，平衡因子-1\n\n当我们遇到平衡因子错误（绝对值大于1）就需要进行旋转\n\n因为搜索树中一般不会进行删除，效率很低，所以这里就不写了！（懒）\n\n2.7 二叉树性能在一些时候，搜索二叉树的性能并不会很高\n\n比如当我们插入的元素已经有序，或者基本有序的时候，二叉树的性能就和普通的容器差距不大了\nAVL树更适合于插入的元素不会被改变的情况。如果插入的元素需要经常被修改，那么也不太适合。（比如删除的时候，AVL树的平衡因子可能需要一直向上到根，时间复杂度不亚于二次插入）\n\n结语那么本篇关于AVL树的博客到这里就结束拉！\n有什么问题欢迎在评论区提出哦！\n\n","categories":["遇见C++"],"tags":["C++","数据结构","树"]},{"title":"【C++】STL map_set","url":"/posts/97886566/","content":"本篇博客让我们来了解一下STL库里面的map&#x2F;set的使用，并尝试用自己写的红黑树封装一个类似的map/set出来\n\n\n\n所用编译器：VS2019\n\n[TOC]\n1 setset就是二叉搜索树中只有单个key的树，它有下面的函数可供使用\n1.1 构造函数、迭代器构造函数、迭代器什么的都很简单，在这里就提到了，和其他STL基本一致\n\n\n1.2 节点计数 sizeset自带节点计数，我们可以之间获取二叉树中节点的个数，或判断set是否为空\n\n1.3 插入删除插入删除等函数在这里不过多解释，使用方法和string、vector完全一致。如果大家的stl是从string一路学习过来，那么对于这些函数的使用肯定没有问题！\n\n插入可以插入单个元素，其返回一个键值对包含这个元素的迭代器+一个bool标识是否插入成功。你还可以用相同类型set的迭代器区间进行插入操作\n\nset&lt;int&gt;t1;//定义 set 对象 t1for (int i = 0; i &lt;= 3; ++i) &#123; // 插入 1 2 3 4 5 6\tt1.insert(i);&#125;\n\n删除可以删除：\n\n指定迭代器位置\n指定元素\n迭代器区间\n\n\n不过对于二叉搜索树而言，删除一直都不是高频操作+效率较低。这也是为什么在实现二叉搜索树的时候，我没有去实现删除操作。\n\n其实主要是删除操作比较难理解，特别是在平衡二叉树中\n\n1.4 查找find作为搜索二叉树，查找才是最重要的一个函数。该函数会返回一个迭代器，指向元素的位置。\n\n如果没有找到这个元素，则返回end迭代器\n\n所以我们只需要在使用这个函数的时候，加上对于end()迭代器的判断，只要不等于end说明找到了该元素，进行访问\nset&lt;int&gt; v1;v1.insert(1);v1.insert(3);v1.insert(6);set&lt;int&gt;::iterator it = v1.find(3);if (it != v1.end())&#123;\tcout &lt;&lt; &quot;找到了 &quot;&lt;&lt; *it &lt;&lt; endl;&#125;\n\n因为set是只有key的搜素二叉树，在获取到迭代器之后，我们直接使用*it进行解引用即可得到节点的值\n\n而当我们查找内部不存在的元素，也可以得知没有找到\n\n\n1.5 count这个函数的作用是查找二叉树中value值的个数。但由于默认的set不支持键值冗余，插入相同的键值会被忽略掉。所以这个count在这里只有0和1两个返回值，也只能用来判断该值是否存在。\n\n但是因为count需要遍历所有元素，所以在set中，它的效率比find是更差的。\nmultiset支持键值冗余这个函数真正起作用的地方是在multiset，人如其名，这是一个支持键值冗余的set，成员函数完全相同。第一个模板变量是set的参数类型，第二个是比较函数，第三个是一个空间配置器\ntemplate &lt; class T,                        // multiset::key_type/value_type           class Compare = less&lt;T&gt;,        // multiset::key_compare/value_compare           class Alloc = allocator&lt;T&gt; &gt;    // multiset::allocator_type           &gt; class multiset;\n\n\n\n1.6 lower&#x2F;upper_bound\niterator lower_bound (const value_type&amp; val);   // 返回指向等于或大于指定键值元素的迭代器iterator upper_bound (const value_type&amp; val);   // 返回指向大于指定键值元素的迭代器\n\n这两个函数的作用是返回一个和我们指定的元素相同&#x2F;或者比指定元素更大（第一个更大的键值）的迭代器\n\n\n如果更大的键值或者它本身不存在，就会返回一个end迭代器，这一点和find一样\n\n\n set基本用得到的迭代器这里都提了一嘴，接下来康康map\n2 mapmap同样有一个支持键值冗余的multimap，后面就不说辣\n\n前面关于构造函数都暂且不提，直接来看map和set最不一样的地方，插入\n2.1 插入map是一个kvl二叉搜索树，其所有元素都是一个键值对。这就要求我们插入的时候，需要先make_pair建立一个键值关系，再插入进map中。\n\n也因为迭代器获取到的是一个键值对，所以访问的时候需要指定键值对的first和second。map是用first进行排序的，所以first是不能修改的，但是second可以\n2.2 下标访问&#x2F;atmap相比于set，最特殊的一点就是它可以用下标直接进行访问\nmap[key]=value;\n\n所以我们可以使用这种方式非常方便的修改value\n\n和重载了下标的vector一样，map也有一个at函数（C++11新增）在之前vector的函数中，我没有提到这两个的区别。在这里说一下\n\noperator[]和at的主要区别在于operator[]不做边界检查，而at会做边界检查。\n\n由于operator[]不做边界检查， 那怕越界了也会返回一个引用，当然这个引用是错误的引用，如何不小心调用了这个引用对象的方法，会直接导致应用退出。\n而由于at会做边界检查，如果越界，会抛出异常，应用可以try/catch这个异常，进行异常管理，而应用还能继续运行。\n\nat的使用和下标不太一样，和成员函数的使用方法一致。我们可以来试一试\n\n\n在这里如果我们下标访问第11个元素，也不会出问题。因为下标访问会自动创建一个对应的key，而value会调用默认构造函数。int类型也是有默认构造的，返回一个0\n\n但如果我们不用下标，直接用at访问第11个元素，就会报debug错误，这便是它们俩的区别所在\n\nmap和set有区别的地方主要就是上面两个函数，其余都是完全相同\n2.3 下标访问自定义类型必须要有默认构造函数如题，如果你想在map里面插入一个自定义类型，使用emplace和insert的时候不会出现问题，但是使用[]重载就会有编译错误。\nclass mytestint&#123;public:    mytestint(uint16_t id, uint16_t pr) : _id(id), _pr(pr) &#123;&#125;    uint16_t get_id() const    &#123;        return _id;    &#125;private:    uint16_t _id;    uint16_t _pr;&#125;;\n\n这里我有一个自定义类型，内部只实现了一个有参构造函数，没有无参构造。\n此时调用下标重载，就会出现问题\nmap&lt;uint16_t, mytestint&gt; _test_map;void test_emplace(uint16_t id, uint16_t pr, const std::string &amp;info)&#123;    mytestint temp = &#123;id, pr&#125;;    auto t = _test_map.emplace(id, temp); // good    auto s = _test_map.insert(&#123;pr, temp&#125;);// good    _test_map[id] = temp; // error    auto h = _test_map[pr]; // error&#125;\n\n编译这个代码，会出现如下报错（如果去掉最后两个下标的访问，只用insert和emplace是不会有报错的）\n/usr/include/c++/11/tuple:1820:9: error: no matching function for call to ‘mytestint::mytestint()’ 1820 |         second(std::forward&lt;_Args2&gt;(std::get&lt;_Indexes2&gt;(__tuple2))...)      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~In file included from test.cpp:1:src/main.hpp:51:5: note: candidate: ‘mytestint::mytestint(uint16_t, uint16_t)’   51 |     mytestint(uint16_t id, uint16_t pr) : _id(id), _pr(pr) &#123;&#125;      |     ^~~~~~~~~src/main.hpp:51:5: note:   candidate expects 2 arguments, 0 providedsrc/main.hpp:47:7: note: candidate: ‘constexpr mytestint::mytestint(const mytestint&amp;)’   47 | class mytestint      |       ^~~~~~~~~src/main.hpp:47:7: note:   candidate expects 1 argument, 0 providedsrc/main.hpp:47:7: note: candidate: ‘constexpr mytestint::mytestint(mytestint&amp;&amp;)’src/main.hpp:47:7: note:   candidate expects 1 argument, 0 providedmake: *** [makefile:2: test] Error 1\n\n如果给mytestint类添加一个默认构造，则不会有编译错误\nmytestint() = default;\n\n3.模拟实现这里主要以KV键值对的map为例，set只需要修改keyofValue和它自己的模板参数即可\n3.1 康康STL源码利用红黑树实现map和set之前，我们需要先来思考一个问题：我们自己写的红黑树只有一个KV键值对，那么要怎么判断封装的是map还是只有key的set呢？\n\n先来看看STL库的源码吧！【链接】\n\n在map.h的第68行可以看到，实际上库函数里面的map和set都只是封装了红黑树\n\n再去找红黑树的头文件，就能看到其与我们实现的不同。这里面的红黑树总共有5个模板参数，除去最后一个用来申请内存空间的alloc，其余4个都有其不同的用处\n\n而其中的value是用来构造红黑树节点的参数\n\n看起来好像差不多对吧？可再回头看看map，其传入的value是一个pair！\n\n实际上，库中的红黑树，并不是一个简单的kvl，其k并不是真正用于比较的k，而是依靠第三个模板参数keyofvalue，以及我们传入的比较函数compore来进行比较的\n\n说人话就是：RBtree不会判断你是map还是set，而是在map和set的封装端，根据数据的不同类型，传入对应的比较函数，以及键值。\n\n比如set的keyofvalue就是它自己的key\n而map的keyofvalue是pair.first\n\n因为库函数里面pair的比较，是会比较first之后，再比较second的。\n\n这和我们搜索二叉树的需求不太符合，所以STL库里面就需要写一个比较大小的仿函数，只针对pair的first进行严格比较，以保证稳定性\n\n3.2 模拟实现的基础框架如果我们自己模拟实现，则可以依据下面的模板进行操作\n// 模板参数V决定红黑树存什么数据// set: RBTree&lt;K, K&gt;// map: RBTree&lt;K, pair&lt;K, V&gt;&gt;// KeyOfV: 取出V对象中key的仿函数template&lt;class K, class V, class KeyOfV&gt;\n\n而节点类也需要进行对应的修改，不再默认创建一个键值对。而是直接用V来创建一个基本的类型，这就和最基础的搜索二叉树相同。\ntemplate&lt;class V&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;V&gt;* _left;\tRBTreeNode&lt;V&gt;* _right;\tRBTreeNode&lt;V&gt;* _parent;\tV _data;\t//AVL树的平衡因子，在红黑树中为颜色\tColor _col;\t//插入节点的时候，默认为红色\t//因为这个满足性质3且不会破坏性质4\tRBTreeNode(const V&amp; data)\t\t:_data(data),\t\t_left(nullptr),\t\t_right(nullptr),\t\t_parent(nullptr),\t\t_col(RED)\t&#123;&#125;&#125;;\n\n3.3 修改插入的代码因为新增了模板参数，所以这里我们也不能通过kv first进行键值的比较了。我们需要里利用模板参数中的KeyOfV仿函数来进行比较的操作。\n在这里，先给出map和set两种KeyOfV仿函数的实现\nstruct MapKeyOfV&#123;    const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)    &#123;        return kv.first;//map是键值对，需要提供kv的first进行比较    &#125;&#125;;struct SetKeyOfV&#123;    const K&amp; operator()(const K&amp; key)    &#123;        return key;//set只有一个键值    &#125;&#125;;\n\n有了这个仿函数，我们只需要实例化一个对象，然后将原有的比较替换成仿函数在进行比较即可！\npair&lt;iterator,bool&gt; Insert(const V&amp; data)&#123;    //判断root为空，即空树    if (_root == nullptr)    &#123;        _root = new Node(data);        _root-&gt;_col = BLACK;//这里必须要手动给黑色        return make_pair(iterator(_root),true);    &#125;    //kv树的操作    Node* parent = nullptr;    Node* cur = _root;    while (cur)    &#123;        //利用key来判断，寻找待插入的位置        if (kov(cur-&gt;_data)&lt; kov(data))        &#123;            parent = cur;            cur = cur-&gt;_right;        &#125;        else if (kov(cur-&gt;_data) &gt; kov(data))        &#123;            parent = cur;            cur = cur-&gt;_left;        &#125;        else &#123;            return make_pair(iterator(cur), false);//构造一个迭代器返回        &#125;    &#125;    //找到位置后插入节点    cur = new Node(data);    Node* newnode = cur;    if (kov(parent-&gt;_data) &lt; kov(data))    &#123;        parent-&gt;_right = cur;    &#125;    else    &#123;        parent-&gt;_left = cur;    &#125;    cur-&gt;_parent = parent;    //插入之后需要向上更新颜色,只有出现连续红色之后才需要更新    while (parent &amp;&amp; parent-&gt;_col==RED)    &#123;        Node* grandpa = parent-&gt;_parent;//祖父        assert(grandpa);//祖父为空不需要进行操作        //p是g的左        if (parent == grandpa-&gt;_left)        &#123;            Node* uncle = grandpa-&gt;_right;            //情况1：插入后p是红，u存在且是红（不需要旋转）            if (uncle &amp;&amp; uncle-&gt;_col == RED)            &#123;                uncle-&gt;_col = BLACK;                parent-&gt;_col = BLACK;                grandpa-&gt;_col = RED;//祖父变成红                //继续向上调整                //cur = cur-&gt;_parent;                //parent = parent-&gt;_parent;                cur = grandpa;                parent = cur-&gt;_parent;            &#125;            else//(uncle &amp;&amp; uncle-&gt;_col == BLACK)            &#123;                //情况2：插入后p为红，u存在且为黑（需要单旋）                if (cur == parent-&gt;_left)                &#123;                    RotateR(grandpa);//因为p在g的左边，所以右旋                    parent-&gt;_col = BLACK;                    grandpa-&gt;_col = RED;                &#125;                else//cur == parent-&gt;_right                &#123;                    //情况3：不是在同一侧，双旋                    //   g                    // p                    //   c                    RotateL(parent);                    RotateR(grandpa);                    grandpa-&gt;_col = RED;//祖父改成红色                    cur-&gt;_col = BLACK;//自己成为了这里的根，需要改成黑的                &#125;                break;            &#125;        &#125;        else &#123;            Node* uncle = grandpa-&gt;_left;            //情况1：插入后p是红，u存在且是红（不需要旋转）            if (uncle &amp;&amp; uncle-&gt;_col == RED)            &#123;                uncle-&gt;_col = BLACK;                parent-&gt;_col = BLACK;                grandpa-&gt;_col = RED;//祖父变成红                //继续向上调整                cur = grandpa;                parent = cur-&gt;_parent;            &#125;            else//(uncle &amp;&amp; uncle-&gt;_col == BLACK)            &#123;                //情况2：插入后p为红，u存在且为黑（需要单旋）                if (cur == parent-&gt;_right)                &#123;                    RotateL(grandpa);//因为p在g的左边，所以右旋                    parent-&gt;_col = BLACK;                    grandpa-&gt;_col = RED;                &#125;                else//cur == parent-&gt;_left                &#123;                    //情况3：不是在同一侧，双旋                    //   g                    //\t\tp                    //   c                    RotateR(parent);                    RotateL(grandpa);                    grandpa-&gt;_col = RED;//祖父改成红色                    cur-&gt;_col = BLACK;//自己成为了这里的根，需要改成黑的                &#125;                break;            &#125;        &#125;    &#125;    //不管是什么情况，最后都把根改成黑，符合条件2    _root-&gt;_col = BLACK;    return make_pair(iterator(newnode), true);&#125;\n\n这里说明一下为何要把返回值替换成键值对。因为在实际操作的时候，我们需要获取道新插入元素的迭代器（迭代器的模拟实现会在后面提及），以方便在插入后进行修改value的操作。\n\n比如我们默认插入的是一个空字符串，在进行一些判断之后，再重新给这个键值的value进行修改（仅限于map的情况）\n\n如果不返回一个迭代器，那么想修改这个键值，就只能通过find函数查找后再进行修改，相对有些麻烦。\n3.4 迭代器✨这一部分是比较难理解的迭代器操作，主要就是在一个二叉树中应该如何进行迭代器的++/--操作。\n3.4.1 加减操作如果你看过我之前的stl博客，那么你应该还记得，我们的模拟实现迭代器其实就是用指针来进行的。迭代器的使用方法也和指针相差无几。\n在此处我们选择使用中序遍历来进行迭代器的操作。中序遍历的基本情况就是左根右，只不过我们这里不再能使用递归进行操作了，而需要使用迭代的方法。\n\n上图中cur遍历到了右子树，其左右子树都为空。这时候我们需要返回到的是根节点，准确来说是祖父节点——吗？要是cur的父亲prev不是g节点的左子树，我们就不能直接返回g进行打印！而需要返回g的左子树。\n总结出来的规律如下，当我们执行++操作的时候：\n\n如果右节点为空，当前节点是父亲的右侧，就需要继续往上找（我们需要找到父亲左侧的那个节点）\n如果右子树不为空，找右子树的最左节点。\n\n在上图中，prev就是g的左子树，所以我们只需要找到prev就行了。然后因为我们的prev的右子树已经遍历过，所以这时候就需要往上。因为g是根节点，所以就需要返回g的右子树的最左节点，也就是下图中的位置\n\n而当我们做到最右侧的节点时，再次++的时候其实已经遍历完了。这时候右子树为空，开始往上找父亲是祖父左的哪一个。这时候会一直找到根，而根的父亲为空，停止遍历\n\n转换为代码如下\nSelf&amp; operator++()&#123;\tif (_node-&gt;_right == nullptr)\t&#123;\t\tNode* cur = _node;\t\tNode* parent = cur-&gt;_parent;\t\t//只要当前节点是父亲的右侧，就需要继续往上找\t\t//我们需要找到是父亲左侧的那个节点。\t\twhile (parent &amp;&amp; parent-&gt;_right == cur)\t\t&#123;\t\t\tcur = cur-&gt;_parent;\t\t\tparent = parent-&gt;_parent;\t\t&#125;\t\t//如果不符合while的条件，就说明\t\t//1 父亲为空（根)\t\t//2 如果cur是父亲的左，那就直接将node设置为父亲\t\t_node = parent;\t&#125;\telse\t&#123;\t\t//右子树不为空，找右子树的最左节点\t\tNode* subLeft = _node-&gt;_right;\t\twhile (subLeft-&gt;_left)\t\t&#123;\t\t\tsubLeft = subLeft-&gt;_left;\t\t&#125;\t\t//最左节点\t\t_node = subLeft;\t&#125;\treturn *this;&#125;\n\n\n进行--操作的时候则是完全相反的情况。我们需要找到父亲是祖父节点右边的那一个。如果父亲是祖父的左，那就继续往上找。\n\nSelf&amp; operator--()&#123;    if (_node-&gt;_left == nullptr)    &#123;        Node* cur = _node;        Node* parent = cur-&gt;_parent;        //依据中序的顺序，--就是和++反过来。需要找节点是父亲的右边的哪一个        //如果是父亲的左就继续往上找        while (parent &amp;&amp; cur == parent-&gt;_left)        &#123;            cur = cur-&gt;_parent;            parent = parent-&gt;_parent;        &#125;        //指向当前的父亲        _node = parent;    &#125;    else    &#123;        // 左子树的最右节点        Node* subRight = _node-&gt;_left;        while (subRight-&gt;_right)        &#123;            subRight = subRight-&gt;_right;        &#125;        _node = subRight;    &#125;    return *this;&#125;\n\n3.4.2 套上完整迭代器模板完成了迭代器的加减操作后，我们只需要套上之前模拟实现的类似模板，再添加参数到红黑树的类中。即可配套好一个迭代器！\ntemplate&lt;class V, class Ref, class Ptr&gt;struct __RBTreeIterator&#123;\ttypedef RBTreeNode&lt;V&gt; Node;\ttypedef __RBTreeIterator&lt;V, Ref, Ptr&gt; Self;\tNode* _node;//当前指向的节点\t__RBTreeIterator(Node* node)\t\t:_node(node)\t&#123;&#125;\tRef operator*()\t&#123;\t\treturn _node-&gt;_data;\t&#125;\tPtr operator-&gt;()\t&#123;\t\treturn &amp;_node-&gt;_data;\t&#125;\t//省略++和--的代码\tbool operator!=(const Self&amp; s) const\t&#123;\t\treturn _node != s._node;\t&#125;\tbool operator==(const Self&amp; s) const\t&#123;\t\treturn _node == s-&gt;_node;\t&#125;&#125;;\n\n\n完整代码请参考我的Gitee仓库\n\n3.4.3 添加参数到红黑树类中我们需要把迭代器写入红黑树的类，并附上普通迭代器和const的两个版本，提供begin和end函数即可。\n//迭代器封装，const和普通版本typedef __RBTreeIterator&lt;V, V&amp;, V*&gt; iterator;typedef __RBTreeIterator&lt;V, const V&amp;, const V*&gt; const_iterator;iterator Begin()&#123;\tNode* subLeft = _root;\twhile (subLeft &amp;&amp; subLeft-&gt;_left)\t&#123;\t\tsubLeft = subLeft-&gt;_left;\t&#125;\treturn iterator(subLeft);&#125;iterator End()&#123;\treturn iterator(nullptr);&#125;const_iterator Begin() const&#123;\tNode* subLeft = _root;\twhile (subLeft &amp;&amp; subLeft-&gt;_left)\t&#123;\t\tsubLeft = subLeft-&gt;_left;\t&#125;\treturn const_iterator(subLeft);&#125;const_iterator End() const&#123;\treturn const_iterator(nullptr);&#125;\n\n\n可以看到，迭代器已经可以正常使用了！\n\n这里的测试环节最好把自己写的map套进一个命名空间中，不然就会用到stl库里面的map\n\n迭代器写好之后，范围for也是可以用的\n\n3.5 重载下标map非常特殊的一点就是，可以直接用map[key]=value来修改value的内容。我们模拟实现的时候当然不能落下这个了！\n其实操作起来非常简单。我们只需要直接调用插入，如果键值存在也会返回当前键值的迭代器。键值不存在就能直接插入，返回新插入元素的迭代器。这也是之前为啥insert函数没有直接用bool做插入的返回值的原因\n//重载下标V&amp; operator[](const K&amp; key)&#123;    pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));    return ret.first-&gt;second;//返回的是一个引用，所以可以直接修改&#125;\n\n因为我们返回的是V的引用，所以可以直接用=进行修改！\n测试一下，咩有问题 OJBK👍\n\nset的模拟实现更为简单，这里就不贴出来辣！大家可以去我的gitee看源码，有啥问题可以评论提出！\n\n4.更多操作4.1 用set得出两组数据的重合处假设有两个文件，我们现需要找到这两个文件的重合处\n\n设置两个set，分别插入两个文件的内容\n同时遍历两个set（从小到大）\n如果两个set的key相同，则取出这个相同值，两个set一起++\n如果不相同，则++那个小的key\n\n\n其中一个set结束遍历，即代表重合处查找完毕！\n\n结语最近感觉自己真的很忙，但又不知在忙什么。事情一个接着一个，虽然学校的课不算多，但事情真的没少多少。\n有些事情自己又有拖延症，再加上作息不规律（指下午一睡睡3h），浪费了好多时间……\n\n","categories":["遇见C++"],"tags":["C++","数据结构","树"]},{"title":"【C++】异常处理","url":"/posts/569709037/","content":"本篇博客让我们来认识一下C++中对于异常的处理机制\n\n\n[TOC]\n1.概念1.1 C语言对于异常的处理在之前我们遇到一些bug的时候，通常会用if判断或者assert断言等问题进行处理。但这种方式太过暴力，会直接中断程序的运行\n另外一种办法是返回错误码，C语言的报错大多使用这种方式。不过这需要程序的用户自己去查对应的错误码表格，较为麻烦\n\n1.2 C++异常所谓异常，便是程序运行过程中可能遇到的bug或者问题。程序可以有选择地抛出一个异常，告知用户程序运行出现了问题。\nC++标准库中便使用了一个exception类来进行异常的处理，我们运行程序中遇到的一些报错，其实就是标准库里面抛出了对应的异常\n\n其操作主要借助下面三个关键字\n\nthrow 在出现问题的地方抛出异常\ntry 监控后续代码中出现的异常，后续需要以catch作为结尾\ncatch 用于捕获异常，同一个try可以用多个不同类型的catch进行捕获\n\nthrow关键字可以抛出任意类型的异常\n2.基本操作下面用除法函数，以除0的情况来做一个最简单的演式\nint Div()&#123;\tint a, b;\tcin &gt;&gt; a &gt;&gt; b;\tif (b == 0)\t\tthrow &quot;div 0 err!&quot;;\treturn a / b;&#125;int main()&#123;\ttry &#123;\t\tcout &lt;&lt; Div() &lt;&lt; endl;\t&#125;\tcatch(const char* s)&#123;\t\tcout &lt;&lt; s &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n\n2.1 需要注意的点这里有几个需要注意的点：\ncatch类型对应当我们进行抛异常的时候，一定需要有对应类型的catch，否则会报错\n比如我们throw的是一个常量字符串，如果用string来catch，就会因为类型不匹配而出现报错\n\n所以当我们使用某一个会抛异常的函数的时候，一定要注意其抛出异常的类型\n\n利用…进行全捕获假设我们不知道这里面会抛出什么类型的错误呢？总不能把所有类型都catch一下吧？\n当然不需要，我们可以使用下面的函数进行全捕获\n\n这就可以用于当我们不知道报错类型的时候。不过一般的使用场景是，在这之前先catch已知的错误类型，最后再加上一个全捕或，作为未知错误的标识\n不过catch(...)有一个缺点，那便是我们不能知道异常的类型\n\n基类捕获派生类的异常当我们出现异常的时候，如果throw了一个子类对象，可以用基类的引用来接收！\nclass A &#123;\tint a;&#125;;class B : public A &#123;\tint b;public:\tB()\t\t:b(1)\t&#123;&#125;&#125;;void testab()&#123;\tB bt;\tthrow bt;&#125;int main()&#123;\ttry &#123;\t\ttestab();\t&#125;\tcatch (A&amp; e) &#123;\t\tcout &lt;&lt; &quot;err class A&quot; &lt;&lt; endl;\t&#125;\tcatch (...) &#123;\t\tcout &lt;&lt; &quot;err&quot; &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n\n这个在进行继承多态的错误编写的时候就很有用啦\n2.2 异常和栈帧抛出异常后，会被离这个异常最近的catch捕获，如果没有任何catch则会报错\n\n比如我们单独写一个函数，而这个函数体内有try/catch的话，那么会直接和这个最近的匹配，并不会和main函数里面的匹配\n\n而如果该函数里面没有进行此操作，则会直接到main的对应catch处\n\n注意！这里是直接跳转到对应catch语句，并不会出现先跳到testCatch函数在跳回main的情况！\n2.3 重新抛出异常假设我们遇到了这种情况\nvoid testab()&#123;\tB bt;\tthrow bt;&#125;void testD()&#123;\tint* arr = new int[10];\ttestab();\tdelete[] arr;&#125;\n\n在testab()函数中抛出了异常，导致testD()函数提前终止！\n\n可我们new的东西还没释放呢！\n这就出现了内存泄漏！\n\n注意：内存泄漏是一个不能被忽略的问题，即便我们每一次new的空间很小，但是积小成多就是大问题！\n\n这时候我们就需要提前进行异常处理，如果出现问题，先释放我们new的资源之后，再将异常重新抛出。可以理解为是提前拦截异常\n\n3.异常需要注意的一些问题3.1 异常安全当我们操作异常的时候，需要注意一些相关的问题\n\n上面2.3中提到的内存泄露问题，在new和delete之间抛出异常而没有中途处理，导致内存泄漏\n不要在构造或析构函数中抛出异常，否则可能导致对象不完全初始化（对象不完整）或不完全析构（内存泄漏）\n多线程操作中在lock与unlock之间抛出异常，导致死锁\n\n当然是有解决方案的，C++使用RAII来解决上述问题，这个待我下一篇智能指针的博客来讲解！\n3.2 异常规范因为异常都是手动写代码进行处理的，那么就极其需要些代码的老哥拥有很好的编程规范。\n\n在函数后加上throw(类型A，类型B)可以列出这个函数能抛出的所有异常类型\n\nvoid test() throw(string,vector&lt;int&gt;);\n\n\n如果只跟一个类型，代表该函数只会抛出一种类型的异常\n\nvoid* operator new(size_t size) throw (std::bad_alloc);\n\n\n如果跟的是throw()代表这个函数不会抛出异常\n\nvoid* test2(size_t sz, void* p) throw();\n\n在C++11中还新增了一个关键字noexcept来标识不会抛出异常\nvoid* test2(size_t sz, void* p) noexcept;\n\n但是这些都依赖于用户的编程习惯，C++并没有强制用户一定要在函数尾部写上异常抛出的类型。\n那在项目合作中，来了一个“实习生”\n\n写了一个会抛出异常的函数，却没有标识该函数会抛异常，那下面调用该函数的地方没有进行异常处理，那不就蛋糕了，程序提前中止！\n或者说是抛出异常的类型写错了，没有对应的异常处理语句，只能被catch(...)捕获\n或者是明明不抛出异常非要写自己抛出，白写了异常处理\n\n以上三种情况都是我们不期望遇到的，所以在写相关函数的时候，最好明确标识相关异常抛出的类型！\n3.3 自定义异常类型要是在协作中，不同用户抛出了太多不同类型的异常，那还怎么调用函数？\n前面提到了，子类抛出的异常可以用基类接受。所以在项目中一般都是会定义一个继承的规范异常体系，用于处理不同的异常。\n这样我们就只需要捕获一个基类对象，就能捕获到所有派生类的异常对象。\n关于基类捕获子类异常的方法在2.1中已经提及，这里不再演示\n\n3.4 C++标准库中的异常在C++标准库中，异常是围绕下图组织的\n\ncplusplus：https://legacy.cplusplus.com/reference/exception/exception/?kw=exception\n\n\n标准异常类的成员：\n\n在上述继承体系中，每个类都有提供了构造函数、复制构造函数、和赋值操作符重载。\nlogic_error类及其子类、runtime_error类及其子类，它们的构造函数是接受一个string类型的形参，用于异常信息的描述\n所有的异常类都有一个what()方法，返回const char* 类型描述异常信息\n\n标准异常类的具体描述：\n\n\n\n异常名称\n描述\n\n\n\nexception\n所有标准异常类的父类\n\n\nbad_alloc\n当operator new and operator new[]，请求分配内存失败时\n\n\nbad_exception\n这是个特殊的异常。如果函数的异常抛出列表里声明了bad_exception异常，而函数内部抛出了异常抛出列表中没有的异常，不论什么类型，都会被替换为bad_exception类型\n\n\nbad_typeid\n使用typeid操作符，操作一个NULL指针，而该指针是带有虚函数的类，这时抛出bad_typeid异常\n\n\nbad_cast\n使用dynamic_cast转换引用失败的时候\n\n\nios_base::failure\nio操作过程出现错误\n\n\nlogic_error\n逻辑错误，可以在运行前检测的错误\n\n\nruntime_error\n运行时错误，仅在运行时才可以检测的错误\n\n\nlogic_error的子类：\n\n\n\n异常名称\n描述\n\n\n\nlength_error\n试图生成一个超出该类型最大长度的对象时，例如很长的string\n\n\ndomain_error\n参数的值域错误，主要用在数学函数中。例如使用一个负值调用只能操作非负数的函数\n\n\nout_of_range\n超出有效范围，vetor的at抛出了此异常\n\n\ninvalid_argument\n参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常\n\n\nfuture_error(C++11)\nThis class defines the type of objects thrown as exceptions to report invalid operations on future objects or other elements of the library that may access a future‘s shared state.\n\n\nruntime_error的子类：\n\n\n\n异常名称\n描述\n\n\n\nrange_error\n计算结果超出了有意义的值域范围\n\n\noverflow_error\n算术计算上溢\n\n\nunderflow_error\n算术计算下溢\n\n\nsystem_error(C++11)\n运行时从操作系统或其他具有关联error_code的低级应用程序接口引发的异常\n\n\n以上部分C++标准库异常解释来自https://blog.csdn.net/linxi8693/article/details/90318166\n\n4.异常优缺点优点\n\n异常对象定义完备之后，相比于错误码的方式，能让用户更加清楚的了解到自己遇到了什么类型的问题，更好定位程序的bug\n函数错误码若遇到，需要层层向外返回；而异常则通过catch可以直接跳到对应处理位置\n第三方库包含异常，我们在使用类似于boost/gtest等第三方库的时候也需要使用对应的异常处理\n对于T&amp; operator[]这种操作符重载，我们没办法很好地使用返回值来标识错误（因为不同类型的返回值不一样，没办法统一处理）这时候就可以用异常来抛出越界问题\n\n缺点\n\n异常可能会导致程序到处乱跳（因为会跳到最近的catch位置）给观察错误情况增添了一些难度\n异常有一定性能开销（可忽略）\n异常容易导致资源泄漏等等问题\n异常依赖于用户编程规范，否则函数调用容易出现异常没有得到处理的问题\n\n\n结语总体而言，异常处理利大于弊。很多语言都是用异常来处理错误的，比如python。只要维持一个良好的编程习惯，在函数后声明会抛出的异常类型，针对性进行处理，还是很香的！\n\n","categories":["遇见C++"],"tags":["C++","C++11","异常"]},{"title":"【C++】函数重载的形式及其背后原理","url":"/posts/909882653/","content":"常言道：中国有俩球，谁都赢不了！这句话在不同的语境下有不同的意思\nC++中，函数支持在同一作用域下声明几个功能类似的同名函数，但需要遵守以下规定……\n\n\n\n形参个数不同\n形参类型不同\n形参类型的顺序不同\n只修改函数返回值不构成重载\n\n编译器会在调用这些同名函数的时候，根据具体情况来选择不同的函数\n\n[TOC]\n1.函数重载的样式\n上面提到了函数重载的3个规定，下面让我们来用具体示例认识一下它们\n\n假设我们需要一个A+B的代码，如果每次都需要根据不同数据类型来写不同的函数去实现这个功能，未免有点太过繁杂。\n在C++中，只需要修改函数的参数，即构成了函数重载，编译器就会自己选择对应的函数进行相加操作\n1.1形参类型不同//函数重载int Add(int a, int rb)&#123;\treturn a + b;&#125;long Add(long a, long b)&#123;\treturn a + b;&#125;double Add(double a, double b)&#123;\treturn a + b;&#125;int main()&#123;\tcout &lt;&lt; Add(10, 20) &lt;&lt;endl;     cout &lt;&lt; Add(10L, 20L) &lt;&lt; endl;\tcout &lt;&lt; Add(10.0, 20.0) &lt;&lt; endl;\treturn 0;&#125;\n\n\n1.2形参个数不同int Add(int a, int b) &#123;\treturn a + b;&#125;//个数不同int Add(int a, int b, int c) &#123;\treturn a + b + c;&#125;\n\n\n1.3形参类型顺序不同这里的顺序并不是a和b的顺序哈！只把a和b换一个位置是不构成函数重载的\n这里指的是先传int再传double，和先传double再传int的两种函数\n//形参类型的顺序不同void Add(int  a, double b) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;&#125;void Add(double  a,int b) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;&#125;\n\n\n\n1.4返回值不同非重载只修改函数的返回值类型是不构成函数重载的\n\n\n2.C++实现函数重载的原理\n在看后续内容之前，建议先复习一下程序运行的4个阶段，以便理解后面的操作👉传送门\n\n这里使用我的树莓派在Linux系统下给大家演示一下函数重载背后的样式\n首先我创建了3个文件，test.c Add.h Add.cpp，文件的内容一并给出\n//Add.h#include&lt;iostream&gt;using namespace std;int Add(int a,int b);double Add(double a,double b);//Add.c#include &quot;Add.h&quot;int Add(int a,int b)&#123;\treturn a+b;&#125;double Add(double a,double b)&#123;\treturn a+b;&#125;//test.cpp#include &quot;Add.h&quot;int main()&#123;\tcout&lt;&lt;Add(1,2)&lt;&lt;endl;\tcout&lt;&lt;Add(1.5,2.5)&lt;&lt;endl;\treturn 0;&#125;\n\n可以看到，这里我们使用gcc这个C语言编译器编译程序的时候，出现了很多报错，因为C语言是不支持函数重载的\n\n2.1编译生成可执行文件需要使用g++编译器来编译这个代码\ng++ test.cpp add.cpp -o Tcpp\n\n执行./Tcpp运行该函数，可以看到正常输出了相加后的结果\n\n\n2.2查看汇编接下来我们要使用另外一个命令来查看可执行文件Tcpp的汇编代码\nobjdump -S Tcpp\n\n在这里面可以找到我们两个Add函数的位置，可见它们的地址是不同的，并且一个函数名为_Z3Addii，另外一个是_Z3Adddd\n\n2.2.1汇编函数名的含义这两个汇编代码中的函数名，其实包含了函数名、函数参数这两个信息\n\n拆分了其中一个，那么另外一个_Z3Adddd的意思就很明确了，末尾的两个d代表函数参数是(double,double)\n\n我们可以创建另外一个文件，查看它的汇编代码，进一步确认命名规则（其实这个命名规则是反推得出的）\n#include&lt;iostream&gt;using namespace std;void f(int a,int b)&#123;\tcout &lt;&lt;a&lt;&lt;endl;\tcout &lt;&lt;b&lt;&lt;endl;&#125;int main()&#123;\tf(3,4);\treturn 0;&#125;\n\n编译程序后，执行objdump -S，可以看到f函数被命名为_Z1fii，代表函数名长度为1，原本函数名f，和函数参数(int ,int)\n\n现在我们知道了汇编中这个函数名的命名规则，那它和C++支持函数重载有什么关系呢？\n\n在这之前，我们还需看看c语言程序，汇编代码中函数又是怎么命名的\n2.2.2查看C语言汇编这里我把之前的函数修改成了C语言的样式，gcc编译后再来看看它的汇编\nvoid f(int a,int b)&#123;\tprintf(&quot;%d %d\\n&quot;,a,b);&#125;\n\n\n然后你就会发现，C语言汇编代码中的函数名，就是函数原本的名字f，没有添加任何东西！\n\n2.3得出结论看到这里，你能猜出来为什么C++支持函数汇编，而C语言不支持了吗？\n\n没错！那是因为C++的汇编代码中，函数名还保存了函数的形参类型，而C语言中并没有保存，自然无法区分两个函数\n\n这个汇编函数名的命名方式也能解释C++函数重载的3种样式\n假设我们有一个fun函数，那么我们可以推断出它的汇编函数名\n\n\n\n类型\n形式一\n形式二\n\n\n\n形参个数不同\n_Z3funii(int,int)\n_Z3funiii(int,int,int)\n\n\n形参类型不同\n_Z3funii(int,int)\n_Z3fundd(double,double)\n\n\n形参类型顺序不同\n_Z3funid(int,double)\n_Z3fundi(double,int)\n\n\n同时也能解释为何只修改函数返回值类型是不构成重载的，因为汇编代码中没有保存函数的返回值\n\n正因为C++在汇编处理中能够以这种命名方式来区分同名的不同函数，并给它们赋予不同的地址，编译器在链接符号表的时候，才能通过函数传参的不同找到它需要调用的对应函数的地址\n\n在main函数的汇编中，也能找到对应函数的调用操作\n\n\n3.语法extern”C”因为C++汇编处理中对函数名的修饰和C语言不同，所以C++中有这么一个语法，专门用来告诉编译器，某某某函数要用C语言的规则来修饰\n #include &lt;iostream&gt;using namespace std;extern &quot;C&quot; int fun(int a,int b);int main()&#123;    int sum=fun(1,2);    return 0;&#125;int fun(int a,int b)&#123;     return a+b;&#125;\n\n可以看到，使用这种方式修饰的fun函数，在汇编中就只有函数名，而不是C++形式原本的_Z3funii\n\n这样C语言的代码就可以链接这种方式写的C++静态库（前提是这个静态库中没有函数重载和C++的语法）\n\n然后我就想问：这和C的静态库有啥区别……\n\n当然有了！一个库里面有很多很多代码，总有些函数接口是C语言也能支持的嘛，这些接口就用C语言的方式来修饰，这样C语言也能调用了，不一举两得？\n3.1C++调用C语言静态库除了更改修饰方式外，extern&quot;C&quot;还用于让C++程序来调用C语言写的库\n\n比如树莓派要用到的wiringPi库，它是用C语言实现的，在编程为静态库后，里面汇编对函数的修饰就固定了，并没有C++下的_Z1...和参数类型修饰。\n\n这时候如果用C++直接来调用这个函数，C++程序是找不到对应的函数的。在这种情况下，extern&quot;C&quot;的作用就是让编译器以C语言的方式去寻找对应函数\n比如下图的代码，调用了wiringPi库里面的初始化函数，是最常用的一个函数\n\n我们用G++编译器编译这个代码，就会发现，欸tnnd怎么没有报错啊？\n\n\n其实吧，库函数的开发者早就想到了这一点。在平日编程中，也有办法来解决这个问题——那就是用条件编译指令！\n3.2用条件编译解决问题前情提要：在C++的编译环境中有一个预定义符号__cplusplus\ncout&lt;&lt; __cplusplus &lt;&lt;endl;\n\n在linux环境下，编译器打印出了以下数字\n\n而在windows的VS2019编译器下打印了下面的数字\n\n咱先不管这个数字是啥意思（看起来是一个日期），至少在C语言中是没有这个预定义符号的\n\n这样我们就可以利用这个预定义符号，假设是C++环境，就放出extern&quot;C&quot;来声明函数，如果是C语言环境，就不用extern&quot;C&quot;\n方法一：批量extern\n#ifdef __cplusplusextern &quot;C&quot; &#123;#endif    void Add(int a,int b);    int fun(int a,int b);    //这里可以放多个函数的声明    //……    #ifdef __cplusplus&#125;#endif\n\n方法二：define一个符号为extern&quot;C&quot;，然后在每一个定义前面单独加\n#ifdef __cplusplus\t#define EXTERN extern &quot;C&quot; #else\t#define EXTERN#endifEXTERN void Add(int a,int b);EXTERN int fun(int a,int b);EXTERN int func(int a,int b);//……\n\n这样不管是C语言，还是C++的程序，都能正常建立符号表，找到对应的函数\n\nGithub：wiringPi库源码仓库\n\n可以看到，大佬当初编写wiringPi库的时候就用了这个方法，这也是为什么在我的树莓派上，G++编译器也能直接识别出wiringPi库的原因\n\n\n在找这部分资料的时候，还发现了一个小故事：wiringPi库现在已经不官方开源了。因为有很多初学者拿代码去烦原作者（于是作者在官网上写了“这不是给初学者玩的”告示）还有很多人倒卖他写的库，所以他就在最后一次公开后，停止了官方开源\n\n3.3C语言调用C++的库同理，有的时候我们也会用C语言来调用C++的库\n但是！就如我上头说的，这个库里面，可以供C语言调用的函数不能有C++的语法和函数重载\n\nGithub：TcMalloc代码仓库\n\n比较好的一个例子是谷歌的tcmalloc库：此存储库包含TCMalloc的C++代码。 TCMalloc是谷歌对C的malloc（）和C++运算符的定制实现，用于在我们的C和C++代码中分配内存。TCMalloc是一个快速的多线程malloc实现。\n\n整个库的函数入口是在tcmalloc.cc中定义的，打开它可以看到，虽然大部分代码都是用C++实现的，但是少部分函数接口因为没有C++的语法，所以使用了extern &quot;C&quot;让C语言也支持它\n\n但是我还发现，有些带有C++的函数接口，也用了extern &quot;C&quot;，那是不是我们上面的结论错了呢？\n\n实践出真知！\n4自己整一个静态库4.1C++调用C语言静态库首先创建一个VS的空项目，把我之前写的C语言单链表代码放进去\n\n右键这里的项目名称-属性，然后在配置属性-常规-配置类型中，把项目改成静态库\n\n修改完毕后，编译程序，你会发现debug目录下多了静态库文件.lib\n\n然后在我们当前的C++项目中，修改项目属性-链接器-常规-附加库目录和项目属性-链接器-输入-附加依赖项\n\n\n最后以#include &quot;../Slist/Slinklist.h&quot;的形式引用静态库\n你会发现直接引用是会报错的，因为这个单链表的库是用C语言写的，我们没有使用extern &quot;C&quot;来引用\n\n使用了之后，程序正常调用了C语言的库，并打印出了结果！\n\n4.2C语言调用C++静态库接着，我们再写一个简单的C++程序，用上面同样的方法编译成静态库，并在C语言的项目中调用它\n\n可以看到，这个没有任何C++语法的C++静态库被正常调用并打印出了结果\n\n如果我们不使用extern &quot;C&quot;，C语言项目就无法正常使用该静态库\n\n而当我们在C++的静态库中包含C++的头文件后，C语言项目中也报错了！\n#include &lt;iostream&gt;using namespace std;\n\n光是链接库函数头文件和命名空间就报错了，那不能使用带C++语法的函数也是板上钉钉的事情了！\n\n而在具有extern &quot;C&quot;属性的路径中，也不能包含函数重载，VS会报错\n\n在头文件中定义自己的命名空间，在C语言项目中也是无法通过编译的\nnamespace muxue &#123;\tint a = 0;&#125;using namespace muxue;\n\n\n现在可以确认我们的结论，只有不包含任何C++的语法和函数重载的C++静态库，才能正常被C语言项目调用！\n勘误，上述结论错误\n22-05-06，在同学的提示下，发现了这个错误\n\n之前C调用C++的方式有问题，因为我是直接把C++的语法放到了头文件中，在展开的时候C程序编译会报错\n但如果把C++的语法放入cpp文件，头文件中不包含的话，就不会报错了！\n\n可以看到在最后的测试项目中，C语言程序成功调用了c++的语法并正确输出了内容\n\n这也能解释我关于谷歌TCmalloc库的疑惑了，看来C和C++真的是互通有无啊！\n\n结语本篇笔记详细解释了C++中函数重载的类型，以及背后的实现原理。\n这个博客花了我整整4小时的时间，感觉很充实！\n\n所以求个赞不过分吧！谢谢大家！\n\n\n","categories":["遇见C++"],"tags":["Linux","C++"]},{"title":"【C++】C++11的那些新特性","url":"/posts/2016080368/","content":"本篇博客，让我们一起来看看C++11的那些新特性！\n\n\n\n所使用的编译器：VS2019\n本篇博客所有的测试源码都可以在我的GITEE仓库找到 \n\n[TOC]\n1.前言C++11是C++的标准委员会在2011年更新的C++新特性。说白了就是一个升级包。和JAVA\\PYTHON这种更新比较频繁的语言相比，C++更新的就没有那么顺风顺水了，而且每一次更新虽然修复了一些问题，但也带来了更多的“没太大必要”的更新\n\n比如没啥用的array容器，和int arr[10]这种内置方式的区别主要在于越界检查\n\n不过咱们这种小菜鸡，只有学习的权力，哪有啥资格评定C++标准呢？我听大佬说，现在最关注的C++更新便是网络库的上线了，不过那个貌似得等到C++23去了\n话不多说，让我们来康康一些C++11的新功能吧！\n\n2.列表&#123;&#125;初始化C++11更新了初始化方式，不管是什么类型的数据，我们都可以用花括号的方式进行初始化\nstruct TestA&#123;\tint _a;\tint _b;&#125;;void TestInit()&#123;\tint arr1[] = &#123; 1,2,3,4,5 &#125;;\tTestA t1 = &#123; 1,2 &#125;;&#125;\n\n之前我们已经习惯于用这张方式来初始化数组或者结构体，这在C++98中已经支持\n而C++11则在这种玩法之上，又增添了一部分新操作，那就是直接用花括号初始化，你甚至可以把=给省略了\nint arr2[]&#123; 1,2,3,4,5 &#125;;int arr3[5]&#123; 0 &#125;;TestA t2&#123; 1,2 &#125;;\n\n不过上面这种写法没有什么意义，还增加了代码理解的难度，不如直接用原本的写法。\n更多时候，我们是在new初始化多个数据的时候使用这种方式。\n2.1 new初始化多个数据在动态内存管理那一章节，我们学习了new的两种使用方式，也提到了()/[]这两个括号的区别\nint *p1 = new int(3);//开辟一个int的空间，并初始化为3赋值给p1int *p2 = new int[3];//开辟3个int的空间，不进行初始化\n\n在C++11中，我们可以直接用花括号，对new开拼出来的数组进行批量初始化。打印的时候，可以看到p2中的数据都是没有进行初始化（vs也报了警告）而p3中的数据都完成了初始化\n\n对于结构体数据而言，我们可以用花括号直接调用其构造函数\n\n其中t5是发生了隐式类型转换+调用构造函数进行的初始化\nTestA t5 = &#123; 1, 3 &#125;;//对类来说，会进行隐式类型转换+调用构造函数\n\n通过调试+打断点可以看到其调用了构造函数进行初始化\n\n同样的，调用new的时候，我们可以用多个花括号的方式进行批量初始化。这在new一个对象数组的时候非常方便\n\n2.2 initializer_list2.2.1 STL容器初始化不光是我们自己写的类、内置类型可以使用这种方式进行初始化，stl库里面的容器也可以使用相同方式进行初始化\nvector&lt;int&gt; v1 = &#123; 1,2,3,4 &#125;;vector&lt;int&gt; v2&#123; 1,2,3,4 &#125;;//不建议这么写\n\n\n同样的，我们还可以用类似的方式初始化vector内部的对象\n\n作为容器的一份子，map也有一个利用il进行初始化的构造函数\n\n使用方式和之前提到的没啥区别，这里就不多讲啦\nmap&lt;int, int&gt; m1 = &#123; &#123;10, 20&#125;,&#123; 30,40&#125;,&#123;50,60&#125; &#125;;for (auto e : m1) &#123;\tcout &lt;&lt; e.first &lt;&lt; &quot;-&quot; &lt;&lt; e.second &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;\n\n\n你可能会好奇，这种初始化的底层是怎么实现的？那么就要提到c++11新增的一个容器了\n2.2.2  initializer_list 容器如果你把vector等容器的版本设定为C++11，看文档的时候便会发现C++11新增了一个用initializer_list进行初始化的操作\n\n\n再来看看initializer_list，这不就是我们刚刚用的花括号嘛？\n\n这个容器的成员函数很少，只有两个迭代器以及size()\n\n它最重要的特性，便是当我们使用auto自动推到参数类型的时候，&#123;1,2,3,4&#125;这种类型会被推到成initializer_list\nauto il = &#123; 10, 20, 30 &#125;;cout &lt;&lt; typeid(il).name() &lt;&lt; endl;//initializer_list \n\n因为他有迭代器，所以我们也可以使用范围for进行打印操作\n\n个人理解，当其他容器使用initializer_list进行初始化的时候，本质上调用的接口和利用迭代器进行初始化是一样的\n2.3.1 插入il部分容器的insert函数也添加了使用il进行插入连续数据的操作\n\nset&lt;int&gt; s2 = &#123; 1,2,3,4 &#125;;s2.insert(&#123; 5,6,7,8 &#125;);\n\n\n在vector中使用il插入的时候，需要指定pos位置这个和vector的其他几个插入函数是一样的\n\n2.4 模拟实现il构造函数那么，如何让我们自己模拟实现的vector也能支持这个功能呢？【模拟实现vector源码】\n和STL库里面的代码一样，添加上initializer_list的构造函数即可\n因为il容器已经有了它自己的迭代器，我们完全可以复用迭代器构造的操作，直接进行遍历然后push_back即可！\n//initializer_list构造vector(const initializer_list&lt;T&gt;&amp; il)    :_start(nullptr),    _finish(nullptr),    _endofstorage(nullptr)&#123;    for (auto e : il) &#123;        push_back(e);    &#125;&#125;\n\n\n试试自定义类型，也可以很好的支持！\n\n这里还有一个优化的地方，那便是开始构造的时候，直接给vector开对应il size()的空间大小，避免后续push_back的时候需要多次扩容\n//initializer_list构造vector(const initializer_list&lt;T&gt;&amp; il)    :_start(nullptr),_finish(nullptr),_endofstorage(nullptr)&#123;    reserve(il.size());//扩容    for (auto e : il) &#123;        push_back(e);    &#125;&#125;\n\n通过调试能发现达成了我们的需求（因为调试步骤太多，截图不方便，这里就不演示了。感兴趣的老哥可以去我的gitee仓库下源码自己试试）\n3.变量声明C++11提供了多种简化的声明/定义方式，比如我们熟悉的auto\n3.1 auto\nC++98中auto是一个存储类型的说明符，表明变量是局部自动存储类型，但是局部域中定义局 部的变量默认就是自动存储类型，所以auto就没什么价值了。\n\nC++11给auto上了实现自动类型推断的全新功能，方便我们在定义一个变量的时候直接用auto进行类型推导\nauto num = 1;//intauto p = &amp;num;//int*\n\n需要注意的是，如果想用auto推到，则必须初始化。只给一个auto i是不行的！\nauto还可以用于范围for等其他操作，这些都在之前讲解这个关键字的博客中有提到，这里就不多说了！\n\n3.2 decltype关键字decltype可以把变量声明成我们想要的目标类型；可以理解为和typedef的作用有一定的类似，但是它是可以自动推导的！\nint a = 10, b = 20;int sum = a * b;cout &lt;&lt; &quot;type(sum) &quot; &lt;&lt; typeid(sum).name() &lt;&lt; endl;decltype(a * b) num; // 把a*b的类型声明为numdecltype(&amp;sum) ptr;  // 把&amp;sum的类型声明为ptrcout &lt;&lt; &quot;type(a*b)  &quot; &lt;&lt; typeid(num).name() &lt;&lt; endl;cout &lt;&lt; &quot;type(&amp;sum) &quot; &lt;&lt; typeid(ptr).name() &lt;&lt; endl;\n\n\n怎么样，是不是觉得很神奇？很方便？\n需要注意的是，使用decltype关键字来指定函数指针的时候，函数名和函数参数之间需要加上&amp;，否则无法正确推导类型\ndecltype(add) &amp;(int, int) // 正确decltype(add) (int, int) // 错误    \n\n\n那让我们来看看另外一个语言声明变量的方式吧！😂 压根不需要变量类型捏（因为python是弱类型的语言）\n# Pythona=10sum = a*20print(type(a))print(type(sum))\n\n\n要是C++也有这么方便就好了😭\n3.3 typeid这个关键字上面已经用过好几次了，就是用来打印变量的类型的\nint a = 10;cout &lt;&lt; &quot;type(a) &quot; &lt;&lt; typeid(a).name() &lt;&lt; endl;\n\n\n4.左&#x2F;右值引用在之前我们学习了引用的基本操作，但那个是左值引用。当时我们尚未引入左指引用和右值引用的区别。本篇博客里面将会详细讲解~\n4.1 左值&#x2F;右值区别要解答这两种引用的区别，首先我们需要直到左值/右值分别代指什么\n左值：\n\n可以存在于=左边或右边\n可以取地址\n可以对它赋值（const除外）\n\n右值：\n\n右值是一个表示数据的表达式，比如：函数返回值[不能是左值引用返回的]、表达式返回值A+B、字面常量10\n右指只能出现在=的右边，不能出现在左边（俺可没见过A+B=C的代码语法）\n右指不能取地址\n\n左值和右值最大的区别便是：左值可以取地址，右值不能取地址\n4.1.1 将亡值（概念）右值还分为两种情况：\n//纯右值10;a+b;Add(a,b);//将亡值string s1(&quot;1111&quot;);//&quot;1111&quot;是将亡值string s2 = to_string(1234);//to_string的return对象是一个将亡值string s3 = s1+&quot;hello&quot; //相加重载的return对象是一个将亡值move(s1);//被move之后的s1也是将亡值\n\n在右值引用的介绍中将用上将亡值的概念\n4.2 左值引用左值引用就是对左值的引用。我们之前学习的就是这一类型\n// a、b、c、*a都是左值// 对象内部的*this也是左值int* a = new int(0);int b = 1;const int c = 2;// 以下是对上面左值的 左值引用int*&amp; rp = a;int&amp; rb = b;const int&amp; rc = c;int&amp; p = *a;// 引用相当于别名，修改引用后的内容相等于修改原本的参数\n\n之前也提到了，其作用主要是在针对出了作用域不会销毁的变量进行引用返回，以节省拷贝的代价。亦或者是引用传参，减少形参拷贝代价\n\n4.3 右值引用来看看几个比较常见的右值吧，其中Add是一个简单的相加函数\ndouble x = 1.1, y = 2.2;// 常见的右值10;x + y;Add(x, y);// 以下都是对右值的右值引用int&amp;&amp; rr1 = 10;double&amp;&amp; rr2 = x + y;double&amp;&amp; rr3 = Add(x, y);//右值不能出现在=的左边//10 = 1;//x + y = 1;//fmin(x, y) = 1;\n\n虽然我们不能直接对右值进行取地址/赋值操作，但是在右值引用过后，便可以对引用值进行取地址/赋值操作\n\n这是因为右值引用的时候，会把当前引用的数据放入一个位置存起来。\n存放位置：普通变量在栈，全局变量&#x2F;静态变量在静态区（没有验证过，可能不对）\n\nint&amp;&amp; rr1 = 10;cout &lt;&lt; rr1  &lt;&lt; endl;rr1 = 3;cout &lt;&lt; rr1 &lt;&lt; endl;int* p = &amp;rr1;*p = 2;cout &lt;&lt; rr1 &lt;&lt; endl;\n\n\n如果你不喜欢右值引用被修改，则可以使用const进行修饰\n\n4.4 两个引用的区别用一个表格来总结二者的区别\n\n\n\n左值引用\n右值引用\n\n\n\n只能引用左值\n只能引用右指\n\n\nconst可以引用左值&#x2F;右值\n可以引用move后的左值\n\n\n4.4.1 movemove可以把左值换成右值，但不能把右值转左值\n\n谨慎使用move，如果当前对象在后续还需要使用，则不能move将其改为右值，否则可能资源被掠夺导致该对象失效！\n\n\n4.5 右值引用使用场景右值引用可以提高移动构造/移动赋值等深拷贝场景的效率\n什么场景可以使用左值引用提高效率?\n\n操作符重载：前置++\n操作符重载：+=\n出了作用域后不会销毁的变量，如输出型参数（即传入函数进行处理的参数）\n\n而有一些场景是左值引用无法处理的：\n\n操作符重载：后置++（需要返回一个全新变量）\n操作符重载：+（需要返回一个全新变量）\n模拟实现string中的to_string函数\n\n这些场景大多有一个特性，那就是会生成一个全新的变量（对象）其对象生命周期出了函数作用域便会销毁（将亡值）\n如果使用左值引用返回，就会出现访问已经销毁了的对象的错误。\n\n假设我们有一个vector&lt;vector&lt;int&gt;&gt;，若内部的vector很大的时候，拷贝构造的代价是很大的！\n\n4.5.1 输出型参数如果在C++98的情况下，我们只能用输出型参数来解决这个问题\nvector&lt;vector&lt;int&gt;&gt;&amp; test(vector&lt;vector&lt;int&gt;&gt;&amp;v1,int val)&#123;    //……    //v1就是一个输出型参数。放入该函数进行操作后原路返回    return v1;&#125;\n\n4.5.2 右值引用 移动构造在C++11中，我们可以使用右值引用的拷贝构造来解决这个问题\n下方就是一个具体示例\nmuxue::string to_string(int val)&#123;    bool flag = true;    if (val &lt; 0)&#123;        flag = false;        val = 0 - val;    &#125;    muxue::string str;    while (val &gt; 0)&#123;        int x = val % 10;        val /= 10;        str += (&#x27;0&#x27; + x);    &#125;    if (flag == false)&#123;       str += &#x27;-&#x27;;    &#125;    std::reverse(str.begin(), str.end());    return str;&#125;\n\n在默认情况下，如果想使用这个to_string函数，就需要进行深拷贝进行传值返回。这是无可避免的代价\n如果使用左值引用返回，这里就会有bug。因为出了函数作用域后，临时对象str会被销毁。而如果我们使用左值引用取别名，在进行赋值的时候，便会出现利用str的别名进行拷贝构造，而str是一个已经销毁的对象的问题\n\n而如果我们使用右值引用返回，则不会出现这种问题。前提是我们自己实现了右值引用的构造函数和赋值重载\n\n一般我们把右值引用的构造函数&#x2F;赋值重载称作移动构造/移动赋值\n\n为什么叫移动呢？因为右值引用是会直接拿取对象的资源\nSTL_string我们可以先用库里面的string观察一下，当我们使用move之后的右值进行构造的时候，会直接拿掉对象的资源！\nstring s1 = &quot;1234134&quot;;string s2(s1);string s3(move(s1));\n\n\n\n而在使用右值进行返回的时候，编译器会进行一波优化，直接使用移动构造拿取资源，避免多次拷贝构造造成的空间和时间损失\n在处理这种问题的时候，就比输出型参数好太多了。\n\nMY_string不过库里面的string涉及到了buf之类的高级操作，也不适合我们调试查看调用的具体情况。所以这里我们再使用自己写的string来演示一下\n\n这里我还发现了之前模拟实现string的一个bug，在push_back操作的时候，没有给末尾加上\\0，导致析构的时候报错了\n\n模拟实现string代码见我的gitee仓库【传送门】\n\n\n在演示之前，我们先要实现自己的移动构造/移动赋值\n//移动赋值string&amp; operator=(string&amp;&amp; s)&#123;    swap(s);    return *this;&#125;//移动拷贝string(string&amp;&amp; s)    :_a(nullptr),    _size(0),    _capa(0)&#123;    swap(s);&#125;\n\n这里我直接复用了之前已经写好的一个swap函数，实现了一个“现代写法”的构造，直接交换了二者的资源。避免深拷贝带来的副作用\n\n接下来用下面的几个来测试一下拷贝构造的操作\nmuxue::string s1 = &quot;1234&quot;;muxue::string s2(s1);//拷贝构造muxue::string s3 = muxue::to_string(5678);//移动构造muxue::string s4 = s1 + s3;//拷贝构造+移动构造\n\n通过在构造函数中添加打印，可以看出这几个分别调用了什么构造函数\n\n\ns2调用了深拷贝构造，因为s1是一个左值\ns3调用了移动构造，因为to_string函数中return的是一个将亡值\ns4先是在运算符+重载中调用深拷贝构建了一个string的临时对象，在使用移动构造进行return\n\n运算符+重载的代码如下，和to_string一样，都是return了一个将亡值\n//相加重载string operator+(const string&amp; s)&#123;    muxue::string tmp(*this);    tmp += s;    return tmp;&#125;\n\n将一个对象move成为右值之后，便可以使用移动赋值\n\n移动构造直接移动资源这时候如果调用拷贝构造，就很是浪费：\n\n本来tmp的资源就要销毁了，你还得先把他的资源复制一份给自己，再销毁tmp\n那为何不把tmp的资源直接拿给自己呢？省去了复制的消耗！\n\n这便是移动构造的优势之处！\n调试体现出来的，便是深拷贝中两个对象_a的地址完全不同\n\n而移动构造是直接把s1的_a资源拿了过来！\n\n其最明显的特征，便是s3的_a地址就是s1的！\n\n\nSTL的更新如果我们把自己模拟实现的移动构造删除，那么所有的return都会去调用深拷贝，代价就很大了。对象很大的时候，来一次深拷贝有可能可以把整个系统干废😂\n\n所有STL的容器，在C++11之后，都支持了右值引用的插入、移动构造和移动赋值\n\nC++11的swap也提供了一个直接使用右值进行资源替换的版本，效率更高\n\n4.6 编译器优化在之前有关构造函数的博客里面有提到过，当我们return一个对象的时候，编译器会把两次拷贝构造优化成一次\n\n和拷贝构造一样，执行移动构造的时候，编译器也有一定的优化\n\n不过这个优化就取决于编译器的处理了。不排除有些编译器没有做此等处理哦！\n4.7 优化插入效率有了右值引用，只要我们实现一个右值引用方式的插入，也可以优化插入时的效率\nmuxue::list&lt;muxue::string&gt; t;muxue::string s1(&quot;111&quot;);//调用拷贝构造，左值t.push_back(s1);//调用移动构造，右值t.push_back(&quot;222&quot;);t.push_back(std::move(s1));\n\n5.完美转发(万能引用)c++11提供了一个万能引用，既可以引用左值，也可以引用右值\nvoid Fun(int&amp; x) &#123;     cout &lt;&lt; &quot;左值引用&quot; &lt;&lt; endl; &#125;void Fun(const int&amp; x) &#123;     cout &lt;&lt; &quot;const 左值引用&quot; &lt;&lt; endl; &#125;void Fun(int&amp;&amp; x) &#123;     cout &lt;&lt; &quot;右值引用&quot; &lt;&lt; endl; &#125;void Fun(const int&amp;&amp; x) &#123;     cout &lt;&lt; &quot;const 右值引用&quot; &lt;&lt; endl; &#125;template&lt;typename T&gt;void test(T&amp;&amp; t)&#123;//T&amp;&amp;就是一个万能引用\tFun(t);&#125;\n\n通过测试我们会发现，不管是传入一个左值还是传入一个右值，其都会调用左值引用\n\n这是因为右值引用之后，形参t就是一个左值，所以调用了左值的函数\n\n我们也不能粗暴的使用move来解决这里的问题，因为有时候一些左值对象在后续还是需要使用的，move之后变成右值，资源被拿走了咋办！\n&gt;template&lt;typename T&gt;&gt;void PerfectForward(T&amp;&amp; t)&gt;&#123;   Fun(std::move(t));&gt;&#125;\n\n\n\n而完美转发的存在就是为了将右值保持其右值属性，依旧调用右值对应的函数，其语法如下，使用forward函数进行完美转发\ntemplate&lt;typename T&gt;void PerfectForward(T&amp;&amp; t)&#123;    Fun(std::forward&lt;T&gt;(t));&#125;\n\n这时候第二种情况就正确掉用了对应的右值引用函数，也没有改变左值的属性\n\n再把函数改成我们自己写的string，也能看出完美转发的作用\ntemplate&lt;typename T&gt;void PerfectForward(T&amp;&amp; t)&#123;\tmuxue::string s = std::forward&lt;T&gt;(t);&#125;\n\n\n\n5.1 使用场景有些场景下，我们需要对一个函数传入不同类型的参数，这时候就需要用万能引用+完美转发来进行不同的处理\n比较典型的便是很多STL容器都提供了一个新的尾插函数emplace_back\n\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n这里便使用了万能引用，以及可变模板参数（后面会写道）\n利用我们自己写的string进行打印，即可看出二者的区别\n\n\nemplace_back直接调用了构造函数\npush_back 构造+移动构造\n\n因为移动构造的效率是很高的，所以这两种方式的差距并不算很大。不过差距肯定是有的，如果为了兼容性，使用push_back肯定更好，因为emplace是C++11新增的操作\n\n5.2 将可变模板参数转为C语言的可变参数列表\nhttps://segmentfault.com/q/1010000043736187\n\n在我尝试实现一个简单的日志类的时候，遇到了这个问题。最终成功解决\n我想通过debug,info,warning这些函数来打印对应等级的日志，它们最终调用的都是_logging函数，并在_logging函数中统一进行vsnprintf，我要怎么才能把可变参数列表传过去？还是说不支持这样的操作？\npublic:void debug(const char *def_name, const char *format, ...)void info(const char *def_name, const char *format, ...)private:void _logging(int level, const char *def_name,  const char *format, ...)\n\n\n如果不这么做，就得把使用vsnprintf的几行代码重复写到每一个独立函数中，有点代码重复\nva_list ap;va_start(ap, format);vsnprintf((char *)_log_info.c_str(), _log_size - 1, format, ap);va_end(ap);\n\n目前百度到如下办法，无作用\nvoid warning(const char *def_name, const char *format, ...)&#123;    // 获取可变参数列表    va_list ap;    va_start(ap, format);    _logging(LOG_WARINING, def_name, format,ap);    va_end(ap);&#125;\n直接调用logging函数的能正常打印，调用warning函数无法正常打印。如下，第一行是直接调用warning的，没有打印出消息内容\n[23-04-27 19:59:35] WARN | 1682596775 | test | [23-04-27 19:59:35] WARN | 1682596775 | test | 这是一个测试而已\n\n\n大佬回答中，提到了可以用可变模板参数+完美转发，直接将可变参数列表传过去就行了\n// c++ 中我们一般使用 variadic templates，除非你要和 c 库兼容template &lt;typename... Args&gt;void warning(const char *def_name, const char *format, Args &amp;&amp;...args) &#123;    _logging(LOG_WARINING, def_name, format, std::forward&lt;Args&gt;(args)...);&#125;\n\n感谢大佬的回答，在这里贴上完整可用的代码【也可以去我的github看】\npublic:    template &lt;typename... Args&gt;    void error(const char *def_name, const char *format, Args &amp;&amp;...args) &#123;        _logging(LOG_ERROR, def_name, format, std::forward&lt;Args&gt;(args)...);    &#125;\t//其他的都是对这项的copy，只修改传入的log levelprivate:\tvoid _logging(size_t level, const char *def_name, const char *format, ...)    &#123;        assert(level &gt;= LOG_DEBUG &amp;&amp; level &lt;= LOG_FATAL);        if (level &lt; _level)        &#123; // 低于定义的等级，不打印            return;        &#125;        va_list ap;        va_start(ap, format);        vsnprintf((char *)_log_info.c_str(), _log_size - 1, format, ap);        va_end(ap);        // 根据日志等级选择打印到stderr/stdout        // 超过了error的日志，要使用stderr打印        FILE *out = (level &gt;= LOG_ERROR) ? stderr : stdout;        def_name = def_name == nullptr ? &quot;unknow&quot; : def_name; // 判断defname是否为空        // 格式化打印到文件流中        fprintf(out, &quot;%s | %s | %s\\n&quot;,                    log_level[level],                    def_name,                    _log_info.c_str());    &#125;\n\n测试\nvoid LogTest()&#123;    vod::Logger _log;    _log.info(&quot;test&quot;,&quot;%s&quot;,&quot;this in info&quot;);    _log.warning(&quot;test&quot;,&quot;%s %d&quot;,&quot;this is warning&quot;,333);    _log.error(&quot;test&quot;,&quot;%s&quot;,&quot;this is err&quot;);    _log.fatal(&quot;test&quot;,&quot;%s&quot;,&quot;this is fatal!!!&quot;);&#125;\n\nINFO | test | this in infoWARINING | test | this is warning 333ERROR | test | this is errFATAL | test | this is fatal!!!\n\n6.新增的默认成员函数在初识类和对象的时候，我便在博客中提到了C++的几个默认成员函数\n\n构造函数 \n析构函数 \n拷贝构造函数 \n拷贝赋值重载 \n取地址重载 \nconst 取地址重载\n\n在C++11中也多了两个成员函数，那便是前文所讲述的移动构造/移动赋值\n但是想让编译器默认生成移动构造可没那么容易：只有你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个，编译器才会帮你整一个移动构造出来\n\n编译器默认生成的移动构造：对于内置类型会执行逐成员按字节拷贝；对自定义类型成员，则需要看这个成员是否实现移动构造， 如果实现了就调用移动构造，没有实现就调用拷贝构造。\n\n同样的，移动赋值也需要满足上面的条件，编译器才会帮你生成。\nclass TestB&#123;private:\tmuxue::string _s;\tint _a;public:\tTestB(const muxue::string&amp; s=&quot;&quot;, int a=0)\t\t:_s(s),\t\t_a(a)\t&#123;&#125;&#125;;void DefaultMoveCopy()&#123;\tTestB t1;\tcout &lt;&lt; endl;\tTestB t2 = t1;\tcout &lt;&lt; endl;\tTestB t3 = std::move(t1);\tcout &lt;&lt; endl;\tTestB t4;\tt4 = std::move(t2);\tcout &lt;&lt; endl;&#125;\n\n通过测试可以看出来，编译器默认生成了移动拷贝和移动赋值重载。并调用了自定义类型的移动拷贝/移动赋值\n\n6.1 关键字default\n这个关键字的作用之前好像记录过? 不记得了\n\ndefault关键字的作用是让编译器强制生成一个指定的成员函数\n还是上面的TestB类的代码，如果我们自己写一个拷贝构造，编译器就不再会生成默认的移动构造/移动赋值，而是会去调用string里面的拷贝构造、拷贝赋值\n\n这时候我们太懒了，不想自己写移动版本了，于是就用default强制让编译器干活\n\n现在就正确调用了对应的移动构造和移动赋值了！\n\n7.可变模板参数在5.1提到的emplace_back函数中，便出现了下面这种语法\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n这就是一个可变的模板参数，允许一个函数有多个参数，且不要求是相同类型\n使用sizeof即可查看参数的个数\n\n7.1 递归解参数包而如果你想查看参数的类型并使用它，则需要进行递归取出参数来\ntemplate &lt;class T&gt;void ShowArgs(const T&amp; val)&#123;\tcout &lt;&lt; val &lt;&lt; &quot;   type: &quot; &lt;&lt; typeid(val).name() &lt;&lt; endl;&#125;template &lt;class T,class... Args&gt;void ShowArgs(const T&amp;val,Args&amp;&amp;... args)&#123;\t//cout &lt;&lt; &quot;参数个数&quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;\tcout &lt;&lt; val &lt;&lt; &quot;   type: &quot; &lt;&lt; typeid(val).name() &lt;&lt; endl;\tShowArgs(args...);&#125;void TestArgs()&#123;\tShowArgs(1, &#x27;x&#x27;, 2.3, muxue::string(&quot;123&quot;));&#125;\n\n\n其中void ShowArgs(const T&amp; val)函数的作用，是当参数包中只有一个参数的时候，调用对应的单参函数，而不会报错\n另外一种办法便是提供一个无参的同名函数，用作参数包递归的结尾\n\n错误解法可能有人想使用这样的方法来解包，当参数包里的函数只有一个的时候，结束递归\n\n但是这样是不行的！\n\n递归推参数包是一个编译时逻辑\n通过sizeof判断是一个运行时逻辑\n\n在编译这个函数的时候，已经开始找对应的函数进行调用了。当参数包里面的参数只有1个或者0个的时候，编译器编译的时候发现找不到对应函数，就直接报错了。\n7.2 数组解包除了上面的递归解包，这里还可以使用数组的方式直接来解包\ntemplate &lt;class... Args&gt;void ShowArgs(Args&amp;&amp;... args)&#123;\tcout &lt;&lt; &quot;参数个数&quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;\tint arr[] = &#123; args... &#125;;&#125;void TestArgs()&#123;\tShowArgs(1, 2, 3, 4);&#125;\n\n可以看到arr数组里面解包出了传入的参数\n\n但是这种方法不通用，只适用于所有参数都是相同类型的情况，如果是不同类型则会报错\n\n通用办法是使用一个逗号表达式，来获取一共有多少个参数以及解包\ntemplate &lt;class T&gt;void PrintArgs(const T&amp; val)&#123;\tcout &lt;&lt; val &lt;&lt; &quot;   type: &quot; &lt;&lt; typeid(val).name() &lt;&lt; endl;&#125;template &lt;class... Args&gt;void ShowArgs(Args&amp;&amp;... args)&#123;\tcout &lt;&lt; &quot;参数个数&quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;\t//int arr[] = &#123; args... &#125;;\tint arr[] = &#123; (PrintArgs(args),0)... &#125;;&#125;\n\n一共有多少个参数，那么数组里面就会有多少个0\n\n7.3 emplace_backstd容器的库函数中emplace_back的参数包还使用了万能引用，这就让它的使用更加灵活\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n可以直接传入两个参数，他会自动解包参数，创建一个键值对\nstd::list&lt;std::pair&lt;int, muxue::string&gt;&gt; t;t.emplace_back(10, &quot;sort&quot;);\n\n而push_back则不支持这么干\n\n\n8.lambda表达式在之前，我们使用sort的时候，如果是内置类型，默认会返回一个升序序列。如果我们需要返回降序，则需要改变比较规则，传入一个仿函数来使用自定义的比较对比\n#include &lt;algorithm&gt;//sort#include &lt;functional&gt;//greaterint main()&#123;\tint arr[]=&#123;1,3,2,5,4&#125;;    int sz=sizeof(arr)/sizeof(arr[0]);    //默认升序\tstd::sort(arr,arr+sz);    //降序传入仿函数greater    std::sort(arr,arr+sz,greater&lt;int&gt;());&#125;\n\n因为int是内置类型，库中自带的greater/less仿函数即可满足我们的需求。而如果我们排序的是自定义类型，则需要自己实现一个对应的仿函数\n//价格降序struct CompPriceGreater&#123;\tbool operator()(const Goods&amp; g1, const Goods&amp; g2)\t&#123;\t\treturn g1._price &gt; g2._price;\t&#125;&#125;;//价格升序struct CompPriceLess &#123;\tbool operator()(const Goods&amp; g1, const Goods&amp; g2)\t&#123;\t\treturn g1._price &lt; g2._price;\t&#125;&#125;;\n\n\n8.1 情景描述但是如果需要处理的对象有很多不同的成员变量的时候（比如京东淘宝上商品不同的筛选方式）我们就需要实现非常非常多的仿函数\n这样一来，程序的代码行数就会变多\n在VS编译器下，这种问题还算好解决，我们可以快速跳转道函数定义。但如果我们没有这个功能可用，在处理大文本代码的时候，怎么很快的找到对应的仿函数呢？\n特别是在项目合作的时候，万一有个家伙编程命名规范很差劲，我们无法从函数名推断函数功能，再加上不能直接跳转定义，那麻烦事可多了。\n\n8.2 lambda出场这时候就可以试试用lambda表达式拉，以下是lambda表达式的书写格式\n[capture-list](parameters)mutable -&gt; return-type&#123;statement&#125;\n\n说明一下各个位置分别写的是啥玩意\n\n[capture-list]捕捉列表，用于编译器判断为lambda表达式，同时捕捉该表达式所在域的变量以供函数使用\n(parameters)参数，和函数的参数一致。如果不需要传参则可连带()一起省略\nmutable默认情况下捕捉列表捕捉的参数是const修饰的，该关键字的作用是取消const使其可修改\n-&gt; return-type函数返回值类型\n&#123;statement&#125;函数体，和普通函数一样。除了可以使用传入的参数，还可以使用捕捉列表获取的参数\n\n8.3 基本使用先来写一个最简单的lambda表达式试试水吧\nauto Add = [](int a, int b) &#123;return a + b; &#125;;\n\n\n可以看到，这个表达式的使用方法和函数完全一致，也成功提供了结果\n因为我们返回值的类型是明确的，所以这里可以省略类型，让编译器自己来推断。当然也可以显示指定类型，这样可以更精确的控制\n\n\nlambda表达式还支持复制给相同类型的函数指针，但是一般都不要这么用！\n//f2是一个lambdavoid(*PF)();PF = f2;PF();\n\n\n8.4 捕捉列表和mutable学会了基本使用，我们再来看看捕捉列表是怎么玩的\nvoid TestLambda1()&#123;\tint a = 10, b = 20;\tauto func3 = [a,b](int x, int y)-&gt;int &#123;\t\treturn a+b;\t&#125;;\tcout&lt;&lt;func3(a, b)&lt;&lt;endl;&#125;\n\n\n这里我们捕捉了函数作用域里面的局部变量a/b，直接在lambda表达式内部使用👍\n因为不需要传入参数，所以我们可以直接把参数()和返回值一并省略掉\n\nmutable默认情况下，我们捕捉到的参数是带const的，我们并不能对其进行修改。\n\n这时候就需要使用前面提到的mutable关键字来修饰\n\n注意：这个关键字使用的时候必须带上函数参数的()\n\nauto func5 = [a, b]()mutable &#123;    a++;    b++;    return a + b;&#125;;\n\n\n\n8.5 捕获的几种方式注意，当我们在对象里面以值传递方式捕获参数的时候，还需要捕获this指针来调用类内部的函数\n[val]：表示值传递方式捕捉变量val[=]：表示值传递方式捕获所有父作用域中的变量(包括this)[&amp;val]：表示引用传递捕捉变量val[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括this)[this]：表示值传递方式捕捉当前的this指针\n\n其中第一个就是我们上面演式的[a,b]这样最直接的值捕获\n而最后一个的this指针主要用用于类内部；需要注意，this指针是不能被引用捕获的！因为函数里面的this指针本来也只是个传值参数而已，对于这个指针本身来说，引用捕获的意义其实并不是很大。\nclang++ test.cpp -o test -std=c++17test.cpp:84:18: error: &#x27;this&#x27; cannot be captured by reference        return [&amp;this]                 ^1 error generated.\n\n在C++17中新增了一个对*this的传值捕获，这部分可以去看C++17的博客。\n8.5.1 全捕获&#x3D;当一个作用域里面的变量很多，而我们又不想一个一个写的时候，可以使用=捕捉全部变量\nint a = 10, b = 20;int c = 1, d = 3, e = 5;auto func6 = [=] &#123;    return (a + b + c + d + e);&#125;;cout &lt;&lt; func6() &lt;&lt; endl;\n\n\n8.5.2 引用全捕或除了基本的全捕或，我们还可以用一个&amp;以引用的方式捕获全部参数。\n\nint a = 10, b = 20;int c = 1, d = 3, e = 5;auto func7 = [&amp;] &#123;    return (a + b + c + d + e);&#125;;cout &lt;&lt; func7() &lt;&lt; endl;\n\n引用了过后，我们也可以修改参数了\n\n8.5.3 全捕获+单独操作如果只是仅仅的全捕或还不够，我们还想单独修改某一个参数的时候，可以以不同的方式进行捕获操作\n\nauto func8 = [=,&amp;e] &#123;\te++;\treturn (a + b + c + d + e);&#125;;\n\n\n这样一来就方便多了\n8.6 最终呈现这样，当我们sort的时候，就不再需要用仿函数了，而是可以直接用lambda表达式来完成相同的操作，大大增加代码可读性！\n这是因为排序所用的方法直接就在sort这里用lambda的形式给出了，看代码的时候，也不需要去找定义，更不用担心函数命名规则的问题了。\nvector&lt;Goods&gt; v1 = &#123; &#123;&quot;牛奶&quot;,20,100&#125;,&#123;&quot;杯子&quot;,10,200&#125;,&#123;&quot;饼干&quot;,15,50&#125; &#125;;//价格升序sort(v1.begin(), v1.end(), [](const Goods&amp; g1, const Goods&amp; g2) &#123;return g1._price &lt; g2._price; &#125;);for (auto&amp; e : v1) &#123;\tcout &lt;&lt; e._name &lt;&lt; &quot;_&quot; &lt;&lt; e._price &lt;&lt; &quot;  &quot;;&#125;cout &lt;&lt; endl;v1 = &#123; &#123;&quot;牛奶&quot;,20,100&#125;,&#123;&quot;杯子&quot;,10,200&#125;,&#123;&quot;饼干&quot;,15,50&#125; &#125;;//价格降序sort(v1.begin(), v1.end(), [](const Goods&amp; g1, const Goods&amp; g2) &#123;return g1._price &gt; g2._price; &#125;);for (auto&amp; e : v1) &#123;\tcout &lt;&lt; e._name &lt;&lt; &quot;_&quot; &lt;&lt; e._price &lt;&lt; &quot;  &quot;;&#125;cout &lt;&lt; endl;v1 = &#123; &#123;&quot;牛奶&quot;,20,100&#125;,&#123;&quot;杯子&quot;,10,200&#125;,&#123;&quot;饼干&quot;,15,50&#125; &#125;;//名称字典序sort(v1.begin(), v1.end(), [](const Goods&amp; g1, const Goods&amp; g2) &#123;return g1._name &lt; g2._name; &#125;);for (auto&amp; e : v1) &#123;\tcout &lt;&lt; e._name &lt;&lt; &quot;_&quot; &lt;&lt; e._price &lt;&lt; &quot;  &quot;;&#125;cout &lt;&lt; endl;\n\n\n8.7 lambda底层：仿函数实际上，lambda的底层就是把自己转成了一个仿函数供我们调用。这也是为何sort可以以lambda来作为排序方法的原因——底层都是仿函数嘛！\n\n8.8 lambda递归如果需要用lambda写递归函数，那么lambda必须用fuction明确指定类型，而不能用auto！\n比如下方是一个最简单的斐波那契的递归\n// 这里必须要引用捕获自身auto fib = [&amp;fib](int a) -&gt; int   &#123;       if ((a == 1) || (a == 2))       &#123;           return 1;       &#125;       else       &#123;           return (fib(a - 1)) + (fib(a - 2)); // n-1和n-2项       &#125;   &#125;;\n\n这个时候编译就会出现如下的报错，因为auto是要这个lambda表达式的定义完全结束了才能进行类型推断，而我们又在lambda的函数体内使用了fib本身，那么就出现了声明前使用的问题！\ntest.cpp: In function ‘int main()’:test.cpp:75:18: error: use of ‘fib’ before deduction of ‘auto’     auto fib = [&amp;fib](int a) -&gt; int                  ^~~test.cpp: In lambda function:test.cpp:83:21: error: use of ‘fib’ before deduction of ‘auto’             return (fib(a - 1)) + (fib(a - 2)); // n-1和n-2项                     ^~~test.cpp:83:36: error: use of ‘fib’ before deduction of ‘auto’             return (fib(a - 1)) + (fib(a - 2)); // n-1和n-2项                                    ^~~\n\n正确的写法如下，用function明确指明这个lambda表达式的类型！而且还需要引用捕捉自身！\n// 这里必须要引用捕获自身，[&amp;fib]，否则他不知道fib是啥玩意std::function&lt;int(int)&gt; fib = [&amp;fib](int a) -&gt; int   &#123;       if ((a == 1) || (a == 2))       &#123;           return 1;       &#125;       else       &#123;           return (fib(a - 1)) + (fib(a - 2)); // n-1和n-2项       &#125;   &#125;;\n\n这时候才能通过编译！\n9.包装器functionfunction包装器，也叫作适配器。C++中的function本质是一个类模板，也是一个包装器。\n那么这个东西是用来干啥的呢？\n\n把所有的可调用对象封装成统一的格式\n\n什么是可调用对象？\n\n函数\n函数指针\n仿函数对象\nlambda表达式\n\n9.1 基本使用我们可以用function来包装这些不同的可调用对象，说白了就是产生了另外一个相同的可调用对象。类似于“引用”了这个函数\nclass AddClass&#123;public:\tstatic int Addi(int a, int b)&#123;\t\treturn a + b;\t&#125;\tdouble Addd(double a, double b)&#123;\t\treturn a + b;\t&#125;&#125;;int func(int a,int b)&#123;\treturn a + b;&#125;struct Functor&#123;\tint operator()(int a,int b)&#123;\t\treturn a+b;\t&#125;&#125;;void TestFunction1()&#123;\t// 函数\tfunction&lt;int(int, int)&gt; func1 = func;\tcout &lt;&lt; func1(10, 20) &lt;&lt; endl;\t// 仿函数\tfunction&lt;int(int, int)&gt; func2 = Functor();\tcout &lt;&lt; func2(10, 20) &lt;&lt; endl;\t// 类中static成员函数\tfunction&lt;int(int, int)&gt; func3 = AddClass::Addi;\tcout &lt;&lt; func3(100, 200) &lt;&lt; endl;\t// 类中非静态成员函数\tfunction&lt;double(AddClass, double, double)&gt; func4 = &amp;AddClass::Addd;\tcout &lt;&lt; func4(AddClass(), 100.11, 200.11) &lt;&lt; endl;\t// lambda表达式\tfunction&lt;int(int, int)&gt; func5 = [](int a, int b) &#123;return a + b; &#125;;\tcout &lt;&lt; func5(100, 200) &lt;&lt; endl;&#125;\n\n\n引用类中非static成员需要注意的是，当我们使用静态成员函数的时候，必须要带上一个this指针才能很好的访问。所以我们需要穿入一个AddClass()的匿名对象来适配包装器\n同时，非静态的成员函数还必须要进行&amp;取地址操作。静态的则可以不加\n\n为了统一，可以给成员函数都加上取地址以防忘记\n\n\n9.2 特殊场景的作用这个东西呢，看起来好像没啥用，但是在一些地方可以帮大忙\n比如模板函数，假设我们知道在函数B里面需要调用一个模板函数A多次，而且每次调用都是相同类型的（或者说就只有已知的几个特定类型），那么就可以先用fuction对这个模板函数进行指定的实例化，避免每一次调用的时候，后台都需要单独去实例化一个函数，减小模板的性能损耗！\n9.3 改造逆波兰表达式OJ\nleetcode逆波兰表达式：https://leetcode.cn/problems/evaluate-reverse-polish-notation/\n\n之前写这个OJ的时候，我用的是栈和switch/case语句\nclass Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; s;        for(auto&amp; ch : tokens)        &#123;            if(ch==&quot;+&quot;||ch==&quot;-&quot;||ch==&quot;*&quot;||ch==&quot;/&quot;)            &#123;                int right=s.top();                s.pop();                int left=s.top();                s.pop();                switch(ch[0])                &#123;                    case &#x27;+&#x27;:                        s.push(left+right);                        break;                    case &#x27;-&#x27;:                        s.push(left-right);                        break;                    case &#x27;*&#x27;:                        s.push(left*right);                        break;                    case &#x27;/&#x27;:                        s.push(left/right);                        break;                    default:                        break;                &#125;            &#125;            else&#123;                s.push(stoi(ch));            &#125;           &#125;        return s.top();    &#125;&#125;;\n\n现在我们就不需要这么麻烦了，可以使用包装器来改造这个OJ题的答案\nclass Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; s;        map&lt;string,function&lt;int(int,int)&gt;&gt; FuncMap = &#123;            &#123;&quot;+&quot;,[](int x,int y)&#123;return x+y;&#125;&#125;,            &#123;&quot;-&quot;,[](int x,int y)&#123;return x-y;&#125;&#125;,            &#123;&quot;*&quot;,[](int x,int y)&#123;return x*y;&#125;&#125;,            &#123;&quot;/&quot;,[](int x,int y)&#123;return x/y;&#125;&#125;        &#125;;        for(auto&amp; ch : tokens)        &#123;            if(ch==&quot;+&quot;||ch==&quot;-&quot;||ch==&quot;*&quot;||ch==&quot;/&quot;)            &#123;                int right=s.top();                s.pop();                int left=s.top();                s.pop();                int ret = FuncMap[ch](left,right);                s.push(ret);            &#125;            else&#123;                s.push(stoi(ch));            &#125;           &#125;        return s.top();    &#125;&#125;;\n\n这里我们还用到了前面提到过的&#123;&#125;初始化构造。现在我们只需要从funcmap里面取出封装器封装的lambda表达式进行操作就可以了！\n代码一下就简洁了许多，但是这也只有学习过C++11的人才看得懂，属于一个进阶用法。这种键值对的方式也更方便后续代码的扩展。想添加其他的运算符，就只需要给map里面新增运算符字符串和对应的lambda表达式就可以了。\n如果用switch/case的老办法，就还得自己再写一个判断分支，会产生一定的代码冗余和重复。\n\n测试的时候发现出现了一些问题，int溢出了。这大概率是因为leetcode修改了测试用例。\n\n把所有的int都改成long long即可。反正逻辑性代码没有bug就OK啦。\n\n\n10.bind绑定在上面我们用fuction包装一个对象内部的成员函数时，需要利用匿名对象传入一个this指针。这样就很不方便了，明明是两个参数的函数，非要传入第三个参数。\n要是我们再用9.3中map的方式来封装一个可调用的表，那带this指针的函数就没办法一起包装了\nclass AddClass&#123;public:\tstatic int Addi(int a, int b)\t&#123;\t\treturn a + b;\t&#125;\tint Addii(int a, int b)\t&#123;\t\treturn a + b;\t&#125;&#125;;int func(int a,int b)&#123;\treturn a + b;&#125;struct Functor&#123;\tint operator()(int a,int b)\t&#123;\t\treturn a+b;\t&#125;&#125;;map&lt;string, function&lt;int(int, int)&gt;&gt; FuncMap = &#123;    &#123;&quot;函数&quot;,func&#125;,    &#123;&quot;仿函数&quot;,Functor()&#125;,    &#123;&quot;静态成员函数&quot;,AddClass::Addi&#125;,    &#123;&quot;非静态成员函数&quot;,&amp;AddClass::Addii&#125;&#125;;\n\n如图，最后addclass中的非静态函数，就没有办法一同包装到map中\n\n\n这里不能使用可变参数包，因为是实例化操作\n\n这时候我们就可以使用bind来进行参数绑定\n10.1 使用bind可以调整参数的顺序，绑定固有参数；最后形成一个新的可调用对象。\nbind的第一个参数用于指定需要绑定的函数，后面就是绑定的参数，和需要自己传入的参数\nfunction&lt;int(int, int)&gt; func7 = bind(&amp;AddClass::Addii,AddClass(), placeholders::_1, placeholders::_2);cout &lt;&lt; func7(100, 200) &lt;&lt; endl;\n\n\n这时候我们就不需要传入this指针，因为当我们用bind绑定的时候，已经默认传入了第一个参数了！\n10.2 占位符placeholdersplaceholders是用来占位的，代表这里的参数需要用户手动传入，而_1代表传入的第一个参数，_2就是传入的第二个参数，以此类推\nfunction&lt;int(int, int)&gt; func7 = bind(&amp;AddClass::Addii,AddClass(), placeholders::_1, placeholders::_2);\n\n因为有不同的后缀，所以我们还可以调整绑定的参数顺序！\n//Minii的作用是a-bfunction&lt;int(int, int)&gt; func8 = bind(&amp;AddClass::Minii, AddClass(), placeholders::_1, placeholders::_2);cout &lt;&lt; func8(100, 200) &lt;&lt; endl;function&lt;int(int, int)&gt; func9 = bind(&amp;AddClass::Minii, AddClass(), placeholders::_2, placeholders::_1);cout &lt;&lt; func9(100, 200) &lt;&lt; endl;\n\n\n我们调整了顺序之后，也得到了不同的结果！\n10.3 异常以下为cplusplus网站上对bind函数可能出现异常的描述\nException safety   Basic guarantee: if an exception is thrown, all objects involved are left in a valid state.   This function may only throw if the construction of any of its internal elements (of the decay types of Fn and Args...) throws.\n\nstd::bind 只有在传入的函数的参数构造时抛异常，他才会抛出异常。比如在拷贝构造中抛出异常的类。\n\n注意，如果传入的函数内部会抛出异常，和bind是没有关系的，这类异常会在函数运行时抛出，而不是bind的时候抛出。\n另外，如果bind的目标函数参数和传入的参数数量&#x2F;类型不一致，会引发编译时错误，而不是运行时异常。\n\n比如下放的示例代码中，myexpclass的拷贝构造会检测成员变量是否为负数，如果为负数不允许拷贝，会抛出一个异常。在main函数中，我们尝试引发这个异常，就能观测到std::bind在函数传参进行拷贝构造时抛出这个异常。（因为这里的参数没有使用引用，所以函数传参需要拷贝）\n#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;stdexcept&gt;using namespace std;// bind测试函数template &lt;typename Callable, typename... Args&gt;void MyExpTestFunc(Callable &amp;&amp;func, Args &amp;&amp;...args)&#123;    try    &#123;        auto function = std::bind(std::forward&lt;Callable&gt;(func), std::forward&lt;Args&gt;(args)...);    &#125; catch (...)    &#123;        std::cout &lt;&lt; &quot;throw exception&quot; &lt;&lt; std::endl;    &#125;&#125;class myexpclass&#123;public:    myexpclass(int32_t a= 10,int32_t b= 20)        :_a(a),_b(b)    &#123;&#125;    myexpclass(const myexpclass&amp; eee)    &#123;        if(eee._a &lt; 0 || eee._b &lt; 0)        &#123;            throw std::runtime_error(&quot;this class cannot be copy&quot;);        &#125;        _a = eee._a;        _b = eee._b;    &#125;private:    int32_t _a;    int32_t _b;&#125;;int main()&#123;    std::function&lt;void(myexpclass)&gt; testFuncInt = [](myexpclass num)    &#123;        std::cout &lt;&lt; &quot;test MyExpTestFuncAgent with params&quot; &lt;&lt; std::endl;    &#125;;    myexpclass test1(1,2);    myexpclass test2(-1,2);    MyExpTestFunc(testFuncInt, test1);    std::cout &lt;&lt; &quot;end test1&quot; &lt;&lt; std::endl;    MyExpTestFunc(testFuncInt, test2);    std::cout &lt;&lt; &quot;end test2&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;exit&quot; &lt;&lt; std::endl;    return 0;&#125;\n\n测试结果如下，test2参数进行bind的时候确抛出了该异常。\n&gt; ./testend test1throw exceptionend test2exit\n\n11.static_assertstatic_assert 是 C++11 引入的一个关键字，用于在编译时进行断言检查。它允许你在代码中添加一些条件，如果这些条件在编译时不满足，编译将会失败并显示错误消息。\nstatic_assert 的主要作用是在编译时验证一些常量表达式的真假情况，从而帮助开发人员捕获一些潜在的问题，例如常量值是否符合预期、模板参数是否满足要求等。\n示例：\n#include &lt;iostream&gt;template &lt;typename T, int Size&gt;class Array &#123;    static_assert(Size &gt; 0, &quot;Array size must be greater than zero&quot;);    T data[Size];public:    // ...&#125;;int main() &#123;    Array&lt;int, 0&gt; emptyArray; // 编译时失败，因为Size不满足条件    return 0;&#125;\n\n在上面的示例中，Array 类使用 static_assert 来检查数组大小是否大于零。如果在实例化 Array 类时数组大小不满足要求，编译时将会失败，并显示指定的错误消息。\n\nstatic_assert在编译时进行合法性检查\nassert在运行时进行检查\n\n12.constexprconstexpr 是 C++11 引入的关键字，用于声明在编译时可以求值的常量表达式。它可以用于变量、函数、构造函数等上下文，用来告诉编译器在编译时计算表达式的值，从而将其作为常量使用。\nconstexpr 的主要作用包括：\n\n编译时计算： 使用 constexpr 声明的变量或函数可以在编译时计算，而不需要在运行时进行计算。这有助于提高代码的性能，因为在编译时计算的结果可以直接嵌入到生成的机器码中。\n常量表达式： 通过使用 constexpr，你可以声明常量表达式，这些表达式可以用作编译时的常量值，例如数组大小、模板参数等。\n模板元编程： constexpr 可以与模板一起使用，用于在编译时执行一些复杂的操作，从而实现元编程技术。\n\n示例：\nconstexpr int factorial(int n) &#123;    return (n &lt;= 1) ? 1 : n * factorial(n - 1);&#125;int main() &#123;    constexpr int result = factorial(5); // 编译时计算阶乘    static_assert(result == 120, &quot;Factorial of 5 should be 120&quot;); // 编译时断言    return 0;&#125;\n\n在上面的示例中，factorial 函数被声明为 constexpr，这意味着它可以在编译时计算。我们使用 constexpr 函数计算了阶乘，并在 main 函数中使用了 static_assert 进行编译时断言，确保计算的结果是正确的。\n在具体运行到这里的时候，就不再需要实时计算，而是直接沿用了编译过程中生成的结果；提高了代码运行效率，但增加了编译时间。\n总之，constexpr 关键字允许在编译时求值的常量表达式，有助于优化代码并支持一些元编程技术。它在 C++ 中为编译时计算提供了强大的工具。\n13.remove_extent#include &lt;type_traits&gt;template&lt; class T &gt;struct remove_extent;\n\n若 T 是某类型 X 的数组，则提供等于 X 的成员 typedef type ，否则 type 为 T 。\n注意若 T 是多维数组，则只移除第一维。添加 std::remove_extent 的特化的程序行为未定义。\n// C++14中多了一个辅助类型来使用该类template&lt; class T &gt;using remove_extent_t = typename remove_extent&lt;T&gt;::type;\n\n说人话的，这个东西的作用是获取到数组的成员的类型；如果传入多维数组，则只会接触第一维；示例：\nvoid test_extend()&#123;    using ArrayType1 = int[5];    using ArrayType2 = int[5][10];    using ArrayType3 = int[5][10][10];    using ElementType1 = std::remove_extent&lt;ArrayType1&gt;::type;    using ElementType2 = std::remove_extent&lt;ArrayType2&gt;::type;    using ElementType3 = std::remove_extent&lt;ArrayType3&gt;::type;    std::cout &lt;&lt; typeid(ElementType1).name() &lt;&lt; std::endl;    std::cout &lt;&lt; typeid(ElementType2).name() &lt;&lt; std::endl;    std::cout &lt;&lt; typeid(ElementType3).name() &lt;&lt; std::endl;&#125;\n\n在linux下打印如下，这里就能看出文档里面说的对于多维数组只移除第一维的含义\n$ ./testiA10_iA10_A10_i\n\n14.[[nodiscard]]这个关键字的作用，是让编译器警告用户，不要忽略函数的返回值\n[[nodiscard]] int calculateSum(int a, int b) &#123;    return a + b;&#125;int main() &#123;    calculateSum(2, 3);  // 编译器可能会发出警告，提示未使用返回值    return 0;&#125;\n\n即这个函数的返回值必须被接受且使用，否则就会被警告\n$ g++ test.cpp -o test -std=c++11test.cpp: In function ‘int main()’:test.cpp:8:17: warning: ignoring return value of ‘int calculateSum(int, int)’, declared with attribute nodiscard [-Wunused-result]     calculateSum(2, 3);  // 编译器可能会发出警告，提示未使用返回值     ~~~~~~~~~~~~^~~~~~test.cpp:3:19: note: declared here [[nodiscard]] int calculateSum(int a, int b) &#123;                   ^~~~~~~~~~~~\n\n只要你用一个变量接受了这个返回值，就不会收到这个警告了\n[[nodiscard]] int calculateSum(int a, int b) &#123;    return a + b;&#125;int main() &#123;    int i = calculateSum(2, 3);  // 接受了返回值，不会发出警告    return 0;&#125;\n\n使用函数返回值作为判断条件，也算是使用了这个返回值，同样不会发出警告\n[[nodiscard]] int calculateSum(int a, int b) &#123;    return a + b;&#125;int main() &#123;    if(calculateSum(2, 3));  // 接受了返回值，不会发出警告    return 0;&#125;\n\n15.std::begin&#x2F;end迭代器这里说的迭代器并不是容器内部的，std为了一致性，在C++11引入了std::begin/std::end来进行对原生数组的迭代;\n这两个函数除了可以构造一个原生数组的迭代器，还能获取到vector容器的迭代器；\n#include &lt;iterator&gt;// container (1)template &lt;class Container&gt;  auto begin (Container&amp; cont) -&gt; decltype (cont.begin());template &lt;class Container&gt;  auto begin (const Container&amp; cont) -&gt; decltype (cont.begin());// array (2)\ttemplate &lt;class T, size_t N&gt;  T* begin (T(&amp;arr)[N]);\n\n如下是cplusplus网站上的示例代码，看了就会好吧；&lt;iterator&gt;头文件会在&lt;vector&gt;头文件中被包含，所以这里不需要再包含一次了。\n// std::begin / std::end example#include &lt;iostream&gt;     // std::cout#include &lt;vector&gt;       // std::vector, std::begin, std::endint main () &#123;  int foo[] = &#123;10,20,30,40,50&#125;;  std::vector&lt;int&gt; bar;  // iterate foo: inserting into bar  for (auto it = std::begin(foo); it!=std::end(foo); ++it)    bar.push_back(*it);  // iterate bar: print contents:  std::cout &lt;&lt; &quot;bar contains:&quot;;  for (auto it = std::begin(bar); it!=std::end(bar); ++it)    std::cout &lt;&lt; &#x27; &#x27; &lt;&lt; *it;  std::cout &lt;&lt; &#x27;\\n&#x27;;  return 0;&#125;\n\n而用typeid获取变量名字\nint main()&#123;\tvector&lt;int&gt; arrv;\tarrv.push_back(1);\tcout &lt;&lt; typeid(arrv.begin()).name() &lt;&lt; endl;\tcout &lt;&lt; typeid(std::begin(arrv)).name() &lt;&lt; endl;\tint arri[] = &#123; 1,2,3 &#125;;\tcout &lt;&lt; typeid(std::begin(arri)).name() &lt;&lt; endl;\treturn 0;&#125;\n\n得到的结果如下，可见std::begin本质上只是对int*指针的一个封装。而如果用begin函数获取vector的迭代器，那么就会去取到vector之中封装好的迭代器，和直接使用arrv.begin()的效果相同\nclass std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;class std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;int *\n\n16.std::any_of类似的函数还有 std::for_each\n函数定义#include &lt;algorithm&gt;bool any_of ( InputIterator start, InputIterator end, UnaryPredicate callback ) ;\n\n这个函数的作用是，根据给定的迭代器区间，遍历执行callback函数；只要callback函数返回了一次true，整个函数就会退出并返回true。否则返回false。\n相当于只有迭代器区间中的所有值都不满足回调函数中的判断条件的时候，才会返回false；\n使用示例上示例\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;int main()&#123;    // 设立一个相除的map    unordered_multimap&lt;int,int&gt; divm;    divm.emplace(1,2);    divm.emplace(6,29);    divm.emplace(0,20);    divm.emplace(10,0); // error    divm.emplace(3,2);    divm.emplace(33,234);    // 遍历判断这个map里面是否所有的参数都满足相除的条件（即除数不能为0）    if(std::any_of(divm.begin(),divm.end(),[](const auto&amp; div_pair)-&gt;bool&#123;        return div_pair.second == 0;    &#125;))    &#123;        cout &lt;&lt; &quot;args error&quot; &lt;&lt; endl;    &#125;    else&#123;        cout &lt;&lt; &quot;all good to div&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n\n在上面的代码中，我们通过any_of和lambda表达式来判断即将要进行批量相除操作的map中是否包含不满足相除条件的参数。可以看到，这之中有一对的除数是0，这是不符合除法的规则的。而判断条件就是判断第二个除数是否为0，所以any_of理应报错；\n运行结果如下，符合预期\nargs error\n\n如果将出错的哪一行注释掉，那么就不会报错\nall good to div\n\n17.std::atomic::compare_exchange_strong1.说明之前只接触过 std::atomic ，它是C++内置提供的一个模板类，帮我们封装了访问的原子性。\n一般情况下，我们只会在数字变量上使用 std::atomic ，这时候对数据的修改操作就不需要我们自己加锁解锁了，std底层会自动封装锁的操作。\n在 std::atomic 中还有两个函数，分别是 compare_exchange_strong 和 compare_exchange_weak ；\n这两个函数的入参和功能都相同，我们主要关注的是前两个入参\n\n和第一个入参except进行比较，如果原子量和该参数相同，则将原子量改成第二个参数，并返回true\n如果原子量和第一个参数不同，则将第一个参数改为当前原子量的值，返回false\n\n第一个入参是引用传参，是一个输入输出参数。在原子量和第一个参数不同的时候，这个参数会被修改。\nif(!x.compare_exchange_strong(0,10))&#123;  // 这两个参数之间可能会出现第二个执行流来访问并修改x，导致线程不安全，缺失原子性    auto current_val = x; // x.load()&#125;\n\n为了避免上述情况中的线程安全问题，compare_exchange函数会在原子量和第一个参数不一致的时候，通过第一个参数输出当前的原子量。这样就能保证线程安全。所以如果你需要获取到原子量的当前值，请不要给第一个参数传入右值，传入可修改的左值；\n2.compare_exchange_strong的使用示例State cur_state = State::Ready;if (engine.state_.compare_exchange_strong(cur_state,State::Closing)&#123;    // 判断当前引擎的状态，如果是就绪状态，就把他关闭    engine.close();&#125;else&#123;    // 如果是其他状态，就将错误输出，并通过输入输出参数获取到当前引擎的状态    cout &lt;&lt; &quot;[cannot close] cur_state: &quot; &lt;&lt; cur_state &lt;&lt; endl;&#125;\n\n3.weak和strong的区别 C++ 中 std::atomic 类型的 compare_exchange 应该选择哪个版本？ - 知乎 (zhihu.com) \n C++11：原子交换函数compare_exchange_weak和compare_exchange_strong-CSDN博客 \nweak版本的CAS允许偶然出乎意料的返回（比如在字段值和期待值一样的时候却返回了false），不过在一些循环算法中，这是可以接受的。通常它比起strong有更高的性能。\n而strong的返回值能保证它是绝对符合预期的。\n结语本篇超长的博客到这里就结束辣！\n其实C++11还有其他的新特性，但是那些我会单开一篇文章来写~\n\n","categories":["遇见C++"],"tags":["C++","数据结构","C++11"]},{"title":"【C++】智能指针","url":"/posts/1282431418/","content":"终于来填坑了😂\n2022-10-19 -&gt; 2023-04-01\n\n1.情景对于C&#x2F;C++而言，内存泄漏是一个老生常谈的问题。每次进行new操作之后，我们都需要对其进行对应的delete，已避免内存泄漏。\n可代码一长，逻辑复杂起来了，想处理就没有那么容易了。\n1.1 代码太长，看不到头int main()&#123;\tint* arr1 = new int[10];\tint* arr2 = new int[10];\t//中间有超级多行代码    delete arr1[];    delete arr2[];&#125;\n\n我们日常的学习，可能写的代码并不是很多。但如果是一个大型的项目，new和delete之中可能隔了成千上万行代码，那时候还想去找这个变量的位置，可就不那么好找了。极其容易出现忘记delete的情况\n1.2 异常安全int func(int a,int b)&#123;    if(b==0)    &#123;        throw invalid_argument(&quot;除0错误&quot;);    &#125;    return a/b;&#125;void test()&#123;    int* arr1 = new int[10];\tint* arr2 = new int[10];\tfunc(1,0);//抛异常    delete[] arr1;    delete[] arr2;&#125;int main()&#123;\ttry&#123;         test();    &#125;   \tcatch(...)&#123;        cout &lt;&lt;&quot;出现异常&quot;&lt;&lt;endl;    &#125;    return 0;&#125;\n\n如上面的代码，在test函数中，调用了另外一个会抛出异常的函数。如果这个函数抛出了异常，后续的delete操作不会被执行，出现内存泄漏。\n如果操作的堆区变量较少，可以采用如下的方式来解决这个问题\nint func(int a,int b)&#123;    if(b==0)    &#123;        throw invalid_argument(&quot;除0错误&quot;);    &#125;    return a/b;&#125;void test()&#123;    int* arr1 = new int[10];\tint* arr2 = new int[10];\ttry&#123;        func(1,0);//抛异常    &#125;    catch(...)&#123;//接管异常    \t// 销毁        delete[] arr1;    \tdelete[] arr2;        throw;// 原样抛出    &#125;    delete[] arr1;    delete[] arr2;&#125;int main()&#123;\ttry&#123;         test();    &#125;   \tcatch(...)&#123;        cout &lt;&lt;&quot;出现异常&quot;&lt;&lt;endl;    &#125;    return 0;&#125;\n\n但是，这样并不能完全解决问题，因为new函数本身也有可能抛出异常！\nvoid test()&#123;    int* arr1 = new int[10];\tint* arr2 = new int[10];//这里抛异常了    // 此时无法被接管！    // arr1没有被析构，出现内存泄漏    \ttry&#123;        func(1,0);//抛异常    &#125;    catch(...)&#123;//接管异常    \t// 销毁        delete[] arr1;    \tdelete[] arr2;        throw;// 原样抛出    &#125;    delete[] arr1;    delete[] arr2;&#125;\n\n把new也丢到try里面？依旧不行（详见注释）\nvoid test()&#123;    try&#123;        int* arr1 = new int[10];        int* arr2 = new int[10];//这里抛异常了        int* arr3 = new int[10];\t        func(1,0);//抛异常    &#125;    catch(...)&#123;    \t// 你不知道哪一个出了异常！        // 假设arr2出异常，arr2和arr3都没有申请空间成功        // 怎么进行销毁？        delete[] arr1;    \tdelete[] arr2;        delete[] arr3;        throw;// 原样抛出    &#125;    delete[] arr1;    delete[] arr2;    delete[] arr3;&#125;\n\n而且，如果需要操作的new变量很多，那么在catch里面就需要加上多个delete，代码就显得过于重复了。\n为了解决这个问题，C++引入了智能指针\n2.智能指针2.1 RAIIRAII - Resource Acquisition is Initialization\n\n需要注意的是，RAII是一种思想，并不能用它来指代智能指针\nRAII != 智能指针\n\n它是一种利用对象的生命周期来控制程序资源（内存、文件句柄、网络链接、互斥量等）的技术\n\n只要是两步操作的，需要申请+释放的资源，都可以使用RAII的思想来进行处理。比如自己封装一个自动处理pthread_mutex锁的init和destory的类\n\n说人话就是，在对象构造的时候获取资源，析构的时候释放资源。\n\n在对象生命周期到了之后，会自动释放资源，免去了我们手动释放资源or忘记释放的繁琐\n资源在对象的生命周期内始终有效\n\n在大型项目中，一般都会用智能指针来管理堆区空间\n3.demo3.1 基础示例在认识不同类型的智能指针之前，先来看个最简单的demo\n#pragma oncenamespace mu &#123;\tusing std::cout;\tusing std::endl;\ttemplate&lt;class T&gt;\tclass SmartPtr\t&#123;\tpublic:\t\tSmartPtr(T* ptr)\t\t\t:_ptr(ptr)\t\t&#123;\t\t\tcout &lt;&lt; &quot;init &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;\t\t&#125;\t\t~SmartPtr()\t\t&#123;\t\t\tcout &lt;&lt; &quot;des  &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;\t\t\tdelete[] _ptr;\t\t&#125;\tprivate:\t\tT* _ptr;\t&#125;;&#125;\n\n上面实现的，就是一个最简单的智能指针。它可以帮助我们管理堆区上的数组。\n#define _CRT_SECURE_NO_WARNINGS 1//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &quot;demo.hpp&quot;using namespace std;void test1()&#123;\tmu::SmartPtr&lt;int&gt; p1(new int[10]);\tmu::SmartPtr&lt;char&gt; p4(new char[10]);\tmu::SmartPtr&lt;double&gt; p3(new double[10]);\tcout &lt;&lt; &quot;test&quot; &lt;&lt; endl;&#125;int main()&#123;\ttest1();\treturn 0;&#125;\n\n运行后，输出的结果如下\ninit 006697A8init 006724D0init 00668860testdes  00668860des  006724D0des  006697A8\n\n其实现了在构造中托管，在析构中销毁资源的操作。\n\n即便抛出异常，依旧能正常析构\n#include &lt;iostream&gt;#include &quot;demo.hpp&quot;using namespace std;int func(int a, int b)&#123;\tif (b == 0)\t&#123;\t\tthrow invalid_argument(&quot;除0错误&quot;);\t&#125;\treturn a / b;&#125;void test1()&#123;\tmu::SmartPtr&lt;int&gt; p1(new int[10]);\tmu::SmartPtr&lt;char&gt; p2(new char[10]);\tmu::SmartPtr&lt;double&gt; p3(new double[10]);\tcout &lt;&lt; &quot;test1&quot; &lt;&lt; endl;\ttry &#123;\t\tfunc(3, 0);\t&#125;\tcatch(...)&#123;\t\tthrow;\t&#125;\t\tcout &lt;&lt; &quot;test2&quot; &lt;&lt; endl;&#125;int main()&#123;\ttry &#123;\t\ttest1();\t&#125;\tcatch (...)\t&#123;\t\tcout &lt;&lt; &quot;mian  出现异常&quot; &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n注意，如果抛出异常又不进行catch，程序会被abort终止，无法观测到现象。\n以下是运行的结果，可以看到异常出现后，走到了test1函数的生命周期末尾，释放了3个指针，才被main中的catch捕获\ninit 012B8F00init 012C3010init 012B8860test1des  012B8860des  012C3010des  012B8F00mian  出现异常\n\n3.2 运算符重载当然，这个智能指针还是却少很多东西的\n\n写死了delete[]，我只想让她管理单个变量怎么办？\n如何获取指针内的资源？\n\n第一个问题我们暂且不提（后续讲解库中智能指针的时候会说明）第二个问题的答案便是：重载*和-&gt;操作符\nT&amp; operator*()&#123;    return *_ptr;&#125;T* operator-&gt;()&#123;    return _ptr;&#125;T&amp; operator[](const T&amp; n)&#123;    return _ptr[n];&#125;\n\n重载了之后，我们就可以操作类内的指针成员了\nvoid test1()&#123;\tmu::SmartPtr&lt;int&gt; p1(new int[10]);\tmu::SmartPtr&lt;char&gt; p2(new char[10]);\tmu::SmartPtr&lt;double&gt; p3(new double[10]);\tcout &lt;&lt; &quot;test&quot; &lt;&lt; endl;\tp2[0] = &#x27;a&#x27;;\tp2[1] = &#x27;b&#x27;;\tp2[2] = &#x27;\\0&#x27;;\tcout &lt;&lt; p2[0] &lt;&lt;&quot; &quot;&lt;&lt; p2[1] &lt;&lt; endl;\tcout &lt;&lt; *p2 + 1 &lt;&lt; endl;&#125;\n\n运行结果如下\ninit 01661C30init 01671748init 016689B8testa b98des  016689B8des  01671748des  01661C30\n\n3.3 拷贝对于智能指针而言，有一个很重要的问题是针对拷贝的。在一些场景中，我们需要对指针进行拷贝，这时候就会出现异常\nvoid test3()&#123;\tmu::SmartPtr&lt;int&gt; p1(new int[10]);\tmu::SmartPtr&lt;int&gt; p2(p1);&#125;\n\n运行结果如下\ninit 00BBFB20des  00BBFB20des  00BBFB20\n\n编译器报错了\n\n原因就是，默认的拷贝构造使用的是浅拷贝，再析构的时候，两个智能指针对同一个地址析构，相当于析构了两次，肯定是不行的！\n接下来，就让我们看看cpp库中是怎么解决这个问题的吧！\n4.auto_ptr为了避免拷贝的时候，导致多次析构，C++98库函数中提供了auto_ptr。在拷贝的时候，auto_ptr采用的是管理权转移的思路\nauto_ptr&lt;int&gt;  sp1(new int);//无法继续使用auto_ptr&lt;int&gt;  sp2 = sp1;//sp2接管了sp1\n\n当我们这样操作了之后，sp1对象将不能再被使用，其内置指针会被置为nullptr，使用相当于解引用空指针！\n因为这个操作实在太坑人了，如果在某些函数传参的时候，进行值拷贝了，就会导致原有的指针失效，从而引发程序错误。\n所以，在C++11之后，应避免使用auto_ptr（一些公司会明令禁止使用）\n5.unique_ptr\n在boost库中，有一个scpoed_ptr，其就是unique_ptr的前身\n\nunique的做法更绝，既然拷贝会出现问题，那我直接不允许你拷贝不就行了？\n直接将拷贝构造和赋值重载给delete了，即禁止对方使用拷贝。\nunique_ptr(const unique_ptr&lt;T&gt;&amp; n) = delete;unique_ptr&lt;T&gt;&amp; operator=(const unique_ptr&lt;T&gt;&amp; n) = delete;\n\n如果是C++11之前，可以采用只声明不实现的方式来禁用拷贝构造。为了避免使用者自己写一个拷贝构造，我们需要将其配置为私有。\nprivate://只声明不实现  unique_ptr(const unique_ptr&lt;T&gt;&amp; n);  unique_ptr&lt;T&gt;&amp; operator=(const unique_ptr&lt;T&gt;&amp; n);\n\n虽然unique_ptr从源头解决了拷贝的问题，但是它有一个小问题：功能不全。\n如果我真的需要拷贝呢？你这个岂不是用不了呀。\n6.shared_ptrshare即分享，这个智能指针是支持拷贝的。那它应该如何解决同一片空间被释放多次的问题呢？\n6.1 引用计数为了保证资源只会被释放一次，其采用了引用计数的方式来实现。\n\n初始化的时候，引用计数为1\n每次拷贝，引用计数都+1（包括拷贝构造和赋值重载）\n析构的时候，引用计数不为1，将计数器-1\n只有引用计数为1，才在析构的时候释放资源\n\n这样就解决了被析构多次的问题！\n6.2 如何实现？\n直接使用一个成员变量？\n\n不行，一个对象的修改不影响第二个对象的成员，依旧会出现析构多次的问题。\n\n使用static成员？\n\nstatic成员属于整个类，这样弄相当于给这个类加了个已有对象数量的计数器，南辕北辙。\nT* _ptr;int* _pcount;//计数器\n\n我们只需要在对象中添加一个int类型的指针，在第一次初始化对象的时候，给这个指针创建堆区的int空间，并初始化为1\n这样每次拷贝、赋值的时候，都给这个pcount指向的int给+1\n(*_pcount)++\n\n每次析构的时候都-1，只有为0的时候，才进行资源释放。同时释放指针托管的资源，和pcount\n(*_pcount)--;//先将自己的-1if((*_pcount==0))//如果为0，则代表自己是最后一个&#123;//释放自己的资源    delete _ptr;    delete _pcount;&#125;\n\n6.3 赋值赋值有两种情况\nshared_ptr&lt;int&gt; sp1(new int(1));shared_ptr&lt;int&gt; sp2; sp2 = sp1;//情况1shared_ptr&lt;int&gt; sp3(new int(3));sp1 = sp3;//情况2shared_ptr&lt;int&gt; sp4 = sp1;//实际上调用的是拷贝构造 \n\n第一种 是对象没有初始化，调用了默认无参构造函数，其内部托管的指针是nullptr，sp2=sp1，相当于是初始化sp2对象。\n第二种 是对象已经初始化了，但是我想让他管理另外一份资源。\n\n针对情况1，操作和拷贝构造相同，我们只需要赋值给sp2后，将引用计数加+1即可\n针对情况2，我们就需要判断sp1的情况了。如果sp1的引用计数为1，则需要先销毁sp1托管的空间，再进行赋值。并将sp3的引用计数赋值给sp1，并将sp3的引用计数+1\n\n落到代码上，应该如下\nshared_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; p)&#123;    if(p._ptr == _ptr)//指向的空间相同    &#123;        return *this;//啥都不做    &#125;    (*_pcount)--;//先将自己的-1    if((*_pcount==0))//如果为0，则代表自己是最后一个    &#123;//释放自己的资源        delete _ptr;        delete _pcount;    &#125;    //赋值对方的资源    _ptr = p._ptr;    _pcount = p._pcount;    (*_pcount)++;//引用计数+1        return *this;&#125;\n\n6.4 简单实现库中的实现更为复杂，其还重载了&lt;&lt;操作符，实现了更多成员函数\ntemplate&lt;class T&gt;   class shared_ptr   &#123;       public:           shared_ptr(T* ptr = nullptr)               :_ptr(ptr),           _pcount(new int(1))           &#123;               cout &lt;&lt; &quot;[init] &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;           &#125;           //拷贝构造           shared_ptr(const shared_ptr&lt;T&gt;&amp; p)           &#123;               cout &lt;&lt; &quot;[copy] &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;               _ptr = p._ptr;               _pcount = p._pcount;               (*_pcount)++;//引用计数+1           &#125;           //赋值重载           shared_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; p)           &#123;               cout &lt;&lt; &quot;[operator=] &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;               if (p._ptr == _ptr)//指向的空间相同               &#123;                   return *this;//啥都不做               &#125;               //释放自己的资源（判断）               _Release();               //赋值对方的资源               _ptr = p._ptr;               _pcount = p._pcount;               (*_pcount)++;//引用计数+1               return *this;           &#125;           T&amp; operator*()           &#123;               return *_ptr;           &#125;           T* operator-&gt;()           &#123;               return _ptr;           &#125;           T&amp; operator[](const T&amp; n)           &#123;               return _ptr[n];           &#125;       \tT* get()           &#123;               return _ptr;           &#125;           ~shared_ptr()           &#123;               _Release();           &#125;       private:           void _Release()           &#123;               (*_pcount)--;               cout &lt;&lt; &quot;[des] pcount:&quot; &lt;&lt; (*_pcount) &lt;&lt; &quot; ptr:&quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;               if ((*_pcount) == 0)               &#123;                   cout &lt;&lt; &quot;[des] delete &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl; // 如果释放了资源，会打印这个                   if(_ptr)//_ptr不为空的时候才释放它                       delete _ptr;                   //无论什么时候都需要删除计数器，否则会有内存泄漏                   delete _pcount;               &#125;           &#125;       T* _ptr;       int* _pcount;//引用计数   &#125;;\n\n6.5 测试用如下代码进行测试\nvoid test4()&#123;\tmu::shared_ptr&lt;int&gt; p1(new int(10));\tmu::shared_ptr&lt;int&gt; p2(p1);\tmu::shared_ptr&lt;int&gt; p3 = p1;//实际上调用的是拷贝构造\tcout &lt;&lt; &quot;p1 &quot; &lt;&lt; (*p1) &lt;&lt; endl;\tcout &lt;&lt; &quot;p2 &quot; &lt;&lt; (*p2) &lt;&lt; endl;\tcout &lt;&lt; &quot;p3 &quot; &lt;&lt; (*p3) &lt;&lt; endl;\tmu::shared_ptr&lt;int&gt; p4;\tp4 = p1;\tcout &lt;&lt; &quot;p4 &quot; &lt;&lt; (*p4) &lt;&lt; endl;\tmu::shared_ptr&lt;int&gt; p5(new int(20));\tp1 = p5;\tcout &lt;&lt; &quot;p1 &quot; &lt;&lt; (*p1) &lt;&lt; endl;\tcout &lt;&lt; &quot;p5 &quot; &lt;&lt; (*p5) &lt;&lt; endl;&#125;\n\n运行的结果如下\n[init] 00BE0B10[copy] 00000000[copy] 00000000p1 10p2 10p3 10[init] 00000000[operator=] 00000000[des] pcount:0 ptr:00000000[des] delete 00000000p4 10[init] 00BD8B30[operator=] 00BE0B10[des] pcount:3 ptr:00BE0B10p1 20p5 20[des] pcount:1 ptr:00BD8B30[des] pcount:2 ptr:00BE0B10[des] pcount:1 ptr:00BE0B10[des] pcount:0 ptr:00BE0B10[des] delete 00BE0B10[des] pcount:0 ptr:00BD8B30[des] delete 00BD8B30\n\n可以看到，每次析构，实际上都会先对引用计数进行-1的操作，只有引用计数为0的情况下，才会真的析构掉对应的值。\n赋值的时候，也没有出现内存泄漏的问题！\nvoid test5()&#123;\tmu::shared_ptr&lt;int&gt; p1(new int(10));\tmu::shared_ptr&lt;int&gt; p2(new int(20));\tcout &lt;&lt; &quot;p1 &quot; &lt;&lt; (*p1) &lt;&lt; endl;\tcout &lt;&lt; &quot;p2 &quot; &lt;&lt; (*p2) &lt;&lt; endl;\tp1 = p2;\tcout &lt;&lt; &quot;p1 &quot; &lt;&lt; (*p1) &lt;&lt; endl;\tcout &lt;&lt; &quot;p2 &quot; &lt;&lt; (*p2) &lt;&lt; endl;&#125;\n\np2在赋值给p1之前，先析构了p1维护的变元，才进行了赋值操作\n[init] 014DF1B8[init] 014D89A8p1 10p2 20[operator=] 014DF1B8[des] pcount:0 ptr:014DF1B8[des] delete 014DF1B8p1 20p2 20[des] pcount:1 ptr:014D89A8[des] pcount:0 ptr:014D89A8[des] delete 014D89A8\n\n6.6 线程安全问题在实际应用场景中，可能会出现多线程对该指针进行拷贝的问题。为了避免引用计数pcount在多线程拷贝的时候出现二义性问题，需要对引用计数的操作进行加锁\n详见 https://blog.musnow.top/posts/1249427441/ 的 12.shared_ptr\n6.7 循环引用问题shared_ptr的引用计数可能会出现循环引用的问题，它需要用weak_ptr来解决。后文会提到\n7.weak_ptr7.1 简介这个指针是专门用来辅助解决shared_ptr循环引用问题的，可以认为它是shared_ptr的小弟。\n//default (1)\tconstexpr weak_ptr() noexcept;//copy (2)\tweak_ptr (const weak_ptr&amp; x) noexcept;template &lt;class U&gt; weak_ptr (const weak_ptr&lt;U&gt;&amp; x) noexcept;//from shared_ptr (3)\ttemplate &lt;class U&gt; weak_ptr (const shared_ptr&lt;U&gt;&amp; x) noexcept;//copy (1)\tweak_ptr&amp; operator= (const weak_ptr&amp; x) noexcept;template &lt;class U&gt; weak_ptr&amp; operator= (const weak_ptr&lt;U&gt;&amp; x) noexcept;//from shared_ptr (2)\ttemplate &lt;class U&gt; weak_ptr&amp; operator= (const shared_ptr&lt;U&gt;&amp; x) noexcept;\n\n相比于其他智能指针的构造函数，weak_ptr只能进行拷贝，或从一个shared_ptr来构造。\n它最大的特点就是：只托管资源，不处理引用计数，析构时也不进行资源释放。可以认为，它只是对指针进行了简单的封装。\n这个特性也决定了，weak_ptr不能使用原生指针来构造！\n7.2 什么是循环引用struct ListNode&#123;\tListNode* _prev;\tListNode* _next;\tT _val;\tListNode(const T&amp; val=T())\t\t:_prev(nullptr),\t\t_next(nullptr),\t\t_val(val)\t&#123;\t\tcout &lt;&lt; &quot;[ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;\t~ListNode()\t&#123;\t\tcout &lt;&lt; &quot;[~ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;&#125;;void test6()&#123;\tmu::shared_ptr&lt;ListNode&lt;int&gt;&gt; p1(new ListNode&lt;int&gt;(10));\tmu::shared_ptr&lt;ListNode&lt;int&gt;&gt; p2(new ListNode&lt;int&gt;(20));\t&#125;\n\n上面这个代码是一个最简单的双链表，在没有给链表内节点赋值之前，它是没有问题的。使用智能指针能成功调用对象的析构，并销毁空间\n[ListNode()] 00DE10E0[init] 00DE10E0[ListNode()] 00DE14D0[init] 00DE14D0[des] pcount:0 ptr:00DE14D0[des] delete 00DE14D0[~ListNode()] 00DE14D0[des] pcount:0 ptr:00DE10E0[des] delete 00DE10E0[~ListNode()] 00DE10E0\n\n\n但如果想要将这两个节点链接起来，那就出bug了\n首先，自然是我们没办法将一个智能指针赋值给普通的指针，因为类型不同。我们也不能直接对它们进行强转\n\n解决这个问题，那就是将listnode中的指针成员也改成智能指针\n// 链表节点template&lt;class T&gt;struct ListNode&#123;\tmu::shared_ptr&lt;ListNode&lt;T&gt;&gt; _prev;\tmu::shared_ptr&lt;ListNode&lt;T&gt;&gt; _next;\tT _val;\tListNode(const T&amp; val=T())\t\t:_prev(nullptr),\t\t_next(nullptr),\t\t_val(val)\t&#123;\t\tcout &lt;&lt; &quot;[ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;\t~ListNode()\t&#123;\t\tcout &lt;&lt; &quot;[~ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;&#125;;void test6()&#123;\tmu::shared_ptr&lt;ListNode&lt;int&gt;&gt; p1(new ListNode&lt;int&gt;(10));\tmu::shared_ptr&lt;ListNode&lt;int&gt;&gt; p2(new ListNode&lt;int&gt;(20));\tp1-&gt;_next = p2;\tp2-&gt;_prev = p1;&#125;\n\n再次运行，诶，出问题了！\n[init] 00000000[init] 00000000[ListNode()] 00FFF1B8[init] 00FFF1B8[init] 00000000[init] 00000000[ListNode()] 00FF8D78[init] 00FF8D78[operator=] 00000000[des] pcount:0 ptr:00000000[operator=] 00000000[des] pcount:0 ptr:00000000[des] pcount:1 ptr:00FF8D78[des] pcount:1 ptr:00FFF1B8\n\n可以看到，虽然shared_ptr的析构函数被调用了，但直到最后，都没有打印出[des] delete，也没有进入ListNode的析构函数，即出现了内存泄漏！\nvoid _Release()&#123;    (*_pcount)--;    cout &lt;&lt; &quot;[des] pcount:&quot; &lt;&lt; (*_pcount) &lt;&lt; &quot; ptr:&quot; &lt;&lt; (void*)_ptr &lt;&lt; endl;    if ((*_pcount) == 0)    &#123;        cout &lt;&lt; &quot;[des] delete &quot; &lt;&lt; (void*)_ptr &lt;&lt; endl; // 如果释放了资源，会打印这个        if(_ptr)//_ptr不为空的时候才释放它            delete _ptr;        //无论什么时候都需要删除计数器，否则会有内存泄漏        delete _pcount;    &#125;&#125;\n\n画个图，看看到底是为甚\n\np1管理资源A，p2管理资源B；二者引用计数都为1\np1-&gt;next&#x3D;p2，p1-&gt;next也开始管理资源B，引用计数为2\np2-&gt;prev&#x3D;p1，p2-&gt;prev也开始管理资源A，引用计数为2\n出作用域，先析构p2，B引用计数-1，此时资源B是只由p1-&gt;next管理的\n后析构p1，A引用计数-1，此时资源A是只由p2-&gt;prev管理\n但是p1-&gt;next必须要完全析构资源A才会被释放；同理，p2-&gt;prev也需要完全析构资源B才会释放\n\n这时候就陷入了一个死循环，因为资源A和资源B实际上已经没有外人在使用了，它们也无法被彻底释放掉，内存泄漏了！\n\n7.3 解决循环引用问题讲到这里，如何解决这个问题，就很明了了。因为weak_ptr是不进行引用计数的操作的，其只对资源进行托管。我们只需要将listnode之中的指针从shared_ptr改为weak_ptr即可\ntemplate&lt;class T&gt;struct ListNode&#123;\t/*mu::shared_ptr&lt;ListNode&lt;T&gt;&gt; _prev;\tmu::shared_ptr&lt;ListNode&lt;T&gt;&gt; _next;*/\tstd::weak_ptr&lt;ListNode&lt;T&gt;&gt; _next;\tstd::weak_ptr&lt;ListNode&lt;T&gt;&gt; _prev;\tT _val;\tListNode(const T&amp; val=T())\t\t:_val(val)\t&#123;\t\tcout &lt;&lt; &quot;[ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;\t~ListNode()\t&#123;\t\tcout &lt;&lt; &quot;[~ListNode()] &quot; &lt;&lt; (void*)this &lt;&lt; endl;\t&#125;&#125;;void test6()&#123;\tstd::shared_ptr&lt;ListNode&lt;int&gt;&gt; p1(new ListNode&lt;int&gt;(10));\tstd::shared_ptr&lt;ListNode&lt;int&gt;&gt; p2(new ListNode&lt;int&gt;(20));\tp1-&gt;_next = p2;\tp2-&gt;_prev = p1;&#125;\n\n可以看到，这时候就能成功释放节点了！\n[ListNode()] 0117F348[ListNode()] 01171950[~ListNode()] 01171950[~ListNode()] 0117F348\n\n7.4 简单实现库里面的实现比我们这个复杂很多，实现只是为了理解设计思路\ntemplate&lt;class T&gt;class weak_ptr&#123;public:\tweak_ptr()\t\t:_ptr(nullptr)\t&#123;&#125;\t//构造\tweak_ptr(const shared_ptr&lt;T&gt;&amp; p)\t\t:_ptr(p.get())\t&#123;\t\t_ptr;\t&#125;\t//拷贝构造\tweak_ptr(const weak_ptr&lt;T&gt;&amp; p)\t\t:_ptr(p._ptr)\t&#123;&#125;\t//赋值重载\tweak_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; p)\t&#123;\t\t_ptr = p.get();\t\treturn *this;\t&#125;\tweak_ptr&lt;T&gt;&amp; operator=(const weak_ptr&lt;T&gt;&amp; p)\t&#123;\t\t_ptr = p._ptr;\t\treturn *this;\t&#125;\tT&amp; operator*()\t&#123;\t\treturn *_ptr;\t&#125;\tT* operator-&gt;()\t&#123;\t\treturn _ptr;\t&#125;\tT&amp; operator[](const T&amp; n)\t&#123;\t\treturn _ptr[n];\t&#125;private:\tT* _ptr;&#125;;\n\n自己也实现一个简单的weak_ptr，还是用相同的代码进行测试，可以看到，成功进行了析构\n[ ListNode()] 00C903C8[init] 00C903C8[ ListNode()] 00C90128[init] 00C90128[des] pcount:0 ptr:00C90128[des] delete 00C90128[~ListNode()] 00C90128[des] pcount:0 ptr:00C903C8[des] delete 00C903C8[~ListNode()] 00C903C8\n\n7.5 成员函数对库中实现的weak_ptr的成员函数做一定解释\nvoid swap (weak_ptr&amp; x) noexcept; // 交换两个weak_ptr托管的指针void reset() noexcept;// 重置 (相当于恢复成默认构造的对象)long int use_count() const noexcept; // 返回weak_ptr管理的空间的引用计数（本身不计入）bool expired() const noexcept; // 判断weak_ptr是否已经过期（即用于构造这个weak_ptr的shared_ptr是否已经释放资源）// 因为weak_ptr不参与资源的管理，只进行托管。所以如果shared_ptr已经将空间释放，那么weak_ptr指向的空间就已经过期了，不能继续使用shared_ptr&lt;element_type&gt; lock() const noexcept;// 如果weak_ptr没有过期/不为空，则返回其托管的shared_ptr对象// 等效于返回 expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this) // 该函数具有原子性// https://legacy.cplusplus.com/reference/memory/weak_ptr/lock/// 说实话，这个函数的作用看的不是很懂。下面这个函数就更看不懂了template &lt;class U&gt; bool owner_before (const weak_ptr&lt;U&gt;&amp; x) const;template &lt;class U&gt; bool owner_before (const shared_ptr&lt;U&gt;&amp; x) const;//https://blog.csdn.net/weixin_45590473/article/details/113040456\n\n8.定制删除器对于我们自己写的shared_ptr，有一个问题就是，析构的时候，默认是写死的delete；\n如果用户传入的是一个数组new int[10]，此时delete就不对应（需要用delete[])，会出现问题（但不一定会报错）\n还有些情况，我们想给智能指针传入一个文件指针，此时就不能用delete来进行资源释放了。为了避免这些情况，智能指针引入了定制删除器\n8.1 unique_ptr和shared_ptr的不同用法//non-specialized\ttemplate &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;//array specialization\ttemplate &lt;class T, class D&gt; class unique_ptr&lt;T[],D&gt;;\n\n比如库中unique_ptr的模板参数中，就有一个模板参数D用于接收用户传入的删除器。而shared_ptr则是采用在构造函数中传入删除器对象的方式来实现定制删除\n//with deleter (4)\ttemplate &lt;class U, class D&gt; shared_ptr (U* p, D del);template &lt;class D&gt; shared_ptr (nullptr_t p, D del);\n\n库中默认的删除器如下\n//non-specialized\ttemplate &lt;class T&gt; class default_delete;//array specialization\ttemplate &lt;class T&gt; class default_delete&lt;T[]&gt;;\n\n内部采用了重载操作符()的办法，来实现仿函数。默认情况下，使用的是delete，如果指定了是数组类型，则会使用delete[]\n\n如果我们要处理的是文件指针或者malloc的值，就只需要自己传入一个仿函数（定制删除器）即可\n8.2 使用这里我定制了一个free的删除器，和文件指针fclose的删除器\ntemplate&lt;class T&gt;struct Free&#123;\tvoid operator()(T* ptr)\t&#123;\t\tcout &lt;&lt; &quot;[free]  &quot; &lt;&lt; ptr &lt;&lt; endl;\t\tfree(ptr);\t&#125;&#125;;struct Fclose&#123;\tvoid operator()(FILE* ptr)\t&#123;\t\tcout &lt;&lt; &quot;[fclose] &quot; &lt;&lt; ptr &lt;&lt; endl;\t\tfclose(ptr);\t&#125;&#125;;\n\n用如下代码进行测试\nunique_ptr&lt;int, default_delete&lt;int[]&gt;&gt; up1(new int[10]);unique_ptr&lt;ListNode&lt;int&gt;, default_delete&lt;ListNode&lt;int&gt;[]&gt;&gt; up2(new ListNode&lt;int&gt;[2]);unique_ptr&lt;FILE, Fclose&gt; up3((FILE*)fopen(&quot;test.cpp&quot;, &quot;r&quot;));unique_ptr&lt;ListNode&lt;int&gt;, Free&lt;ListNode&lt;int&gt;&gt;&gt; up4((ListNode&lt;int&gt;*)malloc(sizeof(ListNode&lt;int&gt;)));\n\n可以看到，成功进行了ListNode数组的销毁，以及malloc、文件指针的free、关闭操作\n[ ListNode()] 011D5B7C[ ListNode()] 011D5B88[free]  011E1070[fclose] 011D89A8[~ListNode()] 011D5B88[~ListNode()] 011D5B7C\n\n需要注意的是，malloc创建的ListNode&lt;int&gt;空间并不会调用ListNode的构造函数，free也不会调用析构函数\n\n因为shared_ptr需要采用类对象的方式在构造函数中进行传参。这方面的底层实现有些复杂。随之而来的好处就是我们可以直接传入一个lambda表达式来作为删除器，避免了代码冗长之后，找不到想要的删除器的定义的问题。\n// shared_ptr需要采用传入对象的方式default_delete&lt;ListNode&lt;int&gt;[]&gt; d1;shared_ptr&lt;ListNode&lt;int&gt;&gt; sp1(new ListNode&lt;int&gt;[3], d1);cout &lt;&lt; &quot;###########################&quot; &lt;&lt; endl;shared_ptr&lt;ListNode&lt;int&gt;&gt; sp2(new ListNode&lt;int&gt;[3], [](ListNode&lt;int&gt;* ptr)&#123;delete[] ptr; &#125;);\n\n运行结果如下\n[ ListNode()] 0127F1BC[ ListNode()] 0127F1C8[ ListNode()] 0127F1D4###########################[ ListNode()] 01278D4C[ ListNode()] 01278D58[ ListNode()] 01278D64[~ListNode()] 01278D64[~ListNode()] 01278D58[~ListNode()] 01278D4C[~ListNode()] 0127F1D4[~ListNode()] 0127F1C8[~ListNode()] 0127F1BC\n\n9.总结\n\n\n智能指针\n拷贝特点\n定制删除器\n\n\n\nauto_ptr(C++98)\n管理权转移。复制后，原有对象失效\n-\n\n\nunique_ptr(scpoed_ptr)\n禁止拷贝\n使用模板参数来传入定制删除器\n\n\nshared_ptr\n支持拷贝，采用引用计数，但是会有循环引用问题\n在构造函数中传入删除器对象\n\n\nweak_ptr\n支持拷贝，只用于托管指针，不参与指针空间的释放，不计入引用计数。用于解决循环引用问题\n-\n\n\nThe end智能指针的基本用法到这里就over了，了解智能指针的同时，需要熟知RAII思想。在不少类的设计中，都会用到这个思想。\n","categories":["遇见C++"],"tags":["C++","类和对象"]},{"title":"【C++】文件IO流","url":"/posts/520771444/","content":"一起来康康C++中的文件IO操作吧\n\n\n[TOC]\n1.operator bool之前写OJ的时候，就已经用过上面这种方式来获取多组测试用例\nstring s;while(cin&gt;&gt;s)&#123;\tcout &lt;&lt; s &lt;&lt; endl;&#125;\n\n不过之前一直没有去了解这里的底层原理是什么，借此机会一并说明\nio流可以进行while判断的依据，是因为库的源码中重载了operator bool\n\n没错，operator不仅可以重载一个操作符，它还可以重载一个类型！即将这个类转换为bool类型，return 一个bool类型的值用于while的判断\n同理，重载int/double这些类型都是可行的！\n\n另外，要想停止上面的多组输入，在VS下可以用ctrl+z的方式解决，而不要用ctrl+c直接杀掉进程\n\n\n2.C++文件IO流\nC++的文件io类设计的较为复杂，其中还出现了菱形继承，也就是我们最常用的iostream\n上面提到的operator bool就是基类IOS实现的，子类都没有去重写\n\ncout为标准输出，将数据从内存流中输入到显示器上\ncin为标准输入，通过键盘输入数据到程序中\ncerr用于标准错误的输出\nclog进行日志输出\n\n其中需要注意的一点是，空格和回车会被当作数据之间的分隔符，所以字符串中不能有空格，回车和空格也不能通过cin读入\n如果需要读入带空格的完整一行，可以使用getline函数\n\n为什么cin和cout可以输入输出所有类型？\n\n因为库里面已经将所有类型通过操作符重载&lt;&lt; 和&gt;&gt;实现了，达到了自动类型识别的效果\n3.文件操作C++标准库中提供的打开方式如下，我们可以根据不同情况传入不同的值，或者一次性用按位或|传入多个打开方法\n\n同时因为C++类和对象会自动调用析构函数，所以我们也不需要手动close文件\n3.0 关于按位与的说明这里为何可以用按位与传入多个方法？\n假设这些方法就是简单的数字2/4/8（必须是2的倍数）我们可以通过按位与了之后，在按位或，判断某一个数字是否在其中\n\n如果或了之后的数字等于它本身，说明数据在其中！\n\n为什么需要是2的倍数呢？\n\n\n\n这种方法在linux中常见，比如linux系统的文件接口\n\n3.1 ifstream\n这个对象是用于读取文件的，默认情况下，传入的打开方法为in\nvoid test1()&#123;\tifstream ifs(&quot;test.txt&quot;);\twhile (ifs)\t&#123;\t\tchar ch = ifs.get();\t\tcout &lt;&lt; ch;\t&#125;&#125;\n\n\n因为重载了bool，所以可以很方便的直接用while来判断结束，成功输出了文件中的内容\nifstream ifs(&quot;test.txt&quot;);char ch;while (ifs &gt;&gt; ch)&#123;\tcout &lt;&lt; ch;&#125;\n\n第二种读取方法采用了流插入&gt;&gt;上面提到过，流提取和插入的时候，会把空格和换行当作数据的分隔符，所以它是不能打印出空格和换行\n\n3.2 ofstream\n写文件的方式同上，用out方法打开文件就可以了（默认传的就是out）\nofstream ifs2(&quot;test1.txt&quot;,ios::out);char str[] = &quot;i love u\\n&quot;;ifs2.write(str,sizeof(str));\n\n\n不过这个和C语言的w方法一样，写入的时候会覆盖文件中已有的内容。如果想进行追加，则需要在后面加上app；如果是执行二进制读写，则需要与上ios::binary\nofstream ifs2(&quot;test1.txt&quot;,ios::out|ios::app);char str[] = &quot;i love u&quot;;ifs2.write(str,sizeof(str));\n\n\n运行成功后会在文件尾部追加内容\n注意，这里的字符串不能用string进行处理，因为string内部只存了一个指向字符串空间的指针，写入string相当于把指针写入进文件中，是么有用的！\n\n流插入文本但是，如果我们用&lt;&lt;进行提取的时候，就可以用string了\nvoid test2()&#123;\tifstream ifs(&quot;test.txt&quot;);\tofstream ofs(&quot;test1.txt&quot;);\tchar ch;\tch = ifs.get();\twhile (~ch)\t&#123;\t\tofs &lt;&lt; ch;\t\tcout &lt;&lt; ch;\t\tch = ifs.get();\t&#125;\tstring s(&quot;i love you&quot;);\tofs &lt;&lt; s;&#125;\n\n程序运行后，会把test.txt中的内容输出到控制台，同时写入到test1.txt\n最后还会写入一个string的内容\n\n这是因为我们调用&lt;&lt;的时候，就和cin&lt;&lt;s一样，调用的是string重载的流提取操作符\n底层实现的时候会将其转为C语言的字符串，从而写入到了文件中\n\n所以当我们需要写入一个自定义类型的时候，可以重载流提取操作符，不仅可以更方便的打印，还可以写入到文件中\n\n\n3.3 ostringstream&#x2F;istringstream这个类可以将不同的类型转为字符串\n这种操作被称为序列化和反序列化，在处理自定义类型的时候非常好用\nstruct Date&#123;public:\tfriend ostream&amp; operator &lt;&lt; (ostream&amp; out, const Date&amp; d);\tfriend istream&amp; operator &gt;&gt; (istream&amp; in, Date&amp; d);\tDate(int y=0, int m=0, int d=0)\t&#123;\t\t_year = y;\t\t_month = m;\t\t_day = d;\t&#125;private:\tint _year;\tint _month;\tint _day;&#125;;istream&amp; operator &gt;&gt; (istream&amp; in, Date&amp; d)&#123;\tin &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;\treturn in;&#125;ostream&amp; operator &lt;&lt; (ostream&amp; out, const Date&amp; d)&#123;\tout &lt;&lt; d._year &lt;&lt; &quot; &quot; &lt;&lt; d._month &lt;&lt; &quot; &quot; &lt;&lt; d._day;\treturn out;&#125;void test4()&#123;\tint i = 123;\tdouble d = 44.55;\tostringstream oss;//序列化\toss &lt;&lt; i;\tstring stri = oss.str();\toss.str(&quot;&quot;);//清空oss\toss &lt;&lt; d;\tstring strd = oss.str();\tcout &lt;&lt; strd&lt;&lt; endl;\toss.str(&quot;&quot;);//清空oss\tDate d1(2022, 10, 11);\toss &lt;&lt; d1;\tstring strdt = oss.str();\tcout &lt;&lt; strdt &lt;&lt; endl;\tistringstream iss(strdt);//反序列\tDate d2;\tiss &gt;&gt; d2;\tcout &lt;&lt; d2 &lt;&lt; endl;&#125;\n\n\n3.4 stringstream这个对象可以用于字符串拼接，也可以用来将其他类型转为str\nstringstream sstream;// 将多个字符串放入 sstream 中sstream &lt;&lt; &quot;first&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;string,&quot;;sstream &lt;&lt; &quot; second string&quot;;cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;// 清空 sstreamsstream.str(&quot;&quot;);sstream &lt;&lt; &quot;third string&quot;;cout &lt;&lt; endl;cout &lt;&lt; &quot;After clear, strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;\n\n\n3.5使用stringstream的注意事项\nstringstream实现转换，实际上是维护了一个string对象实现的\n\n我们可以使用str(&quot;&quot;)清空里面的string对象，设置为空字符串\n\n多次数据类型转换的时候，需要用clear()来清空，才能正确转换。不过clear()不会清空底层的string对象\n\n因为使用的是string对象，所以使用的时候不需要格式化控制，可以自动推导类型\n\n\nstringstreams在转换结尾时(即最后一个转换后),会将其内部状态设置为badbit因此下一次转换是必须调用clear()将状态重置为goodbit才可以继续转换\n\n这里在第一次调用stringstream操作后，我们没有进行clear，会发现后续的double类型转换失败了\n\n执行了clear之后，转换成功！\n结语关于C++IO流操作的基本认识到这里就over了。\n因为在实际中用的并不算多，所以这部分的内容大多数是了解一二，知道如何使用，以及3.0中提到的按位与操作是怎么实现的就OK了！\n","categories":["遇见C++"],"tags":["文件","C++"]},{"title":"【C++】特殊类设计 | 单例模式","url":"/posts/3618449948/","content":"本篇博客让我们来康康一些特殊类的实现方式！\n\n\n1.不支持拷贝的类在一些场景下，比如智能指针、多线程操作、IO流等是不支持拷贝的。因为它们的拷贝会导致一些问题，秉着解决不了问题，就解决提出问题的人的思路，禁止了这些类的拷贝\nC++98中，可以将拷贝构造和=重载只声明不定义，并将其访问权限设置为私有\n\n设置为私有可以防止其他人在类外定义\n\nC++11中，提供了一个特殊的关键字delete来禁止实现拷贝构造和 =重载\n// 禁止拷贝的类class BanCopy&#123;public:\t//构造\tBanCopy()\t&#123;\t\t_a = _b = 0;\t&#125;\t\t//C++11\tBanCopy(const BanCopy&amp; c) = delete;\tBanCopy&amp; operator=(const BanCopy&amp; c) = delete;private:\t//C++98的办法，声明为私有且不定义\t//BanCopy(const BanCopy&amp; c);\t//BanCopy&amp; operator=(const BanCopy&amp; c);\t\tint _a;\tint _b;&#125;;\n\n\n2.只能在堆上创建的类操作方法和上面的思路类似，只需要把构造函数私有化就可以了\n\n同时还需要取消拷贝构造，否则可以用拷贝构造在栈上开一个新的对象\n赋值重载不一定需要取消，因为赋值重载无法创建新对象\n\n// 只能在堆上开辟class HeapOnly &#123;public:\tstatic HeapOnly* CreatObj(int a,int b)\t&#123;\t\treturn new HeapOnly(a, b);\t&#125;private:\t// 构造函数私有\tHeapOnly()\t\t:_a(0),\t\t_b(0)\t&#123;&#125;\tHeapOnly(int a,int b)\t\t:_a(a),\t\t_b(b)\t&#123;&#125;\t// 同时拷贝构造也需要私有，禁止拷贝创建对象\tHeapOnly(const HeapOnly&amp; h) = delete;\t// 赋值不一定需要delete，因为赋值不能创建新对象\t// HeapOnly&amp; operator=(const HeapOnly&amp; h) = delete;\tint _a;\tint _b;&#125;;\n\n这样写了之后，想创建对象就可以调用static函数来操作\n\n而且因为我们并没有私有化析构函数，所以析构是可以正常调用的！\n2.1 另类操作还可以使用static函数提供一个接口来专门处理析构，再把析构函数设计成私有，构造函数公有；\n// 只能在堆上开辟class HeapOnly &#123;public:\tstatic HeapOnly* CreatObj(int a,int b)\t&#123;\t\treturn new HeapOnly(a, b);\t&#125;\tstatic void DelObj(HeapOnly* ptr)\t&#123;\t\tdelete ptr;\t&#125;\t// 因为析构私有了，所以可以把构造公有\tHeapOnly()\t\t:_a(0),\t\t_b(0)\t&#123;&#125;\tHeapOnly(int a, int b)\t\t:_a(a),\t\t_b(b)\t&#123;&#125;private:\t// 构造函数私有\t// ....\t// 同时拷贝构造也需要私有，禁止拷贝创建对象\tHeapOnly(const HeapOnly&amp; h) = delete;\t// 赋值不一定需要delete，因为赋值不能创建新对象\t// HeapOnly&amp; operator=(const HeapOnly&amp; h) = delete;\t~HeapOnly()\t&#123;\t\t_a = _b = 0;\t&#125;\tint _a;\tint _b;&#125;;\n\n这样设计了之后，直接在栈上&#x2F;全局区开辟空间会报错，但是new不受影响。\n在栈上创建一个对象，编译此代码会报错，因为析构函数无法被正常访问，所以无法编译成功；\n$ g++ test.cpp -o testtest.cpp: In function ‘int main()’:test.cpp:133:14: error: ‘HeapOnly::~HeapOnly()’ is private within this context     HeapOnly h3;              ^~test.cpp:122:2: note: declared private here  ~HeapOnly()  ^\n\n因为析构私有了，所以delete不能正确调用析构函数，我们需要使用static函数指定指针进行析构\n\n除了static函数的这种办法，还有另外一个法子可以不传入对象的指针；\n//删除自己void DelObj()&#123;    delete this;&#125;\t\n\n直接用对象调用此成员函数即可\nHeapOnly* h6 = new HeapOnly();h6-&gt;DelObj();\n\n只不过这样操作可能有些不太好理解，视具体情况而定喽！\n3.只能在栈上创建的类相同的思路，设计一个static的创建对象函数，来创建一个栈上的对象return\n// 只能在栈上开辟class StackOnly&#123;public:\tstatic StackOnly CreatObj()\t&#123;\t\treturn StackOnly();//创建匿名对象返回，编译器直接优化为一个构造\t\t//这么写的话，就不能禁止拷贝构造\t\t//StackOnly st;\t\t//return st;\t&#125;\t// 不能禁用拷贝构造，因为return的时候可能会调用（编译器优化是取决于平台的）private:\tStackOnly()\t&#123;\t\t_a = _b = 0;\t&#125;\tint _a;\tint _b;&#125;;\n\n这里我们必须要有拷贝构造，因为return的时候，编译器如果不优化，那就是构造+拷贝，优化了之后才能变成直接构造\n这是取决于平台的，如果禁用了拷贝，万一有些平台编译器没有做这种优化，你的代码就跑不动了\n\n另外，还有一个方法便是禁用掉operator new()，以此禁止了在堆上创建空间。如果用这种办法，构造函数就不需要设计为私有了\n\n但是这两个办法都有个缺陷，那就是用户可以用拷贝构造在静态区上创建一个对象。这只能算个小瑕疵，可以不用管它\n\n4.单例模式单例模式是设计模式的其中一种\n\n设计模式是一套被反复使用且较为流行的代码设计经验总结。\n设计模式有非常多，感兴趣的老哥可以去搜专门的博客了解一下\n\n单例模式：一个类只能创建一个对象。该模式可以保证在一个进程中，某一个类只会有一个实例化的对象\n\n举个例子，比如服务器的配置信息是一个类，这个类就可以设计成单例模式，保证所有人访问到的配置信息完全相同，修改的时候也能同步给所有人。\n\n4.1 饿汉饿汉模式采用static成员来实现单例，思路和上面也是一样的，让构造函数私有而无法创建其他对象\n\n那我们的static对象要怎么创建呢？\n\n先来看看下面的代码\n// 单例模式（饿汉）// 饿汉模式采用static对象，是在main函数之前创建的// 会影响程序启动的速度class Singleton&#123;public:\tstatic Singleton* GetInstance()\t&#123;\t\treturn _sgp;\t&#125;\tvoid Print()\t&#123;\t\tcout &lt;&lt; &quot;----- System Info -----&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;     CPU &quot; &lt;&lt; _cpu &lt;&lt; endl;\t\tcout &lt;&lt; &quot;     GPU &quot; &lt;&lt; _gpu &lt;&lt; endl;\t\tcout &lt;&lt; &quot;     MEM &quot; &lt;&lt; _mem &lt;&lt; endl;\t\tcout &lt;&lt; &quot;-----     End     -----&quot; &lt;&lt; endl;\t&#125;private:\tSingleton()\t\t:_cpu(&quot;i9-12900ks&quot;),\t\t_gpu(&quot;RTX 4090&quot;),\t\t_mem(&quot;128GB&quot;)\t&#123;&#125;    Singleton(const Singleton&amp; s) = delete;    Singleton&amp; operator==(const Singleton&amp; s) = delete;\tstring _cpu;\tstring _mem;\tstring _gpu;\t//static Singleton _sg;//声明\tstatic Singleton* _sgp;//声明&#125;;//Singleton Singleton::_sg;//定义Singleton* Singleton::_sgp = new Singleton();//定义//因为这里的sg和sgp都是属于类里面的成员，不受访问限定符的限制，才可以正常调用构造函数\n\n因为_sg/_sgp这两个成员都在类内部声明的，所以它们属于整个类域，可以成功访问到内部的构造函数。\n而在其他地方的对象由于没有办法访问到构造函数，而无法创建\n\n由于饿汉模式是static对象，其初始化是在main函数之前进行的。如果采用饿汉模式的单例过多，程序迟迟没有运行到main处，会导致一个程序启动很慢\n4.2 懒汉一开始不创建对象，第一调用GetInstance再创建对象\n// 懒汉// 一开始不创建对象，第一调用GetInstance再创建对象class InfoMgr&#123;public:\tstatic InfoMgr* GetInstance()\t&#123;\t\tif (_sp == nullptr)\t\t&#123;\t\t\t_sp = new InfoMgr;\t\t&#125;\t\treturn _sp;\t&#125;\tvoid SetAddress(const string&amp; s)\t&#123;\t\t_address = s;\t&#125;\tstring&amp; GetAddress()\t&#123;\t\treturn _address;\t&#125;private:\tInfoMgr()\t\t:_address(&quot;bilibili&quot;),\t\t_secretKey(1234)\t&#123;&#125;\tInfoMgr(const InfoMgr&amp;) = delete;\tInfoMgr&amp; operator==(const InfoMgr&amp;) = delete;\tstring _address;\tint _secretKey;\tstatic InfoMgr* _sp; // 声明&#125;;InfoMgr* InfoMgr::_sp = nullptr; // 定义\n\n这里我们将内部的_sp定义为了nullptr，如果谁第一个调用，做一个判断，如果是nullptr就创建实例\n\n由于懒汉可能会出现多个线程同时第一次访问这个单例，就会导致在两个线程中都在初始化这个单例，而某一次初始化会失败。这是一个线程安全问题，需要我们对单例进行加锁操作\n\n多线程加锁问题，参考linux下的操作：C++线程操作；C++的操作以这个思路，修改为使用C++的thread库即可\n\n4.3 二者优缺点饿汉的优点\n\n简单易用\n因为是在main函数前初始化，处于单线程状态，没有线程安全问题\n\n缺点：\n\n但是初始化顺序不确定，如果有其他类的依赖关系，可能会出现依赖项B在当前单例A后初始化，导致A无法完成初始化而程序boom\n饿汉单例是在main函数之前创建的，拖慢程序启动速度\n\n\n懒汉的优点\n\n第一次调用的时候才初始化变量，提高程序启动速度\n可以控制初始化顺序，按顺序来初始化，避免依赖关系问题\n\n缺点：\n\n第一次调用的时候，加载会慢一些\n\n基于这两个的优缺点，让我想出来一个不算办法的办法\n如果想控制饿汉的初始化顺序，可以在main一启动的时候，就调用一个初始化函数来初始化这些单例。这样依旧会拖慢进程启动的顺序，但解决了初始化顺序的问题！\n\n实际上，一个单例究竟要不要在main之前就初始化需要看具体情况的！\n\n4.4 单例释放资源一般情况下，单例的类是不需要手动释放的，因为整个进程都需要使用这个单例\n但如果我们的单例和一个文件挂钩，进程结束的时候，需要将单例里面的信息保存到文件里面，要怎么操作？\n可以写一个垃圾回收类，在最后调用析构来回收资源\n// 懒汉 -- 一开始不创建对象，第一调用GetInstance再创建对象class InfoMgr&#123;public:\tstatic InfoMgr* GetInstance()\t&#123;\t\t// 还需要加锁，留着后面填坑\t\tif (_spInst == nullptr)\t\t&#123;\t\t\t_spInst = new InfoMgr;\t\t&#125;\t\treturn _spInst;\t&#125;\tvoid SetAddress(const string&amp; s)\t&#123;\t\t_address = s;\t&#125;\tstring&amp; GetAddress()\t&#123;\t\treturn _address;\t&#125;\t// 实现一个内嵌垃圾回收类    \tclass CGarbo &#123;\tpublic:\t\t~CGarbo() &#123;\t\t\tif (_spInst)\t\t\t\tdelete _spInst;\t\t&#125;\t&#125;;\t// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象\tstatic CGarbo Garbo;//声明private:\tInfoMgr()\t\t:_address(&quot;bilibili&quot;),\t\t_secretKey(1234)\t&#123;&#125;\t~InfoMgr()\t&#123;\t\t// 假设析构时需要信息写到文件持久化\t&#125;\tInfoMgr(const InfoMgr&amp;) = delete;\tstring _address;\tint _secretKey;\tstatic InfoMgr* _spInst; // 声明&#125;;InfoMgr* InfoMgr::_spInst = nullptr; // 定义InfoMgr::CGarbo Garbo;//定义\n\n4.5 static单例有人会采用下面的方式来实现懒汉的单例，其采用static对象，让编译器自动帮我们实现单例！\n\n全局static变量会在main之前初始化\n局部static变量会在第一次调用的时候初始化\n\nclass Singleton&#123;public:\tstatic Singleton* GetInstance()\t&#123;\t\t// 局部的静态对象，第一次调用时初始化\t\tstatic Singleton _s;\t\treturn &amp;_s;\t&#125;private:\t// 构造函数私有\tSingleton()&#123;&#125;;\t// 拷贝构造/赋值重载取消\tSingleton(Singleton const&amp;) = delete;\tSingleton&amp; operator=(Singleton const&amp;) = delete;&#125;;\n\n但是！这个操作并不通用，其取决于编译器和平台的实现。特别是在C++11之前；\nC++11之后，保证了局部静态变量初始化时的线程安全，我们便可以采用这种办法来实现单例。\n\nC++11中局部static变量的线程安全问题\n\n但是！一定要确认你的代码只在C++11的环境下运行！！\n4.6 线程安全在创建单例的时候，我们需要考虑到线程安全的问题，具体请参考linux博客中线程池单例类对线程安全的处理。特别是其中进行了两次nullptr的判断的原因\n5.不能被继承的类C++98中，只需要将构造函数私有，派生类无法调用基类构造函数，也就无法继承\n// c++98,构造私有class A &#123;public:\t// 额外提供一个获取对象的方式\tstatic A GetInstance()\t&#123;\t\treturn A();\t&#125;private:\tA()\t&#123;\t\t_a = 0;\t&#125;\tint _a;&#125;;\n\n而C++11中提供了一个关键字final，用这个关键字修饰类，就无法被继承\n//C++11直接用关键字finalclass B final&#123;\t//...&#125;;\n\n结语几个特殊类到这里就讲解结束辣，其中懒汉多线程加锁还留了一个坑，待后续我会回来更新补上的！\n感谢你看到最后!\n","categories":["遇见C++"],"tags":["C++","类和对象"]},{"title":"【C++】空间配置器","url":"/posts/281674790/","content":"空间配置器，听起来高大上，那它到底是什么东西呢？\n\n\n1.什么是空间配置器？空间配置器是STL源码中实现的一个小灶，用来应对STL容器频繁申请小块内存空间的问题。他算是一个小型的内存池，以提升STL容器在空间申请方面的效率 \n\n2.了解空间配置器STL以128个字节为分界线，将空间配置器分为了一级和二级\n2.1 一级一级空间配置器中，allocate/deallocate函数实际上就是对malloc/free做了一个简单的封装\nstatic void * allocate(size_t n)&#123;    void *result = malloc(n);    if (0 == result) result = oom_malloc(n);    return result;&#125;static void deallocate(void *p, size_t /* n */)&#123;    free(p);&#125;//这个函数是malloc失败的时候才会调用的template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)&#123;    void (* my_malloc_handler)();    void *result;    for (;;) &#123;        my_malloc_handler = __malloc_alloc_oom_handler;        if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;//抛异常        (*my_malloc_handler)();        result = malloc(n);        if (result) return(result);    &#125;&#125;\n\n当malloc失败的时候，一级空间配置器会抛异常\n2.2 二级在二级空间配置器中，会先判断带申请空间大小是否大于128个字节，如果超过了，则会去调用一级空间配置器\n# ifndef __SUNPRO_CCenum &#123;__ALIGN = 8&#125;;enum &#123;__MAX_BYTES = 128&#125;;enum &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;# endif  /* n must be &gt; 0      */static void * allocate(size_t n)&#123;    obj * __VOLATILE * my_free_list;    obj * __RESTRICT result;    if (n &gt; (size_t) __MAX_BYTES) &#123;        return(malloc_alloc::allocate(n));    &#125;    my_free_list = free_list + FREELIST_INDEX(n);    // Acquire the lock here with a constructor call.    // This ensures that it is released in exit or during stack    // unwinding.    #       ifndef _NOTHREADS    /*REFERENCED*/    lock lock_instance;    #       endif    result = *my_free_list;    if (result == 0) &#123;        void *r = refill(ROUND_UP(n));        return r;    &#125;    *my_free_list = result -&gt; free_list_link;    return (result);&#125;;/* p may not be 0 */static void deallocate(void *p, size_t n)&#123;    obj *q = (obj *)p;    obj * __VOLATILE * my_free_list;    if (n &gt; (size_t) __MAX_BYTES) &#123;        malloc_alloc::deallocate(p, n);        return;    &#125;    my_free_list = free_list + FREELIST_INDEX(n);    // acquire lock    #       ifndef _NOTHREADS    /*REFERENCED*/    lock lock_instance;    #       endif /* _NOTHREADS */    q -&gt; free_list_link = *my_free_list;    *my_free_list = q;    // lock is released here&#125;\n\n二级空间配置器中，主要的几个成员变量如下\nstatic obj * __VOLATILE free_list[__NFREELISTS]; //哈希桶// Chunk allocation state.static char *start_free;static char *end_free;static size_t heap_size;\n\n这里是一个内存池+ 一个哈希桶,内存池的长度为heap_size\n\n哈希桶以8字节对齐，分为了16个桶。最开始的时候，free_list哈希桶是空的\n\n当我们需要小于128个字节空间的时候（以16字节为例），二级空间配置器会直接去上面的内存池当中申请20个16字节的空间，链接到16字节对应的哈希桶的位置（1号桶）\n在下面的refill函数中可以看到这一点\ntemplate &lt;bool threads, int inst&gt;void* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n)&#123;    int nobjs = 20;//一次性申请20个    char * chunk = chunk_alloc(n, nobjs);    obj * __VOLATILE * my_free_list;    obj * result;    obj * current_obj, * next_obj;    int i;    if (1 == nobjs) return(chunk);    my_free_list = free_list + FREELIST_INDEX(n);    /* Build free list in chunk */      result = (obj *)chunk;      *my_free_list = next_obj = (obj *)(chunk + n);      for (i = 1; ; i++) &#123;        current_obj = next_obj;        next_obj = (obj *)((char *)next_obj + n);        if (nobjs - 1 == i) &#123;            current_obj -&gt; free_list_link = 0;            break;        &#125; else &#123;            current_obj -&gt; free_list_link = next_obj;        &#125;      &#125;    return(result);&#125;\n\n8字节对齐的妙处假设我们的list单个节点需要12个字节，set单个字节需要16个字节\n当list需要空间的时候，二级空间配置器也会去申请16个字节的空间，而不会去申请12个字节。这时候，当list将用完的空间还回来之后，就能拿过去给set用了！\n关于哈希桶的特殊处理当我们用完了申请的空间，准备“释放”的时候，二级空间配置器会将释放回来的空间插入进哈希桶（头插）\n这里有一个特殊处理，当用完的空间，或者说是刚申请的空间插入进哈希桶的时候，二及空间配置器会将其强转为一个obj类型，这个类型的前4/8个字节会用来存放一个指针，指向下一个空间，以此构成链表\nunion obj &#123;    union obj * free_list_link;    char client_data[1];    /* The client sees this.        */&#125;;\n\n\n当我们再次需要这部分大小的空间的时候，只需要将哈希桶头指针的指向直接修改，就能链接上下一个空间，并将之前头指针指向的空间拿去用\n用的时候也不用管之前在此处存放的指针，毕竟下一次放回来的时候，二级空间配置器会来处理它的\n\n内存池空间不够用了咋办？之前提到了，二级空间配置器里面有一个小内存池。要是这个内存池用完了，要咋整呢？\n二级空间配置器想出来了一种很骚的做法：\n\n假设当前我们需要24字节的空间\n对应的桶下面没有空间给我们用\n内存池也用光了\n但是48字节的桶下面还有空间可以用\n直接把这个空间拿过来，拆成两个24链接到24的桶下面！\n\n这样便有效提高了空间利用率，也避免了realloc造成的时间消耗。\n当然，要是桶里面也没有多余空间了，那就只能老老实实去扩容了\n\n只能大的拆小的，小的空间不连续无法组成大的\n\n//二级空间配置器里面的reallocate封装template &lt;bool threads, int inst&gt;void*__default_alloc_template&lt;threads, inst&gt;::reallocate(void *p,                                                    size_t old_sz,                                                    size_t new_sz)&#123;    void * result;    size_t copy_sz;    if (old_sz &gt; (size_t) __MAX_BYTES &amp;&amp; new_sz &gt; (size_t) __MAX_BYTES) &#123;        return(realloc(p, new_sz));    &#125;    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);    result = allocate(new_sz);    copy_sz = new_sz &gt; old_sz? old_sz : new_sz;    memcpy(result, p, copy_sz);    deallocate(p, old_sz);    return(result);&#125;\n\n\n2.3 关于单例的说明在同一个进程里面，空间配置器只会有一个\n但STL库中的空间配置器并没有把自己设计成单例类，而是用了一个间接的做法\nstatic obj * __VOLATILE free_list[__NFREELISTS]; //哈希桶// Chunk allocation state.static char *start_free;static char *end_free;static size_t heap_size;\n\n那就是所有成员变量都是static静态的\n我们知道，在类和对象中，静态成员变量是属于整个类的，所以它也是一种单例模式！\n\n2.4 空间配置器的优点\n空间配置器的时间复杂度是O(1)，申请空间的效率很高\n空间配置器能解决频繁申请空间导致的内存碎片问题\n\n当我们使用STL容器频繁申请小块空间（比如list）就容易导致堆区中有非常多的小块空间被使用，而无法申请一个大的空间\n空间配置器提前申请了一个大块空间再私下管理，可以有效解决这个问题\n内存外碎片&#x2F;内碎片\n外碎片：多次申请小块空间造成。有足够内存，但是不连续，无法申请大块内存\n内碎片：list只需要12个字节，而空间配置器因为内存对齐而给了它16个字节，浪费了4个字节造成的内存碎片\n\n3.容器和空间配置器之前学习stl容器的时候，就在定义中看到过这里的alloc默认模板参数\n\n这里默认传的便是stl库中的二级空间配置器\n\n只要你自己写的空间配置器符合stl的接口需求，你便可以将自己的空间配置器传入此处让容器使用！\n\ntypedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc;typedef __default_alloc_template&lt;false, 0&gt; single_client_alloc;\n\n在list中，alloc又被封装了一层，用来处理节点申请的问题\ntemplate &lt;class T, class Alloc = alloc&gt;class list &#123;protected:  typedef void* void_pointer;  typedef __list_node&lt;T&gt; list_node;  typedef simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;\n\ntemplate&lt;class T, class Alloc&gt;class simple_alloc &#123;public:    static T *allocate(size_t n)                &#123; return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); &#125;    static T *allocate(void)                &#123; return (T*) Alloc::allocate(sizeof (T)); &#125;    static void deallocate(T *p, size_t n)                &#123; if (0 != n) Alloc::deallocate(p, n * sizeof (T)); &#125;    static void deallocate(T *p)                &#123; Alloc::deallocate(p, sizeof (T)); &#125;&#125;;\n\n随后，当创建节点、销毁节点的时候，list就会调用封装好的simple_alloc来处理空间\nlink_type get_node() &#123; return list_node_allocator::allocate(); &#125;void put_node(link_type p) &#123; list_node_allocator::deallocate(p); &#125; link_type create_node(const T&amp; x) &#123;    link_type p = get_node();    __STL_TRY &#123;      construct(&amp;p-&gt;data, x);//调用节点的构造函数    &#125;    __STL_UNWIND(put_node(p));    return p;  &#125;  void destroy_node(link_type p) &#123;    destroy(&amp;p-&gt;data);//调用节点的析构函数    put_node(p);  &#125;\n\n\nconstruct通过定位new显式调用节点的构造函数\ndestroy通过指针来调用析构函数\n\ntemplate &lt;class T&gt;inline void destroy(T* pointer) &#123;    pointer-&gt;~T();&#125;template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value) &#123;  new (p) T1(value);&#125;\n\n在stl_tree.h中可以看到库里面的红黑树也对空间配置器进行了类似的封装\ntemplate &lt;class Key, class Value, class KeyOfValue, class Compare,          class Alloc = alloc&gt;class rb_tree &#123;protected:  typedef void* void_pointer;  typedef __rb_tree_node_base* base_ptr;  typedef __rb_tree_node&lt;Value&gt; rb_tree_node;  typedef simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;  typedef __rb_tree_color_type color_type;\n\n结语关于空间配置器的内容了解这些就差不多啦！\n其实就是通过库里面的这个设计来了解一个提高小空间内存申请效率的方法，感觉还是很666的\n\n有啥问题可以在评论提出哦\n\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】类型转换方法","url":"/posts/3134809219/","content":"本篇博客让我们来见识一下C++中新增的类型转换方法\n\n\n[TOC]\n1.C语言中类型转换在C语言中，类型转换有下面两种形式\n\n隐式类型转换\n显示强制类型转换int a=(int)&#39;c&#39;\n\n这两种方式想必各位都很熟悉了，但隐式类型转换在一些场景里面会出现问题\nvoid insert(size_t pos,char c)&#123;\tint end=10;\twhile(end&gt;=pos)\t&#123;\t\tend--;\t&#125;\t//...&#125;\n\n上面的代码中，end是int类型，当进行比较的时候，end会-1直到小于pos\n如果pos=0，问题就来了！\n隐式类型转换会让end在比较的时候被转换为size_t无符号整型，而在无符号整型中，-1是一个非常大的正数，从而导致这个函数进入死循环！\n\n\n隐式类型转换可能会丢失数据的精度\n显示类型转换的写法都一样，导致不能很好的区分情况\n\nC++委员会也是认识到了这里的问题，当产生隐式类型转换的时候，难以跟踪错误的来源，于是开发了下面的新的类型转换方式\n\n不过，因为C++兼容C语言，所以C中的转换方式依旧支持\n\n\n2.C++中的强制类型转换C++中新增了下面四种明明的强制类型转换操作符\nstatic_cast、reinterpret_cast、const_cast、dynamic_cast\n\n2.1 static_cast这个关键字是用于相近类型之间的转换的，比如double和int，char和int之间\ndouble d = 11.4;int a1 = static_cast&lt;int&gt;(d);//相近类型的转换char ch = &#x27;a&#x27;;int a2 = static_cast&lt;int&gt;(ch);cout &lt;&lt; a1 &lt;&lt; endl;cout &lt;&lt; a2 &lt;&lt; endl;\n\n\n除了以上的类型转换，其还支持将内置类型转自定义类型\nstruct mytest&#123;public:    // explicit mytest(int a = -1)    mytest(int a = -1)    &#123;        _a = a;        cout &lt;&lt; &quot;mytest() &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    mytest(const mytest &amp;st)    &#123;        _a = st._a;        cout &lt;&lt; &quot;mytest(copy) &quot; &lt;&lt; st._a &lt;&lt; endl;    &#125;    mytest &amp;operator=(const mytest &amp;st)    &#123;        _a = st._a;        cout &lt;&lt; &quot;mytest operator= &quot; &lt;&lt; st._a &lt;&lt; endl;        return *this;    &#125;private:    int _a;&#125;;\n\n使用如下代码进行测试，当mytest的构造函数没有加explicit关键字的时候，下方的两种构造方式都可以成功调用（隐式类型转换）\nint main()&#123;    mytest t1 = static_cast&lt;mytest&gt;(3);    mytest t2 = 5;    return 0;&#125;\n\n$ ./testmytest() 3mytest() 5\n\n加了explicit之后，t2就没有办法成功构造了，因为隐式类型转换被禁用了\n$ g++ test.cpp -o testtest.cpp: In function ‘int main()’:test.cpp:120:17: error: conversion from ‘int’ to non-scalar type ‘mytest’ requested     mytest t2 = 5;                 ^\n\n但static_cast在加了explicit之后，依旧可以帮我们调用构造函数来创建对象；\n$ ./testmytest() 3\n\n2.2 reinterpret_cast这个关键字用于不相近类型之间的转换，比如指针转成int\nint* p = &amp;a1;//int x = static_cast&lt;int&gt;(p);//报错：类型转换无效int x = reinterpret_cast&lt;int&gt;(p);//非相近类型中的转换cout &lt;&lt; x &lt;&lt; endl;\n\n打印的结果如下（每次运行都不一样）\n2029408\n\n2.3 const_cast如同其名，这个关键字的作用是取消一个变量的const属性\nconst int c1 = 3;//这里定义的变量是在栈上的，可以间接修改int* ptr1 = const_cast&lt;int*&gt;(&amp;c1);//取消const权限*ptr1 = 4;cout &lt;&lt; c1 &lt;&lt; endl;//修改了地址之后没有变化cout &lt;&lt; *ptr1 &lt;&lt; endl;\n\n\n欸，为什么我们取地址之后，修改为4了，变量c1本身不会变化呢？\n这是因为编译器做了一些优化，把c1放到了某个地方，取的时候并没有直接去内存里面取\nvolatile关键字这里我们可以使用volatile关键字修饰变量，要求每一次都必须要去内存中取\n//volatile关键字，每次访问c都去内存中取，屏蔽编译器优化volatile const int c2 = 3;int* ptr2 = const_cast&lt;int*&gt;(&amp;c2);//取消const权限*ptr2 = 4;cout &lt;&lt; &quot;volatitle:  &quot;;cout &lt;&lt; c2 &lt;&lt; endl;cout &lt;&lt; *ptr2 &lt;&lt; endl;\n\n\n2.4 dynamic_cast该关键字是用于继承中，将一个父类的指针/引用转换为子类对象的指针/引用\n之前学习继承的时候，我们了解过\n\n向上转型：父类的指针、引用可以直接指向子类对象的指针&#x2F;引用（这是一个赋值兼容的规则，不需要进行转换）\n向下转型：反过来之后，可以直接赋值吗？不够安全\n\ndynamic_cast的作用就是判断一个父类指针指向的是不是他的子类\n\n如果是，能够成功转换\n不能则返回0\n\n这个关键字最大的作用，便是可以帮我们判断这个父类指针&#x2F;引用指向的是否为一个子类对象\nclass A&#123;public:\tvirtual void f() &#123;&#125;&#125;;class B : public A&#123;&#125;;void fun(A* pa)&#123;\t// dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回0\tB* pb1 = static_cast&lt;B*&gt;(pa);\tB* pb2 = dynamic_cast&lt;B*&gt;(pa);\tcout &lt;&lt; &quot;pb1:&quot; &lt;&lt; pb1 &lt;&lt; endl;\tif (pb2)\t&#123;\t\tcout &lt;&lt; &quot;转换成功！pb2:&quot; &lt;&lt; pb2 &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;转换失败！pb2:&quot; &lt;&lt; pb2 &lt;&lt; endl;\t&#125;\t&#125;void test2()&#123;\tA a;\tB b;\tfun(&amp;a);\tfun(&amp;b);&#125;\n\n\n这里有个要求，那便是父类中必须要有虚函数（多态），否则无法成功转换\n\n3.C++强制类型转换的作用C++希望我们规范强制类型转换的情景，针对性的调用不同的关键字\n但是由于它没有强制，在实际情况中用的反而不多\n不过需要注意的是，强制类型转换会关闭&#x2F;挂起正常的类型检查，在强制类型转换之前，我们要仔细检查是否还有别的方法来达到目的。最好是避免使用强制类型转换!\n4.RTTI之前学习智能指针的时候，我们学过一种思路叫RAII\n这里的RTTI全称为Run-time Type identification，即运行时类型识别\nC++通过下面几种方式来支持RTTI：\n\ntypeid\ndecltype\ndyanmic_cast\n\n这个概念只需要了解即可！\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】using的三种用法 | 转载","url":"/posts/834577958/","content":"C++ using的三种用法，这个之前还没有接触过\n\n\n示例#include &lt;iostream&gt;using namespace std;class ClassOne &#123;public:\tint w;protected:\tint a;&#125;;class ClassTwo&#123;public:\tusing ModuleType = ClassOne;&#125;;template &lt;typename ClassType&gt;class ClassThree : private ClassType&#123;public:\tusing typename ClassType::ModuleType;\tModuleType m;\tClassThree() = default;\tvirtual ~ClassThree() = default;&#125;;void main()&#123;\tClassThree&lt;ClassTwo&gt;::ModuleType a;&#125;\n\n\n在上面代码中，一共有三处使用了using，分别是第3,16,22行，它们的作用为：\n\n引入命名空间\n指定别名\n在子类中引用基类的成员\n\n引入命名空间指定命名空间是C++ using namespace中最常被用到的地方，在第3行中的：\nusing namespace std;\n\n\n指定别名using的另一个作用是指定别名，一般都是using a = b;这样的形式出现，比如在13行中：\nusing ModuleType = ClassOne;\n\n\nModuleType 是ClassOne的一个别名。using这个作用也比较常见，比如在vector.h中就有：\ntemplate&lt;class _Ty,class _Alloc = allocator&lt;_Ty&gt;&gt;class vector: public _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;&#123;public:\tusing value_type = _Ty;\tusing allocator_type = _Alloc;&#125;\n\n即value_type 是_Ty的一个别名，value_type a; 和_Ty a;是同样的效果。\n\n可以理解为C++中的typedef\n\n在子类中引用基类的成员using的第三个作用是子类中引用基类的成员，一般都是using CBase::a;这样的形式出现，比如在22行中：\nusing typename ClassType::ModuleType;\n\n它和一般形式有些区别，就是它加了个typename 修饰，这是因为类ClassThree本身是个模板类，它的基类ClassType是个模板，这个typename 和using其实没有什么关系。如果ClassType不是模板的话，这行代码就可以写成：\nusing ClassType::ModuleType;\n\n剩下的就是using的作用，它引用了基类中的成员ModuleType， ModuleType又是类ClassOne的别名，所以后面ModuleType m;相当于定义对象m，对于子类成员m来说，这样的效果和下面是相同的：\ntypename ClassType::ModuleType m;\n\n不同之处在于using还修改了基类成员的访问权限，子类ClassThree 私有继承ClassType，所以ClassType中共有成员ModuleType 在子类ClassThree 是私有的，它不能被外部访问。但是使用using后，在main()函数中可以使用。\n版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA] 版权协议，转载请附上原文出处链接和本声明。本文链接：https://blog.csdn.net/chaipp0607/article/details/100128842\n\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】C++11中局部static变量的线程安全问题 | 转载","url":"/posts/306129693/","content":"C++11中局部static变量的线程安全问题\n\n\n前言大家都知道，在C++11标准中，要求局部静态变量初始化具有线程安全性，所以我们可以很容易实现一个线程安全的单例类：\nclass Foo&#123;public:    static Foo *getInstance()    &#123;        static Foo s_instance;        return &amp;s_instance;    &#125;private:    Foo() &#123;&#125;&#125;;\n\n在C++标准中，是这样描述的（在标准草案的6.7节中）：\n\nsuch a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization. If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.\n\n分析标准关于局部静态变量初始化，有这么几点要求：\n\n变量在代码第一次执行到变量声明的地方时初始化。\n初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。\n在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。\n如果初始化过程中发生了对初始化的递归调用，则视为未定义行为。\n\n关于第4点，如果不明白，可以参考以下代码：\nclass Bar\n&#123;\npublic:\n    static Bar *getInstance()\n    &#123;\n        static Bar s_instance;\n        return &amp;s_instance;\n    &#125;\nprivate:\n    Bar()\n    &#123;\n        getInstance();\n    &#125;\n&#125;;\n\nGCC的实现以GCC 7.3.0版本为例，我们来分析GCC是如何实现标准的。\nFoo::getInstance()使用GCC编译后，我们使用gdb将文章开头的Foo::getInstance()反汇编：\nDump of assembler code for function Foo::getInstance():\n   0x00005555555546ea &lt;+0&gt;:     push   %rbp\n   0x00005555555546eb &lt;+1&gt;:     mov    %rsp,%rbp\n=&gt; 0x00005555555546ee &lt;+4&gt;:     movzbl 0x20092b(%rip),%eax        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;\n   0x00005555555546f5 &lt;+11&gt;:    test   %al,%al\n   0x00005555555546f7 &lt;+13&gt;:    sete   %al\n   0x00005555555546fa &lt;+16&gt;:    test   %al,%al\n   0x00005555555546fc &lt;+18&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;\n   0x00005555555546fe &lt;+20&gt;:    lea    0x20091b(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;\n   0x0000555555554705 &lt;+27&gt;:    callq  0x5555555545b0 &lt;__cxa_guard_acquire@plt&gt;\n   0x000055555555470a &lt;+32&gt;:    test   %eax,%eax\n   0x000055555555470c &lt;+34&gt;:    setne  %al\n   0x000055555555470f &lt;+37&gt;:    test   %al,%al\n   0x0000555555554711 &lt;+39&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;\n   0x0000555555554713 &lt;+41&gt;:    lea    0x2008fe(%rip),%rdi        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;\n   0x000055555555471a &lt;+48&gt;:    callq  0x555555554734 &lt;Foo::Foo()&gt;\n   0x000055555555471f &lt;+53&gt;:    lea    0x2008fa(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;\n   0x0000555555554726 &lt;+60&gt;:    callq  0x5555555545a0 &lt;__cxa_guard_release@plt&gt;\n   0x000055555555472b &lt;+65&gt;:    lea    0x2008e6(%rip),%rax        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;\n   0x0000555555554732 &lt;+72&gt;:    pop    %rbp\n   0x0000555555554733 &lt;+73&gt;:    retq   \nEnd of assembler dump.\n\n在+4、+20、+53出现的_ZGVZN3Foo11getInstanceEvE10s_instance使用c++filt分析为guard variable for Foo::getInstance()::s_instance，而+41、+65位置出现的_ZZN3Foo11getInstanceEvE10s_instance则为Foo::getInstance()::s_instance。后者是s_instance这个局部静态变量，前者从名字看就知道是个guard标志变量，用来指示局部静态变量的初始化状态。\n+4 ~ +18测试guard变量的第一个字节，如果为0，代表s_instance未初始化，进入+27；否则代表s_instance已初始化，进入+65。\n+20 ～ +27以guard变量地址作为参数，执行__cxa_guard_acquire函数。\n+32 ～ +39测试返回值，如果为0，代表s_instance已初始化，进入+65；否则代表s_instance未初始化，进入+41。\n+41 ～ +48初始化s_instance\n+53 ～ +60以guard变量地址作为参数，执行__cxa_guard_release函数。\n+65 ～ +73返回s_instance地址\n__cxa_guard_acquire我们来看看__cxa_guard_acquire这个函数具体做了什么，该函数代码位于gcc-7-7.3.0/gcc-7.3.0/libstdc++-v3/libsupc++/guard.cc。由于这个函数针对不同平台做了不同的实现，有些我们不需要的代码，以我机器的设置，支持线程和futex系统调用，所以删除了一些不相关的代码：\nint __cxa_guard_acquire (__guard *g)&#123;    // If the target can reorder loads, we need to insert a read memory    // barrier so that accesses to the guarded variable happen after the    // guard test.    // 1    if (_GLIBCXX_GUARD_TEST_AND_ACQUIRE (g))        return 0;    // If __atomic_* and futex syscall are supported, don&#x27;t use any global    // mutex.    // 2    if (__gthread_active_p ())    &#123;        int *gi = (int *) (void *) g;        // 3        const int guard_bit = _GLIBCXX_GUARD_BIT;        const int pending_bit = _GLIBCXX_GUARD_PENDING_BIT;        const int waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;        while (1)        &#123;            // 4            int expected(0);            if (__atomic_compare_exchange_n(gi, &amp;expected, pending_bit, false,                                            __ATOMIC_ACQ_REL,                                            __ATOMIC_ACQUIRE))            &#123;                // This thread should do the initialization.                return 1;            &#125;            // 5            if (expected == guard_bit)            &#123;                // Already initialized.                return 0;            &#125;            // 6            if (expected == pending_bit)            &#123;                // Use acquire here.                // 7                int newv = expected | waiting_bit;                // 8                if (!__atomic_compare_exchange_n(gi, &amp;expected, newv, false,                                                 __ATOMIC_ACQ_REL,                                                 __ATOMIC_ACQUIRE))                &#123;                    // 9                    if (expected == guard_bit)                    &#123;                        // Make a thread that failed to set the                        // waiting bit exit the function earlier,                        // if it detects that another thread has                        // successfully finished initialising.                        return 0;                    &#125;                    // 10                    if (expected == 0)                        continue;                &#125;                // 11                expected = newv;            &#125;            // 12            syscall (SYS_futex, gi, _GLIBCXX_FUTEX_WAIT, expected, 0);        &#125;    &#125;    return acquire (g);&#125;\n\n\n\n首先检测guard变量，guard变量等于1的话，直接返回0，代表s_instance已初始化，不需要再次初始化。\n检测是否为多线程环境，如果没有多线程的话，也就没有必要去做额外工作来保证线程安全了。\nguard_bit表示s_instance已经初始化成功；pending_bit表示s_instance正在初始化；waiting_bit表示有其他线程正在等待s_instance的初始化。\n使用一个原子操作来检测guard变量是否为0，如果为0，则由当前线程初始化s_instance，把pending_bit写入guard变量，返回1。如果不为0，则将guard当前值写入expected。\n检测expected值是否为guard_bit，如果是，则s_instance已初始化完成，不再需要初始化，返回0。\n检测expected值是否为pending_bit，如果是，说明s_instance正在初始化，且没有其他线程等待初始化。\n将newv变量设置为pending_bit | waiting_bit，表示s_instance正在初始化且有线程正在等待初始化。\n使用一个原子操作来检测guard变量是否为pending_bit，如果不是，说明有其他线程修改了guard变量，需要做进一步检测；如果是，说明没有其他线程修改guard变量，则将pending_bit | waiting_bit写入guard变量。\n如果expected等于guard_bit，说明s_instance被初始化成功，不需要再初始化，返回0。\n如果expected等于0，说明s_instance初始化失败，回到4重新开始检测。\n如果在8中没有其他线程修改过guard变量，将expected设置为pending_bit | waiting_bit，表示s_instance正在初始化且有线程（也就是当前线程）正在等待初始化。\n如果在6处没有进入if分支，说明expected等于pending_bit | waiting_bit，如果进入了if分支，由11可得，此时expected也被修改为了pending_bit | waiting_bit。总之，此时s_instance正在初始化且有线程正在等待初始化。利用futex系统调用，再次检测guard变量是否发生了变化，如果发生了变化，回到4重新开始检测；如果没有发生变化，仍然等于pending_bit | waiting_bit，则挂起当前线程。\n\n总之，__cxa_guard_acquire要么返回0要么返回1，用来指示s_instance已初始化或未初始化。__cxa_guard_acquire可能会导致当前线程挂起，这发生在s_instance正在初始化的时候。\n__cxa_guard_release由于__cxa_guard_acquire可能导致当前线程挂起，因此需要在s_instance初始化完成后使用将__cxa_guard_release线程唤醒。\nvoid __cxa_guard_release (__guard *g) throw ()&#123;    // If __atomic_* and futex syscall are supported, don&#x27;t use any global    // mutex.    // 1    if (__gthread_active_p ())    &#123;        int *gi = (int *) (void *) g;        const int guard_bit = _GLIBCXX_GUARD_BIT;        const int waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;        // 2        int old = __atomic_exchange_n (gi, guard_bit, __ATOMIC_ACQ_REL);        // 3        if ((old &amp; waiting_bit) != 0)            syscall (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);        return;    &#125;    set_init_in_progress_flag(g, 0);    _GLIBCXX_GUARD_SET_AND_RELEASE (g);&#125;\n\n\n\n检测是否为多线程环境\n使用原子操作将guard变量置为guard_bit，同时获取guard变量原始值。\n如果guard变量原始值包含waiting_bit，说明有线程挂起（或将要调用futex欲使线程挂起），调用futex唤醒挂起的进程。\n\n__cxa_guard_abort由于s_instance可能初始化失败（本例中并未体现），因此还有一个__cxa_guard_abort函数。\nvoid __cxa_guard_abort (__guard *g) throw ()&#123;    // If __atomic_* and futex syscall are supported, don&#x27;t use any global    // mutex.    if (__gthread_active_p ())    &#123;        int *gi = (int *) (void *) g;        const int waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;        int old = __atomic_exchange_n (gi, 0, __ATOMIC_ACQ_REL);        if ((old &amp; waiting_bit) != 0)            syscall (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);        return;    &#125;    set_init_in_progress_flag(g, 0);&#125;\n\n\n与__cxa_guard_release基本一致，不同的地方在于会将guard变量置0。\n递归初始化调用由于在C++11标准中，初始化如果发生了递归是未定义行为，所以GCC 7.3.0针对是否为多线程环境做了不同的处理。如果是多线程环境，不进行额外处理，会发生死锁；如果是单线程环境，则会抛异常。\n// acquire() is a helper function used to acquire guard if thread support is// not compiled in or is compiled in but not enabled at run-time.static intacquire(__guard *g)&#123;    // Quit if the object is already initialized.    if (_GLIBCXX_GUARD_TEST(g))        return 0;    if (init_in_progress_flag(g))        throw_recursive_init_exception();    set_init_in_progress_flag(g, 1);    return 1;&#125;\n\n\n总结看到了GCC如此复杂的实现，我的个人感想是还是不要自己造轮子来保证单例类的线程安全了，想要做到和GCC一样的高效还是比较难的，利用C++11标准的带来的便利就挺好。\n原文作者：imred原文链接：https://blog.csdn.net/imred/article/details/89069750\n\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】C++11中R字符串的作用","url":"/posts/3258704981/","content":"在 C++11 中添加了定义原始字符串的字面量\n\n\n1.定义和基本使用定义方式为：\nR&quot;xxx(原始字符串)xxx&quot;\n\n其中 () 两边的字符串可以省略，R只会处理括号中的字符串。\n原始字面量 R 可以直接表示字符串的实际含义，而不需要额外对字符串做转义等操作。\nR&quot;(&quot;HELLO&quot;)&quot;等同于R&quot;(\\&quot;HELLO\\&quot;)&quot;\n\n可以理解为是忽略所有转义字符的一个字符串格式\n#include &lt;iostream&gt;using namespace std;int main()&#123;\tconst char* s1 = R&quot;(Hello\\\\World)&quot;;\tcout &lt;&lt; s1 &lt;&lt; endl;\tconst char* s2 = &quot;Hello\\\\World&quot;;\tcout &lt;&lt; s2 &lt;&lt; endl;\treturn 0;&#125;\n\n\n2.实际场景在进行项目开发，需要用到Json字符串时，这个R字符串就非常有用\nrsp.body = R&quot;(&#123;&quot;code&quot;:0, &quot;message&quot;:&quot;更新点踩成功&quot;&#125;)&quot;;\n\n我们只需要使用R字符串，就能正常编写json格式的字符串\n如果不使用R字符串，就必须给Json中的每一个&quot;添加用于转义的\\&quot;，大大增加了代码的繁琐性，而且还容易出现漏加转义而导致的bug\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】引用和内联函数","url":"/posts/3945540971/","content":"阿巴阿巴，最近搭建好了腾讯云的Linux环境，所以本篇C++的博客就尝试在Linux环境下来测试代码吧！阿巴阿巴，最近搭建好了腾讯云的Linux环境，所以本篇C++的博客就尝试在Linux环境下来测试代码吧！\n今天学习了C++的引用和内联函数，一起来瞅瞅它们都是些啥……\n\n\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n\n[TOC]\n前言众所周周知，C语言之中，有一个叫指针的家伙，它的使用方式如下\nint main()&#123;\tint a=10;\tint*p=&amp;a;//p是一个指针变量，指向a        return 0;&#125;\n\n这时候我们就可以通过*p对指针解引用访问变量a\n所以C++之中也有一个类似的东西，叫做引用，不过它和指针完全不同哦\n\n1.引用1.1基本形式引用的基本方式如下\nint a=10;int&amp; b=a;int&amp; c=a;//同一个变量可以有多个别名//可以用两个不同的变量名引用同一个//但是引用了之后不可以更改对象\n\n此时的b和c都是a的别名，注意是别名！\n  \n可以用两个不同的变量名引用同一个变量，而且引用了之后不可以更改对象\n\n一个变量可以有多个引用\n指针可以更改指向的对象，引用不可以\n引用必须在定义的时候就初始化，不可以int&amp; b;\n\n\n比如你叫李华，有人叫你“小李”，还有人叫你“英语作文人”，这两个外号都是你的别名。\n\n指针并不是别名，指针是通过地址访问某个变量。而引用是给a变量起另外的两个名字，实际上b和c都可以当作a来使用\n\n编译运行代码，让编译器打印出这三者的地址，可以看到它们的地址是一样的，因为它们本来就是同一个变量的不同名字。\n\n\n指针变量的地址和指针变量所指向对象的地址是不同的\n\n引用的类型必须和引用实体的类型相同，不能用int&amp;引用double类型\n\n\n1.2引用的权限问题①const常量引用可以引用常量，但是必须加const修饰\n\n基本的思路就是“权限可以缩小，但不可以放大”。\n\n在上面的代码中，a是一个可以修改的变量，但是const int&amp;d=a;中的d是不能修改，只可读取a的内容。\ne是不可修改的常量，所以我们不能用int&amp;来放大权限\n\n②int和double相互引用在1.1中有提到，我们不能用int&amp;来引用double类型的变量，编译器会报错\n\n不过我们可以用const int&amp;类型来引用double，此时引用就不是简单的一个别名了\n先来了解一下把double复制给int类型，这时候会产生“隐式类型转换”，h保存的是z的整数部分\n\n\n在这个过程中，编译器会产生一个临时变量存放z的整数部分，然后赋值给h\n\n临时变量具有“常性”，可读不可改\n\n而当我们用const int&amp;类型来引用double时，实际上引用的是编译器产生的临时变量，它是一个常量，所以我们需要用const int&amp;来引用\nconst int&amp; i=z;//这里的i是临时变量的别名//在引用的时候，创建了一个临时变量存放d的整数部分//i的地址和z不相同，且临时变量不会销毁，生命周期和i同步//生成的这个临时变量是常量，所以i的本质是引用了一个int类型cout &lt;&lt;&quot;i= &quot;&lt;&lt;i&lt;&lt;endl;cout &lt;&lt;&quot;&amp;i= &quot;&lt;&lt; &amp;i &lt;&lt;endl; cout &lt;&lt;&quot;&amp;z= &quot;&lt;&lt; &amp;z &lt;&lt;endl;//在c++中函数主要使用引用传参，后面会进一步学习\n\n一个非常直观的验证方法，就是打印一下，瞅瞅它们的地址是否相同。可以看到，i的值和h是相同的，因为它引用的就是那个存放了整数部分的临时变量，这个临时变量的地址和z不同\n\n1.3引用的使用场景①函数传参众所周知，在C语言中，如果我们想在函数中修改某一个main传过来的参数，就必须进行传址调用。而在C++中，我们可以通过引用来操作\n\n可以看到，我们通过引用实现了在函数中修改a的值\n\n更加充分的体现便是Swap函数，在C语言中必须两个都传地址来调用\n在C++中，配合函数重载，我们可以很方便的写出多个交换函数\n\n\n直接测试一下，交换成功！\n\n\n②函数返回值int&amp; Count()&#123;  int n=0;//现在没有加static，返回的变量n可能会覆盖  n++;  cout&lt;&lt;&quot;&amp;n:&quot;&lt;&lt;&amp;n&lt;&lt;endl;  return n;&#125;int main()&#123;  int&amp; ret = Count();  cout&lt;&lt; ret &lt;&lt;endl;  cout&lt;&lt;&quot;&amp;ret:&quot;&lt;&lt;&amp;ret&lt;&lt;endl;  cout&lt;&lt; ret &lt;&lt;endl;&#125;\n\n当我们把n作为int&amp;类型来返回时，ret此时是对n的引用。但是函数中的变量n在出了函数后销毁了，所以在main函数中打印ret的时候，可能会打印出随机值（这个要看什么时候n的内容会被编译器覆写）\n\n而当我们带上static后，多次打印n的值都不会出现问题，因为此时n的空间并没有被销毁\n\n\n如果函数返回时，出了函数作用域，如果返回对象还未还给系统，则可以使用引用返回\n如果已经还给系统了，则必须使用传值返回，避免出现访问随机值\n\n\n下面用一个简单的Add函数来演示一下上面提到的两种情况\n\n如果去掉static修饰，编译器会报警告，而且打印的值会在第二次cout调用的时候被覆写\n\n当Add函数的c变量加了static修饰后，打印的值都是稳定的，不会被覆写（因为c的空间没有被销毁）\n\n③优化函数调用时间在函数返回传参的时候，其实是先把返回值存放到寄存器中，而不是直接返回给main函数的变量\n\n当返回值很小（指占用空间）的时候，会用寄存器存放它的值\n当返回值很大的时候，部分编译器会先在main函数中预先开辟栈帧用来存放返回值\n\n\n而使用引用作为返回值的时候，就不需要用寄存器来接收临时变量，这时候就优化了函数返回的时间！\n\n可以看到，用引用返回的时间消耗很小！\n\n再来试试把引用作为参数传参的消耗，和传址、传值进行对比，代码和上面的类似，稍微修改一下测试函数就行了\n\n可以看到，传地址和引用作为参数的传参消耗都是很小的。因为传值的时候需要拷贝数据！\n\n\n1.4引用和指针的汇编代码用下面的代码来查看引用和指针的汇编区别\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint&amp; ra = a;\tra = 20;\tint* pa = &amp;a;\t*pa = 20;  \treturn 0;&#125;\n\n你可以看到，指针和引用的汇编代码是相同的。因为C++的引用，本质上是用指针实现的！\n\n用objdump -S语句，查看Linux环境下的汇编👇\n\n1.5引用和指针的区别\n引用是别名；指针是指向地址\n引用必须在定义的时候初始化；指针无要求\n引用的sizeof大小和引用对象相同；指针无论指向的谁，大小都是4&#x2F;8\n引用不能为NULL；指针可以为NULL\n引用++即对象数值+1；指针++是指向的地址向后偏移\n引用无多级；指针存在二级、三级……\n引用比指针使用起来更加安全（不会出现野指针）\n引用是编译器处理的；指针需要手动解引用\n……\n\n1.6 数组指针引用笔试的时候遇到了这个纠错题，我感觉这里是错的，但还是没选出来；\nint arr[20];int (&amp;ref1)[20] = arr;// 正确的数组引用int&amp; ref2[20] = arr;  // 错误的引用\n\n2.内联函数2.1基本形式在函数名前用inline修饰的函数是内联函数，编译器在处理此类函数的时候，会将函数在调用它的地方打开。此时内联函数就没有函数压栈的开销，提高了程序运行的效率\n\n这部分和C语言学习过的#define类似，但define是直接替换，内联函数不是\n\n#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;#define ADD(a,b) ((a)+(b))inline int Add(int a,int b)&#123;  return a+b;&#125;int main ()&#123;  int sum=ADD(1+3,2+4);//4+6=10       printf(&quot;%d\\n&quot;, sum);   int ret = 0;  ret=Add(3,4);  return 0;&#125;\n\n2.2查看预处理文件使用下面的Linux语句可以把源文件生成为预处理后的文件\n\n这部分可以看看我之前用树莓派操作的博客哦！【传送门】\n\ng++ -E test.cpp -o test.i\n\n可以看到define被替换了，但是内联函数并没有\n\n2.3查看汇编代码①Linux环境这时候我们先编译这个文件\ng++ test.cpp\n\n然后使用下面的语句查看汇编代码\nobjdump -S a.out\n\n然后你就发现，这不还是有call函数调用嘛？这哪里没有调用呢？\n\n实际上，我们在编译的时候需要调整编译器的优化操作👉【参考博客】\ng++ -O2 test.cpp\n\n这时候的汇编代码就没有call了\n\n②VS2019要想调整VS2019的优化等价，需要在项目属性中C/C++ -常规中修改调试信息格式为“程序数据库”\n\n然后在优化-内联函数扩展修改成只适用于inline(/Ob1)\n\n然后调试，右键转到反汇编，可以看到，no call🕵️‍♂️\n\n\n2.4内联函数的特性define没有传参检查，且不能debug+可读性不高，内联函数解决了这一缺点\n\n内联函数是用空间换时间的做法，省去函数调用的开销\n函数代码很长的时候不适合用内联函数（define同理）\n在代码行数很长的时候，编译器会自己判断是否使用inline。如果函数体内有循环&#x2F;递归等，编译器优化的时候会取消内联\ninline不可以声明和定义分离，会导致链接错误\n\n对最后一点展开介绍一下，当我们把内联函数的声明和定义放在不同的源文件和头文件中，编译器会报错找不到函数\n\n这是因为内联函数在调用的时候已经展开了，对应的函数地址也没了，所以无法正常链接\n\n结语引用和内联函数的博客到这就结束啦，如果对你有帮助，还请点个赞再走哦！\n\n笔记难免有错，还请大佬们无情指出！\n\n","categories":["遇见C++"],"tags":["Linux","C++"]},{"title":"【C++】thread|mutex|atomic|condition_variable","url":"/posts/1249427441/","content":"本篇博客，让我们来认识一下C++中的线程操作\n\n\n\n所用编译器：vs2019\n阅读本文前，建议先了解线程的概念 👉 线程概念\n\n1.基本介绍在不同的操作系统，windows、linux、mac上，都会对多线程操作提供自己的系统调用接口\n为什么C++需要封装一个线程？直接用系统的接口不好吗？\n在Linux文件博客中，已经谈过了这一点：对于C++、python、java这些跨平台的语言来说，如果直接用系统的接口，是可以实现对应操作的。但是，这样会导致代码只能在某一个特定平台，甚至是某一个版本的特定操作系统上才能正常运行，直接与跨平台的特性相违背。\n解决的办法呢，就是对系统的接口套一个语言级别的软件层，封装系统的接口。并用条件编译的方式来识别不同的操作系统，已调用不同操作系统的系统接口，以实现跨平台性\n2.thread类\nhttps://legacy.cplusplus.com/reference/thread/thread/thread/\n\n2.1 构造&#x2F;赋值\n\n线程是不允许拷贝构造和赋值重载的，但是其支持右值引用的重载（主要是为了匿名对象构造）也支持空构造\n\n右值：无法进行取地址的变量\n\n2.2 get_id对于线程而言，比较重要的就是这个id号了，其用于标识线程的唯一性\n\n2.3 join&#x2F;detach创建好了一个线程，我们需要进行join等待或者detach分离\n\n如果主线程不需要获取子进程执行的结果，可以直接执行detach\n如果需要等待子线程执行，则执行join\n\n为什么会产生这两个分歧呢？是因为join等待是有一定消耗的。如果我们不关心线程执行的返回值，应该采用detach尽量减小消耗\n2.4 使用示例相比于Linux系统提供的pthread接口，C++的使用方法更加直接\n#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void Add(int a, int b)&#123;\tcout &lt;&lt; a + b &lt;&lt; endl;;&#125;int main()&#123;\tthread t1(Add, 10, 20);\tthread t2(Add, 10, 30);\tt1.join();\tt2.join();\treturn 0;&#125;\n\n\n2.5 空构造和移动赋值如果我们只是定义了一个t1，没有直接调用构造函数指定其要运行的函数（其实是调用了空构造）那么要怎么给这个线程指定函数呢？\nthread t3;//调用了空构造\n\n别忘了，虽然线程不支持拷贝构造，但他有移动赋值！\nthread&amp; operator= (thread&amp;&amp; rhs) noexcept;\n\n我们要做的，就是采用匿名对象的方式，赋值给t3\nthread t3;t3 = thread(Add, 20, 30);t3.join();\n\n\n2.6 joinablebool joinable() const noexcept;\n\n这个函数的作用是标识一个线程是否还能进行join；下面几种情况，线程不能被join\n\n只调用了空构造（都没有指定需要运行的函数怎么join等待？）\n被move了（move会将对象变成将亡值，也就是右值）\n该对象已经调用过join或者detach\n\n如果是在多层函数中调用的线程，那可能join之前就可以判断一下当前对象是否还能join\n2.7 swap&#x2F;movevoid swap (thread&amp; x) noexcept;\n\n该成员函数的作用是将另外一个线程切换给当前线程\n\n其本质就是一个move移动赋值\n\n被移动后的线程t3不再joinable，不会运行，也不能被join或detach\n\n强行join会报错\n\n2.8 linux下编译由于std是对系统接口进行的封装\n所以在linux下编译带c++线程库的代码时，需要带上pthread库的选项\ng++ test.cpp -o test -std=c++11 -lpthread\n\n3.std::ref这里有一个特殊的函数ref，要想知道其作用，我们需要先看下面这个场景\n3.1 引用传参#define _CRT_SECURE_NO_WARNINGS 1//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;functional&gt;using namespace std;void Print(int n,int&amp; a)&#123;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; &quot; &lt;&lt;  a++ &lt;&lt; endl;\t&#125;&#125;int main()&#123;\tint count = 0;\tthread t1(Print,10, count);\tthread t2(Print,10, count);\tt1.join();\tt2.join();\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; count &lt;&lt; endl;\treturn 0;&#125;\n\n在这个场景中，我想达到的目标是让t1和t2两个线程帮我们对count进行++，最终在main里面打印结果；可编译会发现报错，不给我们这样写\n\n相同的代码在linux下也出现了编译错误，所用g++版本如下\ng++ (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9)\n\n\n为了确认具体的报错位置，我们先把int&amp; a的引用去掉，再看看情况\n\n能看到，在没有采用引用传参的情况下，函数中对count进行的操作并不会反馈到main中，因为采用的是传值，会进行拷贝。\n3.2 thread构造函数那为什么加上引用之后，会报错呢？这就和thread的构造函数有关系了\ntemplate &lt;class Fn, class... Args&gt;explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;... args);\n\n如上，当我们构造一个线程对象的时候，采用的是可变模板参数；在我的博客中写到过，可变模板参数需要采用递归来进行参数类型的推测。\n由于底层实现的问题（也只能是这个原因了）在进行构造的完美转发时，所有的参数都采用了拷贝而不是引用传参。\n这也就导致我们没有办法将一个参数通过引用传入线程需要执行的函数！\n\n用指针肯定是可以的，可C++搞出引用这个东西，就是为了避免使用指针\n\n3.3 ref出场\nhttps://legacy.cplusplus.com/reference/functional/ref/?kw=ref\n\n于是乎，std库中就新增了一个库函数ref，来解决这个问题\n// ref的用法template &lt;class T&gt; reference_wrapper&lt;T&gt; ref (T&amp; elem) noexcept;template &lt;class T&gt; reference_wrapper&lt;T&gt; ref (reference_wrapper&lt;T&gt;&amp; x) noexcept;\ttemplate &lt;class T&gt; void ref (const T&amp;&amp;) = delete;\n\n\nConstructs an object of the appropriate reference_wrapper type to hold a reference to elem.\nIf the argument is itself a reference_wrapper (2), it creates a copy of x instead.\nThe function calls the proper reference_wrapper constructor.\n\n这个函数会构造一个合适的reference_wrapper对象，来管理一个变量的引用。如果参数本身就是reference_wrapper类型，则会调用reference_wrapper的拷贝构造。\n而ref函数不能传递右值，其右值引用的重载是被delete的\n\n3.4 ref使用thread t1(Print,10, ref(count));thread t2(Print,10, ref(count));t1.join();t2.join();\n\n使用了该库函数之后，编译不再报错，main中的值也成功被修改\n\n通过ref传递的参数，也会遵守函数本身的变量规则。如果函数本身没有采用引用传参，则还是调用传值参数，会进行拷贝；\n\n为了避免后续出现这种问题，可以给所有对线程的左值传参都带上ref😏比如给两个线程函数传入同一把锁的时候，就需要采用ref进行引用传参\n4.指令重排\n谈谈指令重排 - 知乎\n面试官: 有了解过指令重排吗，什么是happens-before\n\n4.1 什么是重排序首先，什么是重排序❓计算机在执行过程中，为了提高性能，会对编译器和编译器做指令重排。\n这么做为啥可以提高性能呢❓\n我们知道计算机在执行的时候都是一个个指令去执行，不同的指令可能操作的硬件不一样，在执行的过程中可能会产生中断。\n打个比方，两个指令a和b他们操作的东西各不相同，如果加载a的时候停顿了，b就加载不到，但是实际上它们互补影响，我也可以先加载b在加载a，所以指令重排是减少停顿的一种方法，这样大大提高了效率。\n4.1.1 指令重排的方式指令重排一般分为以下三种\n\n编译器优化 重新安排语句的执行顺序\n指令并行重排 利用指令级并行技术将多个指令并行执行，如果指令之前没有数据依赖，处理器可以改变对应机器指令的执行顺序\n内存系统重排 由于处理使用缓存和读写缓冲区，所以它们是乱序的\n\n指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致**。所以在多线程下，指令重排序可能会导致一些问题\n4.2 实际场景以懒汉的单例模式为例\n// 获取单例对象static InfoMgr* GetInstance()&#123;    if (_sp == nullptr)//第一次检测保证单例    &#123;        unique_lock&lt;mutex&gt; lock(_mtx);        if (_sp == nullptr)//第二次检测保证线程安全        &#123;            _sp = new InfoMgr;        &#125;    &#125;    return _sp;&#125;\n\n一般情况下，new一个新对象，执行的顺序应该是这样的\noperator new构造对象赋值给_sp\n\n但编译器如果进行了指令重排，可能就会变成这样\noperator new赋值给_sp构造对象\n\n如果一个线程执行到第二步赋值给_sp的时候，因为时间片到了被切换走了；其他线程来获取单例，就会导致_sp变量是一个已经被赋值了，但是其指向的是没有初始化的空对象，这是错误的！\n4.3 可行的解决办法：内存栅栏所谓内存栅栏，是系统提供的的接口，用于禁止cpu对指令的优化；\n\nhttps://blog.csdn.net/qq_16498553/article/details/128030833\n\n但内存栈栏是系统接口，没有跨平台性；这里只做了解，知道有这个问题即可！\n\n在一般情况下，我们不需要担心4.2中提到的问题，因为指令优化是有严格规则的，不会对赋值和构造这类指令进行胡乱优化（因为这样优化并不会有效率提升啊）\n但这也需要看具体平台的底层实现了！\n5.获取线程返回值5.1 输出型参数在C语言中，想获取线程返回值，需要使用输出型参数（C++可以用引用传值）\nint Add(int a, int b,int&amp; out)&#123;\tout = a + b;\treturn out;&#125;void test2()&#123;\tint ret = 0;\tthread t2(Add, 10, 39, ref(ret));\tt2.join();\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; ret &lt;&lt; endl;&#125;\n\n\n5.2 lambda在C++中，还可以使用lambda表达式，来在main中获取线程的返回值\nint Add(int a, int b)&#123;\treturn a + b;&#125;void test2()&#123;\tint ret = 0;\tthread t1([&amp;ret]() &#123; ret = Add(10, 29); &#125;);\tt1.join();\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; ret &lt;&lt; endl;&#125;\n\n\n6.函数重载问题在我测试的时候发现，如果一个函数具有重载，线程是不支持的；\n具体的原因嘛，我猜和线程构造的可变模板参数有关系。\n\n百度了一下，解决办法，是给第一个参数传入一个函数指针或者fuctional对象，手动指定使用的是哪一个函数。\n当然，还有一个解决办法：线程调用的函数不要有重载😂\nint Add(int a, int b,int&amp; out)&#123;\tout = a + b;\treturn out;&#125;int Add(int a, int b)&#123;\tint tmp = a + b;\tcout &lt;&lt; tmp &lt;&lt; endl;;\treturn tmp;&#125;void test2()&#123;\tint ret = 0;\t// 使用函数指针指定对应的函数\tthread t2(static_cast&lt;int(*)(int a, int b, int&amp; out)&gt;(Add), 10, 39, ref(ret));\tt2.join();\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; ret &lt;&lt; endl;&#125;\n\n\n7.this_threadstd库中还用命名空间对线程的一些操作进行了封装\n\n\nget_id 获取线程id号（其实线程类里面已经有这个东东了，但是为了方便函数中直接调用，又多开了一个函数）\nyield 放弃自己的时间片\nsleep_until 休眠到一个时间点（比如睡到明天早八）\nsleep_for 休眠一定时间（睡2分钟）\n\n下面来对后面三个函数做一点解释（第一个就不解释了哈）\n7.1 yieldyield的作用是让出当前线程的时间片；\n我们知道每一个线程运行时都会有一个自己的时间片，时间片到了，就会进行线程的切换；\n以下面的场景为例\nvolatile bool ready = false;void count1m(int id) &#123;\t// 如果main没有设置ready信号，线程会一直让出自己的时间片，不会运行\twhile (!ready) \t&#123;            \t\tthis_thread::yield();\t&#125;\t// 开始运行，++数据\tvolatile int i = 0;\tfor (i=0; i &lt; 10000000; i++) \t&#123; \t\t; // 循环体啥都不干\t&#125;\tcout &lt;&lt; id;&#125;void test4()&#123;\tthread threads[10];\tcout &lt;&lt; &quot;创建10个线程 计数\\n&quot;;\tfor (int i = 0; i &lt; 10; ++i) \t&#123;\t\tthreads[i] = thread(count1m, i);\t&#125;\tcout &lt;&lt; &quot;创建10个线程 完毕\\n&quot;;\tready = true;//设置状态，让线程开始运行\tcout &lt;&lt; &quot;main set ture: &quot; &lt;&lt; ready &lt;&lt; &quot;\\n&quot;;\tfor (auto&amp; th : threads) \t&#123;\t\tth.join();\t&#125;\tcout &lt;&lt; &quot;\\nmain join 成功&quot; &lt;&lt; &quot;\\n&quot;;&#125;\n\n执行结果\n创建10个线程 计数创建10个线程 完毕main set ture: 13746089215main join 成功\n\n在这个场景中，每一个线程被设置了task后，都会先进入一个while循环，等待主线程进行ready的设置\nwhile (!ready) &#123;            \t;&#125;\n\n此时我们就可以在while循环中进行yield让线程让出自己的时间片。否则这个线程会一直疯狂访问ready，导致cpu占用提高。\n// 如果main没有设置ready信号，线程会一直让出自己的时间片，不会运行while (!ready) &#123;            \tthis_thread::yield();&#125;\n\n在这种轮询检测的场景下，使用yield能避免某一个线程长时间占用执行流，解决了其他线程的饥饿问题。\n7.2 sleep_until用cplusplus的示例代码来学习使用方法，这里涉及到了多个库函数，详见注释\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;  //std::chrono#include &lt;iomanip&gt; //std::put_time#include &lt;ctime&gt;   //std::time_t, std::tm, std::localtime, std::mktimeusing namespace std;// 直接把main当作一个线程void test5()&#123;\ttime_t tt = chrono::system_clock::to_time_t(chrono::system_clock::now()); // 获取当前时间的时间戳\tstruct tm* ptm = localtime(&amp;tt); // 设置一个tm结构体，从当前时间戳创建\tcout &lt;&lt; &quot;Current time: &quot; &lt;&lt; put_time(ptm, &quot;%X&quot;) &lt;&lt; &#x27;\\n&#x27;; // 打印当前时间\tcout &lt;&lt; &quot;Waiting for the next minute to begin...\\n&quot;;\t(ptm-&gt;tm_min)++; // 设置ptm的min为下一分钟\tptm-&gt;tm_sec = 0; // 下一分钟的第0s\tthis_thread::sleep_until(chrono::system_clock::from_time_t(mktime(ptm))); // 等待下一分钟开始运行\tcout &lt;&lt; put_time(ptm, &quot;%X&quot;) &lt;&lt; &quot; reached!\\n&quot;; // 再次打印当前时间&#125;\n\n运行结果如下，会等到下一分钟的第0s继续执行\nCurrent time: 15:13:40Waiting for the next minute to begin...15:14:00 reached!\n\n7.3 sleep_for这个函数的作用和windows、linux下都有的sleep函数一样，是睡指定的时间\n需要用std中的chrono模块来指定运行的时间，支持从小时一直到纳秒\n\n示例如下\nvoid test6()&#123;\ttime_t now;\ttime(&amp;now);//获取当前时间戳\tcout &lt;&lt; now &lt;&lt; endl;\tthis_thread::sleep_for(chrono::seconds(30));//睡30s\ttime(&amp;now);//获取当前时间戳\tcout &lt;&lt; now &lt;&lt; endl;&#125;\n\n可以看到，进程确实休眠了30s\n\n8.mutex有了线程，那肯定离不开锁；关于线程加锁的问题，详见我的linux博客\n这里只对C++中锁的只用方法做一定演示\n8.1 构造\n锁的构造相对较简单，只有一个无参的构造，其不支持拷贝构造（比如函数传参中，一个锁被拷贝了，就失去了意义）\n8.2 成员函数其余成员就是一个锁的基本接口，对应的也是pthread_mutex中的几个接口\n\nlock 加锁，不能申请锁则阻塞等待\ntry_lock 测试是否能申请锁，不能申请则return\nunlock 解锁\n\n\n8.3 场景所谓加锁，保护的就是临界资源；比如在下面的代码示例中，全局变量count1就是一个临界资源，其能够被多个执行流访问。\n注意：如果你展开了std命名空间，其中有一个count函数，会和你自己定义的全局count变量冲突。刚开始我就定义了count，发现报错变量不明确。\n#define TOP 100volatile int count1 = 0;void func()&#123;\twhile(1)\t&#123;\t\tif (count1 == TOP)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; count1++ &lt;&lt; endl;\t\tthis_thread::sleep_for(chrono::milliseconds(10));\t&#125;\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; count1 &lt;&lt; endl;&#125;void test7()&#123;\tthread threading[10];\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tthreading[i] = thread(func);\t&#125;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tthreading[i].join();\t&#125;\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; count1 &lt;&lt; endl;\tthis_thread::sleep_for(chrono::seconds(2));&#125;\n\n测试的时候，就能看到一个很明显的冲突结果。31752线程已经++到100了，结果它努力的结果被其他两个线程直接复写；\n当然，这里也有可能是显示器乱序打印的结果。要知道，显示器也是一个临界资源\n\nmutex mtx;void func()&#123;\twhile(1)\t&#123;\t\t\t\tif (count1 == TOP)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\t// 加锁的粒度要低\t\tmtx.lock();\t\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; count1++ &lt;&lt; endl;\t\tmtx.unlock();\t\tthis_thread::sleep_for(chrono::milliseconds(10));\t&#125;\tcout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; count1 &lt;&lt; endl;&#125;\n\n给访问count的函数添加上锁，就能避免掉上面出现的问题\n\n9.CAS原子操作在系统中，提供了一些指令，来实现原子操作！\n9.1 原理Compare And Set（或Compare And Swap），简称CAS。其是解决多线程并行情况下使用锁造成性能损耗的一种机制，采用这种无锁的原子操作可以实现线程安全，避免加锁的笨重性。\nCAS操作包含三个操作数：内存位置（V）、预期原值（A）、新值(B)\n具体操作流程请看下图：\n\n如果上面的图看不懂，还可以看下面这个图\n\n文字描述如下：\n\n如果内存位置的值（V）与预期原值（A）相同，处理器会将该位置的值更新为新值（B） CAS 操作成功！\n否则，处理器不做任何更改，只需要将当前位置的值进行返回即可\n\nCAS是实现自旋锁的基础，CAS 利用CPU指令保证了操作的原子性，以达到锁的效果，循环这个指令，直到成功为止。\n9.2 问题CAS也不是万能的，其在如下场景下可能会出现问题\n1.有线程a和b2.有全局变量，初始值为13.线程a先来访问，拿走了初始值14.发生线程切换，线程b来访问，拿走初始值1，更新为2，又修改回15.发生线程切换，线程a继续访问，此时值依旧是1，线程a会认为没有问题，写入\n\n你可以看到，在上面的场景中，有一个线程把全局变量修改了之后又改了回去，这时候就没有办法从取值判断变量是否还是“原来的那个”了\n\n针对这种情况，java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。\n\nC&#x2F;C++中有没有办法解决这个问题呢？我没百度到😂\n10.lock_guard人如其名，这个类是一个守护锁。\ntemplate &lt;class Mutex&gt; class lock_guard;\n\n其运用了RAII的思路，能在构造的时候加锁，析构的时候解锁。我们就不需要自己操作了。\n毕竟，代码一长起来，一个锁有没有被解开，是真的搞不清楚😥\nmutex mtx;void test7()&#123;\tint x = 0;\tint n = 0;\tint m = 1000000;\tcin &gt;&gt; n;\tvector&lt;thread&gt; threading(n);\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tthreading[i] = thread([&amp;]() &#123;\t\t\tfor (int i = 0; i &lt; m; i++)\t\t\t&#123;\t\t\t\tlock_guard&lt;mutex&gt; t(mtx);//自动加锁解锁\t\t\t\tx++;\t\t\t&#125;\t\t&#125;);\t&#125;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tthreading[i].join();\t&#125;\tcout &lt;&lt; &quot;main: &quot; &lt;&lt; x &lt;&lt; endl;&#125;\n\n\n如果for循环中需要执行的代码很多，而只有x是临界资源的话，那就需要我们手动控制一下作用域&#123;&#125;\nfor (int i = 0; i &lt; m; i++)&#123;             //其他代码             &#123;                 lock_guard&lt;mutex&gt; t(mtx);//自动加锁解锁\t   x++;             &#125;             //其他代码&#125;\n\n11.unique_locktemplate &lt;class Mutex&gt; class unique_lock;\n\n如果你学习过智能指针，那肯定就知道这个命名的含义；\nunique_lock是lock_graud的增强版本，其在支持自动加锁解锁的前提下，还支持手动加锁解锁；\n11.1 使用示例下面就是一个标准的使用场景\nthreading[i] = thread([&amp;]() &#123;\tfor (int i = 0; i &lt; m; i++)\t&#123;\t\tunique_lock&lt;mutex&gt; t(mtx);//自动加锁\t\tx++;\t\tt.unlock(); //手动解锁\t\t// 模拟其他工作\t\tthis_thread::sleep_for(chrono::milliseconds(100));\t\t// 又需要访问临界资源\t\tt.lock();// 手动解锁\t\tx++;\t&#125;// 出作用域，自动解锁&#125;);\n\n11.2 try_lock除了最基础的try_lock之外，这个类还支持for和until，和this_thread中的sleep是一样的含义\ntry_lockLock mutex if not locked (public member function )try_lock_forTry to lock mutex during time span (public member function )加锁一直到指定时间解锁（加锁到明天早八）try_lock_untilTry to lock mutex until time point (public member function )加锁xx时间（加锁100秒，时间到了自动解锁）\n\n时间到了之后，这个函数会进行解锁。如果用户在这之前已经手动解锁了，则什么都不会做\n11.3 release这个函数的作用就很独特了，其将自己管理的锁释放掉，不再管理这个锁\nmutex_type* release() noexcept;\n\n调用这个函数会返回托管互斥对象的指针，释放其所有权。调用后，unique_lock对象不再管理任何互斥对象（即，它处于与if默认构造相同的状态）。\n 注意，此函数不会锁定或解锁返回的互斥对象。\n说人话就是，不需要你RALL来管理这个锁了，交给用户自己管理！\n12.shared_ptr\nshared_ptr的完整代码请看我的 Gitee\n\n在智能指针中，shared_ptr采用引用计数来判断有多少次拷贝（拷贝构造、赋值重载），只有拷贝计数器为1的时候，析构才需要释放资源。\n在shared_ptr内部有一个变量进行计数。既然有一个计数变量，那就需要保证多线程执行时的原子性！\n12.1 引用计数加锁void AddRef()//新增引用&#123;\t_pMutex-&gt;lock();\t++(*_pRefCount);\t_pMutex-&gt;unlock();&#125;\n\n12.2 释放void Release()&#123;\tbool flag = false;//判断锁是否需要被释放\t_pMutex-&gt;lock();\tif (--(*_pRefCount) == 0 &amp;&amp; _ptr)\t&#123;               //进入了这个函数，代表引用计数为0\t\tdelete _ptr;\t\tdelete _pRefCount;\t\t//标识需要释放锁\t\tflag = true;\t&#125;\t_pMutex-&gt;unlock();//解锁\t//释放锁\tif (flag)&#123;\t\tdelete _pMutex;           &#125;&#125;\n\n12.3 注意事项shared_ptr的加锁只限于这个类对象本身的安全性，这个锁并不是用来保护shared_ptr所指向的资源的！\n13.atomic在全局变量中，计数器是很常用的类型。所以C++中还提供了一个可以进行原子操作的类，对这个变量进行的操作是具有原子性的，不需要我们进行加锁解锁\ntemplate &lt;class T&gt; struct atomic;\n\n13.1 基本使用atomic&lt;int&gt; val=0;void test8()&#123;\tcout &lt;&lt; val &lt;&lt; endl;\tval++;\tcout &lt;&lt; val &lt;&lt; endl;\tval = 20;\tcout &lt;&lt; val &lt;&lt; endl;\tval--;\tcout &lt;&lt; val &lt;&lt; endl;&#125;\n\n如果是int类型，原子变量和普通的int变量的使用没有什么区别！\n\n可以看到，重载了以后，原子变量支持++  --，也支持直接赋值\n\n不过，这些方法标明了，只有整形家族和指针类型可以使用！\n\n13.2 operator &#x3D;原子变量可以直接赋值，是因为其重载了 operator =\n//set value (1)T operator= (T val) noexcept;T operator= (T val) volatile noexcept;//copy [deleted] (2)atomic&amp; operator= (const atomic&amp;) = delete;atomic&amp; operator= (const atomic&amp;) volatile = delete;\n\n13.3 operator T&#x2F;loadoperator T 的作用，是支持隐式类型转换，这样原子变量在进行if比较的时候，会转换成重载后的类型\noperator T() const volatile noexcept;operator T() const noexcept;\n\n在vs2019里面跳转源码，能看到重载后的这两个函数，其实是调用了load方法\ntemplate &lt;class _Ty&gt;struct atomic : _Choose_atomic_base_t&lt;_Ty&gt;&#123;    //...\toperator _Ty() const volatile noexcept &#123;        static_assert(_Deprecate_non_lock_free_volatile&lt;_Ty&gt;, &quot;Never fails&quot;);        return this-&gt;load();    &#125;    operator _Ty() const noexcept &#123;        return this-&gt;load();    &#125;&#125;\n\n\n查看cplusplus的解释，load方法就是返回了其内部所包含的值\nT load (memory_order sync = memory_order_seq_cst) const volatile noexcept;T load (memory_order sync = memory_order_seq_cst) const noexcept;\n\n\n这里还特意标注了，load方法的使用是原子性的\n13.4 exchangeT exchange (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;T exchange (T val, memory_order sync = memory_order_seq_cst) noexcept;\n\nexchange函数的作用是修改原子变量管理的值，其返回值是修改之前的变量\nReturn valueThe contained value before the call.T is atomic&#x27;s template parameter (the type of the contained value).\n\n以下面的代码为例\natomic&lt;int&gt; val=0;void test8()&#123;\tcout &lt;&lt; val &lt;&lt; endl;\tint tmp = val.exchange(450);\tcout &lt;&lt; val &lt;&lt; endl;\tcout &lt;&lt; tmp &lt;&lt; endl;&#125;\n\n可以看到tmp接收到的结果是val的初始值0，val本身被修改为450\n\n13.5 storevoid store (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;void store (T val, memory_order sync = memory_order_seq_cst) noexcept;\n\n这个函数的作用比exchange简单，其只修改存储的变量，没有返回值\n\n关于原子变量的介绍就这么多，下面来康康C++中的条件变量\n14.condition_variable\n条件变量的概念，参考 linux 线程同步\n\n14.1 构造和wait条件变量，是用于线程同步操作的一个接口。在C++中，条件变量只有一个空构造\n//default (1)\tcondition_variable();//copy [deleted] (2)\tcondition_variable (const condition_variable&amp;) = delete;\n\n当我们进行wait等待的时候，需要往条件变量内传入一个锁；进入wait函数，开始等待前会先解锁（解开你传入的这个锁），退出wait函数前会加锁。\n//unconditional (1)\tvoid wait (unique_lock&lt;mutex&gt;&amp; lck);//predicate (2)\ttemplate &lt;class Predicate&gt;  void wait (unique_lock&lt;mutex&gt;&amp; lck, Predicate pred);\n\nwait函数除了传入锁，还可以传入一个Predicate pred可执行函数体，来判断条件变量是否满足；\n如果指定了pred，则只有当pred返回false时，该函数才会阻塞；并且只有当它变为true时，通知才能解除阻塞线程（这对于检查虚假唤醒特别有用）\n\n虚假唤醒，指的是一些代码错误的情况下，另外一个线程在条件尚未真正就绪的时候就唤醒了该线程\n比如一个线程池，我们可以设置一个is_run的bool值，并在所有线程的条件变量wait的地方添加上一个lambda表达式来返回这个is_run。在执行线程池对象中的Run() 函数并唤醒所有线程之前，将is_run设置为true（需要加锁）。那么如果线程被唤醒、is_run又为假的时候，就代表当前线程池并没有真的启动，是一个虚假唤醒。\n添加上判断条件，能在wait中判断条件是否已经真正满足，从而避免虚假唤醒\n\nwait内部对pred的检测是下面这样\nwhile (!pred()) wait(lck);\n\n只有pred返回真的时候，才会跳出while循环，唤醒线程。\n除了检测虚假唤醒，我们还可以用该执行体，对不同的线程指定不同的唤醒条件！\n14.2 其他接口其他接口的使用也很直接，其中wait_for和until前面已经介绍过了\n\nwait：在条件变量中阻塞等待，等待被唤醒\nnotify_one：唤醒在该条件变量等待下的一个线程\nnotify_all：唤醒在该条件变量下等待的所有线程\n\n\n14.3 实际用例当下我们有两个线程，我们的目标是让t1和t2线程共同管理一个变量i，对其进行++，并实现t1打印奇数，t2打印偶数的功能（二者交错打印）\nvoid test9()&#123;\t// 目标：t1打印奇数，t2打印偶数，二者交错打印    bool ready = true;\tint i = 0;\tint n = 100;\tmutex mtx;\tcondition_variable cv;\t\t// t1打印奇数\tthread t1([&amp;]()&#123;\t\twhile (i &lt; n)\t\t&#123;            unique_lock&lt;mutex&gt; lock(mtx);            cout &lt;&lt; &quot;t1 : &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;            i++;\t\t&#125;\t&#125;);\t\t// t2打印偶数\tthread t2([&amp;]() &#123;\t\twhile (i &lt; n)\t\t&#123;\t\t\tunique_lock&lt;mutex&gt; lock(mtx);\t\t\tcout &lt;&lt;&quot;t2 : &quot;&lt;&lt;this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;\t\t\ti++;\t\t&#125;\t&#125;);\t\tthis_thread::sleep_for(chrono::seconds(3));\t\tcout &lt;&lt; &quot;t1:&quot; &lt;&lt; t1.get_id() &lt;&lt; endl;\tcout &lt;&lt; &quot;t2:&quot; &lt;&lt; t2.get_id() &lt;&lt; endl;\t\tt1.join();\tt2.join();\t&#125;\n\n当下已经实现出了二者的基本操作，但直接运行我们会发现，t1都已经打印到99了，t2才开始执行，完全不符合交错打印的需求\n\nthread t1([&amp;]()&#123;\twhile (i &lt; n)\t&#123;\t\t&#123;\t\t\tunique_lock&lt;mutex&gt; lock(mtx);\t\t\tcout &lt;&lt; &quot;t1 : &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;\t\t\ti++;\t\t&#125;\t\tthis_thread::sleep_for(chrono::microseconds(100));\t&#125;&#125;);\n\n如果在t1的while循环中加上一个休眠，t2的函数体保持不变，则会发现是t2直接加到了99，才让可怜巴巴的t1访问了临界资源（饥饿问题）\n\n这时候，我们就可以使用条件变量来实现线程相互唤醒和交错打印，代码如下\n// 条件变量测试void test9()&#123;\t// 目标：t1打印奇数，t2打印偶数，二者交错打印\tbool ready = true;\tint i = 0;\tint n = 100;\tmutex mtx;\tcondition_variable cv;\t\t// t1打印奇数\tthread t1([&amp;]()&#123;\t\twhile (i &lt; n)\t\t&#123;            unique_lock&lt;mutex&gt; lock(mtx);            //ready为假的时候，唤醒t1            cv.wait(lock, [&amp;ready]()&#123;return !ready; &#125;);            cout &lt;&lt; &quot;t1 : &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;            i++;            ready = true;            cv.notify_one();\t\t&#125;\t&#125;);\t\t// t2打印偶数\tthread t2([&amp;]() &#123;\t\twhile (i &lt; n)\t\t&#123;\t\t\tunique_lock&lt;mutex&gt; lock(mtx);             //ready为真的时候，唤醒t2\t\t\tcv.wait(lock, [&amp;ready]()&#123;return ready; &#125;);\t\t\t\tcout &lt;&lt;&quot;t2 : &quot;&lt;&lt;this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl;\t\t\ti++;\t\t\tready = false;\t\t\t\tcv.notify_one();\t\t&#125;\t&#125;);\t\tthis_thread::sleep_for(chrono::seconds(3));\t\tcout &lt;&lt; &quot;t1:&quot; &lt;&lt; t1.get_id() &lt;&lt; endl;\tcout &lt;&lt; &quot;t2:&quot; &lt;&lt; t2.get_id() &lt;&lt; endl;\t\tt1.join();\tt2.join();\t&#125;\n\n运行一下，可以看到我们成功通过条件变量，使这两个线程交错打印奇偶数！\nt2 : 23208 : 0t1 : 24896 : 1t2 : 23208 : 2t1 : 24896 : 3t2 : 23208 : 4t1 : 24896 : 5t2 : 23208 : 6t1 : 24896 : 7t2 : 23208 : 8t1 : 24896 : 9t2 : 23208 : 10t1 : 24896 : 11//....t2 : 23208 : 90t1 : 24896 : 91t2 : 23208 : 92t1 : 24896 : 93t2 : 23208 : 94t1 : 24896 : 95t2 : 23208 : 96t1 : 24896 : 97t2 : 23208 : 98t1 : 24896 : 99t2 : 23208 : 100\n\n即便在t1中额外加上休眠，也不会影响输出结果的准确性！\n\n这便是条件变量对于线程同步控制的用法\n结语在学习过linux的线程基础和系统接口后，理解C++这里的多线程操作还算轻松！\nC++语法学习的最后一块拼图也被补上了！\n\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】构造函数和初始化列表的性能差距","url":"/posts/2628258650/","content":"构造函数和初始化列表的性能差距对比测试\n\n\n1.说明在C++类和对象中，你可能听到过更加推荐用初始化列表来初始化类内成员。如果类内成员是自定义类型，则只能在初始化列表中调用自定义类型的构造函数。\n但初始化列表和在构造函数体内直接赋值有无性能差距呢？今天就用一份相对简单的代码来测试一下\n2.测试2.1 代码说明首先是一个自定义类型，实现带缺省值的默认构造，拷贝构造和赋值重载这三个函数，并在内部新增打印来区分不同的函数\nstruct mytest &#123;public:    mytest(int a = -1)    &#123;        _a = a;        cout &lt;&lt; &quot;mytest() &quot; &lt;&lt; a &lt;&lt; endl;    &#125;    mytest(const mytest&amp; st) &#123;        _a = st._a;        cout &lt;&lt; &quot;mytest(copy) &quot; &lt;&lt; st._a &lt;&lt; endl;    &#125;    mytest&amp; operator=(const mytest&amp; st)    &#123;        _a = st._a;        cout &lt;&lt; &quot;mytest operator= &quot; &lt;&lt; st._a &lt;&lt; endl;        return *this;    &#125;private:    int _a;&#125;;\n\n再在另外一个类中使用这个自定义类型\nstruct myclass &#123;public:    myclass(const struct mytest&amp; st, int b)    &#123;        cout &lt;&lt; &quot;myclass() _b:&quot; &lt;&lt; _b &lt;&lt; endl;    &#125;    struct mytest _sa;    int _b;&#125;;\n\n此时构造函数就有两种写法，一种是在初始化列表中初始化这个自定义类型\nmyclass(const struct mytest&amp; st, int b)       :_sa(st),       _b(b)   &#123;       cout &lt;&lt; &quot;myclass() _b:&quot; &lt;&lt; _b &lt;&lt; endl;   &#125;\n\n另外一种是在构造函数体内通过赋值重载来初始化这个自定义类型\nmyclass(const struct mytest&amp; st, int b)&#123;     _sa = st;     _b = b;    cout &lt;&lt; &quot;myclass() _b:&quot; &lt;&lt; _b &lt;&lt; endl;&#125;\n\n需要注意的是，这里的自定义类型传参采用了引用传参，并不会因此产生额外的拷贝！\n主函数体如下，为了区分第一个mytest的构造函数，我在其后新增了一行输出作为分割\nint main()&#123;    mytest test_a(1);    cout &lt;&lt; &quot;------&quot; &lt;&lt; endl;    myclass test(test_a, 3);    return 0;&#125;\n\n2.2 测试先来看看使用赋值初始化的方式，可以看到，虽然我们在初始化列表中什么都没有写，但是这里依旧调用了默认的构造函数（因为默认构造函数的缺省值给的是-1，这里能通过参数判断出来这并不是我们显式调用的构造）\n调用了默认构造后，又通过赋值重载来初始化了一遍_sa，相当于两次初始化\n\n但如果调用初始化列表，则只会有一次拷贝构造，避免了额外的默认构造调用！\n\n在linux下也测试过了，结果和VS2019相同\n3.结论结论就出来了：初始化列表能节省一次默认构造的调用，优化性能！\n3.1 实际场景在上面的场景中，性能差距可能并不会特别大，但是在下面的场景中可能就不一样了\nstruct mytest &#123;public:    mytest(int sz = 1)    &#123;        _str = new char[sz];        _sz = sz;        cout &lt;&lt; &quot;mytest() &quot; &lt;&lt; sz &lt;&lt; endl;    &#125;    mytest(const mytest&amp; st) &#123;        delete _str;// 需要先销毁原视的数据        _str = new char[st._sz]; // 再创建一个新的        _sz = st._sz;        //省略拷贝数据的代码        cout &lt;&lt; &quot;mytest(copy) &quot; &lt;&lt; st._sz &lt;&lt; endl;    &#125;    mytest&amp; operator=(const mytest&amp; st)    &#123;        delete _str;// 需要先销毁原视的数据        _str = new char[st._sz]; // 再创建一个新的        //省略拷贝数据的代码        cout &lt;&lt; &quot;mytest&amp; operator= &quot; &lt;&lt; st._sz &lt;&lt; endl;        return *this;    &#125;private:    char* _str;    size_t _sz;&#125;;struct myclass &#123;public:    myclass(const struct mytest&amp; st, int b)        :_sa(st),        _b(b)    &#123;         //_sa = st;         //_b = b;        cout &lt;&lt; &quot;myclass() _b:&quot; &lt;&lt; _b &lt;&lt; endl;    &#125;    struct mytest _sa;    int _b;&#125;;\n\n在这个场景中，因为mytest自定义类型的拷贝构造涉及到了深拷贝，此时就需要将已有的空间给销毁了，再new一片新的空间出来，再将数据给拷贝过去。\n白白多了一层默认构造中的new空间的+拷贝构造中delete原有空间的消耗！\n如果类中需要深拷贝的成员不止一个，那性能差距就更大！\n所以在C++中，一律以初始化列表优先！\n\n这里顺带提一嘴初始化列表的小坑，也算是复习；\n当你使用初始化列表来初始化类内成员的时候，初始化的顺序是类内成员声明的顺序，而不是初始化列表中的顺序！这点非常重要，如果顺序不对，可能会出现使用未定义（还没有初始化完成）的参数的bug！\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++11】future和async等","url":"/posts/2885143113/","content":"C++11的future和async等关键字\n\n\n1.async和future的概念std::async 和 std::future 是 C++11 引入的标准库功能，用于实现异步编程，使得在多线程环境中更容易处理并行任务。它们可以帮助你在不同线程中执行函数，并且能够方便地获取函数的结果。\n在之前使用线程的时候，我们没有办法很好的获取到线程所执行函数的返回值。甚至更多时候，我们使用线程执行的都是不关心返回值的函数。如果真的想要获取线程函数的返回值，可以将一个指针作为输出型参数放入线程所执行的函数中。主执行流执行t.join()等待线程执行结束，并获取到这个返回值。\n但这样并不是非常方便。于是C++11就引入了如上两个关键字来帮助我们获取到线程所执行函数的返回值。适用于异步执行某些耗时的函数，提高程序运行的效率：\n\n异步执行耗时函数\n主执行流干其他事情\n通过std::future获取到返回值\n继续向后执行\n\n基本的并行概念在多线程部分都已经讲过了，这里就不多bb，直接上代码吧！\n2.使用2.1 std::launch在使用std::async之前，还需要认识一个枚举类型 launch，在使用std::async的函数传参的时候会用到（这里先说一下，std::async是用来帮我们创建线程的）\nenum class launch; // std::launch\n\n在 cplusplus网站上，有这个枚举类型的释义，这里面只有俩值\n\n说一下这俩值的区别\n\nlaunch::async，立即创建一个线程来执行目标函数\nlaunch::deferred，不立即创建线程，而是等待调用std::future的get()函数时才调用（这个get函数是用来获取返回值的）\n\n好了知道这个就够了哈！\n2.2 std::result_of这里还出现了另外一个关键字，就顺带也说说是干嘛的（其实我自己也不知道，现学现卖）\n#include &lt;type_traits&gt; // 头文件template &lt;class Fn&gt;struct result_of;template &lt;class Fn, class... ArgTypes&gt;struct result_of&lt;Fn(ArgTypes...)&gt;;\n\n以下是 std::result_of 的基本用法和概念：\n\n使用 std::result_of 获取函数调用的返回类型： 你可以通过将函数类型和参数类型传递给 std::result_of 来推导函数调用的返回类型。这使得你可以在编译时获取函数调用的结果类型，而不需要手动指定它。\n用法示例： 假设有一个函数 int add(int a, int b)，你可以使用 std::result_of 来获取该函数在给定参数下的返回类型。\n\n#include &lt;iostream&gt;#include &lt;type_traits&gt;int add(int a, int b)&#123;    return a + b;&#125;int main()&#123;    std::result_of&lt;decltype(add) &amp;(int, int)&gt;::type result = add(3, 5);    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;\n\n运行结果如下\n$ g++ test.cpp -o test -std=c++11$ ./testResult: 8\n\n需要注意的是，使用decltype关键字来指定函数指针的时候，函数名和函数参数之间需要加上&amp;，否则无法正确推导类型\ndecltype(add) &amp;(int, int) // 正确decltype(add) (int, int) // 错误    \n\n2.3 async先来看看async函数的样本，第一个情况是不显示传入 std::launch，第二个函数重载是传入了std::launch作为启动策略\n#include &lt;future&gt; // 头文件// unspecified policy (1)\ttemplate &lt;class Fn, class... Args&gt;  future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;    async (Fn&amp;&amp; fn, Args&amp;&amp;... args);// specific policy (2)\ttemplate &lt;class Fn, class... Args&gt;  future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;    async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);\n\n在cplusplus网站上，说到了第一种情况是由编译器自主决定到底是采用 std::launch::async 或 std::launch::deferred，这就需要根据平台和编译器实现以及调用逻辑的不同来具体分析了。所以不建议使用第一个，还是直接指定launch policy（翻译过来是启动策略）的会好一点。\n所以只看第二个👇\ntemplate &lt;class Fn, class... Args&gt;  future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;    async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);\n\n这里采用了可变模板参数来接收多个函数参数，类似于可变参数列表。这里还使用了typename关键字来告知编译器result_of&lt;Fn(Args...)&gt;::type是一个参数类型，需要在模板实例化了之后再去获取确定的类型。而class Fn是一个函数指针的模板变量。\n\n第一个参数是std::launch，上文已经提到过两个不同选项的区别了\n第二个参数是函数，直接丢函数名就可以了\n第三个参数是这个函数的参数，也是直接丢参数就可以了\n\n如下是一个简单的调用示例（并非完整示例）\n#include &lt;future&gt; // 头文件// 函数int add(int a, int b) &#123;    return a + b;&#125;// 调用std::async(std::launch::async, add, 3, 5);\n\n调用了这个函数后，CPP会帮我们创建一个线程来执行函数，并根据第一个启动参数的不同，决定啥时候创建这个线程。最终我们可以通过future获取到线程执行函数的返回值。\n2.4 future人如其名，这个类型是用来声明一个未来的变量的。因为std::async会帮我们创建一个线程来执行函数，此时该线程函数的返回值是未知的，这个未来变量就是提前的一个声明，当线程执行完毕函数并返回值的时候，这个变量的值才真正被初始化为我们真正需要的那个值。\ntemplate &lt;class T&gt;  future;// specialization : T is a reference type (R&amp;)template &lt;class R&amp;&gt; future&lt;R&amp;&gt;;     // specialization : T is voidtemplate &lt;&gt;         future&lt;void&gt;;  \n\n其有如下几个成员函数\n\nget：获取对应async所执行函数的返回值，如果函数没有执行完毕则阻塞等待\nvalid：bool，判断当前future类型到底有没有和一个async函数所对应\nshare：将future对象转成一个std::shared_future对象\nwait：等待异步任务完成，但不获取结果\nwait_for：等待异步任务完成，但有等待的时长（没等到就返回错误）\nwait_until：等待异步任务完成，直到一个确定的时间（没等到就返回错误）\n\n后面三个 wait 函数和 CPP 线程中的 wait 函数如出一辙。\n2.5 share_futureshare_future就好比share_ptr智能指针，其让future对象从单一所有权变成了多人可用。本来是一个只能坐一人的餐桌，现在变成了可以坐很多人的大桌子。\ntemplate &lt;class T&gt;  shared_future;template &lt;class R&amp;&gt; shared_future&lt;R&amp;&gt;;   // specialization : T is a reference type (R&amp;)template &lt;&gt;         shared_future&lt;void&gt;; // specialization : T is void\n\n成员函数和future完全一样（只不过么有share()函数）这里就不赘述了；\n\nfuture是单人餐桌，一次只能有一个线程执行get函数；当get被执行后，这个future会失效。\nshare_future是大桌子，所有人一起坐在这个桌子上等服务员上菜，互不干扰；\n\n当一个函数的返回值需要在多个线程中被共享使用的时候，就可以用shared_future了。\n2.5 测试2.5.1 正常测试如下代码是一个简单的使用示例，并且通过提供不同的std::launch启动策略，我们也能观察到不同的现象\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;type_traits&gt; // result_of#include &lt;sys/unistd.h&gt; //sleepint add(int a, int b)&#123;    std::cout &lt;&lt; &quot;Add  Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Sleeping before add...&quot; &lt;&lt; std::endl;    sleep(4);    return a + b;&#125;int main() &#123;    std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Start&quot; &lt;&lt; std::endl;    //std::future&lt;int&gt; futureResult = std::async(std::launch::deferred, add, 3, 5);  // deferred不会创建新线程    std::future&lt;int&gt; futureResult = std::async(std::launch::async, add, 3, 5); // 创建新线程    sleep(3);     std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Waiting for result...&quot; &lt;&lt; std::endl;    int result = futureResult.get();  // 等待异步任务完成并获取结果    std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    sleep(3);        return 0;&#125;\n\n如果使用std::launch::async作为启动策略，可以看到，执行add函数的线程id和主线程的id是不同的，通过linux下的ps -aL命令也能观察到出现两个线程。可以用如下脚本来实时监控线程状态。\nwhile :; do ps jax | head -1 &amp;&amp; ps -aL |  grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\nstd::launch::async下程序执行的输出结果\nMain Thread 139869475694400 | StartAdd  Thread 139869457655552 | Sleeping before add...Main Thread 139869475694400 | Waiting for result...Main Thread 139869475694400 | Result: 8\n\n如果使用std::launch::deferred作为启动策略，则会发现这两个线程的id是完全相同的，这代表实际上其执行了并行的策略，程序就是在主执行流上面运行的，并没有新开一个线程来执行。这也符合deferred作为“延迟运行”的特性。\nMain Thread 139789724776256 | StartMain Thread 139789724776256 | Waiting for result...Add  Thread 139789724776256 | Sleeping before add...Main Thread 139789724776256 | Result: 8\n\n2.5.2 多线程get一个future在如下代码中，我写了一个void future_get_func(std::future&lt;int&gt;&amp; fu)的函数，尝试开一个线程来get，然后主执行流又get一次，看看会发生什么。\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;thread&gt;#include &lt;type_traits&gt; // result_of#include &lt;sys/unistd.h&gt; // sleepint add(int a, int b)&#123;    std::cout &lt;&lt; &quot;Add  Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Sleeping before add...&quot; &lt;&lt; std::endl;    sleep(4);    return a + b;&#125;void future_get_func_shared(std::shared_future&lt;int&gt;&amp; fu)&#123;    int result = fu.get();  // 等待异步任务完成并获取结果    std::cout &lt;&lt; &quot;Func Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    sleep(2);&#125;void future_get_func(std::future&lt;int&gt;&amp; fu)&#123;    int result = fu.get();  // 等待异步任务完成并获取结果    std::cout &lt;&lt; &quot;Func Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    sleep(2);&#125;int main() &#123;    std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Start&quot; &lt;&lt; std::endl;    //std::future&lt;int&gt; futureResult = std::async(std::launch::deferred, add, 3, 5); // 不会创建新线程    std::future&lt;int&gt; futureResult = std::async(std::launch::async, add, 3, 5); // 创建新线程    sleep(3);     std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Waiting for result...&quot; &lt;&lt; std::endl;        // 尝试测试多线程get会发生什么        std::thread t1(future_get_func, std::ref(futureResult)); // 开个线程来get    t1.detach(); // 直接分离线程    sleep(1);    int result = futureResult.get();  // 等待异步任务完成并获取结果    std::cout &lt;&lt; &quot;Main Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    sleep(3);        return 0;&#125;\n\n需要注意的是，如下创建线程的传参必须要用std::ref包裹，来告知线程这是一个引用对象，否则编译会报错。因为 std::thread 要求参数可以在构造函数中被调用，而 std::future 并不能直接传递给 std::thread；\nstd::thread t1(future_get_func, std::ref(futureResult)); //正确std::thread t1(future_get_func, futureResult); //错误\n\n编译通过后执行，会发现跑出来了一个std::future_error异常，代表我们在一个无效的future上调用了get函数。\nMain Thread 139869577889600 | StartAdd  Thread 139869559850752 | Sleeping before add...Main Thread 139869577889600 | Waiting for result...Func Thread 139869551458048 | Result: 8terminate called after throwing an instance of &#x27;std::future_error&#x27;  what():  std::future_error: No associated stateAborted\n\n记住了，std::future在调用了一次get之后将不再与对应的std::async关联，所以才会需要share_future的出现！\n改成share_future再执行上面这套逻辑，就会发现成功跑起来了。\nMain Thread 140369883957056 | StartAdd  Thread 140369865918208 | Sleeping before add...Main Thread 140369883957056 | Waiting for result...Func Thread 140369857525504 | Result: 8Main Thread 140369883957056 | Result: 8\n\n2.5.3 异常处理int add(int a, int b)&#123;    std::cout &lt;&lt; &quot;Add  Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; | Sleeping before add...&quot; &lt;&lt; std::endl;    sleep(4);    throw std::runtime_error(&quot;An error occurred&quot;);    return a + b;&#125;\n\n如果async执行的函数中抛出了异常，那么这个异常将会被传回主执行流，可以在主执行流中被处理。而如果直接使用线程来执行这个函数，其异常不会被捕捉，而是会导致整个进程退出。\n下图，使用async运行，成功打印出异常（捕获成功）\n\n下图，使用线程运行，进程退出\n\n2.6 launch::deferred的真正意义如果std::launch::deferred是同步执行，这样写不是多此一举吗？为什么不直接在需要的地方调用函数，而是使用async？\nNONONO 非也非也，和直接调用Add函数相比，用async+deferred策略这样的方式调用Add函数还是有些区别的：\n\n推迟执行：直接调用Add函数是立马执行，但是用async可以推迟到调用get的时候才执行\n延迟计算：有的时候我们并不是需要立马使用这个函数的返回值，所以就可以延迟一会再执行这个函数，先把函数的调用搞起来，后面只需要一个get就能获取到结果了（避免两个部位之间的代码较长，后续找不到我们需要的那两个变量的名字了）\n避免线程创建：并不是什么时候多线程都更好，有些时候创建一个线程的消耗还不如直接执行函数来的快（比如函数干的活很小的情况，比如一些O(1)的算法）\n\n所以，这个关键字多少还是有点作用了。\n2.7 future_error&#x2F;errc&#x2F;status除了future和share_future，还有如下几个类型\n\nstd::future_error： std::future_error 是一个异常类，用于表示与 std::future 相关的错误。当在使用 std::future 时出现错误，例如获取结果时异步任务抛出了异常，就会抛出 std::future_error 异常。它是一个标准异常类型，通常通过捕获异常对象来处理异步任务执行过程中的问题。\nstd::future_errc： std::future_errc 是一个枚举类型，用于表示 std::future_error 中的不同错误情况。这样的枚举类型是为了在处理异常时更加明确和方便。它包含了一系列可能的错误，如 broken_promise（promise 被破坏，即 promise 对象的 set_value 或 set_exception 被多次调用）和 future_already_retrieved（future 对象已经被获取过一次）等。\nstd::future_status： std::future_status 是一个枚举类型，用于表示 std::future 的状态。它描述了一个 std::future 对象的当前情况，指示异步任务是否已完成、是否有效等。std::future_status 包含三个值：ready（异步任务已完成，可以获取结果）、timeout（等待超时，即异步任务还未完成）、deferred（异步任务延迟执行）。\n\n其中 wait_for 的返回值是 std::future_status，包含三种情况\n\n\n\nvalue\ndescription\n\n\n\nfuture_status::ready\nThe shared state is ready: the producer has set a value or exception.\n\n\nfuture_status::timeout\nThe function waited for rel_time without the shared state becoming ready.\n\n\nfuture_status::deferred\nThe shared state contains a deferred function.\n\n\n第一个情况是future的目标函数已经执行完毕，可以去获取返回值了。\n第二个情况是wait_for等待超时了。\n第三个情况是future中包含的函数使用的策略是std::launch::deferred，此时wait_for函数是没有意义的，因为在这种情况下，函数只有在future.get()的时候才会被执行，wait_for会被直接返回。\n3.为什么C++会出现futrue？为啥要出一个future？直接用老办法不也可以这么玩吗？\n\n这部分是GPT的回答\n\nC++ 标准库引入 std::future 和相关的异步编程机制，是为了更好地支持并发编程和多线程环境。这些机制的出现有几个原因和动机：\n\n并发性和性能提升： 在现代计算机体系结构中，多核处理器已经成为常态。为了充分利用这些多核资源，编写并发代码变得重要。std::future 提供了一种方式，可以在多个线程中同时执行任务，并且可以方便地获取任务的结果，从而允许程序在多核处理器上并行执行，提高性能。\n任务分离： 在很多情况下，我们希望将一个大的任务拆分成多个子任务，在不同的线程中并行执行，然后合并子任务的结果。std::future 允许你在一个线程中等待另一个线程的任务完成，从而支持这种任务分离和并行执行的模式（其实最主要的还是获取线程所执行函数的返回值）。\n避免阻塞： 在传统的同步编程中，如果某个操作需要等待，会导致线程阻塞。而异步编程机制允许线程继续执行其他操作，而不必等待一个潜在的耗时操作完成。std::future 允许你在一个线程中发起异步操作，并在需要的时候获取操作的结果，从而避免了不必要的阻塞。\n异常处理： 在多线程环境中，处理异步任务的异常可能变得复杂，因为异步任务在不同的线程中执行。std::future 引入了异常传递机制，允许异步任务在执行过程中抛出异常，并将这些异常传递到等待结果的线程中。\n\n总之，C++ 的 std::future 和相关的异步编程机制提供了一种更高级别、更方便的方式来处理多线程并发编程。这些机制使得开发者能够更容易地利用多核处理器的性能，并更灵活地设计并发代码，从而在面对并发和异步任务时能够更好地管理资源、提高效率和处理异常。\n4.promise4.1 概念std::promise 是 C++ 标准库中用于在一个线程中产生结果，然后在另一个线程中获取结果的工具。它提供了一些成员函数来设置结果、处理异常以及获取关联的 std::future 对象等。\ntemplate &lt;class T&gt;  promise;template &lt;class R&amp;&gt; promise&lt;R&amp;&gt;;     // specialization : T is a reference type (R&amp;)template &lt;&gt;         promise&lt;void&gt;;   // specialization : T is void\n\n下面是一些常用的 std::promise 成员函数及其用法：\n\nset_value： 用于设置结果值。如果你已经通过 get_future() 获取了一个 std::future 对象，调用 set_value 将会使等待结果的线程被唤醒并获取结果。\nstd::promise&lt;int&gt; promiseObj;std::future&lt;int&gt; futureResult = promiseObj.get_future();// 在某个线程中设置结果值promiseObj.set_value(42);\n\nset_exception： 用于设置异常，将在等待结果的线程中抛出。这允许你在产生结果的线程中处理异常情况。\ntry &#123;    // 产生异常    throw std::runtime_error(&quot;An error occurred&quot;);&#125; catch (...) &#123;    // 将异常设置到 promise 对象中    promiseObj.set_exception(std::current_exception());&#125;\n\nget_future： 返回与 std::promise 关联的 std::future 对象。通过这个 std::future，你可以在另一个线程中等待并获取结果。\nstd::promise&lt;int&gt; promiseObj;std::future&lt;int&gt; futureResult = promiseObj.get_future();\n\nswap： 交换两个 std::promise 对象的状态，包括关联的 std::future 对象和设置的结果。\nstd::promise&lt;int&gt; promise1;std::promise&lt;int&gt; promise2;// 交换两个 promise 对象的状态promise1.swap(promise2);\n\nvalid： 检查 std::promise 对象是否有效，即是否与一个 std::future 对象关联。\nstd::promise&lt;int&gt; promiseObj;if (promiseObj.valid()) &#123;    // promiseObj 有效&#125; else &#123;    // promiseObj 无效&#125;\n\n还有下面这俩个成员函数，看名字也能猜出来它是干嘛的，就不多说了\n\nset_value_at_thread_exit\nSet value at thread exit (public member function )\n\nset_exception_at_thread_exit\nSet exception at thread exit (public member function )\n\n\n这些成员函数允许你在一个线程中产生结果或异常，并在另一个线程中等待和处理这些结果或异常。它们为多线程编程提供了一种可靠的方式来传递数据和控制流。请注意，在使用 std::promise 时，你需要仔细处理异常和线程同步，以确保正确的结果传递。\n4.2 示例然后下头是一个基本的使用示例；你可以理解为promise就是一个用来承担线程所执行函数的参数和异常的一个变量，我们可以通过set_value并在主执行流中使用future.get来获取到这个值，也可以设置异常，并在主执行流中处理这个异常；\n不过promise和future一样，是一次性的，设置value和异常都只能设置一次，设置完毕后就不能再设置了\n#include &lt;iostream&gt;#include &lt;future&gt;void worker(std::promise&lt;int&gt;&amp; p) &#123;    p.set_value(42); // 设置值&#125;int main() &#123;    std::promise&lt;int&gt; promiseObj;    std::future&lt;int&gt; futureResult = promiseObj.get_future();    std::thread t(worker, std::ref(promiseObj)); // 通过线程执行    t.join();    int result = futureResult.get(); // 主线程中获取值    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;\n\n5.packaged_taskstd::packaged_task 是 C++ 标准库中的一个类模板，用于将一个可调用对象（函数、函数对象或可调用成员函数）封装成一个可以异步执行的任务，并且可以通过 std::future 获取任务的返回值。它在多线程编程中起到了连接异步任务和线程间通信的桥梁作用。\nstd::packaged_task 的主要作用有以下几个方面：\n\n封装任务： std::packaged_task 允许你将一个可调用对象封装成一个任务，这个任务可以在另一个线程中异步执行。你可以将函数、函数对象或可调用成员函数封装为一个 std::packaged_task 实例。\n异步执行： 通过将 std::packaged_task 实例传递给一个 std::thread 或其他支持异步执行的机制，你可以在新的线程中执行封装的任务，而不需要显式创建线程函数。\n获取返回值： std::packaged_task 可以与 std::future 一起使用，以获取异步任务的返回值。你可以通过 packaged_task 的 get_future 方法获取一个与任务关联的 std::future 对象，然后在适当的时候使用 std::future 的 get 方法来获取任务的返回值。\n线程池： std::packaged_task 结合线程池的使用，可以更灵活地控制任务的执行方式。线程池可以预先创建一组线程，然后将封装好的任务分配给这些线程执行，避免了频繁创建和销毁线程的开销。\n\n5.1 示例下面是一个简单示例，演示了如何使用 std::packaged_task 来异步执行一个函数并获取其返回值\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int add(int a, int b) &#123;    return a + b;&#125;int main() &#123;    std::packaged_task&lt;int(int, int)&gt; task(add);    std::future&lt;int&gt; future = task.get_future();    std::thread worker(std::move(task), 3, 5);    worker.join(); // 通过线程异步执行这个task    int result = future.get(); // 等待返回值    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;\n\n在这个例子中，std::packaged_task 封装了一个函数 add，然后通过 std::thread 异步执行，最后通过 std::future 获取异步任务的返回值。\n5.2 make_ready_at_thread_exitpackaged_task的成员函数中，主要还是这个需要单独说明；先看如下代码\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;int main() &#123;    std::packaged_task&lt;int()&gt; task([]()&#123; return 42; &#125;);    std::future&lt;int&gt; future = task.get_future();    std::thread worker([&amp;task]() &#123;        // 模拟一些工作        std::this_thread::sleep_for(std::chrono::seconds(2));        // 设置任务结果值        task.make_ready_at_thread_exit();    &#125;);    worker.detach(); // 分离线程，不等待其结束    // 等待任务结果    int result = future.get();    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;\n\n我们让packaged_task执行的是一个return 42的函数，而线程里面还会进行其他处理。\n而make_ready_at_thread_exit()的作用，就是确认当前的worker线程已经干完自己的活了，可以执行packaged_task封装的函数了！\n相当于是一个确认packaged_task中封装的任务到底在什么时候执行的一个函数。调用这个函数的时候，就会开始执行其包装的异步函数，并返回结果给future.get()的执行流\nThe end收工\n","categories":["遇见C++"],"tags":["Linux","C++","C++11"]},{"title":"【C++】C++14的那些新特性","url":"/posts/1184922698/","content":"学习C++14的那些新特性\n\n\n\n为了方便指定使用C++14来编译代码，本文的测试都是在linux下进行的，g++版本如下\n$ g++ --versiong++ (GCC) 8.5.0 20210514 (Red Hat 8.5.0-4)\n\n如果你和我一样，也是使用VSC来链接linux进行代码编写，那一定要记得修改C++插件里面的CPP版本，否则默认以C++11来进行语法高亮的话，会把C++11不支持的语法标红，影响我们学习\n\n\n本文参考 https://zhuanlan.zhihu.com/p/588826142 进行学习;\n官方文档 https://zh.cppreference.com/w/cpp/14\n\n1.lambda新特性C++14给lambda表达式添加了两个新功能\n\n参数推断（auto）\n参数初始化后捕获（可以在[]对某个新参数进行赋值）\n\n先来复习一下C++11中学习的lambda捕获的基本方式\n[val]：表示值传递方式捕捉变量val[=]：表示值传递方式捕获所有父作用域中的变量(包括this)[&amp;val]：表示引用传递捕捉变量val[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括this)[this]：表示值传递方式捕捉当前的this指针\n\n在C++14中，新增的是下面的这种情况\nint a = 30;// [] 中赋值了一个参数// () 中可以使用auto关键字来推断参数类型auto func = [x = 3](auto y) &#123;return x + y; &#125;;cout &lt;&lt; func(a) &lt;&lt; endl;\n\n运行测试，可以看到成功输出了结果\n$ makeg++ test.cpp -o test -std=c++14$ ./test33\n\n修改一下类型，也能正常调用\ndouble a = 30.2;auto func = [x = 3](auto y)&#123; return x + y; &#125;;cout &lt;&lt; func(a) &lt;&lt; endl;\n\n$ ./test33.2\n\n如果想将赋值参数和原本的捕获方式一起使用，则需要将赋值参数放在[]的最后面\nvoid test_lambda2()&#123;    int a = 10, b = 20;    int c = 1, d = 3, e = 5;    // 赋值的参数要放在[]的最后面，捕获方式放在前面    auto func6 = [=, f = 30, g = 40]    &#123;        return (a + b + c + d + e + f + g);    &#125;;    cout &lt;&lt; func6() &lt;&lt; endl;&#125;\n\n$ ./test109\n\n初始化捕获的好处是可以支持移动捕获了；不然在C++11中，lambda就只能使用赋值捕获和引用捕获\nstd::unique_ptr&lt;Item&gt; item(new Item());// std::move改为右值进行赋值后捕获auto func = [m = std::move(item)] &#123; /* do something */ &#125;;\n\n这个新特性的提出，也让lambda成功有了和bind比拼的能力。在C++11中，bind的优势就是在于移动捕获的支持；如今lambda也有了这份能力了，我们可以更灵活地根据场景选用lambda或者bind，而不是只能使用bind了。\n2.变量模板2.1 示例看清楚这个名字啊！是变量模板，可不是什么函数模板哈！\ntemplate&lt;class T&gt;T pi = T(3.1415926535897932385L); // variable template// 数字最后的L代表这是一个长浮点型void test_value_template()&#123;    cout &lt;&lt; pi&lt;double&gt; &lt;&lt; endl;    cout &lt;&lt; pi&lt;float&gt; &lt;&lt; endl;    cout &lt;&lt; pi&lt;int&gt; &lt;&lt; endl;&#125;\n\n如上就是一个最最最简单的变量模板，我们在传入对应的类型后，他就会转成我们需要的类型\n$ makeg++ test.cpp -o test -std=c++14$ ./test3.141593.141593\n\n2.2 类中使用当你需要在类中使用模板变量的时候，这个变量必须定义为static；\n因为它是模板，我们还可以接用模板本身就有的特性，将这个模板针对某一个类型进行特化\nstruct Limits&#123;    template&lt;typename T&gt;    static const T min; // 声明静态成员模板&#125;; template&lt;typename T&gt;const T Limits::min = &#123; &#125;; // 定义静态成员模板，全部使用默认值// 下面三个是模板变量的特化template&lt;&gt;const float Limits::min&lt;float&gt; = 4.5;template&lt;&gt;const double Limits::min&lt;double&gt; = 5.5;template&lt;&gt;const std::string Limits::min&lt;std::string&gt; = &quot;hello&quot;;int main()&#123;    std::cout &lt;&lt; Limits::min&lt;int&gt; &lt;&lt; std::endl;    std::cout &lt;&lt; Limits::min&lt;float&gt; &lt;&lt; std::endl;    std::cout &lt;&lt; Limits::min&lt;double&gt; &lt;&lt; std::endl;    std::cout &lt;&lt; Limits::min&lt;std::string&gt; &lt;&lt; std::endl;    return 0;&#125;\n\n$ ./test04.55.5hello\n\n2.3 和类型转换的区别这里我又直接定义了一个变量，使用static_cast直接转换变量，看看结果会不会有什么区别\n// 数字最后的L代表这是一个长浮点型template&lt;class T&gt;T pi = T(3.1415926535897932385L); // 变量模板long double lpi = 3.1415926535897932385L; // 直接定义长浮点型void test_value_template()&#123;    cout &lt;&lt; pi&lt;double&gt; &lt;&lt; endl;    cout &lt;&lt; pi&lt;float&gt; &lt;&lt; endl;    cout &lt;&lt; pi&lt;int&gt; &lt;&lt; endl;    cout &lt;&lt; &quot; ----- \\n&quot;;    cout &lt;&lt; static_cast&lt;double&gt;(lpi) &lt;&lt; endl;    cout &lt;&lt; static_cast&lt;float&gt;(lpi) &lt;&lt; endl;    cout &lt;&lt; static_cast&lt;int&gt;(lpi) &lt;&lt; endl;&#125;\n\n看上去二者的结果完全相同，那么既然可以直接使用变量类型转换，为什么还要新增一个模板变量呢？\n$ ./test3.141593.141593 ----- 3.141593.141593\n\n\n以下内容来自GPT，我觉得它说的很对\n\n定义一个变量并使用数据转换（类型转换）是一种常见的编程方式，但与变量模板有一些区别：\n\n通用性： 变量模板允许你通过模板参数来生成多个不同类型的变量，从而在不同的上下文中使用。这使得代码更具通用性和可扩展性，因为你可以为多个类型生成相应的变量。相比之下，直接定义变量并使用数据转换通常只适用于特定的一种数据类型。\n模板化： 变量模板是一种模板化的方式来生成变量，它遵循 C++ 的模板机制，这意味着你可以使用模板特化、部分特化等技术来定制化生成的变量，以满足不同的需求。而使用数据转换时，你必须显式地执行类型转换，这可能会在代码中引入不必要的重复。\n编译时计算： 变量模板通常用于在编译时生成值，因此可以在编译阶段进行类型检查和计算。这有助于提高代码的性能和安全性。而数据转换可能在运行时进行，可能会引入一些运行时开销和类型错误的风险。\n抽象性： 变量模板可以在更高的抽象层次上操作数据，使代码更具表达力和可读性。它允许你以更自然的方式描述某个值与特定类型之间的关系，而不必显式进行类型转换。\n\n总之，变量模板提供了一种更灵活、通用和模板化的方式来生成变量，适用于需要在不同类型上工作的情况。当你需要为多个类型生成特定的变量或值时，变量模板是一种更优雅和强大的选择。\n3.constexpr限制放宽在C++11中被引入的constexpr，可以让编译器在编译程序的期间，就将一部分工作完成，不必等到运行期间再做；在C++11中，constexpr的限制很严格，这导致它并不好用：\n\nconstexpr修饰变量，要求变量必须可以在编译器推导出来\nconstexpr修饰函数（返回值），函数内除了可以包含using和typedef指令以及static_asssert断言外，只能包含一条return语句\nconstexpr同时可以修饰构造函数，但也会要求使用这个构造函数的时候，可以在编译器就把相关的内容全推导出来\n\n以下是一个比较基础的C++11中的用例，给该函数设置了constexpr关键字后，该函数就可以在编译期间被计算出结果，再用static_assert在编译期间断言结果是否正确；\nconstexpr int factorial(int n) &#123;    return (n &lt;= 1) ? 1 : n * factorial(n - 1);&#125;int test_constexpr1() &#123;    constexpr int result = factorial(5); // 编译时计算阶乘    static_assert(result == 120, &quot;Factorial of 5 should be 120&quot;); // 编译时断言    cout &lt;&lt; result &lt;&lt; endl;    return 0;&#125;\n\n如果在C++11中的constexpr函数内包含其他语句，编译的时候会报错，翻译过来是该函数内部不是一个return返回语句\n$ g++ test.cpp -o test -std=c++11test.cpp: In function ‘constexpr int FuncNew(int)’:test.cpp:96:1: error: body of ‘constexpr’ function ‘constexpr int FuncNew(int)’ not a return-statement &#125; ^\n\nc++14中，对constexpr的限制放宽了，允许使用循环、if、switch等等语句，但是主旨还是一样的，需要在编译期间就可以计算出全部内容；限制放宽之后，这个关键字便可以更灵活的使用了。\n// 计算前n项和，C++11constexpr int Func(int n)&#123;    return n &gt; 0 ? Func(n - 1) + n : 0;&#125;// 计算前N项和，C++14constexpr int FuncNew(int n)&#123;    if (n &lt;= 0)    &#123;        return 0;    &#125;    int sum = 0;    for (int i = 0; i &lt; n; ++i)    &#123;        sum += i;    &#125;    return sum;&#125;\n\n4.二进制变量可以使用0b或者0B开头直接定义二进制变量。\nint main()&#123;        int bit1 = 0b1001;    int bit2 = 0B1011;    std::cout &lt;&lt; bit1 &lt;&lt; &quot; &quot; &lt;&lt; bit2 &lt;&lt; std::endl;&#125;\n\n运行结果如下\n$ g++ test.cpp -o test -std=c++14$ ./test9 11\n\n我在测试中发现，当我用C++11编译此代码的时候，似乎也没有引发编译错误，难道说0b是在C++11里面就支持了吗？\n$ g++ test.cpp -o test -std=c++11$ ./test9 11\n\nGPT给出了0B这种二进制变量是在C++14中引入的确认，并提到了为什么会出现上述情况；虽然C++11看上去编译和运行都没有问题，但我们还是得遵循版本，选用正确的版本进行编译，才能根本上避免错误\n\nC++标准通常是向后兼容的，这意味着较新版本的编译器通常会继续支持较旧版本的标准。例如，如果你在使用支持C++11标准的编译器（如g++）时，使用了C++14或更高版本的特性，通常不会引发编译错误，因为这些编译器会尽量向后兼容，以保持现有代码的可编译性。\n在你提到的情况下，即使你使用g++编译器以C++11标准编译，它仍然可以理解和接受C++14引入的二进制字面量特性。这是编译器开发者的一种设计选择，以便使代码的迁移更加平滑。但是，为了遵循最佳实践和保持代码的可读性，当你在使用特定C++标准的功能时，最好将编译器选项设置为该标准的版本，以确保代码的可移植性。\n\n5.数字分隔符在日常生活中使用数字的时候，为了更好的可读性，我们会以3个数组或者4个数组为分割，打一个点\n1,0000,0000 一亿100,000,000\n\nC++14中，也支持了这样的打点，以方便我们更好的看出大数字的位数\nvoid test_num_div()&#123;    long long big_num1 = 100000000;    long long big_num2 = 100&#x27;000&#x27;000;    long long big_num3 = 1&#x27;0000&#x27;0000;    cout &lt;&lt; big_num1 &lt;&lt; endl;    cout &lt;&lt; big_num2 &lt;&lt; endl;    cout &lt;&lt; big_num3 &lt;&lt; endl;&#125;\n\n需要注意，这样的操作不会对数字本身有任何影响\n$ ./test100000000100000000100000000\n\n在C++11中这种语法是不支持的\n$ g++ test.cpp -o test -std=c++11test.cpp:116:29: warning: multi-character character constant [-Wmultichar]     long long big_num2 = 100&#x27;000&#x27;000;                             ^~~~~test.cpp:117:27: warning: multi-character character constant [-Wmultichar]     long long big_num3 = 1&#x27;0000&#x27;0000;                           ^~~~~~test.cpp: In function ‘void test_num_div()’:test.cpp:116:29: error: expected ‘,’ or ‘;’ before &#x27;\\x303030&#x27;     long long big_num2 = 100&#x27;000&#x27;000;                             ^~~~~test.cpp:117:27: error: expected ‘,’ or ‘;’ before &#x27;\\x30303030&#x27;     long long big_num3 = 1&#x27;0000&#x27;0000;                           ^~~~~~\n\n6.返回值auto推导c++14新增了函数返回值的推导，当返回值声明为auto时，编译器会根据你的return语句推导出你的返回值类型。\ntemplate&lt;typename T&gt;auto Func(T x, T y)&#123;    return x + y;&#125;int main()&#123;    std::cout &lt;&lt; Func(3, 4) &lt;&lt; std::endl; // 返回值推导为int    std::cout &lt;&lt; Func(3.1, 4.2) &lt;&lt; std::endl; // 返回值推导为double    return 0;&#125;\n\n$ makeg++ test.cpp -o test -std=c++14$ ./test77.3\n\n这个推导是有限制条件的\n1、如果有多个推导语句，那么多个推导的结果必须一致\n// 编译报错，第一个return推导为int，第二个return推导为double，两次推导结果不一致auto Func(int flag)&#123;    if (flag &lt; 0)    &#123;        return 1;    &#125;    else    &#123;        return 3.14;    &#125;&#125;\n\n2、如果没有return或者return为void类型，那么auto会被推导为void。\nauto f() &#123;&#125;              // returns voidauto g() &#123; return f(); &#125; // returns voidauto* x() &#123;&#125;             // error: cannot deduce auto* from void\n\n3、一旦在函数中看到return语句，从该语句推导出的返回类型就可以在函数的其余部分中使用，包括在其他return语句中。\nauto Sum(int i)&#123;    if (i &lt;= 1)    &#123;        return i; // 返回值被推导为int    &#125;    else    &#123;        return Sum(i - 1) + i; // sum的返回值已经被推导出来了，所以这里是没有问题的    &#125;&#125;\n\n但是如果还没被推导出来，那就不能使用。\nauto Sum(int i)&#123;    if (i &gt; 1)    &#123;        return Sum(i - 1) + i;    &#125;    else    &#123;        return i;    &#125;&#125;// 编译报错，因为Sum的返回值还没有被推导出来，所以还不能使用error: use of ‘auto Sum(int)’ before deduction of ‘auto’\n\n4、不能推导初始化列表。\nauto func () &#123; return &#123;1, 2, 3&#125;; &#125;// 编译报错error: returning initializer list\n\n5、虚函数不能使用返回值推导\nstruct Item&#123;    virtual auto Func();&#125;;// 编译报错error: virtual function cannot have deduced return type\n\n7.[[deprecated]]标记这个标记的作用是告知其他人，某个函数被弃用了，不允许继续调用该函数；该字段的好处在于，如果一个方法已经在后续不需要使用了，你可以先给他加上这个关键字，然后再进行其他的代码检查，确认无误后，再将这个函数整体清除；\n别人也不需要去检查函数的实现，因为在编译过程中编译器就会告诉你这个函数被弃用；但是编译依旧是成功的！\n[[deprecated]]int test_return_auto()&#123;    std::cout &lt;&lt; Func(3, 4) &lt;&lt; std::endl; // 返回值推导为int    std::cout &lt;&lt; Func(3.1, 4.2) &lt;&lt; std::endl; // 返回值推导为double    return 0;&#125;int main()&#123;    test_return_auto();    return 0;&#125;\n\n在编译的时候，编译器会警告你，这个函数已经被弃用了；但这里只是警告，编译依旧成功了，所以最终还是需要程序猿去瞅一眼各个警告到底是什么意思。\n$ makeg++ test.cpp -o test -std=c++14test.cpp: In function ‘int main()’:test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]     test_return_auto();                      ^test.cpp:132:5: note: declared here int test_return_auto()     ^~~~~~~~~~~~~~~~test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]     test_return_auto();                      ^test.cpp:132:5: note: declared here int test_return_auto()     ^~~~~~~~~~~~~~~~\n\n\nstd库的新特性以下是STD库的新增内容！\n8.std::make_unique这个东西在cplusplus网站上找不到释义，所以就去cpp的官网上找了\n\nhttps://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique\n\n该函数定义在&lt;memory&gt;头文件中\ntemplate&lt; class T, class... Args &gt;unique_ptr&lt;T&gt; make_unique( Args&amp;&amp;... args );//(1)\t(C++14 起) (仅对非数组类型)template&lt; class T &gt;unique_ptr&lt;T&gt; make_unique( std::size_t size );//(2)\t(C++14 起) (仅对未知边界数组)template&lt; class T, class... Args &gt;/* unspecified */ make_unique( Args&amp;&amp;... args ) = delete;//(3)\t(C++14 起) (仅对已知边界数组)\n\n作用是构造 T 类型对象并将其包装进 std::unique_ptr；\n\n\n\n参数\n说明\n\n\n\nargs\n将要构造的 T 实例所用的参数列表。\n\n\nsize\n要构造的数组大小\n\n\n\n构造非数组类型 T 对象。传递参数 args 给 T 的构造函数。此重载只有在 T 不是数组类型时才会参与重载决议。函数等价于：\n\nunique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...))\n\n\n构造拥有动态大小的数组。值初始化数组元素。此重载只有在 T 是未知边界数组时才会参与重载决议。函数等价于：\n\nunique_ptr&lt;T&gt;(new std::remove_extent_t&lt;T&gt;[size]())\n\n使用示例\nclass test_class&#123;public:    test_class(int a=-1):_a(a)&#123;&#125;    int _a;&#125;;int main()&#123;    std::unique_ptr&lt;test_class&gt; pt = std::make_unique&lt;test_class&gt;(3);    cout &lt;&lt; pt-&gt;_a &lt;&lt; endl;    return 0;&#125;\n\n$ makeg++ test.cpp -o test -std=c++14$ ./test3\n\n9.std::shared_timed_mutex与std::shared_lockc++11引入了多线程线程的一些库，但是是没有读写锁的，因此在c++14引入了读写锁的相关实现（头文件shared_mutex），其实c++14读写锁也还不够完善，直到c++17读写锁这块才算是完备起来。\nstd::shared_timed_mutex是带超时的读写锁对象，接口还算比较简洁易懂，和之前接触过的其他锁基本一致；内部成员中lock()是写锁，lock_shared()是读锁;\nhttps://zh.cppreference.com/w/cpp/thread/shared_timed_mutex\n\nstd::shared_lock是加锁的RAII实现，即构造时加锁，析构时解锁；我们使用shared_lock/unique_lock来从shared_timed_mutex中获取锁的时候，就会自动获取读锁和写锁；\nstd::shared_timed_mutex mutex;void readOperation() &#123;    // 读锁是多人可以获取的，所以要用shared_lock (读锁)    std::shared_lock&lt;std::shared_timed_mutex&gt; lock(mutex);    std::cout &lt;&lt; &quot;Read operation: &quot; &lt;&lt; sharedResource &lt;&lt; std::endl;&#125;void writeOperation() &#123;    // 写锁互斥获取，用unique_lock (写锁)    std::unique_lock&lt;std::shared_timed_mutex&gt; lock(mutex);    sharedResource++;    std::cout &lt;&lt; &quot;Write operation: &quot; &lt;&lt; sharedResource &lt;&lt; std::endl;&#125;\n\n10.std::exchangec++14新增了一个接口std::exchange（头文件utility），其实这个也并不算是新增的，因为这个接口其实在c++11的时候就有了，只不过在c++11中作为一个内部函数，不暴露给用户使用，在c++14中才把它暴露出来给用户使用。使用方法也很简单。\nint main()&#123;    std::string s1 = &quot;hello&quot;;    std::string s2 = &quot;world&quot;;    std::exchange(s1, s2);    std::cout &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; s2 &lt;&lt; std::endl;    return 0;&#125;// 输出结果world world\n\n我们可以看到，exchange会把第二个值赋值给第一个值，但是不会改变第二个值。我们来看下它的实现吧。\n/// Assign @p __new_val to @p __obj and return its previous value. template &lt;typename _Tp, typename _Up = _Tp&gt;  _GLIBCXX20_CONSTEXPR  inline _Tp    exchange(_Tp&amp; __obj, _Up&amp;&amp; __new_val)  noexcept(__and_&lt;is_nothrow_move_constructible&lt;_Tp&gt;,    is_nothrow_assignable&lt;_Tp&amp;, _Up&gt;&gt;::value)  &#123; return std::__exchange(__obj, std::forward&lt;_Up&gt;(__new_val)); &#125;  // C++11 version of std::exchange for internal use.template &lt;typename _Tp, typename _Up = _Tp&gt;  _GLIBCXX20_CONSTEXPR  inline _Tp  __exchange(_Tp&amp; __obj, _Up&amp;&amp; __new_val)  &#123;    _Tp __old_val = std::move(__obj);    __obj = std::forward&lt;_Up&gt;(__new_val);    return __old_val;  &#125;\n\n通过注释我们可以明白含义，它的作用是把第二个值赋值给第一个值，同时返回第一个值的旧值。\n除此之外，我们这里说明一个关键的点。exchange的第二个参数是万能引用，所以说他是既可以接收左值，也可以接收右值的，所以我们可以这样来使用。\nint main()&#123;    std::string s1 = &quot;hello&quot;;    // 第二个值是纯右值    std::exchange(s1, &quot;world&quot;);    std::cout &lt;&lt; s1 &lt;&lt; std::endl;    std::string s2 = &quot;hello world&quot;;    // 第二个值通过move语义转成右值    std::exchange(s1, std::move(s2));    std::cout &lt;&lt; s1 &lt;&lt; &quot; | &quot; &lt;&lt; s2 &lt;&lt; std::endl;    return 0;&#125;// 输出结果，注意这里s2为空字符串，因为s2的东西已经被移动拷贝给s1了worldhello world | \n\n11.std::integer_sequence类模板 std::integer_sequence 表示一个编译时的整数序列。在用作函数模板的实参时，能推导参数包 Ints 并将它用于包展开。\nhttps://zh.cppreference.com/w/cpp/utility/integer_sequence\n这个实在是太难懂了，搞不明白是干嘛的，放弃了😥\n12.std::quotedhttps://zh.cppreference.com/w/cpp/io/manip/quoted\n该函数模板位于 &lt;iomanip&gt; 头文件中，用于在输入输出流中处理被引号包围的字符串。它通常用于处理 CSV（逗号分隔值）文件或其他格式，其中字段被引号括起来以处理包含特殊字符（如逗号、换行符等）的情况。\n对于cout而言，quoted会将字符串包围在双引号中输出\nint test_quorted() &#123;    std::string data = &quot;Hello, \\&quot;world\\&quot;\\n&quot;;        // 输出流中使用 std::quoted，会将字符串在&quot;内包围输出    std::cout &lt;&lt; std::quoted(data) &lt;&lt; std::endl;    return 0;&#125;\n\n$ ./test&quot;Hello, \\&quot;world\\&quot;&quot;\n\n以下是官方给的一个示例\n#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;sstream&gt; int main()&#123;    std::stringstream ss;    std::string in = &quot;String with spaces, and embedded \\&quot;quotes\\&quot; too&quot;;    std::string out;     auto show = [&amp;](const auto&amp; what) &#123;        &amp;what == &amp;in            ?   std::cout &lt;&lt; &quot;read in     [&quot; &lt;&lt; in &lt;&lt; &quot;]\\n&quot;                          &lt;&lt; &quot;stored as   [&quot; &lt;&lt; ss.str() &lt;&lt; &quot;]\\n&quot;            :   std::cout &lt;&lt; &quot;written out [&quot; &lt;&lt; out &lt;&lt; &quot;]\\n\\n&quot;;    &#125;;     ss &lt;&lt; std::quoted(in);    show(in);    ss &gt;&gt; std::quoted(out);    show(out);     ss.str(&quot;&quot;); // clear the stream buffer     in = &quot;String with spaces, and embedded $quotes$ too&quot;;    const char delim &#123;&#x27;$&#x27;&#125;;    const char escape &#123;&#x27;%&#x27;&#125;;     ss &lt;&lt; std::quoted(in, delim, escape);    show(in);    ss &gt;&gt; std::quoted(out, delim, escape);    show(out);&#125;\n\n输出\nread in     [String with spaces, and embedded &quot;quotes&quot; too]stored as   [&quot;String with spaces, and embedded \\&quot;quotes\\&quot; too&quot;]written out [String with spaces, and embedded &quot;quotes&quot; too] read in     [String with spaces, and embedded $quotes$ too]stored as   [$String with spaces, and embedded %$quotes%$ too$]written out [String with spaces, and embedded $quotes$ too]\n\n在给定的代码中，delim 和 escape 是用于指定自定义的分隔符和转义字符的参数。这些参数是用于 std::quoted 函数的重载形式，允许你指定不同于默认引号的字符来包围字符串，并指定一个不同于默认转义字符的字符来转义引号字符。以下是关于这两个参数的详细解释：\n\ndelim: 分隔符 在第一个用法中，std::quoted 函数使用了三个参数的重载形式：std::quoted(in, delim, escape)。delim 参数用于指定包围字符串的分隔符。通常情况下，std::quoted 使用双引号作为默认分隔符，但在某些情况下，你可能想要使用其他字符来包围字符串，以避免与字符串本身的字符冲突。在你的代码示例中，分隔符 delim 被设置为 $，这意味着字符串会被包围在 $ 字符内。\nescape: 转义字符 escape 参数允许你指定一个字符，用于转义分隔符字符本身。在默认情况下，std::quoted 使用双引号 &quot; 作为转义字符，以确保在字符串中嵌入的引号不会被解释为结束引号。但如果你选择了自定义的分隔符，你可能还需要指定一个不同于默认转义字符的字符来进行转义。在你的代码示例中，转义字符 escape 被设置为 %，这意味着在字符串中，如果你想要表示分隔符 $ 本身，你需要使用 %$。\n\n这部分也不是很容易搞明白它是干嘛的，如果面试官问道了就说我不会吧😭\n","categories":["遇见C++"],"tags":["C++","数据结构","C++14"]},{"title":"【C++】使用CPP+STMP发送邮件","url":"/posts/4118547036/","content":"本文转载于CSDN，找了好久才找到的可用的邮件代码！\n原文标题：c++实现smtp发送邮件，支持ssl的465端口发送，支持附件、一次发送多人、抄送等原文链接：https://blog.csdn.net/weixin_44979075/article/details/131094396原文作者：樱花回忆\n\n前言c++实现smtp发送邮件，支持ssl的465端口发送，支持附件、一次发送多人、抄送等。  \n这里只使用了openssl库（用来支持ssl的465端口），其他部分是原生c++,支持在win&#x2F;linux运行。  \n网上很多都是原始的支持25端口，明文发送，这里介绍一下ssl思路\n实现思路使用sockect编程和ssl，使用SMTP协议。  \n使用了c++的多态语言特性，包括重载和虚函数。  \n文中给出mail.h 和mail.cpp 以及main.cpp部分测试代码Linux安装openssl\nsudo apt install libssl-dev\n\nwin下自行下载安装\nSMTP协议简介SMTP协议的定义1、SMTP 是一种TCP协议支持的提供可靠且有效电子邮件传输的应用层协议；2、SMTP 是建立在 TCP上的一种邮件服务，主要用于传输系统之间的邮件信息并提供来信有关的通知；3、SMTP 独立于特定的传输子系统，且只需要可靠有序的数据流信道支持；4、SMTP 重要特性之一是其能跨越网络传输邮件，即“ SMTP 邮件中继”；5、SMTP是一个相对简单的基于文本的协议。\nSMTP基本命令SMTP基本命令包括以下几个：HELO﹑EHLO、MAIL﹑RCPT﹑DATA、AUTH LOGIN和QUIT1、HELO–发件方问候收件方，后面是发件人的服务器地址或标识。收件方回答OK时标识自己的身份。问候和确认过程表明两台机器可以进行通信，同时状态参量被复位，缓冲区被清空。EHLO–申明身份，表示自己身份需要验证，注意这部分需要通过Telnet验证一下，是&#x75;&#x73;&#x65;&#114;&#x40;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#109;还是user，否则会出错。2、MAIL–这个命令用来开始传送邮件，它的后面跟随发件方邮件地址（返回邮件地址）。它也用来当邮件无法送达时，发送失败通知。为保证邮件的成功发送，发件方的地址应是被对方或中间转发方同意接受的。这个命令会清空有关的缓冲区，为新的邮件做准备。3、RCPT –这个命令告诉收件方收件人的邮箱。当有多个收件人时，需要多次使用该命令RCPT4、TO，每次只能指明一个人。如果接收方服务器不同意转发这个地址的邮件，它必须报550错误代码通知发件方。如果服务器同意转发，它要更改邮件发送路径，把最开始的目的地（该服务器）换成下一个服务器。5、DATA–收件方把该命令之后的数据作为发送的数据。数据被加入数据缓冲区中，以单独一行是”.”的行结束数据。结束行对于接收方同时意味立即开始缓冲区内的数据传送，传送结束后清空缓冲区。如果传送接受，接收方回复OK。6、QUIT–SMTP要求接收放必须回答OK，然后中断传输；在收到这个命令并回答OK前，收件方不得中断连接，即使传输出现错误。发件方在发出这个命令并收到OK答复前，也不得中断连接。7、AUTH LOGIN–登录邮箱，这一部分一般要用base64加密。\n头文件mail.h#pragma once#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;openssl/ossl_typ.h&gt;#ifndef WIN32#include&lt;netdb.h&gt;#endifclass SmtpBase&#123;protected:    struct EmailInfo    &#123;        std::string smtpServer;      //the SMTP server        std::string serverPort;      //the SMTP server port        std::string charset;         //the email character set        std::string sender;          //the sender&#x27;s name        std::string senderEmail;     //the sender&#x27;s email        std::string password;        //the password of sender        std::string recipient;       //the recipient&#x27;s name        std::string recipientEmail;  //the recipient&#x27;s email        std::map&lt;std::string, std::string&gt; recvList; //收件人列表&lt;email, name&gt;        std::string subject;         //the email message&#x27;s subject  邮件主题        std::string message;         //the email message body   邮件内容        std::map&lt;std::string, std::string&gt; ccEmail;         //抄送列表        std::vector&lt;std::string&gt; attachment; //附件    &#125;;public:    virtual ~SmtpBase() &#123;&#125;    /**     * @brief 简单发送文本邮件     * @param   from 发送者的帐号     * @param   passs 发送者密码     * @param   to 收件人     * @param   subject 主题     * @param   strMessage  邮件内容     */    virtual int SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::string&amp; to, const std::string&amp; subject, const std::string&amp; strMessage) = 0;    /**     * @brief 发送邮件，包括附件以及抄送人和多个收件人     * @param   from 发送者的帐号     * @param   passs 发送者密码     * @param   vecTo 收件人列表     * @param   subject 主题     * @param   strMessage  邮件内容     * @param   attachment  附件列表    附件可以是绝对路径，默认是可执行程序目录下     * @param   ccList  抄送列表     */    virtual int SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::vector&lt;std::string&gt;&amp; vecTo,        const std::string&amp; subject, const std::string&amp; strMessage, const std::vector&lt;std::string&gt;&amp; attachment,const std::vector&lt;std::string&gt;&amp; ccList) = 0;    std::string GetLastError()    &#123;        return m_lastErrorMsg;    &#125;    virtual int Read(void* buf, int num) = 0;    virtual int Write(const void* buf, int num) = 0;    virtual int Connect() = 0;    virtual int DisConnect() = 0;protected:    std::string m_lastErrorMsg;&#125;;class SmtpEmail : public SmtpBase&#123;public:    SmtpEmail(const std::string&amp; emailHost, const std::string&amp; port);    ~SmtpEmail();    int SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::string&amp; to, const std::string&amp; subject, const std::string&amp; strMessage);    int SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::vector&lt;std::string&gt;&amp; vecTo,        const std::string&amp; subject, const std::string&amp; strMessage, const std::vector&lt;std::string&gt;&amp; attachment, const std::vector&lt;std::string&gt;&amp; ccList);protected:    int Read(void* buf, int num);    int Write(const void* buf, int num);    int Connect();    int DisConnect();    virtual std::string GetEmailBody(const EmailInfo &amp; info);private:    //int SMTPSSLComunicate(SSL *connection, const EmailInfo &amp;info);    int SMTPComunicate(const EmailInfo &amp;info);protected:    addrinfo* m_addrinfo;    int m_socketfd;    std::string m_host;    std::string m_port;    bool m_isConnected;&#125;;class SimpleSmtpEmail : public SmtpEmail&#123;public:    using SmtpEmail::SmtpEmail;    virtual std::string GetEmailBody(const EmailInfo &amp; info);&#125;;class SslSmtpEmail : public SmtpEmail&#123;public:    using SmtpEmail::SmtpEmail;    ~SslSmtpEmail();    int Connect();    int DisConnect();protected:    int Read(void* buf, int num);    int Write(const void* buf, int num);private:    SSL_CTX *m_ctx;    SSL *m_ssl;&#125;;class SimpleSslSmtpEmail : public SslSmtpEmail&#123;public:    using SslSmtpEmail::SslSmtpEmail;    virtual std::string GetEmailBody(const EmailInfo &amp; info);&#125;;\n\n\n实现文件mail.cpp#ifdef WIN32#include &lt;WinSock2.h&gt;#endif#include &quot;mail.h&quot;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;openssl/err.h&gt;#include &lt;openssl/ssl.h&gt;#ifdef WIN32#include &lt;WinSock2.h&gt;#include &lt;WS2tcpip.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)#else #include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;#define INVALID_SOCKET -1#endiftemplate&lt;typename T&gt;std::string join(T&amp; vecData, const std::string&amp; delim)&#123;    if (vecData.size() &lt;= 0)    &#123;        return std::string();    &#125;    std::stringstream ss;    for (auto&amp; item : vecData)    &#123;        ss &lt;&lt; delim  &lt;&lt; item ;    &#125;    return ss.str().substr(delim.length());&#125;const char MimeTypes[][2][128] =&#123;    &#123; &quot;***&quot;,    &quot;application/octet-stream&quot; &#125;,    &#123; &quot;csv&quot;,    &quot;text/csv&quot; &#125;,    &#123; &quot;tsv&quot;,    &quot;text/tab-separated-values&quot; &#125;,    &#123; &quot;tab&quot;,    &quot;text/tab-separated-values&quot; &#125;,    &#123; &quot;html&quot;,    &quot;text/html&quot; &#125;,    &#123; &quot;htm&quot;,    &quot;text/html&quot; &#125;,    &#123; &quot;doc&quot;,    &quot;application/msword&quot; &#125;,    &#123; &quot;docx&quot;,    &quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot; &#125;,    &#123; &quot;ods&quot;,    &quot;application/x-vnd.oasis.opendocument.spreadsheet&quot; &#125;,    &#123; &quot;odt&quot;,    &quot;application/vnd.oasis.opendocument.text&quot; &#125;,    &#123; &quot;rtf&quot;,    &quot;application/rtf&quot; &#125;,    &#123; &quot;sxw&quot;,    &quot;application/vnd.sun.xml.writer&quot; &#125;,    &#123; &quot;txt&quot;,    &quot;text/plain&quot; &#125;,    &#123; &quot;xls&quot;,    &quot;application/vnd.ms-excel&quot; &#125;,    &#123; &quot;xlsx&quot;,    &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot; &#125;,    &#123; &quot;pdf&quot;,    &quot;application/pdf&quot; &#125;,    &#123; &quot;ppt&quot;,    &quot;application/vnd.ms-powerpoint&quot; &#125;,    &#123; &quot;pps&quot;,    &quot;application/vnd.ms-powerpoint&quot; &#125;,    &#123; &quot;pptx&quot;,    &quot;application/vnd.openxmlformats-officedocument.presentationml.presentation&quot; &#125;,    &#123; &quot;wmf&quot;,    &quot;image/x-wmf&quot; &#125;,    &#123; &quot;atom&quot;,    &quot;application/atom+xml&quot; &#125;,    &#123; &quot;xml&quot;,    &quot;application/xml&quot; &#125;,    &#123; &quot;json&quot;,    &quot;application/json&quot; &#125;,    &#123; &quot;js&quot;,    &quot;application/javascript&quot; &#125;,    &#123; &quot;ogg&quot;,    &quot;application/ogg&quot; &#125;,    &#123; &quot;ps&quot;,    &quot;application/postscript&quot; &#125;,    &#123; &quot;woff&quot;,    &quot;application/x-woff&quot; &#125;,    &#123; &quot;xhtml&quot;,&quot;application/xhtml+xml&quot; &#125;,    &#123; &quot;xht&quot;,    &quot;application/xhtml+xml&quot; &#125;,    &#123; &quot;zip&quot;,    &quot;application/zip&quot; &#125;,    &#123; &quot;gz&quot;,    &quot;application/x-gzip&quot; &#125;,    &#123; &quot;rar&quot;,    &quot;application/rar&quot; &#125;,    &#123; &quot;rm&quot;,    &quot;application/vnd.rn-realmedia&quot; &#125;,    &#123; &quot;rmvb&quot;,    &quot;application/vnd.rn-realmedia-vbr&quot; &#125;,    &#123; &quot;swf&quot;,    &quot;application/x-shockwave-flash&quot; &#125;,    &#123; &quot;au&quot;,        &quot;audio/basic&quot; &#125;,    &#123; &quot;snd&quot;,    &quot;audio/basic&quot; &#125;,    &#123; &quot;mid&quot;,    &quot;audio/mid&quot; &#125;,    &#123; &quot;rmi&quot;,        &quot;audio/mid&quot; &#125;,    &#123; &quot;mp3&quot;,    &quot;audio/mpeg&quot; &#125;,    &#123; &quot;aif&quot;,    &quot;audio/x-aiff&quot; &#125;,    &#123; &quot;aifc&quot;,    &quot;audio/x-aiff&quot; &#125;,    &#123; &quot;aiff&quot;,    &quot;audio/x-aiff&quot; &#125;,    &#123; &quot;m3u&quot;,    &quot;audio/x-mpegurl&quot; &#125;,    &#123; &quot;ra&quot;,    &quot;audio/vnd.rn-realaudio&quot; &#125;,    &#123; &quot;ram&quot;,    &quot;audio/vnd.rn-realaudio&quot; &#125;,    &#123; &quot;wav&quot;,    &quot;audio/x-wave&quot; &#125;,    &#123; &quot;wma&quot;,    &quot;audio/x-ms-wma&quot; &#125;,    &#123; &quot;m4a&quot;,    &quot;audio/x-m4a&quot; &#125;,    &#123; &quot;bmp&quot;,    &quot;image/bmp&quot; &#125;,    &#123; &quot;gif&quot;,    &quot;image/gif&quot; &#125;,    &#123; &quot;jpe&quot;,    &quot;image/jpeg&quot; &#125;,    &#123; &quot;jpeg&quot;,    &quot;image/jpeg&quot; &#125;,    &#123; &quot;jpg&quot;,    &quot;image/jpeg&quot; &#125;,    &#123; &quot;jfif&quot;,    &quot;image/jpeg&quot; &#125;,    &#123; &quot;png&quot;,    &quot;image/png&quot; &#125;,    &#123; &quot;svg&quot;,    &quot;image/svg+xml&quot; &#125;,    &#123; &quot;tif&quot;,    &quot;image/tiff&quot; &#125;,    &#123; &quot;tiff&quot;,    &quot;image/tiff&quot; &#125;,    &#123; &quot;ico&quot;,    &quot;image/vnd.microsoft.icon&quot; &#125;,    &#123; &quot;css&quot;,    &quot;text/css&quot; &#125;,    &#123; &quot;bas&quot;,    &quot;text/plain&quot; &#125;,    &#123; &quot;c&quot;,        &quot;text/plain&quot; &#125;,    &#123; &quot;h&quot;,        &quot;text/plain&quot; &#125;,    &#123; &quot;rtx&quot;,    &quot;text/richtext&quot; &#125;,    &#123; &quot;mp2&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpa&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpe&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpeg&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpg&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mpv2&quot;,    &quot;video/mpeg&quot; &#125;,    &#123; &quot;mov&quot;,    &quot;video/quicktime&quot; &#125;,    &#123; &quot;qt&quot;,    &quot;video/quicktime&quot; &#125;,    &#123; &quot;lsf&quot;,    &quot;video/x-la-asf&quot; &#125;,    &#123; &quot;lsx&quot;,    &quot;video/x-la-asf&quot; &#125;,    &#123; &quot;asf&quot;,    &quot;video/x-ms-asf&quot; &#125;,    &#123; &quot;asr&quot;,    &quot;video/x-ms-asf&quot; &#125;,    &#123; &quot;asx&quot;,    &quot;video/x-ms-asf&quot; &#125;,    &#123; &quot;avi&quot;,    &quot;video/x-msvideo&quot; &#125;,    &#123; &quot;3gp&quot;,    &quot;video/3gpp&quot; &#125;,    &#123; &quot;3gpp&quot;,    &quot;video/3gpp&quot; &#125;,    &#123; &quot;3g2&quot;,    &quot;video/3gpp2&quot; &#125;,    &#123; &quot;movie&quot;,&quot;video/x-sgi-movie&quot; &#125;,    &#123; &quot;mp4&quot;,    &quot;video/mp4&quot; &#125;,    &#123; &quot;wmv&quot;,    &quot;video/x-ms-wmv&quot; &#125;,    &#123; &quot;webm&quot;,&quot;video/webm&quot; &#125;,    &#123; &quot;m4v&quot;,    &quot;video/x-m4v&quot; &#125;,    &#123; &quot;flv&quot;,    &quot;video/x-flv&quot; &#125;&#125;;std::string fileBasename(const std::string path) &#123;    std::string filename = path.substr(path.find_last_of(&quot;/\\\\&quot;) + 1);//解析出文件名字    return filename;&#125;std::string getFileContents(const char *filename)&#123;    std::ifstream in(filename, std::ios::in | std::ios::binary);    if (in)    &#123;        std::string contents;        in.seekg(0, std::ios::end);        contents.resize(in.tellg());        in.seekg(0, std::ios::beg);        in.read(&amp;contents[0], contents.size());        in.close();        return(contents);    &#125;    else &#123;        printf(&quot;文件读取失败:%s\\n&quot;,filename);        return &quot;&quot;;    &#125;&#125;//获取文件的后缀名 如xxx.jpg 获取的是jpgstd::string GetFileExtension(const std::string&amp; FileName)&#123;    if (FileName.find_last_of(&quot;.&quot;) != std::string::npos)        //find_last_of逆向查找在原字符串中最后一个与指定字符串（或字符）中的某个字符匹配的字符，返回它的位置。若查找失败，则返回npos。        return FileName.substr(FileName.find_last_of(&quot;.&quot;) + 1);    return &quot;&quot;;&#125;const char* GetMimeTypeFromFileName(char* szFileExt)&#123;    for (unsigned int i = 0; i &lt; sizeof(MimeTypes) / sizeof(MimeTypes[0]); i++)    &#123;        if (strcmp(MimeTypes[i][0], szFileExt) == 0)        &#123;            return MimeTypes[i][1];        &#125;    &#125;    return MimeTypes[0][1];   //if does not match any,  &quot;application/octet-stream&quot; is returned&#125;char* base64Encode(char const* origSigned, unsigned origLength)&#123;    static const char base64Char[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;    unsigned char const* orig = (unsigned char const*)origSigned; // in case any input bytes have the MSB set    if (orig == NULL) return NULL;    unsigned const numOrig24BitValues = origLength / 3;    bool havePadding = origLength &gt; numOrig24BitValues * 3;    bool havePadding2 = origLength == numOrig24BitValues * 3 + 2;    unsigned const numResultBytes = 4 * (numOrig24BitValues + havePadding);    char* result = new char[numResultBytes + 3]; // allow for trailing &#x27;/0&#x27;    // Map each full group of 3 input bytes into 4 output base-64 characters:    unsigned i;    for (i = 0; i &lt; numOrig24BitValues; ++i)    &#123;        result[4 * i + 0] = base64Char[(orig[3 * i] &gt;&gt; 2) &amp; 0x3F];        result[4 * i + 1] = base64Char[(((orig[3 * i] &amp; 0x3) &lt;&lt; 4) | (orig[3 * i + 1] &gt;&gt; 4)) &amp; 0x3F];        result[4 * i + 2] = base64Char[((orig[3 * i + 1] &lt;&lt; 2) | (orig[3 * i + 2] &gt;&gt; 6)) &amp; 0x3F];        result[4 * i + 3] = base64Char[orig[3 * i + 2] &amp; 0x3F];    &#125;    // Now, take padding into account.  (Note: i == numOrig24BitValues)    if (havePadding)    &#123;        result[4 * i + 0] = base64Char[(orig[3 * i] &gt;&gt; 2) &amp; 0x3F];        if (havePadding2)        &#123;            result[4 * i + 1] = base64Char[(((orig[3 * i] &amp; 0x3) &lt;&lt; 4) | (orig[3 * i + 1] &gt;&gt; 4)) &amp; 0x3F];            result[4 * i + 2] = base64Char[(orig[3 * i + 1] &lt;&lt; 2) &amp; 0x3F];        &#125;        else        &#123;            result[4 * i + 1] = base64Char[((orig[3 * i] &amp; 0x3) &lt;&lt; 4) &amp; 0x3F];            result[4 * i + 2] = &#x27;=&#x27;;        &#125;        result[4 * i + 3] = &#x27;=&#x27;;    &#125;    result[numResultBytes] = &#x27;\\0&#x27;;    return result;&#125;int SmtpEmail::SMTPComunicate(const EmailInfo &amp;info)&#123;    if (Connect() != 0)    &#123;        return -1;    &#125;    char * buffer = new char[1000];    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;220&quot;, 3) != 0) // not equal to 220    &#123;        m_lastErrorMsg = buffer;        return 220;    &#125;    //向服务器发送ehlo    std::string command = &quot;ehlo EmailService\\r\\n&quot;;    Write(command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;250&quot;, 3) != 0) // ehlo failed    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    //进行登录验证    command = &quot;AUTH PLAIN &quot;;    std::string auth = &#x27;\\0&#x27; + info.senderEmail + &#x27;\\0&#x27; + info.password;    command += base64Encode(auth.data(), auth.size());    command += &quot;\\r\\n&quot;;    Write(command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;235&quot;, 3) != 0) // login failed    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    //设置邮件发送者的邮箱地址    command = &quot;mail FROM:&lt;&quot; + info.senderEmail + &quot;&gt;\\r\\n&quot;;    Write( command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;250&quot;, 3) != 0) // not ok    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    //设置邮件接收者的邮箱地址    command = &quot;RCPT TO:&lt;&quot; + info.recipientEmail + &quot;&gt;\\r\\n&quot;;    Write( command.c_str(), command.length());    memset(buffer, 0, 1000);    Read( buffer, 999);    if (strncmp(buffer, &quot;250&quot;, 3) != 0) // not ok    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    //准备发送邮件    command = &quot;data\\r\\n&quot;;    Write( command.c_str(), command.length());    memset(buffer, 0, 1000);    Read( buffer, 999);    if (strncmp(buffer, &quot;354&quot;, 3) != 0) // not ready to receive message    &#123;        m_lastErrorMsg = buffer;        return 354;    &#125;    command = std::move(GetEmailBody(info));    Write( command.c_str(), command.length());    memset(buffer, 0, 1000);    Read(buffer, 999);    if (strncmp(buffer, &quot;250&quot;, 3) != 0) // not ok    &#123;        m_lastErrorMsg = buffer;        return 250;    &#125;    //结束发送过程    delete buffer;    Write( &quot;quit\\r\\n&quot;, 6);    DisConnect();    return 0;&#125;std::string SmtpEmail::GetEmailBody(const EmailInfo &amp;info)&#123;    //设定邮件的发送者名称、接收者名称、邮件主题，邮件内容。    std::ostringstream message;    message &lt;&lt; &quot;From: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.sender.c_str(), info.sender.length()) &lt;&lt; &quot;?= &lt;&quot; &lt;&lt; info.senderEmail &lt;&lt; &quot;&gt;\\r\\n&quot;;    std::vector&lt;std::string&gt; vecToList;    for (auto item : info.recvList)    &#123;        std::string to = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.second.c_str(), item.second.length()) + &quot;?= &lt;&quot; + item.first + &quot;&gt;&quot;;        vecToList.push_back(to);    &#125;    message &lt;&lt; &quot;To: &quot; &lt;&lt; join(vecToList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    message &lt;&lt; &quot;Subject: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.subject.c_str(), info.subject.length()) &lt;&lt; &quot;?=\\r\\n&quot;;    message &lt;&lt; &quot;MIME-Version: 1.0\\r\\n&quot;;    if (info.ccEmail.size() &gt; 0)    &#123;        std::vector&lt;std::string&gt; vecCcList;        for (auto item : info.ccEmail)        &#123;            std::string cc = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.first.c_str(), item.first.length()) + &quot;?= &lt;&quot; + item.second + &quot;&gt;&quot;;            vecCcList.push_back(cc);        &#125;        message &lt;&lt; &quot;Cc:&quot; &lt;&lt; join(vecCcList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    &#125;    message &lt;&lt; &quot;Content-Type:multipart/mixed; boundary=\\&quot;Separator_ztq_000\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: multipart/alternative; boundary=\\&quot;Separator_ztq_111\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; &quot;text/plain&quot; &lt;&lt; &quot;; charset=\\&quot;&quot; &lt;&lt; info.charset &lt;&lt; &quot;\\&quot;\\r\\n&quot;;    message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;    message &lt;&lt; &quot;\\r\\n&quot;;                  //此处要加，不然邮件正文无内容    message &lt;&lt; base64Encode(info.message.c_str(), info.message.length());    message &lt;&lt; &quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111--\\r\\n&quot;;    //---------------------文件部分处理--------------------------------------    for (auto item : info.attachment)    &#123;        std::string filename = fileBasename(item);        std::string strContext = getFileContents(item.c_str());        if(strContext.empty())        &#123;            std::cerr &lt;&lt; &quot;请检查传入的文件路径是否正确,此路径文件添加到附件失败，不发送此文件:&quot; &lt;&lt; std::endl;            std::cerr &lt;&lt; item &lt;&lt; std::endl;        &#125;        else        &#123;            std::string fileContext = base64Encode(strContext.c_str(), strContext.length());            std::string extension = GetFileExtension(filename);            std::string mimetype = GetMimeTypeFromFileName((char*)extension.c_str());            message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;            message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; mimetype &lt;&lt; &quot;; name=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n&quot;;            message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;            message &lt;&lt; &quot;Content-Disposition: attachment; filename=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n\\r\\n&quot;;            message &lt;&lt; fileContext + &quot;\\r\\n\\r\\n&quot;;        //把读取到的文件内容以二进制形式发送        &#125;    &#125;    //-----------------------------------------------------------    message &lt;&lt; &quot;\\r\\n.\\r\\n&quot;;    return message.str();&#125;SmtpEmail::SmtpEmail(const std::string&amp; emailHost, const std::string&amp; port) :m_host(emailHost), m_port(port)&#123;&#125;SmtpEmail::~SmtpEmail()&#123;&#125;int SmtpEmail::Read(void* buf, int num)&#123;    return recv(m_socketfd, (char*)buf, num, 0);&#125;int SmtpEmail::Write(const void* buf, int num)&#123;    return send(m_socketfd, (char*)buf, num, 0);&#125;int SmtpEmail::Connect()&#123;#ifdef WIN32    //start socket connection    WSADATA wsadata;    WSAStartup(MAKEWORD(2, 2), &amp;wsadata);#endif    m_socketfd = socket(AF_INET, SOCK_STREAM, 0);    if (m_socketfd == INVALID_SOCKET)    &#123;        m_lastErrorMsg = &quot;Error on creating socket fd.&quot;;        return -1;    &#125;    addrinfo inAddrInfo = &#123; 0 &#125;;    inAddrInfo.ai_family = AF_INET;    inAddrInfo.ai_socktype = SOCK_STREAM;    printf(&quot;host:%s port:%s \\n&quot;,m_host.c_str(), m_port.c_str());    if (getaddrinfo(m_host.c_str(), m_port.c_str(), &amp;inAddrInfo, &amp;m_addrinfo) != 0) // error occurs    &#123;        m_lastErrorMsg = &quot;Error on calling getadrrinfo().&quot;;        return -2;    &#125;    if (connect(m_socketfd, m_addrinfo-&gt;ai_addr, m_addrinfo-&gt;ai_addrlen))    &#123;        m_lastErrorMsg = &quot;Error on calling connect().&quot;;        return -3;    &#125;    return 0;&#125;int SmtpEmail::DisConnect()&#123;    freeaddrinfo(m_addrinfo);#ifdef WIN32    closesocket(m_socketfd);#else    close(m_socketfd);#endif    return 0;&#125;/*********************************************************************************/std::string SimpleSmtpEmail::GetEmailBody(const EmailInfo &amp;info)&#123;    //设定邮件的发送者名称、接收者名称、邮件主题，邮件内容。    std::ostringstream message;    message &lt;&lt; &quot;From: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.sender.c_str(), info.sender.length()) &lt;&lt; &quot;?= &lt;&quot; &lt;&lt; info.senderEmail &lt;&lt; &quot;&gt;\\r\\n&quot;;    std::vector&lt;std::string&gt; vecToList;    for (auto item : info.recvList)    &#123;        std::string to = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.second.c_str(), item.second.length()) + &quot;?= &lt;&quot; + item.first + &quot;&gt;&quot;;        vecToList.push_back(to);    &#125;    message &lt;&lt; &quot;To: &quot; &lt;&lt; join(vecToList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    message &lt;&lt; &quot;Subject: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.subject.c_str(), info.subject.length()) &lt;&lt; &quot;?=\\r\\n&quot;;    message &lt;&lt; &quot;MIME-Version: 1.0\\r\\n&quot;;    if (info.ccEmail.size() &gt; 0)    &#123;        std::vector&lt;std::string&gt; vecCcList;        for (auto item : info.ccEmail)        &#123;            std::string cc = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.first.c_str(), item.first.length()) + &quot;?= &lt;&quot; + item.second + &quot;&gt;&quot;;            vecCcList.push_back(cc);        &#125;        message &lt;&lt; &quot;Cc:&quot; &lt;&lt; join(vecCcList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    &#125;    message &lt;&lt; &quot;Content-Type:multipart/mixed; boundary=\\&quot;Separator_ztq_000\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: multipart/alternative; boundary=\\&quot;Separator_ztq_111\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; &quot;text/plain&quot; &lt;&lt; &quot;; charset=\\&quot;&quot; &lt;&lt; info.charset &lt;&lt; &quot;\\&quot;\\r\\n&quot;;    message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;    message &lt;&lt; &quot;\\r\\n&quot;;                  //此处要加，不然邮件正文无内容    message &lt;&lt; base64Encode(info.message.c_str(), info.message.length());    message &lt;&lt; &quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111--\\r\\n&quot;;    //---------------------文件部分处理--------------------------------------    for (auto item : info.attachment)    &#123;        std::string filename = fileBasename(item);        std::string strContext = getFileContents(item.c_str());        if(strContext.empty())        &#123;            std::cerr &lt;&lt; &quot;请检查传入的文件路径是否正确,此路径文件添加到附件失败，不发送此文件:&quot; &lt;&lt; std::endl;            std::cerr &lt;&lt; item &lt;&lt; std::endl;        &#125;        else        &#123;            std::string fileContext = base64Encode(strContext.c_str(), strContext.length());            std::string extension = GetFileExtension(filename);            std::string mimetype = GetMimeTypeFromFileName((char*)extension.c_str());            message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;            message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; mimetype &lt;&lt; &quot;; name=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n&quot;;            message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;            message &lt;&lt; &quot;Content-Disposition: attachment; filename=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n\\r\\n&quot;;            message &lt;&lt; fileContext + &quot;\\r\\n\\r\\n&quot;;        //把读取到的文件内容以二进制形式发送        &#125;    &#125;    //-----------------------------------------------------------    message &lt;&lt; &quot;\\r\\n.\\r\\n&quot;;    return message.str();&#125;/***************************************************************************************************/SslSmtpEmail::~SslSmtpEmail()&#123;&#125;int SslSmtpEmail::Connect()&#123;    if (SmtpEmail::Connect() == 0)    &#123;        SSL_library_init();        OpenSSL_add_all_algorithms();        SSL_load_error_strings();        m_ctx = SSL_CTX_new(SSLv23_client_method());        m_ssl = SSL_new(m_ctx);        SSL_set_fd(m_ssl, m_socketfd);        SSL_connect(m_ssl);    &#125;    return 0;&#125;int SslSmtpEmail::DisConnect()&#123;    SSL_shutdown(m_ssl);    SSL_free(m_ssl);    SSL_CTX_free(m_ctx);    SmtpEmail::DisConnect();    return 0;&#125;int SmtpEmail::SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::string&amp; to, const std::string&amp; subject, const std::string&amp; strMessage)&#123;    EmailInfo info;    info.charset = &quot;UTF-8&quot;;    info.sender = from;    info.password = passs;    info.senderEmail = from;    info.recipientEmail = to;    info.recvList[to] = &quot;&quot;;    info.subject = subject;    info.message = strMessage;    return SMTPComunicate(info);&#125;int SmtpEmail::SendEmail(const std::string&amp; from, const std::string&amp; passs, const std::vector&lt;std::string&gt;&amp; vecTo,                         const std::string&amp; subject, const std::string&amp; strMessage, const std::vector&lt;std::string&gt;&amp; attachment, const std::vector&lt;std::string&gt;&amp; ccList)&#123;    std::vector&lt;std::string&gt; recvList;    recvList.insert(recvList.end(), vecTo.begin(), vecTo.end());    recvList.insert(recvList.end(), ccList.begin(), ccList.end());    for (auto&amp; item : recvList)    &#123;        EmailInfo info;        info.charset = &quot;UTF-8&quot;;        info.sender = from;        info.password = passs;        info.senderEmail = from;;        info.recipientEmail = item;        for (auto item : vecTo)        &#123;            info.recvList[item] = &quot;&quot;;        &#125;        info.subject = subject;        info.message = strMessage;        for (auto&amp; item : ccList)        &#123;            info.ccEmail[item] = item;        &#125;        info.attachment = attachment;        if (SMTPComunicate(info) != 0)        &#123;            return -1;        &#125;    &#125;    return 0;&#125;int SslSmtpEmail::Read(void * buf, int num)&#123;    int ret = SSL_read(m_ssl, buf, num);    return ret;&#125;int SslSmtpEmail::Write(const void * buf, int num)&#123;    return SSL_write(m_ssl, buf, num);&#125;std::string SimpleSslSmtpEmail::GetEmailBody(const EmailInfo &amp;info)&#123;    //设定邮件的发送者名称、接收者名称、邮件主题，邮件内容。    std::ostringstream message;    message &lt;&lt; &quot;From: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.sender.c_str(), info.sender.length()) &lt;&lt; &quot;?= &lt;&quot; &lt;&lt; info.senderEmail &lt;&lt; &quot;&gt;\\r\\n&quot;;    std::vector&lt;std::string&gt; vecToList;    for (auto item : info.recvList)    &#123;        std::string to = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.second.c_str(), item.second.length()) + &quot;?= &lt;&quot; + item.first + &quot;&gt;&quot;;        vecToList.push_back(to);    &#125;    message &lt;&lt; &quot;To: &quot; &lt;&lt; join(vecToList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    message &lt;&lt; &quot;Subject: =?&quot; &lt;&lt; info.charset &lt;&lt; &quot;?b?&quot; &lt;&lt; base64Encode(info.subject.c_str(), info.subject.length()) &lt;&lt; &quot;?=\\r\\n&quot;;    message &lt;&lt; &quot;MIME-Version: 1.0\\r\\n&quot;;    if (info.ccEmail.size() &gt; 0)    &#123;        std::vector&lt;std::string&gt; vecCcList;        for (auto item : info.ccEmail)        &#123;            std::string cc = &quot;=?&quot; + info.charset + &quot;?b?&quot; + base64Encode(item.first.c_str(), item.first.length()) + &quot;?= &lt;&quot; + item.second + &quot;&gt;&quot;;            vecCcList.push_back(cc);        &#125;        message &lt;&lt; &quot;Cc:&quot; &lt;&lt; join(vecCcList, &quot;,&quot;) &lt;&lt; &quot;\\r\\n&quot;;    &#125;    message &lt;&lt; &quot;Content-Type:multipart/mixed; boundary=\\&quot;Separator_ztq_000\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: multipart/alternative; boundary=\\&quot;Separator_ztq_111\\&quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111\\r\\n&quot;;    message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; &quot;text/plain&quot; &lt;&lt; &quot;; charset=\\&quot;&quot; &lt;&lt; info.charset &lt;&lt; &quot;\\&quot;\\r\\n&quot;;    message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;    message &lt;&lt; &quot;\\r\\n&quot;;                  //此处要加，不然邮件正文无内容    message &lt;&lt; base64Encode(info.message.c_str(), info.message.length());    message &lt;&lt; &quot;\\r\\n\\r\\n&quot;;    message &lt;&lt; &quot;--Separator_ztq_111--\\r\\n&quot;;    //---------------------文件部分处理--------------------------------------    for (auto item : info.attachment)    &#123;        std::string filename = fileBasename(item);        std::string strContext = getFileContents(item.c_str());        if(strContext.empty())        &#123;            std::cerr &lt;&lt; &quot;请检查传入的文件路径是否正确,此路径文件添加到附件失败，不发送此文件:&quot; &lt;&lt; std::endl;            std::cerr &lt;&lt; item &lt;&lt; std::endl;        &#125;        else        &#123;            std::string fileContext = base64Encode(strContext.c_str(), strContext.length());            std::string extension = GetFileExtension(filename);            std::string mimetype = GetMimeTypeFromFileName((char*)extension.c_str());            message &lt;&lt; &quot;--Separator_ztq_000\\r\\n&quot;;            message &lt;&lt; &quot;Content-Type: &quot; &lt;&lt; mimetype &lt;&lt; &quot;; name=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n&quot;;            message &lt;&lt; &quot;Content-Transfer-Encoding: base64\\r\\n&quot;;            message &lt;&lt; &quot;Content-Disposition: attachment; filename=\\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;\\r\\n\\r\\n&quot;;            message &lt;&lt; fileContext + &quot;\\r\\n\\r\\n&quot;;        //把读取到的文件内容以二进制形式发送        &#125;    &#125;    //-----------------------------------------------------------    message &lt;&lt; &quot;\\r\\n.\\r\\n&quot;;    return message.str();&#125;\n\n\n测试代码 main.cppSendEmail函数重载，支持基本的简单发送文本邮件，和支持附件、抄送、以及发给多人的发送方式，亲测能够发送成功，默认发送的编码是utf-8格式\n#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &quot;mail.h&quot;int main()&#123;    std::string from = &quot;xxxx@163.com&quot;;    std::string passs =&quot;xxxxx&quot;;//这里替换成自己的授权码    std::string to = &quot;xxx@126.com&quot;;    std::string subject = &quot;hello&quot;;    std::string strMessage = &quot;test&quot;;    std::vector&lt;std::string&gt; vecTo; //发送列表    vecTo.push_back(&quot;xxx@126.com&quot;);    std::vector&lt;std::string&gt; ccList;    // ccList.push_back(&quot;xxx@xxx.com.cn&quot;);//抄送列表    std::vector&lt;std::string&gt; attachment;    attachment.push_back(&quot;mail.h&quot;);    attachment.push_back(&quot;/home/soft/Desktop/openwrt-sdk-imx6ul/1/mybuild.sh&quot;);    SmtpBase *base;    SimpleSmtpEmail m_mail(&quot;smtp.163.com&quot;,&quot;25&quot;);    base = &amp;m_mail;    //base-&gt;SendEmail(from, passs, to, subject, strMessage);//普通的文本发送，明文发送    SimpleSslSmtpEmail m_ssl_mail(&quot;smtp.163.com&quot;,&quot;465&quot;);    base=&amp;m_ssl_mail;    //base-&gt;SendEmail(from, passs, to, subject, strMessage);    base-&gt;SendEmail(from, passs,vecTo,subject,strMessage,attachment,ccList);//加密的发送，支持抄送、附件等    return 0;&#125;\n\n邮箱收件箱查看邮件头  \n实际收到的邮件 \n\n参考链接C++基于Smtp协议发送邮件SMTP基本原理与C++实现向多人发送邮件\n后记如果您觉得有帮助的话，请点个赞吧！有问题请留言评论，欢迎指出意见，谢谢。\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】C++17的那些新特性","url":"/posts/3858168547/","content":"学习C++17的新特性\n1.构造函数模板推导在之前，我们如果想用stl容器，都需要用&lt;&gt; 来手动指定参数类型。但在C++17中，我们不需要这么做了。\nint main()&#123;    std::vector v1 = &#123;1,2,3,4&#125;;    std::pair p1  = &#123;1,2.4234&#125;;    cout &lt;&lt; typeid(v1).name() &lt;&lt; endl;    cout &lt;&lt; typeid(p1).name() &lt;&lt; endl;    return 0;&#125;\n\n使用C++11编译，这个代码会报错。报错的意思是让我们指定参数的模板类型。\n比如 std::pair p1  = &#123;1,2.4234&#125;; 在C++11中应该写成 std::pair&lt;int,double&gt; p1  = &#123;1,2.4234&#125;;\ntest.cpp:16:10: error: use of class template &#x27;std::pair&#x27; requires template arguments    std::pair p1  = &#123;1,2.4234&#125;;         ^/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_pair.h:211:12: note: template is declared here    struct pair           ^3 errors generated.make: *** [makefile:3: test] Error 1\n\n在C++17中，这样的写法就是可以被通过的了，也能正常推断出参数的类型，分别是一个int的vector，和一个int+double的pair；\n$ makeclang++ test.cpp -o test -std=c++17$ ./testSt6vectorIiSaIiEESt4pairIidE\n\n2.结构化绑定我们可以用 auto[变量1,变量2]的方式来接受一个tuple或者pair的返回值，将其绑定到两个不同的变量上。\ntuple是C++11新增的一个数据结构，它和pair的用法类似，不同的是元组支持无数个参数。而pair仅支持两个。\nstd::tuple&lt;int, double&gt; func_tuple()&#123;    return std::tuple&lt;int,double&gt;(1, 2.2);&#125;std::pair&lt;int, double&gt; func_pair()&#123;    return &#123;1,2&#125;;&#125;int main()&#123;    auto [i, d] = func_tuple();     cout &lt;&lt; typeid(i).name() &lt;&lt; endl;    cout &lt;&lt; typeid(d).name() &lt;&lt; endl;    cout &lt;&lt; endl;    auto [x,y] = func_pair();    cout &lt;&lt; typeid(x).name() &lt;&lt; endl;    cout &lt;&lt; typeid(y).name() &lt;&lt; endl;    return 0;&#125;\n\n使用C++11来编译，编译器会报错，但编译依旧能成功。这是因为我们的编译器是支持C++17的，但又被指定了-std=c++11，所以给用户报了个警告，但没有报错（因为这个语法在C++17里面是正确的）\nclang++ test.cpp -o test -std=c++11test.cpp:34:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]    auto [i, d] = func_tuple();          ^~~~~~test.cpp:40:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]    auto [x,y] = func_pair();         ^~~~~2 warnings generated.\n\n运行输出结果如下\n$ ./testidid\n\n注意：结构化绑定不能应用于constexpr！\n结构化绑定不止可以绑定pair和tuple，还可以绑定数组和结构体等。\n// 注意这里的struct的成员一定要是public的，不然外部无法访问，还怎么绑定？struct Point&#123;    int x;    int y;&#125;;// 返回值是point的函数Point func()&#123;    return &#123;1, 2&#125;;&#125;int main()&#123;    int array[3] = &#123;1, 2, 3&#125;;    auto [a, b, c] = array;    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;    // 直接推导出两个成员变量并赋值给变量x和y    const auto [x, y] = func();    return 0;&#125;\n成功编译并输出结果\n$ makeclang++ test.cpp -o test -std=c++17$ ./test1 2 31 2\n\n自定义类型也能实现结构化绑定，这里从网上扒了一个代码下来，就不自己做测试了\n// 需要实现相关的tuple_size和tuple_element和get&lt;N&gt;方法。class Entry &#123;public:    void Init() &#123;        name_ = &quot;name&quot;;        age_ = 10;    &#125;    std::string GetName() const &#123; return name_; &#125;    int GetAge() const &#123; return age_; &#125;private:    std::string name_;    int age_;&#125;;template &lt;size_t I&gt;auto get(const Entry&amp; e) &#123;    if constexpr (I == 0) return e.GetName();    else if constexpr (I == 1) return e.GetAge();&#125;namespace std &#123;    template&lt;&gt; struct tuple_size&lt;Entry&gt; : integral_constant&lt;size_t, 2&gt; &#123;&#125;;    template&lt;&gt; struct tuple_element&lt;0, Entry&gt; &#123; using type = std::string; &#125;;    template&lt;&gt; struct tuple_element&lt;1, Entry&gt; &#123; using type = int; &#125;;&#125;int main() &#123;    Entry e;    e.Init();    auto [name, age] = e;    cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; // name 10    return 0;&#125;\n\n\n3.if语句新增初始条件在之前我们都是用 if(判断条件) 来使用if语句的，C++17中给if新增了一个类似for循环中第一个参数的相同参数\nif(初始化条件,判断条件)\n\n比如\nif(int i=20;i&lt;39)&#123;    cout &lt;&lt;&quot;i&lt;39!&quot;&lt;&lt;endl;&#125;\n\n运行效果如下\n$ ./testi&lt;39!\n\n4.内联变量在之前我们想初始化一个类中的static变量，需要在类中定义，类外初始化。但如果是const的static变量，就能直接在类中通过缺省值的方式来初始化。\n// 在头文件里面这样是能通过编译的，但是不建议在头文件中初始化static变量，会产生ODR冲突:// Variable &#x27;value&#x27; defined in a header file; variable definitions in header files can lead to ODR violationsstruct A &#123;    static int value;      static const int value_c=10;  // const可以直接初始化&#125;;int A::value = 10;\n\n在C++17中内联变量引入后，我们就可以直接实现在头文件中初始化static非const变量，或者直接用缺省值来初始化了\nstruct A&#123;    static int value;    static const int value_c = 10;    // static int value = 10;&#125;;inline int A::value = 10;// ========= 或者 ========struct B&#123;    inline static int value = 10;    inline static const int value_c = 10;&#125;;\n\n相比于原本static变量初始化需要放到另外一个cpp源文件中，这种直接在头文件里面声明+初始化的方式能更好的确定变量的初始值。\n5.折叠表达式C++17引入了折叠表达式使可变参数模板编程更方便：\ntemplate &lt;typename ... Ts&gt;auto sum(Ts ... ts) &#123;    return (ts + ...);&#125;int a &#123;sum(1, 2, 3, 4, 5)&#125;; // 15std::string a&#123;&quot;hello &quot;&#125;;std::string b&#123;&quot;world&quot;&#125;;cout &lt;&lt; sum(a, b) &lt;&lt; endl; // hello world\n\n实话说，可变模板参数这部分就没有弄明白过，实际上也没有用过，直接跳过！\n6.constexpr+lambda表达式C++17前lambda表达式只能在运行时使用，C++17引入了constexpr lambda表达式，可以用于在编译期进行计算。\nint main() &#123; // c++17可编译    constexpr auto lamb = [] (int n) &#123; return n * n; &#125;;    static_assert(lamb(3) == 9, &quot;a&quot;);&#125;\n\n规则和普通的constexpr函数相同，参考我的C++11和14的文章。这里做简单说明：\nconstexpr修饰的函数体不能包含汇编语句、goto语句、label、try块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有new delete等，不能虚函数。\n7.嵌套命名空间在之前如果需要嵌套命名空间，需要这样写\nnamespace A &#123;    namespace B &#123;        namespace C &#123;            void func();        &#125;    &#125;&#125;\nC++17中可以直接用类似访问限定符的方式，前面加一个namespace来标明嵌套的命名空间。\n// c++17，方便了，可读性也更好namespace A::B::C &#123;    void func();&#125;\n\n8.__has_include预处理表达式#if defined __has_include // 判断是否支持这个表达式#if __has_include(&lt;charconv&gt;) // 支持，判断是否存在该头文件#define has_charconv 1 // 头文件存在，定义一个宏#include &lt;charconv&gt; // 引用这个头文件#endif#endif\n\n如果一个代码会在多个不同的平台下跑，这个功能就很重要。比如我之前写项目的时候需要使用到jsoncpp，在centos和deepin下，安装jsoncpp的include路径是不同的\n//centos#include &lt;json/json.h&gt;//deepin#include &lt;jsoncpp/json/json.h&gt;\n\n这种场景下就可以使用上面提到的这个预处理表达式进行判断，来确认你的jsoncpp路径到底在哪里。注意，这只能解决从yum和apt安装的jsoncpp，如果是自己手动安装的，那鬼知道你安装到哪里去了？🤣\n所以很多大型项目如果需要使用jsoncpp这种第三方依赖项目，一般都会采用git submodule的方式，直接将第三方库下载到当前项目路径下，以避免不同平台的依赖项include路径不对而导致无法编译程序的问题。\n9.this指针捕获（lambda）在lambda表达式中，采用[this]方式捕获的this指针是值传递捕获的，但在一些情况下，会出现访问已经被释放了的空间的行为；比如如下代码\n#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;struct Foo&#123;    std::unique_ptr&lt;int&gt; p;    std::function&lt;void()&gt; f()    &#123;        p.reset(new int(10));        return [&amp;]        &#123;            cout &lt;&lt; 5 &lt;&lt; endl;            cout &lt;&lt; *p &lt;&lt; endl; // 实际上是这一步报错的            // 这里对*p的访问可以解析为 *(this-&gt;p)，但实际上this指针已经被销毁了            // 注意，这里采用了智能指针，不存在内存泄漏，p指针指向的空间也被销毁了            // 但我们的报错其实是对this指针解引用的时候就抛出了            cout &lt;&lt; 6 &lt;&lt; endl;        &#125;;    &#125;&#125;;int main()&#123;    auto foo = new Foo();    cout &lt;&lt; 1 &lt;&lt; endl;    auto f = foo-&gt;f();  // 获取了一个类内成员函数    cout &lt;&lt; 2 &lt;&lt; endl;    delete foo;  // 销毁这个对象    cout &lt;&lt; 3 &lt;&lt; endl;    // 尝试在销毁后继续使用这个对象，我们是通过lambda中=捕获的this指针来访问对象的    f();  // 这里直接报错了 Segmentation fault (core dumped)    cout &lt;&lt; 4 &lt;&lt; endl;    return 0;&#125;\n\n运行这个程序，可以看到是在*p的位置报错退出的；具体的原因参考代码中的注释。\n$ ./test1235Segmentation fault (core dumped)\n\n需要注意，lambda表达式中，使用&#x3D;和&amp;都会默认采用传值捕获this指针，因为this指针是存在于函数作用域中的一个隐藏参数，并不是独立在成员函数外的变量，所以是可以被捕捉到的；另外，this指针是不能被传引用捕获的，[&amp;this] 的写法是不允许的；\nclang++ test.cpp -o test -std=c++17test.cpp:84:18: error: &#x27;this&#x27; cannot be captured by reference        return [&amp;this]                 ^1 error generated.\n\nC++17中提供了一个特殊的写法 [*this] 通过传值的方式捕获了当前对象本身，此时lambda表达式中存在的就是一个对象的拷贝，即便当前对象被销毁了，我们依旧可以通过这个拷贝访问到目标；\n代码修改如下：\n#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;struct Foo&#123;    std::shared_ptr&lt;int&gt; p; // 不能用unique_ptr，因为它的拷贝构造函数是被delete禁止使用的    std::function&lt;void()&gt; f()    &#123;        p.reset(new int(10));        return [*this]        &#123;            cout &lt;&lt; 5 &lt;&lt; endl;            cout &lt;&lt; *p &lt;&lt; endl;            cout &lt;&lt; 6 &lt;&lt; endl;        &#125;;    &#125;&#125;;int main()&#123;    auto foo = new Foo();    cout &lt;&lt; 1 &lt;&lt; endl;    auto f = foo-&gt;f();  // 获取了一个类内成员函数    cout &lt;&lt; 2 &lt;&lt; endl;    delete foo;  // 销毁这个对象    cout &lt;&lt; 3 &lt;&lt; endl;    // 尝试在销毁后继续使用这个对象，我们是通过lambda中=捕获的this指针来访问对象的    f();  // 这里直接报错了 Segmentation fault (core dumped)    cout &lt;&lt; 4 &lt;&lt; endl;    return 0;&#125;\n\n此时重新编译，就能成功访问到指针p指向的对象了，并不受foo对象已经被delete的影响；\n$ ./test12351064\n\n\n10.字符串转换\n没看懂这两个函数是干嘛的，找到的代码连编译都过不去，跳过吧\n\n新增from_chars函数和to_chars函数\nhttps://zh.cppreference.com/w/cpp/utility/from_charshttps://blog.csdn.net/defaultbyzt/article/details/120151801\n\n11.std::variantC++17增加std::variant实现类似union的功能，但却比union更高级，举个例子union里面不能有string这种类型，但std::variant却可以，还可以支持更多复杂类型，如map等，看代码：\nint main() &#123; // c++17可编译    std::variant&lt;int, std::string&gt; var(&quot;hello&quot;);    cout &lt;&lt; var.index() &lt;&lt; endl;    var = 123;    cout &lt;&lt; var.index() &lt;&lt; endl;    try &#123;        var = &quot;world&quot;;        std::string str = std::get&lt;std::string&gt;(var); // 通过类型获取值        var = 3;        int i = std::get&lt;0&gt;(var); // 通过index获取对应值        cout &lt;&lt; str &lt;&lt; endl;        cout &lt;&lt; i &lt;&lt; endl;    &#125; catch(...) &#123;        // xxx;    &#125;    return 0;&#125;\n\n\n注意：一般情况下variant的第一个类型一般要有对应的构造函数，否则编译失败：\nstruct A &#123;    A(int i)&#123;&#125;  &#125;;int main() &#123;    std::variant&lt;A, int&gt; var; // 编译失败&#125;\n\n如何避免这种情况呢，可以使用std::monostate来打个桩，模拟一个空状态。\nstd::variant&lt;std::monostate, A&gt; var; // 可以编译成功\n\n12.std::optionalhttps://en.cppreference.com/w/cpp/utility/optional\n有的时候，我们想在异常的时候抛出一个异常的对象，亦或者是在出现一些不可预期的错误的时候，返回一个空值。要怎么区分空值和异常的对象呢？\n在python中，我们有一个专门的None对象可以来处理这件事。在MySQL中，我们也有NULL来标识空；但在CPP中，我们只剩下一个nullptr，其本质是个指针，与Py中的None和MySQL中的NULL完全不同！如果想用指针来区分空和异常对象，那就需要用到动态内存管理，亦或者是用智能指针来避免内存泄漏。\n说人话就是，在CPP中没有一个类似None的含义为空的对象，来告诉调用这个程序的人，到底是发生了错误，生成了一个错误的对象，还是说压根什么都没有弄出来。\n于是std::optional就出现了，其可以包含一个类型，并有std::nullopt来专门标识“空”这个含义。\n#include &lt;optional&gt;std::optional&lt;int&gt; StoI(const std::string &amp;s) &#123;    try &#123;        return std::stoi(s);    &#125; catch(...) &#123;        return std::nullopt;    &#125;&#125;void func() &#123;    std::string s&#123;&quot;123&quot;&#125;;    std::optional&lt;int&gt; o = StoI(s);    if (o) &#123;        cout &lt;&lt; *o &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;    &#125;&#125;\n\n这里我们进行了if的判断，首先判断变量o本身，为真代表的确返回了一个int值，为假代表返回的是nullopt；\n随后再使用*o来访问到内部托管的成员。\n需要注意这里是两层的逻辑关系，只有optional对象中成功托管了一个指定的参数类型，其本身才是真的。如果想访问它托管的对象，则需要用解引用。\n比如这里，我们的o对象托管的是一个bool类型的假，但假并不代表空，o对象本身的判断是真，内部对*o的判断才是判断托管的bool值到底是真是假。\n#include &lt;optional&gt;int main() &#123;    std::optional&lt;bool&gt; o = false;    cout &lt;&lt; typeid(o).name() &lt;&lt; endl;    if (o) // 这里判断的是optional对象是否有托管一个bool值    &#123;        if(*o)&#123; // 这里判断的是托管的bool值本身            cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;        &#125;        else&#123;            cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;        &#125;    &#125; else &#123; // 这里则代表托管的是nullopt        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n\n最终运行打印的结果是false；\n13.std::anyhttps://en.cppreference.com/w/cpp/utility/any\n这个类型可以托管任意类型的值，与之对应的还有一个std::any_cast来将其托管的值转成我们需要的类型。\n#include &lt;any&gt;int main() &#123; // c++17可编译    std::any a = 1;    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;int&gt;(a) &lt;&lt; endl;    a = 2.2f;    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;float&gt;(a) &lt;&lt; endl;    if (a.has_value()) &#123;        cout &lt;&lt; a.type().name();    &#125;    a.reset();    if (a.has_value()) &#123;        cout &lt;&lt; a.type().name();    &#125;    a = std::string(&quot;a&quot;);    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;std::string&gt;(a) &lt;&lt; endl;    return 0;&#125;\n\n输出结果如下\ni 1f 2.2fNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE a\n虽然any的出现让cpp也在一定程度上能实现“弱类型”变量，但在具体的开发中，明确变量的类型依旧比使用any好得多。特别是在变量的类型并不可以被直接转换的情况下。\n14.std::apply使用std::apply可以将tuple展开作为函数的参数传入，见代码：\n#include &lt;tuple&gt;int add(int first, int second) &#123; return first + second; &#125;auto add_lambda = [](auto first, auto second) &#123; return first + second; &#125;;int main() &#123;    std::cout &lt;&lt; std::apply(add, std::pair(1, 2)) &lt;&lt; &#x27;\\n&#x27;;    std::cout &lt;&lt; add(std::pair(1, 2)) &lt;&lt; &quot;\\n&quot;; // error    std::cout &lt;&lt; std::apply(add_lambda, std::tuple(2.0f, 3.0f)) &lt;&lt; &#x27;\\n&#x27;;&#125;\n\n\n15.std::make_from_tuple使用make_from_tuple可以将tuple展开作为构造函数参数\nstruct Foo &#123;    Foo(int first, float second, int third) &#123;        std::cout &lt;&lt; first &lt;&lt; &quot;, &quot; &lt;&lt; second &lt;&lt; &quot;, &quot; &lt;&lt; third &lt;&lt; &quot;\\n&quot;;    &#125;&#125;;int main() &#123;   auto tuple = std::make_tuple(42, 3.14f, 0);   std::make_from_tuple&lt;Foo&gt;(std::move(tuple));&#125;\n\n\n16.std::string_viewhttps://zhuanlan.zhihu.com/p/166359481\nhttps://en.cppreference.com/w/cpp/string/basic_string_view\n如果我们只需要一个string的只读类型的话，可以用string_view来托管。其内部只包含一个指向目标字符串的指针，以及字符串的长度。\nstring_view内部封装了string的所有只读接口，本来就是给你读的。\n需要注意的是，因为内部只有一个指针，所以当string_view托管的string被销毁了，与之关联的所有string_view都会失效！同样是因为内部只有一个指针和字符串的长度两个变量，所以在传值拷贝的时候，string_view的效率会高很多。\n\n这和const string&amp; 类型的传值又有什么区别呢？传引用不是也没有拷贝消耗吗？\n\n这个问题很好，我不知道！百度也没有百度出来……\n我能想到的就是用string_view作为参数的时候，如果入参是一个常量字符串，此时不需要构造string，而使用const string&amp; 接受常量字符串的时候依旧需要构造一个string对象。这部分就会有一定的消耗。\n17.as_constC++17使用as_const可以将左值转成const类型\nstd::string str = &quot;str&quot;;const std::string&amp; constStr = std::as_const(str);\n\n18.file_systemC++17正式将file_system纳入标准中，提供了关于文件的大多数功能，基本上应有尽有，这里简单举几个例子：\nnamespace fs = std::filesystem;fs::create_directory(dir_path); // 创建文件或者路径fs::copy_file(src, dst, fs::copy_options::skip_existing); // 文件cpfs::exists(filename); // 文件是否存在fs::current_path(err_code); // 获取当前路径\n\n19.shared_mutex这玩意是个读写锁。简单介绍一下什么是读写锁：\n\n读者可以有多个，写者只能有一个\n写锁是互斥的，如果A有锁，B想拿锁就得阻塞等待\n读锁是共享的，C有读锁，D也想读，两个人可以一起看\n读写锁是互斥的，有人写的时候不能读，有人读的时候不能写\n\n换到专业术语上，就是分为独占锁（写锁）和共享锁（读锁）；\n在C++14中其实已经有了一个shared_timed_mutex，C++17中这个锁的操作与其基本一致，只不过多了几个和时间相关的接口\ntry_lock_for(...);try_lock_shared_for(...);try_lock_shared_until(...);try_lock_until(...);\n\n具体使用可以参考 \nhttps://zh.cppreference.com/w/cpp/thread/shared_mutexhttps://zhuanlan.zhihu.com/p/610781321\n\nThe end关于C++17常用的基本就是这些了，后续遇到新的再更新本文。\n","categories":["遇见C++"],"tags":["C++","数据结构","C++17"]},{"title":"【C++】空对象指针也能访问成员函数？","url":"/posts/3858168549/","content":"1.起因今天写代码的时候遇到一个bug，一个类中的set函数在设置一个POD类型的时候出现了异常，直接段错误退出了。\n\n小tips，POD类型指的是内置类型。\n\n想了好久，都没发现这里的问题到底是因为什么。后来才知道，原来空的对象指针，也能被解引用访问到函数！\n2.示例下面是关于这个情况的示例代码\n#include &lt;iostream&gt;using namespace std;class mytest&#123;public:    mytest() = default;    mytest(int a):_a(0)&#123;&#125;    void set_int(int a)    &#123;        cout &lt;&lt; &quot;set int to &quot; &lt;&lt; a &lt;&lt; endl;        _a = a;    &#125;    void print(int a)    &#123;        cout &lt;&lt; &quot;just a print&quot; &lt;&lt; a &lt;&lt; endl;    &#125;private:    int _a = 0;&#125;;int main()&#123;    mytest* ptr = nullptr;    ptr-&gt;print(20);    ptr-&gt;set_int(10);    return 0;&#125;\n\n运行这个程序，会出现段错误。但你会发现这个段错误并不是因为我们的ptr-&gt; 里面出现的，而是成功进入了set_int函数，执行了打印，最终对成员变量_a赋值的时候出现的！\n对象指针为空，代表压根不存在一个实际的对象，也没办法对不存在的成员变量操作。\n&gt; ./testjust a print20set int to 10[1]    280362 segmentation fault  ./test\n\n当代码很多的时候，就会因为忽略这个特性（其实我当时是压根不知道）而误以为错误出现在set_int函数中。\n没有想到是外层的对象指针为空导致的。\n3.为什么？在编译过程中，对象就已经绑定了函数地址。一个类的所有对象，使用的函数地址都是一样的。当编译ptr-&gt;set_int(10) 的时候，函数的地址就已经和这个指针绑定了，调用它等价于直接调用 set_int 函数。\n如果这个函数中没有需要用到成员变量的地方，也就不需要解引用this指针，是不会出错的。比如上方代码中的print函数，就没有出现异常。\n但如果函数内访问了内置成员，那么就会出现解引用空指针导致的段错误！\n","categories":["遇见C++"],"tags":["C++","数据结构"]},{"title":"【C++】早绑定、析构与多态 | 一道关于多态的选择题记录","url":"/posts/2254346194/","content":"今天在和群友聊天的时候看到了一道很坑的题目，分享给大家\n\n\n1.看题！先来看看题目\nstruct Dad&#123;public:    Dad()&#123; echo();&#125;    ~Dad()&#123; echo();&#125;    virtual void echo() &#123;        cout &lt;&lt; &quot;DAD &quot;;    &#125;&#125;;struct Son:Dad&#123;public:    void echo() const override &#123;        cout &lt;&lt; &quot;SON &quot;;    &#125;&#125;;Son ss;\n\n请问这个的输出是什么？\nA  &quot;DAD DAD &quot;B  &quot;DAD SON &quot;C  &quot;SON DAD &quot;D  &quot;SON SON &quot;E  编译出错F  运行出错\n\n\n答案是E，编译出错！\n\n2.涉及到的知识点2.1 知识点先来说说这道题目里面涉及到了什么知识点\n\n多态调用；\n多态重写函数需要满足什么条件；\n类内函数后加const的作用；\n类内函数后加override的作用；\n什么是早绑定和晚绑定\n\n一个一个复习吧！\n\n多态调用是父类指针&#x2F;引用指向子类时，调用虚函数会调用子类重写后的版本\n多态重写函数的条件：函数名&#x2F;参数&#x2F;返回值都必须相同（注意还有协变）\n类内函数后加const修饰的是这个对象的this指针，被修饰的函数中无法修改类内成员变量\n类内函数后加override是让编译器来严格检查是否构成重载\n早绑定：静态绑定；晚绑定：动态绑定（具体请看CPP多态的博客）\n\n2.2 分析题目注意看父类和子类中这两个echo()函数的区别\nvirtual void echo()&#123;&#125;//父类void echo() const override &#123;&#125;//子类\n\n首先需要说明的是，子类函数中virtual关键字是可以省略的，但即便省略了，这个函数依旧是个虚函数。\n这里子类的函数中多了const修饰，而这个const修饰的就是函数中隐含的this指针，此时子类中echo()函数的参数就发生了变化！\nvirtual void echo(Son* this) &#123; &#125; // 不加constvirtual void echo(const Son* this) &#123; &#125; // 加const\n\n正是因为这里的this指针出现了const的修饰，所以子类的echo和父类echo的参数类型不同，不构成虚函数重写！再加上override关键字的严格检查，会直接编译报错！\n正确的写法是删除子类echo中的const或者给父类echo函数加上const\n3.再来看题好了，坑人的点看完了，再来看个「常规」的，就是把上面的题干改成能编译通过的。此时又应该选谁呢？\nstruct Dad&#123;public:    Dad()&#123; echo();&#125;    ~Dad()&#123; echo();&#125;    virtual void echo() const&#123;        cout &lt;&lt; &quot;DAD &quot;;    &#125;&#125;;struct Son:Dad&#123;public:    void echo() const override &#123;        cout &lt;&lt; &quot;SON &quot;;    &#125;&#125;;Son ss;\n\nA  &quot;DAD DAD &quot;B  &quot;DAD SON &quot;C  &quot;SON DAD &quot;D  &quot;SON SON &quot;\n\n\n编译运行，可以看到，结果是DAD DAD，应该选A\n3.1 分析在给 Son 类定义构造函数和析构函数时，没有指定调用父类的对应构造函数和析构函数。因此，在创建 Son 对象 ss 时，会默认调用 Dad 类的构造函数和析构函数。\n由于 Dad 类中的构造函数和析构函数调用了虚函数 echo()，而这个虚函数在子类 Son 中被重写，所以会根据对象类型调用相应的重写函数。然而，在构造函数和析构函数中，虚函数机制不会按照预期工作。\n构造函数中调用虚函数时，会忽略动态绑定机制，直接调用父类的函数版本。因此，在 Dad 的构造函数中调用 echo()，实际上调用的是 Dad 类中的 echo() 函数，而不是 Son 类中的重写版本。\n同样地，析构函数中也会忽略动态绑定机制，直接调用父类的函数版本。所以，在 Dad 的析构函数中调用 echo()，依然调用的是 Dad 类中的 echo() 函数。\n因此，当创建 Son 对象 ss 并打印输出时，会先调用 Dad 类的构造函数并打印 &quot;DAD &quot;，然后调用 Dad 类的析构函数并再次打印 &quot;DAD &quot;。\n3.2 结论在父类的构造和析构中，对象的版本都被确定为父类的版本，会采用早绑定来调用父类自己的函数，而不是子类的重写后的函数；\n简单记忆：父类的构造和析构中如果出现虚函数，只会调用父类自己的函数！\n\n这是因为编译器需要保证正确的构造和析构顺序，如果父类析构里调用子类的虚函数，可能会出现下面的场景\nstruct Dad&#123;public:    Dad()&#123; echo();&#125;    ~Dad()&#123; echo();&#125;    virtual void echo() const&#123;        cout &lt;&lt; &quot;DAD &quot;;    &#125;&#125;;struct Son:Dad&#123;public:    Son() &#123;        _a = new int(3);    &#125;    ~Son() &#123;        delete _a;    &#125;    void echo() const override &#123;        cout &lt;&lt; &quot;SON &quot;;        delete _a;    &#125;private:    int _a;&#125;;Son ss;\n\n如果父类中的析构echo()调用子类重写的函数，此时就会出现子类已经被销毁（子类的析构函数早于父类析构调用）的_a被二次delete，两次delete同一片空间是会报错的！\n所以为了避免这种情况，父类的析构中采用早绑定，子类重写的虚函数不会生效！\n这种行为是为了确保在对象的构造和析构过程中，按照正确的顺序调用各个类的构造和析构函数，避免在对象处于未完全初始化或已部分销毁状态时调用子类的函数。\n\n包括父类的构造也可以这么理解，如果父类构造里面可以调用子类的虚函数，可能会出现两次对一个子类对象进行new空间，会产生内存泄露；\n但构造函数还和虚函数表的初始化有关系，此时虚函数表还没有完全初始化，子类对象尚未构造完成，没有多态调用的条件，所以也不能调用到子类重写后的虚函数。\n\n","categories":["把题目都给刷干净"],"tags":["C++","OJ刷题"]},{"title":"【C++】将浮点数每一位拆分并输出","url":"/posts/398857040/","content":"将浮点数每一位拆分并输出\n\n\n1.问题\n来源 https://ask.csdn.net/questions/7901417\n\n题目要求如下，将浮点数拆分，不允许使用将浮点数整数倍扩大的办法（那样太简单了）\n\n2.办法2.1 库函数modfC语言有一个库函数modf，可以将浮点数的整数部分和小数部分拆分开来、\n\nhttps://www.runoob.com/cprogramming/c-function-modf.html\n\ndouble modf(double x, double *integer)\n\n其中参数x是原有浮点数，参数integer是输出型参数，会存放x的整数部分。\n函数的返回值是x的小数部分\n2.2 代码第一版本代码如下\n#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string.h&gt;#include &lt;string&gt;using namespace std;int main() &#123;    double num;    cin &gt;&gt; num;    double int_part;    double frac_part = modf(num, &amp;int_part);    string int_str = to_string((int)int_part);//获取到整数部分并打印    for (char c : int_str) &#123;        cout &lt;&lt; c &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; &quot;. &quot;;    int i = 0;    int n = 2;//小数点后n位    while (i &lt; n) &#123;        frac_part *= 10;        double int_part;        frac_part = modf(frac_part, &amp;int_part);        cout &lt;&lt; (int)int_part &lt;&lt; &quot; &quot;;        i++;    &#125;    cout&lt;&lt;endl;    return 0;&#125;\n这样已经做到了将整数和小数部分给分离打印了\n2.3 精度缺失问题但是，测试可以看到，小数的最后一位出现了可能会存在的精度缺失\n\n3.解决所以还需要用另外一个办法来处理\n#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string.h&gt;#include &lt;string&gt;using namespace std;//https://ask.csdn.net/questions/7901417int main() &#123;    double num;    cin &gt;&gt; num;    double int_part;    double frac_part = modf(num, &amp;int_part);    cout &lt;&lt; &quot;int_part: &quot;&lt;&lt; int_part &lt;&lt;&quot; | frac_part: &quot; &lt;&lt;frac_part &lt;&lt; endl;    char str[10];    sprintf(str, &quot;%.3f&quot;, frac_part); //将小数部分打印到字符串中    cout &lt;&lt; &quot;str:  &quot; &lt;&lt; str &lt;&lt; endl;    // 打印整数部分    string int_str = to_string((int)int_part);    for (char c : int_str) &#123;        cout &lt;&lt; c &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; &quot;. &quot;;    // 打印小数部分    int n = 2;//小数点后n位    for(int i=0;i&lt;n;i++)     &#123;        // 因为打印到字符串中的数据包含了最开始的0.        // 前两个字符就是0. 应该从第三个字符开始打印        cout &lt;&lt; str[2+i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;\n可以看到，问题已解决，符合题目要求！\n\n","categories":["把题目都给刷干净"],"tags":["C++","OJ刷题"]},{"title":"【C++】auto关键字、范围for、nullptr关键字","url":"/posts/1752517657/","content":"本篇博客一起来继续学习C++的语法\n\n\n\n\n\nauto关键字\nnullptr关键字\n\n\n\n范围for\nlinux如何使用C++11规则\n\n\n[TOC]\n0.linux设置c++11在linux平台下想使用C++11标准有两个办法\n方法1是在.cpp文件的最开头加入下面的这个语句\n#pragma GCC diagnostic error &quot;-std=c++11&quot;\n\n但是这个方法哈，我发现加了它之后使用nullptr还是会报错，但是auto和typeid都可以使用了\n方法2是在编译的时候在加上-std=c++11\ng++ -std=c++11 test.cpp -o test \n\n使用这个方法比较完美\n1.auto关键字\n\n在C++11中，auto作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得\n\n简而言之，这个关键字的作用就是自动给变量设置一个数据类型\n1.1基本使用#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int TestAuto()&#123;     return 10;&#125;int main()&#123;    int a = 10;    auto b = a;    auto c = &#x27;a&#x27;;    auto d = TestAuto();    auto e = &quot;abc&quot;;    char str[20]=&quot;hello auto!&quot;;    auto f =str;        cout &lt;&lt; typeid(b).name() &lt;&lt; endl;    cout &lt;&lt; typeid(c).name() &lt;&lt; endl;    cout &lt;&lt; typeid(d).name() &lt;&lt; endl;    cout &lt;&lt; typeid(e).name() &lt;&lt; endl;//PKC    cout &lt;&lt; typeid(f).name() &lt;&lt; endl;//Pc    //VS下会打印完整的类型，返回的是字符串    //linux下只会打印缩写，其中PKc代表pointer(p) to Const(k) Char(c)    //而如果是字符串，打印的就是Pc，pointer to Char    return 0;&#125;\n\n在上面的代码中，我们使用了typeid().name()来打印变量的类型，使用这个函数需要引用头文件&lt;typeinfo&gt;\n\n可以看到，编译器正确打印出了每一个变量的数据类型，auto自动判断并给这些变量赋予了数据类型\n\nVS下typeid()函数会打印完整数据类型\nLinux下只会打印缩写\n其中PKc代表pointer(p) to Const(k) Char(c)，也就是const char*\nPK代表const修饰的指针；P代表指针，如Pc是char*、Pi是int*\n\nauto e; //无法通过编译，使用auto定义变量时必须对其进行初始化\n\n使用auto关键字的时候，必须要在定义的时候初始化变量。\n其实这很好理解，本来auto就是一个自动根据初始化内容来赋予数据类型的关键字，如果你不给我初始化内容，我哪知道你需要赋值的类型是谁呢？\n\n因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。\n\n1.2使用细节①和指针&#x2F;引用同时使用如图，auto在处理指针变量的时候，带不带*是不受影响的\n\nPi是pointer to int，即int的指针\n\n\n②在同一行定义多个变量如果使用auto在同一行定义多个变量的时候，前后定义的变量必须是同一个类型的\nauto a=1,b=3;//可以auto a=1,b=2.4;//不可以\n\n1.3auto不能用的地方①auto不能作为数组的声明比如下面的这种情况，是不行的\nauto arr[]=&#123;1,2,3,4&#125;;\n\n\n②auto不能用来作为函数的参数和返回值void test(auto a);auto test(int a);\n\n函数的返回值和传参都不能是auto\n因为这样会给使用者带来极大的误导，我连你的返回值是什么类型都不知道，我用啥来接收？？再用一次auto吗？？😂\n\n\n为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法\n\n其实auto最大的作用还是在C++11提供的新式循环中使用👇\n2.范围for循环2.1 基本用法在之前，如果我们想遍历一个数组，一般会使用下面的方式\n这是最经典的for循环语句，想必你肯定不陌生\n\n但这方法太麻烦了！每次都要弄一个sizeof来计算长度，这不纯纯坐牢吗\n\n于是哈，C++11就利用auto关键字提供了另外一个遍历数组的方法\nfor(auto e : arr)       cout &lt;&lt; e &lt;&lt; &quot; &quot;; \n\n没错！就是这么简单的参数设置，就能让auto自己打印出数组内的值！\n这也太省事了👍\n\n这里注意哈，如果在for里面设置的e没有带&amp;引用，其对数据内容的更改是不会改变源数组的。你可以理解为这里是临时传了参数给了e，然后再打印e的值\n\n如果想修改数组的内容，给e带上引用即可\n\n编译器会自动判断什么时候数组打印完毕，所以你想打印一个字符数组也是没问题的\n\n我是用的这个vim配置好像更加智能，因为他把数组中空着的部分也“打印出来了”。实际上编译器并不会打印空出来的值\n\n这点可以在for循环结束后再打印EOF来验证\n\n与普通循环类似，可以用continue来结束范围for循环，也可以用break来跳出整个循环。\n另外，直接使用变量类型来操作范围for也是可以的\n\n2.2 使用条件使用范围for的时候，必须给定一个准确的范围\n\n在遍历数组的时候，这个范围就是数组的开头和结尾\n对于类而言，应该提供begin和end的 方法，begin和end就是for循环迭代的范围\n\n也就是说，我们必须给定一个数组名，而不能给定一个指针\nvoid TestFor4(int*ptr)&#123;\tfor(auto e : ptr)\t\tcout&lt;&lt;e&lt;&lt;&quot; &quot;;&#125;\n\n比如这种使用方法就是错误的，因为编译器不知道这个数组到底什么时候结束\n\n即便把传参改成数组的形式也是不行的\n\n至于为什么范围for里面用的是冒号嘛，好问题，我不知道\n\n2.3 范围for会拷贝数据同时在测试的时候，我还发现原来STL库容器里面的迭代器遍历的时候，是会把自定义类型拷贝构造一份的\n\n实际上，auto在进行范围for的时候，是会拷贝一份数据给e的。\n用引用避免拷贝的代价想让他不进行这种拷贝，就需要给auto&amp;加上引用才可以\n\n下一个知识点！\n\n3.nullptr关键字nullptr是C++11引入的新关键字\n3.1NULL在C语言中，NULL代表空指针\nint*p1=NULL;\n\nNULL实际是一个宏，在c语言头文件stddef.h中，可以看到如下代码：\n#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endif\n\n可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量\n3.2问题引出那么问题就来了，如果我在调用函数的时候传了NULL，编译器究竟会把它识别成int类型，还是识别成指针类型呢？\n\n比如在上面的函数重载代码中，编译器就不知道要调用哪一个函数了，除非你给NULL来一个(int*)强制转换一下\n编译文件会看到如下报错\ntest.cpp|17 col 5 error| call to &#x27;f&#x27; is ambiguous\n\n小码农英语课堂开课啦！今天学习的是ambiguous\n\n\n所以说！C++急需另外一个东西的加入来避免NULL的这种模糊传参情况\n3.3使用nullptr其他需要介绍的就无啦，你只要知道，nullptr不再是一个代表0的值，而是一个专门的关键字，代指空指针的情况，就OK啦！\n\n\n最后是几点注意：\n\n在使用nullptr表示指针空值时，不需要包含头文件，因为它是C++11的关键字 \n在C++11中，sizeof(nullptr)=sizeof((void*)0)\n为了提高代码的稳定性，后续写C++代码的时候一律用nullptr，不再使用NULL\n\n\n结语好啦，本篇C++的笔记到这里就结束喽\n有什么问题大家可以在评论提出哈\n","categories":["遇见C++"],"tags":["Linux","C++"]},{"title":"【C++】类和对象1：初识类+this指针","url":"/posts/2582381960/","content":"不知你在学习C语言和C++的适合，曾否听过老师这么讲述这两个语言之间的区别：\n\nC语言是面向过程的\nC++是面向对象的\n\n\n\n我一直不太理解这二者之间的区别，在查阅了一些博客后，发现了一个比较好的解释👉【传送门】\n\n用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。所谓盖浇饭，北京叫盖饭，东北叫烩饭，广东叫碟头饭，就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜，你就浇上什么菜。\n\n本篇博客，就让我们从类和对象开始，渐渐了解什么是“面向对象编程”\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n\n[TOC]\n1.类的引入1.1结构体在C语言中，我们可以定义自定义类型：结构体。在C++中对结构体的语法进行了扩充，结构体内部不仅能定义变量，还能定义函数\nstruct Student&#123;\tvoid Print()    &#123;\t\tcout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;\t&#125;\tchar _name[20];    char _sex[8];    int _age;    char _phone[20];&#125;;\n\n1.2class为了和C语言里面的结构体作为区分，我们不再用struct来指代这种包含函数的自定义类型，而是使用class作为它的名字，称之为类\nclass className&#123; //类体：由成员函数和成员变量组成&#125;; //一定要注意后面的分号\n\nclass为定义类的关键字，ClassName为类的名字，&#123; &#125;中为类的主体，注意类定义结束时后面分号（这一点和结构体相同）\n类中的元素称为类的成员：\n\n类中的数据称为类的属性或者成员变量\n类中的函数称为类的方法或者成员函数\n\n2.类成员的定义类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 ::作用域解析符指明成员属于哪个类域。\n2.1函数声明和定义分离和普通的函数一样，类同样支持声明和定义分离。下面的代码中，我并没有分离函数的声明和定义\n\n成员函数在类里面定义，编译器会默认处理为内联函数\n\nclass Student&#123;\tvoid Print()    &#123;\t\tcout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;\t&#125;\tchar _name[20];    char _sex[8];    int _age;    char _phone[20];&#125;;\n\n如果需要在.h中写入类的定义，类外面的.cpp中编写类里面的函数，就需要用到类似于命名空间的使用方法::\nclass Student&#123;\tvoid Print();//声明函数\t\tchar _name[20];    char _sex[8];    int _age;    char _phone[20];&#125;;\n\n在另外的源文件中定义函数\n#include &quot;Student.h&quot;void Student::Print()&#123;\tcout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;&#125;\n\n当我们编写大型项目的时候，一般都会采用声明和定义分离的方式来编写源码，这样可以更方便他人快速查阅我们的头文件，理解代码的“大纲”\n\n这样看起来好像和以前的方式没啥区别。但当我们引入访问权限的概念后，一切都变啦！\n2.2访问限定符class的默认访问权限是私有；struct默认为公有\n\n你不知道什么是访问权限？那就继续往下看👇\n\n我们可以用public和private这两个访问限定符来表明某一个具体类型的共有还是私有。它们的最大区别就是在这个类的外部能不能访问\n\n\npublic成员可以在类外面直接使用\nprotected和private修饰的成员只能在类里面访问\n访问权限的作用域是从该访问限定符出现，到下一个访问限定符出现为止\n访问限定符是在编译过程中处理的，并不影响数据在内存上的存放\n\n在前期学习的时候，我们可以认为protected和private是相同作用的\nclass Student&#123;public:    //函数在类里面定义，编译器默认为内联函数    void Print()    &#123;        cout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;    &#125;    void Init(const char * name,const char*sex, int age,const char* phone)    &#123;        strcpy(_name,name);        strcpy(_sex,sex);        _age=age;        strcpy(_phone,phone);    &#125;    //函数在类里面声明    void Delet();private:    //这个是对变量的声明    //变量的声明：没有开辟空间    //变量的定义：开辟了空间来存放内容    char _name[20];    char _sex[8];    int _age;    char _phone[20];    //在创建对象的时候定义&#125;;\n\n\n数据和方法分装到一个类里面\n想给你自用访问的（如函数接口）设置为共有\n不想给你访问的（如通讯录每个用户的信息类型）设置为私有\n\n这样可以做到，当函数定义修改之后，只要不修改函数声明，就不需要修改main函数中函数的调用！这叫做：高内聚，低耦合\n2.3封装为什么会有权限的出现呢？我们可以细想一下下面这个场景：\n\n假设我们编写了一个数组栈的代码，里面有一个top用来标明栈顶的元素位置。一般可以把top定义为0或者1，但是这两种方法的函数使用是不同的！如果有那个铁憨憨跑过来，非要把那个top的定义给改掉，那整个代码就废掉不能用辣！\n设立私有和公有的初衷，就是为了避免这种情况。开放一些共有函数供类外面访问，这样对整个代码的访问会变得易于管理。当我们自己修改类里面的代码时，只需要做好处理，就不会影响类外面的函数调用（否则就是直接推翻重写了）\n\n这便是我们常常提到的封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。\n3.类的实例化用类类型创建对象的过程，称为类的实例化\n\n类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它\n一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量\n\n类就好比一个毛坯房，现在毛坯房建好了，要想它变得精致，我们还需要在main中调用这个类，不然毛坯房就要变成烂尾楼了\nStudent p1;p1.Init(&quot;牛爷爷&quot;,&quot;男&quot;,58,&quot;13251341680&quot;);p1.Print(); \n\n4.计算类的大小一般有4种类：包含函数和变量的、只包含函数的、只包含成员变量的、空类\n\n让我们来康康如何计算这些类的大小，解析见注释哦！\n其实只需要记住，空类和只有函数的类会有1个字节的空间。计算类的空间的时候不会计算函数大小，成员变量的大小计算遵循结构体内存对齐的计算方法就行了！\n#include&lt;iostream&gt;using namespace std;class A1&#123;public:    void func1()    &#123;        int ret=3;        return ;    &#125;&#125;;class A2&#123;&#125;;class A3&#123;public:    char _a;&#125;;\n\n\n#include &lt;iostream&gt;using namespace std; class A&#123;&#125;; int main(void)&#123;    cout &lt;&lt; sizeof(A) &lt;&lt; endl;//空类是1    return 0;&#125;\n\n\n\n5.this指针5.1特点当你用同样的图纸建了很多个屋子后，有没有想过应该如何区分它们呢？\nC++在设计这部分的时候，添加了一个this指针来解决这个问题：\n\nC++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参 数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。\n\n\nthis指针的类型：类名* const \n只能在“成员函数”的内部使用 \nthis指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。 \nthis指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递\n\n5.2显式使用this就用下面这个函数举例\nvoid Print()&#123;\tcout&lt;&lt;_name&lt;&lt;endl;\tcout&lt;&lt;_sex &lt;&lt;endl;&#125;\n\n实际上，在调用它的时候，编译器会做如下处理\nvoid Print(Student*const this)&#123;\tcout&lt;&lt;this-&gt;_name&lt;&lt;endl;\tcout&lt;&lt;this-&gt;_sex &lt;&lt;endl;&#125;\n\n因为只有这样，才能完整的区分两个不同的类\n\n进一步看看下面这个代码，可以帮助你理解this指针\nbool operator==(const Date&amp; d)&#123;       return _year == d._year           &amp;&amp; _month== d._month           &amp;&amp; _day == d._day;&#125;\n\n这是一个日期的比较函数，是操作符重载（后面会讲到）\n你可以看到，这个函数我们传入了一个Date类型的引用，这是区别于this的另外一个类的对象\n如果没有this，那就很难区分两个变量的_year，于是编译器会把它优化成下面这样，就不会存在无法区分的问题了\nbool operator==(Date*const this,const Date&amp; d)&#123;       return this-&gt;_year == d._year           &amp;&amp; this-&gt;_month== d._month           &amp;&amp; this-&gt;_day == d._day;&#125;\n\n5.3空指针问题int main()&#123;    int x=10;    //在程序中，访问NULL不会报错，但是解引用Null会报错    int*a=NULL;    int*b=&amp;x;    //a=x;//err    *b=20;    return 0;&#125;\n\n#include&lt;iostream&gt;using namespace std;class ta&#123;public:    void Print()    &#123;        cout&lt;&lt;&quot;print ta&quot;&lt;&lt;endl;        //cout&lt;&lt;_a&lt;&lt;endl;    &#125;private:    int _a;&#125;;int main()&#123;    ta* p=nullptr;    p-&gt;Print();   //可以去访问空指针的函数   //因为函数只是去调用了类里面的Print函数   //同时传了一个p的this指针（空指针传参是不会报错的）   //但是如果你去访问p里面_a变量，就会报运行错误    return 0;&#125;\n\n6.类中成员函数的处理除了this指针之外，编译器在链接函数名的时候，也做了相应的处理。在Linux里面查看下面这串代码的汇编代码\n#include&lt;iostream&gt;class Test&#123;public:    void func1(const int* a1,int* k,const int*a2,char arr)    &#123;        *a1+*a2;        func2(a1,k,a2,arr);    &#125;    private:    void func2(const int* a1,int* k,const int*a2,char arr)    &#123;        *a1+*a2;    &#125;&#125;;int main()&#123;    Test t;    int arr1[10];    int arr2[20];    int a=10;    t.func1(arr1,&amp;a,arr2,&#x27;a&#x27;);        return 0;&#125;\n\n可以找到这两个类的成员函数的地址和函数名\n\n方法参考我的这篇博客👉【末影门】\n\n00000000004006da &lt;_ZN4Test5func1EPKiPiS1_c&gt;:000000000040071a &lt;_ZN4Test5func2EPKiPiS1_c&gt;:\n\n可以发现，这两个函数的地址不同，但函数名中并没有包含它的公有、私有信息。这也能证明2.2中写道的“访问限定符是在编译过程中处理的，并不影响数据在内存上的存放”\n\n下面是一个普通函数（不在类里面）的函数名\n\n观察类里面的函数名，可以看到比起普通函数，它还包含了类名，来标明自己是被封装在某个类里面的。同时前缀也从_Z变为了_ZH\n\n\n这里S1_的含义是我多次传相同类型参数，查看汇编代码测试出来的\n\n当我把相同传参的函数放在类外面，重新查看汇编代码\n\n000000000040064d &lt;_Z5func3PKiPiS0_c&gt;:\n\n可以看到它发生了一些变化，比如前缀变为了_Z，函数名后面的E不见了，S1_变成了S0_\n虽然我现在还不知道前缀_Z和_ZH、函数名后面那个E分别代表什么含义，但是我们可以看的出，这是编译器在编译链接过程中为了区分类中函数和类外函数做的优化\n\n结语本篇博客是类和对象的第一篇笔记，不知能否帮到你呢\n\n","categories":["遇见C++"],"tags":["Linux","C++","类和对象"]},{"title":"【C++】类和对象2：默认成员函数+操作符重载","url":"/posts/2894176175/","content":"本篇是类和对象的第二站🚌\n主要讲述类的几个默认成员函数，以及操作符重载\n本篇博客会涉及到很多之前C++专栏里面提到的知识点，建议连起来观看。\n\n\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n\n[TOC]\n默认成员函数当我们创建一个类的时候，即便类里面啥都不放，都会自动生成下面6个默认成员函数\n\n它们都有啥功能呢？且听我一一道来\n1.构造函数众所周周知，当我们写C语言的顺序表、链表等代码的时候，一般都会写一个Init函数来初始化内容。\nvoid Init()&#123;\ta=(int*)malloc(sizeof(int)*4);\tsize=0;\tcapa=4;&#125;\n\n但是这样有一个缺点，就是不够智能，需要我们自己来调用它进行初始化。\n于是C++就整出来了一个构造函数来解决这个问题\n1.1特性构造函数：名字和类名相同，创建类对象的时候编译器会自动调用，初始化类中成员变量，使其有一个合适的初始值。构造函数在对象的生命周期中只调用一次\n构造函数有下面几个特性：\n\n函数名和类名相同\n无返回值\n构造函数可以重载\n对象实例化的时候，编译器会自动调用对应的构造函数\n如果你自己不写构造函数，编译器会自己创建一个默认的构造函数\n\n1.2基本使用下面用一个队列来演示一下构造函数\nclass Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;//测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n可以看到，在创建对象q1的时候，编译器就自动调用了类中的构造函数，帮我们初始化了这个队列\n\n\n除了上面这种最基本的无参构造函数以外，一般写构造函数的时候，我们都会带一个有缺省值的参数，这样可以更好地灵活使用这个队列\nQueue(int Capacity=4)&#123;    _a=(int*)malloc(sizeof(int)*Capacity);    _size=0;    _capa=Capacity;&#125;\n\n调用这种构造函数也更加灵活，我们可以根据数据类型的长度，来创建不同容量的队列，避免多次realloc造成的内存碎片\nQueue q1;//调用无参的构造函数Queue q2(100);//调用带参的构造函数\n\n多种构造函数是可以同时存在的，不过！它们需要满足函数重载的基本要求\n当你调用一个无参的函数，和一个全缺省的函数的时候，编译器会懵逼！\nQueue();Queue(int Capacity=4);//这两个函数不构成重载，会报错\n\n正确的重载应该是下面的情况\nQueue();Queue(int Capacity);\n\n编译器在创建对象的时候，就会智能选择这两个构造函数其中之一进行调用。但是同一个对象只会调用一个构造函数\n1.3编译器默认生成的构造函数上面提到过，如果我们不写构造函数，编译器会自己生成一个。\n但测试过以后，你会发现，这个默认生成的构造函数，好像啥事都没有干——或者说，它把_a _b _c 都初始化成了随机值！\n\n实际上，编译器默认生成的构造函数是不会处理内置类型的\n\n内置类型：int、char、float、double……\n外置类型：自定义类型（其他的类）\n\n在处理的时候，编译器忽略内置类型；外置类型会调用它的构造函数\nclass Date&#123;public:    //默认构造函数：不传参就能调用的    //1.全缺省 2.无参 3.编译器自动生成    //可以是半缺省的，但是不实用    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;        _A.Print();    &#125;private:    //编译器会自动生成构造函数（如果你没有自己写的话）    //自动生成的构造函数是不会初始化内置类型的    //内置类型：int,char,double等等    int _year;    int _month;    int _day;    //外置类型：自定义类型    //外置类型会调用它自己的默认构造函数    Queue _A;&#125;;\n\n可以看到，编译器调用了自己的构造函数的同时，还调用了外置类型Queue的构造函数，搞定了它的初始化\n\n如果我们去掉Date的构造函数，就能看到下面的情况。Queue成功初始化，但是内置类型的年月日都是随机值\n\n一般情况下一个C++类都需要自己写构造函数，下面这两个情况除外\n\n类里面的成员都是自定义类型成员（且有自己的构造函数）\n如果还有内置类型成员，声明时给了缺省值\n\n注：只有类在声明变量的时候才可以给缺省值\n//下面的情况就不需要写class MyS&#123;    private:      Queue q1;//自定义类型      Queue q2;      int a=1;//内置类型声明的时候给了缺省值&#125;;\n\n\n\n1.4初始化列表除了上面的方式之外，还有一种构造函数的使用方式为初始化列表\nDate(int year=2022,int month=2,int day=30)    :_year(year),\t_month(month),\t_day(day)&#123;&#125;\n\n\n每个成员变量只能在初始化列表中出现一次\n类中包含以下成员必须在初始化列表中进行初始化\n引用\nconst成员\n自定义类型成员\n\n\n\n一般情况下，建议使用初始化列表进行初始化。因为对于自定义类型的成员变量，初始化列表的优先级是高于&#123; &#125;里面的内容的。\n这里还有非常重要的一点！\n成员变量在类中声明的顺序就是初始化列表的顺序，而并非初始化列表自己的顺序！\n\n怎么理解呢？看下面这个代码\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(month)\t&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n即便我们把_day放在了初始化列表的首位，但由于它是在最后声明的。所以构造函数走初始化列表的时候，会依据声明顺序，依次初始化年、月、日。\n\n这会引起什么问题？再来看看一个错误示例\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(_day)&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n当我们用上面这个初始化列表的时候，我们本意是想在初始化完_day以后，将_day的值赋给_month。但由于_month的声明顺序在_day之前，所以_month(_day)会先执行，此时的_day尚为随机值，这就导致月份变成随机值了！\n\n这只是一个示例，实际上肯定不会用天数初始化月数，范围不一样\n\n最好的办法，就是声明顺序和初始化列表的顺序保持一致！\n\n1.5 explicit关键字构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有隐式类型转换的作用。\nclass Date&#123;public:    //正常的构造函数    //Date(int year)    //    :_year(year)    //    &#123;&#125;\t    explicit Date(int year)        :_year(year)        &#123;&#125;private:    int _year;    int _month:    int _day;&#125;；void TestDate()&#123;    Date d1(2018);    // 用一个整形变量给日期类型对象赋值    // 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值    d1 = 2019;&#125;\n\n当我们调用赋值的时候，实际上编译器会先用2019构造出一个date类型对象，再调用赋值重载（这里还没有写）赋值给d1。这就是一个隐式类型转换\n如果我们用explicit修饰了这个构造函数，那么编译器将不会进行此类隐式类型转换！\n1.6规范命名类的成员变量为了更好的使用构造函数，以及区分类内外的函数类型\n一般我们定义类中的成员变量的时候，都会使用一个下划线进行标明_YEAR\n在一些地方，你会看到函数名前面也带了一个_，这一般表明该函数是另外一个函数的子函数，同样是用于区分的。\n\n不同人的代码风格不同，你可以选择你自己喜欢的风格，但不能影响我们程序的正常使用\n\n比如下面这种情况，就会影响类的构造了\nclass Date&#123;public:    Date(int year=2022)    &#123;        year=year;    &#125;private:    int year;&#125;;\n\n请问year=year里面的这个year，到底是成员变量，还是构造函数的传参呢？编译器又双懵逼了\n实际上，编译器在找year的时候，会先在当前&#123; &#125;中找，找到了传参的year，就不会去找其他地方的year了。所以这个语句实际上是传参过来的year自己给自己赋值，编译器会报错。\n1.7 初始化列表&#x2F;函数体&#x2F;缺省值在VS2019里面测试了一下运行顺序\n\n缺省值&#x2F;初始化列表（缺省值会被处理成初始化列表）\n函数体内\n\n在下面的测试用例中，我用注释标出了初始化的顺序\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class inclass &#123;public:\tinclass(int a = -10,const string&amp; info = &quot;dft&quot;) :_a(a) &#123;\t\tcout &lt;&lt; &quot;init class | &quot; &lt;&lt; info &lt;&lt; endl;\t&#125;\tinclass(const inclass&amp; d) &#123;\t\t_a = d._a;\t\tcout &lt;&lt; &quot;init class copy&quot; &lt;&lt; endl;\t&#125;\tint _a;&#125;;class myclass &#123;public:\tmyclass(int c)\t\t:_c(c),// 3    // 6 这里给变量_f调用了默认构造函数\t\t_g(5,&quot;_g&quot;)// 7\t&#123;\t\t\t_d = 2; // 8\t\t_f = inclass(6,&quot;_f&quot;);// 9 _f实际上构造了两次\t\tcout &lt;&lt; &quot;init myclass&quot; &lt;&lt; endl;\t&#125;private:\tint _a = -1;// 1\tconst int _b = -3;// 2\tint _c;\tint _d;    int _dd = -5;// 4 \tinclass _e = inclass(4,&quot;_e&quot;); // 5 初始化列表中直接构造\tinclass _f; \tinclass _g;&#125;;int main()&#123;\tmyclass b(50);\treturn 0;&#125;\n\n运行输出如下，其中第二行的dft是编译器在初始化列表阶段给变量_f调用的默认构造函数（因为inclass的构造函数写了全缺省）\ninit class | _einit class | dftinit class | _ginit class | _finit myclass\n\n而且这里我们能看出，即便采用 inclass _e = inclass(4,&quot;_e&quot;); 这种形式给自定义类型赋值，最终编译器也会优化成在初始化列表阶段直接调用构造函数；\n2.析构函数和构造函数相对应，析构函数是对象在出了生命周期后自动调用的函数，用来爆破对象里的成员（如进行free操作）\n生命周期是离这个对象最近的&#123; &#125;括号\n2.1特性\n析构函数名是在类名前加~\n无参数，无返回值\n一个类只能有一个析构函数\n如果你没有自己写，编译器会自动生成一个析构函数\n\n和构造函数一样，编译器自己生成的析构函数不会处理内置类型；会调用外置类型的析构函数\n2.2基本使用析构函数的定义和我们在外部写的Destroy函数一样，主要执行free操作\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue&quot;&lt;&lt;endl;//测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;    ~Queue()    &#123;        //析构函数        free(_a);        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;//测试调用    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n假设我们在main函数里面定义了两个对象，你能说出q1和q2谁先进行析构函数的调用吗？\n\n可以看到，先调用的是q2的析构函数\n\n因为在底层操作中，编译器会给main函数开辟栈帧\n栈遵从后进先出的原则，q2是后创建的，所以在析构的时候会先析构\n\n3.拷贝构造3.1特性和使用拷贝构造是一个特殊的构造函数，它的参数是另外一个Date类型。在用已有的类类型对象来创建新对象的时候，由编译器自动调用\n因为拷贝的时候我们不会修改d的内容，所以传的是const\n另外，我们必须进行传引用调用！\n\n这里补充说明一下，下面的这个函数，在传参的时候，编译器会去调用Date的拷贝构造\nvoid func(Date d);\n\n如果你没有写拷贝构造，或者拷贝构造里面不是传引用，编译器会就递归不断创建新的对象进行值拷贝构造，程序就死循环辣\n//拷贝构造，如果不写的时候，编译器会默认生成一个    //对内置类型进行值拷贝(浅拷贝)    Date(const Date&amp; d)    &#123;        _year=d._year;        _month=d._month;        _day=d._day;        //外置类型会调用外置类型的拷贝构造        Queue b(_A);    &#125;\n\n和构造、析构不同的是，编译器自己生成的拷贝构造终于有点用了\n\n它会对内置类型进行按内存存储的字节序完成拷贝，这种称为值拷贝（又称浅拷贝）\n对外置类型会调用它的构造函数\n\n\n3.2外置类型拷贝问题但是！如果你使用了外置类型，该类型中包含malloc的时候，编译器默认生成的构造函数就不能用辣！\n因为这时候，编译器默认生成的拷贝构造会进行值拷贝，拷贝完了之后，就会出现q1和q2指向同一个空间的情况。修改q2会影响q1，free的时候多次释放同一个空间会报错，不符合我们的拷贝构造的要求\n\n注意注意，malloc不行的原因是，数据是存在堆区里面，拷贝的时候，q2的_a得到的是一个地址，而不是拷贝了新的数据内容。\n\n如果你在类里面定义了一个int arr[10]数组，这时候拷贝构造就相当于memcpy，是可以完成拷贝的工作的。\n\n如何解决这个问题呢？我们需要使用深拷贝\n这里我还没有学到那个地方，后续写深浅拷贝的博客的时候，再来填上这个坑\n\n黑马16分钟视频速成完毕，前来填坑\n\n3.3深拷贝3.3.1new和delete这里先给大家从C语言转到C++，讲解一下new和delete关键字，它们分别对应malloc和free\n非常简单！比malloc的使用简单多了！\nint main()&#123;    int*p1=new int;//开辟一个int类型的空间    int*p2=new int(10);//开辟一个int类型的空间，并初始化为10    int*p3=new int[10];//开辟10个int类型的空间    //注意后两个的括号区别！        delete p1;//销毁p1指向的单个空间    delete p2;//同上        //delete p3;//销毁p3指向的第一个空间，不能用于数组    delete[] p3;//销毁p3指向的数组        return 0;&#125;\n\n怎么样？是不是超级简单！\n\n\n3.3.2深拷贝实现在上面写道过，编译器会自动生成拷贝构造函数，完成值拷贝工作。但是队列的代码里面包含堆区的空间，需要我们正确释放。这时候就需要自己写一个拷贝构造完成深拷贝👇\n//拷贝构造Queue(const Queue&amp; q)&#123;    _a=new int[q._capa];//注意解引用    memcpy(_a, q._a, q._capa*sizeof(int));//拷贝内容    _size=q._size;    _capa=q._capa;&#125;\n\n用下面这个队列的代码来测试深拷贝\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;//测试是否调用        //_a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;        _a=new int[_capa];    &#125;    //拷贝构造    Queue(const Queue&amp; q)    &#123;        cout&lt;&lt;&quot;Queue Copy&quot;&lt;&lt;endl;        _a=new int[q._capa];        memcpy(_a, q._a, q._capa*sizeof(int));        _size=q._size;        _capa=q._capa;    &#125;    void Set()    &#123;        for (int i = 0; i &lt; _capa; i++)        &#123;            _a[i] = i + 1;        &#125;    &#125;    void Print()    &#123;        cout&lt;&lt;&quot;this:&quot;&lt;&lt;this&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;_a:&quot;&lt;&lt;_a&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;        for(int i=0;i &lt; _capa;i++)        &#123;            cout&lt;&lt;_a[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    ~Queue()    &#123;        //析构函数        //free(_a);        delete[] _a;        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;int main()&#123;     Queue q1;    q1.Set();    q1.Print();    cout&lt;&lt;endl;    Queue q2=q1;     q2.Print();    cout&lt;&lt;endl;    return 0;&#125;\n\n3.3.3深拷贝效果先注释掉Queue的拷贝构造函数析构函数（不然会报错）\n看一看，发现在不写拷贝构造函数的时候，q2和q1的_a指向了同一个地址\n\n取消析构函数的注释，可以看到两次释放同一片空间，发生了报错\n\n如果我们把写好的深拷贝构造加上，就不会出现这个问题\n\n当你加上给_a里面初始化一些数据，以及打印_a数据的函数后，就可以看到，不仅q2的_a有了自己全新的地址，其内部的值也和q1一样了\n\n这样写出来的拷贝构造，即便把队列中的int* _a修改为char*或者其他类型，都能正确完成拷贝工作\n\n这里有一个小点哈，就是打印char* _a的地址的时候，咱需要用printf而不是cout，因为cout会把_a直接当作字符串打印了，效果就变成了下面这样\n\n用printf来控制输出格式为%x即可\nprintf(&quot;_a:%x &quot;,_a);\n\n\n4.运算符重载4.1定义在讲解赋值运算符重载之前，我们可以来认识一下完整的运算符重载\n\nC++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。\n\n函数名为：关键字 operator运算符，如operator=\n函数原型：返回值类型 operator操作符(参数列表)，如Date operator=();\n下面有几点注意：\n\n重载操作符必须有一个自定义类型的操作数（即操作符重载对内置类型无效）\n不能通过其他符号来创建新的操作符\n对于类类型的操作符重载，形参比操作数少一个传参（因为有一个默认的形参this指针）\n这5个操作符是不能重载的：.*、::、sizeof、? :、.\n\n4.2基本使用以下是在全局定义的操作符重载，用于判断日期是否相等\nbool operator==(const Date&amp; d1, const Date&amp; d2)&#123;    return d1._year == d2._year;    &amp;&amp; d1._month == d2._month    &amp;&amp; d1._day == d2._day;&#125;\n\n当我们在main函数中使用d1==d2的时候，编译器就会自动调用该操作符重载\n当然，你也可以自己来传参使用，如if(operator==(d1,d2))\n但是这样非常不方便，和调用一个而普通函数没啥区别，压根算不上操作符重载。所以我们一般是在类里面定义操作符重载的\n\n\n当我们把它放入类Date中间，就需要修改成下面这样\nbool operator==(const Date&amp; d2)&#123;    return _year == d2._year;    &amp;&amp; _month == d2._month    &amp;&amp; _day == d2._day;&#125;\n\n编译器在调用的时候，会优化成下面这样\nbool operator==(Date* this, const Date&amp; d2)//显示调用为 d1.operator==(d2);\n而在main里面使用的时候，这个重载后的操作符和原本的使用方法完全相同\nDate d1(2022,6,1)Date d2(2022,5,1)d1==d2;//自动调用操作符重载d1.operator==(d2);\n\n后续会以日期类为样板，实现更多的操作符重载\n\n4.3赋值运算符重载因为每一个类都有不同的成员，编译器不可能智能的进行赋值操作。这时候就需要我们自己写一个赋值运算符重载来进行赋值操作了\n以日期类为例，赋值操作其实就是把内置类型成员一一赋值即可\nDate&amp; operator=(const Date&amp; d)&#123;    if(this != &amp;d)//避免自己给自己赋值    &#123;        _year=d._year;        _month=d._month;        _day=d._day;    &#125;    return *this;&#125;\n\n编写赋值重载代码的时候，需要注意下面己点：\n\n返回值和参数类型（注意要引用传参，不然会调用拷贝构造）\n检测是否自己给自己赋值（避免浪费时间）\n因为返回的是*this，出了函数后没有销毁，所以可以用传引用返回\n一个类如果没有显式定义赋值运算符重载，编译器也会自己生成一个，完成对象按字节序的值拷贝。\n\n如果类中有自定义类型，编译器会默认调用它的赋值运算符重载（这里也会涉及到深浅拷贝的问题，后面会在深浅拷贝的博客里详解）\n4.4拷贝构造和赋值重载的调用问题当赋值操作符和拷贝构造同时存在的时候，什么时候会调用赋值，什么时候会调用拷贝构造呢？\n\n在这两个函数中添加cout进行打印提示，可以看到：\n\n如果对象在之前已经存在，就会调用赋值重载\n如果是一个全新的变量在定义的时候初始化，就调用的是拷贝构造\n\n\n5.const成员5.1用const修饰类的成员函数\n将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰的是该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改。\n\n基本的修饰方法如下，在函数的括号后加const即可\nvoid Print()const&#123;\tcout&lt;&lt;_year&lt;&lt;endl;&#125;\n\n实际修饰的是该函数隐含的this指针\nthis指针本身是Date*const类型的，修饰后变为const Date* const类型\nvoid Print(const Date* const this)&#123;\tcout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;&#125;\n\n\n①实例-权限问题这么说好像有点迷糊，我们用实例来演示一下为什么需要const修饰成员函数\nclass Date&#123;public:    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;    &#125;private:    int _year;    int _month;    int _day;&#125;;\n\n假设我们需要在函数中调用Print函数，在main中是可以正常调用的\nint main()&#123;\tDate d1(2022,5,10);    d1.Print();    return 0;&#125;\n\n但当你用一个函数来进行这个操作的时候，事情就不一样了\nvoid TEST(const Date&amp; d)&#123;\td.Print();//d.Print(&amp;d) --&gt;const Date*&#125;int main()&#123;\tDate d1(2022,5,10);    d1.Print();//d1.Print(&amp;d1) --&gt;Date*    TEST(d1);        return 0;&#125;\n\n这时候我们进行了引用调用，因为在TEST中我们不会修改d1的内容，所以用const进行了修饰\n\n这时候TEST中的d.Print()函数调用，传入的是const Date*指针，指针指向的内容不能被修改\nmain中的d1.Print();函数调用，传入的是Date*指针\n\n于是就会发生权限冲突问题👇\n\n这时候如果我们在函数后面加了const，就可以避免此种权限放大问题。这样不管是main函数还是TEST函数中对Print()函数的调用，就都可以正常打印了！\n\n总结一下：\n\nconst对象不可以调用非const成员函数（权限放大）\n非const对象可以调用const成员函数（权限缩小）\nconst成员函数内不可以调用其他非const成员函数（权限放大）\n非const成员函数可以独调用其他const成员函数（权限缩小）\n\n\n\n\n②什么时候需要使用？众所周周知，const修饰指针有下面两种形式\n\n在*之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）\n在*之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）\n\nthis指针本身就是类型名* const类型的，它本身不能被修改。加上const之后，this指向的内容，既类里面的成员变量也不能被修改了。\n知道了这一点后，我们可以合理的判断出：只要是需要修改类中成员变量的函数，就不需要在()后面加const修饰\n如果一个函数中不需要修改成员变量，就可以加const进行修饰\n注意：如果你用了声明和定义分离的写法，那么声明和定义的函数都需要加上const修饰\n\n③出错提醒这里有一点需要提醒的是，如果你对某一个函数进行了const修饰，那么这个函数里面包含的其他类里面的函数，都需要进行const修饰。不然就会报错\n\n出现该报错的情况如下\n\n这个情况也提醒我们，不能在const修饰的函数中，调用非const修饰的成员函数\n\n5.2取地址及对const取地址重载最后两个默认成员函数，编译器会自动生成。这两个函数一般都不需要重载，毕竟返回的本身就是一个this指针，没有什么奇怪的地方\nclass Date&#123; public :     Date* operator&amp;()     &#123;         return this ;     &#125;         const Date* operator&amp;()const     &#123;     \treturn this ;     &#125;private :     int _year ;      int _month ;     int _day ;&#125;;\n\n只有特殊情况，我们需要让&amp;只获取特定内容的时候，才需要手动重载这两个函数\n6.构造，析构顺序下面这个代码是一个很好的示例（22.12.31）\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; class A&#123;public:    A(int count)    &#123;        c = count;        cout &lt;&lt; c &lt;&lt; &quot; init this:: &quot; &lt;&lt; this &lt;&lt; endl;    &#125;     ~A()    &#123;        cout &lt;&lt; c &lt;&lt; &quot; des this:: &quot; &lt;&lt; this &lt;&lt; endl;    &#125;private:    int c;&#125;; A a1(1);//全局 int main()&#123;    A* p = new A(2);//堆区    A a2(3);//栈区    static A a3(4);//静态区     cout &lt;&lt; &quot;#####&quot; &lt;&lt; endl;    delete p;//堆区被主动释放，肯定是第一个析构的&#125;\n\n最终打印的结果如下\n1 init this:: 00D4E4642 init this:: 0160F5583 init this:: 0133F9D84 init this:: 00D4E46C#####2 des this:: 0160F5583 des this:: 0133F9D84 des this:: 00D4E46C1 des this:: 00D4E464\n\n总结：\n\n构造顺序和写代码的运行顺序一致\n析构时候，堆区若手动delete，那么肯定是按delete的顺序析构的\n自动析构的时候，遵循栈-静态-全局的顺序析构\n\n\n日期类的实现类和对象第一站🚌中提到过，在项目协作的时候，我们一半要用定义和声明分离的形式来些一个项目。\n\n下面就让我们用日期类来演示这样的操作\n\n在类中定义的函数会被默认设置为内联，我们的目标就是：短小函数在.h中定义，长函数在.h中声明，在.cpp中定义\n至于源码和解析嘛……大家直接来我的gitee仓库看吧！【传送门】\n注释写的很详细了⏲有啥问题可以在下面留言哦\n\n特殊：对&lt;&lt;和&gt;&gt;的重载这里的&lt;&lt;和&gt;&gt;主要是在使用cin和cout的时候需要使用\n①简单了解io在cplusplus网站上，你可以看到下面这一副图。在使用cin和cout的时候，我们其实分别调用了不同头文件的内容。\n\ncin：istream\ncout、cerr、clog：ostream\n\n\n实际上，流是一个类型的对象，这个对象完成了输入和输出的操作\n\n流操作是系统GUI支持的（了解一下就行，我也不懂）\n\n在cout的定义中，你可以看到，实际上cout为了完成自动识别类型进行输出操作的工作，对各种类型进行了操作符重载operator&lt;&lt;\n\n显然，这部分重载中不包含自定义类型，所以我们需要来仿照这里的函数，进行重载操作\n这里涉及到了友元函数，在类和对象的下一篇博客中我会写道。不过现在你只需要知道，友元函数是某一个类的朋友，目的是在类外访问类里面的成员变量\n\n友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。\n\n②实现最后实现的效果如下，头文件中在最前面进行声明\n\n//这两个是友元函数(因为需要在类外面访问类里面的成员变量)//注意cin和cout的不同实现//因为我们没有完全展开std namepace，所以写这个函数的时候需要自己指定std:://返回值为ostream是为了保证多次coutstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Date&amp; d)&#123;\tout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day &lt;&lt; endl;\treturn out;&#125;//cin使用的是istreamstd::istream&amp; operator&gt;&gt;(std::istream&amp; in, Date&amp; d)&#123;\tint year,month,day;    in &gt;&gt; year &gt;&gt; month &gt;&gt; day;    //这里应该添加一个对日期的正确性判断     if(year&gt;=0        &amp;&amp;(month&gt;=1&amp;&amp;month&lt;=12)        &amp;&amp;(day&gt;=1&amp;&amp;day&lt;=d.GetMonthDay(year,month)) )    &#123;//判断日期正确性        d._year=year;        d._month=month;        d._day=day;    &#125;    else    &#123;        cout&lt;&lt;&quot;Date err!&quot;&lt;&lt;endl;        exit(0);//日期错误直接终止程序    &#125;\treturn in;&#125;\n\n程序运行的效果如下，和我们直接使用cout、cin是一样的！\n\n当你写了一个离谱日期后，程序也会进行正确的报错\n\n③疑惑解答你可能会想，干嘛用友元啊，直接在类里面定义这个函数重载不就可以了？\n之所以在外头定义该函数，是因为类里面定义的函数，默认会带有一个隐含的this指针传参，作为操作符的左操作数。\n然后你的函数使用就得变成下面这样😱\nd1&lt;&lt;cout;\n\n虽然也能跑起来并完成工作，但这样写也太怪了！\n结语最后的最后，今天是5月20日，用下图给大家送上祝福😂\n\n","categories":["遇见C++"],"tags":["Linux","C++","类和对象"]},{"title":"【算法】算法的空间复杂度和时间复杂度","url":"/posts/3906762122/","content":"前言🕵️‍♂️在之前的学习中，已经接触过了网上OJ题目\n在一些题目中，我们经常可以看到时间复杂度和空间复杂度的要求\n你可能和我有一样的疑惑，复杂度究竟是什么？我要怎么评判我自己写的算法的复杂度？\n今天就让我们来认识认识~~\n\n\n\n1.算法效率🧐和做任何事情一样，我们写的算法，自然也有它的运行效率。效率越高越好\n1.1什么是算法算法可以简单地理解为我们为了求解一个问题，所写的函数\n在初识C语言中，我们学习过利用递归求解斐波那契数列的算法\nlong long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n这个算法只有3行代码，看上去非常简洁——但是简洁的代码不一定效率就高！\n1.2如何衡量？算法在编写成可执行程序的时候，main函数使用这个算法，需要调用一定的空间，消耗一定的时间。算法的效率就是通过空间和时间这两个维度来评判的\n\n时间复杂度：衡量一个算法的运行速度\n空间复杂度：衡量一个算法运行需要开辟的额外空间\n\n\n2.时间复杂度⏰算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。算法中基本操作的执行次数，为算法的时间复杂度\n\n时间复杂度是一个近似值，并不是实际运行的时间\n实际上代码的运行时间，和机器的内存、cpu性能和平台都有关系，同一个代码在不同的机器上运行时间都不一样，如果只以纯粹的时间来考核，很难分析\n\n找到某条基本语句与问题规模N之间的数学表达式，就算出了该算法的时间复杂度\nvoid test1(int N){\tint count =0;    for(int i=0;i&lt;N;i++)    {        for(int j=0;j&lt;N;j++)        {            count++;        }    }        for (int k = 0; k &lt; 2 * N ; ++ k)    {     \tcount++;    }        int M = 10;    while (M--)    {     \tcount++;    }        return;}\n\n请问这个代码中，count语句执行了几次？\n可以总结出如下表格\n\n\n\nN\nF(N)\n\n\n\n10\n130\n\n\n100\n10210\n\n\n1000\n1002010\n\n\n你可能会简单地认为，F(N)的结果就是我们的时间复杂度。其实并不然，我们并不需要一个精确的运行次数，只需要知道程序运行次数的量级就行了\n这里我们使用大O渐进表示法来表示时间复杂度（空间复杂度同理）\n2.1大O的渐进表示法大O符号（Big O notation）：是用于描述函数渐进行为的数学符号\n\n推导大O阶方法： \n\n用常数1取代运行时间中的所有加法常数。\n在修改后的运行次数函数中，只保留最高阶项。 \n如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶\n\n\n使用这种方法后，test1函数的时间复杂度为对于test1函数，在计算的时候，我们省略了最后的+10，保留了最高阶数N2，即得出了它的时间复杂度\n\n如果最高阶数前面有系数，如2N，系数也将被省略\n\n因为当N的数值很大的时候，后面的那些值对我们总运行次数的影响已经非常小了。大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数\n2.1.1 O(logN)以什么为低\n来自《代码随想录》2021年12月第1版 P13\n\n在计算过程中，假设我们有如下两个时间复杂度和实际上，以2为底的O是可以转成以10为底的O也就等同于常数总结出来就是而在大O渐进法中常数可以忽略，所以我们可以认为log中的底数是意义不大的，可以忽略直接说logN\n2.2多种情况取最坏一些算法的时间复杂度会有最好、最坏和平均的情况\n\n最好情况：任意输入规模的最小运行次数(下界)\n平均情况：期望的运行次数\n最坏情况：任意输入规模的最大运行次数(上界)\n\n举个例子，当我们编写一个在数组中查找数值的算法时，它可能会出现这几种情况：\n\n最好情况：1次就找到\n平均情况：N/2次\n最坏情况：N次\n\n在实际中的一般情况，我们关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)\n2.3常见时间复杂度的计算NO.1 双独立循环void Func1(int N){     int count = 0;     for (int k = 0; k &lt; 2 * N ; ++ k)     {     \t++count;     }     int M = 10;     while (M--)     {     \t++count;     } \tprintf(\"%d\\n\", count);}\n\n这里出现了两个循环，分别是2N次和10次。前面提到了大O渐进法只保留最高阶数并省略系数，所以它的时间复杂度是O(N)\nNO.2 双独立循环void Func2(int N, int M){     int count = 0;     for (int k = 0; k &lt; M; ++ k)     {     \t++count;     }     for (int k = 0; k &lt; N ; ++ k)     {     \t++count;     }     printf(\"%d\\n\", count);}\n\n这里出现了次数为N和M的两层循环\n\n当M和N差不多大的时候，时间复杂度可以理解为O(M)或O(N)\n当M远远大于N时，时间复杂度为O(M)\n一般情况取O(M+N)\n\n\nNO.3 常数阶void Func3(int N){     int count = 0;     for (int k = 0; k &lt; 100; ++ k)     {     \t++count;     }     printf(\"%d\\n\", count);}\n\n这里我们得知了具体的循环次数为100，是一常数，时间复杂度为O(1)，代表常数阶\n\n只要循环次数已知，为一常数且和所传参数无关，其时间复杂度即为O(1)\n\nNO.4 strchr//计算strchr的时间复杂度const char * strchr ( const char * str, int character );\n\n看到这道题的时候，你可能会一愣，strchr是什么？\n\n在之前的博客里，我介绍了很多常用的字符串函数👉点我\n可这里面没有strchr，但有strstr\n\nstrstr函数的作用：在字符串1中寻找是否有字符串2\n其中第二个str代表的是string字符串，那我们是不是可以猜想，chr代表的是char字符，其作用是在一个字符串中查找是否有一个字符呢？\n当然，光是猜想肯定是不够的，我们还需要求证一下\n\n如何查询库函数定义并尝试使用它？👉点我\n\n打开cplusplus网站，搜索strchr，即可转到函数定义\n\n可以看到，该函数的作用是定位字符串中第一次出现该字符的位置，返回值是一个pointer指针\n和我们猜想的一样，它的作用就是在字符串中查找一个字符，并返回它第一次出现的位置的地址。\n这样一来，strchr函数的时间复杂度就很清楚了，就是遍历字符串所需要的次数，O(N)\nNO.5 冒泡排序void BubbleSort(int* a, int n){     assert(a);     for (size_t end = n; end &gt; 0; --end)     {         int exchange = 0;         for (size_t i = 1; i &lt; end; ++i)         {         \tif (a[i-1] &gt; a[i])         \t{                Swap(&amp;a[i-1], &amp;a[i]);                exchange = 1;         \t}    \t }     if (exchange == 0)    \t break;     }}\n\n冒泡排序是一个非常经典的代码，其思路就是遍历整个数组，如果待排序数字大于它的下一位，则交换这两个数字\n\nN个数字的数组需要N-1次排序才能完成\n每一次排序都需要遍历一次数组\n\n这样算来，冒泡排序的循环次数就是两个N相乘，即为O(N^2)\n\n能否通过循环层级判断？细心的你可能会发现，上述代码中出现了两层循环，那是不是可以通过循环层级来判断时间复杂度呢？\n并不能！\nfor(int i=0;i&lt;n;i++){\tfor(int j=0;j&lt;3;j++)\t\tprintf(\"hehe\\n\");}\n\n如果是上述这种两次循环的情况，会打印3n次呵呵，其时间复杂度是O(N)而不是N^2\n\n我们要准确分析算法的思路，并不能简单地通过循环层级来判断时间复杂度\n\nNO.6 二分查找//a 数组，n长度，x需要查找的数int BinarySearch(int* a, int n, int x){     assert(a);     int begin = 0;     int end = n-1;     while (begin &lt;= end)     {         int mid = begin + ((end-begin)&gt;&gt;1);//使用位移操作符来模拟/2，防止begin和end相加后超出int范围         if (a[mid] &lt; x)         \tbegin = mid+1;         else if (a[mid] &gt; x)         \tend = mid-1;         else         \treturn mid;//返回需要查找的数的下标     }     return -1;}\n\n二分查找的思路这里不再赘述\n假设我们找了x次，每一次查找都会使查找范围减半\nN/2/2/2/2 ……\n\n最后我们可以得出2条公式\n\n\n最好情况：O(1)\n最坏情况：O(logN)\n\n\n通过时间复杂度的对比，我们就能看出二分查找的优势在那里了\n\n\n\nN\nO(N)\nO(logN)\n\n\n\n1000\n1000\n10\n\n\n100w\n100w\n20\n\n\n10亿\n10亿\n30\n\n\n可以看到，当数据很大的时候，O(logN)的算法执行次数比O(N)少了特别多!!（来自BT-7274的肯定）\n\nNO.7 计算N!// 计算阶乘递归Fac的时间复杂度？long long Fac(size_t N){     if(0 == N)     \treturn 1;     return Fac(N-1)*N;}\n\n对于这个阶乘的递归函数而言，每次函数调用是O(1)，时间复杂度主要看递归次数\n对于数字N而言，递归需要N次，时间复杂度是O(N)\n递归算法时间复杂度计算递归算法时间复杂度 = 递归次数 * 每次递归中操作次数\n\n\n如果每次函数调用是O(1)，看递归次数\n每次函数调用不是O(1)，那么就看他递归调用中次数的累加\n\nNO.8 斐波那契数列\n计算斐波那契数可以用递归和迭代两种算法👉点我\n\n// 计算斐波那契递归Fib的时间复杂度？long long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n\n每次递归，次数都会增加，总的来说是以2^x的量级增加的（x代表行数）这里一共有x-1项，用等比数列的求和公式得出，结果为2x-1\n所以最后得出的时间复杂度为O(2N)\n\n需要注意的是，当递归调用到底部时，有一些调用会较早退出，这部分位于金字塔的右下角\n\n由于时间复杂度只是一个估算值，这一部分缺失的调用次数对总运行次数的影响不大，故忽略掉\n\nNO.9 非+1递增循环void fun(int n) {   int i=l;   while(i&lt;=n)      i=i*2;}\n\n此函数有一个循环，但是循环没有被执行n次，i每次都是2倍进行递增，所以循环只会被执行log2n次\nNO.10 有序数组中查找和为sum的两个数给定一个整数sum，从有N个有序元素的数组中寻找元素a，b，使得a+b的结果最接近sum，最快的平均时间复杂度是？\nA. O(n)//√B. O(n^2)C. O(nlogn)D. O(logn)\n\n数组元素有序，所以a,b两个数可以分别从开始和结尾处开始搜，根据首尾元素的和是否大于sum,决定搜索的移动，整个数组被搜索一遍，就可以得到结果，所以最好时间复杂度为n\nNO.11 双嵌套循环void test(int n){    for(int i=0;i&lt;n;i++)    {//循环1        for(int j=i;j&lt;n;j++)        {            //循环2        }    }}\n\n以上是一个很常用的循环。其中循环2的执行次数是一个等差数列，第一次是n，第二次是n-1，第三次是n-2……一直到最后一次为1；这个等差数列的求和为n(n+1)/2，即n2/2+n/2，因为时间复杂度需要取大且忽略系数，所以最终的时间复杂度为n2\n\n3.空间复杂度🏠3.1概念空间复杂度是对一个算法在运行过程中临时占用空间大小的度量\n\n和时间复杂度不是真的计算时间一样，空间复杂度也不衡量算法具体占用的内存字节数。\n\n空间复杂度计算的是额外开辟的变量的个数，适用大O渐近法\n注意：函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。\n3.2空间复杂度计算NO.1 冒泡排序void BubbleSort(int* a, int n){     assert(a);     for (size_t end = n; end &gt; 0; --end)     {         int exchange = 0;         for (size_t i = 1; i &lt; end; ++i)         {         \tif (a[i-1] &gt; a[i])         \t{                Swap(&amp;a[i-1], &amp;a[i]);                exchange = 1;         \t}    \t }     if (exchange == 0)    \t break;     }}\n\n我们会发现，冒泡排序算法并没有额外定义非常多的变量，一共只有3个，属于常数阶\nsize_t end = n;int exchange = 0;size_t i = 1;\n\n其空间复杂度为O(1)\n计算时注意其与N的关系当我们在算法中开辟空间，计算空间复杂度的时候，要注意开辟的这个空间与N有没有关系\nint arr[N];//c99变长数组，和传过来的参数有关int* a=(int*)malloc(sizeof(int)*N);//和传过来的参数有关，O(N)int* a=(int*)malloc(sizeof(int)*3);//和传过来的参数无关，O(1)\n\nNO.2 斐波那契数列// 计算Fibonacci的空间复杂度？// 返回斐波那契数列的前n项long long* Fibonacci(size_t n){     if(n==0)     return NULL;     long long * fibArray = (long long *)malloc((n+1) * sizeof(long long));     fibArray[0] = 0;     fibArray[1] = 1;     for (int i = 2; i &lt;= n ; ++i)     {     \tfibArray[i] = fibArray[i - 1] + fibArray [i - 2];     }     return fibArray;}\n\n和上面的斐波那契数列的递归代码不同，这里我们新创建了一个数组，用来保存计算出来的斐波那契数\n一共malloc了n+1个长整型的空间，空间复杂度是O(N)\n\n函数栈帧空间重复使用问题如果是递归方法的斐波那契算法，其空间复杂度是多少呢？\nlong long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n答案也是O(N)\n因为对于递归算法而言，其开辟的函数栈帧空间是可以重复利用的！\n如fib(8)的调用，其开辟的函数栈帧，是可以在后续继续调用fib函数时重复使用的\n\n通过函数的参数压栈，我们可以很好地理解这是为啥👉点我\n\n\n上图中f1和f2是两个函数，但执行了相同的功能。其函数调用的空间实际上是一个，f2在f1销毁后继承了它的空间\n\n这就好比每一次新的递归都会开一家新的饭店，但是你下次还想吃东北菜的时候，可以去之前开的东北菜馆，咱没必要让别人再开一家馆子不是嘛？\n\n不过由于斐波那契数的递归算法会递归非常多次，在数字很大的时候，会导致栈溢出\n\n递归函数空间复杂度针对递归函数，可以认为空间复杂度如下\n递归层级 * 每次递归的空间复杂度\n\n和时间复杂度的计算是很相似的。\n\n比如下面这个斐波那契数列的空间复杂度，如果入参是5，调用会调用5层，每一层都是一个乘法操作，空间负载度是O(1)，最终得到的空间复杂度是O(5)，也就是O(N)\n// 版本1long long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n这个写法肯定不是最优的，代码随想录中提供了个更好的解法\n// 版本2// 进入这个函数时，前两个参数都给1，N正常给long long Fib(long long first,long long second,size_t N){     if(N &lt;= 0)         return 0;     if(N &lt; 3)     \treturn 1;     else if(N == 3)// 相当于减少了两次递归     \treturn first+second;\t     return Fib(second,first+second,N-1);}\n\n此时减少了2次递归，虽然并没有降低空间复杂度（还是O(N))，但时间负载度大大降低！\n\n版本1时间复杂度为O(2n)\n版本2时间复杂度为O(N)\n\n运行速度也会快非常多！\n\nNO.3 阶乘long long Fac(size_t N){     if(N == 0)     \treturn 1;     return Fac(N-1)*N;}\n\n虽然函数本身的空间不计入时间复杂度，这里计算的是递归调用时额外开辟的函数栈帧空间\n一共调用了N-1次，每个栈帧使用了常数个空间，空间复杂度是O(N)\n4.常见复杂度对比👐\n\n\n结语😘时间复杂度和空间复杂度可以帮我们很好的了解自己所写算法的好坏，在未来面试的时候，HR肯定也更喜欢效率高的算法\n要多刷题，好好积累自己的能力，想必之后写出好算法也是水到渠成（吧？）\n\n如果这篇博客对你有帮助，点个赞再走呗~\n\n","categories":["数据结构太复杂"],"tags":["C语言","算法","数据结构","OJ刷题"]},{"title":"【C++】动态内存管理","url":"/posts/1688214907/","content":"在之前类和对象的博客里面，已经记录过了C++中动态内存管理函数new和delete的基本使用。本篇博客是对C++动态内存管理的进一步细化\n\n\n[TOC]\n1.C&#x2F;C++内存分区这是一个老生常谈的问题了，直接看下面这个图吧！\n\n这里的数据区其实就是静态区，而代码区是常量区。这里的BBS区先暂时pass掉。\n要想辨别上面的几个内存分区，可以现来看下面这个代码，你能分的清楚它们都是存在内存的哪一个区域吗？\nint a = 1;//数据区static int b = 1;//数据区int main()&#123;     static int c = 1;//数据区     int d = 1;//栈     int arr1[10] = &#123;1, 2, 3, 4&#125;;//栈     char arr2[] = &quot;abcd&quot;;//栈     char* arr3 = &quot;abcd&quot;;//&quot;abcd&quot;存在代码区     int* ptr = (int*)malloc(sizeof (int)*4);//堆     free (ptr);    //其中，ptr指针本身是存在栈区的    //同理，arr3指针本身存在栈区    //但是arr3指针指向的对象是存在代码区（静态区）&#125;\n\n2.C++动态内存管理在C语言中，基本的动态内存管理通过malloc和free实现\nint* ptr = (int*)malloc(sizeof (int)*4);//堆free (ptr);\n\n在C++中，对应产生了new和delete，它们比前者更加高级，具有更多特性\n2.1基本认识new和delete下面是基本的使用方式，想必大家看了之后，是“有手就行”😂\nint*p1=new int;//开辟一个int类型的空间   int*p2=new int(10);//开辟一个int类型的空间，并初始化为10   int*p3=new int[10];//开辟10个int类型的空间   //注意后两个的括号区别！      delete p1;//销毁p1指向的单个空间   delete p2;//同上      //delete p3;//销毁p3指向的第一个空间，不能用于数组   delete[] p3;//销毁p3指向的数组\n\n2.2操作类对象new相比于malloc，最大的区别在于处理自定义类型的时候。类和对象就是C++中与C语言完全不同的自定义类型。\n我们知道，当你使用类名创建一个对象的时候，编译器会自动调用这个对象的构造函数。那如果我们用new来创建一个自定义类型的对象呢？\nclass Stack&#123;private:    int* _a;&#125;int main()&#123;    Stack* p1=(Stack*)malloc(sizeof(Stack));    Stack* p2=new Stack;        return 0;&#125;\n\n这时候的区别就在于\n\nnew在创建的对象的时候，会自动调用该对象的构造函数\nmalloc在创建对象的时候，不会调用构造函数\n\n这样就能解释，为什么C++要单独弄出一个new，而不是继续沿用C语言的malloc了。因为我们在class中定义成员变量的时候，大多数是定义成私有的。如果对象在创建的时候没有进行构造，我们很难从外部访问类内部的私有成员进行初始化操作。\n所以new的出现，让我们能够在堆上开辟对象空间的同时，初始化这个对象。\n不难理解，delete和free的区别也是如此：\n\n当你调用delete的时候，编译器会调用类的析构函数\n使用free不会调用析构函数，可能造成内存泄漏\n\n\n2.3对象数组// 申请单个Test类型的对象 Test* p1 = new Test; delete p1;  // 申请10个Test类型的对象 Test* p2 = new Test[10]; delete[] p2;\n\n和内置类型一样，我们也可以方便的使用new来实现开辟对象数组\n注意，在delete操作的时候，一定要注意匹配问题，不能直接用delete p2来释放开辟的数组空间\n\n2.4给构造函数传参如果这个类的构造函数是包含参数的话，还可以使用下面这种方式在开辟空间，调用构造函数时传参（注意括号区别）\nTest* p3 = new Test(10);//给对象Test的构造函数传参delete p3;\n\n\n3.operator new&#x2F;delete函数看到这个名字，估计你和我一样，会下意识的认为这个是c++中对new和delete操作符的重载。nope！这两个实际上是C++中实现new和delete的一部分函数\n为啥说是一部分呢，让我们来康康它的源码\noperator new (std::size_t sz) _GLIBCXX_THROW (std::bad_alloc)&#123;  void *p;  /* malloc (0) is unpredictable; avoid it.  */  if (sz == 0)    sz = 1;  while (__builtin_expect ((p = malloc (sz)) == 0, false))    &#123;      new_handler handler = std::get_new_handler ();      if (! handler)    _GLIBCXX_THROW_OR_ABORT(bad_alloc());      handler ();    &#125;  return p;&#125;\n\n你回复下，这个函数最终使用了malloc来开辟空间，只是在这之上，new还引入了抛异常机制\n\nC语言中，malloc错误会返回null指针\nC++中，new错误会执行抛bad_alloc异常操作\n\n不知抛异常是什么？我们可以暂且不用理解它。只需要知道，当new失败的时候，控制台会直接报错终止程序，而不是和malloc一样，将指针变空指针，从而导致可能出现的解引用空指针操作。\n实际上，当我们new一个对象的时候，会执行下面两个函数\noperator new对象的构造函数\n\n在VS中打开调试，转到反汇编，你便可以看到编译器call这两个函数的操作\n\n再来看看operator delete的代码\n\nhttps://cplusplus.com/reference/new/operator%20delete/\n\nvoid operator delete(void *pUserData)&#123;\t_CrtMemBlockHeader * pHead;\tRTCCALLBACK(_RTC_Free_hook, (pUserData, 0));\tif (pUserData == NULL)\t\treturn;\t_mlock(_HEAP_LOCK); /* block other threads */\t__TRY\t/* get a pointer to memory block header */\tpHead = pHdr(pUserData);\t/* verify block type */\t_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));\t_free_dbg( pUserData, pHead-&gt;nBlockUse );\t__FINALLY\t_munlock(_HEAP_LOCK); /* release other threads */\t__END_TRY_FINALLY\treturn;&#125;\n\n我们发现，delete最终也是通过调用free实现的\n\n但是这里的反汇编，我就有点看不懂了。看起来也调用了一个Stack函数，姑且认为那个就是Stack的析构函数吧\n\n3.1 new和delete的实现原理看到这里，让我们来总结一下new和delete的实现原理。\nnew的原理：\n\n调用opeartor new申请空间，错误时抛异常\n如果操作的是自定义类型，则调用构造函数\n\nnew int[N]原理:\n\n调用operator new[]（没错库里面还有一个这个函数）\n在operator new[]中实际调用N个operator new来申请空间\n如果操作的是自定义类型，则还会分别调用N次构造函数\n\ndelete的原理：\n\n在原始空间上调用析构函数，清楚内容\n调用operator delete执行对象空间的free操作\n\ndelete int[N]的原理：\n\n调用N次析构函数\n调用operator delete[]，实际调用N个operator delete来释放N个对象的空间\n\n编译器在分配内存时通常会在分配的内存块前面存储一些额外的信息，以便在释放内存时正确计算要释放的空间大小。这些额外的信息可能包括分配的内存块大小、指向析构函数的指针等。因此，当调用delete操作符时，编译器可以从所分配的内存块中提取这些信息，并使用它来确定要释放的空间大小。\n3.2 delete加[]和不加的区别\n 1、delete 释放new分配的单个对象指针指向的内存\n\n​     2、delete[] 释放new分配的对象数组指针指向的内存\n​     3、delete处理单个类类型，先会调用析构函数，释放它所占资源，然后释放它所占内存空间。\n​     4、delete处理数组类类型的时候，会对每一个数组对象都调用它们的析构函数，然后再释放它们所占用的内存空间。所以对于类类型的数组如果不调用delete[],那就只调用了下标为0的对象的析构函数，可能会产生问题。\n​     5、两个都会释放所占内存，对于内置类型不管是数组还是单个对象，都可以混用，没有关系，因为对于内置类型，它只干一件事，就是释放它们所占内存\n​     6、如果对于单个类对象，delete和delete[]都可以，因为delete是知道它要释放多大空间的，加不加[]括号的区别是对不对每个对象调用析构函数，如果只有一个的话，它就调用一次，所以没有关系。\n4.定位new定位new表达式会在已分配的原始内存空间中调用构造函数初始化对象\n\n啊嘞，new不是会自己调用构造函数吗？这个定位new有是来干什么的？\n\n查阅了一些我现在看不懂的资料后，了解到，定位new的操作多半是配合自己写的内存池来进行操作。在之前博客中出现的Tcmalloc就是谷歌写的一个内存池\n4.1什么是内存池？当我们使用new或者malloc时，是通过编译器向操作系统申请空间\n而内存池就是一个我们写的预先申请内存空间的模块\n这个模块会在执行后，先预先向操作系统要一个相对较大的空间。我们后续的操作就是在这个已经开辟好的空间中再次申请空间来实现的\n因为这样就是从自己的口袋里面拿东西，没有中间商赚差价，效率就会提高不少。\n但是这样就没有了new本身自动调用构造函数的优势，需要我们自己来调用构造函数\n4.2定位new的使用定位new的英文叫 placemaent new，要知道，别看到这个英文不知道它啥意思；\nnew(place_address) type或者new(place_address) type(initializer-list)\n\n以下面这个类为例\nclass Stack &#123;public:    Stack(int num = 5)    &#123;        _a = new int[num];        _capa = num;        cout &lt;&lt; &quot;Stack(int)&quot; &lt;&lt; endl;    &#125;    ~Stack()    &#123;        delete[] _a;        _capa = 0;        cout &lt;&lt; &quot;~Stack()&quot; &lt;&lt; endl;    &#125;private:    int* _a;    int _capa;&#125;;\n\n我们先使用malloc来模拟没有调用构造函数的情况，再使用定位new来调用构造函数\nint main()&#123;    Stack* p= (Stack*)malloc(sizeof(Stack));\tnew(p) Stack; //如果类的构造函数有参数时，此处需要传参&#125;\n\n可以看到，编译器成功调用了构造函数\n\n\n5.更多知识点5.1 malloc和new的区别malloc&#x2F;free和new&#x2F;delete的共同点是：都是从堆上申请空间，并且需要用户手动释放\n不同的地方是： \n\nmalloc和free是函数，new和delete是操作符\nmalloc申请的空间不会初始化，new可以初始化（通过new int(10))\nmalloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可（其实就是省略了sizeof这一步的操作）\nmalloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型\nmalloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常\n申请自定义类型对象时，malloc&#x2F;free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中内存的清理\n\n5.2 内存泄漏我们知道，当堆区申请的空间没有进行释放的时候，就会出现内存泄漏，造成内存的浪费，甚至导致操作系统boom！\n\n\n堆内存泄漏\n\n堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存， 用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生堆内存泄漏\n\n系统资源导致的泄漏\n\n系统资源泄漏 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统 资源的浪费，严重可导致系统效能减少，系统执行不稳定。\n\n除了忘记free或者delete之外，另外的一些情况导致程序提前终止，也会出现内存泄漏\nint main()&#123;    Stack* p1 = (Stack*)malloc(sizeof(Stack));    Stack* p2 = new Stack;            free(p1);    return 1;//只是做个示例，实际上哪有人这么写代码啊！        delete p2;    return 0;&#125;\n\n比如上面这个函数中，free之后执行了return，跳过了delete的操作，即导致p2的内存没有被释放，出现了内存泄漏\n解决内存泄漏有很多办法，其中最好的办法就是维持一个良好的代码风格，避免出现忘记释放内存的情况！\n5.3 深拷贝这个麻烦大家移步之前类和对象的博客啦\n\nhttps://blog.csdn.net/muxuen/article/details/124881928?spm=1001.2014.3001.5501\n\n\n结语本篇博客到这里就结束了\n期末考试其实已经结束5天了，我还在摸鱼……呜呜\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】快速学习类和对象，看这一篇就够了","url":"/posts/3040822590/","content":"本篇博客是学校大一下C++期末考察的要求，包含了C++中类和对象的大部分内容，适合学习类和对象的你观看。最后还有两个小项目，综合了绝大部分类和对象的知识，很适合练手+深化学习。\n\n\n为了避免被同校copy，本篇博客只在我的HEXO个人博客上发布\n第一章 绪论1.1 面向对象程序特点与目标面向对象有下面几个特征：\n\n类与对象：把现实世界中的某一类东西，提取出来，用代码表示；\n封装性：把过程和数据封装到一个包裹里面，对数据的访问只能通过公开权限的函数接口来进行操作；\n继承性：一种联结类的层次模型，类似树状结构；\n多态性：允许不同类的对象对同一消息做出响应，用不同的方法来解决一个问题。\n\n其中 封装、继承、多态 被称为面向对象的三大特性\n通过这些特征，我们可以看得到，其实面向对象的程序也是在C语言的面向过程的基础上得来的。其目的也是为了更好的服务某一个具体的问题，并通过这个问题衍生出不同的解题方法，并用代码来表示解决一个问题对象的过程。\n1.2 面向对象程序知识架构\n\n第二章 面向程序对象关键支撑技术2.1 类和对象类和对象与命名空间类似，都是存在一种封装。不同的是，类是对C语言struct结构体类型的拓。除了变量以外，类里面还可以定义成员函数，并设置它们的权限，实现了对一个接口的完整封装。\n2.1.1 构造函数众所周周知，当我们写C语言的顺序表、链表等代码的时候，一般都会写一个Init函数来初始化内容。\nvoid Init()&#123;\ta=(int*)malloc(sizeof(int)*4);\tsize=0;\tcapa=4;&#125;\n\n但是这样有一个缺点，就是不够智能，需要我们自己来调用它进行初始化。\n于是C++就整出来了一个构造函数来解决这个问题\n特性\n构造函数：名字和类名相同，创建类对象的时候编译器会自动调用，初始化类中成员变量，使其有一个合适的初始值。构造函数在对象的生命周期中只调用一次\n构造函数有下面几个特性：\n\n函数名和类名相同\n无返回值\n构造函数可以重载\n对象实例化的时候，编译器会自动调用对应的构造函数\n如果你自己不写构造函数，编译器会自己创建一个默认的构造函数\n\n2.1.1.1基本使用下面用一个队列来演示一下构造函数\nclass Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;//测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n可以看到，在创建对象q1的时候，编译器就自动调用了类中的构造函数，帮我们初始化了这个队列\n\n\n除了上面这种最基本的无参构造函数以外，一般写构造函数的时候，我们都会带一个有缺省值的参数，这样可以更好地灵活使用这个队列\nQueue(int Capacity=4)&#123;    _a=(int*)malloc(sizeof(int)*Capacity);    _size=0;    _capa=Capacity;&#125;\n\n调用这种构造函数也更加灵活，我们可以根据数据类型的长度，来创建不同容量的队列，避免多次realloc造成的内存碎片\nQueue q1;//调用无参的构造函数Queue q2(100);//调用带参的构造函数\n\n多种构造函数是可以同时存在的，不过！它们需要满足函数重载的基本要求\n当你调用一个无参的函数，和一个全缺省的函数的时候，编译器会懵逼！\nQueue();Queue(int Capacity=4);//这两个函数不构成重载，会报错\n\n正确的重载应该是下面的情况\nQueue();Queue(int Capacity);\n\n编译器在创建对象的时候，就会智能选择这两个构造函数其中之一进行调用。但是同一个对象只会调用一个构造函数。\n除了在构造函数内部初始化参数，我们还可以在初始化列表处进行操作\nQueue(int Capacity=4)\t:_a(new int[Capacity]),    _size(0),    _capa(Capacity)&#123; &#125;\n\n2.1.1.2编译器默认生成的构造函数上面提到过，如果我们不写构造函数，编译器会自己生成一个。\n但测试过以后，你会发现，这个默认生成的构造函数，好像啥事都没有干——或者说，它把_a _b _c 都初始化成了随机值！\n\n实际上，编译器默认生成的构造函数是不会处理内置类型的\n\n内置类型：int、char、float、double……\n外置类型：自定义类型（其他的类）\n\n在处理的时候，编译器忽略内置类型；外置类型会调用它的构造函数\nclass Date&#123;public:    //默认构造函数：不传参就能调用的    //1.全缺省 2.无参 3.编译器自动生成    //可以是半缺省的，但是不实用    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;        _A.Print();    &#125;private:    //编译器会自动生成构造函数（如果你没有自己写的话）    //自动生成的构造函数是不会初始化内置类型的    //内置类型：int,char,double等等    int _year;    int _month;    int _day;    //外置类型：自定义类型    //外置类型会调用它自己的默认构造函数    Queue _A;&#125;;\n\n可以看到，编译器调用了自己的构造函数的同时，还调用了外置类型Queue的构造函数，搞定了它的初始化\n\n如果我们去掉Date的构造函数，就能看到下面的情况。Queue成功初始化，但是内置类型的年月日都是随机值\n\n一般情况下一个C++类都需要自己写构造函数，下面这两个情况除外\n\n类里面的成员都是自定义类型成员（且有自己的构造函数）\n如果还有内置类型成员，声明时给了缺省值\n\n注：只有类在声明变量的时候才可以给缺省值\n//下面的情况就不需要写class MyStack&#123;private:      Queue q1;//自定义类型      Queue q2;      int a=1;//内置类型声明的时候给了缺省值&#125;;\n2.1.1.3初始化列表除了上面的方式之外，还有一种构造函数的使用方式为初始化列表\nDate(int year=2022,int month=2,int day=30)    :_year(year),\t_month(month),\t_day(day)&#123;&#125;\n\n\n每个成员变量只能在初始化列表中出现一次\n类中包含以下成员必须在初始化列表中进行初始化\n引用\nconst成员\n自定义类型成员\n\n\n\n一般情况下，建议使用初始化列表进行初始化。因为对于自定义类型的成员变量，初始化列表的优先级是高于&#123; &#125;里面的内容的。\n这里还有非常重要的一点！\n成员变量在类中声明的顺序就是初始化列表的顺序，而并非初始化列表自己的顺序！\n\n怎么理解呢？看下面这个代码\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(month)\t&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n即便我们把_day放在了初始化列表的首位，但由于它是在最后声明的。所以构造函数走初始化列表的时候，会依据声明顺序，依次初始化年、月、日。\n\n这会引起什么问题？再来看看一个错误示例\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(_day)&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n当我们用上面这个初始化列表的时候，我们本意是想在初始化完_day以后，将_day的值赋给_month。但由于_month的声明顺序在_day之前，所以_month(_day)会先执行，此时的_day尚为随机值，这就导致月份变成随机值了！\n\n这只是一个示例，实际上肯定不会用天数初始化月数，范围不一样\n\n最好的办法，就是声明顺序和初始化列表的顺序保持一致！\n2.1.1.4 explicit关键字构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有隐式类型转换的作用。\nclass Date&#123;public:    //正常的构造函数    //Date(int year)    //    :_year(year)    //    &#123;&#125;\t    explicit Date(int year)        :_year(year)        &#123;&#125;private:    int _year;    int _month:    int _day;&#125;；void TestDate()&#123;    Date d1(2018);    // 用一个整形变量给日期类型对象赋值    // 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值    d1 = 2019;&#125;\n\n当我们调用赋值的时候，实际上编译器会先用2019构造出一个date类型对象，再调用赋值重载（这里还没有写）赋值给d1。这就是一个隐式类型转换\n如果我们用explicit修饰了这个构造函数，那么编译器将不会进行此类隐式类型转换！\n\n2.1.2 拷贝构造函数2.1.2.1特性和使用拷贝构造是一个特殊的构造函数，它的参数是另外一个Date类型。在用已有的类类型对象来创建新对象的时候，由编译器自动调用\n因为拷贝的时候我们不会修改d的内容，所以传的是const。另外，我们必须进行传引用调用！\n如下面的这个函数，在传参的时候，编译器会去调用Date的拷贝构造\nvoid func(Date d);\n\n如果你没有写拷贝构造，或者拷贝构造里面不是传引用，编译器会就递归不断创建新的对象进行值拷贝构造，程序就死循环辣\n//拷贝构造，如果不写的时候，编译器会默认生成一个    //对内置类型进行值拷贝(浅拷贝)    Date(const Date&amp; d)    &#123;        _year=d._year;        _month=d._month;        _day=d._day;        //外置类型会调用外置类型的拷贝构造        Queue b(_A);    &#125;\n\n和构造、析构不同的是，编译器自己生成的拷贝构造终于有点用了\n\n它会对内置类型进行按内存存储的字节序完成拷贝，这种称为值拷贝（又称浅拷贝）\n对外置类型会调用它的构造函数\n\n2.1.2.2深拷贝外置类型拷贝问题\n但是！如果你使用了外置类型，该类型中包含malloc的时候，编译器默认生成的构造函数就不能用辣！\n因为这时候，编译器默认生成的拷贝构造会进行值拷贝，拷贝完了之后，就会出现q1和q2指向同一个空间的情况。修改q2会影响q1，free的时候多次释放同一个空间会报错，不符合我们的拷贝构造的要求\n\n注意注意，malloc不行的原因是，数据是存在堆区里面，拷贝的时候，q2的_a得到的是一个地址，而不是拷贝了新的数据内容。\n\n如果你在类里面定义了一个int arr[10]数组，这时候拷贝构造就相当于memcpy，是可以完成拷贝的工作的\n但是malloc和new创造的空间是在堆区上的，无法直接拷贝\n\n如何解决这个问题呢？我们需要使用深拷贝\n\n了解new和delete\n从C语言转到C++，多了new和delete关键字，它们分别对应malloc和free\nint main()&#123;    int*p1=new int;//开辟一个int类型的空间    int*p2=new int(10);//开辟一个int类型的空间，并初始化为10    int*p3=new int[10];//开辟10个int类型的空间    //注意后两个的括号区别！        delete p1;//销毁p1指向的单个空间    delete p2;//同上        //delete p3;//销毁p3指向的第一个空间，不能用于数组    delete[] p3;//销毁p3指向的数组        return 0;&#125;\n\n深拷贝实现\n在上面写道过，编译器会自动生成拷贝构造函数，完成值拷贝工作。但是队列的代码里面包含堆区的空间，需要我们正确释放。这时候就需要自己写一个拷贝构造完成深拷贝\n//拷贝构造Queue(const Queue&amp; q)&#123;    _a=new int[q._capa];//注意解引用    memcpy(_a, q._a, q._capa*sizeof(int));//拷贝内容    _size=q._size;    _capa=q._capa;&#125;\n\n用下面这个队列的代码来测试深拷贝\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;//测试是否调用        //_a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;        _a=new int[_capa];        for(int i=0;i &lt; _capa;i++)        &#123;            _a[i]=i+1;        &#125;    &#125;    //拷贝构造    Queue(const Queue&amp; q)    &#123;        cout&lt;&lt;&quot;Queue Copy&quot;&lt;&lt;endl;        _a=new int[q._capa];        memcpy(_a, q._a, q._capa*sizeof(int));        _size=q._size;        _capa=q._capa;    &#125;    void Print()    &#123;        cout&lt;&lt;&quot;this:&quot;&lt;&lt;this&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;_a:&quot;&lt;&lt;_a&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;        for(int i=0;i &lt; _capa;i++)        &#123;            cout&lt;&lt;_a[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    ~Queue()    &#123;        //析构函数        //free(_a);        delete[] _a;        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;int main()&#123;     Queue q1;    q1.Print();    cout&lt;&lt;endl;    Queue q2=q1;     q2.Print();    cout&lt;&lt;endl;    return 0;&#125;\n\n深拷贝效果\n先注释掉Queue的拷贝构造函数析构函数（不然会报错）\n看一看，发现在不写拷贝构造函数的时候，q2和q1的_a指向了同一个地址\n\n取消析构函数的注释，可以看到两次释放同一片空间，发生了报错\n\n如果我们把写好的深拷贝构造加上，就不会出现这个问题\n\n当你加上给_a里面初始化一些数据，以及打印_a数据的函数后，就可以看到，不仅q2的_a有了自己全新的地址，其内部的值也和q1一样了\n\n这样写出来的拷贝构造，即便把队列中的int* _a修改为char*或者其他类型，都能正确完成拷贝工作\n\n\n2.1.3 析构函数和构造函数相对应，析构函数是对象在出了生命周期后自动调用的函数，用来爆破对象里的成员（如进行free操作）\n生命周期是离这个对象最近的&#123; &#125;括号\n特性\n\n析构函数名是在类名前加~\n无参数，无返回值\n一个类只能有一个析构函数\n如果你没有自己写，编译器会自动生成一个析构函数\n\n和构造函数一样，编译器自己生成的析构函数不会处理内置类型；会调用外置类型的析构函数\n基本使用\n析构函数的定义和我们在外部写的Destroy函数一样，主要执行free（delete）操作\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue&quot;&lt;&lt;endl;//测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;    ~Queue()    &#123;        //析构函数        free(_a);        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;//测试调用    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n假设我们在main函数里面定义了两个对象，你能说出q1和q2谁先进行析构函数的调用吗？\n\n可以看到，先调用的是q2的析构函数\n\n因为在底层操作中，编译器会给main函数开辟栈帧\n栈遵从后进先出的原则，q2是后创建的，所以在析构的时候会先析构\n\n2.2 静态成员2.2.1 静态数据成员和普通的成员变量不同，静态成员变量不属于某一个对象，而是属于整一个类\nclass A&#123;//定义一个静态成员变量\tstatic int _a  &#125;;\n\n也因为这个特性，静态成员变量是不会被sizeof计入的\n什么时候会用到静态成员变量？比如当我们需要计算一个类究竟开辟了多少个对象的时候。如果使用普通成员变量，它的值是属于某一个对象的，无法完成正确的count计数。使用静态成员变量后，该变量的值不会因为定义多个对象而被重置。这时候，我们就可以在构造函数和拷贝构造函数里面，使用count++，来实现对类开辟对象个数的统计。\nclass STU&#123;public:    STU()    &#123;        count++;        //...    &#125;    STU(const STU&amp; d)    &#123;        count++;        //...    &#125;\t//声明一个静态成员变量\tstatic int count;  &#125;;int STU::count=0;//必须要在类外定义\n\n这时候，每次对象创建都会让conunt+1，我们可以通过下面两种方式访问来得到count的值\n\n通过指定类域来访问，STU::count\n通过对象来访问，STU s1; s1.count;\n\n如果想在类外直接访问静态成员变量，就不能用private，必须是公有权限\n\n2.2.2 静态成员函数如果把静态成员变量定义为公有，那么外部的所有函数都可以通过类域或者对象来访问这个静态成员变量，这时候就不利于我们程序的封装。所以我们可以借助静态成员函数来访问私有的静态成员变量\n#include &lt;iostream&gt;using namespace std;class STU&#123;public:    STU() &#123;        count++;    &#125;    STU(const STU&amp; d)&#123;        count++;    &#125;    static int GetCount() &#123;        return count;    &#125;private:    static int count;&#125;;int STU::count=0;int main()&#123;    STU s1;        cout&lt;&lt;&quot;通过对象s1访问    &quot;&lt;&lt;s1.GetCount()&lt;&lt;endl;    cout&lt;&lt;&quot;通过类域STU::访问 &quot;&lt;&lt;STU::GetCount()&lt;&lt;endl;        return 0;&#125;\n\n静态成员函数有下面几个特点\n\n类静态成员即可用类名::静态成员或者对象.静态成员来访问\n静态成员函数没有隐藏的this指针，不能访问任何非静态成员\n静态成员和类的普通成员一样，也有public、protected、private三种访问级别\n静态成员函数可以具有返回值\n\n\n2.3 常成员2.3.1 常数据成员有一部分数据成员，是一个定值。比如我们定义了某一个学科的类class MATH\nclass MATH&#123;  int piont=6.0;//数学的学分  &#125;;\n\n可以看到，作为一个学科，它的考试学分&#x2F;绩点是固定的。这时候我们不需要在后续修改这个学分的定义，就可以将它设置为const属性，避免被其他成员误修改\nclass MATH&#123;  const int piont=6.0;//数学的学分  &#125;;\n\n和普通成员和静态成员变量不同的是\n\n常成员变量必须在声明的时候初始化\n常成员变量不能在类外定义\n常成员变量只能在构造函数的初始化列表阶段进行定义\n\nclass MATH&#123;public:    MATH()        :score(6.0)//初始化列表处定义    &#123;        cout&lt;&lt;score&lt;&lt;endl;//打印测试    &#125;private:    const double score=0;//必须在声明的时候定义初值&#125;;\n\n2.3.2 常成员函数const修饰的类成员函数称之为const成员函数，即常成员函数。const修饰类成员函数，实际修饰的是该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改。\n基本的修饰方法如下，在函数的括号后加const即可\nvoid Print()const&#123;\tcout&lt;&lt;_year&lt;&lt;endl;&#125;\n\n实际修饰的是该函数隐含的this指针\nthis指针本身是Date*const类型的，修饰后变为const Date* const类型\nvoid Print(const Date* const this)&#123;\tcout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;&#125;\n\n2.3.2.1 实例-权限问题这么说好像有点迷糊，我们用实例来演示一下为什么需要const修饰成员函数\nclass Date&#123;public:    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;    &#125;private:    int _year;    int _month;    int _day;&#125;;\n\n假设我们需要在函数中调用Print函数，在main中是可以正常调用的\nint main()&#123;\tDate d1(2022,5,10);    d1.Print();    return 0;&#125;\n\n但当你用一个函数来进行这个操作的时候，事情就不一样了\nvoid TEST(const Date&amp; d)&#123;\td.Print();//d.Print(&amp;d) --&gt;const Date*&#125;int main()&#123;\tDate d1(2022,5,10);    d1.Print();//d1.Print(&amp;d1) --&gt;Date*    TEST(d1);        return 0;&#125;\n\n这时候我们进行了引用调用，因为在TEST中我们不会修改d1的内容，所以用const进行了修饰\n\n这时候TEST中的d.Print()函数调用，传入的是const Date*指针，指针指向的内容不能被修改\nmain中的d1.Print();函数调用，传入的是Date*指针\n\n于是就会发生权限冲突问题：\n\n这时候如果我们在函数后面加了const，就可以避免此种权限放大问题。这样不管是main函数还是TEST函数中对Print()函数的调用，就都可以正常打印了！\n总结一下：\n\nconst对象不可以调用非const成员函数（权限放大）\n非const对象可以调用const成员函数（权限缩小）\nconst成员函数内不可以调用其他非const成员函数（权限放大）\n非const成员函数可以独调用其他const成员函数（权限缩小）\n\n2.3.2.2 什么时候需要使用？众所周周知，const修饰指针有下面两种形式\n\n在*之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）\n在*之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）\n\nthis指针本身就是类型名* const类型的，它本身不能被修改。加上const之后，this指向的内容，既类里面的成员变量也不能被修改了。\n知道了这一点后，我们可以合理的判断出：只要是需要修改类中成员变量的函数，就不需要在()后面加const修饰\n如果一个函数中不需要修改成员变量，就可以加const进行修饰（最好加上，告知调用者该函数中不会修改成员变量）\n注意：如果你使用了声明和定义分离的写法来实现一个const成员函数，那么声明和定义的成员函数都需要加上const修饰\n2.3.2.3 出错情况这里有一点需要提醒的是，如果你对某一个函数进行了const修饰，那么这个函数里面包含的其他类里面的函数，都需要进行const修饰。不然就会报错\n\n出现该报错的情况如下\n\n这个情况也提醒我们，不能在const修饰的函数中，调用非const修饰的成员函数\n\n2.4 常对象和常引用2.4.1 常对象可以用const来修饰一个对象，称为常对象\nconst &lt;classname&gt; s1;&lt;classname&gt; const s1;\n\n在初始化设置完常对象后，该对象的内容就不能进行修改。我们可以通过这个对象来访问内部被const修饰的函数，且只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）\n\n常对象调用非const修饰函数会报错\n不能修改常对象中成员变量的值\n\nconst STU s1(&quot;小明&quot;, 15, 90.6);\n\n如果你想在定义const对象后依旧可以修改某一个成员变量的值，可以用mutable来修饰该成员变量，这样依旧可以修改这个值\nclass STU&#123;    mutable char *m_name;//mutable修饰的成员变量，在const对象中仍然可以被修改    int m_age;    float m_score;&#125;;\n\n如上面的name变量，即便定义了const对象，也可以对它进行修改\n\n\n2.4.2 常引用2.4.2.1 引用基本形式引用的基本方式如下\nint a=10;int&amp; b=a;int&amp; c=a;//同一个变量可以有多个别名//可以用两个不同的变量名引用同一个//但是引用了之后不可以更改对象\n\n此时的b和c都是a的别名，注意是别名！\n  \n可以用两个不同的变量名引用同一个变量，而且引用了之后不可以更改对象\n\n一个变量可以有多个引用\n指针可以更改指向的对象，引用不可以\n引用必须在定义的时候就初始化，不可以int&amp; b;\n\n\n比如你叫李华，有人叫你“小李”，还有人叫你“英语作文人”，这两个外号都是你的别名。指针并不是别名，指针是通过地址访问某个变量。而引用是给a变量起另外的两个名字，实际上b和c都可以当作a来使用\n编译运行代码，让编译器打印出这三者的地址，可以看到它们的地址是一样的，因为它们本来就是同一个变量的不同名字。\n\n指针变量的地址和指针变量所指向对象的地址是不同的，引用的类型必须和引用实体的类型相同，不能用int&amp;引用double类型\n\n\n2.4.2.2 引用的权限问题const常量\n引用可以引用常量，但是必须加const修饰\n\n基本的思路就是“权限可以缩小，但不可以放大”。\n\n在上面的代码中，a是一个可以修改的变量，但是const int&amp;d=a;中的d是不能修改，只可读取a的内容。\ne是不可修改的常量，所以我们不能用int&amp;来放大权限\n\nint和double相互引用\n在1.1中有提到，我们不能用int&amp;来引用double类型的变量，编译器会报错\n\n不过我们可以用const int&amp;类型来引用double，此时引用就不是简单的一个别名了。\n先来了解一下把double复制给int类型，这时候会产生“隐式类型转换”，h保存的是z的整数部分\n\n\n在这个过程中，编译器会产生一个临时变量存放z的整数部分，然后赋值给h\n\n临时变量具有“常性”，可读不可改\n\n而当我们用const int&amp;类型来引用double时，实际上引用的是编译器产生的临时变量，它是一个常量，所以我们需要用const int&amp;来引用\nconst int&amp; i=z;//这里的i是临时变量的别名//在引用的时候，创建了一个临时变量存放d的整数部分//i的地址和z不相同，且临时变量不会销毁，生命周期和i同步//生成的这个临时变量是常量，所以i的本质是引用了一个int类型cout &lt;&lt;&quot;i= &quot;&lt;&lt;i&lt;&lt;endl;cout &lt;&lt;&quot;&amp;i= &quot;&lt;&lt; &amp;i &lt;&lt;endl; cout &lt;&lt;&quot;&amp;z= &quot;&lt;&lt; &amp;z &lt;&lt;endl;//在c++中函数主要使用引用传参，后面会进一步学习\n\n一个非常直观的验证方法，就是打印一下，瞅瞅它们的地址是否相同。可以看到，i的值和h是相同的，因为它引用的就是那个存放了整数部分的临时变量，这个临时变量的地址和z不同\n\n2.5 this指针及工作原理2.5.1 特点当你用同样的图纸建了很多个屋子后，有没有想过应该如何区分它们呢？\nC++在设计这部分的时候，添加了一个this指针来解决这个问题：C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参 数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。\n\nthis指针的类型：类名* const \n只能在“成员函数”的内部使用 \nthis指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。 \nthis指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递\n\n2.5.2 显式使用this就用下面这个函数举例\nvoid Print()&#123;\tcout&lt;&lt;_name&lt;&lt;endl;\tcout&lt;&lt;_sex &lt;&lt;endl;&#125;\n\n实际上，在调用它的时候，编译器会做如下处理。因为只有这样，才能完整的区分两个不同的类。\nvoid Print(Student*const this)&#123;\tcout&lt;&lt;this-&gt;_name&lt;&lt;endl;\tcout&lt;&lt;this-&gt;_sex &lt;&lt;endl;&#125;\n\n进一步看看下面这个代码，可以帮助你理解this指针\nbool operator==(const Date&amp; d)&#123;       return _year == d._year           &amp;&amp; _month== d._month           &amp;&amp; _day == d._day;&#125;\n\n这是一个日期的比较函数，是操作符重载（后面会讲到）。你可以看到，这个函数我们传入了一个Date类型的引用，这是区别于this的另外一个类的对象。\n如果没有this，那就很难区分两个变量的_year，于是编译器会把它优化成下面这样，就不会存在无法区分的问题了\nbool operator==(Date*const this,const Date&amp; d)&#123;       return this-&gt;_year == d._year           &amp;&amp; this-&gt;_month== d._month           &amp;&amp; this-&gt;_day == d._day;&#125;\n\n2.5.3 空指针问题在程序中，访问NULL不会报错，但是解引用Null会报错\n#include&lt;iostream&gt;using namespace std;class ta&#123;public:    void Print()    &#123;        cout&lt;&lt;&quot;print ta&quot;&lt;&lt;endl;        //cout&lt;&lt;_a&lt;&lt;endl;//err    &#125;private:    int _a;&#125;;int main()&#123;    ta* p=nullptr;    p-&gt;Print();   //可以去访问空指针的函数   //因为函数只是去调用了类里面的Print函数   //同时传了一个p的this指针（空指针传参是不会报错的）   //但是如果你去访问p里面_a变量，就会报运行错误    return 0;&#125;\n\n2.6 类间关系2.6.1  友元关系友元分为友元函数和友元类。友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。\n2.6.1.1 友元函数友元函数相当于这个类的好朋友，它并不是类的成员函数，但是可以访问这个类的私有成员。友元函数没有this指针，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部明，声明时需要加friend关键字。\nclass DATE&#123; // 友元函数friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Date&amp; d);                                      friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Date&amp; d);&#125;;\n\n以&lt;&lt;和&gt;&gt;操作符重载为例，如果我们直接在类里面定义的话，使用这个重载的方式就会变成下面这样\nDATE d1;d1&lt;&lt;cout;d1&gt;&gt;cin;\n\n因为对于双目操作符，重载的时候，编译器是将第一个参数作为操作符的左值的。在类里面定义时，第一个操作数是隐含的this指针。即必须用对象名作为左操作数来进行使用。这样虽然也能完成既定任务，但这个使用方式未免太过奇葩了。\n定义为友元后，没有隐含的this指针，就可以使用cout&lt;&lt;d1这种正常的方式来调用这个操作符重载了\n\n一个函数可以是多个类的友元函数\n友元函数不能用const修饰\n友元函数可以在类定义的任何地方声明，不受类访问限定符限制\n友元函数的调用与普通函数的调用和原理相同\n\n\n2.6.1.2 友元类友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。 \n\n友元关系是单向的，不具有交换性：比如有A类和B类，在A类中声明B类为其友元类，那么可以在B类中直接访问A类的私有成员变量，但想在A类中访问B类中私有的成员变量则不行。 \n友元关系不能传递：如果B是A的友元，C是B的友元，则不能说明C时A的友元。\n\nclass B;//前置声明class A&#123;\t//声明友元类\tfriend class B;    private:    int _n;&#125;;class B&#123;public:    //可以在类里面通过对象访问A的非公有成员\tvoid Print()    &#123;        cout&lt;&lt;_a1._n&lt;&lt;endl;    &#125;private:    A _a1;&#125;;\n\n2.6.2 整体部分关系2.6.2.1 内嵌对象内嵌对象：在一个类中定义另外一个类的对象\n在一些应用场景中，我们会需要在一个类里面定义另外一个类的对象。如下面这道OJ题中，我们需要用两个队列的类来实现这里的MyStack。\n\nclass Queue&#123;  //队列的实现 &#125;;class MyStack &#123;public:    MyStack() &#123;    &#125;   //.....private:\tQueue q1;     Queue q2;&#125;;\n\n对于内部对象Queue，需要注意的有以下几点：\n\n内部对象属于外置类型，在对象实例化的时候，编译器会去调用Queue的构造函数\n不能在MyStack类中直接对Queue进行初始化\n\n如果在Queue中定义了有参的构造函数，需要在MyStack构造函数中的初始化列表处进行初始化操作\n2.6.2.2 组合聚合问题当一个类的对象拥有另一个类的对象时，就会发生类聚合：\n\n母类A的每一个对象中都会包含一个或多个B类的对象\n类组合是一种特殊的聚合形式，其中拥有者类控制被拥有者类对象的生命周期。\n\n依旧以上面的MyStack代码为例，当我们在里面定义了Queue对象q1和q2后，它们的生命周期和MyStack类对象的生命周期同步。MyStack类会先构造，然后构造q1和q2；q1和q2分别析构后，才会析构MyStack的类对象。\n2.6.2.3 内部类当定义内部类时，内部类默认为外部类的友元，可以直接访问外部类的非公有成员。但是内部类是一个独立的类，外部类不能访问内部类的非私有成员，也不能通过外部类的对象来访问内部类的成员。\nclass A&#123;public:    class B&#123;      void Prin(const A&amp; a1)      &#123;          cout&lt;&lt; a1._a &lt;&lt;endl;//可以直接通过对象来访问私有成员          cout&lt;&lt; count&lt;&lt;endl;//外部的静态成员可以直接访问          cout&lt;&lt; _b &lt;&lt;endl;      &#125;      int _b;      &#125;;private:    int _a;    static int count;&#125;;int A::count=0;\n\n2.6.3 继承派生关系2.6.3.1 基本用法继承和派生是父与子的关系，其中子类拥有父类成员的同时，还会拥有自己的成员\n\n继承是一个特殊的语法，用于多个类有公共部分的时候\n父类：基类\n子类：派生类\n\n//举例：网站的公共部分class ART &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;网站访问量&quot; &lt;&lt; endl;\t&#125;\tvoid func()//文章页面\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; endl;\t&#125;&#125;;class LINK &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们 &quot; &lt;&lt; &quot; 网站访问量&quot; &lt;&lt;endl;\t&#125;\tvoid func()//友链页面\t&#123;\t\tcout &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n在上面的情况中，ART和LINK类中都有网站的公共部分，这时候就出现了代码的重复。继承的出现就是用于解决这个问题的\n//下面使用继承的方式来写，WEB类是网站的公共部分class WEB &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;网站访问量&quot; &lt;&lt; endl;\t&#125;&#125;;//ART、LINK是两个子类，继承了WEB的公共部分//这样就减少了代码量class ART : public WEB&#123;public:\tvoid func()//文章页面\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; endl;\t&#125;&#125;;class LINK : public WEB &#123;public:\tvoid func()//友链页面\t&#123;\t\tcout &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n测试可以发现，ART和LINK作为派生类，在继承了基类WEB的成员的基础上，还拥有了它们独特的单独成员\n\n同一个类可以同时继承多个基类\nclass C : public A,public B&#123;//.....&#125;;\n\n2.6.3.2 权限问题继承有3中类型：public、private、protected。这里会显示出类中protected权限和private权限的区别\nclass A&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\n当我们分别用上面三种方式对类A进行继承的时候，得到的结果是不同的\n\n用什么继承方式，派生类中继承的成员就变成什么类型\n不管用什么继承方式，都无法访问基类中的私有成员\n\n\n2.6.3.3 同名问题当基类和派生类中出现同名成员函数或者同名成员变量时，会出现冲突。这时候编译器会做一定的处理：直接访问变量名和函数名的时候，优先访问派生类自己的成员\n//继承同名成员的处理//\t普通的同名成员class DAD1 &#123;public:\tDAD1()\t&#123;\t\t_a = 100;\t&#125;\tvoid func()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;DAD func&quot; &lt;&lt; endl;\t&#125;\tvoid func(int i)\t&#123;\t\tcout &lt;&lt; &quot;DAD func int: &quot; &lt;&lt; i &lt;&lt; endl;\t&#125;\tint _a;//基类中的该变量&#125;;class SON1 : public DAD1&#123;public:\tSON1()\t&#123;\t\t_a = 20;\t&#125;\tvoid Print()\t&#123;\t\tcout &lt;&lt;&quot;SON: &quot; &lt;&lt; _a &lt;&lt; endl;//优先访问派生类的_a\t\tcout &lt;&lt;&quot;DAD: &quot; &lt;&lt; DAD1::_a &lt;&lt; endl;//访问基类的_a\t&#125;\tvoid func()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;SON func&quot; &lt;&lt; endl;\t&#125;\tint _a;//派生类的同名变量&#125;;\n\n\n如果是静态成员，访问方法就有所变化\n//访问同名的静态成员class DAD2&#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1 &quot; &lt;&lt; endl;\t&#125;\tstatic void Test1(int n)\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1(int)  &quot; &lt;&lt; n &lt;&lt; endl;\t&#125;&#125;;int DAD2::D_a = 100;class SON2 : public DAD2 &#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;SON2 Test1 &quot; &lt;&lt; endl;\t&#125;&#125;;int SON2::D_a = 200;\n\n\n2.6.3.4 虚继承有的时候，继承会出现下面这种情况：一个子类继承了两个基类，而这两个基类又同时是一个基类的派生类\n\n这时候，D里面就会有两份A的内容，相当于两份公共部分。这是我们不想看到的，因为会造成空间浪费。而且直接访问的时候，编译器会报错“对变量X的访问不明确”\n\n和前面说道的同名问题一样，我们可以指定作用域来访问特定的变量，但是这样是治标不治本的方法，并没有解决空间浪费的问题。\n//解决方法1（治表不治本）//用类域来修改和访问cout &lt;&lt; &quot;intel: &quot; &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;cout &lt;&lt; &quot;amd: &quot;   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;\n\n这就需要我们使用虚继承来操作：给B和C对A的继承加上virtural关键字\nclass CPU &#123;public:\tCPU()\t\t:_Structure(&quot;x86&quot;)\t&#123; &#125;\tchar _Structure[100];&#125;;class INTEL : virtual public CPU &#123;public:\tINTEL()\t\t:i_Brand(&quot;intel&quot;)\t&#123;&#125;\tchar i_Brand[10];&#125;;class AMD : virtual public CPU &#123;public:\tAMD()\t\t:a_Brand(&quot;amd&quot;)\t&#123;&#125;\tchar a_Brand[10];&#125;;\n\n这时候直接访问变量就不会报错了。因为这时候，B和C中的该变量指向了同一个地址，修改操作会同步。\n\n2.7 多态性\n静态多态：运算符重载\n动态多态：派生类和虚函数组成的多态\n\n2.7.1 运算符重载2.7.1.1定义在讲解赋值运算符重载之前，我们可以来认识一下完整的运算符重载：C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。\n函数名为：关键字 operator运算符，如operator=\n函数原型：返回值类型 operator操作符(参数列表)，如Date operator=();\n下面有几点注意：\n\n重载操作符必须有一个自定义类型的操作数（即操作符重载对内置类型无效）\n不能通过其他符号来创建新的操作符\n对于类类型的操作符重载，形参比操作数少一个传参（因为有一个默认的形参this指针）\n这5个操作符是不能重载的：.*、::、sizeof、? :、.\n\n2.7.1.2基本使用以下是在全局定义的操作符重载，用于判断日期是否相等\nbool operator==(const Date&amp; d1, const Date&amp; d2)&#123;    return d1._year == d2._year;    &amp;&amp; d1._month == d2._month    &amp;&amp; d1._day == d2._day;&#125;\n\n当我们在main函数中使用d1==d2的时候，编译器就会自动调用该操作符重载\n当然，你也可以自己来传参使用，如if(operator==(d1,d2))\n但是这样非常不方便，和调用一个而普通函数没啥区别，压根算不上操作符重载。所以我们一般是在类里面定义操作符重载的\n\n当我们把它放入类Date中间，就需要修改成下面这样\nbool operator==(const Date&amp; d2)&#123;    return _year == d2._year;    &amp;&amp; _month == d2._month    &amp;&amp; _day == d2._day;&#125;\n\n编译器在调用的时候，会优化成下面这样\nbool operator==(Date* this, const Date&amp; d2)//显示调用为 d1.operator==(d2);\n而在main里面使用的时候，这个重载后的操作符和原本的使用方法完全相同\nDate d1(2022,6,1)Date d2(2022,5,1)d1==d2;//自动调用操作符重载d1.operator==(d2);\n\n\n2.7.1.3赋值运算符重载因为每一个类都有不同的成员，编译器不可能智能的进行赋值操作。这时候就需要我们自己写一个赋值运算符重载来进行赋值操作了\n以日期类为例，赋值操作其实就是把内置类型成员一一赋值即可\nDate&amp; operator=(const Date&amp; d)&#123;    if(this != &amp;d)//避免自己给自己赋值    &#123;        _year=d._year;        _month=d._month;        _day=d._day;    &#125;    return *this;&#125;\n\n编写赋值重载代码的时候，需要注意下面几点：\n\n返回值和参数类型（注意要引用传参，不然会调用拷贝构造）\n检测是否自己给自己赋值（避免浪费时间）\n因为返回的是*this，出了函数后没有销毁，所以可以用传引用返回\n一个类如果没有显式定义赋值运算符重载，编译器也会自己生成一个，完成对象按字节序的值拷贝。\n\n如果类中有自定义类型，编译器会默认调用它的赋值运算符重载\n2.7.1.4拷贝构造和赋值重载的调用问题当赋值操作符和拷贝构造同时存在的时候，什么时候会调用赋值，什么时候会调用拷贝构造呢？\n\n在这两个函数中添加cout进行打印提示，可以看到：\n\n如果对象在之前已经存在，就会调用赋值重载\n如果是一个全新的变量在定义的时候初始化，就调用的是拷贝构造\n\n\n2.7.2 虚函数2.7.2.1 基本使用以及动态多态虚函数，并不代表这个函数是虚无的。而表示这个函数在一定情况下会被替换（就好比继承中的虚继承问题）。要实现动态多态，就需要借助虚函数来实现。以下面这个动物说话的代码为例\n#include &lt;iostream&gt;using namespace std;class Animal &#123;public:\t//void Talk()\tvirtual void Talk()//虚函数\t&#123;\t\tcout &lt;&lt; &quot;Animal is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class CAT : public Animal&#123;public:\tvoid Talk()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;CAT is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class DOG : public Animal &#123;public:\tvoid Talk()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;DOG is talking&quot; &lt;&lt; endl;\t&#125;&#125;;//基类中不使用虚函数时，该函数的内容已确定//不管传参什么类，都会调用Animal自己的Talk函数//加上虚函数virtual后，会调用CAT和DOG的Talk函数void MakeTalk(Animal&amp; it) &#123;\tit.Talk();//调用对应的Talk函数&#125;\n\n当基类Animal中的Talk函数没有用virtual修饰时，不管给这个函数传参什么类的对象，它都会调用Animal自己的Talk函数\n\n当我们用虚函数进行修饰后，就会调用派生类CAT和DOG的Talk函数，这就实现了一个简单的动态多态。\n\n对于虚函数，有几点需要注意：\n\n当基类的指针或引用指向派生类的对象时，就会触发动态多态，派生类中的同名函数会覆写基类中的虚函数\n不能定义静态虚函数——因为静态函数是属于整个类的，而不是属于某一个对象\n不能定义虚构造函数——总不能用派生类的构造来覆写基类的构造吧？\n析构函数可以是虚函数\n\n2.7.2.2 虚析构函数有的时候，我们需要析构一个对象时，往往会给基类的析构函数加上virtual修饰，这样只要传派生类的对象给基类的指针&#x2F;引用，就可以直接调用派生类对应的析构函数，完成不同的析构操作。而不是都呆呆的调用基类的析构函数——那样就会产生内存泄漏\n#include&lt;iostream&gt;using namespace std;class Queue &#123;public:\tQueue()\t\t:_a(new int[10])\t&#123;\t&#125;\tvirtual ~Queue() &#123;\t\tcout &lt;&lt; &quot;~Queue&quot; &lt;&lt; endl;\t\tdelete[] _a;\t&#125;private:\tint* _a;&#125;;class MyStack :public Queue &#123;public:\tMyStack(int capa)\t\t:_a1(new int[capa])\t&#123;&#125;\t~MyStack() &#123;\t\tcout &lt;&lt; &quot;~MyStack&quot; &lt;&lt; endl;\t\tdelete[] _a1;\t&#125;private:\tint* _a1;&#125;;int main()&#123;\tQueue* q1=new MyStack(4);//父类指针指向子类\tdelete q1;//调用子类的析构函数，再调用父类析构\treturn 0;&#125;\n\n运行之后，可以看到，我们成功通过父类的指针，调用了子类的析构函数。子类的析构函数中本身就会自动调用父类析构函数。这样一来，子类和父类都被成功析构，不会出现内存泄漏\n$ ./test~MyStack~Queue\n\n如果去掉父类析构函数的virtual关键字，则只析构父类\n$ ./test~Queue\n\n\n2.7.3 纯虚函数在虚函数的基础上，C++定义了纯虚函数：有些时候，在基类里面定义某一个函数是没有意义的，这时候我们可以把它定义为纯虚函数，具体的实现让派生类去同名覆写。\n纯虚函数的基本形式如下\n//virtual 函数返回类型 函数名()=0;virtual void Print()=0;\n\n派生类中必须重写基类的纯虚函数，否则该类也是抽象类\nclass A &#123;public:\t//virtual void Print();//虚函数\tvirtual void Print() = 0;//纯虚函数&#125;;class B :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;B print &quot; &lt;&lt; endl;\t&#125;&#125;;class C :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;C print &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n当我们在派生类中覆写了该函数后，即可实例化对象并调用该函数\n\n和虚函数一样，使用基类的引用或指针来接收派生类的对象，即可调用对应的函数\n\n2.7.4 抽象类包含纯虚函数的类就是抽象类，抽象类有下面几个特点：\n\n抽象类无法实例化对象\n抽象类的派生类必须重写基类的纯虚函数，不然派生类也是抽象类\n如果在基类中定义的纯虚函数是const修饰的，则派生类中对应的函数也需要用const修饰\n\n\n第三章  面向对象应用3.1 矩阵类设计及应用\n矩阵类要求：设计一个矩阵类，要求能够根据用户需求构建row行、column列的矩阵，并灵活接受反馈矩阵元素信息（如：某行、某列、某行某列元素）。实现矩阵的相关运算，包括矩阵加（+）、矩阵乘（*）、矩阵输出（&lt;&lt;）、矩阵赋值（&#x3D;）、获取矩阵指定位置元素值（[]）\n\n设计该程序的时候，需要注意下面几点：\n\n重载矩阵类必须使用二维数组，不能用一维数组+公式判断的方法（因为这样无法重载[]操作符）\n重载矩阵加减和相乘的运算符时候需要注意矩阵运算的规则（第一行x第一列&#x3D;第一个）\n\n\n\n对于+和-的重载不应该修改原本的矩阵，应该创建临时对象tmp后，修改tmp的值并返回\n\nint a1=1,a2=2;a1+a2;//这样相加并不会影响a1和a2的值\n\n如果需要修改原本的矩阵，应该重载的操作符是+&#x3D;和-&#x3D;\n\n对于矩阵输出&lt;&lt;的重载，必须使用友元函数，否则使用会变成对象&lt;&lt;cout，不是正常使用的方法\n对于获取矩阵指定位置元素值[]的重载，应该返回int*类型。在最开始设计的时候我错误写成了int类型，无法正确地连续使用两个[]\n\n//重载[]操作符int* operator[](int row)&#123;    return arr[row];&#125;//使用该操作符a1[1][3];//第一个[]是操作符重载a1[1];//返回了第二行的数组名//第二个[]是普通的操作符本身，访问返回的数组名找到对应列的值\n\n矩阵类完整代码实现见附录。\n3.2 银行账户管理系统设计及应用\n银行账号管理系统要求：管理不同用户在银行的金融资产，每个用户可以拥有多种银行账户（如：定期储蓄、活期储蓄、信息卡、电子账户、贷款账户等）。账户包括账号、余额、利率等基本信息，用户可以进行账户信息查询、存款、取款、结算利息等操作。银行需统计所有账户的总金额、验证银行系统收支平衡，并能够及时预警反馈。设计Account抽象类作为所有银行账户顶层祖先，根据实际应用需求合理设置派生层次及相应子类。结合银行利息结算、用户贷款申请等实际应用需求，适当添加辅助类协同操作。合理定义虚基类、虚函数、纯虚函数、抽象类完成银行账号管理系统的稳定可靠运行。\n\n3.2.1 基本思路以下是我设计该管理系统的思路：\n\n设计了Account类的主框架，作为后续类的基类\n通过多态，实现了活期储蓄、定期储蓄类、信用卡类、贷款账户的功能\n实现了简易菜单，通过switch case语句和do while语句实现多次调用不同函数接口的操作\n与日期类结合，实时计算天数差距并结算利息\n\n在设计该菜单的过程中，我发现了很多问题需要注意，这些问题也加深了我对编程知识点的理解。\n完整代码实现见附录。\n3.2.2 设计系统时遇到的问题在设计贷款账户的时候，容易出现double浮点数存放精度的问题。用户贷款额度和余额直接若直接判断相等，很难得到正确结果（因为浮点数后面会跟着很多没有打印出来的小数）\n\n这就会出现，即便你根据程序接口中“查看待还金额”来得到自己的待还金额，并执行还款操作后，还是会有一部分小数位的数据并没有完整还完，这一部分的处理是非常困难的。为了避免用户永远都还不完自己的贷款，我设置了double的修约规则，即当用户余额和贷款&#x2F;透支额度的差值小于0.2时，不再处理后续的小数位\nif (_Max - _money &lt; 0.2)//浮点数精度问题&#123;    cout &lt;&lt; &quot;无需还款&quot; &lt;&lt; endl;    return -1;&#125;\n\n同时在余额计算中进行取零修约，保证“剩余待还”打印值和“查看待还金额”函数的打印值同步。用这种方式间接解决了精度问题。\n//待还金额为透支额度+利息double money = (_Max - _money) + Income(tmp);if (money &lt; 0.02) &#123;\tmoney = 0;//修约浮点数，解决精度问题&#125;\n\n在设计销户接口时，为了避免用户在销户后仍然能操作该账户，不能只是简单的使用break跳出单层循环，而是需要用return直接终止该程序。\ncase 8:&#123;    cout &lt;&lt; &quot;销户后，账户内的一切信息都会被清空&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;请问您确认销户吗？Y/N&quot; &lt;&lt; endl;    char a;    cin &gt;&gt; a;    if (a == &#x27;Y&#x27;) &#123;        delete A;        A = nullptr;        cout &lt;&lt; &quot;销户完成&quot; &lt;&lt; endl;        return;//终止程序    &#125;    break;&#125;\n\n3.2.3 一些缺陷1.文件操作\n该银行管理类还可以添加文件操作，来保存用户的信息。原先想法是在Account类中定义static全局变量进行count++，以此得出所有派生类构造对象的总和。再利用for循环进行读取文件操作，这样就能在下一次打开程序的时候，通过用户的账户来定位用户的某一个特定账户对象，进行后续的操作。\n但是Account类作为抽象类是无法实例化对象的，如果用各个派生类来进行文件管理操作，该程序就会变得很臃肿。且由于本人能力问题，没能设计出循环读取文件内容，并进行定位下一个对象位置的操作，故在最终的设计中没有实现文件操作。\n2.时间问题\n为了代码测试需要，每一次操作都需要用户手动输入日期。在实际应用中，这项工作应该由银行用户终端自动化承担。可以设计读取预定义宏__TIME__来获取每一次操作的时间，从而实现和现实中的时间对照，去除每一次都需要手动输入代码的繁琐\n第四章  面向对象程序设计学习总结学习代码需要有一个持之以恒的心，再学习知识点的基础上要同时坚持写代码的练习。我在Gitee码云上创建了自己的学习仓库，坚持每天托管代码，作为自己学习编程打卡的一个记录\n\n和其他科目不同，CPP的学习是不能只停留在书籍和纸笔上的，只有你上手自己敲代码了，才能认识到一些光是听讲和看书学习不到的知识。比如一些程序出现bug之后的VS调试技巧，都是我在练习中学会的。\n\n同时还需要学会利用工具，如在cplusplus网站上查找函数的定义，根据给出的代码示例尝试自己使用这个函数，并做到能在后面的程序设计中活学活用。\n个人认为，不管学习的编程语言是什么，只有综合以上几点，才能真正学好编程。\n附录\n矩阵类和银行管理系统完整代码👉【传送门】\n部分资料参考C语言中文网👉http://c.biancheng.net/\n\n","categories":["遇见C++"],"tags":["Linux","C++","类和对象"]},{"title":"【C语言】数据结构-链式二叉树，详解分治递归和层序遍历","url":"/posts/2357097133/","content":"[TOC]\n前言在之前关于树的学习中，我们接触了二叉树的知识点，以及堆和堆排序的操作。\n\n两个知识点都是超链接，可以点击查看我之前的博客，复习一下这两个知识点哦！\n\n\n接下来我们要更进一步，学习一下链式二叉树的操作\n本篇博客将以知识点讲解+OJ题目验证的方式来展开链式二叉树的内容\n\n1.链式二叉树的基本结构在学习链式二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。\n之前我们提到过，树最优的表示方法是父母孩子表示法。但是对于二叉树这种度固定的树来说，可以 直接使用最简单的方法，定义两个指针指向它的左右叶子节点即可\ntypedef int BTDataType;typedef struct BTreeNode&#123;\tBTDataType data;\tstruct BTreeNode* left;\tstruct BTreeNode* right;&#125;BTNode;\n\n这里要说明的一件事是：普通树的“增删查改”操作是没有意义的，因为树并不是一个最优的储存结构。所以我们学习链式二叉树的操作时，更多学习的是分治 递归思想\n\n2.分治递归思想什么是分治思想？\n举个例子，学校里面需要进行排查，找出本校里面身高最高的人。这时候校长可以去找各个年级的级组长，然后级组长去找各个班主任，班主任让班级里面的小组长统计组员身高数据。\n这时候的小组长已经可以返回一个身高最高的值给班主任了，然后再层层上报，校长只需要在最后上报的4个数据中找出一个最高的，即为本校最高的同学\n\n分治策略的思想就是分而治之，即先将一个规模较大的大问题分解成若干个规模较小的小问题，再对这些小问题进行解决，得到的解，在将其组合起来得到最终的解。在上面的例子中，较小的问题就是小组长统计组员身高，并上报。转换成代码语言就是return一个值\n\n更详细的解释可以参考这篇大佬的博客👇\n五大常见算法策略之——递归与分治策略\n\n早先学习的递归求斐波那契数就运用了分治的思想👉传送门\nint fo2(int a)&#123;\tif ((a == 1) || (a == 2))\t\treturn 1;\telse\t\treturn (fo2(a - 1) )+( fo2(a- 2));//n-1和n-2项&#125;\n\n当a&#x3D;1或者2的时候，就是分治的末端节点，通过return 1开始终止递归\n\n3.前&#x2F;中&#x2F;后序遍历了解了上面所说的分治递归思想后，接下来我们再学习链式二叉树的三种遍历方式\n\n前序遍历：根节点-左子树-右子树\n中序遍历：左子树-根节点-右子树\n后序遍历：左子树-右子树-根节点\n\n从前序遍历入手，我们来实操一下分治的思想：利用递归，以前序遍历的顺序打印出树中节点的值\n假设我们现在创建了一个这样的简单二叉树👇你能想出来前序遍历的打印顺序应该是咋样的吗？\n\n答案是1 2 3 4 5 6\n看到这里，你肯定一脸懵逼：啊，咋出来的？\n\n不着急，我们现给打印出来的内容加上它们的末端子树NULL，所以前序遍历的结果是：\n1 2 3 NULL NULL NULL 4 5 NULL NULL 6 NULL NULL\n\n不卖关子啦，直接下手分析这个遍历结果是怎么出来的！\n前面提到了，前序遍历的顺序是：根节点-左子树-右子树\n\n下图能让你更直观地看出来这三种遍历方式的不同\n\n其中前序遍历转换为代码语言就是下面这样\n// 二叉树前序遍历 void BTreePrevOrder(BTNode* root)&#123;\tif (root == NULL)\t&#123;//为了方便理解，把空节点也打印出来\t\tprintf(&quot;NULL &quot;);\t\treturn ;\t&#125;\tprintf(&quot;%d &quot;, root-&gt;data);\tBTreePrevOrder(root-&gt;left);\tBTreePrevOrder(root-&gt;right);&#125;\n\n在这之中，遇到根节点是NULL的情况，就是分治的末端情况，递归停止\n这样说来恐怕还是不清楚，要彻底弄清，我们必须要通过画递归示意图来解决\n\n图中某个单词打错了，画到一半才发现……请忽略它！😭\n\n如果你能理解上图中前序遍历的思路，那中序遍历和后序遍历的操作就非常简单了！猜猜怎么修改前序的代码呢？\n没错，只需要更改一下printf的位置就可以了！\n// 二叉树中序遍历void BTreeInOrder(BTNode* root)&#123;\tif (root == NULL)&#123;\t\tprintf(&quot;NULL &quot;);\t\treturn;\t&#125;\t\tBTreeInOrder(root-&gt;left);\tprintf(&quot;%d &quot;, root-&gt;data);\tBTreeInOrder(root-&gt;right);&#125;// 二叉树后序遍历void BTreePostOrder(BTNode* root)&#123;\tif (root == NULL)&#123;\t\tprintf(&quot;NULL &quot;);\t\treturn;\t&#125;\tBTreePostOrder(root-&gt;left);\tBTreePostOrder(root-&gt;right);\tprintf(&quot;%d &quot;, root-&gt;data);&#125;\n\n最后打印出来的结果分别是这样的，和上面的示意图完全对应！回到示意图\n\n\n3.1通过递归遍历计算节点个数上面的递归，我们打印出了各个节点的值\n只需要对其中一个递归的代码进行小修改，将printf改成计数++，就能把它从遍历变成计算二叉树的节点个数\n这里我选择指针变量的方式让主函数中能获取计数的结果\n// 二叉树节点个数void BTreeSize(BTNode* root,int* pcount)&#123;\tif (root == NULL)\t\treturn ;\t\t(*pcount)++;//指针变量，main函数中可调用\tBTreeSize(root-&gt;left,pcount);\tBTreeSize(root-&gt;right,pcount);&#125;\n\n\n你可以使用全局静态变量来进行计数，但是那样的计数会在下一次调用的时候叠加，需要在调用后置0，非常不方便\n\n\n当然，我贴出来的这个方法也不是最优的，因为它需要创建一个额外的变量count作为参数调用，而不能直接return节点的数量\n\n所以就有了下面这个使用三目操作符? :来进行分治递归，计算节点个数\n\n其中根节点为空是末端情况，返回0\n其他情况返回左子树和右子树的节点大小+1（该节点自己）\n\n//进阶方法int BTreeSize(BTNode* root) &#123;\treturn root == NULL ? 0 :\t\tBTreeSize(root-&gt;left)\t\t+ BTreeSize(root-&gt;right) + 1;&#125;\n\n3.2 用后续遍历的思想销毁树当我们不需要用二叉树后，需要将其调用的内存释放\n问题就来了，如果你释放了根节点，那要咋找到它的左右子树呢？\n所以我们在释放的时候，要用后序遍历的顺序来进行释放，即先销毁左右子树，再向上销毁。这样就能避免找不到子树的问题\n// 二叉树销毁void BTreeDestory(BTNode** root)&#123;\tif (*root == NULL)\t\treturn;\t//通过后续遍历的思想来摧毁树\tBTreeDestory(&amp;(*root)-&gt;left);\tBTreeDestory(&amp;(*root)-&gt;right);\tfree(*root);\t*root = NULL;//使用二级指针可以直接在函数中置空根节点的指针&#125;\n\n3.3前&#x2F;中&#x2F;后序遍历OJ题\n三道Leetcode OJ题\n\n144. 二叉树的前序遍历\n145. 二叉树的后序遍历\n94. 二叉树的中序遍历\n\n\n这里只对前序遍历的题目做出讲解，因为后面两个的思路完全一致，只需稍微更改代码\n\n题目给出一个树，需要你将它以前序遍历的顺序，将各个节点的值保存在一个数组中并返回它\n\n这里的输入用例是“伪代码”，[1,null,2,3]代表1的左子树是NULL，右子树是2；2的左子树是3，右子树是NULL\n\n既然需要用数组来储存，首先我们需要知道这个二叉树一共有几个节点，这样才能方便我们开辟数组\n\n注意：这种接口型题目，数组都必须是动态内存函数malloc开辟的\n\n\n然后把前序遍历中的printf改成将值放入arr数组中即可！\n// 二叉树节点个数void BTreeSize(struct TreeNode* root,int* pcount)&#123;\tif (root == NULL)\t\treturn ;\t\t(*pcount)++;\tBTreeSize(root-&gt;left,pcount);\tBTreeSize(root-&gt;right,pcount);&#125;// 前序遍历代码void BTreePrevOrder(struct TreeNode* root,int*arr,int* i)&#123;\tif (root == NULL)&#123;\t\treturn ;\t&#125;\t    arr[(*i)++]=root-&gt;val;    //因为在递归调用中需要多次调用不同的i，所以需要取地址\tBTreePrevOrder(root-&gt;left,arr,i);\tBTreePrevOrder(root-&gt;right,arr,i);&#125;int* preorderTraversal(struct TreeNode* root, int* returnSize)&#123;    int count=0;    BTreeSize(root,&amp;count);//计算树节点个数    int* arr=(int*)malloc(sizeof(int)*count);//开辟数组    int i=0;//下标    BTreePrevOrder(root,arr,&amp;i);    *returnSize=count;    return arr;&#125;\n\n\n\n4.计算节点个数在3.1中已经讲述了计算二叉树节点个数的方法，下面是更细致的节点个数计算\n4.1叶子节点个数众所周知，在这颗二叉树中，只有3、5和6是叶子节点\n\n想要判断一个节点是不是叶子节点，其实非常简单：只要它的左右子树都是空，就是叶子节点了。\n\n以此作为分治的末端条件，只要满足这个条件，就返回1\n如果已经遍历到空节点了，返回0\n其他情况，返回左子树和右子树的叶子节点个数之和\n\n// 二叉树叶子节点个数int BTreeLeafSize(BTNode* root)&#123;\tif (root == NULL)\t\treturn 0;\tif (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\t\treturn 1;\treturn BTreeLeafSize(root-&gt;left) + BTreeLeafSize(root-&gt;right);&#125;\n\n4.2二叉树第k层节点个数假设根节点是第1层，要想知道第k层一共有几个节点，需要怎么设计函数呢？\n\n先来这么想：3所在层数对于根来说是第三层，但是对于2来说是第二层，对于3自己来说是第1层\n那么，我们是不是可以让第k层往下-1来进行递归呢？\n\n// 二叉树第k层节点个数int BTreeLevelKSize(BTNode* root, int k)&#123;\tassert(k &gt;= 1);//保证k&gt;=1\tif (root == NULL)\t\treturn 0;\tif (k == 1)\t\treturn 1;\treturn BTreeLevelKSize(root-&gt;left,k - 1)        + BTreeLevelKSize(root-&gt;right,k-1);&#125;\n\n\n\n4.3二叉树的深度在之前树的概念学习中，讲解过树的深度（即树一共有几层）\n深度和之前举例的校长统计身高很相似，我们需要找出左右子树中较深的那一个并进行返回。末端的条件，就是节点为空的时候，return 0终止递归 \n// 二叉树深度，即一共有几层int BTreeDepth(BTNode* root)&#123;\tif (root == NULL)\t\treturn 0;\tint left = BTreeDepth(root-&gt;left);\tint right = BTreeDepth(root-&gt;right);\treturn left &gt; right ? left + 1 : right + 1;&#125;\n\n注意：这里left+1和right+1是为了计算上节点自己\n求二叉树深度OJ题leetcode上有一道oj题就是求二叉树的最大深度，代码复制上，改个名，搞定！\n\n题目链接：104. 二叉树的最大深度\n\n\n\n5.查找树中值为x的节点在二叉树中查找一个值，基本思想就是把它遍历一遍，判断根节点以及左右子树中是否有x值的节点。\n具体的解析，写道下面的代码注释里啦！\n// 二叉树查找值为x的节点BTNode* BTreeFind(BTNode* root, BTDataType x)&#123;\tif (root == NULL)\t\treturn NULL;//节点为空返回空\tif (root-&gt;data == x)\t\treturn root;//节点自己就是x，返回节点自己的地址\tBTNode* ret1 = BTreeFind(root-&gt;left, x);\tif (ret1 != NULL)//如果左边找到了，返回左节点的地址\t\treturn ret1;\tBTNode* ret2 = BTreeFind(root-&gt;right, x);\tif (ret2 != NULL)//如果右边找到了，返回右节点的地址\t\treturn ret2;\treturn NULL;//两个都找不到，它自己也不是，返回空&#125;\n\n6.层序遍历如同其名，层序遍历就是一层一层地遍历\n\n比如上面这棵树，层序遍历的结果如下\n1 2 4 3 NULL 5 6\n\n要想实现层序遍历，我们需要借助之前学习的栈和队列知识里的队列👉传送门\n在VS项目里面，导入预先写好的队列的头文件和源文件，再引用它就可以了！\n\n这里就能体现出之前预先typedef类型的作用了：只需要更改最先的数据类型，就可以搞定后面的一切！\n\n而引用头文件的时候，因为我们需要在栈的代码中使用二叉树的定义，所以需要先引用二叉树的头文件，再引用队列的头文件\n\n搞定这个后，我们再来讲述一下层序遍历的思路\n\n先插入根节点，然后在根节点出队列的同时，插入它的左右子树的节点\n当队列中的值都为NULL时，代表层序遍历完成\n\n\n所以我们需要入队列的不是节点的值，因为那样无法找到节点的左右子树。入队列的是节点的地址！\n// 层序遍历void BTreeLevelOrder(BTNode* root)&#123;\tQueue q;\tQueueInit(&amp;q);\tif (root != NULL)&#123;//根节点非空，开始入队列\t\tQueuePush(&amp;q, root);\t&#125;\twhile (!QueueEmpty(&amp;q))\t&#123;\t\tBTNode* head = QueueFront(&amp;q);//取队头数据\t\tQueuePop(&amp;q);//出队列\t\tprintf(&quot;%d &quot;, head-&gt;data);\t\tif (head-&gt;left != NULL)\t\t&#123;\t\t\tQueuePush(&amp;q, head-&gt;left);\t\t&#125;\t\tif (head-&gt;right != NULL)\t\t&#123;\t\t\tQueuePush(&amp;q, head-&gt;right);\t\t&#125;\t\t//层序遍历不需要递归，可以用循环解决问题\t&#125;\tprintf(&quot;\\n&quot;);\tQueueDestory(&amp;q);//防止内存泄漏\treturn;&#125;\n\n遍历的结果如下\n\n6.1判断二叉树是否为完全二叉树学习了层序遍历后，就可以来判断一个二叉树是否为完全二叉树了！\n完全二叉树：前k-1层为满二叉树，最后一层不满，但是从左到右分布\n\n具体的思路是\n\n当队列中的队头为NULL时开始遍历，如果队列中都是NULL，代表是满二叉树\n如果有非空节点，就不是满二叉树\n\n// 判断二叉树是否是完全二叉树bool BTreeComplete(BTNode* root)&#123;\tQueue q;\tQueueInit(&amp;q);\tif (root != NULL) &#123;\t\tQueuePush(&amp;q, root);\t&#125;\twhile (!QueueEmpty(&amp;q))\t&#123;\t\tBTNode* head = QueueFront(&amp;q);//取队头数据\t\tQueuePop(&amp;q);//出队列\t\tif (head == NULL)&#123;\t\t\tbreak;//遇到队列中空节点，退出循环\t\t&#125;\t\tQueuePush(&amp;q, head-&gt;left);\t\tQueuePush(&amp;q, head-&gt;right);\t&#125;\twhile (!QueueEmpty(&amp;q))\t&#123;\t\tBTNode* head = QueueFront(&amp;q);//取队头数据\t\tQueuePop(&amp;q);//出队列\t\tif (head != NULL)\t\t&#123;\t\t\t//printf(&quot;不是完全二叉树\\n&quot;);\t\t\treturn false;\t\t&#125;\t&#125;\tQueueDestory(&amp;q);//防止内存泄漏\treturn true;&#125;\n\n结语链式二叉树的内容到这里就结束啦！\n如果博客里面有讲的不清楚的地方，欢迎大家在评论区提出哦！\n\n下篇博客将讲解一些有关二叉树的OJ题和概念选择题！我们不见不散哦~\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","树","链表"]},{"title":"【C语言】带你用偷懒的方式刷爆二叉树OJ题","url":"/posts/4165981723/","content":"[TOC]\n前言上篇博客我带大家领略了一番链式二叉树的操作，现在让我们来看看二叉树的相关题目，一起来巩固一下知识点吧！\n\n\n点我复习上一篇博客的内容！👉传送门\n\n1.一些选择题1.1设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（ ）个A.11B.12C.13  √D.14\n\n\n设Ni表示度为i的节点个数，则节点总数 N &#x3D; N0 + N1 + N2\n节点个数于节点边的关系： N个节点的树有N-1个边\n边与度的关系：N - 1 &#x3D; N1 + 2 * N2\n故：N0 + N1 + N2 - 1 &#x3D; N1 + 2 * N2\n因此，得：N0 &#x3D; N2 + 1\n回到原题，N0 &#x3D; 3，N1 &#x3D; 8，可得N2 &#x3D; 2\n因此答案是 3 + 8 + 2 &#x3D; 13\n\n1.2有N个元素的完全二叉树的深度是()答案：logN+1\n\n高度为h的完全二叉树，节点个数在： 2^(h - 1) - 1 &lt; n &lt;= 2^h - 1\n即log(n + 1) &lt;= h &lt; log(n + 1) + 1\n这里需要注意的是n左右区间的开闭问题\n完全二叉树最少的节点个数是2^(h - 1)-1+1个，所以是n&gt;2^(h - 1) - 1\n\n1.3 由已知遍历序列画出原本树的结构已知某二叉树的中序遍历序列为JGDHKBAELIMCF，后序遍历序列为JGKHDBLMIEFCA，则其前序遍历序列为（ ）A.ABDGHJKCEFILMB.ABDGJHKCEILMF   √C.ABDHKGJCEILMFD.ABDGJHKCEIMLF\n\n这道题我刚开始的思路是错的，因为我把它当作完全二叉树来看待，但题目并没有说它是完全二叉树\n\n主要思路：可以从后续遍历确定根节点为A，中序遍历可以确定A的左右子树。再继续从后序遍历中确定A左右子树的根节点，依次往下判断\n\n所以我画了一个分析图，如下👇\n\n已知某二叉树的前序遍历序列为ABDEC，中序遍历序列为BDEAC，则该二叉树（ ）A.是满二叉树B.是完全二叉树，不是满二叉树C.不是完全二叉树   √D.是所有的结点都没有右子树的二叉树\n\n这道题的思路和上一道题是一样的\n\n已知某二叉树的前序遍历序列为5 7 4 9 6 2 1，中序遍历序列为4 7 5 6 9 1 2，则其后序遍历序列为（ ）A.4 2 5 7 6 9 1B.4 2 7 5 6 9 1C.4 7 6 1 2 9 5  √D.4 7 2 9 5 6 1\n\n本题依旧和上面两道题思路相同！\n\n1.4 单边树一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（ ）A.所有的结点均无左孩子B.所有的结点均无右孩子C.只有一个叶子结点D.至多只有一个结点\n\n如果前序遍历和后序遍历序列正好相反，说明它是一个单边树，比如下面这前序和中序序列所构成的树的结构:\n12345（纵向）\n54321\n对于单边树，只有一个叶子节点\n\n1.520.如果一颗二叉树的前序遍历的结果是ABCD，则满足条件的不同的二叉树有（ ）种A.13B.14 √C.15D.16\n\n\n首先这棵二叉树的高度一定在3~4层之间:\n三层：\nA(B(C,D),()), A((),B(C,D)), A(B(C,()),D), A(B((),C),D),\nA(B,C(D,())), A(B,C((),D))\n四层：\n如果为四层，就是单边树，每一层只有一个节点，除过根节点，其他节点都有两种选择，在上层节点的左边还是右边，所以222共8种\n总共为14种。\n\n\n2.OJ题刷起来！KY11 二叉树遍历\n牛客网 KY11 二叉树遍历 👉传送门\n\n\n这道题要求我们用先序遍历的操作从一个数组中读出一个树，并构建出树的基本结构，再用中序遍历的方式打印出这颗树\n之前我们学习了前序遍历的操作，这里只需要把前序遍历中的printf操作改成构建新树即可\n\n因为涉及道i的多次调用，所以函数中的i需要取地址，必须保证多次调用的i会同步++\n构建完树的节点，并赋值后，需要递归构建左右子树，最后返回节点的地址\n题目中的#代表NULL，直接return空即可\n\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;typedef char BTDataType;typedef struct BTreeNode&#123;\tBTDataType data;\tstruct BTreeNode* left;\tstruct BTreeNode* right;&#125;BTNode;// 二叉树中序遍历 void BTreeInOrder(BTNode* root)&#123;\tif (root == NULL)&#123;\t\treturn ;\t&#125;\t\tBTreeInOrder(root-&gt;left);    printf(&quot;%c &quot;, root-&gt;data);\tBTreeInOrder(root-&gt;right);&#125;BTNode* CreatTree(char *arr,int*i)&#123;    if (arr[*i] == &#x27;#&#x27;)&#123;        (*i)++;\t\treturn NULL;\t&#125;        BTNode* newnode=(BTNode*)malloc(sizeof(BTNode));        newnode-&gt;data=arr[(*i)++];//i必须取地址    newnode-&gt;left=CreatTree(arr,i);//递归构建左子树    newnode-&gt;right=CreatTree(arr,i);//递归构建右子树        return newnode;&#125;int main()&#123;    char arr[100];    scanf(&quot;%s&quot;,arr);        int i=0;    BTNode* root=CreatTree(arr,&amp;i);    BTreeInOrder(root);    return 0;&#125;\n\n100 相同的树\nleetcode：100. 相同的树\n\n\n题目要求很简单，给定两颗树的根节点，要求我们判断这两棵树是否相同\n\n如果两棵树都为空，树相同\n如果其中一个为空，另外一个不为空，树不同\n如果两个都不为空，但是节点值不相同，树不同\n然后再递归判断左子树和右子树，将它们的结果与&amp;&amp;在一起，其中一个为假，返回假\n\nbool isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;    if(p==NULL&amp;&amp;q==NULL)//比较是否两个节点都为空，都为空是真        return true;        if(p==NULL||q==NULL)//如果有一个为空，另外一个非空，即为假        return false;    if(p-&gt;val!=q-&gt;val)//都不是空，判断val的值是否相等        return false;        //递归判断左子树和右子树是否相等    return isSameTree(p-&gt;left,q-&gt;left)        &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);&#125;\n\n\n学会这道题后，后面一些题目其实只需要把它的代码改一改就能用了😂\n什么？你不信？那就看看下面这道题！\n\n101 对称二叉树\nleetcode：101. 对称二叉树\n\n\n题目要求很简单哈，判断是不是两边对称的树\n这和判断树相等有什么区别呢？不就是把左右子树的判断改一下就行了嘛？\n直接调用上一题的代码！注意最后的return值，是p的左和q的右进行判断\nbool _isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;    if(p==NULL&amp;&amp;q==NULL)//比较是否两个节点都为空，都为空是真        return true;        if(p==NULL||q==NULL)//如果有一个为空，另外一个非空，即为假        return false;    if(p-&gt;val!=q-&gt;val)//都不是空，判断val的值是否相等        return false;        //递归判断左子树和右子树是否对称相等    return _isSameTree(p-&gt;left,q-&gt;right)        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;left);&#125;bool isSymmetric(struct TreeNode* root)&#123;    return _isSameTree(root-&gt;left,root-&gt;right);&#125;\n\n\n哈哈，是不是很爽，别急，后面还有可以偷懒的题目！\n\n572 另外一棵树的子树\nleetcode：572. 另一棵树的子树\n\n\n这道题我们要判断一颗树是否为另外一棵树的子树，和判断一个字符串是不是另外一个字符串的子串很相似\n其实只需要递归判断每一个节点的左右子树是否和subRoot相同就可以了！\nbool _isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;    if(p==NULL&amp;&amp;q==NULL)//比较是否两个节点都为空，都为空是真        return true;        if(p==NULL||q==NULL)//如果有一个为空，另外一个非空，即为假        return false;    if(p-&gt;val!=q-&gt;val)//都不是空，判断val的值是否相等        return false;        //递归判断左子树和右子树是否相等    return _isSameTree(p-&gt;left,q-&gt;left)        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;right);&#125;bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot)&#123;    // if(root==NULL&amp;&amp;subRoot==NULL)    //     return true;    // if(root!=NULL&amp;&amp;subRoot==NULL)    //     return true;    // 让isSametree函数来比较这俩个    if(root==NULL)        return false;    if(_isSameTree(root,subRoot))        return true;    //只要左右有一个是返回真，那就是子树    return isSubtree(root-&gt;left,subRoot)        || isSubtree(root-&gt;right,subRoot);&#125;\n\n\n是不是爽起来了？再来一道！\n\n\n226 翻转二叉树\nleetcode：226. 翻转二叉树\n\n\n这道题的思路如下哈！\n\n如果是空树，不需要翻转，直接return\n如果非空，就把该节点的左右子树交换（这里不需要担心交换后找不到子树的问题）\n不需要单独搞空的子树，一并交换就可以\n当根节点为空的时候，return\n\n啪的一下很快哈，代码就写出来了！\nvoid _invertTree(struct TreeNode* root)&#123;    if(root==NULL)//设置退出条件，如果根节点为空就返回        return;    //让另外两个值来接收原本的左右节点    struct TreeNode* left=root-&gt;left;    struct TreeNode* right=root-&gt;right;    //更改左右节点    root-&gt;right=left;    root-&gt;left=right;    //递归子树    _invertTree(root-&gt;left);    _invertTree(root-&gt;right);&#125;struct TreeNode* invertTree(struct TreeNode* root)&#123;    if(root==NULL)//判断空树        return NULL;    _invertTree(root);        return root;&#125;\n\n\n102 层序遍历（较难😥）\nleetcode：102. 二叉树的层序遍历\n\n\n这道题相对来说就么有那么容易了，你可能和我一样，压根没看明白题目要求中的后两个参数是用来干嘛的\n\n/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes)&#123;&#125;\n\n看了一些题解，这才算理解了这道题的要求\n\n*returnSize：存放的是二叉树的层数\n**returnColumnSizes：存放的是二叉树每一层的节点个数\n返回值要求是int**：需要返回一个指针数组，该数组中的每一个元素是一个数组A，数组A保存了二叉树每一层的节点值\n\n\n0.错误思路最开始我的想法是，用单独的函数计算出树的节点个数和层级，再进行一次层序遍历来得到树的值。\n但很显然，这一思路在本题是搞不通的！🤔\n1.数组队列初始化在上一篇博客中，我讲述了利用队列来实现层序遍历的思路。这道OJ题目我们也是这么干的。不同的是，在我自己写的队列实现里，使用的是链式队列。而本题使用数组队列会好一点！\n#define MAX 2000int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) &#123;    if (root == NULL)        return;    struct TreeNode* Queue[MAX];//队列，存放节点的地址    int front = 0, tail = 0;//指向队头和队尾\n\n2.初始化数组这部分会毕竟绕，先一步一步来理解\n*returnSize = 0;//将二叉树层级初始化为0//存放二叉树的每一层节点的值int** ret = (int**)malloc(sizeof(int*) * MAX);//开辟一个数组来存放每一层的节点个数*returnColumnSizes = (int*)malloc(sizeof(int*) * (MAX / 2));\n\n\nret是一个指针数组，存放的是数组A，数组A里面是每一层的节点值。ret也就是题目要求的返回值\n*returnColumnSizes开辟一个数组来保存每一层的节点数\n\n这里其实returnColumnSizes没有啥二级指针的必要，但是既然题目给了是int**，我们就需要先*解引用再malloc开辟数组\n3.队列操作思路\n先让根节点入队列，tail++\n外层循环判断队列是否非空，如果非空就停止操作\n内层循环进行每一层的入队操作，这样才能得到每一层的节点值和节点个数\n在内层循环中创建ret数组的子数组，单独存放每一层的节点值\n最后将每一层的节点个数赋值给*returnColumnSizes数组，*returnSize++一次\n\n   struct TreeNode* head;   Queue[tail++] = root;//根节点入队   while (front != tail)   &#123;       int Csize = 0;//每一层的节点个数       int end = tail;       //end是每一层最末一个节点的指针。在后续的入队列操作中tail会改变，所以需要保存tail的值       ret[*returnSize] = (int*)malloc(sizeof(int*) * (end - front));       //为每一层开辟一个单独的数组来存放值       while (front &lt; end)       &#123;           head = Queue[front++];           ret[*returnSize][Csize++] = head-&gt;val;           //数组赋值，同时每一层的节点个数Csize++           if (head-&gt;left != NULL)               Queue[tail++] = head-&gt;left;           if (head-&gt;right != NULL)               Queue[tail++] = head-&gt;right;       &#125;       (*returnColumnSizes)[*returnSize] = Csize;//赋值每一层的节点个数       (*returnSize)++;//层数+1   &#125;return ret;\n\n外层循环结束后，此时ret数组就是题目要求的结果了，返回ret就可以了！\n\n这里有一个小问题，当树为空树时，层级应该是0。所以我们需要在第一行赋值*returnSize = 0;不然会执行出错\n\n\n这道题的思路是我看过题解之后才搞明白的，所以上面的只是一个思路的复现😭还是太菜了！\n\n结语本篇刷题笔记到这里就结束啦，如果对涉及到的题目有什么不懂的地方，可以在评论区提出哦！\n\n\n要是知道，OJ也能偷懒，嘿嘿嘿嘿……😂\n\n不过最后一道题是真的难，我还以为它和前中后序遍历一样，只是让我们遍历出数组的值呢🙃\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","树","OJ刷题"]},{"title":"【C++】模板：了解泛型编程","url":"/posts/2940029419/","content":"本篇是C++模板学习的一些笔记\n\n\n[TOC]\n1.了解泛型编程泛型编程，故如其名，是一个泛化的编程方式。其实现原理为程序员编写一个函数&#x2F;类的代码示例，让编译器去填补出不同的函数实现\n就好比活字印刷术，可以灵活调整印刷的板块和内容，比只能固定印刷某一个内容的雕版印刷术效率更高，也让印刷术由此得到了更广泛的应用。\n\n在C++中，函数重载和模板的出现，让泛型编程得到了实际的应用。其中模板，就是类似活字印刷术一样的存在。\n我们写一个模板，编译器帮我们按照我们写的模板的方式，实例化成不同的函数。相当于替代了一部分操作，节省了代码量。\n2.函数模板八八了那么多没用的，让我们来看看函数模板的语法实现吧\n2.1 简单示例下面是一个最简单的交换函数的例子，通过标明模板参数T，让编译器自动识别函数传参，推测并实例化出不同的函数，供程序来调用。\ntemplate&lt;typename T&gt;void Swap(T&amp; left,T&amp; right)&#123;    T temp = left;    left = right;    right = temp;&#125;\n\n其中，typename是定义模板的关键字，我们可以使用class来替代，但不能使用struct\n\n据我查询到的资料，在模板的定义中使用typename/class是没有区别的\n\n\n可以看到，编译器成功调用了Swap函数，成功交换了int类型和double类型；\n2.2 多个模板参数如果我们尝试把int和double同时传参给这个函数，会发生什么呢？\n\n编译器会报错，表示模板参数T不明确，因为我们在函数模板里面对两个参数的说明都是T，编译器就认为这两个参数必须是相同的类型，而传入的int和double并不相同，于是就报错了。\n这时候我们有几种解决方法：\n\n首先是将double强转为int（反过来亦可）\n\n\n你会发现还是不行，那是因为强转并不支持用double引用int。所以我们把函数传参中的引用去掉，即可正常调用这个函数（暂且不提传引用和传值的区别）\n\n\n使用多个模板参数\n\n和函数传参类似，我们也可以设置多个模板参数\n在下图中，我使用typeid关键字来打印模板参数T1和T2的类型。\n\n使用typeid需要包含头文件#include &lt;typeinfo&gt;\n\n\n可以看到，实际上函数在调用这个模板的时候，已经实例化了这个函数（即替换模板参数为正确参数类型）这时候在后台处理的时候，其实Show函数已经实例化为了下面这个样子\nvoid Show(int left, double right)&#123;    cout &lt;&lt; typeid(left).name() &lt;&lt; endl;    cout &lt;&lt; typeid(right).name() &lt;&lt; endl;&#125;\n\n2.3 模板实例化上面的方式，是编译器自动帮我们实例化模板参数。在实际使用中，我们还可以自己指定实例化为什么类型\n\n利用强制类型转换\n使用&lt;int&gt;直接指定实例化为int类型（显式实例化）\n\n\n使用第二种方式的时候，编译器会对另外一个不匹配的参数进行隐式类型转换。如果转换不成功，或者该参数不支持转换，则会报错。\n另外注意的是，函数模板参数T同样可以用来作为返回值，但是不能通过返回值来推断参数T的类型。比如下面这个函数，我们在使用的时候就需要直接&lt;int&gt;指定模板参数T，而不能写一个 int* ptr=test(10)，让编译器通过 “返回值是int*接收的，所以函数模板参数T是int”来推断。\ntemplate&lt;typename T&gt;T* test(int num)&#123;\treturn new T[num];&#125;int main()&#123;    int* p = test(10);//错误    int* p = test&lt;int&gt;(10);//正确    return 0;&#125;\n\n函数模板支持给予类型缺省值当一个参数不确定的时候，函数模板的参数是支持给予缺省值的\n// 传递一个类型做为缺省值template&lt;typename T=char&gt;T* test(int num)&#123;\treturn new T[num];&#125;\n\n比如这样，当我们没有直接指定的时候，编译器就会将T作为char类型，返回一个num大小的char（一个字节）的空间\n注意：当有多个模板参数时，缺省值需要从右往左给，否则会出现类型匹配不上而无法调用的问题；这点和函数参数缺省值相同。\n函数模板中函数的传参也支持缺省值template&lt;typename T1&gt;void Add(T1 left, T1 right=10)&#123;    cout &lt;&lt; &quot;Add temp &quot;&lt;&lt; typeid(left).name() &lt;&lt; &quot; &quot; &lt;&lt; typeid(right).name() &lt;&lt; endl;    cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;&#125;int main()&#123;    int a=1;    Add(a);&#125;\n\n在这种情况下，编译器会正确调用该函数模板\n\n2.4 模板和普通函数同时存在（重载）以Add函数为例，在函数模板存在的同时，我们还可以单独写一个int类型的add函数。这都归功于函数重载的存在。\n同时，我们还可以使用&lt;int&gt;来指定函数模板重载为已存在的Add函数。因为本质上这两个函数是不同的，并不会冲突。\n\n函数在调用的时候，首先会去调用已经存在的函数。当参数和已存在的函数不匹配时，才会调用函数模板；\n而有&lt;int&gt;直接指定了模板参数类型的函数调用，自然也是会调用函数模板实例化出来的函数。\n2.5 函数模板不支持定义和声明分离一般情况下，我们都会在头文件中声明函数，在另外一个源文件中定义函数。\n但是模板是不支持这么做的！严谨来说，是不支持在不同文件中声明和定义分离，同一个文件是可以的。\n分了两个文件的时候，编译器会报错 链接错误，比如如下VS2019的报错\nerror LNK2019:无法解析的外部符号……\n\n所以我们需要将函数模板的声明和定义放在一个头文件中。在部分使用场景，会使用.hpp后缀，来表示这个头文件是包含了函数定义的（即.h 和 .cpp的集合体）。\n\nc&#x2F;cpp 中对头文件的包含并没有硬性的后缀要求，我们设置为 .h/.hpp 只是一个约定。\n\n需要注意，这并不是一个硬性要求，你也可以直接使用.h，并将声明和定义放入其中。\n\n模板为什么不支持定义和声明分离？\n\n因为单独的.h/.hpp声明会在源文件顶部被编译器展开，而此时函数模板就会开始正常推演参数，并call 函数名；\n但编译器并没有找到这个函数名所对应函数的具体实现，而在另外一个文件中（实现在另外一个函数里面），编译器又不知道你这个函数模板的声明需要实例化成什么类型的函数，那也没有办法成功进行实例化。\n最终就导致call了一个没有地址的函数，链接的时候肯定就找不到函数的地址，产生了符号表的链接错误；\n\n有无解决办法？\n\n其实是有的，我们可以在模板函数定义的.cpp中对我们需要使用的函数进行显式实例化指定.\n //头文件//声明template&lt;typename T1&gt;void Add(T1 left, T1 right);//源文件//定义//template不能被省略！每次都须写上template&lt;typename T1&gt;void Add(T1 left, T1 right)&#123;    cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;&#125;//在源文件中显式实例化//这就相当于告诉编译器这两个碗需要装什么菜//编译器才能正确帮我们实例化这个函数，并成功编译链接templatevoid Add&lt;int&gt;(int left, int right);templatevoid Add&lt;double&gt;(double left, double right);\n\n模板显式实例化需要对我们要用的所有类型的函数模板进行实例化，比如你需要用double类型，只显示实例化了int类型是不行的，依旧会报错。\n这就好比你只告诉厨子做10个人的饭，结果来了20个人。那剩下的10个人肯定是吃不上饭的。因为你没有告诉厨子（编译器）到底要来多少个人干饭。\n这样感觉非常多余……对吧？写多了还容易眼花。所以还是老老实实把声明和定义放在同一个文件里面吧！\n3.类模板类模板的基本形式如下，这里作为一个小区分，我用class来当作模板参数名。实际上typename也是可以的\ntemplate&lt;class T1, class T2, ...&gt;class 类模板名&#123;// 类内成员定义&#125;;     \n\n3.1 简单示例下面用一个非常简单的顺序表代码来演示一下类模板\ntemplate&lt;class T&gt;class List&#123;public:    List(int capacity = 10)        : _a(new T[capacity])        , _size(0)        , _capa(capacity)    &#123;&#125;     ~List();    T&amp; operator[](int pos)    &#123;        assert(pos &lt; _size);        return _a[pos];    &#125;private:    T* _a;    int _size;    int _capa;&#125;;//类模板中函数放在类外进行定义时，需要加模板参数列表//还必须要指定类的声明作为函数的作用域template &lt;class T&gt;List&lt;T&gt;::~List()&#123;    delete[] _a;    _size = _capa = 0;&#125;\n\n可以看到，通过显式实例化类模板的方式，我们成功让这个类模板变成了两个不同类型的顺序表\n\n3.2 成员函数声明和定义分离其中需要注意的是析构函数，声明和定义分离的时候（同一文件），在定义的时候也需要加上模板参数\n//类模板中函数放在类外进行定义时，需要加模板参数列表template &lt;class T&gt;List&lt;T&gt;::~List()&#123;    delete[] _a;    _size = _capa = 0;&#125;\n\n个人觉得这样也非常麻烦，既然模板最好是声明和定义放在同一个文件，那还不如直接将类的成员函数直接定义到类内部。多省事！\n\n如果是类的声明和定义放在不同文件中，显式实例化方式如下\n\ntemplateclass List &lt;int&gt;;templateclass List &lt;double&gt;;\n\n需要什么类型的类，就得实例化这个类型。\n\n以下是模板进阶的内容，源码仓库  GITEE\n\n4.非类型模板参数上面我们接触到的，都是类型模板参数。还有另外一种模板参数是非类型模板参数。\n\n类型模板参数：给的模板参数是一个类型\n非类型模板参数：给的模板参数是一个常量\n\n比如看看stl中的array容器，它的声明是下面这样的\ntemplate &lt; class T, size_t N &gt; class array;\n\n其中第二个参数 size_t N就是一个非类型模板参数\n4.1 什么场景需要非类型模板参数？用一个栈来作为栗子，不考虑动态内存管理。我们可以通过define一个栈的空间大小，来实例化一个int类型的栈\n#define STACK_SIZE 100// 静态栈class Stack1&#123;    int _st[STACK_SIZE];    int _top;&#125;;\n\n为了让这个栈能自适应的实例化出不同成员类型的栈，C++提供了类型模板参数\n#define STACK_SIZE 100// 模板栈template &lt;class T&gt;class Stack2&#123;    T _st[STACK_SIZE];    int _top;&#125;;\n\n这两个栈实例化的方式是下面这样，其中第一个栈是已经确定了是int类型，而第二个栈可以被实例化出任何我们想要的类型。\nint main()&#123;    Stack1 st1;    Stack2&lt;int&gt; st2;    Stack2&lt;double&gt; st3;    return 0;&#125;\n\n不过，即便已经有了模板参数，我们还是没有办法做到，让其中一个栈是100个成员的空间，另外一个栈是30的空间；这是因为空间在初始化的时候就已经被define替换了，并开辟了定长的空间。\n动态内存管理的时候，是可以通过构造函数来解决到底实例化多少空间的问题。但现在假设我们需要的就是一个定长的栈，那么动态内存管理就无能为力了。\n这时候，非类型模板参数就出场了，在这种场景下，我们可以通过模板l传递参数，来确定栈内空间的大小；\n// 动态栈template &lt;class T, size_t N&gt;class Stack3&#123;    T _st[N];    int _top;&#125;;\n\n这就给了我们在使用模板实例化对象的时候，将一些参数像函数传参一样提供给这个类，作为其实例化的地基的能力\nStack3&lt;int, 30&gt; st4;Stack3&lt;double, 100&gt; st5;\n\n编译通过无报错\ng++ test.cpp -o test -std=c++11\n\n将成员变量设置成公有，用sizeof能观察到这两个数组的大小和预期相符\ncout &lt;&lt; sizeof(st4._st) &lt;&lt; endl;cout &lt;&lt; sizeof(st5._st) &lt;&lt; endl;\n\n输出结果\n120800\n\n非类型模板参数不可被修改template &lt;class T, size_t N&gt;class Stack3&#123;public:    void modify_n(int n = 10)    &#123;        N = n; // 尝试修改模板参数    &#125;    T _st[N];    int _top;&#125;;\n\n当我们添加了一个修改N的函数，并尝试调用它的时候，编译会报错\ng++ test.cpp -o test -std=c++11test.cpp: In instantiation of ‘void Stack3&lt;T, N&gt;::modify_n(int) [with T = int; long unsigned int N = 30]’:test.cpp:45:21:   required from heretest.cpp:28:11: error: lvalue required as left operand of assignment         N = n; // 尝试修改模板参数         ~~^~~make: *** [makefile:2: test] Error 1\n\n报错的意思是 = 操作符需要一个可被修改的左值。这便告诉我们，非类型模板参数是一个const常量，是不能被修改的。\n4.2 STL的Array回过头来看stl的array，此时就能理解这个非类型模板参数的作用了；\n在声明中，第二个模板参数已经指定了参数类型为size_t，此时需要给N传入的值就是一个确定的无符号整数，作为array容器的空间大小；\ntemplate &lt; class T, size_t N &gt; class array;\n\n因为array是一个固定大小的数组容器，并不像vector那样可以实现扩容操作。\n而且array开辟的空间在栈上，vector在堆上（堆的空间大小远大于栈）\nArrays are fixed-size sequence containers\n\n那么array这个容器的作用是什么呢？\n\n我们确定知道需要使用多少长度的场景\narray对标的应该是原生数组，和vector相比，其优势基本没有。\narray相比直接使用定长数组，其封装了迭代器，能使用迭代器来进行参数的访问。能保证array和其他STL容器访问的代码的统一性。\narray因为有封装operator[]，所以有预先写好的越界检查；而直接使用 a[100] 原生数组，越界检查是不确定的。\n\n不过，这类封装和vector相比就尽显颓势了，所以在日常编码中array使用的频率很低\n4.3 非类型模板参数类型限制// 非类型模板参数只能用整数template &lt;class T, double N&gt;class Stack4&#123;public:    T _st[N];    int _top;&#125;;\n\n如果你想使用除了整数以外的类型作为非类型模板参数，包括浮点数和字符串，都是不可以的；\n但是char类型都是可以的（字符底层是1个字节的整数）\n\n\n5.模板的特化在绝大多数场景中，模板提供的这两个特性已经可以帮助我们完成很多工作。但在一些特殊情形下，模板的特化就没有我们想象中的那么美好了。\n5.1 问题引出template &lt;class T&gt;bool Less(T left, T right)&#123;    return left &lt; right;&#125;int main()&#123;    double t1 = 33.23;    double t2 = 26.32;    cout &lt;&lt; Less(t1, t2) &lt;&lt; endl;    cout &lt;&lt; Less(3, 4) &lt;&lt; endl;    return 0;&#125;\n\n比如上面的代码中，我们使用一个模板参数来进行两个相同类型之间的比较，输出的结果与预期相符\n01\n\n引入我们自己写的日期类（类中封装了对大小比较的重载）也是可以使用的\n   Date d1(2023,3,1);   Date d2(2023,6,4);// 输出为1   cout &lt;&lt; Less(d1,d2) &lt;&lt; endl;\n\n但如果用指针呢？问题就出现了！\nint main()&#123;    Date d1(2023,3,2);    Date d2(2023,3,1);    // 正确判断，输出0    cout &lt;&lt; Less(d1,d2) &lt;&lt; endl;    Date* pd1 = new Date(2023,3,2);    Date* pd2 = new Date(2023,3,1);    // 错误判断，输出1    cout &lt;&lt; Less(pd1,pd2) &lt;&lt; endl;    return 0;&#125;\n\n编译运行后，发现指针处输出的结果是1，即 pd1&lt;pd2成立！\n$ ./test01\n\n这是因为，在内部的比较是直接比较的这两个date*的指针，其比较的是这两个指针的地址大小！\nDate* pd2 = new Date(2023,3,1);Date* pd1 = new Date(2023,3,2);// Date* pd2 = new Date(2023,3,1);cout &lt;&lt; Less(pd1,pd2) &lt;&lt; endl;\n\n如果让pd2这个更小的日期在pd1之前被new，那输出的结果又变成0了；我们也能确认这个输出的结果，并非预期的日期比较结果\n$ ./test0\n\n5.2 模板特化5.3.1 函数模板特化针对这种情况，我们需要进行一些特殊化的处理；\ntemplate &lt;class T&gt;bool Less(T left, T right)&#123;    return left &lt; right;&#125;// 对Less函数针对Date*的指针进行特殊化处理template &lt;&gt;bool Less&lt;Date*&gt;(Date* left, Date* right)&#123;    return (*left) &lt; (*right); // 使用类内大小比较的重载    // 这里可以做任何处理，可以理解为是专门写的函数&#125;\n\n处理之后的函数再进行比较，输出的结果就是正确的了\nDate* pd1 = new Date(2023,3,2);Date* pd2 = new Date(2023,3,1);cout &lt;&lt; Less(pd1,pd2) &lt;&lt; endl; // 输出为0\n\n可以将这样的特化当作一种特殊的函数重载；\n\n那么函数模板是否支持后文中类模板一样的半特化呢？\ntemplate &lt;class T&gt;bool Less&lt;T*&gt;(T *left, T *right)&#123;    cout &lt;&lt; &quot;T*&quot; &lt;&lt; endl;    return (*left) &lt; (*right);&#125;\n\n并不支持！vscode就会报错告知我们，编译也无法通过\n\ng++ test.cpp date/date.cpp -o test -std=c++11test.cpp:81:32: error: non-type partial specialization ‘Less&lt;T*&gt;’ is not allowed bool Less&lt;T*&gt;(T *left, T *right)                                ^make: *** [makefile:2: test] Error 1\n\n要像实现对指针的操作，反而得单独写一个像下面一样的模板；\n需要注意，这个并不是模板特化，而是一个和原本的模板完全独立的函数模板，二者构成函数重载关系了（将原本的函数模板删除后，依旧可以编译通过并正常运行，就可以证明这个函数模板和原有函数模板无关）\ntemplate &lt;class T&gt;bool Less(T *left, T *right)&#123;    cout &lt;&lt; &quot;T*&quot; &lt;&lt; endl;    return (*left) &lt; (*right);&#125;\n\n此时date和int的指针都会走这个模板，而不会关注原本对Date*特化后的模板\n#include &quot;date/date.h&quot;template &lt;class T&gt;bool Less(T left, T right)&#123;    return left &lt; right;&#125;// 对Less函数针对Date*的指针进行特殊化处理template &lt;&gt;bool Less&lt;Date *&gt;(Date *left, Date *right)&#123;    cout &lt;&lt; &quot;date*&quot; &lt;&lt; endl;    return (*left) &lt; (*right); // 使用类内大小比较的重载    // 这里可以做任何处理，可以理解为是专门写的函数&#125;template &lt;class T&gt;bool Less(T *left, T *right)&#123;    cout &lt;&lt; &quot;T*&quot; &lt;&lt; endl;    return (*left) &lt; (*right);&#125;void test_less()&#123;    Date *pd1 = new Date(2023, 3, 2);    Date *pd2 = new Date(2023, 3, 1);    cout &lt;&lt; Less(pd1, pd2) &lt;&lt; endl;    int* pi1 = new int(3);    int* pi2 = new int(1);    cout &lt;&lt; Less(pi1,pi2) &lt;&lt; endl;&#125;\n\n输出结果\nT*0T*0\n\n在遇到特殊情况的时候，函数模板直接实现一个特定类型的特化，或者实现一个完全不同的函数模板就可以了。函数模板是不支持使用T* 和 T&amp;的偏特化的。\n\n调用时候指定模板参数类型的行为叫显式实例化，并非特化\n\n5.3.2 类模板特化template&lt;class T1, class T2&gt;class Data&#123;public:\tData() &#123; cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl; &#125;private:\tT1 _d1;\tT2 _d2;&#125;;\n\n没有特化之前，两个函数都是调用的模板本身\n$ ./testData&lt;T1, T2&gt;Data&lt;T1, T2&gt;\n\n全特化添加了一个针对&lt;int, double&gt;特化之后（这种特化被称为全特化）\ntemplate&lt;&gt;class Data&lt;int, double&gt;&#123;public:\tData() &#123; cout &lt;&lt; &quot;Data&lt;int, double&gt;&quot; &lt;&lt; endl; &#125;&#125;;\n\n调用的就是我们特化后的类模板了\n$ ./testData&lt;T1, T2&gt;Data&lt;int, double&gt;\n\n半特化&#x2F;偏特化偏特化的第一种形式，将模板参数中的一部分特化。比如下面的代码中，我们将模板参数的T2修改为char\n// 1、将模板参数类表中的一部分参数特化。template &lt;class T1&gt;class Data&lt;T1, char&gt;&#123;public:    Data() &#123; cout &lt;&lt; &quot;Data&lt;T1, char&gt;&quot; &lt;&lt; endl; &#125;&#125;;\n\n那么修改了之后，只要第二个参数是char的实例化类，都会走偏特化后的模板\nData&lt;int,char&gt; d3;Data&lt;char,char&gt; d4;\n\n测试结果，走的都是偏特化后的版本\nData&lt;T1, char&gt;Data&lt;T1, char&gt;\n\n除了这种偏特化某个特定类型的，我们还可以针对指针和引用进行偏特化\n// 2、偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本。template &lt;class T1, class T2&gt;class Data&lt;T1 *, T2 *&gt;&#123;public:    Data() &#123; cout &lt;&lt; &quot;Data&lt;T1*, T2*&gt;&quot; &lt;&lt; endl; &#125;&#125;;template &lt;class T1, class T2&gt;class Data&lt;T1 &amp;, T2 &amp;&gt;&#123;public:    Data() &#123; cout &lt;&lt; &quot;Data&lt;T1&amp;, T2&amp;&gt;&quot; &lt;&lt; endl; &#125;&#125;;\n\n测试代码\nData&lt;char*,char*&gt; d5;Data&lt;char*,double*&gt; d6;Data&lt;int*,char*&gt; d7;\n\n输出如下\nData&lt;T1*, T2*&gt;Data&lt;T1*, T2*&gt;Data&lt;T1*, T2*&gt;\n\n而只有一个指针的情况，会匹配原生的\n// 只有一个指针，会匹配原生的Data&lt;int*,int&gt; d8;\n\n输出结果\nData&lt;T1, T2&gt;\n\n\n引用的结果也是一样的，两个引用就会调用我们对引用特化了的类模板\nData&lt;int&amp;,char&amp;&gt; d9;Data&lt;int&amp;,double&amp;&gt; d10;\n\n输出\nData&lt;T1&amp;, T2&amp;&gt;Data&lt;T1&amp;, T2&amp;&gt;\n\n但是引用如果只有一个（不管是在前面还是后面），那就会报错了！\nData&lt;char&amp;,double&gt; d11;\n\n这是因为它会去调用没有特化后的基础版本，但在默认版本中，我们使用了模板参数来定义了一个变量，这时候就出错了（因为引用必须要在定义的时候赋值！）\ng++ test.cpp date/date.cpp -o test -std=c++11test.cpp: In instantiation of ‘Data&lt;T1, T2&gt;::Data() [with T1 = char&amp;; T2 = double]’:test.cpp:160:24:   required from heretest.cpp:104:5: error: uninitialized reference member in ‘char&amp;’ [-fpermissive]     Data() &#123; cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl; &#125;     ^~~~test.cpp:107:8: note: ‘char&amp; Data&lt;char&amp;, double&gt;::_d1’ should be initialized     T1 _d1;        ^~~make: *** [makefile:2: test] Error 1\n\n如果将基础模板中的这两个变量定义删除，那就不会报错了\ntemplate &lt;class T1, class T2&gt;class Data&#123;public:    Data() &#123; cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl; &#125;// private://     T1 _d1;//     T2 _d2;&#125;;\n\n\n运行，输出的结果也是默认的模板\nData&lt;T1, T2&gt;\n\n小结偏特化的适用范围一般高于全特化。\n偏特化和全特化同时存在时，优先调用全特化！\n5.3 使用场景当我们使用CPP库函数sort的时候， 需要传入一个仿函数来进行排序的操作。\ntemplate &lt;class T&gt;struct Less&#123;    bool operator()(const T &amp;x, const T &amp;y) const    &#123;        return x &lt; y;    &#125;&#125;;void test_less_sort()&#123;    Date d1(2023, 3, 2);    Date d2(2023, 4, 6);    Date d3(2023, 6, 3);    vector&lt;Date&gt; v;    v.push_back(d2);    v.push_back(d1);    v.push_back(d3);    sort(v.begin(), v.end(), Less&lt;Date&gt;());    for (auto e : v)    &#123;        cout &lt;&lt; e ;    &#125;    cout &lt;&lt; endl;&#125;\n\n在栈上创建的Date是可以直接进行仿函数排序，并获取到正确结果\n2023-3-22023-4-62023-6-3\n\n但如果是new出来的Date，就会因为是比较的指针而无法正常进行排序\nDate *pd1 = new Date(2023, 3, 2);    Date *pd2 = new Date(2023, 7, 1);    Date *pd3 = new Date(2023, 5, 1);    vector&lt;Date*&gt; vptr;    vptr.push_back(pd1);    vptr.push_back(pd2);    vptr.push_back(pd3);    sort(vptr.begin(), vptr.end(), Less&lt;Date*&gt;());    for (auto e : vptr)    &#123;        cout &lt;&lt; (*e) ;    &#125;    cout &lt;&lt; endl;\n\n输出结果无序\n2023-7-12023-3-22023-5-1\n\n这时候就需要对Less这个仿函数的类进行特化了，我们可以使用全特化，也可以使用偏特化，二者效果相同；而针对指针的偏特化显然适用范围更广\n// 仿函数类特化template &lt;class T&gt;struct Less&#123;    bool operator()(const T &amp;x, const T &amp;y) const    &#123;        return x &lt; y;    &#125;&#125;;//全特化template&lt;&gt;struct Less&lt;Date*&gt;&#123;\tbool operator()(Date* x, Date* y) const\t&#123;\t\treturn *x &lt; *y;\t&#125;&#125;;// 偏特化template &lt;class T&gt;struct Less&lt;T *&gt;&#123;    bool operator()(T *x, T *y) const    &#123;        return *x &lt; *y;    &#125;&#125;;\n\n再次测试，成功打印出有序结果\n2023-3-22023-5-12023-7-1\n\n5.4 迭代器萃取5.4.1 iterator_traits这个问题在STL-LIST的博客中已经涉及到了一部分；但那时候还没还有了解模板中的特化，没有办法详细地去观察底层的实现机制。\n在STL源码中的stl_iterator.h文件中，可以看到反向迭代器中的如下实现。其使用了iterator_traits模板类，来获取正向迭代器中的成员类型（暂时只关注pointer/reference）\ntemplate &lt;class Iterator&gt;class reverse_iterator &#123;protected:  Iterator current;public:  typedef typename iterator_traits&lt;Iterator&gt;::iterator_category          iterator_category;  typedef typename iterator_traits&lt;Iterator&gt;::value_type          value_type;  typedef typename iterator_traits&lt;Iterator&gt;::difference_type          difference_type;  typedef typename iterator_traits&lt;Iterator&gt;::pointer          pointer;  typedef typename iterator_traits&lt;Iterator&gt;::reference          reference;\n\n再看看这个类的实现，能看到如下的内容，其针对正向迭代器，同时刻画了关于T*指针和const T*引用的两个偏特化版本。\n因为在list中，我们的正向迭代器是自主封装实现的。但是在vector中，正向迭代器直接用的就是指针。提供了这两个特化版本，就能保证即便是用指针这一内置类型实现的特化版本，能成功地获取到一个正确的数据类型（同时也使用了typename告诉编译器这是数据类型）的typedef\ntemplate &lt;class Iterator&gt;struct iterator_traits &#123;  typedef typename Iterator::iterator_category iterator_category;  typedef typename Iterator::value_type        value_type;  typedef typename Iterator::difference_type   difference_type;  typedef typename Iterator::pointer           pointer;  typedef typename Iterator::reference         reference;&#125;;template &lt;class T&gt;struct iterator_traits&lt;T*&gt; &#123;  typedef random_access_iterator_tag iterator_category;  typedef T                          value_type;  typedef ptrdiff_t                  difference_type;  typedef T*                         pointer;  typedef T&amp;                         reference;&#125;;template &lt;class T&gt;struct iterator_traits&lt;const T*&gt; &#123;  typedef random_access_iterator_tag iterator_category;  typedef T                          value_type;  typedef ptrdiff_t                  difference_type;  typedef const T*                   pointer;  typedef const T&amp;                   reference;&#125;;\n\n5.4.2 distance除了反向迭代器这里需要用到特化，在STL提供的distance函数中也会用到（用于计算两个迭代器之间的距离）\ntemplate &lt;class InputIterator, class Distance&gt;inline void __distance(InputIterator first, InputIterator last, Distance&amp; n,                        input_iterator_tag) &#123;  while (first != last) &#123; ++first; ++n; &#125;&#125;template &lt;class RandomAccessIterator, class Distance&gt;inline void __distance(RandomAccessIterator first, RandomAccessIterator last,                        Distance&amp; n, random_access_iterator_tag) &#123;  n += last - first;&#125;template &lt;class InputIterator, class Distance&gt;inline void distance(InputIterator first, InputIterator last, Distance&amp; n) &#123;  __distance(first, last, n, iterator_category(first));&#125;\n\n如果是一个单项迭代器，其就需要用过++来计算出两个迭代器之间的长度。如果是一个随机迭代器，那就可以直接通过二者相减计算出距离。\n这时候就需要通过萃取来获取迭代器的类型（在迭代器类构造的时候，迭代器类型就已经通过萃取确认了），并通过这个迭代器的类型，确定使用的算法；\n6.模板的显示实例化6.1 说明请注意，模板的显示实例化和模板的特化不是一个东西，需要注意区分开来。\n所谓模板显示实例化，就是让编译器给你指定的模板类型生成对应的代码，这样在后续的编译过程中不再需要多次生成。\n在上文中其实已经出现过函数模板实例化的示例 👉 点我跳转到上文. 我们在函数模板定义的源文件中，显示实例化我们需要的类型的函数模板，这样后续编译器在生成对应函数的时候，就可以正常从模板生成出我们需要的函数，而避免编译时找不到目标函数的问题。\n6.2 语法模板显示实例化的方式是template+函数模板的原本声明。\n比如显示实例化一个函数，就需要用template带上这个函数原本的定义和具体的模板参数类型。\ntemplate&lt;typename T1&gt;void Add(T1 left, T1 right)&#123;   cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;&#125;//在源文件中显式实例化templatevoid Add&lt;int&gt;(int left, int right);\n\n如果是显示实例化一个class，那么操作如下\ntemplate &lt;typename T&gt;class MyTemplateClass &#123;public:    void print()     &#123;        std::cout &lt;&lt; &quot;MyTemplateClass: &quot;  &lt;&lt; typeid(T).name() &lt;&lt; std::endl;    &#125;&#125;;// 显式实例化 MyTemplateClass 类模板// 生成专门针对 int 类型的实例化代码template class MyTemplateClass&lt;int&gt;;\n\n6.3 显示实例化的作用域请注意，如果使用显示实例化，那么它的实例化后的模板类&#x2F;函数的声明都只会存在于当前源文件中，其他源文件中无法调用该函数！\n下面给出4个文件中的内容，作为测试。文件名参考开头注释。\n// head.h#include &lt;iostream&gt;using namespace std;// 头文件head.h中，模板函数声明template &lt;typename T&gt;T Add(T a,T b);// 定义普通函数，尝试在a.cpp中实现int test_add_a(int a,int b);// 定义普通函数，尝试在b.cpp中实现int test_add_b(int a,int b);\n\n上为head.h文件，下为a.cpp文件。\n// a.cpp#include &quot;head.h&quot;// A.cpp中定义函数模板template &lt;typename T&gt;T Add(T a,T b)&#123;    return a+b;&#125;int test_add_a(int a,int b)&#123;    return a+b;&#125;\n\n下为b.cpp文件和test.cpp文件.\n// b.cpp#include &quot;head.h&quot;int test_add_b(int a,int b)&#123;    return Add&lt;int&gt;(a,b);&#125;\n\n尝试在main函数中调用分别在a和b中定义的两个相加函数.\n// test.cpp#include &quot;head.h&quot;int main()&#123;    cout &lt;&lt; &quot;a &quot; &lt;&lt; test_add_a(10,3) &lt;&lt; endl;    cout &lt;&lt; &quot;b &quot; &lt;&lt; test_add_b(10,30) &lt;&lt; endl;    return 0;&#125;\n\n\n执行编译后的报错如下，在b.cpp中找不到对应的Add&lt;int&gt;函数实例化之后的函数体实现，无法调用该函数模板！\n╰─ g++ test.cpp a.cpp b.cpp -o test/tmp/ccCFOnFc.o: In function `test_add_b(int, int)&#x27;:b.cpp:(.text+0x19): undefined reference to `int Add&lt;int&gt;(int, int)&#x27;collect2: error: ld returned 1 exit status\n\n这是因为函数模板的实现只存在于a.cpp中,所以只有a.cpp中的其他函数能正常调用到这个函数模板.\n所以,如果想在b.cpp中也能调用到这个函数模板,解决办法只有在其中也带上函数模板的定义!不然是不行的! (只在b.cpp中显示实例化是无效的,编译会报错.)\n\n小结: 不管是什么时候,遇到函数模板和类模板,还是老老实实声明定义不分离最好!\n\n模板总结优点：模板复用了代码，节省了资源和开发效率，C++的模板标准库也因此产生。增强了代码的灵活性；\n缺点：模板会导致代码膨胀问题，也会增加编译时间（模板在编译过程中实例化出具体的函数和类）。而且出现模板编译失败的错误时，错误信息凌乱不方便定位问题。\nThe end关于模板的基本知识和进阶关于特化的知识就基本结束辣！\n其实模板还有模板元编程这种更深层的东西，但那些使用的频率并不高，具体在工作中如果用到了，可能就需要更深入的学习了。\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】并查集","url":"/posts/2359019899/","content":"并查集这个数据结构本身并不难，其主要是提供一个思路，方便我们编写图的代码，和一些OJ题\n\n\n[TOC]\n1.什么是并查集？并查集是多个独立集合的合集，用于表示数据之间的关系。\n比较生动的例子，就是我们生活中的朋友圈（不是wx的那个啊）\n\n张三和李四是好朋友，那么他们就构成了一个集合A\n王舞和王陆是好朋友，那么他们也构成了一个集合B\n此时，王舞突然认识了李四，这时候，就可以把A和B合并成一个集合\n\n推而广之，一个并查集中可以有多个这样的集合，多个朋友圈。\n\n并查集中的每一个集合是用多叉树来表示的\n\n2.思路并查集的思路并不难，给定一个数组的大小（需要在另外的地方管理编号）创建一个并查集\n下标即为数据的编号\n\n设定元素的初始值都是-1\n如果下标1和3为一个集和，那就把3的元素（初始值-1）加到1处，即1的元素为-2；再把3的元素设置为1的下标，即3的元素为1\n依此类推，最终只要下标所对应元素不为负数，那么这个下标就是一个集和的成员\n如果为负数，那么就是一个集合的根，且元素为这个集和中成员的个数（绝对值）\n\n如图所示，下标678所对应元素为0，代表它们属于以下标0为根的一个集合。而下标0处的元素为-4，代表这个集合里面有4个元素\n\n2.1 合并集合如果我们需要合并一个集合，以上图中的0集合和1集合为例。我们只需要将1集合的元素-3加到0集合上，再把1集合的元素改成0即可\n此时的树就会是这样的👇\n\n2.2 压缩路径当节点很多，集合可能会出现路径长度过大的情况。这时候我们就需要进行路径的压缩\n其方法很简单。遍历整个并查集，将同一集合的子节点改成相同的父亲即可\n\n这样在向上找集合的根时，无须跳转多次，一次就能找到。\n但由于并查集的访问是依靠数组下标实现的随机访问，时间复杂度为O(1)，只有数据样本量极大的时候，这么做才能有效果\n\n3.代码相比于其他数据结构复杂的实现，并查集的实现就简单多了。主要的函数只有几个，可以通过封装vector来实现\nclass UnionFindSet {public:\tUnionFindSet(const int sz)\t\t:_set(sz,-1)//调用vector构造函数，初始化sz个-1\t{}\tvoid Union(int x, int y)//设置x和y为一个集合\t{\t\tint r1 = FindRoot(x);\t\tint r2 = FindRoot(y);\t\tif (r1 != r2)//不在一个集和中\t\t{\t\t\t_set[r1] += _set[r2];\t\t\t_set[r2] = r1;\t\t}\t}\tint FindRoot(int n)//找这个集合的根\t{\t\twhile (_set[n] &gt;= 0)\t\t{\t\t\tn = _set[n];\t\t}\t\treturn n;//负数的时候为根\t}\tbool isUnion(int x,int y)//判断是否在一个集合中\t{\t\treturn FindRoot(x) == FindRoot(y);\t}\tint UnionSZ()//返回有几个集合\t{\t\tint count = 0;\t\tfor (int i = 0; i &lt; _set.size(); i++)\t\t{\t\t\tif (_set[i] &lt; 0)\t\t\t{\t\t\t\tcount++;\t\t\t}\t\t}\t\treturn count;\t}private:\tvector&lt;int&gt; _set;//用来存放对应关系};\n\n这里没有写压缩路径的代码，其实也就是一个遍历搞定的事😂\n\n遍历，判断是否为同一集合\n是，找到这个集和的根\n将当前遍历到的节点父亲改成该集和的根\n\n思路还是不难的\n4.OJ题4.1 剑指 Offer II 116. 省份数量\n剑指 Offer II 116. 省份数量 \n\n\n有了并查集，这道题就非常简单。最重要的是思路。我们无须现场造一个轮子，只需要写好找根函数，用一个数组就能实现一个简单的并查集\nclass Solution {public:    int FindRoot(const vector&lt;int&gt;&amp; v,int n)    {        int prev = n;//初始下标        while(v[prev]&gt;=0)//它的父亲下标        {            prev=v[prev];//如果不为负数，那就还是需要往前找        }        return prev;    }    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected)     {        vector&lt;int&gt; v(isConnected.size(),-1);        for(int i=0;i&lt;isConnected.size();i++)        {            for(int j=0;j&lt;isConnected[i].size();j++)            {                if(isConnected[i][j]==1)//为1代表是一个集合中的元素                {                    int root1 = FindRoot(v,i);                    int root2 = FindRoot(v,j);                    if(root1!=root2)                    {                        v[root1] += v[root2];                        v[root2] = root1;                    }                }            }        }        int count = 0;        for(int i=0;i&lt;v.size();i++)        {            if(v[i]&lt;0)            {                count++;            }        }        return count;    }};\n\n\n4.2 等式方程的可满足性\n990.等式方程的可满足性\n\n\n这道题和上面那一道差不多，只不过把省份换成了字母之间的关系\nclass Solution {public:    int FindRoot(const vector&lt;int&gt;&amp; v,int n)    {        int prev = n;//初始下标        while(v[prev]&gt;=0)//它的父亲下标        {            prev=v[prev];//如果不为负数，那就还是需要往前找        }        return prev;    }    bool equationsPossible(vector&lt;string&gt;&amp; equations) {        vector&lt;int&gt; v(26,-1);//因为题目给的都是小写字母，直接建立26个小写字母的映射表        for(int i=0;i&lt;equations.size();i++)        {            int root1 = FindRoot(v,equations[i][0]-'a');//第一个字母            int root2 = FindRoot(v,equations[i][3]-'a');//第二个字母            if(equations[i][1]=='=')//代表等于            {                if(root1!=root2)                {//设置为一个集合中的元素                    v[root1] += v[root2];                    v[root2] = root1;                }            }            else//不等于            {                if(root1==root2)                {                    //如果不等于的同时，根还相同                    //说明是同一个集合，不符合题意                    return false;                }            }        }        //还需要遍历第二遍，避免漏网之鱼        for(int i=0;i&lt;equations.size();i++)        {            int root1 = FindRoot(v,equations[i][0]-'a');//第一个字母            int root2 = FindRoot(v,equations[i][3]-'a');//第二个字母            if(equations[i][1]=='!')//不等于            {                if(root1==root2)                {                    //如果不等于的同时，根还相同                    //说明是同一个集合，不符合题意                    return false;                }            }        }        return true;    }};\n\n\n","categories":["数据结构太复杂"],"tags":["C++","数据结构","图"]},{"title":"【图】拓扑排序 | 转载","url":"/posts/1720780208/","content":"本文搬运自csdn\n\n\n拓扑排序什么是拓扑排序？  在图论中，拓扑排序是一个有向无环图的所有顶点的线性序列(获得拓扑有序序列)。且该序列必须满足下面两个条件：\n\n每个顶点出现且只出现一次。\n若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。\n\n有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。\n  \n怎么拓扑排序？拓扑排序步骤：\n\n在有向图中选一个没有前驱的顶点且输出之。\n从图中删除该顶点和所有以它为尾的弧。\n\n  重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止。后一种情况则说明有向图中存在环。\n \n  图中，V1 和 V6 没有前驱，则可任选一个。假设先输出 V6，在删除 V6 及弧 &lt;V6, V4&gt;,&lt;V6, V5&gt; 之后，只有顶点 V1 没有前驱，输出 V1 且删去 V1 及弧 &lt;V1, V2&gt;,&lt;V1, V3&gt; 和 &lt;V1, V4&gt;，之后 V3 和 V4 都没有前驱。依此类推，可从中任选一个继续进行。整个拓扑排序的过程如上图。\n拓扑排序实现  我们采用邻接表作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组。入度为零的顶点即为没有前驱的顶点，删除顶点以及它为尾的弧的操作，则可换以弧头顶点的入度减 1 来实现。\nStatus TopologicalSort(ALGraph G)&#123;\t//有向图G采用邻接表存储结构 \t//若G无回路，则输出G的顶点的一个拓扑序列并返回OK，否则ERROR \tFindInDegree(G, indegree);//对各顶点求入度indegree[0..vernum-1] \tInitStack(S);\tfor(i=0;i&lt;G.vexnum;i++)//建零入度顶点栈S \t\tif(!indegree[i])//入度为0者进栈 \t\t\tPush(S, i);\tcount = 0;//对输出顶点计数 \twhile(!StackEmpty(S))&#123;\t\tPop(S, i);\tprintf(i, G.vertices[i].data);\tcount++;//输出i号顶点并计数 \t\tfor(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;\t\t\tk = p-&gt;adjvex;//对i号顶点的每个邻接点的入度减1 \t\t\tif(!(--indegree[k]))//若入度减为0，则入栈 \t\t\t\tPush(S, k);\t\t&#125;\t&#125;\tif(count&lt;G.vexnum)//该有向图有回路 \t\treturn ERROR;\telse\t\treturn OK;&#125;\n\n对有 n 个顶点和 e 条弧的有向图而言，建立求各顶点的入度的时间复杂度 O(e)；建零入度顶点栈的时间复杂度为 O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减 1 的操作在 WHILE 语句中总共执行 e 次，所以，总的**时间复杂度为 O(n+e)**。  \n当有向图中无环时，也可利用深度优先遍历进行拓扑排序，因为图中无环，则由图中某点出发进行深度优先搜索遍历时，最先退出 DFS 函数的顶点即出度为零的顶点，是拓扑有序序列中最后一个顶点。由此，按退出 DFS 函数的先后记录下来的顶点序列(如同求强连通分量时 finished 数组中的顶点序列)即为逆向的拓扑有序序列。  \n关键路径什么是关键路径？AOE网： 在一个表示工程的带权有向图中，用顶点表示事件（如V1），用有向边表示活动（如&lt;V1,V2&gt; &#x3D; a1），边上的权值表示活动的持续时间，称这样的有向图为边表示的活动的网。源点： 在AOE网中，没有入边的顶点称为源点；如顶点V1。终点： 在AOE网中，没有出边的顶点称为终点；如顶点V9。AOE网的性质：\n\n只有在进入某顶点的活动都已经结束，该顶点所代表的事件才发生；例如，V5 事件发生需要 a4 和 a5 两个活动都结束。\n只有在某顶点所代表的事件发生后，从该顶点出发的各活动才开始；例如，V5 事件结束，活动 a7 和 a8 活动才能开始。\n\n\n  在AOE网中，所有活动都完成才能到达终点，因此完成整个工程所必须花费的时间（即最短工期）应该为源点到终点的最大路径长度。具有最大路径长度的路径称为关键路径。关键路径上的活动称为关键活动。  假设开始点是 V1，从 V1 到 Vi 的最长路径长度叫做事件 Vi 的最早发生事件。这个时间决定了所有以 Vi 为尾的弧所表示的活动的最早开始时间。我们用 e(i) 表示活动 ai 的最早开始时间。还可以定义一个活动的最迟开始时间 l(i)，这是在不推迟整个过程完成的前提下，活动 ai 最迟必须开始进行的时间。两者之差 l(i)-e(i) 意味着完成活动 ai 的时间余量。我们把 l(i)&#x3D;e(i) 的活动叫做关键活动。\n向关键路径要时间，向非关键路径要资源。\n\n从前往后，计算工期与每项活动的最早开始时间；\n从后往前，倒推每项活动最晚开始时间。\n关键路径：最早开始时间&#x3D;最晚开始时间\n\n怎么求关键路径？ve(j)：最早发生时间vl(j)：最迟发生时间\n\n输入 e 条弧&lt;j, k&gt;，建立 AOE-网的存储结构；\n从源点 v0 出发，令 ve[0]=0，按拓扑有序求其余各顶点的最早发现时间 ve[i] (1≤i≤n-1)。如果得到的拓扑有序序列中顶点个数小于网中顶点数 n，则说明网中存在环，不能求关键路径，算法终止；否则执行步骤(3)。\n从汇点 vn 出发，令 vl[n-1]=ve[n-1]，按逆拓扑有序求其余各顶点的最迟发生时间 vl[i] (n-2≥i≥2)；\n根据各顶点的 ve 和 vl 值，求每条弧 s 的最早开始时间 e(s) 和最迟开始时间 l(s)。若某条弧满足条件 e(s)&#x3D;l(s)，则为关键活动。\n\n  根据上述算法，计算各顶点的 ve 值是在拓扑排序的过程中进行的，需对拓扑排序的算法作如下修改：\n\n在拓扑排序之前设初值，令 ve[i]=0 (0≤i≤n-1)；\n在算法中增加一个计算 vj 的直接后继 vk 的最早发生时间的操作：若 ve[j]+dut(&lt;j, k&gt;) &gt; ve[k]，则 ve[k]=ve[j]+dut(&lt;j, k&gt;)；\n为了能按逆拓扑有序序列的顺序计算各顶点的 vl 值，需记下在拓扑排序的过程中求得的拓扑有序序列，这需要在拓扑排序算法中，增设一个栈以记录拓扑有序序列，则在计算求得各顶点的 ve 值之后，从栈顶至栈底便为逆拓扑有序序列。\n\n关键路径实现改写的拓扑排序代码：\nStatus TopologicalOrder(ALGraph G, Stack &amp;T)&#123;\t//有向图G采用邻接表存储结构，求各顶点事件的最早发生时间 ve(全局变量) \t//T为拓扑序列顶点栈，S为零入度顶点栈 \t//若G无回路，则用栈T返回G的一个拓扑序列，且函数值为OK，否则ERROR \tFindInDegree(G, indegree);//对各顶点求入度indegree[0..vernum-1] \tInitStack(S);//建零入度顶点栈S \tfor(i=0;i&lt;G.vexnum;i++)//建零入度顶点栈S \t\tif(!indegree[i])//入度为0者进栈 \t\t\tPush(S, i);\tInitStack(T);\tcount = 0;\tve[0..G.vexnum-1] = 0;//初始化 \twhile(!StackEmpty(S))&#123;\t\tPop(S, j);\tPush(T, j);\tcount++;//j号顶点入T栈并计数 \t\tfor(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;\t\t\tk = p-&gt;adjvex;//对j号顶点的每个邻接点的入度减1 \t\t\tif(--indegree[k] == 0)//若入度减为0，则入栈 \t\t\t\tPush(S, k);\t\t\tif(ve[j]+ *(p-&gt;info)&gt;ve[k])\t\t\t\tve[k] = ve[j] + *(p-&gt;info);\t\t&#125;\t&#125;\tif(count &lt; G.vexnum)//该有向图有回路 \t\treturn ERROR;\telse\t\treturn OK;&#125; \n\n关键路径算法：\nStatus CriticalPath(ALGraph G)&#123;\t//G为有向图，输出G的各项关键活动 \tif(!TopologicalOrder(G, T))\t\treturn ERROR;\tvl[0..G.vexnum-1] = ve[G.vexnum-1];//初始化顶点事件的最迟发生事件 \twhile(!StackEmpty(T))&#123;//按拓扑逆序求各顶点的vl值 \t\tfor(Pop(T, j),p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;\t\t\tk = p-&gt;adjvex;\tdut = *(p-&gt;info);\t\t\tif(vl[k]-dut &lt; vl[j])\t\t\t\tvl[j] = vl[k]-dut;\t\t&#125;\t&#125;\tfor(j=0;j&lt;G.vexnum;j++)&#123;//求ee，el和关键活动 \t\tfor(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;\t\t\tk = p-&gt;adjvex;\tdut = *(p-&gt;info);\t\t\tee = ve[j];\tel = vl[k]-dut;\t\t\ttag = (ee==el)?&#x27;*&#x27;:&#x27;&#x27;;\t\t\tprintf(j, k, dut, ee, el, tag);//输出关键活动 \t\t&#125;\t&#125;&#125; \n\n\n  上面两种算法的时间复杂度均为 O(n+e)，计算弧的活动最早开始时间和最迟开始时间的时间复杂度为 O(e)，所以总的求关键路径的**时间复杂度为 O(n+e)**。  \n求关键路径过程示例 \n上图的关键活动为 a1，a4，a7，a8，a10 和 a11。它们构成两条关键路径：(V1，V2，V5，V7，V9) 和 (V1，V2，V5，V8，V9)。  \n实践证明：用 AOE-网来估算某些工程完成的时间是非常有用的。只有在不改变网的关键路径的情况下，提高关键活动的速度才有效。若网中有几条关键路径，那么，单是提高一条关键路径上的关键活动的速度，还不能导致整个工程缩短工期，而必须提高同时在几条关键路径上的活动速度。\n版权声明：本文为CSDN博主「qw&amp;amp;jy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43448856/article/details/119959241\n\n","categories":["数据结构太复杂"],"tags":["数据结构","图","Java"]},{"title":"【C语言】八大排序算法（带图详解）","url":"/posts/3996153794/","content":"前言如果你把本专栏从头看到这里，那么恭喜你，本篇博客已经是是初阶数据结构的收尾啦😁！让我们一起来学习一下，那些常见的排序算法！\n\n本篇博客主要讲述八大排序🕵️‍♀️，桶排序/基数排序可能会在后期补上！欢迎大家收藏本文！\n\n\n在之前的学习中，我们已经接触过ez的冒泡排序，和通过堆实现的堆排序，本篇博客就不再详解这两个了！\n\n有些排序的思路不是那么好懂，我的讲解也会有不到位的地方，欢迎在评论区提出你的疑惑或建议！🌭\n\n[TOC]\n1.插入排序1.1直接插入基本思想：把待排序的数依照大小插入一个已经有序的序列中，直到所有数插入完毕，就能得到一个新的有序序列\n\n实际上我们日常生活中打斗地主，在码牌的时候就运用了这种思想。把相同的数放在一起，并依照从小到大排列\n\n\n你可能会疑惑，都“已经有序”了，那还怎么排序？\n\n这需要我们之前学习链式二叉树时接触到的分治思想\n当我们手头上只有两个数的时候，将大的那个数插入到小的数后头，就形成了一个有序的2数序列\n这时候再让下一个数加入进来，把它插入到相应位置，得到一个有序的3数序列\n依次递进，最终就能得到一个有序的N数序列\n\n如果学习过分治思想的你，肯定一拍桌子道：“我知道了，手头上只有两个数的时候，就是分治的末端条件！”\n没错，我们就是要利用这种思想，实现从两个数开始的插入排序！\n\n给定一个数组，需要你使用插入排序，将它变成升序序列9 1 2 5 7 4 8 6 3 5\n\n我们就从9开始，将1插入到9的前面，2插入到1、9之间，……\n\n这样就能最终排序出1 2 3 4 5 5 6 7 8 9的结果\n\n最后以代码的形式操作，如下面所示\n// 插入排序void InsertSort(int* a, int n){    //在一个数组中插入新的数，每一趟都让最后的end+1的数据大于end    for (int i = 0; i &lt; n - 1; i++)    {        int end = i;        int tmp = a[end+1];        while (end &gt;= 0)        {            if (tmp &lt; a[end])            {                a[end + 1] = a[end]; // 将当前和下一位交换                end-= 1; // 往前移动，继续比较            }            else                break;        }        a[end+1] = tmp;        //最后end不符合条件出循环的时候，end可能为-1，a[end]会越界        //如果是break出的循环，end+1和tmp的位置相同，自己等于自己，问题不大    }}\n\n由此我们可以总结出直接插入排序的一些特性\n\n时间复杂度：O(N^2^)\n空间复杂度：O(1)，是原地算法\n元素越接近有序的时候，需要交换的次数就越少，算法的效率越高\n\n\n1.2希尔排序希尔排序是对直接插入的优化，又称“缩小增量法”。之前我们是进数组之后直接开R，现在先Q一下再R闪，这样才能打出更秀的操作。不过我的盲僧很菜，R闪就没有成功过😥\n\n喂喂喂，好像跑题了！\n\n基本思想：先选定一个整数gap，让后把待排序数据以gap为间隔进行单独的插入排序（预排序），这样让数列做到局部有序，最后在进行插入排序，达到优化插入排序算法效率的目的\n比如我们设定gap=3，这样原本的数组就被分割成了下面的模样，接着我们先对这3组数据进行单独的插入排序【这个操作被称为 预排序】\n\n你能写出它们单独插入排序后的结果吗？\n\n这时候我们的序列虽然不是有序的，但是只看一个小局部的时候，它是有序的。\n这样能减少插入排序操作时候的比较次数，自然效率就变高了\n\n执行完预排序后，我们就可以对现在的新序列进行插入排序了。但是直接这么调用还不够优化。\n\n再仔细看看上面的思路，你会发现，其实gap=1的时候，就相当于一次插入排序了\n\n而且当数据量很大的时候，我们也需要实时改变我们的gap。\n待排序数据有100个，gap=3就太小了，优化了个寂寞。\n待排序数据有10个，gap=20就是搬起石头砸自己的脚，同样不行！\n\n解决这个方法其实很简单，我们只需要根据待排序数据的大小动态设置gap就可以了，比如gap=n/2\n这时候就可以进行这么一个操作：每次预排序过后就改变一下gap，直到最后gap=1执行一次插入排序，数列有序\n\n落实到代码上，我们只需要把插入排序中所有和1有关的操作都改成gap，就实现了希尔排序\n\n这里需要注意的是gap的范围，因为我设置的是gap每次都/3，所以在最后可能会出现gap=2/3=0的情况，这时候其实排序还没有结束，但已经跳出循环了。我们需要在末尾+1保证最后一次插入排序的gap=1\n\n// 希尔排序void ShellSort(int* a, int n){    //只要把插入排序中的1全部改成grap，就能形成一次间隔为3的预排序    //当grap=1时，效果同插入排序相同    int grap = n;    // 当grap=1，说明上一把已经是一次直接插入排序了    // 此时数据已经有序，退出循环    while (grap &gt; 1)    {        grap=grap/3+1;//每一次都÷3,再+1；防止grap=2/3=0的情况        for (int i = 0; i &lt; n - grap; i++)        {            int end = i;            int tmp = a[end + grap];            while (end &gt;= 0)            {                if (tmp &lt; a[end])                {                    a[end + grap] = a[end];                    end -= grap;                }                else                    break;            }            a[end + grap] = tmp;        }    }}\n\n希尔排序的时间复杂度不好确定，因为我们通常会选取不同的gap，导致时间效率也不同。不过大部分资料中给出的时间复杂度如下👇到在“菜鸟教程”网，有对希尔排序时间复杂度的解析👉传送门\n\n\n2.选择排序2.1直接选择基本思路：遍历一遍数组，从中找出最大或最小的那一个数，然后将其放在数组前端。下一次遍历的时候，不再遍历这个数。\n注意：得到最大最小值后，需要将其和数组开头（或者结尾）的数进行交换，而不能直接覆盖，不然会出现数据丢失\n\n这个排序的思路非常好理解。进一步拓展，如果我一次遍历选出两个数，将最大值放在数组尾部，最小值放在数组开头，就可以减少一半遍历的次数。\n// 数据交换void Swap(int* a, int* b){    int tmp = *a;    *a = *b;    *b = tmp;}// 直接选择排序void SelectSort(int* a, int n){    int max ,min;    int left = 0, right = n - 1;    while (left &lt; right){        max = min = left;//存放下标便于后面的交换        for (int i = left; i &lt;= right; i++)        {            if (a[i] &gt;=a[max]){                max= i;            }            if (a[i] &lt;= a[min]){                min= i;            }        }        Swap(&amp;a[min], &amp;a[left]);        if (max == left) {            max = min;        }//如果max数据在开头，第一次交换会被替换        //所以需要重定向max的位置，再交换max        Swap(&amp;a[max], &amp;a[right]);        left++;        right--;    }}\n\n不过，这个算法需要多次遍历数组，效率自然低的离谱，堪比冒泡（甚至比冒泡还拉）\n\n时间复杂度：O(N^2^)\n空间复杂度：O(1)\n\n\n2.2堆排序堆排序是指利用二叉树-堆这种数据结构来进行选择数据的一种排序算法，它是选择排序的一种。\n需要注意的是：升序要建大堆，排降序建小堆\n堆排序已经在之前的博客中讲解过，点击下方连接即可查看！👇\n\n【C语言】什么是堆？堆排序和TopK问题又是如何实现的\n\n这里给出堆排序的源码，或许聪明的你看源码就能看懂呢？\n//交换数组中两个元素的位置void Swap(int* pa, int* pb) {    int tmp = *pa;    *pa = *pb;    *pb = tmp;}// 打印数组void PrintArray(int* a,int n,const char*info){    printf(\"[%s] \",info);    for(int i=0;i&lt;n;i++)    {        printf(\"%d \",a[i]);    }    printf(\"\\n\");}// 堆排序void AdjustDown(int* a, int n, int root){    assert(a);    int parent = root;    int child = parent * 2 + 1;//左孩子    while (child &lt; n){        //找左右孩子中小(大)的那一个        if (child + 1 &lt; n &amp;&amp; a[child] &lt; a[child + 1])        {//如果左孩子大(小)于右孩子，则选择右孩子            child++;        }        // 这个也需要根据上方 a[child] &lt; a[child + 1] 大于小于的不同进行修改        // 大堆，将大的往上调        // 小堆，将小的网上调        if (a[child] &gt; a[parent]){            Swap(&amp;a[child], &amp;a[parent]);            parent = child;            child = parent * 2 + 1;        }        else{            return;        }    }}// 升序用大堆// 降序用小堆void HeapSort(int* a, int n){    // 向下调整--建堆 O(N)    for (int i = (n - 1 - 1) / 2; i &gt;= 0; --i){        AdjustDown(a, n, i);//此时建的是一个小堆    }    PrintArray(a, n,\"建堆后\");    size_t end = n - 1;    while (end &gt; 0){        Swap(&amp;a[0], &amp;a[end]);//前后交换，最大的数放到末尾，不进行下一次调整        AdjustDown(a, end, 0);        end--;    }}\n\n使用如下的数据进行测试\nint main(){    int arr[]={1,5,7,3,8,6};    int sz = sizeof(arr)/sizeof(arr[0]);    PrintArray(arr,sz,\"初始值\");    HeapSort(arr,sz);    PrintArray(arr,sz,\"完成排序\");    return 0;}\n\n可以得到升序序列\n$ ./test[初始值] 1 5 7 3 8 6 [建堆后] 8 5 7 3 1 6 [完成排序] 1 3 5 6 7 8 \n\n\n3.交换排序3.1咕噜咕噜排序说道冒泡排序啊，那就是陪伴咱们C语言学习始终的一个老朋友了。\n在初识C语言的学习中，我曾写过一篇博客，里面讲解了用冒泡来模拟实现库函数qsort👉传送门\n\n它的思路就是对两个数进行比较，较大的数往尾部移动，较小的数字往头部移动\n\n在very very long time ago，我也写过关于冒泡排序的博客👇\n\n初识C语言==＞冒泡排序\n\n// 冒泡排序void BubbleSort(int* a, int n){    for (int i = 0; i &lt; n; i++)    {        int exchange = 0;        for(int j=0;j&lt;n-1-i;j++)        {            if (a[j] &gt; a[j + 1]){                exchange=1;                Swap(&amp;a[j], &amp;a[j + 1]);            }        }        if (exchange == 0){            break;           //如果单趟排序没有发生交换，说明此时已经有序        }    }}\n\n\n空间复杂度：O(N^2^)\n时间复杂度：O(1)\n\n\n3.2快速排序快速排序是Hoare于1962年提出的一种二叉树结构的交换排序算法。\n基本思想：任取待排序序列中的某个元素作为基准值，按照该基准值将待排序集合分割成两个子序列，左子序列中所有元素均小于基准值，右 子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。\n\n3.2.1 Hoare法发明快排的大佬给出了一个方法，假设0下标处为基准值key。用左右指针来遍历数组，右指针找到比key小的数后停下，左指针找找到比key大的数后停下，它们俩进行交换。\n最后left和right相遇的时候，左右序列就已经排好了，此时将key与它们相遇的位置进行交换。新的序列key的左边小于key，右边大于key（此时不一定有序）\n\n疑问：既然最后要将相遇位置和key进行交换，那要怎么保证相遇位置小于key？\n答：通过右指针先走来实现！\n\n可能说完思路后，你还是不太了解这左右指针是怎么走的，别着急，来康康我画的动图👇\n\n因为是右指针先走，所以右指针停下的位置，一定是小于key的位置。此时只会是L来相遇R，不可能是R往左遇到L（因为L停下的位置大于key，在这个位置的右边不可能没有一个小于key的值）\n比如下图所示，如果L的位置右边只有一个比key小的值，那R在第一趟就会来到2的位置，然后L向右走一步与R相交，直接交换\n\n两种极端情况也会有下面的两种极端情况\n\nkey右侧没有比key小的值，那么R会直接与L相交，再原地交换key\nkey右侧没有比key大的值，R先移动（原地不动），L直接与R在末尾相交，前后交换\n\n这两种极端情况，就是快排的弱势所在，在后头会讲述如何优化key的选则，来避免这种极端情况\n\n下面给出hoare法的代码，中间的代码是一趟hoare排序的实现，而在末尾，我们递归排序key的前半区域和后半区域，一直递归到最小区间：【区间只有一个值，或者区间不存在】\nvoid QuickSort1(int* a, int begin, int end)//hoare{    if (begin &gt;= end){        return ;//分治的末端条件判断    }    //一趟排序    int left = begin, right = end;    int keyi = begin;    while (left &lt; right)    {        while ((a[right] &gt; a[keyi])&amp;&amp;(right&gt;=begin))        {            right--;        }        while ((a[left] &lt;= a[keyi])&amp;&amp;(left&lt;right))        {            left++;        }        Swap(&amp;a[left], &amp;a[right]);    }    Swap(&amp;a[left],&amp;a[keyi]);    keyi = left;//必须移动keyi的位置    //递归排序左右区间    QuickSort1(a, begin, keyi-1);    QuickSort1(a, keyi + 1, end);}\n\n3.2.2 挖坑法挖坑法的思路比Hoare更好理解，详情见👇动图\n\n我们先用一个变量保存key的值（不是保存下标），然后R先走找比key小的，与坑位交换，L找比key大的，与坑位交换。最终LR相遇的时候，把key放回相遇位置，就完成了一趟排序\n\n注意：图中为了便于理解，将坑位用空白表示。实际在内存中操作的时候，坑位可以一直是key的值，不需要真的把它移走或者删除\n\n怎样？是不是比方法1好理解一些呢？\n下面给出挖坑法的代码示例\n//挖坑void QuickSort2(int* a, int begin, int end){    if (begin &gt;= end) {        return;    }    int left = begin, right = end;    int keyi = a[begin];//先存放keyi的值    int pit = begin;//pit作为坑位    while (left &lt; right)    {        while ((a[right] &gt; keyi) &amp;&amp; (right &gt;= begin))        {            right--;        }        Swap(&amp;a[pit], &amp;a[right]);        pit = right;        while ((a[left] &lt;= keyi) &amp;&amp; (left &lt; right))        {            left++;        }        Swap(&amp;a[pit], &amp;a[left]);        pit = left;    }    QuickSort2(a, begin, pit - 1);    QuickSort2(a, pit + 1, end);}\n\n3.2.3 前后指针法这部分就不画动图了，不知下面的这种方式能不能讲解清楚呢？\n\n\n这里需要弄明白的是cur和prev是分别在什么情况下移动\n\ncur比key小的时候，prev往后++一位，二者交换（在刚开始的时候是原地交换，但在图4中就不是原地交换了）\ncur比key大的时候，prev不动，cur继续往后++，直到找到比key小的数或者越界后停止（如果找到比key小的，就执行上一步的交换）\n最终cur越界了，交换prev和key的数据，一趟排序完成\n\n\n下面给出前后指针法的代码示例\nvoid QuickSort3(int* a, int begin, int end)//前后指针{    if (begin &gt;= end) {        return;    }    int keyi = begin;    int prev = begin, cur = begin + 1;    while (cur &lt;= end)    {        while ((a[cur] &lt; a[keyi]) &amp;&amp; (a[++prev] != a[cur]))        {            Swap(&amp;a[prev], &amp;a[cur]);        }        cur++;    }    Swap(&amp;a[prev], &amp;a[keyi]);    keyi = prev;    QuickSort3(a, begin, keyi - 1);    QuickSort3(a, keyi + 1, end);}\n\n优化极端情况上面提到了快速排序有两种极端情况，我们可以用一个操作来优化它：\n既然key取数组首或尾部都可能会遇到它的后面没有比它小（或大）的数，那我们就让key尽量作为数组有序后应该处于中部的数来作为key\n这时候不能直接选取待排序数组中部的数，因为它不一定是数值正好的那个\n我们可以选取数组开头、末尾、中间的3个数进行比较，再选择这3个数里面居中的那个数作为我们的key，这样就能避免无效遍历！\nint GetMid(int* a, int left, int right){    int mid = (left + right) / 2;    if (a[left] &lt; a[mid])    {        if (a[mid] &lt; a[right]){            return mid;        }        else if (a[left] &gt; a[right]){            return left;        }        else{            return right;        }    }    else // a[left] &gt; a[mid]    {        if (a[mid] &gt; a[right]){            return mid;        }        else if (a[left] &lt; a[right]){            return left;        }        else{            return right;        }    }    return -1;//其实这个没啥意义}\n\n但是单纯加上这个代码并不可行，因为这时候的key不再处于序列开头了，也就意味这我们后头的代码都需要重新写一遍！\n\n这不坑爹吗这是？！\n为了不没事找事重写一遍代码，这里直接把找到的MID和left进行交换就OK了！\n\n同时，为了避免多次递归导致栈溢出，我们还可以设置一个条件，在序列长度小于10的时候调用其他排序（比如插入排序）来实现后面的排序操作\n3.2.4快排的时间/空间复杂度快排的递归调用非常类似链式二叉树的前序遍历，它一共会递归logN层级，每一层加起来都有N个数，这样就能算出它的时间复杂度\n\n时间复杂度：O(N*logN)\n空间复杂度：O(logN)，这个是递归开辟栈帧的空间消耗\n\n\n3.3快排非递归实现这部分的知识就比较深奥了，你可以先看看这篇博客，了解一下函数调用的时候会发生什么👉传送门\n\n但不要担心，其实它的思路并没有那么难！\n\n首先需要先搞明白，递归调用的本质是在操作什么？\n在快排中，递归调用的本质是让程序自己来缩小排序的范围，再逐步扩大\n那我们可不可以利用数据结构中的栈，来模拟实现程序运行中的递归操作呢？\n\n排序完一趟后，将下一趟的左右范围入栈\n程序先调用存放在栈顶的右边范围进行排序，并把这个范围的左右小区间再次入栈\n最后右边的区间已经不可再分，就开始返回调用左边区间\n\n这个操作就犹如链式二叉树的后序遍历，先递归访问右节点，再往回返回左节点\n最后得到的结果就是类似递归调用完毕后的结果\n\n\n如果你还没有学习数据结构里面的栈，点我速览！\n\n下面给出一个非递归的实现：\n// 非递归void QuickSort4(int* a, int begin, int end){    Stack st;    StackInit(&amp;st);    StackPush(&amp;st, begin);    StackPush(&amp;st, end);    while (!StackEmpty(&amp;st))    {        int right = StackTop(&amp;st);        StackPop(&amp;st);        int left = StackTop(&amp;st);        StackPop(&amp;st);        int keyi = PartSort3(a, left, right);        // [left,keyi-1][keyi+1，right]        if (left &lt; keyi-1)        {            StackPush(&amp;st, left);            StackPush(&amp;st, keyi-1);        }        if (keyi + 1 &lt; right)        {            StackPush(&amp;st, keyi+1);            StackPush(&amp;st, right);        }    }    StackDestory(&amp;st);}\n\n注意：因为这里需要得到一趟递归调用后返回的keyi，所以我们需要把之前写的一趟快排单独拿出来，并设置返回值\n\n来调用一下试试，成功了！\n\n\n4.归并排序基本思想：采用分治递归，将已有的子序列合并，得到一个有序的序列。即先使每个子序列有序，再使子序列段间有序\n\n若将两个有序表合并成一个有序表，称为二路归并\n\n实现的步骤如下图\n\n\n先将区间通过递归分割成分治末端（只有一个值）\n再对相邻两个区间进行比较，开辟一个新的数组，依次将两个区间中小的那个按顺序摆放在新的数组中，再拷贝回原数组，就实现了归并\n当区间不存在的时候，开始返回递归，直到序列有序\n\n4.1打印printf调试大法这里最需要注意的就是分治的序列区间问题，如果代码不对，就很容易形成越界访问！\n这里我们可以通过printf调试大法来实现，打印出每一层递归时的区间，就能发现可能存在的越界访问问题。这种方法还能帮助我们理解分治递归\nprintf(\"[%d,%d][%d,%d]\\n\", begin, mid, mid+1, end);\n\n\n\n如果你在写程序的时候，发现控制台的光标闪动了很久都没有打印出数据，那么多半是程序中有死循环和bug\n\n比如现在，我们初步查看递归调用中是没有出现越界的，但是答案错误，进一步调试发现，tmp数组中有序数字，并没有被我们完整的拷贝回去\n原本是2 5拷贝回去变成了2 2，这个问题的根源很明显是memcpy函数调用有问题\n\n一看，哭笑不得，写了俩sizeof，魔怔了属于是\n\n修改之后，没问题啦！\n\n\n4.3非递归实现归并排序的非递归无法用栈来实现，因为我们不能把之前的大区间全给出栈了，因为这些区域还需要在最后重新进行归并！\n\n利用循环来控制不同的区间，由小到大，直到gap=n跳出循环\ngap是归并数据的个数，gap=1代表1个数归并，gap=2代表两两归并\n\n\n根据上面的思路，我们可以写出下面的范围循环\nint gap = 1;while (gap &lt; n){    // 间距为gap是一组，两两归并    for (int i = 0; i &lt; n; i += 2 * gap)    {        int begin1 = i, end1 = i + gap - 1;        //i+gap是个数，再-1是下标        int begin2 = i + gap, end2 = i + 2 * gap - 1;        //i+gap到i+2gap是个数，再-1是下标        //打印调试大法        printf(\"归并[%d,%d][%d,%d] -- gap=%d\\n\", begin1, end1, begin2, end2, gap);    }    gap *= 2;}\n\n跑一遍之前的测试用例，发现能搞定！这不就完事了吗？\n\n并没有！这里gap的操作都是*2，而且我们给的数组是偶数个，正好对的上\n如果我们再加一个数呢？程序打印出了每一层的递归区间，但是没有打印出最终的结果——因为这里在最后free的时候发现了数组越界访问\n\n小知识，数组越界一般都是在free的时候检查到的\n\n\n\n\n接下来要做的事就是控制下标区间，避免它越界\nint begin1 = i, end1 = i + gap - 1;int begin2 = i + gap, end2 = i + 2 * gap - 1;\n\n\n\n\nbegin\nend\n\n\n\ni\ni+gap-1\n\n\ni+gap\ni+2*gap-1\n\n\n仔细分析过后，发现当gap=2,i=8的时候，就会出现+gap之后越界的情况\n\n而会出现越界情况的，不止有end2，end1和begin2都可能会出现\n我们需要做的就是把越界的下标修正为不越界的下标\n\nend1越界，修正为不越界即可\nbegin2和end2都越界，修正为非法区间begin2&gt;end2\nbegin2不越界，end2越界，修正end2即可\n\n修正下标后，可以看到程序已经正常排序出了序列\n虽然打印出来的范围还是有越界的下标，但是这个是begin&gt;end的非法区间，不符合程序运行的条件，就不会产生越界\n\n4.3.1 条件断点这里还有一个骚操作，比如我们已经知道了是8-9的下标越界，这样我们就可以设置一个断点，来直接F5跳到那个情况，而不需要疯狂按F10\n// 条件断点，用于调试if (begin1 == 8 &amp;&amp; end1 == 9 &amp;&amp; begin2 == 10 &amp;&amp; end2 == 11){    int x = 0;}\n\n\n这样我们的非递归实现也搞定啦！\n//非递归void MergeSortNonR(int* a, int n){    int* tmp = (int*)malloc(sizeof(int) * n);    int gap = 1;    while (gap &lt; n)    {        // 间距为gap是一组，两两归并        for (int i = 0; i &lt; n; i += 2 * gap)        {            int begin1 = i, end1 = i + gap - 1;//i+gap是个数，-1是下标            int begin2 = i + gap, end2 = i + 2 * gap - 1;//i+gap到i+2gap是个数，-1是下标            if (end1 &gt;= n) {                end1 = n - 1;            }            if(begin2&gt;=n){                begin2 = n;                end2 = n - 1;            }            if (begin2 &lt; n &amp;&amp; end2 &gt;= n) {                end2 = n - 1;            }            //printf(\"归并[%d,%d][%d,%d] -- gap=%d\\n\", begin1, end1, begin2, end2, gap);            int index = i;            while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)            {                if (a[begin1] &lt; a[begin2])                    tmp[index++] = a[begin1++];                else                    tmp[index++] = a[begin2++];            }            while (begin1 &lt;= end1)                tmp[index++] = a[begin1++];            while (begin2 &lt;= end2)                tmp[index++] = a[begin2++];        }        memcpy(a, tmp, n * sizeof(int));        gap *= 2;    }    free(tmp);}\n\n4.2递归源码这里给出最终的源码，一些地方写了注释\n//_代表这是子函数void _MergeSort(int* a,int* tmp, int begin, int end){    if (begin &gt;= end){        return;    }    int mid = (begin + end) / 2;    _MergeSort(a, tmp, begin, mid);    _MergeSort(a, tmp, mid+1 , end);    //printf(\"归并[%d,%d][%d,%d]\\n\", begin, mid, mid+1, end);    int begin1 = begin, end1 = mid ;    int begin2 = mid+1 , end2 = end;    int cur = begin;    while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)    {        //取小的放到新数组中        if (a[begin1] &lt; a[begin2]) {            tmp[cur++] = a[begin1++];        }        else {            tmp[cur++] = a[begin2++];        }    }    //第一个循环结束，并不代表归并完毕，可能只有一个数组的数据跑完了    //我们需要将另外一个数组的数据全部拷贝到tmp中（因为剩下的的数据已经有序）    while (begin1 &lt;= end1) {        tmp[cur++] = a[begin1++];    }    while (begin2 &lt;= end2) {        tmp[cur++] = a[begin2++];    }    memcpy(a+begin,tmp + begin, ((end - begin +1)*sizeof(int)));}//归并排序void MergeSort(int* a, int n){    int* tmp = (int*)malloc(n * sizeof(int));    if(tmp==NULL){        printf(\"malloc failed\\n\");        exit(0);    }    _MergeSort(a, tmp, 0, n-1);    free(tmp);    tmp = NULL;    return;}\n\n4.4归并排序的时间/空间复杂度\n时间复杂度：O(N*logN)\n空间复杂度：O(N)，创建数组的消耗\n\n\n5.计数排序计数排序的基本思路：利用数组的下标作为映射，遍历到x，在数组的x下标处++一次。最后再依照下标顺序将之前遍历到的数倒出来，就形成了正序序列。\n我在网上找来了一个很棒的动图（这个好像在很多博客里面都有😂）\n\n\n这个排序的思路就不难了，但有一点我们可以优化一下\n\n假设我们的序列是从300开始，而不是从0开始，那么开辟一个301个数的数组显然会浪费300之前的下标（因为并没有值）\n这时候我们可以找出数组的范围，开辟一个对应范围长度的数组，再利用相对映射的方式，来进行计数\n\n最后的代码如下\nvoid CountSort(int* a, int n){    int min = a[0], max = a[0];    for (int i = 1; i &lt; n; ++i)    {        if (a[i] &lt; min)            min = a[i];        if (a[i] &gt; max)            max = a[i];    }    int range = max - min + 1;    int* count = (int*)malloc(sizeof(int) * range);    assert(count);    memset(count, 0, sizeof(int) * range);    // 计数    for (int i = 0; i &lt; n; ++i)    {        count[a[i] - min]++;    }    // 排序    int j = 0;    for (int i = 0; i &lt; range; ++i)    {        while (count[i]--)        {            a[j++] = i + min;        }    }}\n\n5.1计数排序的特性\n时间复杂度：O(range+N)\n空间复杂度：O(range)\n\n计数排序适用于范围集中的数，不然会产生很大的空间浪费\n计数排序可以排序带负数的序列，同样是通过映射的方式\n但是计数排序只能排序整型数据，浮点类型是搞不定的\n\n看到这里，我们的八大排序就已经讲解完毕啦！\n不知道我讲解的够不够清楚呢？\n\n下面还有一个小点，就是关于排序算法的稳定性\n6.排序算法的稳定性估计很多人和我一样，都对这个“稳定性”有错误的理解\n我本来以为，稳定性代表的是排序算法的时间波动大不大\n实际上的稳定性，是算法对于某一个数的处理好不好；\n比如下图，假设大家在考试，从上到下依次是交卷的顺序，我们发现王舞和李四的成绩相同，但是李四先交的卷。对于评判来说，当然是先交卷且分高的同学牛逼一点\n所以依照分数排序的时候，我们应该把李四排在王舞之前（即相同的数据在排序前后的位置不被改变）\n \n但有些算法在排序的时候，就做不到这一点\n这里对直接选择排序做一个简单的解释\n\n因为两个3的位置调换，就导致排序不够稳定\n实际上，所有需要进行选择交换的排序都不够稳定\n\n但是冒泡排序在交换的时候是严格保证大的数在后头，相等的数不交换的思路，所以冒泡排序是稳定的\n\n6.1 稳定性表格\n\n\n排序算法\n稳定性\n排序算法\n稳定性\n\n\n\n直接插入\n稳定\n希尔\n不稳定\n\n\n冒泡\n稳定\n直接选择\n不稳定\n\n\n归并排序\n稳定\n堆排序\n不稳定\n\n\n-\n-\n快速排序\n不稳定\n\n\n-\n-\n计数排序\n不稳定\n\n\n6.2 时间复杂度表格\n7.利用clock函数查看排序耗时排序算法写完后，我们可以通过调用clock函数来查看每一个排序的耗时\n先利用srand和time函数来创建随机数数组，在调用每一个函数，来查看它们排序的耗时\n\n由于代码过长，这里只给出某一个排序的计时代码，其他就CV一下就OK了\nsrand(time(0));const int N = 10000;int* a1 = (int*)malloc(sizeof(int) * N);for (int i = 0; i &lt; N; ++i){    a1[i] = rand();//生成随机数 数组}int begin1 = clock();//读取系统时钟InsertSort(a1, N);int end1 = clock();//再读取系统时钟//二者相减得出该函数运行时长printf(\"InsertSort:%d\\n\", end1 - begin1);free(a1);\n\n运行结果：\n\n结语到这里，排序的绝大数知识点就讲解完毕啦！\n本篇博客画了很多图，还挺不容易的，还请大家点赞支持一下！\n\n特别是那两个看起来很简单的动图，实际上麻烦的很\n\n球球了，点个赞呐！\n\n","categories":["数据结构太复杂"],"tags":["C语言","算法","排序","数据结构"]},{"title":"【C++】图","url":"/posts/1235355339/","content":"本文包含了图的基本概念\n\n\n1.相关概念1.1 无&#x2F;有向无向图：每一个顶点之间的连线没有方向\n有向图：连线有方向（类似离散数学的二元关系 &lt;A,B&gt;代表从A到B的边，有方向）\n&lt;A,B&gt;中A为始点，B为终点\n\n在无向图中，(V,U)和(U,V)是同一条边\n1.2 顶点和边图中的节点叫做顶点。\n顶点之间的线条就是边，表示事物与事物之间的关系。\n\n1.3 自回路&#x2F;多重图\n1.4 完全图图中每一个顶点都有连线（有最多的边数）就叫做完全图\n设顶点为N个\n\n无向完全图中n(n-1)/2条边\n有向完全图中n(n-1)条边\n\n1.5 邻接与关联无向图中(u,v)是一条边\n\n顶点u和v邻接\n边(u,v)与顶点u和v相关联\n\n1.6 子图\n图中G3是G1的子图，G4是G2的子图\n简单说来，就是子图是原图的一部分，包括顶点、边（注意方向）都是原图中的一部分\n1.6 路径路径是顶点序列\n路径是一个节点到另外一个节点需要经过的边\n\n路径长度：路径上边的数目\n简单路径：除起点、终点可以相同外，路径中其余顶点不相同\n回路：起点和重点相同的简单路径\n\n1.7 连通图两个顶点之间只要有路径，那就是连通的\n\n连通图：无向图中任意两点之间都有路径，那么就是一个连通图\n连通分量：无向图的极大连通子图\n\n\n注意，虽然连通分量被称为“极大连通子图”，但它并不是节点最多的哪一个。比如上图中的G2和G3都是极大连通子图。\n\n\n强连通图：有向图中，如果两个顶点之间U和V之间有U到V的路径，那就一定有从V到U的路径\n强连通分量：有向图的极大联通子图\n\n\n强连通图G1的极大强连通分量就是它自己（只有非强连通图才有多个强连通分量）\n上图中G2就不是强联通图，因为4节点没有入边（也就没有节点能到4）\n\n第三图的上半部分并非G1的强连通分量，但是是G2的强力连通分量。\n同时，单独的4顶点也是一个强连通分量（单独顶点都是）\n\n1.7 顶点的度度：与该顶点相关联的边的数目\n\n入度：射入v的边的数目\n出度：从v射出去的边的数目\n\n1.8 生成树生成树包含图中的所有顶点，但是只有足够构成一颗树的n-1条边\n\n因为n-1条边再加上一条就会构成回路\n生成树中不包含回路\n\n1.9 网给图中的每条边都添加上权值，带权的图称为网\n2.表示法2.1 邻接矩阵用二维数组来表示每个顶点之间的关系（矩阵）\n\n优缺点优点\n\n便于判断两个顶点之间是否有边，可以直接根据下标判断，O(1)\n便于计算各个顶点的度\n无向图：第i行元素之和就是顶点i的度（前提是用1来表示）\n有向图：第i行元素之和为顶点i的出度；第i列为入度\n\n\n\n缺点\n\n如果节点多，边少，就会出现空间浪费\n无法方便地找到一个顶点和那一条边相连（需要遍历）\n对于无向图，也会出现空间浪费\n\n2.2 邻接表邻接表有些类似于哈希表的拉链法。每一个节点后面跟着一个单链表，用于存储与这个节点相连的节点。\n在G2的有向图中，一般存储的是出度表，即从该节点出发的边。如果边有权值，则还需要存储权值\n\n优缺点优点：\n\n可以快速找到一个节点和谁相连（出度）\n\n缺点\n\n不便于判断两个顶点之间是否有边\n不便于计算有向图各个顶点的度（需要遍历所有节点）\n\n关于第二个缺点，可以新增一个入度表（即一个出度表&#x2F;一个入读表）来计算。但是这样会增加时空复杂度。\n3.遍历3.1 深度优先DFS深度优先以递归为基本思路，从一个结点开始，递归向后遍历这个节点的单链表中的节点。\n\n为了避免同一个节点遍历多次，我们需要有一个bool数组来标识一个节点是否遍历过。如果遍历过，则把对应下标的值设定为true来标识\n由于深度优先的递归部分只能遍历连通图。若出现了上图中非联通的情况，需要我们在外循环中重新遍历一下bool标识数组，确认所有节点都遍历完成。\n如果漏了节点（就是没有和其他节点联通的独立节点）那么就以此节点开头再进行一次深度遍历。\n\n3.2 广度优先BFS\n广度优先遍历类似二叉树的层序遍历，依靠循环+队列来完成遍历\n\n入起始节点，打印起始节点的值\n出队头节点（第一次的时候是起始节点）往队列中入该节点单链表中的所有节点\n依此类推，出一个节点，就入这个节点单链表中的所有节点\n同样地用一个bool数组标识节点是否被访问。如果被访问了则跳过该节点\n也需要在队列循环结束后遍历一遍bool数组，确认所有节点都访问完毕。\n\n\n3.3 判断一个图是否连通使用任何遍历方式，遍历完毕后检查bool数组\n若有节点没有被访问，则说明是非连通图\n4.拓扑排序\nhttps://blog.musnow.top/posts/1720780208/\n\n给定一个图，每次都选择一个无入度（没有入边）的节点加入序列中，并删除该节点的出边\n最终得到的序列就是一个拓扑排序之后的序列\n\n每次删除出边后，都可能形成新的无入度的节点\n\n因此，针对同一棵树的拓扑排序序列，可能有多种不同的情况\n5.最小生成树算法生成树的概念参考 1.8 生成树，最小生成树即让生成树中所有边的权值加起来最小\n5.1 普里姆Prim\n如图中所示，我们先根据这个树的结构构造三个数组\n\nnearest代表和这个节点最近的节点（默认为-1）\nlowcost代表和这个节点最近节点的权值（默认为无穷大）\nmark是一个bool数组，标识该节点是否已经加入到最小生成树\n\n当我们每从图中取出一个节点的时候，就需要更新这三个表\n如图，当我们取走0之后，就需要更新和0连通的三个节点，其中nearest代表刚刚删除掉的节点0，lowcost代表它们和0相连边的权值；同时要把mark中0改为true，表明0已经加入生成树了\n\n第二次选取的时候，遍历lowcost表，找到权值最小的边为(0,2)权值为1。此时就把2加入进去，并更新与2相连的节点3（注，必须要权值更小才需要更新）\n\n依次遍历，直到所有节点都加入了最小生成树（左下角的图）\n\n该算法的时间复杂度为O(N^2)，只与节点的数量N有关\n5.2 克鲁斯卡尔Kruskal\n构建一个和原图一样的节点图（无边）在原图中查找权值最小的边，判断其节点是否已经相同，如果没有形成环，则加入到最小生成树的图中\n\n判断是否成环可以通过并查集解决\n\n如下图，先遍历所有边，发现(0,2)的权值最小，判断该边加入后并不会使生成树形成环，则加入该边\n\n下图中(0,2)之间的边1已经移动到了T图上\n同时将0和2加入到同一个并查集的合集内\n\n\n同理继续找权值最小的边，加入到生成树中。如下，将3边移动到右图。\n\n此时我们遇到了3条权值最小的边，权值都为5。此时可以随便加入一条边即可（不能使生成树成环）\n如下图中(0,3)和(2,3)的边加入后会使图成环，不能选择该边\n\n并查集中0、2、3、5已经在一个集合中，此时判断(0,3)在一个集合，该边不能加入；(2,3)在一个集合中，该边不能加入\n\n\n应该选择(1,2)这条边，其不会让树成环\n\n此时所有边都已经连起来了，最小生成树生成成功\n算法分析\n\n该算法的时间复杂度为O(E*logE)，其中E为边的数目\n6.最短路径带权有向图中，把一条路径（仅考虑简单路径）上所经边的权值之和定义为该路径的路径长度\n从源点到终点可能不止一条路径，把路径长度最短的那条路径称为最短路径\n6.1 单源最短路径思路有些类似并查集，path数组中存放的是每一个节点的上一条路径，若下标1处存放0，则代表是从0走到1。同时d数组中标识从0走到下标1的长度。\n\n把1加到s序列之后，发现0到节点2的路径长度缩短了，从原本的(0,2)的6变成了现在(0,1)+(1,2)的4+1=5，长度缩短，对应d数组中下标2处也需要更新\n继续下去，直到U数组中没有节点，S数组中节点满，即可获得一个从0出发到任何节点的单源最短路径\n\n6.1.1 狄克斯特拉算法Dijkstra求解单源最短路径问题的算法\n前提：给定一个带权有向图G和源点v，限定各边上的权值大于等于0\n基于定理：最短路径上的顶点的最短路径就是该路径\n\n理解：现有一条v到u的最短路径v-&gt;……-&gt;a-&gt;u，那么v到a的最短路径即为v-&gt;……-&gt;a\n\n算法思路把图G中的顶点集合V分成两部分：\n第一部分，为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径v，……，u，就将u加入到集合S中，直到全部顶点都加入到S中，算法结束）\n第二部分，为其余未求出最短路径的顶点集合（用U表示）\n过程：\n\n初始化：S只包含源点即S&#x3D;{v}，v的最短路径为0。U包含除v以外的其他顶点，U中顶点i距离为边上的权值（若v与i直接相连）或∞（v与i不是直接相连）\n\n\n\n从U中选取一个距离v最小的顶点u，把u加入S中（该选定的距离就是v到u的最短路径长度）\n\n\n\n\n以u为新考虑的中间点，修改U中各顶点i的最短路径长度\n\n\n若从源点v到顶点 i的最短路径长度（经过顶点u）比原来最短路径长度（不经过顶点u）短，则修改顶点 i的最短路径长度\n\n\n\n重复2、3步，直至所有顶点都包含在S中\n\n代码设计着重解决两个问题：\n\n如何存放最短路径长度？\n\n用一维数组d[i]存储。源点v默认，d[i]表示源点到顶点i的最短路径长度\n\n如d[2]&#x3D;12表示源点到顶点2的最短路径长度为12\n\n\n如何存放最短路径？\n\n用一维数组path[]存储。path数组中所存储的数组代表当前顶点在最短路径中的前驱顶点\n\n如path[3]&#x3D;1，表示在最短路径中，顶点3的前驱顶点是顶点1\n\n算法演示\n这是初始化状态\n发现数组d中顶点1距离源点距离最近，那么就将顶点1加入到S中\n\n这时，我们需要更新剩余点的最短路径长度和最短路径\n显然，顶点2，3，4，5，6并不会都做更新。只有与顶点1直接相连的顶点才有可能会受影响。在上图中会受影响的为顶点2和顶点4\n\n原本顶点2的最短路径长度是6，最短路径是&lt;0,2&gt;。现在由于顶点1的引入，最短路径长度变为5，最短路径变为&lt;0,1&gt;,&lt;1,2&gt;\n顶点4同理！\n至此，就完成了一次顶点的引入。下面重复上述操作至所有顶点都在S中即可\n下面是全过程：\n\n\n\n&#x3D;&#x3D;总结一下：在更新d和path数组时，只有与本次引入S中的顶点i直接相连的后驱顶点才有可能发生改变，其余顶点是不可能变的&#x3D;&#x3D;\n现在我们利用d和path数组来求解最短路径长度和最短路径：\n\n求源点0到终点6的最短路径长度\n\n即为d[6]的值，为16\n\n求0到6的最短路径\n\n\n从终点往源点找\n时间复杂度时间复杂度为 O(n2)\n","categories":["数据结构太复杂"],"tags":["C++","数据结构","图"]},{"title":"【C语言】顺序表（详解）","url":"/posts/1519855244/","content":"[TOC]\n前言顺序表是我们学习数据结构第一阶段的必经之路\n什么是顺序表，且听我慢慢道来\n本篇博客用到的知识点：\n\n动态内存管理\n自定义类型-结构体\n所用编译器：VS2019\n\n\n1.什么是顺序表？1.1线性表线性表是数据结构的一种，它是n个具有相同特性的数据元素的有限序列。 常见的线性表：顺序表、链表、栈、队列、字符串……\n线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理内存上存储时，通常以数组和链式结构的形式存储。\n本篇博客所讲述的顺序表，就是以数组结构存储的线性表\n\n\n2.编写你的顺序表！为了保证写完之后不要进入贤者debug状态，建议每编写一个模块，就在test.c的main函数中进行测试，保证当前编写的模块正确后再进行下一步！\n不然问题多了，改起来很头疼的！\n\n2.0 赛前准备和我们日常所用的数组不同，顺序表的这个结构，主要的组成部分是一个结构体（本篇博客中的线性表以int为例）\nstruct SeqList&#123;\tint* a;\tint size;     // 存储数据个数\tint capacity; // 存储空间大小&#125;;\n\n为了方便使用，我们可以使用typedef对符号进行重定义\ntypedef int SLDataType;//和普通的整型区分开，以此命名的数据和顺序表直接相关//动态顺序表typedef struct SeqList&#123;\tSLDataType* a;\tint size;     // 存储数据个数\tint capacity; // 存储空间大小&#125;SeqList;//SeqList可以替代struct SeqList\n\n2.1 初始化本次编写顺序表代码，我们采用“多文件编程”方式，将函数的实现，函数的声明与主函数分开，分别放入两个源文件和一个头文件\n\n先在main函数中定义一个顺序表的结构体，编写SQLinst函数进行初始化\nSeqList s;//创建结构体变量SQLinst(&amp;s);//初始化\n\n在.h文件中，我们写入函数声明和库函数的引用。\n注意需要在另外两个.c文件中以&quot;Seqlist.h&quot;方式引用自定义头文件\n#include&quot;Seqlist.h&quot;\n\n\n初始化方式如下，我们先给a用calloc函数开辟3个SLDataType(int)类型的空间\n\nCAPA：由define定义的符号，方便后续修改初始容量\n\nvoid SQLinst(SeqList* sql)&#123;\tassert(sql);\tsql-&gt;a = (SLDataType*)calloc(CAPA,sizeof(SLDataType));\tsql-&gt;capacity = CAPA;\tsql-&gt;size = 0;\treturn;&#125;\n\n\n2.2 容量检查既然我们的函数是由calloc开辟的动态内存空间，就需要在顺序表内空间不够用的时候，检查容量，判断是否需要扩容\nvoid CheckCapacity(SeqList* sql)&#123;\tassert(sql);\tif (sql-&gt;size &lt; sql-&gt;capacity)\t\treturn;\telse\t&#123;\t\tsize_t newcapacity = 2 * (sql-&gt;capacity);\t\tSLDataType* tmp = (SLDataType*)realloc(sql-&gt;a,newcapacity*sizeof(SLDataType));\t\tif (tmp == NULL)\t\t&#123;\t\t\tprintf(&quot;realloc failed\\n&quot;);\t\t\texit(0);\t\t&#125;\t\telse\t\t&#123;\t\t\tsql-&gt;a = tmp;\t\t\tsql-&gt;capacity = newcapacity;\t\t&#125;\t&#125;\treturn;&#125;\n\n使用realloc函数的时候需要注意，它可能扩容失败，所以我们不能直接让sql-&gt;a来接收realloc函数的返回值（扩容失败返回NULL，相当于前功尽弃）\n而是需要用一个中间变量tmp来接收开辟后的地址，确认realloc成功后再赋值给a。同时，也需要将sql-&gt;capacity更改成新的容量\n\n2.3 打印顺序表void SQLprint(SeqList* sql)&#123;\tassert(sql);\tfor (int i = 0; i &lt; (sql-&gt;size); i++)\t&#123;\t\tprintf(&quot;%d &quot;, sql-&gt;a[i]);\t&#125;\tprintf(&quot;\\n&quot;);\treturn;&#125;\n\n2.4 尾插和尾删和平时使用数组不同的是，线性表中把在表尾插入数据称作尾插、删除数据叫做尾删，对应的是pushback和popback\n\n如果你看过之前我的那篇函数调用参数压栈的博客，应该还记得，汇编代码中入栈和出栈也是push和pop\n\nvoid SQLpushback(SeqList* sql, size_t x);//尾插void SQLpopback(SeqList* sql);//尾删\n\n实现方式很是简单，和我们日常在数组尾部插入元素相同\n需要注意的是，这里我们插入的数据是size_t（unsigned int)类型，也就是说，这个顺序表中并没有负数\nvoid SQLpushback(SeqList* sql, size_t x)&#123;\tassert(sql);\tCheckCapacity(sql);//使用时检查容量\tsql-&gt;a[sql-&gt;size] = x;\tsql-&gt;size++;\treturn;&#125;void SQLpopback(SeqList* sql)&#123;\tassert(sql);    //sql-&gt;a[sql-&gt;size] = 0;    //这里可以把最后一个数改为0，也可以不改\tsql-&gt;size--;\treturn;&#125;\n\n\n2.5 头插和头删和尾部修改数据不同，在头部修改数据，必须要把已有数据整体往后移动\n\nvoid SQLpushfront(SeqList* sql, size_t x)&#123;\tassert(sql);\tCheckCapacity(sql);\tint i = sql-&gt;size;\twhile (i &gt;= 0)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i - 1];\t\ti--;\t&#125;\tsql-&gt;a[0] = x;//整体后移 之后修改第一个数\tsql-&gt;size++;\treturn;&#125;void SQLpopfront(SeqList* sql)&#123;\tassert(sql);\tint i = 0;\twhile (i &lt; (int)sql-&gt;size)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i + 1];\t\ti++;//直接整体前移即可\t&#125;\tsql-&gt;size--;\treturn;&#125;\n\n2.6 插入和删除除了头尾的操作，我们还需要编写在顺序表中间的插入和删除操作\n\n插入：需要将插入位置之后的数据整体后移\n删除：删除位置之后的数据整体前移\npos：插入位置的下标\n\nvoid SQLinsert(SeqList* sql, size_t pos, size_t x)&#123;\tassert(sql);\tif (pos &gt;= (int)sql-&gt;size)\t&#123;//温和的判断，assert太过暴力，在OJ里容易出错\t\tprintf(&quot;input err\\n&quot;);\t\treturn;\t&#125;\tCheckCapacity(sql);\tint i = sql-&gt;size;\twhile (i &gt; (int)pos)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i - 1];\t\ti--;\t&#125;\tsql-&gt;a[pos]=x;\tsql-&gt;size++;\treturn;&#125;void SQLerase(SeqList* sql, size_t pos)&#123;\tassert(sql);\tif (pos &gt;= (int)sql-&gt;size)\t&#123;//温和的判断，assert太过暴力，在OJ里容易出错\t\tprintf(&quot;input err\\n&quot;);\t\treturn;\t&#125;\tint i = pos;\twhile (i &lt; (int)sql-&gt;size-1)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i + 1];\t\ti++;\t&#125;\tsql-&gt;size--;\treturn;&#125;\n\n2.7 查找和更改当我们需要查找的时候，必须从头开始遍历整个数组，来找到待查找元素\nint SQLfind(SeqList* sql, size_t x)&#123;\tassert(sql);\tfor (int i = 0; i &lt; sql-&gt;size; i++)\t&#123;\t\tif (sql-&gt;a[i] == x)\t\t&#123;\t\t\treturn i;//返回下标\t\t&#125;\t&#125;\tprintf(&quot;find err\\n&quot;);\treturn -1;&#125;\n\n而修改函数则是在查找的基础上，更改掉目标元素\nvoid SQLmodify(SeqList* sql, size_t pos, size_t x)&#123;\tassert(sql);\tsql-&gt;a[pos] = x;\t\treturn;&#125;\n\n如果用户不知道自己想修改的元素的下标，可以通过find函数查找，再调用修改函数\n\n3.菜单一个小建议是，不要在一开始编写函数的时候就写出菜单！\n因为这样非常不方便debug，你需要按菜单上的函数调用再进行下一步操作\n\n话说是不是应该在前面就告诉大家？😂\n\n\n菜单的使用需要配合switch&#x2F;case语句来执行，方便用户输入操作数进行函数调用\nvoid menu()&#123;\tprintf(&quot;*****************************\\n&quot;);\tprintf(&quot;******1.头插  2.尾插*********\\n&quot;);\tprintf(&quot;******3.头删  4.尾删*********\\n&quot;);\tprintf(&quot;******5.插入  6.删除*********\\n&quot;);\tprintf(&quot;******7.查找  8.更改*********\\n&quot;);\tprintf(&quot;******9.打印  0.exit*********\\n&quot;);\tprintf(&quot;*****************************\\n&quot;);&#125;\n\n我们可以在每个模块printf对应的提示，方便用户操作顺序表\nint main()&#123;\tSeqList s;//创建结构体变量\tSQLinst(&amp;s);//初始化#if\tM\ttest1(&amp;s);//测试函数#endif\t\tmenu();\tprintf(&quot;请输入命令&gt;&quot;);\tint option;\tscanf(&quot;%d&quot;, &amp;option);\tdo&#123;\t\tswitch (option)\t\t&#123;\t\tcase 0:\t\t&#123;\t\t\tSQLdestory(&amp;s);\t\t\tprintf(&quot;destory SQL\\n&quot;);\t\t\texit(0);\t\t&#125;\t\tcase 1:\t\t&#123;\t\t\tint x;\t\t\tprintf(&quot;请输入需要头插的数&gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;x);\t\t\tSQLpushfront(&amp;s, x);\t\t\tbreak;\t\t&#125;\t\tcase 2:\t\t&#123;\t\t\tint y;\t\t\tprintf(&quot;请输入需要尾插的数&gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;y);\t\t\tSQLpushback(&amp;s, y);\t\t\tbreak;\t\t&#125;\t\tcase 3:\t\t\tSQLpopfront(&amp;s);\t\t\tbreak;\t\tcase 4:\t\t\tSQLpopback(&amp;s);\t\t\tbreak;\t\tcase 5:\t\t&#123;\t\t\tint m, n;\t\t\tprintf(&quot;请输入插入位置和插入数&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;m, &amp;n);\t\t\tSQLinsert(&amp;s, m, n);\t\t\tbreak;\t\t&#125;\t\tcase 6:\t\t&#123;\t\t\tint d;\t\t\tprintf(&quot;请输入待删除数的位置&gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;d);\t\t\tSQLerase(&amp;s, d);\t\t\tbreak;\t\t&#125;\t\tcase 7:\t\t&#123;\t\t\tint f;\t\t\tprintf(&quot;请输入需要查找的数&gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;f);\t\t\tprintf(&quot;该数下标为:%d\\n&quot;, SQLfind(&amp;s, f));\t\t\tbreak;\t\t&#125;\t\tcase 8:\t\t&#123;\t\t\tint h, i;\t\t\tprintf(&quot;请输入需要更改的下标和新的数字\\n&quot;);\t\t\tprintf(&quot;如果您不知道该数的位置，可以调用查找模块\\n&quot;);\t\t\tprintf(&quot;请输入&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;h, &amp;i);\t\t\tSQLmodify(&amp;s, h, i);\t\t\tbreak;\t\t&#125;\t\tcase 9:\t\t\tSQLprint(&amp;s);\t\t\tbreak;\t\t&#125;\t\tprintf(&quot;请输入命令&gt;&quot;);\t&#125; while (scanf(&quot;%d&quot;, &amp;option) != EOF);\treturn 0;&#125;\n\n最终效果如图\n\n一些err当我使用switch&#x2F;case语句，在case语句中定义局部变量的时候，VS报错“声明不能包含标签”\n\n这个报错并不会阻止程序运行\n\n\n解决办法是在case语句后带上大括号，报错就消失了\n\n\n总结顺序表内容算是对前面学习的一些C语言知识的运用，数据结构的严谨性更胜一筹。\n比如在判断pos和size的大小的时候，会报错类型不一致。\n这时候我们需要把无符号整型的size强制转换为int类型，再和pos进行比较！\n\n如果这篇博客对你有帮助，还请点个👍吧\n\n","categories":["数据结构太复杂"],"tags":["C语言","数组","数据结构"]},{"title":"【算法】从x的n次方看递归时间复杂度计算","url":"/posts/2475090872/","content":"从x的n次方看递归时间复杂度计算\n\n\n1.循环这个问题，最简单的办法是用循环\nint pow1(int x,int n){    int result = 1;    for(int i=0;i&lt;n;i++)    {        result*=x;    }    return result;}\n\n如上算法的时间复杂度为O(N)，但还是不够理想。这时尝试使用递归算法\n2.递归1int pow2(int x,int n){    if(n==0)// x^0 = 1        return 1;    return pow2(x,n-1)*x;}\n\n使用如上递归函数时间复杂度计算办法，该函数递归调用次数是从n一直减到0，即n次。每次递归中，需要进行一次相乘的计算，即O(1)\n最终得到的时间复杂度 O(n*1) = O(n)，这和我们用循环写出来的代码没两样\n3.递归2，二叉树int pow3(int x,int n){    if(n==0)// x^0 = 1        return 1;    if(n==1)// 减少一次递归        return x;    if(n%2==1)// 奇数        return pow3(x,n/2)*pow3(x,n/2)*x;    // 偶数方    return pow3(x,n/2)*pow3(x,n/2);}\n\n最终求次方操作被抽象成了一个二叉树\n\n总递归次数，即二叉树中的节点个数。我们能算出来这颗满二叉树的节点个数为 2^4-1 = 15\n所以一共递归了15次，每次的操作还是一个相乘，O(1)\n所以最终的时间复杂度就是\n递归次数 = 满二叉树节点个数 = 2^m -1m = 二叉树层数（从1开始）= log(n)\n\n带入可以计算出来，最终的二叉树总节点数是n-1个，时间复杂度还是O(N)。这说明我们的算法还不够好\n\n二叉树相关知识点 https://blog.musnow.top/posts/4161984418/\n\n4.递归3如果观察第三个函数可以发现，不管是奇数还是偶数的奇怪，都进行了2次递归调用，但这两个递归调用都是完全相同的\npow3(x,n/2)*pow3(x,n/2);\n\n也就是说，我们可以先递归调用1次，存结果再计算！\nint pow4(int x,int n){    if(n==0)// x^0 = 1        return 1;    if(n==1)// 减少一次递归        return x;    int tmp = pow3(x,n/2);    if(n%2==1)// 奇数        return tmp*tmp*x;    // 偶数方    return tmp*tmp;}\n\n此时函数中只调用了1次递归，每次递归之后，数据都除2，所以总共是log2(n)次\n每次递归，还是一个乘法操作，时间复杂度O(1)最终得到的时间复杂度就是O(logN)！\nThe end这才是我们需要的时间复杂度较低的算法，同时也复习了递归调用的时间复杂度计算办法\n递归时间复杂度 = 递归次数 * 每次操作的负载度\n","categories":["把题目都给刷干净"],"tags":["C语言","算法","OJ刷题"]},{"title":"【算法】C程序的运行速度测试","url":"/posts/263649714/","content":"C语言程序的运行速度测试\n\n\n代码随想录上提到了一点，即我们应该学会估计一个时间复杂度较高的算法，在机器上的运行速度。\n\n如果题目给出的数据量级在高复杂度的算法中会超时，那就应该放弃使用这个代码，而想其他时间复杂度更优的解法；\n这样能避免在刷题的时候，图简单写了个暴力写法却发现超时不过的尴尬（没错说的就是我自己）\n\n大部分OJ题目，对C/C++代码的时间限制都是1s。所以我们测试的目标也将放在1s上。\n\n1.代码\n来源：http://www.360doc.com/content/23/0119/15/2690044_1064211133.shtml\n我的Git：Gitee\n\n1.1 循环首先是func.h，内部包含了三个循环函数，时间复杂度分别为O(N) O(N^2) O(NlogN)\n//func.h#include &lt;stdio.h&gt;// O(N)void func1(long long n){    printf(\"开始执行O(N)的函数：%lld\\n\",n);    long long k=0;    for(long long i=0;i&lt;n;i++)    {        k++;    }}// O(N^2)void func2(long long n){    printf(\"开始执行O(N^2)的函数：%lld\\n\",n);    long long k=0;    for(long long i=0;i&lt;n;i++)    {        for(long long j=0;j&lt;n;j++)        {            k++;        }    }}// O(NlogN)void func3(long long n){    printf(\"开始执行O(NlogN)的函数：%lld\\n\",n);    long long k=0;    for(long long i=0;i&lt;n;i++)    {        // j要从1开始        for(long long j=1;j&lt;n;j*=2)        {            k++;        }    }}\n\n1.2 获取毫秒级时间戳随后是主文件，这里我们需要进行时间的测试，所以得想办法获取到毫秒级的时间戳。\ntime.h中的time函数只能够返回秒级时间戳，对于代码的时间测试来说显然是不够的。我们需要借助Windows和Linux的系统函数，获取到毫秒级时间戳\n#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;// http://www.360doc.com/content/23/0119/15/2690044_1064211133.shtml// 宏编译，分别使用windows和linux的系统函数 #ifdef _WIN32    #include&lt;time.h&gt;    #include&lt;windows.h&gt;#else    #include &lt;sys/time.h&gt;    #include &lt;unistd.h&gt;#endif// 获取当前毫秒级时间，给一个char指针，则打印到其中（字符串）// 后三位为毫秒uint64_t GetCurrentTimerMS(char* szTimer){    uint64_t nTimer = 0;#ifdef _WIN32\tSYSTEMTIME currentTime;\tGetLocalTime(&amp;currentTime);\tstruct tm temptm = { currentTime.wSecond,\t\tcurrentTime.wMinute,\t\tcurrentTime.wHour,\t\tcurrentTime.wDay,\t\tcurrentTime.wMonth - 1,\t\tcurrentTime.wYear - 1900\t};\tnTimer =  mktime(&amp;temptm) * 1000 + currentTime.wMilliseconds;#else\tstruct timeval tv;\tgettimeofday(&amp;tv,NULL);\t// printf(\"second:%ld\\n\",tv.tv_sec);  //秒\tnTimer = tv.tv_sec*1000 + tv.tv_usec/1000;#endif    if(szTimer != NULL)        sprintf(szTimer, \"%llu\", nTimer);    return nTimer;}// 测试时间函数int test_def(){\tchar szTimer[64];\tuint64_t nTimer=-1;\tGetCurrentTimerMS(szTimer);\t//带参数，字符串\tnTimer = GetCurrentTimerMS(NULL); //不带参数\tprintf(\"millisecond1:%s\\nmillisecond2:%llu\\n\",szTimer,nTimer );  //毫秒\treturn 0;}\n\n1.3 获取时间戳测试先来执行一下这个测试函数test_def，结果如下\n$ gcc test.c -o test$ ./testmillisecond1:1681878963361millisecond2:1681878963361\n\n成功打印出了毫秒级的时间戳，分别是字符串类型和uint64_t长整型\n#ifdef _WIN32    #include &lt;time.h&gt;    #include&lt;windows.h&gt;#else    #include &lt;sys/time.h&gt;    #include &lt;unistd.h&gt;#endif\n\n这里还采用了宏定义，自动判断windows还是linux，调用各自的系统接口函数。\n如下图，在Windows下的Vs2019也成功执行这个函数\n\n2.开始测试这个命令可以查看linux下的cpu型号\n$ cat /proc/cpuinfo | grep 'model name' |uniqmodel name      : Intel(R) Celeron(R) N5105 @ 2.00GHz\n\n2.1 示例先测试O(N)算法在何等数量级时会超过1s\n$ ./test请键入n：500000000start_time: 1681880952986开始执行O(N)的函数：500000000end_time:   1681880954073diff:       1087msstart_time: 1681880963999开始执行O(N)的函数：450000000end_time:   1681880964993diff:       994ms请键入n：460000000start_time: 1681881111806开始执行O(N)的函数：460000000end_time:   1681881112804diff:       998ms请键入n：470000000start_time: 1681881117572开始执行O(N)的函数：470000000end_time:   1681881118604diff:       1032ms请键入n：400000000start_time: 1681880967163开始执行O(N)的函数：400000000end_time:   1681880968043diff:       880ms请键入n：550000000start_time: 1681880970538开始执行O(N)的函数：550000000end_time:   1681880971736diff:       1198ms\n\n如上，是我的linux服务器的测试结果。\n数量级大概在460000000的时候，就会达到998ms，也就是将近1s\n所以，当我们看到Oj的测试用量超过4500000000数量级的时候，就应该放弃O(N)算法！\n\n而在windows下，我的R7 5800H笔记本，运行到700000000数量级的时候，才需要1s\n请键入n：500000000start_time: 1681881322528开始执行O(N)的函数：500000000end_time:   1681881323236diff:       708ms请键入n：1000000000start_time: 1681881327548开始执行O(N)的函数：1000000000end_time:   1681881328965diff:       1417ms请键入n：600000000start_time: 1681881332928开始执行O(N)的函数：600000000end_time:   1681881333792diff:       864ms请键入n：800000000start_time: 1681881337404开始执行O(N)的函数：800000000end_time:   1681881338537diff:       1133ms请键入n：700000000start_time: 1681881341486开始执行O(N)的函数：700000000end_time:   1681881342486diff:       1000ms\n\n2.2 结果按如上办法测试，我分别测试了三种时间复杂度在多个平台上的结果。稍微了解这些数字，能帮助我们在判断题目选用算法上提供帮助。\n表中E8是科学计数法，代表10的8次方\n\n\n\n平台/CPU\n时间复杂度\n数量级\n时间(毫秒)\n\n\n\nwindows (amd R7-5800H)\nO(N)\n7E9\n1000\n\n\n\nO(N2)\n3E4\n1022\n\n\n\nO(NlogN)\n1.7E7\n996\n\n\nCentos8 (Intel N5105)\nO(N)\n4.5E8\n994\n\n\n\nO(N2)\n2E4\n920\n\n\n\nO(NlogN)\n1.8E7\n966\n\n\nCentos7.2 (Intel Xeon Platinum 8255C)\nO(N)\n5.8E8\n990\n\n\n\nO(N2)\n2.4E4\n976\n\n\n\nO(NlogN)\n2.1E7\n976\n\n\n数据测试于23.04.19\n\n本来还想测测牛客和leetcode的，结果发现它们运行O(N^2)量级的函数，都E7了还是几ms就搞定了，感觉测试的结果不准，故放弃😂\n\n\n","categories":["把题目都给刷干净"],"tags":["C语言","算法","OJ刷题"]},{"title":"【C语言】单链表太难学不懂？看这一篇就够了","url":"/posts/2793401961/","content":"[TOC]\n前言😀之前的博客中我们讲述了顺序表的数据结构，顺序表和之前C语言学习的数组还是比较相似的。\n今天要学习的是链表，这是一个全新的数据结构，和之前我们学的内容都不相同。\n\n编译器：VS2019\n\n1.什么是链表链表，如其名所示，是一个带链子的表\n和顺序表的扩容开辟相比，它可以利用内存堆区中的空闲空间，而不需要一个连续的长空间。从而达到提高空间利用效率的目的。\n\n\n链表中每一个单独开辟的“元素”称为一个节点\n链表有一个头指针phead，用于指向链表的首节点\n单链表中，每一个节点都有一个next指针，指向下一个节点\n链表的尾节点的next指向NULL空指针\n\n这样我们在使用的时候，就可以用过next指针访问链表的下一个节点，一直到最后一个节点的next为空停止。\n需要注意的是，链表的每个节点之间并没有实际意义上的箭头，画出箭头只是方便我们理解。实际上，在内存中，链表的next指针就充当了箭头的角色。\n\n链表的结构在逻辑上连续，但在物理上不一定连续\n实际上在堆区开辟空间中，分配的内存可能连续，可能不连续\n\n1.1链表的分类1 单向&#x2F;双向链表\n2 带头&#x2F;不带头这里的头，指的是一个头节点。该节点的next指向链表实际的表头，val中不存放有效数据\n实际使用时，带头的head-&gt;next相当于不带头的phead指针\n\n3 循环或者非循环\n本篇博客讲解的是无头单向非循环链表，双向链表将在之后的博客里面讲解！\n\n2.开始敲代码！实际编写代码的时候，一定要记住：写完一个模块就要测试一次，不要全写完再测试！！！\n2.1  链表结构和顺序表一样，使用单链表之前，我们需要创建一个“模板”，即单链表每个节点的结构体\ntypedef int SLTDataType;//定义新符号，与该符号相关的都是链表内容typedef struct SListNode&#123;\tSLTDataType data; //val-存放内容\tstruct SListNode* next; //存储下一个节点的地址&#125;SListNode, SLN;\n\n2.2 开辟节点当我们使用单链表时，需要先开辟一个头节点，并使它的next指针指向NULL\nSListNode* node1 = (SListNode*)malloc(sizeof(SListNode));node1-&gt;data = 1;node1-&gt;next = NULL;\n\n这部分我们可以封装一个函数来实现！\nSListNode* BuySListNode(SLTDataType x)//x代表该节点val的值&#123;\tSListNode* newnode = (SListNode*)malloc(sizeof(SListNode));\tif (newnode == NULL)\t&#123;\t\tprintf(&quot;malloc fail\\n&quot;);\t\texit(-1);\t&#125;\telse\t&#123;\t\tnewnode-&gt;data = x;\t\tnewnode-&gt;next = NULL;\t&#125;\treturn newnode;&#125;\n\n需要注意的是，使用这个函数的时候，我们应该先让另外一个指针来接收返回的newnode地址，不建议直接让上一个节点的next来接收返回值\n\n这样做能方便我们后续debug！\n\n//建议做法SListNode* newnode = BuySListNode(x);tail-&gt;next = newnode;//不建议tail-&gt;next=BuySListNode(x);\n\n2.3 尾插&#x2F;头插尾插：将一个新节点连接到已有链表的尾部\n假设我们现在已经有了一个这样的链表，当我们需要尾插的时候，要怎么做呢？\n\n实际上，我们只需要开辟一个新的节点，并将上一个节点的next指向这个新开辟节点的地址即可！（尾插的新节点的next=NULL）\n\nvoid SListPushBack(SListNode** pphead, SLTDataType x)&#123;\tassert(pphead);\tSListNode* newnode = BuySListNode(x);\tif (*pphead == NULL)\t&#123;        //如果原链表为空，直接让头指针=新开辟的节点地址\t\t*pphead = newnode;\t&#125;\telse//原链表非空\t&#123; \t\tSListNode* tail = *pphead;\t\twhile (tail-&gt;next != NULL)\t\t&#123;   //需要先找尾\t\t\ttail = tail-&gt;next;\t\t&#125;\t\ttail-&gt;next = newnode;\t&#125;&#125;\n\n而头插就没有尾插那么麻烦了！\n我们只需要将新节点的next指向原链表的头部，再将head头指针更改为新节点的地址即可\nvoid SListPushFront(SListNode** pphead, SLTDataType x)&#123;\tassert(pphead);\tSListNode* newnode = BuySListNode(x);\tnewnode-&gt;next = *pphead;\t*pphead = newnode;&#125;\n\n细心的你应该注意到了，这里我们使用的都是二级指针pphead\n因为假设我们使用一级指针，直接传入头指针phead时，当我们需要更改该指针指向的地址时，改动只会在函数内部生效，main函数中的phead指针并没有被改变\n\n这是一个经典的函数传址和传值问题\n\n当我们需要更改phead本身时，需要传入二级指针\n\n\n2.4 尾删&#x2F;头删尾删时，需要先进行找尾。并且需要保存尾部的前一个节点的地址\nwhile(tail-&gt;next!=NULL)//会找到尾节点本身，不符合要求    //尾删应该找到尾节点的前一个while (tail-&gt;next-&gt;next != NULL)\n\n同时，我们需要想到特殊情况\n\n链表为空，无需尾删\n链表只有一个，无需找尾\n\n具体的代码实现如下\nvoid SListPopBack(SListNode** pphead)&#123;\tassert(pphead);\t\tif (*pphead==NULL)\t&#123;\t\treturn;\t&#125;\telse if((*pphead)-&gt;next==NULL)\t&#123;\t\tfree(*pphead);\t\t*pphead = NULL;\t&#125;\telse\t&#123;\t\t//有多个尾巴的情况\t\tSListNode* tail = *pphead;//找尾巴\t\twhile (tail-&gt;next-&gt;next != NULL)\t\t&#123;\t\t\ttail = tail-&gt;next;\t\t&#125;\t\tfree(tail-&gt;next);\t\ttail-&gt;next = NULL;\t&#125;\t\treturn;&#125;\n\n头删的情况依旧简单一些\n我们需要用一个变量保存头节点，再让头指针phead指向原本头节点的next，最后free掉头节点即可\nvoid SListPopFront(SListNode** pphead)&#123;\tassert(pphead);\t\tif (*pphead == NULL)\t&#123;\t\treturn;\t&#125;\telse\t&#123;\t\tSListNode* oldhead = *pphead;\t\t*pphead = (*pphead)-&gt;next;\t\tfree(oldhead);\t\toldhead = NULL;\t&#125;\treturn;&#125;\n\n\n2.5 查找&#x2F;更改查找函数需要我们在单链表中进行遍历，找到用户输入的x值，并返回它所在节点的地址\n\n查找函数并不需要更改phead指针，所以这里我们只需要传入一级指针\n\nSListNode* SListFind(SListNode* phead, SLTDataType x)&#123;\tassert(phead);\tSListNode* curt = phead;//找x的位置\twhile (curt-&gt;next != NULL)\t&#123;\t\tif (curt-&gt;data == x)\t\t&#123;\t\t\treturn curt;\t\t&#125;\t\telse\t\t&#123;\t\t\tcurt = curt-&gt;next;\t\t&#125;\t&#125;\t//找不到，返回空\treturn NULL;&#125;\n\n你可能会有一个疑惑，假设我的链表里面有多个x呢？这个函数只能返回找到的第一个x的地址\n\n很遗憾，我们并没有什么好的办法来解决这个问题。除非用户知道他想找的x的准确地址，不然是很难搞定的。\n\n实际应用中，链表的一个节点存放的并不只有一个整型x。我们可以通过其他参数进行多重判断。\n\n比如通讯录中，我们可以用名字+性别来精确查找。也可将所有找到的x都返回给用户进行选择，但那就不是本篇博客会涉及到的内容啦\n\n\n更改函数中，我们需要用户输入待更改节点的地址，和新的val\n如果用户不知道需要更改节点的地址，可以用查找函数来查找。\nvoid SListmodify(SListNode* phead, SListNode* pos, SLTDataType x)&#123;\tassert(phead);\tpos-&gt;data = x;\treturn;&#125;\n\n\n2.6 在pos位置前&#x2F;后插入除了基本的头尾增加，用户可能还需要在某一个特定节点前后进行插入，方便管理数据。这时候我们就需要灵活转变了\n\n链表不存在顺序表中的数据越界\npos位置可由find函数找到\n\n假设用户需要在pos位置之后插入，我们需要暂时断开链表，新插入一个节点后，重新链接\nvoid SListInsertAfter(SListNode** pphead, SListNode* pos, SLTDataType x)&#123;\tassert(pphead);\tassert(pos);\tSListNode* newnode = BuySListNode(x);\tSListNode* next = pos-&gt;next;//原本pos的下一位\tpos-&gt;next = newnode;//新插入的pos下一位\tnewnode-&gt;next = next;\treturn;&#125;\n\n如果是在pos之前插入，需要遍历查找pos的前一位，使用相同方法断开、插入、重连\nvoid SListInsert(SListNode** pphead, SListNode* pos, SLTDataType x)&#123;\tassert(pphead);\tassert(pos);\t\tif (pos == *pphead)\t&#123;\t\tSListPushFront(pphead, x);\t&#125;\telse\t&#123;\t\tSListNode* tail = *pphead;//找pos前一个\t\twhile (tail-&gt;next != NULL)\t\t&#123;//只写了这个情况，没有考虑pos是第一个的情况\t\t\tif (tail-&gt;next == pos)\t\t\t&#123;                 SListNode* newnode = BuySListNode(x);\t\t\t\ttail-&gt;next = newnode;\t\t\t\ttail-&gt;next-&gt;next = pos;\t\t\t\treturn;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\ttail = tail-&gt;next;\t\t\t&#125;\t\t&#125;\t&#125;\t\treturn;&#125;\n\n这里我们都传入了二级指针，因为当pos就是链表的头节点时，在pos前插入就相当于头插，可以直接调用之前写好的头插函数。\n当pos就是链表的头节点时，在其后插入相当于尾插。\n\n该函数不存在链表为空的情况，因为函数需要传入pos。空链表中没有节点，pos为空，assert断言会报错。\n\n这里我编写的功能很简单，所以需要用户严格遵守使用规定，传入一个合法的pos\n\n2.7 在pos位置删除数据说完了插入，再来说说删除\n这里提供两个函数，一个是在删除pos位置的节点，另一个是删除pos下一位的节点\n这一部分其实就是对上一步的逆向，具体的就不详细说啦（偷懒）\n\n大家如果有不懂的，可以在评论区提问~~看到了就会回复的！\n\nvoid SListErase(SListNode** pphead, SListNode** pos)&#123;\tassert(pphead);\tassert(pos);\tif (*pos == *pphead)\t&#123;//如果pos是头节点，等同于头删\t\tSListPopFront(pphead);\t&#125;\telse\t&#123;\t\tSListNode* tail = *pphead;//找pos前一个\t\twhile (tail-&gt;next != NULL)\t\t&#123;\t\t\tif (tail-&gt;next == *pos)\t\t\t&#123;\t\t\t\ttail-&gt;next = (*pos)-&gt;next;\t\t\t\tfree(*pos);//删除后main函数传过来的pos位置已被free\t\t\t\t*pos = NULL;//*pos置空，此时main函数中的pos也被置空\t\t\t\tpos = NULL;\t\t\t\treturn;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\ttail = tail-&gt;next;\t\t\t&#125;\t\t&#125;\t&#125;\treturn;&#125;void SListEraseAfter(SListNode** pphead, SListNode* pos)&#123;\tassert(pphead);\tassert(pos);\tSListNode* next = pos-&gt;next-&gt;next;\tfree(pos-&gt;next);\tpos-&gt;next = next;\treturn;&#125;\n\n2.8 打印链表打印的时候可以打印出-&gt;箭头，方便我们查看链表的结构\nvoid SListPrint(SListNode* phead)&#123;\tSListNode* cur = phead;\twhile (cur != NULL)\t&#123;\t\tprintf(&quot;%d-&gt;&quot;, cur-&gt;data);\t\tcur = cur-&gt;next;\t&#125;\tprintf(&quot;NULL\\n&quot;);&#125;\n\n2.9 销毁链表对于顺序表来说，销毁链表只需要free掉顺序表中指向堆区空间的指针\n但对于链表来说，我们需要一步一步进行释放操作，并在释放完毕后将头指针置空\n\n如果该链表有头节点，则还需将头节点一并置空\n\nvoid SListDestroy(SListNode** pphead)&#123;\tassert(pphead);\tSListNode* curt = *pphead;\twhile (curt)\t&#123;\t\tSListNode* next = curt-&gt;next;\t\tfree(curt);\t\tcurt = next;\t&#125;\t*pphead = NULL;\treturn ;&#125;\n\n\n3.测试这一次，我依旧使用了多文件编程的方法来敲单链表的代码\n这样的好处在于，别人只需要看你的.h头文件，就能清楚的知道你这个项目大概实现了什么样的功能，就好比一篇文章的大纲一样。对于后续的项目实战来说，是非常重要的编程能力积累\n\n测试一下我们的代码，可以看到，所有函数的功能都能正常实现！\n\n\n结语🤳学习完单链表后，我开始接触了一些链表的oj题目，不得不说，链表这部分的题目，难度还是比之前C语言的时候练习的题目更大的！有很多题目都需要我们融会贯通之前的知识。\n最重要的是通读代码和调试的能力，这样才能更好地编写出算法\n\n如果这篇博客对你有帮助，还请点个👍，万分感谢！\n\n有什么问题的话，大家可以在评论区提出哦\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","链表"]},{"title":"【C语言】数据结构-栈（详解）","url":"/posts/3359083806/","content":"[TOC]\n前言在之前的数据结构学习中，我们学习了顺序表、链表这两种结构\n\n顺序表：博客链接1\n单链表：博客链接2\n链表OJ：博客链接3\n\n除了单链表以外，还有一个结构，是双向带头循环链表。这个链表的形式如下\n\n头节点的prev指向尾部节点\n尾节点的next指向头节点，构成循环\n\n\n别看它的形式有些复杂，实际代码的实现，比单链表还简单！\n因为head-&gt;prev指向了尾节点，所以不需要找尾。尾删的时候也不需要遍历找尾节点的前一位，因为尾节点的prev就存放了前一位的地址。\n所以这里就偷懒不写博客了！反正也没啥人看😭\n\n好吧，最后我还是写了一篇水文👉点我\n\n\n本篇博客讲述的是另外一个特别的线性表，栈\n1.什么是栈数据结构里的栈，和函数栈帧中的“栈”有一定相似，但实际上它们完全不同\n栈作为一个特殊的线性表，它只允许在表的一头添加、删除数据。\n所有的数据都遵循先进后出，后进先出的原则\n\n压栈：栈的插入操作叫做进栈&#x2F;压栈&#x2F;入栈，新的数据存放在栈顶\n出栈：栈的删除操作，先删除栈顶的数据\n\n\n2.栈的实现栈可以用数组或者链表来实现，相对而言，数组的方法更优\n因为数组在尾插数据的时候，可以很方便的找到尾。而单链表需要遍历找尾，耗时较长。\n\n是不是有些似曾相识呢？没错，实际上栈区就是一个只能尾插+尾删的顺序表\n3.敲代码！3.1头文件先用头文件写好咱们的大纲，然后在来一一实现这些代码\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;stdbool.h&gt;// 支持动态增长的栈typedef int STDataType;typedef struct Stack&#123;\tSTDataType* a;\tint top; // 栈顶\tint capacity; // 容量&#125;Stack;// 初始化栈void StackInit(Stack* ps);// 销毁栈void StackDestroy(Stack* ps);// 入栈void StackPush(Stack* ps, STDataType data);// 出栈void StackPop(Stack* ps);// 获取栈顶元素STDataType StackTop(Stack* ps);// 获取栈中有效元素个数int StackSize(Stack* ps);// 检测栈是否为空，如果为空返回false，如果不为空返回truebool StackEmpty(Stack* ps);//打印void StackPrint(Stack* ps);\n\n和顺序表不同的是，我们需要写一个单独的函数来获取栈顶元素，这一点在很多OJ题目中都需要用到。\n3.2函数实现如果你看过了我之前顺序表的博客，这部分对你来说想必不难。\n\n如果有什么问题，欢迎在评论区提出！\n\n#include&quot;Stack.h&quot;// 初始化void StackInit(Stack* ps)&#123;\tSTDataType* new = (STDataType*)malloc(4*sizeof(STDataType) );\tif (new == NULL)\t\texit(-1);\telse\t&#123;\t\tps-&gt;a = new;\t\tps-&gt;top = 0;\t\tps-&gt;capacity = 4;\t&#125;&#125;// 销毁栈void StackDestroy(Stack* ps)&#123;\tassert(ps);\tfree(ps-&gt;a);\tps-&gt;a = NULL;\tps-&gt;capacity = 0;\tps-&gt;top = 0;&#125;// 入栈void StackPush(Stack* ps, STDataType data)&#123;\tassert(ps);\tif (ps-&gt;top == ps-&gt;capacity)//容量检查\t&#123;\t\tSTDataType* new = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * (ps-&gt;capacity) * 2);\t\tif (new == NULL)\t\t&#123;\t\t\texit(-1);\t\t&#125;\t\telse\t\t&#123;\t\t\tps-&gt;a = new;\t\t\tps-&gt;capacity *= 2;\t\t&#125;\t&#125;\tps-&gt;a[ps-&gt;top] = data;\tps-&gt;top++;&#125;// 出栈void StackPop(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top &gt; 0)\t\t(ps-&gt;top)--;&#125;// 获取栈顶元素STDataType StackTop(Stack* ps)&#123;\tassert(ps);\tassert(ps-&gt;top &gt; 0);\treturn ps-&gt;a[ps-&gt;top - 1];&#125;// 获取栈中有效元素个数int StackSize(Stack* ps)&#123;\tassert(ps);\treturn ps-&gt;top;&#125;// 检测栈是否为空，如果为空返回true，如果不为空返回falsebool StackEmpty(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top == 0)\t\treturn true;\telse\t\treturn false;&#125;void StackPrint(Stack* ps)&#123;\tassert(ps);\tint n = ps-&gt;top;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tprintf(&quot;%d &quot;, ps-&gt;a[i]);\t&#125;\tprintf(&quot;\\n&quot;);&#125;\n\n大家在自己编写这种带多个板块的代码的时候，一定要一个板块写完就检查一遍！不要将问题都丢一块解决，那样会非常难受的！\n\n在其他版块都确认无误之后，也要过来瞅一眼Destroy板块，避免出现free错误等情况。\n这个板块我们可以通过打断点（VS快捷键F9）并调试的方法来检查该板块是否正确\n\n4.知识巩固，来道OJ！leetcode 20 有效的括号\nleetcode：20. 有效的括号\n\n\n这道题就是一道非常使用用栈来解决的OJ题\n题目要求我们判断给出的字符串中，括号是否一一对应\n&#123;[]&#125;//对应&#123;[(])&#125;//不对应&#123;&#123;()&#125;//少了一个右边括号，不对应\n\n具体要怎么做呢？思路如下：\n\n用一个指针来遍历字符串，如果是左括号&#123;([其中一个，就入栈\n如果是右边括号，说明左括号已经入栈完毕，开始比对\n栈顶的括号一定是和当前右括号匹配的，如果不是则为false\n每判断一次，就让栈顶的左括号出栈一次\n\n最后的函数实现如下\n\n需要注意的是，STDataType类型需要更改为char类型，此时存放的是括号字符，并不是数字\n\ntypedef char STDataType;typedef struct Stack&#123;\tSTDataType* a;\tint top; // 栈顶\tint capacity; // 容量&#125;Stack;// 初始化void StackInit(Stack* ps)&#123;\tSTDataType* new = (STDataType*)malloc(sizeof(STDataType) * 4);\tif (new == NULL)\t&#123;\t\texit(-1);\t&#125;\telse\t&#123;\t\tps-&gt;a = new;\t\tps-&gt;top = 0;\t\tps-&gt;capacity = 4;\t&#125;&#125;// 销毁栈void StackDestroy(Stack* ps)&#123;\tassert(ps);\tfree(ps-&gt;a);\tps-&gt;a = NULL;\tps-&gt;capacity = 0;\tps-&gt;top = 0;&#125;// 入栈void StackPush(Stack* ps, STDataType data)&#123;\tassert(ps);\tif (ps-&gt;top == ps-&gt;capacity)\t&#123;\t\tSTDataType* new = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * (ps-&gt;capacity) * 2);\t\tif (new == NULL)\t\t&#123;\t\t\texit(-1);\t\t&#125;\t\telse\t\t&#123;\t\t\tps-&gt;a = new;\t\t\tps-&gt;capacity *= 2;\t\t&#125;\t&#125;\tps-&gt;a[ps-&gt;top] = data;\tps-&gt;top++;&#125;// 出栈void StackPop(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top &gt; 0)\t\t(ps-&gt;top)--;&#125;// 获取栈顶元素STDataType StackTop(Stack* ps)&#123;\tassert(ps);\tassert(ps-&gt;top &gt; 0);\treturn ps-&gt;a[ps-&gt;top - 1];&#125;// 检测栈是否为空，如果为空返回true，如果不为空返回falsebool StackEmpty(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top == 0)\t\treturn true;\telse\t\treturn false;&#125;bool isValid(char * s)&#123;    Stack st;    StackInit(&amp;st);    while(*s)    &#123;        if(*s==&#x27;&#123;&#x27;||*s==&#x27;[&#x27;||*s==&#x27;(&#x27;)        &#123;            StackPush(&amp;st,*s);            s++;        &#125;        else        &#123;            if(StackEmpty(&amp;st))            &#123;                return false;            &#125;            char top=StackTop(&amp;st);//取栈顶元素            StackPop(&amp;st);//把栈顶删除            //如( &#123; 这两个，取了栈顶&#123;，就立马pop掉它            if((*s==&#x27;&#125;&#x27;&amp;&amp;top==&#x27;&#123;&#x27;)            ||(*s==&#x27;)&#x27;&amp;&amp;top==&#x27;(&#x27;)            ||(*s==&#x27;]&#x27;&amp;&amp;top==&#x27;[&#x27;))            &#123;                s++;            &#125;            else            &#123;                StackDestroy(&amp;st);                return false;            &#125;        &#125;    &#125;    bool ret=StackEmpty(&amp;st);    //如果为空，说明匹配完毕；非空说明还有剩下的左括号    StackDestroy(&amp;st);        return ret;&#125;\n\n这个算法的用时还是非常短的！\n\n结语数据结构学到这里，其实在了解完这些结构的真正思路后，代码的实现反而并不是那么重要。\n在学习这部分知识的时候，一定要多画图！\n如果你不适应用鼠标画图，可以直接用纸笔画，一些非常简单的草图，也能极大帮助我们理解当前的代码，找出问题👍\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","栈"]},{"title":"【C语言】带你刷爆十道链表OJ","url":"/posts/3770717253/","content":"[TOC]\n前言，CSDN的小问题😥最近写博客的时候，发现CSDN的markdown语法不支持加粗一句话末尾的标点符号\n**你好呀，****你好呀**，\n\n这两种方式在typora上都会加粗（包括末尾的标点）\n但是在CSDN上，第一种情况会显示出markdown源码，无法加粗\n\n你好呀，我是你的好朋友你好呀，我是你的好朋友\n\n虽然这不是什么大事，但有的时候写博客，一句本来应该是加粗的话，多显示了几个**，不太美观，还会给不了解markdown的读者带来困扰：“作者在这里打几个*号是干嘛？”\n\n上一篇博客，我们学习了单向无头非循环链表，本篇博客就让我们实践一下，刷十道leetcode的链表OJ题目吧🌭\n如果你把本篇博客里的这几道题都弄明白了，那说明你对链表的掌握已经非常棒了！加油！\n话不多说，直接进入今天的正题！\n第一题：206.反转链表\nleetcode：206. 反转链表\n\n题目需要我们把1-2-3-4-5的链表反转为5-4-3-2-1的链表\n\n有一种取巧的办法，是将所有数取出来放入一个数组，再倒着将数组里面的数放回去\n这种办法可以通过OJ，因为leetcode并没有检查返回链表的地址。但并不符合题目的真正要求\n\nstruct ListNode* reverseList(struct ListNode* head)&#123;    struct ListNode* newhead=NULL;    struct ListNode* cur=head;    while(cur)    &#123;        struct ListNode* next=cur-&gt;next;        cur-&gt;next=newhead;        newhead=cur;        cur=next;    &#125;    return newhead;&#125;\n\n\n\n第二题：876.链表的中间节点\nLeetCode： 876. 链表的中间结点\n\n\n这道题目需要我们返回单链表的中间节点\n如果链表节点个数是奇数，返回中间节点；\n如果链表节点个数是偶数，返回第二个节点。\n\n对于数组和顺序表来说，我们只需要利用下标直接访问中间节点即可\n对于单链表来说，我们不知道它究竟有多少个节点，即便知道了，也需要通过遍历的方法找到这个中间节点\n\n\n这道题我想出了两种解题方式\n解法一：遍历通过遍历得出该链表的节点个数，再使用一个新的指针，查找中间节点\nstruct ListNode* middleNode(struct ListNode* head)&#123;    if(head==NULL)        return NULL;    int count=1;//计算链表一共的节点数    struct ListNode* tail=head;//找尾    while(tail-&gt;next!=NULL)    &#123;        tail=tail-&gt;next;        count++;    &#125;    int half=(count/2);     //如果是3结果为1，如果是4结果为2    //正好是从head开始寻找的次数    struct ListNode* mid =head;    while((mid-&gt;next!=NULL)&amp;&amp;(half--))    &#123;        mid=mid-&gt;next;    &#125;    return mid;&#125;\n\n对于链表oj题目，leetcode会把这个链表的形式以注释的方式标注在最前面\n\n解法二：快慢指针（很爽👍）\n这种方法实现起来也很是简洁，也击败了更多用户！\nstruct ListNode* middleNode(struct ListNode* head)&#123;    if(head==NULL)        return NULL;    struct ListNode*fast=head;    struct ListNode*slow=head;    while(fast&amp;&amp;fast-&gt;next)    &#123;        fast=fast-&gt;next-&gt;next;        slow=slow-&gt;next;    &#125;    return slow;&#125;\n\n\n\n第三题：OR36 链表的回文结构👨‍🔧\n牛客网：OR36 链表的回文结构\n\n\n这道题我们可以使用一个很特别的方法\n\n先找到这串链表的中间节点（可以用到876里的函数）\n\n再将这个节点之后的链表逆置（206反转链表）\n\n\n1-2-3-2-1//逆置后1-2-1-2-3\n\n需要注意的是，逆置函数并不会改变第一个2的next节点，它依旧是链接在3上的\n//进行遍历判断1-2-(3)1-2-3\n\n这样我们就能判断出该链表是否为回文结构了！\n\n开始敲代码，发现牛客网上只有C++的选项，没有C语言\n\n实际上，C++编译器都是支持C语言的，我们可以直接在题目给出的C++结构下进行C语言代码的编写\n\n题目要求的返回值是一个bool类型。如果你不了解它，布尔类型是C99引入的，简单的来说，ture代表1，false代表0\n\n在之前的博客中我写到过这个类型👉点我\n\n\nclass PalindromeList &#123;public:    //链表逆置    struct ListNode* reverseList(struct ListNode* head) &#123;        struct ListNode* newhead = NULL;        struct ListNode* cur = head;        while (cur)        &#123;            struct ListNode* next = cur-&gt;next;            cur-&gt;next = newhead;            newhead = cur;            cur = next;        &#125;        return newhead;    &#125;    //中间节点返回    //1 2 3 4  偶数个，返回3    //1 2 3    奇数个，返回2    struct ListNode* middleNode(struct ListNode* head) &#123;        if (head == NULL)            return NULL;        int count = 1;//计算链表一共的节点数        struct ListNode* tail = head;//找尾        while (tail-&gt;next != NULL)        &#123;            tail = tail-&gt;next;            count++;        &#125;        int half = (count / 2);        //如果是3结果为1，如果是4结果为2        //正好是需要从head开始寻找的次数        struct ListNode* mid = head;        while ((mid-&gt;next != NULL) &amp;&amp; (half--))        &#123;            mid = mid-&gt;next;        &#125;        return mid;    &#125;    bool chkPalindrome(ListNode* A) &#123;        struct ListNode* mid = middleNode(A);        struct ListNode* ret = reverseList(mid);        //1 2 3 2 1 回文链表        //先逆转后面3个        //1 2 1 2 3        //这时候第一个2存放的next依旧是下一个3的地址        //使用while循环进行判断，都是判断3次是否相等        //相等就是回文，否则不是        while (A &amp;&amp; ret)        &#123;            if (A-&gt;val == ret-&gt;val)            &#123;                A = A-&gt;next;                ret = ret-&gt;next;            &#125;            else            &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n\n\n第四题：链表中倒数第K个节点\n牛客网：链表中倒数第k个结点\n\n\n这道题我们同样可以使用快慢指针来解决\n倒数第k个节点，就需要快指针先走k步\n\n这里我尝试用PS做了一个动图，给大伙瞅瞅\n\n\n这道题也是只有C++选项。和上道题一样，我们直接在C++下编写C语言代码就可以了\nclass Solution &#123;public:    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;        if (pListHead == NULL)            return NULL;                struct ListNode* fast = pListHead;        struct ListNode* slow = pListHead;        int i = k;        while (i--)        &#123;            if (fast == NULL)            &#123;                return NULL;            &#125;            fast = fast-&gt;next;        &#125;        while (fast)        &#123;            fast = fast-&gt;next;            slow = slow-&gt;next;        &#125;        return slow;    &#125;&#125;;\n\n\n\n第五题：CM11 链表分割\n牛客网：CM11 链表分割\n\n\n这道题我使用了带头节点的做法，head-&gt;next等同于不带头链表的head指针\nclass Partition &#123;public:    ListNode* partition(ListNode* pHead, int x) &#123;    if(pHead==NULL)        return NULL;            struct ListNode* newhead=(struct ListNode*)malloc(sizeof(struct ListNode));//新链表-比x小的部分    struct ListNode* Bigger=(struct ListNode*)malloc(sizeof(struct ListNode));//比x大的部分            //这里需要定义一个新的指针来遍历链表，防止找不到头    struct ListNode* head=newhead;    struct ListNode* big=Bigger;        while(pHead)    &#123;//遍历里面比x小的，链接在newhead上        if(pHead-&gt;val  &lt;x)        &#123;            head-&gt;next=pHead;            pHead=pHead-&gt;next;            head=head-&gt;next;                    &#125;        else        &#123;//比x大的链接在bigger上            big-&gt;next=pHead;            pHead=pHead-&gt;next;            big=big-&gt;next;        &#125;    &#125;    big-&gt;next=NULL;//big的末尾需要置空    head-&gt;next=Bigger-&gt;next;//让head的末尾链接bigger的头部            struct ListNode* list=newhead-&gt;next;    free(newhead);    free(Bigger);    return list;    &#125;&#125;;\n\n\n第六题：21. 合并两个有序链表\nleetcode：21. 合并两个有序链表\n\n\n这道题的解析就放注释啦\nstruct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)&#123;    if(list1==NULL)        return list2;    if(list2==NULL)        return list1;    struct ListNode* H1=list1;    struct ListNode* H2=list2;    struct ListNode* newList=NULL;    struct ListNode* tail=NULL;    if(H1-&gt;val&lt;H2-&gt;val)//选取新链表的第一个节点    &#123;        newList=H1;        tail=H1;        H1=H1-&gt;next;    &#125;    else    &#123;        newList=H2;        tail=H2;        H2=H2-&gt;next;    &#125;    while(H1 &amp;&amp; H2)//其中一个走完了，就退出循环    &#123;        if(H1-&gt;val&lt;H2-&gt;val)//找小的那一个链接在尾部        &#123;            tail-&gt;next=H1;            tail=H1;//等同于tail=tail-&gt;next            H1=H1-&gt;next;        &#125;        else        &#123;            tail-&gt;next=H2;            tail=H2;//等同于tail=tail-&gt;next            H2=H2-&gt;next;        &#125;    &#125;//最后结束了，还需要判断是谁走完了，把另外一个链表剩下的部分链接在尾部//链表本身是有序的，所以最后无需再进行排序，直接链接即可    if(H1)        tail-&gt;next=H1;    if(H2)        tail-&gt;next=H2;        return newList;&#125;\n\n\n\n第七题：160.相交链表\nleetcode：160. 相交链表\n\n\n题目需要我们返回两个相交链表的交点c1，如果不相交就返回NULL。\n最后一行还提到了，这道题不能破坏原始链表\n\n本题思路如下：\n\n先用两个指针，分别遍历A、B链表，得到两个链表长度\n遍历完毕时，指针处在末尾C3，如果末尾不相等，就说明该链表不相交，返回NULL\n如果相等，计算出A、B链表的长度差，使用快慢指针进行操作\n快指针从长链表开始走，先走|A-B|长度。然后慢指针也开始移动，直到它们相交\n\n\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;    if((headA==NULL)||(headB==NULL))        return NULL;    int countA=1;    int countB=1;    struct ListNode *HA=headA;    struct ListNode *HB=headB;    while(HA&amp;&amp;HA-&gt;next)    &#123;        countA++;        HA=HA-&gt;next;    &#125;    while(HB&amp;&amp;HB-&gt;next)    &#123;        countB++;        HB=HB-&gt;next;    &#125;    if(HB!=HA)//结尾不相等，说明不相交        return NULL;    int num=abs(countA-countB);    struct ListNode* fast=NULL;    struct ListNode* slow=NULL;    if(countA&gt;countB)    &#123;        fast=headA;        slow=headB;    &#125;    else    &#123;        fast=headB;        slow=headA;    &#125;    while(num--)//fast先走    &#123;        fast=fast-&gt;next;    &#125;    while(fast&amp;&amp;slow)    &#123;        if(fast==slow)            return fast;        fast=fast-&gt;next;        slow=slow-&gt;next;    &#125;    return NULL;&#125;\n\n\n\n第八题：141.环形链表\nleetcode：141. 环形链表\n\n\n本题只需要我们判断该链表是否有环，我们同样使用快慢指针，快指针的速度是慢指针的两倍，进环以后，快指针能追上后来的慢指针，即该链表带环。\n\n如果快指针遇到了NULL，即该链表不带环\n\n题目需要返回bool类型，前面已经提到过了~\n\nbool hasCycle(struct ListNode *head) &#123;    if(head==NULL)        return false;        struct ListNode * slow=head;    struct ListNode * fast=head;    struct ListNode * meet=NULL;    while(fast &amp;&amp; fast-&gt;next)    &#123;        fast=fast-&gt;next-&gt;next;        slow=slow-&gt;next;        if(fast==slow)        &#123;            return true;        &#125;    &#125;    return false;    &#125;\n\n\n特殊情况：追不上\n这里有一个附加的思考问题：fast指针比slow走得快，它们就一定能追上吗？\n\n\n第九题：142.环形链表Ⅱ（较难😰）\nleetcode：142. 环形链表 II\n\n这道题比上一道多了一个要求，需要我们返回链表环形的开始节点\n\n示例1里的开始节点为2（下标为1）\n示例2里的开始节点为1（下标为0）\n\n\n\n题目分析这时候，单纯用快慢指针已经不行了，我们还需要想办法找到环的起始节点\n\n标出长度，直线部分为L，我们并不知道meet究竟在环的哪一个部分，设环的起点b到meet的长度为X（这里要注意先后顺序，避免搞混，见下图）\n\n假设有两个指针，一个head从链表的开头a开始走，一个从meet开始走，最终它们一定会在b点相交！\n\n从meet开始走的指针meet，在环里走N*C-X的长度来到b（这里的N指的是在环中走的圈数，是个未知数）\n从链表开头a开始走的指针head，走L长度来到b；\nmeet和head每次都走一步（步长相同）；\n\n在上一道链表有环相交的题目中：\n\nfast指针走了L+N*C+X的距离；\nslow指针走了L+X；\n慢指针是不可能在环中走超过一圈的，因为快慢指针每次的步长为1，是不可能错过的；\nfast指针走的距离是slow的两倍，即 L+N*C+X = 2(L+X)；\n\n这时候就能根据上方公司得出一个结论：L = N*C - X；\n分解一下这个表达式，L=(N-1)*C + (C-X)，你会发现，C-X不就是meet到b点（相遇点）的距离吗？\n转换为文字说明，即meet指针走C-X的长度来到b点，再走N-1圈就会与head相遇！\n敲代码分析到这里，我们就可以开始敲代码了~\nstruct ListNode *detectCycle(struct ListNode *head) &#123;    if (head == NULL)        return NULL;    struct ListNode* slow = head;    struct ListNode* fast = head;    struct ListNode* meet = NULL;    while (fast &amp;&amp; fast-&gt;next)    &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        if (fast == slow)        &#123;            meet=fast;//寻找相交点            break;        &#125;    &#125;    if((fast==NULL)|| (fast-&gt;next==NULL))        return NULL;//如果fast是遇到空退出循环的，说明不带环    while(1)    &#123;        if(head==meet)//相遇点即为环的起点             return meet;                meet=meet-&gt;next;        head=head-&gt;next;    &#125;    return NULL;&#125;\n\n\n第十题：138.复制带随机指针的链表（很难😱）\nLeetCode：138. 复制带随机指针的链表\n\n众所周知，当leetcode给一道题标出“中等”的时候，我这种菜🐕就要写N久，所以对于我来说，简单&#x3D;有难度，中等&#x3D;非常难。\n本题较难的地方不在于复制链表，而在于处理新链表的random指针\n\n解法一：用计数器找到对应位置\n这个方法的缺点是，每一个节点都需要两次遍历，第一次计数，第二次是在新的链表中查找，时间复杂度是O(N^2^)\n不过本题并没有对时间复杂度做出要求，所以这个方法肯定也是没问题的！\n\n重点来瞅瞅这个非常女少的解法二\n解法二：先复制后断开(๑•̀ㅂ•́)و✧这个解法的思路是，先在原链表的每一个节点之后插入一个和它相同的新节点\n\n再利用两个指针进行random的查找\n\n第一个7的random是空，我们直接给新的7random置空\n第二个13的random指向前一位7，新13的random指向原13random的下一位，即新开辟的7\n第三个11的random指向1，新11的random指向原链表1的下一位，即新的1\n\n这样一一对应，就能在新开辟的链表中找到对应的random！\n\n最后，我们需要做的，就是将新开辟的节点从原链表断开，重新链接成新的链表\n怎么样，是不是直接一个“妙”就跑出来了？\n\n\n本题并没有要求不改变原链表，但我们最好还是把原链表还原成初始状态\n\n直接上手敲代码，啪啪啪，一提交，执行出错！\n\n\n仔细找了找，发现是第三个板块最后处理末尾的NULL指针时会出现问题\n\n最后的代码如下！\nstruct Node* copyRandomList(struct Node* head) &#123;\tif(head==NULL)        return NULL;    //1.复制原链表    struct Node*HAED=head;//记录头节点    while(head)//将新链表的每个节点链接在原链表之后    &#123;        struct Node* newnode=(struct Node*)malloc(sizeof(struct Node));        newnode-&gt;val=head-&gt;val;        newnode-&gt;next=head-&gt;next;        head-&gt;next=newnode;        head=head-&gt;next-&gt;next;    &#125;    //2.链接新链表的random    struct Node* old=HAED;    while(old)    &#123;        struct Node* new=old-&gt;next;        if(old-&gt;random==NULL)            new-&gt;random=NULL;        else            new-&gt;random=old-&gt;random-&gt;next;        old=old-&gt;next-&gt;next;    &#125;    //3.将新链表解下来    struct Node* ret=HAED-&gt;next;//记录最后的返回链表    struct Node* oldlist=HAED;    while(oldlist)    &#123;        struct Node*copy=oldlist-&gt;next;        struct Node*next=copy-&gt;next;                oldlist-&gt;next=next;        if(copy-&gt;next==NULL)            copy-&gt;next=NULL;        else            copy-&gt;next=next-&gt;next;        oldlist=next;    &#125;     return ret;&#125;\n\n也就执行出错了十几次就找到错误了……问题不大（阿巴阿巴）\n\n第十一题：BM12链表排序\nBM12链表排序\n\n给定一个节点数为n的无序单链表，对其按升序排序。\n数据范围：0&lt;n≤100000，保证节点权值在[-10^9,10^9]之内。\n要求：空间复杂度 O(N)，时间复杂度 O(NlogN)\n\n方法1：因为允许O(N)的时间复杂度，直接将其写入一个数组，排序后重新链接就可以了。std::sort的时间复杂度正好是 O(NlogN)，也符合要求\n方法2：采用归并排序，不断左右切分，最小的分支是只有2个节点的时候，排成有序地返回；再将两个链表给连起来\n\n具体的看代码的注释吧！\n/** * struct ListNode &#123; *  int val; *  struct ListNode *next; *  ListNode(int x) : val(x), next(nullptr) &#123;&#125; * &#125;; */#include &lt;unistd.h&gt;#include &lt;vector&gt;class Solution &#123;  public:    void PrintList(ListNode* head, const string&amp; pstr) &#123;        cout &lt;&lt; pstr &lt;&lt; &quot;  &quot;;        while (head != nullptr) &#123;            cout &lt;&lt; head-&gt;val &lt;&lt; &quot; &quot;;            head = head-&gt;next;        &#125;        cout &lt;&lt; endl;    &#125;    // 无差别逆置    ListNode* reverseNode(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) &#123;            return head;        &#125;        ListNode* ans = reverseNode(head-&gt;next);        head-&gt;next-&gt;next = head;        head-&gt;next = nullptr;        return ans;    &#125;    // 递归函数    ListNode* _sortInList(ListNode* head) &#123;        // 如果只有一个值，直接返回        if (head == nullptr || head-&gt;next == nullptr) &#123;            return head;        &#125;        // 如果是两个值，那就进行排序后返回新链表的头        if (head-&gt;next-&gt;next == nullptr) &#123;            ListNode* low = head, *big = head-&gt;next;            if (head-&gt;val &gt; head-&gt;next-&gt;val) &#123;                low = head-&gt;next;                big = head;            &#125;            low-&gt;next = big;            big-&gt;next = nullptr;            return low; // 返回一个升序的链表        &#125;        // 如果是超过两个链表，那就进行找中，并将其拆分为两个链表传给自己        ListNode* slow = head, *fast = head;        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;        // 走到这里，slow就是中间的值，将其拆分掉        ListNode* Lhead = head;        ListNode* Rhead = slow-&gt;next;        slow-&gt;next = nullptr;        // 传递给自己，继续分化        Lhead = _sortInList(Lhead);        Rhead = _sortInList(Rhead);        // PrintList(Lhead, &quot;L&quot;);        // PrintList(Rhead, &quot;R&quot;);        // 最终获取到的两个链表都是有序的，将其连起来        ListNode phead(0), *cur_next;        while (Lhead != nullptr &amp;&amp; Rhead != nullptr) &#123;            // 找出小的，头插            if (Lhead-&gt;val &lt; Rhead-&gt;val) &#123;                cur_next = Lhead-&gt;next; // 先记录下下一个值                // 头插                Lhead-&gt;next = phead.next;                phead.next = Lhead;                // 移动到原本的下一个值                Lhead = cur_next;            &#125; else &#123;                cur_next = Rhead-&gt;next;  // 先记录下下一个值                Rhead-&gt;next = phead.next;// 头插                phead.next = Rhead;                Rhead = cur_next;// 移动到原本的下一个值            &#125;        &#125;        // 如果还有剩余值，那就全部头插        ListNode* not_empty = Lhead != nullptr ? Lhead : Rhead;        while (not_empty != nullptr) &#123;            cur_next = not_empty-&gt;next;// 先记录下下一个值            not_empty-&gt;next = phead.next;// 头插            phead.next = not_empty;            not_empty = cur_next;// 移动到原本的下一个值        &#125;        // 因为是把小值头插，最终得到的是降序序列，所以需要逆序        return reverseNode(phead.next);    &#125;    class BigListnode&#123;    public:        bool operator()(ListNode*L,ListNode*R)&#123;            return L-&gt;val &gt; R-&gt;val;        &#125;    &#125;;    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *     * @param head ListNode类 the head node     * @return ListNode类     */    ListNode* sortInList(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) &#123;            return head;        &#125;        // return _sortInList(head); // 方法1，递归+归并        // 方法2，用vector排序        ListNode* cur = head;        vector&lt;ListNode*&gt; nodev;        while (cur != nullptr) &#123;            nodev.push_back(cur);            cur = cur -&gt;next;        &#125;        // 排序，写个仿函数（排降序方便头插）        sort(nodev.begin(),nodev.end(),BigListnode());        ListNode phead(0);        // 遍历一遍，重新连起来        for(auto&amp;e:nodev)&#123;            // 头插            e-&gt;next = phead.next;            phead.next = e;        &#125;        return phead.next;    &#125;&#125;;\n\n\n\n结语💪刷完这些题，有没有觉得自己对链表的理解直接更上一层楼？\n\n如果大家对某道题有问题，或者有我没有说清楚的地方，可以在评论区提出来哦！\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","OJ刷题","链表"]},{"title":"【C语言】双向带头循环链表","url":"/posts/1493158800/","content":"[TOC]\n前言在之前的数据结构学习中，我们学习了顺序表、链表这两种结构\n\n顺序表：博客链接1\n单链表：博客链接2\n链表OJ：博客链接3\n\n之前本来是不想写双链表的博客的，但是看着自己的数据结构专栏少了一part，有强迫症的我感觉很不爽，于是补上了本篇大水文\n1.双链表的结构除了单链表以外，还有一个结构，是双向带头循环链表。这个链表的形式如下\n\n头节点的prev指向尾部节点\n尾节点的next指向头节点，构成循环\n\n\n别看它的形式有些复杂，实际代码的实现，比单链表还简单！\n因为head-&gt;prev指向了尾节点，所以不需要找尾。尾删的时候也不需要遍历找尾节点的前一位，因为尾节点的prev就存放了前一位的地址。\n\n2.代码实现下面贴出双链表实现的源码，如果大家有问题，可以在评论区提出\n只要你学会了单链表的编写，也看完了我的链表OJ题博客，那双链表对于你来说肯定是信手拈来的\n\n2.1头文件DoubleList.h头文件\n如果你想尝试自己编写双链表的代码，可以先把头文件复制到你的本地编译器，将这些函数的实现搞出来\n#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;// 带头+双向+循环链表增删查改实现typedef int LTDataType;typedef struct ListNode&#123;\tLTDataType data;\tstruct ListNode* next;\tstruct ListNode* prev;&#125;ListNode;// 创建并返回链表的头结点ListNode* ListCreate();// 双向链表销毁void ListDestory(ListNode* pHead);// 双向链表打印void ListPrint(ListNode* pHead);//倒着打印，检查双链表是否完整void ListPrintReverse(ListNode* pHead);// 创建新的节点ListNode* BuyNode(LTDataType x);// 双向链表尾插void ListPushBack(ListNode* pHead, LTDataType x);// 双向链表尾删void ListPopBack(ListNode* pHead);// 双向链表头插void ListPushFront(ListNode* pHead, LTDataType x);// 双向链表头删void ListPopFront(ListNode* pHead);// 双向链表查找ListNode* ListFind(ListNode* pHead, LTDataType x);// 双向链表在pos的前面进行插入void ListInsert(ListNode* pos, LTDataType x);// 双向链表删除pos位置的节点void ListErase(ListNode* pos);\n\n2.2源文件DoubleList.c源文件\n还是建议你写完之后再来和我的函数对比对比。\n一定要记住：写完一个模块，测试一个模块，不要等到最后再测试！\n#define _CRT_SECURE_NO_WARNINGS 1#include &quot;DoubleList.h&quot;ListNode* ListCreate()&#123;\tListNode* Createnode = (ListNode*)malloc(sizeof(ListNode));\tif (Createnode == NULL)\t\tprintf(&quot;CreateNode failed\\n&quot;);\telse\t&#123;\t\tCreatenode-&gt;next = Createnode;\t\tCreatenode-&gt;prev = Createnode;\t&#125;\treturn Createnode;&#125;void ListDestory(ListNode* pHead)&#123;\tassert(pHead);\twhile (pHead-&gt;prev!=pHead)\t&#123;\t\tListNode* tail = pHead-&gt;prev;\t\tListNode* tailprev = tail-&gt;prev;\t\tfree(tail);\t\tpHead-&gt;prev = tailprev;\t&#125;\tfree(pHead);&#125;void ListPrint(ListNode* pHead)&#123;\tassert(pHead);\t\tListNode* cur = pHead-&gt;next;\twhile (cur-&gt;next!=pHead)\t&#123;\t\tprintf(&quot;%d -&gt; &quot;,cur-&gt;data);\t\tcur = cur-&gt;next;\t&#125;\tprintf(&quot;%d&quot;, cur-&gt;data);//打印最后一个节点\tprintf(&quot;\\n&quot;);&#125;void ListPrintReverse(ListNode* pHead)&#123;\tassert(pHead);\tListNode* tail = pHead-&gt;prev;\twhile (tail-&gt;prev != pHead)\t&#123;\t\tprintf(&quot;%d -&gt; &quot;, tail-&gt;data);\t\ttail = tail-&gt;prev;\t&#125;\tprintf(&quot;%d&quot;, tail-&gt;data);\tprintf(&quot;\\n\\n&quot;);\t&#125;ListNode* BuyNode(LTDataType x)&#123;\tListNode* Buy = (ListNode*)malloc(sizeof(ListNode));\tif (Buy == NULL)\t\tprintf(&quot;BuyNode failed\\n&quot;);\telse\t&#123;\t\tBuy-&gt;data = x;\t\tBuy-&gt;next = NULL;\t\tBuy-&gt;prev = NULL;\t&#125;\treturn Buy;&#125;void ListPushBack(ListNode* pHead, LTDataType x)&#123;\tassert(pHead);\tListNode* newnode = BuyNode(x);\tListNode* tail = pHead-&gt;prev;\ttail-&gt;next = newnode;\tnewnode-&gt;next = pHead;\tnewnode-&gt;prev = tail;\tpHead-&gt;prev = newnode;&#125;void ListPopBack(ListNode* pHead)&#123;\tassert(pHead);\tListNode* tail = pHead-&gt;prev;\tListNode* tailprev = tail-&gt;prev;\tfree(tail);\ttailprev-&gt;next = pHead;\tpHead-&gt;prev = tailprev;&#125;void ListPushFront(ListNode* pHead, LTDataType x)&#123;\tassert(pHead);\tListNode* newnode= BuyNode(x);\tnewnode-&gt;prev = pHead;\tnewnode-&gt;next = pHead-&gt;next;\tpHead-&gt;next = newnode;\tnewnode-&gt;next-&gt;prev = newnode;&#125;void ListPopFront(ListNode* pHead)&#123;\tassert(pHead);\tListNode* front = pHead-&gt;next-&gt;next;\tListNode* Popnode = pHead-&gt;next;//待爆破的头节点\tpHead-&gt;next = front;\tfree(Popnode);\tfront-&gt;prev = pHead;&#125;ListNode* ListFind(ListNode* pHead, LTDataType x)&#123;\tassert(pHead);\tListNode* cur = pHead-&gt;next;\twhile (cur!=pHead)\t&#123;\t\tif (cur-&gt;data == x)\t\t\treturn cur;\t\telse\t\t\tcur = cur-&gt;next;\t&#125;\treturn NULL;&#125;void ListInsert(ListNode* pos, LTDataType x)&#123;\tassert(pos);\tListNode* newnode = BuyNode(x);\tListNode* Prev = pos-&gt;prev;\tPrev-&gt;next = newnode;\tnewnode-&gt;prev = Prev;\tnewnode-&gt;next = pos;\tpos-&gt;prev = newnode;&#125;void ListErase(ListNode* pos)&#123;\tassert(pos);\tListNode* Prev = pos-&gt;prev;\tListNode* Next = pos-&gt;next;\tPrev-&gt;next = pos-&gt;next;\tNext-&gt;prev = Prev;\tfree(pos);&#125;\n\n测试文件test.c这里不再给出\n结语如果你对上面的代码有问题，欢迎在评论区提出！\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n一起向前！\n\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","链表"]},{"title":"【Python】在你的云服务/电脑上搭建Python环境","url":"/posts/800910784/","content":"本篇wiki会教你在你的电脑&#x2F;云服务器上搭建好Python环境\n\n\n创建你的Python环境要想让bot跑起来，没有一个Python的环境怎么办？\n本篇wiki会教你在你的电脑&#x2F;云服务器上搭建好可以运行KOOK机器人的Python环境\n1.windows在windows下写Python代码的方式有很多种，这里我介绍的是vs code\n如果你已经有了Pycham等代码环境，直接使用即可，也没必要看这篇wiki😋\n1.1安装Python\n进入Python官网 https://www.python.org/\n\n找到download，下载最新的Python版本包\n\n\n这里下载官方推荐的installer即可\n\n\n\n注：如果下载速度很慢，可以考虑使用迅雷等下载工具\n\n下载完成后，打开安装包，一定要勾选ADD PYTHON TO PATH这个选项\n\n一定要勾选ADD PYTHON TO PATH这个选项！\n一定要勾选ADD PYTHON TO PATH这个选项！\n一定要勾选ADD PYTHON TO PATH这个选项！\n\n\n然后无脑下一步即可，后续就不需要修改什么，建议也不要修改安装路径\n\n安装完毕后，在windows开始中找到命令提示符，也就是windows平台的cmd工具。\n或者用win+r快捷键，在弹出的框中输入cmd即可打开\n\n在里面输入Python，出现以下界面即为安装成功！\n\n\n1.2 安装VSC\n微软官网下载 https://code.visualstudio.com/\n\n在官网可以直接下载windows上的VSC，但是默认的下载链接下载是非常慢的！\nhttps://az764295.vo.msecnd.net/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n\n我们要做的就是把这个默认的下载链接改成国内的镜像源，下载速度就可以起飞！\n将下载地址中的az764295.vo.msecnd.net 更换为 vscode.cdn.azure.cn 更改后：https://vscode.cdn.azure.cn/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n安装同样是无脑下一步！\n注：请不要修改VSC的安装位置，可能导致VSC无法正常运行Python程序！\n\n打开VSC后，界面是英文的。别急，让我们安装几个插件，就可以愉快使用了\n点击左侧的这个按钮进入插件面版\n\n\n在这里可以安装插件，需要安装的插件有下面这些\nChinese(Simplified)  //VSC汉化插件Python  //python环境Pylance //python环境Pip Manager //安装、管理pip包Terminal Here //方便我们打开终端vscode-json //json格式化插件\n下好上面的插件后，你的左侧应该会多出来一个pip manager的按钮，在这里可以下载你需要的第三方依赖库\n\n\n到这里，windows下的Python环境搭建就完成了！\n1.3 尝试写个最简单的Python代码在VSC里面创建一个test.py文件（这里会让你选择一个工作目录，弄一个新的文件夹就可以了）\n填入下面的代码\nprint(&#x27;hello world&#x27;)\n按CTRL+SHIFT+T打开命令面板（左下角齿轮也可以打开），输入Terminal Here，选择下面这个选项\n\n\n在VSC的底部会打开这样的一个终端\n\n\n我们在这里输入Python test.py，即可运行刚刚写的hello world代码\n如果一切正常，应该是会输出这样的结果\n\n完成配置！\n2.Linux平台关于Linux平台的Python环境搭建，可以参考 博客\n\n\n下面是一次瞎升级python导致的错误记录,本人所用系统为CentOS 7.6，\n\n2.1.不要瞎改配置文件我先是参考了一些奇葩博客，里面说道了下载完python新版本后，需要修改下面两个yum的配置文件\n实际上，压根不要修改这个配置文件！！！！\n/usr/bin/yum/usr/libexec/urlgrabber-ext-down\n\n说是要把开头的#!/usr/bin/python2.7修改为升级后的版本\n实际上，压根不要修改这个配置文件！！！！\n因为修改了之后执行yum会出现下面这个报错\n-bash: /usr/bin/yum: /usr/bin/python: 坏的解释器: 没有那个文件或目录\n\n\n参考这篇博客，把配置文件该回去才让yum复活【链接】\n\nyum是基于python2.7的，你没事把人家依赖环境改了干哈子？\n2.2.正确下载Python的方法参考下面这个博客\n\nhttps://blog.csdn.net/weixin_41829333/article/details/110141988\n\n2.3.要对症下药教程博客里面提到了，需要重新创建软连接，这是没错\nln -sf /usr/local/bin/python3.8 /usr/bin/pythonln -sf /usr/local/bin/python3.8-config /usr/bin/python-config\n\n但是，并不是所有人的软连接都是用上面的代码创建！\n在执行完python新版本的make后，你需要通过下面的两个指令找到新版本py的安装路径\n[root@bt-7274:~]# whereis pythonpython: /usr/bin/python3.6m /usr/bin/python3.6 /usr/bin/python /usr/bin/python2.7-config /usr/bin/python2.7 /usr/lib/python3.6 /usr/lib/python2.7 /usr/lib64/python3.6 /usr/lib64/python2.7 /etc/python /usr/local/bin/python3.9-config /usr/local/bin/python3.9 /usr/local/lib/python3.9 /usr/include/python3.6m /usr/include/python2.7 /usr/local/python3/bin/python3.7 /usr/local/python3/bin/python3.9-config /usr/local/python3/bin/python3.7-config /usr/local/python3/bin/python3.9 /usr/local/python3/bin/python3.7m-config /usr/local/python3/bin/python3.7m /usr/share/man/man1/python.1.gz[root@bt-7274:~]# which python/usr/bin/python\n\n比如我这里很明显能看出来，我的新版本python3.9是安装在/usr/local/bin里面，而不是/usr/bin里面的\n同时，当我执行py出错时，报错的路径也是下面这个\n-bash: /usr/local/bin/python3: 没有那个文件或目录\n\n所以创建软链接的时候，需要对症下药进行修改！\nln -s /usr/local/python3/bin/python3 /usr/local/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3\n\n这样才能让py成功升级！\n2.4.请重下依赖库下载依赖库的时候，其实是只安装在了对应版本的python里面，也就是我的旧版本python3.7.8\n所以更新好了之后，你需要重新下所有的依赖库\n","categories":["速通Python"],"tags":["Linux","阿狸开发日志","Python","vscode"]},{"title":"【C语言】三道例题让你彻底学会栈和队列","url":"/posts/909011629/","content":"[TOC]\n前言本篇博客，将带着大家刷3道非常经典的OJ题。它们并不算特别难，但对我们理解数据结构中栈和队列的概念有很大的帮助。\n\n如果你还不了解栈，可以看看我之前的博客👉点我\n队列的博客就不写啦，本篇刷题的时候会提到队列的操作\n\n话不多说，直接开始吧！\n\n1.用队列实现栈\nleetcode：225. 用队列实现栈\n\n\n这道题的要求很简单，用两个队列来模拟栈的实现。\n我们知道，队列的操作是从后进，从前出，这就和我们在餐厅排队一样，先进入餐厅排队的人先得到座位。\n而栈是遵循上进上出的，即栈只能在栈顶插入元素和删除元素\n两个队列要如何结合，才能实现栈的要求呢？\n1.1思路首先我们讲数据push到其中一个队列中\n\n如果要访问此时的栈顶，使用队列中的tail尾指针来访问，即题目要求的TOP函数\n当我们需要pop数据的时候，将队列中的N-1个数据全部移动到另外一个队列里，再将最后的栈顶数据删除并返回\n\n最终的目的就是保证一个队列为空，另外一个队列保存数据\n\n\n这样就达成了栈只能在栈顶删除数据的要求\n最后还有一个函数是boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n当两个队列中都没有数据的时候，这个模拟的栈就是空的；\n只要其中一个队列有数据的时候，就代表这个栈是有数据的。\n\n1.2队列的代码你可能会注意到，这道题中并没有给我们初始的队列代码，也就是说我们需要“造轮子”，将自己写的C语言队列代码放在前头\n\n这也是C语言在写一些OJ题目时不方便的原因\n\n\n这里我贴出一个队列的代码，大家可以复制到自己的编译器上测试一下。\n如果有不理解的地方，可以在评论区提出！\n\n和栈的代码实现不同，队列使用链表的方式更加方便。其相当于一个只能尾插和头删的单链表\n为了方便我们找尾进行尾插，这里定义了另外一个结构体类型Queue，其中tail指针指向链表的尾部，方便尾插（否则每次尾插都需要遍历）\n\ntypedef int QDataType;typedef struct QueueNode{\tQDataType data;\tstruct QueueNode* next;}QNode;typedef struct Queue{//这个结构体里有两个指针\tQNode* head;//头\tQNode* tail;//尾}Queue;//初始化void QueueInit(Queue* pq){\tassert(pq);\tpq-&gt;head = NULL;\tpq-&gt;tail = NULL;}//摧毁void QueueDestory(Queue* pq){\tassert(pq);\tQNode* findtail = pq-&gt;head;//找尾挨个挨个free\twhile (findtail)\t{\t\tQNode* next = findtail-&gt;next;\t\tfree(findtail);\t\tfindtail = next;\t}\tpq-&gt;head = NULL;\tpq-&gt;tail = NULL;}//插入（尾插）void QueuePush(Queue* pq, QDataType x){\tassert(pq);\tQNode* newnode = (QNode*)malloc(sizeof(QNode));\tif (newnode == NULL)\t{\t\tprintf(\"Push err\\n\");\t\texit(-1);\t}\tnewnode-&gt;data = x;\tnewnode-&gt;next = NULL;\tif (pq-&gt;tail == NULL)\t{\t\tassert(pq-&gt;head == NULL);\t\tpq-&gt;head = pq-&gt;tail = newnode;\t}\telse\t{\t\tpq-&gt;tail-&gt;next = newnode;\t\tpq-&gt;tail = newnode;\t}\treturn;}//删除（头删）void QueuePop(Queue* pq){\tassert(pq);\tassert(pq-&gt;head &amp;&amp; pq-&gt;tail);//判断是否为空\tif (pq-&gt;head-&gt;next == NULL)\t{\t\tfree(pq-&gt;head);\t\tpq-&gt;head = NULL;\t\tpq-&gt;tail = NULL;\t}\telse\t{\t\tQNode* next = pq-&gt;head-&gt;next;\t\tfree(pq-&gt;head);\t\tpq-&gt;head = next;\t}}//判断是否为空bool QueueEmpty(Queue* pq){\tassert(pq);\t//在C中bool类型和int类型可以直接混用\treturn pq-&gt;head == NULL &amp;&amp; pq-&gt;tail == NULL;}//返回它的长度size_t QueueSize(Queue* pq){\tassert(pq);\tsize_t size = 0;\tQNode* findtail = pq-&gt;head;\twhile (findtail)\t{\t\tsize++;\t\tfindtail = findtail-&gt;next;\t}\treturn size;}//返回头QDataType QueueFront(Queue* pq){\tassert(pq);\tassert(pq-&gt;head);\treturn pq-&gt;head-&gt;data;}//返回尾部QDataType QueueBack(Queue* pq){\tassert(pq);\tassert(pq-&gt;tail);\treturn pq-&gt;tail-&gt;data;}\n\n1.3本题的代码将上述的队列代码拷贝在题目所给模板之前后，我们就可以开始写这道题需要的代码实现了\n//创建两个队列typedef struct {\tQueue q1;\tQueue q2;} MyStack;MyStack* myStackCreate() {\tMyStack* pst = (MyStack*)malloc(sizeof(MyStack));    //因为是在函数中，所以需要使用动态内存管理\tif (pst == NULL)//malloc可能失败\t\treturn NULL;\tQueueInit(&amp;pst-&gt;q1);//直接调用队列的函数进行初始化\tQueueInit(&amp;pst-&gt;q2);\treturn pst;}void myStackPush(MyStack* obj, int x) {\tassert(obj);\t//在push的时候，需要找到不为空的队列进行push\tif (!QueueEmpty(&amp;obj-&gt;q1))\t{\t\tQueuePush(&amp;obj-&gt;q1, x);\t}\telse\t{\t\tQueuePush(&amp;obj-&gt;q2, x);\t}}int myStackPop(MyStack* obj) {\tassert(obj);\t//通过判断找到为空和不为空的队列\tQueue* empty = &amp;obj-&gt;q1;\tQueue* unempty = &amp;obj-&gt;q2;\tif (!QueueEmpty(&amp;obj-&gt;q1))\t{\t\tempty = &amp;obj-&gt;q2;\t\tunempty = &amp;obj-&gt;q1;\t}\twhile (QueueSize(unempty) &gt; 1)\t{\t\tint top1 = QueueFront(unempty);\t\tQueuePush(empty, top1);\t\tQueuePop(unempty);\t}\t//先保存top，再进行出队列操作\tint top = QueueFront(unempty);\tQueuePop(unempty);\treturn top;//返回报错的top}int myStackTop(MyStack* obj) {\tassert(obj);\tif (!QueueEmpty(&amp;obj-&gt;q1))\t{\t\treturn QueueBack(&amp;obj-&gt;q1);\t}\telse\t{\t\treturn QueueBack(&amp;obj-&gt;q2);\t}}bool myStackEmpty(MyStack* obj) {\tassert(obj);\t//只有两个队列都为空的时候，模拟的栈才是空\treturn QueueEmpty(&amp;obj-&gt;q1) &amp;&amp; QueueEmpty(&amp;obj-&gt;q2);}void myStackFree(MyStack* obj) {\tassert(obj);\tQueueDestory(&amp;obj-&gt;q1);\tQueueDestory(&amp;obj-&gt;q2);\tfree(obj);//因为是动态内存开辟的，所以最后销毁的时候还需要销毁模拟栈的结构体\treturn;}\n\n16个用例都完美通过了！\n\n\n2.用栈实现队列\nleetcode: 232. 用栈实现队列\n\n\n有了上一道题目的经验，这道题的实现就不那么困难了。\n2.1思路\n栈的特点是只能在栈顶删除和插入数据\n\n队列需要在队尾插入数据，在对头删除数据\n\n\n假设现在我们有下面这两个栈，第一个栈里面存放了1 2 3 4的数据\n需要进行队列的POP操作时，我们需要删除的是最底部的1\n\n可以先将栈中的所有数据pop并push到另外一个空栈中，再将最后一个数据存放后删除，返回存放的值。\n\n这部分操作与第一题中的操作很像，但是有一个致命的问题：在新的栈里的数据和我们原本想要的数据是相反的！\n1 2 3 4 删除1后原本数据 2 3 4实际数据 4 3 2\n\n解决这个问题的方法只有一个，那就是把这一批数据再复制回原本的栈中，它的顺序就对了\n\n而我自己写的栈是用数组实现的，题目要求的peek函数可以直接通过访问非空栈的0下标元素得到\nempty函数同理，只有两个栈中都为空时，模拟的队列才是空的\n\n2.2栈的代码栈的实现在本文开头的博客链接中有详细解释，这里不再复述\n\n回到开头\n\n// 支持动态增长的栈typedef int STDataType;typedef struct Stack{    STDataType* a;    int top; // 栈顶    int capacity; // 容量}Stack;// 初始化void StackInit(Stack* ps){    STDataType* new = (STDataType*)malloc(sizeof(STDataType) * 4);    if (new == NULL)    {        exit(-1);    }    else    {        ps-&gt;a = new;        ps-&gt;top = 0;        ps-&gt;capacity = 4;    }}// 销毁栈void StackDestroy(Stack* ps){    assert(ps);    free(ps-&gt;a);    ps-&gt;a = NULL;    ps-&gt;capacity = 0;    ps-&gt;top = 0;}// 入栈void StackPush(Stack* ps, STDataType data){    assert(ps);    if (ps-&gt;top == ps-&gt;capacity)    {        STDataType* new = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * (ps-&gt;capacity) * 2);        if (new == NULL)        {            exit(-1);        }        else        {            ps-&gt;a = new;            ps-&gt;capacity *= 2;        }    }    ps-&gt;a[ps-&gt;top] = data;    ps-&gt;top++;}// 出栈void StackPop(Stack* ps){    assert(ps);    if (ps-&gt;top &gt; 0)        (ps-&gt;top)--;}// 获取栈顶元素STDataType StackTop(Stack* ps){    assert(ps);    assert(ps-&gt;top &gt; 0);    return ps-&gt;a[ps-&gt;top - 1];}// 获取栈中有效元素个数int StackSize(Stack* ps){    assert(ps);    return ps-&gt;top;}// 检测栈是否为空，如果为空返回true，如果不为空返回falsebool StackEmpty(Stack* ps){    assert(ps);    if (ps-&gt;top == 0)        return true;    else        return false;}void StackPrint(Stack* ps){    assert(ps);    int n = ps-&gt;top;    for (int i = 0; i &lt; n; i++)    {        printf(\"%d \", ps-&gt;a[i]);    }    printf(\"\\n\");}\n\n2.3本题的代码typedef struct {    Stack st1;    Stack st2;} MyQueue;MyQueue* myQueueCreate() {    MyQueue* qt = (MyQueue*)malloc(sizeof(MyQueue));    if (qt == NULL)        return NULL;    StackInit(&amp;qt-&gt;st1);    StackInit(&amp;qt-&gt;st2);    return qt;}void myQueuePush(MyQueue* obj, int x) {    assert(obj);    if (!StackEmpty(&amp;obj-&gt;st1))    {        StackPush(&amp;obj-&gt;st1, x);    }    else    {        StackPush(&amp;obj-&gt;st2, x);    }    return;}int myQueuePop(MyQueue* obj) {    assert(obj);    Stack* empty = &amp;obj-&gt;st1;    Stack* nonempty = &amp;obj-&gt;st2;    if (!StackEmpty(&amp;obj-&gt;st1))    {        Stack* empty = &amp;obj-&gt;st2;        Stack* nonempty = &amp;obj-&gt;st1;    }    while (StackSize(nonempty) &gt; 1)    {        int top1 = StackTop(nonempty);        StackPush(empty, top1);        StackPop(nonempty);    }    int top = StackTop(nonempty);    StackPop(nonempty);//原本不为空的的最后一个top被取出    //需要将数据再倒放一遍，否则访问是反的    while (StackSize(empty) &gt; 0)    {        int top2 = StackTop(empty);        StackPush(nonempty, top2);        StackPop(empty);    }    return top;}int myQueuePeek(MyQueue* obj) {    assert(obj);    Stack* empty = &amp;obj-&gt;st1;    Stack* nonempty = &amp;obj-&gt;st2;    if (!StackEmpty(&amp;obj-&gt;st1))    {        Stack* empty = &amp;obj-&gt;st2;        Stack* nonempty = &amp;obj-&gt;st1;    }    //这里的栈是用数组实现的，可以直接访问首位元素    return nonempty-&gt;a[0];}bool myQueueEmpty(MyQueue* obj) {    assert(obj);    return StackEmpty(&amp;obj-&gt;st1) &amp;&amp; StackEmpty(&amp;obj-&gt;st2);}void myQueueFree(MyQueue* obj) {    assert(obj);    StackDestroy(&amp;obj-&gt;st1);    StackDestroy(&amp;obj-&gt;st2);    free(obj);    return;}\n\n\n\n3.设计循环队列\nleetcode：622. 设计循环队列\n\n\n这道题最主要的突破口，就是弄明白题目所说的循环队列的意思\n实际上他就是一个下图所示的队列，当tail使用完已有空间后，可以跳到前面继续使用之前开辟好的空间，而不需要额外的扩容空间。\n\n为了方便找头以及找尾，本体将使用数组方式来实现它的代码\n\n3.1思路确定是数组形式后，我们就要来思考两个问题：什么时候队列为空？什么时候队列是满？\n3.1.1判断是否为空这个看起来好像非常简单，只要头指针和尾指针相同，队列不就是空的了嘛！\n\n这个想法对，但有有点瑕疵，即我们怎么界定空和非空的界限？\n3.1.2判断是否为满每插入一个数据，tail指针就会往后++一次，指向已有数据的下一位\n\n当下一位也被装好了数据之后，tail就会回到开头，来到front指针的位置！\n\n这个时候，tail=front，但是队列实际上已经满了！\n这就让我们不得不思考，如何将这两种情况区分开来？\n\n啊哈哈哈哈，答案来喽：\n\n如果需要的数据为K个，为队列的数组开辟K+1个空间\n\n这时候，只要tail+1=front，就代表队列已经满了。多出来的这一个空间不存放数据\n\n注意：这个空间不一定是最末尾的哪一个，它会随着队列的插入、删除操作而移动\n当tail在尾部，tail=k（注意tail是下标而不是指针）且front=0时，队列为满\n\n\n这样就很完美的把空和满两种情况给区分开来了！\n\n3.2本题代码实现需要注意题目给出的返回值要求，依照题目函数要求来编写\ntypedef struct {    int* data;    int front;    int tail;    int k;} MyCircularQueue;bool myCircularQueueIsEmpty(MyCircularQueue* obj);bool myCircularQueueIsFull(MyCircularQueue* obj);//为了让这个函数能在它之前使用MyCircularQueue* myCircularQueueCreate(int k) {    MyCircularQueue* qt = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));    if (qt == NULL)        return NULL;    qt-&gt;data = (int*)malloc(sizeof(int) * (k + 1));    qt-&gt;k = k;        qt-&gt;front = 0;    qt-&gt;tail = 0;    return qt;}bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {    assert(obj);    if (myCircularQueueIsFull(obj))        return false;    obj-&gt;data[obj-&gt;tail] = value;    //obj-&gt;tail++;    //obj-&gt;tail %= obj-&gt;k+1;//保证数据在数组内部    if (obj-&gt;tail == obj-&gt;k)    {        obj-&gt;tail = 0;    }    else    {        obj-&gt;tail ++ ;    }        return true;}bool myCircularQueueDeQueue(MyCircularQueue* obj) {    assert(obj);    if (myCircularQueueIsEmpty(obj))        return false;    if (obj-&gt;front == obj-&gt;k)    {//front在预先开辟的第4个位置上        obj-&gt;front = 0;    }    else    {        obj-&gt;front++;    }    return true;}int myCircularQueueFront(MyCircularQueue* obj) {    assert(obj);    if (myCircularQueueIsEmpty(obj))        return -1;    return obj-&gt;data[obj-&gt;front];}int myCircularQueueRear(MyCircularQueue* obj) {    assert(obj);    if (myCircularQueueIsEmpty(obj))        return -1;    if (obj-&gt;tail == 0)    {        return obj-&gt;data[obj-&gt;k];    }    else    {        return obj-&gt;data[obj-&gt;tail - 1];    }    return -1;}bool myCircularQueueIsEmpty(MyCircularQueue* obj) {    return obj-&gt;tail == obj-&gt;front;}bool myCircularQueueIsFull(MyCircularQueue* obj) {    if ((obj-&gt;tail == obj-&gt;k) &amp;&amp; obj-&gt;front == 0)    {        return true;    }    else    {        return obj-&gt;tail + 1 == obj-&gt;front;    }}void myCircularQueueFree(MyCircularQueue* obj) {    assert(obj);    free(obj-&gt;data);    free(obj);    return;}\n\n\n结语刷完这3道题，有没有感觉数据结构的很多内容都是关系紧密的？🤩\n只要我们把链表和顺序表的内容搞得透彻，栈和队列这部分就没那么难了！\n加油！\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","OJ刷题","栈","队列","循环队列"]},{"title":"【Python】解决SSL certificate problem unable to get local issuer certificate","url":"/posts/3348986841/","content":"CentOS8 出现 SSL certificate problem: unable to get local issuer certificate 解决办法\n\n\n我想直接看解决办法\n1.错误来源我在一个docker安装的Centos8.5系统中启动我自己写的kook机器人时，遇到了下面的bug\n\n其大概意思是没有办法获取到本地的issuer certificate。如果你知道证书和CA的含义，那么大概能猜到这个报错是什么意思。\n\n所有站点的ssl证书，都需要经过CA机构的认证和颁发。操作系统会默认内嵌已有CA机构的公钥，以用于解密CA颁发的证书中的数字签名。\n\n因为CA机构是内嵌在操作系统本地的，如果一个证书的颁发机构不在本地已有CA中，该站点就会被报不安全。\n而无法获取本地issuer certificate，我猜测意思就是没有办法获取道操作系统内嵌的CA\n2.解决刚开始我尝试过通过python的ssl模组取消证书验证、更新本地证书和openssl，都没有解决这个问题。\n在Kook平台khl.py服务器的大佬帮助下，最终定位并解决了这个问题。\n2.1 更新本地ca包先 yum install ca-certificates，已经装过的话那就是 yum update ca-certificates 如果不行再 pip3 install certifi\n操作完毕上面的步骤，发现本地已经安装了最新版本的ca-certificates，python也有安装certifi包\n$ yum update ca-certificatesRepository extras is listed more than once in the configurationWarning: failed loading &#x27;/etc/yum.repos.d/epel.repo&#x27;, skipping.Last metadata expiration check: 8:42:37 ago on Thu 23 Feb 2023 03:09:14 PM UTC.Dependencies resolved.Nothing to do.Complete!$ pip3.10 install  certifiDefaulting to user installation because normal site-packages is not writeableRequirement already satisfied: certifi in ./.local/lib/python3.10/site-packages (2022.12.7)$ pip3.10 install  certifi -UDefaulting to user installation because normal site-packages is not writeableRequirement already satisfied: certifi in ./.local/lib/python3.10/site-packages (2022.12.7)\n\n2.2 查看本地主机的链接于是尝试使用如下命令，看看主机是否能成功连接到kaiheila.cn(kookapp.cn) 并认证ssl证书\nopenssl s_client -connect www.kookapp.cn:443 -showcerts\n\n输出了如下的信息\ndepth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CAverify return:1depth=1 C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1verify return:1depth=0 CN = *.kookapp.cnverify return:1CONNECTED(00000003)---Certificate chain 0 s:CN = *.kookapp.cn   i:C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1-----BEGIN CERTIFICATE-----MIIHkTCCBXmgAwIBAgIQCUlurlf6m1VXsuISNqlT8DANBgkqhkiG9w0BAQsFADBcMQswCQYDVQQGEwJVUzEXMBUGA1UEChMORGlnaUNlcnQsIEluYy4xNDAyBgNVBAMTK1JhcGlkU1NMIEdsb2JhbCBUTFMgUlNBNDA5NiBTSEEyNTYgMjAyMiBDQTEwHhcNMjIwNjE1MDAwMDAwWhcNMjMwNjE1MjM1OTU5WjAXMRUwEwYDVQQDDAwqLmtvb2thcHAuY24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDB1uHkQ/oEkGNloVa6wHz424VznxL+eUt6AAfNhtIXeone8rtnJqeoDJ24lmBYUrL00tChCp4rdTddcrqPppDYSEY7+/U0hf39pDrmsGKZeeOu7JvANjtvqLFdXsqe5CnXtxAo5QUXB9gckttoLTZZX5O1Gyi6mqDtsFCTaVpsQmZWVcbA21zLAdAZJyUyzM2VyfCUPQHs+VFErcmA9SN8nkppLyf00lIHCWR6v9HYC2XgjHN2JX8ARJwTEddhHjvleMc/SlHncU6fpZ8itWx8NzBL6MwPKEjmHgKp0VYBMY6PHrSR/j/XtgOweodp1JBIr6yLLlyCu/lJksCwMUIZAgMBAAGjggOSMIIDjjAfBgNVHSMEGDAWgBTwnIX9op99j8lou9XUiU0dvtOQ/zAdBgNVHQ4EFgQUYe6lb4/s4J82aqWfNDaev2MD8k4wIwYDVR0RBBwwGoIMKi5rb29rYXBwLmNuggprb29rYXBwLmNuMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwgZ8GA1UdHwSBlzCBlDBIoEagRIZCaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL1JhcGlkU1NMR2xvYmFsVExTUlNBNDA5NlNIQTI1NjIwMjJDQTEuY3JsMEigRqBEhkJodHRwOi8vY3JsNC5kaWdpY2VydC5jb20vUmFwaWRTU0xHbG9iYWxUTFNSU0E0MDk2U0hBMjU2MjAyMkNBMS5jcmwwPgYDVR0gBDcwNTAzBgZngQwBAgEwKTAnBggrBgEFBQcCARYbaHR0cDovL3d3dy5kaWdpY2VydC5jb20vQ1BTMIGHBggrBgEFBQcBAQR7MHkwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBRBggrBgEFBQcwAoZFaHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL1JhcGlkU1NMR2xvYmFsVExTUlNBNDA5NlNIQTI1NjIwMjJDQTEuY3J0MAkGA1UdEwQCMAAwggF/BgorBgEEAdZ5AgQCBIIBbwSCAWsBaQB3AOg+0No+9QY1MudXKLyJa8kD08vREWvs62nhd31tBr1uAAABgWbUskcAAAQDAEgwRgIhAL1qZKig2NqYtlAVnaXtJ7Tk+OuROrPHGR8t2zyNTb6xAiEAsLL5yuvJ/WtIj0bLwbKR0/nFe/Juub3aZjrNvUhzZIIAdQA1zxkbv7FsV78PrUxtQsu7ticgJlHqP+Eq76gDwzvWTAAAAYFm1LJ6AAAEAwBGMEQCIDK3qkxuTUB1Dngycy9/LECyVXjlpi2eJBAC6oZPJQ/VAiBs1iupiYwavmD2m6QrDzzZrW2MJWx4LMxCtvf6pmN3NwB3ALc++yTfnE26dfI5xbpY9Gxd/ELPep81xJ4dCYEl7bSZAAABgWbUsnkAAAQDAEgwRgIhAL5vfkeeQAwowpkUhf0U/Z2fFiL8IY+QsCyED40zw0d1AiEA02UjHM3tztsrMn2xyzmTkVgXnly/OozP+LjdwdsTa6gwDQYJKoZIhvcNAQELBQADggIBAGdBom7y2NXOZL7KxtZFBFQCBJrEQOHZvuN4Etkmotb+0aVnrEZ/Qc5+zl86YqURcmOZgPhzSjuVfTvUsJJ1TkC/tMYofoo1Db7B5yRxQmjEYRNLFAZ8rbP/pd5Js8ZGWW7RcxqG+zebqDDD2CWvpiJNStu/yjWwdsFXQUwU0XOGUfwJDHD0eSBaa3uclAn3kUqF82l2X9qzvy9EexGjPOSWyNuksjeScr32OyNUrwo7RUYJU4Ztl8xaiaxcvg7u2/o9WWzPhHMVI6ijrJbj6Wn+BMe3SMYcR/L+foItjWAuOqOVB7IKO32JgCkP1vyl8AWs0up8ddI/9jn3px8ii0HphKJnkCPZNmLnnOhFXQjoPy2PRmKqusP0kleJw1ZpQXsQpm3yZqFggyFH8S4ii83kkHBynC89dlwlBIkF29Ds4mYjau6mZZxE69By7ptvFvcYREYslaRMxd166PEf5mp5jBKSiI2iYcP8PQOudhObpkuw+KHz8ntkf++HeluuEiqsKyiyyiXm5dmRE/9uIUjPcQia5ohs2VpAgOLhLG6yphWCHQ6awFj9q3Ce1Mm5yXyZFvLXWGwoJj6jCVXAZDchwX4uiHW2fI3GHz1pTPg0L3NE/M2CHnQWJlh9cgOljmaZXCeKmLdA9phD+NQho5xVElRiF+rijlrkMutS7p1Y-----END CERTIFICATE----- 1 s:C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1   i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CA-----BEGIN CERTIFICATE-----MIIFyzCCBLOgAwIBAgIQCgWbJfVLPYeUzGYxR3U4ozANBgkqhkiG9w0BAQsFADBhMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBDQTAeFw0yMjA1MDQwMDAwMDBaFw0zMTExMDkyMzU5NTlaMFwxCzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjE0MDIGA1UEAxMrUmFwaWRTU0wgR2xvYmFsIFRMUyBSU0E0MDk2IFNIQTI1NiAyMDIyIENBMTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKY5PJhwCX2UyBb1nelu9APen53D5+C40T+BOZfSFaB0v0WJM3BGMsuiHZX2IHtwnjUhLL25d8tgLASaUNHCBNKKUlUGRXGztuDIeXb48d64k7Gk7u7mMRSrj+yuLSWOKnK6OGKe9+s6oaVIjHXY+QX8p2I2S3uew0bW3BFpkeArLBCU25iqeaoLEOGIa09DVojd3qc/RKqr4P11173R+7Ub05YYhuIcSv8e0d7qN1sO1+lfoNMVfV9WcqPABmOasNJ+ol0hAC2PTgRLy/VZo1L0HRMr6j8cbR7q0nKwdbn4Ar+ZMgCgCcG9zCMFsuXYl/rqobiyV+8U37dDScAebZTIF/xPEvHcmGi3xxH6g+dTCjetOjJx8sdXUHKXGXC9ka33q7EzQIYlZISF7EkbT5dZHsO2DOMVLBdP1N1oUp0/1f6fc8uTDduELoKBRzTTZ6OOBVHeZyFZMMdi6tA5s/jxmb74lqH1+jQ6nTU2/MmahGNxUuJpyhUHezgBA6sto5lNeyqc+3Cr5ehFQzUuwNsJaWbDdQk1v7lqRaqOlYjniomOl36J5txTs0wL7etCeMRfyPsmc+8HmH77IYVMUOcPJb+0gNuSmAkvf5QXbgPIZursn/UYnP9obhNbHc/9LYdQkB7CXyX9mPexnDNO7pggNA2jpbEarLmZGi4grMmfAgMBAAGjggGCMIIBfjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTwnIX9op99j8lou9XUiU0dvtOQ/zAfBgNVHSMEGDAWgBQD3lA1VtFMu2bwo+IbG8OXsj3RVTAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMHYGCCsGAQUFBwEBBGowaDAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNlcnQuY29tMEAGCCsGAQUFBzAChjRodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20vRGlnaUNlcnRHbG9iYWxSb290Q0EuY3J0MEIGA1UdHwQ7MDkwN6A1oDOGMWh0dHA6Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydEdsb2JhbFJvb3RDQS5jcmwwPQYDVR0gBDYwNDALBglghkgBhv1sAgEwBwYFZ4EMAQEwCAYGZ4EMAQIBMAgGBmeBDAECAjAIBgZngQwBAgMwDQYJKoZIhvcNAQELBQADggEBAAfjh/s1f5dDdfm0sNm74/dWMbbsxfYV1LoTpFt+3MSUWvSbiPQfUkoV57b5rutRJvnPP9mSlpFwcZ3e1nSUbi2oITGA7RCOj23I1F4zk0YJm42qAwJIqOVenR3XtyQ2VR82qhC6xslxtNf7f2Ndx2G7Mem4wpFhyPDT2P6UJ2MnrD+FC//ZKH5/ERo96ghz8VqNlmL5RXo8Ks9rMr/Ad9xwY4hyRvAz5920myUffwdUqc0SvPlFnahsZg15uT5HkK48tHR0TLuLH8aRpzh4KJ/Yp0sARNb+9i1R4Fg5zPNvHs2BbIve0vkwxAy+R4727qYzl3027w9jEFC6HMXRaDc=-----END CERTIFICATE--------Server certificatesubject=CN = *.kookapp.cnissuer=C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1---No client certificate CA names sentPeer signing digest: SHA256Peer signature type: RSA-PSSServer Temp Key: X25519, 253 bits---SSL handshake has read 3993 bytes and written 392 bytesVerification: OK---New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384Server public key is 2048 bitSecure Renegotiation IS NOT supportedCompression: NONEExpansion: NONENo ALPN negotiatedEarly data was not sentVerify return code: 0 (ok)---\n\n在这里面能看到如下内容\nSSL handshake has read 3993 bytes and written 392 bytesVerification: OK\n\n也就是说，我们的本地主机是能成功认证kookapp.cn的ssl证书的，那么问题就出现在python的ssl模块中了！\n2.3 检测python的ssl模块python开启一个REPL，输入如下的两行代码\nimport sslssl.create_default_context().cert_store_stats()\n\n输出的内容如下\n&gt;&gt;&gt; import ssl&gt;&gt;&gt; ssl.create_default_context().cert_store_stats()&#123;&#x27;x509&#x27;: 0, &#x27;crl&#x27;: 0, &#x27;x509_ca&#x27;: 0&#125;\n\n这里就能看出来问题了，全都是0！难怪说没有办法获取本地的CA\n作为对比，一台正常的windows11电脑输出如下\n&gt;&gt;&gt; import ssl&gt;&gt;&gt; ssl.create_default_context().cert_store_stats()&#123;&#x27;x509&#x27;: 87, &#x27;crl&#x27;: 0, &#x27;x509_ca&#x27;: 84&#125;\n\n2.4 解决错误找到了错误，那就得想办法解决！\npython开启一个REPL，输入如下的两行代码\nimport sslssl.get_default_verify_paths()\n\n输出内容如下，这是本地python查找ca证书的位置\n&gt;&gt;&gt; import ssl&gt;&gt;&gt; ssl.get_default_verify_paths()DefaultVerifyPaths(cafile=None, capath=&#x27;/usr/local/openssl-1.1.1/ssl/certs&#x27;, openssl_cafile_env=&#x27;SSL_CERT_FILE&#x27;, openssl_cafile=&#x27;/usr/local/openssl-1.1.1/ssl/cert.pem&#x27;, openssl_capath_env=&#x27;SSL_CERT_DIR&#x27;, openssl_capath=&#x27;/usr/local/openssl-1.1.1/ssl/certs&#x27;)\n\n其中/usr/local/openssl-1.1.1/ssl/cert.pem中应该会保存CA的信息\n查看本地的这个文件的内容\nls /usr/local/openssl-1.1.1/ssl/cert.pem\n\n好家伙，发现文件压根不存在！\nls: cannot access &#x27;/usr/local/openssl-1.1.1/ssl/cert.pem&#x27;: No such file or directory\n\n看看openssl的版本和路径\nopenssl  version -d\n\n输出如下\nOPENSSLDIR: &quot;/etc/pki/tls&quot;\n\n于是看看这个目录下有没有我们需要的cert.pem\n$ ls /etc/pki/tlscert.pem  certs  ct_log_list.cnf  misc  openssl.cnf  private\n\n有！那么接下来要做的，就是创建一个软连接，将其弄到&#x2F;usr&#x2F;local中！\nln -s /etc/pki/tls/cert.pem /usr/local/openssl-1.1.1/ssl/cert.pem\n\n3.完美！做完这一切后，再次运行机器人，这次么有报错了！\n$ py3 main.py[FileManage] load all files[BOT] Start at: [23-02-24 00:25:29][BOT.TASK] fetch_public_channel success\n\n也成功响应了命令！\n\n似乎这个问题在mac下更常见？由于没有使用过mac设备，本文不解释相关内容\n\n\n","categories":["速通Python"],"tags":["Python","Kook","CentOS"]},{"title":"【C语言】什么是树，二叉树又是啥玩意","url":"/posts/4161984418/","content":"[TOC]\n前言在之前的数据结构学习中，我们学习了顺序表、链表、栈、队列这几种结构\n它们都是用链表或者数组的方式来实现的，主要考察我们对结构体的运用\n\n今天让我们来学习一个新的数据结构，也就是下面这副图里面的树\n\n啊不好意思，图拿错了！😜\n是下面这个才对\n\n\n1.什么是树？1.1 树的概念树是一种非线性的数据结构，它是由n个有限节点组成的具有一定层次关系的集合。\n把它叫做树是因为它看起来的确像一个树的根部\n当然也可以理解为是树干在上，树叶在下的结构\n\n有一个特殊的节点，被称为根节点，也就是树的开头\n除了根节点外，其余节点都是,个互不相交的集合。每一个集合都是一颗与树的结构类似的子树\n每一个节点只能有一个前驱，但是可以有很多个后驱\n因此，树是递归定义的\n\n\n树中的子节点不能有交集\n\n上图中的B节点不能有G这个孩子，因为G已经有父母C了\n同理，G节点也不能同时拥有两对父母\n子节点之间也不能相连，如E和F不能相连\n\n\n1.2 树的相关知识点\n节点的度：一个节点含有的子树的个数称为该节点的度； 如下图：A的度为6\n\n叶节点或终端节点：度为0的节点称为叶节点； 图中B、C、H、I…等节点为叶节点\n非终端节点或分支节点：度不为0的节点； 如上图中D、E、F、G…等节点为分支节点\n简单的说，就是有娃的节点就是分支节点\n\n双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图，D是H的父节点\n孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：H是D的孩子节点\n\n兄弟节点：具有相同父节点的节点互称为兄弟节点； 如下图：P、Q是兄弟节点\n\n\n树的度：一棵树中，最大的节点的度称为树的度； 示例中树的度为6（即A的度）\n节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推\n树的高度或深度：树中节点的最大层次； 示例中树的高度为4\n\n堂兄弟节点：双亲在同一层的节点互为堂兄弟；如下图：H、I互为兄弟节点\n\n\n节点的祖先：从根到该节点所经分支上的所有节点；示例中A是所有节点的祖先\n子孙：以某节点为根的子树中任一节点都称为该节点的子孙。示例中所有节点都是A的子孙\n\n森林：由m（m&gt;0）棵互不相交的树的集合称为森林\n多个不相交的树就是森林\n\n\n\n1.3 树的代码表示表示树的方式有很多种，比如下面这种\n#define N 5 //指定树的度为5struct TreeNode{\tint data;\tstruct TreeNode* subs[N];//用指针数组存放孩子节点的指针};\n\n但这种方法不够优，给大家展示一个用的最广泛的方法——孩子兄弟表示法\ntypedef int DataType;struct Node{ struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域};\n\n通过这种方法，父亲节点只需要保存它的第一个娃，其他娃就让大娃的兄弟节点来找\n也就是家长只用管老大，老大管老二，老二管老三，依次往下……\n\n实际写代码的结构大概是下图这样\n\n2.二叉树在实际中，二叉树是使用较多的一种树的结构\n2.1 概念二叉树是度为2的树，它是一个特殊的树\n\n二叉树不存在度大于2的节点\n二叉树是有序树，它的娃（子树）有左右之分，次序不能颠倒\n\n\n所以，二叉树都是由下面各类节点组成的树\n\n2.2 特殊的二叉树满二叉树是一个特殊的完全二叉树\n\n满二叉树，每一层都是满的\n完全二叉树，最后一层必须从左到右连续\n\n满二叉树满二叉树：如果每一个层的节点数都达到最大值，那这个二叉树就是满二叉树。也就是说：满二叉树的层数为k，且节点总数是2k-1\n\n满二叉树的节点数是一个等比数列公式\n\n\n完全二叉树完全二叉树：完全二叉树是效率很高的数据结构。对于深度为K，有n个节点的二叉树，当且仅当每一个节点都与深度为K的满二叉树中编号从1至n的节点一一对应时，称为完全二叉树。\n简单说来，完全二叉树的最后一层不一定满，但必须要从左到右连续\n\n\n2.3 二叉树的性质\n只有一个节点的二叉树，度为0\n若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有2^(i-1)个结点\n若规定根节点的层数为1，则深度为h的二叉树的最大结点数是(2^h)-1\n对任何一棵二叉树, 如果度为0其叶结点个数为n0, 度为2的分支结点个数为n2，则有n0 = n2+1\n若规定根节点的层数为1，具有n个结点的满二叉树的深度，h=log2(n+1) 。 (ps： 是log以2为底，n+1为对数)\n对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号为i的结点有：\n若i&gt;0，i位置节点的双亲序号：(i-1)/2；i=0时为根节点编号，无双亲节点\n若2i+1&lt;n，左孩子序号：2i+1，2i+1&gt;=n否则无左孩子\n若2i+2&lt;n，右孩子序号：2i+2，2i+2&gt;=n否则无右孩子\n\n\n\n\n\n2.4 几个选择题1. 某二叉树共有 399 个结点，其中有 199 个度为 2 的结点，则该二叉树中的叶子结点数为（ ）A 不存在这样的二叉树B 200  √C 198D 199//叶子节点的数量 总比度为2的节点多1    2.在具有 2n 个结点的完全二叉树中，叶子结点个数为（ ）A n    √B n+1C n-1D n/2//N0+N1+N2=2n//2N0+N1-1=2n//N1只有0和1两种可能，因为n为整数，2n为偶数，所以2N0=2n，N0=n    3.一棵完全二叉树的节点数位为531个，那么这棵树的高度为（ ）A 11B 10  √C 8D 12//假设高度是h//完全二叉树节点最多2^h -1//             最少2^(h-1)-1 +1//可以通过这两个公式，推断出h=104.一颗完全二叉树第六层的叶子节点为9，那么这棵树的节点数最多为（）A 108B 109 √C 112D 119//1  //2  //4  //8  //16  //32  //64 - 9*2//因为题目中的是第六层的叶子节点，完全二叉树必须从左到右连续，所以说明第六层不只9个节点（那样算出来的结果不对）//所以是第六层已经满了，第七层没有满//把第七层去掉9个叶子节点的孩子就能算出最多的节点数\n\n3.二叉树的存储结构二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构\n3.1 顺序存储顺序结构存储就是使用数组来存储\n一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。\n\n现实使用中只有堆才会使用数组来存储\n下一篇博客会带大家认识堆这个特殊的树形结构（和内存里面那个堆😂没啥关系哈）\n\n\n\n看到这张图，你肯定想问，如果用数组结构存储，那还怎么还原出一颗树🎄呢？\n这里我们需要理解物理存储和逻辑结构的关系\n\n二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树\n那怎么计算这种情况下的父亲和娃呢？\nleftchild  = parent*2+1rightchild = parent*2+2parent     = (child-1)/2\n\n\n怎么样，是不是忽然感觉\n\n3.2 链式存储这就就没啥好说的啦，使用一个简单的二叉链就能构成二叉树\ntypedef int BTDataType;// 二叉链struct BinaryTreeNode{ \tstruct BinTreeNode* _pLeft; // 指向当前节点左孩子 \tstruct BinTreeNode* _pRight; // 指向当前节点右孩子 \tBTDataType _data; // 当前节点的值}\n\n\n4.树转换为二叉树4.1 说明有的时候，我们需要将一个没有规律的多叉树转换为二叉树。\n\n我们电脑磁盘的文件夹层级就是一个没有规律的树\n\n不说废话，直接来看栗子；下图就是一个没有啥规律可言的树，我们要做的，就是想办法把它变成一个二叉树！\n\n当然，如果以写代码的思考角度，在不要求顺序的前提下，我们可以直接遍历这棵树的所有节点，将其存入数组，再用二叉树的方式连接起来（或者直接节点数组当作顺序存储的二叉树）\n但是，以应试的角度，只能依照一个特定的方法，将其转成二叉树\n4.2 步骤\n连线：将树中具有兄弟关系的结点从左到右依次连线；\n去线：对于树中的每个结点，仅保留与其最左(即第一个)孩子的连线，去掉该结点到其余孩 子的所有连线；\n保留：如果当前节点已经是兄弟中的最左节点（比如上图中的B和E），则保留其与父节点的连线\n整形：调整为标准形状的二叉树（根结点+左子树+右叉树）\n\n依照上面的步骤，我们最终处理出的二叉树是下面的模样\n\n这里还有第二个栗子\n\n怎样，你学费了吗？\n5.二叉树转成树或者森林转换步骤是树转换为二叉树方法的逆过程，具体如下：\n\n整形：将二叉树中的所有结点的左孩子连线调整为垂直形态、右孩子连线调整为水平形态； \n连线：对于任一水平线上的结点，将该水平线上的第一个结点的父节点，与该水平线上的其他结点进 行连线； \n去线：去除所有的水平连线，即删除原二叉树中各结点与其右孩子的连线； 4\n整形：调整步骤3结束之后的树的形状，使其符合树的一般特征要求（父子、兄弟关系清晰）\n\n\n以下是俩示例\n\n\n结语嘿嘿嘿，本篇博客到这里就结束啦！\n下篇博客将带来堆的详解\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","树"]},{"title":"【Python】pip下载使用国内镜像源","url":"/posts/783373963/","content":"pip下载使用国内镜像源\n\n\n1.如何使用在直接用pip安装包的时候，有时候会非常非常慢\n可以用下面的命令，在安装的时候使用清华的镜像源\n-i https://pypi.tuna.tsinghua.edu.cn/simple\n\n比如下面的操作\npip3.10 install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple\n\n速度直接起飞\n2.修改配置文件Linux系统，在用户的家目录下创建一个.pip文件夹，并在里面创建一个pip.conf\n[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn\n\n保存后，查看是否配置成功\n$ pip3.10 config listglobal.index-url=&#x27;https://pypi.tuna.tsinghua.edu.cn/simple&#x27;install.trusted-host=&#x27;https://pypi.tuna.tsinghua.edu.cn&#x27;\n\n这样就配置好了，重启后生效\n\nwindows下pip配置文件路径如下（如果没有此文件，创建之）\nC:\\Users\\用户名\\pip\\pip.ini\n\n输入如下内容\n[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = pypi.tuna.tsinghua.edu.cn\n\n3.镜像源汇总目前我测试能直接访问的镜像源有下面几个。\n清华 https://pypi.tuna.tsinghua.edu.cn/simple豆瓣 https://pypi.doubanio.com/simple/中科大 https://mirrors.bfsu.edu.cn/pypi/web/simple/阿里云 https://mirrors.aliyun.com/pypi/simple/\n","categories":["速通Python"],"tags":["Python"]},{"title":"【Python】动手写一个git自动上传脚本！","url":"/posts/1095979040/","content":"本篇博客来教你用Python写一个简单的git自动上传脚本\n\n\n前言为什么需要一个这样的东西？\n有的时候，我的学习代码其实没啥好commit的，写一个自动上传的脚本，就可以自动执行完所有的命令，而不需要自己手动进行git三板斧操作\n\n项目代码已开源  https://gitee.com/musnow/learn_python_code/tree/master/code/22-09-02%20auto_git\n\n效果如下把EXE文件丢进你的git仓库路径，点一下就会自动执行命令\n\n\n打开你的仓库可以看到，成功上传了\n\n源码实现其实很简单，就是用OS往系统的命令行里面写命令而已\nimport osimport timedef GetTime(): #获取当前时间    return time.strftime(&quot;%y-%m-%d %H:%M:%S&quot;, time.localtime())#修改默认的提交信息commit_msg=f&quot; \\&quot;Code updated: &#123;GetTime()&#125;\\&quot; &quot;#git提交命令cmd_1 = &quot;git status&quot;cmd_2 = &quot;git add --all&quot;cmd_3 = &quot;git commit -m&quot;+commit_msgcmd_4 = &quot;git push&quot;print(&quot;[开始] 执行git自动上传&quot;)print(&#x27;[CMD]&#x27;,cmd_1)os.system(cmd_1)#显示当前动态print(&#x27;[CMD]&#x27;,cmd_2)os.system(cmd_2)#添加所有文件更改到工作区print(&#x27;[CMD]&#x27;,cmd_3)os.system(cmd_3)#自动commitprint(&#x27;[CMD]&#x27;,cmd_4)os.system(cmd_4)#push上传print(&quot;[结束] 完成git自动上传&quot;)print(&quot;窗口将在5s后关闭...&quot;)time.sleep(5)#休眠5秒可以看清楚结果\n\n这里的commit信息非常粗暴，就是当前的时间。所以如果你是在写项目，那肯定还是好好写commit信息的好。不然到时候想回退版本都不知道往哪儿回退😂\n利用pyinstaller打包成exe在windows命令行中，安装pyinstaller包\npip install pyinstaller\n\n安装完成之后，在命令行中输入pyinstaller，大概率会报错\nPS D:\\MyCode\\Python\\code\\22-09-02 auto_git&gt; pyinstallerpyinstaller : 无法将“pyinstaller”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ pyinstaller+ ~~~~~~~~~~~    + CategoryInfo          : ObjectNotFound: (pyinstaller:String) [], CommandNotFoundException    + FullyQualifiedErrorId : CommandNotFoundException\n\n这时候如果你去搜教程，什么添加环境变量啊巴拉巴拉的，很麻烦，而且还不一定有用\n\n在我的win11上，添加环境变量就是无效的\n\n这时候我们只需要找到python的安装路径，和里面存放pip包的路径\n在我的电脑上，存放路径如下。如果你找不到，可以直接全盘搜索pyinstaller.exe\nC:\\Users\\用户名\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\Scripts\\pyinstaller.exe\n\n然后我们就可以直接执行下面的命令了\nC:\\Users\\用户名\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\Scripts\\pyinstaller.exe -F 文件名.py\n\n随后pyinstaller就会开始打包，并在当前路径下生成一个build和dist文件夹。其中dist文件夹里面就存放了我们的exe文件\n\n利用ResourceHacker修改exe文件的icon实际上，pyinstaller是可以直接修改exe文件的icon的，命令如下\nC:\\Users\\用户名\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\Scripts\\pyinstaller.exe -F -w -i 图标.ico 文件名.py\n\n在我的电脑上，图标的确修改成功了，但是运行的时候，会多次弹出很多个命令行，非常不雅观！\n所以我就不用pyinstaller来生成图标，而是采用第三方软件ResourceHacker（安装包自行百度）\n\n点击图标组里面的图标\n\n右键这个0:0，选择“替换图标”，找到你想要的图标进行替换即可\n图标只支持.ico文件，你可以用下面这个网站进行jpg转ico\n\nhttp://www.ico51.cn/\n\n修改好后，需要点绿色的保存按钮。然后就修改成功了\n\n\n如果你发现没有修改成功，可能是因为windows缓存的问题，重启电脑即可！\n然后你就可以把这个exe丢到任何你想访到的git仓库路径下，自动上传文件啦！\n","categories":["速通Python"],"tags":["git","Python"]},{"title":"【Python】CentOS安装Python3.10 | 转载","url":"/posts/847195816/","content":"CentOS8安装Python3.10\n\n\n将所有命令里面python对应的版本号替换，就可以安装其他版本的python\n1.安装编译所需的依赖sudo yum -y updatesudo yum -y install openssl-devel libffi-devel bzip2-devel sqlite-develsudo yum -y groupinstall &quot;Development Tools&quot;\n\n考虑到本人需要安装python环境的一般都是台新机子，这里顺带给出几个常用软件包\nyum install gityum install vimyum install net-tools #netstat命令\n\n顺便给出在deepin上的操作，除了安装包的命令不同，后续操作完全相同！（测试使用deepin v23-beta虚拟机）\nsudo apt-get updatesudo apt-get upgrade\n\nsudo apt install make build-essential libssl-dev zlib1g-devsudo apt install libbz2-dev libreadline-dev libsqlite3-dev wget curl llvmsudo apt install libncurses5-dev libncursesw5-dev xz-utils tk-dev\n\n\n2. 安装 Python 3.10 必需的 openssl &gt;&#x3D; 1.1.11.1.1q 发布于 2022-Oct-12 14:17:24 ，算是较新的版本了！\n\nhttps://www.openssl.org/source/old/1.1.1/\n\n# 下载wget https://www.openssl.org/source/openssl-1.1.1q.tar.gz --no-check-certificate# 解压tar zxf openssl-1.1.1q.tar.gz# 进入文件夹cd openssl-1.1.1q# 生成makefilesudo ./config --prefix=/usr/local/openssl-1.1.1# 通过make安装sudo make &amp;&amp; sudo make install\n\n安装完毕这个之后，请检查环境变量中的CA证书是否正常，否则python运行时会报错。（主要是调用api时会报错）\nhttps://blog.musnow.top/posts/3348986841/\n目前我在CentOS8上安装此版本openssl时，python必然出现此问题。建议依照上文检查，再往后执行python安装步骤；\n排查将文章里面的解决步骤直接写在这里吧。安装好openssl后，执行如下命令，看看是否存在这个路径\nls /usr/local/openssl-1.1.1/ssl/cert.pem\n\n如果提示文件路径不存在，则执行如下命令\nln -s /etc/pki/tls/cert.pem /usr/local/openssl-1.1.1/ssl/cert.pem\n\n这样就能避免python导入ssl证书失败！\n\nPS: 如上操作在centos7.2和centos8stream中实测有效，其他系统无法保证有效！\n\n\ndeepin安装的python出现了上文提到的ssl证书无法获取的问题，且目前暂时没有找到解决办法（解决办法和centos不同）\n以下是我在deepin虚拟机里面，用本文方案安装python后测试的结果：\n\npython3.10.5 出现此问题且未知修复办法\npython3.10.6 没有出现此问题\n\n\n3. 安装 Python 3.10# 下载wget https://www.python.org/ftp/python/3.10.5/Python-3.10.5.tgz# 解压tar zxf Python-3.10.5.tgz # 进入文件夹cd Python-3.10.5# 生成makesudo ./configure --enable-optimizations --with-openssl=/usr/local/openssl-1.1.1 --with-openssl-rpath=auto --enable-loadable-sqlite-extensions# 安装sudo make altinstall\n\n如果官网安装慢，可以用如下连接下载对应版本\nwget https://registry.npmmirror.com/-/binary/python/3.10.6/Python-3.10.6.tgz\n\n\n慕雪的警告: 为了避免自己安装的python影响系统yum安装的使用，请不要将软连接直接连接成python\n比如我们安装的是python3.10.5，那软链接的时候，请链接python3.10命令，而不是链接python命令！\n当前官方提供的python3.10安装包，会自动链接python3.10和pip3.10，理论上无需手动操作!\n\n\n原文后半部分都是建立软连接的教程，为了避免引发误解，故此删除！\n版权声明：本文为CSDN博主「一_二」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/zltliqi/article/details/126449120\n\n","categories":["速通Python"],"tags":["Python","CentOS"]},{"title":"【C语言】什么是堆？堆排序和TopK问题又是如何实现的","url":"/posts/3640362579/","content":"[TOC]\n前言在上一篇数据结构博客中，我带大家一起学习了树以及二叉树这一个全新的数据结构。\n\n【C语言】什么是树，二叉树又是啥玩意\n\n本篇博客，就让我们一起来看看常被人津津乐道的堆排序以及堆这个数据结构是一个什么样的存在吧？\n\n1.堆的概念堆的概念是基于完全二叉树的\n\n当k1、k2、k3……kn的数据按照完全二叉树的方式存放在数组中，且这个完全二叉树满足某个节点的值总是不大于（或不小于）其父节点的值时，称该完全二叉树为堆。\n\n\n将根节点最大的堆叫大根堆\n根节点最小的堆叫做小根堆\n堆中某个节点的值总是不大于（或不小于）其父节点的值\n\n上篇树的博客中已经给大家解释过如何用数组的方式存放一颗完全二叉树，这里就不再赘述啦！\nleftchild=parent*2+1rightchild=parent*2+2parent=(child-1)/2\n\n接下来这道题目能考察你是否了解了堆的概念，自测一下吧！\n2.下列关键字序列中，序列（ ）是堆。A .{16，72，31，23，94，53}B .{94，23，31，72，16，53}C .{16，53，23，94，31，72}D .{16，23，53，31，94，72}   √\n\n简单说来，以0下标根为例，下标1和2为根的左右孩子。如果他们都比根小，代表这是一个小根堆，反之是大根堆。\n接着我们就需要判断，是不是所有节点的孩子都满足这个特性，如果出现某一个节点的孩子和该节点的父亲之间的关系不满足根节点和孩子之间的关系（如根节点的孩子比根节点大，那么该树中所有节点的孩子都应该比该节点大）那么这个就不是一个堆\n2.堆的实现先来尝试直接实现一个堆，即将数据以堆的结构存放在数组中\n这里给出一个堆的头文件，里面包含了一个堆的基本框架\n//实现一个小堆#include&lt;stdio.h&gt;#include&lt;assert.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;typedef int HPDataType;typedef struct Heap{\tHPDataType* a;\tsize_t size;\tsize_t capacity;}HP;void HeapInit(HP* php);//初始化-不进行扩容操作void HeapDestroy(HP* php);//摧毁void HeapPrint(HP* php);//打印//交换数组中两个元素的位置void Swap(HPDataType* pa, HPDataType* pb);//插入后向上调整，保证数据是(大/小)堆//child为待操作数据的下标void AdjustUp(HPDataType* a, size_t child);// 插入x以后，保持他依旧是(大/小)堆void HeapPush(HP* php, HPDataType x);//删除后向下调整，保证数组末尾数据位置正确//size堆的大小；root待调节数据的位置，0代表根部（堆顶）void AdjustDown(HPDataType* a, size_t size, size_t root);// 删除堆顶的数据。(最小/最大)；// 交换堆顶数据和数组末尾数据void HeapPop(HP* php);//判断是否为空bool HeapEmpty(HP* php);//返回堆的大小（节点个数）size_t HeapSize(HP* php);//返回堆顶，访问数组下标0HPDataType HeapTop(HP* php);\n\n2.1向上调整你会发现，相较于普通数据结构的增加、删除操作，堆有一个额外的操作，就是调整数据的位置。\n\n本篇博客不再对前面的基础操作进行讲解，如果有不会的可以评论区提出哦\n\n比如下面这幅图里的数组，我们可以直接在数组的末尾插入一个数据6，因为当前的这个堆是一个小堆，堆顶的数据是最小的数据，所以我们不需要对这个数据进行处理\n\n但当我们插入一个0，事情就不一样了。我们必须将这个0调整到堆顶的位置，才能让插入数据后的数组依旧是一个小堆\n\n转换为树的形状，即为下图\n\n我们需要让在叶节点的0往上爬，来到1的位置\n如何操作呢？\n\n将该节点与它的父节点进行比较，如果父节点大于该节点，则交换两个节点的位置。\n通过循环的来完成一个完整的向上调节工作\n\n在上篇博客中，我提到了下图所示的计算公式。使用这个公式来进行父节点和孩子节点的查找工作，再单独编写一个Swap函数进行交换\n\n代码实现如下\n//交换数组中两个元素的位置void Swap(HPDataType* pa, HPDataType* pb) {\tint tmp = *pa;\t*pa = *pb;\t*pb = tmp;}//向上调整，保证数据是(大/小)堆//child为待调整数据的下标位置void AdjustUp(HPDataType* a, size_t child){\tassert(a);//这里依旧需要断言，因为用户可能单独调用这个函数\twhile (child &gt; 0)\t{\t\tint parent = (child - 1) / 2;\t\tif (a[child] &lt; a[parent])//小堆，小的数据往上调\t\t{\t\t\tSwap(&amp;a[child], &amp;a[parent]);\t\t\tchild = parent;\t\t}\t\telse\t\t{\t\t\treturn;\t\t}\t}}// 插入x以后，保持他依旧是(大/小)堆// O(logN)void HeapPush(HP* php, HPDataType x){\tassert(php);\tif (php-&gt;size == php-&gt;capacity)\t{\t\t//如果容量为0，新容量为4；不为0，新容量为原本容量的2倍\t\tint newcapa = php-&gt;capacity==0 ? 4: php-&gt;capacity*2;\t\tHPDataType* tmp = (HPDataType*)realloc(php-&gt;a, newcapa*sizeof(HPDataType));//realloc接收空指针，作用与malloc相同\t\tif (tmp == NULL)\t\t{\t\t\tprintf(\"realloc failed!\\n\");\t\t\texit(-1);\t\t}\t\tphp-&gt;a = tmp;\t\tphp-&gt;capacity = newcapa;\t}\tphp-&gt;a[php-&gt;size] = x;//在数组末尾插入新数据\tphp-&gt;size++;\tAdjustUp(php-&gt;a, php-&gt;size - 1);}\n\n下图更加清晰地展示了向上调整函数的作用过程\n\n2.2向下调整同理，当我们pop掉一个堆顶的数据之后，就需要进行一定的调整，来维持堆的结构\n这里需要注意一个问题，栈顶的数据并不能直接pop掉，因为会破坏掉堆的结构。\n比如下面的这个堆中，如果我们直接删除掉堆顶的元素1，那请问谁来当新的爸爸呢？\n\n为了方便这里数据的处理，我们要先将堆顶的元素和数组的最后一个元素进行交换，再进行pop操作。\n\n\n因为我们的堆是用顺序表实现的，所以交换后，只需让size--即可达到pop的效果\n\n那么如何让8往下掉呢？\n同样是利用上面提到过的关系公式👉点我回到之前的公式图\n我们需要将8和它的孩子进行比较，如果8大于它的孩子，则进行交换。\n代码实现如下👇\n//删除后向下调整，保证数组末尾数据位置正确void AdjustDown(HPDataType* a, size_t size, size_t root){\tassert(a);\tint parent = root;\tint child = parent * 2 + 1;//左孩子\twhile (child &lt; size)\t{\t\t\t\t//找左右孩子中小的那一个\t\tif (child + 1 &lt; size &amp;&amp; a[child] &gt; a[child + 1])\t\t{//如果左孩子大于右孩子，则选择右孩子\t\t\tchild++;\t\t}\t\tif (a[child] &lt; a[parent])\t\t{\t\t\tSwap(&amp;a[child], &amp;a[parent]);\t\t\tparent = child;\t\t\tchild = parent * 2 + 1;\t\t}\t\telse\t\t{\t\t\treturn;\t\t}\t}}// 删除堆顶的数据。(最小/最大)；// 交换堆顶数据和数组末尾数据void HeapPop(HP* php) {\tassert(php);\tassert(php-&gt;size &gt; 0);\tSwap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);\tphp-&gt;size--;\tAdjustDown(php-&gt;a, php-&gt;size, 0);}\n\n这两个函数以外的其他函数就比较简单啦，相信学到这里的你肯定能自己根据头文件的函数声明来解决它们。回到头文件\n\n如果你有疑惑，可以去看看之前顺序表的实现，或者在评论区提问哦\n\n\n2.3代码测试老样子，一定要写完一个模块后，立马测试一个模块！\n\n3.堆排序上面我们自己实现了一个堆的代码，接下来我们可以借助这个堆的代码，进行排序操作。（解析见代码注释）\nvoid HeapSort(int* a, int size){\t// 小堆-升序\tHP hp;\tHeapInit(&amp;hp);\tfor (int i = 0; i &lt; size; ++i)\t{\t\tHeapPush(&amp;hp, a[i]);//往堆内放入数据\t}\tsize_t j = 0;\twhile (!HeapEmpty(&amp;hp))\t{\t\ta[j] = HeapTop(&amp;hp);//每一次都堆顶数据出来放入数组\t\tj++;\t\tHeapPop(&amp;hp);//删除堆顶数据，重新排序\t}\tHeapDestroy(&amp;hp);}\n\n可以看到，上述代码成功排序\n\n3.1为什么要进行堆排序？看到这里，你可能会有一个疑惑：排序的方式有很多种，我们可以直接冒泡排序，也可以利用库函数qsort进行排序，为什么要采取堆排序这种方式呢？还需要写一个堆的代码，多麻烦啊！\n\n要想解答这个问题，我们先来看看冒泡排序算法和堆排序算法的时间复杂度\n\n\n冒泡排序：遍历一遍数组是N，调整一次数据也是N，时间复杂读是O(N^2^)\n堆排序：建堆是O(N*logN)，取堆顶数据是O(N)，时间复杂度是O(N*logN)\n\n如果你不了解什么是时间复杂度，可以看看我的这篇博客👉传送门\n\n对于我示例中这个10个元素的数组来说，这两个时间复杂度的差距可能不是很大，但对于海量数据来说，差距就起飞啦！\n\n\n\n数据个数\nO(N*logN)\nO(N^2^)\n\n\n\n1000\n1000×10\n1000×1000\n\n\n100w\n100w×20\n100w×100w\n\n\n这个数据的差距可大的很呢！😱\n\n从上面的解释，你应该能看出来，堆排序是挺优秀！\n但是我们一般并不会写上面的代码，因为它需要另建一个堆来存放数据，空间复杂度是O(N)\n有没有什么办法，能够在原本的数组上建堆，来进行排序呢？\n3.2在原本数组上建堆直入主题，我们可以直接在原本的数据上，利用堆的向上/下调整算法，建立一个大堆或者小堆来进行排序。\n3.2.1向上调整-插入数据使用插入数据的思想，我们可以把数组第二个元素当作新的元素进行push操作，并利用向上调整算法来调整它们的位置，以此类推，这样就能建成一个堆。\n\n但是这个方法对于升序来说不够优化，后续会提到具体原因\n\n3.2.2 向下调整-删除数据假设我们有一个这样的数组（它现在还不算一个堆）\n\n我们可以从第一个非叶子节点（即8）开始，进行向下调整，如果它的孩子比它小，则进行交换。处理完8后，进一步处理7、2、4……\n最终我们会得到这样的一个小堆\n\n此时再将第一个数据和末尾数据进行交换，pop掉它，让它成为数组尾部的数据。再进行向下调整操作，依次循环，即可完成一个降序的排列\n3.2.3比较时间复杂度我们来比较一下上面两个方法的时间复杂度。\n\n如果是向上调整的话，第二层的2个节点要向上调整1次，第三层的4个节点要向上调整2次，最后累积，我们会得到下面这个公式$$T(h)=2^11+2^22+2^33+……+2^{h-1}(h-1)$$数学好的你，估计一眼就能看出来，这是一个等差×等比形式的数列，可以利用\n\n错位相减法，高考第17题，如果出上面这个式子，属于送分题\n快一年过去了，现在的我看到这个式子，属于送命题\n\n好吧其实也没那么难😂\n\n\n如果是向下调整算法，第一层要向下移动h-1层，第二层要向下移动h-2层，第h-1层需要往下移动1层，我们能得到下面的公式最后能得出，需要移动的总步数为在N很大的时候，减去的log(n+1)可以忽略，时间复杂度为O(N)\n由此可见，向下调整算法是更优的，它的时间复杂度更小\n\n3.3代码示例弄明白思路后，写代码就很简单啦！\n//交换数组中两个元素的位置void Swap(int* pa, int* pb) {\tint tmp = *pa;\t*pa = *pb;\t*pb = tmp;}// 打印数组void PrintArray(int* a,int n,const char*info){\tprintf(\"[%s] \",info);\tfor(int i=0;i&lt;n;i++)\t{\t\tprintf(\"%d \",a[i]);\t}\tprintf(\"\\n\");}// 堆排序void AdjustDown(int* a, int n, int root){\tassert(a);\tint parent = root;\tint child = parent * 2 + 1;//左孩子\twhile (child &lt; n){\t\t//找左右孩子中小(大)的那一个\t\tif (child + 1 &lt; n &amp;&amp; a[child] &gt; a[child + 1])\t\t{//如果左孩子大(小)于右孩子，则选择右孩子\t\t\tchild++;\t\t}\t\t// 这个也需要根据上方 a[child] &lt; a[child + 1] 大于小于的不同进行修改\t\t// 大堆，将大的往上调\t\t// 小堆，将小的网上调\t\tif (a[child] &lt; a[parent]){\t\t\tSwap(&amp;a[child], &amp;a[parent]);\t\t\tparent = child;\t\t\tchild = parent * 2 + 1;\t\t}\t\telse{\t\t\treturn;\t\t}\t}}// 升序用大堆// 降序用小堆void HeapSort(int* a, int n){\t// 向下调整--建堆 O(N)\tfor (int i = (n - 1 - 1) / 2; i &gt;= 0; --i){\t\tAdjustDown(a, n, i);//此时建的是一个小堆\t}\tPrintArray(a, n,\"建堆后\");\tsize_t end = n - 1;\twhile (end &gt; 0){\t\tSwap(&amp;a[0], &amp;a[end]);//前后交换，最大的数放到末尾，不进行下一次调整\t\tAdjustDown(a, end, 0);\t\tend--;\t}}\n\n测试一下代码，完美排序出了降序\n\n如果你需要升序的话，只需将原本实现的小堆代码中的判断条件改一下就行了。按下图修改，即可改为升序排序（建的大堆）\n\n\n4.TopK问题4.1问题说明TOP-K问题：即求数据结合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。\n比如：专业前10名、世界500强、富豪榜、游戏中前100的活跃玩家等\n对于Top-K问题，能想到的最简单直接的方式就是排序。有两个思路\n\n堆排序：时间复杂度O(N*logN)，空间复杂度O(1)\n在原本的数组上建立N个数的大堆，Pop K次，就能选出最大的前K个。时间复杂度O(N+K*logN)，空间复杂度：O(1)\n\n但是，如果数据量非常大，上面这两个方法就不太可取了(可能数据都不能一下子全部加载到内存中，而是存放在硬盘里面)\n\n4.2如何求解？\n用前K个数建立一个K个数的小堆，然后剩下的N-K个数依次遍历，如果比堆顶的数据大，就替换它进堆（进堆后要进行向下调整），最后堆里面的K个数据就是最大的前K个\n\n代码示例如下\nvoid PrintTopK(int* a, int n, int k){\t// 1.建堆--用a中前k个元素建堆\tint* kminHeap = (int*)malloc(sizeof(int) * k);\tassert(kminHeap);\tfor (int i = 0; i &lt; k; ++i)\t{\t\tkminHeap[i] = a[i];\t}\t//利用小堆代码的向下调整，建一个小堆\tfor (int j = (k - 1 - 1) / 2; j &gt;= 0; --j)\t{\t\tAdjustDown(kminHeap, k, j);\t}\t//堆顶是这个堆里面最小的数据\t//2.将剩余n-k个元素依次与堆顶元素判断，如果大于堆顶，则交换\tfor (int i = k; i &lt; n; ++i)\t{\t\tif (a[i] &gt; kminHeap[0])\t\t{\t\t\tkminHeap[0] = a[i];\t\t\tAdjustDown(kminHeap, k, 0);\t\t}\t}\tfor (int j = 0; j &lt; k; ++j)\t{\t\tprintf(\"%d \", kminHeap[j]);\t}\tprintf(\"\\n\");\tfree(kminHeap);}\n\n\n时间复杂度：O(K+logK*(N-K))\n空间复杂度：O(K)\n\n当N非常大，K很小的时候，这个算法的时间复杂度基本就是O(N)\n\n4.3测试代码通过time函数和srand函数，我们可以将一个10000个数的数组中的每个元素赋值小于100w的随机数，再在随机位置放入10个大于100w的数字。\n可以看到，上面的代码巧妙利用堆的知识，帮我们找出了这个10000个数的数组中最大的前K个数字\n\n\n结语堆和堆排序的知识到这里就讲解完毕啦！如果你还有什么问题，可以在评论区留言哦~\n\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","堆"]},{"title":"【Python】设置logging日志时间的时区","url":"/posts/1349268248/","content":"设置logging日志时间的时区\n\n\n1.问题最近我的几个python-bot项目都放在了replit上面白嫖运行，于是遇到了一个很让人头疼的问题。replit的终端采用的是UTC标准时间，比北京时间晚了8h，而我之前的项目，全都是用print来打印信息的（当时还不会用logging）\n为了知道日志输出的时间，我在每一个print里面都调用了一个获取当前时间的函数\ndef getTime():    &quot;&quot;&quot;获取当前时间，格式为 `23-01-01 00:00:00`&quot;&quot;&quot;    return time.strftime(&quot;%y-%m-%d %H:%M:%S&quot;, time.localtime())\n\n这个函数会返回系统的当前时间。对于linux、windows这些时区正确的机器而言，输出的都是北京时间，没有什么问题。\n\n如果你的linux机器（特别是用docker安装的）时区有问题，可以参考这篇文章来解决: 点我\n\n但是到replit上面就不一样了，即便你在.replit文件中添加了时区的环境变量，其依旧无法让localtime返回北京时间\nTZ = &quot;Asia/Shanghai&quot;\n\nshell中输入date查看当前时间，依旧晚8h\n\n我已经尝试过了，replit这个并不能像 linux修改时区 一样修改系统时间。\n我们就只能从python下手来解决这个问题了\n2.解决首先是getTime函数如和强制返回北京时间，我们需要将time改成使用datetime\nfrom datetime import datetimefrom zoneinfo import ZoneInfo # 在Py3.9以后是标准库def getTime():    &quot;&quot;&quot;获取当前时间，格式为 `23-01-01 00:00:00`&quot;&quot;&quot;    a = datetime.now(ZoneInfo(&#x27;Asia/Shanghai&#x27;)) # 返回北京时间    return a.strftime(&#x27;%y-%m-%d %H:%M:%S&#x27;)\n\n针对logging模块，也需要进行特殊处理\n\n参考 https://zhuanlan.zhihu.com/p/304672864\n\nlogging 模块中 asctime 的时间使用的是time.localtime()返回的时间 \n文档：library&#x2F;logging，library&#x2F;time\n而 time.localtime() 又是 ，使用的 time.time() 返回的时间，而 time.time() 返回的是 UTC 时间，即从 1970-1-1 00:00:00 到现在的秒数，由于时区不对，所以没有转成中国所在的 UTC+8 时区。\n经过 stackoverflow 上这篇回答的提醒，可以设定 logging.Formatter.converter 来转换时间，但是回答里是转换成 GMT 时间，我们需要自己重写一个函数来加上 UTC 偏移，返回正确的时间，传给 logging.Formatter.converter\n修改logging.Formatter.converterimport loggingimport datetimedef beijing(sec, what):    beijing_time = datetime.datetime.now() + datetime.timedelta(hours=8)    return beijing_time.timetuple()logging.Formatter.converter = beijing# 只打印info以上的日志（debug低于info）logging.basicConfig(level=logging.INFO,                    format=&quot;[%(asctime)s] %(levelname)s:%(filename)s:%(funcName)s:%(lineno)d | %(message)s&quot;,                    datefmt=&quot;%y-%m-%d %H:%M:%S&quot;)\n\n还可以使用如下办法\nimport loggingfrom datetime import datetimefrom zoneinfo import ZoneInfodef beijing(sec, what):    beijing_time = datetime.now(ZoneInfo(&#x27;Asia/Shanghai&#x27;)) # 返回北京时间    return beijing_time.timetuple()# 日志时间改为北京时间logging.Formatter.converter = beijing\n\n两种办法都可以的！\n3.验证可以看到，修改之前，log输出的时间离正确的时间差8h\n\n修改了之后，输出的时间就对了！\n\n不过，修改这个也需要看你的项目面向的对象是谁。因为我写的都是kook平台的机器人，kook作为国内平台，压根没有几个歪果仁用，所以直接修改，将程序里面所有需要涉及到可读时间的都指定为北京时间。\n如果你的项目是discord平台的机器人，那最好还是保留原状吧！\n需要注意的是，时区的设置影响的是可读时间，即23-03-24 20:14:48这样的时间；和时间戳并没有关系。\n","categories":["速通Python"],"tags":["Python","Kook"]},{"title":"【Python】如何给你的kook机器人添加上翻译功能","url":"/posts/644618981/","content":"翻译功能实现打开 code&#x2F;endpoints&#x2F;translate.py，这便是本仓库中翻译代码的实现。\n其中第一部分有道翻译的代码来自Many-Translaters项目，该项目上一次维护是在4年前，且里面的部分代码已经无法使用。该代码属于一个白嫖产物，稳定性未知。\n为了不让我的bot在有道翻译接口失效后直接没有了翻译功能，这里我使用了彩云小译来作“备胎”\n\n你可以在彩云小译的官网上找到api文档，内部包含了一个Python代码示例，开箱即用！免费用户申请的api-key，每月有100w字符的免费额度，对于我们的bot算是够用了。\n\n1.关于aiohttp和requests的优劣在khl.py一众大佬的建议下，我简单学习了aiohttp的代码，并将彩云小译的requests修改为了aiohttp\n#原有requests代码response = requests.request(&quot;POST&quot;, url, data=json.dumps(payload), headers=headers)return json.loads(response.text)[&quot;target&quot;]#替换为aiohttp代码async with aiohttp.ClientSession() as session:    async with session.post(url, data=json.dumps(payload), headers=headers) as response:        return json.loads(await response.text())[&quot;target&quot;]\n\n这里简单说一下aiohttp和requests的区别\n\nrequests途中，程序会挂起，bot将不会响应其他命令\naiohttp作为异步框架，bot在使用它的同时，可以同步处理其他命令\n\n举个栗子：假设有用户每1分钟调用一次bot的翻译接口，彩云小译的服务器用了3秒钟（实际肯定没那么久）响应了我们的requests。这3秒钟内，如果有其他用户调用了bot的另外一个指令，我们的bot就跟假死了一样，不会响应该用户的指令\n这样看来，优势就很明显了：虽然在网络稳定的时候，requests和aiohttp不会形成鲜明的效率差距，但在KOOK或者彩云小译服务器拥堵期间，我们的bot也能做到不会因为requests时间太长而影响用户的使用体验。\n2.利用抛异常机制更改翻译引擎看到main.py中的translate部分，这里我import了translate.py中的相关函数，随后使用bot.command来调用这两个函数。那么如何让bot在有道翻译接口寄了的时候，自动去找备胎彩云小译呢？\n\n简单了解抛异常\n\n在python中，基本的抛异常机制如下：\ntry:    num(&#x27;a&#x27;, &#x27;b&#x27;)except:    print(&#x27;程序奔溃啦！&#x27;)\n\n上面这个代码就是一个简单的抛异常机制。编译器会先尝试运行try后面的代码，如果该部分报错，则会转而执行except后的代码。\n转换倒我们这里的例子，我们只需要在try后面写入有道翻译的代码，在except后写入彩云小译的代码，编译器就能在有道的接口出错的时候，自动找备胎\ntry:\t#有道代码实现except:    #彩云小译代码实现\n\n\n3.关于带空格英文句子传参问题当我们翻译一个句子的时候，中文内容往往没有空格，但英文句子极其依赖于空格进行单词的分割。\n如果我们简单地使用str来接受传参，就会导致用户需要翻译的英文内容，只有第一个单词传了过来\nasync def translate(msg: Message,txt:str):\n\n比如当用户打出：/TL I LOVE YOU时，bot实际接收到的只有首单词I，它会翻译该单词，可后面的LOVE YOU直接被无情抛弃了！\n这里我们就需要使用python中牛逼的不定传参*arg了！\nasync def translate(msg: Message,*arg):\n\n*arg是python中支持的不定参数传参，即函数先前不知道用户会传入多少个参数。我们可以在传参完毕后，再对这些参数进行操作。\n利用*arg的特性，我们可以一次性把所有单词都接收过来，再在函数中将它们拼成一个完整的字符串，传入到translate函数中。\nasync def translate(msg: Message,*arg):    word = &quot; &quot;.join(arg)\n\n这里的&quot; &quot;.jion(arg)代表用空格来分隔每一个参数，这样才能拼出一个完整的英文句子！\n\n\n\n好了，基本的单句翻译已经写好了，但我们还可以整点花活，让bot可以实时翻译某一个文字频道内的所有消息！\n4.实时翻译（全局变量）见main.py中的ListTL，这里我为实时翻译创建了一个全局数组，用来存放需要实时翻译的文字频道id。\n注意：ListTL作为全局变量，在函数中调用的时候，需要先用global ListTL进行全局变量声明。否侧程序会在该函数中创建临时变量！\n\n当用户需要实时翻译时，利用/TLON功能在他所在的文字频道开启该功能\n\nbot可以在msg.ctx.channel.id中获取到用户所在文字频道的id，并将其写入List中\n\n使用@bot.command(regex=r&#39;(.+)&#39;)正则表达式获取文字频道的所有内容，再通过判断该文字频道id是否存于List之中，来确认是否要进行实时翻译并返回结果\n\n这种正则方法也是让bot监看文字频道的一个非常好的办法，比如发现关键词之后，自动发送对应消息提示。\n\n当用户使用/TLOFF关闭实时翻译后，将对应位置的List置零，空出栏位\n\n具体的代码实现可以查看main.py中translate相关部分的函数\n5.处理met和rol消息为了避免冲突，机器人不应该翻译 @xx用户和@xx角色 的消息，在kook的后台，机器人会接收到 (met)user_id(met)/(rol)role_id(rol) 格式的文字；\n用下面的代码处理，可以将这两个串替换成空串，不进行翻译\n# 单独处理met和rol消息，不翻译这部分内容def deleteByStartAndEnd(s, start, end):    # 找出两个字符串在原始字符串中的位置    # 开始位置是：开始始字符串的最左边第一个位置；    # 结束位置是：结束字符串的最右边的第一个位置    while s.find(start) != -1:        x1 = s.find(start)        x2 = s.find(end, x1 + 5) + len(end)  # s.index()函数算出来的是字符串的最左边的第一个位置，所以需要加上长度找到末尾        # 找出两个字符串之间的内容        x3 = s[x1:x2]        # 将内容替换为空字符串s        s = s.replace(x3, &quot;&quot;)    print(f&#x27;Handel&#123;start&#125;: &#123;s&#125;&#x27;)    return s\n\n\n结语使用实时翻译可以实现一些好玩的事情：比如把一句话来回翻译N遍进行“提纯”\n（非常无聊了属于是）\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】如何多文件编写KOOK机器人","url":"/posts/3454615823/","content":"这个工作一定要早做！！不然就会像我一样，main.py 几千行，找个代码的位置都很困难🙅‍♀️\n好不容易才把阿狸的代码给重构了，将其他命令移动到了各自的文件\n1.基础在对bot进行编程的时候，根据功能不同，会将代码分成几大板块。\n如果将这些内容全部放入一个main文件中的话，虽然是可以的，但会显得非常长和杂乱，且不方便定位问题。\n再加上本人有一定强迫症，于是将valorant查询代码的实现和translate功能的实现分开封装，再在main.py文件中使用bot.command调用\n1.1 在支线文件中要怎么写？以一个最简单的hello代码为例。因为khl.py是异步框架，所以在支线文件中的函数都应该带上async和await来执行功能\n同时，支线文件中也需要import主文件中包含的库函数、以及bot的token。一个比较偷懒的方法就是把主文件import过的内容原封不动的复制到支线文件中\nasync def world(msg: Message):    await msg.reply(&#x27;你好呀~&#x27;)\n\n1.2 在主文件中要怎么写？\n主文件：包含bot.run的文件，有且只能有一个\n\n现在我们的支线文件中已经有一个函数的实现了，在主文件中只需要import支线文件的函数后，实现bot.command让机器人调用这条命令就行\nfrom test import world@bot.command(name=&#x27;hello&#x27;)async def world123(msg: Message):    await world(msg)\n\n要知道，这只是一个示例。像这种较短的程序无需分文件。但如果你的函数实现非常长的时候，就可以用相同的办法实现多文件编程。\n2.进阶前面的办法，也只是编程语言中最常用的导入函数方式。因为Python支持函数内嵌套函数，我们就能实现一个骚操作，在函数里面注册bot。\n说人话就是，这个命令的完整实现，包括命令的注册，都可以丢到另外一个文件中！\n\n如下，我们只需要给支线文件中上一个函数，参数为bot，再内部正常编写代码\nfrom khl import Bot,Messagedef init(bot:Bot):    @bot.command(name=&#x27;hello&#x27;) # 必须写明命令的name    async def world123(msg: Message):        await world(msg)\n\n然后，在主文件中，bot启动之前，调用这个init函数即可！\nfrom test import init # 支线文件from khl import Bot,Messagebot = Bot(token=config[&#x27;token&#x27;][&#x27;bot&#x27;])@bot.on_startupasync def bot_init(bot: Bot):\tinit(bot) # 调用支线文件中的init函数来注册命令\n\n这样才是真正的分文件编写bot！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】对async与await的理解","url":"/posts/1092148697/","content":"对python async与await的理解\n\n\n版权声明：本文为CSDN博主「MaNong125」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/MaNong125/article/details/120987087\n\nasync&#x2F;await关键字是出现在python3.4以后。网上已经有很多文章对async&#x2F;await这两个关键字都有讲解，包括如何由python2的yield from发展到async&#x2F;await这两个关键字，以及一些代码实现都有。\n但是对于像我这样初次接触的人来说，光看代码分析也不一定能理解，我也是在度娘上搜索很多相关的网站，当中也有官网，都没有发现能让我一眼看懂在什么地方可以用await，什么情况用await的文章。\n经过自己的重新思考，总算对async、await有一些初步的了解，所以想把自己的理解记录下来，希望对一些学习协程或者异步的初学者也有一定的帮助。\n对于网上能搜到的一些代码实现、例子，这里就不重复了。\n一、首先要知道什么是协程、异步。\n举个例子：假设有1个洗衣房，里面有10台洗衣机，有一个洗衣工在负责这10台洗衣机。那么洗衣房就相当于1个进程，洗衣工就相当1个线程。如果有10个洗衣工，就相当于10个线程，1个进程是可以开多线程的。这就是多线程！\n那么协程呢？先不急。大家都知道，洗衣机洗衣服是需要等待时间的，如果10个洗衣工，1人负责1台洗衣机，这样效率肯定会提高，但是不觉得浪费资源吗？明明1 个人能做的事，却要10个人来做。只是把衣服放进去，打开开关，就没事做了，等衣服洗好再拿出来就可以了。就算很多人来洗衣服，1个人也足以应付了，开好第一台洗衣机，在等待的时候去开第二台洗衣机，再开第三台，……直到有衣服洗好了，就回来把衣服取出来，接着再取另一台的（哪台洗好先就取哪台，所以协程是无序的）。这就是计算机的协程！洗衣机就是执行的方法。\n当你程序中方法需要等待时间的话，就可以用协程，效率高，消耗资源少。\n好了！现在来总结一下：\n洗衣房 ==&gt; 进程洗衣工 ==&gt; 线程洗衣机 ==&gt; 方法（函数）\n\n\n\n二、async\\await 的使用\n正常的函数在执行时是不会中断的，所以你要写一个能够中断的函数，就需要添加async关键。\nasync 用来声明一个函数为异步函数，异步函数的特点是能在函数执行过程中挂起，去执行其他异步函数，等到挂起条件（假设挂起条件是sleep(5)）消失后，也就是5秒到了再回来执行。\nawait 用来用来声明程序挂起，比如异步程序执行到某一步时需要等待的时间很长，就将此挂起，去执行其他的异步程序。await 后面只能跟异步程序或有__await__属性的对象，因为异步程序与一般程序不同。假设有两个异步函数async a，async b，a中的某一步有await，当程序碰到关键字await b()后，异步程序挂起后去执行另一个异步b程序，就是从函数内部跳出去执行其他函数，当挂起条件消失后，不管b是否执行完，要马上从b程序中跳出来，回到原程序执行原来的操作。如果await后面跟的b函数不是异步函数，那么操作就只能等b执行完再返回，无法在b执行的过程中返回。如果要在b执行完才返回，也就不需要用await关键字了，直接调用b函数就行。所以这就需要await后面跟的是异步函数了。在一个异步函数中，可以不止一次挂起，也就是可以用多个await。\n三、实例：\nasync def test2(i):    r = await other_test(i)    print(i,r) async def other_test(i):    r = requests.get(i)    print(i)    await asyncio.sleep(4)    print(time.time()-start)    return r url = [&quot;https://segmentfault.com/p/1210000013564725&quot;,        &quot;https://www.jianshu.com/p/83badc8028bd&quot;,        &quot;https://www.baidu.com/&quot;] loop = asyncio.get_event_loop()task = [asyncio.ensure_future(test2(i)) for i in url]start = time.time()loop.run_until_complete(asyncio.wait(task))endtime = time.time()-startprint(endtime)loop.close()\n\n输出结果：\nhttps://segmentfault.com/p/1210000013564725https://www.jianshu.com/p/83badc8028bdhttps://www.baidu.com/4.425147771835327https://segmentfault.com/p/1210000013564725 &lt;Response [200]&gt;4.5975635051727295https://www.jianshu.com/p/83badc8028bd &lt;Response [403]&gt;4.722797632217407https://www.baidu.com/ &lt;Response [200]&gt;4.722797632217407\n\n对于下面这几行代码：\nloop = asyncio.get_event_loop()task = [asyncio.ensure_future(test2(i)) for i in url]loop.run_until_complete(asyncio.wait(task))loop.close()\n\n可以在网上找到具体讲解，在这可用下图来粗略形容一下\n\n当所有的异步程序运行完就会返回最后结果。\n对于什么是task和future，asyncio.wait()与asyncio.gather()、asyncio.ensure_future(）这些大家可以网上找到解释。\n说到这里，相信你也大概清楚在什么时候用async、什么时候await了吧! 如果有说得不对的地方，请多多指正！！\n","categories":["速通Python"],"tags":["Python","Kook"]},{"title":"【Python】将kook机器人和爱发电对接，实现vip自动化销售","url":"/posts/2140431451/","content":"demo开源地址 https://github.com/musnows/Kook-Afd-Webhook-Bot\n1.简介本文档主要讲解如何将kook机器人与爱发电的webhook功能进行对接\n\n商品以vip作为示例，提供一个基础的python-demo\n\n主要流程如下\n\n机器人提供vip商城命令，用户执行，机器人发送一张包含不同价位vip价格和购买url的卡片给用户（临时消息，只有这个用户能看到）\n用户购买商品时，爱发电发送webhook给机器人\n机器人获取webhook信息中的custom_order_id，解析出用户id和购买天数，自动给对应用户上vip\n\n相关文档\n\n机器人所用框架：github.com&#x2F;TWT233&#x2F;khl.py\n爱发电webhook接口文档：https://afdian.net/p/9c65d9cc617011ed81c352540025c377\n\n开始前，你需要先拥有自己的kook-bot，并注册爱发电，申请爱发电开发者权限\n\n如果你想使用CDK（即兑换码）的方式来分发vip，可以看看我的 Valorant-Shop-CN&#x2F;Kook-Valorant-Bot 项目\n\n2.python-demo2.1 webhook-api要想和爱发电的api对接，首先bot自己需要维护一个webhook的api-url。这也要求你的机器人是部署在可公网访问的环境中，否则爱发电的webhook无法送达。\n\n爱发电开发者页面 https://afdian.net/dashboard/dev\n该url必须为https协议，所以你还需要绑定域名并配置ssl\n\n同时，为了保证webhook中始终有custom_order_id字段，您需要告知您的用户，只能通过机器人生成的url来购买vip。否则自动化流程将失效\n\n机器人收到爱发电webhook\n解析webhook中的键值，获取到custom_order_id\n解析custom_order_id，获取到kook用户id和vip天数\n给用户添加上vip天数\n\ncustom_order_id=kook用户id:vip天数\n\n处理代码详见 api.py 和 apiHandler.py\n2.2 机器人机器人命令如下\n\n\n\n命令\n说明\n\n\n\n&#x2F;shop\n获取购买vip的卡片\n\n\n&#x2F;vip\n看看自己vip剩余时长\n\n\n&#x2F;vip-l\n获取vip用户列表（会刷掉过期的vip用户）\n\n\n&#x2F;vip-test\n该命令只有vip用户才能执行，用于测试vip是否生效\n\n\n&#x2F;alive\n看看机器人活着不\n\n\n&#x2F;kill\n机器人下线，并保存文件\n\n\n代码详见 main.py\n2.2.1 vip物品url获取先创建你的vip店铺。爱发电的商品有隐藏功能，隐藏后的商品将不会显示在主页上，这样也能实现用户只能通过bot提供的链接来访问购买的操作\n\n\n这里我拿周vip和月vip作为示例\n\n点击商品，进入详情页，点击发电\n\n进入付款页面后，复制最上方的url\n\nhttps://afdian.net/order/create?product_type=1&amp;plan_id=9aea871c304911ed8ec452540025c377&amp;sku=%5B%7B%22sku_id%22%3A%229aed6edc304911edbeb552540025c377%22,%22count%22%3A1%7D%5D\n\n我们要做的就是在这个url尾部添加上custom_order_id\n&amp;custom_order_id=kook用户id:vip天数\n\n添加完毕后的链接如下\nhttps://afdian.net/order/create?product_type=1&amp;plan_id=9aea871c304911ed8ec452540025c377&amp;sku=%5B%7B%22sku_id%22%3A%229aed6edc304911edbeb552540025c377%22,%22count%22%3A1%7D%5D&amp;custom_order_id=kook用户id:vip天数\n\n复制到浏览器，仍可正常访问，代表配置无误\n\n2.2.2 vip物品url配置找到main.py中的如下代码，将里面的vip_item_link替换成你自己的url。如果需要添加更多商品，将两个----------中间的部分多复制几份即可\n@bot.command(name=&#x27;shop&#x27;,case_sensitive=False)async def shop_cmd(msg:Message,*arg):    logMsg(msg)    try:        cm = CardMessage()        c =Card(Module.Section(Element.Text(&quot;欢迎选购机器人Vip&quot;,Types.Text.KMD)))        # -------------        # vip商品1,周vip        vip_item_link1 = &quot;https://afdian.net/order/create?product_type=1&amp;plan_id=9aea871c304911ed8ec452540025c377&amp;sku=%5B%7B%22sku_id%22%3A%229aed6edc304911edbeb552540025c377%22,%22count%22%3A1%7D%5D&quot;        # 添加上自定义订单号的字符串        vip_item_link1+= f&quot;&amp;custom_order_id=&#123;msg.author_id&#125;:7&quot;        c.append(            Module.Section(                Element.Text(&quot;周vip&quot;, Types.Text.KMD),                Element.Button(&quot;购买&quot;, vip_item_link1, Types.Click.LINK)))        # -------------                # vip商品2,月vip        vip_item_link2 = &quot;https://afdian.net/order/create?product_type=1&amp;plan_id=ff2949022e9611ed89d452540025c377&amp;sku=%5B%7B%22sku_id%22%3A%22ff2bb4f82e9611ed83ac52540025c377%22,%22count%22%3A1%7D%5D&quot;        # 添加上自定义订单号的字符串        vip_item_link2+= f&quot;&amp;custom_order_id=&#123;msg.author_id&#125;:30&quot;        c.append(            Module.Section(                Element.Text(&quot;月vip&quot;, Types.Text.KMD),                Element.Button(&quot;购买&quot;, vip_item_link2, Types.Click.LINK)))                cm.append(c)        await msg.reply(cm,is_temp=True) # 临时消息，所以这个按钮只有当前用户可以点    except:        _log.exception(f&quot;Err in shop&quot;)\n\n2.2.3 启动机器人并配置webhook先安装依赖项（Python版本3.10）\npip3.10 install -r requierments.txt\n\n\n配置文件示例config/config.exp.json\n在内部填写正确的机器人token字段后，重命名为config.json\n并将config/log.exp中的两个文件复制到log/路径下\n\n然后启动机器人\npython3.10 start.py\n\n看到如下输出即为启动成功\n\n我们需要将api的地址填写到爱发电的webhook url中\n\n开发者页面 https://afdian.net/dashboard/dev\n\n记得开放对应端口防火墙，并正确绑定域名和开启https\n\n填写url后点击保存，爱发电会发送一条测试webhook给你的机器人。如果在预先定义的debug_ch中看到了如下卡片，则代表webhook配置成功\n\n[23-04-19 19:46:07] INFO:api.py:aifadian_webhook:31 | request | /afd[23-04-19 19:46:07] INFO:apiHandler.py:afd_request:71 | trno:202106232138371083454010626 | afd-cm-send\n\nkill掉机器人后，在log文件中也能看到这次测试webhook的请求体\n\n2.3 命令截图2.3.1 基础测试先测试一下机器人上线没有\n\n刚开始时，没有vip用户\n\n\n使用商城命令，获取购买按钮\n\n点击按钮，会跳转到爱发电的付款页面，能看到url最后成功附着上了用户id和时间\n&amp;custom_order_id=1961572535%3A7\n\nurl中的%3A就是:\n\n2.3.2 购入vip测试如下，我购买了一个周vip，机器人成功获取到了webhook体中的自定义订单id\n\n此时再次执行vip命令，能看到已经正确添加上了7天的vip\n\n\n日志文件也成功记录\n\n\n测试完毕！\nThe end有任何问题，都可以加入我的帮助服务器与我联系\n\n本文档已被官方认可，并放置在了kook开发者频道的常见问题中🎉\n\n\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【KOOK】linkguard机器人配置个性化撤回提醒","url":"/posts/1370917284/","content":"linkguard机器人配置个性化撤回提醒\n\n\n在一位用户的建议下，推出了此功能，经过2h的coding，基本通过了测试\n1.准备打开kook的卡片编辑器，编辑好你准备的消息\nhttps://www.kookapp.cn/tools/message-builder.html#/card\n注意，卡片消息内不能包含按钮，否则会配置失败\n特殊字符特殊字符 &#123;met&#125;，用于标识撤回用户信息中所发送的 @用户名 的位置；\n比如下图中，我是这样配置的\n\n实际发送的效果就如下\n\n如何获取图片url？PC端将图片上传到kook → 点击图片 → 底部...处复制图片链接 → 使用/vip-shop命令设置背景\n\n\n将你准备的图片url替换官方的示例图片url就可以了\n\n2.命令在卡片消息编辑器中，编辑好你的消息后，就可以用命令来上传你的卡片消息了\n命令为 /setifo，操作如下，先展开输入栏\n\n先键入命令，再点击代码块按钮\n\n将你的卡片消息粘贴进去，点击确定\n\n随后发送消息\n\n如果一切顺利，机器人会先发送一个消息示例，再提示您配置成功\n\n有用户发送链接时，机器人撤回就会使用此模板进行操作！\n","categories":["速通Python"],"tags":["Python","Kook"]},{"title":"【Python】pycharm配置代码字体+中文字体","url":"/posts/232801310/","content":"如题，默认pycharm的字体是宋体和楷体的结合，我本人实在是不喜欢宋体，包括word中我也是用黑体创作，最终交作业的时候才会改成宋体（宋体看的真的很不舒服……）\n但是jb里面似乎没有提供中文字体这一设置选项，要改就只能修改整体\n但我又想让代码的英文用等宽字体，中文设置成黑体，要怎么办呢？\n这时候要用pyc的回滚字体配置\n在pyc的字体设置中，默认界面如下，我们只能设置一个字体\n\n但是打开版式设置，这里会有一个回滚字体，其能设置主字体无法显示的字符\n比如jb mono字体就么有对中文进行过适配，所以显示的中文是宋体。这里我们将回滚字体改成微软雅黑\n\n顿时舒服了！\n\n只不过pyc自己的界面用的还是宋体，这需要在设置-外观里面修改\n\n","categories":["速通Python"],"tags":["Python"]},{"title":"【KOOK】阿狸机器人 | 使用文档","url":"/posts/847195815/","content":"时光匆匆，自从2022年6月20日，阿狸的GIT仓库创建第一个commit开始，已经过去了一年零64天，这么长的时间里，我接受到了不少朋友的支持，也有不少朋友对代码编写的帮助，在此衷心地对大家表示感谢！\n但，由于拳头公司给auth鉴权接口新增了cloudflare防火墙和人机验证，导致类似阿狸这种集中式的机器人会被直接封禁云服务器IP而无法继续使用，所以，阿狸只能和大家说拜拜了！\n自 2023-08-24 起，KOOK阿狸机器人和QQ频道阿狸机器人均停止服务。\n感谢！\n\n欢迎来到 Kook-Valorant-Bot 机器人使用文档\n\n开源代码：Github | Gitee\n机器人状态页：api&#x2F;v2&#x2F;bot\n爱发电支持页：点我发电\n\n有任何问题，欢迎在本页下方评论（推荐）或加入阿狸帮助频道 \n\n0.免责声明1.查询接口老生常谈了，目前valorant查询的接口是使用拳头官方的登录接口获取到账户token后，用账户token请求对应的商店、任务、战绩等接口。\n该接口官方没有正式公布，目前的查询操作是在官方默许下进行的。根据外网开发者的经验（他们使用的更久）目前暂时还没有听说过有人因为该接口查询信息而被ban号。\n但，没有不代表封号风险不存在！\n所以，使用了登陆查询功能之后，即代表您愿意承担此类风险。\n2.账户安全机器人的代码完全开源，输出的日志中不会包含用户的账户&#x2F;密码&#x2F;邮箱验证码，所有信息均通过kook的私聊和kook的api传输到机器人进行处理。\n\n传输过程中的私密性将由https协议来保证；\n您的账户密码只有kook的后台能看到；\n\n如果您担心您的账户安全，请一定要开启邮箱双重验证；或不要使用机器人。\n3.自动重登机器人什么时候会进行重登？\n在查询的时候，机器人会先判断账户token是否有效，无效则cookie重登。具体场景如下:\n\n执行需要登录的查询命令\n早八的notify皮肤提醒功能会触发重登\n早八的vip商店提醒功能会触发重登\n\n1.帮助命令1.hello执行本命令，阿狸会回复你好。可用于测试阿狸是否在线\n/hello\n\n\n2.@阿狸在频道内@机器人，会触发一个语句\n@打瓦的阿狸\n\n呀，听说有人想我了，是吗？输入`/ahri` 或 `/vhelp` 打开帮助面板，和阿狸一起玩吧！\n\n如果是开发者@，则会返回只有开发者才能执行的命令帮助面板\n3.ahri阿狸基础帮助命令\n/ahri 或 /Ahri\n\n\n4.vhelpvalorant相关命令帮助\n/vhelp\n\n\n2.基础命令01.val 错误码以下两个命令完全相同，van是val的别名\n/val 错误码编号/van 错误码编号\n\n用这个命令可以查询游戏常见错误码的解决办法\n/val 1067\n\n\n同时支持查询van开头的错误码\n/val 9001\n\n\n02.DX 弹窗错误如果你发现有人在咨询DirectX Runtime相关的错误，可以执行此命令\n/dx\n\n\n03.saveid&#x2F;myid此命令用于保存（修改）用户的游戏id\n/saveid 游戏id\n\n\n保存后，在和别人开黑的时候，可以用myid命令快捷发出自己的游戏id\n/myid\n\n\n04.bundle查询一个皮肤系列包含什么皮肤（捆绑包）\n/bundle 皮肤名\n\n举个例子\n/bundle RGX # 查询显卡套\n\n\n05.login登录命令\n/login 账户 密码\n\n登录您的拳头账户，如果开启了邮箱验证，机器人将提示您使用/tfa命令进行验证\n\n/login 账户 密码 save\n\n后追save，即代表您愿意将账户密码存储到机器人后台的临时变量（内存）中。存在内存中的数据会在机器人进程退出后清空，他人无法获取。\n\n保存账户密码后，机器人将在尝试cookie重新登录失败后，使用账户密码进行重新登录\n不管是vip用户还是普通用户，该功能都生效\n不支持邮箱登录用户save密码。开了邮箱登录的用户，指定save后依旧不会缓存\n\n该功能主要服务于机器人长时间开机的时候（不过目前经常需要维护重启，存的数据会丢失）\n06.tfa用于进行邮箱验证\n/tfa 邮箱验证码\n\n如下，刚开始发送验证码，机器人会提示验证码xxx收到\n\n如果登录成功，机器人会反馈您的游戏id\n\n如果输入了一个错误的验证码，机器人会提示您重新输入\n\n07.login-l目前机器人支持至多3个拳头账户的同时登录，使用该命令可以查看当前已登录账户的游戏名和登录时间\n/login-l\n\n\n08.login-ap前面提到，login登录可以指定save保存账户密码。\n机器人后台会在使用账户密码重登的时候对时间进行记录，用如下命令即可查询\n/login-ap\n\n这样你就能知道机器人啥时候用过你的账户密码操作了\n09.logout如果你不希望机器人在后台操作你的账户\n那就可以用这个命令登出所有账户\n/logout\n\n10.shop查询每日商店\n/shop\n\n如果你登录了多个账户，则需指定编号（编号为/login-ap中显示的账户序号）默认查询的是编号为0的账户商店\n/shop 1\n\n\n\n11.night查询夜市\n/night\n\n多账户操作和shop相同\n/night 账户序号\n\n\n12.uinfo查询用户信息（等级、经验值、玩家卡片、玩家称号、vp、rp等）\n/uinfo\n\n该命令会自动查询所有已登陆账户，无须指定编号\n\n\n13.match查询最近5场的战绩\n/match\n\n多账户查询和shop相同\n\n绿色边框代表本场胜利，红色代表负\n\n14.mission查询你的每日&#x2F;每周任务\n/mission\n\n目前任务uuid尚未完全收录，很多任务都处于未知状态。\n需要大家在执行本命令后，帮助填写表单，尽早集齐所有任务信息。感谢！\n\n3.皮肤提醒1.notify-a查询皮肤，机器人会返回一个皮肤选择表，用sts命令选择指定的皮肤，加入皮肤提醒队列\n/notify-a 皮肤名\n\n\n比如我想在商店刷出显卡暴徒的时候，让机器人私聊提醒我，那就可以用如下命令\n/sts 0\n\n这里的0是上图中显卡暴徒的编号\n2.notify-l/notify-l\n\n查看已添加的皮肤提醒\n\n3.notify-d删除notify-l中不需要提醒的皮肤\n/notify-d 皮肤uuid\n\n示例\n/notify-d 6f2aefab-439d-140a-4dc6-87818e2d72cd\n\n\n4.皮肤评价所谓皮肤评价，就是查询商店的时候，显示在结果之下的信息。采用leancloud存储皮肤评价，数据库已在kook和qq频道的阿狸机器人中共用。\n目前尚有大量皮肤未评价，计算而出的商店评分参考价值低。还需各位多多帮助！\n\n1.rate该命令和notify-a类似，需要先通过皮肤名查找需要评论的皮肤\n/rate 皮肤名\n\n示例\n/rate 离子\n\n\n2.rts执行过rate命令后，用rts命令进行选择\n/rts 序号 打分 吐槽\n\n\n3.kkn执行本命令，查看昨日评分最高&#x2F;最低用户\n/kkn\n\n由于目前皮肤评价数据不足，所以参考性低\n\n5.VIP专属阿狸的VIP基础权益如下\n\n「全新商店展示图」vip用户将获取到16-9的超帅商店返回值\n「商店图片背景自定义」vip用户可自定义商店查询结果的图片背景\n「保存登录信息」vip用户登陆后，阿狸会自动保存您的cookie。在阿狸维护重启的时候，您的登录信息不会丢失（注：cookie内并不包含你的账户密码）\n「早八商店提醒」阿狸将在早8点获取vip用户的每日商店并私聊发图给用户。同时会对这张图片进行缓存，当天使用/shop命令的时候，只需2s获取结果，三倍于普通用户的响应速度！\n\n一些说明\n\n目前商店查询diy背景图支持16-9(横屏)的图片 \n请不要设置违规图片(擦边也不行)！若因为您上传违禁图片后导致阿狸被封，您将被剥夺vip权益并永久禁止兑换vip\n\n1.vip-u该命令用于兑换vip的激活码\n/vip-u 激活码\n\n当您在爱发电购买vip后，爱发电会给您私聊一个vip的激活码。私聊阿狸，使用该激活码即可激活vip。同一激活码只可使用一次。\n\n\n2.vip-c查看vip的剩余时间\n/vip-c\n\n\n3.vip-shop目前支持保存4张背景图\n3.1 查看已保存背景图查看已保存的商店自定义背景图\n/vip-shop\n\n\n3.2 切换背景图这里出现了图片的编号，如果需要切换图片，使用如下命令\n/vip-shop-s 图片编号\n\n就可以切换到对应的背景图\n\n3.3 删除背景图\n由于仅支持4个背景图，所以添加更多背景图之前，需要先删除已有的\n/vip-shop-d 图片编号\n\n示例如下\n\n\n3.4 添加背景图\n图片url获取看3.5\n\n请尽量使用kook上传图片后设置背景图，或使用国内能直连的图床图片url，否则背景图设置很可能出错。\n/vip-shop 图片url\n\n示例\n/vip-shop https://img.kookapp.cn/assets/2023-04/QUGTtwWxuv6bk2l4.jpg\n\n\n3.5 如何获取图片urlPC端将图片上传到kook → 点击图片 → 底部...处复制图片链接 → 使用/vip-shop命令设置背景\n\n\n6.娱乐命令01.roll 骰子该命令可以掷骰子（生成随机数）\n/roll 左边界 右边界 生成数量\n\n示例\n/roll 1 100 3\n\n\n如果不给第三个数量参数，则默认只生成一个随机数\n/roll 1 100\n\n\n02.countdown 倒计时在本频道触发一个倒计时\n/countdown 秒数\n\n示例\n/countdown 120\n\n生成一个120秒的倒计时\n\n03.tl 翻译该命令为translate的缩写，用于翻译。支持中英互译，以及部分外国语言翻译成中文\n/tl 内容\n\n机翻，图一乐\n\n/tlon/tloff\n\n这两个命令是在本频道开启&#x2F;关闭实时翻译\n\n开启后，用户发送的所有信息都会被翻译出来\n\n用/tloff关闭实时翻译\n\n04.we 天气该命令可以用于查询城市的天气情况\n/we 城市\n\n\nThe end阿狸的命令就这些啦，有任何问题都可以在下方留言！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】记录pymysql.err.InterfaceError: (0, ') 的“解决办法”","url":"/posts/520209670/","content":"直奔主题吧！\n情况python写的机器人遇到了一个mysql的错误 pymysql.err.InterfaceError: (0, &#39;&#39;)\n完整报错内容如下\nTraceback (most recent call last):  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/main.py&quot;, line 402, in user_active_on_msg    user_log = await Store.create_user_log(guild_id=gid, user_id=uid)  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/utils/Store.py&quot;, line 313, in create_user_log    user = await QueryMysql.insert_user_log(guild_id, user_id)  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/utils/data/QueryMysql.py&quot;, line 292, in insert_user_log    user = await query_user_log(guild_id, user_id)  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/utils/data/QueryMysql.py&quot;, line 283, in query_user_log    return await UserLog.query(guild_id, user_id)  File &quot;/home/mu/pybot/vshop-bot/poxiao-bot/utils/data/QueryMysql.py&quot;, line 21, in query    cursor.execute(MysqlSql.Select.UserLogGU, (guild_id, user_id))  File &quot;/home/mu/pybot/vshop-bot/vs-venv/lib/python3.10/site-packages/pymysql/cursors.py&quot;, line 153, in execute    result = self._query(query)  File &quot;/home/mu/pybot/vshop-bot/vs-venv/lib/python3.10/site-packages/pymysql/cursors.py&quot;, line 322, in _query    conn.query(q)  File &quot;/home/mu/pybot/vshop-bot/vs-venv/lib/python3.10/site-packages/pymysql/connections.py&quot;, line 557, in query    self._execute_command(COMMAND.COM_QUERY, sql)  File &quot;/home/mu/pybot/vshop-bot/vs-venv/lib/python3.10/site-packages/pymysql/connections.py&quot;, line 840, in _execute_command    raise err.InterfaceError(0, &quot;&quot;)pymysql.err.InterfaceError: (0, &#x27;&#x27;)\n\n百度百度了，说是不要在数据库链接关闭后使用数据库。\n比如下面的代码就是有问题的，close之后相当于你已经没有连上数据库了。这时候再commit肯定是不行的。就好比断网了再点击网页刷新按钮，是无济于事的！\ndb = &quot;数据库连接&quot;# 数据库操作db.close()db.commit()\n\n咋回事？然后呢，我还看到了一些博客提到了需要检查连接是否可用。还有其他的巴拉巴拉的。吓得我以为自己的代码是不是有什么问题，是不是这个报错只要跑久了就一定会出现？\n直到我想起来我操作过docker的iptables，重启过docker（我的mysql是docker搭建的）\n咳咳，数据库重启过，难怪连不上。怪我怪我。\n也提醒下大家，一定要先把需要用数据库的进程都给停了再去重启数据库！\n\n","categories":["速通Python"],"tags":["Python","MySQL"]},{"title":"【Python】deepin下pip安装包找不到Python.h的解决办法","url":"/posts/824840011/","content":"今天用deepin安装python包的时候，报了这个问题\n\n\n(venv) mothra@mothra-PC:~/code/baidu-upd/encrypt2bdy$ pip3 install ruamel.yamlCollecting ruamel.yaml  Using cached https://files.pythonhosted.org/packages/d9/0e/2a05efa11ea33513fbdf4a2e2576fe94fd8fa5ad226dbb9c660886390974/ruamel.yaml-0.17.32-py3-none-any.whlCollecting ruamel.yaml.clib&gt;=0.2.7; platform_python_implementation == &quot;CPython&quot; and python_version &lt; &quot;3.12&quot; (from ruamel.yaml)  Using cached https://files.pythonhosted.org/packages/d5/31/a3e6411947eb7a4f1c669f887e9e47d61a68f9d117f10c3c620296694a0b/ruamel.yaml.clib-0.2.7.tar.gzBuilding wheels for collected packages: ruamel.yaml.clib  Running setup.py bdist_wheel for ruamel.yaml.clib ... error  Complete output from command /home/mothra/code/baidu-upd/encrypt2bdy/venv/bin/python3 -u -c &quot;import setuptools, tokenize;__file__=&#x27;/tmp/pip-install-55f2q2xf/ruamel.yaml.clib/setup.py&#x27;;f=getattr(tokenize, &#x27;open&#x27;, open)(__file__);code=f.read().replace(&#x27;\\r\\n&#x27;, &#x27;\\n&#x27;);f.close();exec(compile(code, __file__, &#x27;exec&#x27;))&quot; bdist_wheel -d /tmp/pip-wheel-m1ay2dbt --python-tag cp37:  sys.argv [&#x27;-c&#x27;, &#x27;bdist_wheel&#x27;, &#x27;-d&#x27;, &#x27;/tmp/pip-wheel-m1ay2dbt&#x27;, &#x27;--python-tag&#x27;, &#x27;cp37&#x27;]  test compiling /tmp/tmp_ruamel_qu43oc5r/test_ruamel_yaml.c -&gt; test_ruamel_yaml OK  running bdist_wheel  running build  running build_py  Generating grammar tables from /usr/lib/python3.7/lib2to3/Grammar.txt  Generating grammar tables from /usr/lib/python3.7/lib2to3/PatternGrammar.txt  creating build  creating build/lib.linux-x86_64-3.7  creating build/lib.linux-x86_64-3.7/ruamel  copying .ruamel/__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel  creating build/lib.linux-x86_64-3.7/ruamel/yaml  copying .ruamel/yaml/__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml  creating build/lib.linux-x86_64-3.7/ruamel/yaml/clib  copying ./__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib  copying ./setup.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib  copying ./LICENSE -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib  running build_ext  building &#x27;_ruamel_yaml&#x27; extension  creating build/temp.linux-x86_64-3.7  x86_64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/home/mothra/code/baidu-upd/encrypt2bdy/venv/include -I/usr/include/python3.7m -c _ruamel_yaml.c -o build/temp.linux-x86_64-3.7/_ruamel_yaml.o  _ruamel_yaml.c:6:10: fatal error: Python.h: 没有那个文件或目录   #include &quot;Python.h&quot;            ^~~~~~~~~~  compilation terminated.  error: command &#x27;x86_64-linux-gnu-gcc&#x27; failed with exit status 1----------------------------------------  Failed building wheel for ruamel.yaml.clib  Running setup.py clean for ruamel.yaml.clibFailed to build ruamel.yaml.clibInstalling collected packages: ruamel.yaml.clib, ruamel.yaml  Running setup.py install for ruamel.yaml.clib ... error    Complete output from command /home/mothra/code/baidu-upd/encrypt2bdy/venv/bin/python3 -u -c &quot;import setuptools, tokenize;__file__=&#x27;/tmp/pip-install-55f2q2xf/ruamel.yaml.clib/setup.py&#x27;;f=getattr(tokenize, &#x27;open&#x27;, open)(__file__);code=f.read().replace(&#x27;\\r\\n&#x27;, &#x27;\\n&#x27;);f.close();exec(compile(code, __file__, &#x27;exec&#x27;))&quot; install --record /tmp/pip-record-lh0gyakn/install-record.txt --single-version-externally-managed --compile --install-headers /home/mothra/code/baidu-upd/encrypt2bdy/venv/include/site/python3.7/ruamel.yaml.clib:    sys.argv [&#x27;-c&#x27;, &#x27;install&#x27;, &#x27;--record&#x27;, &#x27;/tmp/pip-record-lh0gyakn/install-record.txt&#x27;, &#x27;--single-version-externally-managed&#x27;, &#x27;--compile&#x27;, &#x27;--install-headers&#x27;, &#x27;/home/mothra/code/baidu-upd/encrypt2bdy/venv/include/site/python3.7/ruamel.yaml.clib&#x27;]    test compiling /tmp/tmp_ruamel_myagpa5e/test_ruamel_yaml.c -&gt; test_ruamel_yaml OK    running install    running build    running build_py    Generating grammar tables from /usr/lib/python3.7/lib2to3/Grammar.txt    Generating grammar tables from /usr/lib/python3.7/lib2to3/PatternGrammar.txt    creating build    creating build/lib.linux-x86_64-3.7    creating build/lib.linux-x86_64-3.7/ruamel    copying .ruamel/__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel    creating build/lib.linux-x86_64-3.7/ruamel/yaml    copying .ruamel/yaml/__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml    creating build/lib.linux-x86_64-3.7/ruamel/yaml/clib    copying ./__init__.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib    copying ./setup.py -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib    copying ./LICENSE -&gt; build/lib.linux-x86_64-3.7/ruamel/yaml/clib    running build_ext    building &#x27;_ruamel_yaml&#x27; extension    creating build/temp.linux-x86_64-3.7    x86_64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/home/mothra/code/baidu-upd/encrypt2bdy/venv/include -I/usr/include/python3.7m -c _ruamel_yaml.c -o build/temp.linux-x86_64-3.7/_ruamel_yaml.o    _ruamel_yaml.c:6:10: fatal error: Python.h: 没有那个文件或目录     #include &quot;Python.h&quot;              ^~~~~~~~~~    compilation terminated.    error: command &#x27;x86_64-linux-gnu-gcc&#x27; failed with exit status 1    ----------------------------------------Command &quot;/home/mothra/code/baidu-upd/encrypt2bdy/venv/bin/python3 -u -c &quot;import setuptools, tokenize;__file__=&#x27;/tmp/pip-install-55f2q2xf/ruamel.yaml.clib/setup.py&#x27;;f=getattr(tokenize, &#x27;open&#x27;, open)(__file__);code=f.read().replace(&#x27;\\r\\n&#x27;, &#x27;\\n&#x27;);f.close();exec(compile(code, __file__, &#x27;exec&#x27;))&quot; install --record /tmp/pip-record-lh0gyakn/install-record.txt --single-version-externally-managed --compile --install-headers /home/mothra/code/baidu-upd/encrypt2bdy/venv/include/site/python3.7/ruamel.yaml.clib&quot; failed with error code 1 in /tmp/pip-install-55f2q2xf/ruamel.yaml.clib/\n\n百度到的解决办法是安装python-dev\nhttps://blog.csdn.net/CloudsRush/article/details/110580061\nsudo apt-get install python-dev\n\n先安装了这个，没有用，于是又安装了对应python版本的dev包\nsudo apt-get install python3.7-dev\n\n搞定！这下pip安装的时候没有报错了！\n(venv) mothra@mothra-PC:~/code/baidu-upd/encrypt2bdy$ pip3 install ruamel.yamlCollecting ruamel.yaml  Using cached https://files.pythonhosted.org/packages/d9/0e/2a05efa11ea33513fbdf4a2e2576fe94fd8fa5ad226dbb9c660886390974/ruamel.yaml-0.17.32-py3-none-any.whlCollecting ruamel.yaml.clib&gt;=0.2.7; platform_python_implementation == &quot;CPython&quot; and python_version &lt; &quot;3.12&quot; (from ruamel.yaml)  Using cached https://files.pythonhosted.org/packages/d5/31/a3e6411947eb7a4f1c669f887e9e47d61a68f9d117f10c3c620296694a0b/ruamel.yaml.clib-0.2.7.tar.gzBuilding wheels for collected packages: ruamel.yaml.clib  Running setup.py bdist_wheel for ruamel.yaml.clib ... done  Stored in directory: /home/mothra/.cache/pip/wheels/2d/db/d8/e6ded7debed48ad2f416fc153122b7698eb136be4c254beffdSuccessfully built ruamel.yaml.clibInstalling collected packages: ruamel.yaml.clib, ruamel.yamlSuccessfully installed ruamel.yaml-0.17.32 ruamel.yaml.clib-0.2.7\n","categories":["速通Python"],"tags":["Linux","Python"]},{"title":"【API】API的各种分类详解","url":"/posts/73383828/","content":"API，即应用程序编程接口，是为了方便应用程序之间的数据和功能交互而设计的一些标准方法。API 的分类可以从多个维度进行，我会对 API 的分类维度进行简单的介绍。\n\n\n根据使用方式的不同通常情况下，API 可以分为两种使用方式：内部 API 和外部 API。\n内部 API 是指供企业内部开发人员和应用所使用的 API。当企业需要一些定制化的应用程序或者集成特定的功能时，内部 API 可以提供更好的技术支持，同时也能保证数据的安全性和可靠性。\n外部 API 则是供公众开发者使用的 API，通过提供数据和服务，使得外部的开发者可以构建丰富的应用程序并与当前的生态系统进行协作。越来越多的各类公司都开始向公众提供自己的 API，示例包括 Facebook、Twitter、Google 等。\n根据访问方式的不同根据 API 的访问方式，API 可以分为以下几种：\n\nRESTful API REST（Representational State Transfer）是一种基于 HTTP 协议的 Web 应用程序架构标准。RESTful API 遵循 RESTful 架构的原则，通常由资源路径和请求方法组成，以达到可读性高、灵活性好的目的。\nSOAP API SOAP（Simple Object Access Protocol）是一种基于 XML 编码的远程调用协议，比较复杂而且处理时间和网络资源使用率高。虽然 SOAP 技术已经逐渐淡出市场，但在某些特殊场景下仍然会有所应用。\nGraphQL API GraphQL 是由 Facebook 公司开源的一种数据查询语言和 API 执行引擎，可以呈现出 XML schema 来表达整个数据的结构，并为前端工程师提供自由定义获取所需属性、代码重用等人性化的特色。\ngRPC API gRPC 可以理解为 Google Remote Procedure Call，是 Google 最新开源的跨语言 RPC 框架。借助基于 HTTP&#x2F;2 的二进制传输协议，gRPC 提供了比 JSON 和 RESTful 更快速和更可靠的通讯方式。\n\n根据功能的不同根据 API 的功能性质，API 可以分为以下几类：\n\nWeb API Web API 一般都针对 Web 应用程序，提供一些标准的接口，例如：W3C DOM 接口、HTTP 接口、WebSocket 接口、Web Worker 接口等。这些 API 帮助浏览器取得用户元素信息、发送 AJAX 请求等等。\n操作系统 API 操作系统 API（如 Windows API 或 POSIX API）提供了与操作系统软件交互的方法，允许应用程序查询及控制硬件设备或操作系统内核任务等。此类 API 几乎适用于任何类型的环境。\n数据库 API 数据库 API 可以使应用程序通过某些 API 实现对一些数据存储的操作，例如：SQL、NoSQL 等数据库里都有相关的 API 调用。\n\n在实际使用中，API 支持访问不同的功能模块，例如数据转换、数据分析、网络安全、门户管理、日历等等，还可以根据不同的需求进行客制化的开发。\n总之，在开发过程中，根据实际需求选择合适的 API 类型是非常重要的，能够快速、高效地构建需要的应用程序。\n版权声明：本文为CSDN博主「luffy_fe」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_42107247/article/details/130508490\n\n","tags":["API"]},{"title":"【Python】调用飞书API获取excel表格中数据","url":"/posts/3588260369/","content":"调用飞书API获取excel表格中数据\n\n\n1.说明关于云文档的api，今天处理机器人的时候，有位用户提出了这个需求。但我翻了翻腾讯云文档和金山云文档，都没有看到正经的获取execl文档中数据的接口（其实是我愚笨实在是没看懂他文档里面在说什么），大多都是将云文档嵌入到网站中的接口。\n于是又看了看，找到了一个seatable是支持完整的api，甚至支持用sql来查询excel中的数据。但其免费版本的API日用量只有区区5000/天，实在是不够机器人用的。\n又找到了飞书，这次总算是找到了我能看懂的用api来操作excel的文档了。\n\n顺带一提，我的域名邮箱就是用的飞书的免费服务，还是很香的。\n\nhttps://open.feishu.cn/document/server-docs/docs/sheets-v3/overview\n然后又找到了一个CSDN上的教程：https://blog.csdn.net/weixin_49160714/article/details/128004781\n此教程讲述的还是不够清除，感觉还是需要自己记录一下。万一以后用得上，也不用在到处找其他教程了。\n2.创建api应用要想能操作api，首先需要在你创建的企业中创建一个企业自建应用，名字随便填写\n\n为了操作excel表格，我们需要给予应用云文档的权限。\n\n在权限管理，往下滑找到云文档，全选所有权限，点击右侧批量开通\n\n注意，云文档的权限一共有21个，默认一页只是展示了10个，全选也只会添加10个权限，所以需要依次重复上述操作，把这里的21个权限都给选中给应用添加上。避免出现权限问题\n\n随后来到应用凭证，获取你的appid和appsecret，这两个调用鉴权api来获取token的时候需要\n\n随后来到版本管理，随便创建一个版本，点击申请发布，否则不能调用api\n\n因为我本来就是企业的管理员，所以就能在消息里面直接看到申请，点击审核，允许就行了\n\n3.调用api的基本示例3.1 鉴权首先要获取到自己的token，如下代码，修改为你的appid和secret，就能获取到token\nimport requestsurl = &quot;https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal/&quot;# 应用凭证里的 app id 和 app secretpost_data = &#123;    &quot;app_id&quot;: &quot;&quot;,    &quot;app_secret&quot;: &quot;&quot;&#125;r = requests.post(url, data=post_data)tat = r.json()[&quot;tenant_access_token&quot;]print(tat)\n\n完整的json返回值示例如下\n&#123;&quot;code&quot;:0,&quot;expire&quot;:6087,&quot;msg&quot;:&quot;ok&quot;,&quot;tenant_access_token&quot;:&quot;token内容&quot;&#125;\n\n获取到token后，需要构造一个请求headers来请求其他api\nheader = &#123;    &quot;Content-Type&quot;: &quot;application/json&quot;,    &quot;Authorization&quot;: &quot;Bearer &quot; + str(tat)&#125;  # 请求头\n\n3.2 写入要想往excel表里面写入数据，首先得修i改一下权限\n\n代码如下，来解释一下如何获取云文档的id，和sh的id（这两个不同）\n比如下图中，我打开的云文档url里面就包含了云文档的id，和当前sheet1的id\n\n代码注释中有更多说明\n# 飞书文档的储存地址结构：https://企业地址/sheets/shtcnjGdHzBm7Qa85UXQYk9OPxh?sheet=402cb1# 一般来说sh开头为文档地址，sheet=后跟工作簿地址，这两块是代码需要引用的参数# 总结来说就是 https://企业地址/sheets/云文档的完整ID?sheet=工作簿的IDimport jsonsheets_base_url = &quot;https://open.feishu.cn/open-apis/sheets/v2/spreadsheets&quot;excel_id = &quot;云文档的id&quot;def insert_info():    url = f&quot;&#123;sheets_base_url&#125;/&#123;excel_id&#125;/values&quot;  #写入的sh开头的文档地址，其他不变    post_data = &#123;        &quot;valueRange&quot;: &#123;            &quot;range&quot;: &quot;486268!C3:N8&quot;,            &quot;values&quot;: [[&quot;Hello&quot;, 1], [&quot;World&quot;, 1]]        &#125;    &#125;    # 在486268这个工作簿内的单元格C3到N8写入内容为helloworld等内容    r2 = requests.put(url, data=json.dumps(post_data), headers=header)  #请求写入    print(r2.json())  #输出来判断写入是否成功\n\n调用之后，控制台输出success，表中成功新增数据\n\n3.3 查询由于我的需求是查询某一列的数据，这对记账之类的表格很有用。比如下图中C列里面的数据就是数字的加减\n\n这时候我们就可以用如下的方式调用，获取到这个sheet中，C一整列的数据\nurl = f&quot;&#123;sheets_base_url&#125;/&#123;excel_id&#125;/values/486268!C1:C&quot;ret = requests.get(url, headers=header)print(ret.text)print(ret.json())\n\n返回结果示例如下，正好是表格中的数据！\n&#123;        &quot;code&quot;: 0,        &quot;data&quot;: &#123;            &quot;revision&quot;: 8,            &quot;spreadsheetToken&quot;: &quot;云文档ID&quot;,            &quot;valueRange&quot;: &#123;                &quot;majorDimension&quot;: &quot;ROWS&quot;,                &quot;range&quot;: &quot;486268!C1:C4&quot;,                &quot;revision&quot;: 8,                &quot;values&quot;: [[399], [-39], [-63], [65], [52], [0], [-63]]            &#125;        &#125;,        &quot;msg&quot;: &quot;success&quot;&#125;\n\n我需要的基本操作就是这些了。只要你学会了这两个操作，后续应该就能看懂飞书的api文档，来查询其他信息了。\n","categories":["速通Python"],"tags":["Python"]},{"title":"【Python】元组/列表/集合的区别","url":"/posts/1142930252/","content":"1.说明元组（tuple）、列表（list）和集合（set）是Python中常见的数据结构，它们有一些重要的区别。\n\n\n\n可变性：列表是可变的（mutable），可以对其进行添加、删除和修改操作。元组是不可变的（immutable），一旦创建就无法修改。集合也是可变的，但是它具有去重功能，不允许存在重复的元素，并且没有固定的顺序。\n\n语法：列表使用方括号[]来表示，元素之间用逗号,分隔；元组使用圆括号()``来表示，元素之间同样用逗号,分隔；集合使用大括号{}来表示，元素之间也用逗号,&#96;分隔。\n例如：\nmy_list = [1, 2, 3]my_tuple = (4, 5, 6)my_set = &#123;7, 8, 9&#125;\n\n索引和切片：列表和元组都支持通过索引访问元素和切片操作。而集合是无序的，不支持索引和切片操作。\n\n重复元素：列表和元组允许存在重复的元素，而集合会自动去除重复的元素。\n例如：\nmy_list = [1, 1, 2, 2, 3, 3]  # 列表中可以有重复元素my_tuple = (4, 4, 5, 5)      # 元组中也可以有重复元素my_set = &#123;6, 6, 7, 7&#125;        # 集合会自动去除重复的元素# 如上my_set = &#123;6,7&#125;\n\n可哈希性：集合的元素必须是可哈希（hashable）的，而列表和元组的元素可以是可哈希或不可哈希的。可哈希的意思是该对象的值在其生命周期中不发生改变，且能够唯一地确定一个对象。\n\n\n总的来说\n\n元组适用于存储固定的、不可变的数据；\n列表适用于需要频繁对其中的元素进行增删改操作的情况；\n集合适用于需要确保元素唯一性且不关心元素的顺序的场景。\n\n选择使用哪种数据结构取决于具体的需求和问题的特点。\n2.可哈希性2.1 概念可哈希性（hashability）是指一个对象是否具有哈希值（hash value），并且能够保持不变。在Python中，可哈希的对象是指那些在其生命周期中不可变的对象。\n哈希值是一个固定长度的整数，用于唯一标识一个对象。哈希值是通过将对象的内容转换为一个数字来计算得到的。可哈希的对象具有以下特点：\n\n哈希值不会改变：一个对象的哈希值在其生命周期中是不变的，即使对象的内容发生了改变。\n相等的对象具有相同的哈希值：如果两个对象是相等的，则它们的哈希值也相等。\n\n可哈希性在Python中非常重要，主要体现在两个方面：\n\n字典的键（key）必须是可哈希的对象：因为字典是基于哈希表实现的，它使用键的哈希值来索引和快速查找对应的值。所以字典中的键必须是不可变的对象，例如整数、浮点数、字符串、元组等都是可哈希的。\n集合的元素必须是可哈希的对象：集合也是基于哈希表实现的，它使用哈希值来确定元素是否存在于集合中，并且保证集合中的元素唯一性。所以集合中的元素也必须是不可变的对象。\n\n总结起来，可哈希性是指对象在其生命周期中不发生改变，并且能够通过哈希函数计算得到一个固定的、唯一的哈希值。可哈希的对象可以作为字典的键和集合的元素使用。\n2.2 自定义类型的可哈希性自定义类型（Custom types）可以维护可哈希性，但需要满足一定的条件。\n在Python中，对象的可哈希性是由其所属类的__hash__()方法和__eq__()方法共同决定的。下面是关于自定义类型维护可哈希性的条件：\n\n__hash__()方法的实现：自定义类型必须定义__hash__()方法，该方法返回一个整数作为对象的哈希值。通常情况下，可使用内置函数hash()来计算哈希值，具体实现如下：\ndef __hash__(self):    return hash((self.attribute1, self.attribute2, ...))\n\n注意，__hash__()方法应该返回一个不可变的值，并且相等的对象应该具有相等的哈希值。\n\n__eq__()方法的实现：为了确保相等的对象具有相等的哈希值，自定义类型也必须定义__eq__()方法来比较两个对象是否相等。__eq__()方法通常与__hash__()方法配合使用，具体实现如下：\ndef __eq__(self, other):    if isinstance(other, self.__class__):        return (self.attribute1 == other.attribute1) and (self.attribute2 == other.attribute2) and ...    return False\n\n注意，__eq__()方法应该返回布尔值表示两个对象是否相等。\n\n\n通过正确实现__hash__()和__eq__()方法，自定义类型就可以维护可哈希性。这样，对象就可以作为字典的键或集合的元素，并能够保持不变性和相等性的判断。\n然而，请注意，如果自定义类型中的属性是可变的（例如列表、集合等），则对象可能会发生改变，导致哈希值的改变。因此，在定义可哈希的自定义类型时，应该避免使用可变的属性。\n2.2.1 hash(自定义类型)当我们使用 hash函数来处理自定义类型时，python就会调用这个自定义类型的 __hash__()函数\nhash(p1)# 等价于p1.__hash__()\n\n默认情况下，__hash__ 方法返回对象的标识符，而 __eq__ 方法在两个对象相同时返回 True。如果想要覆盖这个默认行为，我们可以实现 __hash__ 方法和 __eq__ 方法。\n2.2.2 只实现eq如果一个自定义类型只实现了 __eq__而没有实现 __hash__，那么这个类型就不具备可哈希性，也就不能作为dict或者集和的键值\n比如如下person对象只实现了 __eq__\nclass Person:    def __init__(self, name, age):        self.name = name        self.age = age    def __eq__(self, other):        return isinstance(other, Person) and self.age == other.age\n\n如果尝试将这个对象放入set，就会报错\nmembers = &#123;    Person(&#x27;John&#x27;, 22),    Person(&#x27;Jane&#x27;, 22)&#125;\n\nTypeError: unhashable type: &#x27;Person&#x27;\n\n同时person对象失去了hash功能\nhash(Person(&#x27;John&#x27;, 22))# TypeError: unhashable type: &#x27;Person&#x27;\n\n为了使得 Person 类可哈希，我们还需要实现 __hash__ 方法\nclass Person:    def __init__(self, name, age):        self.name = name        self.age = age    def __eq__(self, other):        return isinstance(other, Person) and self.age == other.age    def __hash__(self):        return hash(self.age)\n\n现在，Person 类既支持基于 age 的等值比较，又具有哈希功能。\n为了使得 Person 能够正常用于字典这种数据结构，类的哈希值必须具有不可变性。为此，我们可以将 age 定义为只读属性\nclass Person:    def __init__(self, name, age):        self.name = name        self._age = age    @property    def age(self):        return self._age    def __eq__(self, other):        return isinstance(other, Person) and self.age == other.age    def __hash__(self):        return hash(self.age)\n\n2.2.3 总结\n默认情况下，__hash__ 方法返回对象的 ID，__eq__ 方法使用 is 操作符进行比较。\n如果实现了 __eq__ 方法，Python 会将 __hash__ 方法设置为 None，除非实现了自定义的 __hash__ 方法。\n\n","categories":["速通Python"],"tags":["Python"]},{"title":"【Python】request库InsecureRequestWarning的原因","url":"/posts/903214799/","content":"今天在测试我自己写的api的时候，发现了之前出现的一个warning的真正原因\n1.起因先来看请求api的代码\ndef ApiRq(account:str,passwd:str,background=&#x27;&#x27;):    url = &quot;https://val.musnow.top/shop-url&quot;    params = &#123;         # 参数涉及到隐私，省略    &#125;  \tres = requests.get(url,params=params,verify=False) # 请求api    return res.json()\n\n运行，会出现这个警告\n/home/muxue/.local/lib/python3.10/site-packages/urllib3/connectionpool.py:1045: InsecureRequestWarning: Unverified HTTPS request is being made to host &#x27;val.musnow.top&#x27;. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#ssl-warnings\n\n百度了一下，可以用下面的办法来去掉这个警告\nimport urllib3 # 屏蔽ssl warningurllib3.disable_warnings(urllib3.connectionpool.InsecureRequestWarning)\n\n但是这样是不安全的，因为我们没有检查网站的证书，也就无法向服务器发送确认后的加密信息\n2.出现这个警告的原因出现这个警告，其实就是因为我们这里设置了不检查ssl证书\nres = requests.get(url,params=params,verify=False) # 请求api\n\n如果你网站的证书是没有问题的，那么完全没有必要不检查，应该使用下面的代码\nres = requests.get(url,params=params)\n\n之前我的api站点所用证书缺少证书链，所以出现了另外一个报错，从而使用了verify=False才能正常运行代码，现在更新了证书，也就不需要了！\n此时直接运行代码，也不会报错了！\n[muxue@bt-7274:~/kook/test]$ py3 api_test.pystart test\n\n3.进一步了解\n参考 https://blog.csdn.net/memory_qianxiao/article/details/82011282\n\nrequests 库其实是基于 urllib 编写的，对 urllib 进行了封装，使得使用时候的体验好了很多。\n现在 urllib 已经出到了3版本，功能和性能自然是提升了不少。所以，requests最新版本也是基于最新的 urllib3 进行封装。\n在urllib2时代对https的处理非常简单，只需要在请求的时候加上 verify=False 即可，这个参数的意思是忽略https安全证书的验证，也就是不验证证书的可靠性，直接请求。但这其实是不安全的，因为证书可以伪造，不验证的话就不能保证数据的真实性。\n在urllib3时代，官方强制验证https的安全证书，如果没有通过是不能通过请求的，虽然添加忽略验证的参数，但是依然会 给出醒目的 Warning\n\n简单说来，就是如果是旧的request库，你可以用 verify=False 禁用掉证书验证，也不会出现报错；但是到 urllib3 后，官方要求一定要验证https证书，所以禁用掉证书验证，就会报出警告。\n除非你确认你调用的api是正规的，那么禁用掉证书验证是不应该的！\n4.检查一下你的站点ssl证书是否ok这里给大家推荐一个网站：myssl\n在这里输入你的域名，可以检测一下你的ssl证书是否正确部署，我的证书链问题就是在这里检测出来的\n\n只要是A那就是ok的！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook","api"]},{"title":"【Python】生成本项目的requeirments.txt","url":"/posts/1488017193/","content":"有的时候，我们需要对自己写的项目生成一个requeirments.txt，方便其他使用者快速安装依赖项\n\n\n\n参考https://www.cnblogs.com/shun7man/p/14080921.html\n\n1.使用pip如果你的项目本身就是在venv虚拟环境下跑的，那么可以直接用下面的语句生成一个依赖项文件\npip freeze &gt; requirements.txt\n\n\n但如果你和我一样，没有使用虚拟环境，而是用全局的包的话，那就会出现上图的情况，生成的txt文件里面出现了太多本项目没有用到的包，那你让别人安装那么多没有用的包，岂不是坑人嘛！\n所以可以用另外一个项目来解决这个问题\n2.pipreqs安装项目地址 https://github.com/bndr/pipreqs\n使用之前需要先安装一个包\npip install pipreqs\n\n[muxue@bt-7274:~/kook/val-bot]$ pip3.10 install pipreqsDefaulting to user installation because normal site-packages is not writeableCollecting pipreqs  Downloading pipreqs-0.4.11-py2.py3-none-any.whl (32 kB)Collecting yarg  Downloading yarg-0.1.9-py2.py3-none-any.whl (19 kB)Collecting docopt  Downloading docopt-0.6.2.tar.gz (25 kB)  Preparing metadata (setup.py) ... doneRequirement already satisfied: requests in /home/muxue/.local/lib/python3.10/site-packages (from yarg-&gt;pipreqs) (2.28.1)Requirement already satisfied: urllib3&lt;1.27,&gt;=1.21.1 in /home/muxue/.local/lib/python3.10/site-packages (from requests-&gt;yarg-&gt;pipreqs) (1.26.11)Requirement already satisfied: idna&lt;4,&gt;=2.5 in /home/muxue/.local/lib/python3.10/site-packages (from requests-&gt;yarg-&gt;pipreqs) (3.3)Requirement already satisfied: certifi&gt;=2017.4.17 in /home/muxue/.local/lib/python3.10/site-packages (from requests-&gt;yarg-&gt;pipreqs) (2022.6.15)Requirement already satisfied: charset-normalizer&lt;3,&gt;=2 in /home/muxue/.local/lib/python3.10/site-packages (from requests-&gt;yarg-&gt;pipreqs) (2.1.1)Installing collected packages: docopt, yarg, pipreqs  DEPRECATION: docopt is being installed using the legacy &#x27;setup.py install&#x27; method, because it does not have a &#x27;pyproject.toml&#x27; and the &#x27;wheel&#x27; package is not installed. pip 23.1 will enforce this behaviour change. A possible replacement is to enable the &#x27;--use-pep517&#x27; option. Discussion can be found at https://github.com/pypa/pip/issues/8559  Running setup.py install for docopt ... doneSuccessfully installed docopt-0.6.2 pipreqs-0.4.11 yarg-0.1.9\n\n使用安装完成后，使用下面的语句来生成文件\npipreqs . --encoding=utf8 --force\n\n这个语句的意思是生成当前目录的项目所用到的包的requirements文件\n\n可以看到，用这个项目生成的文件，包少多了，且确实是本项目需要用到的！\n3.创建venv虚拟环境进行测试为了方便进行测试，这里我以创建一个新的python虚拟环境为例\n3.1 创建虚拟环境先来吧项目的代码复制到一个新的文件夹，创建一个虚拟环境\npython -m venv botest\n\n这会在当前目录下创建一个botest文件夹\n此时我们使用pip list查看当前环境下安装了什么包\n[muxue@bt-7274:~/kook/test]$ pip3.10 listPackage                Version---------------------- -----------aiofiles               0.8.0aiohttp                3.8.1aiosignal              1.2.0aliyun-python-sdk-core 2.13.36aliyun-python-sdk-kms  2.16.0APScheduler            3.9.1async-timeout          4.0.2attrs                  22.1.0certifi                2022.6.15cffi                   1.15.1charset-normalizer     2.1.1click                  8.1.3colorama               0.4.6crcmod                 1.7cryptography           38.0.2docopt                 0.6.2Flask                  2.2.2frozenlist             1.3.1h11                    0.14.0idna                   3.3itsdangerous           2.1.2Jinja2                 3.1.2jmespath               0.10.0khl.py                 0.3.7MarkupSafe             2.1.1multidict              6.0.2numpy                  1.24.1oss2                   2.16.0pandas                 1.5.2Pillow                 9.2.0pip                    22.3.1pipreqs                0.4.11pycparser              2.21pycryptodome           3.15.0pycryptodomex          3.15.0python-dateutil        2.8.2pytz                   2022.2.1pytz-deprecation-shim  0.1.0.post0requests               2.28.1riot-auth              1.0.3setuptools             63.2.0six                    1.16.0tzdata                 2022.2tzlocal                4.2urllib3                1.26.11uvicorn                0.18.3valorant               1.0.4Werkzeug               2.2.2yarg                   0.1.9yarl                   1.8.1zhconv                 1.4.3\n\n你会发现还是有很多包啊？这是因为我们只创建了虚拟环境，还没有启动它！\n3.2 启动&#x2F;关闭虚拟环境用下面的命令启动\n[muxue@bt-7274:~/kook/test]$ source botest/bin/activate(botest) [muxue@bt-7274:~/kook/test]$ \n\n如果是windows，要用如下命令\n./botest/Scripts/activate\n\n你会发现命令行前面多了一个(botest),这就代表我们的虚拟环境启动成功了\n(botest) [muxue@bt-7274:~/kook/test]$ pip3.10 listPackage    Version---------- -------pip        22.2.1setuptools 63.2.0\n\n再次执行，发现只剩下两个默认的包了，这才是对的！\n要想退出虚拟环境，用下面的语句即可\ndeactivate\n\n3.3 测试代码拷贝过来了，假设我们现在就是一个刚刚克隆了此仓库，要使用项目的程序猿\n此时我们需要利用requirements.txt快速安装需要的包\npip install -r requirements.txt\n\n他会开始一个个安装所需要的包，以及这些包所需要的依赖项；和我们手动安装包是一个效果\n\n随后就出现了一个意料之中的报错\n\n这是因为riot_auth这个包，并没有在pypi里面注册，其安装的方式是用git安装的\npip3.10 install git+https://github.com/floxay/python-riot-auth.git\n\n使用pip freeze创建出来的txt文件里面的依赖项，才是正确的包\nriot-auth @ git+https://github.com/floxay/python-riot-auth.git@e70f76002728b99005baccd6fe3157c03d4d9f02\n\n这也是我目前发现的该项目的一个bug，已经提交了issue了！\n\nhttps://github.com/bndr/pipreqs/issues/350\n\n既然知道问题的情况，那就手动弄一下吧！不过需要提醒的是，这种git方式的pip包经常安装不上，会报下面的错误\n\n个人猜测和github的网络环境也有关系，所以得多试几次，或者手动克隆，粘贴到本地.site-packages源码里面\n如果一切顺利的话，那应该是能安装完成的！此时就可以愉快的运行项目代码了\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】request.session的cookie如何导入aiohttp._cookie_jar","url":"/posts/3768471210/","content":"request.session的cookie导入aiohttp._cookie_jar的教程\n\n\n1.起因我的 kook-valorant-bot 使用了两个开源库，用于riot账户的登录并获取token\n\n其中最主要用的是基于aiohttp的floxay&#x2F;python-riot-auth，但这个仓库不支持2fa用户（开启了邮箱双重验证的用户）作者去年就说会写上，但是他比较忙没有排期；\n于是我又去找了一个另外一个基于request的Prodzify&#x2F;Riot-auth 支持2fa登录的，半月前已经给bot加上了这个缺失半年的功能。\n\n可是 Prodzify&#x2F;Riot-auth 没有写cookie登录方法，其每次登录都需要账户密码，2fa用户每次都需要提供邮箱验证码；对于一个bot来说，每次操作这么麻烦，很是难受！\n随后，我去询问了写discord valorant bot的作者，得知如果2fa用户使用cookie登录，其是不需要提供邮箱验证码的！\n那么问题就变成了，如何将 request的cookie导入到aiohttp的_cookie_jar中，然后调用floxay&#x2F;python-riot-auth已经写好的cookie登录方法呢？\n\n1.1 前置声明这里说明一下，我写bot全都是看khl.py的example自学的，到目前为止，我没有系统性的学习过python语法，关于py类和对象的知识全都得靠C++的存货来旁敲侧击；所以如果我的python博客中出现错误，那是很正常的，还请指正！\n\n2.查找办法不多比比在互联网上大海捞针的困难了，我还是东平西凑才找到了一个办法\n\nPython CookieJar.update_cookies方法代碼示例\n\n该教程提到了下面的办法来导入cookie\n# 需要導入模塊: from aiohttp import CookieJar [as 別名]# 或者: from aiohttp.CookieJar import update_cookies [as 別名]def test_domain_filter_ip_cookie_send(loop) -&gt; None:    jar = CookieJar(loop=loop)    cookies = SimpleCookie(        &quot;shared-cookie=first; &quot;        &quot;domain-cookie=second; Domain=example.com; &quot;        &quot;subdomain1-cookie=third; Domain=test1.example.com; &quot;        &quot;subdomain2-cookie=fourth; Domain=test2.example.com; &quot;        &quot;dotted-domain-cookie=fifth; Domain=.example.com; &quot;        &quot;different-domain-cookie=sixth; Domain=different.org; &quot;        &quot;secure-cookie=seventh; Domain=secure.com; Secure; &quot;        &quot;no-path-cookie=eighth; Domain=pathtest.com; &quot;        &quot;path1-cookie=nineth; Domain=pathtest.com; Path=/; &quot;        &quot;path2-cookie=tenth; Domain=pathtest.com; Path=/one; &quot;        &quot;path3-cookie=eleventh; Domain=pathtest.com; Path=/one/two; &quot;        &quot;path4-cookie=twelfth; Domain=pathtest.com; Path=/one/two/; &quot;        &quot;expires-cookie=thirteenth; Domain=expirestest.com; Path=/;&quot;        &quot; Expires=Tue, 1 Jan 1980 12:00:00 GMT; &quot;        &quot;max-age-cookie=fourteenth; Domain=maxagetest.com; Path=/;&quot;        &quot; Max-Age=60; &quot;        &quot;invalid-max-age-cookie=fifteenth; Domain=invalid-values.com; &quot;        &quot; Max-Age=string; &quot;        &quot;invalid-expires-cookie=sixteenth; Domain=invalid-values.com; &quot;        &quot; Expires=string;&quot;    )    jar.update_cookies(cookies)    cookies_sent = jar.filter_cookies(URL(&quot;http://1.2.3.4/&quot;)).output(        header=&#x27;Cookie:&#x27;)    assert cookies_sent == &#x27;Cookie: shared-cookie=first&#x27;\n\n floxay&#x2F;python-riot-auth 里正好封装了cookie jar，也就是说，我们只要想办法弄出来一个 SimpleCookie 对象，再调用 update_cookie 方法，就大功告成了！\n3.最终实现关于这两个登录项目的源码，请去github仓库查看\n下面只对cookie部分进行说明！\n3.1 request和aiohttp的cookies差异\n因为cookie部分涉及到riot账户的登录信息，所以必须打码\n\n首先当然是从request里面拿到cookie了\nself.cookie = self.session.cookiesprint(self.cookie)\n\n这里直接打印，获取到的内容如下\n\n而aiohttp的cookie打印出来是下面这样的\nauth = riot_auth.RiotAuth(&quot;账户&quot;,&quot;密码&quot;)print(auth._cookie_jar._cookies)\n\n\n可以看到，两个库打印的内容不太相同，但是其键值是一致的，我们只需要把request的键值导入到SimpleCookie里面就可以了\n3.2 request.session的cookie导出为dict要想导入到SimpleCookie里面，我们可以先来看看这个类的构造是什么\n\n可以看到，该类其实是支持用dict来初始化的\n现在问题又变成了，如何将request.session的cookie导出为dict\n百度一下，这个问题的答案还是能找得到的\nau = Auth(username=&quot;账户&quot;,password=&quot;密码&quot;)ck_dict = requests.utils.dict_from_cookiejar( au.cookie )print(ck_dict)\n\n此时打印出来的结果如下，成功转换成了dict\n\n再把这个dict丢进SimpleCookie，运行无报错，那么说明ojbk了\n3.3 最终实现现在就只需要进行如下的操作，就能实现把2fa用户的cookie导入到riot_auth.RiotAuth()里面了！\nimport asyncioif __name__ == &#x27;__main__&#x27;:    print(f&quot;Start&quot;)    au = Auth(username=&quot;账户&quot;,password=&quot;密码&quot;)    ck_dict = requests.utils.dict_from_cookiejar( au.cookie )    print(ck_dict)    scookie = SimpleCookie(ck_dict)    auth = riot_auth.RiotAuth()    auth._cookie_jar._cookies    auth._cookie_jar.update_cookies(scookie)    ret = asyncio.run(auth.reauthorize())    print(ret) #成功！！！！\n\nauth.reauthorize()方法会返回一个bool值，标识是否登录成功\n\n当然成功啦！\n4.结语不得不说，这个问题的答案网上是真的无现成的，都得东平西凑，花了我差不多一个半小时才找到正确方法\n不过现在终于可以保存2fa用户的登录信息了，也算是bot的功能升级吧！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook","api"]},{"title":"【Python】关于vip和普通用户商店返回值图片出错的问题定位+大白话说明","url":"/posts/1592602771/","content":"在开发阿狸的过程中，遇到了一个全局变量写错而导致的bug……\n\n\n问题引出如果你最近几天有用过shop查询功能，可能会遇到下面的情况\n\n上图为普通用户的商店用了vip用户16-9的图片；\n下图为vip用户的商店用了普通用户1-1的图片\n\n\n简单说来，vip的商店返回值是16-9的图片，而普通用户的商店是1-1的图片。\n在上面的三个每日商店返回值中，就出现了vip用户的商店用了1-1的图，或者普通用户的商店用了16-9的图。\n这个bug昨天（22.09.12）我就发现了，是一位vip用户的商店返回值里面用了普通用户的图片。而我昨天定位bug的时候，测试bot保存了画出来的4个小图，没有问题；然后再使用&#x2F;shop命令，发现测试bot没有出现这个问题。于是我就把阿狸重启了一下，问题也消失了！于是就秉持“遇事不决，重启解决”的错误心态，没有打理这个问题。\n而今天（22.09.13）早上，这个问题又出现了，这次是普通用户的商店返回值里面用了vip的图片。于是我又把bot重启了一下，果然，问题又消失了。哈哈！解决了——个锤子！\n\n代码逻辑介绍这里先说明一下，阿狸的商店返回值逻辑如下：\n\n通过api获取玩家商店，api返回的是4个武器的uuid\n遍历所有武器，找到这4个武器名字+皮肤图片+价格+皮肤等级，将它们组合起来，画出一个小图\n再把画出来的4个小图，通过坐标映射，全部粘贴到最终的大图上面。也就是大家获取道的返回结果\n\n今天晚上，我自己获取商店的时候又双遇到了这个bug，于是再次认真看了一边代码。这下可算是发现这个问题的位置了~且听我细细道来（看下面的图片）\n\nweapon_icon_temp（就叫它抽屉吧）是一个全局变量，里面存放了画好的单个武器的图片（武器名字+武器图片+价格+皮肤等级）下图是画好的单图示例\n\n除了抽屉（weapon_icon_temp），阿狸还会把这个图片存放到本地路径里面（仓库）这样在阿狸重启之后（抽屉会被清空）本地路径（仓库）里面的图片还在，可以从仓库里面拿出来，也节省了画图的时间。\n逻辑大概是这样的\n\n用户A获取商店，阿狸画出了4个皮肤的图片，并把它们存了起来（抽屉和仓库都存了）；\n用户B获取商店，阿狸发现这两个用户的商店皮肤有重合，这时候就没必要再画一张图了，于是阿狸就从抽屉里（weapon_icon_temp）拿出了之前给用户A画好的相同皮肤的图片，直接粘贴到用户B最后的大图上。\n\n下图为普通用户的画图逻辑\n\n\n现在，vip的商店图片是16-9，普通用户的商店图片是1-1。所以阿狸会单独处理两种用户，并画出不同的图片，存放在不同的本地路径（仓库）中。\n\n普通用户存放在img_temp本地路径中，vip用户存放在img_temp_vip本地路径中\n\n\n可是，本地路径（仓库）的位置变啦，但是全局变量（抽屉）用的还是同一个啊！\n阿狸画图的时候，肯定是先从抽屉里面拿图片。因为抽屉顺手就能拿到，干嘛跑仓库里面去呢？（指全局变量访问比本地路径更快）\n这就导致了如果某个皮肤A先被普通用户张三查询到，而vip用户李四在之后查询的时候，也获取到相同的皮肤A，那么阿狸就从抽屉里面掏出了一张应该给普通用户用的图片，贴在了vip用户李四的返回值上，于是李四就获取到了下面这一张图片\n\n解决解决办法很简单，把vip和普通用户的抽屉分开就行了\n那为什么这个问题，重启阿狸就好了呢？\n前面提到过，抽屉会在阿狸关机的时候清除（因为全局变量是写在内存里面的，会在使用完毕后释放，类似于你划掉手机的后台应用来释放手机的运存一样）\n这样一来，抽屉里面没有之前画好的图片，那么阿狸就会去仓库里面（仓库是分开的）找出了正确的图片，测试就看不出来有bug了！（因为这个bug的触发必须要普通用户和vip用户使用阿狸查询商店，而他们同时刷出了一个皮肤。我的测试没有这种环境）\n咳咳，说了这么多，不知道大家看明白了没有\n\n结语阿狸会在22.09.14的早8点后重启，以修复这个bug。为啥现在不弄呢？因为重启会把普通用户的登录信息清空。导致普通用户明天8点的皮肤提醒功能不能用，之前因为重启已经连续几天这样了（指普通用户因为没有登录信息，无法使用皮肤提醒功能）对普通用户也太不公平了！\n感谢你看到了最后！！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Python】ValueError:Sample larger than population or is negative的原因","url":"/posts/2918276452/","content":"ValueError: Sample larger than population or is negative 的原因以及解决办法\n\n\n1.出现这几天重构kook-valorant-bot的代码的时候，遇到了这个问题\nJob &quot;vip_roll_task (trigger: interval[0:01:20], next run at: 2023-01-25 19:59:21 CST)&quot; raised an exceptionTraceback (most recent call last):  File &quot;/home/muxue/.local/lib/python3.10/site-packages/apscheduler/executors/base_py3.py&quot;, line 30, in run_coroutine_job    retval = await job.func(*job.args, **job.kwargs)  File &quot;/home/muxue/kook/val-bot/code/main.py&quot;, line 793, in vip_roll_task    ran = random.sample(range(0, len(VipRollDcit[msg_id][&#x27;user&#x27;]) - 1), vnum)  File &quot;/usr/local/lib/python3.10/random.py&quot;, line 482, in sample    raise ValueError(&quot;Sample larger than population or is negative&quot;)ValueError: Sample larger than population or is negativeerror raised during taskTraceback (most recent call last):  File &quot;/home/muxue/.local/lib/python3.10/site-packages/apscheduler/executors/base_py3.py&quot;, line 30, in run_coroutine_job    retval = await job.func(*job.args, **job.kwargs)  File &quot;/home/muxue/kook/val-bot/code/main.py&quot;, line 793, in vip_roll_task    ran = random.sample(range(0, len(VipRollDcit[msg_id][&#x27;user&#x27;]) - 1), vnum)  File &quot;/usr/local/lib/python3.10/random.py&quot;, line 482, in sample    raise ValueError(&quot;Sample larger than population or is negative&quot;)ValueError: Sample larger than population or is negative\n\n这部分代码是用来生成抽奖结果的随机数的，在网上百度了报错之后，得知是random生成随机数时产生的报错\n2.复现找到对应的代码\nran = random.sample(range(0, len(VipRollDcit[msg_id][&#x27;user&#x27;])-1), vnum) # 生成n个随机数\n\n这个代码的作用是，生成vnum个从0到len(VipRollDcit[msg_id][&#39;user&#39;]) - 1的随机数，不包含len(VipRollDcit[msg_id][&#39;user&#39;])-1\n\n咳咳，这里又发现了另外一个bug：我以为是包含右边界的，所以手动-1了；现在导致最后一个参加抽奖的用户永远都抽不到奖了😥\n正确的range应该是(0, len(VipRollDcit[msg_id][&#39;user&#39;]))\n\n但是，如果参与抽奖的人数少于vnum，就会出现上面的报错\nimport randomran = random.sample(range(0, 2), 3) \n\n可以来简单测试一下，这里我想在0到2之间（其实就是0,1）生成3个随机数\n$ py3 test1.pyTraceback (most recent call last):  File &quot;/home/muxue/kook/test/global_val_test/test1.py&quot;, line 16, in &lt;module&gt;    ran = random.sample(range(0, 2), 3)   File &quot;/usr/local/lib/python3.10/random.py&quot;, line 482, in sample    raise ValueError(&quot;Sample larger than population or is negative&quot;)ValueError: Sample larger than population or is negative\n\n此时运行，就会有这样的报错。\n因为这个写法的作用是在0-2之间产生不重复的随机数，你的目标数量都大于这个集合之中已有数据的数量了，那要怎么生成不重复的随机数呢？\n3.解决解决办法很简单\n\n右边界不能等于或者小于左边界\n产生随机数的数量要小于边界之中数据的数量\n\n比如上面的代码，我们修改一下边界，就能获得正确的结果\nimport randomran = random.sample(range(0, 3), 3) print(ran)\n\n运行\n$ py3 test1.py[0, 2, 1]\n\n对于我的抽奖代码而言，则需要重新操作一番。即可能出现奖品数量大于参与抽奖的人数的情况；\n这时候就需要进行判断了\n\n奖品数量少于抽奖人数，使用random生成随机数\n奖品数量大于抽奖人数，抛弃多余奖品，直接生成一个从0到总人数的列表\n奖品数量等于抽奖人数，上面两种情况都可以用\n\n代码如下\n# 人数大于奖品数量if len(VipRollDcit[msg_id][&#x27;user&#x27;])&gt;vnum: \tran = random.sample(range(0, len(VipRollDcit[msg_id][&#x27;user&#x27;])), vnum) # 生成vnum个随机数else: # 生成一个从0到len-1的列表 如果只有一个用户，生成的是[0]\tran = list(range(len(VipRollDcit[msg_id][&#x27;user&#x27;])))\n\n这时候就ok了，没有问题了\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","Kook"]},{"title":"【Artalk】在wiki js站点上使用Artalk评论系统","url":"/posts/3908173775/","content":"本篇博客将教您如何在wiki js站点上使用artalk评论系统\n\n\n[TOC]\n1.介绍1.1 wiki js\nhttps://github.com/requarks/wiki/\n\nwiki js是一个开源的wiki站点，可以在线编辑页面。\n页面以markdown编辑，同时支持富文本格式；因为其用git来管理提交历史，且在线编辑不需要用户知道如何操作git，所以非常适合多人协作撰写文档\n\n如果你只是想要一个博客站点，没有多人协作需求，那么hexo会更合适您\n\n共享文档（如金山文档）的提交历史大多数都不够详细，虽然有插入/删除历史，但是其没有标明上下文，你需要猜他是在文档的啥地方改了东西，非常不方便！\ngit是一个版本管理软件，能清楚地知道xx用户修改了xx文档的xx行，并能看到修改之前和修改之后的提交对比。这部分就不赘述了\nwiki js还有很棒的一点就是，你可以设置一个git仓库作为文档的备份，其会定时把整个站点的所有页面（包括图片）都上传到这个git仓库里面。即便站点因为某些原因出问题了，我们还有git仓库的备份😁\n\nwiki js的安装参考官方文档，建议用docker部署，方便的很，直接对着敲命令就行了。进入系统创建管理员账户后，可以在设置的local里面找到语言选择，下载中文语言包即可改成中文页面！\n\n\nWik js自带了评论系统，也支持markdown评论，但是它连最基础的回复评论都不支持，实在是有些捉急，所以才需要配置一下artalk来作为评论系统\n1.2 artalk\nhttps://artalk.js.org/\n\nartalk同样是一个开源的评论系统，作者写v1的时候还是一名高中生（人比人气死人，我太菜了）\n咳咳，这不是重点！\n\nartalk支持markdown发送评论，支持发送表情，还支持上传图片！作为wikijs的评论系统再合适不过了~\nemm，其实还有另外一个原因，那就是wiki js目前支持的3个第三方评论系统，似乎只有artalk是免费的😥\n\n2.安装artalk后端2.1 docker-compose安装基本安装方式参考官方文档，个人更加推荐用docker compose部署\n\nhttps://artalk.js.org/guide/deploy.html#docker-compose-%E9%83%A8%E7%BD%B2\n\n刚开始我拉取镜像的时候，一直出现505错误（添加了镜像源）后续在镜像后面加上最新的版本号才正常拉取了镜像\nversion: &quot;3.5&quot;services:  artalk:    container_name: artalk-go    image: artalk/artalk-go:2.3.0    ports:      - 8080:23366    volumes:      - ./data:/data\n\n创建好docker-compose.yaml文档后，用下面的命令运行\ndocker-compose up -d\n\n查看你服务器的8080端口（记得在云服务器防火墙里面开放端口）如果能打开下面的后端页面，那就是ok了\n\n2.2 开放管理员账户默认情况下，管理员账户是关闭的，我们需要关闭容器后，修改配置文件开放一个管理员账户\ndocker-compose stop\n\ncd进入data目录（这里的data目录是你在docker compose中映射的本地路径，默认应该就在docker-compose.yaml所在路径下会出现一个data文件夹）\n可以看到一个artalk-go.yml文件，我们需要修改的就是这个文件，找到下面的字段，对应修改后保存\n\n关于密码的部分参考文档 https://artalk.js.org/guide/backend/multi-site.html#%E7%AE%A1%E7%90%86%E5%91%98%E9%85%8D%E7%BD%AE\n\n\ndocker-compose up -d\n\n重新启动容器，用刚刚设置好的账户登录；后台的管理页面可以修改很多配置，我们不需要动配置文件了！\n2.3 配置sslwiki js必须要用ssl和https才能正常使用artalk，我尝试了公网IP:端口的方式，它认不出来😥\n所以我们需要在artalk的后台配置一下ssl（记得点界面右下角的应用）\n\n再次用域名打开页面，此时就没有报错了\n\n备注：我是用frp穿透到香港来映射域名的，所以ssl还需要在frp里面设置一下，请根据您自己的情况配置ssl！\n2.4 图片上传如果想让用户能上传图片，还需要做一些小操作；首先是启用图片上传（记得点界面右下角的应用）\n\n然后需要去后台在data目录下创建一个artalk-img文件夹（我刚开始没有创建这个文件夹的时候，没有办法正确上传图片）\n回到wiki js的界面测试一下，图片上传成功\n\n2.5 邮箱提醒避免有老哥之前没有用过stmp服务，这里也简单说一下吧\n可以注册一个网易的163或者126邮箱，找到设置里面会有一个stmp\n\n进入后，先把这两个服务都开启\n\n再点击这里新增授权密码，会弹出来一个二维码码让你用手机给一个号码发个短信，然后就会出现一个授权码，记住这个授权码\n\n回到artalk的后台进行如下配置\n\n这样就OK了，找朋友发条评论并回复，测试一下邮箱提醒能否正常使用吧！\n3.wiki js使用这部分就很傻瓜了，直接用起来就可以了\n3.1 artalk创建站点artalk虽然会有一个默认站点，但是那个wiki js不一定能正常使用，所以我们需要自己创建一个站点\n\n需要填写站点名称和url，名称建议用英文，避免编码问题\n\n然后为了避免错误，还可以在设置里面添加一下可信域名\n\n3.2 wiki js使用进入wiki js的管理页，找到评论，选择artalk\n\n填入域名和在artalk里面配置的站点名字后，点击应用\n回到wikijs的页面，此时就可以看到artalk的界面啦！\n\n3.3 bug我使用的时候遇到了评论框飞到顶栏上面的bug，已经在wiki的仓库中发评论了\n\nhttps://github.com/requarks/wiki/discussions/6015\n希望能尽快修复这个bug~\n未完待续后续有啥问题，我会在这里补充的~\n","categories":["docker真好玩"],"tags":["wikijs","Docker"]},{"title":"【Linux】浏览器写代码！部署code-server远程vscode网页","url":"/posts/2203891398/","content":"部署code-server远程vscode网页，在浏览器上写代码！\n\n\n参考文档 https://developer.aliyun.com/article/876967#slide-7\n1.什么是code-server？注意，这不是在linux系统上安装vscode软件（和windows一样的vscode客户端）\n\n开源仓库 https://github.com/coder/code-server\n\ncode-server是一个社区项目（非微软官方）其作用是在你的linux主机（云服务器）上部署一个可以在浏览器上访问的vscode页面，类似官方的vscode.dev\n\n微软官方推出的vscode网页版 https://vscode.dev/\n它可以通过浏览器的api访问你电脑上的本地文件，此时浏览器就是一个vscode客户端\n\n\ncode-server同理，其访问的是你linux服务器上的文件，作用类似于vscode插件remote ssh，让我们可以用浏览器，在任何电脑、平板上进行远程开发，无须下载vscode客户端或者ssh软件！\n\n1.1 官方的vscode-server?微软官方确实有一个vscode-server，在官网可以下载。我测试了之后，发现它是打了一个隧道，通过vscode.dev的子域名访问，会转发到你的主机上。\n\n在我这里的测试，发现压根连不上微软的服务器。想想其实也很正常，因为vscode-server的文档页面连中文都没有，再加上微软的服务器，国内用不了也是意料之中\n2.安装2.1 下载安装包截至本文创作时间23-03-09，code-server的最新版本是4.10.1，可以用下面的命令获取到linux下的安装包\nwget https://github.com/cdr/code-server/releases/download/v4.10.1/code-server-4.10.1-linux-amd64.tar.gz\n\n如果上面这个命令你无法访问，可以去github的releases里面手动下载安装包\n\nhttps://github.com/coder/code-server/releases/\n\n我的系统是amd64，即x86架构。在github里面也是找linux amd64的包进行安装\n$ uname -aLinux 1c2261732150 5.10.120 #0 SMP Fri Jan 6 08:05:47 2023 x86_64 x86_64 x86_64 GNU/Linux\n\n如果你使用的是树莓派等设备，请用uname -a确认你的系统架构，并下载对应的包\n\ngithub的release下载慢，可以用下面这个网站加速（用迅雷下，速度起飞）\nhttps://doget.nocsdn.com/#/\n\n下载完成后，将压缩包用xftp传输到服务器上\n2.2 解压使用下面的命令解压刚刚下载好的压缩包\ntar -zxvf code-server-4.10.1-linux-amd64.tar.gz\n\n给解压出来的文件夹改个短名字vsc\nmv code-server-4.10.1-linux-amd64 vsc\n\ncd进入这个文件夹\ncd vsc\n\nls -l，基本文件如下\ntotal 792drwxr-xr-x   8 muxue muxue   4096 Mar  4 12:26 .drwx------   6 muxue muxue   4096 Mar  9 22:42 ..drwxr-xr-x   2 muxue muxue   4096 Mar  4 12:26 bindrwxr-xr-x   3 muxue muxue   4096 Mar  4 12:26 lib-rw-r--r--   1 muxue muxue   1084 Mar  3 17:13 LICENSEdrwxr-xr-x 243 muxue muxue  12288 Mar  4 12:26 node_modules-rw-r--r--   1 muxue muxue 480100 Mar  4 12:26 npm-shrinkwrap.jsondrwxr-xr-x   5 muxue muxue   4096 Mar  3 17:13 out-rw-r--r--   1 muxue muxue   5235 Mar  4 12:24 package.json-rwxr-xr-x   1 muxue muxue   4877 Mar  3 17:13 postinstall.sh-rw-r--r--   1 muxue muxue   3056 Mar  3 17:13 README.mddrwxr-xr-x   3 muxue muxue   4096 Mar  3 17:14 src-rw-r--r--   1 muxue muxue 180977 Mar  3 17:13 ThirdPartyNotices.txtdrwxr-xr-x   2 muxue muxue   4096 Mar  3 17:14 typings-rw-r--r--   1 muxue muxue  76688 Mar  4 12:26 yarn.lock\n\n直接进入bin文件夹，我们需要用的可执行文件就在里头\n$ lscode-server\n\n这个code-server就是我们要的可执行文件\n2.3 启动code-serverexport PASSWORD=&quot;配置一个密码&quot;code-server --port 8888 --host 0.0.0.0 --auth password\n\n上面这个命令，启动之后，会创建一个端口为8888的web服务，此时使用ip:8888的方式，应该就可以访问到你的code-server服务了！\n[2023-03-09T14:52:07.081Z] info  Wrote default config file to ~/.config/code-server/config.yaml[2023-03-09T14:52:07.516Z] info  code-server 4.10.0 ac1fba8bde0c3f29bf6bc27d3d7d75cb2390a7c2[2023-03-09T14:52:07.517Z] info  Using user-data-dir ~/.local/share/code-server[2023-03-09T14:52:07.532Z] info  Using config file ~/.config/code-server/config.yaml[2023-03-09T14:52:07.532Z] info  HTTP server listening on http://0.0.0.0:8888/[2023-03-09T14:52:07.532Z] info    - Authentication is enabled[2023-03-09T14:52:07.532Z] info      - Using password from $PASSWORD[2023-03-09T14:52:07.532Z] info    - Not serving HTTPS\n\n出现下面的页面，那就是安装成功了！输入你刚刚设置的密码，就可以像使用vscode一样使用code-server了！\n\n2.4 配置文件首次启动了之后，会在你的用户路径下生成一个.config/code-server文件夹，里面有一个config.yaml\n$ ls .config/code-serverconfig.yaml\n\n打开这个文件，可以在里面配置code-server的密码，以及https访问。其余的配置项我还没有关注过，可以去看看github上的文档\nbind-addr: 127.0.0.1:8080auth: passwordpassword: 64f1881b805917a449d80874cert: false\n\n默认的密码巨长，改成你自己的即可。在这里还可以修改默认绑定的ip和端口，后续启动code-server，就不需要手动指定了，直接运行即可\n./code-server\n\n2.5 tmux后台运行\nnohup运行code-server有一点问题，所以要用tmux\n\n如果没有这个软件，先安装\nsudo yum install tmux\n\n创建一个新会话，你可以理解为这是一个脱离于bash的独立shell页面，即便当前bash退出了，code-server也不会退出\ntmux new -s vscode_online\n\n开启新会话后，进入vsc的bin目录，启动code-server，命令是不变的\n./code-server\n\n\n随后直接关掉当前bash，此时就已经实现了code-server的后台运行\n# 接入会话tmux a -t vscode_online# 结束会话tmux kill-session -t vscode_online\n\n\n\n3.一些问题3.1 nginx转发遇到1006错误我在采用nginx转发的时候，遇到了这个问题\n\n个人猜测，这大概率是因为我在config.yaml里面配置了code-server的https导致的\ncert: false # 关闭https\n\n将cert修改回false，再次测试，发现还是有这个问题！\n\n实际上，如果你进行了nginx转发，并不需要配置code-server的https\n保持默认的http即可\n\n\n后来发现是我的nginx转发设置有问题，正确的转发配置如下\nlocation / &#123;\tproxy_pass   http://127.0.0.1:8888;\tproxy_set_header Host $host;\tproxy_set_header Upgrade $http_upgrade;\tproxy_set_header Connection upgrade;\tproxy_set_header Accept-Encoding gzip;&#125;\n\n下面给出一个nginx的https的完整配置文件！\nserver &#123;    listen 443 ssl;    server_name  www.example.com;  # 域名    # 注意证书文件位置，是从/etc/nginx/下开始算起的    ssl_certificate cert/example.com.crt;    ssl_certificate_key cert/example.com.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    client_max_body_size 1024m;    location / &#123;       \tproxy_set_header Host $host;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection upgrade;        proxy_set_header Accept-Encoding gzip;        # 当下是直接用yum安装的nginx，可以直接用本地ip访问        # 如果是docker安装的nginx，需要改为公网ip        proxy_pass http://127.0.0.1:8888;    &#125;&#125;# 强制重定向http -&gt; httpsserver &#123;    listen 80; # 监听80端口    server_name  www.example.com;  # 域名    #把http的域名请求转成https    return 301 https://$host$request_uri;&#125;\n\n3.2 C&#x2F;C++插件由于code-server是一个第三方项目，所以一些官方的插件（如pylance）直接在code-server的插件商店里面搜是没有的\n我们需要去微软的vscode官网上下载插件的VSIX文件，使用本地文件的方式进行安装\n\nhttps://marketplace.visualstudio.com/VSCode\n\n\n不过，pylance用这个办法依旧无法安装。看来有些插件只有官方的vsc才能安装\n3.3 本地文件如果你用过vscode的remote-ssh插件连过你这个服务器，用户目录下面会有两个文件夹\n.vsc.vscode-server\n\n这两个文件夹是vscode的插件remote-ssh生成的，和本文安装的code-server无关！\n3.4 tmux常用语句tmux new　　创建默认名称的会话（在tmux命令模式使用new命令可实现同样的功能，其他命令同理，后文不再列出tmux终端命令）tmux new -s mysession　　创建名为mysession的会话tmux ls　　显示会话列表tmux a　　连接上一个会话tmux a -t mysession　　连接指定会话mysessiontmux rename -t s1 s2　　重命名会话s1为s2tmux kill-session　　关闭上次打开的会话tmux kill-session -t s1　关闭会话s1tmux kill-session -a -t s1　　关闭除s1外的所有会话tmux kill-server　　关闭所有会话\n","categories":["差生文具多"],"tags":["Linux","nginx","vscode","CentOS"]},{"title":"【Python】自动解析markdown中的图片并保存","url":"/posts/3761902412/","content":"python自动化下载&#x2F;上传md中图片实在是太方便了\n\n\n1.起因为什么需要python来下载md里面的图片？原因很简单，那就是需要把图片保存下来，上传到第二个图床（迁移）\n对于阿里云OSS来说，有两种迁移办法\n\n使用官方的数据导出功能\n使用api接口遍历oss目录下载所有图片\n\n这两种办法都不是那么方便，所以我选择了第三种\n\n解析本地md文件中的img url，下载图片并保存到本地\n\n那要怎么做呢？👇\n2.教程我在github找到了这个项目 👉 Deali-Axy&#x2F;Markdown-Image-Parser\n作者的代码写的很棒，但是README里面却少了一个重要的启动教程，那就是你需要在当前目录下创建一个files文件夹（md文件放到这里面），对应启动项里面开启的根目录\nif __name__ == &#x27;__main__&#x27;:    files_list = get_files_list(os.path.abspath(os.path.join(&#x27;.&#x27;, &#x27;files&#x27;)))\n\n随后，执行python spider.py，开始运行，脚本会自动将md转成html并下载图片\n我将作者的代码进一步细化，并修改了一部分bug👇建议使用我fork的版本\nhttps://github.com/musnows/Markdown-Image-Parser\n2.1 UnicodeDecodeError在启动的时候，你可能会遇到这个报错\nUnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xbc in position 2: invalid start byt\n\n解决办法参考 👉 点我\n解决办法是将打开文件编码的utf-8 修改成ISO-8859-1\nwith open(file, encoding=&#x27;ISO-8859-1&#x27;) as f:           md_content = f.read()\n\n2.2 request failed因为作者并没有写判断，此时就会出现一个严重问题：本地图片也会进行requests请求\n比如我的md里面就有一些图片是本地的img/图片文件名，这个代码依旧对这个路径当做网络路径进行请求，于是就出现了报错\n所以就需要在download_pics函数中对url进行判断，这里可以写成下面的格式（因为我知道我的阿里云OSS链接里面不包含img文件夹，所以img/的图片是本地文件\ndef download_pics(url, file,MDfilename):    if &#x27;img/&#x27; in url:        print(&#x27;不处理本地图片: &#x27;, url)        return\n\n但是这样其实还是有点呆呆的，我们直接判断http在不在里面不就知道是不是网络图片了😂\ndef download_pics(url, file,MDfilename):    if &#x27;http&#x27; not in url:        print(&#x27;不处理本地图片: &#x27;, url)        return\n\n2.3 图片保存路径默认情况下，图片会保存到子文件夹下的markdown文件名目录\ntarger_dir = os.path.join(dirname,assert_dir)if not os.path.exists(targer_dir):     os.mkdir(targer_dir)\n\n这样其实非常非常不方便管理，有几个md文档就有几个md图片路径，可太难受了\n所以我们需要注释掉这部分代码，直接选择一个根目录进行图片的保存\ntarger_dir =&#x27;./files/img/&#x27; # 所有图片都保存到 ./files/img/ 文件夹里面\n\n2.4 try&#x2F;except作者代码里面的最最最大漏洞，那就是没有对for循环里面的请求进行try/except\n这样就会导致，如果有一个图片请求失败，整个进程会直接终止！\n那么问题就来了，即便这个程序会在遍历的时候打印当前处理的文件名字，但这需要用户去翻命令行输出，再找到到底是哪一个图片发生错误，非常非常非常难受！\n如果重新执行，那就相当与把已经下好的图片又重下一遍，浪费OSS的流量。\n所以我们必须要给for循环内部添加上异常捕获，如果遇到错误，就将这个图片的url存下来，继续往后执行！\nfor file in files_list:    print(f&#x27;正在处理：&#123;file&#125;&#x27;)    with open(file, encoding=&#x27;ISO-8859-1&#x27;) as f:        md_content = f.read()    pics_list = get_pics_list(md_content)    print(f&#x27;发现图片 &#123;len(pics_list)&#125; 张&#x27;)    for index, pic in enumerate(pics_list):        try:            print(f&#x27;正在下载第 &#123;index + 1&#125; 张图片...&#x27;)            MDfilename = os.path.basename(file) # 当前处理的md文件的名字            download_pics(pic, file,MDfilename)            time.sleep(0.5) # 避免下载超速        except KeyboardInterrupt:            os.abort()        except:            print(traceback.format_exc())            if MDfilename not in err_img:                err_img[MDfilename]=[]            # 添加图片            err_img[MDfilename].append(pic)            print(&quot;图片获取错误：&quot;,pic)            time.sleep(1)print(f&#x27;处理完成。&#x27;)write_file(&#x27;err.json&#x27;,err_img)print(f&#x27;写入err完成&#x27;)\n\n完整代码见我的github仓库\n2.5 上传到lsky图床现在我要迁移的图床是lsky，所以为了方便，可以在将图片保存到本地的同时，将图片上传到lsky图床\n注意，上传之前，请在用户组将图片上传的格式改为原始文件命名，否则重命名了那就什么都没了！\n\n\n还发现了一个离谱的问题，那就是一些图片上传了之后，lsky还是会给他改名字！！！\n\n比如这个gif，他的alt里面是原始名字，但是url并不是！！！你说这离谱不\n解决方法那就是把本地的图片打一个压缩包，传到云服务器后台存储路径中覆盖一遍，把没有的图片给添加上\nunzip -o ~/docker/img.zip -d ~/docker/lsky/storage/app/uploads/23/02\n\n上传之前，先获取token\ndef lsky():    url = &quot;服务器地址/api/v1/tokens&quot;    params = &#123;        &#x27;email&#x27;:&#x27;账户邮箱&#x27;,        &#x27;password&#x27;:&#x27;密码&#x27;    &#125;    res = requests.post(url,  params=params)  # 请求api    return res.json()\n\n结果如下\n&#123;&#x27;status&#x27;: True, &#x27;message&#x27;: &#x27;success&#x27;, &#x27;data&#x27;: &#123;&#x27;token&#x27;: &#x27;这里会返回token&#x27;&#125;&#125;\n\n随后是上传的代码，注意兰空必须要用open &#39;rb&#39;重新打开一边图片，所以参数给img_path也就是图片的路径即可\n# 兰空图床def lsky_upload(img_path:str):    url = &quot;你的兰空图床服务器/api/v1/upload&quot;    header = &#123;        &quot;Authorization&quot;: &quot;Bearer 你的兰空token&quot;,        &quot;Accept&quot;: &quot;application/json&quot;    &#125;    img = open(img_path, &#x27;rb&#x27;)    params = &#123;&#x27;strategy_id&#x27;: 1&#125;    myfiles = &#123;&#x27;file&#x27;: img&#125;    res = requests.post(url, headers=header, params=params,                        files=myfiles)  # 请求api    return res.json()\n\n在download_pics的末尾添加如下代码，并对兰空图床的返回值进行判断，如果上传错误，同样添加到错误图片中！\n# 上传lskyres = lsky_upload(img_path=f&quot;&#123;targer_dir&#125;/&#123;filename&#125;&quot;)print(res)if not res[&#x27;status&#x27;]:    global err_img    if MDfilename not in err_img:        err_img[MDfilename]=[]         err_img[MDfilename].append(url)    print(&quot;兰空上传错误！&quot;,url)    time.sleep(1)\n\n上传成功的返回值status是True\n3.开始自动化上传将上面的bug修改好了之后，就可以正式运行，在保存图片到本地的同时，上传到兰空图床了！\n\n图片也都成功保存到本地了\n\n上传完毕之后，也能在err里面看到错误的图片路径，以便重新处理。\n可以看到这里面有一部分是gitee和csdn的链接，这些图片有防盗链，而且图片尾部添加了其他字段，导致lsky没有办法将其识别为图片（却少图片格式后缀）\n不过我的目标是将阿里云OSS的图片转到lsky，这些本来就不是阿里云OSS的图片和我的目的无关！\n\n做完这一切，最让我感慨的是，我的阿里云oss里面有1g的图片，实际用的却只有下面这一丢丢；其他估计都是重复上传的\n\n","categories":["速通Python"],"tags":["Python","图床"]},{"title":"【Nas】绿联安装CentOS8容器","url":"/posts/336198679/","content":"绿联安装CentOS8容器\n\n\n1.创建容器先在客户端安装容器，随后用xshell进入绿联的ssh\n\n绿联如何开启ssh参考视频；2023年11月后，新版本的绿联直接把远程调试打开，给出的调试密钥就是ssh的密码。\n绿联的ssh端口是922\n\n执行如下命令，以特权模式创建一个centos容器，并将容器内的22端口映射给主机的22222端口；如果你是希望在centos容器上进行网络编程开发，请多映射几个端口，以免到时候没办法访问项目的尴尬情况！\ndocker run -d \\\t-p 22222:22 \\\t--name centos \\\t--privileged=true \\\tcentos:latest \\\t/usr/sbin/init\n\n搞定了之后，进绿联客户端，停止容器运行，设置一个文件路径给容器内部，方便docker容器和nas资料互传（不设置也不是不行）\n\n注意，在客户端配置的时候，需要把所有能给的选项（-i -t 高级选项）全都勾上，避免docker安装的centos缺少权限；\n\n回到绿联的ssh终端，用下面的命令进入容器内部\ndocker exec -it centos /bin/bash\n\n你也可以用客户端里面的终端功能，但是那个太简陋了，不太好用。既然都已经能ssh连上绿联了，那完全没必要用客户端;\n当然，因为我们已经映射了22端口到绿联里面，所以你直接用ssh链接这个22222端口即可进入docker安装的centos\nssh root@绿联的IP -p 22222\n\n1.1 判断是否成功以特权模式安装systemctl \n\n执行此命令，看看是否有如下输出。如果没有，代表没有成功以特权模式安装。systemctl在linux中很常用，且开启容器的ssh也需要使用此命令！\n\n如果没能成功使用这个systemctl 命令，请重试上面的步骤\n2.更新软件docker安装的Centos并没有虚拟机安装的那么完全，还需要我们进行软件源的配置操作\nyum update -y &amp;&amp; yum upgrade -y\n\n第一次执行此命令的时候，大概率会出现下面的报错（我在两个不同平台的docker里面启动的centos都遇到了这个问题，因为docker安装的centos是最小安装，所以缺少了yum源的配置项）\nError: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist\n\n参考 Error: Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist 博客，用下面的命令解决这个问题。\n\n如果上面该博客链接无法打开，可以查看本站转载的原文\n\ncd /etc/yum.repos.d/sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*\n\n随后执行如下命令。创建缓存\nyum makecache\n\n执行makecache后，系统会获取一些内容，然后我们重新执行如下命令\nyum update -y &amp;&amp; yum upgrade -y\n\n会进行一连串的更新，直到出现下面的complete窗口，代表成功！\n\n\n3.ssh链接3.1 安装passwd一个linux系统，不能ssh链接可不行，我们需要更新一下内容，实现ssh链接\nyum install passwd\n\n先安装passwd命令，设置root的密码\npasswd\n\n会弹出来让你输入密码，盲敲就行\n3.2 安装vim和openssh用下面的命令安装vim和openssh\nyum install vim openssh-server openssh-clients -y\n\n安装完毕后，修改ssh的配置文件（vim的使用请百度）\nvim /etc/ssh/sshd_config\n\n取消注释下面的字段即可开启ssh\nPort 22ListenAddress 0.0.0.0ListenAddress ::PermitRootLogin yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys\n\n修改好了之后，退出终端；\n用下面的命令重启ssh服务，并设置开机启动ssh\nsystemctl restart sshd.servicesystemctl enable sshd.service\n\n如果一切正常的话，这两个命令应该什么都不会输出！\n3.3 尝试ssh链接因为我们把docker容器的22端口映射给了nas的22222端口，所以ssh的时候需要指定对应端口进行连接。\nssh root@绿联的IP -p 22222\n\n如果一切正常的话，会弹出来让你验证登录，到这里就是ok了\n\n3.4 配置ls命令颜色vim /etc/profile\n\n在末尾添加如下字段\nexport LS_OPTIONS=&#x27;--color=auto&#x27;alias ls=&#x27;ls $LS_OPTIONS&#x27;alias ll=&#x27;ls $LS_OPTIONS -lA&#x27;\n\n随后重启容器即可\n3.5 配置yum阿里源备份原有源\ntar -zcvf CentOS-bk.tar.gz /etc/yum.repos.d/CentOS-*\n\n看看本地的centos是什么版本\ncat /etc/redhat-release\n\n我这里的版本是8.5\nCentOS Linux release 8.5.2111\n\n替换为阿里源\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repocurl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-8.repo\n\n重新生成缓存\nyum clean allyum makecache\n\n\n现在速度快多了！\n开用！后续的使用就不再多说拉！既然你想安装centos，想必对linux的了解肯定比我多😂\n","categories":["docker真好玩"],"tags":["CentOS","nas"]},{"title":"【Docker】deepin/centos安装docker","url":"/posts/2069190154/","content":"deepin虚拟机和centos服务器安装docker \n\n\n1.更新软件包# deepinsudo apt-get update &amp;&amp; sudo apt-get upgrade# centossudo yum update &amp;&amp; yum upgrade\n\n安装docker之前，先更新一下软件包\nmothra@mothra-PC:~$ sudo apt-get update &amp;&amp; sudo apt-get upgrade请输入密码:验证成功命中:1 https://community-packages.deepin.com/deepin apricot InRelease命中:2 https://community-packages.deepin.com/driver driver InRelease命中:3 https://pro-driver-packages.uniontech.com eagle InRelease命中:4 https://community-packages.deepin.com/printer eagle InRelease命中:5 https://home-store-img.uniontech.com/230506175326447/appstore deepin InRelease正在读取软件包列表... 完成正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成正在计算更新... 完成升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。\n\n2.安装docker# deepinsudo apt-get install docker-cesudo apt-get install docker-compose# centosyum install -y https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpmyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.reposudo yum install docker-ce docker-ce-cli containerd.io\n\n\n\n启动docker\nsystemctl start docker\n\n安装之后，用如下命令看看版本，看看是否安装成功\n$ docker -vDocker version 19.03.8, build 1b4342cd4c\n\n如下就是安装成功了\n\n开机自启动\nsystemctl enable docker\n\n2.1 centos8安装报错找不到docker\n参考 https://www.cnblogs.com/yizhangheka/p/16614941.html\n\n在centos8上安装docker的时候，发现找不到docker的相关信息\n# sudo yum install docker-ce docker-ce-cli containerd.ioLast metadata expiration check: 0:12:10 ago on Wed 10 May 2023 10:37:43 PM CST.No match for argument: docker-ceNo match for argument: docker-ce-cliNo match for argument: containerd.ioError: Unable to find a match: docker-ce docker-ce-cli containerd.io\n\n这是因为我们没有docker的软件源。依照如上博客中的教程，执行如下命令\n# 下载软件源yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm# 安装依赖包yum install -y yum-utils device-mapper-persistent-data lvm2# 更新docker源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 安装dockersudo yum install docker-ce docker-ce-cli containerd.io\n\n这样就能安装成功了，执行docker version命令查看版本，出现如下内容就是成功安装docker了。\n&gt; docker versionClient: Docker Engine - Community Version:           24.0.6 API version:       1.43 Go version:        go1.20.7 Git commit:        ed223bc Built:             Mon Sep  4 12:33:07 2023 OS/Arch:           linux/amd64 Context:           default\n\n2.2 安装docker-composepython安装（可能失败）需要保证系统内的python环境完好\npip3 install -i https://mirrors.aliyun.com/pypi/simple docker-compose\n\n安装好了之后查看版本，如下便是安装成功了\n$ docker-compose versiondocker-compose version 1.29.2, build unknowndocker-py version: &lt;module &#x27;docker.version&#x27; from &#x27;/usr/local/lib/python3.10/site-packages/docker/version.py&#x27;&gt;CPython version: 3.10.5OpenSSL version: OpenSSL 1.1.1q  5 Jul 2022\n\n参考 https://www.cnblogs.com/yizhangheka/p/16614941.html\n但在我的CentOS8上，上面的python安装方式会失效；\n我使用的是python3.10.6，安装会出现如下报错，无法成功安装；\n  File &quot;&lt;string&gt;&quot;, line 201, in get_source_files  File &quot;/tmp/pip-build-env-v8dnn0u_/overlay/lib/python3.10/site-packages/setuptools/_distutils/cmd.py&quot;, line 107, in __getattr__    raise AttributeError(attr)AttributeError: cython_sources[end of output]\n\n从Github安装\n参考博客 https://computingforgeeks.com/install-docker-and-docker-compose-on-rhel-8-centos-8/https://serverspace.io/support/help/how-to-install-docker-on-centos-8/\n\n然后又找了些博客，可以使用如下命令，直接下载docker-compose的可执行文件安装\nsudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# 修改权限chmod +x /usr/local/bin/docker-compose\n\n安装完毕后的测试结果如下，也是OK的\n# docker-compose -v docker-compose version 1.29.2, build 5becea4c\n\n但是这个安装的版本实在是太老了，最新版本都已经到2.23.0了。又在想办法找最新版本的安装教程；我尝试修改上述curl命令中的版本号，但是没用\n\n所以还是得用老办法，先打开github的release页面 https://github.com/docker/compose/releases\n这时候我发现上述的curl安装命令其实本质上就是下载一个可执行文件。在CentOS8上，uname -s是linux，uname -m是x86_64，命令执行结果如下；\n&gt; uname -sLinux&gt; uname -mx86_64\n\n所以其实我们需要下载的是docker-compose-linux-x86_64这个文件，对应下图中红色箭头所指的位置\nhttps://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64\n\n\n找到最新版本的文件url了，将其用相同的方式下载下来不就行了？\nsudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64&quot; -o /usr/local/bin/docker-compose# 修改权限chmod +x /usr/local/bin/docker-compose\n\n如果github下载实在是太慢，可以尝试用github的代理地址下载；截至20231028，该代理地址的下载速度很快，完全可用。\nsudo curl -L &quot;https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64&quot; -o /usr/local/bin/docker-compose\n\n安装完成，当前v2.23.0最新版本搞定！\n&gt; docker-compose --versionDocker Compose version v2.23.0\n\n3.修改docker镜像源国内下载docker的images有时候很慢，所以需要我们修改镜像源。可以打开下面这个网站\nhttps://www.daocloud.io/mirror#accelerator-doc\n\n\n额，写博客这天的时候，他们的服务502了。打不开网站。\n\n用如下办法修改\nsudo vim /etc/docker/daemon.json\n\n进入后，按i进入编辑模式，复制如下内容，用shift+ins粘贴\n&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125;\n\n然后:wq退出，用如下命令重启docker服务，镜像就设置好了\nsudo systemctl restart docker\n\n国内可用的docker镜像有下面这些，更多镜像可以百度看看。南京大学和上海交大的镜像源用的人少，似乎更好用。之前有一段时间docker国内的镜像都挂了，基本没办法pull，现在应该是解决了。\n科大镜像：https://docker.mirrors.ustc.edu.cn/七牛云：https://reg-mirror.qiniu.com网易：https://hub-mirror.c.163.com/南京大学: http://docker.nju.edu.cn 上海交大: docker.mirrors.sjtug.sjtu.edu.cn打开下面的地址登录你的阿里云账号获取你的专属镜像源 https://cr.console.aliyun.com/#/accelerator阿里云：https://&lt;你的ID&gt;.mirror.aliyuncs.com\n\n4.一些docker常用命令因为当前我们用的是deepin的用户，而不是root，所以执行docker相关命令的时候都需要带上sudo\nsudo docker ps # 查看当前正在运行的容器sudo docker ps -a # 查看当前所有容器（包括未运行的）sudo docker stats # 查看docker运行状态（资源占用）sudo docker stats 容器名字 # 某一个容器的运行状态sudo docker rm 容器名字  # 删除容器sudo docker rmi 镜像hash # 删除镜像\n\ndocker-compose的操作需要根据docker-compose.yml进行，具体的请参考不同容器的yml文件编写和使用。一般用户量大的开源docker都会有docker-compose.yml的示例文件的！\n其他的docker操作，请根据特定容器进行操作，详情百度吧！\n","categories":["docker真好玩"],"tags":["Linux","Docker","deepin"]},{"title":"【docker】群晖nas部署开源论坛Flarum | 转载","url":"/posts/2506750545/","content":"群晖nas部署开源论坛Flarum，本文为转载\n\n\n版权声明：本文为CSDN博主「杨浦老苏」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/wbsu2004/article/details/127083835原文发布时间：2022-09-28 10:07:30\n\n\n这回是居委会通知的\n\n\n\n本文完成于 5 月底\n\n什么是 Flarum ？\n\nFlarum 是一个非常简单的网站讨论平台。它快速且易于使用，具有运行成功社区所需的所有功能。它还具有极强的可扩展性，可实现终极定制。\n\n论坛虽然逐渐被淘汰了，但老苏觉得搭一个用来做知识管理，或者用来和家人分享照片、视频的快乐时光，还是挺不错的。\n局域网用用就好了，不要映射到互联网\n安装建数据库网上能找到的都是docker-compose 的安装方式，除了 Flarum 外还需要安装 MariaDB。老苏用了群晖自带的 MariaDB 10 数据库。\n\n在 phpMyAdmin 中创建名为 flarum 的空数据库。\n\n安装镜像在群晖上以 Docker 方式安装。\n在注册表中搜索 flarum ，选择第一个 mondedie/flarum，版本选 latest\n\n存储卷在 docker 文件夹中，创建一个新文件夹 flarum，并在其中建 4 个子文件夹，分别是 assets、extensions、logs、nginx\n\n\n\n端口本地端口不冲突就行，不确定的话可以用命令查一下\n# 查看端口占用\nnetstat -tunlp | grep 端口号\n\n本地端口8888，容器端口8888\n默认并没有映射端口\n\n需要点 + 号添加\n\n环境其中部分属于需要修改的，部分属于需要新增的\n\n\n更多的环境变量请移步：https://github.com/mondediefr/docker-flarum\n\n\n常规名称命名为 flarum，这是为了方便后面进入容器内做设置，不改也可以，改了可以少输入几个字母\n\n\n慕雪的提示：在我测试的时候，发现该镜像若修改环境变量中的FORUM_URL，可能会导致docker无法正常启动！请在配置前确认您的远端地址，配置好后最好不要修改！\n\n命令行安装如果你熟悉命令行，可能用 docker cli 更快捷\n# 新建文件夹 flarum 和 子目录mkdir -p /volume2/docker/flarum/&#123;assets,extensions,logs,nginx&#125;# 进入 flarum 目录cd /volume2/docker/flarum# 运行容器docker run -d \\   --restart unless-stopped \\   --name flarum \\   -p 8888:8888 \\   -v $(pwd)/assets:/flarum/app/public/assets \\   -v $(pwd)/extensions:/flarum/app/extensions \\   -v $(pwd)/logs:/flarum/app/storage/logs \\   -v $(pwd)/nginx:/etc/nginx/flarum \\   -e DEBUG=false \\   -e FORUM_URL=http://192.168.0.197:8888 \\   -e DB_HOST=192.168.0.197 \\   -e DB_PORT=3307 \\   -e DB_NAME=flarum \\   -e DB_USER=flarum \\   -e DB_PASS=123456 \\   -e DB_PREF=flarum_ \\   -e FLARUM_ADMIN_USER=laosu \\   -e FLARUM_ADMIN_PASS=123456 \\   -e FLARUM_ADMIN_MAIL=wbsu2003@gmail.com \\   mondedie/flarum\n\n\n慕雪的补充:如果你使用的不是群晖这种自带数据库的nas，也可以使用docker简单部署一个mysql作为flarum的数据库，命令如下；\n\ndocker run -d -p 3306:3306 \\--name mysql --privileged=true \\-v /data/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\mysql:5.7\n\n创建完毕后，进入容器进行mysql的用户创建\ndocker exec -it mysql /bin/sh\n\n用户创建相关语句可查看慕雪的另外一篇博客-&gt;【点我】\n\n也可以用 docker-compose 安装，将下面的内容保存为 docker-compose.yml 文件\nversion: &quot;3&quot;services:  servas:    image: mondedie/flarum    container_name: flarum    restart: unless-stopped    ports:      - &quot;8888:8888&quot;    volumes:      - /volume2/docker/flarum/assets:/flarum/app/public/assets      - /volume2/docker/flarum/extensions:/flarum/app/extensions      - /volume2/docker/flarum/logs:/flarum/app/storage/logs      - /volume2/docker/flarum/nginx:/etc/nginx/flarum    environment:      - DEBUG=false      - FORUM_URL=http://192.168.0.197:8888      - DB_HOST=192.168.0.197      - DB_PORT=3307      - DB_NAME=flarum      - DB_USER=flarum      - DB_PASS=123456      - DB_PREF=flarum_      - FLARUM_ADMIN_USER=laosu      - FLARUM_ADMIN_PASS=123456      - FLARUM_ADMIN_MAIL=wbsu2003@gmail.com\n\n\n然后执行下面的命令，在 portainer 中执行也是可以的\n# 新建文件夹 flarum 和 子目录mkdir -p /volume2/docker/flarum/&#123;assets,extensions,logs,nginx&#125;# 进入 flarum 目录cd /volume2/docker/flarum# 将 docker-compose.yml 放入当前目录# 一键启动docker-compose up -d\n\n\n运行第一次需要初始化，当在日志中看到 Forum is starting. 就可以访问了\n\n在浏览器中输入 http://群晖IP:8888 就能看到主界面\n\n设置界面\n\n管理员后台\n\n中文默认 Flarum 只支持英文，但是有中文扩展：https://discuss.flarum.org.cn/d/1211\n终端机可以进入终端机中安装\n或者命令行填写\ndocker exec -it flarum /bin/sh\n\n\n执行下面的命令\n# 进目录cd /flarum/app# 安装中文语言包composer require flarum-lang/chinese-simplified# 清除缓存php flarum cache:clear\n\n\n\n命令行在 SSH 客户端的命令行中执行下面的命令\n# 进入容器docker exec --user root -it flarum /bin/sh# 进目录cd /flarum/app# 安装中文语言包composer require flarum-lang/chinese-simplified# 清除缓存php flarum cache:clear\n\n\n\n安装完成后，在管理员后台能看到 Languages 中多了 简体中文;\n进入 简体中文，默认是 Disable\n\n改为 Enabled\n\n在 Basic 中，设置为缺省的语言\n\n保存后刷新页面\n\n主界面刷新一下\n\n发个帖子试试\n\n浏览效果\n\n参考文档\nflarum&#x2F;flarum: Simple forum software for building great communities.地址：https://github.com/flarum/flarum\n\n\nmondediefr&#x2F;docker-flarum: Docker image of Flarum地址：https://github.com/mondediefr/docker-flarum\n\n\n简体中文语言包 - Flarum 中文社区地址：https://discuss.flarum.org.cn/d/1211\n\n\nFlarum 中文社区地址：https://discuss.flarum.org.cn/\n\n","categories":["docker真好玩"],"tags":["MySQL","docker"]},{"title":"【docker】如何本地构建镜像并发布到dockerhub","url":"/posts/1414052231/","content":"制作镜像，最后一个.指定的是当前路径，可以切换为其他路径\nsudo docker build -t 镜像名:tag .\n\n\n需要先登录你的dockerhub账户\nsudo docker login\n\n输入docker hub的账户和密码（不需要token）\n然后给本地的镜像打个tag\nsudo docker tag e2bdy:0.1.0 musnows/e2bdy:0.1.0sudo docker tag 本地镜像名:版本 用户名/镜像名:版本\n\n然后再执行push\nsudo docker push musnows/e2bdy:0.1.0sudo docker push 用户名/镜像名:版本","categories":["docker真好玩"],"tags":["docker"]},{"title":"【docker】绿联nas部署mysql+wikijs","url":"/posts/3856317267/","content":"本文为绿联docker上mysql+wikijs的配置教程。\n\n\nmysql是众多数据库之一，很多其他的docker容器都需要用到数据库。比如图床、wikijs\n\n所用nas：绿联dh2600\n\n1.安装mysql1.1 下载镜像在绿联的docker套件-本地镜像-添加-官方库，搜索mysql\n\n选择最新版本，点击确定，等待镜像拉取完毕\n\n1.2 创建容器随后在本地镜像列表中选择刚刚下载的mysql镜像，点击+创建容器。\n未提及的选项都无需设置\n\n若需要对容器进行资源限制，则至少给1G内存\n网络选择bridge\n存储空间建议本地新建一个文件夹进行映射，装载路径为/val/lib/mysql\n\n\n\n端口映射，其中3306是http，33060是https，这部分本地映射一个没有被占用的端口即可\n\n\n\n环境变量处添加MYSQL_ROOT_PASSWORD，值为mysql的初始密码\n\n\n点击下一步-确定，容器创建完毕！\n\n如果你的系统支持ssh，可以直接使用如下命令创建\ndocker run \\\t--name mysql \\\t-d \\\t-p 3306:3306 \\\t--restart unless-stopped \\\t-v 本地路径:/var/lib/mysql \\\t-e MYSQL_ROOT_PASSWORD=123456 \\\t-e TZ=Asia/Shanghai \\\tmysql:8.0.30\n\n这样创建出来的mysql，root用户密码是123456\n1.3 确认安装成功容器开始运行后，点击详细-终端，连接/bin/bash\n\n若配置正确，则应该出现下面的画面\n\n输入以下命令，进入mysql控制台\nmysql -uroot -p密码\n这里的密码是刚刚载环境变量中设置的密码，比如上面演示的密码是123456，那么就应该用下面的语句\nmysql -uroot -p123456\n如果出现下面的内容，则代表mysql安装成功！\n1.4 创建数据库但有mysql还不够，如果想给其他项目使用，我们还需要创建数据库\n以WIKI JS为例，先输入以下语句进入数据库\nmysql -uroot -p密码\n\n输入以下语句，创建数据库。可以复制后按shift+ins粘贴，不要用ctrl+v粘贴\nCREATE DATABASE 数据库名;\n创建一个名为WIKIJS的数据库\nCREATE DATABASE WIKIJS;\n\n1.5 创建用户输入以下语句，查看当前数据库的用户\nselect user from mysql.user;\n显示的结果如下（不知道为啥我这里有两个root，不影响使用）\nmysql&gt; select user from mysql.user;+------------------+| user             |+------------------+| root             || mysql.infoschema || mysql.session    || mysql.sys        || root             |+------------------+6 rows in set (0.00 sec)mysql&gt; \n\n为方便容器管理，我们给WIKI JS创建一个单独的用户，名为WIKI\nCREATE USER &#x27;WIKI&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;\n这样，我们就创建了一个WIKI用户，密码为123456\t\n创建完毕后，我们还需要给这个用户授权，让其有能力处理数据库\nGRANT ALL ON WIKIJS.* TO &#x27;WIKI&#x27;@&#x27;%&#x27;;\n上面这个语句的意思为，授予WIKI用户在数据库WIKIJS中所有权限（ALL).\n注意区分，ALL ON 后面的是数据名字，TO后的是用户名字\n这样，WIKI用户和WIKIJS数据库都创建完毕了，可以在 WIKI JS 的环境变量中进行配置了\n1.6 mysql的实际运用如果你不是程序猿，单独的mysql容器可能没啥用，后续将分享mysql容器的两个使用实例\n\nwiki js\nchevereto 图床\nlsky 图床\n\n1.7 docker使用mysql命令总结如果你看了上面那一堆，还是不懂，那就可以把下面的3个语句记住，对所有要用到MySQL数据库的docker容器都适用!\n-- 先在nas的系统中进入MySQL容器的终端里面，然后执行如下命令mysql -uroot -p密码-- 进入MySQL命令行后，创建数据库和用户create database 数据库名字;-- 数据库名字要和上面创建的这个数据库对应CREATE USER &#x27;用户名&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;用户的密码&#x27;;GRANT ALL ON 数据库名字.* TO &#x27;用户名&#x27;@&#x27;%&#x27;;\n\n当然，如果你的NAS内存够多，你也可以选择抄别人的docker-compose文件一次性联动创建多个容器，突出一个傻瓜式；\n2.WIKI JS下面将继续讲解wiki jsdocker的安装，其至少需要1G内存，加上mysql容器，总共至少需要2G内存。请确认您nas的内存足够，再执行以下操作!\n2.1 是什么wikijs就是一个文档的呈现方式。该站点具有以下几个优点\n\n数据存本地，安全性高\n多用户在线编辑，可进行权限管理\n有历史版本管理，方便查看旧版本情况\n若有需要，可以将文档自动同步到云存储平台备份，如git仓库\n可导出数据到本地，均为markdown格式。脱离wiki js也可以用typora等支持markdown的软件打开\n\n2.2 有啥用你可能觉得，这玩意对家庭用户来说没啥用啊？实际上，它可以作为一个极其不错的家庭记事本！\n所有的数据都是存在你本地的nas上的，只要在家就可以简单地通过ip+端口的方式访问wikijs。电脑手机都能直接在线编辑，免去了多端同步的烦恼。\n如果你有公网ip，还可以在外网直接访问；没有公网ip的也可以用樱花frp进行内网穿透，免费10m带宽足够wiki js使用了（樱花frp的docker安装教程见官网帮助文档）\n相当于一个云同步的记事本！（只不过对手机编辑并不是很友好）\n2.3 下载wikijs镜像老地方，添加镜像，选择 linuxserver/wikijs 的latest版本即可\n\n2.4 安装配置网络模式选择bridge\n创建一个新文件夹，映射给wikijs的/config，记得修改权限为读写\n\nwikijs的端口只有一个，设置一个不冲突的即可\n\n环境变量需要我们配置很多！划重点！！\n\n在配置环境变量前，请先参考 01-mysql 中的教程，在mysql中创建一个WIKIJS数据库，和WIKI用户\n\n\n\n\n环境变量\n值\n\n\n\nDB_TYPE\nmysql\n\n\nDB_HOST\n数据库主机名或ip，直接填写nas的ip即可\n\n\nDB_PROT\nmysql容器的端口\n\n\nDB_USER\n数据库用户名\n\n\nDB_PASS\n数据库用户的密码\n\n\nDB_NAME\n数据库名称\n\n\n其中DB_TYPE为数据库类型，支持 mysql, postgres, mariadb, mssql, sqlite，本文使用的是mysql\n下图为一个配置后的示例\n\n配置完环境变量后，容器就配置完成了，点击确定\n3.使用wikijs在浏览器页面输入你nas的ip+端口，即可打开wiki js的网页。\n是英语的咋办？别担心，进去之后就可以改成中文了。\n\nAdministrator Email 管理员邮箱，输入一个你自己的邮箱即可\nPasswd 密码\nConfirm Passwd 确认密码\n\nurl这里可以不填，填完信息后直接点击下面的INSTALL即可\n\n初次使用的时候需要下载一些依赖项，下载完成后，即可进入登录页面。输入你刚刚设置的账户邮箱，点击log in进入wikijs的管理后台\n\n进入之后你会看到两个选项（无截图）直接点击右边那个进入管理页面👇\n\n进入后选择Locale，在右侧可以看到中文，下载之后，选择中文再点击右上角绿色的APPLY，页面就变成中文了\n\n随后就创建一个页面吧！\n学习markdown语法如果你之前没有接触过任何markdown语法，则可以选择富文本编辑器\n\n个人建议学习一下基本的markdown语法，非常简单！在很多平台（CSDN、知乎、博客园）以及很多笔记软件（为知、有道云、flowus等）都是支持markdown的。\n\n学习md语法可以查看此网站 👉 markdown.com.cn\n\nOVER!现在你已经可以将wiki js作为多人协作文档编辑站点，或者是你的家庭记事本了！\n随时可看，随时可编辑！\n参考文章\n群晖内通过Docker安装MySQL5.7.34\nMySQL 创建用户，设置密码\nMySQL 创建数据库\n轻量但功能强大的Wiki.js\n\n","categories":["docker真好玩"],"tags":["docker","mysql"]},{"title":"【nginx】配置跨域请求问题 | 转载","url":"/posts/3435557393/","content":"ngnix配置跨域请求问题\n\n\n1.问题今天在尝试写一个html代码（抄csdn的）请求我自己的valorant api的时候，遇到了下面的问题\n\n百度了一下，大概的意思就是，当前我的api服务器不支持跨域请求。\n此时请求其实已经完成了（后端日志显示已经返回了结果）在返回到浏览器的时候，浏览器检查了后端的设置，发现后端不允许跨域请求，所以屏蔽了我们的访问\n2.解决需要配置的是nginx，在转发规则里面添加下面的内容\nlocation / &#123;    add_header Access-Control-Allow-Origin *;    add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;;    add_header Access-Control-Allow-Headers &#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;;    if ($request_method = &#x27;OPTIONS&#x27;) &#123;        return 204;    &#125;&#125;\n\n现在就OK了\n\n版权声明：本文为CSDN博主「Young丶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/agonie201218/article/details/112562252\n","categories":["玩上Linux"],"tags":["Linux","nginx"]},{"title":"【docker】部署minio对象存储并用rclone同步","url":"/posts/1950951389/","content":"docker部署minio对象存储并用rclone同步\n1.什么是minio？minio是一个开源的对象存储服务器，兼容S3协议。\n官网：https://min.io/\n官方在开源的基础上也提供云端S3服务，分为个人和企业，有不同的收费标准。\n\n1.1 自建对象存储的好处？当然，本文写下来肯定不是让你去买它的对象存储服务的，而是在我们自己的服务器&#x2F;Nas上部署一个minio的docker，来拥有一个我们自己的对象存储服务器！\n对象存储服务器可以用来做图床、静态资源缓存，亦或者是直接当作一个网盘来使用。\n自建的对象存储的好处是所有源文件我们都能亲手管理，且无需为付费的对象存储的奇怪的计价文档感到手足无措，也不需要担心有人恶意刷流把你一套房子给套走。\n缺点就是，自建的稳定性肯定不如已有厂家提供的服务，且自购的服务器&#x2F;Nas上传带宽一般都很低，文件一多，访问速度就很慢了。\n对于我个人而言，自建minio的唯一作用，就是备份七牛云&#x2F;阿里云对象存储中的文件。考虑到2023下半年，各大厂接连boom云服务，国外的谷歌还出现了云盘里面用户的数据回滚到几月前的恶性问题，这可是可能导致用户数据丢失的大问题啊！\n\n谷歌公布方案，修复 Drive 云盘文件丢失问题\n谷歌承认云端硬盘Google Drive存在BUG，3月内用户文件可能丢失\n\n所以，将数据在自己本地留一份总是安心一些。数据安全靠的是备份，不是云服务厂家给你提供的99.99999%可用性的一面之词。\n如果你对数据备份这个话题感兴趣，可以看看我的另外一篇博客：谈谈如何进行有效数据备份，3+2+1\n\n温馨提醒：如果你想在云服务器上安装minio来备份已有S3中的文件的话，最好是使用一个和已有S3不在同一个地域、非同一个服务商的云服务器，避免某些服务商云服务器和对象存储一起boom的情况……\n\n2.docker安装minio2.1 安装dockerdocker安装的教程详见我的另外一篇博客\n【Docker】deepin&#x2F;centos安装docker | 慕雪的寒舍\n2.2 安装minio这里推荐使用由VMware维护的minio docker版本bitnami/minio，更新很频繁。\nhub.docker.com&#x2F;r&#x2F;bitnami&#x2F;minio\n创建容器的命令如下，非常简单\ndocker run -it -d --name minio \\\t-p 9000:9000 \\\t-p 9001:9001 \\\t--restart=always \\\t-v /minio/data:/bitnami/minio/data \\\t-e MINIO_ROOT_USER=&quot;minio_root&quot; \\\t-e MINIO_ROOT_PASSWORD=&quot;minio_123456&quot; \\\t-e TZ=&#x27;Asia/Shanghai&#x27; \\\tbitnami/minio:latest\n\n该创建容器操作基于如下hash的docker镜像（更新于2023-12-12），创建容器的命令后续可能会有变动，请参考docker-hub中的官方文档\nbitnami/minio  latest    552af9bd3d6d   2 days ago     212MB\n\n对这个docker命令进行解释\n\n-it -d，it提供交互能力，d代表后台运行\n--restart=always，始终重启docker（docker服务重启后，镜像会自动启动）\n-p 9000:9000，将docker内的9000端口（右侧）映射给宿主机（左侧）的9000端口，端口9001的映射同理。\n容器内9000端口是minio的api端口（用于S3协议操作）\n容器内9001端口是minio的web管理界面端口\n根据你的需要，修改冒号左侧的宿主机端口即可。\n\n\n-v /minio/data:/bitnami/minio/data，将docker内/bitnami/minio/data路径映射给主机/minio/data路径，主机上的路径（左侧）请自行修改；这个路径是bucket和minio配置文件的存储路径。\n两个-e设置的是环境变量，分别设置的是minio管理员的账户和管理员的密码。请注意，在这里配置了管理员用户名和密码后，进入minio管理系统的密码无法被修改。如果你的minio服务需要暴露在公网上，请一定要设置一个高强度的密码！\n-e TZ=&#39;Asia/Shanghai&#39; 设置时区为东八区（后续定时备份需要有正确时区）\n最后的bitnami/minio:latest代表我们需要创建bitnami/minio这个docker镜像的latest版本，如果本地没有这个镜像，则会自动去docker-hub拉取。\n如果你卡在了pull镜像的步骤，请自行百度如何替换docker的镜像源。\n\n如下是我在一个没有安装过minio的云服务上测试的结果，成功安装并启动minio\n[root:~/docker]# docker run -it -d --name minio \\&gt; -p 19000:9000 \\&gt; -p 19001:9001 \\&gt; --restart=always \\&gt; -v /root/docker/minio:/bitnami/minio/data \\&gt; -e MINIO_ROOT_USER=&quot;minio_root&quot; \\&gt; -e MINIO_ROOT_PASSWORD=&quot;minio_123456&quot; \\&gt; bitnami/minio:latestUnable to find image &#x27;bitnami/minio:latest&#x27; locallylatest: Pulling from bitnami/minioef5975039511: Pull complete Digest: sha256:3bb81d101dea57a5382a2d01eda6991e75ce69669d2d49c4646d82721b7c258eStatus: Downloaded newer image for bitnami/minio:latestafefbb9514de0f4a1c02b7f4212b1e05eee5ef342ed4ce27e03de10071914060\n\n容器正常启动，处于Running状态，STATUS正常！\nCONTAINER ID   IMAGE                                  COMMAND                  CREATED         STATUS         PORTS                                                                                      NAMESafefbb9514de   bitnami/minio:latest                   &quot;/opt/bitnami/script…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:19000-&gt;9000/tcp, :::19000-&gt;9000/tcp, 0.0.0.0:19001-&gt;9001/tcp, :::19001-&gt;9001/tcp   minio\n\n这样还不够，请在后续创建了bucket并上传测试文件后，查看本地映射的路径中是否有对应文件夹和文件，避免路径映射失败！（如果路径没有成功映射到本地，那么你当前创建的minio被删除之后，文件就很难找回来了）\n\n顺带一提，在我这边测试发现，如果你错误使用浏览器访问了9000这个api端口，会被自动重定向到9001 web管理页面端口（前提是映射的宿主机端口和docker内端口一致）\n\n2.3 web管理使用 http://IP:端口 打开minio的9001端口对应的宿主机端口，访问minio的web管理页面。输入刚刚创建容器时，在环境变量里面配置的用户名和密码进行登录，即可进入控制台。\n\nminio的界面比较简单，基本要做的操作只有两个，创建bucket存储桶，和accesskey用于api调用。\n\n更高阶的配置项和操作我没有尝试过，请自行参考minio的文档或者其他教程。\n\n2.3.1 创建bucket第一个界面就是大大的Object Browser，在这里我们可以创建存储桶\n\n点击创建bucket，会进入如下配置项，除了bucket的名字，还有三个选项\n\nVersioning：版本控制，开启后，该bucket将处于多版本模式下，文件会保留修改的历史记录。\nObject Locking：避免文件被删除，需要支持保留和合法保留（这两个啥意思我不明白），该选项只能在bucket创建时打开。\nQuota：限制容器中文件大小（总容量）\n\n对于我的备份需求来说，这三个额外选项都不需要，直接创建就行了\n\n创建之后，在bucket页面可以看到刚刚创建的test存储桶，这里会统计存储容量和文件数量\n\n2.3.2 创建accessKeyaccessKey是用于操作api的token凭证。创建完毕后，他只会显示一次，后续将不会显示出来。\n\n如果你不想创建太多个密钥，那就把这个密钥的文件下载下来，免得到时候不知道是什么了。点击右下角的import文件就可以下载，会下载一个json文件，内部包含密钥和其他一些相关信息\n\n因为我这只是做个测试，一会就会把这个minio的docker删除，所以展示密钥无所谓。如果你是在生产环境下使用，请一定不要暴露你的密钥给任何人。\n&#123;    &quot;url&quot;: &quot;http://公网IP:19001/api/v1/service-account-credentials&quot;,    &quot;accessKey&quot;: &quot;aXpBxrUceV30Id6gOouG&quot;,    &quot;secretKey&quot;: &quot;dIWl9IFL05UtaI08PZfPXE66zPGu2zWrGFfSTaUm&quot;,    &quot;api&quot;: &quot;s3v4&quot;,    &quot;path&quot;: &quot;auto&quot;&#125;\n\n\n密钥创建完毕，就能在列表看到它。\n\n3.rclone备份rclone是一个全平台的命令行工具，其可以用于多种云端&#x2F;本地存储之间的数据拷贝、同步、加密同步等功能。详见rclone官网：rclone.org\n因为我的目标就是我的七牛云bucket里面的图床文件备份到本地，rclone绝对是不二之选。\n3.1 进入docker容器内终端你可以选择在宿主机上安装rclone，也可以选择直接在minio的容器内安装rclone。但是需要注意，如果在minio的容器内安装，那么minio容器被删除后，rclone和它的配置文件自然也不在了。\n参考：以指定用户启动和进入docker容器 - langyong - 博客园 ，使用ssh链接宿主机，然后使用如下docker命令进入minio的容器终端中。\ndocker exec -it -u 用户名 容器名 /bin/bash# 示例如下docker exec -it -u root minio /bin/bash\n\n如果你使用的是绿联、极空间这类不太方便进入ssh的nas，可以在nas的docker管理页里面操作，如下图所示，选择/bin/bash后点击链接即可进入容器内终端。\n\n3.2 下载安装rclone进入终端后，默认所在路径是docker容器的工作路径/opt/bitnami/minio-client。\n为了避免影响容器运行，我们不要在工作路径里面做操作，请使用如下命令，创建一个新的rclone文件夹，进入root用户的家目录进行操作。\nmkdir /root/rclonecd /root/rclone\n\n\n你可以在创建minio容器的时候，就把/root/rclone路径给映射到宿主机上，方便后续查看rclone备份的日志。\n\n下载安装rclone的命令如下\ncurl -O https://downloads.rclone.org/rclone-current-linux-amd64.zipunzip rclone-current-linux-amd64.zipcd rclone-*-linux-amd64 sudo cp rclone /usr/bin/sudo chown root:root /usr/bin/rclonesudo chmod 755 /usr/bin/rclone\n\nminio的docker内没有unzip命令，需要安装一下\napt-get update &amp;&amp; apt-get install -y unzip\n\nminio的docker内也没有sudo，将上述安装命令中的sudo去掉就可以了。\n完成安装命令后，执行一下rclone，出现rclone命令的使用提示，那就是安装成功了！\nroot@878a0dd03ec4:/root/rclone/rclone-v1.65.0-linux-amd64# rcloneUsage:  rclone [flags]  rclone [command]  ...\n\n3.3 rclone对象存储配置rclone的官网上有不同云端存储协议和不同S3服务商的配置教程，跟着官方的来就可以了。\n执行rclone config命令，工具会自动在/.config/rclone/rclone.conf下创建一个config文件，你可以根据官方的向导，在此处添加新的remote;\nroot@878a0dd03ec4:/root/rclone/rclone-v1.65.0-linux-amd64# rclone config2023/12/14 04:38:44 NOTICE: Config file &quot;/.config/rclone/rclone.conf&quot; not found - using defaultsNo remotes found, make a new one?n) New remotes) Set configuration passwordq) Quit confign/s/q&gt; q\n\n下面给出minio和七牛云的配置文件，你可以直接修改这个配置文件中的内容为你的配置，然后写入/.config/rclone/rclone.conf即可。\n\nrclone.org&#x2F;s3&#x2F;#minio\nrclone.org&#x2F;s3&#x2F;#qiniu\n\n其中minio的region在minio的控制台里面可以修改，如果你没有修改过，默认使用的是us-east-1。因为rclone是直接在minio的docker里面执行的，所以endpoint只需要写成127.0.0.1和minio的api端口9000就可以了。\n如果你的minio在公网或者其他设备上，请修改对应的IP地址和端口。\n七牛云的region和endpoint在七牛云bucket页面找到S3域名就可以看到。\n\n\n请注意，七牛云&#x2F;阿里云这类存储服务商，如果你有多个bucket，且他们的地域不一样，则需要新增对应地域的配置项。通过修改[]里面的配置名进行区分。\n\n[minio]type = s3provider = Minioenv_auth = falseaccess_key_id = 控制台获取的key_idsecret_access_key = 控制台获取的secret_keyregion = us-east-1endpoint = http://127.0.0.1:9000location_constraint =server_side_encryption =[qiniu]type = s3provider = Qiniuaccess_key_id = 七牛云控制台获取key_idsecret_access_key = 七牛云控制台获取secret_keyregion = cn-east-1endpoint = s3-cn-east-1.qiniucs.comlocation_constraint = cn-east-1acl = privatestorage_class = STANDARD\n\n执行如下命令，安装nano编辑器，然后使用nano编辑器打开rclone配置文件进行编辑。\napt-get update &amp;&amp; apt-get install -y nanonano /.config/rclone/rclone.conf\n\nlinux下的粘贴命令是CTRL+SHIFT+V或CTRL+INSERT，你可以在本地修改了配置文件后，通过nano编辑器，直接粘贴到docker容器内。编辑完毕后，使用CTRL+X退出nano的编辑模式，并按Y确认保存，随后直接回车，即完成编辑。\n\n\n这个配置文件建议备份一个，免得每次都得重新弄\n3.4 rclone基本命令copy拷贝命令如下，配置名称是在config文件中[]里面的文字，桶名就是你的S3服务里面的对象存储桶，还可以在桶名后面用/来追加指定上传的路径。\nrclone copy 本地文件路径 配置名称:桶名rclone copy 本地文件路径 配置名称:桶名/桶内目录\n\n这里我在docker内创建了一个test.txt文件，尝试将其拷贝到minio里面。\ntouch test.txtrclone copy ./test.txt minio:1panel-bak\n\n命令没有错误输出，即拷贝成功！\nroot@878a0dd03ec4:/root/rclone# touch test.txtroot@878a0dd03ec4:/root/rclone# rclone copy ./test.txt minio:1panel-bakroot@878a0dd03ec4:/root/rclone# \n\n\n尝试在拷贝的时候指定远端仓库内的路径\nrclone copy ./test.txt minio:qiniu-muxue-sy/test\n\n成功指定，文件被上传到了test文件夹里面。\n\nsync备份命令如下，可以在任意目的地（本地-远端，远端-本地，远端-远端）里面执行这个命令，左侧是源路径，右侧是目标。\nrclone sync 本地源文件路径  目的地配置名称:桶名 rclone sync 源配置名称:桶名 目的地配置名称:桶名rclone sync 源配置名称:桶名 目的地的本地文件路径\n\nrclone sync有两个常用的选项，刚开始使用的时候，建议带上 --dry-run 命令来确认自己的配置没有问题\n\n-P 显示详细同步进度条\n--dry-run 用作命令测试，不会真正的执行同步\n\n指定-P命令后的进度输出如下，可以看到实时网速和文件数量&#x2F;大小。\n\n目前发现的问题是minio显示的文件总量和数据存储量会有一定滞后，刚开始我还以为是rclone没有跑完呢，sync完毕过了几分钟minio里面才刷出正确的文件数量来。\n3.5 cron定时同步部分nas品牌的系统（比如群晖）已经提供了执行定时脚本的功能，这种情况下直接使用系统提供的定时任务来执行rclone sync即可，无需额外安装其。\n\n群晖官网关于定时任务的说明： https://kb.synology.cn/zh-cn/DSM/help/DSM/AdminCenter/system_taskscheduler?version=6\n绿联nas的环境中已有crontab，但我没有试过使用它。考虑到绿联这个nas的系统还是一点都不稳定，还是别动它的系统里面的东西了，不知道绿联官方有没有可能把定时任务加到控制页里面去吧（我估计是没戏，这个系统的限制太多了）。\n\n在minio的docker里面直接安装crontab服务和nano文本编辑器\napt-get updateapt-get install -y cron nano\n\n安装完毕后，使用crontab -e看看是否能打开crontab的配置编辑页面，如果可以打开如下配置界面，则代表cron安装成功。\n\n这个配置文件需要写入的格式如下，一行对应一个配置。\n五位cron表达式 需要执行的命令\n\ncron表达式可以百度搜一下，因为很少用，我也不太了解cron表达式的编写逻辑。\n对于rclone的sync备份而言，写入如下内容即可；\n0 3 * * 1,5 rclone sync qiniu-e1:muxue-sy  minio:qiniu-muxue-sy &gt;&gt; /root/rclone/rclone-sy.log 2&gt;&amp;10 2 * * 1,5 rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone-img.log 2&gt;&amp;1\n\n解析如下\n\n0 3 * * 1,5 代表每周一和周五的凌晨3点执行一次\n0 2 * * 1,5 代表每周一和周五的凌晨2点执行一次\n&gt;&gt; /root/rclone/rclone-img.log 2&gt;&amp;1 代表将rclone命令的输出结果写入到 /root/rclone/rclone-img.log 文件中。\n\n写入完毕后，CTRL+X关闭nano编辑模式，按Y和回车即完成nano编辑。编辑完成后会有如下输出。\nroot@878a0dd03ec4:/root/rclone# crontab -eno crontab for root - using an empty onecrontab: installing new crontab\n\n后续crontab执行的命令结果都会输入到这两个指定的日志文件中。rclone命令只有在出现ERROR的时候才会输出。如果这个文件里面什么都么有，就代表运行没有出错！\n\n请注意，默认情况下，minio的docker是没有时区配置的，请一定要在创建docker容器的时候，使用TZ环境变量来设置时区，否则crontab不会执行！原因也很简单，cron表达式有一个指定时间，比如每周一执行、几点执行，如果没有配置时区，cron没有办法明确你的cron表达式到底应该什么时候跑，干脆就不跑了！\n\n如果你的docker已经创建，不想重新创建，可以通过修改配置文件来设置时区\nnano /etc/environment# 在文件末尾写入如下内容TZ=&#x27;Asia/Shanghai&#x27;\n\n\n配置好了之后，使用如下命令启动cron服务\nservice cron start\n\n执行效果如下\nroot@878a0dd03ec4:/root/rclone# service cron startStarting periodic command scheduler: cron.\n\n可以用如下命令查看cron服务状态\nroot@878a0dd03ec4:/root/rclone# service cron statuscron is running.\n优化日志为了让日志更加合理，可以在执行rclone命令之前，打印当前时间，这样可以知道crontab到底有没有正常执行定时任务。\n打印时间的基本命令如下，echo命令会将当前时间和相关的说明信息写入log.txt文件中\necho &quot;$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) This is a test command&quot; &gt;&gt; log.txt\n\n执行效果如下\nroot@878a0dd03ec4:/root/rclone# echo &quot;$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) This is a test command&quot; &gt;&gt; log.txtroot@878a0dd03ec4:/root/rclone# cat log.txt2023-12-14 03:44:32 This is a test command\n\n这里有另外一个问题，我创建docker的时候忘记指定TZ环境变量了，即docker内部的时区使用的是UTC标准时区，而不是东八区。使用如下命令，就可以让输出的日期变成东八区的时间。\n\n再次提醒，minio的docker内必须指定TZ环境变量，否则crontab不会执行！\n\necho &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) 这是东八区&quot; &gt;&gt; log.txt\n\n执行效果如下，命令直接粘贴到命令行里面，中文出现了乱码，不过文件里面的时间和中文都是正常的；这里只是做一个演示，实际执行的时候，建议使用全英文的echo输出，避免像这样的乱码问题。\nroot@878a0dd03ec4:/root/rclone# echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) \\350\\277\\231\\346\\230\\257\\344\\270\\234\\345\\205\\253\\345\\214\\272&quot; &gt;&gt; log.txtroot@878a0dd03ec4:/root/rclone# cat log.txt2023-12-14 11:45:31 这是东八区\n\n将如上的crontab命令改成如下形式，使用&amp;&amp;来链接echo和rclone命令，这样在每次执行rclone之前都会有一个当前时间和sync的是什么内容的的输出，能让我们知道crontab是否正常执行。\n0 3 * * 1,5 echo &quot;$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) sync muxue-sy&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e1:muxue-sy  minio:qiniu-muxue-sy &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;10 2 * * 1,5 echo &quot;$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) sync muxue-img&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1\n\n你可以修改cron表达式的前2位（对应的是分钟和小时），以及第五位的星期几，让crontab表达式立即执行一次，确认一下输出是否正确。\n\n每次修改配置文件后，都需要重启cron服务！\nservice cron restart\n\nThe end本文的教程结束，有问题欢迎在评论区提出。\n数据无价，多一份备份，多一份安心\n","categories":["docker真好玩"],"tags":["docker"]},{"title":"【Docker】用开源umami监控你的站点访问量","url":"/posts/910878902/","content":"新年到，祝大家兔年吉祥！🎉\n\n\n1.介绍umami是一个开源的站点访问量监看程序，其支持docker部署到自己的服务器上。相比较百度等收费的网站信息监看，这种方式对于小站长来说更加实惠一些\n2.docker安装的坑2.1 docker-compose以下是官方提供的yml文件，我只是将数据库docker的名字改成了umi-db，将3000端口映射给了本机的3010端口\nversion: &#x27;3&#x27;services:  umami:    image: ghcr.io/umami-software/umami:postgresql-latest    ports:      - &quot;3010:3000&quot;    environment:      DATABASE_URL: postgresql://umami:umami@umi-db:5432/umami      DATABASE_TYPE: postgresql      HASH_SALT: adsfadsfa23421313dfabadsf32rl    depends_on:      - umi-db    restart: always  umi-db:    image: postgres:12-alpine    environment:      POSTGRES_DB: umami      POSTGRES_USER: umami      POSTGRES_PASSWORD: umami    volumes:      - ./sql/schema.postgresql.sql:/docker-entrypoint-initdb.d/schema.postgresql.sql:ro      - umami-db-data:/var/lib/postgresql/data    restart: alwaysvolumes:  umami-db-data:\n\n写好文件后，使用docker-compose up -d命令，运行镜像。过一会再使用docker-compose ps，只要两个镜像都是正常运行状态，那就ok了\n2.2 坑这里有一个小🕳，那就是我们并不需要设置数据库的端口。在我的服务器上，5432端口已经被另外一个容器占领了，于是我就使用了下面的语法，想把数据库映射给5433端口\n备注：下面的这个是错误写法，umami容器会因为连不上数据库而一直重启！\nversion: &#x27;3&#x27;services:  umami:    image: ghcr.io/umami-software/umami:postgresql-latest    ports:      - &quot;3010:3000&quot;    environment:      DATABASE_URL: postgresql://umami:umami@umi-db:5433/umami      DATABASE_TYPE: postgresql      HASH_SALT: adsfadsfa23421313dfabadsf32rl    depends_on:      - umi-db    restart: always  umi-db:    image: postgres:12-alpine    environment:      POSTGRES_DB: umami      POSTGRES_USER: umami      POSTGRES_PASSWORD: umami    ports:      - &quot;5433:5432&quot;    volumes:      - ./sql/schema.postgresql.sql:/docker-entrypoint-initdb.d/schema.postgresql.sql:ro      - umami-db-data:/var/lib/postgresql/data    restart: alwaysvolumes:  umami-db-data:\n\n实际上并不需要这么操作，因为默认状态下，这个数据库的端口都没有映射到本机，并不会和已有的端口冲突！\nDATABASE_URL: postgresql://umami:umami@umi-db:5432/umami\n\n这里其实已经指定了，是使用umi-db容器内部的5432端口，并不是使用云服务器的5332端口，二者是不一样的。\n直接使用官方原有的docker-compose文件就没问题了！\n3.进入管理页面安装完毕后，使用云服务器ip:端口的方式访问，进入后台。\n默认用户名是admin，默认密码是umami，进入之后请立刻修改密码。\n3.1 修改中文点击右上角的头像，进入profile，设置语言为中文。\n\n3.2 添加站点随后在网站选项栏添加网站，填入你的站点url和名字\n\n3.3 添加到hexo博客上保存了之后，点击右侧的这个代码块图标，复制里面的代码\n\n到本地的hexo主题文件中，找到head文件，修改&lt;head&gt;处的代码，加入刚刚复制的代码\nkeep主题文件位置 themes\\keep\\layout\\_partial\\head.ejs\n\n重新部署博客即可，数据过几小时就会生效\n3.4 添加到wikijswiki js的管理页面，网站分析一栏就有umami\n\n填入你部署umami的服务器url和站点id即可，圈出来的部分就是网站id，并不是你在umami里面设置的站点名字\n\n","categories":["docker真好玩"],"tags":["Hexo","wikijs","Docker"]},{"title":"【nginx】Docker配置nginx，实现同服务器ip多站点多域名","url":"/posts/1994863894/","content":"Docker配置ngnix，实现同服务器ip，多域名映射多站点\n\n\n1.说明一般情况下，我们的域名映射到ip后，默认访问的是80端口。如果你的服务器只部署了一个服务，这样也是够用的。\n但是很多项目对性能的占用并没有那么夸张，一个服务器一个站点未免有些浪费了。虽然我们可以用域名:端口来访问，但是这样对于用户来说并不友好，对于强迫症来说看着很不舒服🤣\n这时候，就需要配置反向代理来实现不同域名到服务器不同端口的映射。\n1.1 反向代理你可以理解为，反向代理是服务器的一个中间商，其能将80端口的，不同域名来源的请求，导向到服务器上的不同端口\nwww.example.com 指向 8080端口aaa.example.com 指向 3000端口这两个域名都映射到服务器公网ip 114.514.8.8\n\n当你访问www.example.com时，请求的是114.514.8.8:80端口，也就是反向代理的服务。此时反向代理能知道你的来源是www.example.com，于是就把你带到了8080端口的服务上；\n同理，访问aaa.example.com时，就会被带到3000端口。\n\n这里用nginx作演示，nginx是最常用的反向代理服务\n2.docker安装nginx\n本文参考：https://www.jianshu.com/p/6b317192480c\n\n用其他方式还得整一大堆依赖项，这里直接用docker，方便又快捷;\n服务器安装docker的方式，根据你的系统，自行百度\ndocker pull nginx\n\n2.1 配置启动之前，先在你的当前路径下创建一个文件夹（我这里是root用户）\nmkdir /root/docker/ngnix\n\n随后用下面的命令启动nginx容器\ndocker run \\--name=ngx \\-p 80:80 -p 443:443 \\-v /root/docker/nginx/conf.d:/etc/nginx/conf.d \\-v /root/docker/nginx/cert:/etc/nginx/cert \\-d nginx\n\n对一些参数进行说明\n\n-p命令映射端口，将80端口映射给服务器的80端口（右侧容器端口，左侧本地端口\n-v命名映射目录，将本地的/root/nginx/conf.d映射到docker里面的/etc/nginx/conf.d 这是nginx的配置文件路径\n--name设置容器的名字，和镜像名字无关\n\n安装完成后，打开云服务器的ip，就能看到nginx的初始页面\n\n3.编辑配置文件nginx.conf 配置文件我们直接用官方默认的就行，这里主要对站点的配置文件做说明；\n3.1 https如果不需要https加密，可以用下面的配置文件来操作，当使用test.com访问你的云服务器ip时，会被转到4000端口\nserver &#123;    listen 80;  # 监听80端口    server_name test.com;  # 自己的域名    location / &#123;\t\t# 设置缓冲区大小\t\tproxy_buffer_size 64k;        proxy_buffers   32 32k;        proxy_busy_buffers_size 128k;        proxy_set_header HOST $host;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\t\t# 需要代理的地址:端口（因为是docker部署的，需要填公网ip）        proxy_pass http://IP:4000;    &#125;&#125;\n\n3.1.1 关于proxy_pass这里必须要注意一下proxy_pass\n因为我们的nginx是用docker部署的，此时你填 127.0.0.1或localhost，实际上访问的都是nginx这个docker内部的端口，是没有用的，会弹出502 gateway报错！\n正确的办法就是填云服务器的公网ip+端口\n3.2 https配置https如下，这样配置会将80端口的http访问强制转成https\n域名的证书可以在域名提供商里面申请，腾讯云支持申请单域名1年的免费证书。还可以去joyssl，申请90天的域名通配符证书\n因为在启动docker容器的时候，我配置了路径映射，证书配置的cert/对应的其实是 /root/docker/nginx/cert/目录，将证书文件放到该目录下即可\nserver &#123;    listen 443 ssl;    server_name img.text.top;  # 域名    # 注意文件位置，是从/etc/nginx/下开始算起的    ssl_certificate cert/img.text.top.crt; # 域名证书文件crt    ssl_certificate_key cert/img.text.top.key; # 域名证书key    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    client_max_body_size 1024m;    location / &#123;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header Host $host;        proxy_set_header Upgrade-Insecure-Requests 1;        proxy_set_header X-Forwarded-Proto https;        # 因为是docker部署的nginx，所以要填云服务器公网ip        proxy_pass http://云服务器公网IP:端口;    &#125;&#125;# 强制重定向server &#123;    listen 80; # 监听80端口    server_name img.text.top;  # 域名    #把http的域名请求转成https    return 301 https://$host$request_uri;&#125;\n\n修改配置文件后重启nginx的容器，即可正常访问\n\n更多：用portainer管理dockerportainer是一个图形化管理docker镜像和容器的项目，还是很不错的；缺点就是只有英文，想要中文可以配置中文包，但是中文包已经非常非常久没有更新了，索性直接用英文版\ndocker run -p 14730:9000 -p 14729:8000 --name portainer \\--restart=always \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /root/docker/portainer/data:/data \\-d portainer/portainer\n","categories":["docker真好玩"],"tags":["Linux","nginx","Docker"]},{"title":"【Python】教你白嫖replit部署kook-ticket-bot","url":"/posts/2556995516/","content":"教你白嫖replit部署kook的ticket机器人\n\n\n1.前言最近有不少老哥来找我咨询有关ticket机器人的事情，当前ticket机器人需要云服务器才能部署，有些不太友好（要钱啊！而且也不是人人都会安装python环境）\n所以在这里利用replit和uptimerobot两个平台，给大家介绍一个白嫖的方法，实现部署kook-ticket-bot\n\n该方法理论上支持所有使用khl.py框架编写的机器人！\n\n注意！replit上的免费仓库，默认是公开的，也就是所有人都能访问到你这个仓库里面的文件，包括bot的token和日志信息！若您的ticket-bot对数据私密性要求较高，请自购服务器或找开发者代为部署！\n2.准备2.1 注册账户这两个平台国内访问缓慢，如果实在进不去，就下载一个steam++(又称watt toolkit)\n\nhttps://gitee.com/rmbgame/SteamTools/releases/tag/2.8.6\n\n如图，下载exe就可以了\n\n安装打开以后，把这一堆无差别勾上，点一键加速，应该就ok了，访问会稍微快一点\n\n随后就是注册这两个平台的账户了，应该不需要教吧（doge）\n2.2 打开gitee&#x2F;github仓库\nhttps://gitee.com/musnow/Kook-Ticket-Bot/tree/main/code\nhttps://github.com/musnows/Kook-Ticket-Bot\n\n为了方便访问，我将ticket-bot在gitee也传了一份，大家打开仓库的code目录，准备拷贝代码。能使用github的，建议用GitHub（因为github的代码更加新）\n2.3 申请kook开发者\nhttps://developer.kookapp.cn/app/index\n\n到kook的开发者平台，加入官方频道申请承为开发者，获取创建bot的权限；有了权限之后，新建一个应用\n\n\n随后进入机器人页面，复制这里的token，先保存起来，后面要用（一会再来复制也行）\n\n进入邀请页面，给予机器人管理员权限（这样是为了方便，不然得钩一大堆）\n然后复制上面的邀请链接到浏览器，邀请机器人进入你的服务器\n\n\n3.开始部署3.1 创建repl来到replit，创建仓库\n\n选择python，然后给它取个名字\n\n创建之后进入这个项目\n\nimport from github会显示仓库不可用，所以只能手动操作了。\n3.2 添加代码文件进来之后是这样的页面，只有一个main.py，其他什么都无\n\n点击右侧shell，复制后，shift+ins粘贴如下命令，可一建拉取所有代码，并覆盖已有文件。（创建repl的时候一定要选择python，否则pip会无法运行）\ngit clone https://github.com/musnows/Kook-Ticket-Bot.git &amp;&amp; mv -b Kook-Ticket-Bot/* ./ &amp;&amp; mv -b Kook-Ticket-Bot/.[^.]* ./  &amp;&amp; rm -rf Kook-Ticket-Bot &amp;&amp; pip install -r requirements.txt\n\n\n如果如上命令不可用，则需要根据我仓库的代码，手动创建同名文件，并将代码复制进去：\n\ngithub的代码更加新，如果能打开github，请在github复制代码：https://github.com/musnows/Kook-Ticket-Bot\n实在打不开，再来gitee：https://gitee.com/musnow/Kook-Ticket-Bot/tree/main/code\n\n有一个简便办法，就是在github&#x2F;gitee的clone按钮中选择下载zip，然后将zip解压后，将文件夹上传上去，并把内部文件移动道根目录。\n\n\n3.3 添加配置文件如果你直接运行了，会出现如下报错，代表没有找到config/config.json文件。即没有找到机器人运行必要的配置文件。\n\n新版本的ticket机器人会自动创建log目录下的文件，但是config下的配置文件依旧需要您手动操作！\n接下来就是根据仓库的README添加各类配置文件，本文不重复README中已有内容。\nconfig/config.json # 机器人token配置config/TicketConf.json # ticket配置# 下面的文件机器人会自动创建，可以不弄log/TicketLog.json # ticket日志log/TicketMsgLog.json # 消息记录log/ColorID.json # 表情回应上角色\n\n先把如上的几个文件全部建立好，然后根据仓库的README往里面添加键值。新版本log目录下的文件，机器人会自动创建，可以不手动创建。主要配置config即可。\n3.3.1 开启kook开发者模式很多操作都需要复制ID，先在设置高级设置中开启开发者模式\n\n3.3.2 配置config下面给出一个TicketConf.json中需要配置的几项的样例\n\n\n在这里重申，添加了这两个角色id之后，必须要给予用户对应的角色（特别是腐竹）才能操作bot的命令，否则提示权限不足\n配置为文件添加完毕之后，应该是下面这样的\n\n3.4 开始运行\n新版本已经采用logging来替换print，不再需要手动配置logDup\n\n配置文件修改好后，就可以点击顶部的run，尝试运行bot了，变成下面的样子那就是在运行了\n\n3.4.1 安装包刚开始打印如果提示这个，代表没有找到对应的包\n\n先尝试在shell中输入如下命令\npip install -r requirements.txt\n\n如果出现了如图所示的安装页面，那就一切ok，安装好了再点击run就可以了\n\n如果不行。那就在工具tools里面选择packges，搜索khl.py\n\n\n如下提示，安装成功！\n\n3.4.2 时区问题\n新版本自带的.replit文件已经写入了这个配置\n\n运行还会有这个警告\n/home/runner/tk-dev/venv/lib/python3.10/site-packages/tzlocal/unix.py:183: UserWarning: Can not find any timezone configuration, defaulting to UTC.  warnings.warn(&quot;Can not find any timezone configuration, defaulting to UTC.&quot;)\n\n点击显示隐藏文件\n\n打开.replit文件，在如下位置添加一行（然而这个时区配置没有用）\n[env]TZ = &#x27;Asia/Shanghai&#x27;# ....\n\n再次运行，就不会有这个报错了\n3.4.3 运行成功在点击运行，出现如图所示的页面，那就是运行成功了！\n\n因为采用了webhook的链接，需要去后台填入callback url，填入后点击重试。如果没有红色字体报错，那就是成功了！\nreplit给的url/khl-wh\n\n\n如果不成功，先尝试在浏览器中访问此url，看看是否出现了405 Method Not Allowed，如果出现了，代表程序正常运行，多点击几次重试即可。这点在README里面也有说明\n\n现在进kook里面，先测试一下我们的bot是否在线\n\n测试通过！后台也打印出了日志\n\n3.5 uptimeRobot别急别急，虽然到这里已经ok了，但我们还有一个步骤要做！\n进入uptimeRobot，需要创建一个监控实例，来调用机器人的url，保证我们的bot不会因为replit的策略（5分钟不活跃就休眠）而下线过久。\n\n使用webhook连接，也是为了让kook发送报文给机器人的时候，让repl不休眠。\n理论上来说，只要你的服务器用户够多，发言活跃（每次发言，kook都会发送一条信息给机器人，不管是不是机器人的命令）是可以不用配置uptimerobot的。\n但是为了避免机器人在服务器不活跃的时候，无法收到kook的报文，而进入休眠态，还是建议大家按教程配置一下uptimerobot的监控\n\n\n点击add new monitor，选择http\n\n\n按如下所示填写\n\nname随便填个英文名\nurl填在replit复制的链接，后面加上/khl-wh\nintervel是单次监控的间隔，选择5分钟（低于5分钟得收费）\ntimeout默认30s不需要修改\n两个ssl取消勾选\n\n\n建议勾选上这个，在bot下线的时候，会向你的邮箱发送通知\n\n配置完毕，点击右下角的create\n\n这时候就会开始运行了！下方的pause可以暂停运行。\n\n如果你create完毕，发现是黑色的，那就点击一下start让他开始运行\n3.5.1 自建uptime-kuma由于免费的uptimerobot的监控最低只能选择5分钟，正好和replit的休眠时间相同，导致即便你设置了uptimerobot的ping，repl依旧有几率休眠。\n您可以选择在replit上面部署一个uptime-kuma，该项目可以自定义监控时间（无限制）；缺点就是这个repl也需要用请求来进行保活（不确定能否自己请求自己实现保活）\n\nreplit创建一个新的repl，在shell中输入如下命令，即可一键部署。详细内容参考该项目的README\ngit clone https://github.com/valetzx/uptimekumaonreplit &amp;&amp; mv -b uptimekumaonreplit/* ./ &amp;&amp; mv -b uptimekumaonreplit/.[^.]* ./ &amp;&amp; rm -rf *~ &amp;&amp; rm -rf uptimekumaonreplit\n\n\n温馨提示：replit的repl默认公开，若您部署了uptime-kuma，请不要把该服务的用户名&#x2F;密码设置成任何和您已有其他平台的用户名&#x2F;密码相同。\n建议拿张纸记录下一个随机字符串作为uptime-kuma的密码，避免您常用的密码泄露。\n\n本人已经部署了该服务，若您有repl保活需求，可以加入我的帮助服务器，将您的replit-url告知我。\n即：使用我部署的uptime-kuma来请求您的replit-url，实现保活！\n3.5.2 解决405错误导致的down在我replit部署机器人，使用uptimerobot的时候，遇到了下面的问题。我在uptimerobot里面填入了replit的url如下\nreplit给的url/khl-wh\n\n但由于免费版本的uptimerobot仅支持head请求，而/khl-wh路径是只支持post请求的。由此便引发了这个问题\n\n\n\n说来奇怪，我其他三个在replit上面用webhook部署的机器人并没有出现这个问题（理论上来说应该会出现才对）不管这个，有问题我们就解决问题\n\n\n解决办法如下，找到main.py，选中Bot，右键jump to definition，转到定义\n\n或者在左侧选择show hidden files，进入venv文件夹\n\n这时候便展开了隐藏的包文件，路径为\nvenv/lib/python3.10/site-packages/khl/bot/bot.py\n\n\n\n我们需要找的文件是\nvenv/lib/python3.10/site-packages/khl/receiver.py\n\n进去之后，找到大概180行的位置，有一个\nself.app.router.add_post(self.route, on_recv)\n\n复制如下代码替换原有，这个代码的作用是给/khl-wh添加get请求的支持，这样uptimerobot的head请求就不会报错了。\n修改的时候，一定要注意代码的缩进，要保证新的代码缩进和旧的代码缩进相同！否则可能导致意想不到的后果。\nasync def on_root(request: web.Request):    return web.Response(body=&quot;khl.py get recv!&quot;,                    content_type=&#x27;text/html&#x27;,status=200)self.app.router.add_post(self.route, on_recv)self.app.router.add_get(self.route, on_root)\n\n配置了之后，重新启动机器人，将url粘贴到浏览器，尝试访问\nreplit给的url/khl-wh\n\n这时候显示的就不再是405，而是khl.py get recv!了，表明代码修改正确！\n\n这时候去看看uptimerobot，它的请求就没有出错了！\n\n完美解决！\n4.下线机器人bot有一个特殊的kill命令。执行此kill命令，可以刷新缓冲区。\n避免出现数据在缓冲区中没有写入到文件，导致丢失日志or数据文件\n/kill @机器人\n\n\n如果你想退出bot，建议使用kill命令来操作！\n大功告成！现在你可以根据help去测试一下各类命令是否能正常工作啦\n\n\n\n注意，关闭ticket之后可能会出现这个报错，这是因为用户从来没有给bot发送过信息，导致bot无法用户发送私信，忽略此报错即可（新版本已经取消了这个报错）\n\n因为replit是免费的，所以bot的反应可能有些迟钝，正常情况！\n建议使用kook网页版进行测试，如果出现机器人不响应，先刷新一下网页。有很多时候纯粹是kook自己的客户端抽风导致命令消息看不到。\n再次提醒再次提醒！replit上的免费仓库，默认是公开的，也就是所有人都能访问到你这个仓库里面的文件，包括bot的token和日志信息！\n\n为了规避token泄漏造成过大影响，建议每隔一段时间就上后台重置token\n\n若您的ticket-bot对数据私密性要求较高，请自购服务器或找开发者代为部署！\n关于自购服务器相关事项，可加入帮助服务器咨询我，我可以帮助你配置服务器的Python基本环境\n\n\nPS：请不要误会，我不是卖服务器的，我也没有接广告😂\n\n","categories":["速通Python"],"tags":["Python","Kook"]},{"title":"【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo 'appstream' Cannot prepare internal mirrorlist | 转载","url":"/posts/1296728696/","content":"本站经常搬运一些其他博主文章，主要是为了持久化访问。避免日后他人删文or原文无法访问；所有搬运的文章都会写明原文地址，并且不会展示本站的copyright_info\n\n\n下文所出现的场景，是我在linux上使用docker安装centos容器时出现的！\n\n✨在学习使用 docker 技术过程中，基于 centos 镜像自定义新的镜像，其中基础镜像 centos 需要提前安装好 vim 和 net-tools，然而在刚开始通过 yum -y install vim 安装 vim 时，便出现了错误提示信息：\nError: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist\n\n✨上面的报错信息意思是，从仓库 ‘appstream’ 下载元数据失败：由于镜像列表中没有 URL，不能准备内部镜像列表。\n🥎问题分析：\n✨第一种可能的情况便是网络连接问题。检查是否可以连接外部网络，可以使用 ping baidu.com 查看是否有丢包情况。如果丢包，则进一步检查网络连接是否正常；如果没有丢包，继续阅读下文\n✨那么第二种情况，便是 CentOS 已经停止维护的问题。2020 年 12 月 8 号，CentOS 官方宣布了停止维护 CentOS Linux 的计划，并推出了 CentOS Stream 项目，CentOS Linux 8 作为 RHEL 8 的复刻版本，生命周期缩短，于 2021 年 12 月 31 日停止更新并停止维护（EOL），\n更多的信息可以查看 CentOS 官方公告。如果需要更新 CentOS，需要将镜像从 mirror.centos.org 更改为 vault.centos.org\n\n🥎那么针对上面提到的第二种情况，给出的解决方法如下：\n🔔 首先，进入到 yum 的 repos 目录\ncd /etc/yum.repos.d/\n\n🔔其次，修改 centos 文件内容\nsed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*\n\n🔔 然后，生成缓存更新（第一次更新，速度稍微有点慢，耐心等待两分钟左右）\nyum clean allyum makecache\n\n🔔 最后，运行 yum update 并重新安装 vim\nyum update -yyum -y install vim\n\n🎉至此，针对第二种情况出现的问题成功解决！\n原文作者：ReadThroughLife原文地址：https://blog.csdn.net/weixin_43252521/article/details/124409151\n\n","categories":["docker真好玩"],"tags":["CentOS","Docker"]},{"title":"【Vercel】教你部署imsyy/home个人主页","url":"/posts/951011662/","content":"本篇博客教你如何部署一个自己的个人主页\n项目地址：https://github.com/imsyy/home\n\n\n1.fork仓库+vercel部署首先我们点击fork，将仓库复刻到自己的账户\n\n随后进入vercel，点击dashboard-add new-project\n\n选择你复刻的仓库\n\n然后什么都不用改，直接deploy\n\n等待部署成功，点击domains，在这里添加个你自己的域名+解析。否则vercel默认的域名无法直接访问\n\n到这里就已经部署成功了，可以不用管vercel了；\n克隆下我们fork的仓库，接下来就是修改配置文件！\n\n备注，env中已有的配置在这里不提\n\n1.1 本地预览本地预览需要我们在本地安装好node.js环境以及npm包管理器，随后安装yarn\nnpm install yarn\n\n安装完成后，进入项目所在文件夹，先执行yarn install安装依赖项。\nyarn install\n\n\n如果下载依赖的时候卡在其中某一个了，可能是网络问题，可以尝试给npm&#x2F;yarn的下载器配置镜像源【参考博客】\n\n依赖项搞定了，用dev查看预览页面\nyarn dev\n\n注意，第一次查看预览页面的时候，加载会非常慢，这是正常情况\nVITE v3.1.8  ready in 844 ms➜  Local:   http://127.0.0.1:3000/➜  Network: use --host to expose\n\n后续的修改，可以先在本地预览成功后，再部署到vercel\n\n1.2 部署到云服务器如果你想部署到云服务器，则使用\nyarn build\n\n会生成一个dist文件夹，弄到云服务器上就可以了（不会用，没试过）\n1.3 vercel访问问题如果根据上面的步骤设置了解析后，还是出现访问缓慢甚至无法访问的问题，可以将域名的A或者cname解析更改为下面的国内访问较快的解析\n76.223.126.88cname-china.vercel-dns.com\n\n下图是vercel官方对于此问题的说明，需要我们修改指向vercel的dns记录\n\n2.社交链接这里光是修改.env是不够的，因为作者暂时还没有写社交链接的判断，即便你把所有社交链接的环境变量都注释掉，他还是会显示出来\n这里需要我们修改代码，不算难，一步一步来就行\nsrc\\components\\SocialLinks\\index.vue\n\n打开这个文件，最顶部是&lt;/template&gt;包裹的一个div\n&lt;template&gt;  &lt;!-- 社交链接 --&gt;  &lt;div class=&quot;social&quot;&gt;  ....  &lt;/div&gt;&lt;/template&gt;\n\n我们需要修改的就是这里面的代码\n2.1 注释掉不需要的比如下面这一个&lt;a &lt;/a&gt; 包裹的就是tg的社交链接。如果你不需要，那就直接把它注释掉\n&lt;!-- &lt;a   id=&quot;telegram&quot;   :href=&quot;socialLinks.telegram&quot;   target=&quot;_blank&quot;   @mouseenter=&quot;changeTip&quot;   @mouseleave=&quot;leaveTip&quot;   &gt;    &lt;Icon size=&quot;24&quot;&gt;        &lt;Telegram /&gt;    &lt;/Icon&gt;&lt;/a&gt; --&gt;\n\n2.2 增加没有的社交链接根据上面这个模板的格式，我们可以新增自己需要的社交链接，比如我就新增了一个gitee的链接。需要修改的只有id和icon里面的图标名字GitSquare\n&lt;a  id=&quot;gitee&quot;  :href=&quot;socialLinks.gitee&quot;  target=&quot;_blank&quot;  @mouseenter=&quot;changeTip&quot;  @mouseleave=&quot;leaveTip&quot;&gt;  &lt;Icon size=&quot;24&quot;&gt;    &lt;GitSquare /&gt;  &lt;/Icon&gt;&lt;/a&gt;\n\n这里的Icon图标都是从一个本地文件导入的，文件路径为\nnode_modules\\@vicons\\fa\\es\\index.d.ts\n\n你可以在这里面搜索已有的图标名字，并回到社交链接的 src\\components\\SocialLinks\\index.vue 文件，修改如图所示的代码，新增图标（必须要在这里新增， 再去html里面引用）\nimport &#123; Github, Qq, Telegram, Twitter,GitSquare &#125; from &quot;@vicons/fa&quot;;\n\n\n最后，在TipData中新增一个点击会显示的文字，这里的id要和上面写的一样\nlet socialTipData = &#123;  github: &quot;去 Github 看看&quot;,  gitee: &quot;去 Gitee 看看&quot;,  qq: &quot;有什么事吗&quot;,  email: &quot;来封 Email&quot;,  telegram: &quot;你懂的 ~&quot;,  twitter: &quot;你懂的 ~&quot;,&#125;;\n\n在社交链接的地址里面，新增gitee的地址，参考已有的github的地址的写法\nconst socialLinks = reactive(&#123;  github: &quot;https://github.com/&quot; + import.meta.env.VITE_SOCIAL_GITHUB,  gitee: &quot;https://gitee.com/&quot; + import.meta.env.VITE_SOCIAL_GITEE,  ...\n\n最后，还需要在鼠标移入移出事件中，新增一个case，照着已有的抄就行\ncase &quot;gitee&quot;:  socialTip.value = socialTipData.gitee;  return true;\n\n最后的最后，回到.env环境变量，新增一个VITE_SOCIAL_GITEE，填写你的gitee用户名\nVITE_SOCIAL_GITEE = &quot;musnow&quot;\n\n搞定啦！\n\n2.3 添加没有的icon如果一个图标在本地路径没有，可以试着用下面的办法导入一个本地图片，或者是图片url\n本地图片的存储路径为public/images/\n&lt;a  id=&quot;gitee&quot;  :href=&quot;socialLinks.gitee&quot;  target=&quot;_blank&quot;  @mouseenter=&quot;changeTip&quot;  @mouseleave=&quot;leaveTip&quot;&gt;  &lt;img    src=&quot;/images/icon/gitee.png&quot; height=&quot;24&quot;  /&gt;&lt;/a&gt;\n\n但是上面这样弄会有边距问题，可以看到gitee和qq之间的边距比右侧更短，暂时没找到解决办法\n\n嗨嗨嗨，经过半小时的折腾，我找到解决办法了。在本地yarn dev中f12找到如下的代码，这里要做的就是看其他图标的代码是怎么写的\n\n这里能看到，他们都用了一个span的xicon class，我们要做的，就是给这个img也加上一个xicon\n&lt;a  id=&quot;gitee&quot;  :href=&quot;socialLinks.gitee&quot;  target=&quot;_blank&quot;  @mouseenter=&quot;changeTip&quot;  @mouseleave=&quot;leaveTip&quot;&gt;  &lt;span class=&quot;xicon&quot; style=&quot;font-size: 24px;&quot;&gt;    &lt;img src=&quot;/images/icon/gitee.png&quot; height=&quot;24&quot;/&gt;  &lt;/span&gt;&lt;/a&gt;\n\n现在就OK了！\n\n2.4 添加env判断，若为空不显示作者写的版本是写死的，即便你的env里面没有那个社交链接，他还是会展示在主页上。我的需求就是如果env里面没有这个社交链接/为空，那就不展示这个社交链接的图标\n# 社交链接VITE_SOCIAL_GITHUB = &quot;musnows&quot;VITE_SOCIAL_GITEE = &quot;musnow&quot;VITE_SOCIAL_QQ = &quot;&quot;VITE_SOCIAL_EMAIL = &quot;&quot;VITE_SOCIAL_TELEGRAM = &quot;&quot;\n\n比如我个人的需求就不需要后面的3个，那就把环境变量设置为空，且自动不展示\n这时候要做的就是修改代码，添加一个判断语句（我没学过前端，百度到的）\n先在社交链接的文件里面，添加下面这个变量定义（可以理解为他就是一个类，通过类名.变量的方式访问）\nlet socialEnv = &#123;  github: import.meta.env.VITE_SOCIAL_GITHUB,  gitee: import.meta.env.VITE_SOCIAL_GITEE,  kook: import.meta.env.VITE_SOCIAL_KOOK,  qq: import.meta.env.VITE_SOCIAL_QQ,  email: import.meta.env.VITE_SOCIAL_EMAIL,  telegram: import.meta.env.VITE_SOCIAL_TELEGRAM,  twitter: import.meta.env.VITE_SOCIAL_TWITTER,  travellings: import.meta.env.VITE_SOCIAL_TRAVELLINGS,&#125;\n\n随后要做的，就是在最上面的div class=&quot;link&quot;里面添加一个判断语句（需要给每一项都添加，注意名字别搞混了）\n&lt;span v-if=&quot;socialEnv.twitter&quot;&gt;  &lt;a    id=&quot;twitter&quot;    :href=&quot;socialLinks.twitter&quot;    target=&quot;_blank&quot;    @mouseenter=&quot;changeTip&quot;    @mouseleave=&quot;leaveTip&quot;  &gt;    &lt;Icon size=&quot;24&quot;&gt;      &lt;Twitter /&gt;    &lt;/Icon&gt;  &lt;/a&gt;&lt;/span&gt;\n\n这时候，就会自动判断这个环境变量是不是为空，如果为空那就不显示\n\n测试一下VITE_SOCIAL_GITHUB = &quot;musnows&quot;VITE_SOCIAL_GITEE = &quot;musnow&quot;VITE_SOCIAL_KOOK = &quot;https://kook.top/gpbTwZ&quot;VITE_SOCIAL_QQ = &quot;&quot;VITE_SOCIAL_EMAIL = &quot;&quot;VITE_SOCIAL_TELEGRAM = &quot;&quot;VITE_SOCIAL_TWITTER = &quot;&quot;VITE_SOCIAL_TRAVELLINGS = &quot;https://www.travellings.cn/go.html&quot;\n\n\nVITE_SOCIAL_GITHUB = &quot;&quot;VITE_SOCIAL_GITEE = &quot;musnow&quot;VITE_SOCIAL_KOOK = &quot;https://kook.top/gpbTwZ&quot;VITE_SOCIAL_QQ = &quot;111&quot;VITE_SOCIAL_EMAIL = &quot;&quot;VITE_SOCIAL_TELEGRAM = &quot;&quot;VITE_SOCIAL_TWITTER = &quot;&quot;VITE_SOCIAL_TRAVELLINGS = &quot;https://www.travellings.cn/go.html&quot;\n\n\n完美达成目标！\n变量复用可以把原本的socialLinks改成使用socialEnv，避免两个都是import，太长了不好看\nlet socialEnv = &#123;  github: import.meta.env.VITE_SOCIAL_GITHUB,  gitee: import.meta.env.VITE_SOCIAL_GITEE,  kook: import.meta.env.VITE_SOCIAL_KOOK,  qq: import.meta.env.VITE_SOCIAL_QQ,  email: import.meta.env.VITE_SOCIAL_EMAIL,  telegram: import.meta.env.VITE_SOCIAL_TELEGRAM,  twitter: import.meta.env.VITE_SOCIAL_TWITTER,  travellings: import.meta.env.VITE_SOCIAL_TRAVELLINGS,&#125;// 社交链接地址const socialLinks = reactive(&#123;  github: &quot;https://github.com/&quot; + socialEnv.github,  gitee: &quot;https://gitee.com/&quot; + socialEnv.gitee,  kook: socialEnv.kook,  qq: &quot;https://wpa.qq.com/msgrd?v=3&amp;uin=&quot; +    socialEnv.qq +    &quot;&amp;site=qq&amp;menu=yes&quot;,  email: &quot;mailto:&quot; + socialEnv.email,  telegram: &quot;https://t.me/&quot; + socialEnv.telegram,  twitter: &quot;https://twitter.com/&quot; + socialEnv.twitter,  travellings: socialEnv.travellings,&#125;);\n\n3.站点首页文字字体\nhttps://github.com/imsyy/home/issues/49\n\n如果你修改了站点首页的文字，会发现一部分文字没办法正常显示\n\n根据作者在issue里面提供的链接，下载了完整的字体文件\nhttps://file.4everland.app/font/Other/Pacifico-Regular.ttf如果上面的链接坏了，可以去我的仓库里面下https://github.com/musnows/musnows/blob/main/Pacifico-Regular.ttf\n\n将其粘贴到以下路径，覆盖原本的字体文件\npublic/font\n\n现在就Ok了\n\n4.网站logo配置4.1 浏览器顶部图标修改index.html中的如下字段\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://s1.hdslb.com/bfs/static/jinkela/long/font/regular.css&quot; /&gt;&lt;link rel=&quot;icon&quot; href=&quot;/images/icon/myPNG.jpg&quot;&gt;&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/images/icon/myPNG-r.jpg&quot;&gt;\n\n将你自己的logo图标放到public/images下即可。这里修改的是浏览器顶部的图标\n4.2 主页图标主页图标的路径如下\nsrc/components/Message/index.vue\n\n里面有注释，找到字段修改即可\n&lt;!-- Logo --&gt;&lt;div class=&quot;logo&quot;&gt;  &lt;img class=&quot;logo-img&quot; src=&quot;/images/icon/logo.png&quot; alt=&quot;logo&quot; /&gt;  &lt;div class=&quot;name&quot;&gt;    &lt;span class=&quot;bg&quot;&gt;&#123;&#123; siteUrl[0] &#125;&#125;&lt;/span&gt;    &lt;span class=&quot;sm&quot;&gt;.&#123;&#123; siteUrl[1] &#125;&#125;&lt;/span&gt;  &lt;/div&gt;&lt;/div&gt;\n\n5.网站链接配置在环境变量.env中写明了配置网站的位置\n# 网站链接## 请在 src/components/Links/index.vue 中设置\n\n首先是这里的图标，还是在老位置node_modules\\@vicons\\fa\\es\\index.d.ts，找你需要的图标导入\nimport &#123;  Link,  Blog,  CompactDisc,  Cloud,  Compass,  Book,  Flask,  GitSquare,  Image,  GitAlt&#125; from &quot;@vicons/fa&quot;;\n\n随后网站链接就照着抄，起一个新的就可以了\n&#123;  icon: Compass,  name: &quot;起始页&quot;,  link: &quot;https://nav.imsyy.top/&quot;,&#125;,\n\n建议链接不超过6个，不然就会变成下面这样\n\n6.footer配置src\\components\\Footer\\index.vue\n\n在页脚配置网站用户和链接，修改如下字段\n&lt;span  &gt;Copyright&amp;nbsp;&amp;copy;&amp;nbsp;&#123;&#123; fullYear &#125;&#125;  &lt;a href=&quot;链接&quot;&gt;名字&lt;/a&gt;&lt;/span&gt;\n\n如果你的站点经过了备案，修改如下字段\n&lt;a href=&quot;https://beian.miit.gov.cn&quot; target=&quot;_blank&quot;  &gt;豫ICP备2022018134号-1&lt;/a&gt;\n\n如果没有备案，可以把这部分注释掉\n7.音乐播放器配置这部分可能有老哥不太清楚，我顺便说一下吧!\n在环境变量里面，修改最底部的播放id就可以了\n# 歌曲 API 地址## 备用：https://api.wuenci.com/meting/api/VITE_SONG_API = &quot;https://api-meting.imsyy.top&quot;# 歌曲服务器 ( netease-网易云, tencent-qq音乐 )VITE_SONG_SERVER = &quot;netease&quot;# 播放类型 ( song-歌曲, playlist-播放列表, album-专辑, search-搜索, artist-艺术家 )VITE_SONG_TYPE = &quot;playlist&quot;# 播放 IDVITE_SONG_ID = &quot;2893005411&quot;\n\nid在哪儿找？登陆你的网页版网易云&#x2F;QQ音乐，找到一个歌单\n\n此处网页链接里面的ID就是播放id，复制过来就OK了\nhttps://music.163.com/#/playlist?id=2024518101ID是2024518101\n\n8.背景图设置src/components/store/index.vue\n\n这里有不少配置项，其中关于壁纸种类有3中\nstate: () =&gt; &#123;    return &#123;        innerWidth: null, // 当前窗口宽度        coverType: &quot;0&quot;, // 壁纸种类        musicIsOk: false, // 音乐是否加载完成        musicVolume: 0, // 音乐音量;        musicOpenState: false, // 音乐面板开启状态        backgroundShow: false, // 壁纸展示状态        boxOpenState: false, // 盒子开启状态        mobileOpenState: true, // 移动端开启状态        mobileFuncState: false, // 移动端功能区开启状态        setOpenState: false, // 设置页面开启状态        playerState: false, // 当前播放状态        playerTitle: null, // 当前播放歌曲名        playerArtist: null, // 当前播放歌手名        playerLrc: &quot;歌词加载中&quot;, // 当前播放歌词    &#125;&#125;,\n\n可以在backgound里面找到壁纸3个种类的不同：0是本地壁纸，随机1到10（可以在本地新增你喜欢的壁纸，并修改这里的随机数范围）\n0是默认的几张本地壁纸，1是bing，2是随机风景，3是随机二刺螈👻\n&lt;el-radio label=&quot;0&quot; size=&quot;large&quot; border&gt;默认壁纸&lt;/el-radio&gt;&lt;el-radio label=&quot;1&quot; size=&quot;large&quot; border&gt;每日一图&lt;/el-radio&gt;&lt;el-radio label=&quot;2&quot; size=&quot;large&quot; border&gt;随机风景&lt;/el-radio&gt;&lt;el-radio label=&quot;3&quot; size=&quot;large&quot; border&gt;随机动漫&lt;/el-radio&gt;\n\n咳咳，才发现原来背景图可以在前端直接设置呀？点击左侧留言，再点击时间胶囊右侧的设置按钮。不过目前只能设置这一个内容，而且这个设置随着网页刷新会被覆盖掉，建议在后端设置好默认的壁纸\n\n9.时间胶囊增加站点运行时间点击左侧的网站介绍（就是社交链接上面那个面板）能打开时间胶囊。默认显示的信息挺不错的，但是还空了一块，这不得把站点运行时间给加上？\n\n参考 https://blog.csdn.net/jay_chou345/article/details/110201897\n\n将这一串代码添加到src/components/TimeCapsule的&lt;script setup&gt;和&lt;/script&gt;之间\n// 站点存活时间let runTime = &#123;  year: import.meta.env.VITE_SITE_YAER,  month: import.meta.env.VITE_SITE_MONTH,  day: import.meta.env.VITE_SITE_DAY,&#125;function secondToDate(second) &#123;  if (!second) &#123;      return 0;  &#125;  var time = new Array(0, 0, 0, 0, 0);  if (second &gt;= 365 * 24 * 3600) &#123;      time[0] = parseInt(second / (365 * 24 * 3600));      second %= 365 * 24 * 3600;  &#125;  if (second &gt;= 24 * 3600) &#123;      time[1] = parseInt(second / (24 * 3600));      second %= 24 * 3600;  &#125;  if (second &gt;= 3600) &#123;      time[2] = parseInt(second / 3600);      second %= 3600;  &#125;  if (second &gt;= 60) &#123;      time[3] = parseInt(second / 60);      second %= 60;  &#125;  if (second &gt; 0) &#123;      time[4] = second;  &#125;  return time;&#125;function setTime() &#123;  //month要少一个月，不然会出问题。即month的范围为 0-11  var create_time = Math.round(new Date(Date.UTC(runTime.year, runTime.month,runTime.day, 0, 0, 0)).getTime() / 1000);  var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000);  var currentTime = secondToDate((  timestamp-create_time));  var currentTimeHtml = currentTime[0] + &#x27; 年 &#x27; + currentTime[1] + &#x27; 天 &#x27;      + currentTime[2] + &#x27; 时 &#x27; + currentTime[3] + &#x27; 分 &#x27; + currentTime[4]      + &#x27; 秒&#x27;;  if(document.getElementById(&quot;htmer_time&quot;)!=null)      document.getElementById(&quot;htmer_time&quot;).innerHTML = &quot;本站已经苟活 &quot;+currentTimeHtml;&#125;// 即时刷新站点存活时间setInterval(setTime, 1000);\n\n随后在顶部的模板末尾的&lt;/div&gt;前添加如下代码\n&lt;span class=&quot;text&quot;&gt;  &lt;p id=&quot;htmer_time&quot;&gt;&lt;/p&gt;&lt;/span&gt;\n\n环境变量.env中添加如下字段\n# 站点运行时间（显示在时间胶囊中）## 注意：月份的范围是0-11，否则会有bugVITE_SITE_YAER = 2023VITE_SITE_MONTH = 0VITE_SITE_DAY  = 1\n\n这样就OK啦！\n\n当我开了一个pull request后，源项目作者提供了一个更简单的代码版本。该版本更加精简，但是不能显示秒数，不过完全够用了！\n\nhttps://github.com/imsyy/home/pull/63\n\n环境变量\nVITE_SITE_START = &quot;2020-10-24&quot;\n\nvue中代码\n&lt;span class=&quot;text&quot;&gt;    &lt;p id=&quot;htmer_time&quot;&gt;&#123;&#123; startDateText &#125;&#125;&lt;/p&gt;&lt;/span&gt;\n\nlet startDate = ref(import.meta.env.VITE_SITE_START);let startDateText = ref(null);// 建站日期统计函数const siteDateStatistics = (startDate) =&gt; &#123;    const currentDate = new Date();    const differenceInTime = currentDate.getTime() - startDate.getTime();    const differenceInDays = differenceInTime / (1000 * 3600 * 24);    const differenceInMonths = differenceInDays / 30;    const differenceInYears = differenceInMonths / 12;    if (differenceInYears &gt;= 1) &#123;        return `本站已经苟活了 $&#123;Math.floor(differenceInYears)&#125; 年 $&#123;Math.floor(differenceInMonths % 12)&#125; 月 $&#123;Math.round(differenceInDays % 30)&#125; 天`;    &#125; else if (differenceInMonths &gt;= 1) &#123;        return `本站已经苟活了 $&#123;Math.floor(differenceInMonths)&#125; 月 $&#123;Math.round(differenceInDays % 30)&#125; 天`;    &#125; else &#123;        return `本站已经苟活了 $&#123;Math.round(differenceInDays)&#125; 天`;    &#125;&#125;onMounted(() =&gt; &#123;    startDateText.value = siteDateStatistics(new Date(startDate.value));&#125;);\n\n\n\n10.关闭新春灯笼春节假期结束辣！我们首页的新春灯笼也要取下来了\n找到App.vue,注释掉里面的import\n// 新春灯笼// import &quot;@/utils/lantern.js&quot;;\n\n\nMore…有任何问题，欢迎评论提问\n","categories":["docker真好玩"],"tags":["git","Hexo","vercel"]},{"title":"【Docker】配置lsky pro兰空图床","url":"/posts/370869610/","content":"Docker 部署 lsky pro 兰空图床的教程\n\n\n1.使用Docker部署1.1 命令行命令比较简单，用下面的即可\ndocker run -d \\--name lsky \\-p 14728:80 \\-v /root/docker/lsky:/var/www/html \\halcyonazure/lsky-pro-docker:latest\n\n\n--name 设置容器名字为 lsky\n-p 设置端口隐射，容器的80端口映射给本地的14728端口\n-v 设置存储映射，本地的/root/docker/lsky 映射给 /var/www/html\n\n完成后，进入IP:14728 即可打开你的图床页面\n\n此命令在CentOS7.2云服务器上测试有效，但在我的nas上测试无效\n\n230517更新，当时写这篇博客的时候，使用的是旧版本的容器。目前新版本的容器已经切换了内部端口为8089，所以新版本的命令如下\ndocker run -d \\--name lsky \\-p 14728:8089 \\-v /root/docker/lsky:/var/www/html \\halcyonazure/lsky-pro-docker:latest\n\n这也是为什么当初我写下了“在nas上测试无效”的记录。容器内部端口并不是80\n2.初始化新用户直接用sqlite即可，如果对性能有更高要求，建议使用mysql。\n\n因为我就是给自己作图床而已，对mysql的认知近乎为0，所以直接用sqlite方便多了。\n\n后续打开主页面就能上传文件了\n2.1 设置管理员用户总容量首先当然是进入用户组设置，把自己这个管理员用户的总容量改成5gb（默认500mb）\n\n在系统设置里可以改用户的初始容量，看你的情况要不要增加\n\n2.2 新建角色组其次，可以在角色组里面新增一个管理员组，设置一下单图大小限制（默认5mb）以及每天&#x2F;每周&#x2F;每月的图片上传数量限制；同时，在角色组这里还可以修改命名格式\n\n个人建议去掉路径命名中的日期，这样能一定程度上的避免同一图片的二次存储。\n\n如果你上传了两个完全一样的图片，在我的图片里面会显示两个，但是只会有一个本地文件。\n\n文件的命名除了随机字符串，还可以选择md5、时间戳命名\n\n2.3 设置阿里云OSS为存储这部分很简单，照着标识的填就行了。个人还是选择了本地存储的方式（阿里云OSS批量导出数据很麻烦）\n\n填了之后，上传的图片会直接返回阿里云OSS的链接\n2.4 权限问题如果你有一些本地的图片，想添加到lsky图床的根目录方便访问的话，就需要配置一下目录的图片\n举个例子，我有一图片的压缩包，我想将其放入lsky的stroage/app的my文件夹里面，那么创建这个文件夹的时候，就需要修改它的权限\nchown 33:tape my # 配置my文件夹的用户和用户组# 33和tape是docker配置lsky的默认用户名和用户组\n\n否则lsky图床没有办法正确读取或者往这个目录写入，从而导致上传错误\n3.https访问3.1 修改代码参考 https://github.com/lsky-org/lsky-pro/issues/321\n需要添加代码，docker用下面的方式添加后重启即可\ndocker exec -it 容器名字 sed -i &#x27;32 a \\\\\\Illuminate\\\\Support\\\\Facades\\\\URL::forceScheme(&#x27;&quot;&#x27;&quot;&#x27;https&#x27;&quot;&#x27;&quot;&#x27;);&#x27; /var/www/html/app/Providers/AppServiceProvider.php\n\n个人感觉，该issue已经提出了将近一年，lsky还是不支持在前端后台或者配置文件中直接配置https，实在有点不太应该。或许维护者是认为该修改代码的操作并不困难，就没有写入配置文件中。\n不过这只是鸡蛋里挑骨头，lsky整体还是非常好用的\n3.2 nginx配置安装nginx，可以参考我的 nginx安装博客\nserver &#123;    listen 443 ssl;    server_name img.text.top;  # 域名    # 注意文件位置，是从/etc/nginx/下开始算起的    ssl_certificate cert/img.text.top.crt; # 域名证书文件crt    ssl_certificate_key cert/img.text.top.key; # 域名证书key    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    client_max_body_size 1024m;    location / &#123;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header Host $host;        proxy_set_header Upgrade-Insecure-Requests 1;        proxy_set_header X-Forwarded-Proto https;        # 因为是docker部署的nginx，所以要填云服务器公网ip        proxy_pass http://云服务器公网IP:端口;    &#125;&#125;# 强制重定向server &#123;    listen 80; # 监听80端口    server_name img.text.top;  # 域名    #把http的域名请求转成https    return 301 https://$host$request_uri;&#125;\n\n写入配置文件后，重启nginx容器，并将域名的解析设置成你云服务器的公网ip，即可以用img.text.top或img1.text.top访问你的lsky图床\n3.2.1 http重写为https注意，默认情况下，lsky的所有文件加载都会走http，即便你打开了https://img.musnow.top，那些css和js的资源还是走了http://img.musnow.top，这种混合http和https的加载容易被浏览器拦截，导致lsky图床的界面显示的乱七八糟。\n\n\n所以nginx配置文件的location中，一定要加上如下配置项，相当于将http重写为https\nproxy_set_header Upgrade-Insecure-Requests 1;\n\n如果你像我一样使用了1panel来管理站点，此时openresty（1panel用的就是这个）的安装路径如下\n/opt/1panel/apps/openresty/openRestry/www/sites/\n\n在这里面你可以看到你配置好的站点（文件夹名字都是域名）\n进入你想修改的域名站点中，可以看到下面几个文件夹\nindex  log  proxy  ssl  waf\n\n进入proxy文件夹，里面会有一个root.conf，即为根路径的配置文件，你需要修改这个文件，在里面加上上述提到的配置项，否则lsky的界面会变乱。\n修改好了以后，进入1panel的web页面，找到站点的配置文件选项框\n\n点击最下方的保存并重载，即可生效\n\n刷新界面，可以看到页面加载正常了\n\n3.3 又拍云cdn在我的配置项中，并没有把img1和img都解析到云服务器，而是将img1作为cdn加速的域名\n这里我使用的是又拍云CDN，注意使用之前，你需要申请好这两个子域名的https证书，可以是单域名证书，也可以是通配符证书。单域名证书能在又拍云CDN中免费申请\n\n推荐大家去申请一个又拍云联盟，只需要在网站页脚贴一个logo，就能白嫖一年67元的代金券。新人用户也有一个月的61元代金券\n\n\n3.3.1 创建CDN服务进入控制台，点击创建CDN服务，按如下格式填写\n\n创建好了之后，如果访问img1.text.top，那么就是经过了cdn的，如果访问img.text.top即为源站\n此时你可以修改lsky pro存储策略中的图片访问url，让lsky直接返回img1.text.top的连接\n\n3.3.2 回源host创建好了之后，还需要进一步配置。在回源管理中，修改回源host为源站域名。如果是👆图创建的样式，那么源站域名就是img.text.top\n\n解释一下这里的回源host\n\n简单来说就是浏览器在访问img1.text.top加速域名的时候，又拍云服务器会访问img.text.top进行回源操作\n此时他会发送一个host，如果这里不设置，默认的host就是访问域名，即img1.text.top\n但是我们的云服务器中nginx可能没有配置img1.text.top的反代规则，此时就会被随机跳到一个配置了反代的端口上，无法正确跳转到img.text.top（此情况是配置了多个nginx反代，如果只有一个服务，可能不会出现跳转错误）\n配置了host为img.text.top后，CDN进行回源的时候，就会告诉服务器我是img.text.top，服务器的反代就能正确识别并返回服务\n\n这个回源host在加速诸如vercel、netlify、GitHub Pages等具有域名访问控制的服务的时候尤为重要。比如下图就是因为我没有配置host，导致CDN加速发送的请求域名并没有被vercel收录，也就不知道要转到那个服务上，于是便无法访问\n\n3.3.3 https设置使用cdn加速后，即便你源站有ssl证书，cdn加速后的域名也不一定能正常访问\n\n此时就需要在cdn的配置中添加https证书\n\n这里可以添加自有证书，也可以在又拍云CDN申请单域名证书。又拍云申请ssl证书的操作还是挺快的，几分钟就好了，这点值得表扬\n\n3.3.4 缓存控制这里还需要配置一下缓存控制，否则默认会是全站加速\n\n对于lsky来说，我们需要加速的只是图片资源你，并不需要加速管理页面\n\n如果配置了缓存规则之后，进入管理页面出现了问题，那就需要配置一下不缓存规则，把管理页面、设置页面给加入进去\n\n3.3.5 源站静态资源迁移在回源设置里面有一条是静态资源迁移，这个还是很不错的！\n\n因为又拍云的CDN回源到bucket是不用钱的，这样就相当于只需要付存储的费用就行了。因为我的站点访问量小，对于CDN回源而产生的存储肯定少的可怜，完全不用担心费用问题\n\n需要操作的就是添加一个云存储\n\n配置一个操作员，提供写入和读取权限，就OK了。不需要绑定域名\n\n在静态资源迁移里面选择这个云存储即可\n4.picgo都用图床了，肯定不能少了老朋友Picgo\n在插件商店可以搜到lankong插件，开源地址 hellodk34&#x2F;picgo-plugin-lankong\n\n配置插件参考README；我这里发现2.3.0 BATA8无法正常运行插件，只有2.3.1版本的picgo可以用\n\n其中关于permission需要注意的是，这个设置的是兰空图床的权限，也就是你上传的图片能不能在图床网站上直接被看到。并不是阿里云OSS那种外部无法直接访问的私有权限。\n注意啊注意啊，token需要你自己调用curl或者用postman/apifox调用api获取\n别像我一样傻乎乎的，用这个示例值试了好久😥\n\n5.nsfwjs 鉴h除非你的图床不打算公开给任何人用，关闭了注册/游客上传的功能；那么我建议你设置一下鉴h操作。\n兰空图床支持阿里云&#x2F;腾讯云的内容安全，但是这俩玩意说实话，对于一个无人问津的小站点而言，价格太恐怖了。\n相比之下，nsfw的api可以直接用docker部署，经过我的测试，效果还是不错的\nversion: &#x27;3&#x27;services:  nsfw-api:    image: penndu/nsfw-api:latest    restart: unless-stopped    hostname: nsfw-api    container_name: nsfw-api    ports:      - &quot;14727:3000&quot;\n\n在角色组设置里面，可以设置图片审核。配置好docker之后，url末尾需要带一个/classify才能正常调用。默认的阈值是60，实在太低了，保险起见，越低越好。\n请注意，部署的nsfw的服务必须要能够外网访问，填机器本地IP是不行的\n这里我设置成了15，能屏蔽掉很大一部分的h图\n\n但是违反其他规定的图片就需要你人工审核（或者去买阿里云&#x2F;腾讯的内容审核）了\n个人建议，关闭游客上传&#x2F;注册功能——除非你打算建立一个完全公开的图床站点，并对你图床的内容负责。\n\n配置好了之后，如果有用户上传奇怪的图片，会直接禁止，上传失败\n6.修改页脚使用 vscode(remote-ssh) 进入lsky的docker映射到本地的文件夹（如果你使用nas部署，则用vscode打开smb的文件夹，进入倒lsky映射到你nas本地的文件夹），搜索如下\npresent Lsky Pro. All rights reserved.\n\n有两个文件中都包含了页脚信息，都给他修改了就行；修改后重启容器就能生效\n\n如图，我的图床的页脚就是修改后的信息\n\n要是lsky后台配置项能直接加上这个配置项就好了，默认的页脚写的都还是2018，太旧了。\nMore有任何问题，欢迎在下方评论\n","categories":["docker真好玩"],"tags":["nginx","图床","Docker"]},{"title":"【Docker】配置wiki js","url":"/posts/1924263382/","content":"wikijs是一个在线多人协作（带git版本管理）的wiki套件\n\n\n相比于其他wiki的展示功能为主，wikijs将权限管理+多人协作作为了首个要素，其支持富文本编辑器&#x2F;mardown编辑器&#x2F;html源码编辑\n1.Docker-cli部署\n在云服务器安装 https://docs.requarks.io/install/ubuntu\n\n可以跟着官方的指令走，下面节选了最终3个创建容器的命令\n\n配置密钥\nmkdir -p /etc/wiki# Generate DB secretopenssl rand -base64 32 &gt; /etc/wiki/.db-secret# Create internal docker networkdocker network create wikinet# Create data volume for PostgreSQLdocker volume create pgdata\n\n配置数据库\ndocker create \\--name=db \\-e POSTGRES_DB=wiki \\-e POSTGRES_USER=wiki \\-e POSTGRES_PASSWORD_FILE=/etc/wiki/.db-secret \\-v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro \\-v pgdata:/var/lib/postgresql/data \\--restart=unless-stopped \\-h db \\--network=wikinet \\postgres:11\n配置主容器\ndocker create --name=wiki \\-e DB_TYPE=postgres \\-e DB_HOST=db \\-e DB_PORT=5432 \\-e DB_PASS_FILE=/etc/wiki/.db-secret \\-v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro \\-e DB_USER=wiki \\-e DB_NAME=wiki \\-e UPGRADE_COMPANION=1 \\--restart=unless-stopped \\-h wiki \\--network=wikinet \\-p 3000:3000 -p 3443:3443 \\ghcr.io/requarks/wiki:2\n\n升级伴侣\ndocker create \\--name=wiki-update-companion \\-v /var/run/docker.sock:/var/run/docker.sock:ro \\--restart=unless-stopped \\-h wiki-update-companion \\--network=wikinet \\ghcr.io/requarks/wiki-update-companion:latest\n\n配置防火墙\nsudo ufw allow sshsudo ufw allow httpsudo ufw allow httpssudo ufw --force enable\n\n运行容器\ndocker start dbdocker start wikidocker start wiki-update-companion\n\n到这一步，就可以用3000端口访问了\n2.docker-compose部署https://docs.requarks.io/install/docker\ndocker-compose最好的一点就是方便管理，不需要单独管理上面的3个容器，而是用一条命令就能同时启停容器\nversion: &quot;3&quot;services:  db:    image: postgres:11-alpine    environment:      POSTGRES_DB: wiki      POSTGRES_PASSWORD: wikijsrocks      POSTGRES_USER: wikijs    logging:      driver: &quot;none&quot;    restart: unless-stopped    volumes:      - db-data:/var/lib/postgresql/data  wiki:    image: ghcr.io/requarks/wiki:2    depends_on:      - db    environment:      DB_TYPE: postgres      DB_HOST: db      DB_PORT: 5432      DB_USER: wikijs      DB_PASS: wikijsrocks      DB_NAME: wiki    restart: unless-stopped    ports:      - &quot;80:3000&quot;volumes:  db-data:\n\n3.配置证书let’s encrpy配置证书需要多指定两个环境变量，分别是你的域名以及用于申请证书的邮箱\n-e &quot;LETSENCRYPT_DOMAIN=wiki.example.com&quot; \\-e &quot;LETSENCRYPT_EMAIL=admin@example.com&quot; \\-p 443:3443\n\n如果不这么做，则需要在nginx反向代理上配置证书\n4.超级方便的sqlite（个人推荐）上面的两个办法，都需要多建一个数据库的容器。对于云服务器来说，内存是及其宝贵的资源。\n如果你和我一样，wikijs只作为简单的记录用途，而不是生产用途（比如公司内部协作写文档），则可以使用轻便快捷的sqlite来作为数据库，避免多开一个容器的烦恼！\ndocker run -d -p 8080:3000 --name wiki --restart unless-stopped -e &quot;DB_TYPE=sqlite&quot; requarks/wiki\n\n一条命令搞定，不需要弄什么第二个数据库，怎么样，是不是很爽？\n\n参考https://b4d.sablun.org/blog/2021-02-07-instant-wikijs-with-docker/\n\n注意：请确认您不是在生产环境下使用sqlite。相比于其他数据库，sqlite的主要优势是方便，其性能是不如mysql等数据库的！\n4.评论默认的评论连回复都不支持，也没有一个管理页面和通知，如果要把wiki展示出来，这样就非常不方便\n建议配置一下artalk评论系统 教程\n","categories":["docker真好玩"],"tags":["nginx","wikijs","Docker"]},{"title":"【面经】230331模拟面试记录","url":"/posts/3461978244/","content":"参加了一次模拟面试，是已经工作的学长面试我的。\n记录一下问了哪些问题，括号中为我的回答。\n说起来真该打，我竟然没有录屏 😥 以下基于我自己的回忆，顺序和实际问的顺序并不同\n1.做了什么项目？因为我还没来得及写cpp的项目，于是就说了自己的python项目，valorant游戏商店查询机器人\ngithub.com&#x2F;Valorant-Shop-CN&#x2F;Kook-Valorant-Bot\n\n项目功能描述（主要还是基于riot的api获取用户信息，对于机器人而言，更多的工作是在展示数据上。刚开始使用的是纯文字的商店结果，后续改成了用pil库进行画图）\n有没有参考其他项目（这里我说了和我bot功能相同的discord机器人，表示自己写的没有他的好）\n有没有进行压力测试（我描述了早八是用户高峰期，此时机器人对用户的响应会慢上1-2s）\n你觉得有什么优化的空间（类对象封装问题，命名规则问题）\n如果把这个项目从python改成cpp，需要做什么\n\n现在想来，我应该提到自己采用了缓存机制，会避免对重复的商店图片二次画图。数据是存在leancloud上的。\n2.智能指针\n种类（我忘记了weak_ptr）\n特性（主要回答了RAII，以及不同种类智能指针的特点）\n引用计数怎么实现的\n\n由于我忘记了weak_ptr，所以也忘记了循环引用问题……\n3.大文件数据查询问题\n如果有一个100g的文件，我需要将文件中内容和已有数据库中进行对比，怎么做？\n我答了采用归并进行外排序，但是没能讲出实际的处理办法（因为我压根没学）\n\n4.红黑树和AVL\n原理特性\n红黑树是怎么实现的（这里红黑树我只记住了最长的时间复杂度，平均的忘记了😶‍🌫️）\n平均时间复杂度\n\n5.排序算法\n说说你知道的排序算法\n时间复杂度\nstd的sort是用什么实现的？（小区间采用插入排序，大区间采用堆排）\n\n6.tcp三次握手和四次挥手\n三次握手和四次挥手是干嘛的\n讲述这两个过程中的tcp链接状态\n为什么不能是2次握手\n\n这里因为我刚刚才学习到，所以回答的还算完整\n7.跳表没了解过（甚至没听过这个东西），直接跳过了😥学长建议我去学习一下\n8.多态\n静态多态（函数重载，注意只改返回值不构成重载）\n动态多态（继承和虚函数）\n能不能有虚构造？（不能）能不能有虚析构？（可）\n虚析构的作用（父类指针释放子类对象时，调用子类析构，避免内存泄漏）\n虚函数是怎么实现的？（虚函数表，这部分记不太清了，我瞎编的🤣）\n虚函数表中的地址我可以强制修改吗？（不会）\n\n9.类\nC语言struct和C++ class的区别（C++的对象有成员函数，方便调用。我还回答了C++中struct默认公有，class默认私有）\n默认成员函数有几个，作用\n如何实现一个能够在类外访问类内成员的函数？（友元）\n\n10.模板\n用来干嘛（避免多次重复写一个类，简洁代码）\ntemplate中class和typename有什么区别（我回答的是没区别）\n\n11.进程控制\n操作系统是如何控制进程的（进程pcb相关知识，进程地址空间）\n父子进程基本操作\n\n12.原子性\n什么是原子性\n什么是锁，锁怎么保证原子性\n锁就绪了之后，怎么通知等待的线程（我不确定，回答的是用条件变量）\n\n最后写了一道OJ\nhttps://leetcode.cn/problems/longest-palindromic-substring/description/\n给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。输入：s = &quot;cbbd&quot;输出：&quot;bb&quot;\n\n我用的是最简单的暴力办法，在面试环节，这么做肯定要扣分的（\nclass Solution &#123;public:    bool isReverse(const string&amp; s,int begin,int end)    &#123;        while(begin&lt;end)        &#123;            if(s[begin]!=s[end])            &#123;                return false;            &#125;            begin++;            end--;        &#125;        return true;    &#125;    string longestPalindrome(string s) &#123;        if(s.size()&lt;2)        &#123;            char a = s[0];            string tmp=&quot;&quot;;            tmp+=a;            return tmp;        &#125;        int i=0,j=0;        int max = 0;        int index[2];        for(i=0;i&lt;s.size()-1;i++)        &#123;            for(j=i+1;j&lt;s.size();j++)            &#123;                bool ret = isReverse(s,i,j);                if(ret &amp;&amp; (j-i)&gt;max)                &#123;                    max = j-i;                    index[0]=i;                    index[1]=j;                    cout&lt;&lt; &quot;i &quot; &lt;&lt; i &lt;&lt; &quot; j &quot; &lt;&lt; j &lt;&lt; endl;                &#125;            &#125;        &#125;        cout&lt;&lt; &quot;index &quot; &lt;&lt;  index[0] &lt;&lt; &quot; - &quot; &lt;&lt;  index[1] &lt;&lt; endl;        string tmp(s,index[0],max+1);        return tmp;    &#125;&#125;;\n\n总结和建议由于模拟面试只有1h，写完oj之后时间就到了。我感觉我答的挺差的，有好多都记不住了。\n我咨询了学长要不要自己去了解以下C++17和C++23的新增内容\n学长建议看看《STL源码剖析》和《c++primer》这两本书，精进一下已有知识\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【Docker】限制已运行容器的Cpu和内存","url":"/posts/2589797340/","content":"docker限制已运行容器的Cpu和内存\n\n\n1.问题描述最近云服务器的内存经常不够用，而且是莫名其妙的增多，在腾讯云的控制台里面看，4gb 的内存占用了3.2 gb，就卡到连 ssh 都连不上了\n\nPS: 已换过网络和设备，确认不是用户端网络问题导致无法ssh\n\n\n实在没辙了，只能把我的几个不热门的kook-bot移植到replit白嫖，再限制一下lsky图床docker镜像的内存用量\n\n其实主要是nsfw-api的内存用量，我发现有人故意给我的图床上传h图。lsky后台由于鉴黄不通过，不允许上传，也看不到是谁干的。隔这压力测试呢？\n我的图床基本只对自己的博客使用。开放游客上传，也只是方便大家临时上传一些图片，还请大家手下留情！！！😥\n\n这个操作我做了几次，也算是一个高频操作了。在此记录一下如何更改一个正在运行中容器的内存限制\n2.修改内存限制先使用ps命令查看当前容器和对应的id\ndocker ps\n\n可以看到，lsky图床和nsfw的镜像分别是第二个和第三个\n\n再用stats命令查看当前的状态\ndocker stats\n\n\n可以看到，图床的内存没有进行限制，nsfw 的内存已经被限制到了618mb，当前已用565mb，基本要满了.\n重启一下容器，发现初始化的时候只需要100mb左右的内存，合计着现在就有人在往图床里面上传图片？🤣🤣🤣\n\n这怎么行，直接给它内存限制干到512mb，能省一点内存是一点，不能因为图床导致我服务器卡死。\n修改限制，要使用的是container update命令\n\n参考文档\n\n\n\n名称,简写\n默认值\n描述\n\n\n\n–blkio-weight\n0\n阻塞IO(相对权重)，介于10和1000之间，或0禁用(默认为0)\n\n\n–cpu-period\n0\n限制CPU CFS(完全公平的调度程序)周期\n\n\n–cpu-quota\n0\n限制CPU CFS(完全公平的调度程序)配额\n\n\n–cpu-rt-period\n0\n限制CPU实时周期(以微秒为单位)\n\n\n–cpu-rt-runtime\n0\n以微秒为单位限制CPU实时运行时间\n\n\n–cpu-shares, -c\n0\nCPU份额(相对权重)\n\n\n–cpuset-cpus\n\n允许执行的CPU(0-3,0)\n\n\n–cpuset-mems\n\n允许执行的内存率(0-3,0.1)\n\n\n–kernel-memory\n\n内核内存限制\n\n\n–memory, -m\n\n内存限制\n\n\n–memory-reservation\n\n内存软限制\n\n\n–memory-swap\n\n交换限制等于内存加交换：-1以启用无限制的交换\n\n\n–restart\n\n重新启动在容器退出时应用的策略\n\n\n模板如下\n\n\n\n\n\ndocker container update 容器名 --memory=&quot;2g&quot;  --memory-swap=&quot;-1&quot;\n\n上面的命令会限制容器的内存为2gb，交换内存设置为-1（以启用无限制的交换）\n比如我现在想修改nsfw容器的内存限制，应该如下操作\ndocker container update nsfw-api --memory=&quot;0.5g&quot; \n\n然后发现报错了\nError response from daemon: Cannot update container 418fc2a79fa7ad2e637babe17424ee60e9027ef4a7fada3f279864e76bdaaa10: Memory limit should be smaller than already set memoryswap limit, update the memoryswap at the same time\n\n大概意思是让我们同时更新交换内存\ndocker container update nsfw-api --memory=&quot;0.5g&quot;  --memory-swap=&quot;-1&quot;\n\n现在就 ok 了，执行成功会在命令的下一行显示镜像的名字\nnsfw-api\n\n在stats看一下，发现已经修改成功了\ndocker stats\n\n\n修改其他容器的效果也是一样的，目的已经达到啦！\n3.修改cpu限制下面的命令意思是限制容器只能使用主机上两个cpu\ndocker container update  容器名 --cpus=2\n\n所谓两个 CPU，其实就是主机上 CPU 的两个线程。比如如果你的云服务器是 2 核心 4 线程的，那么这个限制就代表该容器只能使用 2 个线程。\n\nhttps://www.cnblogs.com/sparkdev/p/8052522.html\nhttps://zhuanlan.zhihu.com/p/388012843\n\n","categories":["docker真好玩"],"tags":["Docker"]},{"title":"【docker】通过配置文件，修改已有容器的端口映射","url":"/posts/1996139841/","content":"docker修改已有容器的端口映射\n\n\n\n参考 https://www.jb51.net/article/257510.htm\n\n1.需求之前我在我的nas上部署了一个centos容器，当时脑子抽了，没想起来要多映射几个端口。只映射了容器的22端口（ssh）\n对于应用开发而言，没有能够直接访问的端口可太蛋疼了。在centos里面开frp穿透出来访问吧，又太麻烦。\n如果在绿联的控制台里面修改端口隐射，会直接创建一个新的容器，原有容器的信息会丢失。现在这个centos系统已经用了一段时间了，开发环境都配置好了。创建一个新容器就是得重头配置，虽然不是啥难事，但是太耗时间了！！！😥\n于是就想着，能否通过修改配置文件的方式，实现修改容器的端口映射。\n2.操作2.1 开启ssh并关闭docker服务修改之前，需要开启绿联nas的ssh服务。绿联nas如何开启ssh参考 视频\n说白了就是开启设备设置中的远程调试，在远程调试码前面加上如下字符，就是root的密码。用nas的本地ip连接ssh，端口为922（如果连不上，保持远程调试开启状态下，重启nas即可）\nL#W$%W1uGa\n\n2023年11月后的绿联nas，直接开启远程调试，给出的调试码就是ssh的密码。\n链接上ssh之后，先使用docker ps，查看需要修改容器的container id。注意，这里的id并不是完整的容器id，先记录下来。\ncontainer id2b8f29d7b4b0\n\n随后进入绿联的客户端，关闭docker服务；如果是其他linux系统，可以用如下命令关闭docker服务\nsystemctl stop docker\n\n命令行里面再次执行docker ps，确认docker服务确实已经关闭\n$ docker psCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\n\n如果显示如上，则代表docker并没有在运行。即docker被正常关闭了。\n2.2 找到docker安装路径接下来要做的，就是查看docker安装的位置。对于群晖、威联通、绿联这种nas而言，其系统内对docker安装挂载的位置是不同的。比如绿联的nas自带了16gb的闪存（系统盘），但docker的安装位置并不在这16GB里面，而是在我们用户的硬盘中。\n一般的Linux系统（以我的云服务器为例），docker的安装位置应该是如下路径\n/var/lib/docker\n\nls查看内部文件，如下\n# ls /var/lib/dockercontainers  image  network  overlay2  plugins  swarm  tmp  trust  volumes\n\n而绿联的系统并没有这个路径\ncan&#x27;t open &#x27;/var/lib/docker&#x27;: No such file or directory\n\n查看/var/lib，并没有发现docker文件夹\n# ls /var/lib/dbus   nginx  samba\n\n查看/var，发现了一个dockerd，猜测这是docker相关文件存放的位置\n# ls /varall_aria2.txt    dockerd          factory\n\n里面只有一个json文件\n# ls /var/dockerddaemon.json\n\ncat命令查看，果不其然，是docker的安装路径\n# cat /var/dockerd/daemon.json&#123;&quot;data-root&quot;:&quot;/mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6&quot;,&quot;log-level&quot;:&quot;warn&quot;,&quot;iptables&quot;:true,&quot;api-cors-header&quot;:&quot;*&quot;,&quot;host375&quot;],&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]&#125;\n\n这就是docker的安装位置了\n/mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6\n\nls查看，文件结构和云服务器的docker安装位置基本一样，这代表我们找对了！\n# ls /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6buildkit    containerd  containers  image       network     overlay2    plugins     runtimes    swarmtmp        trust       volumes\n\n2.3 找到对应容器的配置文件路径docker路径下的containers文件夹，包含了不同容器的配置文件夹。ls查看，发现都是一些看不懂的字符串。实际上，这里的字符串就是容器的id\n# ls /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers\n\n2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf  9113e1ec4740726feb9623a897f81b9066bc1b63811bfc0a65875d8a2c46c60347aa763o2da18686c6301047ef57f24fb611a2ebea2066f0dbk68205a40777e3\n\n前面提到，docker ps显示的容器id并不是完整的。因为完整的很长很长，不可能在ps命令里面全显示出来。\n我需要修改的目标容器，缩短的id如下，对应的正是containers文件夹里面的第一个文件夹\n2b8f29d7b4b0\n\n看看这个文件夹里面有啥东西\n注意：此时命令已经很长很长。避免出错，建议开个记事本，在里面把命令写好，再复制到终端中执行！\nls -l /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf\n\n得到的文件结构如下，我们需要修改的是config.v2.json和hostconfig.json\n-rw-r-----    1 root     root         87802 Mar 11 18:12 2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf-json.logdrwx------    2 root     root          4096 Feb 23 18:42 checkpoints-rw-------    1 root     root          3300 Mar 11 18:12 config.v2.json-rw-r--r--    1 root     root          1925 Mar 11 18:12 hostconfig.json-rw-r--r--    1 root     root            13 Mar 11 18:12 hostname-rw-r--r--    1 root     root           174 Mar 11 18:12 hostsdrwx--x---    2 root     root          4096 Feb 23 18:43 mounts-rw-r--r--    1 root     root            83 Mar 11 18:12 resolv.conf-rw-r--r--    1 root     root            71 Mar 11 18:12 resolv.conf.hash\n\n2.4 备份在linux的命令行中操作，备份是必不可少的！使用cp命令，把配置文件复制一份，并在名字中添加上.bak予以区别\ncp 源文件 目标文件\n\n以下是cp命令备份config.v2.json文件的命令示例，命令很长！\ncp /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/config.v2.json /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/config.v2.bak.json\n\n备份了我们需要修改的两个文件后，接下来就是修改配置文件了\n2.5 修改配置文件2.5.1  hostconfig.json使用vim来进行编辑（编辑之前，可以用cat先复制出内容，放到vsc等编辑器中格式化，方便找到对应的位置，或者直接在vscode中修改，然后覆盖回去，都OK）\nvim /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/hostconfig.json\n\n如下便是要修改的字段，可以看到里面只有对22端口的映射\n&quot;PortBindings&quot;: &#123;        &quot;22/tcp&quot;: [            &#123;                &quot;HostIp&quot;: &quot;0.0.0.0&quot;,                &quot;HostPort&quot;: &quot;22222&quot;            &#125;,            &#123;                &quot;HostIp&quot;: &quot;::&quot;,                &quot;HostPort&quot;: &quot;22222&quot;            &#125;        ]    &#125;\n\n我们照猫画虎，直接添加上另外两个端口的映射。\n在英文输入法下，按i进入vim的编辑模式，通过键盘移动光标到指定位置，修改文件\n&quot;PortBindings&quot;: &#123;        &quot;22/tcp&quot;: [            &#123;                &quot;HostIp&quot;: &quot;0.0.0.0&quot;,                &quot;HostPort&quot;: &quot;22222&quot;            &#125;,            &#123;                &quot;HostIp&quot;: &quot;::&quot;,                &quot;HostPort&quot;: &quot;22222&quot;            &#125;        ],        &quot;50000/tcp&quot;: [            &#123;                &quot;HostIp&quot;: &quot;0.0.0.0&quot;,                &quot;HostPort&quot;: &quot;50000&quot;            &#125;,            &#123;                &quot;HostIp&quot;: &quot;::&quot;,                &quot;HostPort&quot;: &quot;50000&quot;            &#125;        ],        &quot;50001/tcp&quot;: [            &#123;                &quot;HostIp&quot;: &quot;0.0.0.0&quot;,                &quot;HostPort&quot;: &quot;50001&quot;            &#125;,            &#123;                &quot;HostIp&quot;: &quot;::&quot;,                &quot;HostPort&quot;: &quot;50001&quot;            &#125;        ]    &#125;\n\n编辑好了之后，按esc退出编辑模式，:wq保存并退出\n2.5.2 config.v2.json这个文件需要修改的是如下字段\n&quot;ExposedPorts&quot;: &#123;    &quot;22/tcp&quot;: &#123;&#125;&#125;\n\n添加上刚刚在hostconfig.json里面新增的端口\n&quot;ExposedPorts&quot;: &#123;    &quot;22/tcp&quot;: &#123;&#125;,    &quot;50000/tcp&quot;:&#123;&#125;,    &quot;50001/tcp&quot;:&#123;&#125;&#125;\n\n同样:wq保存并退出\n2.6 现在就已经修改好啦！相同的文件路径中还有一个hostname文件，可以修改容器的hostname，就是ssh登录docker安装的centos后，显示在用户名@右边的那个\n用户名@hostname\n\n用docker安装的centos镜像，是不能在centos系统中修改容器hostname的\n\n在docker安装的centos系统内修改可以，但是不会真正生效；不过这个东西对使用系统毫无影响，所以不修改也没关系\n\n3.重启docker，查看是否修改成功在绿联客户端里面重启docker服务之后，使用docker ps命令查看端口映射是否修改成功；其他linux系统用如下命令启动docker。\nsystemctl start docker\n\n如果多出了刚刚我们在配置文件里面修改的50000和50001端口，就代表端口映射修改成功了！\n","categories":["docker真好玩"],"tags":["Linux","CentOS","Docker"]},{"title":"【面经】230816云账房一面","url":"/posts/1199148787/","content":"230816云账房一面\n\n\n1.什么是移动构造2.循环链表如何实现3.用了那些stl容器4.树的类型这里问了我mysql用的是什么，我答了红黑树。但其实是B+树（没学）\n5.C++11新特性6.C++11future没听说过，得学\n7.linux进程通信的方式管道 共享内存信号量socket本地文件\n\n全答出来了，还问了谁最快（共享内存最快）\n然后又问了进程之间如何同步（不会）\ntnnd现在才想起来。进程同步直接用信号量就可以啊！！！！！我怎么信号量答出来了不知到这玩意是干嘛的呢……说白了还是学艺不精\n8.git的基本命令我说了下面这些\ngit add git pushgit commit git loggit reset git rebasegit merge\n\n9.版本号管理我答我用了3个版本号\n大版本.功能版本.bug修复版本\n\n谢谢惠顾泻药，太多东西没答上来，已经发了感谢信了\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【面经】230913上海零念科技CPP实习生","url":"/posts/2719794733/","content":"230913上海零念科技CPP实习生面试记录\n\n\n上来先做了个自我介绍，然后面试官介绍了他们是做系统进程调度的；\nCPP题目顺序并非实际问的顺序\n1.类的大小类的大小和什么东西有关系？\n我答了成员变量和虚函数表\n2.多态怎么实现的顺着虚函数表问的，就说了一下动态多态的基本实现方式\n3.只能在栈上的类禁止拷贝构造和赋值，构造函数私有化，提供单独函数在栈上开辟空间；\n顺便问了一下动态内存管理的基础形式\n4.智能指针哪些类型？有啥区别？weak ptr怎么解决循环引用问题的？\nweak ptr的lock函数用过吗？有没有办法获取到shared ptr的引用计数？\nunique_ptr可以转成share_ptr吗？\n如果要用C++11的类型转换，要使用哪一个来进行unique_ptr和share_ptr的转换？（这个不会，应该是static_cast）\n定制删除器是干嘛的？\n智能指针线程安全吗？\n拷贝构造share_ptr会不会有内存泄漏？\n5.类型转换C++11的类型转换，几个，区别是什么？\n指针之间转换要用什么？（不会，答的static）\ndynamic_cast父子转换的时候，向上还是向下是安全的？（子转成父是安全的，即向上安全）\n6.单例几种类型，怎么实现？\n7.模板模板的声明和定义为啥不能分离？（忘记了）\n模板特化是什么？函数模板支持半特化吗？（不支持）\n8.C++线程和async有啥区别？thread是类，aysnc是函数\nasync有两种用法，一个是立马异步执行，会开一个线程；第二个是延迟同步执行，在使用future.get的时候才会执行。\n这部分是在云账房面试的时候问道的，得亏我专门去学了，开心！\n9.C++14新特性知道的全说了，auto，lambda新特性，constexpr（和c++11的区别），变量模板，二进制变量，然后还说了最后几个std的函数看不明白；面试官人很好，一直说没关系；\n专门问了constexpr声明变量和const有啥区别（不知道）\n\nGPT的回答\n\n时间点：constexpr 是在编译时确定值的，而 const 是在运行时确定值的。\n编译期计算：constexpr 变量可以用于编译时期间的计算，比如数组大小、模板参数等需要在编译阶段确定大小的场景。而 const 变量只是表示它的值不可以修改，在编译阶段无法使用 const 变量进行编译期计算。\n初始化：constexpr 变量必须在声明时进行初始化，并且只能使用常量表达式初始化；const 变量可以在声明时初始化，也可以稍后赋值，但赋值后就不能再修改。\n地址：constexpr 变量往往会被编译器优化，可能不会占用内存空间，并且在编译期间被消除。const 变量在运行时分配内存，并且有相应的内存地址。\n但是这两个关键字声明的变量都具有常量属性，不可修改；\n\n\n对C++17有没有了解？（无）\n10.stl用过什么？把常用的stl都说了一遍\nstl线程安全吗？当然不\n11.vector和array区别array是定长数组，vector动态开辟\narray可以使用迭代器，保证代码风格统一\n这里顺便提到了[]的重载，面试官问了vector里面at函数和[]重载的区别（at会抛异常，[]不会）\n12.emplace_back和push_back区别我说了emplace_back能节省一次拷贝的消耗；\n面试官问要怎么使用才能节省这个消耗？使用方式（不会）\nemplace_back既然高效，为啥没有取代push_back？（不会，这里我就说了一下设计考虑兼容性的问题）\n13.初始化列表、构造函数体内初始化、成员变量给缺省值那个更好？有啥区别？\n引用是没有办法使用缺省值的，只有常量&#x2F;普通变量可以用缺省值；\n在VS2019里面调试测试了一下运行顺序：\n\n缺省值（会优化成初始化列表）&#x2F;初始化列表\n函数体内\n\n具体的测试参考 CPP类和对象默认成员函数，里面详细注明了构造顺序；\n14.默认构造函数什么时候可以不自己写构造函数？\n这里没有答全，感觉自己已经被绕晕了\n15.function和bind的作用如题\n16.final&#x2F;overide&#x2F;explicit作用\nexplicit忘记了，面试官说没关系，反正也不用🤣\nLinux1.进程通信有哪些，这里主要问了共享内存和管道的优劣，使用谁的资源消耗更优（这里问的是资源消耗，不是通信速度）\n\n我答的是因为管道是文件描述符，操作系统需要维护文件和进程之间的关系，所以消耗会高一点；然后共享内存是直接在页表上操作，没有额外的消耗；\n咱也不知道对不对，感觉答案应该是下面这个\n\n\n问有没有用过消息队列（知道这玩意，没用过）\n2.进程和线程区别说了资源消耗区别，功能比较隔离的时候适合用进程，还举了个epoll的reactor模式的例子（我瞎编的，说实话，也不知道对不对）\n3.开发环境前期用vs2019，后期用vscode+remote ssh；\n面试官问我很多个文件怎么进行编译和管理，我说了makefile；问有没有用过cmake（无）\n4.编译链接过程这个其实是第一个问的问题，就简单地说了一下；\n5.动静态库有啥区别？优缺点？\nThe end没有问网络，也没有写OJ，也没有问项目；\n这次的面试官很耐心，会引导你回答问题。爱了；\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【leetcode】001.两数之和（C语言，超详细）","url":"/posts/2927049053/","content":"这是初学C时候写的题解，可能有思维漏洞，后面重新刷题的时候会更改！\n\n\n\nPS：已重新更正并添加了C++的哈希解法\n\n[toc]\n\n题目来源两数之和 leetcode-001\n如下图所示\n\n右侧给出了题目的基本模板\n/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;&#125;\n\n\n题目要求做题之前，我们需要梳理出题目的各项要求\n算法题目需要我们非常细致，因为一个小要求的未完成，就会导致格式出问题或者结果出问题，无法通过系统的测试\n题目要求如下：\n\n在给定数组nums中找出相加为target的两个数字\n同一个数字不能重复\n假设每一个target只对应一种答案\n找到数字后返回元素的下标\n不能更改摸板里的代码\n\n这里还有一个容易被忽略的隐藏条件！\n\n相加的两个数字在数组中是连续的\n\n这个条件是观察3个示例得出的，如果没有这个条件，这道题目就需要我们在数组中进行完全搜索！\n我做这道题目的时候就卡在了这个地方！\n\n实现步骤1.模板中四个值的意义首先我们要弄明白摸板里的4个值分别代表什么东西\nint* twoSum(int* nums, int numsSize, int target, int* returnSize)\n\n\nint* nums——nums数组（ 此形式等同于int nums[] )\nnumsSize——数组元素的个数\ntarget——需要求和的结果\nint* returnSize——返回值的个数（这个不可以省略！）\n\n再来看题目的要求\n\n需要在给定数组中找到相加&#x3D;target的两个连续的数字\n\n2.在数组中找到两个连续的元素一般在数组里面查找一个数字，我们都会想到使用for循环\n这里需要查找两个连续的数字，可以使用两个嵌套的for循环以及两个循环变量来实现\n\n更新：实际上这两个数字不一定是连续的，用双循环的暴力写法，非连续数字其实也是能搞定的\n\nint i=0；int j=i+1;\n\n需要注意的是，j比i大了1，为了防止数组越界访问\nfor循环里面的判断变量也要相应的差1\nfor(int i = 0; i &lt; numsSize - 1; i++) &#123;     for(int j = i+1; j &lt; numsSize; j++)     &#123;              &#125; &#125;\n\n3.判断相加是否等于target在数组中找到元素后，需要判断它们两个相加是否等于target\nif(nums[i] + nums[j] == target)\n\n4.返回元素下标当代码成功找到了两个相加等于target的元素后，我们要返回这两个元素的下标\n这里就需要一个新的数组来接收这两个下标，这比单纯的使用两个变量更方便\n创建这个数组有两种方法\n\n使用arr[2]来创建\n使用malloc函数来创建\n\n其中方法二，是题目所给提示里的函数，后续将提及\n/* Note: The returned array must be malloced, assume caller calls free(). */\n\n\n代码示例1\n注：leetcode的函数题目只需要补全自定义函数，无需写main函数\n\n在示例1里面，使用普通的方式创建result[2]数组\nint* twoSum(int* nums, int numsSize, int target,int* returnSize) &#123;    static int result[2] = &#123;0&#125;;//static修饰后，return的地址才能被main接收    for(int i = 0; i &lt; numsSize - 1; i++)    &#123;        for(int j = i+1; j &lt; numsSize; j++)        &#123;            if(nums[i] + nums[j] == target)            &#123;                result[0] = i;                result[1] = j;                *returnSize = 2;//这个不能删除                return result;            &#125;        &#125;    &#125;    return NULL;&#125;\n\n因为我们需要在main函数里面使用result数组的值，所以需要用static来修饰这个数组\n不用static修饰的话，出了自定义函数后，result数组的内存空间将被释放\n即便我们return了这个数组，它也不能被主函数接收\n\nstatic的作用\n修饰函数\n修饰全局变量\n修饰局部变量\n\n这里使用的是static的第3个作用，将局部变量数组result，变成静态局部变量\n即数组result不会在出自定义函数后销毁\n\n*returnSize是什么？\n屏幕前的你是否和我有一样的疑惑，此*returnSize在自定义函数里面没有意义\n那为什么不能删除？\n\n要知道，这里的*returnSize是题目的模板给我们的\n而且题目没有要求我们书写main函数\n其实这里的*returnSize在main函数是有变量传过来的\n删除后自定义函数里缺少变量来接受传过来的数据，自然会报错\n*returnSize = 2;\n\n同时，我们需要在if语句中将它定义为2，即为返回值的个数\n具体的分析参考这篇博客&#x3D;&#x3D;&gt; 链接\n\n代码示例2说第二种方法前，我们必须先弄明白malloc函数是什么\n\n什么是malloc函数？在cplusplus网站，我们可以查看到malloc函数的定义\n该函数对应的头文件为cstdlib，即c语言中的&lt;stdlib.h&gt;\n\n它的作用，简单来说就是在内存中开辟对应字节的空间，赋予给一个指针变量\nint *pa = malloc(sizeof(int));\n\n上面这个语句的意义是，开辟一个int类型（即4个字节）的空间，赋给指针变量*pa\n\n其中的sizeof(int)可以换成(4)；也可以在后面乘上一个数sizeof(int)*2表示8个字节\n\n本题需要的是存放两个int整形的数组，malloc函数可以这么写\nint *num = malloc(sizeof(int)*2);\n\ncplusplus对malloc函数中的定义里有一句话\n\nIf the function failed to allocate the requested block of memory, a null pointer is returned.\n\n如果指针分配错误，函数将返回一个NULL，空指针\n\nmalloc使用后free释放在使用完malloc函数后\n\n需要用free函数来释放malloc创建的内存空间\n需要将创建的指针变量指向空指针，以防程序错误调用\n\nfree(pa);pa = NULL;\n\n这两个函数是配对的\n\n如果申请后不释放，会内存泄露\n\n如果无故释放，那就是什么也没有做\n\n\n内存泄漏参考这篇博客 &#x3D;&#x3D;&gt; 链接\n\n以下就是方法2的完整代码\n/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;    int *num = malloc(sizeof(int)*2);    for(int i = 0; i &lt; numsSize - 1; i++)    &#123;        for(int j = i + 1; j &lt; numsSize; j++)        &#123;            if(nums[i] + nums[j] == target)            &#123;                num[0] = i;                num[1] = j;                *returnSize = 2;                return num;            &#125;        &#125;    &#125;    return NULL;&#125;\n\n为什么本题使用完malloc函数后没有free呢？\n原因还是在本题的提示里\n/*Note: The returned array must be malloced, assume caller calls free()*/\n\n这个语句的大概意思应该是：假设main函数里面已有一个free函数来释放内存\n所以我们不需要自己加上free函数;\n\n自己写代码的时候一定别忘了加哦！\n\n\n初学总结虽然这只是leetcode的第一题，网站打上的难度是“简单”\n但对于我这个学艺不精的初学者来说，还是费了一番功夫去完成这道题并理解它\n本片博客就是我求解这道题的过程，希望对你有帮助\n\n小声吐槽：csdn太多繁杂的东西了，有的博客代码不贴代码块，有的答案代码都是错的。\n还有些人就这么一道题的答案都给你上传一个付费文件（无头像无id无简介，上传几千个资源，怀疑是机器人爬虫）\n\n不管怎么样，至少我弄懂这道题啦！\n感谢引用的两篇博客的作者，若不是他们，我也弄不明白这道题！\n点个👍再走吧，球球了！这对我真的很重要啊！\n回顾已经是2023年的2月份了，距离我写下这篇文，已经过去了一年多的时光。回顾看来，当时写的教程着实不太好，于是返回来更正一番\n代码示例3此题最佳的解决方案是哈希思想。哈希就是一个映射关系。\n\n如果你不知道什么是哈希，建议暂时先采用上面的双循环暴力解法。等后续学习了哈希思想以及实现之后，再回头来重做此题\n\n我们可以将数组中的数据和其对应的下标插入到哈希表中，由于哈希表的搜索效率接近O(1)，查找的速度是很快的，此题的整体时间复杂度就变成了O(N)\n思路如下：\n\n查找哈希表中，是否有和（目标-当前值）相同的元素\n如果有，那么得到答案。返回当前遍历到的下标，以及查找到的元素的下标\n如果没有，那就把当前元素-元素下标作为键值对，插入到哈希表中\n\n因为本题是一定有解的，这样一次循环之后，一定能找到我们需要的那两个数的下标\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int,int&gt; m;//哈希表 数据-下标        vector&lt;int&gt; ret;//返回值        for(int i=0;i&lt;nums.size();i++)        &#123;\t        //找有没有和（目标-当前值）相同的元素            auto it = m.find(target-nums[i]);            if(it!=m.end())//找到了            &#123;                ret.push_back(it-&gt;second);//插入哈希表中下标                ret.push_back(i);//插入当前下标                break;//退出循环            &#125;            else            &#123;                m.insert(&#123;nums[i],i&#125;);//插入元素和下标            &#125;        &#125;        return ret;    &#125;   &#125;;\n\n\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","leetcode"]},{"title":"【面经】230915上海戎磐网络科技C/LINUX实习生","url":"/posts/2553205100/","content":"10分钟就面完了，堪称急速，面试官说我答的不错；而且上来自我介绍完毕后就问问题，不多比比🤣\n\n\n知识点1.Linux下线程互斥怎么实现加锁，pthread，然后我还提到了cpp的原子变量\nhttps://blog.musnow.top/posts/1309150756/\n2.CPP多态怎么实现虚函数表，巴拉巴拉\nhttps://blog.musnow.top/posts/3933786088/\n3.CPP为啥要引入模板代码更高复用\nhttps://blog.musnow.top/posts/2940029419/\n4.NAT怎么实现的？转化表，IP地址替换，巴拉巴拉吧说一大堆\nhttps://blog.musnow.top/posts/3482559497/\n5.进程通信老问题了\n6.inet_ntoa函数知道吗？连续调用会有什么问题？\n这是最后一个问题，面试官说我答的挺好的\n\n我先说了这个函数是用于16位IP地址和字符串的转换的；\n然后面试官这里问了一个业务上的问题\nprintf(&quot;%s %s\\n&quot;,inet_ntoa(x),inet_ntoa(y));// x和y是两个ip地址\n\n这个函数会不会有什么错误的地方？\n\n请注意，这里是面试时候的描述，面试官肯定只能给你描述个大概的，并不会细致到具体的传参应该传什么类型的变量，所以传参x和y也只是个伪代码，想问的地方不在这里！\n\n这里我说了inet_ntoa是采用static变量来返回ip字符串的，线程不安全，有可能两个调用最终返回了一个相同的IP地址，又明说了我不确定；（肯定有问题，不然问你干嘛？）\n\n面试结束了，来测试一下到底是啥情况吧！\n#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123;    struct in_addr ip1;    struct in_addr ip2;    inet_aton(&quot;192.168.3.1&quot;,&amp;ip1);    inet_aton(&quot;10.161.33.42&quot;,&amp;ip2);        printf(&quot;%s %s\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));    return 0;&#125;\n\n运行结果如下，两个IP地址返回了同一个，我猜对了；\n$ ./test192.168.3.1 192.168.3.1\n\n为什么呢？打印一下地址，会得到如下输出，两次调用返回了相同的地址，自然打印出来的结果相同；\nprintf(&quot;%x %x\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));//68db1ef0 68db1ef0\n\n对于这个函数而言，它需要给我们返回一个字符串，又必须保证这个字符串能在函数外被正常访问（不能被释放），再加上这是一个C语言接口，那么就只有三种方案了\n\n函数里面malloc，需要用户手动free\nstatic变量\n让用户传入一个有效的地址，将数据写入作为输出型参数\n\n第一个方案肯定是不可行的！这相当于官方提供了一个极其容易导致内存泄漏的接口！这不得被开发者喷死？比如本题提到的场景里面就是两次printf而已，除此之外没有保存这个返回值，更别提free了，这里就直接两次内存泄漏了！\nprintf(&quot;%s %s\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));// 如果用malloc后的字符串地址做返回值，这里就是两个内存泄漏\n\n第三个方案也不方便，系统依赖用户传入一个数组的入参，我们知道ipv4的IP地址字符串最长是3*4+3=15位，那么如果用户只传入一个char arr[12]呢？越界访问的问题怎么解决？相当于系统之中依旧会出现参数不匹配而可能导致的地址访问错误！\n而这个函数本身的工作很简单，完全没必要弄那么复杂；\n最终linux系统采用了static变量的方式，来返回这个IP地址的字符串；man手册里面是这么说的，直接看最后一句，翻译过来的意思是后续的调用会覆盖掉前面的值；\n The inet_ntoa() function converts the Internet host address in,  given in network byte order, to a string in IPv4 dotted-decimal notation.   The string  is returned in a statically allocated buffer,which subsequent calls will overwrite.\n\n所以最终我们看到的结果就是两次打印出了相同的IP地址；\n这里还涉及到第二个知识点，printf的传参顺序;\n简单说来就是printf是从右往左执行的（其实所有函数的传参都是这样，这也是为什么缺省值要从右边往左给）\nprintf(&quot;%s %s\\n&quot;,inet_ntoa(ip1),inet_ntoa(ip2));\n\n这里的执行顺序如下\n\nip2结构体传给函数，转成ip地址字符串后存在static变量中\nip1结构体传给函数，转成ip地址字符串后存在了static变量中，覆盖了ip2的结果\n\n最终打印出来的两个字符串都是ip1的地址！\n对于inet_aton函数而言，正确的调用办法是每次调用后都取走返回的IP地址字符串，可以用std::string接收，也可以用strcmp拷贝到一个自己定义的字符串数组变量中；\n你学会了吗，骚年？\n\ninet_aton这个函数最早出现于本站的此博客：【Linux】来写一个udp的服务端+客户端\n\n项目因为是cpp的岗位，所以没有问python的机器人项目问题；\n1.视频点播传一半关闭了怎么解决两次面试都问到了这个问题，我提到了将新的文件和本地已有文件进行校验，跳过已有数据\n2.传一半剩下的数据后端怎么处理，什么时候删除？我提到了前后端用md5验证来确认视频文件无误，如果有问题，可以设置一个定时器，一小时后删除错误的数据\n3.用户修改了视频后上传怎么处理？同第一个，进行一定的数据校验，然后再复写没有的数据；\n\n然而这些功能我一个都没有实现🤣\n\n效率面经还没写完，结果已经出啦，过了初试！但是要线下复试；\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【面经】C++面筋记录 (一) 231021","url":"/posts/721187015/","content":"记录部分从牛客网上看到的面筋\n\n\n1.声明一个vector，当vector过大时会栈溢出吗？答案是会。\n默认申请的vector是放在栈区的，栈区的大小&lt;&lt;堆区的大小。所以如果我们在栈区中开辟的vector中插入巨量的数据，是会导致栈溢出的。\n解决办法是将数据存放到堆区上（使用new来创建vector，而不是直接创建）\n2.如何实现多次运行程序但只有一个后台进程？使用命名互斥锁，程序启动前申请锁。\n\n如果锁没有被申请，代表是第一个进程，可以正常运行\n如果锁已经被占用，代表已经有进程了，直接退出当前进程（这里要使用try_lock避免阻塞等待）\n\n在Linux下可以用命名信号量来实现类似进程共享锁的操作。这部分可以去学习进程通信中信号量的部分。\n咨询了发这篇面筋的大佬，说是用文件保存之前进程的PID，读取出来将之前的进程kill掉。\n3.二分法的前提是什么？\n数据有序\n数据结构支持随机访问\n\n4.互斥锁和自旋锁有什么区别\n互斥锁是在内核态进行阻塞等待\n自旋锁是在用户态不断循环沦陷检测锁的状态\n\n如果使用场景是较长运行的共享资源，那么就使用互斥锁。避免自旋锁不断沦陷检测消耗大量CPU资源。\n如果使用场景的共享资源访问速度快，那么可以使用自旋锁。避免互斥锁频繁进行用户、内核态的转换而造成消耗（这里指其他需要获取锁的进程得进入内核态阻塞等待）\n5.TCP三次握手除了序列号还发了什么其他东西？\nSYN和ACK这些表记位（具体复习三次握手每个阶段的发送）\n双方服务进程的端口号\n起始序列号和对对方发送的SYN报文的应答序列号\nTCP校验和\nTCP窗口大小\n\n后续建立连接后，就会根据双方的窗口大小和数据的序列号开始相互通信。\n6.子类重写父类函数，子类中该函数声明为private，能否重写成功？用下面这个毛坯房来进行测试，在默认情况下，我们子类的重写函数都和父类有相同的作用域声明符。\nclass A&#123;public:\tvirtual void test()\t&#123;\t\tfoo1();\t\tfoo2();\t\tfoo3();\t&#125;\tvirtual void foo1()\t&#123;\t\tcout &lt;&lt; &quot;A::foo1&quot; &lt;&lt; endl;\t&#125;protected:\tvirtual void foo2()\t&#123;\t\tcout &lt;&lt; &quot;A::foo2&quot; &lt;&lt; endl;\t&#125;private:\tvirtual void foo3()\t&#123;\t\tcout &lt;&lt; &quot;A::foo3&quot; &lt;&lt; endl;\t&#125;&#125;;class B : public A&#123;public:\tvoid test()\t&#123;\t\tfoo1();\t\tfoo2();\t\tfoo3();\t&#125;\tvirtual void foo1() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo1&quot; &lt;&lt; endl;\t&#125;protected:\tvirtual void foo2() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo2&quot; &lt;&lt; endl;\t&#125;private:\tvirtual void foo3() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo3&quot; &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tB b;\tb.test();\tcout &lt;&lt; &quot;----&quot; &lt;&lt; endl;\tA *bb = &amp;b;\tbb-&gt;test();\treturn 0;&#125;\n\n直接运行，结果也符合预期，目前调用的是子类重写后的虚函数，所有函数都重写成功。\nB::foo1B::foo2B::foo3----B::foo1B::foo2B::foo3\n\nclass B : public A&#123;public:\tvoid test()\t&#123;\t\tfoo1();\t\tfoo2();\t\tfoo3();\t&#125;\tvirtual void foo2() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo2&quot; &lt;&lt; endl;\t&#125;protected:\tvirtual void foo3() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo3&quot; &lt;&lt; endl;\t&#125;private:\tvirtual void foo1() override\t&#123;\t\tcout &lt;&lt; &quot;B::foo1&quot; &lt;&lt; endl;\t&#125;&#125;;// 编译能通过，运行输出和上方没区别\n\n我尝试了各种修改作用域的方式，包括将子类中foo3函数改成公有，foo1函数改成私有，都能正常完成重写。这里的作用域声明符只是会改变子类外是否能调用这个函数，和能否完成虚函数重写无关！\n请注意，如果你将继承方式由public改成private，那么就无法在类外使用父类指针指向子类对象了\n╰─ g++ test2.cpp -o testtest2.cpp: In function ‘int main()’:test2.cpp:316:11: error: ‘A’ is an inaccessible base of ‘B’  A *bb = &amp;b;\n\n但这依旧不影响子类函数重写父类函数（我的依据是override关键字没有报错）\n7.pthread_create能传入类成员函数的指针吗可以，但是必须是静态成员函数。\n如果是普通成员函数，那就需要用中间函数来处理，比如下面的示例代码。\n#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;pthread.h&gt;void* threadFunc(void* arg) &#123;    std::function&lt;void()&gt; func = *reinterpret_cast&lt;std::function&lt;void()&gt;*&gt;(arg);    func();    return nullptr;&#125;int main() &#123;    std::function&lt;void()&gt; myFunc = []() &#123;        std::cout &lt;&lt; &quot;Hello from thread!&quot; &lt;&lt; std::endl;    &#125;;    pthread_t thread;    pthread_create(&amp;thread, nullptr, &amp;threadFunc, reinterpret_cast&lt;void*&gt;(&amp;myFunc));    // 等待线程结束    pthread_join(thread, nullptr);    return 0;&#125;\n\n我们可以用std::function包装一个类的成员函数，并用std::bind将对象的this指针绑定到第一个参数上。外层再套上一个用于执行该函数的void函数，就能传给pthread_create。\nstd::function的对象不能直接传给C语言的函数指针，即便参数对应。会报错。\n8.函数内static变量的作用在函数内定义一个static变量，该变量只会在进入这个函数的时候初始化一次。\n// 计算某一月的1号是一年的第几天(不考虑闰年)int DayOfYear(int month)&#123;    static int day_array = &#123;0,31,59,90,120,151,181,212,243,273,304,334&#125;;    return day_array[month];&#125;\n\n比如上面的函数，我们定义的day数组就只会在第一次进入这个函数的时候初始化。之后进入这个函数将不在初始化，就节省了初始化一个数组的消耗。出了这个函数后，该数组变量依旧存在。\n请注意，这个static语句并不只是变量只初始化一次，实际上这一行语句在该函数中都只会进行一次\nbool checkFlag()&#123;\tstatic bool flag = false;    if(!flag)&#123;        // ..进行对应修改    &#125;&#125;\n\n比如上面的代码中，如果用正常思维来理解，你会觉得这个if语句每次都会判断为真而进入其中。但实际上flag的定义只会被定义一次，只要我们在if中将其改成了true，那么下一次进入该函数的时候，flag依旧会是true，static bool flag = false;语句会被直接跳过，并不会再次执行赋值！\n我之前理解的就是flag变量只会被创建一次，但static后的赋值依旧会执行。这个理解是错误的！\n9.私有static成员函数的意义？这个问题比较有意思，我们知道static函数属于整个类，可以直接通过类名作用域调用。且static函数中无法访问任何非static的成员变量。\n但是，如果给你个static的私有成员函数，它又有什么意义呢？\n\n私有static成员是无法通过类名调用的\n他也没有办法访问类中非static成员变量\n\n可以这么理解：我有一个方法只在这个类里面需要，这个方法不需要使用成员变量，可以通过传参实现（比如计算什么的）\n但是，我又不想它的命名污染父作用域。\n那么，我就可以把它写为类的私有成员函数，并加上static告诉其他人，这个函数是一个单纯的方法类，不需要使用类的成员变量。\n当然，加上static只是一个编程习惯罢了，实际上这种情况不写static也无所谓。\n","categories":["求职路上一去不复返"],"tags":["面经"]},{"title":"【leetcode】006 N字形变换","url":"/posts/3624744626/","content":"写了一下午终于写出来了\n\n\n题目\n leetcode 6. N 字形变换\n\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：\nP   A   H   NA P L S I I GY   I   R\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n\n示例 1：\n输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot;\n\n示例 2：\n输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4输出：&quot;PINALSIGYAHRPI&quot;\n\n解释：\nP     I    NA   L S  I GY A   H RP     I\n\n示例 3：\n输入：s = &quot;A&quot;, numRows = 1输出：&quot;A&quot;\n\n提示：\n1 &lt;= s.length &lt;= 1000s 由英文字母（小写和大写）、&#x27;,&#x27; 和 &#x27;.&#x27; 组成1 &lt;= numRows &lt;= 1000\n\n分析刚开始我想的过于简单了，所以写的代码下标控制有严重问题，弄了这么久，其实一直都是在改下标……\n1.写几个例子如下是n从3到7的例子，能基本满足题目需要的情况\n\n\n题目的要求是，给你一个 ABCDEFG...这样的字符串，再给一个行数n，让你按上面这种N的形式排列出来，再按行读出一个新的字符串。\n我们肯定不可能真的用二维数组给她摆出来一个这样的图像再去遍历，哪样效率太低了。而是用n次遍历，利用下标的规律，以下标访问拼出新的字符串。\n2.分析规律按行号写出每一个的间隔，能的出来一个基本规律（最左列是行下标）\n\n\n首先，我们能发现，每一个N型的第一行和最后一行的间隔（步长）是相同的，且和行数符合一个公式\n(行数 - 1) * 2\n\n除了这两个边界行，中间的行数都是简单的递减 2\n\n3.步长翻转但除了只有三行的示例之外，其余都有一个 步长翻转 的问题\n如下，比如第1行（这里说的是下标）B-&gt;H符合从第0行开始递减2的步长6，但下一次查找的步长H-&gt;J就变成了2了\n同理，看第3行，D-&gt;F的步长为2，而F-&gt;L的步长为6，两者正好和第1行相反。\n而第1行和第3行，正好是两个对称的\n\n这便是第二个规律\n除了首末两行，和奇数行数的中间行（比如行数为5，第2行即为中间行 0 1 [2] 3 4 ）其余行数按上下分，其步长每走一次需要切换一次\n\n以上图中的第1行为例\n\n第一步，B-&gt;H，走的是正常的6步（由8-2得来）\n第二步，H-&gt;J，走的是第三行的正常步2（由8-2*3得来）\n\n由此往后，每走一步都需要在6和2之间切换。\n\n复盘的时候才发现一个更简单的翻转，其实每一行的几次查找的步长最终加起来和首末两行是相同的\n\n4.循环解释找到了这个规律之后，写代码就好写了！下面解释一下完整代码中while循环中的判断部分，一共分为三种情况\n\n首末行和奇数中间行，不需要翻转，正常进行步长的相加\n需要翻转的行数，分为中间行上面的和下面的两种情况。该行第一次进入while，不需要加上翻转步长，而是加上由上一行步长sep-2得来的正常步长cur_sep。此时需要对翻转步长reverFlag进行初始化：\n中间行上面，翻转步长为对称行步长的负数（比如第一行和第三行对称，此时第一行的翻转步长就是第三方的正常步长取负数。）\n中间行下面，翻转步长为对称行步长的正数（同上）\n\n\n该行第二次进入while，需要加上翻转步长reverFlag后，并对翻转步长取负数（对称行两个步长之间差值相同，取负数相当于恢复原始步长）\n直到index大于string的长度，一行遍历完毕，sep-=2\n\n完整代码注意啊，如果你和我一样，写题的时候喜欢用print来找bug，那么写完了之后，一定要把这些题目需求中没有的打印给删除掉。不然会影响性能，甚至有可能因此超时无法通过题目。\nclass Solution &#123;public:    // 奇数行，最中间的    // 5 -&gt; 2 | 7 -&gt; 3    bool isMidRow(int n,int numRows)    &#123;        return (numRows%2!=0) &amp;&amp; n == numRows/2;    &#125;    bool isFirstEnd(int n,int numRows)    &#123;        return n==0 || n==numRows-1;    &#125;    string convert(string s, int numRows) &#123;        if(numRows&lt;=1)        &#123;            return s;        &#125;        string ret;        int begin_sep = (numRows-1)*2;        int sep = begin_sep;// 第一行和最后一行都是这个长度        // 中间的是从第一行开始，每次-2                // 开始遍历，排除最后一行        for(int i=0;i&lt;numRows;i++)        &#123;            if(i==numRows-1)&#123;                sep = begin_sep;// 最后一行的长度分割            &#125;            int index = i;            int reverFlag = 1;            int cur_sep = sep;            while(index&lt;s.size())&#123;                ret+=s[index];                //是否是单数行中间的，如果是那就不需要反转                if(isMidRow(i,numRows) || isFirstEnd(i,numRows))&#123;                    index+=sep;                    //cout &lt;&lt; i &lt;&lt; &quot; continue&quot; &lt;&lt; endl;                    continue;                &#125;                else if(reverFlag == 1)&#123;//本行第一次进来                    index+=sep;                    //cout &lt;&lt; i &lt;&lt; &quot; 1r-sped &quot;&lt;&lt;sep&lt;&lt;endl;                    //int reverNum = abs((numRows/2-1)*2);                    //cout &lt;&lt; i &lt;&lt; &quot; 1r-rever &quot;&lt;&lt;reverNum &lt;&lt;endl;                    // 4行，上对称行1第一次翻转是-2                    // 5行，上对称行1第一次反转是-4                    int k = numRows - i - 1;                    if(i&lt;(numRows/2))//上对成行                    &#123;                        //获取对称的行号的sep，并计算两者差值                        reverFlag = - abs((begin_sep - k*2) - cur_sep);                    &#125;                    else                    &#123;                        reverFlag = abs((begin_sep - k*2) - cur_sep);                    &#125;                    //cout &lt;&lt;i &lt;&lt;&quot; 1r-flag &quot;&lt;&lt;reverFlag&lt;&lt;endl;                &#125;                else//第二次以上，开始反转                &#123;                    cur_sep += reverFlag;                    index+= cur_sep;                    //cout &lt;&lt;i &lt;&lt;&quot; sepd &quot;&lt;&lt;( cur_sep)&lt;&lt;endl;                    reverFlag = -reverFlag;//逆置                    //cout &lt;&lt;i &lt;&lt;&quot; flag &quot;&lt;&lt;reverFlag&lt;&lt;endl;                &#125;            &#125;            // 一行走完了，更新sep            sep-=2;        &#125;        return ret;    &#125;&#125;;\n\n通过截图让我很不理解的是，自己有时候搜一些网上题解，有些文章竟然能做到将无法通过的代码当作题解发出来，浪费读者的时间。实在不知道他们是怎么做到的……所以，为了避免自己的文章被人误解，我尽量每次oj刷题都附上通过截图\n\nThe end最后附上一张当时泄题用的乱七八糟的草稿图\n\n","categories":["把题目都给刷干净"],"tags":["C++","OJ刷题","leetcode"]},{"title":"【leetcode】102. 二叉树的层序遍历（C语言+队列）","url":"/posts/2026576418/","content":"这道二叉树的题目相对来说毕竟难，所以又单独拿出来发一篇题解\n\n\n[TOC]\n102 层序遍历（较难😥）\nleetcode：102. 二叉树的层序遍历\n\n\n这道题相对来说就么有那么容易了，你可能和我一样，压根没看明白题目要求中的后两个参数是用来干嘛的\n\n/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes)&#123;&#125;\n\n看了一些题解，这才算理解了这道题的要求\n\n*returnSize：存放的是二叉树的层数\n**returnColumnSizes：存放的是二叉树每一层的节点个数\n返回值要求是int**：需要返回一个指针数组，该数组中的每一个元素是一个数组A，数组A保存了二叉树每一层的节点值\n\n\n0.错误思路最开始我的想法是，用单独的函数计算出树的节点个数和层级，再进行一次层序遍历来得到树的值。\n但很显然，这一思路在本题是搞不通的！🤔\n1.数组队列初始化在链式二叉树博客中，我讲述了利用队列来实现层序遍历的思路。这道OJ题目我们也是这么干的。不同的是，在我自己写的队列实现里，使用的是链式队列。而本题使用数组队列会好一点！\n#define MAX 2000int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) &#123;    if (root == NULL)        return;    struct TreeNode* Queue[MAX];//队列，存放节点的地址    int front = 0, tail = 0;//指向队头和队尾\n\n2.初始化数组这部分会毕竟绕，先一步一步来理解\n*returnSize = 0;//将二叉树层级初始化为0//存放二叉树的每一层节点的值int** ret = (int**)malloc(sizeof(int*) * MAX);//开辟一个数组来存放每一层的节点个数*returnColumnSizes = (int*)malloc(sizeof(int*) * (MAX / 2));\n\n\nret是一个指针数组，存放的是数组A，数组A里面是每一层的节点值。ret也就是题目要求的返回值\n*returnColumnSizes开辟一个数组来保存每一层的节点数\n\n这里其实returnColumnSizes没有啥二级指针的必要，但是既然题目给了是int**，我们就需要先*解引用再malloc开辟数组\n3.队列操作思路\n先让根节点入队列，tail++\n外层循环判断队列是否非空，如果非空就停止操作\n内层循环进行每一层的入队操作，这样才能得到每一层的节点值和节点个数\n在内层循环中创建ret数组的子数组，单独存放每一层的节点值\n最后将每一层的节点个数赋值给*returnColumnSizes数组，*returnSize++一次\n\n   struct TreeNode* head;   Queue[tail++] = root;//根节点入队   while (front != tail)   &#123;       int Csize = 0;//每一层的节点个数       int end = tail;       //end是每一层最末一个节点的指针。在后续的入队列操作中tail会改变，所以需要保存tail的值       ret[*returnSize] = (int*)malloc(sizeof(int*) * (end - front));       //为每一层开辟一个单独的数组来存放值       while (front &lt; end)       &#123;           head = Queue[front++];           ret[*returnSize][Csize++] = head-&gt;val;           //数组赋值，同时每一层的节点个数Csize++           if (head-&gt;left != NULL)               Queue[tail++] = head-&gt;left;           if (head-&gt;right != NULL)               Queue[tail++] = head-&gt;right;       &#125;       (*returnColumnSizes)[*returnSize] = Csize;//赋值每一层的节点个数       (*returnSize)++;//层数+1   &#125;return ret;\n\n外层循环结束后，此时ret数组就是题目要求的结果了，返回ret就可以了！\n\n这里有一个小问题，当树为空树时，层级应该是0。所以我们需要在第一行赋值*returnSize = 0;不然会执行出错\n\n\n这道题的思路是我看过题解之后才搞明白的，所以上面的只是一个思路的复现😭还是太菜了！\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","leetcode"]},{"title":"【leetcode】150. 逆波兰表达式求值","url":"/posts/3211822811/","content":"题目来源\n150. 逆波兰表达式求值\n\n\n思路逆波兰表达式又称为后缀表达式\n\n中缀 1 + 2 * 3\n后缀 1 2 3 + *\n\n我们需要将逆波兰表达式化为正常可计算的中缀表达式，再进行计算。题目所给的参数是后缀表达式，其操作的思路如下：\n\n遇到操作数，入栈\n遇到运算符，取栈顶两个连续数据进行计算，再将计算结果入栈\n\n看起来不难，是因为这道题已经是简化后的版本，其所给后缀表达式中没有出现()这种特殊优先级的操作。下面说一下把中缀转后缀的思路（本题没有涉及）\n中缀表达式转为后缀手工做法：\n以例2给出的中缀表达式为例，中缀表达式转换为后缀表达式的手工做法为：\n按照运算符的优先级对所有的运算单位加括号。例： ((a/b) + (((c*d) - (e*f))/g))把运算符号移动到对应括号的后面，然后去掉括号。例：((ab)/ (((cd)*(ef)*)-g)/+，去掉括号ab/cd*ef*-g/+\n\n以这个中缀表达式为例\n1 + 2 * 3 / 2 -5\n\n我们都知道，运算顺序应该是先计算2*3然后在计算6/2，最后计算1+3-5得出结果-1\n因为* /操作符的优先级高于加减，这里就需要注意这种情况。我们需要用一个栈来存放操作符\n\n遇到操作数的时候 先输出\n遇到操作符，和栈顶进行比较\n如果栈为空&#x2F;操作符优先级高于栈顶，入栈\n操作符优先级低于栈顶或和栈顶相同，出栈顶操作符\n\n\n最后将栈中的操作符全部出栈，就可以获得后缀表达式\n\n用上面这个思路走一遍，即为下面的情况（不知道这样写的大家能不能看明白）\n\n最终得到的结果如下\n1 2 3 * 2 / + 5 -\n\n即需要的后缀表达式\n我们可以用本题代码测试一下这个用例，得出的结果也是-1，正确！\n\n后缀转中缀https://blog.csdn.net/qq_29462849/article/details/93652583\n\n完整代码//https://leetcode.cn/problems/evaluate-reverse-polish-notation/submissions///150逆波兰表达式class Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; s;        for(auto&amp; ch : tokens)        &#123;            if(ch==&quot;+&quot;||ch==&quot;-&quot;||ch==&quot;*&quot;||ch==&quot;/&quot;)            &#123;                int right=s.top();                s.pop();                int left=s.top();                s.pop();                switch(ch[0])                &#123;                    case &#x27;+&#x27;:                        s.push(left+right);                        break;                    case &#x27;-&#x27;:                        s.push(left-right);                        break;                    case &#x27;*&#x27;:                        s.push(left*right);                        break;                    case &#x27;/&#x27;:                        s.push(left/right);                        break;                    default:                        break;                &#125;            &#125;            else&#123;                s.push(stoi(ch));            &#125;           &#125;        return s.top();    &#125;&#125;;\n\n\n","categories":["把题目都给刷干净"],"tags":["C++","OJ刷题","leetcode"]},{"title":"【leetcode】189. 轮转数组（C语言）","url":"/posts/2445477159/","content":"问题来源\nleetcode 189. 轮转数组\n\n给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n输入: nums = [1,2,3,4,5,6,7], k = 3输出: [5,6,7,1,2,3,4]解释:向右轮转 1 步: [7,1,2,3,4,5,6]向右轮转 2 步: [6,7,1,2,3,4,5]向右轮转 3 步: [5,6,7,1,2,3,4]\n\n这道题的底部有一个进阶要求：\n\n进阶：\n\n尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。\n你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗\n\n\n正好最近学习了空间复杂度和时间复杂度，这里可以用于练习\n\n方法1-基本方法最基本的方法就是直接旋转，把最后一位数字移动到数组的第一位，然后将第二位开始的每一位往前移动一位\n\n需要先执行移动操作再替换第一个数\n\nvoid rotate(int* nums, int numsSize, int k) &#123;    k %= numsSize;    for (int i = 0; i &lt; k; i++)    &#123;        int tmp = nums[numsSize - 1];        for (int j = numsSize - 1; j &gt;0; j--)        &#123;            nums[j] = nums[j-1];        &#125;        nums[0] = tmp;    &#125;    return;&#125;\n\n这种算法的时间复杂度是O(k*N)，空间复杂度是O(1)\n这道题的k是常数，可以省略\n\n但很不幸，它在跑leetcode中非常长的测试用例的时候，还是没有跑过去，超时了\n\n方法2-额外开一个数组这种方法也非常简单，额外开辟一个数组，存储需要旋转的几个数字，然后将它们之前的数据存储到该数组的后半部分\n最后再把新数组复制回原来的数组中\nvoid rotate(int* nums, int numsSize, int k) &#123;    k %= numsSize;    int* num1 = (int*)malloc(sizeof(int) * numsSize);    int h = 0;    for (int i = numsSize - k; i &lt; numsSize; i++)    &#123;        num1[h++] = nums[i];    &#125;    for (int i = 0; i &lt; numsSize - k; i++)    &#123;        num1[i + k] = nums[i];    &#125;    memcpy(nums, num1, sizeof(int) * numsSize);    return;&#125;\n\n这个算法的时间复杂度是O(N)，空间复杂度是O(N)\n可以看到，最后的执行结果只打败了leetcode很小一部分人\n\n同时这个算法也不符合进阶要求中的“原地”\n\n方法3-三旋法（最优）和上面两个方法相比，三旋法相对来说较优，而且符合题目的进阶要求\n但是它需要一定的理解能力：\n假设我们需要旋转3个数字\n\n先将前SZ-K个数字逆置\n再将后k个数字逆置\n最后整体逆置\n\n这样就能得到我们想要的结果！\n1 2 3 4 5 6 7 //旋转3个4 3 2 1 5 6 7 //先逆置前7-3=4个4 3 2 1 7 6 5 //再逆置后3个5 6 7 1 2 3 4 //最后整体逆置，即为结果\n\n代码如下\nvoid Swap(int* nums, int sz)&#123;    int i = 0;    while (i &lt;  (sz/2))    &#123;        int tmp = *(nums+i);        *(nums + i) = *(nums + sz - i-1);        *(nums + sz - i - 1) = tmp;        i++;    &#125;&#125;void rotate(int* nums, int numsSize, int k)&#123;    k%=numsSize;    Swap(nums,numsSize-k);    Swap(nums+numsSize-k,k);    Swap(nums,numsSize);    return ;&#125;\n\n这个算法的时间复杂度是O(N)，空间复杂度是O(1)，符合题目进阶要求\n可以看到，最终执行结果比之前优秀多了！\n\n230219重写此题，相同思路；旋转三次。注意一定要处理k，否则会有栈溢出的问题\n// 旋转参数的位置（下标）void ReverseArr(int* arr,int begin,int end)&#123;    while(begin&lt;end)    &#123;        int tmp = arr[end];        arr[end] = arr[begin];        arr[begin] = tmp;        end--;        begin++;    &#125;&#125;void rotate(int* nums, int numsSize, int k) &#123;    k%=numsSize;    ReverseArr(nums,numsSize-k,numsSize-1);    ReverseArr(nums,0,numsSize-k-1);    ReverseArr(nums,0,numsSize-1);    return;&#125;\n\n\n\n结语如果这对你有帮助，还请点个👍支持一下！\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","leetcode"]},{"title":"【C语言】蓝桥杯/ACM竞赛入门 A+B for Input-Output Practice","url":"/posts/2420712993/","content":"[TOC]\n【C语言】蓝桥杯&#x2F;ACM竞赛&#x2F;A+B上次参加了学校的蓝桥杯校队选拔“集训”\n第一次“测试”就直接被考傻了，虽然都是我“好像”学过的内容，但我里里外外真的看不出来到底怎么写，太离谱了！\n而且学长用的都是C++，我只学了c语言，后面的题目完全看不懂了。\n当然，归根结底还是我太菜了\n在这里把我搞了好久终于弄懂的A+B题目分享给大家\n\n开始集训：A+B不有手就行？\n结束后：我手呢?\n\n\n注：题目是英文的！！！！\n\n\nA+B for Input-Output Practice (I)Problem Description \nYour task is to Calculate a + b. \nToo easy?! Of course! I specially designed the problem for acm beginners.  \nYou must have found that some problems have the same titles with this one, yes, all these problems were designed for the same aim.  \nInput \nThe input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line.  \nOutput \nFor each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input.     \nSample Input \n1 510 20\n\nSample Output \n630 \n\n\n\n这道题看起来非常简单，我一上来就打上了两行scanf，啪的一下就提交了\n然后系统啪的一下给我返回了一个大大的红色WRONG ANSWER\n正确做法如下：\n#include&lt;stdio.h&gt;  int main()  &#123;    int a,b;    while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF)       printf(&quot;%d\\n&quot;,a+b);  &#125;   \n\n不能直接使用两行scanf的原因是\n题目需要的是这串代码能完整地使用多次，而不是简单的只执行两次\n在while里使用EOF的原因这里使用eof，可以让程序在未输入错误的情况下一直进行循环计算a+b\nscanf函数的返回值\nscanf函数返回成功读入的数据项数，读入数据时遇到了“文件结束”则返回EOF。\n如：scanf(“%d %d”,&amp;a,&amp;b);\n函数返回值为int型。如果a和b都被成功读入，那么scanf的返回值就是2；\n如果只有a被成功读入，返回值为1；\n如果a和b都未被成功读入，返回值为0；\n如果遇到错误或遇到end of file，返回值为EOF。end of file为Ctrl+z 或者Ctrl+d。\n[摘自百度知道用户@纵横竖屏的回答]\n\nEOF的值为-1，但不能简单的用-1代替EOF\n\nA+B for Input-Output Practice (II)Problem Description \nYour task is to Calculate a + b. \nInput \nInput contains an integer N in the first line, and then N lines follow. Each line consists of a pair of integers a and b, separated by a space, one pair of integers per line.  \nOutput \nFor each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input.  \nSample Input \n21 510 20\n\nSample Output \n630\n\n\n\n这道题的意思其实就是在键入需要相加的数字之前，先键入需要相加的数字组数（也可以理解为行数）\n要求我们用循环的方式完成“相加数字行数”的操作\n完成n行后需要跳出该a+b的循环\n#include&lt;stdio.h&gt;int main()&#123;    int a, b;    int i, j;    int n;    scanf(&quot;%d&quot;, &amp;n);//n即为行数    int sum[20] = &#123; 0 &#125;;    for (i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);        sum[i] = a + b;    &#125;    for (j = 0; j &lt; n; j++)    &#123;        printf(&quot;%d\\n&quot;, sum[j]);    &#125;&#125;\n\n\nA+B for Input-Output Practice (III)Problem Description \nYour task is to Calculate a + b. \nInput \nInput contains multiple test cases. Each test case contains a pair of integers a and b, one pair of integers per line. A test case containing 0 0 terminates the input and this test case is not to be processed.  \nOutput \nFor each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input.  \nSample Input \n1 5 10 200 0 \n\nSample Output \n630\n\n这道题的要求是a+b的程序在读取到两个0 0的时候会退出循环\n且代码不会处理这两个0 0（把它们当作循环结束标志）\n#include&lt;stdio.h&gt;int main()&#123;\tint a = 0, b = 0, c;\twhile (1)\t&#123;\t\tscanf(&quot;%d%d&quot;, &amp;a, &amp;b);\t\tif (a == 0 &amp;&amp; b == 0)//判断键入的是否为0 0\t\t&#123;\t\t\tbreak;//是0 0，退出循环\t\t&#125;\t\telse//不是0 0，继续运行a+b\t\t&#123;\t\t\tc = a + b;\t\t\tprintf(&quot;%d\\n&quot;, c);\t\t&#125;\t\t\t&#125;\treturn 0;&#125;\n\n\nA+B  for  Input-Output  Practice (IV)Description:\nYour task is to Calculate the sum of some integers.\nInput:\nInput contains multiple test cases. Each test case contains a integer N, and then N integers follow in the same line. A test case starting with 0 terminates the input and this test case is not to be processed.\nOutput:\nFor each group of input integers you should output their sum in one line, and with one line of output for each line in input.\nSample Input:\n4 1 2 3 45 1 2 3 4 50 \n\nSample Output:\n1015\n\n与前面的两个数字相加不同，这道题的要求是，先输入你需要相加的数字的个数，再依次键入数字\n遇到0的时候停止循环\n\n这个0必须是第一个数字，即代表需要“0个数字相加”\n如果是需要相加的数字里有0，不应退出循环\n\n#include&lt;stdio.h&gt;int main() &#123;\tint n, sum, i, t;\twhile (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0) //判断是否等于0\t&#123;\t\tsum = 0;\t\tfor (i = 0; i &lt; n; i++) \t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;t);\t\t\tsum = sum + t;//不断往sum里面加数字\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, sum);\t&#125;&#125;\n\n\nA+B  for  Input-Output  Practice (V)Description:\nYour task is to calculate the sum of some integers.\nInput:\nInput contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line.\nOutput:\nFor each group of input integers you should output their sum in one line, and with one line of output for each line in input.\nSample Input:\n24 1 2 3 45 1 2 3 4 5\n\nSample Output:\n1015\n\n这道题和上一道题的要求差不多，结合了第二题的内容，即我们在键入需要相加的数字之前，要先键入“行数”\n当然它也少了在遇到0的时候退出循环\n#include&lt;stdio.h&gt;int main() &#123;\tint n, a, b, i, j, sum;\tsum = 0;\twhile (scanf(&quot;%d\\n&quot;, &amp;n) != EOF) \t&#123;\t\tfor (i = 0; i &lt; n; i++) \t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;b);\t\t\tfor (j = 0; j &lt; b; j++) \t\t\t&#123;\t\t\t\tscanf(&quot;%d&quot;, &amp;a);\t\t\t\tsum += a;\t\t\t&#125;\t\t\tprintf(&quot;%d\\n&quot;, sum);\t\t\tsum = 0;\t\t&#125;\t&#125;&#125;\n\n\nA+B  for  Input-Output  Practice (VI)Description:\nYour task is to calculate the sum of some integers.\nInput:\nInput contains multiple test cases, and one case one line. Each case starts with an integer N, and then N integers follow in the same line.\nOutput:\nFor each test case you should output the sum of N integers in one line, and with one line of output for each line in input.\nSample Input:\n4 1 2 3 45 1 2 3 4 5\n\nSample Output:\n1015\n\n这道题和第四题很像，就缺少了遇到0停止\n#include&lt;stdio.h&gt;int main() &#123;\tint n, sum, i, t;\twhile (scanf(&quot;%d&quot;, &amp;n) != EOF) \t&#123;\t\tsum = 0;\t\tfor (i = 0; i &lt; n; i++) \t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;t);\t\t\tsum = sum + t;\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, sum);\t&#125;&#125;\n\n\nA+B  for  Input-Output  Practice (VII)Description:\nYour task is to Calculate a + b.\nInput:\nThe input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line.\nOutput:\nFor each pair of input integers a and b you should output the sum of a and b, and followed by a blank line.\nSample Input:\n1 510 20\n\nSample Output:\n630\n\n这道题多了一个要求，“followed by a blank line.”\n需要我们在代码完成后，跟着打印一个空行，也就是\\n\n#include&lt;stdio.h&gt;int main()&#123;    int a, b;    while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) != EOF)        printf(&quot;%d\\n&quot;, a + b);        printf(&quot;\\n&quot;);//打印空行    return 0;&#125;\n\n\nA+B  for  Input-Output  Practice (VIII)Description:\nYour task is to calculate the sum of some integers.\nInput:\nInput contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line.\nOutput:\nFor each group of input integers you should output their sum in one line, and you must note that there is a blank line between outputs.\nSample Input:\n34 1 2 3 45 1 2 3 4 53 1 2 3\n\nSample Output:\n10156\n\n这道题的要求结合了上面的题目\n\n需要先键入“行数”\n需要在相加之前键入 需要相加的数字的个数\n打印答案后需要再打印一个 空行\n\n也不怕大家笑话，这道题是我抄的，原博客在这 [点我]\n\n原博客中在for循环的scanf前多了一个if(i&#x3D;&#x3D;0)的代码，我实在没看懂这句代码的意义，去掉之后系统依旧判对！\n\n#include&lt;stdio.h&gt;int main()&#123;    int test,t=0;     scanf(&quot;%d&quot;,&amp;test);//行数    while(test--)//每执行一次，减少一行    &#123;    int s=0,i;    int n,a[1000];//用数组的方式完成相加    scanf(&quot;%d&quot;,&amp;n);//需要相加的数字的个数    for(i=0;i&lt;n;i++)    &#123;            scanf(&quot;%d&quot;,&amp;a[i]);            s+=a[i];    &#125;    t++;    if(t&gt;1)        printf(&quot;\\n&quot;);    printf(&quot;%d\\n&quot;,s);    &#125; return 0;&#125;\n\n\n呼！终于写完这篇博客了\n如果这对你有帮助，还请点赞关注收藏吧！\n这对我真的很重要！\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题"]},{"title":"【leetcode】151. 翻转字符串中的单词","url":"/posts/4154393368/","content":"题目链接 https://leetcode.cn/problems/reverse-words-in-a-string/\n方案1class Solution &#123;public:    //从begin开始找到下一个空格的下标，不包括begin本身    int find_space(string&amp;s,int begin=0)    &#123;        int i=0;        for(i=begin+1;i&lt;s.size();i++)        &#123;            if(s[i]==&#x27; &#x27;)&#123;                return i;            &#125;        &#125;        return s.npos;    &#125;    string reverseWords(string s) &#123;        int i=0;        vector&lt;string&gt; v;//用来存放单词        for(i=0;i&lt;s.size();i++)        &#123;            // 跳过前导空格            while(s[i]==&#x27; &#x27;)&#123;                i++;            &#125;            // 如果已经到最后面了，就直接跳出            if(i&gt;=s.size())&#123;                break;            &#125;            int index = find_space(s,i);            int sz = index-i;//单词长度            //cout &lt;&lt; i &lt;&lt; &quot; | &quot; &lt;&lt; index &lt;&lt; &quot; | &quot;&lt;&lt; sz &lt;&lt; endl;            string temp(s,i,sz);            //cout &lt;&lt; temp &lt;&lt; &quot;-&quot; &lt;&lt; endl;            v.push_back(temp);//插入单词            i = index-1;//跳过当前单词        &#125;        //反向迭代器        auto it = v.rbegin();        string ret = &quot;&quot;;        while(it!=v.rend())        &#123;            ret+=*it;            // 不是倒数第一个才加空格            if(++it!=v.rend())&#123;                ret+=&quot; &quot;;            &#125;        &#125;        cout &lt;&lt; ret &lt;&lt; endl;        return ret;    &#125;&#125;;\n\n上面的办法中，新增了一个vector来拼接字符串，空间复杂度O(N)\n测试 4MS 7.2MB\n版本2进阶要求：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\n//版本2，原地算法吗？class Solution &#123;public:    #define SEP &#x27;|&#x27;    //从begin开始找到下一个空格的下标，不包括begin本身    int find_space(string&amp;s,int begin=0)    &#123;        int i=0;        for(i=begin+1;i&lt;s.size();i++)        &#123;            if(s[i]==&#x27; &#x27;)&#123;                break;            &#125;            else if(s[i]==SEP)            &#123;//用一个特殊字符作为原字符串结尾                break;            &#125;        &#125;        //如果是因为找到空格跳出，判断该字符串后面还有没有有效字符        int k = i;//不能改i        if(s[k]!=SEP)        &#123;            while(s[k]==&#x27; &#x27;)            &#123;                k++;                //一直走到了|，代表没有有效字符了                if(s[k]==SEP)&#123;                    return s.npos;                &#125;            &#125;            //走到这里代表有            return i;        &#125;        return s.npos;    &#125;    string reverseWords(string s) &#123;        int i=0,end_word=0,index=0;        int begin_sz = s.size();//起始大小        s+=SEP;//用一个特殊字符作为原字符串结尾        int sep_index = s.size()-1;//最后一个字符的位置就是分隔符                for(i=0;i&lt;begin_sz;i++)        &#123;            // 跳过前导空格            while(s[i]==&#x27; &#x27;)&#123;                i++;            &#125;            // 如果已经到最后面了，就直接跳出            if(i&gt;=begin_sz)&#123;                break;            &#125;            index = find_space(s,i);            //如果找不到下一个空格了，代表当前是原字符串最后一个单词            //跳过            if(index == s.npos)&#123;                end_word=i;                break;            &#125;            int sz = index-i;//单词长度            string temp(s,i,sz);            temp+=&quot; &quot;;            //不能尾插，应该在sep之后插入            //s += temp;            s.insert(sep_index+1,temp);            // cout &lt;&lt; i &lt;&lt; &quot; | &quot; &lt;&lt; index &lt;&lt; &quot; | &quot;&lt;&lt; sz &lt;&lt; endl;            // cout &lt;&lt; temp &lt;&lt; &quot;-&quot; &lt;&lt; endl;            //构造了之后，把原str这部分删了(错误！删了之后下标变了，循环无意义)            //s.erase(i,sz);            i = index-1;//跳过当前单词            //index-1是因为本次循环过了之后会被for给+1        &#125;        cout &lt;&lt;&quot;[end]&quot;&lt;&lt; s &lt;&lt; endl;        // 字符串中添加的|替换为空格        index = s.find(SEP);                // 删除index之前,end_word之后的空格        int k = s.find(&quot; &quot;,end_word);        //cout &lt;&lt; &quot;k:&quot; &lt;&lt;k&lt;&lt;&quot; endw:&quot; &lt;&lt; end_word &lt;&lt;endl;        if(k!=s.npos&amp;&amp;k&lt;index)&#123;            s.replace(k,1,&quot;&quot;);            index--;            //cout &lt;&lt;&quot;[while1]k:&quot;&lt;&lt;k &lt;&lt;&quot; str:&quot;&lt;&lt; s &lt;&lt; endl;            //因为替换过了之后，k的位置变成了原有k的下一位            //此时如果k还是空格，代表原字符串末尾有多个空格            //继续删除，但是每次删除都需要让sep的位置-1            while(s[k]==&#x27; &#x27;)&#123;                s.replace(k,1,&quot;&quot;);                index--;            &#125;            //跳出这个循环的时候，代表碰到sep分隔符了,字符串已经处理完毕            //cout &lt;&lt;&quot;[while2]k:&quot;&lt;&lt;k &lt;&lt;&quot; str:&quot;&lt;&lt; s &lt;&lt; endl;        &#125;        s.replace(index,1,&quot; &quot;);        s.erase(0,end_word);//删掉前面的原有单词        s.erase(s.size()-1,1);//删除最后单词带的空格        return s;    &#125;&#125;;\n\n结果 4MS 7MB\n方案3上面的办法看起来很对，实际上还是不是原地算法！\n因为我每次都是在后面尾随字符串，而没有把原字符串删掉。如果源字符串很长，我这么做就相当于把源字符串的长度变为原有俩倍\n\n依旧是O(N)的空间复杂度\n\n要想做到真原地，就需要在插入到指定位置的同时，将其原本的字符串给删除了\n//方案3class Solution &#123;public:    #define SEP &#x27;|&#x27;    //从begin开始找到下一个空格的下标，不包括begin本身    int find_space(string&amp;s,int begin=0)    &#123;        int i=0;        for(i=begin+1;i&lt;s.size();i++)        &#123;            if(s[i]==&#x27; &#x27;)&#123;                break;            &#125;            else if(s[i]==SEP)            &#123;//用一个特殊字符作为原字符串结尾                break;            &#125;        &#125;        //如果是因为找到空格跳出，判断该字符串后面还有没有有效字符        int k = i;//不能改i        if(s[k]!=SEP)        &#123;            while(s[k]==&#x27; &#x27;)            &#123;                k++;                //一直走到了|，代表没有有效字符了                if(s[k]==SEP)&#123;                    return s.npos;                &#125;            &#125;            //走到这里代表有            return i;        &#125;        return s.npos;    &#125;    string reverseWords(string s) &#123;        int i=0,end_word=0,index=0;        int begin_sz = s.size();//起始大小        s+=SEP;//用一个特殊字符作为原字符串结尾        int sep_index = s.size()-1;//最后一个字符的位置就是分隔符                for(i=0;i&lt;begin_sz;i++)        &#123;            // 跳过前导空格            while(s[i]==&#x27; &#x27;)&#123;                i++;            &#125;            // 如果已经到最后面了，就直接跳出            if(i&gt;=begin_sz)&#123;                break;            &#125;            index = find_space(s,i);            //如果找不到下一个空格了，代表当前是原字符串最后一个单词            //跳过            if(index == s.npos)&#123;                end_word=i;                break;            &#125;            int sz = index-i;//单词长度            string temp(s,i,sz);            temp+=&quot; &quot;;            //不能尾插，应该在sep之后插入            //s += temp;            s.insert(sep_index+1,temp);            //printf(&quot;[%d-%d-1]%s\\n&quot;,i,sep_index,s.c_str());            // cout &lt;&lt; i &lt;&lt; &quot; | &quot; &lt;&lt; index &lt;&lt; &quot; | &quot;&lt;&lt; sz &lt;&lt; endl;            // cout &lt;&lt; temp &lt;&lt; &quot;-&quot; &lt;&lt; endl;            //构造了之后，把原str这部分删了(错误！删了之后下标变了，循环无意义)            s.erase(i,sz);            sep_index-=sz;            //printf(&quot;[%d-%d-2]%s\\n&quot;,i,sep_index,s.c_str());            // i = i;//跳过当前单词            //index-1是因为本次循环过了之后会被for给+1        &#125;        //cout &lt;&lt;&quot;[end]&quot;&lt;&lt; s &lt;&lt; endl;        index = s.find(SEP);        // 删除index之前,end_word之后的空格        int k = s.find(&quot; &quot;,0);        //cout &lt;&lt; &quot;k:&quot; &lt;&lt;k&lt;&lt;&quot; endw:&quot; &lt;&lt; end_word &lt;&lt;endl;        while(k!=s.npos&amp;&amp;k&lt;index)&#123;            s.replace(k,1,&quot;&quot;);            index--;            //cout &lt;&lt;&quot;[while1]k:&quot;&lt;&lt;k &lt;&lt;&quot; str:&quot;&lt;&lt; s &lt;&lt; endl;            //因为替换过了之后，k的位置变成了原有k的下一位            //此时如果k还是空格，代表原字符串末尾有多个空格            //继续删除，但是每次删除都需要让sep的位置-1            while(s[k]==&#x27; &#x27;)&#123;                s.replace(k,1,&quot;&quot;);                index--;            &#125;            //跳出这个循环的时候，代表碰到sep分隔符了,字符串已经处理完毕            //cout &lt;&lt;&quot;[while2]k:&quot;&lt;&lt;k &lt;&lt;&quot; str:&quot;&lt;&lt; s &lt;&lt; endl;            k = s.find(&quot; &quot;,0);        &#125;        //cout &lt;&lt;&quot;[end2]&quot;&lt;&lt; s &lt;&lt; endl;        s[index]=&#x27; &#x27;;        //s.erase(0,end_word);//删掉前面的原有单词        s.erase(s.size()-1,1);//删除最后单词带的空格        //cout &lt;&lt;&quot;[return]&quot;&lt;&lt; s &lt;&lt; endl;        return s;    &#125;&#125;;\n\n思路4，来自代码随想录P92详见注释\n//思路4，来自代码随想录P92class Solution &#123;public:    //删除空格，时间复杂度O(N)    void removeSpace(string&amp; s)    &#123;        int slow=0,fast=0;        //这个循环结束后，fast会走到第一个不为空格的字符上        while(s.size()&gt;0 &amp;&amp; fast&lt; s.size()&amp;&amp;s[fast]==&#x27; &#x27;)&#123;            fast++;        &#125;        //此时开始复写（也会将字符串开头的空格给替换掉）        for(/*不写第一个，fast的位置没有变动*/;fast&lt;s.size();fast++)        &#123;               //fast要大于1才能判断fast上一位            //上一位和这一位不相等（判端连续空格）            //当前位是否位空格（是就代表是连续空格）            //continue会找到一段空格之后的第一个非空格字符            if(fast&gt;1 &amp;&amp; s[fast-1] == s[fast]                        &amp;&amp; s[fast]==&#x27; &#x27;)                continue;            else            &#123;//复写                s[slow]=s[fast];                slow++;            &#125;        &#125;        //复写结束后，此时slow所在位置是原有字符串的末尾，且会有一个多余的空格        //因为在上面替换的时候，已经将多余的空格跳过了，所以只会有一个空格        //只需要判断有没有空格，将其去掉就行        //注意，此时slow所在位置可能是源字符串中的字母上，并不一定是空格        if(slow&gt;1 &amp;&amp; s[slow-1]==&#x27; &#x27;)        &#123;            s.resize(slow-1);        &#125;        else        &#123;            s.resize(slow);        &#125;    &#125;        //逆置字符串    //每次逆置的时间复杂度为O((START-END)/2)    void revserseString(string&amp;s,int start,int end)    &#123;        //等于的情况也是可以的，只不过此时压根不做交换        assert(end&lt;s.size()&amp;&amp;start&lt;=end);        int i=start,j=end;        for(;i&lt;j;i++,j--)        &#123;            swap(s[i],s[j]);        &#125;    &#125;    //思路有点类似`189轮转数组`中的三旋法    //先去掉冗余空格    //把整个字符串逆置    //再单独逆置所有单词    string reverseWords(string s) &#123;        //删多余空格        removeSpace(s);        //逆置字符串        revserseString(s,0,s.size()-1);        //printf(&quot;|%s|\\n&quot;,s.c_str());        //扫描出单词，逆置每个单词        //因为已经删除多余空格了，所以s[0]肯定是单词        int begin=0,cur=1;        while(cur&lt;s.size() &amp;&amp; begin&lt;s.size())        &#123;            //当前不是空格++            while(cur!=begin&amp;&amp;s[cur]!=&#x27; &#x27;&amp;&amp;cur&lt;s.size())            &#123;                //cout &lt;&lt; begin &lt;&lt; &quot;-&quot; &lt;&lt; cur&lt;&lt; &quot;-&quot; &lt;&lt; s[cur]&lt;&lt;endl;                cur++;            &#125;            //停下来代表是空格,逆置            //如果是最后一个单词，停下来的时候是因为cur==s.size()            //此时cur-1就正好是倒数第一个字符            //cout &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; cur &lt;&lt;endl;            revserseString(s,begin,cur-1);            //更新下标            begin= cur+1;            cur+=2;//保证cur是begin的下一位        &#125;        return s;    &#125;&#125;;\n\n测试 4MS 6.8MB\n一定要记得删除printf以后写oj的时候，一定要记得删除用来debug的printf，否则用时特别特别长！\n如下相同代码，删除pirntf之后快了十倍\n\n","categories":["把题目都给刷干净"],"tags":["C++","OJ刷题","leetcode"]},{"title":"【MySQL】复合查询 | 内外链接（未完成）","url":"/posts/2529084145/","content":"各类复合查询和笛卡尔积、内外链接的操作\n\n\n1.基础查询在之前的MySQL的CURD基本操作博客中，讲述了一部分查询的语法，但是在实际的生产活动中，那种最基础的查询方式不足以满足复杂查询条件时的要求，所以在普通查询的基础上，MySQL还提供了功能更强大的复合查询，本文就让我们一起来学学复合查询的操作吧！\n\n依旧是使用scott提供的这张表，来进行复合查询的操作。\n\n在那之前，先复习一下普通查询的基本操作吧！\n\n查询工资高于500或者岗位为MANAGER的成员，同时他们的姓名首字母为大写J\n\nselect * from emp where (sal &gt; 500 or job = &#x27;MANAGER&#x27;) and ename like &#x27;J%&#x27;;\n\n\n按照部门号升序、雇员的工资降序排序\n\nselect * from emp order by deptno, sal desc;\n\n\n显示工资高于平均工资的员工信息\n\nselect * from emp where sal &gt; (select avg(sal) from emp);\n\n\n显示每个部门的平均工资和最高工资\n\nselect deptno, avg(sal), max(sal) from emp group by deptno;\n\n\n显示每种岗位的雇员数量和平均工资\n\nselect job,count(*),avg(sal) from emp group by job;-- 默认情况下会保留6位小数，可以用format函数保留到2位select job,count(*),format(avg(sal),2) from emp group by job;-- 格式化后的输出结果如下+-----------+----------+--------------------+| job       | count(*) | format(avg(sal),2) |+-----------+----------+--------------------+| ANALYST   |        2 | 3,000.00           || CLERK     |        4 | 1,037.50           || MANAGER   |        3 | 2,758.33           || PRESIDENT |        1 | 5,000.00           || SALESMAN  |        4 | 1,400.00           |+-----------+----------+--------------------+5 rows in set (0.000 sec)\n\n2.多表查询基础查询的操作就复习上面几个就差不多了，接下来我们先看复合查询的第一个大点，多表查询。\n所谓多表查询，就是将一个表和另外一个表合并，再在这个合并了之后的表里面进行查询；\n\n比如：显示雇员名、雇员工资以及所在部门的名字\n\n因为雇员名是在emp表里面，部门名字是在dept表里面，所以我们就需要进行多表的联合查询才能一次取到结果（一次查询的效率优于两次独立查询）\n其基本语句就是在from后面添加多个表，并使用表名.表中字段名来指定某一个表中的字段；如果这个字段只有一个表中有，那就可以不用指定表名（但依旧建议指定表名避免出错）\nselect * from 表1,表2,...;\n\n2.1 笛卡尔积先来一个全列查询，看看效果\nselect * from emp,dept;\n\n可以看到，dept表直接拼接在了emp表之后，而且emp表中的每一个值都被根据dept中不同的部门ID重复了4次。这是因为在MySQL中，他并不知道你需要什么数据，所以进行数据拼接的时候，是采用穷举的方式来拼接的！\n这个不加任何过滤条件，穷举拼接得到的结果被称为笛卡尔积！\n\n2.2 指定条件接下来再回到上面提到的问题：显示雇员名、雇员工资以及所在部门的名字；\nselect emp.ename,emp.sal,dept.dname from emp,dept;\n\n虽然我们选中了我们需要的列来显示，但依旧没有解决笛卡尔积中穷举出来的无效数据；\n\n这时候就需要添加上筛选条件，来剔除掉无效的数据。\n和当前员工的部门编号不同的部门数据就是无效的，我们添加上员工部门编号和部门表中的部门编号相同的条件，就可以剔除掉无效的数据。\nselect emp.ename,emp.sal,dept.dname from emp,dept where emp.deptno = dept.deptno;\n\n这时候筛选出来的数据，才是正确的每个员工和其对应的部门名字的数据；每个员工也不在会重复4次了。\nMariaDB [scott]&gt; select emp.ename,emp.sal,dept.dname from emp,dept where emp.deptno = dept.deptno;+--------+---------+------------+| ename  | sal     | dname      |+--------+---------+------------+| SMITH  |  800.00 | RESEARCH   || ALLEN  | 1600.00 | SALES      || WARD   | 1250.00 | SALES      || JONES  | 2975.00 | RESEARCH   || MARTIN | 1250.00 | SALES      || BLAKE  | 2850.00 | SALES      || CLARK  | 2450.00 | ACCOUNTING || SCOTT  | 3000.00 | RESEARCH   || KING   | 5000.00 | ACCOUNTING || TURNER | 1500.00 | SALES      || ADAMS  | 1100.00 | RESEARCH   || JAMES  |  950.00 | SALES      || FORD   | 3000.00 | RESEARCH   || MILLER | 1300.00 | ACCOUNTING |+--------+---------+------------+14 rows in set (0.004 sec)\n\n再来做两个小练习\n-- 显示部门号为10的部门名字，员工名字和员工工资；MariaDB [scott]&gt; select emp.ename,emp.sal,dept.dname from emp,dept where emp.deptno = dept.deptno and dept.deptno = 10;+--------+---------+------------+| ename  | sal     | dname      |+--------+---------+------------+| CLARK  | 2450.00 | ACCOUNTING || KING   | 5000.00 | ACCOUNTING || MILLER | 1300.00 | ACCOUNTING |+--------+---------+------------+3 rows in set (0.001 sec)-- 显示各个部门员工的姓名，工资，工资级别MariaDB [scott]&gt; select emp.ename,emp.sal,salgrade.grade from emp,salgrade where emp.sal between losal and hisal;+--------+---------+-------+| ename  | sal     | grade |+--------+---------+-------+| SMITH  |  800.00 |     1 || ALLEN  | 1600.00 |     3 || WARD   | 1250.00 |     2 || JONES  | 2975.00 |     4 || MARTIN | 1250.00 |     2 || BLAKE  | 2850.00 |     4 || CLARK  | 2450.00 |     4 || SCOTT  | 3000.00 |     4 || KING   | 5000.00 |     5 || TURNER | 1500.00 |     3 || ADAMS  | 1100.00 |     1 || JAMES  |  950.00 |     1 || FORD   | 3000.00 |     4 || MILLER | 1300.00 |     2 |+--------+---------+-------+14 rows in set (0.001 sec)\n\n3.自链接所谓自连接，是在同一张表中进行链接和查询\n比如显示员工FORD上级领导的员工编号和姓名\n-- 使用子查询select empno,ename from emp where emp.empno=(select mgr from emp whereename=&#x27;FORD&#x27;);-- 使用多表查询（其实是给emp表起两个不同的别名）select leader.empno,leader.ename from emp leader, emp worker whereleader.empno = worker.mgr and worker.ename=&#x27;FORD&#x27;;\n\n这种在一张表里面进行笛卡儿积的查询操作，就叫做自链接。最终都可以获取到正确结果\n+--------+-------+| empno  | ename |+--------+-------+| 007566 | JONES |+--------+-------+1 row in set (0.001 sec)\n\n4.子查询子查询值得是，将一个查询语句作为子操作，嵌入到一个sql语句中；\n我们可以把子查询的结果也当作是一张表来进行处理，这样一想就能理解子查询是怎么玩的了。\n4.1 单行子查询显示和SMITH同一个部门的员工\nselect * from emp where deptno = (select deptno from emp where ename=&#x27;smith&#x27;);\n\n在这个查询中，子查询语句是(select deptno from emp where ename=&#39;smith&#39;)，这个语句返回的结果只有一行，所以被称为单行子查询；\n4.2 多行子查询有单行查询，自然也有多行查询。但是如果一个语句返回了多条结果，将其直接作为判据肯定是不行的，这会导致判据不唯一，MySQL不知道你到底想要比较的是那一部分的数据。这时候就需要用下面几个关键字来帮忙了\n\nin：查询存在于某某结果里面的数据\nall：查询比这个结果中所有值都大&#x2F;小的数据\nany：查询比这个结果中某一个值大&#x2F;小的数据\n\n以下是几个示例\n-- 查询和10号部门工作岗位相同的员工名字、岗位、工资、部门号，但是不包含10号部门自己的员工select ename,job,sal,deptno from emp where job in (select job from emp where deptno=10) and deptno &lt;&gt; 10;+-------+---------+---------+--------+| ename | job     | sal     | deptno |+-------+---------+---------+--------+| SMITH | CLERK   |  800.00 |     20 || JONES | MANAGER | 2975.00 |     20 || BLAKE | MANAGER | 2850.00 |     30 || ADAMS | CLERK   | 1100.00 |     20 || JAMES | CLERK   |  950.00 |     30 |+-------+---------+---------+--------+5 rows in set (0.001 sec)\n\n-- 显示部门工资比30号部门所有员工工资都高的员工姓名、工资、部门号select ename,sal,deptno from emp where sal &gt; all(select sal from emp where deptno = 30);+-------+---------+--------+| ename | sal     | deptno |+-------+---------+--------+| JONES | 2975.00 |     20 || SCOTT | 3000.00 |     20 || KING  | 5000.00 |     10 || FORD  | 3000.00 |     20 |+-------+---------+--------+4 rows in set (0.001 sec)\n\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】索引","url":"/posts/3474107655/","content":"1.索引1.1 为啥需要索引？对于数据库而言，查询始终是一个高频的操作；假设在数据量到百万级的时候，查询一个用户信息就要花5秒中，那用户肯定不愿意等待你的系统响应，这就造成了用户流失。\n所以，MySQL必须使用某种方式来保证查询的高速可靠，索引就诞生了；\n对于使用者而言，索引是很香的，因为你只需要执行create index给指定的列，那么MySQL就会自动帮你维护一系列索引创建的操作，查询嘎嘎快！\n但，查询速度的提高是以插入、更新、删除等操作的速度为代价的，这些写操作会增加大量的IO；索引的价值在于提高海量数据的查询速度；\n常见的索引\n\n主键索引\n唯一键索引\n普通索引\n复合索引\n全文索引\n\n1.2 索引的效果通过如下的大数据用例，我们能看到索引的效果几何\ndrop database if exists `bit_index`;create database if not exists `bit_index` default character set utf8;use `bit_index`;-- 构建一个8000000条记录的数据-- 构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解-- 产生随机字符串delimiter $$create function rand_string(n INT)returns varchar(255)begindeclare chars_str varchar(100) default&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;declare return_str varchar(255) default &#x27;&#x27;;declare i int default 0;while i &lt; n doset return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1));set i = i + 1;end while;return return_str;end $$delimiter ;-- 产生随机数字delimiter $$create function rand_num( )returns int(5)begindeclare i int default 0;set i = floor(10+rand()*500);return i;end $$delimiter ;-- 创建存储过程，向雇员表添加海量数据delimiter $$create procedure insert_emp(in start int(10),in max_num int(10))begindeclare i int default 0;set autocommit = 0;repeatset i = i + 1;insert into EMP values ((start+i),rand_string(6),&#x27;SALESMAN&#x27;,0001,curdate(),2000,400,rand_num());until i = max_numend repeat;commit;end $$delimiter ;-- 雇员表CREATE TABLE `EMP` (  `empno` int(6) unsigned zerofill NOT NULL COMMENT &#x27;雇员编号&#x27;,  `ename` varchar(10) DEFAULT NULL COMMENT &#x27;雇员姓名&#x27;,  `job` varchar(9) DEFAULT NULL COMMENT &#x27;雇员职位&#x27;,  `mgr` int(4) unsigned zerofill DEFAULT NULL COMMENT &#x27;雇员领导编号&#x27;,  `hiredate` datetime DEFAULT NULL COMMENT &#x27;雇佣时间&#x27;,  `sal` decimal(7,2) DEFAULT NULL COMMENT &#x27;工资月薪&#x27;,  `comm` decimal(7,2) DEFAULT NULL COMMENT &#x27;奖金&#x27;,  `deptno` int(2) unsigned zerofill DEFAULT NULL COMMENT &#x27;部门编号&#x27;);-- 执行存储过程，添加8000000条记录call insert_emp(100001, 8000000);\n\n在这个表里面，有大量的数据，其默认状态下，并没有配置索引\nMariaDB [bit_index]&gt; desc EMP;+----------+--------------------------+------+-----+---------+-------+| Field    | Type                     | Null | Key | Default | Extra |+----------+--------------------------+------+-----+---------+-------+| empno    | int(6) unsigned zerofill | NO   |     | NULL    |       || ename    | varchar(10)              | YES  |     | NULL    |       || job      | varchar(9)               | YES  |     | NULL    |       || mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       || hiredate | datetime                 | YES  |     | NULL    |       || sal      | decimal(7,2)             | YES  |     | NULL    |       || comm     | decimal(7,2)             | YES  |     | NULL    |       || deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |+----------+--------------------------+------+-----+---------+-------+8 rows in set (0.001 sec)\n\n此时如果你直接全列查询，进程就会阻塞在这里\n\n进MySQL的文件路径看看，会发现这张表的大小已经到了惊人的564mb，虽然我们的内存也许能存的下这么大的数据，但实际IO读写这么大量的数据是非常耗时的\n[root@vm-cnt8:/var/lib/mysql/bit_index]# ll -htotal 565M-rw-rw----. 1 mysql mysql   61 Sep  6 05:36 db.opt-rw-rw----. 1 mysql mysql  770 Sep  6 05:36 EMP.frm-rw-rw----. 1 mysql mysql 564M Sep  6 05:39 EMP.ibd\n\n在之前的查询操作中提到过，对于这种大数据表的时候，我们应该避免使用全列查询，而应该设置limit只查询出少量用例数据，来判断这个表的数据结构和作用\nMariaDB [bit_index]&gt; select * from EMP limit 3;+--------+--------+----------+------+---------------------+---------+--------+--------+| empno  | ename  | job      | mgr  | hiredate            | sal     | comm   | deptno |+--------+--------+----------+------+---------------------+---------+--------+--------+| 100002 | FNXAKX | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    327 || 100003 | rQbLBy | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    394 || 100004 | wRVdDF | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    195 |+--------+--------+----------+------+---------------------+---------+--------+--------+3 rows in set (0.001 sec)\n\n在没有索引的情况下进行一个查询，用时大约在1.6秒左右\n\n这时候我们来对empno列创建一个主键索引\nalter table EMP add primary key(empno);\n\n因为表中的数据很多，所以设置主键索引也需要耗费一定时间，这个时间内，其实就是MySQL在后台帮我们创建索引所需要的数据结构的过程\nMariaDB [bit_index]&gt; alter table EMP add primary key(empno);Query OK, 0 rows affected (17.184 sec)              Records: 0  Duplicates: 0  Warnings: 0\n\n再来查询一下刚刚查询的数据，可以看到，用时只有0.000 sec，直接秒回！\n\n这便是索引在提升性能方面的重大作用！\n1.3 MySQL和文件系统1.3.1 Linux文件系统在之前对Linux文件系统的学习中，我们知道在磁盘中，一个区块是512KB，在Linux系统中，为了提高效率，会采用4KB的分块对数据进行读取。哪怕你只是修改1KB，也是需要将4KB完整读取，再写入回去的。\n\n因为机械硬盘物理结构的限制，随机读取的性能不佳，一次性读取100KB数据，远远优于100次读取1KB。因为一次性读取的时候，只需要一次寻道就能将磁头摆到正确的位置，往里面写数据就完事了。但多次读取小数据的时候，尽管相邻的两次IO操作在同一时刻发出，但如果它们的请求的扇区地址相差很大的话也只能称为随机访问，而非连续访问。\n随机访问就要多次寻道，每次写入的量又很少，大大增加了IO的负担。\n1.3.2 MySQL和磁盘交互基本单位 16KB而MySQL中，为了更好的实现对数据IO量的缩减和控制，其内部将16KB作为一次IO的基本单位，这个大小我们叫做MySQL的文件Page；\n\nMySQL中的数据文件，都是以Page为基本单位保存至磁盘里面的；\nMySQL中的CURD操作，都需要通过计算来定位到需要修改和访问的数据的位置；\n涉及到计算的操作都需要CPU参与，CPU只能处理内存中的数据，这就要求MySQL需要提前将一部分数据加载到内存中；\n所以在MySQL运行的这段时间内，其操作的数据会同时存在于内存和磁盘中，需要以特定的策略将内存中的数据刷新到磁盘中；这个操作就是IO，基本单位是Page；\n为了更好的管理这些操作，MySQL会自己维护一个buffer pool的内存空间，来进行缓存。\nMySQL是一个应用程序，它的所有文件IO操作都需要通过操作系统提供的接口来实现！但内部的刷盘逻辑是可以由MySQL来调用系统接口来自主控制的，而不需要呆板地遵守操作系统的自动策略；（MySQL创建buffer pool也是基于更高的自主性来考虑的）\n最终目标是尽可能地减少IO操作，提高运行效率；\n\n运行如下命令可以看到MySQL中关于Page设置的全局变量，即16KB\nMariaDB [bit_index]&gt; SHOW GLOBAL STATUS LIKE &#x27;innodb_page_size&#x27;;+------------------+-------+| Variable_name    | Value |+------------------+-------+| Innodb_page_size | 16384 |+------------------+-------+1 row in set (0.001 sec)\n\n1.3.3 为什么要用Page为单位进行交互？为何MySQL和磁盘进行IO交互的时候，要采用Page的方案进行交互呢？用多少，加载多少不香吗？\n先来个测试用例看看吧，这是一个非常简单的用户表\n-- 主键默认生成主键索引create table if not exists user (    id int primary key,     age int not null,    name varchar(16) not null);-- 插入多条记录，主键没有按顺序插入mysql&gt; insert into user (id, age, name) values(3, 18, &#x27;杨过&#x27;);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into user (id, age, name) values(4, 16, &#x27;小龙女&#x27;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into user (id, age, name) values(2, 26, &#x27;黄蓉&#x27;);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into user (id, age, name) values(5, 36, &#x27;郭靖&#x27;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into user (id, age, name) values(1, 56, &#x27;欧阳锋&#x27;);Query OK, 1 row affected (0.00 sec)-- 最终发现数据是有序的mysql&gt; select * from user; +----+-----+-----------+| id | age | name      |+----+-----+-----------+| 1  | 56  | 欧阳锋     || 2  | 26  | 黄蓉       || 3  | 18  | 杨过       || 4  | 16  | 小龙女     || 5  | 36  | 郭靖       |+----+-----+-----------+5 rows in set (0.00 sec)\n\n在上面的5条记录中，如果MySQL要查找id&#x3D;2的记录，第一次加载id&#x3D;1，第二次加载id&#x3D;2，一次一条记录，那么就需要2次IO。如果要找id&#x3D;5，那么就需要5次IO。\n但，如果这5条(或者更多)都被保存在一个Page中(16KB，能保存很多记录)，那么第一次IO查找id&#x3D;2的时候，整个Page会被加载到MySQL的Buffer Pool中，这里完成了一次IO。但是往后如果在查找id&#x3D;1,3,4,5等，完全不需要进行IO了，而是直接在内存中进行了。所以，就在单Page里面，大大减少了IO的次数！\n虽然我们不能保证后续的几次IO一定在这次加载的Page中，但根据局部性原理，其访问相近的几条数据的概率是很大的！所以这样最终是能提升IO效率的！\n往往IO效率低下的最主要矛盾不是IO单次数据量的大小，而是IO的次数。\n1.4 B+树和Page有了对Page的认识，接下来就需要用一个数据结构来维护这些加载到Buffer Pool当中的Page了。这时候，我们的B+树就登场了。\n1.4.1 单个Page单个Page里面存放的肯定是一部分的数据，我们可以加上前后指针，以双链表的形式将所有Page连起来，这样就能实现数据的遍历；在MySQL中，就是这么操作的。\n\n因为存在主键，MySQL还会给单个Page中的数据依照主键进行排序，从上图就能看出阿里，单个Page中数据是依照主键按序排列的；且每一个数据都会链接到下一个数据上；\n这样排序后，数据库在进行数据筛选的时候，就能更好的定位到数据的位置，减少查询耗时。插入时排序也能让后续在进行数据降序&#x2F;升序输出的时候，无需二次对数据进行排序了；\n1.4.2 多个Page既然一个Page是如此，那多个Page呢？\n\n前面提到了，当MySQL需要加载数据的时候，会将和这个数据相邻近的其他数据，以16KB为单位一起加载到一个Page里面，并连接到这个双向链表上；\n这样，我们就可以通过多个Page的遍历来进行数据的定位\n可链表是一个线性结构，MySQL肯定不可能用线性结构来维护数据吧？那样查询的效率也太低了，每次都需要O(N)的遍历，数据一多就慢慢慢！\n\n\n所以，我们肯定要在双向链表的基础上添加其他的结构来进行查找的优化！这时候就可以引入目录了\n页目录在我们看书的时候，就会有目录来帮助我们快速查找到某一个章节。比如我们想看第九章的内容，那就可以先看目录，找到第九章的页码，再进行阅读。\n对于MySQL中的数据，这个情景也是适用的，我们给数据上一个目录，查询的时候先根据目录定位到具体的page，我们可以知道1-10号数据都在这个page里面，那就直接去里面找就行了；这时候查找的效率就比单纯的从链表开头进行遍历快多了！\n当然，和书籍的目录需要消耗纸张一样，在MySQL中对数据设置目录也是需要消耗空间的，这就是一种用空间换时间的做法，而在生产环境中，时间显然更加宝贵！\n单页目录在单个Page里面，我们可以安如下的方式设定一个目录，嗝一定间隔就设置一个新的节点作为目录。在数据量小的时候，这个目录的作用不算大，但数据量一大，目录对搜索效率的提升是非常可观的！\n\n比如，我们要查找id&#x3D;4记录，之前必须线性遍历4次，才能拿到结果。现在直接通过目录2[3]，直接进行定位新的起始位置，只需要遍历3次就能找到结果，提高了效率。\n\n即便在单个Page中添加目录会导致这个Page实际存放的数据变少，但这是必要的牺牲！\n\n多页目录前面提到，MySQL会自动把新的数据加载到一个Page中，并链接到已有链表上；但是线性遍历需要大量的IO，每次遇到新的Page的时候，就需要将其加载到内存里面，进行遍历，这就使得单个Page中的目录不那么实用了；\n\n单个Page的目录是小节目录\n多个Page的目录是章节目录\n\n所以我们必须给多个Page也加上一个顶层的章节目录，进一步优化效率！\n\n使用一个Page来指向多个Page，存放每个Page的起始key值（假设每个Page中的key都有序且为升序）；这个Page中不存放实际的数据，只有目录值；\n遍历的时候，先通过多Page的目录找到我们要去的Page，再去访问该实际存储数据的Page中的单Page目录，最终查找到目标数据；\n所以，每个多Page的目录项中就是一个键值+对应普通Page的指针\n\n\n一层目录Page不够，我们还可以再加一层。这样就实现了一个类似于二叉树的结构，只不过每一个节点Page中都包含多个Page的key+指针，最终只有叶子节点是实际存储数据的！\n\n这个数据结构就叫做B+树（注意，不是B树！）而整个上图中的数据接就是MySQL中对user表做的索引！\n此时的查询，需要经过的节点肯定变少了，比如我们需要查询id=12的用户：\n\n顶层判断，12&gt;11&gt;1，向右走【2次比较】\n第二层判断，12&gt;11且12&lt;16，向左走，来到具体的Page【2次比较】\n查找单页目录，12&gt;11且12&lt;13；【2次比较】\n从11开始遍历，走一步就能找到【1次比较】\n\n最终，我们查找12的操作只用了7次就成功了。而从投开始遍历需要12次才能找到它；\n遍历次数的减少，就等同于IO次数的减少，最终查询的效率就变高了！\n\n这里的分析可能有误，不过结论是没有问题的，分页肯定能增加查找的效率！\n\n另外，MySQL还可以根据访问的频率，定期的释放一些Page；比如在B+树中，可能树的右半部分很少被访问，那就可以暂时释放这部分Page的空间，给其他表使用，真到遇到访问的时候，再去读盘去除这部分数据。这是由MySQL的缓存策略来自主决定的；\n毕竟当一个表非常大的时候，将其全部加载到内存里面是不可行的！必须要用缓存策略和局部性原理来加载频繁使用的数据到内存中，才能在效率和负载上达到平衡；\n不然你的MySQL无脑缓存Page导致占用过多内存，操作系统看不下去直接给你KILL了，那业务就完蛋了！🤣\n1.4.3 小结\nPage分为目录页和数据页。目录页只放各个下级Page的最小键值和该Page的指针。\n查找的时候，自顶向下找，只需要加载部分目录页到内存，即可完成算法的整个查找过程，大大减少了IO次数\n范围查询的时候，可以找到区间边界的两个节点的位置，然后直接通过叶子节点的链表进行遍历，取出数据即可！\nMySQL可以根据访问频率，适当地预先加载或者释放一些Page的空间，并不是说一张表的所有数据都必须全部加载到内存里面；\n\n后续我还会学习B树和B+树数据结构在CPP中的实现，敬请关注我的博客！\n1.5 为什么其他数据结构不适合索引？在认识这个问题之前，我们首先要记住上文提到的一个结论：真正影响索引性能的，是和硬盘IO的次数，IO次数越少，性能越高；\n\n链表、线性表：都是线性遍历，压根没有索引的功能\n二叉搜索树：在极端场景下会退化成普通二叉树，还是线性遍历\nAVLTree/RBTree：虽然相对平衡，但二叉结构会导致树的整体过高，自顶向下查询的时候，需要经过多层的多次IO，才能找到目标数据（B+树的层数更少，在这种情况下B+树更优秀）\nHASH：虽然查找的时候很快，基本能做到O(1)，但范围查询的效果不佳；在MySQL中也是支持HASH索引的，比如MEMOY/HEAP/NDB存储引擎；\n\n\n那B树为什么不适合呢？作为一个多叉树结构，B树的同层能比红黑树存储更多信息，看上去也是可以做索引的呀？\n牵扯到B树和B+树的区别了，来看看二者的结构图\n\n文字说明如下：\n\nB树的每一个节点都会存放一定的数据和page指针；\nB+树只有叶子节点会存放数据，非叶子节点只有page的目录；\nB+树的叶子节点全部相连；\n\n这就引出了B+树的两个优点：\n\n因为B+树的非叶子节点只需要存储page目录，所以在一个非叶子节点中就能存放较多的目录索引，使得树整体更矮；\nB+树的叶子节点全部相连，方便进行范围遍历，比如where sal&gt;100 and sal &lt; 300的这种范围条件，就可以直接通过叶子节点的链表向后遍历来解决；\n\n最终的效率问题依旧落到了如何让树更矮来减少IO次数，因为在整体上B+树都能做到较矮，查询效率优秀，方便范围查询；所以MySQL主要选用了B+树作为索引结构。\n1.6 聚簇&#x2F;非聚簇索引1.6.1 说明InnoDB的数据是和B+树一起存放的，叶子节点里面有数据；这种数据和索引在一起的形式，叫做聚簇索引。\n\nMyISAM的叶子中没有数据，而是存放的指向数据表对应位置的指针，有额外的一张表来存放所有数据；这种数据和索引分离的形式，叫做非聚簇索引；\n\n对于MyISAM存储引擎来说，其很适合进行查询，特别是大文本查找和全文索引（后文会提到）；\n1.6.2 实机演示\n在MySQL中，我们可以通过实际文件的数量看出InnoDB和MyISAM存储引擎的区别；其也反映了聚簇&#x2F;非聚簇索引的性质。\n\n这里我们新建一个数据库，创建user1表，默认采用的是InnoDB作为存储引擎\nMariaDB [hello_mysql]&gt; create table user1( id int unsigned primary key, name varchar(200) NOT NULL );Query OK, 0 rows affected (0.008 sec)\n\n在MySQL的文件存储路径中，可以查看到user1表对应了两个文件，其中.ibd后缀指的就是InnoDB，其内部同时包含了该表中的数据和索引值；\n[root@vm-cnt8:/var/lib/mysql/hello_mysql]# lltotal 104-rw-rw----. 1 mysql mysql    61 Sep  7 02:59 db.opt-rw-rw----. 1 mysql mysql  1545 Sep  7 03:00 user1.frm-rw-rw----. 1 mysql mysql 98304 Sep  7 03:00 user1.ibd\n\n再来创建一个属性完全相同的user2表，但采用MyISAM存储引擎\nMariaDB [hello_mysql]&gt; create table user2( id int unsigned primary key, name varchar(200) NOT NULL ) engine=MyISAM;Query OK, 0 rows affected (0.002 sec)\n\n此时能看到，MyISAM对应的存储文件有3个，.MYI包含的是索引，.MYD包含的是实际数据；\n[root@vm-cnt8:/var/lib/mysql/hello_mysql]# lltotal 112-rw-rw----. 1 mysql mysql    61 Sep  7 02:59 db.opt-rw-rw----. 1 mysql mysql  1545 Sep  7 03:00 user1.frm-rw-rw----. 1 mysql mysql 98304 Sep  7 03:00 user1.ibd-rw-rw----. 1 mysql mysql  1545 Sep  7 03:03 user2.frm-rw-rw----. 1 mysql mysql     0 Sep  7 03:03 user2.MYD-rw-rw----. 1 mysql mysql  1024 Sep  7 03:03 user2.MYI\n\n两表都有一个占用空间完全相同的.frm文件，这个文件中存储的就是该表的结构属性信息，因为两个表的结构完全相同，所以这个文件的大小也相同；\n1.7 回表查找创建辅助索引的时候，MyISAM依旧创建一个B+树，叶子节点也是指向对应位置的指针；所以在MyISAM中，主键&#x2F;非主键索引区别不大，无非是是否允许冗余数据的问题。\n\nInnoDB的辅助索引中，不再直接存放节点数据，而是存放主键key值，查询的时候根据key值回到主键索引表中进行查询，需要查询两次才能获取到结果。\n\n如果辅助索引中还保存数据，就会造成极大的空间浪费，一份数据被保存两次甚至更多次，显然是不合理的。\n\nInnoDB这个先查辅助索引表，再回到主键表中查询的动作，叫做回表查询；\n话虽是这么说，但也并不是每次查询我们都需要回表的。比如下图是一个复合键的索引表，假设数字是用户ID（主键），文字是用户姓名，在这种情况下，我们通过用户姓名查询用户ID的时候，就不需要回到主键表也能获取到结果。\n\n另外，在一般的数据库中，B+树并不会很深，所以即便需要进行回表的两次查询，效率也不会受到较大影响；（但肯定会有一定损失）\n2.索引操作2.1 创建索引的原则\n比较频繁作为查询条件的字段应该创建索引\n唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件\n更新非常频繁的字段不适合作创建索引（因为每次更新都得重置索引，增加IO压力）\n不会出现在where子句中的字段不该创建索引（不作为查询条件的字段）\n\n另外，如果在创建表的时候么有指定主键，那么MySQL会自动帮我们创建一个隐藏的自增主键ID（不然就没办法支持其他索引和其本身的快速查找了）\n2.2 创建主键索引创建表的时候指定primary key，默认就会创建主键索引\ncreate table user1( id int unsigned primary key, name varchar(200) NOT NULL );\n\n创建表的最后，指定某列为主键索引，这个和第一种方式本质上没区别\ncreate table user1( id int unsigned , name varchar(200) NOT NULL, primary key(id) );\n\n创建表了之后再添加主键\n-- 创建表create table user1( id int unsigned , name varchar(200) NOT NULL);-- 添加主键alter table user1 add primary key(id);\n\n主键索引的特点：\n\n一个表里面本来就只能有一个主键，所以主键索引也只有一个（复合主键也只算一个主键）\n主键索引的效率高（主键列不可重复）\n主键列不能为NULL，所以也不存在无法被索引的值\n一般都会用数字来作为主键，在索引中方便数据比较\n\n2.3 唯一键索引当你给某一列设置为唯一键的时候，MySQL就会自动创建唯一键索引；唯一键索引其实就是普通的辅助索引，只不过其和主键一样都包含唯一的键值约束；\n-- 直接指定唯一键create table user2(id int primary key, name varchar(200) unique);-- 创建语句末尾指定唯一键create table user2(id int primary key, name varchar(200),unique(name));-- 创建后再添加唯一键create table user2(id int primary key, name varchar(200));alter table user2 add unique(name);\n\n唯一索引的特点：\n\n一个表中，可以有多个唯一索引，包括复合唯一键的索引；\n查询效率高；\n如果在某一列建立唯一索引，必须保证这列不能有重复数据；\n如果一个唯一索引上指定not null，等价于主键索引；\n如果删除唯一键索引，也会同时删除唯一的约束属性；\n\n2.4 普通键索引创建普通索引依旧有3种方式\n-- 在表的定义最后，指定某列为索引create table user3(id int primary key,    name varchar(20),    email varchar(30),    index(name));-- 创建完表以后指定某列为普通索引create table user3(id int primary key, name varchar(20), emailvarchar(30));alter table user3 add index(name);-- 创建索引的时候指定名字create table user3(id int primary key, name varchar(20), emailvarchar(30));create index idx_name on user3(name); -- 创建一个索引名为 idx_name 的索引\n\n普通索引的特点：\n\n一个表中可以有多个普通索引\n普通索引中的键值可以重复，但不要在大量重复的键值上建立索引（比如性别）\n\n2.5 复合&#x2F;联合索引给多个键值创建索引，操作如下\ncreate index 索引名字 on 表名(字段1,字段2);-- 如果需要索引按不同的规则排序，可以在字段后加DESC和ASCcreate index 索引名字 on 表名(字段1 DESC,字段2 ASC);\n\n此时我们创建的索引，在字段1和字段2上会共用一个索引的Key_name，索引名字是相同的。\n复合索引有一个好处，如果使用InnoDB时，需要查询的结果包含在索引字段中，那就可以节省一次返还到主键索引中查询的回表步骤，可以在一定程度上提高效率（在上文中已经提及此事）\n\n上面这种操作叫做索引覆盖（覆盖索引），直接从普通索引表中查询到结果；\n建立复合索引相比于建立多个单列索引，还能在一定程度上减少空间消耗，提高效率；\n\n另外，在进行复合索引的查询的时候，我们只能使用用户名来查询用户ID，返过来是不行的（不会使用索引）。因为在MySQL对索引进行匹配的时候，只会匹配最左侧的索引值；\n比如下图中，充当判断条件的是用户名字，通过用户名字查用户ID是OK的，反过来就不行；这种情况下MySQL不会使用索引，依旧是全表遍历；\n\n这种叫做MySQL索引的最左匹配原则\n\n详解：联合索引-最左匹配原则\n\nMySQL在创建复合索引的时候，首先会对最左边字段排序，也就是第一个字段，然后再在保证第一个字段有序的情况下，再排序第二个字段，以此类推。所以联合索引最左列是绝对有序的，其他字段无序。\n举个例子：可以把联合索引看成“电话簿”，姓名作为联合索引，姓是第一列，名是第二列，当查找人名时，是先确定这个人姓再根据名确定人。只有名没有姓就查不到。\n2.6 全文索引如果对文章或者大量文字的字段进行检索的时候，就会使用到全文索引。MySQL提供全文索引机制，但是要求表的存储引擎必须是MyISAM；而且默认的全文索引只支持英文，不支持中文。如果对中文进行全文检索，可以使用sphinx的中文版(coreseek)。\n-- 创建表，FULLTEXT设置全文索引CREATE TABLE articles (    id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,    title VARCHAR(200),    body TEXT,    FULLTEXT (title,body) )engine=MyISAM;-- 插入测试数据INSERT INTO articles (title,body) VALUES    (&#x27;MySQL Tutorial&#x27;,&#x27;DBMS stands for DataBase ...&#x27;),    (&#x27;How To Use MySQL Well&#x27;,&#x27;After you went through a ...&#x27;),    (&#x27;Optimizing MySQL&#x27;,&#x27;In this tutorial we will show ...&#x27;),    (&#x27;1001 MySQL Tricks&#x27;,&#x27;1. Never run mysqld as root. 2. ...&#x27;),    (&#x27;MySQL vs. YourSQL&#x27;,&#x27;In the following database comparison ...&#x27;),    (&#x27;MySQL Security&#x27;,&#x27;When configured properly, MySQL ...&#x27;);\n\n创建好表之后，查询表中索引信息，可以看到title和body字段都用上了索引名字为title的全文索引\n\n假设我们查询这个表中有没有包含database的文字数据，虽然成功查询了结果，但是并没有使用到全文索引\nselect * from articles where body like &#x27;%database%&#x27;;+----+-------------------+------------------------------------------+| id | title             | body                                     |+----+-------------------+------------------------------------------+|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             ||  5 | MySQL vs. YourSQL | In the following database comparison ... |+----+-------------------+------------------------------------------+2 rows in set (0.000 sec)\n\n使用explain语句可以看出是否有使用全文索引，这里的key为NULL就代表么有使用上索引；这个工具的作用是预执行，并不会实际上运行这个语句，但是会告诉你我想怎么运行它；\nexplain select * from articles where body like &#x27;%database%&#x27;\\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: articles         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 6        Extra: Using where1 row in set (0.000 sec)\n\n要想使用全文索引，得这么写\nSELECT * FROM articles WHERE MATCH (title,body) AGAINST (&#x27;database&#x27;);\n\n再用explain工具看看，此时就可以看到key里面显示的是title，成功使用上了全文索引\nexplain SELECT * FROM articles WHERE MATCH (title,body) AGAINST    -&gt; (&#x27;database&#x27;)\\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: articles         type: fulltextpossible_keys: title          key: title      key_len: 0          ref:          rows: 1        Extra: Using where1 row in set (0.000 sec)\n\nexplain工具这里对explain工具显示的列作一个说明。这个工具的作用是预执行，并不会实际上运行这个语句，但是会告诉你我想怎么运行它；输出结果包含如下列：\n\nid — 选择标识符，id 越大优先级越高，越先被执行；\nselect_type — 表示查询的类型；\ntable — 输出结果集的表；\npartitions — 匹配的分区；\ntype — 表示表的连接类型；\npossible_keys — 表示查询时，可能使用的索引；\nkey — 表示实际使用的索引；\nkey_len — 索引字段的长度；\nref—  列与索引的比较；\nrows — 大概估算的行数；\nfiltered — 按表条件过滤的行百分比；\nExtra — 执行情况的描述和说明。\n\n2.7 查询&#x2F;删除索引如果需要删除主键索引，直接把主键删了就行了\nalter table 表名 drop primary key;\n\n删除普通索引语句如下\nalter table 表名 drop index 索引名字;\n\n注意，索引的名字不一定和字段名相同（在创建索引的时候可以指定索引名字），需要使用如下语句查看\nshow keys from 表名;\n\n比如user2表中包含id主键索引和name的主键索引，其结果查询如下；其中的Key_name才是索引的名字，不一定和字段名相同！删除索引的时候需要使用索引名字！\n\n还可以用如下语句来更加清楚的看到每个索引的相关属性\nshow index from 表名\\G;\n\n我给user2表添加一个键值，并设置普通索引\nalter table user2 add qq varchar(40); -- 添加一个键值alter table user2 add index(qq); -- 添加普通索引\n\n使用show index from 表名\\G;语句查看user2表的索引属性；在这里可以看到，唯一键索引的属性和普通索引是完全相同的，所以才说唯一键的索引本质上还是普通索引。\n这里还写明了索引的类型是BTREE，其就是B+树；\nMariaDB [hello_mysql]&gt; desc user2;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(200)     | NO   | UNI | NULL    |       || qq    | varchar(40)      | YES  | MUL | NULL    |       |+-------+------------------+------+-----+---------+-------+3 rows in set (0.001 sec)MariaDB [hello_mysql]&gt; show index from user2\\G;*************************** 1. row ***************************        Table: user2   Non_unique: 0     Key_name: PRIMARY Seq_in_index: 1  Column_name: id    Collation: A  Cardinality: 0     Sub_part: NULL       Packed: NULL         Null:    Index_type: BTREE      Comment: Index_comment: *************************** 2. row ***************************        Table: user2   Non_unique: 0     Key_name: name Seq_in_index: 1  Column_name: name    Collation: A  Cardinality: 0     Sub_part: NULL       Packed: NULL         Null:    Index_type: BTREE      Comment: Index_comment: *************************** 3. row ***************************        Table: user2   Non_unique: 1     Key_name: qq Seq_in_index: 1  Column_name: qq    Collation: A  Cardinality: NULL     Sub_part: NULL       Packed: NULL         Null: YES   Index_type: BTREE      Comment: Index_comment: 3 rows in set (0.000 sec)ERROR: No query specified\n\n2.8 什么时候索引会失效？\nhttps://cloud.tencent.com/developer/article/2035778\nhttps://zhuanlan.zhihu.com/p/361172794\n\n2.8.1 如果条件中有or&#x2F;and如果条件中有or&#x2F;and，即使其中有部分条件带索引也不会使用；\n先说结论：如果在使用and和or进行查询的时候，只有两列都包含了索引才会使用；\n-- 创建示例表，其中id是主键，user_id没有创建索引create table user3(\tid int unsigned primary key,\tuser_id int unsigned not null,    name varchar(30) not null);-- 插入示例数据insert into user3 values \t(1,10,&#x27;甲&#x27;),\t(2,20,&#x27;丙&#x27;),\t(3,30,&#x27;乙&#x27;),\t(4,40,&#x27;丁&#x27;),\t(5,50,&#x27;尼斯&#x27;),(6,23,&#x27;企鹅&#x27;),(7,14,&#x27;倪浩&#x27;),(9,21,&#x27;test&#x27;);\n\n这时候如果用如下语句进行查询，那就不会使用索引\nselect * from user3 where id=3 or user_id=40;\n\n使用explain命令来查看运行过程，可以看到key一列为空，代表没有使用索引\nMariaDB [hello_mysql]&gt; explain select * from user3 where id=3 or user_id=40\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: ALLpossible_keys: PRIMARY          key: NULL      key_len: NULL          ref: NULL         rows: 4        Extra: Using where1 row in set (0.000 sec)ERROR: No query specifiedMariaDB [hello_mysql]&gt; explain select * from user3 where id=2 and user_id=30\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: NULL         type: NULLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: NULL        Extra: Impossible WHERE noticed after reading const tables1 row in set (0.001 sec)ERROR: No query specified\n\n直接查询id，有使用索引\nMariaDB [hello_mysql]&gt; explain select * from user3 where id=2\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 4          ref: const         rows: 1        Extra: 1 row in set (0.000 sec)ERROR: No query specified\n\n此时如果给user_id列加上索引后重新操作，那结果就不一样了\nalter table user3 add unique(user_id); -- 唯一键索引\n\n可以看到，有使用索引（在我的测试中，并不是每次都会使用索引，这大概是因为我的内容列太少了，不如直接遍历？）\nMariaDB [hello_mysql]&gt; explain select * from user3 where id=2 and user_id=20\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: constpossible_keys: PRIMARY,user_id          key: PRIMARY      key_len: 4          ref: const         rows: 1        Extra: 1 row in set (0.000 sec)ERROR: No query specified\n\n2.8.2 复合索引没有使用最左列使用sn + name + age创建复合索引，我们假设它们的顺序是 A + B + C，以下联合索引的使用情况如下：\n\n从结果可以看出，只有A+B+C或者A+B&#x2F;A+C才能触发索引，而使用B+C无法触发索引，因为没有使用最左列；\n2.8.3  错误模糊查询模糊查询的时候，只有关键字%才能用到索引，使用%关键字或者%关键字%都是无法使用索引的；\n测试表结构如下，其中ename是用户名，我给他添加了一个普通索引\nMariaDB [bit_index]&gt; desc EMP;+----------+--------------------------+------+-----+---------+-------+| Field    | Type                     | Null | Key | Default | Extra |+----------+--------------------------+------+-----+---------+-------+| empno    | int(6) unsigned zerofill | NO   | PRI | NULL    |       || ename    | varchar(10)              | YES  |     | NULL    |       || job      | varchar(9)               | YES  |     | NULL    |       || mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       || hiredate | datetime                 | YES  |     | NULL    |       || sal      | decimal(7,2)             | YES  |     | NULL    |       || comm     | decimal(7,2)             | YES  |     | NULL    |       || deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |+----------+--------------------------+------+-----+---------+-------+8 rows in set (0.001 sec)MariaDB [bit_index]&gt; alter table EMP add index(ename);Query OK, 0 rows affected (11.911 sec)              Records: 0  Duplicates: 0  Warnings: 0\n\n然后进行测试。注意看下方3次查询的like条件区别，以及是否使用了索引；可以看到，只有第一次使用FN%作为查询条件的时候，才使用了索引\nMariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;FN%&#x27;\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: EMP         type: rangepossible_keys: ename          key: ename      key_len: 33          ref: NULL         rows: 22000        Extra: Using index condition1 row in set (0.000 sec)ERROR: No query specifiedMariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;%FN%&#x27;\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: EMP         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 7968250        Extra: Using where1 row in set (0.000 sec)ERROR: No query specifiedMariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;%FN&#x27;\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: EMP         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 7968250        Extra: Using where1 row in set (0.000 sec)ERROR: No query specified\n\n2.8.4 列运算如果包含索引的列进行了运算，也不会使用索引；\n比如下方，直接进行id=5查询的时候，可以使用索引，但用id+2=5进行查询的时候无法使用索引；\nMariaDB [hello_mysql]&gt; explain select * from user3 where id=5\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 4          ref: const         rows: 1        Extra: 1 row in set (0.000 sec)ERROR: No query specifiedMariaDB [hello_mysql]&gt; explain select * from user3 where id+2=5\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 8        Extra: Using where1 row in set (0.000 sec)ERROR: No query specified\n\n2.8.5 使用函数查询列如果使用任意 MySQL 提供的函数就会导致索引失效，这一点的情况和上一点进行运算其实是类似的，毕竟函数也是一种内置的运算；\nMariaDB [hello_mysql]&gt; explain select * from user3 where ifnull(id,0)=5\\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user3         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 8        Extra: Using where1 row in set (0.001 sec)ERROR: No query specified\n\n2.8.6 类型转换当查询的条件和其本身的数据类型不同时，不会触发索引；\n比如 address 为字符串类型，而查询的时候设置了 int 类型的值就会导致索引失效，如下图所示：\n\n2.8.7 使用is not null当在查询中使用了 is not null 也会导致索引失效，而 is null 则会正常触发索引的，如下图所示：\n\n3.索引优化3.1 关联查询优化保证被驱动表的JOIN字段已经创建了索引，需要 JOIN 的字段，数据类型保持绝对一致。\n\nLEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。\nINNER JOIN 时，MySQL会自动将小结果集的表选为驱动表 。\n\n选择相信MySQL优化策略。能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数）\n\n不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询，参考第二点；\n\n另外，衍生表建不了索引。这点也需要注意\n3.2 子查询优化MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。 \n子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作，子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。\n但是，子查询的执行效率不高。原因： \n\n执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。 \n子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引 ，所以查询性能会受到一定的影响。\n对于返回结果集比较大的子查询，其对查询性能的影响也就越大。 在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表 ，其速度比子查询要快 ，如果查询中使用索引的话，性能就会更好。\n\n结论：尽量不要使用 NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代；\n3.3 排序优化\nSQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 避免全表扫 描 ，在 ORDER BY 子句 避免使用 FileSort 排序 。当然，某些情况下全表扫描，或者 FileSort 排 序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。\n尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。\n无法使用 Index 时，需要对 FileSort 方式进行调优。\n\n3.4 GROUP BY优化group by使用索引的原则几乎跟order by一致 ，group by即使没有过滤条件用到索引，也可以直接使用索引。\n\ngroup by 先排序再分组，遵照索引建的最佳左前缀法则；\n当无法使用索引列事，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置；\nwhere效率高于having，能写在where限定的条件就不要写在having中了！\n减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。\n包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。\n\n3.5 索引覆盖这一点在上文的回表查找中已经提及了，即使用复合索引，并将你需要查询的目标字段以最左匹配原则设置到复合索引中，减少回表操作。\n当然，这依旧需要遵循索引创建的原则，即如果某列数据重复量过多，则不应该作为索引列（如果真的需要，可以放在复合索引的最后面，这样能减少以之为查询判据的场景）\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】安装和基础环境配置","url":"/posts/577382991/","content":"在本地安装mysql，以mariadb为例。\n所有命令都需要在root下面执行or使用sudo\n\n本文基于系统 CentOS 8\n\n1.安装mariadb开发包在 CentOS8 下用如下命令\nyum updateyum install -y mariadbyum install -y mariadb-serveryum install -y mariadb-devel\n\n在 Ubuntu 22.04 系统上用如下命令\nsudo apt updatesudo apt install -y mariadb-server mariadb-client\n\n\n注意，后文没有强调处的操作全都基于 CentOS8，但在 Ubuntu 上的配置操作应类似。可供参考\n\n2.修改配置文件中的编码为了保证对中文的支持，我们需要修改几个配置文件。他们都在如下目录中\n$ ls /etc/my.cnf.d/auth_gssapi.cnf  client.cnf  enable_encryption.preset  mariadb-server.cnf  mysql-clients.cnf\n\n需要修改的是如下3个，修改之前，建议使用cp命令进行备份，避免修改错了无法复原。\n/etc/my.cnf.d/client.cnf/etc/my.cnf.d/mysql-clients.cnf/etc/my.cnf.d/mariadb-server.cnf\n\n我的已经是修改好的了，需要修改的配置看中文注释就ok\n$ cat /etc/my.cnf.d/client.cnf## These two groups are read by the client library# Use it for options that affect all clients, but not the server#[client]# 新增下边一行配置，设置客户端默认字符集为utf8default-character-set = utf8# This group is not read by mysql client library,# If you use the same .cnf file for MySQL and MariaDB,# use it for MariaDB-only client options[client-mariadb]\n\n$ cat /etc/my.cnf.d/mysql-clients.cnf## These groups are read by MariaDB command-line tools# Use it for options that affect only one utility#[mysql]# 新增字符配置default-character-set = utf8[mysql_upgrade]\n\n$ cat /etc/my.cnf.d/mariadb-server.cnf## These groups are read by MariaDB server.# Use it for options that only the server (but not clients) should see## See the examples of server my.cnf files in /usr/share/mysql/## this is read by the standalone daemon and embedded servers[server]# this is only for the mysqld standalone daemon# Settings user and group are ignored when systemd is used.# If you need to run mysqld under a different user or group,# customize your systemd unit file for mysqld/mariadb according to the# instructions in http://fedoraproject.org/wiki/Systemd[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.socklog-error=/var/log/mariadb/mariadb.logpid-file=/run/mariadb/mariadb.pid# 新增以下字符集的配置collation-server = utf8_general_ciinit-connect = &#x27;SET NAMES utf8&#x27;character-set-server = utf8sql-mode = TRADITIONAL\n\n3.测试3.1 启动&#x2F;关闭systemctl start mariadb\n\n看看状态\nsystemctl status mariadb\n\n显示如下，那就是正常运行中的\n● mariadb.service - MariaDB 10.3 database server   Loaded: loaded (/usr/lib/systemd/system/mariadb.service; disabled; vendor preset: disabled)   Active: active (running) since Tue 2023-04-04 14:10:00 CST; 2 days ago     Docs: man:mysqld(8)           https://mariadb.com/kb/en/library/systemd/  Process: 633453 ExecStartPost=/usr/libexec/mysql-check-upgrade (code=exited, status=0/SUCCESS)  Process: 633289 ExecStartPre=/usr/libexec/mysql-prepare-db-dir mariadb.service (code=exited, status=0/SUCCESS)  Process: 633265 ExecStartPre=/usr/libexec/mysql-check-socket (code=exited, status=0/SUCCESS) Main PID: 633422 (mysqld)   Status: &quot;Taking your SQL requests now...&quot;    Tasks: 31 (limit: 75691)   Memory: 67.4M   CGroup: /system.slice/mariadb.service           └─633422 /usr/libexec/mysqld --basedir=/usr\n\n\n用ps命令也能看到相关的进程\n$ ps jax | grep mysql      1  633422  633422  633422 ?             -1 Ssl     27   4:10 /usr/libexec/mysqld --basedir=/usr 625302  634104  634104  625302 pts/48    634104 S+    1000   0:00 mysql -uroot 642521  642555  642554  642521 pts/51    642554 S+    1000   0:00 grep --color=auto mysql\n\n如果想关闭，使用如下命令即可\nsystemctl stop mariadb\n\n使用如下命令进行开机自启的配置\nsystemctl enable mariadb\n\n执行效果如下\n$ systemctl enable mariadbCreated symlink /etc/systemd/system/mysql.service → /usr/lib/systemd/system/mariadb.service.Created symlink /etc/systemd/system/mysqld.service → /usr/lib/systemd/system/mariadb.service.Created symlink /etc/systemd/system/multi-user.target.wants/mariadb.service → /usr/lib/systemd/system/mariadb.service.\n\n取消开机自启，将enable改成disable就可以了\nsystemctl disable mariadb\n\n3.2 进入mysql命令行因为我们没有设置root用户的密码，所以不需要指定密码就能进入数据库\nmysql -uroot\n\n会显示出如下信息，包括mariadb的版本\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.Your MariaDB connection id is 11Server version: 10.3.28-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.MariaDB [(none)]&gt;\n\n\n\n3.3 看看字符编码是否修改成功输入如下命令 (记得要输入末尾的分号)\nshow variables like &quot;%chara%&quot;;\n\n看看是否都配置为了utf-8，如下图，除了filesystem是二进制，其他都是utf8，那就是ok的\n修改之前的是这样的\n\n修改后\n\n到这里，就ok菈！\n3.4 端口mysql服务的默认端口为3306，:::代表它是采用ipv6协议在本地进行访问的。但这不影响我们的使用\n\n4.彻底卸载有的时候，一个环境中已有mysql，但不是我们需要的版本。就需要将其删除后重新安装新的mysql。\nrpm -qa | grep mysqlrpm -qa | grep mariadb\n\n使用这两个命令，可以查看当前系统中安装的mysql（mariadb）的包\n[root@1c2261732150:~]# rpm -qa | grep mysql[root@1c2261732150:~]# rpm -qa | grep mariadbmariadb-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-server-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-common-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-errmsg-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-connector-c-3.1.11-2.el8_3.x86_64mariadb-backup-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-server-utils-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-devel-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-connector-c-config-3.1.11-2.el8_3.noarchmariadb-gssapi-server-10.3.28-1.module_el8.3.0+757+d382997d.x86_64mariadb-connector-c-devel-3.1.11-2.el8_3.x86_64\n\n可以看到，我的系统中安装的是mariadb（而不是mysql）\n这时候就可以用一条命令，快速进行批量卸载\nrpm -qa | grep mariadb | xargs yum -y remove\n\n这条命令中xargs的作用就是把前面这个grep命令的结果，按行喂给yum进行删除。\n删除之后，再次执行。\nrpm -qa | grep mariadb\n\n如果没有软件，那就是卸载完毕了！👌👌\n[root@1c2261732150:~/package]# rpm -qa | grep mariadb[root@1c2261732150:~/package]#\n\n注意，卸载mysql并不会连带删除数据文件\n5.安装特定版本的5.1 查看系统版本$ cat /etc/system-releaseCentOS Linux release 8.5.2111\n\n当前我使用的系统为CentOS 8.5，使用yum安装的mariadb的版本比较高\n# mysql --versionmysql  Ver 15.1 Distrib 10.3.28-MariaDB, for Linux (x86_64) using readline 5.1\n\n假设我需要一个老版本的mysql，就需要去安装特定的rpm版本\n5.2 获取yum源http://repo.mysql.com/\n\n找到el8后缀的包，el指代的就是CentOS\nmysql80-community-release-el8-3.noarch.rpm\n\n如上，就是一个mysql 8.0版本的CentOS8的rpm源。\n在很多教程中，使用的都是5.7版本的mysql，可惜CentOS8已经不支持这个旧版本了（找不到对应的mysql57的包）\n5.3 安装yum源可以使用windows下载了rpm文件后，上传到服务器中。或者用如下命令在linux内部下载。\n如下目录是我们系统源的路径，一般情况下，内部不会带有和mysql相关的源。\nls -al /etc/yum.repos.d/\n\ntotal 92drwxr-xr-x 1 root root 4096 Apr  6 19:14 .drwxr-xr-x 1 root root 4096 Apr  6 19:14 ..-rw-r--r-- 1 root root 2590 Feb 24 08:08 CentOS-Base.repo-rw-r--r-- 1 root root  966 Feb 24 08:00 CentOS-Linux-AppStream.repo-rw-r--r-- 1 root root  710 Feb 24 07:56 CentOS-Linux-BaseOS.repo-rw-r--r-- 1 root root 1136 Feb 24 07:56 CentOS-Linux-ContinuousRelease.repo-rw-r--r-- 1 root root  318 Feb 24 07:56 CentOS-Linux-Debuginfo.repo-rw-r--r-- 1 root root  738 Feb 24 07:56 CentOS-Linux-Devel.repo-rw-r--r-- 1 root root  710 Feb 24 07:56 CentOS-Linux-Extras.repo-rw-r--r-- 1 root root  725 Feb 24 07:56 CentOS-Linux-FastTrack.repo-rw-r--r-- 1 root root  746 Feb 24 07:56 CentOS-Linux-HighAvailability.repo-rw-r--r-- 1 root root  693 Feb 24 07:56 CentOS-Linux-Media.repo-rw-r--r-- 1 root root  712 Feb 24 07:56 CentOS-Linux-Plus.repo-rw-r--r-- 1 root root  730 Feb 24 07:56 CentOS-Linux-PowerTools.repo-rw-r--r-- 1 root root 1124 Feb 24 07:56 CentOS-Linux-Sources.repo-rw-r--r-- 1 root root    0 Feb 24 08:05 epel-8.repo-rw-r--r-- 1 root root 1698 Oct  4  2022 epel-modular.repo-rw-r--r-- 1 root root 1332 Oct  4  2022 epel.repo-rw-r--r-- 1 root root 1417 Jun  8  2021 epel.repo.rpmnew-rw-r--r-- 1 root root 2318 Feb 24 08:08 epel.repo.rpmsave-rw-r--r-- 1 root root 1797 Oct  4  2022 epel-testing-modular.repo-rw-r--r-- 1 root root 1431 Oct  4  2022 epel-testing.repo-rw-r--r-- 1 root root  164 Feb 27 12:21 vscode.repo\n\n将数据传到云服务器后，使用如下命令，进行源安装\nrpm -Uvh mysql80-community-release-el8-3.noarch.rpm\n\n输出如下\nwarning: mysql80-community-release-el8-3.noarch.rpm: Header V4 RSA/SHA256 Signature, key ID 3a79bd29: NOKEYVerifying...                          ################################# [100%]warning: Unable to get systemd shutdown inhibition lock: Unit systemd-logind.service is masked.Preparing...                          ################################# [100%]Updating / installing...   1:mysql80-community-release-el8-3  ################################# [100%]\n\n安装完毕，再次查看yum源路径，可以看到比原来多了两个mysql的包\n# ls -al /etc/yum.repos.d/total 100drwxr-xr-x 1 root root 4096 Apr  7 16:12 .drwxr-xr-x 1 root root 4096 Apr  6 19:14 ..-rw-r--r-- 1 root root 2590 Feb 24 08:08 CentOS-Base.repo-rw-r--r-- 1 root root  966 Feb 24 08:00 CentOS-Linux-AppStream.repo-rw-r--r-- 1 root root  710 Feb 24 07:56 CentOS-Linux-BaseOS.repo-rw-r--r-- 1 root root 1136 Feb 24 07:56 CentOS-Linux-ContinuousRelease.repo-rw-r--r-- 1 root root  318 Feb 24 07:56 CentOS-Linux-Debuginfo.repo-rw-r--r-- 1 root root  738 Feb 24 07:56 CentOS-Linux-Devel.repo-rw-r--r-- 1 root root  710 Feb 24 07:56 CentOS-Linux-Extras.repo-rw-r--r-- 1 root root  725 Feb 24 07:56 CentOS-Linux-FastTrack.repo-rw-r--r-- 1 root root  746 Feb 24 07:56 CentOS-Linux-HighAvailability.repo-rw-r--r-- 1 root root  693 Feb 24 07:56 CentOS-Linux-Media.repo-rw-r--r-- 1 root root  712 Feb 24 07:56 CentOS-Linux-Plus.repo-rw-r--r-- 1 root root  730 Feb 24 07:56 CentOS-Linux-PowerTools.repo-rw-r--r-- 1 root root 1124 Feb 24 07:56 CentOS-Linux-Sources.repo-rw-r--r-- 1 root root    0 Feb 24 08:05 epel-8.repo-rw-r--r-- 1 root root 1698 Oct  4  2022 epel-modular.repo-rw-r--r-- 1 root root 1332 Oct  4  2022 epel.repo-rw-r--r-- 1 root root 1417 Jun  8  2021 epel.repo.rpmnew-rw-r--r-- 1 root root 2318 Feb 24 08:08 epel.repo.rpmsave-rw-r--r-- 1 root root 1797 Oct  4  2022 epel-testing-modular.repo-rw-r--r-- 1 root root 1431 Oct  4  2022 epel-testing.repo-rw-r--r-- 1 root root 1265 Jan 10  2022 mysql-community.repo-rw-r--r-- 1 root root 1321 Jan 10  2022 mysql-community-source.repo-rw-r--r-- 1 root root  164 Feb 27 12:21 vscode.repo\n\n这时候，yum源就已经安装成功了\nyum list | grep mysql\n\n执行后，可以看到，列在最前面的就是el8-3，即为刚刚我们添加的的yum源中的mysql版本\nRepository AppStream is listed more than once in the configurationRepository extras is listed more than once in the configurationmysql80-community-release.noarch                                  el8-3                                                  @Systemanope-mysql.x86_64                                                2.0.12-1.el8                                           epelansible-collection-community-mysql.noarch                         3.5.1-1.el8                                            epelapr-util-mysql.x86_64                                             1.6.1-6.el8                                            AppStream\n\n\n5.4 卸载旧版本的如果需要安装新版本的，那就需要依照第四步的操作，彻底卸载旧版本的mysql\n5.5 安装指定版本此时我们指定mysql进行安装，就肯定能安装到刚刚添加的mysql8.0版本\nyum install -y mysqlyum install -y mysql-serveryum install -y mysql-devel\n\n\n可以看到，版本就是8.0的，不再是之前安装的Ver 15.1\n$ mysql --versionmysql  Ver 8.0.26 for Linux on x86_64 (Source distribution)\n\n共安装了下面的这些包\n# rpm -qa | grep mysqlmysql-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql-errmsg-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql-server-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql-devel-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql-common-8.0.26-1.module_el8.4.0+915+de215114.x86_64mysql80-community-release-el8-4.noarchmysql-libs-8.0.26-1.module_el8.4.0+915+de215114.x86_64# rpm -qa | grep mariadbmariadb-connector-c-config-3.1.11-2.el8_3.noarch\n\n5.6 启动报错（未解决）但是这次启动的时候，却遇到了下面的报错\n# systemctl start mysqldJob for mysqld.service failed because the control process exited with error code.See &quot;systemctl status mysqld.service&quot; and &quot;journalctl -xe&quot; for details.\n\n查看报错信息也看不出个所以然\n# systemctl status mysqld.service● mysqld.service - MySQL 8.0 database server   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; disabled; vendor preset: disabled)   Active: failed (Result: exit-code) since Fri 2023-04-07 16:39:51 CST; 7s ago  Process: 648073 ExecStopPost=/usr/libexec/mysql-wait-stop (code=exited, status=0/SUCCESS)  Process: 648059 ExecStart=/usr/libexec/mysqld --basedir=/usr (code=exited, status=1/FAILURE)  Process: 648023 ExecStartPre=/usr/libexec/mysql-prepare-db-dir mysqld.service (code=exited, status=0/SUCCESS)  Process: 647999 ExecStartPre=/usr/libexec/mysql-check-socket (code=exited, status=0/SUCCESS) Main PID: 648059 (code=exited, status=1/FAILURE)   Status: &quot;Data Dictionary upgrade from MySQL 5.7 in progress&quot;Apr 07 16:39:50 1c2261732150 systemd[1]: Starting MySQL 8.0 database server...Apr 07 16:39:51 1c2261732150 systemd[1]: mysqld.service: Main process exited, code=exited, status=1/FAILUREApr 07 16:39:51 1c2261732150 systemd[1]: mysqld.service: Failed with result &#x27;exit-code&#x27;.Apr 07 16:39:51 1c2261732150 systemd[1]: Failed to start MySQL 8.0 database server.\n\n百度了一下，这个问题是因为mysql的路径权限不足\n\nhttps://blog.csdn.net/Shockang/article/details/118061120\nhttps://blog.csdn.net/weixin_44198965/article/details/104145043\n\n但是我修改了之后还是没有用，百度了另外几个操作，都没有办法正常启动mysqld，那能咋办，放弃了。\n用回最开始安装的mariadb了😥\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】字节跳动MySQL连环40问","url":"/posts/3873856211/","content":"字节MySQL连环40问，网图\n\n\n\n虽然感觉这玩意和字节跳动没关系，但是管他的？直接开始回答！\n1.MySQL中有哪几种锁？\n会的不全，所以查的GPT\n\nMySQL中有多种类型的锁，主要包括以下几种：\n\n共享锁（Shared Lock）：也称为读锁，多个会话可以同时持有共享锁，并且不互斥。共享锁适用于读取操作，多个会话可以并发读取同一份数据而不会产生冲突。\n排他锁（Exclusive Lock）：也称为写锁，排他锁与其他任何锁都互斥，只有一个会话可以持有排他锁。排他锁适用于写入或修改操作，确保在某个会话持有排他锁的时候，其他会话无法同时进行写入操作。\n记录锁（Record Lock）：记录锁（行锁）是针对某条记录的锁定，用于保护特定记录的完整性。在使用InnoDB存储引擎时，读取或修改某条记录时会自动给该记录加上记录锁，其他会话则无法对该记录进行并发写入或删除操作。\nGap锁：Gap锁是InnoDB引擎的一种锁机制，用于防止幻读。它锁定了一个范围，但不包含实际的记录，用于防止其他会话在这个范围内插入新记录，以避免幻读现象的发生。\n表锁（Table Lock）：表锁是对整个表格进行锁定，可以在某些特殊情况下使用，但会阻塞其他会话的读取和写入操作。在需要并发读写的情况下，表锁的性能较低，因此一般不推荐使用。\n\n除此之外，还有一个NEXT-KEY锁：\nNEXT-KEY 锁是 InnoDB 存储引擎中的一种锁机制，用于解决幻读问题。它是通过将 Gap 锁和 记录锁 组合而成的。\n具体来说，当一个事务在 InnoDB 表中执行范围查询时，如使用 &lt;、&lt;=、&gt;、&gt;= 等操作符，InnoDB 引擎会为查询涉及到的范围加上 NEXT-KEY 锁。这个 NEXT-KEY 锁包含两部分：\n\nGap 锁：锁定了查询范围内的间隙（Gap），防止其他事务向该范围内插入新的记录。\n记录锁：锁定了满足查询条件的记录，防止其他事务对这些记录进行并发修改或删除。\n\n通过使用 NEXT-KEY 锁，InnoDB 可以有效地避免幻读现象的发生。它保证了在一个事务读取一个范围的数据时，其他事务无法并发地在该范围内插入新的记录，从而保证了读取的一致性。\n需要注意的是，NEXT-KEY 锁只在事务隔离级别为可重复读（REPEATABLE READ）或更高级别时使用（MySQL默认隔离级别为可重复读）。在较高的并发环境下，使用 NEXT-KEY 锁可能会增加锁冲突的概率，因此在设计数据库和查询时需要考虑到锁的开销和事务的隔离级别。\n2.MySQL中有哪些不同的表格？\n这个也是GPT回答的，注意，表格和存储引擎不是同一个概念！\n\n在MySQL中，有以下几种不同的表格类型：\n\nMyISAM：MyISAM是旧版本MySQL的默认表格类型。它提供了快速的读取速度，适用于大量的并发读取操作。不过，MyISAM不支持事务处理和崩溃恢复功能。\nInnoDB：InnoDB是一种支持事务处理和崩溃恢复功能的表格类型。它提供了行级锁定和外键约束等高级功能，适用于需要数据完整性和并发写入操作的场景。InnoDB是MySQL 5.5版本后的默认表格类型。\nMemory：Memory（也称为Heap）表格是将数据存储在内存中的临时表格类型。它在读取和写入方面非常快速，但它的数据是临时的，当数据库服务器重启时，表格中的数据将会丢失。\nArchive：Archive表格是一种高度压缩的表格类型，适用于存储大量历史数据和归档数据。它对于读取操作不太有效，但在大量写入和存储空间方面具有优势。\nCSV：CSV表格允许将数据以CSV（逗号分隔值）格式存储在文件中，支持导入和导出数据。它不支持索引，事务处理和其他高级特性。\n\n除了以上列举的几种常见的表格类型外，MySQL还支持其他一些特殊用途的表格类型，如Partitioned（分区表格）和Federated（联合表格）等。\n\n表格和存储引擎是同一个东西吗？并不是！\n\n在关系型数据库中，表格（Table）是指一个逻辑上的数据结构，用来组织和存储数据。一张表格由若干列（Column）和若干行（Row）组成，每列定义了一种数据类型和一个字段名，表格中的每一行则代表一个实体或记录，每个单元格存储着对应列的一个数值或字符串。\n存储引擎（Storage Engine）则是指实现了数据库的表格和索引等功能的底层软件模块，它负责将表格数据存储到磁盘、跟踪并处理事务、执行查询语句等任务。不同的存储引擎具有各自的特点和优缺点，在不同场景下选择合适的存储引擎可以提高数据库的性能和可靠性。\n3.MyISAM和InnoDB的区别？MyISAM\n\n不支持事务；\n采用非聚簇索引，普通索引和主键索引的形式相同；\n一张表包含三个本地文件；\n\nInnoDB\n\n支持事务；\n采用聚簇索引，普通索引存放的是主键索引中的key值，需要回表查询；可以用索引覆盖来优化；\n一张表包含两个本地文件；\n\n4.InnoDB支持的四种事务隔离级别和区别四种隔离级别：读未提交，读已提交，可重复读，串行化；\n这部分直接去看我的MySQL索引博客，里面详细介绍了区别，这里就不重写一遍了；\n5.CHAR和VARCHAR的区别\nchar是定长字符串，最长255；varchar是变长字符串，最长65535；\n这就意味着varchar需要更多空间来存放当前字符串长度等信息，并且会根据当前字符串长度动态开辟空间大小，不会有额外的存储空间浪费；\n而char是定死的空间，char(8)里面即便只有一个字符也会占用八个的空间（会用空格进行补齐）；\n在字符串长度确定的情况下，比如计算长度确定的MD5，那就可以用char定长存储；长度不确定的情况下，比如人名、邮箱等信息，可以采用varchar；\n\n顺带说一下varchar和text的区别；需要进行索引的长文可以用TEXT进行存储（注意，只有MyISAM支持全文索引）\n\n存储空间：VARCHAR列存储的内容长度是可变的，而TEXT列可以存储大量的可变长度的文本数据。VARCHAR在存储时会根据实际存储的内容长度进行调整，而TEXT没有固定的最大长度限制，可以用来存储非常长的文本。由于TEXT可以存储更大的数据量，因此它通常占用更多的存储空间。\n查询性能：由于VARCHAR具有固定的最大长度限制，数据库可以更好地优化和管理存储空间，这可能会在某些情况下提升查询性能。而TEXT由于其可变长度和大容量，可能会对某些查询操作稍有影响。\n索引和排序：VARCHAR可以被索引和排序，这意味着可以根据这些列进行快速搜索和排序操作。而TEXT类型通常不直接支持索引和排序，需要额外的配置和处理才能实现类似的功能。\n\n如下user1表做测试，会发现我们无法给TEXT类型上普通索引。给出的提示是，BLOG/TEXT类型不能在没有指定长度的时候上索引；因为你的长度不确定，如果MySQL将一个几万字的TEXT存到内存里面作为索引节点，那么就会占用过多的内存空间。\nMariaDB [hello_mysql]&gt; desc user1;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(200)     | NO   |     | NULL    |       || info  | text             | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+3 rows in set (0.001 sec)MariaDB [hello_mysql]&gt; alter table user1 add index(info);ERROR 1170 (42000): BLOB/TEXT column &#x27;info&#x27; used in key specification without a key length\n\n即便在创建列的时候给定了TEXT的长度，依旧不能创建索引。\nMariaDB [hello_mysql]&gt; alter table user1 add info1 TEXT(20) NOT NULL;Query OK, 0 rows affected (0.002 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello_mysql]&gt; desc user1;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(200)     | NO   |     | NULL    |       || info  | text             | NO   |     | NULL    |       || info1 | tinytext         | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+4 rows in set (0.001 sec)MariaDB [hello_mysql]&gt; alter table user1 add index(info1);ERROR 1170 (42000): BLOB/TEXT column &#x27;info1&#x27; used in key specification without a key length\n\n正确的写法如下，需要在创建索引的时候，括号指定索引的长度；比如index(info1(10))含义就是给info1列的前10个字符建立索引。只要TEXT里面存放的文本前10个字符重复率低，那么这个索引就是有意义的！\nMariaDB [hello_mysql]&gt; alter table user1 add index(info1(10));Query OK, 0 rows affected (0.007 sec)Records: 0  Duplicates: 0  Warnings: 0\n\n6.主键和候选键(码)有啥区别？候选键是一些可以选用（备选）为主键或者唯一键的类型；\n比如一个学生表里面，包含学生主键的INT自增ID，学生学号，学生身份证，学生姓名，学生性别等等信息；在这个表里面，除了主键这个INT的ID，我们还可以把学生的学号和学生的身份证作为主键或者唯一键，因为他们都包含唯一性！\n这时候，这些可以作为主键的列，就叫做候选键；\n\n候选键也需要保持唯一性\n候选键需要遵循最小原则，不能是某一个聚合唯一标识的子集；（比如我需要用部门ID和部门内员工ID来唯一标识一个员工，此时部门ID就不能作为这个员工表的候选键，因为在整个表中部门ID会重复）\n\n在《数据库系统概率》这门课里面，会把键称作为码，本质上是一个东西。\n\n到底是谁把key翻译成码的？真无语😒\n\n7.myisamchk是用来干什么的一个命令行工具（在bash下使用，不是在MySQL命令行使用）\n\nMyisamchk是MyISAM表维护的一个非常实用的工具。可以使用myisamchk实用程序来获得有关数据库表的信息或检查、修复、优化他们。myisamchk适用MyISAM表(对应.MYI和.MYD文件的表)。\n\n这个命令了解即可，下面是两篇使用博客。有需要再去深入学习用法\nhttp://www.4u4v.net/myisamchk-gadgets-manual.html\nhttps://www.cnblogs.com/analyzer/articles/1381538.html\n8.如果表中有一列定义为TIMESTAMP会发生什么TIMESTAMP底层一般是4个字节，在MySQL里面进行查询的时候，会根据系统时区，转成可读时间进行输出。包括使用cpp devel包获取到的也是可读时间；\n因为只有4个字节，所以TIMESTAMP最多能表示 1970-01-01 00:00:01到2038-01-19 03:14:07，这也是一个2038年问题，需要改成8字节存储才能存放更长的时间。\n另外，如果你想更加精确的标识时间，而不依赖于MySQL对时间戳的自动转换，那么就可以用BIGINT或者DECIMAL类型来存放时间戳数字，再在应用层进行时间戳和可读时间之间的转换。\n9.怎么看到表格定义的所有索引两种方式都可以\nshow index from 表名;show keys from 表名;\n\n10.LIKE声明中的%是什么意思代表通配符，匹配所有字符串。下面举几个例子\n查询 &#x27;张%&#x27;    张丽丽    张扣扣    张三    张阿斯顿查询 &#x27;%张%&#x27;\t里张里    十大张撒打发查询 &#x27;%张&#x27;\txx张\txxxxx张\n\n需要注意，只有关键字%的使用方式才能用上索引，另外两种匹配方式无法使用索引！\n11.列对比运算符是什么等于 =不等于 &lt;&gt; !=大于和大于等于  &gt; &gt;=小于和小于等于  &lt; &lt;=区间 BETWEEN .. AND ...是否在列表中 IN模糊匹配 LIKENULL比较 IS NULL, IS NOT NULL\n\n12.BLOB和TEXT有什么区别？GPT说的：\n\n存储容量：BLOB可以存储二进制数据，而TEXT只能存储纯文本数据。\n字符集排序规则：BLOB没有字符集排序规则，而TEXT有，默认为字符集的排序规则。\n数据排序和比较：BLOB会按二进制方式进行排序和比较，而TEXT会按字符排序规则进行排序和比较。\n存储方式：BLOB数据以二进制形式存储，没有字符集转换；而TEXT数据会根据字符集进行转换和存储。\n索引：在MySQL中，BLOB和TEXT列可以有索引，但有一些限制。BLOB列或前缀索引的最大长度是768字节，对于UTF-8字符集是255个字符。而TEXT列或前缀索引的最大长度是3072字节，在UTF-8字符集中是1024个字符。\n默认值：BLOB和TEXT列不能具有默认值。\n\n总的来说，BLOB适合存储二进制数据，例如图像、音频或视频文件等。而TEXT适合存储纯文本数据，如长文本、文章内容等。根据具体的需求，你可以选择适当的数据类型来存储相应的数据。\n\n实际上，把图片、音频这些静态资源存入数据库是不合理的……\n\n13.MySQL_fetch_array和MySQL_fetch_obj有什么区别？PHP里面的函数，不学，直接跳过\n14.MyISAM表格将在那里存储？并且还提供其存储格式？在linux下，MyISAM表格以文件形式存储在数据目录下的对应数据库目录中。每个表格对应一个.MYD数据文件（用于存储表格数据）和一个.MYI索引文件（用于存储表格索引），以及一个.frm表格定义文件（包含表格定义信息，如字段名、数据类型等）\nMyISAM使用一种称为“静态行格式”的存储格式来存储表格数据。这种格式用于在磁盘上保存由定长行组成的表格，每个行定长，占用相同的存储空间，以便更快地读取和写入数据。MyISAM表格还支持动态行格式，这种格式允许可变行长度，因此可以更有效地存储可变长度的数据类型（如VARCHAR，TEXT等）。\n15.MySQL如何优化DISTINCT?使用索引，减少查询行数来优化去重操作\n16.如何显示前50行？查询语句后带上limit就可以\nselect * from 表名 limit 50;\n\n17.可以使用多少列创建索引？根据实际使用场景来确定用几列，并没有固定限制。理论上来说需要保持最小原则，不要包含多余的无效列（除非你需要用来进行索引优化，减少回表操作）\n18.now和current_date有什么区别？now会返回一直到时分秒的信息，current_date只会返回当日日期\n19.什么是非标准字符串类型\nGPT\n\n非标准字符串类型是指在数据库中没有明确定义或标准化的字符串数据类型。这些类型通常是特定数据库管理系统（DBMS）或应用程序开发框架所支持的扩展。由于不同的DBMS和框架有各自的特性和需求，可能会引入额外的非标准字符串类型以满足特定的数据存储和操作需求。\n举例来说，MySQL数据库在其标准字符串类型中包含了CHAR、VARCHAR、TEXT等。而非标准字符串类型可能是根据具体需求和扩展开发的，如JSON、XML、BLOB、CLOB等。这些非标准类型在一些特定场景中使用广泛，例如存储非结构化的文本数据、大型二进制数据、以及存储和查询复杂的结构化数据等。\n需要注意的是，非标准字符串类型在不同的DBMS和开发框架之间可能存在差异，并且在跨平台和迁移时可能会出现兼容性问题。因此，在使用非标准字符串类型时，建议仔细了解相关的文档和规范，并评估其对应用程序的影响和可移植性。\n20.什么是通用SQL函数以下列举了一些常见的通用SQL函数：\n\n聚合函数：如SUM、AVG、COUNT、MIN、MAX等，用于对数据进行统计和聚合计算。\n字符串函数：如CONCAT、SUBSTRING、UPPER、LOWER、LENGTH等，用于处理和操作字符串数据。\n数值函数：如ABS、ROUND、CEILING、FLOOR等，用于执行数值计算和转换。\n日期和时间函数：如DATE, TIME, YEAR, MONTH, DAY等，用于处理日期和时间数据的计算和格式化。\n条件函数：如IF, CASE WHEN, COALESCE等，用于根据条件执行不同的逻辑和返回不同的结果。\n类型转换函数：如CAST、CONVERT等，用于在不同的数据类型之间进行转换。\n\n这只是一小部分通用SQL函数的例子，实际上还有很多其他的函数可用于不同的数据处理和查询需求。需要注意的是，尽管这些函数在大多数DBMS中都存在，但某些特定的DBMS可能会提供额外的函数或有稍微不同的语法，因此在使用函数时应查阅相应的文档和规范以确保兼容性和正确性。\n21.MySQL支持事务吗？肯定支持，这个问题第四点就已经详细问了\n22.MySQL里面记录货币用什么类型好？因为浮点数的精度问题，可以用BIGINT来存放以分为单位的货币，实际调用的时候再加上小数点，来保证数据准确。\n如果不用BIGINT，那就需要用DECIMAL来存放货币。\n\nB站冲浪看到的\n\n23.MySQL有关权限的表有那几个在MySQL中，有几个与权限相关的系统表和视图，用于管理用户、角色和权限。以下是一些常见的权限相关的表和视图：\n\nmysql.user：这个表包含了MySQL实例上的所有用户账户信息，包括用户名、密码等。该表记录了每个用户的全局权限。\nmysql.db：这个表记录了用户对数据库级别的权限。它指定了哪个用户对哪个数据库具有什么样的权限。\nmysql.tables_priv：这个表记录了用户对表级别的权限。它存储了用户对某个具体表的权限信息（如SELECT、INSERT、UPDATE、DELETE等）。\nmysql.columns_priv：这个表记录了用户对列级别的权限。它存储了用户对表中某个具体列的权限信息。\nmysql.procs_priv：这个表记录了用户对存储过程和函数的权限。\nmysql.roles：这个表存储了角色的相关信息，包括角色名、角色的创建者等。\n\n除了上述的表之外，MySQL还提供了一些权限相关的视图，这些视图可以方便地查看用户、角色和权限的信息，如：\n\ninformation_schema.USER_PRIVILEGES：显示所有用户的权限信息。\ninformation_schema.SCHEMA_PRIVILEGES：显示所有数据库的权限信息。\ninformation_schema.TABLE_PRIVILEGES：显示所有表的权限信息。\ninformation_schema.COLUMN_PRIVILEGES：显示所有列的权限信息。\n\n如下是个使用示例\nselect * from information_schema.USER_PRIVILEGES;\n\n这些表和视图可以通过查询相应的系统表或视图来查看和管理用户、角色和权限。请注意，具体的系统表和视图名称可能因MySQL版本和配置而有所不同。为了确保准确性，请参考MySQL官方文档或特定版本的文档。\n24.列的字符串类型可以是什么TEXT CHAR VARCHAR，详见第五点\n25.MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？\n没见过这种业务，只能问GPT\n\n对于一个MySQL作为发布系统存储的场景，处理每天超过五万条增量数据并且需要保持三年的数据，以下是一些优化建议：\n\n数据库硬件和配置优化：\n硬件性能：确保数据库服务器具备足够的计算、内存和存储资源，以处理高负载的写入和读取操作。\n存储设备：使用高性能的存储设备（如SSD）来提高写入和读取速度。\nMySQL参数调优：根据实际情况调整MySQL的配置参数，例如设置合理的缓冲区大小、并发连接数、查询缓存等。\n\n\n数据库架构优化：\n分库分表：考虑将数据进行分库分表来分担单个数据库的负载压力。根据数据的特点和访问模式，合理划分数据到不同的库表中。\n索引优化：根据查询需求创建合适的索引，以加快查询速度。避免过多的索引和冗余索引，以减少维护成本。\n分区表：如果数据的时间范围有明显的界限，可以考虑使用MySQL的分区表功能，将数据按时间范围进行分区，提高查询性能和维护效率。\n\n\n数据写入优化：\n批量插入：使用批量插入方式（如INSERT INTO … VALUES (), (), ()…）来减少单条插入的开销，提高写入性能。\n事务处理：将多个写入操作放在一个事务中，确保数据的一致性和完整性，减少IO开销。\n\n\n数据归档和压缩：\n数据归档：对于历史数据，可以将其归档到独立的存储介质中，例如将旧数据迁移到归档数据库或者离线存储系统中以减轻主数据库的负载。\n数据压缩：对于不频繁查询的历史数据，可以考虑使用压缩算法（例如MySQL的压缩表功能或者第三方压缩库）进行存储，以减少存储空间占用。\n\n\n监控和优化工具：\n使用监控工具实时监测数据库的性能指标，如查询速度、磁盘使用、锁等情况，及时发现潜在的性能瓶颈并进行调优。\n使用性能优化工具，如Explain分析、慢查询日志等，来找出慢查询和低效的SQL语句，并进行优化。\n\n\n\n以上是一些常见的优化建议，具体优化方案还需要根据实际场景和需求进行调整。同时，建议在进行优化前，充分了解应用的读写特征、数据访问模式和业务需求，以便有针对性地进行优化工作。\n26.锁的优化策略？27.索引的底层实现和优化？底层用B+实现，优化索引方式见索引博客 https://blog.musnow.top/posts/3474107655/\n28.什么情况下有索引但是无法使用索引失效，见索引博客 https://blog.musnow.top/posts/3474107655/\n29.实践中如何优化MySQL太宽泛了，不好回答\n\n索引优化\n分表\n事务隔离性选择\n\n30.优化数据库的办法？和29题重合，不做回答\n31.简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）见索引博客 https://blog.musnow.top/posts/3474107655/\n32.数据库的事务是什么见事务博客 https://blog.musnow.top/posts/2200233148/\n33.SQL注入漏洞的产生和原因，如何防止SQL注入漏洞是一种常见的安全漏洞，它可以使攻击者通过构造恶意的SQL语句来绕过应用程序的输入验证，进而执行非法的数据库操作或获取敏感信息。以下是SQL注入漏洞产生的原因和一些防止方法：\n\n原因：\n不正确的输入验证：当应用程序没有对用户的输入进行充分验证和过滤时，攻击者可以通过输入特定的字符或语句来修改SQL语句的结构，从而执行恶意操作。\n拼接字符串构造SQL语句：如果应用程序使用拼接字符串的方式构造SQL查询语句，并且未对用户输入进行正确的转义处理，就容易受到SQL注入攻击。\n\n\n防止方法：\n使用参数化查询或预编译语句：参数化查询将用户输入作为参数传递给SQL语句，而不是直接拼接字符串。这样可以通过数据库驱动程序自动处理转义和编码，有效防止SQL注入攻击。\n输入验证和过滤：对用户的输入数据进行验证和过滤，只接受符合规范的数据。可以使用白名单、黑名单、正则表达式等方法进行输入验证和过滤。\n最小权限原则：在数据库中为应用程序使用的账号设置最小权限，即只授予应用程序完成必要操作所需的最低权限，避免攻击者利用注入漏洞进行更危险的操作。\n不要直接暴露数据库错误信息：在生产环境中，不要将详细的数据库错误信息返回给用户，以防止攻击者从中获取关键信息。可以记录错误日志并给用户一个友好的错误提示。\n定期更新和修补数据库和应用程序：及时安装数据库和应用程序的安全补丁，以修复已知的漏洞，并确保使用最新的安全措施。\n\n\n\n总之，为了防止SQL注入漏洞，关键是要对用户输入数据进行合理验证、过滤和转义处理，并使用参数化查询或预编译语句来构造SQL语句。同时，保持应用程序和数据库的安全性，并及时更新和修补已知的安全漏洞。\n34.如何为表中字段选择合适数据类型肯定是根据具体情况回答\n35.存储时期？感觉这道题有问题，不管他\n36.索引相关问题？和31重合，不回答\n37.解释MySQL中外连接、内连接、自连接的区别\n内连接（INNER JOIN）：\n内连接返回两个表中满足连接条件的记录，即只返回两个表中能够匹配的行。\n内连接使用一个连接谓词（JOIN）或者在FROM子句中使用逗号（,）来表示。\n内连接可以根据指定的连接条件将两个表中的列进行匹配。如果未提供连接条件，则会返回两个表的笛卡尔积。\n语法示例：SELECT * FROM 表1 INNER JOIN 表2 ON 表1.列 &#x3D; 表2.列;\n\n\n外连接（OUTER JOIN）：\n外连接将返回两个表中满足连接条件的记录，并且还包括不满足连接条件的记录。\n外连接分为左外连接（LEFT JOIN）和右外连接（RIGHT JOIN）。\n左外连接返回左表中的所有记录，以及右表中与左表满足连接条件的记录。如果右表中没有匹配的记录，则会返回NULL值。\n右外连接返回右表中的所有记录，以及左表中与右表满足连接条件的记录。如果左表中没有匹配的记录，则会返回NULL值。\n语法示例：\n左外连接：SELECT * FROM 表1 LEFT JOIN 表2 ON 表1.列 &#x3D; 表2.列;\n右外连接：SELECT * FROM 表1 RIGHT JOIN 表2 ON 表1.列 &#x3D; 表2.列;\n\n\n\n\n自连接（SELF JOIN）：\n自连接是指将表视为两个独立的实例，使用别名来区分它们，然后根据某些条件将它们连接在一起。\n自连接通常用于在同一个表中根据某种关系进行数据查询。\n语法示例：SELECT 别名1.列, 别名2.列 FROM 表 别名1, 表 别名2 WHERE 别名1.列 &#x3D; 别名2.列;\n\n\n\n总结：\n\n内连接返回两个表中匹配的记录，外连接返回满足连接条件的记录以及不满足连接条件的记录，而自连接是对同一个表进行连接操作。\n内连接和外连接需要使用JOIN关键字，而自连接使用同一个表的别名进行连接。\n内连接和外连接可以根据连接条件将两个表进行关联，而自连接可以根据表中的某些条件进行关联。\n\n38.MySQL中事务回滚机制描述见事务博客 https://blog.musnow.top/posts/2200233148/\n39.SQL语言包含哪几部分？每部分都有哪些操作关键字包括DQL数据查询语言，DML数据操作语言（增删改），数据控制语言DCL用来管理数据库，事务控制语言TCL用来控制事务，数据定义语言DDL用来创建删除表\n\n数据查询语言（Data Query Language，DQL）：用于从数据库中查询和检索数据。常用的操作关键字包括：\nSELECT：用于从一个或多个表中选择数据列以进行查询。\nFROM：指定要查询的表。\nWHERE：用于指定查询的条件。\nGROUP BY：按照指定的列对结果进行分组。\nHAVING：用于指定对分组后的结果进行筛选的条件。\nORDER BY：指定结果集的排序方式。\n\n\n数据操作语言（Data Manipulation Language，DML）：用于对数据库中的数据进行增加、修改和删除操作。常用的操作关键字包括：\nINSERT INTO：向表中插入新的行或数据。\nUPDATE：更新表中已有的数据。\nDELETE FROM：从表中删除指定的行或数据。\n\n\n数据定义语言（Data Definition Language，DDL）：用于创建、修改和删除数据库和表结构。常用的操作关键字包括：\nCREATE DATABASE：创建新的数据库。\nCREATE TABLE：创建新的数据表。\nALTER TABLE：修改已存在的数据表结构。\nDROP DATABASE：删除现有的数据库。\nDROP TABLE：删除现有的数据表。\n\n\n数据控制语言（Data Control Language，DCL）：用于管理数据库中的用户权限和访问权限。常用的操作关键字包括：\nGRANT：授予用户特定的权限。\nREVOKE：撤销用户的权限。\n\n\n事务控制语言（Transaction Control Language，TCL）：用于管理数据库的事务处理。常用的操作关键字包括：\nCOMMIT：提交一个事务，使其永久生效。\nROLLBACK：回滚一个事务，撤销之前的操作，使其不生效。\nSAVEPOINT：在事务中设置保存点，以便在需要时进行回滚。\n\n\n\n40.完整性的约束包括那些？原子性、隔离性、持久性；这里说的完整性应该就是一致性；\n具体的解释依旧是去看事务的博客 https://blog.musnow.top/posts/2200233148/\n","categories":["学习sql"],"tags":["mysql"]},{"title":"【MySQL】事务","url":"/posts/2200233148/","content":"学习了之后，你会对MySQL如何进行数据的访问控制有更深刻的了解；\n\n\n本文中有大量截图，如果出现404的图片，请评论告知，谢谢；\n1.什么是事务？1.1 场景举例1.1.1 转账当A需要给B转账50元的时候，后台应该进行如何处理？\n-- 先判断用户还有多少余额（这里的user_id=A只是一个示例，知道什么意思就行）select money from user where user_id=A;-- 如果余额充足，那就给A扣50update user set money = money - 50 where user_id=A;-- 然后给B加50update user set money = money + 50 where user_id=B;\n\n这一个操作，需要3个SQL语句才能完成，但很明显，我们即便在当前的服务器端对这3条语句的操作进行加锁，也没有办法避免如下的情况\n\n服务器负载过高，进程被kill了\n服务器断电了\nMySQL服务器抽风挂掉了\n等等不可抗力\n\n这时候，如果在执行第一条查询语句后就挂掉了，那还不会有啥问题；但如果是在执行完毕第二条扣钱的语句之后挂掉了，那问题就大了！\n\nA给B转钱，A的钱扣了，B的钱没有加，这怎么可以？\n\n最终还需要程序员通过MySQL的日志一个个核对到底是谁出现了这样的情况，给人家把钱加回去，那太过麻烦；在数据量大的时候，这种工作更是不应该由人工手动完成的！\n所以，MySQL就需要提供一种方法，让我们能够实现类似原子性的操作。在执行这3条语句的时候，只能出现两种情况：\n\n成功执行，A扣了钱，B也加了钱，转账成功；\n执行失败，但是A和B的钱都没有变化，并告知用户转账失败；\n\n这样才是靠谱的结果！\n1.1.2 卖票另外一个场景就是卖票，其也包含了多条SQL\nselect * from ticket where tid=?; -- 查询某某车次高铁的票还有没有余量-- 有余量，进行售卖流程；这里可能要操作另外一张表来添加买票者的用户信息update ticket set num=num-1 where tid=?; -- 售卖流程结束，扣去这张票\n\n如果有两个客户端都同时来执行这两条SQL语句，那么就会出现问题；\n\n只剩一张票\n客户端A进行查询，发现有票，开始执行卖票流程\n客户端B进行查询，也发现有票，开始执行卖票流程\n此时A执行完毕，将票的数量-1，卖完票了；\n随后B执行完毕，也将票的数量-1，此时就会出现票数是负数的情况！\n更难受的是，同一张票被错误地卖给了两个用户！\n\n这时候在客户端里面加锁是不顶用的，两个客户端都不是同一个进程，锁无法共享；需要MySQL解决这个问题，就还得提供更加严格的访问控制，在A没有完成整个卖票逻辑，票数没有扣掉的情况下，B不可以来查询票数；\n1.2 事务的介绍事务（transaction）就是一组DML语句的集合，这些语句在逻辑上是一个整体；执行这组语句，必须全部成功，亦或者是全部失败。\n在执行这组SQL的时候，MySQL需要将其视作一个原子性的操作；这个操作不能被其他事务打断，出现问题的时候还需要回滚到开始执行之前的初始状态；事务还能使不同客户端看到的数据是不同的，不同事务之间的操作不会相互影响；只有事务结束后，双方才能看到对方的操作（根据隔离级别不同，这点也会有区别）；\n正如上面的两个场景所提到的操作，同一个时刻对于MySQL的一个数据库来说，其可能有多个客户端进行不同业务的操作，如果都在访问同一个表，在不加访问控制的情况下，一定会出现访问临界资源的数据二义性问题。\n\n事务的出现，是客户端在实际应用场景下的需要，\n\n所以，一个完整的事务，除了是多条DML语句的集合，还需要满足下面4个特性\n\n原子性：一个事务中的所有操作，要么全部完成，要么全部失败；如果事务在执行过程中发现错误，那就需要回滚（Rollback）到事务开始之前的状态，就好比这个事务并没有执行过一般\n一致性：事务开始之前和结束后，数据库的完整性没有被破坏。进行的操作复合我们预设的要求；这包含数据的准确度、串联性以及后续数据库可以自发完成预定的工作；\n隔离性：数据库允许多个并发事务同时对数据库中的数据进行CURD操作，隔离性保证这些事务之间的操作并不会由于并发的交叉运行而出现不一致的情况。事务隔离性分为不同级别，具体的区别会在后文详解\n读未提交（Read Uncommitted）\n读已提交（Read Committed）\n可重复读（Repeatble Read）\n串行化（Serializable）\n\n\n持久性：事务处理完毕后，对事务的修改是永久的，即便系统宕机了也不会丢失（除非硬盘坏了）\n\n上面的四个属性，简称为ACID；\n原子性（Atomicity，或称不可分割性）一致性（Consistency）隔离性（Isolation，又称独立性）持久性（Durability）\n\n其中，一致性是由原子性、隔离性、持久性来保证的，只要满足了这三个性质，自然能实现一致性。简单记忆，AID来保证C；\n1.3 事务的存储引擎支持在MySQL中，只有Innodb支持事务，MyISAM是不支持事务的；\n我们可以用如下语句来查询MySQL的引擎和支持的特性\nMariaDB [hello_mysql]&gt; show engines \\G*************************** 1. row ***************************      Engine: MEMORY     Support: YES     Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 2. row ***************************      Engine: MRG_MyISAM     Support: YES     Comment: Collection of identical MyISAM tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 3. row ***************************      Engine: CSV     Support: YES     Comment: Stores tables as CSV filesTransactions: NO          XA: NO  Savepoints: NO*************************** 4. row ***************************      Engine: BLACKHOLE     Support: YES     Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO          XA: NO  Savepoints: NO*************************** 5. row ***************************      Engine: MyISAM     Support: YES     Comment: Non-transactional engine with good performance and small data footprintTransactions: NO          XA: NO  Savepoints: NO*************************** 6. row ***************************      Engine: ARCHIVE     Support: YES     Comment: gzip-compresses tables for a low storage footprintTransactions: NO          XA: NO  Savepoints: NO*************************** 7. row ***************************      Engine: FEDERATED     Support: YES     Comment: Allows to access tables on other MariaDB servers, supports transactions and moreTransactions: YES          XA: NO  Savepoints: YES*************************** 8. row ***************************      Engine: PERFORMANCE_SCHEMA     Support: YES     Comment: Performance SchemaTransactions: NO          XA: NO  Savepoints: NO*************************** 9. row ***************************      Engine: SEQUENCE     Support: YES     Comment: Generated tables filled with sequential valuesTransactions: YES          XA: NO  Savepoints: YES*************************** 10. row ***************************      Engine: InnoDB     Support: DEFAULT -- 默认引擎     Comment: Supports transactions, row-level locking, foreign keys and encryption for tables -- 描述Transactions: YES  -- 支持事务          XA: YES    Savepoints: YES  -- 支持事务中的保存点*************************** 11. row ***************************      Engine: Aria     Support: YES     Comment: Crash-safe tables with MyISAM heritageTransactions: NO          XA: NO  Savepoints: NO11 rows in set (0.000 sec)\n\n1.4 保存点所谓保存点，就是在事务执行过程中，给当前的数据设置一个savepoint，这样在出现问题的时候，可以回退到当前的数据中；就好比之后的操作没有进行一样；\n游戏中的保存点其实也是这样的功能，让玩家回退到打某个BOSS之前，包括当时你收集的材料，都会回退到打这个BOSS之前的状态；\n你可以理解为，是给当前的数据拍了张照片，出现问题的时候，用这个照片里面的东西复写掉新的东西。这便是保存点的作用；\n1.5 基础命令操作先提一下事务的开启和结束方式，以及如何设置保存点和回滚吧\n-- 开启，这两种方式是一样的begin;start transaction;-- 设置保存点（名字可以自由更改，但不能有重复）savepoint save1; -- 创建一个保存点save1rollback to save1; -- 回滚到保存点save1rollback; -- 回滚到事务开始-- 结束commit; -- 提交事务\n\n2.使用了解了事务为什么存在，下面就是来使用一下事务了；\n2.1 提交方式事务的提交方式有两种方式\n\n自动提交\n手动提交\n\n默认情况下，MySQL的自动提交是处于开启状态的\nMariaDB [hello_mysql]&gt; show variables like &#x27;autocommit&#x27;;+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | ON    |+---------------+-------+1 row in set (0.001 sec)\n\n我们可以用下面的语句来设置是否开启自动提交（只对当前会话生效）\nset autocommit = 0; -- 关闭自动提交set autocommit = 1; -- 开启\n\n这两个提交方式有啥区别呢？是不是开了自动提交就什么都不用管了？后文我们再通过实测来说明；\n2.2 场景演示最开始测试的时候，先将事务隔离级别设置为读未提交；请注意，不要在有生产环境的MySQL中进行此项操作；\n-- 设置全局隔离级别为读未提交set global transaction isolation level READ UNCOMMITTED; -- 重启mysql终端后查看隔离级别select @@tx_isolation; +------------------+| @@tx_isolation   |+------------------+| READ-UNCOMMITTED |   -- 成功设置读未提交的隔离级级别+------------------+1 row in set (0.000 sec)\n\n2.2.1 数据回滚演示设置完毕后，进入测试数据库，创建如下测试表\ncreate table test_ruc(\tid int unsigned primary key,\tuser_id int unsigned not null,    name varchar(30) not null);\n\n先给表里面插入几个基本的数据：\ninsert into test_ruc values (1,10,&#x27;李华&#x27;),(2,20,&#x27;王五&#x27;);\n\n插入后，我们在两侧的终端中都可以看到已有的数据\n\n随后在两个终端中都开启一个事务，左侧终端插入一个数据，右侧终端查看\ninsert into test_ruc values (3,30,&#x27;左侧终端插入&#x27;);\n\n可以看到，两侧的终端都可以看到这份数据\n\n此时将左侧终端强制退出（使用CTRL+\\），右侧再次查询，会发现新插入的数据没有了；这里便是事务的原子性的体现，左侧的终端所执行的事务没有commit就因为异常退出了，MySQL自动将数据回滚到了这个事务执行之前，即没有插入这份新数据；\n\n左侧重新链接MySQL，开启一个事务；在右侧插入一个数据，随后创建保存点save1；插入第二个数据，创建保存点save2；\n在左侧查询，我们可以看到右侧插入的两条新数据；\n\n在右侧回滚到保存点save1，会发现插入的数据2没有了；这与保存点的预期操作相符合；\n\n将右侧终端强制退出，再次查询数据，可以看到第一次插入的数据也没有了，数据又回到了右侧终端事务开始之前的样子。\n\n这里能得出一个结论：如果终端异常退出，MySQL会将数据回滚到事务开始时；你可以理解为，我们使用begin;的时候就已经创建了一个隐藏的保存点，MySQL在异常的时候只会将数据回退到这个事务开始之时的隐藏保存点，无论中途用户有没有设置其他保存点！\n即：在异常退出的时候，MySQL会自动帮我们执行rollback命令回退到事务开头！\nrollback; -- 回退到事务开头\n\n这样就能避免最开始提到的，转账系统中给A扣了钱但是没有给B加钱的问题！\n2.2.2 数据持久化演示接着我们再来看看，如果执行了commit之后又会是什么情况；\n右侧提交了事务后退出，左侧依旧能查询倒已经提交的数据。代表数据已经被持久化写入到了磁盘（当然这个时候也不一定立刻刷盘了，但是这已经能代表MySQL将我们的数据加入到了持久化策略中，并不需要我们管啥时候刷盘的问题！）\n\n2.2.3 自动提交前面提到了，MySQL的自动提交默认是开启的；那么这个自动提交有什么作用呢？是不是开启了自动提交，就不需要手动创建事务了？\n并不是！在之前的测试中，autocommit是开启的；我们已经证明了，手动begin创建的事务，在没有手动commit的时候不会被写入磁盘（不进行持久化）；这代表我们手动创建的事务，不会受到autocommit是否开关的影响；（开着的时候都没有自动提交，关闭的时候肯定更不会自动提交了）\n\n那么这个autocommit会影响谁呢？\n\n开启两个终端，左侧将自动提交关闭，随后插入一个数据；插入后会发现右侧看不到左侧新插入的数据！\n\n备注：set autocommit = 0;语句只会影响当前终端，不会影响另外的终端。\n\n\n此时手动进行commit，右侧就看得到数据了！\n\n而如果我们不手动执行commit就把左侧终端CTRL+\\退出，那么新插入的这一条数据会丢失！\n2.2.4 单条SQL和事务的关系欸？我们明明没有begin开启事务，为什么可以执行commit呢？\n这是因为，在MySQL中，每一个不主动使用事务的单条SQL语句，都会视作一个事务进行操作！既我们之前没学习事务时，执行的所有单条SQL也是一个个各自独立的事务！\n知道了这一点，你就能理解自动提交的作用了：在执行单条SQL的时候，是否自动提交该SQL语句的事务。\n将autocommit重新开启，再进行测试；会发现左侧插入的数据右侧可以立马看到，无需手动commit。这便是自动提交的作用的体现！\n\n2.3 结论经过上面的这些简单测试，我们可以看到事务的原子性和持久性，做一个总结\n\n输入了begin/start transaction手动创建的事务，必须通过commit手动挡提交，才会持久化；这一点和autocommit无关！\n事务可以设置保存点和手动回滚，出现异常的时候，MySQL会自动回退到事务开头；\n对于InnoDB存储引擎而言，所有的单条SQL语句都会被视作一个事务，自动提交；\nselect语句会有一些差别，因为MySQL有MVCC访问控制（后文讲解）\n\n操作事务的一些注意事项\n\n只有InnoDB才支持事务，MyISAM不支持;\n一个事务被提交了之后，不可以执行rollback;\n创建了保存点后，可以选择回退到哪一个保存点，亦或者是回退到事务开头；\n\n3.事务隔离级别3.1 基本说明事务的隔离级别和事务的隔离性息息相关\n\nMySQL的单个数据库可能被多个进程&#x2F;线程同时进行访问和事务操作；\n一个事务是由多个SQL语句组成的，任何一个事务，都会存在执行前&#x2F;中&#x2F;后的阶段。所谓原子性，就是MySQL要保证各个客户端要么只能看到事务执行前或者执行后的数据；执行中的事务，对于其他用户来看是原子的，出现异常会被自动回滚；\n但事务毕竟还是存在执行中的概念，其他客户端是有可能看到某个事物执行中的状态的，这就需要隔离性来介入了；\n隔离性：保证事务在执行过程中尽量不受干扰；\n隔离级别：允许事务受不同程度的干扰；\n\n开头就提到了，MySQL的事务有4种隔离级别\n\n读未提交（Read Uncommitted）：在这个隔离级别中，所有事务都可以看到其他事物还没有提交的内容（你可以理解为压根没有隔离性，之前的测试使用的就是这个隔离级别）这种情况下就容易引起并发和读取数据的不一致问题，还有脏读问题（对方没有commit的数据就叫做脏数据），生产环境中是打死不能用这个隔离级别的！\n读已提交（Read Committed）：在这个隔离级别中，事务只可以看到其他事务已经提交了的内容。这已经满足了隔离的基本定义：只能看到其他事务开始前或者开始后的内容；但是这种隔离模式会产生不可重复读的问题（相同select会出现不同结果）；\n可重复读（Repeatable Read）：为了解决不可重复读的问题，这个隔离级别保证了事务在运行过程中多次读取相同数据时会得到相同结果；但是这个隔离级别在某些数据库中可能会出现幻读问题；MySQL默认采用此隔离级别；\n串行化（Serializable）：所谓串行化，就是MySQL给数据库的所有操作都上锁，必须要排队运行。一个事务在运行时，另外一个事务得等它运行完毕了才能进来运行，这样能最大程度保证隔离性；但是会降低效率；\n\n隔离级别是由MySQL进行各种类型的加锁来实现的，比如表锁、行锁、读写锁、间隙锁（GAP）、NEXT-KEY锁（GAP+行锁）等等；\n\n这里还需要验证另外一件事，MySQL如果开启了串行化，客户端c&#x2F;cpp操作还需要加锁吗？mysqlquery的操作是会阻塞还是直接错误退出？\n\n在MySQL中，事务的隔离级别可以分别设置全局的隔离级别和当前客户端的隔离级别；如果没有主动设置客户端的隔离级别，则会继承全局的隔离级别。顾名思义，会话隔离级别只会影响当前的会话，不会影响另外的客户端；\n另外，全局的隔离级别会在数据库服务重启后，被重置为配置文件中默认的隔离级别（一般是RR）\n-- 设置 会话/全局 隔离级别set [session | global] transaction isolation level [read uncommitted | read committed | repeatable read | serializable ]-- 查看当前会话的隔离级别select @@session.tx_isolation;-- 查看全局的隔离级别select @@tx_isolation;\n\n3.2 读未提交这个隔离级别在第二大点里面就已经测试过了，左侧终端插入的数据，即便没有commit，在右侧终端中也能看得到，这里就不二次演示了\n\n清楚已有的数据，来测试一下会话隔离级别的作用；默认情况下，全局和会话的隔离级别都是RR；\nMariaDB [hello_mysql]&gt; select @@tx_isolation;+-----------------+| @@tx_isolation  |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.000 sec)MariaDB [hello_mysql]&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| REPEATABLE-READ        |+------------------------+1 row in set (0.000 sec)\n\n将左侧的终端中的会话隔离级别设置为读未提交\nset session transaction isolation level read uncommitted;\n\n插入数据之前，执行一次select全列查询，两侧都是空；\n在左侧插入数据后，右侧查看会发现依旧是empty set没有结果；只有左侧commit之后，右侧才能看到数据；这是因为在之前测试的时候，我们将自动提交关闭了；右侧看不到我们还没有提交的事务；\n\n右侧手动开启事务后，即便没有进行commit，但是左侧因为设置了读未提交，所以可以直接看到右侧还没有提交的事务中的修改。这便是这个隔离级别的特性；\n\n3.3 读已提交接下来再将全局隔离级别设置为读已提交，重新开启两个终端进行测试；\nset global transaction isolation level read committed;\n\n设置完毕，重启终端后，可以看到两侧的隔离级别都是读已提交，自动提交都是开启的；\n\n两侧都开启一个事务，左侧插入数据，右侧查看，发现没有内容；\n\n左侧commit之后，右侧才可以看到这个数据；\n\n这符合我们对读已提交这个隔离级别的字面理解，但是这并不代表这个隔离级别没有问题！\n3.3.1 出问题的场景来看看下面这个场景：\n\n公司需要根据员工工资，分发不同级别的奖金：\n2000-4000 级别一\n4001-8000 级别二\n8001-15000 级别三\n\n\n甲开启了一个客户端，开始用MySQL筛选不同工资区间的员工，记录下来；\n乙开启了一个客户端，想要给员工丁加工资\n丁原本的工资是3000\n乙给丁加了2000工资，丁的工资变成了5000，跳到了工资级别二；\n乙提交修改（commit）\n\n\n假设甲已经完成了对2000-4000级别工资的员工筛选，此时乙过来给丁加了工资，丁跳到了工资级别二；\n因为隔离级别是读已提交，甲在筛选工资级别二的人员时，会把刚刚被修改过的丁也给纳入进去；\n这时候，对于甲而言，丁就同时出现在了工资级别一和二的人员中，这明显是不合理的！\n\n这个场景被称为不可重复读，即在一个事务中，同一个查询语句，可能会因为其他事务的提交而产生不同的结果；换做SQL语句来描述，在读已提交的隔离级别中，同一个select语句只能执行一次，第二次执行的时候，可能会获取到和第一次不同的结果，所以这个问题才被称作不可重复读（不可以重复执行select）问题；\n\n来实际演示一下，两侧都开启一个新的事务，左侧终端更新表中的用户id，只要它不提交，右侧就看不到修改。\n\n但是提交了之后，右侧就能看到这个用户id的改变，在进行数据筛选的时候，这种情形就会出现问题！\n\n3.4 可重复读所以，为了避免上面提到的这个问题，MySQL还提供了一个可重复读的隔离级别，且默认采用的就是这个隔离级别；\nset global transaction isolation level  repeatable read;\n\n可重复读就解决了上面提到的问题，即便其他事务提交了修改，当前事务也看不到这份修改，只有当前事务结束后，才能看到最新的数据；\n看下图，两侧都开启一个事务，不管左侧是否有提交事务，右侧都看不到左侧新插入的数据；\n\n只有右侧也提交了自己的事务，才能看到左侧插入的新数据；\n\n这就保证了，右侧这个事务在运行的始终，它执行的相同select语句的结果永远都是一样的，不会出现不可重复读的问题！\n而如果在RR级别中，同时访问相同数据，会出现加锁的情况，下图中，右侧插入了主键为6的数据，此时左侧如果也尝试插入一个主键为6的数据，会进入阻塞状态；\n\n如果很久都不继续操作，就会因为等待超时，跳出等待\nMariaDB [hello_mysql]&gt; insert into test_ruc values (6,60,&#x27;天数&#x27;);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n\n但当前事务中插入的数据依旧是存在的，当前事务也没有结束\n\n再次尝试插入这个主键为6的数据，依旧会陷入阻塞态，只有右侧的事务被提交了之后，左侧才会出现主键冲突的提示，禁止插入；\n\n左侧commit了之后，右侧才能看到左侧新插入的主键为5的数据；\n\n3.5 串行化这个就比较简单了，一个事务没结束，另外一个就阻塞等待；\n串行化是最高的隔离级别，但其并发性能很低，实际上用的也不多；\nset global transaction isolation level  serializable;\n\n两侧终端都开始事务，查询的时候是不会加锁的，但是左侧执行update的时候，阻塞了（可以通过左侧update的执行时间观察到阻塞现象，截图看的不是很明显）；右侧也执行一次update，左侧的update就立马成功了，右侧显示报错检测到死锁，建议尝试重启事务；\n\n再来试试，两侧都开启事务，左侧尝试插入一个数据，会阻塞；右侧commit之后，左侧的插入就立马成功了！\n\n这便是串行化的表现：两个事务如果都是在执行select的读取操作，则不会被阻塞，但如果有一个事务要执行增删改，那么就必须等待其他事务都结束了，这个操作才能被执行；\n3.5.1 串行化的适用场景回到 1.1.2 卖票 的场景，在这个场景下，如果你需要保证客户端A的卖票逻辑完全执行完毕了，客户端B才能过来查询票数，那就需要使用串行化；\n但是，串行化中，我们是可以执行查询操作的！那么在A没有结束的情况下，B不还是会查询到有剩余票数？\n\n实际上，我们的卖票操作并不是直连数据库实现的，而是有一个服务端进程来提供API，供客户端来查询剩余票数，剩下的卖票操作其实都是服务端来实现的（让客户端直连MySQL来执行SQL是非常不可靠的，很有可能出现SQL注入攻击）\n\n所以，这个问题得在服务端进程中加锁解决！MySQL本身即便使用串行化也是没有办法解决这个问题的；\n但是，别忘了，MySQL还有另外一个东西——约束；你可以设置一个触发器，更新剩余票数的时候，拒绝将票数设置为负数；这样客户端B即便进入了卖票业务，最终将剩余票数的数据设置为负数的时候，也会被MySQL阻止插入，这个卖票的事务B就相当于错误退出了，所有操作都会被回滚！而隔离级别就是避免A和B同时修改一个数据而导致的错误；\n二者相辅相成，就能解决这个问题；当然，在服务端API处理逻辑中加锁是更好的解决办法，既可以保证数据一致性，又能隔离客户端和MySQL服务；\n\n后文讲到的当前读也能在某种程度上解决这个问题，反正解决的办法多多！\n\n3.5.2 串行化和CPP如果将 MySQL 的隔离级别（isolation level）设置为最高级别的串行化（SERIALIZABLE），那么并发的多线程操作可能会遇到以下情况之一：\n\n阻塞：当一个线程正在使用某个数据时，其他线程需要等待该线程释放锁才能继续进行操作。这会导致其他线程在获得所需锁之前被阻塞。\n错误退出：如果多个线程同时操作相同的数据，并且它们无法同时持有访问该数据的锁，就会引发死锁。在这种情况下，某些线程会被系统终止，从而导致错误退出。\n\n所以，并不是说你将MySQL的隔离级别设置好了，那么客户端就啥事不用干了；最好的操作依旧是在客户端就加锁进行一定的访问控制，因为MySQL Query函数的错误退出+退出情况识别，相比于客户端进行访问控制更难以操作；\n3.6 总结\n隔离级别越高，安全性越高，数据库的并发性能就越低；我们需要根据业务逻辑，选用合适的隔离级别；\n不可重复读的问题在于其他客户端的修改和删除，同样的select语句会查出不同的结果，是不合理的；\n幻读的重点在于新增，其他客户端新增的记录可能被我们当前的客户端查询到；但是在MySQL中，这个问题是不存在的，因为InnoDB通过NEXT-KEY锁解决了幻读问题；\n事务也分为长短事务的概念，事务之间互相影响，主要指的是事务在并行阶段（都没有commit的时候）产生的影响；\n一般情况下，我们使用MySQL默认的RR的事务级别就可以了；\n\n下面给出一个不同事务级别之间的区别的表格，Y代表会出现这个问题，N代表不会出现这个问题\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n加锁读\n\n\n\n读未提交\nY\nY\nY\n不加锁\n\n\n读已提交\nN\nY\nY\n不加锁\n\n\n可重复读\nN\nN\nN\n不加锁\n\n\n串行化\nN\nN\nN\n加锁\n\n\n3.7 一致性\n事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务 成功提交的结果时，数据库处于一致性状态。\n如果系统运行发生中断，某个事务尚未完成而被迫中 断，而改未完成的事务对数据库所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性是通过原子性来保证的。\n其实一致性和用户的业务逻辑强相关，一般MySQL提供技术支持，但是一致性还是要用户业务逻辑做支撑（比如客户端如果不使用事务，那MySQL也没有办法帮助维护），所以说，一致性是由用户决定是否维护的。 \n技术上，通过AID保证C\n\n4.隔离性的理解说完了隔离级别，接下来再深入理解一下隔离性\n4.1 MVCC数据库并发的场景一共有下面三种\n\n读-读：不存在任何问题，不需要访问控制\n读-写：有线程安全问题，可能会遇到隔离性中的脏读、幻读、不可重复读问题；\n写-写：有线程安全问题，还有可能出现更新丢失问题；\n\n我们主要关注的是读写并发的情况，这也是数据库最常遇到的处理场景；\n再MySQL中，采用了MVCC（多版本并发控制）来解决读写冲突，这是一种无锁的并发控制机制；\n在了解MVCC之前，我们需要了解几个前置知识：\n\n三个隐藏列字段\nUNDO日志\nREAD VIEW\n\n4.1.1 隐藏列字段在MySQL中，每一个表都存在三个隐藏的列字段\n\nDB_TRX_ID：6 byte，最近修改(修改&#x2F;插入)事务ID，记录创建这条记录&#x2F;最后一次修改该记录的事务ID；\nDB_ROLL_PTR: 7 byte，回滚指针，指向这条记录的上一个版本（简单理解成，指向历史版本就 行，这些数据一般在 undo log 中） \nDB_ROW_ID: 6 byte，隐含的自增ID（隐藏主键），如果数据表没有主键， InnoDB 会自动以 DB_ROW_ID 产生一个聚簇索引；\n补充：实际还有一个删除flag隐藏字段，既记录被更新或删除并不代表真的删除，而是删除flag变了；\n\n假设有如下表结构\ncreate table if not exists student(    name varchar(11) not null,    age int not null);-- 插入一条记录insert into student (name, age) values (&#x27;张三&#x27;, 19);\n\n那么这个表中的实际数据是这样的\n\n\n\nname\nage\nDB_TRX_ID(创建这个记录的事务ID)\nDB_ROW_ID（隐藏主键）\nDB_ROLL_PTR（回滚指针）\n\n\n\n张三\n19\nNULL\n1\nNULL\n\n\n我们并不知道创建这个记录的事务ID，所以设置为NULL；因为是第一条记录，所以隐藏主键是1；因为是第一条记录，所以没有回滚的地方，回滚指针也是NULL（换句话说，如果回滚指针为NULL，代表这个就是这个表中的第一条记录了）\n4.1.2 undo日志MySQL是以服务进程的方式在内存中运行的，我们对数据的CURD操作，都需要通过MySQL将其刷入到硬盘上进行持久化，MySQL为这些操作会提供一个专门的buffer pool内存缓冲区；而undo log/redo log也是内存中的一块区域，对于MySQL而言\n\n日志需要立刻刷盘（有一个专门的线程来管理日志）\n数据根据运行策略，选择合适的时间刷盘（因为数据量一般比较大，如果实时刷盘会造成较大IO负载，影响进程运行）\n\n先来说说redo log，这里包含了MySQL中的所有尚未落盘的CURD操作；如果MySQL还没有写入数据的时候就挂了，那么下次启动的时候就会从redo log里面恢复数据，来确保数据的一致性和完整性；\n在MySQL存储路径/var/lib/mysql中的ib_logfile0/ib_logfile1就是redo log；\n-rw-rw----. 1 mysql mysql  50331648 Sep 11 03:16 ib_logfile0-rw-rw----. 1 mysql mysql  50331648 Sep  9 21:03 ib_logfile1\n\n而undo log主要用于以下功能\n\n回滚事务\nMVCC（多版本控制&#x2F;隔离性和隔离级别）\n\n假设我们来了一个update操作，将刚刚插入的张三的年龄改成30岁，对于MySQL而言就会在undo log里面做如下处理；\n\n该update操作对应的事务DB_TRX_ID是10；\n将旧数据放入undo log中，并将当前数据的DB_ROLL_PTR指向旧数据的地址；\n如果需要回滚，那么就通过DB_ROLL_PTR找到旧数据，复写回去；\n\n\n如果再来一次修改，将张三的名字改成李四，也是依照这个逻辑在undo log中新增旧数据，并链接DB_ROLL_PTR指针；\n\n事务11修改这条数据，先申请锁；\n将现有数据复制到undo log中（头插），并将DB_ROLL_PTR指针指向旧数据的地址；\n修改记录中的name，并且将DB_TRX_ID改成当前事务的ID 11；\n事务11提交，释放锁；\n\n\n这样，我们就有了一个类似于链表的历史版本链；每次回退的时候，都可以找到历史数据，覆盖当前的数据。这些版本我们称之为快照；\n而插入和删除都可以写入undo log，但是只有更新和删除能形成历史版本链；\n\n删除是将删除flag置为真，旧数据依旧可以写入到undo log中，如果需要回滚，将这行记录恢复；\n插入并没有历史版本，但也需要将其放入undo log中，事务回滚的时候需要将新插入的数据删除；\n事务提交了之后，已有的历史记录可以被删除；\n\n增删改都说了，那么select呢？\n一般而言，查询不会产生数据写入操作，也不需要设置历史版本链；\n但是在之前关于RR级别隔离性的验证中，我们看到了select无法看到另外一个事务已经提交了的数据，这说明select有时候读取的是历史版本的数据，而并非当前最新的数据！\n读取历史数据我们称之为快照读，在RR级别中默认采用的就是快照读；读取最新数据叫做当前读（增删改都是当前读）；还有一种读取是为了更新而查询；\nselect ... -- 在RR级别下，默认是快照读select ... for update; -- 为了更新而查询-- MySQL会将当前行上排他锁，上锁了之后，其他客户端只能查询该行，无法修改select ... lock in share mode; -- 查询最新数据（当前读）-- 是串行化的，只有其他事务完成了，才能查询到最新结果；\n\n除了手动指定select的查询方式以外，隔离级别会影响select的默认行为，比如在串行化隔离级别的场景下，默认执行的就是当前读；\n在RR模式下进行测试，会发现当前读会阻塞当前的客户端（右侧客户端阻塞）；\n\n只有左侧的事务在提交了之后，右侧的查询才会返回最新的结果；\n\n这是因为当前读，包括增删改操作，是需要加锁的；如果要在RR模式下实现当前读，那么整个系统就需要串行化执行；\n而快照读不需要加锁，因为它可以读取历史版本，而历史版本是不会被其他线程修改的，也就不需要维护访问控制，提高了并发效率；\n那么，MySQL是如何实现快照读的呢？\n4.1.3 Read ViewRead View就是MySQL为快照读生成的一个读视图；在事务执行快照读的时候（即执行select的时候）将当前数据拍一张照，这样在这个事务中，后续的所有select都只会看到这个照片里面的结果，看不到其他事务最新的修改（不管其他事务是否commit）。\n\n快照读的现象我们已经在本文 3.4 可重复读 中演示过了，这里就不再二次演示了；\n\nRead View在MySQL的源码中其实就是一个类，该类中包含一些可读性判断的信息，内部有条件，来标明当前事务能够看到那个版本的数据，即有可能是当前最新的数据，也有可能是undo log中的某个历史版本；\nclass ReadView &#123;// 省略...private:    /** 高水位，大于等于这个ID的事务均不可见*/    trx_id_t m_low_limit_id    /** 低水位：小于这个ID的事务均可见 */    trx_id_t m_up_limit_id;    /** 创建该 Read View 的事务ID*/    trx_id_t m_creator_trx_id;    /** 创建视图时的活跃事务id列表，是一个位图 */    ids_t m_ids;    /** 配合purge，标识该视图不需要小于m_low_limit_no的UNDO LOG，    * 如果其他视图也不需要，则可以删除小于m_low_limit_no的UNDO LOG*/    trx_id_t m_low_limit_no;    /** 标记视图是否被关闭*/    bool m_closed;    // 省略...&#125;;\n\n单独说明一下这里的4个重要的变量；其中需要注意，在这里面up是低水位，low是高水位，这是由他们保存的数据的性质决定的，请不要和这两个单词的本意混淆！\nm_ids; // 一张位图，用来保存Read View生成时，系统正活跃（没有结束的）的事务IDup_limit_id; // 记录m_ids列表中事务ID最小的ID low_limit_id; // ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1creator_trx_id // 创建该ReadView的事务ID\n\n要知道，当前事务是知道自己的事务ID的（DB_TRX_ID），那么我们手中就有快照读中最大最小的事务ID，以及当前活跃中的事务ID；那么在读取版本链的时候，就进行如下匹配，设当前开启的这个事务为A:\n\n版本链中的事务ID不存在于m_ids中，代表事务A开启的时候，这个事务已经提交了，所以我们可以读取这个事务操作的结果；\n版本链中的事务ID存在于m_ids中，代表事务A开启的时候，这个事务是活跃状态，那么我就不应该读到这个事务的操作结果；\n版本链的中的事务ID大于low_limit_id，代表事务A开启的时候，这个事务还不存在，所以也不应该看到这个在A之后来的事务的操作结果；（A还没操作完毕，这个新事务就来了）\n版本链中的事物ID小于up_limit_id，代表事物A开启的时候，这个事物都不知道是是它的父亲辈还是爷爷辈了，长辈给你留下的东西肯定得好好收着；说人话：这个是A来之前的之前就已经结束了的事物，肯定是可以读取其结果的；\n\n在MySQL中我们可以看到如下源码，链接也贴出来了，github上可以查看源码；这个函数就是用来判断当前事务应该能看到那些版本链的，具体的判断逻辑参考中文注释（英文注释是官方留的）\n// 这个函数是ReadView类的成员函数 ReadView::changes_visible // 源码链接 https://github.com/mysql/mysql-server/blob/ea1efa9822d81044b726aab20c857d5e1b7e046a/storage/innobase/include/read0types.h#L162  // [[nodiscard]] 代表这个函数的返回值不能被忽略，一定需要使用该返回值；否则编译器会爆警告；即告知程序员必须关注这个函数的返回值！// 函数的返回值是当前事务能否看到某一个事务id值的版本链，入参是目标事务id/** Check whether the changes by id are visible.  @param[in]    id      transaction id to check against the view  @param[in]    name    table name  @return whether the view sees the modifications of id. */  [[nodiscard]] bool changes_visible(trx_id_t id,                                     const table_name_t &amp;name) const &#123;    ut_ad(id &gt; 0);\t    // 小于最小的事务id或者等于当前事务id，则代表这个事务我们可以看到     if (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;      return (true);    &#125;    check_trx_id_sanity(id, name);\t// 如果这个id比当前事务中的高水位还大，说明这个id是后来者，不应该看到    if (id &gt;= m_low_limit_id) &#123;      return (false);    &#125;\t// 如果当前事务创建时，没有活跃事务    // 且 m_up_limit_id &lt;= id &lt; m_low_limit_id     // 那么这个事务ID就可以被看到，返回真     else if (m_ids.empty()) &#123;      return (true);    &#125;    const ids_t::value_type *p = m_ids.data();\t// 如果上面都没有匹配到，那就检查这个id是否在活跃列表m_ids中    // std::binary_search的返回值：是否在位图中，true代表在，false代表不在    // 如果在，那么这个事务是活跃状态，不能被看到    // 如果不在，那么这个事务是已经提交了，可以被看到    return (!std::binary_search(p, p + m_ids.size(), id));  &#125;\n\n如果查到不应该看到当前版本，接下来就是遍历下一个版本，直到符合条件，即可以看到。这便是我们select当前读的时候，会自动产生的ReadView结构体的作用；\n根据这份源码，我们也能知道m_ids位图中，并不需要存放当前事务ID，因为会有额外的判断来处理当前事务ID！\n4.2 快照读实操4.2.1 快照是什么时候生成的？假设当前的事务流程如下，事务2能看到事务1的操作结果吗？\n\n\n\n事务1\n事务2\n\n\n\n事务开始\n事务开始\n\n\n插入数据1并提交事务\n\n\n\n\n第一次查询\n\n\n重开一个新事务，插入数据2并提交\n\n\n\n\n第二次查询\n\n\n来实操一下，开两个MySQL终端，隔离级别设置为RR；图中黄字标出了每一个SQL的执行顺序；我们会发现，当左侧终端提交了第一个插入的数据后，右侧才查询，是可以看到这条新插入的数据的！\n而左侧插入的第二条数据右侧就看不到了，很明显，此时访问的就是快照中的旧数据，而不是新数据了；\n\n这就告诉我们：快照读的快照是在事务中第一次执行select语句的时候生成的！并不是事务开始的时候生成的！\n这也非常合理，如果你的当前事务压根没有进行select语句，那我也就没有必要生成快照了，毕竟快照的底层是ReadView对象，也是会占用内存空间的！而增删改操作本身就是当前读，无需生成快照！\n4.2.2 实例解释ReadView的成员变量用实际例子来解释一下ReadView里面的4个成员变量到底应该存放什么值；\n假设有下面这个数据\n\n\n\nname\nage\nDB_TRX_ID(创建这个记录的事务ID)\nDB_ROW_ID（隐藏主键）\nDB_ROLL_PTR（回滚指针）\n\n\n\n张三\n19\nNULL\n1\nNULL\n\n\n一共有4个事务同时运行，事务序号就是事务ID\n\n\n\n事务2\n事务3\n事务4\n事务5\n\n\n\n事务开始\n事务开始\n事务开始\n事务开始\n\n\n……\n……\n……\n修改张三的年龄并提交\n\n\n运行\n快照读\n运行\n……\n\n\n……\n……\n……\n……\n\n\n在这种情况下，事务3对某行数据进行了快照读，MySQL就会在这时候生成一个ReadView，内部变量赋值如下\nm_ids; // 2,4 (当前事务5已经提交了，所以除了自己就只有2和4活跃中)up_limit_id; // 2 (m_ids中最小事务ID)low_limit_id; // 5 + 1 = 6 (当前已经出现的最大事务ID+1)creator_trx_id // 3 (当前事务ID)\n\n当事务3进行快照读的时候，就会拿事务5的这份数据进行比较，最终得到的结果是，事务3的快照是可以看到事务5对数据进行的修改的！\n而且对于全局来说，事务5提交的这份数据也是当前最新的数据！\n// 比较流程（依照上方MySQL的源码）5 &lt; up_limit_id || 5 == 3; // 不小于最小的，且也不等于当前的事务ID 35 &gt; low_limit_id; // 不大于最大的// 判断5是否在m_ids里面m_ids.contains(5); // 不在// 结论：return true;\n\n4.3 当前读实操快照读的场景基本搞明白了，再来试试当前读（这里小提一嘴，写-写并发可以理解为所有操作都是当前读，需要串行化）\nselect ... lock in share mode;\n\n下面是两个不同的操作流程，最终会得到不同的结果；操作之前，先执行如下两个sql\ndelete from test_ruc;insert into test_ruc values (1,20,&#x27;张三&#x27;);\n\n在第一次测试中，我们在左侧终端更新数据之前就执行了一次快照读，此时MySQL会生成快照，即便在左侧终端的事务commit了之后，右侧也无法看到最新的user_id=18的数据；此时使用当前读，就可以读取到最新的数据！\n\n而在第二次测试中，我们让左侧终端完成所有操作，右侧终端再去查询，会发现快照读和当前读都能查询到最新的修改；\n\n由此可见\n\n快照读的快照是第一次select查询的时候生成的\n当前读能绕过快照查看到最新数据！\n\n4.4 RR和RC的区别\n正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同\n在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活 跃的其他事务记录起来\n此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；\n即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见；\n而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因；\n总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View。 \n正是RC每次快照读，都会形成Read View，所以，RC才会有不可重复读问题。\n\nThe end关于MySQL事务的内容到这里基本就OVER了，内容多多，也需要多多理解和复习！\n可以深入阅读如下文章https://blog.csdn.net/SnailMann/article/details/94724197https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.htmlhttps://blog.csdn.net/chenghan_yang/article/details/97630626\n\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】C/C++代码操作数据库","url":"/posts/2109090511/","content":"简单尝试使用 c 语言的库对 mysql 的数据进行增删改查。\n\n\n1.新增数据库和表刚开始数据库没有设定密码和用户，直接用root用户登录\nmysql -uroot;\n\n创建一个hello数据库，并进入这个数据库\ncreate database hello;use hello;\n\n创建一个stu_student数据表\ncreate table stu_test( id int primary key auto_increment, name varchar(30), age int, score decimal(4,2));\n\n其中第一个id的类型是int，并设置为了auto_increment，每次插入数据的时候它都会自增。\nname是字符串类型，age是int类型，score分数是浮点类型\ndecimal(4,2)         表示的范围是 -99.99 ~ 99.99decimal(4,2)unsigned 表示的范围是 0 ~ 99.99\n\n到这里，前期的准备就完成了\n2.接口简单认识依照注释，简单认识一下mysql库的一些接口\n//头文件#include &lt;mysql/mysql.h&gt;//MySQL操作句柄初始化MYSQL *mysql_init(MYSQL *mysql)；//参数为空则动态申请句柄空间进行初始化//失败返回NULL//连接mysql服务器MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user,  const char *passwd,const char *db, unsigned int port,  const char *unix_socket, unsigned long client_flag); //mysql--初始化完成的句柄//host---连接的mysql服务器的地址//user---连接的服务器的用户名//passwd-连接的服务器的密码//db ----默认选择的数据库名称//port---连接的服务器的端口： 默认0是3306端口//unix_socket---通信管道文件或者socket文件，通常置NULL //client_flag---客户端标志位，通常置0 //返回值：成功返回句柄，失败返回NULL//设置当前客户端的字符集int mysql_set_character_set(MYSQL *mysql, const char *csname) //mysql--初始化完成的句柄//csname--字符集名称，通常：&quot;utf8&quot; //返回值：成功返回0， 失败返回非0    //选择操作的数据库int mysql_select_db(MYSQL *mysql, const char *db) //mysql--初始化完成的句柄//db-----要切换选择的数据库名称//返回值：成功返回0， 失败返回非0    //执行sql语句int mysql_query(MYSQL *mysql, const char *stmt_str) //mysql--初始化完成的句柄//stmt_str--要执行的sql语句//返回值：成功返回0， 失败返回非0    //保存查询结果到本地MYSQL_RES *mysql_store_result(MYSQL *mysql) //mysql--初始化完成的句柄//返回值：成功返回结果集的指针， 失败返回NULL    //获取结果集中的行数与列数uint64_t mysql_num_rows(MYSQL_RES *result)；//result--保存到本地的结果集地址//返回值：结果集中数据的条数；unsigned int mysql_num_fields(MYSQL_RES *result) //result--保存到本地的结果集地址//返回值：结果集中每一条数据的列数；    //遍历结果集MYSQL_ROW mysql_fetch_row(MYSQL_RES *result) //result--保存到本地的结果集地址//返回值：实际上是一个char **的指针，将每一条数据做成了字符串指针数组 row[0]-第0列 row[1]-第1列//并且这个接口会保存当前读取结果位置，每次获取的都是下一条数据//释放结果集void mysql_free_result(MYSQL_RES *result) //result--保存到本地的结果集地址//返回值：void  //关闭数据库客户端连接，销毁句柄：void mysql_close(MYSQL *mysql)  //获取mysql接口执行错误原因const char *mysql_error(MYSQL *mysql)\n\n因为mysql是一个动态库，所以编译的时候，需要加上库名的链接\ng++ test.cpp -o test -lmysqlclient\n\n在我的系统下，MySQL的库是在/usr/lib64目录下的，所以我不需要额外指定库的路径。如果你的系统该目录下没有libmysqlclient.so ，则需要找到库安装的路径，使用-L命令指定该路径\ng++ test.cpp -o test -L/path/to/mysql/lib -lmysqlclient\n\n3.代码开始写代码，一步一步认识mysql的各个接口\n3.1 连接数据库因为我的数据库都是默认的环境，所以不需要账户的密码，按如下宏定义一下我们需要操作的数据库信息，方便后续的修改\n#include &lt;mysql/mysql.h&gt;#define HOST &quot;127.0.0.1&quot;#define PORT 3306#define USER &quot;root&quot;#define PASSWD &quot;&quot;#define DBNAME &quot;hello&quot;\n\n第一步，是用init来初始化一个MYSQL的结构体，并用一个指针来接收；\n第二步，用mysql_real_connect函数来进行数据库的连接，填入我们刚刚的宏定义即可。\n第三步，因为在最初配置mariadb的环境时，为了更好的支持中文，我们将数据库的字符集设置为了utf8，代码中也需要同步修改，避免因为编码问题产生的数据乱码\n最后一步，销毁mysql结构体\nint main()&#123;    // 连接数据库    // 初始化    MYSQL *mysql = mysql_init(nullptr);    if (mysql == nullptr) // 返回值为空代表init失败    &#123;         cerr &lt;&lt; &quot;[ERR] init mysql handle failed!\\n&quot;;         return -1;     &#125;    // 连接    cout &lt;&lt; &quot;[INFO] connect to &quot; &lt;&lt; HOST &lt;&lt; &quot;:&quot; &lt;&lt; PORT &lt;&lt; &quot; &quot; &lt;&lt; USER &lt;&lt; &quot; &quot; &lt;&lt; DBNAME &lt;&lt; endl;    // 第一个参数为输出型参数。返回值为MYSQL的起始地址，如果错误返回NULL    if (mysql_real_connect(mysql, HOST, USER, PASSWD, DBNAME, PORT, nullptr, 0) == nullptr)     &#123;        cerr &lt;&lt; &quot;[ERR] mysql connect error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;         return -1;    &#125;    // 配置为和数据库同步的utf8字符集    mysql_set_character_set(mysql, &quot;utf8&quot;);    // 到这里就已经成功了    cout &lt;&lt; &quot;[INFO] mysql database connect success!&quot; &lt;&lt; endl;         // 关闭连接    mysql_close(mysql);     return 0;&#125;\n\n编译执行，成功链接上了数据库\n$ makeg++ test.cpp -o test -lmysqlclient$ ./test[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success!\n\n3.2 增加键值下面要做的，就是给已有表新增一个键值\n需要注意的是，mysql的代码操作，实际上也是需要使用sql语句的（这点我觉得好麻烦）\n插入语句如下，括号中的键值应该和数据库中表的键值一一对应\ninsert into stu_test value (null,&#x27;牛爷爷&#x27;,50,64.6);\n\n所以我们要做的，就是写一个函数，将传入的参数合并成一个sql语句，传入mysql进行处理\n// 将double转为stringstd::string double2string(const double&amp; d)&#123;    std::stringstream s_tmp;    s_tmp &lt;&lt; d;      std::string s = s_tmp.str();    return s;&#125;int add_key_to_stu(MYSQL *mysql,const std::string&amp; name,int age,double score)&#123;    // 1.将传入的参数处理为一个完整的sql语句    // 因为第一个编号参数，配置的是自增，所以需要传入null    std::string sql_cmd = &quot;insert into stu_test value (null,&#x27;&quot;;    sql_cmd+= name;    sql_cmd+= &quot;&#x27;,&quot;;    sql_cmd+= std::to_string(age);    sql_cmd+= &quot;,&quot;;    sql_cmd+= double2string(score);    sql_cmd+= &quot;);&quot;;    cout &lt;&lt; &quot;[INFO] &quot; &lt;&lt; sql_cmd &lt;&lt; endl;        // 2.执行语句    int ret = mysql_query(mysql,sql_cmd.c_str());    if(ret!=0)    &#123;        cerr &lt;&lt; &quot;[ERR] mysql insert error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;     &#125;    return ret;&#125;\n\n如下代码测试\n// 添加一个数据add_key_to_stu(mysql,&quot;牛爷爷&quot;,50,64.6);add_key_to_stu(mysql,&quot;小图图&quot;,5,72.8);\n\n可以看到，成功运行！\n$ ./test[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success![INFO] insert into stu_test value (null,&#x27;牛爷爷&#x27;,50,64.6);[INFO] insert into stu_test value (null,&#x27;小图图&#x27;,5,72.8);\n\n进入mysql命令行，使用如下命令，即可查询到已有的键值\nselect * from stu_test;\n\n可以看到，处理成功！\n+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  1 | 牛爷爷    |   50 | 64.60 ||  2 | 小图图    |    5 | 72.80 |+----+-----------+------+-------+2 rows in set (0.001 sec)\n\n3.3 修改已有键值sql语句如下，修改当前数据库中，stu_test表中name为牛爷爷的条目的成绩为70\nupdate stu_test set score=70 where name=&#x27;牛爷爷&#x27;;\n\n// 修改已有学生的成绩int mod_score_in_stu(MYSQL *mysql,const std::string&amp; name,double score)&#123;    std::string sql_cmd = &quot;update &quot;;    sql_cmd += TABLENAME;    sql_cmd += &quot; set score=&quot;;    sql_cmd += double2string(score);    sql_cmd += &quot; where name=&#x27;&quot;;    sql_cmd += name;    sql_cmd += &quot;&#x27;;&quot;;    cout &lt;&lt; &quot;[INFO] &quot; &lt;&lt; sql_cmd &lt;&lt; endl;        // 2.执行语句    int ret = mysql_query(mysql,sql_cmd.c_str());    if(ret!=0)    &#123;        cerr &lt;&lt; &quot;[ERR] mysql mod_score error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;     &#125;    return ret;&#125;\n\n可以看到，执行成功了之后，牛爷爷的成绩发生了变化\n$ ./test[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success![INFO] update stu_test set score=70 where name=&#x27;牛爷爷&#x27;;\n\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  1 | 牛爷爷    |   50 | 64.60 ||  2 | 小图图    |    5 | 72.80 |+----+-----------+------+-------+2 rows in set (0.001 sec)MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  1 | 牛爷爷    |   50 | 70.00 ||  2 | 小图图    |    5 | 72.80 |+----+-----------+------+-------+2 rows in set (0.000 sec)\n\n如果想修改其他键值，也是依照此步骤进行。\n在实际场景中，一个数据条目肯定会有一个键值是不变的。比如在我的学生表中，假定每一个学生的名字都不变，我们就可以根据name字段来查找键值，对之进行其他值的修改。\n如果真要严肃起来，用名字来查找肯定是不行的，我们应该给每一个学生都生成一个学号或UID，用这个id来进行检索。修改数据之前，都需要知道目标数据的uid值，才能修改。\n3.4 删除键值如下语句，在test_tb表中，删除名字为张三的键值\ndelete from test_tb where name=&#x27;张三&#x27;;\n\n在删除之前，我又给数据库新增了一个键值\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  1 | 牛爷爷    |   50 | 70.00 ||  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 |+----+-----------+------+-------+3 rows in set (0.001 sec)\n\n下面我要用代码，删除掉牛爷爷\n// 删除键值(根据名字)int del_key_in_stu(MYSQL *mysql,const std::string&amp; name)&#123;    std::string sql_cmd = &quot;delete from &quot;;    sql_cmd += TABLENAME;    sql_cmd += &quot; where name=&#x27;&quot;;    sql_cmd += name;    sql_cmd += &quot;&#x27;;&quot;;    cout &lt;&lt; &quot;[INFO] &quot; &lt;&lt; sql_cmd &lt;&lt; endl;        // 执行语句    int ret = mysql_query(mysql,sql_cmd.c_str());    if(ret!=0)    &#123;        cerr &lt;&lt; &quot;[ERR] mysql mod_score error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;     &#125;    return ret;&#125;\n\n// 删除已有键值del_key_in_stu(mysql,&quot;牛爷爷&quot;);\n\n编译执行\n$ ./test[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success![INFO] delete from stu_test where name=&#x27;牛爷爷&#x27;;\n\n牛爷爷被删掉了\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 |+----+-----------+------+-------+2 rows in set (0.000 sec)\n\n3.4.1 关于自增的id此时再插入一个新的键值，可以看到id并么有把空余的1给补上，而是从4开始继续往后增加\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 ||  4 | 乐迪      |   32 | 99.00 |+----+-----------+------+-------+3 rows in set (0.001 sec)\n\n知道这一点就行\n3.5 查询对于数据库而言，查询也是一个高频操作\nselect * from  tb  where name=key;\n\n上面的语句，是在数据库表tb中查找键值name为key的的数据\n// 返回用户的所有信息,name为空返回所有void get_all_in_stu(MYSQL *mysql,const std::string&amp; name=&quot;&quot;)&#123;    std::string sql_cmd = &quot;select * from &quot;;    sql_cmd += TABLENAME;    if(name.size()!=0)    &#123;        sql_cmd += &quot; where name=&#x27;&quot;;        sql_cmd += name;        sql_cmd += &quot;&#x27;&quot;;    &#125;    sql_cmd += &quot;;&quot;;    cout &lt;&lt; &quot;[INFO] &quot; &lt;&lt; sql_cmd &lt;&lt; endl;    int ret = mysql_query(mysql,sql_cmd.c_str());    if(ret!=0)    &#123;        cerr &lt;&lt; &quot;[ERR] mysql query error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;         return ;    &#125;    // 获取结果    MYSQL_RES *res = mysql_store_result(mysql);    if (res == nullptr)     &#123;         cerr &lt;&lt; &quot;[ERR] mysql store_result error: &quot; &lt;&lt; mysql_error(mysql) &lt;&lt; endl;         return ;     &#125;        int row = mysql_num_rows(res); // 行    int col = mysql_num_fields(res); //列    printf(&quot;%10s%10s%10s%10s\\n&quot;, &quot;ID&quot;, &quot;姓名&quot;, &quot;年龄&quot;, &quot;成绩&quot;);     for (int i = 0; i &lt; row; i++)     &#123;         MYSQL_ROW row_data = mysql_fetch_row(res);         for (int i = 0; i &lt; col; i++)         &#123;            printf(&quot;%10s&quot;, row_data[i]);         &#125;        printf(&quot;\\n&quot;);     &#125;     // 释放结果    mysql_free_result(res);&#125;\n\nget_all_in_stu(mysql);\n\n执行结果如下，显示出了表中所有的值\n[INFO] connect to 127.0.0.1:3306 root hello[INFO] mysql database connect success![INFO] select * from stu_test;        ID    姓名    年龄    成绩         2 小图图         5     72.80         3 大司马        42     87.30         4    乐迪        32     99.00\n\n传入特定名字，则只返回改名字所有值\nget_all_in_stu(mysql,&quot;乐迪&quot;);\n\n[INFO] select * from stu_test where name=&#x27;乐迪&#x27;;        ID    姓名    年龄    成绩         4    乐迪        32     99.00\n\n这样便实现了查询操作。\n\n3.5.1 模糊匹配除了使用name=，还可以使用name like %名字%这条语句进行模糊匹配，即不在乎名字前后的内容，只要有包含名字的数据，就筛选出来。\nselect * from %s where name like &#x27;%牛%&#x27;;\n\n这样就能将名字里面包含牛的所有数据都筛选出来\n3.5.2 查询接口操作注意事项因为查询的返回值是一个字符串二维数组，并不能通过字段名字获取到对应字段的内容。这要求程序猿知晓这个表中字段的顺序，才能通过下标获取到正确的字段对其进行处理。\n因为cpp并不像python那样支持可变变量类型，所以要想筛选出对应类型的数据，还需要我们自行调用对应的函数进行数据的转换。\n比如用atoi函数将字符串转为整型。\nThe end基本的操作到这里就OVER了，后续的其他操作会更新本博客；\n详细的用例可以看我的视频点播项目内部中和mysql相关的代码\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】数据类型","url":"/posts/3544156851/","content":"mysql的数据类型老多了，单开一篇博客记录一下吧\n\n\nmysql  Ver 15.1 Distrib 10.3.28-MariaDB, for Linux (x86_64) using readline 5.1\n\n1.数值类型\n\n\n数据类型\n说明\n字节\n\n\n\nBIT(M)\n位类型，M指定位数，默认位1，可1-64\n\n\n\nTINYINT [UNSIGNED]\n有符号-127 ~ 128；无符号 0 ~ 255\n1\n\n\nBOOL\n用0和1表示真假（实际为tinyint(1))\n1\n\n\nSMALLINT [UNSIGNED]\n有符号-2^15 ~ 2^15 -1; 无符号2^16 -1\n2\n\n\nMEDIUMINT [UNSIGNED]\n有符号-2^23 ~2^23 -1; 无符号 2^24 -1\n3\n\n\nINT [UNSIGNED]\n有符号-2^31 ~ 2^31 -1; 无符号2^32 -1\n4\n\n\nBIGINT [UNSIGNED]\n有符号-2^63 ~ 2^63 -1; 无符号2^64 -1\n8\n\n\nFLOAT [(M,D)] [UNSIGNED]\nM指定显示长度，D指定小数位数\n4\n\n\nDOUBLE [(M,D)] [UNSIGNED]\n同上，精度更高\n8\n\n\nDECIMAL (M,D) [UNSIGNED]\n同上，M和D必须给出\n\n\n\n1.1 插入超范围数据和编译器中会对数据进行截断不同，mysql中的数据范围必须严格遵守其定义的范围\nMariaDB [hello]&gt; create table test(    -&gt; id TINYINT UNSIGNED);Query OK, 0 rows affected (0.021 sec)\n\n这里我创建了一个使用TINYINT类型的表，向里面插入如下的正确数据\nMariaDB [hello]&gt; insert into test value (3);Query OK, 1 row affected (0.040 sec)MariaDB [hello]&gt; insert into test value (0);Query OK, 1 row affected (0.040 sec)MariaDB [hello]&gt; insert into test value (10);Query OK, 1 row affected (0.007 sec)\n\n再尝试插入负数和超过范围的数\nMariaDB [hello]&gt; insert into test value (-1);ERROR 1264 (22003): Out of range value for column &#x27;id&#x27; at row 1MariaDB [hello]&gt; insert into test value (300);ERROR 1264 (22003): Out of range value for column &#x27;id&#x27; at row 1MariaDB [hello]&gt; \n\n可以看到，mysql阻止了我们的插入。\n1.2 约束这就是mysql对应用层的约束，你必须遵守先前对表中对字段类型的定义和范围的要求，才能将数据插入到数据库中。\n这样就保证了，我们在mysql中看到的数据，是能保证范围正确的！\n并不会出现这个数据是因为截断而被存入的缺省值，从而造成的非精确问题。\n\n当然，你要是在代码中强转数据插入，mysql肯定看不出来。但那样就是程序云的锅了，和mysql本身无关！\n\n注意，当一个无符号数据无法被int类型存放的时候，我们不要用无符号int来存放这个数据，而应该使用bigint。这样才能保证数据一定能被存入。\n而我们要存放的数据没有负数的时候（比如年龄、当前时间戳）则建议使用无符号数来存放。因为这样能显式告知其他需要操作这个数据库的人，当前字段是没有负数的。\n1.3 BIT类型BIT类型就是用比特位来表示一些0&#x2F;1的信息\n\n用户在线状态\n用户性别（不考虑不选择的情况下）\n用户是否已经验证邮箱\n用户是否绑定了手机\n用户一系列权限位\n…\n\n这些数据都是只有真假区分的，使用bit来保存的时候，就能节省一定的空间。\n1.4 浮点数FLOAT [(M,D)] [UNSIGNED]\n\n浮点数这里的M和D是什么意思呢？\nalter table test add ft float(4,2) after id;\n\n这里我先往之前已有的test表中插入一个浮点数，来测试一下情况\nMariaDB [hello]&gt; desc test;+-------+---------------------+------+-----+---------+-------+| Field | Type                | Null | Key | Default | Extra |+-------+---------------------+------+-----+---------+-------+| id    | tinyint(3) unsigned | YES  |     | NULL    |       || ft    | float(4,2)          | YES  |     | NULL    |       |+-------+---------------------+------+-----+---------+-------+2 rows in set (0.002 sec)\n\n当插入一个整数时，会自动后补0\nMariaDB [hello]&gt; insert into test values (1,99);Query OK, 1 row affected (0.007 sec)MariaDB [hello]&gt; select * from test;+------+-------+| id   | ft    |+------+-------+|    3 |  NULL ||    0 |  NULL ||   10 |  NULL ||    1 | 99.00 |+------+-------+4 rows in set (0.000 sec)\n\n插入负数也是没问题的\nMariaDB [hello]&gt; insert into test values (1,-99.3);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; select * from test;+------+--------+| id   | ft     |+------+--------+|    3 |   NULL ||    0 |   NULL ||   10 |   NULL ||    1 |  99.00 ||    1 | -99.30 |+------+--------+5 rows in set (0.001 sec)\n\n但当你想插入如下数字的时候，就开始报错了\nMariaDB [hello]&gt; insert into test values (1,-99.99542);ERROR 1264 (22003): Out of range value for column &#x27;ft&#x27; at row 1MariaDB [hello]&gt; insert into test values (1,100.99542);ERROR 1264 (22003): Out of range value for column &#x27;ft&#x27; at row 1MariaDB [hello]&gt; insert into test values (1,100.9942);ERROR 1264 (22003): Out of range value for column &#x27;ft&#x27; at row 1MariaDB [hello]&gt; insert into test values (1,100.99);ERROR 1264 (22003): Out of range value for column &#x27;ft&#x27; at row 1\n\n简单总结\n\n浮点数的M代表浮点数总共的位数（包括整数部分和小数部分）\n后续的D代表小数点之后的位数\n如果D为2，则可以插入0.994，不可以插入0.995（临界数据只能四舍，不支持五入，因为五入了之后就相当于超限了）\n插入30.945会被四舍五入为30.95\nfloat(4,2)的范围就是 -99.99 ~ 99.99; 如果是无符号，则为 0 ~ 99.99\n\nMariaDB [hello]&gt; insert into test values (1,30.945);Query OK, 1 row affected (0.003 sec)MariaDB [hello]&gt; select * from test;+------+--------+| id   | ft     |+------+--------+|    3 |   NULL ||    0 |   NULL ||   10 |   NULL ||    1 |  99.00 ||    1 | -99.30 ||    1 | -99.34 ||    1 |  30.95 |+------+--------+7 rows in set (0.000 sec)\n\n1.5 decimalDECIMAL (M,D) [UNSIGNED]\n\n这个数据类型和float的区别也是精度上的\n\nfloat最大精度约7位\ndecimal最大M为65，D为30；省略时D默认为0，M默认为10\n\n在我当前的mariadb中进行测试，同样是插入10.123456789，float显示的是10.12345695，decimal显示的是10.12345679 \n很明显，decimal的精准度更高，正确对10.123456789进行四舍五入了。而float就把数据给搞坏了。\nMariaDB [hello]&gt; drop table test;Query OK, 0 rows affected (0.046 sec)MariaDB [hello]&gt; create table test (    -&gt; f1 float(10,8),    -&gt; f2 decimal(10,8));Query OK, 0 rows affected (0.058 sec)MariaDB [hello]&gt; insert into test values (10.123456789,10.123456789);Query OK, 1 row affected, 1 warning (0.010 sec)MariaDB [hello]&gt; select * from test;+-------------+-------------+| f1          | f2          |+-------------+-------------+| 10.12345695 | 10.12345679 |+-------------+-------------+1 row in set (0.001 sec)\n\n所以，如果需要存储小数，最好使用decimal\n1.6 浮点数取整的几种方式这个和mysql无关，只是记录一下\n\n零向取整：丢弃小数部分\n向上取整：2.1视作3，-2.5视作-2（2.0不变）\n向下取整：2.1视作2，-2.5视作-3（2.0不变）\n四舍五入（刚刚的测试能看到，mysql采用的是这个）\n\n2.文本、二进制类型\n\n\n数据类型\n说明\n\n\n\nCHAR (SIZE)\n定长字符串，最大255\n\n\nVARCHAR (SIZE)\n可变长度字符串，最大长度 65535\n\n\nBLOB\n二进制数据\n\n\nTEXT\n大文本，支持全文索引\n\n\nTEXT和VARCHAR都是支持全文索引的！\nMariaDB [hello_mysql]&gt; CREATE TABLE articles (    -&gt;     id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,    -&gt;     title VARCHAR(200),    -&gt;     body TEXT DEFAULT &#x27;&#x27;,    -&gt;     FULLTEXT (title,body)     -&gt; )engine=MyISAM;Query OK, 0 rows affected (0.003 sec)\n2.1 char在mysql中，size并不是字节，而是字符数量。\nchar(2)\n\n它可以存放两个英文字母，两个符号，也可以是两个中文。但实际上两个中文占用的字节数并非2。\n比如下方c1和c2分别是char(3) varchar(3)，可以插入3字的中文\nMariaDB [hello]&gt; select * from test;+---------+-----------+| c1      | c2        |+---------+-----------+| 1ca     | 23a       || 123     | 234       || 3       | 23        || 你好   | 我在呢    |+---------+-----------+4 rows in set (0.001 sec)\n\n超过2个字符的数据会被拒绝插入；\nMariaDB [hello]&gt; insert into test values (&#x27;1ca&#x27;,&#x27;23a3&#x27;);ERROR 1406 (22001): Data too long for column &#x27;c2&#x27; at row 1\n\n2.2 char和varchar的区别表中提到，这两个除了最大长度的限制，还有一个区别是定长/变长\n简单理解为，char是C语言中的char*类型的字符串，如果定义为CHAR(3)，就无论如何都会开3个字符的空间来存放数据，不管你的字符串是1个字符还是2个字符；\n而varchar是C++的string，它可以动态开辟长度，如果VARCHAR(20)，当字符串只有3个的时候，只会占用3字节的空间。既然是string，那就需要有额外空间来存放字符串的长度。在mysql中，varchar会采用1-3字节的空间来存放VARCHAR数据类型的当前长度。\n\n当我需要一个长度固定的8位uuid，可以选择char来节省空间（不需要额外空间存放长度）\n当我需要存放名字、地址等信息的时候，选择varchar（但要保证长度不超过varchar的上限）\n\n3.时间类型\n\n\n数据类型\n说明\n\n\n\nDATE\nyyyy-mm-dd\n\n\nDATETIME\nyyyy-mm-dd hh:mm:ss\n\n\nTIMESTAMP\n时间戳\n\n\n这个应该很好看明白，时间类型可以很方便的表示一些时间\n\n数据更新时间\n数据插入的时间\n当前数据关联的操作时间\n…\n\n3.1 示例在我的视频点播项目中，就是用了如下语句设置了一个TIMESTAMP字段，做为视频的上传时间\ninsert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP comment &#x27;视频创建时间&#x27;,\n\n但我发现，即便是用了TIMESTAMP，查询的时候依旧显示的是可读时间\n\n需要使用如下的语句进行查询，才会显示时间戳的数字\nSELECT UNIX_TIMESTAMP(insert_time) AS timestamp FROM tb_video;\n\n效果如下\nMariaDB [vod_system]&gt; SELECT UNIX_TIMESTAMP(insert_time) AS timestamp FROM tb_video;+------------+| timestamp  |+------------+| 1683213543 || 1683256245 |+------------+2 rows in set (0.001 sec)\n\n一般情况下，保存时间戳是更好的选择，因为不管你是在那个时区，时间戳都是统一的。我们可以在应用层将时间戳通过函数（一般都有专门的库函数来转化）成对应时区的可读时间。\n但如果你能特别确定你的应用只会在当前时区使用，比如我写了一个数据纯本地化的应用，在哪里部署就使用那个地方的时间。这时候就可以选择使用date类型来存放str字符串，省去了在应用层重新对时间操作的繁琐。\n而且，像python这样的语言，也是支持将特定格式的str时间转回时间戳的。\n3.2 timestamp和datetime的区别在MySQL中，TIMESTAMP类型和DATETIME类型都用于存储日期和时间信息，但它们之间有几个重要的区别：\n\n存储范围：\nTIMESTAMP类型：使用4个字节进行存储，可以表示的范围为1970-01-01 00:00:01到2038-01-19 03:14:07。因为使用较少的字节，所以TIMESTAMP类型在存储上更加节省空间。\nDATETIME类型：使用8个字节进行存储，可以表示的范围为1000-01-01 00:00:00到9999-12-31 23:59:59。由于使用更多的字节，DATETIME类型可以表示的时间范围更广。\n\n\n自动更新功能：\nTIMESTAMP类型：可以设置为自动更新（DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP），这意味着如果这个列有变化，在每次更新数据时会自动将其设置为当前的时间。\nDATETIME类型：没有内置的自动更新功能。如果你需要在DATETIME类型列上实现类似的自动更新行为，你需要在应用程序中进行相应的处理。\n\n\n时区处理：\nTIMESTAMP类型：存储的值是相对于时区的，即它会根据数据库会话的时区进行自动调整。当从数据库中检索TIMESTAMP类型的值时，MySQL会将其转换为客户端连接的时区。因此，TIMESTAMP类型适用于存储基于时区的日期时间信息。\nDATETIME类型：不受时区影响，它表示一个特定的日期和时间，不会随时区变化而变化。当从数据库中检索DATETIME类型的值时，它会保持存储的原始日期时间值。\n\n\n\n通常情况下，如果你需要存储未来较远的时间或者需要进行跨时区的时间操作，你可能更倾向于选择DATETIME类型。而如果你对存储空间敏感或只需要存储近期时间范围内的数据，并且希望利用ON UPDATE CURRENT_TIMESTAMP功能，那么TIMESTAMP类型可能更合适。选择使用哪种类型取决于你的具体需求和应用场景。\n如果为了数据的长远考虑，使用bigint来直接存储毫秒级时间戳数字是更好的选择\n4.String类型\n\n\n数据类型\n说明\n\n\n\nENUM\nENUM是一个字符串对象，其值来自表创建时在列中规定的枚举变量其中之一的值\n\n\nSET\nSET可以有0个或多个值，其值来之表创建时规定允许的一列值。指定包括多个set成员的set列值时，各成员之间需要用逗号风格。set成员值本身不能有逗号\n\n\n需要注意的是，虽然插入的是我们预先设定的枚举值，但后台存放的时候，依旧是以 数字 的方式存放的（节省空间）\n4.1 enum枚举类型和我们在C语言中定义的类似，可以作为一种数据的选项\nweekday ENUM(&#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Wednesday&#x27;, &#x27;Thursday&#x27;, &#x27;Friday&#x27;, &#x27;Saturday&#x27;, &#x27;Sunday&#x27;) NOT NULL\n\n比如我们可以定义一个weekday的枚举类型，来表示星期几\n这样就能保证，这一列的数据，就只能是这个枚举类型之中的数据，而不会出现mon、wed这样的缩写星期\n相当于对使用这个数据库所有开发者的约束，必须要遵守枚举内部的数据要求。\n4.1.1 通过数字插入除了通过直接指定元素来插入，还可以通过数字来插入\n\n我通过数字3来指定weekday里面的值，可以看到插入后的结果为wednesday，即枚举中的第三个值\nMariaDB [hello]&gt; insert into test  values (&#x27;游泳&#x27;,3);Query OK, 1 row affected (0.001 sec)MariaDB [hello]&gt; select * from test;+------------------------------------------+-----------+| hobby                                    | weekday   |+------------------------------------------+-----------+| 跑步,游泳                                | Monday    || 跑步                                     | Monday    || 羽毛球                                   | Monday    || 跑步,羽毛球                              | Monday    || 乒乓球                                   | Monday    ||                                          | Monday    || 跑步,羽毛球,乒乓球,游泳,跳绳             | Monday    ||                                          | Monday    || 游泳                                     | Wednesday |+------------------------------------------+-----------+9 rows in set (0.000 sec)\n\n再试试数字6，插入的是周六，也是第六个值\nMariaDB [hello]&gt; insert into test  values (&#x27;游泳&#x27;,6);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; select * from test;+------------------------------------------+-----------+| hobby                                    | weekday   |+------------------------------------------+-----------+| 跑步,游泳                                | Monday    || 跑步                                     | Monday    || 羽毛球                                   | Monday    || 跑步,羽毛球                              | Monday    || 乒乓球                                   | Monday    ||                                          | Monday    || 跑步,羽毛球,乒乓球,游泳,跳绳             | Monday    ||                                          | Monday    || 游泳                                     | Wednesday || 游泳                                     | Saturday  |+------------------------------------------+-----------+10 rows in set (0.000 sec)\n\n通过以上测试，我买可以知道，枚举值用数字指定的时候，使用的是实际的第n位，而并不是使用下标。比如我想插入0是会报错的，要想往weekday里面插入数据，正确的数字范围是1-7\nMariaDB [hello]&gt; insert into test  values (&#x27;游泳&#x27;,0);ERROR 1265 (01000): Data truncated for column &#x27;weekday&#x27; at row 1\n\n但是，使用数字会大大降低代码可读性，不符合我们使用枚举的初衷。还是更推荐大家直接指定枚举中的元素值！\n\n4.2 setset和enum是类似的，但是可以多选\nhobby set(&#x27;跑步&#x27;,&#x27;羽毛球&#x27;,&#x27;乒乓球&#x27;,&#x27;游泳&#x27;,&#x27;跳绳&#x27;)\n\n4.2.1 插入多个当我们插入数据的时候，可以用逗号插入多个预定义set中的值\ninsert into test values (&#x27;跑步,游泳&#x27;);\n\nMariaDB [hello]&gt; select * from test;+---------------+| hobby         |+---------------+| 跑步,游泳     |+---------------+1 row in set (0.000 sec)\n\n如果尝试插入set中不包含的值，则会报错\nMariaDB [hello]&gt; insert into test values (&#x27;跑步,游泳,代码&#x27;);ERROR 1265 (01000): Data truncated for column &#x27;hobby&#x27; at row 1MariaDB [hello]&gt; \n\n这个set就可以用于收集表来统计用户固定的爱好的情况，让用户来多选，再插入数据库。\n\n4.2.2 元素不能有,因为set可以插入多个，这就要求set中每一个元素本身不能包含, （不能和mysql的关键字冲突，就好比c语言中你不能将关键字定义为成员变量一样。）\n比如，如下的设置就是不允许的\nhobby set(&#x27;跑步&#x27;,&#x27;羽毛球&#x27;,&#x27;乒乓球&#x27;,&#x27;游泳&#x27;,&#x27;跳,绳&#x27;)\n\n这张表会被拒绝创建，报错也告诉你 跳,绳 是不合法的set值\nMariaDB [hello]&gt; create table test (    -&gt; hobby set(&#x27;跑步&#x27;,&#x27;羽毛球&#x27;,&#x27;乒乓球&#x27;,&#x27;游泳&#x27;,&#x27;跳,绳&#x27;));ERROR 1367 (22007): Illegal set &#x27;跳,绳&#x27; value found during parsingMariaDB [hello]&gt; \n\n4.2.3 用数字插入？除了用set中的数据，我们还可以用数字来插入这些元素\nMariaDB [hello]&gt;  insert into test values (1);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; select * from test;+---------------+| hobby         |+---------------+| 跑步,游泳     || 跑步          |+---------------+2 rows in set (0.001 sec)\n\n多尝试几个，会发现结果很奇怪，并不是当时定义表中，set元素的下标\nMariaDB [hello]&gt; insert into test values (2);Query OK, 1 row affected (0.009 sec)MariaDB [hello]&gt; insert into test values (3);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; insert into test values (4);Query OK, 1 row affected (0.003 sec)MariaDB [hello]&gt; select * from test;+------------------+| hobby            |+------------------+| 跑步,游泳        || 跑步             || 羽毛球           || 跑步,羽毛球      || 乒乓球           |+------------------+5 rows in set (0.001 sec)\n\n比如你打算插入0的时候，会发现是一个空（但不是NULL）\nMariaDB [hello]&gt; insert into test values (0);Query OK, 1 row affected (0.041 sec)MariaDB [hello]&gt; select * from test;+------------------+| hobby            |+------------------+| 跑步,游泳        || 跑步             || 羽毛球           || 跑步,羽毛球      || 乒乓球           ||                  |+------------------+6 rows in set (0.001 sec)\n\n4.2.3 位图实际上，这里是用位图来表示每一个数据的位置的\nhobby set(&#x27;跑步&#x27;,&#x27;羽毛球&#x27;,&#x27;乒乓球&#x27;,&#x27;游泳&#x27;,&#x27;跳绳&#x27;)\n\n这里一共有5个数据，对应就是5个字节。需要注意，其将set中的第一个元素放置在了二进制的低位。比如 跑步 对应的是二进制数码最右侧的（低位）的第一个二进制位\n0 0 0 0 0 # 啥都不插入0 0 0 0 1 # 插入跑步0 0 0 1 0 # 插入羽毛球0 0 0 1 1 # 插入跑步,羽毛球0 0 1 0 1 # 插入跑步,乒乓球# 以此类推\n\n但当我们尝试插入一个超过5个比特能表示的数据（0~31）时，会发生什么呢？\nMariaDB [hello]&gt; insert into test values (1000);ERROR 1265 (01000): Data truncated for column &#x27;hobby&#x27; at row 1MariaDB [hello]&gt; insert into test values (32);ERROR 1265 (01000): Data truncated for column &#x27;hobby&#x27; at row 1\n\n不给插入辣！\n而插入31是可以的，也就是5个爱好都带上\nMariaDB [hello]&gt; insert into test values (31);Query OK, 1 row affected (0.042 sec)MariaDB [hello]&gt; select * from test;+------------------------------------------+| hobby                                    |+------------------------------------------+| 跑步,游泳                                || 跑步                                     || 羽毛球                                   || 跑步,羽毛球                              || 乒乓球                                   ||                                          || 跑步,羽毛球,乒乓球,游泳,跳绳             |+------------------------------------------+7 rows in set (0.001 sec)\n\n这样我们也可以理解为什么插入0是一个空值了。这便代表用户在提供的选项中谁都没有选择（相当于弃权）\n4.2.4 查询既然能用数字插入，就能用数字查询\nMariaDB [hello]&gt; select * from test where hobby=31;+------------------------------------------+| hobby                                    |+------------------------------------------+| 跑步,羽毛球,乒乓球,游泳,跳绳             |+------------------------------------------+1 row in set (0.001 sec)\n\n4.2.5 条件查询 find_in_setselect find_in_set(&#x27;a&#x27;,&#x27;a,b,c&#x27;);\n\n这个函数能帮我们查看一个数据是否在定义的set中，上面这个语句的意思是查询a 是否在set a,b,c 中。控制台中测试，结果输出为1（代表True）\n如果不在，返回的是0（代表False）\nMariaDB [hello]&gt; select find_in_set(&#x27;a&#x27;,&#x27;a,b,c&#x27;);+--------------------------+| find_in_set(&#x27;a&#x27;,&#x27;a,b,c&#x27;) |+--------------------------+|                        1 |+--------------------------+1 row in set (0.000 sec)\n\n而在查询的时候，就可以用这个来筛选出爱好有其中一项的人\nMariaDB [hello]&gt; select * from test where find_in_set(&#x27;游泳&#x27;,hobby);+------------------------------------------+| hobby                                    |+------------------------------------------+| 跑步,游泳                                || 跑步,羽毛球,乒乓球,游泳,跳绳             |+------------------------------------------+2 rows in set (0.001 sec)\n\n这样就成功把爱好中有游泳的人给筛选出来了！\n而且我们还可以用or (and)来连接两个条件，实现更大范围的查询。\nMariaDB [hello]&gt; select * from test where find_in_set(&#x27;游泳&#x27;,hobby) or find_in_set(&#x27;羽毛球&#x27;,hobby);+------------------------------------------+| hobby                                    |+------------------------------------------+| 跑步,游泳                                || 羽毛球                                   || 跑步,羽毛球                              || 跑步,羽毛球,乒乓球,游泳,跳绳             |+------------------------------------------+4 rows in set (0.001 sec)\n\nThe endOver！\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【树莓派开发】出现报错pragama once in main file","url":"/posts/3252921223/","content":"\n\n前言众所周知，#pragma once语句是防止头文件重复包含非常常用的一条语句VS编译器在创建.h文件的时候会自动帮你在开头添加这个语句但是在gcc编译器下，这个语句就可能会出现一些问题\n\n所使用编译器：\n\nVS2019（windows10）\n树莓派（linux-gcc）\n\n\nwarning: #pragma once in main file在我尝试在linux环境下使用#pragma once语句时，遇到了这个报错\n\n解决这个问题的办法很简单，就是不要编译头文件\n\n编译器会自动展开头文件，无需手动编译\n\n\n\n出现问题原因网上查了查：出现这个问题的原因是编译器在编译头文件的时候，#pragma once本身是没有含义的语句，所以报错了。\n\n也有人说是因为linux不支持这个语句，我们来试试\n\n右侧代码中包含了两个test.h的引用，在预处理中只包含了一次\n\n去掉头文件中的#pragma once，再次编译，可以看到预处理文件中出现了两次头文件的内容\n\n这说明linux-gcc编译器是支持该语句的，并非网上说的不支持！\n其他解决方法如果你的gcc编译器不管咋弄都有这个报错，咱可以不用它嘛！使用条件编译指令ifndef也可以达成防止头文件重复包含的效果\n#ifndef __TEST_H__//如果没有定义过这个符号#define __TEST_H__//定义该符号//头文件内容#endif\n\n\n查资料查到外网去了~刚刚写预处理博客的时候，查有关这个问题的资料，百度都给我推了外网的论坛\n\n参考：https://bbs.csdn.net/topics/395771733?page=1\n\n\n网上有关这个报错的信息的确不多，特此写篇博客记录一下\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【Sqlite3】maraidb和sqlite3部分命令操作区别","url":"/posts/2259981507/","content":"maraidb和sqlite3部分命令操作区别记录\n\n\n1.安装sqlite3在实现我的视频点播系统项目时，我尝试封装了两种数据库的调用逻辑\n\nmysql（maraidb）\nsqlite3\n\n这里封装sqlite3的原因是，sqlite3主要针对的就是嵌入式数据库，其性能可能不如mysql，但是就好在可以带着走。安装也很方便，内存占用相对于mariadb来说也降低了很多。\n\n教程：安装maraidb\n\n在上面的博客中，安装maraidb需要很多步骤，还需要修改配置文件中的默认字符集为UTF8。\n而安装sqlite3就要多方便有方便了，而且sqlite3默认采用的就是uft8字符集，完全不需要修改！\nsudo yum install sqlite-devel\n\n就这一行命令就搞定了！\nsqlite3 --version #查看当前安装的版本\n\n安装完成后，可以看看sqlite3的版本（如果没有安装，执行这个命令会告知 command not found）\n[root@1c2261732150:~]# sqlite3 --version3.26.0 2018-12-01 12:34:55 bf8c1b2b7a5960c282e543b9c293686dccff272512d08865f4600fb58238alt1\n\n安装新版本 sqlite3默认安装的版本可以看到已经是 2018 年的老东西了，可以尝试用下面的办法安装最新版本，需要修改以下命令中的链接和文件名，最新版本的 sqlite 去官网上找 https://www.sqlite.org/download.html\nsudo yum remove sqlite-develwget https://www.sqlite.org/2019/sqlite-autoconf-3280000.tar.gztar -xzf sqlite-autoconf-3280000.tar.gzcd sqlite-autoconf-3280000./configuremakesudo make install\n\n选择官网上名字为 sqlite-autoconf 的 tar.gz 下载就行了。请注意安装之前一定要卸载原有的 sqlite。\n请注意，如果你需要用 python 操作 sqlite，在更新 sqlite 版本后需要重新编译安装 python。\n依照如上命令，我成功更新 sqlite 到 2023 年的最新版本了\n# sqlite3 --version3.44.0 2023-11-01 11:23:50 17129ba1ff7f0daf37100ee82d507aef7827cf38de1866e2633096ae6ad81301 (64-bit)\n\n\n更新参考博客 https://number1.co.za/upgrading-sqlite-on-centos-to-3-8-3-or-later/\n\n2.基本操作的区别如下列出一些基本操作在mariadb命令行中，和在sqlite3命令行中的区别\n为了方便，注释中m指代mysql，s指代sqlite3\nshow databases; -- 查看所有数据库 mariadb.database       -- 查看当前数据库 sqlite3use db_name;      -- 进入数据库 m.open db_name.db; -- 提供.db文件的路径，进入数据库 sshow tables;    -- 查看数据库中所有表 m.tables         -- 查看数据库中所有表 squit  -- 退出数据库命令行 m.quit -- 退出数据库命令行 s\n\n这便是基础操作的一些区别，更深入的操作我暂时还没有学到。\n其中进入数据库的操作就能看出来sqlite的特性，只要有这个.db文件，你就可以很轻松的在另外一个主机上恢复之前的数据（或者进行备份），这也是带着走的体现。\n3.创建表mysql和sqlite3所支持的数据类型也有区别\n\n\n\nsqlite3数据类型\n描述\n\n\n\nNULL\n值是一个 NULL 值。\n\n\nINTEGER\n值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。\n\n\nREAL\n值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。\n\n\nTEXT\n值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。\n\n\nBLOB\n值是一个 blob 数据，完全根据它的输入存储。\n\n\n在sqlite3中，没有varchar类型。但我们依旧可以使用TEST(8)来限制字符串类型的长度\n以我的视频点播项目所用数据库为例，以下是mariadb创建数据表的sql语句\ncreate table tb_video(    id VARCHAR(8) NOT NULL DEFAULT (substring(UUID(), 1, 8)) comment &#x27;视频id&#x27;,    name VARCHAR(50) comment &#x27;视频标题&#x27;,    info text comment &#x27;视频简介&#x27;,    video VARCHAR(255) comment &#x27;视频链接&#x27;,    cover VARCHAR(255) comment &#x27;视频封面链接&#x27;,    insert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP comment &#x27;视频创建时间&#x27;);\n\n在这里我采用了mariadb自带的uuid函数来生成uuid字符串，并使用substring函数截取了uuid前8位的内容，作为视频的唯一id\n而如果想让mariadb来保证id字段唯一，可以使用如下命令进行约束\ncreate table tb_video(    id VARCHAR(8) NOT NULL DEFAULT (substring(UUID(), 1, 8)) comment &#x27;视频id&#x27;,    name VARCHAR(50) comment &#x27;视频标题&#x27;,    info text comment &#x27;视频简介&#x27;,    video VARCHAR(255) comment &#x27;视频链接&#x27;,    cover VARCHAR(255) comment &#x27;视频封面链接&#x27;,    insert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP comment &#x27;视频创建时间&#x27;,    UNIQUE (id));\n\n\n以下是sqlite3的操作，sqlite3中并不支持comment对字段进行注释。\n这里要想让id字段唯一，直接在字段类型后面跟着UNIQUE就可以了\n-- sqlite3中不支持uuid函数，所以需要用randomblob函数生成一个随机数，再用hex转成16进制作为视频的id-- sqlite3默认的时间是utc，所以需要用datetime函数将其转化为东八区的时间CREATE TABLE IF NOT EXISTS tb_video(    id TEXT(8) UNIQUE NOT NULL DEFAULT (lower((hex(randomblob(4))))),    name TEXT NOT NULL,    info TEXT,    video TEXT NOT NULL,    cover TEXT NOT NULL,    insert_time TIMESTAMP DEFAULT (datetime(&#x27;now&#x27;, &#x27;+8 hours&#x27;)));\n\n查看表结构在 msyql 中可以用 desc 快捷查看表结构，但是 sqlite3 中不支持此功能。\n在 sqlite3 数据库中用如下语句查看数据库中的建表语句，依此可以看到表结构。\nSELECT sql FROM sqlite_master WHERE type=&quot;table&quot;;\n\n4.插入删除数据在我项目所用字段中，二者插入&#x2F;删除数据的操作完全相同，这里就不记录了\n-- 删除表drop table tb_video;-- 插入数据insert into tb_video (name, info, video, cover) values (&#x27;名字1&#x27;,&#x27;说明信息1&#x27;,&#x27;test1&#x27;,&#x27;testc1&#x27;);-- 查看所有字段select * from tb_video;select * from tb_video where id=&#x27;45f78a68&#x27;; -- 删除数据delete from tb_video where id = &#x27;D81382A8&#x27;;\n\n5.使用cpp操作的时候\nmysql必须要进行init，此时就需要指定目标数据库了\n而sqlite3并不需要进行数据库的连接操作，我们就可以实现在cpp中进行数据库的创建、数据表的创建等操作。\n\nc语言操作sqlite3的方法，可以查看菜鸟教程。上面的用例很详细（虽然没有写注释，但还是能看懂的）我就不写博客了~\n5.1 查询时的回调这里只对select命令操作进行说明，在sqlite3中，所有命令都是用下面这个函数来执行的\nSQLITE_API int sqlite3_exec(  sqlite3*,                                  /* An open database */  const char *sql,                           /* SQL to be evaluated */  int (*callback)(void*,int,char**,char**),  /* Callback function */  void *,                                    /* 1st argument to callback */  char **errmsg                              /* Error msg written here */);\n\n如果你执行的是插入、更新等等sql语句，sqlite_callback函数不会被调用（我测试过了）。目前我只发现select语句会调用这个callback函数。\n比如我的数据库tb_video中有如下两行数据\ndf65c8c5|名字1|说明信息1|test1|testc1|2023-05-04 16:57:1080cd3f51|名字1|说明信息1|test1|testc1|2023-05-04 19:02:05\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt;// 每当有结果返回的时候，用这个函数来处理结果// 第一个参数可以从sqlite3_exec中主动传入// argc 是结果的行数（二维数组行数）// argv 是存放数据的二维数组// azColName 是存放字段名称的二维数组static int callback(void *NotUsed, int argc, char **argv, char **azColName)&#123;\tint i;\tfor (i = 0; i &lt; argc; i++)\t&#123;\t\tprintf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;);\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;// sqlite3数据库打开测试void SqliteTest()&#123;\tsqlite3 *db;// 数据库指针\tchar *zErrMsg = 0;\tstd::string sql;\tint ret;\t// 打开数据库文件\tif (sqlite3_open(&quot;test.db&quot;, &amp;db))\t&#123;\t\tfprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db));\t\texit(0);\t&#125;\telse\t&#123;\t\tfprintf(stderr, &quot;Opened database successfully\\n&quot;);\t&#125;\tsql = &quot;select * from tb_video;&quot;;\t// 执行sql语句\tret = sqlite3_exec(db, sql.c_str(), callback, 0, &amp;zErrMsg);\tif (ret != SQLITE_OK)\t&#123;\t\tfprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg);\t\tsqlite3_free(zErrMsg);\t&#125;\telse\t&#123;\t\tfprintf(stdout, &quot;SQL successfully\\n&quot;);\t&#125;\tsqlite3_close(db);&#125;\n\n用这个函数来查询，会打印如下的结果。从这个结果中，就能推测出callback函数4个参数分别的作用，已经在代码的注释中说明了。\nOpened database successfullyid = df65c8c5name = 名字1info = 说明信息1video = test1cover = testc1insert_time = 2023-05-04 16:57:10id = 80cd3f51name = 名字1info = 说明信息1video = test1cover = testc1insert_time = 2023-05-04 19:02:05\n\n其中，第四个参数是给callback函数传入的第一个入参。\n5.2 通过回调插入数据到Json字符串我的视频点播项目在查询的时候，需要将结果保存为json字符串，如果使用mysql的c++操作，就可以直接在遍历结果的二维数组时，将结果放入到Json::Value中\n// 查询所有-输出所有视频信息（视频列表）bool SelectAll(Json::Value *video_s)&#123;    #define SELET_ALL &quot;select * from %s;&quot;    std::string sql;    sql.resize(512);    sprintf((char*)sql.c_str(),SELET_ALL,_video_table.c_str());    // 这里加锁是为了保证结果集能被正常报错（并不是防止修改原子性问题,mysql本身就已经维护了原子性）    // 下方执行语句后，如果不保存结果集 而又执行一次搜索语句，之前搜索的结果就会丢失    // 加锁是为了保证同一时间只有一个执行流在进行查询操作，避免结果集丢失    _mutex.lock();    // 语句执行失败了    if (!MysqlQuery(_mysql, sql)) &#123;        _mutex.unlock();        _log.error(&quot;Video SelectAll&quot;,&quot;query failed&quot;);        return false;    &#125;    // 保存结果集到本地    MYSQL_RES *res = mysql_store_result(_mysql);    if (res == nullptr) &#123;        _mutex.unlock();        _log.error(&quot;Video SelectAll&quot;,&quot;mysql store result failed&quot;);        return false;    &#125;    // 遍历结果集，存到json中    int num_rows = mysql_num_rows(res);//获取结果集的行数    for (int i = 0; i &lt; num_rows; i++) &#123;        MYSQL_ROW row = mysql_fetch_row(res);//获取每一行的列数        Json::Value video;        video[&quot;id&quot;] = row[0];        video[&quot;name&quot;] = row[1];        video[&quot;info&quot;] = row[2];        video[&quot;video&quot;] = row[3];        video[&quot;cover&quot;] = row[4];        video[&quot;insert_time&quot;] = row[5]; //mysql中存放的就是可读时间 （其实存时间戳更好）        //json list        video_s-&gt;append(video);    &#125;    mysql_free_result(res);//释放结果集    _mutex.unlock();    _log.info(&quot;Video SelectAll&quot;,&quot;select all finished&quot;);    return true;&#125;\n\n而在sqlite3中，就需要使用callback函数的第一个参数来进行json字符串的保存；这里因为sqlite3会给我们返回字段名字，我们就可以直接用字段明作为json的字段名，将参数作为json字段的对应参数。更省事了！\nstatic int callback(void *json_videos, int argc, char **argv, char **azColName)&#123;\tJson::Value* video_s =  (Json::Value*)json_videos;//转为原本的类型\tJson::Value video;//单个视频\tfor (int i = 0; i &lt; argc; i++)\t&#123;\t\tvideo[azColName[i]] = argv[i] ? argv[i] : &quot;NULL&quot;;//存入数据\t\tprintf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;);\t&#125;\tprintf(&quot;\\n&quot;);\tvideo_s-&gt;append(video);//插入到json数组中\treturn 0;&#125;\n\n在主函数中，创建一个Json::Value对象，将其强转为void*的指针，传给callback函数\n// 查询Json::Value videos;sql = &quot;select * from tb_video;&quot;;// 执行sql语句ret = sqlite3_exec(db, sql.c_str(), callback, (void*)&amp;videos, &amp;zErrMsg);if (ret != SQLITE_OK)&#123;\tfprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg);\tsqlite3_free(zErrMsg);&#125;else&#123;\tfprintf(stdout, &quot;Table created successfully\\n&quot;);&#125;sqlite3_close(db);std::string json_str;vod::JsonUtil::Serialize(videos,&amp;json_str);std::cout &lt;&lt; json_str &lt;&lt; std::endl;\n\n编译执行，最终打印的json字符串如下（完整代码见 Github）\n[        &#123;                &quot;cover&quot; : &quot;testc1&quot;,                &quot;id&quot; : &quot;df65c8c5&quot;,                &quot;info&quot; : &quot;\\u8bf4\\u660e\\u4fe1\\u606f1&quot;,                &quot;insert_time&quot; : &quot;2023-05-04 16:57:10&quot;,                &quot;name&quot; : &quot;\\u540d\\u5b571&quot;,                &quot;video&quot; : &quot;test1&quot;        &#125;,        &#123;                &quot;cover&quot; : &quot;testc1&quot;,                &quot;id&quot; : &quot;80cd3f51&quot;,                &quot;info&quot; : &quot;\\u8bf4\\u660e\\u4fe1\\u606f1&quot;,                &quot;insert_time&quot; : &quot;2023-05-04 19:02:05&quot;,                &quot;name&quot; : &quot;\\u540d\\u5b571&quot;,                &quot;video&quot; : &quot;test1&quot;        &#125;]\n\n5.3 对表的查询除了使用sqlite3_exec针对数据库进行操作，还可以用下面这个函数，对指定的表进行查询\nint sqlite3_get_table(  sqlite3* db,              /* 数据库连接 */  const char *zSql,         /* 查询语句 */  char ***pazResult,        /* 查询结果 */  int *pnRow,               /* 查询结果的行数 */  int *pnColumn,            /* 查询结果的列数 */  char **pzErrmsg           /* 错误信息 */);\n\n参数说明如下，这里就比较类似mysql的查询函数了，其会给我们返回结果集，以及结果的行数、列数，让我们自己遍历进行操作。\n\ndb: 数据库连接对象，是已经打开的数据库连接。\nzSql: 执行的 SQL 查询语句。\npazResult: 一个 char 类型的指针数组（二维，每一行是一个指针，指向一个字符串），用于存储查询结果。每个元素都指向一个表示每行数据的字符串数组。最后一个元素为 NULL。\npnRow: 用于存储查询结果的行数。\npnColumn: 用于存储查询结果的列数。\npzErrmsg: 用于存储错误信息。\n\nsqlite3_get_table 函数执行查询语句时，结果集中的每个单元格都被解释为一个字符串。查询结果将被存储在指针数组 pazResult 中，每行数据占用一个字符串数组（除了最后一个元素为 NULL）。表格的第一行包含列名，后面的每行则为查询结果中的一条记录。\nsqlite3_get_table 函数的作用是执行一条 SQL 查询语句，并将其结果存储在一个表格中，以便后续处理和分析。\n调用完毕这个函数，处理完结果集后，需要调用如下函数释放结果集。\nchar **pazResult; /* 二维指针数组，存储查询结果 */int nRow = 0, nColumn = 0;/* 获得查询结果的行数和列数 */sqlite3_get_table(db, &quot;SELECT * FROM tb_video;&quot;, &amp;pazResult, &amp;nRow, &amp;nColumn, NULL);// 遍历处理结果集// ....sqlite3_free_table(pazResult);// 处理完毕结果集后释放\n\n\n5.3.1 错误示例如下是一个示例的错误代码！\nchar **pazResult; /* 二维指针数组，存储查询结果 *//* 获得查询结果的行数和列数 */int nRow = 0, nColumn = 0,index=0;sqlite3_get_table(db, &quot;SELECT * FROM tb_video;&quot;, &amp;pazResult, &amp;nRow, &amp;nColumn, NULL);std::cout &lt;&lt; nRow &lt;&lt; &quot; &quot; &lt;&lt;  nColumn &lt;&lt; std::endl;for (int i = 0; i &lt; nRow; i++)&#123;\tfor (int j = 0; j &lt; nColumn; j++)\t&#123;\t\tprintf(&quot;%-8s : %-8s\\n&quot;, pazResult[j],pazResult[i][j]);\t&#125;   &#125;sqlite3_free_table(pazResult);\n\n编译不会出错，但是执行的时候，直接会出现段错误\nOpened database successfully2 6Segmentation fault\n\n这是因为我们的pazResult只是一个二级指针，我们并没有给他初始化为多少行多少列的模式，导致最终++的时候，会出现访问错位的情况。\n如果改成下面这样的打印\ncout &lt;&lt;  pazResult[j] &lt;&lt; endl;cout &lt;&lt; &quot;--&quot; &lt;&lt; endl;cout &lt;&lt; pazResult[i][j] &lt;&lt; endl;cout &lt;&lt; &quot;---&quot; &lt;&lt; endl;\n\n打印的结果就是这样的，合计是在遍历每一个字符串！\nid--i---name--d---info-----video-----cover-----insert_time--后面重复的就省略掉了\n\n为什么不行呢？这是因为pazResult实际上的结构是这样的\nidnameinfovideocoverinsert_timedf65c8c5名字1说明信息1test1testc12023-05-04 16:57:10\n\n使用pazResult[i][j]进行访问：\n\n当i是0的时候，访问的是id字符串\n此时j就变成id字符串里面的下标了\n而nColumn远大于id字符串的长度（id只有两个字符，而在我这里nColumn=6）\n所以就出现了段错误 Segmentation fault！\n\n我还是学艺不精呀！🤣\n\n5.3.2 正确操作正确的办法应该是这样的\nJson::Value videos;char **pazResult; /* 二维指针数组，存储查询结果 *//* 获得查询结果的行数和列数 */int nRow = 0, nColumn = 0,index=0;sqlite3_get_table(db, &quot;SELECT * FROM tb_video;&quot;, &amp;pazResult, &amp;nRow, &amp;nColumn, NULL);std::cout &lt;&lt; nRow &lt;&lt;&quot; &quot; &lt;&lt;  nColumn &lt;&lt; std::endl;index = nColumn;//从第二列开始，跳过第一行（第一行都是字段名）for (int i = 0; i &lt; nRow; i++)&#123;\tfor (int j = 0; j &lt; nColumn; j++)\t&#123;            // 前nColumn个数据都是字段名，所以可以用 pazResult[j] 来打印\t\tprintf(&quot;%-8s : %-8s\\n&quot;, pazResult[j],pazResult[index]);\t\tindex++;\t&#125;&#125;sqlite3_free_table(pazResult);\n\n成功打印出了数据库中两行的数据\nOpened database successfully2 6id       : df65c8c5name     : 名字1 info     : 说明信息1video    : test1   cover    : testc1  insert_time : 2023-05-04 16:57:10id       : da6d27bename     : 名字2 info     : 说明信息2video    : test2   cover    : testc2  insert_time : 2023-05-04 19:59:38\n\n和从数据库命令行中读取到的结果相同\nsqlite&gt; select * from tb_video;df65c8c5|名字1|说明信息1|test1|testc1|2023-05-04 16:57:10da6d27be|名字2|说明信息2|test2|testc2|2023-05-04 19:59:38\n\n最终的完整代码如下\nvoid SqliteTest()&#123;\tsqlite3 *db; // 数据库指针\tchar *zErrMsg = 0;\tstd::string sql;\tint ret;\t// 打开数据库文件\tif (sqlite3_open(&quot;test.db&quot;, &amp;db))\t&#123;\t\tfprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db));\t\texit(0);\t&#125;\telse\t&#123;\t\tfprintf(stderr, &quot;Opened database successfully\\n&quot;);\t&#125;\t// 查询\tJson::Value videos;\tchar **pazResult; /* 二维指针数组，存储查询结果 */\t/* 获得查询结果的行数和列数 */\tint nRow = 0, nColumn = 0;\tsqlite3_get_table(db, &quot;SELECT * FROM tb_video;&quot;, &amp;pazResult, &amp;nRow, &amp;nColumn, NULL);\tstd::cout &lt;&lt; nRow &lt;&lt;&quot; &quot; &lt;&lt;  nColumn &lt;&lt; std::endl;\tint index = nColumn;//从第二列开始，跳过第一行（第一行都是字段名）\tfor (int i = 0; i &lt; nRow; i++)\t&#123;\t\tJson::Value video;\t\tfor (int j = 0; j &lt; nColumn; j++)\t\t&#123;\t\t\t// 前nColumn个数据都是字段名，所以可以用 pazResult[j] 来打印\t\t\t// printf(&quot;%-8s : %-8s\\n&quot;, pazResult[j],pazResult[index]);\t\t\tvideo[pazResult[j]] = pazResult[index] ?pazResult[index] : &quot;NULL&quot;; // 存入数据\t\t\tindex++;\t\t&#125;\t\t// json list\t\tvideos.append(video);\t&#125;\tstd::string json_str;\tvod::JsonUtil::Serialize(videos, &amp;json_str);\tstd::cout &lt;&lt; json_str &lt;&lt; std::endl;\t\tsqlite3_free_table(pazResult);\tsqlite3_close(db);&#125;\n\n完整输出如下，json字符串内的数据是正确的！\nOpened database successfully2 6[        &#123;                &quot;cover&quot; : &quot;testc1&quot;,                &quot;id&quot; : &quot;df65c8c5&quot;,                &quot;info&quot; : &quot;\\u8bf4\\u660e\\u4fe1\\u606f1&quot;,                &quot;insert_time&quot; : &quot;2023-05-04 16:57:10&quot;,                &quot;name&quot; : &quot;\\u540d\\u5b571&quot;,                &quot;video&quot; : &quot;test1&quot;        &#125;,        &#123;                &quot;cover&quot; : &quot;testc2&quot;,                &quot;id&quot; : &quot;da6d27be&quot;,                &quot;info&quot; : &quot;\\u8bf4\\u660e\\u4fe1\\u606f2&quot;,                &quot;insert_time&quot; : &quot;2023-05-04 19:59:38&quot;,                &quot;name&quot; : &quot;\\u540d\\u5b572&quot;,                &quot;video&quot; : &quot;test2&quot;        &#125;]\n\nsqlite3在返回数据的时候也会给我们返回表中的字段名。我们可以将json字段的key设置成字段名，这样就实现了字段的统一\n\n个人认为，为了避免出现同一value而key不同的情况，最好是将应用层和数据库中的字段统一。否则出现二义性问题不好排查。特别是当一个表中的字段较多的时候。\n\n结语需要注意的是，二者只是适用范围的区别，并没有孰强孰弱的差距。\n以下是gpt3.5对二者区别的总结：\n\nSQLite3 和 MySQL 都是流行的关系型数据库管理系统，但它们有不同的用途和设计重点。\n\nSQLite3 的主要目标是作为嵌入式数据库使用，包括在移动设备和桌面应用程序中，也可以作为轻量级数据库使用。相比之下，MySQL 的主要重点是支持大型企业级应用程序和高负载服务器。\nSQLite3 是一个服务器不需要客户端的完全独立的自包含数据库，MySQL 是一个客户端&#x2F;服务器模型的数据库，需要一个专用的服务器端。\nSQLite3 支持 SQL-92 标准的基本功能，而 MySQL 支持更广泛的 SQL 标准以及许多扩展功能。\nSQLite3 的数据存储在单个文件中，而 MySQL 的数据通常存储在多个文件或分布式系统中。\n\n\n就记录这么多吧！\n","categories":["学习sql"],"tags":["Linux","mysql","sqlite3"]},{"title":"【树莓派开发】使用树莓派在Linux环境下编写C语言代码","url":"/posts/3611814801/","content":"\n\n\n\n前言如何使用树莓派编译C语言代码呢？\n\n\n21年暑假的时候，学习编程的劲头高涨，然后冲动消费买了个树莓派4B……结果压根不会用，吃灰了半年\n\n不过现在已经学完了C语言，也接触了一丢丢Linux系统下的gcc指令，可以尝试用它来编写C语言代码了！\n\n1.创建test.c文件首先我们需要在一个文件夹里创建一个test.c文件\n\n点击test.c文件后，树莓派会用自带的Geany编辑器打开它\n然后我们可以往里写入C语言最经典的helloword代码\n#include &lt;stdio.h&gt;int main(void)&#123;\tprintf(&quot;hello wordl!\\n&quot;); \treturn 0;&#125;\n\n2.编译运行该文件保存文件后，打开顶部的命令行\n\n输入以下代码\n\n注意cd后需要空格，填写的是刚刚创建的test1.c文件的路径\n\ncd /home/pi/code\n\n填写完毕后，可以看到命令行前面多出了一个文件地址\n\n这代表目前我们操作的是code文件夹里面的内容\n输入ls，可以看到当下文件夹里的文件\n\n输入以下指令，可以生成一个可执行文件\ngcc test1.c -o test1\n\n\n最后输入以下指令，可以运行该文件！\n./test1\n\n可以看到，程序已经成功运行了！\n\n\n3.编译并链接两个源文件接下来我们再尝试一个相对来说更复杂的代码\n分开两个源文件，一个是test.c，包含了main函数\n另外一个是Add.c，包含了Add函数\n因为是在不同的源文件里面，我们需要用extern来声明外部函数\n#include &lt;stdio.h&gt; extern int Add(int x,int y); int main(void)&#123;\tint a=3;\tint b=5;\tprintf(&quot;%d&quot;,Add(a,b); \treturn 0;&#125;\n\n\n接下来我们使用-c指令来生成.o目标文件\n\n在vs下，目标文件的后缀是.obj\n.i文件为预编译文件\n\n可以看到，我的代码里面extern写错了（很是尴尬），编译器报了警告\n更改了以后就编译成功了\n\n这一步是把C语言代码转换成机器认识的二进制指令\n\n\n然后输入以下指令，链接这两个文件，生成可执行文件test\ngcc test1.c Add.c -o test\n\n\n最后还是使用./test指令来运行可执行文件\n可以看到我们的结果已经输出了！\n\n结语第一次尝试用linux的gcc指令来编译C语言代码，还有点小激动\n吃灰的树莓派终于有用了！😍\n\n如果有写的不对的地方，还请大佬无情指出！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【树莓派开发】树莓派GeanyIDE和控制台下C/C++中文乱码问题解决方法","url":"/posts/330726760/","content":"\n\n\n\n情况说明之前使用树莓派的时候，遇到了中文乱码的问题。\n\nVS2019编译器下写的.c文件，里面的中文注释在树莓派ide上乱码\n树莓派控制台上，C语言代码输出中文时乱码\n\n这里需要调整三个设置来解决该问题\n1.设置VS，将文件保存为UTF8编码VS2019默认用的是GBK编码，而不是一般中文需要的UTF8编码\n这里我们可以安装一个Force UTF-8(No BOM)插件来解决该问题\n\n在VS顶部工具栏里找到“拓展”-管理拓展\n\n\n\n搜索Force UTF-8(No BOM)，找到该插件并安装\n\n\n这个插件的作用，是让VS保存文件都使用UTF8编码保存\n安装完毕后，可以在原本文件中打一个注释并保存，这时候.c文件就已经是UTF8编码了\n\n\n\n树莓派中可以更改文件编码，但这个更改并不会对已经乱码了的中文生效\n\n更新22.03.01：使用该插件可能会导致报错该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失出现这种情况需要禁用插件，重启VS才能解决。否则程序有中文注释就无法运行\n2.更改Geany IDE编码设置更改完VS的设置后，我们需要更改树莓派下IDE的设置\n在编辑-首选项里面选择文件，将两个设置选项都改为UTF8\n\n\n3.更改树莓派系统设置前面两个设置完之后，我们还需要在树莓派的控制系统中输入一串命令\nsudo raspi-config\n\n\n选择第4个，区域语言设定，进入后选择第一个，来到如下界面\n\n找到zh_cn.UTF8\n\n选择后，会进入设置界面，提示complete就完成设置了\n\n再次进入树莓派，用控制台运行我们的代码，可以看到中文已经正常显示了！\n\n\n\n如果这篇博客对你有帮助，还请点赞支持一下，谢谢！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【MySQL】sql字段约束","url":"/posts/4138950838/","content":"前言在MySQL中，我们需要存储的数据在特定的场景中需要不同的约束。当新插入的数据违背了该字段的约束字段，MySQL会直接禁止插入。\n\n数据类型也是一种约束，但数据类型这个约束太过单一；\n比如我需要存储的是一个序号，那就不可能会有负数，这时候就要用无符号来对整形进行约束；\n如果我要存储的是一个日期，且这个日期每个字段都必须要有，那就需要用NOT NULL不为空来进行约束；\n如果我要存储的是一个用户ID，在整个用户系统中这个值肯定是唯一的，就可以使用UNIQUE来约束唯一性\n\n本文主要介绍下面几种约束的类型，这依旧是MySQL中ddl类型的语句操作。\nnull/not null 是否可以为空default 默认值comment 列评论zerofill 前补0primary key 主键auto_increment 自增unique key 唯一键foreign key 外键check 数据检查约束（比如数据范围判断）\n\n顺带一提，在MySQL中，每一列的值可以称之为列或者字段，一般不称之为键值。而表中的每一行被称作一条记录；\n\n我写python的时候就一直把dict的key叫做键值，然后就叫习惯了…\n\n1.空属性null1.1 说明空属性包含两个值，NULL/NOT NULL，分别对应为空和不为空\n在数据库中，如果我们在插入一行时没有指定某一列的值，那么数据库就会把这个值设置为NULL；\n\n这里要注意区分NULL和空字符串，空字符串并不是NULL！\n\n但实际使用数据的时候，假设这是一个整形的数据，我们需要取出来后对其进行运算。此时NULL取出来的结果就不是一个数字，没有办法进行运算。所以在很多时候，我们都会把一个字段的约束设置为NOT NULL并添加上一个默认值（比如0或者空字符串）\nMariaDB [hello]&gt; select null;+------+| NULL |+------+| NULL |+------+1 row in set (0.000 sec)MariaDB [hello]&gt; select not null;+----------+| not null |+----------+|     NULL |+----------+1 row in set (0.001 sec)\n\n由下可见空属性是没办法参与运算的，不管如何运算其结果都是NULL\n在Python中，NULL直接对应的就是None，当你尝试用None和int类型进行运算的时候，Python就会报错了。CPP中也是如此。\nMariaDB [hello]&gt; select 1+null;+--------+| 1+null |+--------+|   NULL |+--------+1 row in set (0.001 sec)\n\n1.2 案例假设我们有一个楼层中的班级和教室对应的表，其中包含班级编号和教室编号这两个字段\n\n如果班级编号为空，那就不知道在这间教室上课的是那个班级\n如果教室编号为空，那就不知道某个班级到底是在哪里上课\n\n由实际场景可见，这两个字段都不可以为空，所以在建表的时候就需要考虑到这一点\ncreate table if not exists myclass(\tclass_name varchar(30) not null,    class_room varchar(30) not null)default charset=utf8;\n\n创建了表之后，当我们尝试将一个NULL的字段插入，会出现如下的提示，标识某一列不能为空\nMariaDB [hello]&gt; insert into myclass values (&#x27;510&#x27;,NULL);ERROR 1048 (23000): Column &#x27;class_room&#x27; cannot be null\n\n而空字符串是可以被插入的，这里又一次说明了我们认为的空和NULL并不相同，空字符串不是NULL\nMariaDB [hello]&gt; insert into myclass values (&#x27;510&#x27;,&#x27;&#x27;);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from myclass;+------------+------------+| class_name | class_room |+------------+------------+| 510        |            |+------------+------------+1 row in set (0.000 sec)\n\n2.默认值default当我们注册某些网站的时候，一些信息不填，就会被系统设置为默认值。\n比如你不选择年龄的时候，系统可能就会显示你为0岁；其他用户看到你的个人主页上显示的0岁，就知道你并没有填写自己的真实年龄。（而前端开发的时候也可以将0认作没有填写，显示成”隐藏年龄“）\n再比如我们的网站上有一个用户积分的数值，当用户注册的时候，积分肯定是0（暂时不考虑新人送积分什么的操作），这时候就可以把积分那一列的默认值设置成0，在插入的时候就可以不显式插入这列的数据；\n在MySQL中，某一列设置了默认值后。在insert时候如果没有指定这一列的数据，那就会采用默认值。\ncreate table if not exists web_user(    name varchar(30) not null default &#x27;默认用户名&#x27;,    age tinyint not null default 0,    gender char(2) not null default &#x27;男&#x27; );\n\n创建完毕这个表，当我们查看表结构的时候，就能看到是否为空，以及默认直的相关属性\nMariaDB [hello]&gt; desc web_user;+--------+-------------+------+-----+-----------------+-------+| Field  | Type        | Null | Key | Default         | Extra |+--------+-------------+------+-----+-----------------+-------+| name   | varchar(30) | NO   |     | 默认用户名      |       || age    | tinyint(4)  | NO   |     | 0               |       || gender | char(2)     | NO   |     | 男              |       |+--------+-------------+------+-----+-----------------+-------+3 rows in set (0.004 sec)\n\n由于这个表里面的3个字段我们都设置了初始值，你甚至可以直接啥都不指定地插入一个数据；下方可以看到，所有列都被设置成了该列的初始值。\nMariaDB [hello]&gt; insert into web_user values ();Query OK, 1 row affected (0.001 sec)MariaDB [hello]&gt; select * from web_user;+-----------------+-----+--------+| name            | age | gender |+-----------------+-----+--------+| 默认用户名      |   0 | 男     |+-----------------+-----+--------+1 row in set (0.000 sec)\n\n当我们想不设置某一列的值的时候，默认值就能帮上忙。\n这里先给一个错误的演示，我们只在values里面设置了两个值，目的是让新插入的这个用户的性别采用默认值。但MySQL报错了，报错的信息提示是value的个数和列的数量不一致\nMariaDB [hello]&gt; insert into web_user values (&#x27;李华&#x27;,16);ERROR 1136 (21S01): Column count doesn&#x27;t match value count at row 1\n\n这是因为我们在插入的时候，没有显示的告诉MySQL我们这两个值到底是哪两列的值。李华是给name列还是给gender列？MySQL没有办法自主决定！所以干脆拒绝插入。\n所以，当我们想让某一列使用缺省值的时候，就需要告诉MySQL，我们当前指定的values到底是哪几列的数据\ninsert into web_user (name,age) values (&#x27;李华&#x27;,16);\n\n这样才能插入成功\nMariaDB [hello]&gt; insert into web_user (name,age) values (&#x27;李华&#x27;,16);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from web_user;+-----------------+-----+--------+| name            | age | gender |+-----------------+-----+--------+| 默认用户名      |   0 | 男     || 李华            |  16 | 男     |+-----------------+-----+--------+2 rows in set (0.001 sec)\n\n因为这里做了对列名的显示指定，所以顺序并不一定需要依照表中列名的顺序，比如下方我们反过来也是可以插入的。但并不建议这么做，在插入的时候的列名顺序应该和表中列顺序保持一致！\nMariaDB [hello]&gt; insert into web_user (age,name) values (18,&#x27;小李&#x27;);Query OK, 1 row affected (0.001 sec)MariaDB [hello]&gt; select * from web_user;+-----------------+-----+--------+| name            | age | gender |+-----------------+-----+--------+| 默认用户名      |   0 | 男     || 李华            |  16 | 男     || 小李            |  18 | 男     |+-----------------+-----+--------+3 rows in set (0.001 sec)\n\n如果想让age列采用初始值，那就是如下的插入；\nMariaDB [hello]&gt; insert into web_user (name,gender) values (&#x27;菲菲公主&#x27;,&#x27;女&#x27;);Query OK, 1 row affected (0.005 sec)\n\n2.1 默认值和NULL需要注意的是，默认值和NOT NULL并不是必须一起使用的\n\n当我们设置了默认值，但是没有设置NOT NULL，我们可以显式地插入NULL\n默认值也可以设置成NULL\n\ncreate table if not exists test_user(    name varchar(30) not null default &#x27;默认用户名&#x27;,    age tinyint not null default 0,    gender char(2) default null);\n\n使用如上sql创建表，数据库没有报错，即代表我们的语法是被支持的。因为性别并不需要参与运算，所以我们可以认为当性别列为空的时候，就是未选择性别的选项。不过，也可以通过空字符串作为默认值来解决这一问题，相比之下用空字符串更好，因为这样能保证这个字段的值始终是个字符串，而不需要对null进行特殊处理\n\ndefault null 和 not null不能一起使用，这是肯定的！\n3.列描述comment需要注意，在sqlite中是不支持comment的，不同的数据库对sql字段的支持会有些许的差距，请根据你使用的数据库为准。本文所述基于MySQL和MariaDB。\n所谓的列描述，就是对这列到底是干嘛的一个说明信息，相当于代码的注释。其本身没有任何含义；\n列注释的主要作用，就是让所有使用这个数据库，使用这张表的人都能理解这个字段的作用。其中还可以添加额外的注释说明，来让程序员统一在不同模块的上传代码中进行额外的处理。\n比如我们将第二点中出现过的用户表改成如下形式，每个字段都添加上注释\ncreate table if not exists web_user(    name varchar(30) not null default &#x27;默认用户名&#x27; comment &#x27;用户名&#x27;,    age tinyint not null default 0 comment &#x27;用户年龄&#x27;,    gender char(2) not null default &#x27;男&#x27; comment &#x27;用户性别&#x27; );\n\n当我们使用这个sql创建了这个表后，如果想查询字段的注释，可以用如下命令查看创建表时使用的命令（其中就包含了表的注释）\nSHOW CREATE TABLE web_user;\n\n显示如下\nMariaDB [hello]&gt; SHOW CREATE TABLE web_user;+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table    | Create Table                                                                                                                                                                                                                                                               |+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| web_user | CREATE TABLE `web_user` (  `name` varchar(30) NOT NULL DEFAULT &#x27;默认用户名&#x27; COMMENT &#x27;用户名&#x27;,  `age` tinyint(4) NOT NULL DEFAULT 0 COMMENT &#x27;用户年龄&#x27;,  `gender` char(2) NOT NULL DEFAULT &#x27;男&#x27; COMMENT &#x27;用户性别&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8                  |+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.000 sec)\n\n也可以用如下命令来展示所有列和列的属性，其中包括注释\nSHOW FULL COLUMNS FROM web_user;\n\nMariaDB [hello]&gt; SHOW FULL COLUMNS FROM web_user;+--------+-------------+-----------------+------+-----+-----------------+-------+---------------------------------+--------------+| Field  | Type        | Collation       | Null | Key | Default         | Extra | Privileges                      | Comment      |+--------+-------------+-----------------+------+-----+-----------------+-------+---------------------------------+--------------+| name   | varchar(30) | utf8_general_ci | NO   |     | 默认用户名      |       | select,insert,update,references | 用户名       || age    | tinyint(4)  | NULL            | NO   |     | 0               |       | select,insert,update,references | 用户年龄     || gender | char(2)     | utf8_general_ci | NO   |     | 男              |       | select,insert,update,references | 用户性别     |+--------+-------------+-----------------+------+-----+-----------------+-------+---------------------------------+--------------+3 rows in set (0.002 sec)\n\n需要注意，desc命令显示的结果中是不包含列注释的\nMariaDB [hello]&gt; desc web_user;+--------+-------------+------+-----+-----------------+-------+| Field  | Type        | Null | Key | Default         | Extra |+--------+-------------+------+-----+-----------------+-------+| name   | varchar(30) | NO   |     | 默认用户名      |       || age    | tinyint(4)  | NO   |     | 0               |       || gender | char(2)     | NO   |     | 男              |       |+--------+-------------+------+-----+-----------------+-------+3 rows in set (0.001 sec)\n\n\n4.zerofill4.1 测试结果先来用如下命令创建一个表\ncreate table if not exists test_int(\ta int not null,\tb int unsigned not null);\n\n创建完成后，我们查看创建这个表时使用的语句，会发现在int之后多了一个括号，里面跟了一个数字。\n我们知道在char和varchar里面，这个括号是用来限制字符串字符长度的，那么在整形这里的括号是干嘛的呢？\nMariaDB [hello]&gt; show create table test_int;+----------+------------------------------------------------------------------------------------------------------------------------+| Table    | Create Table                                                                                                           |+----------+------------------------------------------------------------------------------------------------------------------------+| test_int | CREATE TABLE `test_int` (  `a` int(11) NOT NULL,  `b` int(10) unsigned NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+----------+------------------------------------------------------------------------------------------------------------------------+1 row in set (0.001 sec)\n\n先往这个表内插入一个数据，并查询显示出来\nMariaDB [hello]&gt; insert into test_int values (3,1);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from test_int;+---+---+| a | b |+---+---+| 3 | 1 |+---+---+1 row in set (0.000 sec)\n\n如果我们把a列的属性进行修改为如下的字段类型\nalter table test_int change a a int(5) unsigned zerofill;\n\n再去查看创建表的命令，此时结果如下，a列已经被修改成了信的属性\nMariaDB [hello]&gt; alter table test_int change a a int(5) unsigned zerofill;Query OK, 1 row affected (0.005 sec)               Records: 1  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; show create table test_int;+----------+---------------------------------------------------------------------------------------------------------------------------------------------+| Table    | Create Table                                                                                                                                |+----------+---------------------------------------------------------------------------------------------------------------------------------------------+| test_int | CREATE TABLE `test_int` (  `a` int(5) unsigned zerofill DEFAULT NULL,  `b` int(10) unsigned NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+----------+---------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.000 sec)\n\n那么这个括号里面的数字，和zerofill有什么作用呢？\n再次查询此表，会发现刚刚插入的数据，a列的3变成了00003！\nMariaDB [hello]&gt; select * from test_int;+-------+---+| a     | b |+-------+---+| 00003 | 1 |+-------+---+1 row in set (0.000 sec)\n\n4.2 前补0此时这个属性的作用就很明确了，其用于给数字进行前补0；而5就是规定的前补0的长度，而不是数字的长度；当数字的位数小于5位，就会触发前补0；\n可以看到，即便表结构中出现了int(5)，我们依旧可以往这个表里面插入长度大于5位的数字\nMariaDB [hello]&gt; insert into test_int values (12345678,1);Query OK, 1 row affected (0.005 sec)\n\n所以这个括号并不是用来限制int的长度的，而是当一个数字小于5位的时候，会给这个数字前补0\nMariaDB [hello]&gt; insert into test_int values (18,3);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from test_int;+----------+---+| a        | b |+----------+---+|    00003 | 1 || 12345678 | 1 ||    00018 | 3 |+----------+---+3 rows in set (0.001 sec)\n\n如果再把int(5) zerofill改成更长的数值，前补0的长度就会变化\nalter table test_int change a a int(7) unsigned zerofill;\n\n效果如下，少于7位的数字都会前补0到七位\nMariaDB [hello]&gt; alter table test_int change a a int(7) unsigned zerofill;Query OK, 0 rows affected (0.007 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; select * from test_int;+----------+---+| a        | b |+----------+---+|  0000003 | 1 || 12345678 | 1 ||  0000018 | 3 |+----------+---+3 rows in set (0.001 sec)\n\n需要注意，int(n)的属性只有和zerofill一起使用，才会触发前补0的操作。这便能解释为何最初创建的表里面是int(11)，但数字并没有被前补0；\n而这里的前补0，只是一个在MySQL内部显示的优化，实际上存储的依旧是数字本身；比如我们在上表中查询3，是可以直接查出来的。\nMariaDB [hello]&gt; select * from test_int where a = 3;+---------+---+| a       | b |+---------+---+| 0000003 | 1 |+---------+---+1 row in set (0.001 sec)\n\n比如我要存储的数字都是5位的，设置了前补0，查询整表时看到的格式化输出的结果会比没有前补0的结果看上去舒服很多。\n4.3 为什么int是11，无符号是10？在前面查询默认的创建表i语句的时候，会发现MySQL系统默认给int了11位，无符号int是10位\n\n这是因为10位的长度已经能标识int范围内的所有值了，而有符号整数多了一位，是用来显示正负号的。\n5.主键primary key主键是用于约束字段里面的数据，不能重复，不能为空；一张表只有一个主键（或者没有），一般都是用整形作为主键。\n主键是用于确定表中每一条记录的唯一性的，其告知了使用者，要想往这个表中插入数据，就必须保证主键的值不冲突。\n5.1 主键的设计类型以一个用户系统为例\n\n我们可以把用户名设置为主键，当用户选择了一个已经存在的用户名时，拒绝此用户名并告知用户；\n我们可以使用另外一个无关的数字作为主键，比如QQ中就使用了QQ号来标识用户唯一性，并不要求用户的用户名不能相相同（现在绝大部分聊天软件都使用了这种方式，比如QQ和KOOK，微信虽然没有QQ那样的唯一标识，但后台肯定也是有主键作为唯一性标识的）、\n我们可以将多列组成复合主键\n\n5.2 删除和添加主键在创建表的时候，可以用两种方式来指定主键\n-- 方法1，在字段后指明create table test_pri_1(\tid int unsigned not null primary key,    name varchar(30) not null);-- 方法2，在表的最后指明create table test_pri_2(\tid int unsigned not null,    name varchar(30) not null,    primary key(id));\n\n二者都能执行成功。\n另外，主键本身就是不能为空的，所以我们定义主键列的时候可以不用写not null\nMariaDB [hello]&gt; create table test_pri_1(    -&gt; id int unsigned not null primary key,    -&gt;     name varchar(30) not null    -&gt; );Query OK, 0 rows affected (0.017 sec)MariaDB [hello]&gt; create table test_pri_2(    -&gt; id int unsigned not null,    -&gt;     name varchar(30) not null,    -&gt;     primary key(id)    -&gt; );Query OK, 0 rows affected (0.019 sec)\n\n而且表结构相同，在id列的Key处可以看到PRI，就是Primary的缩写，代表id列是主键\nMariaDB [hello]&gt; desc test_pri_1;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(30)      | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.001 sec)MariaDB [hello]&gt; desc test_pri_2;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(30)      | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.001 sec)\n\n如果是一个已经存在的表，我们也可以往里面追加主键或者删除主键\nalter table 表名 drop primary key;-- 用于删除主键列的主键属性，因为主键列只能有一个-- 注意，这个语句不会删除该列alter table 表名 add primary key(id);-- 给id列加上主键属性（但是ID列里面不能有重复值）\n\n测试一下，可以看到id列的PRI属性没有了\nMariaDB [hello]&gt; alter table test_pri_1 drop primary key;Query OK, 0 rows affected (0.010 sec)              Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; desc test_pri_1;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   |     | NULL    |       || name  | varchar(30)      | NO   |     | NULL    |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.002 sec)\n\n当我们往表里面插入数据的时候，如果想往主键列插入一个相同的记录，MySQL会拒绝插入\nMariaDB [hello]&gt; insert into test_pri_2  values (1,&#x27;李华&#x27;);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into test_pri_2  values (1,&#x27;李明&#x27;);ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;\n\n5.3 复合主键一张表只有一个主键，但是主键可以不止一列；\n以我自己写的活跃度统计机器人为例，机器人处在不同服务器中，会收到不同的服务器ID，和不同用户的操作；为了记录不同服务器的不同用户的活跃度情况，在用户统计表中，需要同时有服务器ID和用户ID；此时就会出现一个用户加入了两个服务器，而这两个服务器都使用了我这个机器人的情况。反馈到表中，就是一个用户ID出现了两次，但对应的服务器ID不同；\n在这种情形下，肯定是不能把用户ID或服务器ID单独设置成主键的。我们就可以把用户ID和服务器ID统一设置成符合主键；\n设置了复合主键后，我们可以出现相同的服务器ID，和相同的用户ID。但只能是某个服务器的某个用户，不能存在两条服务器ID和用户ID都相同的记录。这便是复合主键的作用！\ncreate table user(\tguild_id int unsigned comment &#x27;服务器ID&#x27;,\tuser_id int unsigned not null comment &#x27;用户ID&#x27;,\tscore tinyint unsigned not null default 0 comment &#x27;用户积分&#x27;,\tprimary key(guild_id, user_id) -- guild_id + user_id 为复合主键);\n\n此时查看表结构，会发现服务器id和用户id的两个键值，在Key里面都有PRI属性，即他们都是主键；\n而且，即便我们的guild_id没有指定not null，其的NULL属性依旧是NO。因为主键是不允许为NULL的！\nMariaDB [hello]&gt; create table user(    -&gt; guild_id int unsigned comment &#x27;服务器ID&#x27;,    -&gt; user_id int unsigned not null comment &#x27;用户ID&#x27;,    -&gt; score tinyint unsigned not null default 0 comment &#x27;用户积分&#x27;,    -&gt; primary key(guild_id, user_id) -- guild_id + user_id 为复合主键    -&gt; );Query OK, 0 rows affected (0.011 sec)MariaDB [hello]&gt; desc user;+----------+---------------------+------+-----+---------+-------+| Field    | Type                | Null | Key | Default | Extra |+----------+---------------------+------+-----+---------+-------+| guild_id | int(10) unsigned    | NO   | PRI | NULL    |       || user_id  | int(10) unsigned    | NO   | PRI | NULL    |       || score    | tinyint(3) unsigned | NO   |     | 0       |       |+----------+---------------------+------+-----+---------+-------+3 rows in set (0.003 sec)\n\n当我们插入时，服务器id和用户id可以在各自列中重复。\nMariaDB [hello]&gt; insert into user values (1,1,0);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; insert into user values (1,2,0);Query OK, 1 row affected (0.008 sec)MariaDB [hello]&gt; insert into user values (2,1,0);Query OK, 1 row affected (0.001 sec)\n\n但如果你想在已经有服务器id为1，用户id为1的记录的基础上再插入一条这样的记录，那就会报错拒绝插入\nMariaDB [hello]&gt; select * from user;+----------+---------+-------+| guild_id | user_id | score |+----------+---------+-------+|        1 |       1 |     0 ||        1 |       2 |     0 ||        2 |       1 |     0 |+----------+---------+-------+3 rows in set (0.000 sec)MariaDB [hello]&gt; insert into user values (1,1,10);ERROR 1062 (23000): Duplicate entry &#x27;1-1&#x27; for key &#x27;PRIMARY&#x27;\n\n6.自增auto_increment自增，人如其名，就是MySQL会自动帮我们往这个列添加数据。比如一个序号，新增一条记录就会将序号加一；自增属性只能添加给整形！\n自增的列必须是主键！\n6.1 使用自增的使用办法是在创建表的键值后添加这个约束\ncreate table test_pri_3(\tid int unsigned auto_increment,    name varchar(30) not null,    primary key(id));\n\n查看表结构，可以看到id列是主键，非空，且具有自增属性\nMariaDB [hello]&gt; desc test_pri_3;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(30)      | NO   |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.003 sec)\n\n由于自增的列必须是主键，所以我们不能将其和主键分开来使用；\n如果在设置自增的时候没有将这列同时设置为主键，那么创建表的时候就会报错\nMariaDB [hello]&gt; create table test_pri_4(    -&gt; id int unsigned auto_increment,    -&gt;     name varchar(30) not null    -&gt; );ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key\n\n设置了自增之后，我们同样可以显示的指定该列的值；也可以不指定，直接插入其他列的数据。MySQL会自动帮我们把当前记录+1。\nMariaDB [hello]&gt; insert into test_pri_3 values (1,&#x27;李华&#x27;);Query OK, 1 row affected (0.007 sec)MariaDB [hello]&gt; select * from test_pri_3;+----+--------+| id | name   |+----+--------+|  1 | 李华   |+----+--------+1 row in set (0.001 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27;小明&#x27;);Query OK, 1 row affected (0.001 sec)MariaDB [hello]&gt; select * from test_pri_3;+----+--------+| id | name   |+----+--------+|  1 | 李华   ||  2 | 小明   |+----+--------+2 rows in set (0.000 sec)\n\n多插入几条数据，可以看到id列都成功自增了\nMariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27;小明3&#x27;);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27;小明5&#x27;);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from test_pri_3;+----+---------+| id | name    |+----+---------+|  1 | 李华    ||  2 | 小明    ||  3 | 小明3   ||  4 | 小明5   |+----+---------+4 rows in set (0.000 sec)\n\n6.2 自增是怎么判断当前所处序号位置的？自增的长度是按最大的那个数字开始自增的？还是说有其他处理流程？\n先尝试往表里面主动插入一个1000为id的键值，然后再不指定id的情况下再插入两行记录\nMariaDB [hello]&gt; insert into test_pri_3 values (1000,&#x27;test&#x27;);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27;test1&#x27;);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27;test2&#x27;);Query OK, 1 row affected (0.001 sec)\n\n查询列表，会发现在这1000之后的的记录，全都是从1000开始增加的。\nMariaDB [hello]&gt; select * from test_pri_3;+------+---------+| id   | name    |+------+---------+|    1 | 李华    ||    2 | 小明    ||    3 | 小明3   ||    4 | 小明5   || 1000 | test    || 1001 | test1   || 1002 | test2   |+------+---------+7 rows in set (0.000 sec)\n\n莫非是依照最大的id来进行自增的吗？我们再来试试。\n先把最大id的记录删除，再插入一个新数据\nMariaDB [hello]&gt; delete from test_pri_3 where id = 1002;Query OK, 1 row affected (0.007 sec)MariaDB [hello]&gt; insert into test_pri_3 (name) values (&#x27;test3&#x27;);Query OK, 1 row affected (0.006 sec)\n\n再次查询，会发现自增的id是1003。可见其内部记录过一个id的最大值，是按内部一个额外的记录来进行自增的，而不是判断表中id列的最大值！\nMariaDB [hello]&gt; select * from test_pri_3;+------+---------+| id   | name    |+------+---------+|    1 | 李华    ||    2 | 小明    ||    3 | 小明3   ||    4 | 小明5   || 1000 | test    || 1001 | test1   || 1003 | test3   |+------+---------+7 rows in set (0.001 sec)\n\n那这个额外的记录在哪里呢？\nshow create table test_pri_3;\n\n使用如上命令查看创建表的sql语句，你会发现紧跟在表之后的，就有一个自增的字段AUTO_INCREMENT=1004\nMariaDB [hello]&gt; show create table test_pri_3;+------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table      | Create Table                                                                                                                                                                              |+------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| test_pri_3 | CREATE TABLE `test_pri_3` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(30) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1004 DEFAULT CHARSET=utf8 |+------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.000 sec)\n\n这就是MySQL中对自增字段当前值的定义，这里存放的就是下一个插入的记录，其id的自增值。每次插入一个信的记录，这里的自增值就会对应变换为下一个记录应该是多少的数值；\n举个例子，如果我们想让一个系统的ID从10001开始自增，那么我们就可以在创建了表之后，直接往表里面插入一个id为10000的记录。在这之后创建的其他记录，id就会从10001开始自增了！\n\n6.3 索引讲到这里，顺带一提MySQL中索引的概念\n索引： 在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构。它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。 \n索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。 数据库使用索引以找到特定值，然后顺指针找到包含该值的行。\n这样可以使对应于表的SQL语句执行得更快，可快速访问数据库表中的特定信息。\n索引本质上就是一个用空间换时间的套路。在当前多并发的业务中，执行速度远比占用内存、磁盘多少来的更重要！\n7.唯一键unique唯一键对字段的约束，那就是这一列的数据都不能出现相同的。\n看起来和主键有点相似，但实际上其是独立于主键之外的一种唯一性的约束。和主键的区别在于：唯一键可以为NULL\n要知道，一个表里面的主键只能设置一个。复合主键在某些时候并不能满足我们的需求。于是MySQL就在主键之外，额外提供了唯一键的约束，让我们可以给其他列设置唯一性。\n至于为什么要这么做？就好比一个免责声明：我这列的数据设置了唯一，那么就不可能接受两个相同的记录（比如用户表中两个人却有相同手机号，是不应该的）如果你的业务中出现了拒绝插入的报错，那么就应该去看业务处理代码中是哪里有BUG，而不应该怪罪MySQL没有维护唯一性或者拒绝记录的插入。\n7.1 单独唯一键假设我有一个平台，类似于qq一样使用了一个qq号作为用户的主键；但为了实名认证，我们又要求一个身份证只能注册一个账户。此时就无法用复合主键来解决这个问题，因为复合主键是允许其中某一列有重复的；而我们需要的是用户账户编号和用户身份证号都不能重复！\n\n同时，在用户的联系方式中，两个用户的电话号码、微信号也不应该出现相同，如果要添加电话号码的键值，也可以将其设置为unique！\n\n此时就可以将用户编号作为主键，用户身分证号设置unique作为唯一键；\ncreate table test_unique_1(\tno int unsigned not null primary key,\tname varchar(30) not null,    id_card varchar(30) not null unique );\n\n查看表结构，唯一键的列，Key的约束是UNI，即unique的缩写\nMariaDB [hello]&gt; desc test_unique_1;+---------+------------------+------+-----+---------+-------+| Field   | Type             | Null | Key | Default | Extra |+---------+------------------+------+-----+---------+-------+| no      | int(10) unsigned | NO   | PRI | NULL    |       || name    | varchar(30)      | NO   |     | NULL    |       || id_card | varchar(30)      | NO   | UNI | NULL    |       |+---------+------------------+------+-----+---------+-------+3 rows in set (0.001 sec)\n\n当我们往这个表中的主键列或者id_card列插入相同记录时，MySQL都会拒绝插入\nMariaDB [hello]&gt; insert into test_unique_1 values (1,&#x27;李华&#x27;,123456);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into test_unique_1 values (1,&#x27;李华&#x27;,1234567);ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;MariaDB [hello]&gt; insert into test_unique_1 values (3,&#x27;小明&#x27;,123456);ERROR 1062 (23000): Duplicate entry &#x27;123456&#x27; for key &#x27;id_card&#x27;\n\n7.2 复合唯一键唯一键也能设置多列，效果和复合主键相同；这里不再说明\ncreate table user(\tuser_no int unsigned primary key auto_increment comment &#x27;用户编号 主键&#x27;,\tguild_id int unsigned comment &#x27;服务器ID&#x27;,\tuser_id int unsigned not null comment &#x27;用户ID&#x27;,\tscore tinyint unsigned not null default 0 comment &#x27;用户积分&#x27;,\tunique(guild_id, user_id) -- guild_id + user_id 为复合唯一键);\n\n表中对guild_id和user_id的约束就变成了MUL，如下图所示；\n其中能观察到，guild_id因为没有设置not null，其NULL一栏为YES，代表这列可以为NULL（唯一键可以为NULL，主键不能）\n而MUL则代表目前允许多行在此列具有相同的值，但guild_id和user_id都相同的两行是不允许存在的\nMariaDB [hello]&gt; desc user;+----------+---------------------+------+-----+---------+----------------+| Field    | Type                | Null | Key | Default | Extra          |+----------+---------------------+------+-----+---------+----------------+| user_no  | int(10) unsigned    | NO   | PRI | NULL    | auto_increment || guild_id | int(10) unsigned    | YES  | MUL | NULL    |                || user_id  | int(10) unsigned    | NO   |     | NULL    |                || score    | tinyint(3) unsigned | NO   |     | 0       |                |+----------+---------------------+------+-----+---------+----------------+4 rows in set (0.001 sec)\n\n如下，最后的插入和第一次的插入中的guild_id和user_id相同，于是就出现了拒绝插入的报错\nMariaDB [hello]&gt; insert into user values (1,1,1,20);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into user values (2,1,2,21);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; insert into user values (3,2,3,22);Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; insert into user values (4,1,1,23);ERROR 1062 (23000): Duplicate entry &#x27;1-1&#x27; for key &#x27;guild_id&#x27;\n\n7.3 在MySQL中MUL、PRI和UNI是什么？从Mysql 5.7官网文档可知：\n\n如果键是PRI，则列是主键或多列主键中的列之一；\n如果键是UNI，则该列是唯一索引的第一列(唯一索引允许多个空值，但可以通过检查NULL字段来判断该列是否允许空)；\n如果键为MUL，则该列是非唯一索引的第一列，其中允许在列中多次出现给定值；\n\n8.外键foreign key8.1 说明外键是用来定义两张表中某些字段的关系，并来约束记录的；\n基础语法如下，在创建表的时候使用。需要设置外键的表是从表！\nforeign key (字段名) references 主表(列)\n\n比如下图中，学生表中每个学生的班级编号都对应了班级表中班级的id，此时我们就可以将班级表的id设置为学生表中class_id的外键；\n虽然我们可以将class表中的数据直接插入到学生表里面，但是这样并不合理。如果我们针对一个班级，或者针对一个学生的字段有非常多的话，将这两张表合起来是非常不方便的。因为同一个班级会有很多学生，合并表之后，就相当于同一个班级的学生，他们的班级列的信息全是相等的，这就存在了无意义的资源占用（冗余）。\n相比之下，分表了之后，再采用外键的方式来绑定两个字段，是更好的选择！\n\n在上图的情况中，myclass是主表，stu是一个从表；你也可以从大小规模的逻辑来理解，只有班级才能包含学生，学生不能包含班级，所以班级表更“大”，为主表，学生表为从表。\n插入数据的时候，需要先往主表插入，再往从表插入。先有班级，才能给这个班级添加学生\n建表语句如下，从表stu中添加了外键约束命令。\n-- 主表 班级create table myclass (\tid int primary key comment &#x27;班级号&#x27;,\tname varchar(30) not null comment &#x27;班级名&#x27;);-- 从表 学生create table stu (\tid int primary key,\tname varchar(30) not null comment &#x27;学生名&#x27;,\tclass_id int,\tforeign key (class_id) references myclass(id) -- 设置从表外键约束);\n\n8.2 基本测试创建好表之后，先来看看学生表i的属性，可以看到class_id表的key是一个MUL，和前面设置复合唯一键的时候相同。\nMariaDB [hello]&gt; desc stu;+----------+-------------+------+-----+---------+-------+| Field    | Type        | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id       | int(11)     | NO   | PRI | NULL    |       || name     | varchar(30) | NO   |     | NULL    |       || class_id | int(11)     | YES  | MUL | NULL    |       |+----------+-------------+------+-----+---------+-------+3 rows in set (0.001 sec)\n\n当我们尝试往学生表里面插入一个数据的时候，会报错\nMariaDB [hello]&gt; insert into stu values (1,&#x27;李华&#x27;,2);ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`hello`.`stu`, CONSTRAINT `stu_ibfk_1` FOREIGN KEY (`class_id`) REFERENCES `myclass` (`id`))\n\n这是因为你设置的这个记录中，学生的班级编号2压根在班级表里面不存在。一个不存在的班级怎么可以有学生呢？所以自然就拒绝了你的插入。\n所以，要想插入学生，我们需要保证这个学生的记录所在班级，是存在于班级表里面的！这样就实现了学生和班级N对1的绑定。\nMariaDB [hello]&gt; insert into myclass values (1,&#x27;少华班&#x27;);Query OK, 1 row affected (0.002 sec)MariaDB [hello]&gt; insert into stu values (1,&#x27;李华&#x27;,1);Query OK, 1 row affected (0.005 sec)MariaDB [hello]&gt; select * from myclass;+----+-----------+| id | name      |+----+-----------+|  1 | 少华班    |+----+-----------+1 row in set (0.001 sec)MariaDB [hello]&gt; select * from stu;+----+--------+----------+| id | name   | class_id |+----+--------+----------+|  1 | 李华   |        1 |+----+--------+----------+1 row in set (0.000 sec)\n\n这里我又多插入了几个数据\nMariaDB [hello]&gt; select * from stu;+----+-----------+----------+| id | name      | class_id |+----+-----------+----------+|  1 | 李华      |        1 ||  2 | 小明      |        1 ||  3 | 小流      |        1 ||  4 | 小流2     |        2 ||  5 | 猪猪侠    |        2 ||  6 | 苗条俊    |        2 |+----+-----------+----------+6 rows in set (0.000 sec)MariaDB [hello]&gt; select * from myclass;+----+-----------+| id | name      |+----+-----------+|  1 | 少华班    ||  2 | 你好班    |+----+-----------+2 rows in set (0.000 sec)\n\n此时还有另外一个问题：如果这个班级有学生，我们可以把这个班级删掉吗？\n考虑看来，肯定是不行的：既然没有这个班级，你不能插入对应的学生。那么这个班级有学生的时候，你也不应该把班级删除。二者是相互的逻辑；在MySQL里面也是如此，当一个班级有对应的学生的时候，是不允许删除的。\nMariaDB [hello]&gt; delete from myclass where id = 1;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`hello`.`stu`, CONSTRAINT `stu_ibfk_1` FOREIGN KEY (`class_id`) REFERENCES `myclass` (`id`))\n\n只有当这个班级没有学生了，才能从班级表中被删除！\nMariaDB [hello]&gt; delete from stu where class_id = 2;Query OK, 3 rows affected (0.005 sec)MariaDB [hello]&gt; delete from myclass where id = 2;Query OK, 1 row affected (0.006 sec)MariaDB [hello]&gt; \n\n更新班级id同样是不允许的，因为在学生表中有学生绑定了这个班级。MySQL并不能做到帮我们直接更新所有学生的班级号。\nMariaDB [hello]&gt; update  myclass set id = 3 where name = &#x27;你好班&#x27;; ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`hello`.`stu`, CONSTRAINT `stu_ibfk_1` FOREIGN KEY (`class_id`) REFERENCES `myclass` (`id`))\n\n8.3 外键约束概念在上面的情况中，我们完全可以建立两个没有外键关系的独立表，在代码层进行两者关系的维护。\n但是这样，这两个表的操作依旧是独立的，MySQL是不知道这两个表之间有毛线关联的；此时你就可以往不存在的班级里面插学生，把还有学生的班级删掉，最终就乱了套了；\n\n自己维护：两个表的信息有关联\n加上外键：MySQL直接进行约束\n\n两者合一，才是外键的完全体！\n\n如果只在上层代码中约束，特别是多端协作公用数据库的时候，极有可能因为双方程序猿沟通不到位而导致数据库中产生无效记录。外键的存在帮我们避免了这个在协作中的沟通问题。\n\n所以我们才需要在MySQL中，将这两个表之间定义外键的约束，让MySQL协助我们维护两张表中的数据关系。\n注意：虽然此时MySQL会约束我们的操作，但实际上的业务流程还是需要程序袁在代码中处理。比如不要往MySQL中插入班级不存在的学生（MySQL只会拒绝插入，并不能帮你把班级给修正）\n8.4 alter添加外键约束给定如下两张表\n-- 所有产品的总表create table Product(    maker char(2),    model integer unsigned primary key,    type varchar(10) NOT NULL);-- 台式电脑的表create table PC(    model integer unsigned primary key,    speed float(4,2),    ram integer unsigned,    hd integer unsigned,    price integer unsigned);\n\n很明显，PC和Product表中都有一个model字段，这两个字段就构成了外键约束关系。且产品总表Product在规模上大于台式电脑表PC，所以Product表是主表，PC表是从表，我们应该给PC表上外键约束，为了防止数据一致性出现错误。\n\n比如PC表中出现了一个不存在于Product表中的电脑产品，肯定是不对劲的\n\n使用alter table命令，在表已经创建之后修改它的外键约束。\nALTER TABLE PCADD CONSTRAINT cpc -- 外键约束的名字为cpcFOREIGN KEY (model) REFERENCES Product(model);\n\n\n如下，操作成功，PC表里面的所有数据都符合这个外键约束，没有出错。\nMariaDB [products]&gt; ALTER TABLE PC    -&gt; ADD CONSTRAINT cpc -- 外键约束的名字为cpc    -&gt; FOREIGN KEY (model) REFERENCES Product(model);Query OK, 13 rows affected (0.019 sec)             Records: 13  Duplicates: 0  Warnings: 0\n\n此时往PC里面插入一个Product中不存在的额外记录\nINSERT INTO PC (model, speed, ram, hd, price) VALUES (1050, 2.66, 1024, 250, 2114);\n\n如下所示，无法插入成功。\nMariaDB [products]&gt; INSERT INTO PC (model, speed, ram, hd, price) VALUES    -&gt; (1050, 2.66, 1024, 250, 2114);ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`products`.`PC`, CONSTRAINT `cpc` FOREIGN KEY (`model`) REFERENCES `Product` (`model`))\n\n删除外键约束使用如下命令，从PC表中删除外键约束cpc\nALTER TABLE PCDROP FOREIGN KEY cpc;\n\n删除了之后，我们再次尝试往PC里面插入一个Product中不存在的额外的记录\nINSERT INTO PC (model, speed, ram, hd, price) VALUES (1050, 2.66, 1024, 250, 2114);\n\n这一次插入就成功了\nMariaDB [products]&gt; INSERT INTO PC (model, speed, ram, hd, price)     -&gt; VALUES (1050, 2.66, 1024, 250, 2114);Query OK, 1 row affected (0.002 sec)\n\n给已有数据冲突的表添加外键如果我们尝试给两个外键存在冲突的表添加上外键会如何？\nALTER TABLE PCADD CONSTRAINT cpc -- 外键约束的名字为cpcFOREIGN KEY (model) REFERENCES Product(model);\n\nmysql报出警告，不允许插入，报错的意思是外键检查失败，符合预期！\nMariaDB [products]&gt; ALTER TABLE PC    -&gt; ADD CONSTRAINT cpc -- 外键约束的名字为cpc    -&gt; FOREIGN KEY (model) REFERENCES Product(model);ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`products`.`#sql-alter-42184-25`, CONSTRAINT `cpc` FOREIGN KEY (`model`) REFERENCES `Product` (`model`))\n\n9.数据检查Check前面提到的都是mysql给我们提供的“固定方式”的约束类型，而check则可以由用户来自主选择约束的条件，即对插入表的数据进行有效性检查。\n\n某些数据是否大于0？\n某些数据是否在某个范围内？\n某些数据是否符合某个条件？\n\n9.1 数据范围检查给定如下表，这是一个笔记本的表，内部包含了一台笔记本的一些基本信息。\ncreate table Laptop(    model integer unsigned primary key,    speed float(4,2),    ram integer unsigned,    hd integer unsigned,    screen float(4,2),    price integer unsigned);\n\n我们需要检查的是笔记本的屏幕大小screen是否在[13,22]之间，如果不在，则代表有问题，不是我们需要售卖的笔记本。\n对应的约束条件如下，通过AND链接不同条件，并用括号将完整的判断条件包括起来。\nALTER TABLE LaptopADD CONSTRAINT con_screenCHECK (screen &gt;= 13 AND screen &lt;= 22);\n\n添加该约束条件后，尝试插入一个屏幕大小为25寸的笔记本，数据库拒绝插入。\nMariaDB [products]&gt; INSERT INTO Laptop (model, speed, ram, hd, screen, price)     -&gt; VALUES (2050, 2, 2048, 240, 25, 3673);ERROR 4025 (23000): CONSTRAINT `con_screen` failed for `products`.`Laptop`\n\n9.2 数据是否在给定选项中给定如下表，希望printer的type只能是laser或者ink-jet其中一种\ncreate table Printer(    model integer unsigned primary key,    color char(6) NOT NULL,    type varchar(10) NOT NULL,    price integer unsigned);\n\n因为可选项只有两个，可以直接用or来链接两个相等判断，但更好的办法是通过in来判断type是否符合条件。\nALTER TABLE PrinterADD CONSTRAINT con_typeCHECK (type in (&#x27;laser&#x27;,&#x27;ink-jet&#x27;));\n\n执行效果如下，已有数据符合该条件\nMariaDB [products]&gt; ALTER TABLE Printer    -&gt; ADD CONSTRAINT con_type    -&gt; CHECK (type in (&#x27;laser&#x27;,&#x27;ink-jet&#x27;));Query OK, 7 rows affected (0.021 sec)Records: 7  Duplicates: 0  Warnings: 0\n\n尝试插入非法数据\ninsert into Printer value (3050,&#x27;black&#x27;,&#x27;test&#x27;,1000);\n\n数据库拒绝插入\nMariaDB [products]&gt; insert into Printer value (3050,&#x27;black&#x27;,&#x27;test&#x27;,1000);ERROR 4025 (23000): CONSTRAINT `con_type` failed for `products`.`Printer`\n\n9.3 多列数据判断create table PC(    model integer unsigned primary key,    speed float(4,2),    ram integer unsigned,    hd integer unsigned,    price integer unsigned);\n\n给定PC表，要求硬盘容量hd小于100的电脑价格price不能超过600。\n直接用AND链接这两个条件是不行的，会变成只允许hd小于100且价格不超过600的PC插入。\n这次的条件需要进行逻辑修改：\n\nhd小于100且价格大于600的PC拒绝插入\n那么就需要一个表达式，让上述条件时为false\nhd大于100的电脑，价格随便（hd&gt;&#x3D;100)\nhd小于100的电脑，价格必须小于100（price&lt;&#x3D;600）\n用or链接\n\n\n\n对应表达式如下\nALTER TABLE PCADD CONSTRAINT con_price CHECK (hd &gt;= 100 OR price &lt;= 600);\n\n目标达成！\nMariaDB [products]&gt; ALTER TABLE PC    -&gt; ADD CONSTRAINT con_price CHECK (hd &gt;= 100 OR price &lt;= 600);Query OK, 13 rows affected (0.013 sec)Records: 13  Duplicates: 0  Warnings: 0\n\n尝试更新一个记录，将硬盘容量为80的，价格改成700。数据库拒绝此更新。\nMariaDB [products]&gt; UPDATE PC SET price = 700 WHERE model = 1013;ERROR 4025 (23000): CONSTRAINT `con_price` failed for `products`.`PC`\n\n插入一个正常记录，可以插入（这里先操作Product表，是因为之前设置了Product和PC的外键约束）\nMariaDB [products]&gt; INSERT INTO Product values (&#x27;tt&#x27;,1014,&#x27;PC&#x27;);Query OK, 1 row affected (0.002 sec)MariaDB [products]&gt; INSERT INTO PC (model, speed, ram, hd, price) VALUES (1014, 3.2, 8, 120, 700);Query OK, 1 row affected (0.002 sec)\nThe end基础的约束操作就是这些了，有其他会用到的，日后再新增！\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【树莓派开发】树莓派安装vim编辑器（附带排错流程）","url":"/posts/919850587/","content":"\n\n前言Linux自带的编辑器有nano和vi，但vi编辑器使用起来很不方便。\n我们要先在树莓派上下载vim编辑器，它是vi编辑器的升级版本，使用更加人性化\n\n但实际上安装vim编辑器并没有网上写的那么简单，在安装过程中出现了种种问题😭\n\n1.用putty软件链接树莓派Putty软件想必把玩树莓派的你应该是很熟悉的。\n输入ip后即可链接到你的树莓派，方便我们进行后续的操作\n\n2.下载vim首先更新索引源\nsudo apt-get update \n\n安装vim编辑器\nsudo apt-get install vim\n\n2.1错误：404无法下载安装过程中可能会有错误提示，比如我这里就显示无法连接到服务器404，且软件包下载失败\n\n\n解决方法参考这篇博客👉传送门1\n\n因为树莓派默认的软件源是国外的，国内可能链接不少，所以我们要把下载源修改为国内清华的\n需要修改两个文件来进行这个操作\nsudo nano /etc/apt/sources.list\n\n在句首加上#注释掉第一行的语句后，在后面加上下面这两行语句\n注意：这里不能复制粘贴，老老实实敲吧😥\ndeb空格http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/空格stretch空格main空格contrib空格non-free空格rpideb-src空格http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/空格stretch空格main空格contrib空格non-free空格rpi\n\n\n编辑好后，按CTRL+X保存，再按y确认，最后按回车回到命令行\n\n\n再运行下面这条指令，打开另外一个文件\nsudo nano /etc/apt/sources.list.d/raspi.list\n\n依旧要#注释掉第一行的语句，在末尾加上 上面的两个deb语句\ndeb空格http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/空格stretch空格main空格contrib空格non-free空格rpideb-src空格http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/空格stretch空格main空格contrib空格non-free空格rpi\n\n编辑好后，按CTRL+X保存，再按y确认，最后按回车回到命令行\n\n两个文件都编辑完后，使用sudo apt-get update查看有没有报错，如果有什么奇怪的报错，建议回去检查一下是不是写错了。\n我这里是这样的情况，实际上它已经搞定了\n\n这时候就可以再次使用下面的语句安装vim了\nsudo apt-get install vim\n\n2.2错误：下列软件包有未满足的依赖关系但很快我就出现了第二个问题👇\n下列软件包有未满足的依赖关系： vim : 依赖: vim-common (= 2:8.0.1453-1ubuntu1) 但是 2:8.0.1453-1ubuntu1.4 正要被安装E: 无法修正\n\n这是因为我们第一次没有正常下载vim的时候，留下了一个旧版本的安装包\n\n解决方法参考这篇博客👉传送门2\n\n依次运行下面的语句，卸载vim-common\nsudo apt-get purge vim-commonsudo apt-get updatesudo apt-get upgrade\n\n\n完成上述操作后，再次尝试安装vim\nsudo apt-get install vim\n\n这一次我才成功把vim安装下来\n\n\n3.查看vim是否安装成功用下面这个最简单的方法查看vim有没有安装成功\nvim test.txt\n\n如果安装失败，会出现这个报错。尝试跟着上面的步骤再走一遍，如果还不行我也不知道咋办😂\n-bash: vim: 未找到命令\n\n出现这个界面就代表安装完毕了，可以输入:q退出\n\n先来配置一下vim编辑器\nsudo nano /etc/vim/vimrc\n\n在打开的文件中，用方向键⬇来到最后，输入下面的三句话（可以不加注释）\nset nu   #显示行号syntax on   #语法高亮set tabstop=4 # tab退四格,默认是8格set softtabstop=4  set shiftwidth=4  #设置缩进的空格数set autoindent #每行的缩进值与上一行相等\n\n4.vim的基本操作前人栽树，后人乘凉\n\n基本操作参考这篇博客👉博客园、\n\n其实只是我懒，不想写而已😥\n5.用vim编写一个C语言代码到这里，你的vim就基本配置完毕啦！让我们来试试用它写一个代码\nvim test.c\n\n这个会在当前目录下创建一个test.c文件，我们来一个最简单的printf代码\n\n编辑完毕后，按ESC退出编辑状态，回到初始模式\n\n输入:wq保存并退出当前文件\n\nls之后可以看到，已经多出来了一个test.c的文件，后面的操作就是gcc指令了\n\ngcc test.c -o TEST\n\n再次ls可以看到多出了一个可执行文件TEST，执行该文件，程序成功运行\n\n结语到这里，咱们的vim编辑器的初始学习就结束啦！后续进阶的指令学习，大家可以看第4点中博主的讲解偶！\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【MySQL】基础命令操作","url":"/posts/2109090510/","content":"mysql的基础命令\n\n\n本文演示所用mariadb版本\nmysql  Ver 15.1 Distrib 10.3.28-MariaDB, for Linux (x86_64) using readline 5.1\n\nSQL语句的分类学习MySQL之前，我们先了解一下MySQL中SQL的分类\n\nDDL【data definition language】 数据定义语言，用来维护存储数据的结构。代表指令: create, drop, alter \nDML【data manipulation language】 数据操纵语言，用来对数据进行操作。代表指令： insert，delete，update \nDML中又单独分了一个DQL，数据查询语言，代表指令： select \n\n\nDCL【Data Control Language】 数据控制语言，主要负责权限管理和事务。 代表指令： grant，revoke，commit\n\n0.连接mysql默认情况下，我们的mysql没有密码，直接使用如下命令，就能链接上mysql\nmysql -uroot\n\nmysql数据库文件路径\n/var/lib/mysql\n\nmysql的语句是大小写不敏感的，大小写都可以。\n如果你的MySQL有密码，那就是用如下命令进入MySQL命令行\nmysql -uroot -p123456 # 示例mysql -u用户名 -p密码  # 基本操作\n\n0.1 查看有谁连接了show processlist;\n\n该命令可以查看当前有谁连接了MySQL服务，所在数据库是什么，正在执行的cmd是什么\n\n0.2 查看支持的存储引擎mysql支持多种存储引擎\n\n存储引擎是：数据库管理系统如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。\n\n每个引擎各有其优势。可以用下面的语句查询当前支持的引擎\nshow engines;\n\n\n1.数据库1.1 创建create database 数据库名字;create database if not exists 数据库名字; # 如果不存在才创建create database hello;\n\n上面的命令创建了一个名为hello的数据库。对于mysql服务端而言，其实际上是在数据文件路径中，帮我们创建了一个对应的文件夹\n\n如果是mysql5.7，在创建语句之前新增一个show，可以看到当前执行语句的详细信息。我当前使用的是高版本的mariadb，不支持这个操作\nshow create database hello;\n\n创建数据库或者表的时候，我们还可以给名称带上如下符号作为分割符\ncreate database `数据库名称`;\n\nMariaDB [(none)]&gt; create database `test2`;Query OK, 1 row affected (0.001 sec)\n\n带上该符号后，可以用于区分你的表名和数据库的内置语句。建议创建、删除操作的时候，都给名字带上这个符号。\n当然，创建的数据库、表名最好不要和mysql内置语句冲突，这和写代码的时候不要用编程语言的关键字&#x2F;库函数名来命名变量一样。\n1.2 查看已有show databases;\n\n查看当前已有数据库\n+--------------------+| Database           |+--------------------+| hello              || information_schema || mysql              || performance_schema |+--------------------+4 rows in set (0.001 sec)\n\n1.3 进入进入这个数据库\nuse hello;\n\n1.4 删除drop database [if exists] 名字;\n\n如下，我先是创建了一个test1数据库\nMariaDB [(none)]&gt; create database test1;Query OK, 1 row affected (0.001 sec)MariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| hello              || information_schema || mysql              || performance_schema || test1              |+--------------------+5 rows in set (0.000 sec)\n\n用下面这个命令删除该数据库\ndrop database test1;\n\n成功删除\nMariaDB [(none)]&gt; drop database test1;Query OK, 0 rows affected (0.035 sec)MariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| hello              || information_schema || mysql              || performance_schema |+--------------------+4 rows in set (0.001 sec)\n\n数据文件路径中，test1文件夹也被对应删除\n\n1.5 字符集和校验规则字符集会有自己对应的校验规则\n\n字符集用于将数据以特定编码存入数据库\n校验规则用于取数据时对数据进行校验\n\n修改字符集的时候，mysql会为我们自动指定对应的校验规则\n1.5.1 字符集一个数据被存放的时候，是会有其所用的编码的。编码不相同，会导致数据在不同软件中显示出不同的结果。\n\n比如 我们使用VS写的C语言代码，文件内的中文注释放入devc++之中，有可能会乱码，这就是字符编码不匹配的原因\n\nshow variables like 语句可以查看mysql的内置变量，其中如下变量就是数据库字符集的编码格式\nshow variables like &#x27;character_set_database&#x27;;\n\n可以看到，为utf-8\n+------------------------+-------+| Variable_name          | Value |+------------------------+-------+| character_set_database | utf8  |+------------------------+-------+1 row in set (0.002 sec)\n\n在配置mariadb的时候，就已经修改过了配置文件中数据库的编码规则，所以所有相关字符集编码都是utf-8\nshow variables like &#x27;character_set_%&#x27;;\n\nMariaDB [(none)]&gt; show variables like &#x27;character_set_%&#x27;;+--------------------------+------------------------------+| Variable_name            | Value                        |+--------------------------+------------------------------+| character_set_client     | utf8                         || character_set_connection | utf8                         || character_set_database   | utf8                         || character_set_filesystem | binary                       || character_set_results    | utf8                         || character_set_server     | utf8                         || character_set_system     | utf8                         || character_sets_dir       | /usr/share/mariadb/charsets/ |+--------------------------+------------------------------+8 rows in set (0.002 sec)\n\n使用如下命令可以查看数据库支持的所有编码\nshow charset;\n\nMariaDB [(none)]&gt; show charset;+----------+-----------------------------+---------------------+--------+| Charset  | Description                 | Default collation   | Maxlen |+----------+-----------------------------+---------------------+--------+| big5     | Big5 Traditional Chinese    | big5_chinese_ci     |      2 || dec8     | DEC West European           | dec8_swedish_ci     |      1 || cp850    | DOS West European           | cp850_general_ci    |      1 || hp8      | HP West European            | hp8_english_ci      |      1 || koi8r    | KOI8-R Relcom Russian       | koi8r_general_ci    |      1 || latin1   | cp1252 West European        | latin1_swedish_ci   |      1 || latin2   | ISO 8859-2 Central European | latin2_general_ci   |      1 || swe7     | 7bit Swedish                | swe7_swedish_ci     |      1 || ascii    | US ASCII                    | ascii_general_ci    |      1 || ujis     | EUC-JP Japanese             | ujis_japanese_ci    |      3 || sjis     | Shift-JIS Japanese          | sjis_japanese_ci    |      2 || hebrew   | ISO 8859-8 Hebrew           | hebrew_general_ci   |      1 || tis620   | TIS620 Thai                 | tis620_thai_ci      |      1 || euckr    | EUC-KR Korean               | euckr_korean_ci     |      2 || koi8u    | KOI8-U Ukrainian            | koi8u_general_ci    |      1 || gb2312   | GB2312 Simplified Chinese   | gb2312_chinese_ci   |      2 || greek    | ISO 8859-7 Greek            | greek_general_ci    |      1 || cp1250   | Windows Central European    | cp1250_general_ci   |      1 || gbk      | GBK Simplified Chinese      | gbk_chinese_ci      |      2 || latin5   | ISO 8859-9 Turkish          | latin5_turkish_ci   |      1 || armscii8 | ARMSCII-8 Armenian          | armscii8_general_ci |      1 || utf8     | UTF-8 Unicode               | utf8_general_ci     |      3 || ucs2     | UCS-2 Unicode               | ucs2_general_ci     |      2 || cp866    | DOS Russian                 | cp866_general_ci    |      1 || keybcs2  | DOS Kamenicky Czech-Slovak  | keybcs2_general_ci  |      1 || macce    | Mac Central European        | macce_general_ci    |      1 || macroman | Mac West European           | macroman_general_ci |      1 || cp852    | DOS Central European        | cp852_general_ci    |      1 || latin7   | ISO 8859-13 Baltic          | latin7_general_ci   |      1 || utf8mb4  | UTF-8 Unicode               | utf8mb4_general_ci  |      4 || cp1251   | Windows Cyrillic            | cp1251_general_ci   |      1 || utf16    | UTF-16 Unicode              | utf16_general_ci    |      4 || utf16le  | UTF-16LE Unicode            | utf16le_general_ci  |      4 || cp1256   | Windows Arabic              | cp1256_general_ci   |      1 || cp1257   | Windows Baltic              | cp1257_general_ci   |      1 || utf32    | UTF-32 Unicode              | utf32_general_ci    |      4 || binary   | Binary pseudo charset       | binary              |      1 || geostd8  | GEOSTD8 Georgian            | geostd8_general_ci  |      1 || cp932    | SJIS for Windows Japanese   | cp932_japanese_ci   |      2 || eucjpms  | UJIS for Windows Japanese   | eucjpms_japanese_ci |      3 |+----------+-----------------------------+---------------------+--------+40 rows in set (0.001 sec)\n\n1.5.2 校验规则show variables like &#x27;collation_%&#x27;;\n\n如下可以看到，当前的校验规则都是utf-8相关的\nMariaDB [(none)]&gt; show variables like &#x27;collation_%&#x27;;+----------------------+-----------------+| Variable_name        | Value           |+----------------------+-----------------+| collation_connection | utf8_general_ci || collation_database   | utf8_general_ci || collation_server     | utf8_general_ci |+----------------------+-----------------+3 rows in set (0.001 sec)\n\n查看系统中所有校验集\nshow collation;\n\n结果很长，就不全贴出来了。能看到每一个编码集都对应了一个字符集\n\n1.5.3 创建库时指定CREATE DATABASE [IF NOT EXISTS] db_name [create_specification [,create_specification] ...]create_specification:    [DEFAULT] CHARACTER SET charset_name    [DEFAULT] COLLATE collation_name\n\n其中[]代表是可选项\n\nCHARACTER SET  指定数据库采用的字符集 \nCOLLATE  指定数据库字符集的校验规则\n\n如果在创建数据库时没有指定字符集和校验规则，则会采用数据库默认的。\n在数据库的文件夹中，有一个db.opt文件，其中就包含了当前数据库使用的字符集和校验规则\n[root@1c2261732150:/var/lib/mysql]# ls hellodb.opt  stu_test.frm  stu_test.ibd[root@1c2261732150:/var/lib/mysql]# cat hello/db.optdefault-character-set=utf8default-collation=utf8_general_ci\n\n如果在创建的时候指明字符集编码\ncreate database `test1` character set gbk; create database `test1` charset=gbk; # 两种写法相同 \n\n查看db.opt，可以看到系统自动指定了gbk字符集对应的校验和\n[root@1c2261732150:/var/lib/mysql]# ls test1db.opt[root@1c2261732150:/var/lib/mysql]# cat test1/db.optdefault-character-set=gbkdefault-collation=gbk_chinese_ci\n\n同时指定字符集和编码\ncreate database `test2` charset=utf8 collate utf8_bin;\n\n执行成功后，查看本地文件\n[root@1c2261732150:/var/lib/mysql]# cat test2/db.optdefault-character-set=utf8default-collation=utf8_bin\n\n成功设置了字符集和编码规则\n\n虽然在创建的时候可以这么做，但我们保持默认配置的utf8即可\n1.5.4 校验的影响通过指定不同的编码，我创建了两个校验规则不同的数据库\nMariaDB [(none)]&gt; create database test_ci charset=utf8;Query OK, 1 row affected (0.001 sec)MariaDB [(none)]&gt; create database test_bin charset=utf8 collate utf8_bin;Query OK, 1 row affected (0.000 sec)\n\n其中一个的校验规则是utf8_general_ci，另外一个是utf8_bin\n[root@1c2261732150:/var/lib/mysql]# cat test_bin/db.optdefault-character-set=utf8default-collation=utf8_bin[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=utf8default-collation=utf8_general_ci\n\nutf8_bin先进入test_bin数据库\nuse test_bin;\n\n创建一个student表，只有一个字符串类型的name字段\ncreate table student(name varchar(30));\n\n插入如下数据\nMariaDB [test_bin]&gt; insert into student value (&#x27;a&#x27;);Query OK, 1 row affected (0.042 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;A&#x27;);Query OK, 1 row affected (0.008 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;b&#x27;);Query OK, 1 row affected (0.003 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;B&#x27;);Query OK, 1 row affected (0.004 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;c&#x27;);Query OK, 1 row affected (0.009 sec)MariaDB [test_bin]&gt; insert into student value (&#x27;C&#x27;);Query OK, 1 row affected (0.007 sec)\n\n查看已有数据，分别是大小写的abc\nMariaDB [test_bin]&gt; select * from  student;+------+| name |+------+| a    || A    || b    || B    || c    || C    |+------+6 rows in set (0.001 sec)\n\n查询数据，可以看到，返回的结果是只有小写a的\nMariaDB [test_bin]&gt; select * from student where name=&#x27;a&#x27;;+------+| name |+------+| a    |+------+1 row in set (0.001 sec)\n\n执行排序（升序）后输出，得到如下结果。我们知道，小写字母的ASCII是在大写字母的之后的，所以这个排序结果是正确的。\nMariaDB [test_bin]&gt; select * from student order by name;+------+| name |+------+| A    || B    || C    || a    || b    || c    |+------+6 rows in set (0.001 sec)\n\nutf8_general_ciuse test_ci;\n\n在这个数据库中进行相同的插入工作，创建表，插入大小写abc（命令同上不再重复）\nMariaDB [test_ci]&gt; select * from  student;+------+| name |+------+| a    || A    || b    || B    || c    || C    |+------+6 rows in set (0.000 sec)\n\n执行查询语句，发现当我们查询小a的时候，同时返回了A和a的结果\nMariaDB [test_ci]&gt; select * from student where name=&#x27;a&#x27;;+------+| name |+------+| a    || A    |+------+2 rows in set (0.001 sec)\n\n排序的时候，大小a没有按ASCII码顺序排，而是放到了一起\nMariaDB [test_ci]&gt; select * from student order by name;+------+| name |+------+| a    || A    || b    || B    || c    || C    |+------+6 rows in set (0.001 sec)\n\n结论\nutf8_bin：查询的时候区分大小写\nutf8_general_ci：查询时忽略大小写\n\n在实际场景中，我们就可以根据需求，选择这两个校验规则中的其一作为我们数据库的校验规则。\n这两个只是众多校验规则之一，更多编码的区别，还得等后续慢慢探寻。在一般场景中，使用utf8是完全足够的。\n1.6 修改alter database 数据库名 [create_specification [,create_specification] ...];\n\n一般情况下，我们修改的是数据库的字符集和校验规则。\n示例如下，修改数据库test_ci的字符集为gbk\nMariaDB [test_ci]&gt; alter database test_ci charset=gbk;Query OK, 1 row affected (0.006 sec)\n\n修改后查看配置文件，字符集和校验规则确实变化了（系统自动查找对应的校验规则）\n[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=utf8default-collation=utf8_general_ci[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=gbkdefault-collation=gbk_chinese_ci\n\n也可以同时修改校验规则，这里和新建数据库时的操作是一样的\nalter database test_ci charset=utf8 collate utf8_bin;\n\n[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=gbkdefault-collation=gbk_chinese_ci[root@1c2261732150:/var/lib/mysql]# cat test_ci/db.optdefault-character-set=utf8default-collation=utf8_bin\n\n1.7 备份数据库1.7.1 备份一个数据库如下操作是在linux命令行中执行的\nmysqldump -P3306 -u root -p 密码 -B 数据库名 &gt; 数据库备份存储的文件路径\n\n示例\nmysqldump -P3306 -u root -B hello &gt; hello.bak.sql\n\n这会在当前路径中出现了一个sql文件，其内容如下。\n-- MySQL dump 10.19  Distrib 10.3.28-MariaDB, for Linux (x86_64)---- Host: localhost    Database: hello-- -------------------------------------------------------- Server version       10.3.28-MariaDB/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;/*!40101 SET NAMES utf8 */;/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;---- Current Database: `hello`--CREATE DATABASE /*!32312 IF NOT EXISTS*/ `hello` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `hello`;---- Table structure for table `stu_test`--DROP TABLE IF EXISTS `stu_test`;/*!40101 SET @saved_cs_client     = @@character_set_client */;/*!40101 SET character_set_client = utf8 */;CREATE TABLE `stu_test` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(30) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `score` decimal(4,2) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;/*!40101 SET character_set_client = @saved_cs_client */;---- Dumping data for table `stu_test`--LOCK TABLES `stu_test` WRITE;/*!40000 ALTER TABLE `stu_test` DISABLE KEYS */;INSERT INTO `stu_test` VALUES (2,&#x27;小图图&#x27;,5,72.80),(3,&#x27;大司马&#x27;,42,87.30),(4,&#x27;乐迪&#x27;,32,99.00);/*!40000 ALTER TABLE `stu_test` ENABLE KEYS */;UNLOCK TABLES;/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;-- Dump completed on 2023-04-15 15:20:25\n\n我们会发现这里面的内容其实都是sql语句，如果将这个备份导入到另外一个数据库中，实际上就是将历史的所有sql语句全部执行一遍！\n\n除此之外，复制/var/lib/mysql下的数据库文件也是可行的一种备份方案。但并不推荐这么做！\n\n1.7.2 备份数据库中的多张表mysqldump -u root -p 数据库名 表名1 表名2 &gt; 备份文件名\n\n1.7.3 同时备份多个数据库mysqldump -u root -p -B 数据库名1 数据库名2  &gt; 备份文件名\n\n1.7.4 还原如下命令需要在mysql中执行\nsource 备份文件路径# 示例source /root/hello.bak.sql;\n\n\n数据库中的内容和原有数据库是完全相同的\nMariaDB [hello]&gt; show tables;+-----------------+| Tables_in_hello |+-----------------+| stu_test        |+-----------------+1 row in set (0.001 sec)MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 ||  4 | 乐迪      |   32 | 99.00 |+----+-----------+------+-------+3 rows in set (0.001 sec)\n\n1.7.5 化简如果你看过了上面对校验影响的验证，其中我往test_bin数据库中使用6条语句插入了大小写的abc。\n但当我们执行备份的时候，可以看到备份出来的sql文件，六个语句被合并了！\nINSERT INTO `student` VALUES (&#x27;a&#x27;),(&#x27;A&#x27;),(&#x27;b&#x27;),(&#x27;B&#x27;),(&#x27;c&#x27;),(&#x27;C&#x27;);\n\n这也是mysql备份的智能之处之一！\n1.8 清空屏幕在MySQL中，可以通过system 来执行linux系统命令\nsystem clear\n\n比如使用如上命令可以清空屏幕\n2.表如下命令需要先进入特定database才能执行\n2.1 创建表基础的创建操作如下。其中末尾的字符集、校验规则、存储引擎的设置项可以留空不填\n\nfield 列名\ndatatype 列的类型\n\ncreate table 表名 (    field1 datatype,    field2 datatype,    field3 datatype) character set 字符集 collate 校验规则 engine 存储引擎;\n\n示例如下，创建了一个student表，并配置了两个键值name和age，类型分别为字符串和int\ncreate table student(    name varchar(30),    age int);\n\n除了基础操作之外，我们还可以给这个表新增一个comment作为列备注\ncreate table student(    name varchar(30) comment &#x27;学生名字&#x27;,    age int comment &#x27;学生年龄&#x27;);\n\n用下面的语句可以查看创建表时候的操作\nshow create table 表名;\n\n\n这部分和备份的时候的sql也是一样的，mysql会帮我们自动规整语句，使其语法规则更规整；\n如下语句也能看到创建表时所用命令\nshow create table stu_test\\G\n\n在数据库帮我们创建这张表的时候，如果没有手动指定引擎和字符集，则会使用数据库的默认设置；\nMariaDB [hello]&gt; show create table stu_test\\G*************************** 1. row ***************************       Table: stu_testCreate Table: CREATE TABLE `stu_test` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(30) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `score` decimal(4,2) DEFAULT NULL,  `avatar` varchar(100) NOT NULL DEFAULT &#x27;default-avatar.png&#x27; COMMENT &#x27;头像图片路径&#x27;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf81 row in set (0.000 sec)\n\n这两个show命令的结果是类似的\n\n如果想在建立表的时候，设置数据库所用引擎和字符集，可以在create语句的括号之后，依照格式添加配置项\nCREATE TABLE xxx() ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n2.2 查看已有表show tables;\n\n+-----------------+| Tables_in_hello |+-----------------+| student         |+-----------------+1 row in set (0.001 sec)\n\n2.3 查看表的属性&#x2F;结构desc 表名;\n\nMariaDB [hello]&gt; desc stu_test;+-------+--------------+------+-----+---------+----------------+| Field | Type         | Null | Key | Default | Extra          |+-------+--------------+------+-----+---------+----------------+| id    | int(11)      | NO   | PRI | NULL    | auto_increment || name  | varchar(30)  | YES  |     | NULL    |                || age   | int(11)      | YES  |     | NULL    |                || score | decimal(4,2) | YES  |     | NULL    |                |+-------+--------------+------+-----+---------+----------------+4 rows in set (0.002 sec)\n\n还可以使用如下命令，输出的结果包括更多信息\nSHOW FULL COLUMNS FROM 表名;\n\n\n2.4 删除该表drop table student;\n\n2.5 修改表的结构注意，这里是对表的属性的修改，并不是对数据的修改！\n比如我想新增字段，或者修改已有字段的属性，或者删除字段\n-- 新增字段ALTER TABLE tablename ADD (column datatype [DEFAULT expr][,columndatatype]...);-- 修改字段ALTER TABLE tablename MODIfy (column datatype [DEFAULT expr][,columndatatype]...);-- 删除字段ALTER TABLE tablename DROP (column);\n\n2.5.0 注意事项请注意：修改表的字段是一个很麻烦的操作，其可能会涉及到已有数据的有效性问题\n\n请在生产环境上线前的测试阶段，完成表字段的定义！\n\n说人话就是，前期设计要想的尽量到位，避免后期表中已有数据的时候修改表的属性！\n2.5.1 新增字段比如我给上方2.5中出现过的stu_test表新增一列，可以用如下的命令\n alter table stu_test add avatar varchar(100) comment &#x27;头像图片路径&#x27; after score;\n\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 ||  4 | 乐迪      |   32 | 99.00 ||  5 | dc872458  |   25 |  NULL |+----+-----------+------+-------+4 rows in set (0.000 sec)MariaDB [hello]&gt; alter table stu_test add avatar varchar(100) comment &#x27;头像图片路径&#x27; after    -&gt; score;Query OK, 0 rows affected (0.005 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------+| id | name      | age  | score | avatar |+----+-----------+------+-------+--------+|  2 | 小图图    |    5 | 72.80 | NULL   ||  3 | 大司马    |   42 | 87.30 | NULL   ||  4 | 乐迪      |   32 | 99.00 | NULL   ||  5 | dc872458  |   25 |  NULL | NULL   |+----+-----------+------+-------+--------+4 rows in set (0.000 sec)\n\n此时可以看到，已有数据都多了一个avatar字段，且这些已有数据的新字段都为NULL\n说明新增字段并不会影响旧数据的旧字段。我们可以在新增字段之后，给旧的数据修改默认值\n2.5.2 删除字段\n如果表中的数据只剩一列（只有一个字段）是不能删除这个字段的（只能删除这个表）\n\n使用如下命令，删除刚刚新增的avatar字段\nalter table stu_test drop avatar;\n\n可以看到avatar列被删除了\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------+| id | name      | age  | score | avatar |+----+-----------+------+-------+--------+|  2 | 小图图    |    5 | 72.80 | NULL   ||  3 | 大司马    |   42 | 87.30 | NULL   ||  4 | 乐迪      |   32 | 99.00 | NULL   ||  5 | dc872458  |   25 |  NULL | NULL   |+----+-----------+------+-------+--------+4 rows in set (0.000 sec)MariaDB [hello]&gt; alter table stu_test drop avatar;Query OK, 0 rows affected (0.034 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+| id | name      | age  | score |+----+-----------+------+-------+|  2 | 小图图    |    5 | 72.80 ||  3 | 大司马    |   42 | 87.30 ||  4 | 乐迪      |   32 | 99.00 ||  5 | dc872458  |   25 |  NULL |+----+-----------+------+-------+4 rows in set (0.000 sec)\n\n在具体场景中，如果需要给已有用户新增头像，一般存放的是头像的文件路径（而不是图片），此时我们就可以设计一个默认头像，并在新增字段的时候将默认值（默认的头像文件路径）修改为这个默认头像图片的路径。\n比如我现在的头像存储的文件路径是\n./images/\n\n此时存放的用户头像文件就应该放到这个目录中，而mysql中只需要存放文件的路径。\n比如用户上传了一个头像图片，我们将头像图片保存到这个路径，再往sql中的avatar字段插入路径\n./images/test-img.pngsql中只需要保存test-img.png，取图片的时候拼接上前方的文件路径\n\n设计一个默认头像，也是放在这个路径中\n./images/test-img.png./images/default-avatar.png\n\n这时候新增avatar字段的时候，就可以指定默认值\nalter table stu_test add avatar varchar(100) not null default &#x27;default-avatar.png&#x27;  comment &#x27;头像图片路径&#x27; afterscore;\n\n这时候就能看到，旧数据的头像都是默认头像了！\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------------------+| id | name      | age  | score | avatar             |+----+-----------+------+-------+--------------------+|  2 | 小图图    |    5 | 72.80 | default-avatar.png ||  3 | 大司马    |   42 | 87.30 | default-avatar.png ||  4 | 乐迪      |   32 | 99.00 | default-avatar.png ||  5 | dc872458  |   25 |  NULL | default-avatar.png |+----+-----------+------+-------+--------------------+4 rows in set (0.000 sec)\n\n默认头像总好过没有图片嘛！\n2.5.3 修改字段类型在设计stu_test表的时候，只给name分配了30个字节的空间。此时如果来了个名字特别特别长的新同学（有些地方的人名确实很长）\n我们发现30个字节存不下这个名字了，就可以考虑将名字字段的长度增加\nalter table stu_test modify name varchar(60);\n\n如下，成功修改！\nMariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+----------------+| Field  | Type         | Null | Key | Default            | Extra          |+--------+--------------+------+-----+--------------------+----------------+| id     | int(11)      | NO   | PRI | NULL               | auto_increment || name   | varchar(30)  | YES  |     | NULL               |                || age    | int(11)      | YES  |     | NULL               |                || score  | decimal(4,2) | YES  |     | NULL               |                || avatar | varchar(100) | NO   |     | default-avatar.png |                |+--------+--------------+------+-----+--------------------+----------------+5 rows in set (0.001 sec)MariaDB [hello]&gt; alter table stu_test modify name varchar(60);Query OK, 0 rows affected (0.013 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+----------------+| Field  | Type         | Null | Key | Default            | Extra          |+--------+--------------+------+-----+--------------------+----------------+| id     | int(11)      | NO   | PRI | NULL               | auto_increment || name   | varchar(60)  | YES  |     | NULL               |                || age    | int(11)      | YES  |     | NULL               |                || score  | decimal(4,2) | YES  |     | NULL               |                || avatar | varchar(100) | NO   |     | default-avatar.png |                |+--------+--------------+------+-----+--------------------+----------------+5 rows in set (0.001 sec)\n\n因为是增加字段的长度，所以也不影响已有数据\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------------------+| id | name      | age  | score | avatar             |+----+-----------+------+-------+--------------------+|  2 | 小图图    |    5 | 72.80 | default-avatar.png ||  3 | 大司马    |   42 | 87.30 | default-avatar.png ||  4 | 乐迪      |   32 | 99.00 | default-avatar.png ||  5 | dc872458  |   25 |  NULL | default-avatar.png |+----+-----------+------+-------+--------------------+4 rows in set (0.000 sec)\n\n如果是减小字段长度，就需要确认已有数据是否有超过新长度的内容了！比如从60减小到30，那么长度为40的数据就会出现错误！\n那如果是将varchar直接改成int，或者将int改成char，会发生什么呢？\n表中的id字段是一个int，尝试将其修改成char\nalter table stu_test modify id varchar(32);\n\nMariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------------------+| id | name      | age  | score | avatar             |+----+-----------+------+-------+--------------------+| 2  | 小图图    |    5 | 72.80 | default-avatar.png || 3  | 大司马    |   42 | 87.30 | default-avatar.png || 4  | 乐迪      |   32 | 99.00 | default-avatar.png || 5  | dc872458  |   25 |  NULL | default-avatar.png |+----+-----------+------+-------+--------------------+4 rows in set (0.001 sec)MariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+-------+| Field  | Type         | Null | Key | Default            | Extra |+--------+--------------+------+-----+--------------------+-------+| id     | varchar(32)  | NO   | PRI | NULL               |       || name   | varchar(60)  | YES  |     | NULL               |       || age    | int(11)      | YES  |     | NULL               |       || score  | decimal(4,2) | YES  |     | NULL               |       || avatar | varchar(100) | NO   |     | default-avatar.png |       |+--------+--------------+------+-----+--------------------+-------+5 rows in set (0.002 sec)\n\n可以看到，其不仅成功变成了字符串类型，已有的值也没有出错。毕竟int数字改成字符串是可行的。那反过来呢？\nMariaDB [hello]&gt; insert into stu_test (id,name,age,score,avatar) values (&#x27;kb&#x27;,&#x27;你好&#x27;,30,60,&#x27;测试图片.png&#x27;);Query OK, 1 row affected (0.007 sec)MariaDB [hello]&gt; select * from stu_test;+----+-----------+------+-------+--------------------+| id | name      | age  | score | avatar             |+----+-----------+------+-------+--------------------+| 2  | 小图图    |    5 | 72.80 | default-avatar.png || 3  | 大司马    |   42 | 87.30 | default-avatar.png || 4  | 乐迪      |   32 | 99.00 | default-avatar.png || 5  | dc872458  |   25 |  NULL | default-avatar.png || kb | 你好      |   30 | 60.00 | 测试图片.png       |+----+-----------+------+-------+--------------------+5 rows in set (0.000 sec)\n\n此时我往表中插入了一个id为kb的数据，再尝试将id从varchar改回int类型\nMariaDB [hello]&gt; alter table stu_test modify id int;ERROR 1292 (22007): Truncated incorrect INTEGER value: &#x27;kb&#x27;MariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+-------+| Field  | Type         | Null | Key | Default            | Extra |+--------+--------------+------+-----+--------------------+-------+| id     | varchar(32)  | NO   | PRI | NULL               |       || name   | varchar(60)  | YES  |     | NULL               |       || age    | int(11)      | YES  |     | NULL               |       || score  | decimal(4,2) | YES  |     | NULL               |       || avatar | varchar(100) | NO   |     | default-avatar.png |       |+--------+--------------+------+-----+--------------------+-------+5 rows in set (0.001 sec)\n\n此时就会报错，kb不符合int类型；修改失败了！\n所以，修改字段的类型，需要保证原有类型和目标类型之间是可以正常双向转换的！\n2.5.4 修改字段名字如下使用change修改字段id -&gt; num，同时还需要注明属性（也可以修改属性）\nalter table stu_test change id num varchar(32);\n\n这里可以看到 0 rows affected，因为我们修改的是字段名字而已，所以不会影响到数据\nMariaDB [hello]&gt; alter table stu_test change id num varchar(32);Query OK, 0 rows affected (0.008 sec)Records: 0  Duplicates: 0  Warnings: 0MariaDB [hello]&gt; desc stu_test;+--------+--------------+------+-----+--------------------+-------+| Field  | Type         | Null | Key | Default            | Extra |+--------+--------------+------+-----+--------------------+-------+| num    | varchar(32)  | NO   | PRI | NULL               |       || name   | varchar(60)  | YES  |     | NULL               |       || age    | int(11)      | YES  |     | NULL               |       || score  | decimal(4,2) | YES  |     | NULL               |       || avatar | varchar(100) | NO   |     | default-avatar.png |       |+--------+--------------+------+-----+--------------------+-------+5 rows in set (0.001 sec)\n\n2.6 修改表名alter table stu_test rename stu;\n\n可以看到修改成功了\nMariaDB [hello]&gt; alter table stu_test rename stu;Query OK, 0 rows affected (0.015 sec)MariaDB [hello]&gt; show tables;+-----------------+| Tables_in_hello |+-----------------+| stu             || tb_video        |+-----------------+2 rows in set (0.000 sec)\n\n2.7 新增自增主键且不影响原有数据新增了一个自增的int id主键到表内，可以使用如下命令\nALTER TABLE 表名 ADD id INT NOT NULL AUTO_INCREMENT PRIMARY KEY FIRST;\n\n2.8 表字段的约束参考 【mysql字段约束 】一文！建议看了这个之后再往下看。\n3.数据记录下方学习的都是数据操控语言DML；主要针对的就是表的增加删除修改和查询，简称CRUD（增查改删）\nCreate   创建Retrieve 读取Update   更新Delete   删除\n\n在MySQL中，我们将一行新增的数据，称为一条记录\n3.1 新增 Create要想往一个表里面插入数据，首先需要创建表（好像是一句废话）\n先使用如下表进行测试\nCREATE TABLE students (\tid INT UNSIGNED PRIMARY KEY AUTO_INCREMENT comment &#x27;主键序号&#x27;,\tsn INT NOT NULL UNIQUE COMMENT &#x27;学号&#x27;,\tname VARCHAR(20) NOT NULL COMMENT  &#x27;学生名字&#x27;,\tqq VARCHAR(20) COMMENT &#x27;学生QQ&#x27;);\n\n在学习插入之前，我们首先要会最基本的查询语句\nselect * from  表名; -- 显示表中的所有数据\n\n3.1.1 单行全列插入所谓单行，代表一次只插入一条记录；\n所谓全列插入，代表插入这条数据的时候，将全部列的数据都手动指定。\ninsert into students values (1,1000,&#x27;小明&#x27;,&#x27;123124&#x27;);insert into students values (2,1001,&#x27;小红&#x27;,NULL);\n\n如上就是两个全列插入的示例；执行完毕这条sql的时候，MySQL会显示 1 row affected，代表只有一行收到了影响（新增了一条记录）\nMariaDB [hello_mysql]&gt; insert into students values (1,1000,&#x27;小明&#x27;,&#x27;123124&#x27;);Query OK, 1 row affected (0.007 sec)MariaDB [hello_mysql]&gt; insert into students values (2,1001,&#x27;小红&#x27;,NULL);Query OK, 1 row affected (0.002 sec)\n\n查询表中数据，可以看到我们刚刚插入的记录\nMariaDB [hello_mysql]&gt; select * from students;+----+------+--------+--------+| id | sn   | name   | qq     |+----+------+--------+--------+|  1 | 1000 | 小明   | 123124 ||  2 | 1001 | 小红   | NULL   |+----+------+--------+--------+2 rows in set (0.001 sec)\n\n3.1.2 多行指定列插入所谓多行插入，就是一次插入多条数据。指定列是在插入的时候，明确告诉MySQL我们想插入的列数是哪几个。\n需要注意的是，只要某一列没有DEFAULT值，如果不指定此列，则会被默认为NULL；如果某一列设置了NOT NULL并且没有设置DEFAULT值，那就必须要指定值，否则会报错。\n另外，指定的列的个数和values中数据的个数需要对应上。\nINSERT INTO students (id, sn, name) VALUES    (102, 20001, &#x27;曹孟德&#x27;),    (103, 20002, &#x27;孙仲谋&#x27;);\n\n执行效果如下\nMariaDB [hello_mysql]&gt; INSERT INTO students (id, sn, name) VALUES    -&gt;     (102, 20001, &#x27;曹孟德&#x27;),    -&gt;     (103, 20002, &#x27;孙仲谋&#x27;);Query OK, 2 rows affected (0.013 sec)Records: 2  Duplicates: 0  Warnings: 0MariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 |  1000 | 小明      | 123124 ||   2 |  1001 | 小红      | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)\n\n3.1.3 插入否则更新如果我们往表里面插入一个已经存在的主键&#x2F;唯一键的值，就会出现主键&#x2F;唯一键冲突而导致的拒绝插入。\nMariaDB [hello_mysql]&gt; insert into students values (1,1003,&#x27;李华&#x27;,&#x27;12354&#x27;);ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;MariaDB [hello_mysql]&gt; insert into students values (5,1000,&#x27;小可&#x27;,&#x27;53134&#x27;);ERROR 1062 (23000): Duplicate entry &#x27;1000&#x27; for key &#x27;sn&#x27;\n\n此时我们可以根据具体情况，将插入改成插入否则更新，即如果主键和唯一键冲突，则更新已有记录。不冲突则正常插入；\n这样就可以把插入和更新的语句给统一成一个。但需要避免出现明明是要插入一个新的，但却因为主键设置错误而更新了旧值，导致记录丢失，那样就不好了。\n插入否则更新的语法是下面这样\nINSERT ... ON DUPLICATE KEY UPDATE column = value [, column = value] ...\n\n示例如下，这个语句的意思是，如果唯一键和主键没有冲突，则插入 (100, 10010, &#39;唐大师&#39;)的记录，如果id和sn冲突了，则将sn更新为10010，name更新为唐大师。\nINSERT INTO students (id, sn, name) VALUES (1, 10010, &#x27;唐大师&#x27;)\tON DUPLICATE KEY UPDATE sn = 10010, name = &#x27;唐大师&#x27;;\n\n执行的效果如下，执行后，可以看到第一行记录因为主键冲突，而更新了这条记录的sn和name\nMariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 |  1000 | 小明      | 123124 ||   2 |  1001 | 小红      | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; INSERT INTO students (id, sn, name) VALUES (1, 10010, &#x27;唐大师&#x27;)    -&gt; ON DUPLICATE KEY UPDATE sn = 10010, name = &#x27;唐大师&#x27;;Query OK, 2 rows affected (0.001 sec)MariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 ||   2 |  1001 | 小红      | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)\n\n唯一键冲突的时候，也是一样的效果，下图中是唯一键sn与原有的第二条记录冲突，最终将第二条记录的sn和name做了更新。\nMariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 ||   2 |  1001 | 小红      | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; INSERT INTO students (id, sn, name) VALUES (3, 1001, &#x27;唐大师2&#x27;) ON DUPLICATE KEY UPDATE sn = 1005, name = &#x27;唐大师&#x27;;Query OK, 2 rows affected (0.001 sec)MariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 ||   2 |  1005 | 唐大师    | NULL   || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   |+-----+-------+-----------+--------+4 rows in set (0.000 sec)\n\n需要注意的是，在UPDATE语句之后的sn也不能和已有的sn冲突，不然会因为唯一键冲突（因为你需要更新到这个值，而这个值已有了）而拒绝更新\nMariaDB [hello_mysql]&gt; INSERT INTO students (id, sn, name) VALUES (3, 1001, &#x27;唐大师2&#x27;) ON DUPLICATE KEY UPDATE sn = 10010, name = &#x27;唐大师&#x27;;ERROR 1062 (23000): Duplicate entry &#x27;10010&#x27; for key &#x27;sn&#x27;\n\n3.1.4 替换 Replace除了上面那种更新的方式，我们还有一个替换语句可以用来替换值\n\n如果没有冲突则直接插入\n如果已经冲突了则删除原有的记录，然后再插入\n\n这里要注意替换和插入否则更新的区别！插入否则更新是需要你指定要更新那些列的数据，而替换是会直接将原视数据删除的！\n下面给出两条sql语句，其中第一条没有冲突，第二条的sn冲突\n-- 无冲突REPLACE INTO students (sn,name) VALUES (20000,&#x27;闰土&#x27;);-- 有冲突REPLACE INTO students (sn,name) VALUES (1005,&#x27;周树人&#x27;);\n\n先执行第一个sql，可以看到返回的是1行受到影响，代表数据被插入\nMariaDB [hello_mysql]&gt; REPLACE INTO students (sn,name) VALUES (20000,&#x27;闰土&#x27;);Query OK, 1 row affected (0.001 sec)\n\n再执行有冲突的，可以看到是2行受影响，因为这条语句会删除原有的再插入，相当于执行了一次删除和一次插入，影响了两行的数据。\nMariaDB [hello_mysql]&gt; REPLACE INTO students (sn,name) VALUES (1005,&#x27;周树人&#x27;);Query OK, 2 rows affected (0.001 sec)\n\n3.2 查询 Retrieve查询的基础语法如下\nSELECT    [DISTINCT] &#123;* | &#123;column [, column] ...&#125;    [FROM table_name]    [WHERE ...]    [ORDER BY column [ASC | DESC], ...]    LIMIT ...\n\n3.2.1 全列查询用通配符*表示查询整个表的数据\nselect * from  students;\n\n该语句会查表中的所有值，在前面我们已经接触过了\nMariaDB [hello_mysql]&gt; select * from  students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   || 104 | 20000 | 闰土      | NULL   || 105 |  1005 | 周树人    | NULL   |+-----+-------+-----------+--------+5 rows in set (0.000 sec)\n\n  不过一般情况下不建议用全列查询：\n\n查询的列越多，意味着需要传输的数据量越大； \n可能会影响到索引的使用（后续会学习到）\n\n3.2.2 指定列查询所谓指定列，就是在查询的时候返回特定的列，比如如下就是在学生表里面返回sn和name这两列的数据\nselect sn,name from  students;\n\n执行效果如下，最终只显示了我们指定的两个列，并没有把id和qq列也给展示出来\nMariaDB [hello_mysql]&gt; select sn,name from  students;+-------+-----------+| sn    | name      |+-------+-----------+| 10010 | 唐大师    || 20001 | 曹孟德    || 20002 | 孙仲谋    || 20000 | 闰土      ||  1005 | 周树人    |+-------+-----------+5 rows in set (0.000 sec)\n\n3.2.3 表达式查询为了进行后续的学习，我们先来构造一个测试表\n-- 表创建CREATE TABLE exam_result (    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20) NOT NULL COMMENT &#x27;同学姓名&#x27;,    chinese float DEFAULT 0.0 COMMENT &#x27;语文成绩&#x27;,    math float DEFAULT 0.0 COMMENT &#x27;数学成绩&#x27;,    english float DEFAULT 0.0 COMMENT &#x27;英语成绩&#x27;);-- 插入多行测试数据INSERT INTO exam_result (name, chinese, math, english) VALUES    (&#x27;唐三藏&#x27;, 67, 98, 56),    (&#x27;孙悟空&#x27;, 87, 78, 77),    (&#x27;猪悟能&#x27;, 88, 98, 90),    (&#x27;曹孟德&#x27;, 82, 84, 67),    (&#x27;刘玄德&#x27;, 55, 85, 45),    (&#x27;孙权&#x27;, 70, 73, 78),    (&#x27;宋公明&#x27;, 75, 65, 30);\n\n在前面两种查询中，我们都只是查询表里面已经有的数据，但实际上我们在查询结果展示的时候，还可以让MySQL帮我们完成一定的表达式计算\nselect id,name,english,10 from exam_result;\n\n比如如上的sql，我们在原本的指定列查询后新增了一个10，这个10就是一个表达式，它并不包含表中已经有的字段，所以会拼接在表的原有数据之后展示出来\nMariaDB [hello_mysql]&gt; select id,name,english,10 from exam_result;+----+-----------+---------+----+| id | name      | english | 10 |+----+-----------+---------+----+|  1 | 唐三藏    |      56 | 10 ||  2 | 孙悟空    |      77 | 10 ||  3 | 猪悟能    |      90 | 10 ||  4 | 曹孟德    |      67 | 10 ||  5 | 刘玄德    |      45 | 10 ||  6 | 孙权      |      78 | 10 ||  7 | 宋公明    |      30 | 10 |+----+-----------+---------+----+7 rows in set (0.000 sec)\n\n在这里写个算式，MySQL也会帮我们计算并展示出来\nMariaDB [hello_mysql]&gt; select id,name,english,10+20 from exam_result;+----+-----------+---------+-------+| id | name      | english | 10+20 |+----+-----------+---------+-------+|  1 | 唐三藏    |      56 |    30 ||  2 | 孙悟空    |      77 |    30 ||  3 | 猪悟能    |      90 |    30 ||  4 | 曹孟德    |      67 |    30 ||  5 | 刘玄德    |      45 |    30 ||  6 | 孙权      |      78 |    30 ||  7 | 宋公明    |      30 |    30 |+----+-----------+---------+-------+7 rows in set (0.001 sec)\n\n这时候我们就可以在返回结果的时候，对原视的数据做一些处理，比如将数学和英语成绩给加起来返回\nMariaDB [hello_mysql]&gt; select id,name,english+math from exam_result;+----+-----------+--------------+| id | name      | english+math |+----+-----------+--------------+|  1 | 唐三藏    |          154 ||  2 | 孙悟空    |          155 ||  3 | 猪悟能    |          188 ||  4 | 曹孟德    |          151 ||  5 | 刘玄德    |          130 ||  6 | 孙权      |          151 ||  7 | 宋公明    |           95 |+----+-----------+--------------+7 rows in set (0.000 sec)\n\n3.2.4 为表达式设置别名在表达式查询的时候，我们可以给表达式设置一些别名来提高可读性，基础语法如下\nSELECT column [AS] alias_name [...] FROM table_name;\n\n比如当我们将三科总分加起来返回的时候，就可以将其设置一个总分别名来返回\nMariaDB [hello_mysql]&gt; select id,name,chinese+english+math as &#x27;总分&#x27; from exam_result;+----+-----------+--------+| id | name      | 总分   |+----+-----------+--------+|  1 | 唐三藏    |    221 ||  2 | 孙悟空    |    242 ||  3 | 猪悟能    |    276 ||  4 | 曹孟德    |    233 ||  5 | 刘玄德    |    185 ||  6 | 孙权      |    221 ||  7 | 宋公明    |    170 |+----+-----------+--------+7 rows in set (0.000 sec)\n\n此时MySQL展示的是总分，而不是原视表达式，可读性更好！\n3.2.5 结果去重 distinct有的时候我们想知道班里同学的成绩都有那些分段，并不想看到底是谁考出来的。此时就可以使用distinct去重查询过滤出不重复的一个集和并展示出来\nselect distinct math from exam_result;\n\n如上语句就是在展示math列的结果的时候对结果进行去重，原本的数据中98分是重复的，添加上这个关键字后，重复的98就被去掉了。\nMariaDB [hello_mysql]&gt; select math from exam_result;+------+| math |+------+|   98 ||   78 ||   98 ||   84 ||   85 ||   73 ||   65 |+------+7 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; select distinct math from exam_result;+------+| math |+------+|   98 ||   78 ||   84 ||   85 ||   73 ||   65 |+------+6 rows in set (0.001 sec)\n\n3.2.6 where条件查询运算符说完了基本的查询，就得来看大头条件查询了，基本用法是在表名后用where带上具体条件。在那之前，先来看看where支持什么比较运算符吧\n\n\n\n比较运算符\n说明\n\n\n\n&gt;,&gt;=,&lt;,&lt;=\n这个应该不需要说吧\n\n\n=\n等于，NULL不安全，NULL=NULL的结果是NULL\n\n\n&lt;=&gt;\n等于，NULL安全，NULL&lt;=&gt;NULL的结果是 TRUE(1)\n\n\n!=,&lt;&gt;\n不等于\n\n\nBETWEEN a AND b\n范围匹配，闭区间，如果 a&lt;=value&lt;=b返回 TRUE(1)\n\n\nIN (option,...)\n如果是option中的任意一个，则返回 TRUE(1)\n\n\nIS NULL\n是NULL\n\n\nIS NOT NULL\n不是NULL\n\n\nLIKE\n模糊匹配，%表示任意多个（包括0个）字符；_表示任意一个字符；\n\n\n除了比较的运算符，还有逻辑运算符\n\n\n\n逻辑运算符号\n说明\n\n\n\nAND\n与，相当于cpp中的&amp;&amp;，全真为1，有假为0\n\n\nOR\n或，相当于cpp中的&#96;\n\n\nNOT\n逻辑取反，条件为TRUE(1)的时候结果为FALSE(0)\n\n\n大于小于和区间筛选比如最基础的，查询成绩表里面某科成绩低于多少分的用户\nselect name,english from exam_result where english &lt; 60;\n\n运行结果如下，成功展示出来了英语成绩小于60分的人\nMariaDB [hello_mysql]&gt; select name,english from exam_result where english &lt; 60;+-----------+---------+| name      | english |+-----------+---------+| 唐三藏    |      56 || 刘玄德    |      45 || 宋公明    |      30 |+-----------+---------+3 rows in set (0.000 sec)\n\n我们还可以用and进行拼接多个条件\nselect name,chinese,english from exam_result where english &lt; 60 and chinese &lt; 60;\n\n比如如上sql是查询英语和语文都不及格的人\nMariaDB [hello_mysql]&gt; select name,chinese,english from exam_result where english &lt; 60 and chinese &lt; 60;+-----------+---------+---------+| name      | chinese | english |+-----------+---------+---------+| 刘玄德    |      55 |      45 |+-----------+---------+---------+1 row in set (0.000 sec)\n\n还有查询语文成绩在[30,60]区间的人\nMariaDB [hello_mysql]&gt; select name,chinese from exam_result where chinese between 30 and 65;+-----------+---------+| name      | chinese |+-----------+---------+| 刘玄德    |      55 |+-----------+---------+1 row in set (0.000 sec)\n\n当然，大于小于的比较也可以用于两个字段之间的比较，比如如下筛选出语文比英语好的同学\nMariaDB [hello_mysql]&gt; SELECT name, chinese, english FROM exam_result WHERE chinese &gt; english;+-----------+---------+---------+| name      | chinese | english |+-----------+---------+---------+| 唐三藏    |      67 |      56 || 孙悟空    |      87 |      77 || 曹孟德    |      82 |      67 || 刘玄德    |      55 |      45 || 宋公明    |      75 |      30 |+-----------+---------+---------+5 rows in set (0.000 sec)\n\n相等筛选select name,math from exam_result where math = 50 or math = 59 or math = 98 or math = 99;\n\n如上语句可以帮我们筛选出数学成绩等于 50、59、98、99其中一个的学生\nMariaDB [hello_mysql]&gt; select name,math from exam_result where math = 50 or math = 59 or math = 98 or math = 99;+-----------+------+| name      | math |+-----------+------+| 唐三藏    |   98 || 猪悟能    |   98 |+-----------+------+2 rows in set (0.000 sec)\n\n和这个语句相同效果的，还有如下的in运算符\nMariaDB [hello_mysql]&gt; select name,math from exam_result where math in (50,59,98,99);+-----------+------+| name      | math |+-----------+------+| 唐三藏    |   98 || 猪悟能    |   98 |+-----------+------+2 rows in set (0.001 sec)\n\n字符匹配 LIKE-- % 匹配多个字符，如下语句代表匹配名字为孙开头的人select name from exam_result where name LIKE &#x27;孙%&#x27;;-- _ 匹配单个字符，如下语句代表匹配名字开头为孙，但只有两个字的人select name from exam_result where name LIKE &#x27;孙_&#x27;;\n\n效果如下，可以看到在第二个单字匹配的时候，就没有将孙悟空也匹配进去\nMariaDB [hello_mysql]&gt; select name from exam_result where name LIKE &#x27;孙%&#x27;;+-----------+| name      |+-----------+| 孙悟空    || 孙权      |+-----------+2 rows in set (0.013 sec)MariaDB [hello_mysql]&gt; select name from exam_result where name LIKE &#x27;孙_&#x27;;+--------+| name   |+--------+| 孙权   |+--------+1 row in set (0.000 sec)\n\n如下语句可以筛选出语文成绩大于80分且不姓孙的同学，同时用到了and和not\nMariaDB [hello_mysql]&gt; SELECT name, chinese FROM exam_result    -&gt; WHERE chinese &gt; 80 AND name NOT LIKE &#x27;孙%&#x27;;+-----------+---------+| name      | chinese |+-----------+---------+| 猪悟能    |      88 || 曹孟德    |      82 |+-----------+---------+2 rows in set (0.000 sec)\n\n计算后筛选上面我们筛选的都是字段本身，但我们还可以将一些字段加起来之后再进行筛选；\nMariaDB [hello_mysql]&gt; SELECT name, chinese + math + english 总分 FROM exam_result WHERE chinese + math + english &lt; 200;+-----------+--------+| name      | 总分   |+-----------+--------+| 刘玄德    |    185 || 宋公明    |    170 |+-----------+--------+2 rows in set (0.000 sec)\n\n需要注意的是，这里虽然我们给三科分数加起来设置了别名，但是别名是不能在where条件中使用的！你可以理解为别名其实只是最终显示结果的时候被修改了，在查询的过程中别名实际上并没有生效！\nMariaDB [hello_mysql]&gt; SELECT name, chinese + math + english 总分 FROM exam_result WHERE 总分 &lt; 200;ERROR 1054 (42S22): Unknown column &#x27;总分&#x27; in &#x27;where clause&#x27;\n\nNULL的查询在之前的students表中，我们有些记录的qq号是NULL，这时候应该使用 IS NULL/IS NOT NULL来进行针对NULL的查询\n-- qq号不是空的人MariaDB [hello_mysql]&gt; select * from students where qq is not null;+----+-------+-----------+--------+| id | sn    | name      | qq     |+----+-------+-----------+--------+|  1 | 10010 | 唐大师    | 123124 |+----+-------+-----------+--------+1 row in set (0.000 sec)-- qq号是空的人MariaDB [hello_mysql]&gt; select * from students where qq is null;+-----+-------+-----------+------+| id  | sn    | name      | qq   |+-----+-------+-----------+------+| 102 | 20001 | 曹孟德    | NULL || 103 | 20002 | 孙仲谋    | NULL || 104 | 20000 | 闰土      | NULL || 105 |  1005 | 周树人    | NULL |+-----+-------+-----------+------+4 rows in set (0.000 sec)\n\n这里我们还可以试验一下 =和&lt;=&gt;的不同，前文提到，=是NULL不安全的，这是因为NULL=NULL为NULL，而我们预期的结果应该是TRUE(1)。\n从测试可以看出，使用 = 筛选出来的是空的，因为NULL在MySQL中认为是假，无法正常进行判断，而使用 &lt;=&gt;的成功筛选出了正确的结果\nMariaDB [hello_mysql]&gt; select * from students where qq = null;Empty set (0.000 sec)MariaDB [hello_mysql]&gt; select * from students where qq &lt;=&gt; null;+-----+-------+-----------+------+| id  | sn    | name      | qq   |+-----+-------+-----------+------+| 102 | 20001 | 曹孟德    | NULL || 103 | 20002 | 孙仲谋    | NULL || 104 | 20000 | 闰土      | NULL || 105 |  1005 | 周树人    | NULL |+-----+-------+-----------+------+4 rows in set (0.000 sec)\n\n同时我们可以将NULL和01进行一下对比，也能看出来NULL的特殊性；NULL和我们认识的真1与假0没有关系，其为一个独立的特殊值，NULL只能用来和NULL进行比较。\nMariaDB [hello_mysql]&gt; SELECT NULL &lt;=&gt; NULL, NULL &lt;=&gt; 1, NULL &lt;=&gt; 0;+---------------+------------+------------+| NULL &lt;=&gt; NULL | NULL &lt;=&gt; 1 | NULL &lt;=&gt; 0 |+---------------+------------+------------+|             1 |          0 |          0 |+---------------+------------+------------+1 row in set (0.000 sec)MariaDB [hello_mysql]&gt; SELECT NULL = NULL, NULL = 1, NULL = 0;+-------------+----------+----------+| NULL = NULL | NULL = 1 | NULL = 0 |+-------------+----------+----------+|        NULL |     NULL |     NULL |+-------------+----------+----------+1 row in set (0.000 sec)\n\n查询条件不一定需要显示如下，我们使用了math作为查询的条件，但最终展示的结果里面并没有math，这也是被允许的。\nMariaDB [hello_mysql]&gt; select name,chinese from exam_result where math &gt; 70;+-----------+---------+| name      | chinese |+-----------+---------+| 唐三藏    |      67 || 孙悟空    |      87 || 猪悟能    |      88 || 曹孟德    |      82 || 刘玄德    |      55 || 孙权      |      70 |+-----------+---------+6 rows in set (0.012 sec)\n\n3.2.7 结果排序在很多时候，我们除了想获取到指定的结果，还希望对结果进行一定的排序，以筛选出更加精细的数据\n-- ASC  为升序（从小到大）-- DESC 为降序（从大到小）-- ORDER BY 默认为 ASCSELECT ... FROM table_name [WHERE ...]\tORDER BY column [ASC|DESC], [...];\n\n注意：没有ORDER BY子句的查询，返回的顺序是未定义的（乱序）；\n如果某个值是NULL，那它比任何值都小！\n单字段升序&#x2F;降序显示SELECT name, math FROM exam_result ORDER BY math; -- 默认升序SELECT name, math FROM exam_result ORDER BY math DESC; -- 降序\n\n使用这个语句，可以让结果以某个字段的升序或者降序来显示；\nMariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result ORDER BY math;+-----------+------+| name      | math |+-----------+------+| 宋公明    |   65 || 孙权      |   73 || 孙悟空    |   78 || 曹孟德    |   84 || 刘玄德    |   85 || 唐三藏    |   98 || 猪悟能    |   98 |+-----------+------+7 rows in set (0.012 sec)MariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result ORDER BY math DESC;+-----------+------+| name      | math |+-----------+------+| 唐三藏    |   98 || 猪悟能    |   98 || 刘玄德    |   85 || 曹孟德    |   84 || 孙悟空    |   78 || 孙权      |   73 || 宋公明    |   65 |+-----------+------+7 rows in set (0.000 sec)\n\nNULL比所有字段都小，比如下方排序的时候，NULL会显示在已有数据的下面；\nMySQL对字符串的排序是按字典序的！会根据字符的 Unicode 值进行字典顺序的比较；\nMariaDB [hello_mysql]&gt; select name,qq from students order by qq desc;+-----------+--------+| name      | qq     |+-----------+--------+| 唐大师    | 123124 || 曹孟德    | NULL   || 孙仲谋    | NULL   || 闰土      | NULL   || 周树人    | NULL   |+-----------+--------+5 rows in set (0.001 sec)\n\n排序的键值不一定需要出现在select的指定列中，如下我们最终返回的结果并没有qq，但依旧可以通过qq进行排序\nMariaDB [hello_mysql]&gt; select name from students order by qq desc;+-----------+| name      |+-----------+| 唐大师    || 曹孟德    || 孙仲谋    || 闰土      || 周树人    |+-----------+5 rows in set (0.000 sec)\n\n多字段排序多字段排序中，排序的优先级依照这里的书写顺序；\n比如下面的语句就会先按数学进行降序排序，再按英语进行升序排序，最后按语文进行升序排序\nSELECT name, math, english, chinese FROM exam_result\tORDER BY math DESC, english, chinese;\n\n效果如下\nMariaDB [hello_mysql]&gt; SELECT name, math, english, chinese FROM exam_result    -&gt; ORDER BY math DESC, english, chinese;+-----------+------+---------+---------+| name      | math | english | chinese |+-----------+------+---------+---------+| 唐三藏    |   98 |      56 |      67 || 猪悟能    |   98 |      90 |      88 || 刘玄德    |   85 |      45 |      55 || 曹孟德    |   84 |      67 |      82 || 孙悟空    |   78 |      77 |      87 || 孙权      |   73 |      78 |      70 || 宋公明    |   65 |      30 |      75 |+-----------+------+---------+---------+7 rows in set (0.000 sec)\n\n求和后排序在ORDER BY里面是支持表达式的，也支持别名\n-- 表达式SELECT name, chinese + english + math FROM exam_result\tORDER BY chinese + english + math DESC;-- 别名SELECT name, chinese + english + math 总分 FROM exam_result\tORDER BY 总分 DESC;\n\n效果如下\nMariaDB [hello_mysql]&gt; SELECT name, chinese + english + math FROM exam_result    -&gt; ORDER BY chinese + english + math DESC;+-----------+--------------------------+| name      | chinese + english + math |+-----------+--------------------------+| 猪悟能    |                      276 || 孙悟空    |                      242 || 曹孟德    |                      233 || 唐三藏    |                      221 || 孙权      |                      221 || 刘玄德    |                      185 || 宋公明    |                      170 |+-----------+--------------------------+7 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; SELECT name, chinese + english + math 总分 FROM exam_result    -&gt; ORDER BY 总分 DESC;+-----------+--------+| name      | 总分   |+-----------+--------+| 猪悟能    |    276 || 孙悟空    |    242 || 曹孟德    |    233 || 唐三藏    |    221 || 孙权      |    221 || 刘玄德    |    185 || 宋公明    |    170 |+-----------+--------+7 rows in set (0.000 sec)\n\nwhere+orderbywhere条件语句和排序语句联合使用\nSELECT name, math FROM exam_result\tWHERE name LIKE &#x27;孙%&#x27; OR name LIKE &#x27;曹%&#x27;\tORDER BY math DESC;\n\nMariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result    -&gt; WHERE name LIKE &#x27;孙%&#x27; OR name LIKE &#x27;曹%&#x27;    -&gt; ORDER BY math DESC;+-----------+------+| name      | math |+-----------+------+| 曹孟德    |   84 || 孙悟空    |   78 || 孙权      |   73 |+-----------+------+3 rows in set (0.001 sec)\n\n3.2.8 筛选分页结果对表的筛选结果进行分页的语句格式如下\n-- 起始下标为 0-- 从 0 开始，筛选 n 条结果SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n;-- 从 s 开始，筛选 n 条结果SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT s, n;-- 从 s 开始，筛选 n 条结果，比第二种用法更明确，建议使用SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n OFFSET s;\n\n为什么需要分页？\n假设一个表里面有上千万条数据，如果你使用select * from 表进行全列查询，那可能MySQL数据库就会因为要一次性给你返回大量数据而卡死，直接影响其他应用使用该数据库，导致服务宕机！\n所以，在查询一个未知表的时候，建议先使用desc查看表结构，在再加上一个LIMIT 1，来查看很少的几条数据，并对数据进行人为分析，确定这个表的功能；\n\n当然，在项目合作中，肯定需要有人编写文档来说明这些表的作用，遇到这种情况，应该先去查项目文档再进行操作。\n\nSELECT id, name, math, english, chinese FROM exam_result\tORDER BY id LIMIT 3 OFFSET 0;\n\n上面的语句的意思是，从偏移量为0的未知（即表开头）筛选出3个数据；最终展示的就只有3条数据\nMariaDB [hello_mysql]&gt; SELECT id, name, math, english, chinese FROM exam_result    -&gt; ORDER BY id LIMIT 3 OFFSET 0;+----+-----------+------+---------+---------+| id | name      | math | english | chinese |+----+-----------+------+---------+---------+|  1 | 唐三藏    |   98 |      56 |      67 ||  2 | 孙悟空    |   78 |      77 |      87 ||  3 | 猪悟能    |   98 |      90 |      88 |+----+-----------+------+---------+---------+3 rows in set (0.000 sec)\n\n修改offset，可以通过id看到数据的变化\nMariaDB [hello_mysql]&gt; SELECT id, name, math, english, chinese FROM exam_result    -&gt; ORDER BY id LIMIT 3 OFFSET 4;+----+-----------+------+---------+---------+| id | name      | math | english | chinese |+----+-----------+------+---------+---------+|  5 | 刘玄德    |   85 |      45 |      55 ||  6 | 孙权      |   73 |      78 |      70 ||  7 | 宋公明    |   65 |      30 |      75 |+----+-----------+------+---------+---------+3 rows in set (0.001 sec)\n\n如果offset后并没有3个数据，也不会出问题，能正常显示出来\nMariaDB [hello_mysql]&gt; SELECT id, name, math, english, chinese FROM exam_result ORDER BY id LIMIT 3 OFFSET 6;+----+-----------+------+---------+---------+| id | name      | math | english | chinese |+----+-----------+------+---------+---------+|  7 | 宋公明    |   65 |      30 |      75 |+----+-----------+------+---------+---------+1 row in set (0.001 sec)\n\n如果offset大于表中已有数据数量，那就会显示空，并不会执行出错！\nMariaDB [hello_mysql]&gt; SELECT id, name, math, english, chinese FROM exam_result ORDER BY id LIMIT 3 OFFSET 10;Empty set (0.001 sec)\n\n3.2.9 执行顺序在执行这些sql语句中的语法的时候，MySQL是会有一个执行顺序的\n\n先通过from表从表中拿到数据\n再通过where的条件筛选数据\n根据 SELECT 子句中指定的列，MySQL 最终确定要返回的数据；\n筛选完毕最终需要显示的数据后，根据order by对数据进行排序；排序可以使用别名；排序的字段不一定需要出现在select指定的列中；\n如果查询包含 DISTINCT 关键字，MySQL 会进行去重操作，确保结果集中的行是唯一的；\n\n在后文讲到聚合语句的时候，还会重谈一遍执行顺序\n3.3 更新 UpdateUPDATE 表名 SET 字段名 = 新值 WHERE 查询条件...;\n\n3.3.1 更新单个记录-- 查看原视数据MariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result WHERE name = &#x27;孙悟空&#x27;;+-----------+------+| name      | math |+-----------+------+| 孙悟空    |   78 |+-----------+------+1 row in set (0.000 sec)-- 更新数据MariaDB [hello_mysql]&gt; UPDATE exam_result SET math = 80 WHERE name = &#x27;孙悟空&#x27;;Query OK, 1 row affected (0.019 sec)Rows matched: 1  Changed: 1  Warnings: 0-- 再次查看结果，成功更新MariaDB [hello_mysql]&gt; SELECT name, math FROM exam_result WHERE name = &#x27;孙悟空&#x27;;+-----------+------+| name      | math |+-----------+------+| 孙悟空    |   80 |+-----------+------+1 row in set (0.000 sec)\n\n3.3.2 一次更新多列MariaDB [hello_mysql]&gt; SELECT name, math, chinese FROM exam_result WHERE name = &#x27;曹孟德&#x27;;+-----------+------+---------+| name      | math | chinese |+-----------+------+---------+| 曹孟德    |   84 |      82 |+-----------+------+---------+1 row in set (0.001 sec)-- 一次更新多列 MariaDB [hello_mysql]&gt; UPDATE exam_result SET math = 60, chinese = 70 WHERE name = &#x27;曹孟德&#x27;;Query OK, 1 row affected (0.001 sec)Rows matched: 1  Changed: 1  Warnings: 0MariaDB [hello_mysql]&gt; SELECT name, math, chinese FROM exam_result WHERE name = &#x27;曹孟德&#x27;;+-----------+------+---------+| name      | math | chinese |+-----------+------+---------+| 曹孟德    |   60 |      70 |+-----------+------+---------+1 row in set (0.000 sec)\n\n3.3.3 将总成绩倒数前三的数学成绩加上30分-- 查看元数据SELECT name, math, chinese + math + english 总分 FROM exam_result\tORDER BY 总分 LIMIT 3;-- 更新，需要注意不支持+=这种运算符UPDATE exam_result SET math = math + 30\tORDER BY chinese + math + english LIMIT 3;-- 查看更新后结果SELECT name, math, chinese + math + english 总分 FROM exam_result\tWHERE name IN (&#x27;宋公明&#x27;, &#x27;刘玄德&#x27;, &#x27;曹孟德&#x27;);-- 按总成绩排序后结果SELECT name, math, chinese + math + english 总分 FROM exam_result\tORDER BY 总分 LIMIT 3;\n\n结果如下\nMariaDB [hello_mysql]&gt; SELECT name, math, chinese + math + english 总分 FROM exam_result    -&gt; ORDER BY 总分 LIMIT 3;+-----------+------+--------+| name      | math | 总分   |+-----------+------+--------+| 宋公明    |   65 |    170 || 刘玄德    |   85 |    185 || 曹孟德    |   60 |    197 |+-----------+------+--------+3 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; UPDATE exam_result SET math = math + 30    -&gt; ORDER BY chinese + math + english LIMIT 3;Query OK, 3 rows affected (0.043 sec)Rows matched: 3  Changed: 3  Warnings: 0MariaDB [hello_mysql]&gt; SELECT name, math, chinese + math + english 总分 FROM exam_result    -&gt; WHERE name IN (&#x27;宋公明&#x27;, &#x27;刘玄德&#x27;, &#x27;曹孟德&#x27;);+-----------+------+--------+| name      | math | 总分   |+-----------+------+--------+| 曹孟德    |   90 |    227 || 刘玄德    |  115 |    215 || 宋公明    |   95 |    200 |+-----------+------+--------+3 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; SELECT name, math, chinese + math + english 总分 FROM exam_result    -&gt; ORDER BY 总分 LIMIT 3;+-----------+------+--------+| name      | math | 总分   |+-----------+------+--------+| 宋公明    |   95 |    200 || 刘玄德    |  115 |    215 || 唐三藏    |   98 |    221 |+-----------+------+--------+3 rows in set (0.000 sec)\n\n3.3.4 将所有同学的语文成绩更新为原有的2倍MariaDB [hello_mysql]&gt; SELECT * FROM exam_result;+----+-----------+---------+------+---------+| id | name      | chinese | math | english |+----+-----------+---------+------+---------+|  1 | 唐三藏    |      67 |   98 |      56 ||  2 | 孙悟空    |      87 |   80 |      77 ||  3 | 猪悟能    |      88 |   98 |      90 ||  4 | 曹孟德    |      70 |   90 |      67 ||  5 | 刘玄德    |      55 |  115 |      45 ||  6 | 孙权      |      70 |   73 |      78 ||  7 | 宋公明    |      75 |   95 |      30 |+----+-----------+---------+------+---------+7 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; UPDATE exam_result SET chinese = chinese * 2;Query OK, 7 rows affected (0.001 sec)Rows matched: 7  Changed: 7  Warnings: 0MariaDB [hello_mysql]&gt; SELECT * FROM exam_result;+----+-----------+---------+------+---------+| id | name      | chinese | math | english |+----+-----------+---------+------+---------+|  1 | 唐三藏    |     134 |   98 |      56 ||  2 | 孙悟空    |     174 |   80 |      77 ||  3 | 猪悟能    |     176 |   98 |      90 ||  4 | 曹孟德    |     140 |   90 |      67 ||  5 | 刘玄德    |     110 |  115 |      45 ||  6 | 孙权      |     140 |   73 |      78 ||  7 | 宋公明    |     150 |   95 |      30 |+----+-----------+---------+------+---------+7 rows in set (0.000 sec)\n\n更新语句的基本操作就只有这些！\n3.4 删除 Delete语法\nDELETE FROM table_name [WHERE ...] [ORDER BY ...] [LIMIT ...]\n\n3.4.1 删除孙悟空的考试成绩DELETE FROM exam_result WHERE name = &#x27;孙悟空&#x27;;\n\n效果\nMariaDB [hello_mysql]&gt; SELECT * FROM exam_result;+----+-----------+---------+------+---------+| id | name      | chinese | math | english |+----+-----------+---------+------+---------+|  1 | 唐三藏    |     134 |   98 |      56 ||  2 | 孙悟空    |     174 |   80 |      77 ||  3 | 猪悟能    |     176 |   98 |      90 ||  4 | 曹孟德    |     140 |   90 |      67 ||  5 | 刘玄德    |     110 |  115 |      45 ||  6 | 孙权      |     140 |   73 |      78 ||  7 | 宋公明    |     150 |   95 |      30 |+----+-----------+---------+------+---------+7 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; DELETE FROM exam_result WHERE name = &#x27;孙悟空&#x27;;Query OK, 1 row affected (0.043 sec)MariaDB [hello_mysql]&gt; SELECT * FROM exam_result;+----+-----------+---------+------+---------+| id | name      | chinese | math | english |+----+-----------+---------+------+---------+|  1 | 唐三藏    |     134 |   98 |      56 ||  3 | 猪悟能    |     176 |   98 |      90 ||  4 | 曹孟德    |     140 |   90 |      67 ||  5 | 刘玄德    |     110 |  115 |      45 ||  6 | 孙权      |     140 |   73 |      78 ||  7 | 宋公明    |     150 |   95 |      30 |+----+-----------+---------+------+---------+6 rows in set (0.000 sec)\n\n3.4.2 删除表中所有数据（不是删除表）慎用！不然就是从删库到跑路了！\nDELETE FROM 表名;\n\n注意，这个语句是删除表中所有数据，表不会被删除， AUTO_INCREMENT 项也不会被重置，会在原有基础上继续增加\n3.4.3 截断表语法如下，这个操作更要慎用。\nTRUNCATE [TABLE] table_name\n\n\n只能对整表操作，不能像 DELETE 一样针对部分数据操作； \n实际上 MySQL 不对数据操作，所以比 DELETE 更快，但是TRUNCATE在删除数据的时候，并不经过真正的事务，所以无法回滚；\n会重置 AUTO_INCREMENT 项；\n\n-- 准备测试表CREATE TABLE for_truncate (id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(20));Query OK, 0 rows affected (0.16 sec)-- 插入测试数据INSERT INTO for_truncate (name) VALUES (&#x27;A&#x27;), (&#x27;B&#x27;), (&#x27;C&#x27;);Query OK, 3 rows affected (1.05 sec)Records: 3 Duplicates: 0 Warnings: 0-- 查看测试数据SELECT * FROM for_truncate;+----+------+| id | name |+----+------+| 1 | A || 2 | B || 3 | C |+----+------+3 rows in set (0.00 sec)\n\n截断整表数据，注意影响行数是 0，所以实际上没有对数据真正操作\n-- 截断表TRUNCATE for_truncate;Query OK, 0 rows affected (0.10 sec)-- 查看删除结果SELECT * FROM for_truncate;Empty set (0.00 sec)\n\n截断数据是会重置自增键值的当前值的，新插入的数据会从1开始重新自增；\n-- 再插入一条数据，自增 id 在重新增长INSERT INTO for_truncate (name) VALUES (&#x27;D&#x27;);Query OK, 1 row affected (0.00 sec)-- 查看数据SELECT * FROM for_truncate;+----+------+| id | name |+----+------+| 1 | D     |+----+------+1 row in set (0.00 sec)\n\n在linux的文件操作里面，也有一个O_TRUNC标记位，作用是打开文件的时候，将文件原有内容清空；\n3.5 插入查询结果INSERT INTO table_name [(column [, column ...])] SELECT ...\n\n这个语法的作用有两个\n\n将表1的数据移植一部分到完全相同的表2（表结构要完全一致）\n将表1的数据拷贝一部分到自己，相当于新增一部分冗余数据\n\n比如我们想将一个表中的重复数据给删除，但是delete语句并没有直接与之相关的语法，这时候我们就可以采取如下措施\n\n创建与表1完全相同的表2（名字改一下）\n从表1中查询目标数据，并带上distinct对查询结果去重\n将表1查询到的这个去重后的数据插入到表2\n删除表1\n重命名表2为表1的名字\n\n以下是一个示例操作\n-- 创建原数据表CREATE TABLE duplicate_table (id int, name varchar(20));Query OK, 0 rows affected (0.01 sec)-- 插入测试数据，有重复INSERT INTO duplicate_table VALUES    (100, &#x27;aaa&#x27;),    (100, &#x27;aaa&#x27;),    (200, &#x27;bbb&#x27;),    (200, &#x27;bbb&#x27;),    (200, &#x27;bbb&#x27;),    (300, &#x27;ccc&#x27;);Query OK, 6 rows affected (0.002 sec)Records: 6  Duplicates: 0  Warnings: 0-- 创建一张空表 no_duplicate_table，结构和 duplicate_table 一样CREATE TABLE no_duplicate_table LIKE duplicate_table;Query OK, 0 rows affected (0.00 sec)-- 将 duplicate_table 的去重数据插入到 no_duplicate_tableINSERT INTO no_duplicate_table SELECT DISTINCT * FROM duplicate_table;Query OK, 3 rows affected (0.002 sec)Records: 3  Duplicates: 0  Warnings: 0-- 重命名表RENAME TABLE duplicate_table TO old_duplicate_table,no_duplicate_table TO duplicate_table;Query OK, 0 rows affected (0.00 sec)-- 查看最终结果，数据没有重复SELECT * FROM duplicate_table;+------+------+| id | name |+------+------+| 100 | aaa || 200 | bbb || 300 | ccc |+------+------+3 rows in set (0.00 sec)\n\n4.聚合函数聚合统计是间接或者直接统计列方向上的某些数据\n\n\n\n函数\n说明\n\n\n\nCOUNT([DISTINCT] expr)\n返回查询到的数据的 数量\n\n\nSUM([DISTINCT] expr)\n返回查询到的数据的 总和，不是数字没有意义\n\n\nAVG([DISTINCT] expr)\n返回查询到的数据的 平均值，不是数字没有意义\n\n\nMAX([DISTINCT] expr)\n返回查询到的数据的 最大值，不是数字没有意义\n\n\nMIN([DISTINCT] expr)\n返回查询到的数据的 最小值，不是数字没有意义\n\n\n4.1 统计班级有多少人select count(*) from students;+----------+| count(*) |+----------+|        5 |+----------+1 row in set (0.000 sec)\n\n也可以使用表达式进行统计，你会发现这里虽然是count1，但是结果依旧是5；这是因为当我们在select的目标列里面添加一个常数或者一个表达式的时候，他会追加到原有表的末尾。这里我们直接写个1，就会把1追加到表中每一行的末尾，所以最终统计出来的结果依旧是表中记录的个数！\nSELECT COUNT(1) FROM students;+----------+| COUNT(1) |+----------+|        5 |+----------+1 row in set (0.000 sec)\n\n4.2 统计班级有多少人有qq号这里能看出来NULL是不计入count的\nselect * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   || 104 | 20000 | 闰土      | NULL   || 105 |  1005 | 周树人    | NULL   |+-----+-------+-----------+--------+5 rows in set (0.000 sec)SELECT COUNT(qq) FROM students;+-----------+| COUNT(qq) |+-----------+|         1 |+-----------+1 row in set (0.000 sec)\n\n但空串是会被正常统计的，这里又一次展现出了空字符串和NULL的区别！NULL表达的意思就是这条记录的这个字段是没有数据的！\nMariaDB [hello_mysql]&gt; insert into students values (2,10123,&#x27;胡图图&#x27;,&#x27;&#x27;);Query OK, 1 row affected (0.001 sec)MariaDB [hello_mysql]&gt; select * from students;+-----+-------+-----------+--------+| id  | sn    | name      | qq     |+-----+-------+-----------+--------+|   1 | 10010 | 唐大师    | 123124 ||   2 | 10123 | 胡图图    |        || 102 | 20001 | 曹孟德    | NULL   || 103 | 20002 | 孙仲谋    | NULL   || 104 | 20000 | 闰土      | NULL   || 105 |  1005 | 周树人    | NULL   |+-----+-------+-----------+--------+6 rows in set (0.000 sec)MariaDB [hello_mysql]&gt; SELECT COUNT(qq) FROM students;+-----------+| COUNT(qq) |+-----------+|         2 |+-----------+1 row in set (0.000 sec)\n\n4.3 统计数学成绩分数的个数-- COUNT(math) 统计的是全部成绩SELECT COUNT(math) FROM exam_result;+-------------+| COUNT(math) |+-------------+|           6 |+-------------+1 row in set (0.000 sec)-- COUNT(DISTINCT math) 统计的是去重成绩数量-- 这里的DISTINCT一定要放在括号里，不然是无效的，这点从语义上也能理解；SELECT COUNT(DISTINCT math) FROM exam_result;+----------------------+| COUNT(DISTINCT math) |+----------------------+|                    5 |+----------------------+1 row in set (0.001 sec)\n\n4.4 统计数学成绩总分MariaDB [hello_mysql]&gt; SELECT SUM(math) FROM exam_result;+-----------+| SUM(math) |+-----------+|       569 |+-----------+1 row in set (0.000 sec)-- 没有结果的时候，返回NULLMariaDB [hello_mysql]&gt; SELECT SUM(math) FROM exam_result WHERE math &lt; 60;+-----------+| SUM(math) |+-----------+|      NULL |+-----------+1 row in set (0.042 sec)\n\n4.5 统计平均分SELECT AVG(chinese + math + english) 平均总分 FROM exam_result;+--------------+| 平均总分      |+--------------+| 297.5        |+--------------+\n\n你也可以将sum和count连用来达到这个效果\nSELECT SUM(chinese + math + english)/COUNT(1) 平均总分 FROM exam_result;+--------------+| 平均总分     |+--------------+|        297.5 |+--------------+1 row in set (0.001 sec)\n\n4.6 统计最高&#x2F;最低返回英语的最高分\nSELECT MAX(english) FROM exam_result;+--------------+| MAX(english) |+--------------+|          90  |+--------------+1 row in set (0.00 sec)\n\n返回大于七十分以上的数学最低分\nSELECT MIN(math) FROM exam_result WHERE math &gt; 70;+-----------+| MIN(math) |+-----------+|        73 |+-----------+1 row in set (0.001 sec)\n\n5.group by基本语法如下，含义是在select的时候对结果进行一定的分组\nselect column1, column2, .. from table group by column;\n\n5.0 测试表这里给大家准备了一个比较经典的测试表，来自oracle 9i，你可以在我的Gitee仓库找到他；\n使用ftp将这个sql传到linux里面，进入mysql的命令行，使用source 文件路径的语句，就可以将这个表里面的数据导入到mysql中；\nsource /root/scott_data.sql\n\n这个sql里面包含EMP员工表、DEPT部门表、SALGRADE工资等级表三张表结构，很方便我们进行测试；表结构如下\nMariaDB [scott]&gt; desc dept;+--------+--------------------------+------+-----+---------+-------+| Field  | Type                     | Null | Key | Default | Extra |+--------+--------------------------+------+-----+---------+-------+| deptno | int(2) unsigned zerofill | NO   |     | NULL    |       || dname  | varchar(14)              | YES  |     | NULL    |       || loc    | varchar(13)              | YES  |     | NULL    |       |+--------+--------------------------+------+-----+---------+-------+3 rows in set (0.001 sec)MariaDB [scott]&gt; desc salgrade;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| grade | int(11) | YES  |     | NULL    |       || losal | int(11) | YES  |     | NULL    |       || hisal | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+3 rows in set (0.001 sec)MariaDB [scott]&gt; desc emp;+----------+--------------------------+------+-----+---------+-------+| Field    | Type                     | Null | Key | Default | Extra |+----------+--------------------------+------+-----+---------+-------+| empno    | int(6) unsigned zerofill | NO   |     | NULL    |       || ename    | varchar(10)              | YES  |     | NULL    |       || job      | varchar(9)               | YES  |     | NULL    |       || mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       || hiredate | datetime                 | YES  |     | NULL    |       || sal      | decimal(7,2)             | YES  |     | NULL    |       || comm     | decimal(7,2)             | YES  |     | NULL    |       || deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |+----------+--------------------------+------+-----+---------+-------+8 rows in set (0.001 sec)\n\n\n\n5.1 如何显示每个部门的平均工资和最高工资select deptno,avg(sal),max(sal) from emp group by deptno;+--------+-------------+----------+| deptno | avg(sal)    | max(sal) |+--------+-------------+----------+|     10 | 2916.666667 |  5000.00 ||     20 | 2175.000000 |  3000.00 ||     30 | 1566.666667 |  2850.00 |+--------+-------------+----------+3 rows in set (0.012 sec)\n\n需要注意的是，这里的聚合函数是无法用作where的条件的，因为where的执行顺序早于聚合函数，你连数据都还没有筛选出来，怎么聚合呢？\nselect deptno,avg(sal),max(sal) from emp where avg(sal)&gt;200 group by deptno;\n\n执行的时候会报错\nMariaDB [scott]&gt; select deptno,avg(sal),max(sal) from emp where avg(sal)&gt;200 group by deptno;ERROR 1111 (HY000): Invalid use of group function\n\n另外，在老版本的mysql中，当你使用了group by之后，select的结果指定列就只能包含group by里面出现过的列，以及聚合函数；但在我当前使用的mariadb中并没有出现这个报错；\n\n5.2 显示每个部门的每种岗位的平均工资和最低工资select avg(sal),min(sal),job, deptno from emp group by deptno, job;+-------------+----------+-----------+--------+| avg(sal)    | min(sal) | job       | deptno |+-------------+----------+-----------+--------+| 1300.000000 |  1300.00 | CLERK     |     10 || 2450.000000 |  2450.00 | MANAGER   |     10 || 5000.000000 |  5000.00 | PRESIDENT |     10 || 3000.000000 |  3000.00 | ANALYST   |     20 ||  950.000000 |   800.00 | CLERK     |     20 || 2975.000000 |  2975.00 | MANAGER   |     20 ||  950.000000 |   950.00 | CLERK     |     30 || 2850.000000 |  2850.00 | MANAGER   |     30 || 1400.000000 |  1250.00 | SALESMAN  |     30 |+-------------+----------+-----------+--------+9 rows in set (0.000 sec)\n\n5.3 显示平均工资地域2000的部门和他的平均工资-- 统计各个部门的平均工资select avg(sal) from emp group by deptno-- 通过having筛选出结果select avg(sal) as myavg from emp group by deptno having myavg&lt;2000;\n\n因为聚合函数的结果无法作为where的条件，所以MySQL额外提供了一个having关键字，用于在聚合查询中对数据进一步进行筛选；这里可以看到它是可以支持别名的，所以having的语句是晚于select指定列执行的；\nselect avg(sal) as myavg from emp group by deptno having myavg&lt;2000;+-------------+| myavg       |+-------------+| 1566.666667 |+-------------+1 row in set (0.042 sec)\n\n总结\ngroup by是通过分组这样的手段，为未来进行聚合统计提供基本的功能支持\ngroup by后跟随的是分组的字段依据，只有在group by后面出现过的字段，未来在聚合统计时，才能在select中出现（新版本mysql似乎取消了此限制）\nwhere语句是在表中数据初步被筛选的时候，来起效果的\nhaving语句是在完成整个分组聚合统计后再进行筛选\n\n6.SQL各个语句执行顺序面试的时候常考，建议记住\nfrom &gt; on &gt; join &gt; where &gt; group by &gt; with &gt; having &gt; select&gt; distinct &gt; order by &gt; limit\n\n以如下的语句为例，执行顺序参考我的圆圈数字标记\nselect deptno, avg(sal) as myavg ④ from emp ① \twhere sal &gt; 1000 ②\tgroup by deptno ③\thaving myavg &lt; 2000 ⑤; \n\n7.视图在MySQL中还有一个特殊的虚拟表，被称作视图；其可以将一个select语句的查询结果视作一个新表，供我们使用；\n请注意！这里的视图要和事务中的ReadView做区分，两者毫无关系！\ncreate view 视图名 as select ...;\n\n比如在scott的测试表中，包含如下3个表；\nMariaDB [scott]&gt; show tables;+-----------------+| Tables_in_scott |+-----------------+| dept            || emp             || salgrade        |+-----------------+3 rows in set (0.001 sec)\n\n我们可以用如下语句创建一个视图\ncreate view v_ename_dname as \tselect ename, dname\tfrom emp,dept \twhere emp.deptno=dept.deptno;\n\n创建了之后，这个视图会以一个新表的形式出现在tables中\nMariaDB [scott]&gt; show tables;+-----------------+| Tables_in_scott |+-----------------+| dept            || emp             || salgrade        || v_ename_dname   |+-----------------+4 rows in set (0.000 sec)\n\n这个表的查询结果和直接执行原有的select语句是完全一致的；\n我们把视图涉及到的数据原有表叫做基表；\nMariaDB [scott]&gt; select * from v_ename_dname;+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || JONES  | RESEARCH   || MARTIN | SALES      || BLAKE  | SALES      || CLARK  | ACCOUNTING || SCOTT  | RESEARCH   || KING   | ACCOUNTING || TURNER | SALES      || ADAMS  | RESEARCH   || JAMES  | SALES      || FORD   | RESEARCH   || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.001 sec)\n\n进入MySQL的存储路径，你会发现视图只有一个.frm文件，是不会有保存数据的.ibd文件的；这也代表视图是一个变相的数据链接，并不会拷贝数据；\n[root@vm-cnt8:/var/lib/mysql/scott]# lsdb.opt  dept.frm  dept.ibd  emp.frm  emp.ibd  salgrade.frm  salgrade.ibd  v_ename_dname.frm\n\n如果修改视图，会对基表数据有影响；修改基表，也会对视图有影响；\n删除视图不会影响基表中的数据；\ndrop view 视图;\n\n7.1 视图的规则和限制\n与表一样，必须唯一命名（不能出现同名视图或表名） \n创建视图数目无限制，但要考虑复杂查询创建为视图之后的性能影响\n视图不能添加索引，也不能有关联的触发器或者默认值\n视图可以提高安全性，必须具有足够的访问权限；\norder by 可以用在查询视图的数据中，但是如果从该视图检索数据 select 中也含有 order by，那么该视图查询中的 order by 将被覆盖 \n视图可以和表一起使用\n\n8. 从文件中加载数据到对应表mariadb 支持通过 load 命令命令加载文件中的数据到对应表。命令格式如下\nLOAD DATA INFILE &#x27;/path/to/data/file&#x27; INTO TABLE my_tableFIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;&quot;&#x27;LINES TERMINATED BY &#x27;\\n&#x27;;\n\n其中 /path/to/data/file 是数据文件的路径，my_table 是要插入数据的表名。FIELDS TERMINATED BY &#39;,&#39; 指定字段之间的分隔符为逗号，ENCLOSED BY &#39;&quot;&#39; 表示字段值被双引号包围，LINES TERMINATED BY &#39;\\n&#39; 则表示行以换行符结束。\n\n比如我有一个 pc.txt 文件, 文件中的格式如下，每一行都是对齐的，每一列用空格作为分割，和字段要求对应。\n1001 2.66 1024 250 21141002 2.10 512  250 9551003 1.42 512  80  478\n\n那么在创建出来一个对应的表后，可以用如下命令来加载文件中的数据\ncreate table PC(    model integer unsigned primary key,    speed float(4,2),    ram integer unsigned,    hd integer unsigned,    price integer unsigned);\n\nLOAD DATA INFILE &#x27;/root/pc.txt&#x27;INTO TABLE PCFIELDS TERMINATED BY &#x27;\\t&#x27;(model,speed,ram,hd,price);\n\n执行后的效果如下，成功加载\nMariaDB [products]&gt; LOAD DATA INFILE &#x27;/root/pc.txt&#x27;    -&gt; INTO TABLE PC    -&gt; FIELDS TERMINATED BY &#x27;\\t&#x27;    -&gt; (model,speed,ram,hd,price);Query OK, 13 rows affected, 12 warnings (0.015 sec)  Records: 13  Deleted: 0  Skipped: 0  Warnings: 12MariaDB [products]&gt; select * from PC;+-------+-------+------+------+-------+| model | speed | ram  | hd   | price |+-------+-------+------+------+-------+|  1001 |  2.66 | 1024 |  250 |  2114 ||  1002 |  2.10 |  512 |  250 |   995 ||  1003 |  1.42 |  512 |   80 |   478 ||  1004 |  2.80 | 1024 |  250 |   649 ||  1005 |  3.20 |  512 |  250 |   630 ||  1006 |  3.20 | 1024 |  320 |  1049 ||  1007 |  2.20 | 1024 |  200 |   510 ||  1008 |  2.20 | 2048 |  250 |   770 ||  1009 |  2.00 | 1024 |  250 |   650 ||  1010 |  2.80 | 2048 |  300 |   770 ||  1011 |  1.86 | 2048 |  160 |   959 ||  1012 |  2.80 | 1024 |  160 |   649 ||  1013 |  3.06 |  512 |   80 |   529 |+-------+-------+------+------+-------+13 rows in set (0.002 sec)\n\n请注意，该命令不是万能的，很有可能出错！在加载之前，请在一个空的数据库中进行测试！\nThe end基本知识就这些了!\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【树莓派开发】使用cpolar实现内网穿透，远程连接在家里的树莓派","url":"/posts/412631379/","content":"众所周知，一般我们远程连接树莓派，需要它和我们的电脑在同一局域网下。如果出门要用树莓派的话，只能把它一并带出门。\n可如果我们想偷懒，把树莓派连上网线或wifi丢家里，然后在另外一个网络下远程连接树莓派的话，就需要借助cpolar来实现内网穿透，把树莓派变为联网的远程LINUX服务器\n\n\n\n如果你还没有配置好树莓派的基本使用环境，可以参考我的博客🚪【传送门】\n\n\n关于cpolar在树莓派上的基本配置，官方有很详细的帮助文档，但是里面有一些问题介绍的并不算清楚【官方文档连接】\n本文是对官方帮助文档的细化（很多我搜到的博客基本就是照搬官方帮助文档）\n在开始之前，请先注册一个你的cpolar账户\n\nhttps://www.cpolar.com/\n\n1.修改树莓派密码注意：使用cpolar共享的SSH接口，主机地址都是一样的，只是端口号不一样\n为了避免有小人，随机生成端口号，偷偷摸摸连接我们的树莓派搞破坏\n这里建议大家一定要先修改你的初始密码！\nsudo passwd pi\n\n2.在树莓派上初始化cpolar2.1下载用这个语句安装cpolar（国内用户）\ncurl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash\n\n或者这个语句（适用于国外用户）\ncurl -sL https://git.io/cpolar | sudo bash\n\n软件不是很大，一下子就下好了\n\n使用这个语句查看版本信息\ncpolar version\n\n如果出现下图代表已经安装OK了\n\n2.2token验证注册账号后，选择了免费界面，你就可以进入后台管理系统\n点击验证，可以找到你的隧道Authtoken\n\n复制它，然后在树莓派上用下面的语句设置token\ncpolar authtoken xxxxxxxxxxxxxxxxxx\n\n\n2.3设置cpolar开机自启和系统保护开机自启动\nsudo systemctl enable cpolar\n\n守护进程方式，启动cpolar（类似于把cpolar设置成了白名单应用）\nsudo systemctl start cpolar\n\n查看守护进程状态\nsudo systemctl status cpolar\n\n\n如图，状态为active, 说明启动状态成功\n2.4查看隧道端口cpolar会默认安装两个样例隧道，一个是Website隧道指向http 8080端口，一个是ssh隧道，指向tcp 22端口\n为了不暴露我自己的SSH连接地址，这里直接丢官方帮助文档里面的图\n\n和官方这里不同，我的后台管理中只有两个website地址和一个ssh地址\n2.5使用putty或者Xshell远程连接树莓派确认你的ssh连接后，需要在树莓派本地设置一下\nssh pi@1.tcp.vip.cpolar.cn -p 20013\n\n这里会让你填写树莓派的密码，并不是cpolar的密码\n填写完毕后，到这里已经设置完毕啦！是不是很简单？\n\n下面来试试远程使用树莓派\n假设我们的SSH地址是下面这个\ntcp://1.tcp.vip.cpolar.cn:20013\n\n那么在Xshell中的主机和端口分别就要填写\n\n主机1.tcp.vip.cpolar.cn\n端口20013\n\n然后就能连接上你的树莓派\n这里需要你输入你树莓派的用户名和密码，输入完毕后，就和局域网使用树莓派没啥区别啦！\n\n我搜资料的时候，就是这里填错了，导致一直没连上树莓派\n\n结语如果对于初始化设置cpolar有啥问题，可以在评论区留言\n复杂问题别问，我不会！！！！！😂\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【树莓派】实验01-双色LED","url":"/posts/3585041582/","content":"\n\n前言今晚上没啥事（其实作业没写完），就开始折腾树莓派了\n我当初买的是树莓派4B(4GB)版本的套件，东西还是非常全的，店家还送了全套学习资料+指导视频，加上一本还算不错的书。\n本篇博客，让我们一起来完成第一个实验：双色LED\n\n学习资料来源于：湖南创乐博智能科技有限公司\n本博客仅供参考，请勿转载！\n\n\n1.实验器材\n装好系统的树莓派开发板+电源适配器\n面包板+T型转接板\n40p软排线\n双色LED\n若干跳线\n\n\n2.实验原理将引脚S（绿色）和中间管脚（红色）链接到面包板的接口上，对树莓派进行编程控制，使LED的颜色由红变绿。并利用PWM混合成其他颜色。\n\n对应接线表格\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPI01\nGPI018\nS\n\n\nGPI00\nGPI017\nR\n\n\nGND\nGND\nGND\n\n\n实际接线图如下（手机画质也太渣了）\n\n3.控制代码当树莓派需要与外部元件相接时，要用到一些写好的库。如树莓派wiringPi库\n\n树莓派wiringPi库：wiringPi是一个很棒的树莓派IO控制库，使用C语言开发，提供了丰富的接口：GPIO控制，中断，多线程，等等\n\n还有softPwm.h库：GitHub链接\n\n本次双色LED实验需要用到的就是这两个库，以及C语言自带的库函数stdio.h\n代码如下：\n#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt;#include &lt;stdio.h&gt;#define uchar unsigned char#define makerobo_Led_PinRed    0 // 红色LED 管脚#define makerobo_Led_PinGreen  1 // 绿色LED 管脚// LED 初始化void makerobo_led_Init(void)&#123;\tsoftPwmCreate(makerobo_Led_PinRed,  0, 100);\tsoftPwmCreate(makerobo_Led_PinGreen,0, 100);&#125;// 设置LED 亮度PWM调节范围是0x00-0xffvoid makerobo_led_ColorSet(uchar r_val, uchar g_val)&#123;\tsoftPwmWrite(makerobo_Led_PinRed,   r_val);\tsoftPwmWrite(makerobo_Led_PinGreen, g_val);&#125;int main()&#123;    //初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\tmakerobo_led_Init(); // LED 初始化\twhile(1)&#123;\t\tmakerobo_led_ColorSet(0xff,0x00);   //红色\t\t\tdelay(500);                         //延时500ms\t\tmakerobo_led_ColorSet(0x00,0xff);   //绿色\t\tdelay(500);\t\tmakerobo_led_ColorSet(0xff,0x45);\t\t\tdelay(500);\t\tmakerobo_led_ColorSet(0xff,0xff);\t\t\tdelay(500);\t\tmakerobo_led_ColorSet(0x7c,0xfc);\t\t\tdelay(500);\t&#125;\treturn 0;&#125;\n\n在wiringPi库中，可以看到两个函数的使用说明\n\nCreate函数相当于初始化针脚\nWrite函数会更改该管脚的pwm值，以达到控制LED亮度的目的\n\n\n3.1显示器的PWM调光和DC调光如果你有了解过显示器的选购知识，估计听说过显示器的PWM调光和DC调光。\n使用DC调光的显示器，屏幕背光将常亮；使用PWM调光的显示器，屏幕背光将高速开关来点亮屏幕。只要PWM高于一定值，人眼就分辨不出该屏幕的闪烁。当一块显示器使用高频PWM调光时，我们认为它与DC调光没有太大的区别。\n但总的来说，使用DC调光技术的显示器更加“护眼”，而使用低频PWM调光的显示器就是极度辣眼睛（这也是有些屏幕在摄像头中会屏闪的原因）\n目前主流手机都上了OLED屏幕，该屏幕材质普遍使用的是PWM调光。部分手机厂家在屏幕设置中推出了“类DC调光选项”，其原理就是用高频PWM来模拟DC调光。\n\n如果你想了解这方面的知识，可以看看这个视频👉链接\n\n好像bb了一些和这个实验没啥关系的内容，赶快回到正题！\n\n3.2 编译代码树莓派中有两种方式编译运行我们的代码\n3.2.1直接使用Geany编译器内部选项\n\n3.2.2 使用linux语言树莓派的系统是基于linux的，我们可以使用linux中的gcc语言来编译这个.c文件\n\n在本专栏之前的博客中，有介绍过这种方式👉链接\n\n\n输入指令，你会发现系统报错显示delay函数未定义\nundefined reference to `delay`\n\n\n这是因为delay函数并不是一个C语言的库函数我，我们可以在前面自己整一个delay函数的原型\n\n第一次使用Geany编译的时候并没有报错，这是因为在Geany里面已经用生成命令引用了wiringPi库\n在Geany的build(生成)--&gt;set build commands(设置生成命令）中输入以下指令gcc -Wall -c &quot;%f&quot; -lwiringPi\n\n// 延时z毫秒的delay函数void delay(unsigned int z)&#123;    unsigned int i,j;    for(i=z;i&gt;0;i--)        for(j=110;j&gt;0;j--)            ;//利用无意义的for循环来进行延时&#125;\n\n我们在linux控制台中用cd打开文件路径后，输入如下指令\n1. gcc 01DuoColorLED.c -o GPIO -lwiringPi2. -lwiringPi选项，链接WiringPi库。\n\n第一条指令是编译程序，生成可执行文件GPIO\n\n使用./GPIO指令来执行此文件\n\n需要注意的是，用这种方法运行程序不太方便终止，你可以去掉main函数中的while循环，让变色只执行一次。\n\n所以在进行此类开发时，建议直接使用Geany编译器，因为它会生成一个前台控制面板，我们可以直接用ctrl+c停止程序\n\n奇怪的是，当我运行第一个Geany编译器生成的可执行文件时，LED会正常变色。\n但是运行第二个在linux控制台生成的GPIO文件时，却不能变色。不知道是什么原因\n\n而当我重新用Geany编译器编译这份加了delay函数定义的代码时，发现这个delay函数还是不太行啊！这灯都闪的飞快，真的有500ms吗\n\n不过这也不算什么大问题，咱们可以通过调整delay函数的定义，和调用参数来控制\n\n4.如何在使用面包板的同时使用散热小风扇原本不使用面包板的时候，小风扇可以插在板载针脚的2、3位\n\n但是现在使用了面包板，这整个针脚都被占用了，风扇往哪里插呢？\n很简单，使用两根跳线，将风扇与面包板上的5v和GND链接就行了！\n\n红线接5V\n黑线接GND\n\n\n\n结语不管如何，这次实验算是完美完成啦！\n这也是我在树莓派上做的第一个实验\n\n如果你想和我一起学习树莓派，那就关注本专栏吧！\n欢迎star本专栏代码仓库：GITEE链接\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验00-配置你的树莓派","url":"/posts/4174630598/","content":"\n\n前言为了完善本专栏的内容，这次我把树莓派的初始化配置也给大家加上。\n干货满满，跟着我一步一步配置，从无到有玩转树莓派！😋\n\n当然前提是你要有一个树莓派，2022年的树莓派价格可太魔幻了，涨价1倍，堪比显卡市场……\n\n不扯这些没用的了，本篇博客，带你走入树莓派这款小电脑的世界！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.什么是树莓派？Raspberry Pi(中文名为“树莓派”,简写为RPi，或者RasPi &#x2F; RPI\n它为学习计算机编程教育而设计，是一个只有信用卡大小的微型电脑，其系统基于Linux。 自问世以来，受众多计算机发烧友和创客的追捧，曾经一“派”难求。别看其外表“娇小”，内“芯”却很强大，视频、音频等功能通通皆有，可谓是“麻雀虽小，五脏俱全”。\n\n它是一款基于ARM的微型电脑主板，以SD&#x2F;MicroSD卡为内存硬盘，卡片主板周围有1&#x2F;2&#x2F;4个USB接口和一个10&#x2F;100 以太网接口（A型没有网口），可连接键盘、鼠标和网线，同时拥有视频模拟信号的电视输出接口和HDMI高清视频输出接口，以上部件全部整合在一张仅比信用卡稍大的主板上，具备所有PC的基本功能只需接通电视机和键盘，就能执行如电子表格、文字处理、玩游戏、播放高清视频等诸多功能。\n Raspberry Pi B款只提供电脑板，无内存、电源、键盘、机箱或连线。\n\n这种历史啥的就不说太多啦，想必大家都懒得看这种东西😂\n\n1.1什么用户适合购买树莓派学习编程？\n在淘宝搜索树莓派，你会发现绝大部分商家都挂着“0基础学习的”幌子，大肆宣传。而且宣传集中于最近挺火的python语言，对C和C++只是提一嘴。\n\n作为C&#x2F;C++方向的编程学习者，我个人建议，购买树莓派之前，需要先学习完初阶的C语言。如何量化呢，大概就是要把目前b站最火的这个C语言视频看到P24👉 传送门\n\n如果你和我一样购买的是带各类电子元件的套件。在树莓派基础实验中，主要利用的是wiringPi库，这个库和C语言自己的框架其实是没啥关系的，即便你把这个库全学完了，也不一定能精通C语言。相反，如果C语言什么都不会的话，肯定也整不明白这个库里面的函数是怎么用的。\n\n说的可能有点绝对，我的意思主要是：如果你之前没有学过编程，得先把某一个语言学完了，再来谈购买树莓派进行进阶学习的事\n\nPython同理，肯定要把基础的语法什么都学会了，再考虑购买树莓派进行进一步的学习。\n商家玩的多半也是文字游戏，“零基础学习”代表你可以零基础上手树莓派，而不能利用树莓派从0开始学习编程，这是很难的。\n\n2.如何初始化一个树莓派首先准备好咱们需要的东西\n\n树莓派开发板\n5V3A电源\nmicroSD卡（16G起步，建议32GB）\n一台能上网的windows电脑\n\n然后，我们要下好下面的一些软件\n\nPutty (SSH远程连接工具)\nAdvanced_IP_Scanner （局域网ip查找工具）\nbalenaEtcher（镜像烧录工具）\nFileZilla（文件传输工具）\nVNC-Viewer（远程桌面软件）\nnotepad++（编辑文本）\n\n树莓派的系统可以去官方下载👉官方下载站\n但是官方下载下来的系统非常纯净，几乎所有东西都要我们自己安装，包括中文输入法，编译器，以及各类需要用到的软件\n\n为方便大家的使用，这里我整理了一些要用到的软件，以及一个已经搭建好基本环境的树莓派系统，大家直接下载我这里的集合包就行了！某度云\n\n如果你想从0开始配置一个树莓派系统，可以看这个专栏学习👉传送门\n\n\n2.1 烧录系统首先将SD卡插入windows电脑，右键，格式化它\n\n很多博主这里都说要用特别的格式化软件，实际上大可不必，直接用win自带的格式化就行了\n\n然后打开balenaEtcher，选择树莓派系统镜像文件.img，然后再选择你的sd卡\n\n\n然后这个软件就会自动开始flash你的系统，你要做的就是等它自己搞定，这期间不要插拔SD卡\n\n\n搞定以后，你的SD卡会变成一个只有256mb的boot启动盘，不要担心，这是树莓派的系统已经将另外一部分磁盘给自己了\n\n右键我的电脑-管理-磁盘管理，即可看到消失的那部分容量\n\nwin10可能会提示你使用前要先格式化磁盘G，一定不要格式化！！！不然你的系统就寄了\n\n这时候我们就可以配置我们的树莓派了\n2.2 测试开机将sd卡插入树莓派（注意方向），接通电源，如果树莓派的红灯常亮，绿灯闪烁的话，那就是系统正在运行了。这时候先断开电源，进行后面的操作\n\n2.3 设置树莓派显示输出的分辨率不管你是直接让树莓派接显示器，还是用VNC来远程链接树莓派，我们都可以通过更改config文件来设置树莓派的分辨率\n\n滑倒最底部，找到hdmi_vct，它后面紧跟着的3个参数分别是分辨率的长宽，以及输出的刷新率\n\n为了减小树莓派的运算负担，我把分辨率设置的比标准1080p（1920x1080）低了一点。实际上树莓派是支持4k60输出的。\n如果你使用hdmi直接接显示器，请根据你的显示器参数来设置树莓派的输出，以防接上后无画面输出的情况\n\n其实哪怕有显示器也建议你直接使用VNC，每次都连线太麻烦了\nVNC的使用后面会讲到\n\n\n2.4 网络链接如果你有网线，直接将树莓派用网线接入网络即可。这里介绍没有网线的方法，即 将树莓派接入wifi。\n我分享的配置文件里面，有这两个WiFi配置文件\n\n使用notepad++打开wpa_supplicant.conf文件，可以看到下面的这些东西。依照图中的注释填写wifi信息即可！wifi名字和密码不要设置成中文的\n\n如果你有多个wifi，可以在原有network之后继续添加network，填写方法是一样的\ncountry=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;\tssid=&quot;zhulin&quot;\tpsk=&quot;12345678&quot;\tpriority=5&#125;network=&#123;\tssid=&quot;zadf&quot;\tpsk=&quot;12345678&quot;\tpriority=3&#125;\n\n搞定了之后，将这两个文件都放入树莓派的boot盘\n注意：树莓派开机后这两个文件会消失，如果需要更改wifi配置，写好新的文件放入boot盘即可\n\n\n如果是你家里的wifi，可以在wifi的管理后台（一般比较新的wifi都有自己的app可以管理，旧的WiFi也有网页端管理页面）找到树莓派的ip\n如果是笔记本&#x2F;手机开的热点，可以直接在热点管理里面看到已连接设备的ip。如果是手机开热点的话，需要将电脑也接入同一热点。\n校园网不算局域网，建议开热点进行操作\n\n如果你不知道怎么找树莓派的ip，直接使用之前提到的ip扫描软件Advanced_IP_Scanner就可以了！\n\n记下树莓派的ip，后续所有操作都要通过它来实现\n注意：即便是连同一个WiFi，树莓派的ip也不是一直不变的，如果在某次使用时出现无法链接的情况，请检查ip是否已经改变了\n\n2.5 Putty链接树莓派比起windows电脑的图形桌面，树莓派是一个linux小主机，使用linux的时候我们更应该学习linux命令行的使用，而不过度依赖于树莓派系统本身\nputty的使用也很简单，直接输入树莓派的ip即可，默认的端口都是22，无需更改\n\n在弹出来的界面输入用户名pi，输入密码的时候要盲打，它不会显示你输入了啥\n\n当输入完密码后，会弹出下面的界面，这就代表你的树莓派已经链接上了\n\n输入sudo raspi-config可以进入树莓派的系统设置，我们需要将VNC的服务开启，这样才能使用VNC远程链接树莓派的桌面\n\n用方向键选择5 Interfacing Options，找到VNC服务，回车选择它，会提示你是否开启（enable）VNC服务，我们选择是就可以了\n\n选择完毕后回到初始菜单，要选择下面的finish使得设置生效\n操作方法是来到P8后按方向键的左右，才能选择底部的Select和Finish\n随后输入sudo reboot重启树莓派，使得设置生效。\n到这里，putty的初始化设置就完成了\n\n2.6 VNC链接树莓派因为我的树莓派烧录的是提前搭建好基本环境的系统，所以这里面我们直接用VNCviewer来远程链接树莓派的桌面\n操作很简单，输入树莓派的ip\n\n然后在弹出的界面上输入默认用户名pi和密码raspberry即可\n\n现在你看到的就是树莓派的桌面啦，是不是和一个普通的windows电脑差不了太多呢？\n\n右键桌面可以更改壁纸\n\n\n这里的操作和使用一台电脑没啥区别，就留给大家自己尝试啦！\n\n2.7 使用filezilla软件传输文件到树莓派安装filezilla软件，它可以通过wifi在我们的windows电脑和树莓派之间传输文件\n\n链接树莓派后，这里出现了两个界面，其中左边是我们电脑里面的文件，右边是树莓派里面的文件，我们直接进行拖动操作即可\n传输完毕后，filezilla会弹出系统通知\n\n注意：这里新建文件夹的操作叫“创建目录”\n\n\n恭喜你，你的树莓派已经初始化完毕啦！可以愉快的用它学习代码了！\n不过别急着关闭本篇博客，后面还有东西呢！\n\n3.使用Xshell将树莓派作为linux主机有这么一个软件，它集成了putty和filezilla的功能，界面更好看，使用也更方便\n没错，他就是Xshell！\n\n它同样可以使用sudo raspi-config进入树莓派的系统设置，同时借助该公司的Xftp软件，它也能实现一样的传输文件功能！\n\n\n今天刚下载Xshell软件，当我把它连上树莓派的时候，感觉自己从本世纪初穿越到了2022年。这界面，终于不再是那个古早的模样了，太感动了！\n\n3.1下载Xshell点进官网的下载界面，一看，我去，只有30天试用，玩球啊！\n要是这么想，你就太年轻了\n让我们来康康右下角这里写着啥，“免费授权”！\n\n只要你填写你的姓名和邮箱号，官方就会把这两个软件的下载链接发到你的邮箱。\n\n个人用户（非商用）的话，这两个软件都是免费的！\n\n唯一的缺点就是在你关闭页面的时候，它会弹出来这样一个页面，不过这也不影响啦！\n\n3.2链接树莓派安装的步骤直接无脑下一步\n打开Xshell，这时候我们还没有设置过服务器，所以是空\n\n点击新建，进入设置服务器的界面，写入你的树莓派IP，并给这个会话起个名\n\n点击链接，会弹出来让你输入你的树莓派用户名和密码，和之前一样操作就行\n\n\n然后，他就建立链接啦！\n\n3.3编码设置点击这里的属性\n\n选择终端，找到右下角的编码，确认它是UTF-8的状态，不然中文会乱码\n\n3.4打开Xftp点击上面这个绿色的文件夹就会打开Xftp，快捷键是CTRL+ALT+F\n\n后续的操作也是直接拖动文件，没什么好说的~~\n\n4.树莓派连接面包板树莓派上有40个IO口，为了方便实验，一般会采用一个转接板把树莓派的IO信号转接出来，使用面包板进行GPIO外接。我们需要以下3个部件：\n\n40p软排线\nT型转接板\n面包板\n\n\n安装40p软排线的时候，要注意软排线上有一个小三角，它要对准树莓派USB接口的另一侧的接口，依照这个方向插入软排线。请平均用力，不要大力出奇迹！\n\n40p排线的另一端就是链接T型转接板了，链接这个就很简单，T型转接板上会有一个凹槽，对准凹槽方向插入即可\n\n然后将T型转接板对准面包板中央的孔位插入即可！G17 G18对准行号1的孔位\n\n5.进阶操作用上Xshell和面包板，你的树莓派已经是一个完全体啦！\n其他的一些操作，可以看看我的另外一个树莓派的专栏👉传送门\n\n如果本篇博客对你有帮助的话，还请点赞支持一下哦！\n\n有什么问题，欢迎在评论区提出！看到了就会回复的\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验03-七彩LED","url":"/posts/2363440807/","content":"\n\n\n\n前言学习太累，那就玩玩树莓派“陶冶情操”吧！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1.实验器材\n树莓派4B开发板\n40p软排线+T型转接板+面包板\n七彩LED模块\n跳线若干\n\n\n2.实验接线七彩LED模块内置了IC芯片，因此无需编写代码，只需通电就能看到LED闪烁。\n不同型号的七彩LED模块，内置的闪烁情况会有所区别，如闪烁快慢和亮度等\n\n七彩LED模块只需串联一个限流电阻即可构成控制电路，示意图如下\n\n所以我们接线的时候，只需接上VCC和GND即可\n\n\n\n树莓派\nT型转接板\n七彩LED模块\n\n\n\nGND\nGND\nGND(中间管脚)\n\n\n5V\n5V\nVCC(一旁标有S)\n\n\n\n前两次实验中，我对每次都需要接5v线却并没有连接设备感到疑惑\n本次实验正好印证了我在02RGBled实验博客里做出的猜测！\n实物接线图如下👇\n\n3.实验效果将电路接通，可以看到LED闪烁了7种颜色，且有不同的闪烁方式！\n\n这不比自己写代码控制的更帅？（bushi）\n如果你想知道如何用代码控制一个LED模块，可以看看我的前两篇树莓派实验的博客\n\n实验02：RGB小灯 \n实验01：双色LED\n\n结语本次实验的内容不多撒，咱也见识了内置小芯片的快乐（指不需要自己写控制代码）\n下一次的实验是继电器实验，这部分涉及到一些原理，看来要秃头了\n\n如果你觉得本篇博客挺有意思，那就点个赞，顺便收藏一下我的树莓派专栏吧！\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验02-RGB小灯","url":"/posts/178546113/","content":"\n\n前言又到了树莓派学习的时候！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n上一次的实验001-双色LED中，虽然我把博客展示了出来，写的好像有模有样的，实际上我对一些函数可谓是丝毫不懂。\n但这次不一样了，我把一些函数的基本使用给整明白了！\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板\n跳线一堆\nRGB小灯\n\n通过这次试验，我们可以基本了解一下让电脑性能提升200%的RGB的底层控制\n\n1.1树莓派运行库准备当树莓派需要与外部元件相接时，要用到一些写好的库。如树莓派wiringPi库\n\n\n树莓派wiringPi库：下载&#x2F;安装教程\n\n下载softPwm.h库：GitHub链接，安装教程见README\n\n\n\n\n2.元件接线RGBled模块的电路图如下，其与实物图是对应关系\n\n\n以下是本次实验的接线图\n\n其实这里我没搞懂这个5V是用来干什么的，因为不接好像也没有关系\n\n让我无语的是，去问店家，客服回复是“原理需要自己学习”\n看来还是得靠自己\n\n大胆猜测一下，后续的实验需要更多接5V的设备，这个5V引线就好比我们每次编写C语言都需要用stdio.h一样，是一个习惯。\n同时解释一下面包板左右两条线的作用：\n\n当你把GND用引线接到蓝色-线上，此时那一排都是GND\n当你把5V用引线接到红色+上，红色一排都是5V了\n\n这就相当于串联线路\n\n\n3.函数解释这里需要用到两个函数： softPwmCreate和softPwmWrite\n上篇博客中我只给出了这两个函数的解释文档（偷懒），这篇博客让我们来真切认识一下这两个函数的作用\n\n以下是函数原型，以及官方解释的翻译\nint softPwmCreate (int pin, int initialValue, int pwmRange) ;\n\n这将创建一个软件控制的PWM引脚。您可以使用任何GPIO引脚，引脚编号将与您使用的wiringPiSetup()函数相同。\ninitialValue是初始值，如果pwmRange使用100，那么给定引脚的值可以是0（关闭）到100（完全打开）之间的任何值。 返回值为0表示成功，-1代表失败。\n如果还有其他情况，您应该检查全局errno变量，看看哪里出了问题。\nvoid softPwmWrite (int pin, int value) ;\n\n更新给定引脚pin上的PWM值。该值将被检查是否在范围pwmRange内\n未通过softPwmCreate初始化的管脚将被忽略\n后续还有一个Note：\n\n\n\nPWM输出的每个“周期”需要10毫秒，默认范围值为100，因此尝试每秒更改PWM值超过100次将是徒劳的\n\n在softPWM模式下激活的每个引脚使用大约0.5%的CPU\n\n目前无法在程序运行时禁用引脚上的softPWM\n\n您需要保持程序运行以保持PWM输出！\n\n\n\n3.1关于softPwmWrite的使用问题，大大的疑惑这里我产生了一个巨大的疑惑，就是softPwmWrite函数的第二个参数究竟应该如何使用\n\n这个问题我在CSDN的问答区提问了，22.04.01的17:00目前还没有回复👉点我\n\n可以看到下面这位大佬的程序中，是将第二个参数设置到超过了100\n\n引用自博客https://www.cnblogs.com/demo-lv/p/14017488.html\n\n\n而参考资料中，提供的代码也是将pwm值设置超过了100\n\n在查询过一些资料（是真的没有博客提到过这个问题），我找到了RGB颜色对照表\n这个代码中提供的参数设置，其实是参照RGB表来设置的\n\n\n也就是说，如果想达到混色的效果，你需要利用softPwmWrite函数将红绿蓝针脚与RGB表中的数值对应进行输出。\n但这不就和官方的pwm值应该在范围内，且超过100的pwm值都是无效的，冲突了吗？\n\n这个问题先暂时放在这里，蹲一个大佬解释\n\n4.代码样例4.1初始化针脚#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt;#include &lt;stdio.h&gt;#define makerobo_Led_PinRed    0 // 红色LED 管脚#define makerobo_Led_PinGreen  1 // 绿色LED 管脚#define makerobo_Led_PinBlue   2 // 蓝色LED 管脚// LED 初始化void makerobo_led_Init()&#123;//第三个参数是range，将pwm设置成100（全开）\tsoftPwmCreate(makerobo_Led_PinRed,  0, 100);\tsoftPwmCreate(makerobo_Led_PinGreen,0, 100);\tsoftPwmCreate(makerobo_Led_PinBlue, 0, 100);&#125;\n\n你可能会想，为什么这里要把红绿蓝的管脚设置成0、1、2，实际上这里和面包板的接线是对应的\n\n可以看到，GPIO 0/1/2分别对应的是17/18/27，同我们第2点中接线图上的针脚位置对应\n\n4.2颜色参数设置初始化针脚之后，我们就来设置各个针脚的参数\n// LED 颜色设置void makerobo_led_Color_Set(uchar r_val, uchar g_val, uchar b_val)&#123;//对应不同颜色针脚的设置，如果需要红色，就只给红色r_val传对应值 //给不同颜色输入不同值，达成混色的效果！\tsoftPwmWrite(makerobo_Led_PinRed,   r_val);\tsoftPwmWrite(makerobo_Led_PinGreen, g_val);\tsoftPwmWrite(makerobo_Led_PinBlue,  b_val);&#125;//函数使用如下makerobo_led_Color_Set(0xff,0x00,0x00);   //红色\tdelay(500);   //延时500ms，使更改便于观察makerobo_led_Color_Set(0x00,0xff,0x00);   //绿色delay(500);                makerobo_led_Color_Set(0x00,0x00,0xff);   //蓝色delay(500);\n\n4.3完整代码及效果演示下面给出完整代码，以及最终的效果、\n#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt;#include &lt;stdio.h&gt;#define uchar unsigned char#define makerobo_Led_PinRed    0 // 红色LED 管脚#define makerobo_Led_PinGreen  1 // 绿色LED 管脚#define makerobo_Led_PinBlue   2 // 蓝色LED 管脚// LED 初始化void makerobo_led_Init()&#123;//第三个参数是range，将pwm设置成100（全开）\tsoftPwmCreate(makerobo_Led_PinRed,  0, 100);\tsoftPwmCreate(makerobo_Led_PinGreen,0, 100);\tsoftPwmCreate(makerobo_Led_PinBlue, 0, 100);&#125;// LED 颜色设置void makerobo_led_Color_Set(uchar r_val, uchar g_val, uchar b_val)&#123;//对应不同颜色针脚的设置，如果需要红色，就只给红色r_val传对应值 //给不同颜色输入不同值，达成混色的效果！\tsoftPwmWrite(makerobo_Led_PinRed,   r_val);\tsoftPwmWrite(makerobo_Led_PinGreen, g_val);\tsoftPwmWrite(makerobo_Led_PinBlue,  b_val);&#125;int main()&#123;    //初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123;\t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\tmakerobo_led_Init();\t\tint n=0;\tprintf(&quot;请输入循环周期的次数&gt;&quot;);\tscanf(&quot;%d&quot;,&amp;n);//输入循环周期的次数\twhile(n--)\t&#123;\t\tmakerobo_led_Color_Set(0xff,0x00,0x00);   //红色\t\t\tdelay(500);   //延时500ms，使更改便于观察\t\tmakerobo_led_Color_Set(0x00,0xff,0x00);   //绿色\t\tdelay(500);                   \t\tmakerobo_led_Color_Set(0x00,0x00,0xff);   //蓝色\t\tdelay(500);\t\tmakerobo_led_Color_Set(0xff,0xff,0x00);   //黄色\t\tdelay(500);                 \t\tmakerobo_led_Color_Set(0xff,0x00,0xff);   //粉色\t\tdelay(500);     \t\tmakerobo_led_Color_Set(0xff,0xff,0xff);   //白色\t\tdelay(500);       \t\tmakerobo_led_Color_Set(0x94,0x00,0xd3);   //紫色\t\tdelay(500);\t\tmakerobo_led_Color_Set(0x76,0xee,0x00);   //偏黄色\t\tdelay(500);\t\tmakerobo_led_Color_Set(0x00,0xc5,0xcd);\t  //淡蓝色\t\tdelay(500);\t&#125;\t\t//最后循环结束时，关闭LED（如果不这么设置，LED灯会停留在最后一个颜色）\tmakerobo_led_Color_Set(0x00,0x00,0x00);\t//参数都为0,相当于关灯\tdelay(500);//如果不延时，效果无法展示出来\t\treturn 0;&#125;\n\n使用树莓派Geany编译器，三板斧点起来\n\n最后的结果如下图~~RGB小灯变色循环成功！\n\n\n4.4 Linux-GCC编译器指令Geany已经可以很好地执行我们的程序了，但它未免有点太easy了，点几下按钮就能搞定\n我们来试试需要敲语句的GCC编译器\n首先依旧是用cd打开源文件的目录\ncd 打开源文件存放的目录ls 列出当前文件路径下的所有文件\n\n使用wiringPi库和softPWM库需要加上两个指令\n\nwiringPi库对应：-lwiringPi\nsoftPWM库对应：-lpthread\n\n在linux的gcc中使用delay函数需要调用另外一个头文件&lt;unistd.h&gt;\ngcc -Wall 02rgbled.c -o TEST -lwiringPi -lpthread\n\n如果没有报错的话，那就是编译成功了，再次ls可以看到多出来了一个TEST可执行文件\n\n./TEST 执行TEST文件\n\n可以看到程序正常运行了！\n\n\n结语第二个树莓派实验也做完啦！\n虽然还有问题没有解决，但我还是很开心的\n\n如果对你有帮助，还请点个大大的👍！有什么问题可以评论区提出来哦\n\n通往大佬的路非常漫长……\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验04-继电器","url":"/posts/3764013947/","content":"\n\n\n\n前言学习树莓派的时候经常要查找前辈们留下的资料\n\n但我发现，有一些博客，写的真的不敢恭维。\n无注释源码一贴，电路图一贴，什么解释都没有，就发出来了。\n这是写给谁看的？恐怕自己过几个月回头看自己都不知道那是什么意思。这样的学习有啥意义呢？\n\n有的人可能觉得我是想抄作业，的确！嵌入式学习需要了解各个元件的工作原理，我的资料单有电路图远远不够啊……即便有源码，也需要自己去弄明白每个函数的作用，不然这样的学习依旧没有意义😥\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n继电器模块+十字螺丝刀\n双色LED模块（实验1使用过）\n跳线一堆\n\n2.实验原理2.1继电器模块继电器模块是一种电控制期间，当输入量的变化达到规定要求时，在电气输出电路中使被控制量发生预定阶跃变化的一种电器。它具有控制系统和被控制系统之间的互动关系，通常运用于自动化的控制电路中。它实际上是用小电流去控制大电流运作的一种“自动开关”，在电路中起到自动调节、安全保护、转换电路等作用。\n\n说人话就是，继电器是一个电动开关，通过接收外部源的电信号来打开和关闭电路。\n例如：按下电视机遥控器的开启按钮，它向电视节内部的“继电器”发出电信号，从而打开电视机的主电源开关。不过电视机内部还有另外的信号接收器，继电器本身不一定能接收红外信号（个人理解）\n\n2.2继电器工作\n当继电器供电时，电流开始经过控制线圈\n电磁体开始通电，将上部衔铁吸附到线圈上，带动触点向右移动，从而与常开触点链接\n带负载的电路通电\n继电器断开供电，弹簧会将触头复位，电路断开\n\n\n\n3.电路图和接线图3.1电路图继电器模块的电路图如下\n\n模块实物图如下\n\n\n引用另外一篇博客对各个接口的介绍👉原文链接\n\n\n3.2接线图继电器的主控制型号源接在GPIO17，和端口0对应（后面代码会用到）\n\n\n\n\n树莓派\nT型转接板\n继电器模块\n\n\n\nGPIO 0\nGPIO 17\nIN\n\n\n5V\n5V\nDC+\n\n\nGND\nGND\nDC-\n\n\n5V\n5V\nCOM\n\n\n\n\n\n双色LED\nT型转接板\n继电器\n\n\n\n中间（R）\n*\nNC\n\n\nGND\nGND\n*\n\n\nS(G)\n*\nNO\n\n\n由于双色LED模块的G接口(Green)接到了继电器的常闭端口NC（即继电器未接通时默认接上的端口）\n所以在接线完毕后，LED模块会亮绿灯\n\n这里需要注意的是，在对继电器接线的时候，需要用螺丝锁住各条线位，不然它们是接不稳的\n\n\n4.代码示例这里给出C语言的代码\n#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_RelayPin 0 //设置继电器GPIO管脚，0对应G17int main()&#123;    //初始化连接失败时，将消息打印到屏幕\t\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\t\t//将继电器管脚设置为输出模式\tpinMode(makerobo_RelayPin, OUTPUT);\t\tint k=2;\twhile(k--)\t&#123;\t\t\tdigitalWrite(makerobo_RelayPin, HIGH); // 打开继电器\t\t\tdelay(1000);                           // 延时1s\t\t\t\t\tdigitalWrite(makerobo_RelayPin, LOW);  // 关闭继电器\t\t\t\t\t\tdelay(1000);                           // 延时1s\t&#125;\treturn 0;&#125;\n\n4.1部分函数解释4.1.1pinMode该函数的作用是设置针脚当前的模式\n\n4.1.2digitalWrite可以看到，这里提到了在使用该函数之前，需要用pinMode函数将针脚设置为OUTPUT模式\n\n0 代表low值\n非0都代表high\n\n\n4.2Geany编译器运行代码老样子，三板斧\n\n\n在Geany里面用生成命令引用wiringPi库（后续的博客不再说明）\n在Geany的build(生成)--&gt;set build commands(设置生成命令）中输入以下指令gcc -Wall -c &quot;%f&quot; -lwiringPi\n\n最终运行的效果如下，当digitalWrite写入high时，继电器接通，红灯电路亮起\n写入low时继电器关闭，恢复原本绿灯常亮状态\n\n使用ctrl+c关闭程序运行面板，停止程序运行\n\n4.3Linux-gcc编译器在linux控制台里面，用cd打开你的文件夹后，输入如下编译指令\ngcc -Wall 04relay.c -o TEST -lwiringPi\n\n如果编译没有报错，那就是成功编译了，ls会发现多出了TEST可执行文件，使用./TEST执行它\n执行结束后，会显示下一行的待定输入\n\n为了避免linux-gcc中程序运行后无法终止，请不要使用while(1)死循环！\n使用结束后请先断开5V跳线后，再断开其他跳线\n\n结语本实验只是简单演示了继电器的使用，再后续更复杂的实验中，我们可以使用它控制更复杂的模块\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验05-激光传感器","url":"/posts/3386580555/","content":"\n\n前言我手头的资料上，又说了一堆和本实验相关但又毫不相关的内容\n还是得自己找资料才能确认我的“猜想”，具体是啥，且往下细看！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n激光传感器模块（其实只是一个发射器）\n跳线若干\n\n2.实验原理激光传感器常见于测距用途。它由激光发射器、激光检测器和测量电路组成。它的优点是能够实现无接触远距离测量，速度快，精度高，量程大。\n激光传感器模块由一个650nm红色激光二极管头和一个电阻器组成\n\n激光传感器工作时，先由激光发射二极管对准目标发射激光脉冲。经目标反射后激光向各方向散射。部分散射光返回到传感器接收器，被光学系统接收后成像到雪崩光电二极管上。雪崩光电二极管是一种内部具有放大功能的光学传感器，因此它能检测极其微弱的光信号，并将其转化为相应的电信号。\n\n书上介绍了这么一堆，弄的好像这个小家伙就集成了上面3个传感器一样。我刚看书的时候，一脸懵逼，这么小一个玩意就能测距？自己找了资料才能勉强确认，它就是一个单纯的激光发射器罢了。\n\n作为一个萌新，书上的内容的确对我产生了误导，还需要自己查阅资料，有点浪费时间。\n\n\n2.1电路图\n2.2接线图\n\n\n树莓派\nT型转接板\n激光传感器模块\n\n\n\nGIPO 0\nGPIO 17\nSIG(S)\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND(-)\n\n\n\n实物接线图如下，本实验接线比较简单\n\n右上角的红黑线是接给树莓派散热风扇的，和本实验无关\n\n\n\n3.代码示例老样子，给出C语言代码。\n#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_LaserPin 0  //定义激光传感器管脚int main()&#123;\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\t\tpinMode(makerobo_LaserPin, OUTPUT); // 激光传感器设置为输出模式\t\tint k=2;\twhile(k--)\t&#123;\t\tdigitalWrite(makerobo_LaserPin, HIGH); //打开激光传感器\t\tdelay(1000); //延时1s                           \t\tdigitalWrite(makerobo_LaserPin, LOW);  //关闭激光传感器\t\tdelay(1000); //延时1s    \t&#125;\t\tdigitalWrite(makerobo_LaserPin, LOW); //循环结束后，恢复关闭状态\tdelay(500); \t\treturn 0;&#125;\n\n\n代码中的两个wiringPi函数在上篇实验博客中有讲解👉传送\n\n3.1Genay编译器老样子，三板斧（其实这句话都是从之前的博客复制过来的😂）\n\n\n在Geany里面用生成命令引用wiringPi库\n在Geany的build(生成)--&gt;set build commands(设置生成命令）中输入以下指令gcc -Wall -c &quot;%f&quot; -lwiringPi\n\n效果如下，激光发射器在延时后不断开关\n请不要将激光发射器对准任何人！伤眼！！！\n\n\n3.2LinuxGcc编译器\n为了防止Linux-Gcc环境中无法正常终止程序，建议不要使用while(1)死循环。你可以将k设置得大一点，方便观察实验结果\n\ncd打开对应文件路径，ls显示当前路径下的文件\n输入以下指令编译代码，生成可执行文件TEST\ngcc -Wall 05laser.c -o TEST -lwiringPi\n\n./TEST运行可执行文件\n\n如果没有报错，那就是编译成功了，你可以观察到相同的实验结果\n结语欸这博客都看到这里了，怎么不点关注啊？\n就算你不想关注我，那就关注一下专栏嘛！👉传送门\nTNND！关注，为什么不关注！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验06-轻触开关实验","url":"/posts/854191546/","content":"\n\n前言书上的代码示例可太牛了，不仅没用字符串比较函数strcmp，还是指针直接和字符串对比😥\n\n学习还得帮书本纠错，问店家客服也是一问三不知。\n不多说了，一起开始本次的实验吧！👍\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派\n40P软盘线+T型转接板+面包板\n轻触开关按键模块\n双色LED模块\n一堆跳线\n\n\n上：双色LED模块；下：轻触开关模块\n\n2.实验原理2.1电路图使用轻触开关作为树莓派的输入设备，按下开关时，树莓派GPIO端口检测到低电平(0v)，表示按键被按下。松开按键时，树莓派检测到高电平(3.3v)\n在本次实验中，将通过打印信息提示按键是否被按下。\n轻触开关模块电路图如下：\n\n2.2接线\n\n\n树莓派\nT型转接板\n轻触开关\n\n\n\nGPIO 0\nGPIO 17\nSIG(S)\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND(-)\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n在实验2的博客中，已经提到过树莓派针脚编号和T型转接板上编号的对应关系\n在树莓派系统控制栏中，我们可以输入以下指令查看树莓派的GPIO接口\ngpio readall\n\n可以看到，17对应0，18对应1，27对应2。和我们的接线方式和初始化针脚的编号是对应的\n\n本次实验的接线图如下，注意各个端口的接线关系\n\n右上角红黑线是树莓派的散热风扇，和实验无关\n\n\n\n3.程序示例以下给出C语言的示例代码\n//轻触开关按键实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define makerobo_BtnPin\t\t0   // 轻触按键PIN口#define makerobo_Rpin\t\t1   // 红色LED灯模块PIN#define makerobo_Gpin\t\t2   // 绿色LED灯模块PIN//双色LED控制函数void double_colorLED(char* color)&#123;\tpinMode(makerobo_Rpin, OUTPUT);  //设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT);  //设置为输出模式    \tif (!strcmp(color,&quot;RED&quot;))     //点亮红色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH); \t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (!strcmp(color,&quot;GREEN&quot;)) //点亮绿色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;makerobo Double color LED Error\\n&quot;);&#125;int main()&#123;\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed!\\n&quot;);\t\treturn 1; \t&#125;    //轻触按键Pin设置为输入模式\tpinMode(makerobo_BtnPin, INPUT);\tdouble_colorLED(&quot;GREEN&quot;);\t\twhile(1)\t&#123;\t\t//轻触按键去除抖动处理\t\tif(0 == digitalRead(makerobo_BtnPin))\t\t&#123;   // 按键有按下\t\t\tdelay(10);   // 延时去抖动\t\t\tif(0 == digitalRead(makerobo_BtnPin))\t\t\t&#123;\t\t\t\tdouble_colorLED(&quot;RED&quot;);\t   // 点亮红色LED灯\t\t\t\tprintf(&quot;Button is pressed\\n&quot;); // 打印出有按键按下\t\t\t&#125;\t\t&#125;\t\telse if(1 == digitalRead(makerobo_BtnPin))\t\t&#123; // 没有按键按下亮绿灯\t\t\tdelay(10);\t\t\tif(1 == digitalRead(makerobo_BtnPin))\t\t\t&#123;\t\t\t\tdouble_colorLED(&quot;GREEN&quot;);   // 点亮绿色LED灯\t\t\t\tprintf(&quot;No Button is pressed\\n&quot;); // 没有按键按下\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.1部分函数解析一些函数在之前的博客中已具体介绍过，这里简单列出它们的功能\n\n\n\n函数\n作用\n\n\n\nvoid pinMode(int pin, int mode)\n设置针脚模式（输入、输出、脉冲输出、GPIO时钟）\n\n\nvoid digitalWrite(int pin, int value);\n向指定管脚写入高&#x2F;低电平信号，使用前需要设置管脚为输出模式\n\n\n这里有个新的函数，作用是读取管脚的值\n在本实验中用于接收轻触开关的按钮信号\n\n3.2 Geany编译器运行运行程序，代码会循环打印“没有按键按下”，LED亮绿灯\n\n按下按键后，打印显示“按键已按下”，LED亮红灯\n\n实验效果如下\n\n3.3Linux-Gcc编译器在命令行中输入以下编译指令，生成可执行文件\ngcc -Wall 06Button.c -o TEST -lwiringPi\n\n运行可执行文件后，可以观测到相同结果\n\n3.4程序优化我个人觉得这个程序用while(1)死循环并不是那么的优，程序需要手动CTRL+C终止，且终止后无法关闭LED灯。\n下面对程序做出一些优化\n\n依旧可以试试判断按键按下情况\n在程序运行后，关闭小灯\n\n只需更改循环体和延时函数即可，在循环结束后，使用digitalWrite输入低电平关闭小灯的红&#x2F;绿管脚，即完全关闭双色LED\nint k=40;while(k--)&#123;\t//轻触按键去除抖动处理\tif(0 == digitalRead(makerobo_BtnPin))\t&#123;   // 按键有按下\t\tdelay(500);   // 延时去抖动\t\tif(0 == digitalRead(makerobo_BtnPin))\t\t&#123;\t\t\tdouble_colorLED(&quot;RED&quot;);\t   // 点亮红色LED灯\t\t\tprintf(&quot;Button is pressed\\n&quot;); // 打印出有按键按下\t\t&#125;\t&#125;\telse if(1 == digitalRead(makerobo_BtnPin))\t&#123; // 没有按键按下亮绿灯\t\tdelay(500);\t\tif(1 == digitalRead(makerobo_BtnPin))\t\t&#123;\t\t\tdouble_colorLED(&quot;GREEN&quot;);   // 点亮绿色LED灯\t\t\tprintf(&quot;No Button is pressed\\n&quot;); // 没有按键按下\t\t&#125;\t&#125;&#125;//关闭LEDdigitalWrite(makerobo_Rpin, LOW);digitalWrite(makerobo_Gpin, LOW);delay(500);//延时查看关闭情况return 0;\n\n\n结语本次实验学习了轻触开关的使用方法，在未来的实验中，可以使用它来控制一些更复杂电路的开合\n\n你学费了吗？\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验07-倾斜开关","url":"/posts/2803202558/","content":"\n\n前言昨天补全了树莓派初始化的博客，本专栏的模块就算是全啦！\n欢迎大家把本专栏推荐给其他有兴趣学习树莓派的朋友！\n\n从本博客开始，将不再讲述Geany编译器的简单操作，所有操作都用linux命令行解决\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n倾斜传感器模块\n双色LED模块\n跳线一堆\n\n\n上：倾斜传感器；下：双色LED\n\n2.实验原理在倾斜开关中，有一个金属球，它用于检测小角度的倾斜。倾斜开关模块的结构为双向传到的球形倾斜该关。只要倾斜度的力满足条件，开关就会通电，从而输出低电平信号。\n\n2.1实验接线\n\n\n树莓派\nT型转接板\n倾斜开关\n\n\n\nGPIO 0\nGPIO 17\nDo\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n\n2.2实物接线图\n接上排线后，倾斜开关模块的PWR-LED指示灯亮起\n\n当检测到倾斜角度改变时，DO-LED也会亮起，这时Do管脚将输出低电平，对应值为0。后续程序的编写将用到这个原理\n\n\n3.代码示例下面给出C语言的示例代码\n//倾斜传感器实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_TiltPin\t0 //倾斜传感器管脚定义#define makerobo_Rpin\t\t1 //红色LED模块管脚定义#define makerobo_Gpin\t\t2 //绿色LED模块管脚定义//双色LED控制函数void double_colorLED(char* color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); //设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); //设置为输出模式\tif (color == &quot;makeroboRED&quot;)     //点亮红色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (color == &quot;makeroboGREEN&quot;) //点亮绿色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;Double color LED Error&quot;);&#125;int main(void)&#123;\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123;\t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    //倾斜传感器Pin设置为输入模式\tpinMode(makerobo_TiltPin, INPUT);\tdouble_colorLED(&quot;makeroboGREEN&quot;);\t\twhile(1)&#123;\t\t//如果没有检测到倾斜，输出高电平1\t\t//检测到了之后，输出高电平0\t\tif(0 == digitalRead(makerobo_TiltPin))\t\t&#123;     //倾斜传感器发生倾斜\t\t\tdelay(10); //倾斜传感器去除抖动处理\t\t\tif(0 == digitalRead(makerobo_TiltPin))&#123;\t\t\t\tdouble_colorLED(&quot;makeroboRED&quot;); // 点亮红色LED灯\t\t\t\tprintf(&quot;Tilt!\\n&quot;);   // 打印出出现倾斜\t\t\t&#125;\t\t&#125;\t\telse if(1 == digitalRead(makerobo_TiltPin))\t\t&#123; // 倾斜传感器没有发生倾斜\t\t\tdelay(10);\t\t\tif(1 == digitalRead(makerobo_TiltPin))&#123;\t\t\t\twhile(!digitalRead(makerobo_TiltPin));\t\t\t\tdouble_colorLED(&quot;makeroboGREEN&quot;);  // 点亮绿色LED灯\t\t\t\tprintf(&quot;No Tilt!\\n&quot;);  // 打印没有出现倾斜\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.1部分代码解释去抖动操作因为倾斜开关和轻触开关都是物理结构，需要有一定的延时来进行去抖动操作\n\n直接用==比较字符串(color == &quot;makeroboGREEN&quot;) \n\n这里用到了==直接比较字符串，之前我以为这样写是错误的，因为Linux-gcc报错了（但是可以编译出可执行文件，也能正常运行）\n\n实际上这个在VS下是可以正常运行的，不会报错\n\n个人理解，这样直接传入字符串的操作，实际上是在函数中创建了一个形参color，接收了传过来的常量字符串，随后的==比较的其实是内存中的字符串的地址，而不是直接比较字符串本身\n\n这个代码里面包含的wiringPi函数，在之前的博客中已经讲解过了，详情可以看实验06👉传送门\n如果有不懂的，可以在评论区提出！\n\n\n3.2 Linux编译运行代码输入以下语句编译这个代码，生成可执行文件TEST\ngcc -Wall 07tiltswitch.c -o TEST -lwiringPi\n\n./TEST运行这个文件，按CTRL+C终止程序\n\n3.3运行效果抬起倾斜开关，LED亮绿灯。放下它后，变成默认的红灯\n\n结语本次实验到这里就结束啦！感觉这个倾斜开关就是手机中陀螺仪的青春版。\n目前我设想的是，以后的小车实验中可以通过它来判断小车现在是在上坡还是在平地，如果在上坡，就加大马达的输出。嗯，应该是这样！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验09-蜂鸣器模块","url":"/posts/2377108764/","content":"\n\n前言最近学习激情不是很高，虽然代码学了很多，但是高数和大物直接摆烂了，呜呜呜呜\n\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n有源蜂鸣器\n无源蜂鸣器\n一堆跳线\n\n\n下：有源蜂鸣器；上：无源蜂鸣器\n它们的外观几乎一样。如果是没有装配好的单独模块，无源蜂鸣器底部的电路引脚带有绿色pcb，而有源蜂鸣器底部是黑色塑料外壳。因为模块已经焊接到了电路板上，所以我们看不到它们的底部引脚。\n\n2.实验原理蜂鸣器属于声音模块。有源蜂鸣器常用于发出单一的提示性报警声音，没有频率变化，内置振荡器；无源蜂鸣器的驱动方式为频率脉冲驱动，可以发出各种有频率的信号声音。\n\n有源蜂鸣器内部有一个简单的振荡电路，能将恒定的直流电转化成一定频率的脉冲信号，程序控制方便但频率固定，单片机一个高低电平就可以让其发出声音。\n无源蜂鸣器和电磁扬声器一样没有内部驱动电路，需要接在音频输出电路中才能发声。如果给直流信号是不响的，因为磁路恒定，必须用2K-5K的方波去驱动它。声音频率可控，可以做出“多来米发索拉西”的效果。\n在一些特例中，可以和LED复用一个控制口。\n\n它们的电路原理图是一样的，只是控制方式不同\n\n因为有两个不同的模块，所以下文将分开讲解\n3.有源蜂鸣器模块有源蜂鸣器有内置振荡源，只需要接线就会发出蜂鸣声，但它的发声是固定频率的。这点和内置了控制芯片的七彩LED模块很相似。\n\n\n\n树莓派\nT型转接板\n有源蜂鸣器\n\n\n\nGPIO 0\nGPIO 17\nI&#x2F;O\n\n\n3.3V\n3.3V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n在连接上电路后，有源蜂鸣器就会哔哔哔叫。我们可以通过控制输入电平的高低，来控制它的开关\n3.1代码示例//有源蜂鸣器#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_BuzzerPin  0  // 有源蜂鸣器管脚定义int main()&#123;    //初始化连接失败时，将消息打印到屏幕    if(wiringPiSetup() == -1)&#123;         printf(&quot;setup wiringPi failed !&quot;);        return 1;      &#125;       pinMode(makerobo_BuzzerPin,  OUTPUT); // 有源蜂鸣器设置为输出模式    // 无限循环    while(1)    &#123;               digitalWrite(makerobo_BuzzerPin, LOW);        \t// 蜂鸣器为低电平触发，所以使能蜂鸣器让其发声            delay(100);           // 延时100ms            digitalWrite(makerobo_BuzzerPin, HIGH);         \t// 蜂鸣器设置为高电平，关闭蜂鸣器            delay(100);           // 延时100ms    &#125;       return 0;&#125;\n\n3.2编译代码第一次编译这个代码的时候，出现了下面的报错。意思其实很简单，就是wiringPi库没有连接上，因为我忘记在最末尾加上-lwiringPi了\n\n正确的编译指令如下\ngcc 09activebuzzer.c -o ACTIVE -lwiringPi\n\n编译成功\n\n3.3实验效果改变delay函数的参数，就能听到蜂鸣器声音的变换。设置成delay(1000)可以延长声音效果\n\n第一次接线的时候，我不小心把它接在了5v的管脚上，导致输入高电平并不能关闭蜂鸣器，而是近似于改变了蜂鸣器的频率（我听不出是音量变了还是频率变了）\n修正错误，接线在3.3v管脚上后，有源蜂鸣器可以正常关闭\n\n总所周知，图片是没有声音的。所以我把两个情况的录音文件都放在了gitee仓库👉传送门\n\n4.无源蜂鸣器无源蜂鸣器可以通过输入pwm来控制发声频率\n它的接线方式和有源蜂鸣器相同\n\n\n\n树莓派\nT型转接板\n无源蜂鸣器\n\n\n\nGPIO 0\nGPIO 17\nI&#x2F;O\n\n\n3.3V\n3.3V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n4.1代码示例//无源蜂鸣器#include &lt;wiringPi.h&gt;#include &lt;softTone.h&gt;#include &lt;stdio.h&gt;#define makerobo_BuzPin    0 // 有源蜂鸣器管脚定义// 音谱定义// 低C音符的频率#define  Tone_CL1  131#define  Tone_CL2  147#define  Tone_CL3  165#define  Tone_CL4  175#define  Tone_CL5  196#define  Tone_CL6  221#define  Tone_CL7  248// 中C音的频率#define  Tone_CM1  262#define  Tone_CM2  294#define  Tone_CM3  330#define  Tone_CM4  350#define  Tone_CM5  393#define  Tone_CM6  441#define  Tone_CM7  495// 高C音符的频率#define  Tone_CH1  525#define  Tone_CH2  589#define  Tone_CH3  661#define  Tone_CH4  700#define  Tone_CH5  786#define  Tone_CH6  882#define  Tone_CH7  990// 第一首歌音谱int makerobo_song_1[] = &#123;Tone_CM3,Tone_CM5,Tone_CM6,Tone_CM3,Tone_CM2,Tone_CM3,Tone_CM5,Tone_CM6,Tone_CH1,Tone_CM6,Tone_CM5,Tone_CM1,Tone_CM3,Tone_CM2,                         Tone_CM2,Tone_CM3,Tone_CM5,Tone_CM2,Tone_CM3,Tone_CM3,Tone_CL6,Tone_CL6,Tone_CL6,Tone_CM1,Tone_CM2,Tone_CM3,Tone_CM2,Tone_CL7,                         Tone_CL6,Tone_CM1,Tone_CL5&#125;;// 第一首歌节拍int makerobo_beat_1[] = &#123;1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,                         1,1,1,1,1,1,3&#125;;// 第二首歌音谱int makerobo_song_2[] = &#123;Tone_CM1,Tone_CM1,Tone_CM1,Tone_CL5,Tone_CM3,Tone_CM3,Tone_CM3,Tone_CM1,Tone_CM1,Tone_CM3,Tone_CM5,Tone_CM5,Tone_CM4,Tone_CM3,Tone_CM2,                         Tone_CM2,Tone_CM3,Tone_CM4,Tone_CM4,Tone_CM3,Tone_CM2,Tone_CM3,Tone_CM1,Tone_CM1,Tone_CM3,Tone_CM2,Tone_CL5,Tone_CL7,Tone_CM2,Tone_CM1                        &#125;;// 第二首歌节拍int makerobo_beat_2[] = &#123;1,1,1,3,1,1,1,3,1,1,1,1,1,1,3,1,1,1,2,1,1,1,3,1,1,1,3,3,2,3&#125;;int main()&#123;    int i;    //初始化连接失败时，将消息打印到屏幕    if(wiringPiSetup() == -1)&#123;        printf(&quot;makerobo setup wiringPi failed !&quot;);        return 1;    &#125;    //软件模拟Tone库初始化识别，将消息打印到屏幕    if(softToneCreate(makerobo_BuzPin) == -1)&#123;        printf(&quot;makerobo setup softTone failed !&quot;);        return 1;    &#125;    while(1)&#123;        printf(&quot;makerobo music is being played...\\n&quot;);  // 开始播放音乐        // 播放第一首歌音乐        for(i=0;i&lt;sizeof(makerobo_song_1)/4;i++)&#123;            softToneWrite(makerobo_BuzPin, makerobo_song_1[i]);             //第一首歌音谱            delay(makerobo_beat_1[i] * 500);   //第一首歌节拍        &#125;        // 播放第二首歌音乐        for(i=0;i&lt;sizeof(makerobo_song_2)/4;i++)&#123;            softToneWrite(makerobo_BuzPin, makerobo_song_2[i]);             //第二首歌音谱            delay(makerobo_beat_2[i] * 500);     //第二首歌节拍        &#125;    &#125;    return 0;&#125;\n\n音符频率对照表\n\n音阶   音阶是音乐必不可少的要素，主要由声音的频率决定。通过给蜂鸣器不同频率的音频脉冲，可以产生不同的音阶，而要产生某频率的音频脉冲，最简单的办法是以该音频的频率除以2的值，函数使用该值为参数改变蜂鸣器输入方波信号的频率，蜂鸣器上就可发出该频率的声音。   若想改变音阶，只需要改变频率即可。下表为各音调音符频率对照表，据此可产生不同音阶的音符。“#”表示半音，用于上升或下降半个音，乘以2就提升该声音一个8度音阶，减半则降一个8度。\n\n节拍   若要构成音乐，光有音阶是不够的，还需要节拍，也就是音符持续时间的长短，一般用拍数表示。至于1拍是多少秒，没有严格的规定，只要节拍适宜，声音悦耳即可。假如某首歌曲的节奏是每分钟120拍，那么1拍为0.5s，1&#x2F;4拍为0.125s，以此类推可得到其他节拍对应的时长。这样，利用不同的频率，加上与拍数对应的延时，就构成了乐曲。\n\n\n以上引用自这位大佬的博客👉原文链接\n\n我找来了一章音符与频率的对照表，供大家参考\n\nsoftTone软件音频库类似于softPWM，wiringPi库中还包含了一个软件音频库，通过输入不同的音频频率来使无源蜂鸣器发出不同的声音\n\n这里提到了需要在编译文件时加入-lpthread选项，实测不需要加入也可以正常编译出来\n4.2编译代码gcc 09passivebuzzer.c -o PASSIVE -lwiringPi\n\n\n4.3实验效果蜂鸣器的确发出了不同频率的声音，但是我感觉它并没有唱歌，哈哈😂\n录音文件也放在gitee仓库里面啦！👉传送门\n\n结语这两个传感器和之前实验中出现的双色LED很像，不过一个是以声音为媒介，一个是以光为媒介来传递信息\n本篇博客到这里就结束啦，如果有什么问题，欢迎在评论区提出哦！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验08-震动开关","url":"/posts/2318722711/","content":"\n\n前言今天折腾vim编辑器折腾了老久，我只是想实现在vim编辑器中可以复制代码到windows电脑下，方便我写博客，但是咋弄都搞不定，放弃了，还是用树莓派的系统来复制吧\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n振动传感器模块\n双色LED模块\n跳线一堆\n\n\n上：双色LED模块；下：震动传感器模块\n振动传感器模块和倾斜传感器模块很像，都是通过物理结构来判断当前的状态。而且它也有PWR-LED和DO-LED两个指示灯\n\n2.实验原理振动开关传感器用的是常闭型振动传感器，可用于跟踪振动触发作用，如防盗报警，地震报警和智能小车。与常开型振动传感器相比，常闭型振动传感器触发时间长，可以用于驱动继电器模块\n\n该模块采用常开高灵敏度震动开关。开关在静止時为开路OFF状态，当受到外力碰触而达到相应震动力时，或移动速度达到适当离(偏)心力时，导电接脚会产生瞬间导通呈瞬间ON状态；当外力消失時，开关恢复为开路OFF状态。可用于各种震动触发作用，报盗报警，智能小车，电子积木等。传感器特设M3固定安装孔，调节方向与固定方便易用，使用宽电压LM393比较器，信号干净，波形好，驱动能力强，超过15mA，配可调精密电位器调节灵敏度。在此实验中，将双色LED模块连接到Raspberry Pi作为指示作用。敲击或敲击振动传感器时，它将打开双色LED将闪烁红色。再次点击它，LED将变为绿色-每次敲击或敲击两种颜色之间交替闪烁。\n2.1电路图\n2.2接线图\n\n\n树莓派\nT型转接板\n振动开关\n\n\n\nGPIO 0\nGPIO 17\nDo\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n因为接口和倾斜开关一模一样，所以接线方式也是一样的\n\n实物接线图这里就不放了，和倾斜开关不同的是，振动开关在接上后，两个指示灯都会亮起，振动该传感器，DO-LED会闪动\n\n\n3.代码示例老样子，给出C语言的代码示例\n\n这里的wiringPi库函数在上两次的实验中都有使用过，详情请查看实验6里的解释\n\n#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_VibratePin\t0   // 震动传感器#define makerobo_Rpin\t\t1   // 红色LED PIN #define makerobo_Gpin\t\t2   // 绿色LED PINint clb_tmp = 0;//全局变量用于比较//双色LED控制函数void double_colorLED(int color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); //设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); //设置为输出模式\tif (0 == color)             //点亮红色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (1 == color)       //点亮绿色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;Makerobo Double color LED Error\\n&quot;); // 双色LED错误&#125;// 打印信息,打印出振动传感器的状态\tvoid makerobo_Print(int x)&#123;\tif (x != clb_tmp)\t&#123;\t\tif (x == 0)\t\t\tprintf(&quot;...Makerobo ON\\n&quot;);\t\tif (x == 1)\t\t\tprintf(&quot;Makerobo OFF..\\n&quot;);\t\tclb_tmp = x;//复位x\t&#125;&#125;int main()&#123;\tint clb_status = 0;  //状态值\tint clb_tmp = 0;     //比较值\tint clb_value = 1;   //当前值\t//wiringPi初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    //振动传感器Pin设置为输入模式\tpinMode(makerobo_VibratePin, INPUT);\t\twhile(1)&#123;\t\tclb_value = digitalRead(makerobo_VibratePin); //获取振动传感的值\t\tif (clb_tmp != clb_value)\t\t&#123;\t//振动传感器的输出值发生改变\t\t\tclb_status ++;   //振动传感器状态加1\t\t\tif (clb_status &gt; 1)\t\t\t&#123;\t\t\t\t\t\t\t\tclb_status = 0; //状态发生改变判断，如果变成2了复位成0\t\t\t&#125;\t\t\tdouble_colorLED(clb_status);  //控制双色LED模块\t\t\tmakerobo_Print(clb_status);   //打印出状态\t\t\tdelay(1000);                  //延时1s\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.1代码思路讲解clb_value接收振动传感器的返回值，每次振动，返回值都会改变\n\nvalue初始值为1，振动时，接收了返回值为0，和tmp不同，所以status++，双色LED的颜色改变\n如果没有检测到振动，返回值为1，和tmp相同，status不改变，双色LED的颜色不变\n\n参数clb_tmp问题void makerobo_Print(int x)函数中调用的其实是全局变量下的clb_tmp\n而main函数中调用的是int clb_tmp = 0;//比较值这个单独定义的局部变量，和全局中的tmp没有关系，所以makerobo_Print函数中对clb_tmp函数的操作不影响main中和状态码的比较\n为了不搞混全局变量和局部变量，建议将main函数中的tmp更名为clb_tmp1\n\n3.2linux运行代码gcc -Wall 08vibrationswitch.c -o TEST -lwiringPi\n\n\n每次晃动传感器，双色LED就会变色，屏幕上打印出on和off（每晃动一次，打印一次）\n按CTRL+C终止程序运行\n\n和倾斜开关的实时改变不同，振动开关的改变不是实时的，而是需要新的振动来触发它（类似一个按钮）\n\n假设我们要用它来做一个报警装置，假设在某一段时间内检测到振动状态多次改变，就可以发出信号报警，代表你的门（或者某个东西）被移动了\n\n\n结语这次实验的代码比上一次的倾斜开关相比，更复杂了一些。希望我的讲解对你有帮助！\n\n感谢你看到最后！如果对你有帮助，还请点个👍，万分感谢！\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验10-干簧管传感器实验","url":"/posts/722925156/","content":"\n\n前言好像没啥可以说的，直接开始进入今天的实验内容吧\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n干簧管传感器模块\n双色LED\n跳线若干\n\n\n上：干簧管传感器；下：双色LED\n\n2.实验原理干簧管传感器也是一种用于检测磁场的传感器。在常用的程控交换机、复印机、洗衣机、电冰箱、照相机、消毒碗柜、门磁、窗磁、电磁继电器、电子衡器、液位计、煤气表、水表等产品中都得到了很好的应用。\n\n个人理解：干簧管传感器的效果和霍尔元件很像，不过后者的体积更小\n笔记本电脑中就有霍尔元件，用于检测笔记本屏幕的开关，实现合盖休眠的功能\n\n\n干簧管是干式舌簧管的简称，是一种有触点的无源电子开关元件，具有结构简单，体积小便于控制等优点。\n\n其外壳一般是一根密封的玻璃管，管中装有两个铁质的弹性簧片电板，还灌有一种叫金属的惰性气体。平时，玻璃管中的两个簧片是分开的。\n\n当有磁性物质靠近玻璃管时，在磁场磁力线的作用下，管内的两个簧片被磁化而互相吸引接触，簧片就会吸合在一起，使结点所接的电路连通。\n外磁力消失后，两个簧片由于本身的弹性而分开，线路也就断开了。\n因此，作为一种利用磁场信号来控制的线路开关器件，干簧管可以作为传感器用于计数、限位等等场景(在安防系统中主要用于门磁、窗磁的制作)，同时还被广泛使用于各种通信设备中。\n在实际运用中，通常用磁铁控制这两根金属片的接通与否，所以又被称为“磁控管”\n\n\n2.1电路图电路图中Reed Switch(干簧管)部分，其实就是原理部分提到的密封玻璃管，内部有两个铁片\n\n当干簧管部分接触到磁性物体时，两个铁片吸附在一起，电路接通，DO管脚输出低电平。同时电路接通，D2 LED点亮\n没有检测到磁性物体，两个铁片断开，电路断开，DO管脚直连VCC，输出高电平\n\n\n2.2接线图类似这种通过一个传感器模块来控制双色LED的实验我们已经做过好几个了。它们的接线方式基本是一样的👍\n\n\n\n树莓派\nT型转接板\n干簧管\n\n\n\nGPIO 0\nGPIO 17\nDO\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n\n\n当接线完毕后，PWM-LED指示灯常亮\n\n即便没有开启控制程序，当干簧管检测到磁性物体时，DO-LED指示灯也会亮起\n\n3.代码示例和之前控制双色LED的代码相同，我们使用pinMode设置干簧管传感器为输入模式，将红绿LED的管脚都设置成输出模式\n\n当digitalRead检测到0（低电平）时，将双色LED设置为红色\n当digitalRead检测到1（高电平）时，将双色LED设置成绿色\n\n//干簧管控制双色LED实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_ReedPin\t0 //干簧管传感器管脚定义#define makerobo_Rpin\t\t1 //红色LED模块管脚定义#define makerobo_Gpin\t\t2 //绿色LED模块管脚定义// 双色LED控制函数void double_colorLED(char* color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); //红色LED管脚设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); //绿色LED管脚设置为输出模式\tif (color == &quot;makeroboRED&quot;)       //点亮红色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (color == &quot;makeroboGREEN&quot;) //点亮绿色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;Double color LED Error&quot;);&#125;int main()&#123;\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    //干簧管传感器Pin设置为输入模式\tpinMode(makerobo_ReedPin, INPUT);\tdouble_colorLED(&quot;makeroboGREEN&quot;);  //点亮绿色LED模块\t\twhile(1)&#123;\t\t//干簧管传感器去除抖动处理\t\tif(0 == digitalRead(makerobo_ReedPin))        &#123; //干簧管传感器检测到磁性物质\t\t\tdelay(10);       // 延时去抖动\t\t\tif(0 == digitalRead(makerobo_ReedPin))&#123;\t\t\t\tdouble_colorLED(&quot;makeroboRED&quot;);\t   // 点亮红色LED灯\t\t\t\tprintf(&quot;Detected Magnetic Material!\\n&quot;);// 打印出检测到磁性物质\t\t\t&#125;\t\t&#125;\t\telse if(1 == digitalRead(makerobo_ReedPin))        &#123; // 干簧管传感器没有检测到磁性物质\t\t\tdelay(10);        // 延时去抖动\t\t\tif(1 == digitalRead(makerobo_ReedPin))&#123;\t\t\t\twhile(!digitalRead(makerobo_ReedPin));\t\t\t\tdouble_colorLED(&quot;makeroboGREEN&quot;);   // 点亮绿色LED灯\t\t\t\tprintf(&quot;No Detected Magnetic Material!\\n&quot;); // 打印出没有检测到磁性物质\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n\n更详细的函数解释，可以参考之前实验6~8的博客👉专栏链接\n\n3.1编译代码在linux控制台下输入以下语句，编译生成可执行文件TEST\ngcc -Wall 10reedswitch.c -o TEST -lwiringPi\n\n3.1.1 GCC中-Wall指令的作用上一篇博客中，我在编译代码的时候就没有使用-Wall指令，但程序依旧编译成功了\n实际上，-Wall指令的作用是让GCC编译器显示程序的警告\n\n编译器在程序中检查出错误时，会终止编译\n编译器在程序中检查出警告时，依旧能编译生成可执行文件\n\nwindows系统中的VS编译器下，也有错误&#x2F;警告两种报错方式\n\n之前我就没有弄明白Linux环境下这两个之间的区别，导致我认为gcc编译器中不支持用==直接比较常量字符串（然后就把它改成了strcmp，当然这样也没错哈）\n\n如果我们在编译的时候去掉-Wall指令，就不会显示这两个警告\n\n\n更多关于-Wall指令的知识，大家可以参考这位dalao的博客学习一二👉传送门\n\n\n3.2实验效果./TEST运行可执行文件，查看实验结果\n\n检测到磁性物质时，屏幕打印Detected Magnetic Material!\n没有检测到的时候，打印No Detected Magnetic Material!\n\n\n结语本次实验到这里就结束啦，希望对你学习树莓派的操作有一些帮助\n\n学校高数和大物欠下的学习债终于补上了，可以摸🐟了\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验11-U型光点传感器","url":"/posts/816458215/","content":"\n\n前言本篇实验和上篇博客的实验相似，我们要学习用U型光电传感器来控制双色LED\n\n这都是基础实验中不可或缺的内容，因为后续我们需要学会交叉使用不同的传感器来控制更复杂的电路。那些才是学习树莓派基础实验真正的意义\n不管怎样，还是继续努力吧！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1.实验器材\n树莓派\n40p软排线+T型转接板+面包板\nU型光电传感器模块\n双色LED模块\n跳线一堆\n\n\n上：U型光电传感器；下：双色LED\n\n2.实验原理U型光电传感器是一种红外感应光点产品。其有红外发射管和接收管，分别位于U型槽的两侧，以此形成一光轴。当检测到物体经过U型槽并阻断光轴时，就能产生对应的电信号。\n2.1电路图以下是U型光电传感器模块的电路图\n\n无障碍物阻挡时，D1\\D2-LED都亮起，OUT管脚检测到低电平0\n有障碍物阻挡时，D1-LED熄灭，OUT管脚检测到高电平1\n\n\n2.2接线图\n\n\n树莓派\nT型转接板\nU型光电传感器\n\n\n\nGPIO 0\nGPIO 17\nOUT\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n\n\n不过我手上的这个传感器并没有两个指示灯。只有一个，该指示灯在传感器被阻隔的时候会变暗\n\n\n3.代码示例//U型光电传感器实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_LBPin\t\t0  // U型光电传感器管脚定义#define makerobo_Rpin\t\t1  // 红色LED模块管脚定义#define makerobo_Gpin\t\t2  // 绿色LED模块管脚定义// 双色LED控制函数void double_colorLED(int color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); // 红色LED管脚设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); // 绿色LED管脚设置为输出模式\t\tif (color == 0)&#123;                // 点亮红色LED灯\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (color == 1)&#123;          // 点亮绿色LED灯\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;&#125;// 有物体挡住时，打印出提示信息void makerobo_Print(int x)&#123;\tif ( x == 0 )&#123;\t\tprintf(&quot;makerobo Light was blocked!\\n&quot;);\t&#125;\telse&#123;\t\tprintf(&quot;clear!\\n&quot;);// 没有挡住\t&#125;&#125;// 主函数int main()&#123;       //初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    //U型光电传感器Pin设置为输入模式\tpinMode(makerobo_LBPin, INPUT);\tint clb_temp=0;\twhile(1)&#123;\t\t//U型光电传感器有无物体挡住信息检测\t\tif ( digitalRead(makerobo_LBPin) == 0 )&#123;  \t\t\tclb_temp = 1;//低电平，代表没有阻挡\t\t&#125;\t\tif ( digitalRead(makerobo_LBPin) == 1 )&#123;\t\t\tclb_temp = 0;//高电平，代表被阻挡\t\t&#125;\t\tdouble_colorLED(clb_temp); // 控制双色LED灯显示\t\tmakerobo_Print(clb_temp);  // 信息打印\t&#125;\treturn 0;&#125;\n\n3.1LinuxGCC编译代码在控制台输入以下指令，编译出可执行文件TEST\ngcc -Wall 11photoeletricsensor.c -o TEST -lwiringPi\n\n执行该文件，当传感器被阻挡时，双色LED变红，屏幕打印makerobo Light was blocked!\n不被阻挡时，双色LED亮绿灯，屏幕打印clear\n\n3.2 效果\n\n结语本次实验到这里就结束啦！如果有什么问题，欢迎在评论区提出哦！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验12-PCF8591模数转换器","url":"/posts/2733996002/","content":"\n\n前言由于树莓派不能直接读取模拟信号，所以我们需要本篇博客中提到的模数转换器来替代实现读取模拟信号的功能。\n本篇博客的这个模数转换器比之前的模块复杂很多，我们需要一步一步弄明白它的原理，才能真正理解如何使用这个小东西\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n双色LED模块（元老级朋友）\nPCF8591模数转换器模块\n一些跳线\n一字或者十字螺丝刀🛠\n\n\n上：PCF8591模数转换器模块；下：双色LED\n\n2.实验原理2.0 元件介绍PCF8591是一个单片集成、单独供电、低功耗、8-bit CMOS数据采集元件。\n\nPCF8591具有4个模拟输入、1个模拟输出和1个串行I2C总线接口。\n它的3个地址引脚A0, A1和A2可用于硬件地址编程，从而允许使用多达8个链接到I2C总线的设备，而无需额外的硬件。\n在PCF8591器件上输入输出的地址、控制和数据信号都是通过双线双向I2C总线以串行的方式进行传输。\n\n该元件的功能包括模拟输入多路复用，片上跟踪和保持功能，8位模数转换和8位数模转换。最大转换率由I2C总线的最大速度决定。\n2.1 i2c总线\ni2c总线是由飞利浦公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。\n\n飞利浦官方有一个关于PCF8591的详细介绍文档，不过它是英语的。我会上传到gitee仓库里面分享给大家，仓库链接在开头介绍过了🤦‍♂️回到开头\n\n\ni2c总线系统中的每个PCF8591设备通过向该设备发送有效地址而被激活。地址由固定部分和可编程部分组成。可编程部分必须按照地址引脚A0，A1，A2进行设置。地址必须以邮寄方式发送。\n在i2c总线协议中，在启动条件之后的第一个字节，地址字节的最后一个位是读&#x2F;写位，它设置了下列数据传输的方向。\n\n2.2 第一字节PCF8591采用典型的I2C总线接口器件寻址方法，即总线地址由器件地址、引脚地址和方向位组成。\n飞利浦公司规定A&#x2F;D器件地址为1001，引脚地址为A2A1A0，其值由用户选择。因此I2C系统中最多可接2^3^个具有I2C总线接口的A&#x2F;D器件。地址的最后一位为方向位R&#x2F;L，当主控器对A&#x2F;D器件进行写操作时为0，进行读操作时为1。\n总线操作时，由器件地址、引脚地址和方向位组成的从地址为主控器发送的第一字节。\n2.3 控制字节发送到PCF8591器件的第二个字节将被存储在其控制寄存器中，并且需要控制器件来实现功能。\n\n\n\nD1、D0 两位是A&#x2F;D通道编号：00通道0，01通道1，10通道2，11通道3\nD2 自动增量选择（0为禁止自动增量，1为允许自动增量），如果允许自动增量，则在每次A&#x2F;D转换后，通道编号会自动递增。\nD3 特征位：固定值为：0。\nD5、D4 模拟量输入选择：00为四路单端输入、01为三路差分输入、10为两路单端与一路差分输入、11为两路差分输入。\nD6 使能模拟输出AOUT有效（1为有效，0为无效）。\nD7 特征位：固定值为：0。\n\n上述内容参考@Maker张大佬的博客👉传送门\n\n控制寄存器的高半字节用于模拟输出，并将模拟输入编程为单端或差分输入。下半字节选择由上半字节定义的一个模拟输入通道。如果设置了自动增加标志，则在每次A&#x2F;D转换后，通道编号会自动递增。\n\n\n更多关于i2c总线的知识，可以查看百度百科的词条👉某度\n\n2.4 模块电路在本次实验中，AIN0（模拟输入0）端口用于接收来自电位计模块的模拟信号，AOUT（模拟输出）用于将模拟信号输出到双色LED模块，用于改变LED的亮度\n\n如果你有注意看电路图的话，你会发现AOUT上链接了一个D4-LED，它也会接收模拟输出信号，同步改变亮度\n\n而在我手头上的模块，D2-LED就是会同步改变亮度的，后文会提到\n\n\n在实验之前，我们可以把AIN上的电位帽拔掉\n\n2.5 电路接线\n\n\n树莓派\nT型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n双色LED\nT型转接板\nPCF8591\n\n\n\nR(中间)\n*\nAOUT\n\n\nGND(-)\nGND\nGND\n\n\nG(S)\n*\n*\n\n\n\n拍出来的接线图好像有亿点点乱😂\n\n正常接线后，主板上的D1-LED会亮起\n\n我们可以根据原理图利用T型转接板来连接模数转换器和双色LED，也可以用这种双母头的线直接连接AOUT端口和双色LED的中间管脚\n\n\n3.程序控制3.1 在树莓派中开启I2C通过VNC打开树莓派的桌面，点击开始-首选项-Raspberry Pi Configuration-Interfaces，打开I2C的开关enable\n\n3.2 代码示例//PCF8591模数转换器#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;//这个头文件是包含在库中的#define makerobo_PCF  120  // 基础管脚120// 主函数int main ()&#123;\tint pcf_value ;// 定义一个变量存储AIN的输入值\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\tpcf8591Setup (makerobo_PCF, 0x48);    // 在基本引脚120上设置pcf8591，地址0x48\twhile(1)\t&#123;\t\tpcf_value = analogRead  (makerobo_PCF + 0);\t\t// 获取AIN0上的值，插上跳线帽之后，采用的是内部的电位器；\t\tprintf(&quot;%d\\n&quot;, pcf_value);        // 打印出该值            \t\tanalogWrite (makerobo_PCF + 0, pcf_value);         // 控制AOUT输出电平控制LED灯\t\tdelay (10) ; // 延时10ms\t&#125; \treturn 0 ;&#125;\n\n头文件&lt;pcf8591.h&gt;在wiringPi的官方库中，可以查找到关于PCF8591使用的相关函数👉点我\n\n\n3.3 编译代码在控制台输入以下指令，编译出可执行文件TEST\ngcc -Wall 12pcf8591.c -o TEST -lwiringPi\n\n3.4 运行结果在运行程序之前，我们需要先把AIN0和INPUT0之间的跳线帽装上\n随后./TEST运行可执行文件，屏幕上会打印出AIN0管脚上获取的值\n\n但是不管我咋拧模块上的白蓝电位计，这个数字都不动\n后面发现这个代码必须要在树莓派的OS里面跑，才能实现控制功能，应该和3.1中的I2C总线功能有关\n\n于是在Geany编译器中编译代码，开始执行\n\n拧动白蓝电位计，屏幕上接收到的值会不断变化，同时LED小灯和主板上的D2-LED红色亮度也会产生变化\n\n\n结语本次实验对于我这个模电小白来说就晕乎乎的，虽然查找了一些I2C相关的文档和博客，但还是没太弄明白这个模块的具体原理和进阶使用。\n\n不过通过本次这个简单的控制双色LED的实验，至少我知道了可以通过电位计来调节AOUT值，想必在更复杂的实验中，这个模块可以扮演不一样的角色！\n那就只能期待未来我会用到它啦！（我怎么感觉不会呢？）\n\n\n纯小白，本篇博客可能有很大的纰漏，还请各位大佬无情指正！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验13-雨滴传感器","url":"/posts/2014251014/","content":"好久没玩树莓派了，今天上手来做一个实验\n\n\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n雨滴传感器模块\nLM393模块\nPCF8591模数转换器模块（实验12）\n一些跳线\n一个一字螺丝刀\n\n\n2.实验原理2.1基本说明雨滴传感器的控制模块具有4个输出，其中VCC连接到5V电源，模块的GND引脚接地。DO引脚连接到微控制器的数字引脚以进行数字输出，也可以使用模拟引脚。要使用模拟输出，可以将A0引脚连接到微控制器的ADC引脚。\n在雨滴&#x2F;雨水器系统中，用雨滴传感器检测降雨量并转换控制器检测到的信号。然后根据这些信号自动设置雨刮器的间隔，以方便地控制雨刮器的电机；在智能照明系统中，自动检测驾驶环境并调整照明模式，提高恶劣环境下的行车安全；在智能天窗系统中，检测是否下雨，如果检测到雨滴，则自动关闭天窗。\n传感器模块包括一个电位计，LM393比较器，LED，电容器和电阻器。雨板模块由铜轨组成，铜轨用作可变电阻器。它的阻力随雨板上的湿度而变化。\n2.2电路图\n2.3接线图\n\n\n树莓派\nT型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\nLM393模块\nT型转接板\nPCF8591\n\n\n\nDO\nGPIO 17\n*\n\n\nAO\n*\nAIN 0\n\n\nVCC\n3.3V\n*\n\n\nGND\nGND\n*\n\n\n\n在连接LM393和雨滴传感器的时候，发现雨滴传感器上并没有明确标出正负极，但是在正极的管脚下方用小点做了标识（负极无该白点）\n\n本次实验需要接的线非常多，注意不要接错了。其中PCF8591模块在接线时需要将所有跳线帽拔出\n\n\n3.代码效果3.1代码示例因为需要使用pcf8591模数转换器，所以需要引用头文件&lt;pcf8591.h&gt;\n//雨滴探测传感器实验#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;#include &lt;math.h&gt;#define\tmakerobo_PCF    120 // 基础管脚120#define\tmakerobo_DOpin\t 0   // 雨滴传感器管脚//打印雨滴传感器提示信息void makerobo_Print(int x)&#123;\tswitch(x)\t&#123;\t\tcase 1:            //没有雨滴\t\t\tprintf(&quot;\\n************************\\n&quot;  );\t\t\tprintf(  &quot;* makerobo Not Raining *\\n&quot;  );\t\t\tprintf(  &quot;************************\\n\\n&quot;);\t\t\tbreak;\t\tcase 0:             //有雨滴\t\t\tprintf(&quot;\\n**********************\\n&quot;  );\t\t\tprintf(  &quot;* makerobo Raining!! *\\n&quot;  );\t\t\tprintf(  &quot;**********************\\n\\n&quot;);\t\t\tbreak;\t\tdefault:         //打印数据错误\t\t\tprintf(&quot;\\n**********************\\n&quot;  );\t\t\tprintf(  &quot;* Print value error. *\\n&quot;  );\t\t\tprintf(  &quot;**********************\\n\\n&quot;);\t\t\tbreak;\t&#125;&#125;int main()&#123;\tint makerobo_analogVal;           // 定义模拟量存储变量\tint makerobo_tmp, makerobo_status;// 定义状态信息    //初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123;\t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1;\t&#125;\t//在基本引脚120上设置pcf8591，地址0x48\tpcf8591Setup(makerobo_PCF, 0x48);    //设置雨滴传感器管脚为输入模式\tpinMode(makerobo_DOpin, INPUT);    //默认状态值设置为0\tmakerobo_status = 0; \t//无限循环\twhile(1) \t&#123;\t\tmakerobo_analogVal = analogRead(makerobo_PCF + 0);\t\t//获取AIN0上的值\t\tprintf(&quot;%d\\n&quot;, makerobo_analogVal); //打印出该值 \t\tmakerobo_tmp = digitalRead(makerobo_DOpin); \t\t//读取数字IO口电平，读取数字雨滴传感器DO端口\t\tif (makerobo_tmp != makerobo_status) //状态发生改变\t\t&#123;\t\t\tmakerobo_Print(makerobo_tmp); //打印出雨滴传感器检测信息\t\t\tmakerobo_status = makerobo_tmp;  //状态值重新赋值\t\t&#125;\t\tdelay (200);   //延时200ms\t&#125;\treturn 0;&#125;\n\n注意：雨滴传感器其实是LM393和雨滴感应模块的集合体，所以代码注释中说的设置管脚为input模式，实际上设置的是LM393模块的管脚（毕竟只有它连上了T型转接板）\n\n本次博客的代码和之前的实验很相似，其中PCF8591在上篇实验12博客中已经有过讲解，所以在这里就不bb啦\n\n3.2运行效果当你把湿纸巾印在雨滴传感器上，屏幕上会打印出makerobo Raining!!，数值会随着雨滴量的大小变化（我这里测试的是，水多的时候打印的值小）但最后会趋于稳定，打印128\n\n如果没有水，屏幕上打印makerobo Not Raining，数值打印255\n\n在LM393模块上有两个LED指示灯，在传感器探测到水后，DO-LED会亮起\n\n如果你的DO-LED没有亮起，可以通过该传感器上蓝色的模块，用十字螺丝调节LM393模块的灵敏度（这个蓝色模块调节的是电阻）\n结语有了这个东西，你可以把雨滴传感器丢到窗台上，在不在家的时候，就可以运行代码，看看家里有无下雨了（毕竟时候工作上学的地方和家里隔了十几公里，天气就可能完全不同）\n\n配合cpolar实现内网穿透，效果更佳哦😀\n\n不过知道自己家下雨了，被子还没收，是不是徒增焦虑？\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验14-PS2游戏手柄摇杆","url":"/posts/423245526/","content":"本次实验还是需要用到PCF8591模数转换器，莫非它要取代双色LED成为新的常驻嘉宾吗？\n\n\n\n本次实验是摇杆实验。这个玩意可以用于操控机器人或者是树莓派的遥控小车。当然，生活中最常见的用途还是在游戏手柄上。不知道你打不打游戏，有没有用过手柄玩游戏呢？\n\n本人有一个游戏手柄，玩3a还是挺爽的，哈哈\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\nPS2手柄模块\nPCF8591模数转换器模块（实验12）\n一些跳线\n一个一字螺丝刀\n\n\n2.实验原理\n手柄模块通过以90度角安装两个电位计来判断当前的X值和Y值，从而计算出手柄的方向。再加上一个按钮，来判断手柄被按下（也就是游戏手柄上的L3和R3键的原理）\n\n处于静止位置时，此模块从X和Y产生约2.5V的输出。移动操纵杆将导致输出在0v到5V之间变化，具体取决于其方向。如果将此模块连接到微控制器，则可能会在其静止位置读取大约512的值(由于弹簧和机构的微小误差而引起的细微变化)。移动操纵杆时，应该看到该值从0变为到1023，具体取决于其位置。\n该模块有两个模拟输出(对应X和Y坐标)和一个数字输出，表示是否在Z轴上按下。\n在本实验中，我们将引脚X和Y连接到PCF8591A&#x2F;D转换器的模拟输入端口，以便将模拟量转换为数字量。然后在树莓派上编程以检测操纵杆的移动方向\n2.1电路图\n2.2接线图\n\n\n树莓派\nT型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\nPS2手柄模块\nT型转接板\nPCF8591\n\n\n\nVRY\n*\nAIN 0\n\n\nVRX\n*\nAIN 1\n\n\nSW\n*\nANI 2\n\n\n5V\n5V\n5V\n\n\nGND\nGND\nGND\n\n\n\n这个是我的接线图，其实可以直接用双母头跳线直接连接PCF8591和手柄模块，不过还是借助了T型转接板来连接二者。\n\n3.效果演示3.1代码示例//PS2操作杆实验#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;#define makerobo_PCF       120   // 基础管脚120#define uchar\tunsigned charint pcf_AIN0 = makerobo_PCF + 0; // AIN0 端口int pcf_AIN1 = makerobo_PCF + 1; // AIN1 端口int pcf_AIN2 = makerobo_PCF + 2; // AIN2 端口// 方向状态信息 char *state[7] = &#123;&quot;home&quot;, &quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;, &quot;pressed&quot;&#125;;// 方向判断函数int makerobo_direction()&#123;\tint ain_x, ain_y, ain_b;       // X方向，Y方向，B 是否按下\tint makerobo_tmp=0;            // 状态值\tain_x = analogRead(pcf_AIN1);  // X为AIN1端口\tain_y = analogRead(pcf_AIN0);  // Y为AIN0端口\tain_b = analogRead(pcf_AIN2);  // B按下为AIN2端口\t\tif (ain_y &lt;= 30)\t\tmakerobo_tmp = 1;\t\t// up\tif (ain_y &gt;= 225)\t\tmakerobo_tmp = 2;\t\t// down\t\tif (ain_x &gt;= 225)\t\tmakerobo_tmp = 4;\t\t// left\tif (ain_x &lt;= 30)\t\tmakerobo_tmp = 3;\t\t// right\tif (ain_b == 0)\t\tmakerobo_tmp = 5;\t\t// button 按下\tif (ain_x-125&lt;15 &amp;&amp; ain_x-125&gt;-15 &amp;&amp; ain_y-125&lt;15 &amp;&amp; ain_y-125&gt;-15 &amp;&amp; ain_b &gt;= 60)\t\tmakerobo_tmp = 0;\t\t// home 位置\t\treturn makerobo_tmp;&#125;// 主函数int main (void)&#123;\tint makerobo_tmp=0;       // 当前值\tint makerobo_status = 0;  // 状态值\twiringPiSetup ();\t// 在基本引脚120上设置pcf8591，地址0x48\tpcf8591Setup (makerobo_PCF, 0x48);\t// 无线循环\twhile(1) \t&#123;\t\tmakerobo_tmp = makerobo_direction(); // 调用方向判断函数\t\tif (makerobo_tmp != makerobo_status) // 判断状态是否发生改变\t\t&#123;\t\t\tprintf(&quot;%s\\n&quot;, state[makerobo_tmp]); // 打印出方向位\t\t\tmakerobo_status = makerobo_tmp;                  // 把当前状态赋给状态值，以防止同一状态多次打印\t\t&#125;\t&#125;\treturn 0 ;&#125;\n\n这部分比较好理解，代码也很直观。只有home位置需要我们单独进行计算（即手柄处于正中心区域且没有按下的情况，才是home的情况）\n3.2效果翻车不过轮到实际测试的时候，翻大车了。在我还没有动摇杆的时候，它就会显示出左和按钮被按下的提示。我尝试修改代码来修复这个错误，发现并不可行\n\n于是我直接把代码给注释掉，加了一个打印X\\Y\\B当前值的代码\n\n结果呢，在我没动摇杆的时候，打印出来的X和Y都是乱七八糟的。只有按下摇杆的B&#x3D;0可以被正常检测到，其他的方位啥的都是毫无反应。\n\n直接给这个模块下达了死亡通知书，拜拜了您嘞！\n结语通过学习这个模块的代码，可以看到实际上一些零部件的基本原理并不是非常难掌握。不过你想把一个摇杆变成一个完整的游戏手柄，那就需要更复杂的控制代码和手柄的内部芯片来转义这些数字值了。\n\n有什么问题的话，可以在评论区提出呢\n\n还是有所收获的，要是摇杆没坏就好了\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验15-电位计传感器","url":"/posts/1509681384/","content":"今天的这个实验需要用上两位常驻嘉宾！\n它们就是PCF8591和双色LED！\n\n\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n双色LED模块（元老级朋友）\nPCF8591模数转换器模块（长老级朋友）\n电位计传感器\n一些跳线\n\n\n上：电位计传感器；下：双色LED\n\n2.实验原理2.1基本原理\n电位计是一种用于测量电路中电势(电压)的仪器。通过电流计将来自电阻式滑动导线的已知电压的一部分与未知电压进行比较。调节电位器的滑动触点或游标。然后将检流计短暂地连接在滑动触点和未知电压之间，观察检流计的挠度，并调节滑动分接头，直到检流计不再从零偏斜为止。\n此时，检流计不再从未知源汲取电流，并且可以从滑动触点的位置计算出电压的幅值。\n\n电位器，又称POT，是可变电阻器。他们可以通过简单地改变其头部顶部的旋钮来提供可变的电阻。可以基于两个主要参数对其进行分类。一个是电阻(R-ohms)本身，另一个是功率(P-Watts)额定值。\n\n在本实验中，PCF8591用于读取电位计的模拟值并将值输出到双色LED。\n将电位器的引脚SIG（电位器上的OUT管脚）连接到PCF8591的引脚AINO。将双色LED的引脚R或引脚G连接到PCF8591的引脚AOUT，以观察LED的变化。\n\n2.2接线图有了前两次接线的经验，这一次就只需要复刻就行了\n\n\n\n树莓派\nT型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n电位计\nT型转接板\nPCF8591\n\n\n\nOUT\n*\nAIN 0\n\n\nVCC\n5v\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n双色LED\nT型转接板\nPCF8591\n\n\n\nR(中间)\n*\nAOUT\n\n\nGND(-)\nGND\nGND\n\n\nG(S)\n*\n*\n\n\n\n实物图一如既往的乱，哈哈哈\n\n\n3.实验效果3.1代码示例本次实验使用上了AOUT的接口，用于接收电位计的信号而改变双色LED亮度\n//电位器模块实验#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;#define makerobo_PCF  120 // 基础管脚120// 主函数int main ()&#123;\tint pcf_value ;     // 定义一个变量存储AIN的输入值\twiringPiSetup () ;   // 调用初始化函数\t// 在基本引脚120上设置pcf8591，地址0x48\tpcf8591Setup (makerobo_PCF, 0x48) ;\twhile(1) // 无限循环\t&#123;\t\tpcf_value = analogRead  (makerobo_PCF + 0) ;        // 获取AIN0上的值，读取电位器模拟量值；\t\tprintf(&quot;Potentiometer Value: %d\\n&quot;, pcf_value);         // 打印出该值    \t\tanalogWrite (makerobo_PCF + 0, pcf_value) ;            // 控制AOUT输出电平控制LED灯\t\tdelay (200) ;  // 延时200ms\t&#125;\treturn 0 ;&#125;\n\n\n这里先用Read函数读取电位计的值，然后再用Write函数写入到PCF8591，它用AOUT输出到双色LED，来控制它的亮度\n\n3.2实验效果如果你看过实验12的博客的话，你应该还记得，PCF8591上也有一个电位计，他也能实现本次实验的效果。\n\n但不同的是，本次实验使用的是单独的电位计模块，调节更加方便，不需要使用螺丝刀\n\n运行程序，屏幕上会打印出电位计接收到的值，通过调节旋钮，值在0-255之间波动\n\n效果如图，还是很明显的\n\n结语本篇博客到此结束，感谢你的阅读\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【项目】视频点播项目的记录","url":"/posts/4231483510/","content":"1.用户密码加密算法在最开始的时候，我打算用md5加盐来存放用户的密码；在查找资料的时候，发现了MD5算法不再适用于用户密码加密的言论，于是问起了GPT。\n感觉这部分面试的时候可能会涉及，干脆记录下来吧！\n1.1 什么是MD5？MD5（Message Digest Algorithm 5）是一种常用的哈希算法，用于将任意长度的数据转换为固定长度（128位或16字节）的哈希值。\nMD5 哈希值通常以十六进制字符串的形式表示。由于每个字节可以用两个十六进制字符表示，因此 MD5 哈希值的长度为 32 个字符（16字节 * 2）。\n需要注意的是，尽管 MD5 哈希值固定为 128 位（16字节），但并不意味着输入数据的长度与哈希值长度相同。无论输入数据的长度是多少，MD5 哈希值始终是固定的 128 位长度。\n1.2 MD5的缺陷？MD5 算法存在安全漏洞主要是由于其设计和性质的限制。\n首先，MD5 算法是一个单向哈希函数，即无法从哈希值逆推出原始输入数据。然而，研究人员发现，通过对不同的输入数据计算相同的 MD5 哈希值（也称为哈希碰撞），可以导致安全问题。这意味着攻击者可以通过寻找具有相同 MD5 哈希值的两个不同输入，来伪造数据或绕过验证机制。\n其次，MD5 的输出长度较短，只有 128 位（16 字节）。这种较短的哈希值使得碰撞的可能性更高。随着计算能力的提升，通过穷举计算或使用专门的碰撞攻击算法，更容易找到两个不同的输入数据产生相同的 MD5 哈希值。\n因此，基于这些安全漏洞，MD5 已被证实不再适用于诸如密码存储等关键安全场景。相反，应该选择更强大且抗碰撞性更好的哈希算法，例如 SHA-256 或 SHA-3 等算法，以提供更高级别的数据完整性和安全性保护。\n1.3 SHA256的优势SHA-256 相对于 MD5 具有以下几个主要的优势：\n\n安全性：MD5 已经被证实存在安全漏洞，容易受到碰撞攻击和预映像攻击。相反，SHA-256 是一种更为安全的哈希算法，目前没有已知的有效攻击方法，能够从哈希值逆推出原始输入数据或找到碰撞。\n哈希长度：MD5 的哈希长度为 128 位（16 字节），而 SHA-256 的哈希长度为 256 位（32 字节），明显更长。更长的哈希长度增加了哈希碰撞的难度，使得找到两个不同的输入产生相同的哈希值的概率大大降低。\n抗碰撞性：SHA-256 提供了更强大的抗碰撞性，即输入数据的微小变化也会导致输出哈希值的较大变化。这意味着无法通过微小的修改来生成具有相同哈希值的不同输入数据。\n\n综上所述，SHA-256 相对于 MD5 具有更高的安全性和抗碰撞性，因此在安全敏感的场景中，应该使用 SHA-256 或其他更强大的哈希算法来保护数据的完整性和安全性。\n\n然而，对于非安全相关的简单校验和一些非关键应用，MD5 仍然是一个快速且有效的哈希算法选择。\n\n2.前端错位230810下午改了一整个下午的前端，一直用的火狐。图标和输入框的样式都是直接手撸的，耗时较长。\n\n原以为大功告成了。结果把url往edge一粘贴，完蛋了，图标直接全部错位\n\n后来咨询了前端大佬才知道，不同浏览器对相同代码的渲染处理可能有所不同。如果用前端框架bootstrap就能较好的解决这个问题。\n而我的项目所使用的模板里面，也确实引入了bootstrap，但我不太会使用……\n","categories":["项目开发记录"],"tags":["Linux","C++","mysql"]},{"title":"【Curl】通过curl模拟referer获取到有防盗链的图片","url":"/posts/2721043914/","content":"本文所描述操作仅供学习curl命令，请勿用于盗刷他人图床等违规操作！🙅‍♀️\n\n\n1.说明当我想把51la添加到我的导航站点，却发现它的icon图标有防盗链，禁止空referer访问的；\n这点完全可以理解，为了防止他人盗刷本站的图片，通常我们都需要给图片地址加上防盗链。\n\n其实51la提供了自己的icon，但这里提供的icon像素特别低，只有16*16，在我的导航站点上的显示就没有那么友好了\n\n\n所以我才想把稍微清晰一点的icon图标下载下来\n2.curl使用\n参考 https://www.ruanyifeng.com/blog/2019/09/curl-reference.html\n\n要避开这个403访问权限，需要做的就是给请求头给定一个referer字段，告诉51la的服务器，我是通过他自己的域名访问图标文件\ncurl \\-H &#x27;Referer: https://v6.51.la/&#x27; \\https://v6-static.51.la/v6-static/202302161047/favicon.ico \\-o favicon.ico\n\n对上面提到的几个参数做一定解释\n\n-H 设定请求头，需要符号http协议的标准key: value\n-o 将获取到的内容保存为文件，在后面指定文件名（这里我指定为了favicon.ico）\n\n在linux下用这个命令，就能成功拉取到51la的站点图片\n\n如果不加referer字段，则还是会返回403\n$ curl https://v6-static.51.la/v6-static/202302161047/favicon.ico &lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;\n\n备注：windows下使用这个curl命令会报错，因为windows下的curl参数和linux下是不同的。\n","categories":["差生文具多"],"tags":["Linux","curl"]},{"title":"【微机】DOSBox在windows上的安装和masm的配置","url":"/posts/2839269095/","content":"最近学校学习微型计算机原理与接口技术，需要用到DOSBox来模拟DOS环境进行汇编编程的学习。\n本文记录了如何在windows11&#x2F;10上安装DOSBox0.74并配置masm5\n1.安装这两个软件我打包上传到了百度云盘。放心，加起来也就2mb，下载应该不会很久\n链接: https://pan.baidu.com/s/1vjbSL7iwP8WpMVA9K505ZA提取码: kr4x\n\n1.1 DOSBox点击DOSBox0.74的安装包，无脑下一步安装即可\n\n安装出来的图标如下\n\n1.2 masm5找一个空的文件夹，文件路径中不能包含空格、特殊字符和中文，将masm5.zip中的文件全部解压到这个文件夹中，如下图\n\n随后修改DOSBox软件的配置文件，右键桌面上Dosbox软件的快捷图标，选择打开文件所在位置找到DOSBox软件的安装路径，点击DOSBox 0.74 Options.bat文件，稍等片刻，会以记事本的方式打开配置文件。\n\n拉到配置文件最底下，新增如下配置。你只需要修改D:\\GAME\\masm为你的masm5文件的解压目录就行了。这个文件路径中不能有空格，也不能有特殊字符和中文！\nMOUNT C D:\\GAME\\masmpath=%path%; \\masmC: cd \\asm\n\n配置完成后，启动DOSbox，查看masm命令是否能正常使用。如图所示，没有报错masm命令不存在，那么就是配置好了。\n\n2.修改DOSBox窗口大小默认情况下DOSBox的命令行窗口是非常非常非常小的，我们需要将其改大。同样是修改DOSBox的配置文件，如何打开配置文件参考上文。\n按下图所示修改\n\n请注意，这里的1280和1080中间的是大写的X，并不是乘号\nwindowresolution=1280X1080output=opengl\n\n修改了之后保存，再重新打开DOSBox，界面就应该会变大了。如果你觉得还是小了，可以修改这里的分辨率，继续让他变大一点。\n3.编译一个汇编程序用下面最简单的汇编程序做测试，将如下内容写入到test.asm中，并放入和masm的同一目录下（必须要是同一目录）\nCODE SEGMENT ;USE16     ASSUME CS:CODEBEG: MOV DL,&#x27;H&#x27;     MOV AH, 2 ; 调用2号DOS系统调用输出字符到屏幕上     INT 21H     MOV AH, 4CH     INT 21HCODE  ENDS        END BEG\n\n打开DOSBox，输入如下命令\nmasm test.asmlink test.obj\n\n输出如下图所示，第一个命令的作用是编译源文件（注意看有没有编译报错）；第二个命令的作用是链接obj文件，最终会弹出来一个警告，不用管他。\n\n最终执行test，成功输出字符H到终端上。\n\n能走到这一步，就代表你的masm基本环境已经配置好了。可以用来编译运行汇编代码了\n","categories":["差生文具多"],"tags":["win"]},{"title":"【工具】复制网页为markdown的浏览器插件","url":"/posts/4128600186/","content":"说明如果您需要转载或者想保存他人的文章。可以使用一个油猴插件，快速将网站页面复制为markdown（以下简称md）。\n只要目标网站是支持md语法（大部分博客站点都是支持的）那么复制下来的效果基本没问题（已知有问题的是md中表格的复制）\n\n再次提醒：转载他人文章一定要注明出处，并尽量在得到原作者许可后转载。\n\n\n安装浏览器油猴扩展edge和chome都可以安装此插件，以edge为例，在如下位置可进入插件配置页\n\n或者直接输入url也可进入插件页面\nedge://extensions/\n\n进入页面后，点击获取商店中的扩展\n\n搜索 tampermonkey，下载下图中绿色的这个插件（下载量最多的那个）\n\n安装复制为markdown插件随后进入 https://greasyfork.org/zh-CN 网站，搜索一个插件\n复制为markdown格式\n\n\nhttps://greasyfork.org/zh-CN/scripts/370299-%E5%A4%8D%E5%88%B6%E4%B8%BAmarkdown%E6%A0%BC%E5%BC%8F\n\n安装完毕后，右上角的油猴图标会多出此插件。在这里也可以选择开关此插件，一般在需要的时候打开就行了。以免日常访问网站的时候误触复制按钮\n\n使用这里随便找了一个csdn文章【链接】\n在右上角可以看到一个蓝色的 copy 按钮\n\n点击按钮，会出现蓝色虚线选择框。我们直接放到文章正文部分，点击一下，就复制成功了。\n目前已知的问题是这个插件无法处理表格，其他都还ok\n\n本教程结束~\n\n再次提醒：转载他人文章一定要注明出处，并尽量在得到原作者许可后转载。\n\n","categories":["差生文具多"]},{"title":"【Python】selenium遇到ActionChains.move_to_element() takes 2 positional arguments but 4 were given报错","url":"/posts/2142561511/","content":"刚开始学的时候，用火绒的selenium插件录制了一个操作，导出为了python文件；\n\n\n使用如下的命令运行这个文件（如果没有pytest用pip安装一下就行）\npip install pytestpip install selenium\n\n用如下命令执行导出的文件\npytest test_test01.py\n\n会得到这个报错\n      actions = ActionChains(self.driver)&gt;     actions.move_to_element(element, 0, 0).perform()E     TypeError: ActionChains.move_to_element() takes 2 positional arguments but 4 were giventest_test1.py:42: TypeError\n\n可我压根没有修改过导出的文件，这个报错是怎么来的呢？\n目测是高低版本的python的selenium包中，报错的ActionChains.move_to_element()这个函数的传参被修改过；而插件生成的代码中，上方的这个就是正确的传参，下方的这个带0,0的传参是错误的\n# 3 | mouseOver | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget | element = self.driver.find_element(By.CSS_SELECTOR, &quot;.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget&quot;)actions = ActionChains(self.driver)actions.move_to_element(element).perform()  # 正确# 4 | mouseOut | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget | element = self.driver.find_element(By.CSS_SELECTOR, &quot;body&quot;)actions = ActionChains(self.driver)actions.move_to_element(element, 0, 0).perform() # 错误\n\n\n可以查看函数定义，只接受一个参数\n\n把这里的两个0,0删除掉就行了，运行的结果和我录制的效果相同，没有问题！\n\n顺带附上本次debug的版本号\npython             3.10.5pytest             7.4.0selenium           4.11.2火狐浏览器版本 116.0.2（64位）火狐浏览器Selenium IDE插件版本 3.17.4\n\n如果帮到了你，还请评论支持我一下，谢谢！\n","categories":["速通Python"],"tags":["Python","selenium"]},{"title":"【Python】自动化测试selenium","url":"/posts/192617188/","content":"学习自动化测试selenium的笔记。\n贪多嚼不烂，当时就是为了面试零时抱佛脚学的，既然现在用不到了，那没必要继续记录博客了。所以请不要看本文！\n\n\n1.什么是自动化测试自动化测试指软件测试的自动化，在预设状态下运行应用程序或者系统，预设条件包括正常和异常，最后评估运行结果。将人为驱动的测试行为转化为机器执行的过程。\n说白了就是编写一系列代码来实现自动帮我们测试某一个功能是否有啥问题。比起自己弄，自动化测试能覆盖到更多情况，特别是某些在实际情况中不好通过人工模拟出的问题。\n下图是自动化测试的金字塔模型，从下往上代表测试需要的时间和投入，单元测试应该是投入最大的测试。\n\n1.1 单元测试所谓单元测试，就是我们代码中每一个函数、程序模块的测试。\n单元测试通常遵循以下步骤：\n\n编写测试用例：为每个函数、方法或类编写测试用例，这些用例包括输入数据、预期输出以及对应的函数调用。\n运行测试：使用单元测试框架运行编写的测试用例。测试框架会执行测试并报告每个测试的结果。\n断言测试结果：测试框架会自动比较实际输出与预期输出，如果不匹配则会产生错误报告。\n修复错误：如果测试失败，开发人员需要检查代码并修复问题，确保代码按预期工作。\n重复测试：在每次代码更改后，都需要重新运行相应的单元测试，以确保新的更改没有破坏现有的功能。\n\n单元测试的目标，就是保证我们写出来的函数是依照我们的预期运行的，能得到我们需要的结果。而最终目的，就是避免当一个函数已经投入使用了，才发现这个函数的运行与预期结果不符合。\n1.2 接口测试目前一般采用后端提供API接口，前端使用静态页面的方式来实现前后端分离。\n而接口测试，就是保证我们后端提供的API接口能正确分离我们预期的参数，并提供与之相符合的返回结果。\n当我们完成了后端接口的编写后，就能在产品前期进行接口测试，避免产品已经上线了才发现接口有问题的情况。\n\n产品前期接口完成后介入\n用例维护量小\n适合接口变动较小，界面变动频繁的项目\n\n常见的接口自动化测试工具有：RobotFramework，JMeter，SoapUI，TestNG+HttpClient，Postman 等。\n1.3 UI测试对于用户来说，他们接触到的其实还是UI（前端），在完成了接口测试后，我们需要对前端界面的操作进行测试。特点：\n\n用例维护量大\n页面相关性强，需要完成后期项目开发后才介入\n由于前端界面相对来说比较复杂，UI测试适合界面变动较小的项目\n\nUI自动化测试的好处\n\n减少重复测试的时间，实现快速回归测试\n创建可靠的测试过程，避免测试过程中的人为错误\n可以实现很多更加繁琐的测试，或者难以用人工实现的测试，减少人力成本\n更好的利用资源和测试脚本\n\nUI层的测试框架比较多，比如Windows客户端测试的AutoIT，web测试的selenium以及TestPlant eggPlant，Robot framework，QTP等。\n1.4 自动化测试适用对象\n产品型项目。产品型的项目，新版本是在旧版本的基础上进行改进，功能变不大的项目，但项目的新老功能都必须重复的进行回归测试。回归测试是自动化测试的强项，它能够很好的验证你是否引入了新的缺陷，老的缺陷是否修改过来了。在某种程度上可以把自动化测试工具叫做回归测试工具。\n机械频繁的测试。每次需要输入大量用例，并且在一个项目中运行的周期比较长。 比如兼容性测试。\n\n以下情况就不适用于自动化测试：\n\n需求变动频繁，自动化脚本不能很好的复用（写个测试脚本的时间都够人工测试了，自然不适合自动化测试）\n项目周期短，自动化脚本编写完毕后使用次数不多（没啥时间写脚本）\n交互性较强，需要人工干预的项目，自动化无法实施\n\n1.5 如何实施自动化测试？单纯的讲，自动化测试的具体实现，应该是包含下面七个过程的。\n\n分析：总体把握系统逻辑，分析出系统的核心体系架构。\n设计：设计测试用例，测试用例要足够明确和清晰，覆盖面广而精\n实现：实现脚本，有两个要求一是断言，二是合理的运用参数化。\n执行：执行脚本远远没有我们想象中那么简单。脚本执行过程中的异常需要我们仔细的去分析原因。\n总结：测试结果的分析，和测试过程的总结是自动化测试的关键。\n维护：自动化测试脚本的维护是一个难以解决但又必须要解决的问题。\n分析：在自动化测试过程中深刻的分析自动化用例的覆盖风险和脚本维护的成本。\n\n\n2.安装Selenium环境本文使用各个软件的版本号\npython             3.10.5pytest             7.4.0selenium           4.11.2火狐浏览器版本   116.0.2（64位）火狐浏览器Selenium IDE插件版本 3.17.4\n\n\n2.1 火狐安装Selenium IDE打开火狐，点击右上角选择框，进入扩展和主题\n\n点击左侧扩展，搜索 Selenium IDE\n\n第一个就是我们要的，图标是蓝色的，中间有一个Se字母\n\n进入后，点击获取插件（这里我已经安装了，所以显示的是移除）\n\n2.2 windows安装python在windows上python安装的基础步骤参考我的这篇博客：【Python】在你的云服务&#x2F;电脑上搭建Python环境\n\n初次安装python的时候，一定要勾选ADD PYTHON TO PATH这个选项，这个在上文中有提及。因为非常重要所以多说几次！\n\n安装好python后，使用pip安装如下两个包\npip install pytestpip install selenium\n\n如果按照的很慢可以加上镜像源\npip install pytest -i https://pypi.tuna.tsinghua.edu.cn/simplepip install selenium  -i https://pypi.tuna.tsinghua.edu.cn/simple\n\nwindows下如何配置pip镜像源参考：【Python】pip下载使用国内镜像源\n2.3 安装火狐驱动geckodriver如果你尝试直接运行selenium的代码，极有可能会遇到如下报错，这是因为你没有安装火狐对应的驱动\nWebDriverException: Message: &#x27;geckodriver&#x27; executable needs to be in PATH.\n\n火狐驱动下载地址：https://github.com/mozilla/geckodriver/releases\n\nchrome驱动下载地址：https://registry.npmmirror.com/binary.html?path=chromedriver/\n因为本文操作用的都是火狐，所以不提及chrome的操作。请自行查阅其他文章\n\n下载好了之后，将其中的geckodriver.exe解压到windows下python的安装路径的Scripts文件夹下；\n\n如果你用的是上面提到那片博客里面的安装方式，那么在windows平台下python默认的安装路径如下\nC:\\Users\\moth\\AppData\\Local\\Programs\\Python\\Python310\n\n如果你不知道你电脑上python的安装路径，可以在vscode的解析器中找到；当你在vscode中打开一个test.py文件，右下角就会显示当前使用的解析器\n\n点击它，就能看到你安装的python的路径\n\n注意：如果你的python是用windows商店安装的，那路径里面是没有Scripts文件夹的！所以强烈不推荐使用windows商店来安装python（虽然确实方便）\n你可以在windows设置-软件里面找到微软商店安装的python，将其卸载，然后再用上面提到的办法重新安装你需要的版本的python！\n\n2.4 尝试录制一段操作上面的安装都完成后，就可以来尝试录制一段操作了。这里我使用了我自己的导航页来测试，打开火狐后，点击右上角的这个拼图图标\n\n选择selenium IDE运行扩展\n\n点击第一个，在新项目中录制一个新操作\n\n随便输入一个项目名字\n\n选择你需要录制的页面url，这里我填了我自己的主页 web.musnow.top，填写好了之后点击START RECORDING开始录制\n\n开始录制后，右下角会出现正在录制的提示；以下是我录制了的操作。\n这里我在我主页的输入框中输入了你好，点击回车\n\n然后我又点击了第一个搜索结果，录制到这里就结束了\n\n进入selenium IDE的页面，点击右上角的红色方框停止录制（下图中是已经停止录制后的样子）中间会显示你这次录制做了什么\n\n将本次录制保存，随便起个名字，然后右键左侧的录制名，选择export导出\n\n选择python代码，点击导出；弹出的框会让你选择导出路径\n\n下面就是我导出后的代码，Selenium IDE会将文件命名为项目名_录制名.py\n# Generated by Selenium IDEimport pytestimport timeimport jsonfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.action_chains import ActionChainsfrom selenium.webdriver.support import expected_conditionsfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesclass TestTest1():  def setup_method(self, method):    self.driver = webdriver.Firefox()    self.vars = &#123;&#125;  def teardown_method(self, method):    self.driver.quit()  def wait_for_window(self, timeout = 2):    time.sleep(round(timeout / 1000))    wh_now = self.driver.window_handles    wh_then = self.vars[&quot;window_handles&quot;]    if len(wh_now) &gt; len(wh_then):      return set(wh_now).difference(set(wh_then)).pop()  def test_test1(self):    # Test name: test1    # Step # | name | target | value    # 1 | open | / |    self.driver.get(&quot;https://web.musnow.top/&quot;)    # 2 | setWindowSize | 1721x935 |    self.driver.set_window_size(1721, 935)    # 3 | mouseOver | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget |    element = self.driver.find_element(By.CSS_SELECTOR, &quot;.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget&quot;)    actions = ActionChains(self.driver)    actions.move_to_element(element).perform()    # 4 | mouseOut | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget |    element = self.driver.find_element(By.CSS_SELECTOR, &quot;body&quot;)    actions = ActionChains(self.driver)    actions.move_to_element(element, 0, 0).perform()    # 5 | click | id=txt |    self.driver.find_element(By.ID, &quot;txt&quot;).click()    # 6 | type | id=txt | 你好    self.driver.find_element(By.ID, &quot;txt&quot;).send_keys(&quot;你好&quot;)    # 7 | sendKeys | id=txt | $&#123;KEY_ENTER&#125;    self.vars[&quot;window_handles&quot;] = self.driver.window_handles    # 8 | selectWindow | handle=$&#123;win5784&#125; |    self.driver.find_element(By.ID, &quot;txt&quot;).send_keys(Keys.ENTER)    # 9 | click | css=.\\_paragraph_5yh6i_2 &gt; span &gt; span |    self.vars[&quot;win5784&quot;] = self.wait_for_window(2000)    # 10 | selectWindow | handle=$&#123;win5879&#125; |    self.driver.switch_to.window(self.vars[&quot;win5784&quot;])    self.vars[&quot;window_handles&quot;] = self.driver.window_handles    self.driver.find_element(By.CSS_SELECTOR, &quot;.\\\\_paragraph_5yh6i_2 &gt; span &gt; span&quot;).click()    self.vars[&quot;win5879&quot;] = self.wait_for_window(2000)    self.driver.switch_to.window(self.vars[&quot;win5879&quot;])\n\n使用如下命令运行这个文件\npytest 文件名\n\n直接运行会遇到如下的报错\n      actions = ActionChains(self.driver)&gt;     actions.move_to_element(element, 0, 0).perform()E     TypeError: ActionChains.move_to_element() takes 2 positional arguments but 4 were giventest_test1.py:42: TypeError\n\n报错的意思是 ActionChains.move_to_element()函数只需要接受两个参数，但却提供了4个参数，出错的是第四十二行的位置\n\n解决办法是将这里的,0,0给删除，类似38行，只传入element参数就可以了\nactions.move_to_element(element).perform()\n\n完整解决办法参考：【Python】selenium遇到ActionChains.move_to_element() takes 2 positional arguments but 4 were given报错\n修改好了之后，再用pytest运行这个文件，其会弹出一个火狐的浏览器窗口，并在窗口里面复现我们刚刚录制的操作了！\n3.代码学习只会录制是不够的，我们还需要学会这个库的webdriver API基本使用；\n\n需要注意是，不同版本的python selenium包其内部函数有所区别，请确认您的版本和本文所使用的版本相同！否则会出问题的😶‍🌫️\nselenium   4.11.2\n\n3.1 小试牛刀在百度主页，用F12打开开发者模式，选中搜索框，能定位到如下html代码\n&lt;input id=&quot;kw&quot; name=&quot;wd&quot; class=&quot;s_ipt&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt;\n\n先来看看如下的示例代码吧，这个代码的作用是在百度里面搜索selenium；\n这里我们选择了webdriver.Firefox()火狐作为驱动；随后使用了By.ID定位到了kw的位置，即这个搜索框，并在内部send_keys输入了selenium文字。\n休眠了2秒后，又通过ID找到了su的html标签（这是确认搜素的按钮），并使用click()方法点击了这个按钮；\n# coding = utf-8from selenium import webdriverfrom selenium.webdriver.common.by import Byimport timebrowser = webdriver.Firefox()  # 使用火狐的浏览器驱动（必须在python安装目录里面安装对应驱动）time.sleep(2)browser.get(&quot;http://www.baidu.com&quot;)  # 打开网页time.sleep(2)browser.find_element(By.ID,&quot;kw&quot;).send_keys(&quot;selenium&quot;)  # 找到网页中的id为kw的地方，输入&quot;selenium&quot;time.sleep(2)browser.find_element(By.ID,&quot;su&quot;).click()  # 点击id为su的按钮time.sleep(2)browser.quit()  # 退出网页\n\n除了quit()，还有close()办法也能关闭网页\nbrowser.close() # 也可以关闭窗口。# 两者的区别是：# close方法关闭当前的浏览器窗口，quit方法不仅关闭窗口，还会彻底的退出webdriver，释放与driver# server之间的连接。所以简单来说quit是更加彻底的close，quit会更好的释放资源。\n\n最终运行的效果如下（录制的动图，效果可能不咋地）\n\n3.2 元素的定位3.2.1 基本说明在html中元素的定位是自动化测试的核心，脚本必须要知道你需要操作的是什么页面的元素，才能正常进行自动化处理；\n而在html中，一个对象可以用不同的办法来定位到\nidnameclass namelink textpartial link texttag namexpathcss selector\n\n前面提到过，百度的输入框html是下面这样的。光是在这一行html代码中，就包含了id、name、class这三个可以用于我们来定位的元素，还有“看不到”的css也能定位到这里。\n&lt;input id=&quot;kw&quot; name=&quot;wd&quot; class=&quot;s_ipt&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt;\n\n浏览器开发者模式中，右侧就能看到和kw相关的css是#kw\n\n需要注意的是，要想定位到唯一元素，必须要保证这个元素的标识符在整个页面是唯一的！假设百度的主页有两个id=&quot;kw&quot;的元素，那就没有办法通过id来定位到输入框！这就要求写前端的朋友们，尽可能地为每一个需要测试的页面元素留下一个唯一的id或者name，保证自动化脚本能正常运行！\n不同定位方式，我们只需要修改By.来自什么，以及传入对应的参数就可以了！\n#  通过id 方式定位browser.find_element(By.ID,&quot;kw&quot;).send_keys(&quot;selenium1&quot;) # 找到网页中的id为kw的地方，输入&quot;selenium&quot;#  通过name 方式定位browser.find_element(By.NAME,&quot;wd&quot;).send_keys(&quot;selenium2&quot;)#  通过tag name 方式定位browser.find_element(By.TAG_NAME,&quot;input&quot;).send_keys(&quot;selenium3&quot;) # 不能成功，因为input元素太多了，不唯一！#  通过class name 方式定位browser.find_element(By.CLASS_NAME,&quot;s_ipt&quot;).send_keys(&quot;selenium4&quot;)#  通过CSS 方式定位browser.find_element(By.CSS_SELECTOR,&quot;#kw&quot;).send_keys(&quot;selenium5&quot;)#  通过XPATH 方式定位browser.find_element(By.XPATH,&quot;//*[@id=&#x27;kw&#x27;]&quot;).send_keys(&quot;selenium6&quot;)\n\n当运行到input定位的时候，由于定位不唯一，就会出现如下报错\nselenium.common.exceptions.ElementNotInteractableException: Message: Element &lt;input name=&quot;ie&quot; type=&quot;hidden&quot;&gt; is not reachable by keyboardStacktrace:RemoteError@chrome://remote/content/shared/RemoteError.sys.mjs:8:8WebDriverError@chrome://remote/content/shared/webdriver/Errors.sys.mjs:187:5ElementNotInteractableError@chrome://remote/content/shared/webdriver/Errors.sys.mjs:347:5webdriverSendKeysToElement@chrome://remote/content/marionette/interaction.sys.mjs:631:13interaction.sendKeysToElement@chrome://remote/content/marionette/interaction.sys.mjs:605:11sendKeysToElement@chrome://remote/content/marionette/actors/MarionetteCommandsChild.sys.mjs:535:29receiveMessage@chrome://remote/content/marionette/actors/MarionetteCommandsChild.sys.mjs:152:31\n\n这是因为有一个&lt;input name=&quot;ie&quot; type=&quot;hidden&quot;&gt; 标签被隐藏了，我们的send_keys函数（相当于键盘）是没有办法往这个标签里面输入信息的，整个进程也就此退出了。\n3.2.2 Xpath这里对XPATH做一个小小的解释\n\nXPath（XML Path Language）是一种用于在XML文档中定位元素和节点的语言。它是一种基于树结构的表达式语言，通常用于在XML文档中进行导航和搜索操作。XPath 可以帮助您根据元素的层次结构、属性和文本内容来精确定位特定的元素或节点。因为HTML可以看做XML的一种实现，所以我们可以用XPath来定位HTML中的元素。\n你可以理解位Xpath类似于正则表达式，可以通过特定的表达式来匹配到我们想要的位置。这里只做了解即可，后续有需要再深入学习；\n\n说明贪多嚼不烂，当时就是为了面试零时抱佛脚学的，既然现在用不到了，那没必要继续记录博客了。\n","categories":["速通Python"],"tags":["Python","selenium"]},{"title":"【leetcode】1137. 第 N 个泰波那契数","url":"/posts/563921472/","content":"今天是学习动归的第一天，先来一道简单题练练手吧！\n1.题目\nleetcode 1137. 第 N 个泰波那契数\n\n泰波那契序列 Tn 定义如下： \nT0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2\n给你整数 n，请返回第 n 个泰波那契数 Tn 的值。\n需要注意的是，这里的不是我们常用的斐波那契数列，哪个是 Tn = Tn-1 + Tn-2，而这里是三个；\n2.动归解法动态递归的思路是需要找到一个递归方程，本题中的递归方程已经给出来了。但是需要注意的是，当n小于3的时候，这个递归方程是不可用的（因为我们没有办法计算T负数的值）\n2.1 解法1-递归如下是我的第一个解法，通过递归函数计算数值，并提前写入0、1、2这三个数值到数组里面。\n如果数组里面有值，直接取出来，如果没有值，在计算了之后再赋值到数组里面。这样就能保证在整个递归流程中，相同下标处的数据只会被计算一次（不这么做会超时）\n#define DEF -1 //默认值    // 直接用递归会超时    // 想法是将数据存到vector里面，避免针对某一个数的二次递归运算    long long fib(int n,vector&lt;int&gt;&amp; _map)&#123;        if(_map[n] != DEF)&#123;            return _map[n];        &#125;        long long ans = fib(n-1,_map) + fib(n-2,_map)+fib(n-3,_map);        _map[n] = ans;        return ans;    &#125;    int tribonacci(int n) &#123;        vector&lt;int&gt; _map(40,DEF);        _map[0] = 0;        _map[1] = 1;        _map[2] = 1;        // 初始化并传引用给递归函数        return fib(n,_map);    &#125;\n\n使用该方法的通过率如图\n\n2.2 方法2-迭代还是相同的思路，只不过这次我们不用递归，而是用迭代来计算出数组里面对应下标的值，最后再返回给用户\nint tribonacci(int n) &#123;    if(n&lt;=1)&#123;        return n;    &#125;    vector&lt;int&gt; _map(n+1,DEF);    _map[0] = 0;    _map[1] = 1;    _map[2] = 1;    for(int i=3;i&lt;_map.size();i++)&#123;        _map[i] = _map[i-3] +_map[i-2]+_map[i-1];    &#125;    return _map[n];&#125;\n\n该办法的通过率如图，时间复杂度和空间复杂度都是O(N)\n\n2.3 迭代+变量既然在计算的时候我们只需要用到当前数据和该数据之前的3个变量，所以我们完全可以用固定的几个变量来实现这个操作，每次计算之后，都对变量进行一次轮换就ok了，官方的题解就是这么操作的\nint tribonacci(int n) &#123;    if (n == 0) &#123;        return 0;    &#125;    if (n &lt;= 2) &#123;        return 1;    &#125;    int p = 0, q = 0, r = 1, s = 1;    for (int i = 3; i &lt;= n; ++i) &#123;        p = q;        q = r;        r = s;        s = p + q + r;    &#125;    return s;&#125;\n\n这样操作，时间复杂度还是O(N)，但是空间复杂度就降到O(1)了！\n\n3.矩阵计算如果不用递归，还可以用矩阵乘法运算，该方法的时间复杂度是O(LogN)\nhttps://leetcode.cn/problems/n-th-tribonacci-number/solutions/921898/di-n-ge-tai-bo-na-qi-shu-by-leetcode-sol-kn16/\n\n奈何本人线代知识忘记了，完全看不懂\nclass Solution &#123;public:    int tribonacci(int n) &#123;        if (n == 0) &#123;            return 0;        &#125;        if (n &lt;= 2) &#123;            return 1;        &#125;        vector&lt;vector&lt;long&gt;&gt; q = &#123;&#123;1, 1, 1&#125;, &#123;1, 0, 0&#125;, &#123;0, 1, 0&#125;&#125;;        vector&lt;vector&lt;long&gt;&gt; res = pow(q, n);        return res[0][2];    &#125;    vector&lt;vector&lt;long&gt;&gt; pow(vector&lt;vector&lt;long&gt;&gt;&amp; a, long n) &#123;        vector&lt;vector&lt;long&gt;&gt; ret = &#123;&#123;1, 0, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, 0, 1&#125;&#125;;        while (n &gt; 0) &#123;            if ((n &amp; 1) == 1) &#123;                ret = multiply(ret, a);            &#125;            n &gt;&gt;= 1;            a = multiply(a, a);        &#125;        return ret;    &#125;    vector&lt;vector&lt;long&gt;&gt; multiply(vector&lt;vector&lt;long&gt;&gt;&amp; a, vector&lt;vector&lt;long&gt;&gt;&amp; b) &#123;        vector&lt;vector&lt;long&gt;&gt; c(3, vector&lt;long&gt;(3));        for (int i = 0; i &lt; 3; i++) &#123;            for (int j = 0; j &lt; 3; j++) &#123;                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];            &#125;        &#125;        return c;    &#125;&#125;;\n\n测了一下效果，好像效率和使用2.3的办法没啥区别，那我还是用动归吧😭\n\n以后有时间了再来纠结这个答案的思路\n","categories":["把题目都给刷干净"],"tags":["C++","OJ刷题","leetcode"]},{"title":"【Linux】修改腾讯云轻量应用服务器的hostname","url":"/posts/4130440541/","content":"今天想修改云主机的hostname，但是腾讯云的控制台里面好像不能直接改这个名字\n需要在root用户里面修改！\n\n\n\n参考https://cloud.tencent.com/developer/article/1190061\n\n\n修改前：修改后：\n1.查看当前的主机名称hostname\n\n2 .临时修改主机名称不建议使用，重启之后又会还原\n//hostname 主机名称hostname XXX\n\n3.永久修改主机名称//hostnamectl set-hostname 主机名称hostnamectl set-hostname XXX\n\n4.重启服务重启后效果就出现了\nreboot\n谢谢你，BT7274\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【网络】CDN/PCDN/SDN详解","url":"/posts/292924834/","content":"朴实的学习原因：京东实习生招聘条目上写了这些技术，那就给他学了！\n\n\n\n参考https://blog.csdn.net/baidu_41651554/article/details/122218513\n\n嗨嗨嗨，直接上菜！\n1.CDNCDN的全程是content delivery network，内容分发网络；说人话就是把网站产生的内容分发到各个用户请求的网络里去，具有 分布式 网络的特点！\n1.1 前置声明当代网络形势错综复杂，特别是视频、音频类网络服务的兴起，给互联网的贷款造成了很大的压力啊！\n以之前很火的“延禧攻略”为例，当时曾经在某视频APP实现了1千万用户同时在线观看。如果大家观看的是1080p清晰度的视频（理论上需要4Mbps带宽），那么，累计需要的流量带宽是$$10,000,000×4Mbps&#x3D;40,000,000Mbps&#x3D;40Tbps$$这个数字老恐怖了！对于优酷、爱奇艺这样的互联网视频内容提供商来说，这无疑是非常巨大的流量压力。\n如果按服务器用的10Gbps的万兆网卡来算，那也需要四千块万兆网卡才能顶得住这么大的流量消耗，更别提压根没有那么多地方给你插这么多网卡的事情了；\n有这么一个说法：当用户打开一个页面，等待超过4秒，他就会关闭这个页面。也就是说，这个用户就会流失。用户流失对于公司来说可就是金钱流失！\n所以，没有任何一家互联网服务提供商原因因为网络的问题而流失客户，那么我们就得像个办法来解决这种流量短时间暴发的问题！\n而CDN，就是一项非常有效的缩短时延的技术。\n1.2 技术主体CDN缩短用户延时的办法也非常“简单”，其实就是将云服务部署到用户身边。在访问的时候，根据DNS的多线解析能力（即为不同地区提供不同的IP解析）选择离用户最近的服务器来为用户提供服务。\n\n因为这样，CDN就在内容层面上进行了一定的筛选和分发，所以他就叫内容分发网络；\n具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓）\n大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。\n确切地说，CDN&#x3D;更智能的镜像+缓存+流量导流\n而且还需要注意的是，CDN并不是只能缓存视频内容，它还可以对网站的静态资源（例如各类型图片、html、css、js等）进行分发，对移动应用APP的静态内容（例如安装包apk文件、APP内的图片视频等）进行分发。\nCDN的具体工作流程。举个例子，如果某个用户想要访问优酷的视频点播内容，那么：\n\n具体步骤如下\n\n当用户点击对应资源内容，应用根据域名地址到底层触发DNS请求；\n先是请求的本地运营商的DNS，再转发到CDN域名服务的DNS；\nCDN域名服务的DNS会将CDN的全局均衡负载服务器的IP地址返回给用户；\n用户向CDN的负载均衡设备发起URL的访问请求；\nCDN的负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域（离用户越近越好）的缓存服务器；\n负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求；\n用户向缓存服务器发起请求，缓存服务器响应，将用户请求内容发送给用户\n如果这台服务器上没有用户想要的内容，那就根据CDN设置的回源服务器（又称源站）来请求该URL\n缓存服务器从源站拉取内容缓存到本地，并传输给用户；并根据用户设置的缓存策略来判断是否需要保留该资源到本地，是则进行缓存。\n\n在CDN工作的整个流程中，源站的服务器IP是对用户不可见的；CDN服务在实现了一定的资源访问加速的基础上，还附带了隐藏源站IP的功能，避免源站直接遭受火力打击（指服务器被攻击）\n1.3 静态加速所谓静态加速，是只加速源站所提供服务中的静态资源，包括js、html、css、图片、音视频等不会出现变动的资源文件。将这些资源在CDN云服务器内进行缓存，用户访问静态资源的时候从CDN传输给用户，访问asp、php、jsp等动态资源的时候，从源站抓取，既保证了数据的及时性，又提高了静态资源的加载速度。\n相比于动态资源文件，静态资源，特别是图片，是访问过程中消耗流量较大的部分；使用静态资源加速能大大减轻源站的网络贷款和资源负载的压力，又减少了用户的加载速度，使得网络服务能更快的展现在用户面前；\n1.4 动态加速动态加速是指CDN的DNS解析中通过动态链路探测，监控网络环境的变化，监控各地网络延迟，寻找到一条最稳定、最高效、最快速的路径，回源动态资源，从而实现动态资源（如asp、php、jsp等）加速。然后构成链路列表，绑定到DNS解析上，更新到CDN的本地域名服务器上。简单架构见下图所示。\n\n1.5 数据节点的更新和同步cdn分为推拉两种方式\n\n推是服务器将内容推到cdn节点上\n拉是cdn在第一次接受请求的时候从服务器拉取资源进行响应并保存\n\n当资源在cdn缓存之后，如果服务器上的资源发生变化，cdn节点是不会知道的，除非缓存时间到期重新拉取或者修改新资源的访问。\n动态资源的话，一般都是无延迟的。静态对于 css 和 js 来说，建议在编译生成的阶段，为文件名加上时间戳。而且最好是在文件名里面，而不是 querystring 里面加。这是最方便的方案，因为一旦发生了更新，每次去取的一定是新文件，不涉及缓存刷新的问题。\n1.6 CDN的好处1.6.1 对服务商采用CDN技术，最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。\n而且，分发至不同线路的缓存服务器，也让跨运营商之间的访问得以加速。例如中国移动手机用户访问中国电信网络的内容源，可以通过在中国移动假设CDN服务器，进行加速。效果是非常明显的。\n此外，CDN还有安全方面的好处。内容进行分发后，源服务器的IP被隐藏，受到攻击的概率会大幅下降。而且，当某个服务器故障时，系统会调用临近的健康服务器，进行服务，避免对用户造成影响。\n正因为CDN的好处很多，所以，目前所有主流的互联网服务提供商，都采用了CDN技术。所有的云服务提供商，也都提供了CDN服务（价格，按流量计费）\n1.6.2 对通信行业\n互联网服务提供商采用CDN，是以存储换时延。花钱购置CDN服务器或云计算服务，以此换取更好的用户体验。\n通信运营商也追捧CDN，但它们的目的，是以存储换带宽 ——通过服务“下沉”，减轻上层骨干网络的流量压力，避免硬件扩容，降低网络建设成本。\n\n以上文提到的爱奇艺看视频的高带宽问题为例，如果不采用CDN，那就是巨大的流量流入同一个机房，这会导致这个机房入网&#x2F;出网的线路被拥塞，影响其他业务的进行！\n同样的，如果大量的业务流量数据在骨干网跑来跑去，骨干网肯定吃不消，要拼命扩容。如果这些业务流量数据在底层就被解决了，那么，骨干网的带宽压力自然就减轻了。\n很多运营商已经将CDN下沉到地市级，以此减轻压力，同时可以提升用户体验！可谓是一举两得的美事！\n\n2.PCDNPCDN技术是P2P技术+CDN技术的集和，在认识PCDN之前，我们首先要简单了解一下P2P技术\n2.1 P2PP2P即Peer to Peer，是一种对等连接方式，纯P2P架构包含如下内容\n\n没有总是在线的服务器\n任意端之间直接通信\n对等方之间可以间断链接，并可以动态改变IP地址\n\n实际的用例如下\n\n文件分发（BT下载）\n流媒体\nVolP\n内网穿透式访问（建立P2P链接，直接和内网主机通信）\n\n\n关于P2P想了解更多信息可以查看此文：详解P2P技术\n2.2 PCDN2.2.1 流程前面提到了，PCDN是P2P+CDN，那么其是如何将P2P技术和CDN结合起来的呢？\n在阿里云官网上可以看到对PCDN的介绍：一篇文章解读提速、降费黑科技：PCDN定义、功能、架构、场景和优势；本文是对这篇文章的个人理解。\n\nPCDN产品是与传统CDN互补协作的关系，以P2P技术为核心的分布式PCDN系统可与传统CDN、云CDN无缝集成，形成互补协作，相对于CDN拥有成本更低、质量更好两方面的核心优势。\n\nP2P 内容分发网络（英文名：P2P CDN，以下简称PCDN）是以P2P技术为基础，通过挖掘利用边缘网络海量碎片化闲置资源而构建的低成本高品质内容分发网络服务。你可以通过集成PCDN SDK（以下简称SDK）接入该服务后能获得等同（或略高于）CDN的分发质量，同时显著降低分发成本。适用于视频点播、直播、大文件下载等业务场景。\n使用PCDN后的http请求处理流程如下图：\n\nP2P的加入，就是将一些数据预先留存在部分终端设备（比如家用路由器，个人电脑，个人NAS）等产品上，再通过P2P技术，从这些Peer做种端获取到一部分数据，以此为周边用户提供服务。\n使用PCDN的SDK后，在请求DNS之后，还会去请求PCDN的调度系统，PCDN同时会返回可用的CDN服务器，和可用的P2P做种端，用户能同时从多端获取到数据（根据文件分块，从不同地方获取同一文件不同分块的数据，提高文件下载速度）\n比如一个文件有1MB，那么使用PCDN，我们可能服务商的从CDN服务器拉取了500KB，再从上图中所示的两个peerid端获取到了500KB数据；\n因为p2p使用的是个人的peer终端节点，不仅数量多，且分布比CDN服务器更广，理论上来说至少能获得等同于仅使用CDN技术的速度优势，如果用户可以连接到的peer较多，则速度就会大于仅使用CDN技术！\n而这些作为peer的做种端，会定期从CDN缓存一部分热门数据到本地，并为其他与自己建立P2P链接的终端提供服务。\n\n京东云路由器、迅雷的网心云、百度云盘PC客户端的闲时带宽上传，其实都是使用了PCDN技术的终端产品，其会在占用一小部分用户带宽的基础上，给用户提供京豆&#x2F;现金奖励；但是PCDN似乎和运营商的政策冲突，具体的就不了解了，本文只是来学习技术的。\n\n2.2.2 优点以下优点来自阿里云那篇文章\n\n价格低：通过P2P技术可为客户提供更低成本的内容分发服务，（以峰值带宽计价）为云CDN价格的1&#x2F;2，为传统CDN价格的1&#x2F;4，可显著降低客户的分发成本；\n因为使用了更多P2P节点，减轻了CDN服务器、源站服务器的网络带宽压力，所以PCDN能在一定程度上起到降本增效的作用。\n\n质量好：通过CDN+P2P多级节点调度，一个请求可由CDN和多个P2P源同时提供内容，通过资源冗余提高了服务可用性，播放流畅率高于纯CDN，在大文件下载场景中更是能极大提高下载速度；通过调用海量分布式P2P节点， 平均播放流畅率 &gt; 97%，平均首播时间小于1秒，用户体验得到有效提升。\n\n成熟稳定：多年为优酷土豆提供优质的视频播放、下载等加速服务，接入带宽超10T，经历了海量用户规模的长时间验证。拥有内网穿透、缓存处理、种子管理、传输策略等各方面的核心技术和专利；（这是阿里云给自己打的广告）\n\n\n\n2.3 常见名词以下是PCDN中常见的名词；这里面漏了的一级节点指的应该是CDN服务器；\n\n由此可见，上文提到的京东云路由器、迅雷的网心云，这些客户端在用户的电脑启动后，其就是作为PCDN的三级节点接入整个PCDN的网络的，其提供的也是三级带宽；\n2.4 基础架构关键组件\n\nindex服务：全局调度，把用户请求调度到最佳的机房\nZooKeeper (Global&amp;Local)：服务活动情况汇报给调度服务，动态配置更新\nNignx Proxy：支持私有协议的nginx代理服务，针对不同文件一致性Hash到不同的Channel服务\nChannel服务：记录文件和拥有文件的端点地址信息，为下载提供就近的端点地址\nRealy服务：服务P2P建立连接和通讯\nHot服务：hot文件发现和推送\n\n以下是PCDN技术的架构图\n\n整个技术的流程在上文已经讲解过了。这里的架构图阿里云的文章并没有提供更多的说明，具体的就得在真正需要开发PCDN的时候在公司内部深入学习了。\n2.5 适用范围PCDN产品适用于视频点播、直播、大文件下载等业务领域。\n\n视频点播：长视频点播，热度集中的短视频点播。\n视频直播：大型晚会赛事直播、地方网台直播、秀场互动直播。\n大文件下载：超过1MB且热度集中的的文件分发，如应用市场分发、在线音频分发。\n\n3.SDNSDN全称Software Defined Network，概念最早由斯坦福大学的Nick McKeown教授于2009年提出；谷歌于2010到2012年建立的数据中心网络B4是SDN的成功案例；\n该技术学习于b站【408 计算机网络新增考点—软件定义网络SDN（字幕版）】\n3.1 看看路由器的功能路由器具备如下功能\n\n报文转发\n路由选择\n\n在当前的路由器架构中，分为数据层面和控制层面。\n\n为了构建出自己的路由表，路由器必须要和周边的其他路由器定期通信，才能通过自己的路由算法设置出路由表，并选择正确的路由路径（这个耗时较长）\n在数据层面，路由器采用硬件，查表进行转发（耗时低）\n\n\n\n分组是网络专有名词。大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组（packet）。也有些书籍把分组定义为网络层的协议数据单元。\n说白了分组就是一个报文！\n\n3.2 SDN核心思想\nSDN这种新型网络体系结构的核心思想，是将网络的控制层和数据层面玻璃，让控制层可以通过软件来控制数据层的较多设备\n\n在SDN体系中，路由器的路由软件被剥离开，路由器之间也不再需要交换路由信息。\n\n控制层面：有一个逻辑上集中的远程控制器，对多个交换机进行控制；该远程控制器可以由多台物理主机组成\n\n远程控制器会掌握各个主机和整个网络体系的状态，并为每一个路由分组计算出最佳的路由，和生成正确的转发表；这时候，底层的路由器硬件就仅仅需要进行查表转发，而不需要进行耗时的路由表生产和算法计算了，大大减轻了底层交换机和路由器硬件的压力。\n\n3.3 OpenFlow协议OpenFlow协议是一个受到高度认可的标准，其一般在SDN中进行使用，但SDN并不一定要用OpenFlow；\n\nOpenFlow协议由开放网络基金会ONF负责指定，该基金会致力于SDN的发展和标准化；OpenFlow协议目前较为成熟的是1.3版本\n\nOpenFlow协议是SDN体系结构中，控制层面和数据层面之间的通信接口，该协议可以允许控制层面的控制器对数据层面的物理设备进行直接的访问和控制。\n\n3.4 路由转发的区别3.4.1 传统路由表传统的路由转发是查询路由表，根据地址掩码计算目的网络，判断是否与当前条目匹配，如果匹配，则从对应的「下一条」中发送出去。\n路由转发这部分内容在我的IP协议详解博客中有所涉及：点我\n\n3.4.2 SDN广义转发SDN在这基础上新增了更多的内容，称为广义转发：\n\n进行匹配：能够对网络体系结构中的各层（数据链路层，网络层，传输层）首部中的字段进行匹配\n执行动作：不仅转发分组，还可以实现负载均衡、重写IP首部（类似NAT中的路由地址转换）、人为阻挡或丢弃一些分组（类似防火墙）\n\n在SDN广义转发中，完成这一操作的设备不再称为路由器，而是叫做OpenFlow交换机（或分组交换机），也可以简称为交换机。\n3.4.3 流表在SDN中替代 了传统路由表的是「流表（Flow Table）」\n\n一个流就是整个网络中的一组分组序列，在此序列中的每个分组都是共享分组首部某些字段的值，例如，某个流可以是共享相同的源IP和目的IP地址的一连串分组\nOpenFlow交换机中的刘表是由SDN远程控制器来管理的，SDN远程控制器通过一个安全信道，通过OpenFlow协议来管理OpenFlow交换机中的流表\n\n\n\n每个OpenFlow交换机必须有一个或者多个流表\n每一个流表包含多个流表项目\n每个流表项包含三个字段：首部字段值（匹配字段）、计数器、动作（类似下一跳）\n\nOpenFlow的首部字段值跨越了三个层次的首部，既可以处理数据链路层的MAC帧，又可以处理IP报文，或者是TCP&#x2F;UDP的端口\n\n计数器字段包含一组计数器\n\n记录已经与该流表项匹配的分组数量的计数器；\n记录该流表项上次更新到现在经历的时间的计数器\n\n动作字段是一族动作，当分组匹配到某个流表项时，执行下方的一个或者多个动作\n\n把分组转发到指定的端口\n丢弃分组\n把分组进行复制后，从多个端口转发出去\n重写分组中的首部字段\n\n3.4.4 VLAN\n关于该报文中VLAN部分可以查看此博客：https://blog.csdn.net/LawssssCat/article/details/127204720\n\nVLAN是一种用于进一步虚拟化划分局域网的方式，假如一台路由器有4个网口，其可以通过将LAN1和LAN2设置成VLAN10，LAN3和LAN4设置成VLAN20来模拟出两个局域网\n\nvlan（virtual lan）技术提供了一种灵活的解决方案；将交换机的接口根据业务需要添加到不同的vlan中，从而实现二层隔离。\n\n隔离广播域，即广播包只在本 vlan 中传播，从而在一定程度上可以提高整个网络的处理能力；\n提高安全性，一个 vlan 内的用户和其他 vlan 内的用户不能互访，提高了网络的安全性；\n增加带宽利用&#x2F;降低延迟&#x2F;管理作用\n\n3.5 举例3.5.1 简单转发通过不同的流表项来设置转发路径和转发动作，动作中的转发(3)代表从该交换机的3号端口转发出去。端口号在图中有标注；\n\n3.5.2 负载均衡第二个栗子是负载均衡的栗子，在下面的场景中，我们想要H3发送的分组通过S2-S1-S3-H5/H6，要H4发送的分组通过S2-S3-H5/H6；以达到负载均衡的目的。\n\n使用传统的源IP和目的IP的转发方式，无法实现这样的负载均衡。在传统场景下，当S2在数据链路层发现目的MAC地址是S3的MAC地址的时候，无论如何都会直接发送给S3，而不是从S1处绕路。\n但在SDN场景中，就可以通过两个不同的流表项来规定不同转发动作，实现这样的负载均衡（这里的转发(4)代表从S2的4号端口转发出去）\n\n3.5.3 防火墙如果我们想让S2主机只接收来自S1的数据而不接受S3的数据，就可以通过只设置S1的源IP地址的流表项，来丢弃S3发送的数据（匹配不上的数据就会被丢弃）\n\n3.6 SDN体系结构的特征下图中包含了SDN的体系结构一览图和SDN的四个关键特征\n\n基于流的转发\n数据层面与控制层面分离\n位于数据层面分组交换机之外的网络控制功能\n可编程的网络\n\n其中，SDN控制器是这个架构中最复杂的设备，其通过南向API控制底层的OpenFlow交换机，通过北向API接受其他网络控制器的策略配置。\n\n3.6.1 SDN控制器SDN控制器可以分成三个层次\n\n其通信层通过OpenFlow协议与交换机通信\n中间间来根据各种策略管理各个交换机\n北向API接收来自其他控制策略发起端的配置\n\n\n这里使用的RESTful API 是基于HTTP的API，也是我们较常见的API接口；\n3.6.2 开源SDN控制器常用的开源SDN控制器有OPEN DAYLIGHT和ONOS；\n3.6.3 SDN的优势\n原文链接：https://blog.csdn.net/as12138/article/details/131273381\n\nSDN相比于传统网络架构，有许多优点和优势。\n\n高度可编程性：SDN架构中的控制器负责管理交换机和路由器，使得网络更加可编程、可配置。管理员可以通过控制器实现灵活调整网络拓扑、管理流量和配置流调度策略，提升网络的可演变性、可定制化和可伸缩性。\n\n网络智能集中化：在SDN中，网络智能被集中在控制器中，通过控制器进行集中式管理和控制。这种分离的模式避免了网络设备中任务的复杂，提升了网络的可管理性和可控制性。此外，集中化的管理方式也可以在网络中间件和应用中实现智能控制，如分布式存储、云计算等。\n\n可扩展性：SDN中的网络设备是通用的硬件设备，不需要特定的功能区分，同时也不需要更新硬件，只需更新控制器即可实现拓扑可伸缩和灵活的网络管理。\n\n自动化和提高效率：SDN中可以实现网络的自动化，通过控制器进行自动化的网络管理，可以避免手动管理网络的局限性和不确定性，从而提高网络的效率和稳定性，同时，自动化网络管理也可以降低网络维护的成本和时间。\n\n安全可靠性提升：网络安全和可靠性是企业网络中最基本的需求。传统的网络安全往往需要通过一些特定设备和协议来实现。相比之下，SDN中的控制器可以根据网络实时状态自动优化管理策略，安全可靠的方式来提高网络的安全性。\n\n\n总之，SDN的优势在于其灵活的可编程性、集中式智能管理、高效的自动化网络管理和增强网络安全性。以上优势也是SDN技术应用广泛的主要原因，越来越多的企业和组织将SDN技术应用到自己的网络架构中，以满足未来网络的需求和挑战。\n3.6.4 SDN应用前景SDN技术目前已经实现了基础网络配置、流控制、网络安全等功能。在未来，SDN技术还会面临更多的挑战和机遇。\n\n5G时代：5G技术将会改变网络的面貌，加速物联网应用的普及。SDN作为架构灵活、可编程的网络方式，将会在5G网络中发挥重要作用，实现网络的自动化和智能化管理。\n\nIoT设备：物联网技术带来大量设备的连接，SDN技术的价值在于自动化了物联网设备的管理、安全和监控。未来，SDN技术将会成为物联网管理的重要工具。\n\nAI：随着人工智能的发展，SDN的业界应用已经开始大规模落地。这将加速智能交通、智能城市和自动驾驶等领域的发展。\n\n集成新技术：SDN可以很容易地与其他技术相结合，例如NFV（网络功能虚拟化）和AI（人工智能），以提高网络的效率和适应性。\n\n云计算：SDN技术的灵活性和可编程性，也使得SDN与云计算等新技术的结合变得更加自然。在未来，SDN技术将与云技术紧密结合，实现业务流程的自动化、快速应用部署和弹性云资源管理。\n\n\n总而言之，SDN技术将为未来网络的发展和实现各种应用提供支撑。在日益增长的网络需求和复杂的网络技术背景下，SDN的灵活性和高可用性将会带来更大的发展空间和市场需求。SDN技术应当继续研究和发展，以满足更多的网络需求和挑战。\n3.7 总结\n","categories":["差生文具多"],"tags":["nginx","CDN","SDN","P2P"]},{"title":"【工具】centos7系统下使用vimplus配置vim的C++环境","url":"/posts/274956107/","content":"centos7系统下使用vimplus配置vim的C++环境开源项目请参考：https://gitee.com/chxuan/vimplus\n配置好的界面如下：\n\n\n1. 准备工作：ubuntu 或者 centos7 系统 \n因为默认下载都是从github拉的，很容易就下载不下来，建议提前下载vim.zip插件安装包 vim.zip - 蓝奏云 (lanzouj.com)\n也可以到慕雪的 Gitea 去下载这个压缩包 https://gitea.musnow.top/musnow/vimplus/src/branch/master/vim-plugins.zip\n2. 具体实现：# 1.1 centos下安装git，sz/rz:yum -y install gityum install -y lrzsz    # 1.2 ubuntu下安装git,sz/rz:sudo apt-get install gitsudo apt-get install lrzsz    # 2.克隆最新版本git clone https://gitee.com/chxuan/vimplus.git# 3.完成后当前路径下出现vimplus文件夹，cd vimplus,并且执行脚本 ./install.shcd vimplus./install.sh\n\n\n\n下载过程中询问：选择python2/3，这里选择3\n3\n\n\n当前这一步包含许多github上面的项目插件，如果网速允许，就已经结束安装；\n如果网速慢，则可以退出当前加载界面：\n# 进程挂起，中断下载，或者命令模式输入 esc + :q 退出CTRL+z    # 切换目录,然后把开始下载的vim.zip拖进来,然后解压： cd  /root/.vim/plugged unzip vim.zip    # 询问时否替换，依次输入 y  A，结束安装yA# vim进入界面，命令模式下，输入PlugInstall检验是否安装完毕:PlugInstall# vim进入依然报错：YouCompleteMe 插件有问题,进入该目录下：cd  /root/.vim/plugged/YouCompleteMe# 输入./install.sh --clang-completer\n\n如果插件都安装好了，执行:PlugInstall应该显示如下界面\n\n至此vimplus配置安装已经结束！参考视频：Vim快速配置C++环境_哔哩哔哩_bilibili\nNoExtraConfDetected: No .ycm_extra_conf.py file detected问题：解决传送门：https://blog.csdn.net/xiaozhidian/article/details/118340118\n","categories":["差生文具多"],"tags":["Linux","vim"]},{"title":"【Linux】比Xshell更爽，用vscode连接云服务器进行开发","url":"/posts/3215059456/","content":"本篇博客教你如何用VScode的remote ssh插件连接上linux云服务器进行代码开发~\n\n\n[TOC]\n1.下载vscodevscode是微软官方的一款多语言代码编辑器，其因为丰富而强大的插件而被非常多用户选中使用！\n\n官网下载：https://code.visualstudio.com/\n\n在这里可以直接下载windows上的VSC，但是默认的下载链接下载是非常慢的！\nhttps://az764295.vo.msecnd.net/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n\n我们要做的就是把这个默认的下载链接改成国内的镜像源，下载速度就可以起飞！\n将下载地址中的az764295.vo.msecnd.net 更换为 vscode.cdn.azure.cn 更改后：https://vscode.cdn.azure.cn/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n\n这速度岂不爽炸了！\n\n1.1 安装一些插件\n在开始之前，我们需要安装一些必要的插件：\n\nChinese (Simplified) (简体中文) Language Pack for Visual Studio Code\nRemote - SSH\n\n\n如果你没有其他的开发需求的话，默认安装这两个就可以让我们愉快地登陆上linux服务器了！\n1.2 连接云服务器安装完remote ssh之后，你的左侧应该会出现这样一个按钮\n\n在最上面的链接模式我们选择ssh targets，在这里可以点击+号添加linux服务器\n\n这里填写的格式为 shh 用户名@公网ip。比如我的用户名是user，公网ip是114.514.20.22，那么需要填写的便是\nssh user@114.514.20.22\n\n\n输入完后会让我们选择一个路径，我们选第一个就可以了，方便日后管理\n\n这时候右下角会弹窗告诉你host add，成功添加了一个远程终端\n打开user路径下的.ssh/config文件，可以看到下面关于host的信息。其中我们可以把Host改成和user同名，注意不要修改hostname哦！\n\n重启vsc，然后你应该就可以在左侧看到刚刚添加的linux云服务器。我们右键这个终端，会出现一个选项卡询问你是在当前vsc界面打开该终端，还是新建一个vsc界面。这个根据自己喜好选一个就OK！\n\n初次链接会让你选择该终端的平台，我们选择linux即可！\n\n\n注意：这里我发现直接链接root会出现错误，可能是安全性考虑阻止了vscode在远程服务器的环境安装，后文改为我自己的子账户进行演示！\n\n1.3 关于修改host现在发现了问题，其实是因为host需要修改成和user一样才能正常访问，否则会报错\n\n同时下面ssh显示的是host名字，而不是公网ip\n\n\n这里我改成自己的子账户进行演示！\n\n输入咱们账户的密码\n\n这里vscode会在你的云服务器上装一些环境，当左下角出现你的公网ip（这里显示的是host，为公网ip是因为我没有改）那就代表链接成功了！\n\n到这里我们就已成功连上云服务器了！\n\n2. 常用插件推荐vscode连接的好处就是我们可以直接在云服务器环境里面安装插件！这里给大家推荐几个非常棒的插件：\n\nChinese (Simplified) (简体中文) Language Pack for Visual Studio Code\nTerminal Here（超级好用，必装！！）\nC&#x2F;C++\nC&#x2F;C++ Extension Pack\n\n如果你还学习python，可以安装下面的插件：\n\nPython\nPylance\nPip Manager\n\n安装这些插件的时候，会有一些附属插件被同时安装，我们不需要管它，交给vsc自己处理就行拉！注意安装的时候一定是选择安装在你的云服务器里面，如果安装在本地，对于云服务器来说是没有用的哦~\n\n3. 开启终端Linux最常用的当然还是终端了，我们使用快捷键ctrl+shift+p打开vsc的命令选择界面，搜索终端，选择下面这个视图：切换终端\n\n可以看到下面会出现一个熟悉的界面~linux的命令行有啦！\n\n但是，如果只用linux的命令行可完全没必要折腾vscode，这里介绍如何更方便的用vsc开发\n4. 打开文件夹在左侧最上面的分区中，我们可以选择打开一个文件夹\n\n这时候，你便可以选择你常用的工作文件夹，比如我的代码都在GIT文件夹里面，选择后vscode会打开它\n\n\n这里vscode会让你在输入一次linux用户的密码，后文会提到如何免密登录\n\n现在我已经打开了GIT文件夹，可以看到里面的几个子文件夹，这里创建一个新的test文件夹来作为演示\n\nvscode非常棒的一点是，他会帮你保存上一次打开本文件夹的命令行操作信息，不像Xshell打开一个新的之前的命令行操作就看不到了😂\n\n咱们直接右键创建一个新的test文件夹，在里面创建一个test.c文件\n\n随便写一个喜闻乐见的hello代码，vscode的代码补全比vim的插件好了不知道多少（个人感受）\n\n这时候之前安装的几个插件就派上用场了！C&#x2F;C++插件会为我们的代码提供高亮\n4.1 Terminal Here插件而Terminal Here这位更是重量级，我们可以方便的直接打开当前目录下的命令行，不需要自己cd进入文件夹！\n还是用ctrl+shift+p打开vsc的命令面板，搜索terminal，找到下面这个选项\n\n直接回车选择它，你会发现，它自动帮我们创建了一个test.c所处文件夹下的终端！当你的文件目录层级很多的时候，这能帮上大忙！\n\n这里用gcc编译一下，没啥好说的，非常尝龟的操作\n\n这里你能看到vscode的另外一个好处，他会给你把运行正常的命令标蓝，而运行不正常的则标红。\n比如我们在代码里面写个bug在尝试编译，可以看到前面的小点变红了！\n\n同时在右边的滚动条上也能清楚地看到那个地方的命令是运行失败标红的！\n\n而Terminal Here插件牛逼的地方还不止这个，如果你的代码是在Python-vnev的虚拟环境工作目录下，该插件还会自动帮你打开虚拟环境！省得我们自己敲这一行代码了\n\n如果你不知道vnev虚拟环境是啥，简单说一下：python有很多第三方软件包，我们可以通过pip下载安装。为了避免不同的项目中的包都直接安装在用户目录下造成环境污染，便可以创建一个vnev虚拟环境，在这个虚拟环境下安装包。\n只有在虚拟环境开启，且在它的工作目录下，才可以访问到这个包！\n\n\n\n咳咳，扯远啦！有了上面的引导，想必你已经可以愉快的用vscode在linux环境上开发了。\n下面介绍一下如何通过ssh密钥来免密登录，不需要每一次都输入密码\n5. ssh免密登录\n参考https://blog.csdn.net/weixin_42907822/article/details/125237307\n\n如果你之前配置过gitee&#x2F;github的ssh连接，那么肯定对下面的步骤有些熟悉\n\n5.1 生成ssh密钥我们打开windows的cmd，输入下面这个语句\nssh-keygen -t rsa -b 4096\n\n出现的提示信息全部回车跳过，不进行任何操作！\n\n第一行是让你填一个文件名，可以根据自己需要填写，也可以不填直接回车跳过\n\n随后系统会创建一个isa公钥和密钥，我们将其复制到c/用户/用户名/.ssh文件夹中，也就是最初配置vscode的ssh那个文件夹\n\n随后我们用Xshell里面的xtfp连接到云服务器，将有.pub后缀的文件拷贝到云服务器用户目录下的.ssh文件夹，并将其改名为authorized_keys\n\n\n设置.ssh文件权限～/.ssh\n\nchmod 700 ~/.ssh\n\n\n设置authorized_keys文件权限\n\nchmod 600 ~/.ssh/authorized_keys\n\n修改完后可以用ll命令看看是否正常修改成功，700对应的是 dxrw-------，600对应的是-rw--------\n还要注意当前文件的所属用户是谁，必须要是当前用户，才能正常ssh连接！否则会提示无权限！（有的时候ftp传上去的文件是root用户的）\n\n5.2 修改root下的配置文件（慎重)友情提示：当你修改任何linux环境下的文件之前，都要记得cp一份出来作为备份！\n进入你云服务器的root用户下，修改下面的文件\nvim /etc/ssh/sshd_config \n\n把 PubkeyAuthentication前的 # 号去掉，这样公钥验证才生效。\n\n修改后保存退出\n用下面的语句重启ssh服务\nsystemctl restart sshd.service \n\n如果无效，则尝试直接重启云服务器\nreboot\n\n5.3 修改本机ssh config文件随后我们再次打开本机(就你现在用的windows电脑).ssh路径下的config文件，注意是本机不是云服务器！\n在原本的配置信息后面追加下面两个，其中IdentityFile指代的是你刚刚生成的那个密钥的文件名，请根据你的实际文件名进行填写！\nPreferredAuthentications publickeyIdentityFile ~/.ssh/id_linux\n\n如果你的主机 ssh 端口端口不是 22，这里还可以继续添加一个 Port 选项选项来设置 ssh 的端口。\n\n前面创建sshkey的时候，第一个对话框是让你填写一个名字，在多终端配置的时候，名字可以方便我们管理不同的ssh密钥，如下是我的配置，Linux服务器和gitee&#x2F;github用的是不同的密钥（也必须用不同的，因为gitee&#x2F;github密钥需要指定邮箱）\n\n这里配置好之后，你应该就可以免密登录云服务器而不需要输入密码了！\n\n这一步可能会出现很多问题，这里建议大家查更多资料作为补充。不要在评论问我，因为我大概率也不会😥当初配置的时候也折腾了一会，也不知道自己是怎么搞定的（真的不知道）\n第一次配置好ssh后可能会连不上，需要重启vscode再试试！\n\n结语不知道这篇博客有没有帮到你呢？\n如果你根据本教程成功配置好了vscode，还请在下面评论说一声哦！\n万分感谢！\n","categories":["玩上Linux"],"tags":["Linux","vscode"]},{"title":"【Linux】设置系统防火墙，解决控制台开了防火墙依旧无法访问问题","url":"/posts/3168515672/","content":"今天在控制台开放了腾讯云服务器的防火墙，发现用ip:端口还是不能访问，查询了之后，才知道需要设置系统里面的防火墙\n\n\n1.命令firewall-cmd --zone=public --add-port=30100/tcp --permanentfirewall-cmd --reload\n\n语句的意思是开放30100的tcp端口，随后重新加载防火墙。\n如果要开放udp端口，吧tcp改成udp就可以了\n2.使用示例# firewall-cmd --zone=public --add-port=30100/tcp --permanentsuccess# firewall-cmd --reloadsuccess\n\n调用完上面两个命令，还可以看看当前开了什么端口\n# firewall-cmd --list-ports30100/tcp\n\n出现这个就是ok了\n3.关闭端口开启了，也得学会关闭\nfirewall-cmd --zone=public --remove-port=3000/tcp --permanentfirewall-cmd --reload\n\n4.tx云防火墙注意啊，默认腾讯云控制台的防火墙开放的是tcp的，如果你需要测试udp服务，那就需要单独开放一下udp的端口！\n5.绑定端口问题如果你启动的服务是自己写的服务端代码，那么绑定ip的时候一定要绑定0.0.0.0，否则无法外网访问！\n127.0.0.1 #绑定这个端口是无法外网访问的！只能在机器内部访问\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】CentOS7.6 升级 gcc/g++","url":"/posts/3646248503/","content":"CentOS 7.6 升级 gcc&#x2F;g++的方法，不一定适用于其他linux系统\n\n\n1.查看版本g++ -vgcc -v\n\n当前查看版本，发现是4.8.5，这已经是2015年的旧版本了，对c++11的支持不是很完善，为了方便学习和编写新版本的代码，升级一下还是可以的\n如果你的系统上没有gcc&#x2F;g++，则尝试用下面的方法安装\nyum install -y gcc gcc-c++\n\n示例\n[root@bt-7274:~]# yum install -y gcc gcc-c++Loaded plugins: fastestmirror, langpacks, product-id, search-disabled-repos, subscription-managerThis system is not registered with an entitlement server. You can use subscription-manager to register.Repository epel is listed more than once in the configurationLoading mirror speeds from cached hostfile * centos-sclo-rh: ftp.sjtu.edu.cn * centos-sclo-sclo: ftp.sjtu.edu.cnPackage gcc-4.8.5-44.el7.x86_64 already installed and latest versionPackage gcc-c++-4.8.5-44.el7.x86_64 already installed and latest versionNothing to do\n\n2.升级yum list dev\\*gcc\n\n用这个命令查看可以安装的版本有哪些\n\n可以看到最新版本已经是11了，那我们就直接安装最新版本的吧\nyum install devtoolset-11-gcc devtoolset-11-gcc-c++\n\nInstalled:  devtoolset-11-gcc.x86_64 0:11.2.1-9.1.el7                                                     devtoolset-11-gcc-c++.x86_64 0:11.2.1-9.1.el7                                                    Dependency Installed:  devtoolset-11-binutils.x86_64 0:2.36.1-1.el7.2                 devtoolset-11-libstdc++-devel.x86_64 0:11.2.1-9.1.el7                 devtoolset-11-runtime.x86_64 0:11.1-2.el7                Complete!\n\n看到complete就代表安装over了\n3.生效现在要做的就是让新安装的版本生效\nsource /opt/rh/devtoolset-11/enable\n\n\n不过这样做，只能在当前bash生效，新建一个bash就会发现还是4.8.5。要做的就是吧这个语句写入bashrc的配置文件中，让每次新建bash的时候自动执行一次就OK了\n要修改的是/etc/bashrc，强烈建议修改之前先备份一下\ncp /etc/bashrc ~/bashrc.bak\n\n随后执行下面俩命令\necho &quot;source /opt/rh/devtoolset-11/enable&quot; &gt;&gt; /etc/bashrcsource /etc/bashrc\n\n现在就OK了，新建一个bash，再gcc -v，发现已经是新版本了\n\n4.关于man失效问题升级了版本后，可能导致man手册失效。这是因为man的环境变量被修改了\n# echo $MANPATH/opt/rh/devtoolset-11/root/usr/share/man\n\n\n如果你需要使用man命令，则还需要重新修改一下MANPATH环境变量\nexport MANPATH=/usr/share/man\n\n解决参考 man什么都搜不了的解决方案\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】修改linux下的时区和系统时间","url":"/posts/809108065/","content":"用配置文件，修改linux系统下的时区（所用系统 CentOS8）\n\n\n1.问题来源在linux上使用python的logging模块的时候，发现了一个问题，那就是模块里面的%(asctime)s打印的时间并非东八区的时间，而是格林尼治时间，比东八区的时间少了8小时\n对于日志来说，这怎么行？总不能每次看日志的时候，自己手动给时间加8小时吧！那样对debug来说可不是什么方便事！\n2.解决百度了一下后，发现是我系统的时区问题。这个Centos系统是用docker安装的，内部的时区没有正常设置\ndate\n\n通过date命令可以查看系统当前的时间\nSat Mar  4 01:29:59 UTC 2023\n\n会发现是3月4日的凌晨1点，但实际上我是在上午9点写下的这篇博客\n\n这就需要我们修改时区了！\n\n刚开始，我尝试用tzselect命令进行时区的选择，再选择了上海时区后，系统的时间还是有问题。然后发现，需要修改文件配置，才能让时间生效\n/etc/timezone # 时区的配置/etc/localtime # 时间/usr/share/zoneinfo/Asia #这里边放着亚洲主要城市的时间\n\n而我的系统中，第一个文件压根不存在！\n要用下面的两个命令来修改配置文件（root下执行）\necho &quot;Asia/Shanghai&quot; &gt; /etc/timezone\n\nrm -rf /etc/localtimeln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n修改完毕，再次执行date命令，可以看到时间已经正常了\nSat Mar  4 09:31:33 CST 2023\n\npython的logging模块中打印的时间也正常了\n[23-03-04 09:31:39] DEBUG:log.py:debug:9 | test in main[23-03-04 09:31:39] ERROR:log.py:exception:24 | Exception occurredTraceback (most recent call last):  File &quot;/home/kook/code/py-test/log.py&quot;, line 32, in test    a = 10/0ZeroDivisionError: division by zero\n\n3.python-logging优化虽然如此，但logging本身其实是可以设置时区的，提供一份简单的模板代码;\n在下面的代码中，用了beijing这个函数来获取东八区的时间，这样这份代码在任何系统上执行，都将会打印东八区的时间了。\nimport loggingfrom datetime import datetime,timezone,timedeltaLOGGER_NAME = &quot;bot-log&quot; # 日志对象名字，这个没啥用LOGGER_FILE = &quot;bot.log&quot; # 如果想修改log文件的名字和路径，修改此变量&quot;&quot;&quot;日志文件路径&quot;&quot;&quot;def beijing(sec, what):    &quot;&quot;&quot;日志返回北京时间的处理&quot;&quot;&quot;    utc_dt = datetime.now(timezone.utc) # 获取当前时间    beijing_time = utc_dt.astimezone(timezone(timedelta(hours=8))) # 转换为北京时间    return beijing_time.timetuple()# 日志时间改为北京时间logging.Formatter.converter = beijing # type:ignore# 只打印info以上的日志（debug低于info）logging.basicConfig(level=logging.INFO,                    format=&quot;[%(asctime)s] %(levelname)s:%(filename)s:%(funcName)s:%(lineno)d | %(message)s&quot;,                    datefmt=&quot;%y-%m-%d %H:%M:%S&quot;)# 获取一个logger对象_log = logging.getLogger(LOGGER_NAME)&quot;&quot;&quot;自定义的logger对象&quot;&quot;&quot;# 实例化控制台handler和文件handler，同时输出到控制台和文件# cmd_handler = logging.StreamHandler() # 默认设置里面，就会往控制台打印信息;自己又加一个，导致打印俩次file_handler = logging.FileHandler(LOGGER_FILE, mode=&quot;a&quot;, encoding=&quot;utf-8&quot;)fmt = logging.Formatter(fmt=&quot;[%(asctime)s] %(levelname)s:%(filename)s:%(funcName)s:%(lineno)d | %(message)s&quot;,                    datefmt=&quot;%y-%m-%d %H:%M:%S&quot;)file_handler.setFormatter(fmt)_log.addHandler(file_handler)\n\n针对replit这类不支持自定义时区的平台，这样也更方便。\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】man什么都搜不了，No manual entry for xxx的解决方案","url":"/posts/1013893765/","content":"man什么都搜不了，No manual entry for xxx的解决方案\n\n\n\n系统 CentOS 7.6\n\n1.问题描述今天查手册的时候，发现man什么都查不了。不管是系统接口还是函数，都显示没有入口文档（No manual entry for）\n[muxue@bt-7274:~/git]$ man pthread_createNo manual entry for pthread_create[muxue@bt-7274:~/git]$ man bindNo manual entry for bind[muxue@bt-7274:~/git]$ man manNo manual entry for man[muxue@bt-7274:~/git]$ man lsNo manual entry for ls\n\n这可得难受了，要知道，我的博客里面关于接口定义的说明，很多都是从man手册里面复制出来的。\n在root下尝试了安装，并yum update更新之后，还是无法使用\n\n于是我就去stackoverflow提了个问题 【点我】 然后又自己解决了这个问题😂\n2.解决感谢kook频道的大佬，一眼就看出来这个是环境变量的问题\n2.1 重装man先试试reinstall重装\nyum reinstall man-pages\n\n\n2.2 查看环境变量安装完毕，查看MANPATH的环境变量，可以看到当前指向的是devtoolset-11里面的man\n# echo $MANPATH/opt/rh/devtoolset-11/root/usr/share/man\n\n罪魁祸首就找到了！几天前，我升级了云服务器的gcc版本【教程】当时安装的就是devtoolset-11；\n所以，情况就是升级的过程中，man的环境变量被修改了！\n我们要做的就是给他改回来\n2.3 修改成正确的环境变量先用whereis man找一下man的安装路径，一般都是/usr/share/man\n# whereis manman: /usr/bin/man /usr/share/man /usr/share/man/man7/man.7.gz /usr/share/man/man1/man.1.gz /usr/share/man/man1p/man.1p.gz\n\n将/usr/share/man导入到环境变量\nexport MANPATH=/usr/share/man\n\n此时再man，发现已经活过来了\nman man\n\n\n2.4 永久生效export MANPATH=/usr/share/man只是暂时修改当前bash的环境变量，要想完全生效，需要修改bash的配置文件\n注意：修改配置文件之前，一定要cp进行备份，避免修改boom！\n\n用户目录下的.bashrc\n\n在里面添加如下命令\nMANPATH=/usr/share/man\n\n然后再source使其生效\nsource .bashrc\n\n此时，当前用户的bash就能正常使用man了，但是其他用户还是不行。这就需要我们修改系统的配置文件\n\n系统配置文件/etc/bashrc\n\n注意，系统的配置文件需要输入的是命令。在新建bash的时候会执行。如下\nexport MANPATH=/usr/share/man\n\n同样的，source使其生效\nsource /etc/bashrc\n\n现在就OK了！此时其他用户也能正常使用man了\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】记录vscode连linux遇到的奇怪报错，附带解决办法","url":"/posts/643136798/","content":"今天vscode连上Linux准备写python代码的时候遇到了下面的这个问题\n\n好家伙，只是用个python虚拟环境而已，怎么ls命令都用不了了？\n百度了一下，说是本地主机缺少grep命令\n直接用ssh连试了试，命令全都是好的。\n所以解决办法就很明了了：把用户家目录下的.vscode-server文件夹给删除了。这个文件夹是vscode使用remote-ssh插件连上linux的时候会自动创建的配置文件夹。\n删除了之后需要重新连vscode并重新安装插件。问题不大，解决了！\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】centos8安装cmake3.27.4","url":"/posts/343476194/","content":"第一步，去官网下安装包，一定不要下错了\n\n下好了之后，用ftp软件传到云服务器或者虚拟机上，也可以用wget直接下载\nwget https://github.com/Kitware/CMake/releases/download/v3.27.4/cmake-3.27.4.tar.gz\n\n我用的是centos8系统，安装之前先准备好这些依赖项\nyum install -y gcc gcc-c++ make automakeyum install -y openssl  openssl-devel\n\n把下载好的安装包传上去后，解压（在root用户下操作）\ntar -zxvf cmake-3.27.4.tar.gz \n\n解压完毕后进入文件夹\ncd cmake-3.27.4\n\n执行命令\n./bootstrap\n\n耐心等候完成后，依次运行下面两个命令\ngmakegmake install\n\n最终判断是否安装成功\ncmake --version\n\n出现如下信息就是搞定了\n# cmake --versioncmake version 3.27.4CMake suite maintained and supported by Kitware (kitware.com/cmake).\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】centos8安装bison3.8","url":"/posts/1067381808/","content":"centos8安装bison3.8的教程，感觉这个软件包很小众啊，百度找不到安装教程，最终还是在起脚旮旯里面翻出来了很久之前的文档，好在没有过时；\n\n\n\nhttps://linux.cn/lfs/LFS-BOOK-7.7-systemd/chapter06/bison.html\n\n\n虽然centos8中你可以使用yum直接安装，但是哪个安装的版本太低了，达不到如今的需求\nyum install -y bison\n\n我这边直接用yum安装的是3.0.4的版本，已经是2015年的东西了，最新的版本已经到3.8了，而且我正在使用的新项目miniob就要求更高的版本，所以老版本肯定是不行的；\nbison (GNU Bison) 3.0.4Written by Robert Corbett and Richard Stallman.Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n先用yum把安装好了的删掉\nyum remove bison\n\n\n我看有的文章说需要先安装前置依赖项flex，这里带上吧。因为我的系统里面不知道什么时候就已经安装好了这个东西了\nyum install flex\n\n去官网 http://ftp.gnu.org/gnu/bison/ 下载最新的压缩包\nwget http://ftp.gnu.org/gnu/bison/bison-3.8.tar.gz\n\n解压并进入文件夹\ntar -zxvf bison-3.8.tar.gzcd bison-3.8\n\n配置安装路径，这里我使用了/usr/local这个目录，如果你查看过安装后的bison，你会发现它的安装包的逻辑是和/usr/local目录一致的，当然你也可以修改成你自己想要的目录\n# ls /usr/local/bin  doc  etc  games  include  lib  lib64  libexec  openssl-1.1.1  sbin  share  src\n\n使用如下命令配置安装路径为/usr/local\n./configure -prefix=/usr/local/\n\n目录配置好了之后，make安装\nmake install\n\n\n如果要卸载，用make uninstall\n\n安装好了之后执行bison --version，你会得到如下输出\n-bash: /usr/bin/bison: No such file or directory\n\n这是因为我们在/usr/local里面安装的东西没有在path中，没有办法直接执行，需要我们将其软链接到/usr/bin里面；\n如果你的安装正确了，应该可以在/usr/local/bin里面找到bison; 如果你安装的路径不同，那就去你安装路径下找bison的可执行文件；\n# ls /usr/local/bin2to3-3.10  bison  cmake  cpack  ctest  docker-compose  idle3.10  pip3.10  pydoc3.10  python3.10  python3.10-config  yacc\n\n将其软连接一下就ok了\n# ln -s /usr/local/bin/bison /usr/bin/bison# ls /usr/bin/bison/usr/bin/bison\n\n再次检查版本，安装3.8成功！\n# bison --versionbison (GNU Bison) 3.8Written by Robert Corbett and Richard Stallman.Copyright (C) 2021 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】root和子用户都能执行的命令，sudo无法执行（已解决）","url":"/posts/2473452644/","content":"\n全流程帖子 https://ask.oceanbase.com/t/topic/35604437/7\n\n1.问题如题，在编译miniob的时候遇到如下错误\n[mu@vm-cnt8:~/code/miniob]$ sudo bash build.sh initbuild.sh initHEAD is now at 5df3037d Merge branch &#x27;release-2.1.12-stable-pull&#x27; into patches-2.1build.sh: line 83: cmake: command not foundbuild.sh: line 91: cmake: command not foundbuild.sh: line 99: cmake: command not foundbuild.sh: line 107: cmake: command not found\n根据字面意思，是cmake命令找不到，但是我的系统里面已经有了符合条件的环境；以下是gihub&#x2F;miniob仓库中docs里面how_to_build.md的内容\n\nMiniOB 需要使用：\n\ncmake 版本 &gt;&#x3D; 3.13\ngcc&#x2F;clang gcc建议8.3以上，编译器需要支持c++20新标准\nflex (2.5+), bison (3.7+) 用于生成词法语法分析代码\n\n\n我使用的系统是centos8-steam的vmware虚拟机；当前使用的miniob的commit为\n76221e46e66ef408771ce886aa0c586a09374b0d\n\n以下是我的系统中各个依赖项的版本号，可以看到在子用户中，依赖项的所有命令都可以正常执行\n[mu@vm-cnt8:~/code/miniob]$ gcc --versiongcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-20)Copyright (C) 2018 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.[mu@vm-cnt8:~/code/miniob]$ cmake --versioncmake version 3.27.4CMake suite maintained and supported by Kitware (kitware.com/cmake).[mu@vm-cnt8:~/code/miniob]$ flex --versionflex 2.6.1[mu@vm-cnt8:~/code/miniob]$ bison --versionbison (GNU Bison) 3.8Written by Robert Corbett and Richard Stallman.Copyright (C) 2021 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n在root中，也可以正常执行这些命令\n[root@vm-cnt8:~]# cmake --versioncmake version 3.27.4CMake suite maintained and supported by Kitware (kitware.com/cmake).[root@vm-cnt8:~]# flex --versionflex 2.6.1[root@vm-cnt8:~]# bison --versionbison (GNU Bison) 3.8Written by Robert Corbett and Richard Stallman.Copyright (C) 2021 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n但是sudo执行miniob的安装脚本的时候，却找不到cmake命令\n2.debug过程经过大佬的教学，知道了一个新的sudo用法：sudo -E\n\nsudo -E 是继承当前用户的环境变量运行sudo后面的命令，否则环境变量会被清理掉；\n\n但是在初次使用的时候，依旧无法成功编译miniob，也找不到cmake命令\n[mu@vm-cnt8:~/code/miniob]$ sudo -E bash build.sh init[sudo] password for mu: build.sh initHEAD is now at 5df3037d Merge branch &#x27;release-2.1.12-stable-pull&#x27; into patches-2.1build.sh: line 83: cmake: command not foundbuild.sh: line 91: cmake: command not foundbuild.sh: line 99: cmake: command not foundbuild.sh: line 107: cmake: command not found[mu@vm-cnt8:~]$ sudo -E cmake --version[sudo] password for mu: sudo: cmake: command not found\n\n3.最终解决：PATH环境变量最终的解决办法是我自己想出来的（大佬也回复了我这个解决方案）\n当前在子用户使用 sudo -E是找不到cmake命令的。\n[mu@vm-cnt8:~]$ sudo -E cmake --version[sudo] password for mu: sudo: cmake: command not found\n\n我的系统里面的PATH环境变量如下。\n[mu@vm-cnt8:~]$ sudo env | grep PATHPATH=/sbin:/bin:/usr/sbin:/usr/bin\n\n而cmake的路径如下\n[mu@vm-cnt8:~]$ type cmakecmake is /usr/local/bin/cmake[mu@vm-cnt8:~]$ whereis cmakecmake: /usr/local/bin/cmake /usr/share/cmake\n\n有没有可能，是因为cmake不在PATH环境变量里面，导致sudo的时候找不到命令呢？虽然在root和mu用户下都可以直接执行cmake。\n于是我就去root里面执行了一下软连接\n[root@vm-cnt8:~]# ls /usr/bin | grep cmake[root@vm-cnt8:~]# ln -s /usr/local/bin/cmake /usr/bin/cmake[root@vm-cnt8:~]# ll /usr/bin | grep cmakelrwxrwxrwx. 1 root root          20 Sep  1 05:57 cmake -&gt; /usr/local/bin/cmake\n\n再来试试\n$ sudo -E cmake --versioncmake version 3.27.4CMake suite maintained and supported by Kitware (kitware.com/cmake).\n\n最后再来试试编译，应该是OK了，init成功执行，编译也通过了，没有报错\n\n感谢miniob社区大佬们的帮助！\n4.结论如果出现一个命令，root和子用户都可以执行，但是子用户中sudo却找不到此命令，可以尝试检查一下该命令所在路径是否与当前系统的PATH环境变量不符合！\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】valgrind检测程序内存泄漏","url":"/posts/565285228/","content":"valgrind是一个用于检测debug内存泄漏的命令行工具\n安装遵循如下命令下载wget https://sourceware.org/pub/valgrind/valgrind-3.21.0.tar.bz2\n解压tar -xf valgrind-3.21.0.tar.bz2cd valgrind-3.21.0\n\n配置&#x2F;安装，需要有root权限sudo ./configuresudo makesudo make install\n\n使用mencheckmencheck是valgrind的一个模块，其还拥有其他功能，但是我们在这里不做使用 –tool&#x3D;memcheck  选择memcheck工具 –log-file&#x3D;log.txt  指定日志输出文件到 log.txt  –leak-check&#x3D;no|summary|full  指定输出日志的详细程度\n基本使用命令的一个示例，最后的 ./test 是一个可执行文件\nvalgrind --tool=memcheck --log-file=log.txt --leak-check=full ./test\n\n说明memcheck模块检测的范围包括 \n\n使用未初始化的内存\n使用已经被释放的内存\n使用超出malloc分配空间的内存\n对堆栈的非法访问\n是否有释放申请的空间\nmemcpy中src和dst的重叠（参数的内存空间有重合部分）\n\n注意，对于某些new和malloc出来的常驻对象（比如全局的某个对象，单例模式中就会遇到）并不能算作内存泄漏，因为它是需要被使用的。\n测试整了个最简单的代码\n \n#include &lt;cstddef&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;using namespace std;​void test_leak()&#123;    int *p = (int *)malloc(sizeof(int));    *p = 1;    return;&#125;​int main()&#123;    int *p1 = (int *)malloc(sizeof(int));    *p1 = 2;​    int *p2 = (int *)malloc(sizeof(int));    *p2 = 3;    // 只析构一个，看看能不能检查出报错    free(p2);    test_leak();// 只有调用的模块出现内存泄漏才能被检测到    // 如果不调用这个函数，则不会检测到这里的问题    // 因为valgrind是操作监看可执行文件的，并不是来扫描代码的​    return 0;&#125;\n\n这里面有3个malloc，其中有两个是没有free的，那么用valgrind可以检测出来吗？\n答案是肯定的:\n==24089== Memcheck, a memory error detector==24089== Copyright (C) 2002-2022, and GNU GPL&#x27;d, by Julian Seward et al.==24089== Using Valgrind-3.21.0 and LibVEX; rerun with -h for copyright info==24089== Command: ./test==24089== Parent PID: 24056==24089== ==24089== ==24089== HEAP SUMMARY:==24089==     in use at exit: 8 bytes in 2 blocks==24089==   total heap usage: 4 allocs, 2 frees, 72,716 bytes allocated==24089== ==24089== 4 bytes in 1 blocks are definitely lost in loss record 1 of 2==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)==24089==    by 0x1091F8: main (in /home/lyk/ub-vm/test)==24089== ==24089== 4 bytes in 1 blocks are definitely lost in loss record 2 of 2==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)==24089==    by 0x1091C1: test_leak() (in /home/lyk/ub-vm/test)==24089==    by 0x10922C: main (in /home/lyk/ub-vm/test)==24089== ==24089== LEAK SUMMARY:==24089==    definitely lost: 8 bytes in 2 blocks==24089==    indirectly lost: 0 bytes in 0 blocks==24089==      possibly lost: 0 bytes in 0 blocks==24089==    still reachable: 0 bytes in 0 blocks==24089==         suppressed: 0 bytes in 0 blocks==24089== ==24089== For lists of detected and suppressed errors, rerun with: -s==24089== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)\n\n在最后的summry里面可以看到，这里提示 definitely lost 了8个字节，而且是在两个不同的区块中丢失的。和我们的代码吻合。\n如果你不调用  test_leak()  函数，那么就不会出现第二次的内存泄漏，报告会变成只有  4 bytes in 1 blocks ，因为valgrind是通过可执行文件来检测是否有内存泄漏的，他不会扫描你的代码（那样的成本太高了而且不一定准确！）\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】ubuntu/centos8安装zsh终端","url":"/posts/2565866661/","content":"根据这篇知乎文章进行 https://zhuanlan.zhihu.com/p/514636147\n1.安装zsh先安装zsh并设置为默认的终端\n# ubuntusudo apt install zsh# centos sudo yum install zsh util-linux-user# 通用chsh -s /bin/zsh\n\n\n如果centos下找不到chsh命令，参考此博客：https://blog.csdn.net/FungLeo/article/details/99448425\n\n然后安装oh-my-zsh，这是一个大佬在github上开源的一个zsh配置项，相对方便点\nwget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh \n\n如果github连不上就用gitee，如果你用的是子用户，那么这个命令不要用sudo权限执行！否则后续子用户会因为权限问题没办法使用。\nsh -c &quot;$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)&quot;\n\n最终出现如图所示的界面就是安装成功了。\n\n2.安装zsh插件安装这两个最常用的插件就可以了\n# zsh-autosuggestions 命令行命令键入时的历史命令建议git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions# zsh-syntax-highlighting 命令行语法高亮插件git clone https://gitee.com/Annihilater/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting\n\n这个历史命令建议的插件是用方向键👉来进行补全的，不要和我一样傻乎乎按tab。\n3.配置文件和主题原文中的配置文件有很多地方都不对劲，需要我们修改；\n首先是oh-my-zsh的安装路径，需要改成你的用户家目录下，然后需要先安装一下powerlevel10k主题，这个主题很好用！\ngit clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k\n\n配置文件~/.zshrc改成如下内容（建议将原本的配置文件cp备份一下）其中的zsh安装路径一定要修改，否则无法正常配置！\n# 防止中文乱码export LC_ALL=en_US.UTF-8export LANG=en_US.UTF-8# oh-my-zsh的安装路径（zsh的配置路径）ZSH=&quot;/home/你的用户名/.oh-my-zsh&quot;# ZSH_THEME=&quot;robbyrussell&quot;# 设置字体模式以及配置命令行的主题POWERLEVEL9K_MODE=&#x27;nerdfont-complete&#x27;# ZSH_THEME=&quot;agnoster&quot;ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; # 主题推荐这个，需要进行安装# 启动错误命令自动更正ENABLE_CORRECTION=&quot;true&quot;# 在命令执行的过程中，使用小红点进行提示COMPLETION_WAITING_DOTS=&quot;true&quot;# 配置要使用的插件plugins=(        git        extract        zsh-autosuggestions        zsh-syntax-highlighting)source $ZSH/oh-my-zsh.shsource $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh# python虚拟环境相关设置if [ -f /usr/local/bin/virtualenvwrapper.sh ];then    export WORKON_HOME=$HOME/.virtualenvs    export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3    source /usr/local/bin/virtualenvwrapper.shfi\n\n改好了之后，启用他，然后就可以了；执行下方命令后，就会自动弹出powerlevel10k主题的配置引导过程。\nsource ~/.zshrc\n\n\n如果设置完毕后，你对powerlevel10k/powerlevel10k的配置又不满意了，可以执行如下命令重新配置\np10k configure\n\n你可能也会遇到如下报错，原因未知，但似乎不影响使用\n❯ ls_p9k_worker_stop:zle:4: No handler installed for fd 12_p9k_worker_stop:5: failed to close file descriptor 12: bad file descriptor\n\n如上报错解决办法参考github的issue内的说明\nhttps://github.com/romkatv/powerlevel10k/issues/1554\n在配置文件.zshrc的末尾加上下面这一行，然后source让其生效就可以了\nunset ZSH_AUTOSUGGEST_USE_ASYNC\n4.使用小技巧输入命令的时候键入tab，会弹出一些命令的提示\n\n输入之前写过的命令的时候，会出现历史命令提示，使用方向键右👉就可以补全这个命令\n\nzsh主要就是这一点非常的方便，至于会不会和默认的/bin/bash有性能差异，那就不知道了。\n另外，在zsh终端中直接重定向会卡住，如下命令就会阻塞掉。\n&gt; 文本文件\n\n所以要用echo（一般我是用来清空某个文本文件）\necho &gt; 文本文件\n\n5.zsh安装后git中文乱码安装zsh后用git log查看提交信息的时候发现中文乱码。\n5.1 修改zsh配置文件其实上文中提到的配置文件里面已经有这两个配置项了，说明问题不在这里\n# 防止中文乱码export LC_ALL=en_US.UTF-8export LANG=en_US.UTF-8\n\n5.2 执行git配置一篇博客说要执行下面的git命令，也没有用\ngit config --global core.quotepath false git config --global gui.encoding utf-8 git config --global i18n.commit.encoding utf-8 git config --global i18n.logoutputencoding utf-8 set LESSCHARSET=utf-8\n\n5.3 修改系统字符配置另外一篇博客说要修改系统的字符集配置，如下环境变量\nexport LESSCHARSET=utf-8\n\n执行后确实ok了，可以编辑/etc/profile文件，在该文件末尾追加如下内容让其始终生效\nexport LESSCHARSET=utf-8\n\n随后用source命令刷新这个配置文件即可。\n6.粘贴文本很慢的问题参考 zsh-users&#x2F;zsh-autosuggestions&#x2F;issues&#x2F;238 解决这个问题\n在.zshrc之后添加如下配置项\n# This speeds up pasting w/ autosuggest# https://github.com/zsh-users/zsh-autosuggestions/issues/238pasteinit() &#123;  OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125;  zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?&#125;pastefinish() &#123;  zle -N self-insert $OLD_SELF_INSERT&#125;zstyle :bracketed-paste-magic paste-init pasteinitzstyle :bracketed-paste-magic paste-finish pastefinish\n\n配置了之后，source使其生效。\n这时候在终端里面粘贴内容的时候，就不会一个一个字符地打印出来了。那样实在是太慢了。\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】lcov2.0安装和perl修改镜像源","url":"/posts/1274282021/","content":"安装lcov 2.0你可能不知道lcov是什么，简而言之，它是一个代码单元测试覆盖率的显示工具，基于gcov。\n\n什么是单元测试覆盖率？\n\n我们需要对项目中的每个函数编写单元测试，其实就是测试函数的功能。通过gcc&#x2F;g++的相关编译选项，可以得到一个gcda文件，内部包含某个cpp文件中相关函数被执行了多少次，以及某些if&#x2F;switch中的多分支是否覆盖上了；\nlcov就可以解析这些gcda文件，得到如下图所示的函数测试覆盖率的报告\n\n包括单元测试在内，这部分对代码函数测试的操作一般被称之为功能安全，这里就不多说了。\nlcov 2.0的安装命令相对来说很简单，就是下面这些\nwget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gztar -zxvf lcov-2.0.tar.gzcd lcov-2.0sudo make install\n\nperl使用lcov的时候需要perl，此时就需要修改镜像源。默认的perl module的源是在国外的，国内基本上是完全用不了。\n# centos8 安装perlsudo yum install perl\n\n如果你的lcov运行的时候遇到下面类似的错误，那么就是因为perl缺少对应module导致的，比如如下报错是因为缺少Capture::Tiny这个module；\nCan&#x27;t locate Capture/Tiny.pm in @INC (you may need to install the Capture::Tiny module) (@INC contains: /usr/local/lib/lcov /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5) at /usr/local/lib/lcov/lcovutil.pm line 14.BEGIN failed--compilation aborted at /usr/local/lib/lcov/lcovutil.pm line 14.Compilation failed in require at /usr/local/bin/lcov line 102.BEGIN failed--compilation aborted at /usr/local/bin/lcov line 102.make: *** [makefile:6: lcov] Error 2\n\nperl使用清华源使用清华源就行了 https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/\n因为我用的centos的系统，安装的perl版本很老，v5.26.3，所以这里记录一个手动修改镜像源的办法\nperl --version\n\n在root用户下执行如下命令，会进入一个perl的命令行\nperl -MCPAN -e shell\n\n在perl的命令行中执行如下命令\no conf init\n\n最终展现的结果应该如下，会自动往当前用户的家目录下创建一个配置文件\n\n这里创建的配置文件是在root用户下，输入quit退出perl的命令行后，我们直接vim打开这个配置文件\nvim /root/.cpan/CPAN/MyConfig.pm\n\n在里面找到urllist选项，根据已有格式添加一个新的镜像路径就可以了\n\n我这里添加后的urllist配置项如下，第一项是镜像源就OK\n&#x27;urllist&#x27; =&gt; [q[https://mirrors.tuna.tsinghua.edu.cn/CPAN/], q[http://www.cpan.org/]],\n\n但是要注意一下，在我这边的网络环境中，清华源在perl安装包的时候也容易抽风，我试出来比较稳定的ip如下，将其写入/etc/hosts文件中，这样安装perl包的时候就不会timeout了\n101.6.15.130 mirrors.tuna.tsinghua.edu.cn\n\n这个ip后续可能会有变化啊，请以你的实际情况为准！\nperl安装module后续安装包的时候，就可以用上镜像源了，安装包的语句如下，请注意这个安装语句最后还有个英文的单引号，一定不要把他删了！\nsudo perl -MCPAN -e &#x27;install &quot;包名&quot;&#x27;\n\n我需要用perl是因为要用到lcov，在lcov仓库的readme里面提到了lcov需要的perl包，一个一个安装就行了（以下节选自lcov2.0的仓库README）\nThese perl packages include:  - Capture::Tiny  - DateTime  - Devel::Cover  - Digest::MD5  - File::Spec  - at least one flavor of JSON module.    In order of performance/preference:       - JSON::XS       - Cpanel::JSON::XS       - JSON::PP       - JSON - Memory::Process - Module::Load::Conditional - Scalar::Util - Time::HiResIf your system is missing any of these, then you may be able to install themvia:   $ perl -MCPAN -e &#x27;install &quot;packageName&quot;&#x27;\n\n比如我需要安装Capture::Tiny包，就用如下命令\nsudo perl -MCPAN -e &#x27;install &quot;Capture::Tiny&quot;&#x27;\n\n正常安装的命令输出结果如下图所示\n\nubuntu安装perl module如果是ubuntu，安装perl的包会方便一点，因为apt源里面是有perl的module\n# ubuntu 22.04 可以直接安装下面的依赖项，就可以使用lcov 2.0了sudo apt install -y perl libcapture-tiny-perl libdatetime-perl\n\n你可以根据perl的包名中的关键字，尝试在apt list里面找找有没有对应的包\nsudo apt list | grep 包名\n\n使用lcov对于lcov2.0的命令使用，可以参考我的linux仓库中的测试\nhttps://gitee.com/musnows/raspberry-practice/tree/master/lcov_test\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【nginx】nginx通过配置文件阻止海外ip访问","url":"/posts/2029711168/","content":"nginx通过配置文件阻止海外ip访问\n说明因为最近发现有不少刷评论的脚本，在nginx请求日志里面看了眼，都是海外的ip，反正我的博客也是全中文。所以干脆把海外ip禁止artalk评论。\n在/etc/nginx/nginx.conf中可以看到默认的日志路径，在里面能找到每一个转发的请求和其源IP。其中artak新增评论的请求是/api/add路径\naccess_log  /var/log/nginx/access.log  main;\n\n考虑到添加海外ip屏蔽可能会阻止一些真的在国外的朋友，如果你在阅读本站博客时，遇到相关问题无法直接评论与我交流，可以移步github随便找个我的仓库开个issue提问！\n解决APNIC介绍后文出现的网站是来自APNIC (Asia Pacific Network Information Center)，其是IP地址管理机构之一，负责亚洲、太平洋地区。\nAPNIC提供了每日更新的亚太地区IPv4，IPv6，AS号分配的信息表：http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest该文件的格式与具体内容参见：http://ftp.apnic.net/pub/apnic/stats/apnic/README.TXT\n\n脚本获取ip初步解决方法参考：https://www.cnblogs.com/guoyabin/p/14263732.html\n原博主提供的脚本如下，可以下载所有海外ip列表并生成一个nginx配置，写入/etc/nginx/blackip.conf中\n#!/bin/bashrm -f legacy-apnic-latest black_`date +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/legacy-apnic-latestawk -F &#x27;|&#x27; &#x27;&#123;if(NR&gt;2)printf(&quot;%s %s/%d%s\\n&quot;,&quot;deny&quot;,$4,24,&quot;;&quot;)&#125;&#x27; legacy-apnic-latest &gt; black_`date +%F`.conf &amp;&amp; \\rm -f /etc/nginx/blackip.conf &amp;&amp; \\ln -s $PWD/black_`date +%F`.conf /etc/nginx/blackip.conf\n\n脚本执行后的效果如下\n[root@bt-7274:/etc/nginx]# lltotal 88lrwxrwxrwx 1 root root   34 Dec  9 16:03 blackip.conf -&gt; /root/docker/black_2023-12-09.conf\n\n文件内容如下\n[root@bt-7274:/etc/nginx/conf.d]# cat ../blackip.confdeny 128.134.0.0/24;deny 128.184.0.0/24;deny 128.250.0.0/24;deny 129.60.0.0/24;deny 129.78.0.0/24;...后面的省略了\n\nnginx屏蔽海外ip参考原博主的做法，你可以将这个blackip.conf在/etc/nginx/nginx.conf中的http模块里面include，这样会阻止当前服务器所有反代的海外的请求。\ninclude /etc/nginx/blackip.conf;\n\n还可以在单个配置文件的location里面引用\n  location / &#123;      proxy_redirect off; # artalk的nginx配置中必须有这个      proxy_set_header X-Real-IP $remote_addr;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_set_header Upgrade-Insecure-Requests 1;      proxy_set_header X-Forwarded-Proto https;      include /etc/nginx/blackip.conf; # 引用配置      proxy_pass http://127.0.0.1:14722;&#125;\n\n修改后重启nginx，没有报错就是ok了\nsystemctl restart nginx\n\n用海外的服务器试试能不能请求artalk，用artk.musnow.top&#x2F;sidebar&#x2F;…这个管理员登录页面来进行测试。\n国内服务器请求结果如下，和浏览器打开的结果基本是一样（管理员登录界面）\n[root@bt-7274:/etc/nginx/conf.d]# curl https://artk.musnow.top/sidebar/#/login&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Artalk Sidebar&lt;/title&gt;    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n海外服务器请求结果也是上面这样……然后发现是因为我的海外服务器ip压根不在那个black的deny列表里面\n尝试把ip的网段给加进去，重启nginx再试试。完美处理！添加前能正常请求到，添加后就变成403了\n[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Artalk Sidebar&lt;/title&gt;    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;[root@RainYun-8aNbbsmA:~]#[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;[root@RainYun-8aNbbsmA:~]#\n\nnginx屏蔽非国内ip我前文提到了我的海外服务器的ip不在这个deny的ip列表里面，没有被屏蔽。\n考虑到网上搜不到legacy-apnic-latest文件存放的是什么ip的信息，我决定换一个思路：allow国内的ip，拒绝所有非国内的ip\n\n获取国内ip列表 https://www.cnblogs.com/sentangle/p/13201770.html\n\n下面这个url里面的ip地址标明了地区，我们只需要将其提取出来即可\nhttp://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest\n\n这个文件里面的内容结构如下\n等级机构|获得该IP段的国家/组织|资源类型|起始IP|IP段长度|分配日期|分配状态\n\n我们只需要提取CN的所有IP，然后允许他们，再deny all阻止其他ip就可以了\n#!/bin/bashrm -f delegated-apnic-latest blackcn_`date +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latestawk -F\\| &#x27;/CN\\|ipv4/ &#123; printf(&quot;%s %s/%d%s\\n&quot;,&quot;allow&quot;,$4, 32-log($5)/log(2), &quot;;&quot;) &#125;&#x27; delegated-apnic-latest &gt; blackcn_`date +%F`.conf &amp;&amp; \\rm -f /etc/nginx/blackcn.conf &amp;&amp; \\ln -s $PWD/blackcn_`date +%F`.conf /etc/nginx/blackcn.conf\n\n执行这个脚本后，会生成/etc/nginx/blackcn.conf文件\n[root@bt-7274:/etc/nginx]# lltotal 88lrwxrwxrwx 1 root root   42 Dec  9 16:54 blackcn.conf -&gt; /root/docker/nginx/blackcn_2023-12-09.conflrwxrwxrwx 1 root root   40 Dec  9 16:56 blackip.conf -&gt; /root/docker/nginx/black_2023-12-09.conf\n\n内容如下\nallow 223.248.0.0/14;allow 223.252.128.0/17;allow 223.254.0.0/16;allow 223.255.0.0/17;allow 223.255.236.0/22;allow 223.255.252.0/23;....\n\n还是修改nginx单个站点配置文件的location中的内容\n  location / &#123;      proxy_redirect off;  \tproxy_set_header X-Real-IP $remote_addr;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_set_header Upgrade-Insecure-Requests 1;      proxy_set_header X-Forwarded-Proto https;# 允许所有国内ip  \tinclude /etc/nginx/blackcn.conf;  \tdeny all; # 阻止其他ip  \tproxy_pass http://127.0.0.1:14722;      &#125;\n\n先来试试不修改配置文件（不做任何deny和allow操作的情况下）海外ip请求结果\n[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Artalk Sidebar&lt;/title&gt;    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n符合预期，正常请求出了登录页面的html文件。\n添加如上修改后，重启nginx，再次进行测试。这一次已经403阻止了，完美！\n[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;\n\nThe end你可以写个crontab让其定时执行脚本并重启nginx，我个人还是选择人工处理了（什么时候想起来就去更新一下ip列表）\n感谢本文中出现的博客的博主。没有他们的帮助，我无法编写出shell脚本。\n","categories":["玩上Linux"],"tags":["Linux","nginx"]},{"title":"【nginx】nginx 配置避免 IP 访问时证书暴露域名","url":"/posts/3528013149/","content":"本文转载自：https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/\n原文TL;DRnginx 配置避免 IP 访问时证书暴露域名\n利用 nginx 1.19.4 后的新特性 ssl_reject_handshake on;，将其置于默认访问时配置中，IP 访问时会终止 TLS 握手，也就不会暴露域名了。\n使用如下命令查看你的nginx版本\n# nginx -vnginx version: nginx/1.20.1\n\n细说CDN 是建站时常用的工具，在自己的主机外面套一层 CDN 是常见操作，一般这样认为自己的主机就安全了，有人来攻击也会先到 CDN 服务器，攻击者根本无法获取到自己主机的 IP，但事实真的是这样吗？\n我们先来看看一般配置后会出现什么问题。\nserver &#123;    listen 80 default_server;    # Redirect all HTTP requests to HTTPS.    return 301 https://$host$request_uri;&#125;server &#123;    listen 443 default_server;    server_name _;    include conf.d/ssl.config;    return 444;&#125;\n\n\n上面是一个很常用的 nginx 配置，HTTP 访问全部重定向到 HTTPS 的 443 端口上，没有配置过的域名返回 444 终止连接。\n好了，现在尝试用 IP 和 HTTPS 访问你的网站，你应该能够看到预想中访问失败、证书无效等连接失败的提示。\n但是！注意下浏览器左上角提示的不安全，点开查看证书信息，你就会发现你的域名其实随着证书发送了过来。此时如果你是攻击者，那么其实就可以知道该域名背后的源主机 IP 就是这个。\n\n上图即为用 IP 访问后，依旧能看到证书内容。这是因为返回 444 是 HTTP 层面的事情，意味着到达这一步下层的 TLS 握手已经完成。证书不被信任是一回事，但说明已经拿到了服务器的证书。\nCDN 确实避免了直接 DNS 查询暴露 IP 的问题，但攻击者通过扫描全网 IP，用上述方式依旧可以知道每个 IP 对应的域名是什么，这也是为什么很多站长用了 CDN 后并且反复更换 IP 却依旧被攻击者迅速找到 IP 的原因。\n\nCensys 就一直在干这件事，全网扫描 IP 并找到其对应的域名\n\n那该怎么办呢？问题根源出在 client 在 TLS 握手时发送了 ClientHello 后，nginx 在 ServerHello 中带着含有域名的默认证书返回了，因为 nginx 期望可以完成握手，这可能可以算是 nginx 的一个缺陷。\n\n如果你不熟悉 TLS 握手流程，那么可以看看 这篇文章\n\n笨办法既然 nginx 默认提供了带有域名的证书，那么想不暴露也很简单，提供一个不含有正确域名的证书即可。\nnginx 设置中 HTTPS 访问如果没有设置证书，那么就会报错。但反正 IP 访问也不需要提供服务，那么直接自签一个 IP 证书，或者随便一个域名的证书都可。当然，如果能搞定合法的 IP 证书也不是不行。\n搞定证书后，添加一个配置，让 IP 访问返回错误证书就完事了。\nserver &#123;    listen 443 ssl default_server;    server_name your_ip;    ssl_certificate    xxxx.pem;    // and more ssl config ...    return 444;&#125;\n\n\n好方法这种方法还得自己搞个证书，如果服务器多每个都得这么搞也挺麻烦的，好在这个问题 nginx 这已经有了很完美的解决方案。\nClientHello 中是带着 SNI 的，所以其实握手阶段是可以知道访问的域名是否合法的，nginx 1.19.4 中添加了一个新的配置项 ssl_reject_handshake 用于拒绝握手，也就不会提供证书。\n使用方法也很简单，将原本默认配置中的 return 444 替换成 ssl_reject_handshake on 即可。\nserver &#123;    listen 443 default_server;    server_name _;    include conf.d/ssl.config;    # 不用返回 444 了，直接拒绝握手    ssl_reject_handshake on;    # return 444;&#125;\n\n\n配置后，再尝试 IP 访问，会发现浏览器报了 ERR_SSL_UNRECOGNIZED_NAME_ALERT 的错误，也看不到证书信息，目标达成！\n\n其实还没完上述方法是通过 ClientHello 中的 SNI 确定访问是否合法的，那如果 SNI 就是正确的域名呢？\n这种场景发生于攻击者已经确定要攻击某个域名，那么他就可以将带着该域名的握手信息遍历所有 IP，握手成功就找到，这样访问其实与正常访问并无区别，唯一解决方法就是白名单只允许 CDN 服务器访问。\n\n例如攻击者用 hosts 直接硬写 IP，将域名强行指向某个 IP\n或者用这种方式 curl https://example.com --resolve &#39;example.com:443:172.17.54.18&#39;\n\n如下，在 nginx 里面的 location 配置添加上 allow 的 IP 段，只允许 CDN 运营商的 IP 访问你的服务，就能避免绕过 CDN 造成的攻击\nlocation / &#123;    allow   172.1.2.0/24; # 允许CDN运营商的IP    allow   1.2.3.4/32;    deny    all; # 阻止其他任何IP&#125;\n\n上述 IP 段只能向 CDN 服务提供商询问，一般文档中都是有相关信息的。\n慕雪的测试上面这篇文章我第一次看的时候还没有理解他说的是什么内容。后来测试了一下，明白了。\n说明以我的服务器举例，我是centos 7.2的服务器，直接用yum安装的nginx，版本nginx/1.20.1，配置路径是/etc/nginx；\n在默认情况下，你会有个nginx.conf，和/etc/nginx/conf.d里面的用户配置文件\n/etc/nginx\t- nginx.conf\t- conf.d\t\t- server1.conf\t\t- server2.conf\n\n在nginx.conf里面除了加载用户配置文件，还会有一个默认的server，指向一个静态文件路径。\n# 用户配置文件   include /etc/nginx/conf.d/*.conf;   server &#123;       listen       80;       listen       [::]:80;       server_name  _;       root         /usr/share/nginx/html; # 默认的静态文件路径       # Load configuration files for the default server block.       include /etc/nginx/default.d/*.conf;       error_page 404 /404.html;       location = /404.html &#123;       &#125;       error_page 500 502 503 504 /50x.html;       location = /50x.html &#123;       &#125;   &#125;\n\n在我的服务器上，这个路径里面是如下内容\n[root@bt-7274:/etc/nginx]# ls /usr/share/nginx/html404.html  50x.html  en-US  icons  img  index.html  nginx-logo.png  poweredby.png\n\n此时直接在浏览器访问你的ip，会展示这个默认路径里面的index.html，是centos的一个介绍页面。\n\n但是，这并不代表你当前没有解析到任何用户自定义文件！nginx默认情况下会使用第一个用户自定义conf来作为ip访问的结果（这是因为对用户自定义conf的include是在defualt server之前的，你可以理解为用户自定义文件会像C语言的头文件一样在nginx.conf中被展开）\n当前实际上是访问了/etc/nginx/conf.d里面按字典排序的第一个用户conf配置！\n/etc/nginx\t- nginx.conf\t- conf.d\t\t- server1.conf # 直接访问ip，使用了这个配置文件\t\t- server2.conf\n\n为什么在我这里依旧展示了默认的静态文件路径呢？是因为我的第一个配置文件a.conf中没有配置location /，全都是其他路径（比如/a/）的反代！所以nginx就往后采用了最末尾的default server里面提供的默认静态文件。\n而浏览器链接左侧的红色不安全就告诉我们，当前其实收到了一个ssl证书，这便是上面原文中提到的ip访问会因为ssl证书泄漏域名的问题。\n\n我们可以点击不安全提示，再点击右上角那个带徽章的小按钮，查看当前收到的证书\n\n如下图，当前收到的这证书，正是我的/etc/nginx/conf.d中第一个用户配置里面的ssl证书；内部包含了该证书对应的域名，我们的域名因此泄漏！\n\n思路回顾再来缕一缕思路\n\nnginx会先加载用户配置文件，末尾才是默认指向/usr/share/nginx/html静态路径的配置\n当你使用ip访问当前服务器，nginx会给浏览器发送/etc/nginx/conf.d中按字典序排在第一位的用户配置文件中的ssl证书（即上图所示证书）\n恶意访问人员可以通过遍历访问所有IP地址，当访问你的服务器IP地址时，他拿到一个ssl证书，其中包括了一个域名A；\n假设你的域名A是按域名A-&gt;CDN-&gt;服务器IP来进行解析的，此时恶意访问人员就通过这个ssl证书直接得到了域名A-&gt;服务器IP的对应关系，完全绕过了CDN\n此时他就可以通过修改hosts强制让域名A指向服务器IP，绕过CDN直接攻击你的源站\n\n套了CDN还暴露源站IP肯定不是我们想要的结果，所以我们需要解决这个问题！\n解决办法在/etc/nginx/conf.d中直接添加一个a.conf，让其排序在字典序的第一位，里面写入如下内容，其中server_name _的含义是除了我们配置过的域名外的其他访问\nserver &#123;    listen 80 default_server;    server_name _;    # Redirect all HTTP requests to HTTPS.    return 301 https://$host$request_uri;&#125;server &#123;    listen 443 default_server;    server_name _;    # 不用返回 444 了，直接拒绝握手    ssl_reject_handshake on;    # return 444;&#125;\n\n配置后直接重启nginx，没有报错就是ok了\n[root@bt-7274:/etc/nginx/conf.d]# systemctl restart nginx[root@bt-7274:/etc/nginx/conf.d]# lltotal 28-rw-r--r-- 1 root root  193 Dec  9 17:52 a.conf\n\n此时直接访问就会报错ssl的alert了，但是edge中估计是因为缓存的问题，依旧能看到证书\n\n换火狐看一下，无法连接，没有证书，目标达成！\n\n这里顺带贴一下火狐中一个正常ssl网站会显示成什么样子。在锁的按钮里面能看到证书的颁发者是谷歌，而上图中没有看到证书颁发者，即我们的证书并没有泄漏，目的达成。\n\n另外，我试了试我另外一个服务器使用的1panel安装的OpenResty，这个比较好，在默认情况下直接访问IP地址返回的是404，且没有暴露证书。不需要自己额外做配置了。\n","categories":["玩上Linux"],"tags":["Linux","nginx"]},{"title":"【nginx】nginx通过配置文件允许uptimerobot的请求","url":"/posts/1547739098/","content":"问题说明前几天，我给我的artalk上了IP屏蔽，只放行国内IP，不允许任何国外的IP地址评论。\n【Nginx】nginx通过配置文件阻止海外ip访问 | 慕雪的寒舍\n然后就发现了一个问题，我使用的uptimerobot这个在线状态监控程序是国外的，它的请求自然也是通过海外IP发起的，此时就会被我服务器的nginx拦截，导致403，uptimerobot认为403也是无法访问，service down了。\n\n解决之前通过折腾，已经知道了如何使用nginx的配置文件来allow或者deny一系列ip地址，那么uptimerobot的这个问题也很好解决：只要我们知道uptimerobbot的请求来源ip，那么将其写入一个如下类似的nginx配置文件，再在具体的location中include，放行对应ip地址即可。\nallow uptime-robot-ip1;allow uptime-robot-ip2;\n\n我在uptimerobot的官网找到了它们的ip地址列表：Locations and IPs | UptimeRobot\ntxt文件也有的：\n\nipv4：uptimerobot.com&#x2F;inc&#x2F;files&#x2F;ips&#x2F;IPv4.txt\nipv4+ipv6：uptimerobot.com&#x2F;inc&#x2F;files&#x2F;ips&#x2F;IPv4andIPv6.txt\n\n用如下脚本来实现\n#!/bin/bashrm -f IPv4.txt black_uptime_`date +%F`.confwget https://uptimerobot.com/inc/files/ips/IPv4.txt# 删除原有文件每一行的回车符号sed -i &#x27;s/\\r//g&#x27; IPv4.txt while IFS= read -r linedo  echo &quot;allow $line;&quot; &gt;&gt; black_uptime_`date +%F`.confdone &lt; IPv4.txtrm -f /etc/nginx/black_uptime.conf &amp;&amp; \\ln -s $PWD/black_uptime_`date +%F`.conf /etc/nginx/black_uptime.conf\n\n将其写入一个uptimerobot.sh文件，使用如下命令执行它\nsh uptimerobot.sh\n\n这个脚本会在当前目录里面下载uptimerobot的这个IPv4.txt，并以nginx的形式写为allow，最后在/etc/nginx里面创建一个软连接 /etc/nginx/black_uptime.conf 文件，文件内容如下\nallow 18.116.158.121;allow 18.223.50.16;allow 54.241.175.147;\n\n随后我们进入nginx的配置文件，在对应站点配置文件的location里面，include这个配置文件就可以了\nlocation / &#123;\t# 允许uptimerobot的请求\tinclude /etc/nginx/black_uptime.conf;\tdeny all; # 拒绝其他所有请求&#125;\n\n添加之后，重启nginx，配置就生效啦\nsystemctl restart nginx\n\n如下图，uptimerobot已经可以正常请求和监看我的artalk评论页面了\n\n","categories":["差生文具多"],"tags":["Linux","nginx"]},{"title":"【牛客网】HJ92 在字符串中找出连续最长的数字串","url":"/posts/3879460729/","content":"HJ92 在字符串中找出连续最长的数字串\n题目来源 牛客网 HJ92\n\n描述输入一个字符串，返回其最长的数字子串，以及其长度。若有多个最长的数字子串，则将它们全部输出（按原字符串的相对位置）\n本题含有多组样例输入。\n数据范围：字符串长度 1 \\le n \\le 200 \\1≤n≤200 ， 保证每组输入都至少含有一个数字\n输入描述：输入一个字符串。1&lt;&#x3D;len(字符串)&lt;&#x3D;200\n输出描述：输出字符串中最长的数字字符串和它的长度，中间用逗号间隔。如果有相同长度的串，则要一块儿输出（中间不要输出空格）\n输入：abcd12345ed125ss123058789a8a72a6a5yy98y65ee1r2输出：123058789,9729865,2说明：样例一最长的数字子串为123058789，长度为9样例二最长的数字子串有72,98,65，长度都为2    \n\n\n题解代码这道题的思路很简答，从前往后遍历一遍，遇到字符串就开始计算count，并记录起始位置。最后再把起始位置和子串长度插入一个pair里面。\n需要注意的是，这里必须要用pair，因为题目要求中提到了，如果有多个相同长度的数字串，就需要一并输出，并加上最后位的,长度\n#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;//给定一个256字符的字符串，输出内部最长数字子串bool isNumStr(const char&amp; c)&#123;    return (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;);&#125;int main()&#123;    string s;//来源    while(getline(cin, s))    &#123;        //cout&lt;&lt;s&lt;&lt;endl;        //string ret_s;//结果        vector&lt;pair&lt;int,int&gt;&gt; v;//用来存放数字子串的位置        int begin = 0;//标记数字串的开始        int count = 0;//标记长度        int max = 0, mbegin;//上一次获取到的数据串长度和起始位置        int flag = 0;//标记位        for (int i = 0; i &lt; s.size(); i++)        &#123;            if (i &lt; s.size() - 1 &amp;&amp; isNumStr(s[i]) &amp;&amp; isNumStr(s[i + 1]))            &#123;                count++;                if (flag != 1) &#123;                    begin = i;//说明开始计算了                    flag = 1;                &#125;                //cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;&quot; c&quot;&lt;&lt;count&lt;&lt;&quot; b&quot;&lt;&lt;begin&lt;&lt;endl;            &#125;            else if (isNumStr(s[i]))//自己还是数字，但是下一位不是            &#123;                count++;                //cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;&quot; c&quot;&lt;&lt;count&lt;&lt;&quot; b&quot;&lt;&lt;begin&lt;&lt;endl;            &#125;            else &#123;                if (count &gt;= max) &#123;                    max = count;//最大的长度                    mbegin = begin;//最大长度的起始位置                    v.push_back(make_pair(count, begin));                &#125;                count = 0;//置零                flag = 0;            &#125;        &#125;                            if (count &gt;= max)        &#123;//循环结束后还需要一次判断，避免最后一个字符依旧是数字的情况            max = count;            mbegin = begin;            v.push_back(make_pair(count, begin));        &#125;                for(auto e:v)        &#123;            if(e.first==max)            &#123;                for(int i = e.second;i&lt;e.second+e.first;i++)                &#123;                    cout&lt;&lt;s[i];                &#125;            &#125;        &#125;        cout&lt;&lt;&quot;,&quot;&lt;&lt;max&lt;&lt;endl;//结束后统一输出max    &#125;    return 0;&#125;// 通过全部用例  运行时间4ms 占用内存448KB\n\n做这道题的起因-另外一道题咳咳，在学校上课的时候遇到了另外一道题目，这道题目只需输出一个最长数字子串就可以了，不需要关心长度相同的问题。\n\n我的思路和HJ92一样，就是遍历找到数字子串的长度和起始位置，然后插入一个新的string再cout进行输出。其中s和ret_s这两个变量都是string\n然后我就遇到了“奇葩情况”\n\n我还在本地测试了两次，发现“应该”是不会多打印空格什么的\n\n上图Linux G++，下图VS2019\n\n而我通过了上面的HJ92那道题，说明代码的思路是完全没有问题的，问题就出在输出这里\n\n在结束之后（这道题限时，我没能解决这个问题）我才发现自己是个大笨蛋！\n解决方法1：加斜杠0注意，加endl的方法我已经试过了，也不行\n其实在这里，我是有想过加\\0的，但是我-加-错-位-置了！！！应该给ret_S加，哼哼啊啊啊啊\n\n\n解决方法2：直接for打印这个方法我也没想到，既然我都已经知道起始位置和子串长度了，为啥不直接打印原本string里面的内容呢？直接for打印一下不就行了???\n只能说自己对容器的使用还不是很熟悉，知识没学到位啊，哭\n\n把自己挂在这里告诫后来者\n","categories":["把题目都给刷干净"],"tags":["C++","OJ刷题","牛客网"]},{"title":"【VMware】VMware安装CentOS8-Stream虚拟机","url":"/posts/3903366745/","content":"VMware安装CentOS8-Stream虚拟机\n\n\n1.安装VMware由于最新版的vm要钱，这里提供一个VMware16pro的安装包；我知道度盘下载速度慢，但确实没啥其他选择，见谅。\n\n后文将用vm来简称VMware\n\n提取嘛: gdt9  亚索包解押: 8888\n\n下载安装包后，右键以管理员身份运行，在弹出的提示框中选择是\n\n在第一个选择框，点击下一步\n\n第二个界面，勾选接受协议中条款，继续下一步；\n第三个页面见下图，此页将控制台工具添加到系统PATH必须要勾选，安装位置自行选择\n\n备注：我保留的是默认的C盘安装路径没有改动，所以修改到其他盘是否会印发其他问题，暂且不知。如果你的C盘空间足够，就安在C盘吧！这里的安装路径是vmware软件的安装路径，不是虚拟机的安装路径，所以不需要担心会占用很多空间\n\n\n将检查产品更新和加入体验计划的钩都去掉，下一步\n\n快捷方式默认就行，后续你可以自己改。这个想必都会吧！\n此页点击下一步后，点击安装，等待安装完成。\n\n安装完成后，会出现如下页面，点击许可证，填入许可证密钥。\n许可证密钥你可以百度，搜索vmware pro 16的密钥就可以了，有很多都可以用的，我分享的压缩包里面就有一个许可证码，填那个就行了。\n网上有很多密钥，我这里贴几个，都是vmware pro 16的。\nZF3R0-FHED2-M80TY-8QYGC-NPKYF  YF390-0HF8P-M81RQ-2DXQE-M2UT6  ZF71R-DMX85-08DQY-8YMNC-PPHV8  110L3-9135J-M807A-08ARK-84V7L  FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA  CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD\n\n\n这一步操作完毕后，点击完成，虚拟机软件vmware就安装成功了。\n2.下载centos8系统iso镜像可以去两个地方下载，推荐跟随本文的操作用阿里云的镜像\n\ncentos官网：https://www.centos.org/download/\n阿里云镜像：http://mirrors.aliyun.com/centos/8-stream/isos/x86_64/\n\n本文安装的是centos8-stream的iso，本站所写的绝大部分linux博客，都兼容这个系统上的操作！这里我选择的是图中箭头所指的CentOS-Stream-8-x86_64-latest-boot.iso镜像。\n为了避免后续的其他操作和本文不符，这里顺便也把iso镜像给上传了一个直接去阿里云官网下载就可以了，应该大差不差，百度云的速度还是太慢了https://pan.baidu.com/s/1jleRo4mxILq2RwSU-rxaaA 提取嘛: t7ay\n\n\n这里我直接贴出上图中箭头所指的iso镜像阿里云下载链接\nhttp://mirrors.aliyun.com/centos/8-stream/isos/x86_64/CentOS-Stream-8-x86_64-latest-boot.iso?spm=a2c6h.25603864.0.0.59013584oRJVrF\n\n3.安装Centos3.1 创建虚拟机先在你电脑硬盘的其他位置，创建一个空目录\n\n打开vm软件主界面，点击创建新虚拟机\n\n自定义\n\n这里保持默认的，不需要修改\n\niso选择iso选择刚刚下载的centos8-stream虚拟机\n\n操作系统操作系统选择linux和centos8\n\n安装盘选择刚刚创建的空文件夹（这里是虚拟机文件的安装路径，所以建议选择你电脑上比较空的那个盘，来创建文件夹）\n\n核数选择核数请根据你的CPU来选择，比如我的笔记本CPU是8核16线程的（ctrl+alt+delete打开你电脑的任务管理器来查看）\n\n这里我选择了4核，内核数量选择2\n\n注意，这里需要和你电脑的CPU匹配，8核16线程就代表每个处理器内核有2个，所以就应该选择2。如果是intel新的大小核设计的CPU，也可以选择2。部分老款的CPU是1核只有1线程的那种 (比如n5105是4核4线程的)\n\n\n内存根据你电脑的内存选择，建议选择低于总内存一半的\n比如电脑是16G，建议只选到8G，否则虚拟机运行占用太多内存，容易弄得笔记本也卡卡的，干不了啥其他事情。\n\n这里还需要纠正小白的一部分错误认识，内存是指运行内存，不是你电脑的硬盘容量！！！右键你电脑桌面上的此电脑，点击属性，就能看到你电脑有多少内存。\n\n\nCentOS8本身占用内存并不多，但如果你想深入学习linux的编程操作，后续可能会用到vscode远程连接虚拟机，这时候内存太低就容易卡卡卡。所以建议至少选择2GB\n现在的电脑都是8G内存打底了，主流价位的笔记本也普及了16GB，所以大家笔记本运行虚拟机都是没问题的。\n\n网络选择桥接\n\nIO和磁盘选择推荐的，不用修改\n\n磁盘类型选择vm推荐的就行（不同电脑推荐的可能不一样）\n\n\n磁盘最少选择20GB，根据自己电脑硬盘容量自行选择。选择的硬盘容量并不会立马占满，而是随着使用时长慢慢增加的；\n虚拟磁盘勾选单个文件\n\n磁盘文件名字不用修改\n完成看看有没有设置错误的，点击完成即可\n\n点击开启虚拟机，即启动了centos\n3.2 初始化CentOS8点击虚拟机的屏幕，使用键盘方向键选第一个install\n\n会弹出一大堆文字，等待其跑完安装进程，会到下面的界面\n语言可以选择语言为中文，但为了方便后续和其他工具的学习接轨（大部分工具都没有中文），依旧推荐选择英语！而且这在系统里面是可以改的，问题不大\n\n网络配置点击网络\n\n点击左上角按钮为ON打开连接，将hostName修改为下图所示，apply后点击左上角的Done\n\n时区我们是东八区，得选择对应时区为 Asia/Shanghai，即上海市的时区。\n\n这里还可以选择ntp授时服务器（就是一个用来广播当前时间的服务器）点击help下面的那个齿轮，我们可以选择一个在国内的服务器，方便接收到时间更新\ncn.pool.ntp.org\n\n\n软件选择随后选择software selection，这里是选择安装的软件和系统的操作方式的。\n由于linux大部分时间我们都是学习的命令行操作，命令行安装方式对主机的负载也更小，这里选择server即可；右侧的都不勾选。\n选好后点左上角done\n\nroot密码接着再点击root password设置，默认root账户是被关闭的，这对我们学习不利。设置密码方便后续连接！\n\n依照顺序，上述操作完毕后，右下角的installation就不是灰色的了，而可以点击\n\n如果出现 installation destination是红的，点进去然后退出就ok\n\n\n点击后等待其安装完毕！耐心等待，耗时挺久的。\n\n这里还会下载一些系统的内容，我选择的是没有gui的server，所以只需要下720MB即可，带gui的肯定更大\n\n完成点右下角重启系统\n\n3.3 启动这里选择第一个（长时间不选会自己开始）\n\n出现如下页面后，填入用户名root和刚刚初始化界面设置的密码，就成功登录了！\n\n需要注意的是，在Linux中，输入密码的操作是不会有任何回显的，所以你需要盲打。只要密码是对的，就一定能成功。\n4.ssh连接先下载ssh连接软件，如tabby、xshell、putty等；推荐使用开源的tabby，这里贴出tabby的下载地址：\nhttps://github.com/Eugeny/tabby/releases\n4.1 安装并启动sshd先在虚拟机里面操作，下载ssh服务端软件\nyum install -y openssh-server\n\n当前使用的CentOS8系统已经自带了这个软件\n\n启动sshd\nsystemctl start sshd\n\n4.2 查看ipifconfig\n\n使用这个命令，能看到当前虚拟机的ip为192.168.6.172\n\n4.3 ssh连接以tabby为例，点击设置，配置与连接，新配置\n\n选择ssh连接\n\n填入刚刚看到的ip，端口22默认不需要动，用户名root\n\n创建完毕后，在配置与链接页面，点击启动键（就和视频的播放键一样的按钮）开始连接\n\n会出现如下让你输入密码的页面，在这里填入root的密码，并勾选remember记住密码\n\n主机密钥校验是每次ssh第一次连接新主机时都会出现的，勾选接受并记住就可以了；\n\n到这里就成功连上虚拟机里面的linux了。日常使用，也更推荐在ssh软件上操作，而不是vm的虚拟机界面里面操作linux命令行。\n\n这样vm的窗口就可以收起来，让虚拟机在后台运行了！\n\nOver！大功告成，一个linux学习环境就搭建好啦。\n顺带看看下面的内容吧\n\ncentos8安装python3.10 https://blog.musnow.top/posts/847195816/\ncentos7云服务器学习环境初始化 https://blog.musnow.top/posts/656771008/\n\n","categories":["玩上Linux"],"tags":["Linux","centos","虚拟机"]},{"title":"【牛客网】JZ65:不用四则运算符实现两数相加","url":"/posts/1481999994/","content":"[TOC]\n问题来源\n牛客网数据结构题目👉JZ65\n\n题目要求如图\n\n\n思考不能使用四则运算，根据过往的学习经历，我唯一能想到的就是位操作符和移位操作符\n例：使用位操作符进行int变量交换\n\n位操作符的使用先来回顾一下位操作符的作用\n位操作符操作的是整形的二进制位，它的操作数是2，比较两个整型的二进制位\n\n&amp;按位与：对应的二进制 全为1才是1，否则0\n|按位或：对应的二进制 有1为1，全为0才为0\n^按位异或：相同为0，不同为1\n\n\n比较一下正常的二进制相加和按位异或，发现按位异或是没有进位的相加\n\n\n原本应该是010，但是按位异或后是000\n1+1需要进位的1并没有进到下一位里去\n\n而使用按位与操作符，我们可以得到这两个数相加需不需要进位\n0 0 10 0 1//按位与-全1为10 0 1//&lt;&lt; -左移1位0 1 0\n\n这时候将按位与之后的结果和按位异或相加，就是我们的答案了\n但是题目要求不能使用加减\n\n再将按位与的结果0 1 0与 按位异或结果0 0 0进行按位与\n得到0 0 0 ，代表无需进位\n这时候将0 1 0与0 0 0 进行按位异或，即得出相加后的结果0 1 0\n\n\n这个例子比较简单，我们可以再用复杂一点的例子再证明它的可行性\n3：0011和5：0101\n\n\n\n操作\n结果\n\n\n\n\n1：按位与和左移\n0 0 1 0\n需要进位\n\n\n2：按位异或\n0 1 1 0\n\n\n\n3：1和2按位与，左移\n0 1 0 0\n需要进位\n\n\n4：1和2按位异或\n0 1 0 0\n\n\n\n5：3和4按位与，左移\n1 0 0 0\n需要进位\n\n\n6：3和4按位异或\n0 0 0 0\n\n\n\n7：5和6按位与，左移\n0 0 0 0\n无需进位\n\n\n8：5和6按位异或\n1 0 0 0\n得到结果为8\n\n\n根据这个思路，我们成功地完成了3和5的相加\n\n代码实现本题是接口型题目，我们只需要完成一个函数，实现相加的功能\n/** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * *  * @param num1 int整型  * @param num2 int整型  * @return int整型 * * C语言声明定义全局变量请加上static，防止重复定义 */int Add(int num1, int num2) &#123;    while(num2)    &#123;        int t = (num1 &amp; num2) &lt;&lt; 1;        num1 ^= num2;        num2 = t;    &#125;    return num1;&#125;\n\n不过我们可以自己写一个主函数来测试它的可行性\n如图，函数正确算出了两个数的和\n\n\n如果这篇博客帮到了你，还请点个赞啦~\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","牛客网"]},{"title":"【VMware】ssh连接deepin虚拟机","url":"/posts/1211975221/","content":"ssh连接linux虚拟机，以deepin20.3为例\n\n\n\n1.VMWare 虚拟网卡配置VMWare虚拟机常用的网络链接方式有下面这3种\n\n桥接（最方便）\nnat（需要设置端口映射）\n仅主机（无法联网）\n\n在我的测试中，不管用上面哪种方式安装，都是可以直接查询IP后，进行ssh连接的。\n需要注意是，如果你所在的环境没有你可以直接管理的路由器（比如校园网）那就不要选择桥接模式，不然你的Linux虚拟机可能因为没有登陆校园网而无法上网；这时候建议选择NAT模式！\n\n桥接模式：以当前主机为桥，直接接入上级路由器；此时虚拟机会作为一个普通设备接入局域网，可以被局域网内的其他电脑直接访问；\nNAT模式：借用当前主机的端口进行互联网访问，此时虚拟机并没有直接接入局域网，如果其他局域网内设备想访问虚拟机，必须设置端口映射；当前主机可以正常通过虚拟机的IP访问到虚拟机。\n仅主机模式：只有当前主机能访问到虚拟机，且该虚拟机无法上网；\n\n如下便是我安装（创建）虚拟机时，选择桥接网络的截图。\n\n顺带提一嘴，安装deepin虚拟机的时候，环境选择ubuntu 64位就可以了，并不需要去搜deepin基于debain的版本号（而且我也没搜到）\n2.安装 openssh在 虚拟机 中执行：\nsudo apt install openssh-client openssh-server\nsudo /etc/init.d/ssh restart\n\n我安装的是deepin20.3，自带了这两个软件包，所以只需要执行重启一下ssh，保证服务正常就行了\n$ sudo apt install openssh-client openssh-server请输入密码:验证成功正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       openssh-client 已经是最新版 (1:7.9p1.10-deepin1)。openssh-server 已经是最新版 (1:7.9p1.10-deepin1)。升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。\n\n而在centos8中，openssh-server也是自带了，不需要安装，启动就行了\nsystemctl start sshd\n\n3.查询虚拟机 IP在 Linux 虚拟机 中执行：\nifconfig\n\n找到 ens33 下的 IPv4 地址，记下来（你的虚拟机里面可能不是33，这不重要）\n\n4.设置端口转发\n咳咳，我发现原来NAT在虚拟机里面查询到的那个IP也是可以直接链接的，所以设置端口转发也是没有必要的🤣！除非你想要让局域网内的其他机器链接到你这个虚拟机里面的服务。\n所以这一步是可以跳过的；不过记录下来，如果你有这个需求就可以根据教程设置一下。\n\n在 VMWare Workstation 中：\n菜单栏 → 编辑 → 虚拟网络编辑器 → VMNet8 -&gt; 更改设置 → NAT 设置 → 添加端口转发\n\n需要提供管理员权限，在弹出的窗口中选确定\n\n确定了管理员权限后，再选择VMnet8，点击NAT设置\n\n点击添加端口转发\n\n\n进入映射传入端口界面后，按下面填写\n\n主机端口：是你当前宿主机的本机端口，可以随便填一个；但要保证不要和windows已有的本地端口冲突。端口号范围是0~65535，建议选用5位数的不常用端口！\n虚拟机IP地址：使用ifconfig查到的虚拟机ip\n虚拟机端口：22（ssh默认端口）\n\n确定，并点击虚拟网络编辑器中的应用（或者确定）按钮；\n5.开放防火墙在 deepin 虚拟机 中执行：\nsudo ufw allow ssh\n\n如果ufw命令找不到，那就安装一下这个命令\n$ sudo ufw allow sshsudo: ufw：找不到命令\n\n$ sudo apt-get install ufw正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列【新】软件包将被安装：  ufw升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 164 kB 的归档。解压缩后会消耗 852 kB 的额外空间。获取:1 https://community-packages.deepin.com/deepin apricot/main amd64 ufw all 0.36-1 [164 kB]已下载 164 kB，耗时 0秒 (1,316 kB/s)正在预设定软件包 ...正在选中未选择的软件包 ufw。(正在读取数据库 ... 系统当前共安装有 251044 个文件和目录。)准备解压 .../archives/ufw_0.36-1_all.deb  ...正在解压 ufw (0.36-1) ...正在设置 ufw (0.36-1) ...Creating config file /etc/ufw/before.rules with new versionCreating config file /etc/ufw/before6.rules with new versionCreating config file /etc/ufw/after.rules with new versionCreating config file /etc/ufw/after6.rules with new versionCreated symlink /etc/systemd/system/multi-user.target.wants/ufw.service → /lib/systemd/system/ufw.service.正在处理用于 rsyslog (8.1901.0.10-1+dde) 的触发器 ...正在处理用于 man-db (2.8.5-3) 的触发器 ...\n\n再执行一下，显示的结果如下。此时就已经ok了\n$ sudo ufw allow sshRules updatedRules updated (v6)\n\n6.连接测试这是ssh连接的通用格式，默认的ssh端口是22\nssh 用户名@虚拟机ip\n\n如果是nat端口映射，需要指定ip，就在后方添加-p选择端口；假设你设置了NAT虚拟机22端口到主机2222端口的NAT映射，那就可以使用如下命令进行链接，因为映射到了本地，所以IP我们可以填localhost或者127.0.0.1代表本机的本地IP，二者是等价的\nssh 用户名@localhost -p 2222ssh 用户名@127.0.0.1 -p 2222\n\n在windows的cmd中执行如下命令，就能连上你的虚拟机\nPS C:\\Users\\moth&gt; ssh mothra@192.168.6.113The authenticity of host &#x27;192.168.6.113 (192.168.6.113)&#x27; can&#x27;t be established.ED25519 key fingerprint is SHA256:ZFGdOP9rRgV3SA0V1W3yikrTWDd8V+8sYxTPgyQu5WQ.This key is not known by any other namesAre you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#x27;192.168.6.113&#x27; (ED25519) to the list of known hosts.mothra@192.168.6.113&#x27;s password: 验证成功Welcome to Deepin 20.9 GNU/Linux    * Homepage:https://www.deepin.org/    * Bugreport:https://bbs.deepin.org/mothra@mothra-PC:~$\n\n当然，你也可以选择使用其他ssh终端来链接，具体方法根据终端软件百度教程就行了。\n7.生成 ssh 密钥对（选做）在 宿主机 (Windows) 执行：\nssh-keygen\n\n敲回车直到执行完成（已有公钥可跳过此步）\n在 宿主机 (Windows) 中用 Powershell 执行：\ncat ~/.ssh/id_rsa.pub | ssh 虚拟机用户名@虚拟机IP &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot;\n\n命令中的虚拟机用户名用你在虚拟机中创建的linux用户名替换；\n虚拟机IP用刚刚第3步中查到的虚拟机IP替换（刚刚背诵的）；\n输入密码即可！\n\n配置了ssh密钥后，无需键入密码即可连接（如果你使用vscode来ssh链接虚拟机，这点很重要，非常省事）\nssh 虚拟机用户名@虚拟机IP\n\n\n参考博客：https://www.cnblogs.com/BinarySong/p/16244415.html\n\n","categories":["玩上Linux"],"tags":["Linux","deepin","虚拟机"]},{"title":"【VMware】VM中虚拟机设置的处理器数量和每个处理器内核数量到底是什么？","url":"/posts/3252027724/","content":"\n原出处：VMWare中的处理器数量和每个处理器的内核数量概念及查询方法\n慕雪对原文进行了一定修改和细化\n\n一、概念：当我们使用vm来创建虚拟机的时候，一定会经历下面的选项。那就是给虚拟机配置分配的cpu核心数量。但vm这里的说法和我们日常生活中对CPU的X核X线程的说法并不统一。就容易混淆一些概念。\n\n先来说说这里三个选项的含义吧\n\n处理器数量 ：虚拟的CPU颗数。\n每个处理器的内核数量：虚拟的CPU内核数。\n处理器内核总数：处理器内核总数 &#x3D; 处理器数量 * 每个处理器的内核数量。\n\n处理器内核总数 对应的是 物理CPU的线程数（逻辑处理器数量）。 \n所以配置虚拟机时，我们只需要关心 CPU实际的线程数 是多少就行了，即配置的 处理器内核总数 &lt; CPU实际的线程数 就行了。\n注：我们电脑上的一个CPU，一般都会有多个内核（单核&#x2F;双核&#x2F;四核&#x2F;六核&#x2F;八核&#x2F;十六核），而一个内核一般对应一个线程。但通过Intel的超线程技术，一个核心可以对应两个线程，即可以同时运行两个线程，并行处理两个任务。\n大小核怎么办？不过，现在的新intel cpu又出现了大小核的说法。不过这并不影响我们来判断到底应该怎么配置。比如下图是不带大小核设计的8代i7 CPU在官网上的详细参数\n\n而下图是最新的带大小核的13代i9在官网上的详细参数\n\n我们可以看到，即便新的出现了性能核（大核）、能效核（小核）这样的设计，但其依旧没有脱离内核数和线程数这两个参数。\n我们依旧可以依照传统的办法，通过线程数来判断应该给虚拟机的CPU上的配置\n虚拟机的处理器内核总数 &lt; 实际CPU的线程数\n\n而AMD的Cpu暂时还没有出现大小核的设计，也是按照这个办法进行VM虚拟机的配置就OK了！\n二、查看电脑配置参数方法：1、网上查询对应的CPU参数，一般可以去官网查询得到\n\nintel产品规范\namd官网\n\n\n\n2、打开windows的任务管理器，先展开视图，再找到“性能”界面。\n\n内核：即CPU核心数。\n逻辑处理器：即线程数。\n\n\n\n3、右键 “我的电脑”–“管理”–“设备管理器”\n“处理器”项下面显示几条记录即代表有几个逻辑处理器（线程数）。\n\n\n三、配置论证参考知道了自己的CPU线程数，就可以来验证一下我们的理论是否正确了\n虚拟机的处理器内核总数 &lt; 实际CPU的线程数\n\n实际硬件参数： 6核12线程\n配置成功\n\n\n\n配置失败\n\n\n\n四、linux查看cpu核心数&#x2F;线程数我使用下图的配置了一个deepin的虚拟机\n\n进了虚拟机，打开终端后，可以用下方的几个命令来查询你的cpu数量是否和上文所述一致\n# 查看cpu核心数# 对应vm处理器数量cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l# 查看每个cpu的内核数量# 对应vm每个处理器的内核数量cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq# 查看线程数# 对应vm的处理器内核总数cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l\n\n可以看到，在deepin里面执行这些命令的结果和预期完全一致！是4核心8线程的系统！\n$ cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l4$ cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniqcpu cores       : 2$ cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l8\n\n总结根据上面的操作，可以确定，只要你配置的处理器内核总数小于你CPU的实际线程数，就不会出现问题。但一般情况下，我们还是遵循最常用的一个核心两个线程配置，将每个处理器的内核数量设置为2，再去对应设置处理器数量，比如\n\n处理器数量2，每个处理器的内核数量2（2核4线程）\n处理器数量4，每个处理器的内核数量2（4核8线程）\n处理器数量6，每个处理器的内核数量2（6核12线程）\n以此类推\n\n处理器数量最好设置为2的倍数，毕竟你也没听说过3核和5核的CPU吧？😂不过vm似乎也不允许选择奇数。\n在我的使用场景中，vm是用来装linux进行学习和开发的。对于不带GUI的linux来说，2核4线程都是杠杠的了。更吃紧的还是内存！如果是不带GUI的linux，建议2G起步，4G往上足够用。\n需要注意的是，如果你和我一样，需要用vscode的remote-ssh功能连接linux进行代码编写，那最好是4G内存起步！（2G实测有点卡，1G根本没法用）\n","categories":["玩上Linux"],"tags":["Linux","deepin","虚拟机"]},{"title":"【deepin】deepin安装新字体","url":"/posts/1504301137/","content":"感觉deepin默认的字体并不是很好用，虽然也是等宽字体，但是太细了。不是我喜欢的类型。于是打算给deepin整一个个人比较喜欢的JetBrainsMono字体\n\n\n下载字体字体自然是去官网下载，这里就不多说了，丢个链接\nhttps://blog.jetbrains.com/zh-hans/2020/03/08/jetbrains-mono/https://github.com/JetBrains/JetBrainsMono\n\n安装字体但是让我没想到的是，光是一个安装字体的教程，就能出这么多烂文。什么啊个性化里面可以选择字体，设置里面可以选择字体之类的无关事项（都用带GUI的linux了肯定会去看看个性化设置啊……还需要你教？）\n找了一小会，总算是找到了一个正常的文章。\ndeepin里面自带了一个字体管理器，在开始菜单里面搜索字体就能出来\n\n先把下载的压缩包里面的fonts解压到桌面\n\n进入字体管理器，点击加号，选中fonts里面tff文件夹内的字体文件，就可以安装了！\n\n\n点击打开，即安装完毕！\n后续其他软件的字体配置就不写啦！\n","categories":["玩上Linux"],"tags":["Linux","deepin","虚拟机"]},{"title":"【Linux】wsl安装的ubuntu不支持POSIX消息队列 | 已解决","url":"/posts/4006913293/","content":"wsl安装的ubuntu不支持POSIX消息队列的解决办法\n\n\n问题\n如题，我的win10上安装了wsl的ubuntu后（微软商店下载的wsl的Ubuntu）这个系统内部不支持POSIX的消息队列，虽然有&lt;mqueue.h&gt;头文件，但是没有实现，会报错。\n如果想找个简单的办法呢，那就是用systemV的消息队列，可这是个虚拟机本地环境问题，我用virtualbox安装的虚拟机就能正常使用。所以肯定得解决这个问题，换成systemV的消息队列就有点「掩耳盗铃」的意味了。\n测试下面是一个POSIX消息队列的demo\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;mqueue.h&gt;using namespace std;int main()&#123;    mqd_t mqID;    mqID = mq_open(&quot;/testmQueue&quot;, O_RDWR | O_CREAT, 0666, NULL);    if (mqID &lt; 0)    &#123;        cout&lt;&lt;&quot;open message queue error...&quot;&lt;&lt;strerror(errno)&lt;&lt;endl;        return -1;    &#125;    mq_attr mqAttr;    if (mq_getattr(mqID, &amp;mqAttr) &lt; 0)    &#123;        cout&lt;&lt;&quot;get the message queue attribute error&quot;&lt;&lt;endl;        return -1;    &#125;    cout&lt;&lt;&quot;mq_flags:&quot;&lt;&lt;mqAttr.mq_flags&lt;&lt;endl;    cout&lt;&lt;&quot;mq_maxmsg:&quot;&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;endl;    cout&lt;&lt;&quot;mq_msgsize:&quot;&lt;&lt;mqAttr.mq_msgsize&lt;&lt;endl;    cout&lt;&lt;&quot;mq_curmsgs:&quot;&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;endl;&#125;\n\n如果编译后运行出现了下面的报错，代表当前系统不支持POSIX消息队列。当前系统下有mqueue头文件，但并没有函数的实现体\nroot@DESKTOP-5SQO6N0:~# ./testopen message queue error...No such file or directoryopen message queue error...Function not implemented\n解决需要将wsl版本1改成版本2，否则无完整Linux内核支持，无法使用POSIX消息队列。这也是WSL版本1和2的重大区别之一。\n用如下命令将当前虚拟机改成wsl2版本，就可以使用了。\nwsl -l -v # 用这个命令查看当前虚拟机的version是不是1wsl --update # 更新wslwsl --set-version 虚拟机名 2  # 把指定虚拟机改成wsl版本2\n再次测试正常情况下，上面的消息队列代码应该输出如下内容\nroot@DESKTOP-5SQO6N0:~# ./testmq_flags:0mq_maxmsg:10mq_msgsize:8192mq_curmsgs:0\n\n\n绑定目录除了上面这个问题，在使用消息队列之前还可以monut一下路径，参考man手册中的教程（似乎不是必须要做的，mount了这个路径之后能更好地看到现有的消息队列）\nmkdir /dev/mqueuemount -t mqueue none /dev/mqueue","categories":["玩上Linux"],"tags":["Linux","虚拟机"]},{"title":"【Linux】wsl虚拟机时间和实际时间不符合","url":"/posts/1339169411/","content":"偶然遇到了这个问题，触发原因是电脑在开启wsl的情况下进入了休眠模式，且在无网络情况下几天不使用。\n然后开启wsl，发现git log显示最新commit的提交时间是明天，给我吓一跳，然后才发现原来是wsl里面的时间不对。\nLinux下看时间的命令是date，本文写于12月12日，但wsl中的时间是12月10日，肯定是不对。\n&gt; dateTue Dec 10 09:51:29 AM CST 2023\n\n在wsl内部使用如下命令进行时间同步\nsudo hwclock -s\n\n执行后，在windows的命令行里面执行如下命令，重启wsl子系统。\nwsl --shutdown\n\n再在wsl里面执行date命令，时间正确。\n&gt; dateTue Dec 12 09:53:21 AM CST 2023","categories":["玩上Linux"],"tags":["Linux","虚拟机"]},{"title":"【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机","url":"/posts/4065446782/","content":"本人所使用的系统是 win11 22H2 家庭版，如果你不是非CentOS不可，强烈建议直接去微软应用商店里面下载Ubuntu，全自动安装到WSL，啥都不用管。(就是好像没办法选择安装路径)\n1.启用WSL刚开始安装WSL的时候，参考的是这个博客。说实话，我个人并不喜欢这篇博客。因为里面遗漏了很多东西，并且在不恰当的位置贴出了命令，导致读者会误以为是需要执行这些命令。\n比如我就理解错误，先执行了设置wsl默认版本为2的命令，这个命令先不要执行！后文会告诉你为什么。\n这篇博客中对开启wsl的设置的位置描述也不完全，看上去像从网上哪里抄过来的win10的设置逻辑（win11的位置完全不一样）\n该博客原文：在windows设置中打开【启用或关闭Windwos功能】，勾选【适用于Linux的Windwos子系统】，点击确定后会系统会提示重启，选择确认即可\n\n实际上在win11中，需要多点好几个地方才能找到这个设置的位置\n右键桌面 - 个性化 - 进入win11设置界面 - 应用 - 可选功能 - (往下滑)更多windows功能\n\n\n\n这都是我对一个不完善博客的吐槽，但并没有贬低这个教程的意思啊！至少他告诉我基本步骤应该做哪些。\n为什么我要吐槽呢？因为这种写的不全的博客经常会让读者得去重新搜索某些设置的位置，而作者明明是已经走过这个流程的。博客里面作者的截图明显是windows11，但他提供的设置却是win10中的旧位置。多花30秒写清楚位置并带上截图，不知道能节省读者多少时间……如果你体会过查资料的时候阅读这些「断头短尾」的博客，应该也能体会到我的心情。\n\n回到正题。在更多 windows 功能选项框中（win10&#x2F;11的这个选项框基本相同），勾选上下面的几个选项，三个都要勾选上！\n\n适用于 Linux 的 Windows 子系统\n虚拟机平台\nwindows 虚拟机监控程序平台\n\n点击确定，就成功启用了 WSL。系统会弹出一个进度条，下载一些东西。\n\n处理完毕后，WIN+R输入cmd，打开命令行工具，在命令行工具中输入wsl -l -v命令，有相关输出就是启用成功了！\n初始化情况下，执行这个命令，应该会提示你当前什么虚拟机都没有安装。\n2.安装Centos82.1 下载系统zip去 github&#x2F;wsldl-pg&#x2F;CentWSL 上下载适用于wsl的CentOS8系统的zip\n\n这个也可以：https://github.com/mishamosher/CentOS-WSL\n\n\n把zip解压到你想安装虚拟机的位置（一定要是一个空文件夹），然后右键CentOS8.exe，以管理员身份运行。\n\n2.2 报错HRESULT:0x80370102解决安装CentOS8的时候，就遇到了这个issue中的问题👇\ngithub.com&#x2F;wsldl-pg&#x2F;CentWSL&#x2F;issues&#x2F;36\n用管理员身份运行CentOS8.exe之后，弹出的终端会输出如下内容\nERROR:Installation Failed!HRESULT:0x80370102\n\n根据该issue 中最后一个回复的解决办法，我先将wsl版本设置回了1（这就是为什么前文说不要先设置为默认wsl2）\n\nwsl --set-default-version 1\n\n重复如上安装步骤（以管理员身份运行CentOS8.exe），就成功安装了虚拟机。在win11的文件管理器左侧会多出来一个Linux图标，里面有CentOS8的系统里面的文件。\n\n在windows的powershell或者cmd中，输入wsl，就可以进入CentOS8的bash；见下图，我们已经成功安装好了一个CentOS8的虚拟机。内部的文件就是CentOS8系统的默认文件。\n在内部执行exit命令，就可以退出wsl虚拟机，回到windows的终端下。\n\n而且WSL有个最大的好处，就是它能自动挂载windows下的文件到/mnt目录下，这个目录里面可以看到我的win11宿主机的3个硬盘分区；windows的文件资源管理器里面也可以看到Linux中的文件，方便我们在windows和linux下互传文件（就不需要用sftp工具了）\n特别是如果你需要写带Doxygen文档的项目，在生成Doxygen的html后，就能直接从这里在windows的浏览器中打开网页，而不需要用sftp或者其他工具传到windows下再打开了！\n\n当然，你也可以用带GUI的Linux系统来解决这个问题。\n\n2.3 更新为WSL2使用wsl -l -v命令，可以看到当前运行的wsl虚拟机，版本是1\nPS C:\\Users\\S2522\\Desktop&gt; wsl -l -v  NAME       STATE           VERSION* CentOS8    Running         1\n\n我们可以将其升级为WSL2版本，但是这里会告诉你需要更新内核组件\nPS C:\\Users\\S2522\\Desktop&gt; wsl --set-version CentOS8 2正在进行转换，这可能需要几分钟时间...有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2WSL 2 需要更新其内核组件。有关信息，请访问 https://aka.ms/wsl2kernel\n\n那就更新呗！微软官方文档 中会告诉你需要 wsl.exe --install 或 wsl.exe --update命令。\n这里我执行了wsl --update命令，执行后会弹窗要你提供管理权限，并出现一个进度条，等他跑完就行。\nPS C:\\Users\\S2522\\Desktop&gt; wsl --update正在安装: 适用于 Linux 的 Windows 子系统已安装 适用于 Linux 的 Windows 子系统。\n\n更新好了，再重新执行wsl --set-version CentOS8 2升级命令，会提示你正在执行转换，需要等待一会。\n\n最终成功转换了，使用命令wsl -l -v里面显示的版本也是2了。\nPS C:\\Users\\S2522\\Desktop&gt; wsl --set-version CentOS8 2有关与 WSL 2 关键区别的信息，请访问 https://aka.ms/wsl2正在进行转换，这可能需要几分钟时间。操作成功完成。PS C:\\Users\\S2522\\Desktop&gt; wsl -l -v  NAME       STATE           VERSION* CentOS8    Stopped         2\n\n搞定！现在我们就有一个方便的CentOS8的WSL环境啦！\n可以用如下命令，将当前的CentOS8设置为默认的wsl虚拟机。这样在windows命令行中执行wsl或者bash命令，就能直接进入CentOS8中。\nwslconfig /setdefault CentOS8\n\n重启电脑后，在powershell的下拉栏中会自动出现CentOS8的选项，点击它也能进入wsl虚拟机环境中。\n\n3.解决yum报错问题因为这个CentOS的镜像是最小安装版本（类似于Docker安装的CentOS），所以内部的yum源都是坏掉的。执行yum update会出现如下报错。\n[root@7945R9P ~]# yum -y updateFailed to set locale, defaulting to C.UTF-8CentOS-8 - AppStream                                                                     68  B/s |  38  B     00:00Failed to download metadata for repo &#x27;AppStream&#x27;Error: Failed to download metadata for repo &#x27;AppStream&#x27;\n\n这时候需要进行yum源的重新设置，参考本站博客解决这个问题就行\n 【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo ‘appstream’ Cannot prepare internal mirrorlist | 转载\n搞定yum之后，就可以正常安装你想要的开发软件了。这个系统很轻量，sudo和passwd等很多完整系统会自带的命令都没有，需要自行安装一些。\n另外，我写过一个CentOS8的初始化脚本，可以自动化安装一些软件，这里安装的软件并不一定是你想要的，请酌情参考：https://gitee.com/musnows/centos8-init\n\n而且，默认情况下的ls命令也没有颜色输出，需要修改bash配置来设置命令别名\nalias ls=&#x27;ls --color=auto&#x27;\n\n你也可以根据自己的喜好，改成zsh或者其他终端。\n4.vscode连接普通的虚拟机我们需要用vscode的remote ssh插件来连接，但是WSL主机我们直接用vsc的WSL插件来连接就行了，使用的效果和remote ssh插件是相同的\n\n在左侧这个远程连接控制器中（和Remote ssh是同一个位置），找到上方的下拉条，改成WSL目标，就能看到我们的CentOS8虚拟机。点击连接它就可以了。\n\n但是vscode默认链接的是root用户，一般情况下肯定不会在root下写代码的。所以需要配置一下子用户\n修改虚拟机中的/etc/wsl.conf文件，添加下面两行\n[user]default=用户名\n\n然后回到windows的命令行，重启wsl\nwsl --shutdown CentOS8\n\n再次启动wsl，这样vsc就能默认链接你的子用户了。\n5.修改wsl资源限制默认情况下，wsl2的虚拟机能访问到完整的系统资源，包括所有CPU核心和内存。\n这就会导致如果Linux下对一些东西进行了缓存而没有及时清理，Windows是没办法回收这部分内存的。最终就导致我们Windows宿主机没有足够的内存可用了，这怎么行？\n\n这种情况下，一般windows系统会把wsl直接给干掉，那我们虚拟机里面跑的活也没办法完成了。要知道，Linux可是很喜欢cache内存的，很容易会把宿主机的内存给干没。\n\n为了解决这个问题，我们需要设置wsl的虚拟机内存&#x2F;CPU限制。\n在Linux下可以用这两个命令来查看cpu和内存的配置信息，刚开始的时候应该是和你的宿主机的CPU和内存一样。\ncat /proc/cpuinfo | grep processor # 查看cpu核心数量cat /proc/meminfo | grep Total     # 查看内存信息\n\n在windows的C盘的用户文件夹下，创建一个.wslconfig文件，并在内部写入限制\n\nprocessors是cpu核数限制\nmemory和swap都是内存限制\n\n顶多设置为宿主机内存的一半，避免宿主机卡顿。\n[wsl2]processors=8memory=8GBswap=8GB\n\n这个配置文件的路径是（windows下）\nC:\\Users\\你的用户名\\.wslconfig\n\n随后在windows的终端中使用如下命令，终止这个wsl虚拟机\nPS C:\\Users\\S2522\\Desktop&gt; wsl --shutdown CentOS8PS C:\\Users\\S2522\\Desktop&gt; wsl -l -v  NAME       STATE           VERSION* CentOS8    Stopped         2\n\nwsl命令中并没有--start选项，我们直接用wsl命令，就会自动重启并进入这个虚拟机。\n这时候再在虚拟机内部看看CPU和内存信息，就可以看到你刚刚配置的性能限制结果了。\n[root@7945R9P ~]# cat /proc/cpuinfo | grep processorprocessor       : 0processor       : 1processor       : 2processor       : 3processor       : 4processor       : 5processor       : 6processor       : 7[root@7945R9P ~]# cat /proc/meminfo | grep TotalMemTotal:        8136640 kBSwapTotal:       8388608 kBVmallocTotal:   34359738367 kBHugePages_Total:       0\n\n删除wsl主机删除虚拟机的命令如下\nwsl --unregister &lt;DistributionName&gt;\n\n更多命令参考微软官网 https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands\n6.启用systemctl我们的系统里面有systemctl命令，但是没有办法使用。网上有些教程说用service命令来替代，但CentOS中是没有service命令的。\n[root@7945R9P bison-3.8]# systemctlSystem has not been booted with systemd as init system (PID 1). Can&#x27;t operate.Failed to connect to bus: Host is down\n\n6.1 distrod 第三方工具我们需要用distrod来安装systemctl的组件，才能成功启用它。具体教程参考github仓库的README中的介绍。不是很难\n\nhttps://github.com/nullpo-head/wsl-distrod\n\n先下载一个自动安装的脚本（连不上github会报ssl或者timeout错误，请使用其他办法下载这个脚本再丢到虚拟机里面去就行）\ncurl -L -O &quot;https://raw.githubusercontent.com/nullpo-head/wsl-distrod/main/install.sh&quot;chmod +x install.shsudo ./install.sh install\n\n然后用下面两个命令之一来启动（第一个命令是会在windows开机自动启动的）\n/opt/distrod/bin/distrod enable --start-on-windows-boot/opt/distrod/bin/distrod enable\n\n更多内容相见该仓库README；\n请注意，执行第一个自启动命令的时候需要windows的管理员权限，此时需要输入的是系统登录的微软账户的密码（不是你的PIN），看下面，我第一次输入密码输入的就是PIN，显示错误，第二次输入了微软账户的密码才成功。\n[root@7945R9P pkg]# /opt/distrod/bin/distrod enable --start-on-windows-boot[Distrod] Distrod has been enabled. Now your shell will start under systemd.[Distrod] Enabling atuomatic startup of Distrod. UAC dialog will appear because schedulinga task requires the admin privilege. Please hit enter to proceed.ErrorIt seems the task has not been scheduled successfully. You may have typed a wrong password, or you may not have thenecessary administrative privileges. Do you want to retry?[Y] Yes  [N] No  [?] 帮助 (默认值为“Y”): yEnabling autostart has succeeded.[Distrod] Distrod will now start automatically on Windows startup.\n\n操作完成后，需要重启虚拟机。用如下命令将对应的wsl虚拟机关闭就行了，再次执行wsl就会重启这个虚拟机。\nwsl --terminate CentOS8\n\n如图，我的systemctl命令已经生效。\n\n也能正常通过systemctl命令启动mariadb数据库\n\n6.2 微软官方（推荐）\n参考 https://zhuanlan.zhihu.com/p/569883693\n\n查看wsl版本号命令为： wsl --version，如果此命令未正常回显版本号，或版本号低于0.67.6，那么你安装的wsl还不支持systemd。如下，我的wsl版本已经是支持的了。\nPS C:\\Users\\S2522\\Desktop&gt; wsl --versionWSL 版本： 1.2.5.0内核版本： 5.15.90.1WSLg 版本： 1.0.51MSRDC 版本： 1.2.3770Direct3D 版本： 1.608.2-61064218DXCore 版本： 10.0.25131.1002-220531-1700.rs-onecore-base2-hypWindows 版本： 10.0.22621.2134\n\n进入wsl的CentOS虚拟机，执行如下命令\necho -e &quot;[boot]\\nsystemd=true&quot; | sudo tee -a /etc/wsl.conf\n\n随后exit退出虚拟机，回到windows终端命令行，重启wsl\nwsl --shutdown\n\n随后再次在windows命令行下执行wsl命令，重启这个虚拟机；\n重启wsl虚拟机后，在虚拟机内部执行如下命令\nps --no-headers -o comm 1\n\n\n如果这个命令返回结果是systemd，则代表我们的systemctl命令已经可以使用。\n如果返回的是init，则设置失败\n\n如下图，我已经设置成功了！\n\n微软官方支持的systemd还是有一点是优于distrod的，那就是启用了官方 systemd 的 wsl2 实例，在用户停止操作后，会自动关闭，和未启用 systemd 时的特性一样，这有利于节约电脑的计算资源。\n","categories":["玩上Linux"],"tags":["Linux","虚拟机"]},{"title":"【leetcode】LCR177：撞色搭配，数组中数字出现的次数","url":"/posts/2188918016/","content":"[TOC]\n题目说明\n来源：剑指 Offer 56 - I. 数组中数字出现的次数另外，260只出现以此的数字3这道题和本题是一样的。2023年再回头看，剑指offer在leatcode上改名成lcr了。所以本文标题也更新一下。\n\n难度：中等\n一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。\n示例 1：\n输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]\n\n示例 2：\n输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]\n\n\n限制：2 &lt;= nums.length &lt;= 10000\n\n方法1：常规做法最容易想到的常规做法：\n\n先对该数组进行qsort排序，再用for循环遍历，找到数组中下标i和i+1不相等的哪一项，这一项i即为只出现了一次的数字。\n\n若最末尾的数是目标数，需要进行判断并break，防止越界访问数组\n\n\n\n如果你不了解qsort，可以看这篇博客学习一下👉点我\n\n//方法1，太过简单，不够高级cmp(const void* e1, const void* e2)&#123;    return *(int*)e1 - *(int*)e2;&#125;int* singleNumbers(int* nums, int numsSize, int* returnSize) &#123;    int* result = (int*)calloc(2, sizeof(int));    int k = 0;    qsort(nums, numsSize, sizeof(int), cmp);//对原数组进行排序    int i = 0;    for (i = 0; i &lt; numsSize; i++)    &#123;        if (i == numsSize-1)//如果i是末尾数，需要进行判断        &#123;            result[k] = nums[i];            break;        &#125;        if (nums[i] == nums[i + 1])        &#123;            i ++;        &#125;        else        &#123;            result[k] = nums[i];            k++;        &#125;    &#125;    *returnSize = 2;    return result;&#125;\n\n\n\n方法2：异或求解复习一下位操作符很尬尴的是，本人对位操作符和移位操作符并不熟悉。经常把它们记混。几次测试的时候，涉及到这两个操作符的题目就是瞎蒙。\n后来发现位操作符和移位操作符似乎是测试中经常考察的对象，这里建议大家一定要把它们弄懂！\n\n\n\n语句\n操作符\n对应结果\n\n\n\nc &#x3D; a &amp; b\n&amp;按位与\n全1为1，否则0\n\n\nc &#x3D; a | b\n| 按位或\n有1为1，否则0\n\n\nc &#x3D; a ^ b\n^按位异或\n相同为0，不同为1\n\n\n\n题解异或有一个特点，a^a=0，a^0=a\n\n案例1输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]\n\n以题目所给参考2为例\n1^2^10^4^1^4^3^3 = 2^10\n\n可以看到，当我们把所给数据全部异或在一起的时候，其结果正好是我们需要的两个数相异或。\n但是我们好像并没有什么好的办法把已经异或了的两个数拆开\n这时候就需要对待查找的数据进行分组\n\n分组的目的：让两个单身狗分开到两组数据中\n这两组数据，除两个单身狗外，其他数字都出现了两次\n\n1 1 3 3 4 4 210\n\n为什么是这么分的呢？\n10: 10102:  001010^2=1000\n\n可见单身狗10和2之间，源码第四位才有差别\n1： 00012： 00103： 00114： 010010：1010\n\n这时候我们就可以通过第4位的差距，将数据分为两组\n\n第一组是1~4，它们的第4位都是0\n\n第二组是10，只有它的第四位是1\n\n\n再根据前面异或的特点，对这两组数字进行异或操作，即可得到单生狗10和2\n1^1^3^3^4^4^2 = 210 = 10\n\n\n案例2上面这组数据有些特殊，第二组里面只有10一个数字\n我们再来看一组数据\n1 2 3 4 5 1 2 3 4 6\n\n这一组数据中，单身狗是5和6\n5：01016：01105^6 = 0011\n\n可见5和6的源码中，第一、二位都有区别\n这里我们取第一位来分类即可\n1：00012：00103：00114：01005：01016：0110\n\n二进制第一位为1的数，放入一组\n1 1 3 3 52 2 4 4 6\n\n对它们进行异或操作，就可以得到单身狗5和6\n\n敲代码//方法2-异或int* singleNumbers(int* nums, int numsSize, int* returnSize) &#123;\t//1.全部异或在一起    int i = 0;    int k = 0;    for (i = 0; i &lt; numsSize; i++)    &#123;        k ^= nums[i];        //4^1^4^6 = 1^6    &#125;    //2.判断k的二进制第几位是1    int set = 0;    for (i = 0; i &lt; 32; i++)    &#123;        if (((k &gt;&gt; i) &amp; 1) == 1)//注意操作符优先级        &#123;            set = i;//第i位为1            break;        &#125;    &#125;    //3.以第set位为1进行分组，可以将这两个数分开    int n = 0;    int m = 0;    for (i = 0; i &lt; numsSize; i++)    &#123;        if (((nums[i] &gt;&gt; set) &amp; 1) == 1)        &#123;            n ^= nums[i];        &#125;        else        &#123;            m ^= nums[i];        &#125;    &#125;    int* result = (int*)calloc(2, sizeof(int));    //返回的数组必须用动态内存管理来创建    result[0] = n;    result[1] = m;    *returnSize = 2;    return result;&#125;\n\n验证自己整一个main函数来测试一下代码是否能达到要求，成功！\n\n做接口题的时候，如果出现输出错误的情况，可以自己写一个main函数并调试来找出错误\n\n\n可以看到，运行的用时远远小于方法1的用时\n击败了92.9%的用户！\n\n你学会了吗😍\n\n如果这篇博客对你有帮助，点个👍再走呗~\n\n摸鱼之发现另外一道一样的题\nhttps://leetcode.cn/problems/single-number-iii/submissions/\n\nclass Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        //1.全部异或在一起        int numsSize=nums.size();        int i = 0;        int k = 0;        for (i = 0; i &lt; numsSize; i++)        &#123;            k ^= nums[i];            //4^1^4^6 = 1^6        &#125;        //2.判断k的二进制第几位是1        int set = 0;        for (i = 0; i &lt; 32; i++)        &#123;            if (((k &gt;&gt; i) &amp; 1) == 1)//注意操作符优先级            &#123;                set = i;//第i位为1                break;            &#125;        &#125;        //3.以第set位为1进行分组，可以将这两个数分开        int n = 0;        int m = 0;        for (i = 0; i &lt; numsSize; i++)        &#123;            if (((nums[i] &gt;&gt; set) &amp; 1) == 1)            &#123;                n ^= nums[i];            &#125;            else            &#123;                m ^= nums[i];            &#125;        &#125;        vector&lt;int&gt; retV;        retV.push_back(n);        retV.push_back(m);        return retV;    &#125;&#125;;\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","leetcode"]},{"title":"【Linux】如何使用ssh密钥配置git","url":"/posts/3625274788/","content":"之前的腾讯云搭建Linux环境博客中包含了本文，但是由于在我的环境下SSH配置git无法多次生效。\n为了避免误导，所以把这一部分单独成文，并删除原文中相关部分\n\n22-06-19更新：问题已解决，可放心阅读本文！\n\n\n\n[TOC]\n1.创建SSH密钥①本地创建ssh密钥输入这个语句（github啥的都是同理）\nssh-keygen -t rsa -C &quot;你的gitee账户邮箱&quot;\n\n然后会弹出来让你输入一个文件名，直接连按3次回车跳过\nEnter file in which to save the key (/home/muxue/.ssh/id_rsa): id_rsa_用户名Enter passphrase (empty for no passphrase): Enter same passphrase again: \n\n后面出现的passphrase语句直接回车跳过，出现下面这个就是配置好了\nYour identification has been saved in id_rsa_用户名……#后面还有很多，还出现了一个文字组成的图片\n\n②把SSH公钥添加到gitee&#x2F;github账户上直接cd .ssh进入隐藏文件夹，cat你刚刚生成的pub文件，将内容复制\ncd .sshcat id_rsa.pub\n\n你还可以使用Xftp打开刚刚创建的密钥文件，把里面生成的内容复制一份\n\n\n在gitee账户设置中找到SSH公钥，添加即可\n\ngithub同理（github中文页面是用了油猴插件）\n\n同一个密钥是可以在多个平台用的，但是同一个密钥不能在多个设备用。\n否则push的时候，远端服务器会禁止并提示你当前密钥有另外一台设备在使用。\n为了安全性，建议一台主机一个ssh密钥，并定时轮换（重新生成新的，替换掉旧的）\n③测试ssh连接搞定密钥后，测试是否可以用ssh访问我们的远程仓库\nssh -T git@gitee.com//github只需要把gitee改成github就行了\n\n出现下面的就是成功了\n\n\n④该方式有错误（已解决）SSH方式不知为何，在我的云主机上，只有当次设置有效，重新打开终端连接云服务器（云服务器没有重启）SSH就会失效。在我的Linux用户目录下以及我朋友的用户目录下都出现了这个问题！\n\n如果你也出现了这个问题，请直接使用账户密码方式，而不是SSH\n\n22-06-19更新：在原先博客中，提到了下面这个本地添加ssh密钥的步骤（该步骤错误，请不要执行）\n\n执行下面两个语句，添加你的ssh密钥到设置中。注意，生成的密匙应该是在\nssh-agent bashssh-add ~/.ssh/id_rsa_用户名\n\n\n\n实际上，出现无法多次使用的问题，就是因为这莫须有的一步操作！\n正确方法是：别执行这一步，就OK了！\n如果你之前做了这一步，那就重新创建一个ssh密钥\n\n2.克隆远程仓库使用mkdir 文件夹名创建一个文件夹，CD进去后，克隆我们的远程仓库\ngit clone 远程仓库的ssh链接\n\n因为现在我们配置的是SSH方式，所以要使用SSH链接而不是https\n\n\n克隆成功后，cd进入该目录，git status查看git仓库当前状态，应该是up-to-date的。\n3.上传代码随便创建一个新的文件，测试能否正常PUSH到远程仓库\n\n这部分设计到git命令行操作，如果你不会，可以搜几篇git的博客学习一下\n\ngit add 文件夹 #添加需要上传的文件路径git commit -m &quot;输入push信息&quot; #git push的信息git push #和远程仓库同步\n\n\n因为我们没有设置用户名和邮箱，所以出现了下面的报错\n\n用下面的两行命令，可以单独设置当前仓库的用户邮箱和用户名。如果需要全局设置，则依照上图中的操作，使用git config --global语句即可\ngit config  user.email &quot;you@example.com&quot;git config  user.name &quot;Your Name&quot;\n\n同时我们需要用下面的这个命令，设置让git默认push到当前分支上\ngit config --global push.default current\n\n\n再次测试git push，成功！\n\n\n有任何问题都可以在评论区提出哦！\n","categories":["玩上Linux"],"tags":["Linux","git"]},{"title":"【Git】如何修改本地仓库的用户名和邮箱","url":"/posts/3842037186/","content":"如果你想在gitea上面加密存储一些数据（比如个人的密码）之类私密的东西，可以尝试用git-crypt加密文件后再上传\n\n\n\n比如有些老哥担心git托管服务商会偷看自己的文件，额……咱也不能完全否认这可能性吧\n\n如何使用以下演示的只有windows系统能用\n1.安装\noholovko&#x2F;git-crypt-windows\n\n在上面的项目中下载exe文件，放入你电脑git安装路径的git/cmd目录中，即可使用\n在电脑的任意位置使用git的命令行输入git-crypt确认正确安装\n2.使用在需要加密的仓库中输入以下命令\ngit-crypt init\n\n然后输入status命令查看状态\nPS D:\\Program Files\\nas\\MyPWD&gt; git-crypt statusnot encrypted: .gitignorenot encrypted: README.mdPS D:\\Program Files\\nas\\MyPWD&gt;\n\n添加.gitattributes文件，键入以下格式的内容\n需要加密的文件路径或者文件名 filter=git-crypt diff=git-crypt\n\n此时先将需要加密的文件移出本仓库，commit上传.gitattributes文件，再将需要加密的文件移动回来\n此时再查看状态，会发现已经加密了\nPS D:\\Program Files\\nas\\MyPWD&gt; git-crypt statusnot encrypted: .gitattributesnot encrypted: .gitignore    encrypted: PWD/napd.mdnot encrypted: README.mdPS D:\\Program Files\\nas\\MyPWD&gt;\n\n此时再使用git三板斧，此时被添加到远端的文件就已经是加密过后的了\n3.解密使用下面的命令导出密钥\ngit-crypt export-key 文件key的名字\n\n因为是个人使用，为了避免以后无法打开此文件，应在多处存放此key（但是不要存云盘里面）\n只有同时获得仓库文件+key才能解密出此项目中的内容！\n\n当然，最初的本地项目也是明文的\n\n使用key解密仓库文件，即可看到明文内容\ngit-crypt unlock /path/to/key\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】提交信息规范 | 转载","url":"/posts/998453050/","content":"git代码提交规范的那些事\n\n\n1.提交格式type(scope): message\n\n\n2.参数介绍2.1 typetype：指的代码的提交类型，不同的提交类型表示对应不同的代码改动，比如：\n\nfeat：新功能的开发\nfix：bug的修复\ndocs：文档格式的改动\nstyle：代码格式改变\nrefactor：对已有的功能进行重构\nperf：性能优化\ntest：增加测试\nbuild：改变了build工具\nrevert：撤销上一次的commit提交\nchore：构建过程或辅助工具的变动\n\n2.2 scopescope：用于说明commit影响的范围，比如：权限模块、还是首页\n2.3 messagemessage：对提交的代码做一个简短的说明，不能过长。\n\n需要注意的是，提交格式并没有一个固定的规范，不管你最后采取了什么格式，一定要遵守一个理念：那就是同一仓库的所有代码提交需要采用一个固定的格式。不能出现一个仓库里面用两个风格的git commit的情况\n作者：听书先生  链接：https://www.jianshu.com/p/2ab3a991d1f9  来源：简书  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】解决git status中文乱码问题 | 转载","url":"/posts/3422840311/","content":"解决windows下命令行中git status中文乱码问题\n\n\n起因在项目下输入git status之后，出现如下情况：\n\n在线搜索了一下，发现是git添加了如下特性：\n\ngit参考文档：https://git-scm.com/docs/git-config\n问题根据上面的文档得知，git对超过0x80的字符都会以八进制输出，由于中文以UTF-8保存，所以上面的文件路径输出了一堆的八进制转义代码，这对用户极其不友好。\n文档给出的方案是-z，通过-z选项的确可以输出正确的中文，但是却缺少了详细信息：\n\n所有的输出全在一行，对用户也不好友。\n查阅git status命令文档可知：\n\n该选项会以NUL为一行的几位，但是终端不能识别NUL结尾，所以终端不会自动换行。\n解决那么最终的解决办法：关闭这个特性。\ngit config --global core.quotePath false\n\n\n再次执行git status：\n\n一切回归正常。\n然后git add python添加所有修改过的文件：\n\n更多默认情况下，git会将入库的文件的行尾符替换为LF，这是因为git原生的工作环境是linux&#x2F;unix，而我目前工作环境是windows，所以这个也挺正常的。当下次在windows下检出分支的时候，会自动将LF替换为CRLF。\n这个警告并不会带来什么问题，完全可以忽略。\n版权声明：本文为CSDN博主「lengye7」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/lengye7/article/details/129208899\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】如何修改本地仓库的用户名和邮箱","url":"/posts/3842037185/","content":"最近我修改了我gitee和github的用户名还有邮箱，所以需要对本地仓库配置的用户名和邮箱进行更改\n\n\n1.命令 刚开始我使用的是如下命令\ngit config --global user.email &quot;邮箱&quot;git config --global user.name &quot;用户名&quot;\n\n但是很不辛，这个命令没有用，因为它是用来初始化你的git环境的，对已有的git仓库不起作用\n但是我们在linux下可以添加上另外一个参数来实现\ngit config --global --replace-all user.email &quot;邮箱&quot; git config --global --replace-all user.name &quot;用户名&quot;\n\n这样就修改成功了\n\n\n这个命令在windows下似乎无法识别，会弹出git的命令行帮助\n\n\n但是，修改成功后的提交，只对未来的提交有效；这里必须得吐槽一下gitee和github统计提交的不同之处\n\ngitee统计提交依据的是用户名+邮箱，只要有一个不对就无法统计\ngithub统计提交只依据邮箱，只要你邮箱对了，用户名是不管你的\n\n所以要想让gitee的统计能生效，那就必须要修改之前所有提交信息中的用户名和邮箱\n\n2.修改之前提交中的用户名和邮箱\n参考博客\n\n复制如下代码到一个本文编辑器里面，将内部的邮箱和用户信息修改\ngit filter-branch -f --env-filter &#x27;OLD_EMAIL=&quot;原来的邮箱&quot;CORRECT_NAME=&quot;现在的名字&quot;CORRECT_EMAIL=&quot;现在的邮箱&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&#x27; --tag-name-filter cat -- --branches --tags\n\n随后将其粘贴到git命令行中，回车执行\n\n\n执行完毕，就能看到所有git提交的用户名和邮箱都修改成功了！接下来要做的就是强制提交\ngit push -f\n\n强制提交了之后，之前显示不出来的信息和小绿点，现在也能正常显示了\n\n如果用上面的命令修改失败的话，那就尝试执行下面的命令\ngit filter-branch -f --index-filter &#x27;git rm --cached --ignore-unmatch Rakefile&#x27; HEAD\n\n随后再重试上面的命令，应该就OK了\n","categories":["差生文具多"],"tags":["Linux","git"]},{"title":"【Git】如何同步Gitee和Github的仓库（超简单）","url":"/posts/2629909823/","content":"本篇博客的设置方法同样可以适用于gitlab等其他平台\n不多bb，直入主题⏲\n\n\n实现两个仓库的同步1.准备两个仓库分别在两个平台创建一个相同名字的仓库，当然，你也可以在a平台上导入b平台已有的仓库，github和gitee目前都支持从别的平台导入仓库\n这部分操作想必大家都会，就不演示了\n2.克隆到本地需要注意的是，你要保证其中一个是主仓库。如果是多人合作仓库的话，想两个平台的远程仓库同时多人合作并保持同步是相对困难的。\n\nhttps://gitee.com/musnow/LetsOJ\n\n\n以我创立的这个多人OJ打卡仓库为例，现在我想得到的效果是，我和朋友们在gitee上面进行打卡协作，然后我通过git操作将这个仓库同步到github上面，仅供展示\n\n当然如果有小伙伴愿意用github进行fork和pull request操作那我也是举双手双脚赞同+欢迎的\n\n需要做的是，既然gitee是主战场，那就对gitee进行克隆操作\ngit clone https://gitee.com/musnow/LetsOJ.git\n\n\n3.设置第二个仓库的url克隆完毕后，直接进入该仓库的.git文件夹，修改config文件\n\n在原本gitee的url后面，添加github的仓库url\n\n执行git remote -v，你可以看到github链接的仓库也显示了出来，后面带有push后缀，代表我们只能往这个仓库上传，并不能执行git pull操作\n\n这时候的设置已经完成了，你可以进行一次修改文件后的git push操作，两个仓库都可以同步！而且上传的编号都是相同的！\n\n\n这时候的基本设置就已经完毕了！如果你还想做到能从github仓库中进行pull操作，那就接着往下看\n4.关于pull操作前面提到，github仓库的url后面有一个push后缀，代表我们不能从这个仓库里面获取更新\n你如果修改了github的仓库，执行git pull操作，会显示Already up-to-date.因为系统检索的是gitee仓库的修改，并不知道你的github仓库有无修改\n\n这时候可以执行下面的语句\ngit remote add github git@github.com:musnows/Lets_OJ.git\n\n再次git remote -v，可以看到在远程仓库中多出来了一个github为名字的仓库类型，而且这一次的仓库是可以fetch也就是获取内容的\n\n这时候你可以执行\ngit pull github\n\n即可获取github仓库的最新更新\n这样就实现了gitee仓库和github仓库的多端同步啦！\n5.效果演示现在我让朋友在gitee的仓库中上传一个内容\n\n执行git pull，可以看到系统从gitee的仓库中更新了内容\n\n这时候你执行git status，理论上来说会出现新文件对吧？并不会\n\n毕竟这时候系统检查的还是gitee主仓库，内容都是完全同步的\n我们也不需要写git add和git commit，直接执行git push即可！\n\n再打开github瞅瞅，你会发现已经同步成功了！\n\n\n提醒强烈建议：如果是多人合作仓库，请确保在某一个平台作为主战场，另外一个平台仅作展示（留档）使用！\n不过我发现了一个好事，那就是当我从gitee导入这个仓库到github的时候，github不仅会自动同步小绿点，还会将这个仓库的协作者同样显示出来（前提是协作者在github上面有同邮箱注册的账户）\n\n一些问题的解决1.关于github克隆网络访问问题关于克隆&#x2F;上传github问题，很多都是因为使用https链接导致的\n我们需要使用ssh私钥来实现github仓库的免密操作\nssh-keygen -t rsa -C &quot;你的gitee/github账户邮箱&quot;\n\ncd进入.ssh隐藏文件夹，找到生成的密钥pub文件\ncat查看该文件里面的内容，将其复制\n在github&#x2F;gitee的个人设置页面，你都能找到ssh密钥的添加处\n\n\n添加ssh密钥后，你就可以通过ssh链接来对github进行操作了，这时候一般就不会出现网络问题了！\n2……还没遇到……😂\n结语关于这项操作，网络上有很多相似内容，但总有些货不对板，不符合我的需求。所以就自己写了个博客\n有任何问题都可以在评论区提出！\n","categories":["玩上Linux"],"tags":["Linux","git"]},{"title":"【Git】解决push时遇到的RPC 413和520错误","url":"/posts/89600062/","content":"解决git push遇到413和510RPC错误\n\n\n说明如题，在使用git上传我的hexo配置仓库到我自己搭建的gitea上时，遇到了这个报错。\n说明：该仓库已在gitea中存在，但是很久没有更新过（数个月），一次push的更新量较大\n所以就遇到了这个报错！下面给出两个报错的完整输出\nPS D:\\HEXO\\blog&gt; git push nasEnumerating objects: 30332, done.Counting objects: 100% (30332/30332), done.Delta compression using up to 16 threadsCompressing objects: 100% (12271/12271), done.Writing objects: 100% (30332/30332), 54.44 MiB | 127.27 MiB/s, done.Total 30332 (delta 10987), reused 29639 (delta 10321), pack-reused 0error: RPC failed; HTTP 520 curl 22 The requested URL returned error: 520send-pack: unexpected disconnect while reading sideband packetfatal: the remote end hung up unexpectedly\n\nPS D:\\HEXO\\blog&gt; git push nasEnumerating objects: 30332, done.Counting objects: 100% (30332/30332), done.Delta compression using up to 16 threadsCompressing objects: 100% (12271/12271), done.Writing objects: 100% (30332/30332), 54.45 MiB | 135.99 MiB/s, done.Total 30332 (delta 10984), reused 29639 (delta 10321), pack-reused 0error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413send-pack: unexpected disconnect while reading sideband packetfatal: the remote end hung up unexpectedly\n\n解决思路第一步当然是百度了，百度到了这篇知乎文章\n\n知乎文章 https://zhuanlan.zhihu.com/p/359316694\n\n先依照第一个步骤，设置本地的buffer大小，再去尝试push\ngit config --global http.postbuffer 524288000\n\n配置完毕这个命令后，原本是520的报错，变成了413报错\nerror: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413\n\n再看文章内的分析\n\n413 Request Entity Too Large服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。\n\n考虑到我的云服务器是用nginx来反代gitea的，所以就采用文章中的第三步，修改nginx配置；\n在gitea的nginx配置文件中的server体内新增了如下限制\nclient_max_body_size 200m;\n\n重新启动nginx，就搞定了！\nPS D:\\HEXO\\blog&gt; git push nasEnumerating objects: 30332, done.Counting objects: 100% (30332/30332), done.Delta compression using up to 16 threadsCompressing objects: 100% (12271/12271), done.Writing objects: 100% (30332/30332), 54.44 MiB | 136.63 MiB/s, done.Total 30332 (delta 10987), reused 29638 (delta 10321), pack-reused 0remote: Resolving deltas: 100% (10987/10987), done.remote:remote: Create a new pull request for &#x27;hexo&#x27;:remote:   https://gitea.musnow.top/musnow/HexoBlog/compare/main...hexoremote:remote: . Processing 1 referencesremote: Processed 1 references in totalTo https://gitea.musnow.top/musnow/HexoBlog.git * [new branch]        hexo -&gt; hexo\n\n成功push到gitea的远程仓库！\n","categories":["差生文具多"],"tags":["git","nginx"]},{"title":"【MySQL】wsl的ubuntu中无法systemctl启动mariadb（已解决）","url":"/posts/1382619221/","content":"这是GPT的答案，实测有效。\n如果您在启动 MariaDB 时遇到 &quot;Failed to start mariadb.service: Interactive authentication required&quot; 错误，这是因为在 Ubuntu 22.04 上默认启用了 systemd 的用户会话限制，需要进行一些额外的步骤来解决该问题。以下是解决方法：\n打开终端，并使用以下命令编辑 MariaDB 的服务文件：\nsudo nano /lib/systemd/system/mariadb.service\n\n\n在文件的 [Service] 部分中添加一个新的行，内容如下：\n[Service]......ExecStartPre=/bin/sh -c &#x27;touch /etc/mysql/mariadb.conf.d/.interactive&#x27;\n\n确保在 [Service] 部分内的其他行之后添加此行。\n保存并关闭文件（在 Nano 编辑器中按 Ctrl+X，然后按 Y 确认保存）。\n运行以下命令重新加载 systemd 配置：\nsudo systemctl daemon-reload\n\n现在，您可以启动 MariaDB 服务：\nsudo systemctl start mariadb\n\n这次启动应该没有出现 “Interactive authentication required” 错误。\n最后，您可以设置 MariaDB 在系统启动时自动启动：\nsudo systemctl enable mariadb\n\n现在，您应该能够成功启动和运行 MariaDB 服务了。如果您仍然遇到问题，请确保按照上述步骤操作，并仔细检查所做的更改是否正确。\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【教程】Gitee如何下载单个文件","url":"/posts/2829756684/","content":"本篇博客将教您如何在gitee上下载单个文件\n\n\n引出问题不知使用gitee的你，有没有遇到过需要下载某个仓库文件的情况？\n\n比如下面这个仓库，是@宏沉一笑大佬转载obsidian的插件的仓库链接\n\n\n点击下载，你会发现gitee开始给你打包整个仓库文件，一个几百m的仓库怎么说也要几分钟才能下完。可是，我只是需要某一个主题或者插件，gitee却不能单文件或者单文件夹下载，这个时候又要怎么弄呢？\n\n解决问题解决这个问题的方法非常简单！\n只需要用chome或者新版edge浏览器，就能使用一个插件，来解决这个难题！\n我们可以在edge设置里面打开扩展商店，搜索GITEE\n\n下载gitee助手即可！\n\n安装这个扩展以后，重启浏览器，再次打开gitee\n\n可以看到，每个文件之后出现了单独的下载图标，点击它即可下载单个文件了\n\ngitee助手的代码也是开源的，主页链接👉点我\n\n大佬的提交绿点就是不一样\n\n\n结语个人也建议大家直接用edge浏览器和微软自带的输入法（这两个现在已经做的很好了）\n避免其他国产流氓污染自己的电脑\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["差生文具多"],"tags":["git","图床"]},{"title":"【Git】解决kex_exchange_identification错误","url":"/posts/1015332822/","content":"kex_exchange_identification: Connection closed by remote host\n\n\n今天在windows命令行下准备上传文件到github的时候，ssh出现了如下问题\n$ ssh -T git@github.comkex_exchange_identification: Connection closed by remote hostConnection closed by 20.205.243.166 port 22\n\n按照老办法，重新生成了ssh-key并添加到了github\n再次测试，依旧是此报错，可奇怪了\n\n于是百度了一下\nssh -Tv git@github.com\n\n用了这个命令，没想到就好了\nHi musnows! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.debug1: channel 0: free: client-session, nchannels 1Transferred: sent 3136, received 2936 bytes, in 0.7 secondsBytes per second: sent 4251.8, received 3980.7debug1: Exit status 1\n\n不过，也可能不是这个命令的作用，恐怕就是玄学网络问题罢了\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】在Windows CMD中和VScode中配置已经安装好的git","url":"/posts/932852149/","content":"本篇博客将教您如何将sourcetree下载好的git导入到windows的cmd进行使用\n\n\n问题引出\n我使用系统为win11。win10的操作理应相同，只不过设置的位置可能有差异\n\n我现在使用git主要用的是sourcetree的可视化界面，可以清楚地看到每一次提交的diff和提交历史，非常好用，也强烈推荐大家使用 【使用教程】\n\n不过当你初次安装sourcetree的时候，他会帮你下载一个git\n如果系统中已有git，也可能会被移动到sourcetree自己的内置使用目录中\n\n这样就会对我们在其他地方使用git-cmd造成一定的不便。\n对于git仓库，sourcetree会提供一个命令行的选项。但是需要从这里面打开肯定不如直接右键选择windows cmd方便！\n\n不过对于我来说，一个非常棒的优点就是——干掉了右键菜单的两个按钮😂\n所以现在我们想做到的就是让windows自带的cmd也可以直接用上git，这样就不担心单独使用git-cmd不方便了\n\n1.设置新的终端路径依据上面sourcetree给出的路径，找到被藏起来的git\nC:\\Users\\用户名\\AppData\\Local\\Atlassian\\SourceTree\\git_local\n\n注：AppData文件夹是隐藏的，需要打开文件资源管理器中的查看隐藏文件选项\n\n在随便一个地方右键，打开cmd\n\n右键上方边栏，选择设置\n\n划到最底下，选择添加一个新的配置文件\n\n这样设置即可，git的图标也是在我们刚刚打开的git目录中可以找到的\n\n注意，命令行要选择bin中的bash.exe而不是git-bash，后者会打开git自己那个老旧的命令行终端\n\n\n这时候，我们就可以在顶部的小三角图标中选择git bash进行使用了！\n\n\n不过！这时候如果你在windows powershell里面打出git，还是会提示找不到git命令。如果每一次都需要在下拉菜单中选择，那还是很麻烦呀！\n\n2.设置环境变量打开电脑设置-系统，拉到最底下，找到系统信息\n\n选择高级系统设置\n\n在高级面板中打开环境变量\n\n在下方系统变量中找到path，选择编辑\n\n在里面新建一个git的环境变量，填入cmd文件夹的路径，注意是cmd文件夹！\n\nC:\\Users\\用户名\\AppData\\Local\\Atlassian\\SourceTree\\git_local\\cmd\n\n\n填入后确定保存，再次打开windows power shell，输入git\n出现下方的git命令帮助，那就大功告成！\n\n\nvscode中git路径配置来都来了，顺便说一嘴vsc中的git路径配置吧！\n在设置中搜索git path，点击在settings.json中编辑\n\n在git.path中填入路径即可！\n注意：因为有转义，所以路径分隔符\\需要改成两个\\\\\n\n点击左侧git管理页面，看到正常显示出仓库就OK啦！\n\n","categories":["差生文具多"],"tags":["git"]},{"title":"【教程】Typora+PicGo+阿里云OSS搭建博客图床（超详细）","url":"/posts/1825409965/","content":"如果你想搭建一个和本站类似的个人博客，那就需要图床来辅助\n\n\n[TOC]\n为什么要搭建博客图床?以CSDN为例，我们可以选择使用大部分blog平台通用的markdown语法进行博客创作\n虽然CSDN自带的编辑器已经能满足我们95%的写作需求\n但是Typora在markdown语法编辑上能给你提供更好的写作体验\n所以我选择了以Typora+Picgo+图床的方式来进行博客创作\n\n而在本地的markdown文件.md中，图片是以“外链”这一形式存在的\n\nOffice word中，图片是直接插入docx文件里面\nMarkdown中，图片只是一个本地&#x2F;联网的地址\n\n如图，在markdown里面，图片显示的其实是一个本地的地址\n\n也就是说，如果我们使用本地markdown编译器（如typora）来编辑MD文件的时候，如果MD里面插入的图片的源文件被移动或者删除了，我们的MD文档里面对应的图片也无法显示出来。\n\n同时，如果我们用本地编辑器写好了一篇博客，想把它上传到CSDN上。CSDN是无法自动转存文件里面的图片的。因为这个图片只是一个你硬盘里面的文件路径，他也没办法越权跑到你电脑里面找文件呀！\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i1aotHJh-1679223552739)(./Snipaste_2023-03-19_18-58-37.png)]\n\n什么是图床？在我们往typora里插入图片的时候，PicGO自动上传图片到图床，并返回一个图片的链接\n\n这时候你的图片就是一个**网络的链接(网址)**，不再是本地路径。你也可以在任何有网络的地方、用任何设备访问这张图片了！\n\n即便是本地的那张图片移动or删除，也不会影响图床里的这张图片。\n同理，typora里面的图片也就不会失效了，CSDN也能正常从网络上将你的图片下载下来，我们的博客也能很方便的从typora拷贝到CSDN上发布。\n\n接下来就是如何搭建阿里云OSS图床的教学了！\n前排提醒，阿里云图床需要付费💴，但价格非常便宜！ \n\n如果你想白嫖，也可以考虑用gitee作为你的图床。但是gitee有单仓库文件大小限制(600mb)。后续图片多了，转移图床的成本更高。还不如一开始就选个好的平台，不是嘛？\ntypora+picgo+gitee图床配置方法，看这个👉【链接】\n\n22.03.26更新：果然“免费的才是最贵的”，经过多个朋友的反馈，确认gitee图床已经崩溃，图片在gitee仓库内没有问题，但是typora/picgo/obsidian内都无法正常预览图片，CSDN也无法转存！可能是gitee更新了外链机制，新增了防盗链。\n还是建议大家更着本篇博客使用阿里云OSS吧！\n1.准备软件1.1Typora\nTypora：【中文官网】\n\n想必各位应该听很多博主安利过Typora这款软件，这里就不展开描述了\n新版本typora需要付费买断。可以考虑支持正版，也可以去找找旧版本安装包\n\n参考这个视频👉【链接】\n如果你找到了旧版本安装包，需要确认typora版本高于0.9.86\n\n1.2Picgo\nPicGo：【Github地址】\n\n找到对应安装包，下载安装即可\n\n2.配置阿里云OSS在浏览器搜索阿里云OSS，即可找到官网\n\nhttps://www.aliyun.com/product/oss\n\n\n2.1注册,开通对象储存注册账户并实名后，进入你的控制台\n\n选择对象储存并开通\n\n2.2创建bucket在左侧选择概览，然后在右侧创建一个新的bucket\n\n注意： \n\nBucket名字不能有大写字母\n服务器就近选择\n图床选择标准存储\n读写权限公共读\n\n\n创建完成后，你的bucket应该就出现在了左侧\n2.3找到你的地域节点点击你的bucket名\n\n然后点击bucket下的概览\n\n在访问域名一栏找到你的地域节点，后面会用到\n\n如图，只需要复制oss-cn-shenzhen即可，不需要后面的.aliyuncs.com\n\n\n2.4找到你的Key来到右上角，鼠标放在你的头像上，在弹出的框里选择AccessKey管理\n\n在弹出的选项框里，选择“继续使用”\n\n进入后，创建一个AccessKey\n\n在弹出的界面里，记住你的accessKeyId和accessKeySecret\n\n2.5给你的阿里云账户充值2.5.1收费问题阿里云OSS的各项收费是独立的！\n对于图床而言，有两种收费形式\n\n以充值的方式使用储存容量以及流量(默认状态)\n按年&#x2F;月收费，购买一定存储包。流量额外收费\n\n也就是说，即便你购买了下图的存储包，你依旧要为访问图床的流量付钱！\n\n\n下图是在默认状态下，容量和流量收费的价格\n\n图床使用的是标准型，请勿购买其他类型\n\n\n储存容量：0.12元&#x2F;GB&#x2F;月\n图片上传到阿里OSS流量：免费\n外网流出流量(如typora访问图床图片)：闲时0.25元&#x2F;GB，忙时0.50元&#x2F;GB\n\n\n\n仔细算算，我们图床的数据量其实很小的\n\n0.12元&#x2F;1GB&#x2F;1个月，一年就是1.44元，远低于40GB的9元收费！\n截图&#x2F;照片以平均0.5mb&#x2F;张估算，1gb可存放超过1600张图片！\n数据低于7GB的情况下直接充值，以GB付费其实比购买储存包更加值得！\n\n2.5.2注意事项\n记得给阿里云账户充值！！别到时候欠费停用了！！\n刚开始作图床的时候，直接充值使用即可，无需购买容量包！\n\n\n到这里，我们阿里云OSS基本配置完毕了😎\n\n3.配置picgo打开picgo后，在你windows的状态栏里找到picgo的图标，打开picgo的主界面\n\n3.1图床设置在图床设置里面选择阿里云OSS，依照以下步骤填写信息\n\n设定Keyld：填写刚刚获得的AccessKeyID\n\n设定KeySecret：填写AccessKeyIDSecret（注意，直接从OSS控制台中复制keysecret有概率会出现空格or回车，建议先复制到记事本中，再复制到picgo中）\n\n设定储存空间名：填写bucket名称。不是浏览器里的域名\n\n指定存储路径：其实就是自定义一个文件夹的名字，以/结尾. 它会自动在你的bucket里面创建一个文件夹，并把图片上传进去\n\n\n\n弄完之后，记得“确定”，并点击“设置为默认图床”！\n\n3.2picgo设置在设置里打开时间戳重命名和上传后自动复制URL\n\n时间戳重命名：以上传时间来重命名图片，避免同名的图片无法上传（该设置不影响本地图片名）\n\n\n4.配置typora进入typora主界面，点击左上角的“文件-偏好设置”\n\n选择图像\n插入图片时上传图片\n下面的选项全勾上（第二项对网络位置的图片可钩可不钩，主要是避免同一张图片被多次上传）\n上传服务选择PicGo(app)\nPicGo路径：找到picgo的安装路径，不是安装包的路径！！！！\n\n\n\n5.测试是否成功5.1 typora自带上传测试设置完毕后，我们点击验证图片上传选项，如果弹出以下弹窗，我们的图床就搞定了！😀\n\n如果出错了，建议先自己看看picgo的日志里面为什么报错，检查一下配置有没有出错。\n如果看不明白日志的报错，就去picgo的github仓库开一个issue问。对于picgo的错误我也不是很清楚，来问我是浪费你的时间🙅‍♀️\n如果你在检查过picgo配置内容和阿里云OSS设置、重启picgo、重启电脑后仍然无法成功上传。还可以参考这篇博客的配置方法👉 很不幸，原文已被删除\n\n5.2 复制图片测试上传最后新建一个文件，验证图片是否正常上传。\n日常写作的时候，我们只需要复制图片，在typora里面粘贴即可，无需拖动！\n当你的图片链接显示为阿里云的网络链接，而不是本地路径时\n\n6.大功告成！到这里，我们的图床就大获全胜！开始你的创作吧！🧐\n","categories":["差生文具多"],"tags":["图床","typora"]},{"title":"【MySQL】windows11安装mysql","url":"/posts/1951514193/","content":"本文是找到的不错的windows下安装mysql的教程，在我的windows11笔记本上成功安装并能正常使用。在此转载下来\n\n\n原文链接：https://blog.csdn.net/ouyangzhenxin/article/details/125514255\n一、提前认知要想在windows中运行mysql，需要32位或者64的windows操作系统，例如：windows10、windows11等；\nwindows平台下提供了两种安装方式：\n\nmysql二进制分发版本（.msi安装文件）；\n\n免安装版（.zip压缩文件）\n\n\n一般我们使用二进制分发版本来安装。\n我这里使用的环境是：\nwindows11-64位\nmysql二进制分发版本\n\n​    \n二、下载mysql安装包1、打开浏览器，访问mysql官网中的下载地址https://dev.mysql.com/downloads/installer/\n\n​    \n2、点击下载按钮，下载安装包到本地装程序有两个版本，分别为mysql-installer-web-community和mysql-installer-communityl，其中mysql-installer-web-community为在线安装版本，mysql-installer-communityl为离线安装版本。在这里我们是当然是选择离线安装版本了。\n\n然后在下面的界面中点击（No thanks, just start my download.）意思是说，我们不登录也不注册，仅仅是下载一个安装包。\n\n然后就会启动我们的下载了，当我们下载结束之后，会得到下面的mysql软件安装包；\n\n三、安装mysql双击mysql安装包，稍等一会儿之后，出现如下安装界面；\n\n可以看到有5中安装类型，分别是：\n\nDeveloper Default：默认安装类型\n\nServer only：仅作为服务器\n\nClient only：仅作为客户端\n\nFull：完全安装\n\nCustom：自定义安装\n\n\n在这里我们选择Custom，也就是自定义安装，然后点击Next；\n\n出现如下界面；\n\n我们进行选择性的安装；\n我们选装MySQL Server 8.0.29-X64、MYSQL Documentation 8.0.29-X86和Samples and Examples 8.0.29-X86即可。\n\n然后点击Next界面，出现下图，我们点击Execute（执行）：\n\n然后就会执行安装了，如下图：\n\n然后我们耐心等待，直至出现如下界面，我们点击Next；\n\n出现下图，我们依旧点击Next；\n\n四、配置mysql出现服务器类型配置窗口，如图：\n\n当我们点击Config Type的时候，可以看到出现几个选项；\n\n上面几个含义分别是：\n\nDevelopment Machine（开发机器）：该选项代表典型个人用桌面工作站。假定机器上运行着多个桌面应用程序，将MySQL服务器配置成使用最少的系统资源。\n\nServer Machine（服务器）：该选项代表服务器，MySQL服务器可以同其他应用程序一起运行，例如FTP、Email和Web服务器。MySQL服务器配置成使用适当比例的系统资源。\n\nDedicated Machine（专用服务器）：该选项代表只运行MySQL服务的服务器。假定没有运行其他服务程序，MySQL服务器配置成使用所有可用系统资源。\n\n\n在这里我们使用Development Machine（开发机器），方便使用，别的默认配置都不动，直接点击Next。\n出现如图的权限设置方式窗口，第一个单选项的含义是MySQL 8.0提供的新的授权方式，采用SHA256基础的密码加密方法；第二个单选项的含义是传统授权方法（保留5.x版本兼容性）。这里选择第二个单选项。\n\n点击Next之后，我们就在新弹出的界面中，配置mysql数据库的root用户名登录信息了，这里我设置的是Yunweijia0909，我们需要输入两遍哈；\n当然，我们也可以在这个界面中新添加其他用户，这个根据实际情况来配置即可；\n\n配置完毕之后，我们继续点击Next按钮；\n然后就可以配置数据库名字了，这里我们配置成MySQL；\n\n点击Next，然后再点击Execute，如图：\n\n系统自动配置MySQL服务器。配置完成后，单击Finish（完成）按钮，弹出新对话框;\n\n接下来界面中点击Next之后，出现如下界面：\n\n在这里我们输入之前配置的用户信息，即Yunweijia0909，然后点击Check按钮，就会发现他右上角的Status变成了Connection succeeded，表示连接成功了。确定无误之后，点击Next;\n新界面中点击Execute；\n\n运行完毕之后会出现Finish按钮，点击即可；\n\n然后在新界面中点击右下角的Next，出现：\n\n我们的MySQL就安装完成了。\n五、验证1、任务管理器打开任务管理器也会发现有一个mysql.exe的进程，如图：\n\n2、命令行PS C:\\Users\\22768&gt; mysql -uroot -p\nEnter password: *************\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 18\nServer version: 8.0.29 MySQL Community Server - GPL\n\nCopyright (c) 2000, 2021, Oracle and/or its affiliates.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n\nmysql&gt;\n\n​    \n至此，本文结束。\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【MySQL】deepin安装mysql的cpp开发包","url":"/posts/971003431/","content":"在deepin下安装好mysql后，发现在c语言中没有&lt;mysql.h&gt;的头文件。\n而根据ubuntu的办法直接按照mysql的开发包，会出现这种情况：\n~/Desktop$ sudo apt-get install libmysqlclient-dev正在读取软件包列表… 完成正在分析软件包的依赖关系树正在读取状态信息… 完成没有可用的软件包 libmysqlclient-dev，但是它被其它的软件包引用了。这可能意味着这个缺失的软件包可能已被废弃，或者只能在其他发布源中找到E: 软件包 libmysqlclient-dev 没有可安装候选\n\n首先使用命令sudo apt install default-libmysqlclient-dev，会出现如下：\n~/Desktop$ sudo apt install default-libmysqlclient-dev正在读取软件包列表… 完成正在分析软件包的依赖关系树正在读取状态信息… 完成将会同时安装下列软件：libmariadbclient-dev libmariadbclient-dev-compat下列【新】软件包将被安装：………\n\n安装好后在运行一次，此时已经是最新版\n第二步使用如下命令安装mariadb的开发包，和mysql是一样的；这样执行了之后，那么你在linux中就应该能引入头文件&lt;mysql/mysql.h&gt;了。\nsudo apt-get install libmariadbclient-dev\n\n\n此时 /usr/include里面已经有mysql的文件夹了！\n\n这是我在找到方法的链接：\nhttps://blog.csdn.net/guyspring/article/details/104302131\nhttps://stackoverflow.com/questions/5178292/pip-install-mysql-python-fails-with-environmenterror-mysql-config-not-found#\n希望有用！\n版权声明：本文为CSDN博主「衣兜」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/wu___hao/article/details/113257493\n\n该方法慕雪在deepin 20.9虚拟机上实测有效！\n","categories":["学习sql"],"tags":["Linux","mysql"]},{"title":"【Git】git仓库code review行话 | 转载","url":"/posts/2882797349/","content":"程序员这个行业，不管你是大佬还是小弟，代码code review是必不可少的。那么在git上，大家日常交流的缩写语，往往一下就能看出你道行的深浅，至少是入行时间，哈哈，不要露怯，勇敢的跟大佬过招拆招。\n\n\n收集了一些实用的缩写，方便大家日常交流(装B)  \nLGTM  —  Looks good to me，表示认可这次PR，同意merge 合并代码到远程仓库  ASAP -— as soon as possible! 尽快  ACK  —  acknowledgement, i.e. agreed/accepted change  NACK/NAK — negative acknowledgement, i.e. disagree with change and/or concept  RFC  —  request for comments, i.e. I think this is a good idea, lets discuss  WIP：Work In Progress 「进展中」，常见词汇，这里做为 Best Practice 单独提出来，主要针对改动较多的 PR，可以先提交部分，标题或 Tag 加上 WIP，表示尚未完成，这样别人可以先 review 已提交的部分  AFAIK/AFAICT  —  as far as I know / can tell  IIRC  —  if I recall correctly  IANAL  — “ I am not a lawyer ”, but I smell licensing issues  IMO  — （In my opinion），在我看来  TL;DR  —  Too Long; Didn&#x27;t Read 「太长懒得看」，README 文档常见。  PR  —  Pull request「合并请求」  CR  —  Code Review 「代码审查」  PTAL  —  Please Take A Look. 你来瞅瞅？用来提示别人来看一下  TBR  —  To Be Reviewed. 提示维护者进行 review  TBD  —  To Be Done(or Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思。  TBH  —  To be honest 「老实说」  atm  —  at the moment 「现阶段」，\n\n站长注：其实主要还是在看别人pr的时候用，比如别人给你发了一个pull rq，你检查了之后，感觉没有什么问题，就可以发一个LGTM表示你认可了这个pr贡献！\n作者：前端大飞  链接：https://www.jianshu.com/p/238a1e1f4037  来源：简书  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】Sourcetree的初始化与使用","url":"/posts/2410861413/","content":"[TOC]\n前言还在用小乌龟管理你的git本地代码吗？\n为何不来尝试一下，这款界面更加直观的git可视化工具！\n\nsorcetree官网👉https://www.sourcetreeapp.com/\n\n别看到英文官网就跑了，软件本身是中文界面！\n\n\n注：本博文只讲述sourcetree初始化方式，并不讨论其与TortoiseGit的功能强弱\n\n什么？你还不知道git是啥？\n那还不赶快点击这篇博客了解一二！👇\n\n实习生 Git 不熟练，还没脸去问是种什么体验…\n\n\n1.初始化下载安装以后，你会看到以下界面\n若不需要用bitbucket，选择跳过即可\n\n第二步，sourcetree会让你下载这两个工具\n\n如果你的电脑里已经有了，它能检测出来安装位置\n如果你的电脑里没有这两个工具，它会自动帮你下载\n\n\n第三步，它会让你填写你的用户名和邮箱\n建议这里和你的gitee或github上的用户名&#x2F;邮箱同步！\n\n填写好后，点击下一步，会弹出这个界面\n选择“否”即可\n\n2.克隆仓库初始化完成后，会变成以下界面\n\n源路径：填写你的gitee&#x2F;github仓库链接\n目标路径：选择一个本地的空文件夹，注意路径不要有中文\n名字：填写一个会在Sourcetree里显示的仓库名字\n\n\n 那么问题来了，要怎么找到你的仓库链接呢？👇\n\n\n填写完毕后，sourcetree会开始下载，并在你选择的路径下创建本地仓库的文件夹\n\n如果你有多个远程仓库，点击+号重复上述步骤即可\n\n\n添加已有本地仓库已有本地仓库的情况下，可直接点击Add添加\nsourcetree会检测出来这是一个git仓库\n\n3.提交代码回到主界面，这里会出现你的仓库push历史，以及操作的日期\n如果你的本地仓库里面做出了更改，和网络仓库不一致的时候，软件内会在第一行显示有未提交的更改\n\n点击文件状态，这里会显示你本地仓库的那些文件做出了更改\n\n未暂存文件：本地文件做出了更改，但并没有确认\n已暂存文件：保存了本地文件的副本，等待push到远程仓库\n底部白框：填写push说明\n\n\n依照下图操作即可\n\n如果你不选择“立即推送变更，就需要在左上角的“推送”选项内进行二次操作，才会上传到远程仓库\n\n\n如果你之前没有使用过git，在这一步点击提交之后，会弹出一个框让你填写你的账号密码\n填写对应网络仓库（gitee&#x2F;github）的账号密码即可！\n\n用户名：填写注册邮箱\n\n\n由于本人已经填写过，且不知为何无法在账户&#x2F;web凭据中找到并删除它，故无法复现这一步\n\n所以我帮同学也弄了一个gitee账户，顺便嫖来了这张填写账户密码的截图\n\n填写完账户密码后，sourcetree就开始上传你的代码了！\n\n如果上传错误，这里会显示对于的git报错信息，根据报错信息百度查找解决方案即可！\n\n\n上传成功后回到History界面，可以看到我们最新的提交\n\n刷新网络仓库页面，可以看到推送成功了！\n\n这2个月的使用下来，只要sourcetree在上传的时候没有报错，那代码是铁定上传成功了。\n无需打开网络仓库再确认一下，还是挺方便的！\n\n如果你的本地仓库并没有做出更改，打开文件状态栏目的时候会显示“没有什么可提交的”\n\n\n\n4.回滚提交git最重要的一个功能，就是保存我们代码的历史版本\n如果你最新push的代码中写了一堆bug，或者不小心删掉了一些代码，就可以在git里面找到你的历史版本\n在sourcetree的主界面中，右键一个之前的提交信息，可以看到两个选项\n\n这两个选项的区别，简单描述如下：\n\n回滚：将改动的代码提交到本地仓库，但未推送到远端仓库的时候\n重置当前分支到此次提交：将改动的代码提交到本地仓库后，并已推送到远端仓库的时候\n\n具体的区别及操作方法，大家可以参考这篇博客👇\n\nsourceTree回滚提交和重置当前分支到此次提交的区别\n\n重置分支演示在这里我简单演示一次重置分支的方法\n假设我们不小心删除了本地文件里面的代码\n\n比如想复制其他代码到此文件，却在复制的时候ctrl+a全选，覆盖了之前的代码\n\n\n而在提交代码的时候，我们又忘记检查，直接上传到了远程仓库\n\n\n这时候，就可以选择我们上一次的push，选择重置当前分支到此次提交\n这里会出现3个选项，我们可以选择最后一个“强行合并”\n\n确认后，打开之前被我们删除了内容的代码文件，发现删除了的代码已经回来了！\n\n由于之前的更改已经提交到了远程桌面，sourcetree发现本地仓库落后于远程仓库，需要我们进行拉取操作\n但拉取之后，我们错误的更改就又回来了，这并非我们的目的\n这时候可以在souretree工具-选项中开启git的强制推送\n\n注：强制推送具有风险，建议提前备份分支内容\n\n\n选择我们重置的分支，并选择推送\n\n勾选上左下角的强制推送\n\nsourcetree会开始上传，上传完毕后，可以看到，之前的那次推送已经消失了！\n\n打开gitee检查一下，可以看到这里显示了“强制推送”\n\n找到我们之前更改过的那个文件，发现它已经回到了我们删除之前的内容\n\n我们的目的也就完美达成了！\n\n还是建议大家上传的时候多多检查，之前我就干过一次这样的蠢事。\n第二次编写那个文件的时候，才发现之前的代码无了。还好可以回退版本！\n\n\n结语个人理解，Sourcetree相比TortoiseGit，最大的优点就是它的界面更美观！\n\n还有另外一个我很喜欢的点：使用sourcetree不会让你的右键菜单多一堆选项！\n\n使用什么样的工具是大家各自的选择，一起进步才是我们共同的目的！加油😋\n\n如果有说的不明白的地方，欢迎在评论区提出！\n\n","categories":["差生文具多"],"tags":["git"]},{"title":"【教程】Typora+PicGo+又拍云uss搭建博客图床","url":"/posts/3648256488/","content":"Typora+PicGo+又拍云UOS搭建博客图床\n\n\n1.又拍云uos配置1.1 创建进入控制台后，点击云存储，创建云存储服务。配置你的服务名称，操作员名称，和操作员的权限。\n请保存操作员的密码，后续配置picgo用得到\n\n1.2 加速域名点击如下图齿轮进入配置页面\n\n在下图绑定你的域名（需要已备案域名）\n\n1.3 https随后在下图所示处配置域名的证书。如果你没有ssl证书，可以在又拍云的控制台主页申请一个免费的let’s encrpy证书\n\n1.4 访问控制在访问控制里面可以配置各种形式的控制。\n对于博客图床而言，referer防盗链是一定要打开的，其余根据自己的需求进行配置\nIP黑白名单 # 白名单：允许的ip,黑名单：不允许的ip# 如果发现某一个ip的请求次数过多，有恶意请求嫌疑，可以暂时将这个ip设置为黑名单CORS 跨域共享 # 参考http://ruanyifeng.com/blog/2016/04/cors.html地区访问限制 # 禁止或允许特定地区的限制Referer 防盗链 # 重点，建议开启白名单，只将自己的域名添加到白名单中（建议开启）User-Agent 防盗链 # 限制只有某种类型的客户端、浏览器可以访问资源Token 防盗链 # 有些麻烦，请自行了解。对于静态博客而言，并不方便回源鉴权 # 如果源站服务器有鉴权操作，可以在这里配置IP 访问限制 # 对单个ip的请求速率进行限制（建议开启）CC 防护 # 防护cc攻击WAF 保护 # Web Application Firewall\n\n2.picgo配置相比于阿里云oss，这里的picgo配置就挺明了了\n\n在picgo的上传区测试一下是否能正常上传\n3.typoratypora的偏好设置中，图像一栏选择上传图片，勾选如下几项。\n上传服务设置为picgo(app)，路径填写为你picgo的安装路径。\n\n随后点击左下角验证图片上传，出现如下所示代表配置成功\n\n此时我们的图床就已经配置好了\n","categories":["差生文具多"],"tags":["图床","typora"]},{"title":"【Picgo】正确重命名文件，避免重复上传","url":"/posts/373497921/","content":"picgo正确设置重命名文件，避免同文件重复上传\n\n\n1.问题来源在之前配置picgo+阿里云oss图床的博客中，我提到了需要开启picgo的时间戳重命名功能，以避免同名文件冲突。\n\n阿里云OSS默认策略：同名文件会被覆盖\n\n现在看来，这个方法还是有一个缺点：那就是没有办法避免同一个文件的多次上传\n说白了就是，我有一个图片，结果因为自己不小心多复制了几次，导致picgo多次上传了这个文件。再加上时间戳不同，之前上传的图片并不会被覆盖，而是留在那儿无人问津；\n亦或者是开启了typora下图中对于网络位置的图片应用上述规则，同一个图片需要在一篇文章中出现两次，复制的时候，因为开启了该策略，typora自动帮你又上传了一遍；\n\n1.1 说明阿里云OSS的空间是要付费的！对于个人博客图床而言，或许并不需要多少空间（本人使用阿里云OSS做图床已有1年，才用了980mb）\n今天为了迁移其中一个bucket，发现了里面有非常非常多的重复文件，文件大小内容完全一致，这就是无意义的空间浪费，对于容量计费的oss来说，这可都是💴啊！\n所以我们需要一个标识文件的方法，避免同一个文件的多次上传。\n比较好的办法，那就是用文件的hash值来命名这个文件。此时，同一文件的hash值是一样的，上传到oss里面之后会直接覆盖，并不会多占用一份空间！我们的目的也就达到了\n2.使用picgo插件解决\n插件开源地址 liuwave&#x2F;picgo-plugin-rename-file\n\n2.1 安装我的picgo是2.3.1版本的，能直接在插件市场安装\n\n安装好了之后，在这里配置\n\n2.2 配置遵循仓库readme里面的配置方法\n\n这里我选择了比较简单的配置方法，年+月+哈希值\n&#123;y&#125;/&#123;m&#125;/&#123;hash&#125;\n\n这么做是为了避免hash值碰撞，虽然同一人能人工弄出两个hash碰撞的图片的可能性及其低，但加上一个年份和月份，可能性就更低了😂\n这样就能保证在同一月上传的图片中，如果有相同图片会直接覆盖，不会多占用一份空间。\n\n至于其他选项，参考文档。个人觉得没有太大必要，毕竟都上传到图床了，谁还管这个文件的原名和本地存储路径是什么呢？\n\n3.收工设置完毕之后，现在上传的图片命名格式如下\n20234d48b94bd1054488005eb239741c807d.png\n\n再次手动上传一遍这个文件，发现返回的url是相同的\n我们的目的就达到了！\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【Typora+Lsky】在deepin使用YGXB-net/lsky-upload上传图片","url":"/posts/4106816943/","content":"在win和deepin上使用lsky-upload上传图片\n\n\n1.说明先前使用lsky图床的时候，我一直用的是picgo的插件来上传图片。\n但最近picgo总是遇到卡上传的问题 https://github.com/Molunerfinn/PicGo/issues/1060\n后来在gitee上面搜到了这个项目，其能将typora的图片上传到lsky，缺点就是只支持lsky图床。不过我正好要的就是这个！\nhttps://github.com/YGXB-net/lsky-upload/releases\n\n进releases下载作者build好的windows包，按作者的README进行操作，就能在windows下成功上传图片。\n经过了一天的使用，没有出现picgo的卡上传问题。开心！\n\n于是尝试在deepin下面也build一个go的包\n2.安装go环境和遇到的问题sudo apt-get install golang\n\nbuild的时候遇到了如下问题\nmothra@mothra-PC: ~/Downloads/lsky-upload$ go buildinternal/config/config.go:4:2: package embed is not in GOROOT (/usr/lib/go-1.15/src/embed)\n\n百度到的解决办法说要修改一个go的环境变量\nmothra@mothra-PC:~/Downloads/lsky-upload$ go env -w GO111MODULE=offmothra@mothra-PC:~/Downloads/lsky-upload$ go installmain.go:7:2: cannot find package &quot;github.com/tidwall/gjson&quot; in any of:        /usr/lib/go-1.15/src/github.com/tidwall/gjson (from $GOROOT)        /home/mothra/go/src/github.com/tidwall/gjson (from $GOPATH)main.go:9:2: cannot find package &quot;lsky-upload/internal/config&quot; in any of:        /usr/lib/go-1.15/src/lsky-upload/internal/config (from $GOROOT)        /home/mothra/go/src/lsky-upload/internal/config (from $GOPATH)main.go:10:2: cannot find package &quot;lsky-upload/internal/httpapi&quot; in any of:        /usr/lib/go-1.15/src/lsky-upload/internal/httpapi (from $GOROOT)        /home/mothra/go/src/lsky-upload/internal/httpapi (from $GOPATH)main.go:11:2: cannot find package &quot;lsky-upload/internal/utils&quot; in any of:        /usr/lib/go-1.15/src/lsky-upload/internal/utils (from $GOROOT)        /home/mothra/go/src/lsky-upload/internal/utils (from $GOPATH)\n\n但修改了之后问题更多了……来来回回搞了半小时，没解决\n3.解决构建问题看了一堆没用的博客，说要改环境变量，配置项什么的……最终还是字最少的最有用。其实就是我的go版本太低了，更新一下新版本就行了\nhttps://blog.csdn.net/qq_35633748/article/details/129436192\n\n我在deepin下的go是用apt-get安装的，版本是1.15，而最新版已经是1.20.4了\nhttps://golang.google.cn/dl/\n\n去这上面下载了linux下的安装包\nwget https://golang.google.cn/dl/go1.20.4.linux-amd64.tar.gz\n\n操作之前，先将旧的golang给卸载了\nsudo apt-get remove golangsudo apt autoremove\n\n输出结果如下\n~/Downloads$ sudo apt-get remove golang请输入密码:验证成功正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       软件包 golang 未安装，所以不会被卸载下列软件包是自动安装的并且现在不需要了：  golang-1.15 golang-1.15-doc golang-1.15-go golang-1.15-src golang-doc golang-go golang-src使用&#x27;sudo apt autoremove&#x27;来卸载它(它们)。升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。~/Downloads$ sudo apt autoremove正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包将被【卸载】：进度：[ 93%] [#############################################################################################.......] 升级了 0 个软件包，新安装了 0 个软件包，要卸载 7 个软件包，有 0 个软件包未被升级。解压缩后将会空出 363 MB 的空间。您希望继续执行吗？ [Y/n] y\n\n卸载旧版本后，解压刚刚下载的新版本包\nsudo tar -C /usr/local -xzf go1.20.4.linux-amd64.tar.gz\n\n然后修改环境变量\nsudo vim /etc/profile\n\n在末尾添加，:wq保存并退出\nexport PATH=$PATH:/usr/local/go/bin\n\n但是不知道为什么source找不到命令，于是重启了机器（我用的虚拟机）\nsudo source /etc/profile\n\n$ sudo source /etc/profilesudo: source：找不到命令\n\n重启之后，看看版本\ngo version\n\n已经是最新的了\n$ go versiongo version go1.20.4 linux/amd64\n\n克隆作者的仓库\nhttps://github.com/YGXB-net/lsky-upload.git\n\n或者用gitee的\nhttps://gitee.com/YGXB-net/lsky-upload.git\n\n克隆后进入仓库路径\ncd lsky-upload\n\n进行构建\ngo build\n\n一切正常，不会有输出。ls -l查看文件，会多一个lsky-upload可执行文件\n-rwxr-xr-x 1 mothra mothra 8060493 5月   7 12:12 lsky-upload\n\n\n先执行一下这个文件，会有初始配置文件的输出。也是根据仓库的README配置成你的图床url和token就行了\n./lsky-upload\n\n4.配置typora这时候就只需要将typora的上传命令修改为这个可执行文件，就可以了！\n\nPS: deepin上的typora是我在deepin的软件商店里面下载的typora-免费版，版本是0.11.18\n\n\n点击验证测试一下能否正常上传，没问题！\n\n","categories":["差生文具多"],"tags":["图床","Typora"]},{"title":"【日志】又拍云CDN被恶意请求","url":"/posts/1758576550/","content":"自23.03.23起，图床CDN遭到了持续一周的恶意请求！\n\n\n说明请求来自同一个ip，请求的是同一张图片，每秒请求约15次，高峰期都是在凌晨，白天每秒也只请求4次（怕不是白天要用电脑，给爬虫限流……），最终导致日请求量上了100w，日均扣费4元😒\n在我禁掉他的移动ip后，他换了另外一个电信的ip继续请求同一张图片。\n因为两个ip的属地相同，都是家宽，无法被ping，所以我认为是同一个人！\n我发现的已经有点晚了，对方已经恶意请求了将近一周。虽然又拍云OSS配置了IP访问限制，但咨询了客服后，得知即便被403挡掉的请求（在日志中，一个小时就有4w个请求被403阻止），依旧会计入https费用。\n在此提醒大家，又拍云的日扣费提醒最低只能设置为10元，建议隔1-2天上控制台查看一下统计信息，及时发现并阻止对方的恶意请求\n几种反制策略1. 禁止他的ip2. 删除源站图片，清空cdn缓存，将原有url配置444访问规则（见下方截图）3. 严重的时候直接关闭CDN的域名解析\n\n截图下图中请求迅速降低是因为我关闭了该cdn的域名解析\n\n昨天上午就请求了44w次，3.28一整天请求了101w次\n\n扣费，心疼啊！\n\n个人觉得https请求如果被403了还进行相同价格的扣费是不太合理的（\n\n\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【七牛云】artalk表情遇到跨域访问问题","url":"/posts/489538601/","content":"如题，当我在我自己编写的文档站点 https://khl-py.eu.org/ 访问我的artalk服务时，其中包含一个artalk表情的请求，被浏览器的跨域策略给挡住了。这会导致artalk评论中无法发送表情（虽然无伤大雅）\nAccess to fetch at &#x27;https://img.musnow.top/i/artalk-emoji.json&#x27; from origin &#x27;https://khl-py.eu.org&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. If an opaque response serves your needs, set the request&#x27;s mode to &#x27;no-cors&#x27; to fetch the resource with CORS disabled.\n\n百度了一下，我们需要在七牛云的CDN策略中进行配置（我的七牛云KODO是绑定到CDN上，通过CDN进行访问的）\n找到CDN界面中的HTTP响应头配置\n\n点击修改配置，添加如下两点\n\n保存后过一会，就不会出现这个跨域访问问题了。至于这部分设置会不会导致有人盗刷你的CDN流量，仍待更多的观察。\n另外，如果你的CDN还开启了防盗链，还需要把对应域名填入防盗链的白名单中！\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【win】windows磁盘管理分区,实现整数容量","url":"/posts/2962575673/","content":"windows磁盘管理分盘分出整数容量\n\n\n1.问题不知道各位在使用windows电脑分区的时候，有没有遇到一个抓狂的问题：那就是windows的分区总是分不出整数！\n不是299.9gb，就是300.1gb\n对于强迫症而言，看着那多出来的小数点，别提有多难受了！\n\n2.解决于是，我就百度了一下，到底要怎么设置分区的容量，才能让它分出一个整数gb的盘来？\n最后，我查到了下面这个办法\n想要整数GB的分区，只需要在原数字上+1就行了N*1024+1\n\n比如，我想要把c盘分出去70GB作为数据盘，那我应该在windows磁盘管理压缩卷里设置的数字如下\n70*1024+1\n\n看，完美的70gb，强迫症有救了！\n\n\n关注本寒舍，分享更多windows电脑使用的小tips！\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【图床】gitee图床寄了，批量转存文件到阿里云OSS","url":"/posts/2474096396/","content":"本篇博客将教您如何转移gitee图床到阿里云OSS\n\n\n\nGitee的问题最近不知道大家的gitee图床是否出现了抽风现象\n简单的说来就是，gitee仓库里面的图片都能正常访问，picgo也能正常上传\n但是本地typora&#x2F;obsidian都无法渲染出图片，甚至出现了图片全变成了gitee的logo的情况\n\n虽然不知道它现在恢复没有（因为我已经全部转移到阿里云OSS了），但还是建议大家不要用gitee作为图床了！因为我之前使用的时候就出现了好几次无法渲染图片的情况\n\n当时我去问了一个大佬，大佬的回复是：“不提倡用代码仓库做图床”\n\n在我的另外一篇博客里面也提到了这个问题\n\n阿里云OSS我已经用了3个月了，它比gitee稳定很多，目前没有遇到过无法加载图片的问题。\n\n下面给大家提一个gitee转阿里云图床的解决方案，理论上来说这个方案是所有图床都能通用的\nGitee批量转阿里云OSS\n思路来自于CSDN用户@1nnoh\n\n1.配置阿里云OSS既然要转阿里云图床，第一步肯定是配置图床了\n这个我之前写过博客，比较详细，大家直接点击下面的链接阅读即可！\n\nTypora+PicGo+阿里云OSS搭建博客图床（超详细）\n\n\n2.批量上传将gitee的图床仓库全部下载下来\n\n建议把图片文件夹打包备份一下，以免出现问题\n以下是我之前作为图床的代码仓库，图片全部存放在img文件夹里面\n\n你可以在阿里云OSS的bucket里面创建一个同名文件夹（不同名也没关系）\n然后把这些图片都上传进去\n\n阿里云oss支持多文件上传，建议大家在已有bucket中创建一个新文件夹，避免出现覆盖bucket已有文件的情况\n\n如果是新bucket，随便创一个文件夹就OK了，之前的博客里面都有提到\n\n\n在配置阿里云OSS的教程中，我建议大家打开picgo的时间戳重命名，因为这个可以防止同名文件的冲突\n\n不管你有没有开启这个功能，都不影响后续的操作（没开的建议开一下）\n3.比较链接区别上传完毕后，我们来比较一下阿里云和gitee的链接差别\n\n你的链接可能和我的不同，请以实际为准\n\n# giteehttps://gitee.com/你的gitee名/仓库名/raw/master/文件夹名字/202108160849879.png# 阿里云osshttps://你的bucket名字.oss-cn-地域.aliyuncs.com/bucket下文件夹的名字/202108160849879.png\n\n可以发现，其实gitee和阿里云OSS的链接都是以图片的文件名结尾的\n也就是说，我们只需要扫描我们本地的md文件，将原本gitee图床链接的前面部分，整体替换成阿里云链接就可以了！\n即：将gitee链接\nhttps://gitee.com/你的gitee名/仓库名/raw/master/文件夹名字/\n\n替换成\nhttps://你的bucket名字.oss-cn-地域.aliyuncs.com/bucket下文件夹的名字/\n\n后面的文件名无需更改\n\n4.批量修改\n我们需要用到文本编辑神器notepad++\n这个工具非常实用，除了可以修改文件编码格式外，还可以完成批量查找文件内容等很多事情，本文的情况就可以用它来完成\n\n打开notepad++后，在顶部的搜索按钮中，选择在文件中查找，然后选择你的markdown文件路径\n\n打开这个面板后，想必已经不需要我教你怎么修改了吧？😂\n再次提示，修改前请先备份一遍你的文件！\n\n\n你还可以用VSC来批量修改文件中的内容参考软通达的博客👉https://cyddgh.github.io/post/20220304175458/\n\n\nThe end到这里，操作就完成了，不出意外的话，所有的链接都被替换了\n你可以愉快地继续使用阿里云OSS作为你的图床了！\n\n如果这对你有帮助，还请在下方评论说一下哦！\n\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【MD】用Obisidian的你一定不能忽略的图片保存问题","url":"/posts/4288058497/","content":"[TOC]\n问题来源😥今天在obsidian使用kanban插件的时候，发现obsidian其实是可以把插入的图片自动保存在本地库文件夹里面的。\n\n这一点其实非常重要！\n之前我从gitee图床转到阿里云OSS，最大的原因就是上学期期末复习高数的时候，自己写的高数笔记里的图，因为gitee的短暂更新导致无法加载！最后过了差不多1h图片才能正常加载出来，相当于白白浪费复习时间！\n\nTypora+PicGo+阿里云OSS搭建博客图床\n\n你想想，这还是在学校里，耽误点时间总归不会出现什么“要人命”的大事。但如果是工作中你写的一些日志笔记，因为图床网站的无法访问而暂时看不见，那不就寄了吗？\n更别提图床是保存在网络中的，总归会有些隐私问题。就连百度网盘都扫用户文件，我们用户又怎能知道阿里云有没有干这种事呢？\n\n如何解决？🕵️‍♂️1.typora设置图片保存查找网络资料，看到了这篇博客\n\ntypora设置图片根目录_用Obsidian一定要注意的图片和笔记问题！\n\n里面讲到了可以用typora来解决这个问题\n打开typora左上角的文件-偏好设置\n依照下图设置\n\n可以看到，复制进去的这个图片（其实就是上面这个截图）显示出了它的相对路径，并正常渲染。\n\n打开本地文件夹，可以看到typora在你当前这个md文件的目录下创建了一个photo文件夹，将你贴的图复制进了这个文件夹中\n\n\n同时如果我们在obsidian打开这个md文件，可以看到图片是能正常显示出来的\n\n到这里，其实我们的问题已经解决了！\n\n2.博客问题但是！这好像和我们当初使用图床的目标冲突\n再来看看下面这个图片，当我把这篇博客从typora复制到CSDN上的时候，它肯定会保存失败\n\n\n\n因为图片本身是在本地硬盘里，CSDN无法原力读取你硬盘里的文件，自然无法转存这张图片了！\n解决这个问题又有两个新的方法~\n2.1 每次编写不同文件的时候，进typora设置进行更改当我写博客的时候，typora需要这样设置，即可借助picgo自动上传我复制进去的图片到图床里，也能正常复制到CSDN中（教程在博客开头的链接里）\n\n而当我写个人随笔/日记/学习笔记这类并不打算上传到博客里的内容时，就可以把它改成上面提到的本地存储方式\n但是这样非常不方便！万一哪一次写博客的时候忘记改回来了，上传博客的时候就想马良了（我是觉得我肯定会忘，这个亏吃不得）\n\n2.2 分开两个软件进行写作别急，刚开头不是提到了，我是在obsidian里面发现这个功能的嘛？\n现在我们要做的，就是将obsidian也设置为同样的保存方式，让复制进去的图片自动保存在本地目录里。\n这样用typora写博客，obsidian写自己的东西，两全其美！\n\n3.obsidian设置图片保存在1.typora方式提到的那篇博客里面，作者发现了obsidian复制图片的时候使用的是自己的格式![[  ]]\n这种格式并不是所有markdown编辑器都认识！\n\n所以我们需要更改obsidian的设置，让它变成大部分markdown编辑器通用的![ ]( )形式\n\n先看看你的obsidian用的是不是最新版本0.13.33，如果不是，先更新一下\n\n\n打开obsidian设置-文件与链接，找到下图的这几个设置。如果你没有更改过，默认的设置和图片里面应该是一样的\n\n我们需要改成以下的样子\n\n再次尝试插入图片，可以看到新插入的这个图片已经变成了md通用的![ ]( )形式\n\n再次用typora打开这个文件，可以看到第一个图片链接依旧不认识，但是第二个图片已经被正常加载出来了！\n\nobsidian的设置也搞定了！\n今后写作的时候，就可以分开两个软件进行写不同的内容啦！\n\n一些提升obsidian编辑体验的插件最后，你可能会想，obsidian的使用体验没有typora好呀！\n\ntypora可以实时渲染，obsidian需要单独切换\ntypora有打字机模式，obsidian需要滚来滚去\n\n欸，别急，这里给大家推荐几个提升写作体验的插件，装了之后，上面这俩功能就都有啦！\n\n\n更新：发现这个功能其实obsidian已经自带了，但是我在编辑器中选择了旧版编辑器导致没看到这个功能。既然自带了就没必要下插件啦！但是问题又来了，下面这个打字机插件只有旧版编辑器才有效。如果你需要这个模式，那就使用上面的渲染插件+这个打字机插件来创作吧（本人现在就是这么做的）你觉得事情真的有那么简单吗？并不是的！更新了打字机插件到0.2.1以后，发现他已经支持了新版本编辑器了，芜湖起飞！\n\n下面还有picgo上传图床的插件\n以及一个自动粘贴链接的插件\n\n\n最后还有这个插件，可以优化obsidian选中中文句子的分词功能\n\n安装完这些，使用体验就很接近typora啦！\n当然我还是更喜欢用typora来编辑\n\n结语😋依照这篇博客设置完后，就能更好地分开写作 私人内容和博客文件啦\n以后也可以放心地往md文件中加图片了，毕竟在本地里，谁都看不到\n\n不过也要考虑到本地文件大小问题，别把你的OneDrive塞满图片导致空间不够用了。那就得掏💴升级容量了，我现在只有免费的5GB\n有些图片可以考虑用光影魔术手等软件来减小文件体积，比如手机拍的笔记图，没必要那么高清，6mb降到500kb都还能看清楚\n\n你学废了吗？\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["差生文具多"],"tags":["图床","typora","obsidian"]},{"title":"【数据备份】谈谈如何进行有效数据备份，3+2+1","url":"/posts/3543423459/","content":"谈谈如何进行有效数据备份，以及什么是3+2+1\n\n\n前言数据备份已经是一个老生常谈的问题了\n今天在群里看到一位群友就出现了数据丢失的问题，两次跳闸后，台式机的固态硬盘无法被识别，在bios中看不到，群友说自己换了电脑依旧识别不出来（可以确定是固态挂了）\n\n于是就有了写这篇博客的想法，来谈谈我对数据备份的看法以及简单的做法\n数据只有丢了才会知道珍惜，请不要在丢了重要数据的时候后悔。\n工作文件、学习资料（严肃正经的）、家庭照片等信息，还有一切你觉得多少有点价值，想留下来的资源。\n\n说句题外话，小时候的我不喜欢拍照，可长大了，发现自己小时候半点照片都没有。脑海里对儿时的记忆，也早已模糊。上了大学之后，我拍照虽然依旧不多，但总归还是比儿时多了几倍。老了之后，这些东西就是你一辈子的回忆了。\n\n须知在备份前，我们首先需要知道的事情如下\n\n任何硬盘都有自我嗝屁（指在正常工况下他就坏了）的风险，不要认为自己买了个很贵的品牌固态硬盘就可以高枕无忧了\n同样，便宜的固态硬盘也不一定很容易坏，在重视数据备份的同时，也没必要提心吊胆\n固态硬盘由于其物理结构和设计原理，数据恢复的可能性极低。如果你的固态硬盘坏了，那就当数据全丢了处理。\n不要存有数据坏了可以去数据恢复的侥幸心理。即便最终可以数据恢复出来，成本比你多买几个硬盘高多了（这位群友去问了，数据恢复要800-1600，这个价格都可以买6t的固态硬盘/16t的机械硬盘了）\n\n\n什么是3+2+1备份你可能在别处看到有人提到这个名词：3+2+1备份原则\n\n三个存储设备（一份数据在3块不同的硬盘中存放）\n两个不同主机（这三块硬盘中，至少要有2块是位于不同主机上的）\n一个异地备份（数据要在异地备份一份，比如你家里着火了设备全挂了，那么异地的备份就有用了）\n\n前面两个条件，如果家里有两个电脑的用户还能勉强达成，最后一个条件可能很多人就没办法达成了\n但这并不重要，我们眼前就有一个最简单易用的异地备份介质——网盘\n最简单的做法手机电脑各一份对于普通用户来说，备份重要数据的最简单办法，那就是将重要数据往手机和电脑各拷贝一份；\n如果你有两台电脑，那就在两台电脑上都拷贝一份，这样就已经满足了3+2+1中的2了；\n单个电脑多硬盘同步如果你的电脑有多个硬盘（一定要是物理硬盘，而不是你Windows里面的磁盘分区）\n建议将重要数据在两个硬盘中都存一份！\n这里推荐一个特别好用的同步软件freefilesync，下载地址\n\n界面使用很简单，左侧和右侧分别设置文件夹，右上角的绿色齿轮里面可以设置同步的类型为更新、镜像，还有带版本管理的同步方式。除了设置本地，还支持google drive和frp，你也可以把nas的硬盘通过smb或webdav映射为本地硬盘，使用此软件进行同步\n和这个软件一起的还有个红色图标的实时同步，在绿色软件里面配置好了之后，将配置文件导入这个红色软件，设置监看间隔，就能做到数据的实时同步。\n\n\n完整使用教学可以查看这个B站视频：【14001】FreeFileSync：差异同步、镜像备份、增量备份 全能的同步软件 文件同步 本地同步\n\n\n比如一份数据，你可以以某块固态为主力，然后将软件的同步模式改成镜像（同步删改）到另外一个硬盘里面。这样两边的数据就能保持一致了。就算一个硬盘坏了，另外一个硬盘还能祝你一臂之力。\n要知道，除非你的电脑主板挂了，或者你买的电源有点劣质（这里也提醒一下，省什么钱都不要省电源，买个相对大瓦数的品牌电源，比如振华或者海韵，比某些淘宝的低价烂货好的多），不然两个硬盘一起挂的概率是极低极低的，远远低于一个硬盘坏掉的概率。\n网盘除了在本地备份，特别特别特别重要的数据也强烈建议在云盘也存一份\n主流的云盘：百度云盘，阿里云盘。如果你注册的比较早，容量应该都是上T了的，对于家用备份来说完全够用了。\n虽然云盘的下载都限速，前期宣传不限速的阿里，现在也只能跑3mb的下载了（不过还是比百度好多了）；一般上传都是不限速的，如果真的有需要了，大不了开个会员下回来，总比数据救援的要价靠谱。\n将重要数据打个压缩包，必要的时候设置个密码（防止被网盘误封），如果你担心忘记压缩包密码，可以直接找个文件名改成密码，一起丢到压缩包里面。这里我们要防止的是网盘的AI误封你的文件，而不是保障数据安全。\n\n什么时候想起来就弄一下，根据你对数据重要性的敏感度来决定备份频率吧！\n\n网盘和隐私？https://zhuanlan.zhihu.com/p/94763454\n虽然很多人说网盘不安全容易泄漏什么的，但实际上哪怕是天天被骂的百度网盘也并没有出现过主动泄漏用户文件的情况；\n很多时候都是一些不会用软件的人，启用了自动备份功能，还把自动备份的文件夹开了分享，甚至直接把分享链接发网上，导致有些爬虫机器人把你的分享链接给收集起来了。后续你的东西肯定被人家看光喽。\n隐私的守护权始终是在你自己手上，在分享文件的时候，请仔细检查文件里面的东西是不是完全和你自己的隐私没有关系，最好的分享是只分享文件，而不要分享文件夹（因为对这个文件夹的后续修改，原有的那个分享链接都能看得到），别到时候分享一个盗版游戏顺便把自己身份证的照片也分享给别人了。\n现在网盘的用户页面都能看到自己的分享链接，时不时去检查一下，把过时的、不需要的分享链接给他们删掉。\n\n如果有些资源你不希望被网盘ban掉，还有个小办法是将资源压缩了之后，放入另外一个文件夹，在文件夹里面随便丢几个文件来混淆视听（主要是为了让你这个压缩包的md5和其他相同资源的压缩包不一样）再加上解压密码，能大大减小被ban的概率！\n另外，请一定不要在任何网盘软件里面使用在线解压功能，他会记录你解压密码然后去算内部文件的md5，然后给你ban掉。（逛贴吧的时候看到过这种情况，属实无语）\n\nNASnas说白了就是另外一台小电脑，只不过这台电脑上有很多硬盘位，其主要的目标就是管理硬盘里面的文件，方便我们将其他设备的数据备份上去。\n既然谈到备份，那就顺便说说什么时候你需要买一台nas吧？\n首先要说明的是，nas本身已经不贵了。尝鲜款可以买海康的h99pro，有基础的nas管理功能。一般日用可以买海康的mega20，双盘位的价格是500（PDD）要知道，这个价格已经比某些硬盘柜都便宜了；\n先不要管nas附属的docker等功能，这些功能海康是没有的。但NAS本身要做到的其实只是存储，在数据备份这点，海康的NAS是完全够用的！\n\n我当初买nas的原由是：方便下好电电影在手机上看；电脑看屏幕大确实爽，但远没有躺着看舒服😂\n\nnas这东西，特别是带docker的nas基本都上1k了，其本身的价格已经能顶上多年的网盘会员了。更别提nas在家里面的访问速度绝对不会有网盘会员快，除非你家能弄到ipv4的公网IP（要折腾很多东西的，很麻烦）\n\n什么是带docker的nas？简单来说就是docker可以理解为是nas上的一个软件商店，我们可以利用各种开源的docker软件，来实现资源下载、文件管理、照片管理、在线看视频等等的功能。\n而没有docker的nas只能局限于厂家给你提供的基本功能。而且那些不带docker的nas的系统大概率是不会有什么好的功能性升级的。能给你推个修系统bug的更新都谢天谢地了。毕竟还是一分钱一分货的。\n\n如果你只是为了数据备份，完全可以不用买nas。给自己电脑加个硬盘、或者买个移动硬盘来冷备份，都是更好的选择。甚至网盘开个多年会员，自己手动备份内容到云盘都会比nas的维护更加方便。\n但如果想尝试附属的影音管理、资源下载、远程开发等功能，或者像我一样宁愿数据在自己的本地存也不想丢网盘的话，那就可以在自己经济条件允许的情况下买个带docker的nas，来备份数据、下点资源什么的。\nThe end就说这么多吧，希望对你有帮助。不过应该没人看，大概率只是我自己碎碎念（阿巴阿巴阿巴）\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【win】Windows下MSI Afterburner如何让其不在某个软件中显示帧数","url":"/posts/4160666395/","content":"Windows下MSI Afterburner如何让其不在某个软件中显示帧数\n\n\n1.问题说明总所周知，MSI Afterburner这个软件可以在游戏里面展示你当前电脑的各项生命体征，包括GPU&#x2F;CPU功耗频率温度，内存占用，当前帧数等等数据，不管是用来监看电脑运行是否正常，还是用来小超一下显卡，都是很好用的东西，再加上毫无广告+免费，几乎是人手必备的PC良药\n\n但总有时候这个软件会抽风，比如我的电脑里面，最新版本的这个软件，就会把照片莫名其妙的也识别成了一个游戏，在里面显示帧数，最离谱的是，最下方的预览其他图片的小框框里面，也给你显示了帧数\n\n这肯定很恼火，我们要怎么样才能让他不在这里面显示呢？\n2.配置和MSI Afterburner捆绑下载的有这么一个软件，其实它才是负责将数据投屏到你的屏幕上的软件，在这里面，我们就可以设置在某个软件中不显示帧数\n\n对于正常安装的软件，我们都可以找到软件的安装路径，选中它的exe可执行文件，再设置一下把帧数器关闭，就可以避免错误地显示帧数影响软件自身的使用\n\n但是windows自带的相册就有点恼火了，我们压根不知道它的可执行文件在哪里！\n3.windows系统应用的可执行文件windows绝大部分的系统自带软件都在这里面，你需要打开显示隐藏文件夹才能看到此文件夹\nC:\\Program Files\\WindowsApps\\\n\n而照片软件路径如下（我的win11版本是22H2 22621.963）\nC:\\Program Files\\WindowsApps\\Microsoft.Windows.Photos_2023.11080.4003.0_x64__8wekyb3d8bbwe\n\n这里面有一个PhotosApp.exe，就是windows自带照片的可执行文件了；\n但是！你会发现你压根没有 C:\\Program Files\\WindowsApps\\这个文件夹的进入权限，更别提找到这个照片软件的exe了！\n百度了一下，找到了一个教程 Win10下WindowsApps权限怎么获取；顺带一提，为了避免原文失效，这篇文章也转载到了本站。\n\n注意！毕竟这算是系统底层文件夹了，我不确定这样修改文件夹权限是否会出现问题！如果你担心出现问题，请不要操作，在不打游戏的时候不要启动MSI Afterbuner是更好的选择！\n如果出现问题，参考 【WindowsApps 权限问题导致Microsoft Store及其下载的应用不能启动（闪退）的解决办法】 复原权限！实在不行就恐怕要重装系统了 🤣\n\n目前我这边还么有出现异常情况，毕竟我修改为了everyone理论上来说是并不会出现权限不够而导致某个程序无法执行的问题的\n\n根据教程里面的步骤一步一步来，就可以获取到这个文件夹的进入权限\n\n4.禁用照片中的帧数显示找到这个PhotosApp.exe之后，在RivaTuner这个软件里面选中这个可执行文件，将其的display关闭\n\n好了，这下没有胡乱显示帧数了！\n\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【win】Windows下C盘里面的WindowsApps文件夹权限怎么获取","url":"/posts/3712817486/","content":"避免原文失效，转载此文\n原文 https://www.bkqs.com.cn/content/kn928o443.html\n\n\n\nWin下WindowsApps权限怎么获取2023-01-31 14:32:17\nWin10下WindowsApps权限怎么获取？WindowsApps安装的是Windows应用商店的应用程序，访问此文件夹需要获取权限才能进入。具体怎么设置呢？一起来了解下吧！\n\n操作方法\n01\n1、在计算机中，打开此电脑。点击查看选项，并勾选选项框中的“隐藏的项目”。如图所示；\n\n\n02\n2、在此电脑窗口中，找到系统盘下的“WindowsApps”（隐藏的文件夹），具体路径为“C:\\Program Files\\WindowsApps”。如图所示；\n\n\n03\n3、选中WindowsApps文件夹，并点击鼠标右键，在弹出的选项框中点击“属性”选项。如图所示；\n\n\n04\n4、点击属性选项后，这个时候会打开“WindowsApps属性”对话框。如图所示；\n\n\n05\n5、在WindowsApps属性对话框中，切换到“安全”选项卡。如图所示；\n\n\n06\n6、在安全选项卡下，看到提示“必须具有读取权限才能查看对象属性”，并点击“高级”选项按钮。如图所示；\n\n\n07\n7、点击高级选项后，这个时候会打开“WindowsApps的高级安全设置”对话窗口。如图所示；\n\n\n08\n8、在WindowsApps的高级安全设置对话窗口中，点击所有者后的“更改”按钮。如图所示；\n\n\n09\n9、点击更改后，这个时候会打开“选择用户或组”对话框。如图所示；\n\n\n10\n10、在输入要选择的对象名称输入框中，输入“Everyone”，并点击“确定”按钮。如图所示；\n\n\n11\n11、点击确定后，这个时候会跳转到WindowsApps的高级安全设置对话窗口。如图所示；\n\n\n12\n12、接着勾选所有者下的“替换子容器和对象的所有者”，并点击“确定”按钮。如图所示；\n\n\n13\n13、点击确定后，这个时候会弹出Windows安全对话框，进行更改所有权。如图所示；\n\n\n14\n14、更改所有权完成后，这个时候就能正常访问“WindowsApps”文件夹了。如图所示；\n\n\n\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【win】windows初次开机和使用的注意事项","url":"/posts/1529306954/","content":"首次开机和使用一台windows电脑需要注意的那些事\n\n\n本文所言仅为本人个人观点，且只作为建议和图一乐的素材。电脑归根结底只是个工具，不同人使用习惯不同，按自己熟悉的来用即可。大可无需因为本文而改变你使用电脑的习惯。\n1.跳过联网windows11的年代，这已是一个过去式了，还是记录一下吧。\n给不知道的人说一下，大部分笔记本厂家的策略，都是windows激活之后，就不允许退款了。\n在windows10的时代，首次开机的时候，在联网阶段，会有一个跳过联网的选项，我们只需要选择这个选项，就能跳过联网，继续我们的验机过程。这样，发现了电脑有各种各样的的问题或者不满意，还能以电脑没有激活为筹码，直接七天无理由退货。\n可微软的阿三工程师不知道怎么想的，windows11一出来，直接把这个按钮干没了。\n起初，还能通过快捷键or命令行的方式，强行跳过联网，但现在，似乎都不行了。\n\n可能还有跳过联网的方式，但相比win10的一个按钮，显然任何方法都麻烦多了，对小白也不够友好\n\n哎，谁知道微软是怎么想的呢？\n2.用户名刚开始使用电脑的时候，电脑的用户名一定一定一定要设置成英文的！哪怕你设置成拼音或一串数字，都不要设置成非英文的其他语言！\n软件安装路径不要有中文虽然现在，大部分软件对中文的支持都足够友好，但依旧有部分软件（以游戏据多）不支持中文路径的安装目录！\n说人话就是，如果你想安装这些软件，它要求你的安装目录是全英文的\nC:\\Progarm Files\\test\\\n\n如果你的安装路径里面带有中文，可能安装不会报错，但是软件打不开、崩溃、报错误，一堆bug就来了\nC:\\Progarm Files\\你好\\\n\n为了避免这种bug，我们安装软件的时候，最好都要选择全英文的安装路径。\n多一事不如少一事。你可以赌对很多个支持中文路径的软件，但只要来一个你需要的而不支持中文安装路径软件，就足够让你抓狂。如果你使用的是某些小众软件，恐怕报错贴到百度上都查不到为什么。\n那这又和用户名有啥关系呢？windows在初始化的时候，会以你的用户名，在C盘如下路径创建一个文件夹\nC:\\Users\\用户名\n\n注意啊，虽然你打开文件管理器，会发现这个文件夹叫做用户，但实际上他还是英文的，显示为用户是微软对界面做的汉化处理而已。\n\n右键这个路径，选择将地址复制成文本，你就会发现用户是汉化处理了\nC:\\Users\\moth\n\n在用户文件夹下，除了会有一些软件的配置文件（如git、vscode、pip）还会有一个隐藏文件夹AppData，这里面存放了大部分软件的缓存文件，甚至有一些软件的安装路径就是在AppData里的！\n如果你的用户名设置成了中文，那很不幸，上面提到的软件安装路径不能有中文的大忌，你将不可避免地遇到了！\nC:\\Users\\慕雪\n\n因为软件会在你的用户目录下创建缓存文件夹，如果一个软件对中文的支持不好，那它就可能因此崩溃！\n在我周边的同学里面，就出现过不少个windows用户名是中文的\n\n好消息是，目前为止，我们专业学习需要的软件都支持中文路径\n坏消息是，这都大二下了，我们还没有学过一个专业课，还在学基础公共课……来大学快两年了，我还连自己的专业是干嘛的都不知道（事先为何不了解？问就是调剂来的！😒）所用的软件，也不过是编程ide罢了\n\n3.保持一个良好的文件存放习惯可笑的是，这件事，知道的人不需要你告诉他；不在乎的人你告诉他也没用。\n有太多太多的用户（包括我的父母）他们的电脑都中了一个病毒，导致整台电脑只有一个分区，叫做桌面\n\n并不是说文件丢桌面不可以，但是丢在桌面上有一个致命的问题：重装的时候，需要格式化C盘。\nwindows重装，是对付软件问题的最好方式。重装的时候，大概率是要格式C盘的，而桌面的文件就是存放在C盘上面的。\n\n虽然可以用PE来取走电脑中的数据，但这很麻烦！\n相比于微软官方的系统安装盘，PE盘安装系统更麻烦（个人在很久之前的体验，没有试过近期的PE，此言欠妥）\n\n所以，为了在电脑出奇怪的软件问题，快速重装让电脑恢复工作状态，最好的办法还是不要在C盘放任何数据文件！\n4.windows11右键菜单设置win11的右键菜单设计就是让人很无语的降级，也不知道开发者有没有自己用过系统。和不玩游戏的开发者和策划一样。\n恢复win10旧版命令（在windows11的命令行里面执行）\nreg.exe add &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\\InprocServer32&quot; /f\n\n重新启用新版：\nreg.exe delete &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;&quot; /f\n\n\n\n未完待续想起来啥了就给本文加点料\n","categories":["电脑使用小贴士"],"tags":["windows"]},{"title":"【npm】error:03000086:digital envelope routines::initialization error","url":"/posts/2800051647/","content":"error:03000086:digital envelope routines::initialization error 问题解决\n\n\n慕雪是在使用vuepress的时候遇到了这个错误。根据官方的描述，vuepress应该使用node.js 14版本即可，但我的电脑上是18.x。\n完整报错如下\nPS D:\\Git_repo\\hexo\\khl.py.docs&gt; npm run docs:dev &gt; docs:dev&gt; vuepress dev docswait Extracting site metadata...tip Apply theme @vuepress/theme-default ...tip Apply plugin container (i.e. &quot;vuepress-plugin-container&quot;) ...tip Apply plugin @vuepress/register-components (i.e. &quot;@vuepress/plugin-register-components&quot;) ...tip Apply plugin @vuepress/active-header-links (i.e. &quot;@vuepress/plugin-active-header-links&quot;) ...tip Apply plugin @vuepress/search (i.e. &quot;@vuepress/plugin-search&quot;) ...tip Apply plugin @vuepress/nprogress (i.e. &quot;@vuepress/plugin-nprogress&quot;) ...* Client █████████████████████████ building (40%) 1/2 modules 1 active node_modules\\webpack-dev-server\\client\\index.jsi ｢wds｣: Project is running at http://0.0.0.0:8081/i ｢wds｣: webpack output is served from /i ｢wds｣: Content not from webpack is served from D:\\Git_repo\\hexo\\khl.py.docs\\docs\\.vuepress\\publici ｢wds｣: 404s will fallback to /index.htmlnode:internal/crypto/hash:71  this[kHandle] = new _Hash(algorithm, xofLen);                  ^Error: error:0308010C:digital envelope routines::unsupported    at new Hash (node:internal/crypto/hash:71:19)    at Object.createHash (node:crypto:133:10)    at module.exports (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\util\\createHash.js:135:53)    at NormalModule._initBuildHash (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\NormalModule.js:417:16)            at handleParseError (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\NormalModule.js:471:10)    at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\NormalModule.js:503:5    at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\webpack\\lib\\NormalModule.js:358:12    at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\loader-runner\\lib\\LoaderRunner.js:373:3    at iterateNormalLoaders (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\loader-runner\\lib\\LoaderRunner.js:214:10)    at Array.&lt;anonymous&gt; (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\loader-runner\\lib\\LoaderRunner.js:205:4)    at Storage.finished (D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\enhanced-resolve\\lib\\CachedInputFileSystem.js:55:16)      at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\enhanced-resolve\\lib\\CachedInputFileSystem.js:91:9    at D:\\Git_repo\\HEXO\\khl.py.docs\\node_modules\\graceful-fs\\graceful-fs.js:123:16    at FSReqCallback.readFileAfterClose [as oncomplete] (node:internal/fs/read_file_context:68:3) &#123;  opensslErrorStack: [ &#x27;error:03000086:digital envelope routines::initialization error&#x27; ],  library: &#x27;digital envelope routines&#x27;,  reason: &#x27;unsupported&#x27;,  code: &#x27;ERR_OSSL_EVP_UNSUPPORTED&#x27;&#125;Node.js v18.15.0\n\n使用原文中的方法3，成功解决此问题\n\n以下为原文\n版权声明：本文为CSDN博主「忙碌的菠萝」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_21271511/article/details/127996193\n\n问题描述问题背景更换新机器的时候下载使用了最新版的nodejs，部署老项目的时候启动报错了\n错误描述跑了一下ruoyi的项目试试，就直接给报了 Error: error:0308010C:digital envelope routines::unsupported\nError: error:0308010C:digital envelope routines::unsupported\n    at new Hash (node:internal/crypto/hash:71:19)\n    at Object.createHash (node:crypto:133:10)\n    at module.exports (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\util\\createHash.js:135:53)\n    at NormalModule._initBuildHash (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\NormalModule.js:417:16)\n    at handleParseError (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\NormalModule.js:471:10)\n    at D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\NormalModule.js:503:5\n    at D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\webpack\\lib\\NormalModule.js:358:12\n    at D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\loader-runner\\lib\\LoaderRunner.js:373:3\n    at iterateNormalLoaders (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\loader-runner\\lib\\LoaderRunner.js:214:10)\n    at Array.&lt;anonymous&gt; (D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\loader-runner\\lib\\LoaderRunner.js:205:4)\n    at D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui\\node_modules\\graceful-fs\\graceful-fs.js:123:16\n    at FSReqCallback.readFileAfterClose [as oncomplete] (node:internal/fs/read_file_context:68:3) &#123;\n  opensslErrorStack: [ &#39;error:03000086:digital envelope routines::initialization error&#39; ],\n  library: &#39;digital envelope routines&#39;,\n  reason: &#39;unsupported&#39;,\n  code: &#39;ERR_OSSL_EVP_UNSUPPORTED&#39;\n\n问题解决原因分析1、原项目是在nodejs 16版本上跑，目前升级为nodejs 18，可能是由于升级影响的2、具体错误原因：ERR_OSSL_EVP_UNSUPPORTED 错误SSL 数字信封不支持\n解决措施1、set NODE_OPTIONS=--openssl-legacy-provider\n这个亲测并没有什么软用\nPS D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui&gt; set NODE_OPTIONS=--openssl-legacy-provider\nPS D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui&gt; npm run dev\n\n&gt; ruoyi@3.8.4 dev\n&gt; vue-cli-service serve\n\n INFO  Starting development server...\n10% building 2/2 modules 0 activeError: error:0308010C:digital envelope routines::unsupported\n\n2、降级nodejs\n升级再降级也没有道理，虽然也是可以的，最后总是要升级的，不推荐\nnvm ls availablenvm install 16.13.0\n\n\n或者卸载当前的nodejs 重新下载安装即可\n3、修改环境变量问题解决\n$env:NODE_OPTIONS=&quot;--openssl-legacy-provider&quot;\n\n输出如下\nPS D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui&gt; $env:NODE_OPTIONS=&quot;--openssl-legacy-provider&quot; PS D:\\dev\\workspace\\RuoYi-Vue-master\\ruoyi-ui&gt; npm run dev&gt; ruoyi@3.8.4 dev&gt; vue-cli-service serve INFO  Starting development server...98% after emitting CopyPlugin DONE  Compiled successfully in 18898ms     \n","categories":["差生文具多"]},{"title":"【js】用html+javascript静态页面实现伪重定向","url":"/posts/1472038549/","content":"javascript代码实现一个伪重定向\n\n\n1.前言本站的域名之前有修改过，但一些朋友的友链，和开往里面的链接尚未更新。旧的域名又米有备案，不能解析到国内服务器上用nginx进行30x转发。\n这时候我就想到了一招，用js的代码来实现一个url的切换，相当于一个伪重定向。因为是静态文件，能直接部署到netlify等平台上。\n百度了一下js是否支持这种语法，嘿，支持！\n那不直接开整！\n2.代码关于http的30x状态码，其代表站点域名或路径更改\n\n301重定向：永久\n302重定向：临时\n\nhtml代码部分很简单，设置body和站点标题都为301重定向，告诉访问者，站点已经换了新的域名\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;\n\nscript部分，通过window获取当前的域名，判断域名是否为目标域名（下文代码中的旧域名）\n如果不是，则什么都不做。如果是，则覆盖url到新域名。\n&lt;!--放在head后，body前--&gt;&lt;script&gt;var path = window.location.href;    console.log(&quot;current path:&quot;,path)//打印到控制台    // 睡眠函数    function sleep (time) &#123;      return new Promise((resolve) =&gt; setTimeout(resolve, time));    &#125;    // 睡500ms,之后执行下面的内容    sleep(500).then(() =&gt; &#123;        // 如果url不是预先设定好的这个，则啥都不做        if (path!=&quot;旧域名1&quot; &amp;&amp; path!=&quot;旧域名2&quot;) &#123;          console.log(&quot;url not match, do nothing&quot;)        &#125;        else&#123;// 否则重定向          window.location.replace(&quot;https://blog.musnow.top/&quot;);        &#125;    &#125;)&lt;/script&gt;\n\n这里我还用sleep函数休眠了500ms，否则切换很快，访客不注意的话，还不一定能发现301重定向。\n\n如果你不需要sleep，那代码更少\n&lt;script&gt;var path = window.location.href;    console.log(&quot;current path:&quot;,path)    // 如果url不是预先设定好的这两个，则啥都不做    if (path!=&quot;旧域名&quot;) &#123;        console.log(&quot;url not match, do nothing&quot;)    &#125;    else&#123;// 否则重定向       window.location.replace(&quot;https://blog.musnow.top/&quot;);    &#125;&lt;/script&gt;\n\n但是，使用过程中，我就发现访问的path有的时候并不是严格等于我的域名的，后面可能会新增一些尾随参数。为了避免有尾随参数而导致无法重定向的问题。我去掉了if的判断\n&lt;script&gt;// 301 Moved Permanentlyvar path = window.location.href;    console.log(&quot;current path:&quot;,path)    // 睡眠函数    function sleep (time) &#123;      return new Promise((resolve) =&gt; setTimeout(resolve, time));    &#125;    // 睡2000ms,之后执行下面的内容    sleep(2000).then(() =&gt; &#123;      window.location.replace(&quot;https://blog.musnow.top/&quot;);    &#125;)&lt;/script&gt;\n\n3.netlify部署将刚刚写好的代码写入一个index.html文件，再放入一个文件夹（netlify的上传只能上传文件夹）\n如果你想，还可以在文件夹里面放一个favicon.ico作为临时的站点logo\n打开netlify，找到Add new site，选择手动部署\n\n在这里上传文件夹\n\n部署好了之后，可以在domain settings里面配置域名为你的旧域名\n\n4.测试先访问旧域名，显示301重定向的信息\n\n休眠的时间到了之后，就会被重定向到当前的站点\n\n目的达成！\n5.添加上尾随参数如果你的站点有部署umami或者百度统计等访问统计服务，则可以在源码中跳转的链接里面加上来源\nwindow.location.replace(&quot;https://blog.musnow.top/?utm_source=旧域名&quot;);\n\n这样，在访问统计中，就能得知有多少用户用了旧域名访问了你的站点\n\n","categories":["差生文具多"],"tags":["nginx","Hexo"]},{"title":"【MD】Markdown如何插入视频、mp3和gif","url":"/posts/27591397/","content":"总所周知，鄙人有一个专栏叫做【差生文具多】，里面记录了一些工具的使用方法，以及使用工具时会遇到的一些问题。\n于是乎，之前就有一个朋友在群里问道“markdown如何插入视频”，当时的我不会弄，然后就出现了下面这一幕👇\n\n明天就弄😂开整！（然而这篇博客是在5.1劳动节写的）\n[TOC]\n首先你要知道，markdown语法其实是兼容html语法的，这也是为什么我们可以很方便地把markdown转换为html，放置到博客网站上\n所以我们可以用html代码来插入视频和mp3音乐\n1.md插入视频对应语法如下，这两个都可以\n&lt;video src=&quot;视频链接&quot;&gt;&lt;/video&gt;\n\n&lt;iframe height=498 width=510 src=&quot;视频链接&quot;&gt;\n\n如果我们插入一个B站视频的链接，在typora中的显示如下\n\n实际上它就是把一个网站插入到了我们的markdown文件中，形成了一个简易的浏览器\n其实你如果复制一个视频，直接在typora里面粘贴的话，typora是会自动生成对应的html链接的\n&lt;video src=&quot;../../../../Desktop/md.mp4&quot;&gt;&lt;/video&gt;\n\n但这个链接和一个本地的图片链接相同，如果需要上传到CSDN网站上的话，CSDN无法正常转存你的视频\n我们要做的，就是把这个视频也上传到我们的图床里面\n\n如果你不知道什么是图床，那就看看我吧：【图床搭建教程】\n\n图床并不是只能保存图片，它可以保存任何格式的文件。将视频拖入picgo，即可上传我们的视频到图床\n\n点击箭头所指按钮，复制我们视频的链接\n\n然后把视频链接填入上面两种形式其中之一的html代码中，即可显示出视频！\n\n\n1.2CSDN博客插入视频然后我就发现CSDN不支持上面两种样式，不过我们可以在markdown编辑器的顶部选择视频\n\n然后这里会让你填写视频的地址，目前只支持tx优酷还有bilibili的已上传视频\n\n或者你可以选择“插入已有视频”，这会把视频上传到CSDN上\n\n\n2.md插入MP3文件2.1网易云音乐外链插入MP3文件的方式很简单，我们可以使用网易云音乐，选择一个非VIP歌曲，点击生成外链播放器\n\n然后复制这里的html代码即可！\n\n&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=33367876&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;\n\n\n\n上面就生成了一个网易云音乐的外链播放器\n\n2.2自己的MP3音频文件根据上面html插入视频的代码，就可以猜出来音频的代码是啥\n把vedio改成audio就可以啦！\n&lt;audio src=&quot;mp3文件链接地址&quot;&gt;&lt;/audio&gt;\n\n下面就是一个我上传的MP3音乐文件\n\n在typora中的样式如下👇\n\n3.md插入gif这个就没有什么特殊的格式了\ngif图片也是一个图片，直接用![]()这种标准的markdown插入图片的样式就可以了\n\n结语这个新文具的博客到这里就结束啦！\n希望对你有帮助！😍\n虽然我感觉在markdown中插入视频的使用场景不是很多\n","categories":["差生文具多"],"tags":["图床","typora"]},{"title":"【牛客网】BM1：翻转链表","url":"/posts/3018206681/","content":"今天打算开启新一轮刷题了，必须得刷了，再不刷就得成废物了。\n也希望看我博客的老哥能监督一下我，一起进步嘛！\n\n\n题目BM001打算从牛客网的面试top101开始刷起来，今天是BM001反转链表\n\n给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。\n数据范围： 0≤n≤1000\n要求：空间复杂度 O(1) ，时间复杂度 O(n) 。\n\n解法1：循环最简单的办法就是用指针来一个一个修改链接，每次都将当前节点的next链接为上一个节点，最终再将开头的节点（单独存一下原本的开头）的next链接为空，返回最后一个节点即可。\n很常规的写法，参考注释\nclass Solution&#123;public:    ListNode *ReverseList(ListNode *head)    &#123;        // 因为需要O(1)空间复杂度，所以我们不能用很蠢的将数据遍历出来后倒序放回的办法        // 时间复杂度是O(N) 也要求我们写的代码相对来说效率需要高一些        if (head == nullptr || head-&gt;next == nullptr)        &#123;            return head; // 只有一个或者为空的情况下，直接跳过        &#125;        ListNode *old_head = head; // 单独存头        ListNode *A, *B, *C;       // 三个指针        A = head;        B = head-&gt;next;        C = head-&gt;next-&gt;next;        while (C != nullptr)        &#123;            // B修改链接为B的前一个（A在原视链表中是B的前一个）            B-&gt;next = A;            A = B;       // A变成B（也相当于A在原视链表中，往后走一步）            B = C;       // B往后走一步            C = C-&gt;next; // C往后走一步        &#125;        // 走到这里是B的下一个C已经为nullptr，代表B是最后一个节点        B-&gt;next = A; // 依旧是链接        old_head-&gt;next = nullptr;        return B; // B是原视链表的最后一个节点，新链表的第一个节点    &#125;&#125;;\n\n解法2：递归一般面试的时候，面试官更希望看到递归的办法，因为这样的代码更加简洁，思路也更加有挑战性（反正你就要往难的办法想）\n递归的思路也是让下一个节点的next链接为当前节点。主要在于递归的末端条件应该是head-&gt;next==nullptr的时候就需要退出了，因为此时 head-&gt;next-&gt;next是无效的，没有办法进行链接。\n整个过程大概就是下面这个简图了，其中方框代表的是节点，圆形代表每一步\n\n上代码，这里将 head-&gt;next = NULL;是为了操作第一个节点（原视链表的首节点）的时候，将下一位改成空。而在中间节点的时候，因为当前节点的next会在上一层递归的时候被修改回去，所以设置为空不会出现问题。\nListNode *ReverseList(ListNode *head)&#123;    // 特判：注意不要漏掉head-&gt;next==NULL的情况    if (head == NULL || head-&gt;next == NULL)    &#123;        return head;    &#125;    // 递归调用    ListNode *ans = ReverseList(head-&gt;next);    // 让当前结点的下一个结点的 next 指针指向当前节点    head-&gt;next-&gt;next = head;    // 同时让当前结点的 next 指针指向NULL ，从而实现从链表尾部开始的局部反转    head-&gt;next = NULL;    return ans;&#125;\n","categories":["把题目都给刷干净"],"tags":["C语言","OJ刷题","牛客网"]},{"title":"【牛客网】BM3：链表中的节点每k个一组翻转","url":"/posts/3391123821/","content":"BM3链表中的节点每k个一组翻转\n\n\n1.题目BM3 链表中的节点每k个一组翻转\n将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。\n\n2.解析2.1 链表逆置其他部分其实很好解决，基于链表逆置的代码（即逆置整个链表的代码）\n我们只需要将每一个需要逆置的小区间的开头给记下来，交付给链表逆置就可以了。\n// 无差别逆置ListNode* reverseNode(ListNode* head) &#123;    if (head == nullptr || head-&gt;next == nullptr) &#123;        return head;    &#125;    ListNode* ans = reverseNode(head-&gt;next);    head-&gt;next-&gt;next = head;    head-&gt;next = nullptr;    return ans;&#125;\n\n2.2 记录每个需要逆置的区间比如如下部分代码，为了方便进行遍历和指针控制，我创建了一个头节点放置在了原本链表开头\n// 头节点和遍历指针ListNode phead(0);phead.next = head;ListNode* cur = &amp;phead;// 把每k个节点单独取出来，分别逆置后链接起来std::vector&lt;ListNode*&gt; begin_node_v,begin_node_prev_v;int index = k-1; // 初始化为k-1(忽略头节点)，原有链表第一个节点始终入栈int node_count = 0;// 节点总数（包含头节点）while (cur != nullptr) &#123; // 不知道有多长，得死循环    if(index+1 == k &amp;&amp; cur != &amp;phead)&#123;        begin_node_prev_v.push_back(cur);    &#125;    else if (index == k) &#123;        begin_node_v.push_back(cur);        index = 0;    &#125;    cur = cur-&gt;next;    index++;    node_count ++;&#125;\n\n这里还创建了两个vector数组\n\nbegin_node_v：待逆置区间的开头\nbegin_node_prev_v：待逆置区间的开头的上一个\n\n下面是对这两个数组的说明，如果给出的示例是如下形式\n&#123;1,2,3,4,5&#125;,2\n\n那么两个数组分别存储了如下值\nbegin_node_v:     &#123;1,3,5&#125;begin_node_prev_v: &#123;2,4&#125;\n\n这样一来，第一个数组实际上存放的是每个区间的开头，第二个数组存放的则是每个区间的结尾。逆置了之后:\n\n第二个数组就是新区间的开头\n第一个数组就是新区间的结尾\n\n方便我们将逆置后的链表重新连起来！\n2.3 抛弃无需逆置的区间在上面的循环中，用了node_count来计算了整个链表的长度，减1剔除我自己添加的头节点，就是原始链表的长度。\n题目有个特殊要求：如果原始链表的长度并非k的整数倍，那么最后一段区域的链表是不需要逆置的\n1 - 2 - 3 - 4 - 5当k=3的时候，只需要逆置 1-2-3            4-5不需要逆置3 - 2 - 1 - 4 - 5\n\n在这种情况，用例和两个数组存放的节点如下\n用例 &#123;1,2,3,4,5&#125;,3begin_node_v:     &#123;1,4&#125;begin_node_prev_v: &#123;3&#125;\n\n如果我们直接将begin_node_v里面的节点交付给链表逆置函数，就会将4-5这一段夜给逆置，最终返回的结果是3-2-1-5-4，不符合题目要求！\n所以在这种情况下，我们需要将4从第一个数组中删除！如果原视链表的节点数量已经小于k了，则也不需要逆置，直接返回即可。\n// 如果节点总数量小于k则不逆置直接返回node_count --;//减-1 头节点if(node_count &lt;k)&#123;    return head;&#125;// 不是整数倍，代表最后一个是不要处理的ListNode* last_link = nullptr;if((node_count %k) != 0) &#123;    last_link = begin_node_v[begin_node_v.size()-1];// 最后一个    begin_node_v.pop_back();// 删除最后一个&#125;\n\n另外，为了最终将这段么有逆置的链表和新链表连起来，我们还需用一个指针记录下这一段的开头；last_link初始化为空是方便后续的判断，如果为空代表不存在这一段链表，不需要链接。\n2.4 区间结束标识为了标识每次逆置的结束符，我们还需要将待逆置的每一个小区间的末尾都改成nullptr\n// 将每个区间的末尾节点的next链接为Null作为递归标识for(auto&amp;n:begin_node_prev_v)&#123;    n-&gt;next = nullptr;&#125;\n\n2.5 逆置和重新链接上面的步骤都敲定了之后，我们就可以将第一个数组begin_node_v的节点喂给链表逆置函数了，该逆置函数的返回值是新链表的开头。\n// 将每个区间交付给递归开始逆置，并将逆置的返回值与上一个区间的开头连起来cur = &amp;phead;for(auto&amp; n:begin_node_v)&#123;    ListNode* ptr=reverseNode(n);    cur-&gt;next = ptr;    cur = n;&#125;\n\n这里说一下cur指针的作用，以用例&#123;1,2,3,4,5&#125;,2为栗子，此时begin_node_v数组中存放的是&#123;1,3,5&#125;\n\n初始化为phead\n第一次循环，n指向的是1，cur指向的是phead；逆置结束后，ptr指向的是2，刚好就是新链表的开头，将cur的next链接为它，并将cur更新为1\n第二次循环，n指向的是3，cur指向的是1；逆置结束后，ptr指向的是4，此时cur的next指向它，就是将1的next链接为4，再次更新cur为3。\n第三次循环，n指向的是5，cur指向的是3；逆置结束后，将3的next链接为5，cur更新为5\n循环结束\n\n结束时，这个链表就已经完工了！我们只需要判断一下还没有剩下的没有逆置的节点，将其链接给begin_node_v数组中的最后一个节点（也是逆置部分的最后一个节点）的next就可以了\n// 判断是否还有剩下的节点if(last_link !=nullptr)&#123;    begin_node_v[begin_node_v.size()-1]-&gt;next = last_link;&#125;\n\n3.完整代码class Solution &#123;  public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *     * @param head ListNode类     * @param k int整型     * @return ListNode类     */    // 无差别逆置    ListNode* reverseNode(ListNode* head) &#123;        if (head == nullptr || head-&gt;next == nullptr) &#123;            return head;        &#125;        ListNode* ans = reverseNode(head-&gt;next);        head-&gt;next-&gt;next = head;        head-&gt;next = nullptr;        return ans;    &#125;    void cout_vector(std::vector&lt;ListNode*&gt;&amp; begin_node_v) &#123;        for (auto&amp; e : begin_node_v) &#123;            cout &lt;&lt; e-&gt;val &lt;&lt; &quot; &quot; ;        &#125;        cout &lt;&lt; endl;    &#125;    ListNode* reverseKGroup(ListNode* head, int k) &#123;        // 只有一个节点，或者逆置区间为1的都不需要操作        if (head == nullptr || head-&gt;next == nullptr || k &lt;= 1) &#123;            return head;        &#125;        // 头节点和遍历指针        ListNode phead(0);        phead.next = head;        ListNode* cur = &amp;phead;        // 把每k个节点单独取出来，分别逆置后链接起来        std::vector&lt;ListNode*&gt; begin_node_v,begin_node_prev_v;        int index = k-1; // 初始化为k-1(忽略头节点)，原有链表第一个节点始终入栈        int node_count = 0;// 节点总数（包含头节点）        while (cur != nullptr) &#123; // 不知道有多长，得死循环            if(index+1 == k &amp;&amp; cur != &amp;phead)&#123;                begin_node_prev_v.push_back(cur);            &#125;            else if (index == k) &#123;                begin_node_v.push_back(cur);                index = 0;            &#125;            cur = cur-&gt;next;            index++;            node_count ++;        &#125;        // 走到这里已经把每个需要逆置的开头节点给记录下来了        // 如果节点总数量小于k则不逆置直接返回        node_count --;//减-1 头节点        if(node_count &lt;k)&#123;            return head;        &#125;        // 不是整数倍，代表最后一个是不要处理的        ListNode* last_link = nullptr;        if((node_count %k) != 0) &#123;            last_link = begin_node_v[begin_node_v.size()-1];// 最后一个            begin_node_v.pop_back();// 删除最后一个        &#125;        // cout_vector(begin_node_v);        // cout_vector(begin_node_prev_v);        // 将每个区间的末尾节点的next链接为Null作为递归标识        for(auto&amp;n:begin_node_prev_v)&#123;            n-&gt;next = nullptr;        &#125;        // 将每个区间交付给递归开始逆置，并将逆置的返回值与上一个区间的开头连起来        cur = &amp;phead;        for(auto&amp; n:begin_node_v)&#123;            ListNode* ptr=reverseNode(n);            cur-&gt;next = ptr;            cur = n;        &#125;        // 判断是否还有剩下的节点        if(last_link !=nullptr)&#123;            begin_node_v[begin_node_v.size()-1]-&gt;next = last_link;        &#125;        return phead.next;    &#125;&#125;;\n\n通过截图\n\n","categories":["把题目都给刷干净"],"tags":["C++","OJ刷题","牛客网"]}]