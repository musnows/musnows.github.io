[{"title":"【Nas】bt的tracker留档","url":"/2022/11/06/nas/%E5%A8%81%E8%81%94%E9%80%9Aqbt%E7%9A%84tracker/","content":"以下tracker来自网站trackerslist.com\n\nhttps://trackerslist.com/#/zh?id=%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8\n\n贴出来是为了留档，避免该网站无法访问\n在qbittorrent-工具-设置-bittorent-tracker中添加即可\nhttp://1337.abcvg.info:80/announcehttp://207.241.226.111:6969/announcehttp://207.241.231.226:6969/announcehttp://[2001:1b10:1000:8101:0:242:ac11:2]:6969/announcehttp://[2a04:ac00:1:3dd8::1:2710]:2710/announcehttp://chouchou.top:8080/announcehttp://fxtt.ru:80/announcehttp://incine.ru:6969/announcehttp://ipv4announce.sktorrent.eu:6969/announcehttp://movies.zsw.ca:6969/announcehttp://nyaa.tracker.wf:7777/announcehttp://open-v6.demonoid.ch:6969/announcehttp://open.acgnxtracker.com:80/announcehttp://open.acgtracker.com:1096/announcehttp://parag.rs:6969/announcehttp://retracker.hotplug.ru:2710/announcehttp://share.camoe.cn:8080/announcehttp://t.acg.rip:6699/announcehttp://t.nyaatracker.com:80/announcehttp://t.overflow.biz:6969/announcehttp://torrentsmd.com:8080/announcehttp://tr.cili001.com:8070/announcehttp://tracker.birkenwald.de:6969/announcehttp://tracker.bt4g.com:2095/announcehttp://tracker.dler.com:6969/announcehttp://tracker.dler.org:6969/announcehttp://tracker.electro-torrent.pl:80/announcehttp://tracker.fansub.id:80/announcehttp://tracker.files.fm:6969/announcehttp://tracker.gbitt.info:80/announcehttp://tracker.ipv6tracker.ru:80/announcehttp://tracker.mywaifu.best:6969/announcehttp://tracker.opentrackr.org:1337/announcehttp://tracker.srv00.com:6969/announcehttp://tracker.vrpnet.org:6969/announcehttp://tracker.zerobytes.xyz:1337/announcehttp://tracker1.itzmx.com:8080/announcehttp://tracker2.dler.org:80/announcehttp://tracker3.itzmx.com:6961/announcehttp://tracker4.itzmx.com:2710/announcehttp://trackme.theom.nz:80/announcehttp://vps-dd0a0715.vps.ovh.net:6969/announcehttp://vps02.net.orel.ru:80/announcehttp://wepzone.net:6969/announcehttp://www.all4nothin.net:80/announce.phphttp://www.wareztorrent.com:80/announcehttps://1337.abcvg.info:443/announcehttps://opentracker.i2p.rocks:443/announcehttps://t1.hloli.org:443/announcehttps://tr.abiir.top:443/announcehttps://tr.abir.ga:443/announcehttps://tr.burnabyhighstar.com:443/announcehttps://tr.fuckbitcoin.xyz:443/announcehttps://tracker.cyber-hub.net:443/announcehttps://tracker.expli.top:443/announcehttps://tracker.foreverpirates.co:443/announcehttps://tracker.gbitt.info:443/announcehttps://tracker.imgoingto.icu:443/announcehttps://tracker.kuroy.me:443/announcehttps://tracker.lilithraws.cf:443/announcehttps://tracker.lilithraws.org:443/announcehttps://tracker.loligirl.cn:443/announcehttps://tracker.m-team.cc:443/announce.phphttps://tracker.nanoha.org:443/announcehttps://tracker.tamersunion.org:443/announcehttps://tracker1.520.jp:443/announcehttps://trackme.theom.nz:443/announcehttps://xtremex.herokuapp.com:443/announceudp://184.105.151.166:6969/announceudp://207.241.226.111:6969/announceudp://207.241.231.226:6969/announceudp://52.58.128.163:6969/announceudp://6ahddutb1ucc3cp.ru:6969/announceudp://9.rarbg.com:2810/announceudp://91.216.110.52:451/announceudp://94-227-232-84.access.telenet.be:6969/announceudp://960303.xyz:6969/announceudp://[2001:1b10:1000:8101:0:242:ac11:2]:6969/announceudp://[2001:470:1:189:0:1:2:3]:6969/announceudp://[2a03:7220:8083:cd00::1]:451/announceudp://[2a04:ac00:1:3dd8::1:2710]:2710/announceudp://[2a0f:e586:f:f::220]:6969/announceudp://aarsen.me:6969/announceudp://admin.52ywp.com:6969/announceudp://admin.videoenpoche.info:6969/announceudp://astrr.ru:6969/announceudp://black-bird.ynh.fr:6969/announceudp://bt.ktrackers.com:6666/announceudp://bt1.archive.org:6969/announceudp://bt2.archive.org:6969/announceudp://buddyfly.top:6969/announceudp://camera.lei001.com:6969/announceudp://chouchou.top:8080/announceudp://concen.org:6969/announceudp://creative.7o7.cx:6969/announceudp://cutiegirl.ru:6969/announceudp://cutscloud.duckdns.org:6969/announceudp://epider.me:6969/announceudp://exodus.desync.com:6969/announceudp://f1sh.de:6969/announceudp://fe.dealclub.de:6969/announceudp://fh2.cmp-gaming.com:6969/announceudp://ftp.pet:2710/announceudp://htz3.noho.st:6969/announceudp://ipv4.tracker.harry.lu:80/announceudp://ipv6.tracker.harry.lu:80/announceudp://jutone.com:6969/announceudp://laze.cc:6969/announceudp://leefafa.tk:6969/announceudp://mail.artixlinux.org:6969/announceudp://mail.zasaonsk.ga:6969/announceudp://mirror.aptus.co.tz:6969/announceudp://moonburrow.club:6969/announceudp://movies.zsw.ca:6969/announceudp://new-line.net:6969/announceudp://open.4ever.tk:6969/announceudp://open.demonii.com:1337/announceudp://open.dstud.io:6969/announceudp://open.free-tracker.ga:6969/announceudp://open.publictracker.xyz:6969/announceudp://open.stealth.si:80/announceudp://open.tracker.ink:6969/announceudp://opentor.org:2710/announceudp://opentracker.i2p.rocks:6969/announceudp://p4p.arenabg.com:1337/announceudp://psyco.fr:6969/announceudp://public.publictracker.xyz:6969/announceudp://public.tracker.vraphim.com:6969/announceudp://qtstm32fan.ru:6969/announceudp://rep-art.ynh.fr:6969/announceudp://retracker.hotplug.ru:2710/announceudp://retracker.lanta-net.ru:2710/announceudp://run.publictracker.xyz:6969/announceudp://sanincode.com:6969/announceudp://slicie.icon256.com:8000/announceudp://smtp-relay.odysseylabel.com.au:6969/announceudp://static.54.161.216.95.clients.your-server.de:6969/announceudp://sx.xxtor.com:6969/announceudp://tamas3.ynh.fr:6969/announceudp://theodoric.fr:6969/announceudp://thinking.duckdns.org:6969/announceudp://thouvenin.cloud:6969/announceudp://torrentclub.space:6969/announceudp://torrents.artixlinux.org:6969/announceudp://tr.bangumi.moe:6969/announceudp://tr.cili001.com:8070/announceudp://tracker-udp.gbitt.info:80/announceudp://tracker.4.babico.name.tr:3131/announceudp://tracker.altrosky.nl:6969/announceudp://tracker.artixlinux.org:6969/announceudp://tracker.auctor.tv:6969/announceudp://tracker.beeimg.com:6969/announceudp://tracker.birkenwald.de:6969/announceudp://tracker.bitsearch.to:1337/announceudp://tracker.cubonegro.xyz:6969/announceudp://tracker.cyberia.is:6969/announceudp://tracker.ddunlimited.net:6969/announceudp://tracker.dler.com:6969/announceudp://tracker.dler.org:6969/announceudp://tracker.encrypted-data.xyz:1337/announceudp://tracker.filemail.com:6969/announceudp://tracker.jonaslsa.com:6969/announceudp://tracker.joybomb.tw:6969/announceudp://tracker.leech.ie:1337/announceudp://tracker.moeking.me:6969/announceudp://tracker.monitorit4.me:6969/announceudp://tracker.novaopcj.eu.org:6969/announceudp://tracker.openbittorrent.com:6969/announceudp://tracker.openbtba.com:6969/announceudp://tracker.opentrackr.org:1337/announceudp://tracker.pimpmyworld.to:6969/announceudp://tracker.pomf.se:80/announceudp://tracker.publictracker.xyz:6969/announceudp://tracker.skynetcloud.site:6969/announceudp://tracker.skyts.net:6969/announceudp://tracker.srv00.com:6969/announceudp://tracker.swateam.org.uk:2710/announceudp://tracker.tcp.exchange:6969/announceudp://tracker.theoks.net:6969/announceudp://tracker.tiny-vps.com:6969/announceudp://tracker.torrent.eu.org:451/announceudp://tracker.yangxiaoguozi.cn:6969/announceudp://tracker.zerobytes.xyz:1337/announceudp://tracker1.bt.moack.co.kr:80/announceudp://tracker1.itzmx.com:8080/announceudp://tracker1.myporn.club:9337/announceudp://tracker2.dler.com:80/announceudp://tracker2.dler.org:80/announceudp://tracker2.itzmx.com:6961/announceudp://tracker3.itzmx.com:6961/announceudp://tracker4.itzmx.com:2710/announceudp://tracker6.lelux.fi:6969/announceudp://uploads.gamecoast.net:6969/announceudp://v1046920.hosted-by-vdsina.ru:6969/announceudp://vibe.sleepyinternetfun.xyz:1738/announceudp://wepzone.net:6969/announceudp://www.torrent.eu.org:451/announceudp://zecircle.xyz:6969/announcews://hub.bugout.link:80/announcewss://tracker.openwebtorrent.com:443/announce\n\n","categories":["捣鼓折腾nas"],"tags":["nas"]},{"title":"【Nas】威联通ts216折腾日志（已出手）","url":"/2022/11/06/nas/%E5%A8%81%E8%81%94%E9%80%9Ats216%E6%8A%98%E8%85%BE/","content":"本篇博客记录了我使用威联通ts216的折腾记录。nas购入于2022年双11，京东自营\n\n\n关于系统初始化等内容不做记录，这部分网上可以找到很多教程，只要是威联通，方法都是一样的\n\n初始化参考视频 【村雨】威联通NAS教程合集（长期更新）\n开启admin账户、开启ssh都可参考上面这个视频的教程\n\n本博客主要记录一些网上不好找到的踩坑记录\n\n如果您还没有选购nas，那么我绝对不推荐您购买TS216；威联通的系统在这块arm CPU上面非常之卡卡卡！除非您的需求只是最基本的备份，否则这个系统会把你卡到怀疑人生😡打开一个file station文件管理器就要15s，如果你的系统盘是机械，关机甚至花了6分钟\n\n\n[TOC]\n1.关于储存卷的选择先说结论，我建议直接用单个ssd静态卷作为系统盘，不用raid1和qtier\n\n名词解释：\n\nraid0：两个盘合并成一个盘，容量和速度为这两个盘的和；如果其中一个盘损坏，则丢失所有数据（极其不安全，完全不推荐）\nraid1：两个盘合并成一个盘，资料会在这两个盘上面存储；损失一个盘的空间；如果两个盘的容量不一样，raid1最后的容量由小容量的盘决定\n威联通qtier：利用ssd和机械组成混合存储，常访问的数据放ssd，不常访问的放机械；如果其中一个盘损坏，也会导致数据丢失\n\n\n1.1 为什么只推荐单一静态卷？ts216是2+2盘位的nas，两个m2+两个3.5\n和群晖ssd只能用于加速不同，威联通是可以把ssd当做一个正常盘，来做系统盘or储存盘or加速盘\n但是！！！ts216由于是低端型号，不支持将ssd作为全局缓存加速。最直观的证明，便是其设置中压根没有高速缓存加速这个选项\n\n\n我还以为威联通虚假宣传。询问客服后，才得知ts216如果想用ssd加速，只能用ssd和机械组qtier卷\n不过我个人不推荐你这么做！\n\nqtier的情况以下是我对qtier技术的小结，信息源于京东自营客服\n\nqtier至少需要一个ssd和一个机械，经常使用的数据会从机械盘转移到ssd中，提高读写速度。不常用的数据会放回机械存储\n如果这两个盘中任意一个盘损坏，都会导致qtier存储池中的数据丢失（但不会导致盘连带损坏，只是数据没了）\n这一切都是威联通系统决定的，你无法得知到底数据在ssd还是在机械上\n\n威联通的系统需要单独指定某一个卷安装，如果用qtier来装系统，反而增大了数据丢失的风险！\n举例如下\n\n盘A坏的几率是1%，盘B坏的几率1% 它们同时坏的几率是A*B，其中一个坏的几率是A+B\n假设我们把os安装到盘A单独的静态卷中，系统是否完好，只取决于A盘坏不坏\n假设我们把os安装到盘AB的qtier中，反而变成了只要AB中有一个盘坏了，系统盘就无了。相当于要承担两个盘其中一个坏掉的几率，几率增大！\n假设我们把os安装到ssd1和ssd2的raid1阵列，os坏掉的几率依旧是两ssd其中一个坏掉的几率（注: r1只能让你数据不丢失，但并不意味着你不需要重新配置系统）\n\n系统储存池损坏会导致什么？\n\n所有软件数据丢失，配置丢失。需要重新配置\n和系统储存池无关的盘不受任何影响\n\n根据以上的条件可知，如果你想提高系统访问速度，直接将系统装入单个固态反而是最稳妥的办法。\n结论：使用单个ssd，设置为静态卷，作为系统盘；另外一个m2口可以用来做热数据盘，比如音乐这种经常听的东西，就可以放到这个盘里面。\n\n个人不推荐上qtier\n\n如果你对数据安全要求高，也可以使用两个ssd组raid1装系统。这样至少能保证数据不会丢，重新配置环境都是后话了。\n\n可如果系统盘里面不存资料，又何必在意里面的数据呢？😂省钱get！\n\n关于固态的选购ts216的固态口是pcie3.0x1的，理论最大速度是1Gb/s，几乎所有nvme盘的速度都大于该速度（现在基本看不到m2的sata盘了）\n所以，你不需要买三星980p这种高端玩意，只需要买一个原片的盘就行了，个人推荐如下：\n\n闪迪（其实就是sn570的换皮）\n西部数据sn570\n铠侠rc20（铠侠是东芝的）\n\n容量建议256起步，如果系统盘不存数据，足够用了。但如果你想用系统盘作为bt下载的缓存盘，而你经常下几十gb的大电影，那建议购买512gb的\n\n我个人使用的是影驰黑将pro256gb，你可能会说这个盘铁定不稳啊！\n咳咳，当初我是想着拿这个盘作为全局加速盘的！没想到ts216不支持这个功能，无奈之下只能用来做系统了。反正系统盘坏了也不影响其他数据，就这样吧，正好看看它能用多久\n\n建议先插入固态，等初始化系统完成之后，再插入其他盘。\n在存储与快照总管中可以看到ssd的寿命百分比，当这个跌到94%左右的时候，就建议你更换ssd了\n\n不过我没有找到系统迁移的办法，似乎只能重新做系统盘，所有软件的配置都会丢失……\n1.2 HBS3文件备份同样的，两块机械也没有必要组raid1，因为威联通自带了一个HBS3文件备份中心\n这个备份中心有什么用呢？\n\n支持本地nas两个文件夹之间的相互备份\n支持百度云、OneDrive、阿里云oss、腾讯云等等第三方客户端的同步\n支持从外接设备（usb）备份数据到nas\n\n这样做比raid1好在哪里？\n\n数据在多个盘中存储\n比raid1节省大量空间！\n\n以我自己为例，我个人压根没有太多重要数据：自己拍的照片、下的音乐电影、一些不好找的软件等等\n这里面真正重要的，恐怕只有照片和一些正经的学校资料😂其他都是无所谓的\n目前我的照片加起来只有可怜的5.6GB，还没有一部电影大！\n\n如果弄raid1，就相当于白白浪费一个盘的空间，舍本逐末了属于是\n这只是我个人的情况！如果你认为你的重要数据超过了机械盘容量的1/3，那可以考虑上raid1\n本地双盘备份先选择一个源\n\n在选择目标，可以选择当前nas，支持的终端非常多\n\n设置作业名称，他会在目标文件夹中创建一个和作业名称相同的文件夹\n\n然后是选择备份计划，可以选择每天、每周的某几天、每个月的某几天进行备份\n\n配置好了之后，可以点击立即备份，先开始拷贝一份资料到目标中，\n这样就能保证我们的数据在两个盘中都存着。如果你想，你还可以给ssd中也备份一份，就相当于3个盘中都有这个数据\n三个盘一起坏的概率……如果你真遇到了，一定要去买个彩票止损！😂\n\n如果你还是担心，就往百度云盘里面再备份一份，这就做到了多个介质存储+异地备份\n注意，上面的备份并不是实时的，如果你需要实时的同步。则需要在下面的页面选择👇\n\n\n备份到百度云盘前面的步骤都是一样的，备份的时候选择百度云作为目的地，登录你的百度云账户。\n你会发现账户目录下面是空的，因为默认它在百度云盘的我的应用数据下新建了一个文件夹，威联通没有权限备份到百度云盘的其他目录，只能在它创建的这个文件夹内部进行备份\n\n选择百度网盘之后，其实没有必要新建文件夹，因为威联通会默认用备份作业名创建一个文件夹。如果你自己再创建一个，文件夹层级就会变得非常多（用过你就知道了）\n\n备份的时候写清楚作业名，便会自动在百度云盘那儿创建一个文件夹\n\n由于是和云端备份，可能会出现没有完整上传的情况，可以在这里配置一下数据完整性的检查\n\n重点来了！威联通和群晖的备份中心都有一个数据加密功能，会将你的数据本地加密之后，再上传到百度云。考虑到百度云扫用户文件的情况，这个功能一定要加上！\n\n选择了之后需要填写密码，这个密码必须记住，否则你再也打不开云端的文件了\n\n可以去威联通官网下载解密软件，即便不用nas也可以通过密码解密出网盘中的资料\n\n如果你的数据还涉及到一些特别隐私的内容，可以使用数据压缩进一步提高安全性！因为威联通这个数据压缩的格式.qnap.bz2百度云盘是不支持识别的\n\n设置完毕后，nas便会定时往百度云上备份你的资料。但是由于威联通没办法单独查看hbs3网络使用情况，只能估算一下上传的速度（无百度网盘会员）\n2.56GB的文件大概用了23分钟上传完毕，平均速度1.8mb/s\n\n\n我没有选择压缩文件，在百度网盘app中查看，图片文件名虽然依旧是明文，但是无法直接预览；下载到手机后，同样无法预览该图片。\n这就是加密之后的效果！免去了我们手动打压缩包+密码的繁琐操作，安心\n\n相比之下，国产的轻nas海康、联想、极空间、绿联都支持备份到百度云盘，但据我所知都不支持加密功能。\n不知道多久能看到国产nas加上这类功能，在云盘普遍乱扫用户文件的环境下，这个功能真的很重要！谁都不想看到自己拍的照片被河蟹🙃之前在贴吧看到一位父亲说，自己拍的宝宝照片，光pp的都被河蟹了😂\n2.qbittorrent2.1 什么是bt下载？之前的我也不是很了解这方面的知识，现在看了几篇文章，大概知晓了这个技术的基本思路，复述如下：\n\n用户a有一份资源z，他做出了第一颗该资源的种子，并分享到网上\n用户b首次下载了该资源，注意，此时这个z资源只有一个上传端，那就是a的电脑。用户b的下载速度，取决于a的上传速度以及ab之间的网络环境\n用户b下载完该资源后，也选择做种。此时，资源z就有了ab两个上传端。\n用户c作为第二个下载z的人，他是从a和b那儿一起下的。可以简单理解为z的前半部分是从a那儿搞来的，后半部分是从b那儿搞来的\n以此类推，只要下载z的人越来越多，而且这些用户都选择了做种，那么z资源的下载速度就会越来越快！\n\n\n做种：即成为该资源的上传端\n\n2.2 何为“吸血”？你可能听到过很多人吐槽迅雷是吸血雷，这是为何？吸血又是什么？\n先来复盘一下上面的思路，用户们下载资源z后，做种成为了z的上传端\n迅雷也是通过这些用户，下载资源z的。下载完资源z后，它也做了种，但是！迅雷不给其他用户使用他做的种！\n\n用户d是迅雷用户，他使用迅雷下载了z资源\n迅雷从之前abc用户那儿下载来了资源z，下载完成后，并用d的电脑给z做了种\n迅雷屏蔽了其他bt下载客户端的访问，d做的种只有迅雷用户能使用\n迅雷凭借广大的用户基数，对z做的种越来越多\n久而久之，出现了用迅雷下载z资源，比其他客户端下载z的速度快几倍的情况！\n因为迅雷下载比其他客户端快，使用迅雷下载的用户越来越多\n下载速度的差距越来越大……并重复上一点的情况……\n\n这就出现了一个无解的死循环！\n很抱歉的是，这个情况已经发生了：百度一搜，处处可以看到不少人发帖询问为何迅雷速度比其他客户端快很多，甚至出现某些资源只有迅雷能下载的情况！\n而这是大环境的问题，牵涉到国人使用软件的习惯、国内网络环境等等情况，并不是说你我做种的时候，ban掉迅雷从自己这里下载就能解决的。\n\n具体参看 https://zhuanlan.zhihu.com/p/87193566\n\nqbt的增强版本qbtee可以屏蔽迅雷，但是很多pt站点都不支持用qbtee进行下载。如何选择就看大家自己了😝\n\n22.11.20更新：今天下载爱情公寓的时候发现了下面这个情况，最后一个XL开头的客户端就是迅雷，似乎是我从迅雷用户哪儿下走了100mb的资源。看来迅雷也不至于完全不会上传😋\n\n知乎老哥说，迅雷也分版本，有些版本是会上传的\n\n2.3 docker安装在ontainer-station里面，搜索qbittorrent（后文简称qbt）\n强烈推荐安装2.3.2中的johngong/qbittorrent镜像\n2.3.1 80X86我最开始下载的是80X86大佬制作的镜像，听说这个比较好用。版本要选择arm的，否则ts216无法使用。如果你是x86的nas，则选择amd64版本\n\n下载好之后，需要配置一些东西👇\ncpu限制为30%，内存限制为512mb（qbt的负载不高，添加限制避免卡死系统）\n点击高级设置，弄好下面三个端口转发\n8089-tcp8999-tcp8999-udp\n\n\n随后需要挂载三个文件夹给qbt，建议先创建好文件夹后，再来这里挂载共享文件夹\n/downloads 建议挂载机械盘/data 建议挂载到ssd/config 建议挂载到ssd\n\n\n\n配置好之后，点击确认创建容器。你可能会遇到这个报错，直接忽略，因为容器已经创建成功了（ts216似乎创建任何容器都会触发此报错）\n\n2.3.2 johngong (推荐)前面提到了qbt的高级版本支持防吸血，我以为高级版本没有docker的arm镜像，实际上是有的！\n这里推荐大家下载johngong/qbittorrent，直接下载最新版本就可以了！\n\n下面是同一个种子，两个版本的下载速度差距！\n\n\n80X86 712KB/S👆 \n增强版本 3.6MB/S👇实际上还跑到了6mb但是没截到图\n\n\n速度差距可不小！而且做种的速度也变快了，这还是我第一次见自己做种速度上了1mb/s\n\n我们还可以在设置高级选项中配置：\n\n同时和所有同级tracker通信（避免qbt只有一两个tracker处于工作状态的情况）\n\n\n\nban掉未知的客户端（防止迅雷吸血）\n\n\n安装方式参考大佬的docker页面readme \n\nhttps://registry.hub.docker.com/r/johngong/qbittorrent/#!\n\n这里只对一些问题进行说明：\n\n环境变量中的QB_EE_BIN设置为true，这样能开启qbt的增强版，有防吸血功能\ntracker-url的list地址可以后续在web ui中配置，不需要改环境变量\n\n\n初次配置的时候，建议啥都不设置直接创建一个新容器，然后删除这个容器，重新在本地镜像中选择后配置。\n\n因为默认情况下是不会显示任何环境变量的，需要你一个一个设置。用这个办法之后，默认的环境变量就会被写入，此时只需要修改值就行了！\n\n配置好了之后，如果你遇到了WEB后台显示unauthorized的问题，直接在浏览器url哪一栏按一下回车，就能进入web界面\n\n如果按了回车之后还是不行，则修改qbittorrent配置文件中的qbittorrent.conf，添加\nWebUI\\HostHeaderValidation=false\n\n\n这个问题困扰了我半小时，还以为容器设置不对。最后还是在true nas的社区找到的解决办法\n\nhttps://www.truenas.com/community/threads/qbittorrent-unauthorized.100991/\n\n有什么问题欢迎在评论区提出！\n2.4 配置tracker刚开始下载的时候，毫无速度，有些资源迅雷也是0kb\n于是百度了一下，看到了知乎的文章\n\n解决 qBittorrent 无速度：添加自定义 Tracker\n\n在qb的工具-设置，bt里面，添加tracker\n\nhttps://trackerslist.com/#/zh?id=%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8\n\n这个网站有教程和traker，很全面，加了之后，速度直接上6mb\n\n注意，tracker只对热门资源有用。一些冷门资源，连吸血雷都没有速度，tracker也无济于事\ntracker留档为了避免tracketlist网站失效或无法访问，这里贴出里面的tracker列表 👉点我\n\n2.5 做种下载完成之后，qbt会自动做种\n下图是我昨晚下好的《西线无战事》已经开始做种了，当前比率为0.1，代表其他用户从我这里下走了整个资源的10%\n\n这里建议在设置-BitTorrent内设置分享率为1，即其他用户累计在你这里下走了一份完整的资源，相当于1换1\n\n如果你不在乎自己内网一直有上传，也可以不限制分享率，贡献肯定是越多越好的！\n同时你还可以限制一下上传和下载速度，避免nas的下载影响我们的网络环境。毕竟谁都不想nas在和打游戏的自己抢wifi带宽\n\n2.6 辅种前面提到过做种，再来谈谈辅种\n简单来说，辅种就是你在A站点下载了一个资源，发现在B站点有一个一模一样的的资源，包括文件结构、文件容量大小、文件格式、文件命名等等信息都完全一样\n这就代表你硬盘上的A站点资源和B站点的资源是完全一致的\n\n这也适用于某些奇怪的资源，qbt下载不下来，但是迅雷可以下载的资源；或者是迅雷下载速度是qbt几十倍的资源\n下载好了之后，可以使用qbt来辅种，提升他人的下载速度。让后人不要因为和你一样的原因去使用迅雷下载该资源\n\n以下图为例，我的硬盘上有一个《爱死机 第一季》的资源，但是我没有做种。此时就可以从资源站点下载种子文件（如果该站点只提供了磁链，可以用一些在线工具将该磁链转成种子文件）\n\n上传该种子文件，下载地址要选择和你硬盘上该种子地址的上级目录\n\n因为种子一般是以一个文件夹下载下来的，你应该选择的是这个文件夹所在目录，而不能直接选择该种子的文件夹\n\n如下图，我的资源是处于Love.Death.and.Robots (2019)目录中，那么我们填写的时候就只需要填写道这一级就行了。\n正确路径downloads/season/Love.Death.and.Robots (2019)/错误路径downloads/season/Love.Death.and.Robots (2019)/Love.Death.and.Robots.S01.1080p.NF.WEBRip.DDP5.1.x264-NTG[rartv]/\n\n注意，我这里是将本地的download文件夹映射给qbt的downloads文件夹，名字有一丢丢区别\n\n如果设置成功了，上传种子之后，应该显示的是校验，而不是重新下载\n\n如果出现了重新下载，说明你和该种子的资源文件夹名字不同，请检查一下文件夹名字\n也有可能你的资源和该种子并不是一个资源，无法进行辅种\n\n下图便是设置成功了，qbt正在校验文件\n\n文件校验成功，开始辅种！（这里我在qbt内修改了一下种子的名字）\n\n这样就OK了！你可以将一个下载好的资源的做种删除，尝试一下这个步骤\n\n3.jellyfin 电影海报墙威联通自带的vedio station挺不好用的。不知道是什么问题，我这里在后台点击大文件都无法播放，而是直接下载。这不是我想要的效果。\n而且威联通下载太多软件会影响系统运行速度，还不如不下！\n这里推荐大家docker下载jellyfin，效果很不错，能有海报墙\n至于电影介绍等等，它可能因为网络环境刷不出来，但我个人其实要海报就够了\n\n3.1 docker安装在container-station中搜索jellyfin，下载jellyfin/jellyfin这个镜像\n同样的，记得选择arm版本\n\nCPU限制60%，内存限制1024mb\n端口转发8096-TCP\n\n挂载文件需要挂载下面三个，同样的，cache和config文件夹建议挂载到ssd上，media则挂载一个装电影的共享文件夹\n\n点击应用，等待配置成功\n关于第二次配置无法连接问题如果你是第二次配置jf，可能会出现无法连接到服务器的报错\n\n解决方案：右键删除旧的服务器主机，ctrl+f5清除浏览器缓存，就能进入jf的初始化配置界面\n\n3.2 如何配置媒体库这里的文件夹，点击加号，就可以看到我们之前隐射的/media文件夹里面的内容，选择你自己的电影存放位置即可\n\n地区和语言设置如下\n\n建议勾选下面这个，保存海报图到电影同目录下\n\njf的刮削器（指自动下载电影信息）是不需要梯子的，点赞！\n配置好媒体库后，等jellyfin扫描你的电影。这部分很漫长，等它慢慢扫完吧！\n3.3 电影命名问题jellyfin官方提供了一个电影命名模板，实际上你没必要参考那个模板命名\n\n参考模板肯定是更好的\n\n他还是很智能的，你只要保证电影名字里面，有该电影的英文名+年份即可\n我的电影之前自己命名的时候，都在前面加了一个中文名，jf依旧正确刷出了电影海报~\n\n如果它找不到的电影，jf会从电影中截个图作为封面。但是这个截图，emmm很阴间！\n建议找不到的电影，自己去豆瓣下载一个海报，然后手动设置一下\n\njf是有一个豆瓣刮削器的插件的，但是该插件很久没有更新，现在已经不支持最新版本10.8.X的jf了\nhttps://github.com/Libitum/jellyfin-plugin-douban\n\n\n3.4 中文字幕乱码问题如果你的电影是外挂字幕，可能会遇到中文字幕是口口口的问题\n这需要我们去之前给jf映射的config文件夹中，添加一个fonts文件夹\n\n去网上下载一个中文字体，丢进去（建议字体文件不要大于20mb）\n注意：jf不支持选择字体，所以请不要下载多个字体，下载一个就行了！\n\n放进去后，在jf的控制台-播放中，设置备用字体路径+启用备用字体\n\n设置好了之后，控制台-扫描所有媒体库\n需要重新扫一下媒体库，这样就能解决口口口的问题了\n\n4.navidrome 音乐这是一个个人音频流媒体服务器，类似于jf\n如果你和我一样，音乐很多，那就可以用它节省一些手机的空间！\n威联通自带的音乐套件可以说不可用，我这边实测很多flac都放不出来🤔\n4.1 安装同样是去docker station里面下载，注意要下载deluan/navidrome\n\n弄最新版本就行了，不分x86和arm\n配置也很简单\n\ncpu限制20%，内存限制为256mb\n该容器负载极低，具体情况看歌曲的数量\n端口转发4533-TCP\n\n\n弄一个data文件夹和一个音乐文件夹，点击确认创建容器\n\n4.2 配置配置？不需要！它会自动扫描你的music文件夹，你什么都不需要做！\n\n默认的界面是英语的，点击右上角头像-Personal，语言改成简体中文就行了\n\n怎么使用就不介绍了，和音乐播放器完全一样\n\n安卓app：subtracker、substreamer（需要去谷歌商店下载）\n电脑客户端：Sonixd\n\n4.3 该容器的缺点来说一说我发现的一些缺点\n\n如果你发现同一个专辑出现了多个显示，需要用foobar2000等本地播放器，把源文件的专辑歌手改成一样的（此情况主要出现于某一个专辑内有多个歌手合唱的情况）\n不支持dsd播放\n不支持m4a播放\n不支持lrc外挂歌词，歌词必须写入文件属性中（这个真的很难受）\n\n注意，安卓手机app会在第一次连接的时候，初始化所有专辑封面信息。如果你的歌曲较多，外网访问就需要较大的带宽，否则app会直接闪退……\n\n5.未完待续等待后续更新吧……\n","categories":["捣鼓折腾nas"],"tags":["nas"]},{"title":"【公告】2023-01-13 站点更新keep版本，使用git管理主题","url":"/2023/01/09/code/%E5%8D%9A%E5%AE%A2%E5%8A%A8%E6%80%81/","content":"现在使用git的submodule 来管理keep主题文件\nhttps://zhuanlan.zhihu.com/p/87053283\n\n\n今天发现 jsdelivr 的 cdn挂掉了，导致很多资源都加载不出来，转为用nmpkg了。同时我缓存了 2.4.16 版本的waline文件，全都放在阿里云了。\n2023-01-09 站点页脚添加网站运行时间今天给站点页脚添加了网站运行时间，同时注释掉了底部的hexo提示框；还添加了一些shields.io的图标，感觉很不错！\n参考博客 hexo+yilia添加网站运行时间，ICP备案信息，设定站点建立时间\n\n\n2023-01-08 更新博客邮箱提醒的模板根据教程更新了vecrel中waline所使用的评论提醒模板，响应速度还是很快的，而且配置没有leancloud的邮箱提醒那么麻烦；\n不过我发现vercel的访问可能没有那么快速，有的时候会出现评论加载不出来的情况，需要多刷新几次！\n更详细的内容请看👉7-2-使用-Waline评论系统\n2023-01-07 加入开往这个也是在逛别人的主页的时候看到的，感觉很不错！那就加入吧！\n\nhttps://www.travellings.cn/\n开往是一个以跳转功能为主的友链接力项目，其名字“开往”取自“开放的网络”。\n将开往放入您的网页，表示您乐于分享并支持开放的网络。\n每当有人访问加入开往的网页时，点击“开往“会随机跳转到另一个加入开往的网页。之后，再次点击网页上的”开往“或后退网页，将继续随机跳转到另一个加入开往的网页。\n\n2023-01-06 更新keep版本啊呀呀，今天折腾了一整天，才把keep从3.4.5 -&gt; 3.5.2，因为我之前站点的个性化配置都是修改的npm包，结果发现一更新，包里面修改过的内容全没了！😥😥\n于是又根据自己写的教程，重新修改了一番，并给自定义过的背景添加了根据明暗自动变化颜色的功能（之前是没有的）\n而且评论系统也从 valine -&gt; waline，其主要的好处就是，waline 支持上传图片，用来在评论区回答一部分问题的时候，还是很方便的，不需要用户还去找个图床了。\n虽然折腾了非常非常久，还做了一些无用功，但是真的搞定的时候，还是很开心哒！\n2022-04-16 建站今天，基于 HEXO + KEEP 主题的站点终于建立起来啦！\n搭建这个站点的灵感来源于我在逛CSDN时候遇到的一个博主的个人站点，并发现了HEXO这个开源的博客搭建框架\n首个版本是基于 Gitee Pages 的，感觉还不错！\n使用hexo和keep主题搭建个人博客\n"},{"title":"【教程】hexo搭建博客+keep主题美化","url":"/2022/04/16/code/%E4%BD%BF%E7%94%A8HEXO%E5%92%8Ckeep%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"感谢你来到本小站，如果这篇博客对你有帮助，欢迎在下方评论😘！\n\n\n折腾了一整天，算是把基本的博客环境给搭建好了，页面效果还是挺不错的！后续对寒舍有什么新操作会对本文进行更新，可以多多关注一下哦\n\n本博客修改过的keep主题文件可以在这里查看👉Aewait&#x2F;hexo-theme-keep \n1.基本配置我最开始使用的平台是HEXO+Gitee，参考这篇博客👉基于Gitee+Hexo搭建个人博客\n现在我不建议你使用gitee pages，具体请看 4.1 \n可以根据本文向导配置 github pages，有问题可以评论提出哦╰(*°▽°*)╯\n\n操作之前，需要下载两个软件；先下载安装好node.js后再进行git操作\nnode.js：官网https://nodejs.org/zh-cn/git：官网https://git-scm.com/\n\n1.1 安装hexo安装好这两个工具后，我们先打开git bash（一般右键菜单里面就会有，如果找不到该软件请全局搜索）如果你安装的时候有选择添加到命令行，那么是可以直接用windows的cmd来操作git的。这里避免你安装的时候没有选择此项，均用git bash来演示\n\n【Git】在Windows CMD中和VScode中配置已经安装好的git\n\n打开之后的界面应该是这样的\n\n我们cd进入你想要创建hexo本地文件的路径，比如我想在D盘里面创建我的hexo博客，那么就cd进入你想要的路径；如果你不知道如何填写路径，可以右键顶栏将路径复制为文本\n\n然后在git bash中，使用 shift+insert(ins) 进行粘贴\ncd D:\\example\n\n这样我们就成功进入我们想要的文件夹了\n\n输入 node -v 命令，测试 node.js 是否安装成功且可用；如果出现版本号，就是安装成功了（请确认node.js的版本大于v12）\n$ node -vv16.13.1\n\n随后在这里执行以下命令\nnpm -g install npm #安装npm包管理器npm -g install cnpm --registry=https://registry.npm.taobao.org# 如果安装npm失败，则使用镜像源安装淘宝的cnpm# 如果安装了cnpm，注意后续所有npm命令要用cnpm代替\n\n安装成功后，安装hexo\nnpm install -g hexo-cli\n\n测试是否成功安装\nmoth@LAPTOP-R9S2524B MINGW32 /d/example$ hexo versionhexo-cli: 4.3.0os: win32 10.0.22000node: 16.13.1v8: 9.4.146.24-node.14uv: 1.42.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1l+quiccldr: 39.0icu: 69.1tz: 2021aunicode: 13.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV\n\n出现上面的字样，就是安装成功了；因为我是2022年\n4月操作的，这里安装的版本有点老，不过不影响使用，那就不升级了😶‍🌫️\n\n温馨提示：这些都是依赖项，如果不影响你的使用，那就不要升级！\n不要升级！不要升级！！不要升级！！！\n\n输入以下命令，我们会在当前文件夹创建一个blog文件夹，hexo会在里面克隆基础hexo需要用的文件\n$ hexo init blogINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitfatal: unable to access &#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054WARN  git clone failed. Copying data insteadINFO  Install dependenciesINFO  Start blogging with Hexo!\n\n使用cd命令进入blog文件夹\n$ cd blog\n\n随后输入下面三个命令\nhexo cl #hexo clean的缩写hexo g #生成文件hexo s #开启本地预览\n\n输出的结果如下\nmoth@LAPTOP-R9S2524B MINGW32 /d/example/blog$ hexo clINFO  Validating configmoth@LAPTOP-R9S2524B MINGW32 /d/example/blog$ hexo gINFO  Validating configINFO  Start processingINFO  Files loaded in 94 msINFO  Generated: archives/index.htmlINFO  Generated: archives/2023/index.htmlINFO  Generated: archives/2023/01/index.htmlINFO  Generated: index.htmlINFO  Generated: fancybox/blank.gifINFO  Generated: fancybox/helpers/fancybox_buttons.pngINFO  Generated: fancybox/fancybox_loading@2x.gifINFO  Generated: css/fonts/fontawesome-webfont.ttfINFO  Generated: fancybox/fancybox_loading.gifINFO  Generated: js/script.jsINFO  Generated: fancybox/fancybox_overlay.pngINFO  Generated: fancybox/fancybox_sprite@2x.pngINFO  Generated: fancybox/fancybox_sprite.pngINFO  Generated: css/fonts/FontAwesome.otfINFO  Generated: fancybox/jquery.fancybox.cssINFO  Generated: fancybox/helpers/jquery.fancybox-buttons.cssINFO  Generated: css/images/banner.jpgINFO  Generated: css/style.cssINFO  Generated: fancybox/helpers/jquery.fancybox-buttons.jsINFO  Generated: fancybox/jquery.fancybox.jsINFO  Generated: fancybox/helpers/jquery.fancybox-media.jsINFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.cssINFO  Generated: fancybox/jquery.fancybox.pack.jsINFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.jsINFO  Generated: 2023/01/10/hello-world/index.htmlINFO  Generated: css/fonts/fontawesome-webfont.svgINFO  Generated: css/fonts/fontawesome-webfont.woffINFO  Generated: css/fonts/fontawesome-webfont.eotINFO  28 files generated in 232 msmoth@LAPTOP-R9S2524B MINGW32 /d/example/blog$ hexo sINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n\n浏览器打开 http://localhost:4000，看到下面的预览，那就OK了！\n\n1.2 部署到github pages在Github创建一个新仓库，名字为 用户名.github.io\n找到blog目录下会有一个_config.yml 文件，这是hexo的配置文件。在里面找到下面的字段，填入你的github仓库地址\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: https://github.com/Aewait/Aewait.github.io.git  branch: master\n\n随后，我们执行hexo d 部署到远程仓库\nhexo d #部署hexo g --d #生成文件的同时部署，推荐使用这个\n\n如果出现下面的错误，那是很正常的，因为我们没有安装部署的依赖项\nERROR Deployer not found: git\n\n安装 hexo-deployer-git\nnpm install hexo-deployer-git --save\n\n再次执行hexo g --d，输入你的github账户（邮箱）和密码，进行部署。\n可以看到github仓库多了一个master分支，其内部就是我们的远端文件。\n进入仓库的设置，找到github pages的设置，选择master分支部署，按下图配置\n\n等待部署成功后，就可以打开 https://你的名字.github.io 就可以访问了！\n做完上面的步骤，此时就可以来安装一个主题了。毕竟默认的landscape主题还是不够好用的😘\n\nssh免密部署操作，参考第4点\n\n1.2 keep主题Hexo下keep主题初始化操作是根据开发者大哥的帮助文档进行的\n本文是对相关踩坑操作的一点说明，建议你先粗略浏览完本文，看看有啥坑🕳（挺多的）再进行keep主题的配置\n\nKeep快速开始\n\n如果你想使用其他hexo主题，建议选择有中文帮助文档的HEXO主题，不然就得啃英语了。\n后面本站样式可能会做其他的更改，待我搞清楚进阶操作再说。毕竟咱对CSS和HTML代码是完全不懂（这是前端的内容，目前没有自学计划）\n\n前人栽树后人乘凉，在keep开发者博客的友链中找到了魔改了主题的老哥，直接学习起来😍！hexo主题魔改汇总和总结\n更多内容详见本文 第8点\n\n当前你看到的主页已经是修改keep主题过后的啦！感觉如何？\n1.3 keep主题安装目录在哪？如果你更具keep的官方文档用npm安装，你可能发现在themes里面没有keep主题的文件夹，那它到哪儿去了呢？\n\n找一找就能发现，其实在这里 blog\\node_modules\\hexo-theme-keep。这是因为我的主题是用npm安装的，node_modules是在当前目录安装的包的位置，所以会出现这种情况\n\n需要注意，后续修改_comfig.yml的时候，有的时候需要修改的是主题的配置文件，有些是HEXO官方的配置文件，不要把二者弄混了！\n建议在hexo更目录的source/_data 文件夹中创建一个keep.yml，修改配置文件只需要修改这里的keep.yml即可，方便以后进行平滑升级\n1.4 主题页面设置成中文keep主题默认的页面是英文的按钮，需要在HEXO配置文件_comfig.yml中修改语言为zh-CN然后页面就变成中文啦！\n\n2.如何添加博客文章HEXO采用的是markdown语法，只需要在本地的source/_posts文件夹添加md源文件，就能在个人博客中显示\n以keep模板为例，我们需要在md源文件的正文之前添加如下语句，来设置博客的标题、上传时间、tag、分类，以及是否置顶\n\n如果要设置多个tag，样式为[Hexo,typora,博客]\n多个分类categories同理\n\n---title: 使用hexo+gitee搭建个人博客date: 2022-04-23 13:30:14tags: [Hexo]categories: [差生文具多]sticky: 999 ---\n\n2.1 首页置顶比如本文件的sticky我设置成了999，你看到的就是本文在我的首页置顶了。如果不设置sticky，首页默认是以时间降序排列文章（后发布的在前头）\n\n\n2.2 搭建图床（必做）本操作必做！为了保证你上传的md文件中的图片能在个人博客上正常显示，请先配置你的个人图床👉图床搭建教程\n如果你开启了阿里云OSS的bucket防盗链，还需要将你的站点加入白名单！\n2.3 如何导出CSDN的博客如果你之前的博客是在CSDN上写的，可以在markdown编辑器的文章管理面板中导出为md文件\n\n为了避免图片后续无法访问，建议上传一下csdn的图片到自己的图床（可以通过obsidian的插件快捷上传全文图片）\n\n3.图片无法显示问题3.1 解决：设置空referrer我们的博客网站向其他站点访问图片的时候，会发送一个 referrer 。有些站点是会block掉你的博客访问的，比如CSDN的图片链接。\n这部分是我在设置友链的时候发现的，有些朋友给我的头像链接是CSDN的图片链接，但是设置完毕后头像图片不显示。\n包括你的图床图片不显示，也可能是因为 referrer 问题；比如我就发现我的阿里云OSS图片，在本地 HEXO S 的时候，博客中的图片无法加载\n\n解决办法参考这篇博客👉Hexo博客不显示图床图片的解决方法\n\n具体操作是打开HEXO主题中包含全局网页head信息的文件（不同主题可能不一样，需要你找到主题的安装路径）keep主题是hexo-theme-keep\\layout\\_partial\\head.ejs\n\n打开后在里面添加这个语句，设置referrer为空\n&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;\n\n\n设置完毕后，应该就可以正常访问图床图片和CSDN的图片外链了\n4.ssh免密部署hexo cl //清除已有格式hexo g --d //将更改更新 并push到git仓库\n\ngit本地用命令行操作的时候，可能每一次hexo g --d操作都会让你输入一次账户和密码，我们只需要生成一个SSH公钥给git仓库，就能跳过这个操作\n\n具体生成操作可以查看这个博客👉如何使用ssh密钥配置git\n\n在设置好后，记得把hexo的_config文件中的https链接更换为ssh链接！\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:Aewait/Aewait.github.io.git  branch: master\n\n\n\n4.1 关于gitee和github的优劣咳咳，gitee的一些ex操作让我不得不换到了github！而且说句实话，虽然gitee服务器在国内，其gitee pages的访问速度真不见得比github快多少\n\ngithub无审查；gitee说我写的技术博客有问题，不给我部署，我一脸蒙蔽\ngithub在hexo g --d部署了之后能自动更新；gitee还需要你自己点一下更新按钮，很烦\ngithub可以免费绑定你自己的域名；gitee只有企业版才行\n\nhexo切换到github非常方便，在github中创建一个用户名.github.io的仓库，将你的hexo中_config.yml的远端仓库路径一改，部署了之后，直接就能正常访问！\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  #repo: git@gitee.com:ewait/ewait.git  #branch: master  repo: git@github.com:Aewait/Aewait.github.io.git  branch: master\n\n对事不对人，平台只是一个载体，分享技术才是重要的！\n4.2 netlifynetlify的部署非常容易，其访问速度比 github pages 快多了！实测netlify的延迟只有80ms，而 github pages 是200ms\n\n部署参考🦋Hexo+Github+Netlify部署个人博客\n\n最最最棒的一点是，netlify的部署速度很快，几乎是你 hexo d 刚刚上传到仓库，没过几秒他就部署成功了！\n你可以主要使用netlify，将 github.io 作为镜像站；不过这样的话，评论系统可能会出现一些问题，要注意别把评论系统弄boom了\n5.关于hexo文内toc问题keep模板已经自带了边栏toc，可以在右上角打开\n\n实际上，我们可以通过hexo-toc插件实现类似CSDN和typora的文章内toc（这个功能很多markdown编辑器都不支持，比如obsidian）\n\n\n文内toc插件安装参考了这篇知乎文章👉传送门\n\n在git里面输入以下命令\nnpm install hexo-toc --save\n\n插件安装完毕后，就可以在md文件的头部插入&lt;!-- toc --&gt; 来生成目录（在typora和csdn中是[TOC]格式）\n但是这个插件有一个问题，就是无法和keep模板的边栏toc同时使用。即使用了该插件后，边栏toc无法跳转，就只能二选一了。\n无奈只能卸载这个插件了，个人感觉还是边栏toc重要一点\nnpm remove hexo-toc --save\n\n6.自定义首页文章预览内容hexo本身支持自定义文件预览格式，在md文件中添加&lt;!-- more --&gt;就可以自定义文章预览显示的内容\n效果如下👇 建议不要在需要预览的内容中设置标题，不然看起来会非常怪异\n\n7.评论系统7.1 Valine评论系统后台如何查看评论在配置好Valine评论系统后，可以在leancloud后台管理中看到评论的html源码。\n但默认的排序的问题是，看不到用户是在那一篇文章下面评论的。我们可以通过调整内容排序（右上角那个带橙色圆点的按钮），把url往前移动，这样就能更方便地看到是谁评论了自己的博客，以及评论文章的位置\n\n7.1.1 leancloud邮箱提醒你可以利用valine插件admin来实现邮箱提醒\n\nGithub项目地址：DesertsP&#x2F;Valine-Admin\n\n但是这个插件需要你有一个备案过的域名！！！！\n然后我就在22-04-27这天发现，其实我设置的邮箱提醒已经生效了！😂真是一波三折（然后又挂了，参看 7.2 😥）\n大家根据这篇博客的教程进行邮件提醒的配置就OK了！valine评论系统使用\n\n7.1.2 关于云引擎500报错本部分更新于2023-01-05，今天更新了博客的url地址，然后就发现leancloud的邮箱提醒挂掉了，看后台会有一个这样的报错\n[2023-01-06T03:20:03.518063400Z][instance:web1] LeanEngine: /self_wake: 500: Error: undefined is not a valid uri or options object.[2023-01-06T03:20:03.518111500Z][instance:web1]     at request (/home/leanengine/app/node_modules/request/index.js:44:11)[2023-01-06T03:20:03.518117400Z][instance:web1]     at /home/leanengine/app/cloud.js:54:5[2023-01-06T03:20:03.518121000Z][instance:web1]     at /home/leanengine/app/node_modules/leanengine/lib/leanengine.js:202:14[2023-01-06T03:20:03.518124500Z][instance:web1]     at processTicksAndRejections (internal/process/task_queues.js:97:5)\n\n最终我百度到了这个issue，里面提到的和我的情况一模一样：邮件提醒报错，不知道为什么Error: undefined is not a valid uri or options object. #138 \n简单说来，就是云引擎需要绑定域名\n而我最开始选择的leadcould是在国内，域名必须要ipc备案才能正常绑定；如果需要用独立IP，那还得额外掏钱，50一个月实在是负担不起😥\n\n至于之前为啥邮箱提醒能用呢？我也不知道；我猜是leancloud最近更新了策略，就需要强制绑定才能用了……\n\n解决方法，使用国际版leancloud！\n7.2 使用 Waline评论系统这部分可以参考Waline的帮助文档，本站的评论系统也于 2023-01-06 从 valine 更换为了 waline，keep版本3.4.5-&gt;3.5.2\n\nWaline.js.org\nkeep使用waline\n\n配置好了 vercel 的自定义的域名之后，就可以通过下面两个方式来快捷管理\n评论系统：example.yourdomain.com评论管理：example.yourdomain.com/ui\n\n下图为更新前的valine评论界面\n\n以下为更新后的waline 界面，其支持上传图片！可惜默认只支持128kb，暂时还没有找到修改该限制的办法；对于我来说，waline最大的优势就是邮箱提醒功能可以很方便地用vecel的环境变量搞定，效果也很不错！\n\n7.2.1 自定义waline邮箱提醒模板\n参考👉waline 邮件通知模板样式一览\n\n为了避免源站无法访问，这里贴出当前我使用的邮件通知模板;\n注意，我是用vercel部署的，所以只需要修改环境变量就行了。如果你是其他部署方式，请参考上面博客中的详细教程!\nMAIL_SUBJECT\n&#123;&#123;parent.nick | safe&#125;&#125;，您在『&#123;&#123;site.name | safe&#125;&#125;』上的评论收到了来自  &#123;&#123;self.nick | safe&#125;&#125; 的回复\n\nMAIL_SUBJECT_ADMIN\n『&#123;&#123;site.name | safe&#125;&#125;』 上有新评论了\n\nMAIL_TEMPLATE\n&lt;div style=&quot;border-radius: 10px 10px 10px 10px;font-size:14px;color: #555555;width: 666px;font-family:&#x27;Century Gothic&#x27;,&#x27;Trebuchet MS&#x27;,&#x27;Hiragino Sans GB&#x27;,微软雅黑,&#x27;Microsoft Yahei&#x27;,Tahoma,Helvetica,Arial,&#x27;SimSun&#x27;,sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffffff repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);&quot;&gt;&lt;div style=&quot;width:100%;background:#49BDAD;color:#ffffff;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));background-image: -webkit-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;&quot;&gt;&lt;p style=&quot;font-size:15px;word-break:break-all;padding: 23px 32px;margin:0;background-color: hsla(0,0%,100%,.4);border-radius: 10px 10px 0 0;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #ffffff;&quot; href=&quot;&#123;&#123;site.url&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123;site.name&#125;&#125;&lt;/a&gt;上的留言有新回复啦！&lt;/p&gt;&lt;/div&gt;&lt;div style=&quot;margin:40px auto;width:90%&quot;&gt;&lt;p&gt;Hi, &#123;&#123;parent.nick&#125;&#125;，您曾在文章上发表评论：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;&#123;&#123;parent.comment | safe&#125;&#125;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;&#123;&#123;self.nick&#125;&#125;&lt;/strong&gt; 给您的回复如下：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;&#123;&#123;self.comment | safe&#125;&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;&#123;&#123;site.postUrl&#125;&#125;&quot; target=&quot;_blank&quot;&gt;查看回复的完整內容&lt;/a&gt;，欢迎再次光临&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;&#123;&#123;site.url&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123;site.name&#125;&#125;&lt;/a&gt;。&lt;hr /&gt;&lt;p style=&quot;font-size:12px;color:#b7adad&quot;&gt;本邮件为系统自动发送，请勿直接回复邮件哦，可到博文内容回复。&lt;/p&gt;&lt;/p&gt;&lt;style type=&quot;text/css&quot;&gt;a:link&#123;text-decoration:none&#125;a:visited&#123;text-decoration:none&#125;a:hover&#123;text-decoration:none&#125;a:active&#123;text-decoration:none&#125;&lt;/style&gt;&lt;/div&gt;&lt;/div&gt;\n\nMAIL_TEMPLATE_ADMIN\n&lt;div style=&quot;background-image: url(https://npm.elemecdn.com/sarakale-assets@v1/Article/email/bg.jpg);;padding:20px 0px 20px;margin:0px;background-color:#ded8ca;width:100%;&quot;&gt;&lt;div style=&quot;background: url(https://npm.elemecdn.com/sarakale-assets@v1/Article/email/leisi-714x62.png) repeat-y scroll top;&quot;&gt;&lt;div style=&quot;border-radius: 10px 10px 10px 10px;font-size:14px;color: #555555;width: 666px;font-family:&#x27;Century Gothic&#x27;,&#x27;Trebuchet MS&#x27;,&#x27;Hiragino Sans GB&#x27;,微软雅黑,&#x27;Microsoft Yahei&#x27;,Tahoma,Helvetica,Arial,&#x27;SimSun&#x27;,sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffe8dd61;box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);margin:auto&quot;&gt;&lt;img class=&quot;headerimg no-lightbox entered loaded&quot;src=&quot;https://npm.elemecdn.com/sarakale-assets@v1/bg/bg3.jpg&quot;style=&quot;width:100%;overflow:hidden;pointer-events:none&quot;data-ll-status=&quot;loaded&quot;&gt;&lt;div style=&quot;width:100%;color:#9d2850;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;background: url(https://npm.elemecdn.com/sarakale-assets@v1/Article/email/line034_666x66.png) left top no-repeat;&quot;&gt;&lt;p style=&quot;font-size:16px;font-weight: bold;text-align:center;word-break:break-all;padding: 23px 32px;margin:0;border-radius: 10px 10px 0 0;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #9d2850;&quot;href=&quot;&#123;&#123;site.url&#125;&#125;&quot;target=&quot;_blank&quot;&gt;&#123;&#123;site.name&#125;&#125;&lt;/a&gt;上的文章有了新的评论&lt;/p&gt;&lt;/div&gt;&lt;div style=&quot;margin:40px auto;width:90%;&quot;&gt;&lt;p&gt;&lt;strong&gt;&#123;&#123;self.nick&#125;&#125;&lt;/strong&gt;回复说：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:15px;color:#555555;&quot;&gt;&#123;&#123;self.comment|safe&#125;&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#cf5c83&quot;href=&quot;&#123;&#123;site.postUrl&#125;&#125;&quot;target=&quot;_blank&quot;&gt;查看回复的完整內容&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n\n7.2.2 163邮箱自定义发件人名字这里需要注意，官方给出了两个自定义邮箱发件人和发件邮箱的环境变量，其对于网易的163和126邮箱来说，你必须要设置成你的登录邮箱才可以，否则会报错，没办法发送邮箱\nSENDER_EMAIL 用来自定义发件邮箱，但是网易邮箱不支持SENDER_NAME  自定义发件人\n\n而且还有一点，就是这两个环境变量需要都加上，邮箱自定义发件人才能生效；\n如果你只设置了 SENDER_NAME 环境变量，而没有设置 SENDER_EMAIL，那么发件人是不会生效的，此时发件人会是你的邮箱，很难看；\n\n8.部分keep魔改记录除了第一点里面提到的博客，我还修改了其他一些内容，并对keep v3.5.2更新了的配置文件进行说明；以下是各个框的标号\n\n\n以下是不同框对应的配置文件路径和对应的类，帮助你找到他们的配置文件路径；更详细的介绍参考 hexo-keep首页样式自定义\n1  Hexo\\themes\\keep\\source\\css\\layout\\_partial\\header.styl   .header-wrapper &#123;&#125;2  Hexo\\themes\\keep\\source\\css\\layout\\page.styl   .page-container &#123;&#125;3  Hexo\\themes\\keep\\source\\css\\layout\\_partial\\first-screen.styl   .description &#123;&#125;4  Hexo\\themes\\keep\\source\\css\\layout\\_partial\\first-screen.styl   .s-icon-list &#123;&#125;5  Hexo\\themes\\keep\\source\\css\\layout\\page.styl   .page-main-content &#123;&#125;6  Hexo\\themes\\keep\\source\\css\\layout\\home-content.styl   .home-content-container &#123;&#125;7  Hexo\\themes\\keep\\source\\css\\layout\\home-content.styl   .home-article-item &#123;&#125;\n\n版本基于KEEP V3.5.2，如果你发现配置文件位置有变动，请在下方留言告知\n备注：keep不支持深层次的自定义页面，所有的修改都是针对 npm 包进行的，会在你更新keep的时候丢失！所以想折腾，建议做好不再更新keep的准备哦（除非你愿意每次都改一遍）🤣\n\nblog&#x2F;node_modules&#x2F;hexo-theme-keep\n\n如果觉得本站修改过后的样式很不错，那可以去我的Github仓库，直接把keep的模组下载后放到你的本地就可以了；这样就只需要修改 keep/source/css/layout/page.styl里面的两个背景图url就可以了！\n\n8.1 雪花飘飘我的主页有飘动的雪花，想知道怎么弄的？那就往下看吧！\n\n雪花代码来自博客👉hexo+next添加雪花飘落背景效果\n\n在Hexo-themes-keep\\source\\js下新建文件snow.js\n/*样式二*//* 控制下雪 */function snowFall(snow) &#123;    /* 可配置属性 */    snow = snow || &#123;&#125;;    this.maxFlake = snow.maxFlake || 200; /* 最多片数 */    this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */    this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.msRequestAnimationFrame ||    window.oRequestAnimationFrame ||    function (callback) &#123;        setTimeout(callback, 1000 / 60);    &#125;;cancelAnimationFrame = window.cancelAnimationFrame ||    window.mozCancelAnimationFrame ||    window.webkitCancelAnimationFrame ||    window.msCancelAnimationFrame ||    window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function () &#123;    /* 创建画布 */    snowCanvas.apply(this);    /* 创建雪花形状 */    createFlakes.apply(this);    /* 画雪 */    drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123;    /* 添加Dom结点 */    var snowcanvas = document.createElement(&quot;canvas&quot;);    snowcanvas.id = &quot;snowfall&quot;;    snowcanvas.width = window.innerWidth;    snowcanvas.height = document.body.clientHeight;    snowcanvas.setAttribute(&quot;style&quot;, &quot;position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;&quot;);    document.getElementsByTagName(&quot;body&quot;)[0].appendChild(snowcanvas);    this.canvas = snowcanvas;    this.ctx = snowcanvas.getContext(&quot;2d&quot;);    /* 窗口大小改变的处理 */    window.onresize = function () &#123;        snowcanvas.width = window.innerWidth;        /* snowcanvas.height = window.innerHeight */    &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123;    this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */    this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */    this.size = Math.random() * flakeSize + 2; /* 形状 */    this.maxSize = flakeSize; /* 最大形状 */    this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */    this.fallSpeed = fallSpeed; /* 坠落速度 */    this.velY = this.speed; /* Y方向速度 */    this.velX = 0; /* X方向速度 */    this.stepSize = Math.random() / 30; /* 步长 */    this.step = 0 /* 步数 */&#125;flakeMove.prototype.update = function () &#123;    var x = this.x,        y = this.y;    /* 左右摆动(余弦) */    this.velX *= 0.98;    if (this.velY &lt;= this.speed) &#123;        this.velY = this.speed    &#125;    this.velX += Math.cos(this.step += .05) * this.stepSize;    this.y += this.velY;    this.x += this.velX;    /* 飞出边界的处理 */    if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123;        this.reset(canvas.width, canvas.height)    &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function (width, height) &#123;    this.x = Math.floor(Math.random() * width);    this.y = 0;    this.size = Math.random() * this.maxSize + 2;    this.speed = Math.random() * 1 + this.fallSpeed;    this.velY = this.speed;    this.velX = 0;&#125;;// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function (ctx) &#123;    var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);    snowFlake.addColorStop(0, &quot;rgba(255, 255, 255, 0.9)&quot;); /* 此处是雪花颜色，默认是白色 */    snowFlake.addColorStop(.5, &quot;rgba(255, 255, 255, 0.5)&quot;); /* 若要改为其他颜色，请自行查 */    snowFlake.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;); /* 找16进制的RGB 颜色代码。 */    ctx.save();    ctx.fillStyle = snowFlake;    ctx.beginPath();    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);    ctx.fill();    ctx.restore();&#125;;/* 创建雪花-定义形状 */function createFlakes() &#123;    var maxFlake = this.maxFlake,        flakes = this.flakes = [],        canvas = this.canvas;    for (var i = 0; i &lt; maxFlake; i++) &#123;        flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed))    &#125;&#125;/* 画雪 */function drawSnow() &#123;    var maxFlake = this.maxFlake,        flakes = this.flakes;    ctx = this.ctx, canvas = this.canvas, that = this;    /* 清空雪花 */    ctx.clearRect(0, 0, canvas.width, canvas.height);    for (var e = 0; e &lt; maxFlake; e++) &#123;        flakes[e].update();        flakes[e].render(ctx);    &#125;    /*  一帧一帧的画 */    this.loop = requestAnimationFrame(function () &#123;        drawSnow.apply(that);    &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;    maxFlake: 60&#125;);snow.start();\n\n添加完成后，在 hexo-theme-keep\\layout\\layout.ejs 中添加如下引用\n&lt;script type = &quot;text/javascript&quot; src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;\n\n添加完成后的 layout.ejs 文件示例如下\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&lt;%= config.language %&gt;&quot;&gt;&lt;%- partial(&#x27;_partial/head&#x27;) %&gt;&lt;body&gt;&lt;%- body %&gt;&lt;%- partial(&#x27;_partial/scripts&#x27;) %&gt;&lt;script type = &quot;text/javascript&quot; src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n重新部署，就OK啦！\n8.2 首页描述字体的背景框和透明度这里对应的是3号框的文字\n修改hexo-theme-keep\\source\\css\\layout\\_partial\\first-screen.styl中以下部分，有注释的地方就是我修改了的地方\n.description &#123;  /*color $first-screen-font-color*/  color: rgb(255 250 250) /*字体颜色*/  font-weight bold  font-size $first-screen-font-size  line-height 1.8  text-align center  background: rgba(50,50,50,0.3); /*字体背景颜色和透明的*/  padding: 3px 15px; /*字体背景框的大小*/  border-radius: 5px; /*圆角*/        .desc-item &#123;    /*color $first-screen-font-color*/    color: rgb(255 250 250) /*字体颜色*/  &#125;  +keep-tablet() &#123;    font-size $first-screen-font-size * 0.9  &#125;&#125;\n\n修改了之后，首页居中的介绍文字就会变成当前的模样（之前的样式没有背景框，在自定义背景后很容易就看不清）\n\n同时我们还需要修改4号框，给它添加一个能够让它看得清的背景框（图标颜色没有办法修改，只能修改背景框颜色）\n\n4号框所在配置文件和3号框相同，找到.s-icon-list字段，添加以下内容\n.s-icon-list &#123;  background: rgba(220 220 220,0.3); /*字体背景颜色和透明的*/  padding:4px 11px 4px 11px; /*字体背景框的大小*/  border-radius: 5px; /*圆角*/  ...   &#125;\n\n8.3 顶部字体加粗\nhexo顶部底部透明度渐变\n\n参考这篇博客的 1-2, 修改 keep\\source\\css\\layout\\_partial\\header.styl\n找到以下代码\n.menu-item &#123;\tfloat: left;\tposition: relative;\tmargin-left: 30px;\tfont-size: 1rem;\tcursor: pointer;\tcolor: var(--default-text-color);\t......\n\n加一条font-weight: bold，修改结果：\n.menu-item &#123;\tfloat: left;\tposition: relative;\tmargin-left: 30px;\tfont-size: 1rem;\tfont-weight: bold;\tcursor: pointer;\tcolor: var(--default-text-color);\t......\n\n顶栏和底栏透明度渐变修改参考 8.5，我更新过后的方法可以让顶栏和底栏的透明度渐变随着明暗模式变化\n8.4 文章侧边栏toc更新了之后的侧边栏变到了页面的右边，且默认下是没有背景的（因为默认在文章页面也是纯白的，没有背景也能看得清）\n但是当下我已经设置了全局背景，所以就需要修改一下！\nkeep更新3.5.2之后的侧边栏配置文件变了,现在是在keep/source/css/layout/_partial/中的toc.styl\n.post-toc-wrap &#123;  position relative  box-sizing border-box  width 100%  height 100%  overflow-y auto  font-size 0.92rem  font-weight: bold /*字体加粗*/  border-radius: 5px; /*圆角*/  ...&#125;\n\n添加我注释了的这几项就OK了，如果你想要旧版样式（固定在左侧）可以尝试将position修改为fixed\n8.5 明暗模式适配修改完背景颜色和背景图之后，就会出现下面的情况：如果有用户的电脑是暗色模式，进入博客的时候，就会发现字完全看不清，整个界面都很难看\n\n解决办法那就是需要让我们的背景颜色能根据明暗自动切换！\n我们要做的，就是在 hexo-theme-keep\\source\\css\\ 中添加一个 my 文件夹，并在内部添加一个 user-style.styl\n// 全局背景的的颜色切换.dark-mode&#123;    --content-background-color:#37383fe6;&#125;.light-mode&#123;    --content-background-color:#ffffffe6;&#125;// toc栏大小.post-toc-wrap .post-toc .nav&#123;  padding:21px&#125;// 使toc能够更具明暗模式自动切换颜色.light-mode .post-toc-wrap &#123;    background-color: #ffffffe6;&#125;.dark-mode .post-toc-wrap &#123;    background-color: #37383fe6;&#125;// 顶部背景透明度渐变，明暗变化.light-mode .header-wrapper &#123;    background: linear-gradient(to bottom, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0.4));&#125;.dark-mode .header-wrapper &#123;    background: linear-gradient(to bottom, rgba(30, 30, 30, 1), rgba(30, 30, 30, 0.4));&#125;// 底部背景透明度渐变，明暗变化.light-mode .page-main-content-bottom &#123;  background: linear-gradient(to top, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4))/*透明度设置*/&#125;.dark-mode .page-main-content-bottom &#123;  background: linear-gradient(to top, rgba(30, 30, 30, 0.9), rgba(30, 30, 30, 0.4));&#125;\n\n写完后，在 css/style.styl 中引用这个文件就可以了\n@import &quot;my/user-style.styl&quot;\n\n刚开始我用的办法太蠢了，浪费了好多时间，而且经常失效。后来请教了一位会前端的朋友，他一下就帮我搞定了，呜呜呜呜😫\n\n按照上面修改了顶栏和底栏样式后，请不要开启keep配置文件中的header_transparent，否则两个效果叠加，主页顶栏会变得有些难看\n# Set transparent background for header.header_transparent: false  # Option values: true | false\n\n8.6 页脚自定义8.6.1 添加站点运行时间2023-01-09 添加了站点运行时间，删除了hexo的提示\n\n修改之后的完整文件请去我的 Github仓库 查看\n\n要想添加网站运行时间，keep主题修改 keep/layout/_partial/footer.ejs，找到如下代码\n&lt;% if (f_upyun) &#123; %&gt;    &lt;div class=&quot;ypyun-info info-item&quot;&gt;        &lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;&lt;%= f_upyun %&gt;&quot;&gt;        &lt;%- __(&#x27;footer_upyun&#x27;, &#x27;&lt;img src=&quot;/images/upyun.png&quot; height=&quot;20&quot;&gt;&#x27;) %&gt;        &lt;/a&gt;    &lt;/div&gt;&lt;% &#125; %&gt;    \n\n在下方添加如下代码，来自👉hexo+yilia添加网站运行时间\n源站的代码有点问题，详见该页面评论（有人指出，但作者没有更新正文）\n&lt;!-- 添加网站运行时间 --&gt;        &lt;% if (theme.running_time &amp;&amp; theme.running_time.enable &amp;&amp; theme.running_time.create_time) &#123; %&gt;            &lt;div class=&quot;timerun-info info-item&quot;&gt;                &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;                &lt;script&gt;                var now = new Date();                function createtime() &#123;                    //此处修改你的建站时间或者网站上线时间                    var create_time = &#x27;&lt;%- theme.running_time.create_time %&gt;&#x27;;                    var grt = new Date(create_time);                    now.setTime(now.getTime() + 250);                    days = (now - grt) / 1000 / 60 / 60 / 24;                    dnum = Math.floor(days);                    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);                    hnum = Math.floor(hours);                    if (String(hnum).length == 1) &#123;                        hnum = &quot;0&quot; + hnum;                    &#125;                    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);                    mnum = Math.floor(minutes);                    if (String(mnum).length == 1) &#123;                        mnum = &quot;0&quot; + mnum;                    &#125;                    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);                    snum = Math.round(seconds);                    if (String(snum).length == 1) &#123;                        snum = &quot;0&quot; + snum;                    &#125;                    document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot; + dnum + &quot; 天 &quot;;                    document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;                &#125;                setInterval(&quot;createtime()&quot;, 250);                &lt;/script&gt;            &lt;/div&gt;        &lt;% &#125; %&gt;        &lt;!-- 添加网站运行时间 --&gt;\n\n这里修改完毕后，还需要在keep的配置文件里面添加下面这一项；如果后续不想要了，可以直接设置为false禁用这一栏\n# 网站运行时间，格式形如：“本站已安全运行 101 天 12 小时 13 分 41 秒”# Runing Timerunning_time:  enable: true  create_time: &#x27;01/01/2021 00:00:00&#x27; #此处修改你的建站时间\n\n如果你想删除hexo的提示，那就注释掉 footer.ejs 的这些代码\n&lt;!--注释掉这里的代码，就可以取消底部的hexo标识--&gt;&lt;!-- &lt;div class=&quot;theme-info info-item&quot;&gt;    &lt;%- __(&#x27;powered_by&#x27;, &#x27;&lt;a target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) %&gt;&amp;nbsp;|&amp;nbsp;&lt;%- __(&#x27;theme&#x27;) %&gt;&amp;nbsp;&lt;a class=&quot;theme-version&quot; target=&quot;_blank&quot; href=&quot;https://github.com/XPoet/hexo-theme-keep&quot;&gt;Keep v3.5.2&lt;/a&gt;&lt;/div&gt; --&gt;\n\n8.6.2 修改页脚内容到底部的距离如图，这个页脚到底部的距离实在有点宽，弄得背景图都被挡住了好大一部分；对于强迫症来说，这谁受得了，改了！\n\n找到 hexo-theme-keep\\source\\css\\layout\\_partial 修改 footer.styl 的 padding-bottom\n.info-container &#123;  padding-bottom 1rem  text-align center&#125;\n\n默认是 1rem，这里我直接改成 0 看看是不是修改对地方了；hexo s 一看，直接靠底了，说明我们改对地方了！\n\n随后我就修改成了 0.3rem，还是需要留一点边距的\n8.6.3 修改页脚字体颜色\n配置了背景图之后，页脚的字体颜色不那么容易看清楚，这时候应该怎么办？改他丫的！\n在浏览器按F12进入开发者模式，用截图软件（qq截图或者sanipaste）选取到这个框上，就能看到颜色的色值\n\n复制该色值，在F12所打开的开发者面板中的页面一栏，粘贴搜索，可以看到 --text-color-4 正好就对应了这个颜色\n\n改成黑夜模式，重复上述步骤，可以看到，此时颜色依旧对应的是 --text-color-4 那么就实锤了该变量即为页脚字体颜色的变量\n\n直接在 8.5 中配置好的 user-style.styl 里面添加，自定义一个颜色；我们的需求是让黑夜模式的字体更亮，白天模式的字体更黑\n.dark-mode&#123;    --content-background-color:#37383fe6;    --text-color-4:\t#F5F5F5; //黑夜模式底部字体颜色&#125;.light-mode&#123;    --content-background-color:#ffffffe6;    --text-color-4: #242424; //白天模式底部字体颜色&#125;//...\n\n大功告成！\n\n8.6.4 页脚添加shields.io的图标为了更好的展示一部分内容，我们可以在页脚加上一些图标，并让这些图标可以点击跳转到指定页面！\n\nhttps://shields.io/\n\n修改 hexo-theme-keep\\source\\css\\layout\\_partial\\footer.ejs，在中间部分添加如下代码（直接跟在 8.6.1 配置的站点运行时间之后）\n如果你不知道具体的位置，还请移步我的Github仓库查看更改后的文件\n&lt;div class=&quot;shields-info info-item&quot;&gt;\t&lt;a href=&quot;link for click&quot; &gt;        &lt;img src=&quot;img url&quot; height=&quot;20px&quot;&gt;     &lt;/a&gt;&lt;/div&gt;\n\n这里的href后跟随的是点击图标会跳转的网页，img src后面跟随的是图片的url；\n\n比如我这样配置了之后，页脚就会出现一个这样的图标，用于标识我的hexo主题版本\n\n点击这个图标，会跳转到keep 主题的Github仓库；\n\n为了方便配置，写成下面的循环+if判断的形式；并且将图标的搞定锁定为20px，避免不同图标大小导致不统一，很难看\n&lt;!-- 添加底部的shields io图片 --&gt;      &lt;% if (theme.shields &amp;&amp; theme.shields.enable) &#123; %&gt;          &lt;div class=&quot;shields-info info-item&quot;&gt;              &lt;% for (var i in theme.shields.data)&#123; %&gt;                  &lt;% if (theme.shields.data[i].img) &#123; %&gt;                      &lt;a href=&quot;&lt;%= theme.shields.data[i].link%&gt;&quot; &gt;                          &lt;img src=&quot;&lt;%= theme.shields.data[i].img%&gt;&quot; height=&quot;20px&quot;&gt;                      &lt;/a&gt;                  &lt;% &#125; %&gt;              &lt;% &#125; %&gt;          &lt;/div&gt;      &lt;% &#125; %&gt;\n\n这样就可以直接在配置文件中添加新的图标和url，不需要来这里修改源码了！😁\n转到我们keep.yml配置文件，在最底部添加如下代码\n# Add shields.io in footershields:  enable: true # Option values: true | false  data:    hexo:      link: https://github.com/XPoet/hexo-theme-keep      img: https://img.shields.io/badge/hexo-keep%20v3.5.2-brightgreen\n\n这样就能在底部添加一个上面提到过的hexo主题图标\n要想追加，那就继续在后面以相同格式填写\n# Add shields.io in footershields:  enable: true # Option values: true | false  data:    hexo:      link: https://github.com/XPoet/hexo-theme-keep      img: https://img.shields.io/badge/hexo-keep%20v3.5.2-brightgreen    travelling:      link: https://www.travellings.cn/go.html      img: https://img1.imgtp.com/2023/01/09/c02alTih.gif\n\n代码会自动判断img是否为空，如果img为空，则不会添加该模块；link项可以为空，此时点击图标不会跳转到其他页面。\n效果还是不错哒！您可以在本页页脚查看😶‍🌫️\n未完待续…期待后续的更新，亦或者是我能从折腾中走出来，别再瞎搞了……\n今天的升级部署就花了几乎一整天的时间😥\n","categories":["差生文具多"],"tags":["Hexo"]},{"title":"【图床】博客表情包","url":"/2022/12/23/code/%E5%8D%9A%E5%AE%A2%E8%A1%A8%E6%83%85%E5%8C%85/","content":"这里是博客中可以用到的表情包列表，一并上传，避免多次上传占用阿里云空间;\n大家觉得不错的可以保存下来😁但是不要恶意使用！\n\n\n表情包\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["图床"]},{"title":"【Linux】使用腾讯云搭建CentOS的Linux编程学习环境，实现多用户使用同一个云服务器","url":"/2022/05/06/code/note_Linux/0%E8%85%BE%E8%AE%AF%E4%BA%91%E5%88%9D%E5%A7%8B%E5%8C%96CentOS7.6/","content":"为了帮助自己系统地学习Linux系统和命令行操作，我购入了腾讯云的轻量云服务器，预装了CentOS7.6系统\n\n\n本篇博客是一个笔记，记录了创建过程中遇到的一些问题，包括：\n\n云服务器多用户隔离使用（因为我的服务器是和同学一起拼购的）\ngit仓库ssh密匙设置\n设置Xshell用户名的显示颜色\n\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n以下是一个导读。其实不管是服主还是个人用户，都推荐使用以下阅读顺序\n\n如果你是服主，看本文的顺序是1→2(其中2.1跳过)→6→8→4.1\n配置好环境并下载好git后，服主就不需要做其他什么的了，就和其他人一起看完本文👇\n如果你不是服主，只需要看2.2.4连接上你的账户，即可开始操作第3、4、5、7点，可跳过4.2和4.3\n\n\n[TOC]\n1.云服务器初始化这部分tx云其实是有帮助文档的，但是它就是不在一个文档里面从头到尾写全，导致你需要翻来翻去找具体的操作，很恼火\n1.1购买云服务器选择腾讯云的理由很简单，现在它比阿里云便宜，2核心4GB的版本只需要168一年（作为对比，同时期阿里云没有打折，1核2GB的版本99一年）\n\n腾讯云校园计划https://cloud.tencent.com/act/campus\n\n注意：如果你只买一年，请不要购买下面的校园服务器！！！！购买校园服务器的资格只有一次，只买一年就花掉这个资格太不划算了！！！\n而且校园云服务器因为是“首单特惠”，是不支持同价续费的，续费价格也是天价！！！（续费要900多一年）\n在轻量应用服务器里面还有一个便宜的版本，2核2GB只要58一年，但是那个只能买一年，续费的价格很贵！！！（续费要900多一年）\n\n如果要买2-3年，请购买上面的校园服务器\n如果只买一年，请购买下面的这个58/年的版本【链接】\n\n\n\n注册腾讯云账户并实名认证后，就可以正常购买。这里不赘述了。\n我选择的系统是CentOS7.6，这个系统非常适合我们初学Linux\n\n\n1.2控制台管理创建完实例后，你应该就能在控制台里面看到你的云服务器了，右下角显示的是公网IP，我们后续使用Xshell链接的时候需要它\n\n进入后做的第一件事，就是充值你的root账户密码。建议设置的稍微复杂一点，一定要用小本本记下来！\n\n1.3下载Xshell我们需要用Xshell和Xftp作为我们的linux链接终端，点击官网链接下载\n\nhttps://www.xshell.com/zh/free-for-home-school/\n\n家庭和校园使用是免费的（个人用户）填了邮箱就可以了，官方会往你的邮箱里面发一个下载软件的链接\n完成上面三步后，现在已经可以连接我们的云服务器了\n\n2.连接云服务器2.0直接连接root账户你可以先使用root的账户密码以及公网ip连接服务器\n\n输入公网IP，端口号22不要改\n\n然后点击确认，系统会让你输入用户名和密码，使用用户名root和你刚刚设置的root密码就可以登录了\n\n还可以在tx云这里直接点登录，会使用tx云的默认账户lighthouse连接你的云主机\n\n\n\n这个方法只适合基础使用，下面讲解两个不同的方法\n\n\n2.1使用SSH密钥因为Xshell比较聪明，会帮我们记住账户密码，自动输入。但是在很多软件（比如putty）每次开启连接都需要输入账户和密码。这时候我们可以使用更加安全的加密SSH方式连接我们的终端\n\n如果你想达到多人一机的目的，请跳过本步骤，直接看2.2\n\n2.1.1创建本地密钥在Xshell的选项卡中，新建一个密匙\n\n无需修改默认参数\n\n这里会让你输入密匙名称和密码，请记住这里的密码！如果忘记了就只能重新生成一个密匙了\n\n\n生成完毕后，点击用户密匙管理者\n\n找到刚刚生成的密匙，点击属性-公钥，把这里的内容复制下来\n\n2.1.2绑定实例然后来到tx云控制台，密钥，点击创建密钥\n\n选择已有公钥，把刚刚复制的内容丢进去并起个名字。注意这里的地域必须和云服务选择的相同！\n\n搞定后，在云服务器的密钥对界面中绑定密钥（需要先把云服务器关机）\n\n绑定成功后，重启云服务器\n2.1.3Xshell会话设置新建一个会话，这里同样填公网ip\n\n然后需要设置用户身份验证，这里很重要！Xshell提示“密钥没有和云服务器绑定”都是因为这里没有设置！\n\n选择你创建的本地密匙，输入创建密匙时的密码！\n\n不出意外，设置完毕后，你就可以免登录连接到云服务器的root用户了\n\n这个方案只适用于单用户使用，如果多个用户想用这个方法连接同一个云服务器，就会出现大家一起用一个文件路径的问题（就比如我和同学拼，大家都用SSH连接了root用户，白搞）\n\n目前我没找到如何用SSH密匙连接到云服务器指定用户下\n\n2.2使用账户密码登录实现多人一机Linux系统是可以实现多用户管理的，首先我们要创建一个新的用户\n\n参考https://cloud.tencent.com/developer/ask/24465\n\n2.2.1创建新用户先用root连接终端，输入\nsudo useradd -g root 用户名\n\n这个命令的含义是在root分组下（这个是默认的分组）建立一个新的用户，用户名自定义\nsudo passwd 用户名\n\n然后使用这个命令设置刚刚创建的那个用户的密码\n随后，使用下面命令测试进入另外一个用户\nsu - 用户名\n\n因为我们是从具有最高权限的root用户进入子用户，所以是不需要输入密码的，但是如果你从子用户往root跑，就需要输入root用户的密码！\n\n你可以在root用户和子用户终端下用mkdir 文件夹名字创建两个不同的文件夹，ls查看当前路径下的文件夹\n你会发现，root和另外一个用户直接是相互看不到对方的文件夹的，这就是我们要达到的隔离效果！相当于互不干扰！\n从子用户A跑到子用户B中，需要输入子用户B的密码。\n这需要root用户在里面创建新的用户，所以服主是知道每个用户的密码的。这就看你们的信任问题了。如果真的信不过，就让每个人进root账户，自己设置自己账户的密码，那就没啥问题了\n2.2.2修改密码实际上，在自己的用户名下，是可以更改当前用户名的密码的\npasswd\n\n\n所以可以让服主创建好用户后，自己登陆进去，把自己的密码改掉\n\n注意：Linux学习中有时候会有一些指令只有root用户能干，所以最好是不要那么在乎这些“隐私问题”，root也公开给大家使用就行了\n\n一般情况下，直接在某一个语句之前加sudo，就会用上root权限\n2.2.3腾讯云多用户管理另外，腾讯云支持多用户管理，你可以在用户组这里邀请其他人，他们就能在自己的控制台里面看到你的云服务器了\n\n\n2.2.4Xshell使用账户密码连接这时候我们就不能使用ssh密钥登录了，而是使用账户和密码\n\n使用这个方式前，貌似需要在云服务器控制台解绑所有SSH密钥\n\n刚开始直接连接会显示“SSH服务器拒绝了密码”，这是因为我们没有开启允许密码登录\n\n\n参考https://cloud.tencent.com/developer/article/1909909\n\n在root用户下，使用vim打开下面这个文件。如果你不会使用vim编辑器，请见本文的第三点\nvim /etc/ssh/sshd_config\n\n在最后添加下面的这个语句，:wq!保存并退出\nPasswordAuthentication=yes\n\n\n搞定后，重启云主机，即可用账号密码登录其他账户\n\n如果设置了这个还是不行，可以在控制台中直接重置root密码。重置密码的时候会自动帮你设置好这个（如果没有就再手动设置一下，哈哈）\n\n\n\n在Xshell中直接用对应的账户和密码登录，就可以打开每个单独的账户\n\nX11警告是正常现象，请忽略它\n\n到这里，你就可以和好基友分享这个服务器了！成本大大降低\n2.3查看当前使用云服务器的用户在Xshell终端中输入who，可以查看当前有谁连接了云服务器\n这里会显示连接云服务器的时间，pts代表远程连接，/2代表不同的远程连接端口\n\n\n3.一些基本的Linux指令之前写博客的时候，忽略了大家可能都是第一次上手linux，对linux命令行一窍不通的。有朋友反应后面的git操作，很多部分都搞不明白怎么用\n这里列出本篇博客需要用到的一些linux指令和vim编辑器的指令。注意，这个只是帮助你完成本篇博客向导后续的git设置，并不是一个完整的命令行教学。建议自行搜索git命令行以及Linux命令行进行学习\n3.1Linux指令ls #显示当前路径下的所有文件ls -a #显示当前路径下包括隐藏文件的所有文件cd 文件路径   #打开对应文件路径cd ..   #回到上一个文件目录cd ~   #回到用户的根目录touch 文件名  #创建对应的文件mkdir 文件夹名字 #创建一个文件夹mv 源路径 目标路径 #移动文件夹或者文件#mv语句还用于重命名文件，操作是mv 原来的名字 新名字cat 文件名字  #显示对应文本文件的内容#如cat .gitconfig，会显示.gitconfig文件中的所有内容\n\n下图演示了部分语句，能帮助你理解这些命令的作用\n\n如果你不小心输错了某些指令或者指令没输入完毕就按了回车，可以使用ctrl+c终止当前操作，linux会另起一个新的入口给你输入命令\n\n3.2vim编辑器操作vim 文件名 #打开对应的文件进行写入\n\n这里我直接以编辑一个C++程序为例，演示vim的操作\n\n打开后是这样的，因为你的vim编辑器还没有设置（见本文第5点），所以和我的不一样，但是这不影响我们的操作。\n注意左下角是vim指令输入的位置以及vim当前模式的提示位置\n\n现在往这个文件中键入内容，你会发现无法键入，这是因为vim是查看模式，我们需要在英文模式下按键盘上的的i（中文模式按i是没有反应的）开启vim的插入模式（也就是insert模式）\n\n开启插入模式后，你就可以往这个文件里面写入内容了。注意vim编辑器是基于键盘的，你需要用键盘方向键定位位置，而不是用鼠标\n\n我往文件中新增了c++语法的内容，现在我想保存这个文件，并退出vim编辑器\n操作是先在英文模式下按键盘的ESC退出插入模式，然后输入:wq保存并退出文件\n\n这就回到了之前的linux命令行界面\n\n下面给出一些常用的vim指令，后续配置git的时候会用到\n:w  #保存文件，相当于windows的ctrl+s:q  #退出文件，前提是这个文件没有被更改#如果你不想保存刚刚的更改，可以使用:q! #强制退出文件:wq #保存并退出文件:wq! #因为部分文件是配置文件，系统权限不够，所以需要加!绕开#后续在编辑gitconfig文件的时候，就需要使用:wq!\n\n\n如果你想从windows中复制内容，粘贴到终端中，需要使用shift+ins键而不是使用ctrl+v\n复制ctrl+ins，粘贴 shift+ins\n如果你不小心习惯性地按了ctrl+s并发现系统卡住了，那是因为这个快捷键在Linux中是暂停终端，可以按ctrl+q复原\n\n上面讲述了vim的一些操作，下面让我们来尝试一下编一个代码\n3.3尝试编译代码C++需要使用g++编译器来编译代码，如果是C语言内容，则使用gcc来编译，操作是一样的\n以下面的指令编译我们刚刚写的代码文件，生成可执行文件TEST\ng++ test.cpp -o TEST\n\n可以看到编译器报错了，我们再vim回去修改代码\n\n修改完毕后，重新编译我们的代码，可以看到没有报错，生成了可执行文件TEST\n\n使用./TEST语句运行可执行文件TEST，即可看到程序输出结果\n\n好了，学会这些后，你应该就能完成后面git的配置操作了！😋\n\n4.Linux的git设置这里我们使用账户密码方式来配置我们的git，因为ssh密钥的方式出现了些许bug\n4.1下载git输入下面的指令查看git的版本，如果没有出现，那说明git没有被安装\ngit --version\n\nCentOS使用下面的指令安装，必须使用root用户。其他LINUX系统需要把yum改成apt-get\nsudo yum install git\n\n\n因为我之前用了树莓派，使用的是apt-get。在这上面不管用，我还去搜了好久为啥sudo: apt-get: command not found😥\n后面才知道CentOS使用的方法不一样\n4.2创建SSH密匙为了避免产生误导，且在我的环境下ssh配置git失败。这部分单独成文我建议是直接使用下面4.3的方式哈\n\nSSH方式不知为何，在我的云主机上，只有当次设置有效，重新打开终端连接云服务器（云服务器没有重启）SSH就会失效。在我的Linux用户目录下以及我朋友的用户目录下都出现了这个问题！\n\n\n如果你也出现了这个问题，请直接跳过4.2，使用4.3提到的账户密码方式\n如果你想学习SSH的方式，那也可以试试👉传送门\n\n22-06-19更新：这个问题已经被我解决，直接看传送门的那篇文章即可\n注：如果你是github用户，且使用https仓库链接时，多次遇到各种各样的无法连接问题，则需要切换使用ssh方式与github通信！这能解决大部分类似time out的网络问题\n\n\n4.3使用账户密码方式操作git其实在配置之前，我也不知道git config可不可以实现多用户独立上传，但是我知道（以为）SSH肯定可以😂\n\n现在ssh确认出了点问题，所以该用账户密码方式\n\n①配置全局git设置直接使用下面3个语句来设置某个Linux用户下的全局git邮箱和用户名\ngit config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;git config --global push.default current\n\n测试了一下--global指令后，发现它保存的文件是我们用户路径下的，而不是root下的全局目录。经过我和同学的测试，这个方法可以在每一次连接终端的时候都保存下来，不会出现SSH那个需要重新设置的情况\n使用下面这个指令可以查看git配置文件的内容，每个不同的Linux用户中，配置文件互不影响\ncat .gitconfig \n\n\n使用SSH的好处是不需要输入密码，不过我们可以用git指令来让git保存你的密码，这样也能在之后的上传中不需要输入密码，操作是编辑.gitconfig 文件，在最后加上这两行：作用是在下一次执行git push操作的时候，保存用户名和密码\n[credential]          helper = store\n\n使用vim .gitconfig修改后的配置文件应该和我这个相同\n[user]\temail = 你的gitee邮箱\tname = 用户名[push]\tdefault = current[credential]\thelper = store\n\n\n②克隆和上传操作使用mkdir 文件夹名创建一个文件夹，cd进去后，执行clone工作，这时候需要使用的是HTTPS链接\n\ngit clone 远程仓库的https链接\n\n\n如果你之前使用了SSH克隆了仓库，可以考虑重新克隆，也可以使用下面的语句更改仓库URL，注意这里的URL是新的地址\ngit remote set-url origin URL \n\ncd进入仓库目录，即可修改仓库中的文件\n\n修改完毕后，先用git status查看当前状态\n\n可以看到这里列出来我们的README文件被修改了，下面执行一次git push操作。这部分涉及到git命令行操作，如果你不会，可以搜几篇git的博客学习一下\ngit add 文件夹 #添加需要上传的文件路径git commit -m &quot;输入push信息&quot; #git push的信息\n\n这里的git add可以添加单个文件，也可以添加整个文件夹\n\ngit push #和远程仓库同步\n\n最后git push的时候，会提示让你输入远程仓库的用户名和密码\n我同学尝试的时候，这里出现了报错。本来我们以为是用户名或者密码有问题，一直在找到底是哪里出错了\nfatal: Authentication failed for &#x27;https://gitee.com/……&#x27;\n\n实际上是因为我们填错了！！！链接\n\n正确的填写方法应该是这样！！！我们错误的把第一个填了gitee的用户名，应该要填写的是gitee账户的邮箱\nUsername for &#x27;https://gitee.com&#x27;: 你的gitee邮箱Password for &#x27;https://xxxxx@gitee.com&#x27;: 填gitee密码\n\n注：这里填写密码的时候是不会显示内容的，直接盲打就可以了\n修改正确之后就可以正常PUSH代码了\n\n经过我和同学的测试，这个方法不会因为终端关闭而重置，可以多次复用且不需要每次都输入git的账户和密码，计划通！\n\ngit命令行语句的进阶学习👉传送门\n\n\n5.vim编辑器设置腾讯云的CentOS已经默认安装了vim编辑器，但是vim编辑器本身的默认设置和我们的习惯不同，比如tap它默认是8个空格（windows下是4个）以及缩进的一些问题，这就需要我们自己设置一下vim编辑器\nvim  ~/.vimrc\n\n用上面的语句打开vim编辑器后，用i开启vim的插入模式，输入下面的命令\nsyntax on #开启语法高亮set nu  #显示行号set tabstop=4 #设置tap为4个空格set softtabstop=4 set shiftwidth=4 set autoindent #自动对齐\n\n写完后，:wq!保存即可\n\n这里我给出了注释，实际写入配置文件的时候，请去掉注释\n\n6.将Linux命令行设置为中文以CentOS为例，默认的命令行显示是全英文的（但这不代表你不能在里面设置中文的文件夹名字）\n我们打开云服务器的root账户（必须是root账户）\nlocale\n\n使用上面的这个指令查看现在的语言，发现是en英文\n\nlocale -a\n\n使用上述命令查看当前支持的语言，会显示一大堆，滑到最底部，可以看到我这个系统里面已经有了zh-CN，支持中文！\n\n\n如果locale -a发现没有出现zh，那就下载中文支持包\n&gt;yum install kde-l10n-Chinese\n\n腾讯云的CentOS里面已经有中文了，所以不需要进行这一步操作\n\n\n修改系统语言为中文\nlocalectl set-locale LANG=zh_CN.utf8\n\n重启Xshell终端（不是重启云服务器），再次使用locale指令查看，发现已经设置成了中文语言包\n\n重启Xshell终端（不是重启云服务器），就可以看到，git这里的提示已经变成了中文。不然就是上文出现过的的英文页面👉回到上头康康\n\n修改Xshell中文显示字体如果你觉得默认的中文字体很难看，可以在Xshell中修改一下，点击左上角的文件-当前会话属性\n\n找到外观，把亚洲字体改成黑体，看起来就舒服多了\n\n这里还可以更改游标的样式，我改成了在windows中更熟悉的竖线样式\n7.Xshell设置用户名显示颜色\n参考https://blog.csdn.net/nmb_jiang/article/details/105195981\n\n默认情况下，Xshell显示的服务器用户名和名字都是白色的\n\n敲的命令多了之后，就分不清啥是啥了，眼睛都得瞎掉\n我们可以设置一下，以CentOS为例，需要用vim编辑器打开.bashrc文件\nvim .bashrc\n\n在打开的文件中，键入i开启vim的编辑模式，在文件的末尾输入\nPS1=&#x27;[\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]]\\$ &#x27;\n\n输入完毕后，按esc退出插入模式，输入:wq!保存该文件\n然后运行下面的指令使其生效\nsource .bashrc\n\n\n看起来就舒服多了\n另外，建议把root改成黄色+绿色的组合，和子用户区分开来。修改的方法是一样的\nPS1=&#x27;[\\[\\033[01;33m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;32m\\]\\w\\[\\033[00m\\]]\\$ &#x27;\n\n8.出现is not in the sudoers file解决方法\n当我们使用sudo命令切换用户的时候可能会遇到提示以下错误：用户名 is not in the sudoers file.\n\n我们需要把当前用户加入sudo的配置文件中\n在root用户下，打开sudo的配置文件\nvim /etc/sudoers\n\n打开这个文件，你会发现腾讯云的默认用户lighthouse已经添加过这个语句了。我们在最后加上xxx ALL=(ALL) ALL，其中xxx代表用户名\n\n结语看到这里，云Linux编程学习环境就搭建好啦！\n速速开始学习Linux命令行吧！👍\n\n\n有什么问题可以在评论区提出哦！\n\n","categories":["玩上Linux"],"tags":["Linux","git"]},{"title":"【Linux】环境变量","url":"/2022/10/05/code/note_Linux/10%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","content":"本篇博客记录了Linux下一些概念的解释，以及环境变量的相关操作\n\n\n\n所用系统：CentOS 7.6\n\n1.概念解释1.1 进程竞争性系统进程的数目较多。而CPU资源等其他资源不够用，所以进程之间存在竞争性，也就出现了优先级，这在上篇博客中有过介绍\n1.2 进程独立性进程运行具有独立性，不会因为某个进程出错，而影响其他进程的运行\n我们知道，一个进程是内核结构task_truck+代码和数据组成的。而linux系统是通过进程地址空间方式来保证进程的独立性，那是下篇博客会讲到的内容\n1.3 并行并行：多个进程在多个CPU下分割，同时运行\n\n我们一般的电脑都是只有1个cpu，那是怎么做到多个进程运行的？\n注意：多个进程都在系统中运行≠多个进程在系统中同时运行。要想知道这是怎么做到的，需要了解并发的概念\n1.4 并发大部分操作系统都是分时的，操作系统会给每一个进程赋予一个时间片，这样在一个调度周期中，可以调用到每一个需要运行的进程。\n这样，在一个时间段内，多个进程会通过交叉运行的方式，让每一个进程的代码，在这段时间内都能得到运行\n\n比如每一个进程运行10ms，假设有10个进程需要运行，那么在1s内，这10个进程都会被运行10次。1s=1000ms\n\ncpu进行多个进程的快速交替运行，以实现我们看到的单cpu运行多个进程的情况\n这种情况就叫做并发\n\n1.5  进程优先级管理操作系统正在运行一个低优先级进程的时候，突然来了一个高优先级数据怎么办？\n\n操作系统支持不同优先级进程的存在\n同一个优先级的进程可以存在多个\n操作系统是用队列来管理进程的，队列只支持支持尾删尾插\n\n这种情况要怎么处理呢？如果给队列头插，那不就破坏了队列的属性了？\n实际上，操作系统并不是用单一队列来进行管理的，而是用了一个哈希桶来进行处理\n\n可以理解为哈希桶是一个数组，后面链接了不同优先级的进程\n当一个更高优先级的进程需要运行的时候，操作系统只需要改变cpu当前运行队列在哈希桶里面的指向，即可马上完成高低优先级进程之间的切换\n操作系统还会管理一个位图，用于标识某一个优先级内是否存在进程\n\n哈希和位图这两个数据结构都会在C++的博客中讲解\n\n除了位图和哈希表之外，操作系统还会管理一个结构体，用于标识目前正在使用的进程哈希桶active，以及新进程的管理桶old\nstruct runqueue&#123;\thash_queue* active;\thash_queue* old;&#125;;\n\n当出现新进程的时候，操作系统不会把它直接链接到active里面，而是放入old中；\nactive内部的进程运行完了之后，只需要swap一下active/old指针，即可完成新进程表和运行完的旧表之间的交换！\n\n这种调度算法也被称为大O(1)调度法\n\n1.6 进程间切换CPU存在寄存器，这些寄存器储存了进程的临时数据\n\n寄存器分为可见寄存器（eax&#x2F;ebx）和不可见寄存器\n\n当进程在运行过程中，会产生各种临时数据\nint test()&#123;\tint a = 10;\treturn a;&#125;int main()&#123;    int b = test();    return 0;&#125;\n\n我们知道，定义在函数test中的a是一个局部变量，出了作用域就会销毁，那么main函数里面的b是怎么拿到test的返回值的？\n这里就用到了寄存器：a的值会先放入寄存器中，销毁了之后，再把寄存器里面的值赋值给b\n和内存一样，CPU只有一套寄存器。这一套寄存器在运行不同进程的时候，可以保存不同的临时数据\n\n这时候如果来了一个高优先级进程A，直接覆盖了正在运行的进程B及其寄存器中的数据，就可能导致进程B存在寄存器中的数据丢失，导致B无法继续运行\n\n所以，在进程的task_struct结构体中，就有一个专门的成员用于保存进程的上下文数据\n\n上下文数据：进程在运行中产生的各种临时数据\n当进程被剥离的时候，需要保存上下文数据\n当进程恢复运行的时候，需要重新加载上下文数据\n\n\n关于进程pcb和task_struct的内容可以看我之前的博客 进程概念\n\n2.环境变量2.1 引入环境变量当我们运行自己编译的一个可执行文件的时候，需要带上./指定路径\n\n使用file命令查看系统的相关指令，你会发现它们和我们自己写的mytest本质上是一样的，都是一个executable的可执行文件\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ file /bin/ls/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=c8ada1f7095f6b2bb7ddc848e088c2d615c3743e, stripped[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ file /bin/gcc/bin/gcc: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=84ea48c51fa70f8cd586b7801bc655487156db7b, stripped[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ file mytestmytest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=db352023d208d9f48899641c3536a8c13b7bc7bf, not stripped\n\n那为何运行诸如ls pwd gcc等等系统命令的时候，不需要在前面带上./路径来运行呢？\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ mytest-bash: mytest: command not found[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ lsmakefile  mytest  mytest.c\n\n这是因为：指向一个可执行程序，前提是需要找到它！\nlinux系统只能找到它自己预设好的命令，找不到我们的mytest\n在linux命令行中，输入env即可查看当前系统的环境变量\n\n其中PATH就是可执行程序存放的路径！系统就是通过环境变量来查找可执行程序的\n2.2 添加删除环境变量别急，我们先来学习一下怎么添加环境变量。实际上，我们的bash命令行里面是可以定义变量的，变量分为两种类型\n\n本地变量（局部）\n环境变量（全局）\n\n直接使用变量名=值的方式，就可以定义一个本地变量。使用echo命令可以查看这个本地变量。这时候我们用env | grep 变量名在环境变量里面查找，会发现当前的环境变量里面没有这个东西\n[muxue@bt-7274:~]$ aaaa=1234[muxue@bt-7274:~]$ echo $aaaa1234[muxue@bt-7274:~]$ env | grep aaaa[muxue@bt-7274:~]$\n\n这时候需要用export命令，创建一个环境变量\n[muxue@bt-7274:~]$ export bbbb=4321[muxue@bt-7274:~]$ env | grep bbbbbbbb=4321\n\n或者可以导入当前的本地变量\n[muxue@bt-7274:~]$ export aaaa[muxue@bt-7274:~]$ env | grep aaaaaaaa=1234\n\n删除的时候则使用unset命令取消环境变量\n[muxue@bt-7274:~]$ unset bbbb[muxue@bt-7274:~]$ env | grep bbbb[muxue@bt-7274:~]$ \n\n查看环境变量\necho: 显示某个环境变量值\nexport: 设置一个新的环境变量\nenv: 显示所有环境变量\nunset: 清除环境变量\nset: 显示本地定义的shell变量和环境变量\n\necho $环境变量名 #查看环境变量set | less #查看所有的shell变量和环境变量\n\n认识一些环境变量\nUSER：当前登录的用户\nHOME：当前用户的工作路径\nLANG：当前的语言和编码设定\nPATH：可执行命令的路径\nSHELL：当前使用的命令行是啥\nLOGNAME：当前登录的用户名\nPWD：当前所处路径\nOLDPWD：上一个路径，使用cd -跳回上一个路径\nHISTSIZE：系统会记录的历史命令条数\n\n我们可以用history命令查看之前运行过的命令，这里面保存的正好是3000条，和环境变量HISTSIZE的设置一致！\n[muxue@bt-7274:~]$ env | grep $HISTSIZEHISTSIZE=3000[muxue@bt-7274:~]$ history | wc --l3000\n\n需要注意的是，系统预载的环境变量都是在配置文件里面的。当前我们对环境变量做的任何操作都只会临时保存。关闭当前的命令行重新开一个，之前设置的环境变量就会消失\n[muxue@bt-7274:~]$ cat /etc/bashrc\n\n系统的环境变量配置文件为/etc/bashrc，用户的则为工作目录下的.bashrc以及.bash_profile\n\n2.3 环境变量PATH使用echo $PATH查看当前系统可执行文件的路径\n这里的路径都以:作为分割，linux查找命令的时候，就会在下面的这些路径里面查找\n[muxue@bt-7274:~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin\n\n除了直接使用ls，我们也可以使用路径的方式来调用ls\n[muxue@bt-7274:~]$ /usr/bin/ls bin  git  install.sh  kook  mon\n\n而如果想让系统能找到自己的可执行程序，就可以直接把可执行程序复制到这些路径中！\n给PATH中添加可执行文件[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ cp mytest ~/bin[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ mytesthello world!hello world!\n\n比如现在，我把mytest这个可执行程序复制到了~/bin也就是/home/muxue/bin的路径下，此时直接使用mytest就能找到对应的命令了！\n除了这种办法以外，我们还可以把当前的路径写入PATH环境变量中\n[muxue@bt-7274:~]$ export PATH=$PATH:/home/muxue/git/raspi/code/test#这样写是在原本的path后面追加内容。不能直接path=自己的路径，会直接覆盖[muxue@bt-7274:~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin:/home/muxue/git/raspi/code/test\n\n这时候直接执行mytest也成功了！\n[muxue@bt-7274:~]$ mytesthello world!hello world!hello world!\n\n前面提到了我们设置的这个环境变量都是临时的，所以重启了之后，自己设置的这个路径也会消失\n[muxue@bt-7274:~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin\n\n注意：一般情况下不建议在linux系统路径中安装自己的可执行程序，因为这样会污染系统的命令环境！\n3.C&#x2F;C++获取环境变量3.1 main函数的参数之前一直没有了解过这个知识点，C&#x2F;C++的main函数是可以带参数的！\n#include&lt;stdio.h&gt;//第一个参数指代命令个数，执行该可执行文件时传入的几个命令//第二个参数是一个指针数组，存放了每一个命令的常量字符串int main(int arg,char* argv[])&#123;    printf(&quot;arg: %d\\n&quot;,arg);    for(int i =0;i&lt;arg;i++)    &#123;        printf(&quot;argv[%d]: %s\\n&quot;,i,argv[i]);    &#125;    return 0;&#125;\n\n\n有了这两个参数，我们就可以利用它写一个命令行版本的计算器\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//main函数可以带参数//第一个参数指代命令个数，执行该可执行文件时传入的几个命令//第二个参数是一个指针数组，存放了每一个命令的常量字符串int main(int arg,char* argv[],char *envs[])&#123;    if(arg != 4)    &#123;        printf(&quot;Usage: %s [-a|-s|-m|-d] first second\\n&quot;, argv[0]);        return 0;    &#125;    int x = atoi(argv[2]);    int y = atoi(argv[3]);    if(strcmp(&quot;-a&quot;, argv[1]) ==0)    &#123;        printf(&quot;%d+%d=%d\\n&quot;,x, y, x + y);    &#125;    else if(strcmp(&quot;-s&quot;, argv[1]) ==0)    &#123;        printf(&quot;%d-%d=%d\\n&quot;,x, y, x - y);    &#125;    else if(strcmp(&quot;-m&quot;, argv[1]) ==0)    &#123;        printf(&quot;%d*%d=%d\\n&quot;,x, y, x * y);    &#125;    else if(strcmp(&quot;-d&quot;, argv[1]) ==0 &amp;&amp; y != 0)    &#123;        printf(&quot;%d/%d=%d\\n&quot;,x, y, x / y);    &#125;    else    &#123;        printf(&quot;Usage: %s [-a|-s|-m|-d] first second\\n&quot;, argv[0]);    &#125;    return 0;&#125;\n\n实现非常简单，其使用方法如下👇\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ gcc test.c -o test -std=c99[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -a 10 2010+20=30[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -s 10 2010-20=-10[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -m 10 3010*30=300[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test -d 30 1030/10=3[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test 1 1 1 1 Usage: ./test [-a|-s|-m|-d] first second\n\n上面这个小程序演示了main函数的参数的作用。\n看到这里，想必你应该不难理解linux系统的命令是如何使用参数的，诸如ls -l等等选项，其实都是通过main函数的参数实现的！\n通过main函数的参数，可以让同一个可执行文件依据命令输出不同的结果！\n3.2 使用第三个参数获取环境变量除了上面提到的main函数前两个参数，实际上main函数还可以带第三个参数！\n//第一个参数指代命令个数，执行该可执行文件时传入的几个命令//第二个参数是一个指针数组，存放了每一个命令的常量字符串//第三个参数用于导入环境变量！int main(int arg,char* argv[],char *envs[])&#123;    for(int i =0;envs[i];i++)    &#123;        printf(&quot;envs[%d]: %s\\n&quot;,i,envs[i]);    &#125;\treturn 0;&#125;\n\n因为envs是一个指针数组，所以可以通过判空来终止for循环\n\n在这个数组的最后，可以看到我们刚刚执行的命令也被写入了环境变量\n\n除了上面这个办法，我们还可以用下面两种方式来获取环境变量\nenviron外部导入环境变量C语言提供了一个environ来导入环境变量，其作用和main函数第三个参数是一样的\n\nextern char ** environ;printf(&quot;get env from [environ]\\n&quot;);for(int i = 0; environ[i]; i++)&#123;    printf(&quot;%d: %s\\n&quot;, i, environ[i]);&#125;\n\n\n其输出的结果也是一样的\ngetenv函数man getenv\n\n\n这个函数就能实现一些骚操作，比如写一个只有我自己可以运行的可执行文件\nint main(int arg,char* argv[],char *envs[])&#123;    char* user = getenv(&quot;USER&quot;);    if(strcasecmp(user,&quot;muxue&quot;)!=0)//strcasecmp忽略大小写    &#123;        printf(&quot;权限禁止！\\n&quot;);        return -1;    &#125;    printf(&quot;成功执行！\\n&quot;);    return 0;&#125;\n\n通过getenv函数获取到环境变量中的USER，判断其与我自己设定的user是否相同。如果不同就拒绝执行，相同才成功执行\n[muxue@bt-7274:~/git/raspi/code/22-10-04_环境变量]$ ./test成功执行！[root@bt-7274:/home/muxue/git/raspi/code/22-10-04_环境变量]# ./test权限禁止！\n\n可以看到，哪怕是root用户也搞不来这个可执行程序！\n\n4.关于本地变量的说明在2.2中提到了本地变量和环境变量的区别\n\n本地变量（局部）\n环境变量（全局）\n\n所谓的本地变量，其实是bash内部定义的变量。\n我们首先需要了解的是，linux下大部分的进程或命令都是以子进程方式运行的，其父进程都是当前打开的bash\n由此可知，bash内部的本地变量，并不会被这些子进程所继承\n而环境变量具有全局属性，可以被子进程继承并获取！\n\n那么问题来了，export/echo也是命令。如果它们也是子进程，那它们是怎么获取到bash内部的本地变量，并将其导入到环境变量中的呢？\nnope！实际上，这两个命令都是由bash自己执行的（调用自己的对应的函数完成功能）我们把这种命令称作内建命令\n结语关于环境变量的基本认识到这里就OVER啦。本博客是我的课堂笔记，难免会有问题，还请各位大佬指出~\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】进程地址空间","url":"/2022/10/07/code/note_Linux/11%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4_%E9%A1%B5%E8%A1%A8/","content":"本篇博客来认识一下linux下程序地址空间的概念\n\n\n\n演示所用系统：CentOS 7.6\n\n[TOC]\n1.引入程序地址空间之前学习C/C++的时候，多少应该都听过栈区&#x2F;堆区&#x2F;静态区&#x2F;全局区的概念，还有一张很经典的演示图，大部分讲解这几个内存区域的图片都和下图类似\n\n但是有一个问题，这里的程序地址空间，是我们的物理内存上的东西吗？\n并不是！\n\n程序&#x2F;进程地址空间是操作系统上的概念，它和我们物理内存本身不是一个东西\n\n\n1.1 验证不同区域用下面这个代码来简单验证一下不同区域上的区别\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int un_global_val;//未初始化全局变量int global_val=100;//已初始化全局变量//main函数的参数int main(int argc, char *argv[], char *env[])&#123;    printf(&quot;code addr         : %p\\n&quot;, main);    printf(&quot;init global addr  : %p\\n&quot;, &amp;global_val);    printf(&quot;uninit global addr: %p\\n&quot;, &amp;un_global_val);    char *m1 = (char*)malloc(100);    char *m2 = (char*)malloc(100);    char *m3 = (char*)malloc(100);    char *m4 = (char*)malloc(100);    int a = 100;    static int s = 100;    printf(&quot;heap addr         : %p\\n&quot;, m1);    printf(&quot;heap addr         : %p\\n&quot;, m2);    printf(&quot;heap addr         : %p\\n&quot;, m3);    printf(&quot;heap addr         : %p\\n&quot;, m4);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m1);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m2);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m3);    printf(&quot;stack addr        : %p\\n&quot;, &amp;m4);    printf(&quot;stack addr a      : %p\\n&quot;, &amp;a);    printf(&quot;stack addr s      : %p\\n&quot;, &amp;s);    printf(&quot;\\n&quot;);    for(int i = 0; i &lt; argc; i++)    &#123;        printf(&quot;argv addr         : %p\\n&quot;, argv[i]);    &#125;    printf(&quot;\\n&quot;);    for(int i =0 ; env[i];i++)    &#123;        printf(&quot;env addr          : %p\\n&quot;, env[i]);    &#125;    return 0;&#125;\n\n\n通过上面的测试，可以看到其结果和文章最开始的那张图相同。这里解释一下向上/向下的含义\n\n向上增长：向地址增大的方向增长\n向下增长：向地址减小的方向增长\n\n不过那个图片内部还少了一些东西，比如命令行参数和环境变量其实是存放在栈区之上的。补全之后的图片如下\n\n其中我们还可以发现，栈区和堆区之间有非常大的内存空隙\nheap addr         : 0x1a140f0heap addr         : 0x1a14160stack addr        : 0x7ffe6671ec60stack addr        : 0x7ffe6671ec58\n\n因为在C&#x2F;C++中定义的变量都是在栈上保存的，栈向下增长，先定义的变量地址较高！\nint a = 100;static int s = 100;\n\n关于函数中static修饰的变量，可以看到其地址空间属于全局静态区。虽然在函数中用static修饰是限制其只能在该函数内访问，但是该变量的声明周期是跟随整个程序的！\nstack addr a      : 0x7ffe6671ec44stack addr s      : 0x601048\n\n说了这么多，我们也没看看出来程序地址空间在哪儿啊？\n1.2 fork感知地址空间的存在下面可以用一个简单的fork代码来确认程序地址空间的存在！\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    int test = 10;    int ret = fork();    if(ret == 0)    &#123;        while(1)        &#123;            printf(&quot;我是子进程%d,ppid:%d,test:%d,&amp;test: %p\\n\\n&quot;,getpid(),getppid(),test,&amp;test);            sleep(1);        &#125;    &#125;    else    &#123;            while(1)        &#123;            printf(&quot;我是父进程%d,ppid:%d,test:%d,&amp;test: %p\\n\\n&quot;,getpid(),getppid(),test,&amp;test);            sleep(1);        &#125;    &#125;           return 0;&#125;\n\n依旧是最简单的一个fork代码，正常情况下，二者打印的结果应该是一样的！\n\n可如果我们在子进程中修改一下test呢？\n\n这时候就会发现一个离谱的现象：子进程和父进程打印的test值不一样，但是其地址却完全相同！\n如果我们在C/C++中使用的地址就是物理地址，是不可能出现这种情况的！怎么可能在物理内存的同一个地址访问出两个不同的结果呢？\n\n就好比张三和李四在同一天的同一时间去了AA路30号这个地址，不可能会出现张三去了发现是超市，而李四去了发现是医院的情况\n\n这便告诉我们了程序地址空间的存在，亦或者说，我们在编程中使用的地址都是虚拟地址\n2.简述程序地址空间每一个进程在启动的时候，都会让操作系统给其分配一个地址空间，这就是进程地址空间\n\n以先描述再组织的理念，进程地址空间其实是操作系统内核的一个数据结构struct mm_struct\n之前提到过进程具有独立性，在多进程运行的时候，需要独享各种资源。而进程地址空间的作用，就是让进程认为自己是独占操作系统中的所有资源！\n\n这个操作，其实就是操作系统给该进进程画了一个假的内存（虚拟地址）进程需要内存的时候，操作系统就会在页表里面画一个地址给他，再将该地址映射到物理内存上面\n\n问题：一个分页存储管理系统中，地址长度为 32 位，其中页号占 8 位，则页表长度是？\n解析：页号即页表项的序号，总共占8个二进制位，意味着页表项的个数就是2^8\n\n\n而当进程需要申请内存的时候，本质就是操作系统在mm_strcut中修改不同区域的end罢了！\n在Linux源码中可以看到这玩意的存在，其中的struct vm_area_struct * mmap;就是一个我们的虚拟地址管理的内核\n\n这里就能看到虚拟地址空间的start和end了！\n\n2.1 程序地址空间和代码编译\n程序地址空间不仅是操作系统需要考虑，我们用的编译器也会考虑这部分的内容\n\n我们知道，C语言代码需要经过预处理-编译-链接-汇编这几个步骤\n\n程序编译出来，没有被加载的时候，程序内部有地址（如果没有地址，无法进行链接）\n程序编译出来，没有被加载的时候，程序内部有区域（readelf -s 可执行文件可以查看区域）\n\n[muxue@bt-7274:~/git/raspi/code/22-10-07_程序地址空间]$ readelf -S testThere are 30 section headers, starting at offset 0x19f8:Section Headers:  [Nr] Name              Type             Address           Offset       Size              EntSize          Flags  Link  Info  Align  [ 0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0  [ 1] .interp           PROGBITS         0000000000400238  00000238       000000000000001c  0000000000000000   A       0     0     1  [ 2] .note.ABI-tag     NOTE             0000000000400254  00000254       0000000000000020  0000000000000000   A       0     0     4  [ 3] .note.gnu.build-i NOTE             0000000000400274  00000274       0000000000000024  0000000000000000   A       0     0     4  [ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298       000000000000001c  0000000000000000   A       5     0     8  [ 5] .dynsym           DYNSYM           00000000004002b8  000002b8       00000000000000c0  0000000000000018   A       6     1     8  [ 6] .dynstr           STRTAB           0000000000400378  00000378       0000000000000059  0000000000000000   A       0     0     1  [ 7] .gnu.version      VERSYM           00000000004003d2  000003d2       0000000000000010  0000000000000002   A       5     0     2  [ 8] .gnu.version_r    VERNEED          00000000004003e8  000003e8       0000000000000020  0000000000000000   A       6     1     8  [ 9] .rela.dyn         RELA             0000000000400408  00000408       0000000000000018  0000000000000018   A       5     0     8  [10] .rela.plt         RELA             0000000000400420  00000420       00000000000000a8  0000000000000018  AI       5    23     8  [11] .init             PROGBITS         00000000004004c8  000004c8       000000000000001a  0000000000000000  AX       0     0     4  [12] .plt              PROGBITS         00000000004004f0  000004f0       0000000000000080  0000000000000010  AX       0     0     16  [13] .text             PROGBITS         0000000000400570  00000570       00000000000001e2  0000000000000000  AX       0     0     16  [14] .fini             PROGBITS         0000000000400754  00000754       0000000000000009  0000000000000000  AX       0     0     4  [15] .rodata           PROGBITS         0000000000400760  00000760       000000000000005e  0000000000000000   A       0     0     8  [16] .eh_frame_hdr     PROGBITS         00000000004007c0  000007c0       0000000000000034  0000000000000000   A       0     0     4  [17] .eh_frame         PROGBITS         00000000004007f8  000007f8       00000000000000f4  0000000000000000   A       0     0     8  [18] .init_array       INIT_ARRAY       0000000000600e10  00000e10       0000000000000008  0000000000000008  WA       0     0     8  [19] .fini_array       FINI_ARRAY       0000000000600e18  00000e18       0000000000000008  0000000000000008  WA       0     0     8  [20] .jcr              PROGBITS         0000000000600e20  00000e20       0000000000000008  0000000000000000  WA       0     0     8  [21] .dynamic          DYNAMIC          0000000000600e28  00000e28       00000000000001d0  0000000000000010  WA       6     0     8  [22] .got              PROGBITS         0000000000600ff8  00000ff8       0000000000000008  0000000000000008  WA       0     0     8  [23] .got.plt          PROGBITS         0000000000601000  00001000       0000000000000050  0000000000000008  WA       0     0     8  [24] .data             PROGBITS         0000000000601050  00001050       0000000000000004  0000000000000000  WA       0     0     1  [25] .bss              NOBITS           0000000000601054  00001054       0000000000000004  0000000000000000  WA       0     0     1  [26] .comment          PROGBITS         0000000000000000  00001054       000000000000002d  0000000000000001  MS       0     0     1  [27] .symtab           SYMTAB           0000000000000000  00001088       0000000000000648  0000000000000018          28    46     8  [28] .strtab           STRTAB           0000000000000000  000016d0       000000000000021e  0000000000000000           0     0     1  [29] .shstrtab         STRTAB           0000000000000000  000018ee       0000000000000108  0000000000000000           0     0     1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),  L (link order), O (extra OS processing required), G (group), T (TLS),  C (compressed), x (unknown), o (OS specific), E (exclude),  l (large), p (processor specific)\n\n需要注意的是，程序内部的地址，和内存的地址没有关系\n可以理解为，我们程序内部都存放的是一个相对地址。编译程序的时候，认为程序是按照0000~FFFF进行编址的。\n当程序被加载到内存当中时，假设系统将该程序的代码从内存0x100开始加载，就可以依照程序编址的数据加上这个偏移量，从而存放在内存中。\n比如程序中有一个代码段的位置是0x1F，这时候在加载程序的时候，就会把这个代码段加上偏移量来加载\n\n\n\n代码地址\n虚拟地址\n\n\n\n0x1f\n0x11f\n\n\n0x20\n0x120\n\n\n大概就是这样，吧哩吧啦……\n2.2 写时拷贝现在就可以来解答一下1.2中出现的问题了\n\n当子进程尝试修改test变量的时候，操作系统就会开始一个写时拷贝，开辟一个新的空间，将对应的值考入该空间，再重新映射页表。\n这时候，虽然页表左侧的虚拟地址没有变化，但是映射的物理地址已经不一样了！\n\n这样就能保证父子进程的独立性，谁修改变量都互不影响！\n\n类似C++中实现的深拷贝！\n\n2.2.1 fork两个返回值的解释pid_t id这个变量属于父进程栈空间中定义的变量，但是fork内部，return会被执行两次（return的本质是通过寄存器将返回值写入到接收返回值的变量中）\n当id = fork()的时候，谁先返回，谁就会发生一次写时拷贝。所以同一个变量有不同的内容值，本质上也是同一个虚拟地址，对应了不同物理地址的体现！\n\n打印fork的返回值，即可观察到和1.2中一样的情况，虚拟地址相同，但是ret的值不同\n\n\n3.程序地址空间的作用需要注意的是，内存作为一个硬件，没有办法拒绝你的读写！内存是不带控制功能的！\n直接让用户修改物理内存风险极大：\n\n野指针问题\n用户可能直接修改操作系统需要用到的内存地址，导致系统boom\n\n程序地址空间让访问内存时添加了一层软硬件层，可以对转化过程进行审核，拦截非法的访问\n\n比如操作系统检测到进程在往虚拟地址的常量区读取数据的时候，不做阻拦；但是往常量区写入数据的时候，会进行拦截。这才是无法修改常量数据的真正原理\n\n\n保护内存\n可以使用进程管理更好的对功能模块进行解耦（linux内存管理）\n让程序&#x2F;进程可以用统一的方式&#x2F;视角来看待内存，以统一的方式编译加载所有可执行程序，简化程序本身的设计和实现\n\n同时，程序地址空间还可以延迟用户的内存使用。比如我们现在malloc了100个字节的空间，实际上操作系统并不会立马给你申请空间，而是操作你的mm_struct让进程以为自己已经申请成功了。当程序真正使用这个空间的时候，操作系统才会去物理内存中进行映射！\n\n申请的时候，是通过linux的内存管理模块进行操作的。同时，写时拷贝也是通过操作系统的内存管理模块来完成的！\n\n这种“延迟访问”，可以避免某些程序申请了内存而在一段时间内没有使用的问题！避免了内存资源的无效占用（也是一种浪费）\n4.页表前面只是对页表做了一个基本的解释，但页表并不单纯进行虚拟地址和物理地址的映射，其还会增添权限，是否命中的判断，以及U/K权限的标识\n\n\n权限：避免你修改const属性的数据\n是否命中：如果对于物理内存处没有数据，则没有命中；需要从硬盘中加载数据到内存中，将是否命中更改为是\nU&#x2F;K权限：用户级和内核级的差别，参考 linux信号 5.1中关于用户态和内核态的描述；避免用户态的进程执行内核态的源码\n\n前面提到，每一个进程都有一个独立的程序地址空间。要是页表只有一张的话，会发生什么事呢？\n以32位系统为例：\n\n内存一共有2^32次方个字节，也就是4Gb\n假设页表每一个字节的条目需要8个字节的空间，那就需要32G的空间来存放页表！\n页表肯定不能存在硬盘里面，但这么大的空间一般电脑的内存可放不下\n这也就告诉我们，页表并不是只有一张！\n\n页表实际上是有多张的👌\n4.1 分页存储当cpu访问进程地址空间的时候，其访问的其实是虚拟地址\n32位环境下，为了保证地址能覆盖到所有位置，每一个地址都有32个比特位；当MMU拿到虚拟地址的时候，其实会将虚拟地址拆分\n10     +    10     +    1201010101 00 01000111 11 00001011 1001xxxxxxxx xx yyyyyyyy yy zzzzzzzz zzzz\n\n\n这里面的前10位会用于在页目录中，用于查找二级页表\n中间10位会在二级页表中查找页，指向的是页在物理内存中的起始地址\n最后的12字节，一共是2^12=4kb，可以覆盖单个页的大小，是单个页中的偏移量\n\n这里又涉及到了一个知识点，那便是Linux下IO的基本单位是4kb\n有了这两级的页表后，第一级页表只需要2^10个条目，第二级页表有多个，每一个也是2^10个条目，最后再指向4kb的页\nlinux下有专门的结构体来描述单个页，和其他系统一样，有了对单个页的描述后，我们就可以用一个数组将页给管理起来。此时对内存的管理，就转换成了对数组的增删查改\nstruct page&#123;&#125;;\n\n页表实现了分离之后，就可以按需创建，不会出现一次性创建一个非常大的页表，导致内存空间都被占满的情况！\n\n最初的算法其实是有问题的，因为页表的映射并不需要对每一个字节进行映射。只需要映射到4kb即可，总共的条目是2^32 / 2^12 = 2^20个，所占用空间也没那么大了\n\n4.2 加载如果在寻址的时候，发现二级页表中所对应的page是NULL，那么代表该代码的数据没有被加载到内存中\n此时就可以从硬盘中加载，并把page的首地址给映射进二级页表中\n\n结语关于这部分的理解其实并不算十分透彻，或许在日后的项目实践中能加深理解呢~\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】进程控制","url":"/2022/10/15/code/note_Linux/12%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"阿巴阿巴，进程概念结束了，现在该学习如何控制一个进程了\n\n\n\n所用系统：CentOS 7.6\n\n[TOC]\n1.进程创建1.1 fork关于linux下的进程创建其实我们已经接触过了，那便是使用fork函数来进行操作\npid_t ret = fork();\n\nfork的返回值：子进程返回0、父进程返回子进程pid；出错返回-1\n\n小tips，其实pid_t就是int类型！\ntypedef __pid_t pid_t;\n\n在上篇程序地址空间的博客中已经提到，当一个进程调用fork函数的时候\n\n操作系统会给子进程分配一个新的内存块mm_struct+页表和内核数据结构task_strcut给子进程\n将父进程的部分数据结构拷贝自子进程（写时拷贝）\n将子进程添加系统进程列表当中\nfork返回，开始调度器调度\n\n简单说来，便是fork之前只有父进程单独运行。fork之后父子进程的执行流会分别执行，且相互独立\n\nfork之后，是父进程先执行还是子进程先执行依赖于调度器的调度。并非一定是父进程先执行！\n\n需要注意的是，子进程虽然共享父进程的所有代码，但是它只能从fork之后开始执行\n这里涉及到了cpu的eip程序计数器（又称pc指针）这玩意的作用就是保存当前正在执行的指令的下一条指令！\n\n注意，这里说的是CPU执行的指令，并非linux下bash里面的命令\n\neip程序计数器会把下一个指令拷贝给子进程，子进程就会从该eip所指向的代码处（即fork之后的代码）开始运行\nfork啥时候会出错如果你写一个循环代码一直创建子进程，那么就有可能创建失败！\n能够创建的子进程个数依赖于代码的复杂度\nfork的小题目\n1.2 写时拷贝之前已经提到过写时拷贝的概念，这里再次说明一番\n\n\n为什么要写时拷贝，创建子进程的时候直接把数据分开不行吗\n\n答，这样会存在内存浪费！\n\n一般情况下，父进程创建子进程之后，会出现下面的一些情况\n\n父进程的代码和数据，子进程不一定全部都会使用。即便使用、也不一定会进行修改\n理想状态下，可以把父子进程会修改的内容进行分离，不会修改的部分共享即可。但是这样的实现非常复杂\n如果fork的时候，就直接分离父子进程的数据，会增加fork运行的时间复杂度和空间复杂度\n\n所以最终linux采用了写时拷贝的方式，只会在需要的时候，拷贝父子需要修改的数据。这样延迟拷贝，变相提高了内存的使用率\n2.进程终止2.1 程序退出码在之前学习C&#x2F;C++的时候，我们知道main函数是一个程序的入口函数，那么你知道main函数内部的返回有何用，又被谁接收了吗？\nint main()&#123;\treturn 0;&#125;\n\n使用echo $?命令查看环境变量，可以看到我们进程的推出码\n\nint main()&#123;\treturn 10;&#125;\n\n修改对应的返回值，再次运行程序，可以看到不同的结果\n\n知识点：?环境变量存放的是上一次运行的程序的退出码\n[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ echo $?10[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ echo $?0\n\n比如这里我们连续两次访问这个环境变量，可以看到第一次的结果是我们自己运行的程序返回的10，第二次的结果是0（echo命令的返回值）\n\n2.1.1 strerror那么，这个程序退出码有什么含义呢？\n这里我们使用for循环打印一下库函数中strerrror函数内记录的错误码\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;    int i=0;    for(i=0;i&lt;100;i++)    &#123;        printf(&quot;[%d] %s\\n&quot;,i,strerror(i));    &#125;    return 0;&#125;\n\n可以看到，100个错误码被打印了出来\n\n进一步加大循环的次数，能看到C语言中定义的错误码一共是134个。后续全部打印unknown error\n\n我们设计程序的退出码的时候，可以参照C语言库函数的错误码来进行设置，这样能更好地和库内部进行对接，或用strerror函数来获取到错误信息\n\n这就是用错误码来实现的异常管理\n\n2.2 程序退出的几种状态一般情况下，程序有下面的几种退出状态：\n\n代码跑完，结果与预期相符\n代码跑完，结果有问题\n代码没有跑完，提前出现异常终止，或者被外部关闭\n\n一般情况下，我们不会去在乎一个进程为何会成功；而更在乎一个错误的进程到底哪儿有bug。所以就需要想办法获取到这个进程的错误码\n错误码表征了程序退出的信息，交由父进程进行读取\n上面我们在bash中能通过echo读取上一个进程的退出码，那是因为我们自己运行的可执行程序，其父进程就为当前的bash。bash接受了我们进程的退出码，放入到了环境变量中\n\n2.3 终止的常见做法一般情况下，我们可以在main函数中return，或者在任何地方使用exit()来终止程序\n这里还需要提及另外一个版本的exit()，即_exit\n\n最可见的区别便是，exit会刷新缓冲区，而_exit不会\nvoid test2()&#123;    printf(&quot;i&#x27;m good, exit&quot;);    exit(0);&#125;void test3()&#123;    printf(&quot;i&#x27;m good, _exit&quot;);    _exit(0);&#125;\n\n这里我先调用test2函数，输出的结果是这样的👇\n[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ gcc test_strerror.c -o test &amp;&amp; ./testi&#x27;m good, exit[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ \n\n如果调用的是test3，则会出现下面的情况\n[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ gcc test_strerror.c -o test &amp;&amp; ./test[muxue@bt-7274:~/git/linux/code/22-10-08_进程控制]$ \n\n程序什么都没有打印！\n缓冲区这部分是基础IO的知识\nlinux下有一个输入输出的缓冲区，当我们调用printf的时候，系统不会立马打印，而是会将待打印的内容先写入缓冲区，直到我们输出\\n或者调用fflush函数手动刷新缓冲区。\nfflush(stdout);//手动刷新缓冲区\n\nexit和_exit在_exit的man手册中也能看到，该函数会立即干掉这个进程；而exit还会做一些其他的操作\n\n2.4 终止的时候，内核做了什么？我们知道，进程&#x3D;内核结构task/mm_struct等+进程代码、数据\n操作系统可能并不会释放该进程的task_struct/mm_struct，而是留给下一个进程使用！\n要知道，如果想使用一个结构体，就需要对它进行开空间和初始化操作。而在操作系统中，创建、终止进程是一个非常高频的操作。如果总是不断的创建内核结构再释放，其内存利用率就很低，而且拖慢系统运行速度。\n这时候系统就会使用内核的数据结构缓冲池，又称slab分派器，来管理这些仍待使用的内核结构。当有新进程出现的时候，更新内核结构的信息，并将其插入到运行队列中\n\n3.进程等待之前讲过子进程退出，父进程如果不管不顾，就会造成僵尸进程的问题，从而导致内存泄漏等一系列问题\n\n另外，僵尸进程一旦出现，即便是kill -9也无法杀掉这个进程\n\n所以父进程需要监看子进程的退出状态，并进行相应的操作\n父进程通过进程等待的方式回收子进程资源，获取子进程的退出信息\n\n3.1 如何等待进程等待这里我们需要用到两个函数\npid_t wait(int*status);pid_t waitpid(pid_t pid, int *status, int options);\n\n它们的头文件是\n#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;\n\n3.2 wait先来康康第一个，其作用是等待子进程退出，status是一个输出型参数，子进程退出后，我们可以从中获取到子进程的退出信息\n\nstatus是从子进程的task_struct中拿出来的，子进程会将自己的退出码写入task_struct\n如果我们不关心子进程的退出状态，则可以给status传一个NULL空指针\n若等待失败，则返回-1\n\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 5;        while(i--)        &#123;            printf(&quot;我是子进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);            sleep(1);        &#125;        printf(&quot;子进程退出\\n&quot;);        exit(0);    &#125;    else    &#123;            printf(&quot;我是父进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(5);        int status = 0;        pid_t st = wait(&amp;status);        printf(&quot;等待成功,子进程pid:%d, 状态信息：%d\\n&quot;,st,status);        sleep(5);    &#125;           return 0;&#125;\n\n\n嗯，看起来没啥问题，我们成功获取了子进程的pid以及退出码0\n那如果我们修改一下子进程中exit的值呢？\nexit(11);\n\n\n呀，出问题了，为何状态码变成2816了？\n3.2.1 关于status实际上，输出型参数中status的值并非是完整的退出状态信息，其分为下面两种情况\n\n所以说，正确访问状态码的方式，是先将status右移8位，再用按位与取出状态码\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 5;        while(i--)        &#123;            printf(&quot;我是子进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n&quot;,getpid(),getppid(),ret,&amp;ret);            //i++;            sleep(1);        &#125;        printf(&quot;子进程退出\\n&quot;);        exit(11);    &#125;    else    &#123;            printf(&quot;我是父进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(5);        int status = 0;        pid_t st = wait(&amp;status);        //printf(&quot;等待成功,子进程pid:%d, 状态信息：%d\\n&quot;,st,status);//直接打印status是错误的！        //status的低16位才有效，其中这16位的高8位是状态码        printf(&quot;等待成功,子进程pid:%d, 状态信息：%d\\n&quot;,st,(status&gt;&gt;8)&amp;0xFF);//0xff是8个1        sleep(5);    &#125;           return 0;&#125;\n\n\n再来修改一下exit的值为200，依旧正确！\n子进程退出等待成功,子进程pid:770, 状态信息：200\n\n\n3.3 waitpid该函数的原型如下\npid_t waitpid(pid_t pid, int *status, int options);\n\n\npid：&gt;0指定等待子进程pid；-1等待所有子进程\nstatus：同wait，为输出型参数\noptions：若设置为0，则进行阻塞等待；其余选项见下图\n\n\n返回值：\n\n正常返回子进程的pid\n如果设置了options，而waitpid发现没有已退出的子进程可收集，返回0\n调用中出错，返回-1。此时errno会被设置成相对应的值来显示错误\n\nint main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 4;        while(i--)        &#123;            printf(&quot;我是子进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n&quot;,getpid(),getppid(),ret,&amp;ret);            //i++;            sleep(1);        &#125;        printf(&quot;子进程退出\\n&quot;);        exit(0);    &#125;    else    &#123;            printf(&quot;我是父进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(5);        int status = 0;        pid_t st = waitpid(ret,&amp;status,0);//指定等待上面创建的子进程        //status的低16位才有效，其中这16位的高8位是状态码        printf(&quot;等待成功,子进程pid:%d, 状态信息：%d\\n&quot;,st,(status&gt;&gt;8)&amp;0xFF);//0xff是8个1        sleep(5);    &#125;          return 0;&#125;\n\n\n3.4 信号终止目前linux支持的信号如下，在后续信号的章节会单独讲解！\n\n\n前面提到了，除了正常的终止，status中还可以保存信号终止的信息\n\n这里的core dump标志是用来干嘛的我们暂且不提（后续信号部分会有讲解）先来试试用kill来干掉子进程！\n这里我们要取出的是status中最低7位的数据，就需要按位与一个二进制末尾是7个1的数字\n注意：如果子进程是因为信号退出，那么我们不需要关注退出码，其没有意义！\nint main()&#123;    int test = 10;    pid_t ret = fork();    if(ret == 0)    &#123;        int i = 20;        while(i--)        &#123;            printf(&quot;我是子进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n&quot;,getpid(),getppid(),ret,&amp;ret);            //i++;            sleep(1);        &#125;        printf(&quot;子进程退出\\n&quot;);        exit(0);    &#125;    else    &#123;            printf(&quot;我是父进程%-5d, ppid:%-5d, ret:%-5d, &amp;ret:%p\\n\\n&quot;,getpid(),getppid(),ret,&amp;ret);        sleep(30);        int status = 0;        pid_t st = waitpid(ret,&amp;status,0);//指定等待上面创建的子进程        //status的低16位才有效，其中这16位的高8位是状态码        printf(&quot;等待成功,子进程pid:%d, 状态：%d，信号：%d\\n&quot;,st,(status&gt;&gt;8)&amp;0xFF,status&amp;0x7F);//0xff是8个1        sleep(10);    &#125;          return 0;&#125;\n\n 程序最开始的时候，子进程正常创建，父进程等待子进程结束\n\n这里使用kill给子进程发信号，干掉了子进程\n[muxue@bt-7274:~/git/c_code]$ kill -9 5952[muxue@bt-7274:~/git/c_code]$ \n\n父进程sleep结束后执行waitpid获取到了子进程的结束信息以及信号9\n\n同时通过之前写的检测脚本\nwhile :; do ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\n能看到子进程进入z僵尸状态\n\n父进程回收子进程的过程\n\n换一个kill的信号，父进程也能正确获得其结果\n[muxue@bt-7274:~/git/c_code]$ kill -30 7607[muxue@bt-7274:~/git/c_code]$ \n\n我是子进程7607 , ppid:7606 , ret:0    , &amp;ret:0x7ffccf2aeb20我是子进程7607 , ppid:7606 , ret:0    , &amp;ret:0x7ffccf2aeb20等待成功,子进程pid:7607, 状态：0，信号：30\n\n除了我们可以手动使用kill 给进程发信号，一些错误也会让进程自己退出。比如信号8就是浮点数错误，可以用除0来复现这个错误\n操作系统是怎么知道我们除0了？\n\n在CPU内有一个状态寄存器，当cpu进行运算的时候出错了，会更新状态寄存器。操作系统检测到CPU用状态寄存器给他报了个错，就会识别错误类型，并通过信号干掉当前运行的进程\n我们运行的进程中的软件错误，部分是会在硬件层面上体现的\n\n3.5 库里面提供的宏自己写按位与多麻烦呀，库里面提供了几个宏供我们使用\n\nWIFEXITED(status)  查看子进程是否是正常退出的，正常退出为真\nWIFSIGNALED(status)查看子进程是否为信号终止，信号终止返回真\nWEXITSTATUS(status) 提取子进程退出码\nWTERMSIG(status) 提取子进程退出信号\n\n//其余部分代码和上面相同，子进程exit(11)int status = 0;pid_t st = waitpid(ret,&amp;status,0);//指定等待上面创建的子进程if(WIFEXITED(status))//子进程正常退出返回真&#123;       printf(&quot;等待成功,子进程pid:%d, 状态：%d，信号：%d\\n&quot;,st,WEXITSTATUS(status),WTERMSIG(status));&#125;else&#123;    printf(&quot;非正常退出,子进程pid:%d, 状态：%d，信号：%d\\n&quot;,st,WEXITSTATUS(status),WTERMSIG(status));&#125;\n\n下图为子进程正常exit\n\n下图为子进程被kill -9干掉\n\n3.6 阻塞等待和非阻塞等待前面的waitpid函数中的option参数就和阻塞&#x2F;非阻塞等待有关\n0       阻塞WNOHANG 非阻塞\n\n3.6.1 阻塞等待当我们调用某些函数的时候，因为条件不就绪，需要我们进行阻塞等待\n\n本质：当前程序自己变成阻塞状态，当一切就绪的时候再被唤醒。\n这时候我们等待的不是硬件资源，而是等待子进程运行结束（软件资源）\n\n阻塞等待时，将父进程放入子进程task_struct中的等待队列。当操作系统检测出子进程退出，就从等待队列中唤醒父进程，阻塞等待成功！\n\n给waitpid的option传入0，即为阻塞等待\npid_t st = waitpid(-1,&amp;status,0);//阻塞等待\n\n在子进程被信号干掉或者执行完毕退出之前，父进程不会向后执行代码。在用户层面看来，就是一个程序卡住了\n3.6.2 非阻塞等待给waitpid的option传入WNOHANG，即为非阻塞等待\n等待期间，父进程可以干其他的事情\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int add(int a,int b)&#123;    return a+b;&#125;int pls(int a,int b)&#123;    return a*b;&#125;int main()&#123;    pid_t id = fork();    if(id == 0)    &#123;        // 子进程        int i =5;        while(i--)        &#123;            printf(&quot;我是子进程, 我的PID: %d, 我的PPID:%d\\n&quot;, getpid(), getppid());            sleep(2);        &#125;        exit(0);    &#125;    else if(id &gt;0)    &#123;        // 父进程        // 基于非阻塞的轮询等待方案        int status = 0;        int i = 1, j=2;        while(1)        &#123;            pid_t ret = waitpid(-1, &amp;status, WNOHANG);            if(ret &gt; 0)            &#123;                printf(&quot;等待成功, %d, exit code: %d, exit sig: %d\\n&quot;, ret, WIFEXITED(status), WTERMSIG(status));                break;            &#125;            else if(ret == 0)            &#123;                //等待成功了，但子进程没有退出                printf(&quot;子进程好了没？没有，父进程做其他事情\\n&quot;);                printf(&quot;add %d  &quot;,add(i++,j++));                printf(&quot;pls %d\\n&quot;,pls(i++,j++));                sleep(1);            &#125;            else&#123;                //err                printf(&quot;父进程等待出错！\\n&quot;);                break;            &#125;        &#125;    &#125;    return 0;&#125;\n\n这里我们给父进程写了一个死循环，一直等待子进程退出。每一次循环都会调用一次waitpid的接口，直到成功获取了子进程的退出信息\n这种多次调用waitpid接口的方式又被称为轮询检测\n\n举个具体例子，当我们使用一个聊天软件需要加载图片的时候，父进程（聊天框）可以先显示一个图片的加载图，告诉你图片正在加载（子进程）。而你还是可以正常浏览其他人的发言。等图片加载完毕（子进程退出）之后，父进程就可以把那个临时的加载图替换成获取到的图片本身，这就是一次成功的非阻塞等待\n\n4.进程替换在之前的fork中，我们的子进程都是运行的已经预先写好的代码，或者说是继承了父进程的代码继续向后执行。\n进程替换就是让子进程可以执行磁盘里面其他的可执行文件，包括Linux系统的命令、其他语言写的代码py c++ php等等……\n4.1 原理其实就是让子进程通过调用操作系统的接口，来执行一个已有的可执行程序\n\n这个过程中并没有创建新的子进程，本质上还是当前子进程\n\n程序替换的过程\n\n将磁盘中的程序加载进入内核结构\n重新建立页表映射，因为是子进程调用的程序替换，那么就会修改子进程的页表映射\n效果：子进程代码和父进程彻底分离，子进程执行了一个全新的程序\n\n\n4.2 如何替换系统提供了非常多的函数接口，供我们在一个程序中调用系统中其他的可执行程序\n\n\n要想调用，首先要找到这个程序在那儿，以及要用什么办法执行这个程序（命令行参数）下面以具体的例子来了解一下吧\n\n需要注意的是：我们需要先用fork创建子进程，再调用上面这些函数接口来使用其他可执行文件。这些函数接口本身并不会创建新的子进程！\n\n4.3 execlint execl(const char *path, const char *arg, ...);\n\n\npath是需要运行程序的路径\narg代表需要执行的程序\n...是可变参数，可以传入不定量的参数。这里我们填入的是命令行的参数\n\n说起来学到了这里我才知道原来C语言支持可变参数……\n#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;    printf(&quot;开始测试\\n\\n&quot;);    int ret = execl(&quot;/usr/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);    printf(&quot;执行结束 %d\\n&quot;,ret);    return 0;&#125;\n\n需要注意的是，当我们填入命令行参数的时候，必须要以NULL作为参数的结尾\n\n我们会发现，调用了其他可执行程序之后，在后面的printf函数并没有被执行！\n这是因为，当我们用这个函数来调用其他可执行程序，本质上已经把当前的代码和数据替换掉了！既然是替换，那么原本的printf(&quot;执行结束 %d\\n&quot;,ret);肯定也不会执行\n返回值问题那execl不是有一个int类型的返回值吗？如果程序替换了之后不会执行后面的代码，那这个返回值还有什么用呢？\n\n查手册可以看到，这个返回值只有出错的时候才会返回-1，同时会更新ERRNO\nint main()&#123;    printf(&quot;开始测试\\n\\n&quot;);    int ret = execl(&quot;/usr/bin/&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return 0;&#125;\n\n现在我们把执行文件改成usr/bin/这个错误文件，那么就会调用失败，同时可以看到调用失败的原因是，我们没有权限去执行/usr/bin\n\nint ret = execl(&quot;/usr/erqer/&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);\n\n如果改成一个乱七八糟的路径，也会打印出错误结果为“文件或路径不存在”\n\n根据这个特效，我们在执行exec这些替换函数的时候，其实没有必要去判断返回值。因为这些函数只有出错的时候，才会执行后面的代码！\n\n无需判断返回值，直接打印errno找出错误原因即可\n\n替换别的代码之前说过，替换不仅可以替换系统的命令，还可以替换成其他语言的代码\n比如下面是一个最简单的py代码\nprint(&quot;我是一个python程序！&quot;)#python中print会默认换一行\n\n我们在C中利用execl来调用这个自己写的python程序。如果你不知道你系统中有没有python，或者不知道它的路径，可以用which来查看位置\n\nint main()&#123;    printf(&quot;开始测试\\n\\n&quot;);    int ret = execl(&quot;/usr/local/bin/python3&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);    //int ret = execl(&quot;/usr/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return 0;&#125;\n\n可以看到，python程序被成功执行！\n\n子进程替换了解了替换程序的基本方法了之后，可以先来试试写一个父子进程\n这里让父进程进行3.6.2里面的轮询检测\nint add(int a,int b)&#123;    return a+b;&#125;int pls(int a,int b)&#123;    return a*b;&#125;int main()&#123;    pid_t id = fork();    if(id == 0)    &#123;        // 子进程        int i = 3;        while(i--)        &#123;            printf(&quot;我是子进程, 我的PID: %d, 我的PPID:%d\\n&quot;, getpid(), getppid());            sleep(2);//便于观察            int ret = execl(&quot;/usr/local/bin/python3&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);            printf(&quot;子进程执行出错: %d\\n&quot;,ret);            printf(&quot;子进程错误原因: %s\\n&quot;,strerror(errno));            exit(-1);        &#125;    &#125;    else if(id &gt;0)    &#123;        // 父进程        // 基于非阻塞的轮询等待方案        int status = 0;        int i = 1, j=2;        printf(&quot;我是父进程, 我的PID: %d, 我的PPID:%d\\n&quot;, getpid(), getppid());        while(1)        &#123;            pid_t ret = waitpid(-1, &amp;status, WNOHANG);            if(ret &gt; 0)            &#123;                printf(&quot;等待成功, %d, exit code: %d, exit sig: %d\\n&quot;, ret, WIFEXITED(status), WTERMSIG(status));                break;            &#125;            else if(ret == 0)            &#123;                //等待成功了，但子进程没有退出                printf(&quot;子进程好了没？没有，父进程做其他事情\\n&quot;);                printf(&quot;add %d  &quot;,add(i++,j++));                printf(&quot;pls %d\\n&quot;,pls(i++,j++));                sleep(1);            &#125;            else&#123;                //err                printf(&quot;父进程等待出错！\\n&quot;);                break;            &#125;        &#125;    &#125;    return 0;&#125;\n\n\n可以看到，子进程替换了python程序成功了之后，不会执行后面的printf\n这里的exit code也被设置成了1\n\n这里我自己想出来了一个问题，这里的exit code和我们python程序里面设置的有没有关系呢？来试试~\nprint(&quot;我是一个python程序！&quot;)exit(10)#execl父进程接收到的退出码和这里没有关系\n\nemm结果没变，说明没有关系\n我是一个python程序！等待成功, 20333, exit code: 1, exit sig: 0\n\n即便我们python程序里面有bug，这里也不会有啥变化\nprint(&quot;我是一个python程序！&quot;)a =10/0\n\n我是一个python程序！Traceback (most recent call last):  File &quot;/home/muxue/git/linux/code/22-10-13_exec/test.py&quot;, line 3, in &lt;module&gt;    a =10/0ZeroDivisionError: division by zero等待成功, 21179, exit code: 1, exit sig: 0\n\n同时我们也可以看到，子进程执行程序替换，是不会影响父进程的（进程具有独立性）\n这是因为数据发生了写时拷贝，程序替换的时候可以理解为代码和数据都通过写时拷贝进行了父子的分离（注意分离的是代码和数据，并非父子关系！）\n4.4 execv学会了前面的execl，再来看看这个\nint execv(const char *path, char *const argv[]);\n\n可以看到这个函数莫得可变参数，而是需要我们用一个指针数组来传入命令行参数！其余都是一样的！\n\n复习一下，const修饰指针有下面两种形式\n\n在*之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）\n在*之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）\n\n\nvoid testExecv()&#123;    printf(&quot;开始测试\\n\\n&quot;);    char*const arg[]=&#123;        &quot;ls&quot;,        &quot;-l&quot;,        &quot;-a&quot;,        NULL    &#125;;    int ret = execv(&quot;/usr/bin/ls&quot;,arg);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n调用成功！\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试total 36drwxrwxr-x  2 muxue muxue  4096 Oct 14 13:36 .drwxrwxr-x 12 muxue muxue  4096 Oct 13 15:19 ..-rw-rw-r--  1 muxue muxue    69 Oct 13 15:24 makefile-rwxrwxr-x  1 muxue muxue 13192 Oct 14 13:36 test-rw-rw-r--  1 muxue muxue  2402 Oct 14 13:37 test.c-rw-rw-r--  1 muxue muxue   111 Oct 14 13:23 test.py[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n\n4.5 execlpint execlp(const char *file, const char *arg, ...);\n\n注意，这里参数的说明从path变成了file\n这个函数和execl的区别在于，它会自己去系统环境变量的PATH里面查找可执行程序\n[muxue@bt-7274:~/git]$ echo $PATH/home/muxue/.vscode-server/bin/d045a5eda657f4d7b676dedbfa7aab8207f8a075/bin/remote-cli:/usr/local/bin:/usr/bin:/usr/local/python3/bin:/usr/local/python3/bin:/usr/local/sbin:/usr/sbin:/usr/local/python3/bin:/usr/local/python3/bin:/home/muxue/.local/bin:/home/muxue/bin:/usr/local/python3/bin:/usr/local/python3/bin[muxue@bt-7274:~/git]$ \n\n只有找不到这个程序的时候，才会报错！\nvoid testExeclp()&#123;    printf(&quot;开始测试\\n\\n&quot;);    int ret = execlp(&quot;python3&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n结果如下，成功调用\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试我是一个python程序！[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n随意指定一个程序，就会报错\nint ret = execlp(&quot;python3300&quot;,&quot;python3&quot;,&quot;test.py&quot;,NULL);\n\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试执行结束: -1错误原因: No such file or directory[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n4.6 execvpint execvp(const char *file, char *const argv[]);\n\n知道了execv/excel之间的区别，那么execvp/execlp之间的区别也就很明显辣！\n同样也是只有传参的区别，其他的操作完全一样\nvoid testExecvp()&#123;    printf(&quot;开始测试\\n\\n&quot;);    char*const arg[]=&#123;        &quot;ls&quot;,        &quot;-l&quot;,        &quot;-a&quot;,        NULL    &#125;;    int ret = execvp(&quot;ls&quot;,arg);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试total 36drwxrwxr-x  2 muxue muxue  4096 Oct 14 13:48 .drwxrwxr-x 12 muxue muxue  4096 Oct 13 15:19 ..-rw-rw-r--  1 muxue muxue    69 Oct 13 15:24 makefile-rwxrwxr-x  1 muxue muxue 13368 Oct 14 13:48 test-rw-rw-r--  1 muxue muxue  2994 Oct 14 13:48 test.c-rw-rw-r--  1 muxue muxue   112 Oct 14 13:45 test.py[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n4.7 execle&#x2F;execvpe&#x2F;execve这几个函数放在一起了，因为它们的使用方法很相似\nint execle(const char *path, const char *arg,                  ..., char * const envp[]);int execvpe(const char *file, char *const argv[],                   char *const envp[]);int execve(const char *filename, char *const argv[],           char *const envp[]);\n\n首先它们的函数名中都有个e，这个e代表的是环境变量，代表我们可以把特定的环境变量传入其中进行处理。它们的环境变量都是在最末尾传的\n\n\n\n函数\n参数\n说明\n\n\n\nexecle\n可执行文件的完整路径，命令行参数，环境变量\n利用可变参数传入命令行参数\n\n\nexecve\n可执行文件的完整路径，命令行参数，环境变量\n利用数组传入命令行参数\n\n\nexecvpe\n可执行文件名字，命令行参数，环境变量\n利用数组传入命令行参数；只需要传入可执行文件的名字，会自动在PATH里面搜索\n\n\n测试这里我先用C++写一个打印程序，来打印我们的环境变量\n#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;hello c++&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;-------------------------------------------\\n&quot;;    cout &lt;&lt; &quot;PATH:&quot; &lt;&lt; getenv(&quot;PATH&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;-------------------------------------------\\n&quot;;    cout &lt;&lt; &quot;MYPATH:&quot; &lt;&lt; getenv(&quot;MYPATH&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;-------------------------------------------\\n&quot;;        return 0;&#125;\n\n利用g++将其编译为可执行文件mytest\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ lsmakefile  mytest  test  test.c  test.cpp  test.py\n\n下面开始测试\nvoid testExecve()&#123;    extern char ** environ;//引入外部环境变量    printf(&quot;开始测试\\n\\n&quot;);    char*const arg[]=&#123;        &quot;./mytest&quot;,        NULL    &#125;;    int ret = execve(&quot;/home/muxue/git/linux/code/22-10-13_exec/mytest&quot;,arg,environ);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n\n从cpp文件的打印结果可以到，我们传入了完整的环境变量，PATH成功打印，但是MYPATH没有打印出来。这是因为环境变量里面没有这个\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ echo $MYPATH[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n利用export导入环境变量\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ export MYPATH=4321[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ echo $MYPATH4321[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ \n\n再次测试，可以看到两个环境变量都被打印出来了\n\n自己传入环境变量上面我们是直接引入外部环境变量\nextern char ** environ;//引入外部环境变量\n\n我们还可以自己整一个数组来传入环境变量\nvoid testExecve()&#123;    extern char ** environ;    printf(&quot;开始测试\\n\\n&quot;);    char*const arg[]=&#123;        &quot;./mytest&quot;,        NULL    &#125;;    char*const env[]=&#123;        &quot;MYPATH=this is c test&quot;,        NULL    &#125;;    int ret = execve(&quot;/home/muxue/git/linux/code/22-10-13_exec/mytest&quot;,arg,env);    printf(&quot;执行结束: %d\\n&quot;,ret);    printf(&quot;错误原因: %s\\n&quot;,strerror(errno));    return ;&#125;\n\n诶，怎么连PATH都打印不出来了？？这不是系统里面有的环境变量吗？\n\nchar*const env[]=&#123;    &quot;PATH=path test&quot;,    &quot;MYPATH=this is c test&quot;,    NULL&#125;;\n\n重新设置传入的环境变量，PATH才能成功打印\n\n这说明这几个函数的环境变量参数，在传入的时候，是会覆盖掉系统的环境变量的！\n关于环境变量参数的问题实际上，其余不带e的函数，也是能获取到系统的环境变量的（直接继承父进程BASH的环境变量）\n而带e的函数允许我们单独控制环境变量\n\n直接传入extern char ** environ;的系统环境变量\n将特定的环境变量传入\n临时自定义一部分环境变量\n\n\n注意PATH和自己的可执行程序这里只对execvpe说明一下，如果想用它调用我们自己写的mytest，那么就需要把mytest放入系统PATH里面，不然是找不到的！\n[muxue@bt-7274:~/git/linux/code/22-10-13_exec]$ ./test开始测试执行结束: -1错误原因: No such file or directory\n\n所以还是用它来调用系统的命令吧\nchar*const arg_[]=&#123;    &quot;ls&quot;,    &quot;-l&quot;,    &quot;-a&quot;,    NULL&#125;;int ret = execvpe(&quot;ls&quot;,arg_,env);\n\n4.8 execve是系统接口如果你有注意看，应该会发现execve的man手册是单独拎出来的，左上角的编号也不一样\n\n这是因为，实际上只有execve是Linux系统提供的接口\n而其他函数都是C语言库中对execve的二次封装，来适应不同的使用场景！\n4.9 函数命名总结\nl(list)：使用可变参数列表\nv(vector)：用数组传参\np(path)：自动在环境变量PATH中搜索\ne(env)：表示自己维护环境变量\n\n\n结语进程控制章节的内容到这里就基本结束啦，后续有补充的内容会在本博客里面新增！\n感谢你看到最后，有啥问题可以在评论区提出哦\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】动静态库","url":"/2022/11/03/code/note_Linux/15%E5%8A%A8%E9%9D%99%E6%80%81%E5%BA%93/","content":"在最初学习GCC的使用的时候，提到了动态、静态库的创建办法。今天就让我们来详细了解一番，它们之间究竟有何不同吧！\n\n\n\n演示所用系统：centos7.6\n\n[TOC]\n1.动态库和静态库先来了解一下动态库和静态库的基本概念吧！\n\n静态库.a 程序编译链接的时候，把静态库的代码连接到自己的可执行程序中，程序运行的时候将不再需要静态库\n动态库.so 程序在运行的时候才去链接动态库的代码，多个程序共享库的代码\n\n2.生成\n测试所用代码 👉 点我\n\n我写好了两个头文件和两个源文件，为了减少博客篇幅，此处只贴出.c的函数实现\n//myMath.c#include&quot;myMath.h&quot;int Add(int a,int b)&#123;    return a+b;&#125;//myPrint.c#include &quot;myPrint.h&quot;void Print(const char* msg)&#123;    printf(&quot;time: %d, msg: %s\\n&quot;,(unsigned int)time(NULL),msg);&#125;\n\n2.1 静态库生成静态库所用命令为ar -rc，对应的完整make操作如下\nlibMytest.a:myMath.o myPrint.o\tar -rc libMytest.a myMath.o myPrint.omyMath.o:myMath.c\tgcc -c myMath.c -o myMath.omyPrint.o:myPrint.c\tgcc -c myPrint.c -o myPrint.o\n\n生成好静态库后，我们可以用 ar -tv命令来查看该库的目录列表\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ ar -tv libmytest.arw-rw-r-- 1001/1001   1240 Nov  3 09:28 2022 myMath.orw-rw-r-- 1001/1001   1632 Nov  3 09:28 2022 myPrint.o[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ \n\n2.2 动态库动态库的生成无需额外的命令，只需要在gcc编译的时候，指定-shared即可\n同时，依赖的.o文件也需要用-fPIC来编译\n-fPIC 与位置无关码，和动态库的特性有关-shared 代表需要编译一个动态库\n\n其make操作如下\nlibmytest.so:myMath.o myPrint.o\tgcc -shared -o libmytest.so myMath.o myPrint.omyMath.o:myMath.c\tgcc -fPIC -c myMath.c -o myMath.omyPrint.o:myPrint.c\tgcc -fPIC -c myPrint.c -o myPrint.o\n\n2.3 一并发布这里我写了一个更加完整的makefile，可以同时编译生成动静态库，并将其打包到一个指定的文件夹内\n.PHONY:allall:libmytest.so libmytest.a.PHONY:liblib:\tmkdir -p lib-static/lib\tmkdir -p lib-static/include\tcp *.a lib-static/lib\tcp *.h lib-static/include\tmkdir -p lib-dynamic/lib\tmkdir -p lib-dynamic/include\tcp *.so lib-dynamic/lib\tcp *.h lib-dynamic/includelibmytest.so:myMath.o myPrint.o\tgcc -shared -o libmytest.so myMath.o myPrint.omyMath.o:myMath.c\tgcc -fPIC -c myMath.c -o myMath.omyPrint.o:myPrint.c\tgcc -fPIC -c myPrint.c -o myPrint.olibmytest.a:myMath.o myPrint.o\tar -rc libmytest.a myMath.o myPrint.omyMath_s.o:myMath.c\tgcc -c myMath.c -o myMath_s.omyPrint_s.o:myPrint.c\tgcc -c myPrint.c -o myPrint_s.o.PHONY:cleanclean:\trm -rf *.o *.a *.so lib-static lib-dynamic\n\n3.使用#include &quot;myPrint.h&quot;#include &quot;myMath.h&quot;#include &quot;stdio.h&quot;int main()&#123;    printf(&quot;ret %d\\n&quot;,Add(1,2));    Print(&quot;这是一个测试&quot;);    return 0;&#125;\n\n当我们使用了动静态库后，就没有办法直接编译这个可执行程序了\nmuxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ gcc test.c/tmp/ccKHwYHv.o: In function `main&#x27;:test.c:(.text+0xf): undefined reference to `Add&#x27;test.c:(.text+0x2a): undefined reference to `Print&#x27;collect2: error: ld returned 1 exit status[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n这是因为，gcc没办法找到我们对应的头文件\n\n&quot;&quot;是在当前路径下找\n&lt;&gt;是在库目录下面找\n\n因为我们的头文件既不在当前路径，也不在系统的库中，所以gcc就没有办法找到头文件和函数声明\n3.1 静态库链接静态库的方法如下\ngcc test.c -L../lib-static/lib/ -I../lib-static/include/ -lmytest -o test\n\n\n-L选项后带的是库的路径\n-I选择后带的是头文件的搜索路径\n-l(小写的L)选项带的是库的名字，需要去掉库文件名前面的lib和后缀.a\n-o test代表生成可执行文件名为test\n\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ gcc test.c -L../lib-static/lib/ -I ../lib-static/include/ -lmytest -o test[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testret 3time: 1667441311, msg: 这是一个测试[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n特点静态库的特点便是，其库的实现已经被编译链接进入了可执行程序，即便我们将库给删除，也不影响可执行程序的运行\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ make cleanrm -rf *.o *.a *.so lib-static lib-dynamic[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ lltotal 24-rw-rw-r-- 1 muxue muxue  702 Nov  3 09:28 makefile-rw-rw-r-- 1 muxue muxue   60 Nov  3 08:52 myMath.c-rw-rw-r-- 1 muxue muxue   35 Nov  3 08:51 myMath.h-rw-rw-r-- 1 muxue muxue  117 Nov  3 09:01 myPrint.c-rw-rw-r-- 1 muxue muxue   77 Nov  3 09:01 myPrint.hdrwxrwxr-x 2 muxue muxue 4096 Nov  3 09:50 test[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ ./test/./testret 3time: 1667440486, msg: 这是一个测试[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库]$ \n\n如果我们把自己的库的实现丢入了系统的库目录下（一般是/lib64/）编译的时候就不需要带-L选项了，只需要用-l指定库名即可\ngcc test.c -lmytest\n\n但是将自己的库丢入系统库路径下的操作并不推荐，就和你将自己的可执行程序丢入/usr/bin路径里面一样，会污染系统的环境\n\n3.2 动态库动态库和静态库链接的基本方式是一样的\ngcc test.c -L../lib-dynamic/lib/ -I ../lib-dynamic/include/ -lmytest -o testd\n\n这里选项的含义和上面完全一致，不同的是运行的时候\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testd./testd: error while loading shared libraries: libmytest.so: cannot open shared object file: No such file or directory[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n直接运行，你会发现报错了！这个报错的大概意思就是找不到动态库文件\nldd命令使用ldd命令查看testd可执行文件的动态库结构，会发现我们自己的库是没有找到的\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ldd testd        linux-vdso.so.1 =&gt;  (0x00007ffd051fe000)        /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f7de6d19000)        libmytest.so =&gt; not found        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f7de6832000)        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f7de662e000)        /lib64/ld-linux-x86-64.so.2 (0x00007f7de6c00000)[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n这是因为，动态库的特点便是运行的时候也需要指定！这是一个动态链接的过程！\n动态链接动态库需要执行动态链接：在可执行程序开始运行之前，外部函数的机器码由操作系统从磁盘上的该动态库复制到内存中\n刚刚我们的指定只是告诉了gcc编译器库路径在哪儿，但是可执行程序运行的时候并不知道！\n那么如何让可执行程序找到我们的动态库呢？\n\n将动态库拷贝到系统的/lib64文件夹中\n通过修改环境变量的方式，类似于PATH，可执行程序运行的时候，会自动到LD_LIBRARY_PATH里面找动态库\n修改系统配置文件\n\n3.3 找到动态库3.3.1 环境变量LD_LIBRARY_PATH和修改PATH的环境变量一样，我们可以通过修改环境变量的方式增加动态库的查找路径\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/\n\n修改了之后的环境变量如下\nLD_LIBRARY_PATH=:/home/muxue/.VimForCpp/vim/bundle/YCM.so/el7.x86_64:/home/muxue/.VimForCpp/vim/bundle/YCM.so/el7.x86_64:/home/muxue/.VimForCpp/vim/bundle/YCM.so/el7.x86_64:/home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/\n\n再次运行./testd 成功执行！\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testdret 3time: 1667443224, msg: 这是一个测试\n\n修改配置文件的办法，便是将该路径永久写入环境变量（修改环境变量的操作只对当前bash有效）这里就不演示辣！\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ldd testd        linux-vdso.so.1 =&gt;  (0x00007ffde04ea000)        /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007fe9000bc000)        libmytest.so =&gt; /home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/libmytest.so (0x00007fe8ffda1000)        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fe8ff9d3000)        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fe8ff7cf000)        /lib64/ld-linux-x86-64.so.2 (0x00007fe8fffa3000)\n\nldd命令的结果也显示出了我们自己写的动态库的路径\n3.3.2 &#x2F;etc&#x2F;ld.so.conf.d除了修改环境变量，我们还可以修改/etc/ld.so.conf.d下的文件\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ls /etc/ld.so.conf.dbind-export-x86_64.conf  kernel-3.10.0-1160.62.1.el7.x86_64.conf  kernel-3.10.0-1160.76.1.el7.x86_64.confdyninst-x86_64.conf      kernel-3.10.0-1160.71.1.el7.x86_64.conf  mariadb-x86_64.conf[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n这里的操作非常简单，我们只需要在该目录下新增一个.conf文件，并在里面写入动态库的绝对路径即可！\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ls /etc/ld.so.conf.dbind-export-x86_64.conf  kernel-3.10.0-1160.62.1.el7.x86_64.conf  kernel-3.10.0-1160.76.1.el7.x86_64.conf  mytest.confdyninst-x86_64.conf      kernel-3.10.0-1160.71.1.el7.x86_64.conf  mariadb-x86_64.conf[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ cat /etc/ld.so.conf.d/mytest.conf/home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n设置了之后，第一次运行，还是显示找不到动态库\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testd./testd: error while loading shared libraries: libmytest.so: cannot open shared object file: No such file or directory[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n我们只需要执行下面的命令让配文件生效，就OK了！\nsudo ldconfig #子用户权限不够，需要加sudo\n\n执行完该命令后，可执行程序也能成功运行了1\n[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ sudo ldconfig[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ ./testdret 3time: 1667448942, msg: 这是一个测试[muxue@bt-7274:~/git/linux/code/22-11-02_动静态库/test]$ \n\n测试完毕之后，建议将配置文件删除，并重新加载动态库配置文件\nsudo rm /etc/ld.so.conf.d/mytest.confsudo ldconfig\n\n这样做是避免污染\n3.3.3 在lib64下创建一个软连接ln -s /home/muxue/git/linux/code/22-11-02_动静态库/lib-dynamic/lib/libmytest.so /lib64/libmytest.so\n\n创建软连接的方式和将我们的文件复制进去本质是一样的，只不过软连接只是一个快捷方式，如果我们把源给删了，软连接也会失效\n这部分就不做演示了\n\n4.优劣4.1 静态库静态库编译之后的可执行程序可以脱离静态库运行，也不需要知道库的路径。\n即便这个库被删除，也丝毫不影响我们的可执行程序\n4.2 动态库动态库的代码只需要一份，所有的可执行程序便都可以使用\n在运行期间，动态库可以被多个进程所共享。但前提是，可执行程序需要知道该动态库的路径，以便将其加载到内存中（或者找到它在内存中的位置）\n\n这样就保证了多个进程同时使用同一个库，节省了内存的消耗，也节省了磁盘空间\n\n这里动态库的可执行文件大小，小于静态库的可执行文件\n\n因为测试的代码不多，所以差距尚不明显\n\n5.动态库-fPIC的作用\n参考https://blog.csdn.net/itworld123/article/details/117587091\n\ngcc -fPIC -c myMath.c -o myMath.o\n\nfPIC 的全称是 Position Independent Code， 用于生成位置无关代码\n\n什么是位置无关代码？\n个人理解是代码无绝对跳转，跳转都为相对跳转\n\n如果我们的静态库中，不使用其他库的代码（比如stdio.h）\nint fuc(int a)&#123;\treturn ++a;&#125;\n\n这时候，就可以再编译的时候不带-fPIC 否则会报错\n/usr/bin/ld: /tmp/ccCViivC.o: relocation R_X86_64_32 against `.rodata&#x27; can not be used when making a shared object; recompile with -fPIC/tmp/ccCViivC.o: could not read symbols: Bad value\n\n但显然，这种情况是非常少见的，所以我们一般编译动态库的时候，都需要带上这个参数，来实现真正意义上的动态库编译\n\n\n加 fPIC 选项生成的动态库，显然是位置无关的，这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针的值，加上一个偏移得到全局变量 &#x2F; 函数的地址。\n加 fPIC 选项的源文件对于它引用的函数头文件编写有很宽松的尺度。比如只需要包含个声明的函数的头文件，即使没有相应的 C 文件来实现，编译成 so 库照样可以通过。\n对于不加 fPIC，则加载 so 文件时，需要对代码段引用的数据对象需要重定位，重定位会修改代码段的内容，这就造成每个使用这个 .so 文件代码段的进程在内核里都会生成这个 .so 文件代码段的 copy。每个 copy 都不一样，取决于这个 .so 文件代码段和数据段内存映射的位置。这种方式更消耗内存，优点是加载速度可能会快一丢丢，弊大于利\n\n\n结语动静态库的基本认识到这里就OVER辣，大家也可以去尝试下载一些第三方的库来使用，比如在树莓派上最常用的wiringPi库，还有C++的boost库等等\nsudo yum install -y boost-devel\n\n有什么问题，可以在评论区提出哦！\n\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】简易shell的实现","url":"/2022/10/17/code/note_Linux/13myshell/","content":"本篇博客，来教大家用C写一个简易的linux shell，帮助理解之前学习的进程控制相关知识\n\n\n\n演示系统：CentOS7.6\n\n[TOC]\n前言之所以说是简易的shell，是因为我们现在的水平肯定写不出来linux系统里面那么复杂的shell。\n我们的目的仅仅是为了学习父子进程、进程替换、内建命令等等知识，并把这些知识的作用通过这个小shell体现出来\n\n源码仓库：gitee\n\n\n1.基础框架之前的学习中有提到过，我们在linux命令行内运行的很多进程，都是以子进程的方式运行的。说白了就是bash进程里面给我们fork创建了其他子进程，再用子进程进行进程替换，指向对应的可执行文件\n而需要做到这一点，我们要一步一步来\n\nbash首先要显示命令行的提示符用户名@主机名 路径（参考之前vim博客中的进度条程序）\n获取用户的输入内容\n从用户的输入中，以&quot; &quot;空格为分割，分离出命令和参数\nfork创建子进程，子进程执行进程替换，父进程等待子进程结束\n\n这一切都是在一个while(1)的死循环里面执行的，bash本质上就是一个死循环的父进程\n2.开整一个2.1 打印命令行提示符先来试试打印出命令行的提示符吧！\nprintf(&quot;[慕雪@FS-1041 当前路径]# &quot;);fflush(stdout); //刷新缓冲区，达到不换行的效果\n\n\n\n为何要使用fflush？\n\n如果不这么弄，而使用\\n换行，就会出现命令行提示符一直在闪动打印。这不是我们想要的结果\n光是打印一个基本的路径可不太够哦，我们还可以试着获取环境变量的PWD得到当前的路径，再打印出来\nchar cur_pwd[SIZE] = &quot;~&quot;;int sz_pwd = strlen(getenv(&quot;HOME&quot;));strcat(cur_pwd, getenv(&quot;PWD&quot;) + sz_pwd);printf(&quot;[慕雪@FS-1041 %s]# &quot;, cur_pwd);fflush(stdout); //刷新缓冲区，达到不换行的效果\n\n这里我们必须要去掉PWD前面/home/用户名的内容，将其替换成~\n打印出来的效果如下，是不是和我们linux的命令行很像啦！\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n你还可以从环境变量中获取HOSTNAME和USER来替换掉前面的内容\n这里为了和linux自己的shell区分一下，我就不替换了\n\n2.2 获取用户输入C语言获取用户输入，我们一般用的是scanf\n但是这个函数在现在这个地方可不那么好用喽！我们输入命令的时候需要用空格分开命令行参数。scanf会因为空格而停止接受\n我们可以用gets函数来解决这个问题！\n#define NUM 1024char cmd_line[NUM]; //命令行输入// 2.获取用户的输入内容memset(cmd_line, &#x27;\\0&#x27;, sizeof(cmd_line) * sizeof(char));fgets(cmd_line, NUM, stdin);           //标准输入stdin获取键盘输入内容\n\n获取了之后先打印一下cmd_line，可以看到成功获取了我们输入的结果\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# test i k dtest i k d[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]#\n\n但为什么多打了一个换行呢？\n这是因为fgets在接受输入的时候，把我们输入结束的回车也给收起来辣\ncmd_line[strlen(cmd_line) - 1] = &#x27;\\0&#x27;; // 去掉\\n回车\n\n光是去掉回车还是有点问题，如果我们只敲了一个回车，后续我们分离参数的时候，总不能对一个空的字符串进行处理吧？\n所以还需要单独判断strlen(cmd_line)==1的情况，直接continue\nif(strlen(cmd_line)==1)&#123;    continue;//等于1的情况只能是敲了一个回车&#125;// 其他情况去掉\\n回车cmd_line[strlen(cmd_line) - 1] = &#x27;\\0&#x27;; \n\n这样我们的bash就和linux自己的bash一样，敲回车会直接新起一行，不做任何操作\n\n如果不这么处理，就会引发段错误导致bash直接终止\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# Segmentation fault\n\n2.3 分离参数获取好用户输入啦，下一步就是分离参数了！\n这里面我们直接使用strtok这个函数即可！\nchar * strtok ( char * str, const char * sep );\n\n它的作用是根据分隔符返回这个分隔符在字符串里面的起始位置；如果传入的是一个NULL，则从上一次处理的位置继续往后处理。\n\nstrtok函数找到str中的下一个标记，并将其用\\0结尾，返回一个指向这个标记的指针\n如果字符串中不存在更多的标记，则返回 NULL 指针\n\n\n该函数的详解参考我的博客 点我 \n\n😥最开始的时候我忘记了这个函数，直接自己写了一个分离算法，debug了好久才勉强搞出来，太笨蛋了\nsize_t cmd_args_num = 0;  //分离出来的参数个数char *cmd_args[SIZE];     //分离参数cmd_args[0] = strtok(cmd_line, SEP);cmd_args_num = 1;while (cmd_args[cmd_args_num++] = strtok(NULL, SEP));cmd_args_num--;//这里-1是因为while循环最后会多++ 1次\n\n注意！=赋值操作符是有返回值的！它的返回值是我们的左值，也就是每一次获取到的strtok的结果，这个结果被cmd_args[cmd_args_num]所接受\n那么，当strtok返回NULL的时候，while就会接受到=的返回值，从而停止循环\nfor(int j=0;j&lt;cmd_args_num;j++)&#123;    printf(&quot;args[%d] %s\\n&quot;,j,cmd_args[j]);&#125;\n\n通过打印，可以看到它成功分离出来了我们的参数\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# ls -largs[0] lsargs[1] -l\n\n单独处理ls在linux的bash下，我们执行的ls都是带颜色的。这是因为centos的配置文件中，将ls设置成了ls --color=auto的别名，要想我们自己bash里面的ls也带上颜色，则需要单独处理一下ls\n// 3.分离出命令和参数cmd_args[0] = strtok(cmd_line, SEP);cmd_args_num = 1;// 给ls命令添加颜色if (strcmp(cmd_args[0], &quot;ls&quot;) == 0)    cmd_args[cmd_args_num++] = (char *)&quot;--color=auto&quot;;while (cmd_args[cmd_args_num++] = strtok(NULL, SEP));cmd_args_num--;//这里-1是因为while循环最后会多++一次\n\n最终ls -l分离出来的参数如下\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# ls -largs[0] lsargs[1] --color=autoargs[2] -l\n\n2.4 进程替换参数分离出来了，下一步要做的，便是进程替换了\n我们需要使用的是exec函数里面的哪一个呢？\n\n带p的exec函数，它会自动去PATH里面查找可执行文件\n带v的，函数，因为我们的传参已经分离在了一个字符指针数组里面\n\n基本的代码如下，父进程打印内容是为了测试，实际的bash肯定是没有这个打印的~\n// 6.创建程序 替换pid_t ret_id = fork();if (ret_id == 0) //子进程&#123;    execvp(cmd_args[0], cmd_args); //程序替换    exit(134);                     //执行到这里，子进程一定替换失败&#125;// 父进程int status = 0;pid_t ret = waitpid(ret_id, &amp;status, 0);printf(&quot;\\n&quot;);if (ret &gt; 0)&#123;    printf(&quot;bash等待子进程成功！code: %d, sig: %d\\n&quot;, WEXITSTATUS(status), WTERMSIG(status));&#125;\n\n运行成功！\n\n执行python3的文件也是ok的\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# python3 test.pyargs[0] python3args[1] test.pyhello pythonbash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]#\n\n3.内建命令完成了上面的几步后，一个基础的bash就搞定了\n但是这样还不够，不信cd试一下？\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lsmakefile  myshell  myshell.c  myshell_err.c  test  test.cpp  test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# cd testbash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lsmakefile  myshell  myshell.c  myshell_err.c  test  test.cpp  test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n 诶，为什么cd了之后，再次ls，路径没有变化呢？\n这是因为我们的cd是被子进程执行的，切换的是子进程的工作目录。可子进程执行完cd之后就结束运行了，它根本没有影响到父进程bash！\n\n之前学习的时候，我们提到过内建命令这一个概念。有一些命令不应该是子进程执行的，而应该是bash自己执行的，比如这里的cd，还有导入环境变量的export\n其实说白了就是bash检测到内建命令，就执行他自己的一个函数呗\n3.1 cd和export命令cd/export命令，c语言中都有现成的函数供我们使用，还是很方便的\n//这里导入环境变量之后，不会影响linux的shell//而是从我们的myshell开始所有子进程都会继承int PutEnvIn(char *new_env)&#123;    putenv(new_env);    return 0;&#125;//不使用内建命令，则不会生效int ChangeDir(const char *new_path)&#123;    chdir(new_path);    return 0; // 调用成功&#125;\n\n以下是main函数里面的内容，完整代码请去我的代码仓库查看\n// 5.内建命令if (strcmp(cmd_args[0], &quot;cd&quot;) == 0 &amp;&amp; cmd_args[1] != NULL)&#123;    ChangeDir(cmd_args[1]); //让调用方进行路径切换, 父进程    continue;&#125;// 目前，环境变量信息在cmd_line,会被清空// 此处我们需要自己保存一下环境变量内容char env_buffer[SIZE][NUM];size_t env_num = 0; //环境变量的数量if (strcmp(cmd_args[0], &quot;export&quot;) == 0 &amp;&amp; cmd_args[1] != NULL)&#123;    strcpy(env_buffer[env_num], cmd_args[1]);    PutEnvIn(env_buffer[env_num]);    env_num++;    continue;&#125;\n\n这时候cd就能正常执行了，不过pwd还没有修改，我没想好要怎么操作捏\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lsmakefile  myshell  myshell.c  myshell_err.c  test  test.cpp  test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# cd test[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lsbash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n试一试export，也没问题呢\n//test.cpp#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;ts= &quot; &lt;&lt; getenv(&quot;ts&quot;) &lt;&lt;endl;    return 0;&#125;\n\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# make testg++ test.cpp -o test -std=c++11bash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# export ts=12341[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# ./testts= 12341bash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n3.2 alias别名设置上面两个命令有现成的，alias的设置就需要我们手写啦\n#define NUM 1024#define SIZE 128//变量名别名typedef struct alias_cmd&#123;    char _cmd[SIZE];    char _acmd[SIZE];&#125; alias;alias cmd_alias[SIZE]; //缓存别名键值对(结构体)size_t alias_num = 0;  //已缓存的别名个数\n\n这里我先定义了一个结构体，用来存放变量别名的键值对，方便我们进行替换\n然后就是漫长的替换步骤，这部分我debug了非常久才写出来，都带了注释，大家可以看看\n//设置别名(新命令，原命令)void set_alias(char *cmd, char *acmd)&#123;    //查找别名里是否已经有了这个    for (int i = 0; i &lt; alias_num; i++)    &#123;        if (strcmp(cmd_alias[i]._cmd, cmd) == 0) //是已有的别名        &#123;            strcpy(cmd_alias[i]._acmd, acmd);            // printf(&quot;set cmd %s acmd %s\\n&quot;,cmd_alias[i]._cmd,cmd_alias[i]._acmd);            return;        &#125;    &#125;    //没有提前退出，说明是新增别名    strcpy(cmd_alias[alias_num]._cmd, cmd);    strcpy(cmd_alias[alias_num]._acmd, acmd);    alias_num++;&#125;//判断一个命令是否有别名bool is_alias(char *cmd_args[], int sz)&#123;    int i = 0;    for (i = 0; i &lt; alias_num; i++)    &#123;        if (strcmp(cmd_alias[i]._cmd, cmd_args[0]) == 0) //是别名        &#123;            size_t index = 1, j;            char *cmd_args_temp[SIZE];                                           //临时数组用于分离别名里面的命令            memset(cmd_line_alias, &#x27;\\0&#x27;, sizeof(cmd_line_alias) * sizeof(char)); //清空别名命令缓存            //先把别名中的命令分开            strcpy(cmd_line_alias, cmd_alias[i]._acmd); //不能直接使用_acmd，不然会影响下次别名使用            cmd_args_temp[0] = strtok(cmd_line_alias, SEP);            //别名的时候也需要设置ls的颜色（需要保证原本命令的第一个不是ls，不然本来就已经有&quot;--color=auto&quot;了）            if (strcmp(cmd_args_temp[0], &quot;ls&quot;) == 0 &amp;&amp; strcmp(cmd_args[0], &quot;ls&quot;) != 0)                cmd_args_temp[index++] = (char *)&quot;--color=auto&quot;;            while (cmd_args_temp[index++] = strtok(NULL, SEP))                ;            index--; // while会多+1，需要重新操作一下            //从原本数组的第二位开始往后设置            for (j = 1; j &lt; cmd_args_num; j++)            &#123;                cmd_args_temp[index++] = cmd_args[j];            &#125;            //替换掉原本的数组            cmd_args_num = index;              //此时的index长度正确，不需要-1            for (j = 0; j &lt; cmd_args_num; j++) //因为while最后会多++一次，所以需要-1            &#123;                //原本的位置没有那么大空间，放不下，不能拷贝                // strcpy(cmd_args[j],cmd_args_temp[j]);                cmd_args[j] = cmd_args_temp[j];                // printf(&quot;temp[%d] %s   args[%d] %s\\n&quot;,j,cmd_args_temp[j],j,cmd_args[j]);            &#125;            cmd_args[j] = NULL; //最后一个位置设置成NULL            return true;        &#125;    &#125;    return false;&#125;\n\n其实肯定是有更好的方案的，但是我还没想出来咋弄。现在这个能跑就OK，哈哈\n以最基本的ll命令来测试以下，替换成功！修改已有的别名也是没有问题的\n[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# alias ll=&#x27;ls -l&#x27;[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lltotal 60-rw-rw-r-- 1 muxue muxue   136 Oct 15 23:21 makefile-rwxrwxr-x 1 muxue muxue 14040 Oct 16 17:05 myshell-rw-rw-r-- 1 muxue muxue  8217 Oct 16 16:59 myshell.c-rw-rw-r-- 1 muxue muxue  6942 Oct 15 22:38 myshell_err.c-rwxrwxr-x 1 muxue muxue  9072 Oct 16 17:08 test-rw-rw-r-- 1 muxue muxue   130 Oct 15 23:22 test.cpp-rw-rw-r-- 1 muxue muxue    21 Oct 16 00:11 test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# alias ll=&#x27;ls -l -a&#x27;[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# lltotal 68drwxrwxr-x  2 muxue muxue  4096 Oct 16 17:08 .drwxrwxr-x 13 muxue muxue  4096 Oct 15 17:31 ..-rw-rw-r--  1 muxue muxue   136 Oct 15 23:21 makefile-rwxrwxr-x  1 muxue muxue 14040 Oct 16 17:05 myshell-rw-rw-r--  1 muxue muxue  8217 Oct 16 16:59 myshell.c-rw-rw-r--  1 muxue muxue  6942 Oct 15 22:38 myshell_err.c-rwxrwxr-x  1 muxue muxue  9072 Oct 16 17:08 test-rw-rw-r--  1 muxue muxue   130 Oct 15 23:22 test.cpp-rw-rw-r--  1 muxue muxue    21 Oct 16 00:11 test.pybash等待子进程成功！code: 0, sig: 0[慕雪@FS-1041 ~/git/linux/code/22-10-15_myshell]# \n\n结语就这样，一个最基本的bash或者说shell就被我们搞定啦\n其实内建命令远不止3里面提到的那几个，不过我们学习的目的已经达到了~也没必要死磕在这里\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】进程通信 | 管道","url":"/2022/11/11/code/note_Linux/16%E7%AE%A1%E9%81%93/","content":"今天让我们来认识如何使用管道来进行进程间通信\n\n\n[TOC]\n1.何为管道？在最初学习linux的基础命令时，接触过用|来连接多个命令的操作。当时便提到了这是一个管道操作，但没有详解管道到底是什么。\n1.1 管道是进程间通信的一种方式管道管道，如同其名，是一个可以让数据在内部流动的东西。创建管道，就好比在两个阀门（进程）之间搭了一根水管，我们可以自由控制管道中水的流向\n不过，在Linux系统中提供的管道接口，只支持单项流动。一个管道只支持从A-&gt;B，不支持B-&gt;A\n要想进行双向通信，则需要创建两个管道\n1.2 进程通信既然管道是用来进程通信的，那进程通信又是什么，它有何用呢？\n进程通信的目的是让两个进程可以相互交流，包括以下几种情况：\n\n数据传输，从进程A发送数据道进程B\n资源共享，多个进程使用同一个资源\n通知事件，进程A向进程B发送消息，告知进程B发生了什么事件\n进程控制，父进程通过管道来控制子进程的执行，进程A控制进程B的执行等等\n\n除了管道，我们还可以通过systemV/POSIX来实现进程通信\n进程通信的核心思想：让两个进程获取到同一份资源\n1.3 管道分类管道分为两种\n\n匿名管道，pipe\n命名管道，管道文件\n\n且听我慢慢道来\n2.匿名管道匿名管道主要用于父子进程之间的通信，其使用pipe接口来进行创建\n\n\n类似于fork，我们只需要在创建了之后判断函数的返回值就可以了\n其中pipefd[2]是一个输出型参数，我们要预先创建好一个2个空间的数组，传入该函数。pipe会创建一个匿名管道（可以理解为一个只属于该进程的临时文件）并将读端赋值给pipefd[0]，写端赋值给pipefd[1]\n\n如果我们需要父进程写，子进程读，就在父进程关闭读端，子进程关闭写端\n如果我们需要父进程读，子进程写，就在父进程关闭写段，子进程关闭读端\n\n通过这种方式，我们就在父子进程中打通了一个管道，可以让父子进程进行一定的交流\n而fd正是我们之前学习过的Linux下文件描述符，其管道的读写操作和调用系统接口读写文件完全相同！\n\n博客：linux文件操作\n\n2.0 康康源码/include/linux/pipe_fs_i.h中可以找到管道操作的源码\nstruct pipe_buffer &#123;\tstruct page *page;\tunsigned int offset, len;\tconst struct pipe_buf_operations *ops;\tunsigned int flags;\tunsigned long private;&#125;;\n\n其中我们的管道文件拥有一个缓冲区，这个缓冲区有一个专门的struct pipe_buf_operations结构体用来处理它的输入输出方法，以及flags用来标识当前缓冲区的装态\n2.1 创建首先，我们需要用pipe接口创建一个匿名管道，使用并不难\n// 1.创建管道int pipefd[2] = &#123;0&#125;;if(pipe(pipefd) != 0)&#123;    cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;    return 1;&#125;\n\n因为pipe是通过pipefd这个输出型参数来创建管道的，所以我们并不需单独定义一个变量来接受该函数的返回值，直接在if语句中进行判断即可\nvoid TestPipe2()&#123;     // 1.创建管道    int pipefd[2] = &#123;0&#125;;    if(pipe(pipefd) != 0)    &#123;        cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;        return ;    &#125;    cout &lt;&lt; pipefd[0] &lt;&lt; &quot; &quot; &lt;&lt; pipefd[1] &lt;&lt; endl;&#125;\n\n先来个小测试，打印这两个值可以发现，它其实是两个不同的文件描述符。系统分别用读方法和写方法打开了同一个文件，供我们使用\n\n0为读端；1为写端\n\n[muxue@bt-7274:~/git/linux/code/22-11-04_pipe]$ ./test3 4[muxue@bt-7274:~/git/linux/code/22-11-04_pipe]$ \n\n我们自己打开的文件描述符是从3开始的，012对应的是stdin/stdout/stderr\n2.2 父子通信有了匿名管道，接下来就可以尝试在父子进程中进行通信了\n以父写子读为例，我们需要在子进程关闭写段，父进程关闭读端\npipefd是父进程的资源，fork创建子进程之后，该资源会发生一次写时拷贝，以供父子进程共享\n// 2.创建子进程pid_t id = fork();if(id &lt; 0)&#123;    cerr &lt;&lt; &quot;fork error&quot; &lt;&lt; endl;    return 2;&#125;else if (id == 0)&#123;    // 3.子进程管道    // 子进程读取, 关掉写端    close(pipefd[1]);    //...&#125;else&#123;    // 4.父进程管道    // 父进程写入，关掉读端    close(pipefd[0]);    //...&#125;\n\n处理完之后，后续的操作便是linux的文件操作了\n完整代码以下是完整代码，通过文件接口对pipefd进行read/write，就能让父进程发送的字符串被子进程读取道\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;using namespace std;#define NUM 1024//匿名管道int TestPipe()&#123;    // 1.创建管道    int pipefd[2] = &#123;0&#125;;    if(pipe(pipefd) != 0)    &#123;        cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;        return 1;    &#125;    // 2.创建子进程    pid_t id = fork();    if(id &lt; 0)    &#123;        cerr &lt;&lt; &quot;fork error&quot; &lt;&lt; endl;        return 2;    &#125;    else if (id == 0)    &#123;        // 3.子进程管道        // 子进程来进行读取, 子进程就应该关掉写端        close(pipefd[1]);        char buffer[NUM];        while(1)        &#123;            cout &lt;&lt; &quot;time_stamp: &quot; &lt;&lt; (size_t)time(nullptr) &lt;&lt; endl;            // 子进程没有带sleep，为什么子进程你也会休眠呢？？            memset(buffer, 0, sizeof(buffer));            ssize_t s = read(pipefd[0], buffer, sizeof(buffer) - 1);            if(s &gt; 0)            &#123;                //读取成功                buffer[s] = &#x27;\\0&#x27;;                cout &lt;&lt; &quot;子进程收到消息,内容是: &quot; &lt;&lt; buffer &lt;&lt; endl;            &#125;            else if(s == 0)            &#123;                cout &lt;&lt; &quot;父进程写完了，我也退出啦&quot; &lt;&lt; endl;                break;            &#125;            else&#123;                cerr &lt;&lt; &quot;err while chlid read pipe&quot; &lt;&lt; endl;            &#125;        &#125;        close(pipefd[0]);        exit(0);    &#125;    else    &#123;        // 4.父进程管道        // 父进程来进行写入，就应该关掉读端        close(pipefd[0]);        const char *msg = &quot;你好子进程，我是父进程, 这次发送的信息编号是&quot;;        int cnt = 0;        while(cnt &lt; 10)        &#123;            char sendBuffer[1024];            sprintf(sendBuffer, &quot;%s : %d&quot;, msg, cnt);//格式化控制字符串            write(pipefd[1], sendBuffer, strlen(sendBuffer));            cnt++;            cout &lt;&lt; &quot;cnt: &quot; &lt;&lt; cnt &lt;&lt; endl;            sleep(1);        &#125;        close(pipefd[1]);        cout &lt;&lt; &quot;父进程写完了&quot; &lt;&lt; endl;    &#125;    // 父进程等待子进程结束    pid_t res = waitpid(id, nullptr, 0);    if(res &gt; 0)    &#123;        cout &lt;&lt; &quot;等待子进程成功&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;父进程退出&quot; &lt;&lt;endl;    return 0;&#125;\n\n运行成功，可以看到父进程每次写入之后，子进程读取\n\n父进程休眠的时候，子进程看起来啥事没有做\n实际上，子进程是在等待父进程对管道的写入\n2.3 等待之前我们学习过进程等待相关的知识点，其中提到了进程有时候需要等待另外一个进程的执行。比如父进程等待子进程执行完成（上面的代码也用了waitpid等待）\n而管道，就是进程需要等待的资源之一\n\n如果管道为空，读端必须要等待写端写入，否则无法执行后面的代码\n如果管道满了，写段必须等待读端取走数据，否则不能写入。因为此时写入会覆盖之前的数据\n\n那么，进程是在执行到什么函数的时候开始等待的呢？\n答案是：进程将在read/write中进行阻塞等待！\n\n执行到read的时候，操作系统判断匿名管道中没有有效数据，让执行read的进程等待管道写入\n执行到write的时候，操作系统判断管道已经满了，就让执行write的进程等待管道被读取（而且需要管道被清空了才能继续写入）\n这个判断机制是管道文件中自带的，是一种同步和互斥机制\n相比之下，我们向显示器输出的时候，就没有访问控制，父子进程向显示器输出内容的顺序是完全随机的\n\n本质就是将该进程的task_strcut放入等待队列中，并将状态从R设置为S/D/T\n写入等待对第二点进行一个测试，我们把父进程改成死循环，子进程每休眠3s读取一次管道\n\n执行后会发现，父进程几乎是在一瞬间写入了1226次数据，随后子进程开始读取，此时我们会发现，尽管子进程已经开始读取了，但是父进程却米有动静。\n\n子进程需要将管道内的数据读取一部分，父进程才能继续执行写入。\n此时父进程就是在write里面进行等待的\n\n进一步观察会发现，当子进程读取到77次消息的时候，父进程又开始往管道里面写入了\n\n嘿，你猜怎么着？父进程刚好写入了74次消息！而子进程继续读取之前的管道信息\n\n这便告诉我们，父进程需要等待子进程将管道内容读取一部分（清理掉一部分）之后，才能继续往管道内部写入。\n\n但在读端，这一切都不一样了\n读取等待我们让父进程直接睡上20s在进行写入，可以看到，子进程是执行到read开始等待的\n\n当父进程第一次写入之后，子进程立马打印出了消息的内容。随后父进程又进入了休眠，子进程开始了新一次等待\n\n简而言之，就是只要你不往管道里面写东西，子进程就需要一直等下去！\n源码中的体现源码中有一个单独的结构体，用来标识管道文件。其中inode便是Linux下的文件描述符\nstruct pipe_inode_info &#123;\twait_queue_head_t wait;\tunsigned int nrbufs, curbuf;\tstruct page *tmp_page;\tunsigned int readers;\tunsigned int writers;\tunsigned int waiting_writers;\tunsigned int r_counter;\tunsigned int w_counter;\tstruct fasync_struct *fasync_readers;\tstruct fasync_struct *fasync_writers;\tstruct inode *inode;\tstruct pipe_buffer bufs[PIPE_BUFFERS];&#125;;\n\n在这里我们可以看到一个wait结构体，其为一个等待队列，维护写入和读取的等待\nstruct __wait_queue_head &#123;\tspinlock_t lock;\tstruct list_head task_list;&#125;;typedef struct __wait_queue_head wait_queue_head_t;\n\nspinlock是何方神圣我们暂且不知，但list_head结构体告诉我们，这是一个等待队列的链表\nstruct list_head &#123;\tstruct list_head *next, *prev;&#125;;\n\n\n2.4 控制多个子进程上面只是实现了父进程和一个子进程的通信，在实际场景中这远远不够用。接下来就来实现一个父进程和多个子进程之间的通信，通过管道给子进程分配不同的任务！\n具体的操作在注释中有所标明，如果有什么问题欢迎评论提出！\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;using namespace std;//提供三个lambda表达式auto func1 = []() &#123;cout &lt;&lt; &quot;this is func1,run by &quot; &lt;&lt; getpid() &lt;&lt;endl;&#125;;auto func2 = []() &#123;cout &lt;&lt; &quot;this is func2,run by &quot; &lt;&lt; getpid() &lt;&lt;endl;&#125;;auto func3 = []() &#123;cout &lt;&lt; &quot;this is func3,run by &quot; &lt;&lt; getpid() &lt;&lt;endl;&#125;;//通过func存在数组中vector&lt;function&lt;void()&gt;&gt; func_v;void LoadFunc()&#123;    func_v.push_back(func1);    func_v.push_back(func2);    func_v.push_back(func3);&#125;//有一种概念叫做”负载均衡”，在多线程/多进程操作中较多使用//其理念就是每一个进程/线程分到的任务应该是平均的，避免出现某一个进程干的活比别人多的情况void BalanceDivide(const vector&lt;pair&lt;int,int&gt;&gt;&amp; processMap)&#123;    //设置初始化    srand((size_t)time(nullptr));    int total = 15;//分配20次任务    while(total&gt;0)    &#123;        sleep(1);        // 选择一个进程, 选择进程是随机的，没有压着一个进程给任务        // 较为均匀的将任务给所有的子进程 --- 负载均衡        int pick = rand() % processMap.size();        // 选择一个任务        int task = rand() % func_v.size();        // 把任务给一个指定的进程        write(processMap[pick].second, &amp;task, sizeof(task));        // 打印对应的提示信息        cout &lt;&lt; &quot;父进程指派任务-&gt;&quot; &lt;&lt; task &lt;&lt; &quot; 给进程: &quot; &lt;&lt; processMap[pick].first &lt;&lt; &quot; 编号: &quot; &lt;&lt; pick &lt;&lt; endl;        total--;    &#125;    //结束后，写入0代表进程终止    for(int i=0;i&lt;processMap.size();i++)    &#123;        int end = -1;        write(processMap[i].second, &amp;end, sizeof(end));        cout &lt;&lt; &quot;stopping process pid = &quot; &lt;&lt; processMap[i].first &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;assign task end!&quot; &lt;&lt; endl;&#125;//子进程工作，参数为pipefd[0]void Working(int pfd)&#123;    cout &lt;&lt; &quot;chlid [&quot; &lt;&lt; getpid() &lt;&lt; &quot;] start working&quot; &lt;&lt; endl;    while(1)    &#123;        int optCode = 0;//读取任务下标        ssize_t s = read(pfd, &amp;optCode, sizeof(optCode));        if(s == 0)        &#123;            break;//读取了0个字节代表错误        &#125;        else if(optCode == -1)        &#123;            break;//读取到-1，代表终止        &#125;           assert(s == sizeof(int));//判断是否为正确的size        // 执行父进程提供的任务        if(optCode &lt; func_v.size())         &#123;            func_v[optCode]();        &#125;    &#125;    cout &lt;&lt; &quot;chlid [&quot; &lt;&lt; getpid() &lt;&lt; &quot;] end working&quot; &lt;&lt; endl;&#125;int main()&#123;       LoadFunc();//加载    vector&lt;pair&lt;int,int&gt;&gt; assignMap;    int processNum = 5;    for(int i=0;i&lt;processNum;i++)    &#123;        int pipefd[2];        if(pipe(pipefd)!=0)        &#123;            cerr &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;            continue;        &#125;        int pid = fork();        if(pid==0)//子进程        &#123;            close(pipefd[1]);//关闭写            //开始工作            Working(pipefd[0]);            close(pipefd[0]);            exit(0);//退出子进程        &#125;        close(pipefd[0]);//父进程关闭读        pair&lt;int,int&gt; p = &#123;pid, pipefd[1]&#125;;//进程pid和pipefd写端的键值对        assignMap.push_back(p);        sleep(1);    &#125;    cout &lt;&lt; &quot;create all process success!&quot; &lt;&lt; endl;    BalanceDivide(assignMap);//分配任务    //结束分配后，等待子进程停止运行    for (int i = 0; i &lt; processNum; i++)    &#123;        if (waitpid(assignMap[i].first, nullptr, 0) &gt; 0)        &#123;            cout &lt;&lt; &quot;wait for pid = &quot; &lt;&lt; assignMap[i].first &lt;&lt; &quot; wait success! &quot;                 &lt;&lt; &quot;num: &quot; &lt;&lt; i &lt;&lt; endl;        &#125;        close(assignMap[i].second);    &#125;        return 0;&#125;\n\n先是父进程创建了5个子进程\n\n再开始用生成随机数的方式，为每一个进程指派相应的“任务”（其实就是一个函数）\n\n15次任务指派完毕之后，以一个循环，通过管道写入-1作为停止符，让子进程停止工作。同时main函数中进行waitpid等待子进程运行成功！\n\n2.5 命令行 |命令行中输入的|命令，其实就是一个匿名管道\n\n这里我们用|运行两个sleep命令，再查看这两个进程，可以看到这两个进程是属于同一个父进程的，这说明这两个sleep进程是一对兄弟~\n\n当父进程创建一对管道的时候，它可以创建两个子进程，并将管道交付给子进程进行使用\n\n父进程创建管道，创建子进程AB\n父进程关闭pipefd[0]和[1]\n子进程A关闭读端，执行写入\n子进程B关闭写段，执行读取\n\n而|就是将信息转给两个子进程使用的一种匿名管道！这也能解释为什么我们可以先ps ajx，再用| grep在内部搜索内容并打印出来。其就是通过匿名管道实现了几个命令中的信息共享\n\n3.命名管道和匿名管道不同的是，命名管道是通过一个管道文件来实现的，其有一个文件的“实体”，支持多个进程打开同一个管道文件，执行读写操作，实现管道的交流\n\n我们通过mkfifo接口创建一个FIFO(front in front out/先进先出)的管道文件，这里的注释也表明他是一个命名管道a named pipe\n3.1 创建管道文件操作方法和创建一个文件的方法是一样的，指定一个路径，并指定该文件的权限。为了避免受系统的权限掩码值的影响，我们要用umask将权限掩码值置零\numask(0);if(mkfifo(&quot;test.pipe&quot;, 0600) != 0)&#123;//当返回值不为0的时候，代表出现了错误    cerr &lt;&lt; &quot;mkfifo error&quot; &lt;&lt; endl;    return 1;&#125;\n\n运行之后可以看到，出现了一个新的文件。其文件权限值的开头为p，代表它是一个管道文件\n\n之后的操作同样是文件操作，因为管道文件本质上就是一个文件\n\n先使用open方法，指定用读、写方法\n再分别在读写端read/write操作文件\n操作完成之后，close文件，并删除该文件\n因为管道文件有唯一的路径，其能够完成让两个进程看到同一份资源，也就实现了进程通信的功能！\n\n3.2 实现两个进程之间的通信下面通过一个服务端和客户端的代码，来演示多进程通信。\n\n服务端负责创建管道文件，以读方式打开该管道文件\n客户端以写方式打开管道文件，向服务端发送消息\n\n完整代码如下，包含一个头文件和两个源文件\n//MyPath.h#pragma once#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;using namespace std;#define NUM 1024#define FILE_PATH &quot;test.pipe&quot;//server.cpp#include&quot;MyPath.h&quot;int main()&#123;    //创建管道文件    umask(0);    if(mkfifo(FILE_PATH, 0600) != 0)    &#123;        cerr &lt;&lt; &quot;mkfifo error&quot; &lt;&lt; endl;        return 1;    &#125;    //打开管道文件    int pipeFd = open(FILE_PATH, O_RDONLY);    if(pipeFd &lt; 0)    &#123;        cerr &lt;&lt; &quot;open fifo error&quot; &lt;&lt; endl;        return 2;    &#125;    //开始通信    cout &lt;&lt; &quot;服务器启动&quot; &lt;&lt; endl;    char buffer[NUM];    while(1)    &#123;        //服务端执行读        ssize_t s = read(pipeFd, buffer, sizeof(buffer)-1);        if(s &gt; 0)        &#123;            buffer[s] = &#x27;\\0&#x27;;            cout &lt;&lt; &quot;客户端-&gt;服务器# &quot; &lt;&lt; buffer &lt;&lt; endl;        &#125;        else if(s == 0)        &#123;            cout &lt;&lt; &quot;客户端退出，服务器终止接收&quot; &lt;&lt; endl;            break;        &#125;        else        &#123;            cout &lt;&lt; &quot;read: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;            break;        &#125;    &#125;    close(pipeFd);    cout &lt;&lt; &quot;服务器关闭&quot; &lt;&lt; endl;    unlink(FILE_PATH);    return 0;&#125;//client.cpp#include&quot;MyPath.h&quot;int main()&#123;    int pipeFd = open(FILE_PATH, O_WRONLY);    if(pipeFd &lt; 0)    &#123;        cerr &lt;&lt; &quot;open: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        return 1;    &#125;    //客户端执行管道写入    char line[NUM];    while(true)    &#123;        printf(&quot;请输入你的消息# &quot;);        fflush(stdout);        memset(line, 0, sizeof(line));        //fgets的结尾会自动添加\\0        if(fgets(line, sizeof(line), stdin) != nullptr)        &#123;            //这里的意义是去掉接收到的回车\\n            //如：abcde\\n\\0 通过下面的代码去掉\\n            line[strlen(line) - 1] = &#x27;\\0&#x27;;            write(pipeFd, line, strlen(line));//管道写入        &#125;        else        &#123;            break;        &#125;    &#125;    close(pipeFd);    cout &lt;&lt; &quot;客户端退出&quot; &lt;&lt; endl;    return 0;&#125;\n\n通过头文件中的文件路径，我们能保证客户端和服务端处于同一个工作目录下，以便他们正确打开同一个管道文件\n先运行server，会发现并没有出现服务器启动的打印\n\n客户端启动了之后，服务器端才打印出服务器启动\n\n这时候，我们就可以在客户端输入消息，转到服务端读取\n\n这就完成了两个进程之间的通信。这两个进行并非父子进程，也不是兄弟关系！\n客户端CTRL+C终止的时候，服务端也会退出！\n\n等待前面提到了，当客户端没有启动的时候，服务端的打印没有被执行\n进一步测试发现，当我们同时用写方式打开管道文件的时候，这两个进程都会在open中等待，而不执行cout\n\n23776 31027 31027 23776 pts/23   31027 S+    1001   0:00 ./server23952 31043 31043 23952 pts/24   31043 S+    1001   0:00 ./client\n\n这说明，管道文件必须要同时以读写方式打开，才能正常执行后续代码。如果一个进程以写方式打开了一个管道，而该管道没有读端（反过来也是一样的），该进程就会进行阻塞等待\n\n4.管道的特性\n单个管道只支持单向通信，这是内核实现决定的。半双工的一种特殊情况\n管道自带同步机制，能够判断管道的状态，是否写满，是否没有写入等等\n管道是面向字节流的，先写的字符一定是先被读取的，在2.3中有所体现。需要用户来定义区分内容的边界（比如网络tcp协议）\n管道是一个文件，管道的生命周期跟随进程\n\n4.1 什么是半双工？半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；\n管道就是一种半双工的特殊情况，因为管道本身是支持任意进程读写的。对于进程A，它既可以成为管道的读端，又可以成为管道的写端。但一旦确认之后，管道的读写方向就不能被改变。\n所以管道是属于半双工的一种特殊情况\n4.2 拓展：单工&#x2F;半双工&#x2F;双工参考资料来源：博客园\n\n单工数据传输只支持数据在一个方向上传输；\n半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；\n全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。\n\n结语阿巴阿巴，关于管道的内容到这里就基本over了，我们通过匿名管道实现了控制多个子进程。通过命名管道实现了两个不相干进程之间的通信\n\n下篇博客是关于共享内存的\n\n如果有啥问题，可以在评论区提出哦！\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】文件IO","url":"/2022/11/01/code/note_Linux/14%E6%96%87%E4%BB%B6IO/","content":"让我们来认识一下linux下的文件接口吧！\n\n\n\n演示所用系统：CentOS7.6\n本文所有代码都可以在我的gitee仓库查看【链接】\n\n[TOC]\n1.什么是文件？\n文件=文件内容+文件属性，文件属性也是数据，即便我们创建一个空文件，也是会占用磁盘空间的\n文件操作=文件内容的操作+文件属性的操作，在之前linux权限的博客里面就提到过，文件操作有可能即改变内容，又改变属性\n文件打开操作其实是把文件的属性和内容加载到内存中，没有被打开的文件依旧处于磁盘当中\n当前路径为当前进程所处的工作路径\n\n我们的打开文件操作需要和磁盘这个硬件打交道，只有操作系统才能直接操作硬件。所以我们的文件操作其实都是调用的系统接口。\n实际上，所有编程语言都对操作系统接口进行了封装，这样才能保证他们的跨平台性。因为不同操作系统的各种接口各不相同，如果不进行封装，直接调用系统接口，则该代码只能在指定系统上跑！\n1.2 C语言文件操作在学习Linux下文件相关内容之前，我们先来复习一下C语言的文件接口\nvoid writetest()&#123;    char*file=&quot;test.txt&quot;;    FILE* f=fopen(file,&quot;w&quot;);    for(int i =0;i&lt;10;i++)    &#123;        fprintf(f,&quot;hello linux! %d\\n&quot;,i);    &#125;        fclose(f);    f=NULL;&#125;void readtest()&#123;    char*file=&quot;test.txt&quot;;    FILE* f=fopen(file,&quot;r&quot;);    char buff[128];//将读取到的数据写入buff数组里面    for(int i =0;i&lt;10;i++)    &#123;        fgets(buff,20,f);        printf(&quot;%s&quot;,buff);    &#125;    fclose(f);    f=NULL;&#125;\n\n这里用循环先往test.txt内输入10行数据，再读取并打印到屏幕上\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test1hello linux! 0hello linux! 1hello linux! 2hello linux! 3hello linux! 4hello linux! 5hello linux! 6hello linux! 7hello linux! 8hello linux! 9[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n\n除了w和r方法外，C语言还提供了w+ r+ a以及带b的二进制读写\n\n这部分内容可以去看看我之前的C语言文件操作博客！\n\nC语言默认打开了三个输入输出流，都是一个FILE*的指针，分别为stdin/stdout/stderr，记住这个点，后面会用到哦\n\n2.初识Linux系统的文件接口Linux下的文件操作用的接口为open/write/read，都需要先用open打开文件并指定打开方式后，再用write/read操作进行读写\n\n注：man查询的时候需要指定man 2 open，否则查询到的是命令不是函数接口\n\n\n这里open一共有两个函数接口，没错，就是函数重载！这是因为linux下的C语言标准和我们之前在win下学习所用的标准是不一样的！\n\n第一个参数为pathname，文件路径\n第二个参数为flags，打开文件的方式\n\n打开文件的方式并不像C语言用w/r等等代替，而是需要我们传入多个flag进行按位与，这一点和C++中的文件类一样！\n\n这里的flag其实是一种位图结构。每一个flag只需要在一个比特位上为1（十进制2的倍数）其余位为0，保证互不影响。这样在按位与的时候，才能正确凑到一起，并通过按位或进行flag的取出\n\n flag的参数中，下面这三个值，必须指定一个且只能指定一个\n\nO_RDONLY: 只读打开\nO_WRONLY: 只写打开\nO_RDWR: 读，写打开\n\n剩余的参数是用作额外操作的\n\nO_CREAT: 若文件不存在，则创建；需要传入mode参数，来指明新文件的访问权限\nO_APPEND: 追加写\nO_TRUNC: 清空文件\n……\n\n常用的参数就上面这些，更多参数可以使用man 2 open查看完整flag列表\n\n这种大写+下划线的命名方式告诉我们，它其实就是系统中预先定义好的宏！\n\n需要注意的是，open函数的返回值是一个int类型，它被称为文件描述符，后面会有详解\n\n2.1 读文件\n读文件的操作和fgets类似，需要指定文件描述符，以及用于保存文件内容的buf，和数据长度count\n#define SIZE 256void test1()&#123;    char buf[SIZE];    int fd1 = open(&quot;test.txt&quot;, O_RDONLY);    read(fd1,buf,strlen(buf)-1);    ssize_t s = read(fd1, buf, sizeof(buf)-1);    if(s &gt; 0)    &#123;       buf[s] = &#x27;\\0&#x27;;       printf(&quot;%s&quot;, buf);    &#125;    close(fd1);&#125;\n\nssize_t是有符号整型，其实就是int\ntypedef int ssize_t\n\n这里我们打开了刚刚测试C语言用的test.txt文件，成功读出了里面的内容\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testhello linux! 0hello linux! 1hello linux! 2hello linux! 3hello linux! 4hello linux! 5hello linux! 6hello linux! 7hello linux! 8hello linux! 9[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n2.2 写文件\n注意的是，默认情况下，如果我们不在open的时候指定第三个参数，其创建的新文件，权限是乱掉的。而单给第三个参数传入0666还不够，我们需要先把系统的umask在当前进程中设置为0，以避免系统umask的默认值对我们创建文件的权限造成影响\nvoid test2()&#123;    umask(0);//先把umask设置为0，保证权限值设置正确，不受系统umask影响    int fd = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);\t//这里我们指定了0_CREAT，所以需要指定0666作为权限值    const char *str = &quot;bbbbbb\\n&quot;;    write(fd, str, strlen(str));    close(fd);&#125;\n\n执行上述代码后，可以看到数据被成功写入\n\n这里我们还指定了O_TRUNC，所以每一次执行的时候，文件内部的内容都会被清空。修改str后重新进行测试，可以看到原有的内容不见了\n\n如果不指定，其不会清空已有内容。而是会从开头进行写入，覆盖开头已有的内容（左边为写入后，右边为写入前）\n\n实际上，C语言的文件操作，调用的就是linux的文件接口\nfopen(&quot;test.txt&quot;, &quot;w&quot;); //底层调用open，O_WRONLY | O_CREAT | O_TRUNCfopen(&quot;test.txt&quot;, &quot;a&quot;); //底层调用open，O_WRONLY | O_CREAT | O_APPEND\n\n写方式覆盖？在测试的时候，我发现了一个神奇的情况\nvoid test2()&#123;    umask(0);//先把umask设置为0，保证权限值设置正确，不受系统umask影响    int fd1 = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT, 0666);    int fd2 = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fd1: %d  fd2: %d\\n&quot;,fd1,fd2);    const char *str = &quot;bbadsfasdfasdfa23123bbbb&quot;;    write(fd1, str, strlen(str));    close(fd1);&#125;\n\n这里我分别用fd1/fd2打开了test.txt文件，打印它们的文件描述符可以看到，结果不一样\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testfd1: 3  fd2: 4[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n但是，执行的写入，却是 O_TRUNC的覆盖方法！\n\n实际上，并不是fd2的写入方法覆盖了fd1的，而是当我们使用 O_TRUNC方法打开文件的时候，文件里面的内容就已经被清空了！\n\n\n可以看到，刚刚才begin fd2的时候，test.txt的文件大小就已经变成0了\n为了避免这种情况，建议不要在同一个进程里面多次打开一个之前已经打开过的文件！\n3.文件描述符3.1 为什么是从3开始？这里我们一次性打开多个文件，打印他们的文件描述符\nvoid test3()&#123;    int fda = open(&quot;loga.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdb = open(&quot;logb.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdc = open(&quot;logc.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdd = open(&quot;logd.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fde = open(&quot;loge.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fda: %d\\n&quot;, fda);    printf(&quot;fdb: %d\\n&quot;, fdb);    printf(&quot;fdc: %d\\n&quot;, fdc);    printf(&quot;fdd: %d\\n&quot;, fdd);    printf(&quot;fde: %d\\n&quot;, fde);&#125;\n\n\n会发现打印的文件是从3开始的。这和我们之前是否有打开过文件没关系，任何进程open的自己的文件都是从3开始的！\n还记得前面C语言部分提到的stdin/stdout/stderr吗？\nlinux系统下一切皆文件，这三个家伙也不例外！既然C语言的文件操作封装了系统的接口，那么其内部肯定是有文件描述符的存在的，我们只需要找到它就行了。\n这一点，代码补全就可以帮忙了\n\nvoid test4()&#123;    //c语言中的FILE是一个结构体，里面管理了linux系统的文件描述符    printf(&quot;stdin %d\\n&quot;,stdin-&gt;_fileno);//  0    printf(&quot;stdout %d\\n&quot;,stdout-&gt;_fileno);// 1    printf(&quot;stderr %d\\n&quot;,stderr-&gt;_fileno);// 2    FILE* f1 = fopen(&quot;test.txt&quot;,&quot;w&quot;);    printf(&quot;f1 %d\\n&quot;,f1-&gt;_fileno);//3&#125;\n\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./teststdin 0stdout 1stderr 2f1 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n打印之后我们发现，其0 1 2就是被C语言的这三个默认打开的文件流占用了，而我们用C语言fopen打开的文件，其文件描述符也是从3开始的！\n\n用文件描述符调用stdin&#x2F;out既然stdout对应的文件描述符是1，那我们可不可以直接调用系统的接口往屏幕上输出东西呢？\nvoid test5()&#123;    char buf[SIZE]=&quot;12345678910\\n&quot;;    write(1,buf,strlen(buf));&#125;\n\n当然是可以的！\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test12345678910[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n同理，我们还可以这样来接收用户输入\nvoid test6()&#123;    char buf[SIZE];    ssize_t s = read(0,buf,sizeof(buf));    if(s&gt;0)    &#123;        buf[s]=&#x27;\\0&#x27;;        printf(&quot;stdin: %s\\n&quot;,buf);    &#125;&#125;\n\n\n运行的时候，程序会挂起等待用户输入，由此可以打印获取输入的结果👇\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ makegcc test.c -o test -std=c99[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testasdfasdfadfadfstdin: asdfasdfadfadf[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n\n3.2 从0开始？数组下标！\n既然stdin/stdout/stderr分别对应的是0/1/2，而我们打开的自己的文件对应的是3开始，有没有可能，这些数字是一个数组的下标呢？\n\n一个进程打开的文件，其数据是在内存中的。操作系统内核肯定需要管理一个进程已经打开的文件！万一有“大聪明”忘记close文件了，而操作系统又没去管理已有文件，其不就会造成内存泄漏吗？\n在操作系统中，有一个struct file，其管理的就是已经打开了的文件\nstruct file&#123;    //包含了文件的内容+属性&#125;\n\n同时，这个文件内核还会被插入到进程的task_struct中，因为一个进程是可以同时打开多个文件的。操作系统在对已打开文件进行管理的同时，还需要对一个进程打开的文件进行管理（知道某个文件是谁打开的）\n\n下载的linux源码中，task_strcut的位置如下\nlinux-2.6.32.12/include/linux/sched.h\n\n\n\n而我们文件描述符，其实就是进程中管理文件的一个数组的下标。\n\nstruct files_struct &#123;  /*   * read mostly part   */\tatomic_t count;\tstruct fdtable *fdt;\tstruct fdtable fdtab;  /*   * written part on a separate cache line in SMP   */\tspinlock_t file_lock ____cacheline_aligned_in_smp;\tint next_fd;\tstruct embedded_fd_set close_on_exec_init;\tstruct embedded_fd_set open_fds_init;\tstruct file * fd_array[NR_OPEN_DEFAULT];//文件数组&#125;;\n\n这样对进程打开的文件的管理，就被转化为了对这个数组的增删查改\n3.3 Linux下一切皆文件最初学习Linux的时候，就提到了Linux下一切皆文件\n现在我们知道了内核中是用file结构体来管理文件的，那么，它是怎么用文件来管理键盘、鼠标、显示器、磁盘、网卡的呢？\n这时候就可以来“浅浅”的看一下源码了！不求看懂代码实现，只求理解理念\n\nstruct file位于include/linux/fs.h中\n\nstruct file &#123;\t/*\t * fu_list becomes invalid after file_free is called and queued via\t * fu_rcuhead for RCU freeing\t */\tunion &#123;\t\tstruct list_head\tfu_list;\t\tstruct rcu_head \tfu_rcuhead;\t&#125; f_u;\tstruct path\t\tf_path;#define f_dentry\tf_path.dentry#define f_vfsmnt\tf_path.mnt\tconst struct file_operations\t*f_op;\tspinlock_t\t\tf_lock;  /* f_ep_links, f_flags, no IRQ */\tatomic_long_t\t\tf_count;\tunsigned int \t\tf_flags;\tfmode_t\t\t\tf_mode;\tloff_t\t\t\tf_pos;\tstruct fown_struct\tf_owner;\tconst struct cred\t*f_cred;\tstruct file_ra_state\tf_ra;\tu64\t\t\tf_version;#ifdef CONFIG_SECURITY\tvoid\t\t\t*f_security;#endif\t/* needed for tty driver, and maybe others */\tvoid\t\t\t*private_data;#ifdef CONFIG_EPOLL\t/* Used by fs/eventpoll.c to link all the hooks to this file */\tstruct list_head\tf_ep_links;#endif /* #ifdef CONFIG_EPOLL */\tstruct address_space\t*f_mapping;#ifdef CONFIG_DEBUG_WRITECOUNT\tunsigned long f_mnt_write_state;#endif&#125;;\n\n其余内容用来干哈子的咱暂且不管，目光聚焦于这一个结构体\nconst struct file_operations\t*f_op;\n\n翻译过来，这个成员的名字为文件操作。再来复习一下const修饰指针的知识点\n\nconst修饰指针有下面两种形式\n\n在*之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）\n在*之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）\n\n\n在这个结构体中，就有read/write方法，它们是两个函数指针\nstruct file_operations &#123;\tstruct module *owner;\tloff_t (*llseek) (struct file *, loff_t, int);\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\tssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);\tssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);\tint (*readdir) (struct file *, void *, filldir_t);\tunsigned int (*poll) (struct file *, struct poll_table_struct *);\tint (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\tint (*mmap) (struct file *, struct vm_area_struct *);\tint (*open) (struct inode *, struct file *);\tint (*flush) (struct file *, fl_owner_t id);\tint (*release) (struct inode *, struct file *);\tint (*fsync) (struct file *, struct dentry *, int datasync);\tint (*aio_fsync) (struct kiocb *, int datasync);\tint (*fasync) (int, struct file *, int);\tint (*lock) (struct file *, int, struct file_lock *);\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\tint (*check_flags)(int);\tint (*flock) (struct file *, int, struct file_lock *);\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\tint (*setlease)(struct file *, long, struct file_lock **);&#125;;\n\nlinux操作系统内的文件系统以统一的方式看待所有的设备。\n特定的设备的read/write方法是不一样的，只需要在这些硬件的驱动程序中给操作系统提供读写这个设备的函数实现，操作系统则将函数指针指向对应的函数，便能实现对某一个硬件设备的操作！\n比如调用显示器驱动的write刷新显示器的画面，调用网卡的read/write来下载/上传数据等等！\n\n\n3.4 分配规则分配文件描述符的时候，会从头开始遍历fd_array[]，找到第一个没有被使用的下标，分配给新的文件！\nvoid test7()&#123;    int fda = open(&quot;loga.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    int fdb = open(&quot;logb.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);        printf(&quot;fda: %d\\n&quot;, fda);    printf(&quot;fdb: %d\\n&quot;, fdb);    close(fda);    printf(&quot;\\n&quot;);    int fdc = open(&quot;logc.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fdc: %d\\n&quot;, fdc);&#125;\n\n上述代码中，我们先打开了两个文件，打印可以看到其文件描述符为3/4；关掉第一个文件后，再打开一个新的文件，会发现文件描述符还是3（第一个为空的文件描述符）\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testfda: 3fdb: 4fdc: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n输出重定向同理，如果我们在打开文件之前，就关闭掉C语言打开的stdout，那么此时打开文件的fd就为1，我们的printf则会把数据打印到该文件当中！\nvoid test8()&#123;    //文件描述符分配的时候，会在数组里面找第一个为空的描述符    printf(&quot;start test!\\n&quot;);//打印到屏幕上    close(1);//关闭stdout    int fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    printf(&quot;fd: %d\\n&quot;,fd);//打印到文件中    close(fd);&#125;\n\n可以看到，运行./test之前，文件里面没有内容。执行之后，就把我们printf的数据输出到文件当中了！\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./teststart test![muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtfd: 1[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n这种操作就叫做输出重定向！\n另外一种情况下，如果我们在关闭stdout之前不进行printf，则不会立马刷新到log.txt而是需要我们刷新了缓冲区之后，才会写入到文件中\nclose(1);//关闭stdoutint fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);printf(&quot;fd: %d\\n&quot;,fd);fflush(stdout);close(fd);\n\n这里有个小技巧&gt;log.txt可以用来清空文件的内容\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ &gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$\n\n\n3.5 dup2上面是我们手动进行的输出重定向操作。操作系统提供了一个接口，可以让我们很方便地进行输出重定向\nint dup2(int oldfd, int newfd);\n\n\n这里我们要用的是dup2函数，它的作用如下\ndup2() makes newfd be the copy of oldfd, closing newfd first if necessary, but note the following:*  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.*  If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.\n\n一定要看清楚，是将newfd变成oldfd的一个拷贝，在执行完毕之后，就只剩oldfd了！\n如果newfd原本已经打开了一个文件，该操作会先将newfd给关掉\nRETURN VALUEOn success, these system calls return the new descriptor.  On error, -1 is returned, and errno is set appropriately.\n\n该函数成功的时候会返回newfd，否则返回-1\n\n下面为一个示例代码，假设我们想将输出的内容重定向到一个文件中，则可以使用dup2将1替换为我们自己的fd，此时oldfd=fd,newfd=1\nvoid test9()&#123;    int fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);    dup2(fd, 1);    int ret = dup2(fd, 1);    if(ret &gt; 0)         close(fd);    printf(&quot;ret: %d\\n&quot;, ret);//ret为newfd    //本来往显示器打印，最终变成向指定文件打印 -&gt; 重定向    fprintf(stdout, &quot;打开文件成功，fd: %d\\n&quot;, fd);    fflush(stdout);//刷新缓冲区    close(fd);&#125;\n\n结果如下，我们成功的将内容printf到了指定文件中\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ &gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n\n为什么这里可以用stdout来输出到文件中呢？\n\n因为当我们使用dup2的时候，stdout所指向的文件描述符1已经被替换成了log.txt，此时对stdout的操作就是对我们自己的文件操作\n\n为什么这里我们已经把fd关掉了，但是替换掉的文件描述符1不受影响呢？\n\n同一个文件是可以被打开多次的！执行dup2的时候，可以理解为操作系统又一次打开了fd指向的文件，在文件底层，则有一个计数来判断该文件被打开了几次。当我们close(fd)的时候，只是让该文件底层struct file的打开计数-1，并非完全关闭了该文件！此时1还能正确指向log.txt呢\n追加重定向这里只需要我们改变fd打开的方式，加上O_APPEND即可！\nvoid test9()&#123;    int fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_APPEND, 0666);    dup2(fd, 1);    int ret = dup2(fd, 1);//    if(ret &gt; 0)         close(fd);    printf(&quot;ret: %d\\n&quot;, ret);//ret为newfd    //本来往显示器打印，最终变成向指定文件打印 -&gt; 重定向    fprintf(stdout, &quot;打开文件成功，fd: %d\\n&quot;, fd);    fflush(stdout);//刷新缓冲区    close(fd);&#125;\n\n运行可以看到，成功在后面追加\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3ret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n输入重定向//输入重定向void test11()&#123;    int fd = open(&quot;log.txt&quot;,O_RDONLY);    if(fd&lt;0)    &#123;        perror(&quot;open&quot;);        return ;    &#125;    int ret = dup2(fd,0);//重定向stdin    if(ret &gt; 0)         close(fd);    char buf[128];    while(fgets(buf,sizeof(buf),stdin)!=NULL)    &#123;        printf(&quot;%s&quot;,buf);    &#125;&#125;\n\n此时我们的stdin被dup2替换成了log.txt，其获取输入的操作转为了读取文件\n[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ cat log.txtret: 1打开文件成功，fd: 3ret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./testret: 1打开文件成功，fd: 3ret: 1打开文件成功，fd: 3[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ \n\n3.6 标准输出&#x2F;标准错误之前写代码的时候，我们常常直接使用了printf来打印一些错误信息，而没有怎么用过perror/cerr这两个库函数\n那么它们和printf/cout又有什么区别呢？\nint main()&#123;    // stdout    printf(&quot;hello printf\\n&quot;);    fprintf(stdout, &quot;hello fprintf to stdout\\n&quot;);    fputs(&quot;hello fputs to stdout\\n&quot;, stdout);    cout &lt;&lt; &quot;hello cout&quot; &lt;&lt; endl;    // stderr    perror(&quot;hello perror&quot;);    fprintf(stderr, &quot;hello fprintf to stderr\\n&quot;);    fputs(&quot;hello fputs to stderr\\n&quot;, stderr);    cerr &lt;&lt; &quot;hello cerr&quot; &lt;&lt; endl;    return 0;&#125;\n\n测试发现，似乎没有啥区别啊，不都打印到屏幕上了吗？\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./testhello printfhello fprintf to stdouthello fputs to stdouthello couthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n非也！当我们使用重定向的时候，就出现问题了\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &gt;log.txthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello printfhello fprintf to stdouthello fputs to stdouthello cout[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n欸？不是使用了重定向吗，为什么还在屏幕上输出了内容呢？\n仔细一看，输出的都是stderr的内容，而没有stdout。cat文件一看，stdout的内容都在文件里面嘞！\n还记得吗？stdout/stderr对应的文件描述符是1/2，而在默认情况下，它们都指向的是显示器。\n\n注意：虽然它们两个指向都是显示器，但它们是通过两个不同的文件描述符，独立地往显示器上打印内容的！\n\n我们重定向的时候，其实省略了一个1，默认情况下，重定向只对1号描述符，也就是stdout有效！\n./test &gt;log.txt./test 1&gt;log.txt\n\n如果我们把这里的1换成2，结果就不一样了\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test 2&gt;log.txthello printfhello fprintf to stdouthello fputs to stdouthello cout[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n可以看到，stderr的内容进了文件，而stdout的内容输出到了屏幕上\n区分错误和正常输出这么设计的意义，就是为了方便我们定位问题。将错误和正常的打印输出写道不同的文件中。如果我们像只关注错误，就只需要去查找记录了错误信息的文件即可\n混合输出2&gt;&amp;1如果我们就是不听不听，非要把他俩打一个文件里面，应该怎么弄呢？\n./test &gt;log.txt 2&gt;&amp;1\n\n这个2&gt;&amp;1的操作需要我们理解：\n\n./test运行可执行程序\n&gt;log.txt代表重定向，默认只重定向了1\n现在指向log.txt的是1号文件描述符，代表stdout\n2&gt;&amp;1代表将2重定向到1，可以理解为dup2(1,2);\n执行结束后，2就成了1的一份拷贝，现在只剩下了1\n因为1指向的是log.txt，所以2也指向的是相同文件\n\n而这个语句必须写在&gt;log.txt的后面， 否则意义就错误了👇\n./test 2&gt;&amp;1 &gt;log.txt #错误写法\n\n\n2&gt;&amp;1代表将2重定向到1，此时1指向的是屏幕，所以2也指向了屏幕\n&gt;log.txt代表将1指向文件，此时1指向了文件，但是2还是指向屏幕\n白写！\n\n执行了正确的命令后，来看看结果吧！\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &gt;log.txt 2&gt;&amp;1[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello printfhello fprintf to stdouthello fputs to stdouthello couthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n标准错误和标准输出的内容都被写入到文件中了！\n上面的整法实在有点太长了，而且还有可能记不住写反了。所以有一种简写的方式\n#简写方式&amp;&gt;log.txt#上面的写法等同于&gt;log.txt 2&gt;&amp;1\n\n测试一下，没问题！\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ &gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &amp;&gt;log.txt[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txthello printfhello fprintf to stdouthello fputs to stdouthello couthello perror: Successhello fprintf to stderrhello fputs to stderrhello cerr[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n\n关于2&gt;&amp;1的详解参考👉 传送门\n\n\n4.C语言缓冲区4.1 观察现象先来看看下面的代码，分别调用C语言的printf和操作系统的write接口，往屏幕上打印内容。结束后sleep(3)\nvoid test1()&#123;    printf(&quot;test printf &quot;);    const char*msg = &quot;test write &quot;;    write(stdout-&gt;_fileno,msg,strlen(msg));    sleep(3);&#125;\n\n\n我们惊奇的发现，第一个打印出来的竟然是write，而不是在它之前的printf接口！\nvoid test1()&#123;    printf(&quot;test printf &quot;);    fflush(stdout);    const char*msg = &quot;test write &quot;;    write(stdout-&gt;_fileno,msg,strlen(msg));        sleep(3);&#125;\n\n只有在printf后立马调用fflush刷新缓冲区，才能按正确的“顺序”打印出内容来\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest printf test write [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n在调用其他C语言的函数，往屏幕上输出信息。我们会发现结果相同！都是先打印出来write结果，才一次性打印出所有C语言函数的结果\nvoid test2()&#123;    printf(&quot;test printf &quot;);    fprintf(stdout,&quot;test fprintf &quot;);    fputs(&quot;test fputs &quot;,stdout);    const char*msg = &quot;test write &quot;;    write(stdout-&gt;_fileno,msg,strlen(msg));        sleep(3);&#125;\n\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest write test printf test fprintf test fputs [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n由此可见，之前我们一直提到的缓冲区，其实是C语言提供的！\n\n注意：缓冲区不止C语言内部有，操作系统内也有。本文只讨论C语言提供的缓冲区\n\n\n4.2 缓冲区在哪?printf(&quot;test printf &quot;);fprintf(stdout,&quot;test fprintf &quot;);fputs(&quot;test fputs &quot;,stdout);\n\n上面这几个函数都有一个共同的特点：它们都往stdout里面打印了内容！\n\nprintf虽然没有显示指定stdout，但是底层是有的\n\n我们知道，C语言的文件是一个FILE类型的结构体。该结构体内封装了很多属性，其中stdout的_fileno文件描述符，就是该FILE对应的语言级别的缓冲区！\n关闭文件描述符如果我们在数据刷新之前，关闭了stdout对应的文件描述符，会发生什么？\nprintf(&quot;test printf &quot;);fprintf(stdout,&quot;test fprintf &quot;);fputs(&quot;test fputs &quot;,stdout);const char*msg = &quot;test write &quot;;write(stdout-&gt;_fileno,msg,strlen(msg));sleep(3);close(stdout-&gt;_fileno);\n\n结果就是，啥都没有刷新！\n缓冲区都被关闭了，其内部的数据都无了，肯定不会刷新啦~\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest write [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n而在输出重定向中，打印的内容没有直接被显示的，也是因为我们没有在关闭fd之前刷新stdout（此时指向的是fd）中的缓冲区\nclose(1);//关闭stdoutint fd = open(&quot;log.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);printf(&quot;fd: %d\\n&quot;,fd);fflush(stdout);close(fd);\n\nFILE既然stdout的缓冲区在FILE内部，推而广之，所有用C语言打开的文件，FILE中都会有一个文件描述符和它自己的语言级别缓冲区\ntypedef struct _IO_FILE FILE;\n\n库函数中的FILE是一个struct _IO_FILE类型的结构体，其定义如下\nstruct _IO_FILE &#123;  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  //下面这些就是它的缓冲区  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;\t/* Current read pointer */  char* _IO_read_end;\t/* End of get area. */  char* _IO_read_base;\t/* Start of putback+get area. */  char* _IO_write_base;\t/* Start of put area. */  char* _IO_write_ptr;\t/* Current put pointer. */  char* _IO_write_end;\t/* End of put area. */  char* _IO_buf_base;\t/* Start of reserve area. */  char* _IO_buf_end;\t/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;//文件描述符#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;\n\n我们可以看到有多个变量用于维护该文件的缓冲区，也证实了缓冲区是由C语言提供的这一结论。\n4.3 缓冲区的作用C语言提供缓冲区的理由很简单，相对于内存而言，其余硬件都是满设备。\n\n为代码提供缓冲区，可以提高该程序&#x2F;进程输出的效率\n缓冲区可以集中处理数据刷新，减少IO的次数，提高了整机运行效率\n\n4.4 什么时候刷新缓冲区？什么时候刷新缓冲区，对应的是刷新策略问题\n常规的刷新策略\n\n无缓冲（立即刷新）\n行缓冲（逐行刷新）\n全缓冲（缓存区满，刷新）\n\n特殊情况\n\n进程退出（刷新）\n用户调用函数，强制刷新\n\n刷新与子进程void test3()&#123;    const char*str1=&quot;test printf\\n&quot;;    const char*str2=&quot;test fprintf\\n&quot;;    const char*str3=&quot;test fputs\\n&quot;;    const char*str4=&quot;test write\\n&quot;;    //C语言    printf(str1);//这样写也是ok的    fprintf(stdout,str2);    fputs(str3,stdout);    //系统接口    write(stdout-&gt;_fileno,str4,strlen(str4));    //子进程创建    fork();&#125;\n\n上面的代码，会出现两种运行情况\n\n如果直接打印到屏幕上，打印的顺序和内容都是正确的\n如果重定向到文件中，却发现C语言打印的内容都多打了一次！\n\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./testtest printftest fprintftest fputstest write[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test &gt; log.txt[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txttest writetest printftest fprintftest fputstest printftest fprintftest fputs[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n刷新的本质，其实就是把缓冲区中数据，调用write接口通过操作系统写入到文件中。而FILE内部的缓冲区，是属于父进程内部的数据。\n当我们在刷新之前fork创建子进程的时候，会发生一次写时拷贝\n结果就是父进程、子进程各刷新一次。于是就出现了上面的C语言的内容多了一份的现象！\n\n4.5 简单模拟实现缓冲区，本质就是C语言在文件的结构体中维护的一个数组。同时维护了多种刷新策略，在不同的时刻将该数组的内容调用系统接口write写入文件\n这里我们提供了一个简单的MyFILE结构体，内部封装文件描述符、刷新策略、缓冲区\n#define NONE_FLUSH 0x0 //无刷#define LINE_FLUSH 0x1 //行刷#define FULL_FLUSH 0x2 //全缓存typedef struct MyFILE&#123;    int _fileno;    char _buffer[NUM];    int _end;//缓冲区结尾    int _fflags; //刷新策略&#125;MyFILE;\n\n有了自己的文件结构体，对应的也需要分装一下系统的open/read/write/close等接口，还有fflush用于强制刷新\n\n封装接口为了做到尽量简单，这里暂时只封装r/w/a三种打开方法\nMyFILE *my_fopen(const char *filename, const char *method)&#123;    assert(filename);    assert(method);    int flags = O_RDONLY;    if(strcmp(method, &quot;r&quot;) == 0)    &#123;        flags = O_RDONLY;    &#125;    else if(strcmp(method, &quot;w&quot;) == 0)    &#123;        flags = O_WRONLY | O_CREAT | O_TRUNC;    &#125;    else if(strcmp(method, &quot;a&quot;) == 0)    &#123;        flags = O_WRONLY | O_CREAT | O_APPEND;    &#125;    int fileno = open(filename, flags, 0666);    if(fileno &lt; 0)    &#123;        return NULL;    &#125;    MyFILE *fp = (MyFILE *)malloc(sizeof(MyFILE));    if(fp == NULL) return fp;    memset(fp, 0, sizeof(MyFILE));    fp-&gt;_fileno = fileno;    fp-&gt;_fflags |= LINE_FLUSH;//默认行缓冲    fp-&gt;_end = 0;    return fp;&#125;\n\n这里暂时只用行缓冲和全缓冲来体验一下缓冲区的作用。同时只对字符串结尾的\\n进行了判断，情况不够全面。\n\n这里其实我很好奇，C库里面是怎么处理\\n的捏；总不能用遍历吧？那样效率也太低了。个人猜测是和预先设置的特殊字符有关系。\n\nvoid my_fwrite(MyFILE *fp, const char *start, int len)&#123;    assert(fp);    assert(start);    assert(len &gt; 0);    //先写入到缓冲区里面    strncpy(fp-&gt;_buffer+fp-&gt;_end, start, len); //将数据写入到缓冲区了    fp-&gt;_end += len;    if(fp-&gt;_fflags &amp; NONE_FLUSH)    &#123;&#125;    else if(fp-&gt;_fflags &amp; LINE_FLUSH)    &#123;        //这里的判断只是测试，实际上还需要判断中间有无\\n        if(fp-&gt;_end &gt; 0 &amp;&amp; fp-&gt;_buffer[fp-&gt;_end-1] == &#x27;\\n&#x27;)        &#123;            //写入到内核中            write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);            fp-&gt;_end = 0;            syncfs(fp-&gt;_fileno);        &#125;    &#125;    else if(fp-&gt;_fflags &amp; FULL_FLUSH)    &#123;//满了刷新        if(fp-&gt;_end &gt; 0 &amp;&amp; fp-&gt;_end==NUM)        &#123;            //写入到内核中            write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);            fp-&gt;_end = 0;            syncfs(fp-&gt;_fileno);        &#125;    &#125;&#125;\n\n这里有一个新接触的函数syncfs\nint syncfs(int fd);\n\n该函数是一个系统调用接口，用于将文件内核缓冲区内的数据写入到指定文件中。\n前面我们提到的缓冲区，一直说的都是C语言内部维护的。从这个接口也能看出，操作系统同样对文件进行了缓冲区的维护。\n\nvoid my_fflush(MyFILE *fp)&#123;    assert(fp);    if(fp-&gt;_end &gt; 0)    &#123;        write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);        fp-&gt;_end = 0;        syncfs(fp-&gt;_fileno);    &#125;&#125;void my_fclose(MyFILE *fp)&#123;    my_fflush(fp);    close(fp-&gt;_fileno);    free(fp);&#125;\n\n运行测试int main()&#123;    MyFILE *fp = my_fopen(&quot;log.txt&quot;, &quot;w&quot;);    if(fp == NULL)    &#123;        printf(&quot;my_fopen error\\n&quot;);        return 1;    &#125;        const char *a = &quot;hello my 111\\n&quot;;    my_fwrite(fp, a, strlen(a));    printf(&quot;消息立即刷新\\n&quot;);    sleep(3);    const char *b = &quot;hello my 222 &quot;;    my_fwrite(fp, b, strlen(b));    printf(&quot;写入了一个不满足刷新条件的字符串\\n&quot;);    sleep(3);    const char *c = &quot;hello my 333 &quot;;    my_fwrite(fp, c, strlen(c));    printf(&quot;写入了一个不满足刷新条件的字符串\\n&quot;);    sleep(3);    const char *d = &quot;end\\n&quot;;    my_fwrite(fp, d, strlen(d));    printf(&quot;写入了一个满足刷新条件的字符串\\n&quot;);    sleep(3);    my_fclose(fp);    printf(&quot;程序结束\\n&quot;);&#125;\n\n刚开始的时候，我们写入了一个\\n结尾的字符串，其立马写入到了文件中\n\n随后写入了两个不满足刷新条件的字符串，文件中没有出现结果\n\n\n而当我们写入一个满足刷新条件的字符串后，缓冲区的内容就同时被写入到文件中了！\n\n子进程测试除此之外，我们还可以测试一下子进程是否会出现刷新两次的情况\nvoid test2(MyFILE * fp)&#123;    const char *s = &quot;-test &quot;;    my_fwrite(fp, s, strlen(s));    printf(&quot;写入了一个不满足刷新条件的字符串\\n&quot;);    fork();&#125;int main()&#123;    MyFILE *fp = my_fopen(&quot;log.txt&quot;, &quot;w&quot;);    if(fp == NULL)    &#123;        printf(&quot;my_fopen error\\n&quot;);        return 1;    &#125;    //test1(fp);    test2(fp);    //模拟进程退出    my_fclose(fp);    printf(&quot;程序结束\\n&quot;);&#125;\n\n结果如我们所料，文件中出现了两个-test  ，原因在4.4中已做解释\n[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txt[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test1写入了一个不满足刷新条件的字符串程序结束程序结束[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ cat log.txt-test -test [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ \n\n\n5.文件系统之前我们提到的这些数据，都是存放在内存中的。接下来我们便要来了解一下操作系统是如何管理磁盘上的文件。\n\n5.1 磁盘的物理结构以机械硬盘为例，其内部主要由盘片和磁头组成。\n\n当我们改变磁盘上某一个位置的NS极，就好比更改了此处保存的数据0/1\n\n在机械硬盘中，一个盘片对应一个磁头\n\n每个盘片被分为诺干个同心圆，每一个同心圆就是一个磁道\n每个磁道被划分为诺干段（扇区）\n每个扇区的存储容量为512字节\n\n由此可见，当我们读写机械硬盘的时候，需要去找某一个盘面、某一个磁道的某一片扇区，就能找到该扇区的数据！\n\n盘面（磁面）有自己对应的磁头\n磁道是由距离圆心的半径决定的\n扇区是由盘面旋转决定的\n\n而操作系统的文件系统所作的工作，便是将文件和其对应的扇区联系起来。用上面提到的办法，便可以查找到每一个扇区！\n\n这种查找数据位置的操作，被称为CHS寻址，CHS分别对应磁柱、磁面、扇区\n5.2 CHS和LBA\n更详细的解析参考：https://blog.csdn.net/jadeshu/article/details/89072512\n\n假设我们把一个磁道的数据“拉直”，其就变成了一条直线。依此类推，可以把每一个盘面上的每一条磁道都“拉直”\n\n最终，其不就变成了和上图类似的“长条状”了吗？我们学过的什么数据结构也是线性长条的捏？\n没错！就是数组！\n此时，对磁盘文件的修改，就可以抽象成对内核中一个数组的增删查改操作！\n这种抽象之后的磁盘，被称为LBA逻辑块地址，他们之中有一个转换关系👇\n用C表示当前柱面号，H表示当前磁头号，S表示当前扇区号，CS表示起始柱面号，HS表示起始磁头号，SS表示起始扇区号，PS表示每磁道有多少个扇区，PH表示每柱面有多少个磁道，计算公式如下：$$LBA &#x3D; ( C – CS ) * PH * PS + ( H – HS ) * PS + ( S – SS )$$通过这个公式，我们就能将磁盘中的一个区块的数据，转为数组中的一个下标，来方便操作系统访问$$C &#x3D; LBA &#x2F; ( PH * PS ) + CS$$\n$$H &#x3D; ( LBA &#x2F; PS ) % PH + HS$$\n$$S &#x3D; LBA &#x2F; PS + SS$$修改了数组中的数据之后，操作系统将LBA对应的CHS地址算出来交给磁盘，让磁盘来修改指定扇区的数据，便实现了保存数据到磁盘中的操作\n\n5.3 IO的基本单位对于操作系统而言，一次IO的基本单位是4kb，也就是8个扇区8*512字节\n\n磁盘的基本单位：扇区（一般为512字节)\n文件系统访问磁盘的基本单位：4kb\n\n在操作系统中，会对前面提到的那个“数组”进一步抽象，8个扇区会被合并成一个4KB的区块，用于单次IO。为了方便管理每一个区块，又将多个区块合并，作为一个分区进行管理\n这便是我们电脑上同一块物理硬盘可以对应不同分区的来源了！\n\n为什么？为什么操作系统要以4kb作为IO的基本单位呢？\n\nhttps://www.51cto.com/article/617936.html\n\n在上文中提到，Linux选择4KB作为“页操作”（即读取内存，以及从内存写入磁盘）的基本单位算是一个历史遗留问题了。\n\n过小的页大小会带来较大的寻址开销\n过大的页大小浪费内存空间，造成内存碎片\n\n而当初这么选择，肯定是有其功用的！\n\n能提高IO效率，不需要多次写入512字节的数据\n不让文件系统的设计和磁盘有强相关性，解耦合\n\n对于第二点进行说明，如果文件系统不在扇区外额外选择一个空间作为IO的基本单位，那么其设计必定会依赖于磁盘扇区大小。\n如果某一天，所有磁盘的扇区大小都从512字节变成了1024字节，那就必须要修改操作系统的源码，才能正确访问新的硬盘。同时还需要对旧盘做优化，可谓事倍功半。\n而提前设定好一个更大的IO基本单位，便是避免了磁盘变动而造成的无法访问。有了这个更大的IO基本单位，我们只需要把磁盘的扇区组成一个4kb大小的空间进行IO，不用管其磁盘扇区大小到底是多少了。\n\n当然，如果哪天扇区大小大于4kb了，恐怕就得改源码了？\n这部分我也不是很懂呢，以上只是个人浅显的理解\n\n\n5.4 系统结构下图向我们展示了一个磁盘是如何被文件系统“拆分”的\n首先是分区，每一个分区都有一个BootSector和文件系统。我们主要关注文件系统中，单个Block Group里面的内容\n\nlinux采用的是文件内容、文件属性分开存放的存储方式\n\n文件的属性是稳定的\n文件的内容在不断增多\n\ndata blocks：保存数据内容inode table：保存文件的inodeinode bitmap：位图结构，指示inode是否被使用GDT：全称group descriptor table，保存了inode个数、起始inode编号、多少inode被使用、多少data blocks被使用……Super Blocks：该Block Group文件系统的顶层数据结构\n\ninode这里提到的inode是linux下每一个文件的独立编号。linux并不以文件名来识别文件，而是用文件编号来识别唯一的文件的。\ninode保存了一个文件的基本信息\n\n文件的属性\nrwx权限\n所属用户、所属组\n硬链接个数\n文件访问、修改、创建的时间\n指向data blocks中文件的内容\n\n\nstruct inode的位置在/include/linux/fs.h\n\n\n查看inode编号的方法为ls -i，其中这串数字便是该文件的inode编号\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -i1453833 makefile  1453832 test.cpp\n\n我们也可以看到，.和..这两个文件夹也是有自己的inode编号的，印证了linux下一切皆文件，包括目录\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -ilatotal 161453831 drwxrwxr-x  2 muxue muxue 4096 Nov  2 09:58 .1443736 drwxrwxr-x 16 muxue muxue 4096 Nov  2 09:20 ..1453833 -rw-rw-r--  1 muxue muxue   81 Nov  2 09:58 makefile1453832 -rw-rw-r--  1 muxue muxue  437 Nov  2 09:35 test.cpp\n\nstat命令还可以用stat命令来查看单个文件的inode信息\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ stat test.cpp  File: ‘test.cpp’  Size: 437             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1453832     Links: 1Access: (0664/-rw-rw-r--)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-11-02 09:35:07.684160444 +0800Modify: 2022-11-02 09:35:04.328161202 +0800Change: 2022-11-02 09:35:04.328161202 +0800 Birth: -\n\ninode内部有一个结构，指向data blocks。前面提到过，文件系统IO的基本单位是4KB，对应的，一个blocks的大小就是4KB\n每一个文件都对应一个inode，至少对应一个data blocks（inode中储存了blocks编号）\n因为inode所能保存的编号有限，所以对data blocks的保存分为两种情况\n\n部分data blocks直接保存了文件的内容。如果是小文件，inode中保存的block就足够存下所有文件内容了\n如果是大文件，inode中一部分blocks会用来保存该文件剩余data blocks的编号\n\n在内核中，文件系统会对这两种情况进行区分\n注意\n\n因为每一个文件都肯定有一个inode与之对应，所以创建空文件也是占用磁盘空间的\n可能会出现inode被用完了，磁盘空间却没有满的情况。但这时候也已经无法创建新文件了\n\n😂你可以尝试写一个while1循环，不断往系统中创建新文件，看看能不能达到这个临界值（咳咳，虽然好玩，但并不推荐你这么做）\n\n文件名存在哪儿？前面提到过，inode保存了文件的属性，文件名是否为文件的属性呢？也算！\n但inode中并不保存文件名字！\n实际上，文件名是存在该文件所在目录的文件内容中的\n\n目录也是文件，文件就有文件属性+文件内容\n\n可以理解为，目录的内容保存的是一个键值对，其中key为文件名，value为inode编号\n这便是为何一个目录中不能出现同名文件，这是一个不支持键值冗余的map(cpp-stl)\n目录权限既然目录也是文件，那么它就也有自己的文件权限\n\nhttps://blog.csdn.net/muxuen/article/details/125776348\n\n在我之前关于linux文件权限的讲解中，就提到了和目录有关的权限问题\n\n进入目录需要x权限\n创建文件需要w权限\n查看文件名需要r权限\n\n了解文件系统了之后，现在我们知道为什么目录的操作需要这些权限了。在目录下创建文件，本质就是在修改目录所对应的文件内容！\n\n5.5 创建&#x2F;删除文件当我们创建一个文件的时候，文件系统做了什么捏？\n\n创建一个新的文件结构体，和对应的inode编号\n根据目录的inode，找到该目录的data blocks\n将文件名和inode编号的对应关系写入到目录的数据块中\n\n当我们删除一个文件的时候：\n\n操作系统只需要删除当前目录下inode和文件名的对应关系\n同时在inode bitmap中将对应的inode置为0（代表没有使用）\n\n这样就算是删除该文件了！好比我们操作线性表进行尾删操作，只是对size-1，并没有真的把该位置的数据删除\n\n这便能解释为什么复制粘贴一个文件的速度远慢于删除文件的速度\n因为没有将文件的inode和data block清空，所以给我们恢复数据带来了可能。只要该文件之前使用的inode/data block并没有被复写，我们就有可能还原出该文件的数据！\n\n\n6.软硬链接在最初学习linux命令行的时候，就已经学习过了ln创建文件链接的操作\n\n 这部分我没有写博客，因为网上的教程实在是太多啦\n\n但是当时并不知道软链接/硬链接到底有什么区别，学习了文件系统之后，回头再来看看\n\n6.1 查看文件硬链接个数ls -li\n\n当我们执行上面这个命令的时候，可以看到每一个文件的完整属性\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -liatotal 161453831 drwxrwxr-x  2 muxue muxue 4096 Nov  2 09:58 .1443736 drwxrwxr-x 16 muxue muxue 4096 Nov  2 09:20 ..1453833 -rw-rw-r--  1 muxue muxue   81 Nov  2 09:58 makefile1453832 -rw-rw-r--  1 muxue muxue  437 Nov  2 09:35 test.cpp\n\n可之前一直没有去了解，这个第三列的2  16   1  1 到底是什么玩意呢？\n不卖关子，前面提到inode会保存文件的硬链接个数，第三列的数字，代表的便是该文件的硬链接个数！\n这里我们创建一个新的文件夹，和一个新的文件\n[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ mkdir test_r[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ touch test_f[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ls -litotal 121453833 -rw-rw-r-- 1 muxue muxue   81 Nov  2 09:58 makefile1453832 -rw-rw-r-- 1 muxue muxue  437 Nov  2 09:35 test.cpp1453836 -rw-rw-r-- 1 muxue muxue    0 Nov  2 16:07 test_f1449813 drwxrwxr-x 2 muxue muxue 4096 Nov  2 16:07 test_r[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ \n\n你会发现，文件夹默认的硬链接数是2，而文件默认的硬链接数是1\n为什么？当我们cd进入目录的时候，linux便会找到底层的inode，进入该inode所对应的文件中。\n如果想知道一个目录的目录名，我们必须要去该目录的上级找。\n为了方便查找当前目录以及其上级目录的inode，每一个目录下面，默认都会有..和.这两个目录文件！\n进入刚刚我们新创的文件夹看看，你会发现，.文件的inode就是该文件夹的inode！\n\n从这里便引出了软连接和硬链接的区别\n6.2 软硬链接区别这里我创建了一个新文件夹，在里面创建了一个test.c文件\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -litotal 41453842 -rw-rw-r-- 1 muxue muxue 78 Nov  2 16:13 test.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ \n\n同时对该文件夹创建一个硬链接和软连接\nln -s 源 目标 #创建软连接ln 源 目标 #创建硬链接\n\n康康结果👇\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ln -s test.c testSoft.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -litotal 41453842 -rw-rw-r-- 1 muxue muxue 78 Nov  2 16:13 test.c1453843 lrwxrwxrwx 1 muxue muxue  6 Nov  2 16:14 testSoft.c -&gt; test.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ln test.c testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -litotal 81453842 -rw-rw-r-- 2 muxue muxue 78 Nov  2 16:13 test.c1453842 -rw-rw-r-- 2 muxue muxue 78 Nov  2 16:13 testHard.c1453843 lrwxrwxrwx 1 muxue muxue  6 Nov  2 16:14 testSoft.c -&gt; test.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ \n\n你能看出区别吗？\n\n软链接的inode和源文件不相同，是一个全新的文件\n硬链接的inode和源文件相同！同时它们的硬链接数+1\n\n把这些文件都以指针理解，会更方便一些\n\n\n软连接的文件内容是所指向文件的路径\n硬链接只是在当前目录下新增文件名和inode编号的映射关系，并对inode中硬链接个数+1\n\n如果我们删除了test.c，软连接就会失效，但硬链接并不会，因为硬链接本身和test.c是一个东西！\n\n而inode中对硬链接的计数，就好比C++中智能指针的引用计数，如果该计数为0，就代表这个文件需要删除了！\n\n解答！知道了区别，我们也便知道为何一个新目录的默认硬链接个数是2了，其便是每一个目录都默认带的.文件，用于标识当前目录的inode；另外一个是该文件本身\n\n每一个新创建的文件，默认都和自己映射，所以硬链接个数为1\n\n同时，我们也可以通过..文件的硬链接个数，快速知道上级目录中有多少个文件夹（除去默认的.和..）\n上级目录内的文件夹个数 = 当前目录..文件的硬链接个数 - 2某一个目录内的文件夹个数 = 该目录..文件的硬链接个数 - 2\n\n6.3 unlink命令我们可以通过unlink命令来取消链接\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ lstestHard.c  testSoft.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ unlink testSoft.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -liatotal 121453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:39 .1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..1453842 -rw-rw-r--  1 muxue muxue   78 Nov  2 16:13 testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ \n\nunlink也可以用来删除正常文件，但一般只用它来删除链接文件！\n[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -liatotal 121453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:39 .1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..1453842 -rw-rw-r--  1 muxue muxue   78 Nov  2 16:13 testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ unlink testHard.c[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ ls -liatotal 81453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:40 .1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..\n\n\n结语linux文件系统的内容，到这里就over辣！后续如果有什么新增知识，会来这里添加！\n\n感谢你看到最后，如果有什么问题，可以在评论区提出哦\n","categories":["玩上Linux"],"tags":["Linux","文件"]},{"title":"【Linux】进程通信 | 共享内存 | 信号量","url":"/2022/11/13/code/note_Linux/17%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98_%E4%BF%A1%E5%8F%B7%E9%87%8F/","content":"上篇Linux的博客是有关管道的，今日就让我们继续康康进程间通信的另外一种方法：共享内存\n\n\n完整代码详见我的gitee仓库 👇\n\nhttps://gitee.com/ewait/raspberry-practice/tree/master/code/22-11-12_systemV\n\n[TOC]\n1.啥是共享内存？进程间通信的基本方式，就是让两个进程看到同一份资源。\n共享内存的方式，通过系统接口开辟一段内存，再让多个进程去访问这块内存，就能同时看到一份资源。\n\n这里贴出之前动态库博客中的图，共享内存的方式和该图展示的方式类似。进程需要调用系统接口，将已经开辟好的共享内存映射到自己的页表中，以实现访问。\n这里就出现了一个问题：\n\n操作系统的接口怎么知道进程要的是那一块共享内存？即共享内存是怎么标识的？\n\n要知道，之前我们打开文件、开辟管道等等，都是具有唯一的文件路径来标识文件的。如果按以前的想法：打开文件-&gt;系统返回文件的文件描述符，共享内存则应该是开辟共享内存-&gt;系统返回共享内存的编号\n\n这就出现了问题！\n\n假设进程A开辟了一段共享内存，系统返回了编号123，那么进程A要怎么让其他想使用这块共享内存进行通信的进程，知道它开辟的共享内存编号是123呢？总不能开个管道告诉它吧？那岂不是多此一举😂\n\n所以，共享内存的编号其实和命名管道一样，是由用户手动在代码中指定的。只要进程使用这个编号去获取共享内存，他们就能获取到同一份！\n\n2.相关接口说完了基本概念，现在让我们来康康它的使用\n2.1 ftokftok - convert a pathname and a project identifier to a System V IPC key\n#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;key_t ftok(const char *pathname, int proj_id);\n\n前面提到了，共享内存的key是我们自己指定的。Linux系统给定了ftok接口，将用户提供的pathname工作路径，以及proj_id项目编号转换为一个共享内存的key（其实就是int类型）\n\n只要我们的工作路径和项目编号传的是一样的，那么它返回的key就是一样的！\n2.2 shmgetshmget - allocates a System V shared memory segment\n#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg);\n参数分别为key值，共享内存的大小，以及创建共享内存的方式。\nkey值需要通过 ftok函数获取；\n其中共享内存的大小最好设置为4kb的整数倍，因为操作系统IO的基本单位是4KB。如果你申请了不是4的整数倍的字节，比如15个字节，其还是会申请16个字节(4个页)交给你，而其中有1kb的内存你是无法使用的，即造成了内存浪费😥\n创建共享内存的shmflg:\n\nIPC_CREAT：创建共享内存。如果存在则获取，如果不存在则创建后获取\nIPC_EXCL：必须配合IPC_CREAT使用，如果不存在指定的共享内存，就进行创建；如果该共享内存存在，则出错返回（即保证获取到的共享内存一定是当前进程创建的，是一个新的共享内存）\n\n返回值是一个共享内存的标识符\nRETURN VALUE       On success, a valid shared memory identifier is returned.  On errir, -1 is returned, and errno is set to indicate the error.\n\n这些工作都是操作系统做的。其内核中有专门的管理单元来判断一个共享内存是否存在，以及何时被创建、被使用、被什么进程绑定等等…\n命令行键入man shmctl，可以看到下面的内核结构\nstruct shmid_ds &#123;    struct ipc_perm shm_perm;    /* Ownership and permissions */    size_t          shm_segsz;   /* Size of segment (bytes) */    time_t          shm_atime;   /* Last attach time */    time_t          shm_dtime;   /* Last detach time */    time_t          shm_ctime;   /* Last change time */    pid_t           shm_cpid;    /* PID of creator */    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */    shmatt_t        shm_nattch;  /* No. of current attaches */    ...&#125;;struct ipc_perm &#123;    key_t          __key;    /* Key supplied to shmget(2) */    uid_t          uid;      /* Effective UID of owner */    gid_t          gid;      /* Effective GID of owner */    uid_t          cuid;     /* Effective UID of creator */    gid_t          cgid;     /* Effective GID of creator */    unsigned short mode;     /* Permissions + SHM_DEST and                                           SHM_LOCKED flags */    unsigned short __seq;    /* Sequence number */&#125;;\n\n共享内存要被管理，其内核结构中一定有一个唯一的key值来标识该共享内存，即和文件的inode一样\nkey_t     __key; //共享内存的唯一标识符，由用户在shmget中提供\n\n关于key为何要让用户提供，已经在上面做出过解释👉 回顾一下\n\n2.3 shmat&#x2F;shmdtat其实是attach绑定的缩写，这个接口的作用是将一个共享内存和我们当前的进程绑定。\n其实就是将这个共享内存映射到进程的页表中（堆栈之间）\nshmat, shmdt - System V shared memory operations\n#include &lt;sys/types.h&gt;#include &lt;sys/shm.h&gt;void *shmat(int shmid, const void *shmaddr, int shmflg);int shmdt(const void *shmaddr);\n\n一共有两个函数，分别为at和dt，用于绑定&#x2F;解绑共享内存\nshmat的三个参数如下\n\nshmid：为shmget的返回值\nshmaddr：指定共享内存连接到当前进程中的地址位置。通常为空，表示让系统来选择共享内存的地址。\nshmflg：如果指定了SHM_RDONLY位，则以只读方式连接此段；否则以读写的方式连接此段；通常设置为0\n\n调用成功的时候，返回指向共享内存第一个字节的指针；出错返回-1\n\nshmdt的参数为shmat正确调用时的返回值\n\n以下是man手册中对这两个函数返回值的描述👇\nRETURN VALUE       On success shmat() returns the address of the attached shared memory segment; on error (void *) -1 is returned, and errno is set  to       indicate the cause of the error.       On success shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.\n\n2.4 shmctl这个函数可以用于操作我们的共享内存\n#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmctl(int shmid, int cmd, struct shmid_ds *buf);\n\n其中cmd的参数有下面几种\n\nIPC_RMID  删除该共享内存\n\nIPC_STAT  把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值\n\nIPC_SET 如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值\n\n\n最后一个buf参数是一个指向shmid_ds结构的指针，一般设为NULL\nThe buf argument is a pointer to a shmid_ds structure\n\nshmid_ds的基本结构如下\nstruct shmid_ds&#123;    uid_t shm_perm.uid;    uid_t shm_perm.gid;    mode_t shm_perm.mode;&#125;;\n\n以删除为例，其操作如下\nshmctl(shmid, IPC_RMID, NULL);//删除shmid的共享内存\n\n2.5 ipcs命令先来康康几个ipcs命令的选项，其中我们要用到的是-m查看共享内存\nipcs -c #查看消息队列/共享内存/信号量ipcs -s #单独查看信号量ipcs -q #单独查看消息队列ipcs -m #单独查看共享内存\n\n执行了之后，会列出当前操作系统中开辟的共享内存，以及它们的基本信息\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m ------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 1          muxue      0          1024       0    \n\n这里的key和我们使用ftok获取到的key值是一样的，只不过我们打印的时候是十进制，操作系统列出来的为十六进制\n我们可以使用ipcrm -m 共享内存的shmid来删除共享内存\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 1          muxue      0          1024       0                       [muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcrm -m 1[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       \n\n可以看到我们自己创建的共享内存已经被删除了\n\n消息队列&#x2F;信号量的接口消息队列和信号量的接口和共享内存很相似\n消息队列用的不多，信号量的难度很高！😂\n//消息队列相关接口msgget //获取msgctl //操作msgsnd //发送信息msgrcv //信号量semgetsemctlsemop\n\nipcrm这个命令可以用与删除ipc资源，包括共享内存\nipcrm -m shmid #删除共享内存\n\n但是，当我们尝试用该命令删除一个正在被使用的共享内存时，它并不会被立即删除（立即删除会影响进程运行）\n此时执行删除，在共享内存的status列会出现dest；观察结果，当进程结束的时候，这个共享内存会被直接删除（进程内部并没有调用shmctl接口）\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 21         muxue      666        1024       2                       [muxue@bt-7274:~/git]$ ipcrm -m 21[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x00000000 21         muxue      666        1024       2          dest         [muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                 \n\n相比之下，如果不执行ipcrm命令+进程内部不调用shmctl接口，这个共享内存就会一直存在\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 22         muxue      666        1024       0                       \n\n结论：使用ipcrm -m命令删除共享内存之后，其共享内存不一定会立即释放。如果有进程关联了该共享内存，则会在进程去关联之后释放\n3.使用3.1 创建并获取//头文件实在太多，为了博客篇幅，这里省略了#define NUM 1024#define PROJ_ID 0x20#define PATH_NAME &quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;key_t CreateKey()&#123;    key_t key = ftok(PATH_NAME, PROJ_ID);    if(key &lt; 0)    &#123;        cerr &lt;&lt;&quot;ftok: &quot;&lt;&lt; strerror(errno) &lt;&lt; endl;        exit(1);//key获取错误直接退出程序    &#125;    return key;&#125;int main()&#123;    key_t key = CreateKey();    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    return 0;&#125;\n\nFile exists这里会发现，第一次运行代码的时候，程序成功获取了共享内存；但是第二次运行的时候，却报错说File exists(文件存在)\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./testshmget: 1[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./testshmget err: File exists\n\n这是因为共享内存的声明周期是随内核的。即只要这个共享内存不被删除，他就会一直存在，直到内核因为某种原因释放掉它，亦或者操作系统关机\n通过上面提到的ipcrm -m shmid 命令删除共享内存，才能重新运行代码获取新的共享内存\n\n为了避免这个问题，应该在进程结束后使用shmctl接口删除共享内存\n\n[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./testshmget success: 2[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 2          muxue      0          1024       0                       \n\n设置权限值默认情况下，我们创建的共享内存的perms是0，代表没有用户能访问这个共享内存。所以在创建的时候，我们需要在flag里面直接或上这个共享内存的权限值       \n代码如下👇\nint main()&#123;    key_t key = CreateKey();    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | 0666);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    sleep(5);    shmctl(id,IPC_RMID,nullptr);    return 0;&#125;\n\n这时候创建的共享内存就有正确的权限值了\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 4          muxue      666        1024       0    \n\n3.2 挂接&#x2F;取消挂接//关联共享内存char *str = (char*)shmat(id, nullptr, 0);\n\n因为shmat函数的返回值是一个void*指针，我们可以以使用malloc一样的方式使来挂接共享内存。随后对这个内存的操作就是正常的指针操作了！\n同样的，另外一个进程也需要用同样的方式挂接共享内存，才能读取到相同的数据\n[muxue@bt-7274:~/git]$ ipcs -m------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      0x00005feb 0          root       666        12000      1                       0x20011ac8 4          muxue      666        1024       1   \n\n挂接成功后，可以发现nattch的值从0变为1\n取消&#x2F;删除取消挂接的方式很简单，直接把shmat的返回值传入即可\nshmdt(str);//取消挂接\n\n如果是服务端，则还需要在取消挂接之后，删除共享内存。避免下次程序运行的时候，无法通过key获取到新的共享内存\nshmctl(id,IPC_RMID,nullptr);//删除共享内存\n\n3.3 写入内容因为共享内存本质就是一个内存，其和malloc出来的内存都是一样的，直接使用即可\n这里还是用一个服务端和一个客户端来进行演示\n//server.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    //获取key值    key_t key = CreateKey();    //创建共享内存    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | 0666);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    sleep(2);    //关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[server] shmat success\\n&quot;);    //读取数据，sleep(1)    int i=0;    while(i&lt;=40)    &#123;        printf(&quot;[%03d] %s\\n&quot;,i,str);        i++;        sleep(1);    &#125;    //去关联    shmdt(str);//shmat的返回值    printf(&quot;[server] shmdt(str)\\n&quot;);    //删除共享内存    shmctl(id,IPC_RMID,nullptr);    printf(&quot;[server] exit\\n&quot;);    return 0;&#125;//client.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    //获取key值    key_t key = CreateKey();    //获取共享内存    int id = shmget(key, NUM, IPC_CREAT);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    sleep(2);    //关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[client] shmat success\\n&quot;);    //写入数据    int i=0;    while(i&lt;26)    &#123;        char base = &#x27;A&#x27;;        str[i] = base+i;        str[i+1] = &#x27;\\0&#x27;;        printf(&quot;write times: %02d\\n&quot;,i);        i++;        sleep(1);    &#125;    //去关联    shmdt(str);//shmat的返回值    printf(&quot;[client] shmdt &amp; exit\\n&quot;);    return 0;&#125;\n\n跑起来之后，客户端向共享内存中写入数据（注意控制\\0）服务端进行读取。这便实现了我们进程之间的通信\n\n不过我们发现，客户端已经停止写入之后，服务端还是在不停的读取。如果我们不控制while循环的话，其会一直这么读取下去\n\n这便牵扯出共享内存的一个特性了\n共享内存没有访问控制在管道的博客中提到，管道是有访问控制的进程通信方式，写端没有写入数据的时候，读端会在read中进行等待\n而共享内存因为我们是直接像操作一个malloc出来的空间一样访问，没有使用任何系统接口（相比之下管道需要使用read/write）所以操作系统没有办法帮我们进行访问控制\n也正是因为没有等待，共享内存是进程中通信中最快的一种方式\n通过管道进行共享内存的控制既然共享内存没有访问控制，那么我们可以利用管道来让控制共享内存的读写\n\n写端写完后，将完成信号写入管道，由读端读取\n读端从管道中获取到信号后，访问共享内存读出内容\n如果写端没有写好，读端就会在管道read内部等待\n\n你可能会说，那为何不直接用管道通信呢？\n\n管道仅作访问控制，只需要一个int乃至一个char类型即可；\n相比直接管道通信，内存的方式更好控制（毕竟使用内存的方式和使用指针一样，管道还需要文件操作）\n读取很长一串数据的时候，共享内存的速度优势能体现出来\n\n以下是完整代码👇\n//mykey.hpp#pragma once#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;cassert&gt;using namespace std;#define NUM 1024#define PROJ_ID 0x20#define PATH_NAME &quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;#define FIFO_FILE &quot;sc.pipe&quot;key_t CreateKey()&#123;    key_t key = ftok(PATH_NAME, PROJ_ID);    if(key &lt; 0)    &#123;        cerr &lt;&lt;&quot;ftok: &quot;&lt;&lt; strerror(errno) &lt;&lt; endl;        exit(1);//key获取错误直接退出程序    &#125;    return key;&#125;void CreateFifo()&#123;    umask(0);    if(mkfifo(FIFO_FILE, 0666) &lt; 0)    &#123;        cerr &lt;&lt; &quot;fifo: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(2);    &#125;&#125;//打开管道文件int Open(int flags)&#123;    return open(FIFO_FILE, flags);&#125;//让读端通过管道等待ssize_t Wait(int fd)&#123;    char val = 0;    //如果写端没有写入，其就会在read中等待    ssize_t s = read(fd, &amp;val, sizeof(val));    return s;&#125;//发送完成信息int Signal(int fd)&#123;    char sig = &#x27;g&#x27;;    write(fd, &amp;sig, sizeof(sig));&#125;//server.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    //创建管道    CreateFifo();    //获取key值    key_t key = CreateKey();    //创建共享内存    int id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | 0666);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    //获取管道    int fd = Open(O_RDONLY);    cout &lt;&lt; &quot;open fifo success: &quot; &lt;&lt; fd &lt;&lt; endl;    sleep(2);    //关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[server] shmat success\\n&quot;);    //读取数据    int i=0;    while(i&lt;=40)    &#123;        ssize_t ret = Wait(fd);//通过管道等待        if(ret!=0)        &#123;            printf(&quot;[%03d] %s\\n&quot;,i,str);            i++;            sleep(1);        &#125;        else        &#123;            cout&lt;&lt;&quot;[server] wait finish, break&quot; &lt;&lt; endl;            break;        &#125;    &#125;    //去关联    shmdt(str);//shmat的返回值    printf(&quot;[server] shmdt(str)\\n&quot;);    //删除共享内存    shmctl(id,IPC_RMID,nullptr);    close(fd);    unlink(FIFO_FILE);    printf(&quot;[server] exit\\n&quot;);    return 0;&#125;//client.cpp#include &quot;Mykey.hpp&quot;int main()&#123;    //获取key值    key_t key = CreateKey();    //获取共享内存    int id = shmget(key, NUM, IPC_CREAT);    if(id&lt;0)    &#123;        cerr&lt;&lt; &quot;shmget err: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;         return 1;    &#125;    cout &lt;&lt; &quot;shmget success: &quot; &lt;&lt; id &lt;&lt; endl;    //获取管道    int fd = Open(O_WRONLY);    cout &lt;&lt; &quot;open fifo success: &quot; &lt;&lt; fd &lt;&lt; endl;    sleep(2);    //关联共享内存    char *str = (char*)shmat(id, nullptr, 0);    printf(&quot;[client] shmat success\\n&quot;);    //写入数据    int i=0;    while(i&lt;26)    &#123;        char base = &#x27;A&#x27;;        str[i] = base+i;        str[i+1] = &#x27;\\0&#x27;;        printf(&quot;write times: %02d\\n&quot;,i);        i++;        Signal(fd);        sleep(1);    &#125;    //去关联    shmdt(str);//shmat的返回值    printf(&quot;[client] shmdt &amp; exit\\n&quot;);    close(fd);    printf(&quot;[client] close fifo\\n&quot;);    return 0;&#125;\n\n运行结果管道控制了之后，当客户端退出的时候，管道也不会继续读取，而是在read内等待\n\n如果客户端最后关闭了管道的写段，服务器端就会直接退出。这样我们就实现了通过管道控制共享内存的读写👍\n\n\n4.相关概念4.0 临界资源能被多个进程看到的资源，被称为临界资源\n如果不对临界资源进行访问控制，进程对该资源的访问就是乱序的（比如父子进程向显示器打印内容）可能会因为数据交叉导致乱码、数据不可用等情况\n以此可见，显示器、管道、共享内存都是临界资源\n\n管道是有访问控制的临界资源\n\n进程访问临界资源的代码，称为临界区\n\n一个进程中，并不是所有的代码都在访问临界资源。如管道中，其实只有read/write接口在访问临界资源\n\n互斥：任何时刻，只允许一个进程访问临界资源\n原子性：一件事情只有做完/没做两种状态，没有中间状态\n下面对信号量的概念进行讲解~只用基本理解即可\n4.1 信号量信号量是对临界资源的控制方式之一，其本质是一个计数器\n\n信号量保证不会有多余的进程连接到这份临界资源\n还需要保证每一个进程的能够访问到临界资源的不同位置（根据上层业务决定）\n\n信号量根据情况的不同分为两种：\n\n二元信号量（互斥状态，当进程使用的时候为1，没有进程使用的时候为0）\n多元信号量（常规）\n\n如果一个进程想访问由信号量控制的临界资源，必须先申请信号量。申请成功，就一定能访问到这个临界资源中的一部分（或者全部）\n原子性的说明先来想想，我们对一个变量+1/-1需要做什么工作：\n\n将这个变量从内存中拿到CPU的寄存器中\n在寄存器中完成加减操作\n放回内存\n\n这其中是有很多个中间状态的，设该变量初始值为100\n\n假设一个进程A拿走了这个变量，放入CPU的寄存器\n另外一个进程B也来拿走了这个变量\n此时A和B拿到的都是100\nA对该变量进行了循环--操作，最终该变量变成了50，将其放回内存\nB对该变量-1，将其放回内存\n最终导致A对变量的操作被B覆盖，出现了变量不统一的情况\n\n而我们的信号量为了保证能够正确的控制进程的访问，其就必须维护自身的原子性！不能有中间状态\n\n说人话就是，如果进程A在访问信号量，进程B来了，信号量应该拒绝B的访问，直到A访问结束。不能让B中途插入访问，从而导致可能的数据不统一\n\n共享内存同样可以通过信号量进行访问控制\n\n改变信号量的值int semop(int semid, struct sembuf *sops, size_t nops);\n\n功能： 操作信号量，P V 操作\n参数： \n\nsemid 为信号量集的标识符；\nsops 指向进行操作的结构体数组的首地址；\nnsops 指出将要进行操作的信号的个数；\n\n返回值： 成功返回0，出错返回-1\nRETURN VALUE       If successful semop() and semtimedop() return 0; otherwise they return -1 with errno indicating the error.\n\n4.2 扩展 mmap\n这部分仅供参考，可能有错误😥部分资料参考\n\n 前面贴出过IPC资源的内核结构，它们都有一个共同的特点：第一个成员都相同\nstruct shmid_ds &#123;    struct ipc_perm shm_perm;    /* Ownership and permissions */    size_t          shm_segsz;   /* Size of segment (bytes) */    time_t          shm_atime;   /* Last attach time */    time_t          shm_dtime;   /* Last detach time */    time_t          shm_ctime;   /* Last change time */    pid_t           shm_cpid;    /* PID of creator */    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */    shmatt_t        shm_nattch;  /* No. of current attaches */    ...&#125;;struct semid_ds &#123;    struct ipc_perm sem_perm;  /* Ownership and permissions */    time_t          sem_otime; /* Last semop time */    time_t          sem_ctime; /* Last change time */    unsigned long   sem_nsems; /* No. of semaphores in set */&#125;;struct msqid_ds &#123;    struct ipc_perm msg_perm;     /* Ownership and permissions */    time_t          msg_stime;    /* Time of last msgsnd(2) */    time_t          msg_rtime;    /* Time of last msgrcv(2) */    time_t          msg_ctime;    /* Time of last change */    unsigned long   __msg_cbytes; /* Current number of bytes in                                                queue (nonstandard) */    msgqnum_t       msg_qnum;     /* Current number of messages                                                in queue */    msglen_t        msg_qbytes;   /* Maximum number of bytes                                                allowed in queue */    pid_t           msg_lspid;    /* PID of last msgsnd(2) */    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */&#125;;\n\n它们的第一个成员都是一个struct ipc_perm，其中包含了一个信号量的基本信息\nstruct ipc_perm &#123;    key_t          __key;    /* Key supplied to shmget(2) */    uid_t          uid;      /* Effective UID of owner */    gid_t          gid;      /* Effective GID of owner */    uid_t          cuid;     /* Effective UID of creator */    gid_t          cgid;     /* Effective GID of creator */    unsigned short mode;     /* Permissions + SHM_DEST and                                           SHM_LOCKED flags */    unsigned short __seq;    /* Sequence number */&#125;;\n\n而内核中对IPC资源的管理，是通过一个数组进行的。我们所获取的shmid，和文件描述符一样，都是一个数组的下标\n其中我在测试的时候，便发现了一点：我们每一次获取的新的共享内存，它的编号都会+1，而不像文件描述符一样，提供第一个没有被使用的下标\nstruct ipc_ids &#123;    int in_use;//说明已分配的资源个数    int max_id;//在使用的最大的位置索引    unsigned short seq;//下一个分配的位置序列号    unsigned short seq_max;//最大位置使用序列    struct semaphore sem; //保护 ipc_ids的信号量    struct ipc_id_ary nullentry;//如果IPC资源无法初始化，则entries字段指向伪数据结构    struct ipc_id_ary* entries;//指向资源ipc_id_ary数据结构的指针&#125;;\n\n在内核中，struct ipc_id_ary* entries是一个指向所有ipc_perm的指针数组。其能够通过该数组找到我们对于id（下标）的资源，对其进行访问\nstruct ipc_id_ary&#123;        int size;        struct kern_ipc_perm *p[0];//指针数组&#125;;\n\n\n那你可能想问了，这里只是第一个元素啊？那如果我想访问shmid_ds结构的其他成员，岂不是没有办法访问了？\n要是这么想，就还是太年轻了😂\n(strcut shmid_ds*)\n\n我们只需要对这个指针进行强转，就能直接访问其他成员！\n这是因为：C语言中，结构体第一个元素的地址，和结构体整体的地址是一样的！\n指针的类型会限制这个指针访问元素的能力，只要我们进行强转，其就能直接访问父结构体的其他成员！\n\n这是一种切片的思想\n\n用这种办法，可以用统一的规则在内核中管理不同的IPC资源，没有必要再为每一个IPC资源建立一个单独的数组来管理。\n\n不得不说，linus大佬是真的牛逼！\n\n结语关于共享内存的操作到这里就OVER了！\n最后还了解了一些内核设计上的小妙招，不得不说，真的牛批~\n如果本文有什么问题，欢迎在评论区提出\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】进程通信 | 信号","url":"/2022/11/20/code/note_Linux/18%E4%BF%A1%E5%8F%B7/","content":"本篇博客让我们一起来康康信号部分的内容\n\n系统为CentOS7.6，完整代码见 Gitee\n\n\n\n[TOC]\n1.什么是信号在进程运行过程中，会出现各种各样的情况。操作系统需要用一套机制，来管理进程的事件\n\n进程退出\n进程停止\n进程恢复运行\n……\n\n同时，这套管理机制是异步的，属于一种软（件）中断\n\n和硬件中断打断处理器类似，软件中断打断进程的执，让其执行对应代码进行响应\n\n1.1 何为异步?\n以网购物品为例：当商品寄到自提点的时候，会给你发送一条取件的短信（信号）。此时我正在打游戏，没时间去处理这个快递（即取快递的行为并不是必须立马执行）\n但这个时候，我已经知道有一个快递到了（知道自己获取到了一个信号）本质上就是知道了一会要去取快递（一会要处理信号）\n当游戏一把打完了，我们就去取快递了（处理信号）\n\n这就是一种异步的过程。因为你不知道你的快递什么时候会到站点，进程也不知道自己什么时候会收到一个信号\n1.2 信号的种类使用kill -l命令，我们可以看到目前linux系统下64种不同的类型。\n其中前32为标准（Standard）信号，后32为实时（Real-time）信号；本篇博客只关注标准信号\n\n这些信号，都是linux系统中预定义的宏\n\n其中最常用的便是9号信号，来中断进程。平时我们最常用的CTRL+C，也是通过向进程发2号信号让进程退出的\n[muxue@bt-7274:~/git]$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX\n\n在include/linux/signal.h中，我们可以看到对信号的解释，以及其默认处理方法 default action\n/* * In POSIX a signal is sent either to a specific thread (Linux task) * or to the process as a whole (Linux thread group).  How the signal * is sent determines whether it&#x27;s to one thread or the whole group, * which determines which signal mask(s) are involved in blocking it * from being delivered until later.  When the signal is delivered, * either it&#x27;s caught or ignored by a user handler or it has a default * effect that applies to the whole thread group (POSIX process). * * The possible effects an unblocked signal set to SIG_DFL can have are: *   ignore\t- Nothing Happens *   terminate\t- kill the process, i.e. all threads in the group, * \t\t  similar to exit_group.  The group leader (only) reports *\t\t  WIFSIGNALED status to its parent. *   coredump\t- write a core dump file describing all threads using *\t\t  the same mm and then kill all those threads *   stop \t- stop all the threads in the group, i.e. TASK_STOPPED state * * SIGKILL and SIGSTOP cannot be caught, blocked, or ignored. * Other signals when not blocked and set to SIG_DFL behaves as follows. * The job control signals also have other special effects. * *\t+--------------------+------------------+ *\t|  POSIX signal      |  default action  | *\t+--------------------+------------------+ *\t|  SIGHUP            |  terminate\t| *\t|  SIGINT            |\tterminate\t| *\t|  SIGQUIT           |\tcoredump \t| *\t|  SIGILL            |\tcoredump \t| *\t|  SIGTRAP           |\tcoredump \t| *\t|  SIGABRT/SIGIOT    |\tcoredump \t| *\t|  SIGBUS            |\tcoredump \t| *\t|  SIGFPE            |\tcoredump \t| *\t|  SIGKILL           |\tterminate(+)\t| *\t|  SIGUSR1           |\tterminate\t| *\t|  SIGSEGV           |\tcoredump \t| *\t|  SIGUSR2           |\tterminate\t| *\t|  SIGPIPE           |\tterminate\t| *\t|  SIGALRM           |\tterminate\t| *\t|  SIGTERM           |\tterminate\t| *\t|  SIGCHLD           |\tignore   \t| *\t|  SIGCONT           |\tignore(*)\t| *\t|  SIGSTOP           |\tstop(*)(+)  \t| *\t|  SIGTSTP           |\tstop(*)  \t| *\t|  SIGTTIN           |\tstop(*)  \t| *\t|  SIGTTOU           |\tstop(*)  \t| *\t|  SIGURG            |\tignore   \t| *\t|  SIGXCPU           |\tcoredump \t| *\t|  SIGXFSZ           |\tcoredump \t| *\t|  SIGVTALRM         |\tterminate\t| *\t|  SIGPROF           |\tterminate\t| *\t|  SIGPOLL/SIGIO     |\tterminate\t| *\t|  SIGSYS/SIGUNUSED  |\tcoredump \t| *\t|  SIGSTKFLT         |\tterminate\t| *\t|  SIGWINCH          |\tignore   \t| *\t|  SIGPWR            |\tterminate\t| *\t|  SIGRTMIN-SIGRTMAX |\tterminate       | *\t+--------------------+------------------+ *\t|  non-POSIX signal  |  default action  | *\t+--------------------+------------------+ *\t|  SIGEMT            |  coredump\t| *\t+--------------------+------------------+ * * (+) For SIGKILL and SIGSTOP the action is &quot;always&quot;, not just &quot;default&quot;. * (*) Special job control effects: * When SIGCONT is sent, it resumes the process (all threads in the group) * from TASK_STOPPED state and also clears any pending/queued stop signals * (any of those marked with &quot;stop(*)&quot;).  This happens regardless of blocking, * catching, or ignoring SIGCONT.  When any stop signal is sent, it clears * any pending/queued SIGCONT signals; this happens regardless of blocking, * catching, or ignored the stop signal, though (except for SIGSTOP) the * default action of stopping the process may happen later or never. */\n\n这也意味着：即便没有接收到信号，进程也具备有识别和处理这个信号的能力！因为在系统中，已经给每一个进程和信号指定了默认动作！\n1.3 信号产生有很多情况会产生信号\n\n系统接口（kill命令）\n键盘产生（CTRL+R  CTRL+\\)\n软件条件（进程停止，进程运行完退出）\n硬件异常（比如除0错误）\n\n1.4 信号动作既然有默认动作，那肯定也有非默认的了。实际上，一个进程对信号的处理分为三种不同的方式\n\n默认动作\n自定义动作\n忽略\n\n前面提到，一个进程并不一定需要立刻处理一个信号。那么它一定需要有一个办法来记住自己收到的信号。\n而存储信号，是由进程的PCB来完成的！\n细心的你可能会发现，进程中的信号一共是64个，刚好是8个字节！我们可以通过位图结构，用两个int类型来存放一个进程收到的各种信号。\n\n在系统内核中，分别有三个表，用来存放进程的信号。而这些信号在位图中的位置，就是在handler方法集中处理动作的下标\nblock - 1表示该进程屏蔽这个信号pending - 表示进程收到了什么信号，1代表收到且未处理handler - 每一个信号所对应的处理方法，默认/忽略/自定义\n\n这一切都是处于进程PCB中的，只有操作系统能为我们管理。所以操作系统提供了相关的接口，方便我们对进程信号进行自定义设置。\npending表中的信号只能保存一个，如果一个信号尚未处理，该位图为1；另外一个相同信号到来的时候，会被直接丢弃掉。（pending表只能记住一个信号）\nhandler表中的两个宏如下：\n\nSIG_DFL 默认方法\nSIG_IGN 忽略\n忽略是信号处理的一种方式，我们能正常收到这个信号，处理方法是不管他\n\n\n2.系统接口2.1 signal#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler);\n\n这个函数可以用于设置某个信号的处理方法。如果设置成功，则返回这个信号的旧处理动作\nRETURN VALUE   signal()  returns the previous value of the signal handler, or SIG_ERR on error. In the event of an error, errno is set to indicate the cause.\n\n比如我们将键盘退出的2号自定义一个回调函数，那么就不能用ctrl+c终止这个进程\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;int main()&#123;    //将二号信号设置一个回调，其余信号不做处理    signal(2, handler);    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);    while (true)    &#123;        cout &lt;&lt; &quot;进程正在运行: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    return 0;&#125;\n\n2.1.1 前台进程和后台进程这里对ctrl+c的作用进一步描述，它只能用来中断一个前台进程\n./test #我们直接运行一个进程，就是前台进程\n\n之前这种直接运行进程，在bash上打印内容的方式，都是一个前台进程，可以用ctrl+c终止；我们可以在后面加上&amp;设置为一个后台进程\n\n&amp;只是临时在后台运行，bash关闭后会终止；如果想持久在后台运行，需要在命令最前面加上nohup\n\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./test &amp;[1] 8898[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898^C[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898^C[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898进程正在运行: 8898\n\n这时候这个进程会一直在当前bash的后台打印，期间我们可以执行其他的命令，但是它依旧会不停的打印。ctrl+c无法终止这个进程，因为它并没有在前台运行！\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ps jax | grep test22965  8898  8898 22965 pts/22   22965 S     1001   0:00 ./test\n\nps命令查看，可以看到其运行态为S；而前台进程，运行态为S+\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ps jax | grep test22965  9664  9664 22965 pts/22    9664 S+    1001   0:00 ./test\n\n不过，虽然我们不能用CTRL+C终止这个进程，但使用kill -2发送2号信号，是可以终止掉这个进程的（前提是没有自定义2号信号的方法）\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程信号已经设置完了进程正在运行: 10464进程正在运行: 10464进程正在运行: 10464进程正在运行: 10464进程正在运行: 10464[1]+  Interrupt               ./test[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ \n\n2.1.2 循环捕捉所有信号我们可以用一个for循环，捕捉所有的信号\n//.....//其余代码同上int main()&#123;    //对所有的进程信号都设置一个回调    for (int sig = 1; sig &lt;= 31; sig++)    &#123;        signal(sig, handler);    &#125;    //signal(2, handler);//将二号信号设置一个回调，其余信号不做处理    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);    while (true)    &#123;        cout &lt;&lt; &quot;进程正在运行: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    return 0;&#125;\n\n设置了之后，对应的信号都会调用我们自己写的函数。但有一个例外，那便是kill -9\n\n2.1.3 信号9&#x2F;19在LINUX下，9号信号是一个管理员信号，具有杀死进程的最高权限，不能被自定义捕捉！\n\n你想啊，要是linux不对9号进行限制，那我把所有信号都捕捉了，岂不是这个进行没有办法被外部中止了？小病毒啊！😂\n\n和9号信号一样不能被屏蔽的，还有19号信号SIGSTOP\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process running: 7779process running: 7779process running: 7779process running: 7779process running: 7779[1]+  Stopped                 ./tsig[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n而6号信号可以被捕捉，自定义捕捉方法执行后，进程依旧会退出。参考2.4 abort\n2.2 killkill不仅是一个系统命令，同时还有一个系统接口；\n\n一般这种情况，用man kill查看命令的文档，man 2 kill查看接口函数\n\n之前我以为它只是一个用来干掉进程的命令（毕竟kill就是这个意思）现在才知道原来它的作用是给进程发信号\n//kill - send signal to a process#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;int kill(pid_t pid, int sig);\n\n它的返回值很简单，如果成功发送信号，则返回0，否则返回-1并且更新errno\nRETURN VALUE       On success (at least one signal was sent), zero is returned.  On error, -1 is returned, and errno is set appropriately\n\n所以我们可以写一个简单的函数实现，来制作一个自己的kill命令\nvoid mykill(int argc,char *argv[])&#123;    if(argc != 3)    &#123;        cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; signo-id process-id&quot; &lt;&lt;endl;        exit(1);    &#125;    if(kill(static_cast&lt;pid_t&gt;(atoi(argv[2])), atoi(argv[1])) == -1)    &#123;        cerr &lt;&lt; &quot;kill: &quot; &lt;&lt; strerror(errno) &lt;&lt; endl;        exit(2);//出现错误    &#125;    exit(0);//正常执行&#125;//argc和argv是命令行参数//argc传入命令个数，包括./test//argv传入命令的字符串地址int main(int argc, char *argv[])&#123;    mykill(argc,argv);    return 0;&#125;\n\n成功发送了信号！\n\n如果我们使用错误的时候，则会发送提示信息👍\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./mkillUsage: ./mkill signo-id process-id\n\n2.2.1 killall这个接口可以通过进程名向所有这个名字的进程发信号\n[muxue@bt-7274:~/git]$ killall tsig\n\n通过测试可以发现，它发送的是第15号信号\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process running: 5846process running: 5846process 5846 get signal: 15process running: 5846process running: 5846\n\n\n2.3 raise这个系统接口的作用是给自己发信号\n#include &lt;signal.h&gt;int raise(int sig);\n\n返回0代表调用成功，非0代表失败\nRETURN VALUE       raise() returns 0 on success, and nonzero for failure.\n\n用下面的代码进行测试，进程会不断的给自己发送2号信号\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;void TestSignal()&#123;    signal(2, handler);//将二号信号设置一个回调，其余信号不做处理    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);&#125;int main(int argc, char *argv[])&#123;    TestSignal();//设置对进程信号的屏蔽    while(1)    &#123;        raise(2);        sleep(1);    &#125;        return 0;&#125;\n\n此时能看到每一秒会调用我们自己写的handler方法，打印收到2号信号\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process get signal: 2process get signal: 2process get signal: 2process get signal: 2process get signal: 2\n\n2.4 abort向自己发送6) SIGABRT信号\n#include &lt;stdlib.h&gt;void abort(void);\n\n还是2.3中的代码，将raise(2)修改为abort()，同时捕捉6号信号。\n此时能观察到我们自己写的handler方法的确被调用了，但是进程依旧终止了\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了process get signal: 6Aborted[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$\n\n这说明6号信号有一个特性：可以被捕捉执行自定义方法，但执行完毕之后需要退出！\n相比之下，9号信号是不能被捕捉\n\n2.5 alarm这个接口的作用是一个定时器，设定秒数，时间到了之后，会收到14) SIGALRM信号\n#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);\n\nRETURN VALUE    alarm()  returns  the number of seconds remaining until any previously scheduled alarm was due to be delivered, or zero if there was no previously scheduled alarm.\n\n用下面的代码进行测试\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;void TestSignal()&#123;    //对所有的进程信号都设置一个回调    for (int sig = 1; sig &lt;= 31; sig++)    &#123;        signal(sig, handler);    &#125;    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);&#125;int main(int argc, char *argv[])&#123;    TestSignal();//设置对进程信号的屏蔽    alarm(4);//4s后向自己发送14信号    cout &lt;&lt; &quot;set alarm, sleep&quot; &lt;&lt; endl;    sleep(8);    cout &lt;&lt; &quot;sleep finish&quot;&lt;&lt;endl;        return 0;&#125;\n\n可以看到在休眠期间，进程收到了14号信号。此时进程并没有退出，而是继续休眠\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了set alarm, sleepprocess get signal: 14sleep finish[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ \n\n如果我们不对14号信号自定义捕捉，则会直接退出进程\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigset alarm, sleepAlarm clock[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ \n\n另外需要注意的是，alarm信号本身不会让进程休眠。如果进程在alarm信号设定秒数之前结束，则什么事情都不会发生\n2.6 sigset_t信号集这是一个数据类型，其为block&#x2F;pending位图的存储结构，被称作信号集/信号屏蔽字\n虽然我们能直接使用这个类型， 但是对这个信号集中的位图操作必须要调用系统接口来完成\n#include &lt;signal.h&gt;int sigemptyset(sigset_t *set);//初始化位图(清空)int sigfillset(sigset_t *set);//全部置为1int sigaddset(sigset_t *set, int signum);//设置位图中某一位的数据int sigdelset(sigset_t *set, int signum);//删除位图中某一位的数据//判断某一位信号是否在该集合中int sigismember(const sigset_t *set, int signum);\n\n2.7 sigprocmask更改或则获取当前进程的信号屏蔽字\n#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n\n其中第一个参数为处理方法，分别有下面三种\n\nSIG_BLOCK 将set参数中包含的位数设置为屏蔽\nSIG_UNBLOCK 将set参数中包含的位数解除屏蔽\nSIG_SETMASK 将当前的信号屏蔽字设置为set（覆盖）\n\n第三个参数是一个输出型参数。如果传入了oldset，那么旧的信号屏蔽字会被放入oldset中\nSIG_BLOCK  The set of blocked signals is the union of the current set and the set argument.SIG_UNBLOCK  The signals in set are removed from the current set of blocked signals.  It is permissible to attempt  to  unblock  a  signal which is not blocked.SIG_SETMASK   The set of blocked signals is set to the argument set.   If oldset is non-NULL, the previous value of the signal mask is stored in oldset.RETURN VALUE       sigprocmask() returns 0 on success and -1 on error.  In the event of an error, errno is set to indicate the cause.\n\n如果用该接口接触了对某一个信号的阻塞，那么在该函数return前，至少其中一个消息被送达\n2.8 sigpending获取当前进程的pending信号集\n#include &lt;signal.h&gt;int sigpending(sigset_t *set);\n\n参数为一个输出型参数。正确获取返回0，否则-1\n这时候我们就可以写一个简单的函数来打印当前进程的信号集了\n//打印信号集的内容void showPending(sigset_t* pdg_ptr)&#123;    for(int i=1;i&lt;32;i++)    &#123;        if(sigismember(pdg_ptr,i))        &#123;            cout &lt;&lt; &quot;1&quot;;        &#125;        else        &#123;            cout &lt;&lt; &quot;0&quot;;        &#125;    &#125;    cout &lt;&lt; endl;&#125;int main()&#123;    sigset_t pdg;    while(1)    &#123;        sigemptyset(&amp;pdg);//初始化信号集        if(sigpending(&amp;pdg)==0)//获取        &#123;            showPending(pdg);//获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    return 0;&#125;\n\n运行之后可以看到，程序一直在打印当前进程的信号集\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigstart process: 30981000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n不过此时我们并没有对信号进行屏蔽，所以给这个进程发信号会被立即处理（递达）不能在pending表中观察到现象\n2.8.1 屏蔽2号信号此时尝试使用sigprocmask来屏蔽某一个信号，再来观察情况\nint main(int argc, char *argv[])&#123;    //block掉2号信号    sigset_t nsig,osig;    sigemptyset(&amp;nsig);    sigemptyset(&amp;osig);    sigaddset(&amp;nsig,2);//在nsig中设置2为1    sigprocmask(SIG_BLOCK,&amp;nsig,&amp;osig);//添加屏蔽    cout &lt;&lt; &quot;start process: &quot; &lt;&lt; getpid() &lt;&lt; endl;    sigset_t pdg;    while(1)    &#123;        sigemptyset(&amp;pdg);//初始化信号集        if(sigpending(&amp;pdg)==0)//获取        &#123;            showPending(&amp;pdg);//获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;        return 0;&#125;\n\n可以看到当我们键入CTRL+C的时候，2号信号被block了没有处理，pending表上的2号信号就会变为1，且多次CTRL+C不会有变化\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigstart process: 360800000000000000000000000000000000000000000000000000000000000000^C0100000000000000000000000000000010000000000000000000000000000001000000000000000000000000000000100000000000000000000000000000^C01000000000000000000000000000000100000000000000000000000000000\n\n2.8.2 屏蔽所有信号可以用一个循环设置所有的信号位，让当前进程屏蔽掉所有信号\nint main(int argc, char *argv[])&#123;    //block掉所有信号    sigset_t nsig,osig;    sigemptyset(&amp;nsig);    sigemptyset(&amp;osig);    for(int i=1;i&lt;32;i++)    &#123;        sigaddset(&amp;nsig,i);//在nsig中设置2为1    &#125;    sigprocmask(SIG_BLOCK,&amp;nsig,&amp;osig);//添加屏蔽    cout &lt;&lt; &quot;start process: &quot; &lt;&lt; getpid() &lt;&lt; endl;    sigset_t pdg;    while(1)    &#123;        sigemptyset(&amp;pdg);//初始化信号集        if(sigpending(&amp;pdg)==0)//获取        &#123;            showPending(&amp;pdg);//获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;        return 0;&#125;\n\n运行之后可以观察到，不管给这个进程发几号信号，都会被屏蔽显示在pending集中；9号信号依旧是老大哥，不受影响，依旧能干掉这个进程\n\n2.8.3 解除屏蔽如果在设置屏蔽之后，休眠15s（在此期间接收信号）再接触对信号的屏蔽\nint main(int argc, char *argv[])&#123;    //block掉所有信号    sigset_t nsig,osig;    sigemptyset(&amp;nsig);    sigemptyset(&amp;osig);    for(int i=1;i&lt;32;i++)    &#123;        sigaddset(&amp;nsig,i);//在nsig中设置2为1    &#125;    sigprocmask(SIG_BLOCK,&amp;nsig,&amp;osig);//添加屏蔽    TestSignal();//设置信号自定义处理    cout &lt;&lt; &quot;start process: &quot; &lt;&lt; getpid() &lt;&lt; endl;    sigset_t pdg;    int k=15;    while(k--)    &#123;        sigemptyset(&amp;pdg);//初始化信号集        if(sigpending(&amp;pdg)==0)//获取        &#123;            showPending(&amp;pdg);//获取成功，打印        &#125;        else        &#123;            cout &lt;&lt; getpid() &lt;&lt; &quot; get pending err&quot;&lt;&lt;endl;        &#125;        sleep(1);    &#125;    //利用osig恢复之前的block表    sigprocmask(SIG_SETMASK,&amp;osig,nullptr);    sigemptyset(&amp;pdg);//初始化信号集    if(sigpending(&amp;pdg)==0)//获取    &#123;        showPending(&amp;pdg);//获取成功，打印    &#125;    sleep(10);    cout &lt;&lt; &quot;process quit&quot;&lt;&lt;endl;    return 0;&#125;\n\n此时就能观察到，信号被立马处理，pending表变为全0\n\n2.9 sigaction#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *act,\t\t\tstruct sigaction *oldact);\n\n这个函数的参数和signal函数很相似，不过都变为了一个结构体。这个接口也可以用来处理实时信号（不在文本考虑范围内） \n\n第一个参数是需要处理信号的编号\n第二个参数是自定义的action\n第三个参数是输出型参数，可以获取到旧的处理方法\n\n设置成功后返回0，出错返回-1\n这个结构体的成员如下\nstruct sigaction &#123;    void     (*sa_handler)(int);//对信号的处理方法    void     (*sa_sigaction)(int, siginfo_t *, void *);//可忽略    sigset_t   sa_mask;//参考2.8中的处理方法    int        sa_flags;//设为0    void     (*sa_restorer)(void);//可忽略&#125;;\n\n2.9.1 基本使用#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;using namespace std;//打印收到的信号void handler(int signo)&#123;    cout &lt;&lt; &quot;process &quot; &lt;&lt; getpid() &lt;&lt; &quot; get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;int main(int argc, char *argv[])&#123;    struct sigaction nact,oact;    nact.sa_flags = 0;    nact.sa_handler = handler;    sigemptyset(&amp;nact.sa_mask);//初始化    sigaction(2,&amp;nact,&amp;oact);    while(1)    &#123;        cout &lt;&lt; &quot;process running: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(2);    &#125;    return 0;&#125;\n\n运行之后，我们自定义捕捉了2号信号，成功调用自己的handler方法！\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigprocess running: 15029process running: 15029^Cprocess 15029 get signal: 2process running: 15029process running: 15029^Cprocess 15029 get signal: 2process running: 15029process running: 15029process running: 15029^\\Quit[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ \n\n2.9.2 sa_mask这个成员是一个sigset_t类型，用于当处理一个信号的时候，连带屏蔽其他信号；\n\n当一个进程正在处理A信号的时候，操作系统会把A信号自动添加入Block表，屏蔽该信号（不允许同时处理两个A信号，避免信号A的递归式处理）\n\n如果你想在处理2号信号的时候，阻塞掉3、4、5号信号，就可以对sa_mask进行设置，设置方法参考2.8的操作\n因为现在我演示的自定义方法只是一个再简单不过的示例，实际上进程收到信号的时候需要根据不同情况进行不同的自定义处理，这些自定义处理的过程可能会很长。此时就可以block掉其他的信号，不让它们影响当前进程运行的自定义方法\n3.软件崩溃的本质之前我们经常会遇到软件出错奔溃的情况，那么奔溃的本质是什么呢？\n3.1 情景演示用下面的一个除零错误作为演示\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;using namespace std;void handler(int signo)&#123;    cout &lt;&lt; &quot;process &quot; &lt;&lt; getpid() &lt;&lt; &quot; get signal: &quot; &lt;&lt; signo &lt;&lt; endl;&#125;void TestSignal()&#123;    //对所有的进程信号都设置一个回调    for (int sig = 1; sig &lt;= 31; sig++)    &#123;        signal(sig, handler);    &#125;    cout &lt;&lt; &quot;进程信号已经设置完了&quot; &lt;&lt; endl;    sleep(3);&#125;int main(int argc, char *argv[])&#123;    TestSignal();    int a = 10;    int b = 0;    try    &#123;        int c = a / b; // C++的除0不是异常，不会抛出        //所以会直接linux系统运行报错    &#125;    catch (const exception &amp;e)    &#123;        cerr &lt;&lt; &quot;a/0 err&quot; &lt;&lt; endl;        abort();    &#125;    catch (...)    &#123;        cout &lt;&lt; &quot;base catch&quot; &lt;&lt; endl;        abort();    &#125;    return 0;&#125;\n\n运行了之后，该进程会一直收到8号信号，直到我们手动kill掉这个进程\nprocess 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8process 3947 get signal: 8Killed\n\n你可能会觉得奇怪，不是用try/catch进行了异常处理吗？为什么没有用呢？\n那是因为，在C++中，并不会将除零错误当作一个异常进行处理！\n\n\n我们自定义捕捉了8号信号，没能让进程终止。但此时这个进程已经出现了一个严重的bug，操作系统就会一直给进程发这个信号\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigFloating point exception[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ \n\n相比之下，如果不自定义捕捉，则会直接报错+终止进程；\n8号信号是SIGFPE，FPE即为Floating point exception的缩写！\n3.2 说明崩溃的本质，是该进程收到了异常信号，从而终止。\n以除零错误为例，CPU内部会有一个状态寄存器，检测到用户进行除零计算的时候，会将状态寄存器设置为浮点数错误。当操作系统检测到这个错误的时候，便会向当前正在运行的进程发送8号信号。而我们的进程在收到信号的时候，会处理这个信号，默认的处理方法就是终止进程！\n同理，当我们访问一个野指针的时候，操作系统能在虚拟地址转换的时候发现这个问题，向我们的进程发送11号信号\nint main(int argc, char *argv[])&#123;    TestSignal();    int *p;    *p=20;    return 0;&#125;\n\n11) SIGSEGV 代表段错误，写OJ题目的时候这个报错很常见😂\nprocess 6754 get signal: 11process 6754 get signal: 11process 6754 get signal: 11process 6754 get signal: 11process 6754 get signal: 11Killed\n\n4.coredump在进程控制的博客中，提到当进程因为信号终止的时候，其status中的0-7位会是对应的终止信号，而第8位是该进程的core dump标记位\n\n在1.2贴出来的源码注释中可以看到，有不少信号的默认动作是进行core dump，比如8号信号。那么这个东西到底是什么玩意呢？\n\n通过fork创建子进程，让子进程除零产生8号信号，子进程退出\nint main(int argc, char *argv[])&#123;    int status;    int id = fork();    if(id == 0)    &#123;        //子进程        int b=0;        int a = 10/b;    &#125;        int ret = waitpid(id,&amp;status,0);    //打印子进程的退出信息    printf(&quot;exitcode:%d signo:%d coredump: %d\\n&quot;,(status&gt;&gt;8)&amp;&amp;0xff,status&amp;0x7f,(status&gt;&gt;7)&amp;0x1);    return 0;&#125;\n\n此时可以观察到，coredump标记位为0\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigexitcode:0 signo:8 coredump: 0\n\n4.1 开启该功能默认情况下，我们云服务器的core dump功能是被关闭的，需要我们手动开启；\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -acore file size          (blocks, -c) 0  #coredump功能被关闭了data seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 14691max locked memory       (kbytes, -l) unlimitedmax memory size         (kbytes, -m) unlimitedopen files                      (-n) 100002pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) 14691virtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ \n\n使用ulimit -a命令指定core file的大小\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -c 10000[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -acore file size          (blocks, -c) 10000\n\n再次运行刚刚的代码，可以看到标记位为1，并且产生了一个core.27908文件，这个文件的后缀是产生coredump文件的进程pid\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsigexitcode:0 signo:8 coredump: 1[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ lltotal 292-rw------- 1 muxue muxue 593920 Nov 20 12:34 core.27908-rw-rw-r-- 1 muxue muxue    194 Nov 20 10:31 makefile-rw-rw-r-- 1 muxue muxue    601 Nov 20 09:57 mkill.cc-rw-rw-r-- 1 muxue muxue    203 Nov 20 09:56 test.cc-rwxrwxr-x 1 muxue muxue  13768 Nov 20 12:34 tsig-rw-rw-r-- 1 muxue muxue   1772 Nov 20 12:34 tsignal.cpp[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ \n\nvscode告诉我们这个不是一个普通的文本文件\n\n这个现象告诉我们，默认动作是coredump的信号，会让进程退出，将coredump标记位置为1并且产生一个core.文件\n4.2 使用coredump这个功能会将进程在运行中产生异常的上下文数据，执行core dump（核心转储）为一个文件，方便我们debug\n如下所示，使用-g命令以debug模式编译test.cc,运行的时候可以看到除零错误之后跟了一个(core dumped)提示我们进行了core dump操作，对应产生了一个core.文件\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ g++ test.cc -g -o test[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./testFloating point exception (core dumped)\n\n这时候打开gdb，输入core-file 文件名加载文件，就可以直接定位到出错代码的位置！\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ gdb testGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/muxue/git/linux/code/22-11-16_signal/test...done.(gdb) core-file core.31997[New LWP 31997]Core was generated by `./test&#x27;.Program terminated with signal 8, Arithmetic exception.#0  0x000000000040065c in main () at test.cc:1313          int a=10/0;Missing separate debuginfos, use: debuginfo-install glibc-2.17-326.el7_9.x86_64 libgcc-4.8.5-44.el7.x86_64(gdb) (gdb) \n\n这可比我们手动debug找错误方便多了\n\n4.3 为什么默认关闭？你可能会觉得，这个功能不挺好的吗，为啥默认没有开启呢？\n先来看看这个文件的大小，足足有580KB\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ls -lht total 292K-rw-rw-r-- 1 muxue muxue 1.8K Nov 20 12:37 tsignal.cpp-rw------- 1 muxue muxue 580K Nov 20 12:34 core.27908\n\n一般而言，服务端运行的一些进程，都需要保持稳定性。比如B站的服务器挂了，第一时间要做的是重启服务进程（并不是重启服务器机器）\n如果设置了这个coredump，当服务器进程因为错误退出的时候，会生成一个core.文件；这时候有一个守护进程（用来监视并及时重启服务器进程）发现服务器进程退出了，就会重启它。\n这时候又遇到了刚刚那个bug，服务器进程又退出了，守护进程又来重启它……\n如此往复，就会生成非常非常多的core.文件，塞满我们的硬盘。\n对于求稳为主的服务器而言，这可不是一个好事。所以云服务器上默认禁止了这个功能。\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -c 0[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -acore file size          (blocks, -c) 0\n\n用umlimit -c 0指定大小为0关闭该功能\n\n5.进程处理信号前面八八了这么一大堆，进程到底是什么时候来处理信号的呢？\n\n开门见山：进程从内核态切换成用户态的时候，处理信号\n\n5.1 内核态&#x2F;用户态在程序地址空间的博客中，提到了每一个进程都有1gb的内核空间；该内核空间用于内核级页表的映射，即映射操作系统的物理内存！\n\n有内核级页表的存在，无论进程怎么切换，都能找到操作系统内核的代码和数据，前提是有权限访问。\n\nCPU中的CR3状态寄存器会标识当前进程处于内核态还是用户态\n内核态可以访问所有代码和数据，权限最高\n用户态只能访问当前进程自己的数据\n\n当我们进程需要执行内核接口的时候，就需要将进程切换为内核态；运行完毕之后，切换回用户态。\n当我们进程出现了异常，会从用户态切换成内核态，由操作系统检测相关异常并向进程发送对应信号。\n当我们进程的时间片到了（需要切换进程）也会从用户态转为内核态，由操作系统来进行进程切换。\n5.2 信号检测当进程从内核态切换回用户态的时候，会进行信号的检测和处理。此时判断pending表中是否有未处理信号，以及该信号是否有被block。如果一个信号没有被block，则将该信号递达给进程，执行对应的处理方法\n\n执行用户的自定义方法时，应该以什么身份执行？\n\n注意，当我们给一个信号指定了自定义处理方法，就代表该信号的处理方法是用户提供的。此时需要以用户的身份去执行这个代码，才能正确访问用户级页表。\n这么做也能避免恶意代码的注入。如果有人在自定义方法中写一个修改系统内核的恶意代码，也能被操作系统发现并阻止。\n这个过程可以用下面这张图来解释（并非完整过程，仅供参考理解）\n\n每次处理完信号后，会返回用户进程，从上一次中断的位置开始继续往后运行\n6.可重入函数//头插void insert(Node* p)&#123;\tp-&gt;next=head;\thead=p;&#125;\n\n上面这个函数是一个非常简单的链表头插函数\n如果我们这个头插函数处理的是一个全局的链表，就可能会因为用户态、内核态的切换，函数重入造成错误\n\n所以insert就是一个不可重入函数！除了这个头插，还有一些其他的函数也符合这个特效：\n\n调用了malloc或者free（可能会多次malloc和多次free）\n调用了I&#x2F;O库的函数\n绝大多数库函数都是不可重入的，比如C++的STL库\n\n依此类推，如果一个函数只访问他自己的局部变量，不会影响其他参数。那么他就是一个可重入函数\n6.1 原子操作所谓原子操作是指不会被 线程调度 机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）\n\n如果一个函数进行了对全局变量的原子操作，那么它也是可重入的函数。因为原子操作不包含中间态\n如果一个函数对全局变量进行了非原子操作（比如上面的链表头插）那么他就是一个不可重入函数\n\n7.volatile之前的学习中就已经知道，这个关键字的作用是每一次访问变量的时候，都必须要去内存中取。\n\n假设我们进程中需要通过一个全局变量进行条件判断\nint flag=0;int main()&#123;    if(flags)    &#123;        //..    &#125;    else    &#123;        //..    &#125;    return 0;&#125;\n\n如果我们自定义捕捉了一个信号，收到该信号的时候，会修改flag，执行if&#x2F;else语句中对应的代码。\n由于编译器的优化问题，每一次访问flag的时候，它可能不会每次都去内存中取，就会出现一个问题\n\n寄存器中 flag&#x3D;0\n经过自定义捕捉函数处理，内存中 flag&#x3D;1\n\n这两个flag在if条件中会导向不同的结果！\n为了避免这种可能因为平台、编译器、优化问题导致的代码bug，我们需要告诉所有编译器，不准对flag变量做任何优化处理，必须要老老实实的去内存中拿这个变量的数据！\n//volatile保持内存的可见性volatile int flag = 0;\n\n7.1 示例\ngcc编译器可以通过-O2指定较高的优化等级\n\n以下面的代码为例\n#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;// 保持内存的可见性int flag = 0;void handler(int signo)&#123;    flag = 1;    printf(&quot;\\n更改flags: 0-&gt;1\\n&quot;);&#125;int main()&#123;       printf(&quot;process start %d\\n&quot;,getpid());    signal(2, handler);//自定义捕捉2号信号    while (!flag)        ;//啥事不干的循环       \tprintf(&quot;process exit!\\n&quot;);    return 0;&#125;\n\n运行之后，键入CTRL+C，你会发现进程依旧没有退出！理论上来说flags=1，!flags为假，应终止循环，退出进程才对！\n[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test -O2[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./testprocess start 22333^C更改flags: 0-&gt;1^C更改flags: 0-&gt;1^C更改flags: 0-&gt;1^C更改flags: 0-&gt;1^\\Quit[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ \n\n如果我们加上volatile关键字，则不会出现这个问题，进程能够正常退出\n[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test -O2[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./testprocess start 23086^C更改flag: 0-&gt;1process exit![muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ \n\n去掉gcc编译器的优化参数，去掉volatile关键字，会发现进程也能正常退出\n[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./testprocess start 23224^C更改flag: 0-&gt;1process exit![muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ \n\n这就是编译器优化不同的影响！加上volatile关键字能避免这个问题，使代码运行能有唯一结果！\n8.子进程发送信号当子进程的状态变化的时候，会向父进程发送17号信号\nvoid testfork()&#123;    int status;    int id = fork();    if(id == 0)    &#123;        //子进程        cout &lt;&lt; &quot;chlid process: &quot; &lt;&lt;getpid()&lt;&lt;endl;        int b=0;        int a = 10/b;    &#125;    TestSignal();    int ret = waitpid(id,&amp;status,0);    //打印子进程的退出信息    printf(&quot;exitcode:%d signo:%d coredump: %d\\n&quot;,(status&gt;&gt;8)&amp;&amp;0xff,status&amp;0x7f,(status&gt;&gt;7)&amp;0x1);&#125;\n\n观察结果，可以看到父进程收到了子进程的17号信号，此时子进程因为错误退出\n[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig进程信号已经设置完了chlid process: 25319process 25318 get signal: 17exitcode:0 signo:8 coredump: 0[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ \n\n除了退出时会发送信号，子进程暂停、继续运行的时候，都会向父进程发送信号\n\n8.1 父进程回收子进程既然父进程能收取到子进程发送的信号，那么我们自定义捕捉17号信号，在其中调用waitpid，即可在子进程出错或执行完毕需要退出的时候，进行父进程回收\n\n这样就不需要在main函数中进行主动wait了\n\n操作并不难，我们只需要将17号信号进行自定义捕捉，在捕捉函数中执行waitpid进行等待即可\n\n注意：这里的waitpid必须使用WNOHANG进行非阻塞等待\n当父进程正在阻塞等待子进程A的时候，它在处理17号信号，新的17号信号无法收到\n这就会导致在A之后种子的子进程，无法向父进程发送有效的17号信号\n从而出现了僵尸进程（未回收的子进程）\n\n使用非阻塞等待，即可以避免此问题，又能让父进程在等待的过程中处理自己的其他工作，一举两得。\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;cassert&gt;using namespace std;void FreeChld(int signo)&#123;    assert(signo == SIGCHLD);    while (true)    &#123;        //如果没有子进程了，waitpid就会调用失败        pid_t id = waitpid(-1, nullptr, WNOHANG); // 非阻塞等待        if (id &gt; 0)        &#123;            cout &lt;&lt; &quot;父进程等待成功, child pid: &quot; &lt;&lt; id &lt;&lt; endl;        &#125;        else if(id == 0)        &#123;            //还有子进程没有退出            cout &lt;&lt; &quot;尚有未退出的子进程，父进程继续运行&quot; &lt;&lt; endl;            break;        &#125;        else        &#123;            cout &lt;&lt; &quot;父进程等待所有子进程结束&quot; &lt;&lt; endl;            break;        &#125;    &#125;&#125;int main()&#123;    signal(SIGCHLD, FreeChld);    for (int i = 0; i &lt; 5; i++)    &#123;        pid_t id = fork();        if (id == 0)        &#123;            //子进程            int cnt = 8;            while (cnt)            &#123;                cout &lt;&lt; &quot;子进程 pid: &quot; &lt;&lt; getpid() &lt;&lt; &quot; cnt: &quot; &lt;&lt; cnt-- &lt;&lt; endl;                sleep(1);            &#125;            cout &lt;&lt; &quot;子进程退出，进入僵尸状态: &quot; &lt;&lt; i &lt;&lt; endl;            exit(0);        &#125;        sleep(2);    &#125;    while (true)    &#123;        cout &lt;&lt; &quot;父进程正在运行: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    return 0;&#125;\n\n如下右图中，第0个子进程退出进入将是状态，父进程收到17号信号，就开始回收子进程。此时还有4个子进程没有运行完毕，父进程会继续运行，等待其他子进程结束\n\n当所有子进程都等待结束了，waitpid返回-1让父进程退出回收子进程的循环，现在就只有父进程自己在干活了\nwhile :; do ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\n反应到监控信息上，父进程先是创建了5个子进程\n\n随后当第一个子进程退出的时候，父进程开始回收子进程。这里也能观测到，回收成功，并没有出现僵尸状态的子进程。\n\n8.2 父进程忽略子进程前面提到过，SIG_IGN的作用是忽略这个子进程；你可能会想，这不对啊，忽略了子进程的信号，那岂不是父进程不想搭理子进程了吗？\n*\t|  SIGCHLD           |\tignore   \t|\n\n查1.2表你还会发现，SIGCHLD的默认动作不就是忽略吗？自己设置一下是不是多此一举？\nsignal(SIGCHLD, SIG_IGN);\n\n然并不是这样，对于SIGCHLD17号信号而言，我们给父进程设置了手动忽略后，子进程退出的时候将自动被回收\n这么做的前提，是父进程不需要和子进程在回收资源的时候进行处理，说人话就是，只要父进程不想管任何子进程的工作，那就可以直接把17号信号手动设置成SIG_IGN\n\n结语进程信号到这里就基本over了，干货满满！\n如果对你有帮助，还请点个赞吧！！！\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【Linux】如何使用ssh密钥配置git","url":"/2022/05/09/code/note_Linux/1%E4%BD%BF%E7%94%A8ssh%E8%BF%9E%E6%8E%A5git/","content":"之前的腾讯云搭建Linux环境博客中包含了本文，但是由于在我的环境下SSH配置git无法多次生效。\n为了避免误导，所以把这一部分单独成文，并删除原文中相关部分\n\n22-06-19更新：问题已解决，可放心阅读本文！\n\n\n\n[TOC]\n1.创建SSH密钥①本地创建ssh密钥输入这个语句（github啥的都是同理）\nssh-keygen -t rsa -C &quot;你的gitee账户邮箱&quot;\n\n然后会弹出来让你输入一个文件名，直接连按3次回车跳过\nEnter file in which to save the key (/home/muxue/.ssh/id_rsa): id_rsa_用户名Enter passphrase (empty for no passphrase): Enter same passphrase again: \n\n后面出现的passphrase语句直接回车跳过，出现下面这个就是配置好了\nYour identification has been saved in id_rsa_用户名……#后面还有很多，还出现了一个文字组成的图片\n\n②把SSH公钥添加到gitee&#x2F;github账户上直接cd .ssh进入隐藏文件夹，cat你刚刚生成的pub文件，将内容复制\ncd .sshcat id_rsa.pub\n\n你还可以使用Xftp打开刚刚创建的密钥文件，把里面生成的内容复制一份\n\n\n在gitee账户设置中找到SSH公钥，添加即可\n\ngithub同理\n\n③测试ssh连接搞定密钥后，测试是否可以用ssh访问我们的远程仓库\nssh -T git@gitee.com//github只需要把gitee改成github就行了\n\n出现下面的就是成功了\n\n\n④该方式有错误（已解决）SSH方式不知为何，在我的云主机上，只有当次设置有效，重新打开终端连接云服务器（云服务器没有重启）SSH就会失效。在我的Linux用户目录下以及我朋友的用户目录下都出现了这个问题！\n\n如果你也出现了这个问题，请直接使用账户密码方式，而不是SSH\n\n22-06-19更新：在原先博客中，提到了下面这个本地添加ssh密钥的步骤\n\n执行下面两个语句，添加你的ssh密钥到设置中。注意，生成的密匙应该是在\nssh-agent bashssh-add ~/.ssh/id_rsa_用户名\n\n\n\n实际上，出现无法多次使用的问题，就是因为这莫须有的一步操作！\n正确方法是：别执行这一步，就OK了！\n如果你之前做了这一步，那就重新创建一个ssh密钥\n\n2.克隆远程仓库使用mkdir 文件夹名创建一个文件夹，CD进去后，克隆我们的远程仓库\ngit clone 远程仓库的ssh链接\n\n因为现在我们配置的是SSH方式，所以要使用SSH链接而不是https\n\n\n克隆成功后，cd进入该目录，git status查看git仓库当前状态，应该是up-to-date的。\n3.上传代码随便创建一个新的文件，测试能否正常PUSH到远程仓库\n\n这部分设计到git命令行操作，如果你不会，可以搜几篇git的博客学习一下\n\ngit add 文件夹 #添加需要上传的文件路径git commit -m &quot;输入push信息&quot; #git push的信息git push #和远程仓库同步\n\n\n因为我们没有设置用户名和邮箱，所以出现了下面的报错\n\n用下面的两行命令，可以单独设置当前仓库的用户邮箱和用户名。如果需要全局设置，则依照上图中的操作，使用git config --global语句即可\ngit config  user.email &quot;you@example.com&quot;git config  user.name &quot;Your Name&quot;\n\n同时我们需要用下面的这个命令，设置让git默认push到当前分支上\ngit config --global push.default current\n\n\n再次测试git push，成功！\n\n\n有任何问题都可以在评论区提出哦！\n","categories":["玩上Linux"],"tags":["Linux","git"]},{"title":"【Linux】线程概念 | 互斥","url":"/2022/12/23/code/note_Linux/19%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5/","content":"千呼万唤始出来，终于到多线程方面的学习了！\n\n\n\n所用系统Centos7.6  本文的源码👉【传送门】\n\n[TOC]\n1.线程的概念在之前的linux学习中，已经接触过了进程的概念，进程由一个task_struct结构体在操作系统中进行描述，CPU在执行的时候，会依照进程时间片进行轮询调度，让每一个进程的代码都得以推进，实现多个进程的同时运行\n而线程，可以理解为是一种轻量化的进程，每一个进程都可以创建多个线程，并行执行不同的代码\n进程:线程 = 1:N\n\n在之前的多进程操作中，我们使用fork接口创建子进程，通过if/else语句判断，实现对特定执行流的划分\n\n创建子进程时，需要拷贝一份task_struct/mm_struct并创建页表\n当子进程修改了一部分变量，会发生写时拷贝，修改页表在物理内存上的映射\n\n可以看到，当我们需要创建一个新进程的时候，操作系统需要做不少的工作\n\n1.1 执行流让我们康康执行流这一概念：\n\n单执行流进程：内部只有一个执行流的进程\n多执行流进程：内部有多个执行流的进程\n\n进程=内核数据结构+代码和数据，在内核视角中，进程是承担分配系统资源的基本实体（进程的基座属性）\n\n进程：向系统申请资源的基本单位（系统分配）\n线程：系统调度的基本单位\n\n\n1.2 线程创建时做了什么？那线程的创建需要做什么呢？\n\n不同操作系统的实现不同，一般用tcb指代描述线程的结构体\n\n在linux中，没有进程和线程在概念上的区分，其以执行流为基础，线程只是简单的对task_strcut进行了二次封装；线程是在进程内部运行的执行流\n\n说人话：linux下的线程是用进程模拟的\n换句话：linux下的进程也是一种线程，但是其只有一个执行流\n对于CPU而言，其看到的task_struct都是一个执行流\n\n而创建线程时也有说法，线程隶属于某一个进程下，并不是独立的子进程，所以不需要创建新的mm_struct和页表映射，创建的效率高于子进程。只需要将task_struct指向原有进程的mm_struct和页表即可。\n\n同样的，CPU在推行多线程操作的时候，无须执行pcb切换，就能实现单进程多个线程操作的同时进行，执行效率变高！\n\n线程是一种Light weight process 轻量级进程，简称LWP\n\n1.3 内核源码中的体现在task_strcut结构体中，有这么一个字段\n/* CPU-specific state of this task */\tstruct thread_struct thread;\n\n转到定义，其内部都是一些寄存器信息，用于标识这个线程的基本信息。这也是linux中没有单独实现线程tcb的体现，而是用task_struct来模拟的\nstruct thread_struct &#123;\t/* Cached TLS descriptors: */\tstruct desc_struct\ttls_array[GDT_ENTRY_TLS_ENTRIES];\tunsigned long\t\tsp0;\tunsigned long\t\tsp;#ifdef CONFIG_X86_32\tunsigned long\t\tsysenter_cs;#else\tunsigned long\t\tusersp;\t/* Copy from PDA */\tunsigned short\t\tes;\tunsigned short\t\tds;\tunsigned short\t\tfsindex;\tunsigned short\t\tgsindex;#endif#ifdef CONFIG_X86_32\tunsigned long\t\tip;#endif#ifdef CONFIG_X86_64\tunsigned long\t\tfs;#endif\tunsigned long\t\tgs;\t/* Hardware debugging registers: */\tunsigned long\t\tdebugreg0;\tunsigned long\t\tdebugreg1;\tunsigned long\t\tdebugreg2;\tunsigned long\t\tdebugreg3;\tunsigned long\t\tdebugreg6;\tunsigned long\t\tdebugreg7;\t/* Fault info: */\tunsigned long\t\tcr2;\tunsigned long\t\ttrap_no;\tunsigned long\t\terror_code;\t/* floating point and extended processor state */\tunion thread_xstate\t*xstate;#ifdef CONFIG_X86_32\t/* Virtual 86 mode info */\tstruct vm86_struct __user *vm86_info;\tunsigned long\t\tscreen_bitmap;\tunsigned long\t\tv86flags;\tunsigned long\t\tv86mask;\tunsigned long\t\tsaved_sp0;\tunsigned int\t\tsaved_fs;\tunsigned int\t\tsaved_gs;#endif\t/* IO permissions: */\tunsigned long\t\t*io_bitmap_ptr;\tunsigned long\t\tiopl;\t/* Max allowed port in the bitmap, in bytes: */\tunsigned\t\tio_bitmap_max;/* MSR_IA32_DEBUGCTLMSR value to switch in if TIF_DEBUGCTLMSR is set.  */\tunsigned long\tdebugctlmsr;\t/* Debug Store context; see asm/ds.h */\tstruct ds_context\t*ds_ctx;&#125;;\n\n1.4 线程的私有物我们知道，一个进程是完全独立的。但是线程并不是，因为线程只是进程的一个执行流分支，它从进程继承了绝大部分属性（也可以理解为是共享的）\n\n用户id和组id\n进程id\n进程工作目录\n文件描述符表\n信号的处理方式（如果进程有对某个信号进行自定义捕捉，那么线程会共用这个自定义捕捉）\n和进程共用一个堆\n\n但线程也会有自己的私有物！\n\n线程id\n线程独立的寄存器（因为线程也需要执行代码，有上下文数据）\n栈（线程运行函数时也需要压栈和出栈，必须独立否则执行流会出问题）\nerrno（单独的报错信息）\n信号屏蔽字（可以单独针对某个信号处理）\n线程调度优先级\n\n1.5 线程优缺点1.5.1 缺点\n线程是缺乏保护的（不具备进程的独立性）这也被称为健壮性；线程的健壮性低\n\n当进程被停止的时候，其下线程也会被停止\n当有一个线程出bug了，会让整个进程退出\n多线程中的全局变量问题\n\n\n线程缺乏访问控制，在一个线程中调用某些操作系统的接口会影响整个进程\n\ndebug多线程较麻烦\n\n如果同一个进程所用线程太多，可能会无法充分利用cpu性能而造成性能损失\n\n\n1.5.2 优点\n开辟的消耗低于进程，占用的资源低于进程\n切换线程无须切换页表等结构，速度快\n等待慢IO设备时，进程可以继续执行其他操作；将部分IO操作重叠，能让进程同时等待多个IO操作\n能充分利用处理器的可并行数量\n\n\n2.基础函数linux下提供了pthread库来实现线程操作\n2.1 pthread_create人如其名，这个函数的作用是来创建新进程的\n#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr,\t\t\t\t\tvoid *(*start_routine) (void *), void *arg);//Compile and link with -pthread.\n\n\n第一个参数是一个输出型参数，为该线程的id\n第二个参数是用于指定线程的属性，暂时设置为NULL使用默认属性\n第三个参数是让该进程执行的函数，这是一个函数指针，参数和返回值都为void*\n第四个参数是传给第三个执行函数的参数\n\n创建正常后返回0，否则返回错误码\n注意，使用了pthread库后，需要在编译的时候指定链接，-lpthread\ntypedef unsigned long int pthread_t;//线程id\n\n创建线程后打印可以发现，线程id是一个非常大的值，并不像进程PID那么小\n//cout &lt;&lt; &quot;pthread_create &quot;&lt;&lt; t1 &lt;&lt; &quot; &quot; &lt;&lt; t2 &lt;&lt; endl;pthread_create 140689524995840 140689516603136\n\n可以通过printf %x的方式来减少打印长度\n//printf(&quot;0x%x  0x%x\\n&quot;,t1,t2);0x393d0700  0x38bcf700\n\n2.2 pthread_join光是创建进程还不够，我们还需要对进程进行等待\n#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);//Compile and link with -pthread.\n\n这里第一个参数是线程的id，第二个参数是进程的退出状态\n等待成功后返回0，否则返回错误码\n\njoin可以在线程退出后，释放线程的资源\n同时获取线程对应的退出码\njoin还能保证是新创建的线程退出后，主线程才退出\n\n2.2.1 基础的多线程操作有了这两个，我们就能写一个简单的多线程操作了\n#include&lt;iostream&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;using namespace std;void* func1(void* arg)&#123;    while(1)    &#123;        cout &lt;&lt; &quot;func1 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;&#125;void* func2(void* arg)&#123;    while(1)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;&#125;int main()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    while(1)    &#123;        cout &lt;&lt; &quot;this is main::&quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);    &#125;    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);    return 0;&#125;\n\n执行会发现，多线程操作成功启动，且打印的进程pid都是一样的，代表其隶属于同一个进程\n\n我们可以用下面的语句来查看轻量级进程\nps -aL\n\n可以看到，执行了程序之后，出现了3个PID相同，LWP不同的轻量级进程，这就代表我们的多线程操作成功了；\n同时也能看到，在多线程操作时，谁先运行是不确定的。这是由系统调度随机决定的\n\n2.2.2 C++的多线程操作C++11也支持了多线程操作，其封装了操作系统的pthread接口，基本的操作很相似\nvoid test2()&#123;    thread t1(func1,(char*)&quot;test1&quot;);    thread t2(func2,(char*)&quot;test2&quot;);       while(1)    &#123;        cout &lt;&lt; &quot;this is main:: &quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);    &#125;    t1.join();    t2.join();&#125;\n\n执行后的效果是一样的，C++的thread库还可以传入functional封装的可调用函数，和lambda表达式\n\n2.3 线程退出2.3.1 retvalint pthread_join(pthread_t thread, void **retval);\n\n我们可以使用该函数的第二个参数来获取线程所执行方法的返回值。retval是一个二级指针，是一个输出型参数\n#include&lt;iostream&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;using namespace std;void* func1(void* arg)&#123;    int a = 5;    while(a--)    &#123;        cout &lt;&lt; &quot;func1 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func1 exit&quot; &lt;&lt; endl;    return (void*)100;&#125;void* func2(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func2 exit&quot; &lt;&lt; endl;    return (void*)10;&#125;void test3()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    int a = 15;    while(a--)    &#123;        cout &lt;&lt; &quot;this is main:: &quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);    &#125;    void* r1;    void* r2;    pthread_join(t1,&amp;r1);    pthread_join(t2,&amp;r2);    sleep(2);    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;&#125;int main()&#123;        test3();    return 0;&#125;\n\n可以看到，当两个线程退出之后，主函数中成功打印出了他们的返回值\n\n注意，因为我们是将void*的指针强转为int，如果在打印的时候强转为int，会出现精度丢失的报错，需要使用long long来规避报错\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ makeg++ test.cpp -o test -lpthread -std=c++11.test.cpp: In function ‘void test3()’:test.cpp:88:35: error: cast from ‘void*’ to ‘int’ loses precision [-fpermissive]     cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (int)r1 &lt;&lt; endl;                                   ^make: *** [test] Error 1\n\n2.3.2 pthread_exit除了直接return，线程还可以调用pthread_exit函数实现退出\n#include &lt;pthread.h&gt;void pthread_exit(void *retval);//Compile and link with -pthread.\n\n效果完全一样\n//return (void*)10;pthread_exit((void*)10);\n\n注意，主线程main中调用该函数，并不会导致进程退出\nvoid* func2(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; &quot; tid: &quot; &lt;&lt; syscall(SYS_gettid) &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func2 exit&quot; &lt;&lt; endl;    pthread_exit((void*)10);&#125;void test5()&#123;    pthread_t t1,t2;\t//func2会执行10s    pthread_create(&amp;t1,nullptr,func2,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    sleep(1);    pthread_detach(t1);    pthread_detach(t2);    sleep(1);&#125;int main()&#123;        test5();    pthread_exit(0);//主线程提前退出    cout &lt;&lt; &quot;main exit&quot; &lt;&lt; endl;    return 0;&#125;\n\n可以看到，主函数已经调用了pthread_exit退出了，但是线程还在跑\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc2 thread:: 1 :: 9474 tid: 9475func2 thread:: 2 :: 9474 tid: 9476func2 thread:: 1 :: 9474 tid: 9475func2 thread:: 2 :: 9474 tid: 9476main exitfunc2 thread:: 1 :: 9474 tid: 9475func2 thread:: 2 :: 9474 tid: 9476\n\n2.3.3 ptrhead_cancel除了上面俩种方式，我们还可以在main里面直接把某一个线程给关掉\n#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);//Compile and link with -pthread.\n\nvoid test3()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);    int a = 15;    while(a--)    &#123;        cout &lt;&lt; &quot;this is main:: &quot; &lt;&lt; getpid()&lt;&lt;endl;        sleep(1);        if(a==11)        &#123;            pthread_cancel(t1);            pthread_cancel(t2);            break;        &#125;    &#125;    void* r1;    void* r2;    pthread_join(t1,&amp;r1);    pthread_join(t2,&amp;r2);    sleep(2);    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;&#125;\n\n被提前终止的进程，返回值都为-1\n\n2.3.4 为什么进程退出不会向主进程发送信号？要理清楚这个问题，还是需要深知一个概念：线程是进程中的一个执行流，它并不是一个独立的进程。\n先来回顾一下进程退出的几种情况：\n\n代码跑完，结果正确\n代码跑完，结果有问题\n代码出错了，异常\n\n线程退出的情况也是这样，但线程如果因为某些异常退出，进程也会同步退出！\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testthis is main:: 13845Floating point exception[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ \n\n由此可见，线程异常 = 进程异常\n这里也就涉及到1.5.1中提到的线程健壮性问题，线程的异常会影响其他线程的运行，会导致进程整体异常退出。\n所以在join等待线程退出的时候，我们只需要考虑线程正常退出的情况；\n\n异常退出的时候恐怕也等不了😂因为进程也挂了\n\n2.3.5 exit任何一个线程执行exit()函数，都会导致整个进程退出\n\n2.4 pthread_detach等待是有性能损失的！默认创建的进程是joinable，也就是可以被主线程进行pthread_join等待的；\n这个函数的作用是让主线程不管创建出来的子线程，也不用去等待它，相当于取消了它的joinable属性；\n就好比父进程不想管子进程的时候，将SIGCHLD设置为SIG_IGN\n#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread);//Compile and link with -pthread.\n\n一个线程是否应该等待，取决于是否需要获取该线程的返回值；如果无须获取返回值，则使用分离能提高运行效率\n2.4.1 实操使用也很简单，只需要指定线程的id就行了\nvoid test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    while(1)    &#123;        cout &lt;&lt; &quot;this is main - global: &quot; &lt;&lt; global &lt;&lt; &quot; - &amp;global: &quot; &lt;&lt; &amp;global &lt;&lt; endl;        sleep(1);    &#125;    pthread_detach(t1);    pthread_detach(t2);&#125;\n\n运行上也不会有什么区别，但是我们已无法获取到该线程的返回值\n\n\n2.4.2 detach后join但如果我们在detach之后又进行pthread_join会发生什么呢？\nvoid* func3(void* arg)&#123;    pthread_detach(pthread_self());    int a = 7;    while(a--)    &#123;        printf(&quot;func thread:%s - global:%d - &amp;global:%p\\n&quot;,(char*)arg,global,&amp;global);        global++;        sleep(1);    &#125;    cout &lt;&lt; &quot;func exit&quot; &lt;&lt; endl;    return (void*)10;&#125;void test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    void* r1=nullptr;    void* r2=nullptr;    pthread_join(t1,&amp;r1);    pthread_join(t2,&amp;r2);    sleep(2);    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;&#125;\n\n诶，这不还是获取到了返回值吗？这么说，他这个detach岂不是没用？\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc thread:1 - global:103 - &amp;global:0x7fb5648b06fcfunc thread:2 - global:103 - &amp;global:0x7fb5640af6fcfunc thread:1 - global:104 - &amp;global:0x7fb5648b06fcfunc thread:2 - global:104 - &amp;global:0x7fb5640af6fcfunc exitfunc exitretval 1 : 10retval 2 : 10[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ \n\n实际上，当我们create一个线程的时候，它会先去执行线程创建的相关代码，此时main又直接去执行后面的代码了；此时pthread_join的调用是成功的，因为线程自己的detach代码还没有被执行！\n\n而如果我们在create之后，等线程开始运行了在执行detach，此时join就会失败\nvoid test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    sleep(2);    pthread_detach(t1);    pthread_detach(t2);    sleep(1);    void* r1=nullptr;    void* r2=nullptr;    int ret = pthread_join(t1,&amp;r1);    cout &lt;&lt; ret &lt;&lt; &quot;:&quot; &lt;&lt; strerror(ret) &lt;&lt; endl;    ret = pthread_join(t2,&amp;r2);    cout &lt;&lt; ret &lt;&lt; &quot;:&quot; &lt;&lt; strerror(ret) &lt;&lt; endl;    cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (long long)r1 &lt;&lt; endl;    cout &lt;&lt; &quot;retval 2 : &quot; &lt;&lt; (long long)r2 &lt;&lt; endl;    sleep(20);&#125;\n\n打印错误码也能看到，系统提示我们给join传入了一个无效的参数，线程依旧在正常运行\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc thread:1 - global:101 - &amp;global:0x7f2d439136fcfunc thread:2 - global:101 - &amp;global:0x7f2d431126fcfunc thread:2 - global:102 - &amp;global:0x7f2d431126fcfunc thread:1 - global:102 - &amp;global:0x7f2d439136fc22:Invalid argument22:Invalid argumentretval 1 : 0retval 2 : 0func thread:2 - global:103 - &amp;global:0x7f2d431126fcfunc thread:1 - global:103 - &amp;global:0x7f2d439136fc\n\n所以正确的做法，应该是在主线程中分离线程，不要在线程自己的代码中执行detach，否则就会出现上面的分离失败的情况\n2.4.3 线程分离后，主线程先退出如果执行完毕pthread_detach后，主线程提前退出了，会发生什么？\nvoid test5()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    sleep(1);    pthread_detach(t1);    pthread_detach(t2);    sleep(2);    cout &lt;&lt; &quot;main exit&quot; &lt;&lt; endl;&#125;\n\n显而易见，线程也跟着一并退出了\n[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./testfunc thread:1 - global:100 - &amp;global:0x7f01cd49a6fcfunc thread:2 - global:100 - &amp;global:0x7f01ccc996fcfunc thread:2 - global:101 - &amp;global:0x7f01ccc996fcfunc thread:1 - global:101 - &amp;global:0x7f01cd49a6fcfunc thread:2 - global:102 - &amp;global:0x7f01ccc996fcfunc thread:1 - global:102 - &amp;global:0x7f01cd49a6fcmain exit[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ \n\n因为线程没有独立性，完全属于这个进程。不可能出现你家房子塌了，你自己的房间还在的情况😂\n\n进程退出的时候，操作系统就回收了这个进程的程序地址空间，连资源都被释放了，线程就没有办法继续运行，自然就退出了。\n\n所以，为了避免这种问题，一般我们分离线程的时候，都倾向于让主线程保持在后台运行（常驻内存的程序）\n2.5 gettid&#x2F;syscall该函数是一个系统接口，但它并不能直接运行\nNAME       gettid - get thread identificationSYNOPSIS       #include &lt;sys/types.h&gt;       pid_t gettid(void);       Note:  There  is  no  glibc wrapper for this system call; see       NOTES.\n\n我们需要用syscall函数来调用该接口，这也是第一次接触到syscall函数\n#define _GNU_SOURCE         /* See feature_test_macros(7) */#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;   /* For SYS_xxx definitions */int syscall(int number, ...);\n\n在syscall的man手册中，我们就能看到获取线程id相关的示例\n//EXAMPLE#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;int main(int argc, char *argv[])&#123;    pid_t tid;    tid = syscall(SYS_gettid);    tid = syscall(SYS_tgkill, getpid(), tid);&#125;\n\n用下面的代码进行测试\nvoid* func2(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func2 thread:: &quot; &lt;&lt; (char*)arg &lt;&lt; &quot; :: &quot; &lt;&lt; getpid() &lt;&lt; &quot; tid: &quot; &lt;&lt; syscall(SYS_gettid) &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func2 exit&quot; &lt;&lt; endl;    pthread_exit((void*)10);&#125;void test1()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func2,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;2&quot;);       while(1)    &#123;        printf(&quot;tis is main - pid:%d - tid:%d\\n&quot;,getpid(),syscall(SYS_gettid));        sleep(1);    &#125;    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;\n\n运行可以看到进程打印出了相同的PID和不同的TID，其TID对应的就是ps -aL中显示的LWP编号\n\n3.相关概念3.1 线程id是什么？前面提到过，pthread_t是线程独立的id，本质上是一个无符号长整形，打印出来后，是一个很大的数字。这个数字有什么特别的含义吗？\n先来回顾一下线程的基本概念：\n\n线程是一个独立的执行流\n线程在运行过程中，会产生自己的临时数据\n线程调用函数的压栈出栈操作，有自己独立的栈结构\n\n因此，既然有一个独立的栈结构，其就需要有一个标识符来指向这个栈结构，方便程序运行的时候进行调用！\n所以，pthread_t本质上是一个地址！其指向的就是这个线程的控制块，其内部包含了这个线程的独立栈结构。\n//printf(&quot;0x%x  0x%x\\n&quot;,t1,t2);0x393d0700  0x38bcf700 //打印出来的结果也很像地址\n\n3.2 pthread库pthread库并不是一个内核级的接口库，其实际上是封装了系统的clone/vfork等接口，从而为我们提供的用户级的线程库。\n使用pthread库创建的进程，和内核中的LWP是1:1的\n\npthread是一个动态库，所以在编译的时候需要加上链接选项\ng++ test.cpp -o test -lpthread\n\n在我的 动静态库 的博客中有讲述过，动态库是在运行的时候动态链接的，其会将库中的代码映射到进程地址空间的共享区，从而调用动态库中的代码\n\n举个例子，当我们调用pthead_create的时候，进程会跳到共享区中，执行动态库中的代码，创建成功后返回自己的代码区，完成一个线程的创建\n\n而线程所用的独立栈，也是pthread库帮我们管理的。因为有共享区的存在，我们能通过pthread_t直接访问到动态库中管理的线程的控制模块，从而完成线程的压栈、出栈等等操作\n\n下为linux的pthreadtypes.h中的部分内容\n# define __SIZEOF_PTHREAD_ATTR_T 36typedef unsigned long int pthread_t;union pthread_attr_t&#123;  char __size[__SIZEOF_PTHREAD_ATTR_T];  long int __align;&#125;;#ifndef __have_pthread_attr_ttypedef union pthread_attr_t pthread_attr_t;# define __have_pthread_attr_t\t1#endif\n\n3.3 线程的局部存储假设我们有一个全局变量，我们想让创建出来的每一个线程，都能独立的使用这个全局变量，那就需要用到线程的局部存储\nint global = 10;//全局变量void* func3(void* arg)&#123;    int a = 10;    while(a--)    &#123;        cout &lt;&lt; &quot;func thread &quot; &lt;&lt; (char*)arg &lt;&lt;  &quot; - global: &quot; &lt;&lt; global &lt;&lt; &quot; - &amp;global: &quot; &lt;&lt; &amp;global &lt;&lt; endl;        sleep(1);    &#125;    cout &lt;&lt; &quot;func exit&quot; &lt;&lt; endl;&#125;void test4()&#123;    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func3,(void*)&quot;1&quot;);    pthread_create(&amp;t2,nullptr,func3,(void*)&quot;2&quot;);    while(1)    &#123;        cout &lt;&lt; &quot;this is main - global: &quot; &lt;&lt; global &lt;&lt; &quot; - &amp;global: &quot; &lt;&lt; &amp;global &lt;&lt; endl;        sleep(1);    &#125;    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;\n\n执行，不管是主线程还是线程，都打印的是相同的值和地址\n\n如果在执行的函数func3中添加一个global++，则能观察到所有线程都是公用的一个变量，这里的+是同步的。\n\n如果我们想让int global变成局部变量，则需要在它之前加上一个__thread\n__thread int global = 100;//可以让线程独立使用的全局变量\n\n此时可以看到，两个线程和主线程打印的global变量地址不同，他们的++操作是独立的，变量的值也是独立的\n\n这就实现了将某一个变量划分给线程进行局部存储\n4.线程互斥问题4.1 临界资源在先前共享内存 信号量的博客中，已经涉及到了这部分的内容；即关于操作原子性和访问临界资源&#x2F;临界区的相关问题。\n\n能被多个进程&#x2F;线程看到的资源，被称为临界资源\n进程&#x2F;线程访问临界资源的代码，被称为临界区\n\n在线程中，同样存在访问临界资源而导致的冲突：\n\n线程A对一个全局变量val进行了-1操作，当操作执行到放回内存那一步的时候，发生了线程切换，线程B开始工作\n线程B同样访问了该全局变量val，对它进行了-10操作，此时因为线程A的-1操作尚未写回内存，全局变量val还是保持初值。线程b将-10之后的全局变量val写回了内存\n又发生了线程切换，跳转到线程A停止的线程上下文数据中开始执行，将全局变量写入内存\n这时候，线程B的-10操作就被A的写入覆盖了！\n\n举个实际点的例子，以100为全局变量的初始值\n\n线程A执行-1，100-1=99，还未写入内存时，就线程切换\n线程B取到的全局变量还是100，对其执行-10，并写入内存， 此时全局变量为90\n返回线程A继续执行写入内存操作，全局变量又被复写成了99；相当于B的操作是无效的\n\n这种条件下会产生很多问题，也是我们不希望看到的！\n4.2 原子&#x2F;互斥性这种时候，我们就需要保证访问该全局变量的操作是原子的，不能出现中间状态；\n也应该是互斥的，不能出现两个线程同时访问一份资源的情况\n\n互斥性：任何时候都只有一个执行流在访问某一份资源\n\n\n为了达成这一目的，我们需要给线程的操作加锁\n4.3 线程加锁线程加锁涉及到几个操作：\n\n提供一把锁\n在需要维持原子性（临界区）的位置加上锁\n访问临界区结束后，打开锁\n进程结束后，把锁丢了\n\n接下来就让我们一一解决这些问题\n4.3.1 pthread_mutex_initpthread在设计之初就考虑到了这种问题，所以它便给我们提供了加锁相关的操作\n#include &lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex);int pthread_mutex_init(pthread_mutex_t *restrict mutex,                       const pthread_mutexattr_t *restrict attr);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\n首先我们需要定义一把锁，类型是pthread_mutex_t\n\n如果我们需要的是一把全局变量的锁，则可以直接使用PTHREAD_MUTEX_INITIALIZER给这把锁初始化\n如果是一把局部的锁，则使用函数pthread_mutex_init进行初始化\n\n初始化的方法很简单，传入锁和对应的属性就行。此时我们忽略属性问题，设置为NULL使用默认属性\n//使用默认属性的全局锁or静态static锁//无须调用函数初始化，可以直接用pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//使用函数进行初始化局部的锁（当然也可以初始化全局锁）pthread_mutex_t mutex;//定义一把锁pthread_mutex_init(&amp;mutex, nullptr);//初始化pthread_mutex_destroy(&amp;mutex);//销毁\n\n4.3.2 加锁&#x2F;解锁有了锁，那么就可以在需要的位置加上这把锁\n#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);\n\n其中lock是阻塞式加锁，如果你调用这个接口的时候，锁正在被别人使用，则会在这里等待；trylock是非阻塞加锁，如果你调用该接口时锁正被使用，则直接return返回\nThe pthread_mutex_trylock() function shall be equivalent to pthread_mutex_lock(), except that if the mutex object referenced  by  mutex  is  currently locked (by any thread, including the current thread), the call shall return immediately. \n\n加了锁之后，在需要的位置unlock解锁；\n\n加锁和解锁操作本身是原子的，不会出现冲突\n加了锁之后，可以理解为加锁解锁操作中间的代码也是原子性的，必须要运行到解锁位置才能让另外一个线程&#x2F;进程执行这里的代码\n加锁的本质是让线程执行临界区的代码串行化\n\n4.3.3 加锁的注意事项\n只对临界区加锁；锁保护的就是临界区\n加锁的粒度越细越好（即加锁的区域越小越好）\n加锁是编程的一种规范；在实际问题中，我们要保证访问某一临界资源的所有操作都要加上锁。不能出现函数A加锁了，但是B没有加锁的情况（这样会导致A的加锁也没有意义）\n\n4.4 示例-倒水问题\n以倒水为示例，假设杯子容量为10000，装满了水就会溢出。我们使用多个线程对这个杯子加水，直到满了之后线程退出\n#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;signal.h&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/syscall.h&gt;using namespace std;//临界资源int water = 0;//全局变量int cup = 10000;//杯子的容量void* func(void* arg)&#123;    while(1)    &#123;        if(water&lt;cup)//临界区        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            water++;        &#125;        else        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水已经满了 &quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            break;        &#125;    &#125;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 线程退出&quot; &lt;&lt; &quot;\\n&quot;;    return (void*)0;&#125;int main()&#123;    pthread_t t1,t2,t3,t4;//创建4个线程    pthread_create(&amp;t1,nullptr,func,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func,(void*)&quot;t2&quot;);    pthread_create(&amp;t3,nullptr,func,(void*)&quot;t3&quot;);    pthread_create(&amp;t4,nullptr,func,(void*)&quot;t4&quot;);    //直接分离线程    pthread_detach(t1);    pthread_detach(t2);    pthread_detach(t3);    pthread_detach(t4);    while(1)    &#123;        ;//啥都不干    &#125;    return 0;&#125;\n\n输出的结果如下，明明水已经满了，但还是会有部分线程报告水还没有满，且数字有很严重的偏差\nt3 水没有满：9993t3 水没有满：9994t3 水没有满：9995t3 水没有满：9996t3 水没有满：9997t3 水没有满：9998t3 水没有满：9999t3 水已经满了t3 线程退出 水没有满：2723t4 水已经满了t4 线程退出0t2 水已经满了t2 线程退出t1 水没有满：9668t1 水已经满了t1 线程退出\n\n多运行几次，也能发现相同的问题\nt2 水没有满：9997t2 水没有满：9998t2 水没有满：9999t2 水已经满了 10000t2 线程退出t4 水没有满：1889t4 水已经满了 10001t4 线程退出t3 水没有满：0t3 水已经满了 10002t3 线程退出t1 水没有满：0t1 水已经满了 10003t1 线程退出\n\n4.4.1 只有一个线程在工作？除了偏差外，还有一个小问题，往前翻打印记录，会发现一直都是某一个线程在倒水，其他线程似乎啥事没有干？\nt3 水没有满：9786t3 水没有满：9787t3 水没有满：9788t3 水没有满：9789t3 水没有满：9790\n\n这是因为当运行t3的时候，t3在while循环中继续运行的消耗，小于切换到其他线程的消耗。所以控制块就让t3一直运行，直到它break退出循环\n此时我们只需要加上一个usleep，增加每一个while循环中需要处理的负担，就能让所有线程都来倒水\n//usleep功能把进程挂起一段时间， 单位是微秒（百万分之一秒）#include &lt;unistd.h&gt;int usleep(useconds_t usec);\n\n这是因为线程切换同样也是时间片到了，从内核返回用户态的时候做检测，切换至其他线程。\n添加usleep能创造更多内核&#x2F;用户的中间态，从而增多切换线程的次数\nvoid* func(void* arg)&#123;    while(1)    &#123;        if(water&lt;cup)        &#123;            usleep(100);//休息100微秒            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            water++;        &#125;        else        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水已经满了&quot; &lt;&lt; &quot;\\n&quot;;            break;        &#125;    &#125;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 线程退出&quot; &lt;&lt; &quot;\\n&quot;;    return (void*)0;&#125;\n\n但是这还是没有解决数字出错的问题\nt4 水没有满：9995t3 水没有满：9996t1 水没有满：9997t2 水没有满：9998t4 水没有满：9999t4 水已经满了 10000t4 线程退出t3 水没有满：10000t3 水已经满了 10001t3 线程退出t1 水没有满：10001t1 水已经满了 10002t1 线程退出t2 水没有满：10002t2 水已经满了 10003t2 线程退出\n\n4.4.2 加锁-问题解决这时候就需要请出我们的锁了\n//省略头文件int water = 0;//全局变量int cup = 10000;//杯子的容量pthread_mutex_t mutex;void* func(void* arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;mutex);        if(water&lt;cup)        &#123;            usleep(100);            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            water++;            pthread_mutex_unlock(&amp;mutex);            usleep(100);//假装喝水        &#125;        else        &#123;            cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水已经满了 &quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;            pthread_mutex_unlock(&amp;mutex);            //此处也需要加锁，否则break出去之后其他线程会因为没有解锁而挂起            break;        &#125;    &#125;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 线程退出&quot; &lt;&lt; &quot;\\n&quot;;    return (void*)0;&#125;// 如果遇到2号信号，就在销毁锁后退出进程void des(int signo)&#123;    //销毁锁    pthread_mutex_destroy(&amp;mutex);    cout &lt;&lt; &quot;pthread_mutex_destroy, exit&quot; &lt;&lt; endl;    exit(0);&#125;int main()&#123;    signal(SIGINT,des);//自定义捕捉2号信号    pthread_mutex_init(&amp;mutex,nullptr);//初始化锁    pthread_t t1,t2,t3,t4;//创建4个线程    pthread_create(&amp;t1,nullptr,func,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func,(void*)&quot;t2&quot;);    pthread_create(&amp;t3,nullptr,func,(void*)&quot;t3&quot;);    pthread_create(&amp;t4,nullptr,func,(void*)&quot;t4&quot;);    //直接分离线程    pthread_detach(t1);    pthread_detach(t2);    pthread_detach(t3);    pthread_detach(t4);    while(1)    &#123;        ;//啥都不干    &#125;    return 0;&#125;\n\n运行可见，数字错误问题就没有出现了；但又出现了只有一个线程工作的问题\nt1 水没有满：9996t1 水没有满：9997t1 水没有满：9998t1 水没有满：9999t1 水已经满了 10000t1 线程退出t3 水已经满了 10000t3 线程退出t4 水已经满了 10000t4 线程退出t2 水已经满了 10000t2 线程退出^Cpthread_mutex_destroy, exit\n\n这还是因为线程切换的效率问题；也有可能是因为其它线程申请锁的时候，发现t1在用，就进行了阻塞等待而挂起\n\n只需要在解锁之后添加一个usleep模拟其他工作，就能让所有线程都跑起来\npthread_mutex_lock(&amp;mutex);if(water&lt;cup)&#123;    usleep(100);    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;    water++;    pthread_mutex_unlock(&amp;mutex);    usleep(100);//假装喝水&#125;\n\n没有出现数据错误，加锁的目的成功达到！\nt1 水没有满：9993t3 水没有满：9994t4 水没有满：9995t2 水没有满：9996t1 水没有满：9997t3 水没有满：9998t4 水没有满：9999t2 水已经满了 10000t2 线程退出t1 水已经满了 10000t1 线程退出t3 水已经满了 10000t3 线程退出t4 水已经满了 10000t4 线程退出^Cpthread_mutex_destroy, exit\n\n4.5 加锁的进一步解释在这个代码示例中，我们给中间的几行代码加了锁；但这并不意味着执行中间这部分代码的时候，就不会发生线程切换\npthread_mutex_lock(&amp;mutex);//加锁if(water&lt;cup)&#123;    cout &lt;&lt; (char*)arg &lt;&lt; &quot; 水没有满：&quot; &lt;&lt; water &lt;&lt; &quot;\\n&quot;;    water++;&#125;pthread_mutex_unlock(&amp;mutex);//解锁\n\n事实上，代码执行的任何地方，都可能发生进程&#x2F;线程的切换。但因为我们加了锁，切换的时候，其他线程要来访问这里的资源，就必须先申请锁\n此时锁在被切走的进线程手上，所以其他线程无法访问临界区的资源，也就不会发生数据不一致的问题。\n\n\n换言之，只要张三拿到了锁，那么它也就不担心自己的工作会被别人覆盖的问题；\n而对其他线程而言，张三访问临界区的工作，只有还没进入临界区和访问完毕临界区两种状态\n\n因此会导致一个问题，那就是线程切换的效率较低，其他线程出现了阻塞等待的情况；为了避免此问题，我们应该让访问临界区的操作快去快回，尽量不要在临界区里面干啥耗时的事情\n4.5.1 加锁原子性的保证\n备注：这部分仅供学习参考，若有错误，还请指出！\n\n那么加锁这个操作，是如何保证其自身的原子性呢？在加锁的途中不会发生线程切换吗？\n\n我找到了一张能大概说明汇编加锁过程的图片，其中movb的操作就是将al寄存器写为0，xchgb的操作是将al寄存器的内容和内存中mutex锁的值进行交换\n\n开始的时候，锁被正常初始化，内存中mutex的值为1（锁只会被初始化一次）\n线程A开始加锁，al寄存器和mutex的值发生交换，此时内存中的mutex为0，al为1\n判断al不为0，代表获取锁成功，线程A加锁成功\n线程B也来申请锁了，movb将al寄存器写为0，再和内存中的mutex交换后，发现还是0，则代表锁在别人手上，此时就需要挂起等待\n\n前面一直强调，线程是有自己独立的栈结构和上下文数据的，在加锁的这部分汇编操作中，同样可能会在任何地方发生线程切换。切换的时候，线程的上下文数据（图中寄存器的状态）会被保留下来，随这个线程一起被切换走\n所以线程A被切换的时候，属于它上下文中那个值为1的al寄存器也被切走了（注意，这里切走的是数据，al寄存器本身作为硬件，有且只有一个）\n由此看来，真正获取锁的操作，其实只有xchgb一条交换指令来完成，保证加锁操作只由一条汇编语句实现，就能保证该操作的原子性！\n解锁的方法就很简单了，movb将1写回mutex变量即可，也是一条汇编完成；而且一般情况下，解锁是不会有执行流和你抢的。\n\n其实加锁远不止一种方法，锁的种类有非常多，还有总线锁、旋转锁等等，每一个锁的实现都不太一样！上面提到的为互斥锁\n\n4.5.2 总线锁现在的CPU一般都有自己的内部缓存，根据一些规则将内存中的数据读取到内部缓存中来，以加快频繁读取的速度。现在服务器通常是多 CPU，更普遍的是，每块CPU里有多个内核，而每个内核都维护了自己的缓存，那么这时候多线程并发就会存在缓存不一致性，这会导致严重问题。\n\n总线锁就是将cpu和内存之间的通信锁住，使得在锁定期间，其他cpu处理器不能操作其他内存中数据，故总线锁开销比较大！\n总线锁的实现是采用cpu提供的LOCK#信号，当一个cpu在总线上输出此信号时，其他cpu的请求将被阻塞，那么该cpu则独占共享内存，相当于锁住了\n\n何为总线？\n\nCPU总线是所有CPU与芯片组连接的主干道，负责CPU与外界所有部件的通信，包括高速缓存、内存、北桥，其控制总线向各个部件发送控制信号、通过地址总线发送地址信号指定其要访问的部件、通过数据总线双向传输\n\n5.死锁死锁就是一种因为两放都不会释放对方需要的资源，从而陷入的永久等待状态\n5.1 死锁情况演示举个例子，张三拿了锁A，申请锁B的时候，发现锁B无法申请，而进入等待；李四拿了锁B，接下来他想申请锁A，结果发现张三拿着锁A，那就只能进入等待。这就陷入了一个僵局，张三想要李四的，李四想要张三的，谁都不让谁\n#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;signal.h&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/syscall.h&gt;using namespace std;pthread_mutex_t m1;//锁1pthread_mutex_t m2;//锁2void* func1(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m1);        pthread_mutex_lock(&amp;m2);        cout &lt;&lt; &quot;func1 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;void* func2(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m2);        pthread_mutex_lock(&amp;m1);        cout &lt;&lt; &quot;func2 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;int main()&#123;    pthread_mutex_init(&amp;m1,nullptr);    pthread_mutex_init(&amp;m2,nullptr);    pthread_t t1,t2;    pthread_create(&amp;t1,nullptr,func1,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func2,(void*)&quot;t2&quot;);    //分离    pthread_detach(t1);    pthread_detach(t2);    while(1)    &#123;        cout &lt;&lt; &quot;main running...&quot; &lt;&lt;endl;        sleep(1);    &#125;    pthread_mutex_destroy(&amp;m1);    pthread_mutex_destroy(&amp;m2);    return 0;&#125;\n\n上面的这个代码便能模拟出这个情况，线程1先要了锁1，再要锁2；线程2先要锁2再要锁1，他们俩就容易打起来，造成死锁。\n运行代码的时候我们却发现，似乎并不是这样的，线程1好像还是成功拿到了俩把锁，并运行了起来\n[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./testmain running...func1 is running... t1func1 is running... t1main running...func1 is running... t1main running...func1 is running... t1main running...\n\n那是因为我们没有执行其他一些工作，从而将线程1和2申请锁的时间错开\n将代码改成下面这样，利用usleep让两个线程休眠不同时间，结果就不同了\nvoid* func1(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m1);        usleep(200);        pthread_mutex_lock(&amp;m2);        cout &lt;&lt; &quot;func1 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;void* func2(void*arg)&#123;    while(1)    &#123;        pthread_mutex_lock(&amp;m2);        usleep(300);        pthread_mutex_lock(&amp;m1);        cout &lt;&lt; &quot;func2 is running... &quot; &lt;&lt;(const char*)arg&lt;&lt;endl;        pthread_mutex_unlock(&amp;m1);        pthread_mutex_unlock(&amp;m2);    &#125;&#125;\n\n可以看到，此时只有主线程在运行，线程t1和t2出现了死锁！\n[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./testmain running...main running...main running...main running...\n\n\n5.2 死锁的条件\n互斥条件：某份资源同一时间只能由一个执行流访问\n请求与保持：一个执行流因请求某种资源进入阻塞等待，而不释放自己的资源（好比上面代码例子中两个线程都不释放自己的锁，又想要别人的锁）\n不剥夺条件：一个执行流已获得的资源，在未使用之前不能被剥夺（部分锁是允许被剥夺的）\n循环等待：若干执行流之间形成一种头尾相接的循环等待资源的状态\n\n一把锁也能造成死锁吗？答案是肯定的！\npthread_mutex_lock(&amp;m1);pthread_mutex_lock(&amp;m1);//两次申请同一把锁\n\n如果有人写出这种bug代码，那就会出现一把锁把自己死锁了；死锁本来就是代码的bug，所以这种低级错误也是死锁的情况之一😂\n5.3 避免死锁避免死锁，其中最简单明了的办法，就是破坏上面提到的死锁的4个条件；其中互斥条件没啥好办法破坏（除非你不加锁），更主要的是看另外3个条件是否能破坏！\n\n保持加锁顺序一致：不要出现上面代码中的线程a先申请锁1，线程b先申请锁2的情况。在不同的执行流中，按相同的顺序申请锁（比如线程a和b都是按锁1&#x2F;2的顺序申请的）一定程度上能破坏请求与保持条件\n降低加锁的粒度：锁保护的区域变小，加锁的粒度减小，能一定程度上避免锁未释放\n资源一次性分配：减少临时资源分开给的情况\n允许抢占：线程之间依靠优先级抢夺锁，这种情况就是锁允许被剥夺\n\n\n6.线程安全线程安全：多个线程并发执行同一段代码的时候，不会出现不同的结果\n线程不安全的情况：\n\n不保护临界资源\n在多线程操作中调用不可重入函数（概念见linux信号部分）\n返回指向静态变量的指针的函数\n\n线程安全：\n\n每个线程只操作局部变量，或者只对全局、静态变量只读不写\n接口对线程来说是原子操作（被锁保护）\n多个线程切换不会使函数接口的结果出现二义性\n多线程操作不调用不可重入函数\n\n注意，绝大多数的系统自带的库（比如C++的STL库）都是不可重入的\n\n不可重入是函数的一种性质，并不是它的缺点！如果一个库函数明明告知你了我是不可重入的，你还不加保护的在多线程操作中调用它，那么这段代码是有bug的，并不是库函数本身有问题\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】线程概念 | 同步","url":"/2022/12/30/code/note_Linux/20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/","content":"除了线程互斥，我们还有线程同步，来康康吧\n\n\n[TOC]\n1.为什么需要同步在部分条件下，互斥是正确的，但是不合理。比如食堂打饭的时候，食堂阿姨一次只能给一个人打饭，于是就选择通过竞争来获得打饭的权利。此时就会出现有些线程因为优先级过低或者CPU调度问题，一直打不到饭，于是就出现了饥饿问题。\n这是因为我们对多线程访问同一个资源没有进行限制，全靠CPU调度来决定运行顺序；所以我们需要对线程进行一定的控制，这就是线程同步的概念\n\n饥饿问题：某一个线程一直无法申请到某种资源（比如因为优先级过低）\n同步：保证数据安全（临界资源访问）的前提下，让线程根据一定条件和顺序访问临界资源，从而避免饥饿问题\n竞态条件：因为时序问题（CPU调度）而导致程序异常；\n\n2.生产消费模型这个模型其实很简单，消费者去超市购买东西，生产者把商品投放到超市中。\n\n这时候就不需要消费者直接去找工厂问他xx东西又没有生产，他需要购买；而是转去超市里面购买xx东西；\n如果xx东西没有货了，超市就会通知生产者进行补货。如果超市里面的货架已经满了，就通知生产者不需要继续生产了；\n当商品没货了，超市会告知消费者这个东西没货，消费者会停止消费行为；而生产者补货了之后，超市就会通知消费者让他来购买\n\n\n在基础模式中，消费者要想知道一个东西有没有货，需要去超市里面看（相当于轮循检测）\n我们可以引入一个通知方式，比如超市开放一个微信公众号，告知消费者xx物品是否有货，以及告知消费者什么时候需要补货，此时就不需要消费者和生产者不断询问超市关于一个商品的情况了！这就相当于线程同步！\n2.1 生产者和消费者的关系下面提到的是普适情况\n\n消费者有多个，他们之间是竞争关系（互斥）竞争商品的购买\n生产者有多个，他们之间是竞争关系（互斥）竞争超市的货架\n消费者和生产者之间，既有互斥关系，也是同步关系（需要生产者供货了之后，消费者才能消费）这两个关系并不冲突！\n\n除了上面提到的3种生产关系，还有下面俩点\n在实际程序中，消费者和生产者都是由线程承担的（2种角色）\n超市是内存中特定的一个数据结构，也是临界资源（1个交易场所）\n\n我们可以用321原则来快速记住这几条，这样就记住了生产消费模型！👍\n\n2.2 以简单代码为例在旧模式中，main函数调用另外一个函数，想获得返回值，需要等这个函数运行完毕；好比消费者购买东西，需要去找厂家并等待厂家生产……\n\n而在生产消费者模型中，main作为主线程，只需要把待处理的数据丢进缓冲区；而线程B从缓冲区中取出数据，处理完毕后放回缓冲区。main可以先执行其他代码，过一会再过来拿线程B处理好的结果。\n这就实现了生产和消费的解耦！\n\n\n接下来我们就要解决下面这些问题😁\n1.如何让多个消费者线程等待呢?又如何让消费者线程被唤醒呢?2.如何让多个生产者线程等待呢?又如何让生产者线程被唤醒呢?3.如何衡量消费者和生产者所关心的条件是否就绪呢?\n\n而前面提到的通知方式，在linux系统中，就是条件变量了！\n3.条件变量接口3.1 init&#x2F;destroy基本的接口和pthread库的其他接口很相似，都是一样的用法；其中attr也是设置条件变量的属性，这里置为nullptr即可\n#include &lt;pthread.h&gt;int pthread_cond_destroy(pthread_cond_t *cond);int pthread_cond_init(pthread_cond_t *restrict cond,                      const pthread_condattr_t *restrict attr);pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\n3.2 pthread_cond_wait这两个接口都是让线程在一个条件变量下进行等待，其中timewait接口可以设置等待的时间（超时了就不等了）\n条件变量也是临界资源，所以这里需要一个mutex锁来保证条件变量读写的原子性\n#include &lt;pthread.h&gt;int pthread_cond_timedwait(pthread_cond_t *restrict cond,                           pthread_mutex_t *restrict mutex,                           const struct timespec *restrict abstime);int pthread_cond_wait(pthread_cond_t *restrict cond,                      pthread_mutex_t *restrict mutex);\n\n3.3 pthrea_cond_signal&#x2F;broadcast这个接口的作用是给在条件变量下等待的线程发信号\n#include &lt;pthread.h&gt;int pthread_cond_broadcast(pthread_cond_t *cond);int pthread_cond_signal(pthread_cond_t *cond);\n\n其中broadcast是给在当前条件变量等待的所有线程发信号，而signal是发送信号，只唤醒一个线程；\n如果调用成功，这两个函数都会返回0；否则返回错误码\nRETURN VALUE       If  successful, the pthread_cond_broadcast() and pthread_cond_signal() functions shall return zero; otherwise, an error number shall       be returned to indicate the error.\n\n3.4 代码示例下面这个代码可以很好的演示上面提到的多个接口\n#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;signal.h&gt;#include&lt;pthread.h&gt;#include&lt;thread&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/syscall.h&gt;using namespace std;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//锁pthread_cond_t cond;//条件变量volatile bool quit = false;void*func(void* arg)&#123;    while(!quit)//这里有bug，后续会提到    &#123;        pthread_cond_wait(&amp;cond,&amp;mutex);        cout &lt;&lt; &quot;thread is running... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;thread quit... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;&#125;int main()&#123;    pthread_cond_init(&amp;cond,nullptr);    pthread_t t1,t2,t3;    pthread_create(&amp;t1,nullptr,func,(void*)&quot;t1&quot;);    pthread_create(&amp;t2,nullptr,func,(void*)&quot;t2&quot;);    pthread_create(&amp;t3,nullptr,func,(void*)&quot;t3&quot;);    char c;    while(1)    &#123;        cout &lt;&lt; &quot;[a/b]$ &quot;;        cin &gt;&gt; c;        if(c==&#x27;a&#x27;)        &#123;            pthread_cond_signal(&amp;cond);        &#125;        else if(c==&#x27;b&#x27;)        &#123;            pthread_cond_broadcast(&amp;cond);        &#125;        else        &#123;            quit = true;            break;        &#125;        usleep(500);    &#125;    cout &lt;&lt; &quot;main break: &quot; &lt;&lt; quit &lt;&lt; endl;    sleep(1);    pthread_cond_broadcast(&amp;cond);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);    pthread_join(t3,nullptr);    return 0;&#125;\n\n每次输入a，就signal会唤醒一个线程；每次输入b，会调用broadcast，唤醒当前所有线程\n[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test[a/b]$ athread is running... t1[a/b]$ athread is running... t2[a/b]$ athread is running... t3[a/b]$ bthread is running... t1thread is running... t2thread is running... t3\n\n3.4.1 小bug上面的代码示例，会出现下面的问题，即我们输入除了a和b以外的所有字符，都应该会把全局变量quit改成true，让三个线程都退出\n但观察到的现象却是只有一个线程退出了，其他线程阻塞等待了\n[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test[a/b]$ qmain break: 1thread is running... t3thread quit... t3\n\n这是因为pthread_cond_wait里面进行了独特的操作，即等待之前，它会释放锁，等待之后，他会重新申请锁\nint pthread_cond_wait(pthread_cond_t *restrict cond,                      pthread_mutex_t *restrict mutex)&#123;\tpthread_mutex_unlock(mutex);//先解锁    //避免因为该线程拿着锁去休眠了，导致其他线程无法申请该锁    \t//条件变量相关代码\t    pthread_mutex_lock(mutex);//条件满足后，再加锁&#125;\n\n第一个退出的线程，退出之前申请了锁却没有释放，于是就导致其他线程在条件满足后，没有办法申请锁，只能阻塞等待！\n3.4.2 修正修正的方法很简单，我们只需要在while(!quit)循环的退出条件满足之后，释放一下锁，就OK了！\nvoid*func(void* arg)&#123;    while(!quit)    &#123;        pthread_cond_wait(&amp;cond,&amp;mutex);        cout &lt;&lt; &quot;thread is running... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;            &#125;    pthread_mutex_unlock(&amp;mutex);//正确操作：需要在条件满足后，解锁    cout &lt;&lt; &quot;thread quit... &quot; &lt;&lt; (char*)arg &lt;&lt; endl;&#125;\n\n此时就能看到，所有线程都正常退出了！\n[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$ ./test[a/b]$ qmain break: 1thread is running... t1thread quit... t1thread is running... t2thread quit... t2thread is running... t3thread quit... t3[muxue@bt-7274:~/git/linux/code/22-12-25_线程同步]$\n\n3.4.3 典型错误根据这点，就能引出一个比较典型的错误\npthread_mutex_lock(&amp;mutex);while (condition_is_false) &#123;    pthread_mutex_unlock(&amp;mutex);    pthread_cond_wait(&amp;cond);//解锁和加锁的操作，该函数会帮我们完成    pthread_mutex_lock(&amp;mutex);//二次申请同一把锁，出现死锁！&#125;pthread_mutex_unlock(&amp;mutex);\n\n两次申请同一把锁，就好比自己把自己绊倒了😂我们要避免写出这样的错误代码！\n\n4.阻塞队列-生产消费模型实例这个队列的作用，就是提供一个超市，供生产者和消费者进行数据的交换\n\n生产者，往队列里面push数据\n消费者，从队列里面pop数据\n\n看起来有些类似于管道，同样的，生产者和消费者在读取阻塞队列的时候，不仅需要保证自己的操作是原子操作，还需要做到一定的访问控制；即消费者在队列空的时候不能继续pop，生产者在队列满的时候不能继续push\n此时，我们还可以引入一个微信公众号，也就是一定的通知方式：不要让生产者、消费者疯狂检测阻塞队列，而是引入条件变量，在队列不为空的时候，通知消费者；在队列不为满的时候，通知生产者；这样就达到了线程之间的同步。\n4.1 成员变量要实现阻塞队列，我们首先需要理清楚需要什么成员变量，来保护该队列\n\n用于访问控制的锁，同一时刻只能有一个线程访问队列\n用户线程同步的条件变量，因为我们需要在不同的条件下通知不同的人，所以需要2个条件变量\n一个队列，为了方便，采用std::queue，这样就不用自己造轮子了\n\n理清楚了之后，就可以来写成员变量啦；我采用了模板类型，这样阻塞队列就可以用来存放任何我们想要的类型了\ntemplate&lt;class T&gt;class BlockQueue&#123;private:    queue&lt;T&gt; _bq;//队列    size_t _size;//大小    pthread_mutex_t _mutex;//锁    pthread_cond_t _proInf;//通知生产者    pthread_cond_t _conInf;//通知消费者public:    BlockQueue(int sz=5)        :_size(sz)    &#123;        pthread_mutex_init(&amp;_mutex,nullptr);        pthread_cond_init(&amp;_proInf,nullptr);        pthread_cond_init(&amp;_conInf,nullptr);    &#125;    ~BlockQueue()    &#123;        pthread_mutex_destroy(&amp;_mutex);        pthread_cond_destroy(&amp;_proInf);        pthread_cond_destroy(&amp;_conInf);    &#125;&#125;;\n\n你可能想问，queue不是有封装size吗？哪这里我们还定义一个大小变量，会不会有些多余？\nnope！实际上，这里的这个_size 就好比我们在C语言写顺序表的时候，成员capacity；其作用是来判断我们的队列有没有满的。\n\n4.2 push和pop对于一个队列，最重要的操作就是在队头出数据，队尾入数据\n简单说来，就是需要在处理队列数据的时候进行加锁，保证原子性；\n除此以外，生产者和消费者有不同的操作逻辑：\n\n生产\n判断是否符合生产条件（队列没有满）\n满，不生产；不满，生产；\n满了的时候，生产者应在条件变量中等待（等待消费者消费）\n不满的时候，生产者生产，并通知消费者来消费\n\n\n消费\n判断是否满足消费条件（队列不为空）\n空，不消费；不空，消费；\n空了的时候，消费者应该在条件变量中等待（等待生产者生产）\n不空的时候，消费者消费，并通知生产者继续生产\n\n\n\n这样就实现了阻塞队列push和pop的基本逻辑；由此可以写出下面的代码\n//消费者消费T pop()&#123;    //加锁    pthread_mutex_lock(&amp;_mutex);    //判断条件    if(_size)//空，不消费    &#123;        pthread_cond_wait(&amp;_conInf,&amp;_mutex);    &#125;    //消费并通知生产者    T tmp = _bq.front();    _bq.pop();    pthread_cond_signal(&amp;_proInf);    //解锁    pthread_mutex_unlock(&amp;_mutex);    return tmp;&#125;//生产者生产void Push(const T&amp; in)&#123;    //加锁    pthread_mutex_lock(&amp;_mutex);    //判断条件    if(bq.size()&gt;=_size)//满，不生产    &#123;        pthread_cond_wait(&amp;_proInf,&amp;_mutex);    &#125;    //生产并通知消费者    _bq.push(in);    pthread_cond_signal(&amp;_conInf);    //解锁    pthread_mutex_unlock(&amp;_mutex);&#125;\n\n4.2.1 运行测试有了这个基本框架，我们就可以来测试一下代码啦！\n先来一个生产者和消费者康康吧\n#include &quot;blockqueue.hpp&quot;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;void *consume(void *args)&#123;    BlockQueue&lt;int&gt; *bqp = (BlockQueue&lt;int&gt; *)args;    while(1)    &#123;        // 消费        int ret = bqp-&gt;pop();        cout &lt;&lt; &quot;consume &quot; &lt;&lt; pthread_self() &lt;&lt; &quot; 消费：&quot; &lt;&lt; ret &lt;&lt; endl;        sleep(1);    &#125;&#125;void *produce(void *args)&#123;    BlockQueue&lt;int&gt; *bqp = (BlockQueue&lt;int&gt; *)args;    while (1)    &#123;        // 制作        cout &lt;&lt; &quot;########↓&quot; &lt;&lt; endl;        int a = rand()%100;        // 投放到超市        bqp-&gt;push(a);        cout &lt;&lt; &quot;produce &quot; &lt;&lt; pthread_self() &lt;&lt; &quot; 生产：&quot; &lt;&lt; a &lt;&lt; endl;        sleep(2);    &#125;&#125;int main()&#123;    srand((unsigned int)time(nullptr));    pthread_t t1,t2;    BlockQueue&lt;int&gt; bq(5);    pthread_create(&amp;t1,nullptr,produce,(void*)&amp;bq);    pthread_create(&amp;t2,nullptr,consume,(void*)&amp;bq);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);    return 0;&#125;\n\n可以看到，刚开始消费者并没有运行，而是等待生产者生产出数据了之后，再开始消费！我们的目的成功达成！\n[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./test########↓produce 139716365768448 生产：41########↓produce 139716365768448 生产：11consume 139716357375744 消费：41########↓produce 139716365768448 生产：19consume 139716357375744 消费：11########↓produce 139716365768448 生产：19consume 139716357375744 消费：19########↓produce 139716365768448 生产：25consume 139716357375744 消费：19########↓produce 139716365768448 生产：63consume 139716357375744 消费：25\n\n如果增加线程到2生产2消费，则会看到下面的情况\n[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./test########↓produce 140483816179456 生产：51consume 140483807786752 消费：51########↓produce 140483799394048 生产：38consume 140483791001344 消费：38########↓produce 140483816179456 生产：37consume 140483807786752 消费：37\n\n每次被唤醒的生产者和消费者都是不一样的，交替唤醒\n4.2.2 进一步封装为了代码的可读性，我们可以对阻塞队列进一步封装\n#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;using namespace std;template&lt;class T&gt;class BlockQueue&#123;private:    queue&lt;T&gt; _bq;//队列    size_t _size;//大小    pthread_mutex_t _mutex;//锁    pthread_cond_t _proInf;//通知生产者    pthread_cond_t _conInf;//通知消费者public:    BlockQueue(int sz=5)        :_size(sz)    &#123;        pthread_mutex_init(&amp;_mutex,nullptr);        pthread_cond_init(&amp;_proInf,nullptr);        pthread_cond_init(&amp;_conInf,nullptr);    &#125;    ~BlockQueue()    &#123;        pthread_mutex_destroy(&amp;_mutex);        pthread_cond_destroy(&amp;_proInf);        pthread_cond_destroy(&amp;_conInf);    &#125;    //消费者消费    T pop()    &#123;        //加锁        lock();        //判断条件        if(isEmpty())//空，不消费        &#123;            ConWait();        &#125;        //消费并通知生产者        T tmp = _bq.front();        _bq.pop();        WakeUpPro();        //解锁        unlock();        return tmp;    &#125;    //生产者生产    void push(const T&amp; in)    &#123;        //加锁        lock();        //判断条件        if(isFull())//满，不生产        &#123;            ProWait();        &#125;        //生产并通知消费者        _bq.push(in);        WakeUpCon();        //解锁        unlock();    &#125;private:    void lock()    &#123;        pthread_mutex_lock(&amp;_mutex);    &#125;    void unlock()    &#123;        pthread_mutex_unlock(&amp;_mutex);    &#125;    //唤醒消费者    void WakeUpCon()    &#123;        pthread_cond_signal(&amp;_conInf);    &#125;    //唤醒生产者    void WakeUpPro()    &#123;        pthread_cond_signal(&amp;_proInf);    &#125;    //消费者等待    void ConWait()    &#123;        pthread_cond_wait(&amp;_conInf,&amp;_mutex);    &#125;    //生产者等待    void ProWait()    &#123;        pthread_cond_wait(&amp;_proInf,&amp;_mutex);    &#125;    //判断条件    bool isFull()    &#123;        return _size == _bq.size();    &#125;    bool isEmpty()    &#123;        return _bq.empty();    &#125;&#125;;\n\n4.2.3 使用task分配运算任务因为阻塞队列是用模板类型的，我们可以自己实现一个仿函数，来给生产者消费者分配任务\n#pragma once#include &lt;iostream&gt;using namespace std;class Task&#123;public:    Task(int one=0, int two=0, char op=&quot;+&quot;)         : _elem1(one), _elem2(two), _operator(op)    &#123;&#125;    // 仿函数    int operator() ()    &#123;        return run();    &#125;    // 运行仿函数    int run()    &#123;        int result = 0;        switch (_operator)        &#123;        case &#x27;+&#x27;:            result = _elem1 + _elem2;            break;        case &#x27;-&#x27;:            result = _elem1 - _elem2;            break;        case &#x27;*&#x27;:            result = _elem1 * _elem2;            break;        case &#x27;/&#x27;:        &#123;            if (_elem2 == 0)            &#123;                cout &lt;&lt; &quot;div zero, abort&quot; &lt;&lt; endl;                result = -1;            &#125;            else            &#123;                result = _elem1 / _elem2;            &#125;            break;        &#125;         case &#x27;%&#x27;:        &#123;            if (_elem2 == 0)            &#123;                cout &lt;&lt; &quot;mod zero, abort&quot; &lt;&lt; endl;                result = -1;            &#125;            else            &#123;                result = _elem1 % _elem2;            &#125;            break;        &#125;        default:            cout &lt;&lt; &quot;unknown: &quot; &lt;&lt; _operator &lt;&lt; endl;            break;        &#125;        return result;    &#125;    // 获取元素，方便打印    void get(int *e1, int *e2, char *op)    &#123;        *e1 = _elem1;        *e2 = _elem2;        *op = _operator;    &#125;private:    int _elem1;    int _elem2;    char _operator;&#125;;\n\n测试一下\n#include &quot;blockqueue.hpp&quot;#include &quot;task.hpp&quot;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;string&gt;string ops =&quot;+-*/%&quot;;void *consumer(void *args)&#123;    BlockQueue&lt;Task&gt; *bqp = (BlockQueue&lt;Task&gt; *)args;    while (1)    &#123;        Task t = bqp-&gt;pop();        int result = t();    //处理任务        int one, two;        char op;        t.get(&amp;one, &amp;two, &amp;op);        cout &lt;&lt; &quot;consumer [&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 消费了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = &quot; &lt;&lt; result &lt;&lt; endl;    &#125;&#125;void *producer(void *args)&#123;    BlockQueue&lt;Task&gt; *bqp = (BlockQueue&lt;Task&gt; *)args;    while (1)    &#123;        // 制作任务        int one = rand() % 50;        int two = rand() % 20;        char op = ops[rand() % ops.size()];        Task t(one, two, op);        // 投放给消费者生产        bqp-&gt;push(t);        cout &lt;&lt; &quot;producter[&quot; &lt;&lt; pthread_self() &lt;&lt; &quot;] &quot; &lt;&lt; (unsigned long)time(nullptr) &lt;&lt; &quot; 生产了一个任务: &quot; &lt;&lt; one &lt;&lt; op &lt;&lt; two &lt;&lt; &quot; = ?&quot; &lt;&lt; endl;        sleep(1);    &#125;&#125;void test2()&#123;    pthread_t t1,t2;    BlockQueue&lt;Task&gt; bq(5);    pthread_create(&amp;t1,nullptr,producer,(void*)&amp;bq);    sleep(1);    pthread_create(&amp;t2,nullptr,consumer,(void*)&amp;bq);    pthread_join(t1,nullptr);    pthread_join(t2,nullptr);&#125;int main()&#123;    srand((unsigned long)time(nullptr));//乘一个数字添加随机性    test2();    return 0;&#125;\n\n运行，可以看到生产者生产了问题之后，消费者会去解答。此时我们只需要在线程中取回运算好的结果，就OK了！\n[muxue@bt-7274:~/git/linux/code/23-01-08 blockqueue]$ ./testproducter[140703422265088] 1673319321 生产了一个任务: 43-16 = ?consumer [140703413872384] 1673319322 消费了一个任务: 43-16 = 27producter[140703422265088] 1673319322 生产了一个任务: 45/12 = ?consumer [140703413872384] 1673319322 消费了一个任务: 45/12 = 3producter[140703422265088] 1673319323 生产了一个任务: 17/7 = ?consumer [140703413872384] 1673319323 消费了一个任务: 17/7 = 2producter[140703422265088] 1673319324 生产了一个任务: 49-14 = ?consumer [140703413872384] 1673319324 消费了一个任务: 49-14 = 35producter[140703422265088] 1673319325 生产了一个任务: 4%4 = ?consumer [140703413872384] 1673319325 消费了一个任务: 4%4 = 0\n\n\n","categories":["玩上Linux"],"tags":["Linux","线程"]},{"title":"【Linux】tar命令打包 | 查看压缩文件 | 打包时忽略文件","url":"/2023/01/16/code/note_Linux/21tar%E5%8E%8B%E7%BC%A9/","content":"tar命令打包 | 查看压缩文件 | 打包时忽略文件 等操作\n\n\n1.起因今天下午写阿狸bot的代码的时候，写错了aiofiles的保存操作\n# 正确写法async def write_file_aio(path:str, value):    async with aiofiles.open(path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:        await f.write(json.dumps(value, indent=2, sort_keys=True,ensure_ascii=False))        # 错误写法# 前面是一样的await f.write(json.dump(value, indent=2, sort_keys=True,ensure_ascii=False))\n\n注意这两个函数，一个是json.dump；一个是json.dumps\n就是因为这里写错了，导致bot执行全局变量保存的时候，所有文件都没有成功保存——还直接把本地文件清空了！！！\n\n当时的我是真的欲哭无泪啊，都不知道如何是好\n\nvscode的时间线功能帮我保存了一部分文件，可是绝大部分文件都是程序生成的，没有经过vscode，其自然也就没有保存历史版本，这可给我整难受了\n\n\n要不是之前有一个val-bot-test目录用于代码测试，那就几乎等同于阿狸bot的用户信息全部丢失，最最最最难受的，还是我bot记录了好久的服务器日志啊，本来有3w多cmd的，现在恢复的文件还是几个月前的，数据量少了好多……\n\n唉，不说这些玩意了，今天我们要来康康怎么在linux下用tar命令打包和压缩文件夹，留作备份！\n2.tar命令打包参考 https://blog.csdn.net/catoop/article/details/40651947\n2.1 将整个目录打包以当前目录下的code文件夹为例\ntar -cvf ./code.tar ./code #仅打包不压缩tar -zcvf ./code.tar.gz ./code #打包，gzip压缩tar -jcvf ./code.tar.bz2 ./code #打包，bzip2压缩\n\n注意，这里的./code.tar是生成的目标文件，./code是源路径；目标文件的命名没有要求，命名成tar.gz/tar.bz2只是一个用于标明的好习惯\n2.2 查看压缩包里面的文件下面的命令是分别查看不同压缩格式的压缩包里面的文件目录的，其会直接在bash打印出来\ntar -tvf ./code.tar tar -ztvf ./code.tar.gz tar -jtvf ./code.tar.bz2 \n\n2.3 解压文件解压的文件会默认存在当前目录\ntar -xvf ./code.tar tar -zxvf ./code.tar.gz tar -jxvf ./code.tar.bz2 \n\n2.4 解压一部分文件假设我们需要解压code.tar里面test目录的文件，可以用下面的命令\ntar -xvf ./code.tar test\n\n知道这几个用法，就基本够用了！\n2.5 打包的时候忽略一些文件现在我需要压缩的是code里面的python运行代码，其中会有一个没有用的__pycache_，我们应该将其忽略，以减小压缩包体积\n下面的命令就是忽略code路径下所有__pycache__文件或者文件目录\ntar -zcvf code.tar.gz --exclude=*__pycache__ code\n\n注意，忽略的路径后面不需要带/，否则还是会被打包。比如下面的用法就是错的\ntar -zcvf code.tar.gz --exclude=*__pycache__/ code #错误\n\n3.一定要多多备份像我今天出现这样的情况，实在是不应该！\n阿狸bot是有vip业务的，vip信息文件的丢失，也很有可能会导致vip用户的丢失。更别提还有广大的普通用户在使用阿狸呢。\n平时我知道要在云盘、nas备份自己的代码、笔记、学习资料等等个人文件，却忘记了云服务器上的bot同样需要备份\n\n这下可算是吸取教训了，一次性把所有bot都给备份了！\n","categories":["玩上Linux"],"tags":["Linux","阿狸开发日志","Python"]},{"title":"【Git】如何同步Gitee和Github的仓库（超简单）","url":"/2022/06/19/code/note_Linux/2%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5gitee%E5%92%8Cgithub%E4%BB%93%E5%BA%93%EF%BC%88%E8%B6%85%E7%AE%80%E5%8D%95%EF%BC%89/","content":"本篇博客的设置方法同样可以适用于gitlab等其他平台\n不多bb，直入主题⏲\n\n\n实现两个仓库的同步1.准备两个仓库分别在两个平台创建一个相同名字的仓库，当然，你也可以在a平台上导入b平台已有的仓库，github和gitee目前都支持从别的平台导入仓库\n这部分操作想必大家都会，就不演示了\n2.克隆到本地需要注意的是，你要保证其中一个是主仓库。如果是多人合作仓库的话，想两个平台的远程仓库同时多人合作并保持同步是相对困难的。\n\nhttps://gitee.com/ewait/LetsOJ\n\n\n以我创立的这个多人OJ打卡仓库为例，现在我想得到的效果是，我和朋友们在gitee上面进行打卡协作，然后我通过git操作将这个仓库同步到github上面，仅供展示\n\n当然如果有小伙伴愿意用github进行fork和pull request操作那我也是举双手双脚赞同+欢迎的\n\n需要做的是，既然gitee是主战场，那就对gitee进行克隆操作\ngit clone https://gitee.com/ewait/LetsOJ.git\n\n\n3.设置第二个仓库的url克隆完毕后，直接进入该仓库的.git文件夹，修改config文件\n\n在原本gitee的url后面，添加github的仓库url\n\n执行git remote -v，你可以看到github链接的仓库也显示了出来，后面带有push后缀，代表我们只能往这个仓库上传，并不能执行git pull操作\n\n这时候的设置已经完成了，你可以进行一次修改文件后的git push操作，两个仓库都可以同步！而且上传的编号都是相同的！\n\n\n这时候的基本设置就已经完毕了！如果你还想做到能从github仓库中进行pull操作，那就接着往下看\n4.关于pull操作前面提到，github仓库的url后面有一个push后缀，代表我们不能从这个仓库里面获取更新\n你如果修改了github的仓库，执行git pull操作，会显示Already up-to-date.因为系统检索的是gitee仓库的修改，并不知道你的github仓库有无修改\n\n这时候可以执行下面的语句\ngit remote add github git@github.com:Aewait/Lets_OJ.git\n\n再次git remote -v，可以看到在远程仓库中多出来了一个github为名字的仓库类型，而且这一次的仓库是可以fetch也就是获取内容的\n\n这时候你可以执行\ngit pull github\n\n即可获取github仓库的最新更新\n这样就实现了gitee仓库和github仓库的多端同步啦！\n5.效果演示现在我让朋友在gitee的仓库中上传一个内容\n\n执行git pull，可以看到系统从gitee的仓库中更新了内容\n\n这时候你执行git status，理论上来说会出现新文件对吧？并不会\n\n毕竟这时候系统检查的还是gitee主仓库，内容都是完全同步的\n我们也不需要写git add和git commit，直接执行git push即可！\n\n再打开github瞅瞅，你会发现已经同步成功了！\n\n\n提醒强烈建议：如果是多人合作仓库，请确保在某一个平台作为主战场，另外一个平台仅作展示（留档）使用！\n不过我发现了一个好事，那就是当我从gitee导入这个仓库到github的时候，github不仅会自动同步小绿点，还会将这个仓库的协作者同样显示出来（前提是协作者在github上面有同邮箱注册的账户）\n\n一些问题的解决1.关于github克隆网络访问问题关于克隆&#x2F;上传github问题，很多都是因为使用https链接导致的\n我们需要使用ssh私钥来实现github仓库的免密操作\nssh-keygen -t rsa -C &quot;你的gitee/github账户邮箱&quot;\n\ncd进入.ssh隐藏文件夹，找到生成的密钥pub文件\ncat查看该文件里面的内容，将其复制\n在github&#x2F;gitee的个人设置页面，你都能找到ssh密钥的添加处\n\n\n添加ssh密钥后，你就可以通过ssh链接来对github进行操作了，这时候一般就不会出现网络问题了！\n2……还没遇到……😂\n结语关于这项操作，网络上有很多相似内容，但总有些货不对板，不符合我的需求。所以就自己写了个博客\n有任何问题都可以在评论区提出！\n","categories":["玩上Linux"],"tags":["Linux","git"]},{"title":"【Linux】修改腾讯云轻量应用服务器的hostname","url":"/2022/05/13/code/note_Linux/3%E4%BF%AE%E6%94%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84hostname/","content":"今天想修改云主机的hostname，但是腾讯云的控制台里面好像不能直接改这个名字\n需要在root用户里面修改！\n\n\n\n参考https://cloud.tencent.com/developer/article/1190061\n\n\n修改前：修改后：\n1.查看当前的主机名称hostname\n\n2 .临时修改主机名称不建议使用，重启之后又会还原\n//hostname 主机名称hostname XXX\n\n3.永久修改主机名称//hostnamectl set-hostname 主机名称hostnamectl set-hostname XXX\n\n4.重启服务重启后效果就出现了\nreboot\n谢谢你，BT7274\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】权限管理","url":"/2022/07/13/code/note_Linux/5linux%E6%9D%83%E9%99%90/","content":"Linux部分的内容，我以权限管理作为起始。\n\n\n关于Linux命令行操作的部分，大家可以去网上搜搜，教程很多，且全面：【链接】。这里我就不再把相同的东西复述一遍了，毕竟Linux命令这种东西，你不会的时候可以去查，常见的命令敲多了肯定忘不掉\n不多说，开始Linux权限操作的内容吧！\n\n本篇博客所有演示均在CentOS7.6下进行\n\n\n[TOC]\n1.什么是权限？权限是用于对用户进行约束的。正好比视频网站的vip一样，没有vip权限，你就看不到只有vip才能观看的影片。\n1.1 root和user在linux中，用户分为两种\n\nroot：超级用户\n其他：普通用户\n\n其中root用户的权限最高，可以在系统里面为所欲为。其所作操作在一定程度上会影响用户的使用环境。比如你在root里面安装了某个程序，那么所有子用户都可以使用这个程序，反之不行。\n在root用户中，你还可以通过su user这个命令切换到任何子用户而不用输入密码。但是从子用户切换到root则需要输入root用户的密码。所以，保证你的root用户密码不被他人知道是很重要的！\n\n2.权限管理本篇博客主要关注Linux中的文件权限\n2.1 文件访问者在Linux中，文件访问者分3类，对于文件的权限也分3类\n\n\n\n访问者\n文件权限\n\n\n\n拥有者 owner\nr 读\n\n\n所属组 grouper\nw 写\n\n\n其他用户 other\nx 执行\n\n\n我们要怎么看一个文件对于这三位不同的访问者的权限有什么不同呢？\n使用ll或者ls -l命令即可看到区别\n\n这里文件的前缀，即标识了一个文件的对于3个角色的权限。\n其中muxue是文件的拥有者，root代表所属组。\n2.1.1 linux的组这里需要说明一下，在我之前的腾讯云多人一机的博客中，是用下面这种方式创建子用户的👇\n\n这里就把子用户分到了root组下面，作用是让子用户可以通过su获得root权限\n如果你在创建用户的时候没有指定组的话，系统会自动创建一个与用户名同名的组。\n\n组有什么用？\n\n当在一个公司中，多人使用同一台服务器进行开发的时候，就需要通过组来对子用户进行进一步分类。即A组中其他用户（grouper）可以查看到子用户A1的代码，但是B组的用户（other）都看不到A组内的东西。\n这样就能实现多个小组开发不同的板块，而互不干扰。\n\n2.1.2 学会看文件前缀说回正题，我们要怎么看一个文件夹&#x2F;文件的前缀呢？\ndrwxr-xr-x 5 muxue root    4096 7月   3 11:56 code-rw-r--r-- 1 muxue root 1908226 2月  23 2021 get-pip.pydrwxr-xr-x 7 muxue root    4096 6月  26 08:10 GIT\n\n\n关于第一列的文件类型，有下面几种\n\n现在我们知道了文件权限的查看方式，要如何修改一个文件的特定权限呢？\n2.2 chmod修改权限我们可以使用chmod命令来修改文件权限\nchmod u-r test.txt\n\n上面这个命令的作用是，给拥有者去掉test.txt文件的r权限。可以用下面这个命令把权限加回去\nchmod u+r test.txt\n\n同理，如果你需要修改所属组和其他人的权限的话，指定g和o即可\nchmod g-r test.txt //去掉所属组的r权限chmod o-rwx test.txt //去掉其他用户的所有权限\n\n除了上面这种依次修改的方式，我们还可以用逗号隔开，用一条命令搞定\nchmod u+rwx,g+rwx,o-rwx test.txt //给拥有者，所属组加上所有权限。去掉other的所有权限\n\n如果你想批量修改成同一个权限，还可以使用a来指定all\nchmod a=rw test.txt\n\n\n2.2.1 以八进制修改文件权限除了上面这个+和-比较好辩认的方式以外，我们还可以通过“八进制”的方式来修改文件权限。\n对于一个用户来说，拥有所有权限rwx，如果我们将它与二进制进行对应，就会得到下面的结果\nrwx111二进制对应7\n\n注意，这里的八进制并不是要通过八进制来读写权限的编码，而是用二进制来读取后，可得到最高权限7（不会超过7，所以是八进制）\n了解上面这个方式后，你便可以写出所有权限类型对应的编号\n\n\n\n权限\n二进制\n对应编号\n\n\n\nrwx\n111\n7\n\n\nrw-\n110\n6\n\n\nr-x\n101\n5\n\n\nr–\n100\n4\n\n\n-w-\n010\n2\n\n\n-wx\n011\n3\n\n\n–x\n001\n1\n\n\n当我们修改一个文件的权限的时候，就不需要用a=这种相对古板的方式。而可以通过编码来直接指定3类用户的不同权限\nchmod 777 test.txt //给所有用户为rwx权限chmod 664 test.txt //给u和g用户为rw-，o用户为r--//……\n\n2.3 rwx权限区别修改完这些文件后有什么区别呢？\n当我们创建一个文件夹和一个常规文件时，作为拥有者，默认有文件夹的所有权限和文本文件的rw权限。\n\n2.3.1 常规文件先来看看test.c的各种权限有什么不同吧！\n我们可以通过cat读取test.c文件的内容，这便是读权限r\n\n而通过vim、nano等编辑器修改这个文件，就是写权限w\n如果我们去掉r和w权限，就无法读，也无法写\n\n使用nano打开test.c文件，会有以下报错\n\n那么对于一个常规文件而言，x权限有什么用呢？\n我们知道，当我们使用gcc等编译器编译代码文件时，会出现一个a.out可执行文件。这里的x便是可执行文件的标识。同时，这个文件也是用绿色标明出来了。\n\n如果我们给test.c也加上x权限，则它也会变成绿色，可以直接用./test.c来执行。当然，直接执行一个.c文件是没有意义的\n\n2.3.2 文件夹（目录）\n在Linux下，一切皆文件。我们所说的目录也是一个文件\n文件=内容+属性\n在目录中保存的是文件的属性（包括文件名）我们想访问一个文件，首先要通过路径去找到这个文件。\n\n那么对于一个文件夹而言，rwx权限又是什么呢？\n\n当我们使用ls的时候，其实是可以指定路径的，默认为.（当前路径）\n可以看到，现在显示出了Mytest中的my.txt文件。\n如果我们去掉文件夹的r权限，在执行ls。就会报错权限不够\n\n得出结论，ls查看某一个文件夹中的文件，需要拥有文件夹的r权限。即便你进入这个文件夹，如果没有r权限，依旧无法用ls显示文件夹里面的内容。\n但是这时候，我们还拥有文件夹的w权限，我们可以把其他文件拷贝到Mytest文件夹中\n\n把r权限加回来，可以看到test.c文件已经被拷贝进去了\n\n这便是w权限的作用，修改文件夹中间的内容。比如拷贝另外一个文件到文件夹中\n\n去掉w权限后，我们也无法删除文件夹中的内容\n\n最后，对于文件夹而言，x权限代表的是能否cd进入该文件夹\n\n\n此时虽然我们无法cd进入，但我们拥有rw权限，可以直接从外部修改这个文件夹里面的内容，并进行访问吗？\n\n答案是nope！不可以\n\n因为在Linux中，所有的操作都要通过路径来进行。路径也是访问文件夹的一个方式（需要x权限）此时因为无法cd进入该文件夹，也就无法通过路径访问这个文件夹的内容。所以没了x权限之后啥事都干不了\n当我们把x权限加回来之后，就可以这么做了\n\n\n如果对于目录只没有r权限，允许进入，可创建文件并写入内容，但不可读取其中内容\n如果对于目录只没有w权限，允许进入，允许在目录下ls查看文件列表，但不可以修改里面的文件\n如果目录没有rw权限，允许进入，但是不能修改也不能查看目录下的文件内容\n如果没有x权限，无法进入，也无法修改&#x2F;查看其中内容\n\n关于最后一点，不同系统的实现可能不一样。我的系统是CentOS7.6，请以你的实际情况为准！\n\n2.4 chown&#x2F;chgrp2.4.1 chown修改拥有者我们可以通过这个指令，把一个文件的拥有者修改为指定用户\nchown [参数] 用户名 文件名\n\n注意，在默认情况下，系统是不允许你修改文件的拥有者的。不过我们可以通过在语句前面加sudo的方式，短暂获取root权限，对文件拥有者进行修改\n\n这里如果提示不在sudoer flis里面，可以参考博客里面第八点的解决方案\n\n\n注意，这里我修改为了root用户，root用户拥有最高权限！即便这是子用户的文件，root用户也可以为所欲为进行修改和删除，不受任何权限的约束。\n如果我们把用户改成其他子用户，其实这个子用户依旧访问不到这个文件。\n\n这就好比你告诉你的朋友，我要送你一个键盘。这个键盘的拥有者即将变成你的朋友。但是你没有把键盘给你朋友，键盘还在你家里，你的朋友依旧用不了这个键盘。\n\n换到Linux环境中，就是在A的用户路径下有一个B用户的文件。但由于B用户无法访问A的用户路径，所以依旧无法访问到这个“属于B的文件”\n2.4.2 chgrp修改所属组chgrp [参数] 用户名 文件名\n\n这里因为我的环境里面没有其他组，所以就不演示该功能的成果了\n\n\n2.5 关于默认权限Linux中有一个默认权限：\n\n默认目录权限777\n默认常规文件666\n\n可为什么我创建的目录文件的权限是755，而常规文件的权限是644呢？\n\n这里我们可以用umask命令查看权限掩码\n\n这个权限掩码是什么意思呢？\n抛弃首位不看，后面的是022。根据2.2.1中提到的八进制方式，我们可以解读出这个权限为\n--- -w- -w-\n\n权限掩码的作用就是，在权限掩码中出现的权限，在实际创建文件的时候不会出现！\n仔细观察你就可以发现，这里我的文件夹权限如下，正好和掩码相反！\nrwx rwx rwx //默认权限777--- -w- -w- //掩码022rwx r-x r-x //实际创建755\n\n而常规文件的默认权限666是rw-rw-rw-，实际创建的结果也和掩码相反！\nrw- rw- rw- //默认权限666--- -w- -w- //掩码022rw- r-- r-- //实际权限644\n\n如何计算？这里的权限并不是简单的相减得出来的，其是通过默认权限&amp;(~umask)得出的\n\n先对默认权限的umask进行按位取反\n再将取反后的结果和默认权限（目录777，常规文件666）按位与得出\n\n2.5 file命令除了用文件属性的第一位来查看我们文件的属性之外，我们还可以用file命令来查看更加详细的文件属性\n\n当我们创建了一个C语言文件，并对他进行编译后，可以得到一个C的源文件和一个可执行文件\n\n常用选项如下\n-c 详细显示指令执行过程，便于排错或分析程序执行的情形-z 尝试去解读压缩文件的内容\n\n2.6 粘滞位简单介绍，粘滞位就相当于给一个目录上了胶水，其他人无法删除被黏住的目录（和目录下的文件）！\nchmod +t test\n\n前面提到了，作为other，你可以去访问别人的目录（只要other有对应的权限）\n比如这里我用\tmuxue用户创建了一个test1.c文件，另外一个用户可以读取这个文件，但是不能写入\n\nvim打开该文件会报错\n\n但这里有一个bug就是，即便你没有那个目录内文件的权限，你依旧可以删除这个目录下的文件！\n\n粘滞位的存在就是保护整个目录，不允许被其他用户删除！\n\n添加粘滞位后，可以看到在Other的权限处出现了一个大写的T\n这时候我们再尝试用另外一个账户删除，就会报错——吗？\n\n以上就是一个明显的错误示范，粘滞位保护只能在root下进行操作，而且粘滞位只能给目录上，并不能单独给一个文件上！\n\n给目录上了粘滞位后，再尝试删除，系统会报警告\n\n被保护后的目录，该目录和目录下的文件只能被下面的用户删除：\n\n超级用户root\n目录的所有者\n该文件的所有者\n\n关于最后一点，虽然粘滞位保护了目录下的其他人的文件不能被你删除。但这不影响你在这个目录下创建&#x2F;写入&#x2F;删除你自己的文件\n\n结语关于linux权限管理到这就结束啦！\nlinux操作在未来找工作的时候非常重要，也是我们学习的时候和其他童鞋拉开差距的一环。\n\n因为很多人可能上完本科4年都不知道企业招聘的时候会考linux操作😥\n\n有什么问题可以在下面留言！看到了就会回复的\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】比Xshell更爽，用vscode连接云服务器进行开发","url":"/2022/08/09/code/note_Linux/7vscode_remoteSSH/","content":"本篇博客教你如何用VScode的remote ssh插件连接上linux云服务器进行代码开发~\n\n\n[TOC]\n1.下载vscodevscode是微软官方的一款多语言代码编辑器，其因为丰富而强大的插件而被非常多用户选中使用！\n\n官网下载：https://code.visualstudio.com/\n\n在这里可以直接下载windows上的VSC，但是默认的下载链接下载是非常慢的！\nhttps://az764295.vo.msecnd.net/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n\n我们要做的就是把这个默认的下载链接改成国内的镜像源，下载速度就可以起飞！\n将下载地址中的az764295.vo.msecnd.net 更换为 vscode.cdn.azure.cn 更改后：https://vscode.cdn.azure.cn/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n\n这速度岂不爽炸了！\n\n1.1 安装一些插件\n在开始之前，我们需要安装一些必要的插件：\n\nChinese (Simplified) (简体中文) Language Pack for Visual Studio Code\nRemote - SSH\n\n\n如果你没有其他的开发需求的话，默认安装这两个就可以让我们愉快地登陆上linux服务器了！\n1.2 连接云服务器安装完remote ssh之后，你的左侧应该会出现这样一个按钮\n\n在最上面的链接模式我们选择ssh targets，在这里可以点击+号添加linux服务器\n\n这里填写的格式为 shh 用户名@公网ip。比如我的用户名是user，公网ip是114.514.20.22，那么需要填写的便是\nssh user@114.514.20.22\n\n\n输入完后会让我们选择一个路径，我们选第一个就可以了，方便日后管理\n\n这时候右下角会弹窗告诉你host add，成功添加了一个远程终端\n打开user路径下的.ssh/config文件，可以看到下面关于host的信息。其中我们可以把Host改成和user同名，注意不要修改hostname哦！\n\n重启vsc，然后你应该就可以在左侧看到刚刚添加的linux云服务器。我们右键这个终端，会出现一个选项卡询问你是在当前vsc界面打开该终端，还是新建一个vsc界面。这个根据自己喜好选一个就OK！\n\n初次链接会让你选择该终端的平台，我们选择linux即可！\n\n\n注意：这里我发现直接链接root会出现错误，可能是安全性考虑阻止了vscode在远程服务器的环境安装，后文改为我自己的子账户进行演示！\n\n1.3关于修改host现在发现了问题，其实是因为host需要修改成和user一样才能正常访问，否则会报错\n\n同时下面ssh显示的是host名字，而不是公网ip\n\n\n这里我改成自己的子账户进行演示！\n\n输入咱们账户的密码\n\n这里vscode会在你的云服务器上装一些环境，当左下角出现你的公网ip（这里显示的是host，为公网ip是因为我没有改）那就代表链接成功了！\n\n到这里我们就已成功连上云服务器了！\n\n2. 常用插件推荐vscode连接的好处就是我们可以直接在云服务器环境里面安装插件！这里给大家推荐几个非常棒的插件：\n\nChinese (Simplified) (简体中文) Language Pack for Visual Studio Code\nTerminal Here（超级好用，必装！！）\nC&#x2F;C++\nC&#x2F;C++ Extension Pack\n\n如果你还学习python，可以安装下面的插件：\n\nPython\nPylance\nPip Manager\n\n安装这些插件的时候，会有一些附属插件被同时安装，我们不需要管它，交给vsc自己处理就行拉！注意安装的时候一定是选择安装在你的云服务器里面，如果安装在本地，对于云服务器来说是没有用的哦~\n\n3. 开启终端Linux最常用的当然还是终端了，我们使用快捷键ctrl+shift+p打开vsc的命令选择界面，搜索终端，选择下面这个视图：切换终端\n\n可以看到下面会出现一个熟悉的界面~linux的命令行有啦！\n\n但是，如果只用linux的命令行可完全没必要折腾vscode，这里介绍如何更方便的用vsc开发\n4. 打开文件夹在左侧最上面的分区中，我们可以选择打开一个文件夹\n\n这时候，你便可以选择你常用的工作文件夹，比如我的代码都在GIT文件夹里面，选择后vscode会打开它\n\n\n这里vscode会让你在输入一次linux用户的密码，后文会提到如何免密登录\n\n现在我已经打开了GIT文件夹，可以看到里面的几个子文件夹，这里创建一个新的test文件夹来作为演示\n\nvscode非常棒的一点是，他会帮你保存上一次打开本文件夹的命令行操作信息，不像Xshell打开一个新的之前的命令行操作就看不到了😂\n\n咱们直接右键创建一个新的test文件夹，在里面创建一个test.c文件\n\n随便写一个喜闻乐见的hello代码，vscode的代码补全比vim的插件好了不知道多少（个人感受）\n\n这时候之前安装的几个插件就派上用场了！C&#x2F;C++插件会为我们的代码提供高亮\n4.1 Terminal Here插件而Terminal Here这位更是重量级，我们可以方便的直接打开当前目录下的命令行，不需要自己cd进入文件夹！\n还是用ctrl+shift+p打开vsc的命令面板，搜索terminal，找到下面这个选项\n\n直接回车选择它，你会发现，它自动帮我们创建了一个test.c所处文件夹下的终端！当你的文件目录层级很多的时候，这能帮上大忙！\n\n这里用gcc编译一下，没啥好说的，非常尝龟的操作\n\n这里你能看到vscode的另外一个好处，他会给你把运行正常的命令标蓝，而运行不正常的则标红。\n比如我们在代码里面写个bug在尝试编译，可以看到前面的小点变红了！\n\n同时在右边的滚动条上也能清楚地看到那个地方的命令是运行失败标红的！\n\n而Terminal Here插件牛逼的地方还不止这个，如果你的代码是在Python-vnev的虚拟环境工作目录下，该插件还会自动帮你打开虚拟环境！省得我们自己敲这一行代码了\n\n如果你不知道vnev虚拟环境是啥，简单说一下：python有很多第三方软件包，我们可以通过pip下载安装。为了避免不同的项目中的包都直接安装在用户目录下造成环境污染，便可以创建一个vnev虚拟环境，在这个虚拟环境下安装包。\n只有在虚拟环境开启，且在它的工作目录下，才可以访问到这个包！\n\n\n\n咳咳，扯远啦！有了上面的引导，想必你已经可以愉快的用vscode在linux环境上开发了。\n下面介绍一下如何通过ssh密钥来免密登录，不需要每一次都输入密码\n5. ssh免密登录\n参考https://blog.csdn.net/weixin_42907822/article/details/125237307\n\n如果你之前配置过gitee&#x2F;github的ssh连接，那么肯定对下面的步骤有些熟悉\n\n5.1 生成ssh密钥我们打开windows的cmd，输入下面这个语句\nssh-keygen -t rsa -b 4096\n\n出现的提示信息全部回车跳过，不进行任何操作！\n\n第一行是让你填一个文件名，可以根据自己需要填写，也可以不填直接回车跳过\n\n随后系统会创建一个isa公钥和密钥，我们将其复制到c/用户/用户名/.ssh文件夹中，也就是最初配置vscode的ssh那个文件夹\n\n随后我们用Xshell里面的xtfp连接到云服务器，将有.pub后缀的文件拷贝到云服务器用户目录下的.ssh文件夹，并将其改名为authorized_keys\n\n\n设置.ssh文件权限～/.ssh\n\nchmod 700 ~/.ssh\n\n\n设置authorized_keys文件权限\n\nchmod 600 ~/.ssh/authorized_keys\n\n修改完后可以用ll命令看看是否正常修改成功，700对应的是 dxrw-------，600对应的是-rw--------\n\n5.2 修改root下的配置文件（慎重)友情提示：当你修改任何linux环境下的文件之前，都要记得cp一份出来作为备份！\n进入你云服务器的root用户下，修改下面的文件\nvim /etc/ssh/sshd_config \n\n把 PubkeyAuthentication前的 # 号去掉，这样公钥验证才生效。\n\n修改后保存退出\n用下面的语句重启ssh服务\nsystemctl restart sshd.service \n\n如果无效，则尝试直接重启云服务器\nreboot\n\n5.3 修改本机ssh config文件随后我们再次打开本机.ssh路径下的config文件，注意是本机不是云服务器！\n在原本的配置信息后面追加下面两个，其中IdentityFile指代的是你刚刚生成的那个密钥的文件名，请根据你的实际文件名进行填写！\nPreferredAuthentications publickeyIdentityFile ~/.ssh/id_linux\n\n\n前面创建sshkey的时候，第一个对话框是让你填写一个名字，在多终端配置的时候，名字可以方便我们管理不同的ssh密钥，如下是我的配置，Linux服务器和gitee&#x2F;github用的是不同的密钥（也必须用不同的，因为gitee&#x2F;github密钥需要指定邮箱）\n\n这里配置好之后，你应该就可以免密登录云服务器而不需要输入密码了！\n\n这一步可能会出现很多问题，这里建议大家查更多资料作为补充。不要在评论问我，因为我大概率也不会😥当初配置的时候也折腾了一会，也不知道自己是怎么搞定的（真的不知道）\n第一次配置好ssh后可能会连不上，需要重启vscode再试试！\n\n结语不知道这篇博客有没有帮到你呢？\n如果你根据本教程成功配置好了vscode，还请在下面评论说一声哦！\n万分感谢！\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】一些工具的简单使用，vim/gcc/gdb/make","url":"/2022/08/07/code/note_Linux/6gdb_g++_make_vim/","content":"本篇博客将介绍linux下面一些简单工具的使用\n\n\n[TOC]\n1.vim编辑器1.1安装vimsudo apt-get install vim\n\n需要注意的是，vim编辑器下不能使用CTRL+S来保存文件，因为在linux中这个快捷键的作用是暂停该终端，整个系统都会卡住，这时候使用CTRL+Q取消暂停就可以了。\n1.2文本操作以下是命令模式下的一些文本批量化操作\nyy 复制当前行，nyy复制n行p  粘贴再当前行的后面，np粘贴n次剪贴板的内容dd 剪切（删除）当前行，ndd操作n行u  撤销ctrl+r  重做shift+g 光标快速定位到文本末尾gg 光标快速移动到文本头n+shift+g 光标定位到文本的第n行shift+4 光标定位到该行末尾shift+6 光标定位到该行开头w,b   以单词为单位进行移动光标h,j,k,l  左、下、上、右shift+`  大小写快速切换r   替换光标所在处的字符，支持nrshift+r  批量化替换x  删除光标所在处的字符，nx删除n个\n\nvim进入插入模式的快捷键有a i o，分别对应不同的功能\n1.3底行模式的操作vim编辑器中底行模式的一些操作如下。在其他模式下按esc即退出到底行模式\n:w   &quot;只保存:q   &quot;不保存退出:wq  &quot;保存并退出:reg &quot;打开vim的寄存器面板:syntax on &quot;开启语法高亮:set nu    &quot;显示行号:set nonu  &quot;取消行号显示:set tabstop=4 &quot;设置tab的缩进，默认为8:set softtabstop=4 &quot;softtabstop是“逢8空格进1制表符”,前提是你tabstop=8:set shiftwidth=4 &quot;设置程序自动缩进所使用的空格长度:set autoindent &quot;自动对齐上一行（这个选项会导致复制的时候代码排版混乱，可以考虑关闭，或者开启粘贴模式）:set paste &quot;开启粘贴模式:set mouse=a &quot;设置鼠标模式，默认是a:%s/A/B/g 将当前文件中的A全部替换成B\n上面的一些配置，写入.vimrc配置文件即可长时生效。\n如果需要写入.vimrc配置文件，需要先把:和注释都去掉\n2.gcc&#x2F;g++编译器g++操作和gcc是一样的，这里我们使用gcc作为演示\n2.1linux下使用不同命令执行程序的几个阶段第一步是预处理，只做文本操作\ngcc -E test.c -o tset.i\n在这个阶段会\n\n展开头文件\n对define等等操作进行替换\n处理条件编译指令\n同时删除所有注释\n\n编译操作\ngcc -S test.i -o test.s\n\n汇编操作\ngcc -c test.s -o test.o\n形成可执行程序\ngcc test.o -o mytest\n这三个命令的顺序就是ESc其中只有-c选项是小写的\n正好就是键盘左上角esc按键的顺序\n2.2代码和库这里我们操作&#x2F;编译的都是自己的代码。比如printf我是调用的c语言库中的函数，并没有自己完成一个打印的实现。\n这时候就需要和系统的c语言库产生关联\nc标准库的位置ls /lib64/libc*\n上面的最后一步形成可执行程序mytest时，系统会自动帮我们把这里的代码和库里面的方法连接起来，形成一个最终的可执行程序，并使用./mytest来执行输出结果\n所以我们平时说的装环境就是需要安装语言的静态和动态库，这样才能正常利用库里面的函数进行代码的编译处理\n同时我们在编译器里面写代码时的代码补全功能也是通过在库函数的头文件里面搜索来完成的。\n\n2.3动态&#x2F;静态链接&amp;库\n动态：linux(.so) windows(.dll)\n静态：linux(.a)  windows(.lib)\n\n网吧是全校所有同学共享的，你在网吧开的机子是和别人一起用的。从学校去网吧（库），然后获得一台机子（库函数），打游戏（执行方法）.这就是一个动态的编译链接的过程，即为动态库。\n如果学校允许带电脑，当你想打游戏的时候用的是自己的电脑，用的是自己的方法，这种情况就是用的静态库。每一个人拥有自己的电脑，这个电脑的功能和网吧里面的功能是一样的，当我们把库中的相关代码直接拷贝到自己的可执行程序中，即为静态链接\n\n动态链接：所有人共享同一个资源\n优点：可以节省资源；\n缺点：一旦库丢失，会导致所有程序失效\n\n\n静态链接：都用的是自己的方法，将库里面的代码拷贝到自己的文件中\n优点：不依赖任何库，程序可以独立运行\n缺点：浪费资源\n\n\n\n查看链接状态，默认是动态链接\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ ldd mytest    linux-vdso.so.1 =&gt;  (0x00007ffc0dd8b000)    /$LIB/libonion.so =&gt; /lib64/libonion.so (0x00007f89bd66c000)    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f89bd185000)    libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f89bcf81000)    /lib64/ld-linux-x86-64.so.2 (0x00007f89bd553000)\n\n查看可执行程序的构成\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ file mytestmytest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7cf0ffacfdaeadf8de9b4c0fea379b2a15c37e4c, not stripped\n\n2.3.1手动指定进行静态链接gcc test.c -o mytest1 -static\n静态链接生成的可执行程序大小很大，动态链接的默认是8040左右的体积。\n-rwxrwxr-x 1 muxue muxue   8416 Aug  7 07:34 mytest-rwxrwxr-x 1 muxue muxue 861288 Aug  7 07:44 hello\n所以一般情况下我们都推荐使用动态链接，避免占用太大的空间\n\n当我首次尝试这种方式的时候，出现了下面的报错\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ gcc hello.c -o hello -static/usr/bin/ld: cannot find -lccollect2: error: ld returned 1 exit status\n因为系统里面默认不会带.a的静态库，所以会报错。这时候需要我们手动安装一下。\nsudo yum install -y glibc-staticsudo yum install -y libstdc++-static\n安装成功！\nInstalled:  glibc-static.x86_64 0:2.17-326.el7_9                                                          Complete!\n这时候执行就不会报错了！\n[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ gcc hello.c -o hello -static[muxue@bt-7274:~/GIT/raspi/code/TestProgram]$ \n\n3.gdb调试默认生成的可执行程序是无法调试的！在linux里面发布的可执行程序默认是release版本的，无法debug\n需要添加一个-g选项进行编译\ngcc test.c -o test_g -g\n同时debug版本的可执行文件也会比release版本大一些，这大的空间里面存放的就是调试信息\n-rwxrwxr-x 1 muxue muxue 8360 Aug  7 07:50 test-rwxrwxr-x 1 muxue muxue 9376 Aug  7 07:53 test_g\n\n利用下面这个语句可以查看可执行程序的调试信息\nreadelf -S test | grep debug\n可以看到debug版本包含了很多调试信息，而release版本里面没有\n[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ readelf -S test | grep debug[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ readelf -S test_g | grep debug  [27] .debug_aranges    PROGBITS         0000000000000000  00001061  [28] .debug_info       PROGBITS         0000000000000000  00001091  [29] .debug_abbrev     PROGBITS         0000000000000000  00001122  [30] .debug_line       PROGBITS         0000000000000000  00001164  [31] .debug_str        PROGBITS         0000000000000000  0000119f\n3.1尝试调试一个简单的代码以下是一些简单的gdb操作\nb 行号：打断点info b：查看断点d 断点编号： 取消断点l 行号：显示代码l main：显示包含main的那一行r：run，开始运行程序,跳到第一个断点s：step，逐语句，对应vs的F11（进入函数）n：next，逐过程，对应vs的F10c：continue，跳转道下一个断点p：查看变量display / undisplay：常显示 或 取消常显示until 行号：跳转到指定行finish：执行完一个函数后停下bt：查看函数调用堆栈\n提醒：编译的时候记得加上-g选项指定debug版本\n下面是一个用于演式的示例代码\n#include &lt;stdio.h&gt;int Add(int a,int b)&#123;    printf(&quot;Add(a,b)\\n&quot;);    return a+b;&#125;int main()&#123;    printf(&quot;hello wolrd！\\n&quot;);    int ret=Add(1,20);    printf(&quot;ret: %d\\n&quot;,ret);    return 0;&#125;\n演示如下\n[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ gdb test_gGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/muxue/GIT/raspi/vim/TestGdb/test_g...done.(gdb) l23       int Add(int a,int b)4       &#123;5           printf(&quot;Add(a,b)\\n&quot;);6           return a+b;7       &#125;89       int main()10      &#123;11          printf(&quot;hello wolrd！\\n&quot;);(gdb) b 11Breakpoint 1 at 0x4005a7: file test.c, line 11.(gdb) llUndefined command: &quot;ll&quot;.  Try &quot;help&quot;.(gdb) l 105           printf(&quot;Add(a,b)\\n&quot;);6           return a+b;7       &#125;89       int main()10      &#123;11          printf(&quot;hello wolrd！\\n&quot;);12          int ret=Add(1,20);13          printf(&quot;ret: %d\\n&quot;,ret);14          return 0;(gdb) b 13Breakpoint 2 at 0x4005c3: file test.c, line 13.(gdb) rStarting program: /home/muxue/GIT/raspi/vim/TestGdb/test_g Breakpoint 1, main () at test.c:1111          printf(&quot;hello wolrd！\\n&quot;);Missing separate debuginfos, use: debuginfo-install glibc-2.17-326.el7_9.x86_64(gdb) shello wolrd！12          int ret=Add(1,20);(gdb) sAdd (a=1, b=20) at test.c:55           printf(&quot;Add(a,b)\\n&quot;);(gdb) p retNo symbol &quot;ret&quot; in current context.(gdb) finishRun till exit from #0  Add (a=1, b=20) at test.c:5Add(a,b)0x00000000004005c0 in main () at test.c:1212          int ret=Add(1,20);Value returned is $1 = 21(gdb) sBreakpoint 2, main () at test.c:1313          printf(&quot;ret: %d\\n&quot;,ret);(gdb) p ret$2 = 21(gdb) p &amp;ret$3 = (int *) 0x7fffffffdf3c(gdb) sret: 2114          return 0;(gdb) s15      &#125;(gdb) qA debugging session is active.        Inferior 1 [process 5932] will be killed.Quit anyway? (y or n) y[muxue@bt-7274:~/GIT/raspi/vim/TestGdb]$ \n整体的操作并不是特别复杂，大家可以自己尝试一番，有问题可以评论提出\n\n4.make&#x2F;makefile这是一个批量处理工具，我们可以通过make来批量编译一些代码，避免手动敲打命令行的出错问题。这在大型项目中非常重要。\nmakefile是当前路径下的一个普通文件，存放了如下内容：\n\n依赖关系\n依赖方法\n\n假设我们需要形成一个c语言的可执行文件\n依赖关系：test -&gt; test.c依赖方法：gcc test.c -o test\n其对应的makefile如下\ntest:test.c    gcc test.c -o mytest\n注意，第二行的依赖方法必须tab缩进，不然无法正常调用！\n编写好makefile后，直接在当前路径下执行make。系统会自动查找名称为makefile&#x2F;Makefile的文件执行\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ makegcc test.c -o test[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ ./testhello wolrd！Add(a,b)ret: 21\n\n我们还可以写一个清除指令，用于在编译后删除大量临时出现的可执行程序\n.PHONY:cleanclean:    rm -f test\n在原本的makefile后追加这部分内容即可\n通过make clean来清理文件\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ make cleanrm -f test[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test.c\n4.1出现missing separator解决方案当我执行make clean的时候出现了这个报错\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ make cleanmakefile:4: *** missing separator.  Stop.\n这是因为在我的makefile中，依赖方法前面的缩进是4个空格，而不是1个tab\n注意需要使用tab进行缩进，而不能手动打空格！\n4.2make如何判断需不需要重新生成？当我们在一个文件夹内执行过make之后，再次make，系统会提示当前的可执行程序test已经是最新版本，无需更新。\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ makegcc test.c -o test[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ lsmakefile  test  test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ makemake: `test&#x27; is up to date.[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ \n\n那么系统是如何实别出来我们的原代码是否有过更改的呢？\n4.2.1 stat时间戳我们可以使用stat命令查看一个文件的时间戳\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test  File: ‘test’  Size: 8440            Blocks: 24         IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450818     Links: 1Access: (0775/-rwxrwxr-x)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-08-07 17:18:40.463120772 +0800Modify: 2022-08-07 17:18:40.463120772 +0800Change: 2022-08-07 17:18:40.463120772 +0800 Birth: -[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test.c  File: ‘test.c’  Size: 201             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450788     Links: 1Access: (0664/-rw-rw-r--)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-08-07 09:30:39.043992599 +0800Modify: 2022-08-07 09:30:38.544992699 +0800Change: 2022-08-07 09:30:38.544992699 +0800 Birth: -\n\n这里可以看到，一个文件的时间戳分为3个，分别是Access查看、modify修改，Change更改。\n第一个查看很好理解，那么modify和change有什么区别呢？\n我们可以手动修改一个程序看看情况\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ vim test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test.c  File: ‘test.c’  Size: 207             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450788     Links: 1Access: (0664/-rw-rw-r--)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-08-07 17:25:12.958082845 +0800Modify: 2022-08-07 17:25:12.808082859 +0800Change: 2022-08-07 17:25:12.808082859 +0800 Birth: -\n\n这里我通过vim进入该文件，添加了一行注释，可以看到，相比于之前的时间，3个时间戳都被修改成了最新的时间。这是因为我们修改文件的时候一定会查看，也有modify和change\n而如果我只是修改这个文件的权限，并不修改它的内容，会发生什么？\n[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ chmod o-r test.c[muxue@bt-7274:~/GIT/raspi/vim/TestMake]$ stat test.c  File: ‘test.c’  Size: 207             Blocks: 8          IO Block: 4096   regular fileDevice: fd01h/64769d    Inode: 1450788     Links: 1Access: (0660/-rw-rw----)  Uid: ( 1001/   muxue)   Gid: ( 1001/   muxue)Access: 2022-08-07 17:25:12.958082845 +0800Modify: 2022-08-07 17:25:12.808082859 +0800Change: 2022-08-07 17:27:34.378068762 +0800 Birth: -\n\n可以看到，只有change发生了变化。\n文件=内容+属性，在这里的modify对应的就是内容修改，而change对应的是属性修改。而当我们修改文件内容的时候，会引起文件大小的变化，也是属性变化，所以修改内容也可能会引起change的变化！\n\n了解了这个时间戳，那么系统是怎么判断是否需要重新生成就很简单了：比较依赖关系中左边的目标文件和右边源文件的modify时间，如果源文件的modify时间早于目标文件，那么说明目标文件生成之后，源文件并没有发生更改，那么也无需再次生成\n4.2.2  PHONY关键字的作用在前面提到的clean代码中，我们使用了.PHONY关键字来修饰clean。\n这个关键字让clean作为一个伪目标，且总是被执行\n\n怎么理解这个总是被执行？\n\n当我们的源文件没有发生更改的时候，make不会重新生成，这个叫做总是不被执行\n\nPHONY关键字的作用就是屏蔽系统对于modify时间的检查，每一次都会强制执行该语句的依赖方法。\n\n一般情况下我们只有在clean的时候才会使用.PHONY关键字来修饰\n4.3 $@ $^ 高级用法mytest:test1.c test2.c\tgcc -o $@ $^\n第一个$@代表是左边的目标文件，$^代表是源文件，这样写可以实现全匹配，不需要自己一个一个写源文件了\n[muxue@bt-7274:~/git/linux/code/22-08-07_make_gdb]$ cat makefiletest:test.c add.c\tgcc $^ -o $@[muxue@bt-7274:~/git/linux/code/22-08-07_make_gdb]$ makegcc test.c add.c -o test[muxue@bt-7274:~/git/linux/code/22-08-07_make_gdb]$ ./test4\n\n4.4 定义变量\n\n5.尝试编写一个简单的linux进图条当我们在linux系统上下载一些软件的时候，总是可以看到用文字组成的进度条，这些进图条是怎么做出来的呢？\n下面我们可以尝试用C语言写出一个简单的进度条。在这之前，我们需要了解一些概念\n5.1 缓冲区在我之前的C语言文件操作博客中，提到了一个缓冲区的概念。简单来说，当我们printf一道字符串的时候，系统是先把这个字符串写入缓冲区，再把缓冲区的内容输出到屏幕上\n比如下面这个代码，再linux环境中，\\n会自动刷新缓冲区。\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123;\twhile (1)\t&#123;\t\tprintf(&quot;hehe\\n&quot;);\t\t//在linux环境中，不带&#x27;\\n&#x27;的时候，并不会打印（没有刷新缓存区）\t\t//而在VS环境中，带不带都会正常打印\t\tsleep(1);//linux环境中，sleep函数的参数，单位是秒（VS是毫秒）        //             linux环境下，sleep函数需要小写，VS下是Sleep\t&#125;\treturn 0;&#125;\n\n如果我们去掉\\n，系统则不会立即打印内容。\n\n这时候需要我们手动用fflush(stdout)刷新一下缓冲区，现在程序会在一行中打印了\nfflush(stdout);//手动刷新缓冲区\n\n\n5.2 回车和换行在我们日常生活中提到的换行一般指的是回车+换行\n实际上，回车和换行是有区别的：\n\n回车：光标回到该行的最前面\n换行：光标去到下一行，但是位置不变\n\n在C语言中，\\n执行的就是回车+换行，而\\r是回车\n那么我们就可以利用这个特性，来实现一个简单的倒计时\n#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main()&#123;    int i=9;\twhile (i&gt;=0)\t&#123;\t\tprintf(&quot;%d\\r&quot;,i);\t\t//在linux环境中，不带&#x27;\\n&#x27;的时候，并不会打印（没有刷新缓存区）\t\t//而在VS环境中，带不带都会正常打印         fflush(stdout);//手动刷新缓冲区\t\tsleep(1);//linux环境中，sleep函数的参数，单位是秒（VS是毫秒）        //             linux环境下，sleep函数需要小写，VS下是Sleep        i--;\t&#125;\treturn 0;&#125;\n\n\n\n5.3 进度条做好前面的准备工作后，现在我们就可以来打印一个简单的进度条了！\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define NUM 102#define STYLE &#x27;#&#x27;void process()&#123;    char bar[NUM];    memset(bar, &#x27;\\0&#x27;, sizeof(bar));    const char *lable = &quot;|/-\\\\&quot;;//在末尾打印一个转动的“小圆圈”    int cnt = 0;    while(cnt &lt;= 100)    &#123;        //默认是右对齐，使用-改位左对齐        printf(&quot;加载中:%-100s[%d\\%][%c]\\r&quot;, bar, cnt, lable[cnt%4]);        fflush(stdout);        bar[cnt++] = STYLE;//打印预定义的符号        usleep(200000);    &#125;    printf(&quot;\\n&quot;);&#125;int main()&#123;    process();    return 0;&#125;\n\n\n这样一个简单的进图条就搞定辣！\n后记linux中一些工具的使用可能不会有windows的编译器那么方便，比如GDB调试。但是在后续编写一些只有linux平台才能运行的代码的时候，我们必须学会使用这些工具，否则操作起来会非常麻烦！\n感谢你看到最后，有任何问题都欢迎在评论区提出哦！\n","categories":["玩上Linux"],"tags":["Linux"]},{"title":"【Linux】进程概念","url":"/2022/08/31/code/note_Linux/8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","content":"本文演示所用系统为CentOS 7.6\n\n\n1.操作系统操作系统是不会直接对用户提供服务的。因为这样会暴露自己的底层实现，对系统稳定性造成了威胁\n\n操作系统是通过系统调用层的方式对外提供接口服务的。\n\n这就好比你是通过前端按钮来使用一个网站的功能，而通常你是看不到网页的后端实现的。\n\nLinux系统的底层是用C语言写的，所以这些接口服务本质上就是一些C语言的函数。这些函数用于操作系统的各种管理。\n我们学习Linux的系统编程，本质上是在学习这些和系统对接的函数。\n1.1 编程语言和系统对接不同的操作系统，其提供的各种管理硬件的函数是不同的。这时候我们的C&#x2F;C++等其他语言想和系统对接（如printf打印到屏幕上）就需要在底层帮用户管理好这些系统接口的调用。当我们使用这些语言的时候，就不需要自己手动去调用\n1.2 描述进程-PCB\nPCB并不是那些绿油油的电路板，这里指的是process control block\n\n进程是有一个担当分配系统资源（CPU时间，内存）的实体\n\n进程信息被放在一个叫做进程控制模块的数据结构中，可以理解为进程属性的集合\n在Linux中的PCB其实就是一个结构体task strcut，包含了这个进程的各种信息。\n\ntask_struct的内容大家可以上网搜搜，能力强的朋友可直接去看Linux的源码。\n1.3 组织进程我们可以在Linux的源码中找到组织进程的方式。所有运行在系统里面的进程都是以task_struct为成员的链表形式存在内核中。下面是关于这个结构体的一部分解析\n\n\n标示符: 描述本进程的唯一标示符，用来区别其他进程\n状态: 任务状态，退出代码，退出信号等。\n优先级: 相对于其他进程的优先级。 \n程序计数器: 程序中即将被执行的下一条指令的地址。 \n内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针\n上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。\nI／O状态信息: 包括显示的I&#x2F;O请求,分配给进程的I／O设备和被进程使用的文件列表。 \n记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。 \n其他信息\n\n\n相关解析可以看看这篇博客【传送门】\n1.4 查看进程1.4.1 ps命令可以用ps命令来查找进程信息。下面这个指令是显示所有的进程\nps axj\n\n系统会打印下面的很多进程信息，这就好比windows下的任务管理器\n\n如果我们使用一个while(1)的死循环函数，运行的时候就变成了一个进程了。我们可以用下面的命令来查找特定的进程信息\nps axj | grep test\n\n\n上图中我们搜索test，出现了两个进程。第一个进程很明显是我们运行的可执行程序。那么第二个是什么呢？\n\n实际上，所有的指令都是一个进程。只不过ls这种类型的命令很快就能执行完毕。\n\n这样一来，我们便可以确认，出现的第二个进程实际上是我们执行这条搜索语句出现的。可以用下面的这个指令来屏蔽grep的结果，只显示我们自己的那个程序。\nps axj | grep test | grep -v grep\n\n最后一个指令的意思是忽略掉包含grep的结果，现在就不会显示第二个grep的进程了\n\n1.4.2 proc目录还可以通过/proc系统文件夹来查看系统进程信息。这里面的内容都是一个实时的进程信息\n\n每一个进程都有一个自己的PID(process id)，用来标识唯一的进程\n可以用下面的这个指令来显示一个提示信息，其中的&amp;&amp;代表逻辑与，只有第一个命令执行成功，才会执行第二个命令\nps ajx | head -1 &amp;&amp; ps ajx | grep test | grep -v grep\n\n\n这里就告诉我们了这个命令的PID是什么，即第2位数字\n\n如果你需要查看PID为1的进程，则打开对应进程的文件夹\n\n上面我们搜到的进程PID为5408，查看对应文件夹可以看到下面的内容\n\n当我们关闭了./test进程在去查找，会发现没有这个路径了\n\n在每一个进程文件夹中都有一个cwd和exe\n\ncwd其指向的是进程当前的工作路径\nexe指向的是进程对应可执行程序的磁盘文件\n\n比如现在我使用ps命令查找到了下面这个python代码进程\n\n使用ls -l /proc/19423命令打开对应文件夹，便可以看到cwd和exe的指向\n\n这代表该进程是用python3.10进行执行的，其工作目录为cwd指向的路径\n\npid、工作路径等等信息都存放在进程的task_struct中\n\n1.4.3 C语言代码获取ppid和pid除了在命令行中输入命令以外，我们还可以通过C语言代码中和系统通信的库函数来获取当前进程的ppid和pid\n#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123;    printf(&quot;pid: %d\\n&quot;, getpid());    printf(&quot;ppid: %d\\n&quot;, getppid());    return 0;&#125;\n\n\n使用一个while(1)循环，我们就可以看看这个进程是否和我们用ps搜出来的结果相同\n\n\n可以看到，搜寻出来的结果和该程序自己打印的结果是一样的\n实际上，我们所有在命令行上执行的程序，都是bash（即当前命令行）的子进程\n\n1.5 fork 通过系统调用创建父子进程如果你用过gitee或者github，想必对fork并不陌生。在git托管网站上，我们fork别人的仓库，便会在自己的账户中出现一个别人仓库的“子仓库”。我们可以在这个“子仓库”里面修改一部分信息，再创建一个pull request合并入被fork的仓库\n而在Linux系统中，fork的作用便是可以创建一个父子进程，这两个进程相互独立，且有很多特殊的地方等着我们的探索\n比如：fork具有两个不同的返回值！\n下面是一个示例代码\n#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123;    pid_t id = fork();    //id=0 子进程；&gt;0为父进程    if(id == 0)    &#123;        //child        while(1)        &#123;            printf(&quot;子进程，pid: %d, 父进程是: %d\\n&quot;, getpid(), getppid());            sleep(1);        &#125;    &#125;    else&#123;        //parent        while(1)        &#123;            printf(&quot;父进程，pid: %d, 父进程是: %d\\n&quot;, getpid(), getppid());            sleep(1);        &#125;    &#125;&#125;\n\n运行上面的代码，你会发现父子进程竟然交叉运行了！而且这两个进程都有不同的pid。其中子进程的ppid即为父进程的pid！\n\n奇怪，我们的while循环明明是写在if里面的啊？为什么else里面的while也被正常执行了呢？\n1.5.1 man fork这便需要我们了解一下fork到底是何方神圣了。\nman fork\n\n\n如果你出现No manual entry for fork的报错，在CentOS下请尝试执行下面的命令\nsudo yum install -y man-pages\n\n\n同时可以看到关于fork的返回值的描述\n\n这便能告诉我们，为啥fork下方同一个id值使用打印会返回不同的结果；以及if else被交叉运行的原因。\n\nfork之后，父子进程共享代码，都会执行后面的if else语句\nfork之后，父子进程的返回值不相同，所以if else语句进入的模块也不相同\n\nfork进程给父进程返回子进程pid，方便父进程管理自己的子进程。这是因为父进程必须要有标识子进程的方法！\n\n一个父亲可以有多个孩子，需要pid来进行管理\n一个子进程只能有1个父亲，所以用0来标识子进程创建成功即可。它可以用ppid方便的找到自己的父进程。\n\n1.5.2 fork做了什么fork会调用系统的OS system call，创建一个子进程\n\ntask_struct + 父进程代码和数据\ntask_struct + 子进程代码和数据\n\n子进程的代码和数据大多数都是从父进程继承下来的，不过pid和ppid肯定不会继承。其内部的变量/数据和父进程独立（这个后续的博客会涉及）\n\n当fork创建好子进程并进行return的时候，它的功能就已经完成了\n此时还会将子进程放入运行队列\n\n了解了这个之后，再来理解一下进程是如何被运行的👇\n2. 如何理解进程被运行在我们的系统中，每一个CPU都有一个运行队列\n这个运行队列之中存放的便是task_struct，系统会依次运行每一个进程。\n\n在上面我们的fork创建子进程之后，便会把子进程放入运行队列\n\n所以实际上，fork并不是有两个返回值，而是在先运行了父进程后，又创建了一个子进程。这两个进程共享代码，而且它们都是挂载在同一个bash命令行上，才会出现上述交替打印的情况。\n\n结语下篇博客是有关进程状态的内容，阿巴阿巴，好久没写博客了\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【leetcode】001.两数之和（C语言，超详细）","url":"/2021/10/31/code/leetcode/001%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"这是初学C时候写的题解，可能有思维漏洞，后面重新刷题的时候会更改！\n\n\n[toc]\n两数之和 leetcode-001题目来源leetcode\n如下图所示\n\n右侧给出了题目的基本模板\n/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;&#125;\n\n\n题目要求做题之前，我们需要梳理出题目的各项要求\n算法题目需要我们非常细致，因为一个小要求的未完成，就会导致格式出问题或者结果出问题，无法通过系统的测试\n题目要求如下：\n\n在给定数组nums中找出相加为target的两个数字\n同一个数字不能重复\n假设每一个target只对应一种答案\n找到数字后返回元素的下标\n不能更改摸板里的代码\n\n这里还有一个容易被忽略的隐藏条件！\n\n相加的两个数字在数组中是连续的\n\n这个条件是观察3个示例得出的，如果没有这个条件，这道题目就需要我们在数组中进行完全搜索！\n我做这道题目的时候就卡在了这个地方！\n\n实现步骤1.模板中四个值的意义首先我们要弄明白摸板里的4个值分别代表什么东西\nint* twoSum(int* nums, int numsSize, int target, int* returnSize)\n\n\nint* nums——nums数组（ 此形式等同于int nums[] )\nnumsSize——数组元素的个数\ntarget——需要求和的结果\nint* returnSize——返回值的个数（这个不可以省略！）\n\n再来看题目的要求\n\n需要在给定数组中找到相加&#x3D;target的两个连续的数字\n\n2.在数组中找到两个连续的元素一般在数组里面查找一个数字，我们都会想到使用for循环\n这里需要查找两个相邻的数字，可以使用两个嵌套的for循环以及两个循环变量来实现\nint i=0；int j=i+1;\n\n需要注意的是，j比i大了1，为了防止数组越界访问\nfor循环里面的判断变量也要相应的差1\nfor(int i = 0; i &lt; numsSize - 1; i++) &#123;     for(int j = i+1; j &lt; numsSize; j++)     &#123;              &#125; &#125;\n\n3.判断相加是否等于target在数组中找到元素后，需要判断它们两个相加是否等于target\nif(nums[i] + nums[j] == target)\n\n4.返回元素下标当代码成功找到了两个相加等于target的元素后，我们要返回这两个元素的下标\n这里就需要一个新的数组来接收这两个下标，这比单纯的使用两个变量更方便\n创建这个数组有两种方法\n\n使用arr[2]来创建\n使用malloc函数来创建\n\n其中方法二，是题目所给提示里的函数，后续将提及\n/* Note: The returned array must be malloced, assume caller calls free(). */\n\n\n代码示例1\n注：leetcode的函数题目只需要补全自定义函数，无需写main函数\n\n在示例1里面，使用普通的方式创建result[2]数组\nint* twoSum(int* nums, int numsSize, int target,int* returnSize) &#123;    static int result[2] = &#123;0&#125;;//static修饰后，return的地址才能被main接收    for(int i = 0; i &lt; numsSize - 1; i++)    &#123;        for(int j = i+1; j &lt; numsSize; j++)        &#123;            if(nums[i] + nums[j] == target)            &#123;                result[0] = i;                result[1] = j;                *returnSize = 2;//这个不能删除                return result;            &#125;        &#125;    &#125;    return 0;&#125;\n\n\n因为我们需要在main函数里面使用result数组的值\n所以需要用static来修饰这个数组\n\n不用static修饰的话，出了自定义函数后，result数组的内存空间将被释放\n即便我们return了这个数组，它也不能被主函数接收\n\nstatic的作用\n修饰函数\n修饰全局变量\n修饰局部变量\n\n这里使用的是static的第3个作用，将局部变量数组result，变成静态局部变量\n即数组result不会在出自定义函数后销毁\n\n*returnSize是什么？\n屏幕前的你是否和我有一样的疑惑，此*returnSize在自定义函数里面没有意义\n那为什么不能删除？\n\n要知道，这里的*returnSize是题目的模板给我们的\n而且题目没有要求我们书写main函数\n其实这里的*returnSize在main函数是有变量传过来的\n删除后自定义函数里缺少变量来接受传过来的数据，自然会报错\n*returnSize = 2;\n\n同时，我们需要在if语句中将它定义为2，即为返回值的个数\n具体的分析参考这篇博客&#x3D;&#x3D;&gt; 链接\n\n代码示例2说第二种方法前，我们必须先弄明白malloc函数是什么\n\n什么是malloc函数？在cplusplus网站，我们可以查看到malloc函数的定义\n该函数对应的头文件为cstdlib，即c语言中的&lt;stdlib.h&gt;\n\n它的作用，简单来说就是在内存中开辟对应字节的空间，赋予给一个指针变量\nint *pa = malloc(sizeof(int));\n\n上面这个语句的意义是，开辟一个int类型（即4个字节）的空间，赋给指针变量*pa\n\n其中的(int)可以换成(4)\n也可以在后面乘上一个数(int)*2表示8个字节\n\n本题需要的是存放两个int整形的数组，malloc函数可以这么写\nint *num = malloc(sizeof(int)*2);\n\ncplusplus图中的定义里有一句话\n\nIf the function failed to allocate the requested block of memory, a null pointer is returned.\n\n如果指针分配错误，函数将返回一个NULL，空指针\n\nmalloc使用后free释放在使用完malloc函数后\n\n需要用free函数来释放malloc创建的内存空间\n需要将创建的指针变量指向空指针，以防程序错误调用\n\nfree(pa); pa = NULL;\n\n这两个函数是配对的\n\n如果申请后不释放，会内存泄露\n\n如果无故释放，那就是什么也没有做\n\n\n\n内存泄漏参考这篇博客&#x3D;&#x3D;&gt;[链接]\n\n\n以下就是方法2的完整代码\n/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;    int *num = malloc(sizeof(int)*2);    for(int i = 0; i &lt; numsSize - 1; i++)    &#123;        for(int j = i + 1; j &lt; numsSize; j++)        &#123;            if(nums[i] + nums[j] == target)            &#123;                num[0] = i;                num[1] = j;                *returnSize = 2;                return num;            &#125;        &#125;    &#125;    return 0;&#125;\n\n为什么本题使用完malloc函数后没有free呢？\n原因还是在本题的提示里\n/*Note: The returned array must be malloced, assume caller calls free()*/\n\n这个语句的大概意思应该是：假设main函数里面已有一个free函数来释放内存\n所以我们不需要自己加上free函数\n\n自己写代码的时候一定别忘了加哦！\n\n\n总结虽然这只是leetcode的第一题，网站打上的难度是“简单”\n但对于我这个学艺不精的初学者来说，还是费了一番功夫去完成这道题并理解它\n本片博客就是我求解这道题的过程，希望对你有帮助\n\n小声吐槽:\ncsdn太多繁杂的东西了，有的博客代码不贴代码块，有的答案代码都是错的\n还有些人就这么一道题的答案都给你上传一个付费文件（无头像无id无简介，上传几千个资源，怀疑是机器人爬虫）\n\n不管怎么样，至少我弄懂这道题啦！\n感谢引用的两篇博客的作者，若不是他们，我也弄不明白这道题！\n点个👍再走吧，球球了！这对我真的很重要啊！\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","leetcode","C语言"]},{"title":"【Linux】进程概念","url":"/2022/09/27/code/note_Linux/9%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81_%E4%BC%98%E5%85%88%E7%BA%A7/","content":"本篇博客是有关进程状态的，好久没有写Linux的博客了，一起来看看吧！\n\n\n\n实验系统：CentOS 7.6\n\n1.系统进程的运行状态当我们想到进程的时候，一定要首先想到task_struct结构体。该结构体内部有一个state状态码，用于标识当前进程处于什么状态\n\n1.1 运行态CPU会有一个进程队列（双链表），队列的每一个成员都是一个task_struct结构体，用来维护即将运行的进程。当轮到某个进程运行的时候，CPU就会将这个进程的数据和代码放入内存和自己的寄存器，并开始运行\n只要进入了运行队列的进程，就是运行态的进程\n\n所以运行态并不是正在运行的进程\n\n为什么我们对这件事的感知不大呢？那是因为现代的CPU的运行速度非常快，这些运行队列的轮转周期很短\n1.2 终止态终止态：进程还在，但是永远不会运行，在队列中等待被释放\n为什么进程都终止了，不立马释放对应的资源，而需要维护一个终止态？\n\n这是因为当前CPU&#x2F;操作系统正在忙着干其他的事情，没时间过来释放你。所以会将不运行的进程放入终止态的队列（将该进程task_struct结构体插入该队列）\n当操作系统空闲的时候，便会取终止态队列里面的进程进行释放\n\n1.3 阻塞态一个进程使用资源的时候，不仅仅会申请CPU的计算资源，还有可能申请其他更多的资源，比如网络/硬盘/网卡/显卡等等\n如果申请这些资源的时候得不到满足，就需要排队\n\nCPU资源：运行队列\n其他资源：也需要进行排队\n\n 下面用伪代码的方式来描述一下进程为何会阻塞 \nstruct cpuinfo&#123;    //……    //运行队列    task_struct *queue;&#125;struct disk_div&#123;   \t//磁盘的等待队列    task_struct *queue;&#125;struct net_div&#123;   \t//网卡的等待队列    task_struct *queue;&#125;\n\n当我们的进程访问某种资源，特别是外存（磁盘）这种慢设备资源的时候，如果磁盘暂时还没有准备好，操作系统就会把当前进程从运行队列剥离，插入到对应需要访问的设备下的等待队列中\n\nDDR4内存的读写大约是40GB&#x2F;S，即便是现在市面上较快的pcie4.0固态硬盘其读写速度也只有7GB&#x2F;S左右，这个差距还是很大的。所以才说磁盘是“慢设备”资源\n\n操作系统移动task_struct到对应的队列下，就是起了它管理进程的作用。同时将进程剥离运行队列，也能让等待慢设备资源的进程不至于把整个系统卡死。当我们电脑上运行的进程很多的时候，就有可能遇到当前的进程在等待过程中出现了阻塞，此时进程的代码不会运行。最直观的反应便是当前进程卡住不动了。\n\n1.4 进程挂起进程挂起和进程阻塞很类似，但也有不同。\n\n进程挂起和阻塞不同的是，阻塞只是单纯地在等待慢资源。而挂起则是该进程的数据被放入回了磁盘，进程本身依旧在排队等待。操作系统会有一个专门的swap分区，用来存放挂起进程的代码和数据。\n操作系统这么管理，是为了不让内存在多进程运行的时候不够用了。这也是为什么，当我们内存不够用的时候，往往伴随着磁盘的频繁读取。\n\n当然，内存不够也有可能是某一个进程需要一次性加载的代码数据已经超过了内存的大小😂\n\n下图中左下角的部分便演示了操作系统在处理阻塞和挂起态的操作循环\n\n\n2.Linux下的进程状态描述在linux下进程的状态是存放在一个数组里面的\n\n2.1 S和R状态的说明其中R对应的是运行态，S对应的就是阻塞态（linux下为休眠）\n我们可以运行一个程序看看它处于什么状态\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    while(1)&#123;        printf(&quot;%d\\n&quot;,getppid());        sleep(1);    &#125;    return 0;&#125;\n\n运行发现，左侧打印出了当前进程PID，而右侧当我们使用ps命令查询该进程的时候，发现该进程的状态是S+也就是休眠状态\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test32080 30455 30455 32080 pts/0    30455 S+    1001   0:00 ./test\n\n\n这是为什么？程序不是一直都在运行吗？\n首先需要知道的是，printf需要将数据打印输出到屏幕上，屏幕作为外设，同样属于慢资源。所以我们的进程绝大部分时间都是处于sleep(1)以及等待屏幕刷新的过程中。而CPU只需要执行printf一个操作，这个操作几乎是瞬间就进行，当然也看不到该进程处于运行态了\n即便我们把sleep(1)去掉，进程也是需要等待屏幕刷新，同样处于S+状态\n那要怎样才能让进程处于运行态呢？很简单，我们写一个不和外设交互的死循环即可\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    while(1)&#123;\t\tint a = 10;    &#125;    return 0;&#125;\n\n可以看到现在进程的状态是R+，处于运行态！\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test32080 32489 32489 32080 pts/0    32489 R+    1001   0:06 ./test\n\n\n2.2 D状态disk sleep除了基本的S状态，linux下还有一个专门的disk sleep状态。如同它的名字一样，这个状态是专门为访问硬盘的进程设计的\n假设有下面这样一个场景\n1.进程A需要访问磁盘资源，写入1GB的数据2.磁盘很忙，进程A进入S状态等待读写3.操作系统发现这里有个进程没干活，内存又不够了，于是把进程A干掉了4.轮到进程A独写的时候，磁盘发现进程A已经被干掉了，于是没管它的1GB数据5.结果：这个1GB数据丢失了\n\n出现这种数据丢失，谁都不想的嘛。所以Linux就设置了一个D状态，\n\nS 浅度睡眠\nD 深度睡眠\n\n处于D状态的进程不能被操作系统kill掉。要想杀掉一个D状态的进程，只有下面三种办法\n\n等硬盘读写完毕，给进程返回结果之后，进程从D状态变成其他状态，操作系统进行处理\n关机重启\n拔掉电脑的电源\n\n\n\nlinux下可以用DD命令直接对硬盘进操作\n\n\n3.僵尸进程Z僵尸进程对应的状态码是Z，而X是1.2提到的终止态\n3.1 为什么会存在僵尸进程?当Linux中的一个进程退出的时候，一般不会进入X状态（终止态，可以回收资源），而是进入Z状态\n\n进程运行了一定的程序，可以理解为这个进程的任务\n当该进程退出的时候，需要知道这个进程是如何结束的（可以理解为终止的原因）\n一般是将执行结果交还给操作系统或者父进程\n\n维护一个状态Z，就是为了维护进程的退出信息，可以让父进程/操作系统读取\n\n父进程/操作系统是通过进程等待来读取进程的退出信息的\n\n在task_struct里面就有一个专门的成员来维护退出信息\n\n3.2 如何复现僵尸状态？我们创建子进程的时候，只要父进程不搭理子进程，一直运行父进程，提前终止子进程，就可以观察到子进程进入僵尸状态\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;int main()&#123;    int ret = fork();    if(ret == 0)    &#123;        int i = 6;        while(i)        &#123;            printf(&quot;我是子进程，我的ppid是%d,pid是%d\\n我还有%i秒终止&quot;,getppid(),getpid(),i--);            sleep(1);        &#125;        printf(&quot;子进程进入僵尸状态\\n&quot;);        exit(0);    &#125;    else&#123;        printf(&quot;我是父进程，我的ppid是%d,pid是%d\\n&quot;,getppid(),getpid());        while(1)        &#123;            int a = 10;           &#125;    &#125;           return 0;&#125;\n\n\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test1 | grep -v grep32080 30962 30962 32080 pts/0    30962 R+    1001   0:05 ./test130962 30963 30962 32080 pts/0    30962 S+    1001   0:00 ./test1[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test1 | grep -v grep32080 30962 30962 32080 pts/0    30962 R+    1001   0:06 ./test130962 30963 30962 32080 pts/0    30962 Z+    1001   0:00 [test1] &lt;defunct&gt;\n\n英语小课堂：defunct\n\n一般我们都会要求父进程回收子进程，不过这个得后续才能学到了！\nps循环监控脚本我们可以使用一个监控脚本来更方便的监控结果\nwhile :; do ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep;sleep 1; echo &quot;########################&quot;; done\n\n上面这个语句的作用是，每一秒执行一次ps jax | head -1 &amp;&amp; ps jax | grep test | grep -v grep命令，直到我们使用ctrl+c终止进程\n需要注意分隔符，while后面的是:;不要写成双冒号！\n3.3 长时间僵尸状态的弊端如果一个僵尸进程长时间不被处理，就容易出现内存泄漏！\n子进程的状态是用数据维护的，如果父进程一直不回收子进程，该子进程的task_struct就一直留存在内存中，这就是一定的内存泄漏。\n3.4 孤儿进程当一个进程的父进程先退出的时候，子进程就会变成孤儿进程\n\n为什么这里我们没有看到父进程进入Z或者X状态呢？那是因为这里父进程的父进程是bash，命令行回收了我们的父进程。\n可子进程为何还在这里呢？\n\n父进程退出之后，子进程并不会不见，而是会被1号进程（操作系统）领养。\n这时候我们可以把子进程称为孤儿进程\n\n注：1号进程又称init进程\n\n\n而操作系统领养之后的子进程，即便你使用ctrl+c也干不掉这个进程\n\n仔细观察，可以看到子进程被操作系统领养后，运行状态上的+不见了\n PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND32080  2842  2842 32080 pts/0     2842 S+    1001   0:00 ./test2 2842  2843  2842 32080 pts/0     2842 S+    1001   0:00 ./test2################################################################ PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND    1  2843  2842 32080 pts/0    32080 S     1001   0:00 ./test2\n\n前台和后台进程状态码上带有+号，代表进程是一个前台进程\n\n能被CTRL+C终止的都是前台进程\n后台进程一直在运行，会影响我们的命令行输入\n\n我们可以使用kill -9干掉该进程，干掉进程之后，就可以使用CTRL+C恢复正常的命令行了\n\n3.5 守护进程和精灵进程守护进程&amp;精灵进程：这两种是同一种进程的不同翻译，是特殊的孤儿进程，不但运行在后台，最主要的是脱离了与终端和登录会话的所有联系，也就是默默的运行在后台不想受到任何影响\n\n4.进程暂停T暂停一共有两种状态，一种是stopped，第二种是tarcing stop\n\n一般linux系统是用大T指代stopped，用小t指代tarcing stop\n4.1 T-stoppedkill发信号在之前的操作中，我们已经学过使用kill -9 pid来干掉一个进程，实际上kill命令能干的事情远不止这一个\nkill -l\n\n使用这个命令可以查看到kill命令支持什么操作\n\n其中我们要用到的是第19和第18，分别用于暂停/恢复一个进程\n#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;start!\\n&quot;);    while(1)&#123;        ;    &#125;    return 0;&#125;\n\n写一个啥事不干的死循环用于测试，可以看到该进程处于R+状态\n\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ kill -19 9503\n\n执行kill -19命令之后，我们可以看到该进程被终止，状态码变为大T\n\n进程暂停并不代表进程结束，这就好比我们看视频的时候暂停一样。你暂停了播放，但是播放器这个进程并不会直接终止！\n要想让这个进程重新运行，执行kill -18即可，进程恢复为R状态。此时也没有了+，代表这是一个后台进程\n\n PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND32080  9503  9503 32080 pts/0    32080 T     1001   0:55 ./test3######################## PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND32080  9503  9503 32080 pts/0    32080 R     1001   0:55 ./test3\n\n使用kill -9干掉该后台进程即可\n4.2 t-tarcing stoptarcing一词意为追踪，最简单的情况便是我们使用的gdb调试打断点\n\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps jax | grep test30493 12333 12333 30493 pts/1    12333 S+    1001   0:00 gdb test_g12333 12412 12412 30493 pts/1    12333 t     1001   0:00 /home/muxue/GIT/raspi/code/22-09-24_?程/test_g\n\n这时候test_g进程就是一个处于小t状态的进程\n\n5. 进程优先级\n权限：能还是不能的问题，决定进程能不能访问某种特定的资源\n优先级：进程可以访问该资源，但有先后顺序（运行队列）\n\n进程在排队获取资源的本质就是在确认优先级。这是因为系统的某些慢资源不够多个进程同时使用，这时候就需要让进程进入排队来先后访问。\n而优先级越高的进程，操作系统执行它的响应就会更快。其会把它插入到优先级低于它的进程之前，先运行这个“vip进程”，再运行那些“普通进程”\n5.1 linux进程优先级可以用下面的ps -la命令查看当前bash下的进程\n[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps -lF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 27595 30493  0  80   0 - 38587 -      pts/1    00:00:00 ps0 S  1001 30493 30492  0  80   0 - 29576 do_wai pts/1    00:00:00 bash[muxue@bt-7274:~/GIT/raspi/code/22-09-24_进程]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD1 S  1001 27546     1  0  80   0 -  1833 hrtime pts/0    00:00:00 test20 R  1001 27598 30493  0  80   0 - 38595 -      pts/1    00:00:00 ps\n\n其中的PRI和NI就是我们进程优先级的数据\n\nlinux的进程优先级&#x3D;priority_old+nice\nlinux下进程的默认优先级是80，PRI值越低，优先级越高\nNI值是进程优先级的修正数据，我们修改进程优先级，修改的是NI值而不是PRI\n\n这两个值允许的范围如下，Linux系统并不支持用户无节制的修改优先级\n-20 &lt;= NI &lt;= 1960 &lt;= PRI &lt;= 99\n\n5.2 使用top命令进行修改优先级linux下修改优先级的操作如下，运行test1程序后，先查看它的优先级信息\n[muxue@bt-7274:~]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 29632 30493 98  80   0 -  1833 -      pts/1    00:00:42 test11 Z  1001 29633 29632  0  80   0 -     0 do_exi pts/1    00:00:00 test1 &lt;defunct&gt;0 R  1001 30732 29713  0  80   0 - 38595 -      pts/0    00:00:00 ps\n\n在使用sudo top后，进入界面按r，输入需要设置的进程pid后，再输入需要调整的nice值\n\n\n[muxue@bt-7274:~]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 29632 30493 99  70 -10 -  1833 -      pts/1    00:02:41 test11 Z  1001 29633 29632  0  80   0 -     0 do_exi pts/1    00:00:00 test1 &lt;defunct&gt;\n\n这里可以看到，test1进程的优先级已经被我们改成了70\n再来尝试第二次，这次nice设置为20看看\n\n[muxue@bt-7274:~]$ ps -laF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 R  1001 30697 30493 98  99  19 -  1833 -      pts/1    00:00:16 test11 Z  1001 30698 30697  0  80   0 -     0 do_exi pts/1    00:00:00 test1 &lt;defunct&gt;\n\n诶，pid设置成20之后，为啥NI值变成了19，而PRI变成了99呢？\n\n依据我们以往的惯性思维，既然进程优先级&#x3D;priority_old+nice，那么修改了之后不应该是原本的70+20&#x3D;90吗？为什么是99呢？\n\n这是因为每一次设置的时候，priority_old都会被重置成80。所以可以直接记住，Linux下进程的优先级&#x3D;80+Ni值\nThe End感谢你看到最后，如果本篇博客有啥问题，欢迎在评论区提出！\n\n","categories":["玩上Linux"],"tags":["Linux","进程"]},{"title":"【leetcode】102. 二叉树的层序遍历（C语言+队列）","url":"/2022/04/20/code/leetcode/102%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"这道二叉树的题目相对来说毕竟难，所以又单独拿出来发一篇题解\n\n\n[TOC]\n102 层序遍历（较难😥）\nleetcode：102. 二叉树的层序遍历\n\n\n这道题相对来说就么有那么容易了，你可能和我一样，压根没看明白题目要求中的后两个参数是用来干嘛的\n\n/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes)&#123;&#125;\n\n看了一些题解，这才算理解了这道题的要求\n\n*returnSize：存放的是二叉树的层数\n**returnColumnSizes：存放的是二叉树每一层的节点个数\n返回值要求是int**：需要返回一个指针数组，该数组中的每一个元素是一个数组A，数组A保存了二叉树每一层的节点值\n\n\n0.错误思路最开始我的想法是，用单独的函数计算出树的节点个数和层级，再进行一次层序遍历来得到树的值。\n但很显然，这一思路在本题是搞不通的！🤔\n1.数组队列初始化在链式二叉树博客中，我讲述了利用队列来实现层序遍历的思路。这道OJ题目我们也是这么干的。不同的是，在我自己写的队列实现里，使用的是链式队列。而本题使用数组队列会好一点！\n#define MAX 2000int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) &#123;    if (root == NULL)        return;    struct TreeNode* Queue[MAX];//队列，存放节点的地址    int front = 0, tail = 0;//指向队头和队尾\n\n2.初始化数组这部分会毕竟绕，先一步一步来理解\n*returnSize = 0;//将二叉树层级初始化为0//存放二叉树的每一层节点的值int** ret = (int**)malloc(sizeof(int*) * MAX);//开辟一个数组来存放每一层的节点个数*returnColumnSizes = (int*)malloc(sizeof(int*) * (MAX / 2));\n\n\nret是一个指针数组，存放的是数组A，数组A里面是每一层的节点值。ret也就是题目要求的返回值\n*returnColumnSizes开辟一个数组来保存每一层的节点数\n\n这里其实returnColumnSizes没有啥二级指针的必要，但是既然题目给了是int**，我们就需要先*解引用再malloc开辟数组\n3.队列操作思路\n先让根节点入队列，tail++\n外层循环判断队列是否非空，如果非空就停止操作\n内层循环进行每一层的入队操作，这样才能得到每一层的节点值和节点个数\n在内层循环中创建ret数组的子数组，单独存放每一层的节点值\n最后将每一层的节点个数赋值给*returnColumnSizes数组，*returnSize++一次\n\n   struct TreeNode* head;   Queue[tail++] = root;//根节点入队   while (front != tail)   &#123;       int Csize = 0;//每一层的节点个数       int end = tail;       //end是每一层最末一个节点的指针。在后续的入队列操作中tail会改变，所以需要保存tail的值       ret[*returnSize] = (int*)malloc(sizeof(int*) * (end - front));       //为每一层开辟一个单独的数组来存放值       while (front &lt; end)       &#123;           head = Queue[front++];           ret[*returnSize][Csize++] = head-&gt;val;           //数组赋值，同时每一层的节点个数Csize++           if (head-&gt;left != NULL)               Queue[tail++] = head-&gt;left;           if (head-&gt;right != NULL)               Queue[tail++] = head-&gt;right;       &#125;       (*returnColumnSizes)[*returnSize] = Csize;//赋值每一层的节点个数       (*returnSize)++;//层数+1   &#125;return ret;\n\n外层循环结束后，此时ret数组就是题目要求的结果了，返回ret就可以了！\n\n这里有一个小问题，当树为空树时，层级应该是0。所以我们需要在第一行赋值*returnSize = 0;不然会执行出错\n\n\n这道题的思路是我看过题解之后才搞明白的，所以上面的只是一个思路的复现😭还是太菜了！\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","leetcode","C语言"]},{"title":"【leetcode】189. 轮转数组（C语言）","url":"/2022/03/13/code/leetcode/189%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","content":"问题来源\nleetcode 189. 轮转数组\n\n给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n输入: nums = [1,2,3,4,5,6,7], k = 3输出: [5,6,7,1,2,3,4]解释:向右轮转 1 步: [7,1,2,3,4,5,6]向右轮转 2 步: [6,7,1,2,3,4,5]向右轮转 3 步: [5,6,7,1,2,3,4]\n\n这道题的底部有一个进阶要求：\n\n进阶：\n\n尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。\n你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗\n\n\n正好最近学习了空间复杂度和时间复杂度，这里可以用于练习\n\n方法1-基本方法最基本的方法就是直接旋转，把最后一位数字移动到数组的第一位，然后将第二位开始的每一位往前移动一位\n\n需要先执行移动操作再替换第一个数\n\nvoid rotate(int* nums, int numsSize, int k) &#123;    k %= numsSize;    for (int i = 0; i &lt; k; i++)    &#123;        int tmp = nums[numsSize - 1];        for (int j = numsSize - 1; j &gt;0; j--)        &#123;            nums[j] = nums[j-1];        &#125;        nums[0] = tmp;    &#125;    return;&#125;\n\n这种算法的时间复杂度是O(k*N)，空间复杂度是O(1)\n这道题的k是常数，可以省略\n\n但很不幸，它在跑leetcode中非常长的测试用例的时候，还是没有跑过去，超时了\n\n方法2-额外开一个数组这种方法也非常简单，额外开辟一个数组，存储需要旋转的几个数字，然后将它们之前的数据存储到该数组的后半部分\n最后再把新数组复制回原来的数组中\nvoid rotate(int* nums, int numsSize, int k) &#123;    k %= numsSize;    int* num1 = (int*)malloc(sizeof(int) * numsSize);    int h = 0;    for (int i = numsSize - k; i &lt; numsSize; i++)    &#123;        num1[h++] = nums[i];    &#125;    for (int i = 0; i &lt; numsSize - k; i++)    &#123;        num1[i + k] = nums[i];    &#125;    memcpy(nums, num1, sizeof(int) * numsSize);    return;&#125;\n\n这个算法的时间复杂度是O(N)，空间复杂度是O(N)\n可以看到，最后的执行结果只打败了leetcode很小一部分人\n\n同时这个算法也不符合进阶要求中的“原地”\n\n方法3-三旋法（最优）和上面两个方法相比，三旋法相对来说较优，而且符合题目的进阶要求\n但是它需要一定的理解能力：\n假设我们需要旋转3个数字\n\n先将前SZ-K个数字逆置\n再将后k个数字逆置\n最后整体逆置\n\n这样就能得到我们想要的结果！\n1 2 3 4 5 6 7 //旋转3个4 3 2 1 5 6 7 //先逆置前7-3=4个4 3 2 1 7 6 5 //再逆置后3个5 6 7 1 2 3 4 //最后整体逆置，即为结果\n\n代码如下\nvoid Swap(int* nums, int sz)&#123;    int i = 0;    while (i &lt;  (sz/2))    &#123;        int tmp = *(nums+i);        *(nums + i) = *(nums + sz - i-1);        *(nums + sz - i - 1) = tmp;        i++;    &#125;&#125;void rotate(int* nums, int numsSize, int k)&#123;    k%=numsSize;    Swap(nums,numsSize-k);    Swap(nums+numsSize-k,k);    Swap(nums,numsSize);    return ;&#125;\n\n这个算法的时间复杂度是O(N)，空间复杂度是O(1)，符合题目进阶要求\n可以看到，最终执行结果比之前优秀多了！\n\n\n结语如果这对你有帮助，还请点个👍支持一下！\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","leetcode","C语言"]},{"title":"【leetcode】150. 逆波兰表达式求值","url":"/2022/07/18/code/leetcode/150%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"题目来源\n150. 逆波兰表达式求值\n\n\n思路逆波兰表达式又称为后缀表达式\n\n中缀 1 + 2 * 3\n后缀 1 2 3 + *\n\n我们需要将逆波兰表达式化为正常可计算的中缀表达式，再进行计算。题目所给的参数是后缀表达式，其操作的思路如下：\n\n遇到操作数，入栈\n遇到运算符，取栈顶两个连续数据进行计算，再将计算结果入栈\n\n看起来不难，是因为这道题已经是简化后的版本，其所给后缀表达式中没有出现()这种特殊优先级的操作。下面说一下把中缀转后缀的思路（本题没有涉及）\n如何将中缀表达式转为后缀？手工做法：\n以例2给出的中缀表达式为例，中缀表达式转换为后缀表达式的手工做法为：\n按照运算符的优先级对所有的运算单位加括号。例： ((a/b) + (((c*d) - (e*f))/g))把运算符号移动到对应括号的后面，然后去掉括号。例：((ab)/ (((cd)*(ef)*)-g)/+，去掉括号ab/cd*ef*-g/+\n\n以这个中缀表达式为例\n1 + 2 * 3 / 2 -5\n\n我们都知道，运算顺序应该是先计算2*3然后在计算6/2，最后计算1+3-5得出结果-1\n因为* /操作符的优先级高于加减，这里就需要注意这种情况。我们需要用一个栈来存放操作符\n\n遇到操作数的时候 先输出\n遇到操作符，和栈顶进行比较\n如果栈为空&#x2F;操作符优先级高于栈顶，入栈\n操作符优先级低于栈顶或和栈顶相同，出栈顶操作符\n\n\n最后将栈中的操作符全部出栈，就可以获得后缀表达式\n\n用上面这个思路走一遍，即为下面的情况（不知道这样写的大家能不能看明白）\n\n最终得到的结果如下\n1 2 3 * 2 / + 5 -\n\n即需要的后缀表达式\n我们可以用本题代码测试一下这个用例，得出的结果也是-1，正确！\n\n后缀转中缀https://blog.csdn.net/qq_29462849/article/details/93652583\n\n完整代码//https://leetcode.cn/problems/evaluate-reverse-polish-notation/submissions///150逆波兰表达式class Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; s;        for(auto&amp; ch : tokens)        &#123;            if(ch==&quot;+&quot;||ch==&quot;-&quot;||ch==&quot;*&quot;||ch==&quot;/&quot;)            &#123;                int right=s.top();                s.pop();                int left=s.top();                s.pop();                switch(ch[0])                &#123;                    case &#x27;+&#x27;:                        s.push(left+right);                        break;                    case &#x27;-&#x27;:                        s.push(left-right);                        break;                    case &#x27;*&#x27;:                        s.push(left*right);                        break;                    case &#x27;/&#x27;:                        s.push(left/right);                        break;                    default:                        break;                &#125;            &#125;            else&#123;                s.push(stoi(ch));            &#125;           &#125;        return s.top();    &#125;&#125;;\n\n\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","leetcode","C++"]},{"title":"【牛客网】HJ92 在字符串中找出连续最长的数字串","url":"/2022/09/07/code/leetcode/HJ92%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%BE%E5%87%BA%E8%BF%9E%E7%BB%AD%E6%9C%80%E9%95%BF%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%B2/","content":"HJ92 在字符串中找出连续最长的数字串\n题目来源 牛客网 HJ92\n\n描述输入一个字符串，返回其最长的数字子串，以及其长度。若有多个最长的数字子串，则将它们全部输出（按原字符串的相对位置）\n本题含有多组样例输入。\n数据范围：字符串长度 1 \\le n \\le 200 \\1≤n≤200 ， 保证每组输入都至少含有一个数字\n输入描述：输入一个字符串。1&lt;&#x3D;len(字符串)&lt;&#x3D;200\n输出描述：输出字符串中最长的数字字符串和它的长度，中间用逗号间隔。如果有相同长度的串，则要一块儿输出（中间不要输出空格）\n输入：abcd12345ed125ss123058789a8a72a6a5yy98y65ee1r2输出：123058789,9729865,2说明：样例一最长的数字子串为123058789，长度为9样例二最长的数字子串有72,98,65，长度都为2    \n\n\n题解代码这道题的思路很简答，从前往后遍历一遍，遇到字符串就开始计算count，并记录起始位置。最后再把起始位置和子串长度插入一个pair里面。\n需要注意的是，这里必须要用pair，因为题目要求中提到了，如果有多个相同长度的数字串，就需要一并输出，并加上最后位的,长度\n#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;//给定一个256字符的字符串，输出内部最长数字子串bool isNumStr(const char&amp; c)&#123;    return (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;);&#125;int main()&#123;    string s;//来源    while(getline(cin, s))    &#123;        //cout&lt;&lt;s&lt;&lt;endl;        //string ret_s;//结果        vector&lt;pair&lt;int,int&gt;&gt; v;//用来存放数字子串的位置        int begin = 0;//标记数字串的开始        int count = 0;//标记长度        int max = 0, mbegin;//上一次获取到的数据串长度和起始位置        int flag = 0;//标记位        for (int i = 0; i &lt; s.size(); i++)        &#123;            if (i &lt; s.size() - 1 &amp;&amp; isNumStr(s[i]) &amp;&amp; isNumStr(s[i + 1]))            &#123;                count++;                if (flag != 1) &#123;                    begin = i;//说明开始计算了                    flag = 1;                &#125;                //cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;&quot; c&quot;&lt;&lt;count&lt;&lt;&quot; b&quot;&lt;&lt;begin&lt;&lt;endl;            &#125;            else if (isNumStr(s[i]))//自己还是数字，但是下一位不是            &#123;                count++;                //cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;&quot; c&quot;&lt;&lt;count&lt;&lt;&quot; b&quot;&lt;&lt;begin&lt;&lt;endl;            &#125;            else &#123;                if (count &gt;= max) &#123;                    max = count;//最大的长度                    mbegin = begin;//最大长度的起始位置                    v.push_back(make_pair(count, begin));                &#125;                count = 0;//置零                flag = 0;            &#125;        &#125;                            if (count &gt;= max)        &#123;//循环结束后还需要一次判断，避免最后一个字符依旧是数字的情况            max = count;            mbegin = begin;            v.push_back(make_pair(count, begin));        &#125;                for(auto e:v)        &#123;            if(e.first==max)            &#123;                for(int i = e.second;i&lt;e.second+e.first;i++)                &#123;                    cout&lt;&lt;s[i];                &#125;            &#125;        &#125;        cout&lt;&lt;&quot;,&quot;&lt;&lt;max&lt;&lt;endl;//结束后统一输出max    &#125;    return 0;&#125;// 通过全部用例  运行时间4ms 占用内存448KB\n\n做这道题的起因-另外一道题咳咳，在学校上课的时候遇到了另外一道题目，这道题目只需输出一个最长数字子串就可以了，不需要关心长度相同的问题。\n\n我的思路和HJ92一样，就是遍历找到数字子串的长度和起始位置，然后插入一个新的string再cout进行输出。其中s和ret_s这两个变量都是string\n然后我就遇到了“奇葩情况”\n\n我还在本地测试了两次，发现“应该”是不会多打印空格什么的\n\n上图Linux G++，下图VS2019\n\n而我通过了上面的HJ92那道题，说明代码的思路是完全没有问题的，问题就出在输出这里\n\n在结束之后（这道题限时，我没能解决这个问题）我才发现自己是个大笨蛋！\n解决方法1：加斜杠0注意，加endl的方法我已经试过了，也不行\n其实在这里，我是有想过加\\0的，但是我-加-错-位-置了！！！应该给ret_S加，哼哼啊啊啊啊\n\n\n解决方法2：直接for打印这个方法我也没想到，既然我都已经知道起始位置和子串长度了，为啥不直接打印原本string里面的内容呢？直接for打印一下不就行了???\n只能说自己对容器的使用还不是很熟悉，知识没学到位啊，哭\n\n把自己挂在这里告诫后来者\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C++","牛客网"]},{"title":"【Python】在你的云服务/电脑上搭建Python环境","url":"/2022/08/10/code/note_Python/0%E8%AE%BE%E7%BD%AEpy%E7%8E%AF%E5%A2%83/","content":"本篇wiki会教你在你的电脑&#x2F;云服务器上搭建好Python环境\n\n\n创建你的Python环境要想让bot跑起来，没有一个Python的环境怎么办？\n本篇wiki会教你在你的电脑&#x2F;云服务器上搭建好可以运行KOOK机器人的Python环境\n1.windows在windows下写Python代码的方式有很多种，这里我介绍的是vs code\n如果你已经有了Pycham等代码环境，直接使用即可，也没必要看这篇wiki😋\n1.1安装Python\n进入Python官网 https://www.python.org/\n\n找到download，下载最新的Python版本包\n\n\n这里下载官方推荐的installer即可\n\n\n\n注：如果下载速度很慢，可以考虑使用迅雷等下载工具\n\n下载完成后，打开安装包，无脑下一步即可！\n安装完毕后，在windows开始中找到命令提示符，也就是windows平台的cmd工具。\n在里面输入Python，出现以下界面即为安装成功！\n\n\n1.2 安装VSC\n微软官网下载 https://code.visualstudio.com/\n\n在官网可以直接下载windows上的VSC，但是默认的下载链接下载是非常慢的！\nhttps://az764295.vo.msecnd.net/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n\n我们要做的就是把这个默认的下载链接改成国内的镜像源，下载速度就可以起飞！\n将下载地址中的az764295.vo.msecnd.net 更换为 vscode.cdn.azure.cn 更改后：https://vscode.cdn.azure.cn/stable/da76f93349a72022ca4670c1b84860304616aaa2/VSCodeUserSetup-x64-1.70.0.exe\n安装同样是无脑下一步！\n注：请不要修改VSC的安装位置，可能导致VSC无法正常运行Python程序！\n\n打开VSC后，界面是英文的。别急，让我们安装几个插件，就可以愉快使用了\n点击左侧的这个按钮进入插件面版\n\n\n在这里可以安装插件，需要安装的插件有下面这些\nChinese(Simplified)  //VSC汉化插件Python  //python环境Pylance //python环境Pip Manager //安装、管理pip包Terminal Here //方便我们打开终端vscode-json //json格式化插件\n下好上面的插件后，你的左侧应该会多出来一个pip manager的按钮，在这里可以下载你需要的第三方依赖库\n\n\n到这里，windows下的Python环境搭建就完成了！\n1.3 尝试写个最简单的Python代码在VSC里面创建一个test.py文件（这里会让你选择一个工作目录，弄一个新的文件夹就可以了）\n填入下面的代码\nprint(&#x27;hello world&#x27;)\n按CTRL+SHIFT+T打开命令面板（左下角齿轮也可以打开），输入Terminal Here，选择下面这个选项\n\n\n在VSC的底部会打开这样的一个终端\n\n\n我们在这里输入Python test.py，即可运行刚刚写的hello world代码\n如果一切正常，应该是会输出这样的结果\n\n完成配置！\n2.Linux平台关于Linux平台的Python环境搭建，可以参考01-Linux_install_python\n请不要直接使用ROOT用户操作！！\n\n\n下面是一次瞎升级python导致的错误记录,本人所用系统为CentOS 7.6\n\n2.1.不要瞎改配置文件我先是参考了一些奇葩博客，里面说道了下载完python新版本后，需要修改下面两个yum的配置文件\n实际上，压根不要修改这个配置文件！！！！\n/usr/bin/yum/usr/libexec/urlgrabber-ext-down\n\n说是要把开头的#!/usr/bin/python2.7修改为升级后的版本\n实际上，压根不要修改这个配置文件！！！！\n因为修改了之后执行yum会出现下面这个报错\n-bash: /usr/bin/yum: /usr/bin/python: 坏的解释器: 没有那个文件或目录\n\n\n参考这篇博客，把配置文件该回去才让yum复活【链接】\n\nyum是基于python2.7的，你没事把人家依赖环境改了干哈子？\n2.2.正确下载Python的方法参考下面这个博客\n\nhttps://blog.csdn.net/weixin_41829333/article/details/110141988\n\n2.3.要对症下药教程博客里面提到了，需要重新创建软连接，这是没错\nln -sf /usr/local/bin/python3.8 /usr/bin/pythonln -sf /usr/local/bin/python3.8-config /usr/bin/python-config\n\n但是，并不是所有人的软连接都是用上面的代码创建！\n在执行完python新版本的make后，你需要通过下面的两个指令找到新版本py的安装路径\n[root@bt-7274:~]# whereis pythonpython: /usr/bin/python3.6m /usr/bin/python3.6 /usr/bin/python /usr/bin/python2.7-config /usr/bin/python2.7 /usr/lib/python3.6 /usr/lib/python2.7 /usr/lib64/python3.6 /usr/lib64/python2.7 /etc/python /usr/local/bin/python3.9-config /usr/local/bin/python3.9 /usr/local/lib/python3.9 /usr/include/python3.6m /usr/include/python2.7 /usr/local/python3/bin/python3.7 /usr/local/python3/bin/python3.9-config /usr/local/python3/bin/python3.7-config /usr/local/python3/bin/python3.9 /usr/local/python3/bin/python3.7m-config /usr/local/python3/bin/python3.7m /usr/share/man/man1/python.1.gz[root@bt-7274:~]# which python/usr/bin/python\n\n比如我这里很明显能看出来，我的新版本python3.9是安装在/usr/local/bin里面，而不是/usr/bin里面的\n同时，当我执行py出错时，报错的路径也是下面这个\n-bash: /usr/local/bin/python3: 没有那个文件或目录\n\n所以创建软链接的时候，需要对症下药进行修改！\nln -s /usr/local/python3/bin/python3 /usr/local/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3\n\n这样才能让py成功升级！\n2.4.请重下依赖库下载依赖库的时候，其实是只安装在了对应版本的python里面，也就是我的旧版本python3.7.8\n所以更新好了之后，你需要重新下所有的依赖库\n","categories":["速通Python"],"tags":["Linux","阿狸开发日志","Python","VSC"]},{"title":"【牛客网】JZ65:不用四则运算符实现两数相加","url":"/2022/02/05/code/leetcode/JZ65%E4%B8%8D%E7%94%A8%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/","content":"[TOC]\n问题来源\n牛客网数据结构题目👉JZ65\n\n题目要求如图\n\n\n思考不能使用四则运算，根据过往的学习经历，我唯一能想到的就是位操作符和移位操作符\n例：使用位操作符进行int变量交换\n\n位操作符的使用先来回顾一下位操作符的作用\n位操作符操作的是整形的二进制位，它的操作数是2，比较两个整型的二进制位\n\n&amp;按位与：对应的二进制 全为1才是1，否则0\n|按位或：对应的二进制 有1为1，全为0才为0\n^按位异或：相同为0，不同为1\n\n\n比较一下正常的二进制相加和按位异或，发现按位异或是没有进位的相加\n\n\n原本应该是010，但是按位异或后是000\n1+1需要进位的1并没有进到下一位里去\n\n而使用按位与操作符，我们可以得到这两个数相加需不需要进位\n0 0 10 0 1//按位与-全1为10 0 1//&lt;&lt; -左移1位0 1 0\n\n这时候将按位与之后的结果和按位异或相加，就是我们的答案了\n但是题目要求不能使用加减\n\n再将按位与的结果0 1 0与 按位异或结果0 0 0进行按位与\n得到0 0 0 ，代表无需进位\n这时候将0 1 0与0 0 0 进行按位异或，即得出相加后的结果0 1 0\n\n\n这个例子比较简单，我们可以再用复杂一点的例子再证明它的可行性\n3：0011和5：0101\n\n\n\n操作\n结果\n\n\n\n\n1：按位与和左移\n0 0 1 0\n需要进位\n\n\n2：按位异或\n0 1 1 0\n\n\n\n3：1和2按位与，左移\n0 1 0 0\n需要进位\n\n\n4：1和2按位异或\n0 1 0 0\n\n\n\n5：3和4按位与，左移\n1 0 0 0\n需要进位\n\n\n6：3和4按位异或\n0 0 0 0\n\n\n\n7：5和6按位与，左移\n0 0 0 0\n无需进位\n\n\n8：5和6按位异或\n1 0 0 0\n得到结果为8\n\n\n根据这个思路，我们成功地完成了3和5的相加\n\n代码实现本题是接口型题目，我们只需要完成一个函数，实现相加的功能\n/** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * *  * @param num1 int整型  * @param num2 int整型  * @return int整型 * * C语言声明定义全局变量请加上static，防止重复定义 */int Add(int num1, int num2) &#123;    while(num2)    &#123;        int t = (num1 &amp; num2) &lt;&lt; 1;        num1 ^= num2;        num2 = t;    &#125;    return num1;&#125;\n\n不过我们可以自己写一个主函数来测试它的可行性\n如图，函数正确算出了两个数的和\n\n\n如果这篇博客帮到了你，还请点个赞啦~\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","C语言","牛客网"]},{"title":"【leetcode】剑指 Offer 56 - I. 数组中数字出现的次数（C语言）","url":"/2022/03/06/code/leetcode/%E5%89%91%E6%8C%87%20Offer%2056%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","content":"[TOC]\n题目说明\n来源：剑指 Offer 56 - I. 数组中数字出现的次数另外，260只出现以此的数字3这道题和本题是一样的\n\n难度：中等\n一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。\n示例 1：\n输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]\n\n示例 2：\n输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]\n\n\n限制：2 &lt;= nums.length &lt;= 10000\n\n方法1：常规做法最容易想到的常规做法：\n\n先对该数组进行qsort排序，再用for循环遍历，找到数组中下标i和i+1不相等的哪一项，这一项i即为只出现了一次的数字。\n\n若最末尾的数是目标数，需要进行判断并break，防止越界访问数组\n\n\n\n如果你不了解qsort，可以看这篇博客学习一下👉点我\n\n//方法1，太过简单，不够高级cmp(const void* e1, const void* e2)&#123;    return *(int*)e1 - *(int*)e2;&#125;int* singleNumbers(int* nums, int numsSize, int* returnSize) &#123;    int* result = (int*)calloc(2, sizeof(int));    int k = 0;    qsort(nums, numsSize, sizeof(int), cmp);//对原数组进行排序       int i = 0;    for (i = 0; i &lt; numsSize; i++)    &#123;        if (i == numsSize-1)//如果i是末尾数，需要进行判断        &#123;            result[k] = nums[i];            break;        &#125;        if (nums[i] == nums[i + 1])        &#123;            i ++;        &#125;        else        &#123;            result[k] = nums[i];            k++;        &#125;    &#125;    *returnSize = 2;    return result;&#125;\n\n\n\n方法2：异或求解复习一下位操作符很尬尴的是，本人对位操作符和移位操作符并不熟悉。经常把它们记混。几次测试的时候，涉及到这两个操作符的题目就是瞎蒙。\n后来发现位操作符和移位操作符似乎是测试中经常考察的对象，这里建议大家一定要把它们弄懂！\n\n\n\n语句\n操作符\n对应结果\n\n\n\nc &#x3D; a &amp; b\n&amp;按位与\n全1为1，否则0\n\n\nc &#x3D; a | b\n| 按位或\n有1为1，否则0\n\n\nc &#x3D; a ^ b\n^按位异或\n相同为0，不同为1\n\n\n\n题解异或有一个特点，a^a=0，a^0=a\n\n案例1输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]\n\n以题目所给参考2为例\n1^2^10^4^1^4^3^3 = 2^10\n\n可以看到，当我们把所给数据全部异或在一起的时候，其结果正好是我们需要的两个数相异或。\n但是我们好像并没有什么好的办法把已经异或了的两个数拆开\n这时候就需要对待查找的数据进行分组\n\n分组的目的：让两个单身狗分开到两组数据中\n这两组数据，除两个单身狗外，其他数字都出现了两次\n\n1 1 3 3 4 4 2 10\n\n为什么是这么分的呢？\n10: 10102:  001010^2=1000\n\n可见单身狗10和2之间，源码第四位才有差别\n1： 00012： 00103： 00114： 010010：1010\n\n这时候我们就可以通过第4位的差距，将数据分为两组\n\n第一组是1~4，它们的第4位都是0\n\n第二组是10，只有它的第四位是1\n\n\n再根据前面异或的特点，对这两组数字进行异或操作，即可得到单生狗10和2\n1^1^3^3^4^4^2 = 210 = 10\n\n\n案例2上面这组数据有些特殊，第二组里面只有10一个数字\n我们再来看一组数据\n1 2 3 4 5 1 2 3 4 6\n\n这一组数据中，单身狗是5和6\n5：01016：01105^6 = 0011\n\n可见5和6的源码中，第一、二位都有区别\n这里我们取第一位来分类即可\n1：00012：00103：00114：01005：01016：0110\n\n二进制第一位为1的数，放入一组\n1 1 3 3 52 2 4 4 6\n\n对它们进行异或操作，就可以得到单身狗5和6\n\n敲代码//方法2-异或int* singleNumbers(int* nums, int numsSize, int* returnSize) &#123;\t//1.全部异或在一起    int i = 0;    int k = 0;    for (i = 0; i &lt; numsSize; i++)    &#123;        k ^= nums[i];        //4^1^4^6 = 1^6    &#125;    //2.判断k的二进制第几位是1    int set = 0;    for (i = 0; i &lt; 32; i++)    &#123;        if (((k &gt;&gt; i) &amp; 1) == 1)//注意操作符优先级        &#123;            set = i;//第i位为1            break;        &#125;    &#125;    //3.以第set位为1进行分组，可以将这两个数分开    int n = 0;    int m = 0;    for (i = 0; i &lt; numsSize; i++)    &#123;        if (((nums[i] &gt;&gt; set) &amp; 1) == 1)        &#123;            n ^= nums[i];        &#125;        else        &#123;            m ^= nums[i];        &#125;    &#125;        int* result = (int*)calloc(2, sizeof(int));    //返回的数组必须用动态内存管理来创建    result[0] = n;    result[1] = m;    *returnSize = 2;    return result;&#125;\n\n验证自己整一个main函数来测试一下代码是否能达到要求，成功！\n\n做接口题的时候，如果出现输出错误的情况，可以自己写一个main函数并调试来找出错误\n\n\n可以看到，运行的用时远远小于方法1的用时\n击败了92.9%的用户！\n\n你学会了吗😍\n\n如果这篇博客对你有帮助，点个👍再走呗~\n\n摸鱼之发现另外一道一样的题\nhttps://leetcode.cn/problems/single-number-iii/submissions/\n\nclass Solution &#123;public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;        //1.全部异或在一起        int numsSize=nums.size();        int i = 0;        int k = 0;        for (i = 0; i &lt; numsSize; i++)        &#123;            k ^= nums[i];            //4^1^4^6 = 1^6        &#125;        //2.判断k的二进制第几位是1        int set = 0;        for (i = 0; i &lt; 32; i++)        &#123;            if (((k &gt;&gt; i) &amp; 1) == 1)//注意操作符优先级            &#123;                set = i;//第i位为1                break;            &#125;        &#125;        //3.以第set位为1进行分组，可以将这两个数分开        int n = 0;        int m = 0;        for (i = 0; i &lt; numsSize; i++)        &#123;            if (((nums[i] &gt;&gt; set) &amp; 1) == 1)            &#123;                n ^= nums[i];            &#125;            else            &#123;                m ^= nums[i];            &#125;        &#125;                vector&lt;int&gt; retV;        retV.push_back(n);        retV.push_back(m);        return retV;    &#125;&#125;;\n","categories":["把题目都给刷干净"],"tags":["OJ刷题","leetcode"]},{"title":"【C语言】蓝桥杯/ACM竞赛入门 A+B for Input-Output Practice","url":"/2021/10/26/code/leetcode/%E8%93%9D%E6%A1%A5%E6%9D%AFA+B/","content":"[TOC]\n【C语言】蓝桥杯&#x2F;ACM竞赛&#x2F;A+B上次参加了学校的蓝桥杯校队选拔“集训”\n第一次“测试”就直接被考傻了，虽然都是我“好像”学过的内容，但我里里外外真的看不出来到底怎么写，太离谱了！\n而且学长用的都是C++，我只学了c语言，后面的题目完全看不懂了。\n当然，归根结底还是我太菜了\n在这里把我搞了好久终于弄懂的A+B题目分享给大家\n\n开始集训：A+B不有手就行？\n结束后：我手呢?\n\n\n注：题目是英文的！！！！\n\n\nA+B for Input-Output Practice (I)Problem Description \nYour task is to Calculate a + b. \nToo easy?! Of course! I specially designed the problem for acm beginners.  \nYou must have found that some problems have the same titles with this one, yes, all these problems were designed for the same aim.  \nInput \nThe input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line.  \nOutput \nFor each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input.     \nSample Input \n1 510 20\n\nSample Output \n630 \n\n\n\n这道题看起来非常简单，我一上来就打上了两行scanf，啪的一下就提交了\n然后系统啪的一下给我返回了一个大大的红色WRONG ANSWER\n正确做法如下：\n#include&lt;stdio.h&gt;  int main()  &#123;    int a,b;    while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF)       printf(&quot;%d\\n&quot;,a+b);  &#125;   \n\n不能直接使用两行scanf的原因是\n题目需要的是这串代码能完整地使用多次，而不是简单的只执行两次\n在while里使用EOF的原因这里使用eof，可以让程序在未输入错误的情况下一直进行循环计算a+b\nscanf函数的返回值\nscanf函数返回成功读入的数据项数，读入数据时遇到了“文件结束”则返回EOF。\n如：scanf(“%d %d”,&amp;a,&amp;b);\n函数返回值为int型。如果a和b都被成功读入，那么scanf的返回值就是2；\n如果只有a被成功读入，返回值为1；\n如果a和b都未被成功读入，返回值为0；\n如果遇到错误或遇到end of file，返回值为EOF。end of file为Ctrl+z 或者Ctrl+d。\n[摘自百度知道用户@纵横竖屏的回答]\n\nEOF的值为-1，但不能简单的用-1代替EOF\n\nA+B for Input-Output Practice (II)Problem Description \nYour task is to Calculate a + b. \nInput \nInput contains an integer N in the first line, and then N lines follow. Each line consists of a pair of integers a and b, separated by a space, one pair of integers per line.  \nOutput \nFor each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input.  \nSample Input \n21 510 20\n\nSample Output \n630\n\n\n\n这道题的意思其实就是在键入需要相加的数字之前，先键入需要相加的数字组数（也可以理解为行数）\n要求我们用循环的方式完成“相加数字行数”的操作\n完成n行后需要跳出该a+b的循环\n#include&lt;stdio.h&gt;int main()&#123;    int a, b;    int i, j;    int n;    scanf(&quot;%d&quot;, &amp;n);//n即为行数    int sum[20] = &#123; 0 &#125;;    for (i = 0; i &lt; n; i++)    &#123;        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);        sum[i] = a + b;    &#125;    for (j = 0; j &lt; n; j++)    &#123;        printf(&quot;%d\\n&quot;, sum[j]);    &#125;&#125;\n\n\nA+B for Input-Output Practice (III)Problem Description \nYour task is to Calculate a + b. \nInput \nInput contains multiple test cases. Each test case contains a pair of integers a and b, one pair of integers per line. A test case containing 0 0 terminates the input and this test case is not to be processed.  \nOutput \nFor each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input.  \nSample Input \n1 5 10 200 0 \n\nSample Output \n630\n\n这道题的要求是a+b的程序在读取到两个0 0的时候会退出循环\n且代码不会处理这两个0 0（把它们当作循环结束标志）\n#include&lt;stdio.h&gt;int main()&#123;\tint a = 0, b = 0, c;\twhile (1)\t&#123;\t\tscanf(&quot;%d%d&quot;, &amp;a, &amp;b);\t\tif (a == 0 &amp;&amp; b == 0)//判断键入的是否为0 0\t\t&#123;\t\t\tbreak;//是0 0，退出循环\t\t&#125;\t\telse//不是0 0，继续运行a+b\t\t&#123;\t\t\tc = a + b;\t\t\tprintf(&quot;%d\\n&quot;, c);\t\t&#125;\t\t\t&#125;\treturn 0;&#125;\n\n\nA+B  for  Input-Output  Practice (IV)Description:\nYour task is to Calculate the sum of some integers.\nInput:\nInput contains multiple test cases. Each test case contains a integer N, and then N integers follow in the same line. A test case starting with 0 terminates the input and this test case is not to be processed.\nOutput:\nFor each group of input integers you should output their sum in one line, and with one line of output for each line in input.\nSample Input:\n4 1 2 3 45 1 2 3 4 50 \n\nSample Output:\n1015\n\n与前面的两个数字相加不同，这道题的要求是，先输入你需要相加的数字的个数，再依次键入数字\n遇到0的时候停止循环\n\n这个0必须是第一个数字，即代表需要“0个数字相加”\n如果是需要相加的数字里有0，不应退出循环\n\n#include&lt;stdio.h&gt;int main() &#123;\tint n, sum, i, t;\twhile (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0) //判断是否等于0\t&#123;\t\tsum = 0;\t\tfor (i = 0; i &lt; n; i++) \t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;t);\t\t\tsum = sum + t;//不断往sum里面加数字\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, sum);\t&#125;&#125;\n\n\nA+B  for  Input-Output  Practice (V)Description:\nYour task is to calculate the sum of some integers.\nInput:\nInput contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line.\nOutput:\nFor each group of input integers you should output their sum in one line, and with one line of output for each line in input.\nSample Input:\n24 1 2 3 45 1 2 3 4 5\n\nSample Output:\n1015\n\n这道题和上一道题的要求差不多，结合了第二题的内容，即我们在键入需要相加的数字之前，要先键入“行数”\n当然它也少了在遇到0的时候退出循环\n#include&lt;stdio.h&gt;int main() &#123;\tint n, a, b, i, j, sum;\tsum = 0;\twhile (scanf(&quot;%d\\n&quot;, &amp;n) != EOF) \t&#123;\t\tfor (i = 0; i &lt; n; i++) \t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;b);\t\t\tfor (j = 0; j &lt; b; j++) \t\t\t&#123;\t\t\t\tscanf(&quot;%d&quot;, &amp;a);\t\t\t\tsum += a;\t\t\t&#125;\t\t\tprintf(&quot;%d\\n&quot;, sum);\t\t\tsum = 0;\t\t&#125;\t&#125;&#125;\n\n\nA+B  for  Input-Output  Practice (VI)Description:\nYour task is to calculate the sum of some integers.\nInput:\nInput contains multiple test cases, and one case one line. Each case starts with an integer N, and then N integers follow in the same line.\nOutput:\nFor each test case you should output the sum of N integers in one line, and with one line of output for each line in input.\nSample Input:\n4 1 2 3 45 1 2 3 4 5\n\nSample Output:\n1015\n\n这道题和第四题很像，就缺少了遇到0停止\n#include&lt;stdio.h&gt;int main() &#123;\tint n, sum, i, t;\twhile (scanf(&quot;%d&quot;, &amp;n) != EOF) \t&#123;\t\tsum = 0;\t\tfor (i = 0; i &lt; n; i++) \t\t&#123;\t\t\tscanf(&quot;%d&quot;, &amp;t);\t\t\tsum = sum + t;\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, sum);\t&#125;&#125;\n\n\nA+B  for  Input-Output  Practice (VII)Description:\nYour task is to Calculate a + b.\nInput:\nThe input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line.\nOutput:\nFor each pair of input integers a and b you should output the sum of a and b, and followed by a blank line.\nSample Input:\n1 510 20\n\nSample Output:\n630\n\n这道题多了一个要求，“followed by a blank line.”\n需要我们在代码完成后，跟着打印一个空行，也就是\\n\n#include&lt;stdio.h&gt;int main()&#123;    int a, b;    while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) != EOF)        printf(&quot;%d\\n&quot;, a + b);        printf(&quot;\\n&quot;);//打印空行    return 0;&#125;\n\n\nA+B  for  Input-Output  Practice (VIII)Description:\nYour task is to calculate the sum of some integers.\nInput:\nInput contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line.\nOutput:\nFor each group of input integers you should output their sum in one line, and you must note that there is a blank line between outputs.\nSample Input:\n34 1 2 3 45 1 2 3 4 53 1 2 3\n\nSample Output:\n10156\n\n这道题的要求结合了上面的题目\n\n需要先键入“行数”\n需要在相加之前键入 需要相加的数字的个数\n打印答案后需要再打印一个 空行\n\n也不怕大家笑话，这道题是我抄的，原博客在这 [点我]\n\n原博客中在for循环的scanf前多了一个if(i&#x3D;&#x3D;0)的代码，我实在没看懂这句代码的意义，去掉之后系统依旧判对！\n\n#include&lt;stdio.h&gt;int main()&#123;    int test,t=0;     scanf(&quot;%d&quot;,&amp;test);//行数    while(test--)//每执行一次，减少一行    &#123;    int s=0,i;    int n,a[1000];//用数组的方式完成相加    scanf(&quot;%d&quot;,&amp;n);//需要相加的数字的个数    for(i=0;i&lt;n;i++)    &#123;            scanf(&quot;%d&quot;,&amp;a[i]);            s+=a[i];    &#125;    t++;    if(t&gt;1)        printf(&quot;\\n&quot;);    printf(&quot;%d\\n&quot;,s);    &#125; return 0;&#125;\n\n\n呼！终于写完这篇博客了\n如果这对你有帮助，还请点赞关注收藏吧！\n这对我真的很重要！\n","categories":["把题目都给刷干净"],"tags":["OJ刷题"]},{"title":"【Python】动手写一个git自动上传脚本！","url":"/2022/09/02/code/note_Python/1git%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E8%84%9A%E6%9C%AC/","content":"本篇博客来教你用Python写一个简单的git自动上传脚本\n\n\n前言为什么需要一个这样的东西？\n有的时候，我的学习代码其实没啥好commit的，写一个自动上传的脚本，就可以自动执行完所有的命令，而不需要自己手动进行git三板斧操作\n\n项目代码已开源  https://gitee.com/ewait/learn_python_code/tree/master/code/22-09-02%20auto_git\n\n效果如下把EXE文件丢进你的git仓库路径，点一下就会自动执行命令\n\n\n打开你的仓库可以看到，成功上传了\n\n源码实现其实很简单，就是用OS往系统的命令行里面写命令而已\nimport osimport timedef GetTime(): #获取当前时间    return time.strftime(&quot;%y-%m-%d %H:%M:%S&quot;, time.localtime())#修改默认的提交信息commit_msg=f&quot; \\&quot;Code updated: &#123;GetTime()&#125;\\&quot; &quot;#git提交命令cmd_1 = &quot;git status&quot;cmd_2 = &quot;git add --all&quot;cmd_3 = &quot;git commit -m&quot;+commit_msgcmd_4 = &quot;git push&quot;print(&quot;[开始] 执行git自动上传&quot;)print(&#x27;[CMD]&#x27;,cmd_1)os.system(cmd_1)#显示当前动态print(&#x27;[CMD]&#x27;,cmd_2)os.system(cmd_2)#添加所有文件更改到工作区print(&#x27;[CMD]&#x27;,cmd_3)os.system(cmd_3)#自动commitprint(&#x27;[CMD]&#x27;,cmd_4)os.system(cmd_4)#push上传print(&quot;[结束] 完成git自动上传&quot;)print(&quot;窗口将在5s后关闭...&quot;)time.sleep(5)#休眠5秒可以看清楚结果\n\n这里的commit信息非常粗暴，就是当前的时间。所以如果你是在写项目，那肯定还是好好写commit信息的好。不然到时候想回退版本都不知道往哪儿回退😂\n利用pyinstaller打包成exe在windows命令行中，安装pyinstaller包\npip install pyinstaller\n\n安装完成之后，在命令行中输入pyinstaller，大概率会报错\nPS D:\\MyCode\\Python\\code\\22-09-02 auto_git&gt; pyinstallerpyinstaller : 无法将“pyinstaller”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ pyinstaller+ ~~~~~~~~~~~    + CategoryInfo          : ObjectNotFound: (pyinstaller:String) [], CommandNotFoundException    + FullyQualifiedErrorId : CommandNotFoundException\n\n这时候如果你去搜教程，什么添加环境变量啊巴拉巴拉的，很麻烦，而且还不一定有用\n\n在我的win11上，添加环境变量就是无效的\n\n这时候我们只需要找到python的安装路径，和里面存放pip包的路径\n在我的电脑上，存放路径如下。如果你找不到，可以直接全盘搜索pyinstaller.exe\nC:\\Users\\用户名\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\Scripts\\pyinstaller.exe\n\n然后我们就可以直接执行下面的命令了\nC:\\Users\\用户名\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\Scripts\\pyinstaller.exe -F 文件名.py\n\n随后pyinstaller就会开始打包，并在当前路径下生成一个build和dist文件夹。其中dist文件夹里面就存放了我们的exe文件\n\n利用ResourceHacker修改exe文件的icon实际上，pyinstaller是可以直接修改exe文件的icon的，命令如下\nC:\\Users\\用户名\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\Scripts\\pyinstaller.exe -F -w -i 图标.ico 文件名.py\n\n在我的电脑上，图标的确修改成功了，但是运行的时候，会多次弹出很多个命令行，非常不雅观！\n所以我就不用pyinstaller来生成图标，而是采用第三方软件ResourceHacker（安装包自行百度）\n\n点击图标组里面的图标\n\n右键这个0:0，选择“替换图标”，找到你想要的图标进行替换即可\n图标只支持.ico文件，你可以用下面这个网站进行jpg转ico\n\nhttp://www.ico51.cn/\n\n修改好后，需要点绿色的保存按钮。然后就修改成功了\n\n\n如果你发现没有修改成功，可能是因为windows缓存的问题，重启电脑即可！\n然后你就可以把这个exe丢到任何你想访到的git仓库路径下，自动上传文件啦！\n","categories":["速通Python"],"tags":["git","Python"]},{"title":"【方法分析】准大学生如何自学C语言","url":"/2021/08/24/code/note_c/0.C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/","content":"准大学生如何自学C语言@[TOC]\n虽说现在已经接近我们最长的且无忧无虑的暑假的尾声\n但我估摸着很多小伙伴还是和我一样整天摸鱼，不知不觉就浪费了一天\n（其实只有我在摸鱼对吗，流下了不争气的泪水）\n不扯这些没用的，进入今天的正题\n本篇博客和大家分享一下我是如何自学C语言的，以及如何做学习笔记\n学习方法各不相同，请以自身情况为准\n一、找寻一个优质教学视频好的教学资源永远是我们学习的第一步\n在这里我建议以视频为主，书本为辅助\nC语言的书籍繁多而杂，有很多热销书籍并非出自名门大家，有纰漏在所难免。作为初学者的我们肯定看不出这些纰漏，但它可能会把我们的学习引入死胡同。\n视频同样也会有错误的地方，这也是为何我们需要寻找优质教学视频\n在看视频的基础上，复以书本练习为辅助，方为学习妙计（个人观点）\n在这里强烈推荐b站比特鹏哥的C语言教学视频 连接\n\n讲的非常非常非常详细，比我之前在某堂在线找到的不知名视频好太多了（那个视频里老师就对着你念ppt，枯燥乏味无干货）\n这里推荐大家直接去看最新版本的视频，画质更好。内容新旧基本是一样的\n找完视频之后请立马开动，收进收藏夹只会让你开学了进度还是0%\n不过想必来csdn看博客的你已经不是小菜鸡了（doge）\n二、使用优质编译器拒绝devc++学习C语言\n当然，它肯定能用，我也推荐你在电脑里面下一个devc++\n但是它不适合日用学习！！\n理由非常简单，让我们看看VS2019和devc++在同一个代码下的界面\n\n请问那边更容易让你眼花缭乱？视觉疲劳？\n(你要说vs颜色太多眼花缭乱，那我无力反驳)\n\nvs2019同样可以改成白色背景，但深色对比度更高推荐深色\n\n同样的，当我们输入库函数的时候，vs可以帮你补充剩下函数\n而devc++就需要看你背单词的功力了\n\n而且在遇到代码错误的时候，vs2019能更准确地报出错误的地方，\n有些中英文半角错误的符号，如分号、逗号。vs2019都会用一个小波浪线标出，而devc++莫得提示\n（讲道理初学的我最常犯的错误就是打错中英文半角+打错函数名……）\n\n前面提到建议在电脑里面下个devc++，因为vs2019不能直接运行.c文件，必须要把它放在一个“项目”里面才行\n对于单个文件的运行来说devc++更方便，可以把它当作一个简易的.cpp和.c的运行器\nVS2019可以直接在官网下载社区版本，请不要下载VS code，对于初学者来说它的初始化设置非常麻烦！\n官网链接&#x3D;&gt;visualstudio.microsoft.com\n(由于微软的土豆服务器，我打不开官网，自然截不到图……太棒了微软)\n\n博客写到一半回去瞅了一眼，终于打开了\n我们需要下载的是2019的社区版本\n\n其次我们还需要收藏几个用于学习时查找资料的网站\n它们主要是用于查找函数定义的，具体方法我在之前的博客中已有过分享 [链接]网站推荐：\ncplusplus.com - The C++ Resources Network \ncppreference.com\n三、安排一个电子笔记初学c语言时的知识繁多而杂，不记笔记的话很多知识点都是左耳进右耳出（至少我是这样）\n纸质笔记本在这种需要大量代码练习的学习中效率太低\n这时候就得请出我们的电子笔记本了\n在这里给大家推荐个人认为最好用的OneNote\n\n如果你是笔记本用户，有出厂赠送的OneNote2016\\2019，直接用即可\n台式机用户OneNote多半是装系统就自带了的。没有的话可以去微软商店下一个OneNote for WIN10，或微软官网下载OneNote2019\n\n\n优点：IOS\\安卓\\WIN\\MAC全平台同步，免费！\n缺点：微软土豆服务器，有时候跨平台同步极慢。\n\n同时建议大家下载一个snipaste，作为截图软件辅助我们的电子笔记\n\nOneNote自带的截图会自动给你添加一个截图时间，有点影响界面观感\n\n\n新建一个笔记本，命名为c语言\n\n\nOneNote主要的界面就是这种三段式的笔记夹。大家可以参照我的分类，把大类知识点放在第一个分区，小类放在第二个\n这样我们后期复习or回看遗忘知识点也会更加方便\n这里建议大家给每个小类知识点都做上数字序号，且不要重复\n这样就可以在已有的笔记内表明这个知识点和另外一个知识点的联系\n\nOneNote的插入链接功能同样可以插入笔记本内页的连接\n如图，我们右击16EOF，点击”复制指向页面的链接“\n\n然后在我们想插入这个链接的位置插入\n\n\n随后点击它，就能直接跳转到指定的笔记本页面\n在复习和知识点联动的时候非常方便实用\nOneNote还有其他非常丰富的功能，在这里推荐大家看这个视频学习OneNote的用法，博客里就不再展开了\n岷|你不得不知道的OneNote功能|电子笔记能有多强！bilibili\n需不需要一个ipad来辅助学习？提到电子笔记，很多人都会想到用平板来做笔记\n这里我的建议是\n-有ipad或其他平板的用户可以购入平替笔尝试\n\n不要直接买高贵的原装笔，对于做笔记来说无济于事，特别是ipad\n发现不合适的时候你想二手出or吃灰就是浪费钱了，平替笔90一支不想用了也可以留着\n最好在购入七天内使用并判断这种方式适不适合你，这样不适合还能无理由退了\n\n\nipad用户推荐益b思的5代青春版平替笔，98一支，真的不是广告，我个人觉得还行顺便提一句而已！\n\n-如果你没有平板，请不要给自己创造需求然后喜加一，因为平板联网激活后就不给退货的！\n在我两周的win电脑+平板做笔记的学习中，有如下问题需要注意\n\nOneNote同步需要一定时间，在电脑截图后ipad端OneNote同步至少20秒。服务器抽风的话就祝自己好运了\n在ipad做笔记可能会让你漏掉老师所讲知识点，因为注意力不在电脑屏幕上，导致回退视频\n请不要在ipad打开你的qq，不然可能做着做着就去聊天了……\n\n当我尝试丢掉平板直接用电脑做笔记的时候，发现效率直线上升！\n所以说用平板做笔记也是我自己给自己创造的需求（笑哭.jpg）\n四、除工具以外的学习方法上述三点都是围绕学习工具来展开的，现在说说其他的一些个人经验\n1.专心致志，不要让其他东西分心现在这个阶段，我们的身心是很放松的，自学c语言其实是在给暑假生活的末尾加料\n这种放松会让你我觉得C语言的学习并不是什么必须要做的、非做不可的事情\n所以手机就会成为你学习路上最大的阻碍……（以下均为本人情况，请勿对号入座）\n\n消息来了看一眼\n\n这部分好像我会，刷会手机\n\n\n虽然我知道这万万不可，可就是控制不住自己这双手\n\n好吧，既然打不过，那我们就跑啊！\n手机关闭WiFi，放在你不能直接够到的地方\n同样的，电脑也不要登录qq，wx，保持无线电静默，专心看视频学习\n\n我觉得咱们这个年纪应该没有非回不可的消息，父母找自己多半直接打电话\n\n2.多练习，多练习，多练习学C语言和学数学一样，一定要多刷题（写代码）\n在看视频的同时，跟着教学内容自己尝试着写写那些代码\n别觉得视频里都打了没必要自己再打一遍\n实际上照着打都会有一堆错误……\n买了书本的小伙伴可以照着书本上的示例代码练习\n在练习的途中更容易发现自己的问题，从而获取更多知识\n3.复习！前面提到了做笔记之事，笔记最主要的目的就是为了方便我们日后的复习。\n这里建议平时多去看看记录下来的操作符、字符类型、转义字符等等极其容易遗忘又经常用的上的知识点\n不然有时候就真的只能看着代码蒙蔽\n遇到新的小知识点的时候也要及时对笔记进行补充\n\n结语以上就是本c语言初学者+准大一同大家的学习方法的分享\n这方法可能不适合你，有些朋友可能更偏爱纸笔笔记，这都是OK的\n学习方法各有异同，但我们都有一个为通向未来大道而努力的心\n这就够了~\n感谢你看到这里，点赞+关注再走呗！万分感谢！\n","categories":["C语言初识"],"tags":["C语言"]},{"title":"【Python】valorant-api-docs","url":"/2023/01/15/code/note_Python/2valorant-api-docs/","content":"欢迎您使用阿狸瓦洛兰特商店ApiApi链接为val.outpost54.top。只有这一个网址！\nApi是一个网页链接，能够方便的被用户使用或被开发者调用，以实现特定功能\n和阿狸机器人一样，此api后台不会打印任何params参数。只要链接不被攻击，你的账户密码只有你自己使用的时候看得到！很是安全\n\n阿狸帮助频道有一个免费的token，加入帮助频道即可领取；有任何问题，也欢迎加入帮助频道与我交流🎶kook帮助服务器邀请链接\n\n\n\n\n接口\n说明\n状态\n\n\n\n&#x2F;shop-img\n直接返回并跳转商店的图片\n正常\n\n\n&#x2F;shop-url\n以json格式返回商店图片url\n正常\n\n\n&#x2F;tfa\n邮箱验证接口，需和/shop-url接口配合使用\n正常\n\n\n1.使用示例查询每日商店的链接如下，调用/shop-img接口，浏览器会直接跳转图片，适合普通用户快捷查看当日每日商店\n由于该接口会直接跳转到图片，所以不支持开启了邮箱验证的用户\nhttps://val.outpost54.top/shop-img?token=API的密钥&amp;account=账户&amp;passwd=密码\n\n直接丢浏览器里面打开就行，想看商店直接用这个链接看就行辣，可以浏览器收藏一下哦！\n\n添加第四个参数&amp;img_src=图片url，此参数用于自定义背景图\n添加第五个参数&amp;img_ratio=图片比例，将此参数设置为1，代表背景图是 1-1 的正方形，最终的成果图也将是正方形；默认比例为 16-9\n注：如果选择 1-1 的返回图，则图中不会带vp和rp剩余\n\n若要添加自定义背景图，则链接应该如下\nhttps://val.outpost54.top/shop-img?token=API的密钥&amp;account=账户&amp;passwd=密码&amp;img_src=背景图片链接\n\n如果背景图是1-1的正方形\nhttps://val.outpost54.top/shop-img?token=API的密钥&amp;account=账户&amp;passwd=密码&amp;img_src=背景图片链接&amp;img_ratio=1\n\n自定义背景图请求示例（16-9）\nhttps://val.outpost54.top/shop-img?token=API的密钥&amp;account=账户&amp;passwd=密码&amp;img_src=https://img.kookapp.cn/assets/2022-09/KV5krdRx080qo0f0.jpg\n\n结果示例图（16-9）\n\n\n结果示例图（1-1）\n\n\n2.注意事项自定义背景图的url请使用国内可以直接访问的图床，如阿里云OSS/路过图床/白嫖kook的图床等。否则无法获取到图片链接的内容，api会报错；\n\n\n路过图床：https://imgse.com/\n薄荷图床：https://riyugo.com/\nkook图床白嫖教程：https://img.kookapp.cn/assets/2022-12/nICYcewY8a0u00yt.png\n\n\n欢迎大家向朋友宣传此Api，但请不要恶意连续多次调用\n3.开发者接口由于服务器是个6m小水管，再加上刚开放的时候本地缓存不足，画图耗时长。所以响应很慢，大约12秒。所以，我估摸着也没有开发者愿意用这种慢吞吞的api吧？\n好处就是后台包装了图片处理+riot登录，你只需要传入账户密码，剩下的交给api解决！\n注：只有code 0才是获取正常，200/400 都是有错误，会返回错误的原因。\n3.1 &#x2F;shop-url如果你是开发者，请使用/shop-url来获取json格式的结果\nhttps://val.outpost54.top/shop-url\n\n请求方法：GET\n速率限制：10r/m\n\n\n\nparams参数\n说明\n是否必填\n\n\n\ntoken\nAPI token\n是\n\n\naccount\n拳头账户\n是\n\n\npasswd\n拳头账户密码\n是\n\n\nimg_src\n自定义背景图的url链接\n否\n\n\nimg_ratio\n自定义背景图比例，值为1代表正方形\n否\n\n\n返回示例\n&#123;    &quot;code&quot;: 0,     &quot;message&quot;: &quot;https://img.kaiheila.cn/attachments/2022-10/12/1GaII87UTd0zk0k0.png&quot;,     &quot;info&quot;: &quot;商店图片获取成功&quot;&#125;\n\n3.2 &#x2F;tfa此接口用于两步验证，适用于开启了邮箱验证的用户；\n您需要先请求 /shop-url 接口，在用户获取到验证码后，再请求本接口\nhttps://val.outpost54.top/tfa\n\n请求方法：POST\n\n\n\nparams参数\n说明\n是否必填\n\n\n\ntoken\nAPI token\n是\n\n\naccount\n拳头账户\n是\n\n\nvcode\n邮箱验证码\n是\n\n\n返回示例\n&#123;    &quot;code&quot;: 0,     &quot;message&quot;: &quot;email verify code post success,wait for shop img return&quot;,     &quot;info&quot;: &quot;两步验证码获取成功，请等待主接口返回&quot;,    &quot;vcode&quot;: 114514&#125;\n\n\n4.Python示例代码import requestsurl = &quot;https://val.outpost54.top/shop-url&quot;params = &#123;    &quot;token&quot;:&quot;api-token&quot;,    &quot;account&quot;: &quot;拳头账户&quot;,    &quot;passwd&quot;: &quot;拳头密码&quot;,    &quot;img-src&quot;: &quot;https://img.kookapp.cn/assets/2022-09/KV5krdRx080qo0f0.jpg&quot;&#125;res = requests.get(url,params=params)print(res.json())\n\n运行即可获得商店返回结果\n&#123;&#x27;code&#x27;: 0, &#x27;message&#x27;: &#x27;https://img.kookapp.cn/attachments/2023-01/15/mLjpR95mZ20rs0rs.png&#x27;, &#x27;info&#x27;: &#x27;商店图片获取成功&#x27;&#125;\n\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","api"]},{"title":"【Python】request库InsecureRequestWarning的原因","url":"/2023/01/15/code/note_Python/3request%E7%9A%84ssl%E6%8A%A5%E9%94%99/","content":"今天在测试我自己写的api的时候，发现了之前出现的一个warning的真正原因\n1.起因先来看请求api的代码\ndef ApiRq(account:str,passwd:str,background=&#x27;&#x27;):    url = &quot;https://val.outpost54.top/shop-url&quot;    params = &#123;         # 参数涉及到隐私，省略    &#125;  \tres = requests.get(url,params=params,verify=False) # 请求api    return res.json()\n\n运行，会出现这个警告\n/home/muxue/.local/lib/python3.10/site-packages/urllib3/connectionpool.py:1045: InsecureRequestWarning: Unverified HTTPS request is being made to host &#x27;val.outpost54.top&#x27;. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#ssl-warnings\n\n百度了一下，可以用下面的办法来去掉这个警告\nimport urllib3 # 屏蔽ssl warningurllib3.disable_warnings(urllib3.connectionpool.InsecureRequestWarning)\n\n但是这样是不安全的，因为我们没有检查网站的证书，也就无法向服务器发送确认后的加密信息\n2.出现这个警告的原因出现这个警告，其实就是因为我们这里设置了不检查ssl证书\nres = requests.get(url,params=params,verify=False) # 请求api\n\n如果你网站的证书是没有问题的，那么完全没有必要不检查，应该使用下面的代码\nres = requests.get(url,params=params)\n\n之前我的api站点所用证书缺少证书链，所以出现了另外一个报错，从而使用了verify=False才能正常运行代码，现在更新了证书，也就不需要了！\n此时直接运行代码，也不会报错了！\n[muxue@bt-7274:~/kook/test]$ py3 api_test.pystart test\n\n3.进一步了解\n参考 https://blog.csdn.net/memory_qianxiao/article/details/82011282\n\nrequests 库其实是基于 urllib 编写的，对 urllib 进行了封装，使得使用时候的体验好了很多。\n现在 urllib 已经出到了3版本，功能和性能自然是提升了不少。所以，requests最新版本也是基于最新的 urllib3 进行封装。\n在urllib2时代对https的处理非常简单，只需要在请求的时候加上 verify=False 即可，这个参数的意思是忽略https安全证书的验证，也就是不验证证书的可靠性，直接请求。但这其实是不安全的，因为证书可以伪造，不验证的话就不能保证数据的真实性。\n在urllib3时代，官方强制验证https的安全证书，如果没有通过是不能通过请求的，虽然添加忽略验证的参数，但是依然会 给出醒目的 Warning\n\n简单说来，就是如果是旧的request库，你可以用 verify=False 禁用掉证书验证，也不会出现报错；但是到 urllib3 后，官方要求一定要验证https证书，所以禁用掉证书验证，就会报出警告。\n除非你确认你调用的api是正规的，那么禁用掉证书验证是不应该的！\n4.检查一下你的站点ssl证书是否ok这里给大家推荐一个网站：myssl\n在这里输入你的域名，可以检测一下你的ssl证书是否正确部署，我的证书链问题就是在这里检测出来的\n\n只要是A那就是ok的！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","api"]},{"title":"【Python】request.session的cookie如何导入aiohttp._cookie_jar","url":"/2023/01/15/code/note_Python/4request%20session%E7%9A%84cookie%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5%E5%88%B0aiohttp/","content":"request.session的cookie导入aiohttp._cookie_jar的教程\n\n\n1.起因我的 kook-valorant-bot 使用了两个开源库，用于riot账户的登录并获取token\n\n其中最主要用的是基于aiohttp的floxay&#x2F;python-riot-auth，但这个仓库不支持2fa用户（开启了邮箱双重验证的用户）作者去年就说会写上，但是他比较忙没有排期；\n于是我又去找了一个另外一个基于request的Prodzify&#x2F;Riot-auth 支持2fa登录的，半月前已经给bot加上了这个缺失半年的功能。\n\n可是 Prodzify&#x2F;Riot-auth 没有写cookie登录方法，其每次登录都需要账户密码，2fa用户每次都需要提供邮箱验证码；对于一个bot来说，每次操作这么麻烦，很是难受！\n随后，我去询问了写discord valorant bot的作者，得知如果2fa用户使用cookie登录，其是不需要提供邮箱验证码的！\n那么问题就变成了，如何将 request的cookie导入到aiohttp的_cookie_jar中，然后调用floxay&#x2F;python-riot-auth已经写好的cookie登录方法呢？\n\n1.1 前置声明这里说明一下，我写bot全都是看khl.py的example自学的，到目前为止，我没有系统性的学习过python语法，关于py类和对象的知识全都得靠C++的存货来旁敲侧击；所以如果我的python博客中出现错误，那是很正常的，还请指正！\n\n2.查找办法不多比比在互联网上大海捞针的困难了，我还是东平西凑才找到了一个办法\n\nPython CookieJar.update_cookies方法代碼示例\n\n该教程提到了下面的办法来导入cookie\n# 需要導入模塊: from aiohttp import CookieJar [as 別名]# 或者: from aiohttp.CookieJar import update_cookies [as 別名]def test_domain_filter_ip_cookie_send(loop) -&gt; None:    jar = CookieJar(loop=loop)    cookies = SimpleCookie(        &quot;shared-cookie=first; &quot;        &quot;domain-cookie=second; Domain=example.com; &quot;        &quot;subdomain1-cookie=third; Domain=test1.example.com; &quot;        &quot;subdomain2-cookie=fourth; Domain=test2.example.com; &quot;        &quot;dotted-domain-cookie=fifth; Domain=.example.com; &quot;        &quot;different-domain-cookie=sixth; Domain=different.org; &quot;        &quot;secure-cookie=seventh; Domain=secure.com; Secure; &quot;        &quot;no-path-cookie=eighth; Domain=pathtest.com; &quot;        &quot;path1-cookie=nineth; Domain=pathtest.com; Path=/; &quot;        &quot;path2-cookie=tenth; Domain=pathtest.com; Path=/one; &quot;        &quot;path3-cookie=eleventh; Domain=pathtest.com; Path=/one/two; &quot;        &quot;path4-cookie=twelfth; Domain=pathtest.com; Path=/one/two/; &quot;        &quot;expires-cookie=thirteenth; Domain=expirestest.com; Path=/;&quot;        &quot; Expires=Tue, 1 Jan 1980 12:00:00 GMT; &quot;        &quot;max-age-cookie=fourteenth; Domain=maxagetest.com; Path=/;&quot;        &quot; Max-Age=60; &quot;        &quot;invalid-max-age-cookie=fifteenth; Domain=invalid-values.com; &quot;        &quot; Max-Age=string; &quot;        &quot;invalid-expires-cookie=sixteenth; Domain=invalid-values.com; &quot;        &quot; Expires=string;&quot;    )    jar.update_cookies(cookies)    cookies_sent = jar.filter_cookies(URL(&quot;http://1.2.3.4/&quot;)).output(        header=&#x27;Cookie:&#x27;)    assert cookies_sent == &#x27;Cookie: shared-cookie=first&#x27;\n\n floxay&#x2F;python-riot-auth 里正好封装了cookie jar，也就是说，我们只要想办法弄出来一个 SimpleCookie 对象，再调用 update_cookie 方法，就大功告成了！\n3.最终实现关于这两个登录项目的源码，请去github仓库查看\n下面只对cookie部分进行说明！\n3.1 request和aiohttp的cookies差异\n因为cookie部分涉及到riot账户的登录信息，所以必须打码\n\n首先当然是从request里面拿到cookie了\nself.cookie = self.session.cookiesprint(self.cookie)\n\n这里直接打印，获取到的内容如下\n\n而aiohttp的cookie打印出来是下面这样的\nauth = riot_auth.RiotAuth(&quot;账户&quot;,&quot;密码&quot;)print(auth._cookie_jar._cookies)\n\n\n可以看到，两个库打印的内容不太相同，但是其键值是一致的，我们只需要把request的键值导入到SimpleCookie里面就可以了\n3.2 request.session的cookie导出为dict要想导入到SimpleCookie里面，我们可以先来看看这个类的构造是什么\n\n可以看到，该类其实是支持用dict来初始化的\n现在问题又变成了，如何将request.session的cookie导出为dict\n百度一下，这个问题的答案还是能找得到的\nau = Auth(username=&quot;账户&quot;,password=&quot;密码&quot;)ck_dict = requests.utils.dict_from_cookiejar( au.cookie )print(ck_dict)\n\n此时打印出来的结果如下，成功转换成了dict\n\n再把这个dict丢进SimpleCookie，运行无报错，那么说明ojbk了\n3.3 最终实现现在就只需要进行如下的操作，就能实现把2fa用户的cookie导入到riot_auth.RiotAuth()里面了！\nimport asyncioif __name__ == &#x27;__main__&#x27;:    print(f&quot;Start&quot;)    au = Auth(username=&quot;账户&quot;,password=&quot;密码&quot;)    ck_dict = requests.utils.dict_from_cookiejar( au.cookie )    print(ck_dict)    scookie = SimpleCookie(ck_dict)    auth = riot_auth.RiotAuth()    auth._cookie_jar._cookies    auth._cookie_jar.update_cookies(scookie)    ret = asyncio.run(auth.reauthorize())    print(ret) #成功！！！！\n\nauth.reauthorize()方法会返回一个bool值，标识是否登录成功\n\n当然成功啦！\n4.结语不得不说，这个问题的答案网上是真的无现成的，都得东平西凑，花了我差不多一个半小时才找到正确方法\n不过现在终于可以保存2fa用户的登录信息了，也算是bot的功能升级吧！\n","categories":["速通Python"],"tags":["阿狸开发日志","Python","api"]},{"title":"【C语言】传值调用和传址调用","url":"/2021/08/14/code/note_c/10%E4%BC%A0%E5%80%BC%E8%B0%83%E7%94%A8/","content":"今天学习C语言的时候，接触到了两个全新的概念话不多说，就此和大家分享一下c语言中函数的传值调用和传址调用，希望有所帮助欢迎dalao无情指正！\n\n\n引子 : 交换函数我们先来写一个简单的函数\n目的是交换a和b\n#include&lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint b = 20;\tint tmp = 0;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);//显示a和b最初的值\ttmp = a;\ta = b;\tb = tmp;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);//查看交换结果\treturn 0;&#125;\n\n运行的结果如图\n需要注意的是，这是在主函数main里面直接进行的交换程序，而我们想要的其实是一个可以在任何地方使用的交换函数\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint b = 20;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\tswap1(a, b);\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\treturn 0;&#125;\n\n若想达成以上目的，我们要先把上述代码优化成以下形式。其中swap1就是我们即将要写的自定义函数\nvoid swap1(int x, int y)&#123;\tint tmp = 0;\ttmp = x;\tx = y;\ty = tmp;&#125;\n\n\nvoid表示自定义函数无返回类型\n\n这个自定义函数看起来没什么问题对吧！\n但是结果却告诉我们a和b并没有被交换\n\n这是为什么？\n查错方法这里给大家介绍一个老师教授的查错方法。虽然我估计大家都知道（小声bb）\n那就是用vs编译器自带的监视器了（快捷键f10，我用的是最新的vs2019，官网即可免费下载使用）\n\n\n左边有个很Q的黄色小箭头，告诉你正在监视那一步\n每按一次f10代码就会往下走一行\n当遇到swap此类函数时，按f11进入函数，f10会直接跳过函数\n\n\n可以看到代码在第25行的时候，x和y已经获得了a和b的值，tmp此时为0\n\n下一行继续，tmp变成10\n\n再下一行，x获得y的值，x&#x3D;20\n\n然后y获得tmp里面保存的x的值，y&#x3D;10\n\n可当我们下一步跳出函数，回到主函数的时候\n会发现a和b仍然是10和20，并没有发生交换\n聪明的你肯定已经想到这是为什么了\n函数中的x和y与主函数的a和b是独立的，x和y的变化无法影响a和b\n那怎么样函数中的x和y才能影响函数外的a和b，从而达到我们交换的目的呢?\n这里需要涉及一个新的大家都知道的概念\n&amp; 取地址操作符先用一个简单的例子让大家了解&amp;取地址操作符的作用\n在我们的c语言中，每个字符都对应了一个它独自的地址\n而&amp;符号就是取出这个字符的地址\nint main()&#123;\tint a = 10;\tint* pa = &amp;a;//pa指针变量\t*pa = 20;//解引用操作\tprintf(&quot;%d\\n&quot;, *pa);\treturn 0;&#125;\n\n这里面的*pa获取了a的地址，在打印的时候会顺着地址找到a，显示a的结果\n让我们继续\n我们将上述交换函数代码的主函数改成如下形式\nint main()&#123;\tint a = 10;\tint b = 20;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);    //swap1(a, b);\tswap2(&amp;a, &amp;b);\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\treturn 0;&#125;\n\n比较swap1和swap2，会发现swap2括号中的a和b前面都多了一个**&amp;操作符**\n这个操作符会让swap2不再读取a和b的数值，即10和20\n而是会读取a和b在内存中的地址\n相对应的，swap2函数也要改成如下形式\n其实形式和swap1基本一样，只是x和y被替换成了**pa 与 pb\nvoid swap2(int* pa, int* pb)&#123;\tint tmp = 0;\ttmp = *pa;\t*pa = *pb;\t*pb = tmp;&#125;\n\n\n表明 pa和pb都是*指针变量\npa和pb保存的是a和b的地址\n\n这时候我们再运行代码，a和b被很好的调换了\n我们的目的也达成了\n\n实参和形参要想了解为什么两个函数会有这样的不同\n我们需要学习实参（实际参数）和形参（形式参数）\nvoid swap1(int x, int y)&#123;\tint tmp = 0;\ttmp = x;\tx = y;\ty = tmp;&#125;void swap2(int* pa, int* pb)&#123;\tint tmp = 0;\ttmp = *pa;\t*pa = *pb;\t*pb = tmp;&#125;int main()&#123;\tint a = 10;\tint b = 20;\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\t//swap1(a, b);\tswap2(&amp;a, &amp;b);\tprintf(&quot;a=%d b=%d\\n&quot;, a, b);\treturn 0;&#125;\n\n\n在这串代码中，a和b是实参\nx、y、*pa、 *pb都是形参\n\n可以借用另外一个代码的例子进一步给大家了解实参\nint get_max(int x, int y)&#123;\tif (x &gt; y)\t\treturn x;\telse\t\treturn y;&#125;int main()&#123;\tint a = 10;\tint b = 20;\tint max = get_max(a, b); \tprintf(&quot;max= %d\\n&quot;, max);    max = get_max(100,300);    max = get_max(100,300+1);//实参可以是表达式\tmax = get_max(100, get_max(3, 5));//也可以是函数\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n在这串代码中，抛去上面的a和b\n max &#x3D; get_max(100,300);是我们使用这个函数的基本方式\n\n这里面的100和300是实参\n同时**300+1和get_max(3, 5)**也是实参\n对应的函数中的x和y就是形参\n\n\n当实参传给形参的时候形参其实是实参的一份临时拷贝对形参的改变是不会改变实参的\n\n这样解释大家应该对实参和形参有一定的认识了\n接下来就有请我们的标题人物隆重登场\n传值调用，传址调用这两个调用方式十分重要，而且两个字从读音到长相（bushi）都十分相似\n所以大家一定要注意区分！\n简而言之\n\n当我们需要在函数内部操作函数外部的变量的时候→传址调用\n如果我们只需要外部变量的值，不需要改变外部变量→传值调用\n\n以上面的交换函数为例子\nvoid swap1(int x, int y)//传值调用&#123;\tint tmp = 0;\ttmp = x;\tx = y;\ty = tmp;&#125;void swap2(int* pa, int* pb)//传址调用&#123;\tint tmp = 0;\ttmp = *pa;\t*pa = *pb;\t*pb = tmp;&#125;\n\n因为swap1里面的x和y是传值调用，x和y只获取了a和b的值，自然无法影响函数外面的a和b\n而swap2中的*pa 和 *pb获取的是a和b的地址（址→地址）所以可以影响函数外的a和b，实现它们的交换\n\n注：x，y，*pa ， *pb 都是局部变量，它们在出了函数外之后就无法使用，也失去了使用它们的意义\n\n结束语本篇小博客到这里也结束啦，感谢你看到最后！\n如果感觉看完之后仍有不明白的地方\n可以去观看这期视频里面的讲解，swap函数的讲解在1小时17分【点我跳转】\n我也是刚学C语言的小白，博文有错在所难免，请各位大佬无情指正\n这篇博文虽然字不多，但依旧花了我2小时的时间，如果觉得不错就点个赞再走吧！\n求求了，跪谢！\n","categories":["C语言初识"],"tags":["C语言","函数"]},{"title":"【C语言】sizeof操作符","url":"/2021/08/16/code/note_c/11sizeof%E6%93%8D%E4%BD%9C%E7%AC%A6/","content":"@[toc]\nsizeof操作符上篇博客提到了一个知识点  【链接】\n\nsizeof操作符括号内的表达式是不会真正计算的\n\n这个是为什么呢？\n我们先来看看sizeof的基本用法\n基本用法#include&lt;stdio.h&gt;int main()&#123;\tint a=10;\tprintf(&quot;%d\\n&quot;,sizeof(a));\tprintf(&quot;%d\\n&quot;,sizeof(int));\t\tprintf(&quot;%d\\n&quot;,sizeof a);\treturn 0; &#125; \n\n打印结果为3个4\n但当我们以这种方式书写的时候，编译器就会报错\nprintf(&quot;%d\\n&quot;,sizeof int);\n\n\n\n在使用sizeof的时候，变量a的括号可以省略\n\n但直接计算int的时候，括号不能省略\n\n\n\n 这说明sizeof是一个操作符，而不是函数\n\nint arr[10]=&#123;0&#125;;printf(&quot;%d\\n&quot;,sizeof  (arr));printf(&quot;%d\\n&quot;,sizeof  (int[10]));\n\n这两句代码打印的都是40，其中int[10]是arr数组的类型\n\n 冷知识，我们可以用9[arr]来访问数组元素\n 但这么做会降低代码的可读性，所以我们还是采取arr[9]的形式更好\n\nint arr[10]=&#123;0&#125;;arr[9]=1;printf(&quot;%d\\n&quot;,9[arr]);\n\n\n\nsizeof和函数传参先来看看下面这个代码\n#include&lt;stdio.h&gt;void test1(int arr[])&#123;\tprintf(&quot;%d\\n&quot;,sizeof(arr));//4&#125;void test2(char ch[])&#123;\tprintf(&quot;%d\\n&quot;,sizeof(ch));//4&#125;int main()&#123;\tint arr[10]=&#123;0&#125;;\tchar ch[10]=&#123;0&#125;;\tprintf(&quot;%d\\n&quot;,sizeof(arr));//40\tprintf(&quot;%d\\n&quot;,sizeof(ch));//10\ttest1 (arr);\ttest2 (ch);\t\t\treturn 0; &#125; \n\n32位平台，打印结果如下\n\n\nVS编译器下\nx86–32位–int 4\nx64–64位–int 8\n\n为什么在main函数里面打印的是40和10\n到了函数里面就只有4了呢？\n数组传参数组在传参的时候，传过去的只是首元素的地址\n\n数组名代码数组首元素的地址\n\n问：为什么字符变量只占一个字节，但这里打印的是4呢？\n答：这里传入的是char数组的指针，指针变量都是4个字节\n\nsiezof和表达式现在就到我们的重点了\n为什么sizeof括号里的表达式没有真正地运算？\nshort s=5;int a=10;printf(&quot;%d\\n&quot;,siezof(s=a+2));printf(&quot;%d\\n&quot;,s);\n\n\n这里就牵扯到C语言程序运行的几个步骤了\n\n编译–test.c\n链接\n运行–test.exe\n\n简单地说，只有在链接之后运行的代码，才会真正给a赋值\n而sizeof括号中的语句，是在编译中运行的\n程序会先计算这个表达式，推断出它的长度，再返回给printf打印\n所以，sizeof括号内的表达式不会真的给S赋值\n你明白了吗？\n\nsizeof和strlen的区别再求字符串的长度的时候，我们可以使用sizeof，也可以使用strlen\n这两个的主要区别如下\n\nsizeof会计算整个数组内字符串的长度，包括字符串暗藏的’\\0’\nstrlen计算长度的时候，遇到’\\0’后停止\n\n在使用的时候，我们需要注意sizeof在计算长度的时候是会比strlen多算一个的\n根据具体情况选择sizeof或者strlen\n\n结语这篇博客迟到太久了，最近实在是有点忙\n如果有错误，还请各位dalao指出！万分感谢！\n高数太难了啊啊啊啊啊！（哭唧唧）\n","categories":["C语言初识"],"tags":["C语言"]},{"title":"【C语言】数组名是什么？","url":"/2021/08/13/code/note_c/12%E6%95%B0%E7%BB%84%E5%90%8D%E6%98%AF%E4%BB%80%E4%B9%88/","content":"数组名是什么？@[TOC]\n在我们敲代码的过程中，经常要遇到使用数组的地方\n提到使用数组，就离不开数组名\nint arr[10] = &#123; 0 &#125;;//arr就是数组名\n\n同时我们也经常要用到使用sizeof计算数组元素个数的情况\nint sz = sizeof(arr) / sizeof(arr[0]);\n\n所以了解数组名的概念对于我们的c语言学习十分重要\n数组名是数组首元素的地址如题，这个概念在我们创建自定义函数的时候尤为重要\n最经常犯的错误就是在自定义函数内部求主函数中arr数组的元素个数\nvoid sp1(int arr[])&#123;\tint sz = sizeof(arr) / sizeof(arr[0]);//放在此处sz计算为1，err    for (i = 0; i &lt; sz; i++)&#125;\n\n这时从主函数传过来的arr只有首元素的地址，使用sizeof计算得到的sz只有1\n对后续要进行的操作如for循环中的 i&lt;sz来说是无效的\n这是因为int arr传到自定义函数中的是形参\n而形参arr是无法计算内部元素大小的\n（具体的代码示例将在下篇博客的冒泡排序中展示）\n代码示例1 sz我们可以用简单的代码来了解不同arr的书写方式得到的结果\n#include &lt;stdio.h&gt;int main()&#123;    int arr[10] = &#123; 0 &#125;;\tint sz = sizeof(arr);//数组名表示整个数组\tprintf(&quot;%d\\n&quot;, sz);\treturn 0;&#125;\n\n可以看到结果是40，这表明数组中10个元素所占用的字节是40\n在这个代码里面，arr表示的是整个数组，sizeof求的自然也是整个数组所占字节的长度\n\n我们可以用下面这串代码得到数组内的元素个数，结果为10\n#include &lt;stdio.h&gt;int main()&#123;    int arr[10] = &#123; 0 &#125;;    int sz = sizeof(arr) / sizeof(arr[0]);\tprintf(&quot;%d\\n&quot;, sz);\treturn 0;&#125;\n\n\n代码示例2下面这串代码中，我们使用三种不同的方式键入arr\n#include &lt;stdio.h&gt;int main()&#123;\tint arr[10] = &#123; 0 &#125;;\tprintf(&quot;%p\\n&quot;, &amp;arr);//1\tprintf(&quot;%p\\n&quot;, arr);//2\tprintf(&quot;%p\\n&quot;, &amp;arr[0]);//3\treturn 0;&#125;\n\n\n我们会发现三次打印的结果是一样的\n\n&amp;arr取出的是整个数组的地址\narr作为数组名–&gt;数组首元素的地址\n&amp;arr[0]取出的是数组首元素的地址\n\n但实际上三者的本质是完全不同的\n可以用+1的方式来找出它们的不同之处\nint main()&#123;\tint arr[10] = &#123; 0 &#125;;\tprintf(&quot;%p\\n&quot;, &amp;arr);//1  &amp;arr取出的是数组的地址\tprintf(&quot;%p\\n&quot;, &amp;arr+1);\tprintf(&quot;%p\\n&quot;, arr);//2\tprintf(&quot;%p\\n&quot;, arr+1);\treturn 0;&#125;\n\n\n可以看到&amp;arr+1之后的结果和arr+1的结果是不一样的\n\n\n&amp;arr+1与&amp;arr之间相差40\narr+1与arr之间相差4\n\n这是因为&amp;arr代表的整个数组的地址，加1即跳过了整个数组\n而arr只代表首元素地址，加1表示第二位的地址\n总结c语言中有很多这样的小知识点，需要我们记录并加以了解\n只有理解了为什么，我们才能在后续的学习、代码创作中写出更好的代码\n点个赞再走呗，求求了！\n","categories":["C语言初识"],"tags":["C语言","数组"]},{"title":"【C语言】冒泡排序","url":"/2021/08/25/code/note_c/13%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","content":"冒泡排序@[TOC]\n无内鬼，直入主题！\n冒泡排序的思想核心是：比较两两相邻的元素，并且可能的话需要交换\n说人话就是\n把原本是9，8，7，6，5，4，3，2，1，0的数组\n变成0 ，1，2，3，4，5，6，7，8，9\n也可以把无序的数组排列为有序（从小到大or从大到小）\n基本的流程如下图：\n\n同时我们可以计算出，0·9这十个数字，重新排列完需要循环9次\n也就是N个数字需要N-1趟的排列\n代码实现说完了原理，还是需要敲代码来实现\n“老铁们int main return 0走一波！”\n#include&lt;stdio.h&gt;int main()&#123;\tint arr[] = &#123; 9,8,7,6,5,4,3,2,1,0 &#125;；//排序为升序 - 冒泡排序    int sz = sizeof(arr) / sizeof(arr[0]);\tbubble_sort(arr, sz);//冒泡排序的自定义函数\treturn 0;&#125;\n\n\n一维数组[]中的元素个数可以省略\n\nSZ的位置问题这里必须要注意的一点是\nsizeof必须在主函数中计算元素个数\n因为如果在自定义函数中计算的话\nvoid bubble_sort(int arr[])&#123;\tint sz = sizeof(arr) / sizeof(arr[0]);//放在此处sz计算为1，err    for (i = 0; i &lt; sz; i++)&#125;\n\nSZ计算出来的结果是1\n\narr数组名，传送的是数组首元素的地址\narr作为形参，无法计算内部元素个数\n对后续要进行的操作如for循环中的 i&lt;sz来说自定义函数中计算的sz是无效的\n\n更具体的原因在上一篇博客《什么是数组名？》中有介绍\n排除此问题后，sz计算出的元素个数就是我们的N\n这里以i为趟数，i&lt;sz指趟数需小于元素个数\nvoid bubble_sort(int arr[], int sz)//形参arr本质是指针&#123;\t//确定趟数\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;        //\t&#125;&#125;\n\n接着书写第二环的for循环，即每一趟冒泡排序的操作\n       //一趟冒泡排序int j = 0;for (j = 0; j &lt; sz - 1 - i; j++)&#123;\tif (arr[j] &gt; arr[j + 1] )\t&#123;              //\t&#125;&#125;\n\n这里需要注意的是j与sz的大小关系\n按照前面的流程图，每运行一趟冒泡序列，就会有一个数字被移动到数组的最后面\nN个元素需要进行N-1次冒泡排序，同时经过一趟后，新的最后一个元素无需重新比对排序\n所以 j&lt;sz-1-i \n比较&amp;交换因为int arr传入的是指针变量，如果想要自定义函数影响函数外的内容，也必须使用指针变量\n          //交换int tmp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = tmp;\n\n实际进行两个数字之间的比较和交换的是上述代码\ntmp这个空盒子也是我们的老朋友了\n总结起来完整的自定义函数如下\nvoid bubble_sort(int arr[], int sz)//因为在主函数中计算sz，这里需要加上int sz&#123;\t//确定趟数\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\t//一趟冒泡排序\t\tint j = 0;\t\tfor (j = 0; j &lt; sz - 1 - i; j++)\t\t&#123;\t\t\tif (arr[j] &gt; arr[j + 1] )\t\t\t&#123;\t\t\t\t//交换\t\t\t\tint tmp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = tmp;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n接下来我们可以用F10的监视器查看代码运行情况\n\narr数组初始化完成，sz计算得出为10\n继续进行下一步，arr数组中的内容成功被排列\n\n冒泡排序完成！\n结语冒泡排序是对循环语句、自定义函数、下标以及数组的综合运用\n了解它的原理有助于我们写出更为复杂的排列组合代码\n点个赞再走呗，谢谢了！\n","categories":["C语言初识"],"tags":["C语言","算法","排序"]},{"title":"【C语言】如何产生数组最大值","url":"/2021/08/27/code/note_c/14%E4%BA%A7%E7%94%9F%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC/","content":"产生数组最大值@[TOC]\n今日风和日丽，是个写（水 ）博客的绝佳时机\n和大家分享一串C语言中产生数组中的元素的最大值的代码\n实现方式很简单，我们需要用到for循环和if语句\n#include &lt;stdio.h&gt;int main()&#123;\tint arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;//数组初始化\tint max = 0;//设置一个最大值\tint i = 0;\tint sz = sizeof(arr) / sizeof(arr[0]);//计算数组元素个数\tfor (i = 0; i &lt; sz; i++)    &#123;\t\tif (arr[i] &gt; max)\t\t&#123;\t\t\tmax = arr[i];\t\t&#125;\t&#125;\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n当我们运行代码的时候，输出的结果是10\n\n看样子我们成功输出了数组的最大值，这串代码已经完成了，对不对？\n但实际上这串代码是有问题的\n先别往下滑，想想它的问题出在那里了呢？\n——————————————————\n正负性当我们把数组里面的数字全部改成负数的时候\n你会发现输出的结果等于0，并不是数组内的最大值-1\n\n出现这个情况的原理十分简单，我们设定的int max &#x3D; 0，而0&gt;-1，输出的结果也自然是0了\n解决这个问题的方法也非常简单\n如果我们数组内的数全部小于0，那我们就设定MAX&#x3D;数组内的某个数字，然后再进行比较，输出最大值不就行了？\nint main()&#123;\tint arr[] = &#123; -1,-2,-3,-4,-5,-6,-7,-8,-9,-10 &#125;;\tint max = arr[0];//arr[0]对应数组中第一个数的下标\tint i = 0;\tint sz = sizeof(arr) / sizeof(arr[0]);\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tif (arr[i] &gt; max)\t\t&#123;\t\t\tmax = arr[i];\t\t&#125;\t&#125;\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n\n避免不同数组的元素个数不同，max应该设置为arr[0]而不是arr[3]或者arr[5]\n\n这时候再次运行我们的代码，可以看到结果已经正确的显示为-1了\n\n进阶玩法以自定义函数的形式实现此功能使用自定义函数的时候，我们需要注意一个问题\n那就是我博客之前写到过的 《传址调用和传值调用》\n先把我们的主函数改造一番\nint main()&#123;    int arr[] =&#123; -1,-2,-3,-4,-5,-6,-7,-8,-9,-10 &#125;;\tint max = arr[0];\tint sz = sizeof(arr) / sizeof(arr[0]);\tsp(arr, sz,&amp;max);\tprintf(&quot;max = %d\\n&quot;, max);\treturn 0;&#125;\n\n其中sp就是我们要编写的自定义函数\n\n因为自定义函数中的步骤需要改变我们主函数中的max，这里我们需要用取地址符，也就是传址调用\n\nsp(arr, sz,&amp;max);//&amp;max是传址调用\n\n同样的，我们的自定义函数也需要使用int*来接收max的地址\nvoid sp(int arr[], int sz,int* pm)&#123;\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tif (arr[i] &gt; *pm)\t\t&#123;\t\t\t*pm = arr[i];\t\t&#125;\t&#125;&#125;\n\n运行结果正确\n\n结语在制作自定义函数的时候，需要注意传址调用和传值调用的区别。具体介绍参考我之前的博客 [链接]\n感谢你看到最后，如果对你有帮助的话，点个赞再走呗！\n（没有帮助也可以点点赞~）\n","categories":["C语言初识"],"tags":["C语言","数组"]},{"title":"【C语言】变量的作用域和生命周期","url":"/2021/08/30/code/note_c/15%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"变量的作用域和生命周期[TOC]\n\n1.全局变量和局部变量定义在代码块外部的是全局变量\n定义在代码块内部的是局部变量\n什么是代码块？\n//这是代码快外部int main()&#123;//这是代码块内部&#125;\n\n实际上用int main来演示是不太对的,实际使用的时候我们定义变量是在int main内部定义的\n下面这个例子更加清晰明了\nint main()&#123;\tint i = 0;//这是代码块外部-i全局变量\tfor(i=0;i&lt;10;i++)\t&#123;//代码块开始\t\tint j=0;//这是代码块内部-j局部变量        for(j=0;j&lt;10;j++)\t&#125;//代码块结束&#125;\n\n需要注意的是：\n同一个变量a可以在全局，局部变量中间同时使用，局部变量优先\n\n这里是指同时存在，同时使用，但不能同时定义\n在局部的代码块中重新定义一个全局变量是错误的\n\n下面这种形式就是 同时使用一个变量\nint main()&#123;    int sz = 8;\tint i = 0;\tif(i&lt;sz)\t&#123;\t\ti=1;\t&#125;&#125;\n\n\n在我们定义变量的时候，变量的名字不能相同\n\n同时变量的名字也不应和库函数名相同\n\n\n简单的说就是变量不要重复，也别和库函数冲突\n2.变量的作用域变量的作用域-&gt;变量的生效区域\n\n局部变量只在它自己的代码块中生效\n全局变量的作用域是整个代码\n\n注：在VS中全局变量的作用域是整个工程\n作用域的规定了变量生效区域\n如果你在局部变量的代码块外部使用这个局部变量\n这样是无效的，无法使用\n2-1.声名外部变量的方法在vs中全局变量的作用域是整个工程\n但是如果源文件不同，我们需要打一串声明来应用工程文件中另外一个源文件的全局变量\nextern int a\n\n以下是声名变量和定义变量的代码示例\n　　extern int a;//声明全局变量a　　int a; //定义全局变量a　　extern int a =0 ;//定义全局变量a 并给初始值　　int a =0;//定义全局变量a,并给初始值\n\n3.变量的生命周期生命周期这个概念和作用域十分相似\n\n局部变量的生命周期从进入”{“开始，离开”}”结束\n全局变量的生命周期是整个程序（VS项目）\n\n4. 局部变量&amp;自动变量局部变量又称自动变量\nauto int a = 0;\n\n实际使用的时候我们一般都是省略auto的\n\n以上就是C语言中有关变量的一些概念，希望对你有帮助\n点个赞再走呗，万分感谢！\n","categories":["C语言初识"],"tags":["C语言","函数"]},{"title":"【C语言】童年经典游戏-三字棋","url":"/2021/11/10/code/note_c/16%E4%B8%89%E5%AD%90%E6%A3%8B/","content":"@toc\n问题引入 - 什么是三子棋？想必大家儿时都玩过：#字棋\n\n如图，即一个3x3的格子，玩家需要在横、竖、斜三条线上布下自己的棋子\n先连成一条线上3个棋子的玩家获胜\n如果格子填满后还未有胜者，即为平局\n今天就让我们用c语言代码来完成一个基础的三子棋小游戏\n\n涉及知识点：\n二维数组、循环语句、自定义函数、自定义头文件\n关联博客：扫雷游戏\n\n\n自定义头文件本次三子棋代码实现中，我们需要使用到自定义头文件\n使用自定义函数前，需要先对函数进行声明\n头文件就是一堆声明的集合\n\n问：为什么不把函数声明直接main函数前面？\n\n\n答：因为这样更方便团队进行同一个项目的分工制作\n\n如何创建自定义头文件？\n在vs编译器的“解决资源管理器”里，我们能看到头文件的文件夹\n右键它，新建项\n\n选择头文件进行新建，后缀是.h\n\n创建完后，我们可以在另外一个源文件中引用头文件\n#include &quot;game.h&quot;\n\n另外，因为我们使用的两个源文件（下面会提到）都需要使用c语言的库函数\n所以我们可以在自定义头文件中引用库函数的头文件\n\n这样只用在其他源文件中引用我们的自定义头文件\n就无需再引用C语言的库函数头文件了\n\n项目中不同源文件之间的连接在三子棋代码中，我们需要编写两个源文件\n\n一个源文件为main函数所在的源文件\n另一个是自定义函数的定义部分所在的头文件\n\n在实际项目合作中，这种方式可以将不同的自定义函数（实现不同功能）的内容分工给每个人\n同样是为了方便团队合作\n在两个源文件中编写自定义函数的方式和在一个源文件中编写是一样的\n如在头文件game.h中声明了初始化棋盘的函数\n//初始化棋盘void Intboard(char board[ROW][COL], int row, int col);\n\n在实现自定义函数的game.c文件中只需要引用头文件game.h\n就能正常编写自定义函数的实现部分\n#include &quot;game.h&quot;//初始化棋盘void Intboard(char board[ROW][COL], int row, int col)&#123;   &#125;\n\n\n代码实现1.打印菜单&amp;初始化棋盘游戏嘛，肯定需要一个最基本的初始菜单了\n玩家通过输入1或0来选择进入游戏还是退出游戏\nvoid menu()&#123;\tprintf(&quot;**********************\\n&quot;);\tprintf(&quot;********1.play********\\n&quot;);\tprintf(&quot;********0.exit********\\n&quot;);\tprintf(&quot;**********************\\n&quot;);&#125;\n\n接下来我们需要弄一个初始化的函数\n三子棋一共是3x3的格子，所以我们需要一个二维数组来存放棋盘\n然后要先把这个棋盘中的每一个棋子都初始化为空格\ngame.h\n#define ROW 3//行#define COL 3//列//初始化棋盘void Intboard(char board[ROW][COL], int row, int col);\n\ntest.c\nchar ret = 0;//存储数据-二维数组char board[ROW][COL] = &#123; 0 &#125;;//初始化棋盘 - 初始化空格Intboard(board, ROW, COL);//自定义函数传参\n\ngame.c\n//初始化棋盘void Intboard(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tboard[i][j] = &#x27; &#x27;;//将每个棋盘都初始化为空格\t\t&#125;\t&#125;&#125;\n\n2.打印棋盘玩家&#x2F;电脑每走一步，游戏都需要打印一次棋盘，告诉玩家自己下在了哪里，以及对手（电脑）落子的位置\n和简单打印二维数组不同\n我们需要在每个元素之间打印一个分割线，达到以下效果\n//   |   |   //---|---|---//   |   |  //---|---|---//   |   |   \n\ngame.h和test.c文件中写法同上，重点来看game.c文件中函数的实现\n//打印棋盘void Display(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tprintf(&quot; %c &quot;, board[i][j]);//打印数组元素\t\t\tif (j &lt; col - 1)\t\t\t\tprintf(&quot;|&quot;);//竖分割线\t\t&#125;//效果  a | b | c  \t\tprintf(&quot;\\n&quot;);//换行\t\tif (i &lt; row - 1)\t\t&#123;\t\t\tfor (j = 0; j &lt; col; j++)\t\t\t&#123;\t\t\t\tprintf(&quot;---&quot;);//横分割线\t\t\t\tif (j &lt; col - 1)\t\t\t\t\tprintf(&quot;|&quot;);//竖分割线\t\t\t&#125;//效果---|---|---\t\t\tprintf(&quot;\\n&quot;);\t\t&#125;\t&#125;&#125;\n\n这样我们就能输出一个如图所示的棋盘\n\n你可能注意到，这里多了两行提示\n这是我们test.c函数中的内容\n三子棋游戏需要以函数返回值来判断是否胜利（平局）\n不过这里的test函数主要用于玩家最开始1和0的选择（是否开始游戏）\nvoid test()&#123;\tint input = 0;\tsrand((unsigned int)time(NULL));\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出游戏\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误，请重新选择!\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);&#125;int main()&#123;\ttest();\treturn 0;&#125;\n\n这里的srand以及time函数是用来生成随机数，作为电脑落子坐标的\n在猜数字游戏的博客里也有提到这两个函数  [链接]\nsrand((unsigned int)time(NULL));\n\n3.游戏基本流程打印完棋盘后，开始编写玩家落子、电脑落子以及判断谁最终胜利的函数\n在日常编写代码的时候，我们也最好使用这种方式\n\n先想好游戏的具体流程\n写出流程需要的函数名和判断过程\n最后补齐自定义函数的实现\n\ntest.c\nvoid game()&#123;\tchar ret = 0;\t//存储数据-二维数组\tchar board[ROW][COL] = &#123; 0 &#125;;\t//初始化棋盘 - 初始化空格\tIntboard(board, ROW, COL);\t//打印棋盘\tDisplay(board, ROW, COL);\twhile (1)\t&#123;\t\t//玩家走\t\tPlayerMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t//判断玩家是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\t//电脑走\t\tBotMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t//判断电脑是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t//判断状态\tif (ret == &#x27;*&#x27;)\t&#123;\t\tprintf(&quot;玩家赢了\\n&quot;);\t&#125;\telse if (ret == &#x27;#&#x27;)\t&#123;\t\tprintf(&quot;电脑赢了\\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;平局\\n&quot;);\t&#125;&#125;\n\n代码中的Iswin函数用于判断谁胜利\n因为每走一步的结果有4种情况\n\n玩家赢\n电脑赢\n平局\n继续\n\n所以这里我们不再使用数字（也是避免和原有menu选择弄混）\n以字符的形式来表达这4种情况\n//在游戏进行的过程中--Iswin判断//1.玩家赢了 -*//2.电脑赢了 -#//3.平局 -Q//4.继续 -C\n\n4.玩家走棋玩家走棋的时候，我们需要注意以下几点\n\n玩家应以[1,3]的数字作为落子坐标，而不应从0开始（下标从0开始）\n玩家是人，可能输错。在坐标出错的时候应给予提示，并让玩家重新输入\n落子前需要判断该坐标是否已有子。若有，提示玩家该处已下子\n\n//玩家走void PlayerMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot;玩家走:&gt; \\n&quot;);\twhile (1)\t&#123;\t\tprintf(&quot;请输入下棋的坐标:&gt; &quot;);\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\tif (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)\t\t&#123;\t\t\t//下棋 \t\t\t//判断坐标是否被占用\t\t\tif (board[x - 1][y - 1] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\tboard[x - 1][y - 1] = &#x27;*&#x27;;\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;坐标已被占用，请重新输入\\n&quot;);\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;坐标错误，请重新输入\\n&quot;);\t\t&#125;\t&#125;&#125;\n\n细心的你肯定发现了，这里的玩家落子使用的是*，也正是玩家胜利时的返回字符\n下面电脑落子的时候用的就是#\n\n5.电脑落子电脑落子比玩家落子相对较简单\n我们只需要让生成的两个随机数在1-3之间即可\nvoid BotMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot;电脑走: \\n&quot;);//提示玩家此处是电脑落子\twhile (1)\t&#123;\t\tx = rand() % row;\t\ty = rand() % col;\t\tif (board[x][y] == &#x27; &#x27;)\t\t&#123;\t\t\tboard[x][y] = &#x27;#&#x27;;\t\t\tbreak;\t\t&#125;\t&#125;&#125;\n\n6.判断是否胜利上面提到，每走一步，我们都需要用Iswin函数判断是否有人胜利\n三子棋胜利有3种方式：行、列、对角线\n这里我们需要分别予以判断，是否存在某一个行、列、对角线上的子全为玩家或电脑所下\n//判断胜利char Iswin(char board[ROW][COL], int row, int col)&#123;\t//判断行\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tif (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[i][1];\t\t&#125;\t&#125;\t//判断列\tfor (i = 0; i &lt; col; i++)\t&#123;\t\tif (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[1][i];\t\t&#125;\t&#125;\t//判断对角线\tif (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\tif (board[2][0] == board[1][1] &amp;&amp; board[1][1] == board[0][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\t//判断平局\t//满了返回1，不满返回2\tif (1 == IsFull(board, row, col))\t&#123;\t\treturn &#x27;Q&#x27;;\t&#125;\t//继续\treturn &#x27;C&#x27;;&#125;\n\n这里又出现了一个新的函数，IsFull\n\n7.判断是否平局当上面的判断胜利的语句走完后，若还没出现返回的情况\n我们就要判断是否是平局，即判断棋盘的9个棋子是否都已落下\nint IsFull(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tif (board[i][j] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 1;//棋盘满了&#125;\n\n如果的判断胜利和平局的语句都走完后，还没出现返回的情况\n即说明游戏并未停止，我们需要继续游戏\n\n游戏效果到这里，我们的三子棋游戏就完成了！\n跑一下看看效果吧！\n\n\n\n完整代码这里贴出三子棋函数的完整代码供大家参考\ngame.c#define _CRT_SECURE_NO_WARNINGS 1#include &quot;game.h&quot;//初始化棋盘void Intboard(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tboard[i][j] = &#x27; &#x27;;\t\t&#125;\t&#125;&#125;//打印棋盘void Display(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tprintf(&quot; %c &quot;, board[i][j]);\t\t\tif (j &lt; col - 1)\t\t\t\tprintf(&quot;|&quot;);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t\tif (i &lt; row - 1)\t\t&#123;\t\t\tfor (j = 0; j &lt; col; j++)\t\t\t&#123;\t\t\t\tprintf(&quot;---&quot;);\t\t\t\tif (j &lt; col - 1)\t\t\t\t\tprintf(&quot;|&quot;);\t\t\t&#125;\t\t\tprintf(&quot;\\n&quot;);\t\t&#125;\t&#125;&#125;//玩家走void PlayerMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot;玩家走:&gt; \\n&quot;);\twhile (1)\t&#123;\t\tprintf(&quot;请输入下棋的坐标:&gt; &quot;);\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\tif (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)\t\t&#123;\t\t\t//下棋 \t\t\t//判断坐标是否被占用\t\t\tif (board[x - 1][y - 1] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\tboard[x - 1][y - 1] = &#x27;*&#x27;;\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot;坐标已被占用，请重新输入\\n&quot;);\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;坐标错误，请重新输入\\n&quot;);\t\t&#125;\t&#125;&#125;void BotMove(char board[ROW][COL], int row, int col)&#123;\tint x = 0;\tint y = 0;\tprintf(&quot;电脑走: \\n&quot;);\twhile (1)\t&#123;\t\tx = rand() % row;\t\ty = rand() % col;\t\tif (board[x][y] == &#x27; &#x27;)\t\t&#123;\t\t\tboard[x][y] = &#x27;#&#x27;;\t\t\tbreak;\t\t&#125;\t&#125;&#125;int IsFull(char board[ROW][COL], int row, int col)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tfor (j = 0; j &lt; col; j++)\t\t&#123;\t\t\tif (board[i][j] == &#x27; &#x27;)\t\t\t&#123;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 1;//棋盘满了&#125;//判断胜利char Iswin(char board[ROW][COL], int row, int col)&#123;\t//判断行\tint i = 0;\tfor (i = 0; i &lt; row; i++)\t&#123;\t\tif (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[i][1];\t\t&#125;\t&#125;\t//判断列\tfor (i = 0; i &lt; col; i++)\t&#123;\t\tif (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != &#x27; &#x27;)\t\t&#123;\t\t\treturn board[1][i];\t\t&#125;\t&#125;\t//判断对角线\tif (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\tif (board[2][0] == board[1][1] &amp;&amp; board[1][1] == board[0][2] &amp;&amp; board[1][1] != &#x27; &#x27;)\t\treturn board[1][1];\t//判断平局\t//满了返回1，不满返回2\tif (1 == IsFull(board, row, col))\t&#123;\t\treturn &#x27;Q&#x27;;\t&#125;\t//继续\treturn &#x27;C&#x27;;&#125;\n\ntest.c#define _CRT_SECURE_NO_WARNINGS 1#include &quot;game.h&quot;void menu()&#123;\tprintf(&quot;**********************\\n&quot;);\tprintf(&quot;********1.play********\\n&quot;);\tprintf(&quot;********0.exit********\\n&quot;);\tprintf(&quot;**********************\\n&quot;);&#125;void game()&#123;\tchar ret = 0;\t//存储数据-二维数组\tchar board[ROW][COL] = &#123; 0 &#125;;\t//初始化棋盘 - 初始化空格\tIntboard(board, ROW, COL);\t//打印棋盘\tDisplay(board, ROW, COL);\twhile (1)\t&#123;\t\t//玩家走\t\tPlayerMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t//判断玩家是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\t//电脑走\t\tBotMove(board, ROW, COL);\t\tDisplay(board, ROW, COL);\t\t//判断电脑是否胜利\t\tret = Iswin(board, ROW, COL);\t\tif (ret != &#x27;C&#x27;)\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t//判断状态\tif (ret == &#x27;*&#x27;)\t&#123;\t\tprintf(&quot;玩家赢了\\n&quot;);\t&#125;\telse if (ret == &#x27;#&#x27;)\t&#123;\t\tprintf(&quot;电脑赢了\\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;平局\\n&quot;);\t&#125;&#125;void test()&#123;\tint input = 0;\tsrand((unsigned int)time(NULL));\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出游戏\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误，请重新选择!\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);&#125;int main()&#123;\ttest();\treturn 0;&#125;\n\ngame.h#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define ROW 3#define COL 3//初始化棋盘void Intboard(char board[ROW][COL], int row, int col);//打印棋盘void Display(char board[ROW][COL], int row, int col);//玩家走void PlayerMove(char board[ROW][COL], int row, int col);//电脑走void BotMove(char board[ROW][COL], int row, int col);//判断是否胜利char Iswin(char board[ROW][COL], int row, int col);//判断是否有空位#pragma once\n\n\n结语本篇三子棋的博客到此结束了\n感谢你看到最后！\n下篇博客会教大家，如何打包我们的代码为dll文件（此文件无法编译）\n点个赞再走吧，球球了！\n","categories":["C语言进阶"],"tags":["C语言","函数"]},{"title":"【C语言】数组练习题分享","url":"/2021/09/13/code/note_c/18%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0%E9%A2%98DAY21/","content":"好久没记录（氵）博客了，今天记录一下昨天学习的数组练习题中的内容\n\n\n数组练习题[TOC]\n\n昨天学习的练习题挺多的，下面只记录了几个我个人认为比较重要和典型的内容\n（1）错误的引用数组题目：\nint arr[10]=&#123;0&#125;;\n\n下面错误的引用方式是：\n\nA. arr[0]&#x3D;1        B.arr[0]&#x3D;5*2          C.   arr[10]&#x3D;2               D.arr[1]&#x3D;arr[2]*arr[0]\n\narr[10]代表数组中有10个元素，但是arr[10]的引用是下标，指第11个元素\n这超出了数组10个元素的范围\n答案是 C\n\n（2）数组中的逗号表达式请问以下代码输出的结果是什么？\n#include&lt;stdio.h&gt;int main()&#123;\tint arr[]=&#123;1,2,(3,4),5&#125;;    printf(&quot;%d\\n&quot;, sizeof(arr));    return 0;&#125;\n\n首先，arr数组中的每个元素都是一个整型元素，占用的字节是4个bit位\n所以sizeof计算数组中的元素个数，将它们所占空间相加\n\n其中逗号表达式(3,4)  —–&gt; 只产生一个结果，4\n\n以防万一，这里提一下逗号表达式的概念\n逗号表达式逗号表达式中的内容可以是数字，也可以是表达式\n#include&lt;stdio.h&gt;int main()&#123;\tint a =3;    int b=5;    int c=0;    //逗号表达式    int d=(c=1,a=c+3,b=a-4,c+=b);    printf(&quot;%d\\n&quot;,d);    return 0;&#125;\n\n这个代码的结果是1\n运算过程如下\n\nc&#x3D;1\na&#x3D;c+3&#x3D;1+3&#x3D;4\nb&#x3D;a-4&#x3D;4-4&#x3D;0\nc+&#x3D;b  —-&gt; c&#x3D;c+b&#x3D;1+0&#x3D;1\n\n逗号表达式会从左到右依次计算里面的每个表达式\n输出的结果是逗号表达式中最后一个表达式的结果\n所以上面数组中(3,4)这个逗号表达式产生的结果是4\nprintf输出的结果是16（4个元素）\n\n（3）数组中字符串和字符元素的区别int arr1[]=&#123;&quot;abcdef&quot;&#125;;int arr2[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;;\n\n\n数组arr1和arr2等价  ×\n\n一个是字符串，一个是字符元素，它们的含义是不同的\n\n数组arr1和arr2的长度相同   ×\n\n这两个的长度实际上是不同的\n因为“abcdef”这个字符串的后面，是有一个字符串结束标志\\0的\n\n数组arr1的长度大于arr2的长度  √\n\n（这里我可能有错的地方，还请dalao无情指正）\n\n（4）自定义函数与数组的简单练习题题目如下\n\n创建一个整形数组，实现以下操作\n1.实现函数init()初始化数组为全0\n2.实现print()打印数组中的每个元素\n3.实现reverse()函数完成数组元素的逆置\n\n前两个自定义函数的实现形式非常相似\n我们只需要用一个for循环，利用i依次访问数组中的每个元素，将它们打印出来或者赋值为0实现初始化\nvoid print(int arr[], int sz)//打印数组中的每个元素&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)    &#123;        printf(&quot;%d &quot;, arr[i]);    &#125;    printf(&quot;\\n&quot;);&#125;void init(int arr[], int sz)//将数组中的每个元素都初始化为0&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)    &#123;        arr[i] = 0;    &#125;&#125;\n\n这里需要注意的一个点是sz（数组元素个数）我们必须在主函数main中计算，不能在自定义函数中计算\n因为传过来的数组是首元素的地址，这时候用sizeof计算的数组元素长度是不准确的\n主函数main如下\nint main()&#123;    int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;    int sz = sizeof (arr)/sizeof( arr[0]);    printf(&quot;%d\\n&quot;, sz);    print(arr, sz);    reverse(arr, sz);    print(arr, sz);    init(arr, sz);    print(arr, sz);    return 0;&#125;\n\nreverse函数的基本理念和另外两个函数其实是相似的\n这里我们依旧会用到“空盒子”tmp来完成我们的交换\n同时我们需要使用循环来确认什么时候停止交换\n即左右两个数组元素的下标一样的时候（或者值一样）就停止交换\nvoid reverse(int arr[], int sz)//数组元素的逆置&#123;    int left = 0;    int right = sz - 1;    while(left &lt; right)    &#123;        int tmp = arr[left];        arr[left] = arr[right];        arr[right] = tmp;        left++;        right--;    &#125;&#125;\n\n当我们进行两个数组之间的元素调换的时候，也需要用for循环+tmp空盒子的方式一一交换每个数组对应下标的元素\n\n前提，两个数组的元素个数相同\n\n下面这种代码是错误的\nint tmp=arr1arr1=arr2arr2=tmp\n\n实现形式和上面打印和初始化的自定义函数的思路是一样的，这里不再赘述！\n\n如果本博客对你有帮助，还请点赞支持一下！这是对我的最大鼓励\n","categories":["C语言初识"],"tags":["C语言","数组"]},{"title":"【C语言】童年经典游戏-扫雷","url":"/2021/09/03/code/note_c/17%E6%89%AB%E9%9B%B7/","content":"\n\n想必屏幕前的你，肯定玩过windows XP系统自带的那个游戏，扫雷\n\n回想当年，我根本没看懂这个游戏是怎么玩的\n\n比起扫雷，三维弹球对我更有吸引力\n跑题了\n本篇博客就让我们一起来试试，如何通过C语言代码，制作出一个“扫雷游戏se”\n1.游戏程序主函数在编写这类游戏代码时，我们要用到的主函数基本是一致的\n扫雷游戏的主函数和猜数字游戏的主函数相差很小\n小白必学！简单的C语言应用&#x3D;&#x3D;＞猜数字游戏\nvoid menu()//简易目录&#123;\tprintf(&quot;***************************\\n&quot;);\tprintf(&quot;**** 1. play   0. exit*****\\n&quot;);\tprintf(&quot;***************************\\n&quot;);&#125;int main()&#123;\tint input = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();//实现游戏的函数\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出游戏\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;输入错误\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n2.游戏实现原理想写好一串代码，首先我们要知道扫雷游戏需要通过什么方式来实现\n\n我们需要一个9x9的棋盘，用于生成我们的雷以及玩家的游玩\n在c语言中当然无法直接产生这样的画面\n但我们可以同符号*或者#来代替网格，用1和0来表示有无雷\n如果我们只生成一个棋盘，那1和0会直接显示出来，达不到隐藏的效果\n所以我们需要用二维数组生成两个棋盘，一个用于存放雷，一个用于玩家的游玩\nchar mine[ROWS][COLS];//雷区布置char show[ROWS][COLS];//玩家看到的界面\n\n扫雷游戏我们使用头文件+源文件的形式撰写代码\n\n这样写代码的优点在于后续我们可以直接通过更改.h文件中的数组，从而更改我们的格子大小\n如: 改成12x12的游玩界面，改变雷区布雷个数等等\n\n所以我们需要在game.h中定义这些符号\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define ROW 9#define COL 9#define ROWS ROW+2#define COLS COL+2\n\n同时我们要在主函数的最上面引用这个自己写的头文件\n只要把库函数头文件放入game.h文件，在其他源文件中只需引用game.h\n不需要再次引用&lt;stdio.h&gt;、&lt;stdlib.h&gt;之类\n#include &#x27;game.h&#x27;\n\n棋盘大小为什么需要11x11？你可能注意到了，在生成数组的时候，我使用了ROWS，其值为ROW+2\n我们最终展示的只是9x9的游戏界面，但生成的棋盘其实是11x11的\n这是因为我们需要在mine数组中实现扫描雷区的操作\n\n玩过扫雷游戏的你肯定知道：在你点击一个格子的时候，如果这个格子不是雷\n它会显示一个数字，告诉你它周围的8个格子中有几颗雷\n\n如图所示：\n\n在C语言中，我们可以用函数统计周围8个格子中雷’1’的个数\n但是如果你来到边缘，那就出现问题了\n\n如果我们想统计边缘的格子周边有几颗雷，就会遇到这种溢出数组的情况\n此时代码会报错\n为了避免这个问题，我们可以在原来9x9的基础上在周围加一圈空白的格子\n也就是代码所示的ROW(行)COL(列)都要+2的情况\n#define ROW 9#define COL 9#define ROWS ROW+2#define COLS COL+2\n\n游戏过程这里简单梳理一下我们的游戏过程\n\n玩家选择开始游戏\n生成两个棋盘，一个放置雷\\扫描雷，一个向玩家展示游戏界面\n玩家输入坐标，选择排雷位置\n有雷–&gt;玩家被炸死，游戏结束；无雷–&gt;显示周边有几颗雷，游戏继续\n所有雷被排出，游戏胜利\n\n\n3.游戏代码实现接下来就进入我们的游戏代码部分\n3-1.初始化和打印//初始化扫雷InitBoard(mine, ROWS, COLS, &#x27;0&#x27;);InitBoard(show, ROWS, COLS, &#x27;*&#x27;);//打印扫雷DisplayBoard(mine, ROW, COL);DisplayBoard(show, ROW, COL);\n\n我们需要初始化两个棋盘，其中雷区初始化为0（0代表无雷），展示区初始化为’*’，用✳代替界面\n同时我们打印这两个棋盘，查看初始化效果\n因为这是我们的自定义函数，所以需要在.h文件中定义函数，在另外一个.c文件中包含函数的实现\n\n//初始化棋盘void InitBoard(char board[ROWS][COLS], int rows, int cols, char set);//打印void DisplayBoard(char board[ROWS][COLS], int row, int col);\n\n初始化函数和打印函数比较简单，使用for语句达成我们的需求\nvoid InitBoard(char board[ROWS][COLS], int rows, int cols, char set)&#123;\tint i = 0;\tint j = 0;\tfor (i = 0; i &lt; rows; i++)\t&#123;\t\tfor (j = 0; j &lt; cols; j++)\t\t&#123;\t\t\tboard[i][j] = set;\t\t&#125;\t&#125;&#125;void DisplayBoard(char board[ROWS][COLS], int row, int col)&#123;\tint i = 0;\tint j = 0;\tprintf(&quot;------扫雷游戏------\\n&quot;);\t//打印列号\tfor (i = 0; i &lt;= col; i++)\t&#123;\t\tprintf(&quot;%d &quot;, i);\t&#125;\tprintf(&quot;\\n&quot;);\tfor (i = 1; i &lt;= row; i++)//只打印中心的99方格\t&#123;\t\tprintf(&quot;%d &quot;, i);//打印行号\t\tfor (j = 1; j &lt;= col; j++)//只打印中心的99方格\t\t&#123;\t\t\tprintf(&quot;%c &quot;, board[i][j]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\tprintf(&quot;--------------------\\n&quot;);&#125;\n\n需要注意的是我们的最后打印棋盘的时候是从i&#x3D;1开始的，这样就能避开添加的空白边缘区域，只打印中心的99方格\n同时我们添加了列号和行号，这样能让玩家清除的知道自己应该输入什么坐标\n\n3-2.布置雷区//布置雷SetMine(mine, ROW, COL);\n\n这部分代码我在学习的时候就有点力不从心了\n同样的，我们需要在game.h中定义这个函数\n//布置地雷void SetMine(char mine[ROWS][COLS], int row, int col);\n\n在game.c中写入自定义函数的实现\n//放置雷void SetMine(char  mine[ROWS][COLS], int row, int col)&#123;\tint count = EASY_COUNT;\twhile (count)\t&#123;\t\tint x = rand() % row + 1;\t\tint y = rand() % col + 1;\t\tif (mine[x][y] ==&#x27;0&#x27;)\t\t&#123;\t\t\tmine[x][y] = &#x27;1&#x27;;\t\t\tcount--;\t\t&#125;\t&#125;&#125;\n\n这里面出现了一个前面没有提到的变量，EASY_COUNT\n本来这个位置只是个10\n但如果我们想更改布雷个数，那每次都需要更改这里的10，后面的代码中也需要更改，非常麻烦\n所以我们改为使用一个自定义变量，在game.h中定义这个变量的值\n#define EASY_COUNT 10\n\n这个值就代表我们布置雷的个数了\n3-3.玩家排查雷//在主函数中引用这个函数\tFindMine(mine,show, ROW, COL);//需要把mine数组中排查的雷放入show//在game.h中定义这个函数void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS],int row, int col);\n\n因为我们需要把mine数组中排查出的雷的个数放入show数组中打印出来\n所以这里我们需要把两个数组都传送过去\n\n1.输入排查的坐标2.检查坐标处是不是雷(1)是雷 -boom！炸死 -游戏结束(2)不是雷 -统计坐标周围有几个雷-存储排雷的信息到show数组，游戏继续\n\nvoid FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)&#123;\tint x = 0;\tint y = 0;    \twhile (1)\t&#123;\t\tprintf(&quot;请输入排雷坐标:&gt; &quot;);\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\t//判断坐标是否正确\t\tif (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)\t\t&#123;\t\t\tif (mine[x][y] == &#x27;1&#x27;)\t\t\t&#123;\t\t\t\tprintf(&quot;很遗憾，你被炸死了\\n&quot;);\t\t\t\tDisplayBoard(mine, ROW, COL);\t\t\t\tbreak;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//不是雷的情况下，统计坐标周围有几个雷\t\t\t\tint count = get_mine_count(mine, x, y);\t\t\t\tshow[x][y] = count + &#x27;0&#x27;;\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;坐标错误，请重新输入 \\n&quot;);\t\t&#125;\t&#125;&#125;\n\n注意，这里面我们需要添加一个代码来判断坐标合法性\n我们的棋盘是9x9，玩家要是输入一个(99,99)的坐标，那肯定不在数组中的，是无效的\n我们需要提醒玩家他输错了\n‘0’的作用show[x][y] = count + &#x27;0&#x27;;\n\n你可能会对这行代码感到疑惑\n为什么要在count后面+上一个‘0’？\n这里就和我们ascii码表有关了\n\n因为我们初始化数组和布置雷的时候，我们给数组传入的都是1和0这两个符号，并不是数字！\n但是在show数组中我们需要给玩家显示一个数字的字符\n\n这里面我们提供的是1的字符，并不是1它本身\n而我们在计算周边雷的个数的时候，传回来的是一个具体的数字\n观察表格，你会发现数字和对应的字符中间，都差了48\n而48恰好是字符’0’对应的ASCII码值\n所以我们需要用count加上字符’0’，以此在界面中向玩家展示周边8格有几颗雷\n3-4. 系统扫描雷如何把玩家选择的格子周边的雷扫描出来呢？\n设玩家的选择的坐标为x和y\n\n\n\nx-1,y-1\nx-1,y\nx-1,y+1\n\n\n\nx,y-1\nx,y\nx,y+1\n\n\nx+1,y-1\nx+1,y\nx+1,y+1\n\n\n我们只需要把这些坐标全部在二维数组中键入，就能逐个扫描出雷的个数\n//统计雷的个数static int get_mine_count(char mine[ROWS][COLS], int x, int y)&#123;\treturn mine[x - 1][y - 1] +\t\tmine[x - 1][y] +\t\tmine[x - 1][y + 1] +\t\tmine[x][y - 1] +\t\tmine[x][y + 1] +\t\tmine[x + 1][y - 1] +\t\tmine[x + 1][y] +\t\tmine[x + 1][y + 1] - 8 * &#x27;0&#x27;;&#125;\n\n这里因为我们扫描出来的也是‘1’的字符，系统中是字符1的ascii码值49\n所以我们需要减去8个字符‘0’，这样就能得到雷的个数的数字\n（然后在之前的那个函数中接受，count+‘0’，在show数组中显示）\n\n这个函数是在玩家排查雷的函数之前的\n因为在主函数中我们不需要使用这个自定义函数，所以不需要在game.h中定义\n我们想让它只在game.c中生效，所以用static修饰它\n\n\nstatic的作用\n1.修饰局部变量2.修饰全局变量3.修饰函数\n\n\n上面的代码其实还少了一个东西\n我们需要判断玩家什么时候胜利——雷区的0（无雷方块）全部被玩家找出，玩家就胜利了\nint win = 0;while (win&lt; row * col - EASY_COUNT)\n\n这里我们需要更改的是whlie函数\n其中 row * col - EASY_COUNT  指方格总数减去雷的个数，得到的是无雷方块的个数\n玩家每成功排除一个无雷方块，win就会加一个数字\nelse&#123;\t//不是雷的情况下，统计坐标周围有几个雷\tint count = get_mine_count(mine, x, y);\tshow[x][y] = count + &#x27;0&#x27;;\t//显示排查出来的信息\tDisplayBoard(show, ROW, COL);       win++;&#125;\n\n当win达到无雷方块个数的时候，whlie循环就会停止\n随后我们判断玩家是否胜利，如果胜利，就打印棋盘，让玩家知道雷的位置\nif (win == row * col - EASY_COUNT)&#123;\tprintf(&quot;恭喜你，游戏胜利！\\n&quot;);\tDisplayBoard(mine, ROW, COL);&#125;\n\n这里必须要判断，因为你失败了也是会跳出循环的！\n到此，我们的扫雷代码就是完成了\n4.查看结果这里我作弊，将雷的个数设置为80并打印出布置雷之后的棋盘\n输入最后一个雷的位置，系统提示我们游戏胜利\n\n输入雷的坐标后，也会提示你被炸死了\n\n到这里我们可以确认代码是编写成功了！\n完整代码获取 &#x3D;&#x3D;&gt;  [DAY018 扫雷]\n\n感谢你看到最后，写这个博客用了我2个小时，点个赞再走吧！\n","categories":["C语言进阶"],"tags":["C语言"]},{"title":"【C语言】剔除最大最小值后，计算数组元素的平均值","url":"/2021/11/11/code/note_c/19%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC/","content":"双11也不能阻挡我学习的心！\n\n\n@[toc]\n问题引入\n题目内容：\n定义一个含10个整型元素的一维数组,从键盘上输入10个元素值,求去掉最大值和最小值之后的元素平均值.\n输入格式:\n用循环控制依次输入10个元素值，scanf语句中的格式控制串为: “%d”\n输出格式：\n输出平均值, printf中的格式控制串为 “%lf\\n”\n\n输入样例：\n2 3 4 5 6 2 4 6 4 3\n\n输出样例：\n3.833333\n\n\n理解1一般人看到这种题目，下意识会认为是去掉一个最大值一个最小值，再计算数组其他元素的最大值\n毕竟很多体育赛事都是这么计算选手的得分的\n实际上这道题并不是这么要求的，这点我们后面再提\n先来看看如何去掉数组中的一个最大值、一个最小值吧！\n去除一个最大&#x2F;最小值先理清思路\n\n需要找到数组中的最大值和最小值\n在计算平均值的时候需要剔除这两个值\n\n想清楚这两点后，方法就很明确了\n之前我写过一篇博客，有关如何查找数组中最大值的 [链接]\n这里我们就能用上那个博客里面的方法，不过是以自定义函数的方式实现\nint sp1(int arr[], int sz, int* pm)&#123;\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tif (arr[i] &gt; *pm)//找出最大值\t\t&#123;\t\t\t*pm = arr[i];\t\t&#125;\t&#125;\tfor (int k = 0; k &lt; sz; k++)\t&#123;\t\tif (arr[k] == *pm)//确认最大值的数值\t\t&#123;\t\t\treturn k;//返回该最大值的下标\t\t&#125;\t&#125;&#125;\n\n找出最小值的代码同上，只需要将其中的&gt;更改为&lt;\n在main函数中，我们需要设立两个变量来接收得到的最大值和最小值的下标\nint main()&#123;\tint arr[10] = &#123; 0 &#125;;\tint a, b = 0;\tdouble ave,sum= 0;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;arr[i]);\t&#125;\tint sz = sizeof(arr) / sizeof(arr[0]);\ta =sp1(arr, sz, &amp;max);\tb =sp2(arr, sz, &amp;min);\tfor (int k = 0; k &lt; 10; k++)\t&#123;\t\tif (k != a &amp;&amp; k != b)\t\t&#123;\t\t\tsum = sum + arr[k];\t\t&#125;\t&#125;\tave = sum / 8;\tprintf(&quot;%lf\\n&quot;, sum);\tprintf(&quot;%lf\\n&quot;, ave);\treturn 0;&#125;\n\n在最后计算sum的时候，只需要用if语句让K不等于最大值和最小值的下标，就能剔除这两个值\n同时，我们的平均数也只需要除以8即可\n运行结果键入数组中元素1-10，程序成功的输出了剔除1和10之后8个元素的平均值\n\n但当我们把题目示例输进去时，得出的答案却和题目要求不同\n\n\n题目实际要求上面提到，这道题的要求并不是只剔除一个最大值和最小值\n而是剔除所有的最大值和最小值\n2 3 4 5 6 2 4 6 4 3\n\n观察输入样例可以发现，这10个数字的最大值是6，最小值是2\n但是不管是最小值2和最大值6，都不止一个\n题目要求的就是要将这里面的所有2和6剔除掉，再计算剩余数据的平均值\n解题思路1&amp;2对上面的代码进行优化，以循环的方式继续寻找最大值的下标\n\n缺点：此方法可能会出现多删的情况\n\n或\n更改代码，在找到最大值下标后，查找数组中有几个元素同这个最大值相同，再返回他们的下标\n\n此方法需要用数组来存放找到的元素的下标，较为麻烦\n\n\n解题思路3 -冒泡排序先对数组进行冒泡排序，再剔除两边的最大值和最小值\n这里我选择的就是解题思路3\n\n冒泡排序的方式可以参考我之前的博客 [链接]\n这里只贴出主函数内需要编写的内容\n计数器因为需要剔除多个最大（小）值\n所以这里我们需要用一个变量进行计数\n每当我们找到和已知最大值相同的数字的时候，count都会++（初值为1）\n当循环走到第一个小于最大值的数后，循环就会终止\nint count2 = 1;for (int k = 8; k &gt;0 ; k--)\t&#123;\t\tif (arr[k] == arr[9])\t\t&#123;\t\t\tarr[k] = 0;//令最大值为0\t\t\tcount2 ++;\t\t&#125;\t\telse \t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\n\n查找最小值的代码同上，但是for循环中的条件需要更改\n注意，这里的下标k必须从8开始而不是从9\n因为经过冒泡排序后，arr[9]本身就是数组中的最大值\n若从它开始循环判断，就会直接把最大值赋值为0\n程序就出bug了\n\n主函数代码int main()&#123;\tint arr[10] = &#123; 0 &#125;;\tint a, b = 0;\tdouble ave, sum = 0;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;arr[i]);\t&#125;\tint sz = sizeof(arr) / sizeof(arr[0]);\t//先对数组进行冒泡排序\tbubble_sort(arr, sz);\t//此时下标0和9即为最大最小值\tint max = arr[0];\tint min = arr[9];\tint count1 = 1;\tint count2 = 1;\tfor (int j = 1; j &lt; 10; j++)\t&#123;\t\tif (arr[j] == arr[0])\t\t&#123;\t\t\tarr[j] = 0;//令最小值为0\t\t\tcount1 ++;\t\t&#125;\t\telse\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\tfor (int k = 8; k &gt;0 ; k--)\t&#123;\t\tif (arr[k] == arr[9])\t\t&#123;\t\t\tarr[k] = 0;//令最大值为0\t\t\tcount2 ++;\t\t&#125;\t\telse \t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\t//令前后两个最大最小值为0\tarr[0] = 0;\tarr[9] = 0;\tfor (int k = 0; k &lt; 10; k++)\t&#123;\t\t\tsum = sum + arr[k];\t&#125;\t//除去已知的所有最大最小值，计算平均数\tave = sum / (10- count1- count2);\t//printf(&quot;%lf\\n&quot;, sum);\tprintf(&quot;%lf\\n&quot;, ave);\treturn 0;&#125;\n\n在最后计算平均数的时候，我们需要剔除count1和count2（10减去后即为剩余元素的个数）\n这时候得出的答案就和题目所给示例相同了\n\n你学废了嘛？反正我是废了 \n","categories":["C语言初识"],"tags":["C语言","数组"]},{"title":"【C语言】野指针是什么？指针在什么情况下会出错？","url":"/2021/09/16/code/note_c/20%E9%87%8E%E6%8C%87%E9%92%88/","content":"@toc\n什么是野指针？概念︰野指针就是指针指向的位置是不可知的（如：随机的、不正确的、没有明确限制的)\n说人话就是：野指针是错误的指针引用形式，通常有以下四种情况\n\n指针未初始化\n越界访问\n指针指向的空间已释放\n\n1.指针未初始化这个概念非常容易理解，同变量一样，指针同样需要我们的初始化\n//初始化指针int a = 10;int*p = &amp;a;\n\n指针未初始化 通常是以下情况\nint main()&#123;\tint*p;\t*p=20;&#125;\n\n这里的指针并没有指向某个内存地址，即便我们更改它的内容也是无效的\n\n指针会默认赋予一个随机值，属于非法访问内存\n\n当然，编译器遇到这种情况会直接报错\n\n2.越界访问越界访问的情况通常出现在数组中\nint arr[10]=&#123;1,2,3,4,5&#125;;int* p=arr;\n\n我们知道，数组名代表是首元素的地址\n我们可以利用 for循环和指针++ 的方式，使指针访问数组中的每个元素\nint main()&#123;\tint arr[5]=&#123;1,2,3,4,5&#125;;\tint* p = arr;    int i =0;    for(i=0;i&lt;=5;i++)    &#123;        *p=0;        p++;    &#125;&#125;\n\n我们知道，数组中的元素访问都是通过下标的方式。5个元素的数组，下标是从0-4\n而在此代码中，p++第五次的时候，下标已经变成了5，对应的是第六个元素\n但数组中并没有第六个元素，此时指针访问的就是一个空的地址了\n同样属于非法访问\n这就是越界访问的一种\n3.指针指向的空间已释放每当我们定义一个变量时，系统都会赋予这个变量一个内存的地址空间\n这时候我们把这个地址赋予给指针p，指针便记录下了这个地址\n用图来给大家演示一下什么叫指向的空间已释放\n\n代码示例如下\nint* test()&#123;\tint a = 10;\treturn &amp;a;&#125;int main()&#123;\tint* p = test();\t*p = 20;\treturn 0;&#125;\n\n\n\n如何避免野指针？1.指针初始化在使用指针的时候，我们要像创建变量一样初始化指针\n如果不知道把指针初始化为什么，那就赋值为NULL(代表0)\n\n 1 int main() 2 &#123; 3     //当前不知道p初始化为什么的时候 4     //直接初始化为NULL(空指针--&gt;0) 5     int* p = NULL; 6     //明确知道初始化的值 7     int a = 10; 8     int* ptr = &amp;a; 9     10     return 0;11 &#125;\n\n2.小心指针越界在使用指针的时候，我们要注意不能让指针越界\n如遇到数组的情况，一定要注意下标和元素个数的区别\n\n注意：C语言本身是不会检查数据的越界行为的！\n\n3.指针指向空间释放就置之为NULL在我们指针使用完毕之后，为了避免指针指向的空间被系统释放\n我们可以将指针初始化为空指针,NULL\n4.指针使用之前检查有效性什么是有效性?\nNULL的空指针就是无效的\n为了避免我们引用这种无效的空指针，我们可以在使用指针之前用if语句判断一下它是否为空\nif(p!=NULL)\t*p=10;\n\n判断为有效指针，我们再使用它\n做到以上4点，就能基本避免我们的代码出错。这只能避免，并不能杜绝\n“你永远叫不醒一个想写bug的人”\n\n结语以上就是野指针的基本解释，希望对你有帮助\n点个赞再走吧！万分感谢！\n","categories":["C语言初识"],"tags":["C语言","指针"]},{"title":"【C语言】二级指针","url":"/2021/09/28/code/note_c/21%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/","content":"二级指针什么是二级指针？我们通常使用的int*p就是一个一级指针，而二级指针存放的变量就是一个一级指针代码示例如下：\nint main()&#123;\tint a =10;    int*pa= &amp;a;                    //有两个*号 的原因    int ** ppa= &amp;pa;//int*是代表变量pa的类型，*ppa表明这是一个指针变量        return 0；&#125;\n\n这里面pa是指针变量，一级指针\nppa是二级指针变量，&amp;pa取出pa在内存中的起始地址\n如图所示\n小结简单的说，指针变量也是变量，变量就有属于它的地址，而二级指针就是用来存放指针变量的地址的\n希望这对你有帮助！\n","categories":["C语言初识"],"tags":["C语言","指针"]},{"title":"【C语言】如何将输入的数字逆序打印","url":"/2021/11/11/code/note_c/22%E5%A6%82%E4%BD%95%E5%B0%86%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E5%AD%97%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0/","content":"﻿这个问题是我在做学校的作业时候看到的。只隐约有印象讲过，但是忘记了怎么操作。听同学的点通才回想起来，特此写个博客留记\n\n\n[toc]\n逆序打印目的：输入“789”，打印“987”\n\n注：本博客的数字逆序只涉及 十进制\n\n代码实现有两种方式：1.利用if语句进行大小判断，直到选出从大到小的数字排序这个方法十分复杂，稍不留意就会弄错，所以在实际应用中不推荐这样操作这里就不赘述具体代码了。(才不是懒，压根没试过）2.使用%10的方法直接打印代码如下：\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 0;\tscanf(&quot;%d&quot;, &amp;a);\tprintf(&quot;%d&quot;, a % 10);\tprintf(&quot;%d&quot;, a/10 % 10);\tprintf(&quot;%d&quot;, a/100 % 10);\treturn 0;&#125;\n\n代码结果如下这个代码成功达到了我们的目的，但是有一个比较明显的弊端如果我们需要更多位的数字的逆序数时，这个代码就会变得很长，而且每次都需要我们手动添加一个新的printf\n\n代码优化1想要逆序比较长的数字，就需要用到循环语句，我使用的是for循环主要需要解决的问题是，a每%10一次后就需要除以10再%10一次\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 0;\tint n = 0;\tint i = 0;\tprintf(&quot;请输入需要逆序的数字：&quot;);\tscanf(&quot;%d&quot;, &amp;a);\tprintf(&quot;请输入该数字的位数：&quot;);\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\t\tprintf(&quot;%d&quot;, a % 10);\t\ta /= 10;\t\t\t&#125;\treturn 0;&#125;\n\n代码运行结果如下我们的目的成功达成！\n\n代码优化2上面的代码虽然完成了我们设想的目的，但它还是有一个缺点\n需要用户手动输入数字的位数\n\n设想一下，系统需要你填写你的手机号，你输入自己的手机号后，系统还要再问问你“你的手机号有几位数”\n这换谁都血压飙升，怒m代码猿了吧！\n\n那怎样让代码自动逆转我们需要的数字呢？\n\n注：这串代码是我在b站看到的，顿时联想到了自己的博客，于是又跑过来更新了! 原视频链接\n\n\n图里while后面的不等于符号应该是一个vscode的插件，我们需要将它改成!&#x3D;\n#include &lt;stdio.h&gt;int main()&#123;\tint num;\tprintf(&quot;请输入一个数；&quot;);\tscanf(&quot;%d&quot;, &amp;num);\tint reverse = 0;\twhile (num != 0)\t&#123;\t\treverse = reverse * 10 + num % 10;\t\tnum /= 10;\t\t\t&#125;\t//输出反转后的数字\tprintf(&quot;反转后的数字是：%d\\n&quot;, reverse);\treturn 0;&#125;\n\n\n这串代码就是完美的了吗？\n并不是，如果我们键入1000，结果就会发生一些细微的变化\n\n输出的结果竟然是1，但我们需要的应该是0001\n\n代码优化3这里涉及到了%d时左补0的问题\nprintf打印时%d左补0假设下面这串代码是需要输出1000逆序后数字0001的printf语句\n因为1000只有4位，所以我们可以在%和d之间加上04\n即满4位不补，不满4位左补0\nint n =1;pirntf(&quot;%04d&quot;,n);\n\n但在逆序数字里面，我们需要打印的数字长度是不可控的\n这里需要用到左补0的另外一种代码\n\n用另外一个变量来表示数的位数\n\nint n=1;int m=3;//代表数的位数，同%03d里面3的意义一样pirntf(&quot;%0*d&quot;,m,n);\n\n这样下来就简单了，我们只需要在原有的while循环里面加上另外一个变量\n每次逆序循环完成后，这个变量都++一次，就能达到我们的目的\n#include &lt;stdio.h&gt;int main()&#123;\tint num;\tint j = 0;\tprintf(&quot;请输入一个数；&quot;);\tscanf(&quot;%d&quot;, &amp;num);\tint reverse = 0;\twhile (num != 0)\t&#123;\t\treverse = reverse * 10 + num % 10;\t\tnum /= 10;\t\tj++;\t&#125;\t//输出反转后的数字\tprintf(&quot;反转后的数字是：%0*d\\n&quot;,j, reverse);\treturn 0;&#125;\n\n运行结果如下：\n\n这下我们的目的才真正完成了，既可以不用自己多输入一遍数字的个数\n又能在输入10000这类数字的时候，逆序后自动左补0\n\n希望这对你有帮助！","categories":["C语言初识"],"tags":["C语言","数组"]},{"title":"【C语言】printf函数的执行顺序，涉及函数传参","url":"/2021/10/26/code/note_c/23printf%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E5%BC%8F/","content":"问题产生偶然在c语言学习交流群看到了这么一串让人费解的代码\n\n#include &lt;stdio.h&gt;int main()&#123;\tint i = 0;\tint j = 0;\tscanf(&quot;%d&quot;, &amp;i);\tj = -i++;\tprintf(&quot;%d %d %d&quot;, i, j, i++);\treturn 0;&#125;\n\n这里让我疑惑的是，为什么打印的第一个i是6而不是5？\n\nprintf语句的执行顺序这里要涉及到一个之前我并不清楚的知识点\nscanf(&quot;%d&quot;, &amp;i);j = -i++;printf(&quot;%d %d %d&quot;, i, j, i++);\n\n按照以往我的理解，代码的运行顺序是这样的\n\n1.用scanf将数字赋值给i\n2.将-i赋值给j，然后i++ （注：后置++是先使用再++）\n3.printf函数依次打印5，-4，6\n\n可代码君它并不想这么跑\n这里要涉及到函数内数据传参的问题\n函数内数据传参函数的传参是从右往左开始传参的\n所以这串代码在运行到printf的时候，会先执行第二个i++语句，此时i&#x3D;6\n然后再从左往右依次打印i，j，和后置++之前的i\n\n“首先-i++，是把-i的值-4给了j，然后i++变成了5，接下来就是函数的传参了，一般是从右3向左传参的”\n\n打印是从左往右打印，但是括号内部从右往左计算\n\n总结这里送给大家一张图，总结这个问题的原理\n如果对你有帮助，还请点个赞再走吧！\n\n","categories":["C语言初识"],"tags":["C语言","函数"]},{"title":"【C语言】简单的printf递归","url":"/2021/10/26/code/note_c/24%E7%AE%80%E5%8D%95print%E9%80%92%E5%BD%92/","content":"简单的Print递归\n说句题外话，很多时候单词我是认识的，但是如果它全大写了，我总要反应老一会才能想出来它的意思\n有和我一样的人吗?\n\n今天的c语言课讲到了一道非常经典的递归题目\n代码如下：\n#include &lt;stdio.h&gt;void Print(int n)&#123;\tif (n &gt; 9)\t\tPrint(n / 10);\tprintf(&quot;%d &quot;, n % 10);&#125;int main()&#123;\tint num = 0;\tscanf(&quot;%d&quot;, &amp;num);\tPrint(num);\treturn 0;&#125;\n\n结果如下\n\n运行顺序谈到递归的时候，最重要的就是要弄明白它究竟是怎么运行的\n老师上课讲的方法非常直观的表示了它的运算顺序\n这里我用粘贴代码块的方式来展示\n刚开始执行的是scanf输入，这里不再赘述\nvoid Print(int n)&#123;\tif (n &gt; 9)\t\tPrint(n / 10);\tprintf(&quot;%d &quot;, n % 10);&#125;\n\n这一块是我们递归的主体\nvoid Print(int n)&#123;\tif (n &gt; 9)\t  Print(3578 / 10);    \t\tif (n &gt; 9)\t\t\tPrint(357 / 10);    \tprintf(&quot;%d &quot;, 357 % 10);//7    \t\t\tif (n &gt; 9)\t\t\t\tPrint(35 / 10);    \t\tprintf(&quot;%d &quot;, 35 % 10);//5    \t\t\t\tif (n &gt; 9)//这时候值为3，已经不满足条件\t\t\t\t\t\tPrint(3 / 10);//该语句不执行    \t\t\tprintf(&quot;%d &quot;, 3 % 10);//3\tprintf(&quot;%d &quot;, 3578 % 10);//8&#125;\n\n看起来可能有点乱，在这基础上加上一些箭头就会清晰了\n\n起初我的想法是，在进行if判断之后，会先执行下面的printf，即先打印最后一位数8，再向前打印\n\n实际上，if语句后的Print函数的嵌套调用是在下一行printf之前的、\n也就是说它需要像图中这样完全调用完，直到if判断为假后，才会从后往前运行printf语句\n这才有了最开始我贴的结果\n程序依次打印了每一位的数字\n\n\n如果这篇博客对你有帮助，还请点赞收藏支持一下！万分感谢！\n","categories":["C语言初识"],"tags":["C语言","函数"]},{"title":"【C语言】验证哥德巴赫猜想","url":"/2021/10/30/code/note_c/25%E9%AA%8C%E8%AF%81%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3/","content":"问题来源这是学校的一个作业，原题如下\n\n题目先给出了哥德巴赫猜想的背景知识（我还真不知道）\n2000以内的正偶数都能分解成两个质数（素数）之和\n题目要求下面来梳理一下题目的要求：\n\n输出样式为a&#x3D;b+c，使用%4d&#x3D;%4d+%4d输出\n每行输出4个，每行最后一个输出无空格\n每个偶数只需要一个结果即可（后续较大的偶数有很多种解）\n\n弄懂了题目要求，下面就来一步一步写代码\n\n如何判断素数？在上篇博客里面提到了如何判断素数&#x3D;&#x3D;&gt;【链接】，这里不再赘述 \n我们需要搞定的是判断是那两个素数b、c相加等于我们需要的那个数a\n因为需要多次判断，这里我们使用自定义函数\nint SuShu(int a)&#123;\tif (a == 2)\t&#123;\t\treturn 1;\t&#125;\tint j = 0;\tfor(j = 2; j &lt;=sqrt(a); j++)\t&#123;\t\tif (a % j == 0)\t\t&#123;\t\t\treturn 0;\t\t&#125;\t&#125;\treturn 1;&#125;\n\n为什么是return1和0呢？\n因为在写这段代码的时候，我本来是想判断之后返回一个素数，但是这个方法效率太低\n而且写到后面我自己都不会写了，遂放弃。\n\n主函数\n最终实现形式：n&#x3D;a+(n-a)\n\n在自定以函数里面返回的值是1和0\n主函数里面就需要内容来接收\nif (SuShu(a) &amp;&amp; SuShu(n - a))//判断a和n-a是否都是素数\n\n同时我们需要完成打印4行换一行，以及每行最后一个不能有空格的要求\n这时候直接在printf语句里面加空格已经不够了\n需要用到判断语句，判断已经打印了几个等式\nif (SuShu(a) &amp;&amp; SuShu(n - a))&#123;\tprintf(&quot;%4d=%4d+%4d&quot;, n, a, n - a);\tcount++;//每打印一次就++一次\tif (count % 4 == 0)\t&#123;  //打印4次后打印一个换行符\tprintf(&quot;\\n&quot;);\t&#125;\telse\t&#123;  //不够4次，需要打印空格\tprintf(&quot; &quot;);\t&#125;&#125;\n\n素数判断的部分我们已经写完了\n接下来要写的是一个for循环，让n从4开始一直+到2000\n另外，同【如何判断素数】博客中的开平方法一样\n在验证哥德巴赫猜想的时候，若a&#x3D;b+c，b和c中肯定有一个数小于或等于a&#x2F;2\n在写a的for循环的时候，我们可以让判断条件a&lt;&#x3D;n&#x2F;2，而不是a&lt;n\nfor (n = 4; n &lt;= 2000; n+=2)&#123;\tfor (int a = 2; a &lt;= n/2 ; a++)\t&#123;  //在之前我们并没有定义a，需要在for循环里加上int\t\tif (SuShu(a) &amp;&amp; SuShu(n - a))\t\t&#123;\t\t\tprintf(&quot;%4d=%4d+%4d&quot;, n, a, n - a);\t\t\tcount++;\t\t\tif (count % 4 == 0)\t\t\t&#123;\t\t\t\tprintf(&quot;\\n&quot;);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tprintf(&quot; &quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t&#125;\n\n到这里，我们的主函数也完成啦！\n完整代码+效果演示#include &lt;stdio.h&gt;#include &lt;math.h&gt; int SuShu(int a)&#123;\tif (a == 2)\t&#123;\t\treturn 1;\t&#125;\tint j = 0;\tfor(j = 2; j &lt;=sqrt(a); j++)\t&#123;\t\tif (a % j == 0)\t\t&#123;\t\t\treturn 0;\t\t&#125;\t&#125;\treturn 1;&#125;//验证哥德巴赫猜想，输出4到2000的偶数//每个偶数的结果只输出一次int main()&#123;\tint n = 0;\tint count = 0;\tfor (n = 4; n &lt;= 2000; n+=2)\t&#123;\t\tfor (int a = 2; a &lt;= n/2 ; a++)\t\t&#123;\t\t\tif (SuShu(a) &amp;&amp; SuShu(n - a))\t\t\t&#123;\t\t\t\tprintf(&quot;%4d=%4d+%4d&quot;, n, a, n - a);\t\t\t\tcount++;\t\t\t\tif (count % 4 == 0)\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;\\n&quot;);\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tprintf(&quot; &quot;);\t\t\t\t&#125;\t\t\t\tbreak; //只打印一种情况\t\t\t&#125;\t\t&#125;\t\t\t&#125;\treturn 0;&#125;\n\n细心的你肯定注意到，在main函数中判断素数的语句里多了一个break，它的作用是什么呢？\n如果没有break，结果如下：\n代码会将符合条件的素数相加全部打印出来\n这显然不符合每个偶数的结果只输出一次的要求\n\n但在加了break这个断点之后\n代码的结果就和题目要求的一样了\n\n\n写代码中的误解在最终提交代码的时候，我的代码格式出错了\n原因是我在printf语句里面加多了两个空格，如下：\nprintf(&quot;%4d= %4d+ %4d&quot;, n, a, n - a);\n\n为什么我会想当然的多加两个空格呢？\n因为题目所给的输出样例，让我误以为&#x3D;和+之间都有两个空格\n\n实际上这里并没有空格，它的“空格”是printf中的%4d造成的\n代码给这里留了4个数字的位置，但是大多都只有一个数字和两个数字\n于是它们前面就会有3或者2个留给数字的空，让我误以为这里有空格\n基础不牢，地动山摇！\n\n总结通过这道题，我复习了循环和自定义函数的写法，也获得了哥德巴赫猜想的新知识\n多刷刷题总是好的\n希望这篇博客对你有帮助！\n","categories":["C语言初识"],"tags":["C语言","函数"]},{"title":"【C语言】如何判断素数","url":"/2021/10/30/code/note_c/26%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/","content":"如何判断素数\n题目要求：输出100-200的素数\n\n首先我们要知道什么是素数（质数），以防有人忘记（比如刚学开始学c的我就忘记了）\n素数（质数）只能被1和它自己整除\n\n\n7只能被1和7整除，是素数\n9能被3整除，不是素数\n\n\n方法1—试除法#include&lt;stdio.h&gt;int main()&#123;    int i=0;    int count=0;    for(i=100;i&lt;=200;i++)    &#123;        int j=0;        for(j=2;j&lt;i;j++)        &#123;             if(i%j==0)//i可以整除j，i不是素数             &#123;                 break;             &#125;        &#125;        if(j==i)//i只能整除它自己，是素数        &#123;            count++;            printf(&quot;%d &quot;,i);        &#125;    &#125;    printf(&quot;\\ncount=%d\\n&quot;,count);//计算100-200之间有几个素数    return 0;&#125;\n\n\n这个代码比较死，只是输出了100到200之间的素数，完成了题目的要求\n我们可以把它改造成输入一个数字，判断是否是素数的形式\n\n代码改造1-1\n用户输入一个数字\n代码判断是否为素数\n是，输出“是素数”以及用户输入的值\n不是，输出“不是素数”\n\n#include&lt;stdio.h&gt;int main()&#123;    int i=0;    int j=0;    scanf(&quot;%d&quot;,&amp;i);    for(j=2;j&lt;i;j++)    &#123;    \tif(i%j==0)        &#123;            printf(&quot;不是素数\\n&quot;);            break;    \t&#125;\t&#125;    if(j==i)    &#123;        printf(&quot;是素数,i=%d\\n&quot;,i);    &#125;      &#125;\n\n结果如下：\n\n\n\n上面的这串代码能很好地完成我们的需求，但它还有优化的空间\n方法2—开平方法方法1中的for循环为j&lt;i\n如果数字很大的话，要循环非常多次才能出现j&#x3D;&#x3D;i的情况\n这就拖慢了我们程序运行的速度\n这里我们引入一个概念\n\n若i&#x3D;a*b\na和b中至少有一个数字 &lt;&#x3D; 开平方i\n\n\n如16&#x3D;2x8&#x3D;4x4\n其中2&lt;4\n\n这样就能得到一个结论：\n在根号i之前一定有一个数字n是非素数的除数\n如果找不到这个数字n，说明该数字为质数\n\n利用开平方法，我们可以将需要查找的数字范围缩小很多\n以下是用该方法完成开头题目要求的代码示例\n#include&lt;stdio.h&gt;int main()&#123;\tint i=0;\tfor(i=101;i&lt;=200;i+=2)\t&#123;\t\tint j=0;\t\tfor(j=2;j&lt;=sqrt(i);j++)\t\t&#123;\t\t\tif(i%j==0)\t\t\t&#123;\t\t\t\tbreak;             &#125;\t\t&#125;\t\tif(j&gt;sqrt(i))\t\t&#123;\t\t\tprintf(&quot;%d &quot;,i);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n\n将这个代码改造成1-1那种形式也不难，自己试试吧！\n两个方法分别的弊端试除法该方法会错过1\n开平方法该方法会错过2\n\n感谢你看到最后如果这篇博客对你有帮助，请点赞支持一下，万分感谢！\n","categories":["C语言初识"],"tags":["C语言","函数"]},{"title":"【C语言】用递归和非递归，求第n个斐波那契数","url":"/2021/11/07/code/note_c/27%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","content":"[toc]\n问题引入 - 什么是斐波那契数列？斐波那契数列中，第n项为n-1和n-2项之和\n\n1，1，2，3，5，8，13，21，34，55……\n\n这个数列非常经典，经常用于编程语言初学者的练习\n接下来让我们用非递归和递归两种方式来实现这个数列\n并了解两种方法的优缺点！\n\n1.非递归方法（迭代）什么是迭代？\n迭代其实和循环的意义差不多（个人理解）\n\n我们计算斐波那契数列的时候，需要从第一项和第二项1、1开始计算\n没后一项数字都是前两项数字之和\n这样我们就可以利用循环，从第一项开始不断相加，再使其中一个加数等于得到的和\n以此迭代，就能得到我们需要的第n个数字\n\n代码实现#include&lt;stdio.h&gt;//非递归int fo1(int a)&#123;\tint tmp = 0;\tint num1 = 1;\tint num2 =1;\tif (a &lt; 3) //前两项都为1\t&#123;\t\treturn 1;\t&#125;\telse//从第三项开始迭代\t&#123;\t\tfor (int i = 0; i &lt;= a - 3; i++)\t\t&#123;\t\t\ttmp = num1 + num2;\t\t\tnum1 = num2;\t\t\tnum2 = tmp;\t\t&#125;\t\treturn tmp;\t&#125;&#125;int main()&#123;\tint a,b = 0;\tscanf(&quot;%d&quot;, &amp;a);\tb=fo1(a);\tprintf(&quot;%d\\n&quot;, b);\treturn 0;&#125;\n\n结果如图：\n\n迭代的缺点这种方法有个缺点，即数字很大的时候，容易栈溢出\n如果栈溢出没有影响，迭代的方法就非常适合\n\n比如：\n\n题目规定了不考虑栈溢出\n\n题目设定了数字范围\n\n\n\n\n2.递归使用递归的基本方法，和迭代其实是一样的\n最大的不同是：递归的核心是函数自己调用自己\n\n代码实现#include&lt;stdio.h&gt;//递归int fo2(int a)&#123;\tif ((a == 1) || (a == 2))\t&#123;\t\treturn 1;\t&#125;\telse\t&#123;\t\treturn (fo2(a - 1) )+( fo2(a- 2));//n-1和n-2项\t&#125;&#125;int main()&#123;\tint a,b = 0;\tscanf(&quot;%d&quot;, &amp;a);\tb=fo2(a);\tprintf(&quot;%d\\n&quot;, b);\treturn 0;&#125;\n\n最终执行的效果是一样的\n递归的缺点递归的实现方式是函数不停地自己调用自己\n如图所示，当我们需要第50个斐波那契数列中的数时\n函数需要从50开始，49、48，再48、47……\n这么一直递归到第3个斐波那契列数，才能逐级返回每项的数字，得出最终答案\n这就大大增加了程序运行的时间！\n\n你可能会发现程序依旧很快运行完了，那是因为现在电脑cpu的运行速度已经非常快了\n但在有运行时间要求的题目中，这样浪费时间是万万不可的\n\n\n总结递归和迭代两种方法各有优劣，我们需要在具体情境中选择是使用递归还是迭代\n计算斐波那契数列只是这其中的一部分\n如果这篇博客对你有帮助，那就点个赞再走吧！\n","categories":["C语言初识"],"tags":["C语言","数组"]},{"title":"【C语言】整型数据在内存中的存储(详解)","url":"/2021/12/03/code/note_c/28%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/","content":"[toc]\n数据类型我们知道，C语言中有很多不同的数据类型\n在cppreference.com网站上可以找到C语言中的不同类型【链接】\n\n先来认识一个不那么常见的类型\n布尔类型C99中引入了布尔类型  _Bool实质：把1和0变成ture和false\n#include&lt;stdbool.h&gt;int main()&#123;\t_Bool flag = true;\tif(flag)\t&#123;\t\tprintf(&quot;hehe\\n&quot;);\t&#125;\treturn 0;&#125;\n\n代码的效果如下：\n\n因为布尔类型和以1-0来判断正误的作用是相同的\n所以这个类型我们一般不会使用\n\n无符号数据的打印Unsigned无符号数用%u打印\n\n\n用%d打印的时候，认为是有符号数\n用%u打印无符号数的时候，负数会乱码\n\n\n我们知道，整型数据在内存中占用4个字节（32位），double类型是8个字节\n不同数据占用的字节\n在之前的学习中，我们已经知道了如何使用这些不同的数据类型\n但是你知道，数据在内存中是怎么存储的吗？\n这篇博客将带你认识整型在内存中的存储\n\n整型在内存中的存储先来认识一下整型家族都有谁吧！\n整型家族\n\nchar\n​\tunsigned char\n​\tsigned char\n\nshort\n​\tunsigned short [int]\n​\tsigned short [int]\n\nint\n​\tunsigned int\n​\tsigned int\n\nlong\n​\tunsigned long [int]\n​\tsigned long [int]\n\n\n\n我们平时用的最频繁的int其实是signed int\n\nchar到底是signed char还是unsigned char，取决于编译器的实现\n常见的编译器下，char就是signed char\n\n在知道整型在内存中的存储方式之前\n我们需要先认识一下三个好朋友“原 反 补”\n“原反补”三兄弟正整数：原反补码相同\n负整数：\n\n\n\n原码\n按照一个数的正负直接写出来的二进制\n\n\n\n反码\n符号位不变，其他位按位取反\n\n\n补码\n反码的二进制序列+1，得到补码\n\n\n二进制要怎么写出来呢？下面以15为例（前面省略了24位）\n每一个1都是2的权重\n\n这就是二进制和十进制转换的方式\n而15作为正数，原反补码都是这个二进制数\n\n00000000 00000000 00000000 00001111\n正数的原反补码相同\n\n\n什么是符号位？每一个整型都有4个字节，由32个bit位组成\n其中原码的第一位，就是该二进制的符号位\n正数为0，负数为1\n\n最高位为符号位，后面的是有效位\n\n再举个-15的例子\n\n\n\n10000000 00000000 00000000 00001111\n原码\n\n\n\n11111111 11111111 11111111 11110000\n反码\n\n\n11111111 11111111 11111111 11110001\n补码\n\n\n为了进一步了解数据在内存中的存储方式，我们将15的&#x3D;&#x3D;补码&#x3D;&#x3D;转化为十六进制\n每4个二进制比特位对应一个十六进制数，转换结果如下\n\n\n\n00000000\n00000000\n00000000\n00001111\n\n\n\n00\n00\n00\n0F\n\n\n\n可当我们在VS编译器-监视-内存窗口里面查看15数据的时候\n展示的是以下的16进制形式\n\n可以看到，内存中存储的十六进制，和我们计算出来的是&#x3D;&#x3D;反着的&#x3D;&#x3D;\n这又是为什么呢？\n\n大小端问题大端字节序存储：\n​\t\t当一个数据的低字节的数据存放在高地址处，高字节序的内容放在了低地址处，这种存储方式就是大端字节序存储\n小端字节序存储：\n​\t\t当一个数据的低字节数据存放在低地址处，高字节序的内容放在了高地址处，这种存储方式就是小端字节序存储\n\n简称：小同大异\n\n而我们图中VS内存窗口显示的这种“反着放”的方式，是因为：\n\nVS编译器下，内存窗口显示的是左低右高\n二进制码是高00000000 00000000 00000000 00001111低\n\n所以VS编译器是小端存储的\n\n而如果是以低00 00 00 0f高的方式放入内存，则是大端字节序存储\n\n负数示例\nint b=-10；\n\n\n\n\n原码10000000\n00000000\n00000000\n00001010\n\n\n\n反码11111111\n11111111\n11111111\n1110101\n\n\n补码11111111\n11111111\n11111111\n11110110\n\n\nf    f\nf    f\nf    f\nf    6\n\n\n\n了解了大小端的机制之后，我们可以来写一个简单的函数\n判断当前编译器是大端还是小端\n#include &lt;stdio.h&gt;int check_sys()&#123;\tint a=1;\tchar*p=(char*)&amp;a;\tif(1==*p)\t\treturn 1;\telse\t\treturn 0;\t\t&#125;int main()&#123;\tint b=check_sys(); \tif(1==b)\t\tprintf(&quot;小端\\n&quot;);\telse\t\tprintf(&quot;大端\\n&quot;);    \treturn 0; &#125; \n\n这串代码的自定义函数部分可以进行优化\n\n因为*p&#x3D;1时返回1\n其他情况返回0\n所以可以选择直接返回*p\n\n//代码优化2 int check_sys()&#123;\tint a=1;\tchar*p=(char*)&amp;a;\treturn *p;\t&#125;\n\n进一步优化，我们可以把(char*)&amp;a直接进行解引用并返回他的值\n这样就能跳过中间变量p\n//代码优化3int check_sys()&#123;\tint a=1;\treturn *(char*)&amp;a;\t&#125;\n\n这里有两个问题需要注意：\n不能直接对a进行强制类型转换，这种方式是错的\n大小端是把数据放在内存之后才有的现象\n\n大小端讲的是以字节为单位的顺序\nchar类型只有一个字节，没有大小端问题\n\n\n为什么整型在内存中存放的是补码呢？\n在计算机系统中，数值一般用补码来表示和存储，原因在于，试用补码，可以将符号位和数值域统一处理；\n同时，加法和减法也可以统一处理(CPU只有加法器)\n此外，补码与反码相互转换，其运算过程是相同的，不需要额外的硬件电路。\n\n计算机中只有加法器，减法用加法来模拟\n1-1→1+(-1)\n如果用原码的计算：\n\n\n\n00000000 00000000 0000000 00000001\n+\n\n\n\n10000000 00000000 0000000 00000001\n&#x3D;\n\n\n10000000 00000000 0000000 00000010\n-2 错误\n\n\n补码：\n\n\n\n00000000 00000000 0000000 00000001\n1原\n\n\n\n10000000 00000000 0000000 00000001\n-1原\n\n\n它们的补码\n\n\n\n00000000 00000000 00000000 00000001   +\n1的补码\n\n\n\n11111111 11111111 1111111 11111111   &#x3D;\n-1的补码\n\n\n00000000 00000000 0000000 00000000\n结果为0\n\n\n 其中第一个1为符号位\n\n结语到这里，整型在内存中存储的基本知识就已经讲完啦\n如果对你有帮助，还请不要吝啬手里的赞👍！\n能留下个评论就更好了\n这对我真的很重要！！！\n","categories":["C语言进阶"],"tags":["C语言","数据存储"]},{"title":"【C语言】整型提升和算术转换","url":"/2021/11/17/code/note_c/29%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BD%AC%E6%8D%A2/","content":"[toc]\n整型提升要想知道什么是整型提升，那就要从表达式求值说起\n表达式求值\n表 达 式 求 值 的 顺 序 一 部 分 是 由 操 作 符 的 优 先 级 和 结 合 性 决 定\n同 样，有 些 表 达 式 的 操 作 数 在 求 值 的 过 程 中 可 能 需 要 转 换 为 其 他 类 型 \n\n什么是表达式？ 举个最简单的例子\nint main()&#123;\tint a=3;\tint b=5;\tint c = a + b * 7;\t//c的式子即为表达式\treturn 0;&#125;\n\n而C的整个式子就是一个表达式求值\n在这之中，参与计算的两个变量以及结果变量都是int类型，并不需要进行整型提升\n在我们日常编写代码的时候，编译器经常会有隐式类型转换\n\n隐式类型转换\nC的整型算术运算总是至少以缺省整型类型的精度来进行的\n为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转化为普通整型，这种转换称为整型提升\n\nfloat f =3.14int num =f;\n\n在上面这个代码中就有隐式类型转换，由float型转换为int型\n但是会有精度的丢失\n\n此时num为3\n\n\n我们知道，不同数据类型的数据大小如下\n数据类型及大小\n\n\nchar\n字符数据类型\n4byte\n\n\n\nshort\n短整型\n2byte\n\n\nint\n整型\n4byte\n\n\nlong\n长整型\n4(32), 8(64)\n\n\nlong long\n长长整型\n8byte\n\n\nfloat\n单精度浮点型（实型）\n4byte\n\n\ndouble\n双精度浮点型（实型）\n8byte\n\n\n可以看到，short类型和char类型的字节数都是小于int类型的\n当我们将一个int类型的数据存放到char中时，会发生截断\n截断&amp;提升\n把四个字节放在1个字节的内容中，截断，只保留一个字节\n把数字5放入char类型中，5的4个字节的内容会被截断\n\n示例\nchar a = 3;   //00000000000000000000000000000011 为3的二进制   //00000011 -a\n\n在char类型a中，只存放了3的后8位(1个字节)的内容\n这就是截断的表现形式\n\n在char类型数据的表达式求值中，就会发生整型提升\n规则如下：\n\n把最高位视为符号位进行提升，在a和b的8位码前加24个0或1\n\n代码示例1#include &lt;stdio.h&gt;int main()&#123;    char a = 3;    //00000000000000000000000000000011 为3的二进制    //00000011 -a    char b = 127;    //00000000000000000000000001111111 为127的二进制    //01111111 -b    char c = a + b;    //把最高位视为符号位进行提升    //在a和b的8位码前加24个0    //00000000000000000000000000000011    //00000000000000000000000001111111    //00000000000000000000000010000010    //10000010 为char c    //11111111111111111111111110000010  -补码    //11111111111111111111111110000001  -反码    //10000000000000000000000001111110  -原码    // -126    //发现a和b都是char类型的，都没有达到一个int的大小    //这里就会发生整型提升    printf(&quot;%d\\n&quot;, c);//%d是有符号数，打印原码    return 0;&#125;\n\n编译器中，负数是以补码的形式存放的\n但在使用的时候，要先转换成原码再计算其数值\n代码示例2再来看一个比较大小的示例\nint main()&#123;\tchar a = 0xb6;\tshort b = 0xb600;\tint c = 0xb6000000;\t\tif(a==0xb6)\t\tprintf(&quot;a&quot;);\tif(b==0xb600)\t\tprintf(&quot;b&quot;);\tif(c==0xb6000000)\t\tprintf(&quot;c&quot;);        return 0;&#125;\n\n猜猜打印结果是什么？\n是这个吗？\nabc\n\n错！\n\n运行后，我们会发现编译器只打印了c这个字符\n\n因为if只会比较整型\n而char和short类型都不足4个字节，在比较的时候需要进行整型提升\n提升之后的结果与原数据不同\n\n而int c本身就是整型，无须进行整型提升\nint c = 0xb6000000;\n\n所以代码只打印了字符c\n\n代码示例3再来看下面的这个代码，打印的结果是几呢？\n#include &lt;stdio.h&gt;int main() &#123;    int a = 3;   int b = 5;    short s = 5;   printf(&quot;%u\\n&quot;, sizeof(s = a + 3));        return 0;&#125;\n\n结果为2\n因为最后的s是短整型，推断出来的长度为2\n\n代码示例4 -sizeofint main()&#123;\tchar c=1;\tprintf(&quot;%u\\n&quot;,sizeof(c));//1    printf(&quot;%u\\n&quot;,sizeof(+c));//4    printf(&quot;%u\\n&quot;,sizeof(-c));//4    printf(&quot;%u\\n&quot;,sizeof(!c));//4        return 0;&#125;\n\n当+c和-c参与计算的时候，就会进行整型提升\n\n这里涉及到了另外一个重要的知识点，sizeof括号中表达式的问题\n下篇博客会详细介绍!\n\n\n算术转换说完整型提升，接下来就是和隐式类型转换很像的算术转换\n\n如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转换为另外一个操作数的类型，否则操作就无法进行。\n\n下面的层次体系称为寻常算术转换\n\n\n\nlong double\n\n\n\ndouble\n\n\nfloat\n\n\nunsigned long int\n\n\nlong int\n\n\nunsigned int\n\n\nint\n\n\n具体是怎么转换的呢?\n在进行运算的时候，如果某个操作数的类型在上表中排名较低，那么首先要转换为另外一个操作数的类型后，再执行运算。\n简单地说，就是从下往上转换\n\n注意：算术转换要合理，不然会有潜在的问题\n\n\n代码示例1下面的是一个简单算术转换的示例\n在int型和float类型一起计算的时候\nint类型会转换为float类型进行计算\n#include&lt;stdio.h&gt; int main()&#123;\tint a=3;\tfloat f =5.5;\tfloat ra =a+f;\t//算术转换，int--&gt;float \t\treturn 0;&#125;\n\n\n表达式属性这里可以引出另外一个知识点，表达式的属性\n表达式的两个属性：\n\n值属性\n类型属性\n\n如以下代码中\n\na+b的结果30就是这个表达式的指属性\n\n类型属性是int\n\n\nint main()&#123;\tint a =10;\tint b=20;\ta+b;//表达式2个属性：值属性，类型属性\t//30 值属性 \t//int 类型属性 \treturn 0;&#125;\n\n\n结语本篇博客到这里就结束了\n如果对你有帮助的话，还请点个赞再走吧！\n这对我非常重要！\n","categories":["C语言进阶"],"tags":["C语言","数据存储"]},{"title":"【VS】如何解决VS编译器scanf报错问题","url":"/2021/10/25/code/note_c/2%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3scanf%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%EF%BC%9F10.25/","content":"[toc]\n问题来源当我们使用vs编译器编译c语言代码，并需要用到一些非常常用的库函数的时候（如scanf）\nvs编译器通常会报出如下错误\n\n\n有的时候即便报错了，程序也可以正常运行\n\n但有的时候就会同图中一样，程序无法运行\n\n\n出现这个错误的原因是vs编译器认为这些库函数是“不安全的”（我可真谢谢你，担duo心guan那xian么shi多，微软）\n解决方法解决这个报错问题的方法有两种\n1.使用_S下标如图所示，我们可以在库函数后面加一个_s，这时候vs就会把它认为是“安全的函数”，程序就可以正常运行了\n\n方法一的致命缺点但是这么做有一个非常大的弊端——该代码只能在vs编译器里运行\n如图，如果我们将这一串带_S的代码复制到**devc++**这款编译器里面\ndevc++编译器会报错，无法运行这串代码\n同样的，如果你需要在mooc、牛客网或者其他刷题网站上填写代码的时候\n系统也无法运行这种带了_s的c语言代码\n这时候代码的“可移植性” （即通用性）就变差了！\n\n这时候就需要我们的解决方法2了\n2.使用防报错语句只需要在这个源文件的第一行添加这样一串代码\n#define _CRT_SECURE_NO_WARNINGS 1\n\n这串代码的作用就是屏蔽掉vs编译器对函数危险性的排查报错\n如图所示，我们的代码就能正常运行了\n\n这样操作，即便是将这一行防报错代码移植到另外一个编译器里，这串代码仍然能正常运行而且有的时候即便加上_s，还是会出现一些和scanf无关的奇怪报错使用方法二就能解决这个问题，这里建议大家还是使用方法二啦！\n\n方法二的缺点？你可能会说，那我岂不是每次写代码之前都需要打上这么一个define语句，那样也太麻烦了吧！\n再说了，我也背不下来啊！\n别急，下面我就会告诉你怎么让vs编译器每次创建源文件的时候自动带上这么一串代码\n如何在vs编译器里加上默认语句这里我们需要用到另外一款同样很经典的软件——Notepad++  \n如果你还没安装这款软件，这里是下载链接——&gt; [点我]\n\n安装完成后，我们点击左上角的 文件\n\n打开如下路径里，箭头所指的new++file文件\n\nvs编译器默认安装路径是c盘\n如果你的vs编译器不在c盘，可以通过右键桌面vs编译器的快捷方式，打开文件所在的位置，找到你vs编译器的安装路径\n\n\n打开以后是空白的\n我们只需要讲这行define语句加入这个文件，ctrl+s保存\n\n由于vs编译器处于c盘，修改这个文件需要申请管理员权限，点击同意即可！\n\n#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;\n\n\n这时候你创建的新的源文件，就会默认带上这串代码啦！\n由于&lt;stdio.h&gt;这个头文件实在是太常用了，所以我把它也加入了这个文件里。\n如果你愿意，也可以把int main()加入这个文件，方法同上\n\n这样就不用每次创建新的源文件的时候自己手打啦！\n一劳永逸！\n\n结语如果这篇文章对你有帮助的话，还请点个赞！\n万分感谢！\n","categories":["C语言初识"],"tags":["C语言"]},{"title":"【C语言】unsigned无符号类型运用的两个实例","url":"/2021/12/13/code/note_c/30%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86/","content":"@[toc]\n前排提醒😂本篇博客是对下一篇博客《char类型在内存中的存放》的拓展\n并非对unsigned类型的详解！\n\n示例1#include &lt;stdio.h&gt;int main()&#123;\tint i=-20;\tunsigned int j=10;\t\tprintf(&quot;%d\\n&quot;,i+j);\treturn 0; &#125; \n\n当有符号类型和无符号类型相加的时候，编译器是怎么处理的呢？\n10000000 00000000 00000000 00010100  -20的原码11111111 11111111 11111111 11101011   反码11111111 11111111 11111111 11101100   补码\n\n00000000 00000000 00000000 00001010   10的补码\n\n-20的补码和10的补码 相加\n11111111 11111111 11111111 11110110 得到的补码11111111 11111111 11111111 11110101 反码10000000 00000000 00000000 00001010 原码 -10\n\n得到的结果为-10\n\n当我们把j改为-10的时候，编译器依然能给出正确的答案-30\n这是因为在计算的时候，编译器先按照补码的形式进行运算，最后%d打印，格式化为有符号整数\n\n数据的存储和类型无关，只有读取的时候有区别\n\n\n示例2 第二个示例可以让我们了解无符号数在应用时候存在的限制\n#include&lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123;\tunsigned int i;\tfor(i=9;i&gt;=0;i--)\t&#123;\t\tprintf(&quot;%u\\n&quot;,i);\t\tSleep(1000);//更好的观察数据的打印\t&#125;\treturn 0;&#125;\n\n因为这里我们使用的是%u打印无符号数\n而无符号数i中不可能出现负数，也就没有小于0的情况（i永远大于等于0）\n当i&#x3D;0后继续–，二进制补码变成如下形式\n11111111 11111111 11111111 11111111\n\n因为是无符号数，直接将补码视作原码进行计算\n就得出了在窗口中打印的非常大的数字\n\n\n小结本篇博客展示了两种无符号数调用的情况\n下篇博客讲述char类型在数据中的存储的时候会用到！\n\n最近事情真的挺多的，英语4级、期末考试\n高数和线代真的太难了，两座大山压着我😥\n希望期末不挂科\n\n感谢你看到最后，求点赞关注！\n","categories":["C语言进阶"],"tags":["C语言","数据存储"]},{"title":"【C语言】char类型如何在内存中存储？","url":"/2022/01/05/code/note_c/31%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/","content":"@[toc]\n引子上篇博客向大家介绍了int类型在内存中的存储方式【链接】\n本篇博客我们继续往后，看看整形家族里的char类型是如何在内存中存储的吧！\n\nchar类型字符类型包括以下两种形式\n\nunsigned char 无符号\n\nsigned char 有符号\n\n\n用一个简单的printf来看看它们在打印上的区别\n#include&lt;stdio.h&gt;int main()&#123;\tchar a=-1;\tsigned char b=-1;\tunsigned char c=-1;    printf(&quot;a=%d b=%d c=%d\\n&quot;,a,b,c);    \treturn 0;&#125;\n\n打印结果为\na=-1 b=-1 c=255\n\n这里我们可以得出两个结论\n\n1.在VS编译器下，char默认为signed char\n2.unsigned char的处理方式和signed不同\n\n无符号数的处理可以看我之前写的这一篇博客👉【链接】\n\n存放和提升例一：-1先写出-1的原反补码\n10000000 00000000 00000000 00000001  -1原码11111111 11111111 11111111 11111110   反码11111111 11111111 11111111 11111111   补码\n\n在内存中存放的时候，a、b、c存放的都是补码的最后一个字节，即11111111\n而当我们用%d打印的时候，会发生整型提升\n\n整型提升的概念我写过另外一篇博客👉【点我】\n\n这里就是有符号和无符号处理不同的地方了\n因为a、b都是有符号的char，所以编译器会将最高位视为符号位进行提升\n所以a、b进行整型提升后的结果如下\n11111111 11111111 11111111 11111111//提升后a、b的补码\n\n而c是无符号char类型，编译器会在最高位补0\n00000000 00000000 00000000 11111111//提升后c的补码\n\n此时最高位为0，编译器将其视为正数，此时补码就是原码，打印255\n\n符号位 0为正，1为负\n正数的原码、反码、补码相同\n\n例二：-128#include &lt;stdio.h&gt;int main()&#123;\tchar a=-128;\tprintf(&quot;%u\\n&quot;,a);\treturn 0;&#125;\n\n打印的结果并不是-128\n4294967168\n\n-128的原反补码\n10000000 00000000 00000000 10000000  -128原码11111111 11111111 11111111 01111111   反码11111111 11111111 11111111 10000000   补码\n\na中存放的是1000 0000\n最高位视为符号位，整型提升后\n11111111 11111111 11111111 10000000//新的补码\n\n但因为这里是**%u打印，视作无符号数**\n此时原反补码一致，直接视作原码进行计算\n打印结果即为4294967168\n\n如果我们让a等于128，结果相同\n\nchar变量中存放数值的范围先来看看这样一串代码\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar a[1000];\tint i;\tfor (i = 0; i &lt; 1000; i++)\t&#123;\t\ta[i] = -1 - i;\t&#125;\tprintf(&quot;%d&quot;, strlen(a));\treturn 0;&#125;\n\n代码的结果如下：255\n\n在初始化的时候，我们设定了a[1000]，a数组里面理应有1000个元素\n那strlen函数求得的结果为何是255，而不是1000呢？\n\n实际char类型中的数据范围分为有符号和无符号两种\n\nsigned char  1byte-8bit，取值范围-128~127\nunsigned char 1byte-8bit，取值范围0~255\n\n以二进制表示，如下图所示\n\n因为无符号char类型中，八位补码视作原码进行计算\n而有符号char类型中，在计算的时会将首位视为符号位\n11111111 //补码11111110 //反码，补码减110000001 //源码，读出-1\n\n10000001//补码10000000//反码11111111//首位符号位不读，其他位读出-127\n\n10000000//补码这个二进制位不能-1，直接视作源码计算不能忘记这是个负数！10000000//源码读出128，加上负号为-128\n\n下面这幅图可以形象地表示出char类型数据范围\n\nchar a[1000];int i;for (i = 0; i &lt; 1000; i++)&#123;\ta[i] = -1 - i;&#125;printf(&quot;%d&quot;, strlen(a));\n\n上面那串代码里面的for循环，实则是一直给数组a中从-1开始赋值到-128，再从127赋值到1，0……如此循环赋值，直到i&#x3D;1000跳出循环。\n而我们的strlen函数在计算数组长度的时候，遇到第一个0就会停止计算\n这样我们就得出了答案为255！\n如何查询范围定义？\n我们可以通过头文件&lt;limits.h&gt;来查找范围定义\n\n在VS2019里面右键该头文件，点击“转到文档”\n\n这里我们就能看到各种数据类型的数据范围\n\n我们还可以看看其他的数据类型\n以有符号short为例，它的范围是-32678到32767\n\n\n\n结语以一串代码示例结束本篇博客吧！\n\n感谢你看到最后！\n点个赞呗，这对我灰常重要！！😘\n","categories":["C语言进阶"],"tags":["C语言","数据存储"]},{"title":"【C语言】浮点数在内存中的存储（详解）","url":"/2022/01/10/code/note_c/32%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/","content":"[TOC]\n写在前面，markdown语法的小知识点\n如何实现文字变红且加上了底色？如hello world\nmarkdown语法如下即可！\n`hello world`\n\n以及页内跳转\n&lt;span id=\"jump\"&gt;这一句话没啥用&lt;/span&gt;[回到开头](#jump)\n\n\n之前学习完了整形、字符类型在内存中的存储，今天让我们来看看float类型！\n\n整数类型👉【int】\n字符类型👉【char】\n\n常见的浮点数3.141591E10\n\n浮点数家族包括float、double、long double 类型\n而浮点数表示的范围是在头文件&lt;float.h&gt;里面定义的\n需要了解的是\n\n如果你打出3.14，编译器默认是double类型的。若想让他为float类型，则要在前面加f\n\n\n1E10是科学计数法，代表1.0×10^10\n\n代码引例这一句话没啥用\n先来看看下面这串代码\nint main(){\tint n = 9;\tfloat* pfloat = (float*)&amp;n;\tprintf(\"n的值为：%d\\n\", n);\tprintf(\"*pfloat的值为：%f\\n\", *pfloat);\t*pfloat = 9.0;\tprintf(\"num的值为：%d\\n\", n);\tprintf(\"*pfloat的值为：%f\\n\", *pfloat);\treturn 0;}\n\n运行的结果如下\n\n指针pfloat保留的是强制转换为float类型的int变量n\n\n准确来说，是将int指针类型强制转换为了float指针类型\n\n那打印的结果不应该是9吗？为什么是0.000000呢？\n再来看看后面的代码，我们让*pfloat=9.0，用%d打印的时候，却打印出了一串不知道怎么来的很大的数字。这又是为什么呢？\n一个涉及到的小知识点\n不管是double类型，还是float类型，默认小数点后都有6位\n我们可以用%.f的方式来控制打印，如%.3f就是只打印到小数点后3位\n\n\n答案只有一个：浮点型在内存中的存储方式和int类型完全不同！\n浮点型如何在内存中存放？根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：\n\n\n(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。\n\nM表示有效数字，大于等于1，小于2。\n\n2^E表示指数位。\n\n\n\n\n十进制&amp;二进制的科学计数法我们在小学就学到过，1.234×10^2=123.4\n而二进制中，其实就是把底数的10变成了2，1.011*2^2=101.1\n记住以下这个结论即可\n\n二进制码M乘以2的n次方，相当于将二进制码M的小数点向右移动n位\n\nS\\M\\E如何判断？我们以5.5为例，它的二进制是101.1\n相当于(-1)^0* 1.011*2^2\n和上面的公式比对，我们可以读出来S=0，M=1.011，E=2\n\n在之前的学习中，我们知道float类型占用4个字节的空间，而double类型则是8个字节\n浮点类型的内存空间示意图\nfloat类型的S\\E\\M被分区存放在这4个字节的内存空间中\n同理，double类型的S\\E\\M也是分区存放，它的有效数字长于float类型\n对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M\n\nIEEE754对M的特殊规定因为是二进制数，1≤M&lt;2，而M可以写成 1.xxxxxx 的形式，其中xxxxxx是小数部分\nIEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的\nxxxxxx部分\n\n比如保存1.01的时候，只保存小数点后的01，等到读取的时候，再把第一位的1加上去\n这样做的目的是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。\n\n我在学习的时候，关于这个24位有效数字曾产生了疑惑。\n实际上它并不难理解：\n在内存中，32位浮点数的M有23位的空间，如果我们保存了小数点前面的1，就只能保存小数点后22位的内容。\n但如果我们省略1，只保留小数点后的内容，那不就能保存到小数点后第23位了吗？再加上原来小数点前的1，不就是24位有效数字了！\n\nIEEE754对指数E的特殊规定E是一个无符号整数(unsigned int)\n\n如果E为8位，它的取值范围是0-255\n如果E为11为，它的取值范围是0-2047\n\n可是科学计数法里面的E是可以出现负数的。\n所以IEEE754规定，存入内存时E的真实值必须再加上一个中间数\n\n8位的E，中间数是127\n11位的E，中间数是1023\n\n\n例：2^10的E是10，所以保存为32位浮点数的时候，E必须保存为10+127=137，即10001001。\n保存为64位浮点数的时候，E保存为10+1023=1033，即10000001001\n\n①当E不为全0或全1时浮点数采用下面的规则来进行存放：\n\n内存中指数E的计算值减去127(或1023)，得到E的真实值，再将有效数字M前面加上第一位的1\n\n以32位浮点数举例：\n0.5的二进制形式为0.1。科学计数法中整数部分必须为1，小数点应右移一位。\n则为1.0*2^(-1)，E的真实值为-1，存放在内存中为-1+127=126(01111110)\nM存放小数点后的0，补全23位，全为0\n这时候0.5的二进制表现形式就是\n0 01111110 00000000000000000000000\n\n\n\n\nS\nE\nM\n\n\n\n0\n01111110\n0 01111110 00000000000000000000000\n\n\n\n②当E为全0时\n这时，浮点数的指数E等于1-127（或者1-1023）即为真实值\n有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数\n这样做是为了表示±0，以及接近于0的很小的数字\n\n③当E为全1时当E为全1时，原E为128，数字非常大，相当于无穷大\n\n这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）\n\n\n解释开篇代码回到开头\n整形9的原码如下\n00000000 00000000 00000000 00001001\n\n当我们将它强制存放到float类型的指针中时\n\n\n\nS\nE\nM\n\n\n\n0\n00000000\n0000000 00000000 00001001\n\n\n解码出来就是$$(-1)^00.0000000 00000000 000010012^{-126}$$这是一个很小的数字，远小于float类型默认的小数点后六位，所以printf打印的是0.000000\n\n*pfloat = 9.0;printf(\"num的值为：%d\\n\", n);printf(\"*pfloat的值为：%f\\n\", *pfloat);\n\n这里9.0就是以浮点数的形式存入float指针的\n\n9.0  十进制\n1001.0 二进制\n\nS=0,M=1.001,E=3二进制码0100 0001 0001 0000 0000 0000 0000 0000\n\n开启调试，在内存框中查看n的地址如下\n\n\n\n\n41\n10\n00\n00\n\n\n\n0100 0001\n0001 0000\n0000 0000\n0000 0000\n\n\n正好对应了浮点数9.0在内存中存放的二进制码\n最后n以%d打印出来，就是我们看到的1091567616\n结语考试周快要结束啦！\n寒假将开始新的代码学习\n\n终于补上了之前欠下的博客了，当作是一种复习吧，的确有不少东西已经忘记的差不多了😥\n\n感谢你看到最后，点个赞再走吧！\n","categories":["C语言进阶"],"tags":["C语言","数据存储"]},{"title":"【C语言】指针进阶第一站，字符指针&typedef关键字","url":"/2022/01/18/code/note_c/33%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88/","content":"[TOC]\n\n紧张刺激的寒假学习开始啦！\n\n简单回顾一下指针的概念\n\n内存会划分以字节为单位的空间，每一个字节都有一个编号（地址&#x2F;指针）\n\n指针变量可以存放这个地址&#x2F;指针\n\n\n注：我们日常所说的指针，一般是指针变量\n\n下面让我们坐上指针进阶的🚌，来到第一站！字符指针\n1字符指针1.1代码示例1int main()&#123;\tchar ch = &#x27;w&#x27;;\tchar* p= &amp;ch;\t\tchar* pa = &quot;abcdef&quot;;\treturn 0;&#125;\n\n\n字符变量ch里面存放了字符w\n字符指针p里面存放了ch的地址\n\n指针变量pa里面存放了abcdef字符串的地址，我们并没有对这个字符串进行初始化。而是直接把它放进了指针变量pa里面。\n和前两行的字符w不同，abcdef是存储在内存中的只读数据区，无法修改，即便通过指针也无法修改。\n为了避免理解出错，我们一般会加上const修饰\nconst char* pa = &quot;abcdef&quot;;\n\n\n\nconst放在*的左边\n表示const修饰的指针指向的内容，表示指针指向的内容不能通过指针来改变\n但是指针变量本身是可以改变的\n\nconst放在*的右边\n表示const修饰的是指针变量本身，指针变量的内容不能被修改\n但是*pa指针指向的内容是可以通过指针来修改的\n\n\n\n\n1.2代码示例2int main()&#123;\tchar arr1[] = &quot;abcdef&quot;;\tchar arr2[] = &quot;abcdef&quot;;\tconst char* str1 = &quot;abcdef&quot;;\tconst char* str2 = &quot;abcdef&quot;;\tif (arr1 == arr2)\t\tprintf(&quot;arr1==arr2\\n&quot;);\telse\t\tprintf(&quot;arr1!=arr2\\n&quot;);\tif (str1 == str2)\t\tprintf(&quot;str1==str2\\n&quot;);\telse\t\tprintf(&quot;str1!=str2\\n&quot;);\treturn 0;&#125;\n\n它的结果如下：\n\n在例子1里面我们提到过，str1和str2这种情况都指向一个常量字符串\n既然字符串abcdef无法被改变，编译器也没有必要创建两个独立的内存空间来存放两个相同的字符串\n所以str1和str2的地址是完全一样的\n而arr1和arr2是完全不同的数组，它们的首元素地址不一样，打印的结果是不相等\n\n\n🚍第一站的距离比较短\n在站台上，我们发现了一个无人认领的袋子，里面装着一个关键字\ntypedef\n\n2typedef关键字2.1如何使用在MSDN中，我们可以查找到typedef的定义\n\n简单地说，typedef的作用就是把一个已有的类型名换一个新的名字\ntypedef int* pint;\n\n这句代码的意思是：将int*命名为pint\n\npint在使用的时候和int*完全一致\n我们仍然可以使用int*\n\n在结构体里面，我们可以用typedef来缩短原有结构体定义的语句\n如：将struct Stu命名为Stu\ntypedef struct Stu&#123;\tint ID[10];\tchar name[10];\tint age;&#125;Stu;\n\n2.2typedef和#define的区别我们同样可以使用#define语句，进行这项操作\n#define PINT int*\n\n👆定义语句PINT为int*\n2.2.1指针连续定义先来了解一下如何正确连续定义两个指针\nint*pa,*pb;//正确的连续定义int*pa，pb;//错误//pa是int*类型，而pb是int类型\n\n因为这两个的情况非常容易搞混，所以我们不建议连续定义指针\ntypedef int* pint;#define PINT int*int main()&#123;    pint pa,pb;//可连续定义指针    //pa--&gt;int*    //pb--&gt;int*    PINT pa,pb;//等同于int*pa，pb    //pa--&gt;int*    //pb--&gt;int&#125;\n\n\ntypedef会产生一个新的变量类型\n#define只是在对应位置进行替换\n\n因为typedef产生了一个新的类型，pint为int*，但与int*也有不同\nint pa,pb;//pa,pb都是int类型pint pa,pb;//pa,pb都是int*类型\n\n而我们直接用int*进行连续定义指针变量是错误的\nint*pa，pb;//错误//pa是int*类型，而pb是int类型\n\n\n你学会了吗？我反正是学废了\n嘟嘟嘟，去下一站！🚌\n","categories":["C语言进阶"],"tags":["C语言","指针"]},{"title":"【C语言】指针进阶第二站，指针数组","url":"/2022/01/20/code/note_c/34%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/","content":"[TOC]\n嘟嘟嘟🚌，指针进阶的第二站指针数组到了！\n上车上车！\n\n回顾一下第一站🚍的内容：字符指针\n\n\n指针数组数组是一种类型的数的集合\n\n整型数组的元素都是int类型\n指针数组的元素都是指针变量\n\nint* arr1[10];//整型指针的数组char*arr2[10];//一级字符指针的数组char** arr3[5];//二级字符指针的数组\n\n参考这一份示意图\n\n示例1:定义多个字符指针在上一站的字符指针里面，提到了可以直接用指针来创建一个常量字符串\n同理，我们可以将多个指针放在一块，凑成指针数组，一次性创建多个指向常量字符串的指针\n\nint main()&#123;\tchar* arr[] = &#123; &quot;abcdef&quot;, &quot;qwer&quot;, &quot;zhangsan&quot; &#125;;\tint i = 0;\tint sz = sizeof(arr) / sizeof(arr[0]);\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tprintf(&quot;%s\\n&quot;, arr[i]);\t&#125;\treturn 0;&#125;\n\n示例2:存放数组名的数组在之前的学习中，我们知道：数组名代表数组首元素的地址\n可以说，数组名本质上也是一个指针\n既然是指针，就能放进指针数组里面\nint main()&#123;\tint arr1[] = &#123; 1,2,3,4,5 &#125;;\tint arr2[] = &#123; 2,3,4,5,6 &#125;;\tint arr3[] = &#123; 3,4,5,6,7 &#125;;\tint* arr[] = &#123;arr1, arr2, arr3&#125;;\t//arr是指针数组\tint i = 0;\tfor (i = 0; i &lt; 3; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; 5; j++)\t\t&#123;\t\t\tprintf(&quot;%d &quot;, arr[i][j]);//*(*(arr+i)+j)\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\treturn 0;&#125;\n\n这串代码中，我们需要了解的是arr[i][j]和*(*(arr+i)+j)之间的关系\n\n以下内容，我的理解可能有偏差。若有错误，还请大佬们无情指正！\n\n\narr[i][j]和*(*(arr+i)+j)\n它们都是访问数组的形式，用到了不同的操作符\n但表达的含义相同：下标为i、j的元素\n\n在内存中，数据的存储是连续的\n创建一个二维数组，可以看到两行的数据是连续存放在数组里面的\nint arr4[2][2]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;\n\n\n既然是连续的，我们就可以用指针++的形式来访问二维数组里面的所有元素\n\n\n*(arr+i)指向第i行元素\n*(arr+i)+j指向第i行下标为j的元素的地址\n*(*(arr+i)+j)再次解引用，得到j元素\n\n\n数组名的本质是地址，是该数组首元素的地址\n二维数组的首元素是第一行，数组名arr就是第一行的地址\n我们可以把二维数组的每一行理解为独立的一个一维数组\n这时候，二维数组的形式和上述代码中int* arr[]数组的形式就相同了\nint arr1[] = &#123; 1,2,3,4,5 &#125;;int arr2[] = &#123; 2,3,4,5,6 &#125;;int arr3[] = &#123; 3,4,5,6,7 &#125;;//arr1 arr2 arr3是二维数组里面的每一行int* arr[] = &#123;arr1, arr2, arr3&#125;;//arr等价于一个二维数组，但有不同\n\n因此，我们可以用二维数组访问的形式来访问int* arr[]数组\n\nint* arr[]和二维数组的不同int*arr数组里的元素arr1，arr2，arr3的地址是连续存放的\n\n这里设计到一个新概念：数组指针\n将在下一站🚌讲解！\n\n\n但是它们对应的各自的数组内数据并不连续\n如：arr1和arr2这两个数组各自元素的地址并不连续\n\n\n示例3：存放二级指针的数组既然一级指针可以放进数组里，二级指针也是指针，同样也能塞进数组里\n下面这串代码里面的arr2就是一个存放二级指针的数组\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint* p = &amp;a;\tint** pp = &amp;p;\tint** arr2[4] = &#123;pp&#125;;\treturn 0;&#125;\n\n\n结语🚍第二站的路程到这里就结束了！\n敬请期待下一站的数组指针航程吧！\n\n如果你对博客内容有疑问，欢迎在评论区提出哦，万分感谢！\n\n","categories":["C语言进阶"],"tags":["C语言","数组","指针"]},{"title":"【C语言】指针进阶第三站，数组指针","url":"/2022/01/21/code/note_c/35%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/","content":"[TOC]\n\n上一站🚏我们学习了指针数组\n今天来到我们的第三站🚌\n寒假也不能落下学习！\n\n今天学到了一个新的markdown语法\n我是红色\n&lt;font color=red&gt;我是红色&lt;/font&gt;\n\n\n数组指针整型指针：指向整型的指针\n字符指针：指向字符的指针\n数组指针：指向数组的指针\n1基本概念下面哪个是数组指针呢？\n\n指针数组和数组指针的概念很容易混淆，一定要分清楚哦！\n\nint *p1[10];int (*p2)[10];\n\n\np1是指针数组，每个元素的类型是int*\np2是数组指针，每个元素的类型是int(*)[10]\n\nint (*p2)[10];//p2先和*结合，表示p2是一个指针变量//指向一个大小为10个整型的数组//所以p2是数组指针\n\n注：[ ]的优先级高于*，所以必须加上()来保证p2先和*结合\n\n1.1代码示例int* parr[6];int* (*pp)[6] = &amp;parr;\n\npp是一个数组指针，类型是int*(*)[6],存放的是int*类型的数组，该数组有6个元素\n\n\n一般情况下，去掉变量名，剩下的即为变量类型\n如：int* (*pp)[6]去掉变量名pp，变量类型为int*(*)[6]\n\nchar arr[5];char (*pa)[5] = &amp;arr;\n\npa也是一个数组指针，变量类型为char(*)[5]，指向char类型的数组，该数组元素个数为5\n1.2错误示范你肯定会有一个疑问，变量类型为int(*)[5]的数组指针，能否指向数组元素为3或者6的数组呢？\n\n程序能够正常编译，但是会报出如下警告\nwarning C4048: “int (*)[5]”和“int (*)[3]”数组的下标不同\n\n在正常编写代码的时候，我们还是得保证数组指针和原数组的元素个数一致！\n2arr和&amp;arr的区别在进一步了解数组指针之前，我们需要了解arr和&amp;arr的区别\n当我们用%p打印arr和&amp;arr时，会发现它们的结果是相同的\n\n但这能说明arr和&amp;arr等价了吗？ \n并不能！\n再来看看下面这串代码\n\n\narr+1跳过4个字节，一个元素int的大小\n&amp;arr+1跳过40个字节，整个数组的大小\n\n其实&amp;arr和arr虽然指向的地址值相同，但是意义不同！\n\n&amp;arr表示的是数组的地址，是int(*)[10]类型\narr表示数组首元素的地址，是int*类型\n\n数组的地址+1，跳过整个数组的大小\n所以&amp;arr+1和&amp;arr的差值为40\n对应的int(*p)[5]和int* p1也有不同\n\np接收的是&amp;arr，整个数组的地址\np1接收arr，数组首元素的地址\n\n\n3数组指针的使用3.1打印一维数组下面这串代码是用整型指针打印数组元素的情况\n\n除了整型指针外，我们可以利用数组指针打印元素\nint main()&#123;\tint arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;\tint (*p)[10] = &amp;arr;\tint i = 0;\tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, *((*p) + i));        //*p--&gt;arr\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;\n\n*p等价于arr，arr+i等价于&amp;arr[i]，对arr+i解引用就是arr[i]\n\n但是这种方式实际上是把简单问题复杂化了：我们本来就可以用int*指针来打印数组元素，为何要利用数组指针来多此一举呢？\n所以在一维数组里面，我们一般不会这么写\n\n3.2打印二维数组假设我现在需要一个print函数来打印二维数组\n在之前，我们一般会想到用这张方式传入二维数组\nvoid print(int a[3][5], int r, int c);\n\n当我们想用数组指针的时候，情况就有些变化了\n\n数组名是数组首元素的地址\n二维数组的首元素是第一行\n二维数组的数组名表示第一行的地址\n\n//main函数中print(arr,3,5);\n\n这里prinf里面的arr就需要用数组指针来接收\n该二维数组是3行5列，每一行都有5个元素，是一个int[5]的数组\n对应的数组指针为int(*)[5]类型\nvoid print(int(*p)[5], int r, int c)\n\n这里的p指针指向的是二维数组第一行的地址\n\n*p：对p直接解引用\n相当于拿道了第一行元素的地址（把第一行看作数组，也就是数组的地址）\n相当于是二维数组第一行首元素的地址\n\n\n\n对(p+i)解引用，就能拿到第i行第一个元素的地址\n*(p+i)+j第i行第j个元素的地址\n*(*(p+i)+j)第i行第j个元素\n\n\n这一部分和上篇博客指针数组的内容相似\n\n最终的函数实现如下\nvoid print(int(*p)[5], int r, int c)&#123;\tint i = 0;\tfor (i = 0; i &lt; r; i++)\t&#123;\t\tint j = 0;\t\tfor (j = 0; j &lt; c; j++)\t\t&#123;\t\t\tprintf(&quot;%d &quot;, *(*(p + i) + j));\t\t\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;int main()&#123;\tint arr[3][5] = &#123; &#123;1,2,3,4,5&#125;,&#123;2,3,4,5,6&#125;,&#123;3,4,5,6,7&#125; &#125;;\tprint(arr,3,5);\treturn 0;&#125;\n\n\n3.3 关于二维数组传参void fun2(int **p)&#123;    return;&#125;void test03()&#123;    int a[4]=&#123;1,2,3,4&#125;;    int b[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;    int *q[3]=&#123;b[0],b[1],b[2]&#125;;    //fun2(a);    //fun2(&amp;a);    //fun2(b);    fun2(q);&#125;\n在2022的暑假作业day02中有这么一道题目，问的是上面4种调用方式谁位合法。经过测试，只有最后一个是不报错的。\n这里涉及到了一个我之前从来没注意过的点：二维数组不能直接用二级指针接受。在上面的2.2中其实有提到，二维数组的接受需要用对应的数组指针来接受。比如 int b[3][4]对应的数组指针就是int (*p)[4]类型的。不能直接简单粗暴地用二级指针int**来接收二维数组\nvoid fun3(int (*p)[4])&#123;    return;&#125;int main()&#123;\tint b[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;\tfunc3(b);//这样才是正确的&#125;\n\n4练习：判断这一站最重要的就是区别指针数组和数组指针\n4.1 int arr[5]int arr[5];\n\narr是一个整型数组，有5个元素，每个元素是int类型的\n4.2 int*parr[10]int*parr1[10];\n\nparr1是一个数组，数组有10个int*类型的元素\n所以parr1是指针数组\n\n4.3 int (*parr2)[10]int(*parr2)[10];\n\nparr2和*结合，表示parr2是一个指针\n去掉parr2即为它的变量类型int(*)[10]\n所以parr2是一个数组指针\n\n4.4 int(*parr3[10])[5]int(*parr3[10])[5];\n\n[]的优先级高于*\nparr3先和[]结合，说明parr3是一个数组\n该数组有10个元素，每一个元素都是一个数组指针，类型是int(*)[5]\n该数组指针指向的数组有5个int类型的元素\n\n结语第三站数组指针到这里就结束啦！\n下一站🚌是：数组传参和指针传参\n敬请期待哦~\n\n如果这篇博客对你有帮助，点个赞再走吧😘\n\n","categories":["C语言进阶"],"tags":["C语言","数组","指针"]},{"title":"【C语言】指针进阶第四站，数组/指针的传参问题","url":"/2022/01/23/code/note_c/36%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E5%92%8C%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82/","content":"[TOC]\n朋友们，到站啦！\n指针进阶第四站🚏，传参问题\n\n0.引例自定义函数里形参的类型，要和函数调用中传过去的实参类型相对应\n\n在初阶C语言的学习里面，我们了解到传参分为传址和传值两种类型\n一起来复习一下吧👉【链接】\n\ntest函数里的是int类型，我们传过去的参数a也是int类型\nvoid test(int n)&#123;&#125;int main()&#123;    int a=1    test(a);    return 0;&#125;\n\n\n\n好了，现在你已经知道了函数传参的基本概念了😁\n那么就来分析一下数组传参、指针传参的代码吧！\n1.一维数组传参看看以下函数的代码示例\n你觉得谁是正确的，谁是错误的呢？\ninclude &lt;stdio.h&gt;void test(int arr[])&#123;&#125;void test(int arr[10])&#123;&#125;void test(int *arr)&#123;&#125;void test2(int *arr[20])&#123;&#125;void test2(int **arr)&#123;&#125;int main()&#123;\tint arr[10] = &#123;0&#125;;\tint *arr2[20] = &#123;0&#125;;\ttest(arr);\ttest2(arr2);    return 0;&#125;\n\n\nNO.1 形参使用数组的形式来接收，正确\n\nNO.2 同样是数组的形式，正确\n需要注意的是，数组传参并不会开辟一个新的数组\n所以函数[ ]里的数字是多少并不影响\n\nNO.3 数组名是首元素的地址，用指针接收，正确\n\nNO.4 arr2是一个指针数组，(int *arr[20])和原数组对应，正确\n\nNO.5 数组名是首元素地址，arr2的首元素是一个int*类型\n可以用二级指针来接收，正确！\n\n\n\n2.二维数组传参了解完一维数组了，那就来看看二维数组\n以下的函数传参，哪些是对的，哪些是错的呢？\nvoid test(int arr[3][5])//一一对应，正确！&#123;&#125;void test(int arr[][])//省略列，错误！&#123;&#125;void test(int arr[][5])//可以省略行，正确！&#123;&#125;void test(int *arr)//二维数组的首元素是第一行&#123;&#125;//第一行是int(*)[5]类型，错误！void test(int* arr[5])//指针数组，错误！&#123;&#125;void test(int (*arr)[5])//数组指针，正确！&#123;&#125;void test(int **arr)//arr不是一级指针的地址，错误！&#123;&#125;int main()&#123;\tint arr[3][5] = &#123;0&#125;;    test(arr);    return 0;&#125;\n\n根据二维数组传参的代码，复习以下知识点\n\n二维数组的首元素是第一行\n二维数组在定义的时候可以省略行，不能省略列\n\n第一行的类型是int[5]，应该放进数组指针里！\n\n3.一级指针传参#include &lt;stdio.h&gt;void print(int *p, int sz)//用int*来接受&#123; int i = 0; for(i=0; i&lt;sz; i++) &#123; printf(&quot;%d\\n&quot;, *(p+i)); &#125;&#125;int main()&#123; int arr[10] = &#123;1,2,3,4,5,6,7,8,9&#125;; int *p = arr; int sz = sizeof(arr)/sizeof(arr[0]);  print(p, sz);//一级指针p，传给函数 return 0;&#125;\n\n4.二级指针传参\n什么是二级指针？👉点我\n\n以下是二级指针传参的基本形式\npp是int**类型，而&amp;p是指针变量的地址，要用二级指针来接收\n#include &lt;stdio.h&gt;void test(int** ptr)&#123; \tprintf(&quot;num = %d\\n&quot;, **ptr); &#125;int main()&#123; \tint n = 10; \tint*p = &amp;n; \tint **pp = &amp;p;\ttest(pp);\ttest(&amp;p);\treturn 0;&#125;\n\n再来看如下代码\n&amp;p、pp、arr这三个参数的类型都是二级指针\ntest函数里面要用char**来接收\nvoid test(char** p)&#123;&#125;int main()&#123;\tchar ch = &#x27;w&#x27;;\tchar* p = &amp;ch;\tchar** pp = &amp;p;\tchar* arr[5];\ttest(&amp;p);\ttest(pp);\ttest(arr);\t\treturn 0;&#125;\n\narr是指针数组的数组名，数组名是数组首元素的地址\n数组的首元素是char*类型，所以要用二级指针来接收\n\n5.如何判断参数类型如果我们在写代码的时候，不缺定应该用什么类型来接收的时候\n可以写一个测试代码，VS编译器会报错“类型不一致”\n\n\n结语传参问题并不算非常难，但我们仍要熟练掌握\n这样才能避免在写自定义函数的时候出现参数类型不同的bug！\n\n站稳了，马上驶往下一站🚌：函数指针\n\n","categories":["C语言进阶"],"tags":["C语言","数组","指针"]},{"title":"【C语言】指针进阶第五站，函数指针","url":"/2022/01/24/code/note_c/37%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","content":"[TOC]\n\n指针进阶第五站🚏：函数指针\n点进我的主页，可以回顾前四站的内容哦~\n\n1函数指针函数也有自己的地址，函数名&#x2F;&amp;函数名 就是函数的地址\n \n1.1基本形式在数组指针的学习中我们了解到\nint arr[5];int (*pa)[5] = &amp;arr;//pa是数组指针\n\n\n指针变量pa的类型是int(*)[5]\n\n那么函数指针的形式是怎样的呢？\nvoid test(char* str)&#123;&#125;int main()&#123;\tvoid (*pt)(char*) = test;    //pt是一个函数指针\treturn 0;&#125;\n\n\npt的类型是void (*)(char*)\n\n下面哪个代码有能力存放函数的地址呢？\nvoid (*pfun1)();void *pfun2();\n\n答：pfun1可以存放\n\n\npfun1先和*结合，说明pfun1是指针，指针指向的是一个函数，指向的函数无 参数，返回值类型为void\n\npfun2先和()结合，判断为一个返回值为int*类型的函数\n\n\n\n那么，如何书写一个函数指针呢？\nint Add(int x, int y)&#123;\treturn x + y;&#125;\n\n以Add函数为例，它有两个int类型的形参，返回类型是int\n所对应的函数指针就是int(*)(int,int)类型\nint (*pf)(int, int) = Add;\n\n依据以下几步就能正确写出函数指针\n\n确定函数的返回类型\n\n确定函数的参数类型和个数\n\n把函数参数类型里的变量名去掉，放入括号里\n(int x,int y)去掉x、y，即(int,int)\n\n在前面加上函数的返回类型\n\n最后加上(*)，以及函数指针变量名\n\n\n需要注意的是，(*pf)的括号不能省略，否则编译器会报错\n\n去掉括号之后就相当于函数声明，无法赋值\n\n\n1.2用函数指针来调用函数如下图所示，当我们定义了一个函数指针后\n就可以通过指针来访问原函数\n这时候(*pf)其实就相当于my_test\n\n我们可以通过函数指针来调用上面提到过的Add函数\nint Add(int x, int y)&#123;\treturn x + y;&#125;int main()&#123;\tint (* pf)(int, int) = Add;\tint sum = (*pf)(2,3);\tint sum1 = pf(2, 3);\tint sum2 = Add(2, 3);\tprintf(&quot;%d\\n&quot;, sum);\tprintf(&quot;%d\\n&quot;, sum1);\tprintf(&quot;%d\\n&quot;, sum2);\treturn 0;&#125;\n\n可以看到，sum和sum1两种形式都正确调用了该函数\n\n因为我们已经把Add的地址转给了pf指针，函数名Add和指针pf实际上是等价的\n所以在使用函数指针的时候，可以不带*使用。但是带*的时候一定要加括号！\n1.3两个奇葩的代码奇葩代码1(*(void (*)())0)();\n\n\n这里的0仅为示例，我们在正常使用的时候并不能访问0的地址\n\n看到这个代码的时候，是不是有点懵？\n别急，让我们来慢慢分析一波！\n\n奇葩代码2void (*signal(int , void(*)(int)))(int);\n\n\n说人话就是，signal函数内传入了一个void(*)(int)的函数指针，返回值也是一个void(*)(int)的函数指针！\nvoid fun(int num)&#123;\tprintf(&quot;fun--&gt;%d\\n&quot;, num);&#125;void ( *signal( int, void(*)(int) ) )(int);int main()&#123;\tvoid(*pf)(int);//定义一个函数指针\tpf = signal(100, fun);    //为signal函数传参，并用pf指针接收\treturn 0;&#125;\n\n“这个代码2是真的奇葩，就没有什么办法把他变成人话吗？(简化一下)”\n当然有！那就是用typedef函数来给void(*)(int)指针起一个新名字！\ntypedef void(*pf_t)(int);//把void(*)(int)命名为pf_t\n\nvoid(*p)(int);//p是函数指针变量的名字typedef void(*pf_t)(int);//pf_t是一个新的类型名\n\n这样我们的代码就能得到简化\nvoid ( *signal( int, void(*)(int) ) )(int);//源代码//简化后pf_t siganal(int,pf_t);\n\n这样是不是就更容易分辨了？\n\n2函数指针数组2.1基本形式既然函数指针也是一个指针类型，那我们就可以用指针数组来存放它\n\n前提：这些函数的参数类型、返回类型一致\n\nint Add(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125;//函数指针数组int (*pfArr[4])(int, int) = &#123;Add, Sub, Mul, Div&#125;;\n\n相比于分开写多次函数调用\n//多次函数调用int (*pf1)(int,int) = Add;int (*pf2)(int, int) = Sub;int (*pf3)(int, int) = Mul;int (*pf4)(int, int) = Div;\n\n函数指针数组可以让我们以使用数组的形式来访问每个函数\nint Add(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125;int main()&#123;\tint (*pfArr[4])(int, int) = &#123;Add, Sub, Mul, Div&#125;;//函数指针数组\tint i = 0;\tfor (i = 0; i &lt; 4; i++)\t&#123;\t\t//int ret = (*pfArr[i])(8, 4);\t\tint ret = pfArr[i](8, 4);\t\tprintf(&quot;%d\\n&quot;, ret);\t&#125;\treturn 0;&#125;\n\n这样也简化了我们的代码\n2.2计算器实现2.2.1switch语句\n目的：实现一个计算器\n菜单：用数字来选择运算类型\n方法：以switch&#x2F;case语句来实现函数调用\n结束：用do&#x2F;while实现多组输入，以及结束程序\n\nint Add(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125;void menu()&#123;\tprintf(&quot;**********************************\\n&quot;);\tprintf(&quot;*****  1. add     2. sub     *****\\n&quot;);\tprintf(&quot;*****  3. mul     4. div     *****\\n&quot;);\tprintf(&quot;*****  0. exit               *****\\n&quot;);\tprintf(&quot;**********************************\\n&quot;);&#125;int main()&#123;\tint input = 0;\tint x = 0;\tint y = 0;\tint ret = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Add(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 2:\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Sub(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 3:\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Mul(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 4:\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = Div(x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出计算器\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n这种方式需要写非常多的重复代码，而且代码长度很长😵\n我们可以使用函数指针对它进行优化\n\n2.2.2函数指针形式int main()&#123;\tint input = 0;\tint x = 0;\tint y = 0;\tint ret = 0;\tint (*pfArr[5])(int, int) = &#123;0, Add, Sub, Mul, Div&#125;;    //pfArr是一个函数指针的数组，也叫转移表\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tif (input == 0)\t\t&#123;\t\t\tprintf(&quot;退出计算器\\n&quot;);\t\t\tbreak;\t\t&#125;\t\telse if (input &gt;= 1 &amp;&amp; input &lt;= 4)\t\t&#123;\t\t\tprintf(&quot;输入2个操作数:&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\t\t\tret = pfArr[input](x, y);\t\t\tprintf(&quot;ret = %d\\n&quot;, ret);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;选择错误\\n&quot;);\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n这样就避免了我们在每个case语句里都写上输入提示、scanf和不同的函数调用所导致的代码冗余了\n运行试试吧！\n\n2.3指向函数指针数组的指针函数指针数组是一个数组，数组可以用数组指针来存放地址\n\n指向函数指针数组的指针：是一个指针\n该指针指向一个数组，数组的每个元素都是一个函数指针\n\nint Add(int x, int y)&#123;\treturn x + y;&#125;int main()&#123;\tint (*pa)(int, int) = Add;//函数指针\tint (* pfA[4])(int, int);//函数指针的数组\tint (* (*ppfA)[4])(int, int) = &amp;pfA;    //ppfA 是一个指针，该指针指向了一个存放函数指针的数组\treturn 0;&#125;\n\n\n3.相关练习题\n定义一个函数指针，指向的函数有两个int形参并且返回一个函数指针，返回的指针指向一个有一个int形参且返回int的函数？下面哪个是正确的？\n&gt;A. int (*(*F)(int, int))(int)&gt;B. int (*F)(int, int)&gt;C. int (*(*F)(int, int))&gt;D. *(*F)(int, int)(int)\n\n一步步分析题目的要求\n\n该函数指针指向的函数有两个int类型，即(int,int)，ABCD都有，无法排除\n\n仔细看看，D的类型没有写全，直接排除\n\n返回一个函数指针，该指针指向一个有一个int形参且返回int的函数\nB是一个函数指针，返回类型是int，错误\nC的返回值是int*类型，错误\n\nA选项去掉函数指针F后，剩下int (*)(int)，符合题意\n\n\n\n结语函数指针的知识点是第一次接触到🧐\n你学废了吗？😂\n\n下一站🚃：回调函数\n\n","categories":["C语言进阶"],"tags":["C语言","函数","指针"]},{"title":"【C语言】指针进阶终点站，回调函数和qsort","url":"/2022/01/24/code/note_c/38%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%92%8Cqsort/","content":"[TOC]\n\n嘟嘟嘟，指针进阶的公交车到终点站🚏啦！\n这一站我们将学习回调函数、qsort的使用以及模拟实现\n\n1.回调函数\n定义：\n回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一 个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该 函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或 条件进行响应。\n\n在上篇博客函数指针数组里，提到了一个计算器的代码\n在这里就能用到我们的回调函数，通过一个新的calc函数来调用计算函数，同样达到了避免switch&#x2F;case语句重复的目的\n\n不过今天我们的学习重点的内容不在这里，而是一个全新的函数：qsort\n\n2.qsort函数qsort函数又称 快速排序函数\n2.1void*指针void* p = &amp;a;\n\n\nvoid* 是一种无类型的指针，无具体类型的指针\nvoid* 的指针变量可以存放任意类型的地址\nvoid* 的指针不能直接进行解引用操作\nvoid* 的指针不能直接进行加减整数\n\n了解了这个之后，我们再来看看qsort函数的定义\n2.2qsort函数定义\nvoid qsort (void* base, size_t num, size_t size,            int (*compar)(const void*,const void*));\n\n这些参数分别代表什么意义呢？\n\nvoid*base 是待排序数据的起始地址\n\nsize_t num 是待排序数据的个数\n\nsize_t size 是待排序数据中每个数据的大小\n\nsiez_t是专为sizeof函数的返回值设计的\n它是一个无符号整型\n\n\n\n\n\nint (*compar)(const void*,const void*)是一个函数指针\n该函数的参数为(const void*,const void*)，返回值为int\n\n在qsort的应用中，需要我们自己来编写这样一个compar函数，来判断待排序数据谁大谁小\nqsort库函数对compar函数做出了如下规定：\n\np1&gt;p2时 返回&gt;0的数\np1&#x3D;p2时 返回0\np1&lt;p2时 返回&lt;0的数\n\n\n\n\n\n为什么比较函数用的void*类型的指针?\n\n因为qsort函数并不知道你需要排序什么类型的数据，但是作为使用者，我们知道待排序的数据类型以及如何比较待排序的数据，这时候就可以将void*指针强制类型转换，变为所需要的指针！\n\n\n2.3利用qsort函数来排序int&#x2F;char首先我们建立一个待排序的整型数组，依照qsort函数的定义，将参数填入该函数\nint main()&#123;\tint arr[10] = &#123; 3,4,7,9,0,1,2,5,8,6 &#125;;\tint sz = sizeof(arr) / sizeof(arr[0]);\tint* ptr = arr;//此处可以直接用arr来代替\tqsort(ptr, sz, sizeof(arr[0]), cmp_int);        return 0;&#125;\n\n接着，我们需要来编写这个cmp_int函数，用于判断两个整型的大小\n然后把这个函数名写入qsort\n//编写一个函数比较整型int cmp_int(const void* e1, const void* e2)&#123;\treturn *(int*)e1 - *(int*)e2;&#125;\n\n运行，可以看到数据已经按照升序重新排序了！\n\n如果你想降序排序，只需要将比较函数参数里的e1和e2对调位置\n\n\n再来试试排序char字符类型吧！\n//比较字符int cmp_char(const void* e1, const void* e2)&#123;\tchar a = *(char*)e1;\tchar b = *(char*)e2;\tif (a == b)\t\treturn 0;\telse if (a &gt; b)\t\treturn 1;\telse\t\treturn -1;&#125;int main()&#123;\tchar arr1[5] = &#123; &#x27;d&#x27;,&#x27;i&#x27;,&#x27;a&#x27;,&#x27;c&#x27;,&#x27;k&#x27;&#125;;\tint sz1 = sizeof(arr1) / sizeof(arr1[0]);\tint* pc = arr1;\tqsort(pc, sz1, sizeof(arr1[0]), cmp_char);\tfor(int i = 0; i &lt; sz1; i++)\t&#123;\t\tprintf(&quot;%c &quot;, arr1[i]);\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;\n\n\n2.4用qsort排序结构体定义一个结构体，内容分别代表姓名、年龄、成绩\nstruct Stu&#123;\tchar name[20];\tint age;\tfloat score;&#125;;\n\n该结构体有char、int、float三种类型的数据，需要我们写三种对应的排序函数\n//排序成绩int cmp_stu_by_socre(const void* e1, const void* e2)&#123;\tif (((struct Stu*)e1)-&gt;score &gt; ((struct Stu*)e2)-&gt;score)\t&#123;\t\treturn 1;\t&#125;\telse if (((struct Stu*)e1)-&gt;score &lt; ((struct Stu*)e2)-&gt;score)\t&#123;\t\treturn -1;\t&#125;\telse\t&#123;\t\treturn 0;\t&#125;&#125;//按年龄排序int cmp_stu_by_age(const void* e1, const void* e2)&#123;\treturn ((struct Stu*)e1)-&gt;age - ((struct Stu*)e2)-&gt;age;&#125;//按名字排序int cmp_stu_by_name(const void* e1, const void* e2)&#123;   //用strcmp函数比较字符串\treturn strcmp(((struct Stu*)e1)-&gt;name, ((struct Stu*)e2)-&gt;name);&#125;\n\n再写一个函数来打印结构体变量\nvoid print_stu(struct Stu arr[], int sz)&#123;\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\tprintf(&quot;%s %d %.2f\\n&quot;, arr[i].name, arr[i].age, arr[i].score);\t&#125;\tprintf(&quot;\\n&quot;);&#125;\n\n最后在主函数里定义结构体类型并写入qsort函数\nint main()&#123;\tstruct Stu arr[] = &#123; &#123;&quot;zhangsan&quot;,20,87.5f&#125;,&#123;&quot;lisi&quot;,22,99.0f&#125;,&#123;&quot;wangwu&quot;, 10, 68.5f&#125;,&#123;&quot;niuyeye&quot;,30,95.0f&#125; &#125;;\tint sz = sizeof(arr) / sizeof(arr[0]);\tqsort(arr, sz, sizeof(arr[0]), cmp_stu_by_name);\tprint_stu(arr,sz);\treturn 0;&#125;\n\n可以看到，我们的数据已经按照姓名排序了！\n\n\n3.模拟实现qsort函数那么，qsort函数的原理是什么呢？\n之前我们写过用于排序整型的冒泡排序\n其原理是比较数组内的a元素以及a的下一位元素，如果a大于a+1的元素，则将它们互换位置\nvoid bubble_sort(int arr[], int sz)//形参arr本质是指针&#123;\t//确定趟数\tint i = 0;\tfor (i = 0; i &lt; sz; i++)\t&#123;\t\t//一趟冒泡排序\t\tint j = 0;\t\tfor (j = 0; j &lt; sz - 1 - i; j++)\t\t&#123;\t\t\tif (arr[j] &gt; arr[j + 1] )\t\t\t&#123;\t\t\t\t//交换\t\t\t\tint tmp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = tmp;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n有没有办法将冒泡排序给改写成通用的排序函数呢？\n思考：\n\n冒泡排序的时候，使用是int类型，int类型是4个字节，无法排序比4个字节小的数据类型\n结构体类型的大小不一定是4的整数倍，也无法用int来排序\nchar类型是1个字节，能否通过char类型来更改所有类型？\n\n答案当然是肯定的！\n在之前的指针学习里，我们了解到，尽管char*和int*类型的指针都占4个字节，但是char*类型只能访问1个字节的数据。\n我们可以利用char*指针的这个特点，对数据进行一个字节一个字节的交换，交换4次不就能交换完一个int类型了吗？同理也能通过char*的多次访问，交换其他类型的数据！\n\n既然是模拟实现qsort函数，那函数的参数应该和qsort相同\n直接把qsort函数改成my_qsort，开整！\n\n利用冒泡排序的基本框架，我们可以写出以下的代码\n//模拟实现qsortvoid my_qsort(void* base, int sz,int width, int(*cmp)(const void* e1, const void* e2))&#123;\tfor (int i = 0; i &lt; sz - 1; i++)\t&#123;\t\tfor (int j = 0; j &lt; sz - i - 1; j++)\t\t&#123;\t\t\tif (cmp((char*)base + j * width , (char*)base + (j + 1) * width)&gt;0)\t\t\t&#123;\t\t\t\tmy_swap((char*)base + j * width, (char*)base + (j+1) * width ,width);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n你可能对if里面的语句感到很懵，别急，看图！\n\ncmp就是一个回调函数，利用函数指针来调用比较函数\n\n\n再来写一个swap函数，实现字节的交换\n//用char类型的指针来一个一个地访问void my_swap(char* e1, char* e2,int sz)&#123;        //sz是待排序数据的宽度:width\tfor (int k = 0; k &lt; sz; k++)\t&#123;\t\tchar tmp = *e1;\t\t*e1 = *e2;\t\t*e2 = tmp;\t\te1++;\t\te2++;\t&#125;&#125;\n\n测试一下，成功按照成绩来排序！\n\n结语指针进阶的行程到这里就圆满结束啦！是不是感觉收获满满呢？\n\n学有余力的朋友们可以看看这一类指针笔试题👉点我\n\n到站，下车！🚍\n","categories":["C语言进阶"],"tags":["C语言","函数","指针"]},{"title":"【C语言】常用的字符串函数和内存函数","url":"/2022/01/25/code/note_c/39%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0/","content":"[TOC]\n今天我们来学习一些新的字符串函数和内存函数，了解它们背后运行的原理，并完成部分函数的自我实现😘\n1.字符串函数1.1 strlen这个函数我们已经很熟悉了，它的作用是计算字符串的大小，以\\0作为结尾\n模拟实现如下：\n//1.strlen模拟实现int my_strlen(char* p)&#123;\tassert(p);\tint count = 0;\twhile (*p)\t&#123;\t\tcount++;\t\tp++;\t&#125;\treturn count;&#125;int main()&#123;\tchar arr[] = &#123; &quot;abcdef&quot; &#125;;\tint sz = my_strlen(arr);\tprintf(&quot;sz=%d\\n&quot;, sz);\treturn 0;&#125;\n\nassert：断言，库函数，用于判断指针是否为空，若为空会报错\n\n1.2 strcpy该函数用于拷贝字符串，将arr2里的内容拷贝到arr1里\nchar* strcpy(char * destination, const char * source );//日常使用strcpy(arr1,arr2);\n\n它有以下几个特点\n\nCopies the C string pointed by source into the array pointed by destination, including the  terminating null character (and stopping at that point).\n\n\n源字符串必须以 ‘\\0’ 结束\n会将源字符串中的 ‘\\0’ 拷贝到目标空间。\n目标空间必须足够大，以确保能存放源字符串。\n目标空间必须可修改\n\n如果源字符串里没有\\0，该函数就无法正确进行拷贝\n\nstrcpy拷贝的时候是复制而不是剪贴，源空间里的内容不会消失\n\n以下模拟实现\n需要注意的就是strcpy会将源字符串的’\\0’一并拷贝，所以在编写判断条件的时候就要考虑到这个情况\n//2.strcpy模拟实现，拷贝char* my_strcpy(char* a2, const char* a1)&#123;\tchar* dest = a2;\tassert(a1 &amp;&amp; a2);\tdo\t&#123;\t\t*a2++ = *a1;\t&#125; while (*a1++);\treturn dest;&#125;int main()&#123;\tchar arr1[] = &#123; &quot;abcdef&quot; &#125;;\tchar arr2[15]=&quot;xxxxxxxxx&quot;;\tmy_strcpy(arr2, arr1);\tputs(arr2);\treturn 0;&#125;\n\n\n1.3 strcatstrcat函数用于追加字符串，简单来说就是把两个字符串接在一起\n其函数返回值为dest\nchar * strcat ( char * destination, const char * source );//以下是使用char arr1[10] = &quot;hello&quot;;char arr2[] = &quot;bit&quot;;strcat(arr1,arr2);puts(arr1);//结果为&quot;hellobit&quot;\n\n\n源字符串必须以 ‘\\0’ 结束。\n目标空间必须有足够的大，能容纳下源字符串的内容。\n目标空间必须可修改。\n\n注意，使用strcat函数的时候不能自己追加自己，程序会死循环\n\n以下是模拟实现\n\n先让dest找到目的地字符串里的\\0\n然后进行追加，注意源字符串里的\\0同样会被追加过去\n\n//3,strcat函数char* my_strcat(char* dest, const char* sour)&#123;\tassert(dest &amp;&amp; sour);\tchar* ptr = dest;\twhile (*dest)\t&#123;\t\tdest++;\t&#125;\tdo\t&#123;\t\t*dest++ = *sour;\t&#125; while (*sour++);\treturn ptr;&#125;int main()&#123;\tchar arr1[10] = &quot;hello&quot;;\tchar arr2[] = &quot;bit&quot;;\tmy_strcat(arr1, arr2);\tputs(arr1);\treturn 0;&#125;\n\n\n1.4 strcmpstrcmp我们也是经常使用的，用于比较字符串\nint strcmp ( const char * str1, const char * str2 );\n\n该函数在比较字符串的时候，实际上是一个字符一个字符地比较的\n\n\n第一个字符串大于第二个字符串，则返回大于0的数字\n第一个字符串等于第二个字符串，则返回0\n第一个字符串小于第二个字符串，则返回小于0的数字\n\n模拟实现\n在VS编译器下，如果字符串s1大于s2，返回的是1。若小于返回的是-1。但C语言只要求大于的时候返回大于0的数字，小于的时候返回小于0的数字，所以我们可以直接用字符相减得出返回值\n//4.strcmp函数int my_strcmp(const char* str1, const char* str2)&#123;\tassert(str1 &amp;&amp; str2);\twhile(*str1 == *str2)\t&#123;\t\tif (*str1 == &#x27;\\0&#x27;)\t\t&#123;\t\t\treturn 0;\t\t&#125;\t\tstr1++;\t\tstr2++;\t&#125;\treturn *str1 - *str2;&#125;int main()&#123;\tchar arr1[] = &#123; &quot;abcdef&quot; &#125;;\tchar arr2[] = &#123; &quot;abcd&quot; &#125;;\t\tprintf(&quot;%d\\n&quot;,my_strcmp(arr2, arr1));\treturn 0;&#125;\n\n\n1.5 strncpy&#x2F;cat&#x2F;cmp以上4个库函数，都对操作数没有要求。\n而strncpy、strncat、strncmp这三个库函数，对操作数有要求\n\nstrncmp，最后一个参数4，代表只对比前4个字符的大小\n\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;\tchar arr1[] = &quot;abcwef&quot;;\tchar arr2[] = &quot;abcqqqqqq&quot;;\tint ret = strncmp(arr1, arr2, 4);\tprintf(&quot;%d\\n&quot;, ret);    return 0;&#125;\n\n\n\nstrncat，最后一个参数3，代表只追加前3个字符到目的地\nstrncpy，最后一个参数5，代表只拷贝前5个字符到目的到底\n\n\n这三个函数的用法非常简单，这里不多赘述！\n\n1.6 strstrconst char * strstr ( const char * str1, const char * str2 );      char * strstr (       char * str1, const char * str2 );\n\n这个函数就是第一次见了，它的作用是在字符串s1里面查找是否有字符串s2\n\n如果有，返回字符串s2在字符串s1里的起始地址\n如果没有，返回NULL\n\n\n模拟实现\nstr函数的模拟实现相对来说比较复杂\n最重要的就是遇到多个字符相同而最后不同的情况\n\n需要用另外一个指针C来遍历字符串，找寻C和ptr2所指元素相等的第一个字符\n然后用ptr1来和ptr2比较，C保持不变\n如果匹配成功，返回C指针\n如果匹配失败，C++后赋值给ptr1，继续进行查找\n\n\n//5.strstr 判断str1里面有没有str2//如果有，返回str1里str2的起始地址//如果str1不包含str2，返回nullchar* my_strstr(const char* str1, const char* str2)&#123;\tconst char* s1 = str1;\tconst char* s2 = str2;\tconst char* cur = str1;\tassert(str1 &amp;&amp; str2);\tif (*str2 == &#x27;\\0&#x27;)\t&#123;\t\treturn (char*)str1;\t&#125;\twhile (*cur)\t&#123;\t\ts1 = cur;\t\ts2 = str2;\t\twhile (*s1 &amp;&amp; *s2 &amp;&amp; *s1 == *s2)\t\t&#123;\t\t\ts1++;\t\t\ts2++;\t\t&#125;\t\tif (*s2 == &#x27;\\0&#x27;)\t\t\treturn (char*)cur;\t\tcur++;\t&#125;\treturn NULL;\t\t&#125;int main()&#123;\tchar arr1[15] = &#123; &quot;helloworld&quot; &#125;;\tchar arr2[] = &#123; &quot;owo&quot; &#125;;\tchar* p=strstr(arr1, arr2);\tif (p == NULL)\t&#123;\t\tprintf(&quot;找不到\\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;%s\\n&quot;, p);\t&#125;\treturn 0;&#125;\n\n\n1.7 strtok该函数用于查找一个字符串中的分隔符\nchar * strtok ( char * str, const char * sep );\n\n\nsep参数是个字符串，定义了用作分隔符的字符集合 \n\n第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记\n\nstrtok函数找到str中的下一个标记，并将其用\\0结尾，返回一个指向这个标记的指针\n\n\n\n注：strtok函数会改变被操作的字符串（把分隔符改为\\0），所以在使用strtok函数切分的字符串一般都是临时拷贝的内容，并且可修改\n\n\nstrtok函数的第一个参数不为 NULL，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置\nstrtok函数的第一个参数为 NULL，函数将在同一个字符串中被保存的位置开始，查找下一个标记\n如果字符串中不存在更多的标记，则返回 NULL 指针\n\n如下如所示，在后续调用的时候，我们可以往strtok函数里传入buf，也可以直接传入NULL，因为传入NULL的时候该函数会在上一次操作的字符串里继续查找分隔符\n\n这样写很多行太麻烦，我们可以尝试用for循环的方式来简化代码\n\nfor循环的第一个表达式只会执行一次，让str&#x3D;strtok第一次查找的返回值\n如果该返回值为空（没找到更多的分隔符），停止循环\n如果该返回值不为空，就让str=strtok(NULL, p)，继续查找并打印下一部分\n\nint main()&#123;\tconst char* p = &quot;@.&quot;;\tchar arr[] = &quot;zpengwei@yeah.net&quot;;\tchar buf[50] = &#123; 0 &#125;;//&quot;zpengwei@yeah.net&quot;\tstrcpy(buf, arr);\tchar* str = NULL;\tfor (str = strtok(buf, p); str != NULL; str=strtok(NULL, p))\t&#123;\t\tprintf(&quot;%s\\n&quot;, str);\t&#125;    return 0;&#125;\n\n\n\n1.8 strerrorchar * strerror ( int errnum );\n\n\nC语言中规定了一部分错误码，这些错误码有他们对应的错误信息\n\n这个函数的作用比较特殊：将错误代码翻译成提示信息\n\nerrno是C语言提供的一个全局变量，可以直接使用，放在errno.h文件中\n当库函数使用发生错误时，会把errno这个全局的错误变量设置为本次执行库函数产生的错误码\n这时候可以用strerror函数将errno错误码翻译成错误信息\n#include &lt;errno.h&gt;//需要调用errno.h头文件printf(&quot;%s\\n&quot;, strerror(errno));\n\n\n\n2.内存函数2.1 memcpy这个函数的作用也是拷贝内容，和strcpy不同，memcpy可以拷贝任意类型\nvoid * memcpy ( void * destination, const void * source, size_t num );\n\n\n函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置\n该函数在遇到 ‘\\0’ 的时候并不会停下来\n如果source和destination有任何的重叠，复制的结果都是未定义的\n\n使用方法如下\n\n模拟实现\n在之前的qsort快速排序函数的模拟实现里面，我们接触到了void*指针，以及用char*指针来进行单个字节访问的模拟方法\n在这里我们使用void*指针进行数据的拷贝\n\n要注意的是我们不能直接对void*指针进行++，而要将其强制类型转换成char*指针后+1\n\n////1.memcpy模拟实现void* my_memcpy(void* dest, const void* sour, int num)&#123;\tassert(dest &amp;&amp; sour);\tvoid* ptr = dest;\twhile (num--)\t&#123;\t\t*(char*)dest = *(char*)sour;\t\tdest = (char*)dest + 1;\t\tsour = (char*)sour + 1;\t&#125;\treturn ptr;&#125;int main()&#123;\tint arr1[10] = &#123; 1,2,4,5,9,7,8 &#125;;\tint arr2[10] = &#123; 0 &#125;;\tmy_memcpy(arr2, arr1, 5 * sizeof(int));\tfor (int i = 0; i &lt; 5; i++)\t&#123;\t\tprintf(&quot;%d &quot;, arr2[i]);\t&#125;\treturn 0;&#125;\n\n\n2.2 memmovevoid * memmove ( void * destination, const void * source, size_t num );\n\n这个函数和memcpy的功能基本一致，只有一点不同\n\nmemmove在拷贝的时候，源地址和目的地可以重叠\n\n如图所示，我们可以将arr1数组的一部分拷贝回该数组里面\n\n但如果你测试一下，就会发现vs编译器下memcpy也是能够拷贝内存重叠的数据的\n\nC语言并没有对memcpy函数做出如下要求，部分编译器的memcpy可能就不支持这样操作\n为了避免出错，我们在拷贝内存重叠数据的时候最好使用memmove函数\n\n\n模拟实现\n在编写该函数的时候，我们需要注意拷贝的顺序\n如果重叠部分还是从前向后拷贝的时候，就会出现后面的内容被前面拷贝来的数据篡改，结果不符合要求的情况\n\n\n如果我们的目的地在源地址的后面，就应该从后向前拷贝，避免数据被改写\n\n如果我们的目的地在源地址的前面，就应该从前向后拷贝\n\n这里的前&#x2F;后都是指有重叠的情况，如果没有重叠，从前往后&#x2F;从后往前都不影响\n\n\n\n最终的函数模拟如下\nvoid* my_memmove(void* dest, const void* sour, int num)&#123;\tassert(dest &amp;&amp; sour);\tvoid* ptr = dest;\tif (dest &lt; sour)\t&#123;\t\twhile (num--)\t\t&#123;\t\t\t*(char*)dest = *(char*)sour;\t\t\tdest = (char*)dest + 1;\t\t\tsour = (char*)sour + 1;\t\t&#125;\t&#125;\telse\t&#123;\t\twhile (num--)\t\t&#123;\t\t\t*((char*)dest+num) = *((char*)sour+num);\t\t&#125;\t&#125;\treturn ptr;&#125;int main()&#123;\tint arr1[10] = &#123; 1,2,4,5,9,7,8,3,0,6&#125;;\t//1 2 4 1 2 4 5 9 0 6\tmy_memmove(&amp;arr1[3], arr1, 5 * sizeof(int));\t\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, arr1[i]);\t&#125;\treturn 0;&#125;\n\n\n2.3 memcmpint memcmp ( const void * ptr1,            const void * ptr2,  \t\t\tsize_t num );\n\n这个函数的作用是：以字节为单位进行比较\n\n模拟实现\nint my_memcmp(const void* ptr1, const void* ptr2, int num)&#123;\tassert(ptr1 &amp;&amp; ptr2);\twhile (num--)\t&#123;\t\tif (*(char*)ptr1 == *(char*)ptr2)\t\t&#123;\t\t\tptr1 = (char*)ptr1 + 1;\t\t\tptr2 = (char*)ptr2 + 1;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn *(char*)ptr1 - *(char*)ptr2;\t\t&#125;\t&#125;\treturn 0;&#125;int main()&#123;\tint arr1[5] = &#123; 1,3,5,6,8 &#125;;\tint arr2[5] = &#123; 2,4,7,9,0 &#125;;\tint arr3[5] = &#123; 1,3,4,7,9 &#125;;\tint ret1 = my_memcmp(arr1, arr3, 9);\tint ret2 = memcmp(arr1, arr3, 9);\tprintf(&quot;my_memcmp:%d\\n&quot;, ret1);\tprintf(&quot;memcmp:%d\\n&quot;, ret2);\treturn 0;&#125;\n\n运行结果\n\n\n2.4 memsetvoid * memset ( void * ptr, int value, size_t num );\n\n这个函数的作用是把内存中ptr所在位置的num个字节的内容改为value\n\n示例代码如下图所示\n\n\n结语🍑今天的内容有点小多，这些函数以后我们就会经常接触啦~\n熟能生巧！\n","categories":["C语言进阶"],"tags":["C语言","函数"]},{"title":"【VS】如何下载VS2019并初始化C/C++环境","url":"/2021/09/16/code/note_c/3%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96vs2019%E7%BC%96%E8%AF%91%E5%99%A8/","content":"1.下载，百度vs2019，去官网下载即可一定要认准官网，官网，官网！\n作为初学者的我们，下载第一个免费的community社区版本即可！\n\n2.基本配置\n3.\n4.\n5.\n6.\n7.\n8.\n9.\n到这里，你的vs2019就配置完成了！可以愉快地写代码了！\n","categories":["C语言初识"],"tags":["C语言"]},{"title":"【C语言】自定义类型（详解）","url":"/2022/01/28/code/note_c/40%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/","content":"[TOC]\n在C语言中，有几个比较特殊的自定义类型：结构体、枚举、联合\n本篇博客，就让我们来认识一下这些自定义类型吧！😶\n1.结构体结构体是一些值的集合，结构体的每个成员可以是不同类型的变量\n1.1结构体的声明以个人信息为例，有姓名、性别、年龄、身高等几个元素。可以定义结构体如下\nstruct Stu&#123;\tchar name[20];\tchar sex[5];\tint age;\tint hight;&#125;s2, s3, s4;//s2,s3,s4全局变量\n\n1.2特殊声明在声明结构体的时候，可以不完全声明\nstruct&#123;\tchar c;\tint a;\tdouble d;&#125;sa;struct&#123;\tchar c;\tint a;\tdouble d;&#125;*ps;\n\n这两个结构体就是两个匿名结构体类型，省略了结构体标签。\n\n匿名结构体类型只能定义一次，后续无法使用\n\n这两个结构体的内容是完全一样的。\n在第二个结构体里面，定义了一个结构体指针*ps，请问这个指针能存放&amp;sa吗？\nint main()&#123;\t//编译器认为等号两边是不同的结构体类型，所以这种写法是错误的\tps = &amp;sa;\treturn 0;&#125;\n\n1.3结构体的自引用在定义结构体的时候，可以包含一个该结构体本身的成员\n//代码1-错误struct Node&#123; int data; struct Node next;&#125;;//正确的自引用方式struct Node&#123; int data; struct Node* next;&#125;;\n\n在很多时候，我们会使用typedef函数来为结构体重命名\n\ntypedef函数不能重命名匿名结构体\n\ntypedef struct&#123; int data;` Node* next;&#125;Node;//不能重命名匿名结构体//正确写法typedef struct Node&#123; int data; struct Node* next;&#125;Node;\n\n\n1.4结构体变量的定义和初始化struct Point&#123; int x; int y;&#125;p1; //声明类型的同时定义变量p1struct Point p2; //定义结构体变量p2\n\n//初始化：定义变量的同时赋初值。struct Point p3 = &#123;x, y&#125;;struct Stu        //类型声明&#123; char name[15];//名字 int age;      //年龄&#125;;struct Stu s = &#123;&quot;zhangsan&quot;, 20&#125;;//初始化struct Node&#123; int data; struct Point p; struct Node* next; &#125;n1 = &#123;10, &#123;4,5&#125;, NULL&#125;; //结构体嵌套初始化struct Node n2 = &#123;20, &#123;5, 6&#125;, NULL&#125;;//结构体嵌套初始化\n\n\n1.5结构体内存对齐结构体在内存中的存储方式比较特殊\nstruct S1&#123;\tchar c1;//1\tint i;//4\tchar c2;//1&#125;;\n\n结构体里面一共存放了6个字节的内容，按理来说，它所占的空间应该也是6个字节。\n但当我们用sizeof计算它的长度的时候，却得到了12个字节。\n\n这是为什么呢？\n\n结构体在内存中存放的时候，为了保证内存读取效率，需要进行内存对齐\n\n\n第一个成员在与结构体变量偏移量为0的地址处。 \n\n其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处\n\n\n 对齐数 &#x3D; 编译器默认的一个对齐数 与 该成员大小的较小值\n VS中默认的值为8 \n\n结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。 \n\n如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处。结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。\n\n\n\n\noffsetof函数：查看结构体成员变量相对于首地址的偏移量\n\n\n\ni变量是int类型，4个字节，默认对齐数是8，对齐数是4。C2变量是1个字节，对齐数就是1。\n\n所以int i就要从内存的4的整数倍的位置开始存放，也就是第5个字节的位置。c2在int后，在对齐数1的整数倍的位置进行存放，也就是第9个字节的位置。\n\n而结构体的总大小应该是最大对齐数（这里就是4）的整数倍，9并不是4的整数倍，所以结构体的总大小应为12个字节\n\n\n\n如图，结构体的3个成员在内存中存放并不是完全连续的。char c1和int i之间相隔了3个字节，char c2后还空出了3个字节。\n\n特殊情况：数组\nstruct Stu &#123;\tint i;    //4  4,8 - 4    char c[5];\t//5  1,8 - 1&#125;;\n\n数组在计算对齐数的时候，是看单个元素的大小，而不是看整个数组的大小。\n\nchar c[5]数组占5个字节\n计算对齐数的时候，用char类型的1个字节和8对比，对齐数是1\n\n （请忽略图中char数组的下标）\n\n\n那么为什么需要内存对齐呢？\n\n平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。\n\n性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访 问。\n\n\n\n在设计结构体的时候，我们可以把占用空间小的结构体成员尽量放在一起，这样可以减小结构体所占的空间\n\n\n1.6修改默认对齐数我们可以利用#pragma预处理指令来更改默认对齐数\n#pragma pack(1)//设置默认对齐数为1struct S2&#123; char c1; int i; char c2;&#125;;#pragma pack()//取消设置的默认对齐数，还原为默认\n\n\n\n1.7结构体传参struct S&#123; int data[1000]; int num;&#125;;struct S s = &#123;&#123;1,2,3,4&#125;, 1000&#125;;//结构体传参void print1(struct S s)&#123; printf(&quot;%d\\n&quot;, s.num);&#125;//结构体地址传参void print2(struct S* ps)&#123; printf(&quot;%d\\n&quot;, ps-&gt;num);&#125;int main()&#123; print1(s);  //传结构体 print2(&amp;s); //传地址 return 0;&#125;\n\n在结构体传参的时候，我们最好传结构体的地址。\n\n函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。\n\n\n\n2.位段位端是一种特殊的结构体\n2.1什么是位段?\n位段的声明和结构是类似的，有两个不同：\n1.位段的成员必须是 int、unsigned int 或signed int \n2.位段的成员名后边有一个冒号和一个数字。\n\nstruct A&#123; int _a:2; int _b:5; int _c:10; int _d:30;&#125;;\n\n成员名后的数字表示，该成员需要几个比特的空间来存储\n\n在结构体内，最小的成员char类型都需要1个字节的空间。但有些数据并不需要1个字节来存储，这时候就可以用位段来减少空间占用\n\nint _a:2;//2bit - 00 01 10 11 -四种情况\n\n位端的大小如下：先是开辟4个字节的空间，进行a、b、c的连续存放。存放完毕后还剩15个bit的空间，不够存放d的30个bit，所以开辟了第二个4个字节的空间，用来存放成员d\n\n\n2.2位段在内存中的存储\n位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型 \n\n位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的\n\n位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段\n\n\n\n//一个例子struct S&#123; char a:3; char b:4; char c:5; char d:4;&#125;;struct S s = &#123;0&#125;;s.a = 10;//1010-截断-010s.b = 12;//1100-完整保存-1100s.c = 3;//0011-前补0-00011s.d = 4;//0100-完整保存-0100\n\n\na和b占一个字节\nc占独立的一个字节\nd占一个字节\n\n它在内存中的存储如下图所示：\n\n2.3位段的跨平台问题在不同编译器下，位段的存储方式会有很大的不同\n\n\nint 位段被当成有符号数还是无符号数是不确定的。\n位段中最大位的数目不能确定（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题）\n位段中的成员在内存中从左向右分配，还是从右向左分配 标准尚未定义\n当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的\n\n\n跟结构体相比，位段可以达到同样的效果，还能很好的节省空间，但是有跨平台的问题存在。\n2.4位段的应用在互联网中，数据在服务器和服务器之间传递的时候，会参照以下的范式。\n图里的4位(4bit)版本号和首部长度，以及3位标志，都没有达到1个字节的大小。这时候如果用结构体来保存，就会存在较大的空间浪费，从而加大服务器的压力。\n这时候就适合采用位段来存储这样的内容，节省空间。\n\n\n3.枚举\n枚举的意思是一一列举\n\n在生活中有一些事物的类型是可以一一列举出来的（有限的）。\n比如：人的性别、星期、12个月。\n在C语言中，就可以用枚举类型来定义这种有限的元素\n3.1枚举类型的定义enum Day//星期&#123; Mon, Tues, Wed, Thur, Fri, Sat, Sun&#125;;enum Sex//性别&#123; MALE, FEMALE, SECRET&#125;；\n\n需要注意的是，枚举类型和结构体是不同的。\n\n&#123; &#125;中的内容是枚举类型的可能取值，也叫枚举常量 \n\n枚举类型代表具体的数值。默认是从0开始，以1递增。\n\n枚举类型可以用来替代数值\n\n\n比如在day的枚举类型里面，每一个元素分别代表一个数字。默认是从0开始，以1递增。\nenum Day//星期&#123; Mon,//0 Tues,//1 Wed,//2 Thur,//3 Fri,//4 Sat,//5 Sun//6&#125;;\n\n我们在定义的时候也可以赋初值\nenum Color//颜色&#123; RED=1, GREEN=2, BLUE=4&#125;;\n\n如果你只对其中一个常量赋值了，后面的常量也是以1递增的\nenum Day//星期&#123; Mon,//0 Tues,//1 Wed=5,//5 Thur,//6 Fri,//7 Sat,//8 Sun//9&#125;;\n\n3.2枚举的优点我们可以使用 #define 定义常量，为什么非要使用枚举？ \n枚举的优点： \n\n增加代码的可读性和可维护性 \n和#define定义的标识符比较枚举有类型检查，更加严谨。 \n防止了命名污染（用了&#123; &#125;封装） \n便于调试\n使用方便，一次可以定义多个常量\n\n其中第四点的内容见下图：\n\n\n3.3枚举的使用enum Color//颜色&#123; RED=1, GREEN=2, BLUE=4&#125;;//在定义完枚举常量之后，无法在外部进行更改！RED=3,//errenum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。clr = 5; //err\n\n\nenum Color里面的内容是枚举常量\nenum Color clr是一个枚举变量\n\n需要注意的是，如果你用数字给枚举变量赋值，在.c文件下不会报错，但是在.cpp文件下会报错\n\nCPP文件的语法检查更严格！\n\n\n\n那么，如何日常使用中应用枚举类型呢？\n\n在计算器的代码中👉【博客链接】\n我们可以使用枚举常量来替代干巴巴的case 0、case 1等等\n//这只是个示例//详细代码见之前的博客enum Options&#123; \tEXIT,//0 \tADD,//1    SUB,//2    MUL,//3    DIV//4&#125;;void menu()&#123;\tprintf(&quot;**********************************\\n&quot;);\tprintf(&quot;*****  1. add     2. sub     *****\\n&quot;);\tprintf(&quot;*****  3. mul     4. div     *****\\n&quot;);\tprintf(&quot;*****  0. exit               *****\\n&quot;);\tprintf(&quot;**********************************\\n&quot;);&#125;int main()&#123;\tint input = 0;\tint x = 0;\tint y = 0;\tint ret = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase ADD:         //用枚举类型代替原本的数字，增强代码可读性\t\t\tbreak;\t\tcase SUB:\t\t\tbreak;\t\tcase MUL:\t\t\tbreak;\t\tcase DIV:\t\t\tbreak;\t\tcase EXIT:\t\t\tprintf(&quot;退出计算器\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n\n\n4.联合体4.1联合类型的定义联合也是一种特殊的自定义类型\n这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）\n//联合类型的声明union Un&#123; char c; int i;&#125;;//联合变量的定义union Un un;\n\n当我们计算这个联合体的大小的时候，发现它只有4个字节，并不是5个字节。\n而且char c和int i元素的起始地址相同，这说明它们是公用这4个字节的空间的。\n\n4.2联合体的特点\n联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小\n（因为联合至少得有能力保存最大的那个成员）\n\nunion Un&#123; int i; char c;&#125;;union Un un;//下面输出的结果是什么？un.i = 0x11223344;un.c = 0x55;printf(&quot;%x\\n&quot;, un.i);\n\n\n4.3用联合体判断大小端\n在之前数据存储的学习中，我们了解到了什么是编译器的大小端，并写了一个函数来判断当前编译器的大小端👉链接\n\n#include &lt;stdio.h&gt;int check_sys()&#123;\tint a=1;\tchar*p=(char*)&amp;a;\tif(1==*p)\t\treturn 1;\telse\t\treturn 0;\t\t&#125;int main()&#123;\tint b=check_sys(); \tif(1==b)\t\tprintf(&quot;小端\\n&quot;);\telse\t\tprintf(&quot;大端\\n&quot;);    \treturn 0; &#125; \n\n\n将int类型地址强制转换成char*类型\n\n如果是小端，第一个地址是01\n如果是大端，第一个地址是00\n\n\n今天我们就利用联合体的成员在内存中共享同一空间的特点，来改进这个代码。\nint cheak_sys()&#123;\tunion\t&#123;\t\tchar c;\t\tint i;\t&#125;u;\tu.i = 1;//将int类型改成1\treturn u.c;//返回该类型的第一个字节&#125;int main()&#123;\tint ret = cheak_sys();\tif (1 == ret)\t\tprintf(&quot;小端\\n&quot;);\telse\t\tprintf(&quot;大端\\n&quot;);\t//如果返回1，表示小端\t//如果返回0，表示大端\treturn 0;&#125;\n\n\n使用联合体，就无需进行指针类型的强制转换\n对char c类型的定义可以覆盖掉int i的第一个字节\n\n\n4.4联合体在内存中的存储和结构体一样，联合体也需要进行内存对齐\n\n联合的大小至少是最大成员的大小\n当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍\n\nunion Un1&#123;\tchar c[5];//5  1,8 - 1\tint i;    //4  4,8 - 4&#125;;union Un2&#123;\tshort c[7];//14  2,8-2\tint i;     //4   4,8-4&#125;;\n\n需要注意的是，联合体在计算对齐数的时候，数组是按一个元素的大小进行计算，而不是以整个数组的大小进行计算！（这一点和结构体是一样的）\n\nUn2中short数组的对齐数：\n\nshort c[7]一共14个字节\n每个元素是2个字节\n默认对齐数是8\n所以它的对齐数是2\n\n\n\n以Un1为例，它在内存里的存储方式如图 (请忽略图中char数组的下标)\n\nchar c[5]和int i类型共用前5个字节（其中int i占4个字节）\n因为需要对齐到最大对齐数的整数倍，所以大小是8\n\n\n\n结语自定义类型的内容非常丰富\n你学会了吗？\n\n码字不易，若有帮助，点个赞呗！\n\n","categories":["C语言进阶"],"tags":["C语言","自定义类型"]},{"title":"【C语言】动态内存管理（详解malloc/calloc/realloc）","url":"/2022/01/29/code/note_c/41%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"[TOC]\n直入主题，动态内存管理！🕵️‍♂️\n1.为什么会有动态内存分配？我们一般使用以下两种方式开辟内存\nint a = 20;//在栈空间上开辟四个字节char arr[10] = &#123;0&#125;;//在栈空间上开辟10个字节的连续空间\n\n但是上述的开辟空间的方式有两个特点： \n\n空间开辟大小是固定的。 \n数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。\n\n但是对于空间的需求，不仅仅是上述的情况。有些时候，我们并不能提前知道需要的空间大小，而部分编译器并不支持变长数组。这时候以数组的方式开辟连续空间的方法就有点不适用了。\n其次，全局变量&#x2F;局部变量是存放在栈区里面的。如果存放的变量太多，就会出现栈溢出的错误\n\n这时候就轮到动态内存上场了！\n\n2.动态内存函数2.1 malloc#include &lt;stdlib.h&gt;//malloc的头文件void* malloc (size_t size);\n\n这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。\n\n如果开辟成功，则返回一个指向开辟好空间的指针。 \n如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。 \n返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。 \n如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。\n\n#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t//开辟10个整型的空间\t//int arr[10];\tint* p = (int*)malloc(40);\tif (NULL == p)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));        //这个函数在之前介绍过，用于转义错误代码\t\treturn 0;\t&#125;\t//使用\tint  i = 0;\tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\t//释放\tfree(p);\tp = NULL;\t\treturn 0;&#125;\n\n2.2 free上述代码里面出现了另外一个重要的函数，free\nfree函数用来释放动态开辟的内存，头文件是&lt;stdlib.h&gt;\n\n如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的\n如果参数ptr是NULL指针，则函数什么事都不做。\n\nfree函数不能用来释放栈区里面的空间，栈区的空间由编译器进行自动创建和自动释放\n重点！\n被free之后的指针p指向的空间已经不属于我们的应用程序了。最好在free之后立马把指针置为NULL避免访问野指针。\nfree(p);p = NULL;\n\n\n2.3 callocvoid* calloc (size_t num, size_t size);\n\ncalloc函数的功能和malloc基本一致，但是有一点不同：\n\ncalloc函数的功能是为num个大小为size的元素开辟一块空间，并且把空间的每个字节初始化为0。\n与malloc的区别只在于calloc会在返回地址之前把申请的空间的每个字节初始化为全0\n\n#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t//开辟10个整型的空间\t//int arr[10];\tint* p = (int*)calloc(10, sizeof(int));\tif (NULL == p)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t//使用\tint  i = 0;             \tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\t//释放\tfree(p);\tp = NULL;\treturn 0;&#125;\n\n添加断点并调试，可以看到calloc函数把这一块内存都初始化为0了\n\n如果这块空间需要初始化，使用calloc函数比malloc更好\n\n\n\n2.4 realloc\n该函数用于更改已经创建好的动态内存空间（可改大可改小）\n\nvoid* realloc (void* ptr, size_t size);\n\n\nptr 是要调整的内存地址 \nsize 调整之后新大小\n返回值为调整之后的内存起始地址\n这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间\n如果开辟失败，返回空指针NULL\n\n在进行扩容操作的时候，会出现两种情况：\n\n原动态内存空间之后有足够空间进行扩容\n原动态内存空间之后无足够空间\n\n如果是第一种情况，realloc函数会在这之后增添空间，分配给ptr指针。原来空间的数据不发生变化。\n如果是第二种情况，realloc会找一块新的空间，开辟好后返回给ptr指针，并把原空间里的数据移动到新空间的对应位置。\n\n情况2的时候，开辟完新空间之后，会把原来的空间给free掉(只有开辟成功才会释放原来的空间)\n\n\n#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t//开辟10个整型的空间\t//int arr[10];\tint* p = (int*)calloc(10, sizeof(int));\tif (NULL == p)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t//使用\tint  i = 0;\tfor (i = 0; i &lt; 10; i++)\t&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\t//需要增容 - 80\tint*ptr = (int*)realloc(p, 80);\tif (NULL != ptr)\t&#123;\t\tp = ptr;\t\tptr = NULL;\t&#125;\t//继续使用了\t\t//释放\tfree(p);\tp = NULL;\treturn 0;&#125;\n\n几点注意：\n\nrealloc(p, 80) 80指的是开辟之后新的空间大小为80，而不是增加80的空间\nrealloc函数可能开辟失败，这时候如果将开辟失败的返回值NULL赋值给了原有指针p，就很危险。\n采用中间指针变量ptr，先判断realloc函数是否开辟成功，若成功，则赋值给p指针。\n赋值给p之后ptr指针就没用了，置为空指针。\n\n\n最后我们不需要对ptr进行free，因为ptr的指向和p是一样的\nfree(p)的时候，ptr所指向的空间也被free掉了\n\n\nrealloc缩小空间的时候，会把原来空间后面的内容都剔除\n\n\n3.常见错误3.1对NULL指针的解引用void test()&#123;  int *p = (int *)malloc(INT_MAX/4);  *p = 20;//如果p的值是NULL，就会有问题  free(p);&#125;\n\nINT_MAX是int类型的最大值，可以在头文件limits.h里面查询并使用\n3.2对动态内存空间的越界访问和数组一样，动态内存空间也是不能越界访问的！\nvoid test()&#123; int i = 0; int *p = (int *)malloc(10*sizeof(int)); if(NULL == p) &#123; exit(EXIT_FAILURE); &#125; for(i=0; i&lt;=10; i++)//应该是i&lt;10 &#123; *(p+i) = i;//当i是10的时候越界访问 &#125; free(p);&#125;\n\n3.3对非动态内存空间进行freevoid test()&#123; int a = 10; int *p = &amp;a; free(p);//err&#125;\n\n3.4使用free释放动态内存空间的一部分void test()&#123; int *p = (int *)malloc(100); p++; free(p);//p不再指向动态内存的起始位置&#125;\n\n\n需要用一个指针来记住起始地址，用另外一个指针来进行赋值等操作\n\n3.5对一个空间进行重复释放void test()&#123; int *p = (int *)malloc(100); free(p); free(p);//重复释放&#125;\n\n在free之后立马把p置为空指针，就能避免这个问题\n\nfree函数接收空指针，不做任何操作\n\n3.6内存泄漏如果忘记释放动态内存开辟的空间，就会导致内存泄漏\nvoid test()&#123; \tint *p = (int*)malloc(100); \tif(NULL != p) \t&#123; \t\t*p = 20; \t&#125;    //没有释放p的空间&#125;int main()&#123; \ttest();\twhile(1);&#125;\n\n一般情况下，谁使用就谁释放。函数里使用就在函数里释放，除非需要传回主函数进行操作。\n\n如果没有传回主函数，也没在函数里进行释放，该指针变量已经被销毁了，无法进行释放操作！\n\n如果主函数里程序没有结束，就造成了内存浪费\n\n4.C&#x2F;C++程序中内存区域划分\n栈区（stack）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。\n\n堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。\n\n数据段（静态区）（static）存放全局变量、静态数据。程序结束后由系统释放。\n\n代码段：存放函数体（类成员函数和全局函数）的二进制代码。\n\n\n\n有了这幅图，我们就可以更好的理解在《C语言初识》中讲的static关键字修饰局部变量的例子了。实际上普通的局部变量是在栈区分配空间的，栈区的特点是在上面创建的变量出了作用域就销毁。但是被static修饰的变量存放在数据段（静态区），数据段的特点是在上面创建的变量，直到程序结束才销毁，所以生命周期变长\n\n\n\n结语动态内存其实就是数组的高级形式，它能让我们更方便的管理开辟的连续的空间。\n你学废了吗？🤤\n","categories":["C语言进阶"],"tags":["C语言","函数"]},{"title":"【C语言】文件操作（详解）","url":"/2022/03/01/code/note_c/42%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","content":"[TOC]\n好久没有更新C语言学习的博客了，今天带来的是文件部分的知识点！😋\n1.为什么需要文件？之前学习过通讯录的代码实现，可以给通讯录中增加、删除联系人。但是这个通讯录在你exe文件关闭的同时就被销毁了，它的内容并不能顺延到下一次打开这个通讯录，这对我们的使用产生了不便。\n而文件可以帮助我们实现数据的持久化：将数据保存在磁盘文件中，下次打开通讯录的时候，之前保存的联系人不会消失。\n\n\n2.什么是文件？文件就是存放在磁盘上的带特定格式的数据。\n2.1文件分类在程序设计中，一般讨论两种文件：程序文件、数据文件\n\n程序文件：代码源文件如.c，目标文件.obj/.o，可执行文件.exe\n数据文件：程序在使用过程中读写的数据，比如读取内容的文件，以及数据输出的文件\n\n这篇博客我们了解的是数据文件\n2.2文件名文件名包含3个部分：文件路径+文件名主干+文件后缀\n如：c:\\code\\test.txt\n文件标识常被称为文件名\n3.文件的使用3.1文件指针在文件操作中，非常重要的一个知识点就是文件类型指针，简称文件指针\n每个文件在开辟的时候都有一个对于的文件信息区，用于保存文件的名字、状态、当前的位置等相关信息。这些信息保存在了一个结构体中，该结构体系统声明为FILE\n不同的C语言编译器都有不同的FILE类型，但是大同小异。\n打开一个文件的时候，系统会根据文件的内容，自动创建FILE结构体变量，并填充它的信息。\n\n我们需要使用文件的时候，就可以通过一个FILE类型的指针来访问这个结构体变量\n\n3.2打开和关闭文件文件在读写之前需要打开文件，使用结束后需要关闭文件\n\n这一点和动态内存管理很相似\n\nANSIC规定用fopen函数来打开文件，fclose来关闭文件。\n打开文件的同时，会返回一个FILE*的指针变量指向该文件。\n\n关闭文件后，文件指针就变成了野指针，需要置为NULL防止错误调用\n\nfopen函数打开文件失败，会返回空指针\n#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main()&#123;    //打开文件\tFILE* pf = fopen(&quot;test.txt&quot;, &quot;r&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));//用该函数打印错误信息\t\treturn 0;\t&#125;\t//1.读文件    \t//关闭文件\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main()&#123;\t//打开文件\tFILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));//用该函数打印错误信息\t\treturn 0;\t&#125;\t//2.写文件        //关闭文件\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n\nstrerror函数在这篇博客里面有讲解👉点我\n\n3.2.1文件使用方式通过这张表格，我们可以了解一下文件使用方式的不同类型\n\n注意：使用它们用的都是双引号，而不是单引号！\n\n\n用w写入的时候，会覆盖原本已有内容。如果需要在已有内容后面追加，需要使用a\n\n3.2.2标准输入输出流\n输出：内存→文件\n输入：文件→内存\n\n\n这里还有一个小知识点：C语言程序，运行的时候会默认打开3个流\n\nstdin：标准输入流\nstdout：标准输出流\nstderr：标准错误流\n\n在执行输入输出操作的时候，之前我们是直接将内存中的数据printf打印到屏幕上\n现在我们可以通过文件指针，将数据输入到标准输出流，达到类似printf的效果\n\n3.3文件输入输出函数上述代码中，用到了fputc函数，这个函数的作用是将一个字符输入到文件中\n下表列出了一些我们会用到的文件函数\n\n3.3.1字符输入输出fputc函数：向文件中写入单个字符\n\nfgetc函数：从文件中读取单个字符\n可以看到，我们把刚刚文件中写入的字符全部打印出来了\n\n实现文件拷贝将一个文件的内容拷贝到另外一个文件中\nint main()&#123;\t//实现一个代码将data.txt 拷贝一份 生成data2.txt\tFILE* pr = fopen(&quot;data.txt&quot;, &quot;r&quot;);\tif (pr == NULL)\t&#123;\t\tprintf(&quot;open for reading: %s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\tFILE* pw = fopen(&quot;data2.txt&quot;, &quot;w&quot;);\tif (pw == NULL)\t&#123;\t\tprintf(&quot;open for writting: %s\\n&quot;, strerror(errno));\t\tfclose(pr);\t\tpr = NULL;\t\treturn 0;\t&#125;\t//拷贝文件\tint ch = 0;\twhile ((ch = fgetc(pr)) != EOF)\t&#123;\t\tfputc(ch, pw);\t&#125;\tfclose(pr);\tpr = NULL;\tfclose(pw);\tpw = NULL;\treturn 0;&#125;\n\n\n\n3.3.2文本行输入输出fputs函数：将字符串写入到文件中\n//写一行#include &lt;stdio.h&gt;int main()&#123;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;w&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\tfputs(&quot;hello world\\n&quot;, pf);\tfputs(&quot;hehe\\n&quot;, pf);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n运行代码，可以看到两行字符串已经被写入到了项目路径下的data.txt文件中\n\nfgets函数：从文件中读取规定长度的字符串\n该函数在使用的时候具有第3个参数，用于限制读取字符串的长度\n////读文件-读一行int main()&#123;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;r&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\tchar buf[1000] = &#123;0&#125;;\t//读文件\tfgets(buf, 3, pf);\tprintf(&quot;%s\\n&quot;, buf);\tfgets(buf, 3, pf);\tprintf(&quot;%s\\n&quot;, buf);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n运行程序，可以看到我们设置的是3，却只读取了2个字符出来\n\n将buf[2]更改为1，调试查看\n\n可以看到，在执行第一个fgets函数后，原本的1被写入成了\\0\n\n这就证实：fgets函数在读取字符的时候，会以\\0作为结尾\n如果我们需要读取3个字符，就需要将限制设置为4\n\n3.3.3格式化输入输出这里的“格式化”指的是结构体这种具有特定格式的数据内容\nfprintf函数：将格式化数据写入文件中\n#include&lt;stdio.h&gt;//……struct Stu&#123;\tchar name[20];\tint age;\tdouble d;&#125;;int main()&#123;\tstruct Stu s = &#123; &quot;张三&quot;, 20, 95.5 &#125;;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;w&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t//写格式化的数据\tfprintf(pf, &quot;%s %d %lf&quot;, s.name, s.age, s.d);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n\nfscanf函数：从文件中读取格式化数据，存放到对应结构体变量s中\n\n\n3.3.4二进制输入输出\nfread、fwrite可以操作任意类型的数据\n正如它的名字，二进制输入函数是将内容以二进制的方式输入到文件中\n\n\n使用该函数的时候需要使用**”rb”,”wb”**来打开文件\n\n\nfwrite(s, sizeof(struct Stu), 2, pf);//s 来源//sizeof 需要写入元素的大小//2 需要写入元素的个数//pf 写入的目标文件指针\n\n以下是写入结构体变量的例子\nstruct Stu&#123;\tchar name[20];\tint age;\tdouble d;&#125;;//二进制的写int main()&#123;\tstruct Stu s[2] = &#123; &#123;&quot;张三&quot;, 20, 95.5&#125; , &#123;&quot;lisi&quot;, 16, 66.5&#125;&#125;;\tFILE* pf = fopen(&quot;data.txt&quot;, &quot;wb&quot;);\tif (pf == NULL)\t&#123;\t\tprintf(&quot;%s\\n&quot;, strerror(errno));\t\treturn 0;\t&#125;\t//按照二进制的方式写文件\tfwrite(s, sizeof(struct Stu), 2, pf);\tfclose(pf);\tpf = NULL;\treturn 0;&#125;\n\n可以看到，此时写入的数据已经部分成了乱码。这时候它的内容已经是用二进制存放的了，txt阅读器无法正确读出这些数据\n\n二进制的读取就是复现这一步，将文本中的二进制数据以特定格式读取出来，并放入对应变量\nfread(s, sizeof(struct Stu), 2, pf);//s 存放文件内容的变量//sizeof 需要读取元素的大小//2 需要读取元素的个数//pf 读取的目标文件指针\n\n\n3.3.5 sscanf&#x2F;sprintf函数这两个函数比较特殊，它们的作用是将文件里面的格式化数据（如结构体）以字符串的形式拷贝到字符数组里面\n\n见下图\n\n\n\n3.4.其他文件函数3.4.1 fseek\nhttp://cplusplus.com/reference/cstdio/fseek/?kw=fseek\n\n该函数的作用是：将文件指针移动到相对于某个位置的特定偏移量的位置\n\n听起来有点绕口，举例说明就知道了\n\n给定一个字符串“abcdef”\n每次使用一次fgetc，文件指针就会往后进一位。使用两次，文件指针指向的是字符c\n如果我们需要指向f，就让指针\n\n从开始位置向后进5位\n从当前位置向后进3位\n从结束位置向前进1位\n\n\n我们可以用该函数，定位文件指针，将其更改到我们需要的位置，进行字符替换等操作\nint main()&#123;    FILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);    if (pf == NULL)    &#123;        printf(&quot;%s\\n&quot;, strerror(errno));        return 0;    &#125;    //写文件    int ch = 0;    for (ch = &#x27;a&#x27;; ch &lt;= &#x27;z&#x27;; ch++)    &#123;        fputc(ch, pf);    &#125;    //定位文件指针        fseek(pf, -2, SEEK_END);    fputc(&#x27;#&#x27;, pf);//将当前字符替换成#    fclose(pf);    pf = NULL;    return 0;&#125;\n\n\n3.4.2 ftell返回文件指针当前的偏移量（相对于文件开头）\n\n3.4.3 rewind\nhttp://cplusplus.com/reference/cstdio/rewind/?kw=rewind\n\n让文件指针的位置回到文件的起始位置\nfseek(pf, 0, SEEK_SET);//rewind函数与该fseek函数操作等价//但是rewind更方便\n\nint main()&#123;    FILE* pf = fopen(&quot;test.txt&quot;, &quot;r&quot;);    if (pf == NULL)    &#123;        printf(&quot;%s\\n&quot;, strerror(errno));        return 0;    &#125;    //读文件    int ch = fgetc(pf);    printf(&quot;%c\\n&quot;, ch);//a    ch = fgetc(pf);    printf(&quot;%c\\n&quot;, ch);//b        int ret = ftell(pf);    printf(&quot;%d\\n&quot;, ret);//2    rewind(pf);    //fseek(pf, 0, SEEK_SET);    ret = ftell(pf);    printf(&quot;%d\\n&quot;, ret);//0    fclose(pf);    pf = NULL;    return 0;&#125;\n\n4.文本文件和二进制文件我们现在已经知道了fread&#x2F;fwrite函数可以实现二进制的输入输出，它们是怎么具体实现的呢？\n\n根据数据的组织形式，数据文件被称为文本文件或者二进制文件。 数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。\n如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。\n在内存中，字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。\n对于数字10000，可以用下面两种方式存储\n\n1 0 0 0 0 作为5个字符来存储–占用5个字节\n以数字本身的二进制形式存储–占用4个字节\n\n这时候使用二进制的方式，就能节省空间\n\n用如下代码，将10000以二进制方式写入文件中\n\n在VS中我们可以以特定打开方式二进制编辑器打开test.txt文档\n\n可以看到10000是以二进制码的形式存放在文件中的\n\n\n这里涉及到了大小端的问题👉点我\n\n\n5.文件读取结束的判定5.1错误使用feof并不能直接使用feof函数的返回值来判断文件是否结束\n而是应在文件读取结束的时候，用feof函数判断是读取失败结束，还是遇到文件结尾正常结束\n\n文本文件读取是否结束，判断返回值\nEOF(fgetc)\nNULL(fgets)\n\n\n\n\nferror函数：判断文件是否出现了读取错误。如果有，返回为真\n\nhttp://cplusplus.com/reference/cstdio/ferror/?kw=ferror\n\n\n\n二进制文件的读取结束，判断返回值是否小于实际要读的个数\nfread的返回值是成功读取数据的个数\n判断返回值是否小于实际要读取的个数\n\n\n\n\n6.文件缓冲区\nANSIC 标准采用“缓冲文件系统”处理数据文件。\n\n所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。\n\n这就和git一样，是先将需要push的文件放入缓存区，确认文件无误后再push到远程仓库中\n\n如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓 冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小是C编译系统（编译器）决定的。\n\n因为有缓冲区的存在，C语言在操作文件的时候，需要做刷新缓冲区或者在文件操作结束的时候关闭文 件。 如果不做，可能导致读写文件的问题。\n代码示例1#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main()&#123;\tFILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);\tfputs(&quot;abcdef&quot;, pf);//先将代码放在输出缓冲区\tprintf(&quot;睡眠10秒-已经写数据了，打开test.txt文件，发现文件没有内容\\n&quot;);\tSleep(10000);\tprintf(&quot;刷新缓冲区\\n&quot;);\tfflush(pf);//刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘）\t\tprintf(&quot;再睡眠10秒-此时，再次打开test.txt文件，文件有内容了\\n&quot;);\tSleep(10000);\tfclose(pf);\t//注：fclose在关闭文件的时候，也会刷新缓冲区\tpf = NULL;\treturn 0;&#125;\n\n运行程序，通过sleep函数暂停程序，可以看到刚开始字符串并没有存入文件中\n\n而是先写入输入缓存区，刷新缓存区后，才写入txt文件\n\n代码示例2\n#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main()&#123;\twhile (1)\t&#123;\t\tprintf(&quot;hehe\\n&quot;);\t\t//在linux环境中，不带&#x27;\\n&#x27;的时候，并不会打印（没有刷新缓存区）\t\t//而在VS环境中，带不带都会正常打印\t\tSleep(1000);//linux环境中，sleep函数的参数，单位是秒（VS是毫秒）        //             linux环境下，sleep函数需要小写，VS下是Sleep\t&#125;\treturn 0;&#125;\n\n\n在Linux环境下（树莓派）测试这个代码\n可以看到，去掉\\n后，代码并不会打印hehe\n\n编译的时候，遇到报错👇，但是程序依旧编译出来了\nimplicit declaration of function ‘sleep’\n\nCSDN查了查，发现是需要引用头文件#include &lt;unistd.h&gt;\n重新编译，没有报错了（此处hehe已经加了\\n，程序正常打印）\n\n\n结语文件章节的内容非常丰富，你学费了吗！😁\n大多数内容还是需要我们多多操作来熟悉它的真正作用\n\n如果内容有误，还请大佬无情指正！\n\n","categories":["C语言进阶"],"tags":["文件","C语言","函数"]},{"title":"【C语言】程序运行过程：预处理/编译/汇编/链接","url":"/2022/03/02/code/note_c/43%E9%A2%84%E5%A4%84%E7%90%86%E7%BC%96%E8%AF%91%E6%B1%87%E7%BC%96/","content":"[TOC]\n哈喽啊，盆友们。一起来看看C语言中编译预处理的内容吧！😜\n1.程序运行的几个阶段众所不周知，C语言的程序运行分为几个阶段。\n咱们可以看看下面这个图，简单了解一二👇\n\n细分开来，编译还分为3个小阶段：预编译（预处理）、编译、汇编\n\n这三个阶段又分别做了什么事情呢？这就需要我们用linux下的gcc编译器来验证了\n1.1预编译现在我们编写了一个这样的代码\n\n\n在运行窗口中输入以下指令，进行预编译操作，得到test.i文件\ngcc -E test.c -o test.i\n\n\n打开该文件，滑倒最底部，查看它与源代码的不同\n\n可以发现以下几点：\n\n头文件消失：实际上被展开了\n注释被删除\ndefine定义的符号被替换\n\n这就是预编译阶段做的3件事，实际上都是一些文本操作，并没有运行该代码\n1.2编译输入以下指令，生成test.s文件\ngcc -S test.i -o test.s\n\n\n打开该文件，发现我们好像看不太懂它里面写了些什么\n\n实际上，mov、sub都是汇编语言，这一步就是把C语言代码转变成了汇编代码。 进行了以下几步操作：\n\n语法分析\n词法分析\n语义分析\n符号汇总\n\n\n\n这一部分内容可以阅读《程序员的自我修养》这本书，记录一下\n\n1.3汇编gcc -c test.s -o test.o\n\n\n这个指令会生成一个test.o目标文件\n\nLinux：目标文件后缀为.o\nWindows：目标文件后缀为.obj\n\n\n.o目标文件和可执行成句的文件格式elf\nreadelf工具可以解析elf格式的文件\n\n用文本编辑器打开这个文件，可以看到里面的东西都是乱码\n\n实际上这个文件里面存放的是二进制内容。\n汇编操作就是将汇编代码转换成二进制指令\n其中有非常重要的一部：形成符号表\n1.4符号表和链接这个代码中其实包含了两个源文件：test.c 、Add.c\n\n里面出现了两个符号，main和Add\n编译器会先对每个源文件创立一个符号表，为它们添加一个类似地址的参数。在链接阶段的时候，相同符号的地址参数会被设置为一样的\n\n这里编译会查看Add函数的定义在哪里\n如main函数中只是extern，并没有Add的具体实现，最后链接之时，Add符号的地址会被设置为Add.c中该符号的地址\n\n这个操作又叫：符号表的合并和重定位\n链接阶段还会执行另外一个操作：合并段表\ngcc test.o add.o -o test//生成可执行程序test\n\n\n使用./TEST操作执行该文件，可以看到程序成功输出了Add后的答案\n\n\n2.运行环境程序执行的过程中：\n\n程序先载入内存。在操作系统中，这个操作由系统完成；在独立环境中，程序的载入必须手动完成，也可以是通过可执行代码置入只读内存来完成\n程序执行开始。调用main函数\n开始执行代码。这时将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时使用静态内存，存储于静态内存中的变量在程序的整个执行过程中保留它们的值\n终止程序。正常终止main函数，也可能是意外终止\n\n\n结语本篇博客中，我们认识了解了程序运行的几个阶段。这里面还有很多更深层次的问题待我去探究。\n\n下篇博客：预处理详解\n\n点个赞再走呗，谢谢！\n","categories":["C语言进阶"],"tags":["C语言","编译"]},{"title":"【C语言】函数调用的参数压栈（详解）","url":"/2022/03/05/code/note_c/44%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7/","content":"[TOC]\n前言在早期的学习中，我们已经了解到当函数传值调用参数的时候，用的是形参。\n形参是实参的一份临时拷贝，对形参的改变不会影响实参里的值。\n\n传值调用和传址调用👉点我\n\n今天让我们以汇编语言来了解函数调用的参数压栈这一知识点\n所用编译器：VS2019\n\n不同编译器的实现可能略有不同，以实际为准\n\n\n1.什么是栈区？栈，是一种数据结构。\n在学习C语言的过程中，我们一般只关注内存中的3个区域，分别是栈区、堆区和静态区。\n其中堆区主要用于动态内存管理，在之前的博客中已经和大家介绍过。\n\n详解动态内存管理👉点我\n\n\n而栈区就是编译器给函数运行分配的空间了。\n和堆区空间需要手动分配不同，这一部分空间是编译器自动管理的，函数的栈帧会自动创建，自动销毁。\n1.1栈区小知识点\n栈区的使用是从高地址到低地址\n栈区的使用遵循先进后出，后进先出\n栈区的放置是从高地址往低地址放置：push压栈\n删除是从低往高删除：pop出栈\n\n\n2.知识点//本次使用的代码#include &lt;stdio.h&gt;int Add(int x, int y)&#123;\tint z = 0;\tz = x + y;\treturn z;&#125;int main() &#123;\tint a = 10;\tint b = 20;\tint c = Add(a, b);\tprintf(&quot;%d\\n&quot;, c);\t\treturn 0;&#125;\n\n2.1 寄存器常见寄存器有eax、ebx、ecx、edx，其中ebp和esp较为特殊\n\nebp、esp这两个寄存器中存放的是地址，这两个地址是用来维护函数栈帧的\n\n\neax&#x2F;ebx&#x2F;ecx&#x2F;edx：通用寄存器，保留临时数据\nebp：栈低指针\nesp：栈顶指针\neip：指令寄存器，保存当前指令的下一条指令的地址\n\n\n2.2 主函数调用每一个函数调用，都要在栈区创建一个空间\n我们知道main函数是程序的入口\n实际上，main函数也是被其他函数调用的\n\nmainCRTStartup函数调用__tmainCRTStartup\n__tmainCRTStartup函数调用main函数\n\n编译器会先在内存高地址处开辟一部分空间给mainCRTStartup和__tmainCRTStartup函数，它们进行调用main函数的操作。\n\n在VS2019中，按F10进行调试，出现黄色小箭头后，右键-转到反汇编，即可打开调试中汇编语言的显示界面\n\n3. 逐条解释3.1 从main开始先来看第一部分代码，逐条语句进行解释\npush  ebp//在栈顶开辟存放ebp这一寄存器对应值的空间mov  ebp,esp//将esp的值传入ebp中（即将ebp指针移动到原本esp指向的位置）sub  esp,0E4h//将esp的内容减去0E4h（将esp移动到原esp-0E4h的位置）push ebx//在栈顶放入ebxpush esi//在栈顶放入esipush edi//在栈顶放入edi\n\n\n\nlea：load effecticve address 加载有效地址\ndword：double word – 4个字节\n\nlea  edi,[ebp-24h]//将ebp-24h的地址放入edimov  ecx,9//将9放入ecx，对应十进制36mov  eax,0CCCCCCCCh//将0CCCCCCCCh放入eaxrep stos  dword ptr es:[edi]//将edi往下ecx个地址的数据全部初始化为0CCCCCCCCh\n\n按F10往下运行，过rep那一步后，可以看到36个字节的数据都被初始化为0CCCCCCCCh\n\n\n继续往下运行，可以看到编译器初始化a、b变量的过程\n\n\n\nVS2019下是小端存储\n\n\n\n\tint c =Add(a,b);mov    eax,dword ptr [b]//把b的内容放入eaxpush   eax  //在栈顶放入eaxmov    ecx,dword ptr [a]//把a的内容放入ecxpush   ecx  //在栈顶放入ecxcall   _Add (01A10B4h) //在栈顶放入该地址（call指令下一条指令的地址） \n\n最后这一步call很关键，后续会用到\n\n3.2 调用Add按F11，进入Add函数\n\n\npush    ebp//将ebp上移mov     ebp,esp//将esp内容放入ebp（移动ebp）sub     esp,0CCh//esp+0CCh（为Add开辟空间）push    ebx//在栈顶放入ebxpush    esi//在栈顶放入esipush    edi//在栈顶放入edi\n\nlea      edi,[ebp-0Ch]//ebp-0Ch的空间  mov      ecx,3//3存入ecx  mov      eax,0CCCCCCCCh//存入eax  rep stos  dword ptr es:[edi]//esp往下0ch的空间初始化mov      ecx,offset _6A27082D_test@c (024C003h)  call     @__CheckForDebuggerJustMyCode@4 (024131Bh)\n\n\n\n继续往下，寄存器初始化了Z地址处的数据 为0\n\nmov    eax,dword ptr [x]//将x的值放入eaxadd    eax,dword ptr [y]//将y的值加道eax中，即x+y   mov    dword ptr [z],eax//将eax的值放入变量z\n\n\n\treturn z;mov    eax,dword ptr [z]//将形参z的值放入eax \n\n\npop     edi//出栈，删除为edi创建的栈区pop     esi//pop指令会将esi的值放入esi（等于没变）  pop     ebx//每pop一次，esp就往高位移动一次      add     esp,0CCh//为esp地址+0CCh，即退出Add程序的栈区空间 cmp     ebp,esp//将esp的值与ebp进行比较\n\n\ncall        __RTC_CheckEsp (0241244h)  mov         esp,ebp//ebp的值赋给esp，此时esp和ebp相同\n\n\npop         ebp//弹出ebp  \n\n这里执行弹出指令时\n\n将ebp所指向的main函数的起始地址赋值给了ebp指针\nesp指针向高位移动一位\n\n最后的结果如下图所示，esp和ebp重新开始维护main函数的栈区空间\n\n3.3 回到main函数ret  \n\n前面提到call   _Add (01A10B4h)这条指令非常重要，实际上，在执行ret指令时，esp指针就指向了栈顶存放的call指令的下一条指令的地址，同时，这个地址也被pop掉了\n\n回到调试界面，可以看到黄色小箭头的确指向了call指令的下一条\n\n而这一条指令的意思，是往esp里加8，即向高位移动8个字节。\n实际上这条指令就是在销毁我们的形参\n\nmov      dword ptr [c],eax//将eax中的值放入变量c  \n\n此时eax中存放的就是Add函数的返回值\n\n这里我们可以得出一个结论：\n自定义函数的返回值是通过寄存器这一中间“变量”，返回主函数中的。\n\n先把返回值放入寄存器A\n主函数从寄存器A中取出返回值，放入接受返回值的变量\n\n\n继续往下，可以看到printf(&quot;%d\\n&quot;, c);语句后，编译器又一次将变量c的值放回了eax\n实际上这里是printf函数的运行：\n\n先把待打印变量放入eax\n在栈顶压入eax\noffset string &quot;%d\\n&quot;（猜测是数据类型检查）\n_printf ：执行printf函数\n\n\nadd  esp,8//给esp+8个字节\n\n我对这一部分产生了疑惑，重新调试发现\n\npush eax这一指令让esp往低地址处走了4个字节\noffset string &quot;%d\\n&quot;这一指令也让esp往低走了4个字节\n\n\n执行完这一指令后，esp回到了执行printf之前的地址处\n\n3.4 结束程序\treturn 0;xor    eax,eax//xor指令是异或--在这里的作用不清楚&#125;pop    edi//出栈--esp对应移动  pop    esi//  pop    ebx//  \n\n\nadd    esp,0E4h//esp+0E4h（退出为main函数开辟的空间） cmp    ebp,esp//比较ebp和esp  \n\n\n\ncall   __RTC_CheckEsp (0241244h)  mov    esp,ebp//将ebp的值复制给esp //此时esp和ebp的值依旧相同    \n\n\npop    ebp//ebp出栈--esp和ebp分离ret//main函数结束  \n\n\n\n4.本篇博客中的汇编语言总结\nmov：数据转移指令\n\npush：数据入栈，同时esp栈顶寄存器往低位走\n\npop：数据弹出至指定位置，同时esp栈顶寄存器往高位走\n\nsub：减法\n\nadd：加法\n\ncall：函数调用。1.压入返回地址；2.转入目标函数\n\njump：通过修改eip，转入目标函数，进行调用\n\nret：回复返回地址，压入eip，类似pop eip指令\n\ncmp（比较）：执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数\n\nxor：在两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，并将结果存放在目标操作数中\n\n\n\n部分汇编指令参考：C语言中文网\n\n\n5.结语\n完成这篇博客的时候，已经是周六的00:54🌛\n从周五的19:20开始，不知不觉中写了这么久\n\n函数调用堆栈这一部分的知识有些晦涩难懂，写下这篇博客也算是理清了一些思路吧。\n加油！\n顶不住了，睡觉去了\n\n说来讽刺，几个舍友还在打某3亿鼠标的枪战梦想……\n\n","categories":["C语言进阶"],"tags":["C语言","编译"]},{"title":"【C语言】预处理操作（详解）","url":"/2022/03/10/code/note_c/45%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/","content":"[TOC]\n前言😜上篇博客，我们提到了C语言程序运行的几个环节。\n本篇博客中提到的预处理指令，就是在预处理阶段运行的一些代码。\n\n本篇博客使用的编译器🎰\n\nVS2019（win10）\n树莓派（linux-gcc）\n\n\n\n1.预定义符号__FILE__ //进行编译的源文件__LINE__ //文件当前的行号__DATE__ //文件被编译的日期__TIME__ //文件被编译的时间__STDC__ //测试编译器是否遵循ANSI C，遵循值为1，不遵循则该符号未定义\n\n\n2.#define2.1定义标识符#define name stuff\n\n#define MAX 1000#define reg register   //为 register这个关键字，创建一个简短的名字#define do_forever for(;;)  //用更形象的符号来替换一种实现#define CASE break;case    //在写case语句的时候自动把 break写上//如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。#define DEBUG_PRINT printf(&quot;file:%s\\tline:%d\\t \\                           date:%s\\ttime:%s\\n&quot; ,\\                        __FILE__,__LINE__ ,       \\                        __DATE__,__TIME__ )  \n\n加分号问题define定义标识符的时候，最好不要在结尾加上;\n#define MAX 1000;#define MAX 1000\n\n\n2.2定义宏\n除了定义标识符以外，define还可以定义一个语句为标识符，允许把参数替换到文本中。这种机制叫做定义宏\n\n下面是宏的申明方式： \n#define name(parament-list)  stuff \n\n其中的parament-list是一个由逗号隔开的符号表，它们可能出现在stuff中\n\n参数列表的左括号必须与name紧邻。 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分\n\n//如#define DOUBLE(x) x+x\n\n宏需要注意的问题这个宏有一个问题👇\n#define DOUBLE(x) x+xint main()&#123;\tprintf(&quot;%d\\n&quot;, 10*DOUBLE(3));\treturn 0;&#125;\n\n这个式子输出的结果是什么呢？是60吗？\n答案是否定的：#define宏在使用的时候执行的是直接替换\n这个语句就相当于10*3+3，根据操作符优先级可知，结果为30+3&#x3D;33\n\n想解决这个问题，我们需要记住这个原则：\n\n给变量加上括号以确保优先级\n给整个宏再加上一个括号防止外部数据影响\n\n#define DOUBLE(x) ((x)+(x))\n\n再运行程序，发现答案变成了60\n\n\n用于对数值表达式进行求值的宏定义，都应该用这种方式加上括号。避免在使用宏时，参数中的操作符或邻近操作符之间产生不可预料的相互作用\n\n2.3define替换规则\n2.4使用#和##2.4.1#将字符串插入字符串int main()&#123;\tint a = 3;\tint b = 5;\tprintf(&quot;the num of a is %d\\n&quot;, a);\tprintf(&quot;the num of b is %d\\n&quot;, b);\tprintf(&quot;\\n&quot;);        return 0;&#125;\n\n\n在这个代码里面，打印的前置内容a和b需要根据打印的变量进行更改\n有没有一种办法，可以让他自己进行更改？\n#define PRINT(X) printf(&quot;the num of &quot;#X&quot; is %d\\n&quot;, X)int main()&#123;\tint a = 3;\tint b = 5;\tprintf(&quot;the num of a is %d\\n&quot;, a);\tprintf(&quot;the num of b is %d\\n&quot;, b);\tprintf(&quot;\\n&quot;);\tPRINT(a);\tPRINT(b);\treturn 0;&#125;\n\n可以看到，#X处的内容被替换成了我们需要打印的变量\n\n实际上，这里#X旁边的双引号，是将整个字符串拆分成了3份进行打印\n\n“the num of”\n#X\n“is %d\\n”\n\n字符串在打印的时候具有自动拼接的特性，所以我们可以通过这种方式将一个需要更改的字符插入到字符串中\n2.4.2## 将两个符号合并\n##可以把位于它两边的符号合成一个符号。 \n它允许宏定义从分离的文本片段创建标识符。\n\n如图，这个宏将Class和10两个分离的符号合并成了Class10，printf识别出来并打印的了Class10的值\n\n当我们同名变量有很多的时候，就可以利用这种宏来给不同的变量增加数据。\n#define ADD_TO_SUM(num, value) sum##num += value;int sum1,sum2,sum3,sum4;ADD_TO_SUM(3, 10);//给sum3增加10.\n\n这样的连接必须产生一个合法的标识符，否则其结果就是未定义的。\n\n2.5带副作用的宏参数当宏在定义中出现超过一次时，如果参数带有副作用，使用这个宏的时候就有可能出现危险，导致无法预测的结果\n\n副作用指表达式求值时出现的一些附带效果，如前置++和后置++\n\nx+1//不带副作用x++//有副作用\n\n以下这个宏可以体现上面描述的问题\n#define MAX(x,y) ((x)&gt;(y)?(x):(y))\n\n如果是一个函数封装，我们的理解是，a和b原来的值3和5被传入MAX，然后再各自++一次\n但实际上并不是这样，可以看到a++了一次，但是b++了两次\n\n这是为什么呢？\n\n宏执行的是直接替换\n\n#define MAX(x,y) ((x)&gt;(y)?(x):(y))//上述宏被替换后的结果int m=((a++)&gt;(b++)?(a++):(b++))\n\n这个表达式中，执行比较的时候，a和b各++一次，但是在最后返回b的时候，末尾b++被执行了一次\n得到的结果就是a=4，b=7\n2.6宏和函数对比宏经常被用作执行简单的计算（如上面提到多次的MAX）\n这时候宏对比函数有几个优点\n\n函数的调用需要压栈出栈，比实际执行这个小型代码需要的时间更长。宏比函数在程序的执行速度方面更胜一筹\n函数的参数必须声明位特定的类型，只适用于特定类型的表达式上。反之，宏可以用整型、长整型、浮点型等可以用&gt;来比较的类型。宏的调用与类型无关\n\n除了MAX这个简单宏语句外，宏的参数还可以出现数据类型\n如下图中我们调用的这个宏，就可以做到用一种更简单的方式来调用malloc函数。此时的调用只需要写入待开辟数据个数和数据类型，不需要再写强制类型转换等语句，方便使用\n\n有得就有失，宏当然也有缺点：\n\n每次使用宏，执行的是直接替换。如果此时宏比较长，则会增加程序的长度\n宏在预处理阶段执行了替换，无法进行调试\n宏与类型无关，不够严谨\n宏会出现操作符优先级问题，容易出错\n\n2.7命名约定一般来讲函数的宏的使用语法很相似，所以语言本身没法帮我们区分二者。 \n那我们平时的一个习惯是： \n\n把宏名全部大写：MAX\n\n函数名不要全部大写：Max\n\n\n#define MAX(x, y) ((x)&gt;(y)?(x):(y))int Max(int x, int y)&#123;\treturn x &gt; y ? x : y;&#125;\n\n2.7 #undef这条指令用于移除一个宏定义\n#undef NAME\n\n如果不移除，就无法重复定义同名宏\n\n\n3.命令行定义一些C语言的编译器提供了一个功能，允许我们在命令行中定义一个符号，用于启动编译过程\n当我们需要一个程序的不同版本时，可以使用该指令\n\n如：在不同情况下需要不同长度的数组\n\n\n如果我们直接编译这部分代码，编译器会报错，SZ未定义\n\n但当我们写上这么一行命令\ngcc test.c -D SZ=10\n\n可以看到编译器没有报错，再次ls，发现多了一个a.out文件\n\n执行该文件，可以看到SZ被定义成10并成功打印\n4.条件编译在编译一个程序的时候，我们可以通过条件编译指令来控制一组语句的使用与否\n4.1if&#x2F;endif#define M 1int main()&#123;\tint i = 0;\tint n = 10;\tfor (i = 0; i &lt; 10; i++)\t&#123;#if M\t\tprintf(&quot;%d\\n&quot;, i);#endif\t\t//其他代码\t&#125;\treturn 0;&#125;\n\n#if语句后为真即执行，为假不执行\n\n该语句之后只能跟随常量表达式，不能跟随定义的变量\n\n#define M 1#if M//正确#if 3&gt;5#if M==1//正确int a=1;#if a//err\n\n\n在linux环境下，使用编译语句执行预处理操作，可以看到生成的test.i文件中，printf代码是被包含进去的\n\n如果把M更改为0，再次执行预处理操作。printf语句并没有包含在for循环中\n\n\n如果这里放入变量n，不起作用\n\n\n你可能想问，如果这一行代码我不需要，直接注释掉不就ok了吗？\n并不然。\n有些时候我们为了验证之前写的程序是否正确，会编写一些测试代码，用于debug。这些代码在测试完成后可以删除，但是如果我们下次还需要测试同一个函数的时候，就有需要重新写一遍，很是不方便。\n有了条件编译指令，我们就可以在程序的最上方#define定义一个常量，来控制是否进行测试。\n\n4.2多个分支的调节编译#define M 150int main()&#123;#if M&lt;100\tprintf(&quot;less\\n&quot;);#elif M==100\tprintf(&quot;==\\n&quot;);#elif M&gt;100&amp;&amp;M&lt;200\tprintf(&quot;more\\n&quot;);#else\tprintf(&quot;hehe\\n&quot;);#endif\treturn 0;&#125;\n\n和之前一样，不运行的代码，VS2019会显示为灰色\n\n4.3判断符号是否已被定义#define M 0int main()&#123;#if defined(M)\tprintf(&quot;hehe\\n&quot;);#endif#ifdef M\tprintf(&quot;haha\\n&quot;);#endif//这两条语句等价       return 0;&#125;\n\n\n如果想把条件改为未定义的时候执行，可以使用下面这两种方式\n\n!：逻辑反操作符\n\n\n4.4嵌套指令和其他语句一样，条件编译语句也可以嵌套使用\n#define M 0#define N 1#if defined(M)     #ifdef OPTION1     \tM_option1();     #endif     #ifdef OPTION2     \tM_option2();     #endif#elif defined(N)     #ifdef OPTION2     \tN_option2();     #endif#endif\n\n\n5.文件包含我们知道，#include指令可以使另外一个文件被编译。它同时也是一个替换：\n\n编译器在预处理阶段删除这条指令，用包含文件的内容替换\n一个源文件被包含10次，就会被编译10次\n\n5.1包含方式#include &quot;test.h&quot;//本地文件#include &lt;stdio.h&gt;//库文件\n\n你可能会有这个疑问，这两种包含方式之间有什么区别呢？\n双引号方式\n现在源文件（项目文件）所在目录下查找。\n如果该头文件未找到，编译器就会像查找库函数头文件一样在标准位置查找头文件。\n如果找不到就提示编译错误\n\nVS2019标准位置（去VS的安装目录找）\nC:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.29.30133\\include\n\nLinux环境标准位置\n/usr/include\n\n\n库文件方式\n只在标准路径下查找，如果找不到就提示编译错误\n\n既然双引号方式也会去标准路径下查找，那是不是说我们可以用双引号方式包含库函数的头文件？\n答案是肯定的\n但是这么做，会让我们难以分辨头文件到底是库函数还是自定义头文件。两次查找也会影响程序编译效率\n\n5.2嵌套文件包含问题假如在项目合作中，出现了这种情况\n\n\ncomm.h和.c是公共文件\ntest1.h和test1.c使用了公共模块\ntest2.h和test2.c也使用了公共模块\ntest.h和test.c最终使用了test1和2模块\n\n这种情况下，就相当于有两份comm.h的内容被拷贝到最终的程序中\n假如comm.h中有define或者全局变量的定义，这就相当于一个定义语句写了两遍，出现了重复定义\n如何解决？我们可以在每个头文件的开头写\n#ifndef __TEST_H__#define __TEST_H__//头文件的内容#endif\n\n这样，如果__TEST_H__符号已经被定义过，编译器就不会二次展开头文件中的代码，也就避免了这个问题\n如果你使用的是VS编译器，在创建.h文件的时候，VS会自己包含一个语句\n#pragma once\n\n这个语句也有相同的作用\n\nwarning: #pragma once in main file在我尝试在linux环境下使用#pragma once语句时，遇到了这个报错\n\n解决这个问题的办法很简单，就是不要编译头文件\n\n编译器会自动展开头文件，无需手动编译\n\n\n\n网上查了查：出现这个问题的原因是编译器在编译头文件的时候，#pragma once本身是没有含义的语句，所以报错了。\n\n也有人说是因为linux不支持这个语句，我们来试试\n\n右侧代码中包含了两个test.h的引用，在预处理中只包含了一次\n\n去掉头文件中的#pragma once，再次编译，可以看到预处理文件中出现了两次头文件的内容\n\n这说明linux-gcc编译器是支持该语句的，并非网上说的不支持！\n还有更多……其实预处理指令还远不止本博客中包含的这些\n#error#pragma#line\n\n这些预处理指令还等待我的学习~记录在小本本上了\n\n如果这篇博客对你有帮助，还请点个👍吧！\n","categories":["C语言进阶"],"tags":["C语言","编译"]},{"title":"【C语言】转义字符","url":"/2021/08/13/code/note_c/4%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/","content":"前排提醒，这不算是转义字符的教学算是个我个人学习的记录\n\n\n我们先来看下面这个代码\n#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;c:\\test\\32\\test.m&quot;);\treturn 0;&#125;\n\n问：printf中的c:\\test\\32\\test.m包含几个字符？\n\n大家可以先思考一下这个问题我们直接数的话，会得出这里面包括了17个字符如果真的有那么简单也不需要这篇博客了对吧\n这里就要引入转义字符的概念了常用的转义字符有以下几个\n比较常规的我们可以看表格中的定义\n需要注意的是”\\?”这个是用于连续问号的情况？？+（某个符号）  称为三字母词如：？？） 显示出来是 ]\\？就让？不被识别为三字母词，而显示问号这个字符同时\\\\也是让“\\”这个字符能以本身形式出现而不是被识别成转义字符同时我们要知道的是\n“\\0”这个转义字符是字符串的结束，在我们输入字符串的时候后面会默认跟着一个隐藏的“\\0”  （如图）\n我们使用strlen计算字符串abc的长度的时候需要在后面-1同时“\\0”也会有自己对应的下标3\n\n说回我们的c:\\test\\32\\test.m通过查表，我们能轻易地发现这里面出现了两个\\t转义字符每个转义字符在数字符长度的时候是记作一个的除了这两个\\t,这里还藏有另外一个转义字符\\32\\32这个转义字符正是图表中的\\ddd格式的转义字符代表32是一个八进制数字\n而\\32在正常代码中 是指\n32作为八进制数字对应的十进制数字，在ASCII表上对应的字符。如：八进制32是十进制的26；那么\\32就代表十进制数26在ASCII码表上对应的符号，查表可知26是替代符号\n\n\n当然，在这里我们的\\32只是一个我们想要打印出来的字符，并没有实际作用\n所以答案就很明朗了。\nint main()&#123;\tprintf(&quot;c:\\test\\32\\test.m&quot;);\treturn 0;&#125;\n在这个代码中，(“c:\\test\\32\\test.m“)一共包含的字符数量是13\n\n本篇不走心博客到这里也结束了\n\n介绍了部分转义字符的作用\n明确在计算字符数量的时候转义字符应视为同一个字符计数\n\n感谢你看到最后还是求dalao无情指正啊！\n","categories":["C语言初识"],"tags":["C语言"]},{"title":"【C语言】猜数字游戏","url":"/2021/08/13/code/note_c/5%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/","content":"这是一初学c语言的新人的第一篇博客，尝试使用Markdown的方式写入\n\n\n这是一初学c语言的新人的第一篇博客尝试使用Markdown的方式写入(本来用的51cto，发现人好少，于是跑过来了）\n什么是MarkdownMarkdown是现在普遍使用的一种文档书写语言格式，只需用一些非常简单易记的符号，如#*/&gt;[]0\\，就可以轻松写出一篇具有良好的排版和可读性的文.接下来进入我们的正题\n猜数字游戏这是一非常经典的代码应用基本逻辑如下：\n\n1．计算机生成一个随机数2．玩家输入一个猜想的数字3．计算机提示“猜大了”或者“猜小了”并在玩家猜测正确时提示“恭喜你，猜对了”\n\n先来看看游戏最终是什么样子的吧玩家运行，可以看到一个菜单以及选择\n键入1即为开始游戏\n系统在玩家猜小或者猜大之后都会有对应的提示，猜对之后程序也会再次运行，玩家可以选择退出或者再来一次那么这个猜数字游戏是怎么实现的呢？首先我们制作一个简易的menu\nvoid menu()&#123;\tprintf(&quot;*****************************\\n&quot;);\tprintf(&quot;****  1.play   0.exit    ****\\n&quot;);\tprintf(&quot;*****************************\\n&quot;);&#125;\n光是这个menu还不够，我们需要写一个代码串来实现在1.play和0.exit之间选择的功能\nswitch case语句为了实现这个功能，我使用的是switch语句\nmenu();printf(&quot;请选择&gt;:&quot;);scanf(&quot;%d&quot;, &amp;input);switch (input)&#123;case 1:\tgame();//猜数字游戏\tbreak;case 0:\tprintf(&quot;退出游戏\\n&quot;);\tbreak;default:\tprintf(&quot;选择错误\\n&quot;);\tbreak;&#125;\n是不是觉得少了点什么？别急玩家肯定想多次游玩这个猜数字游戏总不能是一个一次性游戏吧所以我们需要给这个switch加上循环语句这里我用的是do whlie循环\nint main()&#123;\tint input = 0;\tdo\t&#123;\t\tmenu();\t\tprintf(&quot;请选择&gt;:&quot;);\t\tscanf(&quot;%d&quot;, &amp;input);\t\tswitch (input)\t\t&#123;\t\tcase 1:\t\t\tgame();//猜数字游戏\t\t\tbreak;\t\tcase 0:\t\t\tprintf(&quot;退出游戏\\n&quot;);\t\t\tbreak;\t\tdefault:\t\t\tprintf(&quot;选择错误\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125; while (input);\treturn 0;&#125;\n因为我们这里用到了scanf库函数，所以我们需要引用头文件 #include &lt;stdio.h&gt;注意这里我们的game()函数是接下来要编写的猜数字游戏的主要函数我们可以先屏蔽掉game()来测试目前代码是否正确如果你能复现和我一样的运行框，说明目前编译的选择程序是没问题的\n接下来便是重头戏如何编写我们的game()程序？这里我们要先引入一个rand函数rand是一个生成随机数字的函数 [点击查看rand函数定义]从定义我们可以得知，rand能生成的是0到RAND_MAX的整数通过查询百度百科我们可以知道RAND_MAX最小为7FFF使用WIN10自带的计算器中的程序员计算器，可以得知7FFF(16进制)即为32767(十进制)接下来我们可以编译一个简单的程序查看rand会生成什么数字\nvoid game()&#123;\tint ret = 0;\tint guess = 0;\tret = rand()%100+1; //生成1-100的随机数\tprintf(&quot;%d\\n&quot;, ret);&#125;\n程序很好的生成了1-100的数字，但是真的有这么简单吗？如果你再次运行程序，就会发现两次运行每次生成的结果都一模一样玩家即便是重新进行游戏，猜的还是上一次猜的数字，那怎么行？这里我们就要引入和rand相关的另外一个小知识点\n生成随机数起始点如果你在上面提到的rand定义的网站继续往下滑，便能看到srand这就是我们接下来要用到的函数\nvoid game()&#123;\tint ret = 0;\tint guess = 0;\tret = rand()%100+1;//生成1-100的随机数\tsrand(1);\tprintf(&quot;%d\\n&quot;, ret);&#125;\n我们先添加srand(1)查看效果这时每次生成的随机数字变成统一的42如果我们改成srand(2)的话会发现除了第一个数字是42之外，其他的数字都是46这是因为rand函数需要另外一个随机数作为它生成随机数的起点如果我们想要rand每次都能生成不一样的随机数的话就必须用srand(这里需要一个随机数)这不是套娃吗？我们需要随机数来生成一个随机数，程序不会死循环？那什么样的数字是会一直变化的呢？\n时间函数这里又要引入另外一个time函数同时我们需要了解时间戳的定义\n\n时间戳当前计算机的时间-计算机的起始时间(1970.1.1  0:0:0)&#x3D;(xxxx)秒 \n\n这个数字便是我们最易得的随时在变化的数字我们同样可以在刚才查询rand定义的网站找到time的定义 [点我查看]我们把刚才是srand(2)改成如下格式，再次调试代码\n\ntime函数需要引用头文件#include&lt;time.h&gt;这一次我们终于生成了完全随机的1-100的数字但是有另外一个问题这个game函数是处在main函数循环语句中的也就是每次游戏的时候，game函数都会重新生成一个新的随机数玩家猜测的并不是一个固定的数字，那也永远猜不到答案所以我们应该把srand添加到main主函数中，这样每一次游戏只会生成一个固定的随机数，这才是我们最终想要的效果!\n\n\n接下来我们需要编写if、else if语句来实现游戏的猜测以及提示\nwhile (1)\t&#123;\t\tprintf(&quot;猜数字:&gt;&quot;);\t\tscanf(&quot;%d&quot;, &amp;guess);\t\tif (guess&gt;ret)\t\t&#123;\t\t\tprintf(&quot;猜大了\\n&quot;);\t\t&#125;\t\telse if (guess&lt;ret)\t\t&#123;\t\t\tprintf(&quot;猜小了\\n&quot;);\t\t&#125;\t\telse\t\t&#123;\t\t\tprintf(&quot;恭喜你，猜对啦\\n&quot;);\t\t\tbreak;\t\t&#125;\t&#125;\n同时我们要屏蔽掉刚才放入game函数中的srand以及会告诉玩家答案的printf\n这样我们的猜数字游戏就大功告成了！来试玩一下吧！可以看到游戏正是我们需要的样子玩家也可以重复游戏\n这篇小博客到这里也就结束了第一次尝试的时候，手贱不小心按了F5，写了一半的博客直接无了不管怎样，感谢你看到最后还请dalao们对我的博客进行指正如果能点个赞什么的就最好了\n","categories":["C语言初识"],"tags":["C语言"]},{"title":"【C语言】goto语句","url":"/2021/08/16/code/note_c/6goto%E8%AF%AD%E5%8F%A5/","content":"这是初识c语言的第五篇文章了\n虽然看的人不多，但我不会放弃哒\n毕竟这也是给我自己的一个学习记录，不想写日记就用这个代替了！\n\n\ngoto语句c语言中提供了可以随意使用的goto语句和标记跳转的标号\n理论上来说，goto语句没什么必要，因为我们可以用whlie等循环语句来替代它\n\ngoto是类循环语句，其本身是关键字\n\n\ngoto语句在某些场景下用的到，如终止程序在某些深度嵌套的结构的处理过程，例如一次跳出两次或者多层的循环\n这种情况下break达不到我们的目的。break只能从最内层循环退出到上一层的循环\n\ngoto语句真正适合的场景如下：\nfor(...) \tfor(...)\t&#123;\t\tfor(...)        &#123;        \tif(disaster)         \t\tgoto error;          &#125;    &#125;\t...error:     if(disaster)//处理错误情况\n\n用下面这个例子来给大家简单地演示一下goto的作用\n#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;hello world\\n&quot;);\tgoto again;\tprintf(&quot;你好\\n&quot;);again:\tprintf(&quot;hehe\\n&quot;);\treturn 0;&#125;\n\n结果如下\n\n可以看到，程序跳过了printf(“你好\\n”);，直接到下一步打印hehe\n代码的执行流程图如下：\n\n其实goto的作用方式非常容易理解，即：走到again\n这时候程序会直接跳到again后面的代码，不管这个again是在goto的后面还是前面\n需要注意的是，again在前面必须在特定的循环\\条件代码中使用\n如果你将上述的代码改成这样\nint main()&#123;again:    printf(&quot;hello world\\n&quot;);\tgoto again;\tprintf(&quot;你好\\n&quot;);\tprintf(&quot;hehe\\n&quot;);\treturn 0;&#125;\n\n那么代码就会一直打印hello world，进入死循环\n那goto就不是没有必要了，是毫无意义\n\n想知道goto在前面的时候要怎么书写代码吗\n且听下回分解\n（因为这个代码是个关机小程序，我感觉重新写一篇博客会更好）\n点个赞再走吧，求求了！\n","categories":["C语言初识"],"tags":["C语言"]},{"title":"【C语言】关机程序","url":"/2021/08/20/code/note_c/7%E5%85%B3%E6%9C%BA%E7%A8%8B%E5%BA%8F/","content":"不知不觉就摸了几天鱼，及时醒悟，开始码之前在goto语句中提到的关机小程序\n\n\n@[TOC]\n关机程序在介绍这个程序之前，我们要了解win10系统的一些系统指令\nwindows系统指令用win+r打开系统的运行框（这个从xp，win7到win10都有）\n在弹出的运行框中输入shutdown -s -t 7200（后面跟着的数字是时间，单位是秒）\n\n\n系统将在右下角提示你定时关机的时间，届时还会在定时关机时间提前60s提醒你要关机\n想要取消定时关机，可以在运行中输入shutdown -a\n\n\n定时关机就被取消了\n了解了这个之后，我们就要知悉C语言中可以帮我们在系统的运行中输入指令的函数\nsystem函数首先，让我们在之前和大家分享过的网站cplusplus上查询该函数的定义\n\n简单地说，这个函数就是来帮我们execute执行系统命令的\n同时，网站告诉我们：这个函数的头文件是stdlib.h\n\n先写一个简单的关机程序来实操一下system函数\n#incldue &lt;stdlib.h&gt;int main()&#123;\tsystem(&quot;shutdown -s -t 60&quot;);//system() -执行系统命令的\treturn 0;&#125;\n\n\n循环指令和关机程序接下来让我们用一个有点损的方式写一个关机程序\n运行这个程序后，只有输入“我是🐖”才能取消关机\nint main()&#123;\tchar input[20] = &#123; 0 &#125;;\tsystem(&quot;shutdown -s -t 60&quot;);\twhile(1)\t&#123;\t\tprintf(&quot;请注意，你的电脑将在1分钟内关机，如果输入:我是猪，就取消关机\\n请输入&gt;:&quot;);\t\tscanf(&quot;%s&quot;, input);\t\tif (strcmp(input, &quot;我是猪&quot;) == 0)//头文件#include &lt;string.h&gt;\t\t&#123;\t\t\tsystem(&quot;shutdown -a&quot;);\t\t\tbreak;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n这里我们还用到了strcmp函数，用于比较你输入的字符和“我是🐖”是否一致\n\n要注意“&#x3D;&#x3D;”不能用于比较字符\n\n这里用到的是十分基础的while+if的语句组合。\n运行结果如下\n\n\n输入我是🐖后注销会取消，如果输入错误会再次弹出提示\ngoto语句写关机程序当然，如果看过上一篇的你肯定知道这篇博客的重点是goto\n主要是演示一下again在goto所在代码行之前的情况\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar input[20] = &#123; 0 &#125;;\tsystem(&quot;shutdown -s -t 60&quot;);//头文件&lt;stdlib.h&gt;again:\tprintf(&quot;请注意，你的电脑将在1分钟内关机，如果输入:我是猪，就取消关机\\n请输入&gt;:&quot;);\tscanf(&quot;%s&quot;, input);\tif (strcmp(input, &quot;我是猪&quot;) == 0)//比较两个字符 -strcmp() 头文件&lt;string.h&gt;\t&#123;\t\tsystem(&quot;shutdown -a&quot;);\t&#125;\telse\t&#123;\t\tgoto again;\t&#125;\treturn 0;&#125;\n\n运行的结果和上面的whlie语句一样，这里就不截图了\n这个代码可以用来整蛊你的损友，或者在春节的时候阻止熊孩子“借”用你的女朋友（指电脑）\n询问框里的问题和对应的回答都可以随意更改，当然你也可以把时间改成10秒让人压根来不及反应\n如果你用的是devc++，每次运行代码的时候都会自动生成一个exe文件\n\n把logo改改，就能去糊弄人了\n（话说vs2019要怎么生成exe啊，得去研究一下）\n郑重警告！\n\n娱乐一下即可\n\n若使用该程序导致电脑关机且未保存重要文件\n\n\n本博主不负任何责任！\n点个赞再走呗，谢谢！\n","categories":["C语言初识"],"tags":["C语言","函数"]},{"title":"【C语言】排序三个输入的数字","url":"/2021/08/27/code/note_c/8%E6%8E%92%E5%BA%8F%E4%B8%89%E4%B8%AA%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E5%AD%97/","content":"如何将输入的3个数字排序并打印出来@[TOC]\n承接上篇博客中输出数组内元素最大值的内容\n本篇博客向大家分享如何将我们输入的三个数字进行大小排序并打印出来\n1.scanf函数int main()&#123;\tint a = 0;\tint b = 0;\tint c = 0;\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);&#125;\n\n既然需要输入，那就要用到scanf函数来接受我们输入的数字\n\n要使用指针变量，因为这里的scanf需要改变我们的a，b，c\nscanf的头文件是 &lt;stdio.h&gt;\n\n2.tmp盒子相信大家在自己的学习中已经接触过使用tmp来进行大小比较的代码了\n什么？没有？\n那也没关系，基本实现的原理易懂的很！\nif (a &lt; b)\t&#123;\t\tint tmp = a;\t\ta = b;\t\tb = tmp;\t&#125;\n\n\n把a的值赋给tmp\n因为a小于b，所以我们让a等于更大的值\n再使用tmp把原来是a的值赋给b\n\n这样就写好了一个大小比较和交换的语句了\n我们只需要CTRL+C然后+V\n稍微改改里面的abc\n就能写出下面的完整代码\n#include&lt;stdio.h&gt;int main()&#123;\tint a = 0;\tint b = 0;\tint c = 0;\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\tif (a &lt; b)\t&#123;\t\tint tmp = a;\t\ta = b;\t\tb = tmp;\t&#125;\tif (a &lt; c)\t&#123;\t\tint tmp = a;\t\ta = c;\t\tc = tmp;\t&#125;\tif (b &lt; c)\t&#123;\t\tint tmp = b;\t\tb = c;\t\tc = tmp;\t&#125;\tprintf(&quot;%d&gt;%d&gt;%d&quot;, a, b, c);\treturn 0;&#125;\n\n运行一下\n\n这里需要注意，我们输入数字的时候需要用空格隔开两个数字\n因为这串代码实现的是从大到小排列\n所以我们可以打印的时候在每个数字之间加个&gt;号\n这里显示的内容和下面这行代码%d中间的内容是一致的\nprintf(&quot;%d&gt;%d&gt;%d&quot;, a, b, c);\n\n比如我把中间的&gt;改成#号，打印出来也是一致的\n\n注意的点在编写这个3个数字比较的代码的时候，我们要先将a和b、c比较，再比较b和c下面的这个代码是一个错误的代码\nif (a &lt; b)&#123;\tint tmp = a;\ta = b;\tb = tmp;&#125;if (b &lt; c)&#123;\tint tmp = b;\tb = c;\tc = tmp;&#125;if (a &lt; c)&#123;\tint tmp = a;\ta = c;\tc = tmp;\n\n因为我们需要先确定a里面装的是最大的那个数字，然后才能让b和c比较决出“季军”如果这样说你还是没太明白，可以尝试将这串代码输入vs编译器，用ctrl+f10调试，查看运行一个if语句之后a，b，c的赋值的变化\n\n结语这串代码如果继续复制粘贴的话可以实现不止3个数字的大小排列并打印\n不知道能不能用自定义函数实现这个功能？\n点个赞再走呗，万分感谢！\n","categories":["C语言初识"],"tags":["C语言"]},{"title":"【C语言】猜数字游戏","url":"/2021/08/15/code/note_c/9%E5%87%BD%E6%95%B0%E5%BA%93%E5%87%BD%E6%95%B0/","content":"函数是什么?数学中我们常见到函数的概念，但是你了解C语言中的函数吗？维基百科中对函数是如下定义的。可以说函数function是计算机变成语言中非常重要的一环。如果我们想学好c语言，就必须学会如何使用库函数，以及如何创建自定义函数。\n回溯在我的【猜数字游戏】博客中，已经有讲述过如何查询库函数的定义。在上一篇【传值调用和传址调用】中也有与自定义函数相关的内容。本篇博客将更细致地向初学c的伙伴们分享如何使用库函数。@[toc]\n库函数库函数，是c语言库中已经包含了的函数。这些函数的作用不一，但他们都有一个共同点——所有人都用的上。\n\n当你写出一串代码，肯定会想知道它运行的结果，这时候要用到 printf 来打印大家第一个学习的hello world代码中就用到了 printf库函数\n在编程过程中我们需要频繁地做字符串的拷贝 strcpy\n\n既然所有人都用的上，那为什么不让这些函数变成编程语言中预设的功能，让后来者更方便的使用编程语言呢？这样效率倍增，可移植性和易用性也大大增强，何乐而不为。库函数由此诞生\nC语言常用的库函数\nIO函数\n字符串操作函数\n字符操作函数\n内存操作函数\n时间&#x2F;日期函数\n数学函数\n其他库函数\n在【猜数字游戏】中使用到的time函数是时间函数的一种\n\n\n\n接下来我用两个函数的具体案例，和大家分享如何查找库函数定义以及如何尝试使用库函数分别是 strcpy函数 和 memset函数\n查询库函数定义在这里给大家分享两个超棒的网站！\n\ncppreference 中文\ncplusplus 英文\n\n如果要查询库函数定义，cplusplus是我们的不二之选。它虽然只有英文，但是这难不倒我们代码人，实在不行就网页翻译一下嘛！\n夹带私货时间如果你用的是chrome或者微软最新的edge浏览器，可以尝试安装侧边翻译这个插件非常好用，强力推荐！\nmemset函数打开cplusplus，输入我们需要查询的函数看不懂？没关系。只要了解下面几个简单的单词，我们就能尝试去读库函数的定义了\n\nfunction →函数\nParameters →参数\nReturn Value →返回值\nExample →例子\n\n在页面的左边我们可以看到函数的头文件\n\n需要注意的是，是c++语言里的头文件，而左边的&lt;string.h&gt;才是我们c语言要用的头文件\n\ncplusplus真正强大的地方，在于它可以让你直接在网页端编辑给出的代码例子memset其实是由两个单词组成的，memeory内存 + set设置读函数定义的文档的时候，最好是逐字解读，不要整句翻译。\n\n注意每个函数下面绿色的这一行以memset为例，void*表示它是指针变量，int表示整型，size_t表示大小\n\nFill block of memory 填充内存块\nSets the first num bytes 设置前num个字节\nSets the first num bytes of the block of memory 设置内存块中的前num个字节\npointed by ptr 由ptr指引的\nto the specified value 设置成特殊的value\n\n\n连起来就是：\n\n把由ptr指引的内存块的前num个字节设置成特殊的value\n\n让我们继续解读\n\nptr 要被填充的内存块的pointer指示器\nvalue 要被设定的特殊值，它是int整型\nnum 有多少字节的内存要被设定成value\nsize_t 无符号整型\n\n读到这里，关于memset的定义我们就能大概了解了接下来就要进入实践了\n#include&lt;string.h&gt;//memset头文件#include &lt;stdio.h&gt;//printf头文件int main()&#123;\tchar arr[] = &quot;hello world&quot;;\tmemset(arr, &#x27;*&#x27;, 5);\tprintf(&quot;%s\\n&quot;, arr);\treturn 0;&#125;\n在使用memset的时候，我们遵循定义中的 ( void * ptr, int value, size_t num )方式\nmemset(arr, &#x27;*&#x27;, 5);\n\narr是我们要更改的内容\n‘*’ 指我们把arr中的内容最终改成  ‘*‘\n5 表示我们想更改5个字符的内容\n用 printf 打印最终更改后的结果\n\n运行的结果如下图所示可以看到，hello world中的前五个字符，也就是hello被改成了*****和memset的定义的描述完全一致！\n怎样，是否有点小激动？（反正我当时学到这里的时候是有的）让我们继续！\nstrcpy函数比起memset函数，strcpy函数的使用频率更高我们同样在cplusplus中查询strcpy函数的定义我们依旧用上述说的逐步解读法来查阅strcpy的定义\n\nCopies the C string 拷贝内容\npointed by source 由source指示的的内容\ninto the array pointed by destination 到目标数组中\n\n\n拷贝由source指示的内容到目标数组中\n\n照样实践一下\n#include &lt;string.h&gt;//strcpy函数头文件#include &lt;stdio.h&gt;int main()&#123;\tchar arr1[] = &quot;bit&quot;;\tchar arr2[20] = &quot;##########&quot;;\tstrcpy(arr2, arr1);\tprintf(&quot;%s\\n&quot;, arr2);\treturn 0; &#125;\n(arr2, arr1)  其中arr2是我们的目标，arr1是我们要拷贝的内容\nstrcpy(arr2, arr1);\n\n运行结果如下当你看到这里的时候，肯定会有和我一样的疑惑为什么拷贝到2中的内容只有bit三个字节，但是后续的#######没有打印出来呢？这里就涉及到转义字符里面的内容了\n字符结束标志”\\0“是字符串的结束标志，默认跟在我们输入的字符后面\n\n“bit” 字符实际为 ”bit\\0“\n\n打印的时候遇到”\\0“会自动停止\nchar arr1[] = &quot;bit&quot;;char arr2[20] = &quot;##########&quot;;              // bit\\0遇到\\0认为字符串结束，所以不打印后面的#\n与strcpy长得很像的还有另外一个库函数strlen\n\nstrcpy - string copy - 字符串拷贝\n\nstrlen - string length - 字符串长度有关\n\n对于strcpy函数 和 memset函数 的介绍到这里就结束了\n结语到这里，对于查询库函数以及使用库函数的方法应该已经很清晰了（自我感觉 ）希望对大家有所帮助c语言新人，有所纰漏在所难免，欢迎各路dalao无情指正！\n纯手打，4k多字，今天效率比昨天高，2小时就搞定了点个赞再走吧，谢谢大家！\n","categories":["C语言初识"],"tags":["C语言","函数"]},{"title":"【C++】STL：string","url":"/2022/06/29/code/note_cpp/10STL_String%E7%B1%BB/","content":"这是接触STL的第一篇博客，让我们以string为始，走入SLT的世界吧！\n\n\n[TOC]\n1.何为STLSTL是C++标准库的重要组成部分，其作用是为绝大多数数据结构提供轮子，是一个包罗了数据结构和算法的软件框架。\n在之前C语言的数据结构专栏中，顺序表、链表等等都是需要我们自己造轮子来实现。但在C++中，有STL就好比站在了巨人的肩膀上，可以走的更远。当我们需要使用这些内容时，无需自己重新造轮子，从而大大提高了开发效率。\n1.1 STL版本这里我直接贴一个C语言中文网的链接👉【点我】\n里面详细介绍了STL发展历程中出现的几个版本，其中SGI因为被Linux的GCC所使用，可移植性高。之后的博客主要是学习SGI STL版本。\n\n1.2 STL组成同样是C语言中文网的资料👉【链接】，我将它整理为了下面这个思维导图\n\n在面试中，STL的内容也是HR经常考察的。所以我们一定要认真学习这一部分的知识点！\n1.3 STL的一些吐槽如果你去Cplusplus网站上看过STL库的接口，你就会发现STL库的设计有些复杂。有很多地方都考虑的过于细致，导致函数接口非常多，想要全记住这些接口是有些困难的\n\n当然，这也是我自己太菜了的缘故。或许以后用的多了，这些就理所应当的记住了吧。\n同时，因为STL使用了模板，所以当你多次使用STL时（比如vector容器）就容易出现代码冗余\n\n好啦，不bb这些没用的了，还是直接进入正题string类吧！\n\n\n2.String\n参考cplusplus的标准文档：string\n\nstring类是表示字符串的字符串类，该类的接口和常规的容器基本相同，并添加了一些专门用于操作字符串的常规操作。使用string需要包含&lt;string&gt;和using namespace std;\n\n这里为什么是string而没有.h呢？\n其实编译器处理头文件并不会关注头文件的后缀，且C语言中已经有一个string.h了，为了避免冲突，所以使用了&lt;string&gt;作为头文件\n\n下面介绍一些常用的string类函数接口，标题中的英文和cplusplus网站中的分类对应\n2.1 编码格式在Class instantiations栏目下，可以看到string有很多不同的类，这些类的主要区别在于编码方式的不同。我们主要学习的是第一个的string类\n\n什么是编码格式呢？在编程学习中，比较常用的便是ASCii码，除此之外，还有utf-8、utf-16等等。\n\nASII码表中，英文单词、数字、各类标点符号都有它们对应的值，这样才能在只支持01二进制的电脑上显示出对应的内容。当计算机需要显示英文单词的时候，就会去查找这一个表。所以ASCII码表是漂亮国设计的。\n我们知道，英文中的基础只有26个单词，算上大小写也就52个。但是我们中华文化博大精深，计算机需要显示中文的时候，一个char类型的空间已经不够。所以我们需要整出一个我们自己的编码格式，以此让计算机支持显示中文——GBK就是这样一个编码格式\n\nGBK使用两个字节来存储一个汉字，一些不常用的生僻字可能需要3-4个字节来存储。\n用下面这个简单的函数来测试，我们可以发现，中文中谐音字的编码是相近的\n\n在网络上，我们打某些词汇会被替换成****，就是程序在后台实别了你的编码。同时如果想进行模糊匹配，把谐音字也屏蔽掉的话，就可以把这个词周围的编码全部屏蔽了。\n\n同理，utf-16和utf-32为了支持别的国家的语言，就会用更长的字节来存储文字。这里不进行详解。\n\n\nstring类有非常多的接口，我们并不需要完全掌握所有的函数接口。只需要学会常用的接口，在遇到一些不常用的，在需要使用的时候可以去查找cplusplus的文档。\n2.2 构造函数(constructor)\n下面是一些常用的string类的构造函数\n\n\n\n构造函数\n功能\n\n\n\nstring()\n空的string对象（空的字符串）\n\n\nstring(size_t n,char c)\nstring类对象中包含n个字符c\n\n\nstring(const char*s)\n利用常量字符串来构造对象\n\n\nstring(const string&amp;s)\n拷贝构造\n\n\n除此之外，在文档中我们还可以看到更多构造函数\n\n除此之外，我们还可以调用赋值操作符进行构造。下面是赋值重载的3个版本，想必都能看懂，是通过对象、常量字符串和字符进行赋值操作。\n\nstring类中也重载了流提取和流插入操作符，方便我们直接对对象进行输入输出操作。\n\n\n我们还可以选取一个范围进行构造，比如下面这个\n\n需要注意的是，该构造函数的第三个传参有缺省值npos\nstring (const string&amp; str, size_t pos, size_t len = npos);\n\n查文档可以看到，nops其实是-1，而它的类型是无符号整型，-1就代表无符号整形的最大值。即从pos位置开始，往后取最大值的长度（实际上压根没有那么长的字符串）\n\n2.3 析构函数(destructor)析构函数有个好处，就是编译器自己会进行调用，我们只需要简单了解即可。\n\n2.4 遍历string对象我们可以通过下面的3种方式来遍历一个string对象\nvoid test3()&#123;\t//尝试遍历一个string\tstring s1(&quot;hello world!&quot;);\t//1.重载[]\t//通过调用成员函数size得知长度\tcout &lt;&lt; &quot;operator[] &quot; &lt;&lt; endl;\tfor (int i = 0; i &lt; s1.size(); i++)\t&#123;\t\tcout &lt;&lt; s1[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//2.范围for\t//本质上调用的是迭代器\tcout &lt;&lt; &quot;auto &quot; &lt;&lt; endl;\tfor (auto c : s1)\t&#123;\t\tcout &lt;&lt; c &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//3.迭代器\t//在很多容器中是通用的\tstring::iterator it = s1.begin();//指向开头\t//end指向最后一个数据的下一个位置（即&#x27;\\0&#x27;)\tcout &lt;&lt; &quot;string::iterator &quot; &lt;&lt; endl;\twhile (it != s1.end())\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t\tit++;//使用方法类似指针\t&#125;\tcout &lt;&lt; endl;&#125;\n\n可以看到这三个方式都成功打印出了s1对象的完整内容\n\n其中范围for编译器在操作的时候是用迭代器来实现的，这一点通过查看汇编可以看出来\n\n2.5 operator[]和at（Element access）上面我们用到了operator[]重载，需要了解的是，这个重载返回的是值的引用。也就是说，我们除了可以用这个方式来访问值的内容以外，还可以通过这种方式来改变string中某一个位置的值。\n\nconst string s1(&quot;hello&quot;);s1[0]=&#x27;x&#x27;//此时调用的是const版本的重载，不可修改\n\nat函数的使用方式和[]重载类似\n\n区别就是，当operator[]遇到越界情况的时候，如果相等和小于长度，都不会报错。但是当下标大于长度时，会引发未定义行为\n\n而at()的处理方式是，只要长度不小于string的长度，就抛出异常\n\n2.6 正向和反向迭代器Iterators除了在2.2.3中使用过的正向迭代器以外，string还有一个反向迭代器rbegin\n//反向迭代器string::reverse_iterator rit = s1.rbegin();//指向结尾字符（&#x27;\\0&#x27;之前）//end指向开头数据的前一个位置while (rit != s1.rend())&#123;\tcout &lt;&lt; *rit &lt;&lt; &quot; &quot;;\trit++;//使用方法类似指针&#125;cout &lt;&lt; endl;\n\n这里需要注意的是，虽然这个迭代器是反向的，但是我们使用的时候，依旧会rit++而不是减\n\n注意，基本的迭代器是可读可写的。在string里面还实现了const的迭代器\nconst_iterator begin() const;const_reverse_iterator rbegin() const;\n\n如果你觉得这样写太麻烦，而且容易记不住。可以让auto来自动进行推导\nconst string s1(&quot;hello&quot;);auto rit = s1.rbegin();\n\nC++11中，为了和基本的方式进行区分，新增了以c为前缀的4个迭代器。其使用和const_iterator是没有区别的。\n\n\n2.7长度和容量操作Capacity\n2.7.1 size和length这其中size和length的功能完全相同。只是早期string设计的时候以length作为字符串的长度。在新版本中为了和其他接口比如List进行同步，又新增了一个size来表示字符串长度。\n\n\n2.7.2 resize和reserve\n注意区分reserve和reverse\n\n我们可以通过reserve对内存进行扩容操作，容量变大是因为需要内存对齐\n\n但在实际应用中，当字符串的容量快要写满的时候，程序会自动进行扩容，大概是1.5倍\n\n\n而resize的操作是修改string类的长度size，并同时进行扩容\nstring s1(&quot;hello&quot;);cout &lt;&lt; s1.capacity() &lt;&lt; endl;s1.resize(100);cout &lt;&lt; s1.capacity() &lt;&lt; endl;\n\n通过调试可以发现，这里会把size修改为100，并将多余内容全部初始化为0\n\n我们还可以给resize进行传参，指定初始化的内容\n\n\n同时，这两个函数一般都不会对容量进行缩容\n\n但是resize会修改size的大小，即抛弃掉10以后的内容，但保持容量不变\n\n需要注意的是，在VS2019中（不同编译器可能不一样），reserve如果传参小于15，则会对容量进行缩容到15（string对象默认会开辟15个字节的capacity）\n\n\n2.8修改内容（Modifiers）string可以通过很多方式来增加、删除内容\n2.8.1 尾插\n它们的基本使用如下，其中最方便的肯定是+=操作了，又清晰又简单！\n\n2.8.2 中间插入string并没有提供一个头插的选项，而是提供了一个Insert，可以在任何位置进行插入\n\ninsert函数的时间复杂度相对较高，因为在中间或者开头插入内容需要挪动数据。空间不够的时候还需要执行扩容操作，效率较低。\n\n2.8.3 删除可以通过erase函数删除数据\n\n\n1：默认从0开始完全删除，可以选择从pos位置开始删除len长度的数据\n2：利用迭代器删除p位置的内容\n3：删除一个范围的数据，从first开始last结束\n\n这个很容易理解，在这里就不做演示了\n2.8.4 替换这个函数使用并不频繁，其修改操作不如使用拷贝复制😂\n\n比如其中第二个函数的作用是将str对象中，从subpos位置开始的sublen长度内容复制到本对象中。\n2.8.5 交换在string类中有一个交换函数，同时，std标准库里面也有一个交换函数\ns1.swap(s2);//string类swap(s1,s2);//std标准\n\n\n\nstring类里面的函数是交换类对象的指针\n而标准库里面的swap函数需要进行深拷贝交换\n\n所以string类里面的swap函数在处理对象的时候，比标准库里面的swap效率会高一些\n2.9字符串操作（String operations）2.9.1 c_str这个接口的作用是返回一个字符串的指针，其主要是为了和C语言的一些函数对应，比如利用strcmp拷贝一个string对象到内置字符串char arr[]中。\n\n\n2.9.2 find这里可以看到非常多种类的查找函数（偷懒不写示例了）\n\n\nfind函数可以查找string中的某一个字符或者字符串，并返回起始位置的下标\n该函数默认从头开始查找，你也可以单独指定从pos位置开始查找\n\n\n\n和迭代器一样，rfind则是从末尾开始找指定内容\n\n有些时候我们需要查找的内容并不是从头开始的，所以就需要从尾部开始找。\n\nsubstr是从指定pos位置开始获取长度为len的子串\n\n\n\n2.10 很多操作符重载string里面有非常多的操作符重载，支持和字符串、字符、对象进行大小对比。虽然看的有点麻了，但实际上它们只是方便我们使用。底层实现了解一下就可以了（我这是不是废话…）\n \n其实一部分内容都是可以通过编译器的隐式类型转化或者临时构造一个string类来实现的，但是设计string的大佬们显然觉得多即是好，哈哈。\n3.模拟实现要想切切实实弄明白STL的源码结构，其中一个最好的办法就是尝试模拟实现一个和std库里面string使用方法&#x2F;功能相同的轮子。\n\n我的string模拟实现源码已经托管到gitee了【链接】\n\n其实string和vector就是一个简单的顺序表，其二者的底层差距主要在string只能保存字符（串），当然，内部的接口有一些细微的差距，这会在vector的博客里面进行讲解。\n大部分函数可以直接在gitee上面查看，我写了还算靠谱的注释，有任何问题可以在gitee或者本博客下留言。\n\n3.1 利用指针模拟实现迭代器从string开始，我们第一次接触了stl中的迭代器这一新鲜玩意。\n//反向迭代器string::reverse_iterator rit = s1.rbegin();//指向结尾字符（&#x27;\\0&#x27;之前）//end指向开头数据的前一个位置while (rit != s1.rend())&#123;\tcout &lt;&lt; *rit &lt;&lt; &quot; &quot;;\trit++;//使用方法类似指针&#125;cout &lt;&lt; endl;\n\n看起来很牛，实际上它的操作和我们自己写的指针大差不差。我们大可以直接使用指针来模拟实现出一个相同功能的迭代器！\n//迭代器相关const_iterator begin() const&#123;    return _a;&#125;const_iterator end() const&#123;    return _a + _size;&#125;iterator begin()&#123;    return _a;&#125;iterator end()&#123;    return _a + _size;&#125;//以下是string模拟实现中私有成员变量private:    char* _a;//实际存放数据    size_t _size;//有效长度    size_t _capa;//容量大小    const static size_t npos;//声明\n\n看吧，是不是很简单！🌃这个迭代器的使用方法和顺序表中的指针一模一样，这里就不演式啦！感兴趣的伙伴可以把源码考下来自己试试。\n\n3.2 深拷贝在之前类和对象的博客中，我已经简单实现过一次深拷贝（链接）\n对于string来说，深拷贝的操作和博客里面演示的是一样的，都是通过给予新的空间，然后用strcpy或者memset拷贝内容过去。\n//拷贝构造string(const string&amp; s)    :_size(s._size),\t_capa(s._capa)&#123;    _a = new char[_capa+1];    strcpy(_a, s._a);&#125;\n\n除了拷贝构造以外，赋值重载同样需要深拷贝操作，但是它的操作和构造函数又有些不同\n\n拷贝构造时，该对象还不存在，通过构造函数构造出内容\n赋值重载时，该对象可能已经有自己的数据，需要先释放已有的才能获取新的\n\n这就需要我们在赋值重载的时候，先delete掉原本的内容，再去进行赋值\n//深拷贝赋值重载string&amp; operator=(const string&amp; s) &#123;    //和拷贝构造不同的是，赋值重载之前，this可能已经有自己的内容了    //所以在执行操作之前，我们需要把this自己的内容先释放掉    if (this != &amp;s)//不要自己拷贝自己     &#123;        delete[] _a;//删除已有空间        _size = s._size;        _capa = s._capa;        //_a = new char[_capa + 1];//有一定风险        char* tmp = new char[_capa + 1];        strcpy(tmp, s._a);        _a = tmp;    &#125;&#125;\n\n这样我们的赋值重载便也实现完毕了\n3.3 关于insert函数操作字符和字符串的区间问题当我们使用insert来处理字符的时候，需要将插入位置之后的数据往后挪动。\n而insert字符串的时候，则需要挪动该字符串长度的数据。\n这时候就非常容易出现挪动不完整&#x2F;越界等等问题！\n关于insert代码可以看gitee代码的190-237行，如果你不太能理解这里的移动问题，最好的办法，就是画图！画图会让你清楚的认识到需要移动多长，指针应该指向哪里进行移动。理清思路后，写代码就会容易很多。\n3.4 关于push_back的边界控制问题之前我实现的代码中，尾插的时候没有加上\\0进行边界控制\n这一点需要注意，因为模拟实现的底层用的就是C语言的字符串。在每一次尾插之后，都需要用\\0来标记字符串的结尾。否在我们拷贝构造和reserve的时候使用strcpy就会出现越界错误。\n\n越界错误一般都是在析构delete的时候检查出来的\n\nvoid push_back(char ch)&#123;\tif (_size + 1 &gt;= _capa)\t&#123;\t\treserve(_capa == 0 ? 4 : _capa * 2);\t\t//这里的判断是为了辨别是否在空对象尾插\t&#125; \t_a[_size] = ch;\t_size++;\t//因为reserve和基础的拷贝构造用的都是strcpy\t//所以必须要有\\0来标识结尾！\t_a[_size] = &#x27;\\0&#x27;;&#125;\n\n\n结语关于string类的介绍到这里就结束啦！\n如果有什么新增内容的话，我会对本篇博客进行修改\n\n如果有什么问题，欢迎评论区提出哦！\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：vector","url":"/2022/07/15/code/note_cpp/11STL_Vector/","content":"STL的第二站，便是vector了。\n\n\n对于学习STL，有一个非常大的好处便是，它们有很多函数都是相通的！这也是面向对象的一大好处：背后的函数实现可能不同，但是使用方式相同。\n1.简单了解vector\nhttps://m.cplusplus.com/reference/vector/vector/\n\n老样子，打开我们的cplusplus——然后惊奇的发现，它换UI了！终于不再是那个2000年初的模样了（虽然这和我们的使用没啥关系）\n\n不摸鱼了，来看看vector究竟是何方神圣——其实他就是一个顺序表\n和string不同的是，vector有模板参数，可以存储任何类型的内容。int、double、char、甚至string。\n这一点在cplusplus网站上的第一行便告诉了我们\n\ntemplate &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; // generic template\n\n你还可以看到，标题下方给了一个这样的类模板定义，其中T代表的是存放数据类型，allocator&lt;T&gt;也是STL库中的一部分，用于向堆申请空间（类似一个内存池）可以提高访问的效率\n前期的学习我们不需要知道allocator&lt;T&gt;是怎么实现的，只要知道它有这个功能就ok了。\n\n1.1函数接口往下滑，你会发现vector的函数接口，我们很多都已经学过了！\n\n这些函数的操作和string类型都是一样的，这里就不再讲解了！\n\n对比发现，其实vector多出来的函数并不多，这便是学习STL的好处！\n\n2.使用vector因为大部分函数的功能、操作和string一样，有问题可以去看看我之前string的博客\n2.1构造\n对于vector而言，比较常用的构造函数是下面这几个\n\n这里说说最后一个，利用迭代器进行初始化，它的使用如下\nstd::string s1(&quot;hello&quot;);vector&lt;char&gt; v2(s1.begin(),s1.end());for (auto ch : v2)&#123;\tcout &lt;&lt; ch &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;\n\n当我们已经有一个其他的支持迭代器的容器之后，便可以使用该容器的迭代器初始化一个vector\n这里的区间可以自行控制，对应的初始化的内容也会有所不同\n\n\n2.2迭代器vector的迭代器和string基本相同，都拥有正向和反向两种方式\n\n\n\n迭代器\n说明\n\n\n\nbegin+end\n获取第一个数据位置iterator&#x2F;const_iterator， 获取最后一个数据的下一个位置iterator&#x2F;const_iterator\n\n\nrbegin+rend\n获取最后一个数据位置的reverse_iterator，获取第一个数据前一个位置的 reverse_iterator\n\n\n\nvector&lt;int&gt;::iterator it = v.begin(); while (it != v.end()) &#123;     cout &lt;&lt; *it &lt;&lt; &quot; &quot;;     ++it; &#125;\n\n利用迭代器，我们可以打印vector的内容\n2.3迭代器失效问题在vector中的一些操作会导致迭代器失效，即迭代器指向的内容含义变了。包括但不限于：\n\n因为erase导致的数据擦除\n扩容导致的原有空间被释放（此时迭代器依旧指向原有空间）\n所有会导致扩容的操作\n\n这时候我们需要借助函数的返回值对it进行重新赋值，比如下图是erase和insert的返回参数\n\n\n我们只需要在使用迭代器遍历的时候用it来接受返回值（更新迭代器）就可以规避这个问题\nvoid test02()&#123;    vector&lt;int&gt; v1;    v1.push_back(1);    v1.push_back(2);    v1.push_back(3);    v1.push_back(4);    v1.push_back(5);    v1.push_back(6);    v1.push_back(7);    vector&lt;int&gt;::iterator it = v1.begin();    while (it != v1.end())    &#123;        if (*it % 2 == 0)//在偶数之前插入内容        &#123;            //不这样写会出现it的含义变化而导致的死循环            //程序内出现了扩容，it原先指向的空间已经被释放            it = v1.insert(it, 99);\t            it++;        &#125;        it++;    &#125;    for (auto ch : v1)    &#123;        cout &lt;&lt; ch &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n\n\n库里面的其他函数就不进行讲解啦，有问题的可以去看看之前string的博客。当然最好的学习办法就是依据cplusplus上面的函数定义，尝试自己弄明白这些库函数的使用方法。\n\n3.模拟实现\n代码详见我的gitee仓库【链接】STL-Vector的源码也在里面！\n\n和string类不同的是，在vector里面并不是用size和capacity这两个成员变量来确认有效长度和容量的。\n通过查看stl源码可以看到，其使用了3个迭代器进行标识\n\nprivate:    iterator _start;//指向开头（存放数据）    iterator _finish;//指向结尾的下一个    iterator _endofstorage;//指向空间尾部\n\n了解结构后，便可以先把无参构造和析构函数写出来待用\n//无参构造函数vector()    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123; &#125;//析构~vector()&#123;    if (_start)    &#123;        delete[] _start;        _start = _finish = _endofstorage = nullptr;    &#125;&#125;\n\n那么要怎么知道size和capacity的大小呢？很简单，通过指针相减即可得出结果\nsize_t size()const&#123;    return _finish - _start;&#125;size_t capacity()const&#123;    return _endofstorage - _start;&#125;\n\n3.0 迭代器在模拟实现一开始，我们就要用typdef定义两个迭代器，方便后面的使用\ntypedef T* iterator;typedef const T* const_iterator;iterator begin()&#123;    return _start;&#125;iterator end() &#123;    return _finish;&#125;const_iterator begin()const &#123;    return _start;&#125;const_iterator end()const &#123;    return _finish;&#125;\n\n3.1 reserve&#x2F;resize现在我们的vector内容还是空空的，我们需要先实现一下push_back函数，可以基本操作一下我们的数据。但没有构造函数去申请空间，哪来的目标给我们操作呢？\n\n这时候就需要先实现reserve来扩容和获取空间了！\n\n在扩容之前，我们需要获取原有数据的长度，再new将空间整出来，并给_start。操作结束后，我们需要修改_finish 和_endofstorage，否则这两个迭代器指向的还是原有空间，出现了迭代器失效问题\nvoid reserve(size_t n)//扩容&#123;    size_t sz = size();//计算原有的长度    if( n &gt; capacity())    &#123;        T* tmp = new T[n];        if (_start) //只有_start不为空才进行拷贝操作        &#123;            //memcpy是浅拷贝，当遇到vector类型是自定义类型（比如string和vector&lt;T&gt;这种包含堆区内存的类型）            //浅拷贝会失效，string的成员变量拷贝过去了，但是成员变量指向的堆区空间被释放，出现野指针            //memcpy(tmp, _start, size());            for (size_t i = 0; i &lt; size(); i++)            &#123;                tmp[i] = _start[i];//手动赋值，当成员是自定义类型的时候，会调用=重载            &#125;            delete[] _start;//释放原有空间        &#125;        _start = tmp;    &#125;    //这里必须要先计算sz，如果在这里直接调用sz的话：finish已经是野指针了，finish-start会出现问题    _finish = _start + sz;    _endofstorage = _start + n;&#125;\n\n关于为何拷贝内容的时候需要用&#x3D;而不能直接memcpy，后文会提到。\nresize和reserve唯一不同的一点，就是reserve会修改原有空间的数据，其余的实现是一样的。所以这里面我们直接复用reserve进行扩容即可\n//在C++中，内置类型也有一个“构造函数”//这是为了更好的支持模板操作void resize(size_t n,T val = T())&#123;    if (n &gt; capacity())    &#123;        reserve(n);    &#125;    if (n &gt; size())    &#123;        //初始化        while (_finish &lt; _start + n)        &#123;            *_finish = val;            ++_finish;        &#125;    &#125;    else    &#123;        _finish = _start + n;    &#125;&#125;\n\n注意，T()的含义是用模板参数的构造函数作为缺省值。在C++中，内置类型也可以进行这个操作\n\n当你不进行传值的时候，int类型默认是0\n\n3.2插入&#x2F;删除空间拿到了，现在就可以对我们的数据进行插入操作了\nvoid push_back(const T&amp; x)&#123;    if (_finish == _endofstorage)     &#123;        size_t newcapa = capacity() == 0 ? 4 : capacity() * 2;        reserve(newcapa);    &#125;    *_finish = x;    _finish++;&#125;void pop_back()&#123;    if (_finish &gt; _start)     &#123;\t\t_finish--;\t&#125;&#125;\n\n简单测试一下插入和删除功能，没啥问题\n\n更好的办法，其实是写好insert和earse，然后尾插尾删的时候直接复用即可\n//pos位置插入valiterator insert(iterator pos, const T x)&#123;    assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);    //assert(pos &gt;= _start &amp;&amp; pos &lt;= _endofstorage);    if (_finish == _endofstorage)    &#123;        size_t n = pos - _start;        size_t newcapa = capacity() == 0 ? 4 : capacity() * 2;        reserve(newcapa);        pos = _start + n;    &#125;    iterator end = _finish - 1;    while (end &gt;= pos)    &#123;        *(end + 1) = *end;        end--;    &#125;    *pos = x;    _finish++;    return pos;&#125;//删除数据iterator erase(iterator pos)&#123;    assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);    iterator tmp = pos;    iterator end = _finish - 1;    while (tmp &lt; end)    &#123;        *tmp = *(tmp + 1);        tmp++;    &#125;    _finish--;    return pos;&#125;\n\n因为这里我们只需要操作一个元素，所以就不需要担心移动多个数据可能导致的问题，事情也变得简单多了\nvoid push_back(const T&amp; x)&#123;    insert(end(),x);&#125;void pop_back()&#123;    erase(end()-1);&#125;\n\n尾插尾删操作直接复用源码即可\n3.3重载[ ]操作符因为vector本身只是个顺序表，所以我们需要对它的对象重载一下[]操作符，这样就能和数组一样去访问vector的数据\n//重载[]操作符T&amp; operator[](size_t pos)&#123;    assert(pos &lt; size());    return _start[pos];&#125;const T&amp; operator[](size_t pos) const&#123;    assert(pos &lt; size());    return _start[pos];&#125;\n\n\n关于构造函数，这里重点介绍一下迭代器区间的构造函数，因为后面的拷贝构造我们会用上它。\n3.4迭代器区间构造&#x2F;拷贝&#x2F;赋值库里面关于该构造函数的定义如下\ntemplate &lt;class InputIterator&gt;   vector (InputIterator first, InputIterator last,           const allocator_type&amp; alloc = allocator_type());\n\n因为这时候我的水平还很垃，就暂且不管这个 allocator了\n该函数需要我们传参两个迭代器，因为我们底层就是用指针实现的，所以直接解引用然后将内容尾插即可（如果没有空间，尾插会调用reserve来获取空间&#x2F;扩容）\ntemplate &lt;class InputIterator&gt;vector(InputIterator first, InputIterator last)    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123;    while (first != last)    &#123;        push_back(*first);        first++;    &#125;&#125;\n\n有了这个构造函数后，拷贝构造就很容易了！\nvoid swap(vector&lt;T&gt;&amp; v)&#123;    std::swap(_start, v._start);    std::swap(_finish, v._finish);    std::swap(_endofstorage, v._endofstorage);&#125;//拷贝构造vector(const vector&lt;T&gt;&amp; v)    :_start(nullptr),_finish(nullptr),_endofstorage(nullptr)&#123;    vector&lt;T&gt; tmp(v.begin(), v.end());    swap(tmp);&#125;\n\n利用迭代器区间构造出来一个tmp对象，再将该对象和我们本身进行交换即可！\n\n你可能会问：欸你这样交换了，原本的内容岂不是没人管了，有内存泄漏啊！\n\n并不是这样的，我们使用库函数里面的swap交换了二者的成员变量，在拷贝构造函数完成之后，tmp生命周期结束，会自动调用构造函数处理掉我们的数据！\n这就是让别人帮你干活😂\n赋值重载就跟简单了，我们连tmp变量都不需要弄，直接使用传值（会自动调用拷贝构造一个临时变量）就可以啦！\n//赋值重载（v没有引用，拷贝构造一个新的传参过来，所以不需要手动再构建一个tmp）vector&lt;T&gt;&amp; operator=(vector&lt;T&gt; v)&#123;    swap(v);    return *this;&#125;\n\n3.5用n个value进行构造在库中的vector还有一个这样的构造函数，用n个val进行初始化\n\n因为我们之前已经实现了一个相关功能的函数resize，我们只需要调用resize就可以完成这个操作！\n//利用n个val进行构造vector(size_t n, const T&amp; val = T())    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123;    resize(n, val);&#125;\n\n只实现一个vector(size_t n, const T&amp; val = T())的版本是不可以的，因为我们忽略了一种情况\nvector&lt;char&gt; v1(10,&#x27;x&#x27;)//可以成功调用vector&lt;int&gt;  v2(10,11) //不能成功调用！ \n\n\n为啥第二种情况不行呢？再来看看另外一个构造函数，我们之前实现过的迭代器区间构造\ntemplate &lt;class InputIterator&gt;vector(InputIterator first, InputIterator last)\n\n你会发现，当我们传的两个参数都是int类型的时候，编译器会直接调用这个模板函数！因为first和last就是两个相同类型的参数！\n通过调试也可以看到在进行构造的时候，调用了这个迭代器区间构造函数\n\n为了避免这种情况，我们需要对int类型单独处理一下，修改一下传参即可\n//如果不单独重载一个int类型版本，就会被识别成上面的模板函数//int是不能当作迭代器进行解引用的，会报错vector(int n, const T&amp; val = T())    :_start(nullptr),\t_finish(nullptr),\t_endofstorage(nullptr)&#123;    resize(n,val);&#125;\n\n\n这个问题是怎么发现并解决的？\n\n我们可以直接查看stl源码，瞅瞅库里面是怎么实现的\n\n可以看到库里面不但重载了一个int类型的版本，还重载了long长整型的情况\n到这里，我们的模拟实现就基本完成了！\n\n3.6关于自定义类型的拷贝问题为什么在3.1的reserve实现中，我使用了赋值重载，而没有使用memcpy？\n来看看下面这个OJ题目杨辉三角的代码\n\nleetcode118杨辉三角：https://leetcode.cn/problems/pascals-triangle/submissions/\n\nclass Solution &#123;\tpublic:\t\tvector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;\t\t\tvector&lt;vector&lt;int&gt;&gt; vv;\t\t\tvv.resize(numRows);\t\t\tfor (size_t i = 0; i &lt; vv.size(); ++i)\t\t\t&#123;\t\t\t\t// 杨辉三角，每行个数依次递增\t\t\t\tvv[i].resize(i + 1, 0);\t\t\t\t// 第一个和最后一个初始化成1\t\t\t\tvv[i][0] = 1;\t\t\t\tvv[i][vv[i].size() - 1] = 1;\t\t\t&#125;\t\t\tfor (size_t i = 0; i &lt; vv.size(); ++i)\t\t\t&#123;\t\t\t\tfor (size_t j = 0; j &lt; vv[i].size(); ++j)\t\t\t\t&#123;\t\t\t\t\tif (vv[i][j] == 0)\t\t\t\t\t&#123;\t\t\t\t\t\t// 中间位置等于上一行j-1 和 j个相加\t\t\t\t\t\tvv[i][j] = vv[i - 1][j - 1] + vv[i - 1][j];\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\treturn vv;\t\t&#125;\t&#125;;\n\n在这里面，我们有两层vector进行嵌套使用，外层的vector存放的是内层vector的对象。\n它的结构如下图\n\n这时候如果只用memcpy进行浅拷贝，相当于新的空间里面存放的是的确是新的vector对象，但这些vector对象存放的却是原有数据的指针，而原本的数据已经被我们delete掉了，出现了野指针问题！\n反应到代码上，当我们在 Solution内部进行一次打印，再在外部进行一次打印，结果就会完全不同\nvoid test05()&#123;    vector&lt;vector&lt;int&gt;&gt; ret = Solution().generate(5);    cout &lt;&lt; &quot;外部打印&quot; &lt;&lt; endl;    for (size_t i = 0; i &lt; ret.size(); ++i)    &#123;        for (size_t j = 0; j &lt; ret[i].size(); ++j)        &#123;            cout &lt;&lt; ret[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;\n\n\n使用赋值重载，就可以进行深拷贝，每一个vector对象都能获得新的值，也就不会出现这个问题！\n//reserve代码的一部分for (size_t i = 0; i &lt; size(); i++)&#123;    tmp[i] = _start[i];//手动赋值，当成员是自定义类型的时候，会调用=重载&#125;\n\n\n结语到这里，vector的模拟实现就完成啦！通过模拟实现可以让我们更好的理解vector容器的结构，也方便后续的使用！\n有任何问题，都可以在评论区提出哦！\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：list","url":"/2022/07/16/code/note_cpp/12STL_List/","content":"阿巴阿巴，list的博客来喽！\n\n\n[TOC]\n1.list是嘛玩意？之前的vector是一个顺序表。总所周知，学完顺序表肯定不能不学链表，所以list就来了！\n\nlist是一个可以在任何地方进行插入删除的序列式容器，可以进行前后双向迭代\n\n说人话就是：list是一个双向带头循环链表\n\n这不巧了嘛！之前我写过用C语言实现双向带头循环链表的博客\n其优缺点也很明显\n\n支持快速插入删除O(1)\n支持前后双向迭代访问\n不支持任意位置的随机访问\n\nSTL中的list也满足上面的这些优缺点\n话不多说，来看看list的函数接口吧！\n\nhttps://m.cplusplus.com/reference/list/list/\n\n函数接口大部分接口和前面所学的两个容器都是一样的啦，这里就不贴完整截图了（见上方链接）\n\n这里还多了一个emplace_front，看完函数解释后可知它也是一个头插\n\n2.简单了解使用2.1构造list支持的构造函数如下\n\n这些函数和vector完全一致，这里就不过多介绍了\n\n2.2迭代器\n\n\n迭代器\n说明\n\n\n\nbegin+end\n获取第一个数据位置iterator&#x2F;const_iterator， 获取最后一个数据的下一个位置iterator&#x2F;const_iterator\n\n\nrbegin+rend\n获取最后一个数据位置的reverse_iterator，获取第一个数据前一个位置的 reverse_iterator\n\n\n都是老样子，没有啥好说的\n\n除了迭代器以外，一般的容器都会提供front和back两个参数来访问头部&#x2F;尾部数据。但是我们并不常用这个，迭代器用的更多一些\n2.3长度操作库函数中给我们提供了两个和list长度相关的操作，因为是链表，所以也不存在扩容问题，每一个节点都是一个独立的空间\n\n\nempty 判断是否为空，是空返回true\nsize 计算list中有效数据长度\n\n关于插入和删除操作，list和vector/string基本都是一致的，学会一个基本都会用！\n2.4迭代器失效问题和vector一样，list也会遇到一定程度的迭代器失效问题。\n因为list是一个链表，其在插入操作的时候是在迭代器所指节点前一个位置进行插入，不会影响该节点和这个节点之后的结构，也不会导致迭代器失效。\n\n只有在删除的时候才会导致迭代器失效\n\n解决办法也很简单，使用迭代器删除数据的时候，接收返回值更新一下迭代器即可！\n\n基本了解了函数接口后，让我们来试试模拟实现吧！\n3.模拟实现\n模拟实现和STL-list源码见我的Gitee\n\n下图是之前C语言版本链表博客里，我画的双向带头循环链表的结构图\n\nlist的结构和这个图片是一样的。但因为我们现在所使用的是C++中的类和对象，所以我们的操作都需要尊崇stl库的命名规则和使用方法，其结构的实现也会有所不同。\n比如在STL源码中可以看到，list的主结构中只有一个node，即头节点。\n\n3.1 节点结构在list中，我们不直接在list主类中放入单个节点的结构，而是使用一个自定义类型作为节点。\n\n复习：在struct中，成员默认是共有\n\ntemplate&lt;class T&gt;   struct list_node   &#123;       list_node&lt;T&gt;* _next;       list_node&lt;T&gt;* _prev;       T _data;       list_node(const T&amp; val = T())           :_next(nullptr),       \t_prev(nullptr),       \t_data(val)       &#123;&#125;   &#125;;\n\n这样后面的插入删除操作就可以直接new一个新的node，并调用构造函数完成_data的赋值。\n在list的主类中，我们遵循库的方法，只用一个头节点的指针作为成员\nprivate:\tNode* _head;//头节点指针\n\n\n3.2 插入删除因为之前写过C语言的代码，关于插入和删除操作相对较为熟练，代码如下👇\n//在pos之前插入iterator insert(iterator pos, const T&amp; x)&#123;    Node* newnode = new Node(x);    Node* cur = pos._node;    newnode-&gt;_next = cur;    cur-&gt;_prev-&gt;_next = newnode;    newnode-&gt;_prev = cur-&gt;_prev;    cur-&gt;_prev = newnode;    return iterator(newnode);&#125;//删除pos位置iterator erase(iterator pos)&#123;    assert(_head-&gt;_next != _head &amp;&amp; pos._node!=_head);    Node* next = pos._node-&gt;_next;    Node* prev = pos._node-&gt;_prev;    prev-&gt;_next = next;    next-&gt;_prev = prev;    delete pos._node;    return iterator(next);&#125;\n\n而头插&#x2F;头删&#x2F;尾插&#x2F;尾删这类方法，我们直接复用insert和earse即可！\n\n\n3.3 迭代器（重要）在上面的插入和删除代码中，我已经使用了迭代器作为参数和返回值。由于list的主类中并没有直接存放3.1节点结构，我们需要自己单独完成一个迭代器的类，来实现迭代器的相关操作\n\nvector&#x2F;string是顺序表，迭代器可以直接用指针替代，在本类中模拟实现\nlist是顺序表，迭代器的+和-操作其实是通过next和prev指针往后往前找内容，所以需要单独的模拟实现\n\n在STL源码中的list也是单独重载了一个迭代器类\n\n其基本结构如下\ntemplate&lt;class T, class Ref, class Ptr&gt;struct __list_iterator&#123;    typedef list_node&lt;T&gt; Node;//节点结构    typedef __list_iterator&lt;T, Ref, Ptr&gt; self;//本类    Node* _node;//存放节点指针        __list_iterator(Node* node)\t\t:_node(node)\t&#123;&#125;&#125;\n\n这里解释一下为何有3个模板参数：ref指代引用，ptr指代指针\n因为在后续的操作中我们需要传入T的引用T&amp;和指针T*，如果之传入一个T，编译器无法确认是否为const类型，也就无法阻止用户使用迭代器修改值，成员的数据就不够安全，且const的成员函数无法调用迭代器。\n重载3个模板参数后，我们就可以用传入的模板参数来控制const类型\ntypedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;typedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n\n基本的结构弄清楚之后，下面一起来看看，迭代器的++和--，解引用以及指针-&gt;分别对应了链表的什么操作呢？\n3.3.1 加减好吧，前面已经提到过了，我们需要用\tnext/prev指针来完成加减操作\n//前置++self&amp; operator++()&#123;    _node = _node-&gt;_next;    return *this;&#125;//后置++self operator++(int)&#123;    //self是本类的别名，因为没有重载=操作符    //所以不能使用相等，要用构造函数    //self tmp = _node;    self tmp(*this);    _node = _node-&gt;_next;    return tmp;&#125;//前置--self&amp; operator--()&#123;    _node = _node-&gt;_prev;    return *this;&#125;//后置--self operator--(int)&#123;    self tmp(*this);    _node = _node-&gt;_prev;    return tmp;&#125;\n\n注意前置和后置的区别，后置加减需要先用一个tmp变量储存原本的迭代器位置，再让迭代器指向下一个节点\n而当我们解引用迭代器的时候，想获取的其实是_data的值，而不是节点的地址（这里迭代器依旧是用指针模拟的）\n3.3.2 解引用和指针操作所以重载后的解引用操作如下\nRef operator*()&#123;    return _node-&gt;_data;//返回值的引用&#125;Ptr operator-&gt;()&#123;    return &amp;(_node-&gt;_data);//返回地址&#125;\n\n3.3.3 判断相等&#x2F;不相等最后判断相等和不相等就很简单了，因为本身就是指针，我们直接调用原生的!=进行判断即可\nbool operator!=(const self&amp; it)&#123;    return _node != it._node;&#125;bool operator==(const self&amp; it)&#123;    return _node == it._node;&#125;\n\n到这里，一个建议版本的正向迭代器我们就实现啦！\n\n3.3.4 begin&#x2F;end这里我们需要在List的本类中获取迭代器的begin和end，这里我们是调用了迭代器的构造函数，构造出来一个迭代器并进行返回\nconst_iterator begin() const&#123;    //return _head-&gt;_next;//不能直接返回指针！！    return const_iterator(_head-&gt;_next);&#125;const_iterator end() const&#123;    return const_iterator(_head);&#125;iterator begin()&#123;    return iterator(_head-&gt;_next);&#125;iterator end()&#123;    return iterator(_head);&#125;\n\n现在就可以愉快的用迭代器进行打印操作了！\n\n\n3.4 构造函数有了迭代器，现在就可以完成库函数里面的几个构造函数了（主要是迭代器区间的那个函数）\n默认构造函数如下，先创建一个头节点，再让它的前后都指向自己。在C语言的初始化函数中，我们也是这么做的\nlist()   \t:_head(nullptr)   &#123;       //_head = new Node;       _head = new Node();       _head-&gt;_next = _head;       _head-&gt;_prev = _head;   &#125;\n\n但其他的构造函数由于_head为空，所以我们需要单独实现一个空初始化函数来创建头节点\n//当使用其他构造函数的时候，head还不存在，需要手动构造一个void empty_init()&#123;    _head = new Node();    _head-&gt;_next = _head;    _head-&gt;_prev = _head;&#125;\n\n当然，上面那个空的构造函数list()也可以复用empty_init()，这样代码更整洁\n迭代器区间构造和vector是一样的，其主要是解引用后直接将值进行头插（这里就用上了之前迭代器里重载的解引用操作）\ntemplate &lt;class InputIterator&gt;list(InputIterator first, InputIterator last)&#123;    empty_init();    InputIterator cur = first;    while (cur != last)    &#123;        //push_back(cur._node-&gt;_data);        push_back(*cur);        cur++;    &#125;&#125;\n\n而拷贝构造就可以直接复用迭代器区间构造，赋值重载就直接swap即可。这部分的实现和vector是一样的，有问题可以在评论区提出哦！\nvoid swap(list&lt;T&gt;&amp; lt)&#123;    std::swap(_head, lt._head);&#125;list(const list&lt;T&gt;&amp; lt)&#123;    empty_init();    list tmp(lt.begin(), lt.end());    swap(tmp);&#125;list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt)&#123;    //传参没有传引用，lt已经是拷贝构造之后的结果了    //完全没必要再用tmp拷贝构造一次    //list&lt;T&gt; tmp(lt);    //clear();//因为tmp出了生命周期后会销毁，所以不需要手动clear    swap(lt);    return *this;&#125;\n\n\n3.5 析构函数因为链表需要我们一个一个去删除每一个节点的空间，这里需要单独实现一个clear函数供析构函数使用\nvoid clear()&#123;    //assert(_head-&gt;_next != _head);    iterator it = begin();    while (it != end())    &#123;        //需要用一个临时变量储存该节点的迭代器，避免迭代器失效        iterator its = it;        it++;        delete its._node;    &#125;&#125;~list()&#123;    clear();    delete _head;&#125;\n\n上面这个函数就有些麻烦，我们其实可以直接复用erase进行删除操作+更新迭代器！\nvoid clear()&#123;    iterator it = begin();    while (it != end())    &#123;        it = erase(it);    &#125;&#125;\n\n到这里，一个基本的list就模拟实现完成了！\n3.6 操作自定义类型我们刚刚实现的list和STL库中的一样，都可以存放自定义类型\nstruct TA&#123;\tTA(int a1 = 0, int a2 = 0)\t\t:_a1(a1),\t\t_a2(a2)\t&#123;&#125;\tint _a1;\tint _a2;&#125;;void test03()&#123;\tlist&lt;TA&gt; lt;\tlt.push_back(TA(1, 1));\tlt.push_back(TA(2, 2));\tlt.push_back(TA(3, 3));\tlt.push_back(TA(4, 4));\t//这里因为TA类的流插入没有重载，所以需要我们手动写\tlist&lt;TA&gt;::iterator it = lt.begin();\twhile (it != lt.end())\t&#123;\t\tcout &lt;&lt; it-&gt;_a1 &lt;&lt; &quot;-&quot; &lt;&lt; it-&gt;_a2 &lt;&lt; &quot; &quot;;\t\t++it;\t&#125;\tcout &lt;&lt; endl;&#125;\n\n但在打印和访问自定义类型的时候，我们重载的解引用操作符就不能用了，这就是为啥要重载-&gt;操作符，此时我们还可以通过-&gt;获取到迭代器所指的对象的成员，这时候直接打印成员变量即可！\n\n你可能觉得，这不对啊！之前重载的这个操作符不是返回的节点_data的地址吗？为啥可以直接访问_data的成员？\nPtr operator-&gt;()&#123;    return &amp;(_node-&gt;_data);//返回地址&#125;\n\n实际上，这里应该是it-&gt;-&gt;_a1，但是编译器在处理的时候直接将两个访问箭头简化成了一个，即增加了代码可读性，也方便使用了！\n\n3.7 反向迭代器（适配问题）关于反向迭代器，这里牵扯到一个更深的适配问题。我用我的笨话稍微解释一下，有问题或者有啥错误的话欢迎在评论区提出！😂\n我们知道，反向迭代器是从后往前走的，它的加减操作和正向迭代器相反。\n那么比起单独实现一个反向迭代器的类，我们可否利用正向迭代器，直接适配出一个反向迭代器呢？毕竟看起来它们只有方向不同！\ntemplate&lt;class Iterator, class Ref, class Ptr&gt;struct Reverse_iterator&#123;\tIterator _it;\ttypedef Reverse_iterator&lt;Iterator, Ref, Ptr&gt; Self;              Reverse_iterator(Iterator it)\t\t:_it(it)\t&#123;&#125;   &#125;;\n\n说上就上，这里我们先将反向迭代器设定为和正向相似的结构，不过它的模板参数变成了正向迭代器，而不是参数类型T，这在后续typdef的时候需要注意（不然会报错）\n除了下面的解引用操作之外，其他只需要吧正向迭代器反过来用，就可以达到我们的目的！\nRef operator*()&#123;    Iterator tmp = _it;    return *(--tmp);//反向迭代器解引用访问的是前一个位置的数据&#125;Ptr operator-&gt;()&#123;    return &amp;(operator*());&#125;\n\n解引用访问前一个数据的原因是，我们判断结束是用!=rend()，而rend()指向的是列表的第一个有效数据，如果直接解引用当前内容，最后一个数据就无法访问到，出现了缺漏\n\n//前置++Self&amp; operator++()&#123;    --_it;    return *this;&#125;//前置--Self&amp; operator--()&#123;    ++_it;    return *this;&#125;bool operator!=(const Self&amp; s)&#123;    return _it != s._it;&#125;\n\n更加完整的源码可以去看我的Gitee仓库哦！\n\n完成了上面的代码后，我们需要在list本类里面进行一波操作，让它能够支持反向迭代器\n//支持反向迭代器typedef Reverse_iterator&lt;iterator, T&amp;, T*&gt; reverse_iterator;typedef Reverse_iterator&lt;const_iterator, const T&amp;, const T*&gt; const_reverse_iterator;\n\n注意上面的模板参数，第一个需要传入正向迭代器，而不是T\n//调用反向迭代器的构造函数reverse_iterator rbegin()&#123;    return reverse_iterator(end());&#125;reverse_iterator rend()&#123;    return reverse_iterator(begin());&#125;const_reverse_iterator rbegin()const&#123;    return const_reverse_iterator(end());&#125;const_reverse_iterator rend()const&#123;    return const_reverse_iterator(begin());&#125;\n\n用一个打印代码便可以测试出我们的操作是否正确！\n可以看到，完美逆向打印出了内容！\n\n利用正向迭代器进行适配的最大好处，那就是其他模拟实现的容器也可以直接调用这个反向迭代器，只要在本类中加入上面的typedef和4个函数即可！\n就以上篇博客的vector为例，加上上述代码后，她也能支持反向迭代器了！（源码也上传到仓库里面了）\n\n\n结语本次list的模拟实现，我们尝试模拟了一个更加详细的迭代器类，并实现了反向迭代器\n有任何问题，或者本博客有错误，都欢迎在评论区提出哦！\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】STL：stack/queue/priority_queue/deque","url":"/2022/07/18/code/note_cpp/13STL_stack_queue/","content":"来喽，STL的栈和队列！\n\n\n[TOC]\n1.Stack栈是一个遵循LIFO规则的容器，即后进先出（last in first out）。后放入容器内的数据会先出来。\n\n如果你不太理解栈的性质，可以先看看我写的C语言栈的博客【链接】\n\n打开Cplusplus一看，栈的函数肉眼可见的少。这和我们C语言实现的功能基本是一样的。\n\n它甚至没有拷贝构造！\n\n1.1 容器适配器等会，这个container是什么玩意？\n别急，先让我们来看看栈的类定义👇\nstd::stacktemplate &lt;class T, class Container = deque&lt;T&gt; &gt; class stack;\n\n和之前不同的是，这里出现了container，和一个我们好像没有接触过的deque\n搜索后得知，deque也是一种容器，被称为双端队列\n\n\n那么栈为什么需要一个容器呢？\n\n实际上，栈不是直接写出来的代码，而是借用了deque这个容器，进行封装后的结果。\n意思就是，栈其实是解用了别人的代码！\n比如deque有头插头删，尾插尾删。而我们的栈只需要尾插尾删，那么我们包装一下deque，只提供尾插尾删的函数，不就成了栈了？\n\n1.2 模拟实现直接这么说可能有点干巴巴，我们直接上代码！\ntemplate&lt;class T, class Container = deque&lt;T&gt;&gt;class stack &#123;public:\tsize_t size()const &#123;\t\treturn _con.size();\t&#125;\t\tconst T&amp; top() &#123;\t\treturn _con.back();\t&#125;\tvoid push(const T&amp; val) &#123;\t\t_con.push_back(val);\t&#125;\tvoid pop() &#123;\t\t_con.pop_back();\t&#125;\tbool empty() &#123;\t\treturn _con.empty();\t&#125;private:\tContainer _con;&#125;;\n\n以上便是栈的模拟实现代码！\nWhat？这就结束了？——甚至写的比我们C语言版本的栈更少！\n\n本质上，我们只需要创建一个Container的对象 _con，再借助这个对象的函数进行封装，就完成了一个栈！\n因为模板里面默认传入的是deque，所以这里用的便是deque的函数了。这就好比函数传入了一个缺省值。你可以将deque换成其他有尾插尾删函数的容器，比如vector\n测试一下，莫得问题！\n\n\n2.queue和栈不同，队列遵循FIFO，即先进先出（first in first out）\n\n同样的，我们只需要包装一下容器，即可完成模拟实现\nstd::queuetemplate &lt;class T, class Container = deque&lt;T&gt; &gt; class queue;\n\n2.1 模拟实现template&lt;class T, class Container = deque&lt;T&gt;&gt;class queue &#123;public:\tsize_t size()const&#123;\t\treturn _con.size();\t&#125;\tconst T&amp; front()&#123;\t\treturn _con.front();\t&#125;\tconst T&amp; back()&#123;\t\treturn _con.back();\t&#125;\tvoid push(const T&amp; val)&#123;\t\t_con.push_back(val);\t&#125;\tvoid pop()&#123;\t\t_con.pop_front();\t&#125;\tbool empty()&#123;\t\treturn _con.empty();\t&#125;private:\tContainer _con;&#125;;\n\n需要注意的是，队列就不能用vector来当作容器辣！因为vector头插删的效率很低，需要挪动数据。我们可以使用list来当作容器\n\n当然，你可以把头插头删改成insert和erase，但是那样没有意义，依旧拖慢了效率\n因为栈和队列压根不支持迭代器，自然也没有迭代器失效问题！\n2.2 关于queue的front学习linux课程的时候，突然想到一个问题，如果queue里面是空的，那么我直接访问front会是什么情况？会出现异常吗？\n#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123;    printf(&quot;hello vscode!\\n&quot;);    queue&lt;int&gt; q;//不会报错，但是数据无效    cout &lt;&lt; q.front() &lt;&lt; endl;    return 0;&#125;\n\n在linux下用g++编译运行，发现获取到的值是0\n[muxue@bt-7274:~/git/test]$ ./testhello vscode!0\n\n简单概括，如果队列中没有数据，此时调用front接口不会报错，但是获取到的数据是无效的。\n个人猜测，这里能否获取到数据也和编译器的优化有关。比如相同的代码，在vs2019下，会直接报assert错误！\n\n所以，为了代码的兼容性，请严格检查调用front的时候队列里面有没有数据，stack的top同理\n\n了解完相对简单的栈和队列之后，我们可以直接来看看优先级队列\n3.priority_queue 优先级队列优先级队列和queue同属于头文件&lt;queue&gt;\ntemplate &lt;class T, class Container = vector&lt;T&gt;,  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;\n\n\n那么它和普通的队列有什么不同呢？\n\n优先级队列是一个堆，且默认是大堆\n\n如果你不知道堆是什么，可以看看我之前C语言数据结构的博客【链接】\n\n简单说来，堆的堆顶（这里是第一个数据）一直保持着最大值或者最小值。每一次插入、删除操作，都需要向上、向下重新调整容器内元素的位置\n3.1 make_heap这里简单说一下另外一个函数make_heap，这个函数可以通过迭代器区间，将区间内的数据调整为一个堆。\n\n在文档介绍里面可以看到，最后一行提到了优先级队列就是自动调用make_heap函数来维护自己堆的属性的\n\n3.2 函数接口优先级队列本质上还是一个队列，它提供的函数也很少\n不同的是，这里的top堆顶指的是容器中首个元素，pop也是移除堆顶元素\n\n3.3 仿函数\n注意这里出现了第三个模板参数，Compare\n这是一个仿函数，其就是一个类，但是仿照了函数的调用方式\n想做到这一点，我们需要重载()操作符\n//仿函数，重载（）操作符\ttemplate&lt;class T&gt;\tstruct less &#123;\t\tbool operator()(const T&amp; a, const T&amp; b)const\t\t&#123;\t\t\treturn a &lt; b;\t\t&#125;\t&#125;;\t//大于比较\ttemplate&lt;class T&gt;\tstruct greater&#123;\t\tbool operator()(const T&amp; a, const T&amp; b)const\t\t&#123;\t\t\treturn a &gt; b;\t\t&#125;\t&#125;;\n\n比如这里的less和greater就是两个仿函数，优先级队列需要用它来进行比较。这样我们就可以快速在大堆和小堆直接进行切换。\n它们的使用方式和函数是一样的！不过在使用之前，我们需要先创建一个对象\nless func;func(1,2);\n\n库函数中的less和greater都在&lt;functional&gt;这个头文件中\n\n\nstd库中优先级队列默认传的less小于比较，为大堆！\n我们可以手动传入greater，即可变成小堆\n\n3.4 模拟实现在3.3中，我们已经实现出了库函数中的less和greater这两个仿函数，接下来我们只需要包装一下优先级队列的接口，即可使用！\ntemplate &lt;class T, class Container = vector&lt;T&gt;,class Compare = less&lt;T&gt; &gt;\tclass priority_queue\t&#123;\tpublic:\t\tsize_t size()const &#123;\t\t\treturn _con.size();\t\t&#125;\t\tconst T&amp; top() &#123;\t\t\treturn _con[0];\t\t&#125;\t\tbool empty() &#123;\t\t\treturn _con.empty();\t\t&#125;\t\t//向上调整\t\tvoid AdjustUp(size_t child)\t\t&#123;\t\t\tCompare comFunc;\t\t\twhile (child &gt; 0)\t\t\t&#123;\t\t\t\tsize_t parent = (child - 1) / 2;\t\t\t\tif (comFunc(_con[parent],_con[child]))//小堆，小的数据往上调\t\t\t\t&#123;\t\t\t\t\tstd::swap(_con[parent], _con[child]);\t\t\t\t\tchild = parent;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t//向下调整\t\tvoid AdjustDown(size_t parent)\t\t&#123;\t\t\tCompare comFunc;\t\t\tsize_t child = parent * 2 + 1;//左孩子\t\t\twhile (child &lt; _con.size())\t\t\t&#123;\t\t\t\t//找左右孩子中小的那一个\t\t\t\tif (child + 1 &lt; _con.size() &amp;&amp; comFunc(_con[child], _con[child + 1]))\t\t\t\t&#123;//如果左孩子大于右孩子，则选择右孩子\t\t\t\t\tchild++;\t\t\t\t&#125;\t\t\t\tif (comFunc(_con[parent],_con[child]))\t\t\t\t&#123;\t\t\t\t\tstd::swap(_con[parent], _con[child]);\t\t\t\t\tparent = child;\t\t\t\t\tchild = parent * 2 + 1;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t//因为是优先级队列，所以需要进行调整\t\t//默认情况下第一个元素始终是最大元素\t\tvoid push(const T&amp; val) \t\t&#123;\t\t\t_con.push_back(val);\t\t\tAdjustUp(_con.size() - 1);\t\t&#125;\t\tvoid pop() \t\t&#123;\t\t\tassert(!_con.empty());\t\t\tswap(_con[0], _con[_con.size() - 1]);\t\t\t_con.pop_back();\t\t\tAdjustDown(0);\t\t&#125;\t\t\tprivate:\t\tContainer _con;\t&#125;;\n\n这里需要注意的便是adjustdown/up这两个用来维持堆属性的调整函数，你可以看我之前的博客，里面有关于这部分的详细解释！回到上面\n先来测试一下默认大堆的属性\n\n可以看到，打印出来的数据是按从大到小顺序存放的！\n如果我们显示传入greatre仿函数，就会变成从小到大\n\n同时，即便我们pop了一部分数据，也不会影响堆的属性\n\n优先级队列在一部分地方可以用于帮我们找到一段数据中的topK和第n个最大&#x2F;小的数据\n比如下面这道leetcode OJ题目215. 数组中的第K个最大元素\n\n我们只需要pop掉前面的K-1个元素，这时候的堆顶就是我们需要的第K个最大值\n\n4.deque前面已经提到了deque这个容器，它拥有的库函数和vector很相似，这里我们不关注如何使用这个容器，而是来谈谈这个“双端队列”相比于vector/list有没有什么优势\nstd::dequetemplate &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque;\n\n4.1存储结构deque最特殊的就是它的存储结构了。它并不是一个连续的结构，也不像链表一样每个数据都有自己的单独节点\n这个是百度百科上找到的一张图片\n\n\nhttps://www.cnblogs.com/yifengs/p/15190416.html\n\n其实deque有点类似二维数组，其中有一个头指针指向队列头，一个尾指针指向队列尾部。主数组“中控器”存放的则是这些数组的指针。注：每一个数组的容量大小都是一样的，所以存放在中间的数组一定是满的！\n\n这样我们就避免了list节点分散，需要多次开空间，无法随机访问的缺陷；又可以灵活快速地进行头插头删操作，而不需要挪动数据。\n当然，deque的随机访问性能肯定不如数据连续存储的vector，其更适合下面的场景：\n\n需要高性能的头插头删，尾插尾删\n偶尔需要进行随机访问\n\n结语关于栈和队列的部分到这里就结束辣！\n我们还认识了双端队列deque，以及让其作为容器的模拟实现操作\n\n有任何问题，欢迎评论提出！\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】继承多态详解","url":"/2022/07/23/code/note_cpp/14%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/","content":"在之前的CPP大作业中，为了应付期末（是这样的）关于继承和多态部分的内容只是草草过了一遍，并没有深挖背后的实现原理，以及使用的时候一些注意事项。\n本篇博客是对类和对象继承多态部分的深化！\n\n\n[TOC]\n1.继承派生关系继承是提高代码复用性的一个重要手段。它允许我们在保持基类原有属性的基础上，对其进行一定的扩张，增加不同的功能以应对实际情况。\n与其相似的增加代码复用性的语法，还有模板\n1.1 基本用法继承和派生是父与子的关系，其中子类拥有父类成员的同时，还会拥有自己的成员\n\n继承是一个特殊的语法，用于多个类有公共部分的时候\n父类：基类\n子类：派生类\n\n//举例：网站的公共部分class ART &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;网站访问量&quot; &lt;&lt; endl;\t&#125;\tvoid func()//文章页面\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; endl;\t&#125;&#125;;class LINK &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们 &quot; &lt;&lt; &quot; 网站访问量&quot; &lt;&lt;endl;\t&#125;\tvoid func()//友链页面\t&#123;\t\tcout &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n在上面的情况中，ART和LINK类中都有网站的公共部分，这时候就出现了代码的重复。继承的出现就是用于解决这个问题的\n//下面使用继承的方式来写，WEB类是网站的公共部分class WEB &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;网站访问量&quot; &lt;&lt; endl;\t&#125;&#125;;//ART、LINK是两个子类，继承了WEB的公共部分//这样就减少了代码量class ART : public WEB&#123;public:\tvoid func()//文章页面\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; endl;\t&#125;&#125;;class LINK : public WEB &#123;public:\tvoid func()//友链页面\t&#123;\t\tcout &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n测试可以发现，ART和LINK作为派生类，在继承了基类WEB的成员的基础上，还拥有了它们独特的单独成员\n\n同一个类可以同时继承多个基类\nclass C : public A,public B&#123;//.....&#125;;\n\n1.2 权限问题继承有3中类型：public、private、protected。这里会显示出类中protected权限和private权限的区别\nclass A&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\n当我们分别用上面三种方式对类A进行继承的时候，得到的结果是不同的\n\n用什么继承方式，派生类中继承的成员就变成什么类型\n不管用什么继承方式，都无法访问基类中的私有成员\n\n\n关于权限问题，我们还需要了解下面几点：\n\n基类的私有成员在派生类中不可见，但实际上它也被继承过去了。但是编译器和语法的限制让我们无法访问。\n保护限定符由此出现，如果在基类中的成员不想被外界直接访问，则可以定义为保护\nclass默认继承方式为私有，struct默认继承方式为保护\n实际中我们一般使用public继承，保护&#x2F;私有方式不利于维护和拓展\n\n1.3 同名问题（作用域）在继承体系中，基类和子类都有自己独立的作用域\n当基类和派生类中出现同名成员函数或者同名成员变量时，会出现冲突。这时候编译器会做一定的处理：直接访问变量名和函数名的时候，优先访问派生类自己的成员，而屏蔽掉基类的。\n这种情况被称之为隐藏：\n\n函数名相同构成隐藏（并非重载）\n成员变量名相同构成隐藏\n\n//继承同名成员的处理//\t普通的同名成员class DAD1 &#123;public:\tDAD1()\t&#123;\t\t_a = 100;\t&#125;\tvoid func()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;DAD func&quot; &lt;&lt; endl;\t&#125;\tvoid func(int i)\t&#123;\t\tcout &lt;&lt; &quot;DAD func int: &quot; &lt;&lt; i &lt;&lt; endl;\t&#125;\tint _a;//基类中的该变量&#125;;class SON1 : public DAD1&#123;public:\tSON1()\t&#123;\t\t_a = 20;\t&#125;\tvoid Print()\t&#123;\t\tcout &lt;&lt;&quot;SON: &quot; &lt;&lt; _a &lt;&lt; endl;//优先访问派生类的_a\t\tcout &lt;&lt;&quot;DAD: &quot; &lt;&lt; DAD1::_a &lt;&lt; endl;//访问基类的_a\t&#125;\tvoid func()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;SON func&quot; &lt;&lt; endl;\t&#125;\tint _a;//派生类的同名变量&#125;;\n\n\n实际操作中，不建议写同名的成员\n1.4 静态成员在继承体系中，基类的静态成员有且只能有一个。即所有的子类和他们的对象，都是只有那一个静态成员的。我们可以用这个特性来对继承派生中出现的对象进行计数。\nclass Person&#123;public :\tPerson () &#123;++ _count ;&#125;protected :\tstring _name ; // 姓名public :\tstatic int _count; // 统计人的个数。&#125;;int Person :: _count = 0;\n\n如果出现了与静态成员同名，访问方法就有所变化\n//访问同名的静态成员class DAD2&#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1 &quot; &lt;&lt; endl;\t&#125;\tstatic void Test1(int n)\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1(int)  &quot; &lt;&lt; n &lt;&lt; endl;\t&#125;&#125;;int DAD2::D_a = 100;class SON2 : public DAD2 &#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;SON2 Test1 &quot; &lt;&lt; endl;\t&#125;&#125;;int SON2::D_a = 200;\n\n\n1.5 友元友元关系不会被继承，基类的友元函数无法访问派生类的私有/保护成员\n\n1.6 默认成员函数我们知道，C++类和对象中有6个默认成员函数\n\n在派生类中，这些默认成员函数有新的使用方法\n\n派生类的构造函数必须在初始化列表中调用基类的构造函数，初始化父类的一部分成员。如果你没有写，编译器会自动调用默认构造函数（先调用基类，在调用子类）\n派生类的拷贝构造同上，必须显式调用基类拷贝构造函数\n派生类的赋值重载也需要调用基类赋值重载完成操作\n派生类的析构函数编译器会自动调用基类，先析构派生类，再析构基类成员（符合栈后进先出原则）\n在基类析构函数不是虚析构的时候，子类析构和父类析构构成隐藏关系\n\n\n构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数\n\n继承中先调用父类构造函数\n再调用子类构造函数\n\n析构顺序与构造相反\n显示调用构造函数如何显示调用构造函数呢，下面是一个代码示例\n#include &lt;iostream&gt;using namespace std;class Person&#123;public:    Person(string name, string sex, int age)    &#123;        _name = name;        _sex = sex;        _age = age;    &#125;protected:    string _name;    string _sex;    int _age;&#125;;class Student : public Person&#123;public:    Student(string name,string sex,int age,int no)        :Person(name,sex,age),        _No(no)    &#123;&#125;    int _No;//学号&#125;;int  main()&#123;    Student sobj(&quot;李华&quot;,&quot;男&quot;,18,1000);&#125;\n\n运行结果如下，可见子类正常调用了基类构造函数并进行了初始化\n\n1.7 基类和派生类赋值问题派生类成员可以赋值给基类的 对象&#x2F;指针&#x2F;引用。一般我们把这种情况称为切片，形象地表示把派生类中父类那部分切来赋值过去。\n但是！反过来是不行的哦，你不能把基类对象赋值给派生类对象。\n\n基类的指针&#x2F;引用可以用强制类型转换给基类的指针&#x2F;引用。但是这样不够安全，除非基类的指针指向的是对应的派生类。\n如果基类是多态类型，可以使用dynamic_cast来进行安全处理\n\n#include &lt;iostream&gt;using namespace std;class Person&#123;protected :    string _name;    string _sex;     int _age;&#125;;class Student : public Person&#123;public :    int _No ;//学号&#125;;int  main()&#123;    Student sobj ;    // 1.子类对象可以赋值给父类对象/指针/引用    Person pobj = sobj ;    Person* p1 = &amp;sobj;    Person&amp; p2 = sobj;           //2.基类对象不能赋值给派生类对象    //sobj = pobj;//err        // 3.基类的指针可以通过强制类型转换赋值给派生类的指针    p1 = &amp;sobj;//子类对象给基类指针    Student* ps1 = (Student*)p1; //基类指针指向子类，正常转换    ps1-&gt;_No = 15;     cout&lt;&lt;ps1-&gt;_No &lt;&lt;endl;    p1 = &amp;pobj;//基类对象给基类指针    Student* ps2 = (Student*)p1; //转换虽然可以，但是会存在越界访问    ps2-&gt;_No = 10;    cout&lt;&lt;ps2-&gt;_No &lt;&lt;endl;    return 0;&#125;\n\n\n关于最后提到的越界访问问题，我们知道，指针变量的大小都是相同的，其指针类型的区别主要在访问能力的不同。比如char*指针解引用只能访问1个字节，int*指针解引用可以访问4个字节，以此类推，Student*指针解引用可以访问sizeof(Student)个字节的空间。\n而子类对象的大小都是大于等于基类对象的大小的。这就导致子类指针访问基类对象内容时，一次解引用访问的空间超长，造成了越界访问\n\n实际上，当我们切片讲子类对象赋值给父类对象的时候，编译器会进行切片操作，即新的父类对象中的内容只会包含父类的成员。子类多出去的那一部分成员会被剔除。\n这一点我们可以在VS的调试中证实\n\n因为基类的成员变量被设置成了保护，所以我们不能直接在外部进行修改。需要显式调用基类的构造函数\n1.8 虚继承（菱形继承问题）有的时候，继承会出现下面这种情况：一个子类继承了两个基类，而这两个基类又同时是一个基类的派生类\n\n这时候，D里面就会有两份A的内容，相当于两份公共部分。这是我们不想看到的，因为会造成空间浪费。而且直接访问的时候，编译器会报错“对变量X的访问不明确”\n\n比如：intel和amd联合推出的NUC小电脑中，有一款CPU是他们合作开发的\n如何解决同时继承AMD和INTEL的问题？\n\n这时候会出现两个同名变量，一个是AMD里面有的，另外一个是INTEL里面有的因为他们是从CPU里面继承来的。\n虽然我们可以指定作用域来分别修改和访问。但是实际上这个公共部分就出现了浪费（比如是网站的公共部分，多给你一份没有啥意义）\n\n\n和前面说道的同名问题一样，我们可以指定作用域来访问特定的变量，但是这样是治标不治本的方法，并没有解决空间浪费的问题。\n//解决方法1（治表不治本）//用类域来修改和访问cout &lt;&lt; &quot;intel: &quot; &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;cout &lt;&lt; &quot;amd: &quot;   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;\n\n这就需要我们使用虚继承来操作：给B和C对A的继承加上virtural关键字\nclass CPU &#123;public:\tCPU()\t\t:_Structure(&quot;x86&quot;)\t&#123; &#125;\tchar _Structure[100];&#125;;class INTEL : virtual public CPU &#123;public:\tINTEL()\t\t:i_Brand(&quot;intel&quot;)\t&#123;&#125;\tchar i_Brand[10];&#125;;class AMD : virtual public CPU &#123;public:\tAMD()\t\t:a_Brand(&quot;amd&quot;)\t&#123;&#125;\tchar a_Brand[10];&#125;;//同时继承AMD和INTEL//相当于有两个_Structure变量//实际上我们只需要一个就够了class NUC :public AMD, public INTEL &#123;&#125;;void test1()&#123;\tNUC n1;\t//对“_Structure”的访问不明确\t//cout &lt;&lt; n1._Structure &lt;&lt; endl;//err\t//解决方法1（治表不治本）\t//用类域来修改和访问\tcout &lt;&lt; &quot;intel: &quot; &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;\tcout &lt;&lt; &quot;amd: &quot;   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;\t//解决方法2，在AMD和INTEL对CPU的继承上加virtual\tcout &lt;&lt; &quot;n1访问：&quot; &lt;&lt; n1._Structure &lt;&lt; endl;\t//现在就没有报错了\t//因为这时候AMD和INTEL中的_Structure都会指向同一个地址\tcout &lt;&lt; &quot;&amp;intel: &quot; &lt;&lt; &amp;(n1.INTEL::_Structure) &lt;&lt; endl;\tcout &lt;&lt; &quot;&amp;amd:   &quot; &lt;&lt; &amp;(n1.AMD::_Structure) &lt;&lt; endl;\t//修改INTEL中的_Structure，也会连代修改AMD中的_Structure&#125;\n\n这时候直接访问变量就不会报错了。因为这时候，B和C中的该变量指向了同一个地址，修改操作会同步。\n\n继承模型这种虚继承的模型是什么样子的呢？进入调试窗口，可以看到这里分别分为了3个模块，保存了不同基类的成员。而它们之中的_Stucture成员只有一个，不会出现异义\n\n那这里空着的空间是用来做什么的呢？是内存对齐吗？\n非也！\n虚基表下图能帮你了解这个内存的区块是怎么划分的\n\n这样做就有一个好处，即便我们使用不同的基类指针（比如amd或者intel）来指向nuc的子类对象，它们都可以通过虚基表里面存放的偏移量来计算CPU成员的位置。从而避免了出现异义的问题。\n\n而如果我们在继承的时候去掉virtual关键字，即使用普通继承，它的继承模型又会不同\n\n这里就因为内存对齐的问题，我们无法看清楚它的全貌。不过在菱形继承问题中，不使用虚继承会造成两个CPU对象的继承，导致访问不明确的特性是可以看出来的。\n1.9 继承和组合\n继承：上述所说。每一个派生类对象都是一个基类对象is-a\n组合：在一个类里面包含另外一个类的对象成员。每一个B对象中都包含了一个A has-a\n\n实际情况中，建议优先选择组合，而不是继承。\n\n继承增加了代码的复用性，但是在一定程度上破坏了基类的封装性。派生类和基类的关联很强，耦合度高。\n对象组合是另外一种复用的选择，这时候，对象A的内部结构是不得而知的。这样就减小了对象之间的关联性，耦合度低，保护了封装，更方便代码的维护\n\n不过，继承还有另外一种用途，那就是多态。我们下边会讲解的！\n总结多继承所导致的菱形继承问题，在一定程度上让C++的语法变得复杂了。比如java是没有多继承的。在实际使用情况中，不建议使用多继承。\n\n2.多态\n静态多态：运算符重载\n动态多态：派生类和虚函数组成的多态\n\n多态通俗地讲就是多种形态，当不同的对象去完成相同的事情的时候，会产生不同的状态。\n2.1 虚函数2.1.1 基本使用以及动态多态虚函数，并不代表这个函数是虚无的。而表示这个函数在一定情况下会被替换（就好比继承中的虚继承问题）。要实现动态多态，就需要借助虚函数来实现。以下面这个动物说话的代码为例\n#include &lt;iostream&gt;using namespace std;class Animal &#123;public:\t//void Talk()\tvirtual void Talk()//虚函数\t&#123;\t\tcout &lt;&lt; &quot;Animal is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class CAT : public Animal&#123;public:\tvoid Talk()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;CAT is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class DOG : public Animal &#123;public:\tvoid Talk()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;DOG is talking&quot; &lt;&lt; endl;\t&#125;&#125;;//基类中不使用虚函数时，该函数的内容已确定//不管传参什么类，都会调用Animal自己的Talk函数//加上虚函数virtual后，会调用CAT和DOG的Talk函数void MakeTalk(Animal&amp; it) &#123;\tit.Talk();//调用对应的Talk函数&#125;\n\n当基类Animal中的Talk函数没有用virtual修饰时，不管给这个函数传参什么类的对象，它都会调用Animal自己的Talk函数\n\n当我们用虚函数进行修饰后，就会调用派生类CAT和DOG的Talk函数，这就实现了一个简单的动态多态。\n\n对于虚函数，有几点需要注意：\n\n当基类的指针或引用指向派生类的对象时，就会触发动态多态，派生类中的同名函数会覆写基类中的虚函数\n不能定义静态虚函数——因为静态函数是属于整个类的，而不是属于某一个对象\n不能定义虚构造函数——总不能用派生类的构造来覆写基类的构造吧？\n析构函数可以是虚函数\n\n2.1.2 虚析构函数有的时候，我们需要析构一个对象时，往往会给基类的析构函数加上virtual修饰，这样只要传派生类的对象给基类的指针&#x2F;引用，就可以直接调用派生类对应的析构函数，完成不同的析构操作。而不是都呆呆的调用基类的析构函数——那样就会产生内存泄漏\nclass Queue &#123;public:\tQueue()\t\t:_a(new int[10])\t&#123;\t&#125;\tvirtual ~Queue() &#123;\t\tcout &lt;&lt; &quot;~Queue&quot; &lt;&lt; endl;\t\tdelete[] _a;\t&#125;private:\tint* _a;&#125;;class MyStack :public Queue &#123;public:\tMyStack(int capa)\t\t:_a1(new int[capa])\t&#123;&#125;\t~MyStack() &#123;\t\tcout &lt;&lt; &quot;~MyStack&quot; &lt;&lt; endl;\t\tdelete[] _a1;\t&#125;private:\tint* _a1;&#125;;int main()&#123;\tQueue* q1=new MyStack(4);//父类指针指向子类\tdelete q1;//调用子类的析构函数\treturn 0;&#125;\n\n2.2 纯虚函数在虚函数的基础上，C++定义了纯虚函数：有些时候，在基类里面定义某一个函数是没有意义的，这时候我们可以把它定义为纯虚函数，具体的实现让派生类去同名覆写。\n纯虚函数的基本形式如下\n//virtual 函数返回类型 函数名()=0;virtual void Print()=0;\n\n派生类中必须重写基类的纯虚函数，否则该类也是抽象类\nclass A &#123;public:\t//virtual void Print();//虚函数\tvirtual void Print() = 0;//纯虚函数&#125;;class B :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;B print &quot; &lt;&lt; endl;\t&#125;&#125;;class C :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;C print &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n当我们在派生类中覆写了该函数后，即可实例化对象并调用该函数\n\n和虚函数一样，使用基类的引用或指针来接收派生类的对象，即可调用对应的函数\n\n2.3 抽象类包含纯虚函数的类就是抽象类，抽象类有下面几个特点：\n\n抽象类无法实例化对象\n抽象类的派生类必须重写基类的纯虚函数，不然派生类也是抽象类\n如果在基类中定义的纯虚函数是const修饰的，则派生类中对应的函数也需要用const修饰\n\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】搜索二叉树/KVL树","url":"/2022/08/01/code/note_cpp/15%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E9%98%B6/","content":"暑假已经过去一半了，你的作业写的怎么样了？\n不八八这些没啥用的了，本篇博客让我们来认识一下搜索二叉树以及KVL树，也为后续学习map和set打下基础。\n\n\n\n在之前，我写过一篇用C语言实现的二叉树博客。如果你想了解二叉树的基本定义，可以看看👉 【传送门】\n\n[TOC]\n前言树是我们生活中非常常见的玩意，其特点便是从下而上有非常多的分叉\n\n\n数据结构中的树便是以该特点命名的，每一个节点会有左右两个分叉来链接左右子树，从而构成一种数据结构。\n1.搜索二叉树所谓搜索二叉树（二叉查找树），便是致力于方便搜索的一种数据结构，其具有一下特点：\n\n比该节点大的数存放在右边\n比该节点小的数存放在左边\n\n这样当我们去遍历一颗搜索二叉树的时候，就可以很方便的通过大小比较找到其内部是否包含我们需要搜索的节点。这样在理想状态下，搜索的时间复杂度能控制在O(logN)，还是非常快的一个搜索算法！\n因为搜索二叉树主要用于搜索而不是存储数据，所以一般情况下的搜索二叉树是不允许数据冗余的。即相同的值只会存储一次\n\n同时，搜索二叉树可作为排序算法的一种。当我们用中序遍历搜索二叉树，得到的结果是有序的\n\n\n1.1 基本构建想要构建一个搜索二叉树，首先我们需要一个树的节点的结构\ntemplate&lt;class K&gt;struct BSTreeNode&#123;public:\tBSTreeNode* _left;\tBSTreeNode* _right;\tK _key;//元素\tBSTreeNode(K key)\t\t:_left(nullptr),\t\t_right(nullptr),\t\t_key(key)\t&#123;&#125;&#125;;\n\n\n为何不直接把这个结构定义在二叉树的class里面？\n因为那样会产生数据冗余而且非常不方便调用成员函数\n\n在搜索二叉树的功能实现类中，我们只需要定义一个根部节点即可\ntemplate&lt;class K&gt;class BSTree&#123;typedef BSTreeNode&lt;K&gt; Node;//方便使用private:    //成员变量\tNode* _root=nullptr;&#125;\n\n\n1.2 插入有了基本结构以后，我们就可以写一个插入函数来进行最基本的操作了\n\n当root为空的时候，需要给根节点开一个空间\nroot不为空，定义prev和cur两个指针进行遍历，通过大小判断来找寻正确的插入位置（左边小，右边大）\n找到正确位置后，构造新节点并进行插入操作\n\n使用bool作为返回值是因为我们需要判断是否成功插入。如果成功插入了为true，没有成功插入代表该搜索二叉树内已经包含了相同键值的节点。\nbool Insert(K key)&#123;    if (_root == nullptr)    &#123;        _root = new Node(key);//根为空，直接开空间插入        return true;    &#125;    Node* prev = nullptr;    Node* cur = _root;    while (cur)    &#123;        if (key &gt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_right;        &#125;        else if (key &lt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_left;        &#125;        else        &#123;            return false;//有相同元素不执行插入        &#125;    &#125;\t//创建节点进行插入    cur = new Node(key);    //保存prev指针就是为了操控它的父亲来链接节点    if (key &gt; prev-&gt;_key) &#123;        prev-&gt;_right = cur;    &#125;    else&#123;        prev-&gt;_left = cur;    &#125;    return true;&#125;\n\n除了循环版本，我们还可以写一个递归版本\nbool InsertR(const K&amp; key)//实际调用的函数&#123;    return _InsertR(_root, key);&#125;\t//使用引用，这时候的root就是上一个节点的左右子树的别名//修改root的同时也会修改上一个子树的左右节点//也可以用二级指针来完成这个操作，原理相同bool _InsertR(Node*&amp; root, const K&amp; key)&#123;    //空代表走到叶子了，执行插入    if (root == nullptr) &#123;        Node* newNode = new Node(key);        root = newNode;        return true;    &#125;    if (key &gt; root-&gt;_key) &#123;        _InsertR(root-&gt;_right, key);    &#125;    else if (key &lt; root-&gt;_key) &#123;        _InsertR(root-&gt;_left, key);    &#125;    else &#123;        return false;//不插入相同值    &#125;&#125;\n\n此类二叉树的递归思路最好用画图来理清。需要明白每一个节点是怎么返回的\n\n关于分支递归思想可以看看【链接】，这有助于你理解本文中的递归实现\n\n上面的递归问题便是将原本利用循环进行左右寻找的操作化为往下调用下一课子树。简单来来说就是老师要班长、班长找小组长、小组长找组员这样分配工作。\n只有走到最后的组员（空节点）我们才执行插入操作\n1.3 中序打印插入完成了，要怎样才能看到节点中的内容呢？来个中序遍历吧！\n我们需要重写一个递归函数，因为在类外面无法访问到私有成员root，无法直接给该函数传参。如果想维持类的封装性，也可以把这个函数定义为private成员\n    void InOrder()//中序遍历    &#123;        _InOrder(_root);    &#125;//private:    void _InOrder(Node* root)    &#123; //递归打印        if (root == nullptr)            return ;        _InOrder(root-&gt;_left);        cout &lt;&lt; root-&gt;_key &lt;&lt; &quot; &quot;;        _InOrder(root-&gt;_right);    &#125;\n\n关于前中后序遍历的内容在之前C语言的博客中有过讲解，这里就不再赘述\n\n\n1.4 查找既然是搜索二叉树，那便必须要有查找函数。\n其实在插入操作中，我们便已经把查找函数的思路写出来了（即判断是否是重复节点）\n//搜索二叉树一般不直接操作节点，不需要返回节点的指针//Node* Find(const K&amp; key)bool Find(const K&amp; key)&#123;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (key &gt; cur-&gt;_key)\t\t&#123;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (key &lt; cur-&gt;_key)\t\t&#123;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn true;\t\t&#125;\t&#125;\treturn false;&#125;\n\n同样，也可以写一个递归版本。当节点的值相等时返回true，如果走到空了代表这棵树里面没有这个节点，返回false\nbool FindR(const K&amp; key)//实际调用的函数&#123;    return _FindR(_root, key);&#125;//递归实现bool _FindR(Node* root, const K&amp; key)&#123;    if (root == nullptr) &#123;        return false;    &#125;    if (key &gt; root-&gt;_key) &#123;        _FindR(root-&gt;_right, key);    &#125;    else if (key &lt; root-&gt;_key) &#123;        _FindR(root-&gt;_left, key);    &#125;    else &#123;        return true;    &#125;&#125;\n\n1.5 删除(较难)在搜索二叉树中删除节点并没有那么容易，因为我们需要保证删除节点后，树还满足搜索二叉树的特征。如果删除了之后破坏树的结构还不管他，那就是err了。\n以下面的这棵树为例，它满足搜索二叉树的基本特征\n\n\n假设我们需要删除节点4，这很容易，只需要让3的右子树为空，再delete掉4的节点即可。\n但如果我们想删除6，事情就没那么简单了。我们需要找一个节点，来替补它的位置\n\n那么，谁可以胜任这个新的位置呢？\n答：左子树的最大节点or右子树的最小节点\n\n在删除6的情况下，左子树的最大节点为4，右子树的最小节点为7。你会发现，将它们换上这个位置，的确满足搜索二叉树的特性\n\n那么，怎么可以把这两个节点给替换上来呢？\n这一套操作其实挺麻烦的\n\n先找到需要删除的节点，会有下面3种情况：\n该节点只有左娃\n该节点只有右娃\n该节点左右都有\n\n\n如果是前两种情况（包括没有孩子的情况），我们只需要删除这个节点之后，让它的父亲指向它的孩子就行了（托管）\n只有左娃，父节点托管左娃\n只有右娃，父节点托管右娃\n\n\n左右都有孩子，需要找到左子树最大节点&#x2F;右子树最小节点，进行交换\n\n只是交换还远远不够，我们还需要链接这个最大&#x2F;最小节点的孩子（比如上图中7的情况）再删除掉被交换过去的指定节点\n\n//删除去找左子树的最大节点，或者右子树的最小节点//与需要删除的树进行交换，交换之后删除叶子节点bool Erase(const K&amp; key)&#123;    Node* prev = nullptr;    Node* cur = _root;    while (cur)    &#123;        if (key &gt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_right;        &#125;        else if (key &lt; cur-&gt;_key)        &#123;            prev = cur;            cur = cur-&gt;_left;        &#125;        else        &#123;            if (cur-&gt;_left == nullptr)//只有右娃            &#123;                if (cur == _root)                &#123;                    _root = _root-&gt;_right;                &#125;                else                &#123;                    if (prev-&gt;_left == cur)                    &#123;                        prev-&gt;_left = cur-&gt;_right;                    &#125;                    else &#123;                        prev-&gt;_right = cur-&gt;_right;                    &#125;                &#125;                delete cur;            &#125;            else if (cur-&gt;_right == nullptr)//只有左娃            &#123;                if (cur == _root)                &#123;                    _root = _root-&gt;_left;                &#125;                else                &#123;                    if (prev-&gt;_left == cur)                    &#123;                        prev-&gt;_left = cur-&gt;_left;                    &#125;                    else &#123;                        prev-&gt;_right = cur-&gt;_left;                    &#125;                &#125;                delete cur;            &#125;            else //左右都有孩子            &#123;                //将cur和右子树的最小值节点进行交换                Node* minPrev = cur;                Node* minRight = cur-&gt;_right;                while (minRight-&gt;_left)                &#123;                    minPrev = minRight;                    minRight = minRight-&gt;_left;                &#125;                swap(minRight-&gt;_key, cur-&gt;_key);                if (minPrev-&gt;_left == minRight)                &#123;                    minPrev-&gt;_left = minRight-&gt;_left;                &#125;                else &#123;                    minPrev-&gt;_right = minRight-&gt;_left;                &#125;                delete minRight;            &#125;            return true;        &#125;    &#125;    return false;&#125;\n\n执行之后可以看到，删除之后的树依旧是一个搜索二叉树，中序遍历结果呈有序\n\n递归删除写完了循环版本，再来个递归吧！\nbool _EraseR(Node*&amp; root, const K&amp; key)&#123;    //根直接为空，返回false    if (root == nullptr) &#123;        return false;    &#125;    if (key &gt; root-&gt;_key) &#123;        _EraseR(root-&gt;_right, key);    &#125;    else if (key &lt; root-&gt;_key) &#123;        _EraseR(root-&gt;_left, key);    &#125;    else     &#123;        Node* del = root;//保存变量用于删除        if (root-&gt;_left == nullptr)//只有右娃        &#123;            /*if (root == _root) &#123;\t\t\t\t\t_root = _root-&gt;_left;\t\t\t\t&#125;*/            //这时候root是操作节点的别名，不需要单独对根节点进行处理            root = root-&gt;_right;        &#125;        else if (root-&gt;_right == nullptr)        &#123;            root = root-&gt;_left;        &#125;        else //左右都有孩子        &#123;            //将cur和右子树的最小值节点进行交换            Node* minRight = root-&gt;_right;            //while (minRight) //err            while (minRight-&gt;_left) //判断的是left，不然会走到空然后交换            &#123;                minRight = minRight-&gt;_left;            &#125;            swap(minRight-&gt;_key, root-&gt;_key);            return _EraseR(root-&gt;_right, key);        &#125;        delete del;        return true;    &#125;&#125;\n\n在最后一个情况中，我们巧妙地将问题化为了在指定节点的右子再次执行一次删除操作\n\n为什么在递归的操作中我们不需要单独处理minPrev呢？\n注意看函数的接口。删除的递归操作需要才用一个很巧妙的做法，使用了引用参数，充分利用了函数传值时传引用的特点（别名）\nbool _EraseR(Node*&amp; root, const K&amp; key)\n\n这时候的节点root不仅是当前递归到的节点，同时也是上一个节点的左右节点的别名。对该节点的操作会直接改变上一个节点的左右子树，就省去了我们手动操作的步骤！\n\n对root的修改会直接同步道上一个节点的孩子上\n\n怎么样，是不是超级赞！\n\n2.KVL树2.1 概念KV指代的是两个模板参数key和value。其实现和上面的搜索二叉树完全相同，只需要修改一下模板参数，以及所有操作key的位置都需要添加第二个参数value。\n\n源码实现见我的代码仓库 链接\n\n这么做的好处是，我们可以给一个key添加第二个绑定的参数了。一般把这种绑定关系称为&lt;Key,Value&gt;键值对\nKVL树的特点如下：\n\n排序依据key来排序，而不是value\nkey不可以修改，但是value可以修改\n在保存键值关系的同时，去重+排序\n\n通过这两个参数的绑定关系，我们可以实现类似字典、水果出现次数等等问题的查找操作，有点类似于数组映射，但这种方法更加便捷\n\n2.2 示例插入4个水果和其数量，中序遍历打印后，可以看到数据是以key为排序标准的。\n这里说明的是，string也是可以比较大小的，所以同样适用于搜索二叉树\n\n通过这种类似的绑定关系，我们甚至可以添加更多参数进入搜索二叉树。可以完成类似学生管理系统/车牌管理系统中学号车牌号和用户的绑定关系\n2.3 允许数据冗余我们可以简单修改一下插入函数，来达到允许数据冗余的目的。即插入相同key的时候，判断value，如果value也是相同则不插入，不同则插入。这样可以让kvl树中同一个key有多种对应关系，在字典多义词的时候有一定作用\n//插入，通过传引用避免拷贝bool _InsertR(Node*&amp; root, const K&amp; key, const V&amp; value)&#123;    if (root == nullptr)    &#123;        root = new Node(key, value);        return true;    &#125;    if (root-&gt;_key &lt; key)        return _InsertR(root-&gt;_right, key, value);    else if (root-&gt;_key &gt; key)        return _InsertR(root-&gt;_left, key, value);    else&#123;        if (root-&gt;_value == value)            return false;        else&#123;            //将相同数据插入在右边            return _InsertR(root-&gt;_right, key, value);        &#125;    &#125;&#125;\n\n插入了之后，我们删除也需要删除两次。\n\n这时候我们EraseR返回值为bool的价值就体现出来了，我们可以直接写一个循环来删除掉多个冗余键值\n\n\n结语这两颗树的讲解到这里就结束啦，学习它们是为了后续学习map/set打基础哦！\n\n有什么问题欢迎在评论区提出！\n\n","categories":["遇见C++"],"tags":["C++","数据结构","树"]},{"title":"【C++】AVL树（平衡搜索二叉树）","url":"/2022/09/02/code/note_cpp/16AVL%E6%A0%91/","content":"在上一篇C++博客中，讲述了关于搜索二叉树以及KVL树的实现。也提到了搜索二叉树的最坏情况：插入的数据已经有序。\n而本篇博客涉及到的AVL树，又称平衡搜索二叉树。就是为了解决搜索二叉树的最坏情况而生的。\n\n\n[TOC]\n1. 什么是AVL树二叉搜索树虽然缩短了查找的效率，但是数据有序的时候，就会出现一边非常长的情况，导致原本的O(logN)时间复杂度被迫变成了O(N)\n平衡树也是搜索二叉树，其引入了一个平衡因子的概念，用于控制搜索二叉树的平衡。它会保证左右子树的高度之差（绝对值）不超过1。当新插入节点导致高度之差超过1时，便会触发旋转，使得树的高度降低。\n\n简单说来：AVL树能保证两边高度的相对平衡，这样就稳定了二叉搜索树的效率\n\n1.1 二叉搜索树的性质一颗AVL树或空树，其有以下性质\n\n它的左右子树是AVL树\n左右子树的高度之差的绝对值不超过1\n\n这里引入平衡因子来方便我们控制二叉树的高度。每一个节点都会有一个平衡因子，它的值是1/0/-1。如果平衡因子的值超过了1，那么说明这个节点的子树已经不平衡，需要进行旋转。\n\n实际上，AVL树不一定非要用平衡因子。我们可以用计算树的高度的方式来确认平衡因子，但是这样需要遍历左右子树，时间复杂度较高\n\n2. 实现一颗AVL树2.1 AVL树的节点基本的概念理解之后，我们需要设计出一个节点的结构来。关于各个值的含义，可以参考下方的注释\n\n平衡搜索二叉树是一个“三叉链”。这代表每一个节点都有左右孩子，还有一个prev指针指向它的父节点。为了标识树是否平衡，准确来说是某个节点的左右子树是否平衡。我们需要引入一个“平衡因子”来进行判断，方便我们控制平衡\n\n左右子树高度相同  0\n左子树高于右子树  -1\n右子树高于左子树  1\n\n\ntemplate&lt;class K,class V&gt;struct AVLTreeNode&#123;\tpair&lt;K, V&gt; _kv;//键值对\tAVLTreeNode&lt;K, V&gt;* _left;//左子树\tAVLTreeNode&lt;K, V&gt;* _right;//右子树\tAVLTreeNode&lt;K, V&gt;* _parent;//父节点\t// 右子树-左子树的高度差\tint _bf;  // 平衡因子\tAVLTreeNode(const pair&lt;K, V&gt;&amp; kv)\t\t:_kv(kv),\t\t_left(nullptr),\t\t_right(nullptr),\t\t_parent(nullptr),\t\t_bf(0)\t&#123;&#125;&#125;;\n\n关于键值对的内容，在上篇博客的KVL树中有提到过 【传送门】\n\n2.2 AVL树的插入（重要）因为AVL需要控制树的高度，其插入的时候就没有KVL树那么方便了。我们每次插入之后，都需要向上更新并判断树的平衡因子是否正常\n先来理清一下思路:\n\n如果是空树，new一个新节点交给root，无需进行后续操作\n插入新节点的时候，利用搜索二叉树的规则（在这里我采用了左小右大的规则）来找到新节点应该插入的位置，直接进行插入\n插入之后，需要向上更新平衡因子（利用父节点parent）\n如果该插入节点在父节点的右边，平衡因子+1\n如果在该节点的左边，平衡因子-1。\n\n\n更新了平衡因子之后，需要及时进行判断。如果平衡因子等于0，则不需要继续往上更新。如果平衡因子的绝对值大于1，说明当前就需要旋转了\n\n根据这个思路，我们可以先写出插入的一个基本框架\nbool Insert(const pair&lt;K, V&gt;&amp; kv)&#123;\t//判断root为空，即空树\tif (_root == nullptr)\t&#123;\t\t_root = new Node(kv);\t\treturn true;\t&#125;\t//kv树的操作\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;           //利用key来判断，寻找待插入的位置\t\tif (cur-&gt;_kv.first &lt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (cur-&gt;_kv.first &gt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse&#123;\t\t\treturn false;\t\t&#125;\t&#125;\t//找到位置后插入节点\tcur = new Node(kv);\tif (parent-&gt;_kv.first &lt; kv.first)\t&#123;\t\tparent-&gt;_right = cur;\t&#125;\telse\t&#123;\t\tparent-&gt;_left = cur;\t&#125;\tcur-&gt;_parent = parent;\t//插入之后需要向上更新平衡因子\twhile (parent)\t&#123;\t\tif (cur == parent-&gt;_left) &#123;\t\t\tparent-&gt;_bf--;//左-1\t\t&#125;\t\telse&#123;\t\t\tparent-&gt;_bf++;//右+1\t\t&#125;\t\t//更新了之后，需要判断是否继续更新，还是需要旋转\t\tif (parent-&gt;_bf == 0) &#123;\t\t\tbreak;//为0代表高度没有变化，不需要继续更新\t\t&#125;\t\telse if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)\t\t&#123;\t\t\tcur = cur-&gt;_parent;//向上更新\t\t\tparent = parent-&gt;_parent;\t\t&#125;\t\telse if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)\t\t&#123;\t\t\t//旋转\t\t&#125;\t\telse\t\t&#123;\t\t\t//插入之前AVL就存在不平衡子树\t\t\tassert(false);\t\t&#125;\t&#125;\treturn true;&#125;\n\n其中最复杂的部分：旋转，需要拿出来单独讲解一番\n\n下面是一个最简单的二叉树进行插入之后，平衡因子的变化。\n\n因为搜索二叉树需要保证两边的高度之差不大于1，所以此时我们的树还没有违背AVL树的规则。\n可如果我们继续往右子树插入节点呢？\n\n可以看到，最后一颗子树的根节点的平衡因子为2，超过了1。此时两边子树的高度差为2，需要我们进行旋转操作\n2.2.1 左&#x2F;右单旋为了简化，我们把上图的插入情况直接简化为下面的样子\n\n当我们在这棵树高度较高的那一侧的边缘插入的时候，就需要进行单旋。\n\n比如右边高，就是在最右边的叶子处插入\n\n单旋的思路很好理解，下面以左单旋为例（蓝色代表新增节点）\n\n这里我们设置了3个不同的节点，分别是prev起始节点（即平衡因子大于1的节点）以及它的右子树subR、右子树的左子树subRL（即图中的b子树）\n\n需要做的操作，就是把subRL链接给prev的右，再将prev链接到subR的左\n因为subRL在prev的右侧，其的值肯定大于prev，所以这样链接是不会破坏搜索二叉树的结构的。\n\n旋转完成之后，我们需要把prev和subR的平衡因子都更新为0\n\n右单旋的操作和左单旋的思路完全相同，只不过方向相反\n\n\n思路搞定了，下面就来写一个代码吧！\nvoid RotateL(Node* parent)//左单旋&#123;    Node* prev = parent;    Node* subR = parent-&gt;_right;    Node* subRL = subR-&gt;_left;    //用来记录当前parent的父亲，最后的链接需要    Node* ppNode = parent-&gt;_parent;    prev-&gt;_right = subRL;    if (subRL != nullptr)    &#123;//不为空才能进行parent操作        subRL-&gt;_parent = prev;    &#125;    subR-&gt;_left = prev;    prev-&gt;_parent = subR;    if (prev == _root)    &#123;//单独操作为根节点的情况        //subR-&gt;_parent = nullptr;        _root = subR;        _root-&gt;_parent = nullptr;    &#125;    else    &#123;        if (prev == ppNode-&gt;_left) &#123;            ppNode-&gt;_left = subR;        &#125;        else &#123;            ppNode-&gt;_right = subR;        &#125;        subR-&gt;_parent = ppNode;    &#125;    //默认全都改成0    subR-&gt;_bf = parent-&gt;_bf = 0;&#125;\n\n右单旋的代码和这个类似，这里就不贴出来了\n\n完整代码可以到我的代码仓库里面看哦！【Gitee】\n\n旋转的代码写好了，我们现在还需要了解的是，什么时候需要进行单旋？\n看图可以得知，当prev的平衡因子为-2，subL的平衡因子为-1的时候，需要进行一次右单旋\n\n同理，我们可以推断出一个结论，那就是当父节点的平衡因子的绝对值超过1，其左&#x2F;右边节点的平衡因子为1且和父节点平衡因子的正负相同时，需要向另外一个方向进行单旋。\n左单旋就是父节点为2，其右子树为1，需要向另外一个方向左进行单旋\n\n需要注意的是，虽然图里面画出来的prev是根节点，但实际上进行单旋的时候，prev可能是另外一棵树的子树。在单旋的处理过程中，我们必须要保存prev的父节点，并重新链接至subR\n//插入函数的旋转部分else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)&#123;    if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1)    &#123;        RotateL(parent);    &#125;    else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1)    &#123;        RotateR(parent);    &#125;    else    &#123;        //……    &#125;    break;&#125;\n\n我们用下面的代码进行测试\nvoid TestAVLTree1()&#123;\tint a[] = &#123;9,8,7,6,5,4,3,2,1 &#125;;\tAVLTree&lt;int, int&gt; t;\tfor (auto e : a)\t&#123;\t\tt.Insert(make_pair(e, e));\t&#125;\tt.InOrder();\tcout &lt;&lt; endl;&#125;\n\n进行中序打印，可以获取道下面的结果。可以看到数据已经有序\n\n在VS2019的调试窗口中可以看到，我们厂家的这棵树是符合平衡搜索二叉树的性质的\n\n\n2.2.2 左右&#x2F;右左双旋上面的情况还算容易，一次单旋就能解决。那如果我们插入不有序的数据呢？\n\n可以看到中序打印的结果已经有序，可它符合平衡二叉树的规则吗？\n再插入一个25，会发现触发了断言，说明AVL树的规则被破坏了\n\n就好比下面的这种情况，我们是以15 6 7这种非有序方式插入的，就会出现单旋完全处理不了的情况\n\n如果进行单旋会发生什么呢？\n\n可以看到，毫无变化。旋转了之后的节点依旧是违反AVL树的规则\n这时候我们就需要进行两次循环了！\n\n概念理解了之后，我们就可以直接来写代码了。\n因为本质上就是两次单旋，所以我们可以直接复用之前写好的单旋代码\nvoid RotateLR(Node* parent)//左右&#123;    RotateL(parent-&gt;_left);    RotateR(parent);&#125;\n\n但事情远没有这么简单！\n在2.2.1单旋的操作中，我们旋转完毕后会把prev和subL的平衡因子都改成了0。在这种双旋的情况下，全改成0显然不符合要求。\n下面的情况，我们就需要在旋转之后，把10的平衡因子改成-1，20和30的平衡因子改成0\n\n双旋的情况分为下面3种，我们可以直接用紫色框中所指的这个节点来判断属于哪一种情况，再针对性的处理！\n\n处理之后的结果如下\n\n其代码逻辑如下\n//这种双旋转的情况，基本如下//   9// 7//   8//必须要双旋转才能解决问题void RotateLR(Node* parent)//左右&#123;    Node* prev = parent;    Node* subL = parent-&gt;_left;    Node* subLR = subL-&gt;_right;    int bf = subLR-&gt;_bf;    RotateL(parent-&gt;_left);    RotateR(parent);    if (bf == 0)    &#123;        prev-&gt;_bf = 0;        subL-&gt;_bf = 0;        subLR-&gt;_bf = 0;    &#125;    else if (bf == 1)    &#123;        subL-&gt;_bf = -1;        prev-&gt;_bf = 0;        subLR-&gt;_bf = 0;    &#125;    else if (bf == -1)    &#123;        subL-&gt;_bf = 0;        prev-&gt;_bf = 1;        subLR-&gt;_bf = 0;    &#125;    else &#123;        assert(false);    &#125;&#125;void RotateRL(Node* parent)//右左&#123;    Node* prev = parent;    Node* subR = parent-&gt;_right;    Node* subRL = subR-&gt;_left;    int bf = subRL-&gt;_bf;    RotateR(parent-&gt;_right);    RotateL(parent);    if (bf == 0)    &#123;        prev-&gt;_bf = 0;        subR-&gt;_bf = 0;        subRL-&gt;_bf = 0;    &#125;    else if (bf == -1)    &#123;        subR-&gt;_bf = 1;        prev-&gt;_bf = 0;        subRL-&gt;_bf = 0;    &#125;    else if (bf == 1)    &#123;        subRL-&gt;_bf = 0;        subR-&gt;_bf = 0;        prev-&gt;_bf = -1;    &#125;    else &#123;        assert(false);    &#125;&#125;\n\n到这里我们就可以把插入函数给补全了！\n\n完整代码可以到我的代码仓库里面看哦！【Gitee】\n\n还是刚刚的测试用例，这一次我们可以看到，它已经没有报错了！\n\n\n2.3 AVL树的搜索本质上AVL树还是一个平衡二叉树，所以搜索肯定是少不了的！\n它的搜索和KVL树完全一致，利用key来进行搜索，定位value。\n所以，我们可以直接搬过来用。\n//因为kvl树我们需要修改value，所以返回节点的指针Node* _FindR(Node* root, const K&amp; key)&#123;\tif (root == nullptr)\t\treturn nullptr;\tif (root-&gt;_kv.first &lt; key)\t&#123;\t\treturn _FindR(root-&gt;_right, key);\t&#125;\telse if (root-&gt;_kv.first &gt; key)\t&#123;\t\treturn _FindR(root-&gt;_left, key);\t&#125;\telse\t&#123;\t\treturn root;//返回节点的指针\t&#125;&#125;\n\n上面的这个函数我们定义为私有，在公有里面定义一个下面的函数\n//查找是通过key来进行的Node* FindR(const K&amp; key)&#123;\treturn _FindR(_root, key);&#125;\n\n测试一下可以看到，打印了全0的地址值，即nullptr，说明没有找到34\n\n2.4 如何判断是否符合AVL树的性质如果每一次我们都要用调试去看当前的代码是否符合二叉树的性质，未免有些太麻烦了\n下面我们有两种办法来简洁地判断！\n2.4.1 层序遍历（OJ题）下面的代码是一道OJ题的答案，其要求是让我们把树每一层的节点都插入一个vector，最后返回的是一个嵌套的vector&lt;vector&lt;int&gt;&gt;\n\n来自 https://leetcode.cn/problems/binary-tree-level-order-traversal/\n\n因为我们当前测试的用例都是int类型，所以这里就没有用模板参数。实际上我们应该改成key的类型\nvector&lt;vector&lt;int&gt;&gt; levelOrder() &#123;\tvector&lt;vector&lt;int&gt;&gt; vv;\tif (_root == nullptr)\t\treturn vv;\tqueue&lt;Node*&gt; q;\tint levelSize = 1;\tq.push(_root);\twhile (!q.empty())\t&#123;\t\t// levelSize控制一层一层出\t\tvector&lt;int&gt; levelV;\t\twhile (levelSize--)\t\t&#123;\t\t\tNode* front = q.front();\t\t\tq.pop();\t\t\tlevelV.push_back(front-&gt;_kv.first);\t\t\tif (front-&gt;_left)\t\t\t\tq.push(front-&gt;_left);\t\t\tif (front-&gt;_right)\t\t\t\tq.push(front-&gt;_right);\t\t&#125;\t\tvv.push_back(levelV);\t\tfor (auto e : levelV)\t\t&#123;\t\t\tcout &lt;&lt; e &lt;&lt; &quot; &quot;;\t\t&#125;\t\tcout &lt;&lt; endl;\t\t// 上一层出完，下一层就都进队列\t\tlevelSize = q.size();\t&#125;\treturn vv;&#125;\n测试一下，可以看到每一层的结果，符合我们AVL树的性质\n\n2.4.2 检查平衡因子这里我们用两个递归函数，通过计算子树的高度，来判断是否满足AVL树的性质。\n只要两个子树的高度差大于1，就说明不是AVL树\n//计算高度int _Height(Node* root)&#123;    if (root == nullptr)        return 0;    int lh = _Height(root-&gt;_left);    int rh = _Height(root-&gt;_right);    //如果左子树高于右子树，就返回左子树+1（根）    return lh &gt; rh ? lh + 1 : rh + 1;&#125;//判断是否为平衡二叉树bool _IsBalanceTree(Node* root)&#123;    // 空树也是AVL树    if (nullptr == root)        return true;    // 计算pRoot节点的平衡因子：即pRoot左右子树的高度差    int leftHeight = _Height(root-&gt;_left);    int rightHeight = _Height(root-&gt;_right);    int diff = rightHeight - leftHeight;    // 如果计算出的平衡因子与pRoot的平衡因子不相等，或者    // pRoot平衡因子的绝对值超过1，则一定不是AVL树    if (abs(diff) &gt;= 2)    &#123;        cout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot;节点平衡因子异常&quot; &lt;&lt; endl;        return false;    &#125;    if (diff != root-&gt;_bf)    &#123;        cout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot;节点平衡因子不符合实际&quot; &lt;&lt; endl;        return false;    &#125;    // pRoot的左和右如果都是AVL树，则该树一定是AVL树    return _IsBalanceTree(root-&gt;_left)        &amp;&amp; _IsBalanceTree(root-&gt;_right);&#125;\n\n\n\n2.5 利用随机值和顺序值进行测试下面我们分别利用随机值和顺序值测试AVL树的正确性\nvoid TestAVLTree2()&#123;\tconst size_t N = 1024*1024;\tvector&lt;int&gt; v;\tv.reserve(N);\tsrand(time(0));//使用随机数\tfor (size_t i = 0; i &lt; N; ++i)\t&#123;\t\tv.push_back(rand());\t\t//v.push_back(i);\t&#125;\tAVLTree&lt;int, int&gt; t;\tfor (auto e : v)\t&#123;\t\tt.Insert(make_pair(e, e));\t&#125;\tcout &lt;&lt; &quot;是否平衡?&quot; &lt;&lt; t.IsBalanceTree() &lt;&lt; endl;\tcout &lt;&lt; &quot;高度:&quot; &lt;&lt; t.Height() &lt;&lt; endl;&#125;\n\n利用随机数测试的结果如下\n\n顺序插入的结果如下\n\n没有问题辣！\n2.6 AVL树的删除AVL树的删除和KVL树是基本相同的，但是我们需要更新平衡因子。\n\n如果删除的是左节点，平衡因子+1\n如果删除的是右节点，平衡因子-1\n\n当我们遇到平衡因子错误（绝对值大于1）就需要进行旋转\n\n因为搜索树中一般不会进行删除，效率很低，所以这里就不写了！（懒）\n\n2.7 二叉树性能在一些时候，搜索二叉树的性能并不会很高\n\n比如当我们插入的元素已经有序，或者基本有序的时候，二叉树的性能就和普通的容器差距不大了\nAVL树更适合于插入的元素不会被改变的情况。如果插入的元素需要经常被修改，那么也不太适合。（比如删除的时候，AVL树的平衡因子可能需要一直向上到根，时间复杂度不亚于二次插入）\n\n结语那么本篇关于AVL树的博客到这里就结束拉！\n有什么问题欢迎在评论区提出哦！\n\n","categories":["遇见C++"],"tags":["C++","数据结构","树"]},{"title":"【C++】红黑树的性质和实现","url":"/2022/09/04/code/note_cpp/17%E7%BA%A2%E9%BB%91%E6%A0%91/","content":"上篇博客我们了解了AVL树，这篇博客就让我们来看看另外一个二叉树：红黑树\n\n使用的编译器：VS2019\n\n\n\n[TOC]\n\n博客里面引用了一些百度搜到的图片（自己懒的画了，呜呜）\n1.概念AVL树是一个几乎完全平衡的搜素二叉树，其左右子树的高度差不会超过1。与之相对应的，是每一次插入都有可能需要旋转多次，插入的效率较低。\n而红黑树则选择了“相对平衡”，并拥有以下的特性：\n\n红黑树可以保证最长路径的小于最短路径的2倍\n\n比如最短路径为30，那么最长路径就不能超过60\n\n\n对于cpu来说，AVL树遍历20次（百万级数据）和红黑树遍历40次的时间差距极小。所以红黑树即保持了相对平衡，又减小了AVL树多次旋转的消耗。\n\n1.1 性质其通过下面的几点来维持这一性质：\n\n每一个节点不是红色就是黑色\n根节点一定是黑色\n每一个红节点的左右子树都是黑色\n每一个到叶子（空节点NIL）的支路上黑节点数量相同\n叶子节点（空节点NIL）视作黑色\n\n为什么满足了这几个情况，就满足了红黑树的最长路径的小于最短路径的2倍的性质呢？\n约束4和5，保证了红黑树的大致平衡：根到叶子的所有路径中，最长路径不会超过最短路径的2倍。这使得红黑树在最坏的情况下，也能有O(logN) 的查找效率\n\n黑色高度为3时，最短路径：黑色→ 黑色 →黑色\n最长路径：黑色→红色 →黑色 →红色 →黑色\n此时最短路径的长度为2（不算Nil的叶子节点），最长路径为4\n\n这里可以得出一个普遍规律，红黑树最短路径即为全黑路径。而最长路径是一黑一红间隔的情况\n\n2.设计一颗红黑树在设计红黑树的时候，我们需要牢记上面的5点。其中前4点非常重要且不可以被破坏。一旦被破坏，就影响了红黑树的基本性质。\n2.1 设计节点和AVL树一样，我们需要把节点单独成一个类，来存放我们需要的pair\n这里就设计到了颜色的初值应该给什么。红色，还是黑色？\n来看看性质3和4：\n\n红色的左右子树必须是黑色\n每一个到叶子（空节点NIL）的支路上黑节点数量相同\n\n简单思考，即可发现，插入红节点的时候，更好控制。而插入黑节点极有可能破坏性质4且较难修复。\n//枚举，定义颜色enum Color&#123;\tRED,//0\tBLACK,//1&#125;;//节点类template&lt;class K, class V&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;K, V&gt;* _left;\tRBTreeNode&lt;K, V&gt;* _right;\tRBTreeNode&lt;K, V&gt;* _parent;\tpair&lt;K, V&gt; _kv;\t//AVL树的平衡因子，在红黑树中为颜色\tColor _col;\t//插入节点的时候，默认为红色\t//因为这个满足性质3且不会破坏性质4\tRBTreeNode(const pair&lt;K, V&gt;&amp; kv)\t\t:_kv(kv),\t\t_left(nullptr),\t\t_right(nullptr),\t\t_parent(nullptr),\t\t_col(RED)\t&#123;&#125;&#125;;\n\n2.2 插入的几种情况节点设计好了，我们只需要把插入的逻辑搞定，那么红黑树也就完成了！\n前半部分的代码和AVL树完全相同，只不过我们需要手动给根节点一个黑色（默认是红色）以维持性质2\nbool Insert(const pair&lt;K, V&gt;&amp; kv)&#123;\t//判断root为空，即空树\tif (_root == nullptr)\t&#123;\t\t_root = new Node(kv);\t\t_root-&gt;_col = BLACK;//这里必须要手动给黑色\t\treturn true;\t&#125;\t//kv树的操作\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;\t\t//利用key来判断，寻找待插入的位置\t\tif (cur-&gt;_kv.first &lt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (cur-&gt;_kv.first &gt; kv.first)\t\t&#123;\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse &#123;\t\t\treturn false;\t\t&#125;\t&#125;\t//找到位置后插入节点\tcur = new Node(kv);\tif (parent-&gt;_kv.first &lt; kv.first)\t&#123;\t\tparent-&gt;_right = cur;\t&#125;\telse\t&#123;\t\tparent-&gt;_left = cur;\t&#125;\tcur-&gt;_parent = parent;       //调整       //……  &#125;\n\n2.2.1 情况1：无需旋转在下面的这种情况中，我们在p的左边插入了一个cur新节点。此时违反了性质3，红节点的孩子必须要是黑节点。\n这种情况必须满足p和u都是红节点\n\n随后我们就需要开始向上进行更新，操作如下：\n\n把p和u都改成黑节点\n把g改成红节点\n\n修改之后的结果如下，即不影响性质3；也保证了黑节点的个数不变，维持了性质4\n\n需要注意的是，这里的g不一定是根节点。所以在操作完这一课子树之后，我们需要继续向上进行操作，避免g的父节点是红色的情况。\n\n代码实现如下（以父节点为g的左子树为例）\n//插入之后需要向上更新颜色,只有出现连续红色之后才需要更新while (parent &amp;&amp; parent-&gt;_col==RED)&#123;    //p是g的左    if (parent == grandpa-&gt;_left)    &#123;        Node* uncle = grandpa-&gt;_right;        //情况1：插入后p是红，u存在且是红（不需要旋转）        if (uncle &amp;&amp; uncle-&gt;_col == RED)        &#123;            uncle-&gt;_col = BLACK;            parent-&gt;_col = BLACK;            grandpa-&gt;_col = RED;//祖父变成红            //继续向上调整            //cur = cur-&gt;_parent;            //parent = parent-&gt;_parent;            cur = grandpa;            parent = cur-&gt;_parent;        &#125;    &#125;    else&#123;        //....    &#125;&#125;\n\n需要注意的是，这种调整会把g改成红节点。如果G是根节点，改成红色之后就不符合性质了。所以我们需要在操作完成之后，统一把根节点改成黑色\n//不管是什么情况，最后都把根改成黑，符合条件2_root-&gt;_col = BLACK;\n\n2.2.2 情况2：需要单旋当我们插入了一个cur向上更新的时候，就可能会遇到下图中间的情况。p是红节点，违反了性质3，而u是黑节点，不能简单粗暴的通过把p改成红来解决。\n\n这时候我们就需要针对g进行一次单旋（图中是右单旋，可以简单理解为向u旋转）。因为cur和p形成了同侧的连续两个红节点。和AVL树的单旋情况相似，只有这两节点在同侧，才可以执行单旋。\n旋转完毕之后，需要把g更新为红节点，p更新为黑节点\n2.2.3 情况3：需要双旋在情况2中，p和cur都是在它们父亲的同一侧。而情况3就是p和cur在父亲的不同侧。\n\n比如p是g的左子树，cur是p的右子树\n同时满足p是红，u是黑\n\n这时候就需要进行一次三旋，操作如下：\n\n以p作为基点，向cur的另外一个方向单旋一次（上图中就是左旋）\n旋转了之后，就会变成情况2\n这时候再以g为基点，向u的方向旋转一次（上图中为右旋）\n旋转完成之后，把g设置为红，cur设置为黑即可\n\n\n一下是完整的三种情况代码（p是g的左子树的情况）\n//p是g的左if (parent == grandpa-&gt;_left)&#123;    Node* uncle = grandpa-&gt;_right;    //情况1：插入后p是红，u存在且是红（不需要旋转）    if (uncle &amp;&amp; uncle-&gt;_col == RED)    &#123;        uncle-&gt;_col = BLACK;        parent-&gt;_col = BLACK;        grandpa-&gt;_col = RED;//祖父变成红        //继续向上调整        //cur = cur-&gt;_parent;        //parent = parent-&gt;_parent;        cur = grandpa;        parent = cur-&gt;_parent;    &#125;    else//(uncle &amp;&amp; uncle-&gt;_col == BLACK)    &#123;        //情况2：插入后p为红，u存在且为黑（需要单旋）        if (cur == parent-&gt;_left)        &#123;            RotateR(grandpa);//因为p在g的左边，所以右旋            parent-&gt;_col = BLACK;            grandpa-&gt;_col = RED;        &#125;        else//cur == parent-&gt;_right        &#123;            //情况3：不是在同一侧，双旋            //   g            // p            //   c            RotateL(parent);            RotateR(grandpa);            grandpa-&gt;_col = RED;//祖父改成红色            cur-&gt;_col = BLACK;//自己成为了这里的根，需要改成黑的        &#125;        break;    &#125;&#125;else&#123;    //....&#125;\n\n由于篇幅限制，p是g右子树的情况就不贴出来了，实际上就是把上面的代码全反过来就行了\n\n完整代码请查看我的gitee仓库\n\n2.3 查找（和AVL树完全相同）//因为kvl树我们需要修改value，所以返回节点的指针Node* _FindR(Node* root, const K&amp; key)&#123;\tif (root == nullptr)\t\treturn nullptr;\tif (root-&gt;_kv.first &lt; key)\t&#123;\t\treturn _FindR(root-&gt;_right, key);\t&#125;\telse if (root-&gt;_kv.first &gt; key)\t&#123;\t\treturn _FindR(root-&gt;_left, key);\t&#125;\telse\t&#123;\t\treturn root;\t&#125;&#125;//查找是通过key来进行的Node* FindR(const K&amp; key)&#123;\treturn _FindR(_root, key);&#125;\n\n2.4 判断是否是红黑树有两种方案，1是可以通过计算最大高度&#x2F;最小高度进行间接判断，2是以红黑树性质来验证是否满足最上面提到的5点\n2.4.1 计算最小最大高度这里实现递归即可，最小长度其实就是在最后return的判断中，把大于号改成小于号，返回小的那个子树的高度+1\nint maxHeight()&#123;\treturn _maxHeight(_root);&#125;int minHeight() &#123;\treturn _minHeight(_root);&#125;//最大长度int _maxHeight(Node* root)&#123;\tif (root == nullptr)\t\treturn 0;\tint lh = _maxHeight(root-&gt;_left);\tint rh = _maxHeight(root-&gt;_right);\treturn lh &gt; rh ? lh + 1 : rh + 1;&#125;//最小长度int _minHeight(Node* root)&#123;\tif (root == nullptr)\t\treturn 0;\tint lh = _minHeight(root-&gt;_left);\tint rh = _minHeight(root-&gt;_right);\treturn lh &lt; rh ? lh + 1 : rh + 1;&#125;\n\n只要最大长度小于最小长度的2倍，那么基本规则就是没有破坏的\n\n但这还不够，我们还需要检查它是否满足红黑树的其余性质\n2.4.2 递归检查性质这里再次列出5点性质\n\n每一个节点不是红色就是黑色\n根节点一定是黑色\n每一个红节点的左右子树都是黑色\n每一个到叶子（空节点NIL）的支路上黑节点数量相同\n叶子节点（空节点NIL）视作黑色\n\n然后通过两个函数来实现，其中一个函数需要进行递归\nbool IsRBTree()&#123;    //检查红黑树几条规则    Node* pRoot = _root;    //空树也是红黑树    if (nullptr == pRoot)        return true;    //检测根节点是否满足情况2    if (BLACK != pRoot-&gt;_col)    &#123;        cout &lt;&lt; &quot;违反2：根节点必须为黑色&quot; &lt;&lt; endl;        return false;    &#125;    //获取任意一条路径中黑色节点的个数，作为基准值    size_t blackCount = 0;    Node* pCur = pRoot;    while (pCur)    &#123;        if (BLACK == pCur-&gt;_col)            blackCount++;        pCur = pCur-&gt;_left;    &#125;    //检测是否满足红黑树的性质，k用来记录路径中黑色节点的个数    size_t k = 0;    return _IsValidRBTree(pRoot, k, blackCount);&#125;\t//检测是否为RB树bool _IsValidRBTree(Node* pRoot, size_t k, const size_t blackCount)&#123;    //走到null之后，判断k和black是否相等    if (nullptr == pRoot)    &#123;        if (k != blackCount)        &#123;            cout &lt;&lt; &quot;违反4：每条路径中黑色节点的个数必须相同&quot; &lt;&lt; endl;            return false;        &#125;        return true;    &#125;    //统计黑色节点的个数    if (BLACK == pRoot-&gt;_col)        k++;    //检测当前节点与其双亲是否都为红色    if (RED == pRoot-&gt;_col &amp;&amp; pRoot-&gt;_parent &amp;&amp; pRoot-&gt;_parent-&gt;_col == RED)    &#123;        cout &lt;&lt; &quot;违反3：存在连在一起的红色节点&quot; &lt;&lt; endl;        return false;    &#125;    return _IsValidRBTree(pRoot-&gt;_left, k, blackCount) &amp;&amp;        _IsValidRBTree(pRoot-&gt;_right, k, blackCount);&#125;\n\n可以看到，不管是随机数还是顺序插入，都通过了检查\n\n3.红黑树的运用红黑树在很多地方都有使用，在C++中，最为经典的便是map和set这两个容器，它们便使用了红黑树作为底层逻辑\n\nhttps://gitee.com/ewait/learn_cpp_code/blob/master/STL-Sourcecode/stl_tree.h\n\n在stl源码中，我们可以找到这个tree.h，里面便是一个红黑树的实现。而map和set就是调用了红黑树，只做了一个简单的封装\n结语在下篇博客中，我会记录map和set的基本使用，以及通过红黑树模拟实现map和set\n感谢大家支持！\n","categories":["遇见C++"],"tags":["C++","数据结构","树"]},{"title":"【C++】STL map_set","url":"/2022/09/19/code/note_cpp/18STL_map_set/","content":"本篇博客让我们来了解一下STL库里面的map&#x2F;set的使用，并尝试用自己写的红黑树封装一个类似的map/set出来\n\n\n\n所用编译器：VS2019\n\n[TOC]\n1 setset就是二叉搜索树中只有单个key的树，它有下面的函数可供使用\n1.1 构造函数、迭代器构造函数、迭代器什么的都很简单，在这里就提到了，和其他STL基本一致\n\n\n1.2 节点计数 sizeset自带节点计数，我们可以之间获取二叉树中节点的个数，或判断set是否为空\n\n1.3 插入删除插入删除等函数在这里不过多解释，使用方法和string、vector完全一致。如果大家的stl是从string一路学习过来，那么对于这些函数的使用肯定没有问题！\n\n插入可以插入单个元素，其返回一个键值对包含这个元素的迭代器+一个bool标识是否插入成功。你还可以用相同类型set的迭代器区间进行插入操作\n\nset&lt;int&gt;t1;//定义 set 对象 t1for (int i = 0; i &lt;= 3; ++i) &#123; // 插入 1 2 3 4 5 6\tt1.insert(i);&#125;\n\n删除可以删除：\n\n指定迭代器位置\n指定元素\n迭代器区间\n\n\n不过对于二叉搜索树而言，删除一直都不是高频操作+效率较低。这也是为什么在实现二叉搜索树的时候，我没有去实现删除操作。\n\n其实主要是删除操作比较难理解，特别是在平衡二叉树中\n\n1.4 查找find作为搜索二叉树，查找才是最重要的一个函数。该函数会返回一个迭代器，指向元素的位置。\n\n如果没有找到这个元素，则返回end迭代器\n\n所以我们只需要在使用这个函数的时候，加上对于end()迭代器的判断，只要不等于end说明找到了该元素，进行访问\nset&lt;int&gt; v1;v1.insert(1);v1.insert(3);v1.insert(6);set&lt;int&gt;::iterator it = v1.find(3);if (it != v1.end())&#123;\tcout &lt;&lt; &quot;找到了 &quot;&lt;&lt; *it &lt;&lt; endl;&#125;\n\n因为set是只有key的搜素二叉树，在获取到迭代器之后，我们直接使用*it进行解引用即可得到节点的值\n\n而当我们查找内部不存在的元素，也可以得知没有找到\n\n\n1.5 count这个函数的作用是查找二叉树中value值的个数。但由于默认的set不支持键值冗余，插入相同的键值会被忽略掉。所以这个count在这里只有0和1两个返回值，也只能用来判断该值是否存在。\n\n但是因为count需要遍历所有元素，所以在set中，它的效率比find是更差的。\nmultiset支持键值冗余这个函数真正起作用的地方是在multiset，人如其名，这是一个支持键值冗余的set，成员函数完全相同。\n\n\n1.6 lower&#x2F;upper_bound\niterator lower_bound (const value_type&amp; val);   // 返回指向等于或大于指定键值元素的迭代器iterator upper_bound (const value_type&amp; val);   // 返回指向大于指定键值元素的迭代器\n\n这两个函数的作用是返回一个和我们指定的元素相同&#x2F;或者比指定元素更大（第一个更大的键值）的迭代器\n\n\n如果更大的键值或者它本身不存在，就会返回一个end迭代器，这一点和find一样\n\n\n set基本用得到的迭代器这里都提了一嘴，接下来康康map\n2 mapmap同样有一个支持键值冗余的multimap，后面就不说辣\n\n前面关于构造函数都暂且不提，直接来看map和set最不一样的地方，插入\n2.1 插入map是一个kvl二叉搜索树，其所有元素都是一个键值对。这就要求我们插入的时候，需要先make_pair建立一个键值关系，再插入进map中。\n\n也因为迭代器获取到的是一个键值对，所以访问的时候需要指定键值对的first和second。map是用first进行排序的，所以first是不能修改的，但是second可以\n2.2 下标访问&#x2F;atmap相比于set，最特殊的一点就是它可以用下标直接进行访问\nmap[key]=value;\n\n所以我们可以使用这种方式非常方便的修改value\n\n和重载了下标的vector一样，map也有一个at函数（C++11新增）在之前vector的函数中，我没有提到这两个的区别。在这里说一下\n\noperator[]和at的主要区别在于operator[]不做边界检查，而at会做边界检查。\n\n由于operator[]不做边界检查， 那怕越界了也会返回一个引用，当然这个引用是错误的引用，如何不小心调用了这个引用对象的方法，会直接导致应用退出。\n而由于at会做边界检查，如果越界，会抛出异常，应用可以try/catch这个异常，进行异常管理，而应用还能继续运行。\n\nat的使用和下标不太一样，和成员函数的使用方法一致。我们可以来试一试\n\n\n在这里如果我们下标访问第11个元素，也不会出问题。因为下标访问会自动创建一个对应的key，而value会调用默认构造函数。int类型也是有默认构造的，返回一个0\n\n但如果我们不用下标，直接用at访问第11个元素，就会报debug错误，这便是它们俩的区别所在\n\n\nmap和set有区别的地方主要就是上面两个函数，其余都是完全相同\n我们直接快进到模式实现吧！\n3.模拟实现这里主要以KV键值对的map为例，set只需要修改keyofValue和它自己的模板参数即可\n3.1 康康STL源码利用红黑树实现map和set之前，我们需要先来思考一个问题：我们自己写的红黑树只有一个KV键值对，那么要怎么判断封装的是map还是只有key的set呢？\n\n先来看看STL库的源码吧！【链接】\n\n在map.h的第68行可以看到，实际上库函数里面的map和set都只是封装了红黑树\n\n再去找红黑树的头文件，就能看到其与我们实现的不同。这里面的红黑树总共有5个模板参数，除去最后一个用来申请内存空间的alloc，其余4个都有其不同的用处\n\n而其中的value是用来构造红黑树节点的参数\n\n看起来好像差不多对吧？可再回头看看map，其传入的value是一个pair！\n\n实际上，库中的红黑树，并不是一个简单的kvl，其k并不是真正用于比较的k，而是依靠第三个模板参数keyofvalue，以及我们传入的比较函数compore来进行比较的\n\n说人话就是：RBtree不会判断你是map还是set，而是在map和set的封装端，根据数据的不同类型，传入对应的比较函数，以及键值。\n\n比如set的keyofvalue就是它自己的key\n而map的keyofvalue是pair.first\n\n因为库函数里面pair的比较，是会比较first之后，再比较second的。\n\n这和我们搜索二叉树的需求不太符合，所以STL库里面就需要写一个比较大小的仿函数，只针对pair的first进行严格比较，以保证稳定性\n\n3.2 模拟实现的基础框架如果我们自己模拟实现，则可以依据下面的模板进行操作\n// 模板参数V决定红黑树存什么数据// set: RBTree&lt;K, K&gt;// map: RBTree&lt;K, pair&lt;K, V&gt;&gt;// KeyOfV: 取出V对象中key的仿函数template&lt;class K, class V, class KeyOfV&gt;\n\n而节点类也需要进行对应的修改，不再默认创建一个键值对。而是直接用V来创建一个基本的类型，这就和最基础的搜索二叉树相同。\ntemplate&lt;class V&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;V&gt;* _left;\tRBTreeNode&lt;V&gt;* _right;\tRBTreeNode&lt;V&gt;* _parent;\tV _data;\t//AVL树的平衡因子，在红黑树中为颜色\tColor _col;\t//插入节点的时候，默认为红色\t//因为这个满足性质3且不会破坏性质4\tRBTreeNode(const V&amp; data)\t\t:_data(data),\t\t_left(nullptr),\t\t_right(nullptr),\t\t_parent(nullptr),\t\t_col(RED)\t&#123;&#125;&#125;;\n\n3.3 修改插入的代码因为新增了模板参数，所以这里我们也不能通过kv first进行键值的比较了。我们需要里利用模板参数中的KeyOfV仿函数来进行比较的操作。\n在这里，先给出map和set两种KeyOfV仿函数的实现\nstruct MapKeyOfV&#123;    const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)    &#123;        return kv.first;//map是键值对，需要提供kv的first进行比较    &#125;&#125;;struct SetKeyOfV&#123;    const K&amp; operator()(const K&amp; key)    &#123;        return key;//set只有一个键值    &#125;&#125;;\n\n有了这个仿函数，我们只需要实例化一个对象，然后将原有的比较替换成仿函数在进行比较即可！\npair&lt;iterator,bool&gt; Insert(const V&amp; data)&#123;    //判断root为空，即空树    if (_root == nullptr)    &#123;        _root = new Node(data);        _root-&gt;_col = BLACK;//这里必须要手动给黑色        return make_pair(iterator(_root),true);    &#125;    //kv树的操作    Node* parent = nullptr;    Node* cur = _root;    while (cur)    &#123;        //利用key来判断，寻找待插入的位置        if (kov(cur-&gt;_data)&lt; kov(data))        &#123;            parent = cur;            cur = cur-&gt;_right;        &#125;        else if (kov(cur-&gt;_data) &gt; kov(data))        &#123;            parent = cur;            cur = cur-&gt;_left;        &#125;        else &#123;            return make_pair(iterator(cur), false);//构造一个迭代器返回        &#125;    &#125;    //找到位置后插入节点    cur = new Node(data);    Node* newnode = cur;    if (kov(parent-&gt;_data) &lt; kov(data))    &#123;        parent-&gt;_right = cur;    &#125;    else    &#123;        parent-&gt;_left = cur;    &#125;    cur-&gt;_parent = parent;    //插入之后需要向上更新颜色,只有出现连续红色之后才需要更新    while (parent &amp;&amp; parent-&gt;_col==RED)    &#123;        Node* grandpa = parent-&gt;_parent;//祖父        assert(grandpa);//祖父为空不需要进行操作        //p是g的左        if (parent == grandpa-&gt;_left)        &#123;            Node* uncle = grandpa-&gt;_right;            //情况1：插入后p是红，u存在且是红（不需要旋转）            if (uncle &amp;&amp; uncle-&gt;_col == RED)            &#123;                uncle-&gt;_col = BLACK;                parent-&gt;_col = BLACK;                grandpa-&gt;_col = RED;//祖父变成红                //继续向上调整                //cur = cur-&gt;_parent;                //parent = parent-&gt;_parent;                cur = grandpa;                parent = cur-&gt;_parent;            &#125;            else//(uncle &amp;&amp; uncle-&gt;_col == BLACK)            &#123;                //情况2：插入后p为红，u存在且为黑（需要单旋）                if (cur == parent-&gt;_left)                &#123;                    RotateR(grandpa);//因为p在g的左边，所以右旋                    parent-&gt;_col = BLACK;                    grandpa-&gt;_col = RED;                &#125;                else//cur == parent-&gt;_right                &#123;                    //情况3：不是在同一侧，双旋                    //   g                    // p                    //   c                    RotateL(parent);                    RotateR(grandpa);                    grandpa-&gt;_col = RED;//祖父改成红色                    cur-&gt;_col = BLACK;//自己成为了这里的根，需要改成黑的                &#125;                break;            &#125;        &#125;        else &#123;            Node* uncle = grandpa-&gt;_left;            //情况1：插入后p是红，u存在且是红（不需要旋转）            if (uncle &amp;&amp; uncle-&gt;_col == RED)            &#123;                uncle-&gt;_col = BLACK;                parent-&gt;_col = BLACK;                grandpa-&gt;_col = RED;//祖父变成红                //继续向上调整                cur = grandpa;                parent = cur-&gt;_parent;            &#125;            else//(uncle &amp;&amp; uncle-&gt;_col == BLACK)            &#123;                //情况2：插入后p为红，u存在且为黑（需要单旋）                if (cur == parent-&gt;_right)                &#123;                    RotateL(grandpa);//因为p在g的左边，所以右旋                    parent-&gt;_col = BLACK;                    grandpa-&gt;_col = RED;                &#125;                else//cur == parent-&gt;_left                &#123;                    //情况3：不是在同一侧，双旋                    //   g                    //\t\tp                    //   c                    RotateR(parent);                    RotateL(grandpa);                    grandpa-&gt;_col = RED;//祖父改成红色                    cur-&gt;_col = BLACK;//自己成为了这里的根，需要改成黑的                &#125;                break;            &#125;        &#125;    &#125;    //不管是什么情况，最后都把根改成黑，符合条件2    _root-&gt;_col = BLACK;    return make_pair(iterator(newnode), true);&#125;\n\n这里说明一下为何要把返回值替换成键值对。因为在实际操作的时候，我们需要获取道新插入元素的迭代器（迭代器的模拟实现会在后面提及），以方便在插入后进行修改value的操作。\n\n比如我们默认插入的是一个空字符串，在进行一些判断之后，再重新给这个键值的value进行修改（仅限于map的情况）\n\n如果不返回一个迭代器，那么想修改这个键值，就只能通过find函数查找后再进行修改，相对有些麻烦。\n3.4 迭代器✨这一部分是比较难理解的迭代器操作，主要就是在一个二叉树中应该如何进行迭代器的++/--操作。\n3.4.1 加减操作如果你看过我之前的stl博客，那么你应该还记得，我们的模拟实现迭代器其实就是用指针来进行的。迭代器的使用方法也和指针相差无几。\n在此处我们选择使用中序遍历来进行迭代器的操作。中序遍历的基本情况就是左根右，只不过我们这里不再能使用递归进行操作了，而需要使用迭代的方法。\n\n上图中cur遍历到了右子树，其左右子树都为空。这时候我们需要返回到的是根节点，准确来说是祖父节点——吗？要是cur的父亲prev不是g节点的左子树，我们就不能直接返回g进行打印！而需要返回g的左子树。\n总结出来的规律如下，当我们执行++操作的时候：\n\n如果右节点为空，当前节点是父亲的右侧，就需要继续往上找（我们需要找到父亲左侧的那个节点）\n如果右子树不为空，找右子树的最左节点。\n\n在上图中，prev就是g的左子树，所以我们只需要找到prev就行了。然后因为我们的prev的右子树已经遍历过，所以这时候就需要往上。因为g是根节点，所以就需要返回g的右子树的最左节点，也就是下图中的位置\n\n而当我们做到最右侧的节点时，再次++的时候其实已经遍历完了。这时候右子树为空，开始往上找父亲是祖父左的哪一个。这时候会一直找到根，而根的父亲为空，停止遍历\n\n转换为代码如下\nSelf&amp; operator++()&#123;\tif (_node-&gt;_right == nullptr)\t&#123;\t\tNode* cur = _node;\t\tNode* parent = cur-&gt;_parent;\t\t//只要当前节点是父亲的右侧，就需要继续往上找\t\t//我们需要找到是父亲左侧的那个节点。\t\twhile (parent &amp;&amp; parent-&gt;_right == cur)\t\t&#123;\t\t\tcur = cur-&gt;_parent;\t\t\tparent = parent-&gt;_parent;\t\t&#125;\t\t//如果不符合while的条件，就说明\t\t//1 父亲为空（根)\t\t//2 如果cur是父亲的左，那就直接将node设置为父亲\t\t_node = parent;\t&#125;\telse\t&#123;\t\t//右子树不为空，找右子树的最左节点\t\tNode* subLeft = _node-&gt;_right;\t\twhile (subLeft-&gt;_left)\t\t&#123;\t\t\tsubLeft = subLeft-&gt;_left;\t\t&#125;\t\t//最左节点\t\t_node = subLeft;\t&#125;\treturn *this;&#125;\n\n\n进行--操作的时候则是完全相反的情况。我们需要找到父亲是祖父节点右边的那一个。如果父亲是祖父的左，那就继续往上找。\n\nSelf&amp; operator--()&#123;    if (_node-&gt;_left == nullptr)    &#123;        Node* cur = _node;        Node* parent = cur-&gt;_parent;        //依据中序的顺序，--就是和++反过来。需要找节点是父亲的右边的哪一个        //如果是父亲的左就继续往上找        while (parent &amp;&amp; cur == parent-&gt;_left)        &#123;            cur = cur-&gt;_parent;            parent = parent-&gt;_parent;        &#125;        //指向当前的父亲        _node = parent;    &#125;    else    &#123;        // 左子树的最右节点        Node* subRight = _node-&gt;_left;        while (subRight-&gt;_right)        &#123;            subRight = subRight-&gt;_right;        &#125;        _node = subRight;    &#125;    return *this;&#125;\n\n3.4.2 套上完整迭代器模板完成了迭代器的加减操作后，我们只需要套上之前模拟实现的类似模板，再添加参数到红黑树的类中。即可配套好一个迭代器！\ntemplate&lt;class V, class Ref, class Ptr&gt;struct __RBTreeIterator&#123;\ttypedef RBTreeNode&lt;V&gt; Node;\ttypedef __RBTreeIterator&lt;V, Ref, Ptr&gt; Self;\tNode* _node;//当前指向的节点\t__RBTreeIterator(Node* node)\t\t:_node(node)\t&#123;&#125;\tRef operator*()\t&#123;\t\treturn _node-&gt;_data;\t&#125;\tPtr operator-&gt;()\t&#123;\t\treturn &amp;_node-&gt;_data;\t&#125;\t//省略++和--的代码\tbool operator!=(const Self&amp; s) const\t&#123;\t\treturn _node != s._node;\t&#125;\tbool operator==(const Self&amp; s) const\t&#123;\t\treturn _node == s-&gt;_node;\t&#125;&#125;;\n\n\n完整代码请参考我的Gitee仓库\n\n3.4.3 添加参数到红黑树类中我们需要把迭代器写入红黑树的类，并附上普通迭代器和const的两个版本，提供begin和end函数即可。\n//迭代器封装，const和普通版本typedef __RBTreeIterator&lt;V, V&amp;, V*&gt; iterator;typedef __RBTreeIterator&lt;V, const V&amp;, const V*&gt; const_iterator;iterator Begin()&#123;\tNode* subLeft = _root;\twhile (subLeft &amp;&amp; subLeft-&gt;_left)\t&#123;\t\tsubLeft = subLeft-&gt;_left;\t&#125;\treturn iterator(subLeft);&#125;iterator End()&#123;\treturn iterator(nullptr);&#125;const_iterator Begin() const&#123;\tNode* subLeft = _root;\twhile (subLeft &amp;&amp; subLeft-&gt;_left)\t&#123;\t\tsubLeft = subLeft-&gt;_left;\t&#125;\treturn const_iterator(subLeft);&#125;const_iterator End() const&#123;\treturn const_iterator(nullptr);&#125;\n\n\n可以看到，迭代器已经可以正常使用了！\n\n这里的测试环节最好把自己写的map套进一个命名空间中，不然就会用到stl库里面的map\n\n迭代器写好之后，范围for也是可以用的\n\n3.5 重载下标map非常特殊的一点就是，可以直接用map[key]=value来修改value的内容。我们模拟实现的时候当然不能落下这个了！\n其实操作起来非常简单。我们只需要直接调用插入，如果键值存在也会返回当前键值的迭代器。键值不存在就能直接插入，返回新插入元素的迭代器。这也是之前为啥insert函数没有直接用bool做插入的返回值的原因\n//重载下标V&amp; operator[](const K&amp; key)&#123;    pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));    return ret.first-&gt;second;//返回的是一个引用，所以可以直接修改&#125;\n\n因为我们返回的是V的引用，所以可以直接用=进行修改！\n测试一下，咩有问题 OJBK👍\n\nset的模拟实现更为简单，这里就不贴出来辣！大家可以去我的gitee看源码，有啥问题可以评论提出！\n\n4.更多操作4.1 用set得出两组数据的重合处假设有两个文件，我们现需要找到这两个文件的重合处\n\n设置两个set，分别插入两个文件的内容\n同时遍历两个set（从小到大）\n如果两个set的key相同，则取出这个相同值，两个set一起++\n如果不相同，则++那个小的key\n\n\n其中一个set结束遍历，即代表重合处查找完毕！\n\n结语最近感觉自己真的很忙，但又不知在忙什么。事情一个接着一个，虽然学校的课不算多，但事情真的没少多少。\n有些事情自己又有拖延症，再加上作息不规律（指下午一睡睡3h），浪费了好多时间……\n\n","categories":["遇见C++"],"tags":["C++","数据结构","树"]},{"title":"【C++】哈希Hash（未完成）","url":"/2022/09/20/code/note_cpp/19%E5%93%88%E5%B8%8CHash/","content":"学习完了红黑树以及map&#x2F;set，下面让我们来康康另外一种用于查找数据的新方式，那便是哈希表\n\n\n1.概念哈希是一种用下标映射来查找数据的方式。在STL库中，有map和set的unordered(即为stl库里面的哈希)版本\n我们可以来对比一下它和红黑树（map/set的标准版本）的查找时间差距（是通过for循环查找所有插入数据来实现的计时）\n\n可以看到，在查找方面，unordered版本查找的速度比正常的map和set快了一倍有余。之前我已经觉得搜索二叉树的查找已经非常快了，实际上哈希才是真正的快中之快！\n这两种算法的时间复杂度为：\n\n平衡二叉搜索树 O(logN)\n哈希算法 O(1)\n\n因为哈希是直接从对应的下标映射位置找到数据的，这就和我们进行随机访问顺序表里面的数据一样，都是O(1)的直接访问\n1.1 下标映射那么，要怎么对一个数据进行下标映射呢？\n\n假设我们现在有一个长度为10的数组\n我们需要存放一组int类型的数据，0-9以内的数字可以直接通过下标映射放入对应位置。而大于9的数据则需要进行取模操作，找到对应的下标。比如12%10=2，则放入下标为2的位置\n\n那，如果一个下标位置本来就有数据了怎么办?我们有两种办法来解决这个问题\n1.2 闭散列（开放定址法）当一个下标的位置已经有数据的时候，如果哈希表还没有满，我们可以往这个映射位置的后方插入这个数据\n\n线性探测：依次去找空位置，找到后直接插入\n二次探测：跳跃地找空位置，不会出现太多的拥堵\n\n你可能会问，不对啊。你把别人的位置占了，到时候被人要用这个位置，该怎么去操作啊？\n没错，这个就是闭散列的一大缺点：会占用原本属于其他人的空间。\n1.3 开散列（拉链法）这时候我们就需要用到拉链法。于其在每一个下标映射的位置插入一个数据，我们不如整一个链表。在原有的哈希表中存放链表的头节点。当有相同映射值的数据插入的时候，我们可以执行链表的头插，使其挂载到相同位置的链表上。\n\n这个链表也被称为桶\n\n而没有数据的映射位置，全都为nullptr空指针\n\n在这个应用场景下，我们只需要使用单链表即可以完成桶的操作。若使用list或者自己写的双链表，则会出现不必要的空间浪费。\n你可能会问，那如果一个映射值挂载了特别多的节点，查找的效率会不会从O(1)变成O(N)（即需要遍历一个链表）的时间复杂度呢？\n这就必须要提到哈希表的扩容问题了\n1.4 什么时候需要扩容？在哈希表中，我们一般会定义一个负载因子，用于标记哈希表的数据个数\n负载因子=已有元素个数/总长度\n\n当负载因子大于一定数量级的时候，也就是哈希表快要满的时候，插入数据遇到冲突的可能性就非常大。即便我们用拉链法挂载了桶，如果冲突很多的话，就容易出现上面说的效率低下问题。\n而如果我们的负载因子不大的时候，大部分情况新插入的节点都能找到它自己独立的没有冲突的映射位置，这样就大大增加了访问效率\n\n需要注意的是，哈希表的映射关系和表的长度相关\n所以当我们扩容之后，需要把当前表内的所有元素拿出来，根据键值重新进行下标映射，插入进新表。\n\n对于开放定址法，负载因子应该限制在0.8以下。java的系统库中就以0.75作为了负载因子的限制值，超过此值将进行扩容操作\n\n1.5 怎么映射？关于映射的即便理念、冲突、扩容问题我们都已经提到了。现在还有一个重要的问题，那就是怎么映射？\n如果我们插入的数据是int或者char、double这种可以强转为int的类型作为key，那还算好操作，直接用int进行下标映射即可。\n\n那假如我们用string/自定义类型来作为key呢？\n\n这种类型不能直接强制转为int，虽然string我们可以取第一个元素的ASCII码作为映射值。但是那么做的冲突会非常多，ABC/ADFC/ASD这些字符串都是以A开头，难道我们就要把它放在相同位置下面吗？那样效率也太低了！\n\n可不可以把字符串每一个字符的ASCII加起来呢？\n\n这样能解决一定程度上的冲突，但是ABC/ACB这种字符串排列不同，但是字符是相同的字符串，就会得出相同的结果造成冲突。\n\n这时候就有一个不知名的程序猿[Dennis M. Ritchie](https://baike.baidu.com/item/Dennis M. Ritchie&#x2F;1971171?fromModule&#x3D;lemma_inlink)想出来了一个超级牛逼的办法：把每一个char的ASCII都乘上一个数，再进行相加\nsize_t operator()(const string&amp; key)&#123;    size_t hash = 1;    for (auto s : key)    &#123;//每一次都*13，避免冲突        hash = hash * 13 + s;    &#125;    return hash;&#125;\n\n因为字符串的排列顺序不相同，所以每一次获得的hash值肯定是不同的，再乘上一个数之后，就完美的避免了大部分的冲突问题。\n这个方法可以沿用到所有自定义类型！比如我们之前写的日期类，就可以把年加入hash之后，乘一个数再加月，再乘一个数再加天\n这么牛逼的方法，怎么可能是不知名程序员想出来的？咳咳，实际上，Dennis M. Ritchie还有另外一个名字“C语言之父”\n\n膜拜大佬，大佬牛逼！😍\n\n在本篇博客中就不去讲解STL库中unordered_map/set的使用办法了，因为它们的使用和基础的map/set相差无几。我们直接开始模拟实现\n2.哈希表1-开放定址法2.1 插入插入的时候，我们要做的便是遵循哈希表的映射方法，对key进行映射，再将pair插入进封装好的vector中\n插入的思路如下：\n\n首先判断哈希表中是否有相同键值key的数据（此时我们写的是不支持键值冗余的哈希表，如果出现相同键值的数据，则不再进行二次插入return false（这里复用了查找函数）\n若没有这个键值，则判断负载因子的占比。这里我设置的负载因子是0.7，超过这个比例的时候，将会执行扩容操作。注意：扩容之后映射的位置会发生变化，所以我们需要对已有的数据进行重新插入。\n扩容（或不需要扩容）结束后，我们利用预先写好的仿函数获取道key的hash值，找到对应下标位置。这里采用线性探测的方法，如果当前的下标位置已经有数据了，则往后查找状态值为EMPTY/DELETE的位置，并将我们的数据插入到这个位置上。\n插入成功后，将状态修改为EXITS，return true插入结束\n\nbool Insert(const pair&lt;K, V&gt;&amp; kv)&#123;    if (Find(kv.first))//找到了相同的键值，直接退出（说明已经插入过了）    &#123;        return false;    &#125;    // 负载因子到0.7及以上，就扩容（避免冲突）    if (_tables.size() == 0 || _n * 10 / _tables.size() &gt;= 7)    &#123;        size_t newSize = _tables.size() == 0 ? 10 : _tables.size() * 2;        // 扩容以后，需要重新映射        HashTable&lt;K, V, HashFunc&gt; newHT;        newHT._tables.resize(newSize);// 扩容vector        // 遍历旧表，插入newHT        for (auto&amp; e : _tables)        &#123;            if (e._state == EXITS)            &#123;                newHT.Insert(e._kv);            &#125;        &#125;        newHT._tables.swap(_tables);        //利用vector的交换，这是一种现代写法的深拷贝    &#125;    HashFunc hf;// 仿函数的实例化    size_t starti = hf(kv.first);    starti %= _tables.size();    size_t hashi = starti;    size_t i = 1;    // 线性探测/二次探测    // 线性探测代表是自映射值开始往后依次找为空的位置    // 二次探测指跳着找为空的位置    while (_tables[hashi]._state == EXITS)    &#123;        hashi = starti + i;        ++i;//依次查找，为线性探测        hashi %= _tables.size();    &#125;    _tables[hashi]._kv = kv;//插入数据    _tables[hashi]._state = EXITS;//修改状态码    _n++;//长度+1    return true;&#125;\n\n2.2 查找和之前模拟实现的map一样，查找函数我们需要返回一个data，以便用户修改value\n因为这里我们使用的是开放定址法，没有设置桶。所以查找的操作和顺序表的查找没有本质上的区别。\n\n当映射值的位置就是我们需要找的key，直接返回当前的位置\n当当前映射值的数据不是我们需要找的key，说明这个地方出现了冲突。这时候我们现需要往后查找（线性探测，依次查找）查找的时候需要判断状态码\n如果状态码为EMPTY，则代表后面没有这个数据，返回nullptr代指找不到\n如果状态码为EXITS或者DELETE，说明后面还有可能找到这个数据找到数据后返回该数据的引用\n\n\n如果遍历完整个列表，还是没有找到该数据，同样返回nullptr\n\n这里单独说明DELETE：在insert和find操作之中，我们可能执行了删除，这时候就有可能导致原本的映射值位置和线性探测后的位置之中出现了状态码为DELETE的位置。遇到DELETE并不代表后面没有这个键值，我们需要继续查找。这点和insert的判断不同。\n\n代码实现如下\n//查找Data* Find(const K&amp; key)&#123;    //空表    if (_tables.size() == 0)    &#123;        return nullptr;    &#125;    HashFunc hf;//仿函数的实例    size_t starti = hf(key);//利用hash仿函数算出起始值    starti %= _tables.size();//进行膜大小，获取道映射值    size_t hashi = starti;    size_t i = 1;    while (_tables[hashi]._state != EMPTY)    &#123;        if (_tables[hashi]._state != DELETE &amp;&amp; _tables[hashi]._kv.first == key)        &#123;            return &amp;_tables[hashi];        &#125;        hashi = starti + i;        ++i;//线性探测        hashi %= _tables.size();    &#125;    return nullptr;&#125;\n\n2.3 删除删除操作比较简单，我们利用find找到键值后，直接把这个位置的状态码改成DELETE即可，并不需要执行释放空间的操作。\n如果没有这个键值，则返回false\n//删除，找到映射位置之后，直接修改状态码，而不是真的删除这个内容bool Erase(const K&amp; key)&#123;    Data* ret = Find(key);    if (ret)    &#123;        ret-&gt;_state = DELETE;        _n--;        return true;    &#125;    else    &#123;        return false;    &#125;&#125;\n\n\n","categories":["遇见C++"],"tags":["C++","数据结构","哈希"]},{"title":"【C++】凝视C++的第一眼","url":"/2022/04/29/code/note_cpp/1%E5%88%9D%E8%AF%86Cpp/","content":"从今天开始，正式步入C++学习的大门啦！\n\n\nC++的博客主要是我个人学习的学习笔记，刚开始会记一些比较零碎的小知识点，可能没有之前C语言的博客那么系统化😂\n笔记中可能有错误的地方，欢迎大家指出！\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n[TOC]\n1.C++简介\n你可以通过菜鸟教程网来学习C++👉传送门\n\nC++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\nC++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。\nC++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n\n2.C++关键字C语言有32个关键字，C++在它们的基础上进行了扩容，共有63个关键字\n\n\n\nasm\nelse\nnew\nthis\nauto\nenum\n\n\n\noperator\nthrow\nbool\nexplicit\nprivate\ntrue\n\n\nbreak\nexport\nprotected\ntry\ncase\nextern\n\n\npublic\ntypedef\ncatch\nfalse\nregister\ntypeid\n\n\nchar\nfloat\nreinterpret_cast\ntypename\nclass\nfor\n\n\nreturn\nunion\nconst\nfriend\nshort\nunsigned\n\n\nconst_cast\ngoto\nsigned\nusing\ncontinue\nif\n\n\ndefault\ninline\nsizeof\nvirtual\nstatic\nvoid\n\n\ndo\nlong\nstruct\nwchar_t\ndelete\nint\n\n\nstatic_cast\nvolatile\ndouble\nmutable\nswitch\nwhile\n\n\ndynamic_cast\nnamespace\ntemplate\n\n\n\n\n\n\n如果你想查看它们的完整介绍，可以参考这篇教程👉传送门\n\n这里只做一个基本的认识，后续会一一学习这些关键字\n\n3.安装你的C++环境\n如果是windows系统，建议使用微软的VisualStudio，不要用dev这种老式编译器！\n如果是mac系统，可以使用Xcode（我没有mac不知道具体情况）\n如果是linux系统，需要安装G++编译器\n\n利用我的树莓派，给大家演示一下linux环境安装G++编译器\n下面这个语句是显示g++编译器的版本，如果你弹出了和我一样的页面，说明你的linux系统里面已经有这个编译器了\ng++ -v\n\n\n如果没有，我们可以使用下面这个语句来整一个g++\nsudo apt-get install g++\n\n你也可以用这个语句来验证你的G++是否已经安装\n\n下载完成后，就可以愉快的使用你的G++编译器了\n\n如果你的下载很慢，可能要考虑换源（即更换一个软件下载源）\n树莓派实验室详细记录了国内比较好用的源，也有换源教程👉传送门\n\n\n4.C++的输入输出4.1cout和cin样例老规矩，向这个世界问个好吧！\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;    return 0;&#125;\n\n\n这里出现的endl是“end of line”的缩写，结束一行，相当于C语言中的\\n\n因为C++的编译器是完成兼容C语言的，所以你可以用&quot;\\n&quot;来替换endl\n\n\ncout是流提取操作符，对应的，也有流插入操作符cin。你可以理解为它们就是C++中的printf和scanf\n注意这里的箭头方向，不要弄错了\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;    int a;    cin &gt;&gt; a;    cout &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n\n\n4.2头文件使用这两个“库函数”时，必须要要包含iostream头文件以及std标准命名空间\n在cplusplus.com上搜索，可以看到iostream是标准输入输出流的库\n\n4.3和C语言的不同使用C++来输入输出更加方便，因为我们不需要增加格式控制符（%d %c %f这种）\n因为编译器会自己判断它们的类型\n\n同样的，我们可以使用连续的&gt;&gt;来输入多个数据\n\n4.4浮点数默认保留5位小数通过两个程序的测试，我们可以看到C++中默认保留小数是5位，而C语言中是6位\n\n\n那么问题来了，如果我想控制输出格式，让它输出小数点后两位可以怎么做呢？\n很简单，直接调用printf和%.2f不就完事了？\n\nC++中也有自己的格式控制方式，但是那个比printf更复杂\n\n\n而且在C++中打印低于5位的浮点数，并不会像C语言一样后补0\n\n注意注意！如果在C++程序中使用printf，就不能在printf里面写endl啦！\n\n5.命名空间在输入输出函数中，有这么一个语句\nusing namespace std;\n\n前面已经提到过，std是”标准命名空间”\n那什么是命名空间呢？\n\n5.1简单介绍在main函数中，如果出现了两个相同名字的参数，编译器会报错\n\n\n假设一个班级上有两个同名的同学，为了区分他们俩人，我们会使用一些附加的条件来称呼二者。比如性别、家庭住址、甚至是成绩\n\nC++中的命名空间就是用来干这个事的\n在项目合作的时候，命名空间很有用，可以有效避免两个人写的程序中出现同样名字的变量而导致冲突的情况\n5.2设置一个命名空间比如现在我们设置一个命名空间，把int a放入其中\nnamespace muxue &#123;\tint a = 1;&#125;\n\n可以看到，这个时候编译程序就不会报错了\n\n但是程序打印的是main函数中的double类型a，如果我们想用muxue中的int a要怎么操作呢？\n只需要在变量名之前用::来指定命名空间就可以了\n\n当然，我们也可以使用using namespace muxue;来直接展开这个命名空间中的所有东西\n\n但是这样不太好！后面会提到\n\n如果你定义了两个相同名字的命名空间，在编译程序的时候，编译器会合并他们\n\n5.2.1嵌套定义命名空间定义命名空间就和C语言的结构体很类似，是可以嵌套定义另外一个命名空间的\n//命名空间namespace muxue &#123;\tint a = 1;\t//嵌套定义命名空间\tnamespace happy &#123;\t\tint b = 2;\t&#125;&#125;int main() &#123;\tdouble a = 3.14;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; muxue::a &lt;&lt;endl;\tcout &lt;&lt; muxue::happy::b &lt;&lt; endl;\treturn 0;&#125;\n\n\n直接展开两个命名空间后，就不需要这样写输出函数了\n\n\n我们还可以在已有命名空间中嵌套定义一个命名空间，里面包含另外一个a\nnamespace muxue &#123;\tint a = 1;\t//嵌套定义命名空间\tnamespace happy &#123;\t\tint a = 2;\t&#125;&#125;\n\n这时候如果使用using namespace muxue;，在main函数中会默认打印外层命名空间中的a\n\n但如果你比较喜欢作死，把内层命名空间也展开了，就会出现冲突\nusing namespace muxue;using namespace muxue::happy;\n\n\n\n除了嵌套定义中这种冲突的情况，我们直接展开命名空间时，还会遇到其他冲突\n5.3全部展开可能遇到的问题5.3.1和库函数冲突比如下面这个情况，我们在muxue里面定义了一个int类型叫做rand，并在之后直接using namespace完整展开了这个命名空间\n#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;namespace muxue &#123;\tint a = 1;\tint rand = 0;&#125;using namespace muxue;int main()&#123;\ta += 1;\tcout &lt;&lt; a &lt;&lt; endl;\trand = 10;\tprintf(&quot;%d\\n&quot;, rand);\treturn 0;&#125;\n\n然后你就会发现，程序boom了！\n\n这是因为在&lt;stdlib.h&gt;头文件中有一个生成随机数的rand函数，现在程序不知道你是要用命名空间中的变量rand，还是想调用这个库函数了！\nmuxue::rand = 10;printf(&quot;%d\\n&quot;, muxue::rand);\n\n这时候我们就要选择单独调用命名空间中的rand变量，而不是直接使用变量名\n\n同时，顶部的using namesapce也需要做相应修改\n//using namespace muxue;using muxue::a;\n\n5.3.2和其他命名空间冲突namespace muxue &#123;\tint a = 1;\tint rand = 0;&#125;namespace haha &#123;\tint a = 3;&#125;using namespace muxue;using namespace haha;\n\n假设两个命名空间中都有a变量，这时候程序也不知道你要调用哪一个a了，同样会报错\n\n\n这就好比班级里有俩个叫李华的人，本来一个是男的，一个是女的，咱们可以用性别区分\n直接完整展开了命名空间，就好比让这两个李华都变成男生\n这不BBQ了吗？还怎么用性别判断谁是谁？\n\n所以在很多时候，尽量使用::单独展开某一个变量，而不是展开整个命名空间\n这种冲突的情况，被称为命名空间污染\n\n5.4避免命名空间污染在菜鸟教程上，可以看到有大佬做了一个这样的笔记\n\n是的，有的时候我们自定义的变量类型名会和std标准命名空间冲突，这时候直接在最前面using namespace std;就会出5.3中提到的问题\n可cout和cin这两个家伙天天要用，总不能每一次使用的时候，都写一个std::吧？那样也太麻烦了！\n别急，我们也可以单独展开这几个小家伙！\nusing std::cin;using std::cout;using std::endl;\n\n\n其他一些问题在之前5.2和5.3都已经提到过了，这里就不再说啦！\n个人理解，即便C++有命名空间这个好东西，在定义变量的时候最好还是保持一个良好的编程习惯，不用关键字和库函数名作为变量名\n5.5 ::指定全局作用域当我们默认使用::而不在前面添加命名空间的名字的时候，默认会指定到全局的命名空间。即便函数被另外一个命名空间所包裹，也是会调用全局作用域下的函数\n//全局void _print()&#123;    cout &lt;&lt; &quot;global print&quot; &lt;&lt; endl;&#125;//命名空间namespace muxue&#123;    void _print()    &#123;        cout &lt;&lt; &quot;namespace muxue print&quot; &lt;&lt; endl;    &#125;     void testNamespace()    &#123;        ::_print();//调用全局作用域的函数    &#125;&#125;int main()&#123;    muxue::_print();//调用命名空间内的print    muxue::testNamespace();     return 0;&#125;\n\n打印的结果如下\n\n\n6.缺省参数缺省参数是函数在定义的时候，给指定的参数一个默认值，如果没有指定实参，就会使用这个默认值。比如：\n//缺省参数void Add(int a = 10,int b = 20) &#123;\tcout &lt;&lt; a + b &lt;&lt; endl;&#125;int main() &#123;\tint n = 1, m = 2;\tAdd(n, m);//指定了实参\tAdd();//没有指定\treturn 0;&#125;\n\n\n除了这两种方式外，我们还可以只给该函数传一个实参\n\n但是像下面这样，想给函数中的b传一个参数是不可以的\n\n6.1全缺省和半缺省\n像上面这种，函数中的所有形参都设定了缺省值的，叫做全缺省\n函数中只有一部分设置了缺省值的，叫做半缺省\n\n注意：设置缺省参数的时候，必须从右往左设置，不能出现中间空一个的情况\n\n6.1.1全缺省比如这么一个有3个参数的函数，我们全部设置了缺省值，就是全缺省\nvoid Print(int a = 10, int b = 20,int c=30) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; c &lt;&lt; endl;&#125;\n\n我们可以直接传3个值，进行对应的打印，也可以只传两个、一个或者不传形参\n\n这种中间间隔一个传参是不允许的\n\n\n6.1.2半缺省半缺省是缺省了一部分的函数\nvoid Print2(int a, int b = 20, int c = 30) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; c &lt;&lt; endl;&#125;\n\n在调用的时候，我们就不能不传参数了\n\n至少要传一个参数给我们的a\n\n半缺省的函数可以是如下形式\nvoid Print2(int a, int b = 20, int c = 30);void Print2(int a, int b, int c = 30);\n\n但不能是这样\nvoid Print2(int a=10, int b, int c = 30);\n\n因为这种情况会出现歧义，编译器不知道你的参数是给b还是给a\n\n6.2缺省参数的应用比如在创建一个顺序表的时候，我们可以利用缺省参数来设置默认长度\n这样就避免了单一默认长度导致的多次扩容（realloc扩容是有性能浪费的！）\n\n\n比如我知道我这次需要一个很长的顺序表，直接改默认长度不太合适。使用这种方法传一个新的长度值更加方便我们的动态管理！\n\n缺省参数是只有C++才支持的函数定义方式，这也是C++比C语言更优的体现\n6.3多文件编程中的缺省使用多文件编程的时候，缺省值只需要在头文件中给出即可\n\n不需要在函数定义的源文件中给出，编译器会报错\n\n假设函数的声明和定义中设定的缺省值不同，编译器就不知道要用哪一个缺省值\n\n\n调用函数，可以看到函数正确分配了不同的初始值\n\n\n6.3.1错误情况但如果我们在头文件中不包含缺省，函数就会报错，不支持我们只传1个参数\nvoid InitArr(Qa* q, int n);\n\n\n只要你的头文件中声明没有缺省， 在函数定义的源文件中加入缺省也是没用的！\n\n因为编译器展开头文件是在main函数中之上，在查找函数的时候，只会向上查找声明。所以函数的声明是以头文件为准！\n\n\n\n结语第一篇C++的笔记就写这么多（其实已经有几千字了）\n下一篇笔记是函数重载，可以让你感受到C++的更多花样！\n\n不会有人把博客看完了还不点赞吧？\n\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】异常处理","url":"/2022/10/03/code/note_cpp/21%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","content":"本篇博客让我们来认识一下C++中对于异常的处理机制\n\n\n[TOC]\n1.概念1.1 C语言对于异常的处理在之前我们遇到一些bug的时候，通常会用if判断或者assert断言等问题进行处理。但这种方式太过暴力，会直接中断程序的运行\n另外一种办法是返回错误码，C语言的报错大多使用这种方式。不过这需要程序的用户自己去查对应的错误码表格，较为麻烦\n\n1.2 C++异常所谓异常，便是程序运行过程中可能遇到的bug或者问题。程序可以有选择地抛出一个异常，告知用户程序运行出现了问题。\nC++标准库中便使用了一个exception类来进行异常的处理，我们运行程序中遇到的一些报错，其实就是标准库里面抛出了对应的异常\n\n其操作主要借助下面三个关键字\n\nthrow 在出现问题的地方抛出异常\ntry 监控后续代码中出现的异常，后续需要以catch作为结尾\ncatch 用于捕获异常，同一个try可以用多个不同类型的catch进行捕获\n\nthrow关键字可以抛出任意类型的异常\n2.基本操作下面用除法函数，以除0的情况来做一个最简单的演式\nint Div()&#123;\tint a, b;\tcin &gt;&gt; a &gt;&gt; b;\tif (b == 0)\t\tthrow &quot;div 0 err!&quot;;\treturn a / b;&#125;int main()&#123;\ttry &#123;\t\tcout &lt;&lt; Div() &lt;&lt; endl;\t&#125;\tcatch(const char* s)&#123;\t\tcout &lt;&lt; s &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n\n2.1 需要注意的点这里有几个需要注意的点：\ncatch类型对应当我们进行抛异常的时候，一定需要有对应类型的catch，否则会报错\n比如我们throw的是一个常量字符串，如果用string来catch，就会因为类型不匹配而出现报错\n\n所以当我们使用某一个会抛异常的函数的时候，一定要注意其抛出异常的类型\n\n利用…进行全捕获假设我们不知道这里面会抛出什么类型的错误呢？总不能把所有类型都catch一下吧？\n当然不需要，我们可以使用下面的函数进行全捕获\n\n这就可以用于当我们不知道报错类型的时候。不过一般的使用场景是，在这之前先catch已知的错误类型，最后再加上一个全捕或，作为未知错误的标识\n不过catch(...)有一个缺点，那便是我们不能知道异常的类型\n\n基类捕获派生类的异常当我们出现异常的时候，如果throw了一个子类对象，可以用基类的引用来接收！\nclass A &#123;\tint a;&#125;;class B : public A &#123;\tint b;public:\tB()\t\t:b(1)\t&#123;&#125;&#125;;void testab()&#123;\tB bt;\tthrow bt;&#125;int main()&#123;\ttry &#123;\t\ttestab();\t&#125;\tcatch (A&amp; e) &#123;\t\tcout &lt;&lt; &quot;err class A&quot; &lt;&lt; endl;\t&#125;\tcatch (...) &#123;\t\tcout &lt;&lt; &quot;err&quot; &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n\n这个在进行继承多态的错误编写的时候就很有用啦\n2.2 异常和栈帧抛出异常后，会被离这个异常最近的catch捕获，如果没有任何catch则会报错\n\n比如我们单独写一个函数，而这个函数体内有try/catch的话，那么会直接和这个最近的匹配，并不会和main函数里面的匹配\n\n而如果该函数里面没有进行此操作，则会直接到main的对应catch处\n\n注意！这里是直接跳转到对应catch语句，并不会出现先跳到testCatch函数在跳回main的情况！\n2.3 重新抛出异常假设我们遇到了这种情况\nvoid testab()&#123;\tB bt;\tthrow bt;&#125;void testD()&#123;\tint* arr = new int[10];\ttestab();\tdelete[] arr;&#125;\n\n在testab()函数中抛出了异常，导致testD()函数提前终止！\n\n可我们new的东西还没释放呢！\n这就出现了内存泄漏！\n\n注意：内存泄漏是一个不能被忽略的问题，即便我们每一次new的空间很小，但是积小成多就是大问题！\n\n这时候我们就需要提前进行异常处理，如果出现问题，先释放我们new的资源之后，再将异常重新抛出。可以理解为是提前拦截异常\n\n3.异常需要注意的一些问题3.1 异常安全当我们操作异常的时候，需要注意一些相关的问题\n\n上面2.3中提到的内存泄露问题，在new和delete之间抛出异常而没有中途处理，导致内存泄漏\n不要在构造或析构函数中抛出异常，否则可能导致对象不完全初始化（对象不完整）或不完全析构（内存泄漏）\n多线程操作中在lock与unlock之间抛出异常，导致死锁\n\n当然是有解决方案的，C++使用RAII来解决上述问题，这个待我下一篇智能指针的博客来讲解！\n3.2 异常规范因为异常都是手动写代码进行处理的，那么就极其需要些代码的老哥拥有很好的编程规范。\n\n在函数后加上throw(类型A，类型B)可以列出这个函数能抛出的所有异常类型\n\nvoid test() throw(string,vector&lt;int&gt;);\n\n\n如果只跟一个类型，代表该函数只会抛出一种类型的异常\n\nvoid* operator new(size_t size) throw (std::bad_alloc);\n\n\n如果跟的是throw()代表这个函数不会抛出异常\n\nvoid* test2(size_t sz, void* p) throw();\n\n在C++11中还新增了一个关键字noexcept来标识不会抛出异常\nvoid* test2(size_t sz, void* p) noexcept;\n\n但是这些都依赖于用户的编程习惯，C++并没有强制用户一定要在函数尾部写上异常抛出的类型。\n那在项目合作中，来了一个“实习生”\n\n写了一个会抛出异常的函数，却没有标识该函数会抛异常，那下面调用该函数的地方没有进行异常处理，那不就蛋糕了，程序提前中止！\n或者说是抛出异常的类型写错了，没有对应的异常处理语句，只能被catch(...)捕获\n或者是明明不抛出异常非要写自己抛出，白写了异常处理\n\n以上三种情况都是我们不期望遇到的，所以在写相关函数的时候，最好明确标识相关异常抛出的类型！\n3.3 自定义异常类型要是在协作中，不同用户抛出了太多不同类型的异常，那还怎么调用函数？\n前面提到了，子类抛出的异常可以用基类接受。所以在项目中一般都是会定义一个继承的规范异常体系，用于处理不同的异常。\n这样我们就只需要捕获一个基类对象，就能捕获到所有派生类的异常对象。\n关于基类捕获子类异常的方法在2.1中已经提及，这里不再演示\n\n3.4 C++标准库中的异常在C++标准库中，异常是围绕下图组织的\n\ncplusplus：https://legacy.cplusplus.com/reference/exception/exception/?kw=exception\n\n\n标准异常类的成员：\n\n在上述继承体系中，每个类都有提供了构造函数、复制构造函数、和赋值操作符重载。\nlogic_error类及其子类、runtime_error类及其子类，它们的构造函数是接受一个string类型的形参，用于异常信息的描述\n所有的异常类都有一个what()方法，返回const char* 类型描述异常信息\n\n标准异常类的具体描述：\n\n\n\n异常名称\n描述\n\n\n\nexception\n所有标准异常类的父类\n\n\nbad_alloc\n当operator new and operator new[]，请求分配内存失败时\n\n\nbad_exception\n这是个特殊的异常。如果函数的异常抛出列表里声明了bad_exception异常，而函数内部抛出了异常抛出列表中没有的异常，不论什么类型，都会被替换为bad_exception类型\n\n\nbad_typeid\n使用typeid操作符，操作一个NULL指针，而该指针是带有虚函数的类，这时抛出bad_typeid异常\n\n\nbad_cast\n使用dynamic_cast转换引用失败的时候\n\n\nios_base::failure\nio操作过程出现错误\n\n\nlogic_error\n逻辑错误，可以在运行前检测的错误\n\n\nruntime_error\n运行时错误，仅在运行时才可以检测的错误\n\n\nlogic_error的子类：\n\n\n\n异常名称\n描述\n\n\n\nlength_error\n试图生成一个超出该类型最大长度的对象时，例如很长的string\n\n\ndomain_error\n参数的值域错误，主要用在数学函数中。例如使用一个负值调用只能操作非负数的函数\n\n\nout_of_range\n超出有效范围，vetor的at抛出了此异常\n\n\ninvalid_argument\n参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常\n\n\nfuture_error(C++11)\nThis class defines the type of objects thrown as exceptions to report invalid operations on future objects or other elements of the library that may access a future‘s shared state.\n\n\nruntime_error的子类：\n\n\n\n异常名称\n描述\n\n\n\nrange_error\n计算结果超出了有意义的值域范围\n\n\noverflow_error\n算术计算上溢\n\n\nunderflow_error\n算术计算下溢\n\n\nsystem_error(C++11)\n运行时从操作系统或其他具有关联error_code的低级应用程序接口引发的异常\n\n\n以上部分C++标准库异常解释来自https://blog.csdn.net/linxi8693/article/details/90318166\n\n4.异常优缺点优点\n\n异常对象定义完备之后，相比于错误码的方式，能让用户更加清楚的了解到自己遇到了什么类型的问题，更好定位程序的bug\n函数错误码若遇到，需要层层向外返回；而异常则通过catch可以直接跳到对应处理位置\n第三方库包含异常，我们在使用类似于boost/gtest等第三方库的时候也需要使用对应的异常处理\n对于T&amp; operator[]这种操作符重载，我们没办法很好地使用返回值来标识错误（因为不同类型的返回值不一样，没办法统一处理）这时候就可以用异常来抛出越界问题\n\n缺点\n\n异常可能会导致程序到处乱跳（因为会跳到最近的catch位置）给观察错误情况增添了一些难度\n异常有一定性能开销（可忽略）\n异常容易导致资源泄漏等等问题\n异常依赖于用户编程规范，否则函数调用容易出现异常没有得到处理的问题\n\n\n结语总体而言，异常处理利大于弊。很多语言都是用异常来处理错误的，比如python。只要维持一个良好的编程习惯，在函数后声明会抛出的异常类型，针对性进行处理，还是很香的！\n\n","categories":["遇见C++"],"tags":["C++","C++11","异常"]},{"title":"【C++】C++11的那些新特性","url":"/2022/09/28/code/note_cpp/20C++11%E7%89%B9%E6%80%A7/","content":"本篇博客，让我们一起来看看C++11的那些新特性！\n\n\n\n所使用的编译器：VS2019\n本篇博客所有的测试源码都可以在我的GITEE仓库找到 \n\n[TOC]\n1.前言C++11是C++的标准委员会在2011年更新的C++新特性。说白了就是一个升级包。和JAVA\\PYTHON这种更新比较频繁的语言相比，C++更新的就没有那么顺风顺水了，而且每一次更新虽然修复了一些问题，但也带来了更多的“没太大必要”的更新\n\n比如没啥用的array容器，和int arr[10]这种内置方式的区别主要在于越界检查\n\n不过咱们这种小菜鸡，只有学习的权力，哪有啥资格评定C++标准呢？我听大佬说，现在最关注的C++更新便是网络库的上线了，不过那个貌似得等到C++23去了\n话不多说，让我们来康康一些C++11的新功能吧！\n\n2.列表&#123;&#125;初始化C++11更新了初始化方式，不管是什么类型的数据，我们都可以用花括号的方式进行初始化\nstruct TestA&#123;\tint _a;\tint _b;&#125;;void TestInit()&#123;\tint arr1[] = &#123; 1,2,3,4,5 &#125;;\tTestA t1 = &#123; 1,2 &#125;;&#125;\n\n之前我们已经习惯于用这张方式来初始化数组或者结构体，这在C++98中已经支持\n而C++11则在这种玩法之上，又增添了一部分新操作，那就是直接用花括号初始化，你甚至可以把=给省略了\nint arr2[]&#123; 1,2,3,4,5 &#125;;int arr3[5]&#123; 0 &#125;;TestA t2&#123; 1,2 &#125;;\n\n不过上面这种写法没有什么意义，还增加了代码理解的难度，不如直接用原本的写法。\n更多时候，我们是在new初始化多个数据的时候使用这种方式。\n2.1 new初始化多个数据在动态内存管理那一章节，我们学习了new的两种使用方式，也提到了()/[]这两个括号的区别\nint *p1 = new int(3);//开辟一个int的空间，并初始化为3赋值给p1int *p2 = new int[3];//开辟3个int的空间，不进行初始化\n\n在C++11中，我们可以直接用花括号，对new开拼出来的数组进行批量初始化。打印的时候，可以看到p2中的数据都是没有进行初始化（vs也报了警告）而p3中的数据都完成了初始化\n\n对于结构体数据而言，我们可以用花括号直接调用其构造函数\n\n其中t5是发生了隐式类型转换+调用构造函数进行的初始化\nTestA t5 = &#123; 1, 3 &#125;;//对类来说，会进行隐式类型转换+调用构造函数\n\n通过调试+打断点可以看到其调用了构造函数进行初始化\n\n同样的，调用new的时候，我们可以用多个花括号的方式进行批量初始化。这在new一个对象数组的时候非常方便\n\n2.2 initializer_list2.2.1 STL容器初始化不光是我们自己写的类、内置类型可以使用这种方式进行初始化，stl库里面的容器也可以使用相同方式进行初始化\nvector&lt;int&gt; v1 = &#123; 1,2,3,4 &#125;;vector&lt;int&gt; v2&#123; 1,2,3,4 &#125;;//不建议这么写\n\n\n同样的，我们还可以用类似的方式初始化vector内部的对象\n\n作为容器的一份子，map也有一个利用il进行初始化的构造函数\n\n使用方式和之前提到的没啥区别，这里就不多讲啦\nmap&lt;int, int&gt; m1 = &#123; &#123;10, 20&#125;,&#123; 30,40&#125;,&#123;50,60&#125; &#125;;for (auto e : m1) &#123;\tcout &lt;&lt; e.first &lt;&lt; &quot;-&quot; &lt;&lt; e.second &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;\n\n\n你可能会好奇，这种初始化的底层是怎么实现的？那么就要提到c++11新增的一个容器了\n2.2.2  initializer_list 容器如果你把vector等容器的版本设定为C++11，看文档的时候便会发现C++11新增了一个用initializer_list进行初始化的操作\n\n\n再来看看initializer_list，这不就是我们刚刚用的花括号嘛？\n\n这个容器的成员函数很少，只有两个迭代器以及size()\n\n它最重要的特性，便是当我们使用auto自动推到参数类型的时候，&#123;1,2,3,4&#125;这种类型会被推到成initializer_list\nauto il = &#123; 10, 20, 30 &#125;;cout &lt;&lt; typeid(il).name() &lt;&lt; endl;//initializer_list \n\n因为他有迭代器，所以我们也可以使用范围for进行打印操作\n\n个人理解，当其他容器使用initializer_list进行初始化的时候，本质上调用的接口和利用迭代器进行初始化是一样的\n2.3.1 插入il部分容器的insert函数也添加了使用il进行插入连续数据的操作\n\nset&lt;int&gt; s2 = &#123; 1,2,3,4 &#125;;s2.insert(&#123; 5,6,7,8 &#125;);\n\n\n在vector中使用il插入的时候，需要指定pos位置这个和vector的其他几个插入函数是一样的\n\n2.4 模拟实现il构造函数那么，如何让我们自己模拟实现的vector也能支持这个功能呢？【模拟实现vector源码】\n和STL库里面的代码一样，添加上initializer_list的构造函数即可\n因为il容器已经有了它自己的迭代器，我们完全可以复用迭代器构造的操作，直接进行遍历然后push_back即可！\n//initializer_list构造vector(const initializer_list&lt;T&gt;&amp; il)    :_start(nullptr),    _finish(nullptr),    _endofstorage(nullptr)&#123;    for (auto e : il) &#123;        push_back(e);    &#125;&#125;\n\n\n试试自定义类型，也可以很好的支持！\n\n这里还有一个优化的地方，那便是开始构造的时候，直接给vector开对应il size()的空间大小，避免后续push_back的时候需要多次扩容\n//initializer_list构造vector(const initializer_list&lt;T&gt;&amp; il)    :_start(nullptr),_finish(nullptr),_endofstorage(nullptr)&#123;    reserve(il.size());//扩容    for (auto e : il) &#123;        push_back(e);    &#125;&#125;\n\n通过调试能发现达成了我们的需求（因为调试步骤太多，截图不方便，这里就不演示了。感兴趣的老哥可以去我的gitee仓库下源码自己试试）\n3.变量声明C++11提供了多种简化的声明/定义方式，比如我们熟悉的auto\n3.1 auto\nC++98中auto是一个存储类型的说明符，表明变量是局部自动存储类型，但是局部域中定义局 部的变量默认就是自动存储类型，所以auto就没什么价值了。\n\nC++11给auto上了实现自动类型推断的全新功能，方便我们在定义一个变量的时候直接用auto进行类型推导\nauto num = 1;//intauto p = &amp;num;//int*\n\n需要注意的是，如果想用auto推到，则必须初始化。只给一个auto i是不行的！\nauto还可以用于范围for等其他操作，这些都在之前讲解这个关键字的博客中有提到，这里就不多说了！\n\n3.2 decltype关键字decltype可以把变量声明成我们想要的目标类型\nint a = 10, b = 20;int sum = a * b;cout &lt;&lt; &quot;type(sum) &quot; &lt;&lt; typeid(sum).name() &lt;&lt; endl;decltype(a * b) num;decltype(&amp;sum) ptr;cout &lt;&lt; &quot;type(a*b)  &quot; &lt;&lt; typeid(num).name() &lt;&lt; endl;cout &lt;&lt; &quot;type(&amp;sum) &quot; &lt;&lt; typeid(ptr).name() &lt;&lt; endl;\n\n\n怎么样，是不是觉得很神奇？很方便？\n那让我们来看看另外一个语言声明变量的方式吧！😂\n# Pythona=10sum = a*20print(type(a))print(type(sum))\n\n\n要是C++也有这么方便就好了😭\n3.3 typeid这个关键字上面已经用过好几次了，就是用来打印变量的类型的\nint a = 10;cout &lt;&lt; &quot;type(a) &quot; &lt;&lt; typeid(a).name() &lt;&lt; endl;\n\n\n4.左&#x2F;右值引用在之前我们学习了引用的基本操作，但那个是左值引用。当时我们尚未引入左指引用和右值引用的区别。本篇博客里面将会详细讲解~\n4.1 左值&#x2F;右值区别要解答这两种引用的区别，首先我们需要直到左值/右值分别代指什么\n左值：\n\n可以存在于=左边或右边\n可以取地址\n可以对它赋值（const除外）\n\n右值：\n\n右值是一个表示数据的表达式，比如：函数返回值[不能是左值引用返回的]、表达式返回值A+B、字面常量10\n右指只能出现在=的右边，不能出现在左边（俺可没见过A+B=C的代码语法）\n右指不能取地址\n\n左值和右值最大的区别便是：左值可以取地址，右值不能取地址\n4.1.1 将亡值（概念）右值还分为两种情况：\n//纯右值10;a+b;Add(a,b);//将亡值string s1(&quot;1111&quot;);//&quot;1111&quot;是将亡值string s2 = to_string(1234);//to_string的return对象是一个将亡值string s3 = s1+&quot;hello&quot; //相加重载的return对象是一个将亡值move(s1);//被move之后的s1也是将亡值\n\n在右值引用的介绍中将用上将亡值的概念\n4.2 左值引用左值引用就是对左值的引用。我们之前学习的就是这一类型\n// a、b、c、*a都是左值// 对象内部的*this也是左值int* a = new int(0);int b = 1;const int c = 2;// 以下是对上面左值的 左值引用int*&amp; rp = a;int&amp; rb = b;const int&amp; rc = c;int&amp; p = *a;// 引用相当于别名，修改引用后的内容相等于修改原本的参数\n\n之前也提到了，其作用主要是在针对出了作用域不会销毁的变量进行引用返回，以节省拷贝的代价。亦或者是引用传参，减少形参拷贝代价\n\n4.3 右值引用来看看几个比较常见的右值吧，其中Add是一个简单的相加函数\ndouble x = 1.1, y = 2.2;// 常见的右值10;x + y;Add(x, y);// 以下都是对右值的右值引用int&amp;&amp; rr1 = 10;double&amp;&amp; rr2 = x + y;double&amp;&amp; rr3 = Add(x, y);//右值不能出现在=的左边//10 = 1;//x + y = 1;//fmin(x, y) = 1;\n\n虽然我们不能直接对右值进行取地址/赋值操作，但是在右值引用过后，便可以对引用值进行取地址/赋值操作\n\n这是因为右值引用的时候，会把当前引用的数据放入一个位置存起来。\n存放位置：普通变量在栈，全局变量&#x2F;静态变量在静态区（没有验证过，可能不对）\n\nint&amp;&amp; rr1 = 10;cout &lt;&lt; rr1  &lt;&lt; endl;rr1 = 3;cout &lt;&lt; rr1 &lt;&lt; endl;int* p = &amp;rr1;*p = 2;cout &lt;&lt; rr1 &lt;&lt; endl;\n\n\n如果你不喜欢右值引用被修改，则可以使用const进行修饰\n\n4.4 两个引用的区别用一个表格来总结二者的区别\n\n\n\n左值引用\n右值引用\n\n\n\n只能引用左值\n只能引用右指\n\n\nconst可以引用左值&#x2F;右值\n可以引用move后的左值\n\n\n4.4.1 movemove可以把左值换成右值，但不能把右值转左值\n\n谨慎使用move，如果当前对象在后续还需要使用，则不能move将其改为右值，否则可能资源被掠夺导致该对象失效！\n\n\n4.5 右值引用使用场景右值引用可以提高移动构造/移动赋值等深拷贝场景的效率\n什么场景可以使用左值引用提高效率?\n\n操作符重载：前置++\n操作符重载：+=\n出了作用域后不会销毁的变量，如输出型参数（即传入函数进行处理的参数）\n\n而有一些场景是左值引用无法处理的：\n\n操作符重载：后置++（需要返回一个全新变量）\n操作符重载：+（需要返回一个全新变量）\n模拟实现string中的to_string函数\n\n这些场景大多有一个特性，那就是会生成一个全新的变量（对象）其对象生命周期出了函数作用域便会销毁（将亡值）\n如果使用左值引用返回，就会出现访问已经销毁了的对象的错误。\n\n假设我们有一个vector&lt;vector&lt;int&gt;&gt;，若内部的vector很大的时候，拷贝构造的代价是很大的！\n\n4.5.1 输出型参数如果在C++98的情况下，我们只能用输出型参数来解决这个问题\nvector&lt;vector&lt;int&gt;&gt;&amp; test(vector&lt;vector&lt;int&gt;&gt;&amp;v1,int val)&#123;    //……    //v1就是一个输出型参数。放入该函数进行操作后原路返回    return v1;&#125;\n\n4.5.2 右值引用 移动构造在C++11中，我们可以使用右值引用的拷贝构造来解决这个问题\n下方就是一个具体示例\nmuxue::string to_string(int val)&#123;    bool flag = true;    if (val &lt; 0)&#123;        flag = false;        val = 0 - val;    &#125;    muxue::string str;    while (val &gt; 0)&#123;        int x = val % 10;        val /= 10;        str += (&#x27;0&#x27; + x);    &#125;    if (flag == false)&#123;       str += &#x27;-&#x27;;    &#125;    std::reverse(str.begin(), str.end());    return str;&#125;\n\n在默认情况下，如果想使用这个to_string函数，就需要进行深拷贝进行传值返回。这是无可避免的代价\n如果使用左值引用返回，这里就会有bug。因为出了函数作用域后，临时对象str会被销毁。而如果我们使用左值引用取别名，在进行赋值的时候，便会出现利用str的别名进行拷贝构造，而str是一个已经销毁的对象的问题\n\n而如果我们使用右值引用返回，则不会出现这种问题。前提是我们自己实现了右值引用的构造函数和赋值重载\n\n一般我们把右值引用的构造函数&#x2F;赋值重载称作移动构造/移动赋值\n\n为什么叫移动呢？因为右值引用是会直接拿取对象的资源\nSTL_string我们可以先用库里面的string观察一下，当我们使用move之后的右值进行构造的时候，会直接拿掉对象的资源！\nstring s1 = &quot;1234134&quot;;string s2(s1);string s3(move(s1));\n\n\n\n而在使用右值进行返回的时候，编译器会进行一波优化，直接使用移动构造拿取资源，避免多次拷贝构造造成的空间和时间损失\n在处理这种问题的时候，就比输出型参数好太多了。\n\nMY_string不过库里面的string涉及到了buf之类的高级操作，也不适合我们调试查看调用的具体情况。所以这里我们再使用自己写的string来演示一下\n\n这里我还发现了之前模拟实现string的一个bug，在push_back操作的时候，没有给末尾加上\\0，导致析构的时候报错了\n\n模拟实现string代码见我的gitee仓库【传送门】\n\n\n在演示之前，我们先要实现自己的移动构造/移动赋值\n//移动赋值string&amp; operator=(string&amp;&amp; s)&#123;    swap(s);    return *this;&#125;//移动拷贝string(string&amp;&amp; s)    :_a(nullptr),    _size(0),    _capa(0)&#123;    swap(s);&#125;\n\n这里我直接复用了之前已经写好的一个swap函数，实现了一个“现代写法”的构造，直接交换了二者的资源。避免深拷贝带来的副作用\n\n接下来用下面的几个来测试一下拷贝构造的操作\nmuxue::string s1 = &quot;1234&quot;;muxue::string s2(s1);//拷贝构造muxue::string s3 = muxue::to_string(5678);//移动构造muxue::string s4 = s1 + s3;//拷贝构造+移动构造\n\n通过在构造函数中添加打印，可以看出这几个分别调用了什么构造函数\n\n\ns2调用了深拷贝构造，因为s1是一个左值\ns3调用了移动构造，因为to_string函数中return的是一个将亡值\ns4先是在运算符+重载中调用深拷贝构建了一个string的临时对象，在使用移动构造进行return\n\n运算符+重载的代码如下，和to_string一样，都是return了一个将亡值\n//相加重载string operator+(const string&amp; s)&#123;    muxue::string tmp(*this);    tmp += s;    return tmp;&#125;\n\n将一个对象move成为右值之后，便可以使用移动赋值\n\n移动构造直接移动资源这时候如果调用拷贝构造，就很是浪费：\n\n本来tmp的资源就要销毁了，你还得先把他的资源复制一份给自己，再销毁tmp\n那为何不把tmp的资源直接拿给自己呢？省去了复制的消耗！\n\n这便是移动构造的优势之处！\n调试体现出来的，便是深拷贝中两个对象_a的地址完全不同\n\n而移动构造是直接把s1的_a资源拿了过来！\n\n其最明显的特征，便是s3的_a地址就是s1的！\n\n\nSTL的更新如果我们把自己模拟实现的移动构造删除，那么所有的return都会去调用深拷贝，代价就很大了。对象很大的时候，来一次深拷贝有可能可以把整个系统干废😂\n\n所有STL的容器，在C++11之后，都支持了右值引用的插入、移动构造和移动赋值\n\nC++11的swap也提供了一个直接使用右值进行资源替换的版本，效率更高\n\n4.6 编译器优化在之前有关构造函数的博客里面有提到过，当我们return一个对象的时候，编译器会把两次拷贝构造优化成一次\n\n和拷贝构造一样，执行移动构造的时候，编译器也有一定的优化\n\n不过这个优化就取决于编译器的处理了。不排除有些编译器没有做此等处理哦！\n4.7 优化插入效率有了右值引用，只要我们实现一个右值引用方式的插入，也可以优化插入时的效率\nmuxue::list&lt;muxue::string&gt; t;muxue::string s1(&quot;111&quot;);//调用拷贝构造，左值t.push_back(s1);//调用移动构造，右值t.push_back(&quot;222&quot;);t.push_back(std::move(s1));\n\n5.完美转发c++11提供了一个万能引用，既可以引用左值，也可以引用右值\nvoid Fun(int&amp; x) &#123;     cout &lt;&lt; &quot;左值引用&quot; &lt;&lt; endl; &#125;void Fun(const int&amp; x) &#123;     cout &lt;&lt; &quot;const 左值引用&quot; &lt;&lt; endl; &#125;void Fun(int&amp;&amp; x) &#123;     cout &lt;&lt; &quot;右值引用&quot; &lt;&lt; endl; &#125;void Fun(const int&amp;&amp; x) &#123;     cout &lt;&lt; &quot;const 右值引用&quot; &lt;&lt; endl; &#125;template&lt;typename T&gt;void test(T&amp;&amp; t)&#123;//T&amp;&amp;就是一个万能引用\tFun(t);&#125;\n\n通过测试我们会发现，不管是传入一个左值还是传入一个右值，其都会调用左值引用\n\n这是因为右值引用之后，形参t就是一个左值，所以调用了左值的函数\n\n我们也不能粗暴的使用move来解决这里的问题，因为有时候一些左值对象在后续还是需要使用的，move之后变成右值，资源被拿走了咋办！\n&gt;template&lt;typename T&gt;&gt;void PerfectForward(T&amp;&amp; t)&gt;&#123;   Fun(std::move(t));&gt;&#125;\n\n\n\n而完美转发的存在就是为了将右值保持其右值属性，依旧调用右值对应的函数，其语法如下，使用forward函数进行完美转发\ntemplate&lt;typename T&gt;void PerfectForward(T&amp;&amp; t)&#123;    Fun(std::forward&lt;T&gt;(t));&#125;\n\n这时候第二种情况就正确掉用了对应的右值引用函数，也没有改变左值的属性\n\n再把函数改成我们自己写的string，也能看出完美转发的作用\ntemplate&lt;typename T&gt;void PerfectForward(T&amp;&amp; t)&#123;\tmuxue::string s = std::forward&lt;T&gt;(t);&#125;\n\n\n\n5.1 使用场景有些场景下，我们需要对一个函数传入不同类型的参数，这时候就需要用万能引用+完美转发来进行不同的处理\n比较典型的便是很多STL容器都提供了一个新的尾插函数emplace_back\n\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n这里便使用了万能引用，以及可变模板参数（后面会写道）\n利用我们自己写的string进行打印，即可看出二者的区别\n\n\nemplace_back直接调用了构造函数\npush_back 构造+移动构造\n\n因为移动构造的效率是很高的，所以这两种方式的差距并不算很大。不过差距肯定是有的，如果为了兼容性，使用push_back肯定更好，因为emplace是C++11新增的操作\n\n6.新增的默认成员函数在初识类和对象的时候，我便在博客中提到了C++的几个默认成员函数\n\n构造函数 \n析构函数 \n拷贝构造函数 \n拷贝赋值重载 \n取地址重载 \nconst 取地址重载\n\n在C++11中也多了两个成员函数，那便是前文所讲述的移动构造/移动赋值\n但是想让编译器默认生成移动构造可没那么容易：只有你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个，编译器才会帮你整一个移动构造出来\n\n编译器默认生成的移动构造：对于内置类型会执行逐成员按字节拷贝；对自定义类型成员，则需要看这个成员是否实现移动构造， 如果实现了就调用移动构造，没有实现就调用拷贝构造。\n\n同样的，移动赋值也需要满足上面的条件，编译器才会帮你生成。\nclass TestB&#123;private:\tmuxue::string _s;\tint _a;public:\tTestB(const muxue::string&amp; s=&quot;&quot;, int a=0)\t\t:_s(s),\t\t_a(a)\t&#123;&#125;&#125;;void DefaultMoveCopy()&#123;\tTestB t1;\tcout &lt;&lt; endl;\tTestB t2 = t1;\tcout &lt;&lt; endl;\tTestB t3 = std::move(t1);\tcout &lt;&lt; endl;\tTestB t4;\tt4 = std::move(t2);\tcout &lt;&lt; endl;&#125;\n\n通过测试可以看出来，编译器默认生成了移动拷贝和移动赋值重载。并调用了自定义类型的移动拷贝/移动赋值\n\n6.1 关键字default\n这个关键字的作用之前好像记录过? 不记得了\n\ndefault关键字的作用是让编译器强制生成一个指定的成员函数\n还是上面的TestB类的代码，如果我们自己写一个拷贝构造，编译器就不再会生成默认的移动构造/移动赋值，而是会去调用string里面的拷贝构造、拷贝赋值\n\n这时候我们太懒了，不想自己写移动版本了，于是就用default强制让编译器干活\n\n现在就正确调用了对应的移动构造和移动赋值了！\n\n7.可变模板参数在5.1提到的emplace_back函数中，便出现了下面这种语法\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n这就是一个可变的模板参数，允许一个函数有多个参数，且不要求是相同类型\n使用sizeof即可查看参数的个数\n\n7.1 递归解参数包而如果你想查看参数的类型并使用它，则需要进行递归取出参数来\ntemplate &lt;class T&gt;void ShowArgs(const T&amp; val)&#123;\tcout &lt;&lt; val &lt;&lt; &quot;   type: &quot; &lt;&lt; typeid(val).name() &lt;&lt; endl;&#125;template &lt;class T,class... Args&gt;void ShowArgs(const T&amp;val,Args&amp;&amp;... args)&#123;\t//cout &lt;&lt; &quot;参数个数&quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;\tcout &lt;&lt; val &lt;&lt; &quot;   type: &quot; &lt;&lt; typeid(val).name() &lt;&lt; endl;\tShowArgs(args...);&#125;void TestArgs()&#123;\tShowArgs(1, &#x27;x&#x27;, 2.3, muxue::string(&quot;123&quot;));&#125;\n\n\n其中void ShowArgs(const T&amp; val)函数的作用，是当参数包中只有一个参数的时候，调用对应的单参函数，而不会报错\n另外一种办法便是提供一个无参的同名函数，用作参数包递归的结尾\n\n错误解法可能有人想使用这样的方法来解包，当参数包里的函数只有一个的时候，结束递归\n\n但是这样是不行的！\n\n递归推参数包是一个编译时逻辑\n通过sizeof判断是一个运行时逻辑\n\n在编译这个函数的时候，已经开始找对应的函数进行调用了。当参数包里面的参数只有1个或者0个的时候，编译器编译的时候发现找不到对应函数，就直接报错了。\n7.2 数组解包除了上面的递归解包，这里还可以使用数组的方式直接来解包\ntemplate &lt;class... Args&gt;void ShowArgs(Args&amp;&amp;... args)&#123;\tcout &lt;&lt; &quot;参数个数&quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;\tint arr[] = &#123; args... &#125;;&#125;void TestArgs()&#123;\tShowArgs(1, 2, 3, 4);&#125;\n\n可以看到arr数组里面解包出了传入的参数\n\n但是这种方法不通用，只适用于所有参数都是相同类型的情况，如果是不同类型则会报错\n\n通用办法是使用一个逗号表达式，来获取一共有多少个参数以及解包\ntemplate &lt;class T&gt;void PrintArgs(const T&amp; val)&#123;\tcout &lt;&lt; val &lt;&lt; &quot;   type: &quot; &lt;&lt; typeid(val).name() &lt;&lt; endl;&#125;template &lt;class... Args&gt;void ShowArgs(Args&amp;&amp;... args)&#123;\tcout &lt;&lt; &quot;参数个数&quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;\t//int arr[] = &#123; args... &#125;;\tint arr[] = &#123; (PrintArgs(args),0)... &#125;;&#125;\n\n一共有多少个参数，那么数组里面就会有多少个0\n\n7.3 emplace_back库函数中emplace_back的参数包还使用了万能应用，这就让它的使用更加灵活\ntemplate &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);\n\n可以直接传入两个参数，他会自动解包参数，创建一个键值对\nstd::list&lt;std::pair&lt;int, muxue::string&gt;&gt; t;t.emplace_back(10, &quot;sort&quot;);\n\n而push_back则不支持这么干\n\n\n8.lambda表达式在之前，我们使用sort的时候，如果是内置类型，默认会返回一个升序序列。如果我们需要返回降序，则需要改变比较规则，传入一个仿函数来使用自定义的比较对比\n#include &lt;algorithm&gt;//sort#include &lt;functional&gt;//greaterint main()&#123;\tint arr[]=&#123;1,3,2,5,4&#125;;    int sz=sizeof(arr)/sizeof(arr[0]);    //默认升序\tstd::sort(arr,arr+sz);    //降序传入仿函数greater    std::sort(arr,arr+sz,greater&lt;int&gt;());&#125;\n\n因为int是内置类型，库中自带的greater/less仿函数即可满足我们的需求。而如果我们排序的是自定义类型，则需要自己实现一个对应的仿函数\n//价格降序struct CompPriceGreater&#123;\tbool operator()(const Goods&amp; g1, const Goods&amp; g2)\t&#123;\t\treturn g1._price &gt; g2._price;\t&#125;&#125;;//价格升序struct CompPriceLess &#123;\tbool operator()(const Goods&amp; g1, const Goods&amp; g2)\t&#123;\t\treturn g1._price &lt; g2._price;\t&#125;&#125;;\n\n\n8.1 情景描述但是如果需要处理的对象有很多不同的成员变量的时候（比如京东淘宝上商品不同的筛选方式）我们就需要实现非常非常多的仿函数\n这样一来，程序的代码行数就会变多\n在VS编译器下，这种问题还算好解决，我们可以快速跳转道函数定义。但如果我们没有这个功能可用，在处理大文本代码的时候，怎么很快的找到对应的仿函数呢？\n特别是在项目合作的时候，万一有个家伙编程命名规范很差劲，我们无法从函数名推断函数功能，再加上不能直接跳转定义，那麻烦事可多了。\n\n8.2 lambda出场这时候就可以试试用lambda表达式拉，以下是lambda表达式的书写格式\n[capture-list](parameters)mutable -&gt; return-type&#123;statement&#125;\n\n说明一下各个位置分别写的是啥玩意\n\n[capture-list]捕捉列表，用于编译器判断为lambda表达式，同时捕捉该表达式所在域的变量以供函数使用\n(parameters)参数，和函数的参数一致。如果不需要传参则可连带()一起省略\nmutable默认情况下捕捉列表捕捉的参数是const修饰的，该关键字的作用是取消const使其可修改\n-&gt; return-type函数返回值类型\n&#123;statement&#125;函数体，和普通函数一样。除了可以使用传入的参数，还可以使用捕捉列表获取的参数\n\n8.3 基本使用先来写一个最简单的lambda表达式试试水吧\nauto Add = [](int a, int b) &#123;return a + b; &#125;;\n\n\n可以看到，这个表达式的使用方法和函数完全一致，也成功提供了结果\n因为我们返回值的类型是明确的，所以这里可以省略类型，让编译器自己来推断。当然也可以显示指定类型，这样可以更精确的控制\n\n\nlambda表达式还支持复制给相同类型的函数指针，但是一般都不要这么用！\nvoid(*PF)();PF = f2;PF();\n\n\n8.4 捕捉列表和mutable学会了基本使用，我们再来看看捕捉列表是怎么玩的\nvoid TestLambda1()&#123;\tint a = 10, b = 20;\tauto func3 = [a,b](int x, int y)-&gt;int &#123;\t\treturn a+b;\t&#125;;\tcout&lt;&lt;func3(a, b)&lt;&lt;endl;&#125;\n\n\n这里我们捕捉了函数作用域里面的局部变量a/b，直接在lambda表达式内部使用👍\n因为不需要传入参数，所以我们可以直接把参数()和返回值一并省略掉\n\nmutable默认情况下，我们捕捉到的参数是带const的，我们并不能对其进行修改。\n\n这时候就需要使用前面提到的mutable关键字来修饰\n\n注意：这个关键字使用的时候必须带上函数参数的()\n\nauto func5 = [a, b]()mutable &#123;    a++;    b++;    return a + b;&#125;;\n\n\n\n8.5 捕获的几种方式注意，当我们在对象里面以值传递方式捕获参数的时候，还需要捕获this指针来调用类内部的函数\n[val]：表示值传递方式捕捉变量val[=]：表示值传递方式捕获所有父作用域中的变量(包括this)[&amp;val]：表示引用传递捕捉变量val[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括this)[this]：表示值传递方式捕捉当前的this指针\n\n其中第一个就是我们上面演式的[a,b]这样最直接的值捕获\n而最后一个的this指针主要用用于类内部\n8.5.1 全捕获&#x3D;当一个作用域里面的变量很多，而我们又不想一个一个写的时候，可以使用=捕捉全部变量\nint a = 10, b = 20;int c = 1, d = 3, e = 5;auto func6 = [=] &#123;    return (a + b + c + d + e);&#125;;cout &lt;&lt; func6() &lt;&lt; endl;\n\n\n8.5.2 引用全捕或除了基本的全捕或，我们还可以用一个&amp;以引用的方式捕获全部参数。\n\n引用了过后，我们也可以修改参数了\n\n8.5.3 全捕获+单独操作如果只是仅仅的全捕或还不够，我们还想单独修改某一个参数的时候，可以以不同的方式进行捕获操作\n\nauto func8 = [=,&amp;e] &#123;\te++;\treturn (a + b + c + d + e);&#125;;\n\n\n这样一来就方便多了\n8.6 最终呈现这样，当我们sort的时候，就不再需要用仿函数了，而是可以直接用lambda表达式来完成相同的操作，大大增加代码可读性！\n这是因为排序所用的方法直接就在sort这里用lambda的形式给出了，看代码的时候，也不需要去找定义，更不用担心函数命名规则的问题了。\nvector&lt;Goods&gt; v1 = &#123; &#123;&quot;牛奶&quot;,20,100&#125;,&#123;&quot;杯子&quot;,10,200&#125;,&#123;&quot;饼干&quot;,15,50&#125; &#125;;//价格升序sort(v1.begin(), v1.end(), [](const Goods&amp; g1, const Goods&amp; g2) &#123;return g1._price &lt; g2._price; &#125;);for (auto&amp; e : v1) &#123;\tcout &lt;&lt; e._name &lt;&lt; &quot;_&quot; &lt;&lt; e._price &lt;&lt; &quot;  &quot;;&#125;cout &lt;&lt; endl;v1 = &#123; &#123;&quot;牛奶&quot;,20,100&#125;,&#123;&quot;杯子&quot;,10,200&#125;,&#123;&quot;饼干&quot;,15,50&#125; &#125;;//价格降序sort(v1.begin(), v1.end(), [](const Goods&amp; g1, const Goods&amp; g2) &#123;return g1._price &gt; g2._price; &#125;);for (auto&amp; e : v1) &#123;\tcout &lt;&lt; e._name &lt;&lt; &quot;_&quot; &lt;&lt; e._price &lt;&lt; &quot;  &quot;;&#125;cout &lt;&lt; endl;v1 = &#123; &#123;&quot;牛奶&quot;,20,100&#125;,&#123;&quot;杯子&quot;,10,200&#125;,&#123;&quot;饼干&quot;,15,50&#125; &#125;;//名称字典序sort(v1.begin(), v1.end(), [](const Goods&amp; g1, const Goods&amp; g2) &#123;return g1._name &lt; g2._name; &#125;);for (auto&amp; e : v1) &#123;\tcout &lt;&lt; e._name &lt;&lt; &quot;_&quot; &lt;&lt; e._price &lt;&lt; &quot;  &quot;;&#125;cout &lt;&lt; endl;\n\n\n8.7 lambda底层：仿函数实际上，lambda的底层就是把自己转成了一个仿函数供我们调用。这也是为何sort可以以lambda来作为排序方法的原因——底层都是仿函数嘛！\n\n\n9.包装器functionfunction包装器，也叫作适配器。C++中的function本质是一个类模板，也是一个包装器。\n那么这个东西是用来干啥的呢？\n\n把所有的可调用对象封装成统一的格式\n\n什么是可调用对象？\n\n函数指针\n仿函数对象\nlambda表达式\n\n9.1 基本使用我们可以用function来包装这些不同的可调用对象，说白了就是产生了另外一个相同的可调用对象。类似于“引用”了这个函数\nclass AddClass&#123;public:\tstatic int Addi(int a, int b)&#123;\t\treturn a + b;\t&#125;\tdouble Addd(double a, double b)&#123;\t\treturn a + b;\t&#125;&#125;;int func(int a,int b)&#123;\treturn a + b;&#125;struct Functor&#123;\tint operator()(int a,int b)&#123;\t\treturn a+b;\t&#125;&#125;;void TestFunction1()&#123;\t// 函数\tfunction&lt;int(int, int)&gt; func1 = func;\tcout &lt;&lt; func1(10, 20) &lt;&lt; endl;\t// 仿函数\tfunction&lt;int(int, int)&gt; func2 = Functor();\tcout &lt;&lt; func2(10, 20) &lt;&lt; endl;\t// 类中static成员函数\tfunction&lt;int(int, int)&gt; func3 = AddClass::Addi;\tcout &lt;&lt; func3(100, 200) &lt;&lt; endl;\t// 类中非静态成员函数\tfunction&lt;double(AddClass, double, double)&gt; func4 = &amp;AddClass::Addd;\tcout &lt;&lt; func4(AddClass(), 100.11, 200.11) &lt;&lt; endl;\t// lambda表达式\tfunction&lt;int(int, int)&gt; func5 = [](int a, int b) &#123;return a + b; &#125;;\tcout &lt;&lt; func5(100, 200) &lt;&lt; endl;&#125;\n\n\n引用类中非static成员需要注意的是，当我们使用静态成员函数的时候，必须要带上一个this指针才能很好的访问。所以我们需要穿入一个AddClass()的匿名对象来适配包装器\n同时，非静态的成员函数还必须要进行&amp;取地址操作。静态的则可以不加\n\n为了统一，可以都加上以防忘记\n\n\n9.2 特殊场景的作用这个东西呢，看起来好像没啥用，但是在一些地方可以帮大忙\n比如模板函数，假设我们知道在函数B里面需要调用一个模板函数A多次，而且每次调用都是相同类型的（或者说就只有已知的几个特定类型），那么就可以先用fuction对这个模板函数进行指定的实例化，避免每一次调用的时候，后台都需要单独去实例化一个函数，减小模板的性能损耗！\n9.3 改造逆波兰表达式OJ\nleetcode逆波兰表达式：https://leetcode.cn/problems/evaluate-reverse-polish-notation/\n\n之前写这个OJ的时候，我用的是栈和switch/case语句\nclass Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; s;        for(auto&amp; ch : tokens)        &#123;            if(ch==&quot;+&quot;||ch==&quot;-&quot;||ch==&quot;*&quot;||ch==&quot;/&quot;)            &#123;                int right=s.top();                s.pop();                int left=s.top();                s.pop();                switch(ch[0])                &#123;                    case &#x27;+&#x27;:                        s.push(left+right);                        break;                    case &#x27;-&#x27;:                        s.push(left-right);                        break;                    case &#x27;*&#x27;:                        s.push(left*right);                        break;                    case &#x27;/&#x27;:                        s.push(left/right);                        break;                    default:                        break;                &#125;            &#125;            else&#123;                s.push(stoi(ch));            &#125;           &#125;        return s.top();    &#125;&#125;;\n\n现在我们就不需要这么麻烦了，可以使用包装器来改造这个OJ题的答案\nclass Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; s;        map&lt;string,function&lt;int(int,int)&gt;&gt; FuncMap = &#123;            &#123;&quot;+&quot;,[](int x,int y)&#123;return x+y;&#125;&#125;,            &#123;&quot;-&quot;,[](int x,int y)&#123;return x-y;&#125;&#125;,            &#123;&quot;*&quot;,[](int x,int y)&#123;return x*y;&#125;&#125;,            &#123;&quot;/&quot;,[](int x,int y)&#123;return x/y;&#125;&#125;        &#125;;        for(auto&amp; ch : tokens)        &#123;            if(ch==&quot;+&quot;||ch==&quot;-&quot;||ch==&quot;*&quot;||ch==&quot;/&quot;)            &#123;                int right=s.top();                s.pop();                int left=s.top();                s.pop();                int ret = FuncMap[ch](left,right);                s.push(ret);            &#125;            else&#123;                s.push(stoi(ch));            &#125;           &#125;        return s.top();    &#125;&#125;;\n\n这里我们还用到了前面提到过的&#123;&#125;初始化构造。现在我们只需要从funcmap里面取出封装器封装的lambda表达式进行操作就可以了！\n代码一下就简洁了许多，但是这也只有学习过C++11的人才看得懂，属于一个进阶用法\n\n测试的时候发现出现了一些问题，int溢出了\n\n把所有的int都改成long long即可\n\n\n10.bind绑定在上面我们用fuction包装一个对象内部的成员函数时，需要利用匿名对象传入一个this指针。这样就很不方便了，明明是两个参数的函数，非要传入第三个参数。\n要是我们再用9.3中map的方式来封装一个可调用的表，那带this指针的函数就没办法一起包装了\nclass AddClass&#123;public:\tstatic int Addi(int a, int b)\t&#123;\t\treturn a + b;\t&#125;\tint Addii(int a, int b)\t&#123;\t\treturn a + b;\t&#125;&#125;;int func(int a,int b)&#123;\treturn a + b;&#125;struct Functor&#123;\tint operator()(int a,int b)\t&#123;\t\treturn a+b;\t&#125;&#125;;map&lt;string, function&lt;int(int, int)&gt;&gt; FuncMap = &#123;    &#123;&quot;函数&quot;,func&#125;,    &#123;&quot;仿函数&quot;,Functor()&#125;,    &#123;&quot;静态成员函数&quot;,AddClass::Addi&#125;,    &#123;&quot;非静态成员函数&quot;,&amp;AddClass::Addii&#125;&#125;;\n\n如图，最后addclass中的非静态函数，就没有办法一同包装到map中\n\n\n这里不能使用可变参数包，因为是实例化操作\n\n这时候我们就可以使用bind来进行参数绑定\n10.1 使用bind可以调整参数的顺序，绑定固有参数；最后形成一个新的可调用对象。\nbind的第一个参数用于指定需要绑定的函数，后面就是绑定的参数，和需要自己传入的参数\nfunction&lt;int(int, int)&gt; func7 = bind(&amp;AddClass::Addii,AddClass(), placeholders::_1, placeholders::_2);cout &lt;&lt; func7(100, 200) &lt;&lt; endl;\n\n\n这时候我们就不需要传入this指针，因为当我们用bind绑定的时候，已经默认传入了第一个参数了！\n10.2 占位符placeholdersplaceholders是用来占位的，代表这里的参数需要用户手动传入，而_1代表传入的第一个参数，_2就是传入的第二个参数，以此类推\nfunction&lt;int(int, int)&gt; func7 = bind(&amp;AddClass::Addii,AddClass(), placeholders::_1, placeholders::_2);\n\n因为有不同的后缀，所以我们还可以调整绑定的参数顺序！\n//Minii的作用是a-bfunction&lt;int(int, int)&gt; func8 = bind(&amp;AddClass::Minii, AddClass(), placeholders::_1, placeholders::_2);cout &lt;&lt; func8(100, 200) &lt;&lt; endl;function&lt;int(int, int)&gt; func9 = bind(&amp;AddClass::Minii, AddClass(), placeholders::_2, placeholders::_1);cout &lt;&lt; func9(100, 200) &lt;&lt; endl;\n\n\n我们调整了顺序之后，也得到了不同的结果！\n\n结语本篇超长的博客到这里就结束辣！\n其实C++11还有其他的新特性，但是那些我会单开一篇文章来写~\n\n","categories":["遇见C++"],"tags":["C++","数据结构","C++11"]},{"title":"【C++】智能指针（空）","url":"/2022/10/19/code/note_cpp/22%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","content":"我也不知道啥时候能补上这个……\n","categories":["遇见C++"],"tags":["C++","类和对象"]},{"title":"【C++】特殊类设计","url":"/2022/10/19/code/note_cpp/23%E7%89%B9%E6%AE%8A%E7%B1%BB/","content":"本篇博客让我们来康康一些特殊类的实现方式！\n\n\n\n\n1.不支持拷贝的类在一些场景下，比如智能指针、多线程操作、IO流等是不支持拷贝的。因为它们的拷贝会导致一些问题，秉着解决不了问题，就解决提出问题的人的思路，禁止了这些类的拷贝\nC++98中，可以将拷贝构造和=重载只声明不定义，并将其访问权限设置为私有\n\n设置为私有可以防止其他人在类外定义\n\nC++11中，提供了一个特殊的关键字delete来禁止实现拷贝构造和 =重载\n// 禁止拷贝的类class BanCopy&#123;public:\t//构造\tBanCopy()\t&#123;\t\t_a = _b = 0;\t&#125;\t\t//C++11\tBanCopy(const BanCopy&amp; c) = delete;\tBanCopy&amp; operator=(const BanCopy&amp; c) = delete;private:\t//C++98的办法，声明为私有且不定义\t//BanCopy(const BanCopy&amp; c);\t//BanCopy&amp; operator=(const BanCopy&amp; c);\t\tint _a;\tint _b;&#125;;\n\n\n2.只能在堆上创建的类操作方法和上面的思路类似，只需要把构造函数私有化就可以了\n\n同时还需要取消拷贝构造，否则可以用拷贝构造在栈上开一个新的对象\n赋值重载不一定需要取消，因为赋值重载无法创建新对象\n\n// 只能在堆上开辟class HeapOnly &#123;public:\tstatic HeapOnly* CreatObj(int a,int b)\t&#123;\t\treturn new HeapOnly(a, b);\t&#125;private:\t// 构造函数私有\tHeapOnly()\t\t:_a(0),\t\t_b(0)\t&#123;&#125;\tHeapOnly(int a,int b)\t\t:_a(a),\t\t_b(b)\t&#123;&#125;\t// 同时拷贝构造也需要私有，禁止拷贝创建对象\tHeapOnly(const HeapOnly&amp; h) = delete;\t// 赋值不一定需要delete，因为赋值不能创建新对象\t// HeapOnly&amp; operator=(const HeapOnly&amp; h) = delete;\tint _a;\tint _b;&#125;;\n\n这样写了之后，想创建对象就可以调用static函数来操作\n\n而且因为我们并没有私有化析构函数，所以析构是可以正常调用的！\n另类操作还可以使用static函数提供一个接口来专门处理析构，再把析构函数设计成私有，构造函数公有\n// 只能在堆上开辟class HeapOnly &#123;public:\tstatic HeapOnly* CreatObj(int a,int b)\t&#123;\t\treturn new HeapOnly(a, b);\t&#125;\tstatic void DelObj(HeapOnly* ptr)\t&#123;\t\tdelete ptr;\t&#125;\t// 因为析构私有了，所以可以把构造公有\tHeapOnly()\t\t:_a(0),\t\t_b(0)\t&#123;&#125;\tHeapOnly(int a, int b)\t\t:_a(a),\t\t_b(b)\t&#123;&#125;private:\t// 构造函数私有\t// ....\t// 同时拷贝构造也需要私有，禁止拷贝创建对象\tHeapOnly(const HeapOnly&amp; h) = delete;\t// 赋值不一定需要delete，因为赋值不能创建新对象\t// HeapOnly&amp; operator=(const HeapOnly&amp; h) = delete;\t~HeapOnly()\t&#123;\t\t_a = _b = 0;\t&#125;\tint _a;\tint _b;&#125;;\n\n这样设计了之后，直接在栈上&#x2F;全局区开辟空间会报错，但是new不受影响。\n因为析构私有了，所以delete不能正确调用析构函数，我们需要使用static函数指定指针进行析构\n\n除了这种办法，还有另外一个法子可以不传入指针\n//删除自己void DelObj()&#123;    delete this;&#125;\t\n\n直接用对象调用此函数即可\nHeapOnly* h6 = new HeapOnly();h6-&gt;DelObj();\n\n只不过这样可能有些不太好理解，视具体情况而定喽！\n\n3.只能在栈上创建的类相同的思路，设计一个static的创建对象函数，来创建一个栈上的对象return\n// 只能在栈上开辟class StackOnly&#123;public:\tstatic StackOnly CreatObj()\t&#123;\t\treturn StackOnly();//创建匿名对象返回，编译器直接优化为一个构造\t\t//这么写的话，就不能禁止拷贝构造\t\t//StackOnly st;\t\t//return st;\t&#125;\t// 不能禁用拷贝构造，因为return的时候可能会调用（编译器优化是取决于平台的）private:\tStackOnly()\t&#123;\t\t_a = _b = 0;\t&#125;\tint _a;\tint _b;&#125;;\n\n这里我们必须要有拷贝构造，因为return的时候，编译器如果不优化，那就是构造+拷贝，优化了之后才能变成直接构造\n这是取决于平台的，如果禁用了拷贝，万一有些平台编译器没有做这种优化，你的代码就跑不动了\n\n另外，还有一个方法便是禁用掉operator new()，以此禁止了在堆上创建空间。如果用这种办法，构造函数就不需要设计为私有了\n\n但是这两个办法都有个缺陷，那就是用户可以用拷贝构造在静态区上创建一个对象。这只能算个小瑕疵，可以不用管它\n\n4.单例模式单例模式是设计模式的其中一种\n\n设计模式是一套被反复使用且较为流行的代码设计经验总结。\n设计模式有非常多，感兴趣的老哥可以去搜专门的博客了解一下\n\n单例模式：一个类只能创建一个对象。该模式可以保证在一个进程中，某一个类只会有一个实例化的对象\n\n举个例子，比如服务器的配置信息是一个类，这个类就可以设计成单例模式，保证所有人访问到的配置信息完全相同，修改的时候也能同步给所有人。\n\n4.1 饿汉饿汉模式采用static成员来实现单例，思路和上面也是一样的，让构造函数私有而无法创建其他对象\n\n那我们的static对象要怎么创建呢？\n\n先来看看下面的代码\n// 单例模式（饿汉）// 饿汉模式采用static对象，是在main函数之前创建的// 会影响程序启动的速度class Singleton&#123;public:\tstatic Singleton* GetInstance()\t&#123;\t\treturn _sgp;\t&#125;\tvoid Print()\t&#123;\t\tcout &lt;&lt; &quot;----- System Info -----&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;     CPU &quot; &lt;&lt; _cpu &lt;&lt; endl;\t\tcout &lt;&lt; &quot;     GPU &quot; &lt;&lt; _gpu &lt;&lt; endl;\t\tcout &lt;&lt; &quot;     MEM &quot; &lt;&lt; _mem &lt;&lt; endl;\t\tcout &lt;&lt; &quot;-----     End     -----&quot; &lt;&lt; endl;\t&#125;private:\tSingleton()\t\t:_cpu(&quot;i9-12900ks&quot;),\t\t_gpu(&quot;RTX 4090&quot;),\t\t_mem(&quot;128GB&quot;)\t&#123;&#125;    Singleton(const Singleton&amp; s) = delete;\tstring _cpu;\tstring _mem;\tstring _gpu;\t//static Singleton _sg;//声明\tstatic Singleton* _sgp;//声明&#125;;//Singleton Singleton::_sg;//定义Singleton* Singleton::_sgp = new Singleton();//定义//因为这里的sg和sgp都是属于类里面的成员，不受访问限定符的限制，才可以正常调用构造函数\n\n因为_sg/_sgp这两个成员都在类内部声明的，所以它们属于整个类域，可以成功访问到内部的构造函数。\n而在其他地方的对象由于没有办法访问到构造函数，而无法创建\n\n由于饿汉模式是static对象，其初始化是在main函数之前进行的。如果采用饿汉模式的单例过多，程序迟迟没有运行到main处，会导致一个程序启动很慢\n\n4.2 懒汉（多线程加锁未解决）一开始不创建对象，第一调用GetInstance再创建对象\n// 懒汉// 一开始不创建对象，第一调用GetInstance再创建对象class InfoMgr&#123;public:\tstatic InfoMgr* GetInstance()\t&#123;\t\tif (_sp == nullptr)\t\t&#123;\t\t\t_sp = new InfoMgr;\t\t&#125;\t\treturn _sp;\t&#125;\tvoid SetAddress(const string&amp; s)\t&#123;\t\t_address = s;\t&#125;\tstring&amp; GetAddress()\t&#123;\t\treturn _address;\t&#125;private:\tInfoMgr()\t\t:_address(&quot;bilibili&quot;),\t\t_secretKey(1234)\t&#123;&#125;\tInfoMgr(const InfoMgr&amp;) = delete;\tstring _address;\tint _secretKey;\tstatic InfoMgr* _sp; // 声明&#125;;InfoMgr* InfoMgr::_sp = nullptr; // 定义\n\n这里我们将内部的_sp定义为了nullptr，如果谁第一个调用，做一个判断，如果是nullptr就创建实例\n\n由于懒汉可能会出现多个线程同时第一次访问这个单例，就会导致在两个线程中都在初始化这个单例，而某一次初始化会失败。这是一个线程安全问题，需要我们对单例进行加锁操作\n\n由于我还没有学到多线程操作，所以留在后面来补上！\n\n4.3 二者优缺点饿汉的优点\n\n简单易用\n因为是在main函数前初始化，处于单线程状态，没有线程安全问题\n\n缺点：\n\n但是初始化顺序不确定，如果有其他类的依赖关系，可能会出现依赖项B在当前单例A后初始化，导致A无法完成初始化而程序boom\n饿汉单例是在main函数之前创建的，拖慢程序启动速度\n\n\n懒汉的优点\n\n第一次调用的时候才初始化变量，提高程序启动速度\n可以控制初始化顺序，按顺序来初始化，避免依赖关系问题\n\n缺点：\n\n第一次调用的时候，加载会慢一些\n\n基于这两个的优缺点，让我想出来一个不算办法的办法\n如果想控制饿汉的初始化顺序，可以在main一启动的时候，就调用一个初始化函数来初始化这些单例。这样依旧会拖慢进程启动的顺序，但解决了初始化顺序的问题！\n\n实际上，一个单例究竟要不要在main之前就初始化需要看具体情况的！\n\n4.4 单例释放资源一般情况下，单例的类是不需要手动释放的，因为整个进程都需要使用这个单例\n但如果我们的单例和一个文件挂钩，进程结束的时候，需要将单例里面的信息保存到文件里面，要怎么操作？\n可以写一个垃圾回收类，在最后调用析构来回收资源\n// 懒汉 -- 一开始不创建对象，第一调用GetInstance再创建对象class InfoMgr&#123;public:\tstatic InfoMgr* GetInstance()\t&#123;\t\t// 还需要加锁，留着后面填坑\t\tif (_spInst == nullptr)\t\t&#123;\t\t\t_spInst = new InfoMgr;\t\t&#125;\t\treturn _spInst;\t&#125;\tvoid SetAddress(const string&amp; s)\t&#123;\t\t_address = s;\t&#125;\tstring&amp; GetAddress()\t&#123;\t\treturn _address;\t&#125;\t// 实现一个内嵌垃圾回收类    \tclass CGarbo &#123;\tpublic:\t\t~CGarbo() &#123;\t\t\tif (_spInst)\t\t\t\tdelete _spInst;\t\t&#125;\t&#125;;\t// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象\tstatic CGarbo Garbo;//声明private:\tInfoMgr()\t\t:_address(&quot;bilibili&quot;),\t\t_secretKey(1234)\t&#123;&#125;\t~InfoMgr()\t&#123;\t\t// 假设析构时需要信息写到文件持久化\t&#125;\tInfoMgr(const InfoMgr&amp;) = delete;\tstring _address;\tint _secretKey;\tstatic InfoMgr* _spInst; // 声明&#125;;InfoMgr* InfoMgr::_spInst = nullptr; // 定义InfoMgr::CGarbo Garbo;//定义\n\n5.不能被继承的类C++98中，只需要将构造函数私有，派生类无法调用基类构造函数，也就无法继承\n// c++98,构造私有class A &#123;public:\tstatic A GetInstance()\t&#123;\t\treturn A();\t&#125;private:\tA()\t&#123;\t\t_a = 0;\t&#125;\tint _a;&#125;;\n\n而C++11中提供了一个关键字final，用这个关键字修饰类，就无法被继承\n//C++11直接用关键字finalclass B final&#123;\t//...&#125;;\n\n结语几个特殊类到这里就讲解结束辣，其中懒汉多线程加锁还留了一个坑，待后续我会回来更新补上的！\n感谢你看到最后\n\n加油\n\n","categories":["遇见C++"],"tags":["C++","类和对象"]},{"title":"【C++】文件IO流","url":"/2022/10/22/code/note_cpp/24%E6%96%87%E4%BB%B6io%E6%93%8D%E4%BD%9C/","content":"一起来康康C++中的文件IO操作吧\n\n\n[TOC]\n1.operator bool之前写OJ的时候，就已经用过上面这种方式来获取多组测试用例\nstring s;while(cin&gt;&gt;s)&#123;\tcout &lt;&lt; s &lt;&lt; endl;&#125;\n\n不过之前一直没有去了解这里的底层原理是什么，借此机会一并说明\nio流可以进行while判断的依据，是因为库的源码中重载了operator bool\n\n没错，operator不仅可以重载一个操作符，它还可以重载一个类型！即将这个类转换为bool类型，return 一个bool类型的值用于while的判断\n同理，重载int/double这些类型都是可行的！\n\n另外，要想停止上面的多组输入，在VS下可以用ctrl+z的方式解决，而不要用ctrl+c直接杀掉进程\n\n\n2.C++文件IO流\nC++的文件io类设计的较为复杂，其中还出现了菱形继承，也就是我们最常用的iostream\n上面提到的operator bool就是基类IOS实现的，子类都没有去重写\n\ncout为标准输出，将数据从内存流中输入到显示器上\ncin为标准输入，通过键盘输入数据到程序中\ncerr用于标准错误的输出\nclog进行日志输出\n\n其中需要注意的一点是，空格和回车会被当作数据之间的分隔符，所以字符串中不能有空格，回车和空格也不能通过cin读入\n如果需要读入带空格的完整一行，可以使用getline函数\n\n为什么cin和cout可以输入输出所有类型？\n\n因为库里面已经将所有类型通过操作符重载&lt;&lt; 和&gt;&gt;实现了，达到了自动类型识别的效果\n3.文件操作C++标准库中提供的打开方式如下，我们可以根据不同情况传入不同的值，或者一次性用按位或|传入多个打开方法\n\n同时因为C++类和对象会自动调用析构函数，所以我们也不需要手动close文件\n3.0 关于按位与的说明这里为何可以用按位与传入多个方法？\n假设这些方法就是简单的数字2/4/8（必须是2的倍数）我们可以通过按位与了之后，在按位或，判断某一个数字是否在其中\n\n如果或了之后的数字等于它本身，说明数据在其中！\n\n为什么需要是2的倍数呢？\n\n\n\n这种方法在linux中常见，比如linux系统的文件接口\n\n3.1 ifstream\n这个对象是用于读取文件的，默认情况下，传入的打开方法为in\nvoid test1()&#123;\tifstream ifs(&quot;test.txt&quot;);\twhile (ifs)\t&#123;\t\tchar ch = ifs.get();\t\tcout &lt;&lt; ch;\t&#125;&#125;\n\n\n因为重载了bool，所以可以很方便的直接用while来判断结束，成功输出了文件中的内容\nifstream ifs(&quot;test.txt&quot;);char ch;while (ifs &gt;&gt; ch)&#123;\tcout &lt;&lt; ch;&#125;\n\n第二种读取方法采用了流插入&gt;&gt;上面提到过，流提取和插入的时候，会把空格和换行当作数据的分隔符，所以它是不能打印出空格和换行\n\n3.2 ofstream\n写文件的方式同上，用out方法打开文件就可以了（默认传的就是out）\nofstream ifs2(&quot;test1.txt&quot;,ios::out);char str[] = &quot;i love u\\n&quot;;ifs2.write(str,sizeof(str));\n\n\n不过这个和C语言的w方法一样，写入的时候会覆盖文件中已有的内容。如果想进行追加，则需要在后面加上app；如果是执行二进制读写，则需要与上ios::binary\nofstream ifs2(&quot;test1.txt&quot;,ios::out|ios::app);char str[] = &quot;i love u&quot;;ifs2.write(str,sizeof(str));\n\n\n运行成功后会在文件尾部追加内容\n注意，这里的字符串不能用string进行处理，因为string内部只存了一个指向字符串空间的指针，写入string相当于把指针写入进文件中，是么有用的！\n\n流插入文本但是，如果我们用&lt;&lt;进行提取的时候，就可以用string了\nvoid test2()&#123;\tifstream ifs(&quot;test.txt&quot;);\tofstream ofs(&quot;test1.txt&quot;);\tchar ch;\tch = ifs.get();\twhile (~ch)\t&#123;\t\tofs &lt;&lt; ch;\t\tcout &lt;&lt; ch;\t\tch = ifs.get();\t&#125;\tstring s(&quot;i love you&quot;);\tofs &lt;&lt; s;&#125;\n\n程序运行后，会把test.txt中的内容输出到控制台，同时写入到test1.txt\n最后还会写入一个string的内容\n\n这是因为我们调用&lt;&lt;的时候，就和cin&lt;&lt;s一样，调用的是string重载的流提取操作符\n底层实现的时候会将其转为C语言的字符串，从而写入到了文件中\n\n所以当我们需要写入一个自定义类型的时候，可以重载流提取操作符，不仅可以更方便的打印，还可以写入到文件中\n\n\n3.3 ostringstream&#x2F;istringstream这个类可以将不同的类型转为字符串\n这种操作被称为序列化和反序列化，在处理自定义类型的时候非常好用\nstruct Date&#123;public:\tfriend ostream&amp; operator &lt;&lt; (ostream&amp; out, const Date&amp; d);\tfriend istream&amp; operator &gt;&gt; (istream&amp; in, Date&amp; d);\tDate(int y=0, int m=0, int d=0)\t&#123;\t\t_year = y;\t\t_month = m;\t\t_day = d;\t&#125;private:\tint _year;\tint _month;\tint _day;&#125;;istream&amp; operator &gt;&gt; (istream&amp; in, Date&amp; d)&#123;\tin &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;\treturn in;&#125;ostream&amp; operator &lt;&lt; (ostream&amp; out, const Date&amp; d)&#123;\tout &lt;&lt; d._year &lt;&lt; &quot; &quot; &lt;&lt; d._month &lt;&lt; &quot; &quot; &lt;&lt; d._day;\treturn out;&#125;void test4()&#123;\tint i = 123;\tdouble d = 44.55;\tostringstream oss;//序列化\toss &lt;&lt; i;\tstring stri = oss.str();\toss.str(&quot;&quot;);//清空oss\toss &lt;&lt; d;\tstring strd = oss.str();\tcout &lt;&lt; strd&lt;&lt; endl;\toss.str(&quot;&quot;);//清空oss\tDate d1(2022, 10, 11);\toss &lt;&lt; d1;\tstring strdt = oss.str();\tcout &lt;&lt; strdt &lt;&lt; endl;\tistringstream iss(strdt);//反序列\tDate d2;\tiss &gt;&gt; d2;\tcout &lt;&lt; d2 &lt;&lt; endl;&#125;\n\n\n3.4 stringstream这个对象可以用于字符串拼接，也可以用来将其他类型转为str\nstringstream sstream;// 将多个字符串放入 sstream 中sstream &lt;&lt; &quot;first&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;string,&quot;;sstream &lt;&lt; &quot; second string&quot;;cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;// 清空 sstreamsstream.str(&quot;&quot;);sstream &lt;&lt; &quot;third string&quot;;cout &lt;&lt; endl;cout &lt;&lt; &quot;After clear, strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;\n\n\n3.5使用stringstream的注意事项\nstringstream实现转换，实际上是维护了一个string对象实现的\n\n我们可以使用str(&quot;&quot;)清空里面的string对象，设置为空字符串\n\n多次数据类型转换的时候，需要用clear()来清空，才能正确转换。不过clear()不会清空底层的string对象\n\n因为使用的是string对象，所以使用的时候不需要格式化控制，可以自动推导类型\n\n\nstringstreams在转换结尾时(即最后一个转换后),会将其内部状态设置为badbit因此下一次转换是必须调用clear()将状态重置为goodbit才可以继续转换\n\n这里在第一次调用stringstream操作后，我们没有进行clear，会发现后续的double类型转换失败了\n\n执行了clear之后，转换成功！\n结语关于C++IO流操作的基本认识到这里就over了。\n因为在实际中用的并不算多，所以这部分的内容大多数是了解一二，知道如何使用，以及3.0中提到的按位与操作是怎么实现的就OK了！\n","categories":["遇见C++"],"tags":["文件","C++"]},{"title":"【C++】空间配置器","url":"/2022/10/18/code/note_cpp/25%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/","content":"空间配置器，听起来高大上，那它到底是什么东西呢？\n\n\n1.什么是空间配置器？空间配置器是STL源码中实现的一个小灶，用来应对STL容器频繁申请小块内存空间的问题。他算是一个小型的内存池，以提升STL容器在空间申请方面的效率 \n\n2.了解空间配置器STL以128个字节为分界线，将空间配置器分为了一级和二级\n2.1 一级一级空间配置器中，allocate/deallocate函数实际上就是对malloc/free做了一个简单的封装\nstatic void * allocate(size_t n)&#123;    void *result = malloc(n);    if (0 == result) result = oom_malloc(n);    return result;&#125;static void deallocate(void *p, size_t /* n */)&#123;    free(p);&#125;//这个函数是malloc失败的时候才会调用的template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)&#123;    void (* my_malloc_handler)();    void *result;    for (;;) &#123;        my_malloc_handler = __malloc_alloc_oom_handler;        if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;//抛异常        (*my_malloc_handler)();        result = malloc(n);        if (result) return(result);    &#125;&#125;\n\n当malloc失败的时候，一级空间配置器会抛异常\n2.2 二级在二级空间配置器中，会先判断带申请空间大小是否大于128个字节，如果超过了，则会去调用一级空间配置器\n# ifndef __SUNPRO_CCenum &#123;__ALIGN = 8&#125;;enum &#123;__MAX_BYTES = 128&#125;;enum &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;# endif  /* n must be &gt; 0      */static void * allocate(size_t n)&#123;    obj * __VOLATILE * my_free_list;    obj * __RESTRICT result;    if (n &gt; (size_t) __MAX_BYTES) &#123;        return(malloc_alloc::allocate(n));    &#125;    my_free_list = free_list + FREELIST_INDEX(n);    // Acquire the lock here with a constructor call.    // This ensures that it is released in exit or during stack    // unwinding.    #       ifndef _NOTHREADS    /*REFERENCED*/    lock lock_instance;    #       endif    result = *my_free_list;    if (result == 0) &#123;        void *r = refill(ROUND_UP(n));        return r;    &#125;    *my_free_list = result -&gt; free_list_link;    return (result);&#125;;/* p may not be 0 */static void deallocate(void *p, size_t n)&#123;    obj *q = (obj *)p;    obj * __VOLATILE * my_free_list;    if (n &gt; (size_t) __MAX_BYTES) &#123;        malloc_alloc::deallocate(p, n);        return;    &#125;    my_free_list = free_list + FREELIST_INDEX(n);    // acquire lock    #       ifndef _NOTHREADS    /*REFERENCED*/    lock lock_instance;    #       endif /* _NOTHREADS */    q -&gt; free_list_link = *my_free_list;    *my_free_list = q;    // lock is released here&#125;\n\n二级空间配置器中，主要的几个成员变量如下\nstatic obj * __VOLATILE free_list[__NFREELISTS]; //哈希桶// Chunk allocation state.static char *start_free;static char *end_free;static size_t heap_size;\n\n这里是一个内存池+ 一个哈希桶,内存池的长度为heap_size\n\n哈希桶以8字节对齐，分为了16个桶。最开始的时候，free_list哈希桶是空的\n\n当我们需要小于128个字节空间的时候（以16字节为例），二级空间配置器会直接去上面的内存池当中申请20个16字节的空间，链接到16字节对应的哈希桶的位置（1号桶）\n在下面的refill函数中可以看到这一点\ntemplate &lt;bool threads, int inst&gt;void* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n)&#123;    int nobjs = 20;//一次性申请20个    char * chunk = chunk_alloc(n, nobjs);    obj * __VOLATILE * my_free_list;    obj * result;    obj * current_obj, * next_obj;    int i;    if (1 == nobjs) return(chunk);    my_free_list = free_list + FREELIST_INDEX(n);    /* Build free list in chunk */      result = (obj *)chunk;      *my_free_list = next_obj = (obj *)(chunk + n);      for (i = 1; ; i++) &#123;        current_obj = next_obj;        next_obj = (obj *)((char *)next_obj + n);        if (nobjs - 1 == i) &#123;            current_obj -&gt; free_list_link = 0;            break;        &#125; else &#123;            current_obj -&gt; free_list_link = next_obj;        &#125;      &#125;    return(result);&#125;\n\n8字节对齐的妙处假设我们的list单个节点需要12个字节，set单个字节需要16个字节\n当list需要空间的时候，二级空间配置器也会去申请16个字节的空间，而不会去申请12个字节。这时候，当list将用完的空间还回来之后，就能拿过去给set用了！\n关于哈希桶的特殊处理当我们用完了申请的空间，准备“释放”的时候，二级空间配置器会将释放回来的空间插入进哈希桶（头插）\n这里有一个特殊处理，当用完的空间，或者说是刚申请的空间插入进哈希桶的时候，二及空间配置器会将其强转为一个obj类型，这个类型的前4/8个字节会用来存放一个指针，指向下一个空间，以此构成链表\nunion obj &#123;    union obj * free_list_link;    char client_data[1];    /* The client sees this.        */&#125;;\n\n\n当我们再次需要这部分大小的空间的时候，只需要将哈希桶头指针的指向直接修改，就能链接上下一个空间，并将之前头指针指向的空间拿去用\n用的时候也不用管之前在此处存放的指针，毕竟下一次放回来的时候，二级空间配置器会来处理它的\n\n内存池空间不够用了咋办？之前提到了，二级空间配置器里面有一个小内存池。要是这个内存池用完了，要咋整呢？\n二级空间配置器想出来了一种很骚的做法：\n\n假设当前我们需要24字节的空间\n对应的桶下面没有空间给我们用\n内存池也用光了\n但是48字节的桶下面还有空间可以用\n直接把这个空间拿过来，拆成两个24链接到24的桶下面！\n\n这样便有效提高了空间利用率，也避免了realloc造成的时间消耗。\n当然，要是桶里面也没有多余空间了，那就只能老老实实去扩容了\n\n只能大的拆小的，小的空间不连续无法组成大的\n\n//二级空间配置器里面的reallocate封装template &lt;bool threads, int inst&gt;void*__default_alloc_template&lt;threads, inst&gt;::reallocate(void *p,                                                    size_t old_sz,                                                    size_t new_sz)&#123;    void * result;    size_t copy_sz;    if (old_sz &gt; (size_t) __MAX_BYTES &amp;&amp; new_sz &gt; (size_t) __MAX_BYTES) &#123;        return(realloc(p, new_sz));    &#125;    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);    result = allocate(new_sz);    copy_sz = new_sz &gt; old_sz? old_sz : new_sz;    memcpy(result, p, copy_sz);    deallocate(p, old_sz);    return(result);&#125;\n\n\n2.3 关于单例的说明在同一个进程里面，空间配置器只会有一个\n但STL库中的空间配置器并没有把自己设计成单例类，而是用了一个间接的做法\nstatic obj * __VOLATILE free_list[__NFREELISTS]; //哈希桶// Chunk allocation state.static char *start_free;static char *end_free;static size_t heap_size;\n\n那就是所有成员变量都是static静态的\n我们知道，在类和对象中，静态成员变量是属于整个类的，所以它也是一种单例模式！\n\n2.4 空间配置器的优点\n空间配置器的时间复杂度是O(1)，申请空间的效率很高\n空间配置器能解决频繁申请空间导致的内存碎片问题\n\n当我们使用STL容器频繁申请小块空间（比如list）就容易导致堆区中有非常多的小块空间被使用，而无法申请一个大的空间\n空间配置器提前申请了一个大块空间再私下管理，可以有效解决这个问题\n内存外碎片&#x2F;内碎片\n外碎片：多次申请小块空间造成。有足够内存，但是不连续，无法申请大块内存\n内碎片：list只需要12个字节，而空间配置器因为内存对齐而给了它16个字节，浪费了4个字节造成的内存碎片\n\n3.容器和空间配置器之前学习stl容器的时候，就在定义中看到过这里的alloc默认模板参数\n\n这里默认传的便是stl库中的二级空间配置器\n\n只要你自己写的空间配置器符合stl的接口需求，你便可以将自己的空间配置器传入此处让容器使用！\n\ntypedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc;typedef __default_alloc_template&lt;false, 0&gt; single_client_alloc;\n\n在list中，alloc又被封装了一层，用来处理节点申请的问题\ntemplate &lt;class T, class Alloc = alloc&gt;class list &#123;protected:  typedef void* void_pointer;  typedef __list_node&lt;T&gt; list_node;  typedef simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;\n\ntemplate&lt;class T, class Alloc&gt;class simple_alloc &#123;public:    static T *allocate(size_t n)                &#123; return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); &#125;    static T *allocate(void)                &#123; return (T*) Alloc::allocate(sizeof (T)); &#125;    static void deallocate(T *p, size_t n)                &#123; if (0 != n) Alloc::deallocate(p, n * sizeof (T)); &#125;    static void deallocate(T *p)                &#123; Alloc::deallocate(p, sizeof (T)); &#125;&#125;;\n\n随后，当创建节点、销毁节点的时候，list就会调用封装好的simple_alloc来处理空间\nlink_type get_node() &#123; return list_node_allocator::allocate(); &#125;void put_node(link_type p) &#123; list_node_allocator::deallocate(p); &#125; link_type create_node(const T&amp; x) &#123;    link_type p = get_node();    __STL_TRY &#123;      construct(&amp;p-&gt;data, x);//调用节点的构造函数    &#125;    __STL_UNWIND(put_node(p));    return p;  &#125;  void destroy_node(link_type p) &#123;    destroy(&amp;p-&gt;data);//调用节点的析构函数    put_node(p);  &#125;\n\n\nconstruct通过定位new显式调用节点的构造函数\ndestroy通过指针来调用析构函数\n\ntemplate &lt;class T&gt;inline void destroy(T* pointer) &#123;    pointer-&gt;~T();&#125;template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value) &#123;  new (p) T1(value);&#125;\n\n在stl_tree.h中可以看到库里面的红黑树也对空间配置器进行了类似的封装\ntemplate &lt;class Key, class Value, class KeyOfValue, class Compare,          class Alloc = alloc&gt;class rb_tree &#123;protected:  typedef void* void_pointer;  typedef __rb_tree_node_base* base_ptr;  typedef __rb_tree_node&lt;Value&gt; rb_tree_node;  typedef simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;  typedef __rb_tree_color_type color_type;\n\n结语关于空间配置器的内容了解这些就差不多啦！\n其实就是通过库里面的这个设计来了解一个提高小空间内存申请效率的方法，感觉还是很666的\n\n有啥问题可以在评论提出哦\n\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】类型转换方法","url":"/2022/10/20/code/note_cpp/26C++%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","content":"本篇博客让我们来见识一下C++中新增的类型转换方法\n\n\n[TOC]\n1.C语言中类型转换在C语言中，类型转换有下面两种形式\n\n隐式类型转换\n显示强制类型转换int a=(int)&#39;c&#39;\n\n这两种方式想必各位都很熟悉了，但隐式类型转换在一些场景里面会出现问题\nvoid insert(size_t pos,char c)&#123;\tint end=10;\twhile(end&gt;=pos)\t&#123;\t\tend--;\t&#125;\t//...&#125;\n\n上面的代码中，end是int类型，当进行比较的时候，end会-1直到小于pos\n如果pos=0，问题就来了！\n隐式类型转换会让end在比较的时候被转换为size_t无符号整型，而在无符号整型中，-1是一个非常大的正数，从而导致这个函数进入死循环！\n\n\n隐式类型转换可能会丢失数据的精度\n显示类型转换的写法都一样，导致不能很好的区分情况\n\nC++委员会也是认识到了这里的问题，当产生隐式类型转换的时候，难以跟踪错误的来源，于是开发了下面的新的类型转换方式\n\n不过，因为C++兼容C语言，所以C中的转换方式依旧支持\n\n\n2.C++中的强制类型转换C++中新增了下面四种明明的强制类型转换操作符\nstatic_cast、reinterpret_cast、const_cast、dynamic_cast\n\n2.1 static_cast这个关键字是用于相近类型之间的转换的，比如double和int，char和int之间\ndouble d = 11.4;int a1 = static_cast&lt;int&gt;(d);//相近类型的转换char ch = &#x27;a&#x27;;int a2 = static_cast&lt;int&gt;(ch);cout &lt;&lt; a1 &lt;&lt; endl;cout &lt;&lt; a2 &lt;&lt; endl;\n\n\n2.2 reinterpret_cast这个关键字用于不相近类型之间的转换，比如指针转成int\nint* p = &amp;a1;//int x = static_cast&lt;int&gt;(p);//报错：类型转换无效int x = reinterpret_cast&lt;int&gt;(p);//非相近类型中的转换cout &lt;&lt; x &lt;&lt; endl;\n\n打印的结果如下（每次运行都不一样）\n2029408\n\n2.3 const_cast如同其名，这个关键字的作用是取消一个变量的const属性\nconst int c1 = 3;//这里定义的变量是在栈上的，可以间接修改int* ptr1 = const_cast&lt;int*&gt;(&amp;c1);//取消const权限*ptr1 = 4;cout &lt;&lt; c1 &lt;&lt; endl;//修改了地址之后没有变化cout &lt;&lt; *ptr1 &lt;&lt; endl;\n\n\n欸，为什么我们取地址之后，修改为4了，变量c1本身不会变化呢？\n这是因为编译器做了一些优化，把c1放到了某个地方，取的时候并没有直接去内存里面取\nvolatile关键字这里我们可以使用volatile关键字修饰变量，要求每一次都必须要去内存中取\n//volatile关键字，每次访问c都去内存中取，屏蔽编译器优化volatile const int c2 = 3;int* ptr2 = const_cast&lt;int*&gt;(&amp;c2);//取消const权限*ptr2 = 4;cout &lt;&lt; &quot;volatitle:  &quot;;cout &lt;&lt; c2 &lt;&lt; endl;cout &lt;&lt; *ptr2 &lt;&lt; endl;\n\n\n2.4 dynamic_cast该关键字是用于继承中，将一个父类的指针/引用转换为子类对象的指针/引用\n之前学习继承的时候，我们了解过\n\n向上转型：父类的指针、引用可以直接指向子类对象的指针&#x2F;引用（这是一个赋值兼容的规则，不需要进行转换）\n向下转型：反过来之后，可以直接赋值吗？不够安全\n\ndynamic_cast的作用就是判断一个父类指针指向的是不是他的子类\n\n如果是，能够成功转换\n不能则返回0\n\n这个关键字最大的作用，便是可以帮我们判断这个父类指针&#x2F;引用指向的是否为一个子类对象\nclass A&#123;public:\tvirtual void f() &#123;&#125;&#125;;class B : public A&#123;&#125;;void fun(A* pa)&#123;\t// dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回0\tB* pb1 = static_cast&lt;B*&gt;(pa);\tB* pb2 = dynamic_cast&lt;B*&gt;(pa);\tcout &lt;&lt; &quot;pb1:&quot; &lt;&lt; pb1 &lt;&lt; endl;\tif (pb2)\t&#123;\t\tcout &lt;&lt; &quot;转换成功！pb2:&quot; &lt;&lt; pb2 &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;转换失败！pb2:&quot; &lt;&lt; pb2 &lt;&lt; endl;\t&#125;\t&#125;void test2()&#123;\tA a;\tB b;\tfun(&amp;a);\tfun(&amp;b);&#125;\n\n\n这里有个要求，那便是父类中必须要有虚函数（多态），否则无法成功转换\n\n3.C++强制类型转换的作用C++希望我们规范强制类型转换的情景，针对性的调用不同的关键字\n但是由于它没有强制，在实际情况中用的反而不多\n不过需要注意的是，强制类型转换会关闭&#x2F;挂起正常的类型检查，在强制类型转换之前，我们要仔细检查是否还有别的方法来达到目的。最好是避免使用强制类型转换!\n4.RTTI之前学习智能指针的时候，我们学过一种思路叫RAII\n这里的RTTI全称为Run-time Type identification，即运行时类型识别\nC++通过下面几种方式来支持RTTI：\n\ntypeid\ndecltype\ndyanmic_cast\n\n这个概念只需要了解即可！\n","categories":["遇见C++"],"tags":["C++","C++11"]},{"title":"【C++】函数重载的形式及其背后原理","url":"/2022/04/29/code/note_cpp/2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/","content":"常言道：中国有俩球，谁都赢不了！这句话在不同的语境下有不同的意思\nC++中，函数支持在同一作用域下声明几个功能类似的同名函数，但需要遵守以下规定……\n\n\nC++中，函数支持在同一作用域下声明几个功能类似的同名函数，但需要遵守以下规定\n\n形参个数不同\n形参类型不同\n形参类型的顺序不同\n\n编译器会在调用这些同名函数的时候，根据具体情况来选择不同的函数\n\n[TOC]\n1.函数重载的样式\n上面提到了函数重载的3个规定，下面让我们来用具体示例认识一下它们\n\n假设我们需要一个A+B的代码，如果每次都需要根据不同数据类型来写不同的函数去实现这个功能，未免有点太过繁杂。\n在C++中，只需要修改函数的参数，即构成了函数重载，编译器就会自己选择对应的函数进行相加操作\n1.1形参类型不同//函数重载int Add(int a, int rb)&#123;\treturn a + b;&#125;long Add(long a, long b)&#123;\treturn a + b;&#125;double Add(double a, double b)&#123;\treturn a + b;&#125;int main()&#123;\tcout &lt;&lt; Add(10, 20) &lt;&lt;endl;     cout &lt;&lt; Add(10L, 20L) &lt;&lt; endl;\tcout &lt;&lt; Add(10.0, 20.0) &lt;&lt; endl;\treturn 0;&#125;\n\n\n1.2形参个数不同int Add(int a, int b) &#123;\treturn a + b;&#125;//个数不同int Add(int a, int b, int c) &#123;\treturn a + b + c;&#125;\n\n\n1.3形参类型顺序不同这里的顺序并不是a和b的顺序哈！只把a和b换一个位置是不构成函数重载的\n这里指的是先传int再传double，和先传double再传int的两种函数\n//形参类型的顺序不同void Add(int  a, double b) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;&#125;void Add(double  a,int b) &#123;\tcout &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; b &lt;&lt; endl;&#125;\n\n\n\n1.4非函数重载只修改函数的返回值类型是不构成函数重载的\n\n\n2.C++实现函数重载的原理\n在看后续内容之前，建议先复习一下程序运行的4个阶段，以便理解后面的操作👉传送门\n\n这里使用我的树莓派在Linux系统下给大家演示一下函数重载背后的样式\n首先我创建了3个文件，test.c Add.h Add.cpp，文件的内容一并给出\n//Add.h#include&lt;iostream&gt;using namespace std;int Add(int a,int b);double Add(double a,double b);//Add.c#include &quot;Add.h&quot;int Add(int a,int b)&#123;\treturn a+b;&#125;double Add(double a,double b)&#123;\treturn a+b;&#125;//test.cpp#include &quot;Add.h&quot;int main()&#123;\tcout&lt;&lt;Add(1,2)&lt;&lt;endl;\tcout&lt;&lt;Add(1.5,2.5)&lt;&lt;endl;\treturn 0;&#125;\n\n可以看到，这里我们使用gcc这个C语言编译器编译程序的时候，出现了很多报错，因为C语言是不支持函数重载的\n\n2.1编译生成可执行文件需要使用g++编译器来编译这个代码\ng++ test.cpp add.cpp -o Tcpp\n\n执行./Tcpp运行该函数，可以看到正常输出了相加后的结果\n\n\n2.2查看汇编接下来我们要使用另外一个命令来查看可执行文件Tcpp的汇编代码\nobjdump -S Tcpp\n\n在这里面可以找到我们两个Add函数的位置，可见它们的地址是不同的，并且一个函数名为_Z3Addii，另外一个是_Z3Adddd\n\n2.2.1汇编函数名的含义这两个汇编代码中的函数名，其实包含了函数名、函数参数这两个信息\n\n拆分了其中一个，那么另外一个_Z3Adddd的意思就很明确了，末尾的两个d代表函数参数是(double,double)\n\n我们可以创建另外一个文件，查看它的汇编代码，进一步确认命名规则（其实这个命名规则是反推得出的）\n#include&lt;iostream&gt;using namespace std;void f(int a,int b)&#123;\tcout &lt;&lt;a&lt;&lt;endl;\tcout &lt;&lt;b&lt;&lt;endl;&#125;int main()&#123;\tf(3,4);\treturn 0;&#125;\n\n编译程序后，执行objdump -S，可以看到f函数被命名为_Z1fii，代表函数名长度为1，原本函数名f，和函数参数(int ,int)\n\n现在我们知道了汇编中这个函数名的命名规则，那它和C++支持函数重载有什么关系呢？\n\n在这之前，我们还需看看c语言程序，汇编代码中函数又是怎么命名的\n2.2.2查看C语言汇编这里我把之前的函数修改成了C语言的样式，gcc编译后再来看看它的汇编\nvoid f(int a,int b)&#123;\tprintf(&quot;%d %d\\n&quot;,a,b);&#125;\n\n\n然后你就会发现，C语言汇编代码中的函数名，就是函数原本的名字f，没有添加任何东西！\n\n2.3得出结论看到这里，你能猜出来为什么C++支持函数汇编，而C语言不支持了吗？\n\n没错！那是因为C++的汇编代码中，函数名还保存了函数的形参类型，而C语言中并没有保存，自然无法区分两个函数\n\n这个汇编函数名的命名方式也能解释C++函数重载的3种样式\n假设我们有一个fun函数，那么我们可以推断出它的汇编函数名\n\n\n\n类型\n形式一\n形式二\n\n\n\n形参个数不同\n_Z3funii(int,int)\n_Z3funiii(int,int,int)\n\n\n形参类型不同\n_Z3funii(int,int)\n_Z3fundd(double,double)\n\n\n形参类型顺序不同\n_Z3funid(int,double)\n_Z3fundi(double,int)\n\n\n同时也能解释为何只修改函数返回值类型是不构成重载的，因为汇编代码中没有保存函数的返回值\n\n正因为C++在汇编处理中能够以这种命名方式来区分同名的不同函数，并给它们赋予不同的地址，编译器在链接符号表的时候，才能通过函数传参的不同找到它需要调用的对应函数的地址\n\n在main函数的汇编中，也能找到对应函数的调用操作\n\n\n3.语法extern”C”因为C++汇编处理中对函数名的修饰和C语言不同，所以C++中有这么一个语法，专门用来告诉编译器，某某某函数要用C语言的规则来修饰\n #include &lt;iostream&gt;using namespace std;extern &quot;C&quot; int fun(int a,int b);int main()&#123;    int sum=fun(1,2);    return 0;&#125;int fun(int a,int b)&#123;     return a+b;&#125;\n\n可以看到，使用这种方式修饰的fun函数，在汇编中就只有函数名，而不是C++形式原本的_Z3funii\n\n这样C语言的代码就可以链接这种方式写的C++静态库（前提是这个静态库中没有函数重载和C++的语法）\n\n然后我就想问：这和C的静态库有啥区别……\n\n当然有了！一个库里面有很多很多代码，总有些函数接口是C语言也能支持的嘛，这些接口就用C语言的方式来修饰，这样C语言也能调用了，不一举两得？\n3.1C++调用C语言静态库除了更改修饰方式外，extern&quot;C&quot;还用于让C++程序来调用C语言写的库\n\n比如树莓派要用到的wiringPi库，它是用C语言实现的，在编程为静态库后，里面汇编对函数的修饰就固定了，并没有C++下的_Z1...和参数类型修饰。\n\n这时候如果用C++直接来调用这个函数，C++程序是找不到对应的函数的。在这种情况下，extern&quot;C&quot;的作用就是让编译器以C语言的方式去寻找对应函数\n比如下图的代码，调用了wiringPi库里面的初始化函数，是最常用的一个函数\n\n我们用G++编译器编译这个代码，就会发现，欸tnnd怎么没有报错啊？\n\n\n其实吧，库函数的开发者早就想到了这一点。在平日编程中，也有办法来解决这个问题——那就是用条件编译指令！\n3.2用条件编译解决问题前情提要：在C++的编译环境中有一个预定义符号__cplusplus\ncout&lt;&lt; __cplusplus &lt;&lt;endl;\n\n在linux环境下，编译器打印出了以下数字\n\n而在windows的VS2019编译器下打印了下面的数字\n\n咱先不管这个数字是啥意思（看起来是一个日期），至少在C语言中是没有这个预定义符号的\n\n这样我们就可以利用这个预定义符号，假设是C++环境，就放出extern&quot;C&quot;来声明函数，如果是C语言环境，就不用extern&quot;C&quot;\n方法一：批量extern\n#ifdef __cplusplusextern &quot;C&quot; &#123;#endif    void Add(int a,int b);    int fun(int a,int b);    //这里可以放多个函数的声明    //……    #ifdef __cplusplus&#125;#endif\n\n方法二：define一个符号为extern&quot;C&quot;，然后在每一个定义前面单独加\n#ifdef __cplusplus\t#define EXTERN extern &quot;C&quot; #else\t#define EXTERN#endifEXTERN void Add(int a,int b);EXTERN int fun(int a,int b);EXTERN int func(int a,int b);//……\n\n这样不管是C语言，还是C++的程序，都能正常建立符号表，找到对应的函数\n\nGithub：wiringPi库源码仓库\n\n可以看到，大佬当初编写wiringPi库的时候就用了这个方法，这也是为什么在我的树莓派上，G++编译器也能直接识别出wiringPi库的原因\n\n\n在找这部分资料的时候，还发现了一个小故事：wiringPi库现在已经不官方开源了。因为有很多初学者拿代码去烦原作者（于是作者在官网上写了“这不是给初学者玩的”告示）还有很多人倒卖他写的库，所以他就在最后一次公开后，停止了官方开源\n\n3.3C语言调用C++的库同理，有的时候我们也会用C语言来调用C++的库\n但是！就如我上头说的，这个库里面，可以供C语言调用的函数不能有C++的语法和函数重载\n\nGithub：TcMalloc代码仓库\n\n比较好的一个例子是谷歌的tcmalloc库：此存储库包含TCMalloc的C++代码。 TCMalloc是谷歌对C的malloc（）和C++运算符的定制实现，用于在我们的C和C++代码中分配内存。TCMalloc是一个快速的多线程malloc实现。\n\n整个库的函数入口是在tcmalloc.cc中定义的，打开它可以看到，虽然大部分代码都是用C++实现的，但是少部分函数接口因为没有C++的语法，所以使用了extern &quot;C&quot;让C语言也支持它\n\n但是我还发现，有些带有C++的函数接口，也用了extern &quot;C&quot;，那是不是我们上面的结论错了呢？\n\n实践出真知！\n4自己整一个静态库4.1C++调用C语言静态库首先创建一个VS的空项目，把我之前写的C语言单链表代码放进去\n\n右键这里的项目名称-属性，然后在配置属性-常规-配置类型中，把项目改成静态库\n\n修改完毕后，编译程序，你会发现debug目录下多了静态库文件.lib\n\n然后在我们当前的C++项目中，修改项目属性-链接器-常规-附加库目录和项目属性-链接器-输入-附加依赖项\n\n\n最后以#include &quot;../Slist/Slinklist.h&quot;的形式引用静态库\n你会发现直接引用是会报错的，因为这个单链表的库是用C语言写的，我们没有使用extern &quot;C&quot;来引用\n\n使用了之后，程序正常调用了C语言的库，并打印出了结果！\n\n4.2C语言调用C++静态库接着，我们再写一个简单的C++程序，用上面同样的方法编译成静态库，并在C语言的项目中调用它\n\n可以看到，这个没有任何C++语法的C++静态库被正常调用并打印出了结果\n\n如果我们不使用extern &quot;C&quot;，C语言项目就无法正常使用该静态库\n\n而当我们在C++的静态库中包含C++的头文件后，C语言项目中也报错了！\n#include &lt;iostream&gt;using namespace std;\n\n光是链接库函数头文件和命名空间就报错了，那不能使用带C++语法的函数也是板上钉钉的事情了！\n\n而在具有extern &quot;C&quot;属性的路径中，也不能包含函数重载，VS会报错\n\n在头文件中定义自己的命名空间，在C语言项目中也是无法通过编译的\nnamespace muxue &#123;\tint a = 0;&#125;using namespace muxue;\n\n\n现在可以确认我们的结论，只有不包含任何C++的语法和函数重载的C++静态库，才能正常被C语言项目调用！\n勘误，上述结论错误\n22-05-06，在同学的提示下，发现了这个错误\n\n之前C调用C++的方式有问题，因为我是直接把C++的语法放到了头文件中，在展开的时候C程序编译会报错\n但如果把C++的语法放入cpp文件，头文件中不包含的话，就不会报错了！\n\n可以看到在最后的测试项目中，C语言程序成功调用了c++的语法并正确输出了内容\n\n这也能解释我关于谷歌TCmalloc库的疑惑了，看来C和C++真的是互通有无啊！\n\n结语本篇笔记详细解释了C++中函数重载的类型，以及背后的实现原理。\n这个博客花了我整整4小时的时间，感觉很充实！\n\n所以求个赞不过分吧！谢谢大家！\n\n\n","categories":["遇见C++"],"tags":["Linux","C++"]},{"title":"【C++】引用和内联函数","url":"/2022/05/10/code/note_cpp/3%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","content":"阿巴阿巴，最近搭建好了腾讯云的Linux环境，所以本篇C++的博客就尝试在Linux环境下来测试代码吧！阿巴阿巴，最近搭建好了腾讯云的Linux环境，所以本篇C++的博客就尝试在Linux环境下来测试代码吧！\n今天学习了C++的引用和内联函数，一起来瞅瞅它们都是些啥……\n\n\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n\n[TOC]\n前言众所周周知，C语言之中，有一个叫指针的家伙，它的使用方式如下\nint main()&#123;\tint a=10;\tint*p=&amp;a;//p是一个指针变量，指向a        return 0;&#125;\n\n这时候我们就可以通过*p对指针解引用访问变量a\n所以C++之中也有一个类似的东西，叫做引用，不过它和指针完全不同哦\n\n1.引用1.1基本形式引用的基本方式如下\nint a=10;int&amp; b=a;int&amp; c=a;//同一个变量可以有多个别名//可以用两个不同的变量名引用同一个//但是引用了之后不可以更改对象\n\n此时的b和c都是a的别名，注意是别名！\n  \n可以用两个不同的变量名引用同一个变量，而且引用了之后不可以更改对象\n\n一个变量可以有多个引用\n指针可以更改指向的对象，引用不可以\n引用必须在定义的时候就初始化，不可以int&amp; b;\n\n\n比如你叫李华，有人叫你“小李”，还有人叫你“英语作文人”，这两个外号都是你的别名。\n\n指针并不是别名，指针是通过地址访问某个变量。而引用是给a变量起另外的两个名字，实际上b和c都可以当作a来使用\n\n编译运行代码，让编译器打印出这三者的地址，可以看到它们的地址是一样的，因为它们本来就是同一个变量的不同名字。\n\n\n指针变量的地址和指针变量所指向对象的地址是不同的\n\n引用的类型必须和引用实体的类型相同，不能用int&amp;引用double类型\n\n\n1.2引用的权限问题①const常量引用可以引用常量，但是必须加const修饰\n\n基本的思路就是“权限可以缩小，但不可以放大”。\n\n在上面的代码中，a是一个可以修改的变量，但是const int&amp;d=a;中的d是不能修改，只可读取a的内容。\ne是不可修改的常量，所以我们不能用int&amp;来放大权限\n\n②int和double相互引用在1.1中有提到，我们不能用int&amp;来引用double类型的变量，编译器会报错\n\n不过我们可以用const int&amp;类型来引用double，此时引用就不是简单的一个别名了\n先来了解一下把double复制给int类型，这时候会产生“隐式类型转换”，h保存的是z的整数部分\n\n\n在这个过程中，编译器会产生一个临时变量存放z的整数部分，然后赋值给h\n\n临时变量具有“常性”，可读不可改\n\n而当我们用const int&amp;类型来引用double时，实际上引用的是编译器产生的临时变量，它是一个常量，所以我们需要用const int&amp;来引用\nconst int&amp; i=z;//这里的i是临时变量的别名//在引用的时候，创建了一个临时变量存放d的整数部分//i的地址和z不相同，且临时变量不会销毁，生命周期和i同步//生成的这个临时变量是常量，所以i的本质是引用了一个int类型cout &lt;&lt;&quot;i= &quot;&lt;&lt;i&lt;&lt;endl;cout &lt;&lt;&quot;&amp;i= &quot;&lt;&lt; &amp;i &lt;&lt;endl; cout &lt;&lt;&quot;&amp;z= &quot;&lt;&lt; &amp;z &lt;&lt;endl;//在c++中函数主要使用引用传参，后面会进一步学习\n\n一个非常直观的验证方法，就是打印一下，瞅瞅它们的地址是否相同。可以看到，i的值和h是相同的，因为它引用的就是那个存放了整数部分的临时变量，这个临时变量的地址和z不同\n\n1.3引用的使用场景①函数传参众所周知，在C语言中，如果我们想在函数中修改某一个main传过来的参数，就必须进行传址调用。而在C++中，我们可以通过引用来操作\n\n可以看到，我们通过引用实现了在函数中修改a的值\n\n更加充分的体现便是Swap函数，在C语言中必须两个都传地址来调用\n在C++中，配合函数重载，我们可以很方便的写出多个交换函数\n\n\n直接测试一下，交换成功！\n\n\n②函数返回值int&amp; Count()&#123;  int n=0;//现在没有加static，返回的变量n可能会覆盖  n++;  cout&lt;&lt;&quot;&amp;n:&quot;&lt;&lt;&amp;n&lt;&lt;endl;  return n;&#125;int main()&#123;  int&amp; ret = Count();  cout&lt;&lt; ret &lt;&lt;endl;  cout&lt;&lt;&quot;&amp;ret:&quot;&lt;&lt;&amp;ret&lt;&lt;endl;  cout&lt;&lt; ret &lt;&lt;endl;&#125;\n\n当我们把n作为int&amp;类型来返回时，ret此时是对n的引用。但是函数中的变量n在出了函数后销毁了，所以在main函数中打印ret的时候，可能会打印出随机值（这个要看什么时候n的内容会被编译器覆写）\n\n而当我们带上static后，多次打印n的值都不会出现问题，因为此时n的空间并没有被销毁\n\n\n如果函数返回时，出了函数作用域，如果返回对象还未还给系统，则可以使用引用返回\n如果已经还给系统了，则必须使用传值返回，避免出现访问随机值\n\n\n下面用一个简单的Add函数来演示一下上面提到的两种情况\n\n如果去掉static修饰，编译器会报警告，而且打印的值会在第二次cout调用的时候被覆写\n\n当Add函数的c变量加了static修饰后，打印的值都是稳定的，不会被覆写（因为c的空间没有被销毁）\n\n③优化函数调用时间在函数返回传参的时候，其实是先把返回值存放到寄存器中，而不是直接返回给main函数的变量\n\n当返回值很小（指占用空间）的时候，会用寄存器存放它的值\n当返回值很大的时候，部分编译器会先在main函数中预先开辟栈帧用来存放返回值\n\n\n而使用引用作为返回值的时候，就不需要用寄存器来接收临时变量，这时候就优化了函数返回的时间！\n\n可以看到，用引用返回的时间消耗很小！\n\n再来试试把引用作为参数传参的消耗，和传址、传值进行对比，代码和上面的类似，稍微修改一下测试函数就行了\n\n可以看到，传地址和引用作为参数的传参消耗都是很小的。因为传值的时候需要拷贝数据！\n\n\n1.4引用和指针的汇编代码用下面的代码来查看引用和指针的汇编区别\n#include &lt;stdio.h&gt;int main()&#123;\tint a = 10;\tint&amp; ra = a;\tra = 20;\tint* pa = &amp;a;\t*pa = 20;  \treturn 0;&#125;\n\n你可以看到，指针和引用的汇编代码是相同的。因为C++的引用，本质上是用指针实现的！\n\n用objdump -S语句，查看Linux环境下的汇编👇\n\n1.5引用和指针的区别\n引用是别名；指针是指向地址\n引用必须在定义的时候初始化；指针无要求\n引用的sizeof大小和引用对象相同；指针无论指向的谁，大小都是4&#x2F;8\n引用不能为NULL；指针可以为NULL\n引用++即对象数值+1；指针++是指向的地址向后偏移\n引用无多级；指针存在二级、三级……\n引用比指针使用起来更加安全（不会出现野指针）\n引用是编译器处理的；指针需要手动解引用\n……\n\n2.内联函数2.1基本形式在函数名前用inline修饰的函数是内联函数，编译器在处理此类函数的时候，会将函数在调用它的地方打开。此时内联函数就没有函数压栈的开销，提高了程序运行的效率\n\n这部分和C语言学习过的#define类似，但define是直接替换，内联函数不是\n\n#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;#define ADD(a,b) ((a)+(b))inline int Add(int a,int b)&#123;  return a+b;&#125;int main ()&#123;  int sum=ADD(1+3,2+4);//4+6=10       printf(&quot;%d\\n&quot;, sum);   int ret = 0;  ret=Add(3,4);  return 0;&#125;\n\n2.2查看预处理文件使用下面的Linux语句可以把源文件生成为预处理后的文件\n\n这部分可以看看我之前用树莓派操作的博客哦！【传送门】\n\ng++ -E test.cpp -o test.i\n\n可以看到define被替换了，但是内联函数并没有\n\n2.3查看汇编代码①Linux环境这时候我们先编译这个文件\ng++ test.cpp\n\n然后使用下面的语句查看汇编代码\nobjdump -S a.out\n\n然后你就发现，这不还是有call函数调用嘛？这哪里没有调用呢？\n\n实际上，我们在编译的时候需要调整编译器的优化操作👉【参考博客】\ng++ -O2 test.cpp\n\n这时候的汇编代码就没有call了\n\n②VS2019要想调整VS2019的优化等价，需要在项目属性中C/C++ -常规中修改调试信息格式为“程序数据库”\n\n然后在优化-内联函数扩展修改成只适用于inline(/Ob1)\n\n然后调试，右键转到反汇编，可以看到，no call🕵️‍♂️\n\n\n2.4内联函数的特性define没有传参检查，且不能debug+可读性不高，内联函数解决了这一缺点\n\n内联函数是用空间换时间的做法，省去函数调用的开销\n函数代码很长的时候不适合用内联函数（define同理）\n在代码行数很长的时候，编译器会自己判断是否使用inline。如果函数体内有循环&#x2F;递归等，编译器优化的时候会取消内联\ninline不可以声明和定义分离，会导致链接错误\n\n对最后一点展开介绍一下，当我们把内联函数的声明和定义放在不同的源文件和头文件中，编译器会报错找不到函数\n\n这是因为内联函数在调用的时候已经展开了，对应的函数地址也没了，所以无法正常链接\n\n结语引用和内联函数的博客到这就结束啦，如果对你有帮助，还请点个赞再走哦！\n\n笔记难免有错，还请大佬们无情指出！\n\n","categories":["遇见C++"],"tags":["Linux","C++"]},{"title":"【C++】auto关键字、范围for、nullptr关键字","url":"/2022/05/12/code/note_cpp/4auto%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cnullptr/","content":"本篇博客一起来继续学习C++的语法\n\n\n\n\n\nauto关键字\nnullptr关键字\n\n\n\n范围for\nlinux如何使用C++11规则\n\n\n[TOC]\n0.linux设置c++11在linux平台下想使用C++11标准有两个办法\n方法1是在.cpp文件的最开头加入下面的这个语句\n#pragma GCC diagnostic error &quot;-std=c++11&quot;\n\n但是这个方法哈，我发现加了它之后使用nullptr还是会报错，但是auto和typeid都可以使用了\n方法2是在编译的时候在加上-std=c++11\ng++ -std=c++11 test.cpp -o test \n\n使用这个方法比较完美\n1.auto关键字\n\n在C++11中，auto作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得\n\n简而言之，这个关键字的作用就是自动给变量设置一个数据类型\n1.1基本使用#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int TestAuto()&#123;     return 10;&#125;int main()&#123;    int a = 10;    auto b = a;    auto c = &#x27;a&#x27;;    auto d = TestAuto();    auto e = &quot;abc&quot;;    char str[20]=&quot;hello auto!&quot;;    auto f =str;        cout &lt;&lt; typeid(b).name() &lt;&lt; endl;    cout &lt;&lt; typeid(c).name() &lt;&lt; endl;    cout &lt;&lt; typeid(d).name() &lt;&lt; endl;    cout &lt;&lt; typeid(e).name() &lt;&lt; endl;//PKC    cout &lt;&lt; typeid(f).name() &lt;&lt; endl;//Pc    //VS下会打印完整的类型，返回的是字符串    //linux下只会打印缩写，其中PKc代表pointer(p) to Const(k) Char(c)    //而如果是字符串，打印的就是Pc，pointer to Char    return 0;&#125;\n\n在上面的代码中，我们使用了typeid().name()来打印变量的类型，使用这个函数需要引用头文件&lt;typeinfo&gt;\n\n可以看到，编译器正确打印出了每一个变量的数据类型，auto自动判断并给这些变量赋予了数据类型\n\nVS下typeid()函数会打印完整数据类型\nLinux下只会打印缩写\n其中PKc代表pointer(p) to Const(k) Char(c)，也就是const char*\nPK代表const修饰的指针；P代表指针，如Pc是char*、Pi是int*\n\nauto e; //无法通过编译，使用auto定义变量时必须对其进行初始化\n\n使用auto关键字的时候，必须要在定义的时候初始化变量。\n其实这很好理解，本来auto就是一个自动根据初始化内容来赋予数据类型的关键字，如果你不给我初始化内容，我哪知道你需要赋值的类型是谁呢？\n\n因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。\n\n1.2使用细节①和指针&#x2F;引用同时使用如图，auto在处理指针变量的时候，带不带*是不受影响的\n\nPi是pointer to int，即int的指针\n\n\n②在同一行定义多个变量如果使用auto在同一行定义多个变量的时候，前后定义的变量必须是同一个类型的\nauto a=1,b=3;//可以auto a=1,b=2.4;//不可以\n\n1.3auto不能用的地方①auto不能作为数组的声明比如下面的这种情况，是不行的\nauto arr[]=&#123;1,2,3,4&#125;;\n\n\n②auto不能用来作为函数的参数和返回值void test(auto a);auto test(int a);\n\n函数的返回值和传参都不能是auto\n因为这样会给使用者带来极大的误导，我连你的返回值是什么类型都不知道，我用啥来接收？？再用一次auto吗？？😂\n\n\n为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法\n\n其实auto最大的作用还是在C++11提供的新式循环中使用👇\n2.范围for循环2.1 基本用法在之前，如果我们想遍历一个数组，一般会使用下面的方式\n这是最经典的for循环语句，想必你肯定不陌生\n\n但这方法太麻烦了！每次都要弄一个sizeof来计算长度，这不纯纯坐牢吗\n\n于是哈，C++11就利用auto关键字提供了另外一个遍历数组的方法\nfor(auto e : arr)       cout &lt;&lt; e &lt;&lt; &quot; &quot;; \n\n没错！就是这么简单的参数设置，就能让auto自己打印出数组内的值！\n这也太省事了👍\n\n这里注意哈，如果在for里面设置的e没有带&amp;引用，其对数据内容的更改是不会改变源数组的。你可以理解为这里是临时传了参数给了e，然后再打印e的值\n\n如果想修改数组的内容，给e带上引用即可\n\n编译器会自动判断什么时候数组打印完毕，所以你想打印一个字符数组也是没问题的\n\n我是用的这个vim配置好像更加智能，因为他把数组中空着的部分也“打印出来了”。实际上编译器并不会打印空出来的值\n\n这点可以在for循环结束后再打印EOF来验证\n\n与普通循环类似，可以用continue来结束范围for循环，也可以用break来跳出整个循环。\n另外，直接使用变量类型来操作范围for也是可以的\n\n2.2 使用条件使用范围for的时候，必须给定一个准确的范围\n\n在遍历数组的时候，这个范围就是数组的开头和结尾\n对于类而言，应该提供begin和end的 方法，begin和end就是for循环迭代的范围\n\n也就是说，我们必须给定一个数组名，而不能给定一个指针\nvoid TestFor4(int*ptr)&#123;\tfor(auto e : ptr)\t\tcout&lt;&lt;e&lt;&lt;&quot; &quot;;&#125;\n\n比如这种使用方法就是错误的，因为编译器不知道这个数组到底什么时候结束\n\n即便把传参改成数组的形式也是不行的\n\n至于为什么范围for里面用的是冒号嘛，好问题，我不知道\n\n2.3 范围for会拷贝数据同时在测试的时候，我还发现原来STL库容器里面的迭代器遍历的时候，是会把自定义类型拷贝构造一份的\n\n实际上，auto在进行范围for的时候，是会拷贝一份数据给e的。\n用引用避免拷贝的代价想让他不进行这种拷贝，就需要给auto&amp;加上引用才可以\n\n下一个知识点！\n\n3.nullptr关键字nullptr是C++11引入的新关键字\n3.1NULL在C语言中，NULL代表空指针\nint*p1=NULL;\n\nNULL实际是一个宏，在c语言头文件stddef.h中，可以看到如下代码：\n#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endif\n\n可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量\n3.2问题引出那么问题就来了，如果我在调用函数的时候传了NULL，编译器究竟会把它识别成int类型，还是识别成指针类型呢？\n\n比如在上面的函数重载代码中，编译器就不知道要调用哪一个函数了，除非你给NULL来一个(int*)强制转换一下\n编译文件会看到如下报错\ntest.cpp|17 col 5 error| call to &#x27;f&#x27; is ambiguous\n\n小码农英语课堂开课啦！今天学习的是ambiguous\n\n\n所以说！C++急需另外一个东西的加入来避免NULL的这种模糊传参情况\n3.3使用nullptr其他需要介绍的就无啦，你只要知道，nullptr不再是一个代表0的值，而是一个专门的关键字，代指空指针的情况，就OK啦！\n\n\n最后是几点注意：\n\n在使用nullptr表示指针空值时，不需要包含头文件，因为它是C++11的关键字 \n在C++11中，sizeof(nullptr)=sizeof((void*)0)\n为了提高代码的稳定性，后续写C++代码的时候一律用nullptr，不再使用NULL\n\n\n结语好啦，本篇C++的笔记到这里就结束喽\n有什么问题大家可以在评论提出哈\n","categories":["遇见C++"],"tags":["Linux","C++"]},{"title":"【C++】类和对象1：初识类+this指针","url":"/2022/05/19/code/note_cpp/5%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A11_%E5%88%9D%E8%AF%86%E7%B1%BB/","content":"不知你在学习C语言和C++的适合，曾否听过老师这么讲述这两个语言之间的区别：\n\nC语言是面向过程的\nC++是面向对象的\n\n\n\n我一直不太理解这二者之间的区别，在查阅了一些博客后，发现了一个比较好的解释👉【传送门】\n\n用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。所谓盖浇饭，北京叫盖饭，东北叫烩饭，广东叫碟头饭，就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜，你就浇上什么菜。\n\n本篇博客，就让我们从类和对象开始，渐渐了解什么是“面向对象编程”\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n\n[TOC]\n1.类的引入1.1结构体在C语言中，我们可以定义自定义类型：结构体。在C++中对结构体的语法进行了扩充，结构体内部不仅能定义变量，还能定义函数\nstruct Student&#123;\tvoid Print()    &#123;\t\tcout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;\t&#125;\tchar _name[20];    char _sex[8];    int _age;    char _phone[20];&#125;;\n\n1.2class为了和C语言里面的结构体作为区分，我们不再用struct来指代这种包含函数的自定义类型，而是使用class作为它的名字，称之为类\nclass className&#123; //类体：由成员函数和成员变量组成&#125;; //一定要注意后面的分号\n\nclass为定义类的关键字，ClassName为类的名字，&#123; &#125;中为类的主体，注意类定义结束时后面分号（这一点和结构体相同）\n类中的元素称为类的成员：\n\n类中的数据称为类的属性或者成员变量\n类中的函数称为类的方法或者成员函数\n\n2.类成员的定义类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 ::作用域解析符指明成员属于哪个类域。\n2.1函数声明和定义分离和普通的函数一样，类同样支持声明和定义分离。下面的代码中，我并没有分离函数的声明和定义\n\n成员函数在类里面定义，编译器会默认处理为内联函数\n\nclass Student&#123;\tvoid Print()    &#123;\t\tcout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;\t&#125;\tchar _name[20];    char _sex[8];    int _age;    char _phone[20];&#125;;\n\n如果需要在.h中写入类的定义，类外面的.cpp中编写类里面的函数，就需要用到类似于命名空间的使用方法::\nclass Student&#123;\tvoid Print();//声明函数\t\tchar _name[20];    char _sex[8];    int _age;    char _phone[20];&#125;;\n\n在另外的源文件中定义函数\n#include &quot;Student.h&quot;void Student::Print()&#123;\tcout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;&#125;\n\n当我们编写大型项目的时候，一般都会采用声明和定义分离的方式来编写源码，这样可以更方便他人快速查阅我们的头文件，理解代码的“大纲”\n\n这样看起来好像和以前的方式没啥区别。但当我们引入访问权限的概念后，一切都变啦！\n2.2访问限定符class的默认访问权限是私有；struct默认为公有\n\n你不知道什么是访问权限？那就继续往下看👇\n\n我们可以用public和private这两个访问限定符来表明某一个具体类型的共有还是私有。它们的最大区别就是在这个类的外部能不能访问\n\n\npublic成员可以在类外面直接使用\nprotected和private修饰的成员只能在类里面访问\n访问权限的作用域是从该访问限定符出现，到下一个访问限定符出现为止\n访问限定符是在编译过程中处理的，并不影响数据在内存上的存放\n\n在前期学习的时候，我们可以认为protected和private是相同作用的\nclass Student&#123;public:    //函数在类里面定义，编译器默认为内联函数    void Print()    &#123;        cout&lt;&lt;_name&lt;&lt;&quot; &quot;&lt;&lt;_sex&lt;&lt;&quot; &quot;&lt;&lt;_age&lt;&lt;&quot; &quot;&lt;&lt;_phone&lt;&lt;endl;    &#125;    void Init(const char * name,const char*sex, int age,const char* phone)    &#123;        strcpy(_name,name);        strcpy(_sex,sex);        _age=age;        strcpy(_phone,phone);    &#125;    //函数在类里面声明    void Delet();private:    //这个是对变量的声明    //变量的声明：没有开辟空间    //变量的定义：开辟了空间来存放内容    char _name[20];    char _sex[8];    int _age;    char _phone[20];    //在创建对象的时候定义&#125;;\n\n\n数据和方法分装到一个类里面\n想给你自用访问的（如函数接口）设置为共有\n不想给你访问的（如通讯录每个用户的信息类型）设置为私有\n\n这样可以做到，当函数定义修改之后，只要不修改函数声明，就不需要修改main函数中函数的调用！这叫做：高内聚，低耦合\n2.3封装为什么会有权限的出现呢？我们可以细想一下下面这个场景：\n\n假设我们编写了一个数组栈的代码，里面有一个top用来标明栈顶的元素位置。一般可以把top定义为0或者1，但是这两种方法的函数使用是不同的！如果有那个铁憨憨跑过来，非要把那个top的定义给改掉，那整个代码就废掉不能用辣！\n设立私有和公有的初衷，就是为了避免这种情况。开放一些共有函数供类外面访问，这样对整个代码的访问会变得易于管理。当我们自己修改类里面的代码时，只需要做好处理，就不会影响类外面的函数调用（否则就是直接推翻重写了）\n\n这便是我们常常提到的封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。\n3.类的实例化用类类型创建对象的过程，称为类的实例化\n\n类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它\n一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量\n\n类就好比一个毛坯房，现在毛坯房建好了，要想它变得精致，我们还需要在main中调用这个类，不然毛坯房就要变成烂尾楼了\nStudent p1;p1.Init(&quot;牛爷爷&quot;,&quot;男&quot;,58,&quot;13251341680&quot;);p1.Print(); \n\n4.计算类的大小一般有4种类：包含函数和变量的、只包含函数的、只包含成员变量的、空类\n\n让我们来康康如何计算这些类的大小，解析见注释哦！\n其实只需要记住，空类和只有函数的类会有1个字节的空间。计算类的空间的时候不会计算函数大小，成员变量的大小计算遵循结构体内存对齐的计算方法就行了！\n#include&lt;iostream&gt;using namespace std;class A1&#123;public:    void func1()    &#123;        int ret=3;        return ;    &#125;&#125;;class A2&#123;&#125;;class A3&#123;public:    char _a;&#125;;\n\n\n#include &lt;iostream&gt;using namespace std; class A&#123;&#125;; int main(void)&#123;    cout &lt;&lt; sizeof(A) &lt;&lt; endl;//空类是1    return 0;&#125;\n\n\n\n5.this指针5.1特点当你用同样的图纸建了很多个屋子后，有没有想过应该如何区分它们呢？\nC++在设计这部分的时候，添加了一个this指针来解决这个问题：\n\nC++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参 数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。\n\n\nthis指针的类型：类名* const \n只能在“成员函数”的内部使用 \nthis指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。 \nthis指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递\n\n5.2显式使用this就用下面这个函数举例\nvoid Print()&#123;\tcout&lt;&lt;_name&lt;&lt;endl;\tcout&lt;&lt;_sex &lt;&lt;endl;&#125;\n\n实际上，在调用它的时候，编译器会做如下处理\nvoid Print(Student*const this)&#123;\tcout&lt;&lt;this-&gt;_name&lt;&lt;endl;\tcout&lt;&lt;this-&gt;_sex &lt;&lt;endl;&#125;\n\n因为只有这样，才能完整的区分两个不同的类\n\n进一步看看下面这个代码，可以帮助你理解this指针\nbool operator==(const Date&amp; d)&#123;       return _year == d._year           &amp;&amp; _month== d._month           &amp;&amp; _day == d._day;&#125;\n\n这是一个日期的比较函数，是操作符重载（后面会讲到）\n你可以看到，这个函数我们传入了一个Date类型的引用，这是区别于this的另外一个类的对象\n如果没有this，那就很难区分两个变量的_year，于是编译器会把它优化成下面这样，就不会存在无法区分的问题了\nbool operator==(Date*const this,const Date&amp; d)&#123;       return this-&gt;_year == d._year           &amp;&amp; this-&gt;_month== d._month           &amp;&amp; this-&gt;_day == d._day;&#125;\n\n5.3空指针问题int main()&#123;    int x=10;    //在程序中，访问NULL不会报错，但是解引用Null会报错    int*a=NULL;    int*b=&amp;x;    //a=x;//err    *b=20;    return 0;&#125;\n\n#include&lt;iostream&gt;using namespace std;class ta&#123;public:    void Print()    &#123;        cout&lt;&lt;&quot;print ta&quot;&lt;&lt;endl;        //cout&lt;&lt;_a&lt;&lt;endl;    &#125;private:    int _a;&#125;;int main()&#123;    ta* p=nullptr;    p-&gt;Print();   //可以去访问空指针的函数   //因为函数只是去调用了类里面的Print函数   //同时传了一个p的this指针（空指针传参是不会报错的）   //但是如果你去访问p里面_a变量，就会报运行错误    return 0;&#125;\n\n6.类中成员函数的处理除了this指针之外，编译器在链接函数名的时候，也做了相应的处理。在Linux里面查看下面这串代码的汇编代码\n#include&lt;iostream&gt;class Test&#123;public:    void func1(const int* a1,int* k,const int*a2,char arr)    &#123;        *a1+*a2;        func2(a1,k,a2,arr);    &#125;    private:    void func2(const int* a1,int* k,const int*a2,char arr)    &#123;        *a1+*a2;    &#125;&#125;;int main()&#123;    Test t;    int arr1[10];    int arr2[20];    int a=10;    t.func1(arr1,&amp;a,arr2,&#x27;a&#x27;);        return 0;&#125;\n\n可以找到这两个类的成员函数的地址和函数名\n\n方法参考我的这篇博客👉【末影门】\n\n00000000004006da &lt;_ZN4Test5func1EPKiPiS1_c&gt;:000000000040071a &lt;_ZN4Test5func2EPKiPiS1_c&gt;:\n\n可以发现，这两个函数的地址不同，但函数名中并没有包含它的公有、私有信息。这也能证明2.2中写道的“访问限定符是在编译过程中处理的，并不影响数据在内存上的存放”\n\n下面是一个普通函数（不在类里面）的函数名\n\n观察类里面的函数名，可以看到比起普通函数，它还包含了类名，来标明自己是被封装在某个类里面的。同时前缀也从_Z变为了_ZH\n\n\n这里S1_的含义是我多次传相同类型参数，查看汇编代码测试出来的\n\n当我把相同传参的函数放在类外面，重新查看汇编代码\n\n000000000040064d &lt;_Z5func3PKiPiS0_c&gt;:\n\n可以看到它发生了一些变化，比如前缀变为了_Z，函数名后面的E不见了，S1_变成了S0_\n虽然我现在还不知道前缀_Z和_ZH、函数名后面那个E分别代表什么含义，但是我们可以看的出，这是编译器在编译链接过程中为了区分类中函数和类外函数做的优化\n\n结语本篇博客是类和对象的第一篇笔记，不知能否帮到你呢\n\n","categories":["遇见C++"],"tags":["Linux","C++","类和对象"]},{"title":"【C++】类和对象2：默认成员函数+操作符重载","url":"/2022/05/20/code/note_cpp/6%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A12_%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/","content":"本篇是类和对象的第二站🚌\n主要讲述类的几个默认成员函数，以及操作符重载\n本篇博客会涉及到很多之前C++专栏里面提到的知识点，建议连起来观看。\n\n\n\n感谢你关注慕雪，欢迎来我的寒舍坐坐❄慕雪的寒舍\n\n\n[TOC]\n默认成员函数当我们创建一个类的时候，即便类里面啥都不放，都会自动生成下面6个默认成员函数\n\n它们都有啥功能呢？且听我一一道来\n1.构造函数众所周周知，当我们写C语言的顺序表、链表等代码的时候，一般都会写一个Init函数来初始化内容。\nvoid Init()&#123;\ta=(int*)malloc(sizeof(int)*4);\tsize=0;\tcapa=4;&#125;\n\n但是这样有一个缺点，就是不够智能，需要我们自己来调用它进行初始化。\n于是C++就整出来了一个构造函数来解决这个问题\n1.1特性构造函数：名字和类名相同，创建类对象的时候编译器会自动调用，初始化类中成员变量，使其有一个合适的初始值。构造函数在对象的生命周期中只调用一次\n构造函数有下面几个特性：\n\n函数名和类名相同\n无返回值\n构造函数可以重载\n对象实例化的时候，编译器会自动调用对应的构造函数\n如果你自己不写构造函数，编译器会自己创建一个默认的构造函数\n\n1.2基本使用下面用一个队列来演示一下构造函数\nclass Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;//测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n可以看到，在创建对象q1的时候，编译器就自动调用了类中的构造函数，帮我们初始化了这个队列\n\n\n除了上面这种最基本的无参构造函数以外，一般写构造函数的时候，我们都会带一个有缺省值的参数，这样可以更好地灵活使用这个队列\nQueue(int Capacity=4)&#123;    _a=(int*)malloc(sizeof(int)*Capacity);    _size=0;    _capa=Capacity;&#125;\n\n调用这种构造函数也更加灵活，我们可以根据数据类型的长度，来创建不同容量的队列，避免多次realloc造成的内存碎片\nQueue q1;//调用无参的构造函数Queue q2(100);//调用带参的构造函数\n\n多种构造函数是可以同时存在的，不过！它们需要满足函数重载的基本要求\n当你调用一个无参的函数，和一个全缺省的函数的时候，编译器会懵逼！\nQueue();Queue(int Capacity=4);//这两个函数不构成重载，会报错\n\n正确的重载应该是下面的情况\nQueue();Queue(int Capacity);\n\n编译器在创建对象的时候，就会智能选择这两个构造函数其中之一进行调用。但是同一个对象只会调用一个构造函数\n1.3编译器默认生成的构造函数上面提到过，如果我们不写构造函数，编译器会自己生成一个。\n但测试过以后，你会发现，这个默认生成的构造函数，好像啥事都没有干——或者说，它把_a _b _c 都初始化成了随机值！\n\n实际上，编译器默认生成的构造函数是不会处理内置类型的\n\n内置类型：int、char、float、double……\n外置类型：自定义类型（其他的类）\n\n在处理的时候，编译器忽略内置类型；外置类型会调用它的构造函数\nclass Date&#123;public:    //默认构造函数：不传参就能调用的    //1.全缺省 2.无参 3.编译器自动生成    //可以是半缺省的，但是不实用    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;        _A.Print();    &#125;private:    //编译器会自动生成构造函数（如果你没有自己写的话）    //自动生成的构造函数是不会初始化内置类型的    //内置类型：int,char,double等等    int _year;    int _month;    int _day;    //外置类型：自定义类型    //外置类型会调用它自己的默认构造函数    Queue _A;&#125;;\n\n可以看到，编译器调用了自己的构造函数的同时，还调用了外置类型Queue的构造函数，搞定了它的初始化\n\n如果我们去掉Date的构造函数，就能看到下面的情况。Queue成功初始化，但是内置类型的年月日都是随机值\n\n一般情况下一个C++类都需要自己写构造函数，下面这两个情况除外\n\n类里面的成员都是自定义类型成员（且有自己的构造函数）\n如果还有内置类型成员，声明时给了缺省值\n\n注：只有类在声明变量的时候才可以给缺省值\n//下面的情况就不需要写class MyS&#123;    private:      Queue q1;//自定义类型      Queue q2;      int a=1;//内置类型声明的时候给了缺省值&#125;;\n\n\n\n1.4初始化列表除了上面的方式之外，还有一种构造函数的使用方式为初始化列表\nDate(int year=2022,int month=2,int day=30)    :_year(year),\t_month(month),\t_day(day)&#123;&#125;\n\n\n每个成员变量只能在初始化列表中出现一次\n类中包含以下成员必须在初始化列表中进行初始化\n引用\nconst成员\n自定义类型成员\n\n\n\n一般情况下，建议使用初始化列表进行初始化。因为对于自定义类型的成员变量，初始化列表的优先级是高于&#123; &#125;里面的内容的。\n这里还有非常重要的一点！\n成员变量在类中声明的顺序就是初始化列表的顺序，而并非初始化列表自己的顺序！\n\n怎么理解呢？看下面这个代码\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(month)\t&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n即便我们把_day放在了初始化列表的首位，但由于它是在最后声明的。所以构造函数走初始化列表的时候，会依据声明顺序，依次初始化年、月、日。\n\n这会引起什么问题？再来看看一个错误示例\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(_day)&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n当我们用上面这个初始化列表的时候，我们本意是想在初始化完_day以后，将_day的值赋给_month。但由于_month的声明顺序在_day之前，所以_month(_day)会先执行，此时的_day尚为随机值，这就导致月份变成随机值了！\n\n这只是一个示例，实际上肯定不会用天数初始化月数，范围不一样\n\n最好的办法，就是声明顺序和初始化列表的顺序保持一致！\n\n1.5 explicit关键字构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有隐式类型转换的作用。\nclass Date&#123;public:    //正常的构造函数    //Date(int year)    //    :_year(year)    //    &#123;&#125;\t    explicit Date(int year)        :_year(year)        &#123;&#125;private:    int _year;    int _month:    int _day;&#125;；void TestDate()&#123;    Date d1(2018);    // 用一个整形变量给日期类型对象赋值    // 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值    d1 = 2019;&#125;\n\n当我们调用赋值的时候，实际上编译器会先用2019构造出一个date类型对象，再调用赋值重载（这里还没有写）赋值给d1。这就是一个隐式类型转换\n如果我们用explicit修饰了这个构造函数，那么编译器将不会进行此类隐式类型转换！\n1.6规范命名类的成员变量为了更好的使用构造函数，以及区分类内外的函数类型\n一般我们定义类中的成员变量的时候，都会使用一个下划线进行标明_YEAR\n在一些地方，你会看到函数名前面也带了一个_，这一般表明该函数是另外一个函数的子函数，同样是用于区分的。\n\n不同人的代码风格不同，你可以选择你自己喜欢的风格，但不能影响我们程序的正常使用\n\n比如下面这种情况，就会影响类的构造了\nclass Date&#123;public:    Date(int year=2022)    &#123;        year=year;    &#125;private:    int year;&#125;;\n\n请问year=year里面的这个year，到底是成员变量，还是构造函数的传参呢？编译器又双懵逼了\n实际上，编译器在找year的时候，会先在当前&#123; &#125;中找，找到了传参的year，就不会去找其他地方的year了。所以这个语句实际上是传参过来的year自己给自己赋值，编译器会报错。\n\n2.析构函数和构造函数相对应，析构函数是对象在出了生命周期后自动调用的函数，用来爆破对象里的成员（如进行free操作）\n生命周期是离这个对象最近的&#123; &#125;括号\n2.1特性\n析构函数名是在类名前加~\n无参数，无返回值\n一个类只能有一个析构函数\n如果你没有自己写，编译器会自动生成一个析构函数\n\n和构造函数一样，编译器自己生成的析构函数不会处理内置类型；会调用外置类型的析构函数\n2.2基本使用析构函数的定义和我们在外部写的Destroy函数一样，主要执行free操作\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue&quot;&lt;&lt;endl;//测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;    ~Queue()    &#123;        //析构函数        free(_a);        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;//测试调用    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n假设我们在main函数里面定义了两个对象，你能说出q1和q2谁先进行析构函数的调用吗？\n\n可以看到，先调用的是q2的析构函数\n\n因为在底层操作中，编译器会给main函数开辟栈帧\n栈遵从后进先出的原则，q2是后创建的，所以在析构的时候会先析构\n\n3.拷贝构造3.1特性和使用拷贝构造是一个特殊的构造函数，它的参数是另外一个Date类型。在用已有的类类型对象来创建新对象的时候，由编译器自动调用\n因为拷贝的时候我们不会修改d的内容，所以传的是const\n另外，我们必须进行传引用调用！\n\n这里补充说明一下，下面的这个函数，在传参的时候，编译器会去调用Date的拷贝构造\nvoid func(Date d);\n\n如果你没有写拷贝构造，或者拷贝构造里面不是传引用，编译器会就递归不断创建新的对象进行值拷贝构造，程序就死循环辣\n//拷贝构造，如果不写的时候，编译器会默认生成一个    //对内置类型进行值拷贝(浅拷贝)    Date(const Date&amp; d)    &#123;        _year=d._year;        _month=d._month;        _day=d._day;        //外置类型会调用外置类型的拷贝构造        Queue b(_A);    &#125;\n\n和构造、析构不同的是，编译器自己生成的拷贝构造终于有点用了\n\n它会对内置类型进行按内存存储的字节序完成拷贝，这种称为值拷贝（又称浅拷贝）\n对外置类型会调用它的构造函数\n\n\n3.2外置类型拷贝问题但是！如果你使用了外置类型，该类型中包含malloc的时候，编译器默认生成的构造函数就不能用辣！\n因为这时候，编译器默认生成的拷贝构造会进行值拷贝，拷贝完了之后，就会出现q1和q2指向同一个空间的情况。修改q2会影响q1，free的时候多次释放同一个空间会报错，不符合我们的拷贝构造的要求\n\n注意注意，malloc不行的原因是，数据是存在堆区里面，拷贝的时候，q2的_a得到的是一个地址，而不是拷贝了新的数据内容。\n\n如果你在类里面定义了一个int arr[10]数组，这时候拷贝构造就相当于memcpy，是可以完成拷贝的工作的。\n\n如何解决这个问题呢？我们需要使用深拷贝\n这里我还没有学到那个地方，后续写深浅拷贝的博客的时候，再来填上这个坑\n\n黑马16分钟视频速成完毕，前来填坑\n\n3.3深拷贝3.3.1new和delete这里先给大家从C语言转到C++，讲解一下new和delete关键字，它们分别对应malloc和free\n非常简单！比malloc的使用简单多了！\nint main()&#123;    int*p1=new int;//开辟一个int类型的空间    int*p2=new int(10);//开辟一个int类型的空间，并初始化为10    int*p3=new int[10];//开辟10个int类型的空间    //注意后两个的括号区别！        delete p1;//销毁p1指向的单个空间    delete p2;//同上        //delete p3;//销毁p3指向的第一个空间，不能用于数组    delete[] p3;//销毁p3指向的数组        return 0;&#125;\n\n怎么样？是不是超级简单！\n\n\n3.3.2深拷贝实现在上面写道过，编译器会自动生成拷贝构造函数，完成值拷贝工作。但是队列的代码里面包含堆区的空间，需要我们正确释放。这时候就需要自己写一个拷贝构造完成深拷贝👇\n//拷贝构造Queue(const Queue&amp; q)&#123;    _a=new int[q._capa];//注意解引用    memcpy(_a, q._a, q._capa*sizeof(int));//拷贝内容    _size=q._size;    _capa=q._capa;&#125;\n\n用下面这个队列的代码来测试深拷贝\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;//测试是否调用        //_a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;        _a=new int[_capa];    &#125;    //拷贝构造    Queue(const Queue&amp; q)    &#123;        cout&lt;&lt;&quot;Queue Copy&quot;&lt;&lt;endl;        _a=new int[q._capa];        memcpy(_a, q._a, q._capa*sizeof(int));        _size=q._size;        _capa=q._capa;    &#125;    void Set()    &#123;        for (int i = 0; i &lt; _capa; i++)        &#123;            _a[i] = i + 1;        &#125;    &#125;    void Print()    &#123;        cout&lt;&lt;&quot;this:&quot;&lt;&lt;this&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;_a:&quot;&lt;&lt;_a&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;        for(int i=0;i &lt; _capa;i++)        &#123;            cout&lt;&lt;_a[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    ~Queue()    &#123;        //析构函数        //free(_a);        delete[] _a;        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;int main()&#123;     Queue q1;    q1.Set();    q1.Print();    cout&lt;&lt;endl;    Queue q2=q1;     q2.Print();    cout&lt;&lt;endl;    return 0;&#125;\n\n3.3.3深拷贝效果先注释掉Queue的拷贝构造函数析构函数（不然会报错）\n看一看，发现在不写拷贝构造函数的时候，q2和q1的_a指向了同一个地址\n\n取消析构函数的注释，可以看到两次释放同一片空间，发生了报错\n\n如果我们把写好的深拷贝构造加上，就不会出现这个问题\n\n当你加上给_a里面初始化一些数据，以及打印_a数据的函数后，就可以看到，不仅q2的_a有了自己全新的地址，其内部的值也和q1一样了\n\n这样写出来的拷贝构造，即便把队列中的int* _a修改为char*或者其他类型，都能正确完成拷贝工作\n\n这里有一个小点哈，就是打印char* _a的地址的时候，咱需要用printf而不是cout，因为cout会把_a直接当作字符串打印了，效果就变成了下面这样\n\n用printf来控制输出格式为%x即可\nprintf(&quot;_a:%x &quot;,_a);\n\n\n4.运算符重载4.1定义在讲解赋值运算符重载之前，我们可以来认识一下完整的运算符重载\n\nC++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。\n\n函数名为：关键字 operator运算符，如operator=\n函数原型：返回值类型 operator操作符(参数列表)，如Date operator=();\n下面有几点注意：\n\n重载操作符必须有一个自定义类型的操作数（即操作符重载对内置类型无效）\n不能通过其他符号来创建新的操作符\n对于类类型的操作符重载，形参比操作数少一个传参（因为有一个默认的形参this指针）\n这5个操作符是不能重载的：.*、::、sizeof、? :、.\n\n4.2基本使用以下是在全局定义的操作符重载，用于判断日期是否相等\nbool operator==(const Date&amp; d1, const Date&amp; d2)&#123;    return d1._year == d2._year;    &amp;&amp; d1._month == d2._month    &amp;&amp; d1._day == d2._day;&#125;\n\n当我们在main函数中使用d1==d2的时候，编译器就会自动调用该操作符重载\n当然，你也可以自己来传参使用，如if(operator==(d1,d2))\n但是这样非常不方便，和调用一个而普通函数没啥区别，压根算不上操作符重载。所以我们一般是在类里面定义操作符重载的\n\n\n当我们把它放入类Date中间，就需要修改成下面这样\nbool operator==(const Date&amp; d2)&#123;    return _year == d2._year;    &amp;&amp; _month == d2._month    &amp;&amp; _day == d2._day;&#125;\n\n编译器在调用的时候，会优化成下面这样\nbool operator==(Date* this, const Date&amp; d2)//显示调用为 d1.operator==(d2);\n而在main里面使用的时候，这个重载后的操作符和原本的使用方法完全相同\nDate d1(2022,6,1)Date d2(2022,5,1)d1==d2;//自动调用操作符重载d1.operator==(d2);\n\n后续会以日期类为样板，实现更多的操作符重载\n\n4.3赋值运算符重载因为每一个类都有不同的成员，编译器不可能智能的进行赋值操作。这时候就需要我们自己写一个赋值运算符重载来进行赋值操作了\n以日期类为例，赋值操作其实就是把内置类型成员一一赋值即可\nDate&amp; operator=(const Date&amp; d)&#123;    if(this != &amp;d)//避免自己给自己赋值    &#123;        _year=d._year;        _month=d._month;        _day=d._day;    &#125;    return *this;&#125;\n\n编写赋值重载代码的时候，需要注意下面己点：\n\n返回值和参数类型（注意要引用传参，不然会调用拷贝构造）\n检测是否自己给自己赋值（避免浪费时间）\n因为返回的是*this，出了函数后没有销毁，所以可以用传引用返回\n一个类如果没有显式定义赋值运算符重载，编译器也会自己生成一个，完成对象按字节序的值拷贝。\n\n如果类中有自定义类型，编译器会默认调用它的赋值运算符重载（这里也会涉及到深浅拷贝的问题，后面会在深浅拷贝的博客里详解）\n4.4拷贝构造和赋值重载的调用问题当赋值操作符和拷贝构造同时存在的时候，什么时候会调用赋值，什么时候会调用拷贝构造呢？\n\n在这两个函数中添加cout进行打印提示，可以看到：\n\n如果对象在之前已经存在，就会调用赋值重载\n如果是一个全新的变量在定义的时候初始化，就调用的是拷贝构造\n\n\n5.const成员5.1用const修饰类的成员函数\n将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰的是该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改。\n\n基本的修饰方法如下，在函数的括号后加const即可\nvoid Print()const&#123;\tcout&lt;&lt;_year&lt;&lt;endl;&#125;\n\n实际修饰的是该函数隐含的this指针\nthis指针本身是Date*const类型的，修饰后变为const Date* const类型\nvoid Print(const Date* const this)&#123;\tcout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;&#125;\n\n\n①实例-权限问题这么说好像有点迷糊，我们用实例来演示一下为什么需要const修饰成员函数\nclass Date&#123;public:    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;    &#125;private:    int _year;    int _month;    int _day;&#125;;\n\n假设我们需要在函数中调用Print函数，在main中是可以正常调用的\nint main()&#123;\tDate d1(2022,5,10);    d1.Print();    return 0;&#125;\n\n但当你用一个函数来进行这个操作的时候，事情就不一样了\nvoid TEST(const Date&amp; d)&#123;\td.Print();//d.Print(&amp;d) --&gt;const Date*&#125;int main()&#123;\tDate d1(2022,5,10);    d1.Print();//d1.Print(&amp;d1) --&gt;Date*    TEST(d1);        return 0;&#125;\n\n这时候我们进行了引用调用，因为在TEST中我们不会修改d1的内容，所以用const进行了修饰\n\n这时候TEST中的d.Print()函数调用，传入的是const Date*指针，指针指向的内容不能被修改\nmain中的d1.Print();函数调用，传入的是Date*指针\n\n于是就会发生权限冲突问题👇\n\n这时候如果我们在函数后面加了const，就可以避免此种权限放大问题。这样不管是main函数还是TEST函数中对Print()函数的调用，就都可以正常打印了！\n\n总结一下：\n\nconst对象不可以调用非const成员函数（权限放大）\n非const对象可以调用const成员函数（权限缩小）\nconst成员函数内不可以调用其他非const成员函数（权限放大）\n非const成员函数可以独调用其他const成员函数（权限缩小）\n\n\n\n\n②什么时候需要使用？众所周周知，const修饰指针有下面两种形式\n\n在*之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）\n在*之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）\n\nthis指针本身就是类型名* const类型的，它本身不能被修改。加上const之后，this指向的内容，既类里面的成员变量也不能被修改了。\n知道了这一点后，我们可以合理的判断出：只要是需要修改类中成员变量的函数，就不需要在()后面加const修饰\n如果一个函数中不需要修改成员变量，就可以加const进行修饰\n注意：如果你用了声明和定义分离的写法，那么声明和定义的函数都需要加上const修饰\n\n③出错提醒这里有一点需要提醒的是，如果你对某一个函数进行了const修饰，那么这个函数里面包含的其他类里面的函数，都需要进行const修饰。不然就会报错\n\n出现该报错的情况如下\n\n这个情况也提醒我们，不能在const修饰的函数中，调用非const修饰的成员函数\n\n5.2取地址及对const取地址重载最后两个默认成员函数，编译器会自动生成。这两个函数一般都不需要重载，毕竟返回的本身就是一个this指针，没有什么奇怪的地方\nclass Date&#123; public :     Date* operator&amp;()     &#123;         return this ;     &#125;         const Date* operator&amp;()const     &#123;     \treturn this ;     &#125;private :     int _year ;      int _month ;     int _day ;&#125;;\n\n只有特殊情况，我们需要让&amp;只获取特定内容的时候，才需要手动重载这两个函数\n6.构造，析构顺序下面这个代码是一个很好的示例（22.12.31）\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; class A&#123;public:    A(int count)    &#123;        c = count;        cout &lt;&lt; c &lt;&lt; &quot; init this:: &quot; &lt;&lt; this &lt;&lt; endl;    &#125;     ~A()    &#123;        cout &lt;&lt; c &lt;&lt; &quot; des this:: &quot; &lt;&lt; this &lt;&lt; endl;    &#125;private:    int c;&#125;; A a1(1);//全局 int main()&#123;    A* p = new A(2);//堆区    A a2(3);//栈区    static A a3(4);//静态区     cout &lt;&lt; &quot;#####&quot; &lt;&lt; endl;    delete p;//堆区被主动释放，肯定是第一个析构的&#125;\n\n最终打印的结果如下\n1 init this:: 00D4E4642 init this:: 0160F5583 init this:: 0133F9D84 init this:: 00D4E46C#####2 des this:: 0160F5583 des this:: 0133F9D84 des this:: 00D4E46C1 des this:: 00D4E464\n\n总结：\n\n构造顺序和写代码的运行顺序一致\n析构时候，堆区若手动delete，那么肯定是按delete的顺序析构的\n自动析构的时候，遵循栈-静态-全局的顺序析构\n\n\n日期类的实现类和对象第一站🚌中提到过，在项目协作的时候，我们一半要用定义和声明分离的形式来些一个项目。\n\n下面就让我们用日期类来演示这样的操作\n\n在类中定义的函数会被默认设置为内联，我们的目标就是：短小函数在.h中定义，长函数在.h中声明，在.cpp中定义\n至于源码和解析嘛……大家直接来我的gitee仓库看吧！【传送门】\n注释写的很详细了⏲有啥问题可以在下面留言哦\n\n特殊：对&lt;&lt;和&gt;&gt;的重载这里的&lt;&lt;和&gt;&gt;主要是在使用cin和cout的时候需要使用\n①简单了解io在cplusplus网站上，你可以看到下面这一副图。在使用cin和cout的时候，我们其实分别调用了不同头文件的内容。\n\ncin：istream\ncout、cerr、clog：ostream\n\n\n实际上，流是一个类型的对象，这个对象完成了输入和输出的操作\n\n流操作是系统GUI支持的（了解一下就行，我也不懂）\n\n在cout的定义中，你可以看到，实际上cout为了完成自动识别类型进行输出操作的工作，对各种类型进行了操作符重载operator&lt;&lt;\n\n显然，这部分重载中不包含自定义类型，所以我们需要来仿照这里的函数，进行重载操作\n这里涉及到了友元函数，在类和对象的下一篇博客中我会写道。不过现在你只需要知道，友元函数是某一个类的朋友，目的是在类外访问类里面的成员变量\n\n友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。\n\n②实现最后实现的效果如下，头文件中在最前面进行声明\n\n//这两个是友元函数(因为需要在类外面访问类里面的成员变量)//注意cin和cout的不同实现//因为我们没有完全展开std namepace，所以写这个函数的时候需要自己指定std:://返回值为ostream是为了保证多次coutstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Date&amp; d)&#123;\tout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day &lt;&lt; endl;\treturn out;&#125;//cin使用的是istreamstd::istream&amp; operator&gt;&gt;(std::istream&amp; in, Date&amp; d)&#123;\tint year,month,day;    in &gt;&gt; year &gt;&gt; month &gt;&gt; day;    //这里应该添加一个对日期的正确性判断     if(year&gt;=0        &amp;&amp;(month&gt;=1&amp;&amp;month&lt;=12)        &amp;&amp;(day&gt;=1&amp;&amp;day&lt;=d.GetMonthDay(year,month)) )    &#123;//判断日期正确性        d._year=year;        d._month=month;        d._day=day;    &#125;    else    &#123;        cout&lt;&lt;&quot;Date err!&quot;&lt;&lt;endl;        exit(0);//日期错误直接终止程序    &#125;\treturn in;&#125;\n\n程序运行的效果如下，和我们直接使用cout、cin是一样的！\n\n当你写了一个离谱日期后，程序也会进行正确的报错\n\n③疑惑解答你可能会想，干嘛用友元啊，直接在类里面定义这个函数重载不就可以了？\n之所以在外头定义该函数，是因为类里面定义的函数，默认会带有一个隐含的this指针传参，作为操作符的左操作数。\n然后你的函数使用就得变成下面这样😱\nd1&lt;&lt;cout;\n\n虽然也能跑起来并完成工作，但这样写也太怪了！\n结语最后的最后，今天是5月20日，用下图给大家送上祝福😂\n\n","categories":["遇见C++"],"tags":["Linux","C++","类和对象"]},{"title":"【C++】动态内存管理","url":"/2022/06/25/code/note_cpp/8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"在之前类和对象的博客里面，已经记录过了C++中动态内存管理函数new和delete的基本使用。本篇博客是对C++动态内存管理的进一步细化\n\n\n[TOC]\n1.C&#x2F;C++内存分区这是一个老生常谈的问题了，直接看下面这个图吧！\n\n这里的数据区其实就是静态区，而代码区是常量区。这里的BBS区先暂时pass掉。\n要想辨别上面的几个内存分区，可以现来看下面这个代码，你能分的清楚它们都是存在内存的哪一个区域吗？\nint a = 1;//数据区static int b = 1;//数据区int main()&#123;     static int c = 1;//数据区     int d = 1;//栈     int arr1[10] = &#123;1, 2, 3, 4&#125;;//栈     char arr2[] = &quot;abcd&quot;;//栈     char* arr3 = &quot;abcd&quot;;//&quot;abcd&quot;存在代码区     int* ptr = (int*)malloc(sizeof (int)*4);//堆     free (ptr);    //其中，ptr指针本身是存在栈区的    //同理，arr3指针本身存在栈区    //但是arr3指针指向的对象是存在代码区（静态区）&#125;\n\n2.C++动态内存管理在C语言中，基本的动态内存管理通过malloc和free实现\nint* ptr = (int*)malloc(sizeof (int)*4);//堆free (ptr);\n\n在C++中，对应产生了new和delete，它们比前者更加高级，具有更多特性\n2.1基本认识new和delete下面是基本的使用方式，想必大家看了之后，是“有手就行”😂\nint*p1=new int;//开辟一个int类型的空间   int*p2=new int(10);//开辟一个int类型的空间，并初始化为10   int*p3=new int[10];//开辟10个int类型的空间   //注意后两个的括号区别！      delete p1;//销毁p1指向的单个空间   delete p2;//同上      //delete p3;//销毁p3指向的第一个空间，不能用于数组   delete[] p3;//销毁p3指向的数组\n\n2.2操作类对象new相比于malloc，最大的区别在于处理自定义类型的时候。类和对象就是C++中与C语言完全不同的自定义类型。\n我们知道，当你使用类名创建一个对象的时候，编译器会自动调用这个对象的构造函数。那如果我们用new来创建一个自定义类型的对象呢？\nclass Stack&#123;private:    int* _a;&#125;int main()&#123;    Stack* p1=(Stack*)malloc(sizeof(Stack));    Stack* p2=new Stack;        return 0;&#125;\n\n这时候的区别就在于\n\nnew在创建的对象的时候，会自动调用该对象的构造函数\nmalloc在创建对象的时候，不会调用构造函数\n\n这样就能解释，为什么C++要单独弄出一个new，而不是继续沿用C语言的malloc了。因为我们在class中定义成员变量的时候，大多数是定义成私有的。如果对象在创建的时候没有进行构造，我们很难从外部访问类内部的私有成员进行初始化操作。\n所以new的出现，让我们能够在堆上开辟对象空间的同时，初始化这个对象。\n不难理解，delete和free的区别也是如此：\n\n当你调用delete的时候，编译器会调用类的析构函数\n使用free不会调用析构函数，可能造成内存泄漏\n\n\n2.3对象数组// 申请单个Test类型的对象 Test* p1 = new Test; delete p1;  // 申请10个Test类型的对象 Test* p2 = new Test[10]; delete[] p2;\n\n和内置类型一样，我们也可以方便的使用new来实现开辟对象数组\n注意，在delete操作的时候，一定要注意匹配问题，不能直接用delete p2来释放开辟的数组空间\n\n2.4给构造函数传参如果这个类的构造函数是包含参数的话，还可以使用下面这种方式在开辟空间，调用构造函数时传参（注意括号区别）\nTest* p3 = new Test(10);//给对象Test的构造函数传参delete p3;\n\n\n3.operator new&#x2F;delete函数看到这个名字，估计你和我一样，会下意识的认为这个是c++中对new和delete操作符的重载。nope！这两个实际上是C++中实现new和delete的一部分函数\n为啥说是一部分呢，让我们来康康它的源码\noperator new (std::size_t sz) _GLIBCXX_THROW (std::bad_alloc)&#123;  void *p;  /* malloc (0) is unpredictable; avoid it.  */  if (sz == 0)    sz = 1;  while (__builtin_expect ((p = malloc (sz)) == 0, false))    &#123;      new_handler handler = std::get_new_handler ();      if (! handler)    _GLIBCXX_THROW_OR_ABORT(bad_alloc());      handler ();    &#125;  return p;&#125;\n\n你回复下，这个函数最终使用了malloc来开辟空间，只是在这之上，new还引入了抛异常机制\n\nC语言中，malloc错误会返回null指针\nC++中，new错误会执行抛bad_alloc异常操作\n\n不知抛异常是什么？我们可以暂且不用理解它。只需要知道，当new失败的时候，控制台会直接报错终止程序，而不是和malloc一样，将指针变空指针，从而导致可能出现的解引用空指针操作。\n实际上，当我们new一个对象的时候，会执行下面两个函数\noperator new对象的构造函数\n\n在VS中打开调试，转到反汇编，你便可以看到编译器call这两个函数的操作\n\n再来看看operator delete的代码\n\nhttps://cplusplus.com/reference/new/operator%20delete/\n\nvoid operator delete(void *pUserData)&#123;\t_CrtMemBlockHeader * pHead;\tRTCCALLBACK(_RTC_Free_hook, (pUserData, 0));\tif (pUserData == NULL)\t\treturn;\t_mlock(_HEAP_LOCK); /* block other threads */\t__TRY\t/* get a pointer to memory block header */\tpHead = pHdr(pUserData);\t/* verify block type */\t_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));\t_free_dbg( pUserData, pHead-&gt;nBlockUse );\t__FINALLY\t_munlock(_HEAP_LOCK); /* release other threads */\t__END_TRY_FINALLY\treturn;&#125;\n\n我们发现，delete最终也是通过调用free实现的\n\n但是这里的反汇编，我就有点看不懂了。看起来也调用了一个Stack函数，姑且认为那个就是Stack的析构函数吧\n\n3.1 new和delete的实现原理看到这里，让我们来总结一下new和delete的实现原理。\nnew的原理：\n\n调用opeartor new申请空间，错误时抛异常\n如果操作的是自定义类型，则调用构造函数\n\nnew int[N]原理:\n\n调用operator new[]（没错库里面还有一个这个函数）\n在operator new[]中实际调用N个operator new来申请空间\n如果操作的是自定义类型，则还会分别调用N次构造函数\n\ndelete的原理：\n\n在原始空间上调用析构函数，清楚内容\n调用operator delete执行对象空间的free操作\n\ndelete int[N]的原理：\n\n调用N次析构函数\n调用operator delete[]，实际调用N个operator delete来释放N个对象的空间\n\n3.2 delete加[]和不加的区别\n 1、delete 释放new分配的单个对象指针指向的内存\n\n​     2、delete[] 释放new分配的对象数组指针指向的内存\n​     3、delete处理单个类类型，先会调用析构函数，释放它所占资源，然后释放它所占内存空间。\n​     4、delete处理数组类类型的时候，会对每一个数组对象都调用它们的析构函数，然后再释放它们所占用的内存空间。所以对于类类型的数组如果不调用delete[],那就只调用了下标为0的对象的析构函数，可能会产生问题。\n​     5、两个都会释放所占内存，对于内置类型不管是数组还是单个对象，都可以混用，没有关系，因为对于内置类型，它只干一件事，就是释放它们所占内存\n​     6、如果对于单个类对象，delete和delete[]都可以，因为delete是知道它要释放多大空间的，加不加[]括号的区别是对不对每个对象调用析构函数，如果只有一个的话，它就调用一次，所以没有关系。\n4.定位new定位new表达式会在已分配的原始内存空间中调用构造函数初始化对象\n\n啊嘞，new不是会自己调用构造函数吗？这个定位new有是来干什么的？\n\n查阅了一些我现在看不懂的资料后，了解到，定位new的操作多半是配合自己写的内存池来进行操作。在之前博客中出现的Tcmalloc就是谷歌写的一个内存池\n4.1什么是内存池？当我们使用new或者malloc时，是通过编译器向操作系统申请空间\n而内存池就是一个我们写的预先申请内存空间的模块\n这个模块会在执行后，先预先向操作系统要一个相对较大的空间。我们后续的操作就是在这个已经开辟好的空间中再次申请空间来实现的\n因为这样就是从自己的口袋里面拿东西，没有中间商赚差价，效率就会提高不少。\n但是这样就没有了new本身自动调用构造函数的优势，需要我们自己来调用构造函数\n4.2定位new的使用new(place_address) type或者new(place_address) type(initializer-list)\n\n以下面这个类为例\nclass Stack &#123;public:    Stack(int num = 5)    &#123;        _a = new int[num];        _capa = num;        cout &lt;&lt; &quot;Stack(int)&quot; &lt;&lt; endl;    &#125;    ~Stack()    &#123;        delete[] _a;        _capa = 0;        cout &lt;&lt; &quot;~Stack()&quot; &lt;&lt; endl;    &#125;private:    int* _a;    int _capa;&#125;;\n\n我们先使用malloc来模拟没有调用构造函数的情况，再使用定位new来调用构造函数\nint main()&#123;    Stack* p= (Stack*)malloc(sizeof(Stack));\tnew(p) Stack; //如果类的构造函数有参数时，此处需要传参&#125;\n\n可以看到，编译器成功调用了构造函数\n\n\n5.更多知识点5.1 malloc和new的区别malloc&#x2F;free和new&#x2F;delete的共同点是：都是从堆上申请空间，并且需要用户手动释放\n不同的地方是： \n\nmalloc和free是函数，new和delete是操作符\nmalloc申请的空间不会初始化，new可以初始化（通过new int(10))\nmalloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可（其实就是省略了sizeof这一步的操作）\nmalloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型\nmalloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常\n申请自定义类型对象时，malloc&#x2F;free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中内存的清理\n\n5.2 内存泄漏我们知道，当堆区申请的空间没有进行释放的时候，就会出现内存泄漏，造成内存的浪费，甚至导致操作系统boom！\n\n\n堆内存泄漏\n\n堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存， 用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生堆内存泄漏\n\n系统资源导致的泄漏\n\n系统资源泄漏 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统 资源的浪费，严重可导致系统效能减少，系统执行不稳定。\n\n除了忘记free或者delete之外，另外的一些情况导致程序提前终止，也会出现内存泄漏\nint main()&#123;    Stack* p1 = (Stack*)malloc(sizeof(Stack));    Stack* p2 = new Stack;            free(p1);    return 1;//只是做个示例，实际上哪有人这么写代码啊！        delete p2;    return 0;&#125;\n\n比如上面这个函数中，free之后执行了return，跳过了delete的操作，即导致p2的内存没有被释放，出现了内存泄漏\n解决内存泄漏有很多办法，其中最好的办法就是维持一个良好的代码风格，避免出现忘记释放内存的情况！\n5.3 深拷贝这个麻烦大家移步之前类和对象的博客啦\n\nhttps://blog.csdn.net/muxuen/article/details/124881928?spm=1001.2014.3001.5501\n\n\n结语本篇博客到这里就结束了\n期末考试其实已经结束5天了，我还在摸鱼……呜呜\n\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C++】快速学习类和对象，看这一篇就够了","url":"/2022/05/30/code/note_cpp/7%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A13_%E5%A4%A7%E4%BD%9C%E4%B8%9A/","content":"本篇博客是学校大一下C++期末考察的要求，包含了C++中类和对象的大部分内容，适合学习类和对象的你观看。最后还有两个小项目，综合了绝大部分类和对象的知识，很适合练手+深化学习。\n\n\n为了避免被同校copy，本篇博客只在我的HEXO个人博客上发布\n第一章 绪论1.1 面向对象程序特点与目标面向对象有下面几个特征：\n\n类与对象：把现实世界中的某一类东西，提取出来，用代码表示；\n封装性：把过程和数据封装到一个包裹里面，对数据的访问只能通过公开权限的函数接口来进行操作；\n继承性：一种联结类的层次模型，类似树状结构；\n多态性：允许不同类的对象对同一消息做出响应，用不同的方法来解决一个问题。\n\n通过这些特征，我们可以看得到，其实面向对象的程序也是在C语言的面向过程的基础上得来的。其目的也是为了更好的服务某一个具体的问题，并通过这个问题衍生出不同的解题方法，并用代码来表示解决一个问题对象的过程。\n1.2 面向对象程序知识架构\n\n第二章 面向程序对象关键支撑技术2.1 类和对象类和对象与命名空间类似，都是存在一种封装。不同的是，类是对C语言struct结构体类型的拓。除了变量以外，类里面还可以定义成员函数，并设置它们的权限，实现了对一个接口的完整封装。\n2.1.1 构造函数众所周周知，当我们写C语言的顺序表、链表等代码的时候，一般都会写一个Init函数来初始化内容。\nvoid Init()&#123;\ta=(int*)malloc(sizeof(int)*4);\tsize=0;\tcapa=4;&#125;\n\n但是这样有一个缺点，就是不够智能，需要我们自己来调用它进行初始化。\n于是C++就整出来了一个构造函数来解决这个问题\n特性\n构造函数：名字和类名相同，创建类对象的时候编译器会自动调用，初始化类中成员变量，使其有一个合适的初始值。构造函数在对象的生命周期中只调用一次\n构造函数有下面几个特性：\n\n函数名和类名相同\n无返回值\n构造函数可以重载\n对象实例化的时候，编译器会自动调用对应的构造函数\n如果你自己不写构造函数，编译器会自己创建一个默认的构造函数\n\n2.1.1.1基本使用下面用一个队列来演示一下构造函数\nclass Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;//测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n可以看到，在创建对象q1的时候，编译器就自动调用了类中的构造函数，帮我们初始化了这个队列\n\n\n除了上面这种最基本的无参构造函数以外，一般写构造函数的时候，我们都会带一个有缺省值的参数，这样可以更好地灵活使用这个队列\nQueue(int Capacity=4)&#123;    _a=(int*)malloc(sizeof(int)*Capacity);    _size=0;    _capa=Capacity;&#125;\n\n调用这种构造函数也更加灵活，我们可以根据数据类型的长度，来创建不同容量的队列，避免多次realloc造成的内存碎片\nQueue q1;//调用无参的构造函数Queue q2(100);//调用带参的构造函数\n\n多种构造函数是可以同时存在的，不过！它们需要满足函数重载的基本要求\n当你调用一个无参的函数，和一个全缺省的函数的时候，编译器会懵逼！\nQueue();Queue(int Capacity=4);//这两个函数不构成重载，会报错\n\n正确的重载应该是下面的情况\nQueue();Queue(int Capacity);\n\n编译器在创建对象的时候，就会智能选择这两个构造函数其中之一进行调用。但是同一个对象只会调用一个构造函数。\n除了在构造函数内部初始化参数，我们还可以在初始化列表处进行操作\nQueue(int Capacity=4)\t:_a(new int[Capacity]),    _size(0),    _capa(Capacity)&#123; &#125;\n\n2.1.1.2编译器默认生成的构造函数上面提到过，如果我们不写构造函数，编译器会自己生成一个。\n但测试过以后，你会发现，这个默认生成的构造函数，好像啥事都没有干——或者说，它把_a _b _c 都初始化成了随机值！\n\n实际上，编译器默认生成的构造函数是不会处理内置类型的\n\n内置类型：int、char、float、double……\n外置类型：自定义类型（其他的类）\n\n在处理的时候，编译器忽略内置类型；外置类型会调用它的构造函数\nclass Date&#123;public:    //默认构造函数：不传参就能调用的    //1.全缺省 2.无参 3.编译器自动生成    //可以是半缺省的，但是不实用    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;        _A.Print();    &#125;private:    //编译器会自动生成构造函数（如果你没有自己写的话）    //自动生成的构造函数是不会初始化内置类型的    //内置类型：int,char,double等等    int _year;    int _month;    int _day;    //外置类型：自定义类型    //外置类型会调用它自己的默认构造函数    Queue _A;&#125;;\n\n可以看到，编译器调用了自己的构造函数的同时，还调用了外置类型Queue的构造函数，搞定了它的初始化\n\n如果我们去掉Date的构造函数，就能看到下面的情况。Queue成功初始化，但是内置类型的年月日都是随机值\n\n一般情况下一个C++类都需要自己写构造函数，下面这两个情况除外\n\n类里面的成员都是自定义类型成员（且有自己的构造函数）\n如果还有内置类型成员，声明时给了缺省值\n\n注：只有类在声明变量的时候才可以给缺省值\n//下面的情况就不需要写class MyStack&#123;private:      Queue q1;//自定义类型      Queue q2;      int a=1;//内置类型声明的时候给了缺省值&#125;;\n2.1.1.3初始化列表除了上面的方式之外，还有一种构造函数的使用方式为初始化列表\nDate(int year=2022,int month=2,int day=30)    :_year(year),\t_month(month),\t_day(day)&#123;&#125;\n\n\n每个成员变量只能在初始化列表中出现一次\n类中包含以下成员必须在初始化列表中进行初始化\n引用\nconst成员\n自定义类型成员\n\n\n\n一般情况下，建议使用初始化列表进行初始化。因为对于自定义类型的成员变量，初始化列表的优先级是高于&#123; &#125;里面的内容的。\n这里还有非常重要的一点！\n成员变量在类中声明的顺序就是初始化列表的顺序，而并非初始化列表自己的顺序！\n\n怎么理解呢？看下面这个代码\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(month)\t&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n即便我们把_day放在了初始化列表的首位，但由于它是在最后声明的。所以构造函数走初始化列表的时候，会依据声明顺序，依次初始化年、月、日。\n\n这会引起什么问题？再来看看一个错误示例\n\nclass Date&#123;public:Date(int year=2022,int month=2,int day=30)    :_day(day),    _year(year),\t_month(_day)&#123;&#125;private:    int _year;    int _month;    int _day;&#125;;\n\n当我们用上面这个初始化列表的时候，我们本意是想在初始化完_day以后，将_day的值赋给_month。但由于_month的声明顺序在_day之前，所以_month(_day)会先执行，此时的_day尚为随机值，这就导致月份变成随机值了！\n\n这只是一个示例，实际上肯定不会用天数初始化月数，范围不一样\n\n最好的办法，就是声明顺序和初始化列表的顺序保持一致！\n2.1.1.4 explicit关键字构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有隐式类型转换的作用。\nclass Date&#123;public:    //正常的构造函数    //Date(int year)    //    :_year(year)    //    &#123;&#125;\t    explicit Date(int year)        :_year(year)        &#123;&#125;private:    int _year;    int _month:    int _day;&#125;；void TestDate()&#123;    Date d1(2018);    // 用一个整形变量给日期类型对象赋值    // 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值    d1 = 2019;&#125;\n\n当我们调用赋值的时候，实际上编译器会先用2019构造出一个date类型对象，再调用赋值重载（这里还没有写）赋值给d1。这就是一个隐式类型转换\n如果我们用explicit修饰了这个构造函数，那么编译器将不会进行此类隐式类型转换！\n\n2.1.2 拷贝构造函数2.1.2.1特性和使用拷贝构造是一个特殊的构造函数，它的参数是另外一个Date类型。在用已有的类类型对象来创建新对象的时候，由编译器自动调用\n因为拷贝的时候我们不会修改d的内容，所以传的是const。另外，我们必须进行传引用调用！\n如下面的这个函数，在传参的时候，编译器会去调用Date的拷贝构造\nvoid func(Date d);\n\n如果你没有写拷贝构造，或者拷贝构造里面不是传引用，编译器会就递归不断创建新的对象进行值拷贝构造，程序就死循环辣\n//拷贝构造，如果不写的时候，编译器会默认生成一个    //对内置类型进行值拷贝(浅拷贝)    Date(const Date&amp; d)    &#123;        _year=d._year;        _month=d._month;        _day=d._day;        //外置类型会调用外置类型的拷贝构造        Queue b(_A);    &#125;\n\n和构造、析构不同的是，编译器自己生成的拷贝构造终于有点用了\n\n它会对内置类型进行按内存存储的字节序完成拷贝，这种称为值拷贝（又称浅拷贝）\n对外置类型会调用它的构造函数\n\n2.1.2.2深拷贝外置类型拷贝问题\n但是！如果你使用了外置类型，该类型中包含malloc的时候，编译器默认生成的构造函数就不能用辣！\n因为这时候，编译器默认生成的拷贝构造会进行值拷贝，拷贝完了之后，就会出现q1和q2指向同一个空间的情况。修改q2会影响q1，free的时候多次释放同一个空间会报错，不符合我们的拷贝构造的要求\n\n注意注意，malloc不行的原因是，数据是存在堆区里面，拷贝的时候，q2的_a得到的是一个地址，而不是拷贝了新的数据内容。\n\n如果你在类里面定义了一个int arr[10]数组，这时候拷贝构造就相当于memcpy，是可以完成拷贝的工作的\n但是malloc和new创造的空间是在堆区上的，无法直接拷贝\n\n如何解决这个问题呢？我们需要使用深拷贝\n\n了解new和delete\n从C语言转到C++，多了new和delete关键字，它们分别对应malloc和free\nint main()&#123;    int*p1=new int;//开辟一个int类型的空间    int*p2=new int(10);//开辟一个int类型的空间，并初始化为10    int*p3=new int[10];//开辟10个int类型的空间    //注意后两个的括号区别！        delete p1;//销毁p1指向的单个空间    delete p2;//同上        //delete p3;//销毁p3指向的第一个空间，不能用于数组    delete[] p3;//销毁p3指向的数组        return 0;&#125;\n\n深拷贝实现\n在上面写道过，编译器会自动生成拷贝构造函数，完成值拷贝工作。但是队列的代码里面包含堆区的空间，需要我们正确释放。这时候就需要自己写一个拷贝构造完成深拷贝\n//拷贝构造Queue(const Queue&amp; q)&#123;    _a=new int[q._capa];//注意解引用    memcpy(_a, q._a, q._capa*sizeof(int));//拷贝内容    _size=q._size;    _capa=q._capa;&#125;\n\n用下面这个队列的代码来测试深拷贝\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue Init&quot;&lt;&lt;endl;//测试是否调用        //_a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;        _a=new int[_capa];        for(int i=0;i &lt; _capa;i++)        &#123;            _a[i]=i+1;        &#125;    &#125;    //拷贝构造    Queue(const Queue&amp; q)    &#123;        cout&lt;&lt;&quot;Queue Copy&quot;&lt;&lt;endl;        _a=new int[q._capa];        memcpy(_a, q._a, q._capa*sizeof(int));        _size=q._size;        _capa=q._capa;    &#125;    void Print()    &#123;        cout&lt;&lt;&quot;this:&quot;&lt;&lt;this&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;_a:&quot;&lt;&lt;_a&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;        for(int i=0;i &lt; _capa;i++)        &#123;            cout&lt;&lt;_a[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;    ~Queue()    &#123;        //析构函数        //free(_a);        delete[] _a;        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;    &#125;private:    int* _a;    int _size;    int _capa;&#125;;int main()&#123;     Queue q1;    q1.Print();    cout&lt;&lt;endl;    Queue q2=q1;     q2.Print();    cout&lt;&lt;endl;    return 0;&#125;\n\n深拷贝效果\n先注释掉Queue的拷贝构造函数析构函数（不然会报错）\n看一看，发现在不写拷贝构造函数的时候，q2和q1的_a指向了同一个地址\n\n取消析构函数的注释，可以看到两次释放同一片空间，发生了报错\n\n如果我们把写好的深拷贝构造加上，就不会出现这个问题\n\n当你加上给_a里面初始化一些数据，以及打印_a数据的函数后，就可以看到，不仅q2的_a有了自己全新的地址，其内部的值也和q1一样了\n\n这样写出来的拷贝构造，即便把队列中的int* _a修改为char*或者其他类型，都能正确完成拷贝工作\n\n\n2.1.3 析构函数和构造函数相对应，析构函数是对象在出了生命周期后自动调用的函数，用来爆破对象里的成员（如进行free操作）\n生命周期是离这个对象最近的&#123; &#125;括号\n特性\n\n析构函数名是在类名前加~\n无参数，无返回值\n一个类只能有一个析构函数\n如果你没有自己写，编译器会自动生成一个析构函数\n\n和构造函数一样，编译器自己生成的析构函数不会处理内置类型；会调用外置类型的析构函数\n基本使用\n析构函数的定义和我们在外部写的Destroy函数一样，主要执行free（delete）操作\n#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Queue&#123;public:    Queue()    &#123;        cout&lt;&lt;&quot;Queue&quot;&lt;&lt;endl;//测试是否调用        _a=(int*)malloc(sizeof(int)*4);        _size=0;        _capa=4;    &#125;    void Print()    &#123;        cout&lt;&lt;this&lt;&lt;&quot;: &quot;;        cout&lt;&lt;&quot;size: &quot;&lt;&lt;_size&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;capa: &quot;&lt;&lt;_capa&lt;&lt;endl;    &#125;    ~Queue()    &#123;        //析构函数        free(_a);        _a=nullptr;        _size=_capa=0;        cout&lt;&lt;&quot;distory:&quot;&lt;&lt;this&lt;&lt;endl;//测试调用    &#125;private:    int* _a;    int _size;    int _capa;&#125;;\n\n假设我们在main函数里面定义了两个对象，你能说出q1和q2谁先进行析构函数的调用吗？\n\n可以看到，先调用的是q2的析构函数\n\n因为在底层操作中，编译器会给main函数开辟栈帧\n栈遵从后进先出的原则，q2是后创建的，所以在析构的时候会先析构\n\n2.2 静态成员2.2.1 静态数据成员和普通的成员变量不同，静态成员变量不属于某一个对象，而是属于整一个类\nclass A&#123;//定义一个静态成员变量\tstatic int _a  &#125;;\n\n也因为这个特性，静态成员变量是不会被sizeof计入的\n什么时候会用到静态成员变量？比如当我们需要计算一个类究竟开辟了多少个对象的时候。如果使用普通成员变量，它的值是属于某一个对象的，无法完成正确的count计数。使用静态成员变量后，该变量的值不会因为定义多个对象而被重置。这时候，我们就可以在构造函数和拷贝构造函数里面，使用count++，来实现对类开辟对象个数的统计。\nclass STU&#123;public:    STU()    &#123;        count++;        //...    &#125;    STU(const STU&amp; d)    &#123;        count++;        //...    &#125;\t//声明一个静态成员变量\tstatic int count;  &#125;;int STU::count=0;//必须要在类外定义\n\n这时候，每次对象创建都会让conunt+1，我们可以通过下面两种方式访问来得到count的值\n\n通过指定类域来访问，STU::count\n通过对象来访问，STU s1; s1.count;\n\n如果想在类外直接访问静态成员变量，就不能用private，必须是公有权限\n\n2.2.2 静态成员函数如果把静态成员变量定义为公有，那么外部的所有函数都可以通过类域或者对象来访问这个静态成员变量，这时候就不利于我们程序的封装。所以我们可以借助静态成员函数来访问私有的静态成员变量\n#include &lt;iostream&gt;using namespace std;class STU&#123;public:    STU() &#123;        count++;    &#125;    STU(const STU&amp; d)&#123;        count++;    &#125;    static int GetCount() &#123;        return count;    &#125;private:    static int count;&#125;;int STU::count=0;int main()&#123;    STU s1;        cout&lt;&lt;&quot;通过对象s1访问    &quot;&lt;&lt;s1.GetCount()&lt;&lt;endl;    cout&lt;&lt;&quot;通过类域STU::访问 &quot;&lt;&lt;STU::GetCount()&lt;&lt;endl;        return 0;&#125;\n\n静态成员函数有下面几个特点\n\n类静态成员即可用类名::静态成员或者对象.静态成员来访问\n静态成员函数没有隐藏的this指针，不能访问任何非静态成员\n静态成员和类的普通成员一样，也有public、protected、private三种访问级别\n静态成员函数可以具有返回值\n\n\n2.3 常成员2.3.1 常数据成员有一部分数据成员，是一个定值。比如我们定义了某一个学科的类class MATH\nclass MATH&#123;  int piont=6.0;//数学的学分  &#125;;\n\n可以看到，作为一个学科，它的考试学分&#x2F;绩点是固定的。这时候我们不需要在后续修改这个学分的定义，就可以将它设置为const属性，避免被其他成员误修改\nclass MATH&#123;  const int piont=6.0;//数学的学分  &#125;;\n\n和普通成员和静态成员变量不同的是\n\n常成员变量必须在声明的时候初始化\n常成员变量不能在类外定义\n常成员变量只能在构造函数的初始化列表阶段进行定义\n\nclass MATH&#123;public:    MATH()        :score(6.0)//初始化列表处定义    &#123;        cout&lt;&lt;score&lt;&lt;endl;//打印测试    &#125;private:    const double score=0;//必须在声明的时候定义初值&#125;;\n\n2.3.2 常成员函数const修饰的类成员函数称之为const成员函数，即常成员函数。const修饰类成员函数，实际修饰的是该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改。\n基本的修饰方法如下，在函数的括号后加const即可\nvoid Print()const&#123;\tcout&lt;&lt;_year&lt;&lt;endl;&#125;\n\n实际修饰的是该函数隐含的this指针\nthis指针本身是Date*const类型的，修饰后变为const Date* const类型\nvoid Print(const Date* const this)&#123;\tcout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;&#125;\n\n2.3.2.1 实例-权限问题这么说好像有点迷糊，我们用实例来演示一下为什么需要const修饰成员函数\nclass Date&#123;public:    Date(int year=2022,int month=2,int day=30)    &#123;        _year=year;        _month=month;        _day=day;    &#125;    void Print()    &#123;        cout&lt;&lt;_year&lt;&lt;&quot;-&quot;&lt;&lt;_month&lt;&lt;&quot;-&quot;&lt;&lt;_day&lt;&lt;endl;    &#125;private:    int _year;    int _month;    int _day;&#125;;\n\n假设我们需要在函数中调用Print函数，在main中是可以正常调用的\nint main()&#123;\tDate d1(2022,5,10);    d1.Print();    return 0;&#125;\n\n但当你用一个函数来进行这个操作的时候，事情就不一样了\nvoid TEST(const Date&amp; d)&#123;\td.Print();//d.Print(&amp;d) --&gt;const Date*&#125;int main()&#123;\tDate d1(2022,5,10);    d1.Print();//d1.Print(&amp;d1) --&gt;Date*    TEST(d1);        return 0;&#125;\n\n这时候我们进行了引用调用，因为在TEST中我们不会修改d1的内容，所以用const进行了修饰\n\n这时候TEST中的d.Print()函数调用，传入的是const Date*指针，指针指向的内容不能被修改\nmain中的d1.Print();函数调用，传入的是Date*指针\n\n于是就会发生权限冲突问题：\n\n这时候如果我们在函数后面加了const，就可以避免此种权限放大问题。这样不管是main函数还是TEST函数中对Print()函数的调用，就都可以正常打印了！\n总结一下：\n\nconst对象不可以调用非const成员函数（权限放大）\n非const对象可以调用const成员函数（权限缩小）\nconst成员函数内不可以调用其他非const成员函数（权限放大）\n非const成员函数可以独调用其他const成员函数（权限缩小）\n\n2.3.2.2 什么时候需要使用？众所周周知，const修饰指针有下面两种形式\n\n在*之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）\n在*之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）\n\nthis指针本身就是类型名* const类型的，它本身不能被修改。加上const之后，this指向的内容，既类里面的成员变量也不能被修改了。\n知道了这一点后，我们可以合理的判断出：只要是需要修改类中成员变量的函数，就不需要在()后面加const修饰\n如果一个函数中不需要修改成员变量，就可以加const进行修饰\n注意：如果你用了声明和定义分离的写法，那么声明和定义的函数都需要加上const修饰\n2.3.2.3 出错情况这里有一点需要提醒的是，如果你对某一个函数进行了const修饰，那么这个函数里面包含的其他类里面的函数，都需要进行const修饰。不然就会报错\n\n出现该报错的情况如下\n\n这个情况也提醒我们，不能在const修饰的函数中，调用非const修饰的成员函数\n\n2.4 常对象和常引用2.4.1 常对象可以用const来修饰一个对象，称为常对象\nconst &lt;classname&gt; s1;&lt;classname&gt; const s1;\n\n在初始化设置完常对象后，该对象的内容就不能进行修改。我们可以通过这个对象来访问内部被const修饰的函数，且只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）\n\n常对象调用非const修饰函数会报错\n不能修改常对象中成员变量的值\n\nconst STU s1(&quot;小明&quot;, 15, 90.6);\n\n如果你想在定义const对象后依旧可以修改某一个成员变量的值，可以用mutable来修饰该成员变量，这样依旧可以修改这个值\nclass STU&#123;    mutable char *m_name;//mutable修饰的成员变量，在const对象中仍然可以被修改    int m_age;    float m_score;&#125;;\n\n如上面的name变量，即便定义了const对象，也可以对它进行修改\n\n\n2.4.2 常引用2.4.2.1 引用基本形式引用的基本方式如下\nint a=10;int&amp; b=a;int&amp; c=a;//同一个变量可以有多个别名//可以用两个不同的变量名引用同一个//但是引用了之后不可以更改对象\n\n此时的b和c都是a的别名，注意是别名！\n  \n可以用两个不同的变量名引用同一个变量，而且引用了之后不可以更改对象\n\n一个变量可以有多个引用\n指针可以更改指向的对象，引用不可以\n引用必须在定义的时候就初始化，不可以int&amp; b;\n\n\n比如你叫李华，有人叫你“小李”，还有人叫你“英语作文人”，这两个外号都是你的别名。指针并不是别名，指针是通过地址访问某个变量。而引用是给a变量起另外的两个名字，实际上b和c都可以当作a来使用\n编译运行代码，让编译器打印出这三者的地址，可以看到它们的地址是一样的，因为它们本来就是同一个变量的不同名字。\n\n指针变量的地址和指针变量所指向对象的地址是不同的，引用的类型必须和引用实体的类型相同，不能用int&amp;引用double类型\n\n\n2.4.2.2 引用的权限问题const常量\n引用可以引用常量，但是必须加const修饰\n\n基本的思路就是“权限可以缩小，但不可以放大”。\n\n在上面的代码中，a是一个可以修改的变量，但是const int&amp;d=a;中的d是不能修改，只可读取a的内容。\ne是不可修改的常量，所以我们不能用int&amp;来放大权限\n\nint和double相互引用\n在1.1中有提到，我们不能用int&amp;来引用double类型的变量，编译器会报错\n\n不过我们可以用const int&amp;类型来引用double，此时引用就不是简单的一个别名了。\n先来了解一下把double复制给int类型，这时候会产生“隐式类型转换”，h保存的是z的整数部分\n\n\n在这个过程中，编译器会产生一个临时变量存放z的整数部分，然后赋值给h\n\n临时变量具有“常性”，可读不可改\n\n而当我们用const int&amp;类型来引用double时，实际上引用的是编译器产生的临时变量，它是一个常量，所以我们需要用const int&amp;来引用\nconst int&amp; i=z;//这里的i是临时变量的别名//在引用的时候，创建了一个临时变量存放d的整数部分//i的地址和z不相同，且临时变量不会销毁，生命周期和i同步//生成的这个临时变量是常量，所以i的本质是引用了一个int类型cout &lt;&lt;&quot;i= &quot;&lt;&lt;i&lt;&lt;endl;cout &lt;&lt;&quot;&amp;i= &quot;&lt;&lt; &amp;i &lt;&lt;endl; cout &lt;&lt;&quot;&amp;z= &quot;&lt;&lt; &amp;z &lt;&lt;endl;//在c++中函数主要使用引用传参，后面会进一步学习\n\n一个非常直观的验证方法，就是打印一下，瞅瞅它们的地址是否相同。可以看到，i的值和h是相同的，因为它引用的就是那个存放了整数部分的临时变量，这个临时变量的地址和z不同\n\n2.5 this指针及工作原理2.5.1 特点当你用同样的图纸建了很多个屋子后，有没有想过应该如何区分它们呢？\nC++在设计这部分的时候，添加了一个this指针来解决这个问题：C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参 数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。\n\nthis指针的类型：类名* const \n只能在“成员函数”的内部使用 \nthis指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。 \nthis指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递\n\n2.5.2 显式使用this就用下面这个函数举例\nvoid Print()&#123;\tcout&lt;&lt;_name&lt;&lt;endl;\tcout&lt;&lt;_sex &lt;&lt;endl;&#125;\n\n实际上，在调用它的时候，编译器会做如下处理。因为只有这样，才能完整的区分两个不同的类。\nvoid Print(Student*const this)&#123;\tcout&lt;&lt;this-&gt;_name&lt;&lt;endl;\tcout&lt;&lt;this-&gt;_sex &lt;&lt;endl;&#125;\n\n进一步看看下面这个代码，可以帮助你理解this指针\nbool operator==(const Date&amp; d)&#123;       return _year == d._year           &amp;&amp; _month== d._month           &amp;&amp; _day == d._day;&#125;\n\n这是一个日期的比较函数，是操作符重载（后面会讲到）。你可以看到，这个函数我们传入了一个Date类型的引用，这是区别于this的另外一个类的对象。\n如果没有this，那就很难区分两个变量的_year，于是编译器会把它优化成下面这样，就不会存在无法区分的问题了\nbool operator==(Date*const this,const Date&amp; d)&#123;       return this-&gt;_year == d._year           &amp;&amp; this-&gt;_month== d._month           &amp;&amp; this-&gt;_day == d._day;&#125;\n\n2.5.3 空指针问题在程序中，访问NULL不会报错，但是解引用Null会报错\n#include&lt;iostream&gt;using namespace std;class ta&#123;public:    void Print()    &#123;        cout&lt;&lt;&quot;print ta&quot;&lt;&lt;endl;        //cout&lt;&lt;_a&lt;&lt;endl;//err    &#125;private:    int _a;&#125;;int main()&#123;    ta* p=nullptr;    p-&gt;Print();   //可以去访问空指针的函数   //因为函数只是去调用了类里面的Print函数   //同时传了一个p的this指针（空指针传参是不会报错的）   //但是如果你去访问p里面_a变量，就会报运行错误    return 0;&#125;\n\n2.6 类间关系2.6.1  友元关系友元分为友元函数和友元类。友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。\n2.6.1.1 友元函数友元函数相当于这个类的好朋友，它并不是类的成员函数，但是可以访问这个类的私有成员。友元函数没有this指针，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部明，声明时需要加friend关键字。\nclass DATE&#123; // 友元函数friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Date&amp; d);                                      friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Date&amp; d);&#125;;\n\n以&lt;&lt;和&gt;&gt;操作符重载为例，如果我们直接在类里面定义的话，使用这个重载的方式就会变成下面这样\nDATE d1;d1&lt;&lt;cout;d1&gt;&gt;cin;\n\n因为对于双目操作符，重载的时候，编译器是将第一个参数作为操作符的左值的。在类里面定义时，第一个操作数是隐含的this指针。即必须用对象名作为左操作数来进行使用。这样虽然也能完成既定任务，但这个使用方式未免太过奇葩了。\n定义为友元后，没有隐含的this指针，就可以使用cout&lt;&lt;d1这种正常的方式来调用这个操作符重载了\n\n一个函数可以是多个类的友元函数\n友元函数不能用const修饰\n友元函数可以在类定义的任何地方声明，不受类访问限定符限制\n友元函数的调用与普通函数的调用和原理相同\n\n\n2.6.1.2 友元类友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。 \n\n友元关系是单向的，不具有交换性：比如有A类和B类，在A类中声明B类为其友元类，那么可以在B类中直接访问A类的私有成员变量，但想在A类中访问B类中私有的成员变量则不行。 \n友元关系不能传递：如果B是A的友元，C是B的友元，则不能说明C时A的友元。\n\nclass B;//前置声明class A&#123;\t//声明友元类\tfriend class B;    private:    int _n;&#125;;class B&#123;public:    //可以在类里面通过对象访问A的非公有成员\tvoid Print()    &#123;        cout&lt;&lt;_a1._n&lt;&lt;endl;    &#125;private:    A _a1;&#125;;\n\n2.6.2 整体部分关系2.6.2.1 内嵌对象内嵌对象：在一个类中定义另外一个类的对象\n在一些应用场景中，我们会需要在一个类里面定义另外一个类的对象。如下面这道OJ题中，我们需要用两个队列的类来实现这里的MyStack。\n\nclass Queue&#123;  //队列的实现 &#125;;class MyStack &#123;public:    MyStack() &#123;    &#125;   //.....private:\tQueue q1;     Queue q2;&#125;;\n\n对于内部对象Queue，需要注意的有以下几点：\n\n内部对象属于外置类型，在对象实例化的时候，编译器会去调用Queue的构造函数\n不能在MyStack类中直接对Queue进行初始化\n\n如果在Queue中定义了有参的构造函数，需要在MyStack构造函数中的初始化列表处进行初始化操作\n2.6.2.2 组合聚合问题当一个类的对象拥有另一个类的对象时，就会发生类聚合：\n\n母类A的每一个对象中都会包含一个或多个B类的对象\n类组合是一种特殊的聚合形式，其中拥有者类控制被拥有者类对象的生命周期。\n\n依旧以上面的MyStack代码为例，当我们在里面定义了Queue对象q1和q2后，它们的生命周期和MyStack类对象的生命周期同步。MyStack类会先构造，然后构造q1和q2；q1和q2分别析构后，才会析构MyStack的类对象。\n2.6.2.3 内部类当定义内部类时，内部类默认为外部类的友元，可以直接访问外部类的非公有成员。但是内部类是一个独立的类，外部类不能访问内部类的非私有成员，也不能通过外部类的对象来访问内部类的成员。\nclass A&#123;public:    class B&#123;      void Prin(const A&amp; a1)      &#123;          cout&lt;&lt; a1._a &lt;&lt;endl;//可以直接通过对象来访问私有成员          cout&lt;&lt; count&lt;&lt;endl;//外部的静态成员可以直接访问          cout&lt;&lt; _b &lt;&lt;endl;      &#125;      int _b;      &#125;;private:    int _a;    static int count;&#125;;int A::count=0;\n\n2.6.3 继承派生关系2.6.3.1 基本用法继承和派生是父与子的关系，其中子类拥有父类成员的同时，还会拥有自己的成员\n\n继承是一个特殊的语法，用于多个类有公共部分的时候\n父类：基类\n子类：派生类\n\n//举例：网站的公共部分class ART &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;网站访问量&quot; &lt;&lt; endl;\t&#125;\tvoid func()//文章页面\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; endl;\t&#125;&#125;;class LINK &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们 &quot; &lt;&lt; &quot; 网站访问量&quot; &lt;&lt;endl;\t&#125;\tvoid func()//友链页面\t&#123;\t\tcout &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n在上面的情况中，ART和LINK类中都有网站的公共部分，这时候就出现了代码的重复。继承的出现就是用于解决这个问题的\n//下面使用继承的方式来写，WEB类是网站的公共部分class WEB &#123;public:\tvoid header()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; &quot;归档&quot; &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;\tvoid footer()//所有网站页面都有这个\t&#123;\t\tcout &lt;&lt; &quot;关于我们&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;网站访问量&quot; &lt;&lt; endl;\t&#125;&#125;;//ART、LINK是两个子类，继承了WEB的公共部分//这样就减少了代码量class ART : public WEB&#123;public:\tvoid func()//文章页面\t&#123;\t\tcout &lt;&lt; &quot;文章&quot; &lt;&lt; endl;\t&#125;&#125;;class LINK : public WEB &#123;public:\tvoid func()//友链页面\t&#123;\t\tcout &lt;&lt; &quot;友链&quot; &lt;&lt; endl;\t&#125;&#125;;\n\n测试可以发现，ART和LINK作为派生类，在继承了基类WEB的成员的基础上，还拥有了它们独特的单独成员\n\n同一个类可以同时继承多个基类\nclass C : public A,public B&#123;//.....&#125;;\n\n2.6.3.2 权限问题继承有3中类型：public、private、protected。这里会显示出类中protected权限和private权限的区别\nclass A&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\n当我们分别用上面三种方式对类A进行继承的时候，得到的结果是不同的\n\n用什么继承方式，派生类中继承的成员就变成什么类型\n不管用什么继承方式，都无法访问基类中的私有成员\n\n\n2.6.3.3 同名问题当基类和派生类中出现同名成员函数或者同名成员变量时，会出现冲突。这时候编译器会做一定的处理：直接访问变量名和函数名的时候，优先访问派生类自己的成员\n//继承同名成员的处理//\t普通的同名成员class DAD1 &#123;public:\tDAD1()\t&#123;\t\t_a = 100;\t&#125;\tvoid func()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;DAD func&quot; &lt;&lt; endl;\t&#125;\tvoid func(int i)\t&#123;\t\tcout &lt;&lt; &quot;DAD func int: &quot; &lt;&lt; i &lt;&lt; endl;\t&#125;\tint _a;//基类中的该变量&#125;;class SON1 : public DAD1&#123;public:\tSON1()\t&#123;\t\t_a = 20;\t&#125;\tvoid Print()\t&#123;\t\tcout &lt;&lt;&quot;SON: &quot; &lt;&lt; _a &lt;&lt; endl;//优先访问派生类的_a\t\tcout &lt;&lt;&quot;DAD: &quot; &lt;&lt; DAD1::_a &lt;&lt; endl;//访问基类的_a\t&#125;\tvoid func()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;SON func&quot; &lt;&lt; endl;\t&#125;\tint _a;//派生类的同名变量&#125;;\n\n\n如果是静态成员，访问方法就有所变化\n//访问同名的静态成员class DAD2&#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1 &quot; &lt;&lt; endl;\t&#125;\tstatic void Test1(int n)\t&#123;\t\tcout &lt;&lt; &quot;DAD2 Test1(int)  &quot; &lt;&lt; n &lt;&lt; endl;\t&#125;&#125;;int DAD2::D_a = 100;class SON2 : public DAD2 &#123;public:\tstatic int D_a;\tstatic void Test1()\t&#123;\t\tcout &lt;&lt; &quot;SON2 Test1 &quot; &lt;&lt; endl;\t&#125;&#125;;int SON2::D_a = 200;\n\n\n2.6.3.4 虚继承有的时候，继承会出现下面这种情况：一个子类继承了两个基类，而这两个基类又同时是一个基类的派生类\n\n这时候，D里面就会有两份A的内容，相当于两份公共部分。这是我们不想看到的，因为会造成空间浪费。而且直接访问的时候，编译器会报错“对变量X的访问不明确”\n\n和前面说道的同名问题一样，我们可以指定作用域来访问特定的变量，但是这样是治标不治本的方法，并没有解决空间浪费的问题。\n//解决方法1（治表不治本）//用类域来修改和访问cout &lt;&lt; &quot;intel: &quot; &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;cout &lt;&lt; &quot;amd: &quot;   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;\n\n这就需要我们使用虚继承来操作：给B和C对A的继承加上virtural关键字\nclass CPU &#123;public:\tCPU()\t\t:_Structure(&quot;x86&quot;)\t&#123; &#125;\tchar _Structure[100];&#125;;class INTEL : virtual public CPU &#123;public:\tINTEL()\t\t:i_Brand(&quot;intel&quot;)\t&#123;&#125;\tchar i_Brand[10];&#125;;class AMD : virtual public CPU &#123;public:\tAMD()\t\t:a_Brand(&quot;amd&quot;)\t&#123;&#125;\tchar a_Brand[10];&#125;;\n\n这时候直接访问变量就不会报错了。因为这时候，B和C中的该变量指向了同一个地址，修改操作会同步。\n\n2.7 多态性\n静态多态：运算符重载\n动态多态：派生类和虚函数组成的多态\n\n2.7.1 运算符重载2.7.1.1定义在讲解赋值运算符重载之前，我们可以来认识一下完整的运算符重载：C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。\n函数名为：关键字 operator运算符，如operator=\n函数原型：返回值类型 operator操作符(参数列表)，如Date operator=();\n下面有几点注意：\n\n重载操作符必须有一个自定义类型的操作数（即操作符重载对内置类型无效）\n不能通过其他符号来创建新的操作符\n对于类类型的操作符重载，形参比操作数少一个传参（因为有一个默认的形参this指针）\n这5个操作符是不能重载的：.*、::、sizeof、? :、.\n\n2.7.1.2基本使用以下是在全局定义的操作符重载，用于判断日期是否相等\nbool operator==(const Date&amp; d1, const Date&amp; d2)&#123;    return d1._year == d2._year;    &amp;&amp; d1._month == d2._month    &amp;&amp; d1._day == d2._day;&#125;\n\n当我们在main函数中使用d1==d2的时候，编译器就会自动调用该操作符重载\n当然，你也可以自己来传参使用，如if(operator==(d1,d2))\n但是这样非常不方便，和调用一个而普通函数没啥区别，压根算不上操作符重载。所以我们一般是在类里面定义操作符重载的\n\n当我们把它放入类Date中间，就需要修改成下面这样\nbool operator==(const Date&amp; d2)&#123;    return _year == d2._year;    &amp;&amp; _month == d2._month    &amp;&amp; _day == d2._day;&#125;\n\n编译器在调用的时候，会优化成下面这样\nbool operator==(Date* this, const Date&amp; d2)//显示调用为 d1.operator==(d2);\n而在main里面使用的时候，这个重载后的操作符和原本的使用方法完全相同\nDate d1(2022,6,1)Date d2(2022,5,1)d1==d2;//自动调用操作符重载d1.operator==(d2);\n\n\n2.7.1.3赋值运算符重载因为每一个类都有不同的成员，编译器不可能智能的进行赋值操作。这时候就需要我们自己写一个赋值运算符重载来进行赋值操作了\n以日期类为例，赋值操作其实就是把内置类型成员一一赋值即可\nDate&amp; operator=(const Date&amp; d)&#123;    if(this != &amp;d)//避免自己给自己赋值    &#123;        _year=d._year;        _month=d._month;        _day=d._day;    &#125;    return *this;&#125;\n\n编写赋值重载代码的时候，需要注意下面几点：\n\n返回值和参数类型（注意要引用传参，不然会调用拷贝构造）\n检测是否自己给自己赋值（避免浪费时间）\n因为返回的是*this，出了函数后没有销毁，所以可以用传引用返回\n一个类如果没有显式定义赋值运算符重载，编译器也会自己生成一个，完成对象按字节序的值拷贝。\n\n如果类中有自定义类型，编译器会默认调用它的赋值运算符重载\n2.7.1.4拷贝构造和赋值重载的调用问题当赋值操作符和拷贝构造同时存在的时候，什么时候会调用赋值，什么时候会调用拷贝构造呢？\n\n在这两个函数中添加cout进行打印提示，可以看到：\n\n如果对象在之前已经存在，就会调用赋值重载\n如果是一个全新的变量在定义的时候初始化，就调用的是拷贝构造\n\n\n2.7.2 虚函数2.7.2.1 基本使用以及动态多态虚函数，并不代表这个函数是虚无的。而表示这个函数在一定情况下会被替换（就好比继承中的虚继承问题）。要实现动态多态，就需要借助虚函数来实现。以下面这个动物说话的代码为例\n#include &lt;iostream&gt;using namespace std;class Animal &#123;public:\t//void Talk()\tvirtual void Talk()//虚函数\t&#123;\t\tcout &lt;&lt; &quot;Animal is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class CAT : public Animal&#123;public:\tvoid Talk()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;CAT is talking&quot; &lt;&lt; endl;\t&#125;&#125;;class DOG : public Animal &#123;public:\tvoid Talk()//同名函数\t&#123;\t\tcout &lt;&lt; &quot;DOG is talking&quot; &lt;&lt; endl;\t&#125;&#125;;//基类中不使用虚函数时，该函数的内容已确定//不管传参什么类，都会调用Animal自己的Talk函数//加上虚函数virtual后，会调用CAT和DOG的Talk函数void MakeTalk(Animal&amp; it) &#123;\tit.Talk();//调用对应的Talk函数&#125;\n\n当基类Animal中的Talk函数没有用virtual修饰时，不管给这个函数传参什么类的对象，它都会调用Animal自己的Talk函数\n\n当我们用虚函数进行修饰后，就会调用派生类CAT和DOG的Talk函数，这就实现了一个简单的动态多态。\n\n对于虚函数，有几点需要注意：\n\n当基类的指针或引用指向派生类的对象时，就会触发动态多态，派生类中的同名函数会覆写基类中的虚函数\n不能定义静态虚函数——因为静态函数是属于整个类的，而不是属于某一个对象\n不能定义虚构造函数——总不能用派生类的构造来覆写基类的构造吧？\n析构函数可以是虚函数\n\n2.7.2.2 虚析构函数有的时候，我们需要析构一个对象时，往往会给基类的析构函数加上virtual修饰，这样只要传派生类的对象给基类的指针&#x2F;引用，就可以直接调用派生类对应的析构函数，完成不同的析构操作。而不是都呆呆的调用基类的析构函数——那样就会产生内存泄漏\nclass Queue &#123;public:\tQueue()\t\t:_a(new int[10])\t&#123;\t&#125;\tvirtual ~Queue() &#123;\t\tcout &lt;&lt; &quot;~Queue&quot; &lt;&lt; endl;\t\tdelete[] _a;\t&#125;private:\tint* _a;&#125;;class MyStack :public Queue &#123;public:\tMyStack(int capa)\t\t:_a1(new int[capa])\t&#123;&#125;\t~MyStack() &#123;\t\tcout &lt;&lt; &quot;~MyStack&quot; &lt;&lt; endl;\t\tdelete[] _a1;\t&#125;private:\tint* _a1;&#125;;int main()&#123;\tQueue* q1=new MyStack(4);//父类指针指向子类\tdelete q1;//调用子类的析构函数\treturn 0;&#125;\n\n2.7.3 纯虚函数在虚函数的基础上，C++定义了纯虚函数：有些时候，在基类里面定义某一个函数是没有意义的，这时候我们可以把它定义为纯虚函数，具体的实现让派生类去同名覆写。\n纯虚函数的基本形式如下\n//virtual 函数返回类型 函数名()=0;virtual void Print()=0;\n\n派生类中必须重写基类的纯虚函数，否则该类也是抽象类\nclass A &#123;public:\t//virtual void Print();//虚函数\tvirtual void Print() = 0;//纯虚函数&#125;;class B :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;B print &quot; &lt;&lt; endl;\t&#125;&#125;;class C :public A &#123;public:\tvoid Print() &#123;\t\tcout &lt;&lt; &quot;C print &quot; &lt;&lt; endl;\t&#125;&#125;;\n\n当我们在派生类中覆写了该函数后，即可实例化对象并调用该函数\n\n和虚函数一样，使用基类的引用或指针来接收派生类的对象，即可调用对应的函数\n\n2.7.4 抽象类包含纯虚函数的类就是抽象类，抽象类有下面几个特点：\n\n抽象类无法实例化对象\n抽象类的派生类必须重写基类的纯虚函数，不然派生类也是抽象类\n如果在基类中定义的纯虚函数是const修饰的，则派生类中对应的函数也需要用const修饰\n\n\n第三章  面向对象应用3.1 矩阵类设计及应用\n矩阵类要求：设计一个矩阵类，要求能够根据用户需求构建row行、column列的矩阵，并灵活接受反馈矩阵元素信息（如：某行、某列、某行某列元素）。实现矩阵的相关运算，包括矩阵加（+）、矩阵乘（*）、矩阵输出（&lt;&lt;）、矩阵赋值（&#x3D;）、获取矩阵指定位置元素值（[]）\n\n设计该程序的时候，需要注意下面几点：\n\n重载矩阵类必须使用二维数组，不能用一维数组+公式判断的方法（因为这样无法重载[]操作符）\n重载矩阵加减和相乘的运算符时候需要注意矩阵运算的规则（第一行x第一列&#x3D;第一个）\n\n\n\n对于+和-的重载不应该修改原本的矩阵，应该创建临时对象tmp后，修改tmp的值并返回\n\nint a1=1,a2=2;a1+a2;//这样相加并不会影响a1和a2的值\n\n如果需要修改原本的矩阵，应该重载的操作符是+&#x3D;和-&#x3D;\n\n对于矩阵输出&lt;&lt;的重载，必须使用友元函数，否则使用会变成对象&lt;&lt;cout，不是正常使用的方法\n对于获取矩阵指定位置元素值[]的重载，应该返回int*类型。在最开始设计的时候我错误写成了int类型，无法正确地连续使用两个[]\n\n//重载[]操作符int* operator[](int row)&#123;    return arr[row];&#125;//使用该操作符a1[1][3];//第一个[]是操作符重载a1[1];//返回了第二行的数组名//第二个[]是普通的操作符本身，访问返回的数组名找到对应列的值\n\n矩阵类完整代码实现见附录。\n3.2 银行账户管理系统设计及应用\n银行账号管理系统要求：管理不同用户在银行的金融资产，每个用户可以拥有多种银行账户（如：定期储蓄、活期储蓄、信息卡、电子账户、贷款账户等）。账户包括账号、余额、利率等基本信息，用户可以进行账户信息查询、存款、取款、结算利息等操作。银行需统计所有账户的总金额、验证银行系统收支平衡，并能够及时预警反馈。设计Account抽象类作为所有银行账户顶层祖先，根据实际应用需求合理设置派生层次及相应子类。结合银行利息结算、用户贷款申请等实际应用需求，适当添加辅助类协同操作。合理定义虚基类、虚函数、纯虚函数、抽象类完成银行账号管理系统的稳定可靠运行。\n\n3.2.1 基本思路以下是我设计该管理系统的思路：\n\n设计了Account类的主框架，作为后续类的基类\n通过多态，实现了活期储蓄、定期储蓄类、信用卡类、贷款账户的功能\n实现了简易菜单，通过switch case语句和do while语句实现多次调用不同函数接口的操作\n与日期类结合，实时计算天数差距并结算利息\n\n在设计该菜单的过程中，我发现了很多问题需要注意，这些问题也加深了我对编程知识点的理解。\n完整代码实现见附录。\n3.2.2 设计系统时遇到的问题在设计贷款账户的时候，容易出现double浮点数存放精度的问题。用户贷款额度和余额直接若直接判断相等，很难得到正确结果（因为浮点数后面会跟着很多没有打印出来的小数）\n\n这就会出现，即便你根据程序接口中“查看待还金额”来得到自己的待还金额，并执行还款操作后，还是会有一部分小数位的数据并没有完整还完，这一部分的处理是非常困难的。为了避免用户永远都还不完自己的贷款，我设置了double的修约规则，即当用户余额和贷款&#x2F;透支额度的差值小于0.2时，不再处理后续的小数位\nif (_Max - _money &lt; 0.2)//浮点数精度问题&#123;    cout &lt;&lt; &quot;无需还款&quot; &lt;&lt; endl;    return -1;&#125;\n\n同时在余额计算中进行取零修约，保证“剩余待还”打印值和“查看待还金额”函数的打印值同步。用这种方式间接解决了精度问题。\n//待还金额为透支额度+利息double money = (_Max - _money) + Income(tmp);if (money &lt; 0.02) &#123;\tmoney = 0;//修约浮点数，解决精度问题&#125;\n\n在设计销户接口时，为了避免用户在销户后仍然能操作该账户，不能只是简单的使用break跳出单层循环，而是需要用return直接终止该程序。\ncase 8:&#123;    cout &lt;&lt; &quot;销户后，账户内的一切信息都会被清空&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;请问您确认销户吗？Y/N&quot; &lt;&lt; endl;    char a;    cin &gt;&gt; a;    if (a == &#x27;Y&#x27;) &#123;        delete A;        A = nullptr;        cout &lt;&lt; &quot;销户完成&quot; &lt;&lt; endl;        return;//终止程序    &#125;    break;&#125;\n\n3.2.3 一些缺陷1.文件操作\n该银行管理类还可以添加文件操作，来保存用户的信息。原先想法是在Account类中定义static全局变量进行count++，以此得出所有派生类构造对象的总和。再利用for循环进行读取文件操作，这样就能在下一次打开程序的时候，通过用户的账户来定位用户的某一个特定账户对象，进行后续的操作。\n但是Account类作为抽象类是无法实例化对象的，如果用各个派生类来进行文件管理操作，该程序就会变得很臃肿。且由于本人能力问题，没能设计出循环读取文件内容，并进行定位下一个对象位置的操作，故在最终的设计中没有实现文件操作。\n2.时间问题\n为了代码测试需要，每一次操作都需要用户手动输入日期。在实际应用中，这项工作应该由银行用户终端自动化承担。可以设计读取预定义宏__TIME__来获取每一次操作的时间，从而实现和现实中的时间对照，去除每一次都需要手动输入代码的繁琐\n第四章  面向对象程序设计学习总结学习代码需要有一个持之以恒的心，再学习知识点的基础上要同时坚持写代码的练习。我在Gitee码云上创建了自己的学习仓库，坚持每天托管代码，作为自己学习编程打卡的一个记录\n\n和其他科目不同，CPP的学习是不能只停留在书籍和纸笔上的，只有你上手自己敲代码了，才能认识到一些光是听讲和看书学习不到的知识。比如一些程序出现bug之后的VS调试技巧，都是我在练习中学会的。\n\n同时还需要学会利用工具，如在cplusplus网站上查找函数的定义，根据给出的代码示例尝试自己使用这个函数，并做到能在后面的程序设计中活学活用。\n个人认为，不管学习的编程语言是什么，只有综合以上几点，才能真正学好编程。\n附录\n矩阵类和银行管理系统完整代码👉【传送门】\n部分资料参考C语言中文网👉http://c.biancheng.net/\n\n","categories":["遇见C++"],"tags":["Linux","C++","类和对象"]},{"title":"【C++】模板：了解泛型编程","url":"/2022/06/27/code/note_cpp/9%E6%A8%A1%E6%9D%BF/","content":"本篇是C++模板学习的一些笔记\n\n\n[TOC]\n1.了解泛型编程泛型编程，故如其名，是一个泛化的编程方式。其实现原理为程序员编写一个函数&#x2F;类的代码示例，让编译器去填补出不同的函数实现\n就好比活字印刷术，可以灵活调整印刷的板块和内容，比只能固定印刷某一个内容的雕版印刷术效率更高，也让印刷术由此得到了更广泛的应用。\n\n在C++中，函数重载和模板的出现，让泛型编程得到了实际的应用。其中模板，就是类似活字印刷术一样的存在。\n2.函数模板八八了那么多没用的，让我们来看看函数模板的语法实现吧\n2.1简单示例下面是一个最简单的交换函数的例子，通过标明模板参数T，让编译器自动识别函数传参，并调用出不同的函数\ntemplate&lt;typename T&gt;void Swap(T&amp; left,T&amp; right)&#123;    T temp = left;    left = right;    right = temp;&#125;\n\n其中，typename是定义模板的关键字，我们可以使用class来替代，但不能使用struct\n\n可以看到，编译器成功调用了Swap函数，交换了int类型和double类型\n2.2多个模板参数如果我们尝试把int和double同时传参给这个函数，会发生什么呢？\n\n编译器会报错，表示模板参数T不明确\n这时候我们有几种解决方法\n\n首先是将double强转为int（反过来亦可）\n\n\n你会发现还是不行，那是因为强转并不支持用double引用int。所以我们把函数传参中的引用去掉，即可正常调用这个函数（暂且不提传引用和传值的区别）\n\n\n使用多个模板参数\n\n和函数传参类似，我们也可以设置多个模板参数\n在下图中，我使用typeid关键字来打印模板参数T1和T2的类型。\n\n使用typeid需要包含头文件#include &lt;typeinfo&gt;\n\n\n可以看到，实际上函数在调用这个模板的时候，已经实例化了这个函数（即替换模板参数为正确参数类型）这时候在后台处理的时候，其实Show函数已经实例化为了下面这个样子\nvoid Show(int left, double right)&#123;    cout &lt;&lt; typeid(left).name() &lt;&lt; endl;    cout &lt;&lt; typeid(right).name() &lt;&lt; endl;&#125;\n\n2.3模板实例化上面的方式，是编译器自动帮我们实例化模板参数。在实际使用中，我们还可以自己指定实例化为什么类型\n\n利用强制类型转换\n使用&lt;int&gt;直接指定实例化为int类型\n\n\n使用第二种方式的时候，编译器会对另外一个不匹配的参数进行隐式类型转换。如果转换不成功，则会报错。\n另外注意的是，函数模板参数T同样可以用来作为返回值，但是不能通过返回值来推断参数T的类型。比如下面这个函数，我们在使用的时候就需要直接指定模板参数T，而不能写一个int* ptr=test(10)让编译器通过“返回值是int*接收的，所以函数模板参数T是int”来推断。\ntemplate&lt;typename T&gt;T* test(int num)&#123;\treturn new T[num];&#125;\n\n\n函数模板支持给予参数缺省值\n\n当一个参数不确定的时候，函数模板是支持给予缺省值的\ntemplate&lt;typename T=char&gt;T* test(int num)&#123;\treturn new T[num];&#125;\n\n比如这样，当我们没有直接指定的时候，编译器就会将T作为char类型，返回一个num大小的char（一个字节）的空间\n注意：当有多个模板参数时，缺省值需要从右往左给\n\n函数模板的传参也支持缺省值\n\ntemplate&lt;typename T1&gt;void Add(T1 left, T1 right=10)&#123;    cout &lt;&lt; &quot;Add temp &quot;&lt;&lt;typeid(left).name() &lt;&lt; &quot; &quot; &lt;&lt; typeid(right).name() &lt;&lt; endl;    cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;&#125;int main()&#123;    int a=1;    Add(a);&#125;\n\n在这种情况下，编译器会正确调用该函数模板\n\n2.4模板和普通函数同时存在以Add函数为例，在函数模板存在的同时，我们还可以单独写一个int类型的add函数。这都归功于函数重载的存在。\n同时，我们还可以使用&lt;int&gt;来指定函数模板重载为已存在的Add函数。因为本质上这两个函数是不同的，并不会冲突。\n\n函数在调用的时候，首先会去调用已经存在的函数。当参数和已存在的函数不匹配时，才会调用函数模板\n2.5函数模板不支持定义和声明分离一般情况下，我们都会在头文件中生命函数，在另外一个源文件中定义函数。\n但是模板是不支持这么做的！编译器会报错 链接错误\nerror LNK2019:无法解析的外部符号……\n\n所以我们需要将函数模板的声明和定义放在一个头文件中。在部分使用场景，会使用.hpp来表示这个头文件是包含了函数定义的（即.h和.cpp的集合体）。需要注意，这并不是一个硬性要求，你也可以直接使用.h，并将声明和定义放入其中。\n\n这是为什么呢？\n\n因为单独的.h声明会在源文件顶部展开，而此时函数模板正常推演参数，但编译器并没有找到函数的实现，即这是一个没有地址的函数。从而导致编译器找不到函数的地址，产生了符号表的链接错误\n\n有无解决办法？\n\n其实是有的，我们可以在模板函数定义的.cpp中对我们需要使用的函数进行显式实例化指定\n //头文件//声明template&lt;typename T1&gt;void Add(T1 left, T1 right);//源文件//定义template&lt;typename T1&gt;void Add(T1 left, T1 right)&#123;    cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;&#125;//在源文件中显式实例化templatevoid Add&lt;int&gt;(int left, int right);templatevoid Add&lt;double&gt;(double left, double right);\n\n显式实例化需要对我们要用的所有函数进行实例化，比如你需要用double类型，只显示实例化了int类型是不行的，依旧会报错。\n这样感觉非常多余……对吧！所以还是老老实实把声明和定义放在同一个文件里面吧！\n3.类模板类模板的基本形式如下，这里作为一个小区分，我用class来当作模板参数名。实际上typename也是可以的\ntemplate&lt;class T1, class T2, ...&gt;class 类模板名&#123;// 类内成员定义&#125;;     \n\n3.1简单示例下面用一个非常简单的顺序表代码来演示一下类模板\ntemplate&lt;class T&gt;class List&#123;public:    List(int capacity = 10)        : _a(new T[capacity])        , _size(0)        , _capa(capacity)    &#123;&#125;     ~List();    T&amp; operator[](int pos)    &#123;        assert(pos &lt; _size);        return _a[pos];    &#125;private:    T* _a;    int _size;    int _capa;&#125;;//类模板中函数放在类外进行定义时，需要加模板参数列表template &lt;class T&gt;List&lt;T&gt;::~List()&#123;    delete[] _a;    _size = _capa = 0;&#125;\n\n可以看到，通过显式实例化的方式，我们成功让这个类模板变成了两个不同类型的顺序表\n\n3.2成员函数声明和定义分离其中需要注意的是析构函数，声明和定义分离的时候（同一文件），在定义的时候也需要加上模板参数\n//类模板中函数放在类外进行定义时，需要加模板参数列表template &lt;class T&gt;List&lt;T&gt;::~List()&#123;    delete[] _a;    _size = _capa = 0;&#125;\n\n个人觉得这样也非常麻烦，既然模板最好是声明和定义放在同一个文件，那还不如直接将类的成员函数直接定义到类内部。多省事！\n\n如果是声明和定义放在不同文件中，显式实例化方式如下\n\ntemplateclass List &lt;int&gt;;templateclass List &lt;double&gt;;\n\n需要什么类型的类，就得实例化这个类型。\n4.等待添加……模板还有更多值得学习的内容，待我先捣鼓一下，再回来更新这篇博客\n","categories":["遇见C++"],"tags":["C++"]},{"title":"【C语言】数据结构-链式二叉树，详解分治递归和层序遍历","url":"/2022/04/16/code/note_data_structure/10%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"[TOC]\n前言在之前关于树的学习中，我们接触了二叉树的知识点，以及堆和堆排序的操作。\n\n两个知识点都是超链接，可以点击查看我之前的博客，复习一下这两个知识点哦！\n\n\n接下来我们要更进一步，学习一下链式二叉树的操作\n本篇博客将以知识点讲解+OJ题目验证的方式来展开链式二叉树的内容\n\n1.链式二叉树的基本结构在学习链式二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。\n之前我们提到过，树最优的表示方法是父母孩子表示法。但是对于二叉树这种度固定的树来说，可以 直接使用最简单的方法，定义两个指针指向它的左右叶子节点即可\ntypedef int BTDataType;typedef struct BTreeNode&#123;\tBTDataType data;\tstruct BTreeNode* left;\tstruct BTreeNode* right;&#125;BTNode;\n\n这里要说明的一件事是：普通树的“增删查改”操作是没有意义的，因为树并不是一个最优的储存结构。所以我们学习链式二叉树的操作时，更多学习的是分治 递归思想\n\n2.分治递归思想什么是分治思想？\n举个例子，学校里面需要进行排查，找出本校里面身高最高的人。这时候校长可以去找各个年级的级组长，然后级组长去找各个班主任，班主任让班级里面的小组长统计组员身高数据。\n这时候的小组长已经可以返回一个身高最高的值给班主任了，然后再层层上报，校长只需要在最后上报的4个数据中找出一个最高的，即为本校最高的同学\n\n分治策略的思想就是分而治之，即先将一个规模较大的大问题分解成若干个规模较小的小问题，再对这些小问题进行解决，得到的解，在将其组合起来得到最终的解。在上面的例子中，较小的问题就是小组长统计组员身高，并上报。转换成代码语言就是return一个值\n\n更详细的解释可以参考这篇大佬的博客👇\n五大常见算法策略之——递归与分治策略\n\n早先学习的递归求斐波那契数就运用了分治的思想👉传送门\nint fo2(int a)&#123;\tif ((a == 1) || (a == 2))\t\treturn 1;\telse\t\treturn (fo2(a - 1) )+( fo2(a- 2));//n-1和n-2项&#125;\n\n当a&#x3D;1或者2的时候，就是分治的末端节点，通过return 1开始终止递归\n\n3.前&#x2F;中&#x2F;后序遍历了解了上面所说的分治递归思想后，接下来我们再学习链式二叉树的三种遍历方式\n\n前序遍历：根节点-左子树-右子树\n中序遍历：左子树-根节点-右子树\n后序遍历：左子树-右子树-根节点\n\n从前序遍历入手，我们来实操一下分治的思想：利用递归，以前序遍历的顺序打印出树中节点的值\n假设我们现在创建了一个这样的简单二叉树👇你能想出来前序遍历的打印顺序应该是咋样的吗？\n\n答案是1 2 3 4 5 6\n看到这里，你肯定一脸懵逼：啊，咋出来的？\n\n不着急，我们现给打印出来的内容加上它们的末端子树NULL，所以前序遍历的结果是：\n1 2 3 NULL NULL NULL 4 5 NULL NULL 6 NULL NULL\n\n不卖关子啦，直接下手分析这个遍历结果是怎么出来的！\n前面提到了，前序遍历的顺序是：根节点-左子树-右子树\n\n下图能让你更直观地看出来这三种遍历方式的不同\n\n其中前序遍历转换为代码语言就是下面这样\n// 二叉树前序遍历 void BTreePrevOrder(BTNode* root)&#123;\tif (root == NULL)\t&#123;//为了方便理解，把空节点也打印出来\t\tprintf(&quot;NULL &quot;);\t\treturn ;\t&#125;\tprintf(&quot;%d &quot;, root-&gt;data);\tBTreePrevOrder(root-&gt;left);\tBTreePrevOrder(root-&gt;right);&#125;\n\n在这之中，遇到根节点是NULL的情况，就是分治的末端情况，递归停止\n这样说来恐怕还是不清楚，要彻底弄清，我们必须要通过画递归示意图来解决\n\n图中某个单词打错了，画到一半才发现……请忽略它！😭\n\n如果你能理解上图中前序遍历的思路，那中序遍历和后序遍历的操作就非常简单了！猜猜怎么修改前序的代码呢？\n没错，只需要更改一下printf的位置就可以了！\n// 二叉树中序遍历void BTreeInOrder(BTNode* root)&#123;\tif (root == NULL)&#123;\t\tprintf(&quot;NULL &quot;);\t\treturn;\t&#125;\t\tBTreeInOrder(root-&gt;left);\tprintf(&quot;%d &quot;, root-&gt;data);\tBTreeInOrder(root-&gt;right);&#125;// 二叉树后序遍历void BTreePostOrder(BTNode* root)&#123;\tif (root == NULL)&#123;\t\tprintf(&quot;NULL &quot;);\t\treturn;\t&#125;\tBTreePostOrder(root-&gt;left);\tBTreePostOrder(root-&gt;right);\tprintf(&quot;%d &quot;, root-&gt;data);&#125;\n\n最后打印出来的结果分别是这样的，和上面的示意图完全对应！回到示意图\n\n\n3.1通过递归遍历计算节点个数上面的递归，我们打印出了各个节点的值\n只需要对其中一个递归的代码进行小修改，将printf改成计数++，就能把它从遍历变成计算二叉树的节点个数\n这里我选择指针变量的方式让主函数中能获取计数的结果\n// 二叉树节点个数void BTreeSize(BTNode* root,int* pcount)&#123;\tif (root == NULL)\t\treturn ;\t\t(*pcount)++;//指针变量，main函数中可调用\tBTreeSize(root-&gt;left,pcount);\tBTreeSize(root-&gt;right,pcount);&#125;\n\n\n你可以使用全局静态变量来进行计数，但是那样的计数会在下一次调用的时候叠加，需要在调用后置0，非常不方便\n\n\n当然，我贴出来的这个方法也不是最优的，因为它需要创建一个额外的变量count作为参数调用，而不能直接return节点的数量\n\n所以就有了下面这个使用三目操作符? :来进行分治递归，计算节点个数\n\n其中根节点为空是末端情况，返回0\n其他情况返回左子树和右子树的节点大小+1（该节点自己）\n\n//进阶方法int BTreeSize(BTNode* root) &#123;\treturn root == NULL ? 0 :\t\tBTreeSize(root-&gt;left)\t\t+ BTreeSize(root-&gt;right) + 1;&#125;\n\n3.2 用后续遍历的思想销毁树当我们不需要用二叉树后，需要将其调用的内存释放\n问题就来了，如果你释放了根节点，那要咋找到它的左右子树呢？\n所以我们在释放的时候，要用后序遍历的顺序来进行释放，即先销毁左右子树，再向上销毁。这样就能避免找不到子树的问题\n// 二叉树销毁void BTreeDestory(BTNode** root)&#123;\tif (*root == NULL)\t\treturn;\t//通过后续遍历的思想来摧毁树\tBTreeDestory(&amp;(*root)-&gt;left);\tBTreeDestory(&amp;(*root)-&gt;right);\tfree(*root);\t*root = NULL;//使用二级指针可以直接在函数中置空根节点的指针&#125;\n\n3.3前&#x2F;中&#x2F;后序遍历OJ题\n三道Leetcode OJ题\n\n144. 二叉树的前序遍历\n145. 二叉树的后序遍历\n94. 二叉树的中序遍历\n\n\n这里只对前序遍历的题目做出讲解，因为后面两个的思路完全一致，只需稍微更改代码\n\n题目给出一个树，需要你将它以前序遍历的顺序，将各个节点的值保存在一个数组中并返回它\n\n这里的输入用例是“伪代码”，[1,null,2,3]代表1的左子树是NULL，右子树是2；2的左子树是3，右子树是NULL\n\n既然需要用数组来储存，首先我们需要知道这个二叉树一共有几个节点，这样才能方便我们开辟数组\n\n注意：这种接口型题目，数组都必须是动态内存函数malloc开辟的\n\n\n然后把前序遍历中的printf改成将值放入arr数组中即可！\n// 二叉树节点个数void BTreeSize(struct TreeNode* root,int* pcount)&#123;\tif (root == NULL)\t\treturn ;\t\t(*pcount)++;\tBTreeSize(root-&gt;left,pcount);\tBTreeSize(root-&gt;right,pcount);&#125;// 前序遍历代码void BTreePrevOrder(struct TreeNode* root,int*arr,int* i)&#123;\tif (root == NULL)&#123;\t\treturn ;\t&#125;\t    arr[(*i)++]=root-&gt;val;    //因为在递归调用中需要多次调用不同的i，所以需要取地址\tBTreePrevOrder(root-&gt;left,arr,i);\tBTreePrevOrder(root-&gt;right,arr,i);&#125;int* preorderTraversal(struct TreeNode* root, int* returnSize)&#123;    int count=0;    BTreeSize(root,&amp;count);//计算树节点个数    int* arr=(int*)malloc(sizeof(int)*count);//开辟数组    int i=0;//下标    BTreePrevOrder(root,arr,&amp;i);    *returnSize=count;    return arr;&#125;\n\n\n\n4.计算节点个数在3.1中已经讲述了计算二叉树节点个数的方法，下面是更细致的节点个数计算\n4.1叶子节点个数众所周知，在这颗二叉树中，只有3、5和6是叶子节点\n\n想要判断一个节点是不是叶子节点，其实非常简单：只要它的左右子树都是空，就是叶子节点了。\n\n以此作为分治的末端条件，只要满足这个条件，就返回1\n如果已经遍历到空节点了，返回0\n其他情况，返回左子树和右子树的叶子节点个数之和\n\n// 二叉树叶子节点个数int BTreeLeafSize(BTNode* root)&#123;\tif (root == NULL)\t\treturn 0;\tif (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\t\treturn 1;\treturn BTreeLeafSize(root-&gt;left) + BTreeLeafSize(root-&gt;right);&#125;\n\n4.2二叉树第k层节点个数假设根节点是第1层，要想知道第k层一共有几个节点，需要怎么设计函数呢？\n\n先来这么想：3所在层数对于根来说是第三层，但是对于2来说是第二层，对于3自己来说是第1层\n那么，我们是不是可以让第k层往下-1来进行递归呢？\n\n// 二叉树第k层节点个数int BTreeLevelKSize(BTNode* root, int k)&#123;\tassert(k &gt;= 1);//保证k&gt;=1\tif (root == NULL)\t\treturn 0;\tif (k == 1)\t\treturn 1;\treturn BTreeLevelKSize(root-&gt;left,k - 1)        + BTreeLevelKSize(root-&gt;right,k-1);&#125;\n\n\n\n4.3二叉树的深度在之前树的概念学习中，讲解过树的深度（即树一共有几层）\n深度和之前举例的校长统计身高很相似，我们需要找出左右子树中较深的那一个并进行返回。末端的条件，就是节点为空的时候，return 0终止递归 \n// 二叉树深度，即一共有几层int BTreeDepth(BTNode* root)&#123;\tif (root == NULL)\t\treturn 0;\tint left = BTreeDepth(root-&gt;left);\tint right = BTreeDepth(root-&gt;right);\treturn left &gt; right ? left + 1 : right + 1;&#125;\n\n注意：这里left+1和right+1是为了计算上节点自己\n求二叉树深度OJ题leetcode上有一道oj题就是求二叉树的最大深度，代码复制上，改个名，搞定！\n\n题目链接：104. 二叉树的最大深度\n\n\n\n5.查找树中值为x的节点在二叉树中查找一个值，基本思想就是把它遍历一遍，判断根节点以及左右子树中是否有x值的节点。\n具体的解析，写道下面的代码注释里啦！\n// 二叉树查找值为x的节点BTNode* BTreeFind(BTNode* root, BTDataType x)&#123;\tif (root == NULL)\t\treturn NULL;//节点为空返回空\tif (root-&gt;data == x)\t\treturn root;//节点自己就是x，返回节点自己的地址\tBTNode* ret1 = BTreeFind(root-&gt;left, x);\tif (ret1 != NULL)//如果左边找到了，返回左节点的地址\t\treturn ret1;\tBTNode* ret2 = BTreeFind(root-&gt;right, x);\tif (ret2 != NULL)//如果右边找到了，返回右节点的地址\t\treturn ret2;\treturn NULL;//两个都找不到，它自己也不是，返回空&#125;\n\n6.层序遍历如同其名，层序遍历就是一层一层地遍历\n\n比如上面这棵树，层序遍历的结果如下\n1 2 4 3 NULL 5 6\n\n要想实现层序遍历，我们需要借助之前学习的栈和队列知识里的队列👉传送门\n在VS项目里面，导入预先写好的队列的头文件和源文件，再引用它就可以了！\n\n这里就能体现出之前预先typedef类型的作用了：只需要更改最先的数据类型，就可以搞定后面的一切！\n\n而引用头文件的时候，因为我们需要在栈的代码中使用二叉树的定义，所以需要先引用二叉树的头文件，再引用队列的头文件\n\n搞定这个后，我们再来讲述一下层序遍历的思路\n\n先插入根节点，然后在根节点出队列的同时，插入它的左右子树的节点\n当队列中的值都为NULL时，代表层序遍历完成\n\n\n所以我们需要入队列的不是节点的值，因为那样无法找到节点的左右子树。入队列的是节点的地址！\n// 层序遍历void BTreeLevelOrder(BTNode* root)&#123;\tQueue q;\tQueueInit(&amp;q);\tif (root != NULL)&#123;//根节点非空，开始入队列\t\tQueuePush(&amp;q, root);\t&#125;\twhile (!QueueEmpty(&amp;q))\t&#123;\t\tBTNode* head = QueueFront(&amp;q);//取队头数据\t\tQueuePop(&amp;q);//出队列\t\tprintf(&quot;%d &quot;, head-&gt;data);\t\tif (head-&gt;left != NULL)\t\t&#123;\t\t\tQueuePush(&amp;q, head-&gt;left);\t\t&#125;\t\tif (head-&gt;right != NULL)\t\t&#123;\t\t\tQueuePush(&amp;q, head-&gt;right);\t\t&#125;\t\t//层序遍历不需要递归，可以用循环解决问题\t&#125;\tprintf(&quot;\\n&quot;);\tQueueDestory(&amp;q);//防止内存泄漏\treturn;&#125;\n\n遍历的结果如下\n\n6.1判断二叉树是否为完全二叉树学习了层序遍历后，就可以来判断一个二叉树是否为完全二叉树了！\n完全二叉树：前k-1层为满二叉树，最后一层不满，但是从左到右分布\n\n具体的思路是\n\n当队列中的队头为NULL时开始遍历，如果队列中都是NULL，代表是满二叉树\n如果有非空节点，就不是满二叉树\n\n// 判断二叉树是否是完全二叉树bool BTreeComplete(BTNode* root)&#123;\tQueue q;\tQueueInit(&amp;q);\tif (root != NULL) &#123;\t\tQueuePush(&amp;q, root);\t&#125;\twhile (!QueueEmpty(&amp;q))\t&#123;\t\tBTNode* head = QueueFront(&amp;q);//取队头数据\t\tQueuePop(&amp;q);//出队列\t\tif (head == NULL)&#123;\t\t\tbreak;//遇到队列中空节点，退出循环\t\t&#125;\t\tQueuePush(&amp;q, head-&gt;left);\t\tQueuePush(&amp;q, head-&gt;right);\t&#125;\twhile (!QueueEmpty(&amp;q))\t&#123;\t\tBTNode* head = QueueFront(&amp;q);//取队头数据\t\tQueuePop(&amp;q);//出队列\t\tif (head != NULL)\t\t&#123;\t\t\t//printf(&quot;不是完全二叉树\\n&quot;);\t\t\treturn false;\t\t&#125;\t&#125;\tQueueDestory(&amp;q);//防止内存泄漏\treturn true;&#125;\n\n结语链式二叉树的内容到这里就结束啦！\n如果博客里面有讲的不清楚的地方，欢迎大家在评论区提出哦！\n\n下篇博客将讲解一些有关二叉树的OJ题和概念选择题！我们不见不散哦~\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","树","链表"]},{"title":"【C语言】带你用偷懒的方式刷爆二叉树OJ题","url":"/2022/04/20/code/note_data_structure/11%E4%BA%8C%E5%8F%89%E6%A0%91OJ%E9%A2%98%E5%92%8C%E9%80%89%E6%8B%A9%E9%A2%98/","content":"[TOC]\n前言上篇博客我带大家领略了一番链式二叉树的操作，现在让我们来看看二叉树的相关题目，一起来巩固一下知识点吧！\n\n\n点我复习上一篇博客的内容！👉传送门\n\n1.一些选择题1.1设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（ ）个A.11B.12C.13  √D.14\n\n\n设Ni表示度为i的节点个数，则节点总数 N &#x3D; N0 + N1 + N2\n节点个数于节点边的关系： N个节点的树有N-1个边\n边与度的关系：N - 1 &#x3D; N1 + 2 * N2\n故：N0 + N1 + N2 - 1 &#x3D; N1 + 2 * N2\n因此，得：N0 &#x3D; N2 + 1\n回到原题，N0 &#x3D; 3，N1 &#x3D; 8，可得N2 &#x3D; 2\n因此答案是 3 + 8 + 2 &#x3D; 13\n\n1.2有N个元素的完全二叉树的深度是()答案：logN+1\n\n高度为h的完全二叉树，节点个数在： 2^(h - 1) - 1 &lt; n &lt;= 2^h - 1\n即log(n + 1) &lt;= h &lt; log(n + 1) + 1\n这里需要注意的是n左右区间的开闭问题\n完全二叉树最少的节点个数是2^(h - 1)-1+1个，所以是n&gt;2^(h - 1) - 1\n\n1.3 由已知遍历序列画出原本树的结构已知某二叉树的中序遍历序列为JGDHKBAELIMCF，后序遍历序列为JGKHDBLMIEFCA，则其前序遍历序列为（ ）A.ABDGHJKCEFILMB.ABDGJHKCEILMF   √C.ABDHKGJCEILMFD.ABDGJHKCEIMLF\n\n这道题我刚开始的思路是错的，因为我把它当作完全二叉树来看待，但题目并没有说它是完全二叉树\n\n主要思路：可以从后续遍历确定根节点为A，中序遍历可以确定A的左右子树。再继续从后序遍历中确定A左右子树的根节点，依次往下判断\n\n所以我画了一个分析图，如下👇\n\n已知某二叉树的前序遍历序列为ABDEC，中序遍历序列为BDEAC，则该二叉树（ ）A.是满二叉树B.是完全二叉树，不是满二叉树C.不是完全二叉树   √D.是所有的结点都没有右子树的二叉树\n\n这道题的思路和上一道题是一样的\n\n已知某二叉树的前序遍历序列为5 7 4 9 6 2 1，中序遍历序列为4 7 5 6 9 1 2，则其后序遍历序列为（ ）A.4 2 5 7 6 9 1B.4 2 7 5 6 9 1C.4 7 6 1 2 9 5  √D.4 7 2 9 5 6 1\n\n本题依旧和上面两道题思路相同！\n\n1.4 单边树一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（ ）A.所有的结点均无左孩子B.所有的结点均无右孩子C.只有一个叶子结点D.至多只有一个结点\n\n如果前序遍历和后序遍历序列正好相反，说明它是一个单边树，比如下面这前序和中序序列所构成的树的结构:\n12345（纵向）\n54321\n对于单边树，只有一个叶子节点\n\n1.520.如果一颗二叉树的前序遍历的结果是ABCD，则满足条件的不同的二叉树有（ ）种A.13B.14 √C.15D.16\n\n\n首先这棵二叉树的高度一定在3~4层之间:\n三层：\nA(B(C,D),()), A((),B(C,D)), A(B(C,()),D), A(B((),C),D),\nA(B,C(D,())), A(B,C((),D))\n四层：\n如果为四层，就是单边树，每一层只有一个节点，除过根节点，其他节点都有两种选择，在上层节点的左边还是右边，所以222共8种\n总共为14种。\n\n\n2.OJ题刷起来！KY11 二叉树遍历\n牛客网 KY11 二叉树遍历 👉传送门\n\n\n这道题要求我们用先序遍历的操作从一个数组中读出一个树，并构建出树的基本结构，再用中序遍历的方式打印出这颗树\n之前我们学习了前序遍历的操作，这里只需要把前序遍历中的printf操作改成构建新树即可\n\n因为涉及道i的多次调用，所以函数中的i需要取地址，必须保证多次调用的i会同步++\n构建完树的节点，并赋值后，需要递归构建左右子树，最后返回节点的地址\n题目中的#代表NULL，直接return空即可\n\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;typedef char BTDataType;typedef struct BTreeNode&#123;\tBTDataType data;\tstruct BTreeNode* left;\tstruct BTreeNode* right;&#125;BTNode;// 二叉树中序遍历 void BTreeInOrder(BTNode* root)&#123;\tif (root == NULL)&#123;\t\treturn ;\t&#125;\t\tBTreeInOrder(root-&gt;left);    printf(&quot;%c &quot;, root-&gt;data);\tBTreeInOrder(root-&gt;right);&#125;BTNode* CreatTree(char *arr,int*i)&#123;    if (arr[*i] == &#x27;#&#x27;)&#123;        (*i)++;\t\treturn NULL;\t&#125;        BTNode* newnode=(BTNode*)malloc(sizeof(BTNode));        newnode-&gt;data=arr[(*i)++];//i必须取地址    newnode-&gt;left=CreatTree(arr,i);//递归构建左子树    newnode-&gt;right=CreatTree(arr,i);//递归构建右子树        return newnode;&#125;int main()&#123;    char arr[100];    scanf(&quot;%s&quot;,arr);        int i=0;    BTNode* root=CreatTree(arr,&amp;i);    BTreeInOrder(root);    return 0;&#125;\n\n100 相同的树\nleetcode：100. 相同的树\n\n\n题目要求很简单，给定两颗树的根节点，要求我们判断这两棵树是否相同\n\n如果两棵树都为空，树相同\n如果其中一个为空，另外一个不为空，树不同\n如果两个都不为空，但是节点值不相同，树不同\n然后再递归判断左子树和右子树，将它们的结果与&amp;&amp;在一起，其中一个为假，返回假\n\nbool isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;    if(p==NULL&amp;&amp;q==NULL)//比较是否两个节点都为空，都为空是真        return true;        if(p==NULL||q==NULL)//如果有一个为空，另外一个非空，即为假        return false;    if(p-&gt;val!=q-&gt;val)//都不是空，判断val的值是否相等        return false;        //递归判断左子树和右子树是否相等    return isSameTree(p-&gt;left,q-&gt;left)        &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);&#125;\n\n\n学会这道题后，后面一些题目其实只需要把它的代码改一改就能用了😂\n什么？你不信？那就看看下面这道题！\n\n101 对称二叉树\nleetcode：101. 对称二叉树\n\n\n题目要求很简单哈，判断是不是两边对称的树\n这和判断树相等有什么区别呢？不就是把左右子树的判断改一下就行了嘛？\n直接调用上一题的代码！注意最后的return值，是p的左和q的右进行判断\nbool _isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;    if(p==NULL&amp;&amp;q==NULL)//比较是否两个节点都为空，都为空是真        return true;        if(p==NULL||q==NULL)//如果有一个为空，另外一个非空，即为假        return false;    if(p-&gt;val!=q-&gt;val)//都不是空，判断val的值是否相等        return false;        //递归判断左子树和右子树是否对称相等    return _isSameTree(p-&gt;left,q-&gt;right)        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;left);&#125;bool isSymmetric(struct TreeNode* root)&#123;    return _isSameTree(root-&gt;left,root-&gt;right);&#125;\n\n\n哈哈，是不是很爽，别急，后面还有可以偷懒的题目！\n\n572 另外一棵树的子树\nleetcode：572. 另一棵树的子树\n\n\n这道题我们要判断一颗树是否为另外一棵树的子树，和判断一个字符串是不是另外一个字符串的子串很相似\n其实只需要递归判断每一个节点的左右子树是否和subRoot相同就可以了！\nbool _isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;    if(p==NULL&amp;&amp;q==NULL)//比较是否两个节点都为空，都为空是真        return true;        if(p==NULL||q==NULL)//如果有一个为空，另外一个非空，即为假        return false;    if(p-&gt;val!=q-&gt;val)//都不是空，判断val的值是否相等        return false;        //递归判断左子树和右子树是否相等    return _isSameTree(p-&gt;left,q-&gt;left)        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;right);&#125;bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot)&#123;    // if(root==NULL&amp;&amp;subRoot==NULL)    //     return true;    // if(root!=NULL&amp;&amp;subRoot==NULL)    //     return true;    // 让isSametree函数来比较这俩个    if(root==NULL)        return false;    if(_isSameTree(root,subRoot))        return true;    //只要左右有一个是返回真，那就是子树    return isSubtree(root-&gt;left,subRoot)        || isSubtree(root-&gt;right,subRoot);&#125;\n\n\n是不是爽起来了？再来一道！\n\n\n226 翻转二叉树\nleetcode：226. 翻转二叉树\n\n\n这道题的思路如下哈！\n\n如果是空树，不需要翻转，直接return\n如果非空，就把该节点的左右子树交换（这里不需要担心交换后找不到子树的问题）\n不需要单独搞空的子树，一并交换就可以\n当根节点为空的时候，return\n\n啪的一下很快哈，代码就写出来了！\nvoid _invertTree(struct TreeNode* root)&#123;    if(root==NULL)//设置退出条件，如果根节点为空就返回        return;    //让另外两个值来接收原本的左右节点    struct TreeNode* left=root-&gt;left;    struct TreeNode* right=root-&gt;right;    //更改左右节点    root-&gt;right=left;    root-&gt;left=right;    //递归子树    _invertTree(root-&gt;left);    _invertTree(root-&gt;right);&#125;struct TreeNode* invertTree(struct TreeNode* root)&#123;    if(root==NULL)//判断空树        return NULL;    _invertTree(root);        return root;&#125;\n\n\n102 层序遍历（较难😥）\nleetcode：102. 二叉树的层序遍历\n\n\n这道题相对来说就么有那么容易了，你可能和我一样，压根没看明白题目要求中的后两个参数是用来干嘛的\n\n/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes)&#123;&#125;\n\n看了一些题解，这才算理解了这道题的要求\n\n*returnSize：存放的是二叉树的层数\n**returnColumnSizes：存放的是二叉树每一层的节点个数\n返回值要求是int**：需要返回一个指针数组，该数组中的每一个元素是一个数组A，数组A保存了二叉树每一层的节点值\n\n\n0.错误思路最开始我的想法是，用单独的函数计算出树的节点个数和层级，再进行一次层序遍历来得到树的值。\n但很显然，这一思路在本题是搞不通的！🤔\n1.数组队列初始化在上一篇博客中，我讲述了利用队列来实现层序遍历的思路。这道OJ题目我们也是这么干的。不同的是，在我自己写的队列实现里，使用的是链式队列。而本题使用数组队列会好一点！\n#define MAX 2000int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) &#123;    if (root == NULL)        return;    struct TreeNode* Queue[MAX];//队列，存放节点的地址    int front = 0, tail = 0;//指向队头和队尾\n\n2.初始化数组这部分会毕竟绕，先一步一步来理解\n*returnSize = 0;//将二叉树层级初始化为0//存放二叉树的每一层节点的值int** ret = (int**)malloc(sizeof(int*) * MAX);//开辟一个数组来存放每一层的节点个数*returnColumnSizes = (int*)malloc(sizeof(int*) * (MAX / 2));\n\n\nret是一个指针数组，存放的是数组A，数组A里面是每一层的节点值。ret也就是题目要求的返回值\n*returnColumnSizes开辟一个数组来保存每一层的节点数\n\n这里其实returnColumnSizes没有啥二级指针的必要，但是既然题目给了是int**，我们就需要先*解引用再malloc开辟数组\n3.队列操作思路\n先让根节点入队列，tail++\n外层循环判断队列是否非空，如果非空就停止操作\n内层循环进行每一层的入队操作，这样才能得到每一层的节点值和节点个数\n在内层循环中创建ret数组的子数组，单独存放每一层的节点值\n最后将每一层的节点个数赋值给*returnColumnSizes数组，*returnSize++一次\n\n   struct TreeNode* head;   Queue[tail++] = root;//根节点入队   while (front != tail)   &#123;       int Csize = 0;//每一层的节点个数       int end = tail;       //end是每一层最末一个节点的指针。在后续的入队列操作中tail会改变，所以需要保存tail的值       ret[*returnSize] = (int*)malloc(sizeof(int*) * (end - front));       //为每一层开辟一个单独的数组来存放值       while (front &lt; end)       &#123;           head = Queue[front++];           ret[*returnSize][Csize++] = head-&gt;val;           //数组赋值，同时每一层的节点个数Csize++           if (head-&gt;left != NULL)               Queue[tail++] = head-&gt;left;           if (head-&gt;right != NULL)               Queue[tail++] = head-&gt;right;       &#125;       (*returnColumnSizes)[*returnSize] = Csize;//赋值每一层的节点个数       (*returnSize)++;//层数+1   &#125;return ret;\n\n外层循环结束后，此时ret数组就是题目要求的结果了，返回ret就可以了！\n\n这里有一个小问题，当树为空树时，层级应该是0。所以我们需要在第一行赋值*returnSize = 0;不然会执行出错\n\n\n这道题的思路是我看过题解之后才搞明白的，所以上面的只是一个思路的复现😭还是太菜了！\n\n结语本篇刷题笔记到这里就结束啦，如果对涉及到的题目有什么不懂的地方，可以在评论区提出哦！\n\n\n要是知道，OJ也能偷懒，嘿嘿嘿嘿……😂\n\n不过最后一道题是真的难，我还以为它和前中后序遍历一样，只是让我们遍历出数组的值呢🙃\n","categories":["数据结构太复杂"],"tags":["OJ刷题","C语言","数据结构","树"]},{"title":"【C++】并查集","url":"/2022/12/01/code/note_data_structure/15%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"并查集这个数据结构本身并不难，其主要是提供一个思路，方便我们编写图的代码，和一些OJ题\n\n\n[TOC]\n1.什么是并查集？并查集是多个独立集合的合集，用于表示数据之间的关系。\n比较生动的例子，就是我们生活中的朋友圈（不是wx的那个啊）\n\n张三和李四是好朋友，那么他们就构成了一个集合A\n王舞和王陆是好朋友，那么他们也构成了一个集合B\n此时，王舞突然认识了李四，这时候，就可以把A和B合并成一个集合\n\n推而广之，一个并查集中可以有多个这样的集合，多个朋友圈。\n\n并查集中的每一个集合是用多叉树来表示的\n\n2.思路并查集的思路并不难，给定一个数组的大小（需要在另外的地方管理编号）创建一个并查集\n下标即为数据的编号\n\n设定元素的初始值都是-1\n如果下标1和3为一个集和，那就把3的元素（初始值-1）加到1处，即1的元素为-2；再把3的元素设置为1的下标，即3的元素为1\n依此类推，最终只要下标所对应元素不为负数，那么这个下标就是一个集和的成员\n如果为负数，那么就是一个集合的根，且元素为这个集和中成员的个数（绝对值）\n\n如图所示，下标678所对应元素为0，代表它们属于以下标0为根的一个集合。而下标0处的元素为-4，代表这个集合里面有4个元素\n\n2.1 合并集合如果我们需要合并一个集合，以上图中的0集合和1集合为例。我们只需要将1集合的元素-3加到0集合上，再把1集合的元素改成0即可\n此时的树就会是这样的👇\n\n2.2 压缩路径当节点很多，集合可能会出现路径长度过大的情况。这时候我们就需要进行路径的压缩\n其方法很简单。遍历整个并查集，将同一集合的子节点改成相同的父亲即可\n\n这样在向上找集合的根时，无须跳转多次，一次就能找到。\n但由于并查集的访问是依靠数组下标实现的随机访问，时间复杂度为O(1)，只有数据样本量极大的时候，这么做才能有效果\n\n3.代码相比于其他数据结构复杂的实现，并查集的实现就简单多了。主要的函数只有几个，可以通过封装vector来实现\nclass UnionFindSet {public:\tUnionFindSet(const int sz)\t\t:_set(sz,-1)//调用vector构造函数，初始化sz个-1\t{}\tvoid Union(int x, int y)//设置x和y为一个集合\t{\t\tint r1 = FindRoot(x);\t\tint r2 = FindRoot(y);\t\tif (r1 != r2)//不在一个集和中\t\t{\t\t\t_set[r1] += _set[r2];\t\t\t_set[r2] = r1;\t\t}\t}\tint FindRoot(int n)//找这个集合的根\t{\t\twhile (_set[n] &gt;= 0)\t\t{\t\t\tn = _set[n];\t\t}\t\treturn n;//负数的时候为根\t}\tbool isUnion(int x,int y)//判断是否在一个集合中\t{\t\treturn FindRoot(x) == FindRoot(y);\t}\tint UnionSZ()//返回有几个集合\t{\t\tint count = 0;\t\tfor (int i = 0; i &lt; _set.size(); i++)\t\t{\t\t\tif (_set[i] &lt; 0)\t\t\t{\t\t\t\tcount++;\t\t\t}\t\t}\t\treturn count;\t}private:\tvector&lt;int&gt; _set;//用来存放对应关系};\n\n这里没有写压缩路径的代码，其实也就是一个遍历搞定的事😂\n4.OJ题4.1 剑指 Offer II 116. 省份数量\n剑指 Offer II 116. 省份数量 \n\n\n有了并查集，这道题就非常简单。最重要的是思路。我们无须现场造一个轮子，只需要写好找根函数，用一个数组就能实现一个简单的并查集\nclass Solution {public:    int FindRoot(const vector&lt;int&gt;&amp; v,int n)    {        int prev = n;//初始下标        while(v[prev]&gt;=0)//它的父亲下标        {            prev=v[prev];//如果不为负数，那就还是需要往前找        }        return prev;    }    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected)     {        vector&lt;int&gt; v(isConnected.size(),-1);        for(int i=0;i&lt;isConnected.size();i++)        {            for(int j=0;j&lt;isConnected[i].size();j++)            {                if(isConnected[i][j]==1)//为1代表是一个集合中的元素                {                    int root1 = FindRoot(v,i);                    int root2 = FindRoot(v,j);                    if(root1!=root2)                    {                        v[root1] += v[root2];                        v[root2] = root1;                    }                }            }        }        int count = 0;        for(int i=0;i&lt;v.size();i++)        {            if(v[i]&lt;0)            {                count++;            }        }        return count;    }};\n\n\n4.2 等式方程的可满足性\n990.等式方程的可满足性\n\n\n这道题和上面那一道差不多，只不过把省份换成了字母之间的关系\nclass Solution {public:    int FindRoot(const vector&lt;int&gt;&amp; v,int n)    {        int prev = n;//初始下标        while(v[prev]&gt;=0)//它的父亲下标        {            prev=v[prev];//如果不为负数，那就还是需要往前找        }        return prev;    }    bool equationsPossible(vector&lt;string&gt;&amp; equations) {        vector&lt;int&gt; v(26,-1);//因为题目给的都是小写字母，直接建立26个小写字母的映射表        for(int i=0;i&lt;equations.size();i++)        {            int root1 = FindRoot(v,equations[i][0]-'a');//第一个字母            int root2 = FindRoot(v,equations[i][3]-'a');//第二个字母            if(equations[i][1]=='=')//代表等于            {                if(root1!=root2)                {//设置为一个集合中的元素                    v[root1] += v[root2];                    v[root2] = root1;                }            }            else//不等于            {                if(root1==root2)                {                    //如果不等于的同时，根还相同                    //说明是同一个集合，不符合题意                    return false;                }            }        }        //还需要遍历第二遍，避免漏网之鱼        for(int i=0;i&lt;equations.size();i++)        {            int root1 = FindRoot(v,equations[i][0]-'a');//第一个字母            int root2 = FindRoot(v,equations[i][3]-'a');//第二个字母            if(equations[i][1]=='!')//不等于            {                if(root1==root2)                {                    //如果不等于的同时，根还相同                    //说明是同一个集合，不符合题意                    return false;                }            }        }        return true;    }};\n\n\n","categories":["数据结构太复杂"],"tags":["C++","数据结构","图"]},{"title":"【C语言】八大排序算法（带图详解）","url":"/2022/04/25/code/note_data_structure/12%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"前言如果你把本专栏从头看到这里，那么恭喜你，本篇博客已经是是初阶数据结构的收尾啦😁！让我们一起来学习一下，那些常见的排序算法！\n\n本篇博客主要讲述八大排序🕵️‍♀️，桶排序/基数排序可能会在后期补上！欢迎大家收藏本文！\n\n\n在之前的学习中，我们已经接触过ez的冒泡排序，和通过堆实现的堆排序，本篇博客就不再详解这两个了！\n\n有些排序的思路不是那么好懂，我的讲解也会有不到位的地方，欢迎在评论区提出你的疑惑或建议！🌭\n\n[TOC]\n1.插入排序1.1直接插入基本思想：把待排序的数依照大小插入一个已经有序的序列中，直到所有数插入完毕，就能得到一个新的有序序列\n\n实际上我们日常生活中打斗地主，在码牌的时候就运用了这种思想。把相同的数放在一起，并依照从小到大排列\n\n\n你可能会疑惑，都“已经有序”了，那还怎么排序？\n\n这需要我们之前学习链式二叉树时接触到的分治思想\n当我们手头上只有两个数的时候，将大的那个数插入到小的数后头，就形成了一个有序的2数序列\n这时候再让下一个数加入进来，把它插入到相应位置，得到一个有序的3数序列\n依次递进，最终就能得到一个有序的N数序列\n\n如果学习过分治思想的你，肯定一拍桌子道：“我知道了，手头上只有两个数的时候，就是分治的末端条件！”\n没错，我们就是要利用这种思想，实现从两个数开始的插入排序！\n\n给定一个数组，需要你使用插入排序，将它变成升序序列\n\n我们就从9开始，将1插入到9的前面，2插入到1、9之间，……\n\n这样就能最终排序出1 2 3 4 5 5 6 7 8 9的结果\n\n最后以代码的形式操作，如下面所示\n// 插入排序void InsertSort(int* a, int n){\t//在一个数组中插入新的数，每一趟都让最后的end+1的数据大于end\tfor (int i = 0; i &lt; n - 1; i++)\t{\t\tint end = i;\t\tint tmp = a[end+1];\t\twhile (end &gt;= 0)\t\t{\t\t\tif (tmp &lt; a[end])\t\t\t{\t\t\t\ta[end + 1] = a[end];\t\t\t\tend--;\t\t\t}\t\t\telse\t\t\t\tbreak;\t\t}\t\ta[end+1] = tmp;\t\t//最后end不符合条件出循环的时候，end可能为-1，a[end]会越界\t\t//如果是break出的循环，end+1和tmp的位置相同，自己等于自己，问题不大\t}}\n\n由此我们可以总结出直接插入排序的一些特性\n\n时间复杂度：O(N^2^)\n空间复杂度：O(1)，是原地算法\n元素越接近有序的时候，需要交换的次数就越少，算法的效率越高\n\n\n1.2希尔排序希尔排序是对直接插入的优化，又称“缩小增量法”。之前我们是进数组之后直接开R，现在先Q一下再R闪，这样才能打出更秀的操作。不过我的盲僧很菜，R闪就没有成功过😥\n\n喂喂喂，好像跑题了！\n\n基本思想：先选定一个整数gap，让后把待排序数据以gap为间隔进行单独的插入排序（预排序），这样让数列做到局部有序，最后在进行插入排序，达到优化插入排序算法效率的目的\n比如我们设定gap=3，这样原本的数组就被分割成了下面的模样，接着我们先对这3组数据进行单独的插入排序【这个操作被称为 预排序】\n\n你能写出它们单独插入排序后的结果吗？\n\n这时候我们的序列虽然不是有序的，但是只看一个小局部的时候，它是有序的。\n这样能减少插入排序操作时候的比较次数，自然效率就变高了\n\n执行完预排序后，我们就可以对现在的新序列进行插入排序了。但是直接这么调用还不够优化。\n\n再仔细看看上面的思路，你会发现，其实gap=1的时候，就相当于一次插入排序了\n\n而且当数据量很大的时候，我们也需要实时改变我们的gap。\n待排序数据有100个，gap=3就太小了，优化了个寂寞。\n待排序数据有10个，gap=20就是搬起石头砸自己的脚，同样不行！\n\n解决这个方法其实很简单，我们只需要根据待排序数据的大小动态设置gap就可以了，比如gap=n/2\n这时候就可以进行这么一个操作：每次预排序过后就改变一下gap，直到最后gap=1执行一次插入排序，数列有序\n\n落实到代码上，我们只需要把插入排序中所有和1有关的操作都改成gap，就实现了希尔排序\n\n这里需要注意的是gap的范围，因为我设置的是gap每次都/3，所以在最后可能会出现gap=2/3=0的情况，这时候其实排序还没有结束，但已经跳出循环了。我们需要在末尾+1保证最后一次插入排序的gap=1\n\n// 希尔排序void ShellSort(int* a, int n){\t//只要把插入排序中的1全部改成grap，就能形成一次间隔为3的预排序\t//当grap=1时，效果同插入排序相同\tint grap = n;\twhile (grap &gt; 1)//当grap=1，说明上一把已经是插入排序了\t{\t\tgrap=grap/3+1;//每一次都/3,再+1防止grap=2/3的情况\t\tfor (int i = 0; i &lt; n - grap; i++)\t\t{\t\t\tint end = i;\t\t\tint tmp = a[end + grap];\t\t\twhile (end &gt;= 0)\t\t\t{\t\t\t\tif (tmp &lt; a[end])\t\t\t\t{\t\t\t\t\ta[end + grap] = a[end];\t\t\t\t\tend -= grap;\t\t\t\t}\t\t\t\telse\t\t\t\t\tbreak;\t\t\t}\t\t\ta[end + grap] = tmp;\t\t}\t}}\n\n希尔排序的时间复杂度不好确定，因为我们通常会选取不同的gap，导致时间效率也不同。不过大部分资料中给出的时间复杂度如下👇到在“菜鸟教程”网，有对希尔排序时间复杂度的解析👉传送门\n\n\n2.选择排序2.1直接选择基本思路：遍历一遍数组，从中找出最大或最小的那一个数，然后将其放在数组前端。下一次遍历的时候，不再遍历这个数。\n注意：得到最大最小值后，需要将其和数组开头（或者结尾）的数进行交换，而不能直接覆盖，不然会出现数据丢失\n\n这个排序的思路非常好理解。进一步拓展，如果我一次遍历选出两个数，将最大值放在数组尾部，最小值放在数组开头，就可以减少一半遍历的次数。\n// 数据交换void Swap(int* a, int* b){\tint tmp = *a;\t*a = *b;\t*b = tmp;}// 直接选择排序void SelectSort(int* a, int n){\tint max ,min;\tint left = 0, right = n - 1;\t\twhile (left &lt; right){\t\tmax = min = left;//存放下标便于后面的交换\t\tfor (int i = left; i &lt;= right; i++)\t\t{\t\t\tif (a[i] &gt;=a[max]){\t\t\t\tmax= i;\t\t\t}\t\t\tif (a[i] &lt;= a[min]){\t\t\t\tmin= i;\t\t\t}\t\t}\t\tSwap(&amp;a[min], &amp;a[left]);\t\tif (max == left) {\t\t\tmax = min;\t\t}//如果max数据在开头，第一次交换会被替换        //所以需要重定向max的位置，再交换max\t\tSwap(&amp;a[max], &amp;a[right]);\t\tleft++;\t\tright--;\t}}\n\n不过，这个算法需要多次遍历数组，效率自然低的离谱，堪比冒泡（甚至比冒泡还拉）\n\n时间复杂度：O(N^2^)\n空间复杂度：O(1)\n\n\n2.2堆排序堆排序是指利用二叉树-堆这种数据结构来进行选择数据的一种排序算法，它是选择排序的一种。\n需要注意的是：升序要建大堆，排降序建小堆\n堆排序已经在之前的博客中讲解过，点击下方连接即可查看！👇\n\n【C语言】什么是堆？堆排序和TopK问题又是如何实现的\n\n这里给出堆排序的源码，或许聪明的你看源码就能看懂呢？\n// 堆排序void AdjustDown(int* a, int n, int root){\tassert(a);\tint parent = root;\tint child = parent * 2 + 1;//左孩子\twhile (child &lt; n){\t\t//找左右孩子中小的那一个\t\tif (child + 1 &lt; n &amp;&amp; a[child] &lt; a[child + 1])\t\t{//如果左孩子大于右孩子，则选择右孩子\t\t\tchild++;\t\t}\t\tif (a[child] &gt; a[parent]){\t\t\tSwap(&amp;a[child], &amp;a[parent]);\t\t\tparent = child;\t\t\tchild = parent * 2 + 1;\t\t}\t\telse{\t\t\treturn;\t\t}\t}}// 升序用大堆// 降序用小堆void HeapSort(int* a, int n){\t// 向下调整--建堆 O(N)\tfor (int i = (n - 1 - 1) / 2; i &gt;= 0; --i){\t\tAdjustDown(a, n, i);//此时建的是一个小堆\t}\tPrintArray(a, n);\tsize_t end = n - 1;\twhile (end &gt; 0){\t\tSwap(&amp;a[0], &amp;a[end]);//前后交换，最大的数放到末尾，不进行下一次调整\t\tAdjustDown(a, end, 0);\t\tend--;\t}}\n\n\n3.交换排序3.1咕噜咕噜排序说道冒泡排序啊，那就是陪伴咱们C语言学习始终的一个老朋友了。\n在C语言进阶的学习中，我曾写过一篇博客，里面讲解了用冒泡来模拟实现库函数qsort👉传送门\n\n它的思路就是对两个数进行比较，较大的数往尾部移动，较小的数字往头部移动\n\n在very very long time ago，我也写过关于冒泡排序的博客👇\n\n初识C语言==＞冒泡排序\n\n// 冒泡排序void BubbleSort(int* a, int n){\tfor (int i = 0; i &lt; n; i++)\t{\t\tint exchange = 0;\t\tfor(int j=0;j&lt;n-1-i;j++)\t\t{\t\t\tif (a[j] &gt; a[j + 1]){\t\t\t\texchange=1;\t\t\t\tSwap(&amp;a[j], &amp;a[j + 1]);\t\t\t}\t\t}\t\tif (exchange == 0){\t\t\tbreak;           //如果单趟排序没有发生交换，说明此时已经有序\t\t}\t}}\n\n\n空间复杂度：O(N^2^)\n时间复杂度：O(1)\n\n\n3.2快速排序快速排序是Hoare于1962年提出的一种二叉树结构的交换排序算法。\n基本思想：任取待排序序列中的某个元素作为基准值，按照该基准值将待排序集合分割成两个子序列，左子序列中所有元素均小于基准值，右 子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。\n\n3.2.1 Hoare法发明快排的大佬给出了一个方法，假设0下标处为基准值key。用左右指针来遍历数组，右指针找到比key小的数后停下，左指针找找到比key大的数后停下，它们俩进行交换。\n最后left和right相遇的时候，左右序列就已经排好了，此时将key与它们相遇的位置进行交换。新的序列key的左边小于key，右边大于key（此时不一定有序）\n\n疑问：既然最后要将相遇位置和key进行交换，那要怎么保证相遇位置小于key？\n答：通过右指针先走来实现！\n\n可能说完思路后，你还是不太了解这左右指针是怎么走的，别着急，来康康我画的动图👇\n\n因为是右指针先走，所以右指针停下的位置，一定是小于key的位置。此时只会是L来交R，不可能是R往左遇到L（因为L停下的位置大于key，在此右边不可能没有一个小于key的值）\n比如下图所示，如果L的位置右边只有一个比key小的值，那R在第一趟就会来到2的位置，然后L向右走一步与R相交，直接交换\n\n两种极端情况也会有下面的两种极端情况\n\nkey右侧没有比key小的值，那么R会直接与L相交，再原地交换key\nkey右侧没有比key大的值，R先移动（原地不动），L直接与R在末尾相交，前后交换\n\n这两种极端情况，就是快排的弱势所在，在后头会讲述如何优化key的选则，来避免这种极端情况\n\n下面给出hoare法的代码，中间的代码是一趟hoare排序的实现，而在末尾，我们递归排序key的前半区域和后半区域，一直递归到最小区间：【区间只有一个值，或者区间不存在】\nvoid QuickSort1(int* a, int begin, int end)//hoare{\tif (begin &gt;= end){\t\treturn ;//分治的末端条件判断\t}\t    //一趟排序\tint left = begin, right = end;\tint keyi = begin;\twhile (left &lt; right)\t{\t\twhile ((a[right] &gt; a[keyi])&amp;&amp;(right&gt;=begin))\t\t{\t\t\tright--;\t\t}\t\twhile ((a[left] &lt;= a[keyi])&amp;&amp;(left&lt;right))\t\t{\t\t\tleft++;\t\t}\t\tSwap(&amp;a[left], &amp;a[right]);\t}\tSwap(&amp;a[left],&amp;a[keyi]);\tkeyi = left;//必须移动keyi的位置\t    //递归排序左右区间\tQuickSort1(a, begin, keyi-1);\tQuickSort1(a, keyi + 1, end);}\n\n3.2.2 挖坑法挖坑法的思路比Hoare更好理解，详情见👇动图\n\n我们先用一个变量保存key的值（不是保存下标），然后R先走找比key小的，与坑位交换，L找比key大的，与坑位交换。最终LR相遇的时候，把key放回相遇位置，就完成了一趟排序\n\n注意：图中为了便于理解，将坑位用空白表示。实际在内存中操作的时候，坑位可以一直是key的值，不需要真的把它移走或者删除\n\n怎样？是不是比方法1好理解一些呢？\n下面给出挖坑法的代码示例\n//挖坑void QuickSort2(int* a, int begin, int end){\tif (begin &gt;= end) {\t\treturn;\t}\tint left = begin, right = end;\tint keyi = a[begin];//先存放keyi的值\tint pit = begin;//pit作为坑位\twhile (left &lt; right)\t{\t\twhile ((a[right] &gt; keyi) &amp;&amp; (right &gt;= begin))\t\t{\t\t\tright--;\t\t}\t\tSwap(&amp;a[pit], &amp;a[right]);\t\tpit = right;\t\twhile ((a[left] &lt;= keyi) &amp;&amp; (left &lt; right))\t\t{\t\t\tleft++;\t\t}\t\tSwap(&amp;a[pit], &amp;a[left]);\t\tpit = left;\t}\t\tQuickSort2(a, begin, pit - 1);\tQuickSort2(a, pit + 1, end);}\n\n3.2.3 前后指针法这部分就不画动图了，不知下面的这种方式能不能讲解清楚呢？\n\n\n这里需要弄明白的是cur和prev是分别在什么情况下移动\n\ncur比key小的时候，prev往后++一位，二者交换（在刚开始的时候是原地交换，但在图4中就不是原地交换了）\ncur比key大的时候，prev不动，cur继续往后++，直到找到比key小的数或者越界后停止（如果找到比key小的，就执行上一步的交换）\n最终cur越界了，交换prev和key的数据，一趟排序完成\n\n\n下面给出前后指针法的代码示例\nvoid QuickSort3(int* a, int begin, int end)//前后指针{\tif (begin &gt;= end) {\t\treturn;\t}\tint keyi = begin;\tint prev = begin, cur = begin + 1;\twhile (cur &lt;= end)\t{\t\twhile ((a[cur] &lt; a[keyi]) &amp;&amp; (a[++prev] != a[cur]))\t\t{\t\t\tSwap(&amp;a[prev], &amp;a[cur]);\t\t}\t\tcur++;\t}\tSwap(&amp;a[prev], &amp;a[keyi]);\tkeyi = prev;\t\tQuickSort3(a, begin, keyi - 1);\tQuickSort3(a, keyi + 1, end);}\n\n优化极端情况上面提到了快速排序有两种极端情况，我们可以用一个操作来优化它：\n既然key取数组首或尾部都可能会遇到它的后面没有比它小（或大）的数，那我们就让key尽量作为数组有序后应该处于中部的数来作为key\n这时候不能直接选取待排序数组中部的数，因为它不一定是数值正好的那个\n我们可以选取数组开头、末尾、中间的3个数进行比较，再选择这3个数里面居中的那个数作为我们的key，这样就能避免无效遍历！\nint GetMid(int* a, int left, int right){\tint mid = (left + right) / 2;\tif (a[left] &lt; a[mid])\t{\t\tif (a[mid] &lt; a[right]){\t\t\treturn mid;\t\t}\t\telse if (a[left] &gt; a[right]){\t\t\treturn left;\t\t}\t\telse{\t\t\treturn right;\t\t}\t}\telse // a[left] &gt; a[mid]\t{\t\tif (a[mid] &gt; a[right]){\t\t\treturn mid;\t\t}\t\telse if (a[left] &lt; a[right]){\t\t\treturn left;\t\t}\t\telse{\t\t\treturn right;\t\t}\t}\treturn -1;//其实这个没啥意义}\n\n但是单纯加上这个代码并不可行，因为这时候的key不再处于序列开头了，也就意味这我们后头的代码都需要重新写一遍！\n\n这不坑爹吗这是？！\n为了不没事找事重写一遍代码，这里直接把找到的MID和left进行交换就OK了！\n\n同时，为了避免多次递归导致栈溢出，我们还可以设置一个条件，在序列长度小于10的时候调用其他排序（比如插入排序）来实现后面的排序操作\n3.2.4快排的时间/空间复杂度快排的递归调用非常类似链式二叉树的前序遍历，它一共会递归logN层级，每一层加起来都有N个数，这样就能算出它的时间复杂度\n\n时间复杂度：O(N*logN)\n空间复杂度：O(logN)，这个是递归开辟栈帧的空间消耗\n\n\n3.3快排非递归实现这部分的知识就比较深奥了，你可以先看看这篇博客，了解一下函数调用的时候会发生什么👉传送门\n\n但不要担心，其实它的思路并没有那么难！\n\n首先需要先搞明白，递归调用的本质是在操作什么？\n在快排中，递归调用的本质是让程序自己来缩小排序的范围，再逐步扩大\n那我们可不可以利用数据结构中的栈，来模拟实现程序运行中的递归操作呢？\n\n排序完一趟后，将下一趟的左右范围入栈\n程序先调用存放在栈顶的右边范围进行排序，并把这个范围的左右小区间再次入栈\n最后右边的区间已经不可再分，就开始返回调用左边区间\n\n这个操作就犹如链式二叉树的后序遍历，先递归访问右节点，再往回返回左节点\n最后得到的结果就是类似递归调用完毕后的结果\n\n\n如果你还没有学习数据结构里面的栈，点我速览！\n\n下面给出一个非递归的实现：\n// 非递归void QuickSort4(int* a, int begin, int end){\tStack st;\tStackInit(&amp;st);\tStackPush(&amp;st, begin);\tStackPush(&amp;st, end);\twhile (!StackEmpty(&amp;st))\t{\t\tint right = StackTop(&amp;st);\t\tStackPop(&amp;st);\t\tint left = StackTop(&amp;st);\t\tStackPop(&amp;st);\t\tint keyi = PartSort3(a, left, right);\t\t// [left,keyi-1][keyi+1，right]\t\tif (left &lt; keyi-1)\t\t{\t\t\tStackPush(&amp;st, left);\t\t\tStackPush(&amp;st, keyi-1);\t\t}\t\tif (keyi + 1 &lt; right)\t\t{\t\t\tStackPush(&amp;st, keyi+1);\t\t\tStackPush(&amp;st, right);\t\t}\t}\tStackDestory(&amp;st);}\n\n注意：因为这里需要得到一趟递归调用后返回的keyi，所以我们需要把之前写的一趟快排单独拿出来，并设置返回值\n\n来调用一下试试，成功了！\n\n\n4.归并排序基本思想：采用分治递归，将已有的子序列合并，得到一个有序的序列。即先使每个子序列有序，再使子序列段间有序\n\n若将两个有序表合并成一个有序表，称为二路归并\n\n实现的步骤如下图\n\n\n先将区间通过递归分割成分治末端（只有一个值）\n再对相邻两个区间进行比较，开辟一个新的数组，依次将两个区间中小的那个按顺序摆放在新的数组中，再拷贝回原数组，就实现了归并\n当区间不存在的时候，开始返回递归，直到序列有序\n\n4.1打印printf调试大法这里最需要注意的就是分治的序列区间问题，如果代码不对，就很容易形成越界访问！\n这里我们可以通过printf调试大法来实现，打印出每一层递归时的区间，就能发现可能存在的越界访问问题。这种方法还能帮助我们理解分治递归\nprintf(\"[%d,%d][%d,%d]\\n\", begin, mid, mid+1, end);\n\n\n\n如果你在写程序的时候，发现控制台的光标闪动了很久都没有打印出数据，那么多半是程序中有死循环和bug\n\n比如现在，我们初步查看递归调用中是没有出现越界的，但是答案错误，进一步调试发现，tmp数组中有序数字，并没有被我们完整的拷贝回去\n原本是2 5拷贝回去变成了2 2，这个问题的根源很明显是memcpy函数调用有问题\n\n一看，哭笑不得，写了俩sizeof，魔怔了属于是\n\n修改之后，没问题啦！\n\n\n4.2递归源码这里给出最终的源码，一些地方写了注释\n//_代表这是子函数void _MergeSort(int* a,int* tmp, int begin, int end){\tif (begin &gt;= end){\t\treturn;\t}\tint mid = (begin + end) / 2;\t_MergeSort(a, tmp, begin, mid);\t_MergeSort(a, tmp, mid+1 , end);\t//printf(\"归并[%d,%d][%d,%d]\\n\", begin, mid, mid+1, end);\tint begin1 = begin, end1 = mid ;\tint begin2 = mid+1 , end2 = end;\tint cur = begin;\twhile (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)\t{\t\t//取小的放到新数组中\t\tif (a[begin1] &lt; a[begin2]) {\t\t\ttmp[cur++] = a[begin1++];\t\t}\t\telse {\t\t\ttmp[cur++] = a[begin2++];\t\t}\t}\t//第一个循环结束，并不代表归并完毕，可能只有一个数组的数据跑完了\t//我们需要将另外一个数组的数据全部拷贝到tmp中（因为剩下的的数据已经有序）\twhile (begin1 &lt;= end1) {\t\ttmp[cur++] = a[begin1++];\t}\twhile (begin2 &lt;= end2) {\t\ttmp[cur++] = a[begin2++];\t}\tmemcpy(a+begin,tmp + begin, ((end - begin +1)*sizeof(int)));}//归并排序void MergeSort(int* a, int n){\tint* tmp = (int*)malloc(n * sizeof(int));\tif(tmp==NULL){\t\tprintf(\"malloc failed\\n\");\t\texit(0);\t}\t_MergeSort(a, tmp, 0, n-1);\tfree(tmp);\ttmp = NULL;\treturn;}\n\n4.3非递归实现归并排序的非递归无法用栈来实现，因为我们不能把之前的大区间全给出栈了，因为这些区域还需要在最后重新进行归并！\n\n利用循环来控制不同的区间，由小到大，直到gap=n跳出循环\ngap是归并数据的个数，gap=1代表1个数归并，gap=2代表两两归并\n\n\n根据上面的思路，我们可以写出下面的范围循环\nint gap = 1;while (gap &lt; n){    // 间距为gap是一组，两两归并    for (int i = 0; i &lt; n; i += 2 * gap)    {        int begin1 = i, end1 = i + gap - 1;        //i+gap是个数，再-1是下标        int begin2 = i + gap, end2 = i + 2 * gap - 1;        //i+gap到i+2gap是个数，再-1是下标                //打印调试大法        printf(\"归并[%d,%d][%d,%d] -- gap=%d\\n\", begin1, end1, begin2, end2, gap);    }    gap *= 2;}\n\n跑一遍之前的测试用例，发现能搞定！这不就完事了吗？\n\n并没有！这里gap的操作都是*2，而且我们给的数组是偶数个，正好对的上\n如果我们再加一个数呢？程序打印出了每一层的递归区间，但是没有打印出最终的结果——因为这里在最后free的时候发现了数组越界访问\n\n小知识，数组越界一般都是在free的时候检查到的\n\n\n\n\n接下来要做的事就是控制下标区间，避免它越界\nint begin1 = i, end1 = i + gap - 1;int begin2 = i + gap, end2 = i + 2 * gap - 1;\n\n\n\n\nbegin\nend\n\n\n\ni\ni+gap-1\n\n\ni+gap\ni+2*gap-1\n\n\n仔细分析过后，发现当gap=2,i=8的时候，就会出现+gap之后越界的情况\n\n而会出现越界情况的，不止有end2，end1和begin2都可能会出现\n我们需要做的就是把越界的下标修正为不越界的下标\n\nend1越界，修正为不越界即可\nbegin2和end2都越界，修正为非法区间begin2&gt;end2\nbegin2不越界，end2越界，修正end2即可\n\n修正下标后，可以看到程序已经正常排序出了序列\n虽然打印出来的范围还是有越界的下标，但是这个是begin&gt;end的非法区间，不符合程序运行的条件，就不会产生越界\n\n4.3.1 条件断点这里还有一个骚操作，比如我们已经知道了是8-9的下标越界，这样我们就可以设置一个断点，来直接F5跳到那个情况，而不需要疯狂按F10\n// 条件断点，用于调试if (begin1 == 8 &amp;&amp; end1 == 9 &amp;&amp; begin2 == 10 &amp;&amp; end2 == 11){\tint x = 0;}\n\n\n这样我们的非递归实现也搞定啦！\n//非递归void MergeSortNonR(int* a, int n){\tint* tmp = (int*)malloc(sizeof(int) * n);\tint gap = 1;\twhile (gap &lt; n)\t{\t\t// 间距为gap是一组，两两归并\t\tfor (int i = 0; i &lt; n; i += 2 * gap)\t\t{\t\t\tint begin1 = i, end1 = i + gap - 1;//i+gap是个数，-1是下标\t\t\tint begin2 = i + gap, end2 = i + 2 * gap - 1;//i+gap到i+2gap是个数，-1是下标\t\t\tif (end1 &gt;= n) {\t\t\t\tend1 = n - 1;\t\t\t}\t\t\tif(begin2&gt;=n){\t\t\t\tbegin2 = n;\t\t\t\tend2 = n - 1;\t\t\t}\t\t\t\t\t\tif (begin2 &lt; n &amp;&amp; end2 &gt;= n) {\t\t\t\tend2 = n - 1;\t\t\t}\t\t\t//printf(\"归并[%d,%d][%d,%d] -- gap=%d\\n\", begin1, end1, begin2, end2, gap);\t\t\tint index = i;\t\t\twhile (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)\t\t\t{\t\t\t\tif (a[begin1] &lt; a[begin2])\t\t\t\t\ttmp[index++] = a[begin1++];\t\t\t\telse\t\t\t\t\ttmp[index++] = a[begin2++];\t\t\t}\t\t\twhile (begin1 &lt;= end1)\t\t\t\ttmp[index++] = a[begin1++];\t\t\twhile (begin2 &lt;= end2)\t\t\t\ttmp[index++] = a[begin2++];\t\t}\t\tmemcpy(a, tmp, n * sizeof(int));\t\tgap *= 2;\t}\tfree(tmp);}\n\n4.4归并排序的时间/空间复杂度\n时间复杂度：O(N*logN)\n空间复杂度：O(N)，创建数组的消耗\n\n\n5.计数排序计数排序的基本思路：利用数组的下标作为映射，遍历到x，在数组的x下标处++一次。最后再依照下标顺序将之前遍历到的数倒出来，就形成了正序序列。\n我在网上找来了一个很棒的动图（这个好像在很多博客里面都有😂）\n\n\n这个排序的思路就不难了，但有一点我们可以优化一下\n\n假设我们的序列是从300开始，而不是从0开始，那么开辟一个301个数的数组显然会浪费300之前的下标（因为并没有值）\n这时候我们可以找出数组的范围，开辟一个对应范围长度的数组，再利用相对映射的方式，来进行计数\n\n最后的代码如下\nvoid CountSort(int* a, int n){\tint min = a[0], max = a[0];\tfor (int i = 1; i &lt; n; ++i)\t{\t\tif (a[i] &lt; min)\t\t\tmin = a[i];\t\tif (a[i] &gt; max)\t\t\tmax = a[i];\t}\tint range = max - min + 1;\tint* count = (int*)malloc(sizeof(int) * range);\tassert(count);\tmemset(count, 0, sizeof(int) * range);\t// 计数\tfor (int i = 0; i &lt; n; ++i)\t{\t\tcount[a[i] - min]++;\t}\t// 排序\tint j = 0;\tfor (int i = 0; i &lt; range; ++i)\t{\t\twhile (count[i]--)\t\t{\t\t\ta[j++] = i + min;\t\t}\t}}\n\n5.1计数排序的特性\n时间复杂度：O(range+N)\n空间复杂度：O(range)\n\n计数排序适用于范围集中的数，不然会产生很大的空间浪费\n计数排序可以排序带负数的序列，同样是通过映射的方式\n但是计数排序只能排序整型数据，浮点类型是搞不定的\n\n看到这里，我们的八大排序就已经讲解完毕啦！\n不知道我讲解的够不够清楚呢？\n\n下面还有一个小点，就是关于排序算法的稳定性\n6.排序算法的稳定性估计很多人和我一样，都对这个“稳定性”有错误的理解\n我本来以为，稳定性代表的是排序算法的时间波动大不大\n实际上的稳定性，是算法对于某一个数的处理好不好\n比如下图，假设大家在考试，从上到下依次是交卷的顺序，我们发现王舞和李四的成绩相同，但是李四先交的卷。对于评判来说，当然是先交卷且分高的同学牛逼一点\n所以依照分数排序的时候，我们应该把李四排在王舞之前\n \n但有些算法在排序的时候，就做不到这一点\n这里对直接选择排序做一个简单的解释\n\n因为两个3的位置调换，就导致排序不够稳定\n实际上，所有需要进行选择交换的排序都不够稳定\n\n但是冒泡排序在交换的时候是严格保证大的数在后头，相等的数不交换的思路，所以冒泡排序是稳定的\n\n6.1 稳定性表格\n\n\n排序算法\n稳定性\n排序算法\n稳定性\n\n\n\n直接插入\n稳定\n希尔\n不稳定\n\n\n冒泡\n稳定\n直接选择\n不稳定\n\n\n归并排序\n稳定\n堆排序\n不稳定\n\n\n-\n-\n快速排序\n不稳定\n\n\n-\n-\n计数排序\n不稳定\n\n\n6.2 时间复杂度表格\n7.利用clock函数查看排序耗时排序算法写完后，我们可以通过调用clock函数来查看每一个排序的耗时\n先利用srand和time函数来创建随机数数组，在调用每一个函数，来查看它们排序的耗时\n\n由于代码过长，这里只给出某一个排序的计时代码，其他就CV一下就OK了\nsrand(time(0));const int N = 10000;int* a1 = (int*)malloc(sizeof(int) * N);for (int i = 0; i &lt; N; ++i){\ta1[i] = rand();//生成随机数 数组}int begin1 = clock();//读取系统时钟InsertSort(a1, N);int end1 = clock();//再读取系统时钟//二者相减得出该函数运行时长printf(\"InsertSort:%d\\n\", end1 - begin1);free(a1);\n\n运行结果：\n\n结语到这里，排序的绝大数知识点就讲解完毕啦！\n本篇博客画了很多图，还挺不容易的，还请大家点赞支持一下！\n\n特别是那两个看起来很简单的动图，实际上麻烦的很\n\n球球了，点个赞呐！\n\n","categories":["数据结构太复杂"],"tags":["C语言","算法","排序","数据结构"]},{"title":"【C++】图","url":"/2022/12/06/code/note_data_structure/16%E5%9B%BE/","content":"本文包含了图的基本概念\n\n\n1.相关概念1.1 无&#x2F;有向无向图：每一个顶点之间的连线没有方向\n有向图：连线有方向（类似离散数学的二元关系 &lt;A,B&gt;代表从A到B的边，有方向）\n&lt;A,B&gt;中A为始点，B为终点\n\n在无向图中，(V,U)和(U,V)是同一条边\n1.2 顶点和边图中的节点叫做顶点。\n顶点之间的线条就是边，表示事物与事物之间的关系。\n\n1.3 自回路&#x2F;多重图\n1.4 完全图图中每一个顶点都有连线（有最多的边数）就叫做完全图\n设顶点为N个\n\n无向完全图中n(n-1)/2条边\n有向完全图中n(n-1)条边\n\n1.5 邻接与关联无向图中(u,v)是一条边\n\n顶点u和v邻接\n边(u,v)与顶点u和v相关联\n\n1.6 子图\n图中G3是G1的子图，G4是G2的子图\n简单说来，就是子图是原图的一部分，包括顶点、边（注意方向）都是原图中的一部分\n1.6 路径路径是顶点序列\n路径是一个节点到另外一个节点需要经过的边\n\n路径长度：路径上边的数目\n简单路径：除起点、终点可以相同外，路径中其余顶点不相同\n回路：起点和重点相同的简单路径\n\n1.7 连通图两个顶点之间只要有路径，那就是连通的\n\n连通图：无向图中任意两点之间都有路径，那么就是一个连通图\n连通分量：无向图的极大连通子图\n\n\n注意，虽然连通分量被称为“极大连通子图”，但它并不是节点最多的哪一个。比如上图中的G2和G3都是极大连通子图。\n\n\n强连通图：有向图中，如果两个顶点之间U和V之间有U到V的路径，那就一定有从V到U的路径\n强连通分量：有向图的极大联通子图\n\n\n强连通图G1的极大强连通分量就是它自己（只有非强连通图才有多个强连通分量）\n上图中G2就不是强联通图，因为4节点没有入边（也就没有节点能到4）\n\n第三图的上半部分并非G1的强连通分量，但是是G2的强力连通分量。\n同时，单独的4顶点也是一个强连通分量（单独顶点都是）\n\n1.7 顶点的度度：与该顶点相关联的边的数目\n\n入度：射入v的边的数目\n出度：从v射出去的边的数目\n\n1.8 生成树生成树包含图中的所有顶点，但是只有足够构成一颗树的n-1条边\n\n因为n-1条边再加上一条就会构成回路\n生成树中不包含回路\n\n1.9 网给图中的每条边都添加上权值，带权的图称为网\n2.表示法2.1 邻接矩阵用二维数组来表示每个顶点之间的关系（矩阵）\n\n优缺点优点\n\n便于判断两个顶点之间是否有边，可以直接根据下标判断，O(1)\n便于计算各个顶点的度\n无向图：第i行元素之和就是顶点i的度（前提是用1来表示）\n有向图：第i行元素之和为顶点i的出度；第i列为入度\n\n\n\n缺点\n\n如果节点多，边少，就会出现空间浪费\n无法方便地找到一个顶点和那一条边相连（需要遍历）\n对于无向图，也会出现空间浪费\n\n2.2 邻接表邻接表有些类似于哈希表的拉链法。每一个节点后面跟着一个单链表，用于存储与这个节点相连的节点。\n在G2的有向图中，一般存储的是出度表，即从该节点出发的边。如果边有权值，则还需要存储权值\n\n优缺点优点：\n\n可以快速找到一个节点和谁相连（出度）\n\n缺点\n\n不便于判断两个顶点之间是否有边\n不便于计算有向图各个顶点的度（需要遍历所有节点）\n\n关于第二个缺点，可以新增一个入度表（即一个出度表&#x2F;一个入读表）来计算。但是这样会增加时空复杂度。\n3.遍历3.1 深度优先DFS深度优先以递归为基本思路，从一个结点开始，递归向后遍历这个节点的单链表中的节点。\n\n为了避免同一个节点遍历多次，我们需要有一个bool数组来标识一个节点是否遍历过。如果遍历过，则把对应下标的值设定为true来标识\n由于深度优先的递归部分只能遍历连通图。若出现了上图中非联通的情况，需要我们在外循环中重新遍历一下bool标识数组，确认所有节点都遍历完成。\n如果漏了节点（就是没有和其他节点联通的独立节点）那么就以此节点开头再进行一次深度遍历。\n\n3.2 广度优先BFS\n广度优先遍历类似二叉树的层序遍历，依靠循环+队列来完成遍历\n\n入起始节点，打印起始节点的值\n出队头节点（第一次的时候是起始节点）往队列中入该节点单链表中的所有节点\n依此类推，出一个节点，就入这个节点单链表中的所有节点\n同样地用一个bool数组标识节点是否被访问。如果被访问了则跳过该节点\n也需要在队列循环结束后遍历一遍bool数组，确认所有节点都访问完毕。\n\n\n3.3 判断一个图是否连通使用任何遍历方式，遍历完毕后检查bool数组\n若有节点没有被访问，则说明是非连通图\n4.拓扑排序\nhttps://blog.csdn.net/qq_43448856/article/details/119959241\n\n给定一个图，每次都选择一个无入度（没有入边）的节点加入序列中，并删除该节点的出边\n最终得到的序列就是一个拓扑排序之后的序列\n\n每次删除出边后，都可能形成新的无入度的节点\n\n因此，针对同一棵树的拓扑排序序列，可能有多种不同的情况\n5.最小生成树算法生成树的概念参考 1.8 生成树，最小生成树即让生成树中所有边的权值加起来最小\n5.1 普里姆\n如图中所示，我们先根据这个树的结构构造三个数组\n\nnearest代表和这个节点最近的节点（默认为-1）\nlowcost代表和这个节点最近节点的权值（默认为无穷大）\nmark是一个bool数组，标识该节点是否已经加入到最小生成树\n\n当我们每从图中取出一个节点的时候，就需要更新这三个表\n如图，当我们取走0之后，就需要更新和0连通的三个节点，其中nearest代表刚刚删除掉的节点0，lowcost代表它们和0相连边的权值；同时要把mark中0改为true，表明0已经加入生成树了\n\n第二次选取的时候，遍历lowcost表，找到权值最小的边为(0,2)权值为1。此时就把2加入进去，并更新与2相连的节点3（注，必须要权值更小才需要更新）\n\n依次遍历，直到所有节点都加入了最小生成树（左下角的图）\n\n该算法的时间复杂度为O(N^2)，只与节点的数量N有关\n5.2 克鲁斯卡尔\n构建一个和原图一样的节点图（无边）在原图中查找权值最小的边，判断其节点是否已经相同，如果没有形成环，则加入到最小生成树的图中\n\n判断是否成环可以通过并查集解决\n\n如下图，先遍历所有边，发现(0,2)的权值最小，判断该边加入后并不会使生成树形成环，则加入该边\n\n同时将0和2加入到同一个并查集的合集内\n\n\n同理继续找权值最小的边，加入到生成树中\n\n此时我们遇到了3条权值最小的边，权值都为5。此时可以随便加入一条边即可（不能使生成树成环）\n如下图中(0,3)和(2,3)的边加入后会使图成环，不能选择该边\n\n并查集中0、2、3、5已经在一个集合中，此时判断(0,3)在一个集合，该边不能加入；(2,3)在一个集合中，该边不能加入\n\n\n应该选择(1,2)这条边，其不会让树成环\n\n此时所有边都已经连起来了，最小生成树生成成功\n算法分析\n\n该算法的时间复杂度为O(E*logE)，其中E为边的数目\n6.最短路径单源最短路径思路有些类似并查集，path数组中存放的是每一个节点的上一条路径，若下标1处存放0，则代表是从0走到1。同时d数组中标识从0走到下标1的长度。\n\n把1加到s序列之后，发现0到节点2的路径长度缩短了，从原本的(0,2)的6变成了现在(0,1)+(1,2)的4+1=5，长度缩短，对应d数组中下标2处也需要更新\n继续下去，直到U数组中没有节点，S数组中节点满，即可获得一个从0出发到任何节点的单源最短路径\n","categories":["数据结构太复杂"],"tags":["C++","数据结构","图"]},{"title":"【算法】算法的空间复杂度和时间复杂度","url":"/2022/03/13/code/note_data_structure/1%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","content":"前言🕵️‍♂️在之前的学习中，已经接触过了网上OJ题目\n在一些题目中，我们经常可以看到时间复杂度和空间复杂度的要求\n你可能和我有一样的疑惑，复杂度究竟是什么？我要怎么评判我自己写的算法的复杂度？\n今天就让我们来认识认识~~\n\n\n\n1.算法效率🧐和做任何事情一样，我们写的算法，自然也有它的运行效率。效率越高越好\n1.1什么是算法算法可以简单地理解为我们为了求解一个问题，所写的函数\n在初识C语言中，我们学习过利用递归求解斐波那契数列的算法\nlong long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n这个算法只有3行代码，看上去非常简洁——但是简洁的代码不一定效率就高！\n1.2如何衡量？算法在编写成可执行程序的时候，main函数使用这个算法，需要调用一定的空间，消耗一定的时间。算法的效率就是通过空间和时间这两个维度来评判的\n\n时间复杂度：衡量一个算法的运行速度\n空间复杂度：衡量一个算法运行需要开辟的额外空间\n\n\n2.时间复杂度⏰算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。算法中基本操作的执行次数，为算法的时间复杂度\n\n时间复杂度是一个近似值，并不是实际运行的时间\n实际上代码的运行时间，和机器的内存、cpu性能和平台都有关系，同一个代码在不同的机器上运行时间都不一样，如果只以纯粹的时间来考核，很难分析\n\n找到某条基本语句与问题规模N之间的数学表达式，就算出了该算法的时间复杂度\nvoid Test(int N){\tint count =0;    for(int i=0;i&lt;N;i++)    {        for(int j=0;j&lt;N;j++)        {            count++;        }    }        for (int k = 0; k &lt; 2 * N ; ++ k)    {     \tcount++;    }        int M = 10;    while (M--)    {     \tcount++;    }        return;}\n\n请问这个代码中，count语句执行了几次？\n\nN = 10        F(N) = 130 \nN = 100      F(N) = 10210 \nN = 1000    F(N) = 1002010\n\n你可能会简单地认为，F(N)的结果就是我们的时间复杂度。其实并不然，我们并不需要一个精确的运行次数，只需要知道程序运行次数的量级就行了\n这里我们使用大O渐进表示法来表示时间复杂度（空间复杂度同理）\n2.1大O的渐进表示法大O符号（Big O notation）：是用于描述函数渐进行为的数学符号\n\n推导大O阶方法： \n\n用常数1取代运行时间中的所有加法常数。\n在修改后的运行次数函数中，只保留最高阶项。 \n如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶\n\n\n使用这种方法后，test1函数的时间复杂度为对于test1函数，在计算的时候，我们省略了最后的+10，保留了最高阶数N^2^，即得出了它的时间复杂度\n\n如果最高阶数前面有系数，如2N，系数也将被省略\n\n因为当N的数值很大的时候，后面的那些值对我们总运行次数的影响已经非常小了。大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数\n2.2多种情况取最坏一些算法的时间复杂度会有最好、最坏和平均的情况\n\n最好情况：任意输入规模的最小运行次数(下界)\n平均情况：期望的运行次数\n最坏情况：任意输入规模的最大运行次数(上界)\n\n举个例子，当我们编写一个在数组中查找数值的算法时，它可能会出现这几种情况：\n\n最好情况：1次就找到\n平均情况：N/2次\n最坏情况：N次\n\n在实际中的一般情况，我们关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)\n2.3常见时间复杂度的计算NO.1void Func1(int N){     int count = 0;     for (int k = 0; k &lt; 2 * N ; ++ k)     {     \t++count;     }     int M = 10;     while (M--)     {     \t++count;     } \tprintf(\"%d\\n\", count);}\n\n这里出现了两个循环，分别是2N次和10次。前面提到了大O渐进法只保留最高阶数并省略系数，所以它的时间复杂度是O(N)\nNO.2void Func2(int N, int M){     int count = 0;     for (int k = 0; k &lt; M; ++ k)     {     \t++count;     }     for (int k = 0; k &lt; N ; ++ k)     {     \t++count;     }     printf(\"%d\\n\", count);}\n\n这里出现了次数为N和M的两层循环\n\n当M和N差不多大的时候，时间复杂度可以理解为O(M)或O(N)\n当M远远大于N时，时间复杂度为O(M)\n一般情况取O(M+N)\n\n\nNO.3 常数阶void Func3(int N){     int count = 0;     for (int k = 0; k &lt; 100; ++ k)     {     \t++count;     }     printf(\"%d\\n\", count);}\n\n这里我们得知了具体的循环次数为100，是一常数，时间复杂度为O(1)，代表常数阶\n\n只要循环次数已知，为一常数且和所传参数无关，其时间复杂度即为O(1)\n\nNO.4 strchr//计算strchr的时间复杂度const char * strchr ( const char * str, int character );\n\n看到这道题的时候，你可能会一愣，strchr是什么？\n\n在之前的博客里，我介绍了很多常用的字符串函数👉点我\n可这里面没有strchr，但有strstr\n\nstrstr函数的作用：在字符串1中寻找是否有字符串2\n其中第二个str代表的是string字符串，那我们是不是可以猜想，chr代表的是char字符，其作用是在一个字符串中查找是否有一个字符呢？\n当然，光是猜想肯定是不够的，我们还需要求证一下\n\n如何查询库函数定义并尝试使用它？👉点我\n\n打开cplusplus网站，搜索strchr，即可转到函数定义\n\n可以看到，该函数的作用是定位字符串中第一次出现该字符的位置，返回值是一个pointer指针\n和我们猜想的一样，它的作用就是在字符串中查找一个字符，并返回它第一次出现的位置的地址。\n这样一来，strchr函数的时间复杂度就很清楚了，就是遍历字符串所需要的次数，O(N)\nNO.5 冒泡排序void BubbleSort(int* a, int n){     assert(a);     for (size_t end = n; end &gt; 0; --end)     {         int exchange = 0;         for (size_t i = 1; i &lt; end; ++i)         {         \tif (a[i-1] &gt; a[i])         \t{                Swap(&amp;a[i-1], &amp;a[i]);                exchange = 1;         \t}    \t }     if (exchange == 0)    \t break;     }}\n\n冒泡排序是一个非常经典的代码，其思路就是遍历整个数组，如果待排序数字大于它的下一位，则交换这两个数字\n\nN个数字的数组需要N-1次排序才能完成\n每一次排序都需要遍历一次数组\n\n这样算来，冒泡排序的循环次数就是两个N，即为O(N^2^)\n\n能否通过循环层级判断？细心的你可能会发现，上述代码中出现了两层循环，那是不是可以通过循环层级来判断时间复杂度呢？\n并不能！\nfor(int i=0;i&lt;n;i++){\tfor(int j=0;j&lt;3;j++)\t\tprintf(\"hehe\\n\");}\n\n如果是上述这种两次循环的情况，会打印3n次呵呵，其时间复杂度是O(N)而不是N^2^\n\n我们要准确分析算法的思路，并不能简单地通过循环层级来判断时间复杂度\n\nNO.6 二分查找//a 数组，n长度，x需要查找的数int BinarySearch(int* a, int n, int x){     assert(a);     int begin = 0;     int end = n-1;     while (begin &lt;= end)     {         int mid = begin + ((end-begin)&gt;&gt;1);//使用位移操作符来模拟/2，防止begin和end相加后超出int范围         if (a[mid] &lt; x)         \tbegin = mid+1;         else if (a[mid] &gt; x)         \tend = mid-1;         else         \treturn mid;//返回需要查找的数的下标     }     return -1;}\n\n二分查找的思路这里不再赘述\n假设我们找了x次，每一次查找都会使查找范围减半\nN/2/2/2/2 ……\n\n最后我们可以得出2条公式\n\n\n最好情况：O(1)\n最坏情况：O(logN)\n\n\n通过时间复杂度的对比，我们就能看出二分查找的优势在那里了\n\n\n\nN\nO(N)\nO(logN)\n\n\n\n1000\n1000\n10\n\n\n100w\n100w\n20\n\n\n10亿\n10亿\n30\n\n\n可以看到，当数据很大的时候，O(logN)的算法执行次数比O(N)少了特别多!!（来自BT-7274的肯定）\n\nNO.7 计算N!// 计算阶乘递归Fac的时间复杂度？long long Fac(size_t N){     if(0 == N)     \treturn 1;     return Fac(N-1)*N;}\n\n对于这个阶乘的递归函数而言，每次函数调用是O(1)，时间复杂度主要看递归次数\n对于数字N而言，递归需要N次，时间复杂度是O(N)\n递归算法时间复杂度计算\n如果每次函数调用是O(1)，看递归次数\n每次函数调用不是O(1)，那么就看他递归调用中次数的累加\n\nNO.8 斐波那契数列\n计算斐波那契数可以用递归和迭代两种算法👉点我\n\n// 计算斐波那契递归Fib的时间复杂度？long long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n\n每次递归，次数都会增加，总的来说是以2^x的量级增加的（x代表行数）这里一共有x-1项，用等比数列的求和公式得出，结果为2^x-1^\n所以最后得出的时间复杂度为O(2^N^)\n\n需要注意的是，当递归调用到底部时，有一些调用会较早退出，这部分位于金字塔的右下角\n\n由于时间复杂度只是一个估算值，这一部分缺失的调用次数对总运行次数的影响不大，故忽略掉\n\nNO.9void fun(int n) {   int i=l;   while(i&lt;=n)      i=i*2;}\n\n此函数有一个循环，但是循环没有被执行n次，i每次都是2倍进行递增，所以循环只会被执行log2n次\nNO.10给定一个整数sum，从有N个有序元素的数组中寻找元素a，b，使得a+b的结果最接近sum，最快的平均时间复杂度是？\nA. O(n)//√B. O(n^2)C. O(nlogn)D. O(logn)\n\n数组元素有序，所以a,b两个数可以分别从开始和结尾处开始搜，根据首尾元素的和是否大于sum,决定搜索的移动，整个数组被搜索一遍，就可以得到结果，所以最好时间复杂度为n\n\n3.空间复杂度🏠3.1概念空间复杂度是对一个算法在运行过程中临时占用空间大小的度量\n\n和时间复杂度不是真的计算时间一样，空间复杂度也不衡量算法具体占用的内存字节数。\n\n空间复杂度计算的是额外开辟的变量的个数，适用大O渐近法\n注意：函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。\n3.2空间复杂度计算NO.1 冒泡排序void BubbleSort(int* a, int n){     assert(a);     for (size_t end = n; end &gt; 0; --end)     {         int exchange = 0;         for (size_t i = 1; i &lt; end; ++i)         {         \tif (a[i-1] &gt; a[i])         \t{                Swap(&amp;a[i-1], &amp;a[i]);                exchange = 1;         \t}    \t }     if (exchange == 0)    \t break;     }}\n\n我们会发现，冒泡排序算法并没有额外定义非常多的变量，一共只有3个，属于常数阶\nsize_t end = n;int exchange = 0;size_t i = 1;\n\n其空间复杂度为O(1)\n计算时注意其与N的关系当我们在算法中开辟空间，计算空间复杂度的时候，要注意开辟的这个空间与N有没有关系\nint arr[N];//c99变长数组，和传过来的参数有关int* a=(int*)malloc(sizeof(int)*N);//和传过来的参数有关，O(N)int* a=(int*)malloc(sizeof(int)*3);//和传过来的参数无关，O(1)\n\nNO.2 斐波那契数列// 计算Fibonacci的空间复杂度？// 返回斐波那契数列的前n项long long* Fibonacci(size_t n){     if(n==0)     return NULL;     long long * fibArray = (long long *)malloc((n+1) * sizeof(long long));     fibArray[0] = 0;     fibArray[1] = 1;     for (int i = 2; i &lt;= n ; ++i)     {     \tfibArray[i] = fibArray[i - 1] + fibArray [i - 2];     }     return fibArray;}\n\n和上面的斐波那契数列的递归代码不同，这里我们新创建了一个数组，用来保存计算出来的斐波那契数\n一共malloc了n+1个长整型的空间，空间复杂度是O(N)\n\n空间重复使用问题如果是递归方法的斐波那契算法，其空间复杂度是多少呢？\nlong long Fib(size_t N){     if(N &lt; 3)     \treturn 1;     return Fib(N-1) + Fib(N-2);}\n\n答案也是O(N)\n因为对于递归算法而言，其开辟的函数栈帧空间是可以重复利用的！\n如fib(8)的调用，其开辟的函数栈帧，是可以在后续继续调用fib函数时重复使用的\n\n通过函数的参数压栈，我们可以很好地理解这是为啥👉点我\n\n\n上图中f1和f2是两个函数，但执行了相同的功能。其函数调用的空间实际上是一个，f2在f1销毁后继承了它的空间\n\n这就好比每一次新的递归都会开一家新的饭店，但是你下次还想吃东北菜的时候，可以去之前开的东北菜馆，咱没必要让别人再开一家馆子不是嘛？\n\n\n不过由于斐波那契数的递归算法会递归非常多次，在数字很大的时候，会导致栈溢出\n\n\nNO.3 阶乘long long Fac(size_t N){     if(N == 0)     \treturn 1;     return Fac(N-1)*N;}\n\n虽然函数本身的空间不计入时间复杂度，这里计算的是递归调用时额外开辟的函数栈帧空间\n一共调用了N-1次，每个栈帧使用了常数个空间，空间复杂度是O(N)\n4.常见复杂度对比👐\n\n\n结语😘时间复杂度和空间复杂度可以帮我们很好的了解自己所写算法的好坏，在未来面试的时候，HR肯定也更喜欢效率高的算法\n要多刷题，好好积累自己的能力，想必之后写出好算法也是水到渠成（吧？）\n\n如果这篇博客对你有帮助，点个赞再走呗~\n\n","categories":["数据结构太复杂"],"tags":["OJ刷题","C语言","算法","数据结构"]},{"title":"【C语言】顺序表（详解）","url":"/2022/03/21/code/note_data_structure/2%E9%A1%BA%E5%BA%8F%E8%A1%A8/","content":"[TOC]\n前言顺序表是我们学习数据结构第一阶段的必经之路\n什么是顺序表，且听我慢慢道来\n本篇博客用到的知识点：\n\n动态内存管理\n自定义类型-结构体\n所用编译器：VS2019\n\n\n1.什么是顺序表？1.1线性表线性表是数据结构的一种，它是n个具有相同特性的数据元素的有限序列。 常见的线性表：顺序表、链表、栈、队列、字符串……\n线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理内存上存储时，通常以数组和链式结构的形式存储。\n本篇博客所讲述的顺序表，就是以数组结构存储的线性表\n\n\n2.编写你的顺序表！为了保证写完之后不要进入贤者debug状态，建议每编写一个模块，就在test.c的main函数中进行测试，保证当前编写的模块正确后再进行下一步！\n不然问题多了，改起来很头疼的！\n\n2.0 赛前准备和我们日常所用的数组不同，顺序表的这个结构，主要的组成部分是一个结构体（本篇博客中的线性表以int为例）\nstruct SeqList&#123;\tint* a;\tint size;     // 存储数据个数\tint capacity; // 存储空间大小&#125;;\n\n为了方便使用，我们可以使用typedef对符号进行重定义\ntypedef int SLDataType;//和普通的整型区分开，以此命名的数据和顺序表直接相关//动态顺序表typedef struct SeqList&#123;\tSLDataType* a;\tint size;     // 存储数据个数\tint capacity; // 存储空间大小&#125;SeqList;//SeqList可以替代struct SeqList\n\n2.1 初始化本次编写顺序表代码，我们采用“多文件编程”方式，将函数的实现，函数的声明与主函数分开，分别放入两个源文件和一个头文件\n\n先在main函数中定义一个顺序表的结构体，编写SQLinst函数进行初始化\nSeqList s;//创建结构体变量SQLinst(&amp;s);//初始化\n\n在.h文件中，我们写入函数声明和库函数的引用。\n注意需要在另外两个.c文件中以&quot;Seqlist.h&quot;方式引用自定义头文件\n#include&quot;Seqlist.h&quot;\n\n\n初始化方式如下，我们先给a用calloc函数开辟3个SLDataType(int)类型的空间\n\nCAPA：由define定义的符号，方便后续修改初始容量\n\nvoid SQLinst(SeqList* sql)&#123;\tassert(sql);\tsql-&gt;a = (SLDataType*)calloc(CAPA,sizeof(SLDataType));\tsql-&gt;capacity = CAPA;\tsql-&gt;size = 0;\treturn;&#125;\n\n\n2.2 容量检查既然我们的函数是由calloc开辟的动态内存空间，就需要在顺序表内空间不够用的时候，检查容量，判断是否需要扩容\nvoid CheckCapacity(SeqList* sql)&#123;\tassert(sql);\tif (sql-&gt;size &lt; sql-&gt;capacity)\t\treturn;\telse\t&#123;\t\tsize_t newcapacity = 2 * (sql-&gt;capacity);\t\tSLDataType* tmp = (SLDataType*)realloc(sql-&gt;a,newcapacity*sizeof(SLDataType));\t\tif (tmp == NULL)\t\t&#123;\t\t\tprintf(&quot;realloc failed\\n&quot;);\t\t\texit(0);\t\t&#125;\t\telse\t\t&#123;\t\t\tsql-&gt;a = tmp;\t\t\tsql-&gt;capacity = newcapacity;\t\t&#125;\t&#125;\treturn;&#125;\n\n使用realloc函数的时候需要注意，它可能扩容失败，所以我们不能直接让sql-&gt;a来接收realloc函数的返回值（扩容失败返回NULL，相当于前功尽弃）\n而是需要用一个中间变量tmp来接收开辟后的地址，确认realloc成功后再赋值给a。同时，也需要将sql-&gt;capacity更改成新的容量\n\n2.3 打印顺序表void SQLprint(SeqList* sql)&#123;\tassert(sql);\tfor (int i = 0; i &lt; (sql-&gt;size); i++)\t&#123;\t\tprintf(&quot;%d &quot;, sql-&gt;a[i]);\t&#125;\tprintf(&quot;\\n&quot;);\treturn;&#125;\n\n2.4 尾插和尾删和平时使用数组不同的是，线性表中把在表尾插入数据称作尾插、删除数据叫做尾删，对应的是pushback和popback\n\n如果你看过之前我的那篇函数调用参数压栈的博客，应该还记得，汇编代码中入栈和出栈也是push和pop\n\nvoid SQLpushback(SeqList* sql, size_t x);//尾插void SQLpopback(SeqList* sql);//尾删\n\n实现方式很是简单，和我们日常在数组尾部插入元素相同\n需要注意的是，这里我们插入的数据是size_t（unsigned int)类型，也就是说，这个顺序表中并没有负数\nvoid SQLpushback(SeqList* sql, size_t x)&#123;\tassert(sql);\tCheckCapacity(sql);//使用时检查容量\tsql-&gt;a[sql-&gt;size] = x;\tsql-&gt;size++;\treturn;&#125;void SQLpopback(SeqList* sql)&#123;\tassert(sql);    //sql-&gt;a[sql-&gt;size] = 0;    //这里可以把最后一个数改为0，也可以不改\tsql-&gt;size--;\treturn;&#125;\n\n\n2.5 头插和头删和尾部修改数据不同，在头部修改数据，必须要把已有数据整体往后移动\n\nvoid SQLpushfront(SeqList* sql, size_t x)&#123;\tassert(sql);\tCheckCapacity(sql);\tint i = sql-&gt;size;\twhile (i &gt;= 0)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i - 1];\t\ti--;\t&#125;\tsql-&gt;a[0] = x;//整体后移 之后修改第一个数\tsql-&gt;size++;\treturn;&#125;void SQLpopfront(SeqList* sql)&#123;\tassert(sql);\tint i = 0;\twhile (i &lt; (int)sql-&gt;size)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i + 1];\t\ti++;//直接整体前移即可\t&#125;\tsql-&gt;size--;\treturn;&#125;\n\n2.6 插入和删除除了头尾的操作，我们还需要编写在顺序表中间的插入和删除操作\n\n插入：需要将插入位置之后的数据整体后移\n删除：删除位置之后的数据整体前移\npos：插入位置的下标\n\nvoid SQLinsert(SeqList* sql, size_t pos, size_t x)&#123;\tassert(sql);\tif (pos &gt;= (int)sql-&gt;size)\t&#123;//温和的判断，assert太过暴力，在OJ里容易出错\t\tprintf(&quot;input err\\n&quot;);\t\treturn;\t&#125;\tCheckCapacity(sql);\tint i = sql-&gt;size;\twhile (i &gt; (int)pos)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i - 1];\t\ti--;\t&#125;\tsql-&gt;a[pos]=x;\tsql-&gt;size++;\treturn;&#125;void SQLerase(SeqList* sql, size_t pos)&#123;\tassert(sql);\tif (pos &gt;= (int)sql-&gt;size)\t&#123;//温和的判断，assert太过暴力，在OJ里容易出错\t\tprintf(&quot;input err\\n&quot;);\t\treturn;\t&#125;\tint i = pos;\twhile (i &lt; (int)sql-&gt;size-1)\t&#123;\t\tsql-&gt;a[i] = sql-&gt;a[i + 1];\t\ti++;\t&#125;\tsql-&gt;size--;\treturn;&#125;\n\n2.7 查找和更改当我们需要查找的时候，必须从头开始遍历整个数组，来找到待查找元素\nint SQLfind(SeqList* sql, size_t x)&#123;\tassert(sql);\tfor (int i = 0; i &lt; sql-&gt;size; i++)\t&#123;\t\tif (sql-&gt;a[i] == x)\t\t&#123;\t\t\treturn i;//返回下标\t\t&#125;\t&#125;\tprintf(&quot;find err\\n&quot;);\treturn -1;&#125;\n\n而修改函数则是在查找的基础上，更改掉目标元素\nvoid SQLmodify(SeqList* sql, size_t pos, size_t x)&#123;\tassert(sql);\tsql-&gt;a[pos] = x;\t\treturn;&#125;\n\n如果用户不知道自己想修改的元素的下标，可以通过find函数查找，再调用修改函数\n\n3.菜单一个小建议是，不要在一开始编写函数的时候就写出菜单！\n因为这样非常不方便debug，你需要按菜单上的函数调用再进行下一步操作\n\n话说是不是应该在前面就告诉大家？😂\n\n\n菜单的使用需要配合switch&#x2F;case语句来执行，方便用户输入操作数进行函数调用\nvoid menu()&#123;\tprintf(&quot;*****************************\\n&quot;);\tprintf(&quot;******1.头插  2.尾插*********\\n&quot;);\tprintf(&quot;******3.头删  4.尾删*********\\n&quot;);\tprintf(&quot;******5.插入  6.删除*********\\n&quot;);\tprintf(&quot;******7.查找  8.更改*********\\n&quot;);\tprintf(&quot;******9.打印  0.exit*********\\n&quot;);\tprintf(&quot;*****************************\\n&quot;);&#125;\n\n我们可以在每个模块printf对应的提示，方便用户操作顺序表\nint main()&#123;\tSeqList s;//创建结构体变量\tSQLinst(&amp;s);//初始化#if\tM\ttest1(&amp;s);//测试函数#endif\t\tmenu();\tprintf(&quot;请输入命令&gt;&quot;);\tint option;\tscanf(&quot;%d&quot;, &amp;option);\tdo&#123;\t\tswitch (option)\t\t&#123;\t\tcase 0:\t\t&#123;\t\t\tSQLdestory(&amp;s);\t\t\tprintf(&quot;destory SQL\\n&quot;);\t\t\texit(0);\t\t&#125;\t\tcase 1:\t\t&#123;\t\t\tint x;\t\t\tprintf(&quot;请输入需要头插的数&gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;x);\t\t\tSQLpushfront(&amp;s, x);\t\t\tbreak;\t\t&#125;\t\tcase 2:\t\t&#123;\t\t\tint y;\t\t\tprintf(&quot;请输入需要尾插的数&gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;y);\t\t\tSQLpushback(&amp;s, y);\t\t\tbreak;\t\t&#125;\t\tcase 3:\t\t\tSQLpopfront(&amp;s);\t\t\tbreak;\t\tcase 4:\t\t\tSQLpopback(&amp;s);\t\t\tbreak;\t\tcase 5:\t\t&#123;\t\t\tint m, n;\t\t\tprintf(&quot;请输入插入位置和插入数&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;m, &amp;n);\t\t\tSQLinsert(&amp;s, m, n);\t\t\tbreak;\t\t&#125;\t\tcase 6:\t\t&#123;\t\t\tint d;\t\t\tprintf(&quot;请输入待删除数的位置&gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;d);\t\t\tSQLerase(&amp;s, d);\t\t\tbreak;\t\t&#125;\t\tcase 7:\t\t&#123;\t\t\tint f;\t\t\tprintf(&quot;请输入需要查找的数&gt;&quot;);\t\t\tscanf(&quot;%d&quot;, &amp;f);\t\t\tprintf(&quot;该数下标为:%d\\n&quot;, SQLfind(&amp;s, f));\t\t\tbreak;\t\t&#125;\t\tcase 8:\t\t&#123;\t\t\tint h, i;\t\t\tprintf(&quot;请输入需要更改的下标和新的数字\\n&quot;);\t\t\tprintf(&quot;如果您不知道该数的位置，可以调用查找模块\\n&quot;);\t\t\tprintf(&quot;请输入&gt;&quot;);\t\t\tscanf(&quot;%d %d&quot;, &amp;h, &amp;i);\t\t\tSQLmodify(&amp;s, h, i);\t\t\tbreak;\t\t&#125;\t\tcase 9:\t\t\tSQLprint(&amp;s);\t\t\tbreak;\t\t&#125;\t\tprintf(&quot;请输入命令&gt;&quot;);\t&#125; while (scanf(&quot;%d&quot;, &amp;option) != EOF);\treturn 0;&#125;\n\n最终效果如图\n\n一些err当我使用switch&#x2F;case语句，在case语句中定义局部变量的时候，VS报错“声明不能包含标签”\n\n这个报错并不会阻止程序运行\n\n\n解决办法是在case语句后带上大括号，报错就消失了\n\n\n总结顺序表内容算是对前面学习的一些C语言知识的运用，数据结构的严谨性更胜一筹。\n比如在判断pos和size的大小的时候，会报错类型不一致。\n这时候我们需要把无符号整型的size强制转换为int类型，再和pos进行比较！\n\n如果这篇博客对你有帮助，还请点个👍吧\n\n","categories":["数据结构太复杂"],"tags":["C语言","数组","数据结构"]},{"title":"【C语言】单链表太难学不懂？看这一篇就够了","url":"/2022/03/23/code/note_data_structure/3%E5%8D%95%E9%93%BE%E8%A1%A8/","content":"[TOC]\n前言😀之前的博客中我们讲述了顺序表的数据结构，顺序表和之前C语言学习的数组还是比较相似的。\n今天要学习的是链表，这是一个全新的数据结构，和之前我们学的内容都不相同。\n\n编译器：VS2019\n\n1.什么是链表链表，如其名所示，是一个带链子的表\n和顺序表的扩容开辟相比，它可以利用内存堆区中的空闲空间，而不需要一个连续的长空间。从而达到提高空间利用效率的目的。\n\n\n链表中每一个单独开辟的“元素”称为一个节点\n链表有一个头指针phead，用于指向链表的首节点\n单链表中，每一个节点都有一个next指针，指向下一个节点\n链表的尾节点的next指向NULL空指针\n\n这样我们在使用的时候，就可以用过next指针访问链表的下一个节点，一直到最后一个节点的next为空停止。\n需要注意的是，链表的每个节点之间并没有实际意义上的箭头，画出箭头只是方便我们理解。实际上，在内存中，链表的next指针就充当了箭头的角色。\n\n链表的结构在逻辑上连续，但在物理上不一定连续\n实际上在堆区开辟空间中，分配的内存可能连续，可能不连续\n\n1.1链表的分类1 单向&#x2F;双向链表\n2 带头&#x2F;不带头这里的头，指的是一个头节点。该节点的next指向链表实际的表头，val中不存放有效数据\n实际使用时，带头的head-&gt;next相当于不带头的phead指针\n\n3 循环或者非循环\n本篇博客讲解的是无头单向非循环链表，双向链表将在之后的博客里面讲解！\n\n2.开始敲代码！实际编写代码的时候，一定要记住：写完一个模块就要测试一次，不要全写完再测试！！！\n2.1  链表结构和顺序表一样，使用单链表之前，我们需要创建一个“模板”，即单链表每个节点的结构体\ntypedef int SLTDataType;//定义新符号，与该符号相关的都是链表内容typedef struct SListNode&#123;\tSLTDataType data; //val-存放内容\tstruct SListNode* next; //存储下一个节点的地址&#125;SListNode, SLN;\n\n2.2 开辟节点当我们使用单链表时，需要先开辟一个头节点，并使它的next指针指向NULL\nSListNode* node1 = (SListNode*)malloc(sizeof(SListNode));node1-&gt;data = 1;node1-&gt;next = NULL;\n\n这部分我们可以封装一个函数来实现！\nSListNode* BuySListNode(SLTDataType x)//x代表该节点val的值&#123;\tSListNode* newnode = (SListNode*)malloc(sizeof(SListNode));\tif (newnode == NULL)\t&#123;\t\tprintf(&quot;malloc fail\\n&quot;);\t\texit(-1);\t&#125;\telse\t&#123;\t\tnewnode-&gt;data = x;\t\tnewnode-&gt;next = NULL;\t&#125;\treturn newnode;&#125;\n\n需要注意的是，使用这个函数的时候，我们应该先让另外一个指针来接收返回的newnode地址，不建议直接让上一个节点的next来接收返回值\n\n这样做能方便我们后续debug！\n\n//建议做法SListNode* newnode = BuySListNode(x);tail-&gt;next = newnode;//不建议tail-&gt;next=BuySListNode(x);\n\n2.3 尾插&#x2F;头插尾插：将一个新节点连接到已有链表的尾部\n假设我们现在已经有了一个这样的链表，当我们需要尾插的时候，要怎么做呢？\n\n实际上，我们只需要开辟一个新的节点，并将上一个节点的next指向这个新开辟节点的地址即可！（尾插的新节点的next=NULL）\n\nvoid SListPushBack(SListNode** pphead, SLTDataType x)&#123;\tassert(pphead);\tSListNode* newnode = BuySListNode(x);\tif (*pphead == NULL)\t&#123;        //如果原链表为空，直接让头指针=新开辟的节点地址\t\t*pphead = newnode;\t&#125;\telse//原链表非空\t&#123; \t\tSListNode* tail = *pphead;\t\twhile (tail-&gt;next != NULL)\t\t&#123;   //需要先找尾\t\t\ttail = tail-&gt;next;\t\t&#125;\t\ttail-&gt;next = newnode;\t&#125;&#125;\n\n而头插就没有尾插那么麻烦了！\n我们只需要将新节点的next指向原链表的头部，再将head头指针更改为新节点的地址即可\nvoid SListPushFront(SListNode** pphead, SLTDataType x)&#123;\tassert(pphead);\tSListNode* newnode = BuySListNode(x);\tnewnode-&gt;next = *pphead;\t*pphead = newnode;&#125;\n\n细心的你应该注意到了，这里我们使用的都是二级指针pphead\n因为假设我们使用一级指针，直接传入头指针phead时，当我们需要更改该指针指向的地址时，改动只会在函数内部生效，main函数中的phead指针并没有被改变\n\n这是一个经典的函数传址和传值问题\n\n当我们需要更改phead本身时，需要传入二级指针\n\n\n2.4 尾删&#x2F;头删尾删时，需要先进行找尾。并且需要保存尾部的前一个节点的地址\nwhile(tail-&gt;next!=NULL)//会找到尾节点本身，不符合要求    //尾删应该找到尾节点的前一个while (tail-&gt;next-&gt;next != NULL)\n\n同时，我们需要想到特殊情况\n\n链表为空，无需尾删\n链表只有一个，无需找尾\n\n具体的代码实现如下\nvoid SListPopBack(SListNode** pphead)&#123;\tassert(pphead);\t\tif (*pphead==NULL)\t&#123;\t\treturn;\t&#125;\telse if((*pphead)-&gt;next==NULL)\t&#123;\t\tfree(*pphead);\t\t*pphead = NULL;\t&#125;\telse\t&#123;\t\t//有多个尾巴的情况\t\tSListNode* tail = *pphead;//找尾巴\t\twhile (tail-&gt;next-&gt;next != NULL)\t\t&#123;\t\t\ttail = tail-&gt;next;\t\t&#125;\t\tfree(tail-&gt;next);\t\ttail-&gt;next = NULL;\t&#125;\t\treturn;&#125;\n\n头删的情况依旧简单一些\n我们需要用一个变量保存头节点，再让头指针phead指向原本头节点的next，最后free掉头节点即可\nvoid SListPopFront(SListNode** pphead)&#123;\tassert(pphead);\t\tif (*pphead == NULL)\t&#123;\t\treturn;\t&#125;\telse\t&#123;\t\tSListNode* oldhead = *pphead;\t\t*pphead = (*pphead)-&gt;next;\t\tfree(oldhead);\t\toldhead = NULL;\t&#125;\treturn;&#125;\n\n\n2.5 查找&#x2F;更改查找函数需要我们在单链表中进行遍历，找到用户输入的x值，并返回它所在节点的地址\n\n查找函数并不需要更改phead指针，所以这里我们只需要传入一级指针\n\nSListNode* SListFind(SListNode* phead, SLTDataType x)&#123;\tassert(phead);\tSListNode* curt = phead;//找x的位置\twhile (curt-&gt;next != NULL)\t&#123;\t\tif (curt-&gt;data == x)\t\t&#123;\t\t\treturn curt;\t\t&#125;\t\telse\t\t&#123;\t\t\tcurt = curt-&gt;next;\t\t&#125;\t&#125;\t//找不到，返回空\treturn NULL;&#125;\n\n你可能会有一个疑惑，假设我的链表里面有多个x呢？这个函数只能返回找到的第一个x的地址\n\n很遗憾，我们并没有什么好的办法来解决这个问题。除非用户知道他想找的x的准确地址，不然是很难搞定的。\n\n实际应用中，链表的一个节点存放的并不只有一个整型x。我们可以通过其他参数进行多重判断。\n\n比如通讯录中，我们可以用名字+性别来精确查找。也可将所有找到的x都返回给用户进行选择，但那就不是本篇博客会涉及到的内容啦\n\n\n更改函数中，我们需要用户输入待更改节点的地址，和新的val\n如果用户不知道需要更改节点的地址，可以用查找函数来查找。\nvoid SListmodify(SListNode* phead, SListNode* pos, SLTDataType x)&#123;\tassert(phead);\tpos-&gt;data = x;\treturn;&#125;\n\n\n2.6 在pos位置前&#x2F;后插入除了基本的头尾增加，用户可能还需要在某一个特定节点前后进行插入，方便管理数据。这时候我们就需要灵活转变了\n\n链表不存在顺序表中的数据越界\npos位置可由find函数找到\n\n假设用户需要在pos位置之后插入，我们需要暂时断开链表，新插入一个节点后，重新链接\nvoid SListInsertAfter(SListNode** pphead, SListNode* pos, SLTDataType x)&#123;\tassert(pphead);\tassert(pos);\tSListNode* newnode = BuySListNode(x);\tSListNode* next = pos-&gt;next;//原本pos的下一位\tpos-&gt;next = newnode;//新插入的pos下一位\tnewnode-&gt;next = next;\treturn;&#125;\n\n如果是在pos之前插入，需要遍历查找pos的前一位，使用相同方法断开、插入、重连\nvoid SListInsert(SListNode** pphead, SListNode* pos, SLTDataType x)&#123;\tassert(pphead);\tassert(pos);\t\tif (pos == *pphead)\t&#123;\t\tSListPushFront(pphead, x);\t&#125;\telse\t&#123;\t\tSListNode* tail = *pphead;//找pos前一个\t\twhile (tail-&gt;next != NULL)\t\t&#123;//只写了这个情况，没有考虑pos是第一个的情况\t\t\tif (tail-&gt;next == pos)\t\t\t&#123;                 SListNode* newnode = BuySListNode(x);\t\t\t\ttail-&gt;next = newnode;\t\t\t\ttail-&gt;next-&gt;next = pos;\t\t\t\treturn;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\ttail = tail-&gt;next;\t\t\t&#125;\t\t&#125;\t&#125;\t\treturn;&#125;\n\n这里我们都传入了二级指针，因为当pos就是链表的头节点时，在pos前插入就相当于头插，可以直接调用之前写好的头插函数。\n当pos就是链表的头节点时，在其后插入相当于尾插。\n\n该函数不存在链表为空的情况，因为函数需要传入pos。空链表中没有节点，pos为空，assert断言会报错。\n\n这里我编写的功能很简单，所以需要用户严格遵守使用规定，传入一个合法的pos\n\n2.7 在pos位置删除数据说完了插入，再来说说删除\n这里提供两个函数，一个是在删除pos位置的节点，另一个是删除pos下一位的节点\n这一部分其实就是对上一步的逆向，具体的就不详细说啦（偷懒）\n\n大家如果有不懂的，可以在评论区提问~~看到了就会回复的！\n\nvoid SListErase(SListNode** pphead, SListNode** pos)&#123;\tassert(pphead);\tassert(pos);\tif (*pos == *pphead)\t&#123;//如果pos是头节点，等同于头删\t\tSListPopFront(pphead);\t&#125;\telse\t&#123;\t\tSListNode* tail = *pphead;//找pos前一个\t\twhile (tail-&gt;next != NULL)\t\t&#123;\t\t\tif (tail-&gt;next == *pos)\t\t\t&#123;\t\t\t\ttail-&gt;next = (*pos)-&gt;next;\t\t\t\tfree(*pos);//删除后main函数传过来的pos位置已被free\t\t\t\t*pos = NULL;//*pos置空，此时main函数中的pos也被置空\t\t\t\tpos = NULL;\t\t\t\treturn;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\ttail = tail-&gt;next;\t\t\t&#125;\t\t&#125;\t&#125;\treturn;&#125;void SListEraseAfter(SListNode** pphead, SListNode* pos)&#123;\tassert(pphead);\tassert(pos);\tSListNode* next = pos-&gt;next-&gt;next;\tfree(pos-&gt;next);\tpos-&gt;next = next;\treturn;&#125;\n\n2.8 打印链表打印的时候可以打印出-&gt;箭头，方便我们查看链表的结构\nvoid SListPrint(SListNode* phead)&#123;\tSListNode* cur = phead;\twhile (cur != NULL)\t&#123;\t\tprintf(&quot;%d-&gt;&quot;, cur-&gt;data);\t\tcur = cur-&gt;next;\t&#125;\tprintf(&quot;NULL\\n&quot;);&#125;\n\n2.9 销毁链表对于顺序表来说，销毁链表只需要free掉顺序表中指向堆区空间的指针\n但对于链表来说，我们需要一步一步进行释放操作，并在释放完毕后将头指针置空\n\n如果该链表有头节点，则还需将头节点一并置空\n\nvoid SListDestroy(SListNode** pphead)&#123;\tassert(pphead);\tSListNode* curt = *pphead;\twhile (curt)\t&#123;\t\tSListNode* next = curt-&gt;next;\t\tfree(curt);\t\tcurt = next;\t&#125;\t*pphead = NULL;\treturn ;&#125;\n\n\n3.测试这一次，我依旧使用了多文件编程的方法来敲单链表的代码\n这样的好处在于，别人只需要看你的.h头文件，就能清楚的知道你这个项目大概实现了什么样的功能，就好比一篇文章的大纲一样。对于后续的项目实战来说，是非常重要的编程能力积累\n\n测试一下我们的代码，可以看到，所有函数的功能都能正常实现！\n\n\n结语🤳学习完单链表后，我开始接触了一些链表的oj题目，不得不说，链表这部分的题目，难度还是比之前C语言的时候练习的题目更大的！有很多题目都需要我们融会贯通之前的知识。\n最重要的是通读代码和调试的能力，这样才能更好地编写出算法\n\n如果这篇博客对你有帮助，还请点个👍，万分感谢！\n\n有什么问题的话，大家可以在评论区提出哦\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","链表"]},{"title":"【C语言】带你刷爆十道链表OJ","url":"/2022/03/24/code/note_data_structure/4%E9%93%BE%E8%A1%A8OJ%E9%A2%98/","content":"[TOC]\n前言，CSDN的小问题😥最近写博客的时候，发现CSDN的markdown语法不支持加粗一句话末尾的标点符号\n**你好呀，****你好呀**，\n\n这两种方式在typora上都会加粗（包括末尾的标点）\n但是在CSDN上，第一种情况会显示出markdown源码，无法加粗\n\n你好呀，我是你的好朋友你好呀，我是你的好朋友\n\n虽然这不是什么大事，但有的时候写博客，一句本来应该是加粗的话，多显示了几个**，不太美观，还会给不了解markdown的读者带来困扰：“作者在这里打几个*号是干嘛？”\n\n上一篇博客，我们学习了单向无头非循环链表，本篇博客就让我们实践一下，刷十道leetcode的链表OJ题目吧🌭\n如果你把本篇博客里的这几道题都弄明白了，那说明你对链表的掌握已经非常棒了！加油！\n话不多说，直接进入今天的正题！\n第一题：206.反转链表\nleetcode：206. 反转链表\n\n题目需要我们把1-2-3-4-5的链表反转为5-4-3-2-1的链表\n\n有一种取巧的办法，是将所有数取出来放入一个数组，再倒着将数组里面的数放回去\n这种办法可以通过OJ，因为leetcode并没有检查返回链表的地址。但并不符合题目的真正要求\n\nstruct ListNode* reverseList(struct ListNode* head)&#123;    struct ListNode* newhead=NULL;    struct ListNode* cur=head;    while(cur)    &#123;        struct ListNode* next=cur-&gt;next;        cur-&gt;next=newhead;        newhead=cur;        cur=next;    &#125;    return newhead;&#125;\n\n\n\n第二题：876.链表的中间节点\nLeetCode： 876. 链表的中间结点\n\n\n这道题目需要我们返回单链表的中间节点\n如果链表节点个数是奇数，返回中间节点；\n如果链表节点个数是偶数，返回第二个节点。\n\n对于数组和顺序表来说，我们只需要利用下标直接访问中间节点即可\n对于单链表来说，我们不知道它究竟有多少个节点，即便知道了，也需要通过遍历的方法找到这个中间节点\n\n\n这道题我想出了两种解题方式\n解法一：遍历通过遍历得出该链表的节点个数，再使用一个新的指针，查找中间节点\nstruct ListNode* middleNode(struct ListNode* head)&#123;    if(head==NULL)        return NULL;    int count=1;//计算链表一共的节点数    struct ListNode* tail=head;//找尾    while(tail-&gt;next!=NULL)    &#123;        tail=tail-&gt;next;        count++;    &#125;    int half=(count/2);     //如果是3结果为1，如果是4结果为2    //正好是从head开始寻找的次数    struct ListNode* mid =head;    while((mid-&gt;next!=NULL)&amp;&amp;(half--))    &#123;        mid=mid-&gt;next;    &#125;    return mid;&#125;\n\n对于链表oj题目，leetcode会把这个链表的形式以注释的方式标注在最前面\n\n解法二：快慢指针（很爽👍）\n这种方法实现起来也很是简洁，也击败了更多用户！\nstruct ListNode* middleNode(struct ListNode* head)&#123;    if(head==NULL)        return NULL;    struct ListNode*fast=head;    struct ListNode*slow=head;    while(fast&amp;&amp;fast-&gt;next)    &#123;        fast=fast-&gt;next-&gt;next;        slow=slow-&gt;next;    &#125;    return slow;&#125;\n\n\n\n第三题：OR36 链表的回文结构👨‍🔧\n牛客网：OR36 链表的回文结构\n\n\n这道题我们可以使用一个很特别的方法\n\n先找到这串链表的中间节点（可以用到876里的函数）\n\n再将这个节点之后的链表逆置（206反转链表）\n\n\n1-2-3-2-1//逆置后1-2-1-2-3\n\n需要注意的是，逆置函数并不会改变第一个2的next节点，它依旧是链接在3上的\n//进行遍历判断1-2-(3)1-2-3\n\n这样我们就能判断出该链表是否为回文结构了！\n\n开始敲代码，发现牛客网上只有C++的选项，没有C语言\n\n实际上，C++编译器都是支持C语言的，我们可以直接在题目给出的C++结构下进行C语言代码的编写\n\n题目要求的返回值是一个bool类型。如果你不了解它，布尔类型是C99引入的，简单的来说，ture代表1，false代表0\n\n在之前的博客中我写到过这个类型👉点我\n\n\nclass PalindromeList &#123;public:    //链表逆置    struct ListNode* reverseList(struct ListNode* head) &#123;        struct ListNode* newhead = NULL;        struct ListNode* cur = head;        while (cur)        &#123;            struct ListNode* next = cur-&gt;next;            cur-&gt;next = newhead;            newhead = cur;            cur = next;        &#125;        return newhead;    &#125;    //中间节点返回    //1 2 3 4  偶数个，返回3    //1 2 3    奇数个，返回2    struct ListNode* middleNode(struct ListNode* head) &#123;        if (head == NULL)            return NULL;        int count = 1;//计算链表一共的节点数        struct ListNode* tail = head;//找尾        while (tail-&gt;next != NULL)        &#123;            tail = tail-&gt;next;            count++;        &#125;        int half = (count / 2);        //如果是3结果为1，如果是4结果为2        //正好是需要从head开始寻找的次数        struct ListNode* mid = head;        while ((mid-&gt;next != NULL) &amp;&amp; (half--))        &#123;            mid = mid-&gt;next;        &#125;        return mid;    &#125;    bool chkPalindrome(ListNode* A) &#123;        struct ListNode* mid = middleNode(A);        struct ListNode* ret = reverseList(mid);        //1 2 3 2 1 回文链表        //先逆转后面3个        //1 2 1 2 3        //这时候第一个2存放的next依旧是下一个3的地址        //使用while循环进行判断，都是判断3次是否相等        //相等就是回文，否则不是        while (A &amp;&amp; ret)        &#123;            if (A-&gt;val == ret-&gt;val)            &#123;                A = A-&gt;next;                ret = ret-&gt;next;            &#125;            else            &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n\n\n第四题：链表中倒数第K个节点\n牛客网：链表中倒数第k个结点\n\n\n这道题我们同样可以使用快慢指针来解决\n倒数第k个节点，就需要快指针先走k步\n\n这里我尝试用PS做了一个动图，给大伙瞅瞅\n\n\n这道题也是只有C++选项。和上道题一样，我们直接在C++下编写C语言代码就可以了\nclass Solution &#123;public:    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;        if (pListHead == NULL)            return NULL;                struct ListNode* fast = pListHead;        struct ListNode* slow = pListHead;        int i = k;        while (i--)        &#123;            if (fast == NULL)            &#123;                return NULL;            &#125;            fast = fast-&gt;next;        &#125;        while (fast)        &#123;            fast = fast-&gt;next;            slow = slow-&gt;next;        &#125;        return slow;    &#125;&#125;;\n\n\n\n第五题：CM11 链表分割\n牛客网：CM11 链表分割\n\n\n这道题我使用了带头节点的做法，head-&gt;next等同于不带头链表的head指针\nclass Partition &#123;public:    ListNode* partition(ListNode* pHead, int x) &#123;    if(pHead==NULL)        return NULL;            struct ListNode* newhead=(struct ListNode*)malloc(sizeof(struct ListNode));//新链表-比x小的部分    struct ListNode* Bigger=(struct ListNode*)malloc(sizeof(struct ListNode));//比x大的部分            //这里需要定义一个新的指针来遍历链表，防止找不到头    struct ListNode* head=newhead;    struct ListNode* big=Bigger;        while(pHead)    &#123;//遍历里面比x小的，链接在newhead上        if(pHead-&gt;val  &lt;x)        &#123;            head-&gt;next=pHead;            pHead=pHead-&gt;next;            head=head-&gt;next;                    &#125;        else        &#123;//比x大的链接在bigger上            big-&gt;next=pHead;            pHead=pHead-&gt;next;            big=big-&gt;next;        &#125;    &#125;    big-&gt;next=NULL;//big的末尾需要置空    head-&gt;next=Bigger-&gt;next;//让head的末尾链接bigger的头部            struct ListNode* list=newhead-&gt;next;    free(newhead);    free(Bigger);    return list;    &#125;&#125;;\n\n\n第六题：21. 合并两个有序链表\nleetcode：21. 合并两个有序链表\n\n\n这道题的解析就放注释啦\nstruct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)&#123;    if(list1==NULL)        return list2;    if(list2==NULL)        return list1;    struct ListNode* H1=list1;    struct ListNode* H2=list2;    struct ListNode* newList=NULL;    struct ListNode* tail=NULL;    if(H1-&gt;val&lt;H2-&gt;val)//选取新链表的第一个节点    &#123;        newList=H1;        tail=H1;        H1=H1-&gt;next;    &#125;    else    &#123;        newList=H2;        tail=H2;        H2=H2-&gt;next;    &#125;    while(H1 &amp;&amp; H2)//其中一个走完了，就退出循环    &#123;        if(H1-&gt;val&lt;H2-&gt;val)//找小的那一个链接在尾部        &#123;            tail-&gt;next=H1;            tail=H1;//等同于tail=tail-&gt;next            H1=H1-&gt;next;        &#125;        else        &#123;            tail-&gt;next=H2;            tail=H2;//等同于tail=tail-&gt;next            H2=H2-&gt;next;        &#125;    &#125;//最后结束了，还需要判断是谁走完了，把另外一个链表剩下的部分链接在尾部//链表本身是有序的，所以最后无需再进行排序，直接链接即可    if(H1)        tail-&gt;next=H1;    if(H2)        tail-&gt;next=H2;        return newList;&#125;\n\n\n\n第七题：160.相交链表\nleetcode：160. 相交链表\n\n\n题目需要我们返回两个相交链表的交点c1，如果不相交就返回NULL。\n最后一行还提到了，这道题不能破坏原始链表\n\n本题思路如下：\n\n先用两个指针，分别遍历A、B链表，得到两个链表长度\n遍历完毕时，指针处在末尾C3，如果末尾不相等，就说明该链表不相交，返回NULL\n如果相等，计算出A、B链表的长度差，使用快慢指针进行操作\n快指针从长链表开始走，先走|A-B|长度。然后慢指针也开始移动，直到它们相交\n\n\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;    if((headA==NULL)||(headB==NULL))        return NULL;    int countA=1;    int countB=1;    struct ListNode *HA=headA;    struct ListNode *HB=headB;    while(HA&amp;&amp;HA-&gt;next)    &#123;        countA++;        HA=HA-&gt;next;    &#125;    while(HB&amp;&amp;HB-&gt;next)    &#123;        countB++;        HB=HB-&gt;next;    &#125;    if(HB!=HA)//结尾不相等，说明不相交        return NULL;    int num=abs(countA-countB);    struct ListNode* fast=NULL;    struct ListNode* slow=NULL;    if(countA&gt;countB)    &#123;        fast=headA;        slow=headB;    &#125;    else    &#123;        fast=headB;        slow=headA;    &#125;    while(num--)//fast先走    &#123;        fast=fast-&gt;next;    &#125;    while(fast&amp;&amp;slow)    &#123;        if(fast==slow)            return fast;        fast=fast-&gt;next;        slow=slow-&gt;next;    &#125;    return NULL;&#125;\n\n\n\n第八题：141.环形链表\nleetcode：141. 环形链表\n\n\n本题只需要我们判断该链表是否有环，我们同样使用快慢指针，快指针的速度是慢指针的两倍，进环以后，快指针能追上后来的慢指针，即该链表带环。\n\n如果快指针遇到了NULL，即该链表不带环\n\n题目需要返回bool类型，前面已经提到过了~\n\nbool hasCycle(struct ListNode *head) &#123;    if(head==NULL)        return false;        struct ListNode * slow=head;    struct ListNode * fast=head;    struct ListNode * meet=NULL;    while(fast &amp;&amp; fast-&gt;next)    &#123;        fast=fast-&gt;next-&gt;next;        slow=slow-&gt;next;        if(fast==slow)        &#123;            return true;        &#125;    &#125;    return false;    &#125;\n\n\n特殊情况：追不上\n这里有一个附加的思考问题：fast指针比slow走得快，它们就一定能追上吗？\n\n\n第九题：142.环形链表Ⅱ（较难😰）\nleetcode：142. 环形链表 II\n\n这道题比上一道多了一个要求，需要我们返回链表环形的开始节点\n\n示例1里的开始节点为2（下标为1）\n示例2里的开始节点为1（下标为0）\n\n\n\n题目分析这时候，单纯用快慢指针已经不行了，我们还需要想办法找到环的起始节点\n\n标出长度，直线部分为L，我们并不知道meet究竟在环的哪一个部分，设环的起点b到meet的长度为X（这里要注意先后顺序，避免搞混，见下图）\n\n假设有两个指针，一个head从链表的开头a开始走，一个从meet开始走\n它们一定会在b点相交！\n\n从meet开始走的指针，在环里走N*C-X的长度来到b\n从a开始的指针，走L长度来到b\n\n在上一道相交题目中，fast指针走了L+N*C+X的距离，slow指针走了L+X\n本题中，meet指针和head指针是同速的，即L=N*C-X\n\n分解一下这个表达式，L=(N-1)*C+(C-X)\n你会发现，C-X不就是meet到b的距离吗？\n转换为文字说明，即meet指针走C-X的长度来到b点，再走N-1圈与head相遇！\n敲代码分析到这里，我们就可以开始敲代码了~\nstruct ListNode *detectCycle(struct ListNode *head) &#123;    if (head == NULL)        return NULL;    struct ListNode* slow = head;    struct ListNode* fast = head;    struct ListNode* meet = NULL;    while (fast &amp;&amp; fast-&gt;next)    &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        if (fast == slow)        &#123;            meet=fast;//寻找相交点            break;        &#125;    &#125;    if((fast==NULL)|| (fast-&gt;next==NULL))        return NULL;//如果fast是遇到空退出循环的，说明不带环    while(1)    &#123;        if(head==meet)//相遇点即为环的起点             return meet;                meet=meet-&gt;next;        head=head-&gt;next;    &#125;    return NULL;&#125;\n\n\n第十题：138.复制带随机指针的链表（很难😱）\nLeetCode：138. 复制带随机指针的链表\n\n众所周知，当leetcode给一道题标出“中等”的时候，我这种菜🐕就要写N久，所以对于我来说，简单&#x3D;有难度，中等&#x3D;非常难。\n本题较难的地方不在于复制链表，而在于处理新链表的random指针\n\n解法一：用计数器找到对应位置\n这个方法的缺点是，每一个节点都需要两次遍历，第一次计数，第二次是在新的链表中查找，时间复杂度是O(N^2^)\n不过本题并没有对时间复杂度做出要求，所以这个方法肯定也是没问题的！\n\n重点来瞅瞅这个非常女少的解法二\n解法二：先复制后断开(๑•̀ㅂ•́)و✧这个解法的思路是，先在原链表的每一个节点之后插入一个和它相同的新节点\n\n再利用两个指针进行random的查找\n\n第一个7的random是空，我们直接给新的7random置空\n第二个13的random指向前一位7，新13的random指向原13random的下一位，即新开辟的7\n第三个11的random指向1，新11的random指向原链表1的下一位，即新的1\n\n这样一一对应，就能在新开辟的链表中找到对应的random！\n\n最后，我们需要做的，就是将新开辟的节点从原链表断开，重新链接成新的链表\n怎么样，是不是直接一个“妙”就跑出来了？\n\n\n本题并没有要求不改变原链表，但我们最好还是把原链表还原成初始状态\n\n直接上手敲代码，啪啪啪，一提交，执行出错！\n\n\n仔细找了找，发现是第三个板块最后处理末尾的NULL指针时会出现问题\n\n最后的代码如下！\nstruct Node* copyRandomList(struct Node* head) &#123;\tif(head==NULL)        return NULL;    //1.复制原链表    struct Node*HAED=head;//记录头节点    while(head)//将新链表的每个节点链接在原链表之后    &#123;        struct Node* newnode=(struct Node*)malloc(sizeof(struct Node));        newnode-&gt;val=head-&gt;val;        newnode-&gt;next=head-&gt;next;        head-&gt;next=newnode;        head=head-&gt;next-&gt;next;    &#125;    //2.链接新链表的random    struct Node* old=HAED;    while(old)    &#123;        struct Node* new=old-&gt;next;        if(old-&gt;random==NULL)            new-&gt;random=NULL;        else            new-&gt;random=old-&gt;random-&gt;next;        old=old-&gt;next-&gt;next;    &#125;    //3.将新链表解下来    struct Node* ret=HAED-&gt;next;//记录最后的返回链表    struct Node* oldlist=HAED;    while(oldlist)    &#123;        struct Node*copy=oldlist-&gt;next;        struct Node*next=copy-&gt;next;                oldlist-&gt;next=next;        if(copy-&gt;next==NULL)            copy-&gt;next=NULL;        else            copy-&gt;next=next-&gt;next;        oldlist=next;    &#125;     return ret;&#125;\n\n也就执行出错了十几次就找到错误了……问题不大（阿巴阿巴）\n\n\n结语💪刷完这些题，有没有觉得自己对链表的理解直接更上一层楼？\n\n如果大家对某道题有问题，或者有我没有说清楚的地方，可以在评论区提出来哦！\n","categories":["数据结构太复杂"],"tags":["OJ刷题","C语言","数据结构","链表"]},{"title":"【C语言】双向带头循环链表","url":"/2022/03/28/code/note_data_structure/5%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","content":"[TOC]\n前言在之前的数据结构学习中，我们学习了顺序表、链表这两种结构\n\n顺序表：博客链接1\n单链表：博客链接2\n链表OJ：博客链接3\n\n之前本来是不想写双链表的博客的，但是看着自己的数据结构专栏少了一part，有强迫症的我感觉很不爽，于是补上了本篇大水文\n1.双链表的结构除了单链表以外，还有一个结构，是双向带头循环链表。这个链表的形式如下\n\n头节点的prev指向尾部节点\n尾节点的next指向头节点，构成循环\n\n\n别看它的形式有些复杂，实际代码的实现，比单链表还简单！\n因为head-&gt;prev指向了尾节点，所以不需要找尾。尾删的时候也不需要遍历找尾节点的前一位，因为尾节点的prev就存放了前一位的地址。\n\n2.代码实现下面贴出双链表实现的源码，如果大家有问题，可以在评论区提出\n只要你学会了单链表的编写，也看完了我的链表OJ题博客，那双链表对于你来说肯定是信手拈来的\n\n2.1头文件DoubleList.h头文件\n如果你想尝试自己编写双链表的代码，可以先把头文件复制到你的本地编译器，将这些函数的实现搞出来\n#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;// 带头+双向+循环链表增删查改实现typedef int LTDataType;typedef struct ListNode&#123;\tLTDataType data;\tstruct ListNode* next;\tstruct ListNode* prev;&#125;ListNode;// 创建并返回链表的头结点ListNode* ListCreate();// 双向链表销毁void ListDestory(ListNode* pHead);// 双向链表打印void ListPrint(ListNode* pHead);//倒着打印，检查双链表是否完整void ListPrintReverse(ListNode* pHead);// 创建新的节点ListNode* BuyNode(LTDataType x);// 双向链表尾插void ListPushBack(ListNode* pHead, LTDataType x);// 双向链表尾删void ListPopBack(ListNode* pHead);// 双向链表头插void ListPushFront(ListNode* pHead, LTDataType x);// 双向链表头删void ListPopFront(ListNode* pHead);// 双向链表查找ListNode* ListFind(ListNode* pHead, LTDataType x);// 双向链表在pos的前面进行插入void ListInsert(ListNode* pos, LTDataType x);// 双向链表删除pos位置的节点void ListErase(ListNode* pos);\n\n2.2源文件DoubleList.c源文件\n还是建议你写完之后再来和我的函数对比对比。\n一定要记住：写完一个模块，测试一个模块，不要等到最后再测试！\n#define _CRT_SECURE_NO_WARNINGS 1#include &quot;DoubleList.h&quot;ListNode* ListCreate()&#123;\tListNode* Createnode = (ListNode*)malloc(sizeof(ListNode));\tif (Createnode == NULL)\t\tprintf(&quot;CreateNode failed\\n&quot;);\telse\t&#123;\t\tCreatenode-&gt;next = Createnode;\t\tCreatenode-&gt;prev = Createnode;\t&#125;\treturn Createnode;&#125;void ListDestory(ListNode* pHead)&#123;\tassert(pHead);\twhile (pHead-&gt;prev!=pHead)\t&#123;\t\tListNode* tail = pHead-&gt;prev;\t\tListNode* tailprev = tail-&gt;prev;\t\tfree(tail);\t\tpHead-&gt;prev = tailprev;\t&#125;\tfree(pHead);&#125;void ListPrint(ListNode* pHead)&#123;\tassert(pHead);\t\tListNode* cur = pHead-&gt;next;\twhile (cur-&gt;next!=pHead)\t&#123;\t\tprintf(&quot;%d -&gt; &quot;,cur-&gt;data);\t\tcur = cur-&gt;next;\t&#125;\tprintf(&quot;%d&quot;, cur-&gt;data);//打印最后一个节点\tprintf(&quot;\\n&quot;);&#125;void ListPrintReverse(ListNode* pHead)&#123;\tassert(pHead);\tListNode* tail = pHead-&gt;prev;\twhile (tail-&gt;prev != pHead)\t&#123;\t\tprintf(&quot;%d -&gt; &quot;, tail-&gt;data);\t\ttail = tail-&gt;prev;\t&#125;\tprintf(&quot;%d&quot;, tail-&gt;data);\tprintf(&quot;\\n\\n&quot;);\t&#125;ListNode* BuyNode(LTDataType x)&#123;\tListNode* Buy = (ListNode*)malloc(sizeof(ListNode));\tif (Buy == NULL)\t\tprintf(&quot;BuyNode failed\\n&quot;);\telse\t&#123;\t\tBuy-&gt;data = x;\t\tBuy-&gt;next = NULL;\t\tBuy-&gt;prev = NULL;\t&#125;\treturn Buy;&#125;void ListPushBack(ListNode* pHead, LTDataType x)&#123;\tassert(pHead);\tListNode* newnode = BuyNode(x);\tListNode* tail = pHead-&gt;prev;\ttail-&gt;next = newnode;\tnewnode-&gt;next = pHead;\tnewnode-&gt;prev = tail;\tpHead-&gt;prev = newnode;&#125;void ListPopBack(ListNode* pHead)&#123;\tassert(pHead);\tListNode* tail = pHead-&gt;prev;\tListNode* tailprev = tail-&gt;prev;\tfree(tail);\ttailprev-&gt;next = pHead;\tpHead-&gt;prev = tailprev;&#125;void ListPushFront(ListNode* pHead, LTDataType x)&#123;\tassert(pHead);\tListNode* newnode= BuyNode(x);\tnewnode-&gt;prev = pHead;\tnewnode-&gt;next = pHead-&gt;next;\tpHead-&gt;next = newnode;\tnewnode-&gt;next-&gt;prev = newnode;&#125;void ListPopFront(ListNode* pHead)&#123;\tassert(pHead);\tListNode* front = pHead-&gt;next-&gt;next;\tListNode* Popnode = pHead-&gt;next;//待爆破的头节点\tpHead-&gt;next = front;\tfree(Popnode);\tfront-&gt;prev = pHead;&#125;ListNode* ListFind(ListNode* pHead, LTDataType x)&#123;\tassert(pHead);\tListNode* cur = pHead-&gt;next;\twhile (cur!=pHead)\t&#123;\t\tif (cur-&gt;data == x)\t\t\treturn cur;\t\telse\t\t\tcur = cur-&gt;next;\t&#125;\treturn NULL;&#125;void ListInsert(ListNode* pos, LTDataType x)&#123;\tassert(pos);\tListNode* newnode = BuyNode(x);\tListNode* Prev = pos-&gt;prev;\tPrev-&gt;next = newnode;\tnewnode-&gt;prev = Prev;\tnewnode-&gt;next = pos;\tpos-&gt;prev = newnode;&#125;void ListErase(ListNode* pos)&#123;\tassert(pos);\tListNode* Prev = pos-&gt;prev;\tListNode* Next = pos-&gt;next;\tPrev-&gt;next = pos-&gt;next;\tNext-&gt;prev = Prev;\tfree(pos);&#125;\n\n测试文件test.c这里不再给出\n结语如果你对上面的代码有问题，欢迎在评论区提出！\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n一起向前！\n\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","链表"]},{"title":"【C语言】数据结构-栈（详解）","url":"/2022/03/30/code/note_data_structure/6%E6%A0%88/","content":"[TOC]\n前言在之前的数据结构学习中，我们学习了顺序表、链表这两种结构\n\n顺序表：博客链接1\n单链表：博客链接2\n链表OJ：博客链接3\n\n除了单链表以外，还有一个结构，是双向带头循环链表。这个链表的形式如下\n\n头节点的prev指向尾部节点\n尾节点的next指向头节点，构成循环\n\n\n别看它的形式有些复杂，实际代码的实现，比单链表还简单！\n因为head-&gt;prev指向了尾节点，所以不需要找尾。尾删的时候也不需要遍历找尾节点的前一位，因为尾节点的prev就存放了前一位的地址。\n所以这里就偷懒不写博客了！反正也没啥人看😭\n\n好吧，最后我还是写了一篇水文👉点我\n\n\n本篇博客讲述的是另外一个特别的线性表，栈\n1.什么是栈数据结构里的栈，和函数栈帧中的“栈”有一定相似，但实际上它们完全不同\n栈作为一个特殊的线性表，它只允许在表的一头添加、删除数据。\n所有的数据都遵循先进后出，后进先出的原则\n\n压栈：栈的插入操作叫做进栈&#x2F;压栈&#x2F;入栈，新的数据存放在栈顶\n出栈：栈的删除操作，先删除栈顶的数据\n\n\n2.栈的实现栈可以用数组或者链表来实现，相对而言，数组的方法更优\n因为数组在尾插数据的时候，可以很方便的找到尾。而单链表需要遍历找尾，耗时较长。\n\n是不是有些似曾相识呢？没错，实际上栈区就是一个只能尾插+尾删的顺序表\n3.敲代码！3.1头文件先用头文件写好咱们的大纲，然后在来一一实现这些代码\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;stdbool.h&gt;// 支持动态增长的栈typedef int STDataType;typedef struct Stack&#123;\tSTDataType* a;\tint top; // 栈顶\tint capacity; // 容量&#125;Stack;// 初始化栈void StackInit(Stack* ps);// 销毁栈void StackDestroy(Stack* ps);// 入栈void StackPush(Stack* ps, STDataType data);// 出栈void StackPop(Stack* ps);// 获取栈顶元素STDataType StackTop(Stack* ps);// 获取栈中有效元素个数int StackSize(Stack* ps);// 检测栈是否为空，如果为空返回false，如果不为空返回truebool StackEmpty(Stack* ps);//打印void StackPrint(Stack* ps);\n\n和顺序表不同的是，我们需要写一个单独的函数来获取栈顶元素，这一点在很多OJ题目中都需要用到。\n3.2函数实现如果你看过了我之前顺序表的博客，这部分对你来说想必不难。\n\n如果有什么问题，欢迎在评论区提出！\n\n#include&quot;Stack.h&quot;// 初始化void StackInit(Stack* ps)&#123;\tSTDataType* new = (STDataType*)malloc(4*sizeof(STDataType) );\tif (new == NULL)\t\texit(-1);\telse\t&#123;\t\tps-&gt;a = new;\t\tps-&gt;top = 0;\t\tps-&gt;capacity = 4;\t&#125;&#125;// 销毁栈void StackDestroy(Stack* ps)&#123;\tassert(ps);\tfree(ps-&gt;a);\tps-&gt;a = NULL;\tps-&gt;capacity = 0;\tps-&gt;top = 0;&#125;// 入栈void StackPush(Stack* ps, STDataType data)&#123;\tassert(ps);\tif (ps-&gt;top == ps-&gt;capacity)//容量检查\t&#123;\t\tSTDataType* new = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * (ps-&gt;capacity) * 2);\t\tif (new == NULL)\t\t&#123;\t\t\texit(-1);\t\t&#125;\t\telse\t\t&#123;\t\t\tps-&gt;a = new;\t\t\tps-&gt;capacity *= 2;\t\t&#125;\t&#125;\tps-&gt;a[ps-&gt;top] = data;\tps-&gt;top++;&#125;// 出栈void StackPop(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top &gt; 0)\t\t(ps-&gt;top)--;&#125;// 获取栈顶元素STDataType StackTop(Stack* ps)&#123;\tassert(ps);\tassert(ps-&gt;top &gt; 0);\treturn ps-&gt;a[ps-&gt;top - 1];&#125;// 获取栈中有效元素个数int StackSize(Stack* ps)&#123;\tassert(ps);\treturn ps-&gt;top;&#125;// 检测栈是否为空，如果为空返回true，如果不为空返回falsebool StackEmpty(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top == 0)\t\treturn true;\telse\t\treturn false;&#125;void StackPrint(Stack* ps)&#123;\tassert(ps);\tint n = ps-&gt;top;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tprintf(&quot;%d &quot;, ps-&gt;a[i]);\t&#125;\tprintf(&quot;\\n&quot;);&#125;\n\n大家在自己编写这种带多个板块的代码的时候，一定要一个板块写完就检查一遍！不要将问题都丢一块解决，那样会非常难受的！\n\n在其他版块都确认无误之后，也要过来瞅一眼Destroy板块，避免出现free错误等情况。\n这个板块我们可以通过打断点（VS快捷键F9）并调试的方法来检查该板块是否正确\n\n4.知识巩固，来道OJ！leetcode 20 有效的括号\nleetcode：20. 有效的括号\n\n\n这道题就是一道非常使用用栈来解决的OJ题\n题目要求我们判断给出的字符串中，括号是否一一对应\n&#123;[]&#125;//对应&#123;[(])&#125;//不对应&#123;&#123;()&#125;//少了一个右边括号，不对应\n\n具体要怎么做呢？思路如下：\n\n用一个指针来遍历字符串，如果是左括号&#123;([其中一个，就入栈\n如果是右边括号，说明左括号已经入栈完毕，开始比对\n栈顶的括号一定是和当前右括号匹配的，如果不是则为false\n每判断一次，就让栈顶的左括号出栈一次\n\n最后的函数实现如下\n\n需要注意的是，STDataType类型需要更改为char类型，此时存放的是括号字符，并不是数字\n\ntypedef char STDataType;typedef struct Stack&#123;\tSTDataType* a;\tint top; // 栈顶\tint capacity; // 容量&#125;Stack;// 初始化void StackInit(Stack* ps)&#123;\tSTDataType* new = (STDataType*)malloc(sizeof(STDataType) * 4);\tif (new == NULL)\t&#123;\t\texit(-1);\t&#125;\telse\t&#123;\t\tps-&gt;a = new;\t\tps-&gt;top = 0;\t\tps-&gt;capacity = 4;\t&#125;&#125;// 销毁栈void StackDestroy(Stack* ps)&#123;\tassert(ps);\tfree(ps-&gt;a);\tps-&gt;a = NULL;\tps-&gt;capacity = 0;\tps-&gt;top = 0;&#125;// 入栈void StackPush(Stack* ps, STDataType data)&#123;\tassert(ps);\tif (ps-&gt;top == ps-&gt;capacity)\t&#123;\t\tSTDataType* new = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * (ps-&gt;capacity) * 2);\t\tif (new == NULL)\t\t&#123;\t\t\texit(-1);\t\t&#125;\t\telse\t\t&#123;\t\t\tps-&gt;a = new;\t\t\tps-&gt;capacity *= 2;\t\t&#125;\t&#125;\tps-&gt;a[ps-&gt;top] = data;\tps-&gt;top++;&#125;// 出栈void StackPop(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top &gt; 0)\t\t(ps-&gt;top)--;&#125;// 获取栈顶元素STDataType StackTop(Stack* ps)&#123;\tassert(ps);\tassert(ps-&gt;top &gt; 0);\treturn ps-&gt;a[ps-&gt;top - 1];&#125;// 检测栈是否为空，如果为空返回true，如果不为空返回falsebool StackEmpty(Stack* ps)&#123;\tassert(ps);\tif (ps-&gt;top == 0)\t\treturn true;\telse\t\treturn false;&#125;bool isValid(char * s)&#123;    Stack st;    StackInit(&amp;st);    while(*s)    &#123;        if(*s==&#x27;&#123;&#x27;||*s==&#x27;[&#x27;||*s==&#x27;(&#x27;)        &#123;            StackPush(&amp;st,*s);            s++;        &#125;        else        &#123;            if(StackEmpty(&amp;st))            &#123;                return false;            &#125;            char top=StackTop(&amp;st);//取栈顶元素            StackPop(&amp;st);//把栈顶删除            //如( &#123; 这两个，取了栈顶&#123;，就立马pop掉它            if((*s==&#x27;&#125;&#x27;&amp;&amp;top==&#x27;&#123;&#x27;)            ||(*s==&#x27;)&#x27;&amp;&amp;top==&#x27;(&#x27;)            ||(*s==&#x27;]&#x27;&amp;&amp;top==&#x27;[&#x27;))            &#123;                s++;            &#125;            else            &#123;                StackDestroy(&amp;st);                return false;            &#125;        &#125;    &#125;    bool ret=StackEmpty(&amp;st);    //如果为空，说明匹配完毕；非空说明还有剩下的左括号    StackDestroy(&amp;st);        return ret;&#125;\n\n这个算法的用时还是非常短的！\n\n结语数据结构学到这里，其实在了解完这些结构的真正思路后，代码的实现反而并不是那么重要。\n在学习这部分知识的时候，一定要多画图！\n如果你不适应用鼠标画图，可以直接用纸笔画，一些非常简单的草图，也能极大帮助我们理解当前的代码，找出问题👍\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","栈"]},{"title":"【C语言】三道例题让你彻底学会栈和队列","url":"/2022/03/30/code/note_data_structure/7%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97OJ%E9%A2%98/","content":"[TOC]\n前言本篇博客，将带着大家刷3道非常经典的OJ题。它们并不算特别难，但对我们理解数据结构中栈和队列的概念有很大的帮助。\n\n如果你还不了解栈，可以看看我之前的博客👉点我\n队列的博客就不写啦，本篇刷题的时候会提到队列的操作\n\n话不多说，直接开始吧！\n\n1.用队列实现栈\nleetcode：225. 用队列实现栈\n\n\n这道题的要求很简单，用两个队列来模拟栈的实现。\n我们知道，队列的操作是从后进，从前出，这就和我们在餐厅排队一样，先进入餐厅排队的人先得到座位。\n而栈是遵循上进上出的，即栈只能在栈顶插入元素和删除元素\n两个队列要如何结合，才能实现栈的要求呢？\n1.1思路首先我们讲数据push到其中一个队列中\n\n如果要访问此时的栈顶，使用队列中的tail尾指针来访问，即题目要求的TOP函数\n当我们需要pop数据的时候，将队列中的N-1个数据全部移动到另外一个队列里，再将最后的栈顶数据删除并返回\n\n最终的目的就是保证一个队列为空，另外一个队列保存数据\n\n\n这样就达成了栈只能在栈顶删除数据的要求\n最后还有一个函数是boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n当两个队列中都没有数据的时候，这个模拟的栈就是空的；\n只要其中一个队列有数据的时候，就代表这个栈是有数据的。\n\n1.2队列的代码你可能会注意到，这道题中并没有给我们初始的队列代码，也就是说我们需要“造轮子”，将自己写的C语言队列代码放在前头\n\n这也是C语言在写一些OJ题目时不方便的原因\n\n\n这里我贴出一个队列的代码，大家可以复制到自己的编译器上测试一下。\n如果有不理解的地方，可以在评论区提出！\n\n和栈的代码实现不同，队列使用链表的方式更加方便。其相当于一个只能尾插和头删的单链表\n为了方便我们找尾进行尾插，这里定义了另外一个结构体类型Queue，其中tail指针指向链表的尾部，方便尾插（否则每次尾插都需要遍历）\n\ntypedef int QDataType;typedef struct QueueNode{\tQDataType data;\tstruct QueueNode* next;}QNode;typedef struct Queue{//这个结构体里有两个指针\tQNode* head;//头\tQNode* tail;//尾}Queue;//初始化void QueueInit(Queue* pq){\tassert(pq);\tpq-&gt;head = NULL;\tpq-&gt;tail = NULL;}//摧毁void QueueDestory(Queue* pq){\tassert(pq);\tQNode* findtail = pq-&gt;head;//找尾挨个挨个free\twhile (findtail)\t{\t\tQNode* next = findtail-&gt;next;\t\tfree(findtail);\t\tfindtail = next;\t}\tpq-&gt;head = NULL;\tpq-&gt;tail = NULL;}//插入（尾插）void QueuePush(Queue* pq, QDataType x){\tassert(pq);\tQNode* newnode = (QNode*)malloc(sizeof(QNode));\tif (newnode == NULL)\t{\t\tprintf(\"Push err\\n\");\t\texit(-1);\t}\tnewnode-&gt;data = x;\tnewnode-&gt;next = NULL;\tif (pq-&gt;tail == NULL)\t{\t\tassert(pq-&gt;head == NULL);\t\tpq-&gt;head = pq-&gt;tail = newnode;\t}\telse\t{\t\tpq-&gt;tail-&gt;next = newnode;\t\tpq-&gt;tail = newnode;\t}\treturn;}//删除（头删）void QueuePop(Queue* pq){\tassert(pq);\tassert(pq-&gt;head &amp;&amp; pq-&gt;tail);//判断是否为空\tif (pq-&gt;head-&gt;next == NULL)\t{\t\tfree(pq-&gt;head);\t\tpq-&gt;head = NULL;\t\tpq-&gt;tail = NULL;\t}\telse\t{\t\tQNode* next = pq-&gt;head-&gt;next;\t\tfree(pq-&gt;head);\t\tpq-&gt;head = next;\t}}//判断是否为空bool QueueEmpty(Queue* pq){\tassert(pq);\t//在C中bool类型和int类型可以直接混用\treturn pq-&gt;head == NULL &amp;&amp; pq-&gt;tail == NULL;}//返回它的长度size_t QueueSize(Queue* pq){\tassert(pq);\tsize_t size = 0;\tQNode* findtail = pq-&gt;head;\twhile (findtail)\t{\t\tsize++;\t\tfindtail = findtail-&gt;next;\t}\treturn size;}//返回头QDataType QueueFront(Queue* pq){\tassert(pq);\tassert(pq-&gt;head);\treturn pq-&gt;head-&gt;data;}//返回尾部QDataType QueueBack(Queue* pq){\tassert(pq);\tassert(pq-&gt;tail);\treturn pq-&gt;tail-&gt;data;}\n\n1.3本题的代码将上述的队列代码拷贝在题目所给模板之前后，我们就可以开始写这道题需要的代码实现了\n//创建两个队列typedef struct {\tQueue q1;\tQueue q2;} MyStack;MyStack* myStackCreate() {\tMyStack* pst = (MyStack*)malloc(sizeof(MyStack));    //因为是在函数中，所以需要使用动态内存管理\tif (pst == NULL)//malloc可能失败\t\treturn NULL;\tQueueInit(&amp;pst-&gt;q1);//直接调用队列的函数进行初始化\tQueueInit(&amp;pst-&gt;q2);\treturn pst;}void myStackPush(MyStack* obj, int x) {\tassert(obj);\t//在push的时候，需要找到不为空的队列进行push\tif (!QueueEmpty(&amp;obj-&gt;q1))\t{\t\tQueuePush(&amp;obj-&gt;q1, x);\t}\telse\t{\t\tQueuePush(&amp;obj-&gt;q2, x);\t}}int myStackPop(MyStack* obj) {\tassert(obj);\t//通过判断找到为空和不为空的队列\tQueue* empty = &amp;obj-&gt;q1;\tQueue* unempty = &amp;obj-&gt;q2;\tif (!QueueEmpty(&amp;obj-&gt;q1))\t{\t\tempty = &amp;obj-&gt;q2;\t\tunempty = &amp;obj-&gt;q1;\t}\twhile (QueueSize(unempty) &gt; 1)\t{\t\tint top1 = QueueFront(unempty);\t\tQueuePush(empty, top1);\t\tQueuePop(unempty);\t}\t//先保存top，再进行出队列操作\tint top = QueueFront(unempty);\tQueuePop(unempty);\treturn top;//返回报错的top}int myStackTop(MyStack* obj) {\tassert(obj);\tif (!QueueEmpty(&amp;obj-&gt;q1))\t{\t\treturn QueueBack(&amp;obj-&gt;q1);\t}\telse\t{\t\treturn QueueBack(&amp;obj-&gt;q2);\t}}bool myStackEmpty(MyStack* obj) {\tassert(obj);\t//只有两个队列都为空的时候，模拟的栈才是空\treturn QueueEmpty(&amp;obj-&gt;q1) &amp;&amp; QueueEmpty(&amp;obj-&gt;q2);}void myStackFree(MyStack* obj) {\tassert(obj);\tQueueDestory(&amp;obj-&gt;q1);\tQueueDestory(&amp;obj-&gt;q2);\tfree(obj);//因为是动态内存开辟的，所以最后销毁的时候还需要销毁模拟栈的结构体\treturn;}\n\n16个用例都完美通过了！\n\n\n2.用栈实现队列\nleetcode: 232. 用栈实现队列\n\n\n有了上一道题目的经验，这道题的实现就不那么困难了。\n2.1思路\n栈的特点是只能在栈顶删除和插入数据\n\n队列需要在队尾插入数据，在对头删除数据\n\n\n假设现在我们有下面这两个栈，第一个栈里面存放了1 2 3 4的数据\n需要进行队列的POP操作时，我们需要删除的是最底部的1\n\n可以先将栈中的所有数据pop并push到另外一个空栈中，再将最后一个数据存放后删除，返回存放的值。\n\n这部分操作与第一题中的操作很像，但是有一个致命的问题：在新的栈里的数据和我们原本想要的数据是相反的！\n1 2 3 4 删除1后原本数据 2 3 4实际数据 4 3 2\n\n解决这个问题的方法只有一个，那就是把这一批数据再复制回原本的栈中，它的顺序就对了\n\n而我自己写的栈是用数组实现的，题目要求的peek函数可以直接通过访问非空栈的0下标元素得到\nempty函数同理，只有两个栈中都为空时，模拟的队列才是空的\n\n2.2栈的代码栈的实现在本文开头的博客链接中有详细解释，这里不再复述\n\n回到开头\n\n// 支持动态增长的栈typedef int STDataType;typedef struct Stack{    STDataType* a;    int top; // 栈顶    int capacity; // 容量}Stack;// 初始化void StackInit(Stack* ps){    STDataType* new = (STDataType*)malloc(sizeof(STDataType) * 4);    if (new == NULL)    {        exit(-1);    }    else    {        ps-&gt;a = new;        ps-&gt;top = 0;        ps-&gt;capacity = 4;    }}// 销毁栈void StackDestroy(Stack* ps){    assert(ps);    free(ps-&gt;a);    ps-&gt;a = NULL;    ps-&gt;capacity = 0;    ps-&gt;top = 0;}// 入栈void StackPush(Stack* ps, STDataType data){    assert(ps);    if (ps-&gt;top == ps-&gt;capacity)    {        STDataType* new = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * (ps-&gt;capacity) * 2);        if (new == NULL)        {            exit(-1);        }        else        {            ps-&gt;a = new;            ps-&gt;capacity *= 2;        }    }    ps-&gt;a[ps-&gt;top] = data;    ps-&gt;top++;}// 出栈void StackPop(Stack* ps){    assert(ps);    if (ps-&gt;top &gt; 0)        (ps-&gt;top)--;}// 获取栈顶元素STDataType StackTop(Stack* ps){    assert(ps);    assert(ps-&gt;top &gt; 0);    return ps-&gt;a[ps-&gt;top - 1];}// 获取栈中有效元素个数int StackSize(Stack* ps){    assert(ps);    return ps-&gt;top;}// 检测栈是否为空，如果为空返回true，如果不为空返回falsebool StackEmpty(Stack* ps){    assert(ps);    if (ps-&gt;top == 0)        return true;    else        return false;}void StackPrint(Stack* ps){    assert(ps);    int n = ps-&gt;top;    for (int i = 0; i &lt; n; i++)    {        printf(\"%d \", ps-&gt;a[i]);    }    printf(\"\\n\");}\n\n2.3本题的代码typedef struct {    Stack st1;    Stack st2;} MyQueue;MyQueue* myQueueCreate() {    MyQueue* qt = (MyQueue*)malloc(sizeof(MyQueue));    if (qt == NULL)        return NULL;    StackInit(&amp;qt-&gt;st1);    StackInit(&amp;qt-&gt;st2);    return qt;}void myQueuePush(MyQueue* obj, int x) {    assert(obj);    if (!StackEmpty(&amp;obj-&gt;st1))    {        StackPush(&amp;obj-&gt;st1, x);    }    else    {        StackPush(&amp;obj-&gt;st2, x);    }    return;}int myQueuePop(MyQueue* obj) {    assert(obj);    Stack* empty = &amp;obj-&gt;st1;    Stack* nonempty = &amp;obj-&gt;st2;    if (!StackEmpty(&amp;obj-&gt;st1))    {        Stack* empty = &amp;obj-&gt;st2;        Stack* nonempty = &amp;obj-&gt;st1;    }    while (StackSize(nonempty) &gt; 1)    {        int top1 = StackTop(nonempty);        StackPush(empty, top1);        StackPop(nonempty);    }    int top = StackTop(nonempty);    StackPop(nonempty);//原本不为空的的最后一个top被取出    //需要将数据再倒放一遍，否则访问是反的    while (StackSize(empty) &gt; 0)    {        int top2 = StackTop(empty);        StackPush(nonempty, top2);        StackPop(empty);    }    return top;}int myQueuePeek(MyQueue* obj) {    assert(obj);    Stack* empty = &amp;obj-&gt;st1;    Stack* nonempty = &amp;obj-&gt;st2;    if (!StackEmpty(&amp;obj-&gt;st1))    {        Stack* empty = &amp;obj-&gt;st2;        Stack* nonempty = &amp;obj-&gt;st1;    }    //这里的栈是用数组实现的，可以直接访问首位元素    return nonempty-&gt;a[0];}bool myQueueEmpty(MyQueue* obj) {    assert(obj);    return StackEmpty(&amp;obj-&gt;st1) &amp;&amp; StackEmpty(&amp;obj-&gt;st2);}void myQueueFree(MyQueue* obj) {    assert(obj);    StackDestroy(&amp;obj-&gt;st1);    StackDestroy(&amp;obj-&gt;st2);    free(obj);    return;}\n\n\n\n3.设计循环队列\nleetcode：622. 设计循环队列\n\n\n这道题最主要的突破口，就是弄明白题目所说的循环队列的意思\n实际上他就是一个下图所示的队列，当tail使用完已有空间后，可以跳到前面继续使用之前开辟好的空间，而不需要额外的扩容空间。\n\n为了方便找头以及找尾，本体将使用数组方式来实现它的代码\n\n3.1思路确定是数组形式后，我们就要来思考两个问题：什么时候队列为空？什么时候队列是满？\n3.1.1判断是否为空这个看起来好像非常简单，只要头指针和尾指针相同，队列不就是空的了嘛！\n\n这个想法对，但有有点瑕疵，即我们怎么界定空和非空的界限？\n3.1.2判断是否为满每插入一个数据，tail指针就会往后++一次，指向已有数据的下一位\n\n当下一位也被装好了数据之后，tail就会回到开头，来到front指针的位置！\n\n这个时候，tail=front，但是队列实际上已经满了！\n这就让我们不得不思考，如何将这两种情况区分开来？\n\n啊哈哈哈哈，答案来喽：\n\n如果需要的数据为K个，为队列的数组开辟K+1个空间\n\n这时候，只要tail+1=front，就代表队列已经满了。多出来的这一个空间不存放数据\n\n注意：这个空间不一定是最末尾的哪一个，它会随着队列的插入、删除操作而移动\n当tail在尾部，tail=k（注意tail是下标而不是指针）且front=0时，队列为满\n\n\n这样就很完美的把空和满两种情况给区分开来了！\n\n3.2本题代码实现需要注意题目给出的返回值要求，依照题目函数要求来编写\ntypedef struct {    int* data;    int front;    int tail;    int k;} MyCircularQueue;bool myCircularQueueIsEmpty(MyCircularQueue* obj);bool myCircularQueueIsFull(MyCircularQueue* obj);//为了让这个函数能在它之前使用MyCircularQueue* myCircularQueueCreate(int k) {    MyCircularQueue* qt = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));    if (qt == NULL)        return NULL;    qt-&gt;data = (int*)malloc(sizeof(int) * (k + 1));    qt-&gt;k = k;        qt-&gt;front = 0;    qt-&gt;tail = 0;    return qt;}bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {    assert(obj);    if (myCircularQueueIsFull(obj))        return false;    obj-&gt;data[obj-&gt;tail] = value;    //obj-&gt;tail++;    //obj-&gt;tail %= obj-&gt;k+1;//保证数据在数组内部    if (obj-&gt;tail == obj-&gt;k)    {        obj-&gt;tail = 0;    }    else    {        obj-&gt;tail ++ ;    }        return true;}bool myCircularQueueDeQueue(MyCircularQueue* obj) {    assert(obj);    if (myCircularQueueIsEmpty(obj))        return false;    if (obj-&gt;front == obj-&gt;k)    {//front在预先开辟的第4个位置上        obj-&gt;front = 0;    }    else    {        obj-&gt;front++;    }    return true;}int myCircularQueueFront(MyCircularQueue* obj) {    assert(obj);    if (myCircularQueueIsEmpty(obj))        return -1;    return obj-&gt;data[obj-&gt;front];}int myCircularQueueRear(MyCircularQueue* obj) {    assert(obj);    if (myCircularQueueIsEmpty(obj))        return -1;    if (obj-&gt;tail == 0)    {        return obj-&gt;data[obj-&gt;k];    }    else    {        return obj-&gt;data[obj-&gt;tail - 1];    }    return -1;}bool myCircularQueueIsEmpty(MyCircularQueue* obj) {    return obj-&gt;tail == obj-&gt;front;}bool myCircularQueueIsFull(MyCircularQueue* obj) {    if ((obj-&gt;tail == obj-&gt;k) &amp;&amp; obj-&gt;front == 0)    {        return true;    }    else    {        return obj-&gt;tail + 1 == obj-&gt;front;    }}void myCircularQueueFree(MyCircularQueue* obj) {    assert(obj);    free(obj-&gt;data);    free(obj);    return;}\n\n\n结语刷完这3道题，有没有感觉数据结构的很多内容都是关系紧密的？🤩\n只要我们把链表和顺序表的内容搞得透彻，栈和队列这部分就没那么难了！\n加油！\n","categories":["数据结构太复杂"],"tags":["OJ刷题","C语言","数据结构","栈","队列","循环队列"]},{"title":"【树莓派开发】使用树莓派在Linux环境下编写C语言代码","url":"/2022/02/26/code/raspberry/1%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%9C%A8linux%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81/","content":"\n\n\n\n前言如何使用树莓派编译C语言代码呢？\n\n\n21年暑假的时候，学习编程的劲头高涨，然后冲动消费买了个树莓派4B……结果压根不会用，吃灰了半年\n\n不过现在已经学完了C语言，也接触了一丢丢Linux系统下的gcc指令，可以尝试用它来编写C语言代码了！\n\n1.创建test.c文件首先我们需要在一个文件夹里创建一个test.c文件\n\n点击test.c文件后，树莓派会用自带的Geany编辑器打开它\n然后我们可以往里写入C语言最经典的helloword代码\n#include &lt;stdio.h&gt;int main(void)&#123;\tprintf(&quot;hello wordl!\\n&quot;); \treturn 0;&#125;\n\n2.编译运行该文件保存文件后，打开顶部的命令行\n\n输入以下代码\n\n注意cd后需要空格，填写的是刚刚创建的test1.c文件的路径\n\ncd /home/pi/code\n\n填写完毕后，可以看到命令行前面多出了一个文件地址\n\n这代表目前我们操作的是code文件夹里面的内容\n输入ls，可以看到当下文件夹里的文件\n\n输入以下指令，可以生成一个可执行文件\ngcc test1.c -o test1\n\n\n最后输入以下指令，可以运行该文件！\n./test1\n\n可以看到，程序已经成功运行了！\n\n\n3.编译并链接两个源文件接下来我们再尝试一个相对来说更复杂的代码\n分开两个源文件，一个是test.c，包含了main函数\n另外一个是Add.c，包含了Add函数\n因为是在不同的源文件里面，我们需要用extern来声明外部函数\n#include &lt;stdio.h&gt; extern int Add(int x,int y); int main(void)&#123;\tint a=3;\tint b=5;\tprintf(&quot;%d&quot;,Add(a,b); \treturn 0;&#125;\n\n\n接下来我们使用-c指令来生成.o目标文件\n\n在vs下，目标文件的后缀是.obj\n.i文件为预编译文件\n\n可以看到，我的代码里面extern写错了（很是尴尬），编译器报了警告\n更改了以后就编译成功了\n\n这一步是把C语言代码转换成机器认识的二进制指令\n\n\n然后输入以下指令，链接这两个文件，生成可执行文件test\ngcc test1.c Add.c -o test\n\n\n最后还是使用./test指令来运行可执行文件\n可以看到我们的结果已经输出了！\n\n结语第一次尝试用linux的gcc指令来编译C语言代码，还有点小激动\n吃灰的树莓派终于有用了！😍\n\n如果有写的不对的地方，还请大佬无情指出！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【C语言】什么是堆？堆排序和TopK问题又是如何实现的","url":"/2022/04/11/code/note_data_structure/9%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/","content":"[TOC]\n前言在上一篇数据结构博客中，我带大家一起学习了树以及二叉树这一个全新的数据结构。\n\n【C语言】什么是树，二叉树又是啥玩意\n\n本篇博客，就让我们一起来看看常被人津津乐道的堆排序以及堆这个数据结构是一个什么样的存在吧？\n\n1.堆的概念堆的概念是基于完全二叉树的\n\n当k1、k2、k3……kn的数据按照完全二叉树的方式存放在数组中，且这个完全二叉树满足某个节点的值总是不大于（或不小于）其父节点的值时，称该完全二叉树为堆。\n\n\n将根节点最大的堆叫大根堆\n根节点最小的堆叫做小根堆\n堆中某个节点的值总是不大于（或不小于）其父节点的值\n\n上篇树的博客中已经给大家解释过如何用数组的方式存放一颗完全二叉树，这里就不再赘述啦！\nleftchild=parent*2+1rightchild=parent*2+2parent=(child-1)/2\n\n接下来这道题目能考察你是否了解了堆的概念，自测一下吧！\n2.下列关键字序列中，序列（ ）是堆。A .{16，72，31，23，94，53}B .{94，23，31，72，16，53}C .{16，53，23，94，31，72}D .{16，23，53，31，94，72}   √\n\n简单说来，以0下标根为例，下标1和2为根的左右孩子。如果他们都比根小，代表这是一个小根堆，反之是大根堆。\n接着我们就需要判断，是不是所有节点的孩子都满足这个特性，如果出现某一个节点的孩子和该节点的父亲之间的关系不满足根节点和孩子之间的关系（如根节点的孩子比根节点大，那么该树中所有节点的孩子都应该比该节点大）那么这个就不是一个堆\n2.堆的实现先来尝试直接实现一个堆，即将数据以堆的结构存放在数组中\n这里给出一个堆的头文件，里面包含了一个堆的基本框架\n//实现一个小堆#include&lt;stdio.h&gt;#include&lt;assert.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;typedef int HPDataType;typedef struct Heap{\tHPDataType* a;\tsize_t size;\tsize_t capacity;}HP;void HeapInit(HP* php);//初始化-不进行扩容操作void HeapDestroy(HP* php);//摧毁void HeapPrint(HP* php);//打印//交换数组中两个元素的位置void Swap(HPDataType* pa, HPDataType* pb);//插入后向上调整，保证数据是(大/小)堆//child为待操作数据的下标void AdjustUp(HPDataType* a, size_t child);// 插入x以后，保持他依旧是(大/小)堆void HeapPush(HP* php, HPDataType x);//删除后向下调整，保证数组末尾数据位置正确//size堆的大小；root待调节数据的位置，0代表根部（堆顶）void AdjustDown(HPDataType* a, size_t size, size_t root);// 删除堆顶的数据。(最小/最大)；// 交换堆顶数据和数组末尾数据void HeapPop(HP* php);//判断是否为空bool HeapEmpty(HP* php);//返回堆的大小（节点个数）size_t HeapSize(HP* php);//返回堆顶，访问数组下标0HPDataType HeapTop(HP* php);\n\n2.1向上调整你会发现，相较于普通数据结构的增加、删除操作，堆有一个额外的操作，就是调整数据的位置。\n\n本篇博客不再对前面的基础操作进行讲解，如果有不会的可以评论区提出哦\n\n比如下面这幅图里的数组，我们可以直接在数组的末尾插入一个数据6，因为当前的这个堆是一个小堆，堆顶的数据是最小的数据，所以我们不需要对这个数据进行处理\n\n但当我们插入一个0，事情就不一样了。我们必须将这个0调整到堆顶的位置，才能让插入数据后的数组依旧是一个小堆\n\n转换为树的形状，即为下图\n\n我们需要让在叶节点的0往上爬，来到1的位置\n如何操作呢？\n\n将该节点与它的父节点进行比较，如果父节点大于该节点，则交换两个节点的位置。\n通过循环的来完成一个完整的向上调节工作\n\n在上篇博客中，我提到了下图所示的计算公式。使用这个公式来进行父节点和孩子节点的查找工作，再单独编写一个Swap函数进行交换\n\n代码实现如下\n//交换数组中两个元素的位置void Swap(HPDataType* pa, HPDataType* pb) {\tint tmp = *pa;\t*pa = *pb;\t*pb = tmp;}//向上调整，保证数据是(大/小)堆//child为待调整数据的下标位置void AdjustUp(HPDataType* a, size_t child){\tassert(a);//这里依旧需要断言，因为用户可能单独调用这个函数\twhile (child &gt; 0)\t{\t\tint parent = (child - 1) / 2;\t\tif (a[child] &lt; a[parent])//小堆，小的数据往上调\t\t{\t\t\tSwap(&amp;a[child], &amp;a[parent]);\t\t\tchild = parent;\t\t}\t\telse\t\t{\t\t\treturn;\t\t}\t}}// 插入x以后，保持他依旧是(大/小)堆// O(logN)void HeapPush(HP* php, HPDataType x){\tassert(php);\tif (php-&gt;size == php-&gt;capacity)\t{\t\t//如果容量为0，新容量为4；不为0，新容量为原本容量的2倍\t\tint newcapa = php-&gt;capacity==0 ? 4: php-&gt;capacity*2;\t\tHPDataType* tmp = (HPDataType*)realloc(php-&gt;a, newcapa*sizeof(HPDataType));//realloc接收空指针，作用与malloc相同\t\tif (tmp == NULL)\t\t{\t\t\tprintf(\"realloc failed!\\n\");\t\t\texit(-1);\t\t}\t\tphp-&gt;a = tmp;\t\tphp-&gt;capacity = newcapa;\t}\tphp-&gt;a[php-&gt;size] = x;//在数组末尾插入新数据\tphp-&gt;size++;\tAdjustUp(php-&gt;a, php-&gt;size - 1);}\n\n下图更加清晰地展示了向上调整函数的作用过程\n\n2.2向下调整同理，当我们pop掉一个堆顶的数据之后，就需要进行一定的调整，来维持堆的结构\n这里需要注意一个问题，栈顶的数据并不能直接pop掉，因为会破坏掉堆的结构。\n比如下面的这个堆中，如果我们直接删除掉堆顶的元素1，那请问谁来当新的爸爸呢？\n\n为了方便这里数据的处理，我们要先将堆顶的元素和数组的最后一个元素进行交换，再进行pop操作。\n\n\n因为我们的堆是用顺序表实现的，所以交换后，只需让size--即可达到pop的效果\n\n那么如何让8往下掉呢？\n同样是利用上面提到过的关系公式👉点我回到之前的公式图\n我们需要将8和它的孩子进行比较，如果8大于它的孩子，则进行交换。\n代码实现如下👇\n//删除后向下调整，保证数组末尾数据位置正确void AdjustDown(HPDataType* a, size_t size, size_t root){\tassert(a);\tint parent = root;\tint child = parent * 2 + 1;//左孩子\twhile (child &lt; size)\t{\t\t\t\t//找左右孩子中小的那一个\t\tif (child + 1 &lt; size &amp;&amp; a[child] &gt; a[child + 1])\t\t{//如果左孩子大于右孩子，则选择右孩子\t\t\tchild++;\t\t}\t\tif (a[child] &lt; a[parent])\t\t{\t\t\tSwap(&amp;a[child], &amp;a[parent]);\t\t\tparent = child;\t\t\tchild = parent * 2 + 1;\t\t}\t\telse\t\t{\t\t\treturn;\t\t}\t}}// 删除堆顶的数据。(最小/最大)；// 交换堆顶数据和数组末尾数据void HeapPop(HP* php) {\tassert(php);\tassert(php-&gt;size &gt; 0);\tSwap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);\tphp-&gt;size--;\tAdjustDown(php-&gt;a, php-&gt;size, 0);}\n\n这两个函数以外的其他函数就比较简单啦，相信学到这里的你肯定能自己根据头文件的函数声明来解决它们。回到头文件\n\n如果你有疑惑，可以去看看之前顺序表的实现，或者在评论区提问哦\n\n\n2.3代码测试老样子，一定要写完一个模块后，立马测试一个模块！\n\n3.堆排序上面我们自己实现了一个堆的代码，接下来我们可以借助这个堆的代码，进行排序操作。（解析见代码注释）\nvoid HeapSort(int* a, int size){\t// 小堆-升序\tHP hp;\tHeapInit(&amp;hp);\tfor (int i = 0; i &lt; size; ++i)\t{\t\tHeapPush(&amp;hp, a[i]);//往堆内放入数据\t}\tsize_t j = 0;\twhile (!HeapEmpty(&amp;hp))\t{\t\ta[j] = HeapTop(&amp;hp);//每一次都堆顶数据出来放入数组\t\tj++;\t\tHeapPop(&amp;hp);//删除堆顶数据，重新排序\t}\tHeapDestroy(&amp;hp);}\n\n可以看到，上述代码成功排序\n\n3.1为什么要进行堆排序？看到这里，你可能会有一个疑惑：排序的方式有很多种，我们可以直接冒泡排序，也可以利用库函数qsort进行排序，为什么要采取堆排序这种方式呢？还需要写一个堆的代码，多麻烦啊！\n\n要想解答这个问题，我们先来看看冒泡排序算法和堆排序算法的时间复杂度\n\n\n冒泡排序：遍历一遍数组是N，调整一次数据也是N，时间复杂读是O(N^2^)\n堆排序：建堆是O(N*logN)，取堆顶数据是O(N)，时间复杂度是O(N*logN)\n\n如果你不了解什么是时间复杂度，可以看看我的这篇博客👉传送门\n\n对于我示例中这个10个元素的数组来说，这两个时间复杂度的差距可能不是很大，但对于海量数据来说，差距就起飞啦！\n\n\n\n数据个数\nO(N*logN)\nO(N^2^)\n\n\n\n1000\n1000×10\n1000×1000\n\n\n100w\n100w×20\n100w×100w\n\n\n这个数据的差距可大的很呢！😱\n\n从上面的解释，你应该能看出来，堆排序是挺优秀！\n但是我们一般并不会写上面的代码，因为它需要另建一个堆来存放数据，空间复杂度是O(N)\n有没有什么办法，能够在原本的数组上建堆，来进行排序呢？\n3.2在原本数组上建堆直入主题，我们可以直接在原本的数据上，利用堆的向上/下调整算法，建立一个大堆或者小堆来进行排序。\n3.2.1向上调整-插入数据使用插入数据的思想，我们可以把数组第二个元素当作新的元素进行push操作，并利用向上调整算法来调整它们的位置，以此类推，这样就能建成一个堆。\n\n但是这个方法对于升序来说不够优化，后续会提到具体原因\n\n3.2.2 向下调整-删除数据假设我们有一个这样的数组（它现在还不算一个堆）\n\n我们可以从第一个非叶子节点（即8）开始，进行向下调整，如果它的孩子比它小，则进行交换。处理完8后，进一步处理7、2、4……\n最终我们会得到这样的一个小堆\n\n此时再将第一个数据和末尾数据进行交换，pop掉它，让它成为数组尾部的数据。再进行向下调整操作，依次循环，即可完成一个降序的排列\n3.2.3比较时间复杂度我们来比较一下上面两个方法的时间复杂度。\n\n如果是向上调整的话，第二层的2个节点要向上调整1次，第三层的4个节点要向上调整2次，最后累积，我们会得到下面这个公式$$T(h)=2^11+2^22+2^33+……+2^{h-1}(h-1)$$数学好的你，估计一眼就能看出来，这是一个等差×等比形式的数列，可以利用\n\n错位相减法，高考第17题，如果出上面这个式子，属于送分题\n快一年过去了，现在的我看到这个式子，属于送命题\n\n好吧其实也没那么难😂\n\n\n如果是向下调整算法，第一层要向下移动h-1层，第二层要向下移动h-2层，第h-1层需要往下移动1层，我们能得到下面的公式最后能得出，需要移动的总步数为在N很大的时候，减去的log(n+1)可以忽略，时间复杂度为O(N)\n由此可见，向下调整算法是更优的，它的时间复杂度更小\n\n3.3代码示例弄明白思路后，写代码就很简单啦！\n// 升序用大堆// 降序用小堆void HeapSort(int* a, int n){\t// 向上调整--建堆 O(N*logN)\t//for (int i = 1; i &lt; n; ++i)\t//{\t//\tAdjustUp(a, i);\t//}\t// 向下调整--建堆 O(N)\tfor (int i = (n - 1 - 1) / 2; i &gt;= 0; --i)\t{\t\tAdjustDown(a, n, i);//此时建的是一个小堆\t}\tsize_t end = n - 1;\twhile (end &gt; 0)\t{\t\tSwap(&amp;a[0], &amp;a[end]);        //前后交换，最小的数组放到末尾，不进行下一次调整\t\tAdjustDown(a, end, 0);\t\tend--;\t}\t//现在是小堆代码，所以排序出来是降序}\n\n测试一下代码，完美排序出了降序\n\n如果你需要升序的话，只需将原本实现的小堆代码中的判断条件改一下就行了\n\n\n4.TopK问题4.1问题说明TOP-K问题：即求数据结合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。\n比如：专业前10名、世界500强、富豪榜、游戏中前100的活跃玩家等\n对于Top-K问题，能想到的最简单直接的方式就是排序。有两个思路\n\n堆排序：时间复杂度O(N*logN)，空间复杂度O(1)\n在原本的数组上建立N个数的大堆，Pop K次，就能选出最大的前K个。时间复杂度O(N+K*logN)，空间复杂度：O(1)\n\n但是，如果数据量非常大，上面这两个方法就不太可取了(可能数据都不能一下子全部加载到内存中，而是存放在硬盘里面)\n\n4.2如何求解？\n用前K个数建立一个K个数的小堆，然后剩下的N-K个数依次遍历，如果比堆顶的数据大，就替换它进堆（进堆后要进行向下调整），最后堆里面的K个数据就是最大的前K个\n\n代码示例如下\nvoid PrintTopK(int* a, int n, int k){\t// 1.建堆--用a中前k个元素建堆\tint* kminHeap = (int*)malloc(sizeof(int) * k);\tassert(kminHeap);\tfor (int i = 0; i &lt; k; ++i)\t{\t\tkminHeap[i] = a[i];\t}\t//利用小堆代码的向下调整，建一个小堆\tfor (int j = (k - 1 - 1) / 2; j &gt;= 0; --j)\t{\t\tAdjustDown(kminHeap, k, j);\t}\t//堆顶是这个堆里面最小的数据\t//2.将剩余n-k个元素依次与堆顶元素判断，如果大于堆顶，则交换\tfor (int i = k; i &lt; n; ++i)\t{\t\tif (a[i] &gt; kminHeap[0])\t\t{\t\t\tkminHeap[0] = a[i];\t\t\tAdjustDown(kminHeap, k, 0);\t\t}\t}\tfor (int j = 0; j &lt; k; ++j)\t{\t\tprintf(\"%d \", kminHeap[j]);\t}\tprintf(\"\\n\");\tfree(kminHeap);}\n\n\n时间复杂度：O(K+logK*(N-K))\n空间复杂度：O(K)\n\n当N非常大，K很小的时候，这个算法的时间复杂度基本就是O(N)\n\n4.3测试代码通过time函数和srand函数，我们可以将一个10000个数的数组中的每个元素赋值小于100w的随机数，再在随机位置放入10个大于100w的数字。\n可以看到，上面的代码巧妙利用堆的知识，帮我们找出了这个10000个数的数组中最大的前K个数字\n\n\n结语堆和堆排序的知识到这里就讲解完毕啦！如果你还有什么问题，可以在评论区留言哦~\n\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","堆"]},{"title":"【树莓派开发】出现报错pragama once in main file","url":"/2022/03/11/code/raspberry/2%E5%87%BA%E7%8E%B0%E6%8A%A5%E9%94%99pragma%20once/","content":"\n\n前言众所周知，#pragma once语句是防止头文件重复包含非常常用的一条语句VS编译器在创建.h文件的时候会自动帮你在开头添加这个语句但是在gcc编译器下，这个语句就可能会出现一些问题\n\n所使用编译器：\n\nVS2019（windows10）\n树莓派（linux-gcc）\n\n\nwarning: #pragma once in main file在我尝试在linux环境下使用#pragma once语句时，遇到了这个报错\n\n解决这个问题的办法很简单，就是不要编译头文件\n\n编译器会自动展开头文件，无需手动编译\n\n\n\n出现问题原因网上查了查：出现这个问题的原因是编译器在编译头文件的时候，#pragma once本身是没有含义的语句，所以报错了。\n\n也有人说是因为linux不支持这个语句，我们来试试\n\n右侧代码中包含了两个test.h的引用，在预处理中只包含了一次\n\n去掉头文件中的#pragma once，再次编译，可以看到预处理文件中出现了两次头文件的内容\n\n这说明linux-gcc编译器是支持该语句的，并非网上说的不支持！\n其他解决方法如果你的gcc编译器不管咋弄都有这个报错，咱可以不用它嘛！使用条件编译指令ifndef也可以达成防止头文件重复包含的效果\n#ifndef __TEST_H__//如果没有定义过这个符号#define __TEST_H__//定义该符号//头文件内容#endif\n\n\n查资料查到外网去了~刚刚写预处理博客的时候，查有关这个问题的资料，百度都给我推了外网的论坛\n\n参考：https://bbs.csdn.net/topics/395771733?page=1\n\n\n网上有关这个报错的信息的确不多，特此写篇博客记录一下\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【C语言】什么是树，二叉树又是啥玩意","url":"/2022/04/06/code/note_data_structure/8%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"[TOC]\n前言在之前的数据结构学习中，我们学习了顺序表、链表、栈、队列这几种结构\n它们都是用链表或者数组的方式来实现的，主要考察我们对结构体的运用\n\n今天让我们来学习一个新的数据结构，也就是下面这副图里面的树\n\n啊不好意思，图拿错了！😜\n是下面这个才对\n\n\n1.什么是树？1.1树的概念树是一种非线性的数据结构，它是由n个有限节点组成的具有一定层次关系的集合。\n把它叫做树是因为它看起来的确像一个树的根部\n当然也可以理解为是树干在上，树叶在下的结构\n\n有一个特殊的节点，被称为根节点，也就是树的开头\n除了根节点外，其余节点都是,个互不相交的集合。每一个集合都是一颗与树的结构类似的子树\n每一个节点只能有一个前驱，但是可以有很多个后驱\n因此，树是递归定义的\n\n\n树中的子节点不能有交集\n\n上图中的B节点不能有G这个孩子，因为G已经有父母C了\n同理，G节点也不能同时拥有两对父母\n子节点之间也不能相连，如E和F不能相连\n\n\n1.2树的相关知识点\n节点的度：一个节点含有的子树的个数称为该节点的度； 如下图：A的度为6\n\n叶节点或终端节点：度为0的节点称为叶节点； 图中B、C、H、I…等节点为叶节点\n非终端节点或分支节点：度不为0的节点； 如上图中D、E、F、G…等节点为分支节点\n简单的说，就是有娃的节点就是分支节点\n\n双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图，D是H的父节点\n孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：H是D的孩子节点\n\n兄弟节点：具有相同父节点的节点互称为兄弟节点； 如下图：P、Q是兄弟节点\n\n\n树的度：一棵树中，最大的节点的度称为树的度； 示例中树的度为6（即A的度）\n节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推\n树的高度或深度：树中节点的最大层次； 示例中树的高度为4\n\n堂兄弟节点：双亲在同一层的节点互为堂兄弟；如下图：H、I互为兄弟节点\n\n\n节点的祖先：从根到该节点所经分支上的所有节点；示例中A是所有节点的祖先\n子孙：以某节点为根的子树中任一节点都称为该节点的子孙。示例中所有节点都是A的子孙\n\n森林：由m（m&gt;0）棵互不相交的树的集合称为森林\n多个不相交的树就是森林\n\n\n\n1.3树的代码表示表示树的方式有很多种，比如下面这种\n#define N 5 //指定树的度为5struct TreeNode{\tint data;\tstruct TreeNode* subs[N];//用指针数组存放孩子节点的指针};\n\n但这种方法不够优，给大家展示一个用的最广泛的方法——孩子兄弟表示法\ntypedef int DataType;struct Node{ struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域};\n\n通过这种方法，父亲节点只需要保存它的第一个娃，其他娃就让大娃的兄弟节点来找\n也就是家长只用管老大，老大管老二，老二管老三，依次往下……\n\n实际写代码的结构大概是下图这样\n\n2.二叉树在实际中，二叉树是使用较多的一种树的结构\n2.1概念二叉树是度为2的树，它是一个特殊的树\n\n二叉树不存在度大于2的节点\n二叉树是有序树，它的娃（子树）有左右之分，次序不能颠倒\n\n\n所以，二叉树都是由下面各类节点组成的树\n\n2.2特殊的二叉树满二叉树是一个特殊的完全二叉树\n\n满二叉树，每一层都是满的\n完全二叉树，最后一层必须从左到右连续\n\n满二叉树满二叉树：如果每一个层的节点数都达到最大值，那这个二叉树就是满二叉树。也就是说：满二叉树的层数为k，且节点总数是2^k^-1\n\n满二叉树的节点数是一个等比数列公式\n\n\n完全二叉树完全二叉树：完全二叉树是效率很高的数据结构。对于深度为K，有n个节点的二叉树，当且仅当每一个节点都与深度为K的满二叉树中编号从1至n的节点一一对应时，称为完全二叉树。\n简单说来，完全二叉树的最后一层不一定满，但必须要从左到右连续\n\n\n2.3二叉树的性质\n只有一个节点的二叉树，度为0\n若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有2^(i-1)个结点\n若规定根节点的层数为1，则深度为h的二叉树的最大结点数是(2^h)-1\n对任何一棵二叉树, 如果度为0其叶结点个数为n0, 度为2的分支结点个数为n2，则有n0 = n2+1\n若规定根节点的层数为1，具有n个结点的满二叉树的深度，h=log2(n+1) 。 (ps： 是log以2为底，n+1为对数)\n对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号为i的结点有：\n若i&gt;0，i位置节点的双亲序号：(i-1)/2；i=0时为根节点编号，无双亲节点\n若2i+1&lt;n，左孩子序号：2i+1，2i+1&gt;=n否则无左孩子\n若2i+2&lt;n，右孩子序号：2i+2，2i+2&gt;=n否则无右孩子\n\n\n\n\n\n2.4几个选择题1. 某二叉树共有 399 个结点，其中有 199 个度为 2 的结点，则该二叉树中的叶子结点数为（ ）A 不存在这样的二叉树B 200  √C 198D 199//叶子节点的数量 总比度为2的节点多1    2.在具有 2n 个结点的完全二叉树中，叶子结点个数为（ ）A n    √B n+1C n-1D n/2//N0+N1+N2=2n//2N0+N1-1=2n//N1只有0和1两种可能，因为n为整数，2n为偶数，所以2N0=2n，N0=n    3.一棵完全二叉树的节点数位为531个，那么这棵树的高度为（ ）A 11B 10  √C 8D 12//假设高度是h//完全二叉树节点最多2^h -1//             最少2^(h-1)-1 +1//可以通过这两个公式，推断出h=104.一颗完全二叉树第六层的叶子节点为9，那么这棵树的节点数最多为（）A 108B 109 √C 112D 119//1  //2  //4  //8  //16  //32  //64 - 9*2//因为题目中的是第六层的叶子节点，完全二叉树必须从左到右连续，所以说明第六层不只9个节点（那样算出来的结果不对）//所以是第六层已经满了，第七层没有满//把第七层去掉9个叶子节点的孩子就能算出最多的节点数\n\n3.二叉树的存储结构二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构\n3.1顺序存储顺序结构存储就是使用数组来存储\n一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。\n\n现实使用中只有堆才会使用数组来存储\n下一篇博客会带大家认识堆这个特殊的树形结构（和内存里面那个堆😂没啥关系哈）\n\n\n\n看到这张图，你肯定想问，如果用数组结构存储，那还怎么还原出一颗树🎄呢？\n这里我们需要理解物理存储和逻辑结构的关系\n\n二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树\n那怎么计算这种情况下的父亲和娃呢？\n\nleftchild=parent*2+1\nrightchild=parent*2+2\nparent=(child-1)/2\n\n\n怎么样，是不是忽然感觉\n\n3.2链式存储这就就没啥好说的啦，使用一个简单的二叉链就能构成二叉树\ntypedef int BTDataType;// 二叉链struct BinaryTreeNode{ \tstruct BinTreeNode* _pLeft; // 指向当前节点左孩子 \tstruct BinTreeNode* _pRight; // 指向当前节点右孩子 \tBTDataType _data; // 当前节点的值}\n\n\n结语嘿嘿嘿，本篇博客到这里就结束啦！\n下篇博客将带来堆的详解\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n\n","categories":["数据结构太复杂"],"tags":["C语言","数据结构","树"]},{"title":"【树莓派开发】树莓派GeanyIDE和控制台下C/C++中文乱码问题解决方法","url":"/2022/02/28/code/raspberry/3%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","content":"\n\n\n\n情况说明之前使用树莓派的时候，遇到了中文乱码的问题。\n\nVS2019编译器下写的.c文件，里面的中文注释在树莓派ide上乱码\n树莓派控制台上，C语言代码输出中文时乱码\n\n这里需要调整三个设置来解决该问题\n1.设置VS，将文件保存为UTF8编码VS2019默认用的是GBK编码，而不是一般中文需要的UTF8编码\n这里我们可以安装一个Force UTF-8(No BOM)插件来解决该问题\n\n在VS顶部工具栏里找到“拓展”-管理拓展\n\n\n\n搜索Force UTF-8(No BOM)，找到该插件并安装\n\n\n这个插件的作用，是让VS保存文件都使用UTF8编码保存\n安装完毕后，可以在原本文件中打一个注释并保存，这时候.c文件就已经是UTF8编码了\n\n\n\n树莓派中可以更改文件编码，但这个更改并不会对已经乱码了的中文生效\n\n更新22.03.01：使用该插件可能会导致报错该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失出现这种情况需要禁用插件，重启VS才能解决。否则程序有中文注释就无法运行\n2.更改Geany IDE编码设置更改完VS的设置后，我们需要更改树莓派下IDE的设置\n在编辑-首选项里面选择文件，将两个设置选项都改为UTF8\n\n\n3.更改树莓派系统设置前面两个设置完之后，我们还需要在树莓派的控制系统中输入一串命令\nsudo raspi-config\n\n\n选择第4个，区域语言设定，进入后选择第一个，来到如下界面\n\n找到zh_cn.UTF8\n\n选择后，会进入设置界面，提示complete就完成设置了\n\n再次进入树莓派，用控制台运行我们的代码，可以看到中文已经正常显示了！\n\n\n\n如果这篇博客对你有帮助，还请点赞支持一下，谢谢！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【树莓派开发】树莓派安装vim编辑器（附带排错流程）","url":"/2022/04/12/code/raspberry/4%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8vim/","content":"\n\n前言Linux自带的编辑器有nano和vi，但vi编辑器使用起来很不方便。\n我们要先在树莓派上下载vim编辑器，它是vi编辑器的升级版本，使用更加人性化\n\n但实际上安装vim编辑器并没有网上写的那么简单，在安装过程中出现了种种问题😭\n\n1.用putty软件链接树莓派Putty软件想必把玩树莓派的你应该是很熟悉的。\n输入ip后即可链接到你的树莓派，方便我们进行后续的操作\n\n2.下载vim首先更新索引源\nsudo apt-get update \n\n安装vim编辑器\nsudo apt-get install vim\n\n2.1错误：404无法下载安装过程中可能会有错误提示，比如我这里就显示无法连接到服务器404，且软件包下载失败\n\n\n解决方法参考这篇博客👉传送门1\n\n因为树莓派默认的软件源是国外的，国内可能链接不少，所以我们要把下载源修改为国内清华的\n需要修改两个文件来进行这个操作\nsudo nano /etc/apt/sources.list\n\n在句首加上#注释掉第一行的语句后，在后面加上下面这两行语句\n注意：这里不能复制粘贴，老老实实敲吧😥\ndeb空格http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/空格stretch空格main空格contrib空格non-free空格rpideb-src空格http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/空格stretch空格main空格contrib空格non-free空格rpi\n\n\n编辑好后，按CTRL+X保存，再按y确认，最后按回车回到命令行\n\n\n再运行下面这条指令，打开另外一个文件\nsudo nano /etc/apt/sources.list.d/raspi.list\n\n依旧要#注释掉第一行的语句，在末尾加上 上面的两个deb语句\ndeb空格http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/空格stretch空格main空格contrib空格non-free空格rpideb-src空格http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/空格stretch空格main空格contrib空格non-free空格rpi\n\n编辑好后，按CTRL+X保存，再按y确认，最后按回车回到命令行\n\n两个文件都编辑完后，使用sudo apt-get update查看有没有报错，如果有什么奇怪的报错，建议回去检查一下是不是写错了。\n我这里是这样的情况，实际上它已经搞定了\n\n这时候就可以再次使用下面的语句安装vim了\nsudo apt-get install vim\n\n2.2错误：下列软件包有未满足的依赖关系但很快我就出现了第二个问题👇\n下列软件包有未满足的依赖关系： vim : 依赖: vim-common (= 2:8.0.1453-1ubuntu1) 但是 2:8.0.1453-1ubuntu1.4 正要被安装E: 无法修正\n\n这是因为我们第一次没有正常下载vim的时候，留下了一个旧版本的安装包\n\n解决方法参考这篇博客👉传送门2\n\n依次运行下面的语句，卸载vim-common\nsudo apt-get purge vim-commonsudo apt-get updatesudo apt-get upgrade\n\n\n完成上述操作后，再次尝试安装vim\nsudo apt-get install vim\n\n这一次我才成功把vim安装下来\n\n\n3.查看vim是否安装成功用下面这个最简单的方法查看vim有没有安装成功\nvim test.txt\n\n如果安装失败，会出现这个报错。尝试跟着上面的步骤再走一遍，如果还不行我也不知道咋办😂\n-bash: vim: 未找到命令\n\n出现这个界面就代表安装完毕了，可以输入:q退出\n\n先来配置一下vim编辑器\nsudo nano /etc/vim/vimrc\n\n在打开的文件中，用方向键⬇来到最后，输入下面的三句话（可以不加注释）\nset nu   #显示行号syntax on   #语法高亮set tabstop=4 # tab退四格,默认是8格set softtabstop=4  set shiftwidth=4  #设置缩进的空格数set autoindent #每行的缩进值与上一行相等\n\n4.vim的基本操作前人栽树，后人乘凉\n\n基本操作参考这篇博客👉博客园、\n\n其实只是我懒，不想写而已😥\n5.用vim编写一个C语言代码到这里，你的vim就基本配置完毕啦！让我们来试试用它写一个代码\nvim test.c\n\n这个会在当前目录下创建一个test.c文件，我们来一个最简单的printf代码\n\n编辑完毕后，按ESC退出编辑状态，回到初始模式\n\n输入:wq保存并退出当前文件\n\nls之后可以看到，已经多出来了一个test.c的文件，后面的操作就是gcc指令了\n\ngcc test.c -o TEST\n\n再次ls可以看到多出了一个可执行文件TEST，执行该文件，程序成功运行\n\n结语到这里，咱们的vim编辑器的初始学习就结束啦！后续进阶的指令学习，大家可以看第4点中博主的讲解偶！\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【树莓派开发】使用cpolar实现内网穿透，远程连接在家里的树莓派","url":"/2022/05/02/code/raspberry/5%E4%BD%BF%E7%94%A8cpolar%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE/","content":"众所周知，一般我们远程连接树莓派，需要它和我们的电脑在同一局域网下。如果出门要用树莓派的话，只能把它一并带出门。\n可如果我们想偷懒，把树莓派连上网线或wifi丢家里，然后在另外一个网络下远程连接树莓派的话，就需要借助cpolar来实现内网穿透，把树莓派变为联网的远程LINUX服务器\n\n\n\n如果你还没有配置好树莓派的基本使用环境，可以参考我的博客🚪【传送门】\n\n\n关于cpolar在树莓派上的基本配置，官方有很详细的帮助文档，但是里面有一些问题介绍的并不算清楚【官方文档连接】\n本文是对官方帮助文档的细化（很多我搜到的博客基本就是照搬官方帮助文档）\n在开始之前，请先注册一个你的cpolar账户\n\nhttps://www.cpolar.com/\n\n1.修改树莓派密码注意：使用cpolar共享的SSH接口，主机地址都是一样的，只是端口号不一样\n为了避免有小人，随机生成端口号，偷偷摸摸连接我们的树莓派搞破坏\n这里建议大家一定要先修改你的初始密码！\nsudo passwd pi\n\n2.在树莓派上初始化cpolar2.1下载用这个语句安装cpolar（国内用户）\ncurl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash\n\n或者这个语句（适用于国外用户）\ncurl -sL https://git.io/cpolar | sudo bash\n\n软件不是很大，一下子就下好了\n\n使用这个语句查看版本信息\ncpolar version\n\n如果出现下图代表已经安装OK了\n\n2.2token验证注册账号后，选择了免费界面，你就可以进入后台管理系统\n点击验证，可以找到你的隧道Authtoken\n\n复制它，然后在树莓派上用下面的语句设置token\ncpolar authtoken xxxxxxxxxxxxxxxxxx\n\n\n2.3设置cpolar开机自启和系统保护开机自启动\nsudo systemctl enable cpolar\n\n守护进程方式，启动cpolar（类似于把cpolar设置成了白名单应用）\nsudo systemctl start cpolar\n\n查看守护进程状态\nsudo systemctl status cpolar\n\n\n如图，状态为active, 说明启动状态成功\n2.4查看隧道端口cpolar会默认安装两个样例隧道，一个是Website隧道指向http 8080端口，一个是ssh隧道，指向tcp 22端口\n为了不暴露我自己的SSH连接地址，这里直接丢官方帮助文档里面的图\n\n和官方这里不同，我的后台管理中只有两个website地址和一个ssh地址\n2.5使用putty或者Xshell远程连接树莓派确认你的ssh连接后，需要在树莓派本地设置一下\nssh pi@1.tcp.vip.cpolar.cn -p 20013\n\n这里会让你填写树莓派的密码，并不是cpolar的密码\n填写完毕后，到这里已经设置完毕啦！是不是很简单？\n\n下面来试试远程使用树莓派\n假设我们的SSH地址是下面这个\ntcp://1.tcp.vip.cpolar.cn:20013\n\n那么在Xshell中的主机和端口分别就要填写\n\n主机1.tcp.vip.cpolar.cn\n端口20013\n\n然后就能连接上你的树莓派\n这里需要你输入你树莓派的用户名和密码，输入完毕后，就和局域网使用树莓派没啥区别啦！\n\n我搜资料的时候，就是这里填错了，导致一直没连上树莓派\n\n结语如果对于初始化设置cpolar有啥问题，可以在评论区留言\n复杂问题别问，我不会！！！！！😂\n","categories":["没事就吃树莓派"],"tags":["Linux","树莓派"]},{"title":"【树莓派】实验00-配置你的树莓派","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C00-%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE/","content":"\n\n前言为了完善本专栏的内容，这次我把树莓派的初始化配置也给大家加上。\n干货满满，跟着我一步一步配置，从无到有玩转树莓派！😋\n\n当然前提是你要有一个树莓派，2022年的树莓派价格可太魔幻了，涨价1倍，堪比显卡市场……\n\n不扯这些没用的了，本篇博客，带你走入树莓派这款小电脑的世界！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.什么是树莓派？Raspberry Pi(中文名为“树莓派”,简写为RPi，或者RasPi &#x2F; RPI\n它为学习计算机编程教育而设计，是一个只有信用卡大小的微型电脑，其系统基于Linux。 自问世以来，受众多计算机发烧友和创客的追捧，曾经一“派”难求。别看其外表“娇小”，内“芯”却很强大，视频、音频等功能通通皆有，可谓是“麻雀虽小，五脏俱全”。\n\n它是一款基于ARM的微型电脑主板，以SD&#x2F;MicroSD卡为内存硬盘，卡片主板周围有1&#x2F;2&#x2F;4个USB接口和一个10&#x2F;100 以太网接口（A型没有网口），可连接键盘、鼠标和网线，同时拥有视频模拟信号的电视输出接口和HDMI高清视频输出接口，以上部件全部整合在一张仅比信用卡稍大的主板上，具备所有PC的基本功能只需接通电视机和键盘，就能执行如电子表格、文字处理、玩游戏、播放高清视频等诸多功能。\n Raspberry Pi B款只提供电脑板，无内存、电源、键盘、机箱或连线。\n\n这种历史啥的就不说太多啦，想必大家都懒得看这种东西😂\n\n1.1什么用户适合购买树莓派学习编程？\n在淘宝搜索树莓派，你会发现绝大部分商家都挂着“0基础学习的”幌子，大肆宣传。而且宣传集中于最近挺火的python语言，对C和C++只是提一嘴。\n\n作为C&#x2F;C++方向的编程学习者，我个人建议，购买树莓派之前，需要先学习完初阶的C语言。如何量化呢，大概就是要把目前b站最火的这个C语言视频看到P24👉 传送门\n\n如果你和我一样购买的是带各类电子元件的套件。在树莓派基础实验中，主要利用的是wiringPi库，这个库和C语言自己的框架其实是没啥关系的，即便你把这个库全学完了，也不一定能精通C语言。相反，如果C语言什么都不会的话，肯定也整不明白这个库里面的函数是怎么用的。\n\n说的可能有点绝对，我的意思主要是：如果你之前没有学过编程，得先把某一个语言学完了，再来谈购买树莓派进行进阶学习的事\n\nPython同理，肯定要把基础的语法什么都学会了，再考虑购买树莓派进行进一步的学习。\n商家玩的多半也是文字游戏，“零基础学习”代表你可以零基础上手树莓派，而不能利用树莓派从0开始学习编程，这是很难的。\n\n2.如何初始化一个树莓派首先准备好咱们需要的东西\n\n树莓派开发板\n5V3A电源\nmicroSD卡（16G起步，建议32GB）\n一台能上网的windows电脑\n\n然后，我们要下好下面的一些软件\n\nPutty (SSH远程连接工具)\nAdvanced_IP_Scanner （局域网ip查找工具）\nbalenaEtcher（镜像烧录工具）\nFileZilla（文件传输工具）\nVNC-Viewer（远程桌面软件）\nnotepad++（编辑文本）\n\n树莓派的系统可以去官方下载👉官方下载站\n但是官方下载下来的系统非常纯净，几乎所有东西都要我们自己安装，包括中文输入法，编译器，以及各类需要用到的软件\n\n为方便大家的使用，这里我整理了一些要用到的软件，以及一个已经搭建好基本环境的树莓派系统，大家直接下载我这里的集合包就行了！某度云\n\n如果你想从0开始配置一个树莓派系统，可以看这个专栏学习👉传送门\n\n\n2.1 烧录系统首先将SD卡插入windows电脑，右键，格式化它\n\n很多博主这里都说要用特别的格式化软件，实际上大可不必，直接用win自带的格式化就行了\n\n然后打开balenaEtcher，选择树莓派系统镜像文件.img，然后再选择你的sd卡\n\n\n然后这个软件就会自动开始flash你的系统，你要做的就是等它自己搞定，这期间不要插拔SD卡\n\n\n搞定以后，你的SD卡会变成一个只有256mb的boot启动盘，不要担心，这是树莓派的系统已经将另外一部分磁盘给自己了\n\n右键我的电脑-管理-磁盘管理，即可看到消失的那部分容量\n\nwin10可能会提示你使用前要先格式化磁盘G，一定不要格式化！！！不然你的系统就寄了\n\n这时候我们就可以配置我们的树莓派了\n2.2 测试开机将sd卡插入树莓派（注意方向），接通电源，如果树莓派的红灯常亮，绿灯闪烁的话，那就是系统正在运行了。这时候先断开电源，进行后面的操作\n\n2.3 设置树莓派显示输出的分辨率不管你是直接让树莓派接显示器，还是用VNC来远程链接树莓派，我们都可以通过更改config文件来设置树莓派的分辨率\n\n滑倒最底部，找到hdmi_vct，它后面紧跟着的3个参数分别是分辨率的长宽，以及输出的刷新率\n\n为了减小树莓派的运算负担，我把分辨率设置的比标准1080p（1920x1080）低了一点。实际上树莓派是支持4k60输出的。\n如果你使用hdmi直接接显示器，请根据你的显示器参数来设置树莓派的输出，以防接上后无画面输出的情况\n\n其实哪怕有显示器也建议你直接使用VNC，每次都连线太麻烦了\nVNC的使用后面会讲到\n\n\n2.4 网络链接如果你有网线，直接将树莓派用网线接入网络即可。这里介绍没有网线的方法，即 将树莓派接入wifi。\n我分享的配置文件里面，有这两个WiFi配置文件\n\n使用notepad++打开wpa_supplicant.conf文件，可以看到下面的这些东西。依照图中的注释填写wifi信息即可！wifi名字和密码不要设置成中文的\n\n如果你有多个wifi，可以在原有network之后继续添加network，填写方法是一样的\ncountry=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;\tssid=&quot;zhulin&quot;\tpsk=&quot;12345678&quot;\tpriority=5&#125;network=&#123;\tssid=&quot;zadf&quot;\tpsk=&quot;12345678&quot;\tpriority=3&#125;\n\n搞定了之后，将这两个文件都放入树莓派的boot盘\n注意：树莓派开机后这两个文件会消失，如果需要更改wifi配置，写好新的文件放入boot盘即可\n\n\n如果是你家里的wifi，可以在wifi的管理后台（一般比较新的wifi都有自己的app可以管理，旧的WiFi也有网页端管理页面）找到树莓派的ip\n如果是笔记本&#x2F;手机开的热点，可以直接在热点管理里面看到已连接设备的ip。如果是手机开热点的话，需要将电脑也接入同一热点。\n校园网不算局域网，建议开热点进行操作\n\n如果你不知道怎么找树莓派的ip，直接使用之前提到的ip扫描软件Advanced_IP_Scanner就可以了！\n\n记下树莓派的ip，后续所有操作都要通过它来实现\n注意：即便是连同一个WiFi，树莓派的ip也不是一直不变的，如果在某次使用时出现无法链接的情况，请检查ip是否已经改变了\n\n2.5 Putty链接树莓派比起windows电脑的图形桌面，树莓派是一个linux小主机，使用linux的时候我们更应该学习linux命令行的使用，而不过度依赖于树莓派系统本身\nputty的使用也很简单，直接输入树莓派的ip即可，默认的端口都是22，无需更改\n\n在弹出来的界面输入用户名pi，输入密码的时候要盲打，它不会显示你输入了啥\n\n当输入完密码后，会弹出下面的界面，这就代表你的树莓派已经链接上了\n\n输入sudo raspi-config可以进入树莓派的系统设置，我们需要将VNC的服务开启，这样才能使用VNC远程链接树莓派的桌面\n\n用方向键选择5 Interfacing Options，找到VNC服务，回车选择它，会提示你是否开启（enable）VNC服务，我们选择是就可以了\n\n选择完毕后回到初始菜单，要选择下面的finish使得设置生效\n操作方法是来到P8后按方向键的左右，才能选择底部的Select和Finish\n随后输入sudo reboot重启树莓派，使得设置生效。\n到这里，putty的初始化设置就完成了\n\n2.6 VNC链接树莓派因为我的树莓派烧录的是提前搭建好基本环境的系统，所以这里面我们直接用VNCviewer来远程链接树莓派的桌面\n操作很简单，输入树莓派的ip\n\n然后在弹出的界面上输入默认用户名pi和密码raspberry即可\n\n现在你看到的就是树莓派的桌面啦，是不是和一个普通的windows电脑差不了太多呢？\n\n右键桌面可以更改壁纸\n\n\n这里的操作和使用一台电脑没啥区别，就留给大家自己尝试啦！\n\n2.7 使用filezilla软件传输文件到树莓派安装filezilla软件，它可以通过wifi在我们的windows电脑和树莓派之间传输文件\n\n链接树莓派后，这里出现了两个界面，其中左边是我们电脑里面的文件，右边是树莓派里面的文件，我们直接进行拖动操作即可\n传输完毕后，filezilla会弹出系统通知\n\n注意：这里新建文件夹的操作叫“创建目录”\n\n\n恭喜你，你的树莓派已经初始化完毕啦！可以愉快的用它学习代码了！\n不过别急着关闭本篇博客，后面还有东西呢！\n\n3.使用Xshell将树莓派作为linux主机有这么一个软件，它集成了putty和filezilla的功能，界面更好看，使用也更方便\n没错，他就是Xshell！\n\n它同样可以使用sudo raspi-config进入树莓派的系统设置，同时借助该公司的Xftp软件，它也能实现一样的传输文件功能！\n\n\n今天刚下载Xshell软件，当我把它连上树莓派的时候，感觉自己从本世纪初穿越到了2022年。这界面，终于不再是那个古早的模样了，太感动了！\n\n3.1下载Xshell点进官网的下载界面，一看，我去，只有30天试用，玩球啊！\n要是这么想，你就太年轻了\n让我们来康康右下角这里写着啥，“免费授权”！\n\n只要你填写你的姓名和邮箱号，官方就会把这两个软件的下载链接发到你的邮箱。\n\n个人用户（非商用）的话，这两个软件都是免费的！\n\n唯一的缺点就是在你关闭页面的时候，它会弹出来这样一个页面，不过这也不影响啦！\n\n3.2链接树莓派安装的步骤直接无脑下一步\n打开Xshell，这时候我们还没有设置过服务器，所以是空\n\n点击新建，进入设置服务器的界面，写入你的树莓派IP，并给这个会话起个名\n\n点击链接，会弹出来让你输入你的树莓派用户名和密码，和之前一样操作就行\n\n\n然后，他就建立链接啦！\n\n3.3编码设置点击这里的属性\n\n选择终端，找到右下角的编码，确认它是UTF-8的状态，不然中文会乱码\n\n3.4打开Xftp点击上面这个绿色的文件夹就会打开Xftp，快捷键是CTRL+ALT+F\n\n后续的操作也是直接拖动文件，没什么好说的~~\n\n4.树莓派连接面包板树莓派上有40个IO口，为了方便实验，一般会采用一个转接板把树莓派的IO信号转接出来，使用面包板进行GPIO外接。我们需要以下3个部件：\n\n40p软排线\nT型转接板\n面包板\n\n\n安装40p软排线的时候，要注意软排线上有一个小三角，它要对准树莓派USB接口的另一侧的接口，依照这个方向插入软排线。请平均用力，不要大力出奇迹！\n\n40p排线的另一端就是链接T型转接板了，链接这个就很简单，T型转接板上会有一个凹槽，对准凹槽方向插入即可\n\n然后将T型转接板对准面包板中央的孔位插入即可！G17 G18对准行号1的孔位\n\n5.进阶操作用上Xshell和面包板，你的树莓派已经是一个完全体啦！\n其他的一些操作，可以看看我的另外一个树莓派的专栏👉传送门\n\n如果本篇博客对你有帮助的话，还请点赞支持一下哦！\n\n有什么问题，欢迎在评论区提出！看到了就会回复的\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验01-双色LED","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C01-%E5%8F%8C%E8%89%B2LED/","content":"\n\n前言今晚上没啥事（其实作业没写完），就开始折腾树莓派了\n我当初买的是树莓派4B(4GB)版本的套件，东西还是非常全的，店家还送了全套学习资料+指导视频，加上一本还算不错的书。\n本篇博客，让我们一起来完成第一个实验：双色LED\n\n学习资料来源于：湖南创乐博智能科技有限公司\n本博客仅供参考，请勿转载！\n\n\n1.实验器材\n装好系统的树莓派开发板+电源适配器\n面包板+T型转接板\n40p软排线\n双色LED\n若干跳线\n\n\n2.实验原理将引脚S（绿色）和中间管脚（红色）链接到面包板的接口上，对树莓派进行编程控制，使LED的颜色由红变绿。并利用PWM混合成其他颜色。\n\n对应接线表格\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPI01\nGPI018\nS\n\n\nGPI00\nGPI017\nR\n\n\nGND\nGND\nGND\n\n\n实际接线图如下（手机画质也太渣了）\n\n3.控制代码当树莓派需要与外部元件相接时，要用到一些写好的库。如树莓派wiringPi库\n\n树莓派wiringPi库：wiringPi是一个很棒的树莓派IO控制库，使用C语言开发，提供了丰富的接口：GPIO控制，中断，多线程，等等\n\n还有softPwm.h库：GitHub链接\n\n本次双色LED实验需要用到的就是这两个库，以及C语言自带的库函数stdio.h\n代码如下：\n#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt;#include &lt;stdio.h&gt;#define uchar unsigned char#define makerobo_Led_PinRed    0 // 红色LED 管脚#define makerobo_Led_PinGreen  1 // 绿色LED 管脚// LED 初始化void makerobo_led_Init(void)&#123;\tsoftPwmCreate(makerobo_Led_PinRed,  0, 100);\tsoftPwmCreate(makerobo_Led_PinGreen,0, 100);&#125;// 设置LED 亮度PWM调节范围是0x00-0xffvoid makerobo_led_ColorSet(uchar r_val, uchar g_val)&#123;\tsoftPwmWrite(makerobo_Led_PinRed,   r_val);\tsoftPwmWrite(makerobo_Led_PinGreen, g_val);&#125;int main()&#123;    //初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\tmakerobo_led_Init(); // LED 初始化\twhile(1)&#123;\t\tmakerobo_led_ColorSet(0xff,0x00);   //红色\t\t\tdelay(500);                         //延时500ms\t\tmakerobo_led_ColorSet(0x00,0xff);   //绿色\t\tdelay(500);\t\tmakerobo_led_ColorSet(0xff,0x45);\t\t\tdelay(500);\t\tmakerobo_led_ColorSet(0xff,0xff);\t\t\tdelay(500);\t\tmakerobo_led_ColorSet(0x7c,0xfc);\t\t\tdelay(500);\t&#125;\treturn 0;&#125;\n\n在wiringPi库中，可以看到两个函数的使用说明\n\nCreate函数相当于初始化针脚\nWrite函数会更改该管脚的pwm值，以达到控制LED亮度的目的\n\n\n3.1显示器的PWM调光和DC调光如果你有了解过显示器的选购知识，估计听说过显示器的PWM调光和DC调光。\n使用DC调光的显示器，屏幕背光将常亮；使用PWM调光的显示器，屏幕背光将高速开关来点亮屏幕。只要PWM高于一定值，人眼就分辨不出该屏幕的闪烁。当一块显示器使用高频PWM调光时，我们认为它与DC调光没有太大的区别。\n但总的来说，使用DC调光技术的显示器更加“护眼”，而使用低频PWM调光的显示器就是极度辣眼睛（这也是有些屏幕在摄像头中会屏闪的原因）\n目前主流手机都上了OLED屏幕，该屏幕材质普遍使用的是PWM调光。部分手机厂家在屏幕设置中推出了“类DC调光选项”，其原理就是用高频PWM来模拟DC调光。\n\n如果你想了解这方面的知识，可以看看这个视频👉链接\n\n好像bb了一些和这个实验没啥关系的内容，赶快回到正题！\n\n3.2 编译代码树莓派中有两种方式编译运行我们的代码\n3.2.1直接使用Geany编译器内部选项\n\n3.2.2 使用linux语言树莓派的系统是基于linux的，我们可以使用linux中的gcc语言来编译这个.c文件\n\n在本专栏之前的博客中，有介绍过这种方式👉链接\n\n\n输入指令，你会发现系统报错显示delay函数未定义\nundefined reference to `delay`\n\n\n这是因为delay函数并不是一个C语言的库函数我，我们可以在前面自己整一个delay函数的原型\n\n第一次使用Geany编译的时候并没有报错，这是因为在Geany里面已经用生成命令引用了wiringPi库\n在Geany的build(生成)--&gt;set build commands(设置生成命令）中输入以下指令gcc -Wall -c &quot;%f&quot; -lwiringPi\n\n// 延时z毫秒的delay函数void delay(unsigned int z)&#123;    unsigned int i,j;    for(i=z;i&gt;0;i--)        for(j=110;j&gt;0;j--)            ;//利用无意义的for循环来进行延时&#125;\n\n我们在linux控制台中用cd打开文件路径后，输入如下指令\n1. gcc 01DuoColorLED.c -o GPIO -lwiringPi2. -lwiringPi选项，链接WiringPi库。\n\n第一条指令是编译程序，生成可执行文件GPIO\n\n使用./GPIO指令来执行此文件\n\n需要注意的是，用这种方法运行程序不太方便终止，你可以去掉main函数中的while循环，让变色只执行一次。\n\n所以在进行此类开发时，建议直接使用Geany编译器，因为它会生成一个前台控制面板，我们可以直接用ctrl+c停止程序\n\n奇怪的是，当我运行第一个Geany编译器生成的可执行文件时，LED会正常变色。\n但是运行第二个在linux控制台生成的GPIO文件时，却不能变色。不知道是什么原因\n\n而当我重新用Geany编译器编译这份加了delay函数定义的代码时，发现这个delay函数还是不太行啊！这灯都闪的飞快，真的有500ms吗\n\n不过这也不算什么大问题，咱们可以通过调整delay函数的定义，和调用参数来控制\n\n4.如何在使用面包板的同时使用散热小风扇原本不使用面包板的时候，小风扇可以插在板载针脚的2、3位\n\n但是现在使用了面包板，这整个针脚都被占用了，风扇往哪里插呢？\n很简单，使用两根跳线，将风扇与面包板上的5v和GND链接就行了！\n\n红线接5V\n黑线接GND\n\n\n\n结语不管如何，这次实验算是完美完成啦！\n这也是我在树莓派上做的第一个实验\n\n如果你想和我一起学习树莓派，那就关注本专栏吧！\n欢迎star本专栏代码仓库：GITEE链接\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验02-RGB小灯","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C02-RGB%E5%B0%8F%E7%81%AF/","content":"\n\n前言又到了树莓派学习的时候！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n上一次的实验001-双色LED中，虽然我把博客展示了出来，写的好像有模有样的，实际上我对一些函数可谓是丝毫不懂。\n但这次不一样了，我把一些函数的基本使用给整明白了！\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板\n跳线一堆\nRGB小灯\n\n通过这次试验，我们可以基本了解一下让电脑性能提升200%的RGB的底层控制\n\n1.1树莓派运行库准备当树莓派需要与外部元件相接时，要用到一些写好的库。如树莓派wiringPi库\n\n\n树莓派wiringPi库：下载&#x2F;安装教程\n\n下载softPwm.h库：GitHub链接，安装教程见README\n\n\n\n\n2.元件接线RGBled模块的电路图如下，其与实物图是对应关系\n\n\n以下是本次实验的接线图\n\n其实这里我没搞懂这个5V是用来干什么的，因为不接好像也没有关系\n\n让我无语的是，去问店家，客服回复是“原理需要自己学习”\n看来还是得靠自己\n\n大胆猜测一下，后续的实验需要更多接5V的设备，这个5V引线就好比我们每次编写C语言都需要用stdio.h一样，是一个习惯。\n同时解释一下面包板左右两条线的作用：\n\n当你把GND用引线接到蓝色-线上，此时那一排都是GND\n当你把5V用引线接到红色+上，红色一排都是5V了\n\n这就相当于串联线路\n\n\n3.函数解释这里需要用到两个函数： softPwmCreate和softPwmWrite\n上篇博客中我只给出了这两个函数的解释文档（偷懒），这篇博客让我们来真切认识一下这两个函数的作用\n\n以下是函数原型，以及官方解释的翻译\nint softPwmCreate (int pin, int initialValue, int pwmRange) ;\n\n这将创建一个软件控制的PWM引脚。您可以使用任何GPIO引脚，引脚编号将与您使用的wiringPiSetup()函数相同。\ninitialValue是初始值，如果pwmRange使用100，那么给定引脚的值可以是0（关闭）到100（完全打开）之间的任何值。 返回值为0表示成功，-1代表失败。\n如果还有其他情况，您应该检查全局errno变量，看看哪里出了问题。\nvoid softPwmWrite (int pin, int value) ;\n\n更新给定引脚pin上的PWM值。该值将被检查是否在范围pwmRange内\n未通过softPwmCreate初始化的管脚将被忽略\n后续还有一个Note：\n\n\n\nPWM输出的每个“周期”需要10毫秒，默认范围值为100，因此尝试每秒更改PWM值超过100次将是徒劳的\n\n在softPWM模式下激活的每个引脚使用大约0.5%的CPU\n\n目前无法在程序运行时禁用引脚上的softPWM\n\n您需要保持程序运行以保持PWM输出！\n\n\n\n3.1关于softPwmWrite的使用问题，大大的疑惑这里我产生了一个巨大的疑惑，就是softPwmWrite函数的第二个参数究竟应该如何使用\n\n这个问题我在CSDN的问答区提问了，22.04.01的17:00目前还没有回复👉点我\n\n可以看到下面这位大佬的程序中，是将第二个参数设置到超过了100\n\n引用自博客https://www.cnblogs.com/demo-lv/p/14017488.html\n\n\n而参考资料中，提供的代码也是将pwm值设置超过了100\n\n在查询过一些资料（是真的没有博客提到过这个问题），我找到了RGB颜色对照表\n这个代码中提供的参数设置，其实是参照RGB表来设置的\n\n\n也就是说，如果想达到混色的效果，你需要利用softPwmWrite函数将红绿蓝针脚与RGB表中的数值对应进行输出。\n但这不就和官方的pwm值应该在范围内，且超过100的pwm值都是无效的，冲突了吗？\n\n这个问题先暂时放在这里，蹲一个大佬解释\n\n4.代码样例4.1初始化针脚#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt;#include &lt;stdio.h&gt;#define makerobo_Led_PinRed    0 // 红色LED 管脚#define makerobo_Led_PinGreen  1 // 绿色LED 管脚#define makerobo_Led_PinBlue   2 // 蓝色LED 管脚// LED 初始化void makerobo_led_Init()&#123;//第三个参数是range，将pwm设置成100（全开）\tsoftPwmCreate(makerobo_Led_PinRed,  0, 100);\tsoftPwmCreate(makerobo_Led_PinGreen,0, 100);\tsoftPwmCreate(makerobo_Led_PinBlue, 0, 100);&#125;\n\n你可能会想，为什么这里要把红绿蓝的管脚设置成0、1、2，实际上这里和面包板的接线是对应的\n\n可以看到，GPIO 0/1/2分别对应的是17/18/27，同我们第2点中接线图上的针脚位置对应\n\n4.2颜色参数设置初始化针脚之后，我们就来设置各个针脚的参数\n// LED 颜色设置void makerobo_led_Color_Set(uchar r_val, uchar g_val, uchar b_val)&#123;//对应不同颜色针脚的设置，如果需要红色，就只给红色r_val传对应值 //给不同颜色输入不同值，达成混色的效果！\tsoftPwmWrite(makerobo_Led_PinRed,   r_val);\tsoftPwmWrite(makerobo_Led_PinGreen, g_val);\tsoftPwmWrite(makerobo_Led_PinBlue,  b_val);&#125;//函数使用如下makerobo_led_Color_Set(0xff,0x00,0x00);   //红色\tdelay(500);   //延时500ms，使更改便于观察makerobo_led_Color_Set(0x00,0xff,0x00);   //绿色delay(500);                makerobo_led_Color_Set(0x00,0x00,0xff);   //蓝色delay(500);\n\n4.3完整代码及效果演示下面给出完整代码，以及最终的效果、\n#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt;#include &lt;stdio.h&gt;#define uchar unsigned char#define makerobo_Led_PinRed    0 // 红色LED 管脚#define makerobo_Led_PinGreen  1 // 绿色LED 管脚#define makerobo_Led_PinBlue   2 // 蓝色LED 管脚// LED 初始化void makerobo_led_Init()&#123;//第三个参数是range，将pwm设置成100（全开）\tsoftPwmCreate(makerobo_Led_PinRed,  0, 100);\tsoftPwmCreate(makerobo_Led_PinGreen,0, 100);\tsoftPwmCreate(makerobo_Led_PinBlue, 0, 100);&#125;// LED 颜色设置void makerobo_led_Color_Set(uchar r_val, uchar g_val, uchar b_val)&#123;//对应不同颜色针脚的设置，如果需要红色，就只给红色r_val传对应值 //给不同颜色输入不同值，达成混色的效果！\tsoftPwmWrite(makerobo_Led_PinRed,   r_val);\tsoftPwmWrite(makerobo_Led_PinGreen, g_val);\tsoftPwmWrite(makerobo_Led_PinBlue,  b_val);&#125;int main()&#123;    //初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123;\t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\tmakerobo_led_Init();\t\tint n=0;\tprintf(&quot;请输入循环周期的次数&gt;&quot;);\tscanf(&quot;%d&quot;,&amp;n);//输入循环周期的次数\twhile(n--)\t&#123;\t\tmakerobo_led_Color_Set(0xff,0x00,0x00);   //红色\t\t\tdelay(500);   //延时500ms，使更改便于观察\t\tmakerobo_led_Color_Set(0x00,0xff,0x00);   //绿色\t\tdelay(500);                   \t\tmakerobo_led_Color_Set(0x00,0x00,0xff);   //蓝色\t\tdelay(500);\t\tmakerobo_led_Color_Set(0xff,0xff,0x00);   //黄色\t\tdelay(500);                 \t\tmakerobo_led_Color_Set(0xff,0x00,0xff);   //粉色\t\tdelay(500);     \t\tmakerobo_led_Color_Set(0xff,0xff,0xff);   //白色\t\tdelay(500);       \t\tmakerobo_led_Color_Set(0x94,0x00,0xd3);   //紫色\t\tdelay(500);\t\tmakerobo_led_Color_Set(0x76,0xee,0x00);   //偏黄色\t\tdelay(500);\t\tmakerobo_led_Color_Set(0x00,0xc5,0xcd);\t  //淡蓝色\t\tdelay(500);\t&#125;\t\t//最后循环结束时，关闭LED（如果不这么设置，LED灯会停留在最后一个颜色）\tmakerobo_led_Color_Set(0x00,0x00,0x00);\t//参数都为0,相当于关灯\tdelay(500);//如果不延时，效果无法展示出来\t\treturn 0;&#125;\n\n使用树莓派Geany编译器，三板斧点起来\n\n最后的结果如下图~~RGB小灯变色循环成功！\n\n\n4.4 Linux-GCC编译器指令Geany已经可以很好地执行我们的程序了，但它未免有点太easy了，点几下按钮就能搞定\n我们来试试需要敲语句的GCC编译器\n首先依旧是用cd打开源文件的目录\ncd 打开源文件存放的目录ls 列出当前文件路径下的所有文件\n\n使用wiringPi库和softPWM库需要加上两个指令\n\nwiringPi库对应：-lwiringPi\nsoftPWM库对应：-lpthread\n\n在linux的gcc中使用delay函数需要调用另外一个头文件&lt;unistd.h&gt;\ngcc -Wall 02rgbled.c -o TEST -lwiringPi -lpthread\n\n如果没有报错的话，那就是编译成功了，再次ls可以看到多出来了一个TEST可执行文件\n\n./TEST 执行TEST文件\n\n可以看到程序正常运行了！\n\n\n结语第二个树莓派实验也做完啦！\n虽然还有问题没有解决，但我还是很开心的\n\n如果对你有帮助，还请点个大大的👍！有什么问题可以评论区提出来哦\n\n通往大佬的路非常漫长……\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验03-七彩LED","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C03-%E4%B8%83%E5%BD%A9LED/","content":"\n\n\n\n前言学习太累，那就玩玩树莓派“陶冶情操”吧！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1.实验器材\n树莓派4B开发板\n40p软排线+T型转接板+面包板\n七彩LED模块\n跳线若干\n\n\n2.实验接线七彩LED模块内置了IC芯片，因此无需编写代码，只需通电就能看到LED闪烁。\n不同型号的七彩LED模块，内置的闪烁情况会有所区别，如闪烁快慢和亮度等\n\n七彩LED模块只需串联一个限流电阻即可构成控制电路，示意图如下\n\n所以我们接线的时候，只需接上VCC和GND即可\n\n\n\n树莓派\nT型转接板\n七彩LED模块\n\n\n\nGND\nGND\nGND(中间管脚)\n\n\n5V\n5V\nVCC(一旁标有S)\n\n\n\n前两次实验中，我对每次都需要接5v线却并没有连接设备感到疑惑\n本次实验正好印证了我在02RGBled实验博客里做出的猜测！\n实物接线图如下👇\n\n3.实验效果将电路接通，可以看到LED闪烁了7种颜色，且有不同的闪烁方式！\n\n这不比自己写代码控制的更帅？（bushi）\n如果你想知道如何用代码控制一个LED模块，可以看看我的前两篇树莓派实验的博客\n\n实验02：RGB小灯 \n实验01：双色LED\n\n结语本次实验的内容不多撒，咱也见识了内置小芯片的快乐（指不需要自己写控制代码）\n下一次的实验是继电器实验，这部分涉及到一些原理，看来要秃头了\n\n如果你觉得本篇博客挺有意思，那就点个赞，顺便收藏一下我的树莓派专栏吧！\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验05-激光传感器","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C05-%E6%BF%80%E5%85%89%E4%BC%A0%E6%84%9F%E5%99%A8/","content":"\n\n前言我手头的资料上，又说了一堆和本实验相关但又毫不相关的内容\n还是得自己找资料才能确认我的“猜想”，具体是啥，且往下细看！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n激光传感器模块（其实只是一个发射器）\n跳线若干\n\n2.实验原理激光传感器常见于测距用途。它由激光发射器、激光检测器和测量电路组成。它的优点是能够实现无接触远距离测量，速度快，精度高，量程大。\n激光传感器模块由一个650nm红色激光二极管头和一个电阻器组成\n\n激光传感器工作时，先由激光发射二极管对准目标发射激光脉冲。经目标反射后激光向各方向散射。部分散射光返回到传感器接收器，被光学系统接收后成像到雪崩光电二极管上。雪崩光电二极管是一种内部具有放大功能的光学传感器，因此它能检测极其微弱的光信号，并将其转化为相应的电信号。\n\n书上介绍了这么一堆，弄的好像这个小家伙就集成了上面3个传感器一样。我刚看书的时候，一脸懵逼，这么小一个玩意就能测距？自己找了资料才能勉强确认，它就是一个单纯的激光发射器罢了。\n\n作为一个萌新，书上的内容的确对我产生了误导，还需要自己查阅资料，有点浪费时间。\n\n\n2.1电路图\n2.2接线图\n\n\n树莓派\nT型转接板\n激光传感器模块\n\n\n\nGIPO 0\nGPIO 17\nSIG(S)\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND(-)\n\n\n\n实物接线图如下，本实验接线比较简单\n\n右上角的红黑线是接给树莓派散热风扇的，和本实验无关\n\n\n\n3.代码示例老样子，给出C语言代码。\n#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_LaserPin 0  //定义激光传感器管脚int main()&#123;\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\t\tpinMode(makerobo_LaserPin, OUTPUT); // 激光传感器设置为输出模式\t\tint k=2;\twhile(k--)\t&#123;\t\tdigitalWrite(makerobo_LaserPin, HIGH); //打开激光传感器\t\tdelay(1000); //延时1s                           \t\tdigitalWrite(makerobo_LaserPin, LOW);  //关闭激光传感器\t\tdelay(1000); //延时1s    \t&#125;\t\tdigitalWrite(makerobo_LaserPin, LOW); //循环结束后，恢复关闭状态\tdelay(500); \t\treturn 0;&#125;\n\n\n代码中的两个wiringPi函数在上篇实验博客中有讲解👉传送\n\n3.1Genay编译器老样子，三板斧（其实这句话都是从之前的博客复制过来的😂）\n\n\n在Geany里面用生成命令引用wiringPi库\n在Geany的build(生成)--&gt;set build commands(设置生成命令）中输入以下指令gcc -Wall -c &quot;%f&quot; -lwiringPi\n\n效果如下，激光发射器在延时后不断开关\n请不要将激光发射器对准任何人！伤眼！！！\n\n\n3.2LinuxGcc编译器\n为了防止Linux-Gcc环境中无法正常终止程序，建议不要使用while(1)死循环。你可以将k设置得大一点，方便观察实验结果\n\ncd打开对应文件路径，ls显示当前路径下的文件\n输入以下指令编译代码，生成可执行文件TEST\ngcc -Wall 05laser.c -o TEST -lwiringPi\n\n./TEST运行可执行文件\n\n如果没有报错，那就是编译成功了，你可以观察到相同的实验结果\n结语欸这博客都看到这里了，怎么不点关注啊？\n就算你不想关注我，那就关注一下专栏嘛！👉传送门\nTNND！关注，为什么不关注！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验04-继电器","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C04-%E7%BB%A7%E7%94%B5%E5%99%A8/","content":"\n\n\n\n前言学习树莓派的时候经常要查找前辈们留下的资料\n\n但我发现，有一些博客，写的真的不敢恭维。\n无注释源码一贴，电路图一贴，什么解释都没有，就发出来了。\n这是写给谁看的？恐怕自己过几个月回头看自己都不知道那是什么意思。这样的学习有啥意义呢？\n\n有的人可能觉得我是想抄作业，的确！嵌入式学习需要了解各个元件的工作原理，我的资料单有电路图远远不够啊……即便有源码，也需要自己去弄明白每个函数的作用，不然这样的学习依旧没有意义😥\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n继电器模块+十字螺丝刀\n双色LED模块（实验1使用过）\n跳线一堆\n\n2.实验原理2.1继电器模块继电器模块是一种电控制期间，当输入量的变化达到规定要求时，在电气输出电路中使被控制量发生预定阶跃变化的一种电器。它具有控制系统和被控制系统之间的互动关系，通常运用于自动化的控制电路中。它实际上是用小电流去控制大电流运作的一种“自动开关”，在电路中起到自动调节、安全保护、转换电路等作用。\n\n说人话就是，继电器是一个电动开关，通过接收外部源的电信号来打开和关闭电路。\n例如：按下电视机遥控器的开启按钮，它向电视节内部的“继电器”发出电信号，从而打开电视机的主电源开关。不过电视机内部还有另外的信号接收器，继电器本身不一定能接收红外信号（个人理解）\n\n2.2继电器工作\n当继电器供电时，电流开始经过控制线圈\n电磁体开始通电，将上部衔铁吸附到线圈上，带动触点向右移动，从而与常开触点链接\n带负载的电路通电\n继电器断开供电，弹簧会将触头复位，电路断开\n\n\n\n3.电路图和接线图3.1电路图继电器模块的电路图如下\n\n模块实物图如下\n\n\n引用另外一篇博客对各个接口的介绍👉原文链接\n\n\n3.2接线图继电器的主控制型号源接在GPIO17，和端口0对应（后面代码会用到）\n\n\n\n\n树莓派\nT型转接板\n继电器模块\n\n\n\nGPIO 0\nGPIO 17\nIN\n\n\n5V\n5V\nDC+\n\n\nGND\nGND\nDC-\n\n\n5V\n5V\nCOM\n\n\n\n\n\n双色LED\nT型转接板\n继电器\n\n\n\n中间（R）\n*\nNC\n\n\nGND\nGND\n*\n\n\nS(G)\n*\nNO\n\n\n由于双色LED模块的G接口(Green)接到了继电器的常闭端口NC（即继电器未接通时默认接上的端口）\n所以在接线完毕后，LED模块会亮绿灯\n\n这里需要注意的是，在对继电器接线的时候，需要用螺丝锁住各条线位，不然它们是接不稳的\n\n\n4.代码示例这里给出C语言的代码\n#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_RelayPin 0 //设置继电器GPIO管脚，0对应G17int main()&#123;    //初始化连接失败时，将消息打印到屏幕\t\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\t\t//将继电器管脚设置为输出模式\tpinMode(makerobo_RelayPin, OUTPUT);\t\tint k=2;\twhile(k--)\t&#123;\t\t\tdigitalWrite(makerobo_RelayPin, HIGH); // 打开继电器\t\t\tdelay(1000);                           // 延时1s\t\t\t\t\tdigitalWrite(makerobo_RelayPin, LOW);  // 关闭继电器\t\t\t\t\t\tdelay(1000);                           // 延时1s\t&#125;\treturn 0;&#125;\n\n4.1部分函数解释4.1.1pinMode该函数的作用是设置针脚当前的模式\n\n4.1.2digitalWrite可以看到，这里提到了在使用该函数之前，需要用pinMode函数将针脚设置为OUTPUT模式\n\n0 代表low值\n非0都代表high\n\n\n4.2Geany编译器运行代码老样子，三板斧\n\n\n在Geany里面用生成命令引用wiringPi库（后续的博客不再说明）\n在Geany的build(生成)--&gt;set build commands(设置生成命令）中输入以下指令gcc -Wall -c &quot;%f&quot; -lwiringPi\n\n最终运行的效果如下，当digitalWrite写入high时，继电器接通，红灯电路亮起\n写入low时继电器关闭，恢复原本绿灯常亮状态\n\n使用ctrl+c关闭程序运行面板，停止程序运行\n\n4.3Linux-gcc编译器在linux控制台里面，用cd打开你的文件夹后，输入如下编译指令\ngcc -Wall 04relay.c -o TEST -lwiringPi\n\n如果编译没有报错，那就是成功编译了，ls会发现多出了TEST可执行文件，使用./TEST执行它\n执行结束后，会显示下一行的待定输入\n\n为了避免linux-gcc中程序运行后无法终止，请不要使用while(1)死循环！\n使用结束后请先断开5V跳线后，再断开其他跳线\n\n结语本实验只是简单演示了继电器的使用，再后续更复杂的实验中，我们可以使用它控制更复杂的模块\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验06-轻触开关实验","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C06-%E8%BD%BB%E8%A7%A6%E5%BC%80%E5%85%B3%E5%AE%9E%E9%AA%8C/","content":"\n\n前言书上的代码示例可太牛了，不仅没用字符串比较函数strcmp，还是指针直接和字符串对比😥\n\n学习还得帮书本纠错，问店家客服也是一问三不知。\n不多说了，一起开始本次的实验吧！👍\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派\n40P软盘线+T型转接板+面包板\n轻触开关按键模块\n双色LED模块\n一堆跳线\n\n\n上：双色LED模块；下：轻触开关模块\n\n2.实验原理2.1电路图使用轻触开关作为树莓派的输入设备，按下开关时，树莓派GPIO端口检测到低电平(0v)，表示按键被按下。松开按键时，树莓派检测到高电平(3.3v)\n在本次实验中，将通过打印信息提示按键是否被按下。\n轻触开关模块电路图如下：\n\n2.2接线\n\n\n树莓派\nT型转接板\n轻触开关\n\n\n\nGPIO 0\nGPIO 17\nSIG(S)\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND(-)\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n在实验2的博客中，已经提到过树莓派针脚编号和T型转接板上编号的对应关系\n在树莓派系统控制栏中，我们可以输入以下指令查看树莓派的GPIO接口\ngpio readall\n\n可以看到，17对应0，18对应1，27对应2。和我们的接线方式和初始化针脚的编号是对应的\n\n本次实验的接线图如下，注意各个端口的接线关系\n\n右上角红黑线是树莓派的散热风扇，和实验无关\n\n\n\n3.程序示例以下给出C语言的示例代码\n//轻触开关按键实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define makerobo_BtnPin\t\t0   // 轻触按键PIN口#define makerobo_Rpin\t\t1   // 红色LED灯模块PIN#define makerobo_Gpin\t\t2   // 绿色LED灯模块PIN//双色LED控制函数void double_colorLED(char* color)&#123;\tpinMode(makerobo_Rpin, OUTPUT);  //设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT);  //设置为输出模式    \tif (!strcmp(color,&quot;RED&quot;))     //点亮红色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH); \t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (!strcmp(color,&quot;GREEN&quot;)) //点亮绿色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;makerobo Double color LED Error\\n&quot;);&#125;int main()&#123;\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed!\\n&quot;);\t\treturn 1; \t&#125;    //轻触按键Pin设置为输入模式\tpinMode(makerobo_BtnPin, INPUT);\tdouble_colorLED(&quot;GREEN&quot;);\t\twhile(1)\t&#123;\t\t//轻触按键去除抖动处理\t\tif(0 == digitalRead(makerobo_BtnPin))\t\t&#123;   // 按键有按下\t\t\tdelay(10);   // 延时去抖动\t\t\tif(0 == digitalRead(makerobo_BtnPin))\t\t\t&#123;\t\t\t\tdouble_colorLED(&quot;RED&quot;);\t   // 点亮红色LED灯\t\t\t\tprintf(&quot;Button is pressed\\n&quot;); // 打印出有按键按下\t\t\t&#125;\t\t&#125;\t\telse if(1 == digitalRead(makerobo_BtnPin))\t\t&#123; // 没有按键按下亮绿灯\t\t\tdelay(10);\t\t\tif(1 == digitalRead(makerobo_BtnPin))\t\t\t&#123;\t\t\t\tdouble_colorLED(&quot;GREEN&quot;);   // 点亮绿色LED灯\t\t\t\tprintf(&quot;No Button is pressed\\n&quot;); // 没有按键按下\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.1部分函数解析一些函数在之前的博客中已具体介绍过，这里简单列出它们的功能\n\n\n\n函数\n作用\n\n\n\nvoid pinMode(int pin, int mode)\n设置针脚模式（输入、输出、脉冲输出、GPIO时钟）\n\n\nvoid digitalWrite(int pin, int value);\n向指定管脚写入高&#x2F;低电平信号，使用前需要设置管脚为输出模式\n\n\n这里有个新的函数，作用是读取管脚的值\n在本实验中用于接收轻触开关的按钮信号\n\n3.2 Geany编译器运行运行程序，代码会循环打印“没有按键按下”，LED亮绿灯\n\n按下按键后，打印显示“按键已按下”，LED亮红灯\n\n实验效果如下\n\n3.3Linux-Gcc编译器在命令行中输入以下编译指令，生成可执行文件\ngcc -Wall 06Button.c -o TEST -lwiringPi\n\n运行可执行文件后，可以观测到相同结果\n\n3.4程序优化我个人觉得这个程序用while(1)死循环并不是那么的优，程序需要手动CTRL+C终止，且终止后无法关闭LED灯。\n下面对程序做出一些优化\n\n依旧可以试试判断按键按下情况\n在程序运行后，关闭小灯\n\n只需更改循环体和延时函数即可，在循环结束后，使用digitalWrite输入低电平关闭小灯的红&#x2F;绿管脚，即完全关闭双色LED\nint k=40;while(k--)&#123;\t//轻触按键去除抖动处理\tif(0 == digitalRead(makerobo_BtnPin))\t&#123;   // 按键有按下\t\tdelay(500);   // 延时去抖动\t\tif(0 == digitalRead(makerobo_BtnPin))\t\t&#123;\t\t\tdouble_colorLED(&quot;RED&quot;);\t   // 点亮红色LED灯\t\t\tprintf(&quot;Button is pressed\\n&quot;); // 打印出有按键按下\t\t&#125;\t&#125;\telse if(1 == digitalRead(makerobo_BtnPin))\t&#123; // 没有按键按下亮绿灯\t\tdelay(500);\t\tif(1 == digitalRead(makerobo_BtnPin))\t\t&#123;\t\t\tdouble_colorLED(&quot;GREEN&quot;);   // 点亮绿色LED灯\t\t\tprintf(&quot;No Button is pressed\\n&quot;); // 没有按键按下\t\t&#125;\t&#125;&#125;//关闭LEDdigitalWrite(makerobo_Rpin, LOW);digitalWrite(makerobo_Gpin, LOW);delay(500);//延时查看关闭情况return 0;\n\n\n结语本次实验学习了轻触开关的使用方法，在未来的实验中，可以使用它来控制一些更复杂电路的开合\n\n你学费了吗？\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验07-倾斜开关","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C07-%E5%80%BE%E6%96%9C%E5%BC%80%E5%85%B3/","content":"\n\n前言昨天补全了树莓派初始化的博客，本专栏的模块就算是全啦！\n欢迎大家把本专栏推荐给其他有兴趣学习树莓派的朋友！\n\n从本博客开始，将不再讲述Geany编译器的简单操作，所有操作都用linux命令行解决\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n倾斜传感器模块\n双色LED模块\n跳线一堆\n\n\n上：倾斜传感器；下：双色LED\n\n2.实验原理在倾斜开关中，有一个金属球，它用于检测小角度的倾斜。倾斜开关模块的结构为双向传到的球形倾斜该关。只要倾斜度的力满足条件，开关就会通电，从而输出低电平信号。\n\n2.1实验接线\n\n\n树莓派\nT型转接板\n倾斜开关\n\n\n\nGPIO 0\nGPIO 17\nDo\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n\n2.2实物接线图\n接上排线后，倾斜开关模块的PWR-LED指示灯亮起\n\n当检测到倾斜角度改变时，DO-LED也会亮起，这时Do管脚将输出低电平，对应值为0。后续程序的编写将用到这个原理\n\n\n3.代码示例下面给出C语言的示例代码\n//倾斜传感器实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_TiltPin\t0 //倾斜传感器管脚定义#define makerobo_Rpin\t\t1 //红色LED模块管脚定义#define makerobo_Gpin\t\t2 //绿色LED模块管脚定义//双色LED控制函数void double_colorLED(char* color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); //设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); //设置为输出模式\tif (color == &quot;makeroboRED&quot;)     //点亮红色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (color == &quot;makeroboGREEN&quot;) //点亮绿色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;Double color LED Error&quot;);&#125;int main(void)&#123;\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123;\t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    //倾斜传感器Pin设置为输入模式\tpinMode(makerobo_TiltPin, INPUT);\tdouble_colorLED(&quot;makeroboGREEN&quot;);\t\twhile(1)&#123;\t\t//如果没有检测到倾斜，输出高电平1\t\t//检测到了之后，输出高电平0\t\tif(0 == digitalRead(makerobo_TiltPin))\t\t&#123;     //倾斜传感器发生倾斜\t\t\tdelay(10); //倾斜传感器去除抖动处理\t\t\tif(0 == digitalRead(makerobo_TiltPin))&#123;\t\t\t\tdouble_colorLED(&quot;makeroboRED&quot;); // 点亮红色LED灯\t\t\t\tprintf(&quot;Tilt!\\n&quot;);   // 打印出出现倾斜\t\t\t&#125;\t\t&#125;\t\telse if(1 == digitalRead(makerobo_TiltPin))\t\t&#123; // 倾斜传感器没有发生倾斜\t\t\tdelay(10);\t\t\tif(1 == digitalRead(makerobo_TiltPin))&#123;\t\t\t\twhile(!digitalRead(makerobo_TiltPin));\t\t\t\tdouble_colorLED(&quot;makeroboGREEN&quot;);  // 点亮绿色LED灯\t\t\t\tprintf(&quot;No Tilt!\\n&quot;);  // 打印没有出现倾斜\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.1部分代码解释去抖动操作因为倾斜开关和轻触开关都是物理结构，需要有一定的延时来进行去抖动操作\n\n直接用==比较字符串(color == &quot;makeroboGREEN&quot;) \n\n这里用到了==直接比较字符串，之前我以为这样写是错误的，因为Linux-gcc报错了（但是可以编译出可执行文件，也能正常运行）\n\n实际上这个在VS下是可以正常运行的，不会报错\n\n个人理解，这样直接传入字符串的操作，实际上是在函数中创建了一个形参color，接收了传过来的常量字符串，随后的==比较的其实是内存中的字符串的地址，而不是直接比较字符串本身\n\n这个代码里面包含的wiringPi函数，在之前的博客中已经讲解过了，详情可以看实验06👉传送门\n如果有不懂的，可以在评论区提出！\n\n\n3.2 Linux编译运行代码输入以下语句编译这个代码，生成可执行文件TEST\ngcc -Wall 07tiltswitch.c -o TEST -lwiringPi\n\n./TEST运行这个文件，按CTRL+C终止程序\n\n3.3运行效果抬起倾斜开关，LED亮绿灯。放下它后，变成默认的红灯\n\n结语本次实验到这里就结束啦！感觉这个倾斜开关就是手机中陀螺仪的青春版。\n目前我设想的是，以后的小车实验中可以通过它来判断小车现在是在上坡还是在平地，如果在上坡，就加大马达的输出。嗯，应该是这样！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验08-震动开关","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C08-%E9%9C%87%E5%8A%A8%E5%BC%80%E5%85%B3/","content":"\n\n前言今天折腾vim编辑器折腾了老久，我只是想实现在vim编辑器中可以复制代码到windows电脑下，方便我写博客，但是咋弄都搞不定，放弃了，还是用树莓派的系统来复制吧\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n振动传感器模块\n双色LED模块\n跳线一堆\n\n\n上：双色LED模块；下：震动传感器模块\n振动传感器模块和倾斜传感器模块很像，都是通过物理结构来判断当前的状态。而且它也有PWR-LED和DO-LED两个指示灯\n\n2.实验原理振动开关传感器用的是常闭型振动传感器，可用于跟踪振动触发作用，如防盗报警，地震报警和智能小车。与常开型振动传感器相比，常闭型振动传感器触发时间长，可以用于驱动继电器模块\n\n该模块采用常开高灵敏度震动开关。开关在静止時为开路OFF状态，当受到外力碰触而达到相应震动力时，或移动速度达到适当离(偏)心力时，导电接脚会产生瞬间导通呈瞬间ON状态；当外力消失時，开关恢复为开路OFF状态。可用于各种震动触发作用，报盗报警，智能小车，电子积木等。传感器特设M3固定安装孔，调节方向与固定方便易用，使用宽电压LM393比较器，信号干净，波形好，驱动能力强，超过15mA，配可调精密电位器调节灵敏度。在此实验中，将双色LED模块连接到Raspberry Pi作为指示作用。敲击或敲击振动传感器时，它将打开双色LED将闪烁红色。再次点击它，LED将变为绿色-每次敲击或敲击两种颜色之间交替闪烁。\n2.1电路图\n2.2接线图\n\n\n树莓派\nT型转接板\n振动开关\n\n\n\nGPIO 0\nGPIO 17\nDo\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n因为接口和倾斜开关一模一样，所以接线方式也是一样的\n\n实物接线图这里就不放了，和倾斜开关不同的是，振动开关在接上后，两个指示灯都会亮起，振动该传感器，DO-LED会闪动\n\n\n3.代码示例老样子，给出C语言的代码示例\n\n这里的wiringPi库函数在上两次的实验中都有使用过，详情请查看实验6里的解释\n\n#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_VibratePin\t0   // 震动传感器#define makerobo_Rpin\t\t1   // 红色LED PIN #define makerobo_Gpin\t\t2   // 绿色LED PINint clb_tmp = 0;//全局变量用于比较//双色LED控制函数void double_colorLED(int color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); //设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); //设置为输出模式\tif (0 == color)             //点亮红色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (1 == color)       //点亮绿色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;Makerobo Double color LED Error\\n&quot;); // 双色LED错误&#125;// 打印信息,打印出振动传感器的状态\tvoid makerobo_Print(int x)&#123;\tif (x != clb_tmp)\t&#123;\t\tif (x == 0)\t\t\tprintf(&quot;...Makerobo ON\\n&quot;);\t\tif (x == 1)\t\t\tprintf(&quot;Makerobo OFF..\\n&quot;);\t\tclb_tmp = x;//复位x\t&#125;&#125;int main()&#123;\tint clb_status = 0;  //状态值\tint clb_tmp = 0;     //比较值\tint clb_value = 1;   //当前值\t//wiringPi初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    //振动传感器Pin设置为输入模式\tpinMode(makerobo_VibratePin, INPUT);\t\twhile(1)&#123;\t\tclb_value = digitalRead(makerobo_VibratePin); //获取振动传感的值\t\tif (clb_tmp != clb_value)\t\t&#123;\t//振动传感器的输出值发生改变\t\t\tclb_status ++;   //振动传感器状态加1\t\t\tif (clb_status &gt; 1)\t\t\t&#123;\t\t\t\t\t\t\t\tclb_status = 0; //状态发生改变判断，如果变成2了复位成0\t\t\t&#125;\t\t\tdouble_colorLED(clb_status);  //控制双色LED模块\t\t\tmakerobo_Print(clb_status);   //打印出状态\t\t\tdelay(1000);                  //延时1s\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.1代码思路讲解clb_value接收振动传感器的返回值，每次振动，返回值都会改变\n\nvalue初始值为1，振动时，接收了返回值为0，和tmp不同，所以status++，双色LED的颜色改变\n如果没有检测到振动，返回值为1，和tmp相同，status不改变，双色LED的颜色不变\n\n参数clb_tmp问题void makerobo_Print(int x)函数中调用的其实是全局变量下的clb_tmp\n而main函数中调用的是int clb_tmp = 0;//比较值这个单独定义的局部变量，和全局中的tmp没有关系，所以makerobo_Print函数中对clb_tmp函数的操作不影响main中和状态码的比较\n为了不搞混全局变量和局部变量，建议将main函数中的tmp更名为clb_tmp1\n\n3.2linux运行代码gcc -Wall 08vibrationswitch.c -o TEST -lwiringPi\n\n\n每次晃动传感器，双色LED就会变色，屏幕上打印出on和off（每晃动一次，打印一次）\n按CTRL+C终止程序运行\n\n和倾斜开关的实时改变不同，振动开关的改变不是实时的，而是需要新的振动来触发它（类似一个按钮）\n\n假设我们要用它来做一个报警装置，假设在某一段时间内检测到振动状态多次改变，就可以发出信号报警，代表你的门（或者某个东西）被移动了\n\n\n结语这次实验的代码比上一次的倾斜开关相比，更复杂了一些。希望我的讲解对你有帮助！\n\n感谢你看到最后！如果对你有帮助，还请点个👍，万分感谢！\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验09-蜂鸣器模块","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C09-%E8%9C%82%E9%B8%A3%E5%99%A8%E6%A8%A1%E5%9D%97/","content":"\n\n前言最近学习激情不是很高，虽然代码学了很多，但是高数和大物直接摆烂了，呜呜呜呜\n\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n有源蜂鸣器\n无源蜂鸣器\n一堆跳线\n\n\n下：有源蜂鸣器；上：无源蜂鸣器\n它们的外观几乎一样。如果是没有装配好的单独模块，无源蜂鸣器底部的电路引脚带有绿色pcb，而有源蜂鸣器底部是黑色塑料外壳。因为模块已经焊接到了电路板上，所以我们看不到它们的底部引脚。\n\n2.实验原理蜂鸣器属于声音模块。有源蜂鸣器常用于发出单一的提示性报警声音，没有频率变化，内置振荡器；无源蜂鸣器的驱动方式为频率脉冲驱动，可以发出各种有频率的信号声音。\n\n有源蜂鸣器内部有一个简单的振荡电路，能将恒定的直流电转化成一定频率的脉冲信号，程序控制方便但频率固定，单片机一个高低电平就可以让其发出声音。\n无源蜂鸣器和电磁扬声器一样没有内部驱动电路，需要接在音频输出电路中才能发声。如果给直流信号是不响的，因为磁路恒定，必须用2K-5K的方波去驱动它。声音频率可控，可以做出“多来米发索拉西”的效果。\n在一些特例中，可以和LED复用一个控制口。\n\n它们的电路原理图是一样的，只是控制方式不同\n\n因为有两个不同的模块，所以下文将分开讲解\n3.有源蜂鸣器模块有源蜂鸣器有内置振荡源，只需要接线就会发出蜂鸣声，但它的发声是固定频率的。这点和内置了控制芯片的七彩LED模块很相似。\n\n\n\n树莓派\nT型转接板\n有源蜂鸣器\n\n\n\nGPIO 0\nGPIO 17\nI&#x2F;O\n\n\n3.3V\n3.3V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n在连接上电路后，有源蜂鸣器就会哔哔哔叫。我们可以通过控制输入电平的高低，来控制它的开关\n3.1代码示例//有源蜂鸣器#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_BuzzerPin  0  // 有源蜂鸣器管脚定义int main()&#123;    //初始化连接失败时，将消息打印到屏幕    if(wiringPiSetup() == -1)&#123;         printf(&quot;setup wiringPi failed !&quot;);        return 1;      &#125;       pinMode(makerobo_BuzzerPin,  OUTPUT); // 有源蜂鸣器设置为输出模式    // 无限循环    while(1)    &#123;               digitalWrite(makerobo_BuzzerPin, LOW);        \t// 蜂鸣器为低电平触发，所以使能蜂鸣器让其发声            delay(100);           // 延时100ms            digitalWrite(makerobo_BuzzerPin, HIGH);         \t// 蜂鸣器设置为高电平，关闭蜂鸣器            delay(100);           // 延时100ms    &#125;       return 0;&#125;\n\n3.2编译代码第一次编译这个代码的时候，出现了下面的报错。意思其实很简单，就是wiringPi库没有连接上，因为我忘记在最末尾加上-lwiringPi了\n\n正确的编译指令如下\ngcc 09activebuzzer.c -o ACTIVE -lwiringPi\n\n编译成功\n\n3.3实验效果改变delay函数的参数，就能听到蜂鸣器声音的变换。设置成delay(1000)可以延长声音效果\n\n第一次接线的时候，我不小心把它接在了5v的管脚上，导致输入高电平并不能关闭蜂鸣器，而是近似于改变了蜂鸣器的频率（我听不出是音量变了还是频率变了）\n修正错误，接线在3.3v管脚上后，有源蜂鸣器可以正常关闭\n\n总所周知，图片是没有声音的。所以我把两个情况的录音文件都放在了gitee仓库👉传送门\n\n4.无源蜂鸣器无源蜂鸣器可以通过输入pwm来控制发声频率\n它的接线方式和有源蜂鸣器相同\n\n\n\n树莓派\nT型转接板\n无源蜂鸣器\n\n\n\nGPIO 0\nGPIO 17\nI&#x2F;O\n\n\n3.3V\n3.3V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n4.1代码示例//无源蜂鸣器#include &lt;wiringPi.h&gt;#include &lt;softTone.h&gt;#include &lt;stdio.h&gt;#define makerobo_BuzPin    0 // 有源蜂鸣器管脚定义// 音谱定义// 低C音符的频率#define  Tone_CL1  131#define  Tone_CL2  147#define  Tone_CL3  165#define  Tone_CL4  175#define  Tone_CL5  196#define  Tone_CL6  221#define  Tone_CL7  248// 中C音的频率#define  Tone_CM1  262#define  Tone_CM2  294#define  Tone_CM3  330#define  Tone_CM4  350#define  Tone_CM5  393#define  Tone_CM6  441#define  Tone_CM7  495// 高C音符的频率#define  Tone_CH1  525#define  Tone_CH2  589#define  Tone_CH3  661#define  Tone_CH4  700#define  Tone_CH5  786#define  Tone_CH6  882#define  Tone_CH7  990// 第一首歌音谱int makerobo_song_1[] = &#123;Tone_CM3,Tone_CM5,Tone_CM6,Tone_CM3,Tone_CM2,Tone_CM3,Tone_CM5,Tone_CM6,Tone_CH1,Tone_CM6,Tone_CM5,Tone_CM1,Tone_CM3,Tone_CM2,                         Tone_CM2,Tone_CM3,Tone_CM5,Tone_CM2,Tone_CM3,Tone_CM3,Tone_CL6,Tone_CL6,Tone_CL6,Tone_CM1,Tone_CM2,Tone_CM3,Tone_CM2,Tone_CL7,                         Tone_CL6,Tone_CM1,Tone_CL5&#125;;// 第一首歌节拍int makerobo_beat_1[] = &#123;1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,                         1,1,1,1,1,1,3&#125;;// 第二首歌音谱int makerobo_song_2[] = &#123;Tone_CM1,Tone_CM1,Tone_CM1,Tone_CL5,Tone_CM3,Tone_CM3,Tone_CM3,Tone_CM1,Tone_CM1,Tone_CM3,Tone_CM5,Tone_CM5,Tone_CM4,Tone_CM3,Tone_CM2,                         Tone_CM2,Tone_CM3,Tone_CM4,Tone_CM4,Tone_CM3,Tone_CM2,Tone_CM3,Tone_CM1,Tone_CM1,Tone_CM3,Tone_CM2,Tone_CL5,Tone_CL7,Tone_CM2,Tone_CM1                        &#125;;// 第二首歌节拍int makerobo_beat_2[] = &#123;1,1,1,3,1,1,1,3,1,1,1,1,1,1,3,1,1,1,2,1,1,1,3,1,1,1,3,3,2,3&#125;;int main()&#123;    int i;    //初始化连接失败时，将消息打印到屏幕    if(wiringPiSetup() == -1)&#123;        printf(&quot;makerobo setup wiringPi failed !&quot;);        return 1;    &#125;    //软件模拟Tone库初始化识别，将消息打印到屏幕    if(softToneCreate(makerobo_BuzPin) == -1)&#123;        printf(&quot;makerobo setup softTone failed !&quot;);        return 1;    &#125;    while(1)&#123;        printf(&quot;makerobo music is being played...\\n&quot;);  // 开始播放音乐        // 播放第一首歌音乐        for(i=0;i&lt;sizeof(makerobo_song_1)/4;i++)&#123;            softToneWrite(makerobo_BuzPin, makerobo_song_1[i]);             //第一首歌音谱            delay(makerobo_beat_1[i] * 500);   //第一首歌节拍        &#125;        // 播放第二首歌音乐        for(i=0;i&lt;sizeof(makerobo_song_2)/4;i++)&#123;            softToneWrite(makerobo_BuzPin, makerobo_song_2[i]);             //第二首歌音谱            delay(makerobo_beat_2[i] * 500);     //第二首歌节拍        &#125;    &#125;    return 0;&#125;\n\n音符频率对照表\n\n音阶   音阶是音乐必不可少的要素，主要由声音的频率决定。通过给蜂鸣器不同频率的音频脉冲，可以产生不同的音阶，而要产生某频率的音频脉冲，最简单的办法是以该音频的频率除以2的值，函数使用该值为参数改变蜂鸣器输入方波信号的频率，蜂鸣器上就可发出该频率的声音。   若想改变音阶，只需要改变频率即可。下表为各音调音符频率对照表，据此可产生不同音阶的音符。“#”表示半音，用于上升或下降半个音，乘以2就提升该声音一个8度音阶，减半则降一个8度。\n\n节拍   若要构成音乐，光有音阶是不够的，还需要节拍，也就是音符持续时间的长短，一般用拍数表示。至于1拍是多少秒，没有严格的规定，只要节拍适宜，声音悦耳即可。假如某首歌曲的节奏是每分钟120拍，那么1拍为0.5s，1&#x2F;4拍为0.125s，以此类推可得到其他节拍对应的时长。这样，利用不同的频率，加上与拍数对应的延时，就构成了乐曲。\n\n\n以上引用自这位大佬的博客👉原文链接\n\n我找来了一章音符与频率的对照表，供大家参考\n\nsoftTone软件音频库类似于softPWM，wiringPi库中还包含了一个软件音频库，通过输入不同的音频频率来使无源蜂鸣器发出不同的声音\n\n这里提到了需要在编译文件时加入-lpthread选项，实测不需要加入也可以正常编译出来\n4.2编译代码gcc 09passivebuzzer.c -o PASSIVE -lwiringPi\n\n\n4.3实验效果蜂鸣器的确发出了不同频率的声音，但是我感觉它并没有唱歌，哈哈😂\n录音文件也放在gitee仓库里面啦！👉传送门\n\n结语这两个传感器和之前实验中出现的双色LED很像，不过一个是以声音为媒介，一个是以光为媒介来传递信息\n本篇博客到这里就结束啦，如果有什么问题，欢迎在评论区提出哦！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验10-干簧管传感器实验","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C10-%E5%B9%B2%E7%B0%A7%E7%AE%A1%E4%BC%A0%E6%84%9F%E5%99%A8%E5%AE%9E%E9%AA%8C/","content":"\n\n前言好像没啥可以说的，直接开始进入今天的实验内容吧\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n干簧管传感器模块\n双色LED\n跳线若干\n\n\n上：干簧管传感器；下：双色LED\n\n2.实验原理干簧管传感器也是一种用于检测磁场的传感器。在常用的程控交换机、复印机、洗衣机、电冰箱、照相机、消毒碗柜、门磁、窗磁、电磁继电器、电子衡器、液位计、煤气表、水表等产品中都得到了很好的应用。\n\n个人理解：干簧管传感器的效果和霍尔元件很像，不过后者的体积更小\n笔记本电脑中就有霍尔元件，用于检测笔记本屏幕的开关，实现合盖休眠的功能\n\n\n干簧管是干式舌簧管的简称，是一种有触点的无源电子开关元件，具有结构简单，体积小便于控制等优点。\n\n其外壳一般是一根密封的玻璃管，管中装有两个铁质的弹性簧片电板，还灌有一种叫金属的惰性气体。平时，玻璃管中的两个簧片是分开的。\n\n当有磁性物质靠近玻璃管时，在磁场磁力线的作用下，管内的两个簧片被磁化而互相吸引接触，簧片就会吸合在一起，使结点所接的电路连通。\n外磁力消失后，两个簧片由于本身的弹性而分开，线路也就断开了。\n因此，作为一种利用磁场信号来控制的线路开关器件，干簧管可以作为传感器用于计数、限位等等场景(在安防系统中主要用于门磁、窗磁的制作)，同时还被广泛使用于各种通信设备中。\n在实际运用中，通常用磁铁控制这两根金属片的接通与否，所以又被称为“磁控管”\n\n\n2.1电路图电路图中Reed Switch(干簧管)部分，其实就是原理部分提到的密封玻璃管，内部有两个铁片\n\n当干簧管部分接触到磁性物体时，两个铁片吸附在一起，电路接通，DO管脚输出低电平。同时电路接通，D2 LED点亮\n没有检测到磁性物体，两个铁片断开，电路断开，DO管脚直连VCC，输出高电平\n\n\n2.2接线图类似这种通过一个传感器模块来控制双色LED的实验我们已经做过好几个了。它们的接线方式基本是一样的👍\n\n\n\n树莓派\nT型转接板\n干簧管\n\n\n\nGPIO 0\nGPIO 17\nDO\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n\n\n当接线完毕后，PWM-LED指示灯常亮\n\n即便没有开启控制程序，当干簧管检测到磁性物体时，DO-LED指示灯也会亮起\n\n3.代码示例和之前控制双色LED的代码相同，我们使用pinMode设置干簧管传感器为输入模式，将红绿LED的管脚都设置成输出模式\n\n当digitalRead检测到0（低电平）时，将双色LED设置为红色\n当digitalRead检测到1（高电平）时，将双色LED设置成绿色\n\n//干簧管控制双色LED实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_ReedPin\t0 //干簧管传感器管脚定义#define makerobo_Rpin\t\t1 //红色LED模块管脚定义#define makerobo_Gpin\t\t2 //绿色LED模块管脚定义// 双色LED控制函数void double_colorLED(char* color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); //红色LED管脚设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); //绿色LED管脚设置为输出模式\tif (color == &quot;makeroboRED&quot;)       //点亮红色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (color == &quot;makeroboGREEN&quot;) //点亮绿色LED灯\t&#123;\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;\telse\t\tprintf(&quot;Double color LED Error&quot;);&#125;int main()&#123;\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    //干簧管传感器Pin设置为输入模式\tpinMode(makerobo_ReedPin, INPUT);\tdouble_colorLED(&quot;makeroboGREEN&quot;);  //点亮绿色LED模块\t\twhile(1)&#123;\t\t//干簧管传感器去除抖动处理\t\tif(0 == digitalRead(makerobo_ReedPin))        &#123; //干簧管传感器检测到磁性物质\t\t\tdelay(10);       // 延时去抖动\t\t\tif(0 == digitalRead(makerobo_ReedPin))&#123;\t\t\t\tdouble_colorLED(&quot;makeroboRED&quot;);\t   // 点亮红色LED灯\t\t\t\tprintf(&quot;Detected Magnetic Material!\\n&quot;);// 打印出检测到磁性物质\t\t\t&#125;\t\t&#125;\t\telse if(1 == digitalRead(makerobo_ReedPin))        &#123; // 干簧管传感器没有检测到磁性物质\t\t\tdelay(10);        // 延时去抖动\t\t\tif(1 == digitalRead(makerobo_ReedPin))&#123;\t\t\t\twhile(!digitalRead(makerobo_ReedPin));\t\t\t\tdouble_colorLED(&quot;makeroboGREEN&quot;);   // 点亮绿色LED灯\t\t\t\tprintf(&quot;No Detected Magnetic Material!\\n&quot;); // 打印出没有检测到磁性物质\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n\n更详细的函数解释，可以参考之前实验6~8的博客👉专栏链接\n\n3.1编译代码在linux控制台下输入以下语句，编译生成可执行文件TEST\ngcc -Wall 10reedswitch.c -o TEST -lwiringPi\n\n3.1.1 GCC中-Wall指令的作用上一篇博客中，我在编译代码的时候就没有使用-Wall指令，但程序依旧编译成功了\n实际上，-Wall指令的作用是让GCC编译器显示程序的警告\n\n编译器在程序中检查出错误时，会终止编译\n编译器在程序中检查出警告时，依旧能编译生成可执行文件\n\nwindows系统中的VS编译器下，也有错误&#x2F;警告两种报错方式\n\n之前我就没有弄明白Linux环境下这两个之间的区别，导致我认为gcc编译器中不支持用==直接比较常量字符串（然后就把它改成了strcmp，当然这样也没错哈）\n\n如果我们在编译的时候去掉-Wall指令，就不会显示这两个警告\n\n\n更多关于-Wall指令的知识，大家可以参考这位dalao的博客学习一二👉传送门\n\n\n3.2实验效果./TEST运行可执行文件，查看实验结果\n\n检测到磁性物质时，屏幕打印Detected Magnetic Material!\n没有检测到的时候，打印No Detected Magnetic Material!\n\n\n结语本次实验到这里就结束啦，希望对你学习树莓派的操作有一些帮助\n\n学校高数和大物欠下的学习债终于补上了，可以摸🐟了\n\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验11-U型光点传感器","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C11-U%E5%9E%8B%E5%85%89%E7%94%B5%E4%BC%A0%E6%84%9F%E5%99%A8/","content":"\n\n前言本篇实验和上篇博客的实验相似，我们要学习用U型光电传感器来控制双色LED\n\n这都是基础实验中不可或缺的内容，因为后续我们需要学会交叉使用不同的传感器来控制更复杂的电路。那些才是学习树莓派基础实验真正的意义\n不管怎样，还是继续努力吧！\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n1.实验器材\n树莓派\n40p软排线+T型转接板+面包板\nU型光电传感器模块\n双色LED模块\n跳线一堆\n\n\n上：U型光电传感器；下：双色LED\n\n2.实验原理U型光电传感器是一种红外感应光点产品。其有红外发射管和接收管，分别位于U型槽的两侧，以此形成一光轴。当检测到物体经过U型槽并阻断光轴时，就能产生对应的电信号。\n2.1电路图以下是U型光电传感器模块的电路图\n\n无障碍物阻挡时，D1\\D2-LED都亮起，OUT管脚检测到低电平0\n有障碍物阻挡时，D1-LED熄灭，OUT管脚检测到高电平1\n\n\n2.2接线图\n\n\n树莓派\nT型转接板\nU型光电传感器\n\n\n\nGPIO 0\nGPIO 17\nOUT\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n树莓派\nT型转接板\n双色LED\n\n\n\nGPIO 1\nGPIO 18\nR(中间)\n\n\nGND\nGND\nGND(-)\n\n\nGPIO 2\nGPIO 27\nG(S)\n\n\n\n\n不过我手上的这个传感器并没有两个指示灯。只有一个，该指示灯在传感器被阻隔的时候会变暗\n\n\n3.代码示例//U型光电传感器实验#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#define makerobo_LBPin\t\t0  // U型光电传感器管脚定义#define makerobo_Rpin\t\t1  // 红色LED模块管脚定义#define makerobo_Gpin\t\t2  // 绿色LED模块管脚定义// 双色LED控制函数void double_colorLED(int color)&#123;\tpinMode(makerobo_Rpin, OUTPUT); // 红色LED管脚设置为输出模式\tpinMode(makerobo_Gpin, OUTPUT); // 绿色LED管脚设置为输出模式\t\tif (color == 0)&#123;                // 点亮红色LED灯\t\tdigitalWrite(makerobo_Rpin, HIGH);\t\tdigitalWrite(makerobo_Gpin, LOW);\t&#125;\telse if (color == 1)&#123;          // 点亮绿色LED灯\t\tdigitalWrite(makerobo_Rpin, LOW);\t\tdigitalWrite(makerobo_Gpin, HIGH);\t&#125;&#125;// 有物体挡住时，打印出提示信息void makerobo_Print(int x)&#123;\tif ( x == 0 )&#123;\t\tprintf(&quot;makerobo Light was blocked!\\n&quot;);\t&#125;\telse&#123;\t\tprintf(&quot;clear!\\n&quot;);// 没有挡住\t&#125;&#125;// 主函数int main()&#123;       //初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;    //U型光电传感器Pin设置为输入模式\tpinMode(makerobo_LBPin, INPUT);\tint clb_temp=0;\twhile(1)&#123;\t\t//U型光电传感器有无物体挡住信息检测\t\tif ( digitalRead(makerobo_LBPin) == 0 )&#123;  \t\t\tclb_temp = 1;//低电平，代表没有阻挡\t\t&#125;\t\tif ( digitalRead(makerobo_LBPin) == 1 )&#123;\t\t\tclb_temp = 0;//高电平，代表被阻挡\t\t&#125;\t\tdouble_colorLED(clb_temp); // 控制双色LED灯显示\t\tmakerobo_Print(clb_temp);  // 信息打印\t&#125;\treturn 0;&#125;\n\n3.1LinuxGCC编译代码在控制台输入以下指令，编译出可执行文件TEST\ngcc -Wall 11photoeletricsensor.c -o TEST -lwiringPi\n\n执行该文件，当传感器被阻挡时，双色LED变红，屏幕打印makerobo Light was blocked!\n不被阻挡时，双色LED亮绿灯，屏幕打印clear\n\n3.2 效果\n\n结语本次实验到这里就结束啦！如果有什么问题，欢迎在评论区提出哦！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验12-PCF8591模数转换器","url":"/2022/04/21/code/raspberry/%E5%AE%9E%E9%AA%8C12-PCF8591%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%99%A8/","content":"\n\n前言由于树莓派不能直接读取模拟信号，所以我们需要本篇博客中提到的模数转换器来替代实现读取模拟信号的功能。\n本篇博客的这个模数转换器比之前的模块复杂很多，我们需要一步一步弄明白它的原理，才能真正理解如何使用这个小东西\n\n关注本专栏，和我一起学习树莓派开发板30+经典实验！\nC语言代码，0基础剖析！\n\n还等什么😍心动不如行动！👉点我关注\n\n本专栏代码仓库📝：Raspberry-practice\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n双色LED模块（元老级朋友）\nPCF8591模数转换器模块\n一些跳线\n一字或者十字螺丝刀🛠\n\n\n上：PCF8591模数转换器模块；下：双色LED\n\n2.实验原理2.0 元件介绍PCF8591是一个单片集成、单独供电、低功耗、8-bit CMOS数据采集元件。\n\nPCF8591具有4个模拟输入、1个模拟输出和1个串行I2C总线接口。\n它的3个地址引脚A0, A1和A2可用于硬件地址编程，从而允许使用多达8个链接到I2C总线的设备，而无需额外的硬件。\n在PCF8591器件上输入输出的地址、控制和数据信号都是通过双线双向I2C总线以串行的方式进行传输。\n\n该元件的功能包括模拟输入多路复用，片上跟踪和保持功能，8位模数转换和8位数模转换。最大转换率由I2C总线的最大速度决定。\n2.1 i2c总线\ni2c总线是由飞利浦公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。\n\n飞利浦官方有一个关于PCF8591的详细介绍文档，不过它是英语的。我会上传到gitee仓库里面分享给大家，仓库链接在开头介绍过了🤦‍♂️回到开头\n\n\ni2c总线系统中的每个PCF8591设备通过向该设备发送有效地址而被激活。地址由固定部分和可编程部分组成。可编程部分必须按照地址引脚A0，A1，A2进行设置。地址必须以邮寄方式发送。\n在i2c总线协议中，在启动条件之后的第一个字节，地址字节的最后一个位是读&#x2F;写位，它设置了下列数据传输的方向。\n\n2.2 第一字节PCF8591采用典型的I2C总线接口器件寻址方法，即总线地址由器件地址、引脚地址和方向位组成。\n飞利浦公司规定A&#x2F;D器件地址为1001，引脚地址为A2A1A0，其值由用户选择。因此I2C系统中最多可接2^3^个具有I2C总线接口的A&#x2F;D器件。地址的最后一位为方向位R&#x2F;L，当主控器对A&#x2F;D器件进行写操作时为0，进行读操作时为1。\n总线操作时，由器件地址、引脚地址和方向位组成的从地址为主控器发送的第一字节。\n2.3 控制字节发送到PCF8591器件的第二个字节将被存储在其控制寄存器中，并且需要控制器件来实现功能。\n\n\n\nD1、D0 两位是A&#x2F;D通道编号：00通道0，01通道1，10通道2，11通道3\nD2 自动增量选择（0为禁止自动增量，1为允许自动增量），如果允许自动增量，则在每次A&#x2F;D转换后，通道编号会自动递增。\nD3 特征位：固定值为：0。\nD5、D4 模拟量输入选择：00为四路单端输入、01为三路差分输入、10为两路单端与一路差分输入、11为两路差分输入。\nD6 使能模拟输出AOUT有效（1为有效，0为无效）。\nD7 特征位：固定值为：0。\n\n上述内容参考@Maker张大佬的博客👉传送门\n\n控制寄存器的高半字节用于模拟输出，并将模拟输入编程为单端或差分输入。下半字节选择由上半字节定义的一个模拟输入通道。如果设置了自动增加标志，则在每次A&#x2F;D转换后，通道编号会自动递增。\n\n\n更多关于i2c总线的知识，可以查看百度百科的词条👉某度\n\n2.4 模块电路在本次实验中，AIN0（模拟输入0）端口用于接收来自电位计模块的模拟信号，AOUT（模拟输出）用于将模拟信号输出到双色LED模块，用于改变LED的亮度\n\n如果你有注意看电路图的话，你会发现AOUT上链接了一个D4-LED，它也会接收模拟输出信号，同步改变亮度\n\n而在我手头上的模块，D2-LED就是会同步改变亮度的，后文会提到\n\n\n在实验之前，我们可以把AIN上的电位帽拔掉\n\n2.5 电路接线\n\n\n树莓派\nT型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n双色LED\nT型转接板\nPCF8591\n\n\n\nR(中间)\n*\nAOUT\n\n\nGND(-)\nGND\nGND\n\n\nG(S)\n*\n*\n\n\n\n拍出来的接线图好像有亿点点乱😂\n\n正常接线后，主板上的D1-LED会亮起\n\n我们可以根据原理图利用T型转接板来连接模数转换器和双色LED，也可以用这种双母头的线直接连接AOUT端口和双色LED的中间管脚\n\n\n3.程序控制3.1 在树莓派中开启I2C通过VNC打开树莓派的桌面，点击开始-首选项-Raspberry Pi Configuration-Interfaces，打开I2C的开关enable\n\n3.2 代码示例//PCF8591模数转换器#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;//这个头文件是包含在库中的#define makerobo_PCF  120  // 基础管脚120// 主函数int main ()&#123;\tint pcf_value ;// 定义一个变量存储AIN的输入值\t//初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123; \t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1; \t&#125;\tpcf8591Setup (makerobo_PCF, 0x48);    // 在基本引脚120上设置pcf8591，地址0x48\twhile(1)\t&#123;\t\tpcf_value = analogRead  (makerobo_PCF + 0);\t\t// 获取AIN0上的值，插上跳线帽之后，采用的是内部的电位器；\t\tprintf(&quot;%d\\n&quot;, pcf_value);        // 打印出该值            \t\tanalogWrite (makerobo_PCF + 0, pcf_value);         // 控制AOUT输出电平控制LED灯\t\tdelay (10) ; // 延时10ms\t&#125; \treturn 0 ;&#125;\n\n头文件&lt;pcf8591.h&gt;在wiringPi的官方库中，可以查找到关于PCF8591使用的相关函数👉点我\n\n\n3.3 编译代码在控制台输入以下指令，编译出可执行文件TEST\ngcc -Wall 12pcf8591.c -o TEST -lwiringPi\n\n3.4 运行结果在运行程序之前，我们需要先把AIN0和INPUT0之间的跳线帽装上\n随后./TEST运行可执行文件，屏幕上会打印出AIN0管脚上获取的值\n\n但是不管我咋拧模块上的白蓝电位计，这个数字都不动\n后面发现这个代码必须要在树莓派的OS里面跑，才能实现控制功能，应该和3.1中的I2C总线功能有关\n\n于是在Geany编译器中编译代码，开始执行\n\n拧动白蓝电位计，屏幕上接收到的值会不断变化，同时LED小灯和主板上的D2-LED红色亮度也会产生变化\n\n\n结语本次实验对于我这个模电小白来说就晕乎乎的，虽然查找了一些I2C相关的文档和博客，但还是没太弄明白这个模块的具体原理和进阶使用。\n\n不过通过本次这个简单的控制双色LED的实验，至少我知道了可以通过电位计来调节AOUT值，想必在更复杂的实验中，这个模块可以扮演不一样的角色！\n那就只能期待未来我会用到它啦！（我怎么感觉不会呢？）\n\n\n纯小白，本篇博客可能有很大的纰漏，还请各位大佬无情指正！\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验13-雨滴传感器","url":"/2022/05/13/code/raspberry/%E5%AE%9E%E9%AA%8C13-%E9%9B%A8%E6%BB%B4%E4%BC%A0%E6%84%9F%E5%99%A8/","content":"好久没玩树莓派了，今天上手来做一个实验\n\n\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n雨滴传感器模块\nLM393模块\nPCF8591模数转换器模块（实验12）\n一些跳线\n一个一字螺丝刀\n\n\n2.实验原理2.1基本说明雨滴传感器的控制模块具有4个输出，其中VCC连接到5V电源，模块的GND引脚接地。DO引脚连接到微控制器的数字引脚以进行数字输出，也可以使用模拟引脚。要使用模拟输出，可以将A0引脚连接到微控制器的ADC引脚。\n在雨滴&#x2F;雨水器系统中，用雨滴传感器检测降雨量并转换控制器检测到的信号。然后根据这些信号自动设置雨刮器的间隔，以方便地控制雨刮器的电机；在智能照明系统中，自动检测驾驶环境并调整照明模式，提高恶劣环境下的行车安全；在智能天窗系统中，检测是否下雨，如果检测到雨滴，则自动关闭天窗。\n传感器模块包括一个电位计，LM393比较器，LED，电容器和电阻器。雨板模块由铜轨组成，铜轨用作可变电阻器。它的阻力随雨板上的湿度而变化。\n2.2电路图\n2.3接线图\n\n\n树莓派\nT型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\nLM393模块\nT型转接板\nPCF8591\n\n\n\nDO\nGPIO 17\n*\n\n\nAO\n*\nAIN 0\n\n\nVCC\n3.3V\n*\n\n\nGND\nGND\n*\n\n\n\n在连接LM393和雨滴传感器的时候，发现雨滴传感器上并没有明确标出正负极，但是在正极的管脚下方用小点做了标识（负极无该白点）\n\n本次实验需要接的线非常多，注意不要接错了。其中PCF8591模块在接线时需要将所有跳线帽拔出\n\n\n3.代码效果3.1代码示例因为需要使用pcf8591模数转换器，所以需要引用头文件&lt;pcf8591.h&gt;\n//雨滴探测传感器实验#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;#include &lt;math.h&gt;#define\tmakerobo_PCF    120 // 基础管脚120#define\tmakerobo_DOpin\t 0   // 雨滴传感器管脚//打印雨滴传感器提示信息void makerobo_Print(int x)&#123;\tswitch(x)\t&#123;\t\tcase 1:            //没有雨滴\t\t\tprintf(&quot;\\n************************\\n&quot;  );\t\t\tprintf(  &quot;* makerobo Not Raining *\\n&quot;  );\t\t\tprintf(  &quot;************************\\n\\n&quot;);\t\t\tbreak;\t\tcase 0:             //有雨滴\t\t\tprintf(&quot;\\n**********************\\n&quot;  );\t\t\tprintf(  &quot;* makerobo Raining!! *\\n&quot;  );\t\t\tprintf(  &quot;**********************\\n\\n&quot;);\t\t\tbreak;\t\tdefault:         //打印数据错误\t\t\tprintf(&quot;\\n**********************\\n&quot;  );\t\t\tprintf(  &quot;* Print value error. *\\n&quot;  );\t\t\tprintf(  &quot;**********************\\n\\n&quot;);\t\t\tbreak;\t&#125;&#125;int main()&#123;\tint makerobo_analogVal;           // 定义模拟量存储变量\tint makerobo_tmp, makerobo_status;// 定义状态信息    //初始化连接失败时，将消息打印到屏幕\tif(wiringPiSetup() == -1)&#123;\t\tprintf(&quot;setup wiringPi failed !&quot;);\t\treturn 1;\t&#125;\t//在基本引脚120上设置pcf8591，地址0x48\tpcf8591Setup(makerobo_PCF, 0x48);    //设置雨滴传感器管脚为输入模式\tpinMode(makerobo_DOpin, INPUT);    //默认状态值设置为0\tmakerobo_status = 0; \t//无限循环\twhile(1) \t&#123;\t\tmakerobo_analogVal = analogRead(makerobo_PCF + 0);\t\t//获取AIN0上的值\t\tprintf(&quot;%d\\n&quot;, makerobo_analogVal); //打印出该值 \t\tmakerobo_tmp = digitalRead(makerobo_DOpin); \t\t//读取数字IO口电平，读取数字雨滴传感器DO端口\t\tif (makerobo_tmp != makerobo_status) //状态发生改变\t\t&#123;\t\t\tmakerobo_Print(makerobo_tmp); //打印出雨滴传感器检测信息\t\t\tmakerobo_status = makerobo_tmp;  //状态值重新赋值\t\t&#125;\t\tdelay (200);   //延时200ms\t&#125;\treturn 0;&#125;\n\n注意：雨滴传感器其实是LM393和雨滴感应模块的集合体，所以代码注释中说的设置管脚为input模式，实际上设置的是LM393模块的管脚（毕竟只有它连上了T型转接板）\n\n本次博客的代码和之前的实验很相似，其中PCF8591在上篇实验12博客中已经有过讲解，所以在这里就不bb啦\n\n3.2运行效果当你把湿纸巾印在雨滴传感器上，屏幕上会打印出makerobo Raining!!，数值会随着雨滴量的大小变化（我这里测试的是，水多的时候打印的值小）但最后会趋于稳定，打印128\n\n如果没有水，屏幕上打印makerobo Not Raining，数值打印255\n\n在LM393模块上有两个LED指示灯，在传感器探测到水后，DO-LED会亮起\n\n如果你的DO-LED没有亮起，可以通过该传感器上蓝色的模块，用十字螺丝调节LM393模块的灵敏度（这个蓝色模块调节的是电阻）\n结语有了这个东西，你可以把雨滴传感器丢到窗台上，在不在家的时候，就可以运行代码，看看家里有无下雨了（毕竟时候工作上学的地方和家里隔了十几公里，天气就可能完全不同）\n\n配合cpolar实现内网穿透，效果更佳哦😀\n\n不过知道自己家下雨了，被子还没收，是不是徒增焦虑？\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验14-PS2游戏手柄摇杆","url":"/2022/05/13/code/raspberry/%E5%AE%9E%E9%AA%8C14-PS2%E6%89%8B%E6%9F%84/","content":"本次实验还是需要用到PCF8591模数转换器，莫非它要取代双色LED成为新的常驻嘉宾吗？\n\n\n\n本次实验是摇杆实验。这个玩意可以用于操控机器人或者是树莓派的遥控小车。当然，生活中最常见的用途还是在游戏手柄上。不知道你打不打游戏，有没有用过手柄玩游戏呢？\n\n本人有一个游戏手柄，玩3a还是挺爽的，哈哈\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\nPS2手柄模块\nPCF8591模数转换器模块（实验12）\n一些跳线\n一个一字螺丝刀\n\n\n2.实验原理\n手柄模块通过以90度角安装两个电位计来判断当前的X值和Y值，从而计算出手柄的方向。再加上一个按钮，来判断手柄被按下（也就是游戏手柄上的L3和R3键的原理）\n\n处于静止位置时，此模块从X和Y产生约2.5V的输出。移动操纵杆将导致输出在0v到5V之间变化，具体取决于其方向。如果将此模块连接到微控制器，则可能会在其静止位置读取大约512的值(由于弹簧和机构的微小误差而引起的细微变化)。移动操纵杆时，应该看到该值从0变为到1023，具体取决于其位置。\n该模块有两个模拟输出(对应X和Y坐标)和一个数字输出，表示是否在Z轴上按下。\n在本实验中，我们将引脚X和Y连接到PCF8591A&#x2F;D转换器的模拟输入端口，以便将模拟量转换为数字量。然后在树莓派上编程以检测操纵杆的移动方向\n2.1电路图\n2.2接线图\n\n\n树莓派\nT型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\nPS2手柄模块\nT型转接板\nPCF8591\n\n\n\nVRY\n*\nAIN 0\n\n\nVRX\n*\nAIN 1\n\n\nSW\n*\nANI 2\n\n\n5V\n5V\n5V\n\n\nGND\nGND\nGND\n\n\n\n这个是我的接线图，其实可以直接用双母头跳线直接连接PCF8591和手柄模块，不过还是借助了T型转接板来连接二者。\n\n3.效果演示3.1代码示例//PS2操作杆实验#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;#define makerobo_PCF       120   // 基础管脚120#define uchar\tunsigned charint pcf_AIN0 = makerobo_PCF + 0; // AIN0 端口int pcf_AIN1 = makerobo_PCF + 1; // AIN1 端口int pcf_AIN2 = makerobo_PCF + 2; // AIN2 端口// 方向状态信息 char *state[7] = &#123;&quot;home&quot;, &quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;, &quot;pressed&quot;&#125;;// 方向判断函数int makerobo_direction()&#123;\tint ain_x, ain_y, ain_b;       // X方向，Y方向，B 是否按下\tint makerobo_tmp=0;            // 状态值\tain_x = analogRead(pcf_AIN1);  // X为AIN1端口\tain_y = analogRead(pcf_AIN0);  // Y为AIN0端口\tain_b = analogRead(pcf_AIN2);  // B按下为AIN2端口\t\tif (ain_y &lt;= 30)\t\tmakerobo_tmp = 1;\t\t// up\tif (ain_y &gt;= 225)\t\tmakerobo_tmp = 2;\t\t// down\t\tif (ain_x &gt;= 225)\t\tmakerobo_tmp = 4;\t\t// left\tif (ain_x &lt;= 30)\t\tmakerobo_tmp = 3;\t\t// right\tif (ain_b == 0)\t\tmakerobo_tmp = 5;\t\t// button 按下\tif (ain_x-125&lt;15 &amp;&amp; ain_x-125&gt;-15 &amp;&amp; ain_y-125&lt;15 &amp;&amp; ain_y-125&gt;-15 &amp;&amp; ain_b &gt;= 60)\t\tmakerobo_tmp = 0;\t\t// home 位置\t\treturn makerobo_tmp;&#125;// 主函数int main (void)&#123;\tint makerobo_tmp=0;       // 当前值\tint makerobo_status = 0;  // 状态值\twiringPiSetup ();\t// 在基本引脚120上设置pcf8591，地址0x48\tpcf8591Setup (makerobo_PCF, 0x48);\t// 无线循环\twhile(1) \t&#123;\t\tmakerobo_tmp = makerobo_direction(); // 调用方向判断函数\t\tif (makerobo_tmp != makerobo_status) // 判断状态是否发生改变\t\t&#123;\t\t\tprintf(&quot;%s\\n&quot;, state[makerobo_tmp]); // 打印出方向位\t\t\tmakerobo_status = makerobo_tmp;                  // 把当前状态赋给状态值，以防止同一状态多次打印\t\t&#125;\t&#125;\treturn 0 ;&#125;\n\n这部分比较好理解，代码也很直观。只有home位置需要我们单独进行计算（即手柄处于正中心区域且没有按下的情况，才是home的情况）\n3.2效果翻车不过轮到实际测试的时候，翻大车了。在我还没有动摇杆的时候，它就会显示出左和按钮被按下的提示。我尝试修改代码来修复这个错误，发现并不可行\n\n于是我直接把代码给注释掉，加了一个打印X\\Y\\B当前值的代码\n\n结果呢，在我没动摇杆的时候，打印出来的X和Y都是乱七八糟的。只有按下摇杆的B&#x3D;0可以被正常检测到，其他的方位啥的都是毫无反应。\n\n直接给这个模块下达了死亡通知书，拜拜了您嘞！\n结语通过学习这个模块的代码，可以看到实际上一些零部件的基本原理并不是非常难掌握。不过你想把一个摇杆变成一个完整的游戏手柄，那就需要更复杂的控制代码和手柄的内部芯片来转义这些数字值了。\n\n有什么问题的话，可以在评论区提出呢\n\n还是有所收获的，要是摇杆没坏就好了\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【树莓派】实验15-电位计传感器","url":"/2022/05/14/code/raspberry/%E5%AE%9E%E9%AA%8C15-%E7%94%B5%E4%BD%8D%E4%BC%A0%E6%84%9F%E5%99%A8/","content":"今天的这个实验需要用上两位常驻嘉宾！\n它们就是PCF8591和双色LED！\n\n\n\n\n\n\n1.实验器材\n树莓派开发板\n40p软排线+T型转接板+面包板\n双色LED模块（元老级朋友）\nPCF8591模数转换器模块（长老级朋友）\n电位计传感器\n一些跳线\n\n\n上：电位计传感器；下：双色LED\n\n2.实验原理2.1基本原理\n电位计是一种用于测量电路中电势(电压)的仪器。通过电流计将来自电阻式滑动导线的已知电压的一部分与未知电压进行比较。调节电位器的滑动触点或游标。然后将检流计短暂地连接在滑动触点和未知电压之间，观察检流计的挠度，并调节滑动分接头，直到检流计不再从零偏斜为止。\n此时，检流计不再从未知源汲取电流，并且可以从滑动触点的位置计算出电压的幅值。\n\n电位器，又称POT，是可变电阻器。他们可以通过简单地改变其头部顶部的旋钮来提供可变的电阻。可以基于两个主要参数对其进行分类。一个是电阻(R-ohms)本身，另一个是功率(P-Watts)额定值。\n\n在本实验中，PCF8591用于读取电位计的模拟值并将值输出到双色LED。\n将电位器的引脚SIG（电位器上的OUT管脚）连接到PCF8591的引脚AINO。将双色LED的引脚R或引脚G连接到PCF8591的引脚AOUT，以观察LED的变化。\n\n2.2接线图有了前两次接线的经验，这一次就只需要复刻就行了\n\n\n\n树莓派\nT型转接板\nPCF8591\n\n\n\nSDA\nSDA\nSDA\n\n\nSCL\nSCL\nSCL\n\n\n5V\n5V\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n电位计\nT型转接板\nPCF8591\n\n\n\nOUT\n*\nAIN 0\n\n\nVCC\n5v\nVCC\n\n\nGND\nGND\nGND\n\n\n\n\n\n双色LED\nT型转接板\nPCF8591\n\n\n\nR(中间)\n*\nAOUT\n\n\nGND(-)\nGND\nGND\n\n\nG(S)\n*\n*\n\n\n\n实物图一如既往的乱，哈哈哈\n\n\n3.实验效果3.1代码示例本次实验使用上了AOUT的接口，用于接收电位计的信号而改变双色LED亮度\n//电位器模块实验#include &lt;stdio.h&gt;#include &lt;wiringPi.h&gt;#include &lt;pcf8591.h&gt;#define makerobo_PCF  120 // 基础管脚120// 主函数int main ()&#123;\tint pcf_value ;     // 定义一个变量存储AIN的输入值\twiringPiSetup () ;   // 调用初始化函数\t// 在基本引脚120上设置pcf8591，地址0x48\tpcf8591Setup (makerobo_PCF, 0x48) ;\twhile(1) // 无限循环\t&#123;\t\tpcf_value = analogRead  (makerobo_PCF + 0) ;        // 获取AIN0上的值，读取电位器模拟量值；\t\tprintf(&quot;Potentiometer Value: %d\\n&quot;, pcf_value);         // 打印出该值    \t\tanalogWrite (makerobo_PCF + 0, pcf_value) ;            // 控制AOUT输出电平控制LED灯\t\tdelay (200) ;  // 延时200ms\t&#125;\treturn 0 ;&#125;\n\n\n这里先用Read函数读取电位计的值，然后再用Write函数写入到PCF8591，它用AOUT输出到双色LED，来控制它的亮度\n\n3.2实验效果如果你看过实验12的博客的话，你应该还记得，PCF8591上也有一个电位计，他也能实现本次实验的效果。\n\n但不同的是，本次实验使用的是单独的电位计模块，调节更加方便，不需要使用螺丝刀\n\n运行程序，屏幕上会打印出电位计接收到的值，通过调节旋钮，值在0-255之间波动\n\n效果如图，还是很明显的\n\n结语本篇博客到此结束，感谢你的阅读\n\n","categories":["没事就吃树莓派"],"tags":["Linux","C语言","树莓派"]},{"title":"【教程】Gitee如何下载单个文件","url":"/2022/03/19/code/tools/gitee%E4%B8%8B%E8%BD%BD%E5%8D%95%E6%96%87%E4%BB%B6/","content":"本篇博客将教您如何在gitee上下载单个文件\n\n\n引出问题不知使用gitee的你，有没有遇到过需要下载某个仓库文件的情况？\n\n比如下面这个仓库，是@宏沉一笑大佬转载obsidian的插件的仓库链接\n\n点击下载，你会发现gitee开始给你打包整个仓库文件，一个几百m的仓库怎么说也要几分钟才能下完。可是，我只是需要某一个主题或者插件，gitee却不能单文件或者单文件夹下载，这个时候又要怎么弄呢？\n\n解决问题解决这个问题的方法非常简单！\n只需要用chome或者新版edge浏览器，就能使用一个插件，来解决这个难题！\n我们可以在edge设置里面打开扩展商店，搜索GITEE\n\n下载gitee助手即可！\n\n安装这个扩展以后，重启浏览器，再次打开gitee\n可以看到，每个文件之后出现了单独的下载图标，点击它即可下载单个文件了\n\ngitee助手的代码也是开源的，主页链接👉点我\n\n大佬的提交绿点就是不一样\n\n\n结语个人也建议大家直接用edge浏览器和微软自带的输入法（这两个现在已经做的很好了）\n避免其他国产流氓污染自己的电脑\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["差生文具多"],"tags":["图床","git"]},{"title":"【图床】gitee图床寄了，批量转存文件到阿里云OSS","url":"/2022/03/31/code/tools/gitee%E5%9B%BE%E5%BA%8A%E5%AF%84%E4%BA%86%EF%BC%8C%E5%9B%BE%E7%89%87%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E8%BD%AC%E5%AD%98%E5%88%B0oss%EF%BC%9F/","content":"本篇博客将教您如何转移gitee图床到阿里云OSS\n\n\n\nGitee的问题最近不知道大家的gitee图床是否出现了抽风现象\n简单的说来就是，gitee仓库里面的图片都能正常访问，picgo也能正常上传\n但是本地typora&#x2F;obsidian都无法渲染出图片，甚至出现了图片全变成了gitee的logo的情况\n\n虽然不知道它现在恢复没有（因为我已经全部转移到阿里云OSS了），但还是建议大家不要用gitee作为图床了！因为我之前使用的时候就出现了好几次无法渲染图片的情况\n\n当时我去问了一个大佬，大佬的回复是：“不提倡用代码仓库做图床”\n\n在我的另外一篇博客里面也提到了这个问题\n\n阿里云OSS我已经用了3个月了，它比gitee稳定很多，目前没有遇到过无法加载图片的问题。\n\n下面给大家提一个gitee转阿里云图床的解决方案，理论上来说这个方案是所有图床都能通用的\nGitee批量转阿里云OSS\n思路来自于CSDN用户@1nnoh\n\n1.配置阿里云OSS既然要转阿里云图床，第一步肯定是配置图床了\n这个我之前写过博客，比较详细，大家直接点击下面的链接阅读即可！\n\nTypora+PicGo+阿里云OSS搭建博客图床（超详细）\n\n\n2.批量上传将gitee的图床仓库全部下载下来\n\n建议把图片文件夹打包备份一下，以免出现问题\n以下是我之前作为图床的代码仓库，图片全部存放在img文件夹里面\n\n你可以在阿里云OSS的bucket里面创建一个同名文件夹（不同名也没关系）\n然后把这些图片都上传进去\n\n阿里云oss支持多文件上传，建议大家在已有bucket中创建一个新文件夹，避免出现覆盖bucket已有文件的情况\n\n如果是新bucket，随便创一个文件夹就OK了，之前的博客里面都有提到\n\n\n在配置阿里云OSS的教程中，我建议大家打开picgo的时间戳重命名，因为这个可以防止同名文件的冲突\n\n不管你有没有开启这个功能，都不影响后续的操作（没开的建议开一下）\n3.比较链接区别上传完毕后，我们来比较一下阿里云和gitee的链接差别\n\n你的链接可能和我的不同，请以实际为准\n\n![](https://gitee.com/你的gitee名/仓库名/raw/master/文件夹名字/202108160849879.png)![](https://你的bucket名字.oss-cn-地域.aliyuncs.com/bucket下文件夹的名字/202108160849879.png)\n\n可以发现，其实gitee和阿里云OSS的链接都是以图片的文件名结尾的\n也就是说，我们只需要扫描我们本地的md文件，将原本gitee图床链接的前面部分，整体替换成阿里云链接就可以了！\n即：将gitee链接\nhttps://gitee.com/你的gitee名/仓库名/raw/master/文件夹名字/\n\n替换成\nhttps://你的bucket名字.oss-cn-地域.aliyuncs.com/bucket下文件夹的名字/\n\n后面的文件名无需更改\n\n4.批量修改\n我们需要用到文本编辑神器notepad++\n这个工具非常实用，除了可以修改文件编码格式外，还可以完成批量查找文件内容等很多事情，本文的情况就可以用它来完成\n\n打开notepad++后，在顶部的搜索按钮中，选择在文件中查找，然后选择你的markdown文件路径\n\n打开这个面板后，想必已经不需要我教你怎么修改了吧？😂\n再次提示，修改前请先备份一遍你的文件！\n\n\n你还可以用VSC来批量修改文件中的内容参考软通达的博客👉https://cyddgh.github.io/post/20220304175458/\n\n\nThe end到这里，操作就完成了，不出意外的话，所有的链接都被替换了\n你可以愉快地继续使用阿里云OSS作为你的图床了！\n\n如果这对你有帮助，还请在下方评论说一下哦！\n\n","categories":["差生文具多"],"tags":["图床"]},{"title":"【Git】git仓库code review行话","url":"/2022/08/08/code/tools/github%20code%20review%E8%A1%8C%E8%AF%9D/","content":"程序员这个行业，不管你是大佬还是小弟，代码code review是必不可少的。那么在git上，大家日常交流的缩写语，往往一下就能看出你道行的深浅，至少是入行时间，哈哈，不要露怯，勇敢的跟大佬过招拆招。\n\n\n收集了一些实用的缩写，方便大家日常交流(装B)  \nLGTM  —  Looks good to me，表示认可这次PR，同意merge 合并代码到远程仓库  ASAP -— as soon as possible! 尽快  ACK  —  acknowledgement, i.e. agreed/accepted change  NACK/NAK — negative acknowledgement, i.e. disagree with change and/or concept  RFC  —  request for comments, i.e. I think this is a good idea, lets discuss  WIP：Work In Progress 「进展中」，常见词汇，这里做为 Best Practice 单独提出来，主要针对改动较多的 PR，可以先提交部分，标题或 Tag 加上 WIP，表示尚未完成，这样别人可以先 review 已提交的部分  AFAIK/AFAICT  —  as far as I know / can tell  IIRC  —  if I recall correctly  IANAL  — “ I am not a lawyer ”, but I smell licensing issues  IMO  — （In my opinion），在我看来  TL;DR  —  Too Long; Didn&#x27;t Read 「太长懒得看」，README 文档常见。  PR  —  Pull request「合并请求」  CR  —  Code Review 「代码审查」  PTAL  —  Please Take A Look. 你来瞅瞅？用来提示别人来看一下  TBR  —  To Be Reviewed. 提示维护者进行 review  TBD  —  To Be Done(or Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思。  TBH  —  To be honest 「老实说」  atm  —  at the moment 「现阶段」，\n\n站长注：其实主要还是在看别人pr的时候用，比如别人给你发了一个pull rq，你检查了之后，感觉没有什么问题，就可以发一个LGTM表示你认可了这个pr贡献！\n作者：前端大飞  链接：https://www.jianshu.com/p/238a1e1f4037  来源：简书  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":["差生文具多"],"tags":["git"]},{"title":"【Git】提交信息规范","url":"/2022/08/07/code/tools/git%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83/","content":"git代码提交规范的那些事\n\n\n1.提交格式type(scope): message\n\n\n2.参数介绍2.1 typetype：指的代码的提交类型，不同的提交类型表示对应不同的代码改动，比如：\n\nfeat：新功能的开发\nfix：bug的修复\ndocs：文档格式的改动\nstyle：代码格式改变\nrefactor：对已有的功能进行重构\nperf：性能优化\ntest：增加测试\nbuild：改变了build工具\nrevert：撤销上一次的commit提交\nchore：构建过程或辅助工具的变动\n\n2.2 scopescope：用于说明commit影响的范围，比如：权限模块、还是首页\n2.3 messagemessage：对提交的代码做一个简短的说明，不能过长。\n作者：听书先生  链接：https://www.jianshu.com/p/2ab3a991d1f9  来源：简书  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":["差生文具多"],"tags":["git"]},{"title":"【MD】Markdown如何插入视频、mp3和gif","url":"/2022/05/01/code/tools/md%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/","content":"总所周知，鄙人有一个专栏叫做【差生文具多】，里面记录了一些工具的使用方法，以及使用工具时会遇到的一些问题。\n于是乎，之前就有一个朋友在群里问道“markdown如何插入视频”，当时的我不会弄，然后就出现了下面这一幕👇\n\n明天就弄😂开整！（然而这篇博客是在5.1劳动节写的）\n\n[TOC]\n\n首先你要知道，markdown语法其实是兼容html语法的，这也是为什么我们可以很方便地把markdown转换为html，放置到博客网站上\n所以我们可以用html代码来插入视频和mp3音乐\n1.md插入视频对应语法如下，这两个都可以\n&lt;video src=&quot;视频链接&quot;&gt;&lt;/video&gt;\n\n&lt;iframe height=498 width=510 src=&quot;视频链接&quot;&gt;\n\n如果我们插入一个B站视频的链接，在typora中的显示如下\n\n实际上它就是把一个网站插入到了我们的markdown文件中，形成了一个简易的浏览器\n其实你如果复制一个视频，直接在typora里面粘贴的话，typora是会自动生成对应的html链接的\n&lt;video src=&quot;../../../../Desktop/md.mp4&quot;&gt;&lt;/video&gt;\n\n但这个链接和一个本地的图片链接相同，如果需要上传到CSDN网站上的话，CSDN无法正常转存你的视频\n我们要做的，就是把这个视频也上传到我们的图床里面\n\n如果你不知道什么是图床，那就看看我吧：【图床搭建教程】\n\n图床并不是只能保存图片，它可以保存任何格式的文件。将视频拖入picgo，即可上传我们的视频到图床\n\n点击箭头所指按钮，复制我们视频的链接\n\n然后把视频链接填入上面两种形式其中之一的html代码中，即可显示出视频！\n\n\n1.2CSDN博客插入视频然后我就发现CSDN不支持上面两种样式，不过我们可以在markdown编辑器的顶部选择视频\n\n然后这里会让你填写视频的地址，目前只支持tx优酷还有bilibili的已上传视频\n\n或者你可以选择“插入已有视频”，这会把视频上传到CSDN上\n\n\n2.md插入MP3文件2.1网易云音乐外链插入MP3文件的方式很简单，我们可以使用网易云音乐，选择一个非VIP歌曲，点击生成外链播放器\n\n然后复制这里的html代码即可！\n\n&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=33367876&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;\n\n\n\n上面就生成了一个网易云音乐的外链播放器\n\n2.2自己的MP3音频文件根据上面html插入视频的代码，就可以猜出来音频的代码是啥\n把vedio改成audio就可以啦！\n&lt;audio src=&quot;mp3文件链接地址&quot;&gt;&lt;/audio&gt;\n\n下面就是一个我上传的MP3音乐文件\n\n在typora中的样式如下👇\n\n3.md插入gif这个就没有什么特殊的格式了\ngif图片也是一个图片，直接用![]()这种标准的markdown插入图片的样式就可以了\n\n结语这个新文具的博客到这里就结束啦！\n希望对你有帮助！😍\n虽然我感觉在markdown中插入视频的使用场景不是很多\n","categories":["差生文具多"],"tags":["图床","typora"]},{"title":"【MD】用Obisidian的你一定不能忽略的图片保存问题","url":"/2022/03/18/code/tools/obsidian%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/","content":"[TOC]\n问题来源😥今天在obsidian使用kanban插件的时候，发现obsidian其实是可以把插入的图片自动保存在本地库文件夹里面的。\n\n这一点其实非常重要！\n之前我从gitee图床转到阿里云OSS，最大的原因就是上学期期末复习高数的时候，自己写的高数笔记里的图，因为gitee的短暂更新导致无法加载！最后过了差不多1h图片才能正常加载出来，相当于白白浪费复习时间！\n\nTypora+PicGo+阿里云OSS搭建博客图床\n\n你想想，这还是在学校里，耽误点时间总归不会出现什么“要人命”的大事。但如果是工作中你写的一些日志笔记，因为图床网站的无法访问而暂时看不见，那不就寄了吗？\n更别提图床是保存在网络中的，总归会有些隐私问题。就连百度网盘都扫用户文件，我们用户又怎能知道阿里云有没有干这种事呢？\n\n如何解决？🕵️‍♂️1.typora设置图片保存查找网络资料，看到了这篇博客\n\ntypora设置图片根目录_用Obsidian一定要注意的图片和笔记问题！\n\n里面讲到了可以用typora来解决这个问题\n打开typora左上角的文件-偏好设置\n依照下图设置\n\n可以看到，复制进去的这个图片（其实就是上面这个截图）显示出了它的相对路径，并正常渲染。\n\n打开本地文件夹，可以看到typora在你当前这个md文件的目录下创建了一个photo文件夹，将你贴的图复制进了这个文件夹中\n\n\n同时如果我们在obsidian打开这个md文件，可以看到图片是能正常显示出来的\n\n到这里，其实我们的问题已经解决了！\n\n2.博客问题但是！这好像和我们当初使用图床的目标冲突\n再来看看下面这个图片，当我把这篇博客从typora复制到CSDN上的时候，它肯定会保存失败\n\n\n\n因为图片本身是在本地硬盘里，CSDN无法原力读取你硬盘里的文件，自然无法转存这张图片了！\n解决这个问题又有两个新的方法~~\n2.1 每次编写不同文件的时候，进typora设置进行更改当我写博客的时候，typora需要这样设置，即可借助picgo自动上传我复制进去的图片到图床里，也能正常复制到CSDN中（教程在博客开头的链接里）\n\n而当我写个人随笔/日记/学习笔记这类并不打算上传到博客里的内容时，就可以把它改成上面提到的本地存储方式\n但是这样非常不方便！万一哪一次写博客的时候忘记改回来了，上传博客的时候就想马良了（我是觉得我肯定会忘，这个亏吃不得）\n\n2.2 分开两个软件进行写作别急，刚开头不是提到了，我是在obsidian里面发现这个功能的嘛？\n现在我们要做的，就是将obsidian也设置为同样的保存方式，让复制进去的图片自动保存在本地目录里。\n这样用typora写博客，obsidian写自己的东西，两全其美！\n\n3.obsidian设置图片保存在1.typora方式提到的那篇博客里面，作者发现了obsidian复制图片的时候使用的是自己的格式![[  ]]\n这种格式并不是所有markdown编辑器都认识！\n\n所以我们需要更改obsidian的设置，让它变成大部分markdown编辑器通用的![ ]( )形式\n\n先看看你的obsidian用的是不是最新版本0.13.33，如果不是，先更新一下\n\n\n打开obsidian设置-文件与链接，找到下图的这几个设置。如果你没有更改过，默认的设置和图片里面应该是一样的\n\n我们需要改成以下的样子\n\n再次尝试插入图片，可以看到新插入的这个图片已经变成了md通用的![ ]( )形式\n\n再次用typora打开这个文件，可以看到第一个图片链接依旧不认识，但是第二个图片已经被正常加载出来了！\n\nobsidian的设置也搞定了！\n今后写作的时候，就可以分开两个软件进行写不同的内容啦！\n\n一些提升obsidian编辑体验的插件最后，你可能会想，obsidian的使用体验没有typora好呀！\n\ntypora可以实时渲染，obsidian需要单独切换\ntypora有打字机模式，obsidian需要滚来滚去\n\n欸，别急，这里给大家推荐几个提升写作体验的插件，装了之后，上面这俩功能就都有啦！\n\n\n更新：发现这个功能其实obsidian已经自带了，但是我在编辑器中选择了旧版编辑器导致没看到这个功能。既然自带了就没必要下插件啦！但是问题又来了，下面这个打字机插件只有旧版编辑器才有效。如果你需要这个模式，那就使用上面的渲染插件+这个打字机插件来创作吧（本人现在就是这么做的）你觉得事情真的有那么简单吗？并不是的！更新了打字机插件到0.2.1以后，发现他已经支持了新版本编辑器了，芜湖起飞！\n\n下面还有picgo上传图床的插件\n以及一个自动粘贴链接的插件\n\n\n最后还有这个插件，可以优化obsidian选中中文句子的分词功能\n\n安装完这些，使用体验就很接近typora啦！\n当然我还是更喜欢用typora来编辑\n\n结语😋依照这篇博客设置完后，就能更好地分开写作 私人内容和博客文件啦\n以后也可以放心地往md文件中加图片了，毕竟在本地里，谁都看不到\n\n不过也要考虑到本地文件大小问题，别把你的OneDrive塞满图片导致空间不够用了。那就得掏💴升级容量了，我现在只有免费的5GB\n有些图片可以考虑用光影魔术手等软件来减小文件体积，比如手机拍的笔记图，没必要那么高清，6mb降到500kb都还能看清楚\n\n你学废了吗？\n\n如果对你有帮助，还请点个👍，万分感谢！\n\n","categories":["差生文具多"],"tags":["图床","typora","obsidian"]},{"title":"【Git】Sourcetree的初始化与使用","url":"/2022/02/25/code/tools/sorcetree%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%99%E7%A8%8B/","content":"[TOC]\n前言还在用小乌龟管理你的git本地代码吗？\n为何不来尝试一下，这款界面更加直观的git可视化工具！\n\nsorcetree官网👉https://www.sourcetreeapp.com/\n\n别看到英文官网就跑了，软件本身是中文界面！\n\n\n注：本博文只讲述sourcetree初始化方式，并不讨论其与TortoiseGit的功能强弱\n\n什么？你还不知道git是啥？\n那还不赶快点击这篇博客了解一二！👇\n\n实习生 Git 不熟练，还没脸去问是种什么体验…\n\n\n1.初始化下载安装以后，你会看到以下界面\n若不需要用bitbucket，选择跳过即可\n\n第二步，sourcetree会让你下载这两个工具\n\n如果你的电脑里已经有了，它能检测出来安装位置\n如果你的电脑里没有这两个工具，它会自动帮你下载\n\n\n第三步，它会让你填写你的用户名和邮箱\n建议这里和你的gitee或github上的用户名&#x2F;邮箱同步！\n\n填写好后，点击下一步，会弹出这个界面\n选择“否”即可\n\n2.克隆仓库初始化完成后，会变成以下界面\n\n源路径：填写你的gitee&#x2F;github仓库链接\n目标路径：选择一个本地的空文件夹，注意路径不要有中文\n名字：填写一个会在Sourcetree里显示的仓库名字\n\n\n 那么问题来了，要怎么找到你的仓库链接呢？👇\n\n\n填写完毕后，sourcetree会开始下载，并在你选择的路径下创建本地仓库的文件夹\n\n如果你有多个远程仓库，点击+号重复上述步骤即可\n\n\n添加已有本地仓库已有本地仓库的情况下，可直接点击Add添加\nsourcetree会检测出来这是一个git仓库\n\n3.提交代码回到主界面，这里会出现你的仓库push历史，以及操作的日期\n如果你的本地仓库里面做出了更改，和网络仓库不一致的时候，软件内会在第一行显示有未提交的更改\n\n点击文件状态，这里会显示你本地仓库的那些文件做出了更改\n\n未暂存文件：本地文件做出了更改，但并没有确认\n已暂存文件：保存了本地文件的副本，等待push到远程仓库\n底部白框：填写push说明\n\n\n依照下图操作即可\n\n如果你不选择“立即推送变更，就需要在左上角的“推送”选项内进行二次操作，才会上传到远程仓库\n\n\n如果你之前没有使用过git，在这一步点击提交之后，会弹出一个框让你填写你的账号密码\n填写对应网络仓库（gitee&#x2F;github）的账号密码即可！\n\n用户名：填写注册邮箱\n\n\n由于本人已经填写过，且不知为何无法在账户&#x2F;web凭据中找到并删除它，故无法复现这一步\n\n所以我帮同学也弄了一个gitee账户，顺便嫖来了这张填写账户密码的截图\n\n填写完账户密码后，sourcetree就开始上传你的代码了！\n\n如果上传错误，这里会显示对于的git报错信息，根据报错信息百度查找解决方案即可！\n\n\n上传成功后回到History界面，可以看到我们最新的提交\n\n刷新网络仓库页面，可以看到推送成功了！\n\n这2个月的使用下来，只要sourcetree在上传的时候没有报错，那代码是铁定上传成功了。\n无需打开网络仓库再确认一下，还是挺方便的！\n\n如果你的本地仓库并没有做出更改，打开文件状态栏目的时候会显示“没有什么可提交的”\n\n\n\n4.回滚提交git最重要的一个功能，就是保存我们代码的历史版本\n如果你最新push的代码中写了一堆bug，或者不小心删掉了一些代码，就可以在git里面找到你的历史版本\n在sourcetree的主界面中，右键一个之前的提交信息，可以看到两个选项\n\n这两个选项的区别，简单描述如下：\n\n回滚：将改动的代码提交到本地仓库，但未推送到远端仓库的时候\n重置当前分支到此次提交：将改动的代码提交到本地仓库后，并已推送到远端仓库的时候\n\n具体的区别及操作方法，大家可以参考这篇博客👇\n\nsourceTree回滚提交和重置当前分支到此次提交的区别\n\n重置分支演示在这里我简单演示一次重置分支的方法\n假设我们不小心删除了本地文件里面的代码\n\n比如想复制其他代码到此文件，却在复制的时候ctrl+a全选，覆盖了之前的代码\n\n\n而在提交代码的时候，我们又忘记检查，直接上传到了远程仓库\n\n\n这时候，就可以选择我们上一次的push，选择重置当前分支到此次提交\n这里会出现3个选项，我们可以选择最后一个“强行合并”\n\n确认后，打开之前被我们删除了内容的代码文件，发现删除了的代码已经回来了！\n\n由于之前的更改已经提交到了远程桌面，sourcetree发现本地仓库落后于远程仓库，需要我们进行拉取操作\n但拉取之后，我们错误的更改就又回来了，这并非我们的目的\n这时候可以在souretree工具-选项中开启git的强制推送\n\n注：强制推送具有风险，建议提前备份分支内容\n\n\n选择我们重置的分支，并选择推送\n\n勾选上左下角的强制推送\n\nsourcetree会开始上传，上传完毕后，可以看到，之前的那次推送已经消失了！\n\n打开gitee检查一下，可以看到这里显示了“强制推送”\n\n找到我们之前更改过的那个文件，发现它已经回到了我们删除之前的内容\n\n我们的目的也就完美达成了！\n\n还是建议大家上传的时候多多检查，之前我就干过一次这样的蠢事。\n第二次编写那个文件的时候，才发现之前的代码无了。还好可以回退版本！\n\n\n结语个人理解，Sourcetree相比TortoiseGit，最大的优点就是它的界面更美观！\n\n还有另外一个我很喜欢的点：使用sourcetree不会让你的右键菜单多一堆选项！\n\n使用什么样的工具是大家各自的选择，一起进步才是我们共同的目的！加油😋\n\n如果有说的不明白的地方，欢迎在评论区提出！\n\n","categories":["差生文具多"],"tags":["git"]},{"title":"【Artalk】在wiki js站点上使用Artalk评论系统","url":"/2023/01/05/code/tools/wikijs%E4%BD%BF%E7%94%A8artalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","content":"本篇博客将教您如何在wiki js站点上使用artalk评论系统\n\n\n[TOC]\n1.介绍1.1 wiki js\nhttps://github.com/requarks/wiki/\n\nwiki js是一个开源的wiki站点，可以在线编辑页面。\n页面以markdown编辑，同时支持富文本格式；因为其用git来管理提交历史，且在线编辑不需要用户知道如何操作git，所以非常适合多人协作撰写文档\n\n如果你只是想要一个博客站点，没有多人协作需求，那么hexo会更合适您\n\n共享文档（如金山文档）的提交历史大多数都不够详细，虽然有插入/删除历史，但是其没有标明上下文，你需要猜他是在文档的啥地方改了东西，非常不方便！\ngit是一个版本管理软件，能清楚地知道xx用户修改了xx文档的xx行，并能看到修改之前和修改之后的提交对比。这部分就不赘述了\nwiki js还有很棒的一点就是，你可以设置一个git仓库作为文档的备份，其会定时把整个站点的所有页面（包括图片）都上传到这个git仓库里面。即便站点因为某些原因出问题了，我们还有git仓库的备份😁\n\nwiki js的安装参考官方文档，建议用docker部署，方便的很，直接对着敲命令就行了。进入系统创建管理员账户后，可以在设置的local里面找到语言选择，下载中文语言包即可改成中文页面！\n\n\nWik js自带了评论系统，也支持markdown评论，但是它连最基础的回复评论都不支持，实在是有些捉急，所以才需要配置一下artalk来作为评论系统\n1.2 artalk\nhttps://artalk.js.org/\n\nartalk同样是一个开源的评论系统，作者写v1的时候还是一名高中生（人比人气死人，我太菜了）\n咳咳，这不是重点！\n\nartalk支持markdown发送评论，支持发送表情，还支持上传图片！作为wikijs的评论系统再合适不过了~\nemm，其实还有另外一个原因，那就是wiki js目前支持的3个第三方评论系统，似乎只有artalk是免费的😥\n\n2.安装artalk后端2.1 docker-compose安装基本安装方式参考官方文档，个人更加推荐用docker compose部署\n\nhttps://artalk.js.org/guide/deploy.html#docker-compose-%E9%83%A8%E7%BD%B2\n\n刚开始我拉取镜像的时候，一直出现505错误（添加了镜像源）后续在镜像后面加上最新的版本号才正常拉取了镜像\nversion: &quot;3.5&quot;services:  artalk:    container_name: artalk-go    image: artalk/artalk-go:2.3.0    ports:      - 8080:23366    volumes:      - ./data:/data\n\n创建好docker-compose.yaml文档后，用下面的命令运行\ndocker-compose up -d\n\n查看你服务器的8080端口（记得在云服务器防火墙里面开放端口）如果能打开下面的后端页面，那就是ok了\n\n2.2 开放管理员账户默认情况下，管理员账户是关闭的，我们需要关闭容器后，修改配置文件开放一个管理员账户\ndocker-compose stop\n\ncd进入data目录（这里的data目录是你在docker compose中映射的本地路径，默认应该就在docker-compose.yaml所在路径下会出现一个data文件夹）\n可以看到一个artalk-go.yml文件，我们需要修改的就是这个文件，找到下面的字段，对应修改后保存\n\n关于密码的部分参考文档 https://artalk.js.org/guide/backend/multi-site.html#%E7%AE%A1%E7%90%86%E5%91%98%E9%85%8D%E7%BD%AE\n\n\ndocker-compose up -d\n\n重新启动容器，用刚刚设置好的账户登录；后台的管理页面可以修改很多配置，我们不需要动配置文件了！\n2.3 配置sslwiki js必须要用ssl和https才能正常使用artalk，我尝试了公网IP:端口的方式，它认不出来😥\n所以我们需要在artalk的后台配置一下ssl（记得点界面右下角的应用）\n\n再次用域名打开页面，此时就没有报错了\n\n备注：我是用frp穿透到香港来映射域名的，所以ssl还需要在frp里面设置一下，请根据您自己的情况配置ssl！\n2.4 图片上传如果想让用户能上传图片，还需要做一些小操作；首先是启用图片上传（记得点界面右下角的应用）\n\n然后需要去后台在data目录下创建一个artalk-img文件夹（我刚开始没有创建这个文件夹的时候，没有办法正确上传图片）\n回到wiki js的界面测试一下，图片上传成功\n\n2.5 邮箱提醒避免有老哥之前没有用过stmp服务，这里也简单说一下吧\n可以注册一个网易的163或者126邮箱，找到设置里面会有一个stmp\n\n进入后，先把这两个服务都开启\n\n再点击这里新增授权密码，会弹出来一个二维码码让你用手机给一个号码发个短信，然后就会出现一个授权码，记住这个授权码\n\n回到artalk的后台进行如下配置\n\n这样就OK了，找朋友发条评论并回复，测试一下邮箱提醒能否正常使用吧！\n3.wiki js使用这部分就很傻瓜了，直接用起来就可以了\n3.1 artalk创建站点artalk虽然会有一个默认站点，但是那个wiki js不一定能正常使用，所以我们需要自己创建一个站点\n\n需要填写站点名称和url，名称建议用英文，避免编码问题\n\n然后为了避免错误，还可以在设置里面添加一下可信域名\n\n3.2 wiki js使用进入wiki js的管理页，找到评论，选择artalk\n\n填入域名和在artalk里面配置的站点名字后，点击应用\n回到wikijs的页面，此时就可以看到artalk的界面啦！\n\n3.3 bug我使用的时候遇到了评论框飞到顶栏上面的bug，已经在wiki的仓库中发评论了\n\nhttps://github.com/requarks/wiki/discussions/6015\n希望能尽快修复这个bug~\n未完待续后续有啥问题，我会在这里补充的~\n","categories":["差生文具多"],"tags":["artalk","wikijs"]},{"title":"【Git】在Windows CMD中和VScode中配置已经安装好的git","url":"/2022/08/01/code/tools/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEpath%E8%AE%A9windows%20cmd%E7%94%A8%E4%B8%8A%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84git/","content":"本篇博客将教您如何将sourcetree下载好的git导入到windows的cmd进行使用\n\n\n问题引出\n我使用系统为win11。win10的操作理应相同，只不过设置的位置可能有差异\n\n我现在使用git主要用的是sourcetree的可视化界面，可以清楚地看到每一次提交的diff和提交历史，非常好用，也强烈推荐大家使用 【使用教程】\n\n不过当你初次安装sourcetree的时候，他会帮你下载一个git\n如果系统中已有git，也可能会被移动到sourcetree自己的内置使用目录中\n\n这样就会对我们在其他地方使用git-cmd造成一定的不便。\n对于git仓库，sourcetree会提供一个命令行的选项。但是需要从这里面打开肯定不如直接右键选择windows cmd方便！\n\n不过对于我来说，一个非常棒的优点就是——干掉了右键菜单的两个按钮😂\n所以现在我们想做到的就是让windows自带的cmd也可以直接用上git，这样就不担心单独使用git-cmd不方便了\n\n1.设置新的终端路径依据上面sourcetree给出的路径，找到被藏起来的git\nC:\\Users\\用户名\\AppData\\Local\\Atlassian\\SourceTree\\git_local\n\n注：AppData文件夹是隐藏的，需要打开文件资源管理器中的查看隐藏文件选项\n\n在随便一个地方右键，打开cmd\n\n右键上方边栏，选择设置\n\n划到最底下，选择添加一个新的配置文件\n\n这样设置即可，git的图标也是在我们刚刚打开的git目录中可以找到的\n\n注意，命令行要选择bin中的bash.exe而不是git-bash，后者会打开git自己那个老旧的命令行终端\n\n\n这时候，我们就可以在顶部的小三角图标中选择git bash进行使用了！\n\n\n不过！这时候如果你在windows powershell里面打出git，还是会提示找不到git命令。如果每一次都需要在下拉菜单中选择，那还是很麻烦呀！\n\n2.设置环境变量打开电脑设置-系统，拉到最底下，找到系统信息\n\n选择高级系统设置\n\n在高级面板中打开环境变量\n\n在下方系统变量中找到path，选择编辑\n\n在里面新建一个git的环境变量，填入cmd文件夹的路径，注意是cmd文件夹！\n\nC:\\Users\\用户名\\AppData\\Local\\Atlassian\\SourceTree\\git_local\\cmd\n\n\n填入后确定保存，再次打开windows power shell，输入git\n出现下方的git命令帮助，那就大功告成！\n\n\nvscode中git路径配置来都来了，顺便说一嘴vsc中的git路径配置吧！\n在设置中搜索git path，点击在settings.json中编辑\n\n在git.path中填入路径即可！\n注意：因为有转义，所以路径分隔符\\需要改成两个\\\\\n\n点击左侧git管理页面，看到正常显示出仓库就OK啦！\n\n","categories":["差生文具多"],"tags":["git"]},{"title":"【教程】Typora+PicGo+阿里云OSS搭建博客图床（超详细）","url":"/2022/01/11/code/tools/%E9%98%BF%E9%87%8C%E4%BA%91OSS+picgo+typora/","content":"如果你想搭建一个和本站类似的个人博客，那就需要图床来辅助\n\n\n[TOC]\n为什么要搭建博客图床?以CSDN为例，我们可以选择使用大部分blog平台通用的markdown语法进行博客创作\n虽然CSDN自带的编辑器已经能满足我们95%的写作需求\n但是Typora在markdown语法编辑上能给你提供更好的写作体验\n所以我选择了以Typora+Picgo+图床的方式来进行博客创作\n\n而在本地的markdown文件.md中，图片是以“外链”这一形式存在的\n\nOffice word中，图片是直接插入docx文件里面\nMarkdown中，图片只是一个本地&#x2F;联网的地址\n\n也就是说，如果我们使用本地markdown编译器（如typora）来编辑MD文件的时候，如果MD里面插入的图片的源文件被移动或者删除了，我们的MD文档里面对应的图片也无法显示出来。\n同时，如果我们用本地编辑器写好了一篇博客，想把它上传到CSDN上。CSDN是无法自动转存文件里面的图片的（因为这个图片只是一个你硬盘里面的文件路径）\n什么是图床？在我们往typora里插入图片的时候，PicGO自动上传图片到图床，并返回一个图片的链接 \n\n这时候你的图片就是一个**网络的链接(网址)**，不再是本地路径。你也可以在任何有网络的地方、用任何设备访问这张图片了\n\n即便是本地的那张图片移动or删除，也不会影响图床里的这张图片\n同理，typora里面的图片也就不会失效了！\n\n接下来就是如何搭建阿里云OSS图床的教学了！\n前排提醒，阿里云图床需要付费💴，但价格非常便宜！ \n\n如果你想白嫖，也可以考虑用gitee作为你的图床。但是gitee有单仓库文件大小限制(600mb)。后续图片多了，转移图床的成本更高。还不如一开始就选个好的平台，不是嘛？\n\ntypora+picgo+gitee图床配置方法，看这个👉【链接】\n\n\n22.03.26更新：果然“免费的才是最贵的”，经过多个朋友的反馈，确认gitee图床已经崩溃，图片在gitee仓库内没有问题，但是typora&#x2F;picgo&#x2F;obsidian内都无法正常预览图片，CSDN也无法转存！可能是gitee更新了外链机制。还是建议大家更着本篇博客使用阿里云OSS吧！\n1.准备软件1.1Typora\nTypora：【中文官网】\n\n想必各位应该听很多博主安利过Typora这款软件，这里就不展开描述了\n新版本typora需要付费买断。可以考虑支持正版，也可以去找找旧版本安装包\n\n参考这个视频👉【链接】\n如果你找到了旧版本安装包，需要确认typora版本高于0.9.86\n\n1.2Picgo\nPicGo：【Github地址】\n\n找到对应安装包，下载安装即可\n\n2.配置阿里云OSS在浏览器搜索阿里云OSS，即可找到官网\n\nhttps://www.aliyun.com/product/oss\n\n\n2.1注册,开通对象储存注册账户并实名后，进入你的控制台\n\n选择对象储存并开通\n\n2.2创建bucket在左侧选择概览，然后在右侧创建一个新的bucket\n\n注意： \n\nBucket名字不能有大写字母\n服务器就近选择\n图床选择标准存储\n读写权限公共读\n\n\n创建完成后，你的bucket应该就出现在了左侧\n2.3找到你的地域节点点击你的bucket名\n\n然后点击bucket下的概览\n\n在访问域名一栏找到你的地域节点，后面会用到\n\n如图，只需要复制oss-cn-shenzhen即可，不需要后面的.aliyuncs.com\n\n\n2.4找到你的Key来到右上角，鼠标放在你的头像上，在弹出的框里选择AccessKey管理\n\n在弹出的选项框里，选择“继续使用”\n\n进入后，创建一个AccessKey\n\n在弹出的界面里，记住你的accessKeyId和accessKeySecret\n\n2.5给你的阿里云账户充值2.5.1收费问题阿里云OSS的各项收费是独立的！\n对于图床而言，有两种收费形式\n\n以充值的方式使用储存容量以及流量(默认状态)\n按年&#x2F;月收费，购买一定存储包。流量额外收费\n\n也就是说，即便你购买了下图的存储包，你依旧要为访问图床的流量付钱！\n\n\n下图是在默认状态下，容量和流量收费的价格\n\n图床使用的是标准型，请勿购买其他类型\n\n\n储存容量：0.12元&#x2F;GB&#x2F;月\n图片上传到阿里OSS流量：免费\n外网流出流量(如typora访问图床图片)：闲时0.25元&#x2F;GB，忙时0.50元&#x2F;GB\n\n\n\n仔细算算，我们图床的数据量其实很小的\n\n0.12元&#x2F;1GB&#x2F;1个月，一年就是1.44元，远低于40GB的9元收费！\n截图&#x2F;照片以平均0.5mb&#x2F;张估算，1gb可存放超过1600张图片！\n数据低于7GB的情况下直接充值，以GB付费其实比购买储存包更加值得！\n\n2.5.2注意事项\n记得给阿里云账户充值！！别到时候欠费停用了！！\n刚开始作图床的时候，直接充值使用即可，无需购买容量包！\n\n\n到这里，我们阿里云OSS基本配置完毕了😎\n\n3.配置picgo打开picgo后，在你windows的状态栏里找到picgo的图标，打开picgo的主界面\n\n3.1图床设置在图床设置里面选择阿里云OSS，依照以下步骤填写信息\n\n设定Keyld：填写刚刚获得的AccessKeyID\n\n设定KeySecret：填写AccessKeyIDSecret\n\n设定储存空间名：填写bucket名称\n这里填写的是bucket名称，不是浏览器里的域名\n\n确认存储区域：填写你的地域节点，注意复制的格式\n\n指定存储路径：其实就是自定义一个文件夹的名字，以/结尾\n它会自动在你的bucket里面创建一个文件夹，并把图片上传进去\n\n\n\n弄完之后，记得“确定”，并点击“设置为默认图床”！\n\n3.2picgo设置在设置里打开时间戳重命名和上传后自动复制URL\n\n时间戳重命名：以上传时间来重命名图片，避免同名的图片无法上传（该设置不影响本地图片名）\n\n\n4.配置typora进入typora主界面，点击左上角的“文件-偏好设置”\n\n选择图像\n\n插入图片时上传图片\n\n下面的选项全勾上\n\n上传服务选择PicGo(app)\n\nPicGo路径：找到picgo的安装路径\n不是安装包的路径！！！！\n\n\n\n\n5.大功告成！设置完毕后，我们点击验证图片上传选项\n如果弹出以下弹窗，我们的图床就搞定了！😀\n\n最后新建一个文件，验证图片是否正常上传\n日常写作的时候，我们只需要复制图片，在typora里面粘贴即可，无需拖动！\n当你的图片链接显示为阿里云的网络链接，而不是本地路径时\n\n我们的图床就大获全胜！\n开始你的创作吧！🧐\n\n如果这篇博客帮到了你，还请在留言回复一下哦~万分感谢！\n\n\n如果你在配置完picgo后发现有问题，检查过picgo配置内容和阿里云OSS设置、重启picgo、重启电脑后仍然无法成功上传。还可以参考这篇博客的配置方法👉【博客】\n\n","categories":["差生文具多"],"tags":["图床","typora"]}]