<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="爱折腾的代码初学者"><meta name="author" content="慕雪年华"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><title>【算法】算法的空间复杂度和时间复杂度 | 慕雪的寒舍</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/myPNG.jpg"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/regular.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/solid.min.css"><link rel="stylesheet" href="//unpkg.com/hexo-theme-keep@3.6.1/source/font/css/brands.min.css"><script id="hexo-configurations">let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"blog.musnow.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/myPNG.jpg","favicon":"/images/myPNG.jpg","avatar":"/images/myPNG.jpg","font_size":null,"font_family":null,"hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/background.jpg","background_post_img":"/images/mothra.png","description":"吾心如一，慕雪纷纷","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true},"left_side_width":"260px","content_max_width":"920px"},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"waline","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":"欢迎留下你的声音😋"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://waline.musnow.top/","reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"center","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.2.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/about/"><img src="/images/myPNG.jpg"> </a><a class="logo-title" href="/">慕雪的寒舍</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/qa">留言</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/qa">留言</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【算法】算法的空间复杂度和时间复杂度</span></div><div class="article-header"><div class="avatar"><img src="/images/myPNG.jpg"></div><div class="info"><div class="author"><span class="name">慕雪年华</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2022-03-13 11:57:34</span> <span class="mobile">2022-03-13 11:57</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-04-03 09:23:39</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%AA%E5%A4%8D%E6%9D%82/">数据结构太复杂</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a>&nbsp;</li><li>| <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>&nbsp;</li><li>| <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>&nbsp;</li><li>| <a href="/tags/OJ%E5%88%B7%E9%A2%98/">OJ刷题</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>3.9k 字</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><h1 id="前言🕵️‍♂️"><a href="#前言🕵️‍♂️" class="headerlink" title="前言🕵️‍♂️"></a>前言🕵️‍♂️</h1><p>在之前的学习中，已经接触过了<strong>网上OJ题目</strong></p><p>在一些题目中，我们经常可以看到<strong>时间复杂度和空间复杂度</strong>的要求</p><p>你可能和我有一样的疑惑，复杂度究竟是什么？我要怎么评判我自己写的算法的复杂度？</p><p>今天就让我们来认识认识~~</p><img lazyload="" alt="image" data-src="https://img.musnow.top/i/2023/02/image-20220313100312155.png" height="200px"><hr><h1 id="1-算法效率🧐"><a href="#1-算法效率🧐" class="headerlink" title="1.算法效率🧐"></a>1.算法效率🧐</h1><p>和做任何事情一样，我们写的算法，自然也有它的运行效率。效率越高越好</p><h2 id="1-1什么是算法"><a href="#1-1什么是算法" class="headerlink" title="1.1什么是算法"></a>1.1什么是算法</h2><p>算法可以简单地理解为我们为了求解一个问题，所写的函数</p><p>在初识C语言中，我们学习过<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/121199068">利用递归求解斐波那契数列<i class="fas fa-external-link-alt"></i></a>的算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Fib</span><span class="params">(<span class="type">size_t</span> N)</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(N &lt; <span class="number">3</span>)</span><br><span class="line">     	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> Fib(N<span class="number">-1</span>) + Fib(N<span class="number">-2</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这个算法只有3行代码，看上去非常简洁——但是简洁的代码不一定效率就高！</p><h2 id="1-2如何衡量？"><a href="#1-2如何衡量？" class="headerlink" title="1.2如何衡量？"></a>1.2如何衡量？</h2><p>算法在编写成可执行程序的时候，main函数使用这个算法，需要调用一定的空间，消耗一定的时间。算法的效率就是通过<strong>空间和时间</strong>这两个维度来评判的</p><ul><li>时间复杂度：衡量一个算法的运行速度</li><li>空间复杂度：衡量一个算法运行需要开辟的额外空间</li></ul><hr><h1 id="2-时间复杂度⏰"><a href="#2-时间复杂度⏰" class="headerlink" title="2.时间复杂度⏰"></a>2.时间复杂度⏰</h1><p>算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。<strong>算法中基本操作的执行次数，为算法的时间复杂度</strong></p><ul><li>时间复杂度是一个近似值，并不是实际运行的时间</li><li>实际上代码的运行时间，和机器的内存、cpu性能和平台都有关系，同一个代码在不同的机器上运行时间都不一样，如果只以纯粹的时间来考核，很难分析</li></ul><p>找到某条基本语句与问题规模N之间的数学表达式，就算出了该算法的时间复杂度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        {</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * N ; ++ k)</span><br><span class="line">    {</span><br><span class="line">     	count++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> M = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (M--)</span><br><span class="line">    {</span><br><span class="line">     	count++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>请问这个代码中，count语句执行了几次？<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="24.671ex" height="2.565ex" role="img" focusable="false" viewBox="0 -883.9 10904.7 1133.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mo" transform="translate(749,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1138,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2026,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2692.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(3748.6,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mn" transform="translate(975.3,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(5349.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(6349.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(7072,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(7794.2,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(8904.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(9904.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g></svg></mjx-container></p><ul><li>N = 10 F(N) = 130</li><li>N = 100 F(N) = 10210</li><li>N = 1000 F(N) = 1002010</li></ul><p>你可能会简单地认为，F(N)的结果就是我们的时间复杂度。其实并不然，我们并不需要一个精确的运行次数，<strong>只需要知道程序运行次数的量级就行了</strong></p><p>这里我们使用<code>大O渐进表示法</code>来表示时间复杂度（空间复杂度同理）</p><h2 id="2-1大O的渐进表示法"><a href="#2-1大O的渐进表示法" class="headerlink" title="2.1大O的渐进表示法"></a>2.1大O的渐进表示法</h2><p><strong>大O符号（Big O notation）：是用于描述函数渐进行为的数学符号</strong></p><blockquote><p>推导大O阶方法：</p><ol><li>用常数1取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留<strong>最高阶项</strong>。</li><li>如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶</li></ol></blockquote><p>使用这种方法后，test1函数的时间复杂度为<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="6.606ex" height="2.565ex" role="img" focusable="false" viewBox="0 -883.9 2919.8 1133.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mn" transform="translate(975.3,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2530.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><br>对于test1函数，在计算的时候，我们省略了最后的+10，保留了最高阶数N^2^，即得出了它的时间复杂度</p><ul><li>如果最高阶数前面有系数，如2N，系数也将被省略</li></ul><p>因为当N的数值很大的时候，后面的那些值对我们总运行次数的影响已经非常小了。大O的渐进表示法<strong>去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数</strong></p><h2 id="2-2多种情况取最坏"><a href="#2-2多种情况取最坏" class="headerlink" title="2.2多种情况取最坏"></a>2.2多种情况取最坏</h2><p>一些算法的时间复杂度会有最好、最坏和平均的情况</p><ul><li>最好情况：任意输入规模的最小运行次数(下界)</li><li>平均情况：期望的运行次数</li><li>最坏情况：任意输入规模的最大运行次数(上界)</li></ul><p>举个例子，当我们编写一个在数组中查找数值的算法时，它可能会出现这几种情况：</p><ul><li>最好情况：1次就找到</li><li>平均情况：N/2次</li><li>最坏情况：N次</li></ul><p>在实际中的一般情况，我们关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为<code>O(N)</code></p><h2 id="2-3常见时间复杂度的计算"><a href="#2-3常见时间复杂度的计算" class="headerlink" title="2.3常见时间复杂度的计算"></a>2.3常见时间复杂度的计算</h2><h3 id="NO-1-双独立循环"><a href="#NO-1-双独立循环" class="headerlink" title="NO.1 双独立循环"></a>NO.1 双独立循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func1</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">{</span><br><span class="line">     <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * N ; ++ k)</span><br><span class="line">     {</span><br><span class="line">     	++count;</span><br><span class="line">     }</span><br><span class="line">     <span class="type">int</span> M = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">while</span> (M--)</span><br><span class="line">     {</span><br><span class="line">     	++count;</span><br><span class="line">     }</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里出现了两个循环，分别是2N次和10次。前面提到了大O渐进法只<strong>保留最高阶数并省略系数</strong>，所以它的时间复杂度是<code>O(N)</code></p><h3 id="NO-2-双独立循环"><a href="#NO-2-双独立循环" class="headerlink" title="NO.2 双独立循环"></a>NO.2 双独立循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func2</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M)</span></span><br><span class="line">{</span><br><span class="line">     <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; M; ++ k)</span><br><span class="line">     {</span><br><span class="line">     	++count;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; N ; ++ k)</span><br><span class="line">     {</span><br><span class="line">     	++count;</span><br><span class="line">     }</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里出现了次数为N和M的两层循环</p><ul><li>当M和N差不多大的时候，时间复杂度可以理解为<code>O(M)或O(N)</code></li><li>当M远远大于N时，时间复杂度为<code>O(M)</code></li><li>一般情况取O(M+N)</li></ul><hr><h3 id="NO-3-常数阶"><a href="#NO-3-常数阶" class="headerlink" title="NO.3 常数阶"></a>NO.3 常数阶</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func3</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">{</span><br><span class="line">     <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; ++ k)</span><br><span class="line">     {</span><br><span class="line">     	++count;</span><br><span class="line">     }</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里我们得知了具体的循环次数为100，是一常数，时间复杂度为<code>O(1)</code>，代表<strong>常数阶</strong></p><blockquote><p>只要循环次数已知，为一常数且和所传参数无关，其时间复杂度即为O(1)</p></blockquote><h3 id="NO-4-strchr"><a href="#NO-4-strchr" class="headerlink" title="NO.4 strchr"></a>NO.4 strchr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算strchr的时间复杂度</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="title function_">strchr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str, <span class="type">int</span> character )</span>;</span><br></pre></td></tr></table></figure><p>看到这道题的时候，你可能会一愣，strchr是什么？</p><blockquote><p>在之前的博客里，我介绍了很多常用的字符串函数👉<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/122691244?spm=1001.2014.3001.5502">点我<i class="fas fa-external-link-alt"></i></a></p><p>可这里面没有strchr，但有strstr</p></blockquote><p>strstr函数的作用：在字符串1中寻找是否有字符串2</p><p>其中第二个str代表的是<code>string字符串</code>，那我们是不是可以猜想，chr代表的是<code>char字符</code>，其作用是在一个字符串中查找是否有一个字符呢？</p><p>当然，光是猜想肯定是不够的，我们还需要求证一下</p><blockquote><p>如何查询库函数定义并尝试使用它？👉<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/119715769">点我<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>打开<a class="link" target="_blank" rel="noopener" href="https://cplusplus.com/reference/cstring/strchr/?kw=strchr">cplusplus网站<i class="fas fa-external-link-alt"></i></a>，搜索strchr，即可转到函数定义</p><p><img lazyload="" alt="image-20220313093417048" data-src="https://img.musnow.top/i/2023/02/image-20220313093417048.png"></p><p>可以看到，该函数的作用是<strong>定位字符串中第一次出现该字符的位置</strong>，返回值是一个<code>pointer指针</code></p><p>和我们猜想的一样，它的作用就是在字符串中查找一个字符，并返回它第一次出现的位置的地址。</p><p>这样一来，strchr函数的时间复杂度就很清楚了，就是遍历字符串所需要的次数，O(N)</p><h3 id="NO-5-冒泡排序"><a href="#NO-5-冒泡排序" class="headerlink" title="NO.5 冒泡排序"></a>NO.5 冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">     assert(a);</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">size_t</span> end = n; end &gt; <span class="number">0</span>; --end)</span><br><span class="line">     {</span><br><span class="line">         <span class="type">int</span> exchange = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">         {</span><br><span class="line">         	<span class="keyword">if</span> (a[i<span class="number">-1</span>] &gt; a[i])</span><br><span class="line">         	{</span><br><span class="line">                Swap(&amp;a[i<span class="number">-1</span>], &amp;a[i]);</span><br><span class="line">                exchange = <span class="number">1</span>;</span><br><span class="line">         	}</span><br><span class="line">    	 }</span><br><span class="line">     <span class="keyword">if</span> (exchange == <span class="number">0</span>)</span><br><span class="line">    	 <span class="keyword">break</span>;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/119911717?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164713562916780265463280%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164713562916780265463280&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-119911717.nonecase&utm_term=%E5%86%92%E6%B3%A1&spm=1018.2226.3001.4450">冒泡排序<i class="fas fa-external-link-alt"></i></a>是一个非常经典的代码，其思路就是遍历整个数组，如果待排序数字大于它的下一位，则交换这两个数字</p><ul><li>N个数字的数组需要N-1次排序才能完成</li><li>每一次排序都需要遍历一次数组</li></ul><p>这样算来，冒泡排序的循环次数就是两个N相乘，即为O(N^2)</p><hr><h3 id="能否通过循环层级判断？"><a href="#能否通过循环层级判断？" class="headerlink" title="能否通过循环层级判断？"></a>能否通过循环层级判断？</h3><p>细心的你可能会发现，上述代码中出现了两层循环，那是不是可以通过循环层级来判断时间复杂度呢？</p><p>并不能！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"hehe\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果是上述这种两次循环的情况，会打印3n次呵呵，其时间复杂度是<code>O(N)</code>而不是<code>N^2</code></p><ul><li>我们要准确分析算法的思路，并不能简单地通过循环层级来判断时间复杂度</li></ul><h3 id="NO-6-二分查找"><a href="#NO-6-二分查找" class="headerlink" title="NO.6 二分查找"></a>NO.6 二分查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a 数组，n长度，x需要查找的数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">     assert(a);</span><br><span class="line">     <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> end = n<span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">while</span> (begin &lt;= end)</span><br><span class="line">     {</span><br><span class="line">         <span class="type">int</span> mid = begin + ((end-begin)&gt;&gt;<span class="number">1</span>);<span class="comment">//使用位移操作符来模拟/2，防止begin和end相加后超出int范围</span></span><br><span class="line">         <span class="keyword">if</span> (a[mid] &lt; x)</span><br><span class="line">         	begin = mid+<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)</span><br><span class="line">         	end = mid<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         	<span class="keyword">return</span> mid;<span class="comment">//返回需要查找的数的下标</span></span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>二分查找的思路这里不再赘述</p><p>假设我们找了x次，每一次查找都会使查找范围减半</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N/2/2/2/2 ……</span><br></pre></td></tr></table></figure><p>最后我们可以得出2条公式<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="7.26ex" height="1.827ex" role="img" focusable="false" viewBox="0 -725.5 3209 807.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g><g data-mml-node="mo" transform="translate(1265.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2321,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g></svg></mjx-container></p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align:-.464ex" xmlns="http://www.w3.org/2000/svg" width="10.159ex" height="2.034ex" role="img" focusable="false" viewBox="0 -694 4490.1 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(1905.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(2203.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="msub" transform="translate(2688.6,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mi" transform="translate(3602.1,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g></svg></mjx-container></p><ul><li>最好情况：O(1)</li><li>最坏情况：O(logN)</li></ul><p><img lazyload="" alt="IMG_20220313_095703" data-src="https://img.musnow.top/i/2023/02/63f1db21a32b0.png"></p><p>通过时间复杂度的对比，我们就能看出二分查找的优势在那里了</p><table><thead><tr><th align="center">N</th><th align="center">O(N)</th><th align="center">O(logN)</th></tr></thead><tbody><tr><td align="center">1000</td><td align="center">1000</td><td align="center">10</td></tr><tr><td align="center">100w</td><td align="center">100w</td><td align="center">20</td></tr><tr><td align="center">10亿</td><td align="center">10亿</td><td align="center">30</td></tr></tbody></table><p>可以看到，当数据很大的时候，O(logN)的算法执行次数比O(N)少了特别多!!（来自BT-7274的肯定）</p><p><img lazyload="" alt="img" data-src="https://img.musnow.top/i/2023/02/63f1db618c477.png"></p><h3 id="NO-7-计算N"><a href="#NO-7-计算N" class="headerlink" title="NO.7 计算N!"></a>NO.7 计算N!</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算阶乘递归Fac的时间复杂度？</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Fac</span><span class="params">(<span class="type">size_t</span> N)</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0</span> == N)</span><br><span class="line">     	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> Fac(N<span class="number">-1</span>)*N;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>对于这个阶乘的递归函数而言，每次函数调用是<code>O(1)</code>，时间复杂度主要看递归次数</p><p>对于数字N而言，递归需要N次，时间复杂度是<code>O(N)</code></p><h3 id="递归算法时间复杂度计算"><a href="#递归算法时间复杂度计算" class="headerlink" title="递归算法时间复杂度计算"></a>递归算法时间复杂度计算</h3><ul><li>如果每次函数调用是O(1)，看递归次数</li><li>每次函数调用不是O(1)，那么就看他递归调用中次数的累加</li></ul><h3 id="NO-8-斐波那契数列"><a href="#NO-8-斐波那契数列" class="headerlink" title="NO.8 斐波那契数列"></a>NO.8 斐波那契数列</h3><blockquote><p>计算斐波那契数可以用递归和迭代两种算法👉<a href="">点我</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算斐波那契递归Fib的时间复杂度？</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Fib</span><span class="params">(<span class="type">size_t</span> N)</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(N &lt; <span class="number">3</span>)</span><br><span class="line">     	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> Fib(N<span class="number">-1</span>) + Fib(N<span class="number">-2</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img lazyload="" alt="image" data-src="https://img.musnow.top/i/2023/02/63f1daa652e24.jpg"></p><p>每次递归，次数都会增加，总的来说是以2^x的量级增加的（x代表行数）<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="28.76ex" height="2.213ex" role="img" focusable="false" viewBox="0 -896 12712 978"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1722.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2444.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3444.9,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(4167.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(5167.3,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="mo" transform="translate(5889.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(6889.8,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(8228.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(9622.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msup" transform="translate(10622.9,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(852,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1630,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></g></svg></mjx-container><br>这里一共有x-1项，用<strong>等比数列的求和公式</strong>得出，结果为2<sup>x-1</sup></p><p>所以最后得出的时间复杂度为O(2<sup>N</sup>)</p><blockquote><p>需要注意的是，当递归调用到底部时，有一些调用会较早退出，这部分位于金字塔的右下角</p><p><img lazyload="" alt="IMG_20220313_103131" data-src="https://img.musnow.top/i/2023/02/63f1db730013b.png"></p><p>由于时间复杂度只是一个估算值，这一部分缺失的调用次数对总运行次数的影响不大，故忽略掉</p></blockquote><h3 id="NO-9-非-1递增循环"><a href="#NO-9-非-1递增循环" class="headerlink" title="NO.9 非+1递增循环"></a>NO.9 非+1递增循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">{</span><br><span class="line">   <span class="type">int</span> i=l;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">      i=i*<span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>此函数有一个循环，但是循环没有被执行n次，i每次都是2倍进行递增，所以循环只会被执行log<sub>2</sub>n次</p><h3 id="NO-10-有序数组中查找和为sum的两个数"><a href="#NO-10-有序数组中查找和为sum的两个数" class="headerlink" title="NO.10 有序数组中查找和为sum的两个数"></a>NO.10 有序数组中查找和为sum的两个数</h3><p>给定一个整数sum，从有<strong>N个有序元素</strong>的数组中寻找元素a，b，使得a+b的结果最接近sum，<strong>最快</strong>的平均时间复杂度是？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. O(n)<span class="comment">//√</span></span><br><span class="line">B. O(n^<span class="number">2</span>)</span><br><span class="line">C. O(nlogn)</span><br><span class="line">D. O(logn)</span><br></pre></td></tr></table></figure><p>数组元素有序，所以a,b两个数可以分别从<strong>开始和结尾处</strong>开始搜，根据首尾元素的和是否大于sum,决定搜索的移动，整个数组被搜索一遍，就可以得到结果，所以最好时间复杂度为n</p><h3 id="NO-11-双嵌套循环"><a href="#NO-11-双嵌套循环" class="headerlink" title="NO.11 双嵌套循环"></a>NO.11 双嵌套循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {<span class="comment">//循环1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//循环2</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上是一个很常用的循环。其中循环2的执行次数是一个等差数列，第一次是n，第二次是n-1，第三次是n-2……一直到最后一次为1；<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="30.232ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 13362.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(1822.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2211.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3033.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4033.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4533.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5145.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(6145.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(6534.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(7356.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8356.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(8856.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(9468,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(10468.2,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(11862.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(12862.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container><br>这个等差数列的求和为<code>n(n+1)/2</code>，即n<sup>2</sup>/2+n/2，因为时间复杂度需要<strong>取大且忽略系数</strong>，所以最终的时间复杂度为n<sup>2</sup></p><hr><h1 id="3-空间复杂度🏠"><a href="#3-空间复杂度🏠" class="headerlink" title="3.空间复杂度🏠"></a>3.空间复杂度🏠</h1><h2 id="3-1概念"><a href="#3-1概念" class="headerlink" title="3.1概念"></a>3.1概念</h2><p>空间复杂度是对一个算法在运行过程中临时占用空间大小的度量</p><blockquote><p>和时间复杂度不是真的计算时间一样，空间复杂度也不衡量算法具体占用的内存字节数。</p></blockquote><p>空间复杂度计算的是额外开辟的变量的个数，适用<strong>大O渐近法</strong></p><p>注意：函数运行时所需要的<strong>栈空间</strong>(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。</p><h2 id="3-2空间复杂度计算"><a href="#3-2空间复杂度计算" class="headerlink" title="3.2空间复杂度计算"></a>3.2空间复杂度计算</h2><h3 id="NO-1-冒泡排序"><a href="#NO-1-冒泡排序" class="headerlink" title="NO.1 冒泡排序"></a>NO.1 冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">     assert(a);</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">size_t</span> end = n; end &gt; <span class="number">0</span>; --end)</span><br><span class="line">     {</span><br><span class="line">         <span class="type">int</span> exchange = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">         {</span><br><span class="line">         	<span class="keyword">if</span> (a[i<span class="number">-1</span>] &gt; a[i])</span><br><span class="line">         	{</span><br><span class="line">                Swap(&amp;a[i<span class="number">-1</span>], &amp;a[i]);</span><br><span class="line">                exchange = <span class="number">1</span>;</span><br><span class="line">         	}</span><br><span class="line">    	 }</span><br><span class="line">     <span class="keyword">if</span> (exchange == <span class="number">0</span>)</span><br><span class="line">    	 <span class="keyword">break</span>;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我们会发现，冒泡排序算法并没有额外定义非常多的变量，一共只有3个，属于<strong>常数阶</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> end = n;</span><br><span class="line"><span class="type">int</span> exchange = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其空间复杂度为<code>O(1)</code></p><h3 id="计算时注意其与N的关系"><a href="#计算时注意其与N的关系" class="headerlink" title="计算时注意其与N的关系"></a>计算时注意其与N的关系</h3><p>当我们在算法中开辟空间，计算空间复杂度的时候，要注意开辟的这个空间与N有没有关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[N];<span class="comment">//c99变长数组，和传过来的参数有关</span></span><br><span class="line"><span class="type">int</span>* a=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*N);<span class="comment">//和传过来的参数有关，O(N)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* a=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">3</span>);<span class="comment">//和传过来的参数无关，O(1)</span></span><br></pre></td></tr></table></figure><h3 id="NO-2-斐波那契数列"><a href="#NO-2-斐波那契数列" class="headerlink" title="NO.2 斐波那契数列"></a>NO.2 斐波那契数列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算Fibonacci的空间复杂度？</span></span><br><span class="line"><span class="comment">// 返回斐波那契数列的前n项</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>* <span class="title function_">Fibonacci</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> * fibArray = (<span class="type">long</span> <span class="type">long</span> *)<span class="built_in">malloc</span>((n+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));</span><br><span class="line">     fibArray[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">     fibArray[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n ; ++i)</span><br><span class="line">     {</span><br><span class="line">     	fibArray[i] = fibArray[i - <span class="number">1</span>] + fibArray [i - <span class="number">2</span>];</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> fibArray;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>和上面的斐波那契数列的递归代码不同，这里我们新创建了一个数组，用来保存计算出来的斐波那契数</p><p>一共<code>malloc</code>了n+1个长整型的空间，空间复杂度是O(N)</p><hr><h3 id="空间重复使用问题"><a href="#空间重复使用问题" class="headerlink" title="空间重复使用问题"></a>空间重复使用问题</h3><p>如果是递归方法的斐波那契算法，其空间复杂度是多少呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Fib</span><span class="params">(<span class="type">size_t</span> N)</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(N &lt; <span class="number">3</span>)</span><br><span class="line">     	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> Fib(N<span class="number">-1</span>) + Fib(N<span class="number">-2</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>答案也是<code>O(N)</code></p><p>因为对于递归算法而言，其开辟的函数栈帧空间是可以重复利用的！</p><p>如fib(8)的调用，其开辟的函数栈帧，是可以在后续继续调用fib函数时重复使用的</p><blockquote><p>通过函数的参数压栈，我们可以很好地理解这是为啥👉<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123288455?spm=1001.2014.3001.5502">点我<i class="fas fa-external-link-alt"></i></a></p></blockquote><p><img lazyload="" alt="image-20220313113408340" data-src="https://img.musnow.top/i/2023/02/image-20220313113408340.png"></p><p>上图中f1和f2是两个函数，但执行了相同的功能。其函数调用的空间实际上是一个，f2在f1销毁后继承了它的空间</p><blockquote><p>这就好比每一次新的递归都会开一家新的饭店，但是你下次还想吃东北菜的时候，可以去之前开的东北菜馆，咱没必要让别人再开一家馆子不是嘛？</p></blockquote><p>不过由于斐波那契数的递归算法会<strong>递归非常多次</strong>，在数字很大的时候，会导致<strong>栈溢出</strong></p><p><img lazyload="" alt="image-20220313113142120" data-src="https://img.musnow.top/i/2023/02/image-20220313113142120.png"></p><hr><h3 id="NO-3-阶乘"><a href="#NO-3-阶乘" class="headerlink" title="NO.3 阶乘"></a>NO.3 阶乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Fac</span><span class="params">(<span class="type">size_t</span> N)</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">     	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> Fac(N<span class="number">-1</span>)*N;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>虽然函数本身的空间不计入时间复杂度，<strong>这里计算的是递归调用时额外开辟的函数栈帧空间</strong></p><p>一共调用了N-1次，每个栈帧使用了常数个空间，空间复杂度是O(N)</p><h1 id="4-常见复杂度对比👐"><a href="#4-常见复杂度对比👐" class="headerlink" title="4.常见复杂度对比👐"></a>4.常见复杂度对比👐</h1><p><img lazyload="" alt="image-20220313113721007" data-src="https://img.musnow.top/i/2023/02/image-20220313113721007.png"></p><p><img lazyload="" alt="image-20220313113801204" data-src="https://img.musnow.top/i/2023/02/image-20220313113801204.png"></p><hr><h1 id="结语😘"><a href="#结语😘" class="headerlink" title="结语😘"></a>结语😘</h1><p>时间复杂度和空间复杂度可以帮我们很好的了解自己所写算法的好坏，在未来面试的时候，HR肯定也更喜欢效率高的算法</p><p>要多刷题，好好积累自己的能力，想必之后写出好算法也是水到渠成（吧？）</p><blockquote><p>如果这篇博客对你有帮助，点个赞再走呗~</p></blockquote></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【算法】算法的空间复杂度和时间复杂度</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">慕雪年华</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2022-03-13 11:57:34</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">posts/3906762122/</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/C%E8%AF%AD%E8%A8%80/">#C语言</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>&nbsp;</li><li class="tag-item"><a href="/tags/OJ%E5%88%B7%E9%A2%98/">#OJ刷题</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/posts/2445477159/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">【leetcode】189. 轮转数组（C语言）</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/posts/3252921223/"><span class="title flex-center"><span class="post-nav-title-item">【树莓派开发】出现报错pragama once in main file</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80%F0%9F%95%B5%EF%B8%8F%E2%80%8D%E2%99%82%EF%B8%8F"><span class="nav-text">前言🕵️‍♂️</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%F0%9F%A7%90"><span class="nav-text">1.算法效率🧐</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95"><span class="nav-text">1.1什么是算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%EF%BC%9F"><span class="nav-text">1.2如何衡量？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E2%8F%B0"><span class="nav-text">2.时间复杂度⏰</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">2.1大O的渐进表示法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E5%A4%9A%E7%A7%8D%E6%83%85%E5%86%B5%E5%8F%96%E6%9C%80%E5%9D%8F"><span class="nav-text">2.2多种情况取最坏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-text">2.3常见时间复杂度的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-1-%E5%8F%8C%E7%8B%AC%E7%AB%8B%E5%BE%AA%E7%8E%AF"><span class="nav-text">NO.1 双独立循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-2-%E5%8F%8C%E7%8B%AC%E7%AB%8B%E5%BE%AA%E7%8E%AF"><span class="nav-text">NO.2 双独立循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-3-%E5%B8%B8%E6%95%B0%E9%98%B6"><span class="nav-text">NO.3 常数阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-4-strchr"><span class="nav-text">NO.4 strchr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-5-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">NO.5 冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%BD%E5%90%A6%E9%80%9A%E8%BF%87%E5%BE%AA%E7%8E%AF%E5%B1%82%E7%BA%A7%E5%88%A4%E6%96%AD%EF%BC%9F"><span class="nav-text">能否通过循环层级判断？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-6-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">NO.6 二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-7-%E8%AE%A1%E7%AE%97N"><span class="nav-text">NO.7 计算N!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="nav-text">递归算法时间复杂度计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-8-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text">NO.8 斐波那契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-9-%E9%9D%9E-1%E9%80%92%E5%A2%9E%E5%BE%AA%E7%8E%AF"><span class="nav-text">NO.9 非+1递增循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-10-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%92%8C%E4%B8%BAsum%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0"><span class="nav-text">NO.10 有序数组中查找和为sum的两个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-11-%E5%8F%8C%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="nav-text">NO.11 双嵌套循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%F0%9F%8F%A0"><span class="nav-text">3.空间复杂度🏠</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="nav-text">3.2空间复杂度计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">NO.1 冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%97%B6%E6%B3%A8%E6%84%8F%E5%85%B6%E4%B8%8EN%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">计算时注意其与N的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-2-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text">NO.2 斐波那契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-text">空间重复使用问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NO-3-%E9%98%B6%E4%B9%98"><span class="nav-text">NO.3 阶乘</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94%F0%9F%91%90"><span class="nav-text">4.常见复杂度对比👐</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD%F0%9F%98%98"><span class="nav-text">结语😘</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/about">慕雪年华</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="timerun-info info-item"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/16/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已勉强运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="shields-info info-item"><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_3_tp.gif" height="20px"> </a><a href="https://github.com/XPoet/hexo-theme-keep" target="_blank"><img src="https://img.shields.io/badge/hexo-keep-blue" height="20px"> </a><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"> </a><a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%87-2023007189%E5%8F%B7-red" height="20px"> </a><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/images/upyun_cdn.png" height="20px"></a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/local-search.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/code-block.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/toc.js"></script></div><script src="//unpkg.com/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });</script><script type="text/javascript" src="/js/snow.js"></script></body></html>