<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Linux】高级IO和多路转接 | select/poll/epoll | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多路转接和高级IO"><meta property="og:type" content="article"><meta property="og:title" content="【Linux】高级IO和多路转接 | select&#x2F;poll&#x2F;epoll"><meta property="og:url" content="https://blog.musnow.top/posts/3390191280/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="多路转接和高级IO"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.musnow.top/i/2023/08/748d3a20ba69bb3b3671f5b344cba650.png"><meta property="article:published_time" content="2023-08-25T00:22:36.000Z"><meta property="article:modified_time" content="2023-08-25T04:05:36.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Linux"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.musnow.top/i/2023/08/748d3a20ba69bb3b3671f5b344cba650.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/3390191280/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Linux】高级IO和多路转接 | select/poll/epoll",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-08-25 12:05:36"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">293</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://img.musnow.top/i/2023/08/748d3a20ba69bb3b3671f5b344cba650.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Linux】高级IO和多路转接 | select/poll/epoll</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-25T00:22:36.000Z" title="发表于 2023-08-25 08:22:36">2023-08-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-25T04:05:36.000Z" title="更新于 2023-08-25 12:05:36">2023-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%8E%A9%E4%B8%8ALinux/">玩上Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【Linux】高级IO和多路转接 | select/poll/epoll"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>多路转接和高级IO</p><span id="more"></span><p>咳咳，写的时候出了点问题，标点符号全乱了（批量替换了几次），干脆就把全文的逗号和句号都改成英文的了（不然代码块里面的代码都是中文标点就跑不动了）</p><blockquote><p>IO多路复用和本文提到的多路转接是一个东西！</p></blockquote><h1 id="1-高级IO"><a href="#1-高级IO" class="headerlink" title="1.高级IO"></a>1.高级IO</h1><h2 id="1-1-五种IO模型"><a href="#1-1-五种IO模型" class="headerlink" title="1.1 五种IO模型"></a>1.1 五种IO模型</h2><p>用钓鱼佬的栗子, 来看看五种不同的IO模型吧</p><ul><li>A, 拿着鱼竿去钓鱼, 一直盯着鱼漂, 鱼漂有动静就收钩</li><li>B, 拿着鱼竿去钓鱼, 时不时看看鱼漂, 有动静就收购</li><li>C, 拿着鱼竿去钓鱼, 在鱼漂上弄个铃铛, 然后干其他的事情, 听到铃铛的声音就收钩</li><li>D, 拿了一大堆鱼竿过来, 都摆弄好, 只要有一个鱼漂有动静, 就收钩</li><li>E是大老板, 直接叫人帮忙钓鱼, 钓到一定数量的🐟后通知自己, 自己过来取🐟（没有参与钓鱼过程）</li></ul><p>这五种钓鱼方式, 就对应了五种IO模型</p><ul><li>A, <strong>阻塞等待</strong>, 等待到数据就立即读取</li><li>B, <strong>轮询检测</strong>, 检测到数据的时候读取</li><li>C, 利用铃铛来作为通知方式, 听到了信号之后, 就去读取数据（<strong>信号驱动</strong>）</li><li>D, 一次性检测多个文件描述符（<strong>多路转接</strong>）</li><li>E, 没有自己参与钓鱼过程, 有别人帮忙监控文件描述符, 自己只关心拿走数据（<strong>异步IO</strong>）</li></ul><p>在这五种IO模式中, <strong>D的效率是最高的</strong>。因为它一次性监控了多个文件描述符, 这些文件描述符的IO在一定程度上重合了, 更容易等到数据。</p><p>要知道, D是过来钓鱼的, 他只要能钓到鱼就够了, 并不用关心到底是哪个鱼钩钓上来的鱼。同理, 我们的IO服务器也并不需要关心到底是哪个文件描述符在给自己传递信息, 我们只要每时每刻都在处理信息（都能钓到鱼）才是最高效率的体现。</p><p>换句话说, 在钓鱼（处理IO）的时候, 等的时间比例越低, 效率越高！</p><h2 id="1-2-阻塞和非阻塞"><a href="#1-2-阻塞和非阻塞" class="headerlink" title="1.2 阻塞和非阻塞"></a>1.2 阻塞和非阻塞</h2><p>这两个概念我们在先前对IO的学习中已经见过了</p><ul><li>阻塞：进程会在函数调用中卡住, 在没有成功调用之前不会继续向后运行</li><li>非阻塞：不管能否获取到数据, 函数都是直接返回结果;</li></ul><h2 id="1-3-异步与同步通信"><a href="#1-3-异步与同步通信" class="headerlink" title="1.3 异步与同步通信"></a>1.3 异步与同步通信</h2><ul><li>异步通信：在调用发出后, 这个调用直接返回, 并没有携带结果;类似<code>std::async/future</code>, 在调用发出后, 被调用着通过状态或通知来告知调用者, 亦或者是用回调函数来处理这个异步调用</li><li>同步通信：在发出调用后, 没有得到结果前, 该调用不返回;一旦返回就表明该调用成功获取到了返回值（调用者主动等待调用结果）</li></ul><p>这里的同步和线程&#x2F;进程同步并不是一个概念：</p><ul><li>线程和进程的同步指的是线程和进程之间有相互制约的关系, 需要在某些情况中协调他们的工作次序而进行等待</li></ul><hr><p>了解完IO模型和上方的知识后, 下面就让我们来认识一下第一个接口吧！</p><h1 id="2-fcntl"><a href="#2-fcntl" class="headerlink" title="2.fcntl"></a>2.fcntl</h1><p>这个是一个系统调用, 可以给文件描述符进行不同的策略设置。</p><p>当我们在linux中创建一个文件描述符的时候, 默认创建的都是阻塞的文件描述符。我们可以使用<code>fcntl</code>来将文件描述符设置成<strong>非阻塞</strong>的。</p><h2 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h2><p>该函数的原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><p>其中cmd是我们需要执行的策略, 下面是常见的几种选项</p><ul><li>复制一个现有的描述符（cmd&#x3D;F_DUPFD）</li><li>获得&#x2F;设置文件描述符标记(cmd&#x3D;F_GETFD或F_SETFD)</li><li>获得&#x2F;设置文件状态标记(cmd&#x3D;F_GETFL或F_SETFL)</li><li>获得&#x2F;设置异步I&#x2F;O所有权(cmd&#x3D;F_GETOWN或F_SETOWN)</li><li>获得&#x2F;设置记录锁(cmd&#x3D;F_GETLK, F_SETLK或F_SETLKW)</li></ul><p>这里我们使用的是第三个功能, 来获取和设置文件的状态标记, 就可以将文件描述符设置为非阻塞（这里要注意, 不是用第二种）</p><h2 id="2-2-设置非阻塞"><a href="#2-2-设置非阻塞" class="headerlink" title="2.2 设置非阻塞"></a>2.2 设置非阻塞</h2><p>我们需要先将文件描述符原本的属性给取出来, 然后再加上非阻塞的状态, 使用<code>fcntl</code>设置属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetNoBlock</span><span class="params">(<span class="type">int</span> fd)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> fl = fcntl(fd, F_GETFL);  <span class="comment">// 先获取文件已有状态</span></span><br><span class="line">    <span class="keyword">if</span> (fl &lt; <span class="number">0</span>) &#123; </span><br><span class="line">       perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在已有状态的基础上, 设置O_NONBLOCK非阻塞</span></span><br><span class="line">    fcntl(fd, F_SETFL, fl | O_NONBLOCK);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-stdin测试"><a href="#2-3-stdin测试" class="headerlink" title="2.3 stdin测试"></a>2.3 stdin测试</h2><p>然后, 我们还需要一个会出现阻塞的文件描述符来作为测试。但是, 如果是直接打开一个本地文件, 并不会出现阻塞态（因为文件流会被一次性读取出来）</p><p>不过, 在我们最常用的3个默认文件描述符中, 就有一个是能够实现进程阻塞的, 它就是<code>stdin</code>, 因为在控制台里面等待用户输入的时候, 进程就是处于阻塞状态的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">请输入：</span><br></pre></td></tr></table></figure><p>所以我们就可以尝试将stdin设置为非阻塞, 来观察一下结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SetNoBlock</span>(stdin-&gt;_fileno);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> read_size = <span class="built_in">read</span>(stdin-&gt;_fileno, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(read_size &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read err&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input:%s\n&quot;</span>, buf);</span><br><span class="line">        buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行, 当没有读取到输入内容的时候, 并不会在<code>stdin</code>中阻塞, 而是会通过perror打印出资源暂时不可用的警告信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">asdlfjklaf</span><br><span class="line">input:asdlfjklaf</span><br><span class="line"></span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">adslfkjaldfjklasjfa</span><br><span class="line">input:adslfkjaldfjklasjfa</span><br><span class="line">a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">ewqrqreqqrwer</span><br><span class="line">input:ewqrqreqqrwer</span><br><span class="line">asjfa</span><br><span class="line">a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">qweioruqoruioqewur</span><br><span class="line">input:qweioruqoruioqewur</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">weqioruqoieuotqitqwertq</span><br><span class="line">input:weqioruqoieuotqitqwertq</span><br><span class="line">����a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><h1 id="3-多路转接之select"><a href="#3-多路转接之select" class="headerlink" title="3.多路转接之select"></a>3.多路转接之select</h1><p>接下来就要进入我们的正题了, 关于<strong>多路转接</strong>的知识。</p><p>在之前的时候, 我们如果想在一个进程里面维护多个tcp链接, 就需要用到子线程或者子进程来单独为每一个用户提供服务。<strong>但一个进程可以开的线程是有数量限制的</strong>, 在32位系统中, 这个数字大概是2000。</p><p>对于一个高并发的服务器来说, 这点线程数是完全不够用的！如果你的网站一次性有2000个人访问, 你的服务器就会因为开不出更多的线程而无法为更多的用户提供服务！</p><p>所以, <strong>多路转接</strong>就出现了, 他能帮我们实现单个进程监控多个文件描述符, 同时为多个socket链接提供服务的操作！</p><blockquote><p>普通的本地文件描述符也是可以托管给多路转接的！</p></blockquote><h2 id="3-1-认识select"><a href="#3-1-认识select" class="headerlink" title="3.1 认识select"></a>3.1 认识select</h2><p>select的函数原型和我们之前接触过的linux系统调用接口都不大相似, 它的所有参数都是输入输出型参数, 而且还用到了一个我们平时较少接触的数据结构——位图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* According to POSIX.1-2001, POSIX.1-2008 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, </span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>先来依次说明一下每一个参数的作用吧</p><ul><li><code>nfds</code>：需要select帮我们监视的<code>最大文件描述符+1</code></li><li><code>readfds/writefds/exceptfds</code>, 需要select帮我们检测的读&#x2F;写&#x2F;异常文件描述符（通过<strong>位图</strong>来设定）</li><li><code>timeout</code>：阻塞监控的时长, 用来设置select单次阻塞等待的时间</li></ul><h3 id="3-1-1-timeval"><a href="#3-1-1-timeval" class="headerlink" title="3.1.1 timeval"></a>3.1.1 timeval</h3><p>首先来看看timeout的这个参数的<code>struct timeval</code>结构体框架, 内部包含两个成员变量, 一个表示秒数, 一个表示微秒数。最终select等待的时间是这两个参数的<strong>和</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果设置成0, 则仅检测文件描述符的状态, 不管什么情况都会立即返回（完全非阻塞）</li><li>如果设置成指定的时间, 则会阻塞等待这端时间, 如果有文件事件则返回;如果没有等到文件时间, 那么时间到了就会返回</li><li>如果将<code>timeout</code>参数设置成<code>nullptr</code>, 则会<strong>阻塞等待</strong></li></ul><p>这个参数也是一个输入输出型参数, 返回值为剩余的秒数（如果等待成功的话）</p><h3 id="3-1-2-fd-set"><a href="#3-1-2-fd-set" class="headerlink" title="3.1.2 fd_set"></a>3.1.2 fd_set</h3><p>函数中有3个参数都是用到了这个<code>fd_set</code>结构, 它是一个位图结构, 同时也是一个输入输出参数</p><ul><li>输入：用户告诉操作系统, 需要帮我监控那几个文件描述符, 在需要监控的文件描述符上置1</li><li>输出：系统告诉用户, 那些文件描述符的相关事件就绪了</li></ul><p>虽然这是一个位图结构, 但其并不需要我们手动去设置, 操作系统顺便帮我们封装了相关的设置“函数”, 只需要传入fd和该结构体即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 清空位图中对该文件描述符的设置</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;<span class="comment">// 判断是否被设置了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 设置对应位置的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;         <span class="comment">// 清空整个位图</span></span><br></pre></td></tr></table></figure><p>你可能回觉得奇怪, 为什么这些“函数”是大写的呢？Linux中大写的应该是宏才对吧？</p><p>答对了！这里的设置函数其实都是宏定义！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Access macros for `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	FD_SET(fd, fdsetp)	__FD_SET (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	FD_CLR(fd, fdsetp)	__FD_CLR (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	FD_ISSET(fd, fdsetp)	__FD_ISSET (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	FD_ZERO(fdsetp)		__FD_ZERO (fdsetp)</span></span><br></pre></td></tr></table></figure><p>既然是一个预定义好的位图, 那么它的长度就会收到操作系统底层的一定限制, 以下为源代码中<code>fd_set</code>结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径 usr/include/sys/select.h</span></span><br><span class="line"><span class="comment">/* The fd_set member is required to be an array of longs.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> __fd_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Some versions of &lt;linux/posix_types.h&gt; define this macros.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>	__NFDBITS</span></span><br><span class="line"><span class="comment">/* It&#x27;s easier to assume 8-bit bytes than to get CHAR_BIT.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NFDBITS	(8 * (int) sizeof (__fd_mask))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	__FD_ELT(d)	((d) / __NFDBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	__FD_MASK(d)	((__fd_mask) (1UL &lt;&lt; ((d) % __NFDBITS)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fd_set for select and pselect.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure><p>在另外一个头文件中, 可以找到<code>__FD_SETSIZE</code>这个宏的定义, 是1024;也就是说, <code>fd_set</code>这个位图最大的长度只有1024个比特位, 我们也只能监看这么多文件描述符！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径 usr/include/bits/typesizes.h</span></span><br><span class="line"><span class="comment">/* Number of descriptors that can fit in an `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FD_SETSIZE		1024</span></span><br></pre></td></tr></table></figure><p>这也是<code>select</code>的缺点之一, 同时监看的文件描述符数量是<strong>有限制</strong>的！</p><h3 id="3-1-3-nfds"><a href="#3-1-3-nfds" class="headerlink" title="3.1.3 nfds"></a>3.1.3 nfds</h3><p>这个参数是select需要帮我们监看的最大文件描述符+1, 这是因为select在监看的过程中需要用循环来进行检测, 这个最大文件描述符+1相当于是一个循环的边界条件;</p><p>你只需根据当前已有的文件描述符号, 计算出最大文件描述符, 再加一传给这个函数即可。</p><h3 id="3-1-4-返回值"><a href="#3-1-4-返回值" class="headerlink" title="3.1.4 返回值"></a>3.1.4 返回值</h3><p>man手册中对返回值的描述如下</p><ul><li>成功的时候, 返回事件就绪的文件描述符数量</li><li>失败的时候返回<code>-1</code>, 并设置errno</li><li>如果已经<code>timeout</code>了还没有事件就绪, 返回0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor  sets  (that  is,  the total  number  of  bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens.  On error, -1 is returned, and errno is set to indicate the error; the file descriptor sets are unmodified, and  timeout becomes undefined.</span><br></pre></td></tr></table></figure><h2 id="3-2-实例"><a href="#3-2-实例" class="headerlink" title="3.2 实例"></a>3.2 实例</h2><p>函数原型看完了, 得从实例出发来试试了</p><h3 id="3-2-1-socket"><a href="#3-2-1-socket" class="headerlink" title="3.2.1 socket"></a>3.2.1 socket</h3><p>这里先对<span id="jump-select">socket</span>做了一个简单的封装, 包括初始化, 绑定相关的接口, 只需要在另外一个文件里面调用这个头文件即可 !</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sock.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> gbacklog = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">SocketInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> listenSock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (listenSock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置端口复用, 避免timewait阻塞端口</span></span><br><span class="line">        <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">setsockopt</span>(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line">        <span class="keyword">return</span> listenSock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> socket, <span class="type">uint16_t</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local; <span class="comment">// 用户栈</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;local, <span class="number">0</span>, <span class="keyword">sizeof</span> local);</span><br><span class="line">        local.sin_family = PF_INET;</span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">        local.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 本地socket信息, 写入sock_对应的内核区域</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(socket, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> socket)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">listen</span>(socket, gbacklog) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Accept</span><span class="params">(<span class="type">int</span> socket, std::string *clientip, <span class="type">uint16_t</span> *clientport)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> serviceSock = <span class="built_in">accept</span>(socket, (<span class="keyword">struct</span> sockaddr *)&amp;peer, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (serviceSock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取链接失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(clientport) *clientport = <span class="built_in">ntohs</span>(peer.sin_port);</span><br><span class="line">        <span class="keyword">if</span>(clientip) *clientip = <span class="built_in">inet_ntoa</span>(peer.sin_addr);</span><br><span class="line">        <span class="keyword">return</span> serviceSock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外重点说明一下这两行, 在之前学习tcp服务器的时候就提到过, 这里的<code>SO_REUSEADDR</code>是让端口可以被复用, 不会因为存在<code>TIME_WAIT</code>的链接而无法绑定端口。适用于服务器快速重启的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置端口复用, 避免timewait阻塞端口</span></span><br><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><h3 id="3-2-2-初始化"><a href="#3-2-2-初始化" class="headerlink" title="3.2.2 初始化"></a>3.2.2 初始化</h3><p>还是老一套, 通过命令行参数获取到端口号, 创建socket_fd并绑定端口和开始<code>listen</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">cmd_usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 初始化socket, 获取socket fd并绑定端口</span></span><br><span class="line">    <span class="type">int</span> listensock = Sock::<span class="built_in">SocketInit</span>();</span><br><span class="line">    Sock::<span class="built_in">Bind</span>(listensock, <span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    Sock::<span class="built_in">Listen</span>(listensock); <span class="comment">// 开始监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是, 在select中的文件描述符都只剩位图了, 所以我们必须要有一个单独的文件描述符数组来协助我们管理正在维护的文件描述符。</p><p>这里为了方便, 我设立了一个全局的数组变量, 长度为<code>sizeof(fd_set) * 8</code>, 是<code>fd_set</code>这个位图结构体能够支持的最大socket数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fdsArray[<span class="built_in">sizeof</span>(fd_set) * <span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 保存历史上所有的合法fd</span></span><br><span class="line"><span class="type">int</span> fdsArraySz = <span class="built_in">sizeof</span>(fdsArray) / <span class="built_in">sizeof</span>(fdsArray[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFL_FD -1 <span class="comment">// 数组中默认值</span></span></span><br></pre></td></tr></table></figure><p>在main函数中, 我们需要通过遍历来将这个数组设置为默认的文件描述符<code>-1</code>来表明当前位置没有被使用, 并将0下标处设置为<code>listensock</code>;如果你使用的是vector, 则可以直接用构造函数来初始化;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组里面的文件描述符都初始化为默认值, 并将第一个下标设置为listensocket</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fdsArraySz; i++)&#123;</span><br><span class="line">    fdsArray[i] = DFL_FD;</span><br><span class="line">&#125;</span><br><span class="line">fdsArray[<span class="number">0</span>] = listensock;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-监听"><a href="#3-2-3-监听" class="headerlink" title="3.2.3 监听"></a>3.2.3 监听</h3><p>初始化完毕数组后, 就可以开始循环调用<code>select</code>来进行监听了。</p><p>需要注意的是, 因为<code>select</code>的<code>fd_set</code>是一个位图, 而且是输入输出参数。每次的<code>select</code>调用之后, 这些位图就会被操作系统修改为已经就绪的文件描述符（即参数本身会被修改）所以我们下一次调用之前, <strong>需要重新设置位图参数</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line">fd_set readfds;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxFd = DFL_FD;</span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;readfds); <span class="comment">// 清空位图</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;; <span class="comment">// 设置超时时间为5秒</span></span><br><span class="line">    <span class="comment">// 遍历全局数组, 将有效的fd都添加进去, 并更新maxfd</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fdsArraySz; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 1. 过滤不合法的fd</span></span><br><span class="line">        <span class="keyword">if</span> (fdsArray[i] == DFL_FD) <span class="keyword">continue</span>;   </span><br><span class="line">        <span class="comment">// 2. 添加所有的合法的fd到readfds中, 方便select统一进行就绪监听</span></span><br><span class="line">        <span class="built_in">FD_SET</span>(fdsArray[i], &amp;readfds); </span><br><span class="line">        <span class="keyword">if</span> (maxFd &lt; fdsArray[i]) &#123;</span><br><span class="line">            maxFd = fdsArray[i]; <span class="comment">// 3. 更新出fd最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用select开始监听</span></span><br><span class="line">    <span class="type">int</span> sret = <span class="built_in">select</span>(maxFd+<span class="number">1</span>, &amp;readfds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">    <span class="keyword">switch</span> (sret)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 等待超时</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;time out ... : &quot;</span> &lt;&lt; (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:<span class="comment">// 等待失败</span></span><br><span class="line">        cerr &lt;&lt; errno &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 等待成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;wait success: &quot;</span> &lt;&lt; sret &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本框架搭起来了, 我们这时候就只需要实现等待成功后取出链接和IO信息的操作了;</p><p>先来测试一下当前的手脚架吧</p><h3 id="3-2-4-手脚架测试"><a href="#3-2-4-手脚架测试" class="headerlink" title="3.2.4 手脚架测试"></a>3.2.4 手脚架测试</h3><p>编译启动, 使用命令行参数来绑定端口, 在没有收到数据之前, 进程会在select中阻塞等待5秒, 随后因为超时跳出阻塞态, 返回0并打印当前时间戳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cpp -o test</span><br><span class="line">$ ./test 10000</span><br><span class="line">time out ... : 1692955522</span><br><span class="line">time out ... : 1692955527</span><br><span class="line">time out ... : 1692955532</span><br><span class="line">time out ... : 1692955537</span><br><span class="line">time out ... : 1692955542</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>telnet</code>命令来链接当前服务, <code>select</code>检测到listensock文件描述符就绪, 会立刻返回（对于listensock来说, 来了新链接就是读IO就绪）但因为我们没有写取走新socket的代码, 所以这里会一直打印事件就绪;</p><p>返回值为1, 代表有一个文件描述符的事件就绪。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/bcd37076cf11a3ec0d3caac5f7f0501f.png" alt="image-20230825172642067"></p><h3 id="3-2-5-处理新连接"><a href="#3-2-5-处理新连接" class="headerlink" title="3.2.5 处理新连接"></a>3.2.5 处理新连接</h3><p>在<code>select</code>事件就绪后, 使用如下函数来处理新的链接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerEvent</span><span class="params">(<span class="type">int</span> listensock, fd_set &amp;readfds)</span></span>;</span><br></pre></td></tr></table></figure><p>这里额外写了一个打印数组中元素的函数, 方便我们观察结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 打印数组中的文件描述符</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ShowArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前合法sock list: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == DFL_FD )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要遍历整个链接数组, 并判断当前位置是否是有效的文件描述符。无效直接跳过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fdsArraySz; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fdsArray[i] == DFL_FD)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 处理新连接和已有链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的时候, 我们需要对listensock做单独的处理, 毕竟获取新连接和维护已有链接的流程是完全不同的。下面说说流程</p><ul><li>判断是否有在select中监听该文件描述符</li><li>有监听, 继续往后执行, 开始进行<code>accept</code>获取新的链接</li><li>获取失败, 直接跳出该函数, 结束该轮处理</li><li>获取成功, 不能直接read&#x2F;write, 而是应该通过数组交付给select帮我们监听事件</li><li>下一轮循环中, select便会帮我们监听该新链接的事件是否就绪</li></ul><p>因为走到这里的时候, 我们的<code>listensocket</code>里面是一定有新连接的, 所以对<code>accept</code>的调用是不会阻塞线程的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; fdsArray[i] == listensock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断listensocket有没有事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">FD_ISSET</span>(listensock, &amp;readfds))&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;listensocket not set in readfds&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具有了一个新链接</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get new connection&quot;</span> &lt;&lt; endl;</span><br><span class="line">    string clientip;</span><br><span class="line">    <span class="type">uint16_t</span> clientport = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sock = Sock::<span class="built_in">Accept</span>(listensock, &amp;clientip, &amp;clientport); <span class="comment">// 不会阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 出错了, 直接返回</span></span><br><span class="line">    <span class="comment">// 成功获取新连接</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;new conn:&quot;</span> &lt;&lt; clientip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; clientport &lt;&lt; <span class="string">&quot; | sock: &quot;</span> &lt;&lt; sock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们不能直接对这个socket进行独写, 因为新链接来了并不代表新数据一并过来了</span></span><br><span class="line">    <span class="comment">// 所以需要将新的文件描述符利用全局数组, 交付给select</span></span><br><span class="line">    <span class="comment">// select 帮我们监看socket上的读事件是否就绪</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fdsArraySz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fdsArray[i] == DFL_FD)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 达到上限了</span></span><br><span class="line">    <span class="keyword">if</span> (i == fdsArraySz)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;reach the maximum number of connections&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 没有达到</span></span><br><span class="line">    &#123;</span><br><span class="line">        fdsArray[i] = sock; <span class="comment">// 新的链接, 插入到数组中, 下次遍历就会添加到select监看中</span></span><br><span class="line">        <span class="built_in">ShowArray</span>(fdsArray, fdsArraySz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-6-处理已有链接"><a href="#3-2-6-处理已有链接" class="headerlink" title="3.2.6 处理已有链接"></a>3.2.6 处理已有链接</h3><p>这里暂时只做了对读的操作, 当读事件就绪的时候, 我们通过read读取已有的数据。这里因为socket中肯定是有数据的, 所以也不会出现阻塞的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// end if (i == 0 &amp;&amp; fdsArray[i] == listensock)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理普通sock的IO事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fdsArray[i], &amp;readfds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// read、recv读取即可</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">recv</span>(fdsArray[i], buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>); <span class="comment">// 不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[s] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; <span class="string">&quot;]# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="comment">// 对端关闭</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; <span class="string">&quot;] quit, server close &quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(fdsArray[i]);</span><br><span class="line">            fdsArray[i] = DFL_FD; <span class="comment">// 去除对该文件描述符的select事件监听</span></span><br><span class="line">            <span class="built_in">ShowArray</span>(fdsArray, fdsArraySz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 异常了</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; <span class="string">&quot;] error, server close &quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(fdsArray[i]);</span><br><span class="line">            fdsArray[i] = DFL_FD; <span class="comment">// 去除对该文件描述符的select事件监听</span></span><br><span class="line">            <span class="built_in">ShowArray</span>(fdsArray, fdsArraySz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我单次读取的时候, 最多只能读出1024字节的数据;如果想一次性读取完毕, 则需要使用循环+设置非阻塞来进行读取。后续在epoll的代码示例中会展示这种写法。</p><h3 id="3-2-7-实测"><a href="#3-2-7-实测" class="headerlink" title="3.2.7 实测"></a>3.2.7 实测</h3><p>到这里, 我们这套代码就基本完成了, 可以来测试一下能否实现单线程监听多个链接;</p><p>在本地使用telnet+多个终端进行测试, 可以看到我们成功实现了同时监听两个链接, 并接受这两个链接给自己发送的信息的功能。当telnet退出的时候, 也能成功回收文件描述符。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/c14d2576fc599392522042a1bb12ddc5.png" alt="image-20230825183501900"></p><p>select的小实现暂时先看到这里, 如果想用select实现同时读+写, 其实是很复杂的。需要一套完整的逻辑。这就留着到最后epoll的时候再统一展现吧！</p><h2 id="3-3-socket就绪条件"><a href="#3-3-socket就绪条件" class="headerlink" title="3.3 socket就绪条件"></a>3.3 socket就绪条件</h2><p><span id="jump3">socket不同事件的就绪有各自的条件</span></p><h3 id="3-3-1-读就绪"><a href="#3-3-1-读就绪" class="headerlink" title="3.3.1 读就绪"></a>3.3.1 读就绪</h3><ul><li>socket内核中, 接收缓冲区中的字节数, 大于等于低水位标记<code>SO_RCVLOWAT</code>, 此时可以无阻塞的读该文件描述符, 并且返回值大于0;</li><li>socket在TCP通信中, 对端关闭连接, 此时对该socket读, 则返回0;</li><li>监听的socket上有新的连接请求;</li><li>socket上有未处理的错误;</li></ul><h3 id="3-3-2-写就绪"><a href="#3-3-2-写就绪" class="headerlink" title="3.3.2 写就绪"></a>3.3.2 写就绪</h3><ul><li>socket内核中, 发送缓冲区中的可用字节数(发送缓冲区的空闲位置大小), 大于等于低水位标记 <code>SO_SNDLOWAT</code>, 此时可以无阻塞的写, 并且返回值大于0;</li><li>socket的写操作被关闭(close或者shutdown). 对一个写操作被关闭的socket进行写操作, 会触发 <code>SIGPIPE</code> 信号;</li><li>socket使用非阻塞connect连接成功或失败之后;</li><li>socket上有未读取的错误;</li></ul><h3 id="3-3-3-异常就绪"><a href="#3-3-3-异常就绪" class="headerlink" title="3.3.3 异常就绪"></a>3.3.3 异常就绪</h3><p>socket上收到带外数据（TCP报头中的URG和紧急指针）</p><h2 id="3-4-select的特点"><a href="#3-4-select的特点" class="headerlink" title="3.4 select的特点"></a>3.4 select的特点</h2><ul><li>可监控的文件描述符有上限, 取决于<code>fd_set</code>位图结构体的配置</li><li>在监控文件描述符的时候, 需要用户额外的数组来维护文件描述符</li><li>每次循环都得遍历整个数组, 效率较低（可以优化为保证有效文件描述符都在数组的前方）</li></ul><p>一下是它在效率上的一些缺点</p><ul><li>每次调用select都得手动设置一边fd集和（因为<code>fd_set</code>也是输出型参数, 在内核中会被修改）</li><li>每次调用select, 都需要把所有fd从用户态拷贝到内核态, 小陆地</li><li>每次调用, 内核都须遍历传递进来的位图, 效率低</li><li>监控的文件描述符有上限, 数量小</li></ul><h1 id="4-多路转接之poll"><a href="#4-多路转接之poll" class="headerlink" title="4.多路转接之poll"></a>4.多路转接之poll</h1><h2 id="4-1-函数原型"><a href="#4-1-函数原型" class="headerlink" title="4.1 函数原型"></a>4.1 函数原型</h2><p>接下来我们要了解的是另外一个多路转接方案, <strong>poll</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds,  <span class="type">nfds_t</span> nfds,  <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-1-参数"><a href="#4-1-1-参数" class="headerlink" title="4.1.1 参数"></a>4.1.1 参数</h3><p>这里的参数就和select完全不同了, 出现了另外一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一个结构体分别包含了三个成员</p><ul><li>文件描述符fd;</li><li>用户告诉内核需要监看的事件events;</li><li>内核返回的就绪事件revents;</li></ul><p>但是从这个函数的参数上看来, 貌似它是一个只有一个元素的输入输出型参数, 难道说poll只能监看一个文件描述符吗？🧐</p><p>非也, 我们将函数原型改一下就能看明白了, 实际上, 第一个参数是一个<strong>结构体数组</strong>, 第二个参数是该结构体数组的<strong>长度</strong>！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fds[],  <span class="type">nfds_t</span> nfds,  <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>第三个参数和select中的timeout的功能相同, 如果到达一定时间还没有获取到参数, 则直接返回;如果设置为<code>-1</code>则阻塞等待, 设置为0为完全非阻塞。</p><p>这里的timeout并非输入输出型号参数, 其只是一个输入参数, 单位为<strong>毫秒</strong>（记住, 不是秒, 是毫秒）</p><h3 id="4-1-2-返回值"><a href="#4-1-2-返回值" class="headerlink" title="4.1.2 返回值"></a>4.1.2 返回值</h3><ul><li>小于0, 出错</li><li>等于0, 等待超时</li><li>大于0, 文件描述符已经就绪的数量</li></ul><h3 id="4-1-3-事件"><a href="#4-1-3-事件" class="headerlink" title="4.1.3 事件"></a>4.1.3 事件</h3><p>这里需要了解一下poll包含的事件类型了, 我们需要根据不同情况来选择想要的事件, 并设置到结构体的<code>event</code>中;对于select&#x2F;poll&#x2F;epoll来说, 这些socket的就绪条件都是相同的。详见 <a href="#jump3">3.3 socket就绪条件</a>;</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/748d3a20ba69bb3b3671f5b344cba650.png" alt="img"></p><h2 id="4-2-poll优缺点"><a href="#4-2-poll优缺点" class="headerlink" title="4.2 poll优缺点"></a>4.2 poll优缺点</h2><h3 id="4-2-1-优点"><a href="#4-2-1-优点" class="headerlink" title="4.2.1 优点"></a>4.2.1 优点</h3><p>在poll中, 使用的是一个结构体数组来表示需要监听的文件描述符, 以及事件就绪的文件描述符</p><ul><li>因为结构体中用户需要监听的event和内核返回的就绪event并不在一个变量上, 所以只需要设置一次即可（如果需求没有变动的话）, 无需像select每次都得重新遍历来设置位图</li><li>poll没有最大文件描述符限制</li><li>poll无需用户额外维护一个单独的文件描述符数组, 直接沿用该结构体数组即可</li></ul><h3 id="4-2-2-缺点"><a href="#4-2-2-缺点" class="headerlink" title="4.2.2 缺点"></a>4.2.2 缺点</h3><ul><li>和select一样, poll也需要轮询检测就绪的fd和相关事件</li><li>每次调用poll需要把pollfd结构体从用户态拷贝到内核态</li><li>虽然poll没有最大文件描述符限制, 但是监看的多了后性能会线性下降</li></ul><h2 id="4-3-看看示例代码"><a href="#4-3-看看示例代码" class="headerlink" title="4.3 看看示例代码"></a>4.3 看看示例代码</h2><p>poll的代码部分的主机结构和select基本相同，这里我们主要来说一下不同的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFL_FD -1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fdsArray</span>[<span class="title">NUM</span>];</span></span><br></pre></td></tr></table></figure><p>首先是全局的数组，这时候不需要自己维护一个int文件描述符数组了，直接使用这个结构体作为全局数组就OK了；在main函数里面还是老样子，我们得把整个数组的fd都设置成默认的fd作为标识</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fdsArray[i].fd = DFL_FD;</span><br><span class="line">    fdsArray[i].events = <span class="number">0</span>;</span><br><span class="line">    fdsArray[i].revents = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fdsArray[<span class="number">0</span>].fd = listensock;</span><br><span class="line">fdsArray[<span class="number">0</span>].events = POLLIN;</span><br></pre></td></tr></table></figure><p>在main函数的主循环中，也是用poll来依次监听事件，并判断poll函数的返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> timeout = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = poll(fdsArray, NUM, timeout);</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;time out ... : &quot;</span> &lt;&lt; (<span class="type">unsigned</span> <span class="type">long</span>)time(nullptr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            HandlerEvent(listensock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>HandlerEvent</code>函数中，我们通过判断结构体内部的<code>revent</code>来得知是否有事件就绪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fdsArray[i].revents &amp; POLLIN)&#123;&#125; <span class="comment">// 读事件是否就绪</span></span><br></pre></td></tr></table></figure><p>对于listensocket来说，就绪了就执行accept；并将新的文件描述符添加到数组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NUM; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fdsArray[j].fd == DFL_FD)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过for循环找到当前位置是默认的结构体下标</span></span><br><span class="line"><span class="keyword">if</span> (j == NUM) <span class="comment">// 如果达到上限才break</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;我的服务器已经到了最大的上限了，无法在承载更多同时保持的连接了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    fdsArray[j].fd = sock; <span class="comment">// 将sock添加到数组中</span></span><br><span class="line">    fdsArray[j].events = POLLIN;</span><br><span class="line">    fdsArray[j].revents = <span class="number">0</span>;</span><br><span class="line">    ShowArray(fdsArray, NUM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于其他链接来说，就绪了就开始read。如果read异常或者对端关闭，那就将对应位置的结构体全部初始化（清空），相当于将这个链接从监听中去掉！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdsArray[i].fd = DFL_FD; </span><br><span class="line">fdsArray[i].events = 0;</span><br><span class="line">fdsArray[i].revents = 0;</span><br></pre></td></tr></table></figure><p>其余的操作和select完全一致，在这里就不展示代码了！</p><h1 id="5-epoll"><a href="#5-epoll" class="headerlink" title="5.epoll"></a>5.epoll</h1><p>man手册中提到, epoll是为了处理大量socket文件描述符句柄而进行了一定改进的poll;</p><h2 id="5-1-接口"><a href="#5-1-接口" class="headerlink" title="5.1 接口"></a>5.1 接口</h2><p>epoll就不是只有一个函数接口了, 而是有3个相关的函数，使用过程就是三部曲：</p><ul><li>epoll_create 创建epoll文件句柄</li><li>epoll_ctl 将需要监控的文件描述符进行注册</li><li>epoll_wait 等待文件描述符就绪</li></ul><h3 id="5-1-1-epoll-create"><a href="#5-1-1-epoll-create" class="headerlink" title="5.1.1 epoll_create"></a>5.1.1 epoll_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>epoll在使用的时候, 我们需要用create函数创建一个epoll的句柄（本质上也是文件描述符）, 来管理当前进程需要操作系统帮我们监看的文件描述符</p><ul><li>自从<code>linux 2.6.8</code> 后, 这里的size参数是被忽略的</li><li>epoll的句柄在使用完毕后也需要用<code>close()</code>函数关闭</li><li>错误的时候返回<code>-1</code>并设置errno, 正确的时候返回文件描述符</li></ul><h3 id="5-1-2-epoll-ctl"><a href="#5-1-2-epoll-ctl" class="headerlink" title="5.1.2 epoll_ctl"></a>5.1.2 epoll_ctl</h3><p>该函数是对epoll中需要监看的文件描述符进行设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,  <span class="type">int</span> op,  <span class="type">int</span> fd,  <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数是<code>epoll_create</code>的返回值</li><li>第二个参数是动作, 包含三个不同的选项<ul><li><code>EPOLL_CTL_ADD</code>：将新的文件描述符添加到<code>epfd</code>中</li><li><code>EPOLL_CTL_MOD</code>：修改已有文件描述符的监听事件</li><li><code>EPOLL_CTL_DEL</code>：删除已有文件描述符</li></ul></li><li>第三个参数是目标文件描述符</li><li>第四个参数是一个<code>epoll_event</code>结构体</li></ul><p>这个结构体的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件<code>events</code>可以是下面的这些选项</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>EPOLLIN</td><td>表示对应的文件描述符可以读 (包括对端SOCKET正常关闭);</td></tr><tr><td>EPOLLOUT</td><td>表示对应的文件描述符可以写;</td></tr><tr><td>EPOLLPRI</td><td>表示对应的文件描述符有紧急的数据可读 (这里应该表示有带外数据到来);</td></tr><tr><td>EPOLLERR</td><td>表示对应的文件描述符发生错误;</td></tr><tr><td>EPOLLHUP</td><td>表示对应的文件描述符被挂断;</td></tr><tr><td>EPOLLET</td><td>将EPOLL设为<strong>边缘触发 <strong>(Edge Triggered)模式, 这是相对于</strong>水平触发</strong>(Level Triggered) 来说的；</td></tr><tr><td>EPOLLONESHOT</td><td><strong>只监听一次事件,</strong> 当监听完这次事件之后, 如果还需要继续监听这个socket的话, 需要手动再次把这个socket加入到EPOLL队列里；</td></tr></tbody></table><h3 id="5-1-3-epoll-wait"><a href="#5-1-3-epoll-wait" class="headerlink" title="5.1.3 epoll_wait"></a>5.1.3 epoll_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd,  <span class="keyword">struct</span> epoll_event *events, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> maxevents,  <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_pwait</span><span class="params">(<span class="type">int</span> epfd,  <span class="keyword">struct</span> epoll_event *events, </span></span><br><span class="line"><span class="params">                <span class="type">int</span> maxevents,  <span class="type">int</span> timeout, </span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span>;</span><br></pre></td></tr></table></figure><p>改函数的作用是收集在epoll监控的事件中，已经就绪的事件</p><ul><li>第一个参数是epoll的文件描述符句柄</li><li>参数events是<code>epoll_events</code>结构体数组，是一个输出型参数。epoll会将就绪的事件赋值到events数组里面；</li><li>maxevents 告诉内核这个events的大小，其不可以超过<code>epoll_create</code>的size；</li><li>参数timeout是超时时间，也是毫秒（0非阻塞，-1永久阻塞）</li><li>返回值：成功返回IO事件就绪的文件描述符数目，0代表超时，负数代表失败</li></ul><h2 id="5-2-工作原理"><a href="#5-2-工作原理" class="headerlink" title="5.2 工作原理"></a>5.2 工作原理</h2><h3 id="5-2-1-从源码看流程"><a href="#5-2-1-从源码看流程" class="headerlink" title="5.2.1 从源码看流程"></a>5.2.1 从源码看流程</h3><p>我们知道，select通过位图来告诉操作系统需要管理的文件描述符，poll通过结构体数组来告诉操作系统需要管理的文件描述符。</p><p>但epoll里面，却变成了一个epfd文件句柄，我们只是给这个特定的句柄交付文件描述符。这说明底层肯定需要其他的数据结构，来管理某个进程的某个epfd交付给操作系统的文件描述符，以及需要监看的事件！</p><p>在<code>Linux 2.6.32.16</code>源码<code>fs/eventpoll.c</code>中，可以找到如下这个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux源码文件路径：fs/eventpoll.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is stored inside the &quot;private_data&quot; member of the file</span></span><br><span class="line"><span class="comment"> * structure and rapresent the main data sructure for the eventpoll</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Protect the this structure access */</span></span><br><span class="line">	<span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">	 * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">	 * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">	 * code and the ctl operations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment">	 * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment">	 * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里面，我们既可以看到熟悉的<code>mutex</code>锁，又可以看到一个<code>wait_queue</code>等待队列，一个双链表，和一个<code>rb_root</code>红黑树节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;; <span class="comment">// 内核中的双链表</span></span><br></pre></td></tr></table></figure><p>抽象出来之后，其大概的结构图如下</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/6ca5fd02f9838c2ef2d41a014623262d.png" alt="image-20230826160246637"></p><p>当某一个进程调用<code>epoll_create</code>创建<code>epoll</code>的文件描述符句柄的时候，操作系统就会帮我们在底层创建一个<code>struct eventpoll</code>结构体，内部包含了就绪队列和一个红黑树（主要关注这两个成员）</p><ul><li>调用<code>epoll_ctl</code>的时候，操作系统就会将我们配置的文件描述符和对于的事件添加到红黑树节点中；</li><li>重复添加的事件也可以通过红黑树的键值唯一性检查出来（避免冗余）</li><li>所有添加到epoll中的事件都会与设备的<strong>网卡驱动程序</strong>建立回调消息，当某个文件描述符对应的链接有信息传来的时候，就会调用<strong>回调函数</strong>，告知epoll<ul><li>网卡收到消息</li><li>驱动程序处理，并调用对应的回调机制</li><li>epoll通过回调消息收到事件就绪，将其链入<code>rdllist</code>双链表中</li><li>上层只需要调回<code>epoll_wait</code>从该双链表中获取就绪事件</li></ul></li><li>该回调办法在底层为<code>ep_poll_callback</code>，它会将就绪的事件插入到<code>rdllist</code>双链表中</li><li>epoll中每一个事件都会建立一个对应的<code>epitem</code>结构体</li><li>当调用<code>epoll_wait</code>有事件发生的时候，只需要检查<code>eventpoll</code>对象的<code>rdllist</code>双链表中是否有<code>epitem</code>元素即可，有则取出；</li><li>如果<code>rdllist</code>不为空，则将发生的事件复制到用户态，并将事件数量返回给用户；对比需要遍历的<code>select/poll</code>，这个获取就绪事件的<strong>时间复杂度</strong>是<code>O(1)</code>的（直接判断并取出就可以了）</li></ul><p>这一大圈操作都是操作系统自行完成的，对于用户来说是无感知的！</p><p>关于epitem结构体，可以瞅一眼下面的注释，他也是在源码的<code>fs/eventpoll.c</code>文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class="line">	<span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn; <span class="comment">// 这个事件对应的红黑树节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink; <span class="comment">// 这个事件对应的双链表节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">	 * single linked chain of items.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epitem</span> *next; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd; <span class="comment">// 事件句柄信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">	<span class="type">int</span> nwait; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List containing poll wait queues */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> pwqlist;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The &quot;container&quot; of this item */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep; <span class="comment">// 指向其所属的epollevent对象</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> fllink;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> event; <span class="comment">// 该fd关注的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-PSH标记位"><a href="#5-2-2-PSH标记位" class="headerlink" title="5.2.2 PSH标记位"></a>5.2.2 PSH标记位</h3><p>在学习TCP的时候，我们了解过PSH这个标记位，它的作用是告诉对端的应用层，尽快取走缓冲区中的数据。</p><p>对于epoll而言，这个PSH的作用就是让epoll在<code>rdllist</code>里面新建一个就绪节点，这样上层就能知道这个文件描述符的事件就绪了（至于读不读取依旧是上层的问题）</p><ul><li>你可能会问，既然对方都发消息来催你取数据了，那不应该你的数据并没有被取走吗？这时候该文件描述符的就绪节点不应该已经存在了吗？为什么还需要额外创建一个就绪事件的节点来通知用户呢？</li></ul><p>这就涉及到epoll的两种工作策略LT&#x2F;ET了，后文会讲解；</p><blockquote><p>需要注意的是，epoll并没有对URG进行特殊处理，而是视之为正常的可读事件连入就绪队列，但是事件类型有所不同，可以用<code>EPOLLPRI</code>来关注紧急事件</p><p>（存疑，但是没有找到相关资料，暂且这么认为）</p></blockquote><h3 id="5-2-3-epoll优点"><a href="#5-2-3-epoll优点" class="headerlink" title="5.2.3 epoll优点"></a>5.2.3 epoll优点</h3><p>一下是epoll相比poll和select的优点</p><ul><li>接口使用方便，虽然拆分了3个函数，但是每个函数的功能非常明确；不需要每次使用都重新设置文件描述符，也实现了输入和输出参数的分离</li><li>数据拷贝轻量：在需要的时候调用epoll_ctl来处理文件描述符和事件，并不会每次调用都得大批量在用户和内核态之间拷贝数据（poll和select都需要）</li><li>事件回调机制：使用事件回调来替代遍历，回调函数将就绪的文件描述符结构加入到就绪队列中；<code>epoll_wait</code>直接使用就绪队列，就能知道那些文件描述符就绪；即便文件描述符较多的时候，也能快速知道就绪的文件描述符（省去了遍历的时间消耗）</li><li>无上限：文件描述符没有数量限制</li><li>线程安全：在<code>eventpoll</code>结构体里面，我们可以看到有一个<code>mutex</code>锁，在linux底层已经帮我维护了epoll相关操作的线程安全性！</li></ul><p>在有些博客里面说epoll使用了<strong>内存映射机制</strong>，这种说法是<strong>错误</strong>的！因为<code>epoll_event</code>结构体是在用户态创建的，我们势必还是需要进行一定的用户态到内核态的拷贝。</p><blockquote><p>内存映射机制：linux内核直接将就绪队列通过mmap的方式映射到用户态，避免拷贝消耗（你可以理解为用户态和内核态之间的共享内存）</p></blockquote><h2 id="5-3-工作模式"><a href="#5-3-工作模式" class="headerlink" title="5.3 工作模式"></a>5.3 工作模式</h2><p>在epoll的工作模式中，我们可以选择水平触发和边缘触发，这就好比物理实验中示波器的两种触发模式；</p><p>假设有这样一个tcp通信的栗子：</p><ul><li>对方给我发送了2kb数据</li><li>我通过epoll_wait成功获取到这个文件描述符的读事件就绪</li><li>我取出文件描述符，通过<code>recv</code>读取了1kb的数据</li><li>但缓冲区里面还有1kb……</li></ul><h3 id="5-3-1-水平触发-LT"><a href="#5-3-1-水平触发-LT" class="headerlink" title="5.3.1 水平触发 LT"></a>5.3.1 水平触发 LT</h3><p>所谓水平触发，就是只要fd的缓存区里面有数据，那么epoll就会一直认为这个fd的读事件是就绪的，并一直通知用户；</p><ul><li>上面的栗子中，因为用户只拿走了1kb数据，缓冲区里面还有1kb，在第二次调用<code>epoll_wait</code>的时候，epoll还是会报告该文件描述符的读事件就绪，让用户取走剩下的数据</li><li>只有所有的数据都被处理完毕，epoll才不会继续通知</li><li>LT支持阻塞和非阻塞读写</li></ul><p>因为LT模式只要缓冲区中还有剩余数据，epoll就会一直通知我们，这就允许上层不需要一次性取走所有数据，或者说不立刻处理当前缓冲区的数据。</p><p>因此，在LT模式中，只要是事件就绪，那么缓冲区里面一定会有数据。所以它是即支持阻塞，也支持非阻塞的文件读写的！</p><blockquote><p>select&#x2F;poll都是默认的LT模式，且不可以切换模式；epoll默认是LT，但可以切换到ET</p></blockquote><h3 id="5-3-2-边缘触发-ET"><a href="#5-3-2-边缘触发-ET" class="headerlink" title="5.3.2 边缘触发 ET"></a>5.3.2 边缘触发 ET</h3><p>边缘触发的含义，是只有某个文件描述符的数据变动的时候，才会通知用户；反应到读事件上，只有缓冲区数据增多了，才会通知用户；</p><ul><li>在上面的tcp通信栗子中，epoll会在数据到来的时候通知用户；但即便用户没有一次性读取完毕所有数据，epoll并不会继续通知了（除非有PSH信息到来）</li><li>在ET模式下，文件描述符的事件就绪后，只有一次处理机会。第二次你就无法得知这个文件描述符上是否还有没有读完的数据了</li><li>因为ET模式下<code>epoll_wait</code>返回的次数更少，所以ET的性能远高于LT（nginx默认采用ET模式的epoll）</li><li>因为我们只有一次机会，所以收到事件后必须立即处理</li><li>只支持非阻塞</li></ul><h3 id="5-3-3-LT和ET的区别"><a href="#5-3-3-LT和ET的区别" class="headerlink" title="5.3.3 LT和ET的区别"></a>5.3.3 LT和ET的区别</h3><p>因为ET模式下，epoll只会提示你一次事件就绪，所以就倒逼程序猿在收到这个事件之后，一次性处理完数据；</p><p>当然，LT模式下你也可以这么做（如果每次都能一次性取走数据，那么LT和ET的性能差距就不大了）。但ET模式就相当于告诉所有使用者，必须这么做，减少了容错率；</p><p>但ET的代码复杂度会增加；</p><h3 id="5-3-4-ET和非阻塞"><a href="#5-3-4-ET和非阻塞" class="headerlink" title="5.3.4 ET和非阻塞"></a>5.3.4 ET和非阻塞</h3><p>为什么ET必须要将文件描述符设置成非阻塞呢？</p><p>假设下面这个场景，客户端C给服务端S发送10kb数据，在没有收到服务端对这个数据的响应之前，不会继续发送数据；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/1320c1d24627c05783f4d64dc6f43f21.png" alt="image-20230826180800176"></p><p>但服务器一次性只读取了1KB，剩下了9KB数据在缓冲区中；因为数据没有读完，所以不会给客户端发送响应。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/42b5a34b96663a7b0314afd41e325896.png" alt="image-20230826180840435"></p><p>因为epoll设置了ET模式，所以并不会认为此时的文件描述符读就绪；<code>epoll_wait</code>不会针对这个文件描述符返回，剩下的9KB数据会一直留在缓冲区中；</p><ul><li>注意，服务端的代码逻辑是收到就绪事件就读取一次；并不存在再次读取的可能</li></ul><p>问题就来了！</p><ul><li>服务端必须要收到就绪事件才会把剩下的9kb数据给读取完毕</li><li>服务端想要收到就绪事件，就必须收到客户端C发来的新数据</li><li>但客户端C认为服务器没有给自己发送响应，不会继续发送数据</li></ul><p>这就相当于一个死循环了！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/be296238e7cd395dabf1599602a8b193.png" alt="image-20230826181214987"></p><p>因此，服务端为了保证一次性能将数据全部取出，必须要采用循环读取+非阻塞的方式来将缓冲区读完！</p><p>如果采用阻塞式，那么在轮询读取的时候，就有可能因为缓冲区已经空了而阻塞！因为我们这个是一个单线程的模型，这样会直接导致整个服务器宕机了。</p><p>而LT则不会出现此问题，因为只要缓冲区中有数据就会通知你，所以我们可以一次读取定长，再将读到的数据拼接起来。</p><h3 id="5-3-5-epoll的使用场景"><a href="#5-3-5-epoll的使用场景" class="headerlink" title="5.3.5 epoll的使用场景"></a>5.3.5 epoll的使用场景</h3><p>epoll的高性能是有一定特殊场景的，如果场景不适合，epoll的性能可能表现不佳；</p><ul><li>对于多链接且链接中有一部分活跃的时候，适合使用epoll</li></ul><p>比如各种互联网APP的入口服务器，就很适合使用epoll来处理上万客户端的请求；</p><p>如果是系统内部处理服务器和服务器之间的通信，链接数较少的情况，这种时候使用epoll并不方便。得根据具体需要选择更加适合的IO模型。</p><h2 id="5-4-惊群效应"><a href="#5-4-惊群效应" class="headerlink" title="5.4 惊群效应"></a>5.4 惊群效应</h2><blockquote><p>参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/359774959">https://zhuanlan.zhihu.com/p/359774959</a></p></blockquote><h3 id="5-4-1-概念"><a href="#5-4-1-概念" class="headerlink" title="5.4.1 概念"></a>5.4.1 概念</h3><p>在多线程环境下，可能会遇到epoll的惊群效应；</p><ul><li>那么什么是惊群效应呢。其产生的原因是什么呢？</li></ul><p>惊群效应的具体情况是，当有多个线程或进程在 epoll 上等待某个事件（如套接字可读事件），当该事件发生时，所有等待的线程或进程都会被唤醒。然而，只有一个线程或进程可以成功地处理这个事件，而其他的线程或进程会进行不必要的竞争，可能会导致额外的上下文切换、锁竞争等问题，从而降低系统性能。</p><ul><li>以下是一个具体场景的说明</li></ul><p>在多线程或者多进程环境下，有些人为了提高程序的稳定性，往往会让<strong>多个线程</strong>或者<strong>多个进程</strong>同时在<code>epoll_wait</code>监听的socket描述符。当一个新的链接请求进来时，操作系统<strong>不知道</strong>选派那个线程或者进程处理此事件，则干脆将其中<strong>几个线程</strong>或者进程给唤醒，而实际上只有其中一个进程或者线程能够成功处理accept事件，其他线程都将失败，且errno错误码为<code>EAGAIN</code>。这种现象称为惊群效应。</p><p>结果是肯定的，惊群效应肯定会带来资源的消耗和性能的影响，因为你无端地多唤醒了几个线程，这些线程&#x2F;进程却没有活干。</p><h3 id="5-4-2-多线程环境下解决办法"><a href="#5-4-2-多线程环境下解决办法" class="headerlink" title="5.4.2 多线程环境下解决办法"></a>5.4.2 多线程环境下解决办法</h3><ul><li>专门的线程负责等待：在多线程场景下，不建议让多个线程进行<code>epoll_wait</code>，而用单个线程进行wait，并由该线程调用<code>accept</code>建立新链接，并将就绪的文件描述符交付给其他线程，来处理后续的读写操作。</li><li>使用线程池：不为每个链接都创立一个专门的线程，而是根据读写事件，将其交付给线程池中已有线程来处理；</li><li>使用ET模式：该模式下读写就绪的时候只会通知一次，再加上epoll本身是线程安全的，所以只会有一个线程可以拿到这个就绪事件，从而避免惊群现象；</li><li>互斥锁：同一时间只有一个线程进行等待和事件处理；</li></ul><h3 id="5-4-3-多进程下解决办法"><a href="#5-4-3-多进程下解决办法" class="headerlink" title="5.4.3 多进程下解决办法"></a>5.4.3 多进程下解决办法</h3><p>目前很多开源软件，如lighttpd和nginx等都采用<code>master/workers</code>的模式提高软件的吞吐能力及并发能力，在nginx中甚至还采用了<strong>负载均衡</strong>的技术，在某个子进程的处理能力达到一定负载之后，由其他<strong>负载较轻的子进程</strong>负责·的调用，那么nginx和Lighttpd是如何避免<code>epoll_wait</code>的惊群效用的呢？</p><ul><li>lighttpd的解决思路是<strong>无视</strong>惊群效应</li></ul><p>仍然采用<code>master/workers</code>模式，每个子进程仍然自己在监听的socket上调用<code>epoll_wait</code>，当有新的链接请求发生时，操作系统仍然只是唤醒其中部分的子进程来处理该事件，仍然只有一个子进程能够成功处理此事件，那么其他被惊醒的子进程捕获<code>EAGAIN</code>错误，并无视。</p><ul><li>nginx的解决思路是互斥锁</li></ul><p>在同一时刻，<strong>永远都只有一个</strong>子进程在监听的socket上<code>epoll_wait</code>，其做法是，创建一个全局的<code>pthread_mutex_t</code>，在子进程进行<code>epoll_wait</code>前，则先获取锁。当<code>epoll_wait</code>返回之后，nginx会调用accept把连接取出来，然后释放文件锁，让别的进程去监听。</p><p>这是一种折衷的办法，并没有很完美，首先进程间<strong>争抢锁</strong>会有性能开耗（即使是非阻塞的锁），中间可能会有小段时间没有进程去获取锁，比如A进程拿到锁，其他进程将会过一小段时间尝试再去获取锁，而这小段时间里面如果请求量很大，A仅接受一小部分请求就让出锁，则中间过程会有一些连接事件被hang住；</p><h3 id="5-4-4-内核解决了惊群效应了吗"><a href="#5-4-4-内核解决了惊群效应了吗" class="headerlink" title="5.4.4 内核解决了惊群效应了吗"></a>5.4.4 内核解决了惊群效应了吗</h3><p>惊群的根本原因在于epoll的默认行为是对于<strong>多进程监听同一文件不会设置互斥</strong>，进而将所有进程唤醒，后续的内核版本主要提供了两种解决方案</p><ol><li>既然默认不会设置互斥，那就加一个互斥功能好了，<code>linux 4.5</code>内核之后给epoll添加了一个<code>EPOLLEXCLUSIVE</code>的标志位，如果设置了这个标志位，那epoll将进程挂到等待队列时将会设置一下互斥标志位，这时实现跟内核原生accept一样的特性，只会唤醒队列中的一个进程</li><li>第二种方法：<code>linux 3.9</code>内核之后给socket提供<code>SO_REUSEPORT</code>标志，这种方式解决得更彻底，他允许不同进程的socket绑定到同一个端口，取代以往需要子进程共享socket监听的方式，这时候，每个进程的监听socket将指向<code>open_file_tables</code>下的不同节点，也就是说不同进程是在自己的设备等待队列下被挂起的，不存在共享fd的问题，也就不存在被同时唤醒的可能。而内核则在驱动中将设置了<code>SO_REUSEPORT</code>并且绑定同一端口的这些socket分到同一个group中，当有tcp连接事件到达的时候，内核将会对源<code>IP+源端口</code>取hash然后指定这个group中其中一个进程来接受连接，相当于在内核级别中实现了一个负载均衡</li></ol><p>基于以上两种方法，其实epoll生态在目前来说不存在所谓的惊群效应了。而新版本的nginx也采用了 <code>SO_REUSEPORT</code>来解决此问题。</p><p>除非你溢用epoll，比如多进程之间共享了同一个epfd（父进程创建epoll由多个子进程来调用），那就不能怪epoll了，因为这时候多个进程都被挂到这个epoll下，这种情况下，已经不是仅仅是惊群效应的问题了；比如说，A进程在epoll挂了socket1的连接事件，B进程调用了epoll_wait，由于属于同一个epfd，当socket1产生事件的时候，进程B也会被唤醒，而更严重的事情在于，在B进程的空间下并不存在socket1这个fd，从而把问题搞得很复杂。</p><p>总结：千万不要在多线程&#x2F;多进程之间共享epfd！</p><h1 id="6-Reactor模型"><a href="#6-Reactor模型" class="headerlink" title="6.Reactor模型"></a>6.Reactor模型</h1><p>接下来就让我们来用epoll编写一个基于Reactor模式的服务器吧！</p><h2 id="6-1-什么是Reactor？"><a href="#6-1-什么是Reactor？" class="headerlink" title="6.1 什么是Reactor？"></a>6.1 什么是Reactor？</h2><ul><li>Reactor模型是基于事件驱动的，通过一个或者多个输入同时传递给服务端进行处理</li><li>服务端请求程序处理传入的多个请求，并分发到相应的处理线程</li><li>基于IO多路转接（多路复用）模型：多个链接通用一个阻塞对象，引用程序只需要在一个阻塞对象等待，无需阻塞等待所有链接；当有新链接或者事件就绪的时候，由操作系统通知应用程序，开始进行业务处理</li><li>基于线程池复用线程资源：不必给每个链接单独创建线程，而是将链接完成后的业务处理交付给已有线程池中的线程进行处理，一个线程在生命周期中可以处理多个链接的业务。</li></ul><p>reactor模式有下面3种方式，<a target="_blank" rel="noopener" href="https://blog.csdn.net/wlddhj/article/details/123872275">参考博客 @顽石九变</a></p><h3 id="6-1-1-主从Reactor多线程模型"><a href="#6-1-1-主从Reactor多线程模型" class="headerlink" title="6.1.1 主从Reactor多线程模型"></a>6.1.1 主从Reactor多线程模型</h3><p>第一种是多线程模式的，有不同的从属reactor来进行事件监控和处理</p><ul><li>Reactor主线程负责监听事件并进行链接的accept</li><li>accpet获取到链接后，分配给某一个从Reactor进行读写事件的监听</li><li>从Reactor进行事件监听，当有新事件发生的时候，创建Handler进行事件处理</li><li>Headler通过read读取数据，并处理数据（这里还可以将读取数据后的响应操作分发给线程池进行处理，线程池处理完毕后返回给Handler），通过send返回给客户端</li><li>Reactor主线程可以对应多个子线程</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/9b1f1f0aec63e52ed44fca99f18d6e5a.png" alt="image-20230828085218401"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/ecdd89978c73b286f89f29703c620c7e.png" alt="img"></p><h3 id="6-1-2-单Reactor多线程"><a href="#6-1-2-单Reactor多线程" class="headerlink" title="6.1.2 单Reactor多线程"></a>6.1.2 单Reactor多线程</h3><ul><li>Reactor通过多路转接监听客户端事件，收到事件后，进行分发</li><li>如果是建立链接的请求，则执行accept，建立链接后，创建一个Handler完成链接建立后的各个操作</li><li>如果不是链接请求（读写就绪）则由Reactor分发调用链接对应的读写Handler来进行处理</li><li>Handler只负责响应具体的事件，而不进行具体的业务处理</li><li>通过Handler中的read读取到数据后，分发给线程池子中的线程处理，处理完毕后返回Handler，再通过写方法发送给客户端</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/18889218bcf8b973dd2140f84ee48c1d.png" alt="img"></p><h3 id="6-1-3-单Reactor单线程"><a href="#6-1-3-单Reactor单线程" class="headerlink" title="6.1.3 单Reactor单线程"></a>6.1.3 单Reactor单线程</h3><p>第三种是单线程模式下的（半异步半同步模型），当收到某个客户端的就绪事件，就去处理这个客户端的请求。此时Handler会完成read到业务处理到send的全流程；</p><p>本次主要写的是该模式下的操作，因为它基本是<strong>串行</strong>运行的，思路比较容易理解。但需要注意的是，这种模式支持的客户端量不应过多，否则会极大影响性能。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/bd8688effc6efb18264e9785cc78b54e.png" alt="image-20230828085239238"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/b057900a9b937973503f493cfa576711.png" alt="img"></p><h3 id="6-1-4-总结"><a href="#6-1-4-总结" class="headerlink" title="6.1.4 总结"></a>6.1.4 总结</h3><p><strong>三种模式用生活案例来理解</strong></p><ol><li><p>单Reactor单线程，前台接待员和服务员是同一个人，全程为顾客服务</p></li><li><p>单Reactor多线程，1个前台接待员，多个服务员，接待员只负责接待</p></li><li><p>主从Reactor多线程，多个前台接待员，多个服务员</p></li></ol><p><strong>Reactor模型具有如下优点</strong></p><ol><li><p>响应快，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的</p></li><li><p>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</p></li><li><p>扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源</p></li><li><p>复用性好，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性</p></li></ol><h2 id="6-2-代码分析"><a href="#6-2-代码分析" class="headerlink" title="6.2 代码分析"></a>6.2 代码分析</h2><p>话不多说，直接上代码吧！本次将所有处理模块都给拆分开来，一一进行说明</p><h3 id="6-2-1-Epoller-hpp"><a href="#6-2-1-Epoller-hpp" class="headerlink" title="6.2.1 Epoller.hpp"></a>6.2.1 Epoller.hpp</h3><p>首先是将对epoll的三个系统调用函数进行一定的封装，统一进行错误的判断处理。方便了其他模块的调用用；</p><p>这部分的代码非常简单，就只在注释里写一下解析吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> gsize = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CreateEpoller</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(gsize); <span class="comment">// 创建对应size的epfd</span></span><br><span class="line">        <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) <span class="comment">// 错误判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logMessage</span>(FATAL, <span class="string">&quot;epoll_create : %d : %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> epfd; <span class="comment">// 正确返回epfd</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">AddEvent</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> sock, <span class="type">uint32_t</span> event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">        ev.events = event; <span class="comment">// 设置event</span></span><br><span class="line">        ev.data.fd = sock;</span><br><span class="line">        <span class="comment">// 给对应的socket添加到epoll中</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sock, &amp;ev);</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>; <span class="comment">// 返回值是是否调用成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ModEvent</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> sock, <span class="type">uint32_t</span> event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">        ev.events = event;</span><br><span class="line">        ev.data.fd = sock;</span><br><span class="line">        <span class="comment">// 修改已有scoket的event</span></span><br><span class="line">        <span class="comment">// 该socket必须先用ADD添加，否则无法修改，会返回ENOENT错误</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, sock, &amp;ev);</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">DelEvent</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 删除指定socket</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, sock, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">LoopOnce</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event revs[], <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 单次wait的调用，从数组里面取回就绪的文件描述符</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(epfd, revs, num, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logMessage</span>(FATAL, <span class="string">&quot;epoll_wait : %d : %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-2-2-Sock-hpp"><a href="#6-2-2-Sock-hpp" class="headerlink" title="6.2.2 Sock.hpp"></a>6.2.2 Sock.hpp</h3><p>同select，见上文 <a href="#jump-select">3.2.1 socket</a> 部分；</p><h3 id="6-2-3-Log-hpp"><a href="#6-2-3-Log-hpp" class="headerlink" title="6.2.3 Log.hpp"></a>6.2.3 Log.hpp</h3><p>一个巨简单的日志类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTICE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WARNING 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FATAL 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *log_level[] = &#123;<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;NOTICE&quot;</span>, <span class="string">&quot;WARINING&quot;</span>, <span class="string">&quot;FATAL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGFILE <span class="string">&quot;serverTcp.log&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>():<span class="built_in">logFd</span>(<span class="number">-1</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">        logFd = <span class="built_in">open</span>(LOGFILE, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">        <span class="built_in">assert</span>(logFd != <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dup2</span>(logFd, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dup2</span>(logFd, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Log</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(logFd != <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fsync</span>(logFd);</span><br><span class="line">            <span class="built_in">close</span>(logFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> logFd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logMessage(DEBUG, &quot;%d&quot;, 10);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logMessage</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(level &gt;= DEBUG);</span><br><span class="line">    <span class="built_in">assert</span>(level &lt;= FATAL);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name = <span class="built_in">getenv</span>(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> logInfo[<span class="number">1024</span>];</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap, format);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vsnprintf</span>(logInfo, <span class="built_in">sizeof</span>(logInfo) - <span class="number">1</span>, format, ap);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(ap); <span class="comment">// ap = NULL</span></span><br><span class="line"></span><br><span class="line">    FILE *out = (level == FATAL) ? stderr : stdout;</span><br><span class="line">    <span class="built_in">fprintf</span>(out, <span class="string">&quot;%s | %u | %s | %s\n&quot;</span>,</span><br><span class="line">            log_level[level],</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>),</span><br><span class="line">            name == <span class="literal">nullptr</span> ? <span class="string">&quot;unknow&quot;</span> : name,</span><br><span class="line">            logInfo);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fflush</span>(out); <span class="comment">// 将C语言缓冲区中的数据刷新到OS</span></span><br><span class="line">    <span class="built_in">fsync</span>(<span class="built_in">fileno</span>(out));   <span class="comment">// 将OS中的数据尽快写入硬盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-4-TcpServer"><a href="#6-2-4-TcpServer" class="headerlink" title="6.2.4 TcpServer"></a>6.2.4 TcpServer</h3><p>这是我们reactor模型的重点</p><h4 id="1-Connection类"><a href="#1-Connection类" class="headerlink" title="1.Connection类"></a>1.Connection类</h4><p>这里先定义了一个Connection链接类，比较重要的是类里面有3个回调方法的指针。在Reactor中，我们用回调方法来替代了主执行流直接调用函数的方式。线程只需要接收到这个<code>Connection</code>对象，就可以用回调方法来实现对链接的数据处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using <span class="type">func_t</span> = <span class="built_in">std</span>::function&lt;<span class="type">int</span>(Connection *)&gt;;</span><br><span class="line">using <span class="type">callback_t</span> = <span class="built_in">std</span>::function&lt;<span class="type">int</span>(Connection *, <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> sock_;</span><br><span class="line">    TcpServer *R_;<span class="comment">// 主服务器的类指针</span></span><br><span class="line">    <span class="comment">// 自己的接受和发送缓冲区</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> inbuffer_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> outbuffer_;</span><br><span class="line">    <span class="comment">// 读、写、异常的回调函数</span></span><br><span class="line">    <span class="type">func_t</span> recver_; </span><br><span class="line">    <span class="type">func_t</span> sender_;</span><br><span class="line">    <span class="type">func_t</span> excepter_;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Connection(<span class="type">int</span> sock, TcpServer *r) : sock_(sock), R_(r)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">SetRecver</span><span class="params">(<span class="type">func_t</span> recver)</span> &#123; recver_ = recver; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">SetSender</span><span class="params">(<span class="type">func_t</span> sender)</span> &#123; sender_ = sender; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">SetExcepter</span><span class="params">(<span class="type">func_t</span> excepter)</span> &#123; excepter_ = excepter; &#125;</span><br><span class="line">    ~Connection() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-TcpServer成员变量"><a href="#2-TcpServer成员变量" class="headerlink" title="2.TcpServer成员变量"></a>2.TcpServer成员变量</h4><p>再来看看tcpserver的成员变量有什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">	<span class="comment">// 接收队列的长度</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> revs_num = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 1. 网络socket</span></span><br><span class="line">    <span class="type">int</span> listensock_;</span><br><span class="line">    <span class="comment">// 2. epoll的fd</span></span><br><span class="line">    <span class="type">int</span> epfd_;</span><br><span class="line">    <span class="comment">// 3. 将epoll和上层代码进行结合，已有链接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, Connection *&gt; connections_;</span><br><span class="line">    <span class="comment">// 4. 就绪事件列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">revs_</span>;</span></span><br><span class="line">    <span class="comment">// 5. 设置完整报文的处理回调方法</span></span><br><span class="line">    <span class="type">callback_t</span> cb_;</span><br></pre></td></tr></table></figure><h4 id="3-构造"><a href="#3-构造" class="headerlink" title="3.构造"></a>3.构造</h4><p>随后便是在构造函数中初始化这些成员变量，先是从<code>Sock.hpp</code>中获取到监听文件描述符，然后再通过Epoller类获取到epfd句柄，最后是将listensocket放入epoll的监听中；</p><p>这里的<code>std::bind</code>的作用，是将当前TcpServer的<code>this</code>指针绑定到<code>TcpServer::Accepter</code>函数的第一个参数上，否则在类外没有办法通过<code>Connection</code>类的回调指针来调用这个类的成员函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TcpServer(<span class="type">callback_t</span> cb, <span class="type">int</span> port = <span class="number">8080</span>) : cb_(cb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前监听的文件描述符及其事件</span></span><br><span class="line">    revs_ = new <span class="keyword">struct</span> epoll_event[revs_num]; </span><br><span class="line">    <span class="comment">// 网络功能</span></span><br><span class="line">    listensock_ = Sock::SocketInit();</span><br><span class="line">    Util::SetNonBlock(listensock_);</span><br><span class="line">    Sock::Bind(listensock_, port);</span><br><span class="line">    Sock::Listen(listensock_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路转接</span></span><br><span class="line">    epfd_ = Epoller::CreateEpoller();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加listensock匹配的connection</span></span><br><span class="line">    AddConnection(listensock_, EPOLLIN | EPOLLET,</span><br><span class="line">                  <span class="built_in">std</span>::bind(&amp;TcpServer::Accepter, this, <span class="built_in">std</span>::placeholders::_1), nullptr, nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-添加链接"><a href="#4-添加链接" class="headerlink" title="4.添加链接"></a>4.添加链接</h4><p>在<code>AddConnection</code>函数中，我们会将socket给添加到epfd中；如果这个epfd是使用了<code>EPOLLET</code>的ET模式，则还需要设置非阻塞；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">uint32_t</span> event, <span class="type">func_t</span> recver, <span class="type">func_t</span> sender, <span class="type">func_t</span> excepter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event &amp; EPOLLET)</span><br><span class="line">        Util::<span class="built_in">SetNonBlock</span>(sockfd);</span><br><span class="line">    <span class="comment">// 添加sockfd到epoll</span></span><br><span class="line">    Epoller::<span class="built_in">AddEvent</span>(epfd_, sockfd, event);</span><br><span class="line">    <span class="comment">// 将sockfd匹配的Connection也添加到当前的unordered_map中</span></span><br><span class="line">    Connection *conn = <span class="keyword">new</span> <span class="built_in">Connection</span>(sockfd, <span class="keyword">this</span>);</span><br><span class="line">    conn-&gt;<span class="built_in">SetRecver</span>(recver);</span><br><span class="line">    conn-&gt;<span class="built_in">SetSender</span>(sender);</span><br><span class="line">    conn-&gt;<span class="built_in">SetExcepter</span>(excepter);</span><br><span class="line"></span><br><span class="line">    connections_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(sockfd, conn));</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;添加新链接到connections成功: %d&quot;</span>, sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置非阻塞的代码很简单，在前文已经演示过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">SetNonBlock</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fl = fcntl(fd, F_GETFL);</span><br><span class="line">        fcntl(fd, F_SETFL, fl | O_NONBLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-析构"><a href="#5-析构" class="headerlink" title="5.析构"></a>5.析构</h4><p>在析构函数中，我们需要将listensocket和epfd两个文件描述符关闭，并析构掉链接数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (listensock_ != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">close</span>(listensock_);</span><br><span class="line">    <span class="keyword">if</span> (epfd_ != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">close</span>(epfd_);</span><br><span class="line">    <span class="keyword">delete</span>[] revs_;</span><br><span class="line">    <span class="comment">// 还需要析构掉连接池中尚存在的connection对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;c:connections_)&#123;</span><br><span class="line">        <span class="keyword">delete</span> c.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-获取新连接Accept"><a href="#6-获取新连接Accept" class="headerlink" title="6.获取新连接Accept"></a>6.获取新连接Accept</h4><p>在获取新连接这里，我们采用了一个死循环来获取。这是因为对于listensocket文件描述符而言，只要来了一个新链接，在ET模式下就会提示我们。但有可能会出现我们还没有来得及取走这个链接，就又来了一个新链接的情况（可以简化理解为一次性来了两个链接）</p><p>这时候因为ET的特性，我们就需要一次性取走所有链接；为了避免在Accept的时候，因为链接已经都被取走了而阻塞住，我们需要将listensocket设置为<strong>非阻塞</strong>；</p><blockquote><p>关于新链接为什么只关注读事件，在注释中有说明；</p></blockquote><p>对于listensocket来说，这个Accepter函数就是它的读事件回调，所以这个函数的参数也是一个<code>Connection *conn</code>对象，其是为了与其他事件处理函数统一（因为这个事件处理函数不在<code>Connection</code>类中，所以我们必须要获取一个对象才能访问到它的成员变量）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Accepter</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string clientip;</span><br><span class="line">        <span class="type">uint16_t</span> clientport = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sockfd = Sock::<span class="built_in">Accept</span>(conn-&gt;sock_, &amp;clientip, &amp;clientport);</span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收函数被事件打断了</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 本次数据没有准备好，可以理解为接收缓冲区空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">logMessage</span>(WARNING, <span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;get a new link: %d&quot;</span>, sockfd);</span><br><span class="line">        <span class="comment">// 注意：默认我们只设置了让epoll帮我们关心读事件，没有关心写事件</span></span><br><span class="line">        <span class="comment">// 为什么没有关注写事件：因为最开始的时候，写空间一定是就绪的！</span></span><br><span class="line">        <span class="comment">// 运行中可能才会存在写条件不满足 -- 写空间被写满了</span></span><br><span class="line">        <span class="built_in">AddConnection</span>(sockfd, EPOLLIN | EPOLLET,</span><br><span class="line">                      std::<span class="built_in">bind</span>(&amp;TcpServer::TcpRecver, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                      std::<span class="built_in">bind</span>(&amp;TcpServer::TcpSender, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                      std::<span class="built_in">bind</span>(&amp;TcpServer::TcpExcepter, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EAGAIN or EWOULDBLOCK</span><br><span class="line">	The socket is marked nonblocking and the receive operation would block, or a receive timeout had been set and the timeout expired before data was received.  POSIX.1 allows either error to be returned for this case, and does not require these constants to have the same value, so  a  portable application should check for both possibilities.</span><br></pre></td></tr></table></figure><h4 id="7-链接的事件处理函数"><a href="#7-链接的事件处理函数" class="headerlink" title="7.链接的事件处理函数"></a>7.链接的事件处理函数</h4><p>其他链接的三个处理函数分别是<code>TcpRever/TcpSender/TcpExcepter</code>;</p><p>首先，在处理某一个链接的时候，我们必须要保证这个链接在已有的map里面，否则代表这个链接已经被关闭或者异常退出了；同理，在异常和关闭链接的处理流程中，我们也需要将链接从map中删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsExists</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = connections_.<span class="built_in">find</span>(sock);</span><br><span class="line">    <span class="keyword">if</span> (iter == connections_.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读"><a href="#读" class="headerlink" title="读"></a>读</h5><p>对于读事件而言我们也是进行循环读取，该文件描述符也需要被设置为非阻塞。读取的内容拼接到该Connection对象的输入缓冲区string中；</p><p>在读取完毕后，我们需要在协议里面定义一个根据<strong>应用层协议字段</strong>来分离报文的函数（避免tcp的粘包问题），最终会得到一个string的数组，每个数组成员都是一个完整的报文；</p><p>最后，我们直接一个for循环，通过该tcpserver对象在初始化时候设置的<code>cb_</code>函数回调指针，来处理每一个报文（为每一个报文提供服务）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpRecver</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">recv</span>(conn-&gt;sock_, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[s] = <span class="number">0</span>;</span><br><span class="line">            conn-&gt;inbuffer_ += buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;client quit&quot;</span>);</span><br><span class="line">            conn-&gt;<span class="built_in">excepter_</span>(conn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) <span class="comment">// 接收事件被打断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 接收缓冲区空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 出错了</span></span><br><span class="line">                <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;recv error: %d:%s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                conn-&gt;<span class="built_in">excepter_</span>(conn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将本轮全部读取完毕</span></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line">    <span class="built_in">PackageSplit</span>(conn-&gt;inbuffer_, &amp;result);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;message : result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb_</span>(conn, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架的好处就在于，你可以单独实现不同协议的报文分离函数和数据服务函数，而不需要重写TcpServer的实现，相当于解耦；</p><h5 id="写"><a href="#写" class="headerlink" title="写"></a>写</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSender</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">send</span>(conn-&gt;sock_, conn-&gt;outbuffer_.<span class="built_in">c_str</span>(), conn-&gt;outbuffer_.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 去除已经成功发送的数据</span></span><br><span class="line">            conn-&gt;outbuffer_.<span class="built_in">erase</span>(<span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 写入操作被打断</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 写入缓冲区满了，没办法继续写</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK) <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 异常</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn-&gt;<span class="built_in">excepter_</span>(conn);</span><br><span class="line">                <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;send error: %d:%s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的写入如果遇到<code>(errno == EAGAIN || errno == EWOULDBLOCK)</code> 这两种情况，并不能确保输出缓冲区中的数据已经被全部写入了；有可能是写入缓冲区满了导致无法继续写入；</p><p>这种i情况下，我们需要判断<code>outbuffer</code>是否为空，如果不为空，则还是需要设置<code>EPOLLOUT</code>标记位，告知epoll继续帮我们关注写事件（这样epoll就会发信息告知Reactor，Reactor会重新调用写入函数，继续写入缓冲区的剩下数据）这个操作会在主执行流中进行统一判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主执行流</span></span><br><span class="line">conn-&gt;<span class="built_in">sender_</span>(conn); <span class="comment">// 主执行流调用发送函数</span></span><br><span class="line"><span class="comment">// 判断本次是否发完毕了，没有发完毕还需要继续关心读写</span></span><br><span class="line"><span class="keyword">if</span>(conn-&gt;outbuffer_.<span class="built_in">empty</span>()) conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">else</span> conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开或者关闭对于特定socket是否要关心读或者写</span></span><br><span class="line"><span class="comment">//- EnableReadWrite(sock, true, false); //只关心读</span></span><br><span class="line"><span class="comment">//- EnableReadWrite(sock, true, true);  //同时关心读写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnableReadWrite</span><span class="params">(<span class="type">int</span> sock, <span class="type">bool</span> readable, <span class="type">bool</span> writeable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> event = <span class="number">0</span>;</span><br><span class="line">    event |= (readable ? EPOLLIN : <span class="number">0</span>);</span><br><span class="line">    event |= (writeable ? EPOLLOUT : <span class="number">0</span>);</span><br><span class="line">    Epoller::<span class="built_in">ModEvent</span>(epfd_, sock, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>为了统一进行异常处理，在上文中当我们遇到读写出错的时候，都会调用这个函数；</p><p>在这个函数体内，会将链接从epoll中删除、关闭链接、释放connection对象、将文件描述符从map里面剔除；</p><p>需要注意的是，一定要先将socket从epoll里面剔除掉，再关闭socket！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpExcepter</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0. 判断有效性</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">IsExists</span>(conn-&gt;sock_)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有的服务器异常，都会被归类到这里</span></span><br><span class="line">    <span class="comment">// 1. 删除epoll的监看</span></span><br><span class="line">    Epoller::<span class="built_in">DelEvent</span>(epfd_, conn-&gt;sock_);</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;remove epoll event!&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. close</span></span><br><span class="line">    <span class="built_in">close</span>(conn-&gt;sock_);</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;close fd: %d&quot;</span>, conn-&gt;sock_);</span><br><span class="line">    <span class="comment">// 3. delete conn;</span></span><br><span class="line">    <span class="keyword">delete</span> connections_[conn-&gt;sock_];</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;delete connection object done&quot;</span>);</span><br><span class="line">    <span class="comment">// 4. erase conn;</span></span><br><span class="line">    connections_.<span class="built_in">erase</span>(conn-&gt;sock_);</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;erase connection from connections&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-运行"><a href="#8-运行" class="headerlink" title="8.运行"></a>8.运行</h4><p>对于TcpServer而言，一次的运行就是调用一次<code>epoll_wait</code>，再根据事件就绪的文件描述符，调用不同的事件处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = Epoller::<span class="built_in">LoopOnce</span>(epfd_, revs_, revs_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sock = revs_[i].data.fd;</span><br><span class="line">        <span class="type">uint32_t</span> revent = revs_[i].events;</span><br><span class="line">        <span class="comment">// 判断是否出现错误，如果出现了错误，那就把EPOLLIN和OUT都加上</span></span><br><span class="line">        <span class="comment">// 这样这个链接会进入下面的处理函数，并在处理函数中出现异常</span></span><br><span class="line">        <span class="comment">// 处理函数中出现异常回统一调用TcpExcpter函数</span></span><br><span class="line">        <span class="keyword">if</span>(revent &amp; EPOLLHUP) revent |= (EPOLLIN|EPOLLOUT);</span><br><span class="line">        <span class="keyword">if</span>(revent &amp; EPOLLERR) revent |= (EPOLLIN|EPOLLOUT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (revent &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsExists</span>(sock) &amp;&amp; connections_[sock]-&gt;recver_)</span><br><span class="line">                connections_[sock]-&gt;<span class="built_in">recver_</span>(connections_[sock]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当链接的写事件被激活的时候，在这里就会触发写事件的处理</span></span><br><span class="line">        <span class="comment">// 所以并不需要在recv里面主动调用写事件处理函数</span></span><br><span class="line">        <span class="comment">// 只需要告诉epoll让它帮我们监控写事件，那么就会在这里触发写操作</span></span><br><span class="line">        <span class="keyword">if</span> (revent &amp; EPOLLOUT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsExists</span>(sock) &amp;&amp; connections_[sock]-&gt;sender_)</span><br><span class="line">                connections_[sock]-&gt;<span class="built_in">sender_</span>(connections_[sock]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个服务器运行起来，就一直调用分发函数就OK啦~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Dispatcher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-5-主执行流"><a href="#6-2-5-主执行流" class="headerlink" title="6.2.5 主执行流"></a>6.2.5 主执行流</h3><p>对于主执行流而言，要做的就是获取到命令行参数的端口，然后创建tcpserver对象并绑定事件处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpServer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Service.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">usage</span><span class="params">(std::string process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;\nUsage: &quot;</span> &lt;&lt; process &lt;&lt; <span class="string">&quot; port\n&quot;</span></span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TcpServer <span class="title">svr</span><span class="params">(HandlerRequest, atoi(argv[<span class="number">1</span>]))</span></span>;</span><br><span class="line">    svr.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件处理函数可以做任意封装，来实现你自己想要的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">HandlerRequest</span><span class="params">(Connection *conn, std::string &amp;message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// beginhandler里面是具体的调用逻辑，calculator是本次事务处理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginHandler</span>(conn, message, calculator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是我们单个完整报文的处理函数，在tcprecver方法里面被调用了；</p><p>根据上文描述的调用方法，我们可以确定，这里传入来的<code>message</code>肯定是一个完整的应用层报文，我们只需要创建一个属于我们自己的协议和协议中的数据处理函数就OK了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BeginHandler</span><span class="params">(Connection *conn, std::string &amp;message, <span class="type">service_t</span> service)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// message一定是一个完整的报文，因为我们已经对它进行了解码</span></span><br><span class="line">    Request req;</span><br><span class="line">    <span class="comment">// 反序列化，进行处理的问题</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Parser</span>(message, &amp;req))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 写回错误消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 可以直接关闭连接</span></span><br><span class="line">        <span class="comment">// conn-&gt;excepter_(conn);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    Response resp = <span class="built_in">service</span>(req);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; req.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; req.op &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; req.y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; resp.code &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; resp.result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    std::string sendstr;</span><br><span class="line">    <span class="built_in">Serialize</span>(resp, &amp;sendstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完毕的结果，发送回给client</span></span><br><span class="line">    conn-&gt;outbuffer_ += sendstr;</span><br><span class="line">    conn-&gt;<span class="built_in">sender_</span>(conn);</span><br><span class="line">    <span class="keyword">if</span>(conn-&gt;outbuffer_.<span class="built_in">empty</span>()) conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">else</span> conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- end ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-6-协议和数据处理"><a href="#6-2-6-协议和数据处理" class="headerlink" title="6.2.6 协议和数据处理"></a>6.2.6 协议和数据处理</h3><p>下面提供一个最基础的计算器协议，这个协议的好处是我们可以用telnet就模拟出请求，无需写一个tcp客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 操作符 y#</span><br></pre></td></tr></table></figure><p>这个协议中，每个有效数据中都会带上一个空格，并以<code>#</code>作为单个报文的结尾；</p><p>响应和请求的结构体格式也非常简单，响应里面是状态码和计算结果；我们在协议中添加序列化和反序列化函数就可以将响应和请求结构体转成字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Response</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEP <span class="string">&#x27;#&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEP_LEN sizeof(SEP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF <span class="string">&quot;\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF_LEN strlen(CRLF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE_LEN strlen(SPACE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离独立报文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PackageSplit</span><span class="params">(std::string &amp;inbuffer, std::vector&lt;std::string&gt; *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="type">size_t</span> pos = inbuffer.<span class="built_in">find</span>(SEP);</span><br><span class="line">        <span class="keyword">if</span> (pos == std::string::npos)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        result-&gt;<span class="built_in">push_back</span>(inbuffer.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">        inbuffer.<span class="built_in">erase</span>(<span class="number">0</span>, pos + SEP_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Response</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Parser</span><span class="params">(std::string &amp;in, Request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1 + 1, 2 * 4, 5 * 9, 6 *1</span></span><br><span class="line">    std::<span class="type">size_t</span> spaceOne = in.<span class="built_in">find</span>(SPACE);</span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == spaceOne)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    std::<span class="type">size_t</span> spaceTwo = in.<span class="built_in">rfind</span>(SPACE);</span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == spaceTwo)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    std::string dataOne = in.<span class="built_in">substr</span>(<span class="number">0</span>, spaceOne);</span><br><span class="line">    std::string dataTwo = in.<span class="built_in">substr</span>(spaceTwo + SPACE_LEN);</span><br><span class="line">    std::string oper = in.<span class="built_in">substr</span>(spaceOne + SPACE_LEN, spaceTwo - (spaceOne + SPACE_LEN));</span><br><span class="line">    <span class="keyword">if</span> (oper.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转成内部成员</span></span><br><span class="line">    req-&gt;x = <span class="built_in">atoi</span>(dataOne.<span class="built_in">c_str</span>());</span><br><span class="line">    req-&gt;y = <span class="built_in">atoi</span>(dataTwo.<span class="built_in">c_str</span>());</span><br><span class="line">    req-&gt;op = oper[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Serialize</span><span class="params">(<span class="type">const</span> Response &amp;resp, std::string *out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string ec = std::<span class="built_in">to_string</span>(resp.code);</span><br><span class="line">    std::string res = std::<span class="built_in">to_string</span>(resp.result);</span><br><span class="line"></span><br><span class="line">    *out = ec;</span><br><span class="line">    *out += SPACE;</span><br><span class="line">    *out += res;</span><br><span class="line">    *out += CRLF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>service.hpp</code>里面则是数据处理的计算函数，通过我们传入的请求，计算出结构并构造响应返回给用户</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Protocol.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="type">service_t</span> = std::function&lt;<span class="built_in">Response</span> (<span class="type">const</span> Request &amp;req)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Response <span class="title">calculator</span><span class="params">(<span class="type">const</span> Request &amp;req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Response resp = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (req.op)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        resp.result = req.x + req.y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        resp.result = req.x - req.y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        resp.result = req.x * req.y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">    &#123; <span class="comment">// x_ / y_</span></span><br><span class="line">        <span class="keyword">if</span> (req.y == <span class="number">0</span>)</span><br><span class="line">            resp.code = <span class="number">-1</span>; <span class="comment">// -1. 除0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resp.result = req.x / req.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">    &#123; <span class="comment">// x_ / y_</span></span><br><span class="line">        <span class="keyword">if</span> (req.y == <span class="number">0</span>)</span><br><span class="line">            resp.code = <span class="number">-2</span>; <span class="comment">// -2. 模0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resp.result = req.x % req.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        resp.code = <span class="number">-3</span>; <span class="comment">// -3: 非法操作符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-7-测试"><a href="#6-2-7-测试" class="headerlink" title="6.2.7 测试"></a>6.2.7 测试</h3><p>可以看到，我们的服务启动了之后，成功接收了一个链接，并计算出了我们发送的结果</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/5e164406ab4e280265a7fcd8fdc3de67.png" alt="image-20230828115411040"></p><p>多个链接也不在话下！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/58a989acdf95c2dc2c89a1677f8a4d56.png" alt="image-20230828115525101"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>多路转接这部分是linux服务器最重要的一部分知识，因为大部分服务器都抛弃了最传统的一个线程维护一个链接这样的方式，而采用了多路转接来实现对大量进程的维护；</p><p>本文是学习阶段的产物，有错误在所难免，请大佬们指教！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/56eecd58cac3b6593f83998c9f30eb4b.gif" alt="QQ图片20220413084241"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/3390191280/">https://blog.musnow.top/posts/3390191280/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://img.musnow.top/i/2023/08/748d3a20ba69bb3b3671f5b344cba650.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/73383828/" title="【API】API的各种分类详解"><img class="cover" src="/img/bg/gm17.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【API】API的各种分类详解</div></div></a></div><div class="next-post pull-right"><a href="/posts/2628258650/" title="【C++】构造函数和初始化列表的性能差距"><img class="cover" src="/img/bg/gm10.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【C++】构造函数和初始化列表的性能差距</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/656771008/" title="【Linux】使用腾讯云搭建CentOS的Linux编程学习环境，实现多用户使用同一个云服务器"><img class="cover" src="/img/bg/gm6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-06</div><div class="title">【Linux】使用腾讯云搭建CentOS的Linux编程学习环境，实现多用户使用同一个云服务器</div></div></a></div><div><a href="/posts/3785030062/" title="【Linux】进程概念"><img class="cover" src="/img/bg/gm24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-31</div><div class="title">【Linux】进程概念</div></div></a></div><div><a href="/posts/977518181/" title="【Linux】环境变量"><img class="cover" src="/img/bg/gm18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-05</div><div class="title">【Linux】环境变量</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">293</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%AB%98%E7%BA%A7IO"><span class="toc-text">1.高级IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.1 五种IO模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">1.2 阻塞和非阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">1.3 异步与同步通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-fcntl"><span class="toc-text">2.fcntl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.1 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">2.2 设置非阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-stdin%E6%B5%8B%E8%AF%95"><span class="toc-text">2.3 stdin测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bselect"><span class="toc-text">3.多路转接之select</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%AE%A4%E8%AF%86select"><span class="toc-text">3.1 认识select</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-timeval"><span class="toc-text">3.1.1 timeval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-fd-set"><span class="toc-text">3.1.2 fd_set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-nfds"><span class="toc-text">3.1.3 nfds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">3.1.4 返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AE%9E%E4%BE%8B"><span class="toc-text">3.2 实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-socket"><span class="toc-text">3.2.1 socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">3.2.2 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E7%9B%91%E5%90%AC"><span class="toc-text">3.2.3 监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E6%89%8B%E8%84%9A%E6%9E%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">3.2.4 手脚架测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E5%A4%84%E7%90%86%E6%96%B0%E8%BF%9E%E6%8E%A5"><span class="toc-text">3.2.5 处理新连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6-%E5%A4%84%E7%90%86%E5%B7%B2%E6%9C%89%E9%93%BE%E6%8E%A5"><span class="toc-text">3.2.6 处理已有链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-7-%E5%AE%9E%E6%B5%8B"><span class="toc-text">3.2.7 实测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-socket%E5%B0%B1%E7%BB%AA%E6%9D%A1%E4%BB%B6"><span class="toc-text">3.3 socket就绪条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E8%AF%BB%E5%B0%B1%E7%BB%AA"><span class="toc-text">3.3.1 读就绪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%86%99%E5%B0%B1%E7%BB%AA"><span class="toc-text">3.3.2 写就绪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%BC%82%E5%B8%B8%E5%B0%B1%E7%BB%AA"><span class="toc-text">3.3.3 异常就绪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-select%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">3.4 select的特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E4%B9%8Bpoll"><span class="toc-text">4.多路转接之poll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-text">4.1 函数原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%8F%82%E6%95%B0"><span class="toc-text">4.1.1 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">4.1.2 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E4%BA%8B%E4%BB%B6"><span class="toc-text">4.1.3 事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-poll%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4.2 poll优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E4%BC%98%E7%82%B9"><span class="toc-text">4.2.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">4.2.2 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%9C%8B%E7%9C%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">4.3 看看示例代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-epoll"><span class="toc-text">5.epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%8E%A5%E5%8F%A3"><span class="toc-text">5.1 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-epoll-create"><span class="toc-text">5.1.1 epoll_create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-epoll-ctl"><span class="toc-text">5.1.2 epoll_ctl</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-text">事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-epoll-wait"><span class="toc-text">5.1.3 epoll_wait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">5.2 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B%E6%B5%81%E7%A8%8B"><span class="toc-text">5.2.1 从源码看流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-PSH%E6%A0%87%E8%AE%B0%E4%BD%8D"><span class="toc-text">5.2.2 PSH标记位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-epoll%E4%BC%98%E7%82%B9"><span class="toc-text">5.2.3 epoll优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.3 工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91-LT"><span class="toc-text">5.3.1 水平触发 LT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91-ET"><span class="toc-text">5.3.2 边缘触发 ET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-LT%E5%92%8CET%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5.3.3 LT和ET的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-ET%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">5.3.4 ET和非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5-epoll%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5.3.5 epoll的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94"><span class="toc-text">5.4 惊群效应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">5.4.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">5.4.2 多线程环境下解决办法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">5.4.3 多进程下解决办法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-%E5%86%85%E6%A0%B8%E8%A7%A3%E5%86%B3%E4%BA%86%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94%E4%BA%86%E5%90%97"><span class="toc-text">5.4.4 内核解决了惊群效应了吗</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Reactor%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.Reactor模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AFReactor%EF%BC%9F"><span class="toc-text">6.1 什么是Reactor？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.1.1 主从Reactor多线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">6.1.2 单Reactor多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">6.1.3 单Reactor单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-%E6%80%BB%E7%BB%93"><span class="toc-text">6.1.4 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">6.2 代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-Epoller-hpp"><span class="toc-text">6.2.1 Epoller.hpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-Sock-hpp"><span class="toc-text">6.2.2 Sock.hpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-Log-hpp"><span class="toc-text">6.2.3 Log.hpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-TcpServer"><span class="toc-text">6.2.4 TcpServer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Connection%E7%B1%BB"><span class="toc-text">1.Connection类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TcpServer%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">2.TcpServer成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%84%E9%80%A0"><span class="toc-text">3.构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B7%BB%E5%8A%A0%E9%93%BE%E6%8E%A5"><span class="toc-text">4.添加链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9E%90%E6%9E%84"><span class="toc-text">5.析构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%8E%B7%E5%8F%96%E6%96%B0%E8%BF%9E%E6%8E%A5Accept"><span class="toc-text">6.获取新连接Accept</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E9%93%BE%E6%8E%A5%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">7.链接的事件处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB"><span class="toc-text">读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99"><span class="toc-text">写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-text">异常</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%BF%90%E8%A1%8C"><span class="toc-text">8.运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5-%E4%B8%BB%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-text">6.2.5 主执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-6-%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-text">6.2.6 协议和数据处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-7-%E6%B5%8B%E8%AF%95"><span class="toc-text">6.2.7 测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-end"><span class="toc-text">The end</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3894841472/" title="【Hexo】在中英文之间添加空格"><img src="/img/bg/gm12.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Hexo】在中英文之间添加空格"></a><div class="content"><a class="title" href="/posts/3894841472/" title="【Hexo】在中英文之间添加空格">【Hexo】在中英文之间添加空格</a><time datetime="2023-12-10T07:32:14.000Z" title="发表于 2023-12-10 15:32:14">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3528013149/" title="【Nginx】NGINX 配置避免 IP 访问时证书暴露域名"><img src="https://img.musnow.top/i/2023/12/035ad572d3638bb917c07e53e24c9575.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Nginx】NGINX 配置避免 IP 访问时证书暴露域名"></a><div class="content"><a class="title" href="/posts/3528013149/" title="【Nginx】NGINX 配置避免 IP 访问时证书暴露域名">【Nginx】NGINX 配置避免 IP 访问时证书暴露域名</a><time datetime="2023-12-09T09:12:55.000Z" title="发表于 2023-12-09 17:12:55">2023-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2029711168/" title="【Nginx】nginx通过配置文件阻止海外ip访问"><img src="/img/bg/gm18.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Nginx】nginx通过配置文件阻止海外ip访问"></a><div class="content"><a class="title" href="/posts/2029711168/" title="【Nginx】nginx通过配置文件阻止海外ip访问">【Nginx】nginx通过配置文件阻止海外ip访问</a><time datetime="2023-12-09T08:12:55.000Z" title="发表于 2023-12-09 16:12:55">2023-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3595872827/" title="【图床】删除对象存储桶前一定要检查！"><img src="/img/bg/gm13.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【图床】删除对象存储桶前一定要检查！"></a><div class="content"><a class="title" href="/posts/3595872827/" title="【图床】删除对象存储桶前一定要检查！">【图床】删除对象存储桶前一定要检查！</a><time datetime="2023-12-09T02:32:14.000Z" title="发表于 2023-12-09 10:32:14">2023-12-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/bg/mothra.png)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 慕雪年华</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="https://img.shields.io/badge/-SITEMAP-00CDCD" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%872023007189-red" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a><a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.staticfile.org/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.staticfile.org/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script id="click-heart" src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>