<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【C++】模板：了解泛型编程 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本篇是C++模板学习的一些笔记"><meta property="og:type" content="article"><meta property="og:title" content="【C++】模板：了解泛型编程"><meta property="og:url" content="https://blog.musnow.top/posts/2940029419/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="本篇是C++模板学习的一些笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm7.png"><meta property="article:published_time" content="2022-06-27T02:50:46.000Z"><meta property="article:modified_time" content="2023-07-29T01:18:13.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm7.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/2940029419/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【C++】模板：了解泛型编程",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-07-29 09:18:13"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">284</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm7.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【C++】模板：了解泛型编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-27T02:50:46.000Z" title="发表于 2022-06-27 10:50:46">2022-06-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-29T01:18:13.000Z" title="更新于 2023-07-29 09:18:13">2023-07-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%81%87%E8%A7%81C/">遇见C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【C++】模板：了解泛型编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本篇是C++<strong>模板</strong>学习的一些笔记</p><span id="more"></span><p>[TOC]</p><h1 id="1-了解泛型编程"><a href="#1-了解泛型编程" class="headerlink" title="1.了解泛型编程"></a>1.了解泛型编程</h1><p>泛型编程，故如其名，是一个泛化的编程方式。其实现原理为程序员编写一个函数&#x2F;类的代码示例，让编译器去填补出不同的函数实现</p><p>就好比<strong>活字印刷术</strong>，可以灵活调整印刷的板块和内容，比只能固定印刷某一个内容的雕版印刷术效率更高，也让印刷术由此得到了更广泛的应用。</p><p><img src="https://img.musnow.top/i/2023/02/202206270906537.png" alt="image-20220627090604430"></p><p>在C++中，<strong>函数重载和模板</strong>的出现，让泛型编程得到了实际的应用。其中模板，就是类似活字印刷术一样的存在。</p><p>我们写一个模板，编译器帮我们按照我们写的模板的方式，实例化成不同的函数。相当于替代了一部分操作，节省了代码量。</p><h1 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2.函数模板"></a>2.函数模板</h1><p>八八了那么多没用的，让我们来看看函数模板的语法实现吧</p><h2 id="2-1-简单示例"><a href="#2-1-简单示例" class="headerlink" title="2.1 简单示例"></a>2.1 简单示例</h2><p>下面是一个最简单的交换函数的例子，通过标明模板参数<code>T</code>，让编译器自动识别函数传参，推测并实例化出不同的函数，供程序来调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; left,T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>typename</code>是定义模板的<strong>关键字</strong>，我们可以使用<code>class</code>来替代，但<strong>不能</strong>使用<code>struct</code></p><blockquote><p>据我查询到的资料，在模板的定义中使用<code>typename/class</code>是没有区别的</p></blockquote><p><img src="https://img.musnow.top/i/2023/02/202206270911869.png" alt="image-20220627091101814"></p><p>可以看到，编译器成功调用了<code>Swap</code>函数，成功交换了int类型和double类型；</p><h2 id="2-2-多个模板参数"><a href="#2-2-多个模板参数" class="headerlink" title="2.2 多个模板参数"></a>2.2 多个模板参数</h2><p>如果我们尝试把int和double同时传参给这个函数，会发生什么呢？</p><p><img src="https://img.musnow.top/i/2023/02/202206270913350.png" alt="image-20220627091355313"></p><p>编译器会报错，表示<code>模板参数T不明确</code>，因为我们在函数模板里面对两个参数的说明都是T，编译器就认为这两个参数必须是<strong>相同的类型</strong>，而传入的int和double并不相同，于是就报错了。</p><p>这时候我们有几种解决方法：</p><ul><li>首先是将double强转为int（反过来亦可）</li></ul><p><img src="https://img.musnow.top/i/2023/02/202206270917794.png" alt="image-20220627091752759"></p><p>你会发现还是不行，那是因为强转并不支持用double引用int。所以我们把函数传参中的引用去掉，即可正常调用这个函数（暂且不提<strong>传引用和传值</strong>的区别）</p><p><img src="https://img.musnow.top/i/2023/02/202206270933849.png" alt="image-20220627093341796"></p><ul><li>使用多个模板参数</li></ul><p>和函数传参类似，我们也可以设置多个模板参数</p><p>在下图中，我使用<code>typeid</code>关键字来打印模板参数T1和T2的类型。</p><blockquote><p>使用<code>typeid</code>需要包含头文件<code>#include &lt;typeinfo&gt;</code></p></blockquote><p><img src="https://img.musnow.top/i/2023/02/202206270928130.png" alt="image-20220627092844081"></p><p>可以看到，实际上函数在调用这个模板的时候，已经实例化了这个函数（即替换模板参数为正确参数类型）这时候在后台处理的时候，其实Show函数已经实例化为了下面这个样子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">int</span> left, <span class="type">double</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(left).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(right).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-模板实例化"><a href="#2-3-模板实例化" class="headerlink" title="2.3 模板实例化"></a>2.3 模板实例化</h2><p>上面的方式，是编译器自动帮我们实例化模板参数。在实际使用中，我们还可以自己指定实例化为什么类型</p><ul><li>利用强制类型转换</li><li>使用<code>&lt;int&gt;</code>直接指定实例化为int类型（显式实例化）</li></ul><p><img src="https://img.musnow.top/i/2023/02/202206270944791.png" alt="image-20220627094408745"></p><p>使用第二种方式的时候，编译器会对另外一个不匹配的参数进行<strong>隐式类型转换</strong>。如果转换不成功，或者该参数不支持转换，则会报错。</p><p>另外注意的是，函数模板参数T同样可以用来作为返回值，但是<strong>不能通过返回值来推断参数T的类型</strong>。比如下面这个函数，我们在使用的时候就需要<code>直接&lt;int&gt;指定</code>模板参数T，而不能写一个 <code>int* ptr=test(10)</code>，让编译器通过 “返回值是<code>int*</code>接收的，所以函数模板参数T是int”来推断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">test</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> T[num];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">test</span>(<span class="number">10</span>);<span class="comment">//错误</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">test</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);<span class="comment">//正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模板支持给予类型缺省值"><a href="#函数模板支持给予类型缺省值" class="headerlink" title="函数模板支持给予类型缺省值"></a>函数模板支持给予类型缺省值</h3><p>当一个参数不确定的时候，函数模板的参数是支持给予缺省值的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递一个类型做为缺省值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T</span>=<span class="type">char</span>&gt;</span><br><span class="line"><span class="function">T* <span class="title">test</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> T[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这样，当我们没有直接指定的时候，编译器就会将T作为char类型，返回一个num大小的char（一个字节）的空间</p><p>注意：当有多个模板参数时，缺省值需要从右往左给，否则会出现类型匹配不上而无法调用的问题；这点和函数参数缺省值相同。</p><h3 id="函数模板中函数的传参也支持缺省值"><a href="#函数模板中函数的传参也支持缺省值" class="headerlink" title="函数模板中函数的传参也支持缺省值"></a>函数模板中函数的传参也支持缺省值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(T1 left, T1 right=<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Add temp &quot;</span>&lt;&lt; <span class="built_in">typeid</span>(left).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(right).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Add</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，编译器会正确调用该函数模板</p><p><img src="https://img.musnow.top/i/2023/02/202206271042131.png" alt="image-20220627104218098"></p><h2 id="2-4-模板和普通函数同时存在（重载）"><a href="#2-4-模板和普通函数同时存在（重载）" class="headerlink" title="2.4 模板和普通函数同时存在（重载）"></a>2.4 模板和普通函数同时存在（重载）</h2><p>以Add函数为例，在函数模板存在的同时，我们还可以单独写一个int类型的add函数。这都归功于<strong>函数重载</strong>的存在。</p><p>同时，我们还可以使用<code>&lt;int&gt;</code>来指定函数模板重载为已存在的Add函数。因为本质上这两个函数是不同的，并不会冲突。</p><p><img src="https://img.musnow.top/i/2023/02/202206271043654.png" alt="image-20220627104304580"></p><p>函数在调用的时候，<strong>首先会去调用已经存在的函数</strong>。当参数和已存在的函数不匹配时，才会调用函数模板；</p><p>而有<code>&lt;int&gt;</code>直接指定了模板参数类型的函数调用，自然也是会调用函数模板实例化出来的函数。</p><h2 id="2-5-函数模板不支持定义和声明分离"><a href="#2-5-函数模板不支持定义和声明分离" class="headerlink" title="2.5 函数模板不支持定义和声明分离"></a>2.5 函数模板不支持定义和声明分离</h2><p>一般情况下，我们都会在<strong>头文件</strong>中声明函数，在<strong>另外一个源文件</strong>中定义函数。</p><p>但是模板是不支持这么做的！严谨来说，是不支持在不同文件中声明和定义分离，同一个文件是可以的。</p><p>分了两个文件的时候，编译器会报错 <code>链接错误</code>，比如如下VS2019的报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error LNK2019:无法解析的外部符号……</span><br></pre></td></tr></table></figure><p>所以我们需要将函数模板的声明和定义放在一个头文件中。在部分使用场景，会使用<code>.hpp</code>后缀，来表示这个头文件是包含了函数定义的（即<code>.h 和 .cpp</code>的集合体）。</p><blockquote><p><strong>c&#x2F;cpp</strong> 中对头文件的包含并没有硬性的后缀要求，我们设置为 <code>.h/.hpp</code> 只是一个约定。</p></blockquote><p>需要注意，这并不是一个硬性要求，你也可以直接使用<code>.h</code>，并将声明和定义放入其中。</p><ul><li>模板为什么不支持定义和声明分离？</li></ul><p>因为单独的<code>.h/.hpp</code>声明会在源文件顶部被编译器展开，而此时函数模板就会开始正常推演参数，并<code>call 函数名</code>；</p><p>但编译器并没有找到这个函数名所对应函数的具体实现，而在另外一个文件中（实现在另外一个函数里面），编译器又不知道你这个函数模板的声明需要<strong>实例化成什么类型的函数</strong>，那也没有办法成功进行实例化。</p><p>最终就导致<code>call</code>了一个<strong>没有地址</strong>的函数，链接的时候肯定就找不到函数的地址，产生了符号表的<code>链接错误</code>；</p><ul><li>有无解决办法？</li></ul><p>其实是有的，我们可以在模板函数定义的<code>.cpp</code>中对我们需要使用的函数进行显式实例化指定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(T1 left, T1 right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源文件</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">//template不能被省略！每次都须写上</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(T1 left, T1 right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; left + right &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在源文件中显式实例化</span></span><br><span class="line"><span class="comment">//这就相当于告诉编译器这两个碗需要装什么菜</span></span><br><span class="line"><span class="comment">//编译器才能正确帮我们实例化这个函数，并成功编译链接</span></span><br><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> left, <span class="type">int</span> right);</span><br><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">Add</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span> left, <span class="type">double</span> right);</span><br></pre></td></tr></table></figure><p>显式实例化需要对我们要用的所有类型的函数模板进行实例化，比如你需要用double类型，只显示实例化了int类型是不行的，依旧会报错。</p><p>这就好比你只告诉厨子做10个人的饭，结果来了20个人。那剩下的10个人肯定是吃不上饭的。因为你没有告诉厨子（编译器）到底要来多少个人干饭。</p><p>这样感觉非常多余……对吧？写多了还容易眼花。所以还是老老实实把声明和定义放在<strong>同一个文件</strong>里面吧！</p><h1 id="3-类模板"><a href="#3-类模板" class="headerlink" title="3.类模板"></a>3.类模板</h1><p>类模板的基本形式如下，这里作为一个小区分，我用<code>class</code>来当作模板参数名。实际上<code>typename</code>也是可以的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, ...&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 类内成员定义</span></span><br><span class="line">&#125;;     </span><br></pre></td></tr></table></figure><h2 id="3-1-简单示例"><a href="#3-1-简单示例" class="headerlink" title="3.1 简单示例"></a>3.1 简单示例</h2><p>下面用一个非常简单的<strong>顺序表</strong>代码来演示一下类模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>(<span class="type">int</span> capacity = <span class="number">10</span>)</span><br><span class="line">        : _a(<span class="keyword">new</span> T[capacity])</span><br><span class="line">        , _size(<span class="number">0</span>)</span><br><span class="line">        , _capa(capacity)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">List</span>();</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line">        <span class="keyword">return</span> _a[pos];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _a;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    <span class="type">int</span> _capa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中函数放在类外进行定义时，需要加模板参数列表</span></span><br><span class="line"><span class="comment">//还必须要指定类的声明作为函数的作用域</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">List&lt;T&gt;::~<span class="built_in">List</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] _a;</span><br><span class="line">    _size = _capa = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过显式实例化类模板的方式，我们成功让这个类模板变成了两个不同类型的顺序表</p><p><img src="https://img.musnow.top/i/2023/02/202206271029782.png" alt="image-20220627102953666"></p><h2 id="3-2-成员函数声明和定义分离"><a href="#3-2-成员函数声明和定义分离" class="headerlink" title="3.2 成员函数声明和定义分离"></a>3.2 成员函数声明和定义分离</h2><p>其中需要注意的是析构函数，声明和定义分离的时候（同一文件），在定义的时候也需要加上模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板中函数放在类外进行定义时，需要加模板参数列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">List&lt;T&gt;::~<span class="built_in">List</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] _a;</span><br><span class="line">    _size = _capa = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人觉得这样也非常麻烦，既然模板最好是声明和定义放在<strong>同一个文件</strong>，那还不如直接将类的成员函数直接定义到类内部。多省事！</p><ul><li>如果是类的声明和定义放在<strong>不同文件</strong>中，显式实例化方式如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &lt;<span class="type">double</span>&gt;;</span><br></pre></td></tr></table></figure><p>需要什么类型的类，就得实例化这个类型。</p><blockquote><p>以下是模板进阶的内容，源码仓库 <a target="_blank" rel="noopener" href="https://gitee.com/musnow/learn_cpp_code/tree/master/cpp/23-07-28%20%E6%A8%A1%E6%9D%BF%E8%BF%9B%E9%98%B6">GITEE</a></p></blockquote><h1 id="4-非类型模板参数"><a href="#4-非类型模板参数" class="headerlink" title="4.非类型模板参数"></a>4.非类型模板参数</h1><p>上面我们接触到的，都是类型模板参数。还有另外一种模板参数是非类型模板参数。</p><ul><li>类型模板参数：给的模板参数是一个类型</li><li>非类型模板参数：给的模板参数是一个常量</li></ul><p>比如看看<a target="_blank" rel="noopener" href="https://legacy.cplusplus.com/reference/array/array/">stl中的array容器</a>，它的声明是下面这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N &gt; <span class="keyword">class</span> <span class="title class_">array</span>;</span><br></pre></td></tr></table></figure><p>其中第二个参数 <code>size_t N</code>就是一个非类型模板参数</p><h2 id="4-1-什么场景需要非类型模板参数？"><a href="#4-1-什么场景需要非类型模板参数？" class="headerlink" title="4.1 什么场景需要非类型模板参数？"></a>4.1 什么场景需要非类型模板参数？</h2><p>用一个栈来作为栗子，<strong>不考虑动态内存管理</strong>。我们可以通过<code>define</code>一个栈的空间大小，来实例化一个int类型的栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _st[STACK_SIZE];</span><br><span class="line">    <span class="type">int</span> _top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了让这个栈能自适应的实例化出不同<strong>成员类型</strong>的栈，C++提供了类型模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="comment">// 模板栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack2</span></span><br><span class="line">&#123;</span><br><span class="line">    T _st[STACK_SIZE];</span><br><span class="line">    <span class="type">int</span> _top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个栈实例化的方式是下面这样，其中第一个栈是已经确定了是int类型，而第二个栈可以被实例化出任何我们想要的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack1 st1;</span><br><span class="line">    Stack2&lt;<span class="type">int</span>&gt; st2;</span><br><span class="line">    Stack2&lt;<span class="type">double</span>&gt; st3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，即便已经有了模板参数，我们还是没有办法做到，让其中一个栈是100个成员的空间，另外一个栈是30的空间；这是因为空间在初始化的时候就已经被<code>define</code>替换了，并开辟了定长的空间。</p><p><strong>动态内存管理</strong>的时候，是可以通过构造函数来解决到底实例化多少空间的问题。但现在假设我们需要的就是一个定长的栈，那么动态内存管理就无能为力了。</p><p>这时候，<strong>非类型模板参数</strong>就出场了，在这种场景下，我们可以通过模板l传递参数，来确定栈内空间的大小；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack3</span></span><br><span class="line">&#123;</span><br><span class="line">    T _st[N];</span><br><span class="line">    <span class="type">int</span> _top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就给了我们在使用模板实例化对象的时候，将一些参数像函数传参一样提供给这个类，作为其实例化的地基的能力</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack3&lt;<span class="type">int</span>, <span class="number">30</span>&gt; st4;</span><br><span class="line">Stack3&lt;<span class="type">double</span>, <span class="number">100</span>&gt; st5;</span><br></pre></td></tr></table></figure><p>编译通过无报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o test -std=c++11</span><br></pre></td></tr></table></figure><p>将成员变量设置成公有，用<code>sizeof</code>能观察到这两个数组的大小和预期相符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(st4._st) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(st5._st) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">120</span><br><span class="line">800</span><br></pre></td></tr></table></figure><h3 id="非类型模板参数不可被修改"><a href="#非类型模板参数不可被修改" class="headerlink" title="非类型模板参数不可被修改"></a>非类型模板参数不可被修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify_n</span><span class="params">(<span class="type">int</span> n = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        N = n; <span class="comment">// 尝试修改模板参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T _st[N];</span><br><span class="line">    <span class="type">int</span> _top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们添加了一个修改N的函数，并尝试调用它的时候，编译会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp: In instantiation of ‘void Stack3&lt;T, N&gt;::modify_n(int) [with T = int; long unsigned int N = 30]’:</span><br><span class="line">test.cpp:45:21:   required from here</span><br><span class="line">test.cpp:28:11: error: lvalue required as left operand of assignment</span><br><span class="line">         N = n; // 尝试修改模板参数</span><br><span class="line">         ~~^~~</span><br><span class="line">make: *** [makefile:2: test] Error 1</span><br></pre></td></tr></table></figure><p>报错的意思是 <code>=</code> 操作符需要一个可被修改的左值。这便告诉我们，非类型模板参数是一个const常量，是不能被修改的。</p><h2 id="4-2-STL的Array"><a href="#4-2-STL的Array" class="headerlink" title="4.2 STL的Array"></a>4.2 STL的Array</h2><p>回过头来看stl的array，此时就能理解这个非类型模板参数的作用了；</p><p>在声明中，第二个模板参数已经指定了参数类型为<code>size_t</code>，此时需要给N传入的值就是一个确定的无符号整数，作为array容器的空间大小；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N &gt; <span class="keyword">class</span> <span class="title class_">array</span>;</span><br></pre></td></tr></table></figure><p>因为array是一个固定大小的数组容器，并不像vector那样可以实现扩容操作。</p><p>而且<code>array</code>开辟的空间在栈上，<code>vector</code>在堆上（堆的空间大小远大于栈）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays are fixed-size sequence containers</span><br></pre></td></tr></table></figure><p>那么<code>array</code>这个容器的作用是什么呢？</p><ul><li>我们确定知道需要使用多少长度的场景</li><li><code>array</code>对标的应该是原生数组，和<code>vector</code>相比，其优势基本没有。</li><li><code>array</code>相比直接使用定长数组，其封装了迭代器，能使用迭代器来进行参数的访问。能保证array和其他STL容器访问的代码的统一性。</li><li><code>array</code>因为有封装<code>operator[]</code>，所以有预先写好的越界检查；而直接使用 <code>a[100]</code> 原生数组，越界检查是不确定的。</li></ul><p>不过，这类封装和<code>vector</code>相比就尽显颓势了，所以在日常编码中<code>array</code>使用的频率很低</p><h2 id="4-3-非类型模板参数类型限制"><a href="#4-3-非类型模板参数类型限制" class="headerlink" title="4.3 非类型模板参数类型限制"></a>4.3 非类型模板参数类型限制</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非类型模板参数只能用整数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">double</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T _st[N];</span><br><span class="line">    <span class="type">int</span> _top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你想使用除了整数以外的类型作为非类型模板参数，包括浮点数和字符串，都是不可以的；</p><p>但是<code>char</code>类型都是可以的（字符底层是1个字节的整数）</p><p><img src="https://img.musnow.top/i/2023/07/865655e42055d4b96399d92c16298a21.png" alt="image-20230729105450781"></p><p><img src="https://img.musnow.top/i/2023/07/27c0b6ab3a78b5023995fc0e485e2eba.png" alt="image-20230729105734629"></p><h1 id="5-模板的特化"><a href="#5-模板的特化" class="headerlink" title="5.模板的特化"></a>5.模板的特化</h1><p>在绝大多数场景中，模板提供的这两个特性已经可以帮助我们完成很多工作。但在一些特殊情形下，模板的特化就没有我们想象中的那么美好了。</p><h2 id="5-1-问题引出"><a href="#5-1-问题引出" class="headerlink" title="5.1 问题引出"></a>5.1 问题引出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Less</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left &lt; right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> t1 = <span class="number">33.23</span>;</span><br><span class="line">    <span class="type">double</span> t2 = <span class="number">26.32</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Less</span>(t1, t2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Less</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的代码中，我们使用一个模板参数来进行两个相同类型之间的比较，输出的结果与预期相符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>引入我们自己写的日期类（类中封装了对大小比较的重载）也是可以使用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">   <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2023</span>,<span class="number">6</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="comment">// 输出为1</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">Less</span>(d1,d2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>但如果用指针呢？问题就出现了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 正确判断，输出0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Less</span>(d1,d2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Date* pd1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    Date* pd2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 错误判断，输出1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Less</span>(pd1,pd2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后，发现指针处输出的结果是1，即 <code>pd1&lt;pd2</code>成立！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这是因为，在内部的比较是直接比较的这两个<code>date*</code>的指针，其比较的是这两个指针的地址大小！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date* pd2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">Date* pd1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// Date* pd2 = new Date(2023,3,1);</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">Less</span>(pd1,pd2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>如果让<code>pd2</code>这个更小的日期在<code>pd1</code>之前被new，那输出的结果又变成0了；我们也能确认这个输出的结果，并非预期的日期比较结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="5-2-模板特化"><a href="#5-2-模板特化" class="headerlink" title="5.2 模板特化"></a>5.2 模板特化</h2><h3 id="5-3-1-函数模板特化"><a href="#5-3-1-函数模板特化" class="headerlink" title="5.3.1 函数模板特化"></a>5.3.1 函数模板特化</h3><p>针对这种情况，我们需要进行一些特殊化的处理；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Less</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left &lt; right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Less函数针对Date*的指针进行特殊化处理</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">Less</span>&lt;Date*&gt;(Date* left, Date* right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*left) &lt; (*right); <span class="comment">// 使用类内大小比较的重载</span></span><br><span class="line">    <span class="comment">// 这里可以做任何处理，可以理解为是专门写的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理之后的函数再进行比较，输出的结果就是正确的了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date* pd1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">Date* pd2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">Less</span>(pd1,pd2) &lt;&lt; endl; <span class="comment">// 输出为0</span></span><br></pre></td></tr></table></figure><p>可以将这样的特化当作一种特殊的函数重载；</p><hr><p>那么函数模板是否支持后文中类模板一样的半特化呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">Less</span>&lt;T*&gt;(T *left, T *right)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T*&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (*left) &lt; (*right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不支持！vscode就会报错告知我们，编译也无法通过</p><p><img src="https://img.musnow.top/i/2023/07/626725e5c76d56bc2d9daa31e00b524d.png" alt="image-20230729120652774"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp date/date.cpp -o test -std=c++11</span><br><span class="line">test.cpp:81:32: error: non-type partial specialization ‘Less&lt;T*&gt;’ is not allowed</span><br><span class="line"> bool Less&lt;T*&gt;(T *left, T *right)</span><br><span class="line">                                ^</span><br><span class="line">make: *** [makefile:2: test] Error 1</span><br></pre></td></tr></table></figure><p>要像实现对指针的操作，反而得单独写一个像下面一样的模板；</p><p>需要注意，<strong>这个并不是模板特化</strong>，而是一个和原本的模板完全独立的函数模板，二者构成函数重载关系了（将原本的函数模板删除后，依旧可以编译通过并正常运行，就可以证明这个函数模板和原有函数模板无关）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Less</span><span class="params">(T *left, T *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T*&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (*left) &lt; (*right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时date和int的指针都会走这个模板，而不会关注原本对<code>Date*</code>特化后的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date/date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Less</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left &lt; right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Less函数针对Date*的指针进行特殊化处理</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">Less</span>&lt;Date *&gt;(Date *left, Date *right)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;date*&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (*left) &lt; (*right); <span class="comment">// 使用类内大小比较的重载</span></span><br><span class="line">    <span class="comment">// 这里可以做任何处理，可以理解为是专门写的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Less</span><span class="params">(T *left, T *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T*&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (*left) &lt; (*right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_less</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date *pd1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    Date *pd2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Less</span>(pd1, pd2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* pi1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span>* pi2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Less</span>(pi1,pi2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T*</span><br><span class="line">0</span><br><span class="line">T*</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>在遇到特殊情况的时候，函数模板直接实现一个特定类型的特化，或者实现一个完全不同的函数模板就可以了。函数模板是不支持使用<code>T* 和 T&amp;</code>的偏特化的。</p><blockquote><p>调用时候指定模板参数类型的行为叫<code>显式实例化</code>，并非特化</p></blockquote><h3 id="5-3-2-类模板特化"><a href="#5-3-2-类模板特化" class="headerlink" title="5.3.2 类模板特化"></a>5.3.2 类模板特化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1, T2&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 _d1;</span><br><span class="line">	T2 _d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有特化之前，两个函数都是调用的模板本身</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Data&lt;T1, T2&gt;</span><br><span class="line">Data&lt;T1, T2&gt;</span><br></pre></td></tr></table></figure><h4 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h4><p>添加了一个针对<code>&lt;int, double&gt;</code>特化之后（这种特化被称为<strong>全特化</strong>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;int, double&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用的就是我们特化后的类模板了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Data&lt;T1, T2&gt;</span><br><span class="line">Data&lt;int, double&gt;</span><br></pre></td></tr></table></figure><h4 id="半特化-x2F-偏特化"><a href="#半特化-x2F-偏特化" class="headerlink" title="半特化&#x2F;偏特化"></a>半特化&#x2F;偏特化</h4><p>偏特化的第一种形式，将模板参数中的一部分特化。比如下面的代码中，我们将模板参数的<code>T2</code>修改为char</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、将模板参数类表中的一部分参数特化。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;T1, <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1, char&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么修改了之后，只要第二个参数是char的实例化类，都会走偏特化后的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;<span class="type">int</span>,<span class="type">char</span>&gt; d3;</span><br><span class="line">Data&lt;<span class="type">char</span>,<span class="type">char</span>&gt; d4;</span><br></pre></td></tr></table></figure><p>测试结果，走的都是偏特化后的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;T1, char&gt;</span><br><span class="line">Data&lt;T1, char&gt;</span><br></pre></td></tr></table></figure><p>除了这种偏特化某个特定类型的，我们还可以针对指针和引用进行偏特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;T1 *, T2 *&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1*, T2*&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;T1 &amp;, T2 &amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1&amp;, T2&amp;&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;<span class="type">char</span>*,<span class="type">char</span>*&gt; d5;</span><br><span class="line">Data&lt;<span class="type">char</span>*,<span class="type">double</span>*&gt; d6;</span><br><span class="line">Data&lt;<span class="type">int</span>*,<span class="type">char</span>*&gt; d7;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;T1*, T2*&gt;</span><br><span class="line">Data&lt;T1*, T2*&gt;</span><br><span class="line">Data&lt;T1*, T2*&gt;</span><br></pre></td></tr></table></figure><p>而<strong>只有一个指针</strong>的情况，会匹配原生的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有一个指针，会匹配原生的</span></span><br><span class="line">Data&lt;<span class="type">int</span>*,<span class="type">int</span>&gt; d8;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;T1, T2&gt;</span><br></pre></td></tr></table></figure><hr><p>引用的结果也是一样的，两个引用就会调用我们对引用特化了的类模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;<span class="type">int</span>&amp;,<span class="type">char</span>&amp;&gt; d9;</span><br><span class="line">Data&lt;<span class="type">int</span>&amp;,<span class="type">double</span>&amp;&gt; d10;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;T1&amp;, T2&amp;&gt;</span><br><span class="line">Data&lt;T1&amp;, T2&amp;&gt;</span><br></pre></td></tr></table></figure><p>但是引用如果只有一个（不管是在前面还是后面），那就会报错了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;<span class="type">char</span>&amp;,<span class="type">double</span>&gt; d11;</span><br></pre></td></tr></table></figure><p>这是因为它会去调用没有特化后的基础版本，但在默认版本中，我们使用了模板参数来定义了一个变量，这时候就出错了（因为引用必须要在定义的时候赋值！）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp date/date.cpp -o test -std=c++11</span><br><span class="line">test.cpp: In instantiation of ‘Data&lt;T1, T2&gt;::Data() [with T1 = char&amp;; T2 = double]’:</span><br><span class="line">test.cpp:160:24:   required from here</span><br><span class="line">test.cpp:104:5: error: uninitialized reference member in ‘char&amp;’ [-fpermissive]</span><br><span class="line">     Data() &#123; cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl; &#125;</span><br><span class="line">     ^~~~</span><br><span class="line">test.cpp:107:8: note: ‘char&amp; Data&lt;char&amp;, double&gt;::_d1’ should be initialized</span><br><span class="line">     T1 _d1;</span><br><span class="line">        ^~~</span><br><span class="line">make: *** [makefile:2: test] Error 1</span><br></pre></td></tr></table></figure><p>如果将基础模板中的这两个变量定义删除，那就不会报错了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>() &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1, T2&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line"><span class="comment">//     T1 _d1;</span></span><br><span class="line"><span class="comment">//     T2 _d2;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/07/9cca74e8b19eab5dc1ab204adfc67fa1.png" alt="image-20230729120019816"></p><p>运行，输出的结果也是默认的模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data&lt;T1, T2&gt;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>偏特化的适用范围一般高于全特化。</p><p>偏特化和全特化同时存在时，优先调用全特化！</p><h2 id="5-3-使用场景"><a href="#5-3-使用场景" class="headerlink" title="5.3 使用场景"></a>5.3 使用场景</h2><p>当我们使用CPP库函数<code>sort</code>的时候， 需要传入一个仿函数来进行排序的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Less</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_less_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2023</span>, <span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2023</span>, <span class="number">4</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Date <span class="title">d3</span><span class="params">(<span class="number">2023</span>, <span class="number">6</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;Date&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(d2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(d1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Less</span>&lt;Date&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; e ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈上创建的<code>Date</code>是可以直接进行仿函数排序，并获取到正确结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-3-2</span><br><span class="line">2023-4-6</span><br><span class="line">2023-6-3</span><br></pre></td></tr></table></figure><p>但如果是new出来的<code>Date</code>，就会因为是比较的指针而无法正常进行排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Date *pd1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    Date *pd2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">    Date *pd3 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2023</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;Date*&gt; vptr;</span><br><span class="line">    vptr.<span class="built_in">push_back</span>(pd1);</span><br><span class="line">    vptr.<span class="built_in">push_back</span>(pd2);</span><br><span class="line">    vptr.<span class="built_in">push_back</span>(pd3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(vptr.<span class="built_in">begin</span>(), vptr.<span class="built_in">end</span>(), <span class="built_in">Less</span>&lt;Date*&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : vptr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (*e) ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果无序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-7-1</span><br><span class="line">2023-3-2</span><br><span class="line">2023-5-1</span><br></pre></td></tr></table></figure><p>这时候就需要对Less这个仿函数的类进行特化了，我们可以使用全特化，也可以使用偏特化，二者效果相同；而针对指针的偏特化显然适用范围更广</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仿函数类特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Less</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Less</span>&lt;Date*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Date* x, Date* y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *x &lt; *y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Less</span>&lt;T *&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *x, T *y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *x &lt; *y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次测试，成功打印出有序结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-3-2</span><br><span class="line">2023-5-1</span><br><span class="line">2023-7-1</span><br></pre></td></tr></table></figure><h2 id="5-4-迭代器萃取"><a href="#5-4-迭代器萃取" class="headerlink" title="5.4 迭代器萃取"></a>5.4 迭代器萃取</h2><h3 id="5-4-1-iterator-traits"><a href="#5-4-1-iterator-traits" class="headerlink" title="5.4.1 iterator_traits"></a>5.4.1 iterator_traits</h3><p>这个问题在<a href="https://blog.musnow.top/posts/1456870854/">STL-LIST</a>的博客中已经涉及到了一部分；但那时候还没还有了解模板中的特化，没有办法详细地去观察底层的实现机制。</p><p>在STL源码中的<code>stl_iterator.h</code>文件中，可以看到反向迭代器中的如下实现。其使用了<code>iterator_traits</code>模板类，来获取正向迭代器中的成员类型（暂时只关注<code>pointer/reference</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reverse_iterator</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Iterator current;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category</span><br><span class="line">          iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type</span><br><span class="line">          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type</span><br><span class="line">          difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::pointer</span><br><span class="line">          pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::reference</span><br><span class="line">          reference;</span><br></pre></td></tr></table></figure><p>再看看这个类的实现，能看到如下的内容，其针对正向迭代器，同时刻画了关于<code>T*</code>指针和<code>const T*</code>引用的两个偏特化版本。</p><p>因为在list中，我们的正向迭代器是自主封装实现的。但是在vector中，正向迭代器直接用的就是<strong>指针</strong>。提供了这两个特化版本，就能保证即便是用指针这一内置类型实现的特化版本，能成功地获取到一个正确的数据类型（同时也使用了<code>typename</code>告诉编译器这是数据类型）的<code>typedef</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> T*                   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> T&amp;                   reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-4-2-distance"><a href="#5-4-2-distance" class="headerlink" title="5.4.2 distance"></a>5.4.2 distance</h3><p>除了反向迭代器这里需要用到特化，在STL提供的distance函数中也会用到（用于计算两个迭代器之间的距离）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __distance(InputIterator first, InputIterator last, Distance&amp; n, </span><br><span class="line">                       input_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123; ++first; ++n; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __distance(RandomAccessIterator first, RandomAccessIterator last, </span><br><span class="line">                       Distance&amp; n, random_access_iterator_tag) &#123;</span><br><span class="line">  n += last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">distance</span><span class="params">(InputIterator first, InputIterator last, Distance&amp; n)</span> </span>&#123;</span><br><span class="line">  __distance(first, last, n, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是一个单项迭代器，其就需要用过<code>++</code>来计算出两个迭代器之间的长度。如果是一个随机迭代器，那就可以直接通过二者相减计算出距离。</p><p>这时候就需要通过<code>萃取来获取迭代器的类型</code>（在迭代器类构造的时候，迭代器类型就已经通过萃取确认了），并通过这个迭代器的类型，确定使用的算法；</p><h1 id="模板总结"><a href="#模板总结" class="headerlink" title="模板总结"></a>模板总结</h1><p>优点：模板复用了代码，节省了资源和开发效率，C++的模板标准库也因此产生。增强了代码的灵活性；</p><p>缺点：模板会导致代码膨胀问题，也会增加编译时间（模板在编译过程中实例化出具体的函数和类）。而且出现模板编译失败的错误时，错误信息凌乱不方便定位问题。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于模板的基本知识和进阶关于特化的知识就基本结束辣！</p><p>其实模板还有<code>模板元编程</code>这种更深层的东西，但那些使用的频率并不高，具体在工作中如果用到了，可能就需要更深入的学习了。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/2940029419/">https://blog.musnow.top/posts/2940029419/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm7.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1606342371/" title="【C++】STL：string"><img class="cover" src="/img/bg/gm4.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【C++】STL：string</div></div></a></div><div class="next-post pull-right"><a href="/posts/1688214907/" title="【C++】动态内存管理"><img class="cover" src="/img/bg/gm13.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【C++】动态内存管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2359019899/" title="【C++】并查集"><img class="cover" src="/img/bg/gm24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">【C++】并查集</div></div></a></div><div><a href="/posts/1235355339/" title="【C++】图"><img class="cover" src="/img/bg/gm9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-06</div><div class="title">【C++】图</div></div></a></div><div><a href="/posts/1606342371/" title="【C++】STL：string"><img class="cover" src="/img/bg/gm4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-29</div><div class="title">【C++】STL：string</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Artalk</span><span class="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">284</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BA%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">1.了解泛型编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">2.函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.1 简单示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A4%9A%E4%B8%AA%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-text">2.2 多个模板参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">2.3 模板实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%94%AF%E6%8C%81%E7%BB%99%E4%BA%88%E7%B1%BB%E5%9E%8B%E7%BC%BA%E7%9C%81%E5%80%BC"><span class="toc-text">函数模板支持给予类型缺省值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E5%8F%82%E4%B9%9F%E6%94%AF%E6%8C%81%E7%BC%BA%E7%9C%81%E5%80%BC"><span class="toc-text">函数模板中函数的传参也支持缺省值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%EF%BC%88%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="toc-text">2.4 模板和普通函数同时存在（重载）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8D%E6%94%AF%E6%8C%81%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E5%88%86%E7%A6%BB"><span class="toc-text">2.5 函数模板不支持定义和声明分离</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">3.类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.1 简单示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%88%86%E7%A6%BB"><span class="toc-text">3.2 成员函数声明和定义分离</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-text">4.非类型模板参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%9C%80%E8%A6%81%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-text">4.1 什么场景需要非类型模板参数？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%B8%8D%E5%8F%AF%E8%A2%AB%E4%BF%AE%E6%94%B9"><span class="toc-text">非类型模板参数不可被修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-STL%E7%9A%84Array"><span class="toc-text">4.2 STL的Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E9%99%90%E5%88%B6"><span class="toc-text">4.3 非类型模板参数类型限制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96"><span class="toc-text">5.模板的特化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA"><span class="toc-text">5.1 问题引出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-text">5.2 模板特化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-text">5.3.1 函数模板特化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-text">5.3.2 类模板特化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E7%89%B9%E5%8C%96"><span class="toc-text">全特化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E7%89%B9%E5%8C%96-x2F-%E5%81%8F%E7%89%B9%E5%8C%96"><span class="toc-text">半特化&#x2F;偏特化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5.3 使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%90%83%E5%8F%96"><span class="toc-text">5.4 迭代器萃取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-iterator-traits"><span class="toc-text">5.4.1 iterator_traits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-distance"><span class="toc-text">5.4.2 distance</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93"><span class="toc-text">模板总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-end"><span class="toc-text">The end</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2565866661/" title="【Linux】ubuntu/centos8安装zsh终端"><img src="https://img.musnow.top/i/2023/10/5ebc935468a46d95ac77e65dc879c66d.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Linux】ubuntu/centos8安装zsh终端"></a><div class="content"><a class="title" href="/posts/2565866661/" title="【Linux】ubuntu/centos8安装zsh终端">【Linux】ubuntu/centos8安装zsh终端</a><time datetime="2023-10-15T09:12:55.000Z" title="发表于 2023-10-15 17:12:55">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4065446782/" title="【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机"><img src="https://img.musnow.top/i/2023/10/a13a0b3e0db1dab54e499c9c7bf5ddc6.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机"></a><div class="content"><a class="title" href="/posts/4065446782/" title="【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机">【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机</a><time datetime="2023-10-15T03:30:55.000Z" title="发表于 2023-10-15 11:30:55">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/489538601/" title="【七牛云】artalk表情遇到跨域访问问题"><img src="https://img.musnow.top/i/2023/10/6e1119859945ce9b07928a2bff2643d8.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【七牛云】artalk表情遇到跨域访问问题"></a><div class="content"><a class="title" href="/posts/489538601/" title="【七牛云】artalk表情遇到跨域访问问题">【七牛云】artalk表情遇到跨域访问问题</a><time datetime="2023-10-02T04:35:28.000Z" title="发表于 2023-10-02 12:35:28">2023-10-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/565285228/" title="【Linux】valgrind检测程序内存泄漏"><img src="/img/bg/gm9.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Linux】valgrind检测程序内存泄漏"></a><div class="content"><a class="title" href="/posts/565285228/" title="【Linux】valgrind检测程序内存泄漏">【Linux】valgrind检测程序内存泄漏</a><time datetime="2023-09-26T10:12:55.000Z" title="发表于 2023-09-26 18:12:55">2023-09-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/bg/mothra.png)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 慕雪年华</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%872023007189-red" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.staticfile.org/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline.musnow.top',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.staticfile.org/waline/2.15.5/waline.min.css').then(() => {
      getScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js').then(initWaline)
    })
  }
}

if ('Artalk' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="click-heart" src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>