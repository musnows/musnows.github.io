<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【网络】http(s)协议 | 介绍 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="已经学习过自己定制一个协议了，现在就来看看当下广泛使用的http协议吧"><meta property="og:type" content="article"><meta property="og:title" content="【网络】http(s)协议 | 介绍"><meta property="og:url" content="https://blog.musnow.top/posts/2885791654/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="已经学习过自己定制一个协议了，现在就来看看当下广泛使用的http协议吧"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm2.jpg"><meta property="article:published_time" content="2023-02-15T03:30:55.000Z"><meta property="article:modified_time" content="2023-06-06T04:31:17.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Linux"><meta property="article:tag" content="计算机网络"><meta property="article:tag" content="http"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm2.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/2885791654/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":380},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【网络】http(s)协议 | 介绍",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-06 12:31:17"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">324</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm2.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【网络】http(s)协议 | 介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-15T03:30:55.000Z" title="发表于 2023-02-15 11:30:55">2023-02-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-06T04:31:17.000Z" title="更新于 2023-06-06 12:31:17">2023-06-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【网络】http(s)协议 | 介绍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>已经学习过自己定制一个协议了，现在就来看看当下广泛使用的http协议吧</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><blockquote><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p></blockquote><p>http和https是当下最通用的协议之一，我们访问的大部分网页用的都是这个协议；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/</span><br></pre></td></tr></table></figure><p>这两个协议主要的差别，那就是http是用明文传输数据的，我们的数据在互联网裸奔，可能有安全问题；相比之下，https传输数据的过程会对数据进行加密，但这也不代表https是完全安全的。</p><h2 id="1-1-url"><a href="#1-1-url" class="headerlink" title="1.1 url"></a>1.1 url</h2><p>要认识这两个协议，我们要从url的认识开始；</p><p><code>HTTP(S)</code> 不允许使用用户名或密码，一个合法的 <code>HTTP(S)</code> URL 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure><ul><li>开头为协议名：http 或 https 协议；</li><li><code>&lt;host&gt;</code>：主机名。一个 URL 中，既可以使用域名也可以使用 IP 表示主机地址</li><li><code>&lt;port&gt;</code>：端口。主机名和端口之间使用冒号分隔。端口是可选的，如果省略将采用默认端口，http 默认端口是 80，https 默认端口 443；</li><li><code>&lt;path&gt;</code>：资源路径。资源在网络主机上的路径，路径也是可选的，缺省访问默认资源；</li><li><code>&lt;query&gt;</code>：查询参数。格式为 key&#x3D;value，多个参数使用 &amp; 分隔；参数也是可选的；</li><li><code>&lt;frag&gt;</code>：片段。从 # 开始到最后，一般用于定位到资源内的一个片段，比如文档的一个章节；片段也是可选的。</li></ul><h3 id="1-1-1-栗子-①"><a href="#1-1-1-栗子-①" class="headerlink" title="1.1.1 栗子 ①"></a>1.1.1 栗子 ①</h3><p>接下来举一个具体的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile</span><br></pre></td></tr></table></figure><p>如上是我的个人博客中的一篇文章</p><ul><li>协议是https</li><li>域名是<code>blog.musnow.top</code>，对应的就是<code>&lt;host&gt;:&lt;port&gt;</code>；这里隐藏了端口，会在下面说明。</li><li><code>/2022/08/07/note_linux/6gdb_g++_make_vim/</code>这一长串都是文件的路径，其标示了文件在服务器上存放的位置</li><li>这个url内没有带<code>&lt;query&gt;</code>参数</li><li><code>#4-make-x2F-makefile</code>对应的是<code>&lt;frag&gt;</code>片段，标识了我当前浏览的位置</li></ul><p>当你把这个url粘贴道浏览器，其会直接跳转到对应的标题位置，而不是这篇文章的页首；这就是<code>&lt;frag&gt;</code>片段的作用</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec475e3c6a2.png" alt="image-20230215104544655"></p><h3 id="1-1-2-栗子-②"><a href="#1-1-2-栗子-②" class="headerlink" title="1.1.2 栗子 ②"></a>1.1.2 栗子 ②</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=test</span><br></pre></td></tr></table></figure><p>当我们在百度搜索单词<code>test</code>的时候，百度的url中就会出现<code>&lt;query&gt;</code>参数；</p><p>其中<code>?</code>是参数的开头，后续的一串以<code>&amp;</code>分隔的kv键值对，就是参数的内容。在这里面我们能看到<code>word=test</code>，我们查询的单词test就在这个参数后；</p><p>我们的搜索访问，就是将这些参数传送给服务器，再由百度的服务器返回搜素结果的。</p><h2 id="1-2-域名和端口隐藏"><a href="#1-2-域名和端口隐藏" class="headerlink" title="1.2 域名和端口隐藏"></a>1.2 域名和端口隐藏</h2><p>但我们日常访问的网页中，很少见到过<code>ip:端口</code>的形式，而大多是用域名为我们提供服务的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/</span><br></pre></td></tr></table></figure><p>这并不代表其背后不需要端口号。而是因为如果我们的访问<strong>不指定端口</strong>的时候，http(s)协议会采用默认端口号80或443，从而实现隐藏端口号提供服务</p><blockquote><p>http 默认端口是 80，https 默认端口 443</p></blockquote><p>毕竟对于用户而言，记住一个域名已经不容易了，还要记住你的服务是在哪一个端口，那就更难了；</p><p>而域名也不是凭空给我们提供服务的，每一个域名都需要绑定一个具体的公网ip（域名解析），才能为用户提供服务。在域名的背后，都是一个ip，每一个ip也就是一台服务器。</p><p>域名的作用，就是来隐藏掉ip这个无规律的长数字，方便用户访问；</p><blockquote><p>你觉得是记住<code>baidu.com</code>容易，还是记住<code>114.514.77.58</code>容易呢？</p></blockquote><p>在命令行使用ping工具，我们能知道一个网站服务器的ip是什么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.bilibili.com</span><br></pre></td></tr></table></figure><p>比如我们ping一下b站的域名，可以看到其公网ip是<code>183.131.147.29</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正在 Ping a.w.bilicdn1.com [183.131.147.29] 具有 32 字节的数据:</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=10ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line"></span><br><span class="line">183.131.147.29 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 10ms，最长 = 12ms，平均 = 11ms</span><br></pre></td></tr></table></figure><h2 id="1-3-ip-端口"><a href="#1-3-ip-端口" class="headerlink" title="1.3 ip:端口"></a>1.3 ip:端口</h2><p>我们可以用<code>ip:端口</code>来访问自己的服务（以下ip纯属虚构，如有撞车，纯属巧合）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">114.514.77.58:8080</span><br></pre></td></tr></table></figure><p>当我们把这个粘贴道浏览器，再复制粘贴出来的时候，我们会发现前面多了一个http</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://114.514.77.58:8080</span><br></pre></td></tr></table></figure><p>这是因为当我们使用ip访问一个服务的时候，浏览器会默认采用http的协议去访问，所以在前面加了一个我们看不到的<code>http://</code></p><h2 id="1-4-协议作用"><a href="#1-4-协议作用" class="headerlink" title="1.4 协议作用"></a>1.4 协议作用</h2><p>http协议的作用，就是向<strong>服务器</strong>申请特定的资源，再将资源拉取到本地进行展示or使用。</p><p>资源都是存在我们的服务器上的，当用户请求的时候，服务器必须要知道资源的路径，将其<code>read</code>打开读取，再<code>write</code>写给我们的客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p>所以http的请求中才会带上资源的路径，这是方便服务器进行资源文件的读取；同时，文件的路径也是对一个文件的唯一标识，在告诉服务器文件路径的同时，也保证了我们请求的文件的唯一性，不会出现二义性；</p><hr><p>这时候又会出现一个问题，当我们访问网站的根目录的时候，没有提供文件的路径呀，那这时候，访问的什么文件呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br></pre></td></tr></table></figure><p>实际上，我们访问的是服务器根目录的<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br><span class="line">https://www.baidu.com/index.html</span><br></pre></td></tr></table></figure><p>你可以试着打开这两个链接，其出现的页面是完全一致的；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec4cb9820b6.png" alt="image-20230215110843400"></p><p>类似于端口号隐藏，http协议也确定了当下使用的网页文件的命名为<code>index.html</code>，当我们访问一个网站的时候，就会默认访问根目录下的<code>index.html</code>文件（既然是默认的，那就可以直接隐藏）如果这个文件不存在，那就不会渲染出我们看到的网页！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.html是用前端语言编写的网页代码</span><br></pre></td></tr></table></figure><p>同理，当我们访问博客的时候，读取道的也不是目录，而是目录下的<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec4d38428a8.png" alt="image-20230215111050026"></p><p>我的博客使用的是hexo框架，其网页的源路径在github上开源了，可以帮助你理解url中的文件路径。</p><p>当前你看到的文件目录，就是博客服务的根目录。访问的博客首页，就是根目录下的<code>index.html</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec4d71b69ed.png" alt="image-20230215111147560"></p><p>用作示例的<a href="https://blog.musnow.top/posts/1451721896/">linux工具使用</a>博客，也可以根据它的路径，找到<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec4e066de99.png" alt="image-20230215111416443"></p><p>这便是http协议url中文件路径的作用！</p><p>这里的<code>/</code>根目录是<strong>服务端设置</strong>的，并不一定是（大概率不是）服务端linux服务器的根目录</p><blockquote><p>hexo博客已更新为绝对数字路径，本文中演示的路径已经无法访问</p></blockquote><h2 id="1-5-编码解码"><a href="#1-5-编码解码" class="headerlink" title="1.5 编码解码"></a>1.5 编码解码</h2><p>在url中，还会对一些特殊字符进行编解码，比如中文，和一些特殊的符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile</span><br></pre></td></tr></table></figure><p>比如在作为示例的url中，这里出现了<code>x2F</code>，而原文中是<code>4.make/makefile</code>;这里的编码就是为了避免<code>make/makefile</code>被识别成路径的标识符，从而出现错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=%E4%BD%A0%E5%A5%BD</span><br></pre></td></tr></table></figure><p>当url路径中有中文的时候，也会被转码成特定的格式</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec503e1f0d6.png" alt="image-20230215112344227"></p><p>我们在浏览器上看到的依旧是中文，这是因为浏览器这段帮我们进行了解码</p><blockquote><p>将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成<code>%XY</code>格式</p></blockquote><h1 id="2-http协议请求格式"><a href="#2-http协议请求格式" class="headerlink" title="2.http协议请求格式"></a>2.http协议请求格式</h1><p>了解了http协议中的url网址，现在就可以进一步了解http协议的报头和报文了;</p><p>一个<code>http request/response</code>的基本格式如下</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec536219bf8.png" alt="image-20230215113707995"></p><p>在请求中，客户端会提供自己的请求方法（GET&#x2F;POST&#x2F;PUT等等），并提供url来标识自己需要的文件路径；这个url可能是短链接（截取根目录之后的部分），也有可能是完整的链接。</p><p>随后，就会跟上一大堆的请求参数，注意，这里的请求参数并不是url中的<code>&lt;query&gt;</code>参数，而是http协议自身的请求参数。每一个请求参数都用了<code>\r\n</code>作为分隔，这和我们写的<a href="https://blog.musnow.top/posts/4225991450/">自定义协议</a>中采用<code>\t</code>进行分割是相同的原理！</p><p>这几个部分中，请求的正文可以不带（为空）</p><h2 id="2-1-读取多长？"><a href="#2-1-读取多长？" class="headerlink" title="2.1 读取多长？"></a>2.1 读取多长？</h2><p>为了让协议读取的时候，能够知道什么时候读取完毕了报头，http协议提供了一个<code>\r\n</code>的空行，读取道这个空行，就代表报头读取完毕了，剩下的内容都是报文。</p><p>而为了标识报文的长度，http协议会在发送的时候提供一个参数<code>content-length</code>，用于标识报文的长度。在读取完毕报头后，肯定是读取到了这个<code>content-length</code>参数的，也就知道后续应该继续读取多长，才能读完整个协议字段！</p><p>关于这部分的介绍，可以查看另外一篇博客 <a href="https://blog.musnow.top/posts/1805390619/">http协议content-length详解</a></p><h2 id="2-2-响应的状态码"><a href="#2-2-响应的状态码" class="headerlink" title="2.2 响应的状态码"></a>2.2 响应的状态码</h2><p>和我们进程的退出状态一样，http也表明了一部分响应的状态码，其中我们日常最常见到的，是<code>404/403</code>这两个状态码</p><blockquote><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660">http状态码-百度百科</a></p></blockquote><p>状态码就是标识服务器提供的服务状态，告诉客户端它的请求是否成功了。如果状态码是200，代表请求是成功的。其余状态码会有各自的使用场景，比如404状态码，代表请求的资源不存在，所以才叫 <code>404 not found!</code></p><h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h1><p>完整代码详见 <a target="_blank" rel="noopener" href="https://gitee.com/musnow/raspberry-practice/tree/master/code">Gitee</a></p><h2 id="3-1-前端页面"><a href="#3-1-前端页面" class="headerlink" title="3.1 前端页面"></a>3.1 前端页面</h2><p>由于本人并没有学习过前端语法，这里采用 <a target="_blank" rel="noopener" href="https://www.runoob.com/html/html-tutorial.html">菜鸟教程</a> 提供的前端示例代码来演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们日常所访问的网页都是这样的代码，经由浏览器进行渲染，再展示出来</p><h2 id="3-2-服务端代码"><a href="#3-2-服务端代码" class="headerlink" title="3.2 服务端代码"></a>3.2 服务端代码</h2><p>由于http是基于tcp的，这里直接把之前写的tcpServer搬过来就能用！具体的代码解析请看注释，想必说的是很清楚的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF <span class="string">&quot;\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF_LEN strlen(CRLF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE_LEN strlen(SPACE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOME_PAGE <span class="string">&quot;index.html&quot;</span> <span class="comment">// 首页文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOT_PATH <span class="string">&quot;web&quot;</span> <span class="comment">// 网址根目录地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取http请求中的路径</span></span><br><span class="line"><span class="function">string <span class="title">getPath</span><span class="params">(string http_request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> pos = http_request.<span class="built_in">find</span>(CRLF);<span class="comment">//找到第一行的分隔符</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    string request_line = http_request.<span class="built_in">substr</span>(<span class="number">0</span>, pos);<span class="comment">//取出第一行</span></span><br><span class="line">    <span class="comment">//请求的第一行：GET /a/b/c http/1.0</span></span><br><span class="line">    <span class="type">size_t</span> first = request_line.<span class="built_in">find</span>(SPACE);<span class="comment">// 找到第一个空格</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> second = request_line.<span class="built_in">rfind</span>(SPACE); <span class="comment">// 从后往前找空格</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 找到两个空格了，两个空格之间的就是请求的路径</span></span><br><span class="line">    string path = request_line.<span class="built_in">substr</span>(first+SPACE_LEN, second - (first+SPACE_LEN));</span><br><span class="line">    <span class="comment">// 对path进行判断，如果path是以/结尾的，则在path中追加index.html文件名</span></span><br><span class="line">    <span class="keyword">if</span>(path[path.<span class="built_in">size</span>()<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        path += HOME_PAGE; <span class="comment">//加上被隐藏的index.html文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="function">string <span class="title">readFile</span><span class="params">(<span class="type">const</span> string &amp;recource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(recource, ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in.<span class="built_in">is_open</span>()) <span class="comment">//文件打开失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;404&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    string content;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, line))</span><br><span class="line">    &#123;</span><br><span class="line">        content += line;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handlerHttpRequest</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;###########start#############&quot;</span> &lt;&lt; endl;<span class="comment">//打印一个分隔线</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10240</span>];</span><br><span class="line">    <span class="type">ssize_t</span> s = <span class="built_in">read</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;###########end############&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string path = <span class="built_in">getPath</span>(buffer);</span><br><span class="line">    <span class="comment">// 假设用户请求的是 /a/b 路径</span></span><br><span class="line">    <span class="comment">// 那么服务端处理的时候，就需要添加根目录位置和默认的文件名</span></span><br><span class="line">    <span class="comment">// &lt;root&gt;/a/b/index.html</span></span><br><span class="line">    <span class="comment">// 在本次用例中，根目录为 ./web文件夹，所以完整的文件路径应该是</span></span><br><span class="line">    <span class="comment">// ./web/a/b/index.html</span></span><br><span class="line"></span><br><span class="line">    string resources = ROOT_PATH; <span class="comment">// 根目录路径</span></span><br><span class="line">    resources += path; <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="built_in">logging</span>(DEBUG,<span class="string">&quot;[sockfd: %d] filePath: %s&quot;</span>,sock,resources.<span class="built_in">c_str</span>()); <span class="comment">// 打印用作debug</span></span><br><span class="line"></span><br><span class="line">    string html = <span class="built_in">readFile</span>(resources);<span class="comment">// 打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始响应</span></span><br><span class="line">    string response = <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;</span><br><span class="line">    <span class="comment">//如果readFile返回的是404，代表文件路径不存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(html.<span class="built_in">c_str</span>(),<span class="string">&quot;404&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.0 404 NOT FOUND\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加后续字段</span></span><br><span class="line">    response += <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>;</span><br><span class="line">    response += (<span class="string">&quot;Content-Length: &quot;</span> + <span class="built_in">to_string</span>(html.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    response += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    response += html;</span><br><span class="line">    <span class="comment">// 发送给用户</span></span><br><span class="line">    <span class="built_in">send</span>(sock, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h2><p>启动服务器之前，请先打开你的云服务器防火墙中的对应端口；这里我绑定的是端口10000，在浏览器中用<code>ip:端口</code>的方式可以正常访问！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec6f01b93dd.png" alt="image-20230215133459929"></p><p>这里标识的<code>不安全</code>是因为我们没有采用带加密的https协议，这不是当下需要考虑的问题。不管他就可以了。</p><p>按F12打开开发者页面，可以看到下方出现了完整的html代码，我们成功提供了服务！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec720503cdc.png" alt="image-20230215134751216"></p><h2 id="3-4-后端打印的报文"><a href="#3-4-后端打印的报文" class="headerlink" title="3.4 后端打印的报文"></a>3.4 后端打印的报文</h2><p>在服务器后端，我们看到其打印出来了一个基本的http请求，和上面说明的格式是一样的。这里简单的进行一部分说明：</p><ul><li>GET：请求方式为获取数据</li><li><code>/</code>：请求的是根路径</li><li><code>HTTP/1.1</code>：使用的http协议版本</li><li><code>Connection</code>：代表我们和服务器的链接方式，keep-alive代表保持连接</li><li><code>User-Agent</code>：客户端信息，可以看到是windows系统、Chrome内核的浏览器（我是用的是edge浏览器）</li><li>Accept: 支持接收的信息类型</li><li><code>Aceept-Encoding</code>: 对信息进行压缩</li><li><code>Accept-Language</code>：支持的语言</li><li><code>Cookie</code>：身份信息，后面会详细介绍</li></ul><p>其中出现了一个空行，代表报文结束；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec78b4c5cf2.png" alt="image-20230215141623151"></p><p>往下滑，会发现浏览器还发出了第二个请求，路径是<code>/favicon.ico</code>，这是默认的站点头像文件的命名。因为我们的html文件中没有写明站点头像的路径，所以浏览器就尝试请求默认的头像文件</p><p>但是，当前我们的站点根目录web下并没有该文件，应该返回一个404状态码。</p><ul><li>请求中出现了一个新的参数<code>Referer</code>，代表是从当前网页请求头像的。相比之下，请求网页的报文中没有<code>Referer</code>参数</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec8b10b0daf.png" alt="image-20230215153442298"></p><p>此时可以随便找个图片做头像，看看能不能加载出来；为了方便，我随便找了一张纯绿色的图片，并将其<a target="_blank" rel="noopener" href="http://www.ico51.cn/">在线转换为ico</a>，放入了站点的根目录。</p><p>重启服务器进程，刷新浏览器再次请求，可以看到成功出现了站点的头像；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec7575b082e.png" alt="image-20230215140232033"></p><h2 id="3-5-常见参数表"><a href="#3-5-常见参数表" class="headerlink" title="3.5 常见参数表"></a>3.5 常见参数表</h2><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec8de7299b2.png" alt="img"></p><h1 id="4-请求方法"><a href="#4-请求方法" class="headerlink" title="4.请求方法"></a>4.请求方法</h1><p>一般我们获取一个网页，用的都是GET方法。接下来用一个带按钮的表单创建请求，尝试向服务端发送<code>&lt;query&gt;</code>参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-1-GET"><a href="#4-1-GET" class="headerlink" title="4.1 GET"></a>4.1 GET</h2><p>在method里面，我们指定了get方法，此时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时页面中出现了两个输入框，供我们输入密码，且密码会显示为<code>****</code>而不是明文</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec89644d733.png" alt="image-20230215152726050"></p><p>点击按钮，会跳转到一个404页面，这是因为我们的<code>a/index.html</code>路径并不支持参数请求，所以发送了404错误码</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec89a063d20.png" alt="image-20230215152834203"></p><p>不过这不重要，我们看看后端打印的内容。其中参数是追加到url中，以明文传输过来的；正文部分为空，并没有携带参数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec8b5dd10c0.png" alt="image-20230215153559515"></p><h2 id="4-2-POST"><a href="#4-2-POST" class="headerlink" title="4.2 POST"></a>4.2 POST</h2><p>将请求方法改成post，再次尝试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候能正常显示出<code>a/index.html</code>页面，url中不再带有参数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec8beb1e0c5.png" alt="image-20230215153820898"></p><p>此时查看后端中的信息，能看到请求方法变为POST，参数出现在了正文部分，而不是url中</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec8c2e7faa5.png" alt="image-20230215153928118"></p><h2 id="4-3-GET-x2F-POST区别"><a href="#4-3-GET-x2F-POST区别" class="headerlink" title="4.3 GET&#x2F;POST区别"></a>4.3 GET&#x2F;POST区别</h2><p>这也是GET和POST方法的区别之一：</p><ul><li>GET方法通过url传参</li><li>POST方法会将url参数提取出来，拼接到正文部分</li></ul><p>由此能推出二者的安全性区别</p><ul><li>GET方法相对不安全，因为参数直接以明文贴在了url上</li><li>POST方法以正文传参，使用https协议的时候能进行加密，相对较安全</li></ul><h2 id="4-4-更多方法"><a href="#4-4-更多方法" class="headerlink" title="4.4 更多方法"></a>4.4 更多方法</h2><p>http请求还支持更多方法，如下</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec8daba6e19.png" alt="img"></p><h1 id="5-状态码"><a href="#5-状态码" class="headerlink" title="5.状态码"></a>5.状态码</h1><h2 id="5-1-状态码表"><a href="#5-1-状态码表" class="headerlink" title="5.1 状态码表"></a>5.1 状态码表</h2><p>下面是一个响应状态码的总表</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec8ef551dec.png" alt="image-20230215155118813"></p><h2 id="5-2-404-x2F-403状态码"><a href="#5-2-404-x2F-403状态码" class="headerlink" title="5.2 404&#x2F;403状态码"></a>5.2 404&#x2F;403状态码</h2><p>我们能看到404和403都是客户端状态码，为什么说是客户端错误呢？这是因为你向服务器请求了一个服务器没有的资源，<strong>这个问题不应该是服务器的问题</strong>。</p><p>这就好比你去西瓜摊买肉，人家压根不卖肉。问题出在你身上，你不应该找西瓜摊老板买肉。所以404状态码，应该是客户端的问题！</p><p>而403状态码的含义是<code>403 forbidden</code>，服务器拒绝了你的请求（你没有权限访问）这也是客户端的问题。你不能去超市买东西，然后问老板能不能让你看看老板的钱罐子。老板肯定不给你看啊！所以才会告诉你403，不给你访问。</p><h2 id="5-3-5xx状态码"><a href="#5-3-5xx状态码" class="headerlink" title="5.3 5xx状态码"></a>5.3 5xx状态码</h2><p>什么时候会出现服务器错误的5xx状态码呢？</p><p>当你请求一个服务，服务端需要处理之后给你返回结果。此时服务器在处理过程中，可能因为程序有bug提前退出，这时候就应该给客户端发送一个<code>5xx</code>状态码，标识服务器在处理你的请求的过程中，出现了错误，无法返回结果。</p><h2 id="5-4-301-x2F-302重定向"><a href="#5-4-301-x2F-302重定向" class="headerlink" title="5.4 301&#x2F;302重定向"></a>5.4 301&#x2F;302重定向</h2><p>关于3开头的状态码，主要谈谈下面这两个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">301 永久重定向</span><br><span class="line">302 临时重定向</span><br></pre></td></tr></table></figure><p>为何一个是永久，一个是临时呢？</p><p>在http进行响应的时候，服务端可以发送一个<code>location</code>参数，发送一个新的url给客户端；我们的浏览器在收到这个参数后，会自动打开对应的页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: https://www.baidu.com/</span><br></pre></td></tr></table></figure><p>我们可以用上面的代码来测试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试进行302重定向</span></span><br><span class="line">string response = <span class="string">&quot;HTTP/1.1 302 Temporarily moved\r\n&quot;</span>;</span><br><span class="line">response+= <span class="string">&quot;Location: https://www.baidu.com/\r\n&quot;</span>;</span><br><span class="line">response+= <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给用户</span></span><br><span class="line"><span class="built_in">send</span>(sock, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>此时访问我们自己的<code>IP:端口</code>，会跳转到百度的页面。这就是重定向的作用</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ec9497019d5.png" alt="image-20230215161520817"></p><ul><li>那临时重定向和永久重定向有什么区别呢?</li></ul><p>假如我设立了一个公开站点，域名是<code>test.com</code>，这几年一直提供服务，积累了一部分的用户。过了一会，我不想要这个域名了，想换一个<code>test.cn</code>；可用户已经有那么多，大家都只记得你的<code>test.com</code>，如果直接更换域名，就会导致用户无法访问<code>test.com</code>，以为你跑路了，就放弃使用你的网页。</p><p>这样的结果显而易见：严重的客户流失！</p><p>所以，为了避免这个问题，我可以先将服务迁移到<code>test.cn</code>新域名，在旧域名<code>test.com</code>中设置一个301重定向到<code>test.cn</code>，告诉用户我换新域名了。这样持续一段时间后，等到<code>test.com</code>的使用者不多了，就可以考虑彻底取消<code>test.com</code>的解析，关停此域名了。</p><p>在上面的场景中，我是需要更换域名，是永久更换。我们就应该把状态码设置为301，告诉客户端这个域名将被永久重定向到另外一个域名上</p><hr><p>另外的情况是，我有一个<code>example.com</code>域名，我的服务需要进行维护；此时就将<code>example.com</code>重定向到另外一个域名<code>example.cn</code>，指向另外一个服务器，让这个服务器临时提供服务。</p><p>服务维护完毕后，就将重定向取消，继续使用当前的服务器。</p><p>这个场景中，重定向只是维护期间的一个临时策略，所以状态码设置成302，告诉客户端我只是临时进行重定向，我还会回来的。</p><h1 id="6-cookie-x2F-session"><a href="#6-cookie-x2F-session" class="headerlink" title="6.cookie&#x2F;session"></a>6.cookie&#x2F;session</h1><p>日常生活中，当我们在一个web页面中登录了（如github&#x2F;gitee&#x2F;csdn）这个网页在很长一段时间内都会保持登录，直到超时亦或者是出现了异地访问。</p><p>假如你现在有个网页，但是每次用户访问的时候，都需要重新输入用户名和密码，刚刚输入过了，换一个页面又不行了。这样一来，用户还会想用你这个服务吗？</p><p>为了避免此类问题，http协议就需要引入其他的参数，来维持用户的登录会话。cookie&#x2F;session便是因此而来的。</p><h2 id="6-1-set-cookie"><a href="#6-1-set-cookie" class="headerlink" title="6.1 set cookie"></a>6.1 set cookie</h2><p>服务端可以在响应头中带上<code>Set-Cookie</code>字段，给客户端设置上cookie</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response += <span class="string">&quot;Set-Cookie: This is my cookie test\r\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>打开f12开发者界面，能在其中看到我们设置的cookie</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63eca303c2533.png" alt="image-20230215171652910"></p><p>再次刷新网页，可以看到在之后的请求中，浏览器都会发送一次服务器设置的cookie。这样服务端在收到cookie后，就能解析到自己设置的cookie，确定了指定的用户</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63eca34befdf0.png" alt="image-20230215171805924"></p><p>在服务器端也能看到这个字段</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63eca54f23dfe.png" alt="image-20230215172640992"></p><h2 id="6-1-1-cookie-path"><a href="#6-1-1-cookie-path" class="headerlink" title="6.1.1 cookie path"></a>6.1.1 cookie path</h2><p>对于cookie来说，其还有一个路径的配置项。见下图，我在实现我的视频点播系统的时候，在<code>/usr/login</code>处直接用了如下header来set-cookie</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rsp.<span class="built_in">set_header</span>(<span class="string">&quot;Set-Cookie&quot;</span>,<span class="string">&quot;sid=123456&quot;</span>);</span><br><span class="line"><span class="comment">// 如上语句是httplib，等价于</span></span><br><span class="line"><span class="comment">// Set-Cookie: sid=123456\r\n</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/d49a82b83170f3492eed82e22c912a6f.png" alt="image-20230814105000336"></p><p>这就导致我对我的视频点播其他界面中的操作并没有携带上我自己set的这个cookie，也就没有办法实现后续的seesion识别（这里我写死了是因为还在初始测试阶段）</p><p>我们要做的就是在cookie后面携带一个path，来告诉浏览器这个cookie应该是全局的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: sid=123456; path=/</span><br></pre></td></tr></table></figure><p>这样才能实现后续整个网站的请求都会带上这个cookie，否则只有请求 <code>/usr</code>开头的路径才能带上这个cookie</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/3067e79e290dc2bcc1655f59f2d05c12.png" alt="image-20230814105357134"></p><p>如上图，这样设置了后，cookie path已经是<code>/</code> 代表根路径了</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/1a53c535dfdab00cdee81897541219b7.png" alt="image-20230814105422129"></p><h2 id="6-2-什么是cookie"><a href="#6-2-什么是cookie" class="headerlink" title="6.2 什么是cookie"></a>6.2 什么是cookie</h2><p>所谓cookie，其实就是浏览器帮我们存取了一定的身份信息在本地（内存or磁盘）</p><p>下一次打开特定的网页的时候，就能显示对应的身份信息（不一定是你的账户密码），并告诉服务器，服务器就识别到了你当前的用户，并为你保持登陆状态。</p><p>既然是保存在用户本地的，那就有可能被窃取。一些恶意软件就会去扫描你浏览器本地缓存中的cookie信息，对于一些安全性不高的网站而言，有了这个cookie，就相当于他有了你的账户，可以直接登录你的账户进行操作。</p><p>因此，引入了另外一种身份认证的方式 <code>cookie+session</code></p><h2 id="6-3-cookie-session"><a href="#6-3-cookie-session" class="headerlink" title="6.3 cookie+session"></a>6.3 cookie+session</h2><p>比起将身份信息存到客户端，存至服务端更为安全（攻击企业服务器的成本，比在用户端植入木马程序的成本更高）</p><ul><li>用户使用账户密码请求登录，服务器收到登录请求，验证成功后，给客户端返回一个<code>唯一字符串session_id</code>来标识用户</li><li>客户端下一次请求的时候，带上了这个唯一字符串</li><li>服务器收到请求，在本地的<code>session_id</code>库中查找这个id，找到后，就将用户信息匹配给客户端，相当于客户端登录成功了</li></ul><p>这样，就将原本存在用户本地的身份认证信息，<strong>存到了服务端中</strong>。客户端就只剩下一个孤零零的字符串id，不会有用户的私密信息。即便丢失，也不会影响用户的隐私。</p><ul><li>你可能会说，那我偷走这个id不也是一样的效果？</li></ul><p>其实没有那么简单，服务端可以将<code>session_id</code>和用户的ip或者终端User-Agent绑定，这样只要用户<strong>切换设备</strong>或者<strong>换了登录的地点</strong>（比如从三亚跑到了哈尔滨）就直接让<code>session_id</code>失效，要求用户重新登录。</p><h1 id="7-长短链接"><a href="#7-长短链接" class="headerlink" title="7.长短链接"></a>7.长短链接</h1><p>在早期的http协议中，采用的都是短链接，一次连接只能处理1次http请求。当时的网页大多以文字为主，数据量很小，一起请求也能够满足需求。</p><p>但现在时代已经变了，一个网页里面有图片，文字，音频，视频。这些文件的体积打起来之后，短链接的方式就不适用了。此时就出现了长链接，一次tcp链接，可以持续传输数据。</p><p>相比短链接，长链接连上之后，能持续传输数据，<strong>避免了tcp3次握手的消耗</strong>，提高了数据传输的效率！</p><h2 id="7-1-Connection"><a href="#7-1-Connection" class="headerlink" title="7.1 Connection"></a>7.1 Connection</h2><p>在本文的<code>3.4</code>中，便出现了这个参数，一般情况下，会有下面两种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Connection: closed</span><br></pre></td></tr></table></figure><p>其中<code>keep-alive</code>就是长链接，<code>closed</code>代表当前端口只支持短链接。</p><p>当客户端发送的请求头中包含<code>Connection: keep-alive</code>字段，如果服务器支持长链接，就需要在响应头中也带上<code>Connection: keep-alive</code>，这样双方协商成功，大家都可以使用长链接。</p><p>如果服务器的响应头中没有带<code>Connection: keep-alive</code>，那么客户端就会认为服务器不支持长链接，下次请求的时候，会重新向服务器链接，再获取资源。</p><p>如果客户端和服务端任意一方的响应头中包含<code>Connection: closed</code>，那么就会认为当前的会话只支持短链接，下次请求会重新建立链接。</p><h2 id="7-2-http和tcp的关系"><a href="#7-2-http和tcp的关系" class="headerlink" title="7.2 http和tcp的关系"></a>7.2 http和tcp的关系</h2><p>http虽然是基于tcp的，但http本身是无链接的。</p><blockquote><p>举个最明显的栗子，在你打开一个网页之后，你关闭掉自己的wifi，你的网页并不会因此消失。只是无法进行后续操作而已。</p></blockquote><p>http是一个无链接的应用层协议，其借助tcp进行数据的流式传输，但不一定需要客户端和服务端保持连接。</p><p>所以，http就可以借助单个tcp套接字<strong>持续的传输数据</strong>，也就天然地支持了长链接通信。</p><p>总结一下，http只是借用了tcp的能力，其无连接的特性和tcp没有关系！</p><h2 id="7-3-pipeline"><a href="#7-3-pipeline" class="headerlink" title="7.3 pipeline"></a>7.3 pipeline</h2><p>这其中会牵扯到一个<code>pipeline</code>，其维护了http长链接请求时的<strong>响应顺序</strong>。</p><p>比如人家需要加载一个网页，服务端应该先把网页的整体框架给用户加载出来，再给用户加载图片、视频、音频等资源。下图B站的加载就是一个很好的栗子。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ee31578364a.png" alt="image-20230216213625496"></p><p>否则乱序了，比如只出现了一个孤零零的图片，就会让人感觉非常奇怪。</p><h1 id="8-https"><a href="#8-https" class="headerlink" title="8.https"></a>8.https</h1><p>因为http的数据是无加密明文发送的，相对来说并不是非常的安全；为了实现数据加密，https在http的下层添加了一个<code>SSL/TLS</code>软件层，来进行数据加解密工作</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ecc49657516.png" alt="image-20230215193931213"></p><h2 id="8-1-为啥要加密？"><a href="#8-1-为啥要加密？" class="headerlink" title="8.1 为啥要加密？"></a>8.1 为啥要加密？</h2><p>要知道，所有的加密工作，都是为了防止数据在中间传输的过程，被窃取或修改。如果我们请求一个网站登录的时候，数据包中就会包含我们的账户密码。如果被窃取，我们的隐私就泄露了。这是很难受的一件事！</p><blockquote><p>这也是为什么，我们经常能听到<code>免费公共wifi不安全</code>这一说法，因为我们在这个wifi上进行的所有数据交换，都会走这个wifi的路由器，很容易被<code>中间人</code>窃取并获取到我们的数据包。</p><p>这种情况下，https的加密就更有必要了！</p></blockquote><p>但是，加密解密是需要时间的，所以https响应的速度会稍慢于http。不过当下cpu的执行速度已经非常快，这点时间差距很小，不会特别影响我们的日常使用！</p><p>不过，加密并不是一个万金油，并不是说加密了之后的数据就一定能避免被窃取。但加密可以大大提高窃取破解的成本，无形中降低了数据被窃取的概率，保证了一定的数据安全。</p><h2 id="8-2-常见加密方式"><a href="#8-2-常见加密方式" class="headerlink" title="8.2 常见加密方式"></a>8.2 常见加密方式</h2><h3 id="8-2-1-对称加密"><a href="#8-2-1-对称加密" class="headerlink" title="8.2.1 对称加密"></a>8.2.1 对称加密</h3><p>所谓对称加密，好比有一个带锁的盒子，客户端和服务器都有一把钥匙。客户端先把信息丢进盒子里，再用🔑锁上盒子，发送给服务端。服务端用🔑打开盒子，取出数据。</p><p>因为客户端和服务器持有的钥匙是完全一致的，所以被称为对称加密。在加密的场景下，钥匙一般被称为<code>密钥</code></p><p>在网络场景里，<strong>对称加密是不可取的</strong>。只要客户端和服务端传输密钥的时候被窃取，那么双方的加密就失效了。因为是用同一个密钥来加密解密，我拿走了你的钥匙，自然就能打开你这把锁。</p><p>也就是说，<font color="orange">密钥的传输也需要加密</font>。但是这又引出一个问题，我都没有你的密钥，我怎么解密你发过来的密钥信息？这是一个<code>先有蛋还是先有鸡</code>的死循环！</p><h3 id="8-2-2-非对称加密"><a href="#8-2-2-非对称加密" class="headerlink" title="8.2.2 非对称加密"></a>8.2.2 非对称加密</h3><p>非对称加密场景下，会有一个公钥和私钥</p><ul><li>私钥对数据加密，变成密文</li><li>公钥对数据解密，变成明文</li></ul><p>二者也可以反过来</p><ul><li>私钥对数据解密</li><li>公钥对数据加密</li></ul><p>其中最常用的非对称加密，也就是我们在<a href="https://blog.musnow.top/posts/3625274788/">git的ssh操作</a>中使用过的<code>rsa</code>密钥，其中就有一个<code>.pem</code>公钥和一个私钥。我们将公钥提供给github，私钥保存到本地，就能实现无密码上传数据到git仓库。</p><hr><p>但是非对称加密还是会存在中间人攻击的问题。先看如下图，你应该能发现，其中有一个重要的环节，<strong>就是服务端要把公钥发送给客户端</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ee25050db71.png" alt="image-20230216204344555"></p><p>在这个场景中，公钥是<strong>公开传输给客户端</strong>的，也就是后续服务器发送给客户端的所有信息，都可以被其他人用这个<strong>公钥</strong>解析出来；</p><p>整个环节中，只做到了客户端发送给服务器的信息安全，因为只有服务器拥有私钥，能解密出数据。（单项数据安全）</p><h3 id="8-2-3-双非对称"><a href="#8-2-3-双非对称" class="headerlink" title="8.2.3 双非对称"></a>8.2.3 双非对称</h3><p>这时候，我们可以采用双非对称密钥加密的方式！既然非对称只能保证单方的数据安全，那使用两个非对称，不就能保证双方数据安全了嘛！</p><ul><li>客户端和服务端交换公钥<code>a&#39; 和 b&#39;</code></li><li>客户端给服务端发信息：先用<code>a&#39;</code>对数据加密，再发送；只能由服务器解密，因为只有服务器有私钥a</li><li>服务端给客户端发信息：先用<code>b&#39;</code>对数据加密，再发送；只能由客户端解密，因为只有客户端有私钥b</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ee2acb5bf6c.png" alt="image-20230216210830169"></p><p>因为两份私钥都只有客户端和服务器自己拥有，所以黑客没有办法进行数据的窃取，也就保证了数据的安全。</p><p>即便中间人<strong>替换了交换的公钥</strong>，也会因为后续的通信，客户端or服务端<strong>本地的私钥</strong>无法正常解密，而发现数据被窃取！</p><p>但是但是，这样左还算有很大的<strong>缺点</strong></p><ul><li>效率太低（非对称加密解密负载太高，效率低下，特定场景下无法满足要求）</li><li>依旧可能存在安全问题</li></ul><h3 id="8-2-4-非对称-对称"><a href="#8-2-4-非对称-对称" class="headerlink" title="8.2.4 非对称+对称"></a>8.2.4 非对称+对称</h3><ul><li>服务端具有非对称公钥S和私钥S’</li><li>客⼾端发起请求，获取服务端公钥S</li><li>客⼾端在本地生成对称密钥C, 通过公钥S加密, 发送给服务器.</li><li>由于中间人没有私钥，即使截获了数据，也无法还原出内部的原文，也就无法获取到对称密钥</li><li>服务器通过私钥<code>S&#39;</code>解密，还原出客户端发送的对称密钥C，并且使用这个对称密钥加密给客户端发送的响应数据</li><li>后续客户端和服务端都采用密钥C来进行对称加密通信</li></ul><p>因为对称<strong>密钥C在传输过程中是加密</strong>的，只有客户端和服务端知道密钥是什么，也就实现了数据的安全通信！</p><h2 id="8-3-数据摘要（指纹）"><a href="#8-3-数据摘要（指纹）" class="headerlink" title="8.3 数据摘要（指纹）"></a>8.3 数据摘要（指纹）</h2><p>数字指纹(数据摘要)， 其基本原理是利⽤单向散列函数(<code>Hash函数</code>)对信息进行运算，生成⼀串<strong>固定长度</strong>的数字摘要。</p><p>常见的摘要算法有<code>MD5/SHA1/SHA256/SHA512</code>等；</p><p>数字指纹并不是⼀种加密机制，但可以用来判断<strong>数据有没有被窜改</strong>，亦或者是下载的数据包有没有出现损坏。</p><ul><li>同一个数据文件，用同一个方法生成的数据摘要是一致的</li><li>不同文件生成的数据摘要可能会撞车，但几率极低，可以认为具有唯一性！</li><li>我们无法用数据摘要反推出数据内容（怎么可能用一个字符串推测出原本的内容呢？那样还存放源文件干哈？😂）</li></ul><p>数据摘要在网盘产品中也有使用，当我们使用<strong>百度云盘、阿里云盘</strong>的时候，会遇到一个大的资源文件只用了<strong>短短几秒</strong>就成功上传到服务器的情况。此时，我们并不是真的用几秒就把数据传输上去了，而是经历了以下阶段</p><ul><li>网盘客户端对本地文件生成数据摘要</li><li>生成后，判断服务器端<strong>已有文件</strong>中，是否有同该数据摘要相同的文件</li><li>如果有，代表该文件已经存在了云盘的服务器中</li><li>服务器将该文件给你的账户建立一个<strong>软链接&#x2F;硬链接</strong>，就实现了<code>&quot;妙传&quot;</code></li><li>如果没有，则老老实实的从本地上传文件到云盘</li></ul><p>云盘厂家这么做的原因很简单：<strong>避免同一份文件被多次存储</strong>。当下网盘给用户的免费空间动则上T，如果所有文件都重复保存，那对于云服务器厂家来说，资源消耗太大了。</p><p>这个做法并不会产生数据隐私问题，一般只有电影等资源文件才有可能妙传成功。你可以使用一些<code>“其他手段”</code>，比如把资源打个压缩包，并在压缩包中随便丢另外一个文件，让文件的数据指纹和已有资源不相同，就不会进行<code>妙传</code>了。</p><blockquote><p>这样做还有另外一个好处，那就是原资源因为违规被ban的时候，你的资源不会被<code>连坐</code>😂</p></blockquote><h2 id="8-4-数字签名"><a href="#8-4-数字签名" class="headerlink" title="8.4 数字签名"></a>8.4 数字签名</h2><p>对数据摘要进行<strong>加密</strong>，生成的内容被称为<strong>数字签名</strong></p><h2 id="8-5-中间人攻击"><a href="#8-5-中间人攻击" class="headerlink" title="8.5 中间人攻击"></a>8.5 中间人攻击</h2><p>中间人攻击（Man-in-the-MiddleAttack），简称<code>MITM攻击</code></p><p>以<code>8.2.2</code>的单非对称加密为例，中间人可以在整个过程中进行<strong>偷梁换柱</strong>，窃取双方的信息。如下图：</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ee26a502a69.png" alt="image-20230216205047679"></p><p>透过这个栗子🌰，实际上，如果中间人在客户端和服务端<strong>开始通信之前</strong>就来窃听并<strong>准备换柱</strong>了，他就有可能替换双方密钥，从而解密双方发送的信息！</p><p>最重要的一点，是客户端or服务端<strong>都没有办法证明</strong>，当前的公钥是直接从服务端or客户端发来的，它们没有办法检验公钥的权威性，只能被动接受。由此给中间人<code>偷梁换柱</code>提供了可能。</p><p>这时候，就需要引入CA机构和CA证书了👇</p><h2 id="8-6-CA证书"><a href="#8-6-CA证书" class="headerlink" title="8.6 CA证书"></a>8.6 CA证书</h2><p>所谓CA证书，是由<strong>CA机构</strong>颁发的权威证书。CA机构在颁发证书时，会在证书中附带上该站点的域名，以及申请人（企业）的相关信息</p><ul><li>CA机构会有一个自己的私钥和公钥，其公钥向<strong>所有人</strong>公开</li><li>CA机构的私钥由其自己保存（私钥一定不能泄露）</li><li>当下的浏览器、操作系统都会内置认可的CA；只有被认可的CA，才能为站点提供ssl证书服务</li></ul><p>在我们windows本地就能看到当前操作系统认可的CA机构其公钥；在edge浏览器中，点击右上角选择，进入设置，在选择隐私页面，找到<code>管理证书</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ee3dd712d42.png" alt="image-20230216222946008"></p><p>点击它，就能看到当前本地认可的CA</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ee3e40b1733.png" alt="image-20230216223131725"></p><h3 id="8-6-1-ssl证书加密原理"><a href="#8-6-1-ssl证书加密原理" class="headerlink" title="8.6.1 ssl证书加密原理"></a>8.6.1 ssl证书加密原理</h3><p>当一个站点获取了ssl证书后，在向用户发送ssl证书中包含的公钥的同时，还会发送一个<strong>由CA机构</strong>对ssl证书公钥做的<strong>数字签名</strong></p><ul><li>ssl证书公钥的数字签名A，通过CA机构的<strong>私钥</strong>进行加密</li><li>ssl证书的公钥B</li></ul><p>当客户端收到这份信息之后，会采用hash函数对收到的ssl证书公钥进行数字签名，得到一个<strong>本地生成的数字签名C</strong></p><p>再用CA机构的公钥对传输过来的数字签名A进行解密，得到数字签名A的明文；判断由CA机构生成的ssl公钥数字签名A是否和本地生成的数字签名C相同；</p><ul><li>如果相同，则代表证书正确！</li><li>不相同，代表证书出现错误！</li></ul><p>画个图，大概就是下面这样</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/63ee3aa8d2aa1.png" alt="image-20230216221611664"></p><p>由于当下发送的数据包中，同时存在ssl公钥的明文+由CA机构加密后的数字签名，中间人无法进行任何攻击修改！</p><ul><li>若修改ssl公钥，由于中间人没有CA机构的私钥，无法对修改后的ssl公钥生成对应的加密后数字签名</li><li>若使用CA公钥解密数字签名后修改……依旧会因为没有CA机构私钥，无法把修改后的签名加密回去</li><li>如果中间人用自己的私钥生成一个数字签名，但我不认识你这个CA，也不知道你的公钥是什么，怎么解密你的信息呢？</li></ul><p>综上，中间人要想偷梁换柱，只有一个办法了，那就是拿一个<strong>真的证书</strong>整体替换掉这个数据包。</p><p>可是ssl证书中还包含了<strong>域名、站点主体</strong>等各类信息，我当下访问的是<code>baidu.com</code>，结果收到的证书是<code>qq.com</code>的，那肯定有问题啊！浏览器会直接拒绝访问！😂</p><p>当我们访问一些网站，<strong>浏览器报ssl证书过期</strong>，也是会出现一定的安全问题的！如果一个网站没有使用https，那么在这个网站上进行用户登录等敏感操作的时候，一定不要设置和你其他平台相同的密码！</p><blockquote><p>当然，如果某个网页本来就只是提供文件公开下载功能的，比如下载linux系统的iso镜像，那么它不套用https也是情有可原的，因为压根没有必要！</p></blockquote><h3 id="8-6-2-ssl证书-非对称-对称"><a href="#8-6-2-ssl证书-非对称-对称" class="headerlink" title="8.6.2 ssl证书+非对称+对称"></a>8.6.2 ssl证书+非对称+对称</h3><p>有了上面这个不能被篡改的ssl证书公钥，下面我们就可以利用<code>非对称+对称加密</code>的方式进行通信了</p><ul><li>客户端收到ssl证书，向服务器发送一个本地生成的<strong>密钥D</strong>（使用ssl证书公钥进行加密）</li><li>服务端收到<strong>密钥D</strong>的加密信息，使用ssl证书的私钥进行解密，获取到密钥D</li><li>客户端和服务端使用<strong>密钥D</strong>进行对称加密通信</li></ul><p>这样即解决了安全问题，又规避了非对称加密的效率问题，一举多得！</p><h1 id="9-Content-Type"><a href="#9-Content-Type" class="headerlink" title="9.Content-Type"></a>9.Content-Type</h1><h2 id="9-1-问题"><a href="#9-1-问题" class="headerlink" title="9.1 问题"></a>9.1 问题</h2><p>之前写的http服务器有一个很大的弊端，就是<code>Content-Type</code>没能做到根据文件的格式进行自定义修改</p><p>默认情况下，如果<code>index.html</code>中没有指定icon的路径，浏览器会自动请求根路径下的<code>favicon.ico</code>，如果没有这个文件，则不显示站点图标。</p><p>如果在<code>index.html</code>有指定站点icon的路径，则会请求对应路径的图片。</p><p>如下图，我在index中指定了icon的路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>http协议学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://img.musnow.top/i/2022/12/icon.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是浏览器去请求的时候，返回的文件类型依旧是text（因为已经写死了）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641ea5c88f0fb.png" alt="image-20230325154201646"></p><p>最终结果就是，配置的icon无效，依旧不显示站点图标</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641ea5e899152.png" alt="image-20230325154233852"></p><p>所以，我们应该在服务端给返回的文件添加上正确的<code>Content-Type</code></p><h2 id="9-2-代码"><a href="#9-2-代码" class="headerlink" title="9.2 代码"></a>9.2 代码</h2><p>为了访问支持多种文件类型，我在tcpServer的类中新增了一个map，用于文件后缀和图标类型的对照。每每看到这个场景，我都想感慨一下：Python的dict还是方便多了🤣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _fileTypeMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;html&quot;</span>,<span class="string">&quot;text/html&quot;</span>&#125;);</span><br><span class="line">    _fileTypeMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;jpg&quot;</span>,<span class="string">&quot;image/jpeg&quot;</span>&#125;);</span><br><span class="line">    _fileTypeMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;jpeg&quot;</span>,<span class="string">&quot;image/jpeg&quot;</span>&#125;);</span><br><span class="line">    _fileTypeMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;png&quot;</span>,<span class="string">&quot;image/png&quot;</span>&#125;);</span><br><span class="line">    _fileTypeMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;gif&quot;</span>,<span class="string">&quot;image/gif&quot;</span>&#125;);</span><br><span class="line">    _fileTypeMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;ico&quot;</span>,<span class="string">&quot;image/x-icon&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文件类型和http响应头的对照表</span></span><br><span class="line">map&lt;string,string&gt; _fileTypeMap;</span><br></pre></td></tr></table></figure><p>在设置<code>Content-Type</code>的时候，先从path中分离出客户端请求的文件类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件的后缀</span></span><br><span class="line"><span class="function">string <span class="title">getFileType</span><span class="params">(<span class="type">const</span> string&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> i = path.<span class="built_in">rfind</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(i!=string::npos)<span class="comment">//找到了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">filetype</span><span class="params">(path,i+<span class="number">1</span>)</span></span>;<span class="comment">//获取出文件类型</span></span><br><span class="line">        <span class="built_in">logging</span>(DEBUG,<span class="string">&quot;Path: %s | fileType: %s&quot;</span>,path.<span class="built_in">c_str</span>(),filetype.<span class="built_in">c_str</span>()); <span class="comment">// 打印用作debug</span></span><br><span class="line">        <span class="keyword">return</span> filetype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">//没有后缀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，一些http请求是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://web.musnow.top/about/</span><br></pre></td></tr></table></figure><p>后端会收到这样的path</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/about/</span><br></pre></td></tr></table></figure><p>这个path里面并没有文件名，而本文前面提到过，如果请求的链接中没有指明文件，那就给客户返回对应路径下的<code>index.html</code>文件。如果这个路径下没有html文件，则返回404。这一步在分离请求头中的path时已经做了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对path进行判断，如果path是以/结尾的，则在path中追加index.html文件名</span></span><br><span class="line"><span class="keyword">if</span>(path[path.<span class="built_in">size</span>()<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    path += HOME_PAGE; <span class="comment">//加上被隐藏的index.html文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到正题，在获取到文件后缀后，就可以在map里面查找对应的<code>content-type</code>了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加正确的文件类型Content-Type</span></span><br><span class="line">response += <span class="string">&quot;Content-Type: &quot;</span>;</span><br><span class="line">string contentType = <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> it = fileTypeMap.<span class="built_in">find</span>(fileType);</span><br><span class="line"><span class="keyword">if</span>(it != fileTypeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">    contentType = (*it).second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response += contentType;</span><br><span class="line">response += <span class="string">&quot;\r\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>但是，这样还是出现了问题，图片没办法正常加载</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641ef64de1ce7.png" alt="image-20230325212535554"></p><p>F12打开开发者面板，可以看到服务器返回的响应头是正确的，但是依旧无法显示出图片</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641ef6606cfb1.png" alt="image-20230325212554345"></p><p>这是因为读取图片和读取html文件的操作是不一样。在读取html文件的时候，采用的是按行读取的策略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取txt文件</span></span><br><span class="line"><span class="function">string <span class="title">readTxtFile</span><span class="params">(<span class="type">const</span> string&amp; file_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是文件存在但是打开失败了，应该返回50x代表服务器处理错误</span></span><br><span class="line">    <span class="comment">// tcp是面向字节流的，文件需要用二进制打开</span></span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(file_path, ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in.<span class="built_in">is_open</span>()) <span class="comment">//文件打开失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;503&quot;</span>;<span class="comment">//文件打开失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    string content;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, line))</span><br><span class="line">    &#123;</span><br><span class="line">        content += line;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是图片文件应该需要一个完整的二进制流，而不是按行读取</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取图片文件</span></span><br><span class="line"><span class="function">string <span class="title">readImgFile</span><span class="params">(<span class="type">const</span> string&amp; file_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(file_path, ios::binary)</span></span>;</span><br><span class="line">    <span class="comment">// 打开失败，503</span></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;503&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ostringstream ss;</span><br><span class="line">    ss &lt;&lt; file.<span class="built_in">rdbuf</span>();</span><br><span class="line">    string content = ss.<span class="built_in">str</span>();</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了区别图片和html文件，我新增了一个用于判断文件后缀的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string imageType[] = &#123;<span class="string">&quot;png&quot;</span>,<span class="string">&quot;jpg&quot;</span>,<span class="string">&quot;gif&quot;</span>,<span class="string">&quot;jpeg&quot;</span>&#125;; <span class="comment">// 图片类型</span></span><br><span class="line"><span class="comment">// 判断请求头中文件类型是否为图片</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isImg</span><span class="params">(<span class="type">const</span> string&amp; fileType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t: imageType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果完全一致</span></span><br><span class="line">        <span class="keyword">if</span>(fileType == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终合并成同一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">readFile</span><span class="params">(<span class="type">const</span> string &amp;file_path,<span class="type">bool</span> is_img = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//其实这里应该分两种情况，一种是文件不存在，一种是文件打开失败了</span></span><br><span class="line">    <span class="comment">//如果是文件不存在，应该返回404</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">access</span>(file_path.<span class="built_in">c_str</span>(),<span class="number">0</span>)!=<span class="number">0</span>)<span class="comment">//判断文件是否存在，存在返回0</span></span><br><span class="line">    &#123;<span class="comment">//windows下相同作用的接口为_access，头文件io.h</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;404&quot;</span>;<span class="comment">//文件不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取对应的文件</span></span><br><span class="line">    <span class="keyword">if</span>(!is_img)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">readTxtFile</span>(file_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">readImgFile</span>(file_path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务函数里面，也做出了区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件的后缀</span></span><br><span class="line">string fileType = <span class="built_in">getFileType</span>(path);</span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">string content = <span class="built_in">readFile</span>(resources,<span class="built_in">isImg</span>(fileType));</span><br></pre></td></tr></table></figure><p>再次测试，成功！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641ef799b2d2f.png" alt="image-20230325213107462"></p><p>主页html文件中配置的log也正常显示出来了！（和原来的颜色不一样）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641ef7beab4a7.png" alt="image-20230325213144653"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/2885791654/">https://blog.musnow.top/posts/2885791654/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/http/">http</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm2.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1805390619/" title="【网络】http(s)协议 | content-length详解 | 转载"><img class="cover" src="/img/bg/gm15.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【网络】http(s)协议 | content-length详解 | 转载</div></div></a></div><div class="next-post pull-right"><a href="/posts/4060787526/" title="【网络】自定义协议 | 序列化和反序列化 | Jsoncpp"><img class="cover" src="/img/bg/gm19.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【网络】自定义协议 | 序列化和反序列化 | Jsoncpp</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/4145270627/" title="【Linux】网络原理"><img class="cover" src="/img/bg/gm4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-25</div><div class="title">【Linux】网络原理</div></div></a></div><div><a href="/posts/2887088349/" title="【Linux】实现守护进程 | 以tcpServer为例"><img class="cover" src="/img/bg/gm7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">【Linux】实现守护进程 | 以tcpServer为例</div></div></a></div><div><a href="/posts/368672249/" title="【Linux】来写一个udp的服务端+客户端"><img class="cover" src="/img/bg/gm22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">【Linux】来写一个udp的服务端+客户端</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">324</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-url"><span class="toc-text">1.1 url</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E6%A0%97%E5%AD%90-%E2%91%A0"><span class="toc-text">1.1.1 栗子 ①</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E6%A0%97%E5%AD%90-%E2%91%A1"><span class="toc-text">1.1.2 栗子 ②</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%9F%9F%E5%90%8D%E5%92%8C%E7%AB%AF%E5%8F%A3%E9%9A%90%E8%97%8F"><span class="toc-text">1.2 域名和端口隐藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-ip-%E7%AB%AF%E5%8F%A3"><span class="toc-text">1.3 ip:端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%8D%8F%E8%AE%AE%E4%BD%9C%E7%94%A8"><span class="toc-text">1.4 协议作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="toc-text">1.5 编码解码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-http%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.http协议请求格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%AF%BB%E5%8F%96%E5%A4%9A%E9%95%BF%EF%BC%9F"><span class="toc-text">2.1 读取多长？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%93%8D%E5%BA%94%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">2.2 响应的状态码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B"><span class="toc-text">3.实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-text">3.1 前端页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">3.2 服务端代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%B5%8B%E8%AF%95"><span class="toc-text">3.3 测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%90%8E%E7%AB%AF%E6%89%93%E5%8D%B0%E7%9A%84%E6%8A%A5%E6%96%87"><span class="toc-text">3.4 后端打印的报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%A1%A8"><span class="toc-text">3.5 常见参数表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-text">4.请求方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-GET"><span class="toc-text">4.1 GET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-POST"><span class="toc-text">4.2 POST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-GET-x2F-POST%E5%8C%BA%E5%88%AB"><span class="toc-text">4.3 GET&#x2F;POST区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%9B%B4%E5%A4%9A%E6%96%B9%E6%B3%95"><span class="toc-text">4.4 更多方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">5.状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%8A%B6%E6%80%81%E7%A0%81%E8%A1%A8"><span class="toc-text">5.1 状态码表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-404-x2F-403%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">5.2 404&#x2F;403状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-5xx%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">5.3 5xx状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-301-x2F-302%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">5.4 301&#x2F;302重定向</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-cookie-x2F-session"><span class="toc-text">6.cookie&#x2F;session</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-set-cookie"><span class="toc-text">6.1 set cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-1-cookie-path"><span class="toc-text">6.1.1 cookie path</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E4%BB%80%E4%B9%88%E6%98%AFcookie"><span class="toc-text">6.2 什么是cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-cookie-session"><span class="toc-text">6.3 cookie+session</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E9%95%BF%E7%9F%AD%E9%93%BE%E6%8E%A5"><span class="toc-text">7.长短链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Connection"><span class="toc-text">7.1 Connection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-http%E5%92%8Ctcp%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">7.2 http和tcp的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-pipeline"><span class="toc-text">7.3 pipeline</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-https"><span class="toc-text">8.https</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E4%B8%BA%E5%95%A5%E8%A6%81%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-text">8.1 为啥要加密？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F"><span class="toc-text">8.2 常见加密方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-text">8.2.1 对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-text">8.2.2 非对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E5%8F%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0"><span class="toc-text">8.2.3 双非对称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4-%E9%9D%9E%E5%AF%B9%E7%A7%B0-%E5%AF%B9%E7%A7%B0"><span class="toc-text">8.2.4 非对称+对称</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%95%B0%E6%8D%AE%E6%91%98%E8%A6%81%EF%BC%88%E6%8C%87%E7%BA%B9%EF%BC%89"><span class="toc-text">8.3 数据摘要（指纹）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-text">8.4 数字签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-text">8.5 中间人攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-CA%E8%AF%81%E4%B9%A6"><span class="toc-text">8.6 CA证书</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-1-ssl%E8%AF%81%E4%B9%A6%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86"><span class="toc-text">8.6.1 ssl证书加密原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-2-ssl%E8%AF%81%E4%B9%A6-%E9%9D%9E%E5%AF%B9%E7%A7%B0-%E5%AF%B9%E7%A7%B0"><span class="toc-text">8.6.2 ssl证书+非对称+对称</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Content-Type"><span class="toc-text">9.Content-Type</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E9%97%AE%E9%A2%98"><span class="toc-text">9.1 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E4%BB%A3%E7%A0%81"><span class="toc-text">9.2 代码</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3746722946/" title="【win】使用分区助手扩容C盘"><img src="https://img.musnow.top/i/2024/02/9247b21d9bbd6d8997a14dc33c912316.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【win】使用分区助手扩容C盘"></a><div class="content"><a class="title" href="/posts/3746722946/" title="【win】使用分区助手扩容C盘">【win】使用分区助手扩容C盘</a><time datetime="2024-02-02T01:15:20.000Z" title="发表于 2024-02-02 09:15:20">2024-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1277415323/" title="【Artalk】可信域名未配置导致的跨域访问问题"><img src="https://img.musnow.top/i/2024/01/6d160c66af4d1c70cfb05cce383131f8.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Artalk】可信域名未配置导致的跨域访问问题"></a><div class="content"><a class="title" href="/posts/1277415323/" title="【Artalk】可信域名未配置导致的跨域访问问题">【Artalk】可信域名未配置导致的跨域访问问题</a><time datetime="2024-01-31T03:40:00.000Z" title="发表于 2024-01-31 11:40:00">2024-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4252514363/" title="【MySQL】内置函数"><img src="https://img.musnow.top/i/2023/04/64302610057ae.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【MySQL】内置函数"></a><div class="content"><a class="title" href="/posts/4252514363/" title="【MySQL】内置函数">【MySQL】内置函数</a><time datetime="2024-01-30T07:45:00.000Z" title="发表于 2024-01-30 15:45:00">2024-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1572064315/" title="【MySQL】用户管理"><img src="https://img.musnow.top/i/2023/04/64302610057ae.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【MySQL】用户管理"></a><div class="content"><a class="title" href="/posts/1572064315/" title="【MySQL】用户管理">【MySQL】用户管理</a><time datetime="2024-01-30T01:40:00.000Z" title="发表于 2024-01-30 09:40:00">2024-01-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>