<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【C++】C++11的那些新特性 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本篇博客，让我们一起来看看C++11的那些新特性！"><meta property="og:type" content="article"><meta property="og:title" content="【C++】C++11的那些新特性"><meta property="og:url" content="https://blog.musnow.top/posts/2016080368/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="本篇博客，让我们一起来看看C++11的那些新特性！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm23.png"><meta property="article:published_time" content="2022-09-28T04:20:46.000Z"><meta property="article:modified_time" content="2024-04-12T01:01:19.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="数据结构"><meta property="article:tag" content="Cpp11"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm23.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/2016080368/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【C++】C++11的那些新特性",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-04-12 09:01:19"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><link rel="stylesheet" href="/rating/rating.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">439</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/rating/"><i class="fa-fw fas fa-film"></i><span> 书·影</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnow.blog.csdn.net/"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm23.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/rating/"><i class="fa-fw fas fa-film"></i><span> 书·影</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnow.blog.csdn.net/"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【C++】C++11的那些新特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T04:20:46.000Z" title="发表于 2022-09-28 12:20:46">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-12T01:01:19.000Z" title="更新于 2024-04-12 09:01:19">2024-04-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Cpp/">Cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【C++】C++11的那些新特性"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本篇博客，让我们一起来看看C++11的那些新特性！</p><span id="more"></span><blockquote><p>所使用的编译器：VS2019</p><p>本篇博客所有的测试源码都可以在我的<a target="_blank" rel="noopener" href="https://gitee.com/musnow/learn_cpp_code/tree/master/Code/22-09-21%20C++11">GITEE仓库</a>找到</p></blockquote><p>[TOC]</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>C++11是C++的标准委员会在<code>2011</code>年更新的C++新特性。说白了就是一个升级包。和<code>JAVA\PYTHON</code>这种更新比较频繁的语言相比，C++更新的就没有那么顺风顺水了，而且每一次更新虽然修复了一些问题，但也带来了更多的“没太大必要”的更新</p><blockquote><p>比如没啥用的<code>array</code>容器，和<code>int arr[10]</code>这种内置方式的区别主要在于越界检查</p></blockquote><p>不过咱们这种小菜鸡，只有学习的权力，哪有啥资格评定C++标准呢？我听大佬说，现在最关注的C++更新便是<code>网络库</code>的上线了，不过那个貌似得等到<code>C++23</code>去了</p><p>话不多说，让我们来康康一些C++11的新功能吧！</p><hr><h2 id="2-列表-初始化"><a href="#2-列表-初始化" class="headerlink" title="2.列表{}初始化"></a>2.列表<code>&#123;&#125;</code>初始化</h2><p>C++11更新了初始化方式，不管是什么类型的数据，我们都可以用花括号的方式进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestA</span>&#123;</span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">	<span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	TestA t1 = &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我们已经习惯于用这张方式来初始化数组或者结构体，这在<code>C++98</code>中已经支持</p><p>而<code>C++11</code>则在这种玩法之上，又增添了一部分新操作，那就是直接用花括号初始化，你甚至可以把<code>=</code>给省略了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr2[]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr3[<span class="number">5</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">TestA t2&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>不过上面这种写法没有什么意义，还增加了代码理解的难度，不如直接用原本的写法。</p><p>更多时候，我们是在<code>new</code>初始化多个数据的时候使用这种方式。</p><h3 id="2-1-new初始化多个数据"><a href="#2-1-new初始化多个数据" class="headerlink" title="2.1 new初始化多个数据"></a>2.1 new初始化多个数据</h3><p>在<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/125456615?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166372085116782391821730%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166372085116782391821730&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-125456615-null-null.nonecase&utm_term=new&spm=1018.2226.3001.4450">动态内存管理</a>那一章节，我们学习了new的两种使用方式，也提到了<code>()/[]</code>这两个括号的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);<span class="comment">//开辟一个int的空间，并初始化为3赋值给p1</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];<span class="comment">//开辟3个int的空间，不进行初始化</span></span><br></pre></td></tr></table></figure><p>在C++11中，我们可以直接用花括号，对new开拼出来的数组进行批量初始化。打印的时候，可以看到<code>p2</code>中的数据都是没有进行初始化（vs也报了警告）而<code>p3</code>中的数据都完成了初始化</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210847797.png" alt="image-20220921084746745"></p><p>对于结构体数据而言，我们可以用花括号直接调用其构造函数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210852145.png" alt="image-20220921085232082"></p><p>其中<code>t5</code>是发生了隐式类型转换+调用构造函数进行的初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestA t5 = &#123; <span class="number">1</span>, <span class="number">3</span> &#125;;<span class="comment">//对类来说，会进行隐式类型转换+调用构造函数</span></span><br></pre></td></tr></table></figure><p>通过调试+打断点可以看到其调用了构造函数进行初始化</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210856028.png" alt="image-20220921085614990"></p><p>同样的，调用new的时候，我们可以用多个花括号的方式进行批量初始化。这在<code>new</code>一个对象数组的时候非常方便</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210858913.png" alt="image-20220921085853852"></p><h3 id="2-2-initializer-list"><a href="#2-2-initializer-list" class="headerlink" title="2.2 initializer_list"></a>2.2 initializer_list</h3><h4 id="2-2-1-STL容器初始化"><a href="#2-2-1-STL容器初始化" class="headerlink" title="2.2.1 STL容器初始化"></a>2.2.1 STL容器初始化</h4><p>不光是我们自己写的类、内置类型可以使用这种方式进行初始化，<code>stl</code>库里面的容器也可以使用相同方式进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;<span class="comment">//不建议这么写</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210904864.png" alt="image-20220921090452829"></p><p>同样的，我们还可以用类似的方式初始化<code>vector</code>内部的对象</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210908252.png" alt="image-20220921090818162"></p><p>作为容器的一份子，<code>map</code>也有一个利用<code>il</code>进行初始化的构造函数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210921012.png" alt="image-20220921092157950"></p><p>使用方式和之前提到的没啥区别，这里就不多讲啦</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1 = &#123; &#123;<span class="number">10</span>, <span class="number">20</span>&#125;,&#123; <span class="number">30</span>,<span class="number">40</span>&#125;,&#123;<span class="number">50</span>,<span class="number">60</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : m1) &#123;</span><br><span class="line">	cout &lt;&lt; e.first &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; e.second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210926747.png" alt="image-20220921092623710"></p><p>你可能会好奇，这种初始化的底层是怎么实现的？那么就要提到<code>c++11</code>新增的一个容器了</p><h4 id="2-2-2-initializer-list-容器"><a href="#2-2-2-initializer-list-容器" class="headerlink" title="2.2.2  initializer_list 容器"></a>2.2.2 initializer_list 容器</h4><p>如果你把<code>vector</code>等容器的版本设定为<code>C++11</code>，看文档的时候便会发现C++11新增了一个用<code>initializer_list</code>进行初始化的操作</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210911187.png" alt="image-20220921091125133"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210913024.png" alt="image-20220921091333991"></p><p>再来看看<code>initializer_list</code>，这不就是我们刚刚用的花括号嘛？</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210914769.png" alt="image-20220921091414719"></p><p>这个容器的成员函数很少，只有两个迭代器以及<code>size()</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210914108.png" alt="image-20220921091451066"></p><p>它最重要的特性，便是当我们使用<code>auto</code>自动推到参数类型的时候，<code>&#123;1,2,3,4&#125;</code>这种类型会被推到成<code>initializer_list</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(il).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//initializer_list </span></span><br></pre></td></tr></table></figure><p>因为他有迭代器，所以我们也可以使用范围for进行打印操作</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209210917571.png" alt="image-20220921091705529"></p><p>个人理解，当其他容器使用<code>initializer_list</code>进行初始化的时候，本质上调用的接口和利用迭代器进行初始化是一样的</p><h4 id="2-3-1-插入il"><a href="#2-3-1-插入il" class="headerlink" title="2.3.1 插入il"></a>2.3.1 插入il</h4><p>部分容器的<code>insert</code>函数也添加了使用<code>il</code>进行插入连续数据的操作</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209211410896.png" alt="image-20220921141039836"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s2 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">s2.<span class="built_in">insert</span>(&#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;);</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209211412155.png" alt="image-20220921141224119"></p><p>在<code>vector</code>中使用<code>il</code>插入的时候，需要指定pos位置这个和<code>vector</code>的其他几个插入函数是一样的</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209211413842.png" alt="image-20220921141342802"></p><h3 id="2-4-模拟实现il构造函数"><a href="#2-4-模拟实现il构造函数" class="headerlink" title="2.4 模拟实现il构造函数"></a>2.4 模拟实现il构造函数</h3><p>那么，如何让我们自己模拟实现的<code>vector</code>也能支持这个功能呢？【<a target="_blank" rel="noopener" href="https://gitee.com/musnow/learn_cpp_code/tree/master/Code/22-07-12%20Vector">模拟实现vector源码</a>】</p><p>和<code>STL</code>库里面的代码一样，添加上<code>initializer_list</code>的构造函数即可</p><p>因为<code>il</code>容器已经有了它自己的迭代器，我们完全可以复用迭代器构造的操作，直接进行遍历然后<code>push_back</code>即可！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializer_list构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> initializer_list&lt;T&gt;&amp; il)</span><br><span class="line">    :_start(<span class="literal">nullptr</span>),</span><br><span class="line">    _finish(<span class="literal">nullptr</span>),</span><br><span class="line">    _endofstorage(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : il) &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209211004435.png" alt="image-20220921100435380"></p><p>试试自定义类型，也可以很好的支持！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209211009892.png" alt="image-20220921100902826"></p><p>这里还有一个优化的地方，那便是开始构造的时候，直接给vector开对应<code>il size()</code>的空间大小，避免后续<code>push_back</code>的时候需要多次扩容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializer_list构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> initializer_list&lt;T&gt;&amp; il)</span><br><span class="line">    :_start(<span class="literal">nullptr</span>),</span><br><span class="line">_finish(<span class="literal">nullptr</span>),</span><br><span class="line">_endofstorage(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">reserve</span>(il.<span class="built_in">size</span>());<span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : il) &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>调试</strong>能发现达成了我们的需求（因为调试步骤太多，截图不方便，这里就不演示了。感兴趣的老哥可以去我的gitee仓库下源码自己试试）</p><h2 id="3-变量声明"><a href="#3-变量声明" class="headerlink" title="3.变量声明"></a>3.变量声明</h2><p>C++11提供了多种简化的<code>声明/定义</code>方式，比如我们熟悉的auto</p><h3 id="3-1-auto"><a href="#3-1-auto" class="headerlink" title="3.1 auto"></a>3.1 auto</h3><blockquote><p><code>C++98</code>中auto是一个存储类型的说明符，表明变量是局部自动存储类型，但是局部域中定义局 部的变量默认就是自动存储类型，所以auto就没什么价值了。</p></blockquote><p>C++11给auto上了实现自动类型推断的全新功能，方便我们在定义一个变量的时候直接用<code>auto</code>进行类型推导</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> num = <span class="number">1</span>;<span class="comment">//int</span></span><br><span class="line"><span class="keyword">auto</span> p = &amp;num;<span class="comment">//int*</span></span><br></pre></td></tr></table></figure><p>需要注意的是，如果想用<code>auto</code>推到，则必须初始化。只给一个<code>auto i</code>是不行的！</p><p><code>auto</code>还可以用于范围for等其他操作，这些都在之前讲解这个<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/124735178?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166372704716800180658052%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166372704716800180658052&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-124735178-null-null.nonecase&utm_term=auto&spm=1018.2226.3001.4450">关键字的博客中</a>有提到，这里就不多说了！</p><hr><h3 id="3-2-decltype"><a href="#3-2-decltype" class="headerlink" title="3.2 decltype"></a>3.2 decltype</h3><p>关键字<code>decltype</code>可以把变量声明成我们想要的目标类型；可以理解为和<code>typedef</code>的作用有一定的类似，但是它是可以自动推导的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> sum = a * b;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;type(sum) &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(sum).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(a * b) num; <span class="comment">// 把a*b的类型声明为num</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;sum) ptr;  <span class="comment">// 把&amp;sum的类型声明为ptr</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;type(a*b)  &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(num).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;type(&amp;sum) &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(ptr).<span class="built_in">name</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209211035904.png" alt="image-20220921103529856"></p><p>怎么样，是不是觉得很神奇？很方便？</p><p>需要注意的是，使用<code>decltype</code>关键字来指定函数指针的时候，函数名和函数参数之间需要加上<code>&amp;</code>，否则无法正确推导类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(add) &amp;(<span class="type">int</span>, <span class="type">int</span>) <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">decltype</span>(add) (<span class="type">int</span>, <span class="type">int</span>) <span class="comment">// 错误    </span></span><br></pre></td></tr></table></figure><hr><p>那让我们来看看另外一个语言声明变量的方式吧！😂 压根不需要变量类型捏（因为python是弱类型的语言）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Python</span></span><br><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="built_in">sum</span> = a*<span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">sum</span>))</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209211037051.png" alt="image-20220921103738018"></p><p>要是<code>C++</code>也有这么方便就好了😭</p><h3 id="3-3-typeid"><a href="#3-3-typeid" class="headerlink" title="3.3 typeid"></a>3.3 typeid</h3><p>这个关键字上面已经用过好几次了，就是用来打印变量的类型的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;type(a) &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><hr><h2 id="4-左-x2F-右值引用"><a href="#4-左-x2F-右值引用" class="headerlink" title="4.左&#x2F;右值引用"></a>4.左&#x2F;右值引用</h2><p>在之前我们学习了引用的基本操作，但那个是<code>左值引用</code>。当时我们尚未引入左指引用和右值引用的区别。本篇博客里面将会详细讲解~</p><h3 id="4-1-左值-x2F-右值区别"><a href="#4-1-左值-x2F-右值区别" class="headerlink" title="4.1 左值&#x2F;右值区别"></a>4.1 左值&#x2F;右值区别</h3><p>要解答这两种引用的区别，首先我们需要直到<code>左值/右值</code>分别代指什么</p><p>左值：</p><ul><li>可以存在于<code>=</code>左边或右边</li><li>可以取地址</li><li>可以对它赋值（const除外）</li></ul><p>右值：</p><ul><li>右值是一个表示数据的表达式，比如：函数返回值<code>[不能是左值引用返回的]</code>、表达式返回值<code>A+B</code>、字面常量<code>10</code></li><li>右指只能出现在<code>=</code>的右边，不能出现在左边（俺可没见过<code>A+B=C</code>的代码语法）</li><li>右指不能取地址</li></ul><p>左值和右值最大的区别便是：<font color="Red">左值可以取地址，右值不能取地址</font>。</p><h4 id="4-1-1-将亡值（概念）"><a href="#4-1-1-将亡值（概念）" class="headerlink" title="4.1.1 将亡值（概念）"></a>4.1.1 将亡值（概念）</h4><p><strong>右值</strong>还分为两种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯右值</span></span><br><span class="line"><span class="number">10</span>;</span><br><span class="line">a+b;</span><br><span class="line"><span class="built_in">Add</span>(a,b); <span class="comment">// 返回值是右值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将亡值</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;1111&quot;</span>)</span></span>;<span class="comment">// &quot;1111&quot; 是将亡值</span></span><br><span class="line">string s2 = <span class="built_in">to_string</span>(<span class="number">1234</span>);<span class="comment">// to_string的return对象是一个将亡值</span></span><br><span class="line">string s3 = s1+<span class="string">&quot;hello&quot;</span> <span class="comment">// 相加重载的return对象是一个将亡值</span></span><br><span class="line"><span class="built_in">move</span>(s1);<span class="comment">// 被move之后的s1也是将亡值</span></span><br></pre></td></tr></table></figure><p>在右值引用的介绍中将用上<strong>将亡值</strong>的概念。</p><h3 id="4-2-左值引用"><a href="#4-2-左值引用" class="headerlink" title="4.2 左值引用"></a>4.2 左值引用</h3><p>左值引用就是对左值的引用。我们之前学习的就是这一类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a、b、c、*a都是左值</span></span><br><span class="line"><span class="comment">// 对象内部的*this也是左值</span></span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 以下是对上面左值的 左值引用</span></span><br><span class="line"><span class="type">int</span>*&amp; rp = a;</span><br><span class="line"><span class="type">int</span>&amp; rb = b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rc = c;</span><br><span class="line"><span class="type">int</span>&amp; p = *a;</span><br><span class="line"><span class="comment">// 引用相当于别名，修改引用后的内容相等于修改原本的参数</span></span><br></pre></td></tr></table></figure><p>之前也提到了，其作用主要是在针对出了<strong>作用域不会销毁</strong>的变量进行<strong>引用返回</strong>，以节省拷贝的代价。亦或者是引用传参，减少形参拷贝代价。</p><h3 id="4-3-右值引用"><a href="#4-3-右值引用" class="headerlink" title="4.3 右值引用"></a>4.3 右值引用</h3><p>来看看几个比较常见的右值吧，其中<code>Add</code>是一个简单的相加函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">1.1</span>, y = <span class="number">2.2</span>;</span><br><span class="line"><span class="comment">// 常见的右值</span></span><br><span class="line"><span class="number">10</span>;</span><br><span class="line">x + y;</span><br><span class="line"><span class="built_in">Add</span>(x, y);</span><br><span class="line"><span class="comment">// 以下都是对右值的右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rr1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span>&amp;&amp; rr2 = x + y;</span><br><span class="line"><span class="type">double</span>&amp;&amp; rr3 = <span class="built_in">Add</span>(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//右值不能出现在=的左边</span></span><br><span class="line"><span class="comment">//10 = 1;</span></span><br><span class="line"><span class="comment">//x + y = 1;</span></span><br><span class="line"><span class="comment">//fmin(x, y) = 1;</span></span><br></pre></td></tr></table></figure><p>虽然我们不能直接对右值进行<code>取地址/赋值</code>操作，但是在右值引用过后，便可以对引用值进行<code>取地址/赋值</code>操作（右值引用后的变量是一个左值，或者说右值引用本身是个左值）</p><blockquote><p>这是因为右值引用的时候，会把当前引用的数据放入一个位置存起来。存放位置：普通变量在<code>栈</code>，全局变量&#x2F;静态变量在<code>静态区</code>（没有验证过，可能不对）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rr1 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; rr1  &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">rr1 = <span class="number">3</span>;</span><br><span class="line">cout &lt;&lt; rr1 &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"><span class="type">int</span>* p = &amp;rr1;</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; rr1 &lt;&lt; endl; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209211212161.png" alt="image-20220921121232109"></p><p>如果你不喜欢右值引用被修改，则可以使用<code>const</code>进行修饰。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209211216501.png" alt="image-20220921121611461"></p><h3 id="4-4-两个引用的区别"><a href="#4-4-两个引用的区别" class="headerlink" title="4.4 两个引用的区别"></a>4.4 两个引用的区别</h3><p>用一个表格来总结二者的区别</p><table><thead><tr><th>左值引用</th><th>右值引用</th></tr></thead><tbody><tr><td>只能引用左值</td><td>只能引用右值</td></tr><tr><td>const左值引用可同时引用左值&#x2F;右值</td><td>可引用<code>move</code>后的左值</td></tr></tbody></table><h4 id="4-4-1-move"><a href="#4-4-1-move" class="headerlink" title="4.4.1 move"></a>4.4.1 move</h4><p>move可以把左值换成右值，但<strong>不能</strong>把右值转左值</p><blockquote><p>谨慎使用<code>move</code>，如果当前对象在后续还需要使用，则不能<code>move</code>将其改为右值，否则可能资源被掠夺导致该对象失效！</p></blockquote><p>以简单的A对象为例，这个对象中有一个公有成员<code>int _a</code>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>) : _a(a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create \n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete A &quot;</span> &lt;&lt; _a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="number">10</span>;</span><br><span class="line">std::<span class="built_in">move</span>(a);</span><br><span class="line">cout &lt;&lt; a._a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>当我们move了a对象后，因为没有其他人来对a做移动操作，所以a对应的空间都还是存在的，此时访问a不会有问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="number">10</span>;</span><br><span class="line">A b = std::<span class="built_in">move</span>(a);</span><br><span class="line">cout &lt;&lt; a._a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>此时我们用move将a赋值给了b，但依旧可以访问a中的成员。因为这个成员是一个内置类型，虽然被移动给了b，但是a对象本身并不会被move销毁。执行这个代码可以看到，构造函数只在构造a的时候被调用了一次，b对象并没有调用构造函数（而是调用了编译器默认生成的拷贝构造）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ g++  test.cpp -o test1 &amp;&amp; ./test1</span><br><span class="line">create </span><br><span class="line">10</span><br><span class="line">delete A 10</span><br><span class="line">delete A 10</span><br></pre></td></tr></table></figure><p>这个测试的结论是：move只是将a对象标记为“将亡值”，并不会对这个对象本身做任何操作。被move的对象在后续仍然可以使用，但这并不是推荐的做法，最好不要这么做！</p><p>比如当你将一个智能指针<code>unique_ptr&lt;int&gt; sp1</code>通过move移动给了sp2对象，此时sp1就完全不能使用了，解引用sp1会发生解引用空指针的段错误！</p><h3 id="4-4-2-右值引用函数传值"><a href="#4-4-2-右值引用函数传值" class="headerlink" title="4.4.2 右值引用函数传值"></a>4.4.2 右值引用函数传值</h3><blockquote><p>这道题是在大厂的笔试选择题中遇到的。</p></blockquote><p>下面的例子可以体现出右值引用的性质：右值引用<strong>本身是一个左值</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int&amp;\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const int&amp;\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int&amp;&amp;\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const int&amp;&amp;\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">test</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>见main函数里面的代码，我们将a使用move函数改为右值后传入test函数，再调用test_func，最终调用的是<code>int&amp;</code>这个函数！这是因为test函数中的<code>int&amp;&amp; a</code>作为右值引用，本身是一个左值，自然会调用左值引用的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ test.cpp -o test &amp;&amp; ./test</span><br><span class="line">int&amp;</span><br></pre></td></tr></table></figure><p>如果不存在<code>int&amp;</code>的函数，则会调用<code>const int&amp;</code>的函数。如果没有左值引用的函数重载，则会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test.cpp: In function ‘void test(int&amp;&amp;)’:</span><br><span class="line">test.cpp:511:15: error: cannot bind rvalue reference of type ‘int&amp;&amp;’ to lvalue of type ‘int’</span><br><span class="line">  511 |     test_func(a);</span><br><span class="line">      |               ^</span><br><span class="line">test.cpp:499:22: note:   initializing argument 1 of ‘void test_func(int&amp;&amp;)’</span><br><span class="line">  499 | void test_func(int&amp;&amp; a)</span><br><span class="line">      |                ~~~~~~^</span><br></pre></td></tr></table></figure><h3 id="4-5-右值引用使用场景"><a href="#4-5-右值引用使用场景" class="headerlink" title="4.5 右值引用使用场景"></a>4.5 右值引用使用场景</h3><p>右值引用可以提高<code>移动构造/移动赋值</code>等深拷贝场景的效率</p><p>什么场景可以使用左值引用提高效率?</p><ul><li>操作符重载：前置++</li><li>操作符重载：<code>+=</code></li><li>出了作用域后不会销毁的变量，如输出型参数（即传入函数进行处理的参数）</li></ul><p>而有一些场景是左值引用无法处理的：</p><ul><li>操作符重载：后置++（需要返回一个全新变量）</li><li>操作符重载：<code>+</code>（需要返回一个全新变量）</li><li>模拟实现string中的<code>to_string</code>函数</li></ul><p>这些场景大多有一个特性，那就是会生成一个全新的变量（对象）其对象生命周期出了函数作用域便会销毁（将亡值）</p><p>如果使用左值引用返回，就会出现<strong>访问已经销毁了的对象</strong>的错误。</p><blockquote><p>假设我们有一个<code>vector&lt;vector&lt;int&gt;&gt;</code>，若内部的<code>vector</code>很大的时候，拷贝构造的代价是很大的！</p></blockquote><h4 id="4-5-1-输出型参数"><a href="#4-5-1-输出型参数" class="headerlink" title="4.5.1 输出型参数"></a>4.5.1 输出型参数</h4><p>如果在<code>C++98</code>的情况下，我们只能用<strong>输出型参数</strong>来解决这个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; <span class="built_in">test</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;v1,<span class="type">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="comment">//v1就是一个输出型参数。放入该函数进行操作后原路返回</span></span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-2-右值引用-移动构造"><a href="#4-5-2-右值引用-移动构造" class="headerlink" title="4.5.2 右值引用 移动构造"></a>4.5.2 右值引用 移动构造</h4><p>在<code>C++11</code>中，我们可以使用右值引用的拷贝构造来解决这个问题</p><p>下方就是一个具体示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">muxue::string <span class="title">to_string</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        val = <span class="number">0</span> - val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    muxue::string str;</span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = val % <span class="number">10</span>;</span><br><span class="line">        val /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        str += (<span class="string">&#x27;0&#x27;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="literal">false</span>)&#123;</span><br><span class="line">       str += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认情况下，如果想使用这个<code>to_string</code>函数，就需要进行<strong>深拷贝</strong>进行传值返回。这是无可避免的代价</p><p>如果使用左值引用返回，这里就会有bug。因为出了函数作用域后，临时对象<code>str</code>会被销毁。而如果我们使用左值引用取别名，在进行赋值的时候，便会出现利用str的别名进行拷贝构造，而str是一个<strong>已经销毁的对象</strong>的问题</p><hr><p>而如果我们使用右值引用返回，则不会出现这种问题。前提是我们自己实现了右值引用的构造函数和赋值重载</p><blockquote><p>一般我们把右值引用的构造函数&#x2F;赋值重载称作<code>移动构造/移动赋值</code></p></blockquote><p>为什么叫移动呢？因为右值引用是会直接拿取<strong>对象的资源</strong></p><h5 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h5><p>我们可以先用库里面的<code>string</code>观察一下，当我们使用move之后的右值进行构造的时候，会直接拿掉对象的资源！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;1234134&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(move(s1))</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209212158720.png" alt="image-20220921215819620"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209212159705.png" alt="image-20220921215905594"></p><p>而在使用右值进行返回的时候，编译器会进行一波优化，直接使用<strong>移动构造</strong>拿取资源，避免多次<strong>拷贝构造</strong>造成的空间和时间损失</p><p>在处理这种问题的时候，就比输出型参数好太多了。</p><hr><h5 id="my-string"><a href="#my-string" class="headerlink" title="my::string"></a>my::string</h5><p>不过库里面的<code>string</code>涉及到了<code>buf</code>之类的高级操作，也不适合我们调试查看调用的具体情况。所以这里我们再使用自己写的string来演示一下</p><blockquote><p>这里我还发现了之前模拟实现string的一个bug，在<code>push_back</code>操作的时候，没有给末尾加上<code>\0</code>，导致析构的时候报错了</p><ul><li>模拟实现string代码见我的gitee仓库【<a target="_blank" rel="noopener" href="https://gitee.com/musnow/learn_cpp_code/tree/master/Code/22-09-21%20C++11">传送门</a>】</li></ul></blockquote><p>在演示之前，我们先要实现自己的<code>移动构造/移动赋值</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动赋值</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(string&amp;&amp; s)&#123;</span><br><span class="line">    <span class="built_in">swap</span>(s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动拷贝</span></span><br><span class="line"><span class="built_in">string</span>(string&amp;&amp; s)</span><br><span class="line">    :_a(<span class="literal">nullptr</span>),</span><br><span class="line">    _size(<span class="number">0</span>),</span><br><span class="line">    _capa(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我直接复用了之前已经写好的一个<code>swap</code>函数，实现了一个“现代写法”的构造，直接<strong>交换</strong>了二者的资源。避免<strong>深拷贝</strong>带来的副作用</p><hr><p>接下来用下面的几个来测试一下拷贝构造的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">muxue::string s1 = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="function">muxue::string <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">muxue::string s3 = muxue::<span class="built_in">to_string</span>(<span class="number">5678</span>);<span class="comment">//移动构造</span></span><br><span class="line">muxue::string s4 = s1 + s3;<span class="comment">//拷贝构造+移动构造</span></span><br></pre></td></tr></table></figure><p>通过在构造函数中添加打印，可以看出这几个分别调用了什么构造函数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221255998.png" alt="image-20220922125542908"></p><ul><li>s2调用了深拷贝构造，因为s1是一个左值</li><li>s3调用了移动构造，因为<code>to_string</code>函数中<code>return</code>的是一个将亡值</li><li>s4先是在<code>运算符+重载</code>中调用深拷贝构建了一个<code>string</code>的临时对象，在使用移动构造进行<code>return</code></li></ul><p>运算符<code>+重载</code>的代码如下，和<code>to_string</code>一样，都是<code>return</code>了一个将亡值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相加重载</span></span><br><span class="line">string <span class="keyword">operator</span>+(<span class="type">const</span> string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">muxue::string <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    tmp += s;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个对象move成为右值之后，便可以使用<strong>移动赋值</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221337170.png" alt="image-20220922133745127"></p><h5 id="移动构造直接移动资源"><a href="#移动构造直接移动资源" class="headerlink" title="移动构造直接移动资源"></a>移动构造直接移动资源</h5><p>这时候如果调用拷贝构造，就很是浪费：</p><ul><li>本来tmp的资源就要销毁了，你还得先把他的资源<strong>复制</strong>一份给自己，再销毁tmp</li><li>那为何不把tmp的资源直接拿给自己呢？省去了复制的消耗！</li></ul><p>这便是移动构造的优势之处！</p><p>调试体现出来的，便是深拷贝中两个对象<code>_a</code>的地址完全不同</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221318516.png" alt="image-20220922131819426"></p><p>而移动构造是直接把s1的<code>_a</code>资源拿了过来！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221318856.png" alt="image-20220922131852768"></p><p>其最明显的特征，便是s3的<code>_a</code>地址就是s1的！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221319823.png" alt="image-20220922131947785"></p><h5 id="STL的更新"><a href="#STL的更新" class="headerlink" title="STL的更新"></a>STL的更新</h5><p>如果我们把自己模拟实现的移动构造删除，那么所有的return都会去调用深拷贝，代价就很大了。对象很大的时候，来一次深拷贝有可能可以把整个系统干废😂</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221313180.png" alt="image-20220922131350127"></p><p>所有<code>STL</code>的容器，在C++11之后，都支持了右值引用的插入、移动构造和移动赋值。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221322836.png" alt="image-20220922132259803"></p><p><code>C++11</code>的<code>swap</code>也提供了一个直接使用右值进行资源替换的版本，效率更高</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221322209.png" alt="image-20220922132209159"></p><h3 id="4-6-编译器优化"><a href="#4-6-编译器优化" class="headerlink" title="4.6 编译器优化"></a>4.6 编译器优化</h3><p>在之前有关构造函数的博客里面有提到过，当我们<code>return</code>一个对象的时候，编译器会把两次拷贝构造优化成一次</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221332514.png" alt="image-20220922133226446"></p><p>和拷贝构造一样，执行移动构造的时候，编译器也有一定的优化</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209221332966.png" alt="image-20220922133233909"></p><p>不过这个优化就取决于编译器的处理了。不排除有些编译器没有做此等处理哦！</p><h3 id="4-7-优化插入效率"><a href="#4-7-优化插入效率" class="headerlink" title="4.7 优化插入效率"></a>4.7 优化插入效率</h3><p>有了右值引用，只要我们实现一个右值引用方式的插入，也可以优化插入时的效率</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">muxue::list&lt;muxue::string&gt; t;</span><br><span class="line"><span class="function">muxue::string <span class="title">s1</span><span class="params">(<span class="string">&quot;111&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//调用拷贝构造，左值</span></span><br><span class="line">t.<span class="built_in">push_back</span>(s1);</span><br><span class="line"><span class="comment">//调用移动构造，右值</span></span><br><span class="line">t.<span class="built_in">push_back</span>(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">t.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s1));</span><br></pre></td></tr></table></figure><h2 id="5-完美转发-万能引用"><a href="#5-完美转发-万能引用" class="headerlink" title="5.完美转发(万能引用)"></a>5.完美转发(万能引用)</h2><p><code>c++11</code>提供了一个万能引用，既可以引用左值，也可以引用右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;const 左值引用&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;&amp; x)</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;const 右值引用&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(T&amp;&amp; t)</span></span>&#123;<span class="comment">//T&amp;&amp;就是一个万能引用</span></span><br><span class="line">	<span class="built_in">Fun</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过测试上面的代码我们会发现，不管是传入一个左值还是传入一个右值，其都会调用左值引用。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231638882.png" alt="image-20220923163807798"></p><p>这是因为右值引用之后，形参<code>t</code>就是一个左值，所以调用了左值的函数。（右值引用本身是个左值）</p><blockquote><p>我们也不能粗暴的使用<code>move</code>来解决这里的问题，因为有时候一些左值对象在后续还是需要使用的，<code>move</code>之后变成右值，资源被拿走了咋办！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">&gt;<span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">Fun</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231645696.png" alt="image-20220923164521638"></p></blockquote><p>而<strong>完美转发</strong>的存在就是为了将右值保持其右值属性，依旧调用右值对应的函数，其语法如下，使用<code>forward</code>函数进行完美转发</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Fun</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候第二种情况就正确掉用了对应的右值引用函数，也没有改变左值的属性</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231640165.png" alt="image-20220923164010101"></p><p>再把函数改成我们自己写的string，也能看出完美转发的作用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line">	muxue::string s = std::forward&lt;T&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231708276.png" alt="image-20220923170856230"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231710906.png" alt="image-20220923171012855"></p><h3 id="5-1-使用场景"><a href="#5-1-使用场景" class="headerlink" title="5.1 使用场景"></a>5.1 使用场景</h3><p>有些场景下，我们需要对一个函数传入不同类型的参数，这时候就需要用<code>万能引用+完美转发</code>来进行不同的处理</p><p>比较典型的便是很多STL容器都提供了一个新的尾插函数<code>emplace_back</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231723264.png" alt="image-20220923172318225"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>这里便使用了<strong>万能引用</strong>，以及可变模板参数（后面会提到关于可变模板参数的内容）</p><p>利用我们自己写的string进行构造中的打印，即可看出二者的区别</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231731208.png" alt="image-20220923173119153"></p><p>在上面的场景中</p><ul><li><code>emplace_back</code>直接调用了构造函数;</li><li><code>push_back</code> 构造+移动构造（如果不使用万能转发，就会变成构造+拷贝构造）</li></ul><p>在传参中的常量字符串会被先构造一个临时对象，再被<strong>移动构造</strong>到目标区域，移动构造的效率是很高的，所以这两种方式的差距并不算很大。如果emplace_back没有使用完美转发，那么传入的临时对象将会被视作左值，调用<code>muxue::string</code>的拷贝构造，此时就会出现拷贝的额外耗时了。</p><p>不过差距肯定是有的，如果为了兼容性，使用<code>push_back</code>肯定更好，因为<code>emplace</code>是<code>C++11</code>新增的操作。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231737095.png" alt="image-20220923173728056"></p><h3 id="5-2-将可变模板参数转为C语言的可变参数列表"><a href="#5-2-将可变模板参数转为C语言的可变参数列表" class="headerlink" title="5.2 将可变模板参数转为C语言的可变参数列表"></a>5.2 将可变模板参数转为C语言的可变参数列表</h3><blockquote><p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000043736187">https://segmentfault.com/q/1010000043736187</a></p></blockquote><p>在我尝试实现一个简单的日志类的时候，遇到了这个问题。最终成功解决</p><p>我想通过debug,info,warning这些函数来打印对应等级的日志，它们最终调用的都是<code>_logging</code>函数，并在<code>_logging</code>函数中<strong>统一</strong>进行<code>vsnprintf</code>，我要怎么才能把可变参数列表传过去？还是说不支持这样的操作？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *def_name, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *def_name, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">void _logging(int level, const char *def_name,  const char *format, ...)</span></span><br></pre></td></tr></table></figure><blockquote><p>如果不这么做，就得把使用vsnprintf的几行代码重复写到每一个独立函数中，有点代码重复</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;</span><br><span class="line">va_start(ap, format);</span><br><span class="line">vsnprintf((<span class="type">char</span> *)_log_info.c_str(), _log_size - <span class="number">1</span>, format, ap);</span><br><span class="line">va_end(ap);</span><br></pre></td></tr></table></figure></blockquote><p>目前百度到如下办法，无作用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">warning</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *def_name, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取可变参数列表</span></span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap, format);</span><br><span class="line">    _logging(LOG_WARINING, def_name, format,ap);</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用logging函数的能正常打印，调用warning函数无法正常打印。如下，第一行是直接调用warning的，没有打印出消息内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[23-04-27 19:59:35] WARN | 1682596775 | test | </span><br><span class="line">[23-04-27 19:59:35] WARN | 1682596775 | test | 这是一个测试而已</span><br></pre></td></tr></table></figure><hr><p>大佬回答中，提到了可以用可变模板参数+完美转发，直接将可变参数列表传过去就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++ 中我们一般使用 variadic templates，除非你要和 c 库兼容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">warning</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *def_name, <span class="type">const</span> <span class="type">char</span> *format, Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">    _logging(LOG_WARINING, def_name, format, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感谢大佬的回答，在这里贴上完整可用的代码【也可以去我的<a target="_blank" rel="noopener" href="https://github.com/musnows/Vedio-On-Demand/blob/main/mylog.hpp">github</a>看】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *def_name, <span class="type">const</span> <span class="type">char</span> *format, Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">        _logging(LOG_ERROR, def_name, format, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//其他的都是对这项的copy，只修改传入的log level</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">void</span> _logging(<span class="type">size_t</span> level, <span class="type">const</span> <span class="type">char</span> *def_name, <span class="type">const</span> <span class="type">char</span> *format, ...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(level &gt;= LOG_DEBUG &amp;&amp; level &lt;= LOG_FATAL);</span><br><span class="line">        <span class="keyword">if</span> (level &lt; _level)</span><br><span class="line">        &#123; <span class="comment">// 低于定义的等级，不打印</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        va_list ap;</span><br><span class="line">        <span class="built_in">va_start</span>(ap, format);</span><br><span class="line">        <span class="built_in">vsnprintf</span>((<span class="type">char</span> *)_log_info.<span class="built_in">c_str</span>(), _log_size - <span class="number">1</span>, format, ap);</span><br><span class="line">        <span class="built_in">va_end</span>(ap);</span><br><span class="line">        <span class="comment">// 根据日志等级选择打印到stderr/stdout</span></span><br><span class="line">        <span class="comment">// 超过了error的日志，要使用stderr打印</span></span><br><span class="line">        FILE *out = (level &gt;= LOG_ERROR) ? stderr : stdout;</span><br><span class="line">        def_name = def_name == <span class="literal">nullptr</span> ? <span class="string">&quot;unknow&quot;</span> : def_name; <span class="comment">// 判断defname是否为空</span></span><br><span class="line">        <span class="comment">// 格式化打印到文件流中</span></span><br><span class="line">        <span class="built_in">fprintf</span>(out, <span class="string">&quot;%s | %s | %s\n&quot;</span>,</span><br><span class="line">                    log_level[level],</span><br><span class="line">                    def_name,</span><br><span class="line">                    _log_info.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vod::Logger _log;</span><br><span class="line">    _log.<span class="built_in">info</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;this in info&quot;</span>);</span><br><span class="line">    _log.<span class="built_in">warning</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;%s %d&quot;</span>,<span class="string">&quot;this is warning&quot;</span>,<span class="number">333</span>);</span><br><span class="line">    _log.<span class="built_in">error</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;this is err&quot;</span>);</span><br><span class="line">    _log.<span class="built_in">fatal</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;this is fatal!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO | test | this in info</span><br><span class="line">WARINING | test | this is warning 333</span><br><span class="line">ERROR | test | this is err</span><br><span class="line">FATAL | test | this is fatal!!!</span><br></pre></td></tr></table></figure><h2 id="6-新增的默认成员函数"><a href="#6-新增的默认成员函数" class="headerlink" title="6.新增的默认成员函数"></a>6.新增的默认成员函数</h2><p>在初识类和对象的时候，我便在博客中提到了C++的几个默认成员函数</p><ul><li>构造函数</li><li>析构函数</li><li>拷贝构造函数</li><li>拷贝赋值重载</li><li>取地址重载</li><li>const 取地址重载</li></ul><p>在<code>C++11</code>中也多了两个成员函数，那便是前文所讲述的<code>移动构造/移动赋值</code></p><p>但是想让编译器默认生成移动构造可没那么容易：只有你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个，编译器才会帮你整一个移动构造出来</p><blockquote><p>编译器默认生成的移动构造：对于内置类型会执行逐成员按字节拷贝；对自定义类型成员，则需要看这个成员是否实现移动构造， 如果实现了就调用移动构造，没有实现就调用拷贝构造。</p></blockquote><p>同样的，移动赋值也需要满足上面的条件，编译器才会帮你生成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestB</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	muxue::string _s;</span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TestB</span>(<span class="type">const</span> muxue::string&amp; s=<span class="string">&quot;&quot;</span>, <span class="type">int</span> a=<span class="number">0</span>)</span><br><span class="line">		:_s(s),</span><br><span class="line">		_a(a)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefaultMoveCopy</span><span class="params">()</span></span>&#123;</span><br><span class="line">	TestB t1;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	TestB t2 = t1;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	TestB t3 = std::<span class="built_in">move</span>(t1);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	TestB t4;</span><br><span class="line">	t4 = std::<span class="built_in">move</span>(t2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过测试可以看出来，编译器默认生成了移动拷贝和移动赋值重载。并调用了自定义类型的<code>移动拷贝/移动赋值</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231747964.png" alt="image-20220923174727875"></p><h3 id="6-1-关键字default"><a href="#6-1-关键字default" class="headerlink" title="6.1 关键字default"></a>6.1 关键字default</h3><blockquote><p>这个关键字的作用之前好像记录过? 不记得了</p></blockquote><p><code>default</code>关键字的作用是让编译器强制生成一个指定的成员函数</p><p>还是上面的<code>TestB</code>类的代码，如果我们自己写一个拷贝构造，编译器就不再会生成默认的<code>移动构造/移动赋值</code>，而是会去调用string里面的拷贝构造、拷贝赋值</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231755005.png" alt="image-20220923175537919"></p><p>这时候我们太懒了，不想自己写<strong>移动</strong>版本了，于是就用<code>default</code>强制让编译器干活</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231757694.png" alt="image-20220923175715608"></p><p>现在就正确调用了对应的移动构造和移动赋值了！</p><hr><h2 id="7-可变模板参数"><a href="#7-可变模板参数" class="headerlink" title="7.可变模板参数"></a>7.可变模板参数</h2><p>在<code>5.1</code>提到的<code>emplace_back</code>函数中，便出现了下面这种语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>这就是一个可变的模板参数，允许一个函数有多个参数，且不要求是相同类型</p><p>使用<code>sizeof</code>即可查看参数的个数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231818331.png" alt="image-20220923181824262"></p><h3 id="7-1-递归解参数包"><a href="#7-1-递归解参数包" class="headerlink" title="7.1 递归解参数包"></a>7.1 递归解参数包</h3><p>而如果你想查看参数的类型并使用它，则需要进行递归取出参数来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowArgs</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot;   type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(val).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowArgs</span><span class="params">(<span class="type">const</span> T&amp;val,Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;参数个数&quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;</span></span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot;   type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(val).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">ShowArgs</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestArgs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ShowArgs</span>(<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>, <span class="number">2.3</span>, muxue::<span class="built_in">string</span>(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231822628.png" alt="image-20220923182238538"></p><p>其中<code>void ShowArgs(const T&amp; val)</code>函数的作用，是当参数包中只有一个参数的时候，调用对应的单参函数，而不会报错</p><p>另外一种办法便是提供一个无参的同名函数，用作参数包递归的结尾</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231824956.png" alt="image-20220923182413854"></p><h4 id="错误解法"><a href="#错误解法" class="headerlink" title="错误解法"></a>错误解法</h4><p>可能有人想使用这样的方法来解包，当参数包里的函数只有一个的时候，结束递归</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231825138.png" alt="image-20220923182544016"></p><p>但是这样是不行的！</p><ul><li>递归推参数包是一个<code>编译时逻辑</code></li><li>通过<code>sizeof</code>判断是一个<code>运行时逻辑</code></li></ul><p>在<strong>编译</strong>这个函数的时候，已经开始找对应的函数进行调用了。当参数包里面的参数只有1个或者0个的时候，编译器<strong>编译的时候</strong>发现找不到对应函数，就直接报错了。</p><h3 id="7-2-数组解包"><a href="#7-2-数组解包" class="headerlink" title="7.2 数组解包"></a>7.2 数组解包</h3><p>除了上面的递归解包，这里还可以使用<strong>数组</strong>的方式直接来解包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowArgs</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;参数个数&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; args... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestArgs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">ShowArgs</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>arr</code>数组里面解包出了传入的参数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231833351.png" alt="image-20220923183330262"></p><p>但是这种方法不通用，只适用于所有参数都是<strong>相同类型</strong>的情况，如果是不同类型则会报错</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231835179.png" alt="image-20220923183515095"></p><p>通用办法是使用一个<strong>逗号表达式</strong>，来获取一共有多少个参数以及解包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArgs</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot;   type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(val).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowArgs</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;参数个数&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//int arr[] = &#123; args... &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr[] = &#123; (<span class="built_in">PrintArgs</span>(args),<span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有多少个参数，那么数组里面就会有多少个0</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231837656.png" alt="image-20220923183752578"></p><h3 id="7-3-emplace-back"><a href="#7-3-emplace-back" class="headerlink" title="7.3 emplace_back"></a>7.3 emplace_back</h3><p>std容器的库函数中<code>emplace_back</code>的参数包还使用了万能引用，这就让它的使用更加灵活</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>可以直接传入两个参数，他会自动解包参数，创建一个键值对</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;std::pair&lt;<span class="type">int</span>, muxue::string&gt;&gt; t;</span><br><span class="line">t.<span class="built_in">emplace_back</span>(<span class="number">10</span>, <span class="string">&quot;sort&quot;</span>);</span><br></pre></td></tr></table></figure><p>而<code>push_back</code>则不支持这么干</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209231843413.png" alt="image-20220923184302349"></p><hr><h2 id="8-lambda表达式"><a href="#8-lambda表达式" class="headerlink" title="8.lambda表达式"></a>8.lambda表达式</h2><p>在之前，我们使用sort的时候，如果是内置类型，默认会返回一个升序序列。如果我们需要返回降序，则需要改变比较规则，传入一个仿函数来使用自定义的比较对比</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">//sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span><span class="comment">//greater</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz=<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//默认升序</span></span><br><span class="line">	std::<span class="built_in">sort</span>(arr,arr+sz);</span><br><span class="line">    <span class="comment">//降序传入仿函数greater</span></span><br><span class="line">    std::<span class="built_in">sort</span>(arr,arr+sz,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为int是内置类型，库中自带的<code>greater/less</code>仿函数即可满足我们的需求。而如果我们排序的是自定义类型，则需要自己实现一个对应的仿函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//价格降序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompPriceGreater</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Goods&amp; g1, <span class="type">const</span> Goods&amp; g2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> g1._price &gt; g2._price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//价格升序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompPriceLess</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Goods&amp; g1, <span class="type">const</span> Goods&amp; g2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> g1._price &lt; g2._price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261406670.png" alt="image-20220926140601433"></p><h3 id="8-1-情景描述"><a href="#8-1-情景描述" class="headerlink" title="8.1 情景描述"></a>8.1 情景描述</h3><p>但是如果需要处理的对象有很多不同的成员变量的时候（比如京东淘宝上商品不同的筛选方式）我们就需要实现非常非常多的仿函数</p><p>这样一来，程序的代码行数就会变多</p><p>在VS编译器下，这种问题还算好解决，我们可以快速跳转道函数定义。但如果我们没有这个功能可用，在处理大文本代码的时候，怎么很快的找到对应的仿函数呢？</p><p>特别是在项目合作的时候，万一有个家伙编程命名规范很差劲，我们无法从函数名推断函数功能，再加上不能直接跳转定义，那麻烦事可多了。</p><hr><h3 id="8-2-lambda出场"><a href="#8-2-lambda出场" class="headerlink" title="8.2 lambda出场"></a>8.2 lambda出场</h3><p>这时候就可以试试用lambda表达式拉，以下是lambda表达式的书写格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture-list](parameters)<span class="keyword">mutable</span> -&gt; <span class="keyword">return</span>-type&#123;statement&#125;</span><br></pre></td></tr></table></figure><p>说明一下各个位置分别写的是啥玩意</p><ul><li><code>[capture-list]</code>捕捉列表，用于编译器判断为lambda表达式，同时捕捉该表达式所在域的变量以供函数使用</li><li><code>(parameters)</code>参数，和函数的参数一致。如果不需要传参则可连带<code>()</code>一起省略</li><li><code>mutable</code>默认情况下<strong>捕捉列表</strong>捕捉的参数是<code>const</code>修饰的，该关键字的作用是取消const使其可修改</li><li><code>-&gt; return-type</code>函数返回值类型</li><li><code>&#123;statement&#125;</code>函数体，和普通函数一样。除了可以使用传入的参数，还可以使用捕捉列表获取的参数</li></ul><h3 id="8-3-基本使用"><a href="#8-3-基本使用" class="headerlink" title="8.3 基本使用"></a>8.3 基本使用</h3><p>先来写一个最简单的<code>lambda</code>表达式试试水吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261427715.png" alt="image-20220926142749580"></p><p>可以看到，这个表达式的使用方法和函数完全一致，也成功提供了结果</p><p>因为我们返回值的类型是明确的，所以这里可以省略类型，让编译器自己来推断。当然也可以显示指定类型，这样可以更精确的控制</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261433009.png" alt="image-20220926143307874"></p><blockquote><p>lambda表达式还支持复制给相同类型的函数指针，但是一般都不要这么用！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f2是一个lambda</span></span><br><span class="line"><span class="built_in">void</span>(*PF)();</span><br><span class="line">PF = f2;</span><br><span class="line"><span class="built_in">PF</span>();</span><br></pre></td></tr></table></figure></blockquote><h3 id="8-4-捕捉列表和mutable"><a href="#8-4-捕捉列表和mutable" class="headerlink" title="8.4 捕捉列表和mutable"></a>8.4 捕捉列表和mutable</h3><p>学会了基本使用，我们再来看看捕捉列表是怎么玩的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestLambda1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">auto</span> func3 = [a,b](<span class="type">int</span> x, <span class="type">int</span> y)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">func3</span>(a, b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261443657.png" alt="image-20220926144343512"></p><p>这里我们捕捉了函数作用域里面的局部变量<code>a/b</code>，直接在<code>lambda</code>表达式内部使用👍</p><p>因为不需要传入参数，所以我们可以直接把参数<code>()</code>和返回值一并省略掉</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261455900.png" alt="image-20220926145534773"></p><h4 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h4><p>默认情况下，我们捕捉到的参数是带<code>const</code>的，我们并不能对其进行修改。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261456333.png" alt="image-20220926145633161"></p><p>这时候就需要使用前面提到的<code>mutable</code>关键字来修饰</p><blockquote><p><font color="Red">注意</font>：这个关键字使用的时候必须带上函数参数的<code>()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func5 = [a, b]()<span class="keyword">mutable</span> &#123;</span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261456939.png" alt="image-20220926145654821"></p><hr><h3 id="8-5-捕获的几种方式"><a href="#8-5-捕获的几种方式" class="headerlink" title="8.5 捕获的几种方式"></a>8.5 捕获的几种方式</h3><p>注意，当我们在对象里面以值传递方式捕获参数的时候，还需要捕获this指针来调用类内部的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[val]：表示值传递方式捕捉变量val</span><br><span class="line">[=]：表示值传递方式捕获所有父作用域中的变量(包括this)</span><br><span class="line">[&amp;val]：表示引用传递捕捉变量val</span><br><span class="line">[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括this)</span><br><span class="line">[this]：表示值传递方式捕捉当前的this指针</span><br></pre></td></tr></table></figure><p>其中第一个就是我们上面演式的<code>[a,b]</code>这样最直接的值捕获</p><p>而最后一个的this指针主要用用于类内部；需要注意，this指针是不能被引用捕获的！因为函数里面的this指针本来也只是个传值参数而已，对于这个指针本身来说，引用捕获的意义其实并不是很大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">test.cpp:84:18: error: &#x27;this&#x27; cannot be captured by reference</span><br><span class="line">        return [&amp;this]</span><br><span class="line">                 ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>在C++17中新增了一个对<code>*this</code>的传值捕获，这部分可以去看C++17的博客。</p><h4 id="8-5-1-全捕获-x3D"><a href="#8-5-1-全捕获-x3D" class="headerlink" title="8.5.1 全捕获&#x3D;"></a>8.5.1 全捕获&#x3D;</h4><p>当一个作用域里面的变量很多，而我们又不想一个一个写的时候，可以使用<code>=</code>捕捉全部变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">1</span>, d = <span class="number">3</span>, e = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> func6 = [=] &#123;</span><br><span class="line">    <span class="built_in">return</span> (a + b + c + d + e);</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func6</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261500708.png" alt="image-20220926150039589"></p><h4 id="8-5-2-引用全捕或"><a href="#8-5-2-引用全捕或" class="headerlink" title="8.5.2 引用全捕或"></a>8.5.2 引用全捕或</h4><p>除了基本的全捕或，我们还可以用一个<code>&amp;</code>以引用的方式捕获全部参数。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261503062.png" alt="image-20220926150315933"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">1</span>, d = <span class="number">3</span>, e = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> func7 = [&amp;] &#123;</span><br><span class="line">    <span class="built_in">return</span> (a + b + c + d + e);</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func7</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>引用了过后，我们也可以修改参数了</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261504501.png" alt="image-20220926150426363"></p><h4 id="8-5-3-全捕获-单独操作"><a href="#8-5-3-全捕获-单独操作" class="headerlink" title="8.5.3 全捕获+单独操作"></a>8.5.3 全捕获+单独操作</h4><p>如果只是仅仅的全捕或还不够，我们还想单独修改某一个参数的时候，可以以不同的方式进行捕获操作</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261505515.png" alt="image-20220926150550377"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func8 = [=,&amp;e] &#123;</span><br><span class="line">	e++;</span><br><span class="line">	<span class="keyword">return</span> (a + b + c + d + e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209261506237.png" alt="image-20220926150627126"></p><p>这样一来就方便多了</p><h3 id="8-6-最终呈现"><a href="#8-6-最终呈现" class="headerlink" title="8.6 最终呈现"></a>8.6 最终呈现</h3><p>这样，当我们<code>sort</code>的时候，就不再需要用仿函数了，而是可以直接用<code>lambda</code>表达式来完成相同的操作，大大增加代码可读性！</p><p>这是因为排序所用的方法直接就在sort这里用<code>lambda</code>的形式给出了，看代码的时候，也不需要去找定义，更不用担心函数命名规则的问题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Goods&gt; v1 = &#123; &#123;<span class="string">&quot;牛奶&quot;</span>,<span class="number">20</span>,<span class="number">100</span>&#125;,&#123;<span class="string">&quot;杯子&quot;</span>,<span class="number">10</span>,<span class="number">200</span>&#125;,&#123;<span class="string">&quot;饼干&quot;</span>,<span class="number">15</span>,<span class="number">50</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//价格升序</span></span><br><span class="line"><span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), [](<span class="type">const</span> Goods&amp; g1, <span class="type">const</span> Goods&amp; g2) &#123;<span class="keyword">return</span> g1._price &lt; g2._price; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : v1) &#123;</span><br><span class="line">	cout &lt;&lt; e._name &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; e._price &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v1 = &#123; &#123;<span class="string">&quot;牛奶&quot;</span>,<span class="number">20</span>,<span class="number">100</span>&#125;,&#123;<span class="string">&quot;杯子&quot;</span>,<span class="number">10</span>,<span class="number">200</span>&#125;,&#123;<span class="string">&quot;饼干&quot;</span>,<span class="number">15</span>,<span class="number">50</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//价格降序</span></span><br><span class="line"><span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), [](<span class="type">const</span> Goods&amp; g1, <span class="type">const</span> Goods&amp; g2) &#123;<span class="keyword">return</span> g1._price &gt; g2._price; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : v1) &#123;</span><br><span class="line">	cout &lt;&lt; e._name &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; e._price &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v1 = &#123; &#123;<span class="string">&quot;牛奶&quot;</span>,<span class="number">20</span>,<span class="number">100</span>&#125;,&#123;<span class="string">&quot;杯子&quot;</span>,<span class="number">10</span>,<span class="number">200</span>&#125;,&#123;<span class="string">&quot;饼干&quot;</span>,<span class="number">15</span>,<span class="number">50</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//名称字典序</span></span><br><span class="line"><span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), [](<span class="type">const</span> Goods&amp; g1, <span class="type">const</span> Goods&amp; g2) &#123;<span class="keyword">return</span> g1._name &lt; g2._name; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : v1) &#123;</span><br><span class="line">	cout &lt;&lt; e._name &lt;&lt; <span class="string">&quot;_&quot;</span> &lt;&lt; e._price &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209281045252.png" alt="image-20220928104457887"></p><h3 id="8-7-lambda底层：仿函数"><a href="#8-7-lambda底层：仿函数" class="headerlink" title="8.7 lambda底层：仿函数"></a>8.7 lambda底层：仿函数</h3><p>实际上，lambda的底层就是把自己转成了一个仿函数供我们调用。这也是为何sort可以以<code>lambda</code>来作为排序方法的原因——底层都是仿函数嘛！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209281049083.png" alt="image-20220928104917825"></p><h3 id="8-8-lambda递归"><a href="#8-8-lambda递归" class="headerlink" title="8.8 lambda递归"></a>8.8 lambda递归</h3><p>如果需要用lambda写递归函数，<strong>那么lambda必须用fuction明确指定类型</strong>，而不能用auto！</p><p>比如下方是一个最简单的斐波那契的递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里必须要引用捕获自身</span></span><br><span class="line"><span class="keyword">auto</span> fib = [&amp;fib](<span class="type">int</span> a) -&gt; <span class="type">int</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> ((a == <span class="number">1</span>) || (a == <span class="number">2</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">return</span> (<span class="built_in">fib</span>(a - <span class="number">1</span>)) + (<span class="built_in">fib</span>(a - <span class="number">2</span>)); <span class="comment">// n-1和n-2项</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>这个时候编译就会出现如下的报错，因为auto是要这个lambda表达式的定义完全结束了才能进行类型推断，而我们又在lambda的函数体内使用了fib本身，那么就出现了声明前使用的问题！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:75:18: error: use of ‘fib’ before deduction of ‘auto’</span><br><span class="line">     auto fib = [&amp;fib](int a) -&gt; int</span><br><span class="line">                  ^~~</span><br><span class="line">test.cpp: In lambda function:</span><br><span class="line">test.cpp:83:21: error: use of ‘fib’ before deduction of ‘auto’</span><br><span class="line">             return (fib(a - 1)) + (fib(a - 2)); // n-1和n-2项</span><br><span class="line">                     ^~~</span><br><span class="line">test.cpp:83:36: error: use of ‘fib’ before deduction of ‘auto’</span><br><span class="line">             return (fib(a - 1)) + (fib(a - 2)); // n-1和n-2项</span><br><span class="line">                                    ^~~</span><br></pre></td></tr></table></figure><p>正确的写法如下，用function明确指明这个lambda表达式的类型！而且还需要<strong>引用捕捉自身</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里必须要引用捕获自身，[&amp;fib]，否则他不知道fib是啥玩意</span></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fib = [&amp;fib](<span class="type">int</span> a) -&gt; <span class="type">int</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> ((a == <span class="number">1</span>) || (a == <span class="number">2</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">return</span> (<span class="built_in">fib</span>(a - <span class="number">1</span>)) + (<span class="built_in">fib</span>(a - <span class="number">2</span>)); <span class="comment">// n-1和n-2项</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>这时候才能通过编译！</p><h2 id="9-包装器function"><a href="#9-包装器function" class="headerlink" title="9.包装器function"></a>9.包装器function</h2><p>function包装器，也叫作适配器。C++中的function本质是一个类模板，也是一个包装器。</p><p>那么这个东西是用来干啥的呢？</p><ul><li>把所有的可调用对象封装成统一的格式</li></ul><p>什么是可调用对象？</p><ul><li>函数</li><li>函数指针</li><li>仿函数对象</li><li>lambda表达式</li></ul><h3 id="9-1-基本使用"><a href="#9-1-基本使用" class="headerlink" title="9.1 基本使用"></a>9.1 基本使用</h3><p>我们可以用<code>function</code>来包装这些不同的可调用对象，说白了就是产生了另外一个相同的可调用对象。类似于“引用”了这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Addi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Addd</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Functor</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 函数</span></span><br><span class="line">	function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func1 = func;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func1</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 仿函数</span></span><br><span class="line">	function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func2 = <span class="built_in">Functor</span>();</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 类中static成员函数</span></span><br><span class="line">	function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func3 = AddClass::Addi;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func3</span>(<span class="number">100</span>, <span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 类中非静态成员函数</span></span><br><span class="line">	function&lt;<span class="type">double</span>(AddClass, <span class="type">double</span>, <span class="type">double</span>)&gt; func4 = &amp;AddClass::Addd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func4</span>(<span class="built_in">AddClass</span>(), <span class="number">100.11</span>, <span class="number">200.11</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// lambda表达式</span></span><br><span class="line">	function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func5 = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func5</span>(<span class="number">100</span>, <span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209281103764.png" alt="image-20220928110343451"></p><h4 id="引用类中非static成员"><a href="#引用类中非static成员" class="headerlink" title="引用类中非static成员"></a>引用类中非static成员</h4><p>需要注意的是，当我们使用静态成员函数的时候，必须要带上一个<code>this</code>指针才能很好的访问。所以我们需要穿入一个<code>AddClass()</code>的匿名对象来适配包装器</p><p>同时，<strong>非静态</strong>的成员函数还必须要进行<code>&amp;</code>取地址操作。静态的则可以不加</p><blockquote><p>为了统一，可以给成员函数都加上取地址以防忘记</p></blockquote><hr><h3 id="9-2-特殊场景的作用"><a href="#9-2-特殊场景的作用" class="headerlink" title="9.2 特殊场景的作用"></a>9.2 特殊场景的作用</h3><p>这个东西呢，看起来好像没啥用，但是在一些地方可以帮大忙</p><p>比如模板函数，假设我们知道在函数B里面需要调用一个模板函数A多次，而且每次调用都是相同类型的（或者说就只有已知的几个特定类型），那么就可以先用<code>fuction</code>对这个模板函数进行指定的实例化，避免每一次调用的时候，后台都需要单独去实例化一个函数，减小模板的性能损耗！</p><h3 id="9-3-改造逆波兰表达式OJ"><a href="#9-3-改造逆波兰表达式OJ" class="headerlink" title="9.3 改造逆波兰表达式OJ"></a>9.3 改造逆波兰表达式OJ</h3><blockquote><p>leetcode逆波兰表达式：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></p></blockquote><p>之前写这个OJ的时候，我用的是栈和<code>switch/case</code>语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span>(ch[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left+right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left-right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left*right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left/right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们就不需要这么麻烦了，可以使用包装器来改造这个OJ题的答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x+y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;-&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x-y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;/&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x/y;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> ret = FuncMap[ch](left,right);</span><br><span class="line">                s.<span class="built_in">push</span>(ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们还用到了前面提到过的<code>&#123;&#125;</code>初始化构造。现在我们只需要从<code>funcmap</code>里面取出封装器封装的<code>lambda</code>表达式进行操作就可以了！</p><p>代码一下就简洁了许多，但是这也只有学习过<code>C++11</code>的人才看得懂，属于一个进阶用法。这种键值对的方式也更方便后续代码的扩展。想添加其他的运算符，就只需要给map里面新增运算符字符串和对应的lambda表达式就可以了。</p><p>如果用<code>switch/case</code>的老办法，就还得自己再写一个判断分支，会产生一定的代码冗余和重复。</p><hr><p>测试的时候发现出现了一些问题，int溢出了。这大概率是因为leetcode修改了测试用例。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209281111758.png" alt="image-20220928111146258"></p><p>把所有的int都改成long long即可。反正逻辑性代码没有bug就OK啦。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209281115635.png" alt="image-20220928111508179"></p><hr><h2 id="10-bind绑定"><a href="#10-bind绑定" class="headerlink" title="10.bind绑定"></a>10.bind绑定</h2><p>在上面我们用<code>fuction</code>包装一个对象内部的成员函数时，需要利用匿名对象传入一个<code>this</code>指针。这样就很不方便了，明明是两个参数的函数，非要传入第三个参数。</p><p>要是我们再用<code>9.3中map</code>的方式来封装一个可调用的表，那带<code>this</code>指针的函数就没办法一起包装了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Addi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Addii</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Functor</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;函数&quot;</span>,func&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;仿函数&quot;</span>,<span class="built_in">Functor</span>()&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;静态成员函数&quot;</span>,AddClass::Addi&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;非静态成员函数&quot;</span>,&amp;AddClass::Addii&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如图，最后<code>addclass</code>中的非静态函数，就没有办法一同包装到map中</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209281129347.png" alt="image-20220928112948044"></p><blockquote><p>这里不能使用可变参数包，因为是实例化操作</p></blockquote><p>这时候我们就可以使用<code>bind</code>来进行参数绑定</p><h3 id="10-1-使用"><a href="#10-1-使用" class="headerlink" title="10.1 使用"></a>10.1 使用</h3><p>bind可以调整参数的顺序，绑定固有参数；最后形成一个新的可调用对象。</p><p>bind的第一个参数用于<strong>指定需要绑定的函数</strong>，后面就是绑定的参数，和需要自己传入的参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func7 = <span class="built_in">bind</span>(&amp;AddClass::Addii,<span class="built_in">AddClass</span>(), placeholders::_1, placeholders::_2);</span><br><span class="line">cout &lt;&lt; <span class="built_in">func7</span>(<span class="number">100</span>, <span class="number">200</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209281133083.png" alt="image-20220928113303902"></p><p>这时候我们就不需要传入this指针，因为当我们用<code>bind</code>绑定的时候，已经默认传入了第一个参数了！</p><h3 id="10-2-占位符placeholders"><a href="#10-2-占位符placeholders" class="headerlink" title="10.2 占位符placeholders"></a>10.2 占位符placeholders</h3><p><code>placeholders</code>是用来占位的，代表这里的参数需要用户手动传入，而<code>_1</code>代表传入的第一个参数，<code>_2</code>就是传入的第二个参数，以此类推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func7 = <span class="built_in">bind</span>(&amp;AddClass::Addii,<span class="built_in">AddClass</span>(), placeholders::_1, placeholders::_2);</span><br></pre></td></tr></table></figure><p>因为有不同的后缀，所以我们还可以调整绑定的参数顺序！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Minii的作用是a-b</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func8 = <span class="built_in">bind</span>(&amp;AddClass::Minii, <span class="built_in">AddClass</span>(), placeholders::_1, placeholders::_2);</span><br><span class="line">cout &lt;&lt; <span class="built_in">func8</span>(<span class="number">100</span>, <span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func9 = <span class="built_in">bind</span>(&amp;AddClass::Minii, <span class="built_in">AddClass</span>(), placeholders::_2, placeholders::_1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">func9</span>(<span class="number">100</span>, <span class="number">200</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209281139891.png" alt="image-20220928113901698"></p><p>我们调整了顺序之后，也得到了不同的结果！</p><h3 id="10-3-异常"><a href="#10-3-异常" class="headerlink" title="10.3 异常"></a>10.3 异常</h3><p>以下为cplusplus网站上对bind函数可能出现异常的描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception safety</span><br><span class="line">   Basic guarantee: if an exception is thrown, all objects involved are left in a valid state.</span><br><span class="line">   This function may only throw if the construction of any of its internal elements (of the decay types of Fn and Args...) throws.</span><br></pre></td></tr></table></figure><p><code>std::bind</code> 只有在传入的函数的参数<strong>构造</strong>时抛异常，他才会抛出异常。比如在拷贝构造中抛出异常的类。</p><blockquote><p>注意，如果传入的函数内部会抛出异常，和bind是没有关系的，这类异常会在函数运行时抛出，而不是bind的时候抛出。</p><p>另外，如果bind的<strong>目标函数参数</strong>和<strong>传入的参数数量&#x2F;类型</strong>不一致，会引发编译时错误，而不是运行时异常。</p></blockquote><p>比如下放的示例代码中，myexpclass的拷贝构造会检测成员变量是否为负数，如果为负数不允许拷贝，会抛出一个异常。在main函数中，我们尝试引发这个异常，就能观测到<code>std::bind</code>在函数传参进行拷贝构造时抛出这个异常。（因为这里的参数没有使用引用，所以函数传参需要拷贝）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind测试函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyExpTestFunc</span><span class="params">(Callable &amp;&amp;func, Args &amp;&amp;...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> function = std::<span class="built_in">bind</span>(std::forward&lt;Callable&gt;(func), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;throw exception&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myexpclass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myexpclass</span>(<span class="type">int32_t</span> a= <span class="number">10</span>,<span class="type">int32_t</span> b= <span class="number">20</span>)</span><br><span class="line">        :_a(a),_b(b)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">myexpclass</span>(<span class="type">const</span> myexpclass&amp; eee)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(eee._a &lt; <span class="number">0</span> || eee._b &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;this class cannot be copy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _a = eee._a;</span><br><span class="line">        _b = eee._b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int32_t</span> _a;</span><br><span class="line">    <span class="type">int32_t</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(myexpclass)&gt; testFuncInt = [](myexpclass num)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;test MyExpTestFuncAgent with params&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">myexpclass <span class="title">test1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">myexpclass <span class="title">test2</span><span class="params">(<span class="number">-1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyExpTestFunc</span>(testFuncInt, test1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;end test1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyExpTestFunc</span>(testFuncInt, test2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;end test2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;exit&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下，test2参数进行bind的时候确抛出了该异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./test</span><br><span class="line">end test1</span><br><span class="line">throw exception</span><br><span class="line">end test2</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="11-static-assert"><a href="#11-static-assert" class="headerlink" title="11.static_assert"></a>11.static_assert</h2><p><code>static_assert</code> 是 C++11 引入的一个关键字，用于在编译时进行断言检查。它允许你在代码中添加一些条件，如果这些条件在编译时不满足，编译将会失败并显示错误消息。</p><p><code>static_assert</code> 的主要作用是在<strong>编译</strong>时验证一些常量表达式的真假情况，从而帮助开发人员捕获一些潜在的问题，例如常量值是否符合预期、模板参数是否满足要求等。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(Size &gt; <span class="number">0</span>, <span class="string">&quot;Array size must be greater than zero&quot;</span>);</span><br><span class="line">    T data[Size];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>, <span class="number">0</span>&gt; emptyArray; <span class="comment">// 编译时失败，因为Size不满足条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>Array</code> 类使用 <code>static_assert</code> 来检查数组大小是否大于零。如果在实例化 <code>Array</code> 类时数组大小不满足要求，编译时将会失败，并显示指定的错误消息。</p><ul><li>static_assert在<strong>编译时</strong>进行合法性检查</li><li>assert在<strong>运行时</strong>进行检查</li></ul><h2 id="12-constexpr"><a href="#12-constexpr" class="headerlink" title="12.constexpr"></a>12.constexpr</h2><p><code>constexpr</code> 是 C++11 引入的关键字，用于声明在编译时可以求值的常量表达式。它可以用于变量、函数、构造函数等上下文，用来告诉编译器在编译时计算表达式的值，从而将其作为常量使用。</p><p><code>constexpr</code> 的主要作用包括：</p><ol><li><strong>编译时计算：</strong> 使用 <code>constexpr</code> 声明的变量或函数可以在编译时计算，而不需要在运行时进行计算。这有助于提高代码的性能，因为在编译时计算的结果可以直接嵌入到生成的机器码中。</li><li><strong>常量表达式：</strong> 通过使用 <code>constexpr</code>，你可以声明常量表达式，这些表达式可以用作编译时的常量值，例如数组大小、模板参数等。</li><li><strong>模板元编程：</strong> <code>constexpr</code> 可以与模板一起使用，用于在编译时执行一些复杂的操作，从而实现元编程技术。</li></ol><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 编译时计算阶乘</span></span><br><span class="line">    <span class="built_in">static_assert</span>(result == <span class="number">120</span>, <span class="string">&quot;Factorial of 5 should be 120&quot;</span>); <span class="comment">// 编译时断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>factorial</code> 函数被声明为 <code>constexpr</code>，这意味着它可以在编译时计算。我们使用 <code>constexpr</code> 函数计算了阶乘，并在 <code>main</code> 函数中使用了 <code>static_assert</code> 进行编译时断言，确保计算的结果是正确的。</p><p>在具体运行到这里的时候，就不再需要实时计算，而是直接沿用了编译过程中生成的结果；提高了代码运行效率，但增加了编译时间。</p><p>总之，<code>constexpr</code> 关键字允许在编译时求值的常量表达式，有助于优化代码并支持一些元编程技术。它在 C++ 中为编译时计算提供了强大的工具。</p><h2 id="13-remove-extent"><a href="#13-remove-extent" class="headerlink" title="13.remove_extent"></a>13.remove_extent</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_extent</span>;</span><br></pre></td></tr></table></figure><p>若 <code>T</code> 是某类型 <code>X</code> 的数组，则提供等于 <code>X</code> 的成员 typedef <code>type</code> ，否则 <code>type</code> 为 <code>T</code> 。</p><p>注意若 T 是多维数组，则只移除第一维。添加 <code>std::remove_extent</code> 的特化的程序行为未定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14中多了一个辅助类型来使用该类</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_extent_t</span> = <span class="keyword">typename</span> remove_extent&lt;T&gt;::type;</span><br></pre></td></tr></table></figure><p>说人话的，这个东西的作用是获取到数组的<strong>成员的类型</strong>；如果传入多维数组，则只会接触第一维；示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_extend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ArrayType1 = <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">using</span> ArrayType2 = <span class="type">int</span>[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">using</span> ArrayType3 = <span class="type">int</span>[<span class="number">5</span>][<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">using</span> ElementType1 = std::remove_extent&lt;ArrayType1&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> ElementType2 = std::remove_extent&lt;ArrayType2&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> ElementType3 = std::remove_extent&lt;ArrayType3&gt;::type;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(ElementType1).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(ElementType2).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(ElementType3).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在linux下打印如下，这里就能看出文档里面说的对于多维数组<code>只移除第一维</code>的含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">i</span><br><span class="line">A10_i</span><br><span class="line">A10_A10_i</span><br></pre></td></tr></table></figure><h2 id="14-nodiscard"><a href="#14-nodiscard" class="headerlink" title="14.[[nodiscard]]"></a>14.[[nodiscard]]</h2><p>这个关键字的作用，是让编译器警告用户，不要忽略函数的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">calculateSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">calculateSum</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 编译器可能会发出警告，提示未使用返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即这个函数的返回值必须被接受且使用，否则就会被警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:8:17: warning: ignoring return value of ‘int calculateSum(int, int)’, declared with attribute nodiscard [-Wunused-result]</span><br><span class="line">     calculateSum(2, 3);  // 编译器可能会发出警告，提示未使用返回值</span><br><span class="line">     ~~~~~~~~~~~~^~~~~~</span><br><span class="line">test.cpp:3:19: note: declared here</span><br><span class="line"> [[nodiscard]] int calculateSum(int a, int b) &#123;</span><br><span class="line">                   ^~~~~~~~~~~~</span><br></pre></td></tr></table></figure><p>只要你用一个变量接受了这个返回值，就不会收到这个警告了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">calculateSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">calculateSum</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 接受了返回值，不会发出警告</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数返回值作为判断条件，也算是使用了这个返回值，同样不会发出警告</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">calculateSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calculateSum</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 接受了返回值，不会发出警告</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-std-begin-x2F-end迭代器"><a href="#15-std-begin-x2F-end迭代器" class="headerlink" title="15.std::begin&#x2F;end迭代器"></a>15.std::begin&#x2F;end迭代器</h2><p>这里说的迭代器并不是容器内部的，std为了一致性，在C++11引入了<code>std::begin/std::end</code>来进行对原生数组的迭代;</p><p>这两个函数除了可以构造一个原生数组的迭代器，还能获取到vector容器的迭代器；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">// container (1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">begin</span> <span class="params">(Container&amp; cont)</span> -&gt; <span class="title">decltype</span> <span class="params">(cont.begin())</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">begin</span> <span class="params">(<span class="type">const</span> Container&amp; cont)</span> -&gt; <span class="title">decltype</span> <span class="params">(cont.begin())</span></span>;</span><br><span class="line"><span class="comment">// array (2)	</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line">  <span class="function">T* <span class="title">begin</span> <span class="params">(T(&amp;arr)[N])</span></span>;</span><br></pre></td></tr></table></figure><p>如下是cplusplus网站上的示例代码，看了就会好吧；<code>&lt;iterator&gt;</code>头文件会在<code>&lt;vector&gt;</code>头文件中被包含，所以这里不需要再包含一次了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::begin / std::end example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector, std::begin, std::end</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> foo[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; bar;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterate foo: inserting into bar</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = std::<span class="built_in">begin</span>(foo); it!=std::<span class="built_in">end</span>(foo); ++it)</span><br><span class="line">    bar.<span class="built_in">push_back</span>(*it);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterate bar: print contents:</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;bar contains:&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = std::<span class="built_in">begin</span>(bar); it!=std::<span class="built_in">end</span>(bar); ++it)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *it;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而用typeid获取变量名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arrv;</span><br><span class="line">	arrv.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(arrv.<span class="built_in">begin</span>()).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(std::<span class="built_in">begin</span>(arrv)).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arri[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">typeid</span>(std::<span class="built_in">begin</span>(arri)).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果如下，可见<code>std::begin</code>本质上只是对<code>int*</code>指针的一个封装。而如果用begin函数获取vector的迭代器，那么就会去取到vector之中封装好的迭代器，和直接使用<code>arrv.begin()</code>的效果相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;</span><br><span class="line">class std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;</span><br><span class="line">int *</span><br></pre></td></tr></table></figure><h2 id="16-std-any-of"><a href="#16-std-any-of" class="headerlink" title="16.std::any_of"></a>16.std::any_of</h2><p>类似的函数还有 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/54671272/answer/140868554">std::for_each</a></p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">any_of</span> <span class="params">( InputIterator start, InputIterator end, UnaryPredicate callback )</span> </span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用是，根据给定的迭代器区间，遍历执行callback函数；只要callback函数返回了一次true，整个函数就会退出并返回true。否则返回false。</p><p>相当于只有迭代器区间中的<strong>所有值</strong>都不满足回调函数中的判断条件的时候，才会返回false；</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>上示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设立一个相除的map</span></span><br><span class="line">    unordered_multimap&lt;<span class="type">int</span>,<span class="type">int</span>&gt; divm;</span><br><span class="line">    divm.<span class="built_in">emplace</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    divm.<span class="built_in">emplace</span>(<span class="number">6</span>,<span class="number">29</span>);</span><br><span class="line">    divm.<span class="built_in">emplace</span>(<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">    divm.<span class="built_in">emplace</span>(<span class="number">10</span>,<span class="number">0</span>); <span class="comment">// error</span></span><br><span class="line">    divm.<span class="built_in">emplace</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    divm.<span class="built_in">emplace</span>(<span class="number">33</span>,<span class="number">234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历判断这个map里面是否所有的参数都满足相除的条件（即除数不能为0）</span></span><br><span class="line">    <span class="keyword">if</span>(std::<span class="built_in">any_of</span>(divm.<span class="built_in">begin</span>(),divm.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="keyword">auto</span>&amp; div_pair)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> div_pair.second == <span class="number">0</span>;</span><br><span class="line">    &#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;args error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;all good to div&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们通过<code>any_of</code>和lambda表达式来判断即将要进行批量相除操作的map中是否包含不满足相除条件的参数。可以看到，这之中有一对的除数是0，这是不符合除法的规则的。而判断条件就是判断第二个除数是否为0，所以any_of理应报错；</p><p>运行结果如下，符合预期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args error</span><br></pre></td></tr></table></figure><p>如果将出错的哪一行注释掉，那么就不会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all good to div</span><br></pre></td></tr></table></figure><h2 id="17-std-atomic-compare-exchange-strong"><a href="#17-std-atomic-compare-exchange-strong" class="headerlink" title="17.std::atomic::compare_exchange_strong"></a>17.std::atomic::compare_exchange_strong</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h3><p>之前只接触过 <code>std::atomic</code> ，它是C++内置提供的一个模板类，帮我们封装了访问的原子性。</p><p>一般情况下，我们只会在数字变量上使用 <code>std::atomic</code> ，这时候对数据的修改操作就不需要我们自己加锁解锁了，std底层会自动封装锁的操作。</p><p>在 <code>std::atomic</code> 中还有两个函数，分别是 <code>compare_exchange_strong</code> 和 <code>compare_exchange_weak</code> ；</p><p>这两个函数的入参和功能都相同，我们主要关注的是前两个入参</p><ul><li>和第一个入参except进行比较，如果原子量和该参数相同，则将原子量改成第二个参数，并返回true</li><li>如果原子量和第一个参数不同，则将第一个参数改为当前原子量的值，返回false</li></ul><p>第一个入参是引用传参，是一个输入输出参数。在原子量和第一个参数不同的时候，这个参数会被修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!x.<span class="built_in">compare_exchange_strong</span>(<span class="number">0</span>,<span class="number">10</span>))&#123;</span><br><span class="line">  <span class="comment">// 这两个参数之间可能会出现第二个执行流来访问并修改x，导致线程不安全，缺失原子性</span></span><br><span class="line">    <span class="keyword">auto</span> current_val = x; <span class="comment">// x.load()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免上述情况中的线程安全问题，<code>compare_exchange</code>函数会在原子量和第一个参数不一致的时候，通过第一个参数输出当前的原子量。这样就能保证线程安全。所以如果你需要获取到原子量的当前值，请不要给第一个参数传入右值，<strong>传入可修改的左值</strong>；</p><h3 id="2-compare-exchange-strong的使用示例"><a href="#2-compare-exchange-strong的使用示例" class="headerlink" title="2.compare_exchange_strong的使用示例"></a>2.compare_exchange_strong的使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">State cur_state = State::Ready;</span><br><span class="line"><span class="keyword">if</span> (engine.state_.<span class="built_in">compare_exchange_strong</span>(cur_state,State::Closing)&#123;</span><br><span class="line">    <span class="comment">// 判断当前引擎的状态，如果是就绪状态，就把他关闭</span></span><br><span class="line">    engine.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果是其他状态，就将错误输出，并通过输入输出参数获取到当前引擎的状态</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[cannot close] cur_state: &quot;</span> &lt;&lt; cur_state &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-weak和strong的区别"><a href="#3-weak和strong的区别" class="headerlink" title="3.weak和strong的区别"></a>3.weak和strong的区别</h3><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/526769301">C++ 中 std::atomic 类型的 compare_exchange 应该选择哪个版本？ - 知乎 (zhihu.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/feikudai8460/article/details/107035480">C++11：原子交换函数compare_exchange_weak和compare_exchange_strong-CSDN博客</a></p><p>weak版本的CAS允许偶然出乎意料的返回（比如在字段值和期待值一样的时候却返回了false），不过在一些循环算法中，这是可以接受的。通常它比起strong有更高的性能。</p><p>而strong的返回值能保证它是绝对符合预期的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本篇超长的博客到这里就结束辣！</p><p>其实C++11还有其他的新特性，但是那些我会单开一篇文章来写~</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202209281141224.jpg" alt="QQ图片20220416195218"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/2016080368/">https://blog.musnow.top/posts/2016080368/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/Cpp11/">Cpp11</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm23.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://ifdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.webp" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/569709037/" title="【C++】异常处理"><img class="cover" src="/img/bg/gm22.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【C++】异常处理</div></div></a></div><div class="next-post pull-right"><a href="/posts/3785030063/" title="【Linux】进程概念"><img class="cover" src="/img/bg/gm23.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Linux】进程概念</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1396203902/" title="【C++】搜索二叉树&#x2F;KVL树"><img class="cover" src="/img/bg/gm22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-01</div><div class="title">【C++】搜索二叉树&#x2F;KVL树</div></div></a></div><div><a href="/posts/3807693015/" title="【C++】AVL树（平衡搜索二叉树）"><img class="cover" src="/img/bg/gm9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="title">【C++】AVL树（平衡搜索二叉树）</div></div></a></div><div><a href="/posts/3503649261/" title="【C++】红黑树的性质和实现"><img class="cover" src="/img/bg/gm24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-04</div><div class="title">【C++】红黑树的性质和实现</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">439</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fa fa-home"></i></a><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍，近来可好？</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1.前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%97%E8%A1%A8-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.列表{}初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-new%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE"><span class="toc-text">2.1 new初始化多个数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-initializer-list"><span class="toc-text">2.2 initializer_list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-STL%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.2.1 STL容器初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-initializer-list-%E5%AE%B9%E5%99%A8"><span class="toc-text">2.2.2 initializer_list 容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E6%8F%92%E5%85%A5il"><span class="toc-text">2.3.1 插入il</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0il%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.4 模拟实现il构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">3.变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-auto"><span class="toc-text">3.1 auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-decltype"><span class="toc-text">3.2 decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-typeid"><span class="toc-text">3.3 typeid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B7%A6-x2F-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">4.左&#x2F;右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%B7%A6%E5%80%BC-x2F-%E5%8F%B3%E5%80%BC%E5%8C%BA%E5%88%AB"><span class="toc-text">4.1 左值&#x2F;右值区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%B0%86%E4%BA%A1%E5%80%BC%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%89"><span class="toc-text">4.1.1 将亡值（概念）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">4.2 左值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">4.3 右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.4 两个引用的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-move"><span class="toc-text">4.4.1 move</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC"><span class="toc-text">4.4.2 右值引用函数传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4.5 右值引用使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E8%BE%93%E5%87%BA%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-text">4.5.1 输出型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><span class="toc-text">4.5.2 右值引用 移动构造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#std-string"><span class="toc-text">std::string</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#my-string"><span class="toc-text">my::string</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E7%9B%B4%E6%8E%A5%E7%A7%BB%E5%8A%A8%E8%B5%84%E6%BA%90"><span class="toc-text">移动构造直接移动资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STL%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-text">STL的更新</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-text">4.6 编译器优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E4%BC%98%E5%8C%96%E6%8F%92%E5%85%A5%E6%95%88%E7%8E%87"><span class="toc-text">4.7 优化插入效率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91-%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-text">5.完美转发(万能引用)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5.1 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%B0%86%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%BD%AC%E4%B8%BAC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-text">5.2 将可变模板参数转为C语言的可变参数列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%96%B0%E5%A2%9E%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">6.新增的默认成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%85%B3%E9%94%AE%E5%AD%97default"><span class="toc-text">6.1 关键字default</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-text">7.可变模板参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E9%80%92%E5%BD%92%E8%A7%A3%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-text">7.1 递归解参数包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%A7%A3%E6%B3%95"><span class="toc-text">错误解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%95%B0%E7%BB%84%E8%A7%A3%E5%8C%85"><span class="toc-text">7.2 数组解包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-emplace-back"><span class="toc-text">7.3 emplace_back</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">8.lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%83%85%E6%99%AF%E6%8F%8F%E8%BF%B0"><span class="toc-text">8.1 情景描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-lambda%E5%87%BA%E5%9C%BA"><span class="toc-text">8.2 lambda出场</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">8.3 基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%8D%95%E6%8D%89%E5%88%97%E8%A1%A8%E5%92%8Cmutable"><span class="toc-text">8.4 捕捉列表和mutable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mutable"><span class="toc-text">mutable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E6%8D%95%E8%8E%B7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">8.5 捕获的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-%E5%85%A8%E6%8D%95%E8%8E%B7-x3D"><span class="toc-text">8.5.1 全捕获&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-%E5%BC%95%E7%94%A8%E5%85%A8%E6%8D%95%E6%88%96"><span class="toc-text">8.5.2 引用全捕或</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3-%E5%85%A8%E6%8D%95%E8%8E%B7-%E5%8D%95%E7%8B%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">8.5.3 全捕获+单独操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E6%9C%80%E7%BB%88%E5%91%88%E7%8E%B0"><span class="toc-text">8.6 最终呈现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-lambda%E5%BA%95%E5%B1%82%EF%BC%9A%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">8.7 lambda底层：仿函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-lambda%E9%80%92%E5%BD%92"><span class="toc-text">8.8 lambda递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%8C%85%E8%A3%85%E5%99%A8function"><span class="toc-text">9.包装器function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">9.1 基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E4%B8%AD%E9%9D%9Estatic%E6%88%90%E5%91%98"><span class="toc-text">引用类中非static成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E7%89%B9%E6%AE%8A%E5%9C%BA%E6%99%AF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">9.2 特殊场景的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E6%94%B9%E9%80%A0%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8FOJ"><span class="toc-text">9.3 改造逆波兰表达式OJ</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-bind%E7%BB%91%E5%AE%9A"><span class="toc-text">10.bind绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E4%BD%BF%E7%94%A8"><span class="toc-text">10.1 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%8D%A0%E4%BD%8D%E7%AC%A6placeholders"><span class="toc-text">10.2 占位符placeholders</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%BC%82%E5%B8%B8"><span class="toc-text">10.3 异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-static-assert"><span class="toc-text">11.static_assert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-constexpr"><span class="toc-text">12.constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-remove-extent"><span class="toc-text">13.remove_extent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-nodiscard"><span class="toc-text">14.[[nodiscard]]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-std-begin-x2F-end%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">15.std::begin&#x2F;end迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-std-any-of"><span class="toc-text">16.std::any_of</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">使用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-std-atomic-compare-exchange-strong"><span class="toc-text">17.std::atomic::compare_exchange_strong</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E"><span class="toc-text">1.说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-compare-exchange-strong%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.compare_exchange_strong的使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-weak%E5%92%8Cstrong%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.weak和strong的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/5825720428/" title="【图床】Picgo/Piclist图片上传之前转webp（pic2webp插件）">【图床】Picgo/Piclist图片上传之前转webp（pic2webp插件）</a><time datetime="2025-04-10T12:29:36.000Z" title="发表于 2025-04-10 20:29:36">2025-04-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/9762190903/" title="【SLAM】使用ROS的camera_calibration工具标定D435相机">【SLAM】使用ROS的camera_calibration工具标定D435相机</a><time datetime="2025-04-07T00:09:24.000Z" title="发表于 2025-04-07 08:09:24">2025-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/9149643829/" title="【SLAM】在ORB_SLAM2的ROS模式下使用RealSense D435相机">【SLAM】在ORB_SLAM2的ROS模式下使用RealSense D435相机</a><time datetime="2025-04-06T09:09:24.000Z" title="发表于 2025-04-06 17:09:24">2025-04-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8572288919/" title="【SLAM】使用realsense-viewer对Realsense D435进行自校准">【SLAM】使用realsense-viewer对Realsense D435进行自校准</a><time datetime="2025-04-06T00:51:08.000Z" title="发表于 2025-04-06 08:51:08">2025-04-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://travel.moe/go.html" target="_blank"><img src="/img/ico/moe-default-white.png" style="width:auto;height:25px" title="异次元之旅-跃迁-我们一起去萌站成员的星球旅行吧！"></a>&nbsp<a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>