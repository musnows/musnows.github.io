<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【C++】继承多态详解 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在之前的CPP大作业中，为了应付期末（是这样的）关于继承和多态部分的内容只是草草过了一遍，并没有深挖背后的实现原理，以及使用的时候一些注意事项。 本篇博客是对类和对象继承多态部分的深化！"><meta property="og:type" content="article"><meta property="og:title" content="【C++】继承多态详解"><meta property="og:url" content="https://blog.musnow.top/posts/3933786088/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="在之前的CPP大作业中，为了应付期末（是这样的）关于继承和多态部分的内容只是草草过了一遍，并没有深挖背后的实现原理，以及使用的时候一些注意事项。 本篇博客是对类和对象继承多态部分的深化！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.musnow.top/i/2023/02/202205272034572.png"><meta property="article:published_time" content="2023-08-02T13:13:46.000Z"><meta property="article:modified_time" content="2024-06-19T01:59:51.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Cpp"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.musnow.top/i/2023/02/202205272034572.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/3933786088/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【C++】继承多态详解",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-06-19 09:59:51"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">373</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://img.musnow.top/i/2023/02/202205272034572.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【C++】继承多态详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-02T13:13:46.000Z" title="发表于 2023-08-02 21:13:46">2023-08-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-19T01:59:51.000Z" title="更新于 2024-06-19 09:59:51">2024-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【C++】继承多态详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在之前的CPP大作业中，为了应付期末（是这样的）关于继承和多态部分的内容只是<strong>草草过了一遍</strong>，并没有深挖背后的实现原理，以及使用的时候一些注意事项。</p><p>本篇博客是对类和对象<strong>继承多态</strong>部分的深化！</p><span id="more"></span><p>[TOC]</p><h1 id="0-什么是封装"><a href="#0-什么是封装" class="headerlink" title="0.什么是封装"></a>0.什么是封装</h1><p>面向对象的<strong>三大特性</strong>：封装、继承、多态</p><blockquote><p>面向对象还有 反射（C++中没有）、抽象 等特性</p></blockquote><p>封装：</p><ul><li>不想让用户在类外访问的成员设计成私有，允许访问的设计成公有。相比C语言没有类和访问管理相比，封装能提高设计的安全性和完整性。</li><li>C语言中，如果设计的不好，不规范编写的代码容易出现错误访问<code>struct</code>结构体中的成员。</li><li>同时，C++中的<strong>迭代器</strong>设计，也能给一批容器提供<strong>基本相同的访问接口</strong>，让用户能使用相同的代码，<strong>在不暴露容器底层结构</strong>的前提下访问容器中的值。</li><li>暴露底层结构会提高容器的使用成本，代码也比较复杂，不同数据结构也不一样。</li><li><code>stack/queue/prioritiy_queue</code>的适配器形式，能弄出来我们想要的东西，这也算是一种封装</li></ul><h1 id="1-继承派生关系"><a href="#1-继承派生关系" class="headerlink" title="1.继承派生关系"></a>1.继承派生关系</h1><p>继承是提高代码复用性的一个重要手段。它允许我们在保持基类原有属性的基础上，对其进行一定的扩张，增加不同的功能以应对实际情况。</p><p>比如对于一个人来说，其都会有性别、年龄、身分证号等等信息。但不同职业就还会包含不同职业的特殊信息。这时候就可以通过继承，在基础一个公民的基本信息的同时，再去处理每一个职业的独立信息。这也实现了类在一定程度上的复用，减少了代码复杂性。</p><p>与其相似的增加代码复用性的语法，还有<strong>模板</strong></p><h2 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h2><p>继承和派生是父与子的关系，其中子类拥有父类成员的同时，还会拥有自己的成员</p><ul><li>继承是一个特殊的语法，用于多个类有公共部分的时候</li><li>父类：基类</li><li>子类：派生类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例：网站的公共部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ART</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; <span class="string">&quot;归档&quot;</span> &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;关于我们&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;网站访问量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//文章页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LINK</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; <span class="string">&quot;归档&quot;</span> &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;关于我们 &quot;</span> &lt;&lt; <span class="string">&quot; 网站访问量&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//友链页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的情况中，ART和LINK类中都有网站的公共部分，这时候就出现了代码的重复。继承的出现就是用于解决这个问题的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面使用继承的方式来写，WEB类是网站的公共部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WEB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; <span class="string">&quot;归档&quot;</span> &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;关于我们&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;网站访问量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ART、LINK是两个子类，继承了WEB的公共部分</span></span><br><span class="line"><span class="comment">//这样就减少了代码量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ART</span> : <span class="keyword">public</span> WEB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//文章页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LINK</span> : <span class="keyword">public</span> WEB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//友链页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试可以发现，ART和LINK作为派生类，在继承了基类WEB的成员的基础上，还拥有了它们独特的单独成员</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272021620.png" alt="image-20220527202138439"></p><p>同一个类可以同时继承多个基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-权限问题"><a href="#1-2-权限问题" class="headerlink" title="1.2 权限问题"></a>1.2 权限问题</h2><p>继承有3中类型：public、private、protected。这里会显示出类中protected权限和private权限的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们分别用上面三种方式对类A进行继承的时候，得到的结果是不同的</p><ul><li>用什么继承方式，派生类中继承的基类成员就变成什么类型；</li><li>不管用什么继承方式，都无法访问基类中的<strong>私有</strong>成员；</li></ul><p>可以使用 <code>Min(成员在基类中的访问限定符,继承方式)</code> 来计算某一个成员在子类中的访问限定符是什么。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272034572.png" alt="image-20220527203404310"></p><p>关于权限问题，我们还需要了解下面几点：</p><ul><li>基类的私有成员在派生类中不可见，<strong>但实际上它也被继承过去了</strong>。但是编译器和语法的限制让我们无法访问。</li><li>保护限定符由此出现，如果在基类中的成员不想被外界直接访问，但又需要子类中访问，则可以定义为保护；</li><li>class默认继承方式为私有，struct默认继承方式为保护；</li><li>实际中我们一般使用public继承，<strong>保护&#x2F;私有方式不利于维护和拓展</strong>。</li></ul><p>面试的时候可能会考察你xx继承方式，子类可以访问基类的什么成员。实际上，不管是什么继承方式，子类都可以且只能访问基类中<code>public/protected</code>的成员。</p><h2 id="1-3-同名问题（作用域）"><a href="#1-3-同名问题（作用域）" class="headerlink" title="1.3 同名问题（作用域）"></a>1.3 同名问题（作用域）</h2><p>在继承体系中，基类和子类都有自己<strong>独立的作用域</strong>；</p><p>当基类和派生类中出现同名成员函数或者同名成员变量时，会出现冲突。这时候编译器会做一定的处理：直接访问变量名和函数名的时候，<strong>优先访问派生类自己的成员</strong>，而屏蔽掉基类的。</p><p>这种情况被称之为<code>隐藏</code>：</p><ul><li>函数名相同构成隐藏（并非重载）</li><li>成员变量名相同构成隐藏</li></ul><p>实际操作中，强烈<strong>不建议写同名的成员</strong>，不管是成员函数还是成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承同名成员的处理</span></span><br><span class="line"><span class="comment">//	普通的同名成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DAD1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DAD1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_a = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD func int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;<span class="comment">//基类中的该变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SON1</span> : <span class="keyword">public</span> DAD1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SON1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;SON: &quot;</span> &lt;&lt; _a &lt;&lt; endl;<span class="comment">//优先访问派生类的_a</span></span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;DAD: &quot;</span> &lt;&lt; DAD1::_a &lt;&lt; endl;<span class="comment">//访问基类的_a</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;SON func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;<span class="comment">//派生类的同名变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下方的调用测试能看出结果；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272044379.png" alt="image-20220527204445283"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::func &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个栗子里面，<code>A::func B::func</code>两个函数之间是什么关系？</p><p>答案：二者是<code>隐藏</code>的关系，并非函数重载！函数重载要求两个函数是处于同一个作用域，才构成重载！</p><p>这点通过编译测试也能看出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B bt;</span><br><span class="line">    bt.<span class="built_in">func</span>();</span><br><span class="line">    bt.<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用如上函数进行编译的时候，编译器会报错找不到 <code>B::func()</code>，因为B的作用域中只有<code>func(int a)</code>这个需要传递参数的函数。如果<code>A::func B::func</code>的关系是函数重载的话，那这里应该可以直接调用才对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:24:13: error: no matching function for call to ‘B::func()’</span><br><span class="line">     bt.func();</span><br><span class="line">             ^</span><br><span class="line">test.cpp:15:10: note: candidate: ‘void B::func(int)’</span><br><span class="line">     void func(int a)</span><br><span class="line">          ^~~~</span><br><span class="line">test.cpp:15:10: note:   candidate expects 1 argument, 0 provided</span><br></pre></td></tr></table></figure><p>只有指定父类作用域才能调用到<code>A::func</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B bt;</span><br><span class="line">bt.A::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure><h2 id="1-4-静态成员"><a href="#1-4-静态成员" class="headerlink" title="1.4 静态成员"></a>1.4 静态成员</h2><p>在继承体系中，基类的静态成员有且<strong>只能有一个</strong>。即所有的子类和他们的对象，都是只有那一个静态成员的。我们可以用这个特性来对继承派生中出现的<strong>对象</strong>进行计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="built_in">Person</span> () &#123;++ _count ;&#125;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	string _name ; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _count; <span class="comment">// 统计人的个数。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person :: _count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果出现了与静态成员同名，访问方法就有所变化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问同名的静态成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DAD2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> D_a;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD2 Test1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD2 Test1(int)  &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DAD2::D_a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SON2</span> : <span class="keyword">public</span> DAD2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> D_a;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;SON2 Test1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> SON2::D_a = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272049585.png" alt="image-20220527204928480"></p><h2 id="1-5-友元"><a href="#1-5-友元" class="headerlink" title="1.5 友元"></a>1.5 友元</h2><p>友元关系<strong>不会被继承</strong>，基类的友元函数无法访问派生类的<code>私有/保护</code>成员</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207222001980.png" alt="image-20220722200127880"></p><h2 id="1-6-默认成员函数"><a href="#1-6-默认成员函数" class="headerlink" title="1.6 默认成员函数"></a>1.6 默认成员函数</h2><p>我们知道，C++类和对象中有6个默认成员函数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205191810112.png" alt="image-20220519181052014"></p><p>在派生类中，这些默认成员函数有<strong>新的使用方法</strong></p><ul><li>派生类的构造函数必须在<strong>初始化列表</strong>中调用基类的构造函数，初始化父类的一部分成员。如果你没有写，编译器会自动调用默认构造函数（先调用基类，在调用子类）</li><li>派生类的拷贝构造同上，必须显式调用基类拷贝构造函数（将子类对象传过去，相当于将子类对象中的父类部分传入父类拷贝构造函数。这部分是编译器自动帮我们实现的切片操作）</li><li>派生类的赋值重载也需要调用基类赋值重载完成操作</li><li>派生类的析构函数编译器会自动调用基类，先析构派生类，再析构基类成员（符合栈后进先出原则）</li><li>在基类析构函数不是<strong>虚析构</strong>的时候，<strong>子类析构和父类析构</strong>构成<code>隐藏</code>关系；</li><li>因为多态的需要，析构函数会被统一命名为<code>destructor()</code>，构造函数并<strong>不会</strong>出现重命名。</li></ul><p>在下方栗子中，当我们写B类的深拷贝的时候，可以通过指定类作用域的方式来调用A父类的<code>operator=</code>重载（这里必须要指定类的作用域，否则调用的还是B类自己的<code>operator=</code>重载，相当于无效的递归调用，最终会因为死循环导致栈溢出）</p><p>因为我们是将子类赋值给父类，所以都是编译器自动帮我们进行的切片操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a)</span><br><span class="line">        : _numa(a)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        _numa = a._numa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;a)</span><br><span class="line">        &#123;</span><br><span class="line">            _numa = a._numa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        _numa = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _numa;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a = <span class="number">1</span>, <span class="type">int</span> b = <span class="number">1</span>)</span><br><span class="line">        : <span class="built_in">A</span>(a), _numb(b)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B &amp;b)</span><br><span class="line">        : <span class="built_in">A</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        _numb = b._numb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    B &amp;<span class="keyword">operator</span>=(<span class="type">const</span> B &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            A::<span class="keyword">operator</span>=(b); <span class="comment">// 指定作用域调用A类的赋值重载</span></span><br><span class="line">            _numb = b._numb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::func &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//A::~A();//显示调用会报错</span></span><br><span class="line">        _numb = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _numb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而在析构函数中，子类的析构调用完毕后，会<strong>自动</strong>调用父类的析构，以保证先析构子类，在析构父类。</p><p>所以并不需要我们显式调用；显示调用父类析构的时候会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test.cpp: In destructor ‘B::~B()’:</span><br><span class="line">test.cpp:74:15: error: no matching function for call to ‘B::~B()’</span><br><span class="line">         A::~A();//显示调用会报错</span><br><span class="line">               ^</span><br><span class="line">test.cpp:32:5: note: candidate: ‘A::~A()’</span><br><span class="line">     ~A()</span><br><span class="line">     ^</span><br><span class="line">test.cpp:32:5: note:   candidate expects 1 argument, 0 provided</span><br></pre></td></tr></table></figure><hr><h3 id="构造和析构顺序"><a href="#构造和析构顺序" class="headerlink" title="构造和析构顺序"></a>构造和析构顺序</h3><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><ul><li>继承中<strong>先调用父类构造函数</strong></li><li>再调用子类构造函数</li></ul><p>析构顺序与<strong>构造相反</strong></p><h3 id="显示调用父类构造函数"><a href="#显示调用父类构造函数" class="headerlink" title="显示调用父类构造函数"></a>显示调用父类构造函数</h3><p>如何显示调用父类的构造函数呢，下面是一个代码示例。我们需要在子类构造函数的<strong>初始化列表</strong>中调用父类构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, string sex, <span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _sex = sex;</span><br><span class="line">        _age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line">    string _sex;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在初始化列表中调用父类的构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(string name,string sex,<span class="type">int</span> age,<span class="type">int</span> no)</span><br><span class="line">        :<span class="built_in">Person</span>(name,sex,age),</span><br><span class="line">        _No(no)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _No;<span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">sobj</span><span class="params">(<span class="string">&quot;李华&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">18</span>,<span class="number">1000</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，可见子类正常调用了基类构造函数并进行了初始化</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207231840530.png" alt="image-20220723184035493"></p><p>这里也涉及到之前学过的一个小知识：在CPP中，类中成员的初始化顺序是依照声明的顺序来初始化的！而基类中的成员声明早于子类成员，自然也是先初始化基类的。</p><h2 id="1-7-基类和派生类赋值问题"><a href="#1-7-基类和派生类赋值问题" class="headerlink" title="1.7 基类和派生类赋值问题"></a>1.7 基类和派生类赋值问题</h2><p>派生类成员可以赋值给基类的对象&#x2F;指针&#x2F;引用。一般我们把这种情况称为<code>切片</code>，形象地表示把派生类中父类那部分切来，赋值过去给父类对象。</p><p>但是！反过来是不行的哦，<strong>你不能把基类对象赋值给派生类对象</strong>。</p><blockquote><p>基类的指针&#x2F;引用可以用<strong>强制类型转换</strong>给派生类的指针&#x2F;引用，<strong>但是这样不够安全</strong>，除非基类的指针指向的是对应的派生类。如果基类是多态类型，可以使用RTTI（运行时类型识别）的<code>dynamic_cast</code>转换来进行安全处理。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    string _name;</span><br><span class="line">    string _sex;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> _No ;<span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student sobj ;</span><br><span class="line">    <span class="comment">// 1.子类对象可以赋值给父类对象/指针/引用</span></span><br><span class="line">    Person pobj = sobj ;</span><br><span class="line">    Person* p1 = &amp;sobj;</span><br><span class="line">    Person&amp; p2 = sobj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.基类对象不能赋值给派生类对象</span></span><br><span class="line">    <span class="comment">//sobj = pobj;//err</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.基类的指针可以通过强制类型转换赋值给派生类的指针</span></span><br><span class="line">    p1 = &amp;sobj;<span class="comment">//子类对象给基类指针</span></span><br><span class="line">    Student* ps1 = (Student*)p1; <span class="comment">//基类指针指向子类，正常转换</span></span><br><span class="line">    ps1-&gt;_No = <span class="number">15</span>;</span><br><span class="line">    cout&lt;&lt;ps1-&gt;_No &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    p1 = &amp;pobj;<span class="comment">//基类对象给基类指针</span></span><br><span class="line">    Student* ps2 = (Student*)p1; <span class="comment">//转换虽然可以，但是会存在越界访问</span></span><br><span class="line">    ps2-&gt;_No = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;ps2-&gt;_No &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207231830411.png" alt="image-20220723182953327"></p><p>关于最后提到的越界访问问题，我们知道，指针变量的大小都是相同的，其指针类型的区别主要在访问能力的不同。比如<code>char*</code>指针解引用只能访问1个字节，<code>int*</code>指针解引用可以访问4个字节，以此类推，<code>Student*</code>指针解引用可以访问<code>sizeof(Student)</code>个字节的空间。</p><p>而子类对象的大小都是大于等于基类对象的大小的。这就导致子类指针访问基类对象内容时，一次解引用访问的空间超长，造成了越界访问</p><hr><p>实际上，当我们切片讲子类对象赋值给父类对象的时候，编译器会进行<strong>切片操作</strong>，即新的父类对象中的内容只会包含父类的成员。子类多出去的那一部分成员会被剔除。</p><p>这一点我们可以在VS的调试中证实</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207231839825.png" alt="image-20220723183948793"></p><p>因为基类的成员变量被设置成了保护，所以我们不能直接在外部进行修改。<strong>需要显式调用基类的构造函数</strong>来初始化基类的成员。</p><h2 id="1-8-虚继承（菱形继承问题）"><a href="#1-8-虚继承（菱形继承问题）" class="headerlink" title="1.8 虚继承（菱形继承问题）"></a>1.8 虚继承（菱形继承问题）</h2><p>有的时候，继承会出现下面这种情况：一个子类继承了两个基类，而这两个基类又同时是一个基类的派生类</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205280831658.jpg" alt="未命名_副本"></p><p>这时候，D里面就会有两份A的内容，相当于两份公共部分。这是我们不想看到的，因为会造成空间浪费。而且直接访问的时候，编译器会报错“对变量X的访问不明确”</p><hr><p>比如：intel和amd联合推出的NUC小电脑中，有一款CPU是他们合作开发的</p><p>如何解决同时继承AMD和INTEL的问题？</p><ul><li>这时候会出现两个同名变量，一个是AMD里面有的，另外一个是INTEL里面有的<br>因为他们是从CPU里面继承来的。</li><li>虽然我们可以指定作用域来分别修改和访问。但是实际上这个公共部分就出现了浪费（比如是网站的公共部分，多给你一份没有啥意义）</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272058955.png" alt="image-20220527205808893"></p><p>和前面说道的同名问题一样，我们可以指定作用域来访问特定的变量，但是这样是治标不治本的方法，并没有解决空间浪费的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方法1（治表不治本）</span></span><br><span class="line"><span class="comment">//用类域来修改和访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;intel: &quot;</span> &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;amd: &quot;</span>   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这就需要我们使用<strong>虚继承</strong>来操作：给B和C对A的继承加上<code>virtural</code>关键字（对公共基类的继承添加上虚继承关键字）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CPU</span>()</span><br><span class="line">		:_Structure(<span class="string">&quot;x86&quot;</span>)</span><br><span class="line">	&#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> _Structure[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">INTEL</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> CPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">INTEL</span>()</span><br><span class="line">		:<span class="built_in">i_Brand</span>(<span class="string">&quot;intel&quot;</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> i_Brand[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMD</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> CPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AMD</span>()</span><br><span class="line">		:<span class="built_in">a_Brand</span>(<span class="string">&quot;amd&quot;</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> a_Brand[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时继承AMD和INTEL</span></span><br><span class="line"><span class="comment">//相当于有两个_Structure变量</span></span><br><span class="line"><span class="comment">//实际上我们只需要一个就够了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NUC</span> :<span class="keyword">public</span> AMD, <span class="keyword">public</span> INTEL &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NUC n1;</span><br><span class="line">	<span class="comment">//对“_Structure”的访问不明确</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; n1._Structure &lt;&lt; endl;//err</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//解决方法1（治表不治本）</span></span><br><span class="line">	<span class="comment">//用类域来修改和访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;intel: &quot;</span> &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;amd: &quot;</span>   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解决方法2，在AMD和INTEL对CPU的继承上加virtual</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;n1访问：&quot;</span> &lt;&lt; n1._Structure &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//现在就没有报错了</span></span><br><span class="line">	<span class="comment">//因为这时候AMD和INTEL中的_Structure都会指向同一个地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;intel: &quot;</span> &lt;&lt; &amp;(n1.INTEL::_Structure) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;amd:   &quot;</span> &lt;&lt; &amp;(n1.AMD::_Structure) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改INTEL中的_Structure，也会连代修改AMD中的_Structure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候直接访问变量就不会报错了。因为这时候，B和C中的该变量指向了<strong>同一个地址</strong>，修改操作会同步。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272057303.png" alt="image-20220527205708237"></p><h3 id="继承模型"><a href="#继承模型" class="headerlink" title="继承模型"></a>继承模型</h3><h4 id="普通菱形继承"><a href="#普通菱形继承" class="headerlink" title="普通菱形继承"></a>普通菱形继承</h4><p>下图中的继承模型是一个简单的菱形继承，我们能看到d中关于两个公共<code>A._a</code>的位置是不相同的；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/539c981de721bedb42e1824d872306ae.png" alt="image-20230731104907516"></p><p>在cpu继承模型中也是如此，amd和intel继承的cpu类中<code>X86</code>字符串的<strong>地址</strong>是不相同的</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/6e63170f1f2fe26138dc53a6721ada64.png" alt="image-20220723202515227"></p><p>这里因为<strong>内存对齐</strong>的问题，我们无法看清楚它的全貌。</p><p>但通过这里的继承模型，可以看出来在菱形继承问题中，不使用虚继承会造成两个CPU对象的多次继承，导致访问不明确的特性。</p><h4 id="虚继承模型"><a href="#虚继承模型" class="headerlink" title="虚继承模型"></a>虚继承模型</h4><p>那换成<strong>虚继承</strong>之后的模型是什么样子的呢？</p><p>先用d本身访问<code>d._a</code>，可以看到红色箭头所指区域的内存被初始化为0</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/e81a504bc373a86ed8a5908b43121be4.png" alt="image-20230731105334008"></p><p>再指定作用域<code>B::</code>进行访问，会发现其修改的依旧是这个地址的数据！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/f8272ceb25beeef5001abf14472f6bde.png" alt="image-20230731105446223"></p><p>用作用域<code>C::</code>来访问的结果也是如此，依旧修改的是相同内存位置的数据</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/4ef8345ce3ca5b4c8b970f49cf505ead.png" alt="image-20230731105535444"></p><p>由此可见，菱形继承了之后，<code>_a</code>变量的地址就被确定为一个地址了。所有作用域中的<code>_a</code>指向的都是这个公共地址，修改的都是这个公共地址的值，也就不会出现二义性问题！</p><p>最终运行完毕，内存窗口如图，A被丢到了最后面</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/0a4d677c3db99bb7e3b2f88fdb90178c.png" alt="image-20230731105858019"></p><p>再说回上方提到的cpu继承模型，进入调试窗口，可以看到这里分别分为了3个模块，保存了不同基类的成员。而它们之中的<code>_Stucture</code>成员只有一个（指向<code>&quot;x86&quot;</code>字符串的地址是相同的），所以就不会出现异义；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207231901496.png" alt="image-20220723190101443"></p><p>此时我们会发现，不管是上方ABCD的继承模型，还是这里的CPU继承模型，内存都出现了一定的<code>空置</code>；那这里空着的空间是用来做什么的呢？也是内存对齐吗？<strong>非也</strong>！</p><h3 id="虚基表"><a href="#虚基表" class="headerlink" title="虚基表"></a>虚基表</h3><ul><li>通过在<strong>虚基表</strong>中存放虚基类的偏移量，可以解决菱形继承产生的二义性问题。</li></ul><p>下图能帮你了解这个虚继承模型中，内存的区块是怎么划分的；可以看到B和C这两个父类都会有一个<strong>虚基表的指针</strong>，指向虚基表的地址。地址中存放的是B和C对象跟A对象地址的偏移量。</p><blockquote><p>B和C两个对象都有自己独立的虚基表地址，而不是共用一个，是为了方便切片时候的查询。</p></blockquote><p>这样，虚基表就帮我们避免了在访问菱形继承模型时出现异义的问题。不过，因为多了一层间接的偏移量查询，访问公共基类的成员的效率会有所降低。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/26f3a81af11bc336ccfcaef7a76c0411.png" alt="image-20230731111119744"></p><p>cpu的继承模型也是如此，在amd和intel这两个字符串存储位置上方，存放的就是一个<strong>虚基表的地址</strong>。而虚基表的这个地址之后紧跟着的就是一个<strong>当前对象跟基类对象的偏移量</strong>的数据；</p><p>同时也能总结出一个规律，虚基表的地址中的<strong>数据</strong>以全0开头，第二个（准确来说应该是偏移4个字节）的地址才是<strong>基类偏移量的数据</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/2828b9d9e1526c12410f50fed78380d4.png" alt="image-20230731111050252"></p><p>这样做就有一个好处，即便我们使用不同的基类指针（比如amd或者intel）来指向nuc的子类对象；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NUC n1;</span><br><span class="line">AMD* amd = &amp;n1;</span><br><span class="line">INTEL* itl = &amp;n1;</span><br></pre></td></tr></table></figure><p>这里的赋值需要对<code>NUC</code>对象进行<strong>切片</strong>，要获取到<code>AMD/INTEL</code>这两个父类的成员的同时，还需要获取到公共基类<code>CPU</code>成员的位置；</p><p>此时因为存在虚基表，它们都可以通过<strong>各自</strong>虚基表里面存放的<strong>偏移量</strong>，来计算公共基类CPU成员的位置，从而获取到了CPU类的成员。</p><p>另外，当AMD和INTEL采用虚继承来继承CPU的时候，<strong>他们类内就已经会有虚基表了</strong>。跟他们自己是否存在子类无关！这样是为了保证访问时候的统一性。比如如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NUC n;</span><br><span class="line">AMD a;</span><br><span class="line">AMD* amd1 = &amp;n;</span><br><span class="line">AMD* amd2 = &amp;a;</span><br></pre></td></tr></table></figure><p>对于编译器而言，其并不知道<code>AMD*</code>指针到底指向的是本类还是子类，而AMD对象本身也有虚基表，就能保证不管是本类还是子类，都能通过同样的方式（通过虚基表查询偏移量）来找到虚继承的父类CPU的地址，从而访问到父类对象成员。</p><blockquote><p>使用虚基表还可以让开发者灵活控制编译器对内存区块划分的优化。比如上面的两个栗子中，在VS2019里面，公共基类一般都是处于最下方的。</p><p>但如果我想设计公共基类放在最上方，也可以通过虚基表中的偏移量来实现。</p><p>而如果cpp强制规定公共基类必须要在普通基类的下方，而不使用虚基表来存放基类偏移量，那就限制了编译器的开发，也不方便实际的查找</p></blockquote><p>C++STD中的IO流就使用了菱形继承来进行设计。</p><p>但对于我们而言，由于菱形继承实在过于复杂，一般不建议你这么“作死”；</p><h2 id="1-9-继承和组合"><a href="#1-9-继承和组合" class="headerlink" title="1.9 继承和组合"></a>1.9 继承和组合</h2><ul><li>继承：上述所说。每一个派生类对象都是一个基类对象<code>is-a</code></li><li>组合：在一个类里面包含另外一个类的对象成员。每一个B对象中都包含了一个A <code>has-a</code>；比如我们在自己的类中使用<code>std::string</code>，此时我们自己的类和<code>std::string</code>的关系就是组合</li></ul><p>组合是黑盒复用，继承是百盒复用（子类能知道父类的细节，称为白盒）</p><p>实际情况中，建议优先选择组合，而不是继承。</p><ul><li>继承增加了代码的复用性，但是在一定程度上破坏了基类的封装性。派生类和基类的关联很强，耦合度高。</li><li>对象组合是另外一种复用的选择，这时候，对象A的内部结构是不得而知的。这样就减小了对象之间的关联性，耦合度低，保护了封装，更方便代码的维护</li></ul><p>不过，继承还有另外一种用途，那就是多态。我们下边会讲解的！</p><p>在软件设计中，追求<code>高内聚，低耦合</code>，不同模块之间的关联度应该竟可能的低。在设计类间关系，和不同功能模块的时候，需要考虑具体场景来进行继承和组合的选用。</p><p>比如A继承B，此时两个类就被强关联在一起了，<strong>耦合度相对较高</strong>。对父类A的任何修改i，都会影响达到B，甚至导致B无法正常运行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多继承所导致的菱形继承问题，在一定程度上让C++的语法变得复杂了。比如java是没有多继承的。在实际使用情况中，不建议使用多继承。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207280837462.jpg" alt="QQ图片20220424132540"></p><h1 id="2-多态"><a href="#2-多态" class="headerlink" title="2.多态"></a>2.多态</h1><ul><li>静态多态：函数重载</li><li>动态多态：派生类和虚函数组成的多态</li></ul><p>多态通俗地讲就是多种形态，当不同的对象去完成相同的事情的时候，会产生不同的状态。</p><p>比如买票这个行为，会衍生出全票、儿童票、学生票等等类型。不同身份的人过来买票，应该调用不同的处理流程。使用多态，就能将这些不同流程的相同类型函数（都是在买票）给拟合成不同子类对象中的同名函数；</p><blockquote><p>注意，多态只是实现这个场景的方式之一；你当然可以封装毫无相干的类，或者是使用函数重载，多个函数，判断语句来解决此类问题。</p></blockquote><h2 id="2-1-虚函数"><a href="#2-1-虚函数" class="headerlink" title="2.1 虚函数"></a>2.1 虚函数</h2><h3 id="2-1-1-基本使用以及动态多态"><a href="#2-1-1-基本使用以及动态多态" class="headerlink" title="2.1.1 基本使用以及动态多态"></a>2.1.1 基本使用以及动态多态</h3><p>虚函数，并不代表这个函数是虚无的。而表示这个函数在一定情况下会被<strong>替换</strong>（就好比继承中的虚继承问题）。要实现动态多态，就需要借助<strong>虚函数</strong>来实现。</p><blockquote><p>这里顺便提一嘴函数的三种关系：重载、隐藏（继承中同名问题）、覆盖（多态中虚函数被子类覆盖）</p></blockquote><p>虚函数需要满足两个条件</p><ul><li><strong>函数名、参数、返回值</strong>都相同</li><li>父类中该函数使用了<code>virtual</code>关键字来修饰此函数</li></ul><p>而调用的时候，必须是父类<code>指针/引用</code>指向子类的对象的时候，才会调用子类重写后的虚函数（如果没有重写该函数，则调用的依旧是父类的函数）</p><hr><p>以下面这个动物说话的代码为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//void Talk()</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Talk</span><span class="params">()</span><span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal is talking&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAT</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Talk</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CAT is talking&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DOG</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Talk</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DOG is talking&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类中不使用虚函数时，该函数的内容已确定</span></span><br><span class="line"><span class="comment">//不管传参什么类，都会调用Animal自己的Talk函数</span></span><br><span class="line"><span class="comment">//加上虚函数virtual后，会调用CAT和DOG的Talk函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MakeTalk</span><span class="params">(Animal&amp; it)</span> </span>&#123;</span><br><span class="line">	it.<span class="built_in">Talk</span>();<span class="comment">//调用对应的Talk函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当基类Animal中的Talk函数没有用<code>virtual</code>修饰时，不管给这个函数传参什么类的对象，它都会调用Animal<strong>自己</strong>的Talk函数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272139327.png" alt="image-20220527213937251"></p><p>当我们用<strong>虚函数</strong>进行修饰后，就会调用<strong>派生类</strong>CAT和DOG的Talk函数，这就实现了一个简单的动态多态。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272140385.png" alt="image-20220527214022282"></p><p>对于虚函数，有几点需要注意：</p><ul><li>当基类的<strong>指针或引用</strong>指向派生类的对象时，就会触发动态多态，派生类中的同名函数会覆写基类中的虚函数</li><li>不能定义静态虚函数——因为静态函数是属于整个类的，而不是属于某一个对象</li><li>不能定义虚构造函数——总不能用派生类的构造来覆写基类的构造吧？这不符合继承中对构造函数的要求</li><li><strong>析构函数可以是虚函数</strong></li></ul><h3 id="2-1-2-虚析构函数"><a href="#2-1-2-虚析构函数" class="headerlink" title="2.1.2 虚析构函数"></a>2.1.2 虚析构函数</h3><p>有的时候，我们需要析构一个子类对象时，往往会给<strong>基类</strong>的析构函数加上<code>virtual</code>修饰，这样只要传派生类的对象给基类的指针&#x2F;引用，就可以直接调用派生类对应的析构函数，完成不同的析构操作。</p><p>而不是都呆呆的调用基类的析构函数——那样就会产生内存泄漏，因为子类部分的成员并没有被析构！</p><p>这也是为何，类中析构函数会被统一重命名为<code>destructor()</code>，便是为了让父类和子类的析构函数在设置了<code>virtual</code>关键字后，函数同名，可以构成多态！</p><p>所以，如果一个类是基类，最好将析构设置成虚析构。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>()</span><br><span class="line">        : _a(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> : <span class="keyword">public</span> Queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>(<span class="type">int</span> capa)</span><br><span class="line">        : _a1(<span class="keyword">new</span> <span class="type">int</span>[capa])</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyStack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~MyStack&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _a1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *_a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue *q1 = <span class="keyword">new</span> <span class="built_in">Queue</span>();</span><br><span class="line">    <span class="keyword">delete</span> q1; <span class="comment">// 调用父类的析构函数</span></span><br><span class="line"></span><br><span class="line">    Queue *q2 = <span class="keyword">new</span> <span class="built_in">MyStack</span>(<span class="number">4</span>); <span class="comment">// 父类指针指向子类</span></span><br><span class="line">    <span class="keyword">delete</span> q2;                  <span class="comment">// 如果加了虚析构，就会调用子类的析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中我们将子类<code>MyStack</code>的指针赋值给了父类。运行这个函数，会发现父类的析构函数被正常调用了两次，但子类的析构函数并没有被调用。</p><p>这就导致子类对象中的<code>int *_a1;</code>指针申请的内存没有被正常释放，从而导致内存泄露；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Queue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] _a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们给父类的析构添加上<code>virtual</code>关键字后，再次运行这个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~Queue</span><br><span class="line">~MyStack</span><br><span class="line">~Queue</span><br></pre></td></tr></table></figure><p>此时父类和子类的析构都被成功调用了！</p><p>为了更好的观察析构顺序，给两个类都新增了一个成员变量作为标记位，在析构的时候打印。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">int</span> no)</span><br><span class="line">        : _a(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]), _no(no)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Queue &quot;</span> &lt;&lt; _no &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _no;</span><br><span class="line">    <span class="type">int</span> *_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> : <span class="keyword">public</span> Queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>(<span class="type">int</span> capa, <span class="type">int</span> no)</span><br><span class="line">        : _a1(<span class="keyword">new</span> <span class="type">int</span>[capa]), <span class="built_in">Queue</span>(no), _nos(no)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyStack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~MyStack &quot;</span> &lt;&lt; _nos &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _a1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *_a1;</span><br><span class="line">    <span class="type">int</span> _nos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue *q1 = <span class="keyword">new</span> <span class="built_in">Queue</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> q1; <span class="comment">// 调用父类的析构函数</span></span><br><span class="line"></span><br><span class="line">    Queue *q2 = <span class="keyword">new</span> <span class="built_in">MyStack</span>(<span class="number">4</span>, <span class="number">2</span>); <span class="comment">// 父类指针指向子类</span></span><br><span class="line">    <span class="keyword">delete</span> q2;                     <span class="comment">// 如果加了虚析构，就会调用子类的析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，可以看到，第二个指针<code>q2</code>被<code>delete</code>释放的时候，先调用了子类的析构函数，后调用了父类的析构函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~Queue 1</span><br><span class="line">~MyStack 2</span><br><span class="line">~Queue 2</span><br></pre></td></tr></table></figure><p>这样就不会出现内存泄露了！</p><h3 id="2-1-3-子类不重写"><a href="#2-1-3-子类不重写" class="headerlink" title="2.1.3 子类不重写"></a>2.1.3 子类不重写</h3><p>在这个继承模型中，子类<code>Stu</code>并没有重写父类函数，运行的时候，调用的都是父类的成员函数。这是一个普通的继承调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A *<span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual A* f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stu s;</span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    Person* ptr = &amp;p;</span><br><span class="line">    ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line">    ptr = &amp;s;</span><br><span class="line">    ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtual A* f()</span><br><span class="line">virtual A* f()</span><br></pre></td></tr></table></figure><h3 id="2-1-4-协变"><a href="#2-1-4-协变" class="headerlink" title="2.1.4 协变"></a>2.1.4 协变</h3><p>虚函数重写的时候，对返回值还会有一个例外的要求：<strong>协变</strong>；</p><p>前面提到，虚函数构成重写，必须要保证返回值相同。但协变的存在就新增了一个规定，我们的返回值并不一定要严格相同。</p><p>父类甲中函数返回值是某个父类乙的指针&#x2F;引用时，子类丙虚函数重写的时候，返回值可以是<strong>子类丁&#x2F;父类乙</strong>的<strong>指针&#x2F;引用</strong>（对应父子关系即可，在这里，<code>甲丙/乙丁</code>是两对父子）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B类继承了A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A *<span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual A* f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> B *<span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual B* f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stu s;</span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    Person* ptr = &amp;p;</span><br><span class="line">    ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line">    ptr = &amp;s;</span><br><span class="line">    ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>Stu</code>子类对父类虚函数的重写，返回值就是子类的指针；编译通过并运行，结果如下。可见的确构成了多态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test</span><br><span class="line">$ ./test</span><br><span class="line">virtual A* f()</span><br><span class="line">virtual B* f()</span><br></pre></td></tr></table></figure><p>如果带上引用，效果也是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A *<span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual A* f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A &amp;<span class="title">func_a</span><span class="params">(A &amp;a, B &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual A &amp;func_a(A &amp;a, B &amp;b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> B *<span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual B* f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> B &amp;<span class="title">func_a</span><span class="params">(A &amp;a, B &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual B &amp;func_a(A &amp;a, B &amp;b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stu s;</span><br><span class="line">    Person p;</span><br><span class="line">    B test_b;</span><br><span class="line"></span><br><span class="line">    Person *ptr = &amp;p;</span><br><span class="line">    ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">func_a</span>(test_b,test_b);</span><br><span class="line"></span><br><span class="line">    ptr = &amp;s;</span><br><span class="line">    ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">func_a</span>(test_b,test_b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我给<code>func_a</code>设计了两个参数，保证两个函数参数相同；需要注意子类的引用没办法赋值父类的对象。只有父类的引用才能赋值子类对象。（权限只能缩小不能扩大）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virtual A* f()</span><br><span class="line">virtual A &amp;func_a(A &amp;a, B &amp;b)</span><br><span class="line">virtual B* f()</span><br><span class="line">virtual B &amp;func_a(A &amp;a, B &amp;b)</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></table></figure><p>下面的这种情况就是不允许的！两个函数的参数不同，虽然满足协变的条件，但不满足虚函数重写的规定；可以看到运行后，两次调用都是父类的<code>func_a</code>函数；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/19d10a0f41a65a33d7d7a1990a5c7558.png" alt="image-20230731162200428"></p><h3 id="2-1-5-重写不带virtual"><a href="#2-1-5-重写不带virtual" class="headerlink" title="2.1.5 重写不带virtual"></a>2.1.5 重写不带virtual</h3><p>子类重写该函数的时候，可以不带<code>virtual</code>关键字。即便不带，依旧保有虚函数特性，可以被二次重写。这是因为子类继承父类的时候，<span id="jump"><strong>先继承了虚函数的声明</strong></span>（相当于从父类中继承了<code>virtual</code>关键字）</p><blockquote><p>记住这点，后面要考</p></blockquote><p>虽然这个关键字可以被省略，但不建议你省略它。这个关键字能告诉其他开发者，这个函数是一个重写了父类的虚函数（也有可能是一个即将被重写的虚函数）。相当于一个提示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A *<span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual A* f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A &amp;<span class="title">func_a</span><span class="params">(A &amp;a, B &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual A &amp;func_a(A &amp;a, B &amp;b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">B *<span class="title">f</span><span class="params">()</span><span class="comment">//可以省略virtual关键字</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual B* f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> B &amp;<span class="title">func_a</span><span class="params">(A &amp;a, B &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;virtual B &amp;func_a(A &amp;a, B &amp;b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMing</span> : <span class="keyword">public</span> Stu</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">B* <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;XiaoMing virtual B* f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stu s;</span><br><span class="line">    Person p;</span><br><span class="line">    XiaoMing xiao;</span><br><span class="line">    B test_b;</span><br><span class="line"></span><br><span class="line">    Person *ptr = &amp;p;</span><br><span class="line">    ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">func_a</span>(test_b, test_b);</span><br><span class="line"></span><br><span class="line">    ptr = &amp;s;</span><br><span class="line">    ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">func_a</span>(test_b, test_b);</span><br><span class="line"></span><br><span class="line">    ptr = &amp;xiao;</span><br><span class="line">    ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">virtual A* f()</span><br><span class="line">virtual A &amp;func_a(A &amp;a, B &amp;b)</span><br><span class="line">virtual B* f()</span><br><span class="line">virtual B &amp;func_a(A &amp;a, B &amp;b)</span><br><span class="line">XiaoMing virtual B* f()</span><br><span class="line">~B()</span><br><span class="line">~A()</span><br></pre></td></tr></table></figure><p>截图说明</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/c717b48e79203b7267e5e193da786b38.png" alt="image-20230731163708802"></p><h4 id="坑人的问题"><a href="#坑人的问题" class="headerlink" title="坑人的问题"></a>坑人的问题</h4><p>这个知识点就可以引伸出一个比较坑人的问题了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dad</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dad -&gt; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Dad&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son -&gt; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son* s = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    s-&gt;<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问如上代码的输出结果是什么？它调用的到底是谁的func函数呢？打印的a的值又是多少呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A   Dad -&gt; 3</span><br><span class="line">B   Dad -&gt; 1</span><br><span class="line">C   Son -&gt; 1</span><br><span class="line">D   Son -&gt; 3</span><br><span class="line">E   编译不通过</span><br><span class="line">F   以上都不正确</span><br></pre></td></tr></table></figure><p>答案揭晓，选择的是<code>D</code>，输出结果是<code>Son -&gt; 3</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Son -&gt; 3</span><br></pre></td></tr></table></figure><p>刚开始遇到这道题的时候，我也是一脸蒙蔽。直到看了题解才知道这里多坑人。</p><blockquote><p>其中E和F肯定是不能选的，一般情况下这两个选项都是过来迷惑你的。</p><p>比如有人可能会觉得<code>new</code>了之后没有<code>delete</code>，有语法错误！但实际上你不<code>delete</code>编译器是不会报错的，要不然也不会存在因为忘记<code>delete</code>而出现的内存泄露问题了。</p></blockquote><p>回到 <a href="#jump">2.1.5小点</a> 的开头， 提到了子类继承父类函数的时候，会先继承父类函数的<strong>声明</strong>；</p><p>对于普通函数而言，声明无伤大雅。但这里，子类和父类函数声明中参数a的<strong>缺省值</strong>不相同！</p><p>最终我们通过子类对象调用<code>test()</code>函数的时候，是将子类对象的指针交给了父类对象的指针。不要忘记了，类中所有成员函数都会有一个隐藏的<code>this</code>指针传参！</p><p>实际上，test函数的声明应该是下面这个。我们用子类对象掉用的时候，传入的<code>this</code>指针是子类对象的指针，自然就出现了将<code>子类对象赋值给父类指针</code>的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(Dad* <span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就满足了虚函数的两个条件：父类指针指向子类对象；子类重写了父类的虚函数。</p><p>这时候调用的<code>func()</code>函数，自然是子类中被重写了的<code>func()</code>函数，<strong>但由于继承了父类的函数声明</strong>，a的缺省值被修改成了父类中<code>func()</code>函数的3，最终就打印出了 <code>Son -&gt; 3</code> 的结果；</p><p>为了验证这个结论，我们还可以把子类中<code>func</code>函数的缺省值删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dad</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dad -&gt; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Dad&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son -&gt; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son* s = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    s-&gt;<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上来说，子类函数重写了父类的<code>func</code>，此时这个函数没有缺省值，调用一个没有传参的<code>func()</code>函数应该是会报错的。</p><p>但由于其继承了父类中的函数声明，并没有报错，编译通过了，输出的结果不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test</span><br><span class="line">$ ./test</span><br><span class="line">Son -&gt; 3</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/11dc204fc7bdd01d0cb68e7839628295.gif" alt="坑爹呢这是"></p><p>所以啊，为了避免这种情况，虚函数请不要设计缺省值！</p><hr><p>还是上面那道题，如果是直接调用func，应该输出什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dad</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dad -&gt; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Dad&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son -&gt; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son* s = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    s-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就和什么继承父类函数声明没有关系了，直接调用的就是子类自己重写了的函数，可以理解为是一个普通的函数调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Son -&gt; 1</span><br></pre></td></tr></table></figure><p>多态必须要父类指针&#x2F;引用指向子类的时候才能触发！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son* s = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    s-&gt;<span class="built_in">func</span>();<span class="comment">//普通调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个才是多态调用</span></span><br><span class="line">    Dad* dd = s;</span><br><span class="line">    dd-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Son -&gt; 1</span><br><span class="line">Son -&gt; 3</span><br></pre></td></tr></table></figure><h2 id="2-2-C-11-override和final"><a href="#2-2-C-11-override和final" class="headerlink" title="2.2 C++11 override和final"></a>2.2 C++11 override和final</h2><p>C++11中新增了override和final这两个关键字</p><h3 id="2-2-1-final"><a href="#2-2-1-final" class="headerlink" title="2.2.1 final"></a>2.2.1 final</h3><p>final用于类内成员函数之后，作用是让这个虚函数<strong>无法被重写</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/2a4fe40ec526c54cc68cdc7d34bac7c5.png" alt="image-20230802123422146"></p><p>这个关键字的第二个做用，修饰类，被修饰后的类<strong>无法被继承</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11直接用关键字final修饰，B类就不能被继承了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/51c10fc204ec383bf0312b4a86ff5b7a.png" alt="image-20230802123710960"></p><h3 id="2-2-2-override"><a href="#2-2-2-override" class="headerlink" title="2.2.2 override"></a>2.2.2 override</h3><p>该关键字用于子类中，也是丢在函数后，用于验证<strong>是否完成重写</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如在上面的代码中，基类中并没有test2存在，此时我们在test2后加上了<code>override</code>，编译器就会进行检查并报错。因为test2并不是一个对基类中函数的重写</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/ec65776f13a015fd8dcc19ab664d4920.png" alt="image-20230802124114029"></p><p>将override添加到<code>test1</code>函数之后，就不会报错了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">override</span>  </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span>  </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但如果将基类A的test1的虚函数<code>virtual</code>属性去掉，则又会报错；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/16413e187cb373a9b38a732d5a9e85ad.png" alt="image-20230802124211291"></p><p>如果基类和子类两个同名函数的<strong>参数不相同</strong>，不构成重写，也会报错</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/dbd59887a4486870916a722ddda49dd5.png" alt="image-20230802124323739"></p><p>这个关键字就可以用于在多态类设计中，比如所有子类都会有一个<code>buy</code>的函数重写，那就可以在buy函数后添加一个<code>override</code>，<strong>来检查我的重写是否完成</strong>，参数是否与基类中该函数的参数相同，以及函数名是否正确。</p><h2 id="2-3-重载、覆盖（重写）、隐藏（重定义）的对比"><a href="#2-3-重载、覆盖（重写）、隐藏（重定义）的对比" class="headerlink" title="2.3 重载、覆盖（重写）、隐藏（重定义）的对比"></a>2.3 重载、覆盖（重写）、隐藏（重定义）的对比</h2><p>常考，要理解并记忆</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/1aea383777eb978316c68f8840a291fc.png" alt="image-20230802193432749"></p><h1 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h1><p>包含纯虚函数的类就是抽象类，抽象类不能实例化对象</p><h2 id="3-1-纯虚函数"><a href="#3-1-纯虚函数" class="headerlink" title="3.1 纯虚函数"></a>3.1 纯虚函数</h2><p>在虚函数的基础上，C++定义了纯虚函数：有些时候，在基类里面定义某一个函数是没有意义的，这时候我们可以把它定义为<strong>纯虚函数</strong>，具体的实现让派生类去同名覆写。</p><p>纯虚函数的基本形式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//virtual 函数返回类型 函数名()=0;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>派生类中，<strong>必须重写</strong>基类的纯虚函数，否则该类也是抽象类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//virtual void Print();//虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B print &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C print &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在派生类中覆写了该函数后，即可实例化对象并调用该函数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272207840.png" alt="image-20220527220700695"></p><p>和虚函数一样，使用基类的引用或指针来接收派生类的对象，即可调用对应的函数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272209664.png" alt="image-20220527220929573"></p><p>纯虚函数内部是可以写函数实现的，<strong>但是没有任何意义</strong>。因为纯虚函数必须要被子类重写，这个纯虚函数本身是不能被调用的。</p><h2 id="3-2-抽象类"><a href="#3-2-抽象类" class="headerlink" title="3.2 抽象类"></a>3.2 抽象类</h2><p>包含纯虚函数的类就是抽象类，抽象类有下面几个特点：</p><ul><li>抽象类<strong>无法实例化对象</strong>；</li><li>抽象类的派生类必须重写基类的纯虚函数，不然派生类也是抽象类；</li><li>如果在基类中定义的纯虚函数是const修饰的，则派生类中对应的函数也需要用const修饰；</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202205272205203.png" alt="image-20220527220539119"></p><p>如果我们在子类里面修改了函数的参数，那就不构成重写；此时子类B也是抽象类，无法被实例化对象了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//virtual void Print();//虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 新增了一个参数，不构成重写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B print &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-几个重要概念"><a href="#4-几个重要概念" class="headerlink" title="4.几个重要概念"></a>4.几个重要概念</h1><h2 id="4-1-实现继承和接口继承"><a href="#4-1-实现继承和接口继承" class="headerlink" title="4.1 实现继承和接口继承"></a>4.1 实现继承和接口继承</h2><p>普通函数的进程是一种<code>实现继承</code>，派生类继承了基类的函数，可以使用这个函数。此时继承的就是函数的实现；</p><p>多态中的虚函数是一种<code>接口继承</code>，子类继承的是父类中虚函数的接口，目的是为了在子类中进行重写，以达成多态的目的。此时继承的是函数的接口。</p><p>所以，如果不是为了多态，那就不要把父类的函数定义成虚函数。</p><h2 id="4-2-动态绑定和静态绑定"><a href="#4-2-动态绑定和静态绑定" class="headerlink" title="4.2 动态绑定和静态绑定"></a>4.2 动态绑定和静态绑定</h2><p>这是两个和编译相关的概念。</p><ul><li>静态绑定又称前期绑定（早绑定），在程序编译期间确定了程序的行为，也成为静态多态（函数重载）</li><li>动态绑定又称为后期绑定（晚绑定），是在程序运行期间，根据具体拿到的类型来决定程序的行为，调用具体的函数，又称为动态多态。</li></ul><h2 id="4-3-父类的构造和析构中虚函数不生效"><a href="#4-3-父类的构造和析构中虚函数不生效" class="headerlink" title="4.3 父类的构造和析构中虚函数不生效"></a>4.3 父类的构造和析构中虚函数不生效</h2><p>请记住，在父类的构造和析构中，如果出现虚函数，则只会调用父类自己的函数实现，子类针对该虚函数的重写不会生效！</p><p>以下面的代码为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="type">int</span> _b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base begin&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">func</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="type">int</span> _d = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derive</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive begin&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">func</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derive c;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，子类构造的时候，会先调用父类的构造函数，在父类的构造函数中调用func，是父类的func（即便func是虚函数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base begin</span><br><span class="line">Base func</span><br><span class="line">Base end</span><br><span class="line">Derive begin</span><br><span class="line">Derive func</span><br><span class="line">Derive end</span><br></pre></td></tr></table></figure><p>具体请参考我的另外一篇关于一道CPP选择题目的博客【<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/132437789?spm=1001.2014.3001.5501">点我</a>】</p><h1 id="5-包含虚函数的类的大小"><a href="#5-包含虚函数的类的大小" class="headerlink" title="5.包含虚函数的类的大小"></a>5.包含虚函数的类的大小</h1><p>请问下面的代码中，b和d对象的大小分别是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base b;</span><br><span class="line">	Derive d;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;d: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，b的大小是8，d的大小是12</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/0e5025d1bd02a5016ce1fb6786961e95.png" alt="image-20230802122525747"></p><p>当我们使用了<code>virtual</code>关键字修饰函数之后，类中就会出现一个<strong>虚函数表</strong>，简称<strong>虚表</strong>（需要和虚基表区分开来）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/4db671cf4c93913cbd190cff72020ee3.png" alt="image-20230802201334448"></p><blockquote><p>后文将解释虚函数表的作用，只有虚函数才会存在于虚表中</p></blockquote><p>这个虚函数表是一个指针<code>_vfptr</code>，指针的大小是<code>4/8</code>字节，b类的大小由虚函数表指针和int组成，d类的大小由虚函数表指针和两个int组成。</p><ul><li>在32位下，这两个类的大小分别是8和12；</li><li>在64位下，这两个类的大小分别是16和24（除了指针是8字节外，还需要内存对齐）；</li></ul><p>当我们把Base类中的函数修改回普通函数，可以看到类的大小又变成只包含一个int的4字节了。而Dervie类由于依旧有<code>virtual</code>的存在，所以大小不变。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/941172e763873257e10167ca3c2bc309.png" alt="image-20230802122954378"></p><h1 id="6-虚函数表（虚表）"><a href="#6-虚函数表（虚表）" class="headerlink" title="6.虚函数表（虚表）"></a>6.虚函数表（虚表）</h1><p>以这个类为示例，让我们来看看虚表的样子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内存窗口中，可以看到这两个对象的基本模块。<strong>子类对象中也存在一个虚表</strong>，而且可以发现，父子类的虚表中，只有<code>func1</code>的函数地址是不同的。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/4db671cf4c93913cbd190cff72020ee3.png" alt="image-20230802201334448"></p><p>这里的<code>_vfptr</code>是<code>virtual func pointer</code>的缩写，中文名是虚函数表指针，可以简称为虚表指针</p><blockquote><p>一定要区分虚函数表（多态）和虚基表（菱形继承）！</p></blockquote><h2 id="6-1-虚函数重写和覆盖的概念区别"><a href="#6-1-虚函数重写和覆盖的概念区别" class="headerlink" title="6.1 虚函数重写和覆盖的概念区别"></a>6.1 虚函数重写和覆盖的概念区别</h2><p>这里就需要提及重写和覆盖这两个概念的区别了</p><ul><li>虚函数重写：语法层的概念，指子类中重写父类中虚函数的函数实现</li><li>虚函数覆盖：原理层的概念，子类对象的序表中，子类拷贝了父类的虚表，<strong>重写后的函数的函数指针</strong>覆盖了基类对应虚函数的指针</li></ul><p>多态的实现，就依赖于子类虚表中对函数指针的覆盖，运行时，去指定对象的虚表中，调用对应的函数指针。这是一种<code>运行时决议</code>调用方法的操作；</p><p>在VS的调试窗口中，我们能看到一个完整的父类Base对象，这也是父类指针指向子类对象的实现原理。此时父类的指针是完全没有办法知道自己指向的是父类对象，还是某个子类对象；</p><p>虚函数表的存在，帮我们实现了通过相同的函数调用方法，实际却触发了不同函数的流程的操作。</p><h3 id="6-1-1-运行时决议和编译时决议"><a href="#6-1-1-运行时决议和编译时决议" class="headerlink" title="6.1.1 运行时决议和编译时决议"></a>6.1.1 运行时决议和编译时决议</h3><ul><li>多态调用，运行时决议：运行到这里时确定调用函数的地址</li><li>普通调用，编译时决议：在编译时就确定调用的函数的地址</li><li>因为存在一层通过虚函数表的跳转，所以多态调用会比普通调用的速度慢一些。</li></ul><p>依旧是上方的两个类，在基类和子类中同时存在一个普通函数<code>Func3()</code>，此时通过父类指针去调用的时候，就会发现二者调用的都是父类的<code>Func3</code>。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/16f19acc69f184c2588ec1c477ebe1d0.png" alt="image-20230802211156871"></p><p>这正是因为非虚函数是没有进入虚函数表，此时对<code>Func3</code>的调用就是一个普通函数调用；此时<code>Func3</code>函数的地址在编译出可执行文件的时候，就已经被确定为了基类中的函数地址。</p><p>而<code>Func1</code>因为是虚函数，存在于虚函数表中，所以是通过运行时查询这个虚函数表，来找到父子类不同的函数地址，最终实现多态调用。</p><h3 id="6-1-2-看看汇编"><a href="#6-1-2-看看汇编" class="headerlink" title="6.1.2 看看汇编"></a>6.1.2 看看汇编</h3><p>从图中可以看到，对于<code>Func1</code>的调用，最终是从虚函数表中提取出来的地址，<code>call eax</code>寄存器中的地址，这便体现了运行时决议；</p><p>而对<code>Func3</code>的调用，是编译时决议，直接已经确定了的基类中该函数的地址，直接<code>call 09511CCh</code>这个函数地址来调用函数了。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/ed1c51671937aa59ac4c2f79f6de1f39.png" alt="image-20230802211738847"></p><p>对于指向基类对象的调用也是这样</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/63ab70761f4f36eece59e5519fd114e9.png" alt="image-20230802211937870"></p><p>这里就能很直观的看到，多态中虚函数表，让父类指针不管是指向子类对象、还是指向父类对象，都能通过相同的汇编指令来调用正确的函数。</p><h2 id="6-2-子类对象赋值给父类为何无法实现多态？"><a href="#6-2-子类对象赋值给父类为何无法实现多态？" class="headerlink" title="6.2 子类对象赋值给父类为何无法实现多态？"></a>6.2 子类对象赋值给父类为何无法实现多态？</h2><p>我们都知道，继承了之后，如果把子类对象赋值给父类，则会产生切片。此时无法构成多态。</p><p>这是为什么呢？</p><p>因为编译器在编译的时候，就已经确定了这些函数的地址。</p><ul><li>编译器检查是否符合多态的语法</li><li>不符合多态的语法，则直接确定对类函数调用的成员函数地址</li><li>符合多态的语法，那就编译出运行时决议的汇编语句</li></ul><p>此时地址就已经确定了，根本不存在从虚函数表中找函数地址的步骤，自然就不能实现多态调用了。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/1cc4c5b61b917e6aa3edb33b299a77cf.png" alt="image-20230802214329278"></p><p>这时候可能有些人就会有个不成熟的想法：如果将子类对象赋值给父类对象，切片的时候把子类对象的虚表指针也复制到父类中，那不就能实现多态了吗？</p><p>不行！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derive dd;</span><br><span class="line">Base bb = dd; <span class="comment">// 子类对象赋值给父类</span></span><br><span class="line">Base* ptr1 = &amp;bb; <span class="comment">// 父类指针指向父类对象</span></span><br><span class="line">Base* ptr2 = &amp;dd; <span class="comment">// 父类指针指向子类对象</span></span><br><span class="line"><span class="comment">// 引用本质也是指针，这里就不写了</span></span><br></pre></td></tr></table></figure><p>以上面的代码为例，当我们把一个对象赋值给父类的指针时，程序运行的时候并不知道，这个指针指向的到底是父类还是子类对象。</p><p>假设我们在切片的时候，将子类对象dd的虚表指针也拷贝复制给父类了，那就会出现一个严重的问题：<code>ptr1</code>在调用函数的时候，调用的也是子类的函数！</p><p>这不就乱套了吗？！</p><p>理论上bb是一个父类对象，赋值给<code>Base*</code>指针后，我们调用函数的预期是调用父类的函数。但由于bb对象是从子类对象<strong>切片</strong>而来的，拷贝了子类的虚表指针，此时找到的也是子类的函数地址，不符合预期地调用了子类重写后的虚函数！</p><p>所以！为了避免这种不符合语法预期的问题，在切片的时候，只会将子类对象中的成员变量拷贝给父类，并不会拷贝虚表指针！切片生成的父类对象，虚表指针依旧是父类自己的虚表指针！</p><p>下图中可见，b3是切片而来的父类对象，其虚表指针以及虚表中的函数地址和<code>Base b1</code>完全相同。一个类的虚表其实只有一张。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/3879cc011a3ed1220c1c7e7a7f095bb1.png" alt="image-20230802221417892"></p><p>所以，对象并不能实现多态。即便理论上可行，但依旧不能这么做！</p><h2 id="6-3-子类中新增虚函数，但监视窗不显示"><a href="#6-3-子类中新增虚函数，但监视窗不显示" class="headerlink" title="6.3 子类中新增虚函数，但监视窗不显示"></a>6.3 子类中新增虚函数，但监视窗不显示</h2><h3 id="6-3-1-实地探索"><a href="#6-3-1-实地探索" class="headerlink" title="6.3.1 实地探索"></a>6.3.1 实地探索</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func4()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在子类中新增了一个虚函数<code>Func4</code>之后，再次打开监视，会发现子类的虚表中依旧只有两个函数指针。这是怎么回事？难道说子类没有被另外一个类继承，它的虚函数就不会进这里的虚表吗？</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/a08d37a14b82a34a31d55b96887dd5f5.png" alt="image-20230802223318886"></p><p>通过内存窗口，我们可以看到这里的出现了两个监视窗口中已有的函数地址，但后面还有一个和前面两个很接近，但在监视窗口中没有出现的地址。而在这个地址之后是一行全0（即<code>nullptr</code>）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/e11b875f18ffb0913018dbcfa53f6b92.png" alt="image-20230802225539031"></p><p>以<code>nullptr</code>做结尾作为for循环的判断条件，我们可以把虚函数表中函数的地址都打印出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定义函数指针，需要将新的名字放在括号中间</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*V_FUNC)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVfptrTable</span><span class="params">(V_FUNC* arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; arr[i] != <span class="literal">nullptr</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d] %p\n&quot;</span>, i, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base b1;</span><br><span class="line">	Derive d;</span><br><span class="line">    <span class="comment">// 因为我们已经知道了，在VS中，虚函数表的指针就是对象的前4个字节</span></span><br><span class="line">	<span class="comment">// 这里是先将对象的指针强转为int*，取出前4个字节的地址</span></span><br><span class="line">	<span class="comment">// 再将这个地址解引用，相当于将地址转成int数字</span></span><br><span class="line">	<span class="comment">// 最后再将这个数字重新强转为V_FUNC*函数指针数组的指针，传给我们的打印函数</span></span><br><span class="line">	<span class="built_in">PrintVfptrTable</span>((V_FUNC*)(*((<span class="type">int</span>*)&amp;d)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下， 可以看到成功打印出了3个函数的地址，和内存窗口中看到的数据一致</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/83c4f7aadd1283ecd924f4b5a960565e.png" alt="image-20230802230201218"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*V_FUNC)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVfptrTable</span><span class="params">(V_FUNC* arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; arr[i] != <span class="literal">nullptr</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d] %p -&gt; &quot;</span>, i, arr[i]);</span><br><span class="line">		V_FUNC f = arr[i];</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是函数指针，最终我们是可以通过函数指针来调用函数的。添加了函数调用部分的代码后，再运行，可以看到最后一个函数的确是子类中新增的虚函数<code>Func4</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/331acce23febb03dc6b65bfbe5511020.png" alt="image-20230802230531421"></p><p>所以，VS的监视窗口中不显示<code>Func4</code>是因为VS认为这个函数没有被子类重写，无关痛痒，于是在监视窗口中隐藏了。</p><p>实际上，只要是虚函数，那就是会进入到这个类中的虚函数表里面的！</p><p>记住，<strong>只要是虚函数就一定会进虚表</strong>！</p><h3 id="6-3-2-为什么不新增一个子类的虚表？"><a href="#6-3-2-为什么不新增一个子类的虚表？" class="headerlink" title="6.3.2 为什么不新增一个子类的虚表？"></a>6.3.2 为什么不新增一个子类的虚表？</h3><p>这里我还思考过另外一个问题，既然这个是子类自己的虚函数，那为什么没有多开一个虚表来存放这个函数的指针，而是直接放入到了继承自基类的虚函数表中呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">下图是Derive在VS2019的内存分布模型</span><br><span class="line">————————————</span><br><span class="line">|  _vfptr  | Base</span><br><span class="line">|  int _b  | Base</span><br><span class="line">|  int _d  | Derive</span><br><span class="line">————————————</span><br><span class="line"></span><br><span class="line">假设要新增一个指针，那按VS的规则，也是应该放在对象的最前面；</span><br><span class="line">此时模型就变成了下面这样</span><br><span class="line">————————————</span><br><span class="line">|  _vfptr  | Derive</span><br><span class="line">|  _vfptr  | Base</span><br><span class="line">|  int _b  | Base</span><br><span class="line">|  int _d  | Derive</span><br><span class="line">————————————</span><br><span class="line">新增了一个指针的内存占用不说，还把原本泾渭分明的内存模型，变成了两面包夹芝士；</span><br><span class="line">怎么说都是追加在Base的虚表之后更加靠谱，</span><br><span class="line">因为原本继承自Base的虚表就是子类对象的前4个字节！</span><br></pre></td></tr></table></figure><p>说明参考代码块中的注释。</p><h2 id="6-4-虚表的存储位置"><a href="#6-4-虚表的存储位置" class="headerlink" title="6.4 虚表的存储位置"></a>6.4 虚表的存储位置</h2><p>虚表是存在哪里的？先说答案：<strong>虚表是存在常量区里面的</strong>。</p><p>下图中的b1和b3是两个不同的<code>Base</code>对象，但我们会发现它们的虚表地址包括函数指针的地址都完全相同。毕竟这是两个完全相同的类，虚表里面的内容确实是相同的。</p><p>这就告诉了我们，相同的类，<strong>其虚表在内存里面只有一张</strong>。初始化的时候，将这个类的虚表找到，并插入到类的对象中。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/3879cc011a3ed1220c1c7e7a7f095bb1.png" alt="image-20230802221417892"></p><p>那么虚表是存在内存中的那个区域里面的呢？</p><p>首先排除栈和堆，栈是随时用随时开辟的，而堆需要动态内存管理，对于这种编译器自己完成的操作，也不应该是这样。而<code>静态区/数据段</code>放的是全局数据或者静态变量，好像也不符合虚函数表不变的特性；相比之下，<code>常量区/代码段</code>更靠谱。</p><p>有了猜想之后，就要来验证了。</p><p>我们将常用的存在内存中不同位置的数据类型都弄出来，分别打印它们的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base b1;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;栈：%p\n&quot;</span>, &amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;静态区/数据段：%p\n&quot;</span>, &amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;静态区/数据段：%p\n&quot;</span>, &amp;c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;常量区/代码段：%p\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;堆：%p\n&quot;</span>, p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;虚表：%p\n&quot;</span>, (*((<span class="type">int</span>*)&amp;b1)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数地址：%p\n&quot;</span>, &amp;Derive::Func3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数地址：%p\n&quot;</span>, &amp;Derive::Func2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数地址：%p\n&quot;</span>, &amp;Derive::Func1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/97f7db3b90259557a7b408dfce732876.png" alt="image-20230803073231110"></p><p>这时候可以发现，虚表的地址和常量区&#x2F;代码段的地址开头相似，都是<code>00DF9B</code>，说明它更加靠近代码段的区域。</p><p>而虚表的地址<code>00DF9B34</code>是小于常量区&#x2F;代码段的<code>00DF9B6C</code>的，这就表明了在内存中，虚表的地址比这个常量区参数的地址更低。而在内存中，不同区域的分布如下，常量区就是在最低处的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈</span><br><span class="line">堆</span><br><span class="line">静态区/数据段</span><br><span class="line">常量区/代码段</span><br></pre></td></tr></table></figure><p>实锤了，<strong>虚表就是存在常量区里面的</strong>！类的虚函数表是在<strong>编译阶段</strong>就已经生成了的。</p><h2 id="6-5-多继承中的虚表"><a href="#6-5-多继承中的虚表" class="headerlink" title="6.5 多继承中的虚表"></a>6.5 多继承中的虚表</h2><p>先说结论，如果出现了多继承，那么子类中会根据继承的父类分别产生<strong>独立的虚表</strong>（如果不是独立的，那就没有办法实现某个父类指针指向子类时，对子类的切片）</p><p>以下就是一个最简单的多继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _b1 = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base2::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _b2 = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base,<span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive::Func4()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过监视窗口，能看到这个对象的模型大概是如下图所示</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/6e265450176136e90bc424529327845c.png" alt="image-20230803082210045"></p><p>其中能看到子类独有的虚函数Func4是存在第一张虚表里面的（VS监视窗口依旧没有显示出来）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/783fb742a8750a93e79f1d98367dfafc.png" alt="image-20230803081656878"></p><p>这里还会发现一个问题：Base和Base2这两个基类中都有虚函数<code>Func1</code>，那为什么子类中这两个类的虚表中，这两个被子类重写的Func1函数的地址不相同呢？</p><p>通过之前写的打印函数来打印第二章虚表里面的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*V_FUNC)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVfptrTable</span><span class="params">(V_FUNC* arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; arr[i] != <span class="literal">nullptr</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d] %p -&gt; &quot;</span>, i, arr[i]);</span><br><span class="line">		V_FUNC f = arr[i];</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，我们对d这个子类的指针+1的时候，会直接跳过<code>sizeof(Derive)</code>个空间的大小。为了能精准地通过<code>+sizeof(Base)</code>找到<code>Base2</code>基类的虚表，就需要将子类的指针强转为<code>char*</code>，这样每次+1就是移动一个字节的空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PrintVfptrTable</span>((V_FUNC*)(*((<span class="type">int</span>*)((<span class="type">char</span>*)&amp;d+<span class="built_in">sizeof</span>(Base)))));</span><br></pre></td></tr></table></figure><p>运行可以看到，即便内存不同，但实际上调用的依旧是子类的<code>Func1</code>函数；也能看到子类单独新增的虚函数只会放在第一个虚表中。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/ab4f0f027ad8832cfe8133fbf708d4c8.png" alt="image-20230803082638559"></p><h3 id="6-5-1-Func1地址不同？"><a href="#6-5-1-Func1地址不同？" class="headerlink" title="6.5.1 Func1地址不同？"></a>6.5.1 Func1地址不同？</h3><p>在上面VS打印的虚表中，会发现一个问题：Base和Base1父类中的两个<code>Func1</code>函数的地址不相同，但最终我们看到的运行结果又都是子类重写后的Func1</p><p>把相同的代码挪到liunx环境下，编译运行，发现出现了段错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">[0] 0x400b74 -&gt; Derive::Func1()</span><br><span class="line">[1] 0x400b48 -&gt; Base::Func2()</span><br><span class="line">[2] 0x400ba6 -&gt; Derive::Func4()</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><blockquote><p>顺带一提，在linux下直接编译本博客中的代码会出现如下警告，因为我们对指针进行了多次强转，不用管他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;g++ test.cpp -o test -std=c++11</span><br><span class="line">&gt;test.cpp: In function ‘int main()’:</span><br><span class="line">&gt;test.cpp:92:44: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]</span><br><span class="line">    PrintVfptrTable((V_FUNC *)(*((int *)&amp;d)),3);</span><br><span class="line">                                           ^</span><br><span class="line">&gt;test.cpp:93:69: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]</span><br><span class="line">    PrintVfptrTable((V_FUNC *)(*((int *)((char *)&amp;d + sizeof(Base)))),1);</span><br><span class="line">                                                                    ^</span><br></pre></td></tr></table></figure></blockquote><p>这是因为我们在打印虚函数表中，判断条件是当前函数指针为空，这是VS下对虚函数表的结束规定（以nullptr结尾），并不是linux下的操作，也不是C++对虚表的统一规定。</p><p>所以，为了能正常打印出虚函数表，我们需要将打印函数的判断条件改成固定值；因为我们已经知道了虚函数表中函数的个数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定义函数指针，需要将新的名字放在括号中间</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*V_FUNC)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVfptrTable</span><span class="params">(V_FUNC *arr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_vfptr: %p\n&quot;</span>,arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] %p -&gt; &quot;</span>, i, arr[i]);</span><br><span class="line">        V_FUNC f = arr[i];</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如下是修改后的调用</span></span><br><span class="line"><span class="built_in">PrintVfptrTable</span>((V_FUNC *)(*((<span class="type">int</span> *)&amp;d)),<span class="number">3</span>);</span><br><span class="line"><span class="built_in">PrintVfptrTable</span>((V_FUNC *)(*((<span class="type">int</span> *)((<span class="type">char</span> *)&amp;d + <span class="built_in">sizeof</span>(Base)))),<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>再次编译运行，也出现了相同的结果，两个基类虚函数表中的<code>Func1</code>地址不相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">_vfptr: 0x400d10</span><br><span class="line">[0] 0x400b86 -&gt; Derive::Func1()</span><br><span class="line">[1] 0x400b5a -&gt; Base::Func2()</span><br><span class="line">[2] 0x400bb8 -&gt; Derive::Func4()</span><br><span class="line">_vfptr: 0x400d38</span><br><span class="line">[0] 0x400bb1 -&gt; Derive::Func1()</span><br></pre></td></tr></table></figure><p>再新增一个直接对<code>Derive::Func1</code>函数本身地址的打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PrintVfptrTable</span>((V_FUNC *)(*((<span class="type">int</span> *)&amp;d)),<span class="number">3</span>);</span><br><span class="line"><span class="built_in">PrintVfptrTable</span>((V_FUNC *)(*((<span class="type">int</span> *)((<span class="type">char</span> *)&amp;d + <span class="built_in">sizeof</span>(Base)))),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Derive::Func1 %p\n&quot;</span>,(<span class="type">void</span>*)&amp;Derive::Func1);</span><br></pre></td></tr></table></figure><p>输出结果如下，可以看到这个函数本身的地址和第一张虚表里面的<code>Derive::Func1()</code>地址是吻合的，但是和第二章虚表的地址不相符合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_vfptr: 0x400cd0</span><br><span class="line">[0] 0x400b60 -&gt; Derive::Func1()</span><br><span class="line">[1] 0x400b34 -&gt; Base::Func2()</span><br><span class="line">[2] 0x400b92 -&gt; Derive::Func4()</span><br><span class="line">_vfptr: 0x400cf8</span><br><span class="line">[0] 0x400b8b -&gt; Derive::Func1()</span><br><span class="line"></span><br><span class="line">Derive::Func1 0x400b60</span><br></pre></td></tr></table></figure><p>而在windows的vs2019中，打印的地址就更奇怪了，其和两个虚表中的地址都对不上！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_vfptr: 002D9B84</span><br><span class="line">[0] 002D141F -&gt; Derive::Func1()</span><br><span class="line">[1] 002D1393 -&gt; Base::Func2()</span><br><span class="line">[2] 002D106E -&gt; Derive::Func4()</span><br><span class="line">_vfptr: 002D9B98</span><br><span class="line">[0] 002D10B9 -&gt; Derive::Func1()</span><br><span class="line"></span><br><span class="line">Derive::Func1 002D1122</span><br></pre></td></tr></table></figure><blockquote><p>这里我还发现了一个奇怪的问题，相同的代码在windows下和linux下的效果不同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码在windows下可以正常打印函数地址，linux下打印出来的是0x1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Derive::Func1 %p\n&quot;</span>,(&amp;Derive::Func1));</span><br><span class="line"><span class="comment">// 下面的函数在linux下可以正常打印函数地址，在windows下报错“强制类型转换失效”</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Derive::Func1 %p\n&quot;</span>,(<span class="type">void</span>*)&amp;Derive::Func1);</span><br></pre></td></tr></table></figure><p>有人知道这是为啥吗？😂</p></blockquote><p>你可以理解这是在不同平台下，对虚表中函数指针的一个处理，其最终还是会调用到正确的函数的。</p><p>在windows下查看反汇编，能看到其最终是调用了<code>ebp-14h</code>的一个地址，在内存窗口中可以看到，这个地址正是虚表中存放的Func1函数地址</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/d58ed6905cbca46a797eca6aa2cc3051.png" alt="image-20230803090855304"></p><p>使用调试在反汇编窗口中逐条运行，能进到这个<code>call [ebp-14h]</code>语句中，可以看到在<code>002910B9</code>这个地址上存放的就是子函数中的<code>Func1</code>函数地址，这里的汇编指令<code>jmp</code>相当于跳转到这个函数地址上</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/b4c0122e48631d5c3c618d68bd58fac3.png" alt="image-20230803091038151"></p><p>再进一步观察会发现，这里显示的地址和打印出来的<code>func1</code>函数的地址还是不相同</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/375529f0deaee1cf63ac3c6d55ec43cc.png" alt="image-20230803091651052"></p><p>再跳转，还是不同</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/3c49a8aab779312b712412c20b6be42c.png" alt="image-20230803091321822"></p><p>再次跳转，依旧是不同</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/e530cdc0c6c2b97fa6be84dc86178f49.png" alt="image-20230803091719566"></p><p>再一次跳转，就跑到了子类中<code>Func1</code>函数的执行流里面了。此时就开始执行这个函数了！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/30e06a62a1de52962b9ac5116048e23a.png" alt="image-20230803091731208"></p><p>所以，这只是编译器在某些层面上的处理而已。包括第一个基类的虚表，也是这样的函数地址跳转。在linux下和windows的不同编译器下观察到的情况都不一样，我们没必要过多纠结于这里，只要知道有这类编译器处理的存在就可以了。</p><hr><p>最终两个基类对<code>func1</code>的函数调用的汇编流程如下图</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/8ec29327179e6165028e3cb996074aab.png" alt="image-20230803110713759"></p><p>这其中，我们要发现Base2对Func1的调用，主要是多了下面这两句非常不同的汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">008426B0 83 E9 08             sub         ecx,8</span><br><span class="line">008426B3 E9 67 ED FF FF       jmp         Derive::Func1 (084141Fh)</span><br></pre></td></tr></table></figure><p>原本走到这一步，ecx寄存器的值是 <code>0x00849b98</code>。这一步执行完毕后，ecx的值是<code>0x00849b90</code>，可以看到更新后的值比原本的值少了8字节；正好是<code>Base</code>类的大小！</p><p>这是因为在当前对象模型中，两个父类对象需要调用的Func1都是<strong>子类</strong>的Func1，此时使用的<code>this</code>指针应该是子类<code>Derive</code>的this指针，处于子类对象地址的起始位置。对于<code>Base* ptr1</code>来说，其指向的地址本身就是子类的起始地址，所以不需要进行修正。</p><p>但<code>Base2* ptr2</code>指向的位置并不是子类的起始地址，此时就需要<code>-8</code>回到起始位置，用修正后的this指针来调用子类的Func1函数；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/df0b755e09ee9e37c56a3d05893badb9.png" alt="image-20230803111315242"></p><p>这也就能解释为什么两个虚表中存放的函数指针地址不相同，因为调用的流程不一样，Base2的指针在调用的时候需要对ecx寄存器中的this指针进行修正。</p><h3 id="6-5-2-指针切片地址不同"><a href="#6-5-2-指针切片地址不同" class="headerlink" title="6.5.2 指针切片地址不同"></a>6.5.2 指针切片地址不同</h3><p>当我们用不同的父类指针指向这个子类对象的时候，由于会发生不同位置的切片，最终的地址并不相同。这点我们通过对象模型也能看出来，不同的父类都需要指向自己的那部分，所以切片后的地址不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Derive d;</span><br><span class="line">Base* ptr1 =  &amp;d;</span><br><span class="line">Base2* ptr2= &amp;d;</span><br><span class="line">Derive* ptr3 = &amp;d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Base: %p\nBase2: %p\nDerive: %p\n&quot;</span>, ptr1, ptr2, ptr3);</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/0aa7b9c545a8a902228a5ba2ef6992f0.png" alt="image-20230803083327674"></p><h2 id="6-6-菱形虚拟继承中的虚函数表"><a href="#6-6-菱形虚拟继承中的虚函数表" class="headerlink" title="6.6 菱形虚拟继承中的虚函数表"></a>6.6 菱形虚拟继承中的虚函数表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A:func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用上图代码进行虚拟继承的时候，内存模型如图，在B类和C类中都会有一个继承自A类的虚表；因为这里没有进行函数重写，所以地址是一样的。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/73cd95d6ced1d40910edba78f5abe480.png" alt="image-20230803113830741"></p><p>当我们在B和C类中重写此函数，对象模型如下，B类和C类中虚表的函数指针不同</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/3c055b9a481c35bc2ac072ac542465f0.png" alt="image-20230803114238024"></p><p>但如果我们把B和C对A的继承都改成虚继承，此时就会报错了！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/bed876e951dde4f893c39fcdaeb6b54a.png" alt="image-20230803114518251"></p><p>在前面的虚继承讲解中，提到了在VS下，是将公共基类放在子类的最后面的，此时模型的顺序大概如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>由于B和C都使用了虚继承，解决了数据二义性问题，但没有解决A中的虚表到底是存B重写后的func，还是存C重写后的func的问题；</p><p>这个时候我们就需要在D里面重写func，这时候就能确定最终使用的是D里面对func的重写，也就不会有到底是选B还是选C的分歧问题了。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/ad798953dae68a43236686a02001a9b9.png" alt="image-20230803114719980"></p><h2 id="6-7-虚函数和inline"><a href="#6-7-虚函数和inline" class="headerlink" title="6.7 虚函数和inline"></a>6.7 虚函数和inline</h2><h3 id="6-7-1-状态观察"><a href="#6-7-1-状态观察" class="headerlink" title="6.7.1 状态观察"></a>6.7.1 状态观察</h3><p>我们先尝试给一个虚函数加上<code>inline</code>内联关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;f1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明和定义分离就不是内联函数了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A aa;</span><br><span class="line">	aa.<span class="built_in">f1</span>();</span><br><span class="line">	aa.<span class="built_in">f2</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改VS2019项目的属性</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/cdc8a277a2ca826fa12a11b9516b536d.png" alt="image-20230803115444907"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/da819e1eabe3dc035d97b392be0c9c71.png" alt="image-20230803115210723"></p><p>转到反汇编，可以看到f1函数被展开，f2函数依旧是call地址的调用</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/98bbd5d1107a4c36563ff256bcb9f75a.png" alt="image-20230803115538575"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;f1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;f2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不将声明和定义分离，可以观察到两个函数都被编译器认作是内联而展开了。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/5355c277b6546602555b5a7b594d3235.png" alt="image-20230803115641759"></p><p>此时新增一个继承，再来看看反汇编</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;f1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明和定义分离就不是内联函数了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B f1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A aa;</span><br><span class="line">	aa.<span class="built_in">f1</span>();</span><br><span class="line">	aa.<span class="built_in">f2</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们发现，似乎f1函数依旧是有内联的属性</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/b0ea5d5ace031687067b468cbb83828f.png" alt="image-20230803120105176"></p><p>这说明虚函数是可以用<code>virtual</code>关键字来修饰的。</p><p>但如果用多态调用呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A* aa = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">aa-&gt;<span class="built_in">f1</span>();</span><br><span class="line">aa-&gt;<span class="built_in">f2</span>();</span><br></pre></td></tr></table></figure><p>此时就能发现，原本的多态展开，就变回了call函数地址的调用</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/7d24fab128145dbea57536e88b2ecd4b.png" alt="image-20230803120223673"></p><p><strong>这是因为内联函数是没有地址的</strong>！而多态基于虚基表实现，虚基表中必须要存放函数的地址！</p><h3 id="6-7-2-结论"><a href="#6-7-2-结论" class="headerlink" title="6.7.2 结论"></a>6.7.2 结论</h3><p>结论就是，在多态中，对虚函数的<code>inline</code>修饰不会报错，但会被编译器忽略（不会有内联的属性），依旧是个普通的函数</p><h2 id="6-8-派生类的初始化过程中，调用完毕父类构造函数后，调用子类构造函数之前，虚表是什么样子的？"><a href="#6-8-派生类的初始化过程中，调用完毕父类构造函数后，调用子类构造函数之前，虚表是什么样子的？" class="headerlink" title="6.8 派生类的初始化过程中，调用完毕父类构造函数后，调用子类构造函数之前，虚表是什么样子的？"></a>6.8 派生类的初始化过程中，调用完毕父类构造函数后，调用子类构造函数之前，虚表是什么样子的？</h2><p>这是一道面试的考题，来自<a target="_blank" rel="noopener" href="https://www.nowcoder.com/feed/main/detail/a2c2d116f80f4669a0487be447768f82">牛客网</a>。</p><blockquote><p>问：C++八股问派生类的实例化过程中,调用完基类的构造函数之后,调用派生类构造函数之前,虚函数指针是怎么样的？</p></blockquote><p>使用如下代码来做个调试测试吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="type">int</span> _b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base begin&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">func</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="type">int</span> _d = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derive</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive begin&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">func</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derive func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derive c;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始调试，执行构造函数之前，地址内都是随机值。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/53863e85d9816714fc95a8e78c308591.png" alt="image.png"></p><p>随后F11进入Derive类的构造函数，再F11会进入父类Base的构造函数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/27ce98cb137c1b544a03c826ee9274a8.png" alt="image.png"></p><p>再次F11，会开始执行Base的初始化列表构造，此时虚函数表已经被赋予地址了，从调试窗口可以看出来，这是父类的虚函数表。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/1e28df7a619a80966962c221af657a72.png" alt="image.png"></p><p>再次F11，执行Derive类的初始化列表<strong>之前</strong>，虚函数表依旧是父类的。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/145652dee98c4e56b9fe57672539ea5f.png" alt="image.png"></p><p>再次F11，开始执行Derive的初始化列表，此时虚表发生了变化，变成了子类的虚函数表了。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/7f3222098ef716a9f1c603cb94a8dcfc.png" alt="image.png"></p><p>所以这道题目的答案已经明了了：子类的构造函数初始化列表执行之前，虚函数表的指针是父类的虚函数指针。</p><h1 id="7-静态成员函数不能是虚函数"><a href="#7-静态成员函数不能是虚函数" class="headerlink" title="7.静态成员函数不能是虚函数"></a>7.静态成员函数不能是虚函数</h1><p>静态成员函数属于整个类，无法被指定对象重写。</p><p>而且静态成员函数没有this指针，可以直接用类名来调用，但这也决定了其无法访问到虚表，自然也无法实现多态。</p><p>所以静态成员函数是不能做虚函数的，在VS中这样写会直接报错</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/f7ccfaaa4435d47f10b66ecc753972da.png" alt="image-20230803120648439"></p><h1 id="8-构造函数不能是虚函数"><a href="#8-构造函数不能是虚函数" class="headerlink" title="8.构造函数不能是虚函数"></a>8.构造函数不能是虚函数</h1><p>通过调试可以发现，虚函数表中的指针原本是随机值，是在构造函数中被初始化为正确的函数地址的</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/e40f5382a931f5a71df7078ca56f3019.png" alt="image-20230803121101020"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/adbe527105998c605df5e627a49755b9.png" alt="image-20230803121105181"></p><p>既然是在构造函数中初始化的，那么虚函数表就<strong>不能先于构造函数被初始化出来</strong>，也就没有办法通过虚表来实现多态。</p><p>所以构造函数是不能为虚函数的！</p><h1 id="9-菱形继承构造顺序"><a href="#9-菱形继承构造顺序" class="headerlink" title="9.菱形继承构造顺序"></a>9.菱形继承构造顺序</h1><p>如下虚菱形继承中，调用构造函数的顺序是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> <span class="type">char</span>* s) &#123; cout &lt;&lt; s &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span>  <span class="type">char</span>* s2) :<span class="built_in">A</span>(s1) &#123; cout &lt;&lt; s2 &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span>  <span class="type">char</span>* s2) :<span class="built_in">A</span>(s1) &#123; cout &lt;&lt; s2 &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> :<span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">D</span>(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2, <span class="type">const</span>  <span class="type">char</span>* s3, <span class="type">const</span>  <span class="type">char</span>* s4) :<span class="built_in">B</span>(s1, s2), <span class="built_in">C</span>(s1, s3), <span class="built_in">A</span>(s1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D* p = <span class="keyword">new</span> <span class="built_in">D</span>(<span class="string">&quot;class A&quot;</span>, <span class="string">&quot;class B&quot;</span>, <span class="string">&quot;class C&quot;</span>, <span class="string">&quot;class D&quot;</span>);</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要知道，类的对象在实例化的时候，初始化的顺序就是类声明的顺序</p><p>依照代码中的顺序流程读下来，就是构造函数被初始化的顺序；</p><p>而且A的构造函数也是由最终子类D直接发起的，而不是B或者C发起的。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/1f3850ac51fd9c6e4f7f42f6b05b9553.png" alt="image-20230803121510612"></p><p>下面这道题也是一个有关于构造顺序和多态调用的问题</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/a85a3c674a416f6d7ed7c7ba70c38d8a.png" alt="QQ截图20220928225433"></p><p>在linux下测试，最终打印的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">barfoob_bar</span><br></pre></td></tr></table></figure><p>调用顺序为</p><ul><li>父类A的构造函数调用父类自己的bar函数，因为这时候虚表还没有初始化，所以不存在多态，打印<code>bar</code></li><li>父类指针指向子类，调用foo函数，由于foo函数不是虚函数，不在虚表内，所以调用的是父类的foo函数，打印<code>foo</code></li><li>父类指针调用bar函数，此函数为多态调用，调用的是子类的bar函数，打印<code>b_bar</code></li></ul><p>所以最终的输出结果是<code>barfoob_bar</code></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>内容丰富的继承和多态的博客终于补充完毕了！</p><p>如果有问题还请提出！</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/3933786088/">https://blog.musnow.top/posts/3933786088/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp</a></div><div class="post_share"><div class="social-share" data-image="https://img.musnow.top/i/2023/02/202205272034572.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4231483510/" title="【项目】视频点播项目的记录"><img class="cover" src="https://img.musnow.top/i/2023/08/64d4e21f1e5e7.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【项目】视频点播项目的记录</div></div></a></div><div class="next-post pull-right"><a href="/posts/971003431/" title="【MySQL】deepin安装mysql的cpp开发包"><img class="cover" src="https://img.musnow.top/i/2023/04/64302610057ae.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【MySQL】deepin安装mysql的cpp开发包</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/909882653/" title="【C++】函数重载的形式及其背后原理"><img class="cover" src="/img/bg/gm7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-29</div><div class="title">【C++】函数重载的形式及其背后原理</div></div></a></div><div><a href="/posts/3198614716/" title="【C语言】static和extern的作用"><img class="cover" src="/img/bg/gm8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-18</div><div class="title">【C语言】static和extern的作用</div></div></a></div><div><a href="/posts/1070210667/" title="【C++】凝视C++的第一眼"><img class="cover" src="/img/bg/gm13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-29</div><div class="title">【C++】凝视C++的第一眼</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">373</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E8%A3%85"><span class="toc-text">0.什么是封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F%E5%85%B3%E7%B3%BB"><span class="toc-text">1.继承派生关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">1.1 基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-text">1.2 权限问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%90%8C%E5%90%8D%E9%97%AE%E9%A2%98%EF%BC%88%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%89"><span class="toc-text">1.3 同名问题（作用域）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">1.4 静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%8F%8B%E5%85%83"><span class="toc-text">1.5 友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">1.6 默认成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">构造和析构顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">显示调用父类构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-text">1.7 基类和派生类赋值问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%88%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">1.8 虚继承（菱形继承问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%9E%8B"><span class="toc-text">继承模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-text">普通菱形继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%9E%8B"><span class="toc-text">虚继承模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E8%A1%A8"><span class="toc-text">虚基表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88"><span class="toc-text">1.9 继承和组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%A4%9A%E6%80%81"><span class="toc-text">2.多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">2.1 虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="toc-text">2.1.1 基本使用以及动态多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">2.1.2 虚析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E5%AD%90%E7%B1%BB%E4%B8%8D%E9%87%8D%E5%86%99"><span class="toc-text">2.1.3 子类不重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E5%8D%8F%E5%8F%98"><span class="toc-text">2.1.4 协变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E9%87%8D%E5%86%99%E4%B8%8D%E5%B8%A6virtual"><span class="toc-text">2.1.5 重写不带virtual</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%91%E4%BA%BA%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">坑人的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-C-11-override%E5%92%8Cfinal"><span class="toc-text">2.2 C++11 override和final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-final"><span class="toc-text">2.2.1 final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-override"><span class="toc-text">2.2.2 override</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89%E3%80%81%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">2.3 重载、覆盖（重写）、隐藏（重定义）的对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">3.抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">3.1 纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">3.2 抽象类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-text">4.几个重要概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-text">4.1 实现继承和接口继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">4.2 动态绑定和静态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88"><span class="toc-text">4.3 父类的构造和析构中虚函数不生效</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%8C%85%E5%90%AB%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">5.包含虚函数的类的大小</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%88%E8%99%9A%E8%A1%A8%EF%BC%89"><span class="toc-text">6.虚函数表（虚表）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB"><span class="toc-text">6.1 虚函数重写和覆盖的概念区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%B3%E8%AE%AE%E5%92%8C%E7%BC%96%E8%AF%91%E6%97%B6%E5%86%B3%E8%AE%AE"><span class="toc-text">6.1.1 运行时决议和编译时决议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E7%9C%8B%E7%9C%8B%E6%B1%87%E7%BC%96"><span class="toc-text">6.1.2 看看汇编</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E7%BB%99%E7%88%B6%E7%B1%BB%E4%B8%BA%E4%BD%95%E6%97%A0%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="toc-text">6.2 子类对象赋值给父类为何无法实现多态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%AD%90%E7%B1%BB%E4%B8%AD%E6%96%B0%E5%A2%9E%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BD%86%E7%9B%91%E8%A7%86%E7%AA%97%E4%B8%8D%E6%98%BE%E7%A4%BA"><span class="toc-text">6.3 子类中新增虚函数，但监视窗不显示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E5%AE%9E%E5%9C%B0%E6%8E%A2%E7%B4%A2"><span class="toc-text">6.3.1 实地探索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E7%9A%84%E8%99%9A%E8%A1%A8%EF%BC%9F"><span class="toc-text">6.3.2 为什么不新增一个子类的虚表？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E8%99%9A%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-text">6.4 虚表的存储位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E8%A1%A8"><span class="toc-text">6.5 多继承中的虚表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-Func1%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">6.5.1 Func1地址不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-%E6%8C%87%E9%92%88%E5%88%87%E7%89%87%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%90%8C"><span class="toc-text">6.5.2 指针切片地址不同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-text">6.6 菱形虚拟继承中的虚函数表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8Cinline"><span class="toc-text">6.7 虚函数和inline</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-1-%E7%8A%B6%E6%80%81%E8%A7%82%E5%AF%9F"><span class="toc-text">6.7.1 状态观察</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-2-%E7%BB%93%E8%AE%BA"><span class="toc-text">6.7.2 结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E8%B0%83%E7%94%A8%E5%AE%8C%E6%AF%95%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%8E%EF%BC%8C%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%9F"><span class="toc-text">6.8 派生类的初始化过程中，调用完毕父类构造函数后，调用子类构造函数之前，虚表是什么样子的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">7.静态成员函数不能是虚函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">8.构造函数不能是虚函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><span class="toc-text">9.菱形继承构造顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-end"><span class="toc-text">The end</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2052482894/" title="【win】如何在微软官网下载windows10的iso镜像">【win】如何在微软官网下载windows10的iso镜像</a><time datetime="2024-06-19T01:59:54.000Z" title="发表于 2024-06-19 09:59:54">2024-06-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3193784003/" title="【leetcode】115.不同的子序列">【leetcode】115.不同的子序列</a><time datetime="2024-06-12T08:48:17.000Z" title="发表于 2024-06-12 16:48:17">2024-06-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3529841087/" title="【leetcode】392.判断子序列">【leetcode】392.判断子序列</a><time datetime="2024-06-09T01:44:27.000Z" title="发表于 2024-06-09 09:44:27">2024-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3174951422/" title="【leetcode】买卖股票的最佳时机（汇总篇）">【leetcode】买卖股票的最佳时机（汇总篇）</a><time datetime="2024-06-07T11:39:46.000Z" title="发表于 2024-06-07 19:39:46">2024-06-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>