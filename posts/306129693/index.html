<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【C++】C++11中局部static变量的线程安全问题 | 转载 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++11中局部static变量的线程安全问题">
<meta property="og:type" content="article">
<meta property="og:title" content="【C++】C++11中局部static变量的线程安全问题 | 转载">
<meta property="og:url" content="https://blog.musnow.top/posts/306129693/index.html">
<meta property="og:site_name" content="慕雪的寒舍">
<meta property="og:description" content="C++11中局部static变量的线程安全问题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.musnow.top/img/bg/gm6.webp">
<meta property="article:published_time" content="2023-02-20T13:13:46.000Z">
<meta property="article:modified_time" content="2023-05-04T07:55:38.000Z">
<meta property="article:author" content="慕雪年华">
<meta property="article:tag" content="Cpp">
<meta property="article:tag" content="Cpp11">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm6.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【C++】C++11中局部static变量的线程安全问题 | 转载",
  "url": "https://blog.musnow.top/posts/306129693/",
  "image": "https://blog.musnow.top/img/bg/gm6.webp",
  "datePublished": "2023-02-20T13:13:46.000Z",
  "dateModified": "2023-05-04T07:55:38.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "慕雪年华",
      "url": "https://blog.musnow.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/306129693/index.html"><link rel="preconnect"/><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"/><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"/><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: '/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【C++】C++11中局部static变量的线程安全问题 | 转载',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/equipment/equipment.css?1"><link rel="stylesheet" href="/rating/rating.css?1"><script>!function(p){"use strict";!function(t){var s=window,e=document,i=p,c="".concat("https:"===e.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),n=e.createElement("script"),r=e.getElementsByTagName("script")[0];n.type="text/javascript",n.setAttribute("charset","UTF-8"),n.async=!0,n.src=c,n.id="LA_COLLECT",i.d=n;var o=function(){s.LA.ids.push(i)};s.LA?s.LA.ids&&o():(s.LA=p,s.LA.ids=[],o()),r.parentNode.insertBefore(n,r)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"});</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/main/mothra.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">443</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/rating/"><i class="fa-fw fas fa-film"></i><span> 书·影</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnow.blog.csdn.net/"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/bg/gm6.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/favicon.jpg" alt="Logo"><span class="site-name">慕雪的寒舍</span></a><a class="nav-page-title" href="/"><span class="site-name">【C++】C++11中局部static变量的线程安全问题 | 转载</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/rating/"><i class="fa-fw fas fa-film"></i><span> 书·影</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnow.blog.csdn.net/"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【C++】C++11中局部static变量的线程安全问题 | 转载</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-20T13:13:46.000Z" title="发表于 2023-02-20 21:13:46">2023-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-04T07:55:38.000Z" title="更新于 2023-05-04 15:55:38">2023-05-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Cpp/">Cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:180,&quot;messagePrev&quot;:&quot;距离上次更新本文已经过去了&quot;,&quot;messageNext&quot;:&quot;天，文章部分内容可能已经过时，请注意甄别。&quot;,&quot;postUpdate&quot;:&quot;2023-05-04 15:55:38&quot;}" hidden></div><p>C++11中局部static变量的线程安全问题</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都知道，在C++11标准中，要求局部静态变量初始化具有<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020">线程安全</a>性，所以我们可以很容易实现一个线程安全的单例类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Foo *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Foo s_instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;s_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在C++标准中，是这样描述的（在<a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">标准草案</a>的6.7节中）：</p>
<blockquote>
<p>such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization. If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>标准关于局部静态变量初始化，有这么几点要求：</p>
<ol>
<li>变量在代码第一次执行到变量声明的地方时初始化。</li>
<li>初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。</li>
<li>在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。</li>
<li>如果初始化过程中发生了对初始化的递归调用，则视为未定义行为。</li>
</ol>
<p>关于第4点，如果不明白，可以参考以下代码：</p>
<pre><code>class Bar
&#123;
public:
    static Bar *getInstance()
    &#123;
        static Bar s_instance;
        return &amp;s_instance;
    &#125;
private:
    Bar()
    &#123;
        getInstance();
    &#125;
&#125;;
</code></pre>
<h1 id="GCC的实现"><a href="#GCC的实现" class="headerlink" title="GCC的实现"></a>GCC的实现</h1><p>以GCC 7.3.0版本为例，我们来分析GCC是如何实现标准的。</p>
<h2 id="Foo-getInstance"><a href="#Foo-getInstance" class="headerlink" title="Foo::getInstance()"></a>Foo::getInstance()</h2><p>使用GCC编译后，我们使用gdb将文章开头的<code>Foo::getInstance()</code>反汇编：</p>
<pre><code>Dump of assembler code for function Foo::getInstance():
   0x00005555555546ea &lt;+0&gt;:     push   %rbp
   0x00005555555546eb &lt;+1&gt;:     mov    %rsp,%rbp
=&gt; 0x00005555555546ee &lt;+4&gt;:     movzbl 0x20092b(%rip),%eax        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;
   0x00005555555546f5 &lt;+11&gt;:    test   %al,%al
   0x00005555555546f7 &lt;+13&gt;:    sete   %al
   0x00005555555546fa &lt;+16&gt;:    test   %al,%al
   0x00005555555546fc &lt;+18&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;
   0x00005555555546fe &lt;+20&gt;:    lea    0x20091b(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;
   0x0000555555554705 &lt;+27&gt;:    callq  0x5555555545b0 &lt;__cxa_guard_acquire@plt&gt;
   0x000055555555470a &lt;+32&gt;:    test   %eax,%eax
   0x000055555555470c &lt;+34&gt;:    setne  %al
   0x000055555555470f &lt;+37&gt;:    test   %al,%al
   0x0000555555554711 &lt;+39&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;
   0x0000555555554713 &lt;+41&gt;:    lea    0x2008fe(%rip),%rdi        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;
   0x000055555555471a &lt;+48&gt;:    callq  0x555555554734 &lt;Foo::Foo()&gt;
   0x000055555555471f &lt;+53&gt;:    lea    0x2008fa(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;
   0x0000555555554726 &lt;+60&gt;:    callq  0x5555555545a0 &lt;__cxa_guard_release@plt&gt;
   0x000055555555472b &lt;+65&gt;:    lea    0x2008e6(%rip),%rax        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;
   0x0000555555554732 &lt;+72&gt;:    pop    %rbp
   0x0000555555554733 &lt;+73&gt;:    retq   
End of assembler dump.
</code></pre>
<p>在<code>+4</code>、<code>+20</code>、<code>+53</code>出现的<code>_ZGVZN3Foo11getInstanceEvE10s_instance</code>使用<code>c++filt</code>分析为<code>guard variable for Foo::getInstance()::s_instance</code>，而<code>+41</code>、<code>+65</code>位置出现的<code>_ZZN3Foo11getInstanceEvE10s_instance</code>则为<code>Foo::getInstance()::s_instance</code>。后者是<code>s_instance</code>这个局部静态变量，前者从名字看就知道是个<code>guard</code>标志变量，用来指示局部静态变量的初始化状态。</p>
<h4 id="4-18"><a href="#4-18" class="headerlink" title="+4 ~ +18"></a>+4 ~ +18</h4><p>测试<code>guard</code>变量的第一个字节，如果为<code>0</code>，代表<code>s_instance</code>未初始化，进入<code>+27</code>；否则代表<code>s_instance</code>已初始化，进入<code>+65</code>。</p>
<h4 id="20-～-27"><a href="#20-～-27" class="headerlink" title="+20 ～ +27"></a>+20 ～ +27</h4><p>以<code>guard</code>变量地址作为参数，执行<code>__cxa_guard_acquire</code>函数。</p>
<h4 id="32-～-39"><a href="#32-～-39" class="headerlink" title="+32 ～ +39"></a>+32 ～ +39</h4><p>测试返回值，如果为<code>0</code>，代表<code>s_instance</code>已初始化，进入<code>+65</code>；否则代表<code>s_instance</code>未初始化，进入<code>+41</code>。</p>
<h4 id="41-～-48"><a href="#41-～-48" class="headerlink" title="+41 ～ +48"></a>+41 ～ +48</h4><p>初始化<code>s_instance</code></p>
<h4 id="53-～-60"><a href="#53-～-60" class="headerlink" title="+53 ～ +60"></a>+53 ～ +60</h4><p>以<code>guard</code>变量地址作为参数，执行<code>__cxa_guard_release</code>函数。</p>
<h4 id="65-～-73"><a href="#65-～-73" class="headerlink" title="+65 ～ +73"></a>+65 ～ +73</h4><p>返回<code>s_instance</code>地址</p>
<h2 id="cxa-guard-acquire"><a href="#cxa-guard-acquire" class="headerlink" title="__cxa_guard_acquire"></a>__cxa_guard_acquire</h2><p>我们来看看<code>__cxa_guard_acquire</code>这个函数具体做了什么，该函数代码位于<code>gcc-7-7.3.0/gcc-7.3.0/libstdc++-v3/libsupc++/guard.cc</code>。由于这个函数针对不同平台做了不同的实现，有些我们不需要的代码，以我机器的设置，支持线程和futex系统调用，所以删除了一些不相关的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cxa_guard_acquire (__guard *g)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If the target can reorder loads, we need to insert a read memory</span></span><br><span class="line">    <span class="comment">// barrier so that accesses to the guarded variable happen after the</span></span><br><span class="line">    <span class="comment">// guard test.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (_GLIBCXX_GUARD_TEST_AND_ACQUIRE (g))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> guard_bit = _GLIBCXX_GUARD_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> pending_bit = _GLIBCXX_GUARD_PENDING_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">expected</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (__atomic_compare_exchange_n(gi, &amp;expected, pending_bit, <span class="literal">false</span>,</span><br><span class="line">                                            __ATOMIC_ACQ_REL,</span><br><span class="line">                                            __ATOMIC_ACQUIRE))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// This thread should do the initialization.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5</span></span><br><span class="line">            <span class="keyword">if</span> (expected == guard_bit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Already initialized.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">if</span> (expected == pending_bit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Use acquire here.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7</span></span><br><span class="line">                <span class="type">int</span> newv = expected | waiting_bit;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8</span></span><br><span class="line">                <span class="keyword">if</span> (!__atomic_compare_exchange_n(gi, &amp;expected, newv, <span class="literal">false</span>,</span><br><span class="line">                                                 __ATOMIC_ACQ_REL,</span><br><span class="line">                                                 __ATOMIC_ACQUIRE))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 9</span></span><br><span class="line">                    <span class="keyword">if</span> (expected == guard_bit)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Make a thread that failed to set the</span></span><br><span class="line">                        <span class="comment">// waiting bit exit the function earlier,</span></span><br><span class="line">                        <span class="comment">// if it detects that another thread has</span></span><br><span class="line">                        <span class="comment">// successfully finished initialising.</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 10</span></span><br><span class="line">                    <span class="keyword">if</span> (expected == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 11</span></span><br><span class="line">                expected = newv;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 12</span></span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAIT, expected, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acquire</span> (g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>首先检测<code>guard</code>变量，<code>guard</code>变量等于<code>1</code>的话，直接返回<code>0</code>，代表<code>s_instance</code>已初始化，不需要再次初始化。</li>
<li>检测是否为多线程环境，如果没有多线程的话，也就没有必要去做额外工作来保证线程安全了。</li>
<li><code>guard_bit</code>表示<code>s_instance</code>已经初始化成功；<code>pending_bit</code>表示<code>s_instance</code>正在初始化；<code>waiting_bit</code>表示有其他线程正在等待<code>s_instance</code>的初始化。</li>
<li>使用一个原子操作来检测<code>guard</code>变量是否为<code>0</code>，如果为<code>0</code>，则由当前线程初始化<code>s_instance</code>，把<code>pending_bit</code>写入guard变量，返回<code>1</code>。如果不为<code>0</code>，则将guard当前值写入<code>expected</code>。</li>
<li>检测<code>expected</code>值是否为<code>guard_bit</code>，如果是，则<code>s_instance</code>已初始化完成，不再需要初始化，返回<code>0</code>。</li>
<li>检测<code>expected</code>值是否为<code>pending_bit</code>，如果是，说明<code>s_instance</code>正在初始化，且没有其他线程等待初始化。</li>
<li>将<code>newv</code>变量设置为<code>pending_bit | waiting_bit</code>，表示<code>s_instance</code>正在初始化且有线程正在等待初始化。</li>
<li>使用一个原子操作来检测<code>guard</code>变量是否为<code>pending_bit</code>，如果不是，说明有其他线程修改了<code>guard</code>变量，需要做进一步检测；如果是，说明没有其他线程修改<code>guard</code>变量，则将<code>pending_bit | waiting_bit</code>写入<code>guard</code>变量。</li>
<li>如果<code>expected</code>等于<code>guard_bit</code>，说明<code>s_instance</code>被初始化成功，不需要再初始化，返回<code>0</code>。</li>
<li>如果<code>expected</code>等于<code>0</code>，说明<code>s_instance</code>初始化失败，回到<code>4</code>重新开始检测。</li>
<li>如果在<code>8</code>中没有其他线程修改过<code>guard</code>变量，将<code>expected</code>设置为<code>pending_bit | waiting_bit</code>，表示<code>s_instance</code>正在初始化且有线程（也就是当前线程）正在等待初始化。</li>
<li>如果在<code>6</code>处没有进入if分支，说明<code>expected</code>等于<code>pending_bit | waiting_bit</code>，如果进入了if分支，由<code>11</code>可得，此时<code>expected</code>也被修改为了<code>pending_bit | waiting_bit</code>。总之，此时<code>s_instance</code>正在初始化且有线程正在等待初始化。利用<code>futex</code>系统调用，再次检测<code>guard</code>变量是否发生了变化，如果发生了变化，回到<code>4</code>重新开始检测；如果没有发生变化，仍然等于<code>pending_bit | waiting_bit</code>，则挂起当前线程。</li>
</ol>
<p>总之，<code>__cxa_guard_acquire</code>要么返回<code>0</code>要么返回<code>1</code>，用来指示<code>s_instance</code>已初始化或未初始化。<code>__cxa_guard_acquire</code>可能会导致当前线程挂起，这发生在<code>s_instance</code>正在初始化的时候。</p>
<h2 id="cxa-guard-release"><a href="#cxa-guard-release" class="headerlink" title="__cxa_guard_release"></a>__cxa_guard_release</h2><p>由于<code>__cxa_guard_acquire</code>可能导致当前线程挂起，因此需要在<code>s_instance</code>初始化完成后使用将<code>__cxa_guard_release</code>线程唤醒。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_guard_release (__guard *g) <span class="keyword">throw</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> guard_bit = _GLIBCXX_GUARD_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="type">int</span> old = __atomic_exchange_n (gi, guard_bit, __ATOMIC_ACQ_REL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> ((old &amp; waiting_bit) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">0</span>);</span><br><span class="line">    _GLIBCXX_GUARD_SET_AND_RELEASE (g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>检测是否为多线程环境</li>
<li>使用原子操作将<code>guard</code>变量置为<code>guard_bit</code>，同时获取<code>guard</code>变量原始值。</li>
<li>如果<code>guard</code>变量原始值包含<code>waiting_bit</code>，说明有线程挂起（或将要调用<code>futex</code>欲使线程挂起），调用<code>futex</code>唤醒挂起的进程。</li>
</ol>
<h2 id="cxa-guard-abort"><a href="#cxa-guard-abort" class="headerlink" title="__cxa_guard_abort"></a>__cxa_guard_abort</h2><p>由于<code>s_instance</code>可能初始化失败（本例中并未体现），因此还有一个<code>__cxa_guard_abort</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_guard_abort (__guard *g) <span class="keyword">throw</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line">        <span class="type">int</span> old = __atomic_exchange_n (gi, <span class="number">0</span>, __ATOMIC_ACQ_REL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((old &amp; waiting_bit) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>与<code>__cxa_guard_release</code>基本一致，不同的地方在于会将<code>guard</code>变量置<code>0</code>。</p>
<h2 id="递归初始化调用"><a href="#递归初始化调用" class="headerlink" title="递归初始化调用"></a>递归初始化调用</h2><p>由于在C++11标准中，初始化如果发生了递归是未定义行为，所以GCC 7.3.0针对是否为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>环境做了不同的处理。如果是多线程环境，不进行额外处理，会发生死锁；如果是单线程环境，则会抛异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire() is a helper function used to acquire guard if thread support is</span></span><br><span class="line"><span class="comment">// not compiled in or is compiled in but not enabled at run-time.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">acquire</span><span class="params">(__guard *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Quit if the object is already initialized.</span></span><br><span class="line">    <span class="keyword">if</span> (_GLIBCXX_GUARD_TEST(g))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">init_in_progress_flag</span>(g))</span><br><span class="line">        <span class="built_in">throw_recursive_init_exception</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看到了GCC如此复杂的实现，我的个人感想是还是不要自己造轮子来保证单例类的线程安全了，想要做到和GCC一样的高效还是比较难的，利用C++11标准的带来的便利就挺好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文作者：imred</span><br><span class="line">原文链接：https://blog.csdn.net/imred/article/details/89069750</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp</a><a class="post-meta__tags" href="/tags/Cpp11/">Cpp11</a></div><div class="post-share"><div class="social-share" data-image="/img/bg/gm6.webp" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://ifdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.webp" alt="爱发电"/></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/2721043914/" title="【Curl】通过curl模拟referer获取到有防盗链的图片"><img class="cover" src="/img/bg/gm9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【Curl】通过curl模拟referer获取到有防盗链的图片</div></div><div class="info-2"><div class="info-item-1">本文所描述操作仅供学习curl命令，请勿用于盗刷他人图床等违规操作！🙅‍♀️   1.说明当我想把51la添加到我的导航站点，却发现它的icon图标有防盗链，禁止空referer访问的； 这点完全可以理解，为了防止他人盗刷本站的图片，通常我们都需要给图片地址加上防盗链。  其实51la提供了自己的icon，但这里提供的icon像素特别低，只有16*16，在我的导航站点上的显示就没有那么友好了   所以我才想把稍微清晰一点的icon图标下载下来 2.curl使用 参考 https://www.ruanyifeng.com/blog/2019/09/curl-reference.html  要避开这个403访问权限，需要做的就是给请求头给定一个referer字段，告诉51la的服务器，我是通过他自己的域名访问图标文件 1234curl \-H &#x27;Referer: https://v6.51.la/&#x27; \https://v6-static.51.la/v6-static/202302161047/favicon.ico \-o...</div></div></div></a><a class="pagination-related" href="/posts/1296728696/" title="【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo 'appstream' Cannot prepare internal mirrorlist | 转载"><img class="cover" src="/img/bg/gm32.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo 'appstream' Cannot prepare internal mirrorlist | 转载</div></div><div class="info-2"><div class="info-item-1">本站经常搬运一些其他博主文章，主要是为了持久化访问。避免日后他人删文or原文无法访问；所有搬运的文章都会写明原文地址，并且不会展示本站的copyright_info   下文所出现的场景，是我在linux上使用docker安装centos容器时出现的！  ✨在学习使用 docker 技术过程中，基于 centos 镜像自定义新的镜像，其中基础镜像 centos 需要提前安装好 vim 和 net-tools，然而在刚开始通过 yum -y install vim 安装 vim 时，便出现了错误提示信息： Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist  ✨上面的报错信息意思是，从仓库 ‘appstream’ 下载元数据失败：由于镜像列表中没有 URL，不能准备内部镜像列表。 问题分析 ✨第一种可能的情况便是网络连接问题。检查是否可以连接外部网络，可以使用 ping baidu.com...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/569709037/" title="【C++】异常处理"><img class="cover" src="/img/bg/gm8.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-03</div><div class="info-item-2">【C++】异常处理</div></div><div class="info-2"><div class="info-item-1">本篇博客让我们来认识一下C++中对于异常的处理机制   [TOC] 1.概念1.1 C语言对于异常的处理在之前我们遇到一些bug的时候，通常会用if判断或者assert断言等问题进行处理。但这种方式太过暴力，会直接中断程序的运行 另外一种办法是返回错误码，C语言的报错大多使用这种方式。不过这需要程序的用户自己去查对应的错误码表格，较为麻烦  1.2 C++异常所谓异常，便是程序运行过程中可能遇到的bug或者问题。程序可以有选择地抛出一个异常，告知用户程序运行出现了问题。 C++标准库中便使用了一个exception类来进行异常的处理，我们运行程序中遇到的一些报错，其实就是标准库里面抛出了对应的异常  其操作主要借助下面三个关键字  throw 在出现问题的地方抛出异常 try 监控后续代码中出现的异常，后续需要以catch作为结尾 catch 用于捕获异常，同一个try可以用多个不同类型的catch进行捕获  throw关键字可以抛出任意类型的异常 2.基本操作下面用除法函数，以除0的情况来做一个最简单的演式 12345678910111213141516171819int...</div></div></div></a><a class="pagination-related" href="/posts/2016080368/" title="【C++】C++11的那些新特性"><img class="cover" src="/img/bg/gm31.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="info-item-2">【C++】C++11的那些新特性</div></div><div class="info-2"><div class="info-item-1">本篇博客，让我们一起来看看C++11的那些新特性！    所使用的编译器：VS2019 本篇博客所有的测试源码都可以在我的GITEE仓库找到   [TOC] 1.前言C++11是C++的标准委员会在2011年更新的C++新特性。说白了就是一个升级包。和JAVA\PYTHON这种更新比较频繁的语言相比，C++更新的就没有那么顺风顺水了，而且每一次更新虽然修复了一些问题，但也带来了更多的“没太大必要”的更新  比如没啥用的array容器，和int arr[10]这种内置方式的区别主要在于越界检查  不过咱们这种小菜鸡，只有学习的权力，哪有啥资格评定C++标准呢？我听大佬说，现在最关注的C++更新便是网络库的上线了，不过那个貌似得等到C++23去了 话不多说，让我们来康康一些C++11的新功能吧！  2.列表&#123;&#125;初始化C++11更新了初始化方式，不管是什么类型的数据，我们都可以用花括号的方式进行初始化 123456789struct TestA&#123;    int _a;    int _b;&#125;;void TestInit()&#123;   ...</div></div></div></a><a class="pagination-related" href="/posts/281674790/" title="【C++】空间配置器"><img class="cover" src="/img/bg/gm25.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-18</div><div class="info-item-2">【C++】空间配置器</div></div><div class="info-2"><div class="info-item-1">空间配置器，听起来高大上，那它到底是什么东西呢？   1.什么是空间配置器？空间配置器是STL源码中实现的一个小灶，用来应对STL容器频繁申请小块内存空间的问题。他算是一个小型的内存池，以提升STL容器在空间申请方面的效率   2.了解空间配置器STL以128个字节为分界线，将空间配置器分为了一级和二级 2.1 一级一级空间配置器中，allocate/deallocate函数实际上就是对malloc/free做了一个简单的封装 123456789101112131415161718192021222324252627static void * allocate(size_t n)&#123;    void *result = malloc(n);    if (0 == result) result = oom_malloc(n);    return result;&#125;static void deallocate(void *p, size_t /* n */)&#123;   ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">慕雪年华</div><div class="author-info-description">爱折腾的代码初学者</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">443</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fa fa-home"></i></a><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍，近来可好？</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-text">分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GCC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">GCC的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Foo-getInstance"><span class="toc-text">Foo::getInstance()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-18"><span class="toc-text">+4 ~ +18</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%EF%BD%9E-27"><span class="toc-text">+20 ～ +27</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%EF%BD%9E-39"><span class="toc-text">+32 ～ +39</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-%EF%BD%9E-48"><span class="toc-text">+41 ～ +48</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53-%EF%BD%9E-60"><span class="toc-text">+53 ～ +60</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#65-%EF%BD%9E-73"><span class="toc-text">+65 ～ +73</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cxa-guard-acquire"><span class="toc-text">__cxa_guard_acquire</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cxa-guard-release"><span class="toc-text">__cxa_guard_release</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cxa-guard-abort"><span class="toc-text">__cxa_guard_abort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B0%83%E7%94%A8"><span class="toc-text">递归初始化调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/9085567599/" title="【Mac】拒绝parallels toolbox，从我做起！">【Mac】拒绝parallels toolbox，从我做起！</a><time datetime="2025-05-26T00:57:24.000Z" title="发表于 2025-05-26 08:57:24">2025-05-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7827607861/" title="【Hexo】将代码块中tab替换为空格（修改tab_replace）">【Hexo】将代码块中tab替换为空格（修改tab_replace）</a><time datetime="2025-05-16T02:00:57.000Z" title="发表于 2025-05-16 10:00:57">2025-05-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2725694758/" title="【MCP】了解远程MCP调用背后使用的SSE协议">【MCP】了解远程MCP调用背后使用的SSE协议</a><time datetime="2025-04-20T06:47:57.000Z" title="发表于 2025-04-20 14:47:57">2025-04-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2831928244/" title="【MCP】详细了解MCP协议：和function call的区别何在？如何使用MCP？">【MCP】详细了解MCP协议：和function call的区别何在？如何使用MCP？</a><time datetime="2025-04-19T00:56:01.000Z" title="发表于 2025-04-19 08:56:01">2025-04-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/main/mothra.webp);"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a></br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a></br><a href="https://travel.moe/go.html" target="_blank"><img src="/img/ico/moe-default-white.png" style="width:auto;height:25px" title="异次元之旅-跃迁-我们一起去萌站成员的星球旅行吧！"></a>&nbsp<a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = '/pluginsSrc/mathjax/es5/tex-mml-chtml.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('/pluginsSrc/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  let artalkItem = null
  const option = null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'

  const destroyArtalk = () => {
    if (artalkItem) {
      artalkItem.destroy()
      artalkItem = null
    }
  }

  const artalkChangeMode = theme => artalkItem && artalkItem.setDarkMode(theme === 'dark')

  const initArtalk = (el = document, pageKey = location.pathname) => {
    artalkItem = Artalk.init({
      el: el.querySelector('#artalk-wrap'),
      server: 'https://artk.musnow.top',
      site: 'mublog',
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      ...option,
      pageKey: isShuoshuo ? pageKey : (option && option.pageKey) || pageKey
    })

    if (GLOBAL_CONFIG.lightbox === 'null') return
    artalkItem.on('list-loaded', () => {
      artalkItem.ctx.get('list').getCommentNodes().forEach(comment => {
        const $content = comment.getRender().$content
        btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
      })
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyArtalk = () => {
        destroyArtalk()
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    btf.addGlobalFn('pjaxSendOnce', destroyArtalk, 'destroyArtalk')
    btf.addGlobalFn('themeChange', artalkChangeMode, 'artalk')
  }

  const loadArtalk = async (el, pageKey) => {
    if (typeof Artalk === 'object') initArtalk(el, pageKey)
    else {
      await btf.getCSS('/pluginsSrc/artalk/dist/Artalk.css')
      await btf.getScript('/pluginsSrc/artalk/dist/Artalk.js')
      initArtalk(el, pageKey)
    }
  }

  if (isShuoshuo) {
    'Artalk' === 'Artalk'
      ? window.shuoshuoComment = { loadComment: loadArtalk }
      : window.loadOtherComment = loadArtalk
    return
  }

  if ('Artalk' === 'Artalk' || !false) {
    if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
    else setTimeout(loadArtalk, 100)
  } else {
    window.loadOtherComment = loadArtalk
  }
})()</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>