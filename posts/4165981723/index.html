<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【C语言】带你用偷懒的方式刷爆二叉树OJ题 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文首发于2022-04-20，2024年重新刷题，对本文做了较大更新，所以重新发布。 前言上篇博客我带大家领略了一番链式二叉树的操作，现在让我们来看看二叉树的相关题目，一起来巩固一下知识点吧！ 点我复习上一篇博客的内容！👉 传送门；  1.一些选择题1.112345设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（ ）个A.11B.12C.13  √D.14   设N"><meta property="og:type" content="article"><meta property="og:title" content="【C语言】带你用偷懒的方式刷爆二叉树OJ题"><meta property="og:url" content="https://blog.musnow.top/posts/4165981723/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="本文首发于2022-04-20，2024年重新刷题，对本文做了较大更新，所以重新发布。 前言上篇博客我带大家领略了一番链式二叉树的操作，现在让我们来看看二叉树的相关题目，一起来巩固一下知识点吧！ 点我复习上一篇博客的内容！👉 传送门；  1.一些选择题1.112345设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（ ）个A.11B.12C.13  √D.14   设N"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm4.png"><meta property="article:published_time" content="2024-03-15T08:25:30.000Z"><meta property="article:modified_time" content="2024-04-16T04:33:24.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="C语言"><meta property="article:tag" content="数据结构"><meta property="article:tag" content="树"><meta property="article:tag" content="OJ刷题"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm4.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/4165981723/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【C语言】带你用偷懒的方式刷爆二叉树OJ题",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-04-16 12:33:24"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">360</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm4.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【C语言】带你用偷懒的方式刷爆二叉树OJ题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-15T08:25:30.000Z" title="发表于 2024-03-15 16:25:30">2024-03-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-16T04:33:24.000Z" title="更新于 2024-04-16 12:33:24">2024-04-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>84分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【C语言】带你用偷懒的方式刷爆二叉树OJ题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文首发于<code>2022-04-20</code>，2024年重新刷题，对本文做了较大更新，所以重新发布。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇博客我带大家领略了一番链式二叉树的操作，现在让我们来看看二叉树的相关题目，一起来巩固一下知识点吧！</p><p>点我复习上一篇博客的内容！👉 <a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/124212851?spm=1001.2014.3001.5501">传送门</a>；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161641683.gif" alt="QQ图片20220416140203"></p><h1 id="1-一些选择题"><a href="#1-一些选择题" class="headerlink" title="1.一些选择题"></a>1.一些选择题</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（ ）个</span><br><span class="line">A.11</span><br><span class="line">B.12</span><br><span class="line">C.13  √</span><br><span class="line">D.14</span><br></pre></td></tr></table></figure><blockquote><p>设Ni表示度为i的节点个数，则节点总数 N &#x3D; N0 + N1 + N2</p><p>节点个数于节点边的关系： <strong>N个节点的树有N-1个边</strong></p><p>边与度的关系：N - 1 &#x3D; N1 + 2 * N2</p><p>故：N0 + N1 + N2 - 1 &#x3D; N1 + 2 * N2</p><p>因此，得：N0 &#x3D; N2 + 1</p><p>回到原题，N0 &#x3D; 3，N1 &#x3D; 8，可得N2 &#x3D; 2</p><p>因此答案是 3 + 8 + 2 &#x3D; 13</p></blockquote><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有N个元素的完全二叉树的深度是()</span><br><span class="line">答案：logN+1</span><br></pre></td></tr></table></figure><p>高度为h的完全二叉树，节点个数在： <code>2^(h - 1) - 1 &lt; n &lt;= 2^h - 1</code></p><p>即<code>log(n + 1) &lt;= h &lt; log(n + 1) + 1</code></p><p>这里需要注意的是n左右区间的开闭问题</p><p>完全二叉树最少的节点个数是<code>2^(h - 1)-1+1</code>个，所以是<code>n&gt;2^(h - 1) - 1</code></p><hr><h2 id="1-3-由已知遍历序列画出原本树的结构"><a href="#1-3-由已知遍历序列画出原本树的结构" class="headerlink" title="1.3 由已知遍历序列画出原本树的结构"></a>1.3 由已知遍历序列画出原本树的结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的中序遍历序列为JGDHKBAELIMCF，后序遍历序列为JGKHDBLMIEFCA，则其前序遍历序列为（ ）</span><br><span class="line">A.ABDGHJKCEFILM</span><br><span class="line">B.ABDGJHKCEILMF   √</span><br><span class="line">C.ABDHKGJCEILMF</span><br><span class="line">D.ABDGJHKCEIMLF</span><br></pre></td></tr></table></figure><p>这道题我刚开始的思路是错的，因为我把它当作完全二叉树来看待，但题目并没有说它是完全二叉树</p><blockquote><p>主要思路：可以从后续遍历确定根节点为A，中序遍历可以确定A的左右子树。再继续从后序遍历中确定A左右子树的根节点，依次往下判断</p></blockquote><p>所以我画了一个分析图，如下👇</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161628643.jpg" alt="IMG_20220415_103954"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的前序遍历序列为ABDEC，中序遍历序列为BDEAC，则该二叉树（ ）</span><br><span class="line">A.是满二叉树</span><br><span class="line">B.是完全二叉树，不是满二叉树</span><br><span class="line">C.不是完全二叉树   √</span><br><span class="line">D.是所有的结点都没有右子树的二叉树</span><br></pre></td></tr></table></figure><p>这道题的思路和上一道题是一样的</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161631511.png" alt="image-20220416163152483"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的前序遍历序列为5 7 4 9 6 2 1，中序遍历序列为4 7 5 6 9 1 2，则其后序遍历序列为（ ）</span><br><span class="line">A.4 2 5 7 6 9 1</span><br><span class="line">B.4 2 7 5 6 9 1</span><br><span class="line">C.4 7 6 1 2 9 5  √</span><br><span class="line">D.4 7 2 9 5 6 1</span><br></pre></td></tr></table></figure><p>本题依旧和上面两道题思路相同！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161632859.jpg" alt="IMG_20220415_105012"></p><h2 id="1-4-单边树"><a href="#1-4-单边树" class="headerlink" title="1.4 单边树"></a>1.4 单边树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（ ）</span><br><span class="line">A.所有的结点均无左孩子</span><br><span class="line">B.所有的结点均无右孩子</span><br><span class="line">C.只有一个叶子结点</span><br><span class="line">D.至多只有一个结点</span><br></pre></td></tr></table></figure><p>如果前序遍历和后序遍历序列正好相反，说明它是一个单边树，比如下面这前序和中序序列所构成的树的结构:</p><p>12345（纵向）</p><p>54321</p><p>对于单边树，只有一个叶子节点</p><hr><h2 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20.如果一颗二叉树的前序遍历的结果是ABCD，则满足条件的不同的二叉树有（ ）种</span><br><span class="line"></span><br><span class="line">A.13</span><br><span class="line">B.14 √</span><br><span class="line">C.15</span><br><span class="line">D.16</span><br></pre></td></tr></table></figure><blockquote><p>首先这棵二叉树的高度一定在3~4层之间:</p><p>三层：</p><p>A(B(C,D),()), A((),B(C,D)), A(B(C,()),D), A(B((),C),D),</p><p>A(B,C(D,())), A(B,C((),D))</p><p>四层：</p><p>如果为四层，就是单边树，每一层只有一个节点，除过根节点，其他节点都有两种选择，在上层节点的左边还是右边，所以<code>2*2*2</code>共8种</p><p>总共为14种。</p></blockquote><hr><h1 id="2-OJ题刷起来！"><a href="#2-OJ题刷起来！" class="headerlink" title="2.OJ题刷起来！"></a>2.OJ题刷起来！</h1><h2 id="KY11-二叉树遍历"><a href="#KY11-二叉树遍历" class="headerlink" title="KY11 二叉树遍历"></a>KY11 二叉树遍历</h2><blockquote><p>牛客网 KY11 二叉树遍历 👉<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=60&&tqId=29483&rp=1&ru=/activity/oj&qru=/ta/tsing-kaoyan/question-ranking">传送门</a></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161645079.png" alt="image-20220416164513012"></p><p>这道题要求我们用先序遍历的操作从<strong>一个数组中读出一个树</strong>，并构建出树的基本结构，再用中序遍历的方式打印出这颗树</p><p>之前我们学习了前序遍历的操作，这里只需要把前序遍历中的printf操作改成构建新树即可</p><ul><li>因为涉及道i的多次调用，所以函数中的i需要取地址，必须保证多次调用的i会同步++</li><li>构建完树的节点，并赋值后，需要递归构建左右子树，最后返回节点的地址</li><li>题目中的#代表NULL，直接return空即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BTDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	BTDataType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树中序遍历 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTreeInOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	BTreeInOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">	BTreeInOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTNode* <span class="title function_">CreatTree</span><span class="params">(<span class="type">char</span> *arr,<span class="type">int</span>*i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[*i] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        (*i)++;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    BTNode* newnode=(BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">    </span><br><span class="line">    newnode-&gt;data=arr[(*i)++];<span class="comment">//i必须取地址</span></span><br><span class="line">    newnode-&gt;left=CreatTree(arr,i);<span class="comment">//递归构建左子树</span></span><br><span class="line">    newnode-&gt;right=CreatTree(arr,i);<span class="comment">//递归构建右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,arr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    BTNode* root=CreatTree(arr,&amp;i);</span><br><span class="line">    BTreeInOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100 相同的树"></a>100 相同的树</h2><blockquote><p>leetcode：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161652255.png" alt="image-20220416165211195"></p><p>题目要求很简单，给定两颗树的根节点，要求我们判断这两棵树是否相同</p><ul><li>如果两棵树都为空，树相同</li><li>如果其中一个为空，另外一个不为空，树不同</li><li>如果两个都不为空，但是节点值不相同，树不同</li><li>然后再递归判断左子树和右子树，将它们的结果与<code>&amp;&amp;</code>在一起，其中一个为假，返回假</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归判断左子树和右子树是否相等</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161706054.png" alt="image-20220416170618951"></p><p>这里顺便给出C++代码，基本一模一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 两棵树按相同的方式进行遍历，就能判断出来</span></span><br><span class="line">    <span class="type">bool</span> _isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="comment">// 两个都为空，相同</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有一个为空，不相同</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值不相同</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时递归判断左右子树</span></span><br><span class="line">        <span class="type">bool</span> left = _isSameTree(p-&gt;left, q-&gt;left);</span><br><span class="line">        <span class="type">bool</span> right = _isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right; <span class="comment">// 左右子树都相同才是同一棵树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123; <span class="keyword">return</span> _isSameTree(p, q); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>学会这道题后，后面一些题目其实只需要把它的代码改一改就能用了😂</p><p>什么？你不信？那就看看下面这道题！</p><hr><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h2><blockquote><p>leetcode：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161657137.png" alt="image-20220416165729067"></p><p>题目要求很简单哈，判断是不是两边对称的树。这和判断树相等有什么区别呢？不就是把左右子树的判断改一下就行了嘛？</p><ul><li>根节点的<strong>左子树的左侧</strong>和根节点的<strong>右子树的右侧</strong>相同，即为对称。</li></ul><p>直接调用上一题的代码！注意最后的return值，是<strong>p的左和q的右</strong>进行判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isSameTree(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归判断左子树和右子树是否对称相等</span></span><br><span class="line">    <span class="keyword">return</span> _isSameTree(p-&gt;left,q-&gt;right)</span><br><span class="line">        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _isSameTree(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161706197.png" alt="image-20220416170605085"></p><p>使用迭代法也能解决这道题目。迭代法的思路有点类似层序遍历，但是并不同！</p><ul><li>使用队列存放节点，将根节点的左子树和右子树入队列</li><li>开始循环</li><li>取出队列的两个节点（根节点的左子树和右子树），将左子树的左侧和右子树的右侧入队列，将左子树的右侧和右子树的左侧入队列；</li><li>此时队列中的四个数值就是依照对称需要判断的节点值来排列的，在下一层循环的时候，只需要判断取出队列的头部两个节点的值是否相等就行了。</li><li>当取出的两个节点有一个为空，或者都不为空但节点值不同时，即不符合对称的条件。</li><li>注意，两个节点都为空是符合条件的。</li></ul><p>C++代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里左右的顺序要和上面根节点插入左右的顺序一致</span></span><br><span class="line">            TreeNode* left = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* right = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 两个都是空，符合条件，跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有一个不为空，或者值不同，都是错误的</span></span><br><span class="line">            <span class="keyword">if</span>((left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) || (left-&gt;val != right-&gt;val))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对称插入队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="572-另外一棵树的子树"><a href="#572-另外一棵树的子树" class="headerlink" title="572 另外一棵树的子树"></a>572 另外一棵树的子树</h2><blockquote><p>leetcode：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161700348.png" alt="image-20220416170019257"></p><p>这道题我们要判断<strong>一颗树是否为另外一棵树的子树</strong>，和判断一个字符串是不是另外一个字符串的子串很相似</p><p>其实只需要递归判断每一个节点的左右子树是否和<code>subRoot</code>相同就可以了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isSameTree(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归判断左子树和右子树是否相等</span></span><br><span class="line">    <span class="keyword">return</span> _isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSubtree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* subRoot)</span>&#123;</span><br><span class="line">    <span class="comment">// if(root==NULL&amp;&amp;subRoot==NULL)</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// if(root!=NULL&amp;&amp;subRoot==NULL)</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// 让isSametree函数来比较这俩个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_isSameTree(root,subRoot))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要左右有一个是返回真，那就是子树</span></span><br><span class="line">    <span class="keyword">return</span> isSubtree(root-&gt;left,subRoot)</span><br><span class="line">        || isSubtree(root-&gt;right,subRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161705445.png" alt="image-20220416170549320"></p><p>是不是爽起来了？再来一道！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703532.png" alt="image-20220416170310498"></p><h2 id="102-层序遍历"><a href="#102-层序遍历" class="headerlink" title="102 层序遍历"></a>102 层序遍历</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p></blockquote><p>这道题在之前的博客中已经讲解过，为了方便后序写层序遍历的类型题目，将层序遍历最基本的代码贴在这里。</p><ul><li>根节点入队列</li><li>队列不为空，开始遍历；</li><li>记录当前队列长度（本层节点数量），出对头节点，将值插入数组，并将该节点的左右子树入队列；</li><li>一层节点遍历完毕后，将这一层的数组插入返回值二维数组中；</li><li>依照以上步骤，直到最后一层（队列为空）；</li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV); <span class="comment">// 一层结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="107-层序遍历Ⅱ"><a href="#107-层序遍历Ⅱ" class="headerlink" title="107 层序遍历Ⅱ"></a>107 层序遍历Ⅱ</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p></blockquote><p>这道题是上一道题的逆置，要求我们从最底层往上返回节点的数组。只需要将上题的返回数组逆置一下就OK了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV); <span class="comment">// 一层结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆置返回值数组即可</span></span><br><span class="line">        <span class="built_in">reverse</span>(retV.<span class="built_in">begin</span>(),retV.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/a317dc68b0b4f9b98f31859e359165b2.png" alt="image.png"></p><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199 二叉树的右视图"></a>199 二叉树的右视图</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">https://leetcode.cn/problems/binary-tree-right-side-view/description/</a></p></blockquote><p>题目要求我们假设自己是从右侧观察一颗二叉树，返回能从右侧观察到的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">  4   6</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>比如这棵树，从右侧可以观察到的节点是<code>[5,6,2]</code>，题目要求返回的就是这个节点组成的数组。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/b0c2e5474f671f282fac457fe734ef2c.png" alt="image.png"></p><p>思路还是层序遍历，这一次不需要把每个节点都入数组了，只需要遍历到<strong>每个层的末尾</strong>（循环到<code>size-1</code>的位置），将这个节点插入数组就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 每一层的末尾才插入数组</span></span><br><span class="line">                <span class="keyword">if</span>(i == size<span class="number">-1</span>)&#123;</span><br><span class="line">                    retV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/85b671427128bdd9adc04f79909a630b.png" alt="image.png"></p><h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637 二叉树的层平均值"></a>637 二叉树的层平均值</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/</a></p></blockquote><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10^(-5)</code> 以内的答案可以被接受。</p><p>这道题简单，把每一层的节点都加起来，然后除以节点数量求平均就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 求和</span></span><br><span class="line">                sum += front-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一层结束。计算平均</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(sum/<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(size*<span class="number">1.0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/67b4d7b9120a9184555c39f76908034f.png" alt="image.png"></p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226 翻转二叉树"></a>226 翻转二叉树</h2><blockquote><p>leetcode：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703706.png" alt="image-20220416170322647"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题的思路如下哈！</p><ul><li>如果是空树，不需要翻转，直接return；</li><li>如果非空，就把该节点的左右子树交换（这里不需要担心交换后找不到子树的问题，因为并没有把子树删除或者丢掉）</li><li>不需要单独判断空的子树，一并交换就可以；</li><li>当根节点为空的时候，return；</li></ul><h3 id="前序遍历实现"><a href="#前序遍历实现" class="headerlink" title="前序遍历实现"></a>前序遍历实现</h3><p>啪的一下很快哈，代码就写出来了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _invertTree(<span class="keyword">struct</span> TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//设置退出条件，如果根节点为空就返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让另外两个值来接收原本的左右节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>=</span>root-&gt;left;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>=</span>root-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更改左右节点</span></span><br><span class="line">    root-&gt;right=left;</span><br><span class="line">    root-&gt;left=right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归子树</span></span><br><span class="line">    _invertTree(root-&gt;left);</span><br><span class="line">    _invertTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//判断空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    _invertTree(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161705971.png" alt="image-20220416170530844"></p><p>使用迭代（循环）的方式进行前序遍历，也可以完成本题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	        <span class="keyword">return</span> root;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="comment">// 交换</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历实现"><a href="#层序遍历实现" class="headerlink" title="层序遍历实现"></a>层序遍历实现</h3><p>使用层序遍历，思路还是一样的，层序遍历在出队列头部节点的时候，会将左右子树插入队列。只需要在插入之前，将队列头部节点的左右子树指针交换位置，即可。</p><p>注意：不能通过交换左右子树入队列的顺序实现，这样虽然遍历下一层的顺序改变了，但是上一层的节点左右子树的指针并没有被交换，还是原来的顺序，不符合题目要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(front-&gt;left,front-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 虽然这里可以不用写不等于空，但是写上可读性更好。</span></span><br><span class="line">            <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="429-N叉树层序遍历"><a href="#429-N叉树层序遍历" class="headerlink" title="429 N叉树层序遍历"></a>429 N叉树层序遍历</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">https://leetcode.cn/problems/n-ary-tree-level-order-traversal/</a></p></blockquote><p>基于二叉树层序遍历的代码，修改一下就是多叉树了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size ; j++)&#123;</span><br><span class="line">                Node* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;temp-&gt;children.<span class="built_in">size</span>();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d5a314057186dc0fc8880444838d2381.png" alt="image.png"></p><h2 id="515-在每层中找最大值"><a href="#515-在每层中找最大值" class="headerlink" title="515 在每层中找最大值"></a>515 在每层中找最大值</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/</a></p></blockquote><p>还是层序遍历思路的题目，遍历一层的时候维护一个最大值就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> maxNum = INT32_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                maxNum = <span class="built_in">max</span>(maxNum,temp-&gt;val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(maxNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/42ebd64adefee9120536bd6968a50561.png" alt="image.png"></p><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116 填充每个节点的下一个右侧节点指针"></a>116 填充每个节点的下一个右侧节点指针</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/</a></p></blockquote><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><hr><p>还是层序遍历的思路，遍历每一层的时候，将<strong>前一个节点的right</strong>设置为当前节点。</p><p>因为题目提到了node节点的next指针<strong>初始化都为nullptr</strong>，所以不需要我们手动操作每层最后一个节点的nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            Node* prevNode = <span class="literal">nullptr</span>;</span><br><span class="line">            Node* node = <span class="literal">nullptr</span>; <span class="comment">// 始终指向当前节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每层第一个节点，设置前一个节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    prevNode = que.<span class="built_in">front</span>(); <span class="comment">// 前一个节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = prevNode; <span class="comment">// 当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 非第一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>(); <span class="comment">// 当前节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    prevNode-&gt;next = node;</span><br><span class="line">                    prevNode = prevNode-&gt;next; <span class="comment">// 更新前一个节点为当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入后续节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9316e276ec127d1e7ee096367a4c6e51.png" alt="image.png"></p><h2 id="117-填充每个节点的下一个右侧节点指针Ⅱ"><a href="#117-填充每个节点的下一个右侧节点指针Ⅱ" class="headerlink" title="117 填充每个节点的下一个右侧节点指针Ⅱ"></a>117 填充每个节点的下一个右侧节点指针Ⅱ</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/</a></p></blockquote><p>上题说的是完全二叉树，这道题是普通二叉树。不过我们写的层序遍历代码本来就是通用的，所以直接复制代码过来就行了，什么都不需要改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            Node* prevNode = <span class="literal">nullptr</span>;</span><br><span class="line">            Node* node = <span class="literal">nullptr</span>; <span class="comment">// 始终指向当前节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每层第一个节点，设置前一个节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    prevNode = que.<span class="built_in">front</span>(); <span class="comment">// 前一个节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = prevNode; <span class="comment">// 当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 非第一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>(); <span class="comment">// 当前节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    prevNode-&gt;next = node;</span><br><span class="line">                    prevNode = prevNode-&gt;next; <span class="comment">// 更新前一个节点为当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入后续节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/0ea9cb0afb401d955754c2f85a50c9f1.png" alt="image.png"></p><h2 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104 二叉树最大深度"></a>104 二叉树最大深度</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/</a></p></blockquote><p>这道题在链式二叉树的博客中讲解过递归版本。注意二叉树深度的定义：二叉树的 <strong>最大深度</strong> 是指从根节点到最远<strong>叶子节点</strong>的<strong>最长路径</strong>上的节点数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树深度，即一共有几层</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BTreeDepth</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归遍历左右子树</span></span><br><span class="line">	<span class="type">int</span> left = <span class="built_in">BTreeDepth</span>(root-&gt;left);</span><br><span class="line">	<span class="type">int</span> right = <span class="built_in">BTreeDepth</span>(root-&gt;right);</span><br><span class="line">	<span class="comment">// 返回左右子树层数高的那一个，加一代表当前层，因为空指针是0</span></span><br><span class="line">	<span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用层序遍历也能解决这个问题，遍历到每一层都让深度计数器加一就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            retDepth++; <span class="comment">// 层数加一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9db4df1d7c69a02f1e809f2fac733fb8.png" alt="image.png"></p><p>下面是代码随想录上的递归思路。使用“回溯”的思想，将每一层的depth送给下一层，然后在每一层开始的时候判断当前深度是否大于存放的深度，并进行更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getdepth</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getdepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="114-二叉树的最小深度"><a href="#114-二叉树的最小深度" class="headerlink" title="114 二叉树的最小深度"></a>114 二叉树的最小深度</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/</a></p></blockquote><p>二叉树的最小深度：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>以下面的二叉树为例，它的最小深度是从1到节点3，因为3才是第一个叶子节点，而1并不是叶子节点（没有左右子树的节点才是叶子节点）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">   2</span><br><span class="line">  3  4</span><br><span class="line">	   5</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            retDepth++; <span class="comment">// 层数加一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遇到叶子节点，说明就是最小深度，直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left == <span class="literal">nullptr</span> &amp;&amp; temp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> retDepth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/fdeee76497ce1ee5fce7622e2d5c839b.png" alt="image.png"></p><p>如果使用递归的方式，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);           <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);         <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时是叶子节点，返回当前的最小高度（即深度）</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点数量"><a href="#222-完全二叉树的节点数量" class="headerlink" title="222 完全二叉树的节点数量"></a>222 完全二叉树的节点数量</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">https://leetcode.cn/problems/count-complete-tree-nodes/description/</a></p></blockquote><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1 ~ (2^h)</code> 个节点。</p><hr><p>先按普通二叉树来计算节点的数量，使用层序遍历的思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                count++; </span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用递归遍历也能计算节点数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _countNodes(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = _countNodes(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = _countNodes(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + left + right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _countNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/23e323a933739d577ae14b06b12ebb8a.png" alt="image-20240316092433289"></p><hr><p>但是上面这两个思路都是对任何二叉树都适用的，但本题直接说明了是<strong>完全二叉树</strong>。如果用通用的思路来解题，在面试的时候可能会扣分。我们需要用上完全二叉树的特性。</p><p>首先要知道<strong>满二叉树</strong>的节点数量为<code>2^k - 1</code>，k是二叉树的层数。在完全二叉树中，会有多个满二叉树。所以可以将思路转变为，正常计算非满二叉树的节点数量，但如果是满二叉树，获取层数后直接用公式计算节点数量，再二者相加。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9949b47e3423bf14897b688add450847.png" alt="image-20240316093135112"></p><p>计算满二叉树的层数比较简单，只需要从根节点往左侧、往右侧遍历，计算两侧的节点数量。最后对比左侧右侧节点数量，不同则不是满二叉树。</p><blockquote><p>因为题目已经说明了这棵树是<strong>完全二叉树</strong>，所以<strong>不会出现</strong>下面这种两侧节点数量一致，但中间缺少节点不符合完全二叉树&#x2F;满二叉树条件的情况。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/449114798f3824b2d21fe98eae39ea67.png" alt="image-20240316093752286"></p></blockquote><p>C++代码如下，来自代码随想录。这里层数被初始化为0，这样在后续使用<code>(2 &lt;&lt; leftDepth)</code>的时候，其实就相当于计算2的<code>leftDepth+1</code>次方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span></span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>; <span class="comment">// 这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;  <span class="comment">// 求左子树深度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123; <span class="comment">// 求右子树深度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>; <span class="comment">// 注意(2&lt;&lt;1) 相当于2^2，返回满足满二叉树的子树节点数量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="type">int</span> leftTreeNum = <span class="built_in">countNodes</span>(root-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightTreeNum = <span class="built_in">countNodes</span>(root-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> result = leftTreeNum + rightTreeNum + <span class="number">1</span>;    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p></blockquote><p>这里涉及到高阶数据结构中平衡二叉树的概念，如果你没有了解过，可以移步<a href="https://blog.musnow.top/posts/1396203902">这篇博客</a>；</p><p>简而言之，<strong>平衡二叉树是节点的左右子树高度相差不超过1的树</strong>。这样能保证树的左右两侧节点层数基本一致，方便实现搜索二叉树。</p><p>对于本题而言，我们可以将思路改为计算每个节点左右两侧的树的高度。当高度相差超过1的时候，直接返回错误。这里可以用int来作为递归函数的返回值，用<code>-1</code>代表不符合平衡二叉树的条件。</p><p>题目给出树的节点数量 <code>[0, 5000]</code> ，最大的层数也就5000，用int是足够存放的。</p><p>C++代码如下，使用后序遍历的思想来递归处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _isBalanced(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用后续遍历，如果有一个不符合预期就提前返回</span></span><br><span class="line">        <span class="type">int</span> left = _isBalanced(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> right = _isBalanced(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都不是负一，计算节点高度插值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(right -left)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 超过1了不符合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(right,left); <span class="comment">// 返回高的那一个作为当前树的高度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _isBalanced(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f2d8a5287cd80e7f2aa5099de585d651.png" alt="image-20240316095740190"></p><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257 二叉树的所有路径"></a>257 二叉树的所有路径</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p></blockquote><p>思路是使用前序遍历，将当前节点的值转为字符串插入到数组中，并插入一个<code>-&gt;</code>字符串；递归的末尾条件分两个</p><ul><li>叶子节点，将当前节点的值插入，不需要额外插入<code>-&gt;</code>字符串；</li><li>空节点，直接返回</li></ul><p>递归函数的传参如下，其中string变量不能传引用，因为这样的话，下一层的修改就会影响上层，上层还需要做删除下一层的元素的操作，很麻烦。<code>vector&lt;string&gt;&amp; retV</code>变量需要传引用，因为它包含了所有路径字符串，作为返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root,string curStr,vector&lt;string&gt;&amp; retV)</span></span></span><br></pre></td></tr></table></figure><hr><p>下面的代码中有一个错误的思路，如果遇到空节点就将字符串插入到数组，对于有一个子树的非叶子节点（此时它的左侧或者右侧是空的），就会多插入一个无效的路径，因为此时这个节点并非叶子节点。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/25aa7223e84bc8baeb4dc74da7e3b5ca.png" alt="image-20240316101831139"></p><p>正确的处理办法是到叶子节点了再插入数组，遇到空节点直接返回，不需要做任何处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串不能传引用，不然下层的更改会影响上层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root,string curStr,vector&lt;string&gt;&amp; retV)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// // 到空节点了就插入到数组中</span></span><br><span class="line">        <span class="comment">// if(root == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     // 删除多余的-&gt;</span></span><br><span class="line">        <span class="comment">//     retV.push_back(curStr.substr(0,curStr.size()-2));</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的思路错误，如果某个节点有左子树或右子树，此时就会多插入一个无效的路径</span></span><br><span class="line">        <span class="comment">// 正确思路是空节点不处理</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到叶子节点了就直接插入到数组中</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            curStr +=  <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curStr); <span class="comment">// 不需要删除多余的-&gt;</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curStr += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        curStr += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root-&gt;left,curStr,retV);</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root-&gt;right,curStr,retV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root,<span class="string">&quot;&quot;</span>,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f1c77d652f76b84075ebb60c656bc98c.png" alt="image-20240316102109684"></p><p>也可以使用迭代法，就是利用<strong>前序遍历的迭代思路</strong>将代码从递归改成迭代。</p><p>这里需要用到第二个栈，一个栈用来存放遍历的节点，另外一个栈用来存放当前遍历到的节点的上一层的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stNode; <span class="comment">// 存放节点</span></span><br><span class="line">        stack&lt;string&gt; stStr; <span class="comment">// 存放上一层的字符串</span></span><br><span class="line">        stNode.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">// stStr.push(to_string(root-&gt;val));</span></span><br><span class="line">        stStr.<span class="built_in">push</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 这里一定要插入空字符串而不是根节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stNode.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前序遍历</span></span><br><span class="line">            TreeNode* curNode = stNode.<span class="built_in">top</span>(); <span class="comment">// 中</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; curNode-&gt;val &lt;&lt; endl;</span></span><br><span class="line">            stNode.<span class="built_in">pop</span>();</span><br><span class="line">            string curStr = stStr.<span class="built_in">top</span>();</span><br><span class="line">            stStr.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 遇到叶子节点，插入值然后返回</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">// curStr += &quot;-&gt;&quot;;</span></span><br><span class="line">                curStr += <span class="built_in">to_string</span>(curNode-&gt;val);</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curStr);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                stStr.<span class="built_in">push</span>(curStr  + <span class="built_in">to_string</span>(curNode-&gt;val)+ <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                stStr.<span class="built_in">push</span>(curStr  + <span class="built_in">to_string</span>(curNode-&gt;val)+ <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/00bec4e34eef1c6765743903454e323b.png" alt="image-20240316104632107"></p><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404 左叶子之和"></a>404 左叶子之和</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/description/">https://leetcode.cn/problems/sum-of-left-leaves/description/</a></p></blockquote><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p>这道题我本来的思路是使用层序遍历，除去根节点外，<strong>每一层的第一个就是左叶子的可能节点</strong>。注意是可能，还需要判断这个节点到底是不是叶子节点。如果是就将其加入sum中。</p><p>但是这个思路是<strong>错的</strong>，因为每一层不一定有左侧叶子节点，第一个节点可能是右子树，不符合题目条件。</p><p>正确的办法是用递归，顺序算是中序遍历，当遇到叶子节点和空节点的时候，返回0，当遇到当前节点的左侧节点是叶子节点的时候，返回这个节点的值。</p><p>因为左侧节点不能通过当前节点来判断出来，必须要用父亲节点才能判断，所以“中序”就是在通过父亲节点判断左侧节点是不是叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _sumOfLeftLeaves(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根节点为空，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点，跳过（因为左侧叶子节点不存在，值视作为0）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左侧</span></span><br><span class="line">        <span class="type">int</span> left = _sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        <span class="comment">// 判断左侧是否为叶子节点，如果是需要进行修正（上一行的递归会跳过叶子节点的情况）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = root-&gt;left-&gt;val; <span class="comment">// 左侧叶子节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        <span class="type">int</span> right = _sumOfLeftLeaves(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right + left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _sumOfLeftLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4b6bc8846a4683698401c3b0057e5c91.png" alt="image-20240316111425986"></p><p>你也可以把代码按下面的方式写，会更好理解一些。当判断出当前左子树是叶子节点，就直接赋值，不是叶子节点才去遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _sumOfLeftLeaves(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根节点为空，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点，跳过（因为左侧叶子节点不存在，值视作为0）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断左侧是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = root-&gt;left-&gt;val; <span class="comment">// 左侧叶子节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = _sumOfLeftLeaves(root-&gt;left);<span class="comment">// 遍历左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        <span class="type">int</span> right = _sumOfLeftLeaves(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right + left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _sumOfLeftLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4ae5fbd2fe03e19ee457f91c4716c20d.png" alt="image-20240316111635285"></p><p>使用迭代也是借用遍历的思路，都是在父节点判断左子树是否为叶子节点。下面的代码来自代码随想录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                result += node-&gt;left-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513 找树左下角的值"></a>513 找树左下角的值</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p></blockquote><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><hr><p>这道题用上题层序遍历的思路才是对的，利用层序遍历走到最底层，将这一层最左侧的节点返回。但是这里会涉及到一个问题，<strong>我们怎么知道自己走到最后一层了呢</strong>？</p><p>实际上，并不需要去特殊判断，只需要将层序遍历每一层的第一个节点的值设置为返回值，这样层序遍历结束后，最后被设置的值就是题目需要求的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    ret = front-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6f7b9f6babc8fcbb50d64eb37a926fd0.png" alt="image-20240317161855120"></p><p>递归法使用前序遍历的思想，使用一个变量来记录当前深度，另外一个变量记录最深处左侧节点的值。这里的代码和上文<code>104二叉树的最大深度</code>题目中的思路相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = <span class="number">-1</span>; <span class="comment">// 最大深度</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 左侧节点值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMaxDepthLeftNode</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth &gt; maxDepth)&#123;</span><br><span class="line">                maxDepth = <span class="built_in">max</span>(maxDepth,depth);</span><br><span class="line">                result = root-&gt;val; <span class="comment">// 存放叶子节点的值</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左侧不为空，往左侧递归</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">getMaxDepthLeftNode</span>(root-&gt;left,depth+<span class="number">1</span>); <span class="comment">// 这里深度加一就相当于加上当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往右侧递归</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">getMaxDepthLeftNode</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getMaxDepthLeftNode</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f23bdbc09fdab06e7b0f7542aebeb9a5.png" alt="image-20240317162934828"></p><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/description/">https://leetcode.cn/problems/path-sum/description/</a></p></blockquote><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9924f255828e9bf5d223554c29c23c31.png" alt="image-20240317163532398"></p><p>这道题和<code>257 二叉树的所有路径</code>有些类似，不过那道题是需要将路径写入数组，这道题是需要判断有没有路径中节点值的和为指定数的情况。</p><p>递归函数中，传入目标值targetSum，当前值curSum（这里的当前值也是用了“回溯”的思想），为了避免错误修改目标值targetSum，将其设置为const变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">frontTravelTree</span><span class="params">(TreeNode* root,<span class="type">const</span> <span class="type">int</span> targetSum, <span class="type">int</span> curSum)</span></span></span><br></pre></td></tr></table></figure><p>递归的思路如下</p><ul><li>如果当前节点为空，直接返回false，不需要处理</li><li>如果当前节点非空，将当前节点的值加入curSum；</li><li>如果当前节点是叶子节点，判断当前的curSum是否等于targetSum，等于返回true；</li><li>往左侧和右侧递归，返回这两个递归结果的<strong>或</strong>；</li></ul><p>注意，判断targetSum的时候一定要判断是不是叶子节点，我刚开始写的时候就忘记判断了，因为路径可能还没到叶子节点就已经等于targetSum了，但是这种情况不符合题目条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">frontTravelTree</span><span class="params">(TreeNode* root,<span class="type">const</span> <span class="type">int</span> targetSum, <span class="type">int</span> curSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        <span class="comment">// 当前已经相等，且是叶子节点，返回</span></span><br><span class="line">        <span class="keyword">if</span>(targetSum == curSum &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">frontTravelTree</span>(root-&gt;left,targetSum,curSum);</span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">frontTravelTree</span>(root-&gt;right,targetSum,curSum);</span><br><span class="line">        <span class="keyword">return</span> retLeft || retRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">frontTravelTree</span>(root,targetSum,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/15e968da70f14f4a995298e2cef928e4.png" alt="image-20240317163820934"></p><p>使用迭代，也是用前序遍历的思路，用栈来实现。这里的思路和<code>257 二叉树的所有路径</code>中也是一样的，需要用到两个栈，一个用来遍历节点，另外一个保存上一层遍历到的节点curSum。</p><p>注意，因为是前序遍历，且每一次都会让curSum加上当前节点的值，所以stSum这个栈在初始化的时候一定要插入0，而不是根节点的值（不然会二次加根节点的值，会出错）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; stNode; <span class="comment">// 遍历节点</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stSum; <span class="comment">// 上一层遍历的求和结果</span></span><br><span class="line">        </span><br><span class="line">        stNode.<span class="built_in">push</span>(root);</span><br><span class="line">        stSum.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">// 这里一定要插入0而不是根节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stNode.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* curNode = stNode.<span class="built_in">top</span>();</span><br><span class="line">            stNode.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> curSum = stSum.<span class="built_in">top</span>();</span><br><span class="line">            stSum.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            curSum += curNode-&gt;val;</span><br><span class="line">            <span class="comment">// 如果是叶子节点，判断是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right == <span class="literal">nullptr</span> &amp;&amp; curSum == targetSum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续向下</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                stSum.<span class="built_in">push</span>(curSum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                stSum.<span class="built_in">push</span>(curSum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c2f0411797bfce72243ae97448cbd33b.png" alt="image-20240317165115333"></p><h2 id="113-路径总和Ⅱ"><a href="#113-路径总和Ⅱ" class="headerlink" title="113 路径总和Ⅱ"></a>113 路径总和Ⅱ</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></p></blockquote><p>上一题是让我们判断是否存在某一条路径，这题是需要返回所有符合条件的路径。</p><p>思路是使用前序遍历，用一个curSum记录当前遍历到的和，将当前值加入到这个和中并将当前值插入curV数组；</p><p>如果<strong>是叶子节点</strong>，则与targetSum对比，符合条件则将curV数组插入到返回值数组retV中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _pathSum(TreeNode* root, <span class="type">const</span> <span class="type">int</span> targetSum,<span class="type">int</span> curSum, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV,vector&lt;<span class="type">int</span>&gt; curV) &#123;</span><br><span class="line">        <span class="comment">// 空节点跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        curV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">// 叶子节点，且值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; curSum == targetSum)&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右递归</span></span><br><span class="line">        _pathSum(root-&gt;left,targetSum,curSum,retV,curV);</span><br><span class="line">        _pathSum(root-&gt;right,targetSum,curSum,retV,curV);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _pathSum(root,targetSum,<span class="number">0</span>,retV,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d1bbdfc5f2846feb568ce10501ef2400.png" alt="image-20240318103424964"></p><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106 从中序与后序遍历序列构造二叉树"></a>106 从中序与后序遍历序列构造二叉树</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106 从中序与后序遍历序列构造二叉树</a></p></blockquote><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/cd173d709ec7bad3687083e5340a185e.png" alt="image-20240317171026511"></p><p>首先，要通过中序和后序遍历的概念知道如何从这两个数组中构造一棵树来。</p><ul><li>后序的最后一个节点是根节点</li><li>确定根节点后，中序遍历中根节点左侧的是左子树，右侧的是右子树；</li><li>继续依照这个概念拆分后序遍历的数组，找到左右子树的根节点…</li></ul><p>对于代码而言，重点就是将左右子树从中序和后序的数组中拆分开来，直到拆分到空节点。</p><ol><li>数组大小为空，说明是空节点</li><li>数组大小不为空，从后序遍历中取出最后一个值作为根节点的值；</li><li>从中序遍历的数组中找到根节点所在位置，作为拆分的中位线；</li><li>将中序遍历的数组依照根节点所在位置拆分成左子数组和右子数组；</li><li>切割后序遍历的数组，依照左侧数组和右侧数组的长度和中序遍历拆分后的长度一致来处理（如果中序拆出来的左子树数组有3个元素，那么后序遍历中左子树的数组就是从前往后数的前3个元素）；</li><li>递归处理左侧和右侧的子树；</li></ol><p>代码如下，主要需要注意的是拆分中序和后序数组时候迭代器的位置，这里的下标拆分范围如果搞不清楚可以打印出来多试试，记住思路是最重要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder) &#123;</span><br><span class="line">        <span class="comment">// 递归分治条件</span></span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">        <span class="type">int</span> val = postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找到这个值，注意题目保证节点值不重复，所以能这么做。</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提前定义，后面要用</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆中序数组，使用[0,i)区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderLeft</span><span class="params">(inorder.begin(),inorder.begin()+i)</span></span>;</span><br><span class="line">        <span class="comment">// 下面这里是[i+1,end)区间，必须额外加一，否则不符合条件</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderRight</span><span class="params">(inorder.begin()+i+<span class="number">1</span>,inorder.end())</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆后续数组，因为后续数组的大小肯定和中序一致，从前往后拆就分别对应中序的左数组和右数组了</span></span><br><span class="line">        <span class="comment">// 将后续遍历数组中的的最后一个值删掉，因为当前已经使用了</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>()<span class="number">-1</span>); </span><br><span class="line">        <span class="comment">// 这里inorderLeft.size()理论上和i是相同的，所以用i也没问题</span></span><br><span class="line">        <span class="comment">// [0,inorderLeft.size())</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderLeft</span><span class="params">(postorder.begin(),postorder.begin()+inorderLeft.size())</span></span>;</span><br><span class="line">        <span class="comment">// [inorderLeft.size(),end())</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderRight</span><span class="params">(postorder.begin()+inorderLeft.size(),postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(inorderLeft,postorderLeft);</span><br><span class="line">        TreeNode* right = _buildTree(inorderRight,postorderRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/77678c2d171a81344112bf3d3f177ef2.png" alt="image-20240317173609279"></p><p>当然，上面的代码性能并不好，因为会有额外的空间复杂度消耗（每次递归都需要构建4个vector数组），我们可以将构建数组的操作改成用下标来标定区间。</p><p>代码如下，同样需要注意下标的区间，详见注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder,<span class="type">int</span> inorderBegin,<span class="type">int</span> inorderEnd,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span> postorderBegin,<span class="type">int</span> postorderEnd) &#123;        </span><br><span class="line">        <span class="keyword">if</span>(inorderBegin&gt;=inorderEnd || postorderBegin &gt;= postorderEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">        <span class="comment">// int val = postorder[postorder.size()-1];</span></span><br><span class="line">        <span class="type">int</span> val = postorder[postorderEnd<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找到这个值，注意题目保证节点值不重复，所以能这么做。</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提前定义，后面要用</span></span><br><span class="line">        <span class="comment">// for(i = 0;i&lt;inorder.size();i++)</span></span><br><span class="line">        <span class="keyword">for</span>(i = inorderBegin;i&lt;inorderEnd;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆中序数组，使用[0,i)区间</span></span><br><span class="line">        <span class="type">int</span> inorderBeginLeft = inorderBegin;</span><br><span class="line">        <span class="type">int</span> inorderEndLeft = inorderBegin+(i-inorderBegin); <span class="comment">// 如果直接加i是错误的，i已经是下标了，再加会超出范围</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这里是[i+1,end)区间，必须额外加一，否则不符合条件</span></span><br><span class="line">        <span class="type">int</span> inorderBeginRight = inorderBegin+(i-inorderBegin)+<span class="number">1</span>; <span class="comment">// 这里需要加一，是跳过被选中的中间节点</span></span><br><span class="line">        <span class="type">int</span> inorderEndRight = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆后续数组，因为后续数组的大小肯定和中序一致，从前往后拆就分别对应中序的左数组和右数组了</span></span><br><span class="line">        <span class="comment">// [0,inorderLeft.size())</span></span><br><span class="line">        <span class="type">int</span> postorderBeginLeft = postorderBegin;</span><br><span class="line">        <span class="type">int</span> postorderEndLeft = postorderBegin + (i - inorderBegin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [inorderLeft.size(),end())</span></span><br><span class="line">        <span class="type">int</span> postorderBeginRight = postorderBegin + (i - inorderBegin); <span class="comment">// 这里不需要加一，因为中间没有多出来一个数</span></span><br><span class="line">        <span class="type">int</span> postorderEndRight = postorderEnd <span class="number">-1</span>; <span class="comment">// 排除最后一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(inorder,inorderBeginLeft,inorderEndLeft,postorder,postorderBeginLeft,postorderEndLeft);</span><br><span class="line">        TreeNode* right = _buildTree(inorder,inorderBeginRight,inorderEndRight,postorder,postorderBeginRight,postorderEndRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>(),postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c20668f2784839f073d00b700bc039d1.png" alt="image-20240317182254991"></p><h2 id="105-从前序和中序遍历构造二叉树"><a href="#105-从前序和中序遍历构造二叉树" class="headerlink" title="105 从前序和中序遍历构造二叉树"></a>105 从前序和中序遍历构造二叉树</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p></blockquote><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3b2acc3f4d092a12194f29d9c922f159.png" alt="image-20240317182505486"></p><p>这道题和上一道题的思路基本一致，这里就不用构造vector的思路了，直接用下标的方式来处理。</p><ul><li>前序遍历的第一个值是根节点</li><li>在中序遍历的数组中找到根节点的位置，根据该位置左右拆分数组</li><li>在前序遍历数组中，从第二位开始，根据中序遍历拆出来的两个数组的长度，拆分前序遍历的数组。</li><li>递归处理</li></ul><p>在后序遍历的数组中，需要排除的是最后一位。在前序遍历的数组中，需要排除的是第一位。在拆分数组下标的地方体现出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder,<span class="type">int</span> preorderBegin,<span class="type">int</span> preorderEnd,<span class="type">const</span>  vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> inorderBegin,<span class="type">int</span> inorderEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归返回条件</span></span><br><span class="line">        <span class="keyword">if</span>(inorderBegin &gt;= inorderEnd || preorderBegin &gt;= preorderEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历的第一个</span></span><br><span class="line">        <span class="type">int</span> val = preorder[preorderBegin];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找</span></span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = inorderBegin;i&lt;inorderEnd;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分中序遍历数组</span></span><br><span class="line">        <span class="type">int</span> offset = i-inorderBegin;</span><br><span class="line">        <span class="comment">// 左侧数组[inorderBegin,inorderBegin+offset)</span></span><br><span class="line">        <span class="type">int</span> inorderBeginLeft = inorderBegin;</span><br><span class="line">        <span class="type">int</span> inorderEndLeft = inorderBegin + offset;  <span class="comment">// 这里不能直接加i，应该加i和开头的偏移量</span></span><br><span class="line">        <span class="comment">// 右侧数组[inorderBegin+offset+1,inorderEnd)</span></span><br><span class="line">        <span class="type">int</span> inorderBeginRight = inorderBegin + offset+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> inorderEndRight = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分前序遍历数组</span></span><br><span class="line">        <span class="comment">// 左侧数组[preorderBegin+1,preorderBegin+1+offset)，开头需要加一跳过第一个值</span></span><br><span class="line">        <span class="type">int</span> preorderBeginLeft = preorderBegin+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preorderEndLeft = preorderBegin+<span class="number">1</span>+offset;</span><br><span class="line">        <span class="comment">// 右侧数组[preorderBegin+1+offset,preorderEnd)</span></span><br><span class="line">        <span class="type">int</span> preorderBeginRight = preorderBegin+<span class="number">1</span>+offset;</span><br><span class="line">        <span class="type">int</span> preorderEndRight = preorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(preorder,preorderBeginLeft,preorderEndLeft,inorder,inorderBeginLeft,inorderEndLeft);</span><br><span class="line">        TreeNode* right = _buildTree(preorder,preorderBeginRight,preorderEndRight,inorder,inorderBeginRight,inorderEndRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>() == <span class="number">0</span> || inorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>(),inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/61d66d0b4bbef588ec323178e26c13fa.png" alt="image-20240317184256405"></p><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654 最大二叉树"></a>654 最大二叉树</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></p></blockquote><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <code>nums</code> 构建的<strong>最大二叉树</strong> 。</p><hr><p>这道题和前面105&#x2F;106这两道题的思路几乎完全一致，用前序遍历递归的思想，先找到最大值作为根节点，然后拆分左右区间（类似与105&#x2F;106题目中拆分中序遍历数组的左右区间）。拆分区间后进行遍历构建左右子树就行了。</p><p>这里要注意递归的退出条件，因为begin&#x2F;end选用的是左闭右开的选择，所以<code>begin==end</code>的情况也是无效的，所以<code>begin&gt;=end</code>作为递归的退出条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 查找最大值，返回最大值的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchMaxIndex</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> maxNum = nums[begin];</span><br><span class="line">        <span class="type">int</span> maxNumIndex = begin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = begin;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxNum)&#123;</span><br><span class="line">                maxNum = nums[i];</span><br><span class="line">                maxNumIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNumIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* _constructMaximumBinaryTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> begin,<span class="type">int</span> end)&#123;</span><br><span class="line">        <span class="comment">// 本题采用左闭右开，所以begin==end是无效区间</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> || begin&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到最大值的下标</span></span><br><span class="line">        <span class="type">int</span> maxNumIndex = <span class="built_in">searchMaxIndex</span>(nums,begin,end);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxNumIndex]);</span><br><span class="line">        <span class="comment">// 左右拆分</span></span><br><span class="line">        <span class="type">int</span> leftBegin = begin;</span><br><span class="line">        <span class="type">int</span> leftEnd = maxNumIndex; </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rightBegin = maxNumIndex+<span class="number">1</span>; <span class="comment">// 加一跳过当前选中节点</span></span><br><span class="line">        <span class="type">int</span> rightEnd = end;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = _constructMaximumBinaryTree(nums,leftBegin,leftEnd);</span><br><span class="line">        root-&gt;right = _constructMaximumBinaryTree(nums,rightBegin,rightEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _constructMaximumBinaryTree(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/da6a3c1927b4d27c72da012d018f3cbc.png" alt="image-20240317193842851"></p><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></p></blockquote><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><hr><p>这道题其实就是遍历二叉树多了第二棵树而已，不需要想的太复杂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        <span class="comment">// 如果一棵树为空了，就直接返回另外一棵树来拼接</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 借用root1加上值</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        <span class="comment">// 这里因为root1和root2的遍历顺序都是一样的，所以肯定能匹配上</span></span><br><span class="line">        root1-&gt;left = _mergeTrees(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root1-&gt;right = _mergeTrees(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _mergeTrees(root1,root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6d041cf7b2d1792eeb72179653d0d30d.png" alt="image-20240317205658359"></p><p>使用迭代法的层序遍历思想也能解决这道题，需要将两棵树的根都插入队列中。在开始遍历之前，需要确定我们是用root1还是root2来构造最终的二叉树。</p><ul><li>取出节点，值相加</li><li>如果两个节点的左侧都不为空，入队列（注意顺序要一致）</li><li>如果两个节点的右侧都不为空，入队列</li><li>如果r1的左侧节点为空，r2不为空，将r1的左侧链接为r2</li><li>如果r1的右侧节点为空，r2不为空，将r1的右侧链接为r2</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果一棵树为空了，就直接返回另外一棵树来拼接</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里root1和2都不为空</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root1);</span><br><span class="line">        que.<span class="built_in">push</span>(root2);</span><br><span class="line">        <span class="comment">// 确定用root1来链接树</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里不需要多层序遍历的循环，因为root1和root2每一层节点个数不相同</span></span><br><span class="line">            </span><br><span class="line">            TreeNode* r1 = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* r2 = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            r1-&gt;val += r2-&gt;val;</span><br><span class="line">            <span class="comment">// 如果两个节点的左右子树都不空，则都插入数组</span></span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;left != <span class="literal">nullptr</span> &amp;&amp; r2-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(r1-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(r2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;right != <span class="literal">nullptr</span> &amp;&amp; r2-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(r1-&gt;right);</span><br><span class="line">                que.<span class="built_in">push</span>(r2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果r1的左侧为空，r2不为空，赋值</span></span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;left == <span class="literal">nullptr</span> &amp;&amp; r2-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r1-&gt;left = r2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;right == <span class="literal">nullptr</span> &amp;&amp; r2-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r1-&gt;right = r2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5cd92f8447a1213e28984aa6693eeecf.png" alt="image-20240317210547382"></p><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700 二叉搜索树中的搜索"></a>700 二叉搜索树中的搜索</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></p></blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p>代码如下，其实就是最最基本的搜索二叉树的查找方式。搜索二叉树的左子树的值小于当前节点的值，右子树的值大于当前节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _searchBST(TreeNode* root,<span class="type">const</span> <span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> _searchBST(root-&gt;left,val); <span class="comment">// 左侧更小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _searchBST(root-&gt;right,val); <span class="comment">// 右侧更小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _searchBST(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/27109369c080398669b2833e19d5f102.png" alt="image-20240317211001013"></p><p>用循环也能实现，因为这里不涉及到前中后序遍历什么的，只是单纯找一个值，所以用不上队列或者栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用循环也可以</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; val)</span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="98-验证二层搜索树"><a href="#98-验证二层搜索树" class="headerlink" title="98 验证二层搜索树"></a>98 验证二层搜索树</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p></blockquote><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>注意：二叉搜索树中不能有重复节点，因为无法判断两个相同节点的区别。</p><hr><p>这道题可以采用中序遍历的方式，构建一个二叉树的数组，并遍历判断这个数组是否有序（搜索二叉树的中序遍历肯定是有序的），代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _inorderTravel(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _inorderTravel(root-&gt;left,v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        _inorderTravel(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本题保证root非空</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        _inorderTravel(root,v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 不能有重复节点，这里是大于等于</span></span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt;= v[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e947106623f118df8d3af395f66560e9.png" alt="image-20240318104631391"></p><p>当然，不用额外的数组也能写出这道题。思路是用中序遍历，维护一个当前最大值（初始化为<code>LONG_MIN</code>），在中序部分判断当前节点是否小于这个最大值，如果小于等于，则说明当前节点之前有比当前节点更大或等于当前值的节点，这是不符合条件的，返回假。</p><p>其他情况返回真。</p><p>因为本题目保证了root是非空的，所以第一个root的判断返回false&#x2F;true可以根据算法自行选择。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> maxNum = LONG_MIN;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= maxNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            maxNum = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retLeft &amp;&amp; retRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7def55fee335595ab04630b5e4be6416.png" alt="image-20240318105739796"></p><p>这个算法还是会有一个问题，即二层搜索树中可能会存在本来就等于<code>LONG_MIN</code>的节点，此时会直接返回false，不符合预期。所以应该把maxNum初始化为二叉树中左下角的那个节点的值，来保证无论如何都可以遍历成功，避免我们选用的初始值对算法结果的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= prev-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retLeft &amp;&amp; retRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/55533a22daa18eeb746d2d6cf3d913a8.png" alt="image-20240318110020250"></p><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530 二叉搜索树的最小绝对差"></a>530 二叉搜索树的最小绝对差</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></p></blockquote><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><hr><p>因为题目给的是搜索二叉树，还是和前两题类似，利用中序遍历的有序序列，计算两个相邻节点之间的差值，<strong>差值的最小值只可能是在两个相邻节点之间</strong>。这就好比给你一个有序的<strong>单调递增的数组</strong>，让你返回这个数组中任意两个数的最小差值一样。</p><p>同样，可以用中序遍历将搜索二叉树转为数组再进行处理，具体代码参考上题（一模一样的转化再遍历），这里给出直接用中序遍历递归实现的的算法，思路是维护一个当前节点的<strong>前一个节点的指针</strong>，并依次计算两个相邻节点之间的差值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> minDiff = INT_MAX;</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">void</span> _getMinimumDifference(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左侧</span></span><br><span class="line">        _getMinimumDifference(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算差值</span></span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            minDiff = <span class="built_in">min</span>(minDiff,root-&gt;val - prev-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有情况都需要更新prev</span></span><br><span class="line">        prev = root;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        _getMinimumDifference(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        _getMinimumDifference(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/a214d88159622e177076e223f43e6e95.png" alt="image-20240318143728984"></p><p>使用迭代，利用中序遍历的迭代思路也能解决这道题，这里主要是要记住怎么使用栈进行中序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="type">int</span> ret = INT_MAX; <span class="comment">// 最小差值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个条件符合都不符合才停止循环</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left; <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 往左一直走到空了</span></span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 父亲节点</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 中序处理，计算最小值</span></span><br><span class="line">                <span class="keyword">if</span>(prev != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    ret = <span class="built_in">min</span>(ret,cur-&gt;val - prev-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                prev = cur;</span><br><span class="line">                <span class="comment">// 右</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/eb41ec52f3f08a6acd2f547b9604ae29.png" alt="image-20240318144644478"></p><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501 二叉搜索树中的众数"></a>501 二叉搜索树中的众数</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></p></blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><hr><p>这道题首先可以按任何二叉树来操作，即遍历整棵树，用map记录某个节点出现的频率，最终将出现频率最高的几个数取出来。</p><p>注意，这里不能一上来就直接用优先级队列，因为优先级队列是没有办法修改某个值的。可以用map统计完后再用优先级队列来排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 因为只是遍历统计，所以用什么顺序遍历都没有区别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTravel</span><span class="params">(TreeNode* root,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; countMap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root-&gt;left,countMap);</span><br><span class="line">        countMap[root-&gt;val]++;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root-&gt;right,countMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyCmp</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">// 别忘了设置为公有</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p1, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second &lt; p2.second; <span class="comment">// 使用小于建立大堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; countMap;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root,countMap);</span><br><span class="line">        <span class="comment">// 使用优先级队列来初始化值</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,MyCmp&gt; <span class="built_in">que</span>(countMap.<span class="built_in">begin</span>(),countMap.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 取出头部计数器相同的，插入数组</span></span><br><span class="line">        <span class="keyword">auto</span> curPair = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        retV.<span class="built_in">push_back</span>(curPair.first);</span><br><span class="line">        <span class="comment">// 只要队列不为空就继续操作</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 当当前计数和刚刚插入的一致，则继续插入</span></span><br><span class="line">            <span class="keyword">if</span>(curPair.second == que.<span class="built_in">top</span>().second)&#123;</span><br><span class="line">                curPair = que.<span class="built_in">top</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curPair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 不符合条件，跳出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7add75ede3a5bb148a880b6f8b545578.png" alt="image-20240318150300783"></p><p>不过本题是一个搜索二叉树，解题方法肯定不同。还是那个性质，搜索二叉树的中序遍历结果是有序的，那么我们就可以通过这个有序来遍历计算当前数字出现的频率。同样是维护一个prev指针指向上一个节点，并对连续相同的数进行计数。</p><p>当遇到第一个不相同的节点时，清空计数器，将上一个节点插入返回值数组，重新开始计数。如果新的这个数字的数量大于上一个数字，那么就将返回值数组清空（因为此时返回值数组中的元素是无效的），重新按这个新的count计算众数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">-1</span>; <span class="comment">// 计数器肯定是正的，初始化为负数即可</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 这里不能用count作为参数，因为每一层的修改对全局都是有效的</span></span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inordereTravelCount</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; retV)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root-&gt;left,retV);</span><br><span class="line">        <span class="comment">// 中，计数</span></span><br><span class="line">        <span class="keyword">if</span>(prev == <span class="literal">nullptr</span>)<span class="comment">// 第一个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prev-&gt;val == root-&gt;val) <span class="comment">// 相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 不相同，新的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和当前记录最大值相同，插入        </span></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超过了最大记录，需要清空返回值数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            retV.<span class="built_in">clear</span>();</span><br><span class="line">            retV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root-&gt;right,retV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/493f11bd2c3022a88ee7307d30d5932b.png" alt="image-20240318151918601"></p><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236 二叉树的最近公共祖先"></a>236 二叉树的最近公共祖先</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p></blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><hr><p>首先要明确，root也可以是自己的公共祖先，所以root等于p或者等于q的情况也是符合条件的。本题需要我们从左右子树中找到p和q，然后再往上返回它的最近公共祖先，即从树的底部往上遍历。<strong>后序遍历</strong>（左右中）就是符合这个条件的。</p><p>下图中，带序号的线代表后序遍历的顺序，长虚线代表每一次的返回值。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/11cc4daf0b5ecc01017d3515b944eb39.png" alt="image-20240318190309074"></p><p>整体思路如下：</p><ul><li>判断root是否等于q&#x2F;p，或者root为空，此时返回root；</li><li>递归判断左侧和右侧，记录返回值</li><li>如果左侧和右侧返回值都不为空，则代表当前节点就是最近的公共祖先节点，返回root节点（当前节点）；</li><li>如果左侧和右侧有一个为空，则返回不为空的那一个；</li><li>如果左侧和右侧都为空，则返回空（代表当前节点的子树中没有找到q和p）；</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root也可以是它自己的祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用后序遍历的思路来处理，这样能找到当前节点的孩子里面有么有q或者p</span></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p,  q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p,  q);</span><br><span class="line">        <span class="comment">// 如果左右都不为空，则代表root就是最近的公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// // // 如果两个都为空，代表没有找到，返回空</span></span><br><span class="line">        <span class="comment">// if(left == nullptr &amp;&amp; right == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return nullptr;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// // 如果有一个为空，则返回另外一个</span></span><br><span class="line">        <span class="comment">// if(left != nullptr &amp;&amp; right == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return left;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(left == nullptr &amp;&amp; right != nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return right;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return nullptr; // 这里的返回没有意义，因为不会走到这里来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的三个判断可以精简成下面这个</span></span><br><span class="line">        <span class="comment">// 如果left为空且right也为空的时候，本来就需要返回nullptr，此时返回right也是一样的</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">nullptr</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3fbff287842a54bdb60b89c6ded43521.png" alt="image-20240318184443461"></p><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235 二叉搜索树的最近公共祖先"></a>235 二叉搜索树的最近公共祖先</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></p></blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><hr><p>本题和上一题要求一致，但树是搜索二叉树。利用这个特性，给定q和p的公共祖先的值肯定在<code>[q, p]</code>范围区间之间（注意q和p没有说明谁更大，所以要判断<code>q&lt;cur&lt; p</code>和<code>p&lt;cur&lt;q</code>的两种情况），找公共祖先，只需要从上往下，找到第一个值符合这个区间范围的节点就可以了。</p><ul><li>搜索二叉树的左侧小于当前节点，右侧大于当前节点；</li><li>从上往下遍历（用前序遍历），此时先处理的是中间节点，那么第一个找到的符合<code>[q,p]</code>区间的节点就是最近的公共祖先，此时往左还是往右都会错过；</li></ul><p>如下所示，找1和8节点的公共祖先（即5），此时如果往左走到3，就会错过8的祖先，往右走到9，就会错过1的公共祖先</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ed75ee6553efc114dccd290d96603fc2.png" alt="image-20240318192043482"></p><p>理解思路了，代码就不难写了，前序遍历的二叉搜索代码就可以了。因为这是搜索二叉树，不需要递归也能实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="comment">// 找到q和p中的最小值</span></span><br><span class="line">        <span class="type">int</span> min = q-&gt;val,max = p-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; max)&#123;</span><br><span class="line">            min = max;</span><br><span class="line">            max = q-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 符合条件</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= min &amp;&amp; cur-&gt;val &lt;= max)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果大了，就往左走</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; max)&#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 小了就往右边走</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; min)&#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/38160fcf06b8e269687f27e24468d03d.png" alt="image-20240318192653511"></p><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701 二叉搜索树中的插入操作"></a>701 二叉搜索树中的插入操作</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></p></blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> 新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><hr><p>这道题没有那么难，因为题目要求的是二叉搜索树，并不是平衡二叉搜索树，所以不存在需要翻转的情况。我们只需要找到这个新节点应该存放的位置，将其链接进去就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* newNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* prev = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; val)&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; val)&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到对应位置了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上一个节点肯定是叶子节点</span></span><br><span class="line">        <span class="comment">// 当前节点值更大，是左侧</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &gt; val)&#123;</span><br><span class="line">            prev-&gt;left = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点值更小，所以是右侧</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &lt; val)&#123;</span><br><span class="line">            prev-&gt;right = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/535f71322ea3e7dc4ffbab1b94c9d509.png" alt="image-20240318193613367"></p><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450 删除二叉搜索树中的节点"></a>450 删除二叉搜索树中的节点</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></p></blockquote><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><hr><p>删除搜索二叉树中的节点需要判断当前的情况</p><ul><li>没找到需要删除的节点，直接返回；</li><li>当前节点是叶子节点，将父节点的指针改成nullptr，delete该节点即可；</li><li>当前节点左侧节点为空，右侧不为空，将右侧节点记录，父节点的指针改成右侧节点，删除当前节点；</li><li>当前节点右侧节点为空，左侧不为空，将左侧节点记录，父节点的指针改成左侧节点，删除当前节点；</li><li>当前节点左侧右侧都不为空，将当前节点的<strong>左侧</strong>移动至<strong>右侧的最左节点</strong>，</li></ul><p>这里最难处理的是最后一种情况，见下图，红色是要被删除的节点5，绿色是该节点的左子树，蓝色是该节点的右子树。我们需要将5节点的左子树3移动到它的右子树的最左侧节点（即移动到6的位置）链接上。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/692196a8807952e769421990232060e8.png" alt="image-20240318200430007"></p><p>因为是二叉搜索树，所以不需要用递归，循环找节点就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteOneNode</span><span class="params">(TreeNode* target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧为空，无论如何都返回左侧</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧不为空，统一处理，找到右子树的最左侧节点，进行链接</span></span><br><span class="line">        TreeNode* cur = target-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = target-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> target-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 记录cur的父节点，用来删除cur</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == key) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; key) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果搜索树只有头结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断删左孩子还是右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;left == cur) &#123;</span><br><span class="line">            pre-&gt;left = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;right != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;right == cur) &#123;</span><br><span class="line">            pre-&gt;right = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c59158ebd922e21fcd72d0df02c3d4d0.png" alt="image-20240319105711618"></p><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669 修剪二叉搜索树"></a>669 修剪二叉搜索树</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></p></blockquote><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><hr><p>这里使用递归的方式来处理节点，通过返回值来将需要删除的节点排除掉。</p><ul><li>空节点，返回（递归末端条件）；</li><li>如果当前节点小于目标区间，则往右侧找并返回（这就相当于删除了当前节点）；</li><li>如果当前节点大于目标区间，则往左侧找并返回（这就相当于删除了当前节点）；</li><li>如果当前节点符合目标区间，则递归遍历左子树和右子树，并重新赋值新的左子树和右子树；</li></ul><p>其中最后一步是比较重要的，当前节点符合条件后，它的左侧和右侧可能会有不在区间内的节点，所以在递归遍历的同时，需要更新当前节点的左右子树指针，来接受递归后<strong>剔除了不符合条件节点</strong>的树。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9915c8d233479e5891444fd29a9d1898.png" alt="image-20240319122027435"></p><p>主要是理解如何通过递归的返回值来巧妙的“删除”不符合条件的节点。以上图的树为例，给定区间<code>[2,4]</code>，需要删除的节点是0和1。过程如下</p><ul><li>3符合条件，递归遍历左子树和右子树</li><li>右子树的4符合条件，递归遍历左子树和右子树（都为空，直接返回，相当于对4的节点没有做修改），最终返回4节点，赋值给3节点的right（也相当于没有修改）</li><li>左子树的0不符合条件（小于边界最小值），递归遍历右子树；</li><li>右子树的2符合条件，递归遍历左子树和右子树（2的右子树是空，直接返回）；</li><li>2的左子树1不符合条件（小于边界最小值），递归遍历右子树，此时1的右子树为空，相当于遍历1的这一次也是返回nullptr，并赋值给了2节点的right，相当于删除了节点1；</li><li>此时递归返回，2号节点往上返回（即遍历到0的那一次会返回2号节点），赋值给了3号节点的right，相当于删除了节点0。</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _trimBST(TreeNode* root, <span class="type">const</span> <span class="type">int</span> low,<span class="type">const</span> <span class="type">int</span> high) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意题目给出的是闭区间，所以这里超出的情况不包括=的情况</span></span><br><span class="line">        <span class="comment">// 如果当前节点值不在区间内，则往右边/左边找是否有符合条件的</span></span><br><span class="line">        <span class="comment">// 如果有则会正常返回符合条件的节点（也相当于通过返回值把当前节点删掉了）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; low)&#123;</span><br><span class="line">            <span class="keyword">return</span> _trimBST(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> _trimBST(root-&gt;left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前root的值符合范围，递归左子树和右子树，剔除不符合条件的节点</span></span><br><span class="line">        root-&gt;left = _trimBST(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right = _trimBST(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _trimBST(root,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d182dfe0db490518d670dbdb30fea46f.png" alt="image-20240319121234419"></p><h2 id="108-将有序数组转为二叉搜索树"><a href="#108-将有序数组转为二叉搜索树" class="headerlink" title="108 将有序数组转为二叉搜索树"></a>108 将有序数组转为二叉搜索树</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></p></blockquote><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><hr><p>这道题其实没有想象中的那么难，因为题目给的数组是有序的（可以理解为本来就是一格二叉搜索树的中序遍历数组形式），我们只需要通过<strong>前序遍历</strong>加上拆分数组，最终构建出来的树肯定会是一个平衡的二叉搜索树。</p><p>在上文中的<code>654 最大二叉树</code>中已经使用了拆分数组构建树的方式，那道题是需要找到数组中的最大点。本题的平衡二叉搜索树需要找到<strong>有序数组的中间节点</strong>（即当前的中位数）作为根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _sortedArrayToBST(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right) &#123;</span><br><span class="line">	    <span class="comment">// 注意right是开区间，left=right的时候也无效</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left)/<span class="number">2</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// int mid = (right - left)/2; // 这样计算的结果是错误的，值可能会小于left，导致陷入死循环</span></span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = _sortedArrayToBST(nums,left,mid);</span><br><span class="line">        root-&gt;right = _sortedArrayToBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _sortedArrayToBST(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ad9482d397c93fc97210bb4b8bba543a.png" alt="image-20240319124522237"></p><p>如果使用迭代法，需要三个队列，一个存放节点，一个存放左区间，一个存放右区间。以下代码来自<a target="_blank" rel="noopener" href="https://www.programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);   <span class="comment">// 初始根节点</span></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQue;           <span class="comment">// 放遍历的节点</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; leftQue;                 <span class="comment">// 保存左区间下标</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; rightQue;                <span class="comment">// 保存右区间下标</span></span><br><span class="line">        nodeQue.<span class="built_in">push</span>(root);                 <span class="comment">// 根节点入队列</span></span><br><span class="line">        leftQue.<span class="built_in">push</span>(<span class="number">0</span>);                    <span class="comment">// 0为左区间下标初始位置</span></span><br><span class="line">        rightQue.<span class="built_in">push</span>(nums.<span class="built_in">size</span>() - <span class="number">1</span>);     <span class="comment">// nums.size() - 1为右区间下标初始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeQue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* curNode = nodeQue.<span class="built_in">front</span>();</span><br><span class="line">            nodeQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left = leftQue.<span class="built_in">front</span>(); leftQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> right = rightQue.<span class="built_in">front</span>(); rightQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            curNode-&gt;val = nums[mid];       <span class="comment">// 将mid对应的元素给中间节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= mid - <span class="number">1</span>) &#123;          <span class="comment">// 处理左区间</span></span><br><span class="line">                curNode-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                nodeQue.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                leftQue.<span class="built_in">push</span>(left);</span><br><span class="line">                rightQue.<span class="built_in">push</span>(mid - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &gt;= mid + <span class="number">1</span>) &#123;         <span class="comment">// 处理右区间</span></span><br><span class="line">                curNode-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                nodeQue.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                leftQue.<span class="built_in">push</span>(mid + <span class="number">1</span>);</span><br><span class="line">                rightQue.<span class="built_in">push</span>(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转为累加树"><a href="#538-把二叉搜索树转为累加树" class="headerlink" title="538 把二叉搜索树转为累加树"></a>538 把二叉搜索树转为累加树</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></p></blockquote><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7ef89c321b9f619dfccde873ccd90f9c.png" alt="image-20240319124844008"></p><p>题目要求的是将每个节点的值转为它和它右侧的节点的和。用数组可能更好理解一些，即将当前数组下标位置的<strong>值改为它和它右侧的节点的和</strong>。</p><p>所以可以从右侧往左侧遍历这个数组，记录一个求和值，并将当前数组的值加上这个求和值就行了。比如数组<code>[15,24,30]</code>的结果是<code>[68,54,30]</code>；</p><p>对于二叉树也是一样的，从右侧往左侧遍历，顺序是<code>右中左</code>，把中序遍历的代码改一下顺序就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum  = <span class="number">0</span>;</span><br><span class="line">    TreeNode* _convertBST(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        _convertBST(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        _convertBST(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _convertBST(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/60fa23c99471735c788fe0f350bac25d.png" alt="image-20240319183019626"></p><p>如果要用迭代法，同样是中序遍历的迭代模板，将左右子树遍历的顺序修改一下就可以了。以下代码来自代码随想录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> pre; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;right;   <span class="comment">// 右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();     <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                cur-&gt;val += pre;</span><br><span class="line">                pre = cur-&gt;val;</span><br><span class="line">                cur = cur-&gt;left;    <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129 求根节点到叶节点数字之和"></a>129 求根节点到叶节点数字之和</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/">https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/</a></p></blockquote><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：25</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13</span><br><span class="line">因此，数字总和 = 12 + 13 = 25</span><br></pre></td></tr></table></figure><p>这道题和前文做过的路径总和类似，只不过路径总和是二叉树到叶子节点的整个路径上节点的和，而这道题让我们把二叉树从根到叶子节点的路径视作一个数字来处理。</p><p>所以可以用<strong>前序遍历</strong>（根左右）的方式，给每个二叉树到叶子节点的路径创建一个数组，将节点值尾插。并在叶子节点将这个数组转成int值，作为其中一个数字插入到retV最终数组中。在主函数内，先调用递归函数，然后再遍历retV数组相加里面的值就可以了。</p><p>这道题需要注意的是，我们需要在叶子节点做插入retV的处理，而不是在空节点中做。如果在空节点中做处理，那么一条路径的数字会被插入retV两次（因为叶子节点递归的左子树和右子树都是空，会被操作两次。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">    <span class="comment">// 数组转为int</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vector2int</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum = sum * <span class="number">10</span> + v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _sumNumbers(TreeNode* root, vector&lt;<span class="type">int</span>&gt; curV) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 空节点不做任何处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到叶子节点就需要插入了，不然会额外多处理一次</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(root-&gt;val);        <span class="comment">// 叶子节点的值</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(<span class="built_in">vector2int</span>(curV)); <span class="comment">// 插入返回值数组</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        _sumNumbers(root-&gt;left, curV);</span><br><span class="line">        _sumNumbers(root-&gt;right, curV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        _sumNumbers(root, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : retV) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/36c39234f901411008ac220c78eb5f60.png" alt="image.png"></p><h2 id="1382-将二叉搜索树变平衡"><a href="#1382-将二叉搜索树变平衡" class="headerlink" title="1382 将二叉搜索树变平衡"></a>1382 将二叉搜索树变平衡</h2><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balance-a-binary-search-tree/description/">https://leetcode.cn/problems/balance-a-binary-search-tree/description/</a></p></blockquote><p>给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p><p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,null,3,null,4,null,null]</span><br><span class="line">输出：[2,1,3,null,null,null,4]</span><br><span class="line">解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。</span><br></pre></td></tr></table></figure><p>这道题其实是两道题的结合：将搜索二叉树转为有序数组+108从有序数组构造平衡搜索二叉树。我们将给定的搜索二叉树按中序遍历的方式存入数组，即得到了一个有序数组，再根据这个有序数组构造平衡二叉树即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 中序遍历转数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">treeToVector</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">treeToVector</span>(root-&gt;left,v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">treeToVector</span>(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">vectorToBanlanceBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// right是开区间，left=right的情况也是无效的</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">vectorToBanlanceBST</span>(v, left, mid);</span><br><span class="line">        root-&gt;right = <span class="built_in">vectorToBanlanceBST</span>(v, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="comment">// 先用中序遍历转成数组（题目给的已经是一个二叉搜索树，中序遍历肯定有序）</span></span><br><span class="line">        <span class="built_in">treeToVector</span>(root, v);</span><br><span class="line">        <span class="comment">// 然后用108有序数组转成二叉平衡树的思路来转换</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vectorToBanlanceBST</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/1663eb89ae2a32c62f6380923d722be8.png" alt="image.png"></p><h1 id="3-递归函数什么时候需要返回值？"><a href="#3-递归函数什么时候需要返回值？" class="headerlink" title="3.递归函数什么时候需要返回值？"></a>3.递归函数什么时候需要返回值？</h1><blockquote><p>以下总结来自代码随想录</p></blockquote><p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p><ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（题目113路径总和2）</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （题目236二叉树的最近公共祖先）</li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（题目112路径总和）</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇刷题笔记到这里就结束啦，如果对涉及到的题目有什么不懂的地方，可以在评论区提出哦！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703532.png" alt="image-20220416170310498"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/4165981723/">https://blog.musnow.top/posts/4165981723/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E6%A0%91/">树</a><a class="post-meta__tags" href="/tags/OJ%E5%88%B7%E9%A2%98/">OJ刷题</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm4.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4214339491/" title="【leetcode】哈希OJ题，383赎金信/202快乐数/242有效的字母异位词"><img class="cover" src="/img/bg/gm2.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【leetcode】哈希OJ题，383赎金信/202快乐数/242有效的字母异位词</div></div></a></div><div class="next-post pull-right"><a href="/posts/2402466745/" title="【leetcode】239滑动窗口最大值"><img class="cover" src="/img/bg/gm19.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【leetcode】239滑动窗口最大值</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/3906762122/" title="【算法】算法的空间复杂度和时间复杂度"><img class="cover" src="https://img.musnow.top/i/2023/02/image-20220313113801204.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-13</div><div class="title">【算法】算法的空间复杂度和时间复杂度</div></div></a></div><div><a href="/posts/2357097133/" title="【C语言】数据结构-链式二叉树，详解分治递归和层序遍历"><img class="cover" src="/img/bg/gm24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-16</div><div class="title">【C语言】数据结构-链式二叉树，详解分治递归和层序遍历</div></div></a></div><div><a href="/posts/3770717253/" title="【C语言】带你刷爆十道链表OJ"><img class="cover" src="/img/bg/gm24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">【C语言】带你刷爆十道链表OJ</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">360</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%B8%80%E4%BA%9B%E9%80%89%E6%8B%A9%E9%A2%98"><span class="toc-text">1.一些选择题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1"><span class="toc-text">1.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2"><span class="toc-text">1.2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%94%B1%E5%B7%B2%E7%9F%A5%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%94%BB%E5%87%BA%E5%8E%9F%E6%9C%AC%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">1.3 由已知遍历序列画出原本树的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%8D%95%E8%BE%B9%E6%A0%91"><span class="toc-text">1.4 单边树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5"><span class="toc-text">1.5</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-OJ%E9%A2%98%E5%88%B7%E8%B5%B7%E6%9D%A5%EF%BC%81"><span class="toc-text">2.OJ题刷起来！</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KY11-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-text">KY11 二叉树遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-text">100 相同的树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">101 对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#572-%E5%8F%A6%E5%A4%96%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">572 另外一棵树的子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102 层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#107-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E2%85%A1"><span class="toc-text">107 层序遍历Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">199 二叉树的右视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-text">637 二叉树的层平均值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">226 翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">前序遍历实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">层序遍历实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#429-N%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">429 N叉树层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#515-%E5%9C%A8%E6%AF%8F%E5%B1%82%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">515 在每层中找最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text">116 填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%E2%85%A1"><span class="toc-text">117 填充每个节点的下一个右侧节点指针Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">104 二叉树最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-text">114 二叉树的最小深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F"><span class="toc-text">222 完全二叉树的节点数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">110 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text">257 二叉树的所有路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-text">404 左叶子之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-text">513 找树左下角的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">112 路径总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1"><span class="toc-text">113 路径总和Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">106 从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105 从前序和中序遍历构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">654 最大二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">617 合并二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-text">700 二叉搜索树中的搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%B1%82%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">98 验证二层搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-text">530 二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-text">501 二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">236 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">235 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">701 二叉搜索树中的插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450 删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">669 修剪二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">108 将有序数组转为二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-text">538 把二叉搜索树转为累加树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#129-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-text">129 求根节点到叶节点数字之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1382-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1"><span class="toc-text">1382 将二叉搜索树变平衡</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="toc-text">3.递归函数什么时候需要返回值？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3781449179/" title="【建站】使用mrdoc和1panel的时候如何添加bing站长验证">【建站】使用mrdoc和1panel的时候如何添加bing站长验证</a><time datetime="2024-05-19T02:01:50.000Z" title="发表于 2024-05-19 10:01:50">2024-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3174951422/" title="【leetcode】121.买卖股票的最佳时机">【leetcode】121.买卖股票的最佳时机</a><time datetime="2024-05-04T02:05:23.000Z" title="发表于 2024-05-04 10:05:23">2024-05-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3165124961/" title="【leetcode】96.不同的二叉搜索树">【leetcode】96.不同的二叉搜索树</a><time datetime="2024-04-23T04:42:36.000Z" title="发表于 2024-04-23 12:42:36">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2470995449/" title="【leetcode】95.不同的二叉搜索树2">【leetcode】95.不同的二叉搜索树2</a><time datetime="2024-04-23T04:42:36.000Z" title="发表于 2024-04-23 12:42:36">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>