<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【C语言】八大排序算法（带图详解） | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 前言如果你把本专栏从头看到这里，那么恭喜你，本篇博客已经是是初阶数据结构的收尾啦😁！让我们一起来学习一下，那些常见的排序算法！  本篇博客主要讲述八大排序🕵️‍♀️，桶排序&#x2F;基数排序可能会在后期补上！欢迎大家收藏本文！   在之前的学习中，我们已经接触过ez的冒泡排序，和通过堆实现的堆排序，本篇博客就不再详解这两个了！  有些排序的思路不是那么好懂，我的讲解也会有不到位的地方，欢迎在评论"><meta property="og:type" content="article"><meta property="og:title" content="【C语言】八大排序算法（带图详解）"><meta property="og:url" content="https://blog.musnow.top/posts/3996153794/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="1. 前言如果你把本专栏从头看到这里，那么恭喜你，本篇博客已经是是初阶数据结构的收尾啦😁！让我们一起来学习一下，那些常见的排序算法！  本篇博客主要讲述八大排序🕵️‍♀️，桶排序&#x2F;基数排序可能会在后期补上！欢迎大家收藏本文！   在之前的学习中，我们已经接触过ez的冒泡排序，和通过堆实现的堆排序，本篇博客就不再详解这两个了！  有些排序的思路不是那么好懂，我的讲解也会有不到位的地方，欢迎在评论"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm22.jpg"><meta property="article:published_time" content="2022-04-25T03:13:49.000Z"><meta property="article:modified_time" content="2024-08-17T22:50:49.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="C语言"><meta property="article:tag" content="算法"><meta property="article:tag" content="排序"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm22.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/3996153794/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【C语言】八大排序算法（带图详解）",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-08-18 06:50:49"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">408</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm22.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【C语言】八大排序算法（带图详解）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-25T03:13:49.000Z" title="发表于 2022-04-25 11:13:49">2022-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-17T22:50:49.000Z" title="更新于 2024-08-18 06:50:49">2024-08-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【C语言】八大排序算法（带图详解）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>如果你把本专栏从头看到这里，那么恭喜你，本篇博客已经是是初阶数据结构的收尾啦😁！让我们一起来学习一下，那些常见的<strong>排序算法</strong>！</p><blockquote><p>本篇博客主要讲述<strong>八大排序</strong>🕵️‍♀️，桶排序/基数排序可能会在后期补上！欢迎大家收藏本文！</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204222008002.png" alt="image-20220422200828833"></p><p>在之前的学习中，我们已经接触过ez的冒泡排序，和通过堆实现的堆排序，本篇博客就不再详解这两个了！</p><blockquote><p>有些排序的思路不是那么好懂，我的讲解也会有不到位的地方，欢迎在评论区提出你的疑惑或建议！🌭</p></blockquote><p>[TOC]</p><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h2><h3 id="2-1-直接插入"><a href="#2-1-直接插入" class="headerlink" title="2.1. 直接插入"></a>2.1. 直接插入</h3><p><strong>基本思想</strong>：把待排序的数依照大小插入<strong>一个已经有序的序列</strong>中，直到所有数插入完毕，就能得到一个新的有序序列</p><blockquote><p>实际上我们日常生活中打<strong>斗地主</strong>，在码牌的时候就运用了这种思想。把相同的数放在一起，并依照从小到大排列</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204221600928.png" alt="image-20220422160009868"></p></blockquote><p>你可能会疑惑，都“已经有序”了，那还怎么排序？</p><ul><li>这需要我们之前学习链式二叉树时接触到的<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/124212851">分治思想</a></li><li>当我们手头上只有两个数的时候，将大的那个数插入到小的数后头，就形成了一个有序的2数序列</li><li>这时候再让下一个数加入进来，把它插入到相应位置，得到一个有序的3数序列</li><li>依次递进，最终就能得到一个有序的N数序列</li></ul><p>如果学习过分治思想的你，肯定一拍桌子道：“我知道了，手头上只有两个数的时候，就是<strong>分治的末端条件</strong>！”</p><p>没错，我们就是要利用这种<strong>思想</strong>，实现<strong>从两个数开始</strong>的插入排序！</p><blockquote><p>给定一个数组，需要你使用插入排序，将它变成<strong>升序</strong>序列：<code>9 1 2 5 7 4 8 6 3 5</code>。</p></blockquote><p>我们就从9开始，将1插入到9的前面，2插入到1、9之间，……</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204221618132.png" alt="image-20220422161806094"></p><p>这样就能最终排序出<code>1 2 3 4 5 5 6 7 8 9</code>的结果。</p><p>最后以代码的形式操作，如下面所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，n是数组大小（开区间）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//在一个数组中插入新的数，每一趟都让最后的end+1的数据大于end</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> end = i;</span><br><span class="line">        <span class="type">int</span> tmp = a[end+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">	        <span class="comment">// 如果当前a[end]大于temp则将end往后移动</span></span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; a[end]) </span><br><span class="line">            {</span><br><span class="line">                a[end + <span class="number">1</span>] = a[end]; <span class="comment">// 将当前和下一位交换</span></span><br><span class="line">                end-= <span class="number">1</span>; <span class="comment">// 往前移动，继续比较</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">	        }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 最后end不符合条件出循环的时候，end可能为-1，a[end]会越界</span></span><br><span class="line">        a[end+<span class="number">1</span>] = tmp;</span><br><span class="line">        <span class="comment">// break出来的时候，说明往前已经没有比temp更小的数了（因为是从0开始的，前面的序列肯定是有序的）</span></span><br><span class="line">        <span class="comment">// break出来时的end已经比temp小，所以要在end+1位置复原（原本这个位置的数肯定已经被拷贝到更后面去了）</span></span><br><span class="line">        <span class="comment">// 如果这次循环什么都没有做，此时end+1就是原本的temp，自己等于自己，问题不大</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里解释一下最后为什么是<code>a[end+1] = temp</code>，注意while循环终止的几个情况：</p><ol><li>end不符合条件出循环，即end小于0，此时end应该是<code>-1</code>，所以需要用<code>a[end+1]</code>来避免越界（此时<code>a[0]</code>的值已经被移动到<code>a[1]</code>了，不会丢数据）</li><li>break出循环，分为两种子情况<ol><li>本次循环有相关操作，直到<code>a[end]</code>不再大于temp</li><li>本次循环什么都没做</li></ol></li></ol><p>对于break出循环的情况来说，如果做了操作，最终不符合条件的<code>a[end]</code>一定是小于等于temp的，既然我们需要排升序，那么就需要将temp插入到到end的下一位。原本<code>a[end+1]</code>的值肯定是大于temp的，会被移动到<code>a[end+2]</code>去，所以这样覆盖不会丢数据。</p><p>如果循环内什么都没做，此时end不会被移动，temp就是<code>a[end+1]</code>，自己赋值给自己，问题不大。</p><hr><p>由上面的代码，我们可以总结出直接插入排序的一些特性</p><ul><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(1)，是<strong>原地算法</strong></li></ul><p>元素越接近有序的时候，需要交换的次数就越少，算法的效率越高</p><h3 id="2-2-希尔排序"><a href="#2-2-希尔排序" class="headerlink" title="2.2. 希尔排序"></a>2.2. 希尔排序</h3><p><strong>希尔排序是对直接插入的优化</strong>，又称“缩小增量法”。之前我们是进数组之后直接开R，现在先Q一下再R闪，这样才能打出更秀的操作。不过我的盲僧很菜，R闪就没有成功过😥</p><blockquote><p>喂喂喂，好像跑题了！</p></blockquote><p><strong>基本思想</strong>：先选定一个整数gap，让后把待排序数据<strong>以gap为间隔</strong>进行单独的插入排序（预排序），这样让数列做到<strong>局部有序</strong>，最后在进行插入排序，达到优化<strong>插入排序算法效率</strong>的目的</p><p>比如我们设定<code>gap=3</code>，这样原本的数组就被分割成了下面的模样，接着我们先对这3组数据进行单独的插入排序【这个操作被称为 <strong>预排序</strong>】</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204221641951.png" alt="image-20220422164129904"></p><p>你能写出它们单独插入排序后的结果吗？</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204221645372.png" alt="image-20220422164534325"></p><p>这时候我们的序列虽然不是有序的，但是只看一个小局部的时候，它是有序的。这样能<strong>减少</strong>插入排序操作时候的<strong>比较次数</strong>，自然效率就变高了。</p><p>执行完<strong>预排序</strong>后，我们就可以对现在的新序列进行插入排序了。但是直接这么调用还不够优化。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241449059.jpg" alt="QQ图片20220424132543"></p><p>再仔细看看上面的思路，你会发现，其实<code>gap=1</code>的时候，就相当于一次<strong>插入排序</strong>了：</p><ul><li>而且当数据量很大的时候，我们也需要实时改变我们的<code>gap</code>。</li><li>待排序数据有100个，gap=3就太小了，优化了个寂寞。</li><li>待排序数据有10个，gap=20就是搬起石头砸自己的脚，同样不行！</li></ul><p>解决这个方法其实很简单，我们只需要根据待排序数据的大小动态设置gap就可以了，比如<code>gap=n/2</code>；</p><p>这时候就可以进行这么一个操作：<strong>每次预排序过后就改变一下gap</strong>，直到最后gap=1执行一次插入排序，数列有序。</p><hr><p>落实到代码上，我们只需要把插入排序中所有和1有关的操作都改成gap，就实现了希尔排序</p><ul><li>这里需要注意的是gap的范围，因为我设置的是gap每次都/3，所以在最后可能会出现<code>gap=2/3=0</code>的情况，这时候其实排序还没有结束，但已经跳出循环了。</li><li>我们需要在末尾+1保证最后一次插入排序的gap=1；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//只要把插入排序中的1全部改成grap，就能形成一次间隔为3的预排序</span></span><br><span class="line">    <span class="comment">//当grap=1时，效果同插入排序相同</span></span><br><span class="line">    <span class="type">int</span> grap = n;</span><br><span class="line">    <span class="comment">// 当grap=1，说明上一把已经是一次直接插入排序了</span></span><br><span class="line">    <span class="comment">// 此时数据已经有序，退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (grap &gt; <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        grap=grap/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">//每一次都÷3,再+1；防止grap=2/3=0的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - grap; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> end = i;</span><br><span class="line">            <span class="type">int</span> tmp = a[end + grap];</span><br><span class="line">            <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt; a[end])</span><br><span class="line">                {</span><br><span class="line">                    a[end + grap] = a[end];</span><br><span class="line">                    end -= grap;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            a[end + grap] = tmp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>希尔排序的时间复杂度不好确定，因为我们通常会选取不同的gap，导致时间效率也不同。不过大部分资料中给出的时间复杂度如下👇<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="25.095ex" height="2.565ex" role="img" focusable="false" viewBox="0 -883.9 11091.9 1133.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="TeXAtom" transform="translate(975.3,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(3434.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(4045.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(5045.9,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(5808.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(6197.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(7698.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="msup" transform="translate(8420.4,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="TeXAtom" transform="translate(975.3,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(10702.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><br>在“菜鸟教程”网，有对希尔排序时间复杂度的解析👉<a target="_blank" rel="noopener" href="https://www.runoob.com/data-structures/shell-sort.html#:~:text=%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%20O%20%28n%20%28logn%29%29%20%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BF%AB,%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AF%B9%E4%B8%AD%E7%AD%89%E5%A4%A7%E5%B0%8F%E8%A7%84%E6%A8%A1%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%EF%BC%8C%E4%BD%86%E5%AF%B9%E8%A7%84%E6%A8%A1%E9%9D%9E%E5%B8%B8%E5%A4%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F%E4%B8%8D%E6%98%AF%E6%9C%80%E4%BC%98%E9%80%89%E6%8B%A9%EF%BC%8C%E6%80%BB%E4%B9%8B%E6%AF%94%E4%B8%80%E8%88%AC%20O%20%28n%5E2%20%29%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%AE%97%E6%B3%95%E5%BF%AB%E5%BE%97%E5%A4%9A%E3%80%82%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9B%AE%E7%9A%84%E4%B8%BA%E4%BA%86%E5%8A%A0%E5%BF%AB%E9%80%9F%E5%BA%A6%E6%94%B9%E8%BF%9B%E4%BA%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%8D%E7%9B%B8%E9%82%BB%E7%9A%84%E5%85%83%E7%B4%A0%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%B1%80%E9%83%A8%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%B9%B6%E6%9C%80%E7%BB%88%E7%94%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%B0%86%E5%B1%80%E9%83%A8%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E3%80%82">传送门</a></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204221717852.png" alt="image-20220422171733818"></p><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><h3 id="3-1-直接选择"><a href="#3-1-直接选择" class="headerlink" title="3.1. 直接选择"></a>3.1. 直接选择</h3><p><strong>基本思路</strong>：遍历一遍数组，从中找出最大或最小的那一个数，然后将其放在数组前端。下一次遍历的时候，不再遍历这个数。</p><p>注意：得到最大最小值后，需要将其和数组开头（或者结尾）的数进行<strong>交换</strong>，而不能直接覆盖，不然会出现数据丢失</p><p>这个排序的思路非常好理解。进一步拓展，如果我一次遍历选出两个数，将最大值放在数组尾部，最小值放在数组开头，就可以减少一半遍历的次数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>{</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 直接选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> max ,min;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right){</span><br><span class="line">        max = min = left;<span class="comment">//存放下标便于后面的交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;=a[max]){</span><br><span class="line">                max= i;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[min]){</span><br><span class="line">                min= i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Swap(&amp;a[min], &amp;a[left]);</span><br><span class="line">        <span class="comment">// 如果max和left相等，第一次交换会被替换</span></span><br><span class="line">        <span class="comment">// 此时min位置是原本的max</span></span><br><span class="line">        <span class="keyword">if</span> (max == left) {</span><br><span class="line">            max = min; <span class="comment">// 重定向max</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 所以需要重定向max的位置，再交换max</span></span><br><span class="line">        Swap(&amp;a[max], &amp;a[right]);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>不过，这个算法需要多次遍历数组，效率自然低的离谱，堪比冒泡（甚至比冒泡还拉）</p><ul><li>时间复杂度：<code>O(N^2)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><hr><h3 id="3-2-堆排序"><a href="#3-2-堆排序" class="headerlink" title="3.2. 堆排序"></a>3.2. 堆排序</h3><p>堆排序是指利用<code>二叉树-堆</code>这种数据结构来进行选择数据的一种排序算法，它是<strong>选择排序</strong>的一种。</p><p>堆排序已经在之前的博客中讲解过，点击下方连接即可查看！👇</p><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/124102518">【C语言】什么是堆？堆排序和TopK问题又是如何实现的</a></p></blockquote><p>这里给出堆排序的源码，基本思路是用数组建堆，让后每一次将堆顶的最大值/最小值移动到数组末尾，在下一轮建堆的时候排除这个数。因为需要得到一个当前序列中的最大值/最小值，那么在向下调整的时候也需要符合这个策略：</p><ul><li>如果建小堆，那么就需要将左右孩子中更小的那个和父亲交换（小的往堆顶移动）；</li><li>如果建立大堆，就需要将左右孩子中大的那个和父亲交换。</li></ul><p>需要注意的是：<strong>升序要建大堆，排降序建小堆</strong>；因为每次移动都是将堆顶的移动到数组末尾，对于升序而言，数组末尾是更大的数字，所以是大堆。对于降序同理。</p><p>这里还涉及到了数组中二叉树的父亲/孩子计算问题，这个公式也常考，需要记住。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftChild = p*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">// 左孩子</span></span><br><span class="line">rightChild = p*<span class="number">2</span>+<span class="number">2</span>;<span class="comment">// 右孩子</span></span><br><span class="line">parent = (child<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">// 由孩子计算父亲</span></span><br></pre></td></tr></table></figure><p>堆排序代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换数组中两个元素的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span>* pb)</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> tmp = *pa;</span><br><span class="line">    *pa = *pb;</span><br><span class="line">    *pb = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序（n是开区间）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> root)</span></span><br><span class="line">{</span><br><span class="line">    assert(a);</span><br><span class="line">    <span class="type">int</span> parent = root;</span><br><span class="line">    <span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//左孩子</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt; n){</span><br><span class="line">        <span class="comment">// 升序用大堆，需要将小的往下调</span></span><br><span class="line">        <span class="comment">// 所以应该让p和孩子中大的那一个进行交换（把更大的换上来）</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>])</span><br><span class="line">        {</span><br><span class="line">            child++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 这个也需要根据上方 a[child] &lt; a[child + 1] 大于小于的不同进行修改</span></span><br><span class="line">        <span class="comment">// 大堆，将大的往上调（小的往下调）</span></span><br><span class="line">        <span class="comment">// 小堆，将小的往上调（大的往下调）</span></span><br><span class="line">        <span class="keyword">if</span> (a[child] &gt; a[parent]){</span><br><span class="line">            Swap(&amp;a[child], &amp;a[parent]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 升序用大堆</span></span><br><span class="line"><span class="comment">// 降序用小堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 向下调整--建堆 O(N)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i){</span><br><span class="line">        AdjustDown(a, n, i);<span class="comment">//此时建的是一个小堆</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; <span class="number">0</span>){</span><br><span class="line">        Swap(&amp;a[<span class="number">0</span>], &amp;a[end]);<span class="comment">//前后交换，最大的数放到末尾，不进行下一次调整</span></span><br><span class="line">        AdjustDown(a, end, <span class="number">0</span>);</span><br><span class="line">        end--;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>使用如下的数据进行测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> arr[]={<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>};</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    PrintArray(arr,sz,<span class="string">"初始值"</span>);</span><br><span class="line">    HeapSort(arr,sz);</span><br><span class="line">    PrintArray(arr,sz,<span class="string">"完成排序"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>可以得到升序序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">[初始值] 1 5 7 3 8 6 </span><br><span class="line">[建堆后] 8 5 7 3 1 6 </span><br><span class="line">[完成排序] 1 3 5 6 7 8 </span><br></pre></td></tr></table></figure><hr><h2 id="4-、交换排序"><a href="#4-、交换排序" class="headerlink" title="4. 、交换排序"></a>4. 、交换排序</h2><h3 id="4-1-咕噜咕噜排序"><a href="#4-1-咕噜咕噜排序" class="headerlink" title="4.1. 咕噜咕噜排序"></a>4.1. 咕噜咕噜排序</h3><p>说道<strong>冒泡</strong>排序啊，那就是陪伴咱们<strong>C语言学习始终</strong>的一个老朋友了。</p><p>在初识C语言的学习中，我曾写过一篇博客，里面讲解了用冒泡来模拟实现库函数<code>qsort</code>👉<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/122674411">传送门</a>。</p><p>它的思路就是对两个数进行比较，较大的数往尾部移动，较小的数字往头部移动</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204222014860.gif" alt="冒泡"></p><p>在<strong>very very long time ago</strong>，我也写过关于冒泡排序的博客👇</p><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/119911717?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165062690016780366548985%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165062690016780366548985&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-119911717.nonecase&utm_term=%E5%86%92%E6%B3%A1&spm=1018.2226.3001.4450">初识C语言==＞冒泡排序</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> exchange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)</span><br><span class="line">        {</span><br><span class="line">	        <span class="comment">// 每一轮都会把一个最大的数移动到最后面</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]){</span><br><span class="line">                exchange=<span class="number">1</span>;</span><br><span class="line">                Swap(&amp;a[j], &amp;a[j + <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (exchange == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//如果单趟排序没有发生交换，说明此时已经有序</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>空间复杂度：O(N^2)</li><li>时间复杂度：O(1)</li></ul><hr><h3 id="4-2-快速排序"><a href="#4-2-快速排序" class="headerlink" title="4.2. 快速排序"></a>4.2. 快速排序</h3><p>快速排序是Hoare于1962年提出的一种二叉树结构的交换排序算法。</p><p><strong>基本思想</strong>：任取待排序序列中的某个元素作为基准值，按照该基准值将待排序集合分割成<strong>两个子序列</strong>，左子序列中所有元素均<strong>小于基准值</strong>，右 子序列中所有元素均<strong>大于基准值</strong>，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241343241.jpg" alt="QQ图片20220424132540"></p><h4 id="4-2-1-Hoare法"><a href="#4-2-1-Hoare法" class="headerlink" title="4.2.1. Hoare法"></a>4.2.1. Hoare法</h4><p>发明快排的大佬给出了一个方法，假设<strong>0下标处</strong>为<code>基准值key</code>。用左右指针来遍历数组，右指针找到比key<strong>小</strong>的数后停下，左指针找找到比key<strong>大</strong>的数后停下，它们俩进行<strong>交换</strong>。</p><p>最后left和right相遇的时候，左右序列就已经排好了，此时将key与它们相遇的位置进行交换。<strong>新的序列key的左边小于key，右边大于key</strong>（此时不一定有序）</p><ul><li>疑问：既然最后要将相遇位置和key进行交换，那要怎么保证相遇位置小于key？</li><li>答：通过右指针先走来实现！</li></ul><p>可能说完思路后，你还是不太了解这左右指针是怎么走的，别着急，来康康我画的动图👇</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204222132566.gif" alt="Hoare法"></p><p>因为是右指针先走，所以右指针停下的位置，<strong>一定是小于key</strong>的位置。此时只会是L来相遇R，不可能是R往左遇到L（因为L停下的位置大于key，在这个位置的右边不可能没有一个小于key的值）</p><p>比如下图所示，如果L的位置右边只有一个比key小的值，那R在第一趟就会来到2的位置，然后L向右走一步与R相交，直接交换</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204222136890.png" alt="image-20220422213636856"></p><h5 id="4-2-1-1-两种极端情况"><a href="#4-2-1-1-两种极端情况" class="headerlink" title="4.2.1.1. 两种极端情况"></a>4.2.1.1. 两种极端情况</h5><p>也会有<span id="jump">下面的</span>两种<strong>极端情况</strong></p><ul><li>key右侧没有比key小的值，那么R会直接与L相交，再原地交换key</li><li>key右侧没有比key大的值，R先移动（原地不动），L直接与R在末尾相交，前后交换</li></ul><p>这两种极端情况，就是快排的<strong>弱势</strong>所在，在后头会讲述如何<strong>优化key的选则</strong>，来避免这种极端情况</p><hr><p>下面给出hoare法的代码，中间的代码是一趟hoare排序的实现，而在末尾，我们递归排序key的前半区域和后半区域，一直递归到最小区间：【区间只有一个值，或者区间不存在】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span><span class="comment">//hoare</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end){</span><br><span class="line">        <span class="keyword">return</span> ;<span class="comment">//分治的末端条件判断</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一趟排序</span></span><br><span class="line">    <span class="type">int</span> left = begin, right = end;</span><br><span class="line">    <span class="type">int</span> keyi = begin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span> ((a[right] &gt; a[keyi])&amp;&amp;(right&gt;=begin))</span><br><span class="line">        {</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> ((a[left] &lt;= a[keyi])&amp;&amp;(left&lt;right))</span><br><span class="line">        {</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        Swap(&amp;a[left], &amp;a[right]);</span><br><span class="line">    }</span><br><span class="line">    Swap(&amp;a[left],&amp;a[keyi]);</span><br><span class="line">    keyi = left;<span class="comment">//必须移动keyi的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归排序左右区间</span></span><br><span class="line">    QuickSort1(a, begin, keyi<span class="number">-1</span>);</span><br><span class="line">    QuickSort1(a, keyi + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="4-2-2-挖坑法"><a href="#4-2-2-挖坑法" class="headerlink" title="4.2.2. 挖坑法"></a>4.2.2. 挖坑法</h4><p>挖坑法的思路比Hoare更好理解，详情见👇动图</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241345343.gif" alt="挖坑法"></p><p>我们先用一个变量保存key的值（不是保存下标），然后R先走找比key小的，与坑位交换，L找比key大的，与坑位交换。最终LR相遇的时候，把key放回相遇位置，就完成了一趟排序</p><blockquote><p>注意：图中为了便于理解，将<strong>坑位用空白</strong>表示。实际在内存中操作的时候，坑位可以一直是key的值，不需要真的把它移走或者删除</p></blockquote><p>怎样？是不是比方法1好理解一些呢？</p><p>下面给出挖坑法的代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挖坑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = begin, right = end;</span><br><span class="line">    <span class="type">int</span> keyi = a[begin];<span class="comment">//先存放keyi的值</span></span><br><span class="line">    <span class="type">int</span> pit = begin;<span class="comment">//pit作为坑位</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span> ((a[right] &gt; keyi) &amp;&amp; (right &gt;= begin))</span><br><span class="line">        {</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        Swap(&amp;a[pit], &amp;a[right]);</span><br><span class="line">        pit = right;</span><br><span class="line">        <span class="keyword">while</span> ((a[left] &lt;= keyi) &amp;&amp; (left &lt; right))</span><br><span class="line">        {</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        Swap(&amp;a[pit], &amp;a[left]);</span><br><span class="line">        pit = left;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    QuickSort2(a, begin, pit - <span class="number">1</span>);</span><br><span class="line">    QuickSort2(a, pit + <span class="number">1</span>, end);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="4-2-3-前后指针法"><a href="#4-2-3-前后指针法" class="headerlink" title="4.2.3. 前后指针法"></a>4.2.3. 前后指针法</h4><h5 id="4-2-3-1-基本实现"><a href="#4-2-3-1-基本实现" class="headerlink" title="4.2.3.1. 基本实现"></a>4.2.3.1. 基本实现</h5><p>这部分就不画动图了，不知下面的这种方式能不能讲解清楚呢？</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241442819.png" alt="image-20220424144222726"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241444345.png"></p><p>这里需要弄明白的是cur和prev是分别在什么情况下移动</p><ul><li>cur比key<strong>小</strong>的时候，prev往后++一位，二者交换（在刚开始的时候是原地交换，但在图4中就不是原地交换了）</li><li>cur比key<strong>大</strong>的时候，prev不动，cur继续往后++，直到找到比key小的数或者越界后停止（如果找到比key小的，就执行上一步的交换）</li><li>最终cur越界了，交换prev和key的数据，一趟排序完成；</li><li>需要用递归来排序<strong>keyi之前的和keyi之后的</strong>，它们并不一定有序。</li></ul><p>下面给出前后指针法的代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的end是闭区间，需要传入数组size-1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort3</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span><span class="comment">//前后指针</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> keyi = begin;</span><br><span class="line">    <span class="comment">// 注意cur要从keyi的下一位开始遍历</span></span><br><span class="line">    <span class="type">int</span> prev = begin, cur = begin + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// end是闭区间，所以这里等于end也没有越界的</span></span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= end) </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span> ((a[cur] &lt; a[keyi]) &amp;&amp; (a[++prev] != a[cur]))</span><br><span class="line">        {</span><br><span class="line">            Swap(&amp;a[prev], &amp;a[cur]);</span><br><span class="line">        }</span><br><span class="line">        cur++;</span><br><span class="line">    }</span><br><span class="line">    Swap(&amp;a[prev], &amp;a[keyi]);</span><br><span class="line">    keyi = prev;</span><br><span class="line">	<span class="comment">// 因为我们定义的end是闭区间，所以需要传入keyi-1</span></span><br><span class="line">    QuickSort3(a, begin, keyi - <span class="number">1</span>);</span><br><span class="line">    QuickSort3(a, keyi + <span class="number">1</span>, end);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="4-2-3-2-优化极端情况"><a href="#4-2-3-2-优化极端情况" class="headerlink" title="4.2.3.2. 优化极端情况"></a>4.2.3.2. 优化极端情况</h5><p><a href="#jump">上面</a>提到了快速排序有两种极端情况，我们可以用一个操作来优化它：</p><p>既然key取数组首或尾部都可能会遇到它的后面没有比它小（或大）的数，那我们就让key尽量作为数组有序后应该处于中部的数来作为key</p><p>这时候不能直接选取待排序数组中部的数，因为它不一定是数值正好的那个</p><p>我们可以选取数组<strong>开头、末尾、中间的3个数进行比较</strong>，再选择这3个数里面<strong>居中</strong>的那个数作为我们的key，这样就能避免无效遍历！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetMid</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[left] &lt; a[mid])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; a[right]){</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[left] &gt; a[right]){</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// a[left] &gt; a[mid]</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; a[right]){</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[left] &lt; a[right]){</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//其实这个没啥意义</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>但是单纯加上这个代码并不可行，因为这时候的key不再处于序列开头了，也就意味这我们后头的代码都需要重新写一遍！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241413267.png" alt="image-20220424141305225"></p><p>这不坑爹吗这是？！</p><p>为了不没事找事重写一遍代码，这里直接把找到的<strong>mid和begin进行交换</strong>就OK了！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241415619.png" alt="image-20220424141554572"></p><p>修改后的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// end是闭区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span>*a, <span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(begin &gt;= end){</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 三个数字找中间的哪一个作为keyi，避免cur匹配的时候一直找不到比keyi小的数</span></span><br><span class="line">    <span class="type">int</span> keyi = <span class="built_in">GetMidIndex</span>(a,begin,end);</span><br><span class="line">    <span class="comment">// 将keyi和begin交换，后续的代码就不需要修改</span></span><br><span class="line">    <span class="built_in">Swap</span>(&amp;a[keyi],&amp;a[begin]);</span><br><span class="line"></span><br><span class="line">    keyi = begin;</span><br><span class="line">    <span class="type">int</span> cur = begin+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> prev = begin;</span><br><span class="line">    <span class="keyword">while</span>(cur &lt;= end)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>((a[cur] &lt; a[keyi]) &amp;&amp; (a[++prev] != a[cur])){</span><br><span class="line">            <span class="built_in">Swap</span>(&amp;a[cur],&amp;a[prev]);</span><br><span class="line">        }</span><br><span class="line">        cur++;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Swap</span>(&amp;a[keyi],&amp;a[prev]);</span><br><span class="line">    keyi = prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">QuickSort</span>(a,begin,keyi<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(a,keyi+<span class="number">1</span>,end);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>同时，为了避免多次递归<strong>导致栈溢出</strong>，我们还可以设置一个条件，在序列长度小于10的时候调用其他排序（比如插入排序）来实现后面的排序操作。</p><h4 id="4-2-4-快排的时间-x2F-空间复杂度"><a href="#4-2-4-快排的时间-x2F-空间复杂度" class="headerlink" title="4.2.4. 快排的时间/空间复杂度"></a>4.2.4. 快排的时间/空间复杂度</h4><p>快排的递归调用非常类似链式二叉树的前序遍历，它一共会递归<code>logN</code>层级，每一层加起来都有N个数，这样就能算出它的时间复杂度</p><ul><li>时间复杂度：<code>O(N*logN)</code></li><li>空间复杂度：O(logN)，这个是递归开辟栈帧的空间消耗</li></ul><h3 id="4-3-快排非递归实现"><a href="#4-3-快排非递归实现" class="headerlink" title="4.3. 快排非递归实现"></a>4.3. 快排非递归实现</h3><p>这部分的知识就比较深奥了，你可以先看看这篇博客，了解一下函数调用的时候会发生什么👉<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123288455">传送门</a></p><blockquote><p>但不要担心，其实它的思路并没有那么难！</p></blockquote><p>首先需要先搞明白，递归调用的本质是在操作什么？</p><p>在快排中，递归调用的本质是让程序<strong>自己来缩小排序的范围，再逐步扩大</strong></p><p>那我们可不可以利用<strong>数据结构中的栈</strong>，来模拟实现程序运行中的递归操作呢？</p><ul><li>排序完一趟后，将下一趟的左右范围入栈</li><li>程序先调用存放在<strong>栈顶</strong>的右边范围进行排序，并把这个范围的左右小区间再次入栈</li><li>最后右边的区间已经不可再分，就开始返回调用左边区间</li></ul><p>这个操作就犹如链式二叉树的后序遍历，先递归访问右节点，再往回返回左节点</p><p>最后得到的结果就是类似递归调用完毕后的结果</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241526140.png" alt="image-20220424152639099"></p><blockquote><p>如果你还没有学习数据结构里面的栈，<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123760510">点我速览</a>！</p></blockquote><p>下面给出一个非递归的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort4</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">{</span><br><span class="line">    Stack st;</span><br><span class="line">    StackInit(&amp;st);</span><br><span class="line">    StackPush(&amp;st, begin);</span><br><span class="line">    StackPush(&amp;st, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(&amp;st))</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> right = StackTop(&amp;st);</span><br><span class="line">        StackPop(&amp;st);</span><br><span class="line">        <span class="type">int</span> left = StackTop(&amp;st);</span><br><span class="line">        StackPop(&amp;st);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> keyi = PartSort3(a, left, right);</span><br><span class="line">        <span class="comment">// [left,keyi-1][keyi+1，right]</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; keyi<span class="number">-1</span>)</span><br><span class="line">        {</span><br><span class="line">            StackPush(&amp;st, left);</span><br><span class="line">            StackPush(&amp;st, keyi<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keyi + <span class="number">1</span> &lt; right)</span><br><span class="line">        {</span><br><span class="line">            StackPush(&amp;st, keyi+<span class="number">1</span>);</span><br><span class="line">            StackPush(&amp;st, right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    StackDestory(&amp;st);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>注意：因为这里需要得到一趟递归调用后<strong>返回的keyi</strong>，所以我们需要把之前写的<strong>一趟快排</strong>单独拿出来，并设置返回值</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241535401.png" alt="image-20220424153520330"></p><p>来调用一下试试，成功了！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204241536895.png" alt="image-20220424153658856"></p><hr><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p><strong>基本思想</strong>：采用分治递归，将已有的子序列合并，得到一个有序的序列。即先使每个子序列有序，再使子序列段间有序</p><ul><li>若将<strong>两个</strong>有序表合并成一个有序表，称为<strong>二路归并</strong></li></ul><p>实现的步骤如下图</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204242227495.png" alt="image-20220424222741365"></p><ul><li>先将区间通过递归分割成<strong>分治末端</strong>（只有一个值）</li><li>再对相邻两个区间进行比较，开辟一个新的数组，依次将两个区间中<strong>小</strong>的那个按顺序摆放在新的数组中，再拷贝回原数组，就实现了归并</li><li>当区间不存在的时候，开始返回递归，直到序列有序</li></ul><h3 id="5-1-打印printf调试大法"><a href="#5-1-打印printf调试大法" class="headerlink" title="5.1. 打印printf调试大法"></a>5.1. 打印printf调试大法</h3><p>这里最需要注意的就是分治的序列区间问题，如果代码不对，就很容易形成<strong>越界访问</strong>！</p><p>这里我们可以通过<code>printf调试大法</code>来实现，打印出每一层递归时的区间，就能发现可能存在的<strong>越界访问</strong>问题。这种方法还能帮助我们理解<strong>分治递归</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d,%d][%d,%d]\n"</span>, begin, mid, mid+<span class="number">1</span>, end);</span><br></pre></td></tr></table></figure><blockquote><p>如果你在写程序的时候，发现弹出的控制台的光标闪动了很久都没有打印出数据，那么多半是程序中有<strong>死循环和bug</strong>。需要返回代码中debug定位问题。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204242314760.gif" alt="GIF"></p></blockquote><p>比如现在，我们初步查看递归调用中是没有出现越界的，但是答案错误，进一步调试发现，tmp数组中有序数字，并没有被我们完整的拷贝回去。</p><p>原本是<code>2 5</code>拷贝回去变成了<code>2 2</code>，这个问题的根源很明显是memcpy函数调用有问题</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204242304381.png" alt="image-20220424230425270"></p><p>一看，哭笑不得，写了俩sizeof，魔怔了属于是</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204242306592.png" alt="image-20220424230621551"></p><p>修改之后，没问题啦！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204242307428.png" alt="image-20220424230718378"></p><hr><h3 id="5-2-递归源码"><a href="#5-2-递归源码" class="headerlink" title="5.2. 递归源码"></a>5.2. 递归源码</h3><p>这里给出最终的源码，一些地方写了注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_代表这是子函数</span></span><br><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span>* a,<span class="type">int</span>* tmp, <span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    _MergeSort(a, tmp, begin, mid);</span><br><span class="line">    _MergeSort(a, tmp, mid+<span class="number">1</span> , end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("归并[%d,%d][%d,%d]\n", begin, mid, mid+1, end);</span></span><br><span class="line">    <span class="type">int</span> begin1 = begin, end1 = mid ;</span><br><span class="line">    <span class="type">int</span> begin2 = mid+<span class="number">1</span> , end2 = end;</span><br><span class="line">    <span class="type">int</span> cur = begin;</span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//取小的放到新数组中</span></span><br><span class="line">        <span class="keyword">if</span> (a[begin1] &lt; a[begin2]) {</span><br><span class="line">            tmp[cur++] = a[begin1++];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            tmp[cur++] = a[begin2++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个循环结束，并不代表归并完毕，可能只有一个数组的数据跑完了</span></span><br><span class="line">    <span class="comment">//我们需要将另外一个数组的数据全部拷贝到tmp中（因为剩下的的数据已经有序）</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1) {</span><br><span class="line">        tmp[cur++] = a[begin1++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2) {</span><br><span class="line">        tmp[cur++] = a[begin2++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(a+begin,tmp + begin, ((end - begin +<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>)));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(tmp==<span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _MergeSort(a, tmp, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="5-3-非递归实现"><a href="#5-3-非递归实现" class="headerlink" title="5.3. 非递归实现"></a>5.3. 非递归实现</h3><p>归并排序的非递归无法用<strong>栈</strong>来实现，因为我们不能把之前的<strong>大区间</strong>全给出栈了，因为这些区域还需要在最后重新进行归并！</p><ul><li>利用循环来控制不同的区间，由小到大，直到<code>gap=n</code>跳出循环</li><li>gap是归并数据的个数，gap=1代表1个数归并，gap=2代表两两归并</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204250934315.png" alt="image-20220425093418208"></p><p>根据上面的思路，我们可以写出下面的范围循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 间距为gap是一组，两两归并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//i+gap是个数，再-1是下标</span></span><br><span class="line">        <span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//i+gap到i+2gap是个数，再-1是下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印调试大法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"归并[%d,%d][%d,%d] -- gap=%d\n"</span>, begin1, end1, begin2, end2, gap);</span><br><span class="line">    }</span><br><span class="line">    gap *= <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>跑一遍之前的测试用例，发现能搞定！这不就完事了吗？</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204250947362.png" alt="image-20220425094754302"></p><p>并没有！这里gap的操作都是<code>*2</code>，而且我们给的数组是偶数个，正好对的上</p><p>如果我们再加一个数呢？程序打印出了每一层的递归区间，但是没有打印出最终的结果——因为这里在最后<code>free</code>的时候发现了<strong>数组越界访问</strong></p><blockquote><p>小知识，数组越界一般都是在free的时候检查到的</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251012497.png" alt="image-20220425101224451"></p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204250952347.png" alt="image-20220425095240283"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204250959296.png" alt="image-20220425095947193"></p><p>接下来要做的事就是控制下标区间，避免它越界</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>begin</th><th>end</th></tr></thead><tbody><tr><td>i</td><td>i+gap-1</td></tr><tr><td>i+gap</td><td>i+2*gap-1</td></tr></tbody></table><p>仔细分析过后，发现当<code>gap=2,i=8</code>的时候，就会出现+gap之后越界的情况</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251005867.png" alt="image-20220425100539742"></p><p>而会出现越界情况的，不止有end2，end1和begin2都可能会出现</p><p>我们需要做的就是把越界的下标<strong>修正为不越界的</strong>下标</p><ul><li>end1越界，修正为不越界即可</li><li>begin2和end2都越界，修正为非法区间<code>begin2&gt;end2</code></li><li>begin2不越界，end2越界，修正end2即可</li></ul><p>修正下标后，可以看到程序已经正常排序出了序列</p><p>虽然打印出来的范围还是有越界的下标，但是这个是<code>begin&gt;end</code>的<strong>非法区间</strong>，不符合程序运行的条件，就不会产生越界</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251019242.png" alt="image-20220425101925149"></p><h4 id="5-3-1-条件断点"><a href="#5-3-1-条件断点" class="headerlink" title="5.3.1. 条件断点"></a>5.3.1. 条件断点</h4><p>这里还有一个骚操作，比如我们已经知道了是8-9的下标越界，这样我们就可以设置一个<strong>断点</strong>，来直接F5跳到那个情况，而不需要<strong>疯狂按F10</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件断点，用于调试</span></span><br><span class="line"><span class="keyword">if</span> (begin1 == <span class="number">8</span> &amp;&amp; end1 == <span class="number">9</span> &amp;&amp; begin2 == <span class="number">10</span> &amp;&amp; end2 == <span class="number">11</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="5-3-2-非递归实现代码"><a href="#5-3-2-非递归实现代码" class="headerlink" title="5.3.2. 非递归实现代码"></a>5.3.2. 非递归实现代码</h4><p>这样我们的非递归实现也搞定啦！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 间距为gap是一组，两两归并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;<span class="comment">//i+gap是个数，-1是下标</span></span><br><span class="line">            <span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;<span class="comment">//i+gap到i+2gap是个数，-1是下标</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (end1 &gt;= n) {</span><br><span class="line">                end1 = n - <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(begin2&gt;=n){</span><br><span class="line">                begin2 = n;</span><br><span class="line">                end2 = n - <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (begin2 &lt; n &amp;&amp; end2 &gt;= n) {</span><br><span class="line">                end2 = n - <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//printf("归并[%d,%d][%d,%d] -- gap=%d\n", begin1, end1, begin2, end2, gap);</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> index = i;</span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">                    tmp[index++] = a[begin1++];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp[index++] = a[begin2++];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">                tmp[index++] = a[begin1++];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">                tmp[index++] = a[begin2++];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">memcpy</span>(a, tmp, n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        gap *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="5-4-归并排序的时间-x2F-空间复杂度"><a href="#5-4-归并排序的时间-x2F-空间复杂度" class="headerlink" title="5.4. 归并排序的时间/空间复杂度"></a>5.4. 归并排序的时间/空间复杂度</h3><ul><li>时间复杂度：<code>O(N*logN)</code></li><li>空间复杂度：<code>O(N)</code>，创建数组的消耗</li></ul><hr><h2 id="6-计数排序"><a href="#6-计数排序" class="headerlink" title="6. 计数排序"></a>6. 计数排序</h2><p>计数排序的<strong>基本思路</strong>：利用数组的下标作为映射，遍历到x，在数组的x下标处++一次。最后再依照下标顺序将之前遍历到的数倒出来，就形成了正序序列。</p><p>我在<strong>网上</strong>找来了一个很棒的动图（这个好像在很多博客里面都有😂）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251026710.gif" alt="计数排序"></p><blockquote><p>这个排序的思路就不难了，但有一点我们可以优化一下</p></blockquote><p>假设我们的序列是从300开始，而不是从0开始，那么开辟一个301个数的数组显然会浪费300之前的下标（因为并没有值）</p><p>这时候我们可以找出数组的范围，开辟一个对应范围长度的数组，再利用相对映射的方式，来进行计数</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251033755.png" alt="image-20220425103313697"></p><p>最后的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CountSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> min = a[<span class="number">0</span>], max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">            min = a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* count = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * range);</span><br><span class="line">    assert(count);</span><br><span class="line">    <span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * range);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    {</span><br><span class="line">        count[a[i] - min]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span> (count[i]--)</span><br><span class="line">        {</span><br><span class="line">            a[j++] = i + min;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="6-1-计数排序的特性"><a href="#6-1-计数排序的特性" class="headerlink" title="6.1. 计数排序的特性"></a>6.1. 计数排序的特性</h3><ul><li>时间复杂度：O(range+N)</li><li>空间复杂度：O(range)</li></ul><p>计数排序适用于范围集中的数，不然会产生很大的空间浪费</p><p>计数排序可以排序<strong>带负数</strong>的序列，同样是通过映射的方式</p><p>但是计数排序只能<strong>排序整型数据</strong>，浮点类型是搞不定的</p><hr><p>看到这里，我们的八大排序就已经讲解完毕啦！</p><p>不知道我讲解的够不够清楚呢？</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251038074.jpg" alt="QQ图片20220425092846"></p><p>下面还有一个小点，就是关于排序算法的<strong>稳定性</strong></p><h2 id="7-排序算法的稳定性"><a href="#7-排序算法的稳定性" class="headerlink" title="7. 排序算法的稳定性"></a>7. 排序算法的稳定性</h2><p>估计很多人和我一样，都对这个“稳定性”有错误的理解</p><p>我本来以为，稳定性代表的是排序算法的<strong>时间波动</strong>大不大</p><p>实际上的稳定性，是算法对于<strong>某一个数</strong>的处理好不好；</p><p>比如下图，假设大家在考试，从上到下依次是交卷的顺序，我们发现王舞和李四的成绩相同，但是李四先交的卷。对于评判来说，当然是<code>先交卷且分高的</code>同学牛逼一点</p><p>所以依照分数排序的时候，我们应该把李四排在王舞之前（即相同的数据在排序前后的位置不被改变）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251041817.png" alt="image-20220425104144768"></p><p>但有些算法在排序的时候，就做不到这一点</p><p>这里对<strong>直接选择排序</strong>做一个简单的解释</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251049368.png" alt="image-20220425104914317"></p><p>因为两个3的位置调换，就导致排序不够稳定</p><p>实际上，所有需要进行<strong>选择交换</strong>的排序都不够稳定</p><blockquote><p>但是冒泡排序在交换的时候是严格保证大的数在后头，<strong>相等的数不交换</strong>的思路，所以冒泡排序是稳定的</p></blockquote><h3 id="7-1-稳定性表格"><a href="#7-1-稳定性表格" class="headerlink" title="7.1. 稳定性表格"></a>7.1. 稳定性表格</h3><table><thead><tr><th>排序算法</th><th>稳定性</th><th>排序算法</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入</td><td>稳定</td><td>希尔</td><td>不稳定</td></tr><tr><td>冒泡</td><td>稳定</td><td>直接选择</td><td>不稳定</td></tr><tr><td>归并排序</td><td>稳定</td><td>堆排序</td><td>不稳定</td></tr><tr><td>-</td><td>-</td><td>快速排序</td><td>不稳定</td></tr><tr><td>-</td><td>-</td><td>计数排序</td><td>不稳定</td></tr></tbody></table><h3 id="7-2-时间复杂度表格"><a href="#7-2-时间复杂度表格" class="headerlink" title="7.2. 时间复杂度表格"></a>7.2. 时间复杂度表格</h3><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6426b4fa56840.png"></p><h2 id="8-利用clock函数查看排序耗时"><a href="#8-利用clock函数查看排序耗时" class="headerlink" title="8. 利用clock函数查看排序耗时"></a>8. 利用clock函数查看排序耗时</h2><p>排序算法写完后，我们可以通过调用clock函数来查看每一个排序的耗时</p><p>先利用<code>srand和time</code>函数来创建随机数数组，在调用每一个函数，来查看它们排序的耗时</p><p></p><p>由于代码过长，这里只给出某一个排序的计时代码，其他就<code>CV</code>一下就OK了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span>* a1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">{</span><br><span class="line">    a1[i] = rand();<span class="comment">//生成随机数 数组</span></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> begin1 = clock();<span class="comment">//读取系统时钟</span></span><br><span class="line">InsertSort(a1, N);</span><br><span class="line"><span class="type">int</span> end1 = clock();<span class="comment">//再读取系统时钟</span></span><br><span class="line"><span class="comment">//二者相减得出该函数运行时长</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InsertSort:%d\n"</span>, end1 - begin1);</span><br><span class="line"><span class="built_in">free</span>(a1);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251104224.png" alt="image-20220425110430139"></p><h2 id="9-std的sort采用了什么排序算法？"><a href="#9-std的sort采用了什么排序算法？" class="headerlink" title="9. std的sort采用了什么排序算法？"></a>9. std的sort采用了什么排序算法？</h2><p>后续C++的学习中，我们会接触到一个std提供的排序函数<code>std::sort</code>，虽然一般把它认为是std中提供的快排，但本质上<code>std::sort</code>做了更多的优化处理。</p><p>要知道，快排算法在最差的情况下可能是会退化成<code>O(N^2)</code>的时间复杂度的，这对于大规模数量级排序的影响还是很大的，所以<code>std::sort</code> 底层采用的排序算法并不仅仅是快速排序，而是根据不同情况选择了不同的排序算法。具体来说，<code>std::sort</code> 通常使用了一种叫做 <strong>Introsort</strong> 的混合排序算法。Introsort 是一种结合了快速排序、堆排序和插入排序的混合算法，目的是提高在最坏情况下的性能，并利用插入排序在小规模数据集上的优势。</p><p>Introsort结合了三种本文提到过的排序算法：</p><ol><li><strong>快速排序</strong>: 初始情况下，<code>std::sort</code> 使用快速排序对数据进行排序。快速排序是一种分治算法，通过选择一个“枢轴”元素，将数据分为两部分，其中一部分的元素小于枢轴，另一部分的元素大于枢轴。然后递归地对这两部分分别排序。</li><li><strong>堆排序</strong>: 如果递归的深度超过一定限度（通常是 <code>2*log(n)</code>），则 <code>std::sort</code> 会切换到堆排序。堆排序在最坏情况下的时间复杂度是 <code>O(n*log(n))</code>，从而避免了快速排序在最坏情况下可能出现的 <code>O(n^2)</code> 的性能问题。</li><li><strong>插入排序</strong>: 当待排序的子数组长度比较小时（通常是长度小于16的时候），<code>std::sort</code> 会切换到插入排序，因为插入排序在小规模数据集上的效率通常更高。</li></ol><p>通过这种多个排序算法的组合，<code>std::sort</code> 能够在大多数情况下提供近乎线性的性能（线性的意思就是排序算法的时间复杂度不出现影响数量级的变化），同时在最坏情况下避免性能退化。</p><h2 id="10-结语"><a href="#10-结语" class="headerlink" title="10. 结语"></a>10. 结语</h2><p>到这里，排序的绝大数知识点就讲解完毕啦！</p><p>本篇博客画了很多图，还挺不容易的，还请大家点赞支持一下！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251053471.png" alt="image-20220425105301408"></p><p>特别是那两个看起来很简单的动图，实际上<strong>麻烦</strong>的很</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251054302.png" alt="image-20220425105414115"></p><p>球球了，点个赞呐！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204251055973.jpg" alt="QQ图片20220416195218"></p><p></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/3996153794/">https://blog.musnow.top/posts/3996153794/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm22.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1070210667/" title="【C++】凝视C++的第一眼"><img class="cover" src="/img/bg/gm6.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【C++】凝视C++的第一眼</div></div></a></div><div class="next-post pull-right"><a href="/posts/2733996002/" title="【树莓派】实验12-PCF8591模数转换器"><img class="cover" src="/img/bg/gm4.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【树莓派】实验12-PCF8591模数转换器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1953150880/" title="【C语言】冒泡排序"><img class="cover" src="/img/bg/gm15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-25</div><div class="title">【C语言】冒泡排序</div></div></a></div><div><a href="/posts/3906762122/" title="【算法】算法的空间复杂度和时间复杂度"><img class="cover" src="https://img.musnow.top/i/2023/02/image-20220313113801204.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-13</div><div class="title">【算法】算法的空间复杂度和时间复杂度</div></div></a></div><div><a href="/posts/2793401961/" title="【C语言】单链表太难学不懂？看这一篇就够了"><img class="cover" src="/img/bg/gm7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">【C语言】单链表太难学不懂？看这一篇就够了</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">408</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">2. 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5"><span class="toc-text">2.1. 直接插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">2.2. 希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">3. 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9"><span class="toc-text">3.1. 直接选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">3.2. 堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-text">4. 、交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%92%95%E5%99%9C%E5%92%95%E5%99%9C%E6%8E%92%E5%BA%8F"><span class="toc-text">4.1. 咕噜咕噜排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">4.2. 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-Hoare%E6%B3%95"><span class="toc-text">4.2.1. Hoare法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-1-%E4%B8%A4%E7%A7%8D%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5"><span class="toc-text">4.2.1.1. 两种极端情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E6%8C%96%E5%9D%91%E6%B3%95"><span class="toc-text">4.2.2. 挖坑法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">4.2.3. 前后指针法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-1-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2.3.1. 基本实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-2-%E4%BC%98%E5%8C%96%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5"><span class="toc-text">4.2.3.2. 优化极端情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E5%BF%AB%E6%8E%92%E7%9A%84%E6%97%B6%E9%97%B4-x2F-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">4.2.4. 快排的时间&#x2F;空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%BF%AB%E6%8E%92%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.3. 快排非递归实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">5. 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%89%93%E5%8D%B0printf%E8%B0%83%E8%AF%95%E5%A4%A7%E6%B3%95"><span class="toc-text">5.1. 打印printf调试大法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%80%92%E5%BD%92%E6%BA%90%E7%A0%81"><span class="toc-text">5.2. 递归源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.3. 非递归实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-text">5.3.1. 条件断点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-text">5.3.2. 非递归实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4-x2F-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">5.4. 归并排序的时间&#x2F;空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">6. 计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">6.1. 计数排序的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-text">7. 排序算法的稳定性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%A8%B3%E5%AE%9A%E6%80%A7%E8%A1%A8%E6%A0%BC"><span class="toc-text">7.1. 稳定性表格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8%E6%A0%BC"><span class="toc-text">7.2. 时间复杂度表格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%88%A9%E7%94%A8clock%E5%87%BD%E6%95%B0%E6%9F%A5%E7%9C%8B%E6%8E%92%E5%BA%8F%E8%80%97%E6%97%B6"><span class="toc-text">8. 利用clock函数查看排序耗时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-std%E7%9A%84sort%E9%87%87%E7%94%A8%E4%BA%86%E4%BB%80%E4%B9%88%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">9. std的sort采用了什么排序算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%BB%93%E8%AF%AD"><span class="toc-text">10. 结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2869712310/" title="【win】windows部署minio，实现内网S3同步思源">【win】windows部署minio，实现内网S3同步思源</a><time datetime="2024-08-24T00:40:27.000Z" title="发表于 2024-08-24 08:40:27">2024-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2798538265/" title="【C++】单元测试覆盖率工具lcov的使用（未完待续）">【C++】单元测试覆盖率工具lcov的使用（未完待续）</a><time datetime="2024-08-22T22:40:38.000Z" title="发表于 2024-08-23 06:40:38">2024-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1431516729/" title="【leetcode】44.通配符匹配">【leetcode】44.通配符匹配</a><time datetime="2024-08-18T07:22:47.000Z" title="发表于 2024-08-18 15:22:47">2024-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/266952207/" title="【leetcode】10.正则表达式匹配">【leetcode】10.正则表达式匹配</a><time datetime="2024-08-18T01:49:42.000Z" title="发表于 2024-08-18 09:49:42">2024-08-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>