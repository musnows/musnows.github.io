<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【C++】快速学习类和对象，看这一篇就够了 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本篇博客是学校大一下C++期末考察的要求，包含了C++中类和对象的大部分内容，适合学习类和对象的你观看。最后还有两个小项目，综合了绝大部分类和对象的知识，很适合练手+深化学习。"><meta property="og:type" content="article"><meta property="og:title" content="【C++】快速学习类和对象，看这一篇就够了"><meta property="og:url" content="https://blog.musnow.top/posts/3040822590/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="本篇博客是学校大一下C++期末考察的要求，包含了C++中类和对象的大部分内容，适合学习类和对象的你观看。最后还有两个小项目，综合了绝大部分类和对象的知识，很适合练手+深化学习。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm9.jpg"><meta property="article:published_time" content="2022-05-30T06:50:25.000Z"><meta property="article:modified_time" content="2023-03-31T15:22:54.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Linux"><meta property="article:tag" content="C++"><meta property="article:tag" content="类和对象"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm9.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/3040822590/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【C++】快速学习类和对象，看这一篇就够了",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-03-31 23:22:54"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">283</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm9.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【C++】快速学习类和对象，看这一篇就够了</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-30T06:50:25.000Z" title="发表于 2022-05-30 14:50:25">2022-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-31T15:22:54.000Z" title="更新于 2023-03-31 23:22:54">2023-03-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%81%87%E8%A7%81C/">遇见C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【C++】快速学习类和对象，看这一篇就够了"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本篇博客是学校大一下C++期末考察的要求，包含了C++中<strong>类和对象</strong>的大部分内容，适合学习类和对象的你观看。最后还有两个小项目，综合了绝大部分类和对象的知识，很适合练手+深化学习。</p><span id="more"></span><p>为了避免被同校copy，本篇博客只在我的HEXO<strong>个人博客</strong>上发布</p><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-面向对象程序特点与目标"><a href="#1-1-面向对象程序特点与目标" class="headerlink" title="1.1 面向对象程序特点与目标"></a>1.1 面向对象程序特点与目标</h2><p>面向对象有下面几个特征：</p><ol><li>类与对象：把现实世界中的某一类东西，提取出来，用代码表示；</li><li>封装性：把过程和数据封装到一个包裹里面，对数据的访问只能通过公开权限的函数接口来进行操作；</li><li>继承性：一种联结类的层次模型，类似树状结构；</li><li>多态性：允许不同类的对象对同一消息做出响应，用不同的方法来解决一个问题。</li></ol><p>其中 <strong>封装、继承、多态</strong> 被称为面向对象的三大特性</p><p>通过这些特征，我们可以看得到，其实面向对象的程序也是在C语言的面向过程的基础上得来的。其目的也是为了更好的服务某一个具体的问题，并通过这个问题衍生出不同的解题方法，并用代码来表示解决一个问题对象的过程。</p><h2 id="1-2-面向对象程序知识架构"><a href="#1-2-面向对象程序知识架构" class="headerlink" title="1.2 面向对象程序知识架构"></a>1.2 面向对象程序知识架构</h2><p><img src="https://img.musnow.top/i/2023/02/202205271639621.png" alt="image-20220527163930508"></p><hr><h1 id="第二章-面向程序对象关键支撑技术"><a href="#第二章-面向程序对象关键支撑技术" class="headerlink" title="第二章 面向程序对象关键支撑技术"></a>第二章 面向程序对象关键支撑技术</h1><h2 id="2-1-类和对象"><a href="#2-1-类和对象" class="headerlink" title="2.1 类和对象"></a>2.1 类和对象</h2><p>类和对象与命名空间类似，都是存在一种封装。不同的是，类是对C语言struct结构体类型的拓。除了变量以外，类里面还可以定义成员函数，并设置它们的权限，实现了对一个接口的完整封装。</p><h3 id="2-1-1-构造函数"><a href="#2-1-1-构造函数" class="headerlink" title="2.1.1 构造函数"></a>2.1.1 构造函数</h3><p>众所周周知，当我们写<strong>C语言</strong>的顺序表、链表等代码的时候，一般都会写一个<code>Init</code>函数来初始化内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line">	size=<span class="number">0</span>;</span><br><span class="line">	capa=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样有一个缺点，就是不够智能，需要我们自己来调用它进行初始化。</p><p>于是C++就整出来了一个构造函数来解决这个问题</p><p><strong>特性</strong></p><p><strong>构造函数：名字和类名相同，创建类对象的时候编译器会自动调用，初始化类中成员变量，使其有一个合适的初始值。构造函数在对象的生命周期中只调用一次</strong></p><p>构造函数有下面几个特性：</p><ol><li>函数名和类名相同</li><li>无返回值</li><li>构造函数可以重载</li><li>对象实例化的时候，编译器会<strong>自动调用</strong>对应的构造函数</li><li>如果你自己不写构造函数，编译器会自己创建一个默认的构造函数</li></ol><h4 id="2-1-1-1基本使用"><a href="#2-1-1-1基本使用" class="headerlink" title="2.1.1.1基本使用"></a>2.1.1.1基本使用</h4><p>下面用一个队列来演示一下构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue Init&quot;</span>&lt;&lt;endl;<span class="comment">//测试是否调用</span></span><br><span class="line">        _a=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line">        _size=<span class="number">0</span>;</span><br><span class="line">        _capa=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;_size&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;capa: &quot;</span>&lt;&lt;_capa&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* _a;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    <span class="type">int</span> _capa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，在创建对象q1的时候，编译器就自动调用了类中的构造函数，帮我们初始化了这个队列</p><p><img src="https://img.musnow.top/i/2023/02/202205191902603.png" alt="image-20220519190214530"></p><hr><p>除了上面这种最基本的<strong>无参</strong>构造函数以外，一般写构造函数的时候，我们都会带一个有缺省值的参数，这样可以更好地灵活使用这个队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Queue</span>(<span class="type">int</span> Capacity=<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _a=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*Capacity);</span><br><span class="line">    _size=<span class="number">0</span>;</span><br><span class="line">    _capa=Capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这种构造函数也更加灵活，我们可以根据数据类型的长度，来创建不同容量的队列，避免多次<code>realloc</code>造成的内存碎片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue q1;<span class="comment">//调用无参的构造函数</span></span><br><span class="line"><span class="function">Queue <span class="title">q2</span><span class="params">(<span class="number">100</span>)</span></span>;<span class="comment">//调用带参的构造函数</span></span><br></pre></td></tr></table></figure><p>多种构造函数是可以同时存在的，不过！它们需要满足函数重载的基本要求</p><p>当你调用一个<strong>无参</strong>的函数，和一个<strong>全缺省</strong>的函数的时候，编译器会懵逼！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Queue</span>();</span><br><span class="line"><span class="built_in">Queue</span>(<span class="type">int</span> Capacity=<span class="number">4</span>);</span><br><span class="line"><span class="comment">//这两个函数不构成重载，会报错</span></span><br></pre></td></tr></table></figure><p>正确的重载应该是下面的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Queue</span>();</span><br><span class="line"><span class="built_in">Queue</span>(<span class="type">int</span> Capacity);</span><br></pre></td></tr></table></figure><p>编译器在创建对象的时候，就会智能选择这两个构造函数其中之一进行调用。但是同一个对象<strong>只会调用一个构造函数</strong>。</p><p>除了在构造函数内部初始化参数，我们还可以在<strong>初始化列表</strong>处进行操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Queue</span>(<span class="type">int</span> Capacity=<span class="number">4</span>)</span><br><span class="line">	:_a(<span class="keyword">new</span> <span class="type">int</span>[Capacity]),</span><br><span class="line">    _size(<span class="number">0</span>),</span><br><span class="line">    _capa(Capacity)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-2编译器默认生成的构造函数"><a href="#2-1-1-2编译器默认生成的构造函数" class="headerlink" title="2.1.1.2编译器默认生成的构造函数"></a>2.1.1.2编译器默认生成的构造函数</h4><p>上面提到过，如果我们不写构造函数，编译器会自己生成一个。</p><p>但测试过以后，你会发现，这个默认生成的构造函数，好像啥事都没有干——或者说，它把<code>_a _b _c</code> 都初始化成了随机值！</p><p><img src="https://img.musnow.top/i/2023/02/202205191918321.png" alt="image-20220519191815211"></p><p>实际上，编译器默认生成的构造函数是不会处理内置类型的</p><ul><li>内置类型：int、char、float、double……</li><li>外置类型：自定义类型（其他的类）</li></ul><p>在处理的时候，编译器忽略内置类型；外置类型会调用它的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//默认构造函数：不传参就能调用的</span></span><br><span class="line">    <span class="comment">//1.全缺省 2.无参 3.编译器自动生成</span></span><br><span class="line">    <span class="comment">//可以是半缺省的，但是不实用</span></span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year=<span class="number">2022</span>,<span class="type">int</span> month=<span class="number">2</span>,<span class="type">int</span> day=<span class="number">30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _year=year;</span><br><span class="line">        _month=month;</span><br><span class="line">        _day=day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;_year&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;_month&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;_day&lt;&lt;endl;</span><br><span class="line">        _A.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//编译器会自动生成构造函数（如果你没有自己写的话）</span></span><br><span class="line">    <span class="comment">//自动生成的构造函数是不会初始化内置类型的</span></span><br><span class="line">    <span class="comment">//内置类型：int,char,double等等</span></span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">    <span class="comment">//外置类型：自定义类型</span></span><br><span class="line">    <span class="comment">//外置类型会调用它自己的默认构造函数</span></span><br><span class="line">    Queue _A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，编译器调用了自己的构造函数的同时，还调用了外置类型<code>Queue</code>的构造函数，搞定了它的初始化</p><p><img src="https://img.musnow.top/i/2023/02/202205191923029.png" alt="image-20220519192352946"></p><p>如果我们去掉Date的构造函数，就能看到下面的情况。<code>Queue</code>成功初始化，但是内置类型的年月日都是随机值</p><p><img src="https://img.musnow.top/i/2023/02/202205191927840.png" alt="image-20220519192720777"></p><p>一般情况下一个C++类都需要自己写构造函数，下面这两个情况除外</p><ol><li>类里面的成员都是自定义类型成员（且有自己的构造函数）</li><li>如果还有内置类型成员，声明时给了缺省值</li></ol><p><strong>注：只有类在声明变量的时候才可以给缺省值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的情况就不需要写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      Queue q1;<span class="comment">//自定义类型</span></span><br><span class="line">      Queue q2;</span><br><span class="line">      <span class="type">int</span> a=<span class="number">1</span>;<span class="comment">//内置类型声明的时候给了缺省值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-3初始化列表"><a href="#2-1-1-3初始化列表" class="headerlink" title="2.1.1.3初始化列表"></a>2.1.1.3初始化列表</h4><p>除了上面的方式之外，还有一种构造函数的使用方式为初始化列表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year=<span class="number">2022</span>,<span class="type">int</span> month=<span class="number">2</span>,<span class="type">int</span> day=<span class="number">30</span>)</span><br><span class="line">    :_year(year),</span><br><span class="line">	_month(month),</span><br><span class="line">	_day(day)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>每个成员变量只能在初始化列表中出现一次</li><li>类中包含以下成员必须在初始化列表中进行初始化<ul><li>引用</li><li>const成员</li><li>自定义类型成员</li></ul></li></ul><p>一般情况下，建议使用初始化列表进行初始化。因为对于自定义类型的成员变量，初始化列表的优先级是高于<code>&#123; &#125;</code>里面的内容的。</p><p><font color="Red">这里还有非常重要的一点！</font></p><p>成员变量在类中声明的顺序就是初始化列表的顺序，而并非初始化列表自己的顺序！</p><ul><li>怎么理解呢？看下面这个代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year=<span class="number">2022</span>,<span class="type">int</span> month=<span class="number">2</span>,<span class="type">int</span> day=<span class="number">30</span>)</span><br><span class="line">    :_day(day),</span><br><span class="line">    _year(year),</span><br><span class="line">	_month(month)</span><br><span class="line">	</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即便我们把<code>_day</code>放在了初始化列表的首位，但由于它是在最后声明的。所以构造函数走初始化列表的时候，会依据声明顺序，依次初始化年、月、日。</p><ul><li>这会引起什么问题？再来看看一个错误示例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year=<span class="number">2022</span>,<span class="type">int</span> month=<span class="number">2</span>,<span class="type">int</span> day=<span class="number">30</span>)</span><br><span class="line">    :_day(day),</span><br><span class="line">    _year(year),</span><br><span class="line">	_month(_day)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们用上面这个初始化列表的时候，我们本意是想在初始化完<code>_day</code>以后，将<code>_day</code>的值赋给<code>_month</code>。但由于<code>_month</code>的声明顺序在<code>_day</code>之前，所以<code>_month(_day)</code>会先执行，此时的<code>_day</code>尚为随机值，这就导致月份变成随机值了！</p><blockquote><p>这只是一个示例，实际上肯定不会用天数初始化月数，范围不一样</p></blockquote><p>最好的办法，就是声明顺序和初始化列表的顺序保持一致！</p><h4 id="2-1-1-4-explicit关键字"><a href="#2-1-1-4-explicit关键字" class="headerlink" title="2.1.1.4 explicit关键字"></a>2.1.1.4 explicit关键字</h4><p>构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有隐式类型转换的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//正常的构造函数</span></span><br><span class="line">    <span class="comment">//Date(int year)</span></span><br><span class="line">    <span class="comment">//    :_year(year)</span></span><br><span class="line">    <span class="comment">//    &#123;&#125;</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Date</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function">        :_year(year)</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month:</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 用一个整形变量给日期类型对象赋值</span></span><br><span class="line">    <span class="comment">// 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值</span></span><br><span class="line">    d1 = <span class="number">2019</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用赋值的时候，实际上编译器会先用2019构造出一个date类型对象，再调用赋值重载（这里还没有写）赋值给d1。这就是一个隐式类型转换</p><p>如果我们用<code>explicit</code>修饰了这个构造函数，那么编译器将不会进行此类隐式类型转换！</p><hr><h3 id="2-1-2-拷贝构造函数"><a href="#2-1-2-拷贝构造函数" class="headerlink" title="2.1.2 拷贝构造函数"></a>2.1.2 拷贝构造函数</h3><h4 id="2-1-2-1特性和使用"><a href="#2-1-2-1特性和使用" class="headerlink" title="2.1.2.1特性和使用"></a>2.1.2.1特性和使用</h4><p>拷贝构造是一个特殊的构造函数，它的参数是另外一个Date类型。在用已有的类类型对象来创建新对象的时候，由编译器自动调用</p><p>因为拷贝的时候我们不会修改d的内容，所以传的是<code>const</code>。另外，我们必须进行传引用调用！</p><p>如下面的这个函数，在传参的时候，编译器会去调用Date的拷贝构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure><p>如果你没有写拷贝构造，或者拷贝构造里面不是<strong>传引用</strong>，编译器会就递归不断创建新的<strong>对象</strong>进行值拷贝构造，程序就死循环辣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造，如果不写的时候，编译器会默认生成一个</span></span><br><span class="line">    <span class="comment">//对内置类型进行值拷贝(浅拷贝)</span></span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> Date&amp; d)</span><br><span class="line">    &#123;</span><br><span class="line">        _year=d._year;</span><br><span class="line">        _month=d._month;</span><br><span class="line">        _day=d._day;</span><br><span class="line">        <span class="comment">//外置类型会调用外置类型的拷贝构造</span></span><br><span class="line">        <span class="function">Queue <span class="title">b</span><span class="params">(_A)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和构造、析构不同的是，编译器自己生成的拷贝构造终于有点用了</p><ul><li>它会对内置类型进行按<strong>内存存储的字节序</strong>完成拷贝，这种称为值拷贝（又称<strong>浅拷贝</strong>）</li><li>对外置类型会调用它的构造函数</li></ul><h4 id="2-1-2-2深拷贝"><a href="#2-1-2-2深拷贝" class="headerlink" title="2.1.2.2深拷贝"></a>2.1.2.2深拷贝</h4><p><strong>外置类型拷贝问题</strong></p><p><font color="Red">但是！</font>如果你使用了外置类型，该类型中包含malloc的时候，编译器默认生成的构造函数就不能用辣！</p><p>因为这时候，编译器默认生成的拷贝构造会进行值拷贝，拷贝完了之后，就会出现q1和q2指向同一个空间的情况。<strong>修改q2会影响q1，free的时候多次释放同一个空间会报错，不符合我们的拷贝构造的要求</strong></p><p><img src="https://img.musnow.top/i/2023/02/202205192059798.png" alt="image-20220519205945585"></p><p>注意注意，malloc不行的原因是，数据是存在堆区里面，拷贝的时候，q2的<code>_a</code>得到的是一个地址，而不是拷贝了新的数据内容。</p><ul><li>如果你在类里面定义了一个<code>int arr[10]</code>数组，这时候拷贝构造就相当于<code>memcpy</code>，是可以完成拷贝的工作的</li><li>但是malloc和new创造的空间是在堆区上的，无法直接拷贝</li></ul><p>如何解决这个问题呢？我们需要使用深拷贝</p><hr><p><strong>了解new和delete</strong></p><p>从C语言转到C++，多了new和delete关键字，它们分别对应malloc和free</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>*p1=<span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//开辟一个int类型的空间</span></span><br><span class="line">    <span class="type">int</span>*p2=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//开辟一个int类型的空间，并初始化为10</span></span><br><span class="line">    <span class="type">int</span>*p3=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//开辟10个int类型的空间</span></span><br><span class="line">    <span class="comment">//注意后两个的括号区别！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> p1;<span class="comment">//销毁p1指向的单个空间</span></span><br><span class="line">    <span class="keyword">delete</span> p2;<span class="comment">//同上</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//delete p3;//销毁p3指向的第一个空间，不能用于数组</span></span><br><span class="line">    <span class="keyword">delete</span>[] p3;<span class="comment">//销毁p3指向的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝实现</strong></p><p>在上面写道过，编译器会自动生成拷贝构造函数，完成值拷贝工作。但是队列的代码里面包含<strong>堆区</strong>的空间，需要我们正确释放。这时候就需要自己写一个拷贝构造完成深拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp; q)</span><br><span class="line">&#123;</span><br><span class="line">    _a=<span class="keyword">new</span> <span class="type">int</span>[q._capa];<span class="comment">//注意解引用</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_a, q._a, q._capa*<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//拷贝内容</span></span><br><span class="line">    _size=q._size;</span><br><span class="line">    _capa=q._capa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用下面这个<strong>队列的代码</strong>来测试深拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue Init&quot;</span>&lt;&lt;endl;<span class="comment">//测试是否调用</span></span><br><span class="line">        <span class="comment">//_a=(int*)malloc(sizeof(int)*4);</span></span><br><span class="line">        _size=<span class="number">0</span>;</span><br><span class="line">        _capa=<span class="number">4</span>;</span><br><span class="line">        _a=<span class="keyword">new</span> <span class="type">int</span>[_capa];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; _capa;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _a[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp; q)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue Copy&quot;</span>&lt;&lt;endl;</span><br><span class="line">        _a=<span class="keyword">new</span> <span class="type">int</span>[q._capa];</span><br><span class="line">        <span class="built_in">memcpy</span>(_a, q._a, q._capa*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        _size=q._size;</span><br><span class="line">        _capa=q._capa;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;this:&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;_a:&quot;</span>&lt;&lt;_a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;_size&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;capa: &quot;</span>&lt;&lt;_capa&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; _capa;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;_a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//析构函数</span></span><br><span class="line">        <span class="comment">//free(_a);</span></span><br><span class="line">        <span class="keyword">delete</span>[] _a;</span><br><span class="line">        _a=<span class="literal">nullptr</span>;</span><br><span class="line">        _size=_capa=<span class="number">0</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;distory:&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* _a;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    <span class="type">int</span> _capa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue q1;</span><br><span class="line">    q1.<span class="built_in">Print</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    Queue q2=q1; </span><br><span class="line">    q2.<span class="built_in">Print</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝效果</strong></p><p>先注释掉<code>Queue</code>的拷贝构造函数析构函数（不然会报错）</p><p>看一看，发现在不写拷贝构造函数的时候，q2和q1的<code>_a</code>指向了同一个地址</p><p><img src="https://img.musnow.top/i/2023/02/202205201819231.png" alt="image-20220520181924194"></p><p>取消析构函数的注释，可以看到两次释放同一片空间，发生了报错</p><p><img src="https://img.musnow.top/i/2023/02/202205201819421.png" alt="image-20220520181921299"></p><p>如果我们把写好的<strong>深拷贝构造</strong>加上，就不会出现这个问题</p><p><img src="https://img.musnow.top/i/2023/02/202205201822071.png" alt="image-20220520182240029"></p><p>当你加上给<code>_a</code>里面初始化一些数据，以及打印<code>_a</code>数据的函数后，就可以看到，不仅q2的<code>_a</code>有了自己全新的地址，其内部的值也和q1一样了</p><p><img src="https://img.musnow.top/i/2023/02/202205201836040.png" alt="image-20220520183601995"></p><p>这样写出来的拷贝构造，即便把队列中的<code>int* _a</code>修改为<code>char*</code>或者其他类型，都能正确完成拷贝工作</p><p><img src="https://img.musnow.top/i/2023/02/202205201841901.png" alt="image-20220520184122834"></p><hr><h3 id="2-1-3-析构函数"><a href="#2-1-3-析构函数" class="headerlink" title="2.1.3 析构函数"></a>2.1.3 析构函数</h3><p>和构造函数相对应，析构函数是对象在<strong>出了生命周期</strong>后自动调用的函数，用来爆破对象里的成员（如进行free操作）</p><p>生命周期是离这个对象最近的<code>&#123; &#125;</code>括号</p><p><strong>特性</strong></p><ul><li>析构函数名是在类名前加<code>~</code></li><li>无参数，无返回值</li><li>一个类只能有一个析构函数</li><li>如果你没有自己写，编译器会自动生成一个析构函数</li></ul><p>和构造函数一样，编译器自己生成的析构函数不会处理内置类型；会调用外置类型的析构函数</p><p><strong>基本使用</strong></p><p>析构函数的定义和我们在外部写的<code>Destroy</code>函数一样，主要执行free（delete）操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue&quot;</span>&lt;&lt;endl;<span class="comment">//测试是否调用</span></span><br><span class="line">        _a=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line">        _size=<span class="number">0</span>;</span><br><span class="line">        _capa=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;_size&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;capa: &quot;</span>&lt;&lt;_capa&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//析构函数</span></span><br><span class="line">        <span class="built_in">free</span>(_a);</span><br><span class="line">        _a=<span class="literal">nullptr</span>;</span><br><span class="line">        _size=_capa=<span class="number">0</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;distory:&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;<span class="comment">//测试调用</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* _a;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    <span class="type">int</span> _capa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设我们在main函数里面定义了两个对象，你能说出q1和q2谁先进行析构函数的调用吗？</p><p><img src="https://img.musnow.top/i/2023/02/202205191953551.png" alt="image-20220519195337429"></p><p>可以看到，先调用的是q2的析构函数</p><p><img src="https://img.musnow.top/i/2023/02/202205191955188.png" alt="image-20220519195559016"></p><p>因为在底层操作中，编译器会给main函数开辟栈帧</p><p><strong>栈遵从后进先出的原则</strong>，q2是后创建的，所以在析构的时候会先析构</p><hr><h2 id="2-2-静态成员"><a href="#2-2-静态成员" class="headerlink" title="2.2 静态成员"></a>2.2 静态成员</h2><h3 id="2-2-1-静态数据成员"><a href="#2-2-1-静态数据成员" class="headerlink" title="2.2.1 静态数据成员"></a>2.2.1 静态数据成员</h3><p>和普通的成员变量不同，静态成员变量不属于某一个对象，而是属于整一个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="comment">//定义一个静态成员变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _a  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也因为这个特性，静态成员变量是不会被sizeof计入的</p><p>什么时候会用到静态成员变量？比如当我们需要计算一个类究竟开辟了多少个对象的时候。如果使用普通成员变量，它的值是属于某一个对象的，无法完成正确的count计数。使用静态成员变量后，该变量的值不会因为定义多个对象而被重置。这时候，我们就可以在构造函数和拷贝构造函数里面，使用<code>count++</code>，来实现<strong>对类开辟对象个数的统计</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">STU</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">STU</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">STU</span>(<span class="type">const</span> STU&amp; d)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//声明一个静态成员变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> count;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> STU::count=<span class="number">0</span>;<span class="comment">//必须要在类外定义</span></span><br></pre></td></tr></table></figure><p>这时候，每次对象创建都会让<code>conunt+1</code>，我们可以通过下面两种方式访问来得到<code>count</code>的值</p><ul><li>通过指定类域来访问，<code>STU::count</code></li><li>通过对象来访问，<code>STU s1; s1.count;</code></li></ul><p>如果想在类外直接访问静态成员变量，就不能用<code>private</code>，必须是公有权限</p><hr><h3 id="2-2-2-静态成员函数"><a href="#2-2-2-静态成员函数" class="headerlink" title="2.2.2 静态成员函数"></a>2.2.2 静态成员函数</h3><p>如果把静态成员变量定义为公有，那么外部的所有函数都可以通过类域或者对象来访问这个静态成员变量，这时候就不利于我们程序的封装。所以我们可以借助静态成员函数来<strong>访问私有的静态成员变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">STU</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">STU</span>() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">STU</span>(<span class="type">const</span> STU&amp; d)&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> STU::count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STU s1;    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;通过对象s1访问    &quot;</span>&lt;&lt;s1.<span class="built_in">GetCount</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;通过类域STU::访问 &quot;</span>&lt;&lt;STU::<span class="built_in">GetCount</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员函数有下面几个特点</p><ul><li>类静态成员即可用类名<code>::</code>静态成员或者对象.静态成员来访问</li><li>静态成员函数没有隐藏的this指针，不能访问任何非静态成员</li><li>静态成员和类的普通成员一样，也有public、protected、private三种访问级别</li><li>静态成员函数可以具有返回值</li></ul><hr><h2 id="2-3-常成员"><a href="#2-3-常成员" class="headerlink" title="2.3 常成员"></a>2.3 常成员</h2><h3 id="2-3-1-常数据成员"><a href="#2-3-1-常数据成员" class="headerlink" title="2.3.1 常数据成员"></a>2.3.1 常数据成员</h3><p>有一部分数据成员，是一个定值。比如我们定义了某一个学科的类<code>class MATH</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MATH</span>&#123;</span><br><span class="line">  <span class="type">int</span> piont=<span class="number">6.0</span>;<span class="comment">//数学的学分  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，作为一个学科，它的考试学分&#x2F;绩点是固定的。这时候我们不需要在后续修改这个学分的定义，就可以将它设置为const属性，避免被其他成员误修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MATH</span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> piont=<span class="number">6.0</span>;<span class="comment">//数学的学分  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和普通成员和静态成员变量不同的是</p><ul><li>常成员变量必须在声明的时候初始化</li><li>常成员变量不能在类外定义</li><li>常成员变量只能在构造函数的<strong>初始化列表阶段</strong>进行定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MATH</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MATH</span>()</span><br><span class="line">        :<span class="built_in">score</span>(<span class="number">6.0</span>)<span class="comment">//初始化列表处定义</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;score&lt;&lt;endl;<span class="comment">//打印测试</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> score=<span class="number">0</span>;<span class="comment">//必须在声明的时候定义初值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-常成员函数"><a href="#2-3-2-常成员函数" class="headerlink" title="2.3.2 常成员函数"></a>2.3.2 常成员函数</h3><p>const修饰的类成员函数称之为<code>const成员函数</code>，即常成员函数。const修饰类成员函数，实际修饰的是该成员函数隐含的<code>this指针</code>，表明在该成员函数中不能对类的任何成员进行修改。</p><p>基本的修饰方法如下，在函数的括号后加const即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;_year&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际修饰的是该函数隐含的this指针</p><p>this指针本身是<code>Date*const</code>类型的，修饰后变为<code>const Date* const</code>类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> Date* <span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;_year&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;_month&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;_day&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-1-实例-权限问题"><a href="#2-3-2-1-实例-权限问题" class="headerlink" title="2.3.2.1 实例-权限问题"></a>2.3.2.1 实例-权限问题</h4><p>这么说好像有点迷糊，我们用实例来演示一下为什么需要const修饰成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year=<span class="number">2022</span>,<span class="type">int</span> month=<span class="number">2</span>,<span class="type">int</span> day=<span class="number">30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _year=year;</span><br><span class="line">        _month=month;</span><br><span class="line">        _day=day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;_year&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;_month&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;_day&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设我们需要在函数中调用<code>Print</code>函数，在main中是可以正常调用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2022</span>,<span class="number">5</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    d1.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但当你用一个函数来进行这个操作的时候，事情就不一样了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TEST</span><span class="params">(<span class="type">const</span> Date&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	d.<span class="built_in">Print</span>();<span class="comment">//d.Print(&amp;d) --&gt;const Date*</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2022</span>,<span class="number">5</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    d1.<span class="built_in">Print</span>();<span class="comment">//d1.Print(&amp;d1) --&gt;Date*</span></span><br><span class="line">    <span class="built_in">TEST</span>(d1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们进行了引用调用，因为在TEST中我们不会修改d1的内容，所以用<code>const</code>进行了修饰</p><ul><li>这时候TEST中的<code>d.Print()</code>函数调用，传入的是<code>const Date*</code>指针，指针指向的内容不能被修改</li><li>main中的<code>d1.Print();</code>函数调用，传入的是<code>Date*</code>指针</li></ul><p>于是就会发生权限冲突问题：</p><p><img src="https://img.musnow.top/i/2023/02/202205201223994.png" alt="image-20220520122333913"></p><p>这时候如果我们在函数后面加了const，就可以避免此种权限放大问题。这样不管是main函数还是TEST函数中对<code>Print()函数</code>的调用，就都可以正常打印了！</p><p>总结一下：</p><ul><li>const对象<strong>不可以</strong>调用非const成员函数（权限放大）</li><li>非const对象<strong>可以</strong>调用const成员函数（权限缩小）</li><li>const成员函数内<strong>不可以</strong>调用其他非const成员函数（权限放大）</li><li>非const成员函数<strong>可以</strong>独调用其他const成员函数（权限缩小）</li></ul><h4 id="2-3-2-2-什么时候需要使用？"><a href="#2-3-2-2-什么时候需要使用？" class="headerlink" title="2.3.2.2 什么时候需要使用？"></a>2.3.2.2 什么时候需要使用？</h4><p>众所周周知，const修饰指针有下面两种形式</p><ul><li>在<code>*</code>之前修饰，代表该指针指向<strong>对象的内容</strong>不能被修改（地址里的内容不能改）</li><li>在<code>*</code>之后修饰，代表该指针<strong>指向的对象</strong>不能被修改（指向的地址不能改）</li></ul><p>this指针本身就是<code>类型名* const</code>类型的，它本身不能被修改。加上const之后，this指向的内容，既类里面的成员变量也不能被修改了。</p><p>知道了这一点后，我们可以合理的判断出：<strong>只要是需要修改类中成员变量的函数</strong>，就不需要在<code>()</code>后面加const修饰</p><p>如果一个函数中不需要修改成员变量，就可以加const进行修饰（最好加上，告知调用者该函数中不会修改成员变量）</p><p><font color="Red">注意：</font>如果你使用了声明和定义分离的写法来实现一个const成员函数，那么声明和定义的成员函数<strong>都需要加上const修饰</strong></p><h4 id="2-3-2-3-出错情况"><a href="#2-3-2-3-出错情况" class="headerlink" title="2.3.2.3 出错情况"></a>2.3.2.3 出错情况</h4><p>这里有一点需要提醒的是，如果你对某一个函数进行了const修饰，那么这个函数里面包含的其他类里面的函数，都需要进行const修饰。不然就会报错</p><p><img src="https://img.musnow.top/i/2023/02/202205221651621.png" alt="image-20220522165158500"></p><p>出现该报错的情况如下</p><p><img src="https://img.musnow.top/i/2023/02/202205221654279.png" alt="image-20220522165423213"></p><p>这个情况也提醒我们，<strong>不能在const修饰的函数中，调用非const修饰的成员函数</strong></p><hr><h2 id="2-4-常对象和常引用"><a href="#2-4-常对象和常引用" class="headerlink" title="2.4 常对象和常引用"></a>2.4 常对象和常引用</h2><h3 id="2-4-1-常对象"><a href="#2-4-1-常对象" class="headerlink" title="2.4.1 常对象"></a>2.4.1 常对象</h3><p>可以用const来修饰一个对象，称为常对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> &lt;classname&gt; s1;</span><br><span class="line">&lt;classname&gt; <span class="type">const</span> s1;</span><br></pre></td></tr></table></figure><p>在初始化设置完常对象后，该对象的内容就不能进行修改。我们可以通过这个对象来访问内部被<strong>const修饰的函数</strong>，且只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）</p><ul><li>常对象调用非const修饰函数会报错</li><li>不能修改常对象中成员变量的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> STU <span class="title">s1</span><span class="params">(<span class="string">&quot;小明&quot;</span>, <span class="number">15</span>, <span class="number">90.6</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果你想在定义const对象后依旧可以修改某一个成员变量的值，可以用mutable来修饰该成员变量，这样依旧可以修改这个值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">STU</span>&#123;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">char</span> *m_name;<span class="comment">//mutable修饰的成员变量，在const对象中仍然可以被修改</span></span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">float</span> m_score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上面的name变量，即便定义了const对象，也可以对它进行修改</p><p><img src="https://img.musnow.top/i/2023/02/202205271826188.png" alt="image-20220527182621032"></p><hr><h3 id="2-4-2-常引用"><a href="#2-4-2-常引用" class="headerlink" title="2.4.2 常引用"></a>2.4.2 常引用</h3><h4 id="2-4-2-1-引用基本形式"><a href="#2-4-2-1-引用基本形式" class="headerlink" title="2.4.2.1 引用基本形式"></a>2.4.2.1 引用基本形式</h4><p>引用的基本方式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b=a;</span><br><span class="line"><span class="type">int</span>&amp; c=a;<span class="comment">//同一个变量可以有多个别名</span></span><br><span class="line"><span class="comment">//可以用两个不同的变量名引用同一个</span></span><br><span class="line"><span class="comment">//但是引用了之后不可以更改对象</span></span><br></pre></td></tr></table></figure><p>此时的b和c都是a的别名，注意是别名！</p><p><img src="https://img.musnow.top/i/2023/02/202205101947693.png" alt="image-20220510194732657"></p><p>可以<strong>用两个不同的变量名</strong>引用同一个变量，而且引用了之后不可以更改对象</p><ul><li>一个变量可以有多个引用</li><li>指针可以更改指向的对象，引用不可以</li><li>引用必须在定义的时候就初始化，不可以<code>int&amp; b;</code></li></ul><p><img src="https://img.musnow.top/i/2023/02/202205101946720.png" alt="image-20220510194600682"></p><p>比如你叫李华，有人叫你“小李”，还有人叫你“英语作文人”，这两个外号都是你的别名。指针并不是别名，指针是通过地址访问某个变量。而引用是给a变量起另外的两个名字，实际上b和c都可以当作a来使用</p><p>编译运行代码，让编译器打印出这三者的地址，可以看到它们的<strong>地址是一样的</strong>，因为它们本来就是同一个变量的不同名字。</p><p><img src="https://img.musnow.top/i/2023/02/202205101939320.png" alt="image-20220510193932279"></p><p><strong>指针变量的地址</strong>和指针变量<strong>所指向对象的地址</strong>是不同的，引用的类型必须和引用实体的类型相同，不能用<code>int&amp;</code>引用double类型</p><p><img src="https://img.musnow.top/i/2023/02/202205101958391.png" alt="image-20220510195818363"></p><hr><h4 id="2-4-2-2-引用的权限问题"><a href="#2-4-2-2-引用的权限问题" class="headerlink" title="2.4.2.2 引用的权限问题"></a>2.4.2.2 引用的权限问题</h4><p><strong>const常量</strong></p><p>引用可以引用常量，但是必须加<code>const</code>修饰</p><p><img src="https://img.musnow.top/i/2023/02/202205101949582.png" alt="image-20220510194957550"></p><p>基本的思路就是“权限可以缩小，但不可以放大”。</p><ul><li>在上面的代码中，a是一个可以修改的变量，但是<code>const int&amp;d=a;</code>中的d是不能修改，只可读取a的内容。</li><li>e是不可修改的常量，所以我们不能用<code>int&amp;</code>来放大权限</li></ul><p><strong>int和double相互引用</strong></p><p>在<code>1.1</code>中有提到，我们不能用<code>int&amp;</code>来引用<code>double</code>类型的变量，编译器会报错</p><p><img src="https://img.musnow.top/i/2023/02/202205101958391.png"></p><p>不过我们可以用<code>const int&amp;</code>类型来引用double，此时引用就不是简单的一个别名了。</p><p>先来了解一下把double复制给int类型，这时候会产生“隐式类型转换”，h保存的是z的整数部分</p><p><img src="https://img.musnow.top/i/2023/02/202205102001100.png" alt="image-20220510200102067"></p><p><img src="https://img.musnow.top/i/2023/02/202205102002110.png" alt="image-20220510200239078"></p><p>在这个过程中，编译器会产生一个临时变量存放z的整数部分，然后赋值给h</p><ul><li>临时变量具有“常性”，可读不可改</li></ul><p>而当我们用<code>const int&amp;</code>类型来引用double时，实际上引用的是编译器产生的临时变量，它是一个常量，所以我们需要用<code>const int&amp;</code>来引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i=z;<span class="comment">//这里的i是临时变量的别名</span></span><br><span class="line"><span class="comment">//在引用的时候，创建了一个临时变量存放d的整数部分</span></span><br><span class="line"><span class="comment">//i的地址和z不相同，且临时变量不会销毁，生命周期和i同步</span></span><br><span class="line"><span class="comment">//生成的这个临时变量是常量，所以i的本质是引用了一个int类型</span></span><br><span class="line">cout &lt;&lt;<span class="string">&quot;i= &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;&amp;i= &quot;</span>&lt;&lt; &amp;i &lt;&lt;endl; </span><br><span class="line">cout &lt;&lt;<span class="string">&quot;&amp;z= &quot;</span>&lt;&lt; &amp;z &lt;&lt;endl;</span><br><span class="line"><span class="comment">//在c++中函数主要使用引用传参，后面会进一步学习</span></span><br></pre></td></tr></table></figure><p>一个非常直观的验证方法，就是打印一下，瞅瞅它们的地址是否相同。可以看到，i的值和h是相同的，因为它引用的就是那个<strong>存放了整数部分的临时变量</strong>，这个临时变量的地址和z不同</p><p><img src="https://img.musnow.top/i/2023/02/202205102009869.png" alt="image-20220510200949843"></p><h2 id="2-5-this指针及工作原理"><a href="#2-5-this指针及工作原理" class="headerlink" title="2.5 this指针及工作原理"></a>2.5 this指针及工作原理</h2><h3 id="2-5-1-特点"><a href="#2-5-1-特点" class="headerlink" title="2.5.1 特点"></a>2.5.1 特点</h3><p>当你用同样的图纸建了很多个屋子后，有没有想过应该如何区分它们呢？</p><p>C++在设计这部分的时候，添加了一个this指针来解决这个问题：C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参 数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，<strong>都是通过该指针去访问</strong>。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</p><ol><li>this指针的类型：<code>类名* const</code></li><li>只能在“成员函数”的内部使用</li><li>this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。</li><li>this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递</li></ol><h3 id="2-5-2-显式使用this"><a href="#2-5-2-显式使用this" class="headerlink" title="2.5.2 显式使用this"></a>2.5.2 显式使用this</h3><p>就用下面这个函数举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;_name&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;_sex &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，在调用它的时候，编译器会做如下处理。因为只有这样，才能完整的区分两个不同的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Student*<span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="keyword">this</span>-&gt;_name&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="keyword">this</span>-&gt;_sex &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步看看下面这个代码，可以帮助你理解this指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; d)&#123;</span><br><span class="line">       <span class="keyword">return</span> _year == d._year</span><br><span class="line">           &amp;&amp; _month== d._month</span><br><span class="line">           &amp;&amp; _day == d._day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个日期的比较函数，是操作符重载（后面会讲到）。你可以看到，这个函数我们传入了一个<strong>Date类型的引用</strong>，这是区别于this的另外一个类的对象。</p><p>如果没有this，那就很难区分两个变量的<code>_year</code>，于是编译器会把它优化成下面这样，就不会存在无法区分的问题了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Date*<span class="type">const</span> <span class="keyword">this</span>,<span class="type">const</span> Date&amp; d)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_year == d._year</span><br><span class="line">           &amp;&amp; <span class="keyword">this</span>-&gt;_month== d._month</span><br><span class="line">           &amp;&amp; <span class="keyword">this</span>-&gt;_day == d._day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-空指针问题"><a href="#2-5-3-空指针问题" class="headerlink" title="2.5.3 空指针问题"></a>2.5.3 空指针问题</h3><p>在程序中，访问NULL不会报错，但是解引用Null会报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ta</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;print ta&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;_a&lt;&lt;endl;//err</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ta* p=<span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;<span class="built_in">Print</span>();</span><br><span class="line">   <span class="comment">//可以去访问空指针的函数</span></span><br><span class="line">   <span class="comment">//因为函数只是去调用了类里面的Print函数</span></span><br><span class="line">   <span class="comment">//同时传了一个p的this指针（空指针传参是不会报错的）</span></span><br><span class="line">   <span class="comment">//但是如果你去访问p里面_a变量，就会报运行错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-类间关系"><a href="#2-6-类间关系" class="headerlink" title="2.6 类间关系"></a>2.6 类间关系</h2><h3 id="2-6-1-友元关系"><a href="#2-6-1-友元关系" class="headerlink" title="2.6.1  友元关系"></a>2.6.1 友元关系</h3><p><strong>友元分为友元函数和友元类</strong>。友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。</p><h4 id="2-6-1-1-友元函数"><a href="#2-6-1-1-友元函数" class="headerlink" title="2.6.1.1 友元函数"></a>2.6.1.1 友元函数</h4><p>友元函数相当于这个类的好朋友，它并不是类的成员函数，但是可以访问这个类的私有成员。<strong>友元函数没有this指针</strong>，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部明，声明时需要加friend关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DATE</span>&#123;</span><br><span class="line"> <span class="comment">// 友元函数</span></span><br><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> Date&amp; d);                                      </span><br><span class="line"><span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; in, Date&amp; d);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以&lt;&lt;和&gt;&gt;操作符重载为例，如果我们直接在类里面定义的话，使用这个重载的方式就会变成下面这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DATE d1;</span><br><span class="line">d1&lt;&lt;cout;</span><br><span class="line">d1&gt;&gt;cin;</span><br></pre></td></tr></table></figure><p>因为对于双目操作符，重载的时候，编译器是将第一个参数作为操作符的左值的。在类里面定义时，第一个操作数是隐含的this指针。即必须用对象名作为左操作数来进行使用。这样虽然也能完成既定任务，但这个使用方式未免太过奇葩了。</p><p>定义为友元后，没有隐含的this指针，就可以使用<code>cout&lt;&lt;d1</code>这种正常的方式来调用这个操作符重载了</p><ul><li>一个函数可以是多个类的友元函数</li><li>友元函数不能用const修饰</li><li>友元函数可以在类定义的任何地方声明，不受类访问限定符限制</li><li>友元函数的调用与普通函数的调用和原理相同</li></ul><hr><h4 id="2-6-1-2-友元类"><a href="#2-6-1-2-友元类" class="headerlink" title="2.6.1.2 友元类"></a>2.6.1.2 友元类</h4><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问<strong>另一个类中的非公有成员</strong>。</p><ul><li>友元关系是单向的，不具有交换性：比如有A类和B类，在A类中声明B类为其友元类，那么可以在B类中直接访问A类的私有成员变量，但想在A类中访问B类中私有的成员变量则不行。</li><li>友元关系不能传递：如果B是A的友元，C是B的友元，则不能说明C时A的友元。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;<span class="comment">//前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="comment">//声明友元类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//可以在类里面通过对象访问A的非公有成员</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;_a1._n&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A _a1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-整体部分关系"><a href="#2-6-2-整体部分关系" class="headerlink" title="2.6.2 整体部分关系"></a>2.6.2 整体部分关系</h3><h4 id="2-6-2-1-内嵌对象"><a href="#2-6-2-1-内嵌对象" class="headerlink" title="2.6.2.1 内嵌对象"></a>2.6.2.1 内嵌对象</h4><p>内嵌对象：在一个类中定义另外一个类的对象</p><p>在一些应用场景中，我们会需要在一个类里面定义另外一个类的对象。如下面这道OJ题中，我们需要用两个队列的类来实现这里的<code>MyStack</code>。</p><p><img src="https://img.musnow.top/i/2023/02/202205271912392.png" alt="image-20220527191209932"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">  <span class="comment">//队列的实现 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Queue q1;</span><br><span class="line">     Queue q2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于内部对象Queue，需要注意的有以下几点：</p><ul><li>内部对象属于外置类型，在对象实例化的时候，编译器会去调用Queue的构造函数</li><li>不能在MyStack类中直接对Queue进行初始化</li></ul><p>如果在Queue中定义了有参的构造函数，需要在MyStack构造函数中的<strong>初始化列表处</strong>进行初始化操作</p><h4 id="2-6-2-2-组合聚合问题"><a href="#2-6-2-2-组合聚合问题" class="headerlink" title="2.6.2.2 组合聚合问题"></a>2.6.2.2 组合聚合问题</h4><p>当一个类的对象拥有另一个类的对象时，就会发生类聚合：</p><ul><li>母类A的每一个对象中都会包含一个或多个B类的对象</li><li>类组合是一种特殊的聚合形式，其中拥有者类控制被拥有者类对象的生命周期。</li></ul><p>依旧以上面的MyStack代码为例，当我们在里面定义了Queue对象q1和q2后，它们的生命周期和MyStack类对象的生命周期同步。MyStack类会先构造，然后构造q1和q2；q1和q2分别析构后，才会析构MyStack的类对象。</p><h4 id="2-6-2-3-内部类"><a href="#2-6-2-3-内部类" class="headerlink" title="2.6.2.3 内部类"></a>2.6.2.3 内部类</h4><p>当定义内部类时，内部类默认为外部类的友元，可以直接访问外部类的非公有成员。但是内部类是一个独立的类，外部类不能访问内部类的非私有成员，也不能通过外部类的对象来访问内部类的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">Prin</span><span class="params">(<span class="type">const</span> A&amp; a1)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          cout&lt;&lt; a1._a &lt;&lt;endl;<span class="comment">//可以直接通过对象来访问私有成员</span></span><br><span class="line">          cout&lt;&lt; count&lt;&lt;endl;<span class="comment">//外部的静态成员可以直接访问</span></span><br><span class="line">          cout&lt;&lt; _b &lt;&lt;endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> _b;  </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::count=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="2-6-3-继承派生关系"><a href="#2-6-3-继承派生关系" class="headerlink" title="2.6.3 继承派生关系"></a>2.6.3 继承派生关系</h3><h4 id="2-6-3-1-基本用法"><a href="#2-6-3-1-基本用法" class="headerlink" title="2.6.3.1 基本用法"></a>2.6.3.1 基本用法</h4><p>继承和派生是父与子的关系，其中子类拥有父类成员的同时，还会拥有自己的成员</p><ul><li>继承是一个特殊的语法，用于多个类有公共部分的时候</li><li>父类：基类</li><li>子类：派生类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例：网站的公共部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ART</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; <span class="string">&quot;归档&quot;</span> &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;关于我们&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;网站访问量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//文章页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LINK</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; <span class="string">&quot;归档&quot;</span> &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;关于我们 &quot;</span> &lt;&lt; <span class="string">&quot; 网站访问量&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//友链页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的情况中，ART和LINK类中都有网站的公共部分，这时候就出现了代码的重复。继承的出现就是用于解决这个问题的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面使用继承的方式来写，WEB类是网站的公共部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WEB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; <span class="string">&quot;归档&quot;</span> &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span><span class="comment">//所有网站页面都有这个</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;关于我们&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;网站访问量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ART、LINK是两个子类，继承了WEB的公共部分</span></span><br><span class="line"><span class="comment">//这样就减少了代码量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ART</span> : <span class="keyword">public</span> WEB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//文章页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文章&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LINK</span> : <span class="keyword">public</span> WEB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//友链页面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;友链&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试可以发现，ART和LINK作为派生类，在继承了基类WEB的成员的基础上，还拥有了它们独特的单独成员</p><p><img src="https://img.musnow.top/i/2023/02/202205272021620.png" alt="image-20220527202138439"></p><p>同一个类可以同时继承多个基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-6-3-2-权限问题"><a href="#2-6-3-2-权限问题" class="headerlink" title="2.6.3.2 权限问题"></a>2.6.3.2 权限问题</h4><p>继承有3中类型：public、private、protected。这里会显示出类中protected权限和private权限的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们分别用上面三种方式对类A进行继承的时候，得到的结果是不同的</p><ul><li>用什么继承方式，派生类中继承的成员就变成什么类型</li><li>不管用什么继承方式，都无法访问基类中的私有成员</li></ul><p><img src="https://img.musnow.top/i/2023/02/202205272034572.png" alt="image-20220527203404310"></p><h4 id="2-6-3-3-同名问题"><a href="#2-6-3-3-同名问题" class="headerlink" title="2.6.3.3 同名问题"></a>2.6.3.3 同名问题</h4><p>当基类和派生类中出现同名成员函数或者同名成员变量时，会出现冲突。这时候编译器会做一定的处理：直接访问变量名和函数名的时候，优先访问派生类自己的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承同名成员的处理</span></span><br><span class="line"><span class="comment">//	普通的同名成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DAD1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DAD1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_a = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD func int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;<span class="comment">//基类中的该变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SON1</span> : <span class="keyword">public</span> DAD1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SON1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;SON: &quot;</span> &lt;&lt; _a &lt;&lt; endl;<span class="comment">//优先访问派生类的_a</span></span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;DAD: &quot;</span> &lt;&lt; DAD1::_a &lt;&lt; endl;<span class="comment">//访问基类的_a</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;SON func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;<span class="comment">//派生类的同名变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/02/202205272044379.png" alt="image-20220527204445283"></p><p>如果是静态成员，访问方法就有所变化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问同名的静态成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DAD2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> D_a;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD2 Test1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DAD2 Test1(int)  &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DAD2::D_a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SON2</span> : <span class="keyword">public</span> DAD2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> D_a;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;SON2 Test1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> SON2::D_a = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/02/202205272049585.png" alt="image-20220527204928480"></p><h4 id="2-6-3-4-虚继承"><a href="#2-6-3-4-虚继承" class="headerlink" title="2.6.3.4 虚继承"></a>2.6.3.4 虚继承</h4><p>有的时候，继承会出现下面这种情况：一个子类继承了两个基类，而这两个基类又同时是一个基类的派生类</p><p><img src="https://img.musnow.top/i/2023/02/202205280831658.jpg" alt="未命名_副本"></p><p>这时候，D里面就会有两份A的内容，相当于两份公共部分。这是我们不想看到的，因为会造成空间浪费。而且直接访问的时候，编译器会报错“对变量X的访问不明确”</p><p><img src="https://img.musnow.top/i/2023/02/202205272058955.png" alt="image-20220527205808893"></p><p>和前面说道的同名问题一样，我们可以指定作用域来访问特定的变量，但是这样是治标不治本的方法，并没有解决空间浪费的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方法1（治表不治本）</span></span><br><span class="line"><span class="comment">//用类域来修改和访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;intel: &quot;</span> &lt;&lt; n1.INTEL::_Structure &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;amd: &quot;</span>   &lt;&lt; n1.AMD::_Structure &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这就需要我们使用<strong>虚继承</strong>来操作：给B和C对A的继承加上<code>virtural</code>关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CPU</span>()</span><br><span class="line">		:_Structure(<span class="string">&quot;x86&quot;</span>)</span><br><span class="line">	&#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> _Structure[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">INTEL</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> CPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">INTEL</span>()</span><br><span class="line">		:<span class="built_in">i_Brand</span>(<span class="string">&quot;intel&quot;</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> i_Brand[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMD</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> CPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AMD</span>()</span><br><span class="line">		:<span class="built_in">a_Brand</span>(<span class="string">&quot;amd&quot;</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> a_Brand[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候直接访问变量就不会报错了。因为这时候，B和C中的该变量指向了同一个地址，修改操作会同步。</p><p><img src="https://img.musnow.top/i/2023/02/202205272057303.png" alt="image-20220527205708237"></p><h2 id="2-7-多态性"><a href="#2-7-多态性" class="headerlink" title="2.7 多态性"></a>2.7 多态性</h2><ul><li>静态多态：运算符重载</li><li>动态多态：派生类和虚函数组成的多态</li></ul><h3 id="2-7-1-运算符重载"><a href="#2-7-1-运算符重载" class="headerlink" title="2.7.1 运算符重载"></a>2.7.1 运算符重载</h3><h4 id="2-7-1-1定义"><a href="#2-7-1-1定义" class="headerlink" title="2.7.1.1定义"></a>2.7.1.1定义</h4><p>在讲解赋值运算符重载之前，我们可以来认识一下完整的运算符重载：C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</p><p>函数名为：关键字 <code>operator</code>运算符，如<code>operator=</code></p><p>函数原型：返回值类型 operator操作符(参数列表)，如<code>Date operator=();</code></p><p>下面有几点注意：</p><ul><li>重载操作符必须有一个自定义类型的操作数（即操作符重载对内置类型无效）</li><li>不能通过其他符号来创建新的操作符</li><li>对于类类型的操作符重载，形参比操作数少一个传参（因为有一个默认的形参this指针）</li><li>这5个操作符是不能重载的：<code>.*</code>、<code>::</code>、<code>sizeof</code>、<code>? :</code>、<code>.</code></li></ul><h4 id="2-7-1-2基本使用"><a href="#2-7-1-2基本使用" class="headerlink" title="2.7.1.2基本使用"></a>2.7.1.2基本使用</h4><p>以下是在全局定义的操作符重载，用于判断日期是否相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; d1, <span class="type">const</span> Date&amp; d2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> d1._year == d2._year;</span><br><span class="line">    &amp;&amp; d1._month == d2._month</span><br><span class="line">    &amp;&amp; d1._day == d2._day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在main函数中使用<code>d1==d2</code>的时候，编译器就会自动调用该操作符重载</p><p>当然，你也可以自己来传参使用，如<code>if(operator==(d1,d2))</code></p><p>但是这样非常不方便，和调用一个而普通函数没啥区别，压根算不上操作符重载。所以我们一般是<strong>在类里面</strong>定义操作符重载的</p><hr><p>当我们把它放入类<code>Date</code>中间，就需要修改成下面这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; d2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _year == d2._year;</span><br><span class="line">    &amp;&amp; _month == d2._month</span><br><span class="line">    &amp;&amp; _day == d2._day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器在调用的时候，会优化成下面这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Date* <span class="keyword">this</span>, <span class="type">const</span> Date&amp; d2)</span><br><span class="line"><span class="comment">//显示调用为 d1.operator==(d2);</span></span><br></pre></td></tr></table></figure><p>而在main里面使用的时候，这个重载后的操作符和原本的使用方法完全相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2022</span>,<span class="number">6</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2022</span>,<span class="number">5</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">d1</span>==d2;<span class="comment">//自动调用操作符重载d1.operator==(d2);</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-7-1-3赋值运算符重载"><a href="#2-7-1-3赋值运算符重载" class="headerlink" title="2.7.1.3赋值运算符重载"></a>2.7.1.3赋值运算符重载</h4><p>因为每一个类都有不同的成员，编译器不可能智能的进行赋值操作。这时候就需要我们自己写一个赋值运算符重载来进行赋值操作了</p><p>以日期类为例，赋值操作其实就是把内置类型成员一一赋值即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Date&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; d)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;d)<span class="comment">//避免自己给自己赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        _year=d._year;</span><br><span class="line">        _month=d._month;</span><br><span class="line">        _day=d._day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写赋值重载代码的时候，需要注意下面几点：</p><ul><li>返回值和参数类型（注意要引用传参，不然会调用拷贝构造）</li><li>检测是否自己给自己赋值（避免浪费时间）</li><li>因为返回的是<code>*this</code>，出了函数后没有销毁，所以可以用传引用返回</li><li>一个类如果没有显式定义赋值运算符重载，编译器也会自己生成一个，完成对象按字节序的值拷贝。</li></ul><p>如果类中有<strong>自定义类型</strong>，编译器会默认调用它的赋值运算符重载</p><h4 id="2-7-1-4拷贝构造和赋值重载的调用问题"><a href="#2-7-1-4拷贝构造和赋值重载的调用问题" class="headerlink" title="2.7.1.4拷贝构造和赋值重载的调用问题"></a>2.7.1.4拷贝构造和赋值重载的调用问题</h4><p>当赋值操作符和拷贝构造同时存在的时候，什么时候会调用赋值，什么时候会调用拷贝构造呢？</p><p><img src="https://img.musnow.top/i/2023/02/202205201246760.png" alt="image-20220520124610717"></p><p>在这两个函数中添加<code>cout</code>进行打印提示，可以看到：</p><ul><li>如果对象在之前已经存在，就会调用赋值重载</li><li>如果是一个全新的变量在定义的时候初始化，就调用的是拷贝构造</li></ul><p><img src="https://img.musnow.top/i/2023/02/202205201252132.png" alt="image-20220520125218089"></p><h3 id="2-7-2-虚函数"><a href="#2-7-2-虚函数" class="headerlink" title="2.7.2 虚函数"></a>2.7.2 虚函数</h3><h4 id="2-7-2-1-基本使用以及动态多态"><a href="#2-7-2-1-基本使用以及动态多态" class="headerlink" title="2.7.2.1 基本使用以及动态多态"></a>2.7.2.1 基本使用以及动态多态</h4><p>虚函数，并不代表这个函数是虚无的。而表示这个函数在一定情况下会被替换（就好比继承中的虚继承问题）。要实现动态多态，就需要借助虚函数来实现。以下面这个动物说话的代码为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//void Talk()</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Talk</span><span class="params">()</span><span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal is talking&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAT</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Talk</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CAT is talking&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DOG</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Talk</span><span class="params">()</span><span class="comment">//同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DOG is talking&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类中不使用虚函数时，该函数的内容已确定</span></span><br><span class="line"><span class="comment">//不管传参什么类，都会调用Animal自己的Talk函数</span></span><br><span class="line"><span class="comment">//加上虚函数virtual后，会调用CAT和DOG的Talk函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MakeTalk</span><span class="params">(Animal&amp; it)</span> </span>&#123;</span><br><span class="line">	it.<span class="built_in">Talk</span>();<span class="comment">//调用对应的Talk函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当基类Animal中的Talk函数没有用virtual修饰时，不管给这个函数传参什么类的对象，它都会调用Animal自己的Talk函数</p><p><img src="https://img.musnow.top/i/2023/02/202205272139327.png" alt="image-20220527213937251"></p><p>当我们用虚函数进行修饰后，就会调用派生类CAT和DOG的Talk函数，这就实现了一个简单的动态多态。</p><p><img src="https://img.musnow.top/i/2023/02/202205272140385.png" alt="image-20220527214022282"></p><p>对于虚函数，有几点需要注意：</p><ul><li>当基类的指针或引用指向派生类的对象时，就会触发动态多态，派生类中的同名函数会覆写基类中的虚函数</li><li>不能定义静态虚函数——因为静态函数是属于整个类的，而不是属于某一个对象</li><li>不能定义虚构造函数——总不能用派生类的构造来覆写基类的构造吧？</li><li>析构函数可以是虚函数</li></ul><h4 id="2-7-2-2-虚析构函数"><a href="#2-7-2-2-虚析构函数" class="headerlink" title="2.7.2.2 虚析构函数"></a>2.7.2.2 虚析构函数</h4><p>有的时候，我们需要析构一个对象时，往往会给基类的析构函数加上virtual修饰，这样只要传派生类的对象给基类的指针&#x2F;引用，就可以直接调用派生类对应的析构函数，完成不同的析构操作。而不是都呆呆的调用基类的析构函数——那样就会产生内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Queue</span>()</span><br><span class="line">		:_a(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Queue</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[] _a;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>* _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> :<span class="keyword">public</span> Queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyStack</span>(<span class="type">int</span> capa)</span><br><span class="line">		:_a1(<span class="keyword">new</span> <span class="type">int</span>[capa])</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">MyStack</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~MyStack&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[] _a1;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>* _a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue* q1=<span class="keyword">new</span> <span class="built_in">MyStack</span>(<span class="number">4</span>);<span class="comment">//父类指针指向子类</span></span><br><span class="line">	<span class="keyword">delete</span> q1;<span class="comment">//调用子类的析构函数，再调用父类析构</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，可以看到，我们成功通过父类的指针，调用了子类的析构函数。子类的析构函数中本身就会自动调用父类析构函数。这样一来，子类和父类都被成功析构，不会出现内存泄漏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">~MyStack</span><br><span class="line">~Queue</span><br></pre></td></tr></table></figure><p>如果去掉父类析构函数的virtual关键字，则只析构父类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">~Queue</span><br></pre></td></tr></table></figure><h3 id="2-7-3-纯虚函数"><a href="#2-7-3-纯虚函数" class="headerlink" title="2.7.3 纯虚函数"></a>2.7.3 纯虚函数</h3><p>在虚函数的基础上，C++定义了纯虚函数：有些时候，在基类里面定义某一个函数是没有意义的，这时候我们可以把它定义为<strong>纯虚函数</strong>，具体的实现让派生类去同名覆写。</p><p>纯虚函数的基本形式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//virtual 函数返回类型 函数名()=0;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>派生类中必须重写基类的纯虚函数，否则该类也是抽象类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//virtual void Print();//虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B print &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C print &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在派生类中覆写了该函数后，即可实例化对象并调用该函数</p><p><img src="https://img.musnow.top/i/2023/02/202205272207840.png" alt="image-20220527220700695"></p><p>和虚函数一样，使用基类的引用或指针来接收派生类的对象，即可调用对应的函数</p><p><img src="https://img.musnow.top/i/2023/02/202205272209664.png" alt="image-20220527220929573"></p><h3 id="2-7-4-抽象类"><a href="#2-7-4-抽象类" class="headerlink" title="2.7.4 抽象类"></a>2.7.4 抽象类</h3><p>包含纯虚函数的类就是抽象类，抽象类有下面几个特点：</p><ul><li>抽象类无法实例化对象</li><li>抽象类的派生类必须重写基类的纯虚函数，不然派生类也是抽象类</li><li>如果在基类中定义的纯虚函数是const修饰的，则派生类中对应的函数也需要用const修饰</li></ul><p><img src="https://img.musnow.top/i/2023/02/202205272205203.png" alt="image-20220527220539119"></p><h1 id="第三章-面向对象应用"><a href="#第三章-面向对象应用" class="headerlink" title="第三章  面向对象应用"></a>第三章 面向对象应用</h1><h2 id="3-1-矩阵类设计及应用"><a href="#3-1-矩阵类设计及应用" class="headerlink" title="3.1 矩阵类设计及应用"></a>3.1 矩阵类设计及应用</h2><blockquote><p><strong>矩阵类要求</strong>：设计一个矩阵类，要求能够根据用户需求构建row行、column列的矩阵，并灵活接受反馈矩阵元素信息（如：某行、某列、某行某列元素）。实现矩阵的相关运算，包括矩阵加（+）、矩阵乘（*）、矩阵输出（&lt;&lt;）、矩阵赋值（&#x3D;）、获取矩阵指定位置元素值（[]）</p></blockquote><p>设计该程序的时候，需要注意下面几点：</p><ol><li>重载矩阵类必须使用二维数组，不能用一维数组+公式判断的方法（因为这样无法重载[]操作符）</li><li>重载矩阵加减和相乘的运算符时候需要注意矩阵运算的规则（第一行x第一列&#x3D;第一个）</li></ol><p><img src="https://img.musnow.top/i/2023/02/202205281225971.jpg" alt="光影魔术手拼图"></p><ol start="3"><li>对于+和-的重载不应该修改原本的矩阵，应该创建临时对象tmp后，修改tmp的值并返回</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1=<span class="number">1</span>,a2=<span class="number">2</span>;</span><br><span class="line">a1+a2;<span class="comment">//这样相加并不会影响a1和a2的值</span></span><br></pre></td></tr></table></figure><p>如果需要修改原本的矩阵，应该重载的操作符是+&#x3D;和-&#x3D;</p><ol start="4"><li>对于矩阵输出&lt;&lt;的重载，必须使用友元函数，否则使用会变成<strong>对象&lt;&lt;cout</strong>，不是正常使用的方法</li><li>对于获取矩阵指定位置元素值[]的重载，应该返回int*类型。在最开始设计的时候我错误写成了int类型，无法正确地连续使用两个[]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载[]操作符</span></span><br><span class="line"><span class="type">int</span>* <span class="keyword">operator</span>[](<span class="type">int</span> row)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[row];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用该操作符</span></span><br><span class="line">a1[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//第一个[]是操作符重载</span></span><br><span class="line">a1[<span class="number">1</span>];<span class="comment">//返回了第二行的数组名</span></span><br><span class="line"><span class="comment">//第二个[]是普通的操作符本身，访问返回的数组名找到对应列的值</span></span><br></pre></td></tr></table></figure><p>矩阵类完整代码实现见附录。</p><h2 id="3-2-银行账户管理系统设计及应用"><a href="#3-2-银行账户管理系统设计及应用" class="headerlink" title="3.2 银行账户管理系统设计及应用"></a>3.2 银行账户管理系统设计及应用</h2><blockquote><p><strong>银行账号管理系统要求</strong>：管理不同用户在银行的金融资产，每个用户可以拥有多种银行账户（如：定期储蓄、活期储蓄、信息卡、电子账户、贷款账户等）。账户包括账号、余额、利率等基本信息，用户可以进行账户信息查询、存款、取款、结算利息等操作。银行需统计所有账户的总金额、验证银行系统收支平衡，并能够及时预警反馈。设计Account抽象类作为所有银行账户顶层祖先，根据实际应用需求合理设置派生层次及相应子类。结合银行利息结算、用户贷款申请等实际应用需求，适当添加辅助类协同操作。合理定义虚基类、虚函数、纯虚函数、抽象类完成银行账号管理系统的稳定可靠运行。</p></blockquote><h3 id="3-2-1-基本思路"><a href="#3-2-1-基本思路" class="headerlink" title="3.2.1 基本思路"></a>3.2.1 基本思路</h3><p>以下是我设计该管理系统的思路：</p><ol><li>设计了<code>Account</code>类的主框架，作为后续类的基类</li><li>通过多态，实现了活期储蓄、定期储蓄类、信用卡类、贷款账户的功能</li><li>实现了简易菜单，通过<code>switch case</code>语句和<code>do while</code>语句实现多次调用不同函数接口的操作</li><li>与<a target="_blank" rel="noopener" href="https://gitee.com/musnow/learn_cpp_code/tree/master/PTcode/22-05-20/DateClass">日期类</a>结合，实时计算天数差距并结算利息</li></ol><p>在设计该菜单的过程中，我发现了很多问题需要注意，这些问题也加深了我对编程知识点的理解。</p><p>完整代码实现见附录。</p><h3 id="3-2-2-设计系统时遇到的问题"><a href="#3-2-2-设计系统时遇到的问题" class="headerlink" title="3.2.2 设计系统时遇到的问题"></a>3.2.2 设计系统时遇到的问题</h3><p>在设计贷款账户的时候，容易出现double浮点数存放精度的问题。用户贷款额度和余额直接若直接判断相等，很难得到正确结果（因为浮点数后面会跟着很多没有打印出来的小数）</p><p><img src="https://img.musnow.top/i/2023/02/202205301211765.png" alt="image-20220530121146672"></p><p>这就会出现，即便你根据程序接口中“查看待还金额”来得到自己的待还金额，并执行还款操作后，还是会有一部分小数位的数据并没有完整还完，这一部分的处理是非常困难的。为了避免用户永远都还不完自己的贷款，我设置了double的修约规则，即当用户余额和贷款&#x2F;透支额度的差值小于0.2时，不再处理后续的小数位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_Max - _money &lt; <span class="number">0.2</span>)<span class="comment">//浮点数精度问题</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无需还款&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在余额计算中进行取零修约，保证“剩余待还”打印值和“查看待还金额”函数的打印值同步。用这种方式间接解决了精度问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//待还金额为透支额度+利息</span></span><br><span class="line"><span class="type">double</span> money = (_Max - _money) + <span class="built_in">Income</span>(tmp);</span><br><span class="line"><span class="keyword">if</span> (money &lt; <span class="number">0.02</span>) &#123;</span><br><span class="line">	money = <span class="number">0</span>;<span class="comment">//修约浮点数，解决精度问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设计销户接口时，为了避免用户在销户后仍然能操作该账户，不能只是简单的使用break跳出单层循环，而是需要用return直接终止该程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;销户后，账户内的一切信息都会被清空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请问您确认销户吗？Y/N&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> A;</span><br><span class="line">        A = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;销户完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-一些缺陷"><a href="#3-2-3-一些缺陷" class="headerlink" title="3.2.3 一些缺陷"></a>3.2.3 一些缺陷</h3><p><strong>1.文件操作</strong></p><p>该银行管理类还可以添加文件操作，来保存用户的信息。原先想法是在Account类中定义static全局变量进行<code>count++</code>，以此得出所有派生类构造对象的总和。再利用for循环进行读取文件操作，这样就能在下一次打开程序的时候，通过用户的账户来定位用户的某一个特定账户对象，进行后续的操作。</p><p>但是Account类作为抽象类是<strong>无法实例化对象</strong>的，如果用各个派生类来进行文件管理操作，该程序就会变得很臃肿。且由于本人能力问题，没能设计出循环读取文件内容，并进行定位下一个对象位置的操作，故在最终的设计中没有实现文件操作。</p><p><strong>2.时间问题</strong></p><p>为了代码测试需要，每一次操作都需要用户手动输入日期。在实际应用中，这项工作应该由银行用户终端自动化承担。可以设计读取预定义宏<code>__TIME__</code>来获取每一次操作的时间，从而实现和现实中的时间对照，去除每一次都需要手动输入代码的繁琐</p><h1 id="第四章-面向对象程序设计学习总结"><a href="#第四章-面向对象程序设计学习总结" class="headerlink" title="第四章  面向对象程序设计学习总结"></a>第四章 面向对象程序设计学习总结</h1><p>学习代码需要有一个持之以恒的心，再学习知识点的基础上要同时坚持写代码的练习。我在Gitee码云上创建了自己的学习仓库，坚持每天托管代码，作为自己学习编程打卡的一个记录</p><p><img src="https://img.musnow.top/i/2023/02/202205281212200.png" alt="image-20220528121250010"></p><p>和其他科目不同，CPP的学习是不能只停留在书籍和纸笔上的，只有你上手自己敲代码了，才能认识到一些光是听讲和看书学习不到的知识。比如一些程序出现bug之后的VS<strong>调试技巧</strong>，都是我在练习中学会的。</p><p><img src="https://img.musnow.top/i/2023/02/202205281228368.jpg" alt="QQ图片20220528122800"></p><p>同时还需要学会利用工具，如在<a target="_blank" rel="noopener" href="https://cplusplus.com/">cplusplus网站</a>上查找函数的定义，根据给出的代码示例尝试自己使用这个函数，并做到能在后面的程序设计中活学活用。</p><p>个人认为，不管学习的编程语言是什么，只有综合以上几点，才能真正学好编程。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul><li>矩阵类和银行管理系统完整代码👉<a target="_blank" rel="noopener" href="https://gitee.com/musnow/learn_cpp_code/tree/master/Project">【传送门】</a></li><li>部分资料参考C语言中文网👉<a target="_blank" rel="noopener" href="http://c.biancheng.net/">http://c.biancheng.net/</a></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/3040822590/">https://blog.musnow.top/posts/3040822590/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">类和对象</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm9.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2629909823/" title="【Git】如何同步Gitee和Github的仓库（超简单）"><img class="cover" src="/img/bg/gm24.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Git】如何同步Gitee和Github的仓库（超简单）</div></div></a></div><div class="next-post pull-right"><a href="/posts/2894176175/" title="【C++】类和对象2：默认成员函数+操作符重载"><img class="cover" src="/img/bg/gm13.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【C++】类和对象2：默认成员函数+操作符重载</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2582381960/" title="【C++】类和对象1：初识类+this指针"><img class="cover" src="/img/bg/gm4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-19</div><div class="title">【C++】类和对象1：初识类+this指针</div></div></a></div><div><a href="/posts/2894176175/" title="【C++】类和对象2：默认成员函数+操作符重载"><img class="cover" src="/img/bg/gm13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-20</div><div class="title">【C++】类和对象2：默认成员函数+操作符重载</div></div></a></div><div><a href="/posts/2885143113/" title="【C++11】future和async等"><img class="cover" src="/img/bg/gm13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="title">【C++11】future和async等</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Artalk</span><span class="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">283</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-text">第一章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E7%89%B9%E7%82%B9%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="toc-text">1.1 面向对象程序特点与目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84"><span class="toc-text">1.2 面向对象程序知识架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%9D%A2%E5%90%91%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%B1%A1%E5%85%B3%E9%94%AE%E6%94%AF%E6%92%91%E6%8A%80%E6%9C%AF"><span class="toc-text">第二章 面向程序对象关键支撑技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.1 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.1.1 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">2.1.1.1基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-2%E7%BC%96%E8%AF%91%E5%99%A8%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.1.1.2编译器默认生成的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-3%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">2.1.1.3初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-4-explicit%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.1.1.4 explicit关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.1.2 拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-1%E7%89%B9%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">2.1.2.1特性和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-2%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">2.1.2.2深拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">2.1.3 析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">2.2 静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-text">2.2.1 静态数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">2.2.2 静态成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B8%B8%E6%88%90%E5%91%98"><span class="toc-text">2.3 常成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-text">2.3.1 常数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">2.3.2 常成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-1-%E5%AE%9E%E4%BE%8B-%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.2.1 实例-权限问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">2.3.2.2 什么时候需要使用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-3-%E5%87%BA%E9%94%99%E6%83%85%E5%86%B5"><span class="toc-text">2.3.2.3 出错情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%B8%B8%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-text">2.4 常对象和常引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.4.1 常对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-text">2.4.2 常引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-1-%E5%BC%95%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F"><span class="toc-text">2.4.2.1 引用基本形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-2-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-text">2.4.2.2 引用的权限问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-this%E6%8C%87%E9%92%88%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.5 this指针及工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E7%89%B9%E7%82%B9"><span class="toc-text">2.5.1 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E6%98%BE%E5%BC%8F%E4%BD%BF%E7%94%A8this"><span class="toc-text">2.5.2 显式使用this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E7%A9%BA%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98"><span class="toc-text">2.5.3 空指针问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-text">2.6 类间关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-text">2.6.1 友元关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-1-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-text">2.6.1.1 友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-2-%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-text">2.6.1.2 友元类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E6%95%B4%E4%BD%93%E9%83%A8%E5%88%86%E5%85%B3%E7%B3%BB"><span class="toc-text">2.6.2 整体部分关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-1-%E5%86%85%E5%B5%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.6.2.1 内嵌对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-2-%E7%BB%84%E5%90%88%E8%81%9A%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-text">2.6.2.2 组合聚合问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-3-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">2.6.2.3 内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F%E5%85%B3%E7%B3%BB"><span class="toc-text">2.6.3 继承派生关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">2.6.3.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-2-%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-text">2.6.3.2 权限问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-3-%E5%90%8C%E5%90%8D%E9%97%AE%E9%A2%98"><span class="toc-text">2.6.3.3 同名问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-4-%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">2.6.3.4 虚继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">2.7 多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">2.7.1 运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-1%E5%AE%9A%E4%B9%89"><span class="toc-text">2.7.1.1定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">2.7.1.2基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-3%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">2.7.1.3赋值运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E7%9A%84%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">2.7.1.4拷贝构造和赋值重载的调用问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">2.7.2 虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="toc-text">2.7.2.1 基本使用以及动态多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-2-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">2.7.2.2 虚析构函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">2.7.3 纯虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-4-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">2.7.4 抽象类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BA%94%E7%94%A8"><span class="toc-text">第三章 面向对象应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%9F%A9%E9%98%B5%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-text">3.1 矩阵类设计及应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%93%B6%E8%A1%8C%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-text">3.2 银行账户管理系统设计及应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-text">3.2.1 基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3.2.2 设计系统时遇到的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E4%B8%80%E4%BA%9B%E7%BC%BA%E9%99%B7"><span class="toc-text">3.2.3 一些缺陷</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="toc-text">第四章 面向对象程序设计学习总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4065446782/" title="【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机"><img src="https://img.musnow.top/i/2023/10/a13a0b3e0db1dab54e499c9c7bf5ddc6.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机"></a><div class="content"><a class="title" href="/posts/4065446782/" title="【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机">【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机</a><time datetime="2023-10-15T03:30:55.000Z" title="发表于 2023-10-15 11:30:55">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/489538601/" title="【七牛云】artalk表情遇到跨域访问问题"><img src="https://img.musnow.top/i/2023/10/6e1119859945ce9b07928a2bff2643d8.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【七牛云】artalk表情遇到跨域访问问题"></a><div class="content"><a class="title" href="/posts/489538601/" title="【七牛云】artalk表情遇到跨域访问问题">【七牛云】artalk表情遇到跨域访问问题</a><time datetime="2023-10-02T04:35:28.000Z" title="发表于 2023-10-02 12:35:28">2023-10-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/565285228/" title="【Linux】valgrind检测程序内存泄漏"><img src="/img/bg/gm4.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Linux】valgrind检测程序内存泄漏"></a><div class="content"><a class="title" href="/posts/565285228/" title="【Linux】valgrind检测程序内存泄漏">【Linux】valgrind检测程序内存泄漏</a><time datetime="2023-09-26T10:12:55.000Z" title="发表于 2023-09-26 18:12:55">2023-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3858168547/" title="【C++】C++17的那些新特性"><img src="/img/bg/gm1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【C++】C++17的那些新特性"></a><div class="content"><a class="title" href="/posts/3858168547/" title="【C++】C++17的那些新特性">【C++】C++17的那些新特性</a><time datetime="2023-09-26T04:40:46.000Z" title="发表于 2023-09-26 12:40:46">2023-09-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/bg/mothra.png)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 慕雪年华</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%872023007189-red" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.staticfile.org/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline.musnow.top',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.staticfile.org/waline/2.15.5/waline.min.css').then(() => {
      getScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js').then(initWaline)
    })
  }
}

if ('Artalk' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="click-heart" src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>