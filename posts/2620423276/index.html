<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Linux】进程通信 | 信号 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本篇博客让我们一起来康康信号部分的内容  系统为CentOS7.6，完整代码见 Gitee"><meta property="og:type" content="article"><meta property="og:title" content="【Linux】进程通信 | 信号"><meta property="og:url" content="https://blog.musnow.top/posts/2620423276/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="本篇博客让我们一起来康康信号部分的内容  系统为CentOS7.6，完整代码见 Gitee"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm17.jpg"><meta property="article:published_time" content="2022-11-20T08:30:16.000Z"><meta property="article:modified_time" content="2023-03-29T08:18:13.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Linux"><meta property="article:tag" content="进程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm17.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/2620423276/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Linux】进程通信 | 信号",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-03-29 16:18:13"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">415</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnow.blog.csdn.net/"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm17.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnow.blog.csdn.net/"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Linux】进程通信 | 信号</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-20T08:30:16.000Z" title="发表于 2022-11-20 16:30:16">2022-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-29T08:18:13.000Z" title="更新于 2023-03-29 16:18:13">2023-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【Linux】进程通信 | 信号"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本篇博客让我们一起来康康<strong>信号</strong>部分的内容</p><blockquote><p>系统为CentOS7.6，完整代码见 <a target="_blank" rel="noopener" href="https://gitee.com/musnow/raspberry-practice/tree/master/code/22-11-16_signal">Gitee</a></p></blockquote><span id="more"></span><p>[TOC]</p><h1 id="1-什么是信号"><a href="#1-什么是信号" class="headerlink" title="1.什么是信号"></a>1.什么是信号</h1><p>在进程运行过程中，会出现各种各样的情况。操作系统需要用一套机制，来管理进程的<strong>事件</strong></p><ul><li>进程退出</li><li>进程停止</li><li>进程恢复运行</li><li>……</li></ul><p>同时，这套管理机制是<code>异步</code>的，属于一种<code>软（件）中断</code></p><blockquote><p>和硬件中断打断处理器类似，软件中断打断进程的执，让其执行对应代码进行响应</p></blockquote><h2 id="1-1-何为异步"><a href="#1-1-何为异步" class="headerlink" title="1.1 何为异步?"></a>1.1 何为异步?</h2><blockquote><p>以网购物品为例：当商品寄到自提点的时候，会给你发送一条取件的短信（信号）。此时我正在打游戏，没时间去处理这个快递（即取快递的行为并不是必须立马执行）</p><p>但这个时候，我已经知道有一个快递到了（知道自己获取到了一个信号）本质上就是知道了一会要去取快递（一会要处理信号）</p><p>当游戏一把打完了，我们就去取快递了（处理信号）</p></blockquote><p>这就是一种<code>异步</code>的过程。因为<strong>你不知道你的快递什么时候会到站点</strong>，进程也不知道自己<strong>什么时候会收到一个信号</strong></p><h2 id="1-2-信号的种类"><a href="#1-2-信号的种类" class="headerlink" title="1.2 信号的种类"></a>1.2 信号的种类</h2><p>使用<code>kill -l</code>命令，我们可以看到目前linux系统下<code>64</code>种不同的类型。</p><p>其中前32为标准（Standard）信号，后32为实时（Real-time）信号；<strong>本篇博客只关注标准信号</strong></p><blockquote><p>这些信号，都是linux系统中预定义的<strong>宏</strong></p></blockquote><p>其中最常用的便是9号信号，来中断进程。平时我们最常用的<code>CTRL+C</code>，也是通过<strong>向进程发2号信号</strong>让进程退出的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>在<code>include/linux/signal.h</code>中，我们<span id="jump1">可以看到对信号</span>的解释，以及其<code>默认处理方法 default action</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In POSIX a signal is sent either to a specific thread (Linux task)</span></span><br><span class="line"><span class="comment"> * or to the process as a whole (Linux thread group).  How the signal</span></span><br><span class="line"><span class="comment"> * is sent determines whether it&#x27;s to one thread or the whole group,</span></span><br><span class="line"><span class="comment"> * which determines which signal mask(s) are involved in blocking it</span></span><br><span class="line"><span class="comment"> * from being delivered until later.  When the signal is delivered,</span></span><br><span class="line"><span class="comment"> * either it&#x27;s caught or ignored by a user handler or it has a default</span></span><br><span class="line"><span class="comment"> * effect that applies to the whole thread group (POSIX process).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The possible effects an unblocked signal set to SIG_DFL can have are:</span></span><br><span class="line"><span class="comment"> *   ignore	- Nothing Happens</span></span><br><span class="line"><span class="comment"> *   terminate	- kill the process, i.e. all threads in the group,</span></span><br><span class="line"><span class="comment"> * 		  similar to exit_group.  The group leader (only) reports</span></span><br><span class="line"><span class="comment"> *		  WIFSIGNALED status to its parent.</span></span><br><span class="line"><span class="comment"> *   coredump	- write a core dump file describing all threads using</span></span><br><span class="line"><span class="comment"> *		  the same mm and then kill all those threads</span></span><br><span class="line"><span class="comment"> *   stop 	- stop all the threads in the group, i.e. TASK_STOPPED state</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</span></span><br><span class="line"><span class="comment"> * Other signals when not blocked and set to SIG_DFL behaves as follows.</span></span><br><span class="line"><span class="comment"> * The job control signals also have other special effects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	+--------------------+------------------+</span></span><br><span class="line"><span class="comment"> *	|  POSIX signal      |  default action  |</span></span><br><span class="line"><span class="comment"> *	+--------------------+------------------+</span></span><br><span class="line"><span class="comment"> *	|  SIGHUP            |  terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGINT            |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGQUIT           |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGILL            |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGTRAP           |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGABRT/SIGIOT    |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGBUS            |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGFPE            |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGKILL           |	terminate(+)	|</span></span><br><span class="line"><span class="comment"> *	|  SIGUSR1           |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGSEGV           |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGUSR2           |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGPIPE           |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGALRM           |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGTERM           |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGCHLD           |	ignore   	|</span></span><br><span class="line"><span class="comment"> *	|  SIGCONT           |	ignore(*)	|</span></span><br><span class="line"><span class="comment"> *	|  SIGSTOP           |	stop(*)(+)  	|</span></span><br><span class="line"><span class="comment"> *	|  SIGTSTP           |	stop(*)  	|</span></span><br><span class="line"><span class="comment"> *	|  SIGTTIN           |	stop(*)  	|</span></span><br><span class="line"><span class="comment"> *	|  SIGTTOU           |	stop(*)  	|</span></span><br><span class="line"><span class="comment"> *	|  SIGURG            |	ignore   	|</span></span><br><span class="line"><span class="comment"> *	|  SIGXCPU           |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGXFSZ           |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGVTALRM         |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGPROF           |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGPOLL/SIGIO     |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGSYS/SIGUNUSED  |	coredump 	|</span></span><br><span class="line"><span class="comment"> *	|  SIGSTKFLT         |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGWINCH          |	ignore   	|</span></span><br><span class="line"><span class="comment"> *	|  SIGPWR            |	terminate	|</span></span><br><span class="line"><span class="comment"> *	|  SIGRTMIN-SIGRTMAX |	terminate       |</span></span><br><span class="line"><span class="comment"> *	+--------------------+------------------+</span></span><br><span class="line"><span class="comment"> *	|  non-POSIX signal  |  default action  |</span></span><br><span class="line"><span class="comment"> *	+--------------------+------------------+</span></span><br><span class="line"><span class="comment"> *	|  SIGEMT            |  coredump	|</span></span><br><span class="line"><span class="comment"> *	+--------------------+------------------+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (+) For SIGKILL and SIGSTOP the action is &quot;always&quot;, not just &quot;default&quot;.</span></span><br><span class="line"><span class="comment"> * (*) Special job control effects:</span></span><br><span class="line"><span class="comment"> * When SIGCONT is sent, it resumes the process (all threads in the group)</span></span><br><span class="line"><span class="comment"> * from TASK_STOPPED state and also clears any pending/queued stop signals</span></span><br><span class="line"><span class="comment"> * (any of those marked with &quot;stop(*)&quot;).  This happens regardless of blocking,</span></span><br><span class="line"><span class="comment"> * catching, or ignoring SIGCONT.  When any stop signal is sent, it clears</span></span><br><span class="line"><span class="comment"> * any pending/queued SIGCONT signals; this happens regardless of blocking,</span></span><br><span class="line"><span class="comment"> * catching, or ignored the stop signal, though (except for SIGSTOP) the</span></span><br><span class="line"><span class="comment"> * default action of stopping the process may happen later or never.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这也意味着：即便没有接收到信号，进程也具备有<strong>识别和处理</strong>这个信号的能力！因为在系统中，已经给每一个进程和信号指定了默认动作！</p><h2 id="1-3-信号产生"><a href="#1-3-信号产生" class="headerlink" title="1.3 信号产生"></a>1.3 信号产生</h2><p>有很多情况会产生信号</p><ul><li>系统接口（kill命令）</li><li>键盘产生（<code>CTRL+R CTRL+\</code>)</li><li>软件条件（进程停止，进程运行完退出）</li><li>硬件异常（比如除0错误）</li></ul><h2 id="1-4-信号动作"><a href="#1-4-信号动作" class="headerlink" title="1.4 信号动作"></a>1.4 信号动作</h2><p>既然有默认动作，那肯定也有非默认的了。实际上，一个进程对信号的处理分为三种不同的方式</p><ul><li>默认动作</li><li>自定义动作</li><li>忽略</li></ul><p>前面提到，一个进程并不一定需要立刻处理一个信号。那么它一定需要有一个办法来记住自己收到的信号。</p><p>而存储信号，是由<strong>进程的PCB</strong>来完成的！</p><p>细心的你可能会发现，进程中的信号一共是64个，刚好是8个字节！我们可以通过<code>位图</code>结构，用两个int类型来存放一个进程收到的各种信号。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211181850945.png" alt="image-20221118185053908"></p><p>在系统内核中，分别有三个表，用来存放进程的信号。而这些信号在位图中的位置，就是在<code>handler</code>方法集中处理动作的<strong>下标</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block - 1表示该进程屏蔽这个信号</span><br><span class="line">pending - 表示进程收到了什么信号，1代表收到且未处理</span><br><span class="line">handler - 每一个信号所对应的处理方法，默认/忽略/自定义</span><br></pre></td></tr></table></figure><p>这一切都是处于进程PCB中的，只有<strong>操作系统</strong>能为我们管理。所以操作系统提供了相关的接口，方便我们对进程信号进行自定义设置。</p><p>pending表中的信号只能保存一个，如果一个信号尚未处理，该位图为1；另外一个相同信号到来的时候，会被直接丢弃掉。（pending表只能记住一个信号）</p><p>handler表中的两个宏如下：</p><ul><li>SIG_DFL 默认方法</li><li>SIG_IGN 忽略</li><li>忽略是信号处理的一种方式，我们能正常收到这个信号，处理方法是不管他</li></ul><hr><h1 id="2-系统接口"><a href="#2-系统接口" class="headerlink" title="2.系统接口"></a>2.系统接口</h1><h2 id="2-1-signal"><a href="#2-1-signal" class="headerlink" title="2.1 signal"></a>2.1 signal</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure><p>这个函数可以用于设置某个信号的处理方法。如果设置成功，则返回值为这个信号的<code>旧处理动作</code>；不过我们一般不关心这个函数的返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">   signal()  returns the previous value of the signal handler, or SIG_ERR on error. In the event of an error, errno is set to indicate the cause.</span><br></pre></td></tr></table></figure><p>比如我们将键盘退出的2号自定义一个回调函数，那么就不能用<code>ctrl+c</code>终止这个进程；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process get signal: &quot;</span> &lt;&lt; signo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将二号信号设置一个回调，其余信号不做处理</span></span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">2</span>, handler);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;进程信号已经设置完了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;进程正在运行: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是系统调用接口，所以我们的当前进程处于什么状态，都不会影响这个回调办法的调用。</p><p>比如<code>CTRL+C</code>的默认策略是终止某个前台进程，但在我们之前的测试中，即便这个进程在sleep或者是在某些共享资源中进行阻塞等待，它依旧能被<code>CTRL+C</code>所发送的2号信号终止。</p><p>同理，在设置了自定义的信号捕捉函数后，我们发送信号的时候，操作系统也能根据当初设置的回调函数（底层有对应的结构体来存储和这个进程相关的信号处理函数）成功将其调用。</p><h3 id="2-1-1-前台进程和后台进程"><a href="#2-1-1-前台进程和后台进程" class="headerlink" title="2.1.1 前台进程和后台进程"></a>2.1.1 前台进程和后台进程</h3><p>这里对<code>ctrl+c</code>的作用进一步描述，它只能用来中断一个<strong>前台进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test <span class="comment">#我们直接运行一个进程，就是前台进程</span></span><br></pre></td></tr></table></figure><p>之前这种直接运行进程，在bash上打印内容的方式，都是一个前台进程，可以用<code>ctrl+c</code>终止；我们可以在后面加上<code>&amp;</code>设置为一个后台进程</p><blockquote><p><code>&amp;</code>只是临时在后台运行，bash关闭后会终止；如果想持久在后台运行，需要在命令最前面加上<code>nohup</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./test &amp;</span><br><span class="line">[1] 8898</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898</span><br><span class="line">进程正在运行: 8898</span><br><span class="line">进程正在运行: 8898</span><br><span class="line">进程正在运行: 8898</span><br><span class="line">^C</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898</span><br><span class="line">进程正在运行: 8898</span><br><span class="line">进程正在运行: 8898</span><br><span class="line">^C</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程正在运行: 8898</span><br><span class="line">进程正在运行: 8898</span><br><span class="line">进程正在运行: 8898</span><br><span class="line">进程正在运行: 8898</span><br></pre></td></tr></table></figure><p>这时候这个进程会一直在当前bash的后台打印，期间我们可以执行其他的命令，但是它依旧会不停的打印。<code>ctrl+c</code>无法终止这个进程，因为它并没有在前台运行！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ps jax | grep <span class="built_in">test</span></span><br><span class="line">22965  8898  8898 22965 pts/22   22965 S     1001   0:00 ./test</span><br></pre></td></tr></table></figure><p><code>ps</code>命令查看，可以看到其运行态为<code>S</code>；而前台进程，运行态为<code>S+</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ps jax | grep <span class="built_in">test</span></span><br><span class="line">22965  9664  9664 22965 pts/22    9664 S+    1001   0:00 ./test</span><br></pre></td></tr></table></figure><p>不过，虽然我们不能用<code>CTRL+C</code>终止这个进程，但使用<code>kill -2</code>发送2号信号，是可以终止掉这个进程的（前提是没有自定义2号信号的方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ 进程信号已经设置完了</span><br><span class="line">进程正在运行: 10464</span><br><span class="line">进程正在运行: 10464</span><br><span class="line">进程正在运行: 10464</span><br><span class="line">进程正在运行: 10464</span><br><span class="line">进程正在运行: 10464</span><br><span class="line">[1]+  Interrupt               ./test</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><h3 id="2-1-2-循环捕捉所有信号"><a href="#2-1-2-循环捕捉所有信号" class="headerlink" title="2.1.2 循环捕捉所有信号"></a>2.1.2 循环捕捉所有信号</h3><p>我们可以用一个<code>for</code>循环，捕捉所有的信号；所有信号的列表可以通过<code>kill -l</code>命令获取到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">//其余代码同上</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对所有的进程信号都设置一个回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sig = <span class="number">1</span>; sig &lt;= <span class="number">31</span>; sig++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">signal</span>(sig, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//signal(2, handler);//将二号信号设置一个回调，其余信号不做处理</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;进程信号已经设置完了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;进程正在运行: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置了之后，对应的信号都会调用我们自己写的函数。但有一个例外，那便是<code>kill -9</code>，九号信号是不能被自定义捕获的！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211181934296.png" alt="image-20221118193453220"></p><h3 id="2-1-3-信号9-x2F-19"><a href="#2-1-3-信号9-x2F-19" class="headerlink" title="2.1.3 信号9&#x2F;19"></a>2.1.3 信号9&#x2F;19</h3><p>在<code>LINUX</code>下，9号信号是一个管理员信号，具有杀死进程的最高权限，<strong>不能被自定义捕捉</strong>！</p><blockquote><p>你想啊，要是linux不对9号进行限制，那我把所有信号都捕捉了，岂不是这个进行没有办法被外部中止了？小病毒啊！😂</p></blockquote><p>和9号信号一样不能被屏蔽的，还有19号信号SIGSTOP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">进程信号已经设置完了</span><br><span class="line">process running: 7779</span><br><span class="line">process running: 7779</span><br><span class="line">process running: 7779</span><br><span class="line">process running: 7779</span><br><span class="line">process running: 7779</span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 ./tsig</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><p>而6号信号可以被捕捉，自定义捕捉方法执行后，进程依旧会退出。参考<code>2.4 abort</code></p><h2 id="2-2-kill"><a href="#2-2-kill" class="headerlink" title="2.2 kill"></a>2.2 kill</h2><p>kill不仅是一个系统命令，同时还有一个系统接口；</p><blockquote><p>一般这种情况，用<code>man kill</code>查看命令的文档，<code>man 2 kill</code>查看接口函数</p></blockquote><p>之前我以为它只是一个用来干掉进程的命令（毕竟kill就是这个意思）现在才知道原来它的作用是给进程发信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kill - send signal to a process</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>它的返回值很简单，如果成功发送信号，则返回0，否则返回-1并且更新errno</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On success (at least one signal was sent), zero is returned.  On error, -1 is returned, and errno is set appropriately</span><br></pre></td></tr></table></figure><p>所以我们可以写一个简单的函数实现，来制作一个自己的kill命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mykill</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; signo-id process-id&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kill(static_cast&lt;<span class="type">pid_t</span>&gt;(atoi(argv[<span class="number">2</span>])), atoi(argv[<span class="number">1</span>])) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;kill: &quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);<span class="comment">//出现错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//argc和argv是命令行参数</span></span><br><span class="line"><span class="comment">//argc传入命令个数，包括./test</span></span><br><span class="line"><span class="comment">//argv传入命令的字符串地址</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    mykill(argc,argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功发送了信号！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211182305081.png" alt="image-20221118230540961"></p><p>如果我们使用错误的时候，则会发送提示信息👍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./mkill</span><br><span class="line">Usage: ./mkill signo-id process-id</span><br></pre></td></tr></table></figure><h3 id="2-2-1-killall"><a href="#2-2-1-killall" class="headerlink" title="2.2.1 killall"></a>2.2.1 killall</h3><p>这个接口可以通过进程名向所有<strong>这个名字的进程</strong>发信号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ killall tsig</span><br></pre></td></tr></table></figure><p>通过测试可以发现，它发送的是第15号信号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">进程信号已经设置完了</span><br><span class="line">process running: 5846</span><br><span class="line">process running: 5846</span><br><span class="line">process 5846 get signal: 15</span><br><span class="line">process running: 5846</span><br><span class="line">process running: 5846</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-raise"><a href="#2-3-raise" class="headerlink" title="2.3 raise"></a>2.3 raise</h2><p>这个系统接口的作用是给自己发信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>返回0代表调用成功，<strong>非0代表失败</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       raise() returns 0 on success, and nonzero for failure.</span><br></pre></td></tr></table></figure><p>用下面的代码进行测试，进程会不断的给自己发送2号信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process get signal: &quot;</span> &lt;&lt; signo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestSignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(<span class="number">2</span>, handler);<span class="comment">//将二号信号设置一个回调，其余信号不做处理</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;进程信号已经设置完了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TestSignal</span>();<span class="comment">//设置对进程信号的屏蔽</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">raise</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时能看到每一秒会调用我们自己写的<code>handler</code>方法，打印收到2号信号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">进程信号已经设置完了</span><br><span class="line">process get signal: 2</span><br><span class="line">process get signal: 2</span><br><span class="line">process get signal: 2</span><br><span class="line">process get signal: 2</span><br><span class="line">process get signal: 2</span><br></pre></td></tr></table></figure><h2 id="2-4-abort"><a href="#2-4-abort" class="headerlink" title="2.4 abort"></a>2.4 abort</h2><p>向自己发送<code>6) SIGABRT</code>信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>还是<code>2.3</code>中的代码，将<code>raise(2)</code>修改为<code>abort()</code>，同时捕捉6号信号。</p><p>此时能观察到我们自己写的handler方法的确被调用了，但是进程依旧终止了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">进程信号已经设置完了</span><br><span class="line">process get signal: 6</span><br><span class="line">Aborted</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><p>这说明6号信号有一个特性：可以被捕捉执行自定义方法，但<strong>执行完毕之后需要退出</strong>！</p><p>相比之下，9号信号是<strong>不能被捕捉</strong></p><hr><h2 id="2-5-alarm"><a href="#2-5-alarm" class="headerlink" title="2.5 alarm"></a>2.5 alarm</h2><p>这个接口的作用是一个定时器，设定秒数，时间到了之后，会收到<code>14) SIGALRM</code>信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">    alarm()  returns  the number of seconds remaining until any previously scheduled alarm was due to be delivered, or zero if there was no previously scheduled alarm.</span><br></pre></td></tr></table></figure><p>用下面的代码进行测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process get signal: &quot;</span> &lt;&lt; signo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestSignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对所有的进程信号都设置一个回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sig = <span class="number">1</span>; sig &lt;= <span class="number">31</span>; sig++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">signal</span>(sig, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;进程信号已经设置完了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TestSignal</span>();<span class="comment">//设置对进程信号的屏蔽</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">4</span>);<span class="comment">//4s后向自己发送14信号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set alarm, sleep&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sleep finish&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在休眠期间，进程收到了14号信号。此时进程并没有退出，而是继续休眠</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">进程信号已经设置完了</span><br><span class="line">set alarm, sleep</span><br><span class="line">process get signal: 14</span><br><span class="line">sleep finish</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><p>如果我们不对14号信号自定义捕捉，则会<strong>直接退出进程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">set alarm, sleep</span><br><span class="line">Alarm clock</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><p>另外需要注意的是，<code>alarm</code>信号本身不会让进程休眠。如果进程在alarm信号设定秒数之前结束，则什么事情都不会发生</p><h2 id="2-6-sigset-t信号集"><a href="#2-6-sigset-t信号集" class="headerlink" title="2.6 sigset_t信号集"></a>2.6 sigset_t信号集</h2><p>这是一个数据类型，其为block&#x2F;pending位图的存储结构，被称作<code>信号集/信号屏蔽字</code></p><p>虽然我们能直接使用这个类型， 但是对这个信号集中的位图操作必须要<strong>调用系统接口</strong>来完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;<span class="comment">//初始化位图(清空)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;<span class="comment">//全部置为1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//设置位图中某一位的数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//删除位图中某一位的数据</span></span><br><span class="line"><span class="comment">//判断某一位信号是否在该集合中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure><h2 id="2-7-sigprocmask"><a href="#2-7-sigprocmask" class="headerlink" title="2.7 sigprocmask"></a>2.7 sigprocmask</h2><p>更改或则获取当前进程的信号屏蔽字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><p>其中第一个参数为处理方法，分别有下面三种</p><ul><li>SIG_BLOCK 将set参数中包含的位数设置为屏蔽</li><li>SIG_UNBLOCK 将set参数中包含的位数解除屏蔽</li><li>SIG_SETMASK 将当前的信号屏蔽字设置为set（覆盖）</li></ul><p>第三个参数是一个输出型参数。如果传入了oldset，那么旧的信号屏蔽字会被放入<code>oldset</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SIG_BLOCK</span><br><span class="line">  The set of blocked signals is the union of the current set and the set argument.</span><br><span class="line"></span><br><span class="line">SIG_UNBLOCK</span><br><span class="line">  The signals in set are removed from the current set of blocked signals.  It is permissible to attempt  to  unblock  a  signal which is not blocked.</span><br><span class="line"></span><br><span class="line">SIG_SETMASK</span><br><span class="line">   The set of blocked signals is set to the argument set.</span><br><span class="line"></span><br><span class="line">If oldset is non-NULL, the previous value of the signal mask is stored in oldset.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       sigprocmask() returns 0 on success and -1 on error.  In the event of an error, errno is set to indicate the cause.</span><br></pre></td></tr></table></figure><p>如果用该接口接触了对某一个信号的阻塞，那么在该函数return前，至少其中一个消息被送达</p><h2 id="2-8-sigpending"><a href="#2-8-sigpending" class="headerlink" title="2.8 sigpending"></a>2.8 sigpending</h2><p>获取当前进程的pending信号集</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数为一个输出型参数。正确获取返回0，否则-1</p><p>这时候我们就可以写一个简单的函数来打印当前进程的信号集了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印信号集的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPending</span><span class="params">(<span class="type">sigset_t</span>* pdg_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sigismember</span>(pdg_ptr,i))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> pdg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;pdg);<span class="comment">//初始化信号集</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sigpending</span>(&amp;pdg)==<span class="number">0</span>)<span class="comment">//获取</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">showPending</span>(pdg);<span class="comment">//获取成功，打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; get pending err&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后可以看到，程序一直在打印当前进程的信号集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">start process: 30981</span><br><span class="line">0000000000000000000000000000000</span><br><span class="line">0000000000000000000000000000000</span><br><span class="line">0000000000000000000000000000000</span><br><span class="line">0000000000000000000000000000000</span><br><span class="line">0000000000000000000000000000000</span><br><span class="line">0000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>不过此时我们并没有对信号进行屏蔽，所以给这个进程发信号会被立即处理（递达）不能在pending表中观察到现象</p><h3 id="2-8-1-屏蔽2号信号"><a href="#2-8-1-屏蔽2号信号" class="headerlink" title="2.8.1 屏蔽2号信号"></a>2.8.1 屏蔽2号信号</h3><p>此时尝试使用<code>sigprocmask</code>来屏蔽某一个信号，再来观察情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//block掉2号信号</span></span><br><span class="line">    <span class="type">sigset_t</span> nsig,osig;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;nsig);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;osig);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;nsig,<span class="number">2</span>);<span class="comment">//在nsig中设置2为1</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;nsig,&amp;osig);<span class="comment">//添加屏蔽</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start process: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">sigset_t</span> pdg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;pdg);<span class="comment">//初始化信号集</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sigpending</span>(&amp;pdg)==<span class="number">0</span>)<span class="comment">//获取</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">showPending</span>(&amp;pdg);<span class="comment">//获取成功，打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; get pending err&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当我们键入<code>CTRL+C</code>的时候，2号信号被block了没有处理，pending表上的2号信号就会变为1，且多次<code>CTRL+C</code>不会有变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">start process: 3608</span><br><span class="line">0000000000000000000000000000000</span><br><span class="line">0000000000000000000000000000000</span><br><span class="line">^C0100000000000000000000000000000</span><br><span class="line">0100000000000000000000000000000</span><br><span class="line">0100000000000000000000000000000</span><br><span class="line">0100000000000000000000000000000</span><br><span class="line">^C0100000000000000000000000000000</span><br><span class="line">0100000000000000000000000000000</span><br></pre></td></tr></table></figure><h3 id="2-8-2-屏蔽所有信号"><a href="#2-8-2-屏蔽所有信号" class="headerlink" title="2.8.2 屏蔽所有信号"></a>2.8.2 屏蔽所有信号</h3><p>可以用一个循环设置所有的信号位，让当前进程屏蔽掉所有信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//block掉所有信号</span></span><br><span class="line">    <span class="type">sigset_t</span> nsig,osig;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;nsig);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;osig);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigaddset</span>(&amp;nsig,i);<span class="comment">//在nsig中设置2为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;nsig,&amp;osig);<span class="comment">//添加屏蔽</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start process: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">sigset_t</span> pdg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;pdg);<span class="comment">//初始化信号集</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sigpending</span>(&amp;pdg)==<span class="number">0</span>)<span class="comment">//获取</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">showPending</span>(&amp;pdg);<span class="comment">//获取成功，打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; get pending err&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后可以观察到，不管给这个进程发几号信号，都会被屏蔽显示在pending集中；9号信号依旧是老大哥，不受影响，依旧能干掉这个进程</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211201832576.png" alt="image-20221120183259473"></p><h3 id="2-8-3-解除屏蔽"><a href="#2-8-3-解除屏蔽" class="headerlink" title="2.8.3 解除屏蔽"></a>2.8.3 解除屏蔽</h3><p>如果在设置屏蔽之后，休眠15s（在此期间接收信号）再接触对信号的屏蔽</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//block掉所有信号</span></span><br><span class="line">    <span class="type">sigset_t</span> nsig,osig;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;nsig);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;osig);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigaddset</span>(&amp;nsig,i);<span class="comment">//在nsig中设置2为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;nsig,&amp;osig);<span class="comment">//添加屏蔽</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">TestSignal</span>();<span class="comment">//设置信号自定义处理</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start process: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">sigset_t</span> pdg;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;pdg);<span class="comment">//初始化信号集</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sigpending</span>(&amp;pdg)==<span class="number">0</span>)<span class="comment">//获取</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">showPending</span>(&amp;pdg);<span class="comment">//获取成功，打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; get pending err&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用osig恢复之前的block表</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;osig,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;pdg);<span class="comment">//初始化信号集</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sigpending</span>(&amp;pdg)==<span class="number">0</span>)<span class="comment">//获取</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">showPending</span>(&amp;pdg);<span class="comment">//获取成功，打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process quit&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就能观察到，信号被立马处理，pending表变为全0</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211201841950.png" alt="image-20221120184159874"></p><h2 id="2-9-sigaction"><a href="#2-9-sigaction" class="headerlink" title="2.9 sigaction"></a>2.9 sigaction</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的参数和<code>signal</code>函数很相似，不过都变为了一个结构体。这个接口也可以用来处理<code>实时信号</code>（不在文本考虑范围内）</p><ul><li>第一个参数是需要处理信号的编号</li><li>第二个参数是自定义的action</li><li>第三个参数是输出型参数，可以获取到旧的处理方法；如果你不关心旧的处理方法，可以将它置为NULL空指针；</li></ul><p>设置成功后返回0，出错返回-1；</p><p>这个结构体的成员如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);<span class="comment">//对信号的处理方法</span></span><br><span class="line">    <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);<span class="comment">//可忽略</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;<span class="comment">//参考2.8中的处理方法</span></span><br><span class="line">    <span class="type">int</span>        sa_flags;<span class="comment">//设为0</span></span><br><span class="line">    <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);<span class="comment">//可忽略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-9-1-基本使用"><a href="#2-9-1-基本使用" class="headerlink" title="2.9.1 基本使用"></a>2.9.1 基本使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印收到的信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; get signal: &quot;</span> &lt;&lt; signo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> nact,oact;</span><br><span class="line">    nact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    nact.sa_handler = handler;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;nact.sa_mask);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigaction</span>(<span class="number">2</span>,&amp;nact,&amp;oact);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;process running: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，我们自定义捕捉了2号信号，成功调用自己的<code>handler</code>方法！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">process running: 15029</span><br><span class="line">process running: 15029</span><br><span class="line">^Cprocess 15029 get signal: 2</span><br><span class="line">process running: 15029</span><br><span class="line">process running: 15029</span><br><span class="line">^Cprocess 15029 get signal: 2</span><br><span class="line">process running: 15029</span><br><span class="line">process running: 15029</span><br><span class="line">process running: 15029</span><br><span class="line">^\Quit</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><p>请注意，信号处理函数在自定义捕获后，进程接收到信号，会调用自定义捕捉的函数，<strong>再继续往后运行</strong>。所以如果你捕获了2号信号，用ctrl+c来退出的时候，理论上也是会调用对象的析构函数的（前提是你的进程里面没有死循环）。</p><h4 id="信号2终止后是否会调用析构函数？"><a href="#信号2终止后是否会调用析构函数？" class="headerlink" title="信号2终止后是否会调用析构函数？"></a>信号2终止后是否会调用析构函数？</h4><p>上面的代码中，我们有死循环，所以再接受到信号处理后，调用完毕函数，就会自动回到死循环的位置。</p><p>在下面的函数中，我们的main是直接在sleep里面阻塞等待的，那么在获取到ctrl+c的信号后，会先调用信号处理函数，再回到main函数中继续往后执行，最终调用对象的析构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的代码省略了</span></span><br><span class="line"><span class="comment">// mytest和myclass是两个类，类中的构造和析构都添加了打印</span></span><br><span class="line"><span class="comment">// mytest中用智能指针包裹了一个myclass对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytest</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> a):_ptr(<span class="built_in">make_shared</span>&lt;myclass&gt;(a))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;init mytest&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">mytest</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destroy mytest&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;myclass&gt; _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RegisterSigTermHandler</span>(); <span class="comment">// 捕捉2号信号</span></span><br><span class="line"></span><br><span class="line">    <span class="function">mytest <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,mytest&gt; tmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmap.<span class="built_in">emplace</span>(i,t1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    tmap.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>); <span class="comment">// 在这里ctrl+c，接收到信号，运行完毕信号处理函数后，会继续往后运行。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-- end --&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的终端输出如下，在接收到信号后，会先调用信号处理函数，打印singal字符串，再返回到main函数，打印<code>-- end --</code>字符串，最终退出main函数，析构掉两个对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./test</span><br><span class="line">init myclass</span><br><span class="line">init mytest</span><br><span class="line">----</span><br><span class="line">destroy mytest</span><br><span class="line">destroy mytest</span><br><span class="line">destroy mytest</span><br><span class="line">destroy mytest</span><br><span class="line">destroy mytest</span><br><span class="line">destroy mytest</span><br><span class="line">----</span><br><span class="line">^Csingal</span><br><span class="line">-- end --</span><br><span class="line">destroy mytest</span><br><span class="line">destroy myclass</span><br></pre></td></tr></table></figure><p>记录这一点，是因为GPT告诉我如果是接收到信号退出是不会执行析构函数的。然而情况并非如此。析构函数依旧会被正常执行！</p><p>那如果有死循环的话，应该如何保证对象的析构能被正常执行呢？</p><ul><li>在死循环中加上<code>if(全局变量)</code>的判断逻辑，并在信号处理函数中设置变量</li><li>在信号处理函数中手动调用一个shutdown函数，为了避免一个函数写两次，可以在析构函数中也调用这个shutdown函数。</li></ul><p>但是，如果你的进程中是多层嵌套循环的话，最终的退出可能没有完全退出，会导致析构函数不被正常调用的资源泄漏问题！如果你需要使用的资源中包含IPC（进程间通信）这些必须要被删除的对象的话，这个问题就需要注意了。</p><blockquote><p>比如你进程退出的时候析构函数没有调用，没有删除掉消息队列，下一次启动的时候，消息队列读端如果先启动，有可能会读取到上次冗余的脏数据。</p><p>所以我们要保证IPC资源能被正常释放。</p></blockquote><h3 id="2-9-2-sa-mask"><a href="#2-9-2-sa-mask" class="headerlink" title="2.9.2 sa_mask"></a>2.9.2 sa_mask</h3><p>这个成员是一个<code>sigset_t</code>类型，用于当处理一个信号的时候，连带屏蔽其他信号；</p><ul><li>当一个进程正在处理A信号的时候，操作系统会把A信号自动添加入Block表，屏蔽该信号（不允许同时处理两个A信号，避免信号A的<strong>递归式处理</strong>）</li></ul><p>如果你想在处理2号信号的时候，阻塞掉3、4、5号信号，就可以对<code>sa_mask</code>进行设置，设置方法参考<code>2.8</code>的操作</p><p>因为现在我演示的自定义方法只是一个再简单不过的示例，实际上进程收到信号的时候需要根据不同情况进行不同的自定义处理，这些自定义处理的过程可能会很长。此时就可以block掉其他的信号，<strong>不让它们影响当前进程运行的自定义方法</strong></p><h1 id="3-软件崩溃的本质"><a href="#3-软件崩溃的本质" class="headerlink" title="3.软件崩溃的本质"></a>3.软件崩溃的本质</h1><p>之前我们经常会遇到软件出错奔溃的情况，那么奔溃的本质是什么呢？</p><h2 id="3-1-情景演示"><a href="#3-1-情景演示" class="headerlink" title="3.1 情景演示"></a>3.1 情景演示</h2><p>用下面的一个<strong>除零错误</strong>作为演示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; get signal: &quot;</span> &lt;&lt; signo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestSignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对所有的进程信号都设置一个回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sig = <span class="number">1</span>; sig &lt;= <span class="number">31</span>; sig++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">signal</span>(sig, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;进程信号已经设置完了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TestSignal</span>();</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c = a / b; <span class="comment">// C++的除0不是异常，不会抛出</span></span><br><span class="line">        <span class="comment">//所以会直接linux系统运行报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;a/0 err&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base catch&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行了之后，该进程会一直收到8号信号，直到我们手动kill掉这个进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process 3947 get signal: 8</span><br><span class="line">process 3947 get signal: 8</span><br><span class="line">process 3947 get signal: 8</span><br><span class="line">process 3947 get signal: 8</span><br><span class="line">process 3947 get signal: 8</span><br><span class="line">process 3947 get signal: 8Killed</span><br></pre></td></tr></table></figure><p>你可能会觉得奇怪，不是用<code>try/catch</code>进行了异常处理吗？为什么没有用呢？</p><p>那是因为，在C++中，并<strong>不会将除零错误当作一个异常</strong>进行处理！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031201497.gif" alt="QQ图片20220413084241"></p><hr><p>我们自定义捕捉了8号信号，没能让进程终止。但此时这个进程已经出现了一个严重的bug，操作系统就会一直给进程发这个信号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">Floating point exception</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><p>相比之下，如果不自定义捕捉，则会<strong>直接报错+终止进程</strong>；</p><p>8号信号是<code>SIGFPE</code>，FPE即为<code>Floating point exception</code>的缩写！</p><h2 id="3-2-说明"><a href="#3-2-说明" class="headerlink" title="3.2 说明"></a>3.2 说明</h2><p>崩溃的本质，是该进程收到了异常信号，从而终止。</p><p>以除零错误为例，CPU内部会有一个状态寄存器，检测到用户进行除零计算的时候，会将状态寄存器设置为<strong>浮点数错误</strong>。当操作系统检测到这个错误的时候，便会向当前<strong>正在运行的进程</strong>发送8号信号。而我们的进程在收到信号的时候，会处理这个信号，默认的处理方法就是终止进程！</p><p>同理，当我们访问一个野指针的时候，操作系统能在虚拟地址转换的时候发现这个问题，向我们的进程发送11号信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TestSignal</span>();</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    *p=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>11) SIGSEGV</code>代表<strong>段错误</strong>，写OJ题目的时候这个报错很常见😂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process 6754 get signal: 11</span><br><span class="line">process 6754 get signal: 11</span><br><span class="line">process 6754 get signal: 11</span><br><span class="line">process 6754 get signal: 11</span><br><span class="line">process 6754 get signal: 11Killed</span><br></pre></td></tr></table></figure><h1 id="4-coredump"><a href="#4-coredump" class="headerlink" title="4.coredump"></a>4.coredump</h1><p>在<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/127331290?spm=1001.2014.3001.5501">进程控制</a>的博客中，提到当进程因为信号终止的时候，其status中的0-7位会是对应的终止信号，而第8位是该进程的<code>core dump</code>标记位</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211201106597.png" alt="image-20221120110639470"></p><p>在<a href="#jump1">1.2</a>贴出来的源码注释中可以看到，有不少信号的默认动作是进行<code>core dump</code>，比如8号信号。那么这个东西到底是什么玩意呢？</p><hr><p>通过fork创建子进程，让子进程除零产生8号信号，子进程退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">10</span>/b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(id,&amp;status,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//打印子进程的退出信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exitcode:%d signo:%d coredump: %d\n&quot;</span>,(status&gt;&gt;<span class="number">8</span>)&amp;&amp;<span class="number">0xff</span>,status&amp;<span class="number">0x7f</span>,(status&gt;&gt;<span class="number">7</span>)&amp;<span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以观察到，coredump标记位为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">exitcode:0 signo:8 coredump: 0</span><br></pre></td></tr></table></figure><h2 id="4-1-开启该功能"><a href="#4-1-开启该功能" class="headerlink" title="4.1 开启该功能"></a>4.1 开启该功能</h2><p>默认情况下，我们云服务器的core dump功能是被关闭的，需要我们手动开启；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ <span class="built_in">ulimit</span> -a</span><br><span class="line">core file size          (blocks, -c) 0  <span class="comment">#coredump功能被关闭了</span></span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 14691</span><br><span class="line">max locked memory       (kbytes, -l) unlimited</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 100002</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 14691</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><p>使用<code>ulimit -a</code>命令指定<code>core file</code>的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -c 10000</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 10000</span><br></pre></td></tr></table></figure><p>再次运行刚刚的代码，可以看到标记位为1，并且产生了一个<code>core.27908</code>文件，这个文件的后缀是产生coredump文件的进程pid</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">exitcode:0 signo:8 coredump: 1</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ll</span><br><span class="line">total 292</span><br><span class="line">-rw------- 1 muxue muxue 593920 Nov 20 12:34 core.27908</span><br><span class="line">-rw-rw-r-- 1 muxue muxue    194 Nov 20 10:31 makefile</span><br><span class="line">-rw-rw-r-- 1 muxue muxue    601 Nov 20 09:57 mkill.cc</span><br><span class="line">-rw-rw-r-- 1 muxue muxue    203 Nov 20 09:56 test.cc</span><br><span class="line">-rwxrwxr-x 1 muxue muxue  13768 Nov 20 12:34 tsig</span><br><span class="line">-rw-rw-r-- 1 muxue muxue   1772 Nov 20 12:34 tsignal.cpp</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><p>vscode告诉我们这个不是一个普通的文本文件</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211201238772.png" alt="image-20221120123842724"></p><p>这个现象告诉我们，默认动作是coredump的信号，会让进程退出，将coredump标记位置为1并且产生一个<code>core.</code>文件</p><h2 id="4-2-使用coredump"><a href="#4-2-使用coredump" class="headerlink" title="4.2 使用coredump"></a>4.2 使用coredump</h2><p>这个功能会将进程在运行中产生异常的上下文数据，执行core dump（核心转储）为一个文件，方便我们debug</p><p>如下所示，使用<code>-g</code>命令以debug模式编译<code>test.cc</code>,运行的时候可以看到除零错误之后跟了一个<code>(core dumped)</code>提示我们进行了core dump操作，对应产生了一个<code>core.</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ g++ test.cc -g -o <span class="built_in">test</span></span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./test</span><br><span class="line">Floating point exception (core dumped)</span><br></pre></td></tr></table></figure><p>这时候打开gdb，输入<code>core-file 文件名</code>加载文件，就可以直接定位到出错代码的位置！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ gdb <span class="built_in">test</span></span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span><br><span class="line">and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-redhat-linux-gnu&quot;</span>.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /home/muxue/git/linux/code/22-11-16_signal/test...done.</span><br><span class="line">(gdb) core-file core.31997</span><br><span class="line">[New LWP 31997]</span><br><span class="line"></span><br><span class="line">Core was generated by `./test<span class="string">&#x27;.</span></span><br><span class="line"><span class="string">Program terminated with signal 8, Arithmetic exception.</span></span><br><span class="line"><span class="string">#0  0x000000000040065c in main () at test.cc:13</span></span><br><span class="line"><span class="string">13          int a=10/0;</span></span><br><span class="line"><span class="string">Missing separate debuginfos, use: debuginfo-install glibc-2.17-326.el7_9.x86_64 libgcc-4.8.5-44.el7.x86_64</span></span><br><span class="line"><span class="string">(gdb)</span></span><br><span class="line"><span class="string">(gdb)</span></span><br></pre></td></tr></table></figure><p>这可比我们手动debug找错误方便多了</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031202739.gif" alt="QQ图片20220419102702"></p><h2 id="4-3-为什么默认关闭？"><a href="#4-3-为什么默认关闭？" class="headerlink" title="4.3 为什么默认关闭？"></a>4.3 为什么默认关闭？</h2><p>你可能会觉得，这个功能不挺好的吗，为啥默认没有开启呢？</p><p>先来看看这个文件的大小，足足有<code>580KB</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ <span class="built_in">ls</span> -lht</span><br><span class="line">total 292K</span><br><span class="line">-rw-rw-r-- 1 muxue muxue 1.8K Nov 20 12:37 tsignal.cpp</span><br><span class="line">-rw------- 1 muxue muxue 580K Nov 20 12:34 core.27908</span><br></pre></td></tr></table></figure><p>一般而言，服务端运行的一些进程，都需要保持稳定性。比如B站的服务器挂了，第一时间要做的是<strong>重启服务进程</strong>（并不是重启服务器机器）</p><p>如果设置了这个coredump，当服务器进程因为错误退出的时候，会生成一个<code>core.</code>文件；这时候有一个守护进程（用来监视并及时重启服务器进程）发现服务器进程退出了，就会重启它。</p><p>这时候又遇到了刚刚那个bug，服务器进程又退出了，守护进程又来重启它……</p><p>如此往复，就会生成非常非常多的<code>core.</code>文件，塞满我们的硬盘。</p><p>对于<strong>求稳</strong>为主的服务器而言，这可不是一个好事。所以云服务器上默认禁止了这个功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -c 0</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br></pre></td></tr></table></figure><p>用<code>umlimit -c 0</code>指定大小为0关闭该功能</p><hr><h1 id="5-进程处理信号"><a href="#5-进程处理信号" class="headerlink" title="5.进程处理信号"></a>5.进程处理信号</h1><p>前面八八了这么一大堆，进程到底是什么时候来处理信号的呢？</p><ul><li>开门见山：进程从内核态切换成用户态的时候，处理信号</li></ul><h2 id="5-1-内核态-x2F-用户态"><a href="#5-1-内核态-x2F-用户态" class="headerlink" title="5.1 内核态&#x2F;用户态"></a>5.1 内核态&#x2F;用户态</h2><p>在程序地址空间的博客中，提到了每一个进程都有1gb的内核空间；该内核空间用于内核级页表的映射，即映射操作系统的物理内存！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211201852239.png" alt="image-20221120185234159"></p><p>有内核级页表的存在，无论进程怎么切换，都能找到操作系统内核的代码和数据，前提是有权限访问。</p><ul><li>CPU中的CR3状态寄存器会标识当前进程处于内核态还是用户态</li><li>内核态可以访问所有代码和数据，权限最高</li><li>用户态只能访问当前进程自己的数据</li></ul><p>当我们进程需要执行内核接口的时候，就需要将进程切换为内核态；运行完毕之后，切换回用户态。</p><p>当我们进程出现了异常，会从用户态切换成内核态，由操作系统检测相关异常并向进程发送对应信号。</p><p>当我们进程的<strong>时间片</strong>到了（需要切换进程）也会从用户态转为内核态，由操作系统来进行进程切换。</p><h2 id="5-2-信号检测"><a href="#5-2-信号检测" class="headerlink" title="5.2 信号检测"></a>5.2 信号检测</h2><p>当进程从内核态切换回用户态的时候，<strong>会进行信号的检测和处理</strong>。此时判断pending表中是否有未处理信号，以及该信号是否有被block。如果一个信号没有被block，则将该信号递达给进程，执行对应的处理方法</p><ul><li>执行用户的自定义方法时，应该以什么身份执行？</li></ul><p>注意，当我们给一个信号指定了自定义处理方法，就代表该信号的处理方法是<strong>用户提供的</strong>。此时需要以用户的身份去执行这个代码，才能正确访问用户级页表。</p><p>这么做也能<strong>避免恶意代码</strong>的注入。如果有人在自定义方法中写一个修改系统内核的恶意代码，也能被操作系统发现并阻止。</p><p>这个过程可以用下面这张图来解释（并非完整过程，仅供参考理解）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211211425321.png" alt="image-20221121142458166"></p><p>每次处理完信号后，会返回用户进程，从上一次中断的位置开始继续往后运行</p><h1 id="6-可重入函数"><a href="#6-可重入函数" class="headerlink" title="6.可重入函数"></a>6.可重入函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Node* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	p-&gt;next=head;</span><br><span class="line">	head=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数是一个非常简单的链表头插函数</p><p>如果我们这个头插函数处理的是一个全局的链表，就可能会因为用户态、内核态的切换，<strong>函数重入造成错误</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211212114593.png" alt="image-20221121211426452"></p><p>所以<code>insert</code>就是一个<strong>不可重入函数</strong>！除了这个头插，还有一些其他的函数也符合这个特效：</p><ul><li>调用了malloc或者free（可能会多次malloc和多次free）</li><li>调用了I&#x2F;O库的函数</li><li>绝大多数库函数都是不可重入的，比如C++的STL库</li></ul><p>依此类推，如果一个函数只访问他自己的局部变量，不会影响其他参数。那么他就是一个<strong>可重入函数</strong></p><h2 id="6-1-原子操作"><a href="#6-1-原子操作" class="headerlink" title="6.1 原子操作"></a>6.1 原子操作</h2><p>所谓原子操作是指不会被 <code>线程调度</code> 机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 <code>context switch （切换到另一个线程）</code></p><ul><li>如果一个函数进行了对全局变量的原子操作，那么它也是<strong>可重入</strong>的函数。因为原子操作不包含中间态</li><li>如果一个函数对全局变量进行了非原子操作（比如上面的链表头插）那么他就是一个不可重入函数</li></ul><h1 id="7-volatile"><a href="#7-volatile" class="headerlink" title="7.volatile"></a>7.volatile</h1><p>之前的学习中就已经知道，这个关键字的作用是每一次访问变量的时候，<strong>都必须要去内存中取</strong>。</p><hr><p>假设我们进程中需要通过一个<strong>全局变量</strong>进行<strong>条件判断</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(flags)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们<strong>自定义捕捉</strong>了一个信号，收到该信号的时候，会修改flag，执行if&#x2F;else语句中对应的代码。</p><p>由于<strong>编译器的优化问题</strong>，每一次访问flag的时候，它可能不会每次都去内存中取，就会出现一个问题</p><ul><li>寄存器中 flag&#x3D;0</li><li>经过自定义捕捉函数处理，内存中 flag&#x3D;1</li></ul><p>这两个flag在if条件中会导向不同的结果！</p><p>为了避免这种可能因为平台、编译器、优化问题导致的代码bug，我们需要告诉所有编译器，不准对flag变量做任何优化处理，必须要老老实实的去内存中拿这个变量的数据！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//volatile保持内存的可见性</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> flag = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="7-1-示例"><a href="#7-1-示例" class="headerlink" title="7.1 示例"></a>7.1 示例</h2><blockquote><p>gcc编译器可以通过<code>-O2</code>指定较高的优化等级</p></blockquote><p>以下面的代码为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保持内存的可见性</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n更改flags: 0-&gt;1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process start %d\n&quot;</span>,getpid());</span><br><span class="line">    signal(<span class="number">2</span>, handler);<span class="comment">//自定义捕捉2号信号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!flag)</span><br><span class="line">        ;<span class="comment">//啥事不干的循环</span></span><br><span class="line"></span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;process exit!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，键入<code>CTRL+C</code>，你会发现进程依旧没有退出！理论上来说<code>flags=1</code>，<code>!flags</code>为假，应终止循环，退出进程才对！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test -O2</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./test</span><br><span class="line">process start 22333</span><br><span class="line">^C</span><br><span class="line">更改flags: 0-&gt;1</span><br><span class="line">^C</span><br><span class="line">更改flags: 0-&gt;1</span><br><span class="line">^C</span><br><span class="line">更改flags: 0-&gt;1</span><br><span class="line">^C</span><br><span class="line">更改flags: 0-&gt;1</span><br><span class="line">^\Quit</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$</span><br></pre></td></tr></table></figure><p>如果我们加上<code>volatile</code>关键字，则不会出现这个问题，进程能够正常退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test -O2</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./test</span><br><span class="line">process start 23086</span><br><span class="line">^C</span><br><span class="line">更改flag: 0-&gt;1</span><br><span class="line">process exit!</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$</span><br></pre></td></tr></table></figure><p>去掉gcc编译器的优化参数，去掉<code>volatile</code>关键字，会发现进程也能正常退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ gcc test.c -o test</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$ ./test</span><br><span class="line">process start 23224</span><br><span class="line">^C</span><br><span class="line">更改flag: 0-&gt;1</span><br><span class="line">process exit!</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-21_volatile]$</span><br></pre></td></tr></table></figure><p>这就是编译器优化不同的影响！加上volatile关键字能避免这个问题，使代码运行能有唯一结果！</p><h1 id="8-子进程发送信号"><a href="#8-子进程发送信号" class="headerlink" title="8.子进程发送信号"></a>8.子进程发送信号</h1><p><strong>当子进程的状态变化的时候</strong>，会向父进程发送17号信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testfork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;chlid process: &quot;</span> &lt;&lt;<span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">10</span>/b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TestSignal</span>();</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(id,&amp;status,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//打印子进程的退出信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exitcode:%d signo:%d coredump: %d\n&quot;</span>,(status&gt;&gt;<span class="number">8</span>)&amp;&amp;<span class="number">0xff</span>,status&amp;<span class="number">0x7f</span>,(status&gt;&gt;<span class="number">7</span>)&amp;<span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察结果，可以看到父进程收到了子进程的17号信号，此时子进程因为<strong>错误退出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$ ./tsig</span><br><span class="line">进程信号已经设置完了</span><br><span class="line">chlid process: 25319</span><br><span class="line">process 25318 get signal: 17</span><br><span class="line">exitcode:0 signo:8 coredump: 0</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-16_signal]$</span><br></pre></td></tr></table></figure><p>除了退出时会发送信号，子进程暂停、继续运行的时候，都会向父进程发送信号</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211212153388.png" alt="image-20221121215300234"></p><h2 id="8-1-父进程回收子进程"><a href="#8-1-父进程回收子进程" class="headerlink" title="8.1 父进程回收子进程"></a>8.1 父进程回收子进程</h2><p>既然父进程能收取到子进程发送的信号，那么我们自定义捕捉17号信号，在其中调用<code>waitpid</code>，即可在子进程出错或执行完毕需要退出的时候，进行父进程回收</p><blockquote><p>这样就不需要在main函数中进行主动wait了</p></blockquote><p>操作并不难，我们只需要将17号信号进行自定义捕捉，在捕捉函数中执行<code>waitpid</code>进行等待即可</p><ul><li>注意：这里的waitpid必须使用<code>WNOHANG</code>进行非阻塞等待</li><li>当父进程正在阻塞等待子进程A的时候，它在处理17号信号，新的17号信号无法收到</li><li>这就会导致在A之后种子的子进程，无法向父进程发送有效的17号信号</li><li>从而出现了僵尸进程（未回收的子进程）</li></ul><p>使用<strong>非阻塞等待</strong>，即可以避免此问题，又能让父进程在等待的过程中处理自己的其他工作，一举两得。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FreeChld</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(signo == SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果没有子进程了，waitpid就会调用失败</span></span><br><span class="line">        <span class="type">pid_t</span> id = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>, WNOHANG); <span class="comment">// 非阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父进程等待成功, child pid: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还有子进程没有退出</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;尚有未退出的子进程，父进程继续运行&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//退出等待子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父进程等待所有子进程结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, FreeChld);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> id = fork();</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//子进程</span></span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;子进程 pid: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; cnt: &quot;</span> &lt;&lt; cnt-- &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子进程退出，进入僵尸状态: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;父进程正在运行: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下右图中，第0个子进程退出进入将是状态，父进程收到17号信号，就开始回收子进程。此时还有4个子进程没有运行完毕，父进程会继续运行，等待其他子进程结束</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202212141036517.png" alt="image-20221214103626344"></p><p>当所有子进程都等待结束了，<code>waitpid</code>返回-1让父进程退出回收子进程的循环，现在就只有父进程自己在干活了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :; <span class="keyword">do</span> ps jax | <span class="built_in">head</span> -1 &amp;&amp; ps jax | grep <span class="built_in">test</span> | grep -v grep;<span class="built_in">sleep</span> 1; <span class="built_in">echo</span> <span class="string">&quot;########################&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>反应到监控信息上，父进程先是创建了5个子进程</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202212141039571.png" alt="image-20221214103938520"></p><p>随后当第一个子进程退出的时候，父进程开始回收子进程。这里也能观测到，回收成功，并没有出现<strong>僵尸状态</strong>的子进程。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202212141042670.png" alt="image-20221214104215559"></p><h2 id="8-2-父进程忽略子进程"><a href="#8-2-父进程忽略子进程" class="headerlink" title="8.2 父进程忽略子进程"></a>8.2 父进程忽略子进程</h2><p>前面提到过，<code>SIG_IGN</code>的作用是忽略这个子进程；你可能会想，这不对啊，忽略了子进程的信号，那岂不是父进程不想搭理子进程了吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*	|  SIGCHLD           |	ignore   	|</span><br></pre></td></tr></table></figure><p>查<code>1.2</code>表你还会发现，SIGCHLD的<strong>默认动作</strong>不就是忽略吗？自己设置一下是不是多此一举？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD, SIG_IGN);</span><br></pre></td></tr></table></figure><p>然并不是这样，对于<code>SIGCHLD</code>17号信号而言，我们给父进程设置了手动忽略后，子进程退出的时候将<strong>自动被回收</strong></p><p>这么做的前提，是父进程不需要和子进程在回收资源的时候进行处理，说人话就是，<strong>只要父进程不想管任何子进程的工作</strong>，那就可以直接把17号信号手动设置成<code>SIG_IGN</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031201497.gif" alt="QQ图片20220413084241"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>进程信号到这里就基本over了，干货满满！</p><p>如果对你有帮助，还请点个赞吧！！！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031202863.gif" alt="QQ图片20220416140203"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/2620423276/">https://blog.musnow.top/posts/2620423276/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm17.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://ifdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2359019899/" title="【C++】并查集"><img class="cover" src="/img/bg/gm5.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【C++】并查集</div></div></a></div><div class="next-post pull-right"><a href="/posts/3323274806/" title="【Linux】进程通信 | 共享内存 | 信号量"><img class="cover" src="/img/bg/gm18.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Linux】进程通信 | 共享内存 | 信号量</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1845419185/" title="【Linux】进程地址空间"><img class="cover" src="https://img.musnow.top/i/2023/02/202210071510984.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-07</div><div class="title">【Linux】进程地址空间</div></div></a></div><div><a href="/posts/3785030062/" title="【Linux】进程概念"><img class="cover" src="/img/bg/gm15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-31</div><div class="title">【Linux】进程概念</div></div></a></div><div><a href="/posts/3971907787/" title="【Linux】进程通信 | 管道"><img class="cover" src="/img/bg/gm8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-11</div><div class="title">【Linux】进程通信 | 管道</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">415</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E5%8F%B7"><span class="toc-text">1.什么是信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BD%95%E4%B8%BA%E5%BC%82%E6%AD%A5"><span class="toc-text">1.1 何为异步?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">1.2 信号的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F"><span class="toc-text">1.3 信号产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E4%BF%A1%E5%8F%B7%E5%8A%A8%E4%BD%9C"><span class="toc-text">1.4 信号动作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.系统接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-signal"><span class="toc-text">2.1 signal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%89%8D%E5%8F%B0%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B"><span class="toc-text">2.1.1 前台进程和后台进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%BE%AA%E7%8E%AF%E6%8D%95%E6%8D%89%E6%89%80%E6%9C%89%E4%BF%A1%E5%8F%B7"><span class="toc-text">2.1.2 循环捕捉所有信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E4%BF%A1%E5%8F%B79-x2F-19"><span class="toc-text">2.1.3 信号9&#x2F;19</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-kill"><span class="toc-text">2.2 kill</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-killall"><span class="toc-text">2.2.1 killall</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-raise"><span class="toc-text">2.3 raise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-abort"><span class="toc-text">2.4 abort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-alarm"><span class="toc-text">2.5 alarm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-sigset-t%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">2.6 sigset_t信号集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-sigprocmask"><span class="toc-text">2.7 sigprocmask</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-sigpending"><span class="toc-text">2.8 sigpending</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-%E5%B1%8F%E8%94%BD2%E5%8F%B7%E4%BF%A1%E5%8F%B7"><span class="toc-text">2.8.1 屏蔽2号信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-2-%E5%B1%8F%E8%94%BD%E6%89%80%E6%9C%89%E4%BF%A1%E5%8F%B7"><span class="toc-text">2.8.2 屏蔽所有信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-3-%E8%A7%A3%E9%99%A4%E5%B1%8F%E8%94%BD"><span class="toc-text">2.8.3 解除屏蔽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-sigaction"><span class="toc-text">2.9 sigaction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">2.9.1 基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B72%E7%BB%88%E6%AD%A2%E5%90%8E%E6%98%AF%E5%90%A6%E4%BC%9A%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">信号2终止后是否会调用析构函数？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-2-sa-mask"><span class="toc-text">2.9.2 sa_mask</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E5%B4%A9%E6%BA%83%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">3.软件崩溃的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%83%85%E6%99%AF%E6%BC%94%E7%A4%BA"><span class="toc-text">3.1 情景演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%AF%B4%E6%98%8E"><span class="toc-text">3.2 说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-coredump"><span class="toc-text">4.coredump</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%BC%80%E5%90%AF%E8%AF%A5%E5%8A%9F%E8%83%BD"><span class="toc-text">4.1 开启该功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BD%BF%E7%94%A8coredump"><span class="toc-text">4.2 使用coredump</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E5%85%B3%E9%97%AD%EF%BC%9F"><span class="toc-text">4.3 为什么默认关闭？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="toc-text">5.进程处理信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%86%85%E6%A0%B8%E6%80%81-x2F-%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-text">5.1 内核态&#x2F;用户态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E4%BF%A1%E5%8F%B7%E6%A3%80%E6%B5%8B"><span class="toc-text">5.2 信号检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-text">6.可重入函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-text">6.1 原子操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-volatile"><span class="toc-text">7.volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%A4%BA%E4%BE%8B"><span class="toc-text">7.1 示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">8.子进程发送信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-text">8.1 父进程回收子进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%BF%BD%E7%95%A5%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-text">8.2 父进程忽略子进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4252209616/" title="【Mac】分享一个mac下自动提交hexo的脚本">【Mac】分享一个mac下自动提交hexo的脚本</a><time datetime="2024-11-15T13:15:00.000Z" title="发表于 2024-11-15 21:15:00">2024-11-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3646407477/" title="【Mac】使用AIDente限制mac最大充电电量">【Mac】使用AIDente限制mac最大充电电量</a><time datetime="2024-11-14T13:15:00.000Z" title="发表于 2024-11-14 21:15:00">2024-11-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2620921861/" title="【Linux】如何将一个命令要求的输入通过管道传递？">【Linux】如何将一个命令要求的输入通过管道传递？</a><time datetime="2024-11-06T13:46:11.000Z" title="发表于 2024-11-06 21:46:11">2024-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1547470773/" title="【Python】从peewee切换到tortoise-orm异步orm库">【Python】从peewee切换到tortoise-orm异步orm库</a><time datetime="2024-10-23T22:58:58.000Z" title="发表于 2024-10-24 06:58:58">2024-10-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>