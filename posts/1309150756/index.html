<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Linux】线程概念 | 互斥 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="千呼万唤始出来，终于到多线程方面的学习了！"><meta property="og:type" content="article"><meta property="og:title" content="【Linux】线程概念 | 互斥"><meta property="og:url" content="https://blog.musnow.top/posts/1309150756/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="千呼万唤始出来，终于到多线程方面的学习了！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm1.jpg"><meta property="article:published_time" content="2022-12-23T08:30:16.000Z"><meta property="article:modified_time" content="2023-03-29T08:18:13.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Linux"><meta property="article:tag" content="线程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm1.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/1309150756/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Linux】线程概念 | 互斥",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-03-29 16:18:13"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">288</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm1.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Linux】线程概念 | 互斥</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-23T08:30:16.000Z" title="发表于 2022-12-23 16:30:16">2022-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-29T08:18:13.000Z" title="更新于 2023-03-29 16:18:13">2023-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%8E%A9%E4%B8%8ALinux/">玩上Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【Linux】线程概念 | 互斥"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>千呼万唤始出来，终于到多线程方面的学习了！</p><span id="more"></span><blockquote><p>所用系统<code>Centos7.6</code> 本文的源码👉<a target="_blank" rel="noopener" href="https://gitee.com/musnow/raspberry-practice/tree/master/code/22-12-15_pthread">【传送门】</a></p></blockquote><p>[TOC]</p><h1 id="1-线程的概念"><a href="#1-线程的概念" class="headerlink" title="1.线程的概念"></a>1.线程的概念</h1><p>在之前的linux学习中，已经接触过了进程的概念，进程由一个<code>task_struct</code>结构体在操作系统中进行描述，CPU在执行的时候，会依照进程时间片进行轮询调度，让每一个进程的代码都得以推进，实现多个进程的同时运行</p><p>而线程，可以理解为是一种轻量化的进程，每一个进程都可以创建多个线程，并行执行不同的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程:线程 = 1:N</span><br></pre></td></tr></table></figure><p>在之前的多进程操作中，我们使用<code>fork</code>接口创建子进程，通过<code>if/else</code>语句判断，实现对特定执行流的划分</p><ul><li>创建子进程时，需要拷贝一份<code>task_struct/mm_struct</code>并创建页表</li><li>当子进程修改了一部分变量，会发生<strong>写时拷贝</strong>，修改页表在物理内存上的映射</li></ul><p>可以看到，当我们需要创建一个<strong>新进程</strong>的时候，操作系统需要做不少的工作</p><p><img src="https://img.musnow.top/i/2023/02/202212151917491.png" alt="image-20221215191721355"></p><h2 id="1-1-执行流"><a href="#1-1-执行流" class="headerlink" title="1.1 执行流"></a>1.1 执行流</h2><p>让我们康康执行流这一概念：</p><ul><li>单执行流进程：内部只有一个执行流的进程</li><li>多执行流进程：内部有多个执行流的进程</li></ul><p><code>进程=内核数据结构+代码和数据</code>，在内核视角中，进程是<code>承担分配系统资源的基本实体</code>（进程的基座属性）</p><ul><li>进程：向系统申请资源的基本单位（系统分配）</li><li>线程：系统调度的基本单位</li></ul><hr><h2 id="1-2-线程创建时做了什么？"><a href="#1-2-线程创建时做了什么？" class="headerlink" title="1.2 线程创建时做了什么？"></a>1.2 线程创建时做了什么？</h2><p>那线程的创建需要做什么呢？</p><blockquote><p>不同操作系统的实现不同，一般用<code>tcb</code>指代描述线程的结构体</p></blockquote><p>在linux中，没有进程和线程在概念上的区分，其以<strong>执行流</strong>为基础，线程只是简单的对<code>task_strcut</code>进行了二次封装；<strong>线程是在进程内部运行的执行流</strong></p><ul><li>说人话：linux下的线程是<strong>用进程模拟</strong>的</li><li>换句话：linux下的进程也是一种线程，但是其<strong>只有一个执行流</strong></li><li>对于CPU而言，其看到的<code>task_struct</code>都是一个执行流</li></ul><p>而创建线程时也有说法，线程隶属于某一个进程下，并不是独立的子进程，所以不需要创建新的<code>mm_struct</code>和页表映射，创建的效率高于子进程。只需要将<code>task_struct</code>指向原有进程的<code>mm_struct</code>和页表即可。</p><p><img src="https://img.musnow.top/i/2023/02/202212151923818.png" alt="image-20221215192345757"></p><p>同样的，CPU在推行多线程操作的时候，无须执行pcb切换，就能实现<strong>单进程多个线程操作</strong>的同时进行，执行效率变高！</p><blockquote><p>线程是一种 <code>Light weight process 轻量级进程</code>，简称<code>LWP</code>；是现代linux对线程提供的原生支持</p></blockquote><h2 id="1-3-内核源码中的体现"><a href="#1-3-内核源码中的体现" class="headerlink" title="1.3 内核源码中的体现"></a>1.3 内核源码中的体现</h2><p>在<code>task_strcut</code>结构体中，有这么一个字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br></pre></td></tr></table></figure><p>转到定义，其内部都是一些<strong>寄存器</strong>信息，用于标识这个线程的基本信息。这也是linux中没有<strong>单独</strong>实现线程tcb的体现，而是用<code>task_struct</code>来模拟的（<code>task_struct</code>中包含线程的信息）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Cached TLS descriptors: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>	<span class="title">tls_array</span>[<span class="title">GDT_ENTRY_TLS_ENTRIES</span>];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sp0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sysenter_cs;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		usersp;	<span class="comment">/* Copy from PDA */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		es;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		ds;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		fsindex;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		gsindex;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		ip;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		fs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		gs;</span><br><span class="line">	<span class="comment">/* Hardware debugging registers: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg1;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg2;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg3;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg6;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		debugreg7;</span><br><span class="line">	<span class="comment">/* Fault info: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		cr2;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		trap_no;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		error_code;</span><br><span class="line">	<span class="comment">/* floating point and extended processor state */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">thread_xstate</span>	*<span class="title">xstate</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="comment">/* Virtual 86 mode info */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm86_struct</span> __<span class="title">user</span> *<span class="title">vm86_info</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		screen_bitmap;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		v86flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		v86mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		saved_sp0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		saved_fs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		saved_gs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* IO permissions: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*io_bitmap_ptr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		iopl;</span><br><span class="line">	<span class="comment">/* Max allowed port in the bitmap, in bytes: */</span></span><br><span class="line">	<span class="type">unsigned</span>		io_bitmap_max;</span><br><span class="line"><span class="comment">/* MSR_IA32_DEBUGCTLMSR value to switch in if TIF_DEBUGCTLMSR is set.  */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	debugctlmsr;</span><br><span class="line">	<span class="comment">/* Debug Store context; see asm/ds.h */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ds_context</span>	*<span class="title">ds_ctx</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们创建一个线程时，Linux内核会为该线程分配一个唯一的线程标识符（TID），并在内部维护线程相关的数据结构。然而，每个线程在内核中仍然被视为独立的进程，并且共享同一个进程地址空间、文件描述符表以及其他进程资源。</p><p>通过使用进程模拟线程的方式，Linux实现了以下优势：</p><ol><li><p>轻量级：相比于传统意义上的进程，线程的创建和销毁更加高效，占用的系统资源更少。</p></li><li><p>并发性：线程之间可以并发执行，通过共享相同的地址空间，线程可以直接访问进程的内存区域，简化了线程间的通信和同步操作。</p></li><li><p>兼容性：由于早期版本的Linux内核并不直接支持线程，使用进程模拟线程的方式使得老旧的代码可以无缝迁移到新的内核版本中运行。</p></li></ol><p>现代的Linux内核已经提供了对线程的原生支持，称为轻量级进程（Lightweight Process，LWP）。通过使用LWP，每个线程都可以在内核中独立地进行调度和管理，而无需依赖进程资源。这种方式更加高效，并且更符合线程概念的定义。然而，为了保持向后兼容性，Linux仍然保留了使用进程模拟线程的机制。</p><h2 id="1-4-线程的私有物"><a href="#1-4-线程的私有物" class="headerlink" title="1.4 线程的私有物"></a>1.4 线程的私有物</h2><p>我们知道，一个进程是完全独立的。但是线程并不是，因为线程只是进程的一个执行流分支，它从进程继承了绝大部分属性（也可以理解为是共享的）</p><ul><li>用户id和组id</li><li>进程id</li><li>进程工作目录</li><li>文件描述符表</li><li>信号的处理方式（如果进程有对某个信号进行自定义捕捉，那么线程会共用这个自定义捕捉）</li><li>和进程共用一个堆</li></ul><p>但线程也会有自己的<strong>私有物</strong>！</p><ul><li>线程id</li><li>线程独立的寄存器（因为线程也需要执行代码，有上下文数据）</li><li>栈（线程运行函数时也需要压栈和出栈，必须独立否则执行流会出问题）</li><li>errno（单独的报错信息）</li><li>信号屏蔽字（可以单独针对某个信号处理）</li><li>线程调度优先级</li></ul><h3 id="1-5-3-线程结构体"><a href="#1-5-3-线程结构体" class="headerlink" title="1.5.3 线程结构体"></a>1.5.3 线程结构体</h3><p>在Linux内核中的<code>struct thread_struct</code>结构体中包含了如下字段，这些字段有助于模拟线程。因为我们对linux内核代码的了解并不多，这里只做基本认识，可以和上方的<code>struct thread_struct</code>结构体源码对照着看</p><ol><li><p><code>tls_array</code>: 这个字段表示线程的TLS（Thread Local Storage）描述符数组。TLS是一种机制，允许线程在其单独的存储区域中存储和访问变量。每个线程都可以有自己的TLS数组。</p></li><li><p><code>sp0</code>和<code>sp</code>: 这些字段表示线程的栈指针，用于管理线程的函数调用栈。</p></li><li><p><code>sysenter_cs</code>, <code>usersp</code>, <code>es</code>, <code>ds</code>, <code>fsindex</code>, <code>gsindex</code>: 这些字段用于保存与线程相关的段寄存器信息，例如代码段选择子、用户栈指针以及各种段寄存器的索引。</p></li><li><p><code>ip</code>, <code>fs</code>, <code>gs</code>: 这些字段记录线程的指令指针和段寄存器的值。</p></li><li><p><code>debugreg0</code>, <code>debugreg1</code>, <code>debugreg2</code>, <code>debugreg3</code>, <code>debugreg6</code>, <code>debugreg7</code>: 这些字段用于保存硬件调试寄存器的值，用于调试目的。</p></li><li><p><code>cr2</code>, <code>trap_no</code>, <code>error_code</code>: 这些字段记录了发生异常或中断时的相关信息。</p></li><li><p><code>xstate</code>: 这个字段用于保存浮点数和扩展处理器状态。</p></li></ol><h2 id="1-5-线程优缺点"><a href="#1-5-线程优缺点" class="headerlink" title="1.5 线程优缺点"></a>1.5 线程优缺点</h2><h3 id="1-5-1-缺点"><a href="#1-5-1-缺点" class="headerlink" title="1.5.1 缺点"></a>1.5.1 缺点</h3><ul><li><p>线程是缺乏保护的（不具备进程的<strong>独立性</strong>）这也被称为<code>健壮性</code>；线程的健壮性低</p><ul><li>当进程被停止的时候，其下线程也会被停止</li><li>当有一个线程出bug了，会让整个进程退出</li><li>多线程中的全局变量问题</li></ul></li><li><p>线程缺乏访问控制，在一个线程中调用某些操作系统的接口会影响整个进程</p></li><li><p>debug多线程较麻烦</p></li><li><p>如果同一个进程所用线程太多，可能会无法充分利用cpu性能而造成性能损失</p></li></ul><h3 id="1-5-2-优点"><a href="#1-5-2-优点" class="headerlink" title="1.5.2 优点"></a>1.5.2 优点</h3><ul><li>线程开辟的消耗低于进程，占用的资源低于进程</li><li>切换线程无须切换页表等结构，速度快！</li><li>等待慢IO设备时，进程可以继续执行其他操作；将部分IO操作重叠，能让进程同时等待多个IO操作；</li><li>能充分利用处理器的<strong>可并行数量</strong>；</li></ul><h2 id="1-6-linux下线程和进程的区别"><a href="#1-6-linux下线程和进程的区别" class="headerlink" title="1.6 linux下线程和进程的区别"></a>1.6 linux下线程和进程的区别</h2><p>在Linux系统中，进程和线程是两个并发执行的基本单位。它们之间有以下区别：</p><ol><li>资源占用：每个进程都有独立的地址空间、文件描述符、堆栈等资源，而线程共享进程的资源，包括地址空间、文件描述符等。因此，创建线程比创建进程更加轻量级。在线程直接切换也比进程切换效率更高。</li><li>调度：进程是由操作系统进行调度和分配资源的基本单位，而线程是<strong>进程的执行单元</strong>，由操作系统进行调度和分配CPU时间片。</li><li>通信和同步：进程间通信需要使用操作系统提供的机制，如管道、消息队列、共享内存等。而线程之间可以通过共享内存的方式直接进行通信。此外，线程之间的同步更加方便，可以使用互斥锁、条件变量等机制。</li><li>独立性：进程之间相互独立，一个进程的崩溃不会影响其他进程。而线程共享进程的资源，一个线程的崩溃会导致整个进程的崩溃。</li></ol><p>总结来说，<strong>进程是资源分配的基本单位，线程是执行的基本单位</strong>。进程之间相互独立，线程之间共享部分资源。</p><p>在实际应用中，需要根据情况的不同，选择使用进程或线程来实现并发执行。</p><hr><h1 id="2-基础函数"><a href="#2-基础函数" class="headerlink" title="2.基础函数"></a>2.基础函数</h1><p>linux下提供了<code>pthread</code>库来实现线程操作</p><h2 id="2-1-pthread-create"><a href="#2-1-pthread-create" class="headerlink" title="2.1 pthread_create"></a>2.1 pthread_create</h2><p>人如其名，这个函数的作用是来创建新进程的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><ul><li>第一个参数是一个<strong>输出型参数</strong>，为该线程的id</li><li>第二个参数是用于指定线程的属性，暂时设置为<code>NULL</code>使用默认属性</li><li>第三个参数是让该进程执行的函数，这是一个函数指针，参数和返回值都为<code>void*</code></li><li>第四个参数是<strong>传给第三个执行函数的参数</strong></li></ul><p>创建正常后返回0，否则返回错误码</p><p>注意，使用了pthread库后，需要在编译的时候指定链接，<code>-lpthread</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;<span class="comment">//线程id</span></span><br></pre></td></tr></table></figure><p>创建线程后打印可以发现，线程id是一个非常大的值，并不像进程PID那么小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cout &lt;&lt; &quot;pthread_create &quot;&lt;&lt; t1 &lt;&lt; &quot; &quot; &lt;&lt; t2 &lt;&lt; endl;</span></span><br><span class="line">pthread_create <span class="number">140689524995840</span> <span class="number">140689516603136</span></span><br></pre></td></tr></table></figure><p>可以通过<code>printf %x</code>的方式打印十六进制，来减少打印长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;0x%x  0x%x\n&quot;,t1,t2);</span></span><br><span class="line"><span class="number">0x393d0700</span>  <span class="number">0x38bcf700</span></span><br></pre></td></tr></table></figure><h2 id="2-2-pthread-join"><a href="#2-2-pthread-join" class="headerlink" title="2.2 pthread_join"></a>2.2 pthread_join</h2><p>光是创建进程还不够，我们还需要对进程<strong>进行等待</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>这里第一个参数是线程的id，第二个参数是进程的退出状态</p><p>等待成功后返回0，否则返回错误码</p><ul><li>join可以在线程退出后，释放线程的资源</li><li>同时获取线程对应的退出码</li><li>join还能保证是新创建的线程退出后，主线程才退出</li></ul><h3 id="2-2-1-基础的多线程操作"><a href="#2-2-1-基础的多线程操作" class="headerlink" title="2.2.1 基础的多线程操作"></a>2.2.1 基础的多线程操作</h3><p>有了这两个，我们就能写一个简单的多线程操作了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func1</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func1 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func1,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main::&quot;</span> &lt;&lt; <span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行会发现，多线程操作成功启动，且打印的进程pid都是一样的，<strong>代表其隶属于同一个进程</strong></p><p><img src="https://img.musnow.top/i/2023/02/202212152032424.png" alt="image-20221215203210372"></p><p>我们可以用下面的语句来查看轻量级进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aL</span><br></pre></td></tr></table></figure><p>可以看到，执行了程序之后，出现了3个<code>PID</code>相同，<code>LWP</code>不同的轻量级进程，这就代表我们的多线程操作成功了；</p><p>同时也能看到，在多线程操作时，谁先运行是不确定的。这是由系统调度随机决定的</p><p><img src="https://img.musnow.top/i/2023/02/202212152033288.png" alt="image-20221215203326193"></p><h3 id="2-2-2-C-的多线程操作"><a href="#2-2-2-C-的多线程操作" class="headerlink" title="2.2.2 C++的多线程操作"></a>2.2.2 C++的多线程操作</h3><p>C++11也支持了多线程操作，其封装了操作系统的pthread接口，基本的操作很相似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1,(<span class="type">char</span>*)<span class="string">&quot;test1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func2,(<span class="type">char</span>*)<span class="string">&quot;test2&quot;</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main:: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后的效果是一样的，C++的thread库还可以传入<code>functional</code>封装的可调用函数，和<code>lambda</code>表达式</p><p><img src="https://img.musnow.top/i/2023/02/202212152054822.png" alt="image-20221215205453606"></p><h2 id="2-3-线程退出"><a href="#2-3-线程退出" class="headerlink" title="2.3 线程退出"></a>2.3 线程退出</h2><h3 id="2-3-1-retval"><a href="#2-3-1-retval" class="headerlink" title="2.3.1 retval"></a>2.3.1 retval</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><p>我们可以使用该函数的第二个参数来获取线程所执行方法的返回值。<code>retval</code>是一个二级指针，是一个<strong>输出型参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func1</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func1 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func1,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main:: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* r1;</span><br><span class="line">    <span class="type">void</span>* r2;</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,&amp;r1);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,&amp;r2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 1 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 2 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当两个线程退出之后，主函数中成功打印出了他们的返回值</p><p><img src="https://img.musnow.top/i/2023/02/202212161842059.png" alt="image-20221216184220924"></p><p>注意，因为我们是将<code>void*</code>的指针强转为int，如果在打印的时候强转为<code>int</code>，会出现<strong>精度丢失</strong>的报错，需要使用<code>long long</code>来规避报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ make</span><br><span class="line">g++ test.cpp -o test -lpthread -std=c++11</span><br><span class="line">.test.cpp: In function ‘void test3()’:</span><br><span class="line">test.cpp:88:35: error: cast from ‘void*’ to ‘int’ loses precision [-fpermissive]</span><br><span class="line">     cout &lt;&lt; &quot;retval 1 : &quot; &lt;&lt; (int)r1 &lt;&lt; endl;</span><br><span class="line">                                   ^</span><br><span class="line">make: *** [test] Error 1</span><br></pre></td></tr></table></figure><h3 id="2-3-2-pthread-exit"><a href="#2-3-2-pthread-exit" class="headerlink" title="2.3.2 pthread_exit"></a>2.3.2 pthread_exit</h3><p>除了直接return，线程还可以调用<code>pthread_exit</code>函数实现退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>效果完全一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return (void*)10;</span></span><br><span class="line">pthread_exit((<span class="type">void</span>*)<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>注意，主线程main中调用该函数，并不会导致进程退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; tid: &quot;</span> &lt;&lt; <span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">	<span class="comment">//func2会执行10s</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">test5</span>();</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);<span class="comment">//主线程提前退出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主函数已经调用了<code>pthread_exit</code>退出了，但是线程还在跑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./test</span><br><span class="line">func2 thread:: 1 :: 9474 tid: 9475</span><br><span class="line">func2 thread:: 2 :: 9474 tid: 9476</span><br><span class="line">func2 thread:: 1 :: 9474 tid: 9475</span><br><span class="line">func2 thread:: 2 :: 9474 tid: 9476</span><br><span class="line">main exit</span><br><span class="line">func2 thread:: 1 :: 9474 tid: 9475</span><br><span class="line">func2 thread:: 2 :: 9474 tid: 9476</span><br></pre></td></tr></table></figure><h3 id="2-3-3-ptrhead-cancel"><a href="#2-3-3-ptrhead-cancel" class="headerlink" title="2.3.3 ptrhead_cancel"></a>2.3.3 ptrhead_cancel</h3><p>除了上面俩种方式，我们还可以在main里面直接把某一个线程给关掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func1,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main:: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">11</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_cancel</span>(t1);</span><br><span class="line">            <span class="built_in">pthread_cancel</span>(t2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span>* r1;</span><br><span class="line">    <span class="type">void</span>* r2;</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,&amp;r1);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,&amp;r2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 1 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 2 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被提前终止的进程，返回值都为-1</p><p><img src="https://img.musnow.top/i/2023/02/202212161903290.png" alt="image-20221216190338205"></p><h3 id="2-3-4-为什么进程退出不会向主进程发送信号？"><a href="#2-3-4-为什么进程退出不会向主进程发送信号？" class="headerlink" title="2.3.4 为什么进程退出不会向主进程发送信号？"></a>2.3.4 为什么进程退出不会向主进程发送信号？</h3><p>要理清楚这个问题，还是需要深知一个概念：线程是进程中的一个执行流，它并不是一个独立的进程。</p><p>先来回顾一下进程退出的几种情况：</p><ul><li>代码跑完，结果正确</li><li>代码跑完，结果有问题</li><li>代码出错了，异常</li></ul><p>线程退出的情况也是这样，但线程如果因为某些异常退出，<strong>进程也会同步退出</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./test</span><br><span class="line">this is main:: 13845</span><br><span class="line">Floating point exception</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ </span><br></pre></td></tr></table></figure><p>由此可见，<code>线程异常 = 进程异常</code></p><p>这里也就涉及到<code>1.5.1</code>中提到的线程<strong>健壮性</strong>问题，线程的异常会影响其他线程的运行，会导致进程整体异常退出。</p><p>所以在<code>join</code>等待线程退出的时候，我们只需要考虑线程正常退出的情况；</p><blockquote><p>异常退出的时候恐怕也等不了😂因为进程也挂了</p></blockquote><h2 id="2-3-5-exit"><a href="#2-3-5-exit" class="headerlink" title="2.3.5 exit"></a>2.3.5 exit</h2><p>任何一个线程执行<code>exit()</code>函数，都会导致整个进程退出</p><hr><h2 id="2-4-pthread-detach"><a href="#2-4-pthread-detach" class="headerlink" title="2.4 pthread_detach"></a>2.4 pthread_detach</h2><p>等待是有性能损失的！默认创建的进程是<code>joinable</code>，也就是可以被主线程进行<code>pthread_join</code>等待的；</p><p>这个函数的作用是让主线程不管创建出来的子线程，也不用去等待它，相当于取消了它的<code>joinable</code>属性；</p><p>就好比父进程不想管子进程的时候，将<code>SIGCHLD</code>设置为<code>SIG_IGN</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">//Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure><p>一个线程是否应该等待，取决于是否需要获取该线程的返回值；如果无须获取返回值，则使用分离能提高运行效率</p><blockquote><p>即便线程所运行的函数return是无效的，但我们可以用输出型参数来获取返回值</p></blockquote><h3 id="2-4-1-实操"><a href="#2-4-1-实操" class="headerlink" title="2.4.1 实操"></a>2.4.1 实操</h3><p>使用也很简单，只需要指定线程的id就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main - global: &quot;</span> &lt;&lt; global &lt;&lt; <span class="string">&quot; - &amp;global: &quot;</span> &lt;&lt; &amp;global &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上也不会有什么区别，但是我们已无法获取到该线程的返回值</p><p><img src="https://img.musnow.top/i/2023/02/202212181127252.png" alt="image-20221218112720052"></p><hr><h3 id="2-4-2-detach后join"><a href="#2-4-2-detach后join" class="headerlink" title="2.4.2 detach后join"></a>2.4.2 detach后join</h3><p>但如果我们在detach之后又进行<code>pthread_join</code>会发生什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func3</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;func thread:%s - global:%d - &amp;global:%p\n&quot;</span>,(<span class="type">char</span>*)arg,global,&amp;global);</span><br><span class="line">        global++;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* r1=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">void</span>* r2=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,&amp;r1);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,&amp;r2);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 1 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 2 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诶，这不还是获取到了返回值吗？这么说，他这个<code>detach</code>岂不是没用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./test</span><br><span class="line">func thread:1 - global:103 - &amp;global:0x7fb5648b06fc</span><br><span class="line">func thread:2 - global:103 - &amp;global:0x7fb5640af6fc</span><br><span class="line">func thread:1 - global:104 - &amp;global:0x7fb5648b06fc</span><br><span class="line">func thread:2 - global:104 - &amp;global:0x7fb5640af6fc</span><br><span class="line">func exit</span><br><span class="line">func exit</span><br><span class="line">retval 1 : 10</span><br><span class="line">retval 2 : 10</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ </span><br></pre></td></tr></table></figure><p>实际上，当我们create一个线程的时候，它会先去执行线程创建的相关代码，此时main又直接去执行后面的代码了；此时<code>pthread_join</code>的调用是成功的，因为线程自己的<code>detach</code>代码<strong>还没有被执行</strong>！</p><hr><p>而如果我们在create之后，等线程开始运行了在执行<code>detach</code>，此时join就会失败</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* r1=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">void</span>* r2=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_join</span>(t1,&amp;r1);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(ret) &lt;&lt; endl;</span><br><span class="line">    ret = <span class="built_in">pthread_join</span>(t2,&amp;r2);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(ret) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 1 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retval 2 : &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)r2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印错误码也能看到，系统提示我们给<code>join</code>传入了一个无效的参数，线程依旧在正常运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt<span class="number">-7274</span>:~/git/linux/code/<span class="number">22</span><span class="number">-12</span><span class="number">-15</span>_pthread]$ ./test</span><br><span class="line">func thread:<span class="number">1</span> - global:<span class="number">101</span> - &amp;global:<span class="number">0x7f2d439136fc</span></span><br><span class="line">func thread:<span class="number">2</span> - global:<span class="number">101</span> - &amp;global:<span class="number">0x7f2d431126fc</span></span><br><span class="line">func thread:<span class="number">2</span> - global:<span class="number">102</span> - &amp;global:<span class="number">0x7f2d431126fc</span></span><br><span class="line">func thread:<span class="number">1</span> - global:<span class="number">102</span> - &amp;global:<span class="number">0x7f2d439136fc</span></span><br><span class="line"><span class="number">22</span>:Invalid argument</span><br><span class="line"><span class="number">22</span>:Invalid argument</span><br><span class="line">retval <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">retval <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">func thread:<span class="number">2</span> - global:<span class="number">103</span> - &amp;global:<span class="number">0x7f2d431126fc</span></span><br><span class="line">func thread:<span class="number">1</span> - global:<span class="number">103</span> - &amp;global:<span class="number">0x7f2d439136fc</span></span><br></pre></td></tr></table></figure><p>所以正确的做法，<strong>应该是在主线程中分离线程</strong>，不要在线程自己的代码中执行detach，否则就会出现上面的分离失败的情况</p><h3 id="2-4-3-线程分离后，主线程先退出"><a href="#2-4-3-线程分离后，主线程先退出" class="headerlink" title="2.4.3 线程分离后，主线程先退出"></a>2.4.3 线程分离后，主线程先退出</h3><p>如果执行完毕<code>pthread_detach</code>后，主线程提前退出了，会发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，线程也跟着一并退出了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ ./test</span><br><span class="line">func thread:1 - global:100 - &amp;global:0x7f01cd49a6fc</span><br><span class="line">func thread:2 - global:100 - &amp;global:0x7f01ccc996fc</span><br><span class="line">func thread:2 - global:101 - &amp;global:0x7f01ccc996fc</span><br><span class="line">func thread:1 - global:101 - &amp;global:0x7f01cd49a6fc</span><br><span class="line">func thread:2 - global:102 - &amp;global:0x7f01ccc996fc</span><br><span class="line">func thread:1 - global:102 - &amp;global:0x7f01cd49a6fc</span><br><span class="line">main exit</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-15_pthread]$ </span><br></pre></td></tr></table></figure><p>因为线程<strong>没有独立性</strong>，完全属于这个进程。不可能出现你家房子塌了，你自己的房间还在的情况😂</p><blockquote><p>进程退出的时候，操作系统就回收了这个进程的程序地址空间，连资源都被释放了，线程就没有办法继续运行，自然就退出了。</p></blockquote><p>所以，为了避免这种问题，一般我们分离线程的时候，都倾向于让主线程保持在后台运行（常驻内存的程序）</p><h2 id="2-5-gettid-x2F-syscall"><a href="#2-5-gettid-x2F-syscall" class="headerlink" title="2.5 gettid&#x2F;syscall"></a>2.5 gettid&#x2F;syscall</h2><p>该函数是一个系统接口，<strong>但它并不能直接运行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       gettid - get thread identification</span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/types.h&gt;</span><br><span class="line">       pid_t gettid(void);</span><br><span class="line"></span><br><span class="line">       Note:  There  is  no  glibc wrapper for this system call; see</span><br><span class="line">       NOTES.</span><br></pre></td></tr></table></figure><p>我们需要用<strong>syscall函数</strong>来调用该接口，这也是第一次接触到syscall函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span>   <span class="comment">/* For SYS_xxx definitions */</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall</span><span class="params">(<span class="type">int</span> number, ...)</span>;</span><br></pre></td></tr></table></figure><p>在syscall的man手册中，我们就能看到获取线程id相关的示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EXAMPLE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> tid;</span><br><span class="line"></span><br><span class="line">    tid = syscall(SYS_gettid);</span><br><span class="line">    tid = syscall(SYS_tgkill, getpid(), tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用下面的代码进行测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 thread:: &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; :: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; tid: &quot;</span> &lt;&lt; <span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2 exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tis is main - pid:%d - tid:%d\n&quot;</span>,<span class="built_in">getpid</span>(),<span class="built_in">syscall</span>(SYS_gettid));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可以看到进程打印出了相同的PID和不同的TID，其TID对应的就是<code>ps -aL</code>中显示的<code>LWP</code>编号</p><p><img src="https://img.musnow.top/i/2023/02/202212181307710.png" alt="image-20221218130755643"></p><h1 id="3-相关概念"><a href="#3-相关概念" class="headerlink" title="3.相关概念"></a>3.相关概念</h1><h2 id="3-1-线程id是什么？"><a href="#3-1-线程id是什么？" class="headerlink" title="3.1 线程id是什么？"></a>3.1 线程id是什么？</h2><p>前面提到过，<code>pthread_t</code>是线程独立的id，本质上是一个无符号长整形，打印出来后，是一个很大的数字。这个数字有什么特别的含义吗？</p><p>先来回顾一下线程的基本概念：</p><ul><li>线程是一个独立的执行流</li><li>线程在运行过程中，会产生自己的临时数据</li><li>线程调用函数的压栈出栈操作，有自己独立的栈结构</li></ul><p>因此，既然有一个独立的栈结构，其就需要有一个标识符来指向这个栈结构，方便程序运行的时候进行调用！</p><p>所以，<code>pthread_t</code>本质上是一个地址！其指向的就是这个<strong>线程的控制块</strong>，其内部包含了这个线程的独立栈结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;0x%x  0x%x\n&quot;,t1,t2);</span></span><br><span class="line"><span class="number">0x393d0700</span>  <span class="number">0x38bcf700</span> <span class="comment">//打印出来的结果也很像地址</span></span><br></pre></td></tr></table></figure><h2 id="3-2-pthread库"><a href="#3-2-pthread库" class="headerlink" title="3.2 pthread库"></a>3.2 pthread库</h2><p>pthread库并不是一个内核级的接口库，其实际上是封装了系统的<code>clone/vfork</code>等接口，从而为我们提供的用户级的线程库。</p><p>使用pthread库创建的进程，和内核中的LWP是<code>1:1</code>的</p><p><img src="https://img.musnow.top/i/2023/02/202212181023276.png" alt="image-20221218102338117"></p><p>pthread是一个<strong>动态库</strong>，所以在编译的时候需要加上链接选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o test -lpthread</span><br></pre></td></tr></table></figure><p>在我的 <a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/127668016?spm=1001.2014.3001.5501">动静态库</a> 的博客中有讲述过，动态库是在运行的时候动态链接的，其会将库中的代码映射到进程地址空间的<code>共享区</code>，从而调用动态库中的代码</p><blockquote><p>举个例子，当我们调用<code>pthead_create</code>的时候，<strong>进程会跳到共享区中</strong>，执行动态库中的代码，创建成功后返回自己的<code>代码区</code>，完成一个线程的创建</p></blockquote><p>而线程所用的独立栈，也是pthread库帮我们管理的。因为有共享区的存在，我们能通过<code>pthread_t</code>直接访问到动态库中管理的<strong>线程的控制模块</strong>，从而完成线程的压栈、出栈等等操作</p><p><img src="https://img.musnow.top/i/2023/02/202212181036505.png" alt="image-20221218103643205"></p><p>下为linux的<code>pthreadtypes.h</code>中的部分内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __SIZEOF_PTHREAD_ATTR_T 36</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">pthread_attr_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __have_pthread_attr_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">pthread_attr_t</span> <span class="title">pthread_attr_t</span>;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __have_pthread_attr_t	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="3-3-线程的局部存储"><a href="#3-3-线程的局部存储" class="headerlink" title="3.3 线程的局部存储"></a>3.3 线程的局部存储</h2><p>假设我们有一个全局变量，我们想让创建出来的每一个线程，都能独立的使用这个全局变量，那就需要用到线程的<strong>局部存储</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global = <span class="number">10</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func3</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func thread &quot;</span> &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt;  <span class="string">&quot; - global: &quot;</span> &lt;&lt; global &lt;&lt; <span class="string">&quot; - &amp;global: &quot;</span> &lt;&lt; &amp;global &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func3,(<span class="type">void</span>*)<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is main - global: &quot;</span> &lt;&lt; global &lt;&lt; <span class="string">&quot; - &amp;global: &quot;</span> &lt;&lt; &amp;global &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(t1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(t2,<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行，不管是主线程还是线程，都打印的是相同的值和地址</p><p><img src="https://img.musnow.top/i/2023/02/202212181107524.png" alt="image-20221218110718405"></p><p>如果在执行的函数<code>func3</code>中添加一个<code>global++</code>，则能观察到所有线程都是公用的一个变量，这里的+是同步的。</p><p><img src="https://img.musnow.top/i/2023/02/202212181110159.png" alt="image-20221218111031984"></p><p>如果我们想让<code>int global</code>变成局部变量，则需要在它之前加上一个<code>__thread</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread <span class="type">int</span> global = <span class="number">100</span>;<span class="comment">//可以让线程独立使用的全局变量</span></span><br></pre></td></tr></table></figure><p>此时可以看到，两个线程和主线程打印的global变量地址不同，他们的<code>++</code>操作是独立的，变量的值也是独立的</p><p><img src="https://img.musnow.top/i/2023/02/202212181116428.png" alt="image-20221218111639283"></p><p>这就实现了将某一个变量划分给线程进行<strong>局部存储</strong></p><h1 id="4-线程互斥问题"><a href="#4-线程互斥问题" class="headerlink" title="4.线程互斥问题"></a>4.线程互斥问题</h1><h2 id="4-1-临界资源"><a href="#4-1-临界资源" class="headerlink" title="4.1 临界资源"></a>4.1 临界资源</h2><p>在先前<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/127834035?spm=1001.2014.3001.5501">共享内存 信号量</a>的博客中，已经涉及到了这部分的内容；即关于操作<strong>原子性</strong>和访问<strong>临界资源&#x2F;临界区</strong>的相关问题。</p><ul><li>能被多个进程&#x2F;线程看到的资源，被称为<code>临界资源</code></li><li>进程&#x2F;线程访问临界资源的代码，被称为<code>临界区</code></li></ul><p>在线程中，同样存在访问<strong>临界资源</strong>而导致的冲突：</p><ul><li>线程A对一个<strong>全局变量val</strong>进行了<code>-1</code>操作，当操作执行到放回内存那一步的时候，发生了线程切换，线程B开始工作</li><li>线程B同样访问了该全局变量val，对它进行了<code>-10</code>操作，此时因为线程A的<code>-1</code>操作尚未写回内存，全局变量val还是保持初值。线程b将<code>-10</code>之后的全局变量val写回了内存</li><li>又发生了线程切换，跳转到线程A停止的<strong>线程上下文数据</strong>中开始执行，将全局变量写入内存</li><li>这时候，线程B的<code>-10</code>操作就被A的写入覆盖了！</li></ul><p>举个实际点的例子，以100为全局变量的初始值</p><ul><li>线程A执行-1，<code>100-1=99</code>，还未写入内存时，就线程切换</li><li>线程B取到的全局变量还是100，对其执行-10，并写入内存， 此时全局变量为90</li><li>返回线程A继续执行写入内存操作，全局变量又被复写成了99；<strong>相当于B的操作是无效的</strong></li></ul><p>这种条件下会产生很多问题，也是我们不希望看到的！</p><h2 id="4-2-原子-x2F-互斥性"><a href="#4-2-原子-x2F-互斥性" class="headerlink" title="4.2 原子&#x2F;互斥性"></a>4.2 原子&#x2F;互斥性</h2><p>这种时候，我们就需要保证访问该全局变量的操作是<strong>原子</strong>的，不能出现中间状态；</p><p>也应该是<strong>互斥</strong>的，不能出现两个线程同时访问一份资源的情况</p><blockquote><p>互斥性：任何时候都只有一个执行流在访问某一份资源</p></blockquote><p><img src="https://img.musnow.top/i/2023/02/202212181937011.png" alt="image-20221218193343035"></p><p>操作系统维护原子性，就必须保证该操作<strong>只用一条汇编语句</strong>执行（这样才不会出现进程&#x2F;线程切换导致的问题）这个在后面会详细介绍</p><p>为了达成这一目的，我们需要给线程的操作<strong>加锁</strong></p><h2 id="4-3-线程加锁"><a href="#4-3-线程加锁" class="headerlink" title="4.3 线程加锁"></a>4.3 线程加锁</h2><p>线程加锁涉及到几个操作：</p><ul><li>提供一把锁</li><li>在需要维持原子性（临界区）的位置加上锁</li><li>访问临界区结束后，打开锁</li><li>进程结束后，把锁丢了</li></ul><p>接下来就让我们一一解决这些问题</p><h3 id="4-3-1-pthread-mutex-init"><a href="#4-3-1-pthread-mutex-init" class="headerlink" title="4.3.1 pthread_mutex_init"></a>4.3.1 pthread_mutex_init</h3><p>pthread线程库在设计之初就考虑到了线程安全问题，所以它便给我们提供了加锁相关的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>首先我们需要定义一把锁，类型是<code>pthread_mutex_t</code></p><ul><li>如果我们需要的是一把<strong>全局变量</strong>的锁，则可以直接使用赋值<code>PTHREAD_MUTEX_INITIALIZER</code>给这把锁初始化</li><li>如果是一把局部的锁，则使用函数<code>pthread_mutex_init</code>进行初始化</li></ul><p>初始化的方法很简单，传入锁和对应的属性就行。此时我们忽略属性问题，设置为<code>NULL</code>使用<strong>默认属性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认属性的全局锁or静态static锁</span></span><br><span class="line"><span class="comment">//无须调用函数初始化，可以直接用</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数进行初始化局部的锁（当然也可以初始化全局锁）</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//定义一把锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, nullptr);<span class="comment">//初始化</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);<span class="comment">//销毁</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-加锁-x2F-解锁"><a href="#4-3-2-加锁-x2F-解锁" class="headerlink" title="4.3.2 加锁&#x2F;解锁"></a>4.3.2 加锁&#x2F;解锁</h3><p>有了锁，那么就可以在需要的位置加上这把锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>其中lock是<strong>阻塞式</strong>加锁，如果你调用这个接口的时候，锁正在被别人使用，则会在这里等待；trylock是<strong>非阻塞</strong>加锁，如果你调用该接口时锁正被使用，则直接<code>return</code>返回（相当于看看锁能否被获取）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The pthread_mutex_trylock() function shall be equivalent to pthread_mutex_lock(), except that if the mutex object referenced  by  mutex  is  currently locked (by any thread, including the current thread), the call shall return immediately. </span><br></pre></td></tr></table></figure><p>加了锁之后，在需要的位置<code>unlock</code>解锁；</p><ul><li>加锁和解锁操作<strong>本身</strong>是原子的，不会出现冲突</li><li>加了锁之后，可以理解为加锁解锁操作<strong>中间</strong>的代码也是原子性的，<strong>必须要运行到解锁位置</strong>才能让另外一个线程&#x2F;进程执行这里的代码</li><li>加锁的本质是让线程执行临界区的代码串行化</li></ul><h3 id="4-3-3-加锁的注意事项"><a href="#4-3-3-加锁的注意事项" class="headerlink" title="4.3.3 加锁的注意事项"></a>4.3.3 加锁的注意事项</h3><ul><li>只对临界区加锁；锁保护的就是临界区</li><li>加锁的粒度越细越好（即加锁的区域越小越好。如果访问的不是临界区，则可以不考虑加锁）</li><li>加锁是编程的一种规范；在实际问题中，我们要保证<strong>访问某一临界资源</strong>的<strong>所有操作</strong>都要加上锁。不能出现函数A加锁了，但是B没有加锁的情况（这样会导致A的加锁也没有意义）</li></ul><h2 id="4-4-示例-倒水问题"><a href="#4-4-示例-倒水问题" class="headerlink" title="4.4 示例-倒水问题"></a>4.4 示例-倒水问题</h2><p><img src="https://img.musnow.top/i/2023/02/202212240951765.png" alt="image-20221224095101707"></p><p>以<strong>倒水</strong>为示例，假设杯子容量为10000，<strong>装满了水就会溢出</strong>。我们使用多个线程对这个杯子加水，直到满了之后线程退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//临界资源</span></span><br><span class="line"><span class="type">int</span> water = <span class="number">0</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> cup = <span class="number">10000</span>;<span class="comment">//杯子的容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(water&lt;cup)<span class="comment">//临界区</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            water++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水已经满了 &quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 线程退出&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2,t3,t4;<span class="comment">//创建4个线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t3,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t4,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接分离线程</span></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t3);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;<span class="comment">//啥都不干</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果如下，明明水已经满了，但还是会有部分线程报告水还没有满，且数字有很严重的偏差</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t3 水没有满：9993</span><br><span class="line">t3 水没有满：9994</span><br><span class="line">t3 水没有满：9995</span><br><span class="line">t3 水没有满：9996</span><br><span class="line">t3 水没有满：9997</span><br><span class="line">t3 水没有满：9998</span><br><span class="line">t3 水没有满：9999</span><br><span class="line">t3 水已经满了</span><br><span class="line">t3 线程退出</span><br><span class="line"> 水没有满：2723</span><br><span class="line">t4 水已经满了</span><br><span class="line">t4 线程退出</span><br><span class="line">0</span><br><span class="line">t2 水已经满了</span><br><span class="line">t2 线程退出</span><br><span class="line">t1 水没有满：9668</span><br><span class="line">t1 水已经满了</span><br><span class="line">t1 线程退出</span><br></pre></td></tr></table></figure><p>多运行几次，也能发现相同的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t2 水没有满：9997</span><br><span class="line">t2 水没有满：9998</span><br><span class="line">t2 水没有满：9999</span><br><span class="line">t2 水已经满了 10000</span><br><span class="line">t2 线程退出</span><br><span class="line">t4 水没有满：1889</span><br><span class="line">t4 水已经满了 10001</span><br><span class="line">t4 线程退出</span><br><span class="line">t3 水没有满：0</span><br><span class="line">t3 水已经满了 10002</span><br><span class="line">t3 线程退出</span><br><span class="line">t1 水没有满：0</span><br><span class="line">t1 水已经满了 10003</span><br><span class="line">t1 线程退出</span><br></pre></td></tr></table></figure><h3 id="4-4-1-只有一个线程在工作？"><a href="#4-4-1-只有一个线程在工作？" class="headerlink" title="4.4.1 只有一个线程在工作？"></a>4.4.1 只有一个线程在工作？</h3><p>除了偏差外，还有一个小问题，往前翻打印记录，会发现一直都是<strong>某一个线程在倒水</strong>，其他线程似乎啥事没有干？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t3 水没有满：9786</span><br><span class="line">t3 水没有满：9787</span><br><span class="line">t3 水没有满：9788</span><br><span class="line">t3 水没有满：9789</span><br><span class="line">t3 水没有满：9790</span><br></pre></td></tr></table></figure><p>这是因为当运行t3的时候，t3在while循环中继续运行的消耗，<strong>小于切换到其他线程的消耗</strong>。所以控制块就让t3一直运行，直到它break退出循环</p><p>此时我们只需要加上一个usleep，增加每一个while循环中需要<strong>处理的负担</strong>，就能让所有线程都来倒水</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usleep功能把进程挂起一段时间， 单位是微秒（百万分之一秒）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">usleep</span><span class="params">(<span class="type">useconds_t</span> usec)</span>;</span><br></pre></td></tr></table></figure><p>这是因为线程切换同样也是时间片到了，从内核返回用户态的时候做检测，切换至其他线程。</p><p>添加usleep能创造更多<strong>内核&#x2F;用户的中间态</strong>，从而增多切换线程的次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(water&lt;cup)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span>);<span class="comment">//休息100微秒</span></span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            water++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水已经满了&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 线程退出&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这还是没有解决数字出错的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t4 水没有满：9995</span><br><span class="line">t3 水没有满：9996</span><br><span class="line">t1 水没有满：9997</span><br><span class="line">t2 水没有满：9998</span><br><span class="line">t4 水没有满：9999</span><br><span class="line">t4 水已经满了 10000</span><br><span class="line">t4 线程退出</span><br><span class="line">t3 水没有满：10000</span><br><span class="line">t3 水已经满了 10001</span><br><span class="line">t3 线程退出</span><br><span class="line">t1 水没有满：10001</span><br><span class="line">t1 水已经满了 10002</span><br><span class="line">t1 线程退出</span><br><span class="line">t2 水没有满：10002</span><br><span class="line">t2 水已经满了 10003</span><br><span class="line">t2 线程退出</span><br></pre></td></tr></table></figure><h3 id="4-4-2-加锁-问题解决"><a href="#4-4-2-加锁-问题解决" class="headerlink" title="4.4.2 加锁-问题解决"></a>4.4.2 加锁-问题解决</h3><p>这时候就需要请出我们的锁了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略头文件</span></span><br><span class="line"><span class="type">int</span> water = <span class="number">0</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> cup = <span class="number">10000</span>;<span class="comment">//杯子的容量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(water&lt;cup)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            water++;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span>);<span class="comment">//假装喝水</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水已经满了 &quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="comment">//此处也需要加锁，否则break出去之后其他线程会因为没有解锁而挂起</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 线程退出&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果遇到2号信号，就在销毁锁后退出进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">des</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//销毁锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pthread_mutex_destroy, exit&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT,des);<span class="comment">//自定义捕捉2号信号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">nullptr</span>);<span class="comment">//初始化锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> t1,t2,t3,t4;<span class="comment">//创建4个线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t3,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t4,<span class="literal">nullptr</span>,func,(<span class="type">void</span>*)<span class="string">&quot;t4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接分离线程</span></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t3);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;<span class="comment">//啥都不干</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可见，数字错误问题就没有出现了；<strong>但又出现了只有一个线程工作的问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t1 水没有满：<span class="number">9996</span></span><br><span class="line">t1 水没有满：<span class="number">9997</span></span><br><span class="line">t1 水没有满：<span class="number">9998</span></span><br><span class="line">t1 水没有满：<span class="number">9999</span></span><br><span class="line">t1 水已经满了 <span class="number">10000</span></span><br><span class="line">t1 线程退出</span><br><span class="line">t3 水已经满了 <span class="number">10000</span></span><br><span class="line">t3 线程退出</span><br><span class="line">t4 水已经满了 <span class="number">10000</span></span><br><span class="line">t4 线程退出</span><br><span class="line">t2 水已经满了 <span class="number">10000</span></span><br><span class="line">t2 线程退出</span><br><span class="line">^Cpthread_mutex_destroy, exit</span><br></pre></td></tr></table></figure><p>这还是因为线程切换的效率问题；也有可能是因为其它线程申请锁的时候，发现t1在用，就进行了<strong>阻塞等待</strong>而挂起</p><p><img src="https://img.musnow.top/i/2023/02/202212191022656.png" alt="image-20221219102217522"></p><p>只需要在解锁之后添加一个<code>usleep</code>模拟其他工作，就能让所有线程都跑起来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span>(water&lt;cup)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    water++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">100</span>);<span class="comment">//假装喝水</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有出现数据错误，加锁的目的成功达到！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t1 水没有满：9993</span><br><span class="line">t3 水没有满：9994</span><br><span class="line">t4 水没有满：9995</span><br><span class="line">t2 水没有满：9996</span><br><span class="line">t1 水没有满：9997</span><br><span class="line">t3 水没有满：9998</span><br><span class="line">t4 水没有满：9999</span><br><span class="line">t2 水已经满了 10000</span><br><span class="line">t2 线程退出</span><br><span class="line">t1 水已经满了 10000</span><br><span class="line">t1 线程退出</span><br><span class="line">t3 水已经满了 10000</span><br><span class="line">t3 线程退出</span><br><span class="line">t4 水已经满了 10000</span><br><span class="line">t4 线程退出</span><br><span class="line">^Cpthread_mutex_destroy, exit</span><br></pre></td></tr></table></figure><h2 id="4-5-加锁的进一步解释"><a href="#4-5-加锁的进一步解释" class="headerlink" title="4.5 加锁的进一步解释"></a>4.5 加锁的进一步解释</h2><p>在这个代码示例中，我们给中间的几行代码加了锁；但这并不意味着执行中间这部分代码的时候，就不会发生线程切换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">if</span>(water&lt;cup)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>*)arg &lt;&lt; <span class="string">&quot; 水没有满：&quot;</span> &lt;&lt; water &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    water++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>事实上，代码执行的任何地方，都可能发生进程&#x2F;线程的切换。但因为我们加了锁，切换的时候，其他线程要来访问这里的资源，<strong>就必须先申请锁</strong></p><p>此时锁在<strong>被切走的进线程手上</strong>，所以其他线程无法访问临界区的资源，也就不会发生数据不一致的问题。</p><p><img src="https://img.musnow.top/i/2023/02/202211031203810.gif" alt="QQ图片20220504102516"></p><blockquote><p>换言之，只要<strong>张三</strong>拿到了锁，那么它也就不担心自己的工作会被别人覆盖的问题；</p><p>而对其他线程而言，张三访问临界区的工作，只有<strong>还没进入</strong>临界区和<strong>访问完毕</strong>临界区两种状态</p></blockquote><p>因此会导致一个问题，那就是线程切换的效率较低，其他线程出现了阻塞等待的情况；为了避免此问题，我们应该让访问临界区的操作快去快回，尽量不要在临界区里面干啥耗时的事情</p><h3 id="4-5-1-加锁原子性的保证"><a href="#4-5-1-加锁原子性的保证" class="headerlink" title="4.5.1 加锁原子性的保证"></a>4.5.1 加锁原子性的保证</h3><blockquote><p>备注：这部分仅供学习参考，若有错误，还请指出！</p></blockquote><p>那么加锁这个操作，是如何保证其自身的原子性呢？在加锁的途中不会发生线程切换吗？</p><p><img src="https://img.musnow.top/i/2023/02/202212240939271.png" alt="Snipaste_2022-12-24_09-38-46"></p><p>我找到了一张能大概说明汇编加锁过程的图片，其中<code>movb</code>的操作就是将al寄存器写为0，<code>xchgb</code>的操作是将al寄存器的内容和内存中mutex锁的值进行交换</p><ul><li>开始的时候，锁被正常初始化，内存中mutex的值为1（锁只会被初始化一次）</li><li>线程A开始加锁，al寄存器和mutex的值发生交换，此时内存中的mutex为0，al为1</li><li>判断al不为0，代表获取锁成功，线程A加锁成功</li><li>线程B也来申请锁了，<code>movb</code>将al寄存器写为0，再和内存中的mutex交换后，发现还是0，则代表锁在别人手上，此时就需要挂起等待</li></ul><p>前面一直强调，线程是有自己独立的栈结构和上下文数据的，在加锁的这部分汇编操作中，同样可能会在任何地方发生线程切换。切换的时候，线程的<strong>上下文数据</strong>（图中寄存器的状态）会被保留下来，<strong>随这个线程一起被切换走</strong></p><p>所以线程A被切换的时候，属于它上下文中那个值为1的al寄存器也被切走了（注意，这里切走的是数据，al寄存器本身作为硬件，<strong>有且只有一个</strong>）</p><p>由此看来，真正获取锁的操作，其实只有<code>xchgb</code>一条交换指令来完成，<font color="Red">保证加锁操作只由一条汇编语句实现</font>，就能保证该操作的原子性！</p><p>解锁的方法就很简单了，<code>movb</code>将1写回mutex变量即可，也是一条汇编完成；而且一般情况下，解锁是不会有执行流和你抢的。</p><blockquote><p>其实加锁远不止一种方法，锁的种类有非常多，还有<strong>总线锁、旋转锁</strong>等等，每一个锁的实现都不太一样！上面提到的为<code>互斥锁</code></p></blockquote><h3 id="4-5-2-总线锁"><a href="#4-5-2-总线锁" class="headerlink" title="4.5.2 总线锁"></a>4.5.2 总线锁</h3><p>现在的CPU一般都有自己的内部缓存，根据一些规则将内存中的数据读取到内部缓存中来，以加快频繁读取的速度。现在服务器通常是多 CPU，更普遍的是，每块CPU里有多个内核，而每个内核都维护了自己的缓存，那么这时候多线程并发就会存在缓存不一致性，这会导致严重问题。</p><p><img src="https://img.musnow.top/i/2023/02/202301031154743.webp" alt="img"></p><p>总线锁就是将cpu和内存之间的<strong>通信</strong>锁住，使得在锁定期间，其他cpu处理器不能操作其他内存中数据，故总线锁开销比较大！</p><p>总线锁的实现是采用cpu提供的<code>LOCK#</code>信号，当一个cpu在总线上输出此信号时，其他cpu的请求将被阻塞，那么该cpu则<strong>独占共享内存</strong>，相当于锁住了</p><ul><li>何为总线？</li></ul><p>CPU总线是所有CPU与芯片组连接的主干道，<strong>负责CPU与外界所有部件的通信</strong>，包括高速缓存、内存、北桥，其控制总线向各个部件发送控制信号、通过地址总线发送地址信号指定其要访问的部件、通过数据总线双向传输</p><p><img src="https://img.musnow.top/i/2023/02/202301031153214.png" alt="image-20230103115306140"></p><h1 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5.死锁"></a>5.死锁</h1><p>死锁就是一种因为两放都不会释放对方需要的资源，从而陷入的永久等待状态</p><h2 id="5-1-死锁情况演示"><a href="#5-1-死锁情况演示" class="headerlink" title="5.1 死锁情况演示"></a>5.1 死锁情况演示</h2><p>举个例子，张三拿了锁A，申请锁B的时候，发现锁B无法申请，而进入等待；李四拿了锁B，接下来他想申请锁A，结果发现张三拿着锁A，那就只能进入等待。这就陷入了一个僵局，张三想要李四的，李四想要张三的，谁都不让谁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> m1;<span class="comment">//锁1</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> m2;<span class="comment">//锁2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func1</span><span class="params">(<span class="type">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m2);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func1 is running... &quot;</span> &lt;&lt;(<span class="type">const</span> <span class="type">char</span>*)arg&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m2);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m1);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 is running... &quot;</span> &lt;&lt;(<span class="type">const</span> <span class="type">char</span>*)arg&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;m1,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;m2,<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">nullptr</span>,func1,(<span class="type">void</span>*)<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">nullptr</span>,func2,(<span class="type">void</span>*)<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分离</span></span><br><span class="line">    <span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;main running...&quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m1);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这个代码便能模拟出这个情况，线程1先要了锁1，再要锁2；线程2先要锁2再要锁1，他们俩就容易打起来，造成死锁。</p><p>运行代码的时候我们却发现，似乎并不是这样的，线程1好像还是成功拿到了俩把锁，并运行了起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./test</span><br><span class="line">main running...</span><br><span class="line">func1 is running... t1</span><br><span class="line">func1 is running... t1</span><br><span class="line">main running...</span><br><span class="line">func1 is running... t1</span><br><span class="line">main running...</span><br><span class="line">func1 is running... t1</span><br><span class="line">main running...</span><br></pre></td></tr></table></figure><p>那是因为我们没有执行其他一些工作，从而将线程1和2申请锁的时间错开</p><p>将代码改成下面这样，利用<code>usleep</code>让两个线程休眠不同时间，结果就不同了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func1</span><span class="params">(<span class="type">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">200</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m2);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func1 is running... &quot;</span> &lt;&lt;(<span class="type">const</span> <span class="type">char</span>*)arg&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func2</span><span class="params">(<span class="type">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m2);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">300</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m1);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2 is running... &quot;</span> &lt;&lt;(<span class="type">const</span> <span class="type">char</span>*)arg&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m1);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，此时只有主线程在运行，线程t1和t2出现了死锁！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-12-23_线程死锁]$ ./test</span><br><span class="line">main running...</span><br><span class="line">main running...</span><br><span class="line">main running...</span><br><span class="line">main running...</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/02/202211031204889.jpg" alt="QQ图片20220519220428"></p><h2 id="5-2-死锁的条件"><a href="#5-2-死锁的条件" class="headerlink" title="5.2 死锁的条件"></a>5.2 死锁的条件</h2><ul><li>互斥条件：某份资源同一时间只能由一个执行流访问</li><li>请求与保持：一个执行流因请求某种资源进入阻塞等待，而不释放自己的资源（好比上面代码例子中两个线程都不释放自己的锁，又想要别人的锁）</li><li>不剥夺条件：一个执行流已获得的资源，在未使用之前不能被剥夺（部分锁是允许被剥夺的）</li><li>循环等待：若干执行流之间形成一种头尾相接的循环等待资源的状态</li></ul><p>一把锁也能造成死锁吗？答案是肯定的！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;m1);</span><br><span class="line">pthread_mutex_lock(&amp;m1);</span><br><span class="line"><span class="comment">//两次申请同一把锁</span></span><br></pre></td></tr></table></figure><p>如果有人写出这种bug代码，那就会出现一把锁把自己死锁了；死锁本来就是代码的bug，所以这种低级错误也是死锁的情况之一😂</p><h2 id="5-3-避免死锁"><a href="#5-3-避免死锁" class="headerlink" title="5.3 避免死锁"></a>5.3 避免死锁</h2><p>避免死锁，其中最简单明了的办法，就是破坏上面提到的死锁的4个条件；其中互斥条件没啥好办法破坏（除非你不加锁），更主要的是看另外3个条件是否能破坏！</p><ul><li>保持加锁顺序一致：不要出现上面代码中的线程a先申请锁1，线程b先申请锁2的情况。在不同的执行流中，按相同的顺序申请锁（比如线程a和b都是按锁1&#x2F;2的顺序申请的）一定程度上能破坏<code>请求与保持</code>条件</li><li>降低加锁的粒度：锁保护的区域变小，加锁的粒度减小，能一定程度上避免锁未释放</li><li>资源一次性分配：减少临时资源分开给的情况</li><li>允许抢占：线程之间依靠优先级抢夺锁，这种情况就是<strong>锁允许被剥夺</strong></li></ul><hr><h1 id="6-线程安全"><a href="#6-线程安全" class="headerlink" title="6.线程安全"></a>6.线程安全</h1><p>线程安全：多个线程并发执行同一段代码的时候，<strong>不会</strong>出现不同的结果</p><p>线程不安全的情况：</p><ul><li>不保护临界资源</li><li>在多线程操作中调用<strong>不可重入</strong>函数（概念见<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/128138012?spm=1001.2014.3001.5502">linux信号</a>部分）</li><li>返回指向静态变量的指针的函数</li></ul><p>线程安全：</p><ul><li>每个线程只操作局部变量，或者只对全局、静态变量只读不写</li><li>接口对线程来说是原子操作（被锁保护）</li><li>多个线程切换不会使函数接口的结果出现<strong>二义性</strong></li><li>多线程操作不调用不可重入函数</li></ul><p>注意，绝大多数的系统自带的库（比如C++的STL库）都是<strong>不可重入</strong>的</p><p><img src="https://img.musnow.top/i/2023/02/202212241021973.jpeg" alt="QQ图片20220512164211"></p><p>不可重入是函数的一种<strong>性质</strong>，并不是它的缺点！如果一个库函数明明告知你了我是不可重入的，你还不加保护的在多线程操作中调用它，<strong>那么这段代码是有bug的</strong>，并不是库函数本身有问题</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/1309150756/">https://blog.musnow.top/posts/1309150756/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm1.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4215614474/" title="【图床】博客表情包"><img class="cover" src="https://img.musnow.top/i/2023/02/202211031201961.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【图床】博客表情包</div></div></a></div><div class="next-post pull-right"><a href="/posts/3856317267/" title="【docker】绿联nas部署mysql+wikijs"><img class="cover" src="/img/bg/gm2.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【docker】绿联nas部署mysql+wikijs</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2186356144/" title="【Linux】线程概念 | 同步"><img class="cover" src="/img/bg/gm5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-30</div><div class="title">【Linux】线程概念 | 同步</div></div></a></div><div><a href="/posts/1969264863/" title="【Linux】线程实例 | 简单线程池"><img class="cover" src="/img/bg/gm17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-19</div><div class="title">【Linux】线程实例 | 简单线程池</div></div></a></div><div><a href="/posts/822375107/" title="【Linux】旋转锁 | 读写锁"><img class="cover" src="/img/bg/gm22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-20</div><div class="title">【Linux】旋转锁 | 读写锁</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Artalk</span><span class="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">288</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-text">1.1 执行流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%97%B6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.2 线程创建时做了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">1.3 内核源码中的体现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A7%81%E6%9C%89%E7%89%A9"><span class="toc-text">1.4 线程的私有物</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">1.5.3 线程结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%BA%BF%E7%A8%8B%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1.5 线程优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E7%BC%BA%E7%82%B9"><span class="toc-text">1.5.1 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E4%BC%98%E7%82%B9"><span class="toc-text">1.5.2 优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-linux%E4%B8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.6 linux下线程和进程的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="toc-text">2.基础函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-pthread-create"><span class="toc-text">2.1 pthread_create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-pthread-join"><span class="toc-text">2.2 pthread_join</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%9F%BA%E7%A1%80%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-text">2.2.1 基础的多线程操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-C-%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-text">2.2.2 C++的多线程操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-text">2.3 线程退出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-retval"><span class="toc-text">2.3.1 retval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-pthread-exit"><span class="toc-text">2.3.2 pthread_exit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-ptrhead-cancel"><span class="toc-text">2.3.3 ptrhead_cancel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E4%B8%8D%E4%BC%9A%E5%90%91%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%EF%BC%9F"><span class="toc-text">2.3.4 为什么进程退出不会向主进程发送信号？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-5-exit"><span class="toc-text">2.3.5 exit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-pthread-detach"><span class="toc-text">2.4 pthread_detach</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%AE%9E%E6%93%8D"><span class="toc-text">2.4.1 实操</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-detach%E5%90%8Ejoin"><span class="toc-text">2.4.2 detach后join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E5%90%8E%EF%BC%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%85%88%E9%80%80%E5%87%BA"><span class="toc-text">2.4.3 线程分离后，主线程先退出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-gettid-x2F-syscall"><span class="toc-text">2.5 gettid&#x2F;syscall</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">3.相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%BA%BF%E7%A8%8Bid%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3.1 线程id是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-pthread%E5%BA%93"><span class="toc-text">3.2 pthread库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-text">3.3 线程的局部存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="toc-text">4.线程互斥问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-text">4.1 临界资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8E%9F%E5%AD%90-x2F-%E4%BA%92%E6%96%A5%E6%80%A7"><span class="toc-text">4.2 原子&#x2F;互斥性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81"><span class="toc-text">4.3 线程加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-pthread-mutex-init"><span class="toc-text">4.3.1 pthread_mutex_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%8A%A0%E9%94%81-x2F-%E8%A7%A3%E9%94%81"><span class="toc-text">4.3.2 加锁&#x2F;解锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E5%8A%A0%E9%94%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">4.3.3 加锁的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%A4%BA%E4%BE%8B-%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="toc-text">4.4 示例-倒水问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%9C%A8%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-text">4.4.1 只有一个线程在工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%8A%A0%E9%94%81-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">4.4.2 加锁-问题解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%8A%A0%E9%94%81%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%A7%A3%E9%87%8A"><span class="toc-text">4.5 加锁的进一步解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%8A%A0%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="toc-text">4.5.1 加锁原子性的保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E6%80%BB%E7%BA%BF%E9%94%81"><span class="toc-text">4.5.2 总线锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%AD%BB%E9%94%81"><span class="toc-text">5.死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5%E6%BC%94%E7%A4%BA"><span class="toc-text">5.1 死锁情况演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">5.2 死锁的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">5.3 避免死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">6.线程安全</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/721187015/" title="【面经】C++面筋记录 (一) 231021"><img src="https://pic1.zhimg.com/v2-6150a176a227aa058a9d3c1f7c54130c_r.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【面经】C++面筋记录 (一) 231021"></a><div class="content"><a class="title" href="/posts/721187015/" title="【面经】C++面筋记录 (一) 231021">【面经】C++面筋记录 (一) 231021</a><time datetime="2023-10-21T10:50:14.000Z" title="发表于 2023-10-21 18:50:14">2023-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4006913293/" title="【Linux】wsl安装的ubuntu不支持POSIX消息队列 | 已解决"><img src="https://img.musnow.top/i/2023/10/f317c38d511b44a48ff5dc5df48b1c80.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Linux】wsl安装的ubuntu不支持POSIX消息队列 | 已解决"></a><div class="content"><a class="title" href="/posts/4006913293/" title="【Linux】wsl安装的ubuntu不支持POSIX消息队列 | 已解决">【Linux】wsl安装的ubuntu不支持POSIX消息队列 | 已解决</a><time datetime="2023-10-17T04:30:55.000Z" title="发表于 2023-10-17 12:30:55">2023-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2839269095/" title="【微机】DOSBox在windows上的安装和masm的配置"><img src="https://img.musnow.top/i/2023/10/62cba64fa60c2fd957b5968d4387109b.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【微机】DOSBox在windows上的安装和masm的配置"></a><div class="content"><a class="title" href="/posts/2839269095/" title="【微机】DOSBox在windows上的安装和masm的配置">【微机】DOSBox在windows上的安装和masm的配置</a><time datetime="2023-10-16T17:49:13.000Z" title="发表于 2023-10-17 01:49:13">2023-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2565866661/" title="【Linux】ubuntu/centos8安装zsh终端"><img src="https://img.musnow.top/i/2023/10/5ebc935468a46d95ac77e65dc879c66d.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Linux】ubuntu/centos8安装zsh终端"></a><div class="content"><a class="title" href="/posts/2565866661/" title="【Linux】ubuntu/centos8安装zsh终端">【Linux】ubuntu/centos8安装zsh终端</a><time datetime="2023-10-15T09:12:55.000Z" title="发表于 2023-10-15 17:12:55">2023-10-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/bg/mothra.png)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 慕雪年华</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%872023007189-red" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.staticfile.org/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline.musnow.top',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.staticfile.org/waline/2.15.5/waline.min.css').then(() => {
      getScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js').then(initWaline)
    })
  }
}

if ('Artalk' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="click-heart" src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>