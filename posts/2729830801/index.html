<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【Redis】04.常用变量类型 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis的常用变量类型以及数据类型相关命令的介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="【Redis】04.常用变量类型">
<meta property="og:url" content="https://blog.musnow.top/posts/2729830801/index.html">
<meta property="og:site_name" content="慕雪的寒舍">
<meta property="og:description" content="Redis的常用变量类型以及数据类型相关命令的介绍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png">
<meta property="article:published_time" content="2024-02-14T12:37:08.000Z">
<meta property="article:modified_time" content="2024-03-07T12:42:16.000Z">
<meta property="article:author" content="慕雪年华">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【Redis】04.常用变量类型",
  "url": "https://blog.musnow.top/posts/2729830801/",
  "image": "https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png",
  "datePublished": "2024-02-14T12:37:08.000Z",
  "dateModified": "2024-03-07T12:42:16.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "慕雪年华",
      "url": "https://blog.musnow.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/2729830801/index.html"><link rel="preconnect"/><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"/><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"/><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: '/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Redis】04.常用变量类型',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/equipment/equipment.css?1"><link rel="stylesheet" href="/rating/rating.css?1"><script src="/js/typing_style.js"></script><script>var _hmt = _hmt || [];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?f444e8de702765e309d1a751aa12203e";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/main/mothra.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">460</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/rating/"><i class="fa-fw fas fa-film"></i><span> 书·影</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnow.blog.csdn.net/"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/favicon.jpg" alt="Logo"><span class="site-name">慕雪的寒舍</span></a><a class="nav-page-title" href="/"><span class="site-name">【Redis】04.常用变量类型</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/rating/"><i class="fa-fw fas fa-film"></i><span> 书·影</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnow.blog.csdn.net/"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【Redis】04.常用变量类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-14T12:37:08.000Z" title="发表于 2024-02-14 20:37:08">2024-02-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-07T12:42:16.000Z" title="更新于 2024-03-07 20:42:16">2024-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">16.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div class="ai-summary"><div class="ai-explanation" style="display: block;" data-summary="这里是慕雪的小助手，这篇文章介绍了Redis中字符串类型的特性及其相关命令包括string类型的无编码转换和512MB大小限制，中文存储和显示，整数存储和原子性加减操作，以及setnx、msetnx、setex、psetex、incr、incrby、decr、decrby、incrbyfloat、append和getrange等命令的使用方法和注意事项。">慕雪的小助手正在绞尽脑汁···</div><div class="ai-title"> <div class="ai-title-left"> <i class="fa-brands fa-slack"></i><div class="ai-title-text">慕雪小助手的总结</div></div><div class="ai-tag" id="ai-tag">LongCat-Flash-Chat</div></div></div><div id="post-outdate-notice" data="{&quot;limitDay&quot;:180,&quot;messagePrev&quot;:&quot;距离上次更新本文已经过去了&quot;,&quot;messageNext&quot;:&quot;天，文章部分内容可能已经过时，请注意甄别。&quot;,&quot;postUpdate&quot;:&quot;2024-03-07 20:42:16&quot;}" hidden></div><p>本文是对Redis的变量类型以及和特定数据类型相关命令的介绍。</p>
<h2 id="1-string">1 string</h2>
<p><a target="_blank" rel="noopener" href="https://redis.io/docs/data-types/strings/">Redis Strings | Redis</a></p>
<h3 id="1-1-介绍">1.1 介绍</h3>
<p>Redis中，所有key都是字符串类型，作为value的字符串有几个特性</p>
<ul>
<li>无编码转换（存的是什么取出来就是什么），所以你可以用string来存放二进制文件；</li>
<li>限制大小为512MB（避免过长的string操作耗时）；</li>
</ul>
<p>在MySQL中默认的字符集是拉丁文，此时插入中文内容会直接报错编码无法识别而失败，需要修改MySQL数据库的字符集。而在Redis中（不配置的情况下）插入中文，可以正常存放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 你好</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br></pre></td></tr></table></figure>
<p>这里get查看的时候显示的是中文编码。此时Redis客户端没有配置字符集转码，所以没能显示中文，但实际上中文就是这么存放的（这就好比英文存放的是对应ASCII码一样）。</p>
<p>因为Redis服务端没有对编码进行转换，所以它遇到乱码问题（比如烫烫烫）的概率更小。但依旧不建议使用<code>非英文+数字</code>的组合来做Redis的key。</p>
<p>如果想让redis-cli的终端中<strong>正常显示中文</strong>，可以在启动的时候添加<code>--raw</code>选项。如下所示，添加了该选项后，正常显示出了value的中文值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">你好</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：使用该选项会导致Redis中显示的<code>(nil)</code>变成空字符串，极易产生误导！如果不是硬性需要在控制台中显示中文，请不要使用该选项！</p>
</blockquote>
<p>另外，在<a href="https://blog.musnow.top/posts/3677820204">Redis基础命令博客</a>中提到，Redis会对不同的string采取不同的存储方式，其中对于纯整数的string采用的是int来存放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">int</span><br></pre></td></tr></table></figure>
<p>所以在Redis中如果存放一个<strong>整数数字</strong>（包括负数），虽然对应变量类型是string，但实际上就是一个int数字来存放的，Redis还提供了一系列原子性命令来对整数进行加减操作！</p>
<h3 id="1-2-相关命令">1.2 相关命令</h3>
<p>set/get以及mset/mget命令已经在<a href="https://blog.musnow.top/posts/3677820204">Redis基础命令博客</a>中讲解了，这里不再重复。</p>
<h4 id="1-2-1-setnx-msetnx">1.2.1 setnx/msetnx</h4>
<p>setnx等价于set中添加nx选项，只有在key不存在的时候才能正常设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure>
<ul>
<li>当key值已经存在的时候，setnx不会执行任何操作，返回0；</li>
<li>当key值不存在的时候，setnx等价于set，返回1；</li>
</ul>
<p>如下所示，key1存在，设置失败返回0；key2不存在，设置成功返回1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx key1 value2</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setnx key2 value2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>还有一个命令是msetnx（和mset一样），可以原子性地同时setnx多个key。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></table></figure>
<ul>
<li>只要给定的多个key中有一个key存在，msetnx就会失败且什么都不做，返回0；</li>
<li>只有给定的多个key全部都不存在，msetnx才会成功，返回1；</li>
</ul>
<p>如下所示，此时key1和key2已经存在，设置失败返回0；key3和key4都不存在， 设置成功返回1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; msetnx key1 value1 key2 value2 key3 value3</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; msetnx key3 value3 key4 value4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-setex-psetex">1.2.2 setex/psetex</h4>
<p>setex/psetex是在设置key的时候指定过期时间，只是时间单位不一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key value second</span><br><span class="line">psetex key value milisecond</span><br></pre></td></tr></table></figure>
<p>虽然set命令本身已经提供了关于这些功能的选项，但直接使用<strong>特定命令</strong>来设置而不是用命令的参数会更加方便且符合人的直觉，使用门槛也更低！</p>
<blockquote>
<p>对于学习过Linux系统使用的开发人员而言，命令参数已经见怪不怪了。但对于初次学习Redis使用而没有接触过Linux系统的萌新而言，使用一个简单的命令来传递单个参数，会比在set后面添加一大堆选项更加简单且不容易犯错。</p>
</blockquote>
<h4 id="1-2-3-数字加减命令">1.2.3 数字加减命令</h4>
<p>因为Redis中的整数是用int来存放的，所以它提供了一些命令来<strong>原子性</strong>的操作数字。这些命令中如果给定的key不存在，则会将其视作0，新建一个key再加上目标值。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>incr key</td>
<td>value + 1</td>
<td>value必须是整数</td>
</tr>
<tr>
<td>incrby key n</td>
<td>value + n</td>
<td>value必须是整数，给定的n可以是负数</td>
</tr>
<tr>
<td>decr key</td>
<td>value - 1</td>
<td>value必须是整数</td>
</tr>
<tr>
<td>decrby key n</td>
<td>value - n</td>
<td>value必须是整数，给定的n可以是负数</td>
</tr>
<tr>
<td>incrbyfloat key n</td>
<td>value +/- 小数</td>
<td>给定的n可以是负数来实现减法</td>
</tr>
</tbody>
</table>
<p>注意：<code>decrbyfloat</code>命令是不存在的！</p>
<p>前四个命令的操作数value必须是一个整数，否则会失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; incr key1</span><br><span class="line">ERR value is not an integer or out of range</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; decr key1</span><br><span class="line">ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure>
<p>使用incrbyfloat命令操作一个整数后，它的存放方式就不再是int，而变成embstr了。此时我们依旧可以用incrbyfloat命令来继续添加小数（包括减去小数）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">int</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 19.3</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">embstr</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 0.7</span><br><span class="line">120</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">embstr</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 -0.7</span><br><span class="line">119.3</span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-append">1.2.4 append</h4>
<p>append命令用于在字符串之后追加字符串。如果给定key不存在，则和set命令等价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure>
<p>该命令的时间复杂度是<code>O(1)</code>，返回值是追加后的字符串长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; append k 45</span><br><span class="line">5</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>如果尝试给k追加一个中文，字符串长度会是多少呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; append k 你好</span><br><span class="line">11</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345你好</span><br></pre></td></tr></table></figure>
<p>可以看到，最终长度是11，因为Redis不会对字符串进行转码，中文在UTF8环境下是用三个字节存放的，所以两个中文就是6字节，加上原本的5个字节，最终长度就是11字节。</p>
<p>不使用<code>--raw</code>启动redis-cli，就能看到这两个中文的原始编码值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;12345\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-5-getrange">1.2.5 getrange</h4>
<p>这个命令用于获取字符串的子串，start/end指定一个区间（采用下标方式且为闭区间）。该命令的时间复杂度是<code>O(N)</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end</span><br></pre></td></tr></table></figure>
<p>测试如下，2代表从第三个字符开始，4代表第五个字符结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 123456789</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 4</span><br><span class="line">&quot;345&quot;</span><br></pre></td></tr></table></figure>
<p>这里的start/end还可以给负数。当end为负数时，代表直接取到末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange key -1 4</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 -1</span><br><span class="line">&quot;3456789&quot;</span><br></pre></td></tr></table></figure>
<p>当start小于end时，返回空字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange key 2 0</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 1</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 2</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>
<p>注意，getrange的切分是严格按照字节切分的，如果是中文，则难以拆分出一个正常的中文字符（要按3个字节的间隙才能拆出一个正常的中文字符）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-cli</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;12345\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 -1</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 6</span><br><span class="line">&quot;\xe4\xbd&quot;</span><br><span class="line"></span><br><span class="line">❯ sudo redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345你好</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 6</span><br><span class="line">�</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 7</span><br><span class="line">你</span><br></pre></td></tr></table></figure>
<h4 id="1-2-6-setrange">1.2.6 setrange</h4>
<p>从指定下标开始替换字符串，返回值是替换后字符串的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setrange key offset value</span><br></pre></td></tr></table></figure>
<p>示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">123456789</span><br><span class="line">127.0.0.1:6379&gt; setrange key 3 hhhh</span><br><span class="line">9</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">123hhhh89</span><br></pre></td></tr></table></figure>
<h4 id="1-2-7-strlen">1.2.7 strlen</h4>
<p>返回字符串的长度，单位是字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure>
<h3 id="1-3-编码介绍">1.3 编码介绍</h3>
<p>string有三种编码方式</p>
<ul>
<li>embstr：为短字符串优化；</li>
<li>int：为非负整数优化；</li>
<li>raw：原始字符串；</li>
</ul>
<p>注意，不管是什么编码方式，都不会影响对string的数字加减命令的使用（只要value是一个数字就行，即便小数的编码方式是embstr，也依旧可以使用数字加减命令）</p>
<h3 id="1-4-应用场景">1.4 应用场景</h3>
<h4 id="1-4-1-用户信息缓存">1.4.1 用户信息缓存</h4>
<p>绝大部分情况下，我们需要获取的信息都是字符串类型的。比如用户个人信息的JSON字符串。</p>
<p>此时可以在Redis中用<code>user:平台:用户ID</code>的方式做key，来保存用户基本个人信息的JSON字符串。如果使用Redis+MySQL的组合的话，整个用户信息的请求步骤如下：</p>
<ul>
<li>用户浏览器/APP中点击个人信息页面，客户端发起请求，假设用户ID为100；</li>
<li>应用服务器收到请求，先去请求Redis服务器：<code>get user:平台:100</code>；</li>
<li>Redis中成功查询到用户信息，将Json字符串返回给用户；</li>
<li>没有在Redis中查询到，使用SQL请求MySQL服务器<code>select 用户个人信息字段 from user where user_id = '100';</code></li>
<li>将MySQL返回的相关键值按预定格式制作成JSON字符串，返回给用户；</li>
<li>将该JSON字符串写入Redis服务器：<code>set user:平台:100 JSON字符串</code>；</li>
</ul>
<p>在set的时候还可以设定一定的过期时间，在保证缓存的实时性的基础上，避免Redis中的数据始终增长而导致内存爆满。（当然，内存快满的时候Redis有淘汰策略可供选择，那是后面要学习的内容了）。</p>
<h4 id="1-4-2-视频播放量计数">1.4.2 视频播放量计数</h4>
<p>对于视频点赞、播放量这种经常变动的数据，可以使用Redis来做计数。比如使用<code>vedio:hit:视频ID</code>作为key，代表视频的播放量。</p>
<p>当用户点击一个视频的时候，发起请求给应用服务器，服务器在返回视频相关信息的同时，将播放量加一的信息，使用incr命令传递给Redis服务器。</p>
<p>但只用Redis肯定是不够的，还会有一个MySQL数据表来存放视频对应的点赞、播放、收藏等全量信息。此时我们可以令起一个服务，<strong>异步</strong>地同步视频播放量、点赞等相关信息到MySQL表中。</p>
<blockquote>
<p><strong>异步</strong>同步：并非来一个视频请求就同步到MySQL一次，而是以一定频率（时间间隔）将Redis中的数据同步到MySQL表中。这样能保证Redis中的数据能有备份。</p>
</blockquote>
<p>实际场景中，要想开发一个稳定的真实计数系统，还需要考虑防作弊、不同维度计数、避免单点问题以及数据持久化等等方面。这些都需要根据具体的业务逻辑来特殊处理。</p>
<h4 id="1-4-3-cookie-seesion">1.4.3 cookie+seesion</h4>
<p>在HTTP网络服务中，cookie是最常用的用于标定客户端信息的方式。有些网站并非每次打卡都需要登录，而是登录了之后能维持一段时间不需要用户每次都重新登录。在这个过程中，就是通过浏览器端的cookie和服务器端的session来实现的。</p>
<ul>
<li>cookie：存放在用户的浏览器中，其值是通过HTTP的<code>Set-Cookie</code>响应头由服务器告知用户浏览器的；</li>
<li>session：存放在服务器端（实际上服务器端应该存放的是cookie-session的键值对），用于标定用户的基本信息；</li>
</ul>
<p>当用户登录后，服务器会生成一个<code>session_id</code>，将其和登录的用户信息绑定（键值对），并发送包含<code>Set-Cookie</code>头的HTTP报文给客户端，将<code>session_id</code>告知用户。浏览器在检测到这个响应头后，会将它对应的值保存在本地，下一次向这个网站发起HTTP请求的时候就会带上这个设置的cookie值里面的<code>session_id</code>。</p>
<p>服务器收到HTTP请求后，检查请求头中的<code>Cookie</code>字段，并与服务器中存放的<code>session_id</code>键值对进行对比，得到对应的用户，则返回用户相关信息，即当前用户已登录。</p>
<p>实现网页登录在一定时间后过期的功能，只需要在Redis中给这个键值对设置一个<strong>过期时间</strong>就行了。</p>
<p>使用cookie+session的方式也更加方便多个应用服务器之间的消息共享。因为<strong>负载均衡</strong>的存在，用户的请求可能会被发送到不同的应用服务器。只要这些应用服务器<strong>使用相同的Redis</strong>，它们就都能检索到用户的cookie对应的session信息，也就知道了当前用户的个人信息，可以正常进行服务（其实就是信息在多个应用服务器之中进行共享）。整个过程中用户完全不会发现自己的请求并非是同一个服务器来处理的。</p>
<h4 id="1-4-4-验证码">1.4.4 验证码</h4>
<p>这个场景就很常见了，手机验证码/邮箱验证码都是如此，在Redis中设置一个验证码的key，value是对应用户的id，<strong>并给这个key设置一定的过期时间</strong>，就能实现验证码的功能。</p>
<p>当用户输入验证码后，检查Redis中的key，当value中的id和用户的id相同，则代表验证成功。用户id不同或验证码的key不存在，则验证失败。</p>
<p>这个过程中可能还会涉及到间隔60s秒才能发送一次验证码（这种限制大概率是前端做的处理）后端自然也可以通过一些缓存的时间值来做检查，避免给同一个用户在较短时间内发送多个验证码（会影响性能）。</p>
<h2 id="2-Hash">2 Hash</h2>
<h3 id="2-1-介绍">2.1 介绍</h3>
<p>哈希是比较常见的一种数据结构，Redis本身的key-value结构其实就是通过哈希来实现的。同时，Redis也提供了hash作为value的数据类型，为了和Redis本身的kv进行区分，hash类型内的键值对被称为<code>field-value</code>。</p>
<p>比如存放一个用户信息，原本我们可以采用如下方式，在key中用冒号作为分隔来保存个人信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user:1:name 李四</span><br><span class="line">user:1:age  20</span><br><span class="line">user:1:sex  男</span><br></pre></td></tr></table></figure>
<p>现在我们可以直接将value设置为hash类型，然后在其中再设置对应的field和value，看上去就更加明了。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>field</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>user:1</td>
<td>name</td>
<td>李四</td>
</tr>
<tr>
<td>user:1</td>
<td>ag</td>
<td>20</td>
</tr>
<tr>
<td>user:1</td>
<td>sex</td>
<td>男</td>
</tr>
</tbody>
</table>
<h3 id="2-2-相关命令">2.2 相关命令</h3>
<h4 id="2-2-1-HSET-HGET-HGETALL">2.2.1 HSET/HGET/HGETALL</h4>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/hget/">https://redis.io/commands/hget/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value [field value ...]</span><br><span class="line">HGET key field</span><br></pre></td></tr></table></figure>
<p>经过之前的命令学习，现在这里的命令就很好理解了。</p>
<ul>
<li>HSET用于设置hash类型内部的field，可以同时设置多个field；</li>
<li>HGET用于获取hash类型内部的field。</li>
</ul>
<p>HSET命令的返回值是设置成功的field的个数。当HGET命令指定的key或者field不存在时，会返回<code>nil</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET user:1 name 李四 age 20 sex 男</span><br><span class="line">3</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 name</span><br><span class="line">&quot;\xe6\x9d\x8e\xe5\x9b\x9b&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 age</span><br><span class="line">20</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 info</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; HGET user:2 test</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<p>与此相关的还有HSETNX和HGETALL两个命令</p>
<ul>
<li>HSETNX：当hash中的field不存在时才会设置成功（返回值为1），如果field已经存在则不会做任何操作（返回值为0）；</li>
<li>HGETALL：返回hash中的所有field-value值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;\xe6\x9d\x8e\xe5\x9b\x9b&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;sex&quot;</span><br><span class="line">6) &quot;\xe7\x94\xb7&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:2</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-HEXISTS">2.2.2 HEXISTS</h4>
<p>该命令用于查询hash中的某个field是否存在。存在返回1，key或者field不存在返回0；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 info</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS user:2 info</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-HDEL">2.2.3 HDEL</h4>
<p>删除hash中指定的field，可以一次性给定多个field来删除。返回值是本次成功删除的field个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></table></figure>
<p>示例，info字段是不存在的，实际上只成功删除了name字段，所以返回值为1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HDEL user:1 name info</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>如果你需要删除整个hash，直接使用Redis的del命令将key给删除就行了。比如<code>del user:1</code>;</p>
<h4 id="2-2-4-HKEYS">2.2.4 HKEYS</h4>
<p>获取哈希中的所有field（仅获取字段）；该命令的时间复杂度是<code>O(N)</code>，N是hash中的field个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure>
<p>这个命令和HGETALL命令有所不同，HGETALL命令会获取field和value，但HKEYS只会获取field。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;sex&quot;</span><br><span class="line">4) &quot;\xe7\x94\xb7&quot;</span><br><span class="line">127.0.0.1:6379&gt; HKEYS user:1</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;sex&quot;</span><br></pre></td></tr></table></figure>
<p>当然，这个命令和HGETALL命令都需要<strong>谨慎使用</strong>，它们就和<code>keys *</code>一样，需要遍历整个hash对象，而我们在执行命令之前并不知道一个hash里面到底有多少个field。如果查询的hash中field过多，那就会阻塞Redis。</p>
<h4 id="2-2-5-HVALS">2.2.5 HVALS</h4>
<p>获取hash中的所有value，和HKEYS的功能对应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HVALS user:1</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;\xe7\x94\xb7&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-6-HMGET">2.2.6 HMGET</h4>
<p>一次性获取hash中的多个field（一条命令查询优于多条命令查询）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMGET user:1 age sex</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;\xe7\x94\xb7&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-7-HSCAN（仅作介绍）">2.2.7 HSCAN（仅作介绍）</h4>
<p>和HGETALL/HKEYS/HVALS这些一次性遍历完毕所有hash内元素的命令不同，HSCAN命令是“渐进式遍历”（就好比过程化SQL和编程中常用的for循环）。</p>
<p>所谓渐进式遍历，就是敲一次命令遍历一次，这样遍历的过程和速度都是可控的，不会阻塞Redis。当你需要获取一个hash中的所有field/value，使用HSCAN会更加安全。</p>
<p>官网文档：<a target="_blank" rel="noopener" href="https://redis.io/commands/hscan/">https://redis.io/commands/hscan/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>
<h4 id="2-2-8-HLEN">2.2.8 HLEN</h4>
<p>获取一个hash中键值对的个数，该命令时间复杂度是<code>O(1)</code>，因为Redis有使用额外变量来存放hash中元素的个数，无需遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure>
<p>使用该命令遍历一个不存在的key时，返回值为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HLEN user:1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HLEN user:2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h4 id="2-2-9-HINCRBY-HINCRYBYFLOAT">2.2.9 HINCRBY/HINCRYBYFLOAT</h4>
<p>这些命令和string中的数字操作命令一致，因为hash中的value也是字符串，也能当作数字来处理。参数可以是负数来左减法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field num</span><br><span class="line">HINCRBYFLOAT key field float</span><br></pre></td></tr></table></figure>
<p>测试如下，两个命令的返回值都是操作之后的变量值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrby user:1 age 10</span><br><span class="line">(integer) 30</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user:1 age 10.13</span><br><span class="line">&quot;40.13&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user:1 age -11.13</span><br><span class="line">&quot;29&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-10-HSTRLEN">2.2.10 HSTRLEN</h4>
<p>计算hash中value的字符串长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSTRLEN key field</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 age</span><br><span class="line">&quot;29&quot;</span><br><span class="line">127.0.0.1:6379&gt; hstrlen user:1 age</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h3 id="2-3-编码介绍">2.3 编码介绍</h3>
<p>之前在Redis基础命令博客的<code>object encoding</code>中提到，hash有两种编码方式，一个是ziplist，一个是hashtable。</p>
<p>其中ziplist是在hash中元素较少的情况下使用的，如下所示，刚开始hash中的f1只有3个字节的字符串长度，使用的是ziplist来存放；当我买尝试设置一个非常长的字符串f2，就会切换成hashtable来存放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset key f1 111</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset key f2 235xczbjlkq3e5jl123j5ljlbsjlk32j6l5k1hasldg82357989789787124nlahbkasdlj3215897avsalkjl32k51432097zvlmq32j5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>
<p>如果你了解hashtable的数据结构，以拉链法为例，它会有一个数组，内部存放链表指针。存放数据时，通过哈希函数计算出key所在下标位置，将value链接到数组下标位置的对应指针上，即为存放完毕。当hash表中的元素较少时，数组可能会空出几个下标的位置没有value链接，这几个下标的空间就算是浪费了。</p>
<p>而使用ziplist就可以节省这部分空间的浪费，对应的代价是ziplist的读写速度会慢于原生hashtable。</p>
<p>在Redis中可以通过下面两个配置项来设置hash什么时候使用ziplist，写入<code>/etc/redis/redis.conf</code>即可。</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash-max-ziplist-entries</td>
<td>设置field个数为多少以下时使用ziplist</td>
<td>默认512个</td>
</tr>
<tr>
<td>hash-max-ziplist-value</td>
<td>设置hash中value字符串的最大长度</td>
<td>默认为64字节</td>
</tr>
</tbody>
</table>
<h3 id="2-4-应用场景">2.4 应用场景</h3>
<h4 id="2-4-1-关系数据库缓存">2.4.1 关系数据库缓存</h4>
<p>正如介绍阶段时提到的，hash非常适合用于存放一些结构化的数据。以用户数据为例，可以用uid作为key的标识，内部存放对应的个人信息。有的时候为了方便，还会在hash中再存放一次uid。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>field</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>user:1</td>
<td>uid</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>name</td>
<td>李四</td>
</tr>
<tr>
<td></td>
<td>ag</td>
<td>20</td>
</tr>
<tr>
<td></td>
<td>sex</td>
<td>男</td>
</tr>
<tr>
<td>user:2</td>
<td>uid</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>name</td>
<td>王五</td>
</tr>
<tr>
<td></td>
<td>age</td>
<td>23</td>
</tr>
<tr>
<td></td>
<td>sex</td>
<td>男</td>
</tr>
</tbody>
</table>
<p>这样其实就好比一个MySQL数据库中的表</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>name</th>
<th>age</th>
<th>sex</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>李四</td>
<td>20</td>
<td>男</td>
</tr>
<tr>
<td>2</td>
<td>王五</td>
<td>23</td>
<td>男</td>
</tr>
</tbody>
</table>
<p>用这种方式，我们可以将MySQL中的表直接缓存在Redis中，提供更加快速的查询。需要修改数据的时候，也可以采用先修改Redis中的数据，再异步同步到MySQL中的方式来提高效率。</p>
<p>当然，使用string+json的方式也可以存放结构化数据，但在使用的时候就涉及到了<strong>json的序列化和反序列化</strong>，效率会低于直接使用Redis里面的hash来存放，不过使用hash会有更大的空间消耗。</p>
<p>这里还涉及到了高内聚/低内聚的概念：</p>
<ul>
<li>高内聚：把有关联的数据存放在一起；</li>
<li>低内聚：有关联的东西散开存放了；</li>
</ul>
<p>使用hash来存放用户数据，就属于高内聚。如果使用<code>user:1:name</code>、<code>user:1:age</code>的key/value来存放用户数据，就是低内聚，因为用户信息被拆开存放在了不同的key中。</p>
<p>同理，上文string中提到的视频播放量信息统计，也可以使用hash来存放一个视频的点击量/点赞量，将一个视频的数据存放在一个hash中，而不用string来存放。</p>
<p>我们在设计的时候都强调<strong>高内聚、低耦合</strong>，就是为了整个系统能有更好的整洁度，维护更加方便。</p>
<h4 id="2-4-2-hash和关系数据库的区别">2.4.2 hash和关系数据库的区别</h4>
<ul>
<li>哈希类型是稀疏的，关系数据库是结构化的。比如不同的hash里面的field完全没有关系，可以随意设置，但MySQL中一个表想插入一个数据，就必须依照表的要求设置所有数据；</li>
<li>关系数据库可以进行复杂的关系查询（比如多表查询），而Redis很难模拟关系查询，维护的复杂度很高且没有必要。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/d37409c171aed0f980fdea3322e6a54d.png" alt="image-20240219143844313"></p>
<h2 id="3-List">3 List</h2>
<h3 id="3-1-介绍">3.1 介绍</h3>
<p>Redis中的list列表类型提供了头插头删/尾插尾删的命令，我们可以将它当作顺序表、栈、队列来使用。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/e9f8229179473cd0d3ed2afb034c539d.png" alt="image-20240219144352348"></p>
<p>列表中的元素是按序存放的，所以我们可以通过下标来访问列表中的元素或获取一个范围中的元素。列表中的元素<strong>允许重复</strong>。</p>
<h3 id="3-2-相关命令">3.2 相关命令</h3>
<h4 id="3-2-1-LINDEX">3.2.1 LINDEX</h4>
<p>根据下标查看list中的数据，当下标超出范围时返回<code>nil</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure>
<p>index支持负数下标，从后往前数。比如<code>-1</code>代表从后往前第一个数据（即list末尾数据）。</p>
<p>注意，该命令的时间复杂度是<code>O(N)</code>，因为Redis中的list并非时刻采用顺序表来实现（会有不同编码方式），不能保证顺序表下标访问那样的快速！</p>
<h4 id="3-2-2-LPUSH-RPUSH">3.2.2 LPUSH/RPUSH</h4>
<p>头插命令，支持一次插入多个数据。如果指定的key不是list类型则报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]</span><br></pre></td></tr></table></figure>
<p>注意，当一次插入多个数据时，最后一个数据会在list的头部（按命令中出现的顺序，从左往右插入）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; lpush key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lindex key 0</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>尾插也是相同的效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key element [element ...]</span><br></pre></td></tr></table></figure>
<p>一次性插入多个数据的时候，也是最后一个数据在list的末尾。可以用lindex命令指定<code>-1</code>下标来获取末尾的数据（从后往前数第一个值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 5 6 7 8</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lindex key -1</span><br><span class="line">&quot;8&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-LPOP-RPOP">3.2.3 LPOP/RPOP</h4>
<p>从list的头部或者尾部去除数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]</span><br><span class="line">RPOP key [count]</span><br></pre></td></tr></table></figure>
<p>注意，高版本Redis才有可选的count选项，当前我使用的Redis仅可一次pop一个元素，返回值是被删除的元素。</p>
<blockquote>
<p>Starting with Redis version 6.2.0: Added the <code>count</code> argument.</p>
</blockquote>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop key</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>如果是高版本，指定count参数后，会返回一个被删除元素的array，效果参考下面这个官网给出的examples。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot;</span><br><span class="line">(integer) 5</span><br><span class="line">redis&gt; LPOP mylist</span><br><span class="line">&quot;one&quot;</span><br><span class="line">redis&gt; LPOP mylist 2</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;three&quot;</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;four&quot;</span><br><span class="line">2) &quot;five&quot;</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure>
<p>如果尝试操作一个空的list或者不存在的key，返回值是<code>nil</code>；如下所示，key1的list中只有1个元素，第一次成功删除元素，但是第二次操作的时候key1是一个空list，操作失败返回<code>nil</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key1 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpop key1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop key1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p>当一个list中不存在元素的时候，Redis会自动将该list的key删除！如下所示，当我们把test键值中的元素全部删除时，这个test键值就直接不存在了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; lpush key 1 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush test 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">2) &quot;test&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop test</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-4-LRANGE">3.2.4 LRANGE</h4>
<p>查看list中指定范围的元素，这里的区间是闭区间（最终结果包含start和stop下标的数据），当start小于stop时返回<code>empty array</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure>
<p>示例如下，指定了<code>0</code>和<code>-1</code>等同于获取list中的全部元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br></pre></td></tr></table></figure>
<p>注意，此处Redis是用array返回的一个结果集，序号是从1开始的（和list中的下标不一样且无关）</p>
<h5 id="3-2-4-1-超出下标范围">3.2.4.1 超出下标范围</h5>
<p>另外，使用lrange命令指定下标的时候，如果下标超出范围，也会得到尽可能符合下标结果的数据，这点和lindex不同！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key 3 10</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">4) &quot;7&quot;</span><br><span class="line">5) &quot;8&quot;</span><br></pre></td></tr></table></figure>
<p>如上所示，我尝试访问3到10的数据，但实际上list中的数据下标到7就结束了（一共八个元素），但Redis并没有报错或返回<code>empty array</code>，而是获取了从下标3开始一直到list末尾的数据。</p>
<p>同理，当你访问超出范围的负数下标，也能得到类似的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key -10 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br></pre></td></tr></table></figure>
<p>当然，实际业务时正确使用合法肯定是更好的！</p>
<h4 id="3-2-5-LPUSHX-RPUSHX">3.2.5 LPUSHX/RPUSHX</h4>
<p>和LPUSH/RPUSH作用相同，多了一个对key是否存在的检测，只有key存在时才能插入成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX key element [element ...]</span><br><span class="line">RPUSHX key element [element ...]</span><br></pre></td></tr></table></figure>
<p>返回值是插入成功的元素个数，如果key不存在则返回0；</p>
<h4 id="3-2-6-LINSERT">3.2.6 LINSERT</h4>
<p>这个命令的作用是在指定pivot元素位置插入一个元素，可以通过参数选择是在指定pivot元素之前插入，还是在指定pivot元素之后插入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key &lt;BEFORE | AFTER&gt; pivot element</span><br></pre></td></tr></table></figure>
<p>该命令时间复杂度是<code>O(N)</code>，N是pivot元素和list开头的距离，返回值如下：</p>
<ul>
<li>成功时返回插入元素后list的元素个数；</li>
<li>key不存在时返回0；</li>
<li>pivot元素不存在时返回-1，且什么都不会发生；</li>
</ul>
<p>测试如下，这里选择的已有元素是4，before会在4之前插入一个元素，after会在4之后插入一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; linsert key before 4 10</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;2&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert key after 4 11</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;11&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure>
<p>清空key后重新测试，如果list中有多个相同的pivot元素，会在哪里操作呢？可以看到它会在第一个5的位置操作，即pivot会采用第一个找到的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key 1 2 5 3 4 5 6</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; linsert key before 5 10</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;5&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-7-LLEN">3.2.7 LLEN</h4>
<p>获取list的长度，如果key不存在返回0；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure>
<h4 id="3-2-8-LREM">3.2.8 LREM</h4>
<p>删除list中指定的值，返回值是被删除元素的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count element</span><br></pre></td></tr></table></figure>
<p>count参数的可选项如下</p>
<ul>
<li>count大于0：从前往后删除count个等于element的元素；</li>
<li>count小于0：从后往前删除<code>|count|</code>个等于element的元素；</li>
<li>count等于0：删除所有等于element的元素；</li>
</ul>
<p>测试一下，使用rpush可以让list和我们输入的顺序一致。这里指定的count大于0，删除的元素是1，最终删除了从前往后数的两个1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 1 2 3 4 1 2 3 4 1 2 3 4</span><br><span class="line">(integer) 12</span><br><span class="line">127.0.0.1:6379&gt; lrem key 2 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line"> 1) &quot;2&quot;</span><br><span class="line"> 2) &quot;3&quot;</span><br><span class="line"> 3) &quot;4&quot;</span><br><span class="line"> 4) &quot;2&quot;</span><br><span class="line"> 5) &quot;3&quot;</span><br><span class="line"> 6) &quot;4&quot;</span><br><span class="line"> 7) &quot;1&quot;</span><br><span class="line"> 8) &quot;2&quot;</span><br><span class="line"> 9) &quot;3&quot;</span><br><span class="line">10) &quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>再指定count为-1，删除元素是3，会删除从后往前数的第一个3；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem key -1 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;4&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;4&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">8) &quot;2&quot;</span><br><span class="line">9) &quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>指定count为0，删除元素是4，list中的所有4都会被删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem key 0 4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;1&quot;</span><br><span class="line">6) &quot;2&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-9-LTRIM">3.2.9 LTRIM</h4>
<p>删除list中指定区间<strong>外</strong>的元素（即保留指定的闭区间，其他都删除）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key start stop</span><br></pre></td></tr></table></figure>
<p>示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; ltrim key 2 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-10-LSET">3.2.10 LSET</h4>
<p>该命令可以设置某个下标的元素（替换）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSET key index element</span><br></pre></td></tr></table></figure>
<p>该命令的时间复杂度是<code>O(N)</code>，这就和LINDEX的原因一样，因为Redis不总是用顺序表来存放list的数据，所以无法保证<code>O(1)</code>下标访问一样的时间复杂度。</p>
<h4 id="3-2-11-BLPOP-BRPOP（阻塞版本）">3.2.11 BLPOP/BRPOP（阻塞版本）</h4>
<h5 id="3-2-11-1-阻塞命令说明">3.2.11.1 阻塞命令说明</h5>
<p>BLPOP和BRPOP是LPOP/RPOP的阻塞版本，命令里面的B就是block阻塞的缩写。这也是我们第一次接触Redis里面的“阻塞命令”。</p>
<p>使用这两个命令的时候，list就可以当作一个阻塞队列（和Linux的管道也有点相似）了：</p>
<ul>
<li>如果队列为空，尝试出队列时会阻塞;</li>
<li>如果队列已满，尝试入队列时会阻塞;</li>
</ul>
<p>对于Redis而言，list一般不存在“满”的情况，我们大多考虑队列为空的情况。而Redis的单线程模型也保证了这个“阻塞队列”是线程安全的。</p>
<p>另外，Redis提供的阻塞命令<strong>并不会把自己给阻塞</strong>，而类似于阻塞了客户端，使用BLPOP/BRPOP的时候需要给定一个timeout参数，在阻塞等待的期间，<strong>Redis可以正常响应其他的命令和请求</strong>。</p>
<p>而被阻塞的客户端实际上是在等待其他客户端往对应list中插入新元素。</p>
<h5 id="3-2-11-2-命令参数">3.2.11.2 命令参数</h5>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/blpop/">https://redis.io/commands/blpop/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>
<p>注意：timeout单位为秒，Redis 6中可以设置为小数，设置为0时代表永久阻塞。</p>
<p>这两个命令都可以指定多个key，当指定多个key的时候，Redis会进行从左往右的遍历，只要其中一个key对应的list有元素，就会立刻返回。相当于一次等多个list。</p>
<blockquote>
<p>如果有多个客户端都需要使用这两个命令来等待<strong>同一个key</strong>，那么先执行命令的客户端会得到弹出的元素。</p>
</blockquote>
<p>因为blpop/brlpop都支持多个key值等待，为了标定弹出的键属于哪一个key，这两个命令在返回的时候会返回array类型的key+value；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; blpop key 0</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>当超时时间结束时，给定的几个key的list还是为空，则会返回nil；</p>
<h5 id="3-2-11-3-命令预期行为">3.2.11.3 命令预期行为</h5>
<p>当list不为空时，lpop和blpop的命令行为完全一致。</p>
<p>当list为空，且blpop指定的timeout时间中没有新元素插入list时：</p>
<ul>
<li>lpop会立马得到nil；</li>
<li>blpop会在等待timeout时间后得到nil；</li>
<li>此时lpop和brlpop的命令行为就不一致了。</li>
</ul>
<p>当list为空，且timeout时间内有新元素插入</p>
<ul>
<li>因为原本list是为空的，所以lpop还是会立马得到nil；</li>
<li>blpop会在新元素插入后返回key和新元素；</li>
</ul>
<h5 id="3-2-11-4-阻塞测试">3.2.11.4 阻塞测试</h5>
<p>下面是一个阻塞时的测试，使用0来指定永久阻塞，当右侧终端回车提交插入操作时，左侧的阻塞会立马返回数据。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/2a28441785171abc8b20a27af768dfd9.png" alt="image-20240221211633743"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/a466d5f993d3a24be07a7dd93037a8c1.png" alt="image-20240221211639797"></p>
<p>尝试等待多个key，只要有一个key返回了数据，阻塞的终端就会立马返回。虽然说这个等待时遍历的顺序是从左往右的，但由于Redis是单线程模型，不会出现两个key同时新增数据的情况，<strong>总会有个先后顺序</strong>，所以最终还是等待列表中，<strong>哪一个key先有数据插入</strong>，哪一个key就会被blpop返回。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/8156e009dcd7a8ac02ade9b5df20bbed.png" alt="image-20240221212327656"></p>
<p>如果开始遍历的时候，key没有数据，key1和key2有数据，那么Redis就会按从左往右的原则，返回key1的数据。</p>
<h3 id="3-3-编码方式">3.3 编码方式</h3>
<p>旧版本Redis中list的编码方式有两个</p>
<ul>
<li>ziplist：为短list优化</li>
<li>linklist：正常的双向链表</li>
</ul>
<p>但在新版本（Redis 3.2以后）对list的数据结构进行了改造，使用quicklist替代了ziplist/linklist，更多信息可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/12624691.html">redis数据结构-快速列表</a>；</p>
<h3 id="3-4-应用场景">3.4 应用场景</h3>
<h4 id="3-4-1-栈和队列">3.4.1 栈和队列</h4>
<p>使用list来模拟栈或者队列的功能</p>
<ul>
<li>队列：只使用rpush和lpop命令</li>
<li>栈：只使用lpush和lpop命令</li>
</ul>
<h4 id="3-4-2-班级中有那些学生-部门中有那些员工">3.4.2 班级中有那些学生/部门中有那些员工</h4>
<p>可以使用list将一个班级id作为key，学生id作为list里面的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class:1  [1,3,4]</span><br><span class="line">class:2  [2,5,6]</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过list来得知每个班级对应的学生id编号。部门和员工的关系也是一样的；</p>
<h4 id="3-4-3-消息队列">3.4.3 消息队列</h4>
<p>使用BLPOP/BRPOP这两个命令就可以让list作为一个简单的消息队列来使用。</p>
<p>以“生产-消费者模型”为例，生产者往list中插入数据，消费者使用BLPOP等待新数据的插入并进行消费。此时可以有多个生产者进行push，也可以有多个消费者同时使用BLPOP命令等待list中的新数据插入。</p>
<p>因为Redis不存在多线程竞争的问题，所以新数据插入后只会有一个消费者能拿到数据进行消费。并且多个消费者执行BLPOP命令时也存在一个先后顺序，按123的顺序来说的话，这一次消费者1拿到了数据，下一次就是消费者2，再下一次就是消费者3，不会出现某个消费者<strong>饥饿</strong>的情况。</p>
<h4 id="3-4-4-视频信息传递">3.4.4 视频信息传递</h4>
<p>以一个视频网站为例，使用list作为消息队列时，可以采用一个视频对应多个key的方式来处理</p>
<ul>
<li>视频数据</li>
<li>视频评论</li>
<li>视频新弹幕</li>
<li>…</li>
</ul>
<p>对应的消费者可以通过BLPOP命令一次性等待多个key，这样不管是新的评论来了，还是新的弹幕来了，都能在第一时间被处理。</p>
<h4 id="3-4-5-用户的timeline">3.4.5 用户的timeline</h4>
<p>因为list里面的元素是有序的，先插入的始终是在list的头部。我们就可以通过list来实现一个时间轴的功能。</p>
<p>当用户新建一个微博的时候，就将这个微博的id插入用户相关的list，这样用户和他上传的微博就有了一个时间的关系，还可以用lrange命令很方便的获取到用户的前n个微博，或某个区间的微博。</p>
<p>下面是一个分页获取用户微博的伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 先获取用户前10个微博</span></span><br><span class="line">key_list = <span class="string">&quot;LRANGE user:1:blog 0 9&quot;</span></span><br><span class="line"><span class="comment">## 遍历每个key获取到微博的详细信息</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> key_list: </span><br><span class="line">    blog_info = <span class="string">&quot;HGETALL key&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里就会出现一个问题，假设将单个分页需要显示的数据设置为100，那么每次循环中就会多次调用hash类型的HGETALL命令，导致Redis可能被阻塞。</p>
<blockquote>
<p>这个问题可以使用pipeline来解决，相当于将多个Redis命令合并成一个网络请求来执行，可以减少网络传输多次导致的延迟。后续将学习相关内容。</p>
</blockquote>
<p>另外一个问题是，lrange针对list两头的查询效率还不错（因为可以直接从头或从尾部开始遍历）但对中间的分页获取的效率就有点低了。这个问题可以通过list来解决（有点类似分库分表）。</p>
<h2 id="4-Set">4 Set</h2>
<p>set是一个集合，集合中的每个元素都是string类型。它和list的区别主要在于：</p>
<ul>
<li>set的元素不可以重复；</li>
<li>set的元素是无序的；</li>
</ul>
<p>所谓无需，是相对于list的有序而言的（注意，list的有序指的是顺序表中元素的顺序，并不是说list会按大小排序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3] 和 [1,3,2] 是两个不同的list</span><br><span class="line">[1,2,3] 和 [1,3,2] 和 [2,3,1] 都是相同的set</span><br></pre></td></tr></table></figure>
<h3 id="4-1-相关命令">4.1 相关命令</h3>
<h4 id="4-1-1-SADD">4.1.1 SADD</h4>
<p>SADD命令用于给set中添加元素，为了和list中的元素作区分，set中的元素被称为member。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure>
<p>返回值表示本次操作添加成功了几个元素，重复的元素只会被添加一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4 5 4</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-SMEMBERS">4.1.2 SMEMBERS</h4>
<p>查看set的所有成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers key</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-3-SISMEMBER">4.1.3 SISMEMBER</h4>
<p>查看某个元素是否在集合中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure>
<p>返回值为1代表存在，返回值为0代表不存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember key 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember key 120</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h4 id="4-1-4-SPOP">4.1.4 SPOP</h4>
<p>该命令可以弹出set中的元素。但因为set是无序的，所以我们只能指定删除元素的个数，Redis会**随机删除（弹出）**set中的元素，这一点在官方文档中有说明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure>
<p>返回值是被删除的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; spop key 2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure>
<p>这个命令也能体现出set中元素无序的概念。我们按1234构架两个set，尝试进行spop，能发现每次删除的元素的顺序是不一样的，完全随机。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-5-SRANDMEMBER">4.1.5 SRANDMEMBER</h4>
<p>这个命令和SPOP功能类似，返回set中的一个或多个随机数据，但不会删除该数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></table></figure>
<h4 id="4-1-6-SMOVE">4.1.6 SMOVE</h4>
<p>将某个元素从set1移动到set2，或者说是从source中删除，在destination中新增。</p>
<p>如果destination中已经存在该元素，则只会删除source中的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member</span><br></pre></td></tr></table></figure>
<p>测试如下，该命令成功时返回1，不成功返回0（source中不存在该元素时失败）；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 5 6</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smove key1 key2 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers key2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">127.0.0.1:6379&gt; smove key1 key2 33</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h4 id="4-1-7-SREM">4.1.7 SREM</h4>
<p>删除set中的指定元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure>
<h4 id="4-1-8-SINTER-SINTERSTORE">4.1.8 SINTER/SINTERSTORE</h4>
<p>求两个集合的交集，即获取同时出现在两个set中的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure>
<p>这个命令的时间复杂度是<code>O(M*N)</code>，其中M是最小的集合元素个数，N是最大的集合元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sinter key1 key2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>另外一个命令是SINTERSTORE，它多了一个存储功能，求了交集后，存储到destination中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>
<p>这个命令的返回值是最终交集的元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sinterstore key3 key1 key2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h4 id="4-1-9-SUNION-SUNIONSTORE">4.1.9 SUNION/SUNIONSTORE</h4>
<p>求两个集合的并集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUNION key [key ...]</span><br><span class="line">SUNIONSTROE destination key [key ...]</span><br></pre></td></tr></table></figure>
<p>功能和上面的命令类似，这里就不做演示了</p>
<h4 id="4-1-10-SDIFF-SDIFFSTORE">4.1.10 SDIFF/SDIFFSTORE</h4>
<p>求集合的差集，即存在于第一个key，但是不在第二个key中的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br><span class="line">SDIFFSTROE destination key [key ...]</span><br></pre></td></tr></table></figure>
<p>实测如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff key2 key1</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure>
<p>如果key的数量不止两个，你可以理解为Redis会进行依次计算。即先计算key1和key2的差集，再将结果和key3进行计算。如下所示，key1和key2的差集包含1和2，但是key3中有1，所以最终的差集结果就只有2了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key3 1 3 7 8</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2 key3</span><br><span class="line">1) &quot;2&quot;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-11-SCARD">4.1.11 SCARD</h4>
<p>获取set中元素的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; scard key1</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>
<h3 id="4-2-编码方式">4.2 编码方式</h3>
<p>set有两种编码方式</p>
<ul>
<li>intset：如果set中全都是整数，采用这种方式，可以通过<code>set-max-intset-entries</code>来配置元素个数，超过这个数量的会采用hashtable。</li>
<li>hashtable：当set中有其他非数字类型时，采用这种方式。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd key 1afb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-应用场景">4.3 应用场景</h3>
<h4 id="4-3-1-保存标签">4.3.1 保存标签</h4>
<p>一个视频会有相关标签，一个用户也会有相关标签，set类型有元素不能重复的特性，比较适合用于保存某个对象的标签。</p>
<p>比如某个用户的兴趣爱好，这些爱好能帮助刻画一个用户画像，以便更加精确的推送用户喜欢的东西（或则广告）</p>
<h4 id="4-3-2-公共好友">4.3.2 公共好友</h4>
<p>通过集合求交集，能很容易得到两个用户的公共好友，或者共同关注了xxx。</p>
<h4 id="4-3-3-记录站点PV-UV">4.3.3 记录站点PV/UV</h4>
<p>站点PV（Page View）指的是站点的访问量，每次点击一个页面，就会产生一个PV。</p>
<p>站点UV（User View）指的是站点的用户访问量，每个用户只会记录一次。</p>
<p>因为PV和UV的记录内容不同，在记录的时候需要进行一定的去重。比如UV需要按用户去重，一个用户只能记录一次。这时候用set来去重就比较方便了，当有新用户访问页面的时候，就将这个用户的id插入到对应key的set中，最终记录UV就获取这个set的长度就行。</p>
<h2 id="5-Zset">5.Zset</h2>
<p>Zset是有序的集合，在集合的基础上，对内容会进行升序排序。</p>
<p>Zset中的member同时引入了一个<code>score</code>分数的属性，每个member都会有一个自己的分数，排序的时候就是按分数的大小来进行<strong>升序排序</strong>的。Zset中的member必须唯一，但score分数可以重复。</p>
<p>注意，member/score之间的关系并非键值对，score只是member的一个用于排序的属性值！在Zset中既可以通过member查询score，也可以通过score来查询member。</p>
<p>Zset中的分数可以是小数。如果多个元素有相同的分数，则按元素的字典序排序。</p>
<h3 id="5-1-相关命令">5.1 相关命令</h3>
<h4 id="5-1-1-ZADD">5.1.1 ZADD</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member</span><br><span class="line">  ...]</span><br></pre></td></tr></table></figure>
<p>ZADD命令有很多选项，其中一些选项之前已经见过了</p>
<ul>
<li>XX：只有member存在的时候，才会更新分数；</li>
<li>NX：插入新的member，如果已存在则不做任何处理；</li>
<li>LT：只有新的score<strong>小于</strong>当前score时才会更新， 不会阻止添加新元素（不存在的member正常添加）</li>
<li>GT：同上，但只有新的score<strong>大于</strong>当前score时才会更新；</li>
<li>CH：一般情况下，ZADD返回新元素被添加的个数。添加CH选项后，会返回新元素被添加的个数+被修改score的元素个数。</li>
<li>INCR：当指定此选项时，ZADD的作用类似于ZINCRBY。在此模式下只能指定一个score-element对。</li>
</ul>
<p>这个命令的时间复杂度<code>O(log(N))</code>，<strong>N是Zset中元素的个数</strong>。因为zset作为有序的结构，需要将新插入的元素放到正确的位置上，这个操作会有耗时。</p>
<p>插入数据后查看，可以看到数据是按我们预先设置是分数进行升序排序的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 98 lisi 97 zhangsan 99 wangwu</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br></pre></td></tr></table></figure>
<p>测试NX/XX选项，如果不带任何选项，则会更新已有member的分数（原本lisi的分数是98），带了NX选项后，lisi的分数没有被修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 99 lisi</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;99&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd key nx 100 lisi</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;99&quot;</span><br></pre></td></tr></table></figure>
<p>带xx选项，lisi的分数被修改成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key xx 100 lisi</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p>带xx选项操作一个不存在的member，没有被新增</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key xx 100 kk</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p>ch会在返回值中带上被修改分数的个数，如下所示，kk已经存在，将分数修改为110，带ch选项，返回值为1；再次修改kk的分数，不带ch选项，返回值为0，但kk的分数已经被修改为112了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key xx ch 110 kk</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd key xx 112 kk</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 9) &quot;kk&quot;</span><br><span class="line">10) &quot;112&quot;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-ZRANGE">5.1.2 ZRANGE</h4>
<p>ZRANGE类似于LRANGE，可以用下标的方式来查看Zset中的元素个数。因为Zset中的元素有序，所以它存在“下标”的概念。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count]</span><br><span class="line">  [WITHSCORES]</span><br></pre></td></tr></table></figure>
<p>这个命令的时间复杂度是<code>O(log(N)+M)</code>，其中N是ZSET中的元素个数，M是需要返回的元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 98 lisi 97 zhangsan 99 wangwu</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br></pre></td></tr></table></figure>
<p>使用WITHSCORES选项，可以让元素和分数一起返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;98&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;99&quot;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-ZCARD">5.1.3 ZCARD</h4>
<p>获取Zset中元素的个数（被称为zset的基数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wangwu&quot;</span><br><span class="line">3) &quot;kk1&quot;</span><br><span class="line">4) &quot;lisi&quot;</span><br><span class="line">5) &quot;kk&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcard key</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>
<h4 id="5-1-4-ZCOUNT">5.1.4 ZCOUNT</h4>
<p>返回分数在min/max之间的元素个数，默认是闭区间，包含min和max的值。该命令的时间复杂度是<code>O(log(N))</code>，N是Zset中元素个数。</p>
<p>zset在存放一个member的时候会保存它的次序（可以简单理解为下标）所以这个命令不是通过min到max的遍历来获取元素的，而是先找到min和max这两个边界值的member，再获取到它们的元素次序，<strong>最终将次序相减，就得到了元素个数</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure>
<p>可以使用括号来表示开区间，注意括号都是加在前面的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key (min (max</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line"> 1) &quot;zhangsan&quot;</span><br><span class="line"> 2) &quot;97&quot;</span><br><span class="line"> 3) &quot;wangwu&quot;</span><br><span class="line"> 4) &quot;99&quot;</span><br><span class="line"> 5) &quot;kk1&quot;</span><br><span class="line"> 6) &quot;100&quot;</span><br><span class="line"> 7) &quot;lisi&quot;</span><br><span class="line"> 8) &quot;100&quot;</span><br><span class="line"> 9) &quot;kk&quot;</span><br><span class="line">10) &quot;112&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcount key 97 100</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zcount key 97 (100</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<p>因为zset中的score可以使用浮点数，在Redis中有两个特殊的浮点数，用于表示正无穷大<code>inf</code>和负无穷大<code>-inf</code>，所以在ZCOUNT的min/max中也可以用这两个特殊的浮点数来筛选</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcount key -inf 100</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>
<h4 id="5-1-5-ZREVRANCE">5.1.5 ZREVRANCE</h4>
<p>这个命令的作用和ZRANGE类似，但返回的数据是降序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANGE key 0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;kk&quot;</span><br><span class="line"> 2) &quot;112&quot;</span><br><span class="line"> 3) &quot;lisi&quot;</span><br><span class="line"> 4) &quot;100&quot;</span><br><span class="line"> 5) &quot;kk1&quot;</span><br><span class="line"> 6) &quot;100&quot;</span><br><span class="line"> 7) &quot;wangwu&quot;</span><br><span class="line"> 8) &quot;99&quot;</span><br><span class="line"> 9) &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure>
<p>注意，该命令在Redis6.2中已经<strong>弃用(deprecated)</strong>，在ZRANGE中使用REV选项能实现它的功能。</p>
<blockquote>
<p>As of Redis version 6.2.0, this command is regarded as deprecated.</p>
<p>It can be replaced by <a target="_blank" rel="noopener" href="https://redis.io/commands/zrange"><code>ZRANGE</code></a> with the <code>REV</code> argument when migrating or writing new code.</p>
</blockquote>
<h4 id="5-1-6-ZPOPMAX-ZPOPMIN">5.1.6 ZPOPMAX/ZPOPMIN</h4>
<p>删除并返回Zset中分数最高的count个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZPOPMAX key [count]</span><br><span class="line">ZPOPMIN key [count]</span><br></pre></td></tr></table></figure>
<p>这个命令可以用来解决TopK问题，假设有个10元素的zset，想获得score在前3的元素的一个set，可以使用两种方式</p>
<ul>
<li>ZPOPMAX将高三位弹出并存放到另外一个zset中；</li>
<li>ZPOPMIN将低七位弹出，此时剩下的就是高三位；</li>
</ul>
<p>测试如下，pop的时候会将member和score一起弹出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zpopmax key 2</span><br><span class="line">1) &quot;kk&quot;</span><br><span class="line">2) &quot;112&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;100&quot;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-7-BZPOPMAX">5.1.7 BZPOPMAX</h4>
<p>这个命令是ZPOPMAX的阻塞版本，当key中没有元素时会阻塞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BZPOPMAX key [key ...] timeout</span><br></pre></td></tr></table></figure>
<p>这个和BLPOP/BRPOP的效果一样，不做演示了。</p>
<h4 id="5-1-8-ZRANK">5.1.8 ZRANK</h4>
<p>获取一个Zset中某个成员的排名（返回的是排名序号，以0开始）时间复杂度<code>O(log(N))</code>，N是Zset中元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member [WITHSCORE]</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wangwu&quot;</span><br><span class="line">3) &quot;kk1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrank key wangwu</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>redis7.2后，添加withscore选项，会同时返回这个成员的分数</p>
<h4 id="5-1-9-ZREVRANK">5.1.9 ZREVRANK</h4>
<p>返回某个成员的排名，降序排序。时间复杂度<code>O(log(N))</code>，N是Zset中元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANK key member [WITHSCORE]</span><br></pre></td></tr></table></figure>
<p>redis7.2后，添加withscore选项，会同时返回这个成员的分数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wangwu&quot;</span><br><span class="line">3) &quot;kk1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrank key wangwu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrevrank key kk1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrevrank key zhangsan</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h4 id="5-1-10-ZSCORE">5.1.10 ZSCORE</h4>
<p>返回zset中某个成员的分数，时间复杂度为<code>O(1)</code>；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;kk1&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; zscore key kk1</span><br><span class="line">&quot;100&quot;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-11-ZREM">5.1.11 ZREM</h4>
<p>删除某个zset中的member，可以一次性传入多个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure>
<p>时间复杂度<code>O(M*log(N))</code>，N是zset中元素个数，M是需要删除的元素个数。</p>
<h4 id="5-1-12-ZREMRANGEBYRANK">5.1.12 ZREMRANGEBYRANK</h4>
<p>删除某个区间的元素，和ZRANGE的start/stop相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure>
<p>时间复杂度是<code>O(log(N)+M) </code>，N是zset中元素个数，M是区间内的元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 1 one 2 two 3 three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK key 0 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-13-ZREMRANGEBYSCORE">5.1.13 ZREMRANGEBYSCORE</h4>
<p>删除某个区间的元素，使用的是min/max分数区间，默认闭区间，也可以用左括号表示开区间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br><span class="line">ZREMRANGEBYSCORE key (min (max</span><br></pre></td></tr></table></figure>
<p>时间复杂度是<code>O(log(N)+M) </code>，N是zset中元素个数，M是区间内的元素个数。</p>
<h4 id="5-1-14-ZINCRBY">5.1.14 ZINCRBY</h4>
<p>给某个zset中的元素<strong>增加分数</strong>，如果元素不存在，则和zadd的作用相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure>
<p>时间复杂度<code>O(log(N))</code>，N为zset中元素个数。</p>
<h4 id="5-1-15-ZUNIONSTORE">5.1.15 ZUNIONSTORE</h4>
<p>这个命令会求两个zset的<strong>并集</strong>并存放到的destination中。</p>
<p>时间复杂度：<code>O(N)+O(M log(M))</code>，N是所有input参数zset中元素的个数总和，M是结果集中的元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight</span><br><span class="line">  [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]</span><br></pre></td></tr></table></figure>
<p>命令参数</p>
<ul>
<li>destination：目标zset的key，如果这个key已经存在，则会被覆盖。</li>
<li>numkeys：输入的key的个数</li>
<li>WEIGHTS：给每个入参的key设定的乘法系数，当求交集的时候，会将最终结果的分值乘以这个乘法系数再交付。不提供的时候默认为1；</li>
<li>AGGREGATE：该选项可以指定并集运算结果的聚合方式。该选项默认值为 SUM，即将输入中所有存在该元素的集合中对应的分值全部加一起。当选项被设置为 MIN 或 MAX 任意值时，结果集合将保存输入中所有存在该元素的集合中对应的分值的最小或最大值。</li>
</ul>
<p>测试如下，先不使用weights，可以看到两个zset中，相同的元素的分数会相加，one的分值变成了2，two的分值变成了4；如果只有一个zset存在的元素则保持不变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd zset2 1 &quot;one&quot; 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>使用weight提供乘法系数，zset1中的分值被乘以2，zset2中的分值被乘以3，然后二者再相加起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2 weights 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;10&quot;</span><br></pre></td></tr></table></figure>
<p>如果修改AGGREGATE策略，结果又不同，默认sum是相加；指定min是当两个zset都有某个参数的时候，选用分数较小的哪一个。比如zset1中乘法系数是2，所以one/two的分数<strong>小于</strong>zset2中的分数，最终的集合out中存放的就是zset1中的元素分数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2 weights 2 3 aggregate min</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;9&quot;</span><br></pre></td></tr></table></figure>
<p>使用<code>AGGREGATE MAX</code>存放的就会是zset2中的分数了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2 weights 2 3 aggregate max</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;6&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;9&quot;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-16-ZINTERSTORE">5.1.16 ZINTERSTORE</h4>
<p>这个命令存放并集到destination中，相关的命令选项和<code>ZUNIONSTORE</code>一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight</span><br><span class="line">  [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]</span><br></pre></td></tr></table></figure>
<p>时间复杂度：最坏情况是<code>O(N*K)+O(M*log(M))</code> ，N是最小的输入zset中的元素个数，K是输入参数中zset的个数，M是结果集中元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd zset2 1 &quot;one&quot; 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zinterstore out 2 zset1 zset2 weights 2 3</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;10&quot;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-编码方式">5.2 编码方式</h3>
<p>当zset中元素个数少的时候，会使用ziplist；</p>
<p>当元素个数较多，或者单个元素的体积较大（字符串长），使用skiplist来存储。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-max-ziplist-entries 元素少于这个数量的时候使用ziplist</span><br><span class="line">zset-max-ziplist-value   元素长度大于这个数字的时候使用skiplist</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; object encoding zset1</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd zset1 20 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zset1</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-使用场景">5.3 使用场景</h3>
<p>zset比较适合建立排行榜。诸如微博热搜、B站热搜、游戏排行榜这些，都是一个“排行榜”的应用场景。</p>
<p>游戏玩家的排位会有一个分数，排行榜按这个分数来降序排列的，并展示给用户。且可以使用zrange来进行分页查看。</p>
<p>微博热搜也可以应用zset，每个话题肯定会有一个热搜的指数，<strong>如果简单来处理</strong>，那么就是用户搜索一次这个话题，它在zset中的分数就加一（zincrby命令），这样被搜索的次数越多的话题，在热搜榜中就越靠前。</p>
<p>当然，微博实际上用的是一个综合的数值，而不是只看搜索量这个单一指标。这时候可以用zinterstore/zunionstore中的weight来实现多个维度数值的计算。比如浏览量、点赞率、转发量、评论量这些数据，在最终结果集合的时候都给他们赋予一个权值再进行计算，最终得到一个热榜的指数。</p>
<h2 id="6-Steams">6.Steams</h2>
<p>steams数据类型类似一个<code>append-only log</code>，可以让我们把一个事件投放给多个目标。你可以理解为它就是一个队列，比list更加适合作为消息中间件。</p>
<p>在Redis官网上提到了steams类型的几个应用场景</p>
<ul>
<li>事件来源监看</li>
<li>事件通知</li>
<li>消息监看（消费者进行阻塞等待）</li>
</ul>
<p>所谓事件，就是某个东西满足了某种状态的场景。比如linux多路转接中epoll/select就是通过事件来通知进程来处理io请求的，我们在进程中调用接口进行等待的时候，就相当于是在执行“消息监看”这一步骤。</p>
<h2 id="7-Geospatial">7.Geospatial</h2>
<p>这个类型就是用来存储坐标（经纬度）的，代表一个地理位置。它存储点了之后，可以进行地理半径进行查找，在导航软件中就很有用。</p>
<p>基本命令是添加和查询：</p>
<ul>
<li>GEOADD将位置添加到给定的地理空间索引（请注意，使用此命令，经度先于纬度）。</li>
<li>GEOSEARCH返回具有给定半径或<strong>地理边界框</strong>的位置。</li>
</ul>
<p>平时肯定用不上这个类型，只有接触了具体的业务才需要了解</p>
<h2 id="8-HyperLogLog">8.HyperLogLog</h2>
<p>这个数据类型的应用场景主要是用于计算（估算）集合中的元素个数。</p>
<p>比如用set来存放站点的UV的时候，假设set中存放用户id（8字节）一个1亿UV的站点大约会占用800MB的内存。看上去好像不多？毕竟一亿UV的网站哪里有那么多啊？</p>
<p>但HyperLogLog可以使用最多12KB的空间就实现上述的效果！</p>
<blockquote>
<p>The Redis HyperLogLog implementation uses up to 12 KB and provides a standard error of 0.81%.</p>
</blockquote>
<p>set占用那么多内存是因为它完整存储了用户的id，但HyperLogLog并不存放元素内容，但可以记录“元素的特征”，新增元素的时候可以判断当前元素是新增的元素还是已经存在的元素。这时候就可以用HyperLogLog来进行<strong>计数</strong>，但不能用于真正存放元素。</p>
<p>这里的底层肯定很复杂，且HyperLogLog并不能保证百分百精确。官方文档上也提到了，HyperLogLog大概会有<code>0.81%</code>的误差。</p>
<p>注意：HyperLogLog是一个算法思想，并非Redis专有的。其他工具中也可能提供这个数据结构来实现此类需求。</p>
<h2 id="9-Bitmaps">9.Bitmaps</h2>
<p>bitmaps是位图结构，本质上还是一个集合，它使用某个比特位来存放某些特定的数据，以此来节省空间。</p>
<p>比如存放数字10，我们不是直接存放整形，而是将位图中的从右往左数第10位从0改成1，这样就代表10已经存放了。</p>
<p>和HyperLogLog不存放元素相比，bitmaps虽然是用比特来表示是否存在某个元素，但<strong>实际上它是存放了这个元素的</strong>，因为我们可以通过位图中的数据还原出某个元素是否存在！比如第3个比特位是1，那么集合中就有3。</p>
<ul>
<li>不需要知道元素内容，可以使用HyperLogLog；</li>
<li>想节省空间的同时需要记录整形元素，使用bitmaps</li>
</ul>
<h2 id="10-Bitfields">10.Bitfields</h2>
<p>位域Bitfields，在C语言中<strong>位段</strong>其实就是位域；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestBit</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a:<span class="number">8</span>; <span class="comment">// 数字表示某个变量占用几个比特位</span></span><br><span class="line">    <span class="type">int</span> b:<span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span> c:<span class="number">8</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Redis中的bitfield和C语言中的位域相似，可以理解位一串二进制序列，并给某个位设置特定的哈衣，并进行读取/修改/算术运算等相关操作。</p>
<p>相比于string类型，它的核心目标还是节省空间。比如一把moba游戏中玩家的金币、KDA、补刀等信息，并不需要用大量空间来存储，使用位域可以节省空间。在Redis官网上也有相关的示例命令</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/docs/data-types/bitfields/">https://redis.io/docs/data-types/bitfields/</a></p>
<h2 id="The-end">The end</h2>
<p>Redis中最主要使用的数据类型和命令就是这些了，后续相关知识点会继续补充。</p>
<h4 id=""></h4>
<h4 id="-2"></h4>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/2729830801/">https://blog.musnow.top/posts/2729830801/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://ifdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.webp" alt="爱发电"/></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/3677820204/" title="【Redis】03.基本命令学习"><img class="cover" src="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【Redis】03.基本命令学习</div></div><div class="info-2"><div class="info-item-1">Redis基本命令学习</div></div></div></a><a class="pagination-related" href="/posts/4231483511/" title="【项目】高并发内存池项目的学习"><img class="cover" src="https://img.musnow.top/i/2024/02/c03c4843d4f6b153fc536709b8864c05.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【项目】高并发内存池项目的学习</div></div><div class="info-2"><div class="info-item-1">高并发内存池项目的学习</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/996575798/" title="【Redis】01.初步认识Redis和分布式系统"><img class="cover" src="https://img.musnow.top/i/2024/02/903cf874bef24f120d4a6f89d6f08868.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-08</div><div class="info-item-2">【Redis】01.初步认识Redis和分布式系统</div></div><div class="info-2"><div class="info-item-1">什么是Redis？什么是分布式系统？</div></div></div></a><a class="pagination-related" href="/posts/269089114/" title="【Redis】02.Ubuntu22.04安装Redis"><img class="cover" src="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-10</div><div class="info-item-2">【Redis】02.Ubuntu22.04安装Redis</div></div><div class="info-2"><div class="info-item-1">ubuntu22.04下安装redis</div></div></div></a><a class="pagination-related" href="/posts/3677820204/" title="【Redis】03.基本命令学习"><img class="cover" src="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-10</div><div class="info-item-2">【Redis】03.基本命令学习</div></div><div class="info-2"><div class="info-item-1">Redis基本命令学习</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">慕雪年华</div><div class="author-info-description">爱折腾的代码初学者</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">460</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fa fa-home"></i></a><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍，近来可好？</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-string"><span class="toc-text">1 string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">1.2 相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-setnx-msetnx"><span class="toc-text">1.2.1 setnx&#x2F;msetnx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-setex-psetex"><span class="toc-text">1.2.2 setex&#x2F;psetex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%87%8F%E5%91%BD%E4%BB%A4"><span class="toc-text">1.2.3 数字加减命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-append"><span class="toc-text">1.2.4 append</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-getrange"><span class="toc-text">1.2.5 getrange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6-setrange"><span class="toc-text">1.2.6 setrange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-7-strlen"><span class="toc-text">1.2.7 strlen</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BC%96%E7%A0%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.3 编码介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1.4 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%BC%93%E5%AD%98"><span class="toc-text">1.4.1 用户信息缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E9%87%8F%E8%AE%A1%E6%95%B0"><span class="toc-text">1.4.2 视频播放量计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-cookie-seesion"><span class="toc-text">1.4.3 cookie+seesion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-text">1.4.4 验证码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Hash"><span class="toc-text">2 Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">2.2 相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-HSET-HGET-HGETALL"><span class="toc-text">2.2.1 HSET&#x2F;HGET&#x2F;HGETALL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-HEXISTS"><span class="toc-text">2.2.2 HEXISTS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-HDEL"><span class="toc-text">2.2.3 HDEL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-HKEYS"><span class="toc-text">2.2.4 HKEYS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-HVALS"><span class="toc-text">2.2.5 HVALS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-HMGET"><span class="toc-text">2.2.6 HMGET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-7-HSCAN%EF%BC%88%E4%BB%85%E4%BD%9C%E4%BB%8B%E7%BB%8D%EF%BC%89"><span class="toc-text">2.2.7 HSCAN（仅作介绍）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-8-HLEN"><span class="toc-text">2.2.8 HLEN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-9-HINCRBY-HINCRYBYFLOAT"><span class="toc-text">2.2.9 HINCRBY&#x2F;HINCRYBYFLOAT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-10-HSTRLEN"><span class="toc-text">2.2.10 HSTRLEN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BC%96%E7%A0%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.3 编码介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.4 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98"><span class="toc-text">2.4.1 关系数据库缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-hash%E5%92%8C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.4.2 hash和关系数据库的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-List"><span class="toc-text">3 List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">3.2 相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-LINDEX"><span class="toc-text">3.2.1 LINDEX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-LPUSH-RPUSH"><span class="toc-text">3.2.2 LPUSH&#x2F;RPUSH</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-LPOP-RPOP"><span class="toc-text">3.2.3 LPOP&#x2F;RPOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-LRANGE"><span class="toc-text">3.2.4 LRANGE</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-1-%E8%B6%85%E5%87%BA%E4%B8%8B%E6%A0%87%E8%8C%83%E5%9B%B4"><span class="toc-text">3.2.4.1 超出下标范围</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-LPUSHX-RPUSHX"><span class="toc-text">3.2.5 LPUSHX&#x2F;RPUSHX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-LINSERT"><span class="toc-text">3.2.6 LINSERT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-7-LLEN"><span class="toc-text">3.2.7 LLEN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-8-LREM"><span class="toc-text">3.2.8 LREM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-9-LTRIM"><span class="toc-text">3.2.9 LTRIM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-10-LSET"><span class="toc-text">3.2.10 LSET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-11-BLPOP-BRPOP%EF%BC%88%E9%98%BB%E5%A1%9E%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-text">3.2.11 BLPOP&#x2F;BRPOP（阻塞版本）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-11-1-%E9%98%BB%E5%A1%9E%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="toc-text">3.2.11.1 阻塞命令说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-11-2-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0"><span class="toc-text">3.2.11.2 命令参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-11-3-%E5%91%BD%E4%BB%A4%E9%A2%84%E6%9C%9F%E8%A1%8C%E4%B8%BA"><span class="toc-text">3.2.11.3 命令预期行为</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-11-4-%E9%98%BB%E5%A1%9E%E6%B5%8B%E8%AF%95"><span class="toc-text">3.2.11.4 阻塞测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-text">3.3 编码方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.4 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text">3.4.1 栈和队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E7%8F%AD%E7%BA%A7%E4%B8%AD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%AD%A6%E7%94%9F-%E9%83%A8%E9%97%A8%E4%B8%AD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%91%98%E5%B7%A5"><span class="toc-text">3.4.2 班级中有那些学生&#x2F;部门中有那些员工</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">3.4.3 消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-%E8%A7%86%E9%A2%91%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">3.4.4 视频信息传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-%E7%94%A8%E6%88%B7%E7%9A%84timeline"><span class="toc-text">3.4.5 用户的timeline</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Set"><span class="toc-text">4 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">4.1 相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-SADD"><span class="toc-text">4.1.1 SADD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-SMEMBERS"><span class="toc-text">4.1.2 SMEMBERS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-SISMEMBER"><span class="toc-text">4.1.3 SISMEMBER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-SPOP"><span class="toc-text">4.1.4 SPOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-SRANDMEMBER"><span class="toc-text">4.1.5 SRANDMEMBER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-6-SMOVE"><span class="toc-text">4.1.6 SMOVE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-7-SREM"><span class="toc-text">4.1.7 SREM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-8-SINTER-SINTERSTORE"><span class="toc-text">4.1.8 SINTER&#x2F;SINTERSTORE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-9-SUNION-SUNIONSTORE"><span class="toc-text">4.1.9 SUNION&#x2F;SUNIONSTORE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-10-SDIFF-SDIFFSTORE"><span class="toc-text">4.1.10 SDIFF&#x2F;SDIFFSTORE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-11-SCARD"><span class="toc-text">4.1.11 SCARD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-text">4.2 编码方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4.3 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E4%BF%9D%E5%AD%98%E6%A0%87%E7%AD%BE"><span class="toc-text">4.3.1 保存标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E5%85%AC%E5%85%B1%E5%A5%BD%E5%8F%8B"><span class="toc-text">4.3.2 公共好友</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E8%AE%B0%E5%BD%95%E7%AB%99%E7%82%B9PV-UV"><span class="toc-text">4.3.3 记录站点PV&#x2F;UV</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Zset"><span class="toc-text">5.Zset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">5.1 相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-ZADD"><span class="toc-text">5.1.1 ZADD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-ZRANGE"><span class="toc-text">5.1.2 ZRANGE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-ZCARD"><span class="toc-text">5.1.3 ZCARD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-ZCOUNT"><span class="toc-text">5.1.4 ZCOUNT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-5-ZREVRANCE"><span class="toc-text">5.1.5 ZREVRANCE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-6-ZPOPMAX-ZPOPMIN"><span class="toc-text">5.1.6 ZPOPMAX&#x2F;ZPOPMIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-7-BZPOPMAX"><span class="toc-text">5.1.7 BZPOPMAX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-8-ZRANK"><span class="toc-text">5.1.8 ZRANK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-9-ZREVRANK"><span class="toc-text">5.1.9 ZREVRANK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-10-ZSCORE"><span class="toc-text">5.1.10 ZSCORE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-11-ZREM"><span class="toc-text">5.1.11 ZREM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-12-ZREMRANGEBYRANK"><span class="toc-text">5.1.12 ZREMRANGEBYRANK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-13-ZREMRANGEBYSCORE"><span class="toc-text">5.1.13 ZREMRANGEBYSCORE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-14-ZINCRBY"><span class="toc-text">5.1.14 ZINCRBY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-15-ZUNIONSTORE"><span class="toc-text">5.1.15 ZUNIONSTORE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-16-ZINTERSTORE"><span class="toc-text">5.1.16 ZINTERSTORE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-text">5.2 编码方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5.3 使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Steams"><span class="toc-text">6.Steams</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Geospatial"><span class="toc-text">7.Geospatial</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-HyperLogLog"><span class="toc-text">8.HyperLogLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Bitmaps"><span class="toc-text">9.Bitmaps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Bitfields"><span class="toc-text">10.Bitfields</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-end"><span class="toc-text">The end</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-2"><span class="toc-text"></span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/5899307553/" title="【Hexo】为自己的博客站点加上离线的AI摘要">【Hexo】为自己的博客站点加上离线的AI摘要</a><time datetime="2025-10-02T01:08:21.000Z" title="发表于 2025-10-02 09:08:21">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4044218607/" title="【Agent.04】AI时代的hello world：调用OpenAI接口，与大模型交互">【Agent.04】AI时代的hello world：调用OpenAI接口，与大模型交互</a><time datetime="2025-09-30T07:25:08.000Z" title="发表于 2025-09-30 15:25:08">2025-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3454235760/" title="【面试】求职面试大忌：自断后路">【面试】求职面试大忌：自断后路</a><time datetime="2025-09-29T11:31:10.000Z" title="发表于 2025-09-29 19:31:10">2025-09-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4200815612/" title="【AI】配置claude-code-router转发Claude Code请求至OpenAI API格式">【AI】配置claude-code-router转发Claude Code请求至OpenAI API格式</a><time datetime="2025-09-27T12:33:46.000Z" title="发表于 2025-09-27 20:33:46">2025-09-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/main/mothra.webp);"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15" style="position:relative; top:2px;">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a></br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a></br><a href="https://travel.moe/go.html" target="_blank"><img src="/img/ico/moe-default-white.png" style="width:auto;height:25px" title="异次元之旅-跃迁-我们一起去萌站成员的星球旅行吧！"></a>&nbsp<a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = '/pluginsSrc/mathjax/es5/tex-mml-chtml.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('/pluginsSrc/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  let artalkItem = null
  const option = null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'

  const destroyArtalk = () => {
    if (artalkItem) {
      artalkItem.destroy()
      artalkItem = null
    }
  }

  const artalkChangeMode = theme => artalkItem && artalkItem.setDarkMode(theme === 'dark')

  const initArtalk = (el = document, pageKey = location.pathname) => {
    artalkItem = Artalk.init({
      el: el.querySelector('#artalk-wrap'),
      server: 'https://artk.musnow.top',
      site: 'mublog',
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      ...option,
      pageKey: isShuoshuo ? pageKey : (option && option.pageKey) || pageKey
    })

    if (GLOBAL_CONFIG.lightbox === 'null') return
    artalkItem.on('list-loaded', () => {
      artalkItem.ctx.get('list').getCommentNodes().forEach(comment => {
        const $content = comment.getRender().$content
        btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
      })
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyArtalk = () => {
        destroyArtalk()
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    btf.addGlobalFn('pjaxSendOnce', destroyArtalk, 'destroyArtalk')
    btf.addGlobalFn('themeChange', artalkChangeMode, 'artalk')
  }

  const loadArtalk = async (el, pageKey) => {
    if (typeof Artalk === 'object') initArtalk(el, pageKey)
    else {
      await btf.getCSS('/pluginsSrc/artalk/dist/Artalk.css')
      await btf.getScript('/pluginsSrc/artalk/dist/Artalk.js')
      initArtalk(el, pageKey)
    }
  }

  if (isShuoshuo) {
    'Artalk' === 'Artalk'
      ? window.shuoshuoComment = { loadComment: loadArtalk }
      : window.loadOtherComment = loadArtalk
    return
  }

  if ('Artalk' === 'Artalk' || !false) {
    if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
    else setTimeout(loadArtalk, 100)
  } else {
    window.loadOtherComment = loadArtalk
  }
})()</script></div><script src="/js/domain_check.js"></script><script>document.addEventListener('DOMContentLoaded',()=>{if(window.location.pathname.includes('/posts')){const e=document.querySelector('.footnotes');e&&e.insertBefore(document.createElement('strong').appendChild(document.createTextNode('脚注：')).parentNode,e.firstChild);}});</script><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>