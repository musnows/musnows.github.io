<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Redis】04.变量类型（未完成） | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis的变量类型以及数据类型相关命令的介绍"><meta property="og:type" content="article"><meta property="og:title" content="【Redis】04.变量类型（未完成）"><meta property="og:url" content="https://blog.musnow.top/posts/2729830801/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="Redis的变量类型以及数据类型相关命令的介绍"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png"><meta property="article:published_time" content="2024-02-14T12:37:08.000Z"><meta property="article:modified_time" content="2024-02-19T04:35:49.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/2729830801/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Redis】04.变量类型（未完成）",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-02-19 12:35:49"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">335</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Redis】04.变量类型（未完成）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-14T12:37:08.000Z" title="发表于 2024-02-14 20:37:08">2024-02-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-19T04:35:49.000Z" title="更新于 2024-02-19 12:35:49">2024-02-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【Redis】04.变量类型（未完成）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文是对Redis的变量类型以及和特定数据类型相关命令的介绍。</p><h1 id="1-string"><a href="#1-string" class="headerlink" title="1.string"></a>1.string</h1><p><a target="_blank" rel="noopener" href="https://redis.io/docs/data-types/strings/">Redis Strings | Redis</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis中，所有key都是字符串类型，作为value的字符串有几个特性</p><ul><li>无编码转换（存的是什么取出来就是什么），所以你可以用string来存放二进制文件；</li><li>限制大小为512MB（避免过长的string操作耗时）；</li></ul><p>在MySQL中默认的字符集是拉丁文，此时插入中文内容会直接报错编码无法识别而失败，需要修改MySQL数据库的字符集。而在Redis中（不配置的情况下）插入中文，可以正常存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 你好</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br></pre></td></tr></table></figure><p>这里get查看的时候显示的是中文编码。此时Redis客户端没有配置字符集转码，所以没能显示中文，但实际上中文就是这么存放的（这就好比英文存放的是对应ASCII码一样）。</p><p>因为Redis服务端没有对编码进行转换，所以它遇到乱码问题（比如烫烫烫）的概率更小。但依旧不建议使用<code>非英文+数字</code>的组合来做Redis的key。</p><p>如果想让redis-cli的终端中<strong>正常显示中文</strong>，可以在启动的时候添加<code>--raw</code>选项。如下所示，添加了该选项后，正常显示出了value的中文值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">你好</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用该选项会导致Redis中显示的<code>(nil)</code>变成空字符串，极易产生误导！如果不是硬性需要在控制台中显示中文，请不要使用该选项！</p></blockquote><p>另外，在<a href="https://blog.musnow.top/posts/3677820204">Redis基础命令博客</a>中提到，Redis会对不同的string采取不同的存储方式，其中对于纯整数的string采用的是int来存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">int</span><br></pre></td></tr></table></figure><p>所以在Redis中如果存放一个<strong>整数数字</strong>（包括负数），虽然对应变量类型是string，但实际上就是一个int数字来存放的，Redis还提供了一系列原子性命令来对整数进行加减操作！</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>set&#x2F;get以及mset&#x2F;mget命令已经在<a href="https://blog.musnow.top/posts/3677820204">Redis基础命令博客</a>中讲解了，这里不再重复。</p><h3 id="setnx-x2F-msetnx"><a href="#setnx-x2F-msetnx" class="headerlink" title="setnx&#x2F;msetnx"></a>setnx&#x2F;msetnx</h3><p>setnx等价于set中添加nx选项，只有在key不存在的时候才能正常设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure><ul><li>当key值已经存在的时候，setnx不会执行任何操作，返回0；</li><li>当key值不存在的时候，setnx等价于set，返回1；</li></ul><p>如下所示，key1存在，设置失败返回0；key2不存在，设置成功返回1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx key1 value2</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setnx key2 value2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>还有一个命令是msetnx（和mset一样），可以原子性地同时setnx多个key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></table></figure><ul><li>只要给定的多个key中有一个key存在，msetnx就会失败且什么都不做，返回0；</li><li>只有给定的多个key全部都不存在，msetnx才会成功，返回1；</li></ul><p>如下所示，此时key1和key2已经存在，设置失败返回0；key3和key4都不存在， 设置成功返回1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; msetnx key1 value1 key2 value2 key3 value3</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; msetnx key3 value3 key4 value4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="setex-x2F-psetex"><a href="#setex-x2F-psetex" class="headerlink" title="setex&#x2F;psetex"></a>setex&#x2F;psetex</h3><p>setex&#x2F;psetex是在设置key的时候指定过期时间，只是时间单位不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key value second</span><br><span class="line">psetex key value milisecond</span><br></pre></td></tr></table></figure><p>虽然set命令本身已经提供了关于这些功能的选项，但直接使用<strong>特定命令</strong>来设置而不是用命令的参数会更加方便且符合人的直觉，使用门槛也更低！</p><blockquote><p>对于学习过Linux系统使用的开发人员而言，命令参数已经见怪不怪了。但对于初次学习Redis使用而没有接触过Linux系统的萌新而言，使用一个简单的命令来传递单个参数，会比在set后面添加一大堆选项更加简单且不容易犯错。</p></blockquote><h3 id="数字加减命令"><a href="#数字加减命令" class="headerlink" title="数字加减命令"></a>数字加减命令</h3><p>因为Redis中的整数是用int来存放的，所以它提供了一些命令来<strong>原子性</strong>的操作数字。这些命令中如果给定的key不存在，则会将其视作0，新建一个key再加上目标值。</p><table><thead><tr><th>命令</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>incr key</td><td>value + 1</td><td>value必须是整数</td></tr><tr><td>incrby key n</td><td>value + n</td><td>value必须是整数，给定的n可以是负数</td></tr><tr><td>decr key</td><td>value - 1</td><td>value必须是整数</td></tr><tr><td>decrby key n</td><td>value - n</td><td>value必须是整数，给定的n可以是负数</td></tr><tr><td>incrbyfloat key n</td><td>value +&#x2F;- 小数</td><td>给定的n可以是负数来实现减法</td></tr></tbody></table><p>注意：<code>decrbyfloat</code>命令是不存在的！</p><p>前四个命令的操作数value必须是一个整数，否则会失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; incr key1</span><br><span class="line">ERR value is not an integer or out of range</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; decr key1</span><br><span class="line">ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure><p>使用incrbyfloat命令操作一个整数后，它的存放方式就不再是int，而变成embstr了。此时我们依旧可以用incrbyfloat命令来继续添加小数（包括减去小数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">int</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 19.3</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">embstr</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 0.7</span><br><span class="line">120</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">embstr</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 -0.7</span><br><span class="line">119.3</span><br></pre></td></tr></table></figure><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>append命令用于在字符串之后追加字符串。如果给定key不存在，则和set命令等价。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><p>该命令的时间复杂度是<code>O(1)</code>，返回值是追加后的字符串长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; append k 45</span><br><span class="line">5</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>如果尝试给k追加一个中文，字符串长度会是多少呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; append k 你好</span><br><span class="line">11</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345你好</span><br></pre></td></tr></table></figure><p>可以看到，最终长度是11，因为Redis不会对字符串进行转码，中文在UTF8环境下是用三个字节存放的，所以两个中文就是6字节，加上原本的5个字节，最终长度就是11字节。</p><p>不使用<code>--raw</code>启动redis-cli，就能看到这两个中文的原始编码值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;12345\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br></pre></td></tr></table></figure><h3 id="getrange"><a href="#getrange" class="headerlink" title="getrange"></a>getrange</h3><p>这个命令用于获取字符串的子串，start&#x2F;end指定一个区间（采用下标方式且为闭区间）。该命令的时间复杂度是<code>O(N)</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end</span><br></pre></td></tr></table></figure><p>测试如下，2代表从第三个字符开始，4代表第五个字符结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 123456789</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 4</span><br><span class="line">&quot;345&quot;</span><br></pre></td></tr></table></figure><p>这里的start&#x2F;end还可以给负数。当end为负数时，代表直接取到末尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange key -1 4</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 -1</span><br><span class="line">&quot;3456789&quot;</span><br></pre></td></tr></table></figure><p>当start小于end时，返回空字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange key 2 0</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 1</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 2</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>注意，getrange的切分是严格按照字节切分的，如果是中文，则难以拆分出一个正常的中文字符（要按3个字节的间隙才能拆出一个正常的中文字符）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-cli</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;12345\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 -1</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 6</span><br><span class="line">&quot;\xe4\xbd&quot;</span><br><span class="line"></span><br><span class="line">❯ sudo redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345你好</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 6</span><br><span class="line">�</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 7</span><br><span class="line">你</span><br></pre></td></tr></table></figure><h3 id="setrange"><a href="#setrange" class="headerlink" title="setrange"></a>setrange</h3><p>从指定下标开始替换字符串，返回值是替换后字符串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setrange key offset value</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">123456789</span><br><span class="line">127.0.0.1:6379&gt; setrange key 3 hhhh</span><br><span class="line">9</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">123hhhh89</span><br></pre></td></tr></table></figure><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p>返回字符串的长度，单位是字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><h2 id="编码介绍"><a href="#编码介绍" class="headerlink" title="编码介绍"></a>编码介绍</h2><p>string有三种编码方式</p><ul><li>embstr：为短字符串优化；</li><li>int：为非负整数优化；</li><li>raw：原始字符串；</li></ul><p>注意，不管是什么编码方式，都不会影响对string的数字加减命令的使用（只要value是一个数字就行，即便小数的编码方式是embstr，也依旧可以使用数字加减命令）</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="用户信息缓存"><a href="#用户信息缓存" class="headerlink" title="用户信息缓存"></a>用户信息缓存</h3><p>绝大部分情况下，我们需要获取的信息都是字符串类型的。比如用户个人信息的JSON字符串。</p><p>此时可以在Redis中用<code>user:平台:用户ID</code>的方式做key，来保存用户基本个人信息的JSON字符串。如果使用Redis+MySQL的组合的话，整个用户信息的请求步骤如下：</p><ul><li>用户浏览器&#x2F;APP中点击个人信息页面，客户端发起请求，假设用户ID为100；</li><li>应用服务器收到请求，先去请求Redis服务器：<code>get user:平台:100</code>；</li><li>Redis中成功查询到用户信息，将Json字符串返回给用户；</li><li>没有在Redis中查询到，使用SQL请求MySQL服务器<code>select 用户个人信息字段 from user where user_id = &#39;100&#39;;</code></li><li>将MySQL返回的相关键值按预定格式制作成JSON字符串，返回给用户；</li><li>将该JSON字符串写入Redis服务器：<code>set user:平台:100 JSON字符串</code>；</li></ul><p>在set的时候还可以设定一定的过期时间，在保证缓存的实时性的基础上，避免Redis中的数据始终增长而导致内存爆满。（当然，内存快满的时候Redis有淘汰策略可供选择，那是后面要学习的内容了）。</p><h3 id="视频播放量计数"><a href="#视频播放量计数" class="headerlink" title="视频播放量计数"></a>视频播放量计数</h3><p>对于视频点赞、播放量这种经常变动的数据，可以使用Redis来做计数。比如使用<code>vedio:hit:视频ID</code>作为key，代表视频的播放量。</p><p>当用户点击一个视频的时候，发起请求给应用服务器，服务器在返回视频相关信息的同时，将播放量加一的信息，使用incr命令传递给Redis服务器。</p><p>但只用Redis肯定是不够的，还会有一个MySQL数据表来存放视频对应的点赞、播放、收藏等全量信息。此时我们可以令起一个服务，<strong>异步</strong>地同步视频播放量、点赞等相关信息到MySQL表中。</p><blockquote><p><strong>异步</strong>同步：并非来一个视频请求就同步到MySQL一次，而是以一定频率（时间间隔）将Redis中的数据同步到MySQL表中。这样能保证Redis中的数据能有备份。</p></blockquote><p>实际场景中，要想开发一个稳定的真实计数系统，还需要考虑防作弊、不同维度计数、避免单点问题以及数据持久化等等方面。这些都需要根据具体的业务逻辑来特殊处理。</p><h3 id="cookie-seesion"><a href="#cookie-seesion" class="headerlink" title="cookie+seesion"></a>cookie+seesion</h3><p>在HTTP网络服务中，cookie是最常用的用于标定客户端信息的方式。有些网站并非每次打卡都需要登录，而是登录了之后能维持一段时间不需要用户每次都重新登录。在这个过程中，就是通过浏览器端的cookie和服务器端的session来实现的。</p><ul><li>cookie：存放在用户的浏览器中，其值是通过HTTP的<code>Set-Cookie</code>响应头由服务器告知用户浏览器的；</li><li>session：存放在服务器端（实际上服务器端应该存放的是cookie-session的键值对），用于标定用户的基本信息；</li></ul><p>当用户登录后，服务器会生成一个<code>session_id</code>，将其和登录的用户信息绑定（键值对），并发送包含<code>Set-Cookie</code>头的HTTP报文给客户端，将<code>session_id</code>告知用户。浏览器在检测到这个响应头后，会将它对应的值保存在本地，下一次向这个网站发起HTTP请求的时候就会带上这个设置的cookie值里面的<code>session_id</code>。</p><p>服务器收到HTTP请求后，检查请求头中的<code>Cookie</code>字段，并与服务器中存放的<code>session_id</code>键值对进行对比，得到对应的用户，则返回用户相关信息，即当前用户已登录。</p><p>实现网页登录在一定时间后过期的功能，只需要在Redis中给这个键值对设置一个<strong>过期时间</strong>就行了。</p><p>使用cookie+session的方式也更加方便多个应用服务器之间的消息共享。因为<strong>负载均衡</strong>的存在，用户的请求可能会被发送到不同的应用服务器。只要这些应用服务器<strong>使用相同的Redis</strong>，它们就都能检索到用户的cookie对应的session信息，也就知道了当前用户的个人信息，可以正常进行服务（其实就是信息在多个应用服务器之中进行共享）。整个过程中用户完全不会发现自己的请求并非是同一个服务器来处理的。</p><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>这个场景就很常见了，手机验证码&#x2F;邮箱验证码都是如此，在Redis中设置一个验证码的key，value是对应用户的id，<strong>并给这个key设置一定的过期时间</strong>，就能实现验证码的功能。</p><p>当用户输入验证码后，检查Redis中的key，当value中的id和用户的id相同，则代表验证成功。用户id不同或验证码的key不存在，则验证失败。</p><p>这个过程中可能还会涉及到间隔60s秒才能发送一次验证码（这种限制大概率是前端做的处理）后端自然也可以通过一些缓存的时间值来做检查，避免给同一个用户在较短时间内发送多个验证码（会影响性能）。</p><h1 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>哈希是比较常见的一种数据结构，Redis本身的key-value结构其实就是通过哈希来实现的。同时，Redis也提供了hash作为value的数据类型，为了和Redis本身的kv进行区分，hash类型内的键值对被称为<code>field-value</code>。</p><p>比如存放一个用户信息，原本我们可以采用如下方式，在key中用冒号作为分隔来保存个人信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user:1:name 李四</span><br><span class="line">user:1:age  20</span><br><span class="line">user:1:sex  男</span><br></pre></td></tr></table></figure><p>现在我们可以直接将value设置为hash类型，然后在其中再设置对应的field和value，看上去就更加明了。</p><table><thead><tr><th>key</th><th>field</th><th>value</th></tr></thead><tbody><tr><td>user:1</td><td>name</td><td>李四</td></tr><tr><td>user:1</td><td>ag</td><td>20</td></tr><tr><td>user:1</td><td>sex</td><td>男</td></tr></tbody></table><h2 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="HSET-x2F-HGET-x2F-HGETALL"><a href="#HSET-x2F-HGET-x2F-HGETALL" class="headerlink" title="HSET&#x2F;HGET&#x2F;HGETALL"></a>HSET&#x2F;HGET&#x2F;HGETALL</h3><p><a target="_blank" rel="noopener" href="https://redis.io/commands/hget/">https://redis.io/commands/hget/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value [field value ...]</span><br><span class="line">HGET key field</span><br></pre></td></tr></table></figure><p>经过之前的命令学习，现在这里的命令就很好理解了。</p><ul><li>HSET用于设置hash类型内部的field，可以同时设置多个field；</li><li>HGET用于获取hash类型内部的field。</li></ul><p>HSET命令的返回值是设置成功的field的个数。当HGET命令指定的key或者field不存在时，会返回<code>nil</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET user:1 name 李四 age 20 sex 男</span><br><span class="line">3</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 name</span><br><span class="line">&quot;\xe6\x9d\x8e\xe5\x9b\x9b&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 age</span><br><span class="line">20</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 info</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; HGET user:2 test</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>与此相关的还有HSETNX和HGETALL两个命令</p><ul><li>HSETNX：当hash中的field不存在时才会设置成功（返回值为1），如果field已经存在则不会做任何操作（返回值为0）；</li><li>HGETALL：返回hash中的所有field-value值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;\xe6\x9d\x8e\xe5\x9b\x9b&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;sex&quot;</span><br><span class="line">6) &quot;\xe7\x94\xb7&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:2</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><h3 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h3><p>该命令用于查询hash中的某个field是否存在。存在返回1，key或者field不存在返回0；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 info</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS user:2 info</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h3><p>删除hash中指定的field，可以一次性给定多个field来删除。返回值是本次成功删除的field个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></table></figure><p>示例，info字段是不存在的，实际上只成功删除了name字段，所以返回值为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HDEL user:1 name info</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果你需要删除整个hash，直接使用Redis的del命令将key给删除就行了。比如<code>del user:1</code>;</p><h3 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h3><p>获取哈希中的所有field（仅获取字段）；该命令的时间复杂度是<code>O(N)</code>，N是hash中的field个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><p>这个命令和HGETALL命令有所不同，HGETALL命令会获取field和value，但HKEYS只会获取field。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;sex&quot;</span><br><span class="line">4) &quot;\xe7\x94\xb7&quot;</span><br><span class="line">127.0.0.1:6379&gt; HKEYS user:1</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;sex&quot;</span><br></pre></td></tr></table></figure><p>当然，这个命令和HGETALL命令都需要<strong>谨慎使用</strong>，它们就和<code>keys *</code>一样，需要遍历整个hash对象，而我们在执行命令之前并不知道一个hash里面到底有多少个field。如果查询的hash中field过多，那就会阻塞Redis。</p><h3 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h3><p>获取hash中的所有value，和HKEYS的功能对应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HVALS user:1</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;\xe7\x94\xb7&quot;</span><br></pre></td></tr></table></figure><h3 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h3><p>一次性获取hash中的多个field（一条命令查询优于多条命令查询）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMGET user:1 age sex</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;\xe7\x94\xb7&quot;</span><br></pre></td></tr></table></figure><h3 id="HSCAN（仅作介绍）"><a href="#HSCAN（仅作介绍）" class="headerlink" title="HSCAN（仅作介绍）"></a>HSCAN（仅作介绍）</h3><p>和HGETALL&#x2F;HKEYS&#x2F;HVALS这些一次性遍历完毕所有hash内元素的命令不同，HSCAN命令是“渐进式遍历”（就好比过程化SQL和编程中常用的for循环）。</p><p>所谓渐进式遍历，就是敲一次命令遍历一次，这样遍历的过程和速度都是可控的，不会阻塞Redis。当你需要获取一个hash中的所有field&#x2F;value，使用HSCAN会更加安全。</p><p>官网文档：<a target="_blank" rel="noopener" href="https://redis.io/commands/hscan/">https://redis.io/commands/hscan/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h3 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h3><p>获取一个hash中键值对的个数，该命令时间复杂度是<code>O(1)</code>，因为Redis有使用额外变量来存放hash中元素的个数，无需遍历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure><p>使用该命令遍历一个不存在的key时，返回值为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HLEN user:1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HLEN user:2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="HINCRBY-x2F-HINCRYBYFLOAT"><a href="#HINCRBY-x2F-HINCRYBYFLOAT" class="headerlink" title="HINCRBY&#x2F;HINCRYBYFLOAT"></a>HINCRBY&#x2F;HINCRYBYFLOAT</h3><p>这些命令和string中的数字操作命令一致，因为hash中的value也是字符串，也能当作数字来处理。参数可以是负数来左减法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field num</span><br><span class="line">HINCRBYFLOAT key field float</span><br></pre></td></tr></table></figure><p>测试如下，两个命令的返回值都是操作之后的变量值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrby user:1 age 10</span><br><span class="line">(integer) 30</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user:1 age 10.13</span><br><span class="line">&quot;40.13&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user:1 age -11.13</span><br><span class="line">&quot;29&quot;</span><br></pre></td></tr></table></figure><h3 id="HSTRLEN"><a href="#HSTRLEN" class="headerlink" title="HSTRLEN"></a>HSTRLEN</h3><p>计算hash中value的字符串长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSTRLEN key field</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 age</span><br><span class="line">&quot;29&quot;</span><br><span class="line">127.0.0.1:6379&gt; hstrlen user:1 age</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h2 id="编码介绍-1"><a href="#编码介绍-1" class="headerlink" title="编码介绍"></a>编码介绍</h2><p>之前在Redis基础命令博客的<code>object encoding</code>中提到，hash有两种编码方式，一个是ziplist，一个是hashtable。</p><p>其中ziplist是在hash中元素较少的情况下使用的，如下所示，刚开始hash中的f1只有3个字节的字符串长度，使用的是ziplist来存放；当我买尝试设置一个非常长的字符串f2，就会切换成hashtable来存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset key f1 111</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset key f2 235xczbjlkq3e5jl123j5ljlbsjlk32j6l5k1hasldg82357989789787124nlahbkasdlj3215897avsalkjl32k51432097zvlmq32j5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><p>如果你了解hashtable的数据结构，以拉链法为例，它会有一个数组，内部存放链表指针。存放数据时，通过哈希函数计算出key所在下标位置，将value链接到数组下标位置的对应指针上，即为存放完毕。当hash表中的元素较少时，数组可能会空出几个下标的位置没有value链接，这几个下标的空间就算是浪费了。</p><p>而使用ziplist就可以节省这部分空间的浪费，对应的代价是ziplist的读写速度会慢于原生hashtable。</p><p>在Redis中可以通过下面两个配置项来设置hash什么时候使用ziplist，写入<code>/etc/redis/redis.conf</code>即可。</p><table><thead><tr><th>配置</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>hash-max-ziplist-entries</td><td>设置field个数为多少以下时使用ziplist</td><td>默认512个</td></tr><tr><td>hash-max-ziplist-value</td><td>设置hash中value字符串的最大长度</td><td>默认为64字节</td></tr></tbody></table><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="关系数据库缓存"><a href="#关系数据库缓存" class="headerlink" title="关系数据库缓存"></a>关系数据库缓存</h3><p>正如介绍阶段时提到的，hash非常适合用于存放一些结构化的数据。以用户数据为例，可以用uid作为key的标识，内部存放对应的个人信息。有的时候为了方便，还会在hash中再存放一次uid。</p><table><thead><tr><th>key</th><th>field</th><th>value</th></tr></thead><tbody><tr><td>user:1</td><td>uid</td><td>1</td></tr><tr><td></td><td>name</td><td>李四</td></tr><tr><td></td><td>ag</td><td>20</td></tr><tr><td></td><td>sex</td><td>男</td></tr><tr><td>user:2</td><td>uid</td><td>2</td></tr><tr><td></td><td>name</td><td>王五</td></tr><tr><td></td><td>age</td><td>23</td></tr><tr><td></td><td>sex</td><td>男</td></tr></tbody></table><p>这样其实就好比一个MySQL数据库中的表</p><table><thead><tr><th>uid</th><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>1</td><td>李四</td><td>20</td><td>男</td></tr><tr><td>2</td><td>王五</td><td>23</td><td>男</td></tr></tbody></table><p>用这种方式，我们可以将MySQL中的表直接缓存在Redis中，提供更加快速的查询。需要修改数据的时候，也可以采用先修改Redis中的数据，再异步同步到MySQL中的方式来提高效率。</p><p>当然，使用string+json的方式也可以存放结构化数据，但在使用的时候就涉及到了<strong>json的序列化和反序列化</strong>，效率会低于直接使用Redis里面的hash来存放，不过使用hash会有更大的空间消耗。</p><p>这里还涉及到了高内聚&#x2F;低内聚的概念：</p><ul><li>高内聚：把有关联的数据存放在一起；</li><li>低内聚：有关联的东西散开存放了；</li></ul><p>使用hash来存放用户数据，就属于高内聚。如果使用<code>user:1:name</code>、<code>user:1:age</code>的key&#x2F;value来存放用户数据，就是低内聚，因为用户信息被拆开存放在了不同的key中。</p><p>同理，上文string中提到的视频播放量信息统计，也可以使用hash来存放一个视频的点击量&#x2F;点赞量，将一个视频的数据存放在一个hash中，而不用string来存放。</p><p>我们在设计的时候都强调<strong>高内聚、低耦合</strong>，就是为了整个系统能有更好的整洁度，维护更加方便。</p><h3 id="hash和关系数据库的区别"><a href="#hash和关系数据库的区别" class="headerlink" title="hash和关系数据库的区别"></a>hash和关系数据库的区别</h3><ul><li>哈希类型是稀疏的，关系数据库是结构化的。比如不同的hash里面的field完全没有关系，可以随意设置，但MySQL中一个表想插入一个数据，就必须依照表的要求设置所有数据；</li><li>关系数据库可以进行复杂的关系查询（比如多表查询），而Redis很难模拟关系查询，维护的复杂度很高且没有必要。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/d37409c171aed0f980fdea3322e6a54d.png" alt="image-20240219143844313"></p><h1 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>Redis中的list列表类型提供了头插头删&#x2F;尾插尾删的命令，我们可以将它当作顺序表、栈、队列来使用。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/e9f8229179473cd0d3ed2afb034c539d.png" alt="image-20240219144352348"></p><p>列表中的元素是按序存放的，所以我们可以通过下标来访问列表中的元素或获取一个范围中的元素。列表中的元素<strong>允许重复</strong>。</p><h2 id="相关命令-2"><a href="#相关命令-2" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h3><p>根据下标查看list中的数据，当下标超出范围时返回<code>nil</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure><p>index支持负数下标，从后往前数。比如<code>-1</code>代表从后往前第一个数据（即list末尾数据）。</p><p>注意，该命令的时间复杂度是<code>O(N)</code>，因为Redis中的list并非时刻采用顺序表来实现（会有不同编码方式），不能保证顺序表下标访问那样的快速！</p><h3 id="LPUSH-x2F-RPUSH"><a href="#LPUSH-x2F-RPUSH" class="headerlink" title="LPUSH&#x2F;RPUSH"></a>LPUSH&#x2F;RPUSH</h3><p>头插命令，支持一次插入多个数据。如果指定的key不是list类型则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]</span><br></pre></td></tr></table></figure><p>注意，当一次插入多个数据时，最后一个数据会在list的头部（按命令中出现的顺序，从左往右插入）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; lpush key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lindex key 0</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure><p>尾插也是相同的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key element [element ...]</span><br></pre></td></tr></table></figure><p>一次性插入多个数据的时候，也是最后一个数据在list的末尾。可以用lindex命令指定<code>-1</code>下标来获取末尾的数据（从后往前数第一个值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 5 6 7 8</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lindex key -1</span><br><span class="line">&quot;8&quot;</span><br></pre></td></tr></table></figure><h3 id="LPOP-x2F-RPOP"><a href="#LPOP-x2F-RPOP" class="headerlink" title="LPOP&#x2F;RPOP"></a>LPOP&#x2F;RPOP</h3><p>从list的头部或者尾部去除数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]</span><br><span class="line">RPOP key [count]</span><br></pre></td></tr></table></figure><p>注意，高版本Redis才有可选的count选项，当前我使用的Redis仅可一次pop一个元素，返回值是被删除的元素。</p><blockquote><p>Starting with Redis version 6.2.0: Added the <code>count</code> argument.</p></blockquote><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop key</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure><p>如果是高版本，指定count参数后，会返回一个被删除元素的array，效果参考下面这个官网给出的examples。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot;</span><br><span class="line">(integer) 5</span><br><span class="line">redis&gt; LPOP mylist</span><br><span class="line">&quot;one&quot;</span><br><span class="line">redis&gt; LPOP mylist 2</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;three&quot;</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;four&quot;</span><br><span class="line">2) &quot;five&quot;</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure><p>如果尝试操作一个空的list或者不存在的key，返回值是<code>nil</code>；如下所示，key1的list中只有1个元素，第一次成功删除元素，但是第二次操作的时候key1是一个空list，操作失败返回<code>nil</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key1 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpop key1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop key1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>当一个list中不存在元素的时候，Redis会自动将该list的key删除！如下所示，当我们把test键值中的元素全部删除时，这个test键值就直接不存在了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; lpush key 1 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush test 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">2) &quot;test&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop test</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h3><p>查看list中指定范围的元素，这里的区间是闭区间（最终结果包含start和stop下标的数据），当start小于stop时返回<code>empty array</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure><p>示例如下，指定了<code>0</code>和<code>-1</code>等同于获取list中的全部元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br></pre></td></tr></table></figure><p>注意，此处Redis是用array返回的一个结果集，序号是从1开始的（和list中的下标不一样且无关）</p><h4 id="超出下标范围"><a href="#超出下标范围" class="headerlink" title="超出下标范围"></a>超出下标范围</h4><p>另外，使用lrange命令指定下标的时候，如果下标超出范围，也会得到尽可能符合下标结果的数据，这点和lindex不同！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key 3 10</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">4) &quot;7&quot;</span><br><span class="line">5) &quot;8&quot;</span><br></pre></td></tr></table></figure><p>如上所示，我尝试访问3到10的数据，但实际上list中的数据下标到7就结束了（一共八个元素），但Redis并没有报错或返回<code>empty array</code>，而是获取了从下标3开始一直到list末尾的数据。</p><p>同理，当你访问超出范围的负数下标，也能得到类似的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key -10 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br></pre></td></tr></table></figure><p>当然，实际业务时正确使用合法肯定是更好的！</p><h3 id="LPUSHX-x2F-RPUSHX"><a href="#LPUSHX-x2F-RPUSHX" class="headerlink" title="LPUSHX&#x2F;RPUSHX"></a>LPUSHX&#x2F;RPUSHX</h3><p>和LPUSH&#x2F;RPUSH作用相同，多了一个对key是否存在的检测，只有key存在时才能插入成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX key element [element ...]</span><br><span class="line">RPUSHX key element [element ...]</span><br></pre></td></tr></table></figure><p>返回值是插入成功的元素个数，如果key不存在则返回0；</p><h3 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a>LINSERT</h3><p>这个命令的作用是在指定pivot元素位置插入一个元素，可以通过参数选择是在指定pivot元素之前插入，还是在指定pivot元素之后插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key &lt;BEFORE | AFTER&gt; pivot element</span><br></pre></td></tr></table></figure><p>该命令时间复杂度是<code>O(N)</code>，N是pivot元素和list开头的距离，返回值如下：</p><ul><li>成功时返回插入元素后list的元素个数；</li><li>key不存在时返回0；</li><li>pivot元素不存在时返回-1，且什么都不会发生；</li></ul><p>测试如下，这里选择的已有元素是4，before会在4之前插入一个元素，after会在4之后插入一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; linsert key before 4 10</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;2&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert key after 4 11</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;11&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>清空key后重新测试，如果list中有多个相同的pivot元素，会在哪里操作呢？可以看到它会在第一个5的位置操作，即pivot会采用第一个找到的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key 1 2 5 3 4 5 6</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; linsert key before 5 10</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;5&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h3><p>获取list的长度，如果key不存在返回0；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><h3 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a>LREM</h3><p>删除list中指定的值，返回值是被删除元素的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count element</span><br></pre></td></tr></table></figure><p>count参数的可选项如下</p><ul><li>count大于0：从前往后删除count个等于element的元素；</li><li>count小于0：从后往前删除<code>|count|</code>个等于element的元素；</li><li>count等于0：删除所有等于element的元素；</li></ul><p>测试一下，使用rpush可以让list和我们输入的顺序一致。这里指定的count大于0，删除的元素是1，最终删除了从前往后数的两个1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 1 2 3 4 1 2 3 4 1 2 3 4</span><br><span class="line">(integer) 12</span><br><span class="line">127.0.0.1:6379&gt; lrem key 2 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line"> 1) &quot;2&quot;</span><br><span class="line"> 2) &quot;3&quot;</span><br><span class="line"> 3) &quot;4&quot;</span><br><span class="line"> 4) &quot;2&quot;</span><br><span class="line"> 5) &quot;3&quot;</span><br><span class="line"> 6) &quot;4&quot;</span><br><span class="line"> 7) &quot;1&quot;</span><br><span class="line"> 8) &quot;2&quot;</span><br><span class="line"> 9) &quot;3&quot;</span><br><span class="line">10) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>再指定count为-1，删除元素是3，会删除从后往前数的第一个3；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem key -1 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;4&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;4&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">8) &quot;2&quot;</span><br><span class="line">9) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>指定count为0，删除元素是4，list中的所有4都会被删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem key 0 4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;1&quot;</span><br><span class="line">6) &quot;2&quot;</span><br></pre></td></tr></table></figure><h3 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h3><p>删除list中指定区间<strong>外</strong>的元素（即保留指定的闭区间，其他都删除）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key start stop</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; ltrim key 2 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h3><p>该命令可以设置某个下标的元素（替换）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSET key index element</span><br></pre></td></tr></table></figure><p>该命令的时间复杂度是<code>O(N)</code>，这就和LINDEX的原因一样，因为Redis不总是用顺序表来存放list的数据，所以无法保证<code>O(1)</code>下标访问一样的时间复杂度。</p><h3 id="BLPOP-x2F-BRPOP（阻塞版本）"><a href="#BLPOP-x2F-BRPOP（阻塞版本）" class="headerlink" title="BLPOP&#x2F;BRPOP（阻塞版本）"></a>BLPOP&#x2F;BRPOP（阻塞版本）</h3><h4 id="阻塞命令说明"><a href="#阻塞命令说明" class="headerlink" title="阻塞命令说明"></a>阻塞命令说明</h4><p>BLPOP和BRPOP是LPOP&#x2F;RPOP的阻塞版本，命令里面的B就是block阻塞的缩写。这也是我们第一次接触Redis里面的“阻塞命令”。</p><p>使用这两个命令的时候，list就可以当作一个阻塞队列（和Linux的管道也有点相似）了：</p><ul><li>如果队列为空，尝试出队列时会阻塞;</li><li>如果队列已满，尝试入队列时会阻塞;</li></ul><p>对于Redis而言，list一般不存在“满”的情况，我们大多考虑队列为空的情况。而Redis的单线程模型也保证了这个“阻塞队列”是线程安全的。</p><p>另外，Redis提供的阻塞命令<strong>并不会把自己给阻塞</strong>，而类似于阻塞了客户端，使用BLPOP&#x2F;BRPOP的时候需要给定一个timeout参数，在阻塞等待的期间，<strong>Redis可以正常响应其他的命令和请求</strong>。</p><p>而被阻塞的客户端实际上是在等待其他客户端往对应list中插入新元素。</p><h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p><a target="_blank" rel="noopener" href="https://redis.io/commands/blpop/">https://redis.io/commands/blpop/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure><p>注意：timeout单位为秒，Redis 6中可以设置为小数，设置为0时代表永久阻塞。</p><p>这两个命令都可以指定多个key，当指定多个key的时候，Redis会进行从左往右的遍历，只要其中一个key对应的list有元素，就会立刻返回。相当于一次等多个list。</p><blockquote><p>如果有多个客户端都需要使用这两个命令来等待<strong>同一个key</strong>，那么先执行命令的客户端会得到弹出的元素。</p></blockquote><p>因为blpop&#x2F;brlpop都支持多个key值等待，为了标定弹出的键属于哪一个key，这两个命令在返回的时候会返回array类型的key+value；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; blpop key 0</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>当超时时间结束时，给定的几个key的list还是为空，则会返回nil；</p><h4 id="命令预期行为"><a href="#命令预期行为" class="headerlink" title="命令预期行为"></a>命令预期行为</h4><p>当list不为空时，lpop和blpop的命令行为完全一致。</p><p>当list为空，且blpop指定的timeout时间中没有新元素插入list时：</p><ul><li>lpop会立马得到nil；</li><li>blpop会在等待timeout时间后得到nil；</li><li>此时lpop和brlpop的命令行为就不一致了。</li></ul><p>当list为空，且timeout时间内有新元素插入</p><ul><li>因为原本list是为空的，所以lpop还是会立马得到nil；</li><li>blpop会在新元素插入后返回key和新元素；</li></ul><h4 id="阻塞测试"><a href="#阻塞测试" class="headerlink" title="阻塞测试"></a>阻塞测试</h4><p>下面是一个阻塞时的测试，使用0来指定永久阻塞，当右侧终端回车提交插入操作时，左侧的阻塞会立马返回数据。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/2a28441785171abc8b20a27af768dfd9.png" alt="image-20240221211633743"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/a466d5f993d3a24be07a7dd93037a8c1.png" alt="image-20240221211639797"></p><p>尝试等待多个key，只要有一个key返回了数据，阻塞的终端就会立马返回。虽然说这个等待时遍历的顺序是从左往右的，但由于Redis是单线程模型，不会出现两个key同时新增数据的情况，<strong>总会有个先后顺序</strong>，所以最终还是等待列表中，<strong>哪一个key先有数据插入</strong>，哪一个key就会被blpop返回。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/8156e009dcd7a8ac02ade9b5df20bbed.png" alt="image-20240221212327656"></p><p>如果开始遍历的时候，key没有数据，key1和key2有数据，那么Redis就会按从左往右的原则，返回key1的数据。</p><h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><p>旧版本Redis中list的编码方式有两个</p><ul><li>ziplist：为短list优化</li><li>linklist：正常的双向链表</li></ul><p>但在新版本（Redis 3.2以后）对list的数据结构进行了改造，使用quicklist替代了ziplist&#x2F;linklist，更多信息可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/12624691.html">redis数据结构-快速列表</a>；</p><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p>使用list来模拟栈或者队列的功能</p><ul><li>队列：只使用rpush和lpop命令</li><li>栈：只使用lpush和lpop命令</li></ul><h3 id="班级中有那些学生-x2F-部门中有那些员工"><a href="#班级中有那些学生-x2F-部门中有那些员工" class="headerlink" title="班级中有那些学生&#x2F;部门中有那些员工"></a>班级中有那些学生&#x2F;部门中有那些员工</h3><p>可以使用list将一个班级id作为key，学生id作为list里面的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class:1  [1,3,4]</span><br><span class="line">class:2  [2,5,6]</span><br></pre></td></tr></table></figure><p>这样我们就可以通过list来得知每个班级对应的学生id编号。部门和员工的关系也是一样的；</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>使用BLPOP&#x2F;BRPOP这两个命令就可以让list作为一个简单的消息队列来使用。</p><p>以“生产-消费者模型”为例，生产者往list中插入数据，消费者使用BLPOP等待新数据的插入并进行消费。此时可以有多个生产者进行push，也可以有多个消费者同时使用BLPOP命令等待list中的新数据插入。</p><p>因为Redis不存在多线程竞争的问题，所以新数据插入后只会有一个消费者能拿到数据进行消费。并且多个消费者执行BLPOP命令时也存在一个先后顺序，按123的顺序来说的话，这一次消费者1拿到了数据，下一次就是消费者2，再下一次就是消费者3，不会出现某个消费者<strong>饥饿</strong>的情况。</p><h3 id="视频信息传递"><a href="#视频信息传递" class="headerlink" title="视频信息传递"></a>视频信息传递</h3><p>以一个视频网站为例，使用list作为消息队列时，可以采用一个视频对应多个key的方式来处理</p><ul><li>视频数据</li><li>视频评论</li><li>视频新弹幕</li><li>…</li></ul><p>对应的消费者可以通过BLPOP命令一次性等待多个key，这样不管是新的评论来了，还是新的弹幕来了，都能在第一时间被处理。</p><h3 id="用户的timeline"><a href="#用户的timeline" class="headerlink" title="用户的timeline"></a>用户的timeline</h3><p>因为list里面的元素是有序的，先插入的始终是在list的头部。我们就可以通过list来实现一个时间轴的功能。</p><p>当用户新建一个微博的时候，就将这个微博的id插入用户相关的list，这样用户和他上传的微博就有了一个时间的关系，还可以用lrange命令很方便的获取到用户的前n个微博，或某个区间的微博。</p><p>下面是一个分页获取用户微博的伪代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先获取用户前10个微博</span></span><br><span class="line">key_list = <span class="string">&quot;LRANGE user:1:blog 0 9&quot;</span></span><br><span class="line"><span class="comment"># 遍历每个key获取到微博的详细信息</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> key_list: </span><br><span class="line">	blog_info = <span class="string">&quot;HGETALL key&quot;</span></span><br></pre></td></tr></table></figure><p>这里就会出现一个问题，假设将单个分页需要显示的数据设置为100，那么每次循环中就会多次调用hash类型的HGETALL命令，导致Redis可能被阻塞。</p><blockquote><p>这个问题可以使用pipeline来解决，相当于将多个Redis命令合并成一个网络请求来执行，可以减少网络传输多次导致的延迟。后续将学习相关内容。</p></blockquote><p>另外一个问题是，lrange针对list两头的查询效率还不错（因为可以直接从头或从尾部开始遍历）但对中间的分页获取的效率就有点低了。这个问题可以通过list来解决（有点类似分库分表）。</p><h1 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h1><p>set是一个集合，集合中的每个元素都是string类型。它和list的区别主要在于：</p><ul><li>set的元素不可以重复；</li><li>set的元素是无序的；</li></ul><p>所谓无需，是相对于list的有序而言的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3] 和 [1,3,2] 是两个不同的list</span><br><span class="line">[1,2,3] 和 [1,3,2] 和 [2,3,1] 都是相同的set</span><br></pre></td></tr></table></figure><h2 id="相关命令-3"><a href="#相关命令-3" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h3><p>SADD命令用于给set中添加元素，为了和list中的元素作区分，set中的元素被称为member。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><p>返回值表示本次操作添加成功了几个元素，重复的元素只会被添加一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4 5 4</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><h3 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h3><p>查看set的所有成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers key</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h3><p>查看某个元素是否在集合中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p>返回值为1代表存在，返回值为0代表不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember key 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember key 120</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h3><p>该命令可以弹出set中的元素。但因为set是无序的，所以我们只能指定删除元素的个数，Redis会<strong>随机删除（弹出）</strong>set中的元素，这一点在官方文档中有说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure><p>返回值是被删除的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; spop key 2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure><p>这个命令也能体现出set中元素无序的概念。我们按1234构架两个set，尝试进行spop，能发现每次删除的元素的顺序是不一样的，完全随机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h3><p>这个命令和SPOP功能类似，返回set中的一个或多个随机数据，但不会删除该数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></table></figure><h3 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h3><p>将某个元素从set1移动到set2，或者说是从source中删除，在destination中新增。</p><p>如果destination中已经存在该元素，则只会删除source中的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member</span><br></pre></td></tr></table></figure><p>测试如下，该命令成功时返回1，不成功返回0（source中不存在该元素时失败）；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 5 6</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smove key1 key2 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers key2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">127.0.0.1:6379&gt; smove key1 key2 33</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h3><p>删除set中的指定元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><h3 id="SINTER-x2F-SINTERSTORE"><a href="#SINTER-x2F-SINTERSTORE" class="headerlink" title="SINTER&#x2F;SINTERSTORE"></a>SINTER&#x2F;SINTERSTORE</h3><p>求两个集合的交集，即获取同时出现在两个set中的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure><p>这个命令的时间复杂度是<code>O(M*N)</code>，其中M是最小的集合元素个数，N是最大的集合元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sinter key1 key2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>另外一个命令是SINTERSTORE，它多了一个存储功能，求了交集后，存储到destination中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p>这个命令的返回值是最终交集的元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sinterstore key3 key1 key2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3 id="SUNION-x2F-SUNIONSTORE"><a href="#SUNION-x2F-SUNIONSTORE" class="headerlink" title="SUNION&#x2F;SUNIONSTORE"></a>SUNION&#x2F;SUNIONSTORE</h3><p>求两个集合的并集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUNION key [key ...]</span><br><span class="line">SUNIONSTROE destination key [key ...]</span><br></pre></td></tr></table></figure><p>功能和上面的命令类似，这里就不做演示了</p><h3 id="SDIFF-x2F-SDIFFSTORE"><a href="#SDIFF-x2F-SDIFFSTORE" class="headerlink" title="SDIFF&#x2F;SDIFFSTORE"></a>SDIFF&#x2F;SDIFFSTORE</h3><p>求集合的差集，即存在于第一个key，但是不在第二个key中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br><span class="line">SDIFFSTROE destination key [key ...]</span><br></pre></td></tr></table></figure><p>实测如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff key2 key1</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure><p>如果key的数量不止两个，你可以理解为Redis会进行依次计算。即先计算key1和key2的差集，再将结果和key3进行计算。如下所示，key1和key2的差集包含1和2，但是key3中有1，所以最终的差集结果就只有2了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key3 1 3 7 8</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2 key3</span><br><span class="line">1) &quot;2&quot;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/2729830801/">https://blog.musnow.top/posts/2729830801/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4231483511/" title="【项目】高并发内存池项目的学习"><img class="cover" src="/img/bg/gm14.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【项目】高并发内存池项目的学习</div></div></a></div><div class="next-post pull-right"><a href="/posts/3677820204/" title="【Redis】03.基本命令学习"><img class="cover" src="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Redis】03.基本命令学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/269089114/" title="【Redis】02.Ubuntu22.04安装Redis"><img class="cover" src="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-10</div><div class="title">【Redis】02.Ubuntu22.04安装Redis</div></div></a></div><div><a href="/posts/3677820204/" title="【Redis】03.基本命令学习"><img class="cover" src="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-10</div><div class="title">【Redis】03.基本命令学习</div></div></a></div><div><a href="/posts/996575798/" title="【Redis】01.初步认识Redis和分布式系统"><img class="cover" src="https://img.musnow.top/i/2024/02/903cf874bef24f120d4a6f89d6f08868.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-08</div><div class="title">【Redis】01.初步认识Redis和分布式系统</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">335</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-string"><span class="toc-text">1.string</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setnx-x2F-msetnx"><span class="toc-text">setnx&#x2F;msetnx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setex-x2F-psetex"><span class="toc-text">setex&#x2F;psetex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%8A%A0%E5%87%8F%E5%91%BD%E4%BB%A4"><span class="toc-text">数字加减命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#append"><span class="toc-text">append</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getrange"><span class="toc-text">getrange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setrange"><span class="toc-text">setrange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strlen"><span class="toc-text">strlen</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">编码介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%BC%93%E5%AD%98"><span class="toc-text">用户信息缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E9%87%8F%E8%AE%A1%E6%95%B0"><span class="toc-text">视频播放量计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie-seesion"><span class="toc-text">cookie+seesion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-text">验证码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Hash"><span class="toc-text">2.Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-1"><span class="toc-text">相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HSET-x2F-HGET-x2F-HGETALL"><span class="toc-text">HSET&#x2F;HGET&#x2F;HGETALL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEXISTS"><span class="toc-text">HEXISTS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HDEL"><span class="toc-text">HDEL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HKEYS"><span class="toc-text">HKEYS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HVALS"><span class="toc-text">HVALS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HMGET"><span class="toc-text">HMGET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HSCAN%EF%BC%88%E4%BB%85%E4%BD%9C%E4%BB%8B%E7%BB%8D%EF%BC%89"><span class="toc-text">HSCAN（仅作介绍）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HLEN"><span class="toc-text">HLEN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HINCRBY-x2F-HINCRYBYFLOAT"><span class="toc-text">HINCRBY&#x2F;HINCRYBYFLOAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HSTRLEN"><span class="toc-text">HSTRLEN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">编码介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98"><span class="toc-text">关系数据库缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E5%92%8C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">hash和关系数据库的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-List"><span class="toc-text">3.List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-2"><span class="toc-text">相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LINDEX"><span class="toc-text">LINDEX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LPUSH-x2F-RPUSH"><span class="toc-text">LPUSH&#x2F;RPUSH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LPOP-x2F-RPOP"><span class="toc-text">LPOP&#x2F;RPOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRANGE"><span class="toc-text">LRANGE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E5%87%BA%E4%B8%8B%E6%A0%87%E8%8C%83%E5%9B%B4"><span class="toc-text">超出下标范围</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LPUSHX-x2F-RPUSHX"><span class="toc-text">LPUSHX&#x2F;RPUSHX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LINSERT"><span class="toc-text">LINSERT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LLEN"><span class="toc-text">LLEN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LREM"><span class="toc-text">LREM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LTRIM"><span class="toc-text">LTRIM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LSET"><span class="toc-text">LSET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BLPOP-x2F-BRPOP%EF%BC%88%E9%98%BB%E5%A1%9E%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-text">BLPOP&#x2F;BRPOP（阻塞版本）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="toc-text">阻塞命令说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0"><span class="toc-text">命令参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E9%A2%84%E6%9C%9F%E8%A1%8C%E4%B8%BA"><span class="toc-text">命令预期行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E6%B5%8B%E8%AF%95"><span class="toc-text">阻塞测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-text">编码方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text">栈和队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8F%AD%E7%BA%A7%E4%B8%AD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%AD%A6%E7%94%9F-x2F-%E9%83%A8%E9%97%A8%E4%B8%AD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%91%98%E5%B7%A5"><span class="toc-text">班级中有那些学生&#x2F;部门中有那些员工</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">视频信息传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%9A%84timeline"><span class="toc-text">用户的timeline</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Set"><span class="toc-text">4.Set</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-3"><span class="toc-text">相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SADD"><span class="toc-text">SADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMEMBERS"><span class="toc-text">SMEMBERS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SISMEMBER"><span class="toc-text">SISMEMBER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPOP"><span class="toc-text">SPOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SRANDMEMBER"><span class="toc-text">SRANDMEMBER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMOVE"><span class="toc-text">SMOVE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SREM"><span class="toc-text">SREM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SINTER-x2F-SINTERSTORE"><span class="toc-text">SINTER&#x2F;SINTERSTORE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SUNION-x2F-SUNIONSTORE"><span class="toc-text">SUNION&#x2F;SUNIONSTORE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDIFF-x2F-SDIFFSTORE"><span class="toc-text">SDIFF&#x2F;SDIFFSTORE</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1835761968/" title="【算法】KMP算法"><img src="/img/bg/gm2.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【算法】KMP算法"></a><div class="content"><a class="title" href="/posts/1835761968/" title="【算法】KMP算法">【算法】KMP算法</a><time datetime="2024-02-29T08:31:48.000Z" title="发表于 2024-02-29 16:31:48">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3573352712/" title="【Linux】Linux64位环境下编译32位报错的解决办法"><img src="/img/bg/gm5.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Linux】Linux64位环境下编译32位报错的解决办法"></a><div class="content"><a class="title" href="/posts/3573352712/" title="【Linux】Linux64位环境下编译32位报错的解决办法">【Linux】Linux64位环境下编译32位报错的解决办法</a><time datetime="2024-02-24T03:04:53.000Z" title="发表于 2024-02-24 11:04:53">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4231483511/" title="【项目】高并发内存池项目的学习"><img src="/img/bg/gm14.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【项目】高并发内存池项目的学习"></a><div class="content"><a class="title" href="/posts/4231483511/" title="【项目】高并发内存池项目的学习">【项目】高并发内存池项目的学习</a><time datetime="2024-02-20T13:32:14.000Z" title="发表于 2024-02-20 21:32:14">2024-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2729830801/" title="【Redis】04.变量类型（未完成）"><img src="https://img.musnow.top/i/2024/02/9284dcf218849c1b82f2627c5255b358.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Redis】04.变量类型（未完成）"></a><div class="content"><a class="title" href="/posts/2729830801/" title="【Redis】04.变量类型（未完成）">【Redis】04.变量类型（未完成）</a><time datetime="2024-02-14T12:37:08.000Z" title="发表于 2024-02-14 20:37:08">2024-02-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>