<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Linux】进程通信 | 共享内存 | 信号量 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="上篇Linux的博客是有关管道的，今日就让我们继续康康进程间通信的另外一种方法：共享内存"><meta property="og:type" content="article"><meta property="og:title" content="【Linux】进程通信 | 共享内存 | 信号量"><meta property="og:url" content="https://blog.musnow.top/posts/3323274806/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="上篇Linux的博客是有关管道的，今日就让我们继续康康进程间通信的另外一种方法：共享内存"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm9.jpg"><meta property="article:published_time" content="2022-11-13T02:40:16.000Z"><meta property="article:modified_time" content="2024-02-23T11:37:01.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Linux"><meta property="article:tag" content="进程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm9.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/3323274806/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Linux】进程通信 | 共享内存 | 信号量",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-02-23 19:37:01"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm9.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Linux】进程通信 | 共享内存 | 信号量</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-13T02:40:16.000Z" title="发表于 2022-11-13 10:40:16">2022-11-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-23T11:37:01.000Z" title="更新于 2024-02-23 19:37:01">2024-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【Linux】进程通信 | 共享内存 | 信号量"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>上篇Linux的博客是有关管道的，今日就让我们继续康康进程间通信的另外一种方法：<code>共享内存</code></p><span id="more"></span><p>完整代码详见我的gitee仓库 👇</p><blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/musnow/raspberry-practice/tree/master/code/22-11-12_systemV">https://gitee.com/musnow/raspberry-practice/tree/master/code/22-11-12_systemV</a></p></blockquote><p>[TOC]</p><h1 id="1-啥是共享内存？"><a href="#1-啥是共享内存？" class="headerlink" title="1.啥是共享内存？"></a>1.啥是共享内存？</h1><p>进程间通信的基本方式，就是让两个进程看到同一份资源。</p><p>共享内存(shm)实现进程间通信的方式，通过系统接口开辟一段内存，再让多个进程去访问这块内存，就能同时看到一份资源。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211120900047.png" alt="image-20221112090042941"></p><p>这里贴出之前动态库博客中的图，共享内存的方式和该图展示的方式类似。进程需要调用系统接口，将已经开辟好的共享内存映射到自己的页表中，以实现访问。</p><p>这里就出现了一个问题：</p><ul><li>操作系统的接口怎么知道进程要的是那一块共享内存？即共享内存是怎么标识的？</li></ul><p>要知道，之前我们打开文件、开辟管道等等，都是具有唯一的文件路径来标识文件的。如果按以前的想法：<code>打开文件-&gt;系统返回文件的文件描述符</code>，共享内存则应该是<code>开辟共享内存-&gt;系统返回共享内存的编号</code></p><ul><li>这就出现了问题！</li></ul><p>假设进程A开辟了一段共享内存，系统返回了编号123，那么进程A要怎么让其他想使用这块共享内存进行通信的进程，<span id="jump">知道它开辟的共享内存编号</span>是123呢？总不能开个管道告诉它吧？那岂不是多此一举😂</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031201142.gif" alt="QQ图片20220502222002"></p><p>所以，共享内存的<strong>编号</strong>其实和命名管道一样，<strong>是由用户手动在代码中指定的</strong>。只要进程使用这个编号去获取共享内存，他们就能获取到同一份！</p><hr><h1 id="2-相关接口"><a href="#2-相关接口" class="headerlink" title="2.相关接口"></a>2.相关接口</h1><p>说完了基本概念，现在让我们来康康它的使用</p><h2 id="2-1-ftok"><a href="#2-1-ftok" class="headerlink" title="2.1 ftok"></a>2.1 ftok</h2><p><code>ftok - convert a pathname and a project identifier to a System V IPC key</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure><p>前面提到了，共享内存的key是我们自己指定的。Linux系统给定了<code>ftok</code>接口，将用户提供的<code>pathname</code>工作路径，以及<code>proj_id</code>项目编号转换为一个共享内存的key（其实就是int类型）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211121323400.png" alt="image-20221112132307366"></p><p>只要我们的<strong>工作路径和项目编号</strong>传的是一样的，那么它返回的key就是一样的！</p><p>这个函数也能用于信号量的key的创建！</p><h2 id="2-2-shmget"><a href="#2-2-shmget" class="headerlink" title="2.2 shmget"></a>2.2 shmget</h2><p><code>shmget - allocates a System V shared memory segment</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><p>参数分别为key值，共享内存的大小，以及创建共享内存的方式。</p><p>key值需要通过<code>ftok</code>函数获取；</p><p>其中共享内存的大小最好设置为4kb的整数倍，因为操作系统IO的基本单位是4KB。如果你申请了不是4的整数倍的字节，比如15个字节，其还是会申请16个字节(4个页)交给你，而其中有1kb的内存你是无法使用的，即造成了内存浪费😥</p><p>创建共享内存的<code>shmflg</code>:</p><ul><li><code>IPC_CREAT</code>：创建共享内存。如果存在则获取，如果不存在则创建后获取</li><li><code>IPC_EXCL</code>：必须配合<code>IPC_CREAT</code>使用，如果不存在指定的共享内存，就进行创建；如果该共享内存存在，则<strong>出错返回</strong>（即保证获取到的共享内存一定是当前进程创建的，是一个新的共享内存）</li></ul><p>返回值是一个共享内存的<strong>标识符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On success, a valid shared memory identifier is returned.  On errir, -1 is returned, and errno is set to indicate the error.</span><br></pre></td></tr></table></figure><p>这些工作都是操作系统做的。其内核中有专门的管理单元来判断一个共享内存是否存在，以及何时被创建、被使用、被什么进程绑定等等…</p><p>命令行键入<code>man shmctl</code>，可以看到下面的内核结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">key_t</span>          __key;    <span class="comment">/* Key supplied to shmget(2) */</span></span><br><span class="line">    <span class="type">uid_t</span>          uid;      <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>          gid;      <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">    <span class="type">uid_t</span>          cuid;     <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">    <span class="type">gid_t</span>          cgid;     <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">/* Permissions + SHM_DEST and</span></span><br><span class="line"><span class="comment">                                           SHM_LOCKED flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共享内存要被管理，其内核结构中一定有一个唯一的key值来标识该共享内存，即和文件的<code>inode</code>一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span>     __key; <span class="comment">//共享内存的唯一标识符，由用户在shmget中提供</span></span><br></pre></td></tr></table></figure><p>关于key为何要让用户提供，已经在上面做出过解释👉 <a href="#jump">回顾一下</a></p><hr><h2 id="2-3-shmat-x2F-shmdt"><a href="#2-3-shmat-x2F-shmdt" class="headerlink" title="2.3 shmat&#x2F;shmdt"></a>2.3 shmat&#x2F;shmdt</h2><p>at其实是attach绑定的缩写，这个接口的作用是将一个共享内存和我们当前的进程绑定。</p><p>其实就是将这个共享内存映射到进程的页表中（堆栈之间）</p><p><code>shmat, shmdt - System V shared memory operations</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure><p>一共有两个函数，分别为at和dt，用于绑定&#x2F;解绑共享内存</p><p><code>shmat</code>的三个参数如下</p><ul><li>shmid：为<code>shmget</code>的返回值</li><li>shmaddr：指定共享内存连接到当前进程中的地址位置。通常为空，表示让系统来选择共享内存的地址。</li><li>shmflg：如果指定了<code>SHM_RDONLY</code>位，则以只读方式连接此段；否则以读写的方式连接此段；通常设置为0</li></ul><p>调用成功的时候，返回指向共享内存第一个字节的指针；出错返回-1</p><ul><li><code>shmdt</code>的参数为<code>shmat</code>正确调用时的返回值</li></ul><p>以下是man手册中对这两个函数返回值的描述👇</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On success shmat() returns the address of the attached shared memory segment; on error (void *) -1 is returned, and errno is set  to</span><br><span class="line">       indicate the cause of the error.</span><br><span class="line"></span><br><span class="line">       On success shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.</span><br></pre></td></tr></table></figure><h2 id="2-4-shmctl"><a href="#2-4-shmctl" class="headerlink" title="2.4 shmctl"></a>2.4 shmctl</h2><p>这个函数可以用于操作我们的共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure><p>其中cmd的参数有下面几种</p><ul><li><p><code>IPC_RMID</code> 删除该共享内存</p></li><li><p><code>IPC_STAT</code> 把<code>shmid_ds</code>结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖<code>shmid_ds</code>的值</p></li><li><p><code>IPC_SET</code> 如果进程有足够的权限，就把共享内存的当前关联值设置为<code>shmid_ds</code>结构中给出的值</p></li></ul><p>最后一个buf参数是一个指向<code>shmid_ds</code>结构的指针，一般设为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The buf argument is a pointer to a shmid_ds structure</span><br></pre></td></tr></table></figure><p><code>shmid_ds</code>的基本结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uid_t</span> shm_perm.uid;</span><br><span class="line">    <span class="type">uid_t</span> shm_perm.gid;</span><br><span class="line">    <span class="type">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以删除为例，其操作如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);<span class="comment">//删除shmid的共享内存</span></span><br></pre></td></tr></table></figure><h2 id="2-5-ipcs命令"><a href="#2-5-ipcs命令" class="headerlink" title="2.5 ipcs命令"></a>2.5 ipcs命令</h2><p>先来康康几个<code>ipcs</code>命令的选项，这些命令可以帮助我们查看共享资源。其中我们要用到的是<code>-m</code>查看共享内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipcs -c <span class="comment">#查看消息队列/共享内存/信号量</span></span><br><span class="line">ipcs -s <span class="comment">#单独查看信号量</span></span><br><span class="line">ipcs -q <span class="comment">#单独查看消息队列</span></span><br><span class="line">ipcs -m <span class="comment">#单独查看共享内存</span></span><br></pre></td></tr></table></figure><p>执行了之后，会列出当前操作系统中开辟的共享内存，以及它们的基本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m </span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 1          muxue      0          1024       0    </span><br></pre></td></tr></table></figure><p>这里的key和我们使用<code>ftok</code>获取到的key值是一样的，只不过我们打印的时候是十进制，操作系统列出来的为十六进制。</p><h3 id="ipcrm-删除进程通信资源"><a href="#ipcrm-删除进程通信资源" class="headerlink" title="ipcrm 删除进程通信资源"></a>ipcrm 删除进程通信资源</h3><p>这个命令可以用与删除ipc资源，包括共享内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -m shmid <span class="comment">#删除共享内存</span></span><br></pre></td></tr></table></figure><p>我们可以使用<code>ipcrm -m 共享内存的shmid</code>来删除共享内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 1          muxue      0          1024       0                       </span><br><span class="line"></span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcrm -m 1</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br></pre></td></tr></table></figure><p>可以看到我们自己创建的共享内存已经被删除了。</p><hr><p>但是，当我们尝试用该命令删除一个<strong>正在被使用</strong>的共享内存时，它并不会被立即删除（立即删除会影响进程运行）</p><p>此时执行删除，在共享内存的<code>status</code>列会出现<code>dest</code>；观察结果，当<strong>进程结束</strong>的时候，这个共享内存会被直接删除（进程内部并没有调用<code>shmctl</code>接口）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 21         muxue      666        1024       2                       </span><br><span class="line"></span><br><span class="line">[muxue@bt-7274:~/git]$ ipcrm -m 21</span><br><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x00000000 21         muxue      666        1024       2          dest         </span><br><span class="line"></span><br><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                 </span><br></pre></td></tr></table></figure><p>相比之下，如果不执行<code>ipcrm</code>命令+进程内部不调用<code>shmctl</code>接口，这个共享内存就会一直存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 22         muxue      666        1024       0                       </span><br></pre></td></tr></table></figure><p>结论：使用<code>ipcrm -m</code>命令删除共享内存之后，其共享内存不一定会立即释放。如果有进程关联了该共享内存，则会在进程<strong>去关联之后释放</strong>；</p><h2 id="2-6-共享内存和管道的对比"><a href="#2-6-共享内存和管道的对比" class="headerlink" title="2.6 共享内存和管道的对比"></a>2.6 共享内存和管道的对比</h2><p>面试的时候问道了这个问题！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/09/17766a5a0226a48b578aed58d9ed5c1d.png" alt="image-20230913212808024"></p><h2 id="2-7-消息队列mq-x2F-信号量的接口"><a href="#2-7-消息队列mq-x2F-信号量的接口" class="headerlink" title="2.7 消息队列mq&#x2F;信号量的接口"></a>2.7 消息队列mq&#x2F;信号量的接口</h2><p>消息队列和信号量的接口和共享内存很相似</p><p>消息队列用的不多，信号量的难度很高！😂 后文会介绍信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息队列相关接口</span></span><br><span class="line">msgget <span class="comment">//获取</span></span><br><span class="line">msgctl <span class="comment">//操作</span></span><br><span class="line">msgsnd <span class="comment">//发送信息</span></span><br><span class="line">msgrcv </span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量</span></span><br><span class="line">semget</span><br><span class="line">semctl</span><br><span class="line">semop</span><br></pre></td></tr></table></figure><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h1><h2 id="3-1-创建并获取"><a href="#3-1-创建并获取" class="headerlink" title="3.1 创建并获取"></a>3.1 创建并获取</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件实在太多，为了博客篇幅，这里省略了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJ_ID 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH_NAME <span class="string">&quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">CreateKey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PATH_NAME, PROJ_ID);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt;<span class="string">&quot;ftok: &quot;</span>&lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//key获取错误直接退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = CreateKey();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id = shmget(key, NUM, IPC_CREAT | IPC_EXCL);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="File-exists"><a href="#File-exists" class="headerlink" title="File exists"></a>File exists</h3><p>这里会发现，第一次运行代码的时候，程序成功获取了共享内存；但是第二次运行的时候，却报错说<code>File exists(文件存在)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./test</span><br><span class="line">shmget: 1</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./test</span><br><span class="line">shmget err: File exists</span><br></pre></td></tr></table></figure><p>这是因为共享内存的声明周期是随内核的。即只要这个共享内存不被删除，他就会一直存在，直到内核因为某种原因释放掉它，亦或者操作系统关机</p><p>通过上面提到的<code>ipcrm -m shmid</code> 命令删除共享内存，才能重新运行代码获取新的共享内存</p><blockquote><p>为了避免这个问题，应该在进程结束后使用<code>shmctl</code>接口删除共享内存</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ./test</span><br><span class="line">shmget success: 2</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-12_systemV]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 2          muxue      0          1024       0                       </span><br></pre></td></tr></table></figure><h3 id="设置权限值"><a href="#设置权限值" class="headerlink" title="设置权限值"></a>设置权限值</h3><p>默认情况下，我们创建的共享内存的<code>perms</code>是0，代表没有用户能访问这个共享内存。所以在创建的时候，我们需要在flag里面直接或上这个共享内存的权限值</p><p>代码如下👇</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = CreateKey();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id = shmget(key, NUM, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    shmctl(id,IPC_RMID,nullptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候创建的共享内存就有正确的权限值了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 4          muxue      666        1024       0    </span><br></pre></td></tr></table></figure><h2 id="3-2-挂接-x2F-取消挂接"><a href="#3-2-挂接-x2F-取消挂接" class="headerlink" title="3.2 挂接&#x2F;取消挂接"></a>3.2 挂接&#x2F;取消挂接</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关联共享内存</span></span><br><span class="line"><span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>因为shmat函数的返回值是一个<code>void*</code>指针，我们可以以使用<code>malloc</code>一样的方式使来挂接共享内存。随后对这个内存的操作就是正常的指针操作了！</p><p>同样的，另外一个进程也需要用同样的方式挂接共享内存，才能读取到相同的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      1                       </span><br><span class="line">0x20011ac8 4          muxue      666        1024       1   </span><br></pre></td></tr></table></figure><p>挂接成功后，可以发现<code>nattch</code>的值从0变为1</p><h3 id="取消-x2F-删除"><a href="#取消-x2F-删除" class="headerlink" title="取消&#x2F;删除"></a>取消&#x2F;删除</h3><p>取消挂接的方式很简单，直接把<code>shmat</code>的返回值传入即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmdt(str);<span class="comment">//取消挂接</span></span><br></pre></td></tr></table></figure><p>如果是服务端，则还需要在取消挂接之后，删除共享内存。避免下次程序运行的时候，无法通过key获取到新的共享内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shmctl</span>(id,IPC_RMID,<span class="literal">nullptr</span>);<span class="comment">//删除共享内存</span></span><br></pre></td></tr></table></figure><h2 id="3-3-写入内容"><a href="#3-3-写入内容" class="headerlink" title="3.3 写入内容"></a>3.3 写入内容</h2><p>因为共享内存本质就是一个内存，其和malloc出来的内存都是一样的，直接使用即可</p><p>这里还是用一个服务端和一个客户端来进行演示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mykey.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key值</span></span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">CreateKey</span>();</span><br><span class="line">    <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">shmget</span>(key, NUM, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//关联共享内存</span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] shmat success\n&quot;</span>);</span><br><span class="line">    <span class="comment">//读取数据，sleep(1)</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">40</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%03d] %s\n&quot;</span>,i,str);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(str);<span class="comment">//shmat的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] shmdt(str)\n&quot;</span>);</span><br><span class="line">    <span class="comment">//删除共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(id,IPC_RMID,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mykey.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key值</span></span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">CreateKey</span>();</span><br><span class="line">    <span class="comment">//获取共享内存</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">shmget</span>(key, NUM, IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//关联共享内存</span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] shmat success\n&quot;</span>);</span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> base = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        str[i] = base+i;</span><br><span class="line">        str[i+<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write times: %02d\n&quot;</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//去关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(str);<span class="comment">//shmat的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] shmdt &amp; exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑起来之后，客户端向共享内存中写入数据（注意控制<code>\0</code>）服务端进行读取。这便实现了我们进程之间的通信</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211130917762.png" alt="image-20221113091741600"></p><p>不过我们发现，客户端已经停止写入之后，服务端还是在不停的读取。如果我们不控制<code>while</code>循环的话，其会一直这么读取下去</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211130918667.png" alt="image-20221113091847579"></p><p>这便牵扯出共享内存的一个特性了</p><h3 id="共享内存没有访问控制"><a href="#共享内存没有访问控制" class="headerlink" title="共享内存没有访问控制"></a>共享内存没有访问控制</h3><p>在管道的博客中提到，管道是有访问控制的进程通信方式，写端没有写入数据的时候，读端会在<code>read</code>中进行等待。</p><p>而共享内存因为我们是直接像操作一个malloc出来的空间一样访问，<strong>没有使用任何系统接口</strong>（相比之下管道需要使用<code>read/write</code>）所以操作系统没有办法帮我们进行访问控制！</p><p>也正是因为没有阻塞等待就能直接访问这块内存空间，共享内存是进程中通信中<strong>最快</strong>的一种方式。</p><h3 id="通过管道进行共享内存的控制"><a href="#通过管道进行共享内存的控制" class="headerlink" title="通过管道进行共享内存的控制"></a>通过管道进行共享内存的控制</h3><p>既然共享内存没有访问控制，那么我们可以利用管道来让控制共享内存的读写</p><ul><li>写端写完后，将<strong>完成信号</strong>写入管道，由读端读取</li><li>读端从管道中获取到信号后，访问共享内存读出内容</li><li>如果写端没有写好，读端就会在管道read内部等待</li></ul><p>你可能会说，那为何不直接用管道通信呢？</p><ul><li>管道仅作访问控制，只需要一个int乃至一个char类型即可；</li><li>相比直接管道通信，共享内存的方式更好控制（毕竟使用内存的方式和使用指针一样，我们比较熟悉，管道还需要文件操作；）</li><li>读取很长一串数据的时候，<strong>共享内存的速度优势能体现出来</strong>；</li></ul><p>以下是完整代码👇</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mykey.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJ_ID 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH_NAME <span class="string">&quot;/home/muxue/git/linux/code/22-11-12_systemV&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;sc.pipe&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">CreateKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(PATH_NAME, PROJ_ID);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt;<span class="string">&quot;ftok: &quot;</span>&lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//key获取错误直接退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateFifo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mkfifo</span>(FIFO_FILE, <span class="number">0666</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;fifo: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开管道文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Open</span><span class="params">(<span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(FIFO_FILE, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让读端通过管道等待</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果写端没有写入，其就会在read中等待</span></span><br><span class="line">    <span class="type">ssize_t</span> s = <span class="built_in">read</span>(fd, &amp;val, <span class="built_in">sizeof</span>(val));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送完成信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Signal</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> sig = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, &amp;sig, <span class="built_in">sizeof</span>(sig));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//server.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mykey.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建管道</span></span><br><span class="line">    <span class="built_in">CreateFifo</span>();</span><br><span class="line">    <span class="comment">//获取key值</span></span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">CreateKey</span>();</span><br><span class="line">    <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">shmget</span>(key, NUM, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//获取管道</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">Open</span>(O_RDONLY);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;open fifo success: &quot;</span> &lt;&lt; fd &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//关联共享内存</span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] shmat success\n&quot;</span>);</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">40</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> ret = <span class="built_in">Wait</span>(fd);<span class="comment">//通过管道等待</span></span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%03d] %s\n&quot;</span>,i,str);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;[server] wait finish, break&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(str);<span class="comment">//shmat的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] shmdt(str)\n&quot;</span>);</span><br><span class="line">    <span class="comment">//删除共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(id,IPC_RMID,<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">unlink</span>(FIFO_FILE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[server] exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mykey.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key值</span></span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">CreateKey</span>();</span><br><span class="line">    <span class="comment">//获取共享内存</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">shmget</span>(key, NUM, IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;shmget err: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;shmget success: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取管道</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">Open</span>(O_WRONLY);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;open fifo success: &quot;</span> &lt;&lt; fd &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//关联共享内存</span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] shmat success\n&quot;</span>);</span><br><span class="line">    <span class="comment">//写入数据</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> base = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        str[i] = base+i;</span><br><span class="line">        str[i+<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write times: %02d\n&quot;</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">Signal</span>(fd);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//去关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(str);<span class="comment">//shmat的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] shmdt &amp; exit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[client] close fifo\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>管道控制了之后，当客户端退出的时候，管道也不会继续读取，而是在read内等待</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211131049472.png" alt="image-20221113104949379"></p><p>如果客户端最后关闭了管道的写段，服务器端就会直接退出。这样我们就实现了通过管道控制<strong>共享内存</strong>的读写👍</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211131117485.png" alt="image-20221113111731418"></p><hr><h1 id="4-相关概念"><a href="#4-相关概念" class="headerlink" title="4.相关概念"></a>4.相关概念</h1><h2 id="4-0-临界资源"><a href="#4-0-临界资源" class="headerlink" title="4.0 临界资源"></a>4.0 临界资源</h2><p>能被多个进程看到的资源，被称为<code>临界资源</code></p><p>如果不对临界资源进行访问控制，进程对该资源的访问就是<strong>乱序的</strong>（比如父子进程向显示器打印内容）可能会因为数据交叉导致乱码、数据不可用等情况；</p><p>以此可见，显示器、管道、共享内存都是临界资源。</p><ul><li><strong>管道</strong>是有访问控制的临界资源</li></ul><p>进程访问临界资源的代码，称为<code>临界区</code></p><ul><li>一个进程中，并不是所有的代码都在访问临界资源。如管道中，其实只有<code>read/write</code>接口在访问临界资源。</li></ul><p><strong>互斥</strong>：任何时刻，只允许一个进程访问临界资源。</p><p><strong>原子性</strong>：一件事情只有<code>做完/没做</code>两种状态，没有中间状态。</p><p>下面对信号量的概念进行讲解~ 只用基本理解即可；</p><h2 id="4-1-信号量"><a href="#4-1-信号量" class="headerlink" title="4.1 信号量"></a>4.1 信号量</h2><h3 id="4-1-1-概念"><a href="#4-1-1-概念" class="headerlink" title="4.1.1 概念"></a>4.1.1 概念</h3><p>信号量是对<code>临界资源</code>的控制方式之一，其本质是一个<strong>计数器</strong>；准确来说，是一个拥有<strong>原子性</strong>的计数器。</p><ul><li>信号量保证<strong>不会有多余</strong>的进程连接到这份临界资源</li><li>还需要保证每一个进程的能够访问到临界资源的不同位置（根据上层业务决定）</li></ul><p>信号量根据情况的不同分为两种：</p><ul><li>二元信号量（<strong>互斥</strong>状态，当进程使用的时候为1，没有进程使用的时候为0）</li><li>多元信号量（常规的计数器）</li></ul><p>如果一个进程想访问由信号量控制的临界资源，必须先申请信号量才能进行访问。但是只要我申请成功了，就一定能访问到这个临界资源中的一部分（或者全部）</p><h3 id="4-1-2-原子性的说明"><a href="#4-1-2-原子性的说明" class="headerlink" title="4.1.2 原子性的说明"></a>4.1.2 原子性的说明</h3><p>先来想想，我们对一个变量<code>+1/-1</code>需要做什么工作：</p><ul><li>将这个变量从内存中拿到CPU的寄存器中</li><li>在寄存器中完成加减操作</li><li>放回内存</li></ul><p>这其中是有很多个中间状态的，设该变量初始值为100</p><ul><li>假设一个进程A拿走了这个变量，放入CPU的寄存器</li><li>另外一个进程B也来拿走了这个变量</li><li>此时A和B拿到的都是100</li><li>A对该变量进行了循环<code>--</code>操作，最终该变量变成了50，将其放回内存</li><li>B对该变量<code>-1</code>，将其放回内存</li><li>最终导致A对变量的操作被B覆盖，出现了变量不统一的情况</li></ul><p>而我们的信号量为了保证能够正确的控制进程的访问，<strong>其就必须维护自身的原子性</strong>！不能有<strong>中间状态</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031203959.jpg" alt="QQ图片20220424132543"></p><p>说人话就是，如果进程A在访问信号量，进程B来了，信号量应该拒绝B的访问，直到A访问结束。不能让B中途插入访问，从而导致<strong>可能的数据不统一</strong>；</p><blockquote><p><strong>共享内存同样可以通过信号量进行访问控制</strong></p></blockquote><h3 id="4-1-3-接口"><a href="#4-1-3-接口" class="headerlink" title="4.1.3 接口"></a>4.1.3 接口</h3><h4 id="创建信号量-semget"><a href="#创建信号量-semget" class="headerlink" title="创建信号量 semget"></a>创建信号量 semget</h4><p>使用如下函数获取一个信号量，或者创建一个新的信号量；</p><p>调用这个函数之前，我们需要使用 <code>ftok</code> 函数创建一个 <code>key_t</code> 值作为信号量的标识符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>key</code> 是一个唯一标识符，用于标识信号量集。</li><li><code>nsems</code> 是信号量集中信号量的数量。</li><li><code>semflg</code> 是标志位，用于指定信号量的权限。</li></ul><p>一般情况下，我们将<code>semflg</code>写为 <code>IPC_CREAT | 权限值</code>，这里的权限值和linux中文件权限值是相同的，比如需要所有人都有一切权限，就可以写 <code>777</code>；一般写成 <code>666</code>就行了，这代表所有用户，所属组和其他用户都拥有读写权限。</p><p>指定了 <code>IPC_CREAT</code> 标志位，则表示如果该信号量不存在，则创建它；如果存在，则返回已存在的信号量的标识符。</p><h4 id="初始化信号量-semctl"><a href="#初始化信号量-semctl" class="headerlink" title="初始化信号量 semctl"></a>初始化信号量 semctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>semid</code> 是信号量集的标识符。</li><li><code>semnum</code> 是信号量在信号量集中的索引。</li><li><code>cmd</code> 是操作指令，可以是 <code>SETVAL</code>、<code>GETVAL</code> 等。</li><li>对于 <code>SETVAL</code> 操作指令，需要通过可变参数 <code>...</code> 来设置初始化的值。</li></ul><p>对于该函数的第三个参数<code>cmd</code>，有如下类型的选项</p><ol><li><code>IPC_STAT</code>：获取信号量的状态信息，包括信号量的当前值、最后一次修改时间等。</li><li><code>IPC_SET</code>：设置信号量的状态信息，比如设置信号量的权限、所有者等。</li><li><code>IPC_RMID</code>：删除信号量，释放占用的系统资源。</li><li><code>GETVAL</code>：获取信号量的当前值。</li><li><code>SETVAL</code>：设置信号量的当前值。</li></ol><p>除了上述常见的操作类型，还有其他一些操作类型用于更具体的操作，例如：</p><ul><li><code>GETPID</code>：获取最后一次操作信号量的进程 ID。</li><li><code>GETNCNT</code>：获取当前正在等待信号量解锁的进程数量。</li><li><code>GETZCNT</code>：获取当前等待信号量解锁的进程数量。</li></ul><p>根据我们的需要选择对应的操作符来进行信号量的操作即可；</p><p>如下是一个获取信号量当前值的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> semid;  <span class="comment">// 信号量集标识符</span></span><br><span class="line"><span class="comment">// 需要初始化</span></span><br><span class="line"><span class="type">int</span> sem_num = <span class="number">0</span>;  <span class="comment">// 信号量索引，如果信号量集里面只有一个信号量，就用0</span></span><br><span class="line"><span class="type">int</span> cmd = GETVAL;  <span class="comment">// 获取信号量的命令，GETVAL表示获取当前值</span></span><br><span class="line"><span class="comment">// 执行这个函数时，返回值就是信号量当前值</span></span><br><span class="line"><span class="comment">// 如果返回-1就代表获取失败了</span></span><br><span class="line"><span class="type">int</span> sem_value = <span class="built_in">semctl</span>(semid, sem_num, cmd);</span><br></pre></td></tr></table></figure><h4 id="修改信号量-semop"><a href="#修改信号量-semop" class="headerlink" title="修改信号量 semop"></a>修改信号量 semop</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nops)</span>;</span><br></pre></td></tr></table></figure><p>功能： 操作信号量，<code>P V</code> 操作</p><p>参数：</p><ul><li><code>semid</code>为信号量集的标识符；</li><li><code>sops</code> 指向进行操作的结构体数组的首地址；</li><li><code>nsops</code> 指出将要进行操作的信号的个数；</li></ul><p>返回值： 成功返回0，出错返回<code>-1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       If successful semop() and semtimedop() return 0; otherwise they return -1 with errno indicating the error.</span><br></pre></td></tr></table></figure><h4 id="结构体-sembuf"><a href="#结构体-sembuf" class="headerlink" title="结构体 sembuf"></a>结构体 sembuf</h4><p>这里我们会用到 <code>struct sembuf</code>这个结构体来操作信号量，在系统中这个结构体的声明如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sem_num;	<span class="comment">/* semaphore number */</span></span><br><span class="line">  <span class="type">short</span> <span class="type">int</span> sem_op;		<span class="comment">/* semaphore operation */</span></span><br><span class="line">  <span class="type">short</span> <span class="type">int</span> sem_flg;		<span class="comment">/* operation flag */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>sem_num</code>：表示要操作的信号量在信号量集中的索引，如果信号量集只有一个信号量，则为 0。</li><li><code>sem_op</code>：表示进行的操作类型，可以是正数、负数或零。正数表示增加（释放）信号量的值，负数表示减少（获取）信号量的值，零表示检查信号量的值。</li><li><code>sem_flg</code>：表示操作的标志位，用于指定额外的操作选项。一般用的是两个：<ul><li><code>SEM_UNDO</code> 表示异常时撤回对信号量的操作</li><li><code>IPC_NOWAIT</code> 表示如果信号量没有就绪，不进行阻塞等待，直接错误退出</li></ul></li></ul><p>比如如下操作，就是给信号量新增值的处理（如果<code>sem_op</code>为负数，那就是减去值）需要注意的是，信号量的值不能为负数。如果你想减去值，请保证信号量里面有足够的值给你减，否则进程会在<code>semop</code>中阻塞等待。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span> semaphore;</span><br><span class="line">semaphore.sem_num = <span class="number">0</span>;</span><br><span class="line">semaphore.sem_op = <span class="number">1</span>;  <span class="comment">// 新增信号量1</span></span><br><span class="line">semaphore.sem_flg = SEM_UNDO; </span><br><span class="line"><span class="comment">// SEM_UNDO 标记位代表异常的时候还原（撤销）操作</span></span><br></pre></td></tr></table></figure><p>如下操作是等待信号量变成0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span> semaphore;</span><br><span class="line"></span><br><span class="line">semaphore.sem_num = <span class="number">0</span>;    <span class="comment">// 操作的信号量索引</span></span><br><span class="line">semaphore.sem_op = <span class="number">0</span>;     <span class="comment">// 检查信号量的值</span></span><br><span class="line">semaphore.sem_flg = <span class="number">0</span>;    <span class="comment">// 操作标志位为0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">semop</span>(semid, &amp;semaphore, <span class="number">1</span>);  <span class="comment">// 等待信号量变成0</span></span><br><span class="line"><span class="comment">// 如果没有变成0，就会阻塞等待</span></span><br><span class="line"><span class="comment">// 如果sem_flg设置了IPC_NOWAIT，那就不会阻塞等待，而是直接返回EAGAIN</span></span><br></pre></td></tr></table></figure><p>在man手册里面是这么描述的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">If  sem_op is zero, the process must have read permission on the semaphore set.  This is a &quot;wait-for-zero&quot; operation: if semval is zero,</span><br><span class="line">the operation can immediately proceed.  Otherwise, if IPC_NOWAIT is specified in sem_flg, semop() fails with errno set  to  EAGAIN  (and</span><br><span class="line">none  of  the  operations  in sops is performed).  Otherwise, semzcnt (the count of threads waiting until this semaphore&#x27;s value becomes</span><br><span class="line">zero) is incremented by one and the thread sleeps until one of the following occurs:</span><br><span class="line"></span><br><span class="line">·  semval becomes 0, at which time the value of semzcnt is decremented.</span><br><span class="line">·  The semaphore set is removed: semop() fails, with errno set to EIDRM.</span><br><span class="line">·  The calling thread catches a signal: the value of semzcnt is decremented and semop() fails, with errno set to EINTR.</span><br></pre></td></tr></table></figure><p>翻译一下，如果 <code>sem_op</code>设置为了0，且没有设置 <code>IPC_NOWAIT</code>，那么进程就会在 <code>semop</code>函数中等待，直到出现下面的情况：</p><ul><li>信号量变成0，等待成功</li><li>信号量被销毁</li><li>执行流接收到信号退出（信号是下一章要学习的内容，和信号量没关系）</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>如下是单个进程操作信号量的示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> semid;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">semaphore</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建或获取信号量集</span></span><br><span class="line">    key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">    semid = semget(key, <span class="number">1</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (semid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to create semaphore\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量的值为1</span></span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to initialize semaphore value\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;12\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对信号量进行操作</span></span><br><span class="line">    semaphore.sem_num = <span class="number">0</span>;</span><br><span class="line">    semaphore.sem_op = <span class="number">34</span>;  <span class="comment">// 新增信号量值</span></span><br><span class="line">    semaphore.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;semaphore, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to perform semaphore operation\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;13\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取信号量的当前值</span></span><br><span class="line">    <span class="type">int</span> cmd = GETVAL;  <span class="comment">// 获取信号量的命令，GETVAL表示获取当前值</span></span><br><span class="line">    <span class="type">int</span> sem_value = semctl(semid, <span class="number">0</span>, cmd);</span><br><span class="line">    <span class="keyword">if</span>(sem_value == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to perform semaphore operation\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;current val for sem: %d\n&quot;</span>,sem_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;14\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放信号量</span></span><br><span class="line">    semaphore.sem_op = <span class="number">-34</span>;  <span class="comment">// 减少信号量值</span></span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;semaphore, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to release semaphore\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;15\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除信号量集</span></span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, <span class="number">0</span>, IPC_RMID) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to remove semaphore\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，这里的<code>printf</code>是我用来标识进程跑到那个阶段的，没有啥实际意义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">current val for sem: 35</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td></tr></table></figure><h2 id="4-2-扩展-mmap"><a href="#4-2-扩展-mmap" class="headerlink" title="4.2 扩展: mmap"></a>4.2 扩展: mmap</h2><blockquote><p>这部分仅供参考，可能有错误😥<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/224953636#:~:text=struct%20ipc_ids%20%7B%20int%20in_use%3B%2F%2F%E8%AF%B4%E6%98%8E%E5%B7%B2%E5%88%86%E9%85%8D%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%AA%E6%95%B0%20int%20max_id%3B%2F%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95%20unsigned,ipc_ids%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%20struct%20ipc_id_ary%20nullentry%3B%2F%2F%E5%A6%82%E6%9E%9CIPC%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%88%99entries%E5%AD%97%E6%AE%B5%E6%8C%87%E5%90%91%E4%BC%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20struct%20ipc_id_ary%2A%20entries%3B%2F%2F%E6%8C%87%E5%90%91%E8%B5%84%E6%BA%90ipc_id_ary%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88%20%7D%3B">部分资料参考</a></p></blockquote><p>前面贴出过<code>IPC</code>资源的内核结构，它们都有一个共同的特点：第一个成员都相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">    <span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">    <span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span>  <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">time_t</span>          sem_otime; <span class="comment">/* Last semop time */</span></span><br><span class="line">    <span class="type">time_t</span>          sem_ctime; <span class="comment">/* Last change time */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   sem_nsems; <span class="comment">/* No. of semaphores in set */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span>     <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="type">time_t</span>          msg_stime;    <span class="comment">/* Time of last msgsnd(2) */</span></span><br><span class="line">    <span class="type">time_t</span>          msg_rtime;    <span class="comment">/* Time of last msgrcv(2) */</span></span><br><span class="line">    <span class="type">time_t</span>          msg_ctime;    <span class="comment">/* Time of last change */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   __msg_cbytes; <span class="comment">/* Current number of bytes in</span></span><br><span class="line"><span class="comment">                                                queue (nonstandard) */</span></span><br><span class="line">    <span class="type">msgqnum_t</span>       msg_qnum;     <span class="comment">/* Current number of messages</span></span><br><span class="line"><span class="comment">                                                in queue */</span></span><br><span class="line">    <span class="type">msglen_t</span>        msg_qbytes;   <span class="comment">/* Maximum number of bytes</span></span><br><span class="line"><span class="comment">                                                allowed in queue */</span></span><br><span class="line">    <span class="type">pid_t</span>           msg_lspid;    <span class="comment">/* PID of last msgsnd(2) */</span></span><br><span class="line">    <span class="type">pid_t</span>           msg_lrpid;    <span class="comment">/* PID of last msgrcv(2) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它们的<strong>第一个成员</strong>都是一个<code>struct ipc_perm</code>，其中包含了一个信号量的基本信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">key_t</span>          __key;    <span class="comment">/* Key supplied to shmget(2) */</span></span><br><span class="line">    <span class="type">uid_t</span>          uid;      <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>          gid;      <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">    <span class="type">uid_t</span>          cuid;     <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">    <span class="type">gid_t</span>          cgid;     <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">/* Permissions + SHM_DEST and</span></span><br><span class="line"><span class="comment">                                           SHM_LOCKED flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而内核中对<code>IPC</code>资源的管理，是通过一个<strong>数组</strong>进行的。我们所获取的<code>shmid</code>，和文件描述符一样，<strong>都是一个数组的下标</strong></p><p>其中我在测试的时候，便发现了一点：我们每一次获取的新的共享内存，它的编号都会<code>+1</code>，而不像文件描述符一样，提供第一个没有被使用的下标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> in_use;<span class="comment">//说明已分配的资源个数</span></span><br><span class="line">    <span class="type">int</span> max_id;<span class="comment">//在使用的最大的位置索引</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> seq;<span class="comment">//下一个分配的位置序列号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> seq_max;<span class="comment">//最大位置使用序列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span> <span class="comment">//保护 ipc_ids的信号量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span> <span class="title">nullentry</span>;</span><span class="comment">//如果IPC资源无法初始化，则entries字段指向伪数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span>* <span class="title">entries</span>;</span><span class="comment">//指向资源ipc_id_ary数据结构的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内核中，<code>struct ipc_id_ary* entries</code>是一个指向所有<code>ipc_perm</code>的<strong>指针数组</strong>。其能够通过该数组找到我们对于id（下标）的资源，对其进行访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">p</span>[0];</span><span class="comment">//指针数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211131639022.png" alt="image-20221113163918931"></p><p>那你可能想问了，这里只是第一个元素啊？那如果我想访问<code>shmid_ds</code>结构的其他成员，岂不是没有办法访问了？</p><p>要是这么想，就还是太年轻了😂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(strcut shmid_ds*)</span><br></pre></td></tr></table></figure><p>我们只需要对这个指针进行强转，就能直接访问其他成员！</p><p>这是因为：<font color="orange">C语言中，结构体第一个元素的地址，和结构体整体的地址是一样的！</font></p><p>指针的类型会限制这个指针访问元素的能力，只要我们进行强转，其就能直接访问父结构体的其他成员！</p><blockquote><p>这是一种<strong>切片</strong>的思想</p></blockquote><p>用这种办法，可以用统一的规则在内核中管理不同的<code>IPC</code>资源，没有必要再为每一个IPC资源建立一个单独的数组来管理。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031202438.gif" alt="QQ图片20220419103136"></p><p>不得不说，<code>linus</code>大佬是真的牛逼！</p><hr><h2 id="4-3-多进程共享锁-mutex"><a href="#4-3-多进程共享锁-mutex" class="headerlink" title="4.3 多进程共享锁 mutex"></a>4.3 多进程共享锁 mutex</h2><p>共享内存因为缺少访问控制，常常需要借助其他具有访问控制的进程通信手段来间接实现访问控制。</p><p>但实际上有一个更加符合我们使用习惯的写法，那就是使用 <code>pthread_mutex</code> 锁的 <code>PTHREAD_PROCESS_SHARED</code> 多进程共享属性，让这把锁可以在<strong>多个进程</strong>中被使用。在每个进程中，我们都可以像使用自己的锁一样使用它，以此实现了一把能同时管多个进程的一把互斥锁！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 共享内存的名字必须以/开头</span></span><br><span class="line">    <span class="type">int</span> shared_mem_fd = <span class="built_in">shm_open</span>(<span class="string">&quot;/my_shared_memory&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 创建了一个mutex大小的共享内存(这个函数的作用是将fd文件给截断/扩展为第二个参数的大小)</span></span><br><span class="line">    <span class="built_in">ftruncate</span>(shared_mem_fd, <span class="built_in">sizeof</span>(<span class="type">pthread_mutex_t</span>));</span><br><span class="line">    <span class="comment">// 用mmap挂载到本地</span></span><br><span class="line">    <span class="comment">// addr：指定映射的虚拟地址，通常设置为NULL，让系统自动分配。</span></span><br><span class="line">    <span class="comment">// length：指定映射的长度，以字节为单位。</span></span><br><span class="line">    <span class="comment">// prot：指定映射区域的保护权限，可选值为PROT_READ（可读权限）、PROT_WRITE（可写权限）、PROT_EXEC（可执行权限）以及它们的组合。</span></span><br><span class="line">    <span class="comment">// flags：指定映射的类型和其他标志位，常见的标志位有MAP_SHARED（共享映射）、MAP_PRIVATE（私有映射）、MAP_ANONYMOUS（匿名映射）等。</span></span><br><span class="line">    <span class="comment">// fd：如果要映射文件，则为文件描述符；如果映射的是匿名内存区域，则传入-1。</span></span><br><span class="line">    <span class="comment">// offset：从文件开始处的偏移量，通常设置为0。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 返回值：成功时，返回映射区域的起始地址指针；</span></span><br><span class="line">    <span class="comment">//        失败时，返回MAP_FAILED，并设置errno来指示错误类型。</span></span><br><span class="line">    <span class="type">void</span> *shared_mem_ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_mutex_t</span>), PROT_READ | PROT_WRITE, MAP_SHARED, shared_mem_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line">    <span class="built_in">pthread_mutexattr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_mutexattr_setpshared</span>(&amp;attr, PTHREAD_PROCESS_SHARED); <span class="comment">// 设置锁的属性为共享锁</span></span><br><span class="line">    <span class="comment">// 如果删除上面这一行，那么当下这个锁就是父进程的私有锁，不具有公有属性</span></span><br><span class="line">    <span class="comment">// 即便我们使用共享内存将锁映射到了父子进程的页表中</span></span><br><span class="line">    <span class="comment">// 观察到的现象是，即便父进程已经释放锁了，但是子进程依旧是在阻塞状态中</span></span><br><span class="line">    <span class="comment">// 个人猜测：因为这个锁是父进程独有的，所以子进程在调用lock函数访问mutex的时候，实际上是将mutex进行了一次写时拷贝；</span></span><br><span class="line">    <span class="comment">//          拷贝的时候，这个锁是被占用的，拷贝过去之后也是一个被占用中的锁。</span></span><br><span class="line">    <span class="comment">//          但实际上压根没有进程在占用这个被子进程拷贝出去的独立的锁，父进程的解锁操作也不会在进程间同步，这就是一种死锁。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_mutex_t</span> *mutex = (<span class="type">pthread_mutex_t</span> *)shared_mem_ptr;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(mutex, &amp;attr); <span class="comment">// 指定使用共享内存的地址来初始化锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Fork failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Child process</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 子进程先休眠1秒，等待夫进程获取锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child trying to acquire the mutex... %p\n&quot;</span>, mutex);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(mutex); <span class="comment">// 子进程获取锁，这时候父进程在休眠，无法获取</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child acquired the mutex.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// Do some work...</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child released the mutex.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Parent process</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent trying to acquire the mutex... %p\n&quot;</span>, mutex);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent acquired the mutex.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// Do some work...</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(mutex); <span class="comment">// 父进程释放锁后，观察到的情况是子进程成功获取锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent released the mutex.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>); <span class="comment">// 等待子进程执行完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutexattr_destroy</span>(&amp;attr); <span class="comment">// 父进程来销毁相关资源</span></span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(mutex);</span><br><span class="line">        <span class="built_in">munmap</span>(shared_mem_ptr, <span class="built_in">sizeof</span>(<span class="type">pthread_mutex_t</span>));</span><br><span class="line">        <span class="built_in">shm_unlink</span>(<span class="string">&quot;/my_shared_memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于共享内存的操作到这里就OVER了！</p><p>最后还了解了一些内核设计上的小妙招，不得不说，真的牛批~</p><p><strong>如果本文有什么问题，欢迎在评论区提出</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031206219.png" alt="QQ图片20220527185356"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/3323274806/">https://blog.musnow.top/posts/3323274806/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm9.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2620423276/" title="【Linux】进程通信 | 信号"><img class="cover" src="/img/bg/gm23.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Linux】进程通信 | 信号</div></div></a></div><div class="next-post pull-right"><a href="/posts/3971907787/" title="【Linux】进程通信 | 管道"><img class="cover" src="/img/bg/gm20.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Linux】进程通信 | 管道</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/3785030062/" title="【Linux】进程概念"><img class="cover" src="/img/bg/gm5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-31</div><div class="title">【Linux】进程概念</div></div></a></div><div><a href="/posts/1845419185/" title="【Linux】进程地址空间"><img class="cover" src="/img/bg/gm3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-07</div><div class="title">【Linux】进程地址空间</div></div></a></div><div><a href="/posts/3785030063/" title="【Linux】进程概念"><img class="cover" src="/img/bg/gm11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-27</div><div class="title">【Linux】进程概念</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">352</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%95%A5%E6%98%AF%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-text">1.啥是共享内存？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.相关接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-ftok"><span class="toc-text">2.1 ftok</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-shmget"><span class="toc-text">2.2 shmget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-shmat-x2F-shmdt"><span class="toc-text">2.3 shmat&#x2F;shmdt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-shmctl"><span class="toc-text">2.4 shmctl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-ipcs%E5%91%BD%E4%BB%A4"><span class="toc-text">2.5 ipcs命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ipcrm-%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E8%B5%84%E6%BA%90"><span class="toc-text">ipcrm 删除进程通信资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C%E7%AE%A1%E9%81%93%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">2.6 共享内存和管道的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97mq-x2F-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.7 消息队列mq&#x2F;信号量的接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8"><span class="toc-text">3.使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%8E%B7%E5%8F%96"><span class="toc-text">3.1 创建并获取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#File-exists"><span class="toc-text">File exists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90%E5%80%BC"><span class="toc-text">设置权限值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%8C%82%E6%8E%A5-x2F-%E5%8F%96%E6%B6%88%E6%8C%82%E6%8E%A5"><span class="toc-text">3.2 挂接&#x2F;取消挂接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88-x2F-%E5%88%A0%E9%99%A4"><span class="toc-text">取消&#x2F;删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%86%99%E5%85%A5%E5%86%85%E5%AE%B9"><span class="toc-text">3.3 写入内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%B2%A1%E6%9C%89%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">共享内存没有访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-text">通过管道进行共享内存的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-text">运行结果</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">4.相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-0-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-text">4.0 临界资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">4.1 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">4.1.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">4.1.2 原子性的说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%8E%A5%E5%8F%A3"><span class="toc-text">4.1.3 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BF%A1%E5%8F%B7%E9%87%8F-semget"><span class="toc-text">创建信号量 semget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BF%A1%E5%8F%B7%E9%87%8F-semctl"><span class="toc-text">初始化信号量 semctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%BF%A1%E5%8F%B7%E9%87%8F-semop"><span class="toc-text">修改信号量 semop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-sembuf"><span class="toc-text">结构体 sembuf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%89%A9%E5%B1%95-mmap"><span class="toc-text">4.2 扩展: mmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E9%94%81-mutex"><span class="toc-text">4.3 多进程共享锁 mutex</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/196461022/" title="【leetcode】295.数据流的中位数"><img src="/img/bg/gm4.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【leetcode】295.数据流的中位数"></a><div class="content"><a class="title" href="/posts/196461022/" title="【leetcode】295.数据流的中位数">【leetcode】295.数据流的中位数</a><time datetime="2024-03-30T07:05:54.000Z" title="发表于 2024-03-30 15:05:54">2024-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3245288951/" title="【C++】布隆过滤器（海量数据处理）"><img src="/img/bg/gm9.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【C++】布隆过滤器（海量数据处理）"></a><div class="content"><a class="title" href="/posts/3245288951/" title="【C++】布隆过滤器（海量数据处理）">【C++】布隆过滤器（海量数据处理）</a><time datetime="2024-03-30T01:26:11.000Z" title="发表于 2024-03-30 09:26:11">2024-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2123053741/" title="【leetcode】233.数字1的个数"><img src="/img/bg/gm13.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【leetcode】233.数字1的个数"></a><div class="content"><a class="title" href="/posts/2123053741/" title="【leetcode】233.数字1的个数">【leetcode】233.数字1的个数</a><time datetime="2024-03-29T11:06:22.000Z" title="发表于 2024-03-29 19:06:22">2024-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4261184242/" title="【leetcode】53.最大子数组和"><img src="/img/bg/gm7.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【leetcode】53.最大子数组和"></a><div class="content"><a class="title" href="/posts/4261184242/" title="【leetcode】53.最大子数组和">【leetcode】53.最大子数组和</a><time datetime="2024-03-26T10:15:05.000Z" title="发表于 2024-03-26 18:15:05">2024-03-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>