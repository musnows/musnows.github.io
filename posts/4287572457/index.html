<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【网络】UDP和TCP协议详解 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文带你详细了解tcp协议的相关知识"><meta property="og:type" content="article"><meta property="og:title" content="【网络】UDP和TCP协议详解"><meta property="og:url" content="https://blog.musnow.top/posts/4287572457/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="本文带你详细了解tcp协议的相关知识"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.musnow.top/i/2023/03/6414766c49315.png"><meta property="article:published_time" content="2023-03-17T07:30:55.000Z"><meta property="article:modified_time" content="2024-05-17T09:13:45.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Linux"><meta property="article:tag" content="nginx"><meta property="article:tag" content="tcp"><meta property="article:tag" content="udp"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.musnow.top/i/2023/03/6414766c49315.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/4287572457/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【网络】UDP和TCP协议详解",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-05-17 17:13:45"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">401</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://img.musnow.top/i/2023/03/6414766c49315.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【网络】UDP和TCP协议详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-17T07:30:55.000Z" title="发表于 2023-03-17 15:30:55">2023-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-17T09:13:45.000Z" title="更新于 2024-05-17 17:13:45">2024-05-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【网络】UDP和TCP协议详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文带你详细了解tcp协议的相关知识</p><span id="more"></span><blockquote><p>本文中部分截图为手写，字丑见谅</p></blockquote><h1 id="1-linux下常用网络命令"><a href="#1-linux下常用网络命令" class="headerlink" title="1.linux下常用网络命令"></a>1.linux下常用网络命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/servcies <span class="comment"># 系统常用服务和端口</span></span><br></pre></td></tr></table></figure><p>我们自己写网络服务器进程时，绑定的端口不能和系统端口冲突。尽量绑定1024以上的端口，推荐绑定不常用的5位数端口。</p><p>绑定低于1024的端口，会出现权限不足的报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./tcpServer 100</span><br><span class="line">DEBUG | 1679473830 | muxue | socket create success: 3</span><br><span class="line">FATAL | 1679473830 | muxue | bind: Permission denied:3</span><br></pre></td></tr></table></figure><h2 id="1-1-netstat命令"><a href="#1-1-netstat命令" class="headerlink" title="1.1 netstat命令"></a>1.1 netstat命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br><span class="line">netstat -l <span class="comment"># 只列出listen状态服务</span></span><br><span class="line">netstat -n <span class="comment"># 将显示的信息用数字（id）代替</span></span><br><span class="line">netstat -p <span class="comment"># 显示端口和进程pid的关联</span></span><br><span class="line">netstat -t <span class="comment"># tcp</span></span><br><span class="line">netstat -u <span class="comment"># udp</span></span><br><span class="line">netstat -a <span class="comment"># 显示所有服务</span></span><br></pre></td></tr></table></figure><h2 id="1-2-pidof"><a href="#1-2-pidof" class="headerlink" title="1.2 pidof"></a>1.2 pidof</h2><p>获取某个进程名的进程pid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof 进程名</span><br></pre></td></tr></table></figure><p>比如我想查看<code>sshd</code>的进程id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pidof sshd</span><br><span class="line">20706 20703 10775 6067 6009 3339 3338 3272 3269 1340</span><br></pre></td></tr></table></figure><h1 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2.UDP协议"></a>2.UDP协议</h1><p>一下为udp报文格式的结构图</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6414432a16b9f.png" alt="image-20230317183835725"></p><p>udp采用了定长报文，这也是udp <code>面向数据报</code> 的特性</p><ul><li>udp采用16位作为ip+端口的存放，源端口和目的端口用于数据的<strong>解包分用</strong>（系统需要知道当前的数据包应该丢给上层的哪一个端口）</li><li>16位udp长度，表示整个数据报 <code>udp首部+udp数据</code> 的最大长度</li><li>16位校验和用于校验报文是否出现错误。如果校验和出错，就会直接丢弃报文</li></ul><p>由于udp的长度标志位只有16位，所以一个udp报文<strong>理论上</strong>能传输的最大数据是<code>64kb</code> (2<sup>16</sup>)；</p><p>如果需要用udp传输大于<code>64kb</code>的数据，则需要在<strong>应用层</strong>进行拆分，在接收方的<strong>应用层</strong>进行合并。</p><h2 id="2-1-理解报头"><a href="#2-1-理解报头" class="headerlink" title="2.1 理解报头"></a>2.1 理解报头</h2><p>所谓报头，其实就是操作系统内核中的一个C语言的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例，不代表真实情况</span></span><br><span class="line"><span class="comment">//udp报头采用了位段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udp_hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> src_port:<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dst_port:<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> udp_len:<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> udp_check:<span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加报头的本质，其实就是给数据的头部添加上一个<code>struct udp_hdr</code>结构体；</p><p>而解包的时候，也是将指针移动固定长度（8个字节）的空间，将指针强转为<code>struct udp_hdr</code>，即获取到了当前报文的udp报头</p><h2 id="2-2-udp的特点"><a href="#2-2-udp的特点" class="headerlink" title="2.2 udp的特点"></a>2.2 udp的特点</h2><p>udp传输的过程类似于<code>飞鸽传书</code></p><ul><li>无连接：知道对方的<code>ip:端口</code>就能直接传输数据，不需要建立连接</li><li>面向数据报：定长报文，不能灵活控制报文的读取次数和数量<ul><li>一次必须要读取完毕一个完整的udp报文</li><li>假设报文100字节，不能通过10次每次读10字节来获取报文。必须一次读完100字节</li></ul></li><li>不可靠：没有确认机制和重传机制，如果因为各种原因，鸽子在路上出事了，那传输的信息也直接丢失了。udp也不会给应用层返回错误信息。</li></ul><h2 id="2-3-udp缓冲区"><a href="#2-3-udp缓冲区" class="headerlink" title="2.3 udp缓冲区"></a>2.3 udp缓冲区</h2><p>udp支持<code>全双工</code>，udp的socket即可写也可读</p><p>udp没有发送缓冲区，应用层调用<code>sendto</code>会直接将数据交给OS内核（其实就是拷贝），内核再交由网络模组进行后续传输。</p><blockquote><p>由于udp采用了定长报头，其报头较为简单，OS只需要添加上报头即可发送。这个过程很快，所以缓冲区的作用不大。</p></blockquote><p>udp有接收缓冲区，这个接收缓冲区只是一味地接收，并不能保证报文的顺序</p><blockquote><p>因为不保证顺序，所以有可能<strong>乱序</strong>，也是<strong>udp不可靠</strong>的体现</p></blockquote><p>若缓冲区满，新到达的udp数据就会被丢弃。</p><h2 id="2-4-丢包"><a href="#2-4-丢包" class="headerlink" title="2.4 丢包"></a>2.4 丢包</h2><p>一个数据包丢包可能有多种情况</p><ul><li>数据包内容出错（比特位翻转等）</li><li>数据包延迟到达（延迟过久视为丢包）</li><li>数据包在路上被阻塞（到不了）</li><li>数据包在路上由于网络波动而丢失（网络突然抽风了，报文直接不见了）</li></ul><p>udp的报文也是如此，但udp<strong>不可靠</strong>并不是一个贬义词，应该是一个中性词。</p><ul><li>udp不可靠是他的特点，由于udp简单，其不需要进行连接，报头添加的效率快，由此性能消耗小于tcp。</li><li>带来的缺点就是udp不可靠</li></ul><p>在直播场景中，udp的使用很多。同一场直播观看的人数会很多，如果每一个用户都维持一个tcp连接，服务器的负载就太大了。用udp就能直接向该用户广播数据，负载小。</p><h2 id="2-5-基于udp的应用层协议"><a href="#2-5-基于udp的应用层协议" class="headerlink" title="2.5 基于udp的应用层协议"></a>2.5 基于udp的应用层协议</h2><ul><li>NFS: 网络文件系统</li><li>TFTP: 简单文件传输协议</li><li>DHCP: 动态主机配置协议</li><li>BOOTP: 启动协议（用于无盘设备启动）</li><li>DNS: 域名解析协议</li></ul><h2 id="2-6-udp的传输大小限制"><a href="#2-6-udp的传输大小限制" class="headerlink" title="2.6 udp的传输大小限制"></a>2.6 udp的传输大小限制</h2><p>在学习DNS协议的时候，发现DNS是512字节的数据采用UDP，大于512字节的数据就会采用TCP了。又看了几个相关的博客，发现有些用词不太严谨，直接说“UDP最大只支持512字节数据的传输”给我吓了一跳，还以为自己之前学习的内容有误，赶快来研究一下到底是什么情况。</p><blockquote><p><a target="_blank" rel="noopener" href="https://taifua.com/udp-512bytes-limit.html">https://taifua.com/udp-512bytes-limit.html</a></p></blockquote><p>前文提到，UDP报文中的16位长度字段，限制了udp报文的长度为<code>64KB</code>，对应有效载荷的大小是 <code>64KB - 20IP首部 - 8UDP首部 = 65507 字节</code>（这里减去IP首部长度是因为IP报文的最大长度限制也是64KB）。</p><p>如果计算 MTU 1500 字节的限制，那么UDP的有效载荷就变成了<code>1500-20-8=1472</code>字节了，超过1472字节的数据都需要在网络层进行分片才能传输成功。这里的分片是由IP层来负责的，具体的参考IP分片的知识点。</p><p>但实际上，在最终的国际互联网中，由于IPv4协议的原因，很多链路的MTU并不是1500字节，而是576字节（IPv4 标准规定，每个主机必须能够重新组装576字节或更少的数据包）。</p><p>这就要求我们最好将UDP有效载荷的长度控制在 <code>576-20-8=548</code> 字节。但这还不是512字节，原博主在StackOverflow上看到的回答提到了另外一个知识点，即IP数据报的选项字段：</p><blockquote><p>典型的 IPv4 头部是 20 字节，而 UDP 头部是 8 字节。然而，可以包括 IP 选项，该选项可以将 IP头部的大小增加到多达 60 字节（如图 1 所示）。</p><p>此外，有时中间节点需要将数据报封装在另一种协议（如IPsec（用于VPN等））中，以便将数据包路由到其目的地。</p><p>因此，如果不知道特定网络路径上的 MTU，最好为可能没有预料到的其他头部信息留出合理的余量。512字节的 UDP 有效载荷通常被认为可以做到这一点，尽管即使这样也没有为最大尺寸的IP报头留下足够的空间。</p></blockquote><p>因为IP报文的选项字段最大能让IP的首部增长到60字节，如果考虑最大的IP首部，则udp的有效载荷是 <code>576-60-8=508</code>，最终选用512字节，是给IP报文的选项留有一定空间余量的同时，给udp的有效载荷维持一个适中的值。</p><p>现在情况就明了了：UDP并非只能承载512字节的数据，最大有效载荷依旧是 <code>64KB - 20IP首部 - 8UDP首部 = 65507 字节</code>，选用512字节是考虑互联网IPv4的底层架构和UDP本身无链接的特性给出的<strong>一个建议</strong>罢了，主要目的是避免路途上出现分片（因为分片增加了丢包的概率），让UDP的效率和稳定性提高。</p><h1 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3.TCP协议"></a>3.TCP协议</h1><blockquote><p>本文往下都是tcp的内容了哦！</p></blockquote><p>下图为tcp协议报头的一个基本结构图，我们需要了解整个结构，以及每一个部分的作用</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6414766c49315.png" alt="image-20230317221627931"></p><h2 id="3-1-源和目的端口号"><a href="#3-1-源和目的端口号" class="headerlink" title="3.1 源和目的端口号"></a>3.1 源和目的端口号</h2><p>这部分和udp相同，tcp也需要源端口和目的端口号，以用于找到报文要去的目的地。</p><h2 id="3-2-4位首部长度"><a href="#3-2-4位首部长度" class="headerlink" title="3.2 4位首部长度"></a>3.2 4位首部长度</h2><p>相比于udp的定长报头，tcp采用了不定长的方式。但tcp的报头有<strong>标准的20字节</strong>，所有报头都至少有20字节。</p><p>在这20字节中，有一个<code>4位首部长度</code>，用于标识tcp报文的<strong>真实长度</strong>。</p><p>我们知道，4位二进制可以表示<code>0~15</code>，这不比固定的20字节还少吗？难道说，这4位首部长度标识的是比20字节多余的内容？</p><p>并不是！这4位首部长度的标识是有单位的，每一位首部长度，实际上代表的是4字节，即tcp报头的最大长度为 <code>15*4=60</code> 字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于标准长度也记入4位首部长度，所以4位首部长度的最小值为 0101</span><br></pre></td></tr></table></figure><p>读取tcp报文的时候，只需要先读取20字节，再从这20字节中<strong>取出</strong>4位首部长度，获得报头的实际长度；再重新读取，即获得了<strong>完整</strong>的tcp报头。剩下的部分就是报文携带的数据了（有效载荷）</p><h3 id="3-2-1-TCP报文完整长度"><a href="#3-2-1-TCP报文完整长度" class="headerlink" title="3.2.1 TCP报文完整长度"></a>3.2.1 TCP报文完整长度</h3><p>一个TCP报文段的最大长度为<code>65495</code>字节.</p><p>TCP封装在IP内，IP报头有一个最大长度字段是16位，即<code>65535</code> (2^16 - 1)，IP头部最小20，TCP头部长度最小20，所以最大封装数据长度为 <code>65535-20-20=65495</code>；</p><h2 id="3-3-32位序号-x2F-确认序号"><a href="#3-3-32位序号-x2F-确认序号" class="headerlink" title="3.3 32位序号&#x2F;确认序号"></a>3.3 32位序号&#x2F;确认序号</h2><h3 id="3-3-1-如何确认信息被对方收到？"><a href="#3-3-1-如何确认信息被对方收到？" class="headerlink" title="3.3.1 如何确认信息被对方收到？"></a>3.3.1 如何确认信息被对方收到？</h3><blockquote><p>tcp具有确认应答的机制</p></blockquote><p>当我们和对方<strong>微信交流</strong>的时候，怎么样才能确认自己的信息被对方看到了？</p><ul><li>A发：吃饭了吗？</li><li>B回应：吃了</li></ul><p>在这个场景中，只有B给A发出回应，A才能确认自己的消息被B看到了。</p><p>tcp通信也是如此，只有给对方发送的报文收到了对方的<strong>应答</strong>，发送方才能确认自己的报文被对方收到了。</p><p>为此，tcp引入了<code>32位 序号/确认序号</code></p><hr><h3 id="3-3-2-确认应答"><a href="#3-3-2-确认应答" class="headerlink" title="3.3.2 确认应答"></a>3.3.2 确认应答</h3><p>用于确认自己和对方的通信，究竟收到了哪一个报文（序号）以及确认信息发出的顺序。</p><p>比如客户端会向服务器发 <code>吃了吗？吃的什么？好吃吗？晚上想去干什么？</code>，如果没有对报头带上序号，服务器接收到的可能就会是下面这样 <code>好吃吗？晚上想去干什么？吃的什么？吃了吗？</code>，看起来是不是十分怪异？</p><p>所以，为了保证tcp报文的顺序性，以及保证报文被送达到对方。tcp引入了以序号为基础的<code>确认应答</code>机制：</p><ul><li>客户端向服务器发送一个报头，并将<strong>序号</strong>设置为1</li><li>服务端收到信息后，回复客户端一个报头，将<strong>确认序号</strong>设置为2（为已经收到了的客户端消息的序号<code>+1</code>。确认序号为2，代表1号报文收到，期望收到2号报文）</li><li>此时客户端就能确认服务器收到了自己刚刚发出的序号为1的消息</li><li>下次发送消息，客户端会从2号开始发送</li></ul><p>以上是一次通信的过程，如果是多次通信呢？</p><ul><li>客户端连续向服务器发送了n个消息，服务器应答：1、2、3、4……</li><li>服务器的每次应答会设置<strong>确认序号</strong>，代表n之前的报文（不包括n自己）被全部收到</li><li>比如假设客户端发送了<code>1-10</code>的报文，而第6个报文出现了丢失，那么服务端就应该设置<code>确认序号</code>为6，代表<strong>6之前</strong>的报文都被正常收到。</li><li>此时客户端发现，明明自己已经都发到10了，服务端还在回应6。这就代表发送过程中，<strong>6号报文丢失了</strong>！于是客户端从6号报文开始，<strong>重发报文</strong>：6、7、8……</li></ul><p>不管是服务端给客户端发信息，还是客户端给服务器发信息，收方都需要对信息进行回应。tcp通信中，<strong>通信双方地位是对等</strong>的！</p><p>重点：TCP确认序号应该设置为已经成功收到的报文的<strong>下一位序号</strong></p><h3 id="3-3-3-为什么有两组确认序号？"><a href="#3-3-3-为什么有两组确认序号？" class="headerlink" title="3.3.3 为什么有两组确认序号？"></a>3.3.3 为什么有两组确认序号？</h3><p>tcp是<strong>全双工</strong>的，通信一方在发送响应信息的同时，可能也会携带新的报文给对方。</p><ul><li>客户端给服务器发了一条消息 <code>吃了吗？</code></li><li>服务器在回复的同时，也带上了新的请求 <code>吃了，你呢？</code></li><li>服务器的这种策略叫做：<strong>捎带应答</strong></li></ul><p>此时服务端就需要在填充<em>客户端</em>消息的<strong>确认序号</strong>的同时，填充<em>自己</em>所发消息的<strong>序号</strong>。这样才能保证tcp在双向交流中的可靠性！</p><p>所以在tcp报头中，<strong>序号和确认序号</strong>缺一不可！</p><h3 id="3-3-4-没有完美的协议！"><a href="#3-3-4-没有完美的协议！" class="headerlink" title="3.3.4 没有完美的协议！"></a>3.3.4 没有完美的协议！</h3><p>经过上面的过程，我们会发现，总有一条报文，<strong>在收到对方回应之前</strong>，是无法得知对方是否收到信息的。</p><p>这也说明：没有一定可靠的协议！</p><h3 id="3-3-5-按序到达"><a href="#3-3-5-按序到达" class="headerlink" title="3.3.5 按序到达"></a>3.3.5 按序到达</h3><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641543370a163.png" alt="image-20230318125057097"></p><p>序号除了用于确认应答，还有多个功能</p><ul><li>保证数据的顺序收发问题</li></ul><p>比如一个http的报头，原本的格式应该是下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></table></figure><p>结果由于传输的过程中乱序了，变成了下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 GET /</span><br></pre></td></tr></table></figure><p>这种情况，是不能被应用层所正常解析的！数据全都乱了，原本写好的代码也没用了。</p><p>所以，为了避免数据在传输中<code>乱序</code>，tcp的序号就有了新的功能——保证数据的按序到达。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.客户端发送了1-5号报文</span><br><span class="line">2.服务端收到了1 3 4 2 5（乱序）</span><br><span class="line">3.服务端在tcp的接收缓冲区中，将报文重排序为1-5</span><br><span class="line">4.将重排序后的正确数据交付给应用层</span><br></pre></td></tr></table></figure><p>但是，如果<strong>只</strong>按顺序来接收数据，那就无法处理<code>优先级</code>问题。<span id="jump">这部分</span>将在后文<strong>6个标记位</strong>详解。</p><p>序号除了可以用于排序，还能用于<code>去重</code>，这部分也将在后文<strong>超时重传</strong>部分解析。</p><h3 id="3-3-6-第一个序号的产生"><a href="#3-3-6-第一个序号的产生" class="headerlink" title="3.3.6 第一个序号的产生"></a>3.3.6 第一个序号的产生</h3><p>之前学习的时候都是用0来举例子，在计网的学习中又了解到TCP的第一个序号是随机生成的。下面是对这个随机生成的简单说明。</p><blockquote><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/397593729/answer/1248286390">https://www.zhihu.com/question/397593729/answer/1248286390</a></p></blockquote><p>假如一个TCP连接的第一个报文序列号（ISN）是0，那么后续每个报文的序列号是固定的。但是为了防止黑客使用TCP Spoof方法攻击，这个ISN要求是随机的，避免被黑客猜到。</p><p>在Windows的不同版本，或者Linux的不同版本，这个随机的方法都不太一样。RFC1948里建议的随机算法是 <code>ISN=M+F(localhost, localport,remotehost, remoteport)</code>，其中M是一个计时器，每4毫秒加1。F是一个Hash算法，比如MD5或者SHA256。</p><p>TCP协议要使用的序列号是后面报文实际携带的序列号和ISN的相对值。</p><h2 id="3-4-16位窗口大小"><a href="#3-4-16位窗口大小" class="headerlink" title="3.4 16位窗口大小"></a>3.4 16位窗口大小</h2><h3 id="3-4-1-发送和接收缓冲区"><a href="#3-4-1-发送和接收缓冲区" class="headerlink" title="3.4.1 发送和接收缓冲区"></a>3.4.1 发送和接收缓冲区</h3><p>tcp同时拥有发送和接收缓冲区。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6415458533954.png" alt="image-20230318130053000"></p><p>我们在应用层调用的<code>read/write</code>函数，实际上只是将数据<code>从接收缓冲区中拷贝出来/发送的数据拷贝到发送缓冲区</code>。</p><blockquote><p>如果write包含将数据发送给对方的过程，那么这个函数的调用效率就太低了，影响应用层执行其他代码。</p></blockquote><p>数据并没有被立即送入网络传输，而是由tcp协议自主决定发送数据的长度和发送的时间！这一切，都是由<strong>操作系统</strong>来决定的。这就是为什么tcp又称为<code>传输控制协议</code>！</p><h3 id="3-4-2-接收缓冲区满了咋办"><a href="#3-4-2-接收缓冲区满了咋办" class="headerlink" title="3.4.2 接收缓冲区满了咋办"></a>3.4.2 接收缓冲区满了咋办</h3><p>既然有缓冲区，就肯定会存在缓冲区被写满的问题。</p><ul><li>发送缓冲区满，由操作系统告知应用层，不再往发送缓冲区中写入数据</li><li>接受缓冲区满<ul><li>直接丢弃数据？</li><li>告诉对方，不再给自己发信息？</li></ul></li></ul><p>在实际的tcp收发过程中，由于<strong>接收方缓冲区满</strong>而丢弃数据，是不可接受的。因为数据跨过了茫茫网络，都已经到你机器上了，结果因为你缓冲区满了给它丢掉了，这不是坑人吗？</p><p>虽然出现这种情况，我们可以让发送方重传报文，但这样效率太低！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031203959.jpg" alt="QQ图片20220424132543"></p><p>所以，我们应该让收发双方知晓对方的缓冲区大小，从而避免这个问题！</p><p>这就是tcp报头中<code>16位窗口大小</code>的作用了！</p><h3 id="3-4-3-告知对方收缓大小"><a href="#3-4-3-告知对方收缓大小" class="headerlink" title="3.4.3 告知对方收缓大小"></a>3.4.3 告知对方收缓大小</h3><p>如下图，在客户端和服务端<code>互通有无</code>的时候，假设服务端的<strong>接收缓冲区</strong>满了，应该告知客户端，让他别再给自己发消息了。</p><p>此时，服务端设置自己的<code>16位窗口大小</code>，以此告知客户端自己的缓冲区<strong>剩余</strong>容量。</p><p>如果对方发来的报文中，<code>16位窗口大小</code>所表示的缓冲区剩余容量已经不足了，发送方就不应该继续发送，而应该等待对方从缓冲区中取走数据。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/64154988e2f2b.png" alt="image-20230318131802239"></p><p>这是已经开始通讯的情况，但如果是<strong>第一次</strong>通讯呢？如果客户端一来就发送了一个巨大的数据，直接塞满了服务端的缓冲区，那不是出事了？</p><p>这便是tcp在<strong>三次握手</strong>中要做的事情了，简单来说就是在通信开始前就互相告知自己缓冲区的大小。后文会讲解。</p><h3 id="3-4-4-缓冲区是否独立？"><a href="#3-4-4-缓冲区是否独立？" class="headerlink" title="3.4.4 缓冲区是否独立？"></a>3.4.4 缓冲区是否独立？</h3><ul><li>进程的tcp缓冲区是独立的吗？</li></ul><p>每个进程都有自己的内核空间，内核空间里有tcp缓冲区，所以每个进程都有自己独立的tcp缓冲区</p><ul><li>线程的tcp缓冲区是独立的吗？</li></ul><p>是的！虽然这些线程共享同一个内核TCP缓冲区，但是每个线程使用的缓冲区是独立的，互相之间不会产生冲突。每个线程对自己的缓冲区进行读写操作时，会使用内核提供的同步机制，如互斥锁、信号量等来确保线程之间的缓冲区不会互相干扰，从而实现数据的安全读写。</p><h2 id="3-5-六个标记位"><a href="#3-5-六个标记位" class="headerlink" title="3.5 六个标记位"></a>3.5 六个标记位</h2><p>在4位首部长度右侧，有一块保留长度，和6个标记位。这六个标记位是所有设备都支持的标记位。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/64156cd9c9751.png" alt="image-20230318154843384"></p><ul><li>SYN: 连接标记位，用于建立连接（又称同步报文）</li><li>FIN: 表示请求关闭连接，又称为<code>结束报文</code></li><li>ACK：响应报文，代表本次报文中包含对之前报文的确认应答</li><li>PSH：要求对方立马从tcp缓冲区中取走数据</li><li>URG：紧急指针标记位，用于紧急数据的传输</li><li>RST：要求重置连接（双方重新建立一次新的tcp连接）</li></ul><h3 id="3-5-1-8个标记位？"><a href="#3-5-1-8个标记位？" class="headerlink" title="3.5.1 8个标记位？"></a>3.5.1 8个标记位？</h3><p>在部分书籍中，还会出现8个标记位与4位保留长度的说法（下图源自《图解tcp&#x2F;ip第五版》）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/64156e7dd3169.png" alt="image-20230318155543377"></p><ul><li>CWR（Congestion Window Reduced）：该标志位用于通知对方自己已经将拥塞窗口缩小。在TCP SYN握手时，发送方会将CWR标志位设置为1，表示它支持ECN（Explicit Congestion Notification）拥塞控制，并且接收到的TCP包的IP头部的ECN被设置为11。如果发送方收到了一个设置了ECE（ECN Echo）标志位的TCP数据包，则它将调整自己的拥塞窗口，就像它从丢失的数据包中快速恢复一样。然后，发送方会在下一个数据包中设置CWR标志位，向接收方表明它已对拥塞做出反应。发送方在每个RTT（Round Trip Time）间隔最多做出一次这种反应。</li><li>ECE（ECN Echo）：该标志位用于通知对方从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时，TCP首部中的ECE会被设置为1。接收方会在所有数据包中设置ECE标志位，以便通知发送方网络发生了拥塞。</li></ul><p>而我百度到的文章提到，tcp给多出来的两个标记位新增了功能：</p><ul><li>除了以上6个标志位，还有一个实验性的标志位NS（Nonce Sum），用于防止TCP发送者的数据包标记被意外或恶意改动。NS标志位仍然是一个实验标志，用于帮助防止发送者的数据包标记被意外或恶意更改。<a target="_blank" rel="noopener" href="https://www.codetd.com/article/12421677">3</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38323666/article/details/85338477">4</a></li><li>TCP标志位中还有两个标志位后来加的一个功能：显式拥塞通知（ECN）。ECN允许拥塞控制的端对端通知而避免丢包。但是，ECN在某些老旧的路由器和操作系统（例如：Windows XP）上不受支持。在TCP连接上使用ECN也是可选的；当ECN被使用时，它必须在连接创建时通过SYN和SYN-ACK段中包含适当选项来协商。 <a target="_blank" rel="noopener" href="https://www.likecs.com/show-203551574.html">2</a> <a target="_blank" rel="noopener" href="https://www.codetd.com/article/12421677">3</a></li></ul><p>诸如<code>tcp的标记位到底是6个还是8个?</code> 这种摸棱两可的问题，在考试中不会问道。</p><p>在学习中，我们只需要掌握所有设备都支持的<strong>6个标记位</strong>即可</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211031205743.png" alt="狗头"></p><h3 id="3-5-2-ACK"><a href="#3-5-2-ACK" class="headerlink" title="3.5.2 ACK"></a>3.5.2 ACK</h3><p>该标记位用于标识本条报文是对之前的报文的<code>确认应答</code>。设置了改标记位，那么接收方就应该去查看该报文中的确认应答序号。</p><p>ACK标记位的设置和其他标记位并不冲突，在<code>捎带应答</code>的时候，可以同时设置包括ACK在内的多个标记位，而不影响当前报文的原本功能</p><h3 id="3-5-3-SYN-x2F-FIN"><a href="#3-5-3-SYN-x2F-FIN" class="headerlink" title="3.5.3 SYN&#x2F;FIN"></a>3.5.3 SYN&#x2F;FIN</h3><ul><li>SYN：表示请求建立连接，并在建立连接时用于同步序列号，所以又称为<code>同步报文</code>；</li><li>FIN：表示请求关闭连接，又称为<code>结束报文</code>。设置为1时，代表本方希望断开连接。此时双方要交换FIN（四次挥手）才能真正断开tcp连接。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6415723928135.png" alt="image-20230318161138819"></p><h4 id="3-5-3-1-三次握手"><a href="#3-5-3-1-三次握手" class="headerlink" title="3.5.3.1 三次握手"></a>3.5.3.1 三次握手</h4><p>在三次握手的时候，经历了如下过程</p><ul><li>连接发方A向对方主机B发送SYN报文，请求建立连接（A进入<code>SYN-SENT</code>状态）</li><li>主机B在收到报文后，回应<code>ACK+SYN</code>的报文，在确认应答的同时，请求建立连接（B进入<code>SYN-RCVD</code>状态）</li><li>A收到这条报文后，发送确认应答ACK（A认为连接成功建立 <code>ESTABLISHED</code>）</li><li>B收到A发送的ACK，三次握手完成（B认为连接成功建立 <code>ESTABLISHED</code>）</li></ul><p>下面这样写应该能更容易明白一些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A     SYN-&gt;      B</span><br><span class="line">A(SYN_SENT)      B</span><br><span class="line">A   &lt;-SYN+ACK    B</span><br><span class="line">A      (SYN_RCVD)B</span><br><span class="line">A     ACK-&gt;      B</span><br><span class="line">A(ESTABLISHED)   B</span><br><span class="line">A   (ESTABLISHED)B 收到ACK</span><br></pre></td></tr></table></figure><h5 id="为什么接收方要发送ACK-SYN"><a href="#为什么接收方要发送ACK-SYN" class="headerlink" title="为什么接收方要发送ACK+SYN"></a>为什么接收方要发送ACK+SYN</h5><ul><li>为什么接收方要发送ACK+SYN，而不是只发送ACK？</li></ul><p>接收方发送带有ACK+SYN标志的数据包，是为了确认收到了发送方的SYN，<strong>并向发送方表明自己也同意建立连接</strong>。ACK字段用于确认收到了之前的数据包，而SYN字段用于表示接收方也希望建立连接。</p><p>若接收方只发送ACK而不带SYN标志，这可能会导致混淆。因为TCP中的ACK字段表示确认收到之前的数据包，而在初始握手阶段，双方都还没有进行数据传输，<strong>所以ACK字段无法明确指示是在确认SYN还是确认其他数据包</strong>。因此，发送方在收到只带ACK标志的数据包时，无法准确知道接收方是否同意建立连接。</p><p>通过在握手过程中同时发送ACK+SYN标志，接收方可以在一个数据包中明确表示两个信息：确认收到发送方的SYN，并表示自己也愿意建立连接。这样就能够确保双方在握手过程中能够准确理解对方的意图，并建立起可靠的连接。</p><h4 id="3-5-3-2-四次挥手"><a href="#3-5-3-2-四次挥手" class="headerlink" title="3.5.3.2 四次挥手"></a>3.5.3.2 四次挥手</h4><p>在断开连接，四次挥手的时候，经历了如下过程</p><ul><li>A要断开连接，发送FIN（A进入<code>FIN WAIT 1</code>状态）</li><li>B收到了FIN，发送ACK（B进入<code>CLOSE-WAIT</code>半关闭状态）</li><li>A收到了ACK（A进入<code>FIN WAIT 2</code>状态)</li><li>此时只是A要和B单方面分手，<code>A-&gt;B</code>的路被切断了，但是<code>B-&gt;A</code>的还没有，B还能继续给A发数据</li><li>B发完数据了，也和A分手了，B发送FIN（B进入<code>LAST ACK</code>状态）</li><li>A收到FIN，发送回应ACK（A进入<code>TIME WAIT</code>状态，将在<strong>一段时间后</strong>进入<code>CLOSE</code>断连状态）</li><li>B收到了ACK（B进入<code>CLOSE</code>状态）</li><li>连接关闭</li></ul><p>我们不仅需要知道3次握手和4次挥手的过程，还需要知道每一次的状态变化！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/fb6e6fbecf79673798620e173728b111.png" alt="img"></p><p>3次握手和4次挥手对于应用层的C语言接口，<strong>都只有1个对应的函数</strong>。这些操作都是由西欧系统内核的tcp协议栈自主完成的。</p><h3 id="3-5-4-PSH"><a href="#3-5-4-PSH" class="headerlink" title="3.5.4 PSH"></a>3.5.4 PSH</h3><p>PSH标记位的作用是：要求对方立马取走缓冲区中数据</p><p>如下图，S在接收缓冲区满了之后过了很久，还没有取走缓冲区中的数据，C实在忍不住了，给S发一个<code>PSH</code>标记位的报文，要求S立马取走这些数据！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641578af00365.png" alt="image-20230318163912700"></p><p>tcp在收到此报文后，将由操作系统告知应用层，取走缓冲区中的数据。</p><p>如果应用层不听操作系统的咋办？<strong>那就代表应用层写的有bug</strong>！人家给你发了那么多东西了你还不处理，有点过分了！</p><h3 id="3-5-5-URG"><a href="#3-5-5-URG" class="headerlink" title="3.5.5 URG"></a>3.5.5 URG</h3><p>URG是<strong>紧急指针标记位</strong>。</p><p>在<a href="#jump">3.3.5 按序到达</a>部分提到过，如果只关注序号，则无法处理优先级问题。有一些数据对于应用层来说，优先级较高。如果tcp只会老老实实的按顺序把数据交付给应用层，那在高优先级的数据也搞不过操作系统对tcp的处理。</p><p>所以，为了能操作优先级，tcp提供了<code>URG</code>标记位，设置了此标记位的报文具有较高优先级。</p><p>应用层有专门的接口可以优先读取带有<code>URG</code>标记位的报文。</p><h4 id="3-5-5-1-16位紧急指针"><a href="#3-5-5-1-16位紧急指针" class="headerlink" title="3.5.5.1 16位紧急指针"></a>3.5.5.1 16位紧急指针</h4><p>为了能标识这个紧急数据在报文中的位置，tcp还提供了<code>16位紧急指针</code>；这个指针的指向便是<strong>紧急数据</strong>在tcp报文中的偏移量。<strong>紧急数据</strong>规定只有1个字节！</p><p>由于紧急指针的数据可以被提前读取，不受tcp缓冲区的约束，所以又被称为<code>带外数据</code></p><p>下图就举了一个紧急指针使用的场景：</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/64157b0e4aeba.png" alt="image-20230318164915979"></p><p>TCP 在传输数据时是有顺序的，它有<strong>字节号</strong>，URG配合紧急指针，就可以找到紧急数据的<strong>字节号</strong>。</p><p>紧急数据的字节号公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">紧急数据字节号(urgSeq) = TCP报文序号(seq) + 紧急指针(urgpoint) −1</span><br></pre></td></tr></table></figure><p>比如图中的例子，如果 <code>seq = 10,urgpoint = 5</code>，那么字节序号 <code>urgSeq = 10 + 5 -1 = 14</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641582bf3d3bc.png" alt="image-20230318172209050"></p><p>知道了字节号后，就可以计算紧急数据字位于<strong>所有传输数据中</strong>的第几个字节了。如果从第0个字节开始算起，那么紧急数据就是第<code>urgSeq - ISN - 1</code>个字节（ISN 表示初始序列号），减1表示不包括第一个SYN段，因为一个SYN段会消耗一个字节号。</p><h3 id="3-5-6-RST"><a href="#3-5-6-RST" class="headerlink" title="3.5.6 RST"></a>3.5.6 RST</h3><p>RST为复位报文，即<code>RESET</code>。</p><p>如下图，如果A给B发送的ACK在传输路途上丢失了，咋办？</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6415911e126cc.png" alt="image-20230318182326946"></p><p>这时候，就会出现A认为连接已经建立，而B由于没收到A的ACK而处于<code>SYN-RCVD</code>状态。</p><ul><li>此时A开始给B发送数据，B一看，不是说好了要建立连接才能发送数据的吗，你这是在干嘛？</li><li>于是B告知A，发送RST标志位的报文，要求和A重新建立连接（重新进行三次握手）</li><li>重新建立连接成功后，AB再正常发送信息。</li></ul><p>以上只是RST使用的情况之一。我们使用浏览器访问一些网页时，<code>F5刷新</code>就可以理解为浏览器向服务器发送了一个带有RST标记位的报文。</p><h2 id="3-6-为什么是3次握手？"><a href="#3-6-为什么是3次握手？" class="headerlink" title="3.6 为什么是3次握手？"></a>3.6 为什么是3次握手？</h2><p>为什么握手的次数是3次，不是1次、2次、4次、5次？</p><p>在讨论这个问题之前，我们要知道：<strong>连接建立是有消耗的</strong>！需要维护其缓存区、连接描述符（linux下为文件描述符）等等数据。基于这点认识，我们接着往下看</p><ul><li>如果是一次握手？</li></ul><p>一次握手，即A给B发送一个SYN，双方就认为连接建立了。</p><p>那么我们直接拿个机器，写个死循环，一直给对方发送SYN，自己直接丢弃文件描述符（不做维护）</p><p>由于服务器并不知道你（发送方）直接丢弃了文件描述符，其还是要为此次连接维护相关数据，这样会导致服务器的资源（为了维护tcp链接）在短时间内被大量消耗，最后直接dead了</p><blockquote><p>这种攻击叫做<strong>SYN洪水</strong></p></blockquote><ul><li>如果是二次握手？</li></ul><p>A给B发送一个SYN，B给A发送一个ACK，即认为连接建立。</p><p>这和一次握手其实是相似的，服务器发送完毕ACK之后，就认为连接已经建立，需要维护相关资源。而我们依旧可以直接丢弃，不进行任何维护，最后还是服务器的资源被消耗完了</p><ul><li>三次握手</li></ul><p>三次握手了之后，双方都必须维护连接的相关资源；这样，哪怕你攻击我的服务器，<strong>你也得付出同等的资源消耗</strong>。最后就是比谁资源更多呗！</p><p>相比于前两种情况，三次握手能在<strong>验证全双工</strong>的同时，一定程度上避免攻击。</p><p>三次握手还将最后一次ACK丢失的成本嫁接给了客户端（连接发起方）如果最后一次ACK丢失，要由客户端重新发起和服务器的连接。</p><p>注意，三次握手只是<strong>一定程度</strong>上避免攻击。我们依旧可以用很多宿主机“堆料”来和服务器硬碰硬，这是无可避免的情况。</p><ul><li>更多次握手？</li></ul><p>由于三次握手已经满足了我们的要求，更多次握手依旧有被攻击的可能，还降低了效率，完全没必要！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/64158f71c8c50.png" alt="image-20230318181619570"></p><h2 id="3-7-超时重传"><a href="#3-7-超时重传" class="headerlink" title="3.7 超时重传"></a>3.7 超时重传</h2><h3 id="3-7-1-超时重传的说明"><a href="#3-7-1-超时重传的说明" class="headerlink" title="3.7.1 超时重传的说明"></a>3.7.1 超时重传的说明</h3><p>为了保证可靠性，如果一个报文长时间未收到对方的ACK回应，则需要进行<code>超时重传</code>。</p><p>linux下每一次尝试的时间间隔为500ms，若500ms内尚未收到对方的ACK，则重发报文，再等待1000ms……以此类推。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6415924e3984a.png" alt="image-20230318182832179"></p><p>超时重传还可能遇到下面的情况：</p><ul><li>服务器收到了消息，也发送了ACK，但是ACK在路上丢失了</li><li>客户端没有收到ACK，于是进行超时重传</li><li>服务器再次收到了消息，此时接收缓冲区里出现了两个一样的数据</li></ul><p>但是，我们的报文是有序号的，tcp就可以<strong>直接根据序号去重</strong>，所以，tcp交给应用层的数据是<code>去重+排序</code>之后的数据！应用层并不需要担心数据重复或者顺序有误的情况。</p><p>如果同一个报文超时重传了好几次，还没有收到对方的应答，就会认为对方的服务挂掉了，此时本端会<strong>强制断连</strong>。此时客户端就可以发送一个带有RST标记位的报文，要求和对方重新建立连接。如果重连失败，<strong>则可以认为对方确实挂掉了</strong>，这便是我们在浏览器中有时会看到的 <code>SERVICE_UNAVALIABLE</code> 服务不可用；</p><h3 id="3-7-2-超时重传时间RTO的选择"><a href="#3-7-2-超时重传时间RTO的选择" class="headerlink" title="3.7.2 超时重传时间RTO的选择"></a>3.7.2 超时重传时间RTO的选择</h3><p>超时重传时间的选择是TCP最复杂的问题之一。</p><p>首先要知道一个概念：往返时间RTT，即一端发送一个报文+收到ACK报文的时间；</p><ul><li>如果超时重传时间RTO设置的小于往返时间RTT，则会产生不必要的重传，加大网络拥塞</li><li>如果超时重传时间RTO设置的远大于往返时间RTT，则会导致网络中出现大段空闲，网络使用效率降低</li></ul><p>由此可以得到一个暂时的结论：超时重传时间RTO的值应该设置为略大于RTT的值</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/c317995de6648e111a6dd94b349ccd93.png" alt="image-20240101130801208"></p><p>但是，这个问题的复杂在于，TCP下层的网络环境随时都有可能变化，往返时间RTT也有可能会有极具的波动，因此RTO也得跟着RTT实时发生变化。</p><p>比如下图所示，RTT1大于RTT0，此时RTO就不再适用于RTT1的情况，会造成不必要的重传。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/04d3151f032518dfdcb5d4d15cb121c0.png" alt="image-20240101132011738"></p><p>所以，并不能简单的使用某次测量得到的RTT样本来计算超时重传时间RTO。</p><p>而需要使用一个加权公式来计算平均往返时间RTTs，又称为平滑往返时间。<br>$$<br>RTT_{si} &#x3D; RTT_{i}<br>$$</p><p>$$<br>新 RTT_{s} &#x3D; (1-α) * 旧 RTT_{s} + α*新RTT样本<br>$$</p><p>在上述公式中，<code>0&lt;=α&lt;1</code></p><ul><li>如果α很接近于0，则新RTT样本对RTTs影响不大</li><li>如果α很接近于1，则新RTT样本对RTTs的影响较大</li></ul><p>已成为建议标准的RFC6298推荐的α值为1&#x2F;8，即<code>0.125</code>；</p><p>用这种方式得到的加权平均往返时间RTTs就比测量出的RTT值更加平滑。超时重传时间RTO应该略大于加权平均往返时间RTTs；</p><p>RFC6298建议使用下式计算出超时重传时间RTO<br>$$<br>RTO &#x3D; RTT_S +4*RTT_D<br>$$<br>RTT偏差的加权平均RTTd的计算公式如下<br>$$<br>RTT_{DI} &#x3D; RTT_I &#x2F;2 \<br>$$<br>$$<br>新 RTT_D &#x3D; (1-β) * 旧 RTT_d + β * |RTT_S - 新RTT样本| \<br>$$<br>$$<br>0&lt;&#x3D;β&lt;1<br>$$<br>已成为建议标准的RFC6298推荐的β值为1&#x2F;4，即<code>0.25</code>；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/51f1231b8977d97ebbd5d5ebad630798.png" alt="image-20240101132601814"></p><p>由此可见，超时重传时间RTO的计算基于新的RTT样本。但是在已经出现超时重传的情况下，RTT的测量并不容易。如下图所示，左侧是发送的第一个报文丢失，进行超时重传后收到ACK的情况。但是A主机并没有办法确认这个ACK是对第一个丢失报文的确认，还是对超时重传后的报文的确认，RTT就有可能会有两个取值，如果取值错误，就容易出现问题。右侧情况也是同理</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/7a25cf3e2b25788db1670f1c49421eba.png" alt="image-20240101133854845"></p><p>因为这种超时重传的情况无法得到一个准确的新RTT样本，所以Karn提出一个算法，如果出现超时重传，则不更新RTTs和RTO。但这个算法并不完善，需要修正：报文段每重传一次，就将RTO稍微增大一些，典型的做法是将RTO取值为旧RTO值的2倍。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/8c10b3a841fbdf8cf28028b800f059cf.png" alt="image-20240101134236720"></p><h3 id="3-7-3-超时重传时间例题"><a href="#3-7-3-超时重传时间例题" class="headerlink" title="3.7.3 超时重传时间例题"></a>3.7.3 超时重传时间例题</h3><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/4c3cfe2dc60b1d5775e0cbe27aad4652.png" alt="image-20240101134847585"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/c1cf24614a22bfef173cec56cfd0abbd.png" alt="image-20240101135244716"></p><h2 id="3-8-出现了很多CLOSE-WAIT状态的连接？"><a href="#3-8-出现了很多CLOSE-WAIT状态的连接？" class="headerlink" title="3.8 出现了很多CLOSE-WAIT状态的连接？"></a>3.8 出现了很多CLOSE-WAIT状态的连接？</h2><p>在上面提到过，当客户端向服务器发送FIN之后，服务器回复ACK，会进入<code>CLOSE-WAIT</code>状态。此时服务器还能给客户端发送消息，双方都还在维护连接的相关资源。</p><p>如果一个服务出现了很多个处于<code>CLOSE-WAIT</code>状态的连接，就必须要检查一下，应用层的代码里面是不是没有调用<code>close(fd)</code>函数来关闭对应的文件描述符。</p><blockquote><p>一方的<code>close(fd)</code>就对应了两次挥手，两端都进行<code>close(fd)</code>即四次挥手。</p></blockquote><p>对方明明都要和你分手了，你还挂着对方当备胎，还要找对方要钱，也太不像话了😂</p><h3 id="3-8-1-活学活用🤣"><a href="#3-8-1-活学活用🤣" class="headerlink" title="3.8.1 活学活用🤣"></a>3.8.1 活学活用🤣</h3><p>230322下午，正准备通过之前写的tcp代码来验证tcp握手和挥手的各个状态的，没想到用命令一看，全是CLOSE-WAIT状态，填满了整个屏幕，这完全没办法写博客啊</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641abf6b4b48b.png" alt="image-20230322164218824"></p><p>而且这些状态清一色来自<code>python3.10</code>的程序，看到它的时候，我已经基本猜到了是啥进程引发的了——我的<a target="_blank" rel="noopener" href="https://github.com/Valorant-Shop-CN/">两个valorant机器人</a>。查了查pid，坐实了这一点</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641abfb02da9d.png" alt="image-20230322164328076"></p><p>我将数据写入到一个文件里面，统计了一下，一共1200多个<code>CLOSE-WAIT</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntp &gt; <span class="built_in">log</span> <span class="comment"># 将统计结果写入文件log</span></span><br><span class="line">netstat -antp | grep CLOSE_WAIT <span class="comment"># 只统计CLOSE_WAIT状态的链接</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641abff36dad2.png" alt="image-20230322164435422"></p><p>这些状态值的远程ip来源虽然有多个，但一个ip出现了多次，于是我就使用 <a target="_blank" rel="noopener" href="https://www.itdog.cn/http/">itdog</a> 看了一下其中几个ip的来源，是<code>Anycast/cloudflare.com</code>，也就是很出名的cloudflare-cdn。</p><p>在我的kook-valorant-bot里面，有一项业务是方便开发者使用的valorant登录和商店查询的<strong>api</strong>（使用aiohttp库编写）</p><p>为了统计其上线状态，我使用了<code>uptimerobot</code>定时请求，每5分钟获取一次api的在线情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://stats.uptimerobot.com/Wl4KwU6Bzz</span><br></pre></td></tr></table></figure><p>嗯，运行状态倒是蛮好的，100%在线</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641ac0f123c14.png" alt="image-20230322164848818"></p><p>前面提到过，系统是需要消耗资源来维护tcp链接的。如下图，机器人占用了将近400mb的内存，其中肯定有一部分就是被这些没有关闭的tcp链接所占用的</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641ac1b16c065.png" alt="image-20230322165201221"></p><p>大量<code>CLOSE-WAIT</code>，只可能是一个原因：<code>uptimebot</code>的请求已经结束并发送了FIN，而我的api代码作为服务端，并没有在收到FIN后，对链接进行<code>close</code>，于是链接一直处于<code>CLOSE-WAIT</code>半关闭状态。只有程序关闭（机器人下线）才会被操作系统清空。</p><hr><p>后来又研究了一下，经过他人点醒，才发现上面的结论都是<strong>错的</strong>！！</p><blockquote><p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000043572705/a-1020000043573118">https://segmentfault.com/q/1010000043572705/a-1020000043573118</a></p></blockquote><p>其实在<code>netstat</code>里面很明显的一点，表示这一切和uptimebot以及我写的api没有任何关系</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e705375685.png" alt="image-20230325115349060"></p><p>那就是这里面<code>Local Address</code>的端口，每一个都是不一样的。如果是我写的api导致的，那么他们的端口都应该是api绑定的端口，且固定才对！</p><p>后来就找到了一个2014年的issue，大概情况就是，python的requests库会维护一个<strong>连接池</strong>（类似于线程池）。这些处于<code>close-wait</code>状态的连接，都是requests库维护的。并不是说他们是忘记关闭的链接。</p><p><a target="_blank" rel="noopener" href="https://github.com/psf/requests/issues/1973">https://github.com/psf/requests/issues/1973</a></p><p>好嘛，原来是自己学艺不精，闹了个大笑话。当时找处理aiohttp的web状态的资料找了老半天都没找到……原来一开始方向就错了😶‍🌫️</p><h2 id="3-9-异常情况"><a href="#3-9-异常情况" class="headerlink" title="3.9 异常情况"></a>3.9 异常情况</h2><ul><li>进程终止：进程终止会释放文件描述符，仍然可以发送FIN。和正常关闭没有什么区别</li><li>机器重启&#x2F;关机：和进程终止的情况相同，<strong>操作系统会在重启&#x2F;关机前</strong>释放TCP文件描述符。</li><li>机器断电&#x2F;网络断开：接收端认为连接还在，一旦接收端有写入操作，接收端发现连接已经不在了，就会进行<code>reset</code>。即使接收端没有写入操作，TCP内置了一个保活定时器，会定期询问对方是否还在。如果对方不在，也会把连接释放。</li></ul><p>除了TCP本身，应用层的某些协议，也会有这样的重连检测机制。</p><h2 id="3-10-校验和"><a href="#3-10-校验和" class="headerlink" title="3.10 校验和"></a>3.10 校验和</h2><blockquote><p>这部分并不是重点。</p></blockquote><p>校验和能保证TCP双方发送的数据不会出现数据对不上的问题</p><p>校验和是一种简单的数据验证机制，它通过对数据进行数学运算得到一个校验值，并将该校验值与原始数据一起传输。接收方收到数据后，会再次计算数据的校验和，并将结果与传输过来的校验值进行比较。如果两个校验和相匹配，那么说明数据在传输过程中没有发生错误或损坏。但如果校验和不匹配，接收方会认为数据发生了错误或损坏，于是会请求发送方重新传输数据。</p><p>TCP在数据包的头部添加了一个16位的校验和字段，该字段包含了数据段的校验和值。在发送端，TCP将数据段中的所有字节（包括TCP头部和数据部分）加起来，然后取其反码作为校验和。接收端也采用同样的方式计算校验和，并与接收到的校验和进行比较，以验证数据的完整性。</p><blockquote><p>举个简单的栗子，我们可以把发送的数据体当作一个字符串，对其进行MD5计算，再将计算后的MD5同数据体一同发送给对方。这时候接受方收到信息后，同样进行相同算法的MD5计算，得出来的MD5和对方发送过来的MD5进行对比，如果相同，代表数据没有问题。不相同代表数据发送错误，该数据包被丢弃。</p><p>如果发送的MD5在传输过程中出现了损坏，那么最终计算出来的MD5字符串依旧是不相同的，也会当作无效报文被丢弃;</p><p>实际TCP使用的并不是MD5，上面的这个栗子只是为了方便理解。</p></blockquote><p><strong>校验和</strong>不仅用于TCP协议，在许多其他协议中也有类似的机制，用于确保数据传输的可靠性。</p><p>通过使用校验和，网络协议可以帮助确保数据在传输过程中不会因为噪声、干扰或其他错误而变得损坏。然而，需要注意的是，校验和并不能提供绝对的数据完整性保证，<strong>因为一些复杂的错误模式可能会导致校验和匹配</strong>，但数据仍然损坏。</p><p>为了进一步增强数据的可靠性，TCP协议还使用了序列号（按序到达）、确认应答（确认收到）和超时重传（避免丢包）等机制。</p><h2 id="3-11-TCP保活计数器"><a href="#3-11-TCP保活计数器" class="headerlink" title="3.11 TCP保活计数器"></a>3.11 TCP保活计数器</h2><p>为了避免TCP单端发生故障，TCP内会有一个连接保活计数器。</p><p>当保活计时器的周期内，没收到TCP发来的数据，那么保活计数器结束后，TCP服务器就会发送探测报文段，判断客户端是否还存在。如果连续发送10个探测报文还没有收到TCP客户端的响应，则认为客户端断连，服务器关闭连接。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0a67cb31ebc9a3ef59c095c228a90200.png" alt="image-20231221144600987"></p><h1 id="4-验证TCP状态"><a href="#4-验证TCP状态" class="headerlink" title="4.验证TCP状态"></a>4.验证TCP状态</h1><p>下面可以用代码来实地查看tcp在传输过程中的各种状态。之前写过一个<a target="_blank" rel="noopener" href="https://gitee.com/musnow/raspberry-practice/blob/f3fb8669cd32b1ed2cc0a869ea6c05d070baa2c2/code/23-02-15_http/tcpServer.cpp">简单的http服务器</a>，现在为了方便，直接拿来使用。</p><p>采用如下bash命令来进行netstat的循环监测</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :; <span class="keyword">do</span> netstat -ntp | grep 端口号;<span class="built_in">sleep</span> 1; <span class="built_in">echo</span> <span class="string">&quot;########################&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="4-1-TIME-WAIT"><a href="#4-1-TIME-WAIT" class="headerlink" title="4.1 TIME-WAIT"></a>4.1 TIME-WAIT</h2><p>在浏览器访问，可以看到服务器返回的html页面</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e730913703.png" alt="image-20230325120528729"></p><p>后台可以看到，服务器接收到了请求的报头</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e75084bbf3.png" alt="image-20230325121400802"></p><p>并按如下返回<code>response</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEBUG | 1679717397 | muxue | [sockfd: 4] filePath: web/index.html</span><br><span class="line">######### response header ##########</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 362</span><br><span class="line">Set-Cookie: This is my cookie test</span><br><span class="line"></span><br><span class="line">######### response end ##########</span><br></pre></td></tr></table></figure><p>使用<code>netstat</code>命令查看，当前多出了一个处于<code>time wait</code>状态的连接</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e7529b2ec4.png" alt="image-20230325121434464"></p><p>这代表四次挥手的第一个FIN是由服务器发出的，这一点在代码中也能体现，服务器accpet到连接后，会交由孙子进程来执行<code>handlerHttpRequest(conet)</code>服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供服务（孙子进程）</span></span><br><span class="line"><span class="type">pid_t</span> id = fork();</span><br><span class="line"><span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(_listenSock);<span class="comment">//因为子进程不需要监听，所以关闭掉监听socket</span></span><br><span class="line">    <span class="comment">//又创建一个子进程，大于0代表是父进程，即创建完子进程后父进程直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(fork()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程推出后，子进程被操作系统接管</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 孙子进程执行</span></span><br><span class="line">    <span class="built_in">handlerHttpRequest</span>(conet);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 爷爷进程</span></span><br><span class="line"><span class="built_in">close</span>(conet); <span class="comment">//这个close并不会影响孙子进程内部的，因为有写时拷贝</span></span><br><span class="line"><span class="type">pid_t</span> ret = <span class="built_in">waitpid</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>); <span class="comment">//此时就可以直接用阻塞式等待了</span></span><br><span class="line"><span class="built_in">assert</span>(ret &gt; <span class="number">0</span>);<span class="comment">//ret如果不大于0，则代表等待发生了错误</span></span><br></pre></td></tr></table></figure><p>这个服务函数并不是<code>while(1)</code>的死循环，内部也没有进行socket的close操作，而是发送完毕客户端请求的文件后，直接退出了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">handlerHttpRequest</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt;     <span class="string">&quot;########### header-start ##########&quot;</span> &lt;&lt; endl;<span class="comment">//打印一个分隔线</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10240</span>];</span><br><span class="line">    <span class="type">ssize_t</span> s = <span class="built_in">read</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;########### header-end   ##########&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    string path = <span class="built_in">getPath</span>(buffer);</span><br><span class="line">    <span class="comment">// 假设用户请求的是 /a/b 路径</span></span><br><span class="line">    <span class="comment">// 那么服务端处理的时候，就需要添加根目录位置和默认的文件名</span></span><br><span class="line">    <span class="comment">// &lt;root&gt;/a/b/index.html</span></span><br><span class="line">    <span class="comment">// 在本次用例中，根目录为 ./web文件夹，所以完整的文件路径应该是</span></span><br><span class="line">    <span class="comment">// ./web/a/b/index.html</span></span><br><span class="line"></span><br><span class="line">    string resources = ROOT_PATH; <span class="comment">// 根目录路径</span></span><br><span class="line">    resources += path; <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="built_in">logging</span>(DEBUG,<span class="string">&quot;[sockfd: %d] filePath: %s&quot;</span>,sock,resources.<span class="built_in">c_str</span>()); <span class="comment">// 打印用作debug</span></span><br><span class="line"></span><br><span class="line">    string html = <span class="built_in">readFile</span>(resources);<span class="comment">// 打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始响应</span></span><br><span class="line">    string response = <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;</span><br><span class="line">    <span class="comment">//如果readFile返回的是404，代表文件路径不存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(html.<span class="built_in">c_str</span>(),<span class="string">&quot;404&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.0 404 NOT FOUND\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加后续字段</span></span><br><span class="line">    response += <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>;</span><br><span class="line">    response += (<span class="string">&quot;Content-Length: &quot;</span> + <span class="built_in">to_string</span>(html.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    response += <span class="string">&quot;Set-Cookie: This is my cookie test\r\n&quot;</span>;</span><br><span class="line">    response += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;######### response header ##########\n&quot;</span> &lt;&lt; response &lt;&lt; <span class="string">&quot;######### response end ##########\n&quot;</span>;</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    response += html;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送给用户</span></span><br><span class="line">    <span class="built_in">send</span>(sock, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数退出了之后，文件描述符就交由了操作系统。一个没有进程使用的文件描述符，会被操作系统直接close关掉。相当于<strong>操作系统</strong>帮我们发出了FIN，就出现了<code>TIME WAIT</code>状态。</p><h3 id="4-1-1-为啥要有这个状态？"><a href="#4-1-1-为啥要有这个状态？" class="headerlink" title="4.1.1 为啥要有这个状态？"></a>4.1.1 为啥要有这个状态？</h3><p>知道了4次挥手的过程后，我们就能知道，<code>TIME-WAIT</code>是4次挥手的<strong>发起方</strong>才有的状态。</p><p>既然对方已经给我发了FIN，这不就代表对方也想和我分手吗？那我为啥还留着好友不删，非要等等呢？</p><p>这是因为，我们发出的最后一次ACK是否被对方收到，是未知的！</p><ul><li>A给B发送最后一次ACK，B没有收到</li><li>A不TIME-WAIT直接退出，A已经断开连接了，但是B还在维护这个连接</li><li>如果有TIME-WAIT状态，B没有收到ACK，会对FIN进行超时重传</li><li>A再次收到FIN，代表上一次ACK丢了，那就再次发送ACK</li><li>如果A在<code>TIME-WAIT</code>状态什么信息都没有收到，那就代表自己的ACK被B收到了，便可以放心断连</li></ul><p>此时，<code>TIME-WAIT</code>状态保证了最后一次ACK的正常递达</p><p>还有第二种情况：</p><ul><li>C给S发送FIN，准备断连</li><li>S给C发送data，发送完毕后，立马发送FIN</li><li>data和FIN都在路由传输的过程，可能会出现FIN比data早到的情况</li><li>C收到FIN，返回ACK，进入<code>TIME-WAIT</code>状态，期间收到了S发送的data</li><li>C成功接收data，继续等待到计时器结束，释放链接</li></ul><p>此时，TIME-WAIT状态保证了二者之间的消息能都被收到</p><h3 id="4-1-2-等多久？"><a href="#4-1-2-等多久？" class="headerlink" title="4.1.2 等多久？"></a>4.1.2 等多久？</h3><p>这里引入一个新概念：一个报文在双方之间传输花费的时间，被称为这个消息的 MSL（maximun segment lifetime 最大生存时间）</p><p>TIME-WAIT等待的时间需要适中，不同的操作系统，默认等待的时间都是不同的。CentOS下，这个时间是60s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/ipv4/tcp_fin_timeout</span><br><span class="line">60</span><br></pre></td></tr></table></figure><p>一般情况下，设置为<code>MSL*2</code>是最好的，这样能保证双方数据的递达，和最后ACK的递达</p><h2 id="4-2-CLOSE-WAIT"><a href="#4-2-CLOSE-WAIT" class="headerlink" title="4.2 CLOSE-WAIT"></a>4.2 CLOSE-WAIT</h2><p>如果我们在<code>handlerHttpRequest(conet);</code>向客户端发送了html文件后，服务端休眠几秒钟；客户端打开网页后关闭网页，是否就能看到其他状态呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送给用户</span></span><br><span class="line">send(sock, response.c_str(), response.size(), <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 休眠几秒钟作为测试</span></span><br><span class="line">sleep(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>如下，情况又不同了。这次出现的是<code>CLOSE-WAIT</code>状态，代表第一个FIN请求是客户端发出的</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e78f5d0133.png"></p><p>这是因为当前的进程没有进行<code>长链接</code>的维护，如果想维护长连接，则服务器应该给客户也返回一个http协议报头 <code>Connection: keep-alive</code></p><p>如下图，可以看到客户端发来的<code>http-header</code>里面，是有该字段的。而服务器并没有返回相同的字段，客户端就认为服务器不支持长链接，从而主动发出了<code>FIN</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e7981d948c.png" alt="image-20230325123306633"></p><p>进一步看tcp的状态，当前是有两个父进程为1（采用了孙子进程的写法，父进程退出后会被操作系统接管）的进程在进行休眠，它们同属于<code>295942</code>这个tcp服务器主进程的进程组（<code>PGID</code>相同）</p><p>当这两个进程结束休眠的时候，<code>CLOSE-WAIT</code>状态的连接立马消失了。因为操作系统接管了文件描述符后，进行了close，服务端也发出了fin，四次挥手成功，连接终止。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e78f5d0133.png"></p><h2 id="4-3-ESTABLISHED"><a href="#4-3-ESTABLISHED" class="headerlink" title="4.3 ESTABLISHED"></a>4.3 ESTABLISHED</h2><p>如果我们给response加上长链接的报头，是否可以看到<code>ESTABLISHED</code>状态呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response += <span class="string">&quot;Connection: keep-alive\r\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以看到，确实出现了这个状态，这代表双方成功维护起了长链接（虽然当前情况下，这个长链接并没有起到应有的作用）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e7de86ad76.png" alt="image-20230325125153006"></p><p>进一步轮换，将处理函数改为<code>while(1)</code>的死循环调用，我们应该可以通过一个socket实现多个报文的发送</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孙子进程执行</span></span><br><span class="line">logging(DEBUG, <span class="string">&quot;new child process&quot;</span>);<span class="comment">//打印一个新进程的提示信息，方便观察结果</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    handlerHttpRequest(conet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只出现了一个子进程，对客户端进行服务</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e7f2a9b670.png" alt="image-20230325125715102"></p><p>查看日志，能看到，成功实现了长链接通信</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e7ff8ac7fc.png" alt="image-20230325130041133"></p><p>如果不采用<code>while(1)</code>死循环进行服务，则客户端的每一次请求，都需要一个新的子进程来服务</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e8197ea194.png" alt="image-20230325130736659"></p><p>即便response中带有长链接标识，也会因为fd被操作系统回收而进入<code>TIME-WAIT</code>状态</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e8132ba5d3.png" alt="image-20230325130555495"></p><h2 id="4-4-端口不能被bind"><a href="#4-4-端口不能被bind" class="headerlink" title="4.4 端口不能被bind"></a>4.4 端口不能被bind</h2><p>之前在tcp服务器的学习中，出现了如果立马把tcp服务器关了后开，同一个端口无法被bind的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./tcpServer 50000 &gt; log</span><br><span class="line">FATAL | 1679720482 | muxue | bind: Address already in use:3</span><br><span class="line">$ ./tcpServer 50000 &gt; log</span><br><span class="line">FATAL | 1679720491 | muxue | bind: Address already in use:3</span><br></pre></td></tr></table></figure><p>经过对tcp协议的学习，现在能知道为何这个端口不能被bind了。使用<code>netstat -ntp</code>命令查看，能看到这个端口上还有处于<code>TIME-WAIT</code>状态的链接，所以系统认为这个端口上还有tcp链接在运行，<strong>不允许</strong>我们二次bind这个端口。这是操作系统在默认状态下的行为。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e80825f8aa.png" alt="image-20230325130259120"></p><p>前面提到过，centos默认的<code>TIME-WAIT</code>等待时间是60s。只要等待60s，操作系统释放了这个端口上的冗余链接，就能被bind了！</p><p>但是，这样会有很大的问题！请接着往下看</p><h3 id="4-4-1-问题"><a href="#4-4-1-问题" class="headerlink" title="4.4.1 问题"></a>4.4.1 问题</h3><p>假设我现在的服务器进程是直接<code>bind 80</code>端口对外进行服务的，这样他人就能直接通过我服务器的ip，以http协议与我的<strong>服务进程</strong>进行通信。</p><p>以http网页服务为例，经过了很久很久的运行时间</p><ul><li>服务器进程出了恶性bug，导致进程退出了</li><li>服务器压力过大，操作系统为了释放资源，直接把服务进程给kill了</li></ul><p>这时候，由于第一个FIN是由服务端发出的，服务器会进入<code>TIME-WAIT</code>状态。</p><p>假设<strong>服务进程</strong>崩溃的时候，有数个用户正在访问你的网页。对于他们而言，崩溃的表现就是，刷新网页，<strong>直接白屏</strong>，显示不出来后续的页面了。</p><p>此时就需要运维老哥赶快ssh连上服务器，重启<strong>服务进程</strong></p><p>为了关照运维老哥的头发，让出错的服务进程快速重启，一般情况下，我们会给这个服务进程增加一个监视进程</p><ul><li>监视进程是个死循环，其要做的功能很单一，所以负载并不大</li><li>监视进程实时查看，每几秒就看一眼服务进程的状态</li><li>服务进程挂掉了，监视进程在下一轮监视时会立马发现，通过 <a href="https://blog.musnow.top/posts/2395550697/#4-3-execl">exec系列函数</a> 直接重启服务进程</li></ul><p>这时候，<code>TIME-WAIT</code>的问题就出现了：服务进程想绑定的是80端口，也只能绑定80端口（不然客户端无法知道服务器端口改变，也依旧无法访问服务）但是80端口还有没有清理的tcp链接，操作不给你bind啊！</p><p>如果等操作系统60s后清除链接再bind，那也太晚了🙅‍♀️</p><p>大型服务进程启动时要干的活很多，所以启动会较慢。等待系统释放<code>TIME-WAIT</code>的链接后再bind，相当于多给服务进程启动增加了60s</p><ul><li>对于一些客户量级巨大的服务，时间就是生命呀！</li><li>用户的耐心都不咋地，拿我自己举栗子吧！当我去访问一些网站时，如果<code>5s</code>之内网页没有加载出来，我就准备x掉那个网页了</li></ul><p>所以，为了避免由于<code>TIME-WAIT/CLOSE-WAIT</code>未释放而无法bind端口的问题，操作系统提供了<strong>端口复用</strong>的接口。让进程可以忽略冗余连接，直接bind这个端口！</p><h3 id="4-4-2-端口复用"><a href="#4-4-2-端口复用" class="headerlink" title="4.4.2 端口复用"></a>4.4.2 端口复用</h3><p>端口复用，复用的是有<code>TIME-WAIT/CLOSE-WAIT</code>这种冗余链接的端口，而不是处于服务状态的端口哈！一个端口只能对应一个服务，老规矩可不能破坏了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，端口有冗余链接，无法bind</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e8992278ab.png" alt="image-20230325134139050"></p><p>只需要在bind函数之前添加上如下代码，就能实现端口复用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1 允许端口被复用（即便还有TIME-WAIT的链接）</span></span><br><span class="line"><span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">setsockopt(_listenSock, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br></pre></td></tr></table></figure><p>如下图，即便50000端口存在<code>time-wait</code>的链接，我们依旧可以正常bind这个端口！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641e89e075269.png" alt="image-20230325134257205"></p><p>除了这种形式的端口复用，其实还有一个<code>SO_REUSEPORT</code>，它允许多个进程绑定同一个的端口；在nginx中就是采用这样的方式，让多个worker线程进行链接的竞争的。</p><h2 id="4-5-accpet不影响tcp"><a href="#4-5-accpet不影响tcp" class="headerlink" title="4.5 accpet不影响tcp"></a>4.5 accpet不影响tcp</h2><p>linux给我们提供的接口accpt，并不参与3次握手的阶段</p><p>将http服务的accpet给去掉，来观察这一情况。如下图，服务器直接是一个啥事不干的死循环，不对新来的连接进行<code>accept</code>，此时浏览器访问该服务，依旧会出现两个处于<code>ESTABLISHED</code>的连接</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641fff6bbcb20.png" alt="image-20230326161637486"></p><p>这便证实了我们的结论：accpet不参与tcp3次握手的过程</p><h2 id="4-6-listen的第二个参数"><a href="#4-6-listen的第二个参数" class="headerlink" title="4.6 listen的第二个参数"></a>4.6 listen的第二个参数</h2><h3 id="4-6-1-概念"><a href="#4-6-1-概念" class="headerlink" title="4.6.1 概念"></a>4.6.1 概念</h3><p>之前学习<a href="https://blog.musnow.top/posts/2171263616/">tcp服务器写法</a>的时候，粗略提到了listen函数第二个参数的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//backlog参数限制了能被阻塞等待连接的数量</span></span><br><span class="line"><span class="comment">//如果超过这个数量，则会返回一个ECONNREFUSED错误。亦或者如果协议支持重传，多余的请求会被忽略，后续可以重传</span></span><br></pre></td></tr></table></figure><p>这里的阻塞等待连接是什么意思？还是用前面用到的http服务，以实际情况来看看</p><ul><li>什么情况下，一个连接会被阻塞？</li></ul><p>这一点就涉及到服务器的承受能力了。假设服务器现在很忙，压根没时间去<code>accept</code>一个新的连接，那这个连接就一直存在操作系统的tcp连接中，<strong>而没有进程对它服务</strong>。这种状态，就可以被称为连接的<strong>阻塞等待</strong></p><h3 id="4-6-2-看看具体情况"><a href="#4-6-2-看看具体情况" class="headerlink" title="4.6.2 看看具体情况"></a>4.6.2 看看具体情况</h3><p>假设我将listen的第二个参数设置为了2，服务器是个啥事不干的死循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(_listenSock, <span class="number">2</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logging</span>(FATAL, <span class="string">&quot;listen: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">exit</span>(LISTEN_ERR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器内直接开5个窗口请求这个连接，加上我的手机，一共是6个请求</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6420011b1f157.png" alt="image-20230326162356252"></p><p>但后台可以看到，再继续增加浏览器请求的数量，依旧都只有两个连接是处于<code>ESTABLISHED</code>状态，和listen的第二个参数正好相同！这两个连接因为没有被服务进程<code>accept</code>，它们就是处于阻塞等待状态的！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/64200113b694e.png" alt="image-20230326162348693"></p><h3 id="4-6-3-为什么？"><a href="#4-6-3-为什么？" class="headerlink" title="4.6.3 为什么？"></a>4.6.3 为什么？</h3><p>为什么操作系统要给一个进程维护<strong>阻塞等待</strong>的连接呢？既然这个进程不进行新连接的accept，操作系统为何不直接把这个连接丢弃呢？</p><p>拿生活中非常场景的<code>餐厅排队</code>举例子吧。大家应该都见过一个餐馆在中晚餐高峰期时，门口有人在排队等位吧？特别是<del>河</del>海底捞，每次想去都得提前预定，不然排队的时间吃门口的小零食都要吃饱了。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6420040c2a47d.png" alt="image-20230326163628670"></p><p>那么，餐馆为什么要提供排队等位呢？为何服务员不直接告诉新来的客人，馆子里没空位了，请另寻他处呢？</p><ul><li>原因很简单：为了上桌率。</li></ul><p><strong>一个餐馆的上桌率越高，就代表其生意越好</strong>。如果餐馆内部没桌了，但是外头有人排队，这样就能让有客人离开（空出桌子后）立马有新的客人上桌。</p><ul><li>对于我们的服务进程也是一样！</li></ul><p>假设这个服务进程有10个线程对外进行服务，此时来了第11位需要服务的客人。服务的10个线程（桌子）都被坐满了，没人能给11号客人服务。那这时候，操作系统就告诉11位客人：“你在这里稍作等待，我去给你<del>买个橘子</del>取个排队单号”，这时候11号客人就在操作系统为服务进程提供的等候位置上坐了下来，等待服务进程腾出空位来给他服务（链接阻塞等待）</p><p>这时候，有一个用户断开了连接，空出来了一个进程，那么服务进程（餐馆）内的服务员就跑出来，和11号客户说，他可以上桌了（accept）这时候，服务进程就开始给11号客户提供服务了。</p><p>这样一来，只要服务进程有空闲，就能立马有新的进程入座，让服务进程<strong>不至于摸鱼</strong>。提高了服务器资源的利用效率。</p><p>我买了一个服务器，我肯定是希望它在不崩溃的前提下<strong>为越多客户服务越好</strong>，资源最大化嘛！</p><h3 id="4-6-4-该参数应该设置成多少？"><a href="#4-6-4-该参数应该设置成多少？" class="headerlink" title="4.6.4 该参数应该设置成多少？"></a>4.6.4 该参数应该设置成多少？</h3><p>既然我们已经知道了这个参数的作用，那么应该把它设置为多少呢？</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/642007ef3e094.png" alt="image-20230326165304255"></p><p>餐馆也需要面临这个问题</p><ul><li>如果自己设置的排队等位太少，那么可能会有想排队的客户没有位置坐。</li><li>如果设置的太多，那新来的客户压根不打算排队了，因为他们知道，轮到自己的时候，已经饿扁了。</li></ul><p>服务器也是如此</p><ul><li>第二个参数设置的低了，排队的空位太少，超过该参数的链接直接被os拒绝，错过了本来可以提供服务的用户</li><li>第二个参数设置的高了，用户过来排队，等了好久都没等到，于是就报错<code>连接超时</code>了。</li><li>而且，打开一个网页的响应速度，也会直接影响用户对你的服务的满意度。每次点开你的网页都需要加载个十几秒的，久而久之，用的人只会越来越少！</li><li>设置的太高了，维护的连接也会占用系统资源，服务进程可用资源变少了！</li><li>与其增长队列，还不如增加服务进程的服务能力（扩大店面）</li></ul><p>所以，我们应该根据自己服务的面向用户数量级，设置一个合适的等位数量！这个应该根据具体情况来看的！</p><h3 id="4-6-5-listen和accept"><a href="#4-6-5-listen和accept" class="headerlink" title="4.6.5 listen和accept"></a>4.6.5 listen和accept</h3><p>如下图，我让服务进程只对一个链接进行accept，相当于餐厅里面只有两张桌子。此时新来的链接就会处于等待状态，数量正好是<code>listen</code>的第二个参数（但是我的第二个参数是2，我也不知道为啥会是3个🤣）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/6420098c95af5.png" alt="image-20230326165957731"></p><h1 id="5-滑动窗口（可靠传输）"><a href="#5-滑动窗口（可靠传输）" class="headerlink" title="5.滑动窗口（可靠传输）"></a>5.滑动窗口（可靠传输）</h1><p>tcp中引入了<strong>滑动窗口</strong>的操作来实现可靠传输</p><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><p>在实际通信中，如果真的只是让双方一发一答，那效率也太低了。所以，一般都是直接一次性发送多条消息，对方也是对多条报文进行ACK的，而且只需要ACK一次（这点在前面序号部分已经讲过原理了）</p><ul><li>一次性可以发送多条报文，但前提是对方有能力收那么多</li><li>窗口大小：一次性可以发送的数据数量（无需等待前面已发报文的ACK，就可以发送这么多）<ul><li>窗口大小是由<strong>对方的接收能力</strong>决定的</li><li>tcp报头中，<strong>16位窗口大小</strong>就是滑动窗口的大小</li><li>S给C所发报头中的窗口大小，既代表S接收缓冲区的大小，又代表C可以一次发送的数据大小</li><li>S接收缓冲区的大小变化，也会导致S给C所发报文中，窗口大小的变化</li></ul></li><li>窗口越大，代表双方通信的<strong>吞吐率</strong>就越大</li><li>发送的数据会保留在发送缓冲区中，发送缓冲区以如下区域构成<ul><li>已发，收到了ACK的报文（可删）</li><li>已发，未收到ACK的报文</li><li>未发，准备发送的报文</li></ul></li></ul><h2 id="5-2-滑动窗口示意图"><a href="#5-2-滑动窗口示意图" class="headerlink" title="5.2 滑动窗口示意图"></a>5.2 滑动窗口示意图</h2><p>滑动窗口可以用下图来形象的理解，对图中的文字就不复述了（如果图片404了请及时告知我，谢谢）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/64203f7797844.png" alt="image-20230326204959886"></p><p>咳咳，本人字丑，用pad写就更丑了，请谅解</p><h2 id="5-3-总结和习题"><a href="#5-3-总结和习题" class="headerlink" title="5.3 总结和习题"></a>5.3 总结和习题</h2><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/af161c4e3650a97d512937a0c801f1fc.png" alt="image.png"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b233be769e45e9b7164656f5c525853c.png" alt="image.png"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/31950cb085eeac94ec33cba3c26bf8cf.png" alt="image.png"></p><h1 id="6-流量控制"><a href="#6-流量控制" class="headerlink" title="6.流量控制"></a>6.流量控制</h1><h2 id="6-1-流量控制基本概念"><a href="#6-1-流量控制基本概念" class="headerlink" title="6.1 流量控制基本概念"></a>6.1 流量控制基本概念</h2><p>所谓流量控制，就是发送方根据对方的接收能力来选择发送数据的多少，让发送方发送速率别太快。</p><p>如果B的接收缓冲区满了，会通过报文中的<strong>窗口大小</strong>告知A，A不再继续发送数据。</p><p>此时，A会在过一会后，向B发送一个<code>窗口探测</code>报文，该报文没有有效载荷，所以不会过多占用接收缓冲区；</p><p>B在收到该报文后，会回应报文，告知A自己的窗口大小，被称为<code>窗口更新</code></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/64203fc18dba2.png" alt="image-20230326205114217"></p><h2 id="6-2-流量控制举例"><a href="#6-2-流量控制举例" class="headerlink" title="6.2 流量控制举例"></a>6.2 流量控制举例</h2><p>下图是一个更加详细的过程，A和B建立TCP连接后，开始发送数据。假设起始的接收窗口为400字节，前两次通信正常， 但是A发送201~300的数据时，出现了丢包。</p><p>B端收到1到200的数据后，发送了ACK&#x3D;201的报文，并在该报文中设置rwnd&#x3D;300，即告诉A，B的接收窗口只有300字节，要求A更新发送窗口的值。</p><p>A收到这个报文后，能得到两个信息</p><ul><li>201以前的报文（1到200）都被B成功收到了，但201到300的报文还没有收到</li><li>需要将自己的发送窗口调整为300字节。</li></ul><p>随后，A先根据自己的发送策略，将301到400和401到500发送出去，此时发送窗口已满，不能继续发送！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f3638bc8b72648164d116e460f7b94b0.png" alt="image.png"></p><p>过了一会，A发送还没有收到对201到300这个报文的确认，重传计时器超时，触发对201和300的超时重传。由于发送窗口依旧是满的，所以A只能进行重传，不能发送新的数据。</p><p>B收到重传的报文后，对501之前的报文进行累计确认，并更新B自己的接受窗口大小为100字节，对A主机再次进行流控。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/23376478cea43e6bf88e1e0c58e25db9.png" alt="image.png"></p><p>此时A就能更新自己的滑动窗口到501字节之后，同时将发送窗口缩短到100字节。A只能发送501到600的数据，就需要等待B的确认。</p><p>假设B收到501到600后，又对A进行了第三次流量控制，将rwnd设置为0。此时A可以将滑动窗口移动到601的位置，601之前的数据可以被删除。但由于B的接收窗口为0，A需要更新自己的发送窗口为0，此时A不能发送任何数据。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b7792539d108afc2c15acf0105285f6f.png" alt="image.png"></p><h2 id="6-3-持续计时器"><a href="#6-3-持续计时器" class="headerlink" title="6.3 持续计时器"></a>6.3 持续计时器</h2><p>上面例子最后，A的发送窗口被设置为了0。此时就需要一个<strong>持续计时器</strong>的介入。</p><p>假设B过了一段时间再次发送了一个窗口更新报文，将rwnd设置为300，但是该报文丢包了。这时候A和B就会进入一个很尬尴的局面，即B在等待A发送数据，A在等待B更新rwnd，双方谁都没有办法继续发送数据。即出现<strong>死锁</strong>。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/3c47e6e8f5eefb7c113f791a15f91979.png" alt="image.png"></p><p>持续计数器会在一端的<strong>发送窗口</strong>被置为0的时候介入：A过了一段时间后，如果还没有收到窗口更新报文，则会发送一个<strong>零窗口探测报文</strong>（携带1字节数据）。B收到这个<strong>零窗口探测报文</strong>后，需要发送一个响应，并携带新的rwnd值。</p><p>这个步骤会被一直重复，直到A收到一个rwnd不为0的报文后，将自己的发送窗口大小更新，开始继续发送数据。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/1aff0270ac3a6168cd6b1a9774345e27.png" alt="image.png"></p><p>如果这个零窗口探测报文也丢失了会咋样？不用担心，接收方需要对零窗口探测报文进行ACK，发送方一直没有收到ACK，会触发<strong>超时重传</strong>机制。</p><h2 id="6-4-发送窗口例题"><a href="#6-4-发送窗口例题" class="headerlink" title="6.4 发送窗口例题"></a>6.4 发送窗口例题</h2><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/760b56b0a89a64543eb7b6decf66206e.png" alt="image.png"></p><h1 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7.拥塞控制"></a>7.拥塞控制</h1><p>前面提到的tcp处理措施，都是为了保证通信<strong>双方的主机</strong>不会出什么错误，导致数据的丢失。</p><p>但是一直么有提到一点：<strong>网络出错</strong>了咋办？</p><blockquote><p>你和对方打电话，结果电线都断了，那还咋电话呢？</p></blockquote><p>为了避免通信给网络造成太大的负担，tcp除了考虑对方的接受能力以外，还需要考虑网络的承载能力。</p><h2 id="7-1-如何确认网络出问题？"><a href="#7-1-如何确认网络出问题？" class="headerlink" title="7.1 如何确认网络出问题？"></a>7.1 如何确认网络出问题？</h2><p>如果双方通信的时候，出现了丢包，我们真的能确认网络出现问题了吗？</p><ul><li>答案是否定的。</li></ul><p>你和朋友之间打电话，突然对方的声音卡了一下，你就能下结论，是的电话线断了吗？</p><ul><li>实际上，只有<strong>你完全听不到对方声音</strong>了，又确认双方的手机都没有问题，才能认为是通信出了问题。</li></ul><p>网络也是一样，只有出现<code>大面积丢包</code>，才能认为是网络出了问题。当网络中的某一资源的要求超过了该资源能提供的部分，网络性能就会变坏，这种情况就叫做<strong>拥塞</strong>。</p><p>我们知道，tcp基于字节流，一次性可以发送大量的信息。要是一个进程的tcp连接一建立，就开始往网络里面<strong>塞一大堆的信息</strong>，把网络给整堵塞了，那好吗？</p><p>一个进程这么干，那多几个进程加入，网络直接雪上加霜。卡死了，谁都别想用！因此，如果出现了拥塞还不对连接进行控制，整个网络的吞吐量会随着输入载荷的扩大而不断下降。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6cbaa76469a9f4b3ca5c3df94f7dca80.png" alt="image.png"></p><h3 id="7-1-1-TCP提供的拥塞控制策略"><a href="#7-1-1-TCP提供的拥塞控制策略" class="headerlink" title="7.1.1 TCP提供的拥塞控制策略"></a>7.1.1 TCP提供的拥塞控制策略</h3><p>为了解决网络拥塞问题，TCP提供了四个步骤：慢开始、拥塞避免、快重传、快恢复。</p><p>下面将依次介绍这四个步骤的原理，并在如下假定条件下进行</p><ul><li>数据单方向传送，另外一方只发送确认</li><li>接收方总是有足够大的缓存空间，发送方的窗口大小只由网络拥塞程度来决定</li><li>以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。</li></ul><p>为了实现这些机制，发送方需要维护一个<strong>cwnd拥塞窗口</strong>字段，用于约束自己的发送。该值取决于网络的拥塞程度，并会动态变化。</p><ul><li>拥塞窗口维护原则：只要网络没有出现拥塞，拥塞窗口就会增大。网络出现拥塞，拥塞窗口减少</li><li>判断出现网络拥塞的依据：没有按时收到应当到达的确认报文</li></ul><p>发送方会将拥塞窗口cwnd作为发送窗口swnd，即swnd&#x3D;cwnd。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/03/641a57740be43.png" alt="image-20230724092314419"></p><h2 id="7-2-慢启动和拥塞避免"><a href="#7-2-慢启动和拥塞避免" class="headerlink" title="7.2 慢启动和拥塞避免"></a>7.2 慢启动和拥塞避免</h2><p>TCP添加了<strong>慢启动</strong>机制。说白了就是：刚开始发送的少，逐渐增多！</p><p>为了实现慢启动，TCP还需要维护一个<strong>慢开始门限ssthresh</strong>状态变量：</p><ul><li>当cwnd &lt; ssthresh时，采用慢开始算法；</li><li>当cwnd &gt; ssthresh时，停止使用慢开始算法，而改用拥塞避免算法；</li><li>当cwnd &#x3D; ssthresh时，既可以使用慢开始，又可以使用拥塞避免算法。</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/80d15cbbcea75d3da1bdf035f1e8f7d2.png" alt="image-20230724092314418"></p><p>整个过程如下：</p><ul><li>拥塞窗口从<strong>一个段</strong>的大小开始（约1KB），可以理解为从1开始</li><li>拥塞窗口有一个阈值<code>ssthresh</code>，默认为对方的窗口大小，这在3次挥手的时候已经确定了；</li><li>收到<strong>一次</strong>ACK，且<code>拥塞窗口&lt;阈值ssthresh</code>，直接将现有拥塞窗口大小加倍【指数增长】<ul><li>也可以理解为，<strong>一个ACK</strong>（注意是一个ACK，并非一个ACK报文）就加1；</li><li>比如第一次发送了1000个字节的消息，那么收到对方的ACK为1001后，直接将拥塞窗口大小加倍，此时为2000，下一次发送就发2000字节的消息；</li><li>拥塞窗口加倍的时候<strong>不能大于ssthresh</strong>，如果本次加倍会大于ssthresh，则只能增加到ssthresh并使用拥塞避免；</li></ul></li><li>收到ACK，<code>拥塞窗口&gt;=阈值ssthresh</code>，开始使用<strong>拥塞避免</strong>算法，窗口值+1【线性增长】</li></ul><p>如果出现了<strong>发送超时</strong>（重传计时器超时），发送方可能会认为网络拥塞，开始进行控制：</p><ul><li>阈值<code>ssthresh</code>设置为<code>拥塞窗口/2</code>；</li><li>拥塞窗口cwnd置为1（从头开始，避免大面积的重传）；</li><li>拥塞窗口cwnd始终小于接收端的接收窗口；</li><li>拥塞窗口重新开始慢开始，直到<code>拥塞窗口&gt;=阈值ssthresh</code>，开始使用拥塞避免算法，重复上述步骤。</li></ul><p>这便是慢启动和拥塞控制的机制，上面贴的图能形象的展示数据慢慢增长到指数级增长的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实际传输的数据大小 = min(拥塞窗口,对方接收窗口大小)</span><br><span class="line">Swnd = Min[Rwnd, Cwnd]</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/528b26d6a2036e43155e70ee3b78c4fe.png" alt="image.png"></p><h2 id="7-3-快重传（3ACK）"><a href="#7-3-快重传（3ACK）" class="headerlink" title="7.3 快重传（3ACK）"></a>7.3 快重传（3ACK）</h2><p>TCP快重传（Fast Retransmit）是TCP协议中的一种拥塞控制机制，用于加快数据包的重传，以减少数据传输的延迟和提高网络性能。</p><p>在TCP协议中，当发送方发送数据包到接收方后，会启动一个<strong>定时器</strong>，等待接收方发送确认应答（ACK）回来。如果发送方在定时器超时前收到了相应的ACK，说明数据包已经成功接收，发送方会将定时器停止，并继续发送下一个数据包。</p><blockquote><p>这个默认的<strong>定时器</strong>策略，是用于TCP的<code>超时重传</code>的。</p></blockquote><p>然而，如果发送方在定时器超时前没有收到ACK，通常会认为数据包丢失了，因此会重新发送该数据包。但有时候，接收方实际上已经收到了数据包，只是ACK因为某种原因没有及时发送回来，这可能是由于网络延迟、拥塞等造成的。</p><p>而TCP<strong>快重传</strong>的思想是，当发送方收到<strong>连续的相同的ACK</strong>时，<strong>不等待定时器超时</strong>，而是立即重传对应的数据包。</p><ul><li>要求接收方不要等自己发送数据的时候才进行捎带确认，而是立马发送确认</li><li>即便收到了失序的报文段，也要立即发出对已收到的报文段的重复确认。比如收到了1、2、3、6、5，收到后续的报文时必须发送对3的重复确认（即ACK&#x3D;4，期望收到4号报文）</li></ul><p>这是因为连续收到相同的ACK，表明接收方已经收到了一系列的数据包，并且正在等待接收下一个数据包。通过立即重传，可以<strong>避免等待定时器超时</strong>的延迟，从而更快地恢复数据传输。</p><p>具体来说，TCP快重传的步骤如下：</p><ol><li>发送方发送一个数据包，并启动定时器。</li><li>接收方收到数据包后，发送对应的ACK回去。</li><li>如果发送方收到<strong>三个连续的相同ACK</strong>（即收到三个对同一个数据包的确认应答），就立即重传该数据包，而不等待定时器超时。</li></ol><p>因为收到三个连续相同ACK才会触发立即重传，这里的问题又叫<strong>3ACK问题</strong>。</p><p>使用快重传策略，可以避免某些报文出现超时重传，从而导致发送方错误重置cwnd和ssthresh，让网络的吞吐率增加。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/e0b01dd51e5a0a3a7e8f9286485f1c3a.png" alt="image.png"></p><p>3ACK之后，一般的做法下需要将cwnd和ssthresh都设置为当前cwnd的一半。</p><h2 id="7-4-快恢复"><a href="#7-4-快恢复" class="headerlink" title="7.4 快恢复"></a>7.4 快恢复</h2><p>快恢复算法也是基于3ACK问题的，当发送方收到三个重复的ACK，这代表接收方其实收到了后续的三个报文，只不过中间有一个丢包了而已。因此，网络中需要发送的报文其实是少了三个，可以将拥塞窗口增大（ssthresh+3）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d171b7ca25b98b68f44c83afa7e0eb03.png" alt="image.png"></p><h2 id="7-5-总结和习题"><a href="#7-5-总结和习题" class="headerlink" title="7.5 总结和习题"></a>7.5 总结和习题</h2><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/fda3d09063b60f6f9dab95114bd5523c.png" alt="image.png"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b578f9345d8565e34875c64b4e2cf068.png" alt="image.png"></p><h1 id="8-延迟应答"><a href="#8-延迟应答" class="headerlink" title="8.延迟应答"></a>8.延迟应答</h1><h2 id="8-1-问题"><a href="#8-1-问题" class="headerlink" title="8.1 问题"></a>8.1 问题</h2><blockquote><p>如何在保证<strong>不拥塞网络</strong>的前提下，传输更多数据？</p></blockquote><p>要知道，网络环境复杂多变，一次性发送更多数据，是<strong>优于</strong>多次发送少量数据的</p><p>记住：<strong>窗口越大，网络吞吐量越大，传输效率就越高</strong>！</p><p>这时候，如何提高网络传输效率的问题，就被转换成了：上层如何尽快取走缓冲区中的数据的问题。</p><h2 id="8-2-概念"><a href="#8-2-概念" class="headerlink" title="8.2 概念"></a>8.2 概念</h2><p>所谓<strong>延迟应答</strong>，即收到消息后，等一会再给对方应答；</p><p>此时等待的是<strong>应用层取走接收缓冲区中</strong>的数据。这样在回应ACK的时候，缓冲区的容量更富裕，ACK中携带的接收窗口大小也就更大，下次对方就能发送更多数据，提高了tcp通信的效率！</p><blockquote><p>需要注意的是，窗口大小的增加，是与网络拥塞无关的。二者是tcp在传输中都要考虑的两个独立的问题。</p></blockquote><p>我们只要多等一等，就能给出时间让应用层取走一些数据，再给对方ACK，就能让自己的滑动窗口大小更大！</p><p>比如下面这个栗子：</p><ul><li>假设接收端缓冲区为1MB，一次收到了500KB的数据；如果立刻应答，此时返回的窗口大小就是500KB；</li><li>但实际上，接收端处理的很快，在30ms后，应用层就取走了收到的这500KB的数据</li><li>这时候，接收端在<strong>等待</strong>发送端给自己发来的500KB数据的时候，缓冲区就已经恢复成1MB了</li><li>但<strong>发送端并不能知晓这件事</strong>，它依旧是按500KB给接收端发送的信息。这时候，接收端的缓冲区就出现了<strong>闲置</strong></li><li>如果我们让接受端晚一点（比如晚200ms）再给发送端进行应答，此时应用层就已经取走缓冲区中的数据了，缓冲区大小恢复为1MB，接收端发送的应答中滑动窗口的大小也增加为1MB，发送端可以一次发送更多数据，缓冲区利用率提高！</li></ul><p>注意，接收端缓冲区提高，能让发送端一次发送数据量的<strong>上限提高</strong>。实际发送多少数据，还是由双方通信的内容决定的。</p><h2 id="8-3-策略"><a href="#8-3-策略" class="headerlink" title="8.3 策略"></a>8.3 策略</h2><p>延迟应答的时间需要注意，不能太长（否则发送端会因为超时没有收到ACK而触发重传）；也不能太短，否则应用层还没来得及取走数据</p><p>一般延迟应答有如下两个策略</p><ul><li>隔N个包应答一次</li><li>隔一定时间应答一次（要在延迟的同时，避免对方进行超时重传）</li></ul><p>延迟应答的策略根据不同平台而不同，一般N取2，间隔时间取<code>200ms</code>；</p><h1 id="9-捎带应答"><a href="#9-捎带应答" class="headerlink" title="9.捎带应答"></a>9.捎带应答</h1><p>在tcp报文的ACK应答的时候，如果采用一问一答的方式，会导致双方通信效率较低</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B 吃了吗</span><br><span class="line">B -&gt; A 吃了</span><br><span class="line">B -&gt; A 你呢？</span><br><span class="line">A -&gt; B 我还没有</span><br></pre></td></tr></table></figure><p>如果采用下面这种方式，就节省了一次收发的时间，提高了通信效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B 吃了吗</span><br><span class="line">B -&gt; A 吃了,你呢？</span><br><span class="line">A -&gt; B 我还没有</span><br></pre></td></tr></table></figure><p>TCP的捎带应答就是如此，在回答对方的消息(ACK)的同时，携带上自己要发送给对方的信息。</p><p>要知道，所谓的ACK报文，只是需要将报头中的<strong>ACK标记位置为1</strong>即可，并不影响这个报文其他部分的功能！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/04/64278f879368d.png" alt="image-20230401095727239"></p><h1 id="10-选择确认"><a href="#10-选择确认" class="headerlink" title="10.选择确认"></a>10.选择确认</h1><p>前面讲述拥塞控制以及TCP可靠传输的时候，都提到TCP接收方只能对收到的按序报文数据中的最高序号给出确认，如果还有多余的未按序抵达的报文，则无法实现确认，并且会在超时重传的时候一并重传</p><ul><li>接受方收到了0，1，2，3，4，7，6；</li><li>接收方只能确认0到4，即ACK&#x3D;5；</li><li>发送方收到该ACK，会认为6和7也丢了，会从5开始重新发送5，6，7；</li><li>但是实际上接收方已经收到了6和7，发送方相当于多重传了一次6和7；</li></ul><p>未了避免这种情况，TCP可以使用选择确认，来让发送方只重传缺少的报文，而不出现多余的重传问题。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/7ee142722cf8d137d10244077889fe1a.png"></p><p>因为默认的TCP报头中并没有提供选择确认字段相关的取值，所以RCF2018规定，如果需要使用选择确认功能，要在TCP的扩展选项中实现。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/6b533d5bc06fc5b09dd577bb55e53937.png" alt="image-20240101140053632"></p><p>但是，SACK相关文档并没有明确指出发送方应该如何响应SACK，因此大部分TCP的实现还是采用了重传所有未被确认的数据块。</p><h1 id="11-面向字节流"><a href="#11-面向字节流" class="headerlink" title="11.面向字节流"></a>11.面向字节流</h1><p>调用<code>write</code>时，数据会先写入发送缓冲区中，并不是立马发送给对方</p><ul><li>如果一次性发送的字节数太长，会被拆分成多个TCP的数据包发出</li><li>如果发送的字节数太短，可能会在缓冲区中等待，到一定数据量后，再发出</li></ul><p>这两个操作都是TCP<strong>自主帮我们完成</strong>的</p><ul><li>接收数据时，数据从<strong>网卡</strong>（数据一定是先被网卡收到的），被驱动程序读取后，流入操作系统的接收缓冲区</li><li>应用层调用 read 从接收缓冲区中拿到数据</li></ul><p>因为同时拥有接收和发送缓冲区（全双工），所以TCP程序的读写<strong>不需要完全同步</strong></p><ul><li>写100个字节，可以调用 write 写入100个字节，也可以调用100次 write 写入1个字节</li><li>读100个字节，也可以多次读取，或一次性读取完毕</li><li>二者都不需要考虑对方的写入是如何写入的！</li></ul><p>因为数据在缓冲区中都是没有严格分界的<strong>字节数据</strong>，TCP不关心这些数据的组成，所以TCP是面向字节流的。我们只需要读取之后，依照<strong>应用层</strong>的<strong>协议</strong>进行数据的处理即可。</p><p>这也是为什么使用TCP时，<strong>应用层的协议</strong>需要规定一个协议中数据的边界（比如报文中数据字节的长度，或者用特殊字符来做边界，参考HTTP协议）</p><h1 id="12-粘包问题"><a href="#12-粘包问题" class="headerlink" title="12.粘包问题"></a>12.粘包问题</h1><p>前面提到了，tcp在读写数据的时候，并没有严格的读取字节的要求，那么就可能会遇到下面的问题（C代表发送端，S代表接收端）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设应用层定义的协议一个报文是100KB大小；</span><br><span class="line">C -&gt; 100KB S</span><br><span class="line">C -&gt; 100KB S</span><br><span class="line">S 一次性读取了150KB的数据；</span><br><span class="line">此时，它读取了1.5个应用层的报文，并不完整！</span><br></pre></td></tr></table></figure><p>这种情况，被称为<strong>粘包问题</strong>；解决粘包问题最好的办法，就是要明确<code>报文和报文之间的边界</code>，其通过<strong>应用层</strong>的协议来明确，必须要在应用层来处理；</p><ul><li>定长报文，要求双方都必须读写特定长度的报文，多的拆包，少的补空</li><li>变长报文，可以采用在报文开头写明本条报文长度的方式，告知对方应读取多少字节</li><li>变长报文，还可以采用数据分隔符的方式作为边界（需要保证正文中不能出现分隔符，比如http中的<code>\r\n</code>）</li></ul><p>对于UDP而言，并<strong>不存在</strong>粘包问题。因为UDP采用的是定长报文（面向数据报），应用层只会读取到一个完整的报文。如果UDP的一个报文不完整，代表数据在传输过程中出现了丢失。</p><p>但是上面的描述都不完整，其实TCP有粘包问题最直接的证明就是：TCP的报头中，<strong>并没有报文总长度字段</strong>，只有一个4位首部长度字段用于标识TCP首部的长度。但是在UDP的报头中，<strong>有一个16位总长度</strong>，且UDP的首部长度固定为8字节，接收方只需要读取固定的前8字节，就能得到整个UDP报文的总长度，并进一步进行读取。</p><h1 id="13-UDP如何实现可靠传输？"><a href="#13-UDP如何实现可靠传输？" class="headerlink" title="13.UDP如何实现可靠传输？"></a>13.UDP如何实现可靠传输？</h1><p>有的时候，会遇到这个问题。解决这个问题的思路就是：借鉴！</p><p>tcp就是可靠的传输机制，我们只需要在tcp里面选择一部分<strong>tcp协议的特性</strong>，加到udp中，就能在一定程度上实现udp的可靠传输</p><ul><li>报文中添加序号，保证按序到达</li><li>引入确认应答，确认对方收到了信息</li><li>引入按序到达，保证数据包发送的顺序正确</li><li>引入超时重传，如果一段时间对方没有应答，则重发</li><li>…</li></ul><p>这些操作就需要程序猿在应用层去实现了。</p><h1 id="14-SYN洪水攻击如何抵御？"><a href="#14-SYN洪水攻击如何抵御？" class="headerlink" title="14.SYN洪水攻击如何抵御？"></a>14.SYN洪水攻击如何抵御？</h1><p>syn攻击实质是只发送syn报文，占满服务端的半连接队列，导致正常请求的syn被丢弃。</p><p>1，增大tcp_max_backlog，somaxconn和listen参数backlog，达到增大半连接队列的作业</p><p>2，开启tcp_syncookies服务，半连接队列慢也不会丢弃syn包，会采取cookie验证</p><p>3，减少syn_ack重传次数，调节tcp_synack_retries。同时</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>UDP&#x2F;TCP协议的基本知识如上，后续还会继续补充</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/4287572457/">https://blog.musnow.top/posts/4287572457/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/nginx/">nginx</a><a class="post-meta__tags" href="/tags/tcp/">tcp</a><a class="post-meta__tags" href="/tags/udp/">udp</a></div><div class="post_share"><div class="social-share" data-image="https://img.musnow.top/i/2023/03/6414766c49315.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2962575673/" title="【win】windows磁盘管理分区,实现整数容量"><img class="cover" src="https://p8.itc.cn/images01/20220320/7dc777fe5cc8407f842b35cc66276014.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【win】windows磁盘管理分区,实现整数容量</div></div></a></div><div class="next-post pull-right"><a href="/posts/3422840311/" title="【Git】解决git status中文乱码问题 | 转载"><img class="cover" src="https://img.musnow.top/i/2023/03/6413fd7f3709b.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Git】解决git status中文乱码问题 | 转载</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/3390191280/" title="【Linux】高级IO和多路转接 | select&#x2F;poll&#x2F;epoll"><img class="cover" src="https://img.musnow.top/i/2023/08/748d3a20ba69bb3b3671f5b344cba650.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-25</div><div class="title">【Linux】高级IO和多路转接 | select&#x2F;poll&#x2F;epoll</div></div></a></div><div><a href="/posts/3435557393/" title="【nginx】配置跨域请求问题 | 转载"><img class="cover" src="/img/bg/gm17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-24</div><div class="title">【nginx】配置跨域请求问题 | 转载</div></div></a></div><div><a href="/posts/1994863894/" title="【nginx】Docker配置nginx，实现同服务器ip多站点多域名"><img class="cover" src="/img/bg/gm11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-24</div><div class="title">【nginx】Docker配置nginx，实现同服务器ip多站点多域名</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">401</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">1.linux下常用网络命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-netstat%E5%91%BD%E4%BB%A4"><span class="toc-text">1.1 netstat命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-pidof"><span class="toc-text">1.2 pidof</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-UDP%E5%8D%8F%E8%AE%AE"><span class="toc-text">2.UDP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%90%86%E8%A7%A3%E6%8A%A5%E5%A4%B4"><span class="toc-text">2.1 理解报头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-udp%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2.2 udp的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-udp%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">2.3 udp缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%B8%A2%E5%8C%85"><span class="toc-text">2.4 丢包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-text">2.5 基于udp的应用层协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-udp%E7%9A%84%E4%BC%A0%E8%BE%93%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6"><span class="toc-text">2.6 udp的传输大小限制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-TCP%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%BA%90%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">3.1 源和目的端口号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-4%E4%BD%8D%E9%A6%96%E9%83%A8%E9%95%BF%E5%BA%A6"><span class="toc-text">3.2 4位首部长度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-TCP%E6%8A%A5%E6%96%87%E5%AE%8C%E6%95%B4%E9%95%BF%E5%BA%A6"><span class="toc-text">3.2.1 TCP报文完整长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-32%E4%BD%8D%E5%BA%8F%E5%8F%B7-x2F-%E7%A1%AE%E8%AE%A4%E5%BA%8F%E5%8F%B7"><span class="toc-text">3.3 32位序号&#x2F;确认序号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E4%BF%A1%E6%81%AF%E8%A2%AB%E5%AF%B9%E6%96%B9%E6%94%B6%E5%88%B0%EF%BC%9F"><span class="toc-text">3.3.1 如何确认信息被对方收到？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94"><span class="toc-text">3.3.2 确认应答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%A4%E7%BB%84%E7%A1%AE%E8%AE%A4%E5%BA%8F%E5%8F%B7%EF%BC%9F"><span class="toc-text">3.3.3 为什么有两组确认序号？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E6%B2%A1%E6%9C%89%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%81"><span class="toc-text">3.3.4 没有完美的协议！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-5-%E6%8C%89%E5%BA%8F%E5%88%B0%E8%BE%BE"><span class="toc-text">3.3.5 按序到达</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-6-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-text">3.3.6 第一个序号的产生</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-16%E4%BD%8D%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F"><span class="toc-text">3.4 16位窗口大小</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">3.4.1 发送和接收缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%A1%E4%BA%86%E5%92%8B%E5%8A%9E"><span class="toc-text">3.4.2 接收缓冲区满了咋办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E5%91%8A%E7%9F%A5%E5%AF%B9%E6%96%B9%E6%94%B6%E7%BC%93%E5%A4%A7%E5%B0%8F"><span class="toc-text">3.4.3 告知对方收缓大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%98%AF%E5%90%A6%E7%8B%AC%E7%AB%8B%EF%BC%9F"><span class="toc-text">3.4.4 缓冲区是否独立？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%85%AD%E4%B8%AA%E6%A0%87%E8%AE%B0%E4%BD%8D"><span class="toc-text">3.5 六个标记位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-8%E4%B8%AA%E6%A0%87%E8%AE%B0%E4%BD%8D%EF%BC%9F"><span class="toc-text">3.5.1 8个标记位？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-ACK"><span class="toc-text">3.5.2 ACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-SYN-x2F-FIN"><span class="toc-text">3.5.3 SYN&#x2F;FIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">3.5.3.1 三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A5%E6%94%B6%E6%96%B9%E8%A6%81%E5%8F%91%E9%80%81ACK-SYN"><span class="toc-text">为什么接收方要发送ACK+SYN</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">3.5.3.2 四次挥手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-PSH"><span class="toc-text">3.5.4 PSH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-URG"><span class="toc-text">3.5.5 URG</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-5-1-16%E4%BD%8D%E7%B4%A7%E6%80%A5%E6%8C%87%E9%92%88"><span class="toc-text">3.5.5.1 16位紧急指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-6-RST"><span class="toc-text">3.5.6 RST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF3%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-text">3.6 为什么是3次握手？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-text">3.7 超时重传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">3.7.1 超时重传的说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4RTO%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">3.7.2 超时重传时间RTO的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E4%BE%8B%E9%A2%98"><span class="toc-text">3.7.3 超时重传时间例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E5%87%BA%E7%8E%B0%E4%BA%86%E5%BE%88%E5%A4%9ACLOSE-WAIT%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">3.8 出现了很多CLOSE-WAIT状态的连接？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-%E6%B4%BB%E5%AD%A6%E6%B4%BB%E7%94%A8%F0%9F%A4%A3"><span class="toc-text">3.8.1 活学活用🤣</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5"><span class="toc-text">3.9 异常情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-text">3.10 校验和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-TCP%E4%BF%9D%E6%B4%BB%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">3.11 TCP保活计数器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%AA%8C%E8%AF%81TCP%E7%8A%B6%E6%80%81"><span class="toc-text">4.验证TCP状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-TIME-WAIT"><span class="toc-text">4.1 TIME-WAIT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E4%B8%BA%E5%95%A5%E8%A6%81%E6%9C%89%E8%BF%99%E4%B8%AA%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">4.1.1 为啥要有这个状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E7%AD%89%E5%A4%9A%E4%B9%85%EF%BC%9F"><span class="toc-text">4.1.2 等多久？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-CLOSE-WAIT"><span class="toc-text">4.2 CLOSE-WAIT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-ESTABLISHED"><span class="toc-text">4.3 ESTABLISHED</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%AB%AF%E5%8F%A3%E4%B8%8D%E8%83%BD%E8%A2%ABbind"><span class="toc-text">4.4 端口不能被bind</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E9%97%AE%E9%A2%98"><span class="toc-text">4.4.1 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="toc-text">4.4.2 端口复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-accpet%E4%B8%8D%E5%BD%B1%E5%93%8Dtcp"><span class="toc-text">4.5 accpet不影响tcp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-listen%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-text">4.6 listen的第二个参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">4.6.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E7%9C%8B%E7%9C%8B%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5"><span class="toc-text">4.6.2 看看具体情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4.6.3 为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-4-%E8%AF%A5%E5%8F%82%E6%95%B0%E5%BA%94%E8%AF%A5%E8%AE%BE%E7%BD%AE%E6%88%90%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">4.6.4 该参数应该设置成多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-5-listen%E5%92%8Caccept"><span class="toc-text">4.6.5 listen和accept</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%89"><span class="toc-text">5.滑动窗口（可靠传输）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">5.2 滑动窗口示意图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%80%BB%E7%BB%93%E5%92%8C%E4%B9%A0%E9%A2%98"><span class="toc-text">5.3 总结和习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">6.流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">6.1 流量控制基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B"><span class="toc-text">6.2 流量控制举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%8C%81%E7%BB%AD%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-text">6.3 持续计时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E4%BE%8B%E9%A2%98"><span class="toc-text">6.4 发送窗口例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">7.拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E7%BD%91%E7%BB%9C%E5%87%BA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">7.1 如何确认网络出问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-TCP%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-text">7.1.1 TCP提供的拥塞控制策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%85%A2%E5%90%AF%E5%8A%A8%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-text">7.2 慢启动和拥塞避免</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%BF%AB%E9%87%8D%E4%BC%A0%EF%BC%883ACK%EF%BC%89"><span class="toc-text">7.3 快重传（3ACK）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="toc-text">7.4 快恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%80%BB%E7%BB%93%E5%92%8C%E4%B9%A0%E9%A2%98"><span class="toc-text">7.5 总结和习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%BB%B6%E8%BF%9F%E5%BA%94%E7%AD%94"><span class="toc-text">8.延迟应答</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E9%97%AE%E9%A2%98"><span class="toc-text">8.1 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%A6%82%E5%BF%B5"><span class="toc-text">8.2 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E7%AD%96%E7%95%A5"><span class="toc-text">8.3 策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%8D%8E%E5%B8%A6%E5%BA%94%E7%AD%94"><span class="toc-text">9.捎带应答</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4"><span class="toc-text">10.选择确认</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">11.面向字节流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">12.粘包问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-text">13.UDP如何实现可靠传输？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-SYN%E6%B4%AA%E6%B0%B4%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E6%8A%B5%E5%BE%A1%EF%BC%9F"><span class="toc-text">14.SYN洪水攻击如何抵御？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-end"><span class="toc-text">The end</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/0/" title="无题">无题</a><time datetime="2024-08-03T06:14:18.087Z" title="发表于 2024-08-03 14:14:18">2024-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3021867507/" title="【Docker】威联通QNAP部署思源笔记">【Docker】威联通QNAP部署思源笔记</a><time datetime="2024-07-31T13:20:15.000Z" title="发表于 2024-07-31 21:20:15">2024-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1936212186/" title="【Docker】以思源笔记为例，谈谈什么是端到端加密">【Docker】以思源笔记为例，谈谈什么是端到端加密</a><time datetime="2024-07-27T23:31:24.000Z" title="发表于 2024-07-28 07:31:24">2024-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/321211845/" title="【C语言】字符串 | 回顾C语言005">【C语言】字符串 | 回顾C语言005</a><time datetime="2024-07-27T22:07:48.000Z" title="发表于 2024-07-28 06:07:48">2024-07-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>