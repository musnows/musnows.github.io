<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Linux】文件IO | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="让我们来认识一下linux下的文件接口吧！"><meta property="og:type" content="article"><meta property="og:title" content="【Linux】文件IO"><meta property="og:url" content="https://blog.musnow.top/posts/2864480005/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="让我们来认识一下linux下的文件接口吧！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.musnow.top/img/bg/gm4.png"><meta property="article:published_time" content="2022-11-01T12:40:16.000Z"><meta property="article:modified_time" content="2023-03-29T08:18:13.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Linux"><meta property="article:tag" content="文件"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.musnow.top/img/bg/gm4.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/2864480005/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Linux】文件IO",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-03-29 16:18:13"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">285</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(/img/bg/gm4.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> Keep</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51cto</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/memos/"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Linux】文件IO</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-01T12:40:16.000Z" title="发表于 2022-11-01 20:40:16">2022-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-29T08:18:13.000Z" title="更新于 2023-03-29 16:18:13">2023-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%8E%A9%E4%B8%8ALinux/">玩上Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【Linux】文件IO"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>让我们来认识一下linux下的文件接口吧！</p><span id="more"></span><blockquote><p>演示所用系统：CentOS7.6</p><p>本文所有代码都可以在我的gitee仓库查看【<a target="_blank" rel="noopener" href="https://gitee.com/musnow/raspberry-practice/tree/master/code/22-10-18_files">链接</a>】</p></blockquote><p>[TOC]</p><h1 id="1-什么是文件？"><a href="#1-什么是文件？" class="headerlink" title="1.什么是文件？"></a>1.什么是文件？</h1><ul><li><code>文件=文件内容+文件属性</code>，文件属性也是数据，即便我们创建一个空文件，也是会占用磁盘空间的</li><li><code>文件操作=文件内容的操作+文件属性的操作</code>，在之前<code>linux权限</code>的博客里面就提到过，文件操作有可能即改变内容，又改变属性</li><li><code>文件打开操作</code>其实是把文件的属性和内容加载到内存中，没有被打开的文件依旧处于磁盘当中</li><li><code>当前路径</code>为当前进程所处的工作路径</li></ul><p>我们的打开文件操作需要和磁盘这个硬件打交道，只有操作系统才能直接操作硬件。所以我们的文件操作其实都是<strong>调用的系统接口</strong>。</p><p>实际上，所有编程语言都对操作系统接口进行了封装，这样才能保证他们的<strong>跨平台性</strong>。因为不同操作系统的各种接口各不相同，如果不进行封装，直接调用系统接口，则该代码只能在指定系统上跑！</p><h2 id="1-2-C语言文件操作"><a href="#1-2-C语言文件操作" class="headerlink" title="1.2 C语言文件操作"></a>1.2 C语言文件操作</h2><p>在学习Linux下文件相关内容之前，我们先来复习一下C语言的文件接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">writetest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>*file=<span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">    FILE* f=<span class="built_in">fopen</span>(file,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(f,<span class="string">&quot;hello linux! %d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fclose</span>(f);</span><br><span class="line">    f=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readtest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>*file=<span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">    FILE* f=<span class="built_in">fopen</span>(file,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>];<span class="comment">//将读取到的数据写入buff数组里面</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fgets</span>(buff,<span class="number">20</span>,f);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(f);</span><br><span class="line">    f=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用循环先往<code>test.txt</code>内输入10行数据，再读取并打印到屏幕上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test1</span><br><span class="line">hello linux! 0</span><br><span class="line">hello linux! 1</span><br><span class="line">hello linux! 2</span><br><span class="line">hello linux! 3</span><br><span class="line">hello linux! 4</span><br><span class="line">hello linux! 5</span><br><span class="line">hello linux! 6</span><br><span class="line">hello linux! 7</span><br><span class="line">hello linux! 8</span><br><span class="line">hello linux! 9</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/02/202210240914321.png" alt="image-20221024091420220"></p><p>除了w和r方法外，C语言还提供了<code>w+ r+ a</code>以及带<code>b</code>的二进制读写</p><blockquote><p>这部分内容可以去看看我之前的<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123203942">C语言文件操作</a>博客！</p></blockquote><p>C语言默认打开了三个输入输出流，都是一个<code>FILE*</code>的指针，分别为<code>stdin/stdout/stderr</code>，记住这个点，后面会用到哦</p><hr><h1 id="2-初识Linux系统的文件接口"><a href="#2-初识Linux系统的文件接口" class="headerlink" title="2.初识Linux系统的文件接口"></a>2.初识Linux系统的文件接口</h1><p>Linux下的文件操作用的接口为<code>open/write/read</code>，都需要先用open打开文件并指定打开方式后，再用<code>write/read</code>操作进行读写</p><blockquote><p>注：man查询的时候需要指定<code>man 2 open</code>，否则查询到的是命令不是函数接口</p></blockquote><p><img src="https://img.musnow.top/i/2023/02/202210240942664.png" alt="image-20221024094258584"></p><p>这里open一共有两个函数接口，没错，就是<strong>函数重载</strong>！这是因为linux下的C语言标准和我们之前在win下学习所用的标准是不一样的！</p><ul><li>第一个参数为<code>pathname</code>，文件路径</li><li>第二个参数为<code>flags</code>，打开文件的方式</li></ul><p>打开文件的方式并不像C语言用<code>w/r</code>等等代替，而是需要我们传入多个<code>flag</code>进行<strong>按位与</strong>，这一点和<code>C++</code>中的文件类一样！</p><blockquote><p>这里的flag其实是一种位图结构。每一个<code>flag</code>只需要在一个比特位上为1（十进制2的倍数）其余位为0，保证互不影响。这样在按位与的时候，才能正确凑到一起，并通过按位或进行flag的取出</p></blockquote><p>flag的参数中，下面这三个值，必须指定一个且只能指定一个</p><ul><li>O_RDONLY: 只读打开</li><li>O_WRONLY: 只写打开</li><li>O_RDWR: 读，写打开</li></ul><p>剩余的参数是用作额外操作的</p><ul><li>O_CREAT: 若文件不存在，则创建；需要传入<code>mode</code>参数，来指明新文件的访问权限</li><li>O_APPEND: 追加写</li><li>O_TRUNC: 清空文件</li><li>……</li></ul><p>常用的参数就上面这些，更多参数可以使用<code>man 2 open</code>查看完整<code>flag</code>列表</p><blockquote><p>这种<strong>大写+下划线</strong>的命名方式告诉我们，它其实就是系统中预先定义好的<strong>宏</strong>！</p></blockquote><p>需要注意的是，open函数的返回值是一个<code>int</code>类型，它被称为<code>文件描述符</code>，后面会有详解</p><hr><h2 id="2-1-读文件"><a href="#2-1-读文件" class="headerlink" title="2.1 读文件"></a>2.1 读文件</h2><p><img src="https://img.musnow.top/i/2023/02/202210241002861.png" alt="image-20221024100233819"></p><p>读文件的操作和<code>fgets</code>类似，需要指定文件描述符，以及用于保存文件内容的<code>buf</code>，和数据长度<code>count</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    read(fd1,buf,<span class="built_in">strlen</span>(buf)<span class="number">-1</span>);</span><br><span class="line">    <span class="type">ssize_t</span> s = read(fd1, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       buf[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ssize_t</code>是有符号整型，其实就是int</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">ssize_t</span></span><br></pre></td></tr></table></figure><p>这里我们打开了刚刚测试C语言用的<code>test.txt</code>文件，成功读出了里面的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">hello linux! 0</span><br><span class="line">hello linux! 1</span><br><span class="line">hello linux! 2</span><br><span class="line">hello linux! 3</span><br><span class="line">hello linux! 4</span><br><span class="line">hello linux! 5</span><br><span class="line">hello linux! 6</span><br><span class="line">hello linux! 7</span><br><span class="line">hello linux! 8</span><br><span class="line">hello linux! 9</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><h2 id="2-2-写文件"><a href="#2-2-写文件" class="headerlink" title="2.2 写文件"></a>2.2 写文件</h2><p><img src="https://img.musnow.top/i/2023/02/202210241012338.png" alt="image-20221024101226288"></p><p>注意的是，默认情况下，如果我们不在<code>open</code>的时候指定第三个参数，其创建的新文件，权限是乱掉的。而单给第三个参数传入<code>0666</code>还不够，我们需要先把系统的<code>umask</code>在当前进程中设置为0，以避免系统<code>umask</code>的默认值对我们创建文件的权限造成影响</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);<span class="comment">//先把umask设置为0，保证权限值设置正确，不受系统umask影响</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">	<span class="comment">//这里我们指定了0_CREAT，所以需要指定0666作为权限值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;bbbbbb\n&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码后，可以看到数据被成功写入</p><p><img src="https://img.musnow.top/i/2023/02/202210241015476.png" alt="image-20221024101514428"></p><p>这里我们还指定了<code>O_TRUNC</code>，所以每一次执行的时候，文件内部的内容都会被清空。修改<code>str</code>后重新进行测试，可以看到原有的内容不见了</p><p><img src="https://img.musnow.top/i/2023/02/202210241017590.png" alt="image-20221024101732559"></p><p>如果不指定，其不会清空已有内容。而是会从开头进行写入，覆盖开头已有的内容（左边为写入后，右边为写入前）</p><p><img src="https://img.musnow.top/i/2023/02/202210241028982.png" alt="image-20221024102817916"></p><p>实际上，C语言的文件操作，调用的就是<code>linux</code>的文件接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>); <span class="comment">//底层调用open，O_WRONLY | O_CREAT | O_TRUNC</span></span><br><span class="line">fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;a&quot;</span>); <span class="comment">//底层调用open，O_WRONLY | O_CREAT | O_APPEND</span></span><br></pre></td></tr></table></figure><h3 id="写方式覆盖？"><a href="#写方式覆盖？" class="headerlink" title="写方式覆盖？"></a>写方式覆盖？</h3><p>在测试的时候，我发现了一个神奇的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    umask(<span class="number">0</span>);<span class="comment">//先把umask设置为0，保证权限值设置正确，不受系统umask影响</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;test.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;test.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d  fd2: %d\n&quot;</span>,fd1,fd2);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;bbadsfasdfasdfa23123bbbb&quot;</span>;</span><br><span class="line">    write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我分别用<code>fd1/fd2</code>打开了<code>test.txt</code>文件，打印它们的文件描述符可以看到，结果不一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">fd1: 3  fd2: 4</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><p>但是，执行的写入，却是<code>O_TRUNC</code>的覆盖方法！</p><p><img src="https://img.musnow.top/i/2023/02/202210241045432.png" alt="image-20221024104541372"></p><p>实际上，并不是<code>fd2</code>的写入方法覆盖了<code>fd1</code>的，而是当我们使用<code>O_TRUNC</code>方法打开文件的时候，文件里面的内容就已经被清空了！</p><p><img src="https://img.musnow.top/i/2023/02/202210241554067.png" alt="image-20221024155450999"></p><p><img src="https://img.musnow.top/i/2023/02/202210241558186.png" alt="image-20221024155807127"></p><p>可以看到，刚刚才<code>begin fd2</code>的时候，<code>test.txt</code>的文件大小就已经变成0了</p><p>为了避免这种情况，建议不要在同一个进程里面多次打开一个之前已经打开过的文件！</p><h1 id="3-文件描述符"><a href="#3-文件描述符" class="headerlink" title="3.文件描述符"></a>3.文件描述符</h1><h2 id="3-1-为什么是从3开始？"><a href="#3-1-为什么是从3开始？" class="headerlink" title="3.1 为什么是从3开始？"></a>3.1 为什么是从3开始？</h2><p>这里我们一次性打开多个文件，打印他们的文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fda = <span class="built_in">open</span>(<span class="string">&quot;loga.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fdb = <span class="built_in">open</span>(<span class="string">&quot;logb.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fdc = <span class="built_in">open</span>(<span class="string">&quot;logc.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fdd = <span class="built_in">open</span>(<span class="string">&quot;logd.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fde = <span class="built_in">open</span>(<span class="string">&quot;loge.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fda: %d\n&quot;</span>, fda);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fdb: %d\n&quot;</span>, fdb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fdc: %d\n&quot;</span>, fdc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fdd: %d\n&quot;</span>, fdd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fde: %d\n&quot;</span>, fde);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/02/202210241124041.png" alt="image-20221024112417994"></p><p>会发现打印的文件是从3开始的。这和我们之前是否有打开过文件没关系，任何进程open的自己的文件都是从3开始的！</p><p>还记得前面C语言部分提到的<code>stdin/stdout/stderr</code>吗？</p><p>linux系统下一切皆文件，这三个家伙也不例外！既然C语言的文件操作封装了系统的接口，<strong>那么其内部肯定是有文件描述符的存在的</strong>，我们只需要找到它就行了。</p><p>这一点，代码补全就可以帮忙了</p><p><img src="https://img.musnow.top/i/2023/02/202210241128792.png" alt="image-20221024112816731"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//c语言中的FILE是一个结构体，里面管理了linux系统的文件描述符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stdin %d\n&quot;</span>,<span class="built_in">stdin</span>-&gt;_fileno);<span class="comment">//  0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stdout %d\n&quot;</span>,<span class="built_in">stdout</span>-&gt;_fileno);<span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stderr %d\n&quot;</span>,<span class="built_in">stderr</span>-&gt;_fileno);<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    FILE* f1 = fopen(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f1 %d\n&quot;</span>,f1-&gt;_fileno);<span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">stdin 0</span><br><span class="line">stdout 1</span><br><span class="line">stderr 2</span><br><span class="line">f1 3</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><p>打印之后我们发现，其<code>0 1 2</code>就是被C语言的这三个默认打开的文件流占用了，而我们用C语言<code>fopen</code>打开的文件，其文件描述符也是从3开始的！</p><hr><h3 id="用文件描述符调用stdin-x2F-out"><a href="#用文件描述符调用stdin-x2F-out" class="headerlink" title="用文件描述符调用stdin&#x2F;out"></a>用文件描述符调用stdin&#x2F;out</h3><p>既然<code>stdout</code>对应的文件描述符是1，那我们可不可以直接调用系统的接口往屏幕上输出东西呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[SIZE]=<span class="string">&quot;12345678910\n&quot;</span>;</span><br><span class="line">    write(<span class="number">1</span>,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然是可以的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">12345678910</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><p>同理，我们还可以这样来接收用户输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test6</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> s = read(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(s&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[s]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;stdin: %s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/02/202210251404470.png" alt="image-20221025140417277"></p><p>运行的时候，程序会挂起等待用户输入，由此可以打印获取输入的结果👇</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ make</span><br><span class="line">gcc test.c -o <span class="built_in">test</span> -std=c99</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">asdfasdfadfadf</span><br><span class="line">stdin: asdfasdfadfadf</span><br><span class="line"></span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><hr><h2 id="3-2-从0开始？数组下标！"><a href="#3-2-从0开始？数组下标！" class="headerlink" title="3.2 从0开始？数组下标！"></a>3.2 从0开始？数组下标！</h2><blockquote><p>既然<code>stdin/stdout/stderr</code>分别对应的是<code>0/1/2</code>，而我们打开的自己的文件对应的是3开始，有没有可能，这些数字是一个数组的下标呢？</p></blockquote><p>一个进程打开的文件，其数据是在内存中的。操作系统内核肯定需要管理一个进程已经打开的文件！万一有“大聪明”忘记<code>close</code>文件了，而操作系统又没去管理已有文件，其不就会造成<strong>内存泄漏</strong>吗？</p><p>在操作系统中，有一个<code>struct file</code>，其管理的就是已经打开了的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//包含了文件的内容+属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，这个文件内核还会被插入到进程的<code>task_struct</code>中，因为一个进程是可以同时打开多个文件的。操作系统在对已打开文件进行管理的同时，还需要对一个<strong>进程打开的文件</strong>进行管理（知道某个文件是谁打开的）</p><blockquote><p>下载的linux源码中，task_strcut的位置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux-2.6.32.12/include/linux/sched.h</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/02/202210251431673.png" alt="image-20221025143114568"></p></blockquote><p>而我们文件描述符，其实就是进程中管理文件的一个数组的下标。</p><p><img src="https://img.musnow.top/i/2023/02/202210251433844.png" alt="image-20221025143326760"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">files_struct</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fdtable</span> *fdt;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fdtable</span> fdtab;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">	<span class="type">int</span> next_fd;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">embedded_fd_set</span> close_on_exec_init;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">embedded_fd_set</span> open_fds_init;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> * fd_array[NR_OPEN_DEFAULT];<span class="comment">//文件数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样对进程打开的文件的管理，就被转化为了对这个数组的<strong>增删查改</strong></p><h2 id="3-3-Linux下一切皆文件"><a href="#3-3-Linux下一切皆文件" class="headerlink" title="3.3 Linux下一切皆文件"></a>3.3 Linux下一切皆文件</h2><p>最初学习Linux的时候，就提到了Linux下一切皆文件</p><p>现在我们知道了内核中是用<code>file</code>结构体来管理文件的，那么，它是怎么用<strong>文件</strong>来管理键盘、鼠标、显示器、磁盘、网卡的呢？</p><p>这时候就可以来“浅浅”的看一下源码了！不求看懂代码实现，只求理解理念</p><blockquote><p><code>struct file</code>位于<code>include/linux/fs.h</code>中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * fu_list becomes invalid after file_free is called and queued via</span></span><br><span class="line"><span class="comment">	 * fu_rcuhead for RCU freeing</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">fu_list</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f_dentry	f_path.dentry</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f_vfsmnt	f_path.mnt</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;  <span class="comment">/* f_ep_links, f_flags, no IRQ */</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_WRITECOUNT</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> f_mnt_write_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其余内容用来干哈子的咱暂且不管，目光聚焦于这一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br></pre></td></tr></table></figure><p>翻译过来，这个成员的名字为文件操作。再来复习一下<code>const修饰指针</code>的知识点</p><blockquote><p>const修饰指针有下面两种形式（关键字：const和指针，const常量指针，const指针）</p><ul><li>在<code>*</code>之前修饰，代表该指针指向对象的内容不能被修改（地址里的内容不能改）</li><li>在<code>*</code>之后修饰，代表该指针指向的对象不能被修改（指向的地址不能改）</li></ul></blockquote><p>在这个结构体中，就有<code>read/write</code>方法，它们是两个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">	<span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">	<span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>linux操作系统内的文件系统以<strong>统一的方式</strong>看待所有的设备。</p><p>特定的设备的<code>read/write</code>方法是不一样的，只需要在这些硬件的<strong>驱动程序</strong>中给操作系统提供读写这个设备的函数实现，操作系统则将<strong>函数指针</strong>指向对应的函数，便能实现对某一个硬件设备的操作！</p><p>比如调用显示器驱动的write刷新显示器的画面，调用网卡的<code>read/write</code>来<code>下载/上传</code>数据等等！</p><p><img src="https://img.musnow.top/i/2023/02/202210261210571.png" alt="image-20221026121038482"></p><hr><h2 id="3-4-分配规则"><a href="#3-4-分配规则" class="headerlink" title="3.4 分配规则"></a>3.4 分配规则</h2><p>分配文件描述符的时候，会从头开始遍历<code>fd_array[]</code>，找到第一个没有被使用的下标，分配给新的文件！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test7</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fda = open(<span class="string">&quot;loga.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> fdb = open(<span class="string">&quot;logb.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fda: %d\n&quot;</span>, fda);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fdb: %d\n&quot;</span>, fdb);</span><br><span class="line">    close(fda);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fdc = open(<span class="string">&quot;logc.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fdc: %d\n&quot;</span>, fdc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们先打开了两个文件，打印可以看到其文件描述符为<code>3/4</code>；关掉第一个文件后，再打开一个新的文件，会发现文件描述符还是3（第一个为空的文件描述符）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">fda: 3</span><br><span class="line">fdb: 4</span><br><span class="line"></span><br><span class="line">fdc: 3</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>同理，如果我们在打开文件之前，就关闭掉C语言打开的<code>stdout</code>，那么此时打开文件的fd就为1，我们的printf则会把数据打印到该文件当中！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test8</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//文件描述符分配的时候，会在数组里面找第一个为空的描述符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start test!\n&quot;</span>);<span class="comment">//打印到屏幕上</span></span><br><span class="line">    close(<span class="number">1</span>);<span class="comment">//关闭stdout</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>,fd);<span class="comment">//打印到文件中</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，运行<code>./test</code>之前，文件里面没有内容。执行之后，就把我们<code>printf</code>的数据输出到文件当中了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">start <span class="built_in">test</span>!</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">fd: 1</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><p>这种操作就叫做<strong>输出重定向</strong>！</p><p>另外<span id="jump">一种情况</span>下，如果我们在关闭<code>stdout</code>之前不进行<code>printf</code>，则不会立马刷新到<code>log.txt</code>而是需要我们刷新了缓冲区之后，才会写入到文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">close(<span class="number">1</span>);<span class="comment">//关闭stdout</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>,fd);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>这里有个小技巧<code>&gt;log.txt</code>可以用来清空文件的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ &gt;log.txt</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$</span><br></pre></td></tr></table></figure><hr><h2 id="3-5-dup2"><a href="#3-5-dup2" class="headerlink" title="3.5 dup2"></a>3.5 dup2</h2><p>上面是我们手动进行的<strong>输出重定向</strong>操作。操作系统提供了一个<strong>接口</strong>，可以让我们很方便地进行输出重定向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/02/202210261610321.png" alt="image-20221026161000273"></p><p>这里我们要用的是<code>dup2</code>函数，它的作用如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dup2() makes newfd be the copy of oldfd, closing newfd first if necessary, but note the following:</span><br><span class="line"></span><br><span class="line">*  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.</span><br><span class="line">*  If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.</span><br></pre></td></tr></table></figure><p>一定要看清楚，是将<code>newfd</code>变成<code>oldfd</code>的一个拷贝，在执行完毕之后，就只剩<code>oldfd</code>了！</p><p>如果<code>newfd</code>原本已经打开了一个文件，该操作会先将<code>newfd</code>给关掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">On success, these system calls return the new descriptor.  On error, -1 is returned, and errno is set appropriately.</span><br></pre></td></tr></table></figure><p>该函数成功的时候会返回<code>newfd</code>，否则返回<code>-1</code></p><hr><p>下面为一个示例代码，假设我们想将输出的内容重定向到一个文件中，则可以使用<code>dup2</code>将1替换为我们自己的fd，此时<code>oldfd=fd,newfd=1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test9</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ret = dup2(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) </span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret: %d\n&quot;</span>, ret);<span class="comment">//ret为newfd</span></span><br><span class="line">    <span class="comment">//本来往显示器打印，最终变成向指定文件打印 -&gt; 重定向</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;打开文件成功，fd: %d\n&quot;</span>, fd);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//刷新缓冲区</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，我们成功的将内容<code>printf</code>到了指定文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ &gt;log.txt</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">ret: 1</span><br><span class="line">打开文件成功，fd: 3</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><ul><li>为什么这里可以用<code>stdout</code>来输出到文件中呢？</li></ul><p>因为当我们使用<code>dup2</code>的时候，stdout所指向的文件描述符1已经被替换成了<code>log.txt</code>，此时对stdout的操作就是对我们自己的文件操作</p><ul><li>为什么这里我们已经把<code>fd</code>关掉了，但是替换掉的文件描述符<code>1</code>不受影响呢？</li></ul><p>同一个文件是可以被打开多次的！执行<code>dup2</code>的时候，可以理解为操作系统又一次打开了<code>fd</code>指向的文件，在文件底层，则有一个计数来判断该文件被打开了几次。当我们<code>close(fd)</code>的时候，只是让该文件底层<code>struct file</code>的打开计数<code>-1</code>，并非完全关闭了该文件！此时<code>1</code>还能正确指向<code>log.txt</code>呢</p><h3 id="追加重定向"><a href="#追加重定向" class="headerlink" title="追加重定向"></a>追加重定向</h3><p>这里只需要我们改变<code>fd</code>打开的方式，加上<code>O_APPEND</code>即可！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test9</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ret = dup2(fd, <span class="number">1</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) </span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret: %d\n&quot;</span>, ret);<span class="comment">//ret为newfd</span></span><br><span class="line">    <span class="comment">//本来往显示器打印，最终变成向指定文件打印 -&gt; 重定向</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;打开文件成功，fd: %d\n&quot;</span>, fd);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);<span class="comment">//刷新缓冲区</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可以看到，成功在后面追加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">ret: 1</span><br><span class="line">打开文件成功，fd: 3</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">ret: 1</span><br><span class="line">打开文件成功，fd: 3</span><br><span class="line">ret: 1</span><br><span class="line">打开文件成功，fd: 3</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入重定向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test11</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = dup2(fd,<span class="number">0</span>);<span class="comment">//重定向stdin</span></span><br><span class="line">    <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) </span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们的<code>stdin</code>被<code>dup2</code>替换成了<code>log.txt</code>，其获取输入的操作转为了读取文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">ret: 1</span><br><span class="line">打开文件成功，fd: 3</span><br><span class="line">ret: 1</span><br><span class="line">打开文件成功，fd: 3</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ ./test</span><br><span class="line">ret: 1</span><br><span class="line">打开文件成功，fd: 3</span><br><span class="line">ret: 1</span><br><span class="line">打开文件成功，fd: 3</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-18_files]$ </span><br></pre></td></tr></table></figure><h2 id="3-6-标准输出-x2F-标准错误"><a href="#3-6-标准输出-x2F-标准错误" class="headerlink" title="3.6 标准输出&#x2F;标准错误"></a>3.6 标准输出&#x2F;标准错误</h2><p>之前写代码的时候，我们常常直接使用了printf来打印一些错误信息，而没有怎么用过<code>perror/cerr</code>这两个库函数</p><p>那么它们和<code>printf/cout</code>又有什么区别呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// stdout</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello printf\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;hello fprintf to stdout\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;hello fputs to stdout\n&quot;</span>, stdout);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello cout&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stderr</span></span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;hello perror&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;hello fprintf to stderr\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;hello fputs to stderr\n&quot;</span>, stderr);</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;hello cerr&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试发现，似乎没有啥区别啊，不都打印到屏幕上了吗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test</span><br><span class="line">hello <span class="built_in">printf</span></span><br><span class="line">hello fprintf to stdout</span><br><span class="line">hello fputs to stdout</span><br><span class="line">hello cout</span><br><span class="line">hello perror: Success</span><br><span class="line">hello fprintf to stderr</span><br><span class="line">hello fputs to stderr</span><br><span class="line">hello cerr</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ </span><br></pre></td></tr></table></figure><p>非也！当我们使用重定向的时候，就出现问题了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &gt;log.txt</span><br><span class="line">hello perror: Success</span><br><span class="line">hello fprintf to stderr</span><br><span class="line">hello fputs to stderr</span><br><span class="line">hello cerr</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">hello <span class="built_in">printf</span></span><br><span class="line">hello fprintf to stdout</span><br><span class="line">hello fputs to stdout</span><br><span class="line">hello cout</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ </span><br></pre></td></tr></table></figure><p>欸？不是使用了重定向吗，为什么还在屏幕上输出了内容呢？</p><p>仔细一看，输出的都是<code>stderr</code>的内容，而没有<code>stdout</code>。cat文件一看，<code>stdout</code>的内容都在文件里面嘞！</p><p>还记得吗？<code>stdout/stderr</code>对应的文件描述符是<code>1/2</code>，而在默认情况下，它们都指向的是显示器。</p><blockquote><p>注意：虽然它们两个指向都是显示器，但它们是通过两个<strong>不同的文件描述符</strong>，独立地往显示器上打印内容的！</p></blockquote><p>我们重定向的时候，其实省略了一个1，默认情况下，重定向只对1号描述符，也就是stdout有效！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./test &gt;log.txt</span><br><span class="line">./test 1&gt;log.txt</span><br></pre></td></tr></table></figure><p>如果我们把这里的1换成2，结果就不一样了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test 2&gt;log.txt</span><br><span class="line">hello <span class="built_in">printf</span></span><br><span class="line">hello fprintf to stdout</span><br><span class="line">hello fputs to stdout</span><br><span class="line">hello cout</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">hello perror: Success</span><br><span class="line">hello fprintf to stderr</span><br><span class="line">hello fputs to stderr</span><br><span class="line">hello cerr</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ </span><br></pre></td></tr></table></figure><p>可以看到，stderr的内容进了文件，而stdout的内容输出到了屏幕上</p><h3 id="区分错误和正常输出"><a href="#区分错误和正常输出" class="headerlink" title="区分错误和正常输出"></a>区分错误和正常输出</h3><p>这么设计的意义，就是为了方便我们定位问题。将错误和正常的打印输出写道不同的文件中。如果我们像只关注错误，就只需要去查找记录了错误信息的文件即可</p><h3 id="混合输出2-gt-amp-1"><a href="#混合输出2-gt-amp-1" class="headerlink" title="混合输出2&gt;&amp;1"></a>混合输出2&gt;&amp;1</h3><p>如果我们就是不听不听，非要把他俩打一个文件里面，应该怎么弄呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test &gt;log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>这个<code>2&gt;&amp;1</code>的操作需要我们理解：</p><ul><li><code>./test</code>运行可执行程序</li><li><code>&gt;log.txt</code>代表重定向，默认只重定向了1</li><li>现在指向<code>log.txt</code>的是1号文件描述符，代表stdout</li><li><code>2&gt;&amp;1</code>代表将2重定向到1，可以理解为<code>dup2(1,2);</code></li><li>执行结束后，2就成了1的一份拷贝，现在只剩下了1</li><li>因为1指向的是<code>log.txt</code>，所以2也指向的是相同文件</li></ul><p>而这个语句必须写在<code>&gt;log.txt</code>的后面， 否则意义就错误了👇</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test 2&gt;&amp;1 &gt;log.txt <span class="comment">#错误写法</span></span><br></pre></td></tr></table></figure><ul><li><code>2&gt;&amp;1</code>代表将2重定向到1，此时1指向的是屏幕，所以2也指向了屏幕</li><li><code>&gt;log.txt</code>代表将1指向文件，此时1指向了文件，但是2还是指向屏幕</li><li>白写！</li></ul><p>执行了正确的命令后，来看看结果吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &gt;log.txt 2&gt;&amp;1</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txt</span><br><span class="line">hello printf</span><br><span class="line">hello fprintf to stdout</span><br><span class="line">hello fputs to stdout</span><br><span class="line">hello cout</span><br><span class="line">hello perror: Success</span><br><span class="line">hello fprintf to stderr</span><br><span class="line">hello fputs to stderr</span><br><span class="line">hello cerr</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ </span><br></pre></td></tr></table></figure><p>标准错误和标准输出的内容都被写入到文件中了！</p><p>上面的整法实在有点太长了，而且还有可能记不住写反了。所以有一种简写的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简写方式</span></span><br><span class="line">&amp;&gt;log.txt</span><br><span class="line"><span class="comment">#上面的写法等同于</span></span><br><span class="line">&gt;log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>测试一下，没问题！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ &gt;log.txt</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ ./test &amp;&gt;log.txt</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ cat log.txt</span><br><span class="line">hello printf</span><br><span class="line">hello fprintf to stdout</span><br><span class="line">hello fputs to stdout</span><br><span class="line">hello cout</span><br><span class="line">hello perror: Success</span><br><span class="line">hello fprintf to stderr</span><br><span class="line">hello fputs to stderr</span><br><span class="line">hello cerr</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ </span><br></pre></td></tr></table></figure><blockquote><p>关于<code>2&gt;&amp;1</code>的详解参考👉 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaominpro/article/details/82630528">传送门</a></p></blockquote><hr><h1 id="4-C语言缓冲区"><a href="#4-C语言缓冲区" class="headerlink" title="4.C语言缓冲区"></a>4.C语言缓冲区</h1><h2 id="4-1-观察现象"><a href="#4-1-观察现象" class="headerlink" title="4.1 观察现象"></a>4.1 观察现象</h2><p>先来看看下面的代码，分别调用C语言的<code>printf</code>和操作系统的<code>write</code>接口，往屏幕上打印内容。结束后<code>sleep(3)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test printf &quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*msg = <span class="string">&quot;test write &quot;</span>;</span><br><span class="line">    write(<span class="built_in">stdout</span>-&gt;_fileno,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/02/202210270937921.gif" alt="GIF"></p><p>我们惊奇的发现，第一个打印出来的竟然是<code>write</code>，而不是在它之前的<code>printf</code>接口！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test printf &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*msg = <span class="string">&quot;test write &quot;</span>;</span><br><span class="line">    write(<span class="built_in">stdout</span>-&gt;_fileno,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在<code>printf</code>后立马调用<code>fflush</code>刷新缓冲区，才能按正确的“顺序”打印出内容来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">printf</span> <span class="built_in">test</span> write [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ </span><br></pre></td></tr></table></figure><p>在调用其他C语言的函数，往屏幕上输出信息。我们会发现结果相同！都是先打印出来<code>write</code>结果，才<strong>一次性</strong>打印出所有C语言函数的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test printf &quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;test fprintf &quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;test fputs &quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*msg = <span class="string">&quot;test write &quot;</span>;</span><br><span class="line">    write(<span class="built_in">stdout</span>-&gt;_fileno,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test</span><br><span class="line"><span class="built_in">test</span> write <span class="built_in">test</span> <span class="built_in">printf</span> <span class="built_in">test</span> fprintf <span class="built_in">test</span> fputs [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ </span><br></pre></td></tr></table></figure><p>由此可见，之前我们一直提到的缓冲区，其实是<strong>C语言提供</strong>的！</p><blockquote><p>注意：缓冲区不止C语言内部有，操作系统内也有。本文只讨论C语言提供的缓冲区</p></blockquote><hr><h2 id="4-2-缓冲区在哪"><a href="#4-2-缓冲区在哪" class="headerlink" title="4.2 缓冲区在哪?"></a>4.2 缓冲区在哪?</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test printf &quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;test fprintf &quot;</span>);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;test fputs &quot;</span>,<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure><p>上面这几个函数都有一个共同的特点：它们都往<code>stdout</code>里面打印了内容！</p><blockquote><p><code>printf</code>虽然没有显示指定<code>stdout</code>，但是底层是有的</p></blockquote><p>我们知道，C语言的文件是一个<code>FILE</code>类型的结构体。该结构体内封装了很多属性，其中<code>stdout</code>的<code>_fileno</code>文件描述符，就是该<code>FILE</code>对应的语言级别的缓冲区！</p><h3 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h3><p>如果我们在数据刷新之前，关闭了<code>stdout</code>对应的文件描述符，会发生什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test printf &quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;test fprintf &quot;</span>);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;test fputs &quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*msg = <span class="string">&quot;test write &quot;</span>;</span><br><span class="line">write(<span class="built_in">stdout</span>-&gt;_fileno,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line">close(<span class="built_in">stdout</span>-&gt;_fileno);</span><br></pre></td></tr></table></figure><p>结果就是，啥都没有刷新！</p><p>缓冲区都被关闭了，其内部的数据都无了，肯定不会刷新啦~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt<span class="number">-7274</span>:~/git/linux/code/<span class="number">22</span><span class="number">-10</span><span class="number">-27</span>_buffer]$ ./test</span><br><span class="line">test write [muxue@bt<span class="number">-7274</span>:~/git/linux/code/<span class="number">22</span><span class="number">-10</span><span class="number">-27</span>_buffer]$ </span><br></pre></td></tr></table></figure><p>而在<a href="#jump">输出重定向</a>中，打印的内容没有直接被显示的，也是因为我们没有在关闭<code>fd</code>之前刷新<code>stdout</code>（此时指向的是fd）中的缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">close(<span class="number">1</span>);<span class="comment">//关闭stdout</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>,fd);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h3 id="FILE"><a href="#FILE" class="headerlink" title="FILE"></a>FILE</h3><p>既然stdout的缓冲区在FILE内部，推而广之，所有用C语言打开的文件，<code>FILE</code>中都会有一个<strong>文件描述符</strong>和它自己的<strong>语言级别缓冲区</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure><p>库函数中的<code>FILE</code>是一个<code>struct _IO_FILE</code>类型的结构体，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//下面这些就是它的缓冲区</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">//文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到有多个变量用于维护该文件的缓冲区，也证实了缓冲区是由C语言提供的这一结论。</p><h2 id="4-3-缓冲区的作用"><a href="#4-3-缓冲区的作用" class="headerlink" title="4.3 缓冲区的作用"></a>4.3 缓冲区的作用</h2><p>C语言提供缓冲区的理由很简单，相对于内存而言，其余硬件都是满设备。</p><ul><li>为代码提供缓冲区，可以提高该程序&#x2F;进程输出的效率</li><li>缓冲区可以集中处理数据刷新，减少IO的次数，提高了<strong>整机</strong>运行效率</li></ul><h2 id="4-4-什么时候刷新缓冲区？"><a href="#4-4-什么时候刷新缓冲区？" class="headerlink" title="4.4 什么时候刷新缓冲区？"></a>4.4 什么时候刷新缓冲区？</h2><p>什么时候刷新缓冲区，对应的是<code>刷新策略</code>问题</p><p><span id="jump1">常规的刷新策略</span></p><ul><li>无缓冲（立即刷新）</li><li>行缓冲（逐行刷新）</li><li>全缓冲（缓存区满，刷新）</li></ul><p>特殊情况</p><ul><li>进程退出（刷新）</li><li>用户调用函数，强制刷新</li></ul><h3 id="刷新与子进程"><a href="#刷新与子进程" class="headerlink" title="刷新与子进程"></a>刷新与子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*str1=<span class="string">&quot;test printf\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*str2=<span class="string">&quot;test fprintf\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*str3=<span class="string">&quot;test fputs\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*str4=<span class="string">&quot;test write\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C语言</span></span><br><span class="line">    <span class="built_in">printf</span>(str1);<span class="comment">//这样写也是ok的</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,str2);</span><br><span class="line">    <span class="built_in">fputs</span>(str3,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统接口</span></span><br><span class="line">    write(<span class="built_in">stdout</span>-&gt;_fileno,str4,<span class="built_in">strlen</span>(str4));</span><br><span class="line">    <span class="comment">//子进程创建</span></span><br><span class="line">    fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，会出现两种运行情况</p><ul><li>如果直接打印到屏幕上，打印的顺序和内容都是正确的</li><li>如果重定向到文件中，却发现C语言打印的内容都多打了一次！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">printf</span></span><br><span class="line"><span class="built_in">test</span> fprintf</span><br><span class="line"><span class="built_in">test</span> fputs</span><br><span class="line"><span class="built_in">test</span> write</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test &gt; log.txt</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ <span class="built_in">cat</span> log.txt</span><br><span class="line"><span class="built_in">test</span> write</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">printf</span></span><br><span class="line"><span class="built_in">test</span> fprintf</span><br><span class="line"><span class="built_in">test</span> fputs</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">printf</span></span><br><span class="line"><span class="built_in">test</span> fprintf</span><br><span class="line"><span class="built_in">test</span> fputs</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ </span><br></pre></td></tr></table></figure><p>刷新的本质，其实就是把缓冲区中数据，调用<code>write</code>接口通过操作系统写入到文件中。而<code>FILE</code>内部的缓冲区，是属于<strong>父进程内部</strong>的数据。</p><p>当我们在刷新之前<code>fork</code>创建子进程的时候，会发生一次<strong>写时拷贝</strong></p><p>结果就是父进程、子进程<strong>各刷新一次</strong>。于是就出现了上面的C语言的内容多了一份的现象！</p><hr><h2 id="4-5-简单模拟实现"><a href="#4-5-简单模拟实现" class="headerlink" title="4.5 简单模拟实现"></a>4.5 简单模拟实现</h2><p>缓冲区，本质就是C语言在文件的结构体中维护的一个数组。同时维护了多种<a href="#jump1">刷新策略</a>，在不同的时刻将该数组的内容调用系统接口<code>write</code>写入文件</p><p>这里我们提供了一个简单的<code>MyFILE</code>结构体，内部封装文件描述符、刷新策略、缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NONE_FLUSH 0x0 <span class="comment">//无刷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINE_FLUSH 0x1 <span class="comment">//行刷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FULL_FLUSH 0x2 <span class="comment">//全缓存</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyFILE</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> _fileno;</span><br><span class="line">    <span class="type">char</span> _buffer[NUM];</span><br><span class="line">    <span class="type">int</span> _end;<span class="comment">//缓冲区结尾</span></span><br><span class="line">    <span class="type">int</span> _fflags; <span class="comment">//刷新策略</span></span><br><span class="line">&#125;MyFILE;</span><br></pre></td></tr></table></figure><p>有了自己的文件结构体，对应的也需要分装一下系统的<code>open/read/write/close</code>等接口，还有<code>fflush</code>用于强制刷新</p><hr><h3 id="封装接口"><a href="#封装接口" class="headerlink" title="封装接口"></a>封装接口</h3><p>为了做到尽量简单，这里暂时只封装<code>r/w/a</code>三种打开方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">MyFILE *<span class="title function_">my_fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *method)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(filename);</span><br><span class="line">    assert(method);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags = O_RDONLY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(method, <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flags = O_RDONLY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(method, <span class="string">&quot;w&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flags = O_WRONLY | O_CREAT | O_TRUNC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(method, <span class="string">&quot;a&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flags = O_WRONLY | O_CREAT | O_APPEND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fileno = open(filename, flags, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(fileno &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyFILE *fp = (MyFILE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyFILE));</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) <span class="keyword">return</span> fp;</span><br><span class="line">    <span class="built_in">memset</span>(fp, <span class="number">0</span>, <span class="keyword">sizeof</span>(MyFILE));</span><br><span class="line">    fp-&gt;_fileno = fileno;</span><br><span class="line">    fp-&gt;_fflags |= LINE_FLUSH;<span class="comment">//默认行缓冲</span></span><br><span class="line">    fp-&gt;_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里暂时只用行缓冲和全缓冲来体验一下缓冲区的作用。同时只对字符串结尾的<code>\n</code>进行了判断，情况不够全面。</p><blockquote><p>这里其实我很好奇，C库里面是怎么处理<code>\n</code>的捏；总不能用遍历吧？那样效率也太低了。个人猜测是和预先设置的特殊字符有关系。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_fwrite</span><span class="params">(MyFILE *fp, <span class="type">const</span> <span class="type">char</span> *start, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(fp);</span><br><span class="line">    assert(start);</span><br><span class="line">    assert(len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先写入到缓冲区里面</span></span><br><span class="line">    <span class="built_in">strncpy</span>(fp-&gt;_buffer+fp-&gt;_end, start, len); <span class="comment">//将数据写入到缓冲区了</span></span><br><span class="line">    fp-&gt;_end += len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp-&gt;_fflags &amp; NONE_FLUSH)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fp-&gt;_fflags &amp; LINE_FLUSH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里的判断只是测试，实际上还需要判断中间有无\n</span></span><br><span class="line">        <span class="keyword">if</span>(fp-&gt;_end &gt; <span class="number">0</span> &amp;&amp; fp-&gt;_buffer[fp-&gt;_end<span class="number">-1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//写入到内核中</span></span><br><span class="line">            write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);</span><br><span class="line">            fp-&gt;_end = <span class="number">0</span>;</span><br><span class="line">            syncfs(fp-&gt;_fileno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fp-&gt;_fflags &amp; FULL_FLUSH)</span><br><span class="line">    &#123;<span class="comment">//满了刷新</span></span><br><span class="line">        <span class="keyword">if</span>(fp-&gt;_end &gt; <span class="number">0</span> &amp;&amp; fp-&gt;_end==NUM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//写入到内核中</span></span><br><span class="line">            write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);</span><br><span class="line">            fp-&gt;_end = <span class="number">0</span>;</span><br><span class="line">            syncfs(fp-&gt;_fileno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个新接触的函数<code>syncfs</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syncfs</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>该函数是一个系统调用接口，用于将文件内核缓冲区内的数据写入到指定文件中。</p><p>前面我们提到的缓冲区，一直说的都是C语言内部维护的。从这个接口也能看出，操作系统同样对文件进行了缓冲区的维护。</p><p><img src="https://img.musnow.top/i/2023/02/202210310827200.png" alt="image-20221031082754128"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_fflush</span><span class="params">(MyFILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(fp);</span><br><span class="line">    <span class="keyword">if</span>(fp-&gt;_end &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fp-&gt;_fileno, fp-&gt;_buffer, fp-&gt;_end);</span><br><span class="line">        fp-&gt;_end = <span class="number">0</span>;</span><br><span class="line">        syncfs(fp-&gt;_fileno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_fclose</span><span class="params">(MyFILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_fflush(fp);</span><br><span class="line">    close(fp-&gt;_fileno);</span><br><span class="line">    <span class="built_in">free</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyFILE *fp = my_fopen(<span class="string">&quot;log.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_fopen error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a = <span class="string">&quot;hello my 111\n&quot;</span>;</span><br><span class="line">    my_fwrite(fp, a, <span class="built_in">strlen</span>(a));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;消息立即刷新\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *b = <span class="string">&quot;hello my 222 &quot;</span>;</span><br><span class="line">    my_fwrite(fp, b, <span class="built_in">strlen</span>(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写入了一个不满足刷新条件的字符串\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *c = <span class="string">&quot;hello my 333 &quot;</span>;</span><br><span class="line">    my_fwrite(fp, c, <span class="built_in">strlen</span>(c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写入了一个不满足刷新条件的字符串\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *d = <span class="string">&quot;end\n&quot;</span>;</span><br><span class="line">    my_fwrite(fp, d, <span class="built_in">strlen</span>(d));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写入了一个满足刷新条件的字符串\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    my_fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序结束\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始的时候，我们写入了一个<code>\n</code>结尾的字符串，其立马写入到了文件中</p><p><img src="https://img.musnow.top/i/2023/02/202210310837274.png" alt="image-20221031083740203"></p><p>随后写入了两个不满足刷新条件的字符串，文件中没有出现结果</p><p><img src="https://img.musnow.top/i/2023/02/202210310843013.png" alt="image-20221031084319928"></p><p><img src="https://img.musnow.top/i/2023/02/202210310845723.png" alt="image-20221031084533660"></p><p>而当我们写入一个满足刷新条件的字符串后，缓冲区的内容就<strong>同时</strong>被写入到文件中了！</p><p><img src="https://img.musnow.top/i/2023/02/202210310844732.png" alt="image-20221031084426633"></p><h3 id="子进程测试"><a href="#子进程测试" class="headerlink" title="子进程测试"></a>子进程测试</h3><p>除此之外，我们还可以测试一下子进程是否会出现刷新两次的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(MyFILE * fp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;-test &quot;</span>;</span><br><span class="line">    my_fwrite(fp, s, <span class="built_in">strlen</span>(s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写入了一个不满足刷新条件的字符串\n&quot;</span>);</span><br><span class="line">    fork();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyFILE *fp = my_fopen(<span class="string">&quot;log.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my_fopen error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test1(fp);</span></span><br><span class="line">    test2(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟进程退出</span></span><br><span class="line">    my_fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序结束\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如我们所料，文件中出现了两个<code>-test</code>，原因在<code>4.4</code>中已做解释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ ./test1</span><br><span class="line">写入了一个不满足刷新条件的字符串</span><br><span class="line">程序结束</span><br><span class="line">程序结束</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ <span class="built_in">cat</span> log.txt</span><br><span class="line">-<span class="built_in">test</span> -<span class="built_in">test</span> [muxue@bt-7274:~/git/linux/code/22-10-27_buffer]$ </span><br></pre></td></tr></table></figure><hr><h1 id="5-文件系统"><a href="#5-文件系统" class="headerlink" title="5.文件系统"></a>5.文件系统</h1><p>之前我们提到的这些数据，都是存放在内存中的。接下来我们便要来了解一下操作系统是如何管理磁盘上的文件。</p><hr><h2 id="5-1-磁盘的物理结构"><a href="#5-1-磁盘的物理结构" class="headerlink" title="5.1 磁盘的物理结构"></a>5.1 磁盘的物理结构</h2><p>以机械硬盘为例，其内部主要由盘片和磁头组成。</p><p><img src="https://img.musnow.top/i/2023/02/202211011519001.png" alt="image-20221101151954853"></p><p>当我们改变磁盘上某一个位置的NS极，就好比更改了此处保存的数据<code>0/1</code></p><p><img src="https://img.musnow.top/i/2023/02/202211011523967.png" alt="image-20221101152349875"></p><p>在机械硬盘中，一个盘片对应一个磁头</p><ul><li>每个盘片被分为诺干个同心圆，每一个同心圆就是一个<code>磁道</code></li><li>每个磁道被划分为诺干<code>段</code>（扇区）</li><li>每个扇区的存储容量为<code>512字节</code></li></ul><p>由此可见，当我们读写机械硬盘的时候，需要去找某一个盘面、某一个磁道的某一片扇区，就能找到该扇区的数据！</p><ul><li>盘面（磁面）有自己对应的磁头</li><li>磁道是由距离圆心的半径决定的</li><li>扇区是由盘面旋转决定的</li></ul><p>而操作系统的文件系统所作的工作，便是将文件和其对应的<strong>扇区</strong>联系起来。用上面提到的办法，便可以查找到每一个扇区！</p><p><img src="https://img.musnow.top/i/2023/02/202211011600086.png" alt="image-20221101160047022"></p><p>这种查找数据位置的操作，被称为<code>CHS寻址</code>，<code>CHS</code>分别对应磁柱、磁面、扇区</p><h2 id="5-2-CHS和LBA"><a href="#5-2-CHS和LBA" class="headerlink" title="5.2 CHS和LBA"></a>5.2 CHS和LBA</h2><blockquote><p>更详细的解析参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jadeshu/article/details/89072512">https://blog.csdn.net/jadeshu/article/details/89072512</a></p></blockquote><p>假设我们把一个磁道的数据“拉直”，其就变成了一条直线。依此类推，可以把每一个盘面上的每一条磁道都“拉直”</p><p><img src="https://img.musnow.top/i/2023/02/202211011606527.png" alt="image-20221101160644467"></p><p>最终，其不就变成了和上图类似的“长条状”了吗？我们学过的什么数据结构也是线性长条的捏？</p><p>没错！就是<strong>数组</strong>！</p><p>此时，对磁盘文件的修改，就可以抽象成对内核中一个数组的<strong>增删查改</strong>操作！</p><p>这种抽象之后的磁盘，被称为<code>LBA逻辑块地址</code>，他们之中有一个转换关系👇</p><p>用C表示当前柱面号，H表示当前磁头号，S表示当前扇区号，CS表示起始柱面号，HS表示起始磁头号，SS表示起始扇区号，PS表示每磁道有多少个扇区，PH表示每柱面有多少个磁道，计算公式如下：<br>$$<br>LBA &#x3D; ( C – CS ) * PH * PS + ( H – HS ) * PS + ( S – SS )<br>$$<br>通过这个公式，我们就能将磁盘中的一个区块的数据，转为数组中的一个下标，来方便操作系统访问<br>$$<br>C &#x3D; LBA &#x2F; ( PH * PS ) + CS<br>$$</p><p>$$<br>H &#x3D; ( LBA &#x2F; PS ) % PH + HS<br>$$</p><p>$$<br>S &#x3D; LBA &#x2F; PS + SS<br>$$<br>修改了<strong>数组</strong>中的数据之后，操作系统将LBA对应的CHS地址算出来交给<strong>磁盘</strong>，让磁盘来修改指定扇区的数据，便实现了保存数据到磁盘中的操作</p><hr><h2 id="5-3-IO的基本单位"><a href="#5-3-IO的基本单位" class="headerlink" title="5.3 IO的基本单位"></a>5.3 IO的基本单位</h2><p>对于操作系统而言，一次IO的基本单位是4kb，也就是8个扇区<code>8*512字节</code></p><ul><li>磁盘的基本单位：扇区（一般为512字节)</li><li>文件系统访问磁盘的基本单位：<code>4kb</code></li></ul><p>在操作系统中，会对前面提到的那个“数组”进一步抽象，8个扇区会被合并成一个<code>4KB</code>的区块，用于<code>单次IO</code>。为了方便管理每一个区块，又将多个区块合并，作为一个<strong>分区</strong>进行管理</p><p>这便是我们电脑上同一块物理硬盘可以对应<strong>不同分区</strong>的来源了！</p><hr><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>为什么操作系统要以4kb作为<code>IO</code>的基本单位呢？</p><blockquote><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/617936.html">https://www.51cto.com/article/617936.html</a></p></blockquote><p>在上文中提到，Linux选择4KB作为“页操作”（即读取内存，以及从内存写入磁盘）的基本单位算是一个历史遗留问题了。</p><ul><li>过小的页大小会带来较大的寻址开销</li><li>过大的页大小浪费内存空间，造成内存碎片</li></ul><p>而当初这么选择，肯定是有其功用的！</p><ul><li>能提高IO效率，不需要多次写入512字节的数据</li><li>不让文件系统的设计和磁盘有强相关性，解耦合</li></ul><p>对于第二点进行说明，如果文件系统不在扇区外额外选择一个空间作为IO的基本单位，那么其设计必定会依赖于<strong>磁盘扇区大小</strong>。</p><p>如果某一天，所有磁盘的扇区大小都从512字节变成了1024字节，那就必须要<strong>修改操作系统的源码</strong>，才能正确访问新的硬盘。同时还需要对旧盘做优化，可谓事倍功半。</p><p>而提前设定好一个更大的IO基本单位，便是避免了磁盘变动而造成的无法访问。有了这个更大的IO基本单位，我们只需要把磁盘的扇区组成一个4kb大小的空间进行IO，不用管其磁盘扇区大小到底是多少了。</p><blockquote><p>当然，如果哪天扇区大小大于4kb了，恐怕就得改源码了？</p><p>这部分我也不是很懂呢，以上只是个人浅显的理解</p></blockquote><hr><h2 id="5-4-系统结构"><a href="#5-4-系统结构" class="headerlink" title="5.4 系统结构"></a>5.4 系统结构</h2><p>下图向我们展示了一个磁盘是如何被文件系统“拆分”的</p><p>首先是分区，每一个分区都有一个<code>BootSector</code>和文件系统。我们主要关注文件系统中，单个<code>Block Group</code>里面的内容</p><p><img src="https://img.musnow.top/i/2023/02/202211021025226.png" alt="image-20221102102453953"></p><p>linux采用的是文件内容、文件属性分开存放的存储方式</p><ul><li>文件的属性是稳定的</li><li>文件的内容在不断增多</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data blocks：保存数据内容</span><br><span class="line">inode table：保存文件的inode</span><br><span class="line">inode bitmap：位图结构，指示inode是否被使用</span><br><span class="line">GDT：全称group descriptor table，保存了inode个数、起始inode编号、多少inode被使用、多少data blocks被使用……</span><br><span class="line">Super Blocks：该Block Group文件系统的顶层数据结构</span><br></pre></td></tr></table></figure><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>这里提到的<code>inode</code>是linux下每一个文件的独立编号。linux并不以文件名来识别文件，而是用文件编号来识别唯一的文件的。</p><p>inode保存了一个文件的基本信息</p><ul><li>文件的属性</li><li>rwx权限</li><li>所属用户、所属组</li><li>硬链接个数</li><li>文件访问、修改、创建的时间</li><li>指向<code>data blocks</code>中文件的内容</li></ul><blockquote><p><code>struct inode</code>的位置在<code>/include/linux/fs.h</code></p><p><img src="https://img.musnow.top/i/2023/02/202211021502761.png" alt="image-20221102150228669"></p></blockquote><p>查看inode编号的方法为<code>ls -i</code>，其中这串数字便是该文件的inode编号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ <span class="built_in">ls</span> -i</span><br><span class="line">1453833 makefile  1453832 test.cpp</span><br></pre></td></tr></table></figure><p>我们也可以看到，<code>.和..</code>这两个文件夹也是有自己的inode编号的，印证了linux下一切皆文件，包括目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ <span class="built_in">ls</span> -ila</span><br><span class="line">total 16</span><br><span class="line">1453831 drwxrwxr-x  2 muxue muxue 4096 Nov  2 09:58 .</span><br><span class="line">1443736 drwxrwxr-x 16 muxue muxue 4096 Nov  2 09:20 ..</span><br><span class="line">1453833 -rw-rw-r--  1 muxue muxue   81 Nov  2 09:58 makefile</span><br><span class="line">1453832 -rw-rw-r--  1 muxue muxue  437 Nov  2 09:35 test.cpp</span><br></pre></td></tr></table></figure><h3 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h3><p>还可以用stat命令来查看单个文件的inode信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt<span class="number">-7274</span>:~/git/linux/code/<span class="number">22</span><span class="number">-10</span><span class="number">-31</span>_stdout_err]$ stat test.cpp</span><br><span class="line">  File: ‘test.cpp’</span><br><span class="line">  Size: <span class="number">437</span>             Blocks: <span class="number">8</span>          IO Block: <span class="number">4096</span>   regular file</span><br><span class="line">Device: fd01h/<span class="number">64769</span>d    Inode: <span class="number">1453832</span>     Links: <span class="number">1</span></span><br><span class="line">Access: (<span class="number">0664</span>/-rw-rw-r--)  Uid: ( <span class="number">1001</span>/   muxue)   Gid: ( <span class="number">1001</span>/   muxue)</span><br><span class="line">Access: <span class="number">2022</span><span class="number">-11</span><span class="number">-02</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">07.684160444</span> +<span class="number">0800</span></span><br><span class="line">Modify: <span class="number">2022</span><span class="number">-11</span><span class="number">-02</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">04.328161202</span> +<span class="number">0800</span></span><br><span class="line">Change: <span class="number">2022</span><span class="number">-11</span><span class="number">-02</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">04.328161202</span> +<span class="number">0800</span></span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>inode内部有一个结构，指向<code>data blocks</code>。前面提到过，文件系统IO的基本单位是4KB，对应的，一个blocks的大小就是4KB</p><p>每一个文件都对应一个inode，至少对应一个data blocks（inode中储存了blocks编号）</p><p>因为inode所能保存的编号有限，所以对data blocks的保存分为两种情况</p><ol><li>部分data blocks直接保存了文件的内容。如果是小文件，inode中保存的block就足够存下所有文件内容了</li><li>如果是大文件，inode中一部分blocks会用来保存该文件剩余<code>data blocks</code>的编号</li></ol><p>在内核中，文件系统会对这两种情况进行区分</p><p><font color="Red">注意</font></p><ul><li>因为每一个文件都肯定有一个inode与之对应，所以创建空文件也是占用磁盘空间的</li><li>可能会出现inode被用完了，磁盘空间却没有满的情况。但这时候也已经无法创建新文件了</li></ul><p>😂你可以尝试写一个while1循环，不断往系统中创建新文件，看看能不能达到这个临界值（咳咳，虽然好玩，但<strong>并不推荐</strong>你这么做）</p><hr><h3 id="文件名存在哪儿？"><a href="#文件名存在哪儿？" class="headerlink" title="文件名存在哪儿？"></a>文件名存在哪儿？</h3><p>前面提到过，inode保存了文件的属性，文件名是否为文件的属性呢？也算！</p><p>但inode中并不保存文件名字！</p><p>实际上，文件名是存在该文件所在<strong>目录的文件内容</strong>中的</p><blockquote><p>目录也是文件，文件就有文件属性+文件内容</p></blockquote><p>可以理解为，目录的内容保存的是一个键值对，其中key为文件名，value为inode编号</p><p>这便是为何一个目录中<strong>不能出现同名文件</strong>，这是一个不支持键值冗余的<code>map(cpp-stl)</code></p><h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><p>既然目录也是文件，那么它就也有自己的文件权限</p><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/125776348">https://blog.csdn.net/muxuen/article/details/125776348</a></p></blockquote><p>在我之前关于linux文件权限的讲解中，就提到了和目录有关的权限问题</p><ul><li>进入目录需要x权限</li><li>创建文件需要w权限</li><li>查看文件名需要r权限</li></ul><p>了解文件系统了之后，现在我们知道为什么目录的操作需要这些权限了。在目录下创建文件，本质就是在修改目录所对应的<strong>文件内容</strong>！</p><p><img src="https://img.musnow.top/i/2023/02/202211021535708.jpg" alt="QQ图片20220424132540"></p><h2 id="5-5-创建-x2F-删除文件"><a href="#5-5-创建-x2F-删除文件" class="headerlink" title="5.5 创建&#x2F;删除文件"></a>5.5 创建&#x2F;删除文件</h2><p>当我们创建一个文件的时候，文件系统做了什么捏？</p><ul><li>创建一个新的文件结构体，和对应的inode编号</li><li>根据目录的inode，找到该目录的data blocks</li><li>将文件名和inode编号的对应关系写入到目录的数据块中</li></ul><p>当我们删除一个文件的时候：</p><ul><li>操作系统只需要删除当前目录下inode和文件名的对应关系</li><li>同时在inode bitmap中将对应的inode置为0（代表没有使用）</li></ul><p>这样就算是删除该文件了！好比我们操作线性表进行尾删操作，只是对<code>size-1</code>，并没有真的把该位置的数据删除</p><ul><li>这便能解释为什么复制粘贴一个文件的速度远慢于删除文件的速度</li><li>因为没有将文件的inode和data block清空，所以给我们<code>恢复数据</code>带来了可能。只要该文件之前使用的<code>inode/data block</code>并没有被复写，我们就有可能还原出该文件的数据！</li></ul><p><img src="https://img.musnow.top/i/2023/02/202211021557390.jpg" alt="好得很"></p><h1 id="6-软硬链接"><a href="#6-软硬链接" class="headerlink" title="6.软硬链接"></a>6.软硬链接</h1><p>在最初学习linux命令行的时候，就已经学习过了<code>ln</code>创建文件链接的操作</p><blockquote><p>这部分我没有写博客，因为网上的教程实在是太多啦</p></blockquote><p>但是当时并不知道<code>软链接/硬链接</code>到底有什么区别，学习了文件系统之后，回头再来看看</p><hr><h2 id="6-1-查看文件硬链接个数"><a href="#6-1-查看文件硬链接个数" class="headerlink" title="6.1 查看文件硬链接个数"></a>6.1 查看文件硬链接个数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -li</span><br></pre></td></tr></table></figure><p>当我们执行上面这个命令的时候，可以看到每一个文件的完整属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ <span class="built_in">ls</span> -lia</span><br><span class="line">total 16</span><br><span class="line">1453831 drwxrwxr-x  2 muxue muxue 4096 Nov  2 09:58 .</span><br><span class="line">1443736 drwxrwxr-x 16 muxue muxue 4096 Nov  2 09:20 ..</span><br><span class="line">1453833 -rw-rw-r--  1 muxue muxue   81 Nov  2 09:58 makefile</span><br><span class="line">1453832 -rw-rw-r--  1 muxue muxue  437 Nov  2 09:35 test.cpp</span><br></pre></td></tr></table></figure><p>可之前一直没有去了解，这个第三列的<code>2 16 1 1</code>到底是什么玩意呢？</p><p>不卖关子，前面提到inode会保存文件的硬链接个数，第三列的数字，代表的便是该文件的硬链接个数！</p><p>这里我们创建一个新的文件夹，和一个新的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ <span class="built_in">mkdir</span> test_r</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ <span class="built_in">touch</span> test_f</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ <span class="built_in">ls</span> -li</span><br><span class="line">total 12</span><br><span class="line">1453833 -rw-rw-r-- 1 muxue muxue   81 Nov  2 09:58 makefile</span><br><span class="line">1453832 -rw-rw-r-- 1 muxue muxue  437 Nov  2 09:35 test.cpp</span><br><span class="line">1453836 -rw-rw-r-- 1 muxue muxue    0 Nov  2 16:07 test_f</span><br><span class="line">1449813 drwxrwxr-x 2 muxue muxue 4096 Nov  2 16:07 test_r</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-10-31_stdout_err]$ </span><br></pre></td></tr></table></figure><p>你会发现，文件夹默认的硬链接数是2，而文件默认的硬链接数是1</p><h3 id="为什么？-1"><a href="#为什么？-1" class="headerlink" title="为什么？"></a>为什么？</h3><p>当我们cd进入目录的时候，linux便会找到底层的inode，进入该inode所对应的文件中。</p><p>如果想知道一个目录的目录名，我们必须要去该目录的<strong>上级</strong>找。</p><p>为了方便查找当前目录以及其上级目录的inode，每一个目录下面，默认都会有<code>..和.</code>这两个目录文件！</p><p>进入刚刚我们新创的文件夹看看，你会发现，<code>.</code>文件的inode就是该文件夹的inode！</p><p><img src="https://img.musnow.top/i/2023/02/202211021609412.png" alt="image-20221102160940330"></p><p>从这里便引出了软连接和硬链接的区别</p><h2 id="6-2-软硬链接区别"><a href="#6-2-软硬链接区别" class="headerlink" title="6.2 软硬链接区别"></a>6.2 软硬链接区别</h2><p>这里我创建了一个新文件夹，在里面创建了一个<code>test.c</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">ls</span> -li</span><br><span class="line">total 4</span><br><span class="line">1453842 -rw-rw-r-- 1 muxue muxue 78 Nov  2 16:13 test.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ </span><br></pre></td></tr></table></figure><p>同时对该文件夹创建一个硬链接和软连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s 源 目标 <span class="comment">#创建软连接</span></span><br><span class="line"><span class="built_in">ln</span> 源 目标 <span class="comment">#创建硬链接</span></span><br></pre></td></tr></table></figure><p>康康结果👇</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">ln</span> -s test.c testSoft.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">ls</span> -li</span><br><span class="line">total 4</span><br><span class="line">1453842 -rw-rw-r-- 1 muxue muxue 78 Nov  2 16:13 test.c</span><br><span class="line">1453843 lrwxrwxrwx 1 muxue muxue  6 Nov  2 16:14 testSoft.c -&gt; test.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">ln</span> test.c testHard.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">ls</span> -li</span><br><span class="line">total 8</span><br><span class="line">1453842 -rw-rw-r-- 2 muxue muxue 78 Nov  2 16:13 test.c</span><br><span class="line">1453842 -rw-rw-r-- 2 muxue muxue 78 Nov  2 16:13 testHard.c</span><br><span class="line">1453843 lrwxrwxrwx 1 muxue muxue  6 Nov  2 16:14 testSoft.c -&gt; test.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ </span><br></pre></td></tr></table></figure><p>你能看出区别吗？</p><ul><li>软链接的inode和源文件不相同，是一个全新的文件</li><li>硬链接的inode和源文件相同！同时它们的硬链接数+1</li></ul><p>把这些文件都以指针理解，会更方便一些</p><p><img src="https://img.musnow.top/i/2023/02/202211021631401.png" alt="image-20221102163102293"></p><ul><li>软连接的文件内容是所指向文件的路径</li><li>硬链接只是在当前目录下新增文件名和inode编号的<strong>映射关系</strong>，并对inode中硬链接个数+1</li></ul><p>如果我们删除了<code>test.c</code>，软连接就会失效，但硬链接并不会，因为硬链接本身和<code>test.c</code>是一个东西！</p><p><img src="https://img.musnow.top/i/2023/02/202211021623566.png" alt="image-20221102162339477"></p><p>而inode中对硬链接的计数，就好比C++中智能指针的引用计数，如果该计数为0，就代表这个文件需要删除了！</p><hr><h3 id="解答！"><a href="#解答！" class="headerlink" title="解答！"></a>解答！</h3><p>知道了区别，我们也便知道为何一个新目录的<strong>默认硬链接个数是2</strong>了，其便是每一个目录都默认带的<code>.</code>文件，用于标识当前目录的inode；另外一个是该文件本身</p><ul><li>每一个新创建的文件，默认都和自己映射，所以硬链接个数为1</li></ul><p>同时，我们也可以通过<code>..</code>文件的硬链接个数，快速知道上级目录中有多少个文件夹（除去默认的<code>.和..</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上级目录内的文件夹个数 = 当前目录..文件的硬链接个数 - 2</span><br><span class="line">某一个目录内的文件夹个数 = 该目录..文件的硬链接个数 - 2</span><br></pre></td></tr></table></figure><h2 id="6-3-unlink命令"><a href="#6-3-unlink命令" class="headerlink" title="6.3 unlink命令"></a>6.3 unlink命令</h2><p>我们可以通过unlink命令来取消链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">ls</span></span><br><span class="line">testHard.c  testSoft.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">unlink</span> testSoft.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">ls</span> -lia</span><br><span class="line">total 12</span><br><span class="line">1453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:39 .</span><br><span class="line">1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..</span><br><span class="line">1453842 -rw-rw-r--  1 muxue muxue   78 Nov  2 16:13 testHard.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ </span><br></pre></td></tr></table></figure><p>unlink也可以用来删除正常文件，但一般只用它来删除链接文件！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">ls</span> -lia</span><br><span class="line">total 12</span><br><span class="line">1453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:39 .</span><br><span class="line">1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..</span><br><span class="line">1453842 -rw-rw-r--  1 muxue muxue   78 Nov  2 16:13 testHard.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">unlink</span> testHard.c</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/22-11-01_软硬链接]$ <span class="built_in">ls</span> -lia</span><br><span class="line">total 8</span><br><span class="line">1453838 drwxrwxr-x  2 muxue muxue 4096 Nov  2 16:40 .</span><br><span class="line">1443736 drwxrwxr-x 17 muxue muxue 4096 Nov  2 16:12 ..</span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>linux文件系统的内容，到这里就over辣！后续如果有什么新增知识，会来这里添加！</p><p><img src="https://img.musnow.top/i/2023/02/202211021643449.gif" alt="QQ图片20220520121536"></p><p>感谢你看到最后，如果有什么问题，可以在评论区提出哦</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/2864480005/">https://blog.musnow.top/posts/2864480005/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E6%96%87%E4%BB%B6/">文件</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/gm4.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2737580475/" title="【Linux】动静态库"><img class="cover" src="/img/bg/gm6.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Linux】动静态库</div></div></a></div><div class="next-post pull-right"><a href="/posts/520771444/" title="【C++】文件IO流"><img class="cover" src="/img/bg/gm6.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【C++】文件IO流</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/977518181/" title="【Linux】环境变量"><img class="cover" src="/img/bg/gm23.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-05</div><div class="title">【Linux】环境变量</div></div></a></div><div><a href="/posts/1845419185/" title="【Linux】进程地址空间"><img class="cover" src="/img/bg/gm3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-07</div><div class="title">【Linux】进程地址空间</div></div></a></div><div><a href="/posts/656771008/" title="【Linux】使用腾讯云搭建CentOS的Linux编程学习环境，实现多用户使用同一个云服务器"><img class="cover" src="/img/bg/gm15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-06</div><div class="title">【Linux】使用腾讯云搭建CentOS的Linux编程学习环境，实现多用户使用同一个云服务器</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Artalk</span><span class="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">285</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-text">1.什么是文件？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">1.2 C语言文件操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%9D%E8%AF%86Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.初识Linux系统的文件接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-text">2.1 读文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">2.2 写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%B9%E5%BC%8F%E8%A6%86%E7%9B%96%EF%BC%9F"><span class="toc-text">写方式覆盖？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">3.文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%8E3%E5%BC%80%E5%A7%8B%EF%BC%9F"><span class="toc-text">3.1 为什么是从3开始？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%B0%83%E7%94%A8stdin-x2F-out"><span class="toc-text">用文件描述符调用stdin&#x2F;out</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BB%8E0%E5%BC%80%E5%A7%8B%EF%BC%9F%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%EF%BC%81"><span class="toc-text">3.2 从0开始？数组下标！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Linux%E4%B8%8B%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6"><span class="toc-text">3.3 Linux下一切皆文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-text">3.4 分配规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">输出重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-dup2"><span class="toc-text">3.5 dup2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">追加重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">输入重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA-x2F-%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF"><span class="toc-text">3.6 标准输出&#x2F;标准错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E9%94%99%E8%AF%AF%E5%92%8C%E6%AD%A3%E5%B8%B8%E8%BE%93%E5%87%BA"><span class="toc-text">区分错误和正常输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA2-gt-amp-1"><span class="toc-text">混合输出2&gt;&amp;1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-C%E8%AF%AD%E8%A8%80%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">4.C语言缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%A7%82%E5%AF%9F%E7%8E%B0%E8%B1%A1"><span class="toc-text">4.1 观察现象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%9C%A8%E5%93%AA"><span class="toc-text">4.2 缓冲区在哪?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">关闭文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FILE"><span class="toc-text">FILE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.3 缓冲区的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F"><span class="toc-text">4.4 什么时候刷新缓冲区？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E4%B8%8E%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-text">刷新与子进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.5 简单模拟实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%8E%A5%E5%8F%A3"><span class="toc-text">封装接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-text">运行测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-text">子进程测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">5.文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%A3%81%E7%9B%98%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">5.1 磁盘的物理结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-CHS%E5%92%8CLBA"><span class="toc-text">5.2 CHS和LBA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-IO%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-text">5.3 IO的基本单位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">为什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-text">5.4 系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inode"><span class="toc-text">inode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stat%E5%91%BD%E4%BB%A4"><span class="toc-text">stat命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%98%E5%9C%A8%E5%93%AA%E5%84%BF%EF%BC%9F"><span class="toc-text">文件名存在哪儿？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90"><span class="toc-text">目录权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%88%9B%E5%BB%BA-x2F-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-text">5.5 创建&#x2F;删除文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-text">6.软硬链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%AA%E6%95%B0"><span class="toc-text">6.1 查看文件硬链接个数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-text">为什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB"><span class="toc-text">6.2 软硬链接区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%EF%BC%81"><span class="toc-text">解答！</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-unlink%E5%91%BD%E4%BB%A4"><span class="toc-text">6.3 unlink命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2839269095/" title="【微机】DOSBox在windows上的安装和masm的配置"><img src="/img/bg/gm7.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【微机】DOSBox在windows上的安装和masm的配置"></a><div class="content"><a class="title" href="/posts/2839269095/" title="【微机】DOSBox在windows上的安装和masm的配置">【微机】DOSBox在windows上的安装和masm的配置</a><time datetime="2023-10-16T17:49:13.000Z" title="发表于 2023-10-17 01:49:13">2023-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2565866661/" title="【Linux】ubuntu/centos8安装zsh终端"><img src="https://img.musnow.top/i/2023/10/5ebc935468a46d95ac77e65dc879c66d.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Linux】ubuntu/centos8安装zsh终端"></a><div class="content"><a class="title" href="/posts/2565866661/" title="【Linux】ubuntu/centos8安装zsh终端">【Linux】ubuntu/centos8安装zsh终端</a><time datetime="2023-10-15T09:12:55.000Z" title="发表于 2023-10-15 17:12:55">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4065446782/" title="【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机"><img src="https://img.musnow.top/i/2023/10/a13a0b3e0db1dab54e499c9c7bf5ddc6.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机"></a><div class="content"><a class="title" href="/posts/4065446782/" title="【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机">【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机</a><time datetime="2023-10-15T03:30:55.000Z" title="发表于 2023-10-15 11:30:55">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/489538601/" title="【七牛云】artalk表情遇到跨域访问问题"><img src="https://img.musnow.top/i/2023/10/6e1119859945ce9b07928a2bff2643d8.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【七牛云】artalk表情遇到跨域访问问题"></a><div class="content"><a class="title" href="/posts/489538601/" title="【七牛云】artalk表情遇到跨域访问问题">【七牛云】artalk表情遇到跨域访问问题</a><time datetime="2023-10-02T04:35:28.000Z" title="发表于 2023-10-02 12:35:28">2023-10-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/bg/mothra.png)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 慕雪年华</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="https://img.shields.io/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="https://img.shields.io/badge/%E7%B2%A4ICP%E5%A4%872023007189-red" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="https://img.foreverblog.cn/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.staticfile.org/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdn.staticfile.org/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline.musnow.top',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.staticfile.org/waline/2.15.5/waline.min.css').then(() => {
      getScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js').then(initWaline)
    })
  }
}

if ('Artalk' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="click-heart" src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>