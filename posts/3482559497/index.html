<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【网络】IP网络层和数据链路层 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IP协议和数据链路层协议学习"><meta property="og:type" content="article"><meta property="og:title" content="【网络】IP网络层和数据链路层"><meta property="og:url" content="https://blog.musnow.top/posts/3482559497/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="IP协议和数据链路层协议学习"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.musnow.top/i/2023/07/f93a3878d288a436d0a9f8320202f3c0.png"><meta property="article:published_time" content="2023-08-21T12:22:36.000Z"><meta property="article:modified_time" content="2023-08-22T04:05:36.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Linux"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.musnow.top/i/2023/07/f93a3878d288a436d0a9f8320202f3c0.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/3482559497/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【网络】IP网络层和数据链路层",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-08-22 12:05:36"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">358</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://img.musnow.top/i/2023/07/f93a3878d288a436d0a9f8320202f3c0.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-robot"></i><span> 机器人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/posts/847195815/"><i class="fa-fw fab fa-waze"></i><span> Kook-Valorant</span></a></li><li><a class="site-page child" href="/posts/2556995516/"><i class="fa-fw fas fa-ticket-alt"></i><span> Kook-Ticket</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://kdocs.cn/l/cn3OnSwigGxx"><i class="fa-fw fas fa-microphone-alt"></i><span> Kook-VoiceShop</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/musnows/Kook-Afd-Webhook-Bot"><i class="fa-fw fa-brands fa-square-github"></i><span> Kook-AfdWh</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 友链文章</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【网络】IP网络层和数据链路层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-21T12:22:36.000Z" title="发表于 2023-08-21 20:22:36">2023-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-22T04:05:36.000Z" title="更新于 2023-08-22 12:05:36">2023-08-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【网络】IP网络层和数据链路层"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>IP协议详解</p><span id="more"></span><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><h2 id="1-1-四层模型"><a href="#1-1-四层模型" class="headerlink" title="1.1 四层模型"></a>1.1 四层模型</h2><ul><li>应用层：解决如何传输数据（依照什么格式&#x2F;协议处理数据）的问题</li><li>传输层：解决可靠性问题</li><li>网络层：数据往哪里传，怎么找到目标主机</li><li>数据链路层（物理层）：数据在物理硬件层面上传输</li></ul><p>网络层的IP协议，就是让网络，拥有将数据从A主机发送到B主机的能力。</p><blockquote><p>注意：拥有此能力，并不代表每次都能成功送达！（即可靠性非100%）</p></blockquote><p>而失败的时候，就需要<strong>传输层</strong>来获取发生错误的原因，并进行错误重传或者超时重传等操作。</p><p>所以，在从网络层获取到信息成功送达到对方的反馈之前，传输层需要暂时保留已经发送的数据。如果网络层发送失败了，传输层需要进行重发操作，以保证可靠性。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/2023e40723a2e8f8c6b0662d97d468537cbb.jpeg"></p><h2 id="1-2-主机、路由器、节点"><a href="#1-2-主机、路由器、节点" class="headerlink" title="1.2 主机、路由器、节点"></a>1.2 主机、路由器、节点</h2><ul><li>主机：拥有IP地址，但不进行路由控制的设备</li><li>路由器：拥有IP地址，并进行路由控制的设备</li><li>节点：主机和路由器的统称</li></ul><h1 id="2-IP报文"><a href="#2-IP报文" class="headerlink" title="2.IP报文"></a>2.IP报文</h1><h2 id="2-1-报文结构"><a href="#2-1-报文结构" class="headerlink" title="2.1 报文结构"></a>2.1 报文结构</h2><p>IP协议的报文与TCP的报文有一定程度上的相似</p><p>下图为IPV4中报文的格式（IPV6的报文和下图是不同的）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/f93a3878d288a436d0a9f8320202f3c0.png" alt="image-20230724122812011"></p><p>对图中首部字段的解析如下：</p><ul><li>四位版本号：指定IP协议的版本，IPV4来说就是4；</li><li>四位<strong>首部长度</strong>：IP报头的长度，和TCP的定义一样，标准长度需要用<code>四位首部长度 * 4字节</code>，即最大报头长度为<code>15*4=60</code>字节；</li><li>八位服务类型（区分服务）：包含3位优先权字段（已经弃用）、4位TOS字段和1位保留字段（必须置为0）<ul><li>四位TOS分别表示：<strong>最大吞吐量、最高可靠性、最小成本、最小延时</strong>。只能四选一，需要根据具体传输层的协议要求进行选择；</li><li>只有区分服务的时候，这个字段才会启用，一般情况下都不使用这个字段；</li></ul></li><li>十六位<strong>总长度</strong>：包括报头的整个报文的长度，减去四位首部长度代表的IP的报头长度，就能得出报文中数据字段的长度，最大值为65535。</li><li>十六位首部校验和：使用<code>因特网检验和</code>来检测数据是否损坏（比CRC简单）；</li><li>八位协议：上层协议类型（比如TCP、UDP等）解决如何向上层交付的问题；</li><li>八位生存时间（TTL）：用于控制IP报文能在网络层传输的时间（生命周期的限制）<ul><li>比如有些报文由于路由时出现了错误，陷入了路由的死循环；亦或者是路由程序出现了BUG，导致没办法被正常转发到正确的主机上；还有路由超时的问题。<strong>此时这个出错的报文就会在路由里面长时间游离而没办法抵达目的地</strong>（好比内存泄露）。</li><li>规定了TTL之后，可以在IP报头中中记录报文的生命周期时间，当报文转发的耗时已经大于这个TTL之后，就将这个报文丢弃。最大生存周期为255秒；</li><li>最初是以IP数据报中该字段的值减去报文在当前主机耗费的时间，若结果不为0则转发，否则丢弃；</li><li>现在以<code>跳数</code>为单位，路由器转发IP数据报的时候，将该字段值减一，如果减一后不为0则转发，否则丢弃</li></ul></li><li>三十二位源地址和三十二位目标地址：表示发送端IP和接收端IP</li><li>选项字段：不定长，最多40字节（这是因为首部默认是20字节，再加上首部长度最多只能表示60个字节，所以选项字段就是 <code>60-20=40</code>字节）</li><li>此处省略了标识、标志、片偏移字段，会在后文的<strong>分片</strong>中说明……</li></ul><p>IP协议的报文中没有端口号，因为端口号是<strong>传输层应该解决</strong>的事情（UDP和TCP的报头中才有端口号的字段）IP层只关注如何将报文发送给目标主机。也就是两个主机之间如何正常通信的问题。</p><h2 id="2-2-分片"><a href="#2-2-分片" class="headerlink" title="2.2 分片"></a>2.2 分片</h2><h3 id="2-2-1-认识MTU"><a href="#2-2-1-认识MTU" class="headerlink" title="2.2.1 认识MTU"></a>2.2.1 认识MTU</h3><p>MTU相<span id="jump1">当于</span>网络层发快递时<strong>对包裹尺寸</strong>的限制，这个限制是不同的<strong>数据链路层对应的物理层</strong>产生的限制。</p><ul><li>以太网帧中的数据长度规定<strong>最小46字节，最大1500字节</strong>；</li><li>ARP数据包的长度不够46字节。要在后面补填充位；</li><li><strong>最大值1500</strong>称为以太网的最大传输单元(MTU)，不同的网络类型有不同的MTU；</li><li>如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU了，则需要对数据包进行分片(fragmentation)；</li><li>不同的数据链路层标准的MTU是不同的；</li><li>MTU指上层能交付的数据的最大大小，其<strong>不包括以太网本身的报头</strong>。</li></ul><p>所以，数据链路层不支持过大的数据，这就需要在<strong>网络层对数据进行分片</strong>。</p><p>而网络层IP协议会<strong>自动</strong>帮我们分片，并在接收端组装。这个行为对传输层来说是不需要关注的，在<strong>四层模型</strong>中，每一层之间的功能需要进行解耦。</p><p>分片之后，只要有一个分片报文丢失，这个报文的整体就会认为丢失了（因为没有办法拼出完整的报文数据）</p><p>但这样就引出了一个问题：<strong>分片会提高丢包的概率</strong>，影响传输速率（发一次快递和发三次快递，明显三次快递丢东西的可能性更高）</p><p>对于具有可靠性机制的TCP而言，丢包问题不大，我们可以在传输层进行重传。但UDP没有可靠性，此时出现分片后丢包了就没办法找回了。</p><p>所以，网络层进行分片并不是主流！相比之下，在传输层就进行分片才是更好的选择。</p><h3 id="2-2-2-如何分片"><a href="#2-2-2-如何分片" class="headerlink" title="2.2.2 如何分片"></a>2.2.2 如何分片</h3><p>在IP报头中，如下标识、标志、片偏移字段就是用于分片和组装操作的</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/4245674fedcf6b9d43b2845083017f26.png" alt="image-20230724185036181"></p><ul><li>十六位标识 (id): 唯一的标识主机发送的报文。如果IP报文在数据链路层被分片了，那么<strong>每一个片里面的这个id都是相同的</strong></li><li>三位标志字段:<ul><li>第一位保留 (保留的意思是现在不用， 但是还没想好说不定以后要用到)。</li><li>第二位DF为1表示“禁止分片”， 这时候如果报文长度超过MTU， IP模块就会丢弃报文。</li><li>第三位MF表示”更多分片”， 如果分片了的话， <strong>最后一个分片置为0</strong>， 其他分片报文都是1；<strong>0就类似于一个分片报文段的结束标记</strong>；</li></ul></li><li>十三位分片偏移 (framegament offset): 是分片相对于原始IP报文的<strong>数据载荷</strong>开始处的偏移。 其实就是在表示当前分片在原<strong>完整数据载荷</strong>中处在哪个位置。实际偏移的字节数是这个值 <code>* 8</code>得到的。因此，<strong>除了最后一个报文之外，其他报文的长度必须是8的整数倍</strong> (否则报文就不连续了)</li></ul><p>这一点非常重要！一定要记住：<strong>除了最后一个报文之外， 其他报文的数据载荷长度必须是8的整数倍</strong>。</p><blockquote><p>如果数据载荷不足8的整数倍，需要进行向下取整！比如某个分片的数据载荷部分是1476字节，并非8的整数倍，那就应该选择<code>1476/8=184.5</code>向下取整，即采用<code>8*184=1472</code>为该报文的数据载荷长度。</p></blockquote><p>根据这三个分片相关字段，我们只要将三位标志字段中的<code>更多分片MF</code>置为1，就代表当前报文并不是一个完整的报文，而是已经被分片后的报文。</p><ul><li>更多分片为0，且分片偏移为0，代表当前报文没有进行分片； 也可以判断DF禁止分片位，确认是否禁止分片；</li><li>更多分片为1，且分片偏移为0，代表当前是分片后报文中的第一个；</li><li>更多分片为0，且分片偏移<strong>不为0</strong>，代表当前是分片报文中的最后一个；</li></ul><p>如果当前报文是分片后的，那就需要根据<strong>十六位标识</strong>来确定当前分片属于哪一个“组”，再将当前报文和后续收到的ID相同的报文集合在一起，通过十三位片偏移来进行排序，组装成完整数据！</p><p>比如，第一个报文的起始偏移量是0，第二个是1000，第三个是2000，这时候就根据片偏移排序进行拼接就可以了。（这只是个栗子）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/5a4c0d6dfc0870e2ef226d6d0ffe1b35.png" alt="image.png"></p><p>如果对第二个分片还需要进一步分片，效果如下</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/b42621d353de2e9386e25591efd3f980.png" alt="image.png"></p><h4 id="分片练习题"><a href="#分片练习题" class="headerlink" title="分片练习题"></a>分片练习题</h4><p>下面是一个分片的例题，包含了偏移量的选择问题；</p><p>可以看到，一开始我们选择将原有的数据载荷拆成780+700的两部分，但通过计算得出，<code>780/8=97.5</code>，并非8的整数倍，此时第二个IP报文中首部的偏移量字段就不符合要求了，所以我们要保证第一个报文中的数据载荷的长度是8的整数倍。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/657d1d9741a43e9ed40a85fe25b0aa8f.png" alt="image.png"></p><p>此时要采用向下取整的策略，即<code>780/8=97.5</code>，则我们采用<code>97*8=776</code>为第一个IP报文的数据载荷长度，第二个报文的数据载荷长度为<code>1480-776 = 704</code>，因为第二个报文是最后一个分片，所以它的数据载荷部分长度没有8的倍数的要求。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/d2d8f5b34281f02204714ac21d2de09b.png" alt="image.png"></p><h3 id="2-2-3-如何保证收完了一整个分片组？"><a href="#2-2-3-如何保证收完了一整个分片组？" class="headerlink" title="2.2.3 如何保证收完了一整个分片组？"></a>2.2.3 如何保证收完了一整个分片组？</h3><p>根据十六位标识，按照片偏移进行排序，排序后发现缺失了部分的报文，那就代表没有被收完。因为每一个报文的<code>偏移量+该报文长度</code>，就是下一个报文的<code>偏移量</code>！只要数据对不上，那就代表丢东西了。</p><p>而开头和结尾的报文，就能通过上面提到的根据<code>更多分片标记位+分片偏移</code>来确定有没有丢。</p><h3 id="2-2-4-如何减少分片"><a href="#2-2-4-如何减少分片" class="headerlink" title="2.2.4 如何减少分片"></a>2.2.4 如何减少分片</h3><p>虽然说IP网络层会自动帮我们分片，但是否分片是<strong>可以通过传输层</strong>来进行控制的</p><p>只要传输层一次交付的数据没有超过需要分片的阈值，那网络层在传输的时候就不会进行分片了！</p><p>减少分片的方式，那就是在传输层就进行一定的分片，这样能更好将<code>丢分片报文</code>这件事在传输层进行处理。而不是在网络层丢包后，没办法在传输层失败并处理。</p><p>如果是TCP协议，在三次握手的时候，就会协商双方单次传输数据的大小（窗口大小）。从而避免网络层对数据进行分片，以规避数据链路层的MTU限制。同时也维护了滑动窗口，如果网络层的传输出现了丢包，由传输层来进行重传操作，以实现可靠传输。</p><ul><li>限制成多少好呢？</li></ul><p>一般建议将该大小设置为比网络中的最小MTU值小一些，以防止出现分片</p><h3 id="2-2-5-分片的限制"><a href="#2-2-5-分片的限制" class="headerlink" title="2.2.5 分片的限制"></a>2.2.5 分片的限制</h3><p>在上文中提到，MTU的限制是最大1500字节，这个数据长度是包含IP协议的报头的（数据是从IP网络层向下交付给数据链路层的）</p><p>假设我们有一个<strong>网络层的3000字节</strong>的数据，此时网络层要进行分片，并不是简单的<code>3000/1500=2</code>就能搞定了的。而是要计算上IP报头的长度（20字节）</p><p>每一个分片都是一个独立的IP报文，都会有自己独立的IP报头！否则缺少报头，在接收端没有办法进行数据组装操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20+1480</span><br><span class="line">20+1480</span><br><span class="line">20+20</span><br></pre></td></tr></table></figure><p>一共需要分3片，才能将这网络层的3000字节的数据成功传输！</p><p>但是这里就有一个问题了，明明<code>1480+1480+20 = 2980</code>，并不是3000字节啊？</p><p>注意！上面提到的是网络层的3000字节数据。实际上，<strong>传输层只向下交付了2980字节</strong>，加上IP报头20字节才是<strong>网络层的3000字节</strong>数据。因为要进行分片，原本这3000字节的统一报头肯定是要丢弃的，我们需要操作的是传输层向下交付的<code>2980</code>字节数据，将其正确分片并添加上每一个分片的报头，再交给数据链路层。</p><h2 id="2-3-TTL"><a href="#2-3-TTL" class="headerlink" title="2.3 TTL"></a>2.3 TTL</h2><p>上文提到TTL是用来控制报文的生命周期的，其为了避免报文在路由中出现<strong>死循环</strong>，又称路由环路。</p><p>比如下图中，假设有一个报文路由到了路由器D，原本他应该被正常交付给主机C，但路由器D出现了一些问题，将这个报文交付给了路由器I，路由器I给J，J给H，H给C，路由器C又给D，路由器D还是有bug，又转发给了路由器I。这时候，就出现了一个报文路由的死循环。</p><p>如果没有TTL来控制生命周期，报文就会一直在这个死循环中跑，白白浪费路由器的性能！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/cfb3fb1c0b8d2c1d8ae655d17a5e3fef.png" alt="image-20230726201220852"></p><p>规定了TTL之后，当报文的生命周期已经到了，但却还没有发送到目的地，那就需要将这个报文丢弃了。即超了TTL的时间就认为报文无效；</p><ul><li>最初是以IP数据报中该字段的值减去报文在当前主机耗费的时间，若结果不为0则转发，否则丢弃；</li><li>现在以<code>跳数</code>为单位，路由器转发IP数据报的时候，将该字段值减一，如果减一后不为0则转发，否则丢弃</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/439ed52c3652b7d454d31de0552dfc72.png" alt="image.png"></p><h2 id="2-4-协议字段"><a href="#2-4-协议字段" class="headerlink" title="2.4 协议字段"></a>2.4 协议字段</h2><p>协议字段占8比特，标识IPV4报文携带的是什么协议数据单元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICMP 1</span><br><span class="line">IGMP 2</span><br><span class="line">TCP  6</span><br><span class="line">UDP  17</span><br><span class="line">IPv6 41</span><br><span class="line">OSPF 89</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/2e904567fac2a78eb78c4bcf81e31761.png" alt="image.png"></p><p>为什么协议字段里面会有IPv6？因为IPv4到IPv6过渡的方法之一就是用IPv4报文来携带IPv6数据。另外一个过渡方案是双协议栈（即在机器上同时实现IPv6和IPv4的协议栈）</p><h2 id="2-5-首部检验和"><a href="#2-5-首部检验和" class="headerlink" title="2.5 首部检验和"></a>2.5 首部检验和</h2><p>首部检验和采用的是<strong>因特网检验和</strong>，并非CRC检验。</p><p>IP数据报每经过一次路由器，就需要重新计算首部检验和，因为某些字段（生存时间、标志、片偏移）可能会在传输过程中发生变化。</p><p>由于IP层本身并不提供可靠传输服务，而计算检验和是一个耗时的操作，所以在IPv6中路由器不再计算首部校验和，以更快的转发IP报文。</p><h2 id="2-6-例题：从以太网帧字节流中读取目标IP地址"><a href="#2-6-例题：从以太网帧字节流中读取目标IP地址" class="headerlink" title="2.6 例题：从以太网帧字节流中读取目标IP地址"></a>2.6 例题：从以太网帧字节流中读取目标IP地址</h2><p>考研题目中会给你一堆字节流，让你以太网帧的从字节里面提取出IP地址。这需要我们对以太网帧格式和IP报文都深刻的了解。</p><ul><li>以太网帧在IP报头之前添加了源MAC、目标MAC地址、类型字段，一共14字节</li><li>IP报头中，在目的IP地址之前还有16个字节的内容</li></ul><p>因此，我们将字节流中前30字节去掉，在读取32位（4字节）即可得到目标主机的IP地址。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/07a160ec1fb30a29108c9b08d71d794b.png" alt="image.png"></p><p>除了读取目的IP地址，题目还需要我们读取默认网关的MAC地址。而主机的默认网关一般都是路由器，该题转为读取以太网帧格式中的<strong>目的MAC地址</strong>。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/e2f34a70316fab871d30aa1e5ed80912.png" alt="image.png"></p><p>第四题，该报文中IP分组经过路由器R转发的时候，应该需要修改源IP地址、生存时间、首部校验和字段。</p><blockquote><p>如果是在不同的子网中进行转发，源IP地址不需要修改。如果是通过路由器的WAN口转发到上层局域网，则需要修改源IP地址。</p></blockquote><p>如果路由器所连的两个局域网中MTU不同，可能需要对IP重新进行分片。</p><h1 id="3-网段划分"><a href="#3-网段划分" class="headerlink" title="3.网段划分"></a>3.网段划分</h1><h2 id="3-1-IP如何找到对方主机？"><a href="#3-1-IP如何找到对方主机？" class="headerlink" title="3.1 IP如何找到对方主机？"></a>3.1 IP如何找到对方主机？</h2><p>IP如何找到对方主机呢？</p><ul><li>IP &#x3D; 目的网络 + 目的主机</li><li>由此还衍生出网段划分</li></ul><p>以IPV4的ip为例，其格式为<code>1.1.1.1</code>，可以认为是下面的划分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.1.1  .1</span><br><span class="line">网段   .主机</span><br></pre></td></tr></table></figure><p>这就好比你的学号，前X位里面是学院的代码，最后才是班级+班级内编号。先找到你所在学院，再找到班级，最后再找到你。</p><p>反馈到IP里面，就是先找到网段，再找到主机。</p><h3 id="3-1-1-发送数据的本质"><a href="#3-1-1-发送数据的本质" class="headerlink" title="3.1.1 发送数据的本质"></a>3.1.1 发送数据的本质</h3><p>IP就是先找到目的的<strong>网段</strong>，再找这个网段中的目的<strong>主机</strong>。（先根据目的网段进行路由，找到目的网络，再通过主机号找到目的主机）</p><p>而查找目的主机的过程，本质是一个<strong>排除</strong>的过程。</p><p>先通过网段排除一个大类，再通过主机号来排除该网段中的单个主机。这样就能避免我们<strong>一个一个遍历</strong>在全网中查找主机，<strong>提高了查找的效率</strong></p><blockquote><p>子网划分的目的：就是提高查找目标主机的效率</p></blockquote><p>这也是学校里面用学号的原因，除了为了给每个学生提供一个唯一标识，还能通过学号来提高查找到某一个学生的效率。</p><p>在全球互联网上，同样是通过IP地址的网段来划分国家，再划分到每个国家内部的不同区。这时候就会有一定IP地址资源的竞争。比如米国互联网发展早，下图中谷歌的服务器IP就老整齐了😂（不过这些服务器都在同一个地域，IP很接近是合理的）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/5b872ab28b7ae44e7b57d513874d395c.png" alt="image-20230726132920408"></p><h3 id="3-1-2-网络号和主机号"><a href="#3-1-2-网络号和主机号" class="headerlink" title="3.1.2 网络号和主机号"></a>3.1.2 网络号和主机号</h3><ul><li>网络号：保证相互连接的两个网段具有不同的标识</li><li>主机号：在同一网段中，主机之间具有相同的网络号，但是主机号不同以进行区分</li></ul><p>具体框架可以查看下图，<code>192.168.128</code>就是这个局域网的网段 ，而最后的10和11是不同主机的两个主机标识。一般情况下，网段中的<code>1</code>号主机就是这个网段中的路由器。</p><blockquote><p>我们家里的路由器除了进行路由转发，还有子网划分的功能。</p></blockquote><p>如果出现了一个开头并非<code>192.168.128</code>的IP，主机就能知道这不是当前局域网的IP，于是就会将报文直接转发给<code>192.168.128.1</code>，让路由器去找这个IP的目标主机（进行跨局域网的下一层转发）</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/92a09c99e1a35e35157cd259802c2b75.jpeg" alt="img"></p><p>就好比我们的学号是学校的教务系统派发给每一位同学的，IP中的网段也被“某人”在一定程度上根据地区进行了划分。</p><h2 id="3-2-IP地址类别划分"><a href="#3-2-IP地址类别划分" class="headerlink" title="3.2 IP地址类别划分"></a>3.2 IP地址类别划分</h2><h3 id="3-2-1-ABCDE"><a href="#3-2-1-ABCDE" class="headerlink" title="3.2.1 ABCDE"></a>3.2.1 ABCDE</h3><p>通过A到E类不同的划分，会衍生出不同范围的IP号，然后再分配给不同的国家或地区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A类 0.0.0.0到127.255.255.255 </span><br><span class="line">B类 128.0.0.0到191.255.255.255 </span><br><span class="line">C类 192.0.0.0到223.255.255.255 </span><br><span class="line">D类 224.0.0.0到239.255.255.255 </span><br><span class="line">E类 240.0.0.0到247.255.255.255</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/f3248796ffe4f8989ee68b52f3b2f7d7.png" alt="image-20230726110410094"></p><p>依照上面的划分，如果我是一个大型企业，申请了一个B类的IP地址。此时就能支持我的局域网内<code>2^16</code>台主机的ip分配。但实际上我顶多会有2w个主机，此时就出现了IP地址的浪费！</p><h3 id="3-2-2-CIDR和子网掩码"><a href="#3-2-2-CIDR和子网掩码" class="headerlink" title="3.2.2 CIDR和子网掩码"></a>3.2.2 CIDR和子网掩码</h3><p>为了避免上文中出现的IP浪费问题，CIDR（Classless Interdomain Routing）就出现了</p><ul><li>引入一个额外的子网掩码(subnet mask)来区分网络号和主机号；</li><li>子网掩码也是一个32位的正整数. 通常用一串 <code>0</code> 来结尾，一串 <code>1</code> 开头；</li><li>将IP地址和子网掩码进行 <strong>按位与</strong> 操作, 得到的结果就是网络号；</li><li>网络号和主机号的划分与这个IP地址是A类、B类还是C类<strong>无关</strong></li></ul><p>如果我们需要更多主机，就可以将子网掩码中最后一个1置0，就能适配更多局域网主机。</p><p>所以，现在已经不用<code>ABCDE</code>的类别划分方式了，都采用了<strong>子网掩码</strong>方式。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/06b71c71fe5cee4bfd70781717f7f031.png" alt="image-20230726133558191"></p><p>根据上图可见，IP地址与子网掩码做与运算可以得到网络号，<strong>主机号</strong>的二进制位从全0到全1就是子网的地址范围；</p><p>IP地址和子网掩码还有一种更简洁的表示方法：例如<code>140.252.20.68/24</code>,表示IP地址为<code>140.252.20.68</code>, 子网掩码的<strong>高24位是1</strong>，也就是子网掩码<code>255.255.255.0</code></p><h2 id="3-3-基础设施"><a href="#3-3-基础设施" class="headerlink" title="3.3 基础设施"></a>3.3 基础设施</h2><p>有了网段划分，给不同国家和地区划分了IP之后，就需要有人来建设网络的<code>基础设施</code></p><p>在我们国家，搞基础设施就是三大运营商（移动 电信 联通）</p><p>比如几年前做的“光纤入户”就是基础设施建设的一部分。</p><p>基础设施搭建好了后，再通过子网掩码和已经获取到的IP的网段来划分不同省份、不同市区；最终再落到每个入网用户的头上。</p><h2 id="3-4-缓解IP地址不够用的办法"><a href="#3-4-缓解IP地址不够用的办法" class="headerlink" title="3.4 缓解IP地址不够用的办法"></a>3.4 缓解IP地址不够用的办法</h2><p>有人肯定会问了，现在公网IPV4的资源那么匮乏，大部分家宽都是没有公网ip的，那我们平时的上网是怎么实现的？</p><p>换句话说，如何缓解IP地址的匮乏？</p><ul><li>可以使用<code>动态IP分配</code>技术，只给直接接入公网的设备分配IP地址，每一个设备接入网络时，其获取到的IP地址不一定和上次相同。</li><li>NAT技术（重点）</li><li>IPV6（但是现在普及率有待提高）</li></ul><p>IPV6使用16字节（128位）来标识一个IP地址，目前看来，<code>2^128</code> 位能给“地球上每一粒沙子”都分配一个IP地址了。虽然迟早也会有不够用的那一天，但至少是一个很不错的解决方案。我们国家就在大力推广IPV6</p><p>通过前文的报文结构图可知，IPV4的IP地址只有4字节（32位）</p><hr><h1 id="4-私有IP"><a href="#4-私有IP" class="headerlink" title="4.私有IP"></a>4.私有IP</h1><h2 id="4-1-特殊的IP地址"><a href="#4-1-特殊的IP地址" class="headerlink" title="4.1 特殊的IP地址"></a>4.1 特殊的IP地址</h2><p>但是，直接采用CIDR的方式作为局域网控制的方式，就容易出现混乱。而且即便是采用了子网掩码的方式，依旧可能出现IP不够用的情况（一位网民很可能有多个设备， 再加上各类智能终端，现在需要上网的设备只会越来越多）</p><p>需要注意的是CIDR只能提高IP地址的利用率，并不能提高IP地址的上限。</p><p>所以，就衍生出了部分特殊的IP地址。这些IP地址被规定<strong>只能用于局域网</strong>，由此来减少对公网IP的地址消耗。</p><ul><li>将IP地址中的主机地址全设为0，就是该地址的网络号，代表当前局域网</li><li>将IP地址中的主机地址全设为1，就是广播地址，用于给同一个链路中相互连接的所有主机发送数据包。</li><li><code>127.*</code>的IP地址用于<strong>本机回环</strong>。我们通常使用<code>127.0.0.1</code>来进行本地服务的访问和测试，该IP地址是IPv4回环地址的标准规定，IPv6的回环地址为<code>::1</code>。</li></ul><p>我们在计算一个局域网中有多少设备的时候，需要减掉上文提到的网络号和广播地址。</p><hr><p>以下是特殊的只能用于局域网的私有IP地址，包含在这个范围中的， 都称为私有IP， 其余的则称为全局IP (或公网IP)</p><ul><li><code>10.*</code>, 前8位是网络号，共<code>16,777,216</code>个地址</li><li><code>172.16.</code>到<code>172.31.</code>，前12位是网络号，共<code>1,048,576</code>个地址</li><li><code>192.168.*</code>，前16位是网络号，共<code>65,536</code>个地址</li></ul><p>这里要记住2的16次方为<code>65536</code>，在网络的知识点里面经常会接触到这个数字。</p><h2 id="4-2-loopback环回"><a href="#4-2-loopback环回" class="headerlink" title="4.2 loopback环回"></a>4.2 loopback环回</h2><p>上文提到了<code>127.*</code>是用于本地环回的。下图是环回驱动程序针对IP地址的判断</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/94236a76f61d44ff8b9d1b6b0150aa79.jpeg" alt="img"></p><p>在云服务器上执行<code>ifconfig</code>，也能看到本地环回的配置项；这里我们能发现，本地环回的MTU是远高于网络的1500。毕竟是自己和自己通信，基本不会出现丢包，传输速度也是飞快，也就不用担心数据包太大的问题</p><p>同时也能发现，我们的云服务器被分配到的ip地址并不是云服务器的公网ip，这也就表明了我们的云服务器并没有被直接暴露在公网上，而是通过了云服务器厂家的入网服务器（或者也叫路由器）来进行公网ip的映射和数据包的转发操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.0.12.2  netmask 255.255.252.0  broadcast 10.0.15.255</span><br><span class="line">        inet6 fe80::5054:ff:fec9:274f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 52:54:00:c9:27:4f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 277674393  bytes 80031748700 (74.5 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 302405663  bytes 162670581730 (151.4 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 111135687  bytes 27644436547 (25.7 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 111135687  bytes 27644436547 (25.7 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h3 id="4-2-1-环回"><a href="#4-2-1-环回" class="headerlink" title="4.2.1 环回"></a>4.2.1 环回</h3><p>上图中的环回驱动程序会直接和IP协议的接收端（即IP输入函数）相连，当检测到 <code>127.0.0.1</code> 的IP访问请求的时候，会直接把这个报文转发给IP输入函数，而不将其插入到以太网中。</p><p>就相当于你知道 <code>127.0.0.1</code> 这个IP地址代表的就是你自己，你想访问自己电脑上8080端口的程序，即便么有接入互联网的状况下也是能正常访问的！</p><p>Loopback环回接口对于<strong>测试和诊断本地主机上的网络服务和应用程序</strong>非常有用，因为它可以模拟网络通信而不涉及实际的网络传输。</p><h3 id="4-2-2-ARP"><a href="#4-2-2-ARP" class="headerlink" title="4.2.2 ARP"></a>4.2.2 ARP</h3><p>ARP是一个在局域网数据链路层通过IP获取到局域网主机MAC地址的协议，具体请参考后文中的解析</p><hr><h2 id="4-3-访问广域网的步骤"><a href="#4-3-访问广域网的步骤" class="headerlink" title="4.3 访问广域网的步骤"></a>4.3 访问广域网的步骤</h2><h3 id="4-3-1-说明"><a href="#4-3-1-说明" class="headerlink" title="4.3.1 说明"></a>4.3.1 说明</h3><p>下图中能看到我们家用主机是怎么来进行广域网的访问的基本流程；</p><p>我们家里的路由器除了进行路由转发，还有子网划分的功能。可以看到左下角虽然是两个不同的家庭，但其可以分配出完全一样的局域网的子网ip <code>192.168.1.1</code>，和不同的WAN口IP（WAN口就是路由器连接互联网的口）</p><p>这是因为我们的设备是直接和<strong>当前路由器</strong>相连的，访问的时候也只能通过<strong>当前路由器</strong>来进行局域网IP的转发。不可能会出现我访问一个局域网IP，却跑到了别人家里的设备上的情况。因为这个局域网IP访问的报文并不会被转发到上层路由器上，也就不可能凭空飞到其他局域网中</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/1a3192c168e559aee56371f85945c32b.png" alt="image-20230726185645407"></p><p>图中的 <code>122.77.241.3</code> 就是一个公网IP的服务器，当我们需要访问这个主机的时候，局域网的家用路由器在检测到这个目的IP的时候，发现其并不是局域网的IP地址，于是就会将这个报文给转发给上层的运营商路由器。</p><p>运营商路由器是直接接入了公网IP的，其就能通过<code>网段划分+主机编号</code>来查找目标主机，将报文转发给 <code>122.77.241.3</code> 服务器，再将服务器返回的信息转发给你的家用路由器，再转发到你的主机上。</p><p>这也告诉我们，想绕过运营商直接获得公网IP是不可能的，因为从<strong>物理层面上</strong>，我们的家用路由器就不是接在公网IP上的！即便是可以申请到的家用公网IP，也和云服务器的入网服务器一样，是运营商的路由器分配给你的。</p><blockquote><p>你会发现，家用申请的公网ip，很多端口都是被屏蔽的（比如 <code>80/443/8080</code>）这些端口的屏蔽操作，以及海外网站的「墙」也是运营商的路由器进行检测和屏蔽的！</p></blockquote><h3 id="4-3-2-内网访问公网的流程"><a href="#4-3-2-内网访问公网的流程" class="headerlink" title="4.3.2 内网访问公网的流程"></a>4.3.2 内网访问公网的流程</h3><p>假设我们的模型如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">广域网</span><br><span class="line">  ↓</span><br><span class="line">运营商路由器C （公网IP是122.77.241.4）</span><br><span class="line">  ↓</span><br><span class="line">家用路由器B （运营商路由器分配私有IP 10.1.1.2）</span><br><span class="line">  ↓</span><br><span class="line">家用主机A （家用路由器分配私有IP 192.168.1.201）</span><br></pre></td></tr></table></figure><p>下面是一个家用主机A，访问公网IP的主机 <code>122.77.241.10</code> 的具体步骤；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">本地主机A发送IP报文给家庭路由器B</span><br><span class="line">————————————————————————</span><br><span class="line">| 源IP：192.168.1.201   |</span><br><span class="line">| 目的IP：122.77.241.10 |</span><br><span class="line">————————————————————————</span><br><span class="line"></span><br><span class="line">路由器B收到报文后，检测目的IP，发现并不似局域网的IP</span><br><span class="line">于是交付给上层的运营商路由器C；</span><br><span class="line">报文的源IP被修改为家用路由器B的wan口IP</span><br><span class="line">————————————————————————</span><br><span class="line">| 源IP：10.1.1.2        |</span><br><span class="line">| 目的IP：122.77.241.10 |</span><br><span class="line">————————————————————————</span><br><span class="line"></span><br><span class="line">运营商路由器C收到报文后，发现其也不是自己所在内网 10.1.1.* 的局域网IP</span><br><span class="line">于是开始执行广域网IP寻址操作，找到目标公网IP的主机，再将报文发送给该主机；</span><br><span class="line">此时发送的报文又被改成了</span><br><span class="line">————————————————————————</span><br><span class="line">| 源IP：122.77.241.4    |</span><br><span class="line">| 目的IP：122.77.241.10 |</span><br><span class="line">————————————————————————</span><br></pre></td></tr></table></figure><h3 id="4-3-3-NAT技术"><a href="#4-3-3-NAT技术" class="headerlink" title="4.3.3 NAT技术"></a>4.3.3 NAT技术</h3><p>这种不断替换源IP来进行路由转发的过程，就是<strong>NAT技术</strong>！</p><p>也正是NAT技术的存在，让我们能通过多级局域网来让更多的设备上网，大大缓解了公网IP的不足。</p><p>也正是因为IPV4地址不足的问题被大大缓解，推广IPV6就没有我们想象中的那么顺利了。毕竟IPV6的IP格式和V4完全不同，需要每个层级的路由器都进行功能升级，这可是一个巨大的工程！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/18a4c496be6f375256a5563b7ff537a2.png" alt="image-20230822092804992"></p><h3 id="4-3-4-NAT怎么回来？NAPT"><a href="#4-3-4-NAT怎么回来？NAPT" class="headerlink" title="4.3.4 NAT怎么回来？NAPT"></a>4.3.4 NAT怎么回来？NAPT</h3><p>当目标主机收到这个报文后，他的反馈报文如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">————————————————————————</span><br><span class="line">| 源IP：122.77.241.10   |</span><br><span class="line">| 目的IP：122.77.241.4  |</span><br><span class="line">————————————————————————</span><br></pre></td></tr></table></figure><p>同样是先到达运营商路由器，运营商路由器需要缓存每一个转发到公网的报文的来源信息；为此路由器会维护一个<strong>转换表</strong>，记录着局域网主机的<code>私有IP地址:端口号</code>与对应的<code>公网IP地址:NAT端口号</code>的映射关系。</p><p>比如此次TCP链接中，我将路由器公网IP的<code>122.77.241.4:30000</code>映射给了局域网<code>10.1.1.2:40000</code>；当从公网收到服务器的响应报文后，从<strong>转换表</strong>里面就能够查到这个映射（一次通信中这个NAT映射是不会变的）从而确定该报文的局域网流向。</p><blockquote><p>需要注意的是，NAT技术在端口映射的时候不一定会映射到和内网主机相同的端口，此时不仅需要修改IP报文中的来源IP，还需要进一步修改传输层（比如TCP和UDP）中的源端口号</p></blockquote><p>确定局域网IP后，就修改当前报文的目的IP，继续往局域网转发；后面的子路由器也是如此，不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">————————————————————————</span><br><span class="line">| 源IP：122.77.241.10   |</span><br><span class="line">| 目的IP：10.1.1.2      |</span><br><span class="line">————————————————————————</span><br></pre></td></tr></table></figure><p>这种<code>IP:端口</code>的关联关系表，就是由支持NAT技术的路由器来维护的，这个转换表被称为<strong>NAPT</strong>；当这次链接结束后，这对映射关系就会从转换表中被删除。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/b1d4032e4d2cfd4fad023cbd0ad0f6d8.png" alt="image-20230822093121691"></p><h3 id="4-3-5-NAT和代理服务器"><a href="#4-3-5-NAT和代理服务器" class="headerlink" title="4.3.5 NAT和代理服务器"></a>4.3.5 NAT和代理服务器</h3><p>代理服务器看上去和NAT设备有一定类似，客户端向代理服务器发送请求，代理服务器将请求转发给真正需要请求的服务器；服务器返回结果后，代理服务器把结果传回客户端。</p><h4 id="4-3-5-1-NAT和代理服务器的区别？"><a href="#4-3-5-1-NAT和代理服务器的区别？" class="headerlink" title="4.3.5.1 NAT和代理服务器的区别？"></a>4.3.5.1 NAT和代理服务器的区别？</h4><ul><li>从应用来说，NAT是属于网络基础设置，解决的是公网IP不足的问题；代理服务器更贴近具体应用，比如通过代理服务器进行“翻墙”和游戏加速；</li><li>从底层来讲，NAT在网络层工作，对IP地址进行替换；代理服务器是在应用层工作；</li><li>从使用范围来讲，NAT一般部署在局域网出口，代理服务器既可以在局域网又可以在广域网部署</li><li>从部署位置来看，NAT集成在路由器或者防火墙的硬件上；代理服务器本质上是一个应用层软件，部署在服务器上</li></ul><p>代理服务器应用相对来说也比较广</p><ul><li>翻墙：广域网代理</li><li>负载均衡：局域网代理</li></ul><h4 id="4-3-5-2-反向代理"><a href="#4-3-5-2-反向代理" class="headerlink" title="4.3.5.2 反向代理"></a>4.3.5.2 反向代理</h4><p>代理服务器分为正向代理和反向代理，这里来说说<strong>反向代理</strong>，反向代理处于目标服务器和客户端之间，客户端通过反向代理访问目标服务器，而不会直接连接到目标服务器</p><ul><li>通过反向代理服务器作为一个云服务器主机集群的入网服务器</li><li>举例，一个网站拥有10台提供服务的服务器和一台反向代理服务器</li><li>域名解析到反向代理服务器</li><li>反向代理服务器通过服务器监控程序，获取到10台服务器中负载最低的那个，并将报文转发给它</li><li>反向代理服务器还会识别10台服务器中是否有宕机的服务器，如果有，则会告警给维护人员，并不再给这个宕机的服务器转发报文</li><li>反向代理服务器还可以设置黑白名单，当遇到DDOS攻击的时候，将来源IP放入黑名单进行屏蔽，避免过多的访问让所有服务器都宕机影响业务；将本公司的其他服务器放入白名单（一般白名单都很短）</li></ul><p>反向代理的作用</p><ul><li>通过反向代理服务器实现了<strong>负载均衡</strong></li><li>便于<strong>统一管理</strong>服务器集群，提供统一入网服务器</li><li>避免了直接将提供服务的主机IP暴露在公网上而被直接攻击的问题，提高了<strong>安全性</strong>。</li><li>反向代理还能对网页内容进行一定的<strong>缓存</strong>，从而减轻后端服务器的负担（比如缓存网页前端的静态资源，当用户访问的时候，由代理服务器直接返回资源，而不需要去请求实际提供服务的服务器）</li></ul><p>总之好处多多！</p><h4 id="4-3-5-3-正向代理"><a href="#4-3-5-3-正向代理" class="headerlink" title="4.3.5.3 正向代理"></a>4.3.5.3 正向代理</h4><p>正向代理是位于客户端和目标服务器之间的中间服务器。客户端通过正向代理来访问互联网上的资源，而不是直接连接到目标服务器。正向代理的作用主要有以下几点：</p><ol><li><strong>访问控制和过滤：</strong> 正向代理可以用于限制用户访问特定网站或资源，以实施访问控制策略。它可以过滤不良内容，提供更好的安全性和隐私保护。</li><li><strong>隐藏客户端身份：</strong> 正向代理可以隐藏客户端的真实 IP 地址，从而保护用户的隐私和匿名性。目标服务器只能看到代理服务器的 IP 地址，而无法获取到真正的客户端信息。</li><li><strong>缓存和加速：</strong> 正向代理服务器可以缓存常用的内容，从而减少对目标服务器的请求，提高访问速度。</li><li><strong>突破防火墙限制：</strong> 在一些网络环境中，访问特定网站可能受到限制或封锁。使用正向代理可以绕过这些限制，访问被封锁的资源。</li></ol><h2 id="4-4-ISP检测宽带账户"><a href="#4-4-ISP检测宽带账户" class="headerlink" title="4.4 ISP检测宽带账户"></a>4.4 ISP检测宽带账户</h2><blockquote><p>下文中的部分内容来自chatgpt，我对里面的内容进行了补充和修改</p></blockquote><p>运营商的路由器还会检测我们的账户是否还有余额。我们的家用路由器一般是通过光猫登录了自己的宽带账户；也可以将光猫设置成桥接模式，<strong>将接入光猫的路由器设置为宽带帐号（PPPoE）上网方式</strong>，登录运营商提供的宽带账户和密码，来接入网络。</p><p>ISP的路由器检测你的宽带账户通常是通过以下步骤来完成的：</p><ol><li><strong>设备连接与识别：</strong> 当你的计算机或其他网络设备连接到ISP提供的路由器时，路由器会分配一个私有IP地址给你的设备。这个IP地址是由路由器动态分配的，并且通常处于特定的私有IP地址范围，比如<code>10.11.1.0/16</code>或<code>10.11.1.0/24</code>等。此时，你的设备与路由器建立了一个<em>大局域网</em>内的连接。（运营商并不会直接给你分配<code>192.168.*</code>这样的私有IP，因为这个IP一般是用于<strong>最底层局域网</strong>的，给你分配了，那家庭局域网的就没IP用了）</li><li><strong>认证过程：</strong> 在你尝试访问互联网时，ISP的路由器会引导你的设备进行认证过程。这通常涉及向ISP服务器发送你的宽带账户的登录凭据（例如，用户名和密码）。</li><li><strong>账户验证：</strong> ISP的服务器会验证你提供的登录凭据是否与其记录中的账户匹配。如果验证成功，说明你的宽带账户是有效的，路由器会为你的设备分配一个公共IP地址，这个IP地址是可供互联网访问的。</li><li><strong>IP地址分配：</strong> 一旦认证成功，ISP的路由器会为你的设备分配一个公共IP地址。这个IP地址是在互联网上唯一标识你的设备的地址，使你的设备可以与其他互联网设备进行通信。</li><li><strong>数据传输：</strong> 一旦有了公共IP地址，你的设备就可以与互联网上的其他设备进行通信，发送和接收数据。</li></ol><p>这样，通过认证和IP地址分配的过程，ISP的路由器可以检测并识别你的宽带账户，从而让你的设备能够访问互联网。</p><p>人话就是，<strong>登录了宽带账户</strong>以后，当我们路由器发送的报文交付到运营商路由器的时候，该路由器就会检测你这个宽带账户的余额。如果没有余额了，就会直接丢弃掉你的IP报文。我们看到的结果就是无法上网！</p><blockquote><p>这个操作并不是每次都会执行的，只要你的路由器能稳定的接入到运营商的路由器上，那就不会每次都进行宽带账户的验证，否则会增加网络的负担。</p><p>具体的验证流程都是运营商路由器和你的本地光猫自动完成的。</p></blockquote><p>而手机没有话费余额的时候，我们依旧能拨通诸如120、119等紧急号码，这也是运营商的服务对这些特殊的电话号码做了类似于<code>免费白名单</code>的操作（手机号码可以类比公网IP来理解）</p><h1 id="5-域名"><a href="#5-域名" class="headerlink" title="5.域名"></a>5.域名</h1><h2 id="5-1-DNS服务器"><a href="#5-1-DNS服务器" class="headerlink" title="5.1 DNS服务器"></a>5.1 DNS服务器</h2><p>上文讲述的都是关于IP协议的事情。但实际上我们日常生活中，一般都不会直接使用IP地址+端口号的方式来访问某一个服务，而是使用域名来访问。比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com</span><br><span class="line">www.google.com</span><br></pre></td></tr></table></figure><p>所谓域名，就是这些<strong>英文字符串</strong>和IP的映射。</p><p>比如<code>baidu.com</code>就是一个域名，而<code>www.baidu.com</code>是该域名下的三级域名（几级域名可以看有几个点）</p><p>实际访问的时候，是百度在域名注册商哪里，将<code>www.baidu.com</code>指向了自己的服务器的地址(假设指向的是<code>1.1.1.1</code>) 我们访问百度，实际上访问的就是 IP地址 <code>1.1.1.1</code>；</p><ul><li>DNS是应用层协议，底层使用的是UDP</li><li>系统会缓存一部分DNS的结果</li></ul><p>在主机本地，有一个<code>hosts</code>文件，也可以用于设置主机到域名的映射，在linux里面就是<code>/etc/hosts</code>这个文件。 在访问域名的时候，操作系统会先检查自己本机器的hosts，如果本地没有，就请求DNS服务器来获取解析结果。</p><h2 id="5-2-域名访问主机流程"><a href="#5-2-域名访问主机流程" class="headerlink" title="5.2 域名访问主机流程"></a>5.2 域名访问主机流程</h2><p>当我们访问一个域名的时候，首先会去请求特殊的DNS服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 谷歌公司的DNS服务器</span><br><span class="line">119.29.29.29 腾讯提供的公共DNS</span><br></pre></td></tr></table></figure><p>先请求这些DNS服务器，服务器内会针对域名查询对应的DNS解析，最后再访问该解析对应的IP地址</p><p>而使用域名的时候，默认访问的是该主机的 <code>80(HTTP)/443(HTTPS)</code> 端口 ，我们也可以像IP一样，在域名之后用<code>:端口</code> 来指定特定端口号进行访问，即<code>域名:端口</code>。</p><p>一般情况下，我们的主机都可以通过<strong>自动配置DNS</strong>从上层路由器中获取到DNS服务器的地址（比如运营商会在路由器基站中内置DNS服务器）</p><h3 id="5-2-1-DNS劫持"><a href="#5-2-1-DNS劫持" class="headerlink" title="5.2.1 DNS劫持"></a>5.2.1 DNS劫持</h3><p>所谓DNS污染和DNS劫持，就是因为我们访问的DNS服务器的时候，获取到的结果和预期不同，从而导致无法访问目标网站，或者访问了<strong>假</strong>的目标网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com 明明应该指向 1.1.1.1</span><br><span class="line">但被坏蛋劫持了DNS解析，变成了指向 1.1.1.3</span><br></pre></td></tr></table></figure><p>坏蛋可以在 <code>1.1.1.3</code> 服务器上，搭建一个和百度「看起来」一模一样的页面，并将你的报文给转发到百度服务器上。此时他就通过中间转发，获取到了你报文中的用户信息、密码等等参数；</p><p>这时候因为这个<strong>假的服务器</strong>是直接给你提供服务了，使用的HTTPS证书也是这个假服务器的证书，对方可以直接通过自己的证书解密获取到你的信息，再转发给百度。</p><h3 id="5-2-2-DNS和负载均衡"><a href="#5-2-2-DNS和负载均衡" class="headerlink" title="5.2.2 DNS和负载均衡"></a>5.2.2 DNS和负载均衡</h3><p>对于大公司而言，DNS解析还有一个重要的作用，就是通过不同区域的设置来实现负载的均衡。</p><p>假设百度在每一个省份都设立了一个自己的机房，那么它就可以通过DNS服务器，当不同省份的用户请求服务器的时候，返回他当前所处省份的机房地址。这时候就实现了每个机房的负载均衡。</p><p>在现实中，就是将你的请求转接到离你最近的拥有机房的省份，这样既能保证所有服务器的负载均衡，又能保证你的访问能较快地获取到响应（广东访问广州的服务器，肯定比访问北京服务器的延迟低一些）</p><h2 id="5-3-DNS分层"><a href="#5-3-DNS分层" class="headerlink" title="5.3 DNS分层"></a>5.3 DNS分层</h2><p>DNS服务器不会存放所有已知域名的IP解析，因为互联网上存在大量的域名，数量庞大且不断增长，单一DNS服务器无法存储和处理所有域名的IP映射。</p><p>实际上，DNS服务器通过<strong>分层的架构</strong>来解决这个问题。在根DNS服务器层级，有一组全球性的顶级DNS服务器，它们存储顶级域名（例如<code>.com、.org、.net</code>等）的IP地址。然后，在每个顶级域名下，有其他DNS服务器，负责管理该顶级域名下的子域名（例如，<code>google.com、facebook.com</code>等）。这个过程继续向下，形成了一个层级结构。</p><p>当你的设备需要解析某个域名时，它首先会向本地DNS服务器（通常由你的ISP，即<strong>互联网服务提供商</strong>，人话就是国内的三大运营商提供）发起请求。如果本地DNS服务器知道所需域名的IP地址，它会直接返回该IP地址给你的设备。但如果本地DNS服务器不知道该域名的IP地址，它会向<strong>根DNS</strong>服务器发起请求。</p><p>根DNS服务器将指导本地DNS服务器转向相应的<strong>顶级DNS服务器</strong>。然后，顶级DNS服务器可能会进一步将请求转发给负责该<strong>特定域名的授权DNS</strong>服务器。最终，这个授权DNS服务器将返回所需域名的IP地址给本地DNS服务器，本地DNS服务器再将其返回给你的设备。</p><p>这个层级结构允许DNS系统更高效地处理大量的域名解析请求，并确保及时更新和管理域名与IP地址的映射。所以，单个DNS服务器并不会存放所有已知域名的IP解析，而是通过层级结构来分散和管理这些信息。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/74893f7e207a52fc1a4c3c683ebb0976.png" alt="img"></p><h2 id="5-4-dig工具分析DNS解析过程"><a href="#5-4-dig工具分析DNS解析过程" class="headerlink" title="5.4 dig工具分析DNS解析过程"></a>5.4 dig工具分析DNS解析过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bind-utils</span><br></pre></td></tr></table></figure><p>安装了之后就可以使用dig命令来查看域名解析过程了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig 域名</span><br></pre></td></tr></table></figure><h1 id="6-路由"><a href="#6-路由" class="headerlink" title="6.路由"></a>6.路由</h1><p>路由的过程，就是下图这样一跳一跳(Hop by Hop) “问路” 的过程</p><p>所谓 “一跳” 就是数据链路层中的一个区间。具体在以太网中，指从源MAC地址到目的MAC地址之间的帧传输区间。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/f1a4a3b26f00fe29305bba853e830186.png" alt="image-20230726194559495"></p><h2 id="6-1-问路栗子（帮助理解）"><a href="#6-1-问路栗子（帮助理解）" class="headerlink" title="6.1 问路栗子（帮助理解）"></a>6.1 问路栗子（帮助理解）</h2><p>拿日常生活中问路来举例子（请屏蔽现在有导航这件事）一般问路，会得到三种结果：</p><ul><li>我不知道</li><li>我知道XXX知道</li><li>我不知道，但是给你乱指（在路由寻址的过程中，这个情况是不存在的）</li></ul><p>比如张三要去南京大学的仙林校区，他飞机落地南京后，不知道怎么走；他找了个机场的保安，问他“我是从xx省新来的大学生，应该怎么去南京大学？” 保安让他先坐xx路公交车去仙林大学城，到哪里再去问其他人。</p><p>张三到了仙林大学城后，又找到了路边的环卫工，又问“我从机场过来，应该怎么去南京大学。” 环卫工给他指了条明路，那里就是南京大学的教学楼，入口就在这附近。这时候张三获取了两个人（路由器）的帮助，成功递达了南京大学的仙林校区（目标主机）。</p><p>可以看到，问路和上面图示中IP报文的路由是很相似的，都是一个路由一个路由的“问路”，最终找到目标主机。</p><hr><h2 id="6-2-路由表"><a href="#6-2-路由表" class="headerlink" title="6.2 路由表"></a>6.2 路由表</h2><p>报文在各个路由器之间路由也是如此。当一个路由器遇到一个IP报文</p><ul><li>他首先检测这是不是自己分配的局域网中的IP，是则可以直接转发到目标主机；</li><li>不是则查看自己的<strong>路由表</strong>，看看自己是否保存了这个IP应该往哪里走；</li><li>如果它自己不知道，则可以和其他与自己相连的路由器通信（信息同步），问他们这个IP应该给谁（就好比你在公司里面问某一个工作应该交给谁去做）</li><li>如果周边的路由（旁边的路人）都不知道该往哪里去，则路由器会将其交付给自己的<code>默认路由</code>，报文继续转发，去下一个人那里问路了。</li></ul><p>这样的跳跃都会有一个前提条件：相邻的两个主机（或路由器）一定是在物理上相连，处于同一局域网之中。每次的跳跃，本质上是从一个子网跳到另外一个子网；广域网可以认为是最大的“子网”</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/07/2eb52f0f7cb80aeed61e8a17d8402688.png" alt="image-20230727085331798"></p><h2 id="6-3-route命令"><a href="#6-3-route命令" class="headerlink" title="6.3 route命令"></a>6.3 route命令</h2><blockquote><p>在windows电脑上可以使用 <code>route print</code> 命令打印路由表，本文不关注windows平台。</p></blockquote><p>在linux平台里面，可以通过<code>route</code>命令查看当前主机的路由表，在Centos8主机上，命令显示如下。</p><p>可以看到，路由表的名字叫做 <strong>内核IP路由表</strong>，这也是linux系统中的一个内核数据结构。内部维护了路由表的目的地、Gateway网关、Genmask掩码、Flags标志位、Metric、Ref、Use、Iface接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         _gateway        0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-96d69eeef1ac</span><br><span class="line">172.19.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-fa4aff4c583e</span><br></pre></td></tr></table></figure><ul><li>Flags中，U代表当前路由表的条目是有效的，G代表其是一个路由器。</li><li>Gateway中，<code>_gateway</code>以及<code>0.0.0.0</code>代表的都是默认网关</li><li>Iface中，只有<code>eth0</code>是一个真正的物理网络接口，而<code>docker0/br-*</code>都是docker容器虚拟出来的桥接网络接口</li></ul><p>假设我我们有一个目的IP是 <code>172.16.0.2</code>，获取到这个IP后，系统就会将其和路由表中的子网掩码依次进行<strong>按位与</strong>；</p><p>在linux环境下，可以使用如下代码来进行这两个IP的按位与操作。其中<code>inet_addr 和 inet_ntoa</code>是linux下的两个系统调用接口。用于IP字符串到无符号整数之间的转换，具体的介绍可以阅读我的 <a href="https://blog.musnow.top/posts/368672249/">UDP博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将点分十进制的IP地址和子网掩码转换为无符号整数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ipAddress = <span class="built_in">inet_addr</span>(<span class="string">&quot;172.16.0.2&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> subnetMask = <span class="built_in">inet_addr</span>(<span class="string">&quot;255.255.0.0&quot;</span>);</span><br><span class="line">    <span class="comment">// 进行按位与操作得到网络地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> networkAddress = ipAddress &amp; subnetMask;</span><br><span class="line">    <span class="comment">// 将网络地址转换回点分十进制表示法并输出结果</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr;</span><br><span class="line">    addr.s_addr = networkAddress;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IP地址: &quot;</span> &lt;&lt; <span class="string">&quot;172.16.0.2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子网掩码: &quot;</span> &lt;&lt; <span class="string">&quot;255.255.0.0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;网络地址: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非linux环境可以使用下方的代码进行处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ip_and_gmask_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ipAddress = <span class="number">172</span> &lt;&lt; <span class="number">24</span> | <span class="number">16</span> &lt;&lt; <span class="number">16</span> | <span class="number">0</span> &lt;&lt; <span class="number">8</span> | <span class="number">2</span>; <span class="comment">// 将 IP 地址转换为 32 位无符号整数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> subnetMask = <span class="number">255</span> &lt;&lt; <span class="number">24</span> | <span class="number">255</span> &lt;&lt; <span class="number">16</span> | <span class="number">0</span> &lt;&lt; <span class="number">8</span> | <span class="number">0</span>; <span class="comment">// 将子网掩码转换为 32 位无符号整数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> networkAddress = ipAddress &amp; subnetMask; <span class="comment">// 按位与</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IP地址:  172.16.0.2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子网掩码: 255.255.0.0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;网络地址: &quot;</span> &lt;&lt; (networkAddress &gt;&gt; <span class="number">24</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; ((networkAddress &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; ((networkAddress &gt;&gt; <span class="number">8</span>) &amp; <span class="number">255</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; (networkAddress &amp; <span class="number">255</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者输出结果都是<code>172.16.0.0</code></p><p>得到输出结果后，再和路由表中该项的<code>Destination</code>进行对比，二者相等，代表当前IP就是需要通过该项进行路由，那就将这个报文通过<code>Iface</code>接口<code>eth0</code>发送出去就OK了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0</span><br></pre></td></tr></table></figure><p>如果按位与的结果与<code>Destination</code>匹配不上，那就继续往下一个条目的子网掩码进行按位与。如果整个表都按位与完毕了，还没找到该去的地方，那就将其通过<code>default</code>默认路由发送出去。</p><h1 id="7-数据链路层"><a href="#7-数据链路层" class="headerlink" title="7.数据链路层"></a>7.数据链路层</h1><p>前面谈了一大堆将数据从一个主机到路由器再跨越多个路由器递达目标主机的流程。</p><p>要想实现这一点，我们还需要数据链路层的帮助，即实现同一局域网内两台主机在物理层面上的相互通信。</p><ul><li>IP网络层：提供跨网络找到正确路由路径，并传输数据的能力</li><li>数据链路层：提供将数据在同一网络中传输的能力</li><li>物理层：实际上的数据在物理（网线）上传输</li></ul><p>数据链路层也有不同的传输方式，本文主要关注当前主流的<strong>以太网</strong>；</p><p>需要注意的是，以太网不是一种具体的网络，而是一种技术标准。它即包含了数据链路层的内容，也包含了一些物理层的规定，比如拓扑结构和访问控制方式，传输速率等。</p><blockquote><p>注意：本文中关于数据链路层的知识并不完整，因为当时的学习目标是最常用、面试最常考的网络知识，并没有完整学习计算机网络。</p><p>2023-12-17：后续计算机网络的完整总结会根据<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NT411g7n6/">B站视频</a>的学习单独开一个博客。</p></blockquote><h2 id="7-1-认识局域网的基本情况"><a href="#7-1-认识局域网的基本情况" class="headerlink" title="7.1 认识局域网的基本情况"></a>7.1 认识局域网的基本情况</h2><h3 id="7-1-1-局域网认识"><a href="#7-1-1-局域网认识" class="headerlink" title="7.1.1 局域网认识"></a>7.1.1 局域网认识</h3><p>不过在认识以太网之前，我们需要先知道局域网通信的一个基本情况；假设下图中就是一个局域网，其中包含了不同的主机</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/ffd57666730e838d74d4c8c9af7d95cd.png" alt="image-20230821171017532"></p><p>首先，如果想要两台主机能够通信，我们就需要先将其链接到<strong>同一根网线</strong>上（在这里暂且不管WIFI，其实本质上也是连在了这根网线上）；这就好比进程间通信的时候，你需要先能看到同一份资源，才能实现对这份资源的共享访问。</p><p>虽然我们认为在局域网里面通信的时候，是两台主机直接交流，但实际上你可以把局域网当作一个教师，当张三和李四沟通的时候，其实会有很多其他的吃瓜群众都能接收到你发送的这个信息。</p><p>反馈到以太网报文上，因为每个主机都是知道自己的地址的，所以只要检测到以太网报头中的<code>目的地址</code>不是自己的时候，就可以丢弃掉这个报文。因为目标并不在和你说话。这就好比在教室里面，你隔壁有俩人在聊天，他们并没有和你交谈，所以你可以不用管他们聊了什么。</p><blockquote><p>这也反馈出了为什么某些公共WIFI会不安全，因为只要接入了这个WIFI，你就有办法检测到其他用户通过这个局域网发送了什么信息！</p></blockquote><p>因为局域网内的主机是通过目的地址判断有没有人和自己聊天的，所以即便我们的电脑开机后什么事情都没有干，在操作系统底层（数据链路层）其实一直都在从局域网中拿到新的数据链路层报文，并检测是否是发给自己的报文：</p><ul><li>是，向上交付</li><li>否，丢掉</li></ul><h3 id="7-1-2-碰撞域"><a href="#7-1-2-碰撞域" class="headerlink" title="7.1.2 碰撞域"></a>7.1.2 碰撞域</h3><p>由于数据链路层向下是直接交付给物理层的，在物理层（网线）中光电信号传输是不能同时传输多个数据的，这就要求我们同一个局域网的多台主机不能同时往局域网中发数据。为了解决这个问题，主机引入了休眠机制，通过不同时间的错开休眠，来避免两台主机同时往局域网中发数据的情况。</p><ul><li>理想情况：同一时间只有一台主机在局域网中发送数据</li><li>碰撞问题：如果出现了同时发送，数据出现冲突，就需要剔除掉这部分数据</li></ul><p>通过<code>碰撞域</code>解决数据冲突问题，尽量达到理想情况；</p><p>比如我们的交换机就有<strong>划分碰撞域</strong>的功能。接到交换机上的设备，除了通过交换机进行路由转发，如果在交换机的这部分设备中出现了数据碰撞，那么交换机就能把碰撞控制在当前这个小的碰撞域内，而不会向更大的局域网中传播。</p><blockquote><p>如果一个局域网里面只有一个交换机（路由器）那么这整个局域网共享碰撞域</p></blockquote><p>所以大公司内为了避免局域网因为碰撞问题而导致的网络卡顿，一般都会将几台电脑接入一个小的交换机中来<strong>划分碰撞域</strong>。</p><p>如上是物理层面的事情，软件层面上，一个<strong>MAC帧</strong>不要太大，否则会大大增加碰撞的概率。所以MAC帧必须要对上层交付的数据大小提一个要求，不能交付太大的数据，这就是MTU的由来（一般都是1500字节，至于为什么是1500，那就是学术层面的事情了）</p><h3 id="7-1-3-链路和数据链路"><a href="#7-1-3-链路和数据链路" class="headerlink" title="7.1.3 链路和数据链路"></a>7.1.3 链路和数据链路</h3><p>链路是一条物理的链路，中间没有任何交换节点；</p><p>数据链路是基于链路上的，需要有协议来实现数据的传输；将这些协议和硬件加入到链路上，就行程了数据链路；</p><h2 id="7-2-以太网帧格式（MAC帧）"><a href="#7-2-以太网帧格式（MAC帧）" class="headerlink" title="7.2 以太网帧格式（MAC帧）"></a>7.2 以太网帧格式（MAC帧）</h2><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/736bb377f1eb050bba42a13f153a435e.png" alt="image-20230803144819270"></p><h3 id="7-2-1-MAC帧格式"><a href="#7-2-1-MAC帧格式" class="headerlink" title="7.2.1 MAC帧格式"></a>7.2.1 MAC帧格式</h3><p>这部分的知识可以小结如下</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/380cd2fab4548c72be221bbf3ad152b5.png" alt="image-20231217102831227"></p><p>以太网MAC帧格式分为下面两种，这两种格式仅类型字段有区别</p><ul><li>DIX Ethernet V2（流行，后文涉及到的是这个）</li><li>IEEE 802.3</li></ul><p>其中以太网V2的MAC帧格式如下</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/60f7691d7eb1beb3df9d4a99f030d6b1.png" alt="image-20231217104707151"></p><ul><li>目的地址（6B）：48位的MAC地址，MAC是每个主机在局域网内唯一的身份标识</li><li>源地址（6B）：48位的MAC地址，同上</li><li>类型（2B）：上层（网络层）使用的协议，帧协议类型有三种值，分别对应<code>IP、ARP、RARP</code>，所以只需要2个字节<ul><li>TCP&#x2F;IPv4：0x0800</li><li>ARP请求或响应：0x0806</li><li>RARP：0x8035</li><li>Novell网络层IPX协议：0x8137（这个了解即可）</li></ul></li><li>数据载荷：46B-1500B，<strong>满足最小帧长64B</strong>和最大帧长1518B的要求</li><li>FCS（4B）：使用<strong>CRC-32</strong>校验计算出来是帧检验序列（计算包括了除FCS字段的全部内容）</li></ul><p>这便就是以太网<strong>固定添加的报头</strong>，在进行解包的时候，我们只需要取走数据最前面的14个字节（6+6+2），再丢弃末尾的4个FCS的字节，就能取到上层（网络层）的原始数据。</p><h3 id="7-2-2-MAC帧中的MTU"><a href="#7-2-2-MAC帧中的MTU" class="headerlink" title="7.2.2 MAC帧中的MTU"></a>7.2.2 MAC帧中的MTU</h3><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sugelantianxin/article/details/117930398">网络协议-最大传输单元 MTU</a></p></blockquote><p>请注意，数据链路层的MTU是1500，其实是IP可以交付的（包括IP报头）的长度是1500，这个<strong>1500是不包含以太网帧的报头的！</strong></p><p>以太网帧的<strong>报头是18字节</strong>（包括MAC头部和FCS），如上图所示。实际上能传输的数据大小是 <code>[64 -18, 1518 - 18] = [46, 1500]</code>；</p><p>这个限制是为了满足数据链路层中<code>最大帧/最小帧</code>的要求，其中如果有效载荷不满足46字节，则会自动补0；多余的部分需要在网络层进行分片。</p><h3 id="7-2-3-物理层8字节前导码"><a href="#7-2-3-物理层8字节前导码" class="headerlink" title="7.2.3 物理层8字节前导码"></a>7.2.3 物理层8字节前导码</h3><p>在以太网V2的<strong>物理层</strong>，还会给<strong>MAC帧</strong>前加上8个字节的前导码；</p><ul><li>前7字节为前同步码</li><li>后1字节为帧开始定界符（以太网帧中没有帧定界符）</li></ul><h3 id="7-2-4-不可靠传输"><a href="#7-2-4-不可靠传输" class="headerlink" title="7.2.4 不可靠传输"></a>7.2.4 不可靠传输</h3><p>以太网v2的数据链路层<strong>不提供可靠传输机制</strong>，遇到错误会直接丢弃。</p><ul><li>MAC帧长度不是整数字节</li><li>MAC帧的FCS字段检验出错</li><li>MAC帧长度不在<code>[64,1518]</code>范围内</li></ul><h3 id="7-2-5-FCS字段"><a href="#7-2-5-FCS字段" class="headerlink" title="7.2.5 FCS字段"></a>7.2.5 FCS字段</h3><p>MAC帧中的FCS字段为4字节（32比特），采用是CRC校验码是CRC-32；</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/9521d05a3c71cc4acff987483ec14968.png" alt="image-20231217102953795"></p><h2 id="7-3-认识MAC地址"><a href="#7-3-认识MAC地址" class="headerlink" title="7.3 认识MAC地址"></a>7.3 认识MAC地址</h2><p>MAC地址就好比网络层里面的IP地址，是用来标识数据链路层中的主机的。</p><ul><li>MAC地址用来识别数据链路层中相连的节点；</li><li>MAC地址长度为48位（6个字节）一般用十六进制加上冒号的方式来表示，例如<code>08:00:27:03:fb:19</code></li><li>MAC地址在网卡出场的时候就确定了，不能被修改。虚拟机中的MAC地址并不是真实的MAC地址，可能会和已有的冲突（但虚拟机会检测冲突并及时修改，不然虚拟机就上不了网了）也有很少部分网卡支持用户配置MAC地址</li></ul><p>MAC地址又称为<code>物理地址</code>，当你看到物理地址这个概念时，需要知道它指的是数据链路层里面的MAC地址，并不是物理层里面的概念！</p><h3 id="7-3-1-MAC地址和IP协议的区别"><a href="#7-3-1-MAC地址和IP协议的区别" class="headerlink" title="7.3.1 MAC地址和IP协议的区别"></a>7.3.1 MAC地址和IP协议的区别</h3><p>MAC地址和IP地址的区别如下：</p><ul><li>IP地址描述的是路途总体的起点和终点</li><li>MAC地址描述的是路途上每一个小路由区间的起点和终点</li></ul><p>因为我们的主机不可能知道一个很远的内网主机的MAC地址，所以就需要MAC地址在小路由区间来标识起点和终点，并实现正确的数据传输。</p><h3 id="7-3-2-MAC地址的唯一性"><a href="#7-3-2-MAC地址的唯一性" class="headerlink" title="7.3.2 MAC地址的唯一性"></a>7.3.2 MAC地址的唯一性</h3><p>这里需要知道一个小知识，虽然MAC地址在一定程度上可以认为是全球唯一的，但实际上只需要保证同一个局域网内的MAC地址是唯一的，就OK了</p><h2 id="7-4-MTU对上层的影响"><a href="#7-4-MTU对上层的影响" class="headerlink" title="7.4 MTU对上层的影响"></a>7.4 MTU对上层的影响</h2><h3 id="7-4-1-MTU对IP的影响"><a href="#7-4-1-MTU对IP的影响" class="headerlink" title="7.4.1 MTU对IP的影响"></a>7.4.1 MTU对IP的影响</h3><p>在前文提到过，为了避免光电信号在物理层传输的时候出现冲突，需要限制网络层给数据链路层传输的单次的数据大小，MTU的具体说明可以参考本文 <a href="#jump1">2.2.1 认识MTU</a>；</p><p>因为MTU的存在，网络层IP协议中需要对较大的数据包进行分包（IP分片和组装问题在上文也谈过了，这里就不重复了）</p><p>但因为IP协议层分片和组装对于传输层来说是不可见的，如果IP分片后出现丢包导致数据丢失，那么传输层就必须得重传。所以传输层为了避免这种不受自己控制的事情，最终分片的操作应该是由<strong>传输层</strong>来进行处理才是最好的；</p><h3 id="7-4-2-MTU对UDP的影响"><a href="#7-4-2-MTU对UDP的影响" class="headerlink" title="7.4.2 MTU对UDP的影响"></a>7.4.2 MTU对UDP的影响</h3><p>UDP最大可以传输数据是 <code>2^16</code>字节，也就是<code>64KB</code>，而1500字节是<code>1.5KB</code>；也就是说，只要UDP携带的数据超过 <code>1472 (1500 - 20 IP首部 - 8 UDP首部)</code>，那么就会在网络层被分为多个IP数据报。</p><p>一旦这个数据报中有一个IP报文丢失了，那么整个UDP报文就会丢失。再加上UDP并没有超时重传机制（不过可以根据具体的协议来定制应答和重传机制来保证数据可靠性），UDP的报文在IP层中被分片后丢包的概率远大于TCP</p><h3 id="7-4-3-MTU对TCP的影响"><a href="#7-4-3-MTU对TCP的影响" class="headerlink" title="7.4.3 MTU对TCP的影响"></a>7.4.3 MTU对TCP的影响</h3><ul><li>TCP的一个数据报也不能无限大，还是受制于MTU</li><li>TCP的单个数据报的最大消息长度，称为<code>MSS(Max Segment Size)</code>;</li><li>TCP在建立连接的过程中，通信双方会进行MSS协商。最理想的情况， MSS的值正好是在IP不会被分片处理的最大长度(这个长度仍然是受制于数据链路层的 MTU)。</li><li>双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值。然后双方得知对方的MSS值之后，选择较小的作为最终MSS，进行数据传输；</li><li>MSS的值在TCP首部的40字节变长选项中 <code>(kind=2)</code>；</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/e1f2b9c52380a6bfb16d1e3ccb5c208d.png" alt="image-20230821185112918"></p><h3 id="7-4-4-MSS"><a href="#7-4-4-MSS" class="headerlink" title="7.4.4 MSS"></a>7.4.4 MSS</h3><p>除了MTU，还有另外一个概念是MSS，既<strong>应用层</strong>中有效数据部分的长度</p><ul><li>MAC帧中有效数据长度是<code>[46,1500]</code>；</li><li></li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/b4f7547b20f6d6207f43f2cee952dd35.png" alt="image-20230821202306869"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/544017c8a47d9adea902832cff849d3e.png" alt="image-20231121221114046"></p><h2 id="7-5-ARP协议"><a href="#7-5-ARP协议" class="headerlink" title="7.5 ARP协议"></a>7.5 ARP协议</h2><p>ARP协议<strong>属于数据链路层</strong>，可以认为是MAC帧协议的“上层”</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/17b6b24463f26ddb5b6c8fd2f7ab0006.png" alt="image.png"></p><h3 id="7-5-1-说明"><a href="#7-5-1-说明" class="headerlink" title="7.5.1 说明"></a>7.5.1 说明</h3><p>因为在局域网内的传输时，我们是用MAC地址来作为不同主机的标识符的，所以就必须存在一个IP地址到MAC地址的转换。</p><p>ARP协议也是包含在以太网帧格式这个整体概念中的，其中属于ARP自己的正文只有28个字节；因为MTU限制最小的数据长度是46字节，所以在发送ARP报文的时候，需要给这个28字节后面填补空位。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/08/2e608f063bce6f728307d40d2aa275d3.png" alt="image-20230821192339835"></p><p>先来看看ARP请求&#x2F;应答中的各个字段的含义吧</p><ul><li>硬件类型：标定底层使用的是以太网还是其他帧格式，1为以太网</li><li>协议类型：指要转换的地址类型，<code>0X0800</code>为IP地址</li><li>硬件地址长度：对于以太网来说为6字节（这里填的是数字6，所以只需要占用1个字节）；</li><li>协议地址长度：对于IP地址来说为4字节（同上）；</li><li><code>op</code>字段为1表示ARP请求，2表示ARP应答</li></ul><p>当我们的主机开始发送报文之前，我们的主机是不知道某一个IP对于的目标主机的MAC地址的。所以就需要用ARP协议向局域网内发送一个请求，并得到目标主机的ARP响应，响应中就包含了该主机的MAC地址</p><h3 id="7-5-2-ARP请求-x2F-响应的流程"><a href="#7-5-2-ARP请求-x2F-响应的流程" class="headerlink" title="7.5.2 ARP请求&#x2F;响应的流程"></a>7.5.2 ARP请求&#x2F;响应的流程</h3><p>主机A需要给主机B发送数据，但是不知道主机B的MAC地址，它就需要发起一个ARP请求：</p><ul><li>以太网目的地址填为<strong>全F</strong>，代表广播；源地址填自己的MAC地址</li><li>帧类型填<code>0806</code>代表ARP协议；</li><li>ARP中的OP填为1，代表是ARP请求；</li><li>发送端以太网地址和IP地址填为<strong>主机A</strong>自己的MAC地址和自己的IP地址；</li><li>目的以太网地址填为全F，IP地址填为目的的IP地址（注意我们是知道对方IP地址的）；</li><li>向下交付给以太网的MAC帧，然后送入局域网；</li></ul><p>这个ARP请求的报文就开始在局域网内进行<strong>广播</strong></p><ul><li>收到这个ARP请求的主机在MAC帧收到，并向上交付给自己的ARP层；</li><li>ARP层先通过OP为1判断是ARP的请求；</li><li>取出请求中的目的IP地址，判断是否为本机IP地址，不是则丢弃；</li><li>是本机的IP地址，代表这个报文是发给自己的ARP请求，需要构造ARP响应；</li></ul><p>于是<strong>主机B</strong>就收到了这个ARP请求，并开始构造ARP响应</p><ul><li>以太网目的地址填为ARP请求中的发送端MAC地址，源MAC地址填自己的</li><li>帧类型填<code>0806</code>代表ARP协议</li><li>ARP中的OP填2，代表ARP响应</li><li>发送端以太网地址和IP地址填为<strong>主机B</strong>自己的MAC地址和自己的IP地址</li><li>目的以太网地址填为A的MAC地址（在ARP请求中得知的）IP地址填为目的主机A的IP地址</li><li>向下交付给以太网的MAC帧，然后送入局域网</li></ul><p>此时这个ARP的响应就开始在局域网中传输，因为此时以太网的目的地址不再是全F，所以各个收到这个报文的主机，<strong>就可以直接通过MAC地址来判断是否是发给自己的MAC帧</strong>。如果不是就直接丢弃，不交付给上层；</p><p><strong>主机A</strong>判断目的MAC帧是自己的，交付给上层的ARP协议</p><ul><li>判断ARP中的OP为2，代表是ARP响应</li><li>因为前面已经判断过目的MAC地址是自己的了，所以这时候不需要判断ARP中的目的MAC和目的主机IP了</li><li>直接取出发送端主机MAC和主机IP，就能得到主机B的IP和MAC地址的映射关系</li></ul><p>这时候主机A就<strong>得到了主机B的MAC地址</strong>，可以正常进行数据的发送了！</p><h3 id="7-5-3-ARP缓存与更新"><a href="#7-5-3-ARP缓存与更新" class="headerlink" title="7.5.3 ARP缓存与更新"></a>7.5.3 ARP缓存与更新</h3><ul><li>任何一台主机发出的一定是ARP的请求；</li><li>接收到的ARP可能是对方向往发送的ARP请求，也可能是我发送的ARP请求的响应；</li></ul><p>但如果每台主机都不知道IP和MAC的映射关系，岂不是每次发送数据之前，都需要来个ARP请求和响应来获取对方MAC地址？这样整个局域网内就得被ARP请求和响应给塞满了。</p><p>所以，当我们发送了一个ARP请求后，应该需要将ARP响应给暂时<strong>缓存</strong>到本机上，避免下次发送的时候不知道对方的MAC地址。操作系统中就有一张ARP缓存表，保存了局域网内部分主机的IP和MAC地址的映射关系。</p><blockquote><p>如果一个主机想获取到局域网内所有的MAC地址，就可以写个循环，把局域网内的所有IP都发送一次ARP请求，再将收集到的ARP响应给缓存起来（因为局域网内的主机网络号都是相同的，主机号都是是从1到254，并不多，写个循环就行了）</p></blockquote><p>但这里会有一个问题：如果某台主机B离开了你这个局域网，主机C接入后，路由器给主机C分配了原本是给主机B用的IP，这时候主机A里面的ARP缓存表没有更新，还是填了主机B的MAC地址（但主机B其实已经不在局域网里面了），这时候这个报文岂不是找不到目标主机了？</p><p>所以ARP不仅仅需要缓存，还需要保有一定的<strong>更新机制</strong>：可以设置一个定时器，定时向缓存表中已有IP的主机发送一条ARP请求，并得到对方的ARP响应。这时候就可以比对返回的MAC地址是否有变动，有变动则更新。</p><p>如果一个ARP请求长时间没有得到响应，则可以认为该IP地址目前没有对应的主机，将其从缓存表中删除。</p><h3 id="7-5-4-中间人攻击"><a href="#7-5-4-中间人攻击" class="headerlink" title="7.5.4 中间人攻击"></a>7.5.4 中间人攻击</h3><p>上文讲述了ARP的请求和响应的格式，假设出现了下面的这个情况：</p><ul><li>主机A想获取主机B的MAC，发送ARP请求并获取到了响应</li><li>主机D把自己的IP伪装成主机B的IP，又给主机A发送了ARP响应</li><li>此时主机A更新了ARP缓存表，将主机B的IP B映射给了MAC D</li><li>主机D用同样的办法，将主机B的ARP缓存表中的IP A映射给了MAC D</li><li>此时主机A给B发送消息，填的是MAC D；B给A发消息，填的也是MAC D；</li><li>主机D在收到A和B双方通信的报文后，先交付给自己的上层，再转发给对方；</li><li>A和B的双方通信就出现了一个<strong>中间人D</strong>，此时如果你的信息不是加密的，那就可以被主机D所窃取！</li></ul><p>这也是为啥出现了https来避免中间人攻击！</p><h3 id="7-5-5-RARP"><a href="#7-5-5-RARP" class="headerlink" title="7.5.5  RARP"></a>7.5.5 RARP</h3><p>RARP（Reverse Address Resolution Protocol，逆地址解析协议）是一种网络协议，用于在局域网（LAN）<strong>中通过已知的物理地址查找相应的IP地址</strong>。</p><p>与前面讲述的ARP（Address Resolution Protocol，地址解析协议）不同，ARP用于通过已知的IP地址查找相应的物理地址，通常用于将网络层（IP）地址映射到链路层（MAC）地址。<strong>RARP则执行相反的操作</strong>，它允许主机在启动时使用其物理地址来请求分配给它的IP地址。</p><p>RARP协议在过去的计算机网络中用于在没有人工配置的情况下为计算机分配IP地址。当计算机启动时，它会向网络发送一个RARP请求包，其中包含它的物理地址（MAC地址），以请求分配一个IP地址。网络中的RARP服务器会接收这个请求并回复包含IP地址的RARP响应包。</p><p>然而，随着时间的推移，RARP的使用逐渐减少，主要是因为它的局限性，例如不太适用于大型网络，以及需要特定的服务器来管理地址分配。现代的网络通常使用DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）来实现类似的功能，它更灵活且易于管理，可以自动分配IP地址以及其他网络配置参数给主机。</p><h2 id="7-6-虚拟局域网VLAN"><a href="#7-6-虚拟局域网VLAN" class="headerlink" title="7.6 虚拟局域网VLAN"></a>7.6 虚拟局域网VLAN</h2><h3 id="7-6-1-问题说明"><a href="#7-6-1-问题说明" class="headerlink" title="7.6.1 问题说明"></a>7.6.1 问题说明</h3><p>我们常用的<strong>以太网交换机</strong>工作在数据链路层+物理层，使用以太网交换机互连起来的交换式以太网，其所有站点都属于同一个<strong>广播域</strong>。</p><p>但是巨大的广播域会造成一些问题，比如难以管理和维护、潜在安全问题（一个设备可以攻击整个巨大的广播域中的所有设备）、广播风暴。</p><blockquote><p>当局域网内的A要给B发送一个MAC帧的时候，首先需要用ARP协议获取目标设备的MAC地址。此时这个<strong>ARP请求</strong>就会被局域网内的所有设备都收到，每个设备收到ARP请求需要判断它是不是发给自己的，这就造成了无效的CPU资源浪费</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0ac410afeea05bbb70028a0c7ce2c018.png" alt="image-20231217103821673"></p><p>如果局域网内不会频繁出现广播信息，这个问题还不是很严重。但是当前使用的很多协议都会发出广播，网络中会频繁出现广播信息，这就很难受了。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b10365bfa9422709c22a7a98d887c017.png" alt="image-20231217105549873"></p><p>为了解决这个问题，引入了虚拟局域网VLAN技术，来将一个大的广播域划分为各个小的广播域。</p><p>除了使用虚拟局域网，还可以使用<strong>路由器</strong>来隔离广播域。但是路由器成本较高，虚拟局域网只需要在支持的交换机中进行设置即可，成本较低。</p><h3 id="7-6-2-虚拟局域网VLAN"><a href="#7-6-2-虚拟局域网VLAN" class="headerlink" title="7.6.2 虚拟局域网VLAN"></a>7.6.2 虚拟局域网VLAN</h3><p>虚拟机局域网 Virtul Local Area Network 是一种将局域网内设备化为与物理位置无关的逻辑组的技术，让这些逻辑组成为一个独立的逻辑上的局域网。</p><p>如下图，使用VLAN1和VLAN2对设备进行隔离后，只有同一个VLAN里面的设备才能相互通信，不同VLAN直接不会收到相互的广播域。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c833d51f03f6688d021cd17182b014fb.png" alt="image-20231217110239038"></p><h3 id="7-6-3-VLAN实现机制"><a href="#7-6-3-VLAN实现机制" class="headerlink" title="7.6.3 VLAN实现机制"></a>7.6.3 VLAN实现机制</h3><h4 id="VLAN标记字段"><a href="#VLAN标记字段" class="headerlink" title="VLAN标记字段"></a>VLAN标记字段</h4><p>交换机在收到一个常规的MAC帧后，会在其源MAC地址字段和类型字段之间插入一个4字节的VLAN标记字段，将MAC帧转为了<code>IEEE 802.1Q</code>帧。这个VLAN标记字段能告诉我们当前这个MAC帧属于哪一个VLAN，从而实现VLAN隔离。</p><p>VLAN标记中的最后12比特为VLAN标识符VID，它唯一的标识了以太网帧属于哪一个VLAN。</p><ul><li>取值范围是0到4095（0到2的12次方-1）</li><li>但是0和4095都不使用，<strong>实际可用为1到4094</strong></li></ul><p>注意，这个操作是由交换机来实现的，而不是用户主机实现的。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/e443301690be6308b80f0b45fb208140.png" alt="image-20231217110509950"></p><h4 id="交换机端口类型"><a href="#交换机端口类型" class="headerlink" title="交换机端口类型"></a>交换机端口类型</h4><p>交换机的端口类型有下面三种</p><ul><li>Access</li><li>Trunk</li><li>Hybrid</li></ul><p>在不同品牌的交换机上，每一个端口都会有一个缺省的VLAN ID</p><ul><li>思科交换机上称为Native VLAN，即本征VLAN</li><li>华为交换机上称为Port VLAN ID，即端口VLAN ID，简记为PVID</li></ul><h5 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h5><p>在<strong>Access端口</strong>中，一般只用于连接用户计算机，且它只支持“未打标签”的普通以太网MAC帧，收到帧后再给它打标签，确认要转发目标也是Access端口的主机时，则去标签转发。</p><ul><li>Access端口只能属于一个VLAN（一个端口不能同时属于两个VLAN）</li><li>Access端口的PVID值和端口所属的VLAN ID相同</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/9fe280a47f8ed26149fcd30af48c9937.png" alt="image-20231217111245910"></p><p>当我们划分出两个VLAN，并将不同的Access端口添加到对应VLAN中后，发送帧时，交换机会添加VLAN标记字段，再判断它属于哪一个VLAN，比如右侧C主机发送广播帧后，交换机加上VLAN字段后，发现它是属于VLAN3的，于是只会在VLAN3中对这个帧进行广播转发，不会影响VLAN2里面的设备。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/99ab1ce9d3588c6347cc1172b42b49b1.png" alt="image-20231217111421321"></p><h5 id="Trunk"><a href="#Trunk" class="headerlink" title="Trunk"></a>Trunk</h5><p>Trunk端口一般用于两个交换机的连接（一个交换机接口不够用了），它可以属于多个VLAN，并供用户设置VLAN ID的值；</p><ul><li>下图所示，我们将Trunk端口的PVID设置为1，假设A发送帧，因为从Access端口接受，交换机1会对其加上VLAN ID字段。并检测当前交换机中有哪些端口的PVID是1</li><li>因为2号Access端口和5号Trunk端口的PVID都为1，交换机1将该帧去端口转发给主机B和Trunk端口</li><li>交换机2从5号Trunk端口收到该帧，因为它内部没有打标签，所以它知道该帧的PVID和Trunk端口的PVID相同，将其打上VLAN1的ID，并检测交换机器2中那些端口的PVID为1，将其去标签转发给主机E和F</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b3b2b57e257c111333acbb9c55254452.png" alt="image-20231217111927004"></p><p>如果是C主机发送广播帧，此时该帧的PVID和5号Trunk端口的PVID不符合，交换机1会将该帧不去标签从Trunk端口转发出去（即不管Trunk端口的PVID是多少，交换机都需要将报文发给他，只不过发送的内容是否有标签的区别）</p><p>交换机2收到这个带VLAN2标签的帧后，就会直接检测那些端口的PVID为2，将其去标签转发给对应主机。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/625e0e2b0b4ac96e4c2024f45d82c1a2.png" alt="image-20231217112451365"></p><p>下面是一个练习题</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b662d8449476a66c0b53cf104d5d2546.png" alt="image-20231217112554010"></p><p>答案如下，需要注意两个交换机互联时，Trunk端口的PVID必须要设置为相同的值，否则会出现错误转发的情况。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0f6a71a151905140d1a4036b1244b955.png" alt="image-20231217112627996"></p><h5 id="Hybrid（华为交换机私有）"><a href="#Hybrid（华为交换机私有）" class="headerlink" title="Hybrid（华为交换机私有）"></a>Hybrid（华为交换机私有）</h5><p>Hybrid端口可以单独设置需要对那些PVID进行去标签操作，当收到帧的PVID不在去标签设置中时，会直接发送给主机，此时主机收到一个不支持的<code>IEEE 802.1Q</code>帧，会将其丢弃！</p><p>而如果一个帧的PVID在去标签的设置中，则去标签后再发送给主机。此时主机就能收到一个正常的MAC帧，从而进行处理。</p><p>通过给不同端口设置去标签VID值，其实就是变相的设置了该端口能属于那些VLAN，从而受到不同VLAN里面的帧，设置比固定的单个VLAN更加灵活！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/e94dc28c208ae477923b35d60cd67b05.png" alt="image-20231217112923088"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li>数据链路层的作用：两个设备(同一种数据链路节点)之间进行传递数据；</li><li>以太网是一种技术标准；既包含了数据链路层的内容， 也包含了一些物理层的内容。 例如: 规定了网络拓扑结构, 访问控制方式, 传输速率等；</li><li>以太网帧格式</li><li>理解mac地址</li><li>理解arp协议</li><li>理解MTU</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>网络层的作用: 在复杂的网络环境中确定一个合适的路径.</li><li>理解IP地址, 理解IP地址和MAC地址的区别</li><li>理解IP协议格式</li><li>了解网段划分方法</li><li>理解如何解决IP数目不足的问题, 掌握网段划分的两种方案</li><li>理解私有IP和公网IP</li><li>理解网络层的IP地址路由过程</li><li>理解一个数据包如何跨越网段到达最终目的地</li><li>理解IP数据包分包的原因</li><li>了解NAT设备的工作原理</li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul><li>传输层的作用: 负责数据能够从发送端传输接收端</li><li>理解端口号的概念</li><li>认识UDP协议, 了解UDP协议的特点。</li><li>认识TCP协议，理解TCP协议的可靠性</li><li>理解TCP协议的状态转化</li><li>掌握TCP的连接管理，确认应答, 超时重传, 滑动窗口, 流量控制, 拥塞控制, 延迟应答, 捎带应答特性</li><li>理解TCP面向字节流, 理解粘包问题和解决方案</li><li>能够基于UDP实现可靠传输</li><li>理解MTU对UDP&#x2F;TCP的影响</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>应用层的作用: 满足我们日常需求的网络程序, 都是在应用层</li><li>能够根据自己的需求，设计应用层协议</li><li>了解HTTP协议</li><li>理解DNS的原理和工作流程</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/3482559497/">https://blog.musnow.top/posts/3482559497/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://img.musnow.top/i/2023/07/f93a3878d288a436d0a9f8320202f3c0.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2254346194/" title="【C++】早绑定、析构与多态 | 一道关于多态的选择题记录"><img class="cover" src="/img/bg/gm17.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【C++】早绑定、析构与多态 | 一道关于多态的选择题记录</div></div></a></div><div class="next-post pull-right"><a href="/posts/3018206681/" title="【牛客网】BM1：翻转链表"><img class="cover" src="https://img.musnow.top/i/2023/08/64e1df7f0a9d9.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【牛客网】BM1：翻转链表</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/3787294814/" title="【Linux】权限管理"><img class="cover" src="/img/bg/gm14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-13</div><div class="title">【Linux】权限管理</div></div></a></div><div><a href="/posts/3785030062/" title="【Linux】进程概念"><img class="cover" src="/img/bg/gm19.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-31</div><div class="title">【Linux】进程概念</div></div></a></div><div><a href="/posts/656771008/" title="【Linux】使用腾讯云搭建CentOS的Linux编程学习环境，实现多用户使用同一个云服务器"><img class="cover" src="/img/bg/gm20.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-06</div><div class="title">【Linux】使用腾讯云搭建CentOS的Linux编程学习环境，实现多用户使用同一个云服务器</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">358</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1.概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.1 四层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%B8%BB%E6%9C%BA%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E3%80%81%E8%8A%82%E7%82%B9"><span class="toc-text">1.2 主机、路由器、节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-IP%E6%8A%A5%E6%96%87"><span class="toc-text">2.IP报文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-text">2.1 报文结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%88%86%E7%89%87"><span class="toc-text">2.2 分片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%AE%A4%E8%AF%86MTU"><span class="toc-text">2.2.1 认识MTU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%A6%82%E4%BD%95%E5%88%86%E7%89%87"><span class="toc-text">2.2.2 如何分片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%89%87%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-text">分片练习题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%94%B6%E5%AE%8C%E4%BA%86%E4%B8%80%E6%95%B4%E4%B8%AA%E5%88%86%E7%89%87%E7%BB%84%EF%BC%9F"><span class="toc-text">2.2.3 如何保证收完了一整个分片组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%88%86%E7%89%87"><span class="toc-text">2.2.4 如何减少分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E5%88%86%E7%89%87%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">2.2.5 分片的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-TTL"><span class="toc-text">2.3 TTL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5"><span class="toc-text">2.4 协议字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E9%A6%96%E9%83%A8%E6%A3%80%E9%AA%8C%E5%92%8C"><span class="toc-text">2.5 首部检验和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E4%BE%8B%E9%A2%98%EF%BC%9A%E4%BB%8E%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%AD%E8%AF%BB%E5%8F%96%E7%9B%AE%E6%A0%87IP%E5%9C%B0%E5%9D%80"><span class="toc-text">2.6 例题：从以太网帧字节流中读取目标IP地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BD%91%E6%AE%B5%E5%88%92%E5%88%86"><span class="toc-text">3.网段划分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-IP%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%AF%B9%E6%96%B9%E4%B8%BB%E6%9C%BA%EF%BC%9F"><span class="toc-text">3.1 IP如何找到对方主机？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">3.1.1 发送数据的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7"><span class="toc-text">3.1.2 网络号和主机号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-IP%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%88%AB%E5%88%92%E5%88%86"><span class="toc-text">3.2 IP地址类别划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-ABCDE"><span class="toc-text">3.2.1 ABCDE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-CIDR%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-text">3.2.2 CIDR和子网掩码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD"><span class="toc-text">3.3 基础设施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%BC%93%E8%A7%A3IP%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%A4%9F%E7%94%A8%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="toc-text">3.4 缓解IP地址不够用的办法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%A7%81%E6%9C%89IP"><span class="toc-text">4.私有IP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%89%B9%E6%AE%8A%E7%9A%84IP%E5%9C%B0%E5%9D%80"><span class="toc-text">4.1 特殊的IP地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-loopback%E7%8E%AF%E5%9B%9E"><span class="toc-text">4.2 loopback环回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E7%8E%AF%E5%9B%9E"><span class="toc-text">4.2.1 环回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-ARP"><span class="toc-text">4.2.2 ARP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%AE%BF%E9%97%AE%E5%B9%BF%E5%9F%9F%E7%BD%91%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">4.3 访问广域网的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E8%AF%B4%E6%98%8E"><span class="toc-text">4.3.1 说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E5%85%AC%E7%BD%91%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">4.3.2 内网访问公网的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-NAT%E6%8A%80%E6%9C%AF"><span class="toc-text">4.3.3 NAT技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-NAT%E6%80%8E%E4%B9%88%E5%9B%9E%E6%9D%A5%EF%BC%9FNAPT"><span class="toc-text">4.3.4 NAT怎么回来？NAPT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-NAT%E5%92%8C%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">4.3.5 NAT和代理服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-1-NAT%E5%92%8C%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.3.5.1 NAT和代理服务器的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-2-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">4.3.5.2 反向代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-3-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">4.3.5.3 正向代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-ISP%E6%A3%80%E6%B5%8B%E5%AE%BD%E5%B8%A6%E8%B4%A6%E6%88%B7"><span class="toc-text">4.4 ISP检测宽带账户</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%9F%9F%E5%90%8D"><span class="toc-text">5.域名</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-DNS%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">5.1 DNS服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E4%B8%BB%E6%9C%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">5.2 域名访问主机流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-DNS%E5%8A%AB%E6%8C%81"><span class="toc-text">5.2.1 DNS劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-DNS%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">5.2.2 DNS和负载均衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-DNS%E5%88%86%E5%B1%82"><span class="toc-text">5.3 DNS分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-dig%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-text">5.4 dig工具分析DNS解析过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%B7%AF%E7%94%B1"><span class="toc-text">6.路由</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E9%97%AE%E8%B7%AF%E6%A0%97%E5%AD%90%EF%BC%88%E5%B8%AE%E5%8A%A9%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-text">6.1 问路栗子（帮助理解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="toc-text">6.2 路由表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-route%E5%91%BD%E4%BB%A4"><span class="toc-text">6.3 route命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-text">7.数据链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%AE%A4%E8%AF%86%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5"><span class="toc-text">7.1 认识局域网的基本情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%A4%E8%AF%86"><span class="toc-text">7.1.1 局域网认识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E7%A2%B0%E6%92%9E%E5%9F%9F"><span class="toc-text">7.1.2 碰撞域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E9%93%BE%E8%B7%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF"><span class="toc-text">7.1.3 链路和数据链路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F%EF%BC%88MAC%E5%B8%A7%EF%BC%89"><span class="toc-text">7.2 以太网帧格式（MAC帧）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="toc-text">7.2.1 MAC帧格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-MAC%E5%B8%A7%E4%B8%AD%E7%9A%84MTU"><span class="toc-text">7.2.2 MAC帧中的MTU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E7%89%A9%E7%90%86%E5%B1%828%E5%AD%97%E8%8A%82%E5%89%8D%E5%AF%BC%E7%A0%81"><span class="toc-text">7.2.3 物理层8字节前导码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">7.2.4 不可靠传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-FCS%E5%AD%97%E6%AE%B5"><span class="toc-text">7.2.5 FCS字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E8%AE%A4%E8%AF%86MAC%E5%9C%B0%E5%9D%80"><span class="toc-text">7.3 认识MAC地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-MAC%E5%9C%B0%E5%9D%80%E5%92%8CIP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.3.1 MAC地址和IP协议的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-MAC%E5%9C%B0%E5%9D%80%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-text">7.3.2 MAC地址的唯一性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-MTU%E5%AF%B9%E4%B8%8A%E5%B1%82%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">7.4 MTU对上层的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-MTU%E5%AF%B9IP%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">7.4.1 MTU对IP的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-MTU%E5%AF%B9UDP%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">7.4.2 MTU对UDP的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3-MTU%E5%AF%B9TCP%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">7.4.3 MTU对TCP的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-4-MSS"><span class="toc-text">7.4.4 MSS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-ARP%E5%8D%8F%E8%AE%AE"><span class="toc-text">7.5 ARP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E8%AF%B4%E6%98%8E"><span class="toc-text">7.5.1 说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-ARP%E8%AF%B7%E6%B1%82-x2F-%E5%93%8D%E5%BA%94%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">7.5.2 ARP请求&#x2F;响应的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3-ARP%E7%BC%93%E5%AD%98%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="toc-text">7.5.3 ARP缓存与更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-4-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-text">7.5.4 中间人攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-5-RARP"><span class="toc-text">7.5.5 RARP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN"><span class="toc-text">7.6 虚拟局域网VLAN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E"><span class="toc-text">7.6.1 问题说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN"><span class="toc-text">7.6.2 虚拟局域网VLAN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3-VLAN%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">7.6.3 VLAN实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VLAN%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5"><span class="toc-text">VLAN标记字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-text">交换机端口类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Access"><span class="toc-text">Access</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Trunk"><span class="toc-text">Trunk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hybrid%EF%BC%88%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-text">Hybrid（华为交换机私有）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">应用层</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2470995449/" title="【leetcode】95.不同的二叉搜索树2"><img src="/img/bg/gm17.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【leetcode】95.不同的二叉搜索树2"></a><div class="content"><a class="title" href="/posts/2470995449/" title="【leetcode】95.不同的二叉搜索树2">【leetcode】95.不同的二叉搜索树2</a><time datetime="2024-04-23T04:42:36.000Z" title="发表于 2024-04-23 12:42:36">2024-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3165124961/" title="【leetcode】96.不同的二叉搜索树"><img src="/img/bg/gm4.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【leetcode】96.不同的二叉搜索树"></a><div class="content"><a class="title" href="/posts/3165124961/" title="【leetcode】96.不同的二叉搜索树">【leetcode】96.不同的二叉搜索树</a><time datetime="2024-04-23T04:42:36.000Z" title="发表于 2024-04-23 12:42:36">2024-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/656037608/" title="【Linux】如何用一条命令终止某个后台进程？"><img src="/img/bg/gm16.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【Linux】如何用一条命令终止某个后台进程？"></a><div class="content"><a class="title" href="/posts/656037608/" title="【Linux】如何用一条命令终止某个后台进程？">【Linux】如何用一条命令终止某个后台进程？</a><time datetime="2024-04-23T01:14:50.000Z" title="发表于 2024-04-23 09:14:50">2024-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4112588292/" title="【leetcode】62不同路径和63不同路径2"><img src="/img/bg/gm7.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【leetcode】62不同路径和63不同路径2"></a><div class="content"><a class="title" href="/posts/4112588292/" title="【leetcode】62不同路径和63不同路径2">【leetcode】62不同路径和63不同路径2</a><time datetime="2024-04-20T02:31:40.000Z" title="发表于 2024-04-20 10:31:40">2024-04-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>