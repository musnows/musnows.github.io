<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>【Docker】Docker学习04 | dockerfile的编写 | 慕雪的寒舍</title><meta name="author" content="慕雪年华"><meta name="copyright" content="慕雪年华"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker学习第4话，学习编写dockerfile。"><meta property="og:type" content="article"><meta property="og:title" content="【Docker】Docker学习04 | dockerfile的编写"><meta property="og:url" content="https://blog.musnow.top/posts/188682082/index.html"><meta property="og:site_name" content="慕雪的寒舍"><meta property="og:description" content="Docker学习第4话，学习编写dockerfile。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.musnow.top/i/2024/07/919bea31fa7c37892d94c569cf17382b.png"><meta property="article:published_time" content="2024-07-21T06:04:27.000Z"><meta property="article:modified_time" content="2024-08-23T23:25:58.000Z"><meta property="article:author" content="慕雪年华"><meta property="article:tag" content="Docker"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.musnow.top/i/2024/07/919bea31fa7c37892d94c569cf17382b.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.musnow.top/posts/188682082/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="iR4A6ntiwhI9JX_YDe2ZFY6DerPD7c-NaLyIDlrDguY"><meta name="msvalidate.01" content="D5CD621F38EE3FB5071F785AD4977161"><meta name="baidu-site-verification" content="codeva-aZGKJiqRSI"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"距离上次更新本文已经过去了","messageNext":"天，文章部分内容可能已经过时，请注意甄别"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":420},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":600,"languages":{"author":"作者: 慕雪年华","link":"链接: ","source":"来源: 慕雪的寒舍","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"【Docker】Docker学习04 | dockerfile的编写",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-08-24 07:25:58"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/equipment/equipment.css?1"><script>!function(r){"use strict";!function(){var t=window,s=document,e=r,c="".concat("https:"===s.location.protocol?"https://":"http://","sdk.51.la/js-sdk-pro.min.js"),i=s.createElement("script"),n=s.getElementsByTagName("script")[0];i.type="text/javascript",i.setAttribute("charset","UTF-8"),i.async=!0,i.src=c,i.id="LA_COLLECT",e.d=i;function o(){t.LA.ids.push(e)}t.LA?t.LA.ids&&o():(t.LA=r,t.LA.ids=[],o()),n.parentNode.insertBefore(i,n)}()}({id:"JwxEfuZ8fwQ1GPEq",ck:"JwxEfuZ8fwQ1GPEq"})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="慕雪的寒舍" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">407</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image:url(https://img.musnow.top/i/2024/07/919bea31fa7c37892d94c569cf17382b.png)"><nav id="nav"><span id="blog-info"><a href="/" title="慕雪的寒舍"><img class="site-icon" src="/favicon.jpg"><span class="site-name">慕雪的寒舍</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 归档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-friends"></i><span> 友人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/fcircle/"><i class="fa-fw fas fa-link"></i><span> 朋友圈</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-train"></i><span> 开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><i class="fa-fw fab fa-superpowers"></i><span> 虫洞</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fas fa-globe-americas"></i><span> 异次元</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-glass-whiskey"></i><span> 镜像</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://blog.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-home"></i><span> Main</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog1.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-battle-net"></i><span> Netlify</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://musnows.github.io/?utm_source=mirror"><i class="fa-fw fa-brands fa-square-github"></i><span> Github</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog2.musnow.top/?utm_source=mirror"><i class="fa-fw fa-solid fa-square-caret-up"></i><span> Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog3.musnow.top/?utm_source=mirror"><i class="fa-fw fas fa-cloud"></i><span> Cloudflare</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://keep-hexo.musnow.top/?utm_source=mirror"><i class="fa-fw fa-brands fa-kickstarter"></i><span> KeepTheme</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen"><i class="fa-fw fas fa-copyright"></i><span> CSDN</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.51cto.com/u_15307009"><i class="fa-fw fas fa-dice-five"></i><span> 51CTO</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-blackberry"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fas fa-laptop"></i><span> 背包</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://memos.musnow.top"><i class="fa-fw fas fa-map-signs"></i><span> 说说</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/qrNpVSLkgV"><i class="fa-fw fas fa-chart-bar"></i><span> Uptime</span></a></li><li><a class="site-page child" href="/atom.xml"><i class="fa-fw fas fa-rss-square"></i><span> RSS</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Docker】Docker学习04 | dockerfile的编写</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-21T06:04:27.000Z" title="发表于 2024-07-21 14:04:27">2024-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-23T23:25:58.000Z" title="更新于 2024-08-24 07:25:58">2024-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">编程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/">Docker学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="【Docker】Docker学习04 | dockerfile的编写"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="ArtalkPV"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>dockerfile是构建docker镜像的基础，它规定了一系列语法，让我们可以在某个基础镜像之上，添加自己需要的操作，打包出一个自己的镜像。</p><h1 id="1-dockerfile基本语法"><a href="#1-dockerfile基本语法" class="headerlink" title="1. dockerfile基本语法"></a>1. dockerfile基本语法</h1><p>下面是dockerfile的基本语法和其对应的功能，dockerfile中的每一个指令都对应的<strong>镜像的一层</strong>。</p><p>除了这些构建语法外，在dockerfile中使用<code>#</code>开头的行代表注释行。注意，<strong>注释只能单成一行</strong>，不能在已有语句末尾追加。</p><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>RUN</td><td>在基础镜像上需要执行的命令（构建命令）</td></tr><tr><td>WORKDIR</td><td>其实就是cd的意思，设置镜像的工作目录</td></tr><tr><td>VOLUME</td><td>设置需要挂载文件实现持久化的目录</td></tr><tr><td>EXPOSE</td><td>指定容器对外暴露的端口</td></tr><tr><td>ENV</td><td>设置镜像中的环境变量</td></tr><tr><td>ARG</td><td>设置dockerfile<strong>构建过程中</strong>的环境变量</td></tr><tr><td>ENTRYPOINT</td><td>设置默认的可执行文件</td></tr><tr><td>HEALTHCHECK</td><td>在容器启动的时候进行健康检查</td></tr><tr><td>MAINTAINER</td><td>设置维护者信息（弃用，推荐用LABEL替代）</td></tr><tr><td>LABEL</td><td>给镜像添加元数据（如镜像作者）</td></tr><tr><td>ADD</td><td>添加本地&#x2F;远程的目录或文件</td></tr><tr><td>COPY</td><td>拷贝文件&#x2F;目录</td></tr><tr><td>ONBUILD</td><td>只有FROM基于当前镜像的时候才会执行</td></tr><tr><td>SHELL</td><td>设置镜像默认使用的shell</td></tr><tr><td>STOPSIGNAL</td><td>设置特定的系统信号来让容器退出</td></tr><tr><td>USER</td><td>设置<strong>执行构建命令</strong>的用户和用户组ID</td></tr></tbody></table><p>本文对这些命令的解释只停留于基础，更详细的介绍建议查看<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/">dockerfile</a>文档。</p><h1 id="2-dockerfile语法详解"><a href="#2-dockerfile语法详解" class="headerlink" title="2. dockerfile语法详解"></a>2. dockerfile语法详解</h1><h2 id="2-1-FROM"><a href="#2-1-FROM" class="headerlink" title="2.1. FROM"></a>2.1. FROM</h2><p>这个是指定当前需要构建的镜像的<strong>基础镜像</strong>，dockerfile文件中必须要有FROM字段。</p><p>比如我们有一个项目，需要在ubuntu环境上运行，我们就可以指定当前镜像是基于ubuntu镜像的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br></pre></td></tr></table></figure><p>这时候就出现了一个问题了，这些<strong>基础镜像</strong>是怎么制作出来的？以<a target="_blank" rel="noopener" href="https://github.com/CentOS/sig-cloud-instance-images/blob/CentOS-7.6.1810/docker/Dockerfile">CentOS 7.6</a>为例，官方的dockerfile是这么写的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> centos-7-docker.tar.xz /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.label-schema.schema-version=<span class="string">&quot;1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.name=<span class="string">&quot;CentOS Base Image&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.vendor=<span class="string">&quot;CentOS&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.license=<span class="string">&quot;GPLv2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.build-date=<span class="string">&quot;20181204&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>第一行的<code>FROM scratch</code>代表从“空”开始创建镜像，而第二行的ADD代表添加了一个文件。从Github仓库的<a target="_blank" rel="noopener" href="https://github.com/CentOS/sig-cloud-instance-images/blob/CentOS-7.6.1810/docker/Dockerfile">文件路径</a>中可以看到，官方使用了一个centos的<code>tar.xz</code>系统包，这个压缩包里面是系统运行的必要二进制文件。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/b6ef336c8962fcb547f8b3ae8b94953a.png" alt="image.png"></p><p>把这个<code>centos-7-docker.tar.xz</code>压缩包下载到本地，解压看看，内部其实就是一个centos系统的根路径下的必要内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">❯ tree -L 1 /tmp/centos7</span><br><span class="line">/tmp/centos7</span><br><span class="line">├── anaconda-post.log</span><br><span class="line">├── bin -&gt; usr/bin</span><br><span class="line">├── dev</span><br><span class="line">├── etc</span><br><span class="line">├── home</span><br><span class="line">├── lib -&gt; usr/lib</span><br><span class="line">├── lib64 -&gt; usr/lib64</span><br><span class="line">├── media</span><br><span class="line">├── mnt</span><br><span class="line">├── opt</span><br><span class="line">├── proc</span><br><span class="line">├── root</span><br><span class="line">├── run</span><br><span class="line">├── sbin -&gt; usr/sbin</span><br><span class="line">├── srv</span><br><span class="line">├── sys</span><br><span class="line">├── tmp</span><br><span class="line">├── usr</span><br><span class="line">└── var</span><br><span class="line"></span><br><span class="line">18 directories, 1 file</span><br></pre></td></tr></table></figure><p>至此可以明确一个概念，我们需要制作一个镜像，有两种方式：</p><ul><li>一个是基于开源的镜像的基础上二次构建；</li><li>第二种方式就是像centos官方一样，制作系统的二进制文件，从0开始构建镜像。</li></ul><p>如果不是有神马特殊需要，直接使用<strong>第一种方式</strong>，基于已有开源镜像的基础来构建镜像就够了。</p><h2 id="2-2-RUN"><a href="#2-2-RUN" class="headerlink" title="2.2. RUN"></a>2.2. RUN</h2><p>RUN字段指定了在基础镜像上需要执行的命令，通常用于安装环境。这些命令都等同于直接在基础镜像的shell中运行的命令。</p><p>RUN有两种语法格式，一种是直接写命令，另外一种是用exec的格式将命令和选项拼接起来。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;需要运行的命令&gt;</span></span><br><span class="line"><span class="comment"># 等价于直接运行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;apt&quot;</span>,<span class="string">&quot;install&quot;</span>,<span class="string">&quot;vim&quot;</span>] </span></span><br><span class="line"><span class="comment"># 等价于 RUN apt install vim</span></span><br></pre></td></tr></table></figure><p>比如我们创建一个ubuntu的容器，尝试在里面安装一个<code>net-tools</code>软件包，可以如下编写dockerfile。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt intstall -y net-tools</span></span><br></pre></td></tr></table></figure><p>如果你需要执行多个环境配置的命令，使用<code>&amp;&amp;</code>将其连接，而不要写多个RUN命令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	apt intstall -y net-tools</span></span><br></pre></td></tr></table></figure><h2 id="2-3-MAINTAINER和LABEL"><a href="#2-3-MAINTAINER和LABEL" class="headerlink" title="2.3. MAINTAINER和LABEL"></a>2.3. MAINTAINER和LABEL</h2><p>MAINTAINER和LABEL都是用于给docker镜像打标签的。你可以理解为给他身上挂个名牌，这样其他人就可以从名牌上看到和这个镜像相关的一些信息。</p><p>使用<code>docker inspect ubuntu:22.04</code>命令，可以看到ubuntu镜像上挂着的一些名牌。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.ref.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22.04&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而且我们基于<code>ubuntu:22.04</code>镜像构建的其他镜像，也会包含这个名牌。这可以让使用者在没有看到dockerfile的情况下，了解到你构建的镜像是基于ubuntu的。</p><p>下面的LABEL和MAINTAINER的语法格式，都是<code>key=value</code>的形式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br><span class="line"><span class="comment"># MAINTAINER 会设置镜像详情中的Author字段</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure><p>来简单试试吧</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> musnows</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> build.in=<span class="string">&quot;vmware-ubuntu&quot;</span></span></span><br></pre></td></tr></table></figure><p>使用这个dockerfile构建的镜像，会有下面的LABEL，且Author字段是<code>MAINTAINER</code>设置的musnows（ubuntu基础镜像中Author字段为空）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;Author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;musnows&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;build.in&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmware-ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.ref.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22.04&quot;</span></span><br><span class="line">	    <span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>另外，dockerfile的官方文档中提到，下面这个LABEL和MAINTAINER是对应的</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="string">&quot;SvenDowideit@home.org.au&quot;</span></span></span><br></pre></td></tr></table></figure><p>但经过我的测试，这个LABEL不会修改Author字段（只有MAINTAINER会修改Author字段）。你可以根据自己的需要选择使用LABEL还是MAINTAINER。</p><h2 id="2-4-SHELL"><a href="#2-4-SHELL" class="headerlink" title="2.4. SHELL"></a>2.4. SHELL</h2><p>这个命令用于设置镜像默认使用的SHELL。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;parameters&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>在<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/#shell">官方文档</a>中，有列出Linux和Windows下默认使用的SHELL是什么。如果它们不符合你的要求，比如你需要使用<code>/bin/bash</code>作为你的shell，则可以自行更换。</p><blockquote><p>The SHELL instruction allows the default shell used for the shell form of commands to be overridden. The default shell on Linux is<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>, and on Windows is <code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code>. The SHELL instruction must be written in JSON form in a Dockerfile.</p></blockquote><h2 id="2-5-WORKDIR"><a href="#2-5-WORKDIR" class="headerlink" title="2.5. WORKDIR"></a>2.5. WORKDIR</h2><p>设置docker构建过程和最终程序运行使用的工作路径。默认的工作路径是<code>/</code>根路径。如果指定的WORKDIR路径不存在，则会被创建。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure><p>另外，工作路径采用的是追加的方式，比如下方设置了多个工作路径，那么最终的工作路径是<code>/a/b/c/</code>这个目录。你可以理解为它本质上就是一个CD命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p>工作路径可以使用环境变量，前提这个环境变量是在dockerfile中被显式设置的</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DIRPATH=/path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$DIRPATH</span>/<span class="variable">$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p>此时pwd命令的输出是<code>/path/$DIRNAME</code>。</p><h2 id="2-6-COPY"><a href="#2-6-COPY" class="headerlink" title="2.6. COPY"></a>2.6. COPY</h2><p>COPY命令有两种方式，如果路径中包含空格，则必须使用第二种形式（将路径使用英文双引号括起来）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [OPTIONS] &lt;src&gt; ... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [OPTIONS] [<span class="string">&quot;&lt;src&gt;&quot;</span>, ... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>COPY命令支持使用<code>*</code>来匹配任意字符，<code>?</code>匹配单个字符。如果需要拷贝名称中包含<code>[]</code>的特殊文件，则需要使用Golang转义规则对文件名进行转义。详见<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/#copy">官方文档</a>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地文件 app.py 复制到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py /app/</span></span><br><span class="line"><span class="comment"># 将整个本地目录 my_app 复制到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> my_app/ /app/</span></span><br><span class="line"><span class="comment"># 复制所有以 .py 结尾的文件到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> *.py /app/</span></span><br><span class="line"><span class="comment"># 将 src 目录中所有文件复制到 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src/* /app/</span></span><br></pre></td></tr></table></figure><h3 id="2-6-1-选项说明"><a href="#2-6-1-选项说明" class="headerlink" title="2.6.1. 选项说明"></a>2.6.1. 选项说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--from</span><br><span class="line">--chown</span><br><span class="line">--chmod</span><br><span class="line">--link</span><br><span class="line">--parents</span><br><span class="line">--exclude</span><br></pre></td></tr></table></figure><h4 id="2-6-1-1-–from"><a href="#2-6-1-1-–from" class="headerlink" title="2.6.1.1. –from"></a>2.6.1.1. –from</h4><p><code>--from</code>选项允许COPY从多段构建中拷贝文件，或从其他镜像中拷贝文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--from=&lt;image|stage|context&gt;] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>比如我们可以从nginx镜像中直接拷贝配置文件，对应选项中的image</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure><p>我们还可以从多段构建中拷贝文件，对应选项中的stage。</p><p>下面是官网中一个多段构建的dockefile，在基础镜像alpine中使用clang编译了<code>hello.c</code>的程序，随后将这个程序的可执行文件移动到一个空的镜像中。这就相当于空镜像里面直接添加了一个可执行文件。不过这只是个例子，经过我的测试，这个镜像并不能正常运行😑。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> alpine AS build</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add clang</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> clang -o /hello hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /hello /</span></span><br></pre></td></tr></table></figure><p>在docker build命令中，可以指定多个构建的上下文，并在dockerfile中选择其中某个上下文中的文件进行拷贝，对应选项中的context。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行 Docker 构建时，指定两个构建上下文</span></span><br><span class="line">docker build -t myapp \</span><br><span class="line">  --build-context source1=. \</span><br><span class="line">  --build-context source2=../other-folder \</span><br><span class="line">  -f Dockerfile .</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Dockerfile 中，从指定的构建上下文 &quot;source2&quot; 中复制文件</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=source2 /extra-files/ /app/</span></span><br></pre></td></tr></table></figure><h4 id="2-6-1-2-–chown-–chmod"><a href="#2-6-1-2-–chown-–chmod" class="headerlink" title="2.6.1.2. –chown,–chmod"></a>2.6.1.2. –chown,–chmod</h4><p>这两个选项只有在Linux中构建镜像的时候才有效</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [--<span class="built_in">chmod</span>=&lt;perms&gt; ...] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>在COPY的时候，默认是使用0号PGID&#x2F;PUID进行操作的。如果你想避免默认的root权限，可以通过这两个选项进行修改。参数和linux本地的chown&#x2F;chmod命令一致。</p><h4 id="2-6-1-3-–link"><a href="#2-6-1-3-–link" class="headerlink" title="2.6.1.3. –link"></a>2.6.1.3. –link</h4><p>详见<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/#copy---link">官方文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY [--link[=&lt;boolean&gt;]] &lt;src&gt; ... &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>下面的图片展示了添加<code>--link</code>选项和不添加这个选项时的区别，使用的dockerfile很简单</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> foo /</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> bar /</span></span><br></pre></td></tr></table></figure><p>使用link的时候，会从一个空镜像里面构建文件，再最终合并到原有镜像上。最终产生的是独立的blob镜像层，而不是<code>diff(快照1,快照2)</code>这种两个镜像层之间的diff文件。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/919bea31fa7c37892d94c569cf17382b.png" alt="image.png"></p><h4 id="2-6-1-4-–parents"><a href="#2-6-1-4-–parents" class="headerlink" title="2.6.1.4. –parents"></a>2.6.1.4. –parents</h4><p>在拷贝文件的时候保留父目录。目前尚未在稳定版中推出此功能，需要使用<code>docker/dockerfile:1.7-labs</code>版本。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--parents[=&lt;boolean&gt;]] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>举个例子，当我们使用如下语句，拷贝a.txt到镜像中时，最终会存在<code>/app/a.txt</code>文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./b/a.txt /app/</span></span><br></pre></td></tr></table></figure><p>但如果加上了保留父目录的选项，则会保留这个txt文件的父目录b，最终会存在<code>/app/b/a.txt</code>文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --parents ./b/a.txt /app/</span></span><br></pre></td></tr></table></figure><p>在同时拷贝多个文件的时候，这样做就有效果了。如下所示，第一行的copy没有设置保留父目录，此时两个文件中的<code>a.txt</code>最终只在镜像内保留了一个（应该保留的是y的那一个），出现了文件被覆盖的问题。使用了<code>--parents</code>选项就不会有这个问题了。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1.7-labs</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./x/a.txt ./y/a.txt /no_parents/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --parents ./x/a.txt ./y/a.txt /parents/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /no_parents/a.txt</span></span><br><span class="line"><span class="comment"># /parents/x/a.txt</span></span><br><span class="line"><span class="comment"># /parents/y/a.txt</span></span><br></pre></td></tr></table></figure><h4 id="2-6-1-5-–excule"><a href="#2-6-1-5-–excule" class="headerlink" title="2.6.1.5. –excule"></a>2.6.1.5. –excule</h4><p>允许在拷贝的时候忽略某些路径中的内容。目前尚未在稳定版中推出此功能，需要使用<code>docker/dockerfile:1.7-labs</code>版本。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--exclude=&lt;path&gt; ...] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-7-ADD"><a href="#2-7-ADD" class="headerlink" title="2.7. ADD"></a>2.7. ADD</h2><p>ADD命令是更加高级的COPY命令，它有两种形式。如果路径中包含空格，则必须使用第二种形式（将路径使用英文双引号括起来）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [OPTIONS] &lt;src&gt; ... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [OPTIONS] [<span class="string">&quot;&lt;src&gt;&quot;</span>, ... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>当源文件是tar压缩文件，压缩方式为gzip、bzip或xz的情况下，ADD命令会自动将压缩包中的内容解压并复制到目标路径中。但是这个解压是不可以关闭的，即如果你不需要解压压缩包，则只能使用COPY命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 archive.tar.gz 解压缩到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> archive.tar.gz /app/</span></span><br><span class="line"><span class="comment"># 从 URL 下载文件并放在镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://example.com/file.txt /app/</span></span><br></pre></td></tr></table></figure><h3 id="2-7-1-选项说明"><a href="#2-7-1-选项说明" class="headerlink" title="2.7.1. 选项说明"></a>2.7.1. 选项说明</h3><p>下面是可选的OPTIONS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--keep-git-dir</span><br><span class="line">--checksum</span><br><span class="line">--chown</span><br><span class="line">--chmod</span><br><span class="line">--link</span><br><span class="line">--exclude</span><br></pre></td></tr></table></figure><h4 id="2-7-1-1-–keep-git-dir"><a href="#2-7-1-1-–keep-git-dir" class="headerlink" title="2.7.1.1. –keep-git-dir"></a>2.7.1.1. –keep-git-dir</h4><p>默认情况下，如果src是一个git仓库连接，则ADD会忽略<code>.git</code>目录。将下面这个选项设置为true，则会保留<code>.git</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--keep-git-dir=&lt;boolean&gt; </span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">ADD --keep-git-dir=<span class="literal">true</span> https://github.com/moby/buildkit.git<span class="comment">#v0.10.1 /buildkit</span></span><br></pre></td></tr></table></figure><h4 id="2-7-1-2-–checksum"><a href="#2-7-1-2-–checksum" class="headerlink" title="2.7.1.2. –checksum"></a>2.7.1.2. –checksum</h4><p>如果src是一个HTTP的连接（只支持HTTP&#x2F;HTTPS下载的文件），则可以使用checksum设置这个文件的校验和，ADD命令会在下载了文件之后自动进行校验，判断是否下载成功。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--checksum=&lt;<span class="built_in">hash</span>&gt;] &lt;src&gt; ... &lt;<span class="built_in">dir</span>&gt;</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --checksum=sha256:24454f830cdb571e2c4ad15481119c43b3cafd48dd869a9b2945d1036d1dc68d https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/linux-0.01.tar.gz /</span></span><br></pre></td></tr></table></figure><h4 id="2-7-1-3-剩余选项"><a href="#2-7-1-3-剩余选项" class="headerlink" title="2.7.1.3. 剩余选项"></a>2.7.1.3. 剩余选项</h4><p>剩下的几个选项，和COPY命令中的选项作用一致，详情可查看上文中对COPY命令的说明。</p><h2 id="2-8-CMD"><a href="#2-8-CMD" class="headerlink" title="2.8. CMD"></a>2.8. CMD</h2><p>CMD命令指定了容器以神马命令启动，同时它也可以是ENTRYPOINT的扩展</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接设置这个命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> executable param1 parma2</span></span><br><span class="line"><span class="comment"># 等价于上面这样直接设置</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="comment"># 如果设置了ENTREPOINT，可以在后面使用CMD设置额外的命令选项（可以被docker run改变）</span></span><br><span class="line"><span class="comment"># 注意，ENTREPOINT必须采用exec格式才能使用CMD继续追加命令选项！</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>如果一个容器没有指定ENTREPOINT或者CMD，则必须在docker run的时候指定才能正常运行。如果一个容器<strong>只指定了CMD</strong>，则可以被docker run指定的命令覆盖。</p><h2 id="2-9-ENTRYPOINT"><a href="#2-9-ENTRYPOINT" class="headerlink" title="2.9. ENTRYPOINT"></a>2.9. ENTRYPOINT</h2><p>ENTRYPOINT指定了容器以神马命令启动，同样有exec和shell两种格式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec格式</span></span><br><span class="line"><span class="comment"># 注意，ENTREPOINT必须采用exec格式才能使用CMD继续追加命令选项！</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="comment"># shell格式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure><p>设置了ENTRYPOINT后，在docker run里面提供的命令就不再是启动命令，而是发送给ENTRYPOINT命令的参数了。</p><p>前文提到了可以在ENTRYPOINT之后进一步设置CMD来启动进程，如下所示，下面这个dockerfile，最终启动进程使用的命令是<code>top -b -c</code>。其中<code>-c</code>选项会被docker run提供的命令覆盖（此时docker run提供的命令是发送给ENTRYPOINT命令的参数，会覆盖CMD）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;top&quot;</span>, <span class="string">&quot;-b&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-c&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>我们可以写个自己的程序来验证一下这里的命令行参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Run as: %s &quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;argc;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,argv[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会把我们提供的命令行参数打印出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o test</span><br><span class="line">$ ./test -c -o</span><br><span class="line">Run as: ./test -c -o </span><br></pre></td></tr></table></figure><p>使用如下dockerfile来进行操作</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> alpine AS build</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add clang</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> clang -o /test test.c</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/test&quot;</span>,<span class="string">&quot;-entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-cmd&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>使用如下命令，可见CMD的参数会追加在原有命令行参数之后，而且会被docker run使用的命令覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t myub</span><br><span class="line">$ docker run myub</span><br><span class="line">Run as: /test -entry -cmd </span><br><span class="line">$ docker run myub -run -h</span><br><span class="line">Run as: /test -entry -run -h </span><br></pre></td></tr></table></figure><p>根据dockerfile的官方文档，你可以用ENTRYPOINT指定稳定的命令选项，并使用CMD指定一些可用的命令选项</p><blockquote><p>You can use the exec form of ENTRYPOINT to set fairly stable default commands and arguments and then use either form of CMD to set additional defaults that are more likely to be changed.</p></blockquote><h2 id="2-10-ARG和ENV"><a href="#2-10-ARG和ENV" class="headerlink" title="2.10. ARG和ENV"></a>2.10. ARG和ENV</h2><h3 id="2-10-1-介绍"><a href="#2-10-1-介绍" class="headerlink" title="2.10.1. 介绍"></a>2.10.1. 介绍</h3><p>在介绍的表格里面说明了这两个语法的区别</p><ul><li>ARG：设置镜像构建过程中使用的环境变量，只有构建过程中才有效，构建完成的镜像中不包括这个环境变量，可以在<code>docker build</code>中通过<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>覆盖；</li><li>ENV：构建过程和镜像中都会存在的环境变量，可以在<code>docker run</code>中通过<code>-e &lt;key&gt;=&lt;value&gt;</code>来覆盖；</li></ul><p>同时这两个命令的语法也有细微区别，即ARG可以省略环境变量的默认值（相当于要求build的时候传入）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><h3 id="2-10-2-ENV测试"><a href="#2-10-2-ENV测试" class="headerlink" title="2.10.2. ENV测试"></a>2.10.2. ENV测试</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># env设置的环境变量，在构建过程和实际的容器中都会存在</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR=from_dockerfile</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>使用这个dockerfile构建一个镜像，并创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t myub:<span class="built_in">test</span> -f dockefile</span><br><span class="line">docker run --<span class="built_in">rm</span> myub:<span class="built_in">test</span>  <span class="comment"># --rm会在容器运行完毕后自动删除</span></span><br></pre></td></tr></table></figure><p>容器会在终端中输出我们刚刚设置的环境变量。注意这里我们是使用CMD命令来执行的这个echo语句，CMD是在容器创建之后，执行的命令，也就是ENV的设置已经保留到了容器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm myub:test</span><br><span class="line">MY_VAR is from_dockerfile</span><br></pre></td></tr></table></figure><p>使用<code>-it</code>交互式地创建这个容器，直接启动容器的bash终端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm myub:test /bin/bash</span><br></pre></td></tr></table></figure><p>在容器内的终端中使用env命令也可以看到这个环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@7cab70963b65:/# env</span><br><span class="line">MY_VAR=from_dockerfile</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/42915bc3579a24611a1c599a5a34111f.png" alt="image.png"></p><p>在docker run命令中用<code>-e</code>选项，可以覆盖这个环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -e MY_VAR=from_docker_run myub:<span class="built_in">test</span> </span><br></pre></td></tr></table></figure><p>执行效果如下，最终打印的环境变量是我们run命令中配置的了（容器内的环境变量也会被修改）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -e MY_VAR=from_docker_run myub:test</span><br><span class="line">MY_VAR is from_docker_run</span><br></pre></td></tr></table></figure><p>修改dockerfile中的CMD为RUN，让echo命令在构建过程中执行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># env设置的环境变量，在构建过程和实际的容器中都会存在</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR=from_dockerfile</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，构建过程中，ENV环境变量也生效了，会打印一个<code>[RUN] echo &quot;RUN MY_VAR is from_dockerfile</code>。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/178160d2912a0bdb3f056fada0ba1716.png" alt="image.png"></p><p>当然，生效的前提是ENV在RUN之前，如果ENV在RUN之后，那自然是无效了，打印的内容会变成<code>echo &quot;MY_VAR is $&#123;MY_VAR&#125;&quot;</code>这个原始内容。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/c3270bc5e9800978ae8f56845f6d1797.png" alt="image.png"></p><p>另外，ENV指定的环境变量必须赋值初始值，否则语法会报错</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># env设置的环境变量，在构建过程和实际的容器中都会存在</span></span><br><span class="line"><span class="comment"># 这里省略等于号是不支持的语法，如果不知道环境变量设置什么值，可以先等于空串</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>docker build的时候会提示语法错误，ENV必须要有两个参数（即必须要给定初始值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dockerfile:3</span><br><span class="line">--------------------</span><br><span class="line">   1 |     FROM ubuntu:22.04</span><br><span class="line">   2 |     # env设置的环境变量，在构建过程和实际的容器中都会存在</span><br><span class="line">   3 | &gt;&gt;&gt; ENV MY_VAR</span><br><span class="line">   4 |     RUN echo &quot;MY_VAR is $&#123;MY_VAR&#125;&quot;</span><br><span class="line">   5 |     </span><br><span class="line">--------------------</span><br><span class="line">ERROR: failed to solve: ENV must have two arguments</span><br></pre></td></tr></table></figure><h3 id="2-10-3-ARG测试"><a href="#2-10-3-ARG测试" class="headerlink" title="2.10.3. ARG测试"></a>2.10.3. ARG测试</h3><p>将ENV改成ARG，继续测试</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># arg设置的环境变量，在构建过程中才会存在</span></span><br><span class="line"><span class="keyword">ARG</span> MY_VAR=from_dockerfile</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>可见环境变量在构建过程中生效了，打印<code>[RUN] echo &quot;RUN MY_VAR is from_dockerfile</code>。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/0a9ed50597d6f6e35f426909a9f03b48.png" alt="image.png"></p><p>在docker build命令中可以覆盖dockerfile中设置的环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t myub --build-arg MY_VAR=from_docker_build</span><br></pre></td></tr></table></figure><p>可以观察到在build命令中设置的环境变量会覆盖dockerfile中的配置，打印的是<code>[RUN] echo &quot;RUN MY_VAR is from_docker_build</code>。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/19045a7063d5d2b04c2a2c3f76b95184.png" alt="image.png"></p><p>另外，ARG设置的时候，环境变量之后是可以不带等于号的。此时相当于没有设置这个环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># arg设置的环境变量，在构建过程中才会存在</span></span><br><span class="line"><span class="keyword">ARG</span> MY_VAR</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>直接使用<code>docker build . -t myob</code>进行构建，打印的内容是<code>RUN echo &quot;MY_VAR is $&#123;MY_VAR&#125;&quot;</code>这个原始值，因为此时MY_VAR环境变量等于没有设置。必须通过build命令传值才会设置MY_VAR环境变量。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/d456a37f4282fb622a60249fb4641a12.png" alt="image.png"></p><h2 id="2-11-VOLUME"><a href="#2-11-VOLUME" class="headerlink" title="2.11. VOLUME"></a>2.11. VOLUME</h2><p>在docker volume的解析中已经说明了数据卷的重要性。只要你的容器运行过程中，有需要持久化保存的重要数据，则都建议使用VOLUME在dockerfile中标出。这样即便用户没有主动绑定指定路径的数据卷，docker也会自动创建匿名数据卷来保存这里面的数据，不至于出现数据丢失问题。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec格式</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br><span class="line"><span class="comment"># shell格式，等价于[&quot;/data1&quot;,&quot;/data2&quot;]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data1 /data2</span></span><br></pre></td></tr></table></figure><p>下面是官网上给出的一些说明。比如在json格式中，必须用双引号括起来目录名，不能使用单引号；volume的挂载是基于宿主机的，所以不能在dockerfile中指定最终挂载的host-dir，必须用户手动使用docker run命令来指定，或者由docker自行创建volume数据卷。</p><blockquote><p>Keep the following things in mind about volumes in the Dockerfile.</p><p>Volumes on Windows-based containers: When using Windows-based containers, the destination of a volume inside the container must be one of:</p><ul><li>a non-existing or empty directory</li><li>a drive other than <code>C:</code></li></ul><p>Changing the volume from within the Dockerfile: If any build steps change the data within the volume after it has been declared, those changes will be discarded.</p><p>JSON formatting: The list is parsed as a JSON array. You must enclose words with double quotes <code>(&quot;)</code> rather than single quotes <code>(&#39;)</code>.</p><p>The host directory is declared at container run-time: The host directory (the mountpoint) is, by its nature, host-dependent. This is to preserve image portability, since a given host directory can’t be guaranteed to be available on all hosts. For this reason, you can’t mount a host directory from within the Dockerfile. The VOLUME instruction does not support specifying a host-dir parameter. You must specify the mountpoint when you create or run the container.</p></blockquote><h2 id="2-12-EXPOSE"><a href="#2-12-EXPOSE" class="headerlink" title="2.12. EXPOSE"></a>2.12. EXPOSE</h2><p>指定容器需要对外提供服务的端口。比如nginx的80和443端口。且可以在dockerfile中设置默认绑定的端口值。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure><p>当一个EXPOSE的端口没有被用户设置，也没有默认值时，docker会自动绑定一个未被使用的端口给他。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴露3000端口给外部（默认是tcp）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="comment"># 暴露6000端口给外部，并设置默认绑定宿主机的60000端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6000</span> <span class="number">60000</span>/tcp</span><br><span class="line"><span class="comment"># 暴露10000的udp端口给外部，并设置默认绑定宿主机的12000端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10000</span>/udp <span class="number">12000</span>/udp</span><br></pre></td></tr></table></figure><p>注意，这里的默认绑定端口设置，只有在bridge模式创建容器的时候才会生效。如果用户使用host模式，那么就会采用<strong>原有端口</strong>（比如暴露6000端口，使用host模式就会直接绑定宿主机的6000端口，和默认值无关）绑定在宿主机上。</p><p>在host模式中，容器可以绑定宿主机的任意未使用端口，即便这些端口没有在EXPOSE中被设置。所以，如果你不想容器中的网络进程影响宿主机上的有效端口数量，则建议使用bridge模式来增强隔离性。</p><p>不管EXPOSE是如何设置的，在docker run中都可以被覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80/tcp -p 80:80/udp ...</span><br></pre></td></tr></table></figure><p>另外，EXPOSE只是代表容器“想要”使用这些端口，最终端口的bind操作是由容器内的进程来处理的。当然，使用bridge选项时，docker引擎会帮容器先确认宿主机的端口可用并占用，再由容器内的进程bind容器内的端口，对外提供服务。</p><h2 id="2-13-ONBUILD"><a href="#2-13-ONBUILD" class="headerlink" title="2.13. ONBUILD"></a>2.13. ONBUILD</h2><p>ONBUILD指定的dockerfile语句会在尝试基于当前镜像构建镜像的时候被启用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> &lt;INSTRUCTION&gt;</span><br></pre></td></tr></table></figure><p>来测试一下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;running build&quot;</span></span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;on build&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，构建的时候，只有不带<code>ONBUILD</code>选项的命令才被执行了，而带了ONBUILD的<code>echo &quot;on build&quot;</code>命令没有被执行。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/769e9b38abe47a9d1a772a4775bbda6e.png" alt="image.png"></p><p>我们基于这个构建出来的镜像，再写一个dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> myub:latest </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;running build from myub&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，构建过程会先执行父镜像ONBUILD设置的命令，再执行自己dockerfile中的命令，先打印的是<code>echo &quot;on build&quot;</code>，然后才打印<code>echo &quot;running build from myub&quot;</code>。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/182ae6b6d386df0988ab3883ab8b9be6.png" alt="image.png"></p><h2 id="2-14-STOPSIGNAL"><a href="#2-14-STOPSIGNAL" class="headerlink" title="2.14. STOPSIGNAL"></a>2.14. STOPSIGNAL</h2><p>STOPSIGNAL设置docker内<strong>运行的进程</strong>在收到什么信号的时候会终止，即docker stop某个容器时，docker会给容器内进程发送的信号。</p><p>这里的signal可以是信号的名称（如<code>SIGKILL</code>）也可以是信号的编号。默认值是<code>SIGTERM</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure><p>关于信号的编号和名称，可以在linux下使用<code>kill -l</code>命令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>在docker run和docker create中可以使用<code>--stop-signal</code>选项覆盖dockerfile中的设置。</p><h2 id="2-15-HEALTHCHECK"><a href="#2-15-HEALTHCHECK" class="headerlink" title="2.15. HEALTHCHECK"></a>2.15. HEALTHCHECK</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/#healthcheck">https://docs.docker.com/reference/dockerfile/#healthcheck</a></p><p>用于检查容器的健康状态，如果检查失败（可以设置重试次数），则会将容器标记为<strong>不健康</strong>。这可以方便集群化管理，特别是解决某些容器内服务器进程虽然仍在运行，但因为某些原因已经无法提供服务的情况。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础语法</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> [OPTIONS] CMD <span class="built_in">command</span></span></span><br><span class="line"><span class="comment"># 禁用健康检查，包括从父镜像继承下来的检查</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> NONE</span></span><br></pre></td></tr></table></figure><p>下面是一个示例，docker会每5分钟使用curl检查一下<code>http://localhost:8080/</code>是否可以被访问，如果超过3秒还没有反应，则认为它不能被访问。</p><p>当curl返回的状态码不是2xx&#x2F;3xx的时候，则exit 1表示不成功。告知HEALTHCHECK认为容器不健康。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5m --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost:8080/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>一次检查可能不太好，我们可以设置重试次数（<strong>默认会重试3次</strong>），下面就使用retries指定了重试两次</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5m --<span class="built_in">timeout</span>=3s --retries=2 \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost:8080/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><h2 id="2-16-USER"><a href="#2-16-USER" class="headerlink" title="2.16. USER"></a>2.16. USER</h2><p>指定用于执行构建命令和最终执行CMD&#x2F;ENTRYPOINT命令使用的用户&#x2F;用户组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;]</span><br><span class="line"><span class="keyword">USER</span> UID[:GID]</span><br></pre></td></tr></table></figure><blockquote><p>Note that when specifying a group for the user, the user will have only the specified group membership. Any other configured group memberships will be ignored.</p></blockquote><h1 id="3-验证dockerfile命令对镜像层数的影响"><a href="#3-验证dockerfile命令对镜像层数的影响" class="headerlink" title="3. 验证dockerfile命令对镜像层数的影响"></a>3. 验证dockerfile命令对镜像层数的影响</h1><p>前文提到，dockerfile中的一条命令就是一层，如果冗余的命令过多，会让构建出来的dockerfile层级过多。下面通过一个例子来实际验证一下。</p><blockquote><p>参考 <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/981453">Docker 进阶之镜像分层详解</a></p></blockquote><h2 id="3-1-查看基础镜像的层级"><a href="#3-1-查看基础镜像的层级" class="headerlink" title="3.1. 查看基础镜像的层级"></a>3.1. 查看基础镜像的层级</h2><p>测试基于<code>ubuntu:22.04</code>的镜像，首先使用<code>docker inspect</code>命令查看这个镜像的所有层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect ubuntu:22.04</span><br></pre></td></tr></table></figure><p>得到的结果如下，其中<code>RootFS/Layers</code>是这个镜像的所有层级。可见ubuntu的镜像只有一层。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:52882761a72a60649edff9a2478835325d084fb640ea32a975e29e12a012025f&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RepoTags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;ubuntu:22.04&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RepoDigests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;ubuntu@sha256:a6d2b38300ce017add71440577d5b0a90460d0e57fd7aec21dd0d1b0761bbfb2&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Comment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-04-27T13:18:37.512234142Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;DockerVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24.0.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Domainname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AttachStdin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AttachStdout&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AttachStderr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Tty&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OpenStdin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;StdinOnce&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:2252dc08ad59a3723b856050e7848a7fe152b469dd24cf30b0a910b7c615766c&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;WorkingDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Entrypoint&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OnBuild&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.ref.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22.04&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Size&quot;</span><span class="punctuation">:</span> <span class="number">77863352</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;GraphDriver&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;MergedDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/overlay2/fbc6cfc7d29a6660ebf2a172548649ec0ce6a2578f369a2076b13f6f8a1b375c/merged&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;UpperDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/overlay2/fbc6cfc7d29a6660ebf2a172548649ec0ce6a2578f369a2076b13f6f8a1b375c/diff&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;WorkDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/overlay2/fbc6cfc7d29a6660ebf2a172548649ec0ce6a2578f369a2076b13f6f8a1b375c/work&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:629ca62fb7c791374ce57626d6b8b62c76378be091a0daf1a60d32700b49add7&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;LastTagTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>通过docker history命令可以查看这个镜像的构建过程，虽然这里显示了多行，但实际上有效的行只有ADD了ubuntu的系统二进制文件的那一行，其他行都是对这个镜像的基础设置和元数据设置，并没有给镜像实际添加文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker history  ubuntu:22.04</span><br><span class="line">IMAGE          CREATED      CREATED BY                                      SIZE      COMMENT</span><br><span class="line">52882761a72a   9 days ago   /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop) ADD file:a5d32dc2ab15ff0d7…   77.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  ARG RELEASE                  0B  </span><br></pre></td></tr></table></figure><h2 id="3-2-构建两个镜像"><a href="#3-2-构建两个镜像" class="headerlink" title="3.2. 构建两个镜像"></a>3.2. 构建两个镜像</h2><p>下面用两个dockerfile来基于ubuntu构建两个新的镜像。两个dockerfile执行的内容都是一致的，只不过第一个dockerfile中将命令都合并了，第二个dockerfile将命令拆分了。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:1</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新和安装软件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	apt-get -y upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	apt-get install -y \</span></span><br><span class="line"><span class="language-bash">	cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">	net-tools \</span></span><br><span class="line"><span class="language-bash">	openssh-server \</span></span><br><span class="line"><span class="language-bash">	build-essential \</span></span><br><span class="line"><span class="language-bash">	python3</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/63b064c75ef93cd63201a46033c02e5b.png" alt="image.png"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:2</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">	cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">	net-tools openssh-server</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential </span></span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/27c2753f592acd2b16e90f50c406c38d.png" alt="image.png"></p><h2 id="3-3-查看构建的两个镜像包含的层级"><a href="#3-3-查看构建的两个镜像包含的层级" class="headerlink" title="3.3. 查看构建的两个镜像包含的层级"></a>3.3. 查看构建的两个镜像包含的层级</h2><p>分别用<code>docker history</code>查看这两个镜像的层级，根据刚刚<code>docker build</code>命令的输出，以2b9f开头的是第一个镜像（命令都写一起了），以8156开头的是命令被拆分了的docker镜像。</p><p>这里能看到第一个现象，虽然两个镜像一个是被拆分的RUN构建出来的，另外一个并没有被拆分，但最终构建出来的镜像大小并没有明显的区别（其实只是本次测试的情况没有区别，其他情况下，一般合并命令构建出来的镜像会更小）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">&lt;none&gt;       &lt;none&gt;    8156b17c21a3   2 minutes ago   598MB</span><br><span class="line">&lt;none&gt;       &lt;none&gt;    2b9f30d55cc3   9 minutes ago   596MB</span><br><span class="line">ubuntu       22.04     52882761a72a   9 days ago      77.9MB</span><br></pre></td></tr></table></figure><p>先给这两个镜像打个tag（最好是docker build的时候就用<code>-t</code>选项打tag，我忘记了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag 2b9f30d55cc3 myub:1</span><br><span class="line">docker tag 8156b17c21a3 myub:2</span><br></pre></td></tr></table></figure><p>先来看命令合并的这个，可见它只在原有镜像的基础上，多了RUN命令的这一层。ARG&#x2F;ENV命令虽然会在history中被显示，但并不会增加层级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker history myub:1</span><br><span class="line">IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT</span><br><span class="line">2b9f30d55cc3   10 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   518MB     buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      10 minutes ago   ENV TZ=Asia/Shanghai                            0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      10 minutes ago   ARG DEBIAN_FRONTEND=noninteractive              0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop) ADD file:a5d32dc2ab15ff0d7…   77.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  ARG RELEASE                  0B    </span><br></pre></td></tr></table></figure><p>通过docker inspect查看详细信息，在Layers中只能看到两层，即对应一条RUN命令创建出来的镜像层。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:629ca62fb7c791374ce57626d6b8b62c76378be091a0daf1a60d32700b49add7&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:2a381621675d1e9a462aa951211a3cf6938a480fcd82796cb18ef85234696014&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再来看看命令被拆分的镜像，层数就多了起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker history myub:2</span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">8156b17c21a3   8 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   10.5kB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      8 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   56.1MB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      8 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   413MB     buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   50.9MB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   ENV TZ=Asia/Shanghai                            0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   ARG DEBIAN_FRONTEND=noninteractive              0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop) ADD file:a5d32dc2ab15ff0d7…   77.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  ARG RELEASE                  0B  </span><br></pre></td></tr></table></figure><p><code>myub:2</code>相比<code>myub:1</code>额外多了4层，也对应的RUN命令的个数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:629ca62fb7c791374ce57626d6b8b62c76378be091a0daf1a60d32700b49add7&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:2ae784f0abd479326b00d2fbe2ba96a16e46056e386275d6f57988fe2ecf3034&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:fa903b82d02c9769bc58b795b9c1789a45dca63be57e81c7e15df3de2618bda0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:3c2f1f7362025cbbb03b9a5760fc7fd72e940b1b768002ec6e15bc677e2657e4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:86d0ee2ab97d64cee7d15598f4374bfe1ff940d89d945bbaf66e947e20068a1e&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:e72805c5ca21af8edf5f6d539da83e62c083436b1a58d00a394b2bf0b6be4a87&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-分层的影响？"><a href="#3-4-分层的影响？" class="headerlink" title="3.4. 分层的影响？"></a>3.4. 分层的影响？</h2><p>先说结论：根据你的业务需要，选择合适的层数来构建docker镜像。</p><p>docker分层其中之一的目的，就是让构建镜像的时候能更多的<strong>用上缓存</strong>。假设构建容器A和容器B中有相同的操作，<strong>会构建出一个相同的镜像层</strong>，那么这个镜像层<strong>只需要存储一次就行了</strong>，而且下次执行相同的构建操作时，也可以直接使用这个缓存！容器运行的时候，这些镜像的<strong>只读层</strong>同样可以共享，节省了占用的空间。</p><p>所以，<strong>适当</strong>的加多RUN的层数，<strong>且将相同的构建命令放在同一个RUN中</strong>，是可以方便多个容器的构建的。因为单层RUN的缓存能被下一次相同的构建直接用上，构建效率提高！</p><p>同理，在pull拉取远程镜像的时候，如果某一层在本地已有了，也能直接使用本地已有缓存，避免重复拉取。这就好比APP的“增量更新”功能，镜像那么大，如果每一次都得全量下载，网络不好的时候就有的一等了。只拉取有变化的层数，能大大提高效率。</p><p>但是，如果层数太多，新增了太多的小层，那么每一个小层的变化都会使<strong>后续构建的缓存失效</strong>！具体场景也需要具体的考量！</p><h2 id="3-5-分层缓存测试"><a href="#3-5-分层缓存测试" class="headerlink" title="3.5. 分层缓存测试"></a>3.5. 分层缓存测试</h2><h3 id="3-5-1-拉取镜像缓存命中"><a href="#3-5-1-拉取镜像缓存命中" class="headerlink" title="3.5.1. 拉取镜像缓存命中"></a>3.5.1. 拉取镜像缓存命中</h3><p>当我们pull一个redis的6.2版本时，因为之前没有pull过，需要全量下载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull redis:6.2                 </span><br><span class="line">6.2: Pulling from library/redis</span><br><span class="line">b0a0cf830b12: Pull complete </span><br><span class="line">57ad18570194: Pull complete </span><br><span class="line">056356a7a403: Pull complete </span><br><span class="line">c3351a5ba2a8: Pull complete </span><br><span class="line">1042efef0b42: Pull complete </span><br><span class="line">9f26115a8134: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">68d2d706a2f6: Pull complete </span><br><span class="line">Digest: sha256:d4948d011cc38e94f0aafb8f9a60309bd93034e07d10e0767af534512cf012a9</span><br><span class="line">Status: Downloaded newer image for redis:6.2</span><br><span class="line">docker.io/library/redis:6.2</span><br></pre></td></tr></table></figure><p>但当我们pull一个redis的7.0版本时，就不需要全量下载了，因为有一层和6.2版本是一致的，会显示<code>Already exists</code>，使用了本地缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull redis:7.0</span><br><span class="line">7.0: Pulling from library/redis</span><br><span class="line">b0a0cf830b12: Already exists </span><br><span class="line">ea9699b63e68: Pull complete </span><br><span class="line">bf380b81aa96: Pull complete </span><br><span class="line">0164b64ea927: Pull complete </span><br><span class="line">e06189a3bd9d: Pull complete </span><br><span class="line">81fd2c0406f8: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">e3a29842ec15: Pull complete </span><br><span class="line">Digest: sha256:084f7275d9a3abc11d9f8905c3377e61e1464880af941b1eb68b8605863000e4</span><br><span class="line">Status: Downloaded newer image for redis:7.0</span><br><span class="line">docker.io/library/redis:7.0</span><br></pre></td></tr></table></figure><h3 id="3-5-2-构建缓存命中"><a href="#3-5-2-构建缓存命中" class="headerlink" title="3.5.2. 构建缓存命中"></a>3.5.2. 构建缓存命中</h3><p>先来看看构建缓存给命中的例子，来个dockerfile3，这里我们前几个命令都和上文构建<code>myub:2</code>使用的命令相同，但是最终安装的软件不同。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:3</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">	python3 vim git cmake net-tools sqlite3</span></span><br></pre></td></tr></table></figure><p>在build的输出中可以看到，前两层<code>apt-get -y update</code>和<code>apt-get -y upgrade</code>直接命中了本地已有的缓存，会有一个<code>CACHED</code>的输出，代表此时无需再次构建！</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/89162d9895887d381a368e97f7926add.png" alt="image.png"></p><p>不过，<code>apt-get update/upgrade</code>这两个命令的结果是会随着ubuntu系统软件源的更新而进一步变化的。如果想获取最新的软件源，在docker build的时候，可以选择不使用本地的docker缓存，来构建最新的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache . -t imageName </span><br></pre></td></tr></table></figure><h3 id="3-5-3-构建缓存失效"><a href="#3-5-3-构建缓存失效" class="headerlink" title="3.5.3. 构建缓存失效"></a>3.5.3. 构建缓存失效</h3><p>再来看看什么时候缓存会失效。首先，如果将这里的<code>apt-get</code>命令合并，那么就无法使用本地的缓存了，还是需要重新拉取ubuntu的软件源，执行构建过程。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:4</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	apt-get -y upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	apt-get install -y \</span></span><br><span class="line"><span class="language-bash">	python3 vim git cmake net-tools sqlite3</span></span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/46f8a4287cf5627aa18fc67b179728df.png" alt="image.png"></p><p>而在原本构建<code>myub:2</code>的过程中，我们有很多的小层，这些小层的变化，同样会让这一层和下层的缓存都失效</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:5</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具（这个小层和myub:2不同，多安装了sqlite3）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">	cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">	net-tools openssh-server sqlite3</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential </span></span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3</span></span><br></pre></td></tr></table></figure><p>可以看到，因为RUN命令中多安装了sqlite3，不光这一层需要重新构建，后面没有变动的两层同样需要重新构建，大大增加了构建耗时。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9243f568cf729a28fd1ae4f6f8f8c4f7.png" alt="image.png"></p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/95c6449bd4943ace8de5a4ea2f53a5e4.png" alt="image.png"></p><p>如果我们想新增一个sqlite3包，直接在最后添加一个新的命令，反而可以用上原本的缓存，飞速构建</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:6</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">	cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">	net-tools openssh-server</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential </span></span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3</span></span><br><span class="line"><span class="comment"># 额外安装sqlite3</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y sqlite3</span></span><br></pre></td></tr></table></figure><p>反应到结果上，就是前几层直接命中缓存，只有最后一个安装sqlite3的命令需要进行运行构建。</p><p><img src="/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/a40126981c119fc06da0912fc904fd6a.png" alt="image.png"></p><h1 id="4-如何减少docker构建镜像的大小？"><a href="#4-如何减少docker构建镜像的大小？" class="headerlink" title="4.如何减少docker构建镜像的大小？"></a>4.如何减少docker构建镜像的大小？</h1><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39213171/article/details/107789804">Dockerfile最小化构建镜像：减少层数、清理无用数据、多段构建</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.musnow.top">慕雪年华</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.musnow.top/posts/188682082/">https://blog.musnow.top/posts/188682082/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.musnow.top" target="_blank">慕雪的寒舍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="https://img.musnow.top/i/2024/07/919bea31fa7c37892d94c569cf17382b.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://afdian.net/a/128ahri" target="_blank"><img class="post-qr-code-img" src="/img/ico/aifadian.png" alt="爱发电"></a><div class="post-qr-code-desc">爱发电</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/430272532/" title="【Git】如何在已经提交内容中删除某个目录或文件"><img class="cover" src="/img/bg/gm10.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Git】如何在已经提交内容中删除某个目录或文件</div></div></a></div><div class="next-post pull-right"><a href="/posts/2851039659/" title="【Docker】Docker学习03 | Docker的volume"><img class="cover" src="https://img.musnow.top/i/2024/07/fdc07e592ab6ecbbe91ffcbdc1db123f.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Docker】Docker学习03 | Docker的volume</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2069190154/" title="【Docker】deepin&#x2F;ubuntu&#x2F;centos安装docker"><img class="cover" src="https://img.musnow.top/i/2023/05/64755fd9d41a8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-07</div><div class="title">【Docker】deepin&#x2F;ubuntu&#x2F;centos安装docker</div></div></a></div><div><a href="/posts/3908173775/" title="【Artalk】在wiki js站点上使用Artalk评论系统"><img class="cover" src="/img/bg/gm14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-05</div><div class="title">【Artalk】在wiki js站点上使用Artalk评论系统</div></div></a></div><div><a href="/posts/370869610/" title="【Docker】配置lsky pro兰空图床"><img class="cover" src="/img/bg/gm10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-28</div><div class="title">【Docker】配置lsky pro兰空图床</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="artalk-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">慕雪年华</div><div class="author-info__description">爱折腾的代码初学者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">407</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/musnows"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:muxue@musnow.top" target="_blank" title="email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/musnows" target="_blank" title="Gitee"><i class="fa-sharp fa-solid fa-g"></i></a><a class="social-icon" href="https://blog.csdn.net/muxuen" target="_blank" title="CSDN"><i class="fa-brands fa-blogger-b"></i></a><a class="social-icon" href="https://musnow.top/?utm_source=blog" target="_blank" title="个人主页"><i class="fas fa-globe-asia"></i></a><a class="social-icon" href="https://web.musnow.top/?utm_source=blog" target="_blank" title="导航站点"><i class="fas fa-server"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到寒舍</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-dockerfile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">1. dockerfile基本语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-dockerfile%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">2. dockerfile语法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-FROM"><span class="toc-text">2.1. FROM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-RUN"><span class="toc-text">2.2. RUN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-MAINTAINER%E5%92%8CLABEL"><span class="toc-text">2.3. MAINTAINER和LABEL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-SHELL"><span class="toc-text">2.4. SHELL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-WORKDIR"><span class="toc-text">2.5. WORKDIR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-COPY"><span class="toc-text">2.6. COPY</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E"><span class="toc-text">2.6.1. 选项说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-1-%E2%80%93from"><span class="toc-text">2.6.1.1. –from</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-2-%E2%80%93chown-%E2%80%93chmod"><span class="toc-text">2.6.1.2. –chown,–chmod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-3-%E2%80%93link"><span class="toc-text">2.6.1.3. –link</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-4-%E2%80%93parents"><span class="toc-text">2.6.1.4. –parents</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-5-%E2%80%93excule"><span class="toc-text">2.6.1.5. –excule</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-ADD"><span class="toc-text">2.7. ADD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E"><span class="toc-text">2.7.1. 选项说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-1-%E2%80%93keep-git-dir"><span class="toc-text">2.7.1.1. –keep-git-dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-2-%E2%80%93checksum"><span class="toc-text">2.7.1.2. –checksum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-3-%E5%89%A9%E4%BD%99%E9%80%89%E9%A1%B9"><span class="toc-text">2.7.1.3. 剩余选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-CMD"><span class="toc-text">2.8. CMD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-ENTRYPOINT"><span class="toc-text">2.9. ENTRYPOINT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-ARG%E5%92%8CENV"><span class="toc-text">2.10. ARG和ENV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.10.1. 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-2-ENV%E6%B5%8B%E8%AF%95"><span class="toc-text">2.10.2. ENV测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-3-ARG%E6%B5%8B%E8%AF%95"><span class="toc-text">2.10.3. ARG测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-VOLUME"><span class="toc-text">2.11. VOLUME</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-EXPOSE"><span class="toc-text">2.12. EXPOSE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-ONBUILD"><span class="toc-text">2.13. ONBUILD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-STOPSIGNAL"><span class="toc-text">2.14. STOPSIGNAL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-HEALTHCHECK"><span class="toc-text">2.15. HEALTHCHECK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16-USER"><span class="toc-text">2.16. USER</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81dockerfile%E5%91%BD%E4%BB%A4%E5%AF%B9%E9%95%9C%E5%83%8F%E5%B1%82%E6%95%B0%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">3. 验证dockerfile命令对镜像层数的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%9F%A5%E7%9C%8B%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-text">3.1. 查看基础镜像的层级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%9E%84%E5%BB%BA%E4%B8%A4%E4%B8%AA%E9%95%9C%E5%83%8F"><span class="toc-text">3.2. 构建两个镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%9F%A5%E7%9C%8B%E6%9E%84%E5%BB%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%95%9C%E5%83%8F%E5%8C%85%E5%90%AB%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-text">3.3. 查看构建的两个镜像包含的层级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%88%86%E5%B1%82%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">3.4. 分层的影响？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%88%86%E5%B1%82%E7%BC%93%E5%AD%98%E6%B5%8B%E8%AF%95"><span class="toc-text">3.5. 分层缓存测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD"><span class="toc-text">3.5.1. 拉取镜像缓存命中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD"><span class="toc-text">3.5.2. 构建缓存命中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88"><span class="toc-text">3.5.3. 构建缓存失效</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91docker%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-text">4.如何减少docker构建镜像的大小？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2798538265/" title="【C++】单元测试覆盖率工具lcov的使用（未完待续）">【C++】单元测试覆盖率工具lcov的使用（未完待续）</a><time datetime="2024-08-22T22:40:38.000Z" title="发表于 2024-08-23 06:40:38">2024-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1431516729/" title="【leetcode】44.通配符匹配">【leetcode】44.通配符匹配</a><time datetime="2024-08-18T07:22:47.000Z" title="发表于 2024-08-18 15:22:47">2024-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/266952207/" title="【leetcode】10.正则表达式匹配">【leetcode】10.正则表达式匹配</a><time datetime="2024-08-18T01:49:42.000Z" title="发表于 2024-08-18 09:49:42">2024-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1452956128/" title="【算法】单调栈">【算法】单调栈</a><time datetime="2024-08-14T22:40:27.000Z" title="发表于 2024-08-15 06:40:27">2024-08-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/main/mothra.webp)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 慕雪年华</div><div class="footer_custom_text"><img src="/img/ico/gonganbeian.png" height="15">&nbsp;<a href="https://beian.mps.gov.cn/#/query/webSearch?code=44190002007715" rel="noreferrer" target="_blank">粤公网安备44190002007715</a><br><a href="https://icp.gov.moe/?keyword=20230054" target="_blank"><img src="/img/badge/-%E8%90%8CICP%E5%A4%8720230054-ff69b4.svg" height="20px"></a>&nbsp<a href="/sitemap.xml" target="_blank"><img src="/img/badge/-SITEMAP-00CDCD.svg" height="20px"></a>&nbsp<a href="https://beian.miit.gov.cn/" target="_blank"><img src="/img/badge/%E7%B2%A4ICP%E5%A4%872023007189-red.svg" height="20px"></a><br><a href="https://www.foreverblog.cn/go.html" target="_blank"><img src="/img/ico/wormhole_1_tp.gif" height="25px"></a>&nbsp<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/ico/upyun_cdn_w.png" height="25px"></a>&nbsp<a href="https://www.travellings.cn/go.html" target="_blank"><img src="/img/ico/travelling_icon.gif" height="25px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.3/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadArtalk () {
  function initArtalk () {
    window.artalkItem = new Artalk(Object.assign({
      el: '#artalk-wrap',
      server: 'https://artk.musnow.top',
      site: 'mublog',
      pageKey: location.pathname,
      darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
      countEl: '.artalk-count'
    },null))

    if (GLOBAL_CONFIG.lightbox === 'null') return
    window.artalkItem.use(ctx => {
      ctx.on('list-loaded', () => {
        ctx.getCommentList().forEach(comment => {
          const $content = comment.getRender().$content
          btf.loadLightbox($content.querySelectorAll('img:not([atk-emoticon])'))
        })
      })
    })
  }

  if (typeof window.artalkItem === 'object') initArtalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.css').then(()=>{
      getScript('https://cdnjs.cloudflare.com/ajax/libs/artalk/2.5.5/Artalk.min.js').then(initArtalk)
    })
  }
}

function artalkChangeMode (theme) {
  const artalkWrap = document.getElementById('artalk-wrap')
  if (!(artalkWrap && artalkWrap.children.length)) return
  const isDark = theme === 'dark'
  window.artalkItem.setDarkMode(isDark)
}

btf.addModeChange('artalk', artalkChangeMode)

if ('Artalk' === 'Artalk' || !false) {
  if (false) btf.loadComment(document.getElementById('artalk-wrap'), loadArtalk)
  else loadArtalk()
} else {
  function loadOtherComment () {
    loadArtalk()
  }
}</script></div><script src="/js/domain_check.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.9.0/js/search/local-search.min.js"></script></div></div></body></html>