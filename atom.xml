<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2024-07-17T12:59:47.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【思源笔记】思源笔记配置S3同步</title>
    <link href="https://blog.musnow.top/posts/1277165852/"/>
    <id>https://blog.musnow.top/posts/1277165852/</id>
    <published>2024-07-16T12:41:44.000Z</published>
    <updated>2024-07-17T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h1><p><a href="https://b3log.org/siyuan/">思源笔记</a>是一款由国人开发的开源笔记软件，它是本地优先，支持双链、块级的笔记软件。思源笔记采用json作为数据存储格式，编辑器兼容MarkDown语法（编辑体验极佳，堪比Typora），最重要的是，<strong>自带同步功能</strong>。是我目前使用过的所有笔记软件中，感觉最适合个人多设备使用的笔记软件，既能简单的实现多设备同步，又能保证数据本地化，不受在线笔记产品会员资费、云服务宕机的困扰。</p><blockquote><p>你可以在官网找到下载页面，也可以去Github Release中下载：<a href="https://b3log.org/siyuan/download.html">https://b3log.org/siyuan/download.html</a></p></blockquote><p>思源笔记基础版本提供了几乎所有笔记相关的功能，会员版本分为永久买断功能特性和年付订阅，详见<a href="https://b3log.org/siyuan/pricing.html">价格页面</a>:</p><ul><li>永久买断：在所有基础功能的基础上，提供S3&#x2F;WEBDAV同步功能（需自行使用第三方服务）</li><li>年付订阅：在永久买断的基础上，提供官方的同步功能（8GB空间），且支持图床（可以将自己的图片上传至官方图床并在博客中引用）和剪藏、微信收集箱（通过微信公众号实时记录笔记并保存到思源笔记中）功能。</li><li>注意，若年付订阅者想使用S3&#x2F;WEBDAV同步功能，<strong>则需要保持按年付费</strong>，会员失效后无法使用S3&#x2F;WEBDAV功能，若想永久使用这两个功能，也需要购买永久买断的功能特性。</li></ul><p>如下图所示，<strong>付费版本和免费版本的区别只有同步功能是否可以使用</strong>，不会存在基础笔记共的限制。个人感觉目前64元买断的价格还是非常香的（之前早鸟付费是48元）。考虑到这里标了个原价96，建议对思源笔记感兴趣，且使用后觉得确实不错的老哥趁早购买功能特性，不排除后续可能会恢复原价96的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/bd7cf06a72bae304c8222f78bf126f94.png" alt="image.png"></p><p>另外，除非你不太想折腾S3同步（本文就是教你怎么做的），个人其实不太建议购买年付订阅。一是提供的同步空间有点小（社区里不少用户反馈认为8GB太少了，虽然对于我来说是够用）；二是S3的配置并不算麻烦，而官方提供的同步功能和S3同步基本没有体验差异。只要敢于尝试配置S3，完全可以剩下这笔钱。</p><p>不过这里有个小提醒，不管是功能特性还是年付订阅均<strong>不支持退款</strong>，付款前请三思。</p><h1 id="2-什么是思源笔记的S3-x2F-WEBDAV同步？"><a href="#2-什么是思源笔记的S3-x2F-WEBDAV同步？" class="headerlink" title="2. 什么是思源笔记的S3&#x2F;WEBDAV同步？"></a>2. 什么是思源笔记的S3&#x2F;WEBDAV同步？</h1><h2 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1. 说明"></a>2.1. 说明</h2><p>思源笔记本身是一个<strong>本地</strong>的笔记软件，提供了端到端加密的S3&#x2F;WEBDAV或官方提供的同步功能。当你安装思源笔记后，在默认的思源用户指南笔记本中，可以看到有一整个章节都是关于数据安全的描述：</p><ul><li>思源云端同步使用端到端加密，密码在本地通过内置密钥加密保存，除使用者之外的任何第三方均无法在云端获得明文数据。</li><li>加密和解密过程完全在本地设备上进行</li><li>加密算法为业界公认安全的 AES GCM；</li></ul><p>端到端加密同步功能，简单来说，就是思源笔记使用一个密钥，先在你的电脑上将需要同步的笔记内容加密成密文，然后发送给云端。当这些数据在网络中开始流动时，它们已经是加密后的内容了，<strong>对于不知道密钥的其他人来说，这一堆数据和乱码没有区别</strong>。而在你需要同步的另外一台设备中，它会下载云端的加密内容，数据在流入这台设备之前也是一堆乱码，只能在你的设备中，通过相同的密钥才能正确还原出最初的笔记内容。</p><p>端到端加密功能，意味着除非你自己知道你的数据库密钥，否则即便别人获取到了你存放在云端的全量同步数据，<strong>也无法解密内容</strong>。这样一来也完全避免了云端服务商可能存在的扫盘而带来的隐私担忧。与之对应的是，<strong>如果你忘记了你的数据库密钥</strong>，且没有进行其他备份的话，那么任何人都没有办法解密你的云端笔记数据了。</p><p>思源提供S3和WEBDAV这两个不同的云端存储服务协议进行同步。<strong>其中S3协议的可靠性和稳定性远远优于WEBDAV</strong>，除非特殊情况，否则百分百不推荐使用WEBDAV进行同步。</p><p>当你配置了S3&#x2F;WEBDAV同步之后，只需要在其他设备上使用相同的同步配置以及数据库密钥，即可以实现多设备的同步。思源提供了<strong>三种同步选项</strong>，分别是完全手动、半自动（客户端开启和关闭的时候会自动同步一次，其余时间手动同步）、自动同步（停止修改后30S自动同步一次）。</p><blockquote><p>这里推荐手机APP采用<strong>全手动</strong>模式，因为手机端界面按钮较小，极其容易误触导致意外修改一些内容，完全手动同步可以避免这些意外修改的内容被上传。电脑客户端根据您自己的需要选择半自动或全自动。另外，手机APP也可以在设置中配置为<strong>默认只读</strong>状态，这样可以避免修改笔记内容。</p></blockquote><p>但需要注意的是，思源的加密仅限于同步到云端的数据，你的<strong>笔记在设备本地是明文存储的</strong>。也就是说，如果你的设备丢失，那么任何人都可以<strong>在设备本地的硬盘中读取到你的笔记明文内容</strong>。除非你对笔记所在文件夹使用其他软件或系统功能进行了加密，比如微软的BitLocker。</p><p>作为一个本地优先的笔记软件，配置了同步后，即便没有网络，也丝毫不影响你浏览本地已有笔记内容（只不过会有一个无法同步的提示）。这一点对于我个人来说非常重要，我已经遇到过两次因为云端服务商产品协议更改或服务器访问波动导致我急需阅读笔记的时候无法阅读了。在那之后，我就把我所有的笔记内容全都转为纯本地了，包括笔记内的图片附件。</p><p>思源对大文本（超过4W字）的笔记支持也非常不错，毕竟是个本地笔记软件，性能基本取决于你的电脑配置。</p><blockquote><p>我曾使用过语雀存放我计算机网络的笔记（大约5.7W字），语雀会直接卡到完全不能动弹，整个页面都卡死了。即便我过几天再上去打开那个文档，也依旧是这样。不过flowus对这种大文本支持也还算不错，不会卡死。但是flowus的免费用户直接限制了200MB存储空间也太抠了，我一个计算机网络笔记里面的图片和附件就不止这么多了。</p></blockquote><p>咳咳，不跑题了，回到正文。</p><h2 id="2-2-思源的同步配置和工作空间"><a href="#2-2-思源的同步配置和工作空间" class="headerlink" title="2.2. 思源的同步配置和工作空间"></a>2.2. 思源的同步配置和工作空间</h2><blockquote><p>本文将以2024-07-17可下载到的最新思源版本<code>V3.1.1</code>做演示。</p></blockquote><p>思源笔记以<code>工作空间</code>为基础，独立进行各类主题、设置、密钥、同步配置。工作空间就是你的电脑上的一个文件夹，在这个工作空间中产生的各类笔记本和附件，都会被存放到这个工作空间的文件夹中。每个工作空间之间相互独立，没有任何关联，也需要进行独立的同步配置，和obisidian的vault是同一个概念。</p><p>为了避免出现同步错误，每个工作空间不可共用S3的bucket或同一个WEBDAV的同步路径。正确配置方式是每一个工作空间<strong>独立使用</strong>一个S3同步的bucket或者WEBDAV同步目录。</p><p>另外，因为思源笔记经常会实时进行本地文件的索引，所以不能将思源笔记的工作空间文件夹选择放在坚果云、OneDrive这类会进行实时同步的同步目录中，<strong>必须将思源的工作空间文件夹存放在一个和其他任何软件都没有任何关系的文件目录中</strong>。若想同步，请使用思源笔记自带的同步功能；若想备份，思源笔记的设置中有一个<code>导出-导出DATA</code>功能，这个功能会将整个工作空间的笔记和附件全量导出为一个压缩包，可以在另外一个设备上进行导入或上传至云盘进行备份。</p><p>在你初次打开思源笔记的界面下，也会有相关的提示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/92ce5419aa5e159e68dca2e1a39ca0be.png" alt="image.png"></p><p>选择工作空间文件夹的时候也会有提示，不能放在同步盘的路径中。如上文所述，在一个和其他任何软件都没有关系的独立文件夹中创建一个文件夹来存放思源笔记的工作空间，选中这个文件夹后，下方的弹窗点击确定就可以了。</p><p><strong>这只是个每次都会出现的提示</strong>，并不代表你当前选中的文件夹有这些第三方同步盘配置。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/7f858cb23ae59c2d46d4491f8fdabaca.png" alt="image.png"></p><h2 id="2-3-什么是S3协议？"><a href="#2-3-什么是S3协议？" class="headerlink" title="2.3. 什么是S3协议？"></a>2.3. 什么是S3协议？</h2><p>S3是一个对象存储的公共协议，目前国内主流的云服务厂商如阿里云、腾讯云、七牛云等等都会提供兼容S3协议的对象存储的服务。您可以选择任意一家您熟悉的支持对象存储的服务提供商来配置思源的S3同步，并不局限于本文举例的服务商。</p><p>如果您是第一次使用思源笔记，且没有接触过S3对象存储，个人推荐有免费额度的<strong>七牛云</strong>作为入门选择。我已经使用七牛云超过一年了，暂未遇到过收到影响的无法访问的情况，稳定性还是不错的。</p><p>几乎所有服务商的对象存储服务，都是分为两个计费项的：</p><ul><li>流量计费；</li><li>存储空间计费；</li></ul><p>存储空间计费比较好理解，就是为你存储空间占用的硬盘容量付钱。流量付费对于小白来说可能没有听说过，因为商用宽带是很贵的，所以云服务厂家为您提供服务时，需要收取带宽的流量费用。一般情况下来说，都是<strong>上传不计费，下载才计费</strong>。举个例子，您使用思源笔记，将本地的文件同步到S3时，使用的是<code>上传</code>宽带，这一部分是不计费的；而在另外一台设备上，将云端的内容同步到本地时，使用的是<code>下载</code>，这一部分就需要计费了。</p><p>如果您的设备不多，这部分由同步产生的下载流量费用是不高的。以我个人举例，我使用的思源笔记目前存储空间只有1GB，在七牛云产生的资费只有极低的外网流出流量的费用。</p><p>如下是2024年6月的账单，可以看到存储空间容量直接扣除了免费的额度，不用钱。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/e246955816ceef383e0dceb4f7c02a5c.png" alt="image.png"></p><p>外网流出流量2.68GB，扣费0.77元。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/58892f2e7d28d94f96bc41efa0ef47d7.png" alt="image.png"></p><p>PUT&#x2F;DELETE和GET请求都没有超过免费额度，都不用钱。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9b7bc32056f81b49039199e2b4d9743a.png" alt="image.png"></p><h1 id="3-配置思源S3同步"><a href="#3-配置思源S3同步" class="headerlink" title="3. 配置思源S3同步"></a>3. 配置思源S3同步</h1><h2 id="3-1-初始化数据仓库密钥"><a href="#3-1-初始化数据仓库密钥" class="headerlink" title="3.1. 初始化数据仓库密钥"></a>3.1. 初始化数据仓库密钥</h2><p>初次使用思源时，创建了一个工作空间后，要做的第一件事是在<code>设置-关于</code>中，初始化你的仓库密钥。思源会使用这个密钥进行端到端加密，密钥只有你当前使用的设备能知道。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/1003cc7ab75d392c3a727ceaf8b29f08.png" alt="image.png"></p><p>点击自动生成密钥，这里会提示您如果在其他设备上已经有工作空间时，应该选择导入密钥。而我们当前是新建的一个工作空间，需要初始化密钥，点击确定即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/3dd380d46081974cce118403a3e06d5d.png" alt="image.png"></p><p>密钥初始化完毕后，这里会显示复制密钥字符串，如果你需要在其他设备上同步这个工作空间的内容，可以在这里复制密钥，然后在另外一台设备上（比如手机app或者另外一台电脑）思源app设置的<code>设置-关于-数据仓库密钥</code>中，选择<strong>导入密钥</strong>。两台设备只有密钥一致，才能正确解密云端同步的数据。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/7521b39d5081c25ee529b5ccc488b8c9.png" alt="image.png"></p><h2 id="3-2-思源S3同步界面"><a href="#3-2-思源S3同步界面" class="headerlink" title="3.2. 思源S3同步界面"></a>3.2. 思源S3同步界面</h2><p>思源的S3同步界面是在<code>右上角按钮-设置-云端</code>里面的，在使用同步功能之前，需要先在<strong>账户</strong>一栏登录你的思源账户（用于验证是否购买了订阅）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/2df437c04fb0dc9213678ff62a421653.png" alt="image.png"></p><p>登录了之后，云端选项就会开放，在下拉菜单中选择S3即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/480859be7370f05529b8829c01904a60.png" alt="image.png"></p><p>你可以先记住这里的几个配置条目，后文会一一说明它们的对应内容。</p><h2 id="3-3-配置七牛云KODO"><a href="#3-3-配置七牛云KODO" class="headerlink" title="3.3. 配置七牛云KODO"></a>3.3. 配置七牛云KODO</h2><p>使用浏览器打开 <a href="https://www.qiniu.com/">七牛云</a> 官网， 注册账户。</p><p>七牛云的S3对象存储服务名为KODO，在它的<a href="https://www.qiniu.com/prices/kodo">定价页面</a>，你可以看到七牛云提供了每月10GB的免费存储空间和10GB的CDN回源流量额度。对于思源笔记的用途而言，CDN是用不上的，所以这个10G的CDN回源流量额度是用不到的。<strong>但10GB的存储空间额度可以用上了</strong>。至于后续的PUT&#x2F;DELETE还有GET的免费额度可以不用管，基本是用不完的。</p><p>这里也说明了上传流量是免费的，符合前文关于S3计费项目的介绍。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/284ac975a2928deb82469434bd5426c0.png" alt="image.png"></p><p>另外，在这个页面也有一个<a href="https://www.qiniu.com/prices/kodo?tab=calc">价格计算器</a>，你可以根据你的存储空间容量和设备数量来估计你最终会流出多少流量以及产生的资费。每个月的外网流出流量（也就是你的同步下载流量）平均到每月大概是在笔记本容量的1.5倍左右。注意：这只是个我根据个人情况<strong>猜测出来的大概比例</strong>，不代表实际情况，只用于预估价格。</p><p>如下图所示，假设你有10GB的笔记容量空间，那么外网流出流量一个月可能会需要15GB，那么每个月产生的资费是4.35元左右。这只是流出流量的费用，因为10GB的存储空间是免费的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9ca445e8b78103c7743e4aeeaae6d5a9.png" alt="image.png"></p><p>现在你已经了解定价啦，来看看怎么配置七牛云的S3同步吧。登录七牛云后，点击右上角账户旁边的控制台按钮，进入后台，点击产品与方案，选择对象存储kodo。你可以在这里选择将其钉住，这样会直接显示在侧边栏上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/0706e3ee43433f31fa2789e222f35a35.png" alt="image.png"></p><p>在对象存储栏目中，点击空间管理，点击新建空间，这会创建一个bucket，也对应的思源S3同步中bucket一栏的填写项。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/b9463c8ecd8c05327a5155b9145cc241.png" alt="image.png"></p><p>bucket的名字根据你的喜好填写，<strong>建议填写辨识度高的名字</strong>，而不要填写一个诸如siyuan这类没有什么辨识度的名字。辨识度高的名字方便你后续创建更多bucket来对应其他思源工作空间或其他软件。</p><p>地域的选择采取就近原则，除非你人在国外，否则请不要选择非大陆地域。</p><p>访问控制选择<strong>私有</strong>，这代表只有拥有你的七牛云账户和相关密钥的软件可以访问这个bucket，其他任何人都没有办法直接访问这个bucket。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/384a403c846ce69b5d0437b53008dbe2.png" alt="image.png"></p><p>点击确定后，会弹出如下的提示。这里是很多新手朋友不太理解的一点，什么是测试域名？为什么有效期只有30天？实际上，这个域名是用于<strong>公开bucket</strong>的访问的，刚刚我们创建bucket的时候已经选择了私有，<strong>这个域名对于思源同步来说没有任何用处</strong>，也就不用管他的30天过期说明！直接点击<code>好的,我知道了</code>忽略这个提示即可！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/ea73be35361f1647eb68fa5b810e2258.png" alt="image.png"></p><p>现在我们已经创建了一个新的bucket，点击它的名字，即可进入bucket的管理页面</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/ca825415de2154c81ad5fc4e82c60b8d.png" alt="image.png"></p><p>在bucket的空间概览中，可以看到当前bucket的存储空间占用量，以及外网流出流量统计。我们需要记录的是右下角的这个存储空间域名。这个存储空间域名的格式如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http(s)://siyuan-bucket-1.s3.cn-east-1.qiniucs.com</span><br><span class="line">http(s)://&lt;bucket名字&gt;.s3.cn-east-1.qiniucs.com</span><br><span class="line">http(s)://&lt;bucket名字&gt;.&lt;协议&gt;.cn-east-1.qiniucs.com</span><br><span class="line">http(s)://&lt;bucket名字&gt;.&lt;协议&gt;.&lt;区域名字&gt;.qiniucs.com</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/f8bf7b43794bb2c22fd9a51f7988c20a.png" alt="image.png"></p><p>回到思源的配置中，现在可以填写一部分内容了</p><ul><li>Bucket：对应刚刚你创建的存储空间的名字，在我的示例中，是<code>siyuan-bucket-1</code>;</li><li>Endpoint：填写域名中除了bucket名字以外的部分，即<code>https://s3.cn-east-1.qiniucs.com</code>；</li><li>Region：填写域名中显示的区域名字，即<code>cn-east-1</code>；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/d6d18a4d349bb3384f256082620f76b3.png" alt="image.png"></p><p>还剩下两个内容分别是Access Key和Secret Key，正如它们的名字翻译过来的结果，这两个是访问你这个bucket的用户密钥，也是你的七牛云账户的密钥。这是你的<strong>私密信息</strong>，请一定<strong>不要将用户密钥发送给任何人或发送到论坛上</strong>！</p><p>这两个密钥的获取位置是在七牛云界面的右上角，鼠标移动到你的用户头像位置，会弹出一个选择框，点击里面的密钥管理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/4ab349939ae1115bf41ecc1c2c60f8c6.png" alt="image.png"></p><p>这里我已经创建过两组密钥了，我不记得新用户进到这个界面时是否会有一个创建密钥的提示了。总之你可以创建一组密钥，然后分别复制这里的<strong>AK和SK</strong>，填写到思源笔记的Access Key和Secret Key中，同步配置就完成了！</p><blockquote><p>如果你认为你的七牛云密钥已经泄漏，可以选择停用密钥，停用后删除这个密钥，再重新创建一个新密钥即可。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/723f04ab1bc1f51300e4bf2dfe07706d.png" alt="image.png"></p><p>填写完毕后，点击下方的启用云端同步</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9082891d4b4817ef75a96e99354c2c09.png" alt="image.png"></p><p>在同步方式中，可以选择前文提到过的三种不同方式。对于电脑客户端而言，选择自动同步或者手动同步都是可以的；而对于手机APP而言，强烈推荐选择完全手动同步。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/731b4f2549605e64575e9e63bc1e68ad.png" alt="image.png"></p><p>这里又会出现另外一个会让小白感到困扰的设置，在云端同步目录的设置中，你会发现你的七牛云账户里面的所有bucket都会显示出来。但是！刚刚在S3的同步配置中有一个Bucket填写项，我们使用的Bucket已经在填写项目中被<strong>固定</strong>了，所以这里的bucket选项是毫无意义的！<strong>它是留给WEBDAV协议选择文件路径使用的</strong>！使用了S3协议后，请忽略这个<code>云端同步目录</code>配置项。</p><p>正如前文提到过的，请针对<strong>每一个工作空间配置一个对应的Bucket</strong>，请不要多个工作空间公用同一个bucket！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/846620eca1ae0a2485b07f2df3d45a2f.png" alt="image.png"></p><p>现在我创建了一个测试笔记本，点击左上角的这个<strong>小云图标</strong>，即可进行同步操作。</p><blockquote><p>顺带提一嘴，你可能会在文档树中看到<code>思源用户指南</code>这个笔记本，请不要在这个笔记中记录任何笔记！每次启动思源的时候，<strong>这个笔记本都会被重置</strong>！他是一个说明书，并不是一个可用的笔记本。一定要在文档树中<code>右键-新建笔记本</code>来做你的记录！</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/2e07bd704af10290cb5ef8449fb28b5c.png" alt="image.png"></p><p>同步时，左下角会显示实时进度。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/70b0e714f197963591e412662e5a966d.png" alt="image.png"></p><p>同步完毕后，我们可以来到七牛云的bucket的文件管理中，查看是否有新增的数据。如下图所示，刚刚我新建的bucket中已经出现了一个repo文件夹，且内部已有文件，这就代表你的同步配置完成啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/92474957afc3dfd8203b51a2336ebd5d.png" alt="image.png"></p><p>这里的repo文件和本地工作空间路径中的repo文件夹内容是一致的，都是使用数据库密钥加密后的笔记内容。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/f47a493cc9fdd4cab4084f24c307ef69.png" alt="image.png"></p><h2 id="3-4-如何将同步配置导入其他设备？"><a href="#3-4-如何将同步配置导入其他设备？" class="headerlink" title="3.4. 如何将同步配置导入其他设备？"></a>3.4. 如何将同步配置导入其他设备？</h2><p>注意：<strong>两台设备请保证思源的版本一致，数据仓库密钥一致，再进行同步</strong>。个人建议关闭思源客户端的自动更新功能，只要你使用当前版本没有遇到任何问题，建议维持版本，不进行更新。我现在还在使用v2.11.4老版本呢。</p><p>在设置-云端中，会有一个导入和导出的按钮，在这里可以快捷的导出你的云端配置，并在其他设备的云端设置中进行导入。</p><blockquote><p>请注意区分 云端的导入&#x2F;导出 和 设置中的导出 选项，<code>设置-导出-导出DATA</code>是将你的全量笔记数据导出为一个压缩包，方便在其他设备上直接导入笔记或备份笔记。而<code>设置-云端-导出</code>则只是导出你的云端配置项目，方便在其他设备上直接引用相同的云端配置项而不需要重新填写而已！</p></blockquote><p>注意：导出的压缩包是明文存储的，你的AccessKey和SecretKey都是明文。<strong>请在导入其他设备后，尽快删除压缩包</strong>，避免AccessKey和SecretKey泄漏！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/697b546ceaecff9365b3b46bce82d4d8.png" alt="image.png"></p><p>在其他设备导入云端配置后，启用云端同步，将同步选项改为<code>完全手动同步</code>，并手动点击小云图标，选择下载数据。等待云端的数据被下载完毕之后，再修改为其他同步方式。这样能最大限度的保障同步数据不出错！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/cc7ca5c616e1c0670d32a9ea35141f3b.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/72a6d2b5d430eb96520a5750e2e4803a.png" alt="image.png"></p><p>另外，如果你尝试用QQ或微信的文件传输助手将这个云端同步压缩包发送给手机，需要注意的是QQ的文件传输助手收到的压缩包文件，完全没有办法在手机的文件管理器中被找到，也就没有办法导入思源APP中。<strong>建议使用数据线连接手机和电脑，将导出的云端同步配置压缩包传输到手机上</strong>。</p><h1 id="4-The-end"><a href="#4-The-end" class="headerlink" title="4. The end"></a>4. The end</h1><p>到这里，云端的配置就大功告成啦！其他云服务厂商的配置都是大同小异，如果本文的反响不错，我可以添加一个阿里云OSS的配置教程。</p><p>感谢大家支持啦！如果在配置过程中有任何问题，都可以在评论区与我交流。如果本文帮助到了你，也可以在评论区互动一下，这会让慕雪感觉自己的努力有收获，非常感谢！</p>]]></content>
    
    
    <summary type="html">一步一步引导诸位配置思源笔记的S3同步。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="docker" scheme="https://blog.musnow.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】647.回文子串</title>
    <link href="https://blog.musnow.top/posts/3816992778/"/>
    <id>https://blog.musnow.top/posts/3816992778/</id>
    <published>2024-07-14T02:08:13.000Z</published>
    <updated>2024-07-14T03:03:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-647.回文子串</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p></blockquote><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 1000</span><br><span class="line">s 由小写英文字母组成</span><br></pre></td></tr></table></figure><h1 id="思路一：双指针法"><a href="#思路一：双指针法" class="headerlink" title="思路一：双指针法"></a>思路一：双指针法</h1><p>我们可以遍历整个字符串，用双指针法从当前下标开始扩张寻找回文子串。找寻相同的字符，如果找到了，则将结果集加一（回文子串个数）。</p><p>这里需要注意的是，回文子串有两种情况，一种是奇数长度，我们从中间位置开始扩张就OK了，另外一种是偶数长度，我们必须从中间两位开始扩张。</p><p>这个思路比较好理解，所以直接上代码。主要还是注意奇数和偶数这两种不同的回文子串长度。偶数情况可以从<code>(i-1,i)</code>开始找，也可以从<code>(i,i+1)</code>开始找，最终结果都是等价的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            result += <span class="built_in">subStringExtend</span>(s, i, i, s.<span class="built_in">size</span>());     <span class="comment">// 奇数</span></span><br><span class="line">            result += <span class="built_in">subStringExtend</span>(s, i, i + <span class="number">1</span>, s.<span class="built_in">size</span>()); <span class="comment">// 偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从left/right开始往两头扩展，返回最长回文子串长度</span></span><br><span class="line">    <span class="comment">// 分为二者相等（奇数长度）二者不等（偶数长度）的情况</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subStringExtend</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 字符自己也认为是一个长度</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; end &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 结果长度</span></span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/df29ff97cd6c91a9429382adb4d27a47.png" alt="image.png"></p><h1 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a>思路二：动态规划</h1><p>动态规划的思路就在<a href="https://blog.musnow.top/posts/2092587888">516最长回文子序列</a>题目里面接触过了。</p><p>动态规划的思路主要还是在于回文子串的特性是只需要判断首末两个字符是否相同。如果相同，再根据之前判断的结果，看这两个字符中间的部分是否回文，就能得出整体是否回文。</p><p>定义二维bool数组dp，长和宽都是字符串的长度；<code>dp[i][j]</code>的含义是i和j之间的子串是否为回文子串。</p><p>此时递推就只有<code>s[i]==s[j]</code>的情况需要进行操作，分为三种长度</p><ol><li>长度为1，一个字符是回文；</li><li>长度为2，两个字符相同，比如<code>aa</code>，也是回文；</li><li>长度大于2，可能是奇数回文也可能是偶数回文子串，判断<code>dp[i+1][j-1]</code>是否为true。</li></ol><p>根据这个递推关系，i和j的遍历顺序也需要进行修改，首先j肯定大于i，所以j是从i开始正序遍历的（因为j依赖于j-1）；而i依赖于i+1，所以i是从最后一个字符开始倒叙遍历的。</p><p>初始化的时候，只需要初始化矩阵中i和j相等的部分，相当于一个字符，是回文子串。</p><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代表s中i和j下标之间是否是回文子串</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 初始化，i和j相同的时候肯定是回文，初始化为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始遍历，依赖项是i+1和j-1，所以i倒叙遍历，j正序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="comment">// 只有一个字符，或者两个字符，是回文</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(i - j) + <span class="number">1</span> &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 偶数回文和奇数回文的情况等价，需要判断中间是否回文</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/88be5cf1b9174388e1e9428a851cd66c.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-647.回文子串</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】72.编辑距离问题</title>
    <link href="https://blog.musnow.top/posts/3809163346/"/>
    <id>https://blog.musnow.top/posts/3809163346/</id>
    <published>2024-07-14T01:29:40.000Z</published>
    <updated>2024-07-14T01:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-72.编辑距离问题</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p><a href="https://leetcode.cn/problems/edit-distance/">https://leetcode.cn/problems/edit-distance/</a></p></blockquote><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= word1.length, word2.length &lt;= 500</span><br><span class="line">word1 和 word2 由小写英文字母组成</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题基于<a href="https://blog.musnow.top/posts/1692714843">583.两个字符串的删除操作</a>上，将只可以删除一个字符改成了可以进行删除、替换、插入操作。但本质还是两个字符串进行比较，所以大部份代码都是一模一样的，只有比较时两个字符不相同的时候的操作才有区别。</p><p>首先是定义dp数组，还是采用常用的定义方式</p><ul><li><code>dp[i][j]</code>：将字符串1的i之前和字符串2的j之前变成相同字符串的最少操作次数。</li></ul><p>然后是确定dp数组的递推，首先是<code>word1[i-1]</code>和<code>word2[j-1]</code>相同和不相同这两种大情况</p><ul><li>当<code>word1[i-1] == word2[j-1]</code>，相当于不需要进行操作，<code>dp[i][j]=dp[i-1][j-1]</code>;</li><li>当<code>word[i-1] != word2[j-1]</code>，就需要进行编辑修改了；</li></ul><p>当二者不同的时候，有多种方式进行修改，题目给出的是删除、替换、插入。但其实插入和删除是等价的！给出下面这两个字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word1=&quot;a&quot; word2=&quot;ab&quot;</span><br></pre></td></tr></table></figure><p>假设我们进行删除，可以从word2中删除b字符，操作数是1；而进行插入是给word1插入一个字符b，操作数也是1。二者的操作数相同，那么递推公式也就相同，所以插入和删除可以认为是一种操作方式！</p><p>和583题不同的点就在于有一个<strong>替换</strong>的操作方式，当两个字符不同的时候，我们可以直接替换其中一个字符串中的字符，替换后两个字符就相等了，也就变成了<code>word1[i-1] == word2[j-1]</code>的情况，<code>dp[i][j]==dp[i-1][j-1]+1</code>;</p><p>最终的递推方案如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) &#123;</span><br><span class="line"><span class="comment">// 二者相等，不需要做额外操作，沿用前一位的结果</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 二者不相等，分为三种操作情况，其中插入一个字符和删除一个字符等价</span></span><br><span class="line"><span class="comment">// 1.在word1中删除一个字符</span></span><br><span class="line"><span class="type">int</span> action1 = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 2.在word2中删除一个字符</span></span><br><span class="line"><span class="type">int</span> action2 = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 3.二者都删除一个字符</span></span><br><span class="line"><span class="type">int</span> action3 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 4.在word1或者word2中替换一个字符，那就是使用一次操作让二者相等</span></span><br><span class="line"><span class="type">int</span> action4 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 得到最小值</span></span><br><span class="line">dp[i][j] =</span><br><span class="line"><span class="built_in">min</span>(<span class="built_in">min</span>(action1, action2), <span class="built_in">min</span>(action3, action4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，这里完全可以省略583题目中<strong>两个字符串中都删除字符</strong>的操作，因为它的值很明显比替换字符需要的操作数多一次，进行min计算是没有意义的。</p><p>初始化和遍历方式都和583题目完全一样，可以去看站内之前写的<a href="https://blog.musnow.top/posts/1692714843">583题目</a>的题解，这里就不赘述了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> sz1 = word1.<span class="built_in">size</span>(), sz2 = word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (sz1 == <span class="number">0</span> || sz2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sz1 == <span class="number">0</span> ? sz2 : sz1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1中i之前和2中j之前的字符串的最小编辑距离</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(sz1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(sz2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化情况，dp[0][0]是两个空字符串，不需要编辑，初始化为0</span></span><br><span class="line">        <span class="comment">// i=0的情况和j=0的情况都是初始化为另外一个字符串的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz1; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sz2; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sz2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 二者相等，不需要做额外操作，沿用前一位的结果</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 二者不相等，分为三种操作情况，其中插入一个字符和删除一个字符等价</span></span><br><span class="line">                    <span class="comment">// 1.在word1中删除一个字符</span></span><br><span class="line">                    <span class="type">int</span> action1 = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 2.在word2中删除一个字符</span></span><br><span class="line">                    <span class="type">int</span> action2 = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 3.二者都删除一个字符，但这会比第四点耗费多一次操作，没意义</span></span><br><span class="line">                    <span class="comment">// int action3 = dp[i - 1][j - 1] + 2;</span></span><br><span class="line">                    <span class="comment">// 4.在word1或者word2中替换一个字符，那就是使用一次操作让二者相等</span></span><br><span class="line">                    <span class="type">int</span> action4 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 得到最小值</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(action1, action2), action4);</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;:&quot; &lt;&lt; dp[i][j] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sz1][sz2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/89371c34c3d6a3dacfa8f4ce0db8fa16.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-72.编辑距离问题</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】583.两个字符串的删除操作</title>
    <link href="https://blog.musnow.top/posts/1692714843/"/>
    <id>https://blog.musnow.top/posts/1692714843/</id>
    <published>2024-07-07T11:30:28.000Z</published>
    <updated>2024-07-07T11:48:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-583.两个字符串的删除操作。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">https://leetcode.cn/problems/delete-operation-for-two-strings/</a></p></blockquote><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。</p><p>每步 可以删除任意一个字符串中的一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: word1 = &quot;sea&quot;, word2 = &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot;</span><br><span class="line"></span><br><span class="line">示例  2:</span><br><span class="line">输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= word1.length, word2.length &lt;= 500</span><br><span class="line">word1 和 word2 只包含小写英文字母</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题要求将两个字符串变成相同的字符串，对于给出的所有用例，肯定是能变成相同的，最大的删除操作数就是将两个字符串的所有字符都删除（即两个字符串的长度之和），此时会得到两个空字符串，空字符串自然是相等的。至于其他情况，需要求的是<strong>最少</strong>操作次数，我们需要用<strong>动态规划</strong>的思路来解题。</p><p>这道题和之前写过的<a href="https://blog.musnow.top/posts/3193784003">115题：不同的子序列</a>非常相似，在115题中，是用s的子序列去匹配t整个字符串，t字符串不能改变，只能在s中删除字母。但本题是求两个字符串怎么通过一些操作变成相同的字符串，每一步都可以从两个字符串其中一个字符串中删除一个字符，两个字符串都能被修改。</p><p>先来走动态规划的流程吧！第一步是确定dp数组的含义。</p><ul><li><code>dp[i][j]</code>：字符串a中下标i-1和字符串b中下标i-1及其之前的字符串需要至少几次操作能变成相同的字符串。</li><li>这里也可以理解为字符串a中前i个字符组成的字符串与字符串b中前j个字符组成的字符串需要至少几次操作能变成相同的字符串。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                       <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>然后是确定递推公式</p><ul><li>情况一：<code>a[i-1] == b[j-1]</code>，此时不需要删除字符，沿用<code>dp[i-1][j-1]</code>的结果就行了。</li><li>情况二：<code>a[i-1] != b[j-1]</code>，此时需要删除字符，有三种删除方式，取其中最小值即可：<ul><li>删除a中的字符，结果为<code>dp[i-1][j]+1</code>;</li><li>删除b中的字符，结果为<code>dp[i][j-1]+1</code>;</li><li>把a和b中的这俩字符都删了，结果为<code>dp[i-1][j-1]+2</code>;</li></ul></li></ul><p>dp数组的遍历顺序，因为<code>dp[i][j]</code>很明显是依赖于<code>dp[i-1][j-1]</code>的，所以需要从左到右遍历。</p><p>再确定如何初始化dp数组，也分为三种情况：</p><ul><li><code>i=0,j=0</code>的情况，两个都是空字符串，不需要做删除操作，初始化为0；</li><li><code>i=0</code>或<code>j=0</code>的情况，一个是空字符串，另外一个字符串需要做的操作次数是字符串的长度次。</li></ul><p>最终的初始化代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i和j都为0的时候不需要操作，初始化为0（通过构造函数初始化）</span></span><br><span class="line"><span class="comment">// 当i=0或者j=0的时候，需要的操作次数是当前的字符串长度，即需要将当前字符串全部删除才能和空字符串相同</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整代码如下，思路明白了代码还是很好写的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果有一个长度为0，那么需要做的操作是另外一个字符串的长度次</span></span><br><span class="line">        <span class="keyword">if</span> (word1.<span class="built_in">size</span>() == <span class="number">0</span> || word2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> word1.<span class="built_in">size</span>() == <span class="number">0</span> ? word2.<span class="built_in">size</span>() : word1.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp数组，代表a中i-1和b中j-1的字符串相同需要操作的最少次数（i和j可以认为是字符串长度）</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                               <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// i和j都为0的时候不需要操作，初始化为0（通过构造函数初始化）</span></span><br><span class="line">        <span class="comment">// 当i=0或者j=0的时候，需要的操作次数是当前的字符串长度，即需要将当前字符串全部删除才能和空字符串相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 情况1，二者相同，不需要删除</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="comment">// 情况2，不同</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 把word1中的字符串删除，需要的操作次数是dp[i-1][j]+1</span></span><br><span class="line">                    <span class="comment">// 把word2中的字符串删除，需要的操作次数是dp[i][j-1]+1</span></span><br><span class="line">                    <span class="comment">// 把word1和2中的字符串都删除，需要的操作次数是dp[i-1][j-1]+2</span></span><br><span class="line">                    <span class="comment">// 取三种情况最小值作为最终结果。</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                                   <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp数组右下角的值就是最终结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/c4a7e94f23264e9d36aec1931f96f0d6.png" alt="image.png"></p><p>注意提交到leetcode时候可能会提示返回值不匹配，将函数开头的if里面加一个对<code>int</code>类型的强转就行了。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-583.两个字符串的删除操作</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】升级OpenSSH版本规避远程代码执行漏洞</title>
    <link href="https://blog.musnow.top/posts/3307105016/"/>
    <id>https://blog.musnow.top/posts/3307105016/</id>
    <published>2024-07-06T01:53:14.000Z</published>
    <updated>2024-07-06T15:01:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>升级OpenSSH版本规避远程代码执行漏洞。</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>今天早上逛别人的博客的时候看到了这个重磅消息。OpenSSH爆出能远程通过root身份执行任意代码的漏洞，影响版本是 <code>8.5p1 &lt;= OpenSSH &lt; 9.8p1</code>，奇安信的报告可以<a href="https://www.secrss.com/articles/67636?app=1">点我</a>查看。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/3b52c18c721324a209cb2a710faa7b90.png"></p><p>上我的几个云服务器（ubuntu22.04和CentOS8Strem）看了看版本，Ubuntu的服务器中招了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sshd -V</span><br><span class="line">unknown option -- V</span><br><span class="line">OpenSSH_8.9p1 Ubuntu-3ubuntu0.6, OpenSSL 3.0.2 15 Mar 2022</span><br><span class="line">usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]</span><br><span class="line">            [-E log_file] [-f config_file] [-g login_grace_time]</span><br><span class="line">            [-h host_key_file] [-o option] [-p port] [-u len]</span><br></pre></td></tr></table></figure><p>CentOS的服务器因为依赖项确实老旧，没有中招，因祸得福了属于是。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sshd -V</span><br><span class="line">unknown option -- v</span><br><span class="line">OpenSSH_8.0p1, OpenSSL 1.1.1k  FIPS 25 Mar 2021</span><br><span class="line">usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]</span><br><span class="line">            [-E log_file] [-f config_file] [-g login_grace_time]</span><br><span class="line">            [-h host_key_file] [-o option] [-p port] [-u len]</span><br></pre></td></tr></table></figure><p>不过本次攻击如果服务器上有fail2ban的话能被拦截掉。我的服务器都安装了1panel里面的fail2ban组件，好欸！</p><h1 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h1><blockquote><p>参考博客：<a href="https://learnku.com/articles/87482">https://learnku.com/articles/87482</a> 和论坛 <a href="https://linux.do/t/topic/124761">https://linux.do/t/topic/124761</a></p></blockquote><p>编译和安装依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装编译依赖</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y build-essential zlib1g-dev libssl-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载指定版本源码</span></span><br><span class="line">wget https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-9.8p1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压并进入目录</span></span><br><span class="line">tar -xzf openssh-9.8p1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssh-9.8p1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译和安装</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">sudo systemctl restart ssh</span><br></pre></td></tr></table></figure><p>可以用下面的命令一键升级（和上面的一致只是整合在一起了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y build-essential zlib1g-dev libssl-dev &amp;&amp; wget https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-9.8p1.tar.gz &amp;&amp; tar -xzf openssh-9.8p1.tar.gz &amp;&amp; <span class="built_in">cd</span> openssh-9.8p1 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; sudo make install &amp;&amp; sudo systemctl restart ssh</span><br></pre></td></tr></table></figure><p>处理后重新看看版本更新了没有，如下所示就是OK了——吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ssh -V</span><br><span class="line">OpenSSH_9.8p1, OpenSSL 3.0.2 15 Mar 2022</span><br></pre></td></tr></table></figure><p>实际上，上文的步骤只更新了ssh（客户端），而且是一个环境变量导致的“假更新”，sshd（服务端）还没有变化，还是旧版本。用可执行文件的<strong>绝对路径</strong>查看版本就会漏出鸡脚，依然是旧版本没有被正常升级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/bin/ssh -V</span><br><span class="line">OpenSSH_8.9p1 Ubuntu-3ubuntu0.10, OpenSSL 3.0.2 15 Mar 2022</span><br></pre></td></tr></table></figure><p>要更新一下软连接，才能正确更新ssh&#x2F;sshd。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份原来的ssh组件</span></span><br><span class="line"><span class="built_in">mv</span> /usr/sbin/sshd /usr/sbin/sshd.old</span><br><span class="line"><span class="built_in">mv</span> /usr/bin/ssh /usr/bin/ssh.old</span><br><span class="line"><span class="built_in">mv</span> /usr/bin/ssh-keygen /usr/bin/ssh-keygen.old</span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line"><span class="built_in">cp</span> /usr/local/bin/ssh /usr/bin/ssh</span><br><span class="line"><span class="built_in">cp</span> /usr/local/bin/ssh-keygen /usr/bin/ssh-keygen</span><br><span class="line"><span class="built_in">cp</span> /usr/local/sbin/sshd /usr/sbin/sshd</span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo systemctl restart ssh</span><br><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><p>如下所示，更新成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># sshd -V</span><br><span class="line">OpenSSH_9.8p1, OpenSSL 3.0.2 15 Mar 2022</span><br><span class="line"># ssh -V</span><br><span class="line">OpenSSH_9.8p1, OpenSSL 3.0.2 15 Mar 2022</span><br></pre></td></tr></table></figure><p>注意，必须使用cp来修改文件，而不能使用软连接！</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>注意，升级完毕sshd后会导致服务器的ssh密钥发生变化，如果你的本地曾经链接过这个主机，会出现本地记录的公钥和服务器升级ssh后重新发送的公钥不一致的情况。</p><p>这时候需要修改<code>C:\Users\用户名\.ssh\known_hosts</code>这个文件（使用记事本打开就行了），将里面对应云服务器IP开头的记录全部删除，再重新链接服务器。</p><p>如果您不执行这一步操作，一些严格检查密钥的ssh终端软件可能会无法连接服务器，比如vscode的remote ssh插件，tabby则会在重新链接服务器的时候弹出密钥不一致的警告。反正修改一下准没错，修改了之后重新接受并保存云服务器发过来的新密钥就可以了。</p><p>PS：vscode的remove ssh插件在出现密钥不一致的时候会显示链接不上远程服务器，但是在错误日志中会打印出密钥不一致和开启了严格检查相关的字样（当然打印的错误信息是全英文的），我也是因此定位到这个问题的。所以说遇到问题的时候，不要有畏难情绪，一定要敢于看日志，敢于查日志。</p>]]></content>
    
    
    <summary type="html">升级OpenSSH版本规避远程代码执行漏洞</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Linux" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【docker】使用github action来自动发布项目到dockerhub</title>
    <link href="https://blog.musnow.top/posts/92024430/"/>
    <id>https://blog.musnow.top/posts/92024430/</id>
    <published>2024-06-27T14:04:31.000Z</published>
    <updated>2024-07-01T03:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用github action来自动发布项目到dockerhub。参考 <a href="https://msdemt.github.io/p/github-action-build-docker/">https://msdemt.github.io/p/github-action-build-docker/</a> 博客</p><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><h2 id="1-1-dockerhub-token"><a href="#1-1-dockerhub-token" class="headerlink" title="1.1 dockerhub token"></a>1.1 dockerhub token</h2><blockquote><p><a href="https://hub.docker.com/settings/security">https://hub.docker.com/settings/security</a></p></blockquote><p>登录dockerhub，在用户的account settings里面获取用户token</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e5a6a9c655d9db35241803283107f9b6.png" alt="image.png"></p><p>将其添加到github仓库的secrets里面，具体位置是仓库设置中的 Secrets and variables 里面的 Actions 栏目中，如下图所示，添加 Repository secrets。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/5f6bbb25c29e36438a077c77b0b2f7f8.png" alt="image.png"></p><p>需要添加的是<code>DOCKER_USERNAME</code>为你的docker用户名（注意是用户名，不是邮箱），还有<code>DOCKER_TOKEN</code>为刚刚我们在dockerhub中获取的token。</p><h2 id="1-2-获取github操作token"><a href="#1-2-获取github操作token" class="headerlink" title="1.2 获取github操作token"></a>1.2 获取github操作token</h2><blockquote><p><a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p></blockquote><p>到GitHub的用户设置中，创建一个token，需要给予repo、workflow、packages权限。如果你不知道给予什么权限，直接全给他选上，保障这个token不泄露给外部就可以了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/d34671906803fd55ffe656bd4643f6d5.png" alt="image.png"></p><p>另外，expiration是过期日期，如果你担心泄漏造成问题，可以设置一个过期时间，但是需要到时间后去更新仓库的secrets。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/6df1058ec2b9b838df0451d1d9dd2dfe.png" alt="image.png"></p><p>点击确定以后会得到token，复制他，同样是到github仓库的secrets里面添加一个 <code>RELEASE_TOKEN</code> 变量。</p><h1 id="2-上传workflows文件"><a href="#2-上传workflows文件" class="headerlink" title="2.上传workflows文件"></a>2.上传workflows文件</h1><h2 id="2-1-添加如下yml文件"><a href="#2-1-添加如下yml文件" class="headerlink" title="2.1 添加如下yml文件"></a>2.1 添加如下yml文件</h2><p>前期的准备工作已经搞定了，现在就是添加一个github action的yml文件了。</p><p>在你的仓库里面创建一个<code>.github/workflows</code>文件夹，并在里面创建一个<code>.yml</code>文件，写入如下内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">docker</span> <span class="string">images</span> <span class="string">cicd</span></span><br><span class="line"><span class="comment"># 触发器设置</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;main&quot;</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;main&quot;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目任务，任务之间可以并行调度</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">  <span class="comment"># 选择云端运行的环境</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="comment"># uses代表使用一个模块，此处使用的是checkout模块，将github项目文件导入到当前环境中</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">    <span class="comment"># 使用with跟在后面来为前面的模块输入参数</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">QEMU</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/setup-qemu-action@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Docker</span> <span class="string">Buildx</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/setup-buildx-action@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Login</span> <span class="string">to</span> <span class="string">DockerHub</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/login-action@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">    <span class="comment"># 这里用到了github的secrets功能，避免账户和密码随仓库泄露</span></span><br><span class="line">       <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">       <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="comment"># 设置当前的发行版本tag</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Release</span> <span class="string">version</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">release_version</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        app_version=$(cat version.py |sed -ne &quot;s/APP_VERSION\s=\s&#x27;v\(.*\)&#x27;/\1/gp&quot;)</span></span><br><span class="line"><span class="string">        echo &quot;app_version=$app_version&quot; &gt;&gt; $GITHUB_ENV</span></span><br><span class="line"><span class="string"></span>    <span class="comment"># 开始构建镜像</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">push</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/build-push-action@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">        <span class="attr">file:</span> <span class="string">dockerfile</span></span><br><span class="line">        <span class="attr">build-args:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          GITHUB_TOKEN=$&#123;&#123; secrets.RELEASE_TOKEN &#125;&#125;</span></span><br><span class="line"><span class="string"></span>        <span class="attr">platforms:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          linux/amd64</span></span><br><span class="line"><span class="string">          linux/arm64</span></span><br><span class="line"><span class="string">          linux/arm</span></span><br><span class="line"><span class="string"></span>        <span class="attr">push:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 指定用户/仓库名</span></span><br><span class="line">        <span class="attr">tags:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;/kook-ticket-bot:latest</span></span><br><span class="line"><span class="string">          $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;/kook-ticket-bot:$&#123;&#123; env.app_version &#125;&#125;</span></span><br><span class="line"><span class="string"></span>    <span class="comment"># 这里是通过md文件自动生成dockerhub描述的模块，也可以不需要</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Docker</span> <span class="string">Hub</span> <span class="string">Description</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peter-evans/dockerhub-description@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USERNAME</span> <span class="string">&#125;&#125;/kook-ticket-bot</span></span><br><span class="line">        <span class="attr">readme-filepath:</span> <span class="string">./README.md</span></span><br></pre></td></tr></table></figure><p>对这里面的内容做一定说明，其中<code>secrets.</code>使用的就是我们刚刚添加到github仓库中的变量，分别用于访问github仓库和登录dockerhub。</p><blockquote><p>你会发现最末尾通过readme文件自动生成dockerhub的描述部分，多出来了一个上文没有提到的<code>secrets.DOCKER_PASSWORD</code>，这个是你dockerhub账户的密码。如果你不需要自动生成dockerhub的描述，那就可以把最后一个<code>Docker Hub Description</code>条目直接删除了，否则需要添加这个secrets。</p></blockquote><p>项目中我使用了<code>version.py</code>文件来存放最新的版本号，该文件需要在项目的根路径中创建，内容格式如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP_VERSION = <span class="string">&#x27;版本号&#x27;</span></span><br></pre></td></tr></table></figure><p>使用这个workflows文件，你只需要修改<code>$&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;/kook-ticket-bot</code>里面右侧的镜像名字为你的项目名字，将<code>file: dockerfile</code>这里的dockerfile设置为你项目中dockerfile的文件路径就可以了。</p><p>另外，在这个yml中，指定了三个平台的docker镜像，这里可以根据你自己的实际需要来减少一些平台。毕竟大部分用户用的都是amd64（即x86）的电脑，如果没有用户需要使用arm平台，可以把后两项删除，以加快github action的运行速度。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">platforms:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  linux/amd64</span></span><br><span class="line"><span class="string">  linux/arm64</span></span><br><span class="line"><span class="string">  linux/arm</span></span><br></pre></td></tr></table></figure><p>最终完成action的截图如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/de256712cbc7eeb5a0b09c51b21fa424.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/66332edc975a36e9f3e7c76b8d336554.png" alt="image.png"></p><h2 id="2-2-关于GITHUB-REPOSITORY-NAME-PART环境变量"><a href="#2-2-关于GITHUB-REPOSITORY-NAME-PART环境变量" class="headerlink" title="2.2 关于GITHUB_REPOSITORY_NAME_PART环境变量"></a>2.2 关于GITHUB_REPOSITORY_NAME_PART环境变量</h2><p>在别的github action教学文章中，会提到使用<code>$&#123;&#123; env.GITHUB_REPOSITORY_NAME_PART &#125;&#125;</code>来直接用github的仓库名字作为镜像名。但经过我的测试，这个方法<strong>不适用于本文</strong>的这个workflows文件，使用该环境变量会导致容器的名字多出来一个尾随的<code>/</code>，最终的镜像名字变成了<code>用户名/镜像名/:tag</code>，不符合dockerhub中镜像的命名规范。以下是具体的actions执行错误截图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e8cc4604fa2b465f6ff37f8cc8862a69.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>不过，根据github actions上的warning，我这个workflows文件已经是老版本的了，里面使用的很多特性都即将不再支持，所以只是个临时用用的权宜之计，后续得去找个另外的yaml文件来处理这个docker镜像了。</p>]]></content>
    
    
    <summary type="html">使用github action来自动发布项目到dockerhub</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【win】解决windows打游戏卡输入法的问题</title>
    <link href="https://blog.musnow.top/posts/104528985/"/>
    <id>https://blog.musnow.top/posts/104528985/</id>
    <published>2024-06-26T03:04:23.000Z</published>
    <updated>2024-06-27T14:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>APEX在24.06.26更新了四人赛的新版本，然后，您猜怎么着？卡输入法啦！昨天的旧版本都不卡的，不愧是重生，引入了新的BUG。</p><p>本片博文来告诉各位游戏玩家，如何让你的游戏不会卡输入法。</p><p>给不打游戏的老哥科普一下：卡输入法一般指<strong>卡中文输入法</strong>，即部分游戏与中文输入法不兼容，在游戏全屏的时候，WASD会直接呼出中文输入法，导致游戏退出全屏，且不响应玩家的输入。如果在和其他玩家干架的时候遇到这个问题，那就GG了。</p><h1 id="添加ENG语言选项"><a href="#添加ENG语言选项" class="headerlink" title="添加ENG语言选项"></a>添加ENG语言选项</h1><p>在windows设置中找到语言和区域，在这里添加一个英文语言，一般添加 <code>英语（美国）</code> 这个语言，只需要选择基本输入法就行了，语言包什么的都可以不用选。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/d558dfff82b9867940d095c535c00d97.png" alt="image.png"></p><p>打游戏的时候，在状态栏右下角将语言切换为ENG，就不会卡输入法了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/f23fd8f3f31318f12d2ed88edabf9eb3.png" alt="image.png"></p><h1 id="关闭快捷键"><a href="#关闭快捷键" class="headerlink" title="关闭快捷键"></a>关闭快捷键</h1><p>默认情况下，切换输入法会有两个快捷键，一个是WIN+空格，一个是ALT+SHIFT，这两个快捷键都极其容易在打游戏的时候误触，所以我们需要把快捷键给改了。</p><p>在win11的<code>设置-时间和语言-输入-高级键盘设置</code>中，找到<strong>输入语言热键</strong>选项，将输入语言的热键全都设置为无。这样ALT+SHIFT的快捷键就被删了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e520841c3cc8fc6b17718029b44f7e4a.png" alt="image.png"></p><p>现在就只能用<code>WIN+空格</code>切换输入法了，直接用键盘把WIN给锁了就行了（一般都是FN+WIN快捷键），稍微好一点的键盘都有锁WIN这个功能。</p><p>部分游戏本也有锁WIN的功能，一般是在游戏本的控制台里面（据我所知拯救者和华硕的游戏本都有这个功能，其他品牌不清楚）。如果是商务本，那基本就没有这个功能了，考虑外接键盘吧。</p><p>根据我个人核显本、带独立显卡的轻薄本、游戏本都用过一圈的使用经历，目前就没有几个笔记本电脑能做到打游戏键盘完全不烫手的。<strong>为了避免低温烫伤</strong>，请不要使用笔记本自带键盘打游戏，这可关系到个人健康！哪怕买个最烂的薄膜键盘，也好过烫烫烫！</p>]]></content>
    
    
    <summary type="html">解决windows打游戏卡输入法的问题</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Python】使用py脚本按序号重命名md文档</title>
    <link href="https://blog.musnow.top/posts/2939398257/"/>
    <id>https://blog.musnow.top/posts/2939398257/</id>
    <published>2024-06-21T02:12:32.000Z</published>
    <updated>2024-06-21T11:54:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>前情提要：我的HEXO是用obsidian管理的，本地使用FreeFileSync将obsidian中CODE目录里面的所有文件（这个目录里面都是博客）镜像同步到HEXO配置的<code>_posts</code>目录里面。</p><p>为了方便按时间排序我的文档，我每次写新博客的时候，都会按序号命名。但是之前将一些大文件夹里面的md文件进行了细分归纳，导致某些文件夹里面的md文件<strong>序号不再连续</strong>，看起来非常奇怪，自己改肯定不方便，直接写个python脚本来处理一下这种情况吧。</p><p>我的md文件是这样命名的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序号.文件名.md</span><br></pre></td></tr></table></figure><p>在某个文件夹下会出现这种情况，即文件的序号不连续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.文件a.md</span><br><span class="line">3.文件b.md</span><br><span class="line">10.文件c.md</span><br></pre></td></tr></table></figure><p>我想达成的目标就是让这三个文件按连续的序号重新命名，并添加前导0，就像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01.文件a.md</span><br><span class="line">02.文件b.md</span><br><span class="line">03.文件c.md</span><br></pre></td></tr></table></figure><p>将需求直接喂给GPT，给出了下面这个脚本，个人测试完全莫得问题，贴出来分享给大家。自己写也不是写不出来，主要就是懒，实在是太懒了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename_md_files</span>(<span class="params">folder_path</span>):</span><br><span class="line">    <span class="comment"># 获取所有md文件</span></span><br><span class="line">    files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(folder_path) <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.md&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用正则表达式匹配文件名中的数字</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(\d+)\..+\.md$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取出所有匹配的文件</span></span><br><span class="line">    matched_files = []</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">match</span> = pattern.<span class="keyword">match</span>(file)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            matched_files.append((<span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="number">1</span>)), file))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照原始数字顺序排序</span></span><br><span class="line">    matched_files.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新编号</span></span><br><span class="line">    <span class="keyword">for</span> new_index, (old_index, old_name) <span class="keyword">in</span> <span class="built_in">enumerate</span>(matched_files, start=<span class="number">1</span>):</span><br><span class="line">        new_name = <span class="string">f&quot;<span class="subst">&#123;new_index:02d&#125;</span>.<span class="subst">&#123;old_name.split(<span class="string">&#x27;.&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>]&#125;</span>&quot;</span></span><br><span class="line">        old_path = os.path.join(folder_path, old_name)</span><br><span class="line">        new_path = os.path.join(folder_path, new_name)</span><br><span class="line">        os.rename(old_path, new_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Renamed &#x27;<span class="subst">&#123;old_name&#125;</span>&#x27; to &#x27;<span class="subst">&#123;new_name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_and_rename</span>(<span class="params">folder_path</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(folder_path):</span><br><span class="line">        rename_md_files(root)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> dirs:</span><br><span class="line">            traverse_and_rename(os.path.join(root, <span class="built_in">dir</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    folder_path = <span class="string">r&quot;path/to/folder&quot;</span>  <span class="comment"># 替换为你的文件夹路径</span></span><br><span class="line">    traverse_and_rename(folder_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The End.&quot;</span>)</span><br></pre></td></tr></table></figure><p>修改脚本最末尾需要处理的文件夹路径，脚本会使用<code>os.walk</code>来遍历这个文件路径下的所有文件，并交付给<code>traverse_and_rename</code>函数进行md文件的处理。在<code>traverse_and_rename</code>函数中，使用了正则来匹配我的原有文件命名方式，再根据原有的序号进行排序，最终按排序的结果重新命名文档。</p><p>这里的<code>new_index:02d</code>就是添加前导0的写法，<code>02d</code>代表数字不足两位会添加一个前导0。比如01和02。</p><p>运行脚本，会打印出原有名字和命名后的结果，个人感觉效果还是非常不错的。不过还是得提醒一下大家：<strong>使用任何脚本操作你的笔记之前，都一定要对先有的数据备份一次</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PS E:\GIT\rename_py&gt; python test.py</span><br><span class="line">Renamed &#x27;0.设置py环境.md&#x27; to &#x27;01.设置py环境.md&#x27;</span><br><span class="line">Renamed &#x27;1.git自动上传脚本.md&#x27; to &#x27;02.git自动上传脚本.md&#x27;</span><br><span class="line">Renamed &#x27;3.request的ssl报错.md&#x27; to &#x27;03.request的ssl报错.md&#x27;</span><br><span class="line">Renamed &#x27;4.request session的cookie如何导入到aiohttp.md&#x27; to &#x27;04.request session的cookie如何导入到aiohttp.md&#x27;</span><br><span class="line">Renamed &#x27;5.生成requeirments.txt文件.md&#x27; to &#x27;05.生成requeirments.txt文件.md&#x27;</span><br><span class="line">Renamed &#x27;7.ValueError Sample larger than population or is negative.md&#x27; to &#x27;06.ValueError Sample larger than population or is negative.md&#x27;</span><br><span class="line">Renamed &#x27;8.python自动化下载md文件中图片.md&#x27; to &#x27;07.python自动化下载md文件中图片.md&#x27;</span><br><span class="line">Renamed &#x27;10.ssl报错证书错误的解决方法.md&#x27; to &#x27;08.ssl报错证书错误的解决方法.md&#x27;</span><br><span class="line">Renamed &#x27;11.pip安装使用镜像源.md&#x27; to &#x27;09.pip安装使用镜像源.md&#x27;</span><br><span class="line">Renamed &#x27;12.logging设置时间的时区.md&#x27; to &#x27;10.logging设置时间的时区.md&#x27;</span><br><span class="line">Renamed &#x27;13.Centos安装python3.10.md&#x27; to &#x27;11.Centos安装python3.10.md&#x27;</span><br><span class="line">Renamed &#x27;18.python的异步同步.md&#x27; to &#x27;12.python的异步同步.md&#x27;</span><br><span class="line">Renamed &#x27;20.pycharm设置中文字体.md&#x27; to &#x27;13.pycharm设置中文字体.md&#x27;</span><br><span class="line">Renamed &#x27;21.pymysql链接错误.md&#x27; to &#x27;14.pymysql链接错误.md&#x27;</span><br><span class="line">Renamed &#x27;22.pip安装包时找不到Python.h.md&#x27; to &#x27;15.pip安装包时找不到Python.h.md&#x27;</span><br><span class="line">Renamed &#x27;23.调用飞书api获取excel表格中数据.md&#x27; to &#x27;16.调用飞书api获取excel表格中数据.md&#x27;</span><br><span class="line">Renamed &#x27;24.元组列表集和的区别.md&#x27; to &#x27;17.元组列表集和的区别.md&#x27;</span><br><span class="line">Renamed &#x27;25.API的分类.md&#x27; to &#x27;18.API的分类.md&#x27;</span><br><span class="line">Renamed &#x27;26.python分片计算文件md5.md&#x27; to &#x27;19.python分片计算文件md5.md&#x27;</span><br><span class="line">Renamed &#x27;27.python文件分片加密和上传.md&#x27; to &#x27;20.python文件分片加密和上传.md&#x27;</span><br><span class="line">Renamed &#x27;28.valorant国服和港服文件差距.md&#x27; to &#x27;21.valorant国服和港服文件差距.md&#x27;</span><br><span class="line">Renamed &#x27;6.关于阿狸vip画图bug的复盘.md&#x27; to &#x27;01.关于阿狸vip画图bug的复盘.md&#x27;</span><br><span class="line">Renamed &#x27;9.白嫖replit部署ticket机器人.md&#x27; to &#x27;02.白嫖replit部署ticket机器人.md&#x27;</span><br><span class="line">Renamed &#x27;14.阿狸机器人使用文档.md&#x27; to &#x27;03.阿狸机器人使用文档.md&#x27;</span><br><span class="line">Renamed &#x27;15.如何给kook机器人加上翻译功能.md&#x27; to &#x27;04.如何给kook机器人加上翻译功能.md&#x27;</span><br><span class="line">Renamed &#x27;16.多文件kook机器人.md&#x27; to &#x27;05.多文件kook机器人.md&#x27;</span><br><span class="line">Renamed &#x27;17.kook机器人与爱发电对接.md&#x27; to &#x27;06.kook机器人与爱发电对接.md&#x27;</span><br><span class="line">Renamed &#x27;19.linkguard机器人配置个性化撤回消息.md&#x27; to &#x27;07.linkguard机器人配置个性化撤回消息.md&#x27;</span><br><span class="line">Renamed &#x27;01.关于阿狸vip画图bug的复盘.md&#x27; to &#x27;01.关于阿狸vip画图bug的复盘.md&#x27;</span><br><span class="line">Renamed &#x27;02.白嫖replit部署ticket机器人.md&#x27; to &#x27;02.白嫖replit部署ticket机器人.md&#x27;</span><br><span class="line">Renamed &#x27;03.阿狸机器人使用文档.md&#x27; to &#x27;03.阿狸机器人使用文档.md&#x27;</span><br><span class="line">Renamed &#x27;04.如何给kook机器人加上翻译功能.md&#x27; to &#x27;04.如何给kook机器人加上翻译功能.md&#x27;</span><br><span class="line">Renamed &#x27;05.多文件kook机器人.md&#x27; to &#x27;05.多文件kook机器人.md&#x27;</span><br><span class="line">Renamed &#x27;06.kook机器人与爱发电对接.md&#x27; to &#x27;06.kook机器人与爱发电对接.md&#x27;</span><br><span class="line">Renamed &#x27;07.linkguard机器人配置个性化撤回消息.md&#x27; to &#x27;07.linkguard机器人配置个性化撤回消息.md&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">使用python脚本按序号重命名md文档</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Python" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Python/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【win】如何在微软官网下载windows10的iso镜像</title>
    <link href="https://blog.musnow.top/posts/2052482894/"/>
    <id>https://blog.musnow.top/posts/2052482894/</id>
    <published>2024-06-19T01:59:54.000Z</published>
    <updated>2024-06-19T12:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何在微软官网下载windows10的iso镜像？</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>win10官网：<a href="https://www.microsoft.com/zh-cn/software-download/windows10/">https://www.microsoft.com/zh-cn/software-download/windows10/</a></p></blockquote><p>如果你现在打开windows10的官网，会发现压根没有iso镜像的下载选择，这里让你下载的是MediaCreationTool，是用于制作系统安装盘或者直接在当前电脑上安装win10的，用它来下iso可慢的很。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/61ae3e1723b1990be912ba971b646482.png" alt="image.png"></p><h2 id="如何直接下载ISO"><a href="#如何直接下载ISO" class="headerlink" title="如何直接下载ISO"></a>如何直接下载ISO</h2><p>但实际上官网是有iso的下载页面的，只不过在电脑上直接给你藏住了。参考知乎老哥<a href="https://zhuanlan.zhihu.com/p/653156950">pewper</a>的回答，我们需要把电脑的浏览器改成<strong>手机的UA</strong>，然后再访问这个官网，就能看到下载连接了。</p><p>在刚刚的官网页面，按F12打开edge浏览器的开发者选项，然后点击有一个手机和ipad一样图标的选项，这个选项是将浏览器模拟成手机的浏览器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/f710913be974001cebfb53c7647a352a.png" alt="image.png"></p><p>点了之后，会发现好像没有什么变化，只是官网屏幕变小了，别急，我们刷新一下这个界面</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/c18e09d3fe52e0827f78d819d5ac19f8.png" alt="image.png"></p><p>这时候就出现下载ISO的选项了，选择你想下载的版本</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/3f5b6e6a68cdc2ba3f0259a21433608a.png" alt="image.png"></p><p>这里我直接选了国内的win10家庭版</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e38dcf1ba0fb529dbac756c3324efbda.png" alt="image.png"></p><p>然后点击确认，下面就会弹出选择语言的选项，选了简体中文（只有这个选项）之后，再点击一次确认。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e953c0a42bf9fae4d1da4229f11610fa.png" alt="image.png"></p><p>此时就会弹出下32位还是64位iso的页面了，直接下64位的iso就OK了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/b736fa714978eccb436adc6623a1bdc9.png" alt="image.png"></p><h2 id="搞定"><a href="#搞定" class="headerlink" title="搞定"></a>搞定</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e306888c9d32d1cf2e421d78a9e42b47.png" alt="image.png"></p><p>实话实说，不知道微软为什么要藏住明明有的iso下载页面，非引导着用户下MediaCreationTool。</p>]]></content>
    
    
    <summary type="html">如何在微软官网下载windows10的iso镜像</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】115.不同的子序列</title>
    <link href="https://blog.musnow.top/posts/3193784003/"/>
    <id>https://blog.musnow.top/posts/3193784003/</id>
    <published>2024-06-12T08:48:17.000Z</published>
    <updated>2024-07-07T11:30:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-115.不同的子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 <code>10^9 + 7</code> 取模。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/8d31b52d38ede01b577227b1bf213b64.png" alt="image.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先注意审题，本题需要<strong>求s的子序列中t出现的次数</strong>，即t多少次完整的出现在了s的某个子序列中。如果不考虑时间复杂度，其实我们可以用<strong>回溯</strong>把s的所有长度等于t的子序列都列出来，然后再判断是否有和t相同的子序列。</p><p>但很明显，这样写时间复杂度报表了，所以还是用<strong>动态规划</strong>的思路解题。</p><p>第一步是确定dp数组，类似的题目已经写过很多遍了，dp数组的定义都大差不差。</p><ul><li><code>dp[i][j]</code>含义：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为<code>dp[i][j]</code>。</li></ul><p>然后是确定递推的公式，对于这种子序列匹配的题目，都是分为两种情况</p><ul><li><code>s[i-1] == t[j-1]</code>：此时代表s的子序列可以被扩张，也可以选择不扩张，<code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code>;</li><li><code>s[i-1] != t[j-1]</code>：此时代表s的子序列不能扩张，只能沿用“上一次”的结果，因为是在s的子序列中找t，我们不能从t中删除元素，所以“上一次”的结果只有<code>dp[i-1][j]</code>;</li></ul><p>这里对第一种<code>s[i-1] == t[j-1]</code>二者相同的情况做说明，为什么会出现“可以扩张，也可以不扩张”呢？</p><ul><li><strong>扩张的情况</strong>：二者相等，说明当前可能出现t的子序列数量和<code>dp[i-1][j-1]</code>是一致的，因为<code>s[i-1]</code>和<code>t[j-1]</code>这两个字母不需要考虑（这两个字母是相等的，相当于我们从匹配结果中忽略这两个字符，最终得到的子序列的个数也是一样的）。</li><li><strong>不扩张的情况</strong>：二者相等，我们不一定需要用<code>s[i-1]</code>来扩张子序列。<ul><li>比如s是bagg，t是bag的情况，<code>s[3]==t[2]</code>，如果我们使用<code>s[3]</code>，最终的子序列是<code>s[0][1][3]</code>；如果不使用<code>s[3]</code>，最终的子序列是<code>s[0][1][2]</code>，这两个子序列都等于t，都是可行的结果。此时使用<code>dp[i-1][j]</code>，相当于我们不用<code>s[3]</code>去构造子序列，而是沿用了s字符串中前一位的结果，说不定不用这个<code>s[i-1]</code>，之前的结果中也能和当前的<code>t[j-1]</code>完整匹配出一个子序列呢？</li><li>如果不加上不扩张情况的这个值，相当于漏掉了这种可能性，最终得到的答案肯定是错误的。注意dp的递推一直都是有一个依赖关系的，假设<code>s[0][1][2]</code>这个匹配项不存在，那么<code>dp[i-1][j]</code>会是0，也就不会影响当前的结果。</li></ul></li></ul><p>把这两种情况都考虑上，才是正确的推导公式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据推导公式，遍历自然是从小到大遍历，且i和j都依赖于<code>i-1/j-1</code>，所以遍历的时候需要从下标1开始遍历。</p><p>我们还需要对下标0的位置进行初始化，分别是i&#x3D;0和j&#x3D;0的情况</p><ul><li>i为0：代表s字符串为空，此时没有任何办法匹配出t字符串，所以i为0的位置需要初始化为0；</li><li>j为0：代表t字符串为空，此时s字符串可以删除所有元素形成一个空的子序列和t进行匹配，即j为0的位置都须初始化为1；</li><li>特殊情况：i和j都为0，此时就是空来匹配空，所以也是初始化为1；</li></ul><p>初始化也搞定了，直接遍历使用递推公式就OK啦！</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整代码如下，注意数组中元素需要使用无符号的64位整型，不然会出现计算溢出的情况。最后返回结果的时候需要按题目的要求进行取模。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">uint64_t</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                                     <span class="built_in">vector</span>&lt;<span class="type">uint64_t</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化，分为j=0还有i=0的情况，我们只需要手动处理j=0的情况；</span></span><br><span class="line">        <span class="comment">// 此时s不管多长都可以删除所有元素构成一个空字符串，所以结果应该是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; dp[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终dp数组右下角的就是结果，完整的t和完整的s</span></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/bb97eda7703e8a2b73bad2d58f1296e3.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-115.不同的子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】392.判断子序列</title>
    <link href="https://blog.musnow.top/posts/3529841087/"/>
    <id>https://blog.musnow.top/posts/3529841087/</id>
    <published>2024-06-09T01:44:27.000Z</published>
    <updated>2024-06-10T07:56:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-392.判断子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/is-subsequence/description/">https://leetcode.cn/problems/is-subsequence/description/</a></p></blockquote><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>进阶：</p><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= s.length &lt;= 100</span><br><span class="line">0 &lt;= t.length &lt;= 10^4</span><br><span class="line">两个字符串都只由小写字符组成。</span><br></pre></td></tr></table></figure><h1 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>还是用动态规划的思路，本题其实可以借鉴1143.最长公共子序列的思路，我们需要判断s是否为t的子序列，本质上就是判断s和t是否有公共子序列，且s本身就是s和t的<strong>最长公共子序列</strong>。</p><p>首先是定义dp数组，用一个二维数组来表示：<code>dp[i][j]</code>代表s字符串i-1和t字符串中j-1的公共子序列长度为<code>dp[i][j]</code>。因为是i-1和j-1，所以初始化的时候需要将长度加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>最终我们得到的<code>dp[s.size()][t.size()]</code>，就是s和t的公共子序列长度，这个长度应该等于s的长度，否则代表s不是t的子序列。</p><p>然后是定义递推公式，分为两种情况</p><ol><li><code>s[i-1]==t[j-1]</code>，代表子序列可以扩张，即<code>dp[i][j] = dp[i-1][j-1]+1</code>，含义是两个字符串中各上一位的公共子序列长度加一；</li><li><code>s[i-1]!=t[j-1]</code>，代表子序列不能扩张，此时应该沿用“上一次的结果”，注意这里和1143题目就有区别了，我们需要判断s是否为t的子序列，则只能从t中删除元素来匹配s，所以只能是 <code>dp[i][j] = dp[i][j-1]</code>；</li></ol><p>确定了递推公式，根据递推公式可知当前的<code>dp[i][j]</code>依赖于i-1和j-1，所以必须从小到大遍历进行推导。因为我们dp数组的含义使用了i-1和j-1，所以并不需要对dp数组的第0列和第0行进行单独初始化操作，构造函数里面统一初始化为全0就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s更长肯定不会是t的子序列</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j]表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 两种递推的情况</span></span><br><span class="line">        <span class="comment">//  1.当前s和t相等，代表相同子序列长度可以扩张 dp[i][j] = dp[i-1][j-1]+1;</span></span><br><span class="line">        <span class="comment">//  2.当前s和t不相等，相同子序列长度不可扩张，过渡于上一个</span></span><br><span class="line">        <span class="comment">//          如果是普通题目，“上一个”分为两种情况 dp[i-1][j] 和</span></span><br><span class="line">        <span class="comment">//          dp[i][j-1]</span></span><br><span class="line">        <span class="comment">//          但是本题判断s是否为t的子序列，所以我们不能从s中删除元素，只能从t中删除元素</span></span><br><span class="line">        <span class="comment">//          所以只能使用 dp[i][j-1]</span></span><br><span class="line">        <span class="comment">//          代表从t中删除一个元素（删除的其实就是当前元素j-1）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果t中包含s，那么最终得到的相同子序列长度应该是s.size()</span></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空间复杂度和时间复杂度是<code>O(N^2)</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/2ea2b927a49e150aa35d6332369980ed.png" alt="image.png"></p><h1 id="思路二：直接遍历"><a href="#思路二：直接遍历" class="headerlink" title="思路二：直接遍历"></a>思路二：直接遍历</h1><p>这道题限制的条件很简单，s是否为t的子序列本质上是s中的每个字符是否能按顺序的在t中出现。</p><p>那么我们只需要从头开始遍历t字符串，匹配上一个s中的字符后，就开始匹配下一个s中的字符，直到t字符串遍历完毕。</p><p>此时如果s字符串中已遍历的部分是s字符串的长度，那么就代表s是t的子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s必须长度小于等于t才有可能是t的子序列</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接遍历t字符串，判断s中的字符是否在t中按顺序出现了</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == s[index]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最终index是s的长度，代表s被完整遍历了，即s是t的子序列</span></span><br><span class="line">        <span class="keyword">return</span> index == s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空间复杂度是<code>O(1)</code>，时间复杂度是<code>O(N)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/945a691e0af70ee4b1fc56e2026a5ee7.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-392.判断子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】买卖股票的最佳时机（汇总篇）</title>
    <link href="https://blog.musnow.top/posts/3174951422/"/>
    <id>https://blog.musnow.top/posts/3174951422/</id>
    <published>2024-06-07T11:39:46.000Z</published>
    <updated>2024-06-07T11:39:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记，买卖股票的最佳时机，问题汇总。</p><h1 id="121-买卖股票的最佳时机1"><a href="#121-买卖股票的最佳时机1" class="headerlink" title="121.买卖股票的最佳时机1"></a>121.买卖股票的最佳时机1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></p></blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>暴力思路就是两层for循环，计算最大的差值，就是得到的最大利润</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">0</span>; <span class="comment">// 最大收益</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; prices.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                maxProfit = <span class="built_in">max</span>(maxProfit, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(N^2)</code>，会超时</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/234748c82c574033336617a9303c6960.png" alt="image.png"></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>贪心算法，思路是枚举当前数之前的最小值，计算当前数得到的利润的最大值。</p><ul><li>用一个元素来记录最小值，每一次遍历都更新这个最小值（最小的买入价格）</li><li>用一个元素来记录得到的最大利润，每一次遍历都更新最大利润（当前价格减去最小买入价格）</li></ul><p>首先更新的是最大利润，再更新最小买入价格，这样能保证最小买入价格的值一定是当前元素之前的某一个值，计算出来的最大利润才有效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">-1</span>;       <span class="comment">// 最大收益</span></span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>]; <span class="comment">// 当前的最小价格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : prices) &#123;</span><br><span class="line">            <span class="comment">// 当前值减去最小价格得到最大收益</span></span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit, i - minPrice);</span><br><span class="line">            <span class="comment">// 需要更新最小价格，保证最小价格是在当前值之前的某一个数</span></span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/cbde462eff228fcd0de5c1d883b59048.png" alt="image.png"></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划就要记住解题的几个步骤。</p><ul><li>确定动归数组每个下标的含义</li><li>确定迭代方程</li><li>确定初始值</li><li>确定遍历顺序</li><li>举例推导</li></ul><p>对于这道题而言，每天都有两种状态：今天持有股票和今天卖出股票。</p><p>我们可以设定<code>dp[i][0]</code>是第i天持有股票时的得到的最多钱，<code>dp[i][1]</code>是第i天不持有股票时得到的最多钱。很容易发现每天不持有股票得到的钱是更多的，所以最终的答案就是<code>dp[prices.size()-1][1]</code>，即这个二维数组的右下角。</p><p>这里就需要两个递推公式了，先看第i天持有股票的钱</p><ul><li>上一天就持有股票，即保持<code>dp[i-1][0]</code>不变；</li><li>今天才持有股票（买入），即<code>-price[i]</code>，本题股票只能买入一次，所以选择今天买入，那么剩下的钱就是0减去股票的价格；</li></ul><p>可得 <code>dp[i][0] = max(dp[i-1][0],-price[i])</code>，上两种情况的最大值。</p><p>第i天不持有股票的钱也分为两种情况</p><ul><li>上一天就没有持有股票，即保持<code>dp[i-1][1]</code>不变；</li><li>今天才卖出股票，即保持<code>price[i]+dp[i-1][0]</code>（因为今天卖出，所以上一天肯定是持有股票的）</li></ul><p>可得递推公式 <code>dp[i][1] = max(dp[i-1][1],price[i]+dp[i-1][0])</code>；</p><p>初始化dp数组时，第0天肯定只能持有股票，不能卖出，所以初始化如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>-price[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里还有另外一个优化方向，从递推公式中可以看出，每一天的值只和上一天有关系，那么并不需要一个完整的二维数组，只需要一个<code>2*2</code>的数组就可以了，我们把今天的值写入上一天就OK了，这样可以把空间复杂度降为<code>O(1)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="number">0</span>-prices[i], dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(prices[i] + dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 把当前值挪过去，作为上一行的结果</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/d7cce93225d5d8f2ea36a3a2379fce97.png" alt="image.png"></p><p>不过个人感觉这道题用动态规划来写实在是想不出来思路，而且还感觉很麻烦，还不如用贪心来处理一下。</p><h1 id="122-买卖股票的最佳时机2"><a href="#122-买卖股票的最佳时机2" class="headerlink" title="122.买卖股票的最佳时机2"></a>122.买卖股票的最佳时机2</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii</a></p></blockquote><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     总利润为 4 。</span><br><span class="line">     </span><br><span class="line">示例 3：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= prices.length &lt;= 3 * 104</span><br><span class="line">0 &lt;= prices[i] &lt;= 104</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>122题和121在<strong>动态规划</strong>上唯一的区别就是当天买入股票的时候，需要计算上一天卖出股票后能剩下的最多钱（因为同一天只能持有一张股票）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 1.今天买入股票的剩余钱需要计算上一天卖出后剩下的最多钱</span></span><br><span class="line">            <span class="comment">// 2.今天不买入，沿用上一天的结果</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>] - prices[i], dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 1.今天卖出股票，得到的钱是上一天买入股票剩余价值+今天卖出的价格</span></span><br><span class="line">            <span class="comment">// 2.今天不卖出股票，沿用上一天的结果</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(prices[i] + dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 把当前值挪过去，作为上一行的结果</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>122题在121的基础上新增了一个可以多次卖出+买入的操作。而121题只能买入一次+未来卖出一次。</p><p>因为每一天都可以买入+卖出，所以我们可以把利润拆分成每一天。只要某一天买入+明天卖出的利润是正数，那么就把他加入到最终结果中。这样就相当于排除亏钱的情况，只要能赚钱就买，即可计算出最大利润。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 122. 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment">// https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第0天买，第3天卖的利润是prices[3]-prices[0]</span></span><br><span class="line">        <span class="comment">// 也等于 p[3]-p[2] + p[2]-p[1] + p[1]-p[0]</span></span><br><span class="line">        <span class="comment">// 所以最大利润其实就是每天利润之和（前提是利润都是正的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 计算昨天买今天卖能获得多少利润</span></span><br><span class="line">            <span class="comment">// 如果大于0就加入进去</span></span><br><span class="line">            count += <span class="built_in">max</span>(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="123-买卖股票的最佳时机3"><a href="#123-买卖股票的最佳时机3" class="headerlink" title="123.买卖股票的最佳时机3"></a>123.买卖股票的最佳时机3</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/</a></p></blockquote><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">     </span><br><span class="line">示例 3：</span><br><span class="line">输入：prices = [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：prices = [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= prices.length &lt;= 105</span><br><span class="line">0 &lt;= prices[i] &lt;= 105</span><br></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>主要是需要列出可以购入两次一共会有多少种状态：</p><ol><li>当天不做操作；</li><li>当天继续持有股票（可以是新买股票，也可能是昨天就买入股票了）；</li><li>当天不继续持有股票；</li><li>当天第二次持有股票；</li><li>当天不持有第二次的股票；</li></ol><p>这五个状态已经包含了所有的情况，使用一个<code>dp[prices.size()][5]</code>的二维数组分别存放这五种情况的剩余钱的数量，我们要做的就是列出每一种状态的转移方程就可以了。</p><p>对于当天不做操作而言，啥事都不用干，所以<code>dp[i][0] = dp[i-1][0]</code>。</p><p>对于当天第一次持有股票，分为两种情况：</p><ul><li>这个股票是昨天留下来的（昨天就买了），对应的是<code>dp[i-1][1]</code>；</li><li>这个股票是今天刚买的，对应的是<code>dp[i-1][0] - prices[i]</code>，含义是昨天啥事没干的剩余余额减去当天股票的价格（买入）；</li></ul><p>因为我们最终需要的是最多能赚的钱，所以要用max来取二者最大值。</p><p>对于当天第一次不持有股票，也分为两种情况：</p><ul><li>昨天就不持有了，对应的是<code>dp[i-1][2]</code>；</li><li>昨天持有，今天卖出，对应的是<code>dp[i-1][0] + prices[i]</code>，含义是昨天买入股票的剩余余额加上当前股票的价格（今天卖出）；</li></ul><p>同样是用max来取二者的最大值。</p><p>对于第二次持有和不持有，都是用同样的方式分析的，得到的递推公式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 今天第二次购入股票（可能是本来就持有了第二次的股票，也可能是今天再买一次股票）</span></span><br><span class="line"><span class="comment">// 今天再买一次依赖于昨天卖出过了，所以是dp[i - 1][2]</span></span><br><span class="line">dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line"><span class="comment">// 今天不持有第二次的股票（可能是本来就不持有，也可能是把第二次购买的股票在今天卖掉）</span></span><br><span class="line"><span class="comment">// 1.这里使用dp[i-1][4]其实也可以理解为是当前买入后又卖出了（余额没有变化）</span></span><br><span class="line"><span class="comment">// 2.今天卖出依赖于昨天买入过第二次，所以是dp[i - 1][3]</span></span><br><span class="line">dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br></pre></td></tr></table></figure><p>有了状态转移方程，可以看到每一次都是依赖于<code>dp[i-1]</code>的情况，所以我们需要先对<code>dp[0]</code>进行初始化，再从下标1开始遍历整个数组。</p><p>对于第0天而言，我们只有两种选择，即当天买入一次股票，和当天买入第二次股票（我们买了第一次，卖掉，再买入第二次）</p><p>分别对应的是下面两个值，需要初始化为第0天股票的价格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第一次买入</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第二次买入</span></span><br></pre></td></tr></table></figure><p>因为第0天我们手头上是没钱的，所以买了股票之后余额就是负数了。</p><p>最终返回的最大值是最后一天第二次卖出的余额。因为只有第二次卖出，才</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是完整的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第一次买入</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第二次买入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 今天啥事不干</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 今天继续持有股票（可能是新买入，也可能是沿用之前啥事不干+买入股票的状态）</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 今天不持有股票（可能是本来就没有持有，也可以能是卖出了昨天买的股票）</span></span><br><span class="line">            <span class="comment">// 今天不持有前提是昨天买入过，所以是dp[i - 1][1]</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 今天第二次购入股票（可能是本来就持有了第二次的股票，也可能是今天再买一次股票）</span></span><br><span class="line">            <span class="comment">// 今天再买一次依赖于昨天卖出过了，所以是dp[i - 1][2]</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 今天不持有第二次的股票（可能是本来就不持有，也可能是把第二次购买的股票在今天卖掉）</span></span><br><span class="line">            <span class="comment">// 1.这里使用dp[i-1][4]其实也可以理解为是当前买入后又卖出了（余额没有变化）</span></span><br><span class="line">            <span class="comment">// 2.今天卖出依赖于昨天买入过第二次，所以是dp[i - 1][3]</span></span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终得到的获利值，一定是最后一天的第二次不持有是最多的</span></span><br><span class="line">        <span class="comment">// 因为买卖两次赚的钱肯定会比买卖一次多（亏钱还买啊？）</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(N)</code>，空间复杂度是<code>O(N)</code>。注意空间复杂度是<code>O(5*N)</code>，我们二维数组的每一行长度是固定的，所以空间复杂度并不是<code>N^2</code>！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/3202d8583ed32312ca76e94123c1e3ca.png" alt="image.png"></p><h2 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h2><p>因为每一次遍历其实只和<code>i-1</code>有关系，其实我们可以把这个二维数组给压缩成<code>dp[2][5]</code>，只不过每次操作之后都须需要把当前的结果<code>dp[1]</code>给复制到<code>dp[0]</code>去作为下一次的操作依赖。</p><p>这样做能将空间复杂度降到<code>O(1)</code>，因为我们的数组长度是固定值。代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第一次买入</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第二次买入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 今天啥事不干</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 今天继续持有股票（可能是新买入，也可能是沿用之前啥事不干+买入股票的状态）</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 今天不持有股票（可能是本来就没有持有，也可以能是卖出了昨天买的股票）</span></span><br><span class="line">            <span class="comment">// 今天不持有前提是昨天买入过，所以是dp[0][1]</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">2</span>], dp[<span class="number">0</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 今天第二次购入股票（可能是本来就持有了第二次的股票，也可能是今天再买一次股票）</span></span><br><span class="line">            <span class="comment">// 今天再买一次依赖于昨天卖出过了，所以是dp[0][2]</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">3</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">3</span>], dp[<span class="number">0</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 今天不持有第二次的股票（可能是本来就不持有，也可能是把第二次购买的股票在今天卖掉）</span></span><br><span class="line">            <span class="comment">// 1.这里使用dp[i-1][4]其实也可以理解为是当前买入后又卖出了（余额没有变化）</span></span><br><span class="line">            <span class="comment">// 2.今天卖出依赖于昨天买入过第二次，所以是dp[0][3]</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">4</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">4</span>], dp[<span class="number">0</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将今天的情况赋值给昨天，留给下一次循环用</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">3</span>] = dp[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">4</span>] = dp[<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终得到的获利值，一定是最后一天的第二次不持有是最多的</span></span><br><span class="line">        <span class="comment">// 因为买卖两次赚的钱肯定会比买卖一次多（亏钱还买啊？）</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/55b06e5ee9ea90e3cfc967a28ecf73d6.png" alt="image.png"></p><p>leetcode官方题解给的是一个将二维数组压成一维的空间压缩方式，但是那个方式非常不好理解，我个人感觉学会第一种思路就够了。</p><h1 id="188-买卖股票的最佳时机4"><a href="#188-买卖股票的最佳时机4" class="headerlink" title="188.买卖股票的最佳时机4"></a>188.买卖股票的最佳时机4</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/</a></p></blockquote><p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= k &lt;= 100</span><br><span class="line">1 &lt;= prices.length &lt;= 1000</span><br><span class="line">0 &lt;= prices[i] &lt;= 1000</span><br></pre></td></tr></table></figure><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这道题其实就是123题目的变体，在123题目中我们是可以交易两次，本题就是将这个2改成了k。所以我们只需要将123题目中的思路改成k个就可以了。</p><p>当k为2的时候，一共有5个情况；当k为3的时候，一共有7种情况，多出来的是第三次持有和第三次不持有；同理，当k为未知数的时候，可得情况总数是<code>2*k+1</code>；</p><ul><li>当i为奇数的时候，代表第<code>i/2+1</code>次持有；</li><li>当i为偶数的时候，代表第<code>i/2</code>次不持有；</li></ul><p>观察123题目的状态转移方程，能很明显的发现每一层其实都依赖于前一种情况，也就是二维数组中的前一列。根据此，只需要上一个内层的循环去遍历情况，就能递推出最终最大的利润值。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当k==2的时候一共有五种状态，状态总数是2k+1</span></span><br><span class="line">        <span class="comment">// 除了第一个状态（下标0）的时候是啥事不干</span></span><br><span class="line">        <span class="comment">// 其余的状态奇数是当前第n次持有，偶数是当前第n次持有</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k * <span class="number">2</span> + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 遍历，将奇数都初始化为当前买入的初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前的第n次买入</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始完整遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 当天啥事不干</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 开始遍历k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; dp[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 奇数，买入</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 偶数，卖出</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个肯定是最大钱的时候</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/492f26bea3eddc063ec05d7b6219b294.png" alt="image.png"></p><h1 id="309-买卖股票的最佳时机含冷冻期"><a href="#309-买卖股票的最佳时机含冷冻期" class="headerlink" title="309.买卖股票的最佳时机含冷冻期"></a>309.买卖股票的最佳时机含冷冻期</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/</a></p></blockquote><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: prices = [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: prices = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= prices.length &lt;= 5000</span><br><span class="line">0 &lt;= prices[i] &lt;= 1000</span><br></pre></td></tr></table></figure><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这道题还是需要把所有状态给列出来，然后再列出每个状态对应的相关状态。</p><p>首先要明确冷冻期的概念：卖出股票的第二天不能买入股票。但没有说买入股票的第二天不能卖出。即冷冻期只对卖出股票有效。</p><p>那么每一天的状态就会有四种情况，同样是用二维dp数组来对应每一种情况：</p><ol start="0"><li>今天持有股票（今天买入或者保持持有状态）；</li><li>今天不持有股票（今天卖出股票）；</li><li>今天不持有股票（昨天甚至前天就已经卖了）；</li><li>今天是冷冻期，啥事干不了；</li></ol><p>这里相比188题目省略了“当天啥事不干”的状态，因为这个状态没有必要记录，一直都是0。</p><p>下面要做的就是分析出这四种状态的转移方程。</p><p>今天持有股票的情况，分为<strong>今天买入</strong>和<strong>保持持有</strong>的状态，转移方程如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 今天持有股票，要么是昨天就买了，要么是今天才买</span></span><br><span class="line"><span class="comment">// 昨天就已经持有的情况是沿用过去的状态dp[i-1][0]</span></span><br><span class="line"><span class="comment">// 今天才买的情况一是昨天保持卖出股票的情况</span></span><br><span class="line"><span class="comment">// 还有一种情况是昨天是冷冻期，那么我们今天买股票要用的是冷冻期状态的钱</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],</span><br><span class="line"><span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">3</span>] - prices[i]));</span><br></pre></td></tr></table></figure><p>今天卖出股票的情况，只有一种，那就是昨天持有+今天卖出股票的价格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i];</span><br></pre></td></tr></table></figure><p>昨天甚至前几天就不持有股票了，就有很多种情况；比如昨天是冷冻期，或前天就卖出了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 昨天是冷冻期</span></span><br><span class="line"><span class="comment">// 前天就卖出了，还没有买入，维持不持有的状态</span></span><br><span class="line">dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>今天是冷冻期，说明昨天肯定是卖出股票了，不会有其他情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">3</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>状态转移方程确定了，下面要处理的就是如何进行初始化了。因为我们状态转移方程是依赖于<code>i-1</code>的，所以肯定是从左往右遍历，且需要提前初始化下标0的数据。</p><p>还是比较好想的，第一天其实只有当前买入的情况，其他买入+卖出，还是冷冻期的情况都是0（第一天不可能是冷冻期），所以只需要初试化<code>dp[i][0] = 0 - prices[0]</code>就可以了。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一共有4种状态</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 今天持有股票，要么是昨天就买了，要么是今天才买</span></span><br><span class="line">            <span class="comment">// 昨天就已经持有的情况是沿用过去的状态dp[i-1][0]</span></span><br><span class="line">            <span class="comment">// 今天才买的情况一是昨天保持卖出股票的情况</span></span><br><span class="line">            <span class="comment">// 还有一种情况是昨天是冷冻期，那么我们今天买股票要用的是冷冻期状态的钱</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i],</span><br><span class="line">                                             dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i]));</span><br><span class="line">            <span class="comment">// 今天卖出，代表昨天是持有股票的情况</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            <span class="comment">// 昨天是冷冻期</span></span><br><span class="line">            <span class="comment">// 前天就卖出了，还没有买入，维持不持有的状态</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// 冷冻期只可能是昨天卖出股票了</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大值只会出现后三种情况中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">                   <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/cdb7253b64e2ff9376d6caf3d26a5b6b.png" alt="image.png"></p><h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/</a></p></blockquote><p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,3,7,5,10,3], fee = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= prices.length &lt;= 5 * 104</span><br><span class="line">1 &lt;= prices[i] &lt; 5 * 104</span><br><span class="line">0 &lt;= fee &lt; 5 * 104</span><br></pre></td></tr></table></figure><h2 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h2><p>这道题其实是122的翻版，交易的时候多加一个手续费就行了。一次交易（买入+卖出）只需要交一次手续费，我们统一在卖股票的时候交手续费就ok了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 第一天持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 1.今天买入</span></span><br><span class="line">            <span class="comment">// 2.昨天开始就持有了</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 1.今天卖出（需要交手续费）</span></span><br><span class="line">            <span class="comment">// 2.昨天开始就不持有了</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">            <span class="comment">// 把今天的数值挪过昨天去</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/0106306417bd055562a62818aa51d846.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>你学废了吗？</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记，买卖股票的最佳时机，问题汇总</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1035.不相交的线</title>
    <link href="https://blog.musnow.top/posts/842071863/"/>
    <id>https://blog.musnow.top/posts/842071863/</id>
    <published>2024-06-06T09:20:18.000Z</published>
    <updated>2024-06-06T10:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-1035.不相交的线</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1[i] == nums2[j]</span><br><span class="line">且绘制的直线不与任何其他连线（非水平线）相交。</span><br></pre></td></tr></table></figure><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums1 = [1,4,2], nums2 = [1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/5ef7bc2f78a834585ebf4fe54086b37f.png" alt="image.png"></p><p><strong>提示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums1.length, nums2.length &lt;= 500</span><br><span class="line">1 &lt;= nums1[i], nums2[j] &lt;= 2000</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题乍一看好像没有什么好的办法，但是多举几个例子，就能发现它本质上问的是这两个数组的<a href="https://blog.musnow.top/posts/1438517746">最长公共子序列</a>。因为只要我们不修改画线的元素在原始数组中的相对位置，那么画出来的线就不会出现交叉，最长公共子序列就符合这个特性，这也是这道题真正询问的点！</p><p>来复盘一下最长公共子序列的思路吧，最长公共子序列这个题目非常重要，会被其他很多相似的题目引用。最好是能理解并记忆下来。</p><p>首先是dp数组的含义，我们定义了二维dp数组，含义是<code>a[i]</code>和<code>b[j]</code>这两个元素（包括他们自己）之前的最长公共子序列的长度。</p><p>递推的情况则是<code>a[i]</code>和<code>b[j]</code>相等的时候，<code>dp[i][j] = dp[i-1][j-1] + 1</code>；其他情况代表最长公共子序列没有被扩张，则需要采用“前一位”的最大值，分别是i-1（j不变）和j-1（i不变）的两种情况。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整代码如下，另外的办法可以参考最长公共子序列的题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化，第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums2[j] == nums1[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/1492d042fac783c1128fafe7b24c03ce.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-1035.不相交的线</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】516.最长回文子序列</title>
    <link href="https://blog.musnow.top/posts/2092587888/"/>
    <id>https://blog.musnow.top/posts/2092587888/</id>
    <published>2024-06-04T02:34:54.000Z</published>
    <updated>2024-06-04T04:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-516.最长回文子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p></blockquote><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 1000</span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><h1 id="思路1：最长公共子序列"><a href="#思路1：最长公共子序列" class="headerlink" title="思路1：最长公共子序列"></a>思路1：最长公共子序列</h1><p>这道题可以直接使用<a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143.最长公共子序列</a>的代码，只要把原始字符串反转一下，就变成了两个字符串中求最长公共子序列的问题了。</p><p>对于回文子序列来说，<strong>字符串翻转过后也一定和原有的回文子序列相同</strong>，所以将原始字符串翻转后就能通过最长公共子序列找到最长的回文子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// i为0和j为0的情况下，长度为0的字符串是不会有公共子序列的，所以可以全部初始化为0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 判断 a[i-1] == b[j-1] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string b = s;</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">longestCommonSubsequence</span>(s, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整体的时间复杂度和空间复杂度都是<code>O(N^2)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/b45b953cefb2b16cca25cc24ef99c8c9.png" alt="image.png"></p><h1 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有了用之前写过的题目的思路，下面还是得想一个直接写这道题的思路。总不能回避问题嘛。</p><p>因为回文的结构一般都是要从字符串中心开始向两次扩张来判断的，本题中只有一个字符串，所以不要和之前写的其他题目搞混了。</p><ul><li><code>dp[i][j]</code>代表字符串s中<code>[i,j]</code>范围内的最长回文子序列的长度。</li></ul><p>因为单个字符也可以认为是回文子序列，<strong>所以当i等于j的时候，初始化为1</strong>。对于这个dp数组，我们只需要关注<code>i&lt;j</code>的情况，所以<code>i&gt;j</code>的位置都需要初始化为0。</p><p>这里可以沿用<a href="https://blog.musnow.top/posts/1161861455">5.最长回文子串</a>的思路，当i和j相等，回文子序列扩张的时候，最长的回文子序列的长度只能比<code>[i+1,j-1]</code>的范围多一对字符（即多两个字符）。</p><p>其他情况，因为本题求的是子序列，i和j不相等代表子序列不能被扩展，但dp数组的含义是<code>[i,j]</code>范围内的最长回文子序列的长度，所以当前的值依旧需要更新为“上一个结果”的值，对应本题也是在<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>中用max选最大值。</p><p>所以，递推代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个递推方程，<code>dp[i][j]</code>的依赖项是<code>dp[i+1][j-1]</code>、<code>dp[i+1][j]</code>、<code>dp[i][j-1]</code>，对于一个矩阵而言，是它的左下角的部分，如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/aec771ab871e6d1863313ce24aa511c8.png" alt="image.png"></p><p>根据依赖关系，我们遍历的时候，需要从i开始<strong>倒序遍历</strong>；因为依赖项中有<code>j-1</code>，所以j是<strong>正序遍历</strong>。</p><p>遍历顺序确定了，维护一个最大值，或者直接返回<code>dp[0][s.size()-1]</code>即为本题所求结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][j]代表s中[i,j]范围内最长公共子序列的长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// i和j相等的情况初始化为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// j 必须大于i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/7f13895038a74d9db8a418a82698f5c0.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-516.最长回文子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1143.最长公共子序列</title>
    <link href="https://blog.musnow.top/posts/1438517746/"/>
    <id>https://blog.musnow.top/posts/1438517746/</id>
    <published>2024-06-01T07:46:40.000Z</published>
    <updated>2024-06-06T10:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-1143.最长公共子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">https://leetcode.cn/problems/longest-common-subsequence/description/</a></p></blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= text1.length, text2.length &lt;= 1000</span><br><span class="line">text1 和 text2 仅由小写英文字符组成。</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题和<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组</a>的区别在于，718要求的是连续的子序列，而本题不要求子序列连续，就不是让你算子数组了。</p><p>虽然题目给出的是字符串，但本质上我们可以把它当作数组来处理，没有区别。</p><ul><li><code>dp[i][j]</code>代表字符串a中<code>i-1</code>和字符串b中<code>j-1</code>下标<strong>之前</strong>的最长公共子序列的长度。</li></ul><p>这样做就可以不对数组提前进行初始化了，因为<code>dp[0][x]</code>和<code>dp[x][0]</code>都是没有意义的。因为不会存在以下标<code>-1</code>为结尾的字符串，也自然没有公共子序列。换句话说，<strong>长度为0</strong>的字符串是不会有公共子序列的。</p><p>依照dp数组，可以想出递推的公式，当<code>a[i-1]</code>和<code>b[j-1]</code>相同的时候，就说明子序列可以被扩展，<code>dp[i][j] == dp[i-1][j-1]+1</code>。</p><p>如果不相同，则代表子序列断了，但注意我们dp数组的含义，它代表的是i-1和j-1之前的最长公共子序列的长度，即便i-1和j-1不相等，这个最长公共子序列依旧是有一个取值的，即选用“前一位”的公共子序列长度最大值。</p><p>但由于dp是一个二维数组，这里的“前一位”就有两个情况了，分别是<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>，对应含义是字符串a中前一位（根据dp数组，下标是i-1，公共子序列的含义是i-2）和<code>b[j-1]</code>能构成的最长公共子序列，以及字符串b中前一位和<code>a[i-1]</code>能构成的最长公共子序列的长度。<strong>需要用max来选取二者的最大值</strong>。</p><p>递推的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据递推公式，<code>dp[i][j]</code>的值可以从dp数组中的三个方向推导出来，如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/4796284855ff7814090f5f198e5eaedd.png" alt="image.png"></p><p>剩下的代码就很简单了，因为我们不需要对dp数组进行提前初始化，直接用vector构造函数统一初始化为0就可以了，然后从1开始遍历直到字符串末尾，维护一个最大值，返回即可。</p><p>其实不维护最大值也是可以的，因为根据dp数组的定义，<code>dp[a.size()][b.size()]</code>就是我们需要的最大值。</p><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><p>完整的代码如下，具体参考注释中的说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// i为0和j为0的情况下，长度为0的字符串是不会有公共子序列的，所以可以全部初始化为0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 判断 a[i-1] == b[j-1] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/fc86ae51ad0f984572360fc94f373acf.png"></p><h1 id="代码2：提前初始化"><a href="#代码2：提前初始化" class="headerlink" title="代码2：提前初始化"></a>代码2：提前初始化</h1><p>依照718题的思路，我们也可以写出一个提前初始化dp数组的代码，完整代码如下。</p><p>注意初始化的情况也有所不同，因为本题要求的是子序列，可以出现不连续的情况，即便<code>a[i] != b[0]</code>，我们也需要沿用之前<code>dp[i - 1][0]</code>的结果，来保证初始化是正确的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化，判断第一个字符是否有相同的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[j] == a[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断 a[i] == b[j] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/59e2de13c184a74ed1a3f938e5875d64.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-1143.最长公共子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】718. 最长重复子数组</title>
    <link href="https://blog.musnow.top/posts/1636801435/"/>
    <id>https://blog.musnow.top/posts/1636801435/</id>
    <published>2024-05-31T07:22:41.000Z</published>
    <updated>2024-06-04T02:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-718. 最长重复子数组</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/</a></p></blockquote><p>给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums1.length, nums2.length &lt;= 1000</span><br><span class="line">0 &lt;= nums1[i], nums2[i] &lt;= 100</span><br></pre></td></tr></table></figure><p>子数组其实就是连续的子序列。</p><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>依旧是用动态规划的思路，dp数组肯定需要一个二维的了，之前写过最长递增子序列，当时用的dp数组下标的含义是以j下标为结尾的最长递增子序列的长度。本题也是一样的思路</p><ul><li><code>dp[i][j]</code>代表数组1中以i结尾，数组2中以j结尾的最长公共子数组的长度（包括i和j）；</li></ul><p>根据这个定义，可以推算出递推公式，当 <code>nums1[i] == nums2[j]</code> 的时候，说明子数组可以被扩张，此时<code>dp[i][j] = dp[i-1][j-1] +1</code>，含义是当前的最长公共子数组的长度是前一位的最长公共子数组的长度加一（加上当前位）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums1[i] == nums2[j]) &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要对这个dp数组进行初始化，需要初始化第一列和第一行，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="comment">// 第一个数组中的元素是否在第二个数组中第一位</span></span><br><span class="line"><span class="comment">// 在第一位说明最长公共子数组长度是1</span></span><br><span class="line"><span class="keyword">if</span> (nums1[i] == nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="comment">// 第一个数组中的元素是否在第二个数组中第一位</span></span><br><span class="line"><span class="comment">// 在第一位说明最长公共子数组长度是1</span></span><br><span class="line"><span class="keyword">if</span> (nums2[j] == nums1[<span class="number">0</span>]) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>随后就是i和j都从1开始遍历了，更新出一个最大值返回就可以了。完整代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DP 以i和j结尾的元素最长的子数组的长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 我们要对第一行和第一列进行初始化</span></span><br><span class="line">        <span class="comment">// 判断第二个数组中是否出现了第一个数组中的元素，出现了就算是公共子数组</span></span><br><span class="line">        <span class="type">bool</span> contains = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 第一个数组中的元素是否在第二个数组中第一位</span></span><br><span class="line">            <span class="comment">// 在第一位说明最长公共子数组长度是1</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                contains = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 第一个数组中的元素是否在第二个数组中第一位</span></span><br><span class="line">            <span class="comment">// 在第一位说明最长公共子数组长度是1</span></span><br><span class="line">            <span class="keyword">if</span> (nums2[j] == nums1[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                contains = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result =</span><br><span class="line">            contains</span><br><span class="line">                ? <span class="number">1</span></span><br><span class="line">                : <span class="number">0</span>; <span class="comment">// 如果之前初始化的时候有相同的，那么就设置为1，没有就设置为0</span></span><br><span class="line">        <span class="comment">// 开始遍历，递推思路：如果当前两位相等，那么最长子数组长度就是前一位的子数组长度+1</span></span><br><span class="line">        <span class="comment">// 相当于是以i-1和j-1结尾的最长公共子数组的长度+1</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度和空间复杂度都是<code>O(N^2)</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/a85f5e59980b419decd2d827832105a8.png" alt="image.png"></p><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>上文的思路中，dp数组下标的含义是以i和j结尾的最长公共子序列的长度。我们可以将其改成<code>dp[i][j]</code>代表以i-1和j-1结尾的最长重复子数组的长度。</p><p>这样做就可以不对数组提前进行初始化了，因为<code>dp[0][x]</code> 和<code>dp[x][0]</code>都是没有意义的。</p><p>基本思路都是一致的，只不过递推方程的判断改为判断<code>nums1[i-1] == nums2[j-1]</code>了，另外dp数组的长度也需要加一。</p><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DP 以i和j结尾的元素最长的子数组的长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                               <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 开始遍历，递推思路：如果i,j前两位相等，那么最长子数组长度就是前一位的子数组长度+1</span></span><br><span class="line">        <span class="comment">// 相当于是以i-1和j-1结尾的最长公共子数组的长度+1</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/220747fbd31883d92fa3f5e74dbe2ced.png" alt="image.png"></p><h2 id="压缩为一维数组"><a href="#压缩为一维数组" class="headerlink" title="压缩为一维数组"></a>压缩为一维数组</h2><p>这道题中的dp递推方程每次都只和<code>[i-1][j-1]</code>有关系，所以可以将二维数组直接压缩为一维，倒叙遍历j就可以沿用上一层dp的结果了，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DP 以i和j结尾的元素最长的子数组的长度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 开始遍历，递推思路：如果i,j前两位相等，那么最长子数组长度就是前一位的子数组长度+1</span></span><br><span class="line">        <span class="comment">// 相当于是以i-1和j-1结尾的最长公共子数组的长度+1</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意这里是从1遍历到=nums1.size()的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = nums2.<span class="built_in">size</span>(); j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不相等需要把这一位设置为初始值（就好比二维矩阵中的初始值）</span></span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt; result) &#123;</span><br><span class="line">                    result = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/c17dc641583ca7e326b0467e6c992d7f.png" alt="image.png"></p><h1 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h1><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h2><p>这道题要求是最长的公共子序列，就不是让你算子数组了。虽然题目给出的是字符串，但本质上我们可以把它当作数组来处理，没有区别。</p><p>完整的代码如下，采用的是思路2，具体参考注释中的说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// i为0和j为0的情况下，长度为0的字符串是不会有公共子序列的，所以可以全部初始化为0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 判断 a[i-1] == b[j-1] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/fc86ae51ad0f984572360fc94f373acf.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-718. 最长重复子数组</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】674.最长连续递增序列</title>
    <link href="https://blog.musnow.top/posts/3365284395/"/>
    <id>https://blog.musnow.top/posts/3365284395/</id>
    <published>2024-05-30T02:10:25.000Z</published>
    <updated>2024-05-30T02:38:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-674.最长连续递增序列。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</a></p></blockquote><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,5,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [2,2,2,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 104</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br></pre></td></tr></table></figure><h1 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h1><p>这道题相比<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300.最长递增子序列</a>多了一个连续的要求，这样一来思路其实就简单多了。</p><p>定义dp数组含义为i和i之前的最长递增子序列的长度（准确来说是以i为结尾的最长递增子序列的长度，子序列开始的下标不确定）</p><p>我们只需要判断当前位是不是比前一位大，如果比前一位大，那么就可以沿用之前的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能很容易的写出代码来，时间和空间复杂度都是<code>O(N)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>; <span class="comment">// 结果长度</span></span><br><span class="line">        <span class="comment">// 最开始的时候，每一位的最长子序列认为是它自己</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从1开始遍历，因为0只有一个元素，没有意义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 因为要求连续，所以只需要判断前一位就够了。</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新结果最大值</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; ret) &#123;</span><br><span class="line">                ret = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/213cf8eb8a3a43d87cf44919809169c1.png" alt="image.png"></p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>这个代码可以进行优化，因为每一次的递推只和前一个数字有关系，我们直接用一个变量来记录就够了，空间复杂度降低为<code>O(1)</code>。</p><p>这样做就有点类似<strong>贪心</strong>的思路，我们认为当前位大于前一位就是一个上升子序列的局部最优，最终的全局最优就是找到一个最长的连续上升子序列。官方的贪心题解本质上和下面的写法是一样的思路。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>; <span class="comment">// 结果长度</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>; <span class="comment">// 当前的长度</span></span><br><span class="line">        <span class="comment">// 从1开始遍历，因为0只有一个元素，没有意义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 因为要求连续，所以只需要判断前一位就够了。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                cur = cur + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = <span class="number">1</span>; <span class="comment">// 其他情况，重置为1，重新开始计算</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新结果最大值</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; ret) &#123;</span><br><span class="line">                ret = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/3b3aa2b543bf4840c1b1a11273eb50f2.png" alt="image.png"></p><p>顺带贴一下官方题解的贪心代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：力扣官方题解</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence/solutions/573383/zui-chang-lian-xu-di-zeng-xu-lie-by-leet-dmb8/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-674.最长连续递增序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】300.最长递增子序列</title>
    <link href="https://blog.musnow.top/posts/3118298969/"/>
    <id>https://blog.musnow.top/posts/3118298969/</id>
    <published>2024-05-30T01:32:50.000Z</published>
    <updated>2024-05-30T02:09:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-300.最长递增子序列。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">https://leetcode.cn/problems/longest-increasing-subsequence/description/</a></p></blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 2500</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先理解题目说的两个概念</p><ol><li>严格递增：<code>[1,2,3,4]</code>是严格递增，<code>[1,2,2,3]</code>不是严格递增；</li><li>子序列：数组中的一部分，删除某些元素后得到的序列，比如<code>[1,2,3]</code>数组，删除2后可以得到子序列<code>1,3</code>，也可以不删除元素<code>1,2,3</code>也是它的子序列。但是<code>3,1</code>或者<code>2,1</code>都不是这个数组的子序列，因为元素的顺序和源数组中元素的顺序不一致；</li></ol><p>了解定义了，就可以上动态规划的思路了。</p><p>我们定义dp数组的含义为源数组中下标i和i之前的最长递增子序列的长度（这一点和第五题最长回文子串的思路类似）。易得dp数组应该全部初始化为1，即认为最开始的时候，每一位之前的最长递增子序列是他自己。</p><p>那么递推方程应该是咋样的呢？分为两种情况</p><ul><li>当前位元素大于前一位，那么当前的最长子序列长度应该是前一位的最长子序列长度+1；</li><li>当前位元素小于前一位，说明不能沿用之前的结果，当前的最长子序列长度得保持不变；</li></ul><p>可得递推公式<code>dp[i] = max(dp[i], dp[j] + 1)</code>，判断逻辑如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line"><span class="comment">// 大于，沿用之前的结果</span></span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i],dp[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 小于或者等于，不对dp[i]操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样判断还不够，因为子序列是允许删除某些元素的，对于遍历一个数组而言，<strong>它就是允许遍历不连续</strong>，所以我们需要用两层循环来处理，外层循环i从1开始遍历nums数组（从0开始没有意义），内层循环j从0开始遍历到i-1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line"><span class="comment">// 大于，沿用之前的结果</span></span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 小于或者等于，不对dp[i]操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我们需要用max来计算呢？因为每一次对i的递推都需要遍历i之前的所有元素才能递推出来，可能会出现前面某一位的最长递增子序列结果更大的情况，我们必须要保证得到的是最长的那一个子序列值。</p><p>同时，我们的遍历是从左往右的，当遍历到i的时候，i之前的那些元素在dp里面已经被正常计算出来最长的子序列长度了，所以我们只需要判断一次<code>nums[i] &gt; nums[j]</code>，就可以沿用之前的结果了。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>现在就可以写最终的代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>;<span class="comment">// 结果长度</span></span><br><span class="line">        <span class="comment">// 最开始的时候，每一位的最长子序列认为是它自己</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从1开始遍历，因为0只有一个元素，没有意义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="comment">// 大于，沿用之前的结果</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新结果最大值</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; ret)&#123;</span><br><span class="line">                ret = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(n^2)</code>，空间复杂度是<code>O(n)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/c1bf520c0b26f08b2835e7c311cfb071.png" alt="image.png"></p><p>和这道题类似的是 <a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/">674. 最长连续递增序列</a>，其中要求子序列必须是连续的，中间不能中断。我会在另外一篇博客中写674的题解。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-300.最长递增子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】5.最长回文子串</title>
    <link href="https://blog.musnow.top/posts/1161861455/"/>
    <id>https://blog.musnow.top/posts/1161861455/</id>
    <published>2024-05-28T01:16:43.000Z</published>
    <updated>2024-05-30T01:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-5.最长回文子串。这么经典的题目我竟然现在才刷，懒虫一个。</p><blockquote><p>参考：<a href="https://writings.sh/post/algorithm-longest-palindromic-substring">https://writings.sh/post/algorithm-longest-palindromic-substring</a></p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">https://leetcode.cn/problems/longest-palindromic-substring/description/</a></p></blockquote><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>回文字符串：从前往后和从后往前读的结果完全一致，比如aba；</p><p>子串：字符串s中的一部分称之为子串。与之区别的是<code>子序列</code>，子序列是不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 1000</span><br><span class="line">s 仅由数字和英文字母组成</span><br></pre></td></tr></table></figure><h1 id="思路一：暴力-O-N-3"><a href="#思路一：暴力-O-N-3" class="headerlink" title="思路一：暴力 O(N^3)"></a>思路一：暴力 O(N^3)</h1><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>最蠢的办法就是直接暴力了，一个函数判断是否是回文，再用双层循环来枚举所有子串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReverseString</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个也算回文</span></span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        string ret;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 再去找其他的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isReverseString</span>(s, i, j)) &#123;</span><br><span class="line">                    <span class="type">int</span> len = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">if</span> (len &gt; maxLength) &#123;</span><br><span class="line">                        maxLength = len;</span><br><span class="line">                        ret = s.<span class="built_in">substr</span>(i, len);</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于本题而言，也能通过，但很明显耗时太长了，这是一个<code>O(N^3)</code>时间复杂度的暴力算法。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/d782bfddd37df1f5e5c3c81f43e1d309.png" alt="image.png"></p><h2 id="一定优化"><a href="#一定优化" class="headerlink" title="一定优化"></a>一定优化</h2><p>其实这个暴力求解法也有可优化的地方，即内层循环的枚举我们可以用maxLength进行枚举，j的初始值是<code>i+maxLength</code>，<strong>这样每一次枚举都是比上一次更长的字符串</strong>，得到回文子串后也不需要判断长度是否大于maxLength了，能减少很多次遍历。</p><p>且在当前的写法中，每次得到一个结果，我们都调用了一次substr函数，这个函数也是<code>O(N)</code>的时间复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = s.substr(i, len);</span><br></pre></td></tr></table></figure><p>我们可以将其改成记录结果字符串的起始下标和长度，在最终才调用substr函数来构造返回字符串，这样也能减少一定的时间复杂度。</p><p>优化后的代码如下，注意maxLength必须初始化为1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReverseString</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个也算回文</span></span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>,length = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 再去找其他的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + maxLength; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isReverseString</span>(s, i, j)) &#123;</span><br><span class="line">                    <span class="type">int</span> len = j - i + <span class="number">1</span>;</span><br><span class="line">                    maxLength = len;</span><br><span class="line">                    begin = i;</span><br><span class="line">                    length = len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后才构造结果字符串</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多次提交测试，平均耗时都是之前1000ms的十分之一了，还是有不少提升的，但是时间复杂度依旧不变，还是<code>O(N^3)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/d843f12ea8c4c90df9af20813735bf7f.png" alt="image.png"></p><h1 id="思路二：动态规划-O-N-2"><a href="#思路二：动态规划-O-N-2" class="headerlink" title="思路二：动态规划 O(N^2)"></a>思路二：动态规划 O(N^2)</h1><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>首先我们要知道，如果一个字符串是回文子串，那么它的中间一部分也一定是个回文子串。比如<code>ABCBA</code>的中间部分<code>BCB</code>也是一个回文子串。</p><p>这样我们就可以得出一个二维的dp数组，数组的下标<code>(i,j)</code>代表s字符串中，从i到j的这个字符串是一个回文子串。且i大于j的情况是不合法的。</p><p>这样我们就能省去很多的判断步骤，如果<code>dp[i][j]=true</code>，那么只需要判断i-1和j+1是否相等，就可以知道<code>(i-1,j+1)</code>这个范围是不是一个回文子串了。递推公式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j-1] &amp;&amp; (s[i] == s[j])</span><br></pre></td></tr></table></figure><p>那么dp数组要怎么遍历呢？从递归公式中可知，当前状态<code>i,j</code>依赖于<code>i+1,j-1</code>，即依赖于当前元素<strong>右上角</strong>的哪一个。所以，<strong>我们需要先遍历列j，再遍历行i</strong>。</p><blockquote><p>在别的题解中你可能看到大家谈论的是<code>左下角</code>，这是因为矩阵的<strong>坐标系原点</strong>选择不同，我个人比较喜欢选左上角作为原点，然后往左是i下标，往下是j下标。</p></blockquote><p>由下图可知，当我们需要知道<code>(1,2)</code>这个下标位置的结果是多少的时候，我们需要先把<code>(0,3)</code>给搞出来，所以应该让j作为外层循环开始遍历，这样才能保证遍历到某一个位置的时候，依赖项已经更新完成了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/26489357a33a0603d07abd6219fa3b1a.png" alt="image.png"></p><p>继续确定dp数组的初始值，我们可以知道长度为1的时候肯定是个回文子串，即所有i和j相等的位置都可以初始化为true。长度为2的时候是否为子串需要进行判断，两个字符相同就是个回文子串。</p><p>现在就可以写代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始dp数组，[i][j]代表下标i到j是回文串</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 一个字符的时候肯定是true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录结果字符的起始位置</span></span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 需要先遍历列j在遍历行i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// i大于j的情况不合法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="comment">// 两个字符相等是回文</span></span><br><span class="line">                <span class="keyword">if</span> (j == i + <span class="number">1</span> &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 依赖于右上角，注意i+1不能超过j-1</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= j - <span class="number">1</span> &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="literal">true</span> &amp;&amp;</span><br><span class="line">                         s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前是回文，更新最大值</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == <span class="literal">true</span> &amp;&amp; maxLength &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                    maxLength = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码的时间复杂度和空间复杂度都是<code>O(N^2)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/88a11eede2eeffa0540a837253b3bbbd.png" alt="image.png"></p><p>建议根据代码的遍历顺序画个矩阵，更方便理解。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>使用一维数组，就可以降低一层空间复杂度。对应的思路也需要改变。</p><ul><li>数组中<code>dp[j]</code>的值是下标j和j之前的最大回文子串的起始下标i；</li><li>易得初始值<code>dp[0] = 0</code>；</li></ul><p>举例字符串<code>aabba</code>对应的dp数组，第一个a的最大回文子串起始地址是他自己，也就是0；第二个a之前的最大回文子串是aa，所以起始地址是0；第三个b之前的最大回文子串是它自己，因为aab不构成回文子串；第四个b之前的最大回文子串是bb，起始地址下标是2；最后一个a的最大回文子串是abba，起始下标是1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a  a  b  b  a</span><br><span class="line">0  0  2  2  1</span><br></pre></td></tr></table></figure><p>另外我们需要知道每一位的递推值是怎么的来的。依照上面这个dp数组，假设我们需要递推最后一位a（下标为4）的dp值，那么应该是前一位b（下标为3）的<strong>最长子串起始下标的前一位</strong>是否和当前位相等，即判断<code>s[i]==s[dp[i-1]-1]</code>。</p><p><strong>如果二者相等</strong>，则说明这个回文子串还可以被扩展，此时<code>dp[i]</code>等于<code>dp[i-1]-1</code>，子串长度是<code>i-(dp[i-1]-1)+1</code>。对于当前这个例子，<code>dp[4]=1</code>，回文子串长度是<code>4-1+1=4</code>。</p><blockquote><p>这里还有另外一个结论，即当前位i组成的最长回文子串长度一定只会比i-1能组成的最长回文子串长度多两个字符（即i-1能组成的最长回文子串左右各多一个字符）。</p></blockquote><p><strong>如果不相等</strong>，说明前一位的回文子串不能被扩展，但这并不代表当前位并不能组成回文子串了。如下图所示，虽然当前j和前一位j-1的回文子串不能继续扩展，但它依旧有一个长度为3的回文子串。这时候就需要从j之前通过遍历来判断是否有回文子串了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/1d494a61b864199c5ed4b42618789b25.png" alt="image.png"></p><p>不过我们并不需要从0开始遍历，只需要从<code>dp[j-1]</code>开始遍历就可以了（即上图中下标为3的字母c开始）。前文说了，<strong>当前位i组成的最长回文子串长度一定只会比i-1能组成的最长回文子串长度多两个字符</strong>，不可能会有<code>dp[j-1]-1</code>之前到j能组成的回文串，而<code>(dp[j-1]-1,j)</code>这个子串我们已经在前面的条件中判断过不是回文了。</p><p>思路解决了，就可以写代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 下标为0只能和自己组成回文串</span></span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意j要从1开始，因为0已经被初始化过了，而且我们需要访问j-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[j] == s[dp[j - <span class="number">1</span>] - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 从左向右找</span></span><br><span class="line">                <span class="type">int</span> left = dp[j - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> right = j;</span><br><span class="line">                <span class="type">int</span> start = left; <span class="comment">// 记录回文子串查找的起始位置</span></span><br><span class="line">                <span class="comment">// 开始遍历</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="comment">// 二者不相等，不是回文，左侧需要缩限</span></span><br><span class="line">                    <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                        right = j;        <span class="comment">// 重置right</span></span><br><span class="line">                        start = left + <span class="number">1</span>; <span class="comment">// 左侧缩限</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 是回文，右侧缩限</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 不管是不是回文，左侧都需要缩限</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] = start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            <span class="type">int</span> len = j - dp[j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLength) &#123;</span><br><span class="line">                maxLength = len;</span><br><span class="line">                begin = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然这么做的时间复杂度依旧是<code>O(N^2)</code>，但是空间复杂度被降为了<code>O(N)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/7abf018774001fa96a73b23ced72ae21.png" alt="image.png"></p><h1 id="思路三：中心扩散-O-N-2"><a href="#思路三：中心扩散-O-N-2" class="headerlink" title="思路三：中心扩散 O(N^2)"></a>思路三：中心扩散 O(N^2)</h1><p>中心扩散的思路比较简单，遍历每一个下标，从这个下标开始往左往右扩散，直到找到最长的回文子串。这个思路不需要借助额外的数组，空间复杂度为<code>O(1)</code>。时间复杂度依旧是<code>O(N^2)</code>。</p><p>第一版本代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 扩展</span></span><br><span class="line">            <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> begin = i;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 相同，记录长度和开始下标</span></span><br><span class="line">                len = right - left + <span class="number">1</span>;</span><br><span class="line">                begin = left;</span><br><span class="line">                <span class="comment">// 扩展</span></span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLength) &#123;</span><br><span class="line">                maxLength = len;</span><br><span class="line">                maxBegin = begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(maxBegin, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码看上去好像没有问题，但实际上我们漏掉了回文串为偶数的情况，直接从长度为3的回文串开始递推了。这是不可行的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/b64f95bf323975b47e765035e1a5c22a.png" alt="image.png"></p><p>应该要把回文串长度为奇数，回文串长度为偶数的情况都考虑进去。下面是修改后的代码，其中使用了C++17的新特性，auto的结构化绑定来接收pair返回值，会方便一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 从left和right开始往左右扩展找回文子串，返回值是起始下标和长度</span></span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">findReverseString</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = left;</span><br><span class="line">        <span class="comment">// 往两边扩展</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 相同，记录长度和开始下标</span></span><br><span class="line">            len = right - left + <span class="number">1</span>;</span><br><span class="line">            begin = left;</span><br><span class="line">            <span class="comment">// 扩展</span></span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;begin, len&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 偶数情况</span></span><br><span class="line">            <span class="keyword">auto</span> [begin, len] = <span class="built_in">findReverseString</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 奇数情况</span></span><br><span class="line">            <span class="keyword">auto</span> [begin2, len2] = <span class="built_in">findReverseString</span>(s, i - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果奇数的结果更长，更新结果</span></span><br><span class="line">            <span class="keyword">if</span> (len2 &gt; len) &#123;</span><br><span class="line">                len = len2;</span><br><span class="line">                begin = begin2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLength) &#123;</span><br><span class="line">                maxLength = len;</span><br><span class="line">                maxBegin = begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(maxBegin, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/bf0cf0b351446058ee6dbf56050df8f8.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>其他更牛逼的思路暂时就不记录了！可以参考博客开头贴出来的博客。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-5.最长回文子串。这么经典的题目我竟然现在才刷，懒虫一个。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】计算器问题汇总</title>
    <link href="https://blog.musnow.top/posts/1512949254/"/>
    <id>https://blog.musnow.top/posts/1512949254/</id>
    <published>2024-05-26T02:20:29.000Z</published>
    <updated>2024-05-31T07:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯面试手撕计算器，带括号和加减乘除的中缀表达式，面试的时候没有写出来，必须得学学咋做了。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>我们平时遇到的数学表达式其实都是中缀表达式，比如<code>1+2/3</code>这一类。但是对于计算机而言，计算后缀表达式是更加方便的操作，包括我们自己写计算的函数，也是后缀表达式更加好处理。</p><p>所以我们应该先记住中缀、后缀、前缀表达式的区别，以及如何将中缀表达式转为后缀表达式。因为<strong>选择题</strong>有时候也会考相关的题目，不仅是要会写代码，还得记住怎么人工转换。</p><blockquote><p>我当时面试的时候就是忘记怎么把中缀转为后缀了，结果一直在死算，手撕给的时间本来就不多，临时写之前没写过的代码实在是写不出来，一堆BUG，突出一个菜。</p></blockquote><p>这部分内容都在本站的另外一篇博客 <a href="https://blog.musnow.top/posts/3211822811">逆波兰表达式求值</a> 中有提到，本文不再重复。阅读本文之前，建议先阅读该文章并完成 leetcode <a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150.逆波兰表达式求值</a>那道题。后缀表达式求值的思路如下：</p><ul><li>从左往右遍历，遇到操作数，入栈；</li><li>遇到运算符，取栈顶两个连续数据进行计算（第二个取出来的是左操作数），再将计算结果入栈；</li></ul><p>下面给出的是逆波兰表达式求值的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x+y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;-&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x-y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;/&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x/y;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> ret = FuncMap[ch](left,right);</span><br><span class="line">                s.<span class="built_in">push</span>(ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="题目一：227-基本计算器-II"><a href="#题目一：227-基本计算器-II" class="headerlink" title="题目一：227. 基本计算器 II"></a>题目一：227. 基本计算器 II</h1><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator-ii/description/">227. 基本计算器 II</a> 和 <a href="https://leetcode.cn/problems/calculator-lcci/description/">面试题 16.26. 计算器</a></p></blockquote><p>这是leetcode上和计算器有关的题目中最简单的一个，它并不需要我们将中缀表达式转为后缀，直接通过一个栈加遍历的方式就可以将其写出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。</span><br><span class="line"></span><br><span class="line">表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格。 整数除法仅保留整数部分。</span><br></pre></td></tr></table></figure><p>代码如下，我们需要一个栈来存放处理的数字，并用一个num来拼接字符串里面的数字（虽然用例都是一位数字，但是题目并没有说不会出现多位数字，所以需要拼接），和一个prevClac指代上一个操作符。</p><p>当遇到<strong>操作符且不为空格</strong>，或者当前已经遍历到字符串末尾的时候，就需要进行计算。其他情况都说明是数字，对num变量进行拼接就可以了。</p><p>在计算过程中，我们把加减计算给替代成用数字的正负号来处理，乘除计算则直接对栈内元素做处理。这里需要记住一个小知识点，即STL的<code>stack.top()</code>函数返回的是栈顶元素的引用，所以我们可以直接对其进行修改，不需要用临时变量来处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 是不是数字？</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNum</span><span class="params">(<span class="type">char</span>&amp; c)</span> </span>&#123; <span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; numSt;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;         <span class="comment">// 拼数字</span></span><br><span class="line">        <span class="type">char</span> prevClac = <span class="string">&#x27;+&#x27;</span>; <span class="comment">// 上一位运算符</span></span><br><span class="line">        <span class="comment">// 遍历字符串，跳过空格，遇到乘除直接计算，遇到加减推后计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">char</span>&amp; c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isNum</span>(c)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是操作符（注意不能是空格），或者当前已经是最后一位了，就需要计算</span></span><br><span class="line">            <span class="keyword">if</span> ((!<span class="built_in">isNum</span>(c) &amp;&amp; c != <span class="string">&#x27; &#x27;</span>) || i == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 我们把加减操作改成数字的正负来处理</span></span><br><span class="line">                <span class="keyword">if</span> (prevClac == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    numSt.<span class="built_in">push</span>(num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevClac == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    numSt.<span class="built_in">push</span>(-num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 直接计算乘除，top返回的是引用</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (prevClac == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    numSt.<span class="built_in">top</span>() *= num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevClac == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    numSt.<span class="built_in">top</span>() /= num;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新操作符</span></span><br><span class="line">                prevClac = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后统一求和</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!numSt.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            sum += numSt.<span class="built_in">top</span>();</span><br><span class="line">            numSt.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/c6c59e9995858323ff9f7a94d2021fc7.png" alt="image.png"></p><h1 id="题目二：224-基本计算器"><a href="#题目二：224-基本计算器" class="headerlink" title="题目二：224. 基本计算器"></a>题目二：224. 基本计算器</h1><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator/description/">https://leetcode.cn/problems/basic-calculator/description/</a></p></blockquote><p>这道题在原本的普通中缀表达式的基础上，添加了括号，但没有乘除法。</p><p>我们可以用中缀表达式先转为后续表达式的方式，再使用上文提到过的150逆波兰表达式求值的代码来计算它。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 3 * 105</span><br><span class="line">s 由数字、&#x27;+&#x27;、&#x27;-&#x27;、&#x27;(&#x27;、&#x27;)&#x27;、和 &#x27; &#x27; 组成</span><br><span class="line">s 表示一个有效的表达式</span><br><span class="line">&#x27;+&#x27; 不能用作一元运算(例如， &quot;+1&quot; 和 &quot;+(2 + 3)&quot; 无效)</span><br><span class="line">&#x27;-&#x27; 可以用作一元运算(即 &quot;-1&quot; 和 &quot;-(2 + 3)&quot; 是有效的)</span><br><span class="line">输入中不存在两个连续的操作符</span><br><span class="line">每个数字和运行的计算将适合于一个有符号的 32位 整数</span><br></pre></td></tr></table></figure><h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h2><p>使用一个栈来存放操作符，注意左右括号，左括号的优先级低于任何操作符，右括号优先级高于任何操作符。</p><ul><li>遇到操作数的时候 <strong>先输出</strong> 到结果表达式中;</li><li>遇到操作符，和<strong>栈顶</strong>进行比较<ul><li>如果栈为空&#x2F;操作符优先级<strong>高于</strong>栈顶，入栈；</li><li>操作符优先级<strong>低于</strong>栈顶或和栈顶<strong>相同</strong>，出栈顶操作符（然后继续比较当前操作符和栈顶操作符）；</li></ul></li><li>如果是左括号<code>(</code>，正常入栈；</li><li>遇到右括号<code>)</code>，出栈内所有操作符，直到遇到对应左括号，注意，最终的输出后缀表达式中不需要添加左&#x2F;右括号；</li><li>最后将栈中的操作符全部出栈，就可以获得后缀表达式；</li></ul><p>具体的代码如下，有点长，但是不难理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前的操作符优先级是不是比栈顶更高？</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isCalcHigher</span><span class="params">(<span class="type">const</span> string&amp; cur, <span class="type">const</span> string&amp; target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是乘除，且栈顶是加减，那么优先级就更高</span></span><br><span class="line">    <span class="keyword">if</span> ((cur == <span class="string">&quot;*&quot;</span> || cur == <span class="string">&quot;/&quot;</span>) &amp;&amp; (target == <span class="string">&quot;+&quot;</span> || target == <span class="string">&quot;-&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果target是左括号，则为true</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况，包括栈顶也是乘除的情况，优先级都低</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序表达式转后缀表达式</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">inOrderTobackOrder</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    stack&lt;string&gt; st; <span class="comment">//  操作符栈</span></span><br><span class="line">    string num;       <span class="comment">// 零时存放数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; itr : s)</span><br><span class="line">    &#123;</span><br><span class="line">        string c;</span><br><span class="line">        c.<span class="built_in">push_back</span>(itr);</span><br><span class="line">        <span class="comment">// 跳过空格</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 操作数</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; c &lt;= <span class="string">&quot;9&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num.<span class="built_in">push_back</span>(c[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他情况都说明不是操作数，需要将之前的操作数输出</span></span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(num);</span><br><span class="line">            num.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左括号入栈</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&quot;(&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到右括号，需要一直出栈内操作符，直到遇到左括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&quot;)&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遇到右括号的时候不可能出现栈为空的情况</span></span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">top</span>() != <span class="string">&quot;(&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">pop</span>(); <span class="comment">// 弹出左括号</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈为空，则入栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 其他操作符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 栈不为空，和栈顶的优先级进行比较</span></span><br><span class="line">            <span class="comment">// 操作符优先级高于栈顶，入栈;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isCalcHigher</span>(c, st.<span class="built_in">top</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优先级低于/等于栈顶操作符，将栈顶出栈（放入结果表达式）</span></span><br><span class="line">            retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 继续判断，直到高于栈顶运算符</span></span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">isCalcHigher</span>(c, st.<span class="built_in">top</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈顶高于当前运算符或栈为空，入栈</span></span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// num不为空，还需要处理</span></span><br><span class="line">    <span class="keyword">if</span> (num.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retV.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束遍历，将栈内操作符依次输出，即得到了最终的后缀表达式</span></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter inOrder &gt; &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="comment">// 处理</span></span><br><span class="line">    <span class="keyword">auto</span> retV = <span class="built_in">inOrderTobackOrder</span>(s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;backOrder result: [&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;retV.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; retV[i] &lt;&lt; <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=retV.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在224题目中给出的<code>(1+(4+5+2)-3)+(6+8)</code>这个表达式，经过转换的结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ 中缀表达式转后缀表达式.cpp -o test &amp;&amp; ./test</span><br><span class="line">enter inOrder &gt; (1+(4+5+2)-3)+(6+8)</span><br><span class="line">backOrder result: [&quot;1&quot;, &quot;4&quot;, &quot;5&quot;, &quot;+&quot;, &quot;2&quot;, &quot;+&quot;, &quot;+&quot;, &quot;3&quot;, &quot;-&quot;, &quot;6&quot;, &quot;8&quot;, &quot;+&quot;, &quot;+&quot;]</span><br></pre></td></tr></table></figure><p>把这个结果提供给150题目中的代码，计算结果就是23，代表我们的中缀转后缀的转换代码是正确的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/f0d515cb379b565bb22f687256517196.png" alt="image.png"></p><h2 id="单独的正负号处理"><a href="#单独的正负号处理" class="headerlink" title="单独的正负号处理"></a>单独的正负号处理</h2><p>有了这个函数后，我们就可以编写OJ的代码了，先把给出的中缀表达式转成后缀的，在进行计算。</p><p>先把基本的代码合并在一起，然后运行。此时会发现题目中有些刁钻的测试用例是过不了的。比如下面这个，它缺少了一个操作数，这导致我们中序转后续转出来的表达式是错误的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1-(     -2)&quot;</span><br></pre></td></tr></table></figure><p>题目中的提示也说明了这一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;+&#x27; 不能用作一元运算(例如， &quot;+1&quot; 和 &quot;+(2 + 3)&quot; 无效)</span><br><span class="line">&#x27;-&#x27; 可以用作一元运算(即 &quot;-1&quot; 和 &quot;-(2 + 3)&quot; 是有效的)</span><br></pre></td></tr></table></figure><p>这就需要我们对这种情况做个单独处理，即把<code>-2</code>变成<code>0-2</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改中缀表达式为合法表达式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stringHandler</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 去除所有空格</span></span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理独立的负号或者正号</span></span><br><span class="line">    <span class="comment">// (-n) -&gt; (0-n)</span></span><br><span class="line">    <span class="comment">// (+n) -&gt; (0+n)</span></span><br><span class="line">    <span class="comment">// 开头的-n -&gt; 0-n</span></span><br><span class="line">    <span class="comment">// 开头的+n -&gt; 0+n</span></span><br><span class="line">    s.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n = tmp.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开头的-n或者括号里面的-n</span></span><br><span class="line">        <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tmp[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            s += <span class="string">&quot;0-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开头的+n或者括号里面的+n</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27;+&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tmp[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            s += <span class="string">&quot;0+&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 其他情况说明是有匹配的表达式的，所以不需要处理</span></span><br><span class="line">            s += tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，通过这个函数处理后，一切都正常了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enter inOrder &gt; 1-( -2)</span><br><span class="line">handle: 1-(0-2)</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前的操作符优先级是不是比栈顶更高？</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCalcHigher</span><span class="params">(<span class="type">const</span> string&amp; cur, <span class="type">const</span> string&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是乘除，且栈顶是加减，那么优先级就更高</span></span><br><span class="line">        <span class="keyword">if</span> ((cur == <span class="string">&quot;*&quot;</span> || cur == <span class="string">&quot;/&quot;</span>) &amp;&amp; (target == <span class="string">&quot;+&quot;</span> || target == <span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果target是左括号，则为true</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他情况，包括栈顶也是乘除的情况，优先级都低</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改中缀表达式为合法表达式</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stringHandler</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 去除所有空格</span></span><br><span class="line">        std::string tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                tmp += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理独立的负号或者正号</span></span><br><span class="line">        <span class="comment">// (-n) -&gt; (0-n)</span></span><br><span class="line">        <span class="comment">// (+n) -&gt; (0+n)</span></span><br><span class="line">        <span class="comment">// 开头的-n -&gt; 0-n</span></span><br><span class="line">        <span class="comment">// 开头的+n -&gt; 0+n</span></span><br><span class="line">        s.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> n = tmp.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 开头的-n或者括号里面的-n</span></span><br><span class="line">            <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tmp[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)) &#123;</span><br><span class="line">                s += <span class="string">&quot;0-&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开头的+n或者括号里面的+n</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27;+&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tmp[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)) &#123;</span><br><span class="line">                s += <span class="string">&quot;0+&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他情况说明是有匹配的表达式的，所以不需要处理</span></span><br><span class="line">                s += tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序表达式转后缀表达式</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">inOrderTobackOrder</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        stack&lt;string&gt; st; <span class="comment">//  操作符栈</span></span><br><span class="line">        string num;       <span class="comment">// 零时存放数字</span></span><br><span class="line">        <span class="built_in">stringHandler</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; itr : s) &#123;</span><br><span class="line">            string c;</span><br><span class="line">            c.<span class="built_in">push_back</span>(itr);</span><br><span class="line">            <span class="comment">// 跳过空格</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 操作数</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; c &lt;= <span class="string">&quot;9&quot;</span>) &#123;</span><br><span class="line">                num.<span class="built_in">push_back</span>(c[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他情况都说明不是操作数，需要将之前的操作数输出</span></span><br><span class="line">            <span class="keyword">if</span> (num.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(num);</span><br><span class="line">                num.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左括号入栈</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到右括号，需要一直出栈内操作符，直到遇到左括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到右括号的时候不可能出现栈为空的情况</span></span><br><span class="line">                <span class="keyword">while</span> (st.<span class="built_in">top</span>() != <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                    retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 弹出左括号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果栈为空，则入栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 其他操作符</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 栈不为空，和栈顶的优先级进行比较</span></span><br><span class="line">                <span class="comment">// 操作符优先级高于栈顶，入栈;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isCalcHigher</span>(c, st.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(c);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 优先级低于/等于栈顶操作符，将栈顶出栈（放入结果表达式）</span></span><br><span class="line">                retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 继续判断，直到高于栈顶运算符</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">isCalcHigher</span>(c, st.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                    retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 栈顶高于当前运算符或栈为空，入栈</span></span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// num不为空，还需要处理</span></span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束遍历，将栈内操作符依次输出，即得到了最终的后缀表达式</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> retV = <span class="built_in">inOrderTobackOrder</span>(s);</span><br><span class="line">        <span class="comment">// 后缀表达式计算</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        unordered_map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; funcMap = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;+&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;-&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x - y; &#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;*&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x * y; &#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;/&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x / y; &#125;&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : retV) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&quot;+&quot;</span> || ch == <span class="string">&quot;-&quot;</span> || ch == <span class="string">&quot;*&quot;</span> || ch == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> right = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> ret = funcMap[ch](left, right);</span><br><span class="line">                st.<span class="built_in">push</span>(ret);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/2a9fa990a2a0baa915ccff75e5b5c050.png" alt="image.png"></p><h1 id="题目三：772-基本计算器-III"><a href="#题目三：772-基本计算器-III" class="headerlink" title="题目三：772. 基本计算器 III"></a>题目三：772. 基本计算器 III</h1><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator-iii/">https://leetcode.cn/problems/basic-calculator-iii/</a></p></blockquote><p>这道题和上一道题的区别就是多了乘法和除法。上一道题我们使用中缀转后缀再计算的思路已经包含了处理除法的情况了，所以直接用相同的代码就能过了。</p><p>腾讯面试的时候考的也是这道题，竟然在leetcode上需要开plus会员才能看，无语。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/6b958f2376075c862637bfddba606a90.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-计算器问题</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
</feed>
