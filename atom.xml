<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2024-03-13T02:35:11.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【算法】滑动窗口思想解决数组OJ题目</title>
    <link href="https://blog.musnow.top/posts/19524588/"/>
    <id>https://blog.musnow.top/posts/19524588/</id>
    <published>2024-03-12T04:29:19.000Z</published>
    <updated>2024-03-13T02:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>滑动窗口在很多地方都有实际使用，比如TCP的发送缓冲区就使用了这个思想来维护。</p><p>对于数组相关的算法OJ题来说，滑动窗口思路主要是基于双指针来实现的，一个作为窗口的左边界，一个作为窗口的右边界，并根据题目的条件来移动左右边界。</p><h1 id="题目1-209-长度最小的子数组"><a href="#题目1-209-长度最小的子数组" class="headerlink" title="题目1-209-长度最小的子数组"></a>题目1-209-长度最小的子数组</h1><p>第一题是leetcode的209，<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a>，这也是滑动窗口的一个基础且经典的题目。</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其总和大于等于 target 的长度最小的 <strong>连续</strong><br>子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>进阶：如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题要求的是数组中加起来大于等于target的最小连续子数组。最简单的办法是暴力两次遍历来计算每一个子数组组合的和，再与目标target对比，但这样的时间复杂度是<code>O(N^2)</code>。</p><p>使用滑动窗口来解决这道题才是对的，思路如下。</p><ol><li>left和right作为滑动窗口的左右边界，以right作为for循环的自增；</li><li>right++遍历一个数（滑动窗口扩张），加入到sum中；</li><li>如果sum大于等于target，记录<code>right-left+1</code>为当前子数组长度，开始操作left；</li><li>left++遍历一个数（滑动窗口缩限），将其从sum中删除；</li><li>再次判断sum是否大于等于target，如果大于，继续执行第三部和第四步；</li><li>sum不大于target了，继续for循环操作right，移动右边边界；</li><li>right大于等于下标，循环结束。</li></ol><p>最终得到的len就是最短的子数组。</p><p>注意，操作left的时候要用while循环，而不是用if来操作，因为最终可能会遇到，right固定在最后一位，但left还能继续往前走的情况，如果使用if，那么每个循环中left都最多只能走一次，会漏掉情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于这类问题，可以用打印下标的方式进行调试。最终测试的时候记得把打印注释掉，因为它们很耗时，可能会导致你的答案超时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right=<span class="number">0</span>; <span class="comment">// 滑动窗口</span></span><br><span class="line">        <span class="type">int</span> minRange = INT32_MAX; <span class="comment">// 因为需要获取最小值，所以要用一个最大值来比较</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(right =<span class="number">0</span>;right&lt;nums.<span class="built_in">size</span>();right++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) <span class="comment">// 这里必须要用while，需要考虑right是最后一个但left还可以继续走的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;fix: &quot; &lt;&lt; left &lt;&lt; &quot; - &quot; &lt;&lt; right &lt;&lt; &quot; sum:&quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">                <span class="type">int</span> curDiff = right - left + <span class="number">1</span>; <span class="comment">// 当前长度</span></span><br><span class="line">                minRange = <span class="built_in">min</span>(minRange,curDiff);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left ++;<span class="comment">// 左侧缩限</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;all: &quot; &lt;&lt; left &lt;&lt; &quot; - &quot; &lt;&lt; right &lt;&lt; &quot; sum:&quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还是最大值，则返回0</span></span><br><span class="line">        <span class="keyword">return</span> minRange == INT32_MAX ? <span class="number">0</span> : minRange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明一下，leetcode&#x2F;牛客网上的代码击败人数是没有参考意义的，这个时间和你的网络状况也有关系。我的题解博客中贴出代码通过截图，是想告诉未来的读者，这个代码在我测试的时候是通过的，以免未来leetcode测试用例变化无法通过时产生误解。</p><blockquote><p>好不容易搜到一个题解，结果它贴了无法通过的代码，谁看了不气？🤣</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/434871f83a804f052d952c3a2e5f9c89.png" alt="image.png"></p><h1 id="题目2-904-水果成篮"><a href="#题目2-904-水果成篮" class="headerlink" title="题目2-904-水果成篮"></a>题目2-904-水果成篮</h1><p><a href="https://leetcode.cn/problems/fruit-into-baskets/submissions/510977160/">904.水果成篮 - 力扣（LeetCode）</a></p><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 <code>fruits[i]</code> 是第 i 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ol><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ol><p>给你一个整数数组 fruits ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>刚开始我都没有读懂这个题目，注意，输入参数中的数组并非每棵树上有几个种类的水果，而是每棵树上的水果是<strong>第几类</strong>。比如<code>fruits[0] = 1</code>代表第0棵树上的水果是种类1，<code>fruits[1] = 2</code>代表第1棵树上的水果是种类2。</p><blockquote><p>我刚开始错误的理解为2代表这棵树上有两种水果，如果这样理解这道题就没法写了……</p></blockquote><p>你的篮子里面一次只能装两个种类的水果，这样这道题就转变成了，给出的数组中只包含两个相同数字的最长子数组。</p><p>比如数组 <code>[3,3,3,1,2,1,1,2,3,3,4]</code>，最长只包含两个数字的子数组是 <code>[1,2,1,1,2]</code>；数组<code>[1,2,3,2,2]</code>最长只包含两个数字的子数组是<code>[3,2,2]</code>；</p><p>同样是用滑动窗口来解题，使用left&#x2F;right左右边界，right作为while循环条件，并设置一个数字种类计数器fruitsCount、数字个数计数器sizeCount和一个set来保存当前的两个数字。另外还需要一个maxSizeCount来保存最长的数字个数，作为题目返回值。</p><ol><li>right遍历，当当前数字不存在set中，且count小于2时，将其加入到set中，并将fruitsCount++，长度sizeCount++，使用sizeCount对比更新maxSizeCount；</li><li>当当前数字存在于set中，长度sizeCount++，使用sizeCount对比更新maxSizeCount；</li><li>当当前数字不存在于set中，且fruitsCount已经为2，说明当前走到了第三个数字的位置，重置set和fruitsCount，使用sizeCount对比更新maxSizeCount后，将sizeCount重置为0；</li><li>left++（滑动窗口左侧缩限），一直加加到和<strong>当前数字不同</strong>的位置（比如left当前处于<code>3,3,3,1,2</code>的3的位置，那么就需要移动到1的位置，过滤重复数据）；</li><li>right重置到left的位置，继续执行上述步骤，直到right走完数组。</li></ol><p>注意，每次sizeCount++之后，都需要和maxSizeCount对比并更新。否则如果给出的数组本来就只有两种数字（比如<code>[1,2,1]</code>这整个数组本身就是答案）的情况，maxSizeCount会没有正常更新。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>因为本题目的set并不需要排序，所以使用哈希set会优于红黑树的set。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; fruitsSet;</span><br><span class="line">        <span class="type">int</span> fruitsCount = <span class="number">0</span>; <span class="comment">// 种类数量</span></span><br><span class="line">        <span class="type">int</span> curCount = <span class="number">0</span>; <span class="comment">// 当前水果计数</span></span><br><span class="line">        <span class="type">int</span> retCount = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; fruits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 水果不在里面，且还没有2个</span></span><br><span class="line">            <span class="keyword">if</span>(fruitsCount &lt; <span class="number">2</span> &amp;&amp; fruitsSet.<span class="built_in">count</span>(fruits[right]) == <span class="number">0</span>)&#123;</span><br><span class="line">                fruitsCount++; <span class="comment">// 种类数量加一</span></span><br><span class="line">                fruitsSet.<span class="built_in">insert</span>(fruits[right]);</span><br><span class="line">                curCount++; <span class="comment">// 水果个数加一</span></span><br><span class="line">                right++;</span><br><span class="line">                retCount = <span class="built_in">max</span>(curCount,retCount);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; right &lt;&lt; &quot; - &quot; &lt;&lt; fruits[right] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 水果在里面</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fruitsCount &lt;= <span class="number">2</span> &amp;&amp; fruitsSet.<span class="built_in">count</span>(fruits[right]) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">                curCount++;</span><br><span class="line">                retCount = <span class="built_in">max</span>(curCount,retCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 水果不在里面，且已经有两个了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fruitsCount &gt;= <span class="number">2</span> &amp;&amp; fruitsSet.<span class="built_in">count</span>(fruits[right]) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                retCount = <span class="built_in">max</span>(curCount,retCount);</span><br><span class="line">                fruitsSet.<span class="built_in">clear</span>(); <span class="comment">// 清空</span></span><br><span class="line">                curCount = <span class="number">0</span>;</span><br><span class="line">                fruitsCount = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 找下一个和left当前不同的水果</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; fruits.<span class="built_in">size</span>() &amp;&amp; fruits[left+<span class="number">1</span>] == fruits[left])&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 还需要再走一步，才是和刚刚不一样的水果</span></span><br><span class="line">                left++;</span><br><span class="line">                right = left; <span class="comment">// 重新开始新一轮计数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e71c0534a185be79be2606779f304890.png" alt="image.png"></p><h1 id="题目3-76-最小覆盖子串"><a href="#题目3-76-最小覆盖子串" class="headerlink" title="题目3-76-最小覆盖子串"></a>题目3-76-最小覆盖子串</h1><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p><h2 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。 </p><p>注意：</p><ul><li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li><li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p>s 和 t 由英文字母组成，且可能会重复（未规定大小写）</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>同样是使用滑动窗口，但这一次的缩限需要进行判断。</p><p>首先要明白题目给出的条件</p><ul><li>当t字符串大于s字符串的时候，直接返回空，因为s的子串无法包含t；</li><li>t中的字母可能是大写也可能是小写，而且t中的某个字母可能会重复，所以需要一个map来保存字符及其个数；</li><li>题目要求返回的是子串，所以需要记录子串在s内的起始下标及其长度；</li></ul><p>这里需要用到两个哈希map，一个tMaps用于存放t字符串中的所有字符和个数，另外一个curMaps用来存放当前滑动窗口内包含的t字符串内字符的个数。</p><ol><li>right++，当遇到t字符串内的字符，则将curMaps中对应字符数量加一；</li><li>检查curMaps中的字符个数是否都已经大于tMaps中的字符数量，且没有缺少字符；</li><li>如果符合条件，记录当前的left（作为子串起始位置）和长度len，随后left++开始缩限，并将curMaps中对应字符减一，直到curMaps不符合条件为止；</li><li>right继续加加，重复上述步骤，直到right越界。</li></ol><p>注意，这里建议将用于更新的子串起始地址begin初始化为非法下标<code>-1</code>，并在return的时候进行判断，这样能知道s字符串中是否存在符合条件的子串。如果begin在循环结束后还是<code>-1</code>，则代表s内没有符合条件的子串，此时返回空字符串。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断当前map中是否已经包含目标map中需要的所有字符</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">statusCheck</span><span class="params">(<span class="type">const</span> unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&amp; tMaps,unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&amp; curMaps)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:tMaps)&#123;</span><br><span class="line">            <span class="comment">// 这里不能用不等于判断，因为curMaps中的计数器大于的时候也是符合条件的</span></span><br><span class="line">            <span class="keyword">if</span>(curMaps.<span class="built_in">count</span>(e.first)!=<span class="number">0</span> &amp;&amp; curMaps[e.first] &lt; e.second)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (curMaps.<span class="built_in">count</span>(e.first)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">-1</span>, end = <span class="number">-1</span>, len = INT32_MAX; <span class="comment">// 最终用于返回结果的下标区间</span></span><br><span class="line">        <span class="comment">// 记录t中每个字符出现的次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; tMaps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:t)&#123;</span><br><span class="line">            tMaps[e]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前出现的tmap中的字符的数量</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; curMaps;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果目标map里面有，则在当前map里面将数量加一</span></span><br><span class="line">            <span class="keyword">if</span>(tMaps.<span class="built_in">count</span>(s[right]) !=<span class="number">0</span>)&#123;</span><br><span class="line">                curMaps[s[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果符合条件，则缩限到不能缩限为止</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">statusCheck</span>(tMaps,curMaps) &amp;&amp; left &lt;=right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果长度小于当前记录的长度，则更新</span></span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; len)</span><br><span class="line">                &#123;</span><br><span class="line">                    len = right - left + <span class="number">1</span>;</span><br><span class="line">                    begin = left;</span><br><span class="line">                    end = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 在目标map里面看是否有这个字符串，有则在当前map中将数量减一</span></span><br><span class="line">                <span class="keyword">if</span>(tMaps.<span class="built_in">count</span>(s[left]) !=<span class="number">0</span>)&#123;</span><br><span class="line">                    curMaps[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果begin没有被更新，则说明不存在</span></span><br><span class="line">        <span class="keyword">return</span> begin == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(begin,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f0da87219c6ebd2175cfdba9633791c5.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>滑动窗口方法同时也是双指针法的一个运用，这三道题目都囊括了这个方法，平时记得加以复习。</p>]]></content>
    
    
    <summary type="html">使用“滑动窗口”思想来解决一些数组的OJ题目</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="数组" scheme="https://blog.musnow.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】16.最接近的三数之和</title>
    <link href="https://blog.musnow.top/posts/4003189051/"/>
    <id>https://blog.musnow.top/posts/4003189051/</id>
    <published>2024-03-10T08:27:23.000Z</published>
    <updated>2024-03-13T01:28:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这下真的得好好重头开始学算法了，基于《代码随想录》，今天周日的目标是完成<strong>哈希章节</strong>，并复习字符串章节和KMP算法。争取在四月中旬之前学完《代码随想录》里面的算法，欢迎大家监督我！</p><p><a href="https://gitee.com/musnows/LetsOJ">LetsOJ_多人刷题打卡: 这是一个多人OJ打卡仓库</a></p><p>新建了一个leetcode的进度，OJ刷题打卡仓库中的代码也重新归档。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/2eadb6db523d970c34710e334ed2af18.png" alt="image.png"></p><p>注意：在手机上代码块中的下标位置会因为字体原因偏离，请使用电脑查看本博客。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和 - 力扣（LeetCode）</a></p><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,0,0], target = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题和15三数之和的思路很相似，15题中要求是三数和为0，这道题要求是和target越接近越好。其实就是在把目标值从0改成target，并将三数和为target改成接近target，中间会多一个记录差距数的操作。</p><p>使用排序+双指针来实现。排序后的数组已经有序，使用双指针的时候方便控制指针移动</p><ul><li>如果和大于target，则右侧指针–；</li><li>如果和小于target，则左侧指针++；</li></ul><p>这里还会涉及到一些优化，虽然题目中没有15题去重的要求，但跳过重复元素也能提高运行效率。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h3><p>最简单的方式即<strong>不做任何去重</strong>，按照思路写代码就行。sum大于或者等于target的时候就让右侧指针减一，小于target的时候让左侧指针加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retNum = INT_MAX; <span class="comment">// 差距值</span></span><br><span class="line">        <span class="type">int</span> retSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"><span class="comment">// 更新结果值</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">abs</span>(target-sum);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; retNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    retNum = diff;</span><br><span class="line">                    retSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样也能通过</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/8cdda259da83a2ac2bdc1d2b5cdc8a84.png" alt="image.png"></p><h3 id="下标i去重"><a href="#下标i去重" class="headerlink" title="下标i去重"></a>下标i去重</h3><p>下标i去重的目的是让i不处理刚刚已经处理过的值。注意，和15题18题中的去重都是相同的思路，要先处理完毕某个值再去重。</p><p>如下所示，假设我们需要对<code>-1</code>这个元素去重（不重复处理），应该先正常对第一个<code>-1</code>进行操作，再让i跳过第二个<code>-1</code>走到2的位置进行下一步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 3 4</span><br><span class="line">    i</span><br></pre></td></tr></table></figure><p>如果先去重，在三数之和中，假设target&#x3D;0，下面的情况就会被忽略。这里i已经走到了第二个<code>-1</code>的位置了，但<code>(-1) + (-1) +2 = 0</code> ，这种符合题意的结果就直接被跳过了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先去重的代码，错误！</span></span><br><span class="line"><span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 3 4</span><br><span class="line">   i l   r</span><br></pre></td></tr></table></figure><p>如果我们不先执行去重，下标分布如下所示，右侧指针不断减，就能匹配上<code>-1 -1 2</code>这个三元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 3 4</span><br><span class="line">    i  l     r</span><br></pre></td></tr></table></figure><p>匹配上了之后再让i跳过第二个<code>-1</code>才是正确的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的去重代码</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="comment">// 跳过刚刚已经处理过的相同值</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>对于这道题，加上对i的去重后代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retNum = INT_MAX; <span class="comment">// 差距值</span></span><br><span class="line">        <span class="type">int</span> retSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先匹配再去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="comment">// 更新结果值</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">abs</span>(target-sum);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; retNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    retNum = diff;</span><br><span class="line">                    retSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/79d0779bb11dc8a284135570167f8402.png" alt="image.png"></p><h3 id="left-x2F-right去重"><a href="#left-x2F-right去重" class="headerlink" title="left&#x2F;right去重"></a>left&#x2F;right去重</h3><p>在15题三数之和的题解中会对left和right进行去重，同样是遵循先匹配再去重的操作。</p><p>假设当前指针位置如下，当前和为<code>5</code>，假设小于target，此时需要移动left指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 2 2 3 4</span><br><span class="line">    i    l       r</span><br></pre></td></tr></table></figure><p>那么left指针移动的时候，可以直接移动到最后一个2的位置，因为对于求和而言它们没有任何区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 2 2 3 4</span><br><span class="line">    i          l r</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retNum = INT_MAX; <span class="comment">// 差距值</span></span><br><span class="line">        <span class="type">int</span> retSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先匹配再去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新结果值</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">abs</span>(target-sum);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; retNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    retNum = diff;</span><br><span class="line">                    retSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 必须要再操作一次才是下一个</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 必须要再操作一次才是下一个</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9ce082f0e755255f5e368fd805290888.png" alt="image.png"></p><h3 id="遇到target直接返回"><a href="#遇到target直接返回" class="headerlink" title="遇到target直接返回"></a>遇到target直接返回</h3><p>如果三数和已经等于target，可以直接返回，不需要继续执行。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>leetcode和16题类似的有15题&#x2F;18题&#x2F;454题，具体可以参考代码随想录和我的刷题仓库。</p>]]></content>
    
    
    <summary type="html">leetcode 16.最接近的三数之和</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】11.盛水最多的容器</title>
    <link href="https://blog.musnow.top/posts/62868007/"/>
    <id>https://blog.musnow.top/posts/62868007/</id>
    <published>2024-03-09T07:15:46.000Z</published>
    <updated>2024-03-10T08:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/68a275f35ddd873d91e563b3aa409b40.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最开始想的是暴力破解，两个for就能遍历出来。但很明显这个思路是会超时的，两个for的时间复杂度是<code>O(N^2)</code>；</p><p>这道题在leetcode的top100中是双指针法里面的，所以要想使用前后两个指针来遍历，可以让时间复杂度降低为<code>O(N)</code>；这也是官方题解中提到的方式。</p><p>首先是前后指针应该移动谁的问题，先列出这个面积的计算公式，两个下标的插值是x轴的长度，然后是两个数组中元素的较小值，作为柱子的长度。假设index1和index2为两个下标，默认情况一个数组头一个数组尾部。</p><p>$$<br> range &#x3D; abs(index1-index2) * min(arr[index1],arr[index2])<br>$$</p><p>假设index1的数组元素（高度）小于index2，那么这个公式就变成了</p><p>$$<br> range &#x3D; abs(index1-index2) * arr[index1]<br>$$</p><p>注意，此时移动index2下标，这个容器的面积还是不会大于这个值，x轴长度减少了，但高度无论怎么变较小者还是<code>arr[index1]</code>；所以需要移动的下标是<strong>二者高度小的那一个</strong>。</p><p>官方题解中有更详细的演示：<a href="https://leetcode.cn/problems/container-with-most-water/solutions/207215/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked">盛最多水的容器. - 力扣（LeetCode）</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxRet = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = height.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curMin = <span class="built_in">min</span>(height[right],height[left]);</span><br><span class="line">            maxRet = <span class="built_in">max</span>((right-left)*curMin,maxRet);</span><br><span class="line">            <span class="keyword">if</span>(curMin == height[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/620573c4c3b8234fbcc5dcac2eb0ca81.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode11题，盛水最多的容器</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="默认标签" scheme="https://blog.musnow.top/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>【面试】C++三个线程交替打印1到100</title>
    <link href="https://blog.musnow.top/posts/235113945/"/>
    <id>https://blog.musnow.top/posts/235113945/</id>
    <published>2024-03-09T01:31:10.000Z</published>
    <updated>2024-03-09T01:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天面了个大厂，自己太傻逼了，<strong>这么简单的一道题目没写出来</strong>。因为我不太熟悉条件变量，拖了很长时间，面试官估计有点失望，后续的八股也没问什么，意料之中的挂了😭。</p><p>还有个题目是LRU，这个倒是临时抱佛脚复习到了，写出来了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7421b5d3ff29ccbb72dfb3efd12d70fd.png"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>问题：线程1打印1，线程2打印2，线程3打印3，线程1打印4，线程2打印5，线程3打印6……一直打印到100。</p><p>其实一点都不难，就是我自己平时压根没做过多少线程同步的练习，对于条件变量之类的玩意基本停留在理论和学习时的简单demo层面，一上战场加上紧张就毛都不会了。</p><h2 id="思路1-直接用线程序号做判断"><a href="#思路1-直接用线程序号做判断" class="headerlink" title="思路1-直接用线程序号做判断"></a>思路1-直接用线程序号做判断</h2><p>最简单的一个思路，因为只有三个线程，每个线程打印的数字是有规律的</p><ul><li>线程一打印的数字%3都等于1</li><li>线程二打印的数字%3都等于2</li><li>线程三打印的数字%3都等于0</li></ul><p>所以我们可以直接写一个函数，提供一个线程编号，通过计算判断当前是否是自己需要打印的数字，不是就睡觉。这个方法是最简单的，只需要一个全局变量加一个锁就能实现。</p><p>两个atomic变量，一个用于主线程通知所有线程当前已经初始化完毕，另外一个用于线程通知主线程当前已经执行完毕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1打印1，线程2打印2，线程3打印3，线程1打印4，线程2打印5.... 打印到100</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; isRun = <span class="literal">false</span>;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; isFinished = <span class="literal">false</span>;</span><br><span class="line">std::mutex gMtx;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintCountFun</span><span class="params">(<span class="type">int</span> no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!isRun)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!isFinished)</span><br><span class="line">    &#123;</span><br><span class="line">        gMtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isFinished = <span class="literal">true</span>;</span><br><span class="line">            gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1号2号线程</span></span><br><span class="line">        <span class="keyword">if</span>(no!=<span class="number">3</span> &amp;&amp; count % <span class="number">3</span> == no)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; no &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">            count ++;</span><br><span class="line">            gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3号线程</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">3</span> &amp;&amp; count % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; no &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">            count ++;</span><br><span class="line">            gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(PrintCountFun,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(PrintCountFun,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(PrintCountFun,<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    t2.<span class="built_in">detach</span>();</span><br><span class="line">    t3.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    isRun = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!isFinished)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finished\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>方法1代码运行结果</summary><p>反正是通过编号判断的，肯定不会错，只不过这样效率其实很低。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">1 - 140173660395072 - c: 1</span><br><span class="line">2 - 140173652002368 - c: 2</span><br><span class="line">3 - 140173643609664 - c: 3</span><br><span class="line">1 - 140173660395072 - c: 4</span><br><span class="line">2 - 140173652002368 - c: 5</span><br><span class="line">3 - 140173643609664 - c: 6</span><br><span class="line">1 - 140173660395072 - c: 7</span><br><span class="line">2 - 140173652002368 - c: 8</span><br><span class="line">3 - 140173643609664 - c: 9</span><br><span class="line">1 - 140173660395072 - c: 10</span><br><span class="line">2 - 140173652002368 - c: 11</span><br><span class="line">3 - 140173643609664 - c: 12</span><br><span class="line">1 - 140173660395072 - c: 13</span><br><span class="line">2 - 140173652002368 - c: 14</span><br><span class="line">3 - 140173643609664 - c: 15</span><br><span class="line">1 - 140173660395072 - c: 16</span><br><span class="line">2 - 140173652002368 - c: 17</span><br><span class="line">3 - 140173643609664 - c: 18</span><br><span class="line">1 - 140173660395072 - c: 19</span><br><span class="line">2 - 140173652002368 - c: 20</span><br><span class="line">3 - 140173643609664 - c: 21</span><br><span class="line">1 - 140173660395072 - c: 22</span><br><span class="line">2 - 140173652002368 - c: 23</span><br><span class="line">3 - 140173643609664 - c: 24</span><br><span class="line">1 - 140173660395072 - c: 25</span><br><span class="line">2 - 140173652002368 - c: 26</span><br><span class="line">3 - 140173643609664 - c: 27</span><br><span class="line">1 - 140173660395072 - c: 28</span><br><span class="line">2 - 140173652002368 - c: 29</span><br><span class="line">3 - 140173643609664 - c: 30</span><br><span class="line">1 - 140173660395072 - c: 31</span><br><span class="line">2 - 140173652002368 - c: 32</span><br><span class="line">3 - 140173643609664 - c: 33</span><br><span class="line">1 - 140173660395072 - c: 34</span><br><span class="line">2 - 140173652002368 - c: 35</span><br><span class="line">3 - 140173643609664 - c: 36</span><br><span class="line">1 - 140173660395072 - c: 37</span><br><span class="line">2 - 140173652002368 - c: 38</span><br><span class="line">3 - 140173643609664 - c: 39</span><br><span class="line">1 - 140173660395072 - c: 40</span><br><span class="line">2 - 140173652002368 - c: 41</span><br><span class="line">3 - 140173643609664 - c: 42</span><br><span class="line">1 - 140173660395072 - c: 43</span><br><span class="line">2 - 140173652002368 - c: 44</span><br><span class="line">3 - 140173643609664 - c: 45</span><br><span class="line">1 - 140173660395072 - c: 46</span><br><span class="line">2 - 140173652002368 - c: 47</span><br><span class="line">3 - 140173643609664 - c: 48</span><br><span class="line">1 - 140173660395072 - c: 49</span><br><span class="line">2 - 140173652002368 - c: 50</span><br><span class="line">3 - 140173643609664 - c: 51</span><br><span class="line">1 - 140173660395072 - c: 52</span><br><span class="line">2 - 140173652002368 - c: 53</span><br><span class="line">3 - 140173643609664 - c: 54</span><br><span class="line">1 - 140173660395072 - c: 55</span><br><span class="line">2 - 140173652002368 - c: 56</span><br><span class="line">3 - 140173643609664 - c: 57</span><br><span class="line">1 - 140173660395072 - c: 58</span><br><span class="line">2 - 140173652002368 - c: 59</span><br><span class="line">3 - 140173643609664 - c: 60</span><br><span class="line">1 - 140173660395072 - c: 61</span><br><span class="line">2 - 140173652002368 - c: 62</span><br><span class="line">3 - 140173643609664 - c: 63</span><br><span class="line">1 - 140173660395072 - c: 64</span><br><span class="line">2 - 140173652002368 - c: 65</span><br><span class="line">3 - 140173643609664 - c: 66</span><br><span class="line">1 - 140173660395072 - c: 67</span><br><span class="line">2 - 140173652002368 - c: 68</span><br><span class="line">3 - 140173643609664 - c: 69</span><br><span class="line">1 - 140173660395072 - c: 70</span><br><span class="line">2 - 140173652002368 - c: 71</span><br><span class="line">3 - 140173643609664 - c: 72</span><br><span class="line">1 - 140173660395072 - c: 73</span><br><span class="line">2 - 140173652002368 - c: 74</span><br><span class="line">3 - 140173643609664 - c: 75</span><br><span class="line">1 - 140173660395072 - c: 76</span><br><span class="line">2 - 140173652002368 - c: 77</span><br><span class="line">3 - 140173643609664 - c: 78</span><br><span class="line">1 - 140173660395072 - c: 79</span><br><span class="line">2 - 140173652002368 - c: 80</span><br><span class="line">3 - 140173643609664 - c: 81</span><br><span class="line">1 - 140173660395072 - c: 82</span><br><span class="line">2 - 140173652002368 - c: 83</span><br><span class="line">3 - 140173643609664 - c: 84</span><br><span class="line">1 - 140173660395072 - c: 85</span><br><span class="line">2 - 140173652002368 - c: 86</span><br><span class="line">3 - 140173643609664 - c: 87</span><br><span class="line">1 - 140173660395072 - c: 88</span><br><span class="line">2 - 140173652002368 - c: 89</span><br><span class="line">3 - 140173643609664 - c: 90</span><br><span class="line">1 - 140173660395072 - c: 91</span><br><span class="line">2 - 140173652002368 - c: 92</span><br><span class="line">3 - 140173643609664 - c: 93</span><br><span class="line">1 - 140173660395072 - c: 94</span><br><span class="line">2 - 140173652002368 - c: 95</span><br><span class="line">3 - 140173643609664 - c: 96</span><br><span class="line">1 - 140173660395072 - c: 97</span><br><span class="line">2 - 140173652002368 - c: 98</span><br><span class="line">3 - 140173643609664 - c: 99</span><br><span class="line">1 - 140173660395072 - c: 100</span><br><span class="line">finished</span><br></pre></td></tr></table></figure></details><p>我刚开始的时候就是想着用条件变量，比如三个条件变量分别用于通知……但这个实在是复杂且没有必要，没做过条件变量练习一时半会完全是写不出来的。后来就换了这个思路，但时间已经来不及了。</p><p>说来惭愧，我写完上面代码的基本框架后编译错误，显示<code>atomic&lt;bool&gt;</code>初始化失败，我找了好久都没有发现是自己<strong>没有引用</strong><code>&lt;atomic&gt;</code>这个头文件导致的，一直在看自己的语法是不是写错了……</p><p>还是自己练习不够，不然也不会怀疑自己语法是否写错😣</p><h1 id="思路2-条件变量"><a href="#思路2-条件变量" class="headerlink" title="思路2-条件变量"></a>思路2-条件变量</h1><p>上述的这个单锁加遍历的思路其实并不是一个好的答案（<strong>但总比没写出来的好</strong>），因为它完全没有涉及到线程同步的机制，<strong>三个线程其实毫无关系</strong>，只是在通过锁竞争和判断来确定自己是否需要打印。面试官想要的答案肯定得包含条件变量。</p><p>下面这个解决方案的思路同样是通过线程编号判断（只不过拆分成了三个不同的函数），每个线程打印完毕自己的，就把另外两个线程唤醒，然后被唤醒的两个线程会通过锁竞争先后进入自己的函数打印区域，判断是否是自己需要打印的部分，如果不是就继续在条件变量里面等待。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex gMtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lc</span><span class="params">(gMtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">count++;</span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">wait</span>(lc);</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lc</span><span class="params">(gMtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count % <span class="number">3</span> == <span class="number">1</span> &amp;&amp; count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">count++; </span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">wait</span>(lc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lc</span><span class="params">(gMtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">count++; </span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">wait</span>(lc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">s1</span><span class="params">(func1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">s2</span><span class="params">(func2)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">s3</span><span class="params">(func3)</span></span>;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">join</span>();</span><br><span class="line">s2.<span class="built_in">join</span>();</span><br><span class="line">s3.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finished\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>方法2代码运行结果</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">140713900033600 - c: 1</span><br><span class="line">140713891640896 - c: 2</span><br><span class="line">140713908426304 - c: 3</span><br><span class="line">140713900033600 - c: 4</span><br><span class="line">140713891640896 - c: 5</span><br><span class="line">140713908426304 - c: 6</span><br><span class="line">140713900033600 - c: 7</span><br><span class="line">140713891640896 - c: 8</span><br><span class="line">140713908426304 - c: 9</span><br><span class="line">140713900033600 - c: 10</span><br><span class="line">140713891640896 - c: 11</span><br><span class="line">140713908426304 - c: 12</span><br><span class="line">140713900033600 - c: 13</span><br><span class="line">140713891640896 - c: 14</span><br><span class="line">140713908426304 - c: 15</span><br><span class="line">140713900033600 - c: 16</span><br><span class="line">140713891640896 - c: 17</span><br><span class="line">140713908426304 - c: 18</span><br><span class="line">140713900033600 - c: 19</span><br><span class="line">140713891640896 - c: 20</span><br><span class="line">140713908426304 - c: 21</span><br><span class="line">140713900033600 - c: 22</span><br><span class="line">140713891640896 - c: 23</span><br><span class="line">140713908426304 - c: 24</span><br><span class="line">140713900033600 - c: 25</span><br><span class="line">140713891640896 - c: 26</span><br><span class="line">140713908426304 - c: 27</span><br><span class="line">140713900033600 - c: 28</span><br><span class="line">140713891640896 - c: 29</span><br><span class="line">140713908426304 - c: 30</span><br><span class="line">140713900033600 - c: 31</span><br><span class="line">140713891640896 - c: 32</span><br><span class="line">140713908426304 - c: 33</span><br><span class="line">140713900033600 - c: 34</span><br><span class="line">140713891640896 - c: 35</span><br><span class="line">140713908426304 - c: 36</span><br><span class="line">140713900033600 - c: 37</span><br><span class="line">140713891640896 - c: 38</span><br><span class="line">140713908426304 - c: 39</span><br><span class="line">140713900033600 - c: 40</span><br><span class="line">140713891640896 - c: 41</span><br><span class="line">140713908426304 - c: 42</span><br><span class="line">140713900033600 - c: 43</span><br><span class="line">140713891640896 - c: 44</span><br><span class="line">140713908426304 - c: 45</span><br><span class="line">140713900033600 - c: 46</span><br><span class="line">140713891640896 - c: 47</span><br><span class="line">140713908426304 - c: 48</span><br><span class="line">140713900033600 - c: 49</span><br><span class="line">140713891640896 - c: 50</span><br><span class="line">140713908426304 - c: 51</span><br><span class="line">140713900033600 - c: 52</span><br><span class="line">140713891640896 - c: 53</span><br><span class="line">140713908426304 - c: 54</span><br><span class="line">140713900033600 - c: 55</span><br><span class="line">140713891640896 - c: 56</span><br><span class="line">140713908426304 - c: 57</span><br><span class="line">140713900033600 - c: 58</span><br><span class="line">140713891640896 - c: 59</span><br><span class="line">140713908426304 - c: 60</span><br><span class="line">140713900033600 - c: 61</span><br><span class="line">140713891640896 - c: 62</span><br><span class="line">140713908426304 - c: 63</span><br><span class="line">140713900033600 - c: 64</span><br><span class="line">140713891640896 - c: 65</span><br><span class="line">140713908426304 - c: 66</span><br><span class="line">140713900033600 - c: 67</span><br><span class="line">140713891640896 - c: 68</span><br><span class="line">140713908426304 - c: 69</span><br><span class="line">140713900033600 - c: 70</span><br><span class="line">140713891640896 - c: 71</span><br><span class="line">140713908426304 - c: 72</span><br><span class="line">140713900033600 - c: 73</span><br><span class="line">140713891640896 - c: 74</span><br><span class="line">140713908426304 - c: 75</span><br><span class="line">140713900033600 - c: 76</span><br><span class="line">140713891640896 - c: 77</span><br><span class="line">140713908426304 - c: 78</span><br><span class="line">140713900033600 - c: 79</span><br><span class="line">140713891640896 - c: 80</span><br><span class="line">140713908426304 - c: 81</span><br><span class="line">140713900033600 - c: 82</span><br><span class="line">140713891640896 - c: 83</span><br><span class="line">140713908426304 - c: 84</span><br><span class="line">140713900033600 - c: 85</span><br><span class="line">140713891640896 - c: 86</span><br><span class="line">140713908426304 - c: 87</span><br><span class="line">140713900033600 - c: 88</span><br><span class="line">140713891640896 - c: 89</span><br><span class="line">140713908426304 - c: 90</span><br><span class="line">140713900033600 - c: 91</span><br><span class="line">140713891640896 - c: 92</span><br><span class="line">140713908426304 - c: 93</span><br><span class="line">140713900033600 - c: 94</span><br><span class="line">140713891640896 - c: 95</span><br><span class="line">140713908426304 - c: 96</span><br><span class="line">140713900033600 - c: 97</span><br><span class="line">140713891640896 - c: 98</span><br><span class="line">140713908426304 - c: 99</span><br><span class="line">140713900033600 - c: 100</span><br><span class="line">finished</span><br></pre></td></tr></table></figure></details><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>自己平时不多练习，只能大意失荆州了……</p>]]></content>
    
    
    <summary type="html">使用C++实现三个线程交替打印1到100</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="线程" scheme="https://blog.musnow.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】146LRU缓存</title>
    <link href="https://blog.musnow.top/posts/1621367479/"/>
    <id>https://blog.musnow.top/posts/1621367479/</id>
    <published>2024-03-08T01:58:17.000Z</published>
    <updated>2024-03-08T01:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked">146. LRU 缓存 - 力扣（LeetCode）</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>操作系统中学习过LRU的相关知识，中文是<strong>最长最久未使用</strong>，是页面置换算法的一部分。即页表在置换算法的时候，从当前时刻往前找，找到以载入页面中最长时间没有被使用的哪一个，将其置换出去。</p><p>对于代码而言，可以用list+哈希表的结构来实现。</p><ul><li>哈希表存放key和node的关系</li><li>node中存放key和value</li></ul><p>我们使用list来维护节点被使用的时间，<strong>一个节点被访问就插入到链表头</strong>，这样就能保证链表尾部的就是那个最久没有被使用的节点。需要删除的时候就将尾部的节点删除即可。</p><p>如果一个key已经存在与list中，访问的时候就需要将其先删除，再头插。为了满足题目中<code>O(1)</code>时间复杂度的要求，使用链表才能保证删除的时间复杂度是<code>O(1)</code>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>刚开始用的头删+尾插的方式，结果弄了好久都还有段错误，改成头插+尾删好处理一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _val;</span><br><span class="line">    <span class="type">int</span> _key;</span><br><span class="line">    Node* _prev;</span><br><span class="line">    Node* _next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>():_val(<span class="number">0</span>),_key(<span class="number">0</span>),_prev(<span class="literal">nullptr</span>),_next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> key,<span class="type">int</span> val):_val(val),_key(key),_prev(<span class="literal">nullptr</span>),_next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    Node* _head;</span><br><span class="line">    Node* _tail;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,Node*&gt; _map;</span><br><span class="line">    <span class="type">int</span> _size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> _capa = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        _head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        _tail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        _head-&gt;_next = _tail;</span><br><span class="line">        _tail-&gt;_prev = _head;</span><br><span class="line">        _capa = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addNodeToHead</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;_prev = _head;</span><br><span class="line">        node-&gt;_next = _head-&gt;_next;</span><br><span class="line">        _head-&gt;_next-&gt;_prev = node;</span><br><span class="line">        _head-&gt;_next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</span><br><span class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_map.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            Node* node = _map[key];</span><br><span class="line">            <span class="built_in">removeNode</span>(node);</span><br><span class="line">            <span class="built_in">addNodeToHead</span>(node);</span><br><span class="line">            <span class="keyword">return</span> node-&gt;_val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存在</span></span><br><span class="line">        <span class="keyword">if</span>(_map.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            Node* node = _map[key];</span><br><span class="line">            node-&gt;_val = value;</span><br><span class="line">            <span class="built_in">removeNode</span>(node);</span><br><span class="line">            <span class="built_in">addNodeToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 超长了</span></span><br><span class="line">            <span class="keyword">if</span>(_size == _capa)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* remove = _tail-&gt;_prev;</span><br><span class="line">                _map.<span class="built_in">erase</span>(remove-&gt;_key);</span><br><span class="line">                <span class="built_in">removeNode</span>(remove);</span><br><span class="line">                _size--;</span><br><span class="line">                <span class="comment">// 这里可以不free节点，因为OJ不考虑内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> remove;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(key,value);</span><br><span class="line">            <span class="built_in">addNodeToHead</span>(node);</span><br><span class="line">            _map[key] = node;</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/44f70ed77f48124bd2b0a1080122d732.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">使用哈希表和链表实现的LRU缓存</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="链表" scheme="https://blog.musnow.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】KMP算法</title>
    <link href="https://blog.musnow.top/posts/1835761968/"/>
    <id>https://blog.musnow.top/posts/1835761968/</id>
    <published>2024-02-29T08:31:48.000Z</published>
    <updated>2024-03-10T06:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考《代码随想录》。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>KMP算法是解决字符串问题时比较常用的一个算法，它可以将暴力破解法的时间复杂度<code>O(N^2)</code>降低到<code>O(M+N)</code>，效率有不错的提升。</p><p>KMP算法由Knuth、Morris和Pratt三位学者发明，也因此得名KMP。</p><h2 id="1-1-next-前缀表"><a href="#1-1-next-前缀表" class="headerlink" title="1.1 next 前缀表"></a>1.1 next 前缀表</h2><p>KMP算法的核心是next数组，实际上是一个<strong>前缀表</strong>：记录下标i（包括i）之前的字符串中有多长的相同前后缀。</p><p>首先我们要明确前缀和后缀的概念：除了最后一个字符的字符串其余部分都可称之为前缀；除了第一个字符的字符串其余部分都可以称之为后缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">字符串：abba</span><br><span class="line">最长前缀：abb</span><br><span class="line">最长后缀：bba</span><br><span class="line"></span><br><span class="line">字符串：aa</span><br><span class="line">最长前缀：a</span><br><span class="line">最长后缀：a</span><br><span class="line"></span><br><span class="line">字符串：a</span><br><span class="line">没有前缀和后缀</span><br></pre></td></tr></table></figure><p>相同前后缀就是看前缀和后缀的相同部分；比如字符串<code>abba</code>，前缀和后缀中只有字符串a是相同的，所以这个字符串的<strong>最长相同前后缀</strong>只有1。</p><p>而KMP算法中的next数组，就是存放这个最长相同前后缀数量的。以字符串<code>aabaaf</code>为例</p><table><thead><tr><th>下标</th><th>字符串</th><th>最大相同前后缀</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>0</td></tr><tr><td>1</td><td>aa</td><td>1</td></tr><tr><td>2</td><td>aab</td><td>0</td></tr><tr><td>3</td><td>aaba</td><td>1</td></tr><tr><td>4</td><td>aabaa</td><td>2</td></tr><tr><td>5</td><td>aabaaf</td><td>0</td></tr></tbody></table><p>对<code>aabaaf</code>字符串而言，最终得到的KMP算法next数组存放的就是<code>&#123;0,1,0,1,2,0&#125;</code>，这个数组就是该字符串的<strong>前缀表</strong>。</p><h2 id="1-2-next数组的作用"><a href="#1-2-next数组的作用" class="headerlink" title="1.2 next数组的作用"></a>1.2 next数组的作用</h2><p>那么这个next数组有什么作用呢？给出一个示例题目：让你在<code>aabaabaaf</code>中查找是否包含子字符串<code>aabaaf</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/89e406b57e7dc7d1cff721dee001bb7d.png" alt="image.png"></p><p>假设我们使用暴力法，当匹配到最后一个字符不相同时，会将源串下标+1，然后重新匹配子串。</p><p>但仔细观察你会发现，虽然这里源字符串和子串的最后一个字符f不匹配，但前面三个aab是已经匹配上的，我们完全可以从这个已经匹配上的字符串往后找，会发现最终可以找到子字符串<code>aabaaf</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/7d08ccd09b14e5e8a082473d6c3d4965.png" alt="image.png"></p><p>next数组就是用来解决这个问题的。当发现不匹配时，回溯到当前位置前一个的next数组中所对应元素的下标位置。下图中f是<strong>下标5</strong>，那么就需要回溯到<code>next[5-1]</code>的下标处，即回溯到子串中的<strong>下标2</strong>位置，重新开始匹配。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/1759f4d6ba0630f323c5fd1a5898cc3d.png" alt="image.png"></p><p>此时会发现下标2的位置和当前源串的字符相同，继续往后匹配子串，能找到完整的子串。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/e1655433e59d6d266480f4cdc5043b8d.png" alt="image.png"></p><p>通过next数组，把原本需要重新遍历的方式改为从上一个可以被匹配的位置重新开始匹配，就节省了时间。</p><h2 id="1-3-为什么？"><a href="#1-3-为什么？" class="headerlink" title="1.3 为什么？"></a>1.3 为什么？</h2><p>因为前缀表记录了最长相同前后缀的信息，当我们匹配不上的时候，找到前一个下标对应前缀表内的数据，就能得到当前字符以前的字符串是否有相同的前缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下标数 0 1 2 3 4 5</span><br><span class="line">字符串 a a b a a f</span><br><span class="line">前缀表 0 1 0 1 2 0</span><br></pre></td></tr></table></figure><p>当f匹配不上的时候，前一位在前缀表中为2，代表往前一共有2个字符（后缀），和整个字符串的<strong>前2位</strong>是相同的（即aabaa里面后缀的aa和前缀的aa相同，这里的前缀aa也是字符串的起始两个字符）。</p><p>这能告诉我们，刚刚匹配的字符串中，后缀部分匹配成功了2个aa（不然也走不到f这里来），可以把这个后缀的2个aa当作前缀的2个aa来处理，而指针只需要回溯到<strong>前缀aa的下一个字符</strong>重新开始匹配即可，对于数组而言，<strong>下一个字符的下标就是前缀表中的数字</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/7d08ccd09b14e5e8a082473d6c3d4965.png" alt="image.png"></p><h2 id="1-4-获取一个字符串的next数组"><a href="#1-4-获取一个字符串的next数组" class="headerlink" title="1.4 获取一个字符串的next数组"></a>1.4 获取一个字符串的next数组</h2><p>获取next数组有几种实现方式</p><ul><li>将前缀表中的数据全部减一；</li><li>将前缀表中的数据整体右移一位；</li><li>直接使用前缀表；</li></ul><p>个人更加喜欢直接使用前缀表的方式，因为原理就是这么学的，直接使用前缀表也比较好动懂一些。构造前缀表的代码如下，这个代码的逻辑可能没有那么好懂，<strong>最好是想办法背下来</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 初始化next数组第一位（第一位是不存在前缀和后缀，肯定为0）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">//遍历要从字符串第二位开始</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 后续需要取j-1作为下标的操作，所以j必须大于0</span></span><br><span class="line"><span class="comment">// 当j和i的字符二者不匹配的时候，就需要往前回溯</span></span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">&#123;</span><br><span class="line">j = next[j<span class="number">-1</span>]; <span class="comment">// 回溯到前一位下标在next数组中的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二者匹配，j+1</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值next数组</span></span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下，成功获得刚刚计算出来的前缀表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string test = <span class="string">&quot;aabaaf&quot;</span>;</span><br><span class="line"><span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">getNext</span>(next, test);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; test.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; next[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 2 0</span><br></pre></td></tr></table></figure><h1 id="2-leetcode-28-找到子串并返回起始下标"><a href="#2-leetcode-28-找到子串并返回起始下标" class="headerlink" title="2.leetcode-28-找到子串并返回起始下标"></a>2.leetcode-28-找到子串并返回起始下标</h1><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></p><p>题目：给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><p>这道题就是学习KMP算法的经典题目，思路前文已经描述过了，这里只给出代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 初始化next数组第一位（第一位是不存在前缀和后缀，肯定为0）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">//遍历要从字符串第二位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 后续需要取j-1作为下标的操作，所以j必须大于0</span></span><br><span class="line">            <span class="comment">// 当j和i的字符二者不匹配的时候，就需要往前回溯</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>]; <span class="comment">// 回溯到前一位下标在next数组中的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 二者匹配，j+1</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 赋值next数组</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子串为空肯定找不到</span></span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next,needle);</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i] != needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>]; <span class="comment">// 往前回溯一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j已经超出大小，说明子串完全匹配，成功。</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=needle.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>); <span class="comment">// 返回子串的起始下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>题解通过</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/52720e7926e1e664422d129534951804.png" alt="image.png"></p><h1 id="3-leetcode-459-重复的子字符串"><a href="#3-leetcode-459-重复的子字符串" class="headerlink" title="3.leetcode-459-重复的子字符串"></a>3.leetcode-459-重复的子字符串</h1><h2 id="3-1-题目"><a href="#3-1-题目" class="headerlink" title="3.1 题目"></a>3.1 题目</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459. 重复的子字符串</a></p><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="3-2-解释"><a href="#3-2-解释" class="headerlink" title="3.2 解释"></a>3.2 解释</h2><p>这道题同样可以用KMP算法来解决，因为前缀表间接包含了当前字符串是否能通过某个子串重复构成的功能。</p><p>假设目标字符串长度为len，前缀表为next数组，那么<code>next[len-1]</code>是前缀表的最后一位，保存了完整字符串的最长相同前后缀的长度。</p><p>$$<br>len % (len - next[len-1])&#x3D;0<br>$$</p><p>如果字符串的长度能 整除 字符串的长度减去<code>next[len-1]</code>，则代表字符串能被重复的子串循环构成！</p><p>观察下面这个字符串和它的前缀表，最后一位的数据是6，整个字符串的长度是9，这代表，整个字符串中，最长相同前缀和后缀有3个字符是重合的部分，且字符串的前缀3个字符和后缀3个字符都和中间这个重复的三个字符相同！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串 abcabcabc</span><br><span class="line">前缀表 000123456</span><br><span class="line"></span><br><span class="line">源串 abcabcabc</span><br><span class="line">前缀 abcabc</span><br><span class="line">后缀    abcabc</span><br></pre></td></tr></table></figure><p>如下所示，中间三个字符abc是在前后缀中重合的，而前缀第一个abc又能和后缀的前一个abc匹配上，后缀的末尾abc又能和中间重复的部分匹配上，则代表整个字符串就是由abc循环构成的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/ab8928003a833abad85bb828bc8f0075.png" alt="image.png"></p><p>而依据上述的公式计算，<code>9/(9-6) = 3</code>，可以被整除，即符合循环构成的条件！</p><p>描述的可能有点抽象，估计过几天回头看我自己也看不懂了……🤣</p><h2 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 初始化next数组第一位（第一位是不存在前缀和后缀，肯定为0）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">//遍历要从字符串第二位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 后续需要取j-1作为下标的操作，所以j必须大于0</span></span><br><span class="line">            <span class="comment">// 当j和i的字符二者不匹配的时候，就需要往前回溯</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>]; <span class="comment">// 回溯到前一位下标在next数组中的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 二者匹配，j+1</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 赋值next数组</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next,s);</span><br><span class="line">        <span class="type">size_t</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(next[len<span class="number">-1</span>] != <span class="number">0</span> &amp;&amp; (len%(len-next[len<span class="number">-1</span>])) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/66abe22355e25713fb484e3fdb3bcb5c.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>KMP算法有点不好理解，把next数组的构建背下来就差不多得了……</p>]]></content>
    
    
    <summary type="html">简单学习一下KMP算法</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="KMP" scheme="https://blog.musnow.top/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Linux64位环境下编译32位报错的解决办法</title>
    <link href="https://blog.musnow.top/posts/3573352712/"/>
    <id>https://blog.musnow.top/posts/3573352712/</id>
    <published>2024-02-24T03:04:53.000Z</published>
    <updated>2024-02-24T03:09:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如题，当我尝试在wsl2的ubuntu中使用<code>-m32</code>选项编译32位程序的时候，出现了下面的两种报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ -m32 test.cpp -o test1 &amp;&amp; ./test1</span><br><span class="line">In file included from test.cpp:1:</span><br><span class="line">/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: No such file or directory</span><br><span class="line">   27 | #include &lt;bits/libc-header-start.h&gt;</span><br><span class="line">      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ -m32 test.cpp -o test1 &amp;&amp; ./test1</span><br><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/11/libstdc++.so when searching for -lstdc++</span><br><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/11/libstdc++.a when searching for -lstdc++</span><br><span class="line">/usr/bin/ld: cannot find -lstdc++: No such file or directory</span><br><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/11/libstdc++.so when searching for -lstdc++</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>原因是当前缺少32位的开发库，需要安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-multilib g++-multilib libc6-dev-i386 -y</span><br></pre></td></tr></table></figure><p>安装后重试，编译成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ -m32  test.cpp -o test1 &amp;&amp; ./test1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>代码很简单，是一个打印指针大小的代码，在32位下指针大小是4，64位下指针大小是8；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> * ptr= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(ptr));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多说明"><a href="#更多说明" class="headerlink" title="更多说明"></a>更多说明</h2><p>在linux下可以使用下面的命令查看你的系统位数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ getconf LONG_BIT</span><br><span class="line">64</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://stackoverflow.com/questions/60553541/usr-bin-ld-skipping-incompatible-usr-lib-gcc-x86-64-linux-gnu-9-libstdc-a-w">assembly - &#x2F;usr&#x2F;bin&#x2F;ld: skipping incompatible &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;9&#x2F;libstdc++.a when searching for -lstdc++ &#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lstdc++ - Stack Overflow</a></p>]]></content>
    
    
    <summary type="html">64位linu下编译32位程序出错，提示skipping incompatible</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Linux" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
    <category term="ubuntu" scheme="https://blog.musnow.top/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>【项目】高并发内存池项目的学习</title>
    <link href="https://blog.musnow.top/posts/4231483511/"/>
    <id>https://blog.musnow.top/posts/4231483511/</id>
    <published>2024-02-20T13:32:14.000Z</published>
    <updated>2024-03-03T06:03:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下类似于谷歌tcmalloc的高并发内存池。</p><p>项目代码都在<a href="https://github.com/musnows/MemoryPool">GitHub</a>上了，本文是对项目开发过程中的设计学习以及遇到问题的解决方法。</p><p>备注：当前项目在Linux上运行有些问题（mmap地址对齐没有解决），所以暂时只能在win32上开发！</p><h1 id="1-什么是内存池"><a href="#1-什么是内存池" class="headerlink" title="1.什么是内存池"></a>1.什么是内存池</h1><p>核心思想：内存池预先申请大块内存，当其他代码需要申请堆区内存时，不调用malloc&#x2F;new，而是调用我们自己实现的内存池的接口来申请内存。</p><p>因为内存池里面已经预先申请了很多内存，所以它可以直接分配给其他模块。而分配已经申请的内存会比使用malloc&#x2F;new向操作系统申请内存快非常多！</p><blockquote><p>这就好比在家里屯一点纸巾，当纸巾没了，直接用家里的纸巾，不用去小卖部重新买了，自然会快一些。</p></blockquote><p>而malloc&#x2F;new这些能适配所有场景的内存申请函数，自然会有额外的性能损失，当一个系统对性能要求很高的时候，使用内存池来预先申请+分配内存，就可以节省不少的时间，提高系统运行效率。</p><p>因为我们是自己实现了一个内存池，相当于替代了malloc&#x2F;new的工作，此时就可以使用底层的系统调用接口来直接向操作系统申请内存（malloc&#x2F;new会有额外封装）</p><ul><li>windows: VirtualAlloc</li><li>Linux: BRK或MMAP</li></ul><p>分配内存后，如果是C++的对象，可以通过<code>定位new</code>来调用类的构造函数。</p><h2 id="1-1-什么是高并发内存池"><a href="#1-1-什么是高并发内存池" class="headerlink" title="1.1 什么是高并发内存池"></a>1.1 什么是高并发内存池</h2><p>这个项目想实现的高并发内存池，就是在实现一个内存池的基础上，要满足多线程高并发请求空间申请时的性能和不出错。</p><p>这就涉及到多线程竞争以及加锁机制了，后文会补全。</p><h2 id="1-2-内碎片和外碎片"><a href="#1-2-内碎片和外碎片" class="headerlink" title="1.2 内碎片和外碎片"></a>1.2 内碎片和外碎片</h2><ul><li>内碎片：线程池内部分配了却没有使用的内存</li><li>外碎片：进程地址空间中，分配了多块内存，没有全部回收，导致剩余的内存虽然有足够大小，但不连续，无法实现大内存分配。</li></ul><p>内碎片和外碎片的场景如下图所示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/deb006a52f219b90261c67e6e6b9b35f.png" alt="image-20240224103722887"></p><p>假设一个进程申请了512KB的内存，却始终只使用了400KB，这里就出现了112KB的<strong>内碎片</strong>（申请了但没有完全使用）；</p><p>外碎片就看图吧，文字描述不清楚。</p><h1 id="2-定长内存池的实现"><a href="#2-定长内存池的实现" class="headerlink" title="2.定长内存池的实现"></a>2.定长内存池的实现</h1><h2 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h2><p>对于定长内存池而言，实现比较简单</p><ul><li>申请大块空间；</li><li>使用链表的方式来链接这些空间；</li><li>当申请的时候，释放链表头部的空间；</li><li>当销毁的时候，使用链表头插将空间复原到链表中；</li><li>当空间不够用的时候（链表为空）重新申请大块空间；</li></ul><p>为了实现链表的结构，定长内存池的单个空间分片的大小应该大于平台中一个指针的大小（不然没有办法实现指向下一块空间的地址）</p><p>因为内存池中的内存已经被分配出去了（会有碎片）所以内存池申请的内存是不能被释放的。如果一直没有模块从内存池中申请内存，就可能会产生内存的浪费。但这和内存池的功能<strong>相悖</strong>：如果系统申请内存的频率很低，那说明不需要内存池的介入。</p><p>只要最终内存池的进程是正常结束的，这些被申请的内存都会被操作系统托管和释放。</p><h2 id="2-2-图解"><a href="#2-2-图解" class="headerlink" title="2.2 图解"></a>2.2 图解</h2><p>初始化线程池时，会先申请大块内存，并用指针指向内存开头。</p><p>当有模块申请内存时，将内存开头的部分分配出去，并向后移动指针（同时还需将内存大小计数器给减小）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/5ee43b02da15875217fe4be4eb44b42f.png" alt="image-20240223130822219"></p><p>当回收内存时，将另外一个指针FREELIST指向被回收内存的开头，并将被回收内存的前4&#x2F;8个字节指向NULLPTR或者另外一个被回收的内存分片。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/55ba510435b21c825e098dfa5ff0e195.png" alt="image-20240223131544965"></p><p>当FREELIST为空，且用于标示预先申请的大块内存剩余容量的size为0的时候，就需要重新申请内存了（代表当前线程池已经没有可分配的内存）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/7224a6c2f4a743dd0098d0fe83f108c8.png" alt="image-20240223132634407"></p><p>定长内存池的思路还是比较简单的。</p><h2 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixMemoryPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T* <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* obj = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先把还回来内存块对象，再次重复利用</span></span><br><span class="line"><span class="keyword">if</span> (_freeList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* next = *((<span class="type">void</span>**)_freeList);</span><br><span class="line">obj = (T*)_freeList;</span><br><span class="line">_freeList = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 剩余内存不够一个对象大小时，则重新开大块空间</span></span><br><span class="line"><span class="keyword">if</span> (_remainBytes &lt; <span class="built_in">sizeof</span>(T))</span><br><span class="line">&#123;</span><br><span class="line">_remainBytes = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">_memory = (<span class="type">char</span>*)<span class="built_in">malloc</span>(_remainBytes);</span><br><span class="line"><span class="keyword">if</span> (_memory == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj = (T*)_memory;</span><br><span class="line"><span class="type">size_t</span> objSize = <span class="built_in">sizeof</span>(T) &lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) ? <span class="built_in">sizeof</span>(<span class="type">void</span>*) : <span class="built_in">sizeof</span>(T);</span><br><span class="line">_memory += objSize;</span><br><span class="line">_remainBytes -= objSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位new，显示调用T的构造函数初始化</span></span><br><span class="line"><span class="keyword">new</span>(obj)T; <span class="comment">// 即便是POD类型也是有个构造函数的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(T* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 显示调用析构函数</span></span><br><span class="line">obj-&gt;~<span class="built_in">T</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插，使用void*强转能保证转换后的空间一定是个指针的大小</span></span><br><span class="line">*(<span class="type">void</span>*)obj = _freeList; <span class="comment">// 指向原本的freelist开头的地址</span></span><br><span class="line">_freeList = obj; <span class="comment">// 更新头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* _memory = <span class="literal">nullptr</span>; <span class="comment">// 指向大块内存的指针</span></span><br><span class="line"><span class="type">size_t</span> _remainBytes = <span class="number">0</span>; <span class="comment">// 大块内存在切分过程中剩余字节数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* _freeList = <span class="literal">nullptr</span>; <span class="comment">// 还回来过程中链接的自由链表的头指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-性能测试"><a href="#2-4-性能测试" class="headerlink" title="2.4 性能测试"></a>2.4 性能测试</h2><p>下面用循环申请内存的方式来测试一下这个定长内存池的效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _val;</span><br><span class="line">TreeNode* _left;</span><br><span class="line">TreeNode* _right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TreeNode</span>()</span><br><span class="line">:_val(<span class="number">0</span>)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Rounds = <span class="number">5</span>; <span class="comment">// 申请释放的轮次</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N = <span class="number">100000</span>; <span class="comment">// 每轮申请释放多少次</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;TreeNode*&gt; v1;</span><br><span class="line">v1.<span class="built_in">reserve</span>(N);</span><br><span class="line"><span class="comment">// new的耗时测试</span></span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; Rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="keyword">new</span> TreeNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> v1[i];</span><br><span class="line">&#125;</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">std::vector&lt;TreeNode*&gt; v2;</span><br><span class="line">v2.<span class="built_in">reserve</span>(N);</span><br><span class="line"><span class="comment">// 定长内存池的耗时测试</span></span><br><span class="line">FixMemoryPool&lt;TreeNode&gt; TNPool;</span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; Rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(TNPool.<span class="built_in">New</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">TNPool.<span class="built_in">Delete</span>(v2[i]);</span><br><span class="line">&#125;</span><br><span class="line">v2.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new cost time:&quot;</span> &lt;&lt; end1 - begin1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;memory pool cost time:&quot;</span> &lt;&lt; end2 - begin2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用vs2019的x86-debug模式下运行，二者的时间消耗已经对比明显</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new cost time:195</span><br><span class="line">memory pool cost time:100</span><br></pre></td></tr></table></figure><p>使用x86-release的模式运行，时间消耗差距就更大了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new cost time:21</span><br><span class="line">memory pool cost time:1</span><br></pre></td></tr></table></figure><p>这就是线程池存在的意义。</p><h1 id="3-整体框架设计"><a href="#3-整体框架设计" class="headerlink" title="3.整体框架设计"></a>3.整体框架设计</h1><p>简单实现了一个定长的内存池，下面就要学习一下如何实现一个高并发的内存池。谷歌的tcmalloc在多线程环境下会有更好的性能，我们模拟设计时也需要考虑相关的问题：</p><ul><li>性能应该优于malloc&#x2F;new；</li><li>多线程环境下竞争和锁申请问题；</li><li>内存碎片问题；</li></ul><p>最终的设计主要由下面三个部分构成</p><ol><li>ThreadCache：供每个线程独有，用于小于<code>256KB</code>的内存分配，因为每个线程独有一个ThreadCache，线程从这里申请内存时不需要加锁，效率高；</li><li>CentralCache：中心缓存供所有线程共享，ThreadCache按需从CentralCache中获取内存。CentralCache在合适的时候回收分配给线程的ThreadCache，避免某个线程占用太多未使用的内存，达到多个线程均衡调度的目的。CentralCache存在多线程竞争，需要加锁；</li><li>PageCache：以页为单位向操作系统申请内存。当CentralCache没有内存可分配时会向PageCache申请，PageCache会向操作系统申请一定的Page的内存放入<code>span</code>对象，这个大块内存会在<code>span</code>内部切割成多个定长大小的小块内存，最终给CentralCache的是<code>span</code>对象。当一个<code>span</code>的内部小块内存都被回收后，PageCache会回收CentralCache中满足条件的内存<code>span</code>对象，并合并相邻的页，组成更大的页，缓解内存碎片问题；</li></ol><p>下图是这个框架的示意</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/c03c4843d4f6b153fc536709b8864c05.png" alt="image-20240223160514186"></p><p>三层设计后，每一层的工作都不一样了</p><ul><li>ThreadCache：为线程分配空间；</li><li>CentralCache：为ThreadCache分配空间并回收部分空间；</li><li>PageCache：分页管理和向操作系统获取空间；</li></ul><p>其中，只有多个ThreadCache同时没内存需要向CentralCache申请的时候，才会出现<strong>加锁</strong>的问题。这种情况其实是不多的，所以CentralCache并不会有特别大的锁竞争问题。</p><p>而且，大部分情况下申请内存大小都不会大于256KB，所以ThreadCache是基本能满足线程申请空间的需求的。上述二者结合，就提高了多线程并发的效率。</p><h1 id="4-ThreadCache设计"><a href="#4-ThreadCache设计" class="headerlink" title="4.ThreadCache设计"></a>4.ThreadCache设计</h1><p>ThreadCache只对一个线程服务，它的设计思路和定长内存池其实是非常相似的。不过ThreadCache需要支持不定长内存的分配，需要对回收内存的FreeList做设计上的更正。</p><h2 id="4-1-哈希桶"><a href="#4-1-哈希桶" class="headerlink" title="4.1 哈希桶"></a>4.1 哈希桶</h2><p>为了更加方便的管理不同大小的内存空间申请，ThreadCache采用了哈希桶的方式，以一定空间为分割，链接不同大小的回收内存，类似多个不同大小的定长自由链表。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/5a0502f4b16d03e0f207c0c4971da9bd.png" alt="image-20240224104548066"></p><p>当线程需要8字节以下空间时，就从8字节的桶里面分配给它；当进程需要8到16字节空间时，就从16字节的桶里面分配，以此类推。</p><p>很明显，这种方式会产生<strong>内碎片</strong>，比如申请5字节空间，ThreadCache还是会从8字节的桶中分配给它，出现了3字节的空间浪费。</p><p>但这个空间浪费是必须接受的，否则就需要用更加复杂的方式来管理回收的空间（比如在内存中记录自己的大小），分配的时候还需要遍历找到合适大小的内存来分配，效率反而会降低。</p><h2 id="4-2-分配映射规则"><a href="#4-2-分配映射规则" class="headerlink" title="4.2 分配映射规则"></a>4.2 分配映射规则</h2><p>但是，如果整个哈希桶都用8字节来做分割，最终整个哈希桶的数组部分就会非常非常长。<br>$$<br>256KB&#x2F;8B &#x3D; 32768<br>$$<br>所以，最终需要采用一个让内碎片尽量保持在10%左右的哈希映射算法。</p><table><thead><tr><th>字节区间</th><th>对齐方式</th><th>哈希桶下标区间</th></tr></thead><tbody><tr><td>[1, 128]</td><td>8B</td><td>[0,16)</td></tr><tr><td>[128+1, 1024]</td><td>16B</td><td>[16,72)</td></tr><tr><td>[1024+1, 8*1024]</td><td>128B</td><td>[72,128)</td></tr><tr><td>[8*1024+1, 64*1024]</td><td>1024B</td><td>[128,184)</td></tr><tr><td>[64*1024+1,256*1024]</td><td>8*1024B</td><td>[184,208)</td></tr></tbody></table><p>这个表的含义是，当字节范围在1到128之间时，哈希桶的每个下标对应的freelist内存大小相差<strong>8字节</strong>；当字节范围在129到1024字之间时，哈希桶每个下标对应的freelist内存大小相差<strong>16字节</strong>……</p><p>这样就可以控制内碎片在10%左右，以129字节到1024字节为例，最终映射的哈希桶如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/afba0bd136dbd8bed517f978195b3955.png" alt="image-20240226093850295"></p><p>当申请129到144字节之间的空间时，会分配144字节的内存块给线程。此时最大的空间浪费就是这<strong>144字节中只使用了129字节</strong>。浪费率大概是<code>10.5%</code>；其他区间的内碎片浪费率也是用这个方式计算。</p><p>注意：当我们考虑内碎片时，只考虑线程池设计会造成的内碎片问题，而不考虑线程本身申请了却不用造成的空间浪费（这是不可预期的，且和内存池的设计没有关系）。</p><h2 id="4-3-代码-分配内存大小"><a href="#4-3-代码-分配内存大小" class="headerlink" title="4.3 代码-分配内存大小"></a>4.3 代码-分配内存大小</h2><p>下面是<strong>某个对齐区间内</strong>，计算需要分配的空间大小的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size: 申请的块大小</span></span><br><span class="line"><span class="comment">// align: 当前对齐大小</span></span><br><span class="line"><span class="type">size_t</span> _RoundUp(<span class="type">size_t</span> size, <span class="type">size_t</span> align)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> returnSize;</span><br><span class="line">    <span class="keyword">if</span>(size % align == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        returnSize = size; <span class="comment">// 能直接模代表就是需要的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他，计算对齐区间内的最大值</span></span><br><span class="line">        returnSize = (size/align + <span class="number">1</span>) * align;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个函数的逻辑计算，当我们需要申请130字节空间时（对齐大小是16字节，应该返回144字节），这个函数计算出来的结果也是144。<br>$$<br>returnSize &#x3D; (130&#x2F;16 +1) * 16 &#x3D; 144<br>$$<br>这个算法还有个更取巧的写法，用到了位运算，不好想不出来。位运算的效率会略高于乘除法，所以采用这种设计能提高一定的效率（已经是很深层的问题了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _RoundUp(<span class="type">size_t</span> size, <span class="type">size_t</span> align)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((size + align - <span class="number">1</span>) &amp; (~(align - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法是怎么实现的呢？以区间9到16为例（都需要分配16字节的空间），假设需要分配10字节空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">10 + 8 - 1 = 17</span><br><span class="line">align - 1 = 8-1 = 7</span><br><span class="line"></span><br><span class="line">7的二进制如下</span><br><span class="line">0000 0111</span><br><span class="line">7的二进制取反后</span><br><span class="line">1111 1000</span><br><span class="line">17的二进制</span><br><span class="line">0001 0001</span><br><span class="line"></span><br><span class="line">二者相与，得到的结果就是16</span><br><span class="line">1111 1000</span><br><span class="line">0001 0001</span><br><span class="line">——————————</span><br><span class="line">0001 0000</span><br></pre></td></tr></table></figure><p>这种牛逼的位运算方法我可想不出来……😣</p><p>有了单个对齐区间内计算大小的函数，剩下要做的就是把每个区间和对应的对齐大小给传参进入这个函数就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">RoundUp</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">128</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _RoundUp(size,<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _RoundUp(size,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= (<span class="number">8</span>*<span class="number">1024</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _RoundUp(size,<span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= (<span class="number">64</span>*<span class="number">1024</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _RoundUp(size,<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= (<span class="number">256</span>*<span class="number">1024</span>))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> _RoundUp(size,<span class="number">8</span>*<span class="number">1024</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不是threadCache负责的范围了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-代码-计算哈希下标"><a href="#4-4-代码-计算哈希下标" class="headerlink" title="4.4 代码-计算哈希下标"></a>4.4 代码-计算哈希下标</h2><p>除了计算需要分配的内存大小，还需要计算这个内存应该链接在哈希桶的哪一个下标。</p><ul><li>指定下标的freelist有剩余空间时直接分配；</li><li>如果没有，则从预先申请的大块内存中申请；</li></ul><p>单个区间内计算下标偏移量的方式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size: 申请的块大小</span></span><br><span class="line"><span class="comment">// align: 当前对齐大小</span></span><br><span class="line"><span class="type">size_t</span> _Index(<span class="type">size_t</span> size, <span class="type">size_t</span> align)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size % align == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> size / align - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> size / align;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用位运算时可以采用另外一个巧妙的设计方式。将1左移<code>align_shift</code>位相当于计算2的<code>align_shift</code>次方；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// align_shift是当前对齐大小是2的几次方，如果对齐大小是8，则传参3</span></span><br><span class="line"><span class="type">size_t</span> _Index(<span class="type">size_t</span> size, <span class="type">size_t</span> align_shift)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((size + (<span class="number">1</span> &lt;&lt; align_shift) - <span class="number">1</span>) &gt;&gt; align_shift) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用位运算的函数，最终的计算代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Index</span><span class="params">(<span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(bytes &lt;= <span class="number">256</span>*<span class="number">1024</span>); <span class="comment">// 不能超出ThreadCache的最大服务范围</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用数组表示每个区间有多少个链</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> group_array[<span class="number">4</span>] = &#123; <span class="number">16</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (bytes &lt;= <span class="number">128</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">1024</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes - <span class="number">128</span>, <span class="number">4</span>) + group_array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">8</span> * <span class="number">1024</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes - <span class="number">1024</span>, <span class="number">7</span>) + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">64</span> * <span class="number">1024</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes - <span class="number">8</span> * <span class="number">1024</span>, <span class="number">10</span>) + group_array[<span class="number">2</span>] + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">256</span> * <span class="number">1024</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes - <span class="number">64</span> * <span class="number">1024</span>, <span class="number">13</span>) + group_array[<span class="number">3</span>] + group_array[<span class="number">2</span>] + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 不是threadCache负责的范围了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-ThreadCache分配-x2F-回收内存"><a href="#4-5-ThreadCache分配-x2F-回收内存" class="headerlink" title="4.5 ThreadCache分配&#x2F;回收内存"></a>4.5 ThreadCache分配&#x2F;回收内存</h2><p>这部分比较简答，哈希桶对应的FreeList里面有就直接分配，没有就去找CentralCache要。</p><p>这里使用assert进行申请大小的判断，是因为ThreadCache不应该接受超过256KB的请求（如果出现了说明外部调用的代码的处理有问题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> MAX_BYTES = <span class="number">256</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::Allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES);</span><br><span class="line"><span class="type">size_t</span> alignSize = <span class="built_in">RoundUp</span>(size); <span class="comment">// 计算大小</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">Index</span>(size); <span class="comment">// 计算下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_freeLists[index].<span class="built_in">Empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _freeLists[index].<span class="built_in">Pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 向centralcache申请内存</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FetchFromCentralCache</span>(index, alignSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::Deallocate</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ptr);</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找对映射的自由链表桶，插入内存</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">Index</span>(size); <span class="comment">// 计算下标</span></span><br><span class="line">_freeLists[index].<span class="built_in">Push</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-TLS-线程局部变量"><a href="#4-6-TLS-线程局部变量" class="headerlink" title="4.6 TLS-线程局部变量"></a>4.6 TLS-线程局部变量</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>TLS的全称是Thread Local Storage，使用特殊的关键字来修饰一个变量，可以让这个变量变成一个只有某个线程可以访问的独立成员，其他线程无法访问。</p><p>比如我有个变量A，那么多个线程都会有一个自己的变量A，他们都可以访问这个A，但访问的并不是同一个，也就不涉及到加锁问题。</p><p>对于线程独有的ThreadCache而言，我们就可以使用这个特性来让每个线程独有一个变量，避免构建ThreadCache的时候还需要辨别当前线程号或加锁操作。</p><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> _declspec(thread) ThreadCache* TLSThreadCache = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>这里使用<code>_declspec(thread)</code>就是windows平台下声明TLS变量的方式，加上static是为了避免在包含头文件的时候该全局变量声明被复制多次导致重复。</p><blockquote><p>微软官方文档：<a href="https://learn.microsoft.com/en-us/cpp/c-language/thread-local-storage?view=msvc-170&redirectedfrom=MSDN">https://learn.microsoft.com/en-us/cpp/c-language/thread-local-storage?view=msvc-170&amp;redirectedfrom=MSDN</a></p></blockquote><p>用下面的代码对TLS变量做一个简单的测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line">_declspec(thread) <span class="type">int</span>* TLStest = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> test_func = []() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;before:%p\n&quot;</span>, TLStest);</span><br><span class="line"><span class="keyword">if</span> (TLStest == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">TLStest = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after:%p\n&quot;</span>, TLStest);</span><br><span class="line">         <span class="keyword">delete</span> TLStest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(test_func)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(test_func)</span></span>;</span><br><span class="line">t1.<span class="built_in">detach</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用VS2019执行，输出结果如下所示，两个线程调用函数中的打印和初始化，能发现最终初始化出来的地址是不同的，而且<code>&amp;TLStest</code>的地址也不一样，说明TLStest变量被每个线程独有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[before] TLStest:00000000  &amp;TLStest:00ACCEBC</span><br><span class="line">[after] TLStest:00ACE0E0  &amp;TLStest:00ACCEBC</span><br><span class="line">[before] TLStest:00000000  &amp;TLStest:00ACCDE4</span><br><span class="line">[after] TLStest:00ACE1D0  &amp;TLStest:00ACCDE4</span><br></pre></td></tr></table></figure><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>在Linux下的线程本地存储可以用<code>__thread</code>关键字声明。但需要注意，这个关键字只能声明POD（内置类型），不能声明自定义的class对象。当然，自定义class的指针类型不在此列，因为<code>myclass*</code>这类指针类型始终是一个指针，属于C&#x2F;C++的内置类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread <span class="type">int</span>* TLStest = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>Linux下上述代码的测试结果，和windows下的效果类似。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ test.cpp  -o test1 &amp;&amp; ./test1</span><br><span class="line">[before] TLStest:(nil)  &amp;TLStest:0x7f63315cd638</span><br><span class="line">[after] TLStest:0x7f632c000f80  &amp;TLStest:0x7f63315cd638</span><br><span class="line">[before] TLStest:(nil)  &amp;TLStest:0x7f6330dcc638</span><br><span class="line">[after] TLStest:0x7f632c000f80  &amp;TLStest:0x7f6330dcc638</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>windows和linux下线程局部变量会有自己的存放位置和存放的地址，但有一个问题是，这些<strong>线程局部变量的地址</strong>是全进程共享的。</p><p>假设线程A知道了线程B的局部变量的地址，那么线程A就可以访问并修改它！因为这个地址是在进程地址空间中的，整个进程共享！</p><h1 id="5-CentralCache设计"><a href="#5-CentralCache设计" class="headerlink" title="5.CentralCache设计"></a>5.CentralCache设计</h1><h2 id="5-1-span跨度页"><a href="#5-1-span跨度页" class="headerlink" title="5.1 span跨度页"></a>5.1 span跨度页</h2><p>CentralCache的主体也采用了和ThreadCache类似的哈希桶的数据结构，但是CentralCache的哈希桶下面链接的不是内存碎片，而是包含一个大块内存的span对象（跨度页）。</p><p>在CentralCache的哈希桶中，8字节的桶链接的是<strong>内部内存被拆分成8字节小块</strong>的Span对象。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/cecdd3677b008340b43ad7cdd1c05647.png" alt="image-20240228092725430"></p><p>Span对象的基本成员如下所示，在win32环境下，一个Span对象是32字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PAGE_ID;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> PAGE_ID;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Span</span>&#123;</span><br><span class="line">    PAGE_ID _pageId; <span class="comment">//页号</span></span><br><span class="line">    <span class="type">size_t</span> _n; <span class="comment">//页的数量</span></span><br><span class="line">    </span><br><span class="line">    Span* _next = <span class="literal">nullptr</span>;</span><br><span class="line">    Span* _prev = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>* _list = <span class="literal">nullptr</span>; <span class="comment">// 链接span拆分的小块内存</span></span><br><span class="line">    <span class="type">size_t</span> _useCount = <span class="number">0</span>; <span class="comment">// 使用数量，为0代表没有被使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> _objSize; <span class="comment">// 拆分的小块内存的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> _isUse = <span class="literal">false</span>; <span class="comment">// 是否在占用</span></span><br><span class="line">    <span class="comment">// 当Span被分配给CentralCache后设置为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个对象做一定说明</p><ul><li>假设我们给定一个Span包含512KB的内存（内存是由PageCache申请的）；</li><li>那么8B的Span就是将这个512KB拆分成8B链接在Span对象内部的list中</li><li>256KB的Span就是将512KB拆分成两个256KB链接在Span对象内部的list中</li><li>当ThreadCache申请内存时，会从对应哈希桶下标位置的第一个Span对象中分配内存给它，如果第一个Span对象没有剩余内存了，就往后找第二个Span对象申请内存来分配给ThreadCache；</li><li>当一个Span的useCount为0时，说明这个Span内部的内存都是没有被使用的，它可以被PageCache回收；</li><li>PageCache根据Span中的pageID来确定它的<strong>页号</strong>，可以和相邻页号的Span内存合并成更大的内存，暂为管理或释放给操作系统，一定程度上缓解内存碎片问题。</li></ul><p>你可能会有一个疑问，Span对象中似乎没有用于存放大块内存的指针（内部的list并不是用来存大块内存起始地址的，而需要CentralCache来制作<strong>内存链表</strong>），当PageCache分配给CentralCache的时候，CentralCache要怎么知道这个Span的起始地址呢？</p><ul><li><strong>页号</strong>是直接用内存地址强转成整形，除以8KB来计算的；</li><li>只需要将页号乘以8KB（即<code>8*1024</code>），就能得到这个Span所对应的内存起始地址；</li><li><strong>页号+页的数量</strong>即可得到内存最后一页的起始地址，再加上8KB即为大块内存的末尾；</li></ul><p>用这种方式，我们就节省了一个多余的指针。页号+页的数量也是后续PageCache回收内存时辨别两个Span对象所保存的页是否相邻的重要判据。</p><h2 id="5-2-桶锁"><a href="#5-2-桶锁" class="headerlink" title="5.2 桶锁"></a>5.2 桶锁</h2><p>为了进一步细化锁的粒度，CentralCache采用桶锁的设计，即每个不同大小的哈希桶下标都会有一个对应的锁</p><ul><li>线程A向CentralCache申请16B内存，线程B向CentralCache申请128KB内存，二者不在同一个哈希桶下标位置，所以不存在竞争也不需要加锁；</li><li>线程A和线程B都向CentralCache申请16B内存，此时需要加锁；</li></ul><p>定义桶锁比较简单，因为Span需要一个单独的List来管理（不能使用原本定长内存池里面的freelist对象了），我们在单独实现的SpanList里面加一个mutex，POP和PUSH的时候加锁&#x2F;解锁就可以了。</p><h2 id="5-3-向PageCache申请-x2F-释放内存"><a href="#5-3-向PageCache申请-x2F-释放内存" class="headerlink" title="5.3 向PageCache申请&#x2F;释放内存"></a>5.3 向PageCache申请&#x2F;释放内存</h2><p>当CentralCache中的桶没有指定大小Span的时候，就需要去PageCache中申请内存。申请时需要给定申请的大小，随后PageCache会将包含对应大小内存的Span对象返还给CentralCache，由CentralCache来负责将这块内存切成小块并链接Span内部的list。</p><p>当某个Span对象下useCount为0的时候，CentralCache就可以将其归还给PageCache。</p><h2 id="5-4-申请内存的数量限制"><a href="#5-4-申请内存的数量限制" class="headerlink" title="5.4 申请内存的数量限制"></a>5.4 申请内存的数量限制</h2><p>ThreadCache申请内存的时候会有一个“慢开始”的调节算法。即申请的时候，会略微申请多一些，但也不能一次性申请太多，否则很有可能用不完。</p><ul><li>当申请内存的size大的时候，一次向CentralCache申请的内存数量就越少（多少个size的内存）</li><li>当申请内存的size小的时候，一次向CentralCache申请的内存数量就会多一些</li></ul><p>每申请一次内存，就将对应FreeList的<strong>阈值</strong>调高一些，这样内存池刚启动的时候，申请的内存就会少一些，运行一段时间后，认为系统对内存的需求会更加频繁，一次要的内存就会多一些。</p><h2 id="5-5-回收ThreadCache中的内存"><a href="#5-5-回收ThreadCache中的内存" class="headerlink" title="5.5 回收ThreadCache中的内存"></a>5.5 回收ThreadCache中的内存</h2><p>因为ThreadCache是用freelist来管理内存的，所以CentralCache的回收接口也是以一个链表的区间来回收。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleaseListToSpans</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>当ThreadCache检测到当前某个哈希桶对应的freelist长度已经大于一次性会申请的内存长度（上文提到的FreeList<strong>阈值</strong>）时，就会释放一部分内存给CentralCache。这种情况说明ThreadCache保存的内存已经有点多了，可能会用不完。</p><h1 id="6-PageCache设计"><a href="#6-PageCache设计" class="headerlink" title="6.PageCache设计"></a>6.PageCache设计</h1><h2 id="6-1-基本架构"><a href="#6-1-基本架构" class="headerlink" title="6.1 基本架构"></a>6.1 基本架构</h2><p>PageCache的哈希桶和CentralCache基本一致，都是链接的Span对象，只不过PageCache中是通过页面数量作为哈希下标的选址的。</p><p>比如一个Span中有2页，那么它就会被映射到下标为2的哈希桶中（只不过这样会导致下标为0的哈希桶空置，也可以在哈希函数里面将页面数量减一来避免这个浪费）</p><p>除了哈希桶外，PageCache中还有一个<code>unordered_map</code>用于映射页号和Span对象地址，这样能让后续PageCache回收Span的时候，更快地找到这个Span<strong>页号相邻</strong>的其他Span对象的地址。</p><p>注意，这个<code>unordered_map</code>中需要映射<strong>一个Span对应的所有页号</strong>和Span地址的对应关系，不能只保存起始页号和Span地址的关系。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/9bab99b19e081adbb08dbbdc4e2fd414.png" alt="image-20240229104149463"></p><h2 id="6-2-申请内存"><a href="#6-2-申请内存" class="headerlink" title="6.2 申请内存"></a>6.2 申请内存</h2><p>当PageCache的哈希桶中没有剩余Span时，就会向操作系统申请内存。</p><p>PageCache将以8KB为一个页，去向操作系统申请内存。且为了提高申请内存的效率，会直接使用系统底层接口来获取内存（Windows下VirutalAlloc，Linux下btk和mmap）</p><p>申请内存后，PageCache会new一个Span对象，并设置对应的页号和页的起始地址。随后是设置ID和Span对象地址的关系，并将Span返回给CentralCache。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k是页的个数</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">SystemAlloc</span>(k); <span class="comment">// 向系统申请内存</span></span><br><span class="line">Span* span = <span class="keyword">new</span> Span;      <span class="comment">// 获取一个Span对象</span></span><br><span class="line">span-&gt;_pageId = (PAGE_ID)ptr &gt;&gt; <span class="number">13</span>; <span class="comment">// 相当于除以8KB，得到页号</span></span><br><span class="line">span-&gt;_n = k; <span class="comment">//设置页的个数</span></span><br></pre></td></tr></table></figure><h3 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h3><p>当然，这里还有一个不太合适的地方。对于一个高并发的内存池而言，我们预期应该是会<strong>有很多个Span对象的构建</strong>的（即便我们最终的测试环境可能达不到这个并发量），所以这里应该将<code>new Span</code>改成使用上文提到的<strong>定长内存池</strong>来处理，可以在PageCache初始化的时候就申请一部分内存，供未来新建Span对象的时候使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span* span = _spanPool.<span class="built_in">New</span>();<span class="comment">// 使用定长内存池来分配内存</span></span><br></pre></td></tr></table></figure><p>只需要在PageCache中包括一个<strong>定长内存池</strong>的对象即可。</p><h2 id="6-3-分配内存"><a href="#6-3-分配内存" class="headerlink" title="6.3 分配内存"></a>6.3 分配内存</h2><p>分配内存的流程如下</p><ol><li>判断哈希桶中对应页面大小的Span是否存在，存在直接分配；</li><li>不存在则向操作系统申请内存，而且每次都会按<strong>最大页面</strong>来申请（最大页128）；</li><li>申请大块内存后，将其拆分成一个CentralCache需要的Span和另外一个剩余的Span；</li><li>将剩余的Span放入哈希表，CentralCache需要的Span返回；</li></ol><p>上述步骤中的第三步就是<strong>拆分大Span对象</strong>的情况，比如当10页的Span没有时，将一个128页的Span拆分成10页和118页的。这时候，一个线程可能会访问PageCache中哈希桶<strong>多个下标位置</strong>的元素，所以PageCache不能采用桶锁，而采用<strong>全局锁</strong>（访问PageCache的时候加锁，访问结束解锁）。</p><p>另外，<strong>拆分Span对象</strong>是一个频率比较高的动作，这也是为什么PageCache中会出现多个可以进行合并的相邻页面的Span对象。</p><p>如果PageCache中不是一次性申请最大页面的内存，而是按需申请，此时操作系统给定的内存很大概率和之前的<strong>并不是相邻</strong>的，那PageCache自然就没有办法“合并相邻页面”，这也会导致操作系统中内存外碎片较多，且难以处理。</p><h2 id="6-4-回收和合并"><a href="#6-4-回收和合并" class="headerlink" title="6.4 回收和合并"></a>6.4 回收和合并</h2><p>回收是CentralCache在Span中useCount为0的时候触发的，会将这个Span归还给PageCache。</p><p>PageCache收到一个Span后，需要进行合并操作</p><ul><li>从<code>unordered_map</code>中查找前一页的Span（当前页号减一），如果存在，判断是否可以进行合并；</li><li>查找后续的Span（当前页号加上页面数量再加一），如果存在，判断是否可以进行合并；</li></ul><p>因为这个<code>unordered_map</code>只在合并的时候需要使用，且每次合并时的查询操作都是当前span的页号减一，和当前span末尾页号+1，所以我们只需要给<code>unoreder_map</code>中设置<strong>当前页号以及末尾页号</strong>对应的span对象地址就行了！节省空间。</p><blockquote><p>为了保险起见和方便理解，项目中我还是采用了<strong>遍历页号范围设置全部</strong>的方式，这样能避免出现问题😂但会有空间浪费和效率损失。</p></blockquote><p>合并Span需要满足下面几个条件：</p><ul><li>Span的isUse为false，即这个Span是处于PageCache中暂未分配的</li><li>Span的页面数量加上当前Span的页面数量不超过128（超过后会超出哈希桶的下标，无法管理，自然不能合并）</li></ul><p>合并操作比较简单</p><ul><li>如果是合并前一个Span，将前一个Span的页面数量加上当前Span的页面数量即可；</li><li>如果是合并后一个Span，将当前Span的页面数量加上后一个Span的页面数量即可；</li><li>合并后要将<strong>被合并的Span对象</strong>释放，并将合并后的Span对象的isUse设置为false；</li><li>将合并后的Span对象更换正确的哈希桶下标位置链接（因为包含的页面数量改变了）；</li><li>修改<code>unodered_map</code>中的页号和Span对象地址的映射表；</li></ul><h2 id="6-5-超出256KB的内存申请"><a href="#6-5-超出256KB的内存申请" class="headerlink" title="6.5 超出256KB的内存申请"></a>6.5 超出256KB的内存申请</h2><p>因为低于256KB的内存都能被ThreadCache来处理，所以256KB也算是个分水岭。而PageCache中哈希桶最大的下标是128，即最大能托管的Span是1MB的内存，超出1MB的内存就得直接向操作系统申请了。</p><p>此时向内存池申请内存的流程会变成下面这样：</p><ul><li>申请低于256KB的调用ThreadCache的接口（包括分配和回收）；</li><li>大于256KB的调用PageCache的接口（包括分配和回收）；</li><li>当PageCache检测到申请的内存大于128Page的时候，直接向系统申请内存并返回；</li><li>当PageCache检测到回收的内存大于128Page的时候，直接释放给操作系统；</li></ul><p>到这里，内存池的主题框架就全部成型了，后续要做的就是性能测试和优化了。</p><h2 id="6-6-SpanList和子类"><a href="#6-6-SpanList和子类" class="headerlink" title="6.6 SpanList和子类"></a>6.6 SpanList和子类</h2><p>因为只有CentralCache需要用到桶锁，而PageCache同意需要使用SpanList，<strong>为了节省一定空间</strong>（PageCache的SpanList中的锁是没用的），CentralCache我使用了继承自父类SpanList的另外一个类型，在里面添加了一个mutex锁。</p><p>在32位windows环境下，mutex类的大小是48字节，128个SpanList，还是能节省一定空间的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(mtx) &lt;&lt; endl; <span class="comment">// 32位下是48字节</span></span><br></pre></td></tr></table></figure><h1 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h1><h2 id="7-1-申请和释放函数"><a href="#7-1-申请和释放函数" class="headerlink" title="7.1 申请和释放函数"></a>7.1 申请和释放函数</h2><p>虽然写了三成的设计，但是申请和释放函数并不能直接调用ThreadCache的函数，还需要另外一个函数来进行ThreadCache的构造，以及大于256KB内存的处理。</p><p>这里有个复用设计，即将PageCache中的页号对应Span对象指针的映射的<code>unordered_map</code>来确定当前申请的内存的<strong>大小</strong>，这样就不需要用户主动传入参数了（主动传入容易出现内存泄漏和处理问题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">ConcurrentAlloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAX_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> alignSize = SizeClass::<span class="built_in">RoundUp</span>(size);</span><br><span class="line">        <span class="type">size_t</span> kpage = alignSize &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">        Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(kpage);</span><br><span class="line">        span-&gt;_objSize = size; <span class="comment">// 申请大内存没有拆分</span></span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span>* ptr = (<span class="type">void</span>*)(span-&gt;_pageId &lt;&lt; PAGE_SHIFT);</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为是线程局部变量，所以不需要加锁</span></span><br><span class="line">        <span class="keyword">if</span> (TLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里的static变量是全局可见的</span></span><br><span class="line">            <span class="type">static</span> FixedMemoryPool&lt;ThreadCache&gt; tcPool; </span><br><span class="line">            TLSThreadCache = tcPool.<span class="built_in">New</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TLSThreadCache-&gt;<span class="built_in">Allocate</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConcurrentFree</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">MapObjectToSpan</span>(ptr);</span><br><span class="line">    <span class="type">size_t</span> size = span-&gt;_objSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAX_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseSpanToPageCache</span>(span);</span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(TLSThreadCache);</span><br><span class="line">        TLSThreadCache-&gt;<span class="built_in">Deallocate</span>(ptr, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-单线程申请"><a href="#7-2-单线程申请" class="headerlink" title="7.2 单线程申请"></a>7.2 单线程申请</h2><p>用下面的代码测试，环境是windows x64；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestNormalAlloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">void</span>* p1 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">6</span>);</span><br><span class="line"><span class="type">void</span>* p2 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="type">void</span>* p3 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">12</span>);</span><br><span class="line"><span class="type">void</span>* p4 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">7000</span>);</span><br><span class="line"><span class="type">void</span>* p5 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">void</span>* p6 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">800</span>);</span><br><span class="line"><span class="type">void</span>* p7 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p5 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p6 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p7 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p1);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p2);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p3);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p4);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p5);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p6);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下，释放和申请都没有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">000001A864B20000</span><br><span class="line">000001A864B20008</span><br><span class="line">000001A864B22000</span><br><span class="line">000001A864B24000</span><br><span class="line">000001A864B22010</span><br><span class="line">000001A864B62000</span><br><span class="line">000001A864BA0000</span><br></pre></td></tr></table></figure><h2 id="7-3-多线程申请"><a href="#7-3-多线程申请" class="headerlink" title="7.3 多线程申请"></a>7.3 多线程申请</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultiThreadAlloc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">ConcurrentAlloc</span>(<span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1 - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error in MultiThreadAlloc1\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultiThreadAlloc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">ConcurrentAlloc</span>(<span class="number">20</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2 - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error in MultiThreadAlloc2\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试多线程处理是否有问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestMultiThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(MultiThreadAlloc1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(MultiThreadAlloc2)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">detach</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也没啥问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 - 34788 - 0000019E47920000</span><br><span class="line">2 - 14252 - 0000019E47922000</span><br><span class="line">1 - 34788 - 0000019E47920008</span><br><span class="line">1 - 34788 - 0000019E47920010</span><br><span class="line">2 - 14252 - 0000019E47922018</span><br><span class="line">1 - 34788 - 0000019E47920018</span><br><span class="line">2 - 14252 - 0000019E47922030</span><br><span class="line">1 - 34788 - 0000019E47920020</span><br><span class="line">1 - 34788 - 0000019E47920028</span><br><span class="line">1 - 34788 - 0000019E47920030</span><br><span class="line">1 - 34788 - 0000019E47920038</span><br><span class="line">1 - 34788 - 0000019E47920040</span><br><span class="line">1 - 34788 - 0000019E47920048</span><br><span class="line">2 - 14252 - 0000019E47922048</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，进行多线程测试的时候，一定要保证主线程退出时间<strong>晚于子线程</strong>（比如在<code>thread.join()</code>之后加sleep)，避免出现主线程提前退出的情况，这会导致子线程里面的<strong>打印不输出</strong>，或者其他的一些错误。</p><h2 id="7-4-定长内存池段错误解决"><a href="#7-4-定长内存池段错误解决" class="headerlink" title="7.4 定长内存池段错误解决"></a>7.4 定长内存池段错误解决</h2><p>刚开始运行的时候，<strong>多线程经常遇到段错误问题</strong>，而且不是每次都会出现。</p><blockquote><p>一般遇到这种不是每次都会出现的段错误，就可以考虑是否为<strong>多线程并发问题</strong>了。</p></blockquote><p>后来审查了一下，发现问题所在是申请内存函数中的ThreadCache初始化部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过TLS 每个线程无锁的获取自己的专属的ThreadCache对象</span></span><br><span class="line"><span class="keyword">if</span> (TLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> FixedMemoryPool&lt;ThreadCache&gt; tcPool; <span class="comment">// 这里的static变量是全局可见的</span></span><br><span class="line">    TLSThreadCache = tcPool.<span class="built_in">New</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化部分这里，设置了一个static的定长内存池，对于所有线程都是可见的。这时候就会出现多线程并发的问题（两个线程同时访问一个定长内存池）。</p><p>在PageCache中的Span定长内存池，<strong>因为访问PageCache的时候已经加过锁了</strong>，所以不会出现并发问题，但是这里的ThreadCache初始化时并没有加锁，就会出现多线程访问问题。</p><p>解决方案：</p><ol><li>在定长内存池中加上一个mutex成员，并进行加锁解锁操作；</li><li>在申请内存初始化ThreadCache的部分添加一个锁，并进行加锁解锁操作；</li></ol><p>采用第一种方式设置完毕后，连续运行了十几次，都没有再出现段错误问题了。</p><p>后续为了优化性能，我改为了第二种方式。因为PageCache中访问Span对象的定长内存池的加锁是无意义的，会有额外性能损失。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过TLS 每个线程无锁的获取自己的专属的ThreadCache对象</span></span><br><span class="line"><span class="keyword">if</span> (TLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// C++11后static变量初始化时线程安全</span></span><br><span class="line">    <span class="type">static</span> FixedMemoryPool&lt;ThreadCache&gt; tcPool; <span class="comment">// 这里的static变量是全局可见的</span></span><br><span class="line">    <span class="comment">// 在new之前加锁就可以了</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(TLSThreadCacheMtx)</span></span>;</span><br><span class="line">    TLSThreadCache = tcPool.<span class="built_in">New</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-Linux下接口补全"><a href="#8-Linux下接口补全" class="headerlink" title="8.Linux下接口补全"></a>8.Linux下接口补全</h1><p>前文所述的接口都是在Windows下使用的，下面要对Linux中与Windows不一致的地方进行补全。</p><h2 id="8-1-PageID的typedef"><a href="#8-1-PageID的typedef" class="headerlink" title="8.1 PageID的typedef"></a>8.1 PageID的typedef</h2><p>之前在Windows下是用<code>_WIN32</code>和<code>_WIN64</code>这两个宏来确定平台是32位还是64位的，但是Linux下没有类似的宏。最终采用如下方式来确认Linux下平台的位数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为64位和32位中内存地址的长度不一样，所以对应类型也得不一样</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64 <span class="comment">// 64位的win才会有这个宏</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PageID;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32 <span class="comment">// 32和64位的win都会有这个宏</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> PageID;</span><br><span class="line"><span class="comment">// 后续还需要插入一些Linux的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64 <span class="comment">// 64位的Linux</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PageID;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// 32位的Linux</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> PageID;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里使用了<code>__WORDSIZE</code>这个宏，它其实比较通用，含义是当前平台下指针的大小（单位是比特），32位平台下指针是32比特4字节，64位平台下指针是64比特8字节。</p><h2 id="8-2-mmap申请和释放内存"><a href="#8-2-mmap申请和释放内存" class="headerlink" title="8.2 mmap申请和释放内存"></a>8.2 mmap申请和释放内存</h2><p>在Linux下使用mmap和munmap两个接口来申请和释放内存，具体使用方式参考man手册。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>mmap的参数说明：</p><ul><li>第一个参数addr: 指定需要申请的内存在操作系统中的偏移量，设置为NULL让操作系统自行选择；</li><li>第二个参数length: 指定申请内存的比特数</li><li>第三个参数prot: 指定申请内存的权限（读写）</li><li>第四个参数flags: 指定申请内存的方式</li><li>第五个参数fd: 申请的内存是否需要和某个文件描述符绑定，<code>-1</code>代表不绑定；</li><li>第六个参数offset：指定偏移，对于匿名映射通常设置为0；</li></ul><p>释放内存的munmap接口就比较简单了，传入内存的指针和长度就可以了。</p><p>示例代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> bytes = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// PROT_READ | PROT_WRITE 指定读写权限</span></span><br><span class="line"><span class="comment">// MAP_PRIVATE | MAP_ANONYMOUS 私有和匿名映射</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, bytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">munmap</span>(ptr, bytes);</span><br></pre></td></tr></table></figure><p>因为windows下的VirtualFree并不需要传入长度，所以在Linux中改造内存池的时候，还需要一个map来存放指针其实地址和长度的关系，保证释放的时候能按正确的内存长度进行释放。</p><h2 id="8-3-TLS变量"><a href="#8-3-TLS变量" class="headerlink" title="8.3 TLS变量"></a>8.3 TLS变量</h2><p>这一点前文已经提到过区别，Linux下和Windows的代码有一定差异。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="type">static</span> _declspec(thread) ThreadCache *TLSThreadCache = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="type">static</span> __thread ThreadCache *TLSThreadCache = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="8-4-系统内存分配和释放地址不一致问题（未解决）"><a href="#8-4-系统内存分配和释放地址不一致问题（未解决）" class="headerlink" title="8.4 系统内存分配和释放地址不一致问题（未解决）"></a>8.4 系统内存分配和释放地址不一致问题（未解决）</h2><p>当直接申请大块内存（比如2000KB）的时候，PageCache会调用SystemAlloc函数，不使用malloc&#x2F;new而直接调用系统接口来申请大块内存。</p><p>这里就出现了问题，申请内存的时候，操作系统返回的内存并不是严格按我们预定的8KB页来起始的，比如下面的<code>0xf7617000</code>这个地址；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alloc ptr: 0xf7617000 - 2048000</span><br><span class="line">2000KB: 0xf7616000</span><br><span class="line">free ptr: 0xf7616000</span><br></pre></td></tr></table></figure><p>将<code>0xf7617000</code>除以8KB再乘以8KB，得到的结果是<code>0xf7616000</code>，和原本分配的内存不一致！因为PageCache中申请内存的时候会将其<strong>按页号</strong>来保存在Span对象里面，但操作系统返回的内存<strong>并不一定是某个页的起始地址</strong>！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/0dcaaceac0ccd22bad9f571d1edfe42c.png" alt="image-20240304130129640"></p><p>而且会发现最终调用方得到的内存是<code>0xf7616000</code>，这个地址小于操作系统分配给我们的<code>0xf7617000</code>，如果直接访问，会访问到并不属于当前已分配内存的部分，直接段错误！</p><p>这个问题大概率是由Windows和Linux下系统调用接口的不同设计导致的，因为windows下不管是用x86和x64都没有复现出这个问题（在Linux下会有60%的几率出现该问题）</p><p>而且该问题影响的不只是超过1MB的大内存申请，PageCache申请内存的时候也有可能会遇到系统调用接口返回的内存并非按8KB对齐的情况，最终导致段错误。</p><p>由于这不是线程池设计中的重点，也和线程池本身的思路没有关系，所以暂时挂起不去深究，<strong>继续在Windows上以32位对线程池进行优化</strong>。</p><h1 id="9-性能问题"><a href="#9-性能问题" class="headerlink" title="9.性能问题"></a>9.性能问题</h1><h2 id="9-1-简单测试"><a href="#9-1-简单测试" class="headerlink" title="9.1 简单测试"></a>9.1 简单测试</h2><p>使用下面的代码，在多线程环境下分别测试线程池申请和malloc申请内存的耗时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultiThreadAlloc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v1;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v2;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">ConcurrentAlloc</span>(<span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;21 - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;22 - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">v2.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2 memory pool cost time:&quot;</span> &lt;&lt; end1 - begin1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2 malloc cost time:&quot;</span> &lt;&lt; end2 - begin2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error in MultiThreadAlloc2\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vs2019的debug-x86模式，测试结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 memory pool cost time:98</span><br><span class="line">2 malloc cost time:91</span><br><span class="line">1 memory pool cost time:44</span><br><span class="line">1 malloc cost time:95</span><br></pre></td></tr></table></figure><p>会发现线程2的malloc申请时间小于线程池，而线程1的线程池效率更高。再测试一次，又会发现两个线程malloc的效率都更高了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 memory pool cost time:80</span><br><span class="line">2 malloc cost time:77</span><br><span class="line">1 memory pool cost time:69</span><br><span class="line">1 malloc cost time:61</span><br></pre></td></tr></table></figure><p>这明显不是我们想要的结果，如果一个内存池的效率低于malloc，它存在的意义就不是很大了。所以需要针对当前线程池中的性能瓶颈进行一定分析和优化。</p><h2 id="9-2-VS2019性能查看器"><a href="#9-2-VS2019性能查看器" class="headerlink" title="9.2 VS2019性能查看器"></a>9.2 VS2019性能查看器</h2><p>VS2019的调试选项中有一个性能探查器，它可以帮助我们确定当前项目中哪一个部分最耗时。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e5741918e40f4f3f998be52e652048d1.png" alt="image-20240306090902495"></p><p>调整到DEBUG模式下，选择检测，点击开始</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e26975b85eb27872042507ca14a725e8.png" alt="image-20240306091010082"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/0138862a8de2f1ed9c6c46a5936b5751.png" alt="image-20240306091438569"></p><p>最终选择当前项目并等待运行后，会得到一个下面这样的报告。注意使用性能监看器的时候应该把多线程代码内部的打印和sleep给去掉（否则会显示打印和sleep的耗时很长）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c898dca7428fcf06364e3dccb76439bf.png" alt="image-20240306091039084"></p><p>上图是只有两个线程时的报告，下图是4个线程同时运行时的报告</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5632ea109f2e97504928900d47e5e208.png" alt="image-20240306141404925"></p><p>这里就能看到，ConcurrentFree函数占用了很大的CPU时间</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/1d0da72d2acb63ba4235cca495d9667c.png" alt="image-20240306091851440"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9c47bb8bb270db12ab4b121d404b1522.png" alt="image-20240306091802354"></p><p>在ConcurrentFree函数中，<code>MapObjectToSpan</code>函数和<code>ThreadCache::Deallocate</code>函数占用的时间比较长。</p><p>进一步查看，在<code>ThreadCache::Deallocate</code>函数中，耗时的也是MapObjectToSpan这个HashMap的查询操作。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e8611fceb986f9a88665d6546bd3a2e3.png" alt="image-20240306092056267"></p><p>MapObjectToSpan函数中，<strong>占用时间长的是加锁和find的操作</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3b85e480b784725724674b6d707717e9.png" alt="image-20240306092009240"></p><p>如果能省去这里的加锁，<strong>那么内存池释放内存的效率就会大大提高</strong>。</p><p>这时候就需要引入另外一种数据结构了：基数树 radix_tree。</p><h2 id="9-3-基数树"><a href="#9-3-基数树" class="headerlink" title="9.3 基数树"></a>9.3 基数树</h2><h3 id="数据结构说明"><a href="#数据结构说明" class="headerlink" title="数据结构说明"></a>数据结构说明</h3><p>在PageCache中的<code>unordered_map</code>是用于映射页号和对应Span对象指针的，这两个本质上都是一个整形。基数树就比较适合这样的场景。</p><ul><li>单层基数树其实就是一个“直接定址法”的哈希数组，用页面数量作为数组长度，每个数组的元素都是一个指针；</li></ul><p>在32位系统下，这个数组的长度是<code>32-PAGE_SHIFT</code>，对于当前项目而言<code>PAGE_SHIFT</code>是13，则最终数组的长度是<code>2^19</code>，每个元素都是一个4字节的指针类型，数组的大小就是2048KB，即2MB。这个大小并不算大，可以接受。</p><p>很明显，使用单层基数树，时间复杂度就直接被压缩到了数组下标直接访问的<code>O(1)</code>，比<code>unordered_map</code>提供的哈希表效率更高（因为单层基数树完全没有哈希碰撞和扩容问题）。</p><ul><li>多层基数树利用页号的比特位来分层</li></ul><p>如下所示，在32位下，页号只有低19位是有意义的。因为页号是由32位地址右移13位得来的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/77a3771140158154ec2f2d3b4abe7c44.png" alt="image-20240306145039892"></p><p>将低的十九位进一步分为高5位，低13位；这里的高5位就作为第一层的映射，低13位作为第二层的映射</p><ul><li>第一层的长度为2的5次方；</li><li>第二层的长度为2的13次方；</li></ul><p>最终基数树的数组长度是<code>2^5 * 2^13 = 262,144</code>，占用空间大小是1024KB，即1MB。分层不仅节省了空间，而且还避免了一次性申请大块内存（如果是单层基数树需要一次性把数组的空间申请出来）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/abdc5fcc1f253aad8f44941127644868.png" alt="image-20240306150859855"></p><p>更多层的基数树都是按上述思路往下扩展，如果是六十四位的系统就需要用更多层的基数树。</p><p>基数树因为每一个页号都有一个单独的存储空间，在修改的时候只会修改局部，并不影响整体。而且和红黑树这种数据结构有一点不同，红黑树为了保证key的有序，在插入的时候可能需要进行树结构的旋转，假设查询的时候遇到这种旋转，效率就会变低甚至出现错误，这也是为什么使用<code>map</code>的时候需要<strong>加锁</strong>。<code>unoredered_map</code>也是同理，遇到哈希碰撞和空间不足的时候，都会修改原本数据的存放结构，为了避免多线程问题，就需要加锁才能进行查询。</p><p>而基数树不管是插入还是删除操作都<strong>不会影响整个树的结构</strong>，你可以理解为基数树创建完毕之后整个树的结构就不会动了，这一点就让它在一定程度上是线程安全的。只要多线程<strong>不会同时读写相同页号的数据</strong>，就不会出现并发问题。</p><h3 id="回到项目"><a href="#回到项目" class="headerlink" title="回到项目"></a>回到项目</h3><p>再来看看项目中什么时候需要设置映射，什么时候会查询映射？</p><p>设置页号和Span对象的指针函数为<code>SetMapObjectToSpan</code>，只在PageCache的NewSpan和ReleaseSpanToPageCache函数中被调用。而访问PageCache的时候都会加锁，这里对映射的<strong>写操作</strong>不存在多线程问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5bfcc0a0a5b6a8c682c446851f8c05b0.png" alt="image-20240306152054722"></p><p>查询操作都是在<code>ConcurrentFree</code>和<code>CentralCache::ReleaseListToSpans</code>这两个内存释放函数中。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f1306727d9c65e996b18a83f5b0b8514.png" alt="image-20240306153145300"></p><p>PageCache中什么时候会修改映射：</p><ul><li>将对应大小Span分配给CentralCache时；</li><li>将大Span拆成小Span，并分配给CentralCache时；</li><li>回收时将小Span与相邻Span合并时；</li></ul><p>而查询操作都是在回收内存的时候出现的，被回收的内存一定<strong>不会是刚刚准备被分配的Span对象</strong>，因为分配内存后的Span对象就会从PageCache的SpanList中删除，PageCache不管是回收合并操作还是拆分操作都不会遇到这个不存在于SpanList中的Span对象。换而言之，当前映射的写操作和读操作<strong>不会同时访问相同页号的位置</strong>！而基数树的特性让这种读写不同下标位置的操作无需加锁！</p><p>去掉了锁竞争，效率就提高了！</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>单层基数树，其实就是一个数组，给定一个Get和一个Set，就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单层基数树，利用模板变量来获取长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> BITS&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageMap1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> LENGTH = <span class="number">1</span> &lt;&lt; BITS; <span class="comment">// 用于确定基数树的长度</span></span><br><span class="line"><span class="type">void</span>** _array; <span class="comment">// 一个数组，数组内的每个元素都是一个void*指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">PageMap1</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(<span class="type">void</span>*) * LENGTH; <span class="comment">// 整个数组的长度</span></span><br><span class="line"><span class="type">size_t</span> alignSize = SizeClass::<span class="built_in">RoundUp</span>(size); <span class="comment">// 调用SystemAlloc申请内存的时候需要按页对齐</span></span><br><span class="line">_array = (<span class="type">void</span>**)<span class="built_in">SystemAlloc</span>(alignSize &gt;&gt; PAGE_SHIFT); <span class="comment">// 为了可移植性，使用C语言的强制转换</span></span><br><span class="line"><span class="built_in">memset</span>(_array, <span class="number">0</span>, size); <span class="comment">// 清零</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里采用uintptr_t，保证可以覆盖当前平台上的指针数量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uintptr_t</span> Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set的时候需要保证key有效</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(Number key, <span class="type">void</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_array[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Get</span><span class="params">(Number key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超过当前的允许范围了</span></span><br><span class="line"><span class="keyword">if</span> ((key &gt;&gt; BITS) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _array[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-4-再次性能测试"><a href="#9-4-再次性能测试" class="headerlink" title="9.4 再次性能测试"></a>9.4 再次性能测试</h2><p>将PageCache中的<code>unordered_map</code>改为单层基数树，然后再进行测试。这次使用更好的自动创建线程来并发申请的方式进行测试，方便修改测试变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc多线程测试</span></span><br><span class="line"><span class="comment">// ntimes 一轮申请和释放内存的次数</span></span><br><span class="line"><span class="comment">// nworks 线程数量</span></span><br><span class="line"><span class="comment">// rounds 轮次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchmarkMalloc</span><span class="params">(<span class="type">size_t</span> ntimes, <span class="type">size_t</span> nworks, <span class="type">size_t</span> rounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;std::thread&gt; <span class="title">vthread</span><span class="params">(nworks)</span></span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; malloc_costtime = <span class="number">0</span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; free_costtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; nworks; ++k)</span><br><span class="line">&#123;</span><br><span class="line">vthread[k] = std::<span class="built_in">thread</span>([&amp;, k]() &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(ntimes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">malloc</span>(<span class="number">35</span>));</span><br><span class="line"><span class="comment">//v.push_back(malloc((35 + i) % 8192 + 1));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">malloc_costtime += (end1 - begin1);</span><br><span class="line">free_costtime += (end2 - begin2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vthread)</span><br><span class="line">&#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行 %u 轮次，每轮 malloc %u 次，耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, rounds, ntimes, malloc_costtime.<span class="built_in">load</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行 %u 轮次，每轮 free %u 次，耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, rounds, ntimes, free_costtime.<span class="built_in">load</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行malloc/free %u 次，总计耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, nworks * rounds * ntimes, malloc_costtime.<span class="built_in">load</span>() + free_costtime.<span class="built_in">load</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池多线程测试</span></span><br><span class="line"><span class="comment">// ntimes 一轮申请和释放内存的次数</span></span><br><span class="line"><span class="comment">// nworks 线程数量</span></span><br><span class="line"><span class="comment">// rounds 轮次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchmarkConcurrentMalloc</span><span class="params">(<span class="type">size_t</span> ntimes, <span class="type">size_t</span> nworks, <span class="type">size_t</span> rounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;std::thread&gt; <span class="title">vthread</span><span class="params">(nworks)</span></span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; malloc_costtime = <span class="number">0</span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; free_costtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; nworks; ++k)</span><br><span class="line">&#123;</span><br><span class="line">vthread[k] = std::<span class="built_in">thread</span>([&amp;]() &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(ntimes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">ConcurrentAlloc</span>(<span class="number">35</span>));</span><br><span class="line"><span class="comment">//v.push_back(ConcurrentAlloc((35 + i) % 8192 + 1));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">malloc_costtime += (end1 - begin1);</span><br><span class="line">free_costtime += (end2 - begin2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vthread)</span><br><span class="line">&#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行 %u 轮次，每轮内存池申请 %u 次，耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, rounds, ntimes, malloc_costtime.<span class="built_in">load</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行 %u 轮次，每轮内存池释放 %u 次，耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, rounds, ntimes, free_costtime.<span class="built_in">load</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行内存池申请和释放 %u 次，总计耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, nworks * rounds * ntimes, malloc_costtime.<span class="built_in">load</span>() + free_costtime.<span class="built_in">load</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchMark</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> n = <span class="number">10000</span>;</span><br><span class="line"><span class="built_in">BenchmarkConcurrentMalloc</span>(n, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BenchmarkMalloc</span>(n, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是使用<code>uordered_map</code>的测试结果（DEBUG-X86），性能远低于malloc&#x2F;free。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 个线程并发执行 10 轮次，每轮内存池申请 100000 次，耗时：4756 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮内存池释放 100000 次，耗时：25577 ms</span><br><span class="line">4 个线程并发执行内存池申请和释放 4000000 次，总计耗时：30333 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4 个线程并发执行 10 轮次，每轮 malloc 100000 次，耗时：6064 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮 free 100000 次，耗时：1797 ms</span><br><span class="line">4 个线程并发执行malloc/free 4000000 次，总计耗时：7861 ms</span><br></pre></td></tr></table></figure><p>以下是使用<strong>单层基数树</strong>的测试结果（DEBUG-X86），可以看到此时我们的内存池效率就完美体现出来了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 个线程并发执行 10 轮次，每轮内存池申请 10000 次，耗时：177 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮内存池释放 10000 次，耗时：72 ms</span><br><span class="line">4 个线程并发执行内存池申请和释放 400000 次，总计耗时：249 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4 个线程并发执行 10 轮次，每轮 malloc 10000 次，耗时：644 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮 free 10000 次，耗时：181 ms</span><br><span class="line">4 个线程并发执行malloc/free 400000 次，总计耗时：825 ms</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 个线程并发执行 10 轮次，每轮内存池申请 100000 次，耗时：1899 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮内存池释放 100000 次，耗时：796 ms</span><br><span class="line">4 个线程并发执行内存池申请和释放 4000000 次，总计耗时：2695 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4 个线程并发执行 10 轮次，每轮 malloc 100000 次，耗时：5947 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮 free 100000 次，耗时：2298 ms</span><br><span class="line">4 个线程并发执行malloc/free 4000000 次，总计耗时：8245 ms</span><br></pre></td></tr></table></figure><p>改成Release模式重新测试一下，可见Release模式对malloc操作有一定优化，二者差距没有那么高，不过已经能体现当前内存池的性能还不错了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 个线程并发执行 10 轮次，每轮内存池申请 100000 次，耗时：169 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮内存池释放 100000 次，耗时：118 ms</span><br><span class="line">4 个线程并发执行内存池申请和释放 4000000 次，总计耗时：287 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4 个线程并发执行 10 轮次，每轮 malloc 100000 次，耗时：165 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮 free 100000 次，耗时：189 ms</span><br><span class="line">4 个线程并发执行malloc/free 4000000 次，总计耗时：354 ms</span><br></pre></td></tr></table></figure><p>再用性能监视器查看，发现性能消耗最大的已经是vector的push操作了，原先耗时的Map查询操作现在占比已经不高了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3a3ced1ce9cbe0818832ab752fd58f17.png" alt="image-20240306214130138"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>内存池的基本学习和项目的实现内容到这里就OVER啦！</p>]]></content>
    
    
    <summary type="html">高并发内存池项目的学习</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="项目开发记录" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】04.常用变量类型</title>
    <link href="https://blog.musnow.top/posts/2729830801/"/>
    <id>https://blog.musnow.top/posts/2729830801/</id>
    <published>2024-02-14T12:37:08.000Z</published>
    <updated>2024-03-07T12:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对Redis的变量类型以及和特定数据类型相关命令的介绍。</p><h1 id="1-string"><a href="#1-string" class="headerlink" title="1 string"></a>1 string</h1><p><a href="https://redis.io/docs/data-types/strings/">Redis Strings | Redis</a></p><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p>Redis中，所有key都是字符串类型，作为value的字符串有几个特性</p><ul><li>无编码转换（存的是什么取出来就是什么），所以你可以用string来存放二进制文件；</li><li>限制大小为512MB（避免过长的string操作耗时）；</li></ul><p>在MySQL中默认的字符集是拉丁文，此时插入中文内容会直接报错编码无法识别而失败，需要修改MySQL数据库的字符集。而在Redis中（不配置的情况下）插入中文，可以正常存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 你好</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br></pre></td></tr></table></figure><p>这里get查看的时候显示的是中文编码。此时Redis客户端没有配置字符集转码，所以没能显示中文，但实际上中文就是这么存放的（这就好比英文存放的是对应ASCII码一样）。</p><p>因为Redis服务端没有对编码进行转换，所以它遇到乱码问题（比如烫烫烫）的概率更小。但依旧不建议使用<code>非英文+数字</code>的组合来做Redis的key。</p><p>如果想让redis-cli的终端中<strong>正常显示中文</strong>，可以在启动的时候添加<code>--raw</code>选项。如下所示，添加了该选项后，正常显示出了value的中文值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">你好</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用该选项会导致Redis中显示的<code>(nil)</code>变成空字符串，极易产生误导！如果不是硬性需要在控制台中显示中文，请不要使用该选项！</p></blockquote><p>另外，在<a href="https://blog.musnow.top/posts/3677820204">Redis基础命令博客</a>中提到，Redis会对不同的string采取不同的存储方式，其中对于纯整数的string采用的是int来存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">int</span><br></pre></td></tr></table></figure><p>所以在Redis中如果存放一个<strong>整数数字</strong>（包括负数），虽然对应变量类型是string，但实际上就是一个int数字来存放的，Redis还提供了一系列原子性命令来对整数进行加减操作！</p><h2 id="1-2-相关命令"><a href="#1-2-相关命令" class="headerlink" title="1.2 相关命令"></a>1.2 相关命令</h2><p>set&#x2F;get以及mset&#x2F;mget命令已经在<a href="https://blog.musnow.top/posts/3677820204">Redis基础命令博客</a>中讲解了，这里不再重复。</p><h3 id="1-2-1-setnx-x2F-msetnx"><a href="#1-2-1-setnx-x2F-msetnx" class="headerlink" title="1.2.1 setnx&#x2F;msetnx"></a>1.2.1 setnx&#x2F;msetnx</h3><p>setnx等价于set中添加nx选项，只有在key不存在的时候才能正常设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure><ul><li>当key值已经存在的时候，setnx不会执行任何操作，返回0；</li><li>当key值不存在的时候，setnx等价于set，返回1；</li></ul><p>如下所示，key1存在，设置失败返回0；key2不存在，设置成功返回1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx key1 value2</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setnx key2 value2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>还有一个命令是msetnx（和mset一样），可以原子性地同时setnx多个key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></table></figure><ul><li>只要给定的多个key中有一个key存在，msetnx就会失败且什么都不做，返回0；</li><li>只有给定的多个key全部都不存在，msetnx才会成功，返回1；</li></ul><p>如下所示，此时key1和key2已经存在，设置失败返回0；key3和key4都不存在， 设置成功返回1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; msetnx key1 value1 key2 value2 key3 value3</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; msetnx key3 value3 key4 value4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="1-2-2-setex-x2F-psetex"><a href="#1-2-2-setex-x2F-psetex" class="headerlink" title="1.2.2 setex&#x2F;psetex"></a>1.2.2 setex&#x2F;psetex</h3><p>setex&#x2F;psetex是在设置key的时候指定过期时间，只是时间单位不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key value second</span><br><span class="line">psetex key value milisecond</span><br></pre></td></tr></table></figure><p>虽然set命令本身已经提供了关于这些功能的选项，但直接使用<strong>特定命令</strong>来设置而不是用命令的参数会更加方便且符合人的直觉，使用门槛也更低！</p><blockquote><p>对于学习过Linux系统使用的开发人员而言，命令参数已经见怪不怪了。但对于初次学习Redis使用而没有接触过Linux系统的萌新而言，使用一个简单的命令来传递单个参数，会比在set后面添加一大堆选项更加简单且不容易犯错。</p></blockquote><h3 id="1-2-3-数字加减命令"><a href="#1-2-3-数字加减命令" class="headerlink" title="1.2.3 数字加减命令"></a>1.2.3 数字加减命令</h3><p>因为Redis中的整数是用int来存放的，所以它提供了一些命令来<strong>原子性</strong>的操作数字。这些命令中如果给定的key不存在，则会将其视作0，新建一个key再加上目标值。</p><table><thead><tr><th>命令</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>incr key</td><td>value + 1</td><td>value必须是整数</td></tr><tr><td>incrby key n</td><td>value + n</td><td>value必须是整数，给定的n可以是负数</td></tr><tr><td>decr key</td><td>value - 1</td><td>value必须是整数</td></tr><tr><td>decrby key n</td><td>value - n</td><td>value必须是整数，给定的n可以是负数</td></tr><tr><td>incrbyfloat key n</td><td>value +&#x2F;- 小数</td><td>给定的n可以是负数来实现减法</td></tr></tbody></table><p>注意：<code>decrbyfloat</code>命令是不存在的！</p><p>前四个命令的操作数value必须是一个整数，否则会失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; incr key1</span><br><span class="line">ERR value is not an integer or out of range</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; decr key1</span><br><span class="line">ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure><p>使用incrbyfloat命令操作一个整数后，它的存放方式就不再是int，而变成embstr了。此时我们依旧可以用incrbyfloat命令来继续添加小数（包括减去小数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">int</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 19.3</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">embstr</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 0.7</span><br><span class="line">120</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">embstr</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 -0.7</span><br><span class="line">119.3</span><br></pre></td></tr></table></figure><h3 id="1-2-4-append"><a href="#1-2-4-append" class="headerlink" title="1.2.4 append"></a>1.2.4 append</h3><p>append命令用于在字符串之后追加字符串。如果给定key不存在，则和set命令等价。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><p>该命令的时间复杂度是<code>O(1)</code>，返回值是追加后的字符串长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; append k 45</span><br><span class="line">5</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>如果尝试给k追加一个中文，字符串长度会是多少呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; append k 你好</span><br><span class="line">11</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345你好</span><br></pre></td></tr></table></figure><p>可以看到，最终长度是11，因为Redis不会对字符串进行转码，中文在UTF8环境下是用三个字节存放的，所以两个中文就是6字节，加上原本的5个字节，最终长度就是11字节。</p><p>不使用<code>--raw</code>启动redis-cli，就能看到这两个中文的原始编码值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;12345\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br></pre></td></tr></table></figure><h3 id="1-2-5-getrange"><a href="#1-2-5-getrange" class="headerlink" title="1.2.5 getrange"></a>1.2.5 getrange</h3><p>这个命令用于获取字符串的子串，start&#x2F;end指定一个区间（采用下标方式且为闭区间）。该命令的时间复杂度是<code>O(N)</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end</span><br></pre></td></tr></table></figure><p>测试如下，2代表从第三个字符开始，4代表第五个字符结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 123456789</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 4</span><br><span class="line">&quot;345&quot;</span><br></pre></td></tr></table></figure><p>这里的start&#x2F;end还可以给负数。当end为负数时，代表直接取到末尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange key -1 4</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 -1</span><br><span class="line">&quot;3456789&quot;</span><br></pre></td></tr></table></figure><p>当start小于end时，返回空字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange key 2 0</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 1</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 2</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>注意，getrange的切分是严格按照字节切分的，如果是中文，则难以拆分出一个正常的中文字符（要按3个字节的间隙才能拆出一个正常的中文字符）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-cli</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;12345\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 -1</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 6</span><br><span class="line">&quot;\xe4\xbd&quot;</span><br><span class="line"></span><br><span class="line">❯ sudo redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345你好</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 6</span><br><span class="line">�</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 7</span><br><span class="line">你</span><br></pre></td></tr></table></figure><h3 id="1-2-6-setrange"><a href="#1-2-6-setrange" class="headerlink" title="1.2.6 setrange"></a>1.2.6 setrange</h3><p>从指定下标开始替换字符串，返回值是替换后字符串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setrange key offset value</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">123456789</span><br><span class="line">127.0.0.1:6379&gt; setrange key 3 hhhh</span><br><span class="line">9</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">123hhhh89</span><br></pre></td></tr></table></figure><h3 id="1-2-7-strlen"><a href="#1-2-7-strlen" class="headerlink" title="1.2.7 strlen"></a>1.2.7 strlen</h3><p>返回字符串的长度，单位是字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><h2 id="1-3-编码介绍"><a href="#1-3-编码介绍" class="headerlink" title="1.3 编码介绍"></a>1.3 编码介绍</h2><p>string有三种编码方式</p><ul><li>embstr：为短字符串优化；</li><li>int：为非负整数优化；</li><li>raw：原始字符串；</li></ul><p>注意，不管是什么编码方式，都不会影响对string的数字加减命令的使用（只要value是一个数字就行，即便小数的编码方式是embstr，也依旧可以使用数字加减命令）</p><h2 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h2><h3 id="1-4-1-用户信息缓存"><a href="#1-4-1-用户信息缓存" class="headerlink" title="1.4.1 用户信息缓存"></a>1.4.1 用户信息缓存</h3><p>绝大部分情况下，我们需要获取的信息都是字符串类型的。比如用户个人信息的JSON字符串。</p><p>此时可以在Redis中用<code>user:平台:用户ID</code>的方式做key，来保存用户基本个人信息的JSON字符串。如果使用Redis+MySQL的组合的话，整个用户信息的请求步骤如下：</p><ul><li>用户浏览器&#x2F;APP中点击个人信息页面，客户端发起请求，假设用户ID为100；</li><li>应用服务器收到请求，先去请求Redis服务器：<code>get user:平台:100</code>；</li><li>Redis中成功查询到用户信息，将Json字符串返回给用户；</li><li>没有在Redis中查询到，使用SQL请求MySQL服务器<code>select 用户个人信息字段 from user where user_id = &#39;100&#39;;</code></li><li>将MySQL返回的相关键值按预定格式制作成JSON字符串，返回给用户；</li><li>将该JSON字符串写入Redis服务器：<code>set user:平台:100 JSON字符串</code>；</li></ul><p>在set的时候还可以设定一定的过期时间，在保证缓存的实时性的基础上，避免Redis中的数据始终增长而导致内存爆满。（当然，内存快满的时候Redis有淘汰策略可供选择，那是后面要学习的内容了）。</p><h3 id="1-4-2-视频播放量计数"><a href="#1-4-2-视频播放量计数" class="headerlink" title="1.4.2 视频播放量计数"></a>1.4.2 视频播放量计数</h3><p>对于视频点赞、播放量这种经常变动的数据，可以使用Redis来做计数。比如使用<code>vedio:hit:视频ID</code>作为key，代表视频的播放量。</p><p>当用户点击一个视频的时候，发起请求给应用服务器，服务器在返回视频相关信息的同时，将播放量加一的信息，使用incr命令传递给Redis服务器。</p><p>但只用Redis肯定是不够的，还会有一个MySQL数据表来存放视频对应的点赞、播放、收藏等全量信息。此时我们可以令起一个服务，<strong>异步</strong>地同步视频播放量、点赞等相关信息到MySQL表中。</p><blockquote><p><strong>异步</strong>同步：并非来一个视频请求就同步到MySQL一次，而是以一定频率（时间间隔）将Redis中的数据同步到MySQL表中。这样能保证Redis中的数据能有备份。</p></blockquote><p>实际场景中，要想开发一个稳定的真实计数系统，还需要考虑防作弊、不同维度计数、避免单点问题以及数据持久化等等方面。这些都需要根据具体的业务逻辑来特殊处理。</p><h3 id="1-4-3-cookie-seesion"><a href="#1-4-3-cookie-seesion" class="headerlink" title="1.4.3 cookie+seesion"></a>1.4.3 cookie+seesion</h3><p>在HTTP网络服务中，cookie是最常用的用于标定客户端信息的方式。有些网站并非每次打卡都需要登录，而是登录了之后能维持一段时间不需要用户每次都重新登录。在这个过程中，就是通过浏览器端的cookie和服务器端的session来实现的。</p><ul><li>cookie：存放在用户的浏览器中，其值是通过HTTP的<code>Set-Cookie</code>响应头由服务器告知用户浏览器的；</li><li>session：存放在服务器端（实际上服务器端应该存放的是cookie-session的键值对），用于标定用户的基本信息；</li></ul><p>当用户登录后，服务器会生成一个<code>session_id</code>，将其和登录的用户信息绑定（键值对），并发送包含<code>Set-Cookie</code>头的HTTP报文给客户端，将<code>session_id</code>告知用户。浏览器在检测到这个响应头后，会将它对应的值保存在本地，下一次向这个网站发起HTTP请求的时候就会带上这个设置的cookie值里面的<code>session_id</code>。</p><p>服务器收到HTTP请求后，检查请求头中的<code>Cookie</code>字段，并与服务器中存放的<code>session_id</code>键值对进行对比，得到对应的用户，则返回用户相关信息，即当前用户已登录。</p><p>实现网页登录在一定时间后过期的功能，只需要在Redis中给这个键值对设置一个<strong>过期时间</strong>就行了。</p><p>使用cookie+session的方式也更加方便多个应用服务器之间的消息共享。因为<strong>负载均衡</strong>的存在，用户的请求可能会被发送到不同的应用服务器。只要这些应用服务器<strong>使用相同的Redis</strong>，它们就都能检索到用户的cookie对应的session信息，也就知道了当前用户的个人信息，可以正常进行服务（其实就是信息在多个应用服务器之中进行共享）。整个过程中用户完全不会发现自己的请求并非是同一个服务器来处理的。</p><h3 id="1-4-4-验证码"><a href="#1-4-4-验证码" class="headerlink" title="1.4.4 验证码"></a>1.4.4 验证码</h3><p>这个场景就很常见了，手机验证码&#x2F;邮箱验证码都是如此，在Redis中设置一个验证码的key，value是对应用户的id，<strong>并给这个key设置一定的过期时间</strong>，就能实现验证码的功能。</p><p>当用户输入验证码后，检查Redis中的key，当value中的id和用户的id相同，则代表验证成功。用户id不同或验证码的key不存在，则验证失败。</p><p>这个过程中可能还会涉及到间隔60s秒才能发送一次验证码（这种限制大概率是前端做的处理）后端自然也可以通过一些缓存的时间值来做检查，避免给同一个用户在较短时间内发送多个验证码（会影响性能）。</p><h1 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2 Hash"></a>2 Hash</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>哈希是比较常见的一种数据结构，Redis本身的key-value结构其实就是通过哈希来实现的。同时，Redis也提供了hash作为value的数据类型，为了和Redis本身的kv进行区分，hash类型内的键值对被称为<code>field-value</code>。</p><p>比如存放一个用户信息，原本我们可以采用如下方式，在key中用冒号作为分隔来保存个人信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user:1:name 李四</span><br><span class="line">user:1:age  20</span><br><span class="line">user:1:sex  男</span><br></pre></td></tr></table></figure><p>现在我们可以直接将value设置为hash类型，然后在其中再设置对应的field和value，看上去就更加明了。</p><table><thead><tr><th>key</th><th>field</th><th>value</th></tr></thead><tbody><tr><td>user:1</td><td>name</td><td>李四</td></tr><tr><td>user:1</td><td>ag</td><td>20</td></tr><tr><td>user:1</td><td>sex</td><td>男</td></tr></tbody></table><h2 id="2-2-相关命令"><a href="#2-2-相关命令" class="headerlink" title="2.2 相关命令"></a>2.2 相关命令</h2><h3 id="2-2-1-HSET-x2F-HGET-x2F-HGETALL"><a href="#2-2-1-HSET-x2F-HGET-x2F-HGETALL" class="headerlink" title="2.2.1 HSET&#x2F;HGET&#x2F;HGETALL"></a>2.2.1 HSET&#x2F;HGET&#x2F;HGETALL</h3><p><a href="https://redis.io/commands/hget/">https://redis.io/commands/hget/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value [field value ...]</span><br><span class="line">HGET key field</span><br></pre></td></tr></table></figure><p>经过之前的命令学习，现在这里的命令就很好理解了。</p><ul><li>HSET用于设置hash类型内部的field，可以同时设置多个field；</li><li>HGET用于获取hash类型内部的field。</li></ul><p>HSET命令的返回值是设置成功的field的个数。当HGET命令指定的key或者field不存在时，会返回<code>nil</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET user:1 name 李四 age 20 sex 男</span><br><span class="line">3</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 name</span><br><span class="line">&quot;\xe6\x9d\x8e\xe5\x9b\x9b&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 age</span><br><span class="line">20</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 info</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; HGET user:2 test</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>与此相关的还有HSETNX和HGETALL两个命令</p><ul><li>HSETNX：当hash中的field不存在时才会设置成功（返回值为1），如果field已经存在则不会做任何操作（返回值为0）；</li><li>HGETALL：返回hash中的所有field-value值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;\xe6\x9d\x8e\xe5\x9b\x9b&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;sex&quot;</span><br><span class="line">6) &quot;\xe7\x94\xb7&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:2</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><h3 id="2-2-2-HEXISTS"><a href="#2-2-2-HEXISTS" class="headerlink" title="2.2.2 HEXISTS"></a>2.2.2 HEXISTS</h3><p>该命令用于查询hash中的某个field是否存在。存在返回1，key或者field不存在返回0；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 info</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS user:2 info</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="2-2-3-HDEL"><a href="#2-2-3-HDEL" class="headerlink" title="2.2.3 HDEL"></a>2.2.3 HDEL</h3><p>删除hash中指定的field，可以一次性给定多个field来删除。返回值是本次成功删除的field个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></table></figure><p>示例，info字段是不存在的，实际上只成功删除了name字段，所以返回值为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HDEL user:1 name info</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果你需要删除整个hash，直接使用Redis的del命令将key给删除就行了。比如<code>del user:1</code>;</p><h3 id="2-2-4-HKEYS"><a href="#2-2-4-HKEYS" class="headerlink" title="2.2.4 HKEYS"></a>2.2.4 HKEYS</h3><p>获取哈希中的所有field（仅获取字段）；该命令的时间复杂度是<code>O(N)</code>，N是hash中的field个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><p>这个命令和HGETALL命令有所不同，HGETALL命令会获取field和value，但HKEYS只会获取field。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;sex&quot;</span><br><span class="line">4) &quot;\xe7\x94\xb7&quot;</span><br><span class="line">127.0.0.1:6379&gt; HKEYS user:1</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;sex&quot;</span><br></pre></td></tr></table></figure><p>当然，这个命令和HGETALL命令都需要<strong>谨慎使用</strong>，它们就和<code>keys *</code>一样，需要遍历整个hash对象，而我们在执行命令之前并不知道一个hash里面到底有多少个field。如果查询的hash中field过多，那就会阻塞Redis。</p><h3 id="2-2-5-HVALS"><a href="#2-2-5-HVALS" class="headerlink" title="2.2.5 HVALS"></a>2.2.5 HVALS</h3><p>获取hash中的所有value，和HKEYS的功能对应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HVALS user:1</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;\xe7\x94\xb7&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-HMGET"><a href="#2-2-6-HMGET" class="headerlink" title="2.2.6 HMGET"></a>2.2.6 HMGET</h3><p>一次性获取hash中的多个field（一条命令查询优于多条命令查询）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMGET user:1 age sex</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;\xe7\x94\xb7&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-7-HSCAN（仅作介绍）"><a href="#2-2-7-HSCAN（仅作介绍）" class="headerlink" title="2.2.7 HSCAN（仅作介绍）"></a>2.2.7 HSCAN（仅作介绍）</h3><p>和HGETALL&#x2F;HKEYS&#x2F;HVALS这些一次性遍历完毕所有hash内元素的命令不同，HSCAN命令是“渐进式遍历”（就好比过程化SQL和编程中常用的for循环）。</p><p>所谓渐进式遍历，就是敲一次命令遍历一次，这样遍历的过程和速度都是可控的，不会阻塞Redis。当你需要获取一个hash中的所有field&#x2F;value，使用HSCAN会更加安全。</p><p>官网文档：<a href="https://redis.io/commands/hscan/">https://redis.io/commands/hscan/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h3 id="2-2-8-HLEN"><a href="#2-2-8-HLEN" class="headerlink" title="2.2.8 HLEN"></a>2.2.8 HLEN</h3><p>获取一个hash中键值对的个数，该命令时间复杂度是<code>O(1)</code>，因为Redis有使用额外变量来存放hash中元素的个数，无需遍历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure><p>使用该命令遍历一个不存在的key时，返回值为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HLEN user:1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HLEN user:2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="2-2-9-HINCRBY-x2F-HINCRYBYFLOAT"><a href="#2-2-9-HINCRBY-x2F-HINCRYBYFLOAT" class="headerlink" title="2.2.9 HINCRBY&#x2F;HINCRYBYFLOAT"></a>2.2.9 HINCRBY&#x2F;HINCRYBYFLOAT</h3><p>这些命令和string中的数字操作命令一致，因为hash中的value也是字符串，也能当作数字来处理。参数可以是负数来左减法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field num</span><br><span class="line">HINCRBYFLOAT key field float</span><br></pre></td></tr></table></figure><p>测试如下，两个命令的返回值都是操作之后的变量值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrby user:1 age 10</span><br><span class="line">(integer) 30</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user:1 age 10.13</span><br><span class="line">&quot;40.13&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user:1 age -11.13</span><br><span class="line">&quot;29&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-10-HSTRLEN"><a href="#2-2-10-HSTRLEN" class="headerlink" title="2.2.10 HSTRLEN"></a>2.2.10 HSTRLEN</h3><p>计算hash中value的字符串长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSTRLEN key field</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 age</span><br><span class="line">&quot;29&quot;</span><br><span class="line">127.0.0.1:6379&gt; hstrlen user:1 age</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h2 id="2-3-编码介绍"><a href="#2-3-编码介绍" class="headerlink" title="2.3 编码介绍"></a>2.3 编码介绍</h2><p>之前在Redis基础命令博客的<code>object encoding</code>中提到，hash有两种编码方式，一个是ziplist，一个是hashtable。</p><p>其中ziplist是在hash中元素较少的情况下使用的，如下所示，刚开始hash中的f1只有3个字节的字符串长度，使用的是ziplist来存放；当我买尝试设置一个非常长的字符串f2，就会切换成hashtable来存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset key f1 111</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset key f2 235xczbjlkq3e5jl123j5ljlbsjlk32j6l5k1hasldg82357989789787124nlahbkasdlj3215897avsalkjl32k51432097zvlmq32j5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><p>如果你了解hashtable的数据结构，以拉链法为例，它会有一个数组，内部存放链表指针。存放数据时，通过哈希函数计算出key所在下标位置，将value链接到数组下标位置的对应指针上，即为存放完毕。当hash表中的元素较少时，数组可能会空出几个下标的位置没有value链接，这几个下标的空间就算是浪费了。</p><p>而使用ziplist就可以节省这部分空间的浪费，对应的代价是ziplist的读写速度会慢于原生hashtable。</p><p>在Redis中可以通过下面两个配置项来设置hash什么时候使用ziplist，写入<code>/etc/redis/redis.conf</code>即可。</p><table><thead><tr><th>配置</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>hash-max-ziplist-entries</td><td>设置field个数为多少以下时使用ziplist</td><td>默认512个</td></tr><tr><td>hash-max-ziplist-value</td><td>设置hash中value字符串的最大长度</td><td>默认为64字节</td></tr></tbody></table><h2 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h2><h3 id="2-4-1-关系数据库缓存"><a href="#2-4-1-关系数据库缓存" class="headerlink" title="2.4.1 关系数据库缓存"></a>2.4.1 关系数据库缓存</h3><p>正如介绍阶段时提到的，hash非常适合用于存放一些结构化的数据。以用户数据为例，可以用uid作为key的标识，内部存放对应的个人信息。有的时候为了方便，还会在hash中再存放一次uid。</p><table><thead><tr><th>key</th><th>field</th><th>value</th></tr></thead><tbody><tr><td>user:1</td><td>uid</td><td>1</td></tr><tr><td></td><td>name</td><td>李四</td></tr><tr><td></td><td>ag</td><td>20</td></tr><tr><td></td><td>sex</td><td>男</td></tr><tr><td>user:2</td><td>uid</td><td>2</td></tr><tr><td></td><td>name</td><td>王五</td></tr><tr><td></td><td>age</td><td>23</td></tr><tr><td></td><td>sex</td><td>男</td></tr></tbody></table><p>这样其实就好比一个MySQL数据库中的表</p><table><thead><tr><th>uid</th><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>1</td><td>李四</td><td>20</td><td>男</td></tr><tr><td>2</td><td>王五</td><td>23</td><td>男</td></tr></tbody></table><p>用这种方式，我们可以将MySQL中的表直接缓存在Redis中，提供更加快速的查询。需要修改数据的时候，也可以采用先修改Redis中的数据，再异步同步到MySQL中的方式来提高效率。</p><p>当然，使用string+json的方式也可以存放结构化数据，但在使用的时候就涉及到了<strong>json的序列化和反序列化</strong>，效率会低于直接使用Redis里面的hash来存放，不过使用hash会有更大的空间消耗。</p><p>这里还涉及到了高内聚&#x2F;低内聚的概念：</p><ul><li>高内聚：把有关联的数据存放在一起；</li><li>低内聚：有关联的东西散开存放了；</li></ul><p>使用hash来存放用户数据，就属于高内聚。如果使用<code>user:1:name</code>、<code>user:1:age</code>的key&#x2F;value来存放用户数据，就是低内聚，因为用户信息被拆开存放在了不同的key中。</p><p>同理，上文string中提到的视频播放量信息统计，也可以使用hash来存放一个视频的点击量&#x2F;点赞量，将一个视频的数据存放在一个hash中，而不用string来存放。</p><p>我们在设计的时候都强调<strong>高内聚、低耦合</strong>，就是为了整个系统能有更好的整洁度，维护更加方便。</p><h3 id="2-4-2-hash和关系数据库的区别"><a href="#2-4-2-hash和关系数据库的区别" class="headerlink" title="2.4.2 hash和关系数据库的区别"></a>2.4.2 hash和关系数据库的区别</h3><ul><li>哈希类型是稀疏的，关系数据库是结构化的。比如不同的hash里面的field完全没有关系，可以随意设置，但MySQL中一个表想插入一个数据，就必须依照表的要求设置所有数据；</li><li>关系数据库可以进行复杂的关系查询（比如多表查询），而Redis很难模拟关系查询，维护的复杂度很高且没有必要。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/d37409c171aed0f980fdea3322e6a54d.png" alt="image-20240219143844313"></p><h1 id="3-List"><a href="#3-List" class="headerlink" title="3 List"></a>3 List</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><p>Redis中的list列表类型提供了头插头删&#x2F;尾插尾删的命令，我们可以将它当作顺序表、栈、队列来使用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/e9f8229179473cd0d3ed2afb034c539d.png" alt="image-20240219144352348"></p><p>列表中的元素是按序存放的，所以我们可以通过下标来访问列表中的元素或获取一个范围中的元素。列表中的元素<strong>允许重复</strong>。</p><h2 id="3-2-相关命令"><a href="#3-2-相关命令" class="headerlink" title="3.2 相关命令"></a>3.2 相关命令</h2><h3 id="3-2-1-LINDEX"><a href="#3-2-1-LINDEX" class="headerlink" title="3.2.1 LINDEX"></a>3.2.1 LINDEX</h3><p>根据下标查看list中的数据，当下标超出范围时返回<code>nil</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure><p>index支持负数下标，从后往前数。比如<code>-1</code>代表从后往前第一个数据（即list末尾数据）。</p><p>注意，该命令的时间复杂度是<code>O(N)</code>，因为Redis中的list并非时刻采用顺序表来实现（会有不同编码方式），不能保证顺序表下标访问那样的快速！</p><h3 id="3-2-2-LPUSH-x2F-RPUSH"><a href="#3-2-2-LPUSH-x2F-RPUSH" class="headerlink" title="3.2.2 LPUSH&#x2F;RPUSH"></a>3.2.2 LPUSH&#x2F;RPUSH</h3><p>头插命令，支持一次插入多个数据。如果指定的key不是list类型则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]</span><br></pre></td></tr></table></figure><p>注意，当一次插入多个数据时，最后一个数据会在list的头部（按命令中出现的顺序，从左往右插入）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; lpush key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lindex key 0</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure><p>尾插也是相同的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key element [element ...]</span><br></pre></td></tr></table></figure><p>一次性插入多个数据的时候，也是最后一个数据在list的末尾。可以用lindex命令指定<code>-1</code>下标来获取末尾的数据（从后往前数第一个值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 5 6 7 8</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lindex key -1</span><br><span class="line">&quot;8&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-LPOP-x2F-RPOP"><a href="#3-2-3-LPOP-x2F-RPOP" class="headerlink" title="3.2.3 LPOP&#x2F;RPOP"></a>3.2.3 LPOP&#x2F;RPOP</h3><p>从list的头部或者尾部去除数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]</span><br><span class="line">RPOP key [count]</span><br></pre></td></tr></table></figure><p>注意，高版本Redis才有可选的count选项，当前我使用的Redis仅可一次pop一个元素，返回值是被删除的元素。</p><blockquote><p>Starting with Redis version 6.2.0: Added the <code>count</code> argument.</p></blockquote><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop key</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure><p>如果是高版本，指定count参数后，会返回一个被删除元素的array，效果参考下面这个官网给出的examples。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot;</span><br><span class="line">(integer) 5</span><br><span class="line">redis&gt; LPOP mylist</span><br><span class="line">&quot;one&quot;</span><br><span class="line">redis&gt; LPOP mylist 2</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;three&quot;</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;four&quot;</span><br><span class="line">2) &quot;five&quot;</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure><p>如果尝试操作一个空的list或者不存在的key，返回值是<code>nil</code>；如下所示，key1的list中只有1个元素，第一次成功删除元素，但是第二次操作的时候key1是一个空list，操作失败返回<code>nil</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key1 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpop key1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop key1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>当一个list中不存在元素的时候，Redis会自动将该list的key删除！如下所示，当我们把test键值中的元素全部删除时，这个test键值就直接不存在了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; lpush key 1 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush test 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">2) &quot;test&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop test</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-LRANGE"><a href="#3-2-4-LRANGE" class="headerlink" title="3.2.4 LRANGE"></a>3.2.4 LRANGE</h3><p>查看list中指定范围的元素，这里的区间是闭区间（最终结果包含start和stop下标的数据），当start小于stop时返回<code>empty array</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure><p>示例如下，指定了<code>0</code>和<code>-1</code>等同于获取list中的全部元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br></pre></td></tr></table></figure><p>注意，此处Redis是用array返回的一个结果集，序号是从1开始的（和list中的下标不一样且无关）</p><h4 id="3-2-4-1-超出下标范围"><a href="#3-2-4-1-超出下标范围" class="headerlink" title="3.2.4.1 超出下标范围"></a>3.2.4.1 超出下标范围</h4><p>另外，使用lrange命令指定下标的时候，如果下标超出范围，也会得到尽可能符合下标结果的数据，这点和lindex不同！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key 3 10</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">4) &quot;7&quot;</span><br><span class="line">5) &quot;8&quot;</span><br></pre></td></tr></table></figure><p>如上所示，我尝试访问3到10的数据，但实际上list中的数据下标到7就结束了（一共八个元素），但Redis并没有报错或返回<code>empty array</code>，而是获取了从下标3开始一直到list末尾的数据。</p><p>同理，当你访问超出范围的负数下标，也能得到类似的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key -10 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br></pre></td></tr></table></figure><p>当然，实际业务时正确使用合法肯定是更好的！</p><h3 id="3-2-5-LPUSHX-x2F-RPUSHX"><a href="#3-2-5-LPUSHX-x2F-RPUSHX" class="headerlink" title="3.2.5 LPUSHX&#x2F;RPUSHX"></a>3.2.5 LPUSHX&#x2F;RPUSHX</h3><p>和LPUSH&#x2F;RPUSH作用相同，多了一个对key是否存在的检测，只有key存在时才能插入成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX key element [element ...]</span><br><span class="line">RPUSHX key element [element ...]</span><br></pre></td></tr></table></figure><p>返回值是插入成功的元素个数，如果key不存在则返回0；</p><h3 id="3-2-6-LINSERT"><a href="#3-2-6-LINSERT" class="headerlink" title="3.2.6 LINSERT"></a>3.2.6 LINSERT</h3><p>这个命令的作用是在指定pivot元素位置插入一个元素，可以通过参数选择是在指定pivot元素之前插入，还是在指定pivot元素之后插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key &lt;BEFORE | AFTER&gt; pivot element</span><br></pre></td></tr></table></figure><p>该命令时间复杂度是<code>O(N)</code>，N是pivot元素和list开头的距离，返回值如下：</p><ul><li>成功时返回插入元素后list的元素个数；</li><li>key不存在时返回0；</li><li>pivot元素不存在时返回-1，且什么都不会发生；</li></ul><p>测试如下，这里选择的已有元素是4，before会在4之前插入一个元素，after会在4之后插入一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; linsert key before 4 10</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;2&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert key after 4 11</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;11&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>清空key后重新测试，如果list中有多个相同的pivot元素，会在哪里操作呢？可以看到它会在第一个5的位置操作，即pivot会采用第一个找到的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key 1 2 5 3 4 5 6</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; linsert key before 5 10</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;5&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-7-LLEN"><a href="#3-2-7-LLEN" class="headerlink" title="3.2.7 LLEN"></a>3.2.7 LLEN</h3><p>获取list的长度，如果key不存在返回0；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><h3 id="3-2-8-LREM"><a href="#3-2-8-LREM" class="headerlink" title="3.2.8 LREM"></a>3.2.8 LREM</h3><p>删除list中指定的值，返回值是被删除元素的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count element</span><br></pre></td></tr></table></figure><p>count参数的可选项如下</p><ul><li>count大于0：从前往后删除count个等于element的元素；</li><li>count小于0：从后往前删除<code>|count|</code>个等于element的元素；</li><li>count等于0：删除所有等于element的元素；</li></ul><p>测试一下，使用rpush可以让list和我们输入的顺序一致。这里指定的count大于0，删除的元素是1，最终删除了从前往后数的两个1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 1 2 3 4 1 2 3 4 1 2 3 4</span><br><span class="line">(integer) 12</span><br><span class="line">127.0.0.1:6379&gt; lrem key 2 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line"> 1) &quot;2&quot;</span><br><span class="line"> 2) &quot;3&quot;</span><br><span class="line"> 3) &quot;4&quot;</span><br><span class="line"> 4) &quot;2&quot;</span><br><span class="line"> 5) &quot;3&quot;</span><br><span class="line"> 6) &quot;4&quot;</span><br><span class="line"> 7) &quot;1&quot;</span><br><span class="line"> 8) &quot;2&quot;</span><br><span class="line"> 9) &quot;3&quot;</span><br><span class="line">10) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>再指定count为-1，删除元素是3，会删除从后往前数的第一个3；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem key -1 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;4&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;4&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">8) &quot;2&quot;</span><br><span class="line">9) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>指定count为0，删除元素是4，list中的所有4都会被删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem key 0 4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;1&quot;</span><br><span class="line">6) &quot;2&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-9-LTRIM"><a href="#3-2-9-LTRIM" class="headerlink" title="3.2.9 LTRIM"></a>3.2.9 LTRIM</h3><p>删除list中指定区间<strong>外</strong>的元素（即保留指定的闭区间，其他都删除）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key start stop</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; ltrim key 2 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-10-LSET"><a href="#3-2-10-LSET" class="headerlink" title="3.2.10 LSET"></a>3.2.10 LSET</h3><p>该命令可以设置某个下标的元素（替换）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSET key index element</span><br></pre></td></tr></table></figure><p>该命令的时间复杂度是<code>O(N)</code>，这就和LINDEX的原因一样，因为Redis不总是用顺序表来存放list的数据，所以无法保证<code>O(1)</code>下标访问一样的时间复杂度。</p><h3 id="3-2-11-BLPOP-x2F-BRPOP（阻塞版本）"><a href="#3-2-11-BLPOP-x2F-BRPOP（阻塞版本）" class="headerlink" title="3.2.11 BLPOP&#x2F;BRPOP（阻塞版本）"></a>3.2.11 BLPOP&#x2F;BRPOP（阻塞版本）</h3><h4 id="3-2-11-1-阻塞命令说明"><a href="#3-2-11-1-阻塞命令说明" class="headerlink" title="3.2.11.1 阻塞命令说明"></a>3.2.11.1 阻塞命令说明</h4><p>BLPOP和BRPOP是LPOP&#x2F;RPOP的阻塞版本，命令里面的B就是block阻塞的缩写。这也是我们第一次接触Redis里面的“阻塞命令”。</p><p>使用这两个命令的时候，list就可以当作一个阻塞队列（和Linux的管道也有点相似）了：</p><ul><li>如果队列为空，尝试出队列时会阻塞;</li><li>如果队列已满，尝试入队列时会阻塞;</li></ul><p>对于Redis而言，list一般不存在“满”的情况，我们大多考虑队列为空的情况。而Redis的单线程模型也保证了这个“阻塞队列”是线程安全的。</p><p>另外，Redis提供的阻塞命令<strong>并不会把自己给阻塞</strong>，而类似于阻塞了客户端，使用BLPOP&#x2F;BRPOP的时候需要给定一个timeout参数，在阻塞等待的期间，<strong>Redis可以正常响应其他的命令和请求</strong>。</p><p>而被阻塞的客户端实际上是在等待其他客户端往对应list中插入新元素。</p><h4 id="3-2-11-2-命令参数"><a href="#3-2-11-2-命令参数" class="headerlink" title="3.2.11.2 命令参数"></a>3.2.11.2 命令参数</h4><p><a href="https://redis.io/commands/blpop/">https://redis.io/commands/blpop/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure><p>注意：timeout单位为秒，Redis 6中可以设置为小数，设置为0时代表永久阻塞。</p><p>这两个命令都可以指定多个key，当指定多个key的时候，Redis会进行从左往右的遍历，只要其中一个key对应的list有元素，就会立刻返回。相当于一次等多个list。</p><blockquote><p>如果有多个客户端都需要使用这两个命令来等待<strong>同一个key</strong>，那么先执行命令的客户端会得到弹出的元素。</p></blockquote><p>因为blpop&#x2F;brlpop都支持多个key值等待，为了标定弹出的键属于哪一个key，这两个命令在返回的时候会返回array类型的key+value；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; blpop key 0</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>当超时时间结束时，给定的几个key的list还是为空，则会返回nil；</p><h4 id="3-2-11-3-命令预期行为"><a href="#3-2-11-3-命令预期行为" class="headerlink" title="3.2.11.3 命令预期行为"></a>3.2.11.3 命令预期行为</h4><p>当list不为空时，lpop和blpop的命令行为完全一致。</p><p>当list为空，且blpop指定的timeout时间中没有新元素插入list时：</p><ul><li>lpop会立马得到nil；</li><li>blpop会在等待timeout时间后得到nil；</li><li>此时lpop和brlpop的命令行为就不一致了。</li></ul><p>当list为空，且timeout时间内有新元素插入</p><ul><li>因为原本list是为空的，所以lpop还是会立马得到nil；</li><li>blpop会在新元素插入后返回key和新元素；</li></ul><h4 id="3-2-11-4-阻塞测试"><a href="#3-2-11-4-阻塞测试" class="headerlink" title="3.2.11.4 阻塞测试"></a>3.2.11.4 阻塞测试</h4><p>下面是一个阻塞时的测试，使用0来指定永久阻塞，当右侧终端回车提交插入操作时，左侧的阻塞会立马返回数据。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/2a28441785171abc8b20a27af768dfd9.png" alt="image-20240221211633743"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/a466d5f993d3a24be07a7dd93037a8c1.png" alt="image-20240221211639797"></p><p>尝试等待多个key，只要有一个key返回了数据，阻塞的终端就会立马返回。虽然说这个等待时遍历的顺序是从左往右的，但由于Redis是单线程模型，不会出现两个key同时新增数据的情况，<strong>总会有个先后顺序</strong>，所以最终还是等待列表中，<strong>哪一个key先有数据插入</strong>，哪一个key就会被blpop返回。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/8156e009dcd7a8ac02ade9b5df20bbed.png" alt="image-20240221212327656"></p><p>如果开始遍历的时候，key没有数据，key1和key2有数据，那么Redis就会按从左往右的原则，返回key1的数据。</p><h2 id="3-3-编码方式"><a href="#3-3-编码方式" class="headerlink" title="3.3 编码方式"></a>3.3 编码方式</h2><p>旧版本Redis中list的编码方式有两个</p><ul><li>ziplist：为短list优化</li><li>linklist：正常的双向链表</li></ul><p>但在新版本（Redis 3.2以后）对list的数据结构进行了改造，使用quicklist替代了ziplist&#x2F;linklist，更多信息可以参考：<a href="https://www.cnblogs.com/hunternet/p/12624691.html">redis数据结构-快速列表</a>；</p><h2 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 应用场景</h2><h3 id="3-4-1-栈和队列"><a href="#3-4-1-栈和队列" class="headerlink" title="3.4.1 栈和队列"></a>3.4.1 栈和队列</h3><p>使用list来模拟栈或者队列的功能</p><ul><li>队列：只使用rpush和lpop命令</li><li>栈：只使用lpush和lpop命令</li></ul><h3 id="3-4-2-班级中有那些学生-x2F-部门中有那些员工"><a href="#3-4-2-班级中有那些学生-x2F-部门中有那些员工" class="headerlink" title="3.4.2 班级中有那些学生&#x2F;部门中有那些员工"></a>3.4.2 班级中有那些学生&#x2F;部门中有那些员工</h3><p>可以使用list将一个班级id作为key，学生id作为list里面的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class:1  [1,3,4]</span><br><span class="line">class:2  [2,5,6]</span><br></pre></td></tr></table></figure><p>这样我们就可以通过list来得知每个班级对应的学生id编号。部门和员工的关系也是一样的；</p><h3 id="3-4-3-消息队列"><a href="#3-4-3-消息队列" class="headerlink" title="3.4.3 消息队列"></a>3.4.3 消息队列</h3><p>使用BLPOP&#x2F;BRPOP这两个命令就可以让list作为一个简单的消息队列来使用。</p><p>以“生产-消费者模型”为例，生产者往list中插入数据，消费者使用BLPOP等待新数据的插入并进行消费。此时可以有多个生产者进行push，也可以有多个消费者同时使用BLPOP命令等待list中的新数据插入。</p><p>因为Redis不存在多线程竞争的问题，所以新数据插入后只会有一个消费者能拿到数据进行消费。并且多个消费者执行BLPOP命令时也存在一个先后顺序，按123的顺序来说的话，这一次消费者1拿到了数据，下一次就是消费者2，再下一次就是消费者3，不会出现某个消费者<strong>饥饿</strong>的情况。</p><h3 id="3-4-4-视频信息传递"><a href="#3-4-4-视频信息传递" class="headerlink" title="3.4.4 视频信息传递"></a>3.4.4 视频信息传递</h3><p>以一个视频网站为例，使用list作为消息队列时，可以采用一个视频对应多个key的方式来处理</p><ul><li>视频数据</li><li>视频评论</li><li>视频新弹幕</li><li>…</li></ul><p>对应的消费者可以通过BLPOP命令一次性等待多个key，这样不管是新的评论来了，还是新的弹幕来了，都能在第一时间被处理。</p><h3 id="3-4-5-用户的timeline"><a href="#3-4-5-用户的timeline" class="headerlink" title="3.4.5 用户的timeline"></a>3.4.5 用户的timeline</h3><p>因为list里面的元素是有序的，先插入的始终是在list的头部。我们就可以通过list来实现一个时间轴的功能。</p><p>当用户新建一个微博的时候，就将这个微博的id插入用户相关的list，这样用户和他上传的微博就有了一个时间的关系，还可以用lrange命令很方便的获取到用户的前n个微博，或某个区间的微博。</p><p>下面是一个分页获取用户微博的伪代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先获取用户前10个微博</span></span><br><span class="line">key_list = <span class="string">&quot;LRANGE user:1:blog 0 9&quot;</span></span><br><span class="line"><span class="comment"># 遍历每个key获取到微博的详细信息</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> key_list: </span><br><span class="line">blog_info = <span class="string">&quot;HGETALL key&quot;</span></span><br></pre></td></tr></table></figure><p>这里就会出现一个问题，假设将单个分页需要显示的数据设置为100，那么每次循环中就会多次调用hash类型的HGETALL命令，导致Redis可能被阻塞。</p><blockquote><p>这个问题可以使用pipeline来解决，相当于将多个Redis命令合并成一个网络请求来执行，可以减少网络传输多次导致的延迟。后续将学习相关内容。</p></blockquote><p>另外一个问题是，lrange针对list两头的查询效率还不错（因为可以直接从头或从尾部开始遍历）但对中间的分页获取的效率就有点低了。这个问题可以通过list来解决（有点类似分库分表）。</p><h1 id="4-Set"><a href="#4-Set" class="headerlink" title="4 Set"></a>4 Set</h1><p>set是一个集合，集合中的每个元素都是string类型。它和list的区别主要在于：</p><ul><li>set的元素不可以重复；</li><li>set的元素是无序的；</li></ul><p>所谓无需，是相对于list的有序而言的（注意，list的有序指的是顺序表中元素的顺序，并不是说list会按大小排序）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3] 和 [1,3,2] 是两个不同的list</span><br><span class="line">[1,2,3] 和 [1,3,2] 和 [2,3,1] 都是相同的set</span><br></pre></td></tr></table></figure><h2 id="4-1-相关命令"><a href="#4-1-相关命令" class="headerlink" title="4.1 相关命令"></a>4.1 相关命令</h2><h3 id="4-1-1-SADD"><a href="#4-1-1-SADD" class="headerlink" title="4.1.1 SADD"></a>4.1.1 SADD</h3><p>SADD命令用于给set中添加元素，为了和list中的元素作区分，set中的元素被称为member。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><p>返回值表示本次操作添加成功了几个元素，重复的元素只会被添加一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4 5 4</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><h3 id="4-1-2-SMEMBERS"><a href="#4-1-2-SMEMBERS" class="headerlink" title="4.1.2 SMEMBERS"></a>4.1.2 SMEMBERS</h3><p>查看set的所有成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers key</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-SISMEMBER"><a href="#4-1-3-SISMEMBER" class="headerlink" title="4.1.3 SISMEMBER"></a>4.1.3 SISMEMBER</h3><p>查看某个元素是否在集合中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p>返回值为1代表存在，返回值为0代表不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember key 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember key 120</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="4-1-4-SPOP"><a href="#4-1-4-SPOP" class="headerlink" title="4.1.4 SPOP"></a>4.1.4 SPOP</h3><p>该命令可以弹出set中的元素。但因为set是无序的，所以我们只能指定删除元素的个数，Redis会<strong>随机删除（弹出）</strong>set中的元素，这一点在官方文档中有说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure><p>返回值是被删除的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; spop key 2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure><p>这个命令也能体现出set中元素无序的概念。我们按1234构架两个set，尝试进行spop，能发现每次删除的元素的顺序是不一样的，完全随机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="4-1-5-SRANDMEMBER"><a href="#4-1-5-SRANDMEMBER" class="headerlink" title="4.1.5 SRANDMEMBER"></a>4.1.5 SRANDMEMBER</h3><p>这个命令和SPOP功能类似，返回set中的一个或多个随机数据，但不会删除该数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></table></figure><h3 id="4-1-6-SMOVE"><a href="#4-1-6-SMOVE" class="headerlink" title="4.1.6 SMOVE"></a>4.1.6 SMOVE</h3><p>将某个元素从set1移动到set2，或者说是从source中删除，在destination中新增。</p><p>如果destination中已经存在该元素，则只会删除source中的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member</span><br></pre></td></tr></table></figure><p>测试如下，该命令成功时返回1，不成功返回0（source中不存在该元素时失败）；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 5 6</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smove key1 key2 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers key2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">127.0.0.1:6379&gt; smove key1 key2 33</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="4-1-7-SREM"><a href="#4-1-7-SREM" class="headerlink" title="4.1.7 SREM"></a>4.1.7 SREM</h3><p>删除set中的指定元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><h3 id="4-1-8-SINTER-x2F-SINTERSTORE"><a href="#4-1-8-SINTER-x2F-SINTERSTORE" class="headerlink" title="4.1.8 SINTER&#x2F;SINTERSTORE"></a>4.1.8 SINTER&#x2F;SINTERSTORE</h3><p>求两个集合的交集，即获取同时出现在两个set中的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure><p>这个命令的时间复杂度是<code>O(M*N)</code>，其中M是最小的集合元素个数，N是最大的集合元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sinter key1 key2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>另外一个命令是SINTERSTORE，它多了一个存储功能，求了交集后，存储到destination中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p>这个命令的返回值是最终交集的元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sinterstore key3 key1 key2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3 id="4-1-9-SUNION-x2F-SUNIONSTORE"><a href="#4-1-9-SUNION-x2F-SUNIONSTORE" class="headerlink" title="4.1.9 SUNION&#x2F;SUNIONSTORE"></a>4.1.9 SUNION&#x2F;SUNIONSTORE</h3><p>求两个集合的并集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUNION key [key ...]</span><br><span class="line">SUNIONSTROE destination key [key ...]</span><br></pre></td></tr></table></figure><p>功能和上面的命令类似，这里就不做演示了</p><h3 id="4-1-10-SDIFF-x2F-SDIFFSTORE"><a href="#4-1-10-SDIFF-x2F-SDIFFSTORE" class="headerlink" title="4.1.10 SDIFF&#x2F;SDIFFSTORE"></a>4.1.10 SDIFF&#x2F;SDIFFSTORE</h3><p>求集合的差集，即存在于第一个key，但是不在第二个key中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br><span class="line">SDIFFSTROE destination key [key ...]</span><br></pre></td></tr></table></figure><p>实测如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff key2 key1</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure><p>如果key的数量不止两个，你可以理解为Redis会进行依次计算。即先计算key1和key2的差集，再将结果和key3进行计算。如下所示，key1和key2的差集包含1和2，但是key3中有1，所以最终的差集结果就只有2了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key3 1 3 7 8</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2 key3</span><br><span class="line">1) &quot;2&quot;</span><br></pre></td></tr></table></figure><h3 id="4-1-11-SCARD"><a href="#4-1-11-SCARD" class="headerlink" title="4.1.11 SCARD"></a>4.1.11 SCARD</h3><p>获取set中元素的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; scard key1</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><h2 id="4-2-编码方式"><a href="#4-2-编码方式" class="headerlink" title="4.2 编码方式"></a>4.2 编码方式</h2><p>set有两种编码方式</p><ul><li>intset：如果set中全都是整数，采用这种方式，可以通过<code>set-max-intset-entries</code>来配置元素个数，超过这个数量的会采用hashtable。</li><li>hashtable：当set中有其他非数字类型时，采用这种方式。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd key 1afb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><h2 id="4-3-应用场景"><a href="#4-3-应用场景" class="headerlink" title="4.3 应用场景"></a>4.3 应用场景</h2><h3 id="4-3-1-保存标签"><a href="#4-3-1-保存标签" class="headerlink" title="4.3.1 保存标签"></a>4.3.1 保存标签</h3><p>一个视频会有相关标签，一个用户也会有相关标签，set类型有元素不能重复的特性，比较适合用于保存某个对象的标签。</p><p>比如某个用户的兴趣爱好，这些爱好能帮助刻画一个用户画像，以便更加精确的推送用户喜欢的东西（或则广告）</p><h3 id="4-3-2-公共好友"><a href="#4-3-2-公共好友" class="headerlink" title="4.3.2 公共好友"></a>4.3.2 公共好友</h3><p>通过集合求交集，能很容易得到两个用户的公共好友，或者共同关注了xxx。</p><h3 id="4-3-3-记录站点PV-x2F-UV"><a href="#4-3-3-记录站点PV-x2F-UV" class="headerlink" title="4.3.3 记录站点PV&#x2F;UV"></a>4.3.3 记录站点PV&#x2F;UV</h3><p>站点PV（Page View）指的是站点的访问量，每次点击一个页面，就会产生一个PV。</p><p>站点UV（User View）指的是站点的用户访问量，每个用户只会记录一次。</p><p>因为PV和UV的记录内容不同，在记录的时候需要进行一定的去重。比如UV需要按用户去重，一个用户只能记录一次。这时候用set来去重就比较方便了，当有新用户访问页面的时候，就将这个用户的id插入到对应key的set中，最终记录UV就获取这个set的长度就行。</p><h1 id="5-Zset"><a href="#5-Zset" class="headerlink" title="5.Zset"></a>5.Zset</h1><p>Zset是有序的集合，在集合的基础上，对内容会进行升序排序。</p><p>Zset中的member同时引入了一个<code>score</code>分数的属性，每个member都会有一个自己的分数，排序的时候就是按分数的大小来进行<strong>升序排序</strong>的。Zset中的member必须唯一，但score分数可以重复。</p><p>注意，member&#x2F;score之间的关系并非键值对，score只是member的一个用于排序的属性值！在Zset中既可以通过member查询score，也可以通过score来查询member。</p><p>Zset中的分数可以是小数。如果多个元素有相同的分数，则按元素的字典序排序。</p><h2 id="5-1-相关命令"><a href="#5-1-相关命令" class="headerlink" title="5.1 相关命令"></a>5.1 相关命令</h2><h3 id="5-1-1-ZADD"><a href="#5-1-1-ZADD" class="headerlink" title="5.1.1 ZADD"></a>5.1.1 ZADD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member</span><br><span class="line">  ...]</span><br></pre></td></tr></table></figure><p>ZADD命令有很多选项，其中一些选项之前已经见过了</p><ul><li>XX：只有member存在的时候，才会更新分数；</li><li>NX：插入新的member，如果已存在则不做任何处理；</li><li>LT：只有新的score<strong>小于</strong>当前score时才会更新， 不会阻止添加新元素（不存在的member正常添加）</li><li>GT：同上，但只有新的score<strong>大于</strong>当前score时才会更新；</li><li>CH：一般情况下，ZADD返回新元素被添加的个数。添加CH选项后，会返回新元素被添加的个数+被修改score的元素个数。</li><li>INCR：当指定此选项时，ZADD的作用类似于ZINCRBY。在此模式下只能指定一个score-element对。</li></ul><p>这个命令的时间复杂度<code>O(log(N))</code>，<strong>N是Zset中元素的个数</strong>。因为zset作为有序的结构，需要将新插入的元素放到正确的位置上，这个操作会有耗时。</p><p>插入数据后查看，可以看到数据是按我们预先设置是分数进行升序排序的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 98 lisi 97 zhangsan 99 wangwu</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br></pre></td></tr></table></figure><p>测试NX&#x2F;XX选项，如果不带任何选项，则会更新已有member的分数（原本lisi的分数是98），带了NX选项后，lisi的分数没有被修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 99 lisi</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;99&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd key nx 100 lisi</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;99&quot;</span><br></pre></td></tr></table></figure><p>带xx选项，lisi的分数被修改成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key xx 100 lisi</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>带xx选项操作一个不存在的member，没有被新增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key xx 100 kk</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>ch会在返回值中带上被修改分数的个数，如下所示，kk已经存在，将分数修改为110，带ch选项，返回值为1；再次修改kk的分数，不带ch选项，返回值为0，但kk的分数已经被修改为112了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key xx ch 110 kk</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd key xx 112 kk</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 9) &quot;kk&quot;</span><br><span class="line">10) &quot;112&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-ZRANGE"><a href="#5-1-2-ZRANGE" class="headerlink" title="5.1.2 ZRANGE"></a>5.1.2 ZRANGE</h3><p>ZRANGE类似于LRANGE，可以用下标的方式来查看Zset中的元素个数。因为Zset中的元素有序，所以它存在“下标”的概念。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count]</span><br><span class="line">  [WITHSCORES]</span><br></pre></td></tr></table></figure><p>这个命令的时间复杂度是<code>O(log(N)+M)</code>，其中N是ZSET中的元素个数，M是需要返回的元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 98 lisi 97 zhangsan 99 wangwu</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br></pre></td></tr></table></figure><p>使用WITHSCORES选项，可以让元素和分数一起返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;98&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;99&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-ZCARD"><a href="#5-1-3-ZCARD" class="headerlink" title="5.1.3 ZCARD"></a>5.1.3 ZCARD</h3><p>获取Zset中元素的个数（被称为zset的基数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wangwu&quot;</span><br><span class="line">3) &quot;kk1&quot;</span><br><span class="line">4) &quot;lisi&quot;</span><br><span class="line">5) &quot;kk&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcard key</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><h3 id="5-1-4-ZCOUNT"><a href="#5-1-4-ZCOUNT" class="headerlink" title="5.1.4 ZCOUNT"></a>5.1.4 ZCOUNT</h3><p>返回分数在min&#x2F;max之间的元素个数，默认是闭区间，包含min和max的值。该命令的时间复杂度是<code>O(log(N))</code>，N是Zset中元素个数。</p><p>zset在存放一个member的时候会保存它的次序（可以简单理解为下标）所以这个命令不是通过min到max的遍历来获取元素的，而是先找到min和max这两个边界值的member，再获取到它们的元素次序，<strong>最终将次序相减，就得到了元素个数</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure><p>可以使用括号来表示开区间，注意括号都是加在前面的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key (min (max</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line"> 1) &quot;zhangsan&quot;</span><br><span class="line"> 2) &quot;97&quot;</span><br><span class="line"> 3) &quot;wangwu&quot;</span><br><span class="line"> 4) &quot;99&quot;</span><br><span class="line"> 5) &quot;kk1&quot;</span><br><span class="line"> 6) &quot;100&quot;</span><br><span class="line"> 7) &quot;lisi&quot;</span><br><span class="line"> 8) &quot;100&quot;</span><br><span class="line"> 9) &quot;kk&quot;</span><br><span class="line">10) &quot;112&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcount key 97 100</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zcount key 97 (100</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>因为zset中的score可以使用浮点数，在Redis中有两个特殊的浮点数，用于表示正无穷大<code>inf</code>和负无穷大<code>-inf</code>，所以在ZCOUNT的min&#x2F;max中也可以用这两个特殊的浮点数来筛选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcount key -inf 100</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><h3 id="5-1-5-ZREVRANCE"><a href="#5-1-5-ZREVRANCE" class="headerlink" title="5.1.5 ZREVRANCE"></a>5.1.5 ZREVRANCE</h3><p>这个命令的作用和ZRANGE类似，但返回的数据是降序的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANGE key 0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;kk&quot;</span><br><span class="line"> 2) &quot;112&quot;</span><br><span class="line"> 3) &quot;lisi&quot;</span><br><span class="line"> 4) &quot;100&quot;</span><br><span class="line"> 5) &quot;kk1&quot;</span><br><span class="line"> 6) &quot;100&quot;</span><br><span class="line"> 7) &quot;wangwu&quot;</span><br><span class="line"> 8) &quot;99&quot;</span><br><span class="line"> 9) &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure><p>注意，该命令在Redis6.2中已经**弃用(deprecated)**，在ZRANGE中使用REV选项能实现它的功能。</p><blockquote><p>As of Redis version 6.2.0, this command is regarded as deprecated.</p><p>It can be replaced by <a href="https://redis.io/commands/zrange"><code>ZRANGE</code></a> with the <code>REV</code> argument when migrating or writing new code.</p></blockquote><h3 id="5-1-6-ZPOPMAX-x2F-ZPOPMIN"><a href="#5-1-6-ZPOPMAX-x2F-ZPOPMIN" class="headerlink" title="5.1.6 ZPOPMAX&#x2F;ZPOPMIN"></a>5.1.6 ZPOPMAX&#x2F;ZPOPMIN</h3><p>删除并返回Zset中分数最高的count个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZPOPMAX key [count]</span><br><span class="line">ZPOPMIN key [count]</span><br></pre></td></tr></table></figure><p>这个命令可以用来解决TopK问题，假设有个10元素的zset，想获得score在前3的元素的一个set，可以使用两种方式</p><ul><li>ZPOPMAX将高三位弹出并存放到另外一个zset中；</li><li>ZPOPMIN将低七位弹出，此时剩下的就是高三位；</li></ul><p>测试如下，pop的时候会将member和score一起弹出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zpopmax key 2</span><br><span class="line">1) &quot;kk&quot;</span><br><span class="line">2) &quot;112&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;100&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-7-BZPOPMAX"><a href="#5-1-7-BZPOPMAX" class="headerlink" title="5.1.7 BZPOPMAX"></a>5.1.7 BZPOPMAX</h3><p>这个命令是ZPOPMAX的阻塞版本，当key中没有元素时会阻塞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BZPOPMAX key [key ...] timeout</span><br></pre></td></tr></table></figure><p>这个和BLPOP&#x2F;BRPOP的效果一样，不做演示了。</p><h3 id="5-1-8-ZRANK"><a href="#5-1-8-ZRANK" class="headerlink" title="5.1.8 ZRANK"></a>5.1.8 ZRANK</h3><p>获取一个Zset中某个成员的排名（返回的是排名序号，以0开始）时间复杂度<code>O(log(N))</code>，N是Zset中元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member [WITHSCORE]</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wangwu&quot;</span><br><span class="line">3) &quot;kk1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrank key wangwu</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>redis7.2后，添加withscore选项，会同时返回这个成员的分数</p><h3 id="5-1-9-ZREVRANK"><a href="#5-1-9-ZREVRANK" class="headerlink" title="5.1.9 ZREVRANK"></a>5.1.9 ZREVRANK</h3><p>返回某个成员的排名，降序排序。时间复杂度<code>O(log(N))</code>，N是Zset中元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANK key member [WITHSCORE]</span><br></pre></td></tr></table></figure><p>redis7.2后，添加withscore选项，会同时返回这个成员的分数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wangwu&quot;</span><br><span class="line">3) &quot;kk1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrank key wangwu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrevrank key kk1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrevrank key zhangsan</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3 id="5-1-10-ZSCORE"><a href="#5-1-10-ZSCORE" class="headerlink" title="5.1.10 ZSCORE"></a>5.1.10 ZSCORE</h3><p>返回zset中某个成员的分数，时间复杂度为<code>O(1)</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;kk1&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; zscore key kk1</span><br><span class="line">&quot;100&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-11-ZREM"><a href="#5-1-11-ZREM" class="headerlink" title="5.1.11 ZREM"></a>5.1.11 ZREM</h3><p>删除某个zset中的member，可以一次性传入多个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(M*log(N))</code>，N是zset中元素个数，M是需要删除的元素个数。</p><h3 id="5-1-12-ZREMRANGEBYRANK"><a href="#5-1-12-ZREMRANGEBYRANK" class="headerlink" title="5.1.12 ZREMRANGEBYRANK"></a>5.1.12 ZREMRANGEBYRANK</h3><p>删除某个区间的元素，和ZRANGE的start&#x2F;stop相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(log(N)+M) </code>，N是zset中元素个数，M是区间内的元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 1 one 2 two 3 three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK key 0 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-13-ZREMRANGEBYSCORE"><a href="#5-1-13-ZREMRANGEBYSCORE" class="headerlink" title="5.1.13 ZREMRANGEBYSCORE"></a>5.1.13 ZREMRANGEBYSCORE</h3><p>删除某个区间的元素，使用的是min&#x2F;max分数区间，默认闭区间，也可以用左括号表示开区间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br><span class="line">ZREMRANGEBYSCORE key (min (max</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(log(N)+M) </code>，N是zset中元素个数，M是区间内的元素个数。 </p><h3 id="5-1-14-ZINCRBY"><a href="#5-1-14-ZINCRBY" class="headerlink" title="5.1.14 ZINCRBY"></a>5.1.14 ZINCRBY</h3><p>给某个zset中的元素<strong>增加分数</strong>，如果元素不存在，则和zadd的作用相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(log(N))</code>，N为zset中元素个数。</p><h3 id="5-1-15-ZUNIONSTORE"><a href="#5-1-15-ZUNIONSTORE" class="headerlink" title="5.1.15 ZUNIONSTORE"></a>5.1.15 ZUNIONSTORE</h3><p>这个命令会求两个zset的<strong>并集</strong>并存放到的destination中。</p><p>时间复杂度：<code>O(N)+O(M log(M))</code>，N是所有input参数zset中元素的个数总和，M是结果集中的元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight</span><br><span class="line">  [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]</span><br></pre></td></tr></table></figure><p>命令参数</p><ul><li>destination：目标zset的key，如果这个key已经存在，则会被覆盖。</li><li>numkeys：输入的key的个数</li><li>WEIGHTS：给每个入参的key设定的乘法系数，当求交集的时候，会将最终结果的分值乘以这个乘法系数再交付。不提供的时候默认为1；</li><li>AGGREGATE：该选项可以指定并集运算结果的聚合方式。该选项默认值为 SUM，即将输入中所有存在该元素的集合中对应的分值全部加一起。当选项被设置为 MIN 或 MAX 任意值时，结果集合将保存输入中所有存在该元素的集合中对应的分值的最小或最大值。</li></ul><p>测试如下，先不使用weights，可以看到两个zset中，相同的元素的分数会相加，one的分值变成了2，two的分值变成了4；如果只有一个zset存在的元素则保持不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd zset2 1 &quot;one&quot; 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>使用weight提供乘法系数，zset1中的分值被乘以2，zset2中的分值被乘以3，然后二者再相加起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2 weights 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;10&quot;</span><br></pre></td></tr></table></figure><p>如果修改AGGREGATE策略，结果又不同，默认sum是相加；指定min是当两个zset都有某个参数的时候，选用分数较小的哪一个。比如zset1中乘法系数是2，所以one&#x2F;two的分数<strong>小于</strong>zset2中的分数，最终的集合out中存放的就是zset1中的元素分数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2 weights 2 3 aggregate min</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;9&quot;</span><br></pre></td></tr></table></figure><p>使用<code>AGGREGATE MAX</code>存放的就会是zset2中的分数了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2 weights 2 3 aggregate max</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;6&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;9&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-16-ZINTERSTORE"><a href="#5-1-16-ZINTERSTORE" class="headerlink" title="5.1.16 ZINTERSTORE"></a>5.1.16 ZINTERSTORE</h3><p>这个命令存放并集到destination中，相关的命令选项和<code>ZUNIONSTORE</code>一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight</span><br><span class="line">  [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]</span><br></pre></td></tr></table></figure><p>时间复杂度：最坏情况是<code>O(N*K)+O(M*log(M))</code> ，N是最小的输入zset中的元素个数，K是输入参数中zset的个数，M是结果集中元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd zset2 1 &quot;one&quot; 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zinterstore out 2 zset1 zset2 weights 2 3</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;10&quot;</span><br></pre></td></tr></table></figure><h2 id="5-2-编码方式"><a href="#5-2-编码方式" class="headerlink" title="5.2 编码方式"></a>5.2 编码方式</h2><p>当zset中元素个数少的时候，会使用ziplist；</p><p>当元素个数较多，或者单个元素的体积较大（字符串长），使用skiplist来存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-max-ziplist-entries 元素少于这个数量的时候使用ziplist</span><br><span class="line">zset-max-ziplist-value   元素长度大于这个数字的时候使用skiplist</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; object encoding zset1</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd zset1 20 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zset1</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure><h2 id="5-3-使用场景"><a href="#5-3-使用场景" class="headerlink" title="5.3 使用场景"></a>5.3 使用场景</h2><p>zset比较适合建立排行榜。诸如微博热搜、B站热搜、游戏排行榜这些，都是一个“排行榜”的应用场景。</p><p>游戏玩家的排位会有一个分数，排行榜按这个分数来降序排列的，并展示给用户。且可以使用zrange来进行分页查看。</p><p>微博热搜也可以应用zset，每个话题肯定会有一个热搜的指数，<strong>如果简单来处理</strong>，那么就是用户搜索一次这个话题，它在zset中的分数就加一（zincrby命令），这样被搜索的次数越多的话题，在热搜榜中就越靠前。</p><p>当然，微博实际上用的是一个综合的数值，而不是只看搜索量这个单一指标。这时候可以用zinterstore&#x2F;zunionstore中的weight来实现多个维度数值的计算。比如浏览量、点赞率、转发量、评论量这些数据，在最终结果集合的时候都给他们赋予一个权值再进行计算，最终得到一个热榜的指数。</p><h1 id="6-Steams"><a href="#6-Steams" class="headerlink" title="6.Steams"></a>6.Steams</h1><p>steams数据类型类似一个<code>append-only log</code>，可以让我们把一个事件投放给多个目标。你可以理解为它就是一个队列，比list更加适合作为消息中间件。</p><p>在Redis官网上提到了steams类型的几个应用场景</p><ul><li>事件来源监看</li><li>事件通知</li><li>消息监看（消费者进行阻塞等待）</li></ul><p>所谓事件，就是某个东西满足了某种状态的场景。比如linux多路转接中epoll&#x2F;select就是通过事件来通知进程来处理io请求的，我们在进程中调用接口进行等待的时候，就相当于是在执行“消息监看”这一步骤。</p><h1 id="7-Geospatial"><a href="#7-Geospatial" class="headerlink" title="7.Geospatial"></a>7.Geospatial</h1><p>这个类型就是用来存储坐标（经纬度）的，代表一个地理位置。它存储点了之后，可以进行地理半径进行查找，在导航软件中就很有用。</p><p>基本命令是添加和查询：</p><ul><li>GEOADD将位置添加到给定的地理空间索引（请注意，使用此命令，经度先于纬度）。</li><li>GEOSEARCH返回具有给定半径或<strong>地理边界框</strong>的位置。</li></ul><p>平时肯定用不上这个类型，只有接触了具体的业务才需要了解</p><h1 id="8-HyperLogLog"><a href="#8-HyperLogLog" class="headerlink" title="8.HyperLogLog"></a>8.HyperLogLog</h1><p>这个数据类型的应用场景主要是用于计算（估算）集合中的元素个数。</p><p>比如用set来存放站点的UV的时候，假设set中存放用户id（8字节）一个1亿UV的站点大约会占用800MB的内存。看上去好像不多？毕竟一亿UV的网站哪里有那么多啊？</p><p>但HyperLogLog可以使用最多12KB的空间就实现上述的效果！</p><blockquote><p>The Redis HyperLogLog implementation uses up to 12 KB and provides a standard error of 0.81%.</p></blockquote><p>set占用那么多内存是因为它完整存储了用户的id，但HyperLogLog并不存放元素内容，但可以记录“元素的特征”，新增元素的时候可以判断当前元素是新增的元素还是已经存在的元素。这时候就可以用HyperLogLog来进行<strong>计数</strong>，但不能用于真正存放元素。</p><p>这里的底层肯定很复杂，且HyperLogLog并不能保证百分百精确。官方文档上也提到了，HyperLogLog大概会有<code>0.81%</code>的误差。</p><p>注意：HyperLogLog是一个算法思想，并非Redis专有的。其他工具中也可能提供这个数据结构来实现此类需求。</p><h1 id="9-Bitmaps"><a href="#9-Bitmaps" class="headerlink" title="9.Bitmaps"></a>9.Bitmaps</h1><p>bitmaps是位图结构，本质上还是一个集合，它使用某个比特位来存放某些特定的数据，以此来节省空间。</p><p>比如存放数字10，我们不是直接存放整形，而是将位图中的从右往左数第10位从0改成1，这样就代表10已经存放了。</p><p>和HyperLogLog不存放元素相比，bitmaps虽然是用比特来表示是否存在某个元素，但<strong>实际上它是存放了这个元素的</strong>，因为我们可以通过位图中的数据还原出某个元素是否存在！比如第3个比特位是1，那么集合中就有3。</p><ul><li>不需要知道元素内容，可以使用HyperLogLog；</li><li>想节省空间的同时需要记录整形元素，使用bitmaps</li></ul><h1 id="10-Bitfields"><a href="#10-Bitfields" class="headerlink" title="10.Bitfields"></a>10.Bitfields</h1><p>位域Bitfields，在C语言中<strong>位段</strong>其实就是位域；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestBit</span> &#123;</span></span><br><span class="line"><span class="type">int</span> a:<span class="number">8</span>; <span class="comment">// 数字表示某个变量占用几个比特位</span></span><br><span class="line"><span class="type">int</span> b:<span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> c:<span class="number">8</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Redis中的bitfield和C语言中的位域相似，可以理解位一串二进制序列，并给某个位设置特定的哈衣，并进行读取&#x2F;修改&#x2F;算术运算等相关操作。</p><p>相比于string类型，它的核心目标还是节省空间。比如一把moba游戏中玩家的金币、KDA、补刀等信息，并不需要用大量空间来存储，使用位域可以节省空间。在Redis官网上也有相关的示例命令</p><p><a href="https://redis.io/docs/data-types/bitfields/">https://redis.io/docs/data-types/bitfields/</a></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>Redis中最主要使用的数据类型和命令就是这些了，后续相关知识点会继续补充。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">Redis的常用变量类型以及数据类型相关命令的介绍</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.musnow.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】03.基本命令学习</title>
    <link href="https://blog.musnow.top/posts/3677820204/"/>
    <id>https://blog.musnow.top/posts/3677820204/</id>
    <published>2024-02-10T08:33:30.000Z</published>
    <updated>2024-02-20T02:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习Redis的命令可以参考官网文档：<a href="https://redis.io/commands">Commands | Redis</a>。我还发现官网的examples里面是可以敲Redis命令的，如果你没有配置Redis环境，应该可以白嫖这里的Redis做个临时的练习。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/ada4c2c766f7d1faabd2a1a7a5a32287.png" alt="image.png"></p><p>本文使用Redis版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-server --version</span><br><span class="line">Redis server v=6.0.16 sha=00000000:0 malloc=jemalloc-5.2.1 bits=64 build=a3fdef44459b3ad6</span><br><span class="line">❯ sudo redis-cli --version</span><br><span class="line">redis-cli 6.0.16</span><br></pre></td></tr></table></figure><p>注意，本文并非Redis命令大全，只是对最常用的命令做的记录。</p><h1 id="1-set和get"><a href="#1-set和get" class="headerlink" title="1.set和get"></a>1.set和get</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在Redis中，最常用的就是这两个命令。顾名思义，set是用来设置key值的，get是用来获取某个key值的。</p><p>注意set&#x2F;get命令<strong>只能用于设置字符串string变量</strong>，其他类型有对应的设置命令，用get获取一个非string的key会失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br></pre></td></tr></table></figure><p>在redis中不区分命令的大小写（但是区分key和value的大小写），字符串也不需要加引号（如果有<strong>空格</strong>就需要加），set成功会返回<code>OK</code>，失败会返回<code>nil</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 value1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set key2 value2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get KEY2</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; set k &quot;100 01&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">100 01</span><br></pre></td></tr></table></figure><p>最后的key3是一个不存在的键值，Redis返回了<code>(nil)</code>，意思和NULL其实一样，就是没有值。同时大写的KEY2也没有值，因为Redis中的key需要区分大小写。</p><p>如果尝试set一个已经存在的key，会自动覆盖旧数据。覆盖的时候可能会修改key对应value的数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key1 value11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;value11&quot;</span><br></pre></td></tr></table></figure><p>如果你需要设置的字符串中有引号，可以用<code>\</code>进行转义，但还必须在外部再套一个引号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k &quot;10&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">10</span><br><span class="line">127.0.0.1:6379&gt; set k \&quot;10\&quot;</span><br><span class="line">Invalid argument(s)</span><br><span class="line">127.0.0.1:6379&gt; set k &quot;\&quot;10\&quot;&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; object encoding k</span><br><span class="line">embstr</span><br></pre></td></tr></table></figure><h2 id="进阶选项"><a href="#进阶选项" class="headerlink" title="进阶选项"></a>进阶选项</h2><p>set命令还有一些额外的选项可供选择，具体参考官网文档 <a href="https://redis.io/commands/set/">SET | Redis</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET key value [NX | XX] [GET] [EX seconds | PX milliseconds |</span><br><span class="line">  EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]</span><br></pre></td></tr></table></figure><p>在Redis官网上，<code>[]</code>代表可选命令参数，<code>|</code>可以理解为“或”，代表每个可选命令参数中的不同设置值；每个<code>[]</code>之间是独立的，可以同时存在。如下是对set命令选项的说明：</p><ul><li>NX：只有key不存在的时候才能set成功;</li><li>XX：只有key存在的时候才能set成功;</li><li>GET：如果key已存在，返回旧值；如果key不存在返回nil（空）；如果key存在但是value不是string，则本次set操作会返回错误并终止；</li><li>EX&#x2F;PX：set的时候指定当前key的过期时间，过期时间到了会自动被删除，EX的单位是秒，PX的单位是毫秒（类似<code>sleep_for</code>）；</li><li>EXAT&#x2F;PXAT：指定过期时间戳，即当前时间到<strong>指定时间戳</strong>后key值过期。EXAT是秒级时间戳，PXAT是毫秒级时间戳（类似<code>sleep_until</code>）；</li><li>KEEPTTL：如果key值已存在且有过期时间，使用KEEPTTL更新当前key的时候会重置过期时间计数器。举例：A的过期时间是100秒，我在A设置后60秒又更新了A，此时新的A的过期计时器会继承原有时间，即为40秒后过期。如果不指定KEEPTTL选项，则会被重置为Redis的默认TTL（如果没有配置，默认是永不过期）。</li></ul><p>注意，一些选项是高版本中才被支持的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Starting with Redis version 2.6.12: Added the EX, PX, NX and XX options.</span><br><span class="line">Starting with Redis version 6.0.0: Added the KEEPTTL option.</span><br><span class="line">Starting with Redis version 6.2.0: Added the GET, EXAT and PXAT option.</span><br><span class="line">Starting with Redis version 7.0.0: Allowed the NX and GET options to be used together.</span><br></pre></td></tr></table></figure><h3 id="NX和XX"><a href="#NX和XX" class="headerlink" title="NX和XX"></a>NX和XX</h3><p>NX是key值不存在才能正常被设置，XX是key值存在才能被正常设置。如果没有被set成功，则会返回<code>nil</code>，set成功返回的是OK。</p><p>如下所示，a键值不存在时，nx设置a成功返回OK。再次用nx尝试设置，因为此时a已经存在，不符合nx的策略，设置失败，返回<code>nil</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a test1 nx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set a test1 nx</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>使用xx测试，因为a存在，所以设置成功。而b不存在，设置失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a test2 xx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set b test1 xx</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="KEEPTTL"><a href="#KEEPTTL" class="headerlink" title="KEEPTTL"></a>KEEPTTL</h3><p>对KEEPTTL来做个测试，为了更好的展示效果，把一个始终摆在终端旁边。</p><p>我在19秒的时候执行了命令<code>set a test ex 20</code>，即键值a会在20秒后过期。如同预期，在39秒左右，a的键值无法被get了（截图落后了一些）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/00c937e7e04b4440fea45f4dd7a2a638.png" alt="image.png"></p><p>尝试在这20秒中重新给a设置一个新的值，同时不携带KEEPTTL选项。会发现重新设置后的key没有继承原有的过期时间，而是<strong>不过期</strong>了（Redis的默认策略就是永不过期）</p><p>如果携带了KEEPTTL选项，则a还是会在20秒后过期。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/eb367ae0e3b2730146a4ef800c92274a.png" alt="image.png"></p><p>使用TTL命令可以看的更直观一点（关于TTL命令的介绍参考后文），当我们使用KEEPTTL设置了a后，它的过期时间还是继承了原本的10秒，随后被过期删除，TTL显示<code>-2</code>代表键值不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a t1 ex 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; set a t2 keepttl</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) -2</span><br></pre></td></tr></table></figure><p>如果不使用KEEPTTL选项，则过期时间会变成<code>-1</code>代表永不过期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a t1 ex 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;t1&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; set a t2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;t2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><h2 id="mset和mget"><a href="#mset和mget" class="headerlink" title="mset和mget"></a>mset和mget</h2><p>这两个命令是set&#x2F;get的变体，可以用于同时设置&#x2F;获取多个键值的数据。这两个命令的时间复杂度都是<code>O(N)</code>，其中N是命令后跟随的key的个数。</p><p>mset只能单纯的设置key和value，没有set的额外的参数选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MSET key value [key value ...]</span><br><span class="line">MGET key [key ...]</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset key1 t1 key2 t2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2</span><br><span class="line">t1</span><br><span class="line">t2</span><br></pre></td></tr></table></figure><p>为什么要提供一个这样的命令呢？还是关于网络请求方面的性能节省。如果我知道我需要一次性设置&#x2F;获取大量键值，那可以一条命令写完的绝对好过多次请求Redis服务器，节省了多次通信的网络延迟。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/a31a19e2b651a86213df25325e42d1d9.png" alt="image.png"></p><p>Redis会保证mset的执行是<strong>原子的</strong>，不会出现mset中的多个键值只观察到其中一个被修改的情况。官网原话：MSET is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</p><blockquote><p>比如我mset了key1和key2，客户端可以观察到key1和key2都被修改，不会观察到只有key1或只有key2被修改了的情况。</p></blockquote><p>这也是得益于Redis采用的单线程模型，它必须处理完毕mset的所有key后才会去响应其他命令请求，那客户端自然就不可能中断设置多个key的过程，也观察不到只有一部分key被修改了的情况。</p><p>但这也警示我们：如果尝试用mset设置特别大量的key，可能会阻塞Redis服务器导致其无法响应其他请求。</p><h1 id="2-keys"><a href="#2-keys" class="headerlink" title="2.keys"></a>2.keys</h1><p>keys命令用于查询当前Redis中的key值有哪些，如果匹配不上则返回<code>empty array</code>。</p><p>命令格式如下，<a href="https://redis.io/commands/keys/">KEYS | Redis</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys [pattern]</span><br></pre></td></tr></table></figure><p>其中参数pattern是一个字符串，类似于正则表达式，用来匹配Redis中已有的key的名称。</p><p>举个最简单的例子，<code>key*</code>代表匹配以key开头的所有键值，可以看到当前我的Redis有上文set的两个key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys key*</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br></pre></td></tr></table></figure><p>pattern支持的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">h?llo     matches hello, hallo and hxllo</span><br><span class="line">问号只匹配一个字符</span><br><span class="line"></span><br><span class="line">h*llo     matches hllo and heeeello</span><br><span class="line">星号代表匹配0个或者无数个字符</span><br><span class="line"></span><br><span class="line">h[ae]llo  matches hello and hallo, but not hillo</span><br><span class="line">匹配a或者e这两个字符</span><br><span class="line"></span><br><span class="line">h[^e]llo  matches hallo, hbllo, ... but not hello</span><br><span class="line">匹配除了e以外的其他单个字符</span><br><span class="line"></span><br><span class="line">h[a-b]llo matches hallo and hbllo</span><br><span class="line">匹配a到b这个区间中的单个字符</span><br></pre></td></tr></table></figure><p>如果你需要匹配的字符串中包含 <code>[</code>、<code>]</code>、<code>*</code>、<code>?</code> 这些特殊字符，可以用<code>\</code>来转义它们。</p><p>注意：keys的时间复杂度是<code>O(N)</code>（其采用遍历方式来获取结果），所以在生产环境的大数据库中一般都禁止使用keys命令，特别是<code>keys *</code>全部查询。因为Redis是单线程模型，如果用keys的查询把Redis给弄阻塞了，就没有办法提供服务给其他链接了。</p><p>在Redis+MySQL的框架中，如果使用keys命令导致Redis阻塞了，请求就会直接回源到MySQL上，导致MySQL服务器遭受了意料之外的大批量请求，它也容易挂掉。如果Redis和MySQL都挂了，业务就完蛋了🤣。 </p><h1 id="3-exists"><a href="#3-exists" class="headerlink" title="3.exists"></a>3.exists</h1><h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><p>判断某个key是否存在，返回值是一个数字：返回命令中给出的key中，实际存在的key的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key [key1 key2 ...]</span><br></pre></td></tr></table></figure><p>举个例子，比如我使用如下命令。那么返回值就是这三个key中有几个key是存在的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key1 key2 key3</span><br></pre></td></tr></table></figure><p>exists命令<strong>检查一个key</strong>的时间复杂度是<code>O(1)</code>，因为Redis底层是用哈希表来管理key的。</p><blockquote><p>Time complexity: O(N) where N is the number of keys to check.</p></blockquote><p>Redis的官方文档说exists命令的时间复杂度是<code>O(N)</code>，不要误解，这里的N是命令中给出key的个数。相当于我们需要检查N个key，每个key都是<code>O(1)</code>，最终的时间复杂度就是<code>O(N)</code>了。</p><blockquote><p>在实际使用时，如果需要查询多个key是否存在，一条命令写完肯定比多次查询更好。因为每一次查询都涉及到了<strong>一次网络请求和响应</strong>，一条命令把需要查询的多个key都告诉Redis，得到一个返回结果是更好的选择。这就和MySQL中的请求一样，一条SQL能解决的事情分成两个SQL就会因为网络通信而增加延迟！</p><p>Redis中的大部分命令都支持一次性给定多个key，就是为了减少网络通信带来的影响。</p></blockquote><p>当然，exists命令的返回结果并没有办法让我们知道给出的key中到底是哪一个不存在，这是要看具体业务来确定的。</p><h2 id="命令测试"><a href="#命令测试" class="headerlink" title="命令测试"></a>命令测试</h2><p>实际测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists key1 key2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; exists key1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>注意，exists在检查某个key是否存在的时候并不会进行去重操作，如果你尝试检查两个相同的key，返回结果也是2；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists key1 key1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h1 id="4-del"><a href="#4-del" class="headerlink" title="4.del"></a>4.del</h1><p>用于删除指定key，返回值是一个数字，给定key中被成功删除的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key [key1 key2 ...]</span><br></pre></td></tr></table></figure><p>删除单个key的时间复杂度是<code>O(1)</code>，多个是<code>O(N)</code>；</p><h1 id="5-expire-x2F-pexpire"><a href="#5-expire-x2F-pexpire" class="headerlink" title="5.expire&#x2F;pexpire"></a>5.expire&#x2F;pexpire</h1><p>用于给某个key设置过期时间（时间到了之后自动被删除）其中expire的单位是秒，pexpire的单位是毫秒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire key second</span><br><span class="line">pexpire key millisecond</span><br></pre></td></tr></table></figure><p>这个功能非常有用，在很多平台上我们都使用过验证码，为了保证一定的安全性，验证码都被设计为有过期时间的。这样系统生成一个验证码后，可以将其set进入Redis，然后使用expire命令给验证码设置过期时间（其实set命令里面就有选项可以设置过期时间了，这里只是举个例子）。还有限时优惠券、限时VIP体验券等等……</p><p>如果不使用Redis的expire功能，就需要在应用层甚至数据库中设计过期操作，相对来说就有些麻烦了。</p><p>还有另外一个场景，是基于Redis实现分布式锁：即在分布式集群中实现锁，以实现同步&#x2F;互斥功能。</p><ul><li>加锁：设置一个特殊的key，并设置过期时间；</li><li>解锁：删除该key；</li><li>判断是否有人占用：exists判断key存在则代表有人已经申请了锁，需要等待到key不存在的时候，则代表锁已经被释放。</li><li>可以在set的时候使用NX选项，保证只有key值不存在的时候才能设置上key（即只有锁没有被获取的时候才能加锁）；</li><li>因为Redis是单线程模型，所以set以及exists的操作是原子性的，不会出现并发访问的问题。</li></ul><p>此时为了<strong>避免申请锁的应用服务器无法正常解锁</strong>（比如申请了锁的服务器突然挂掉了），都会给锁上一个过期时间，避免整个系统陷入死锁状态。这个过期时间应该略大于当前服务器需要访问临界资源的时间（避免还没有访问完毕就因为超时自动解锁了）。</p><h1 id="6-ttl-x2F-pttl"><a href="#6-ttl-x2F-pttl" class="headerlink" title="6.ttl&#x2F;pttl"></a>6.ttl&#x2F;pttl</h1><p>这两个命令和expire&#x2F;pexpire对应，用于命令显示某个键值的过期时间还剩下多少，ttl返回的单位是秒，pttl返回的单位是毫秒。该命令查询的时间复杂度是<code>O(1)</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure><p>这两个命令都有两个特殊的返回值</p><ul><li><code>-1</code> 代表当前键值永不过期；</li><li><code>-2</code> 代表当前键值不存在；</li></ul><blockquote><p>Starting with Redis version 2.8.0: Added the -2 reply.</p></blockquote><h2 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h2><p>Redis是怎么知道一个key是否过期需要被删除呢？</p><p>直接遍历肯定不行，当库很大的时候，遍历一次的时间都够喝一壶了，完全达不到过期时间的要求。</p><p>Redis采用了定时删除+惰性删除策略的结合：</p><ul><li>定时删除：Redis定时（默认100ms检查一次）<strong>抽取一部分</strong>key检查TTL过期时间，并将过期的key删除。因为只抽取一部分，所以检查的耗时短；</li><li>惰性删除：用户请求某个key的时候检查TTL过期时间，过期的key被删除，不会返回给用户；</li></ul><p>这两个操作虽然维持了性能，但并不能保证过期键一定能被清理掉。如果某个键值很久没有被使用，且没有被Redis的定期删除策略抽取到，它就会留存在那里。要想保证Redis中不存在过期键，还需使用一些辅助策略来处理。</p><h2 id="定时器方案有哪些？"><a href="#定时器方案有哪些？" class="headerlink" title="定时器方案有哪些？"></a>定时器方案有哪些？</h2><blockquote><p>这里记录的是实现一个定时器可以采取的方式，和Redis采用的策略无关。</p></blockquote><h3 id="新建线程来定时删除"><a href="#新建线程来定时删除" class="headerlink" title="新建线程来定时删除"></a>新建线程来定时删除</h3><p><strong>方式1</strong>：使用线程来实现定时器。当需要定时删除的时候，启动一个线程，休眠指定时间，休眠结束后执行删除操作。但这会大大增加线程数量和系统负载，效率低。</p><h3 id="基于过期时间的优先级队列"><a href="#基于过期时间的优先级队列" class="headerlink" title="基于过期时间的优先级队列"></a>基于过期时间的优先级队列</h3><p><strong>方式2</strong>：使用优先级队列（以TTL剩余时间为key值，小的在前面），有设置过期时间的键值就被插入该队列，队首元素就是最快过期的键值。配置了优先级队列后，只需要一个线程去轮询检查队首来处理过期键值就行了。但是频繁的扫描会大大增加CPU负担。</p><p><strong>方式3</strong>：在方式2的基础上，添加休眠机制，让线程根据队首键值的过期时间进行休眠。休眠结束后删除队首元素。如果有新的键值插入，则唤醒该线程，重新根据队首键值的过期时间设置休眠时间。这可以通过条件变量的<code>wait_for</code>接口加上<code>notify</code>接口来实现。</p><h3 id="时间轮方案"><a href="#时间轮方案" class="headerlink" title="时间轮方案"></a>时间轮方案</h3><p><strong>方式4</strong>：使用时间轮方案，<strong>如下表所示</strong>。左侧代表一个基于现在的时间偏移量，每一个格子对应的100ms时间偏移，右侧是一个链表。从数据结构来看可以是一个顺序表+链表。</p><p>我们只需要将ttl根据范围插入对应的时间偏移量需要删除的key中，线程每次休眠100ms，休眠结束后就从链表里面取走过期的键值进行删除。</p><table><thead><tr><th>时间偏移量</th><th>需要删除的key（链表）</th></tr></thead><tbody><tr><td>100ms</td><td>ttl在<code>[0,100]</code>之间的</td></tr><tr><td>200ms</td><td>ttl在<code>[101,200]</code>之间的</td></tr><tr><td>300ms</td><td>…</td></tr></tbody></table><p>举个例子，现在是0秒，<strong>过期处理线程甲</strong>开始休眠100ms。此时来了几个有过期策略的key，分别是50ms过期key1、150ms过期key2、190ms过期key3、210秒过期key4。那么我们就可以获得下面这张顺序表+链表。</p><table><thead><tr><th>时间偏移量</th><th>需要删除的key（链表）</th></tr></thead><tbody><tr><td>100ms</td><td>key1</td></tr><tr><td>200ms</td><td>key2,key3</td></tr><tr><td>300ms</td><td>key4</td></tr></tbody></table><p>线程甲休眠100ms后，key1的过期时间就已经到了（此时早已过去了50ms）线程甲可以将其删除，然后再休眠100ms后处理key2和key3，再休眠100ms处理key4。</p><p>当然，当key1被删除后（第一个100ms已经休眠过了），表会出现下面的偏移。新来的键值都需要根据距离当前时间的偏移量插入到对应的位置。</p><table><thead><tr><th>时间偏移量</th><th>需要删除的key（链表）</th></tr></thead><tbody><tr><td>100ms</td><td>key2,key3</td></tr><tr><td>200ms</td><td>key4</td></tr></tbody></table><p>实际场景下，我们不可能让这个表格的长度一直增长下去，否则来个30000ms(30s)才过期的key，<strong>就需要300个表格（左侧顺序表）的空间才能存下这个需要30s才过期的键值</strong>，而这之中可能有很多表格项是空的（没有对应的过期键值），存在空间浪费。</p><p>为了节省这部分空间，要采用类似哈希映射的思想，比如1050ms过期的key也会被插入到时间偏移量为100ms的链表中，当线程休眠结束后需要检查链表中的值的过期时间是否真的到了，到了才执行删除操作。</p><p>另外，我们也需要根据具体休眠时间间隔来确定每次应该休眠多久。假设我们的key都是5ms到20ms就过期了，此时设置休眠间隔为100ms就不太合理了。</p><h1 id="7-type"><a href="#7-type" class="headerlink" title="7.type"></a>7.type</h1><p>该命令返回key对应value的类型，时间复杂度为<code>O(1)</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><p>返回值可以是 string, list, set, zset, hash and stream. 如果key不存在则返回none（注意返回的不是nil）。</p><p>在Redis官网文档中可以看到每个数据类型对应的数据结构：<a href="https://redis.io/docs/data-types/#core">Understand Redis data types | Redis</a>，其中当redis作为<strong>消息队列</strong>时类型为stream。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; type key1</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; type mylist</span><br><span class="line">list</span><br></pre></td></tr></table></figure><h1 id="8-object-encoding-变量编码类型"><a href="#8-object-encoding-变量编码类型" class="headerlink" title="8.object encoding 变量编码类型"></a>8.object encoding 变量编码类型</h1><p>Redis提供了多种数据类型：<a href="https://redis.io/docs/data-types/">Understand Redis data types | Redis</a></p><p>这些类型和我们常见的编程语言中的数据类型基本类似，<strong>但底层实现就不一样了</strong>。</p><p>Redis保证提供的数据类型符合这个数据类型应该有的预期，比如hash类型的插入和查询的效率应该是<code>O(1)</code>，但底层并不一定严格使用哈希表来实现。</p><p>Redis会根据实际场景动态选择更加合适的底层数据结构实现，<strong>来一定程度的提高效率</strong>。一个纯整数数字的string，直接用数字类型来存放会比使用字符串来存放占用更少的存储空间（1字节可以存放无符号数0到255，但255用字符串来存放需要3个字节）。</p><table><thead><tr><th>数据结构</th><th>内部编码</th></tr></thead><tbody><tr><td>string</td><td>raw(原始字符串)&#x2F;int&#x2F;embstr(为短字符串优化)</td></tr><tr><td>hash</td><td>hashtable(哈希表)&#x2F;ziplist(压缩列表,节省空间)</td></tr><tr><td>list</td><td>linkedlist(链表)&#x2F;ziplist&#x2F;quicklist</td></tr><tr><td>set</td><td>hashtable&#x2F;intset(整形集合)</td></tr><tr><td>zset</td><td>skiplist(跳表)&#x2F;ziplist</td></tr></tbody></table><p>ziplist是用来存放小列表的编码方式，使用它相比直接使用链表或哈希表能节省空间占用。当Redis中有很多个很小的list和hash的时候，ziplist就能辅助节省很可观的内存空间了。具体可以参考：<a href="https://blog.csdn.net/qq_31387317/article/details/94578370">Redis ziplist(压缩列表) CSDN博客</a></p><p>在Redis中可以使用object encoding命令来查看一个键值底层实际的编码方式是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object encoding key</span><br></pre></td></tr></table></figure><p>可以看到，比较短的字符串是embstr，list类型是quicketlist，全数字的字符串是int（包括负整数也是用int存放的）；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; object encoding mylist</span><br><span class="line">&quot;quicklist&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key3 12345</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key3</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; get a </span><br><span class="line">-1</span><br><span class="line">127.0.0.1:6379&gt; object encoding a</span><br><span class="line">int</span><br></pre></td></tr></table></figure><p>Redis会在键值中数据增加到一定量级后自动切换编码方式，对于用户来说是无感知的，所以我们只需要知道这个思想就行了。</p><h1 id="9-flushall-删库跑路"><a href="#9-flushall-删库跑路" class="headerlink" title="9.flushall 删库跑路"></a>9.flushall 删库跑路</h1><p>MySQL可以删库跑路，Redis自然也可以。这个命令的作用是清除Redis中的<strong>所有键值</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushall</span><br></pre></td></tr></table></figure><p>如果采用Redis作为缓存，清空了问题相对来说还没那么大，但如果是作为数据库，那就祝你好运吧……</p><p>请不要在生产环境使用这个命令哦！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>以上便是Redis的全局命令了（最常用的命令），关于其他数据类型的命令会单独起文讲解。</p>]]></content>
    
    
    <summary type="html">Redis基本命令学习</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.musnow.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】02.Ubuntu22.04安装Redis</title>
    <link href="https://blog.musnow.top/posts/269089114/"/>
    <id>https://blog.musnow.top/posts/269089114/</id>
    <published>2024-02-10T06:54:05.000Z</published>
    <updated>2024-02-19T04:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y redis</span><br></pre></td></tr></table></figure><p>安装了之后使用如下方式启动redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start redis</span><br></pre></td></tr></table></figure><p>看一下6379端口号是否有进程在监听，有代表启动成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root:/etc/redis]# systemctl status redis</span><br><span class="line">● redis-server.service - Advanced key-value store</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/redis-server.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Sat 2024-02-10 14:45:11 CST; 4min 56s ago</span><br><span class="line">       Docs: http://redis.io/documentation,</span><br><span class="line">             man:redis-server(1)</span><br><span class="line">   Main PID: 1350 (redis-server)</span><br><span class="line">     Status: &quot;Ready to accept connections&quot;</span><br><span class="line">      Tasks: 5 (limit: 9527)</span><br><span class="line">     Memory: 7.5M</span><br><span class="line">     CGroup: /system.slice/redis-server.service</span><br><span class="line">             └─1350 &quot;/usr/bin/redis-server 127.0.0.1:6379&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &gt;</span><br><span class="line"></span><br><span class="line">Feb 10 14:45:11 wsl-ubuntu systemd[1]: Starting Advanced key-value store...</span><br><span class="line">Feb 10 14:45:11 wsl-ubuntu systemd[1]: Started Advanced key-value store.</span><br><span class="line">[root:/etc/redis]# netstat -nltp | grep 6379</span><br><span class="line">tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      1350/redis-server 1</span><br><span class="line">tcp6       0      0 ::1:6379                :::*                    LISTEN      1350/redis-server 1</span><br></pre></td></tr></table></figure><p>注意，如果你尝试在子用户里用如下命令查看redis是否绑定成功端口，可能查询不到结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nltp | grep redis</span><br></pre></td></tr></table></figure><p>因为在子用户中，我们看不到当前占用6379端口的进程名字。只有root用户能看到。</p><h1 id="允许远程访问"><a href="#允许远程访问" class="headerlink" title="允许远程访问"></a>允许远程访问</h1><p>默认情况下redis绑定的ip是127.0.0.1，这个ip地址只允许本机访问，即你只能在这台linux主机上访问这个redis。</p><p>如果想实现远程访问，我们需要将绑定的ip改成0.0.0.0，并且关闭远程访问的保护</p><p>使用如下命令切换到root用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su - </span><br></pre></td></tr></table></figure><p>进入redis的配置文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/redis</span><br></pre></td></tr></table></figure><p>这里有一个<code>redis.conf</code>配置文件，我们需要修改的是下面的条目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 ::1</span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure><p>将它们修改为如下所示，即启用了redis允许远程访问的模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0 ::1</span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><p>修改完毕配置文件后，重启服务器即可生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart redis</span><br></pre></td></tr></table></figure><h1 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis"></a>连接redis</h1><p>和MySQL一样，Redis也是客户-服务端架构的软件。在Linux中，使用<code>redis-cli</code>命令即可直接连到当前主机的redis服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root:/etc/redis]# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>如果需要链接非本机的redis服务器，使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h IP地址 -p 端口</span><br></pre></td></tr></table></figure><p>如果想让redis-cli中可以正常显示中文，可以添加<code>--raw</code>选项。注意：使用该选项会导致Redis中显示的<code>(nil)</code>变成空字符串，极易产生误导！如果不是硬性需要在控制台中显示中文，请不要使用该选项！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --raw</span><br></pre></td></tr></table></figure><p>当然，我们也可以像MySQL一样使用C语言的开发包来链接redis，那是后话了。</p><h1 id="命令学习"><a href="#命令学习" class="headerlink" title="命令学习"></a>命令学习</h1><p>redis的命令学习可以参考官网 <a href="https://redis.io/commands/">Commands | Redis</a></p><p>虽然是英文文档，但是照着翻译读读差不多都能看明白是怎么用的。</p>]]></content>
    
    
    <summary type="html">ubuntu22.04下安装redis</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【vscode】远程主机可能不符合glibc和libstdc++ vscode服务器的先决条件</title>
    <link href="https://blog.musnow.top/posts/1712214675/"/>
    <id>https://blog.musnow.top/posts/1712214675/</id>
    <published>2024-02-09T01:54:24.000Z</published>
    <updated>2024-02-09T02:37:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如图，VSCODE 1.86版本突然不支持我的centos7.6服务器了，这可咋办?</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/803920d76095f770c24324cfed769f89.png" alt="image.png"></p><p>百度了一下，官网上说是centos7缺少依赖项，已经无法被支持。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/c28bde6edd23e6a5285d42485f810f1a.png" alt="image.png"></p><h1 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h1><p>不过并不是没有办法解决，回退到1.85版本就行了。</p><blockquote><p>参考：<a href="https://blog.csdn.net/Xuuuuuuuuuuu/article/details/135991844">vscode的ssh忽然连不上服务器：远程主机可能不符合glibc和libstdc++ VS Code服务器的先决条件-CSDN博客</a></p></blockquote><h2 id="关闭自动更新"><a href="#关闭自动更新" class="headerlink" title="关闭自动更新"></a>关闭自动更新</h2><p>回退之前，你先要把vscode的自动更新关掉，不然你安装了1.85后不用过10秒就会自动更新……</p><p>在vscode的设置里面搜索更新，点击左侧的<code>应用程序-更新</code>，找到更新模式，设置为None即取消自动更新，然后再去掉后台下载新版本的勾。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/1169a49b1d503846a31bdedcbc6c02a9.png" alt="image.png"></p><p>然后去微软官网下载1.85旧版本，位置是vscode官网的update模块，在更新日志<code>November 2023 (version 1.85)</code>里面能找到旧版本。</p><p><a href="https://code.visualstudio.com/updates/v1_85">Visual Studio Code November 2023</a></p><p>windows主机点击这个x64下载就行了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/9e57878ba739716326425a3c87c80999.png" alt="image.png"></p><h2 id="回退插件版本"><a href="#回退插件版本" class="headerlink" title="回退插件版本"></a>回退插件版本</h2><p>安装1.85后remote-ssh和wsl插件都会显示不可用，会是灰色状态带一个红色感叹号。</p><p>点击插件旁边的齿轮，选择安装另外一个版本，安装4个月前的版本就行了。</p><ul><li>wsl插件：0.81.8</li><li>remote-ssh插件：0.107.0</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4f8240bb5ab45cddbfecca7473b5a10e.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/114aa6786aa0fe8fac26cd5ec48e92d4.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>安装完毕这两个旧版本插件后，就能连上centos7.6的服务器了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/2945ac9e10cbee3fcfd0a2e2f398c048.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">远程主机可能不符合glibc和libstdc++ vscode服务器的先决条件的解决办法</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="编程工具" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vscode" scheme="https://blog.musnow.top/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】01.初步认识Redis和分布式系统</title>
    <link href="https://blog.musnow.top/posts/996575798/"/>
    <id>https://blog.musnow.top/posts/996575798/</id>
    <published>2024-02-08T05:02:41.000Z</published>
    <updated>2024-02-14T11:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Redis"><a href="#1-什么是Redis" class="headerlink" title="1.什么是Redis"></a>1.什么是Redis</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/903cf874bef24f120d4a6f89d6f08868.png" alt="image.png"></p><p>Redis是一个开源的，基于键值对key-value的NoSQL数据库。Redis内部存放的值可以是string、hash、list、set、zset、bitmaps、GEO等多种数据结构或算法；除了数据存放，Redis还提供了键值过期、订阅发布、事务、流水线、Lua脚本等附加功能，因此Redis能满足很多应用场景。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/a26a91dc01fb2d631e4199609132f374.png" alt="image.png"></p><p>Redis会将数据存放在<strong>内存</strong>中，所以Redis的检索速率非常快（或者说IO吞吐高）。同时，为了保证数据不丢失，Redis会将内存中的数据用快照或者日志的方式存在硬盘上，实现一定程度上的数据持久化。</p><h2 id="1-2-什么时候用Redis？"><a href="#1-2-什么时候用Redis？" class="headerlink" title="1.2 什么时候用Redis？"></a>1.2 什么时候用Redis？</h2><p>在编程语言中定义变量，也是将数据存放在内存中。Redis的优势是在分布式集群系统中，而单机（单进程）程序里面，直接在编程语言中定义变量&#x2F;数据结构是更好的选择（Redis的快只是相对于MySQL这类数据库而言的）。</p><ul><li>如果未来需要引入分布式架构，使用Redis是一个好选择。否则没有必要。</li></ul><p>如果一个系统需要涉及到多个变量、多台主机时，Redis就能起作用了。它基于TCP，可以将自己内存中的变量分享给多个进程、多个主机来访问，这样分布式系统之间就能进行<strong>数据同步</strong>了。</p><p>又因为Redis是在内存中存放，所以它的检索速度相比MySQL会有更快的查询速度。在互联网应用中对数据库的查询性能要求较高，所以Redis就比MySQL更加适合这种场景。</p><blockquote><p>比如存储浏览器中的用户Cookie和Session的对应关系，这里还有一个特点，就是session并不是必须要永久保存的数据，我们能允许一定的数据丢失，后果无非是用户需要重新登录网页而已。</p></blockquote><p>当然，现在更多的选择是将Redis和MySQL等数据库结合，将热点数据（最常访问的数据）放入Redis，全量数据在MySQL中。此时Redis就好比一个数据的缓存了。</p><ul><li>保证热点数据的查询性能；</li><li>保证全量数据的正确保存；</li><li>但是会出现Redis和MySQL中增删改的数据同步问题；</li><li>使用Redis+MySQL会大大增加系统复杂性。</li></ul><h2 id="1-3-Redis不能做的事情？"><a href="#1-3-Redis不能做的事情？" class="headerlink" title="1.3 Redis不能做的事情？"></a>1.3 Redis不能做的事情？</h2><p>因为Redis是内存存储，所以它不适合存储大规模数据。</p><h1 id="2-分布式"><a href="#2-分布式" class="headerlink" title="2.分布式"></a>2.分布式</h1><p>前面提到，Redis的真正适用场景是分布式系统。那么什么是分布式系统呢？</p><h2 id="2-1-单机架构"><a href="#2-1-单机架构" class="headerlink" title="2.1 单机架构"></a>2.1 单机架构</h2><p>所谓单机架构，就是一个系统的所有服务都在一台服务器中运行。</p><p>如下图所示，假设这是一个简单的电商系统，它的数据库和应用程序都在同一台服务器上。用户访问这个服务器来获取电商服务。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4b3ddd75cab10fc351e38737b5c18ad7.png" alt="image.png"></p><p>之前我写的小项目<a href="https://blog.musnow.top/posts/4231483510">视频点播系统</a>，也是一个单机架构。采用MySQL作为数据库，C++来提供应用服务。</p><p>如果一台主机的性能能足够满足我们的用户服务需求了，单机架构就是很不错的选择，因为它的维护复杂度不高，且部署成本也较低。</p><h2 id="2-2-分布式"><a href="#2-2-分布式" class="headerlink" title="2.2 分布式"></a>2.2 分布式</h2><p>主机的性能指标包括IO性能（内存和硬盘）、网络吞吐、CPU计算性能等，这些性能都会在用户量增长到某一个量级时顶不住，导致服务的请求耗时较长甚至出现处理错误，用户体验差。</p><p>此时我们可以采取两个措施，开源节流：</p><ul><li>开源：给主机升级硬件</li><li>节流：通过软件debug找到影响系统性能的部分，针对性进行软件优化；</li></ul><p>但是，一台主机的性能，不管再怎么升级硬件，总归是有上限的。如果一个主机都被升级到顶天了还没有办法服务我们的性能，此时就需要<strong>多台主机</strong>来帮忙了。这便是分布式系统的基础。</p><ul><li>引入分布式其实是个万不得已的操作；</li><li>会导致系统复杂度大大提高；</li><li>系统出现BUG的可能性越来越高；</li><li>程序员被“开猿节流”的可能性越来越高……</li></ul><p>2023年年末，各大互联网厂家（阿里、滴滴）旗下的服务挨个boom，正是说明了这一点……</p><p>先来看看一个最简单的分布式系统吧，即将应用服务和数据库服务分离。</p><ul><li>应用服务器：CPU和内存性能，提高处理速度；</li><li>存储服务器：更大更快的硬盘，增加IO吞吐量；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/7420a71996b1c3c0a848e644d0419b13.png" alt="image.png"></p><h2 id="2-3-负载均衡"><a href="#2-3-负载均衡" class="headerlink" title="2.3 负载均衡"></a>2.3 负载均衡</h2><p>进一步扩展，就需要更多的主机，以及负载均衡措施了。</p><ul><li>一个负载均衡服务器和两个独立的应用服务器；</li><li>用户请求负载均衡服务器；</li><li>负载均衡服务器根据两个应用服务器当前的负载，选择较低的服务器来处理请求（这里涉及到负载均衡的算法）；</li></ul><p>此时两个应用服务器在一定程度上都干了相同的活，就能减少单个机器的压力。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/fef48f23eed772c5c53a99c5b89f26e2.png" alt="image.png"></p><p>注意，虽然负载均衡服务器看上去会接受所有用户的请求，但它的请求承担能力是远远大于应用服务器的。因为它的工作很简单，只是一个简单的识别和分配工作，并不涉及到具体的功能。</p><p>如果请求量大到负载均衡服务器也顶不住了，那可以添加多个负载均衡服务器（可以采用多地节点的方式）。</p><p>添加上负载均衡措施后，就有了服务集群，这个集群中某个服务器挂掉对整个服务器的影响不高（它的请求可以由其他正常运行的服务器承担）一定程度上提高了可用性。</p><p>另外，负载均衡服务器也需要使用一些算法，比如想办法让同一个用户的请求始终走到同一个应用服务器上，避免在不同应用服务器中进行数据交换。</p><h2 id="2-4-数据库读写分离"><a href="#2-4-数据库读写分离" class="headerlink" title="2.4 数据库读写分离"></a>2.4 数据库读写分离</h2><p>前面提到的措施都是在优化应用服务器的负载，那么数据库服务器的负载应该如何降低呢？</p><p>比较简单的一种办法就是数据库的<code>读写分离</code>。即读数据库的操作和写数据库的操作由不同的服务器来承担。</p><ul><li>应用程序需要写入，请求A服务器</li><li>A服务器处理写入后，定期同步到B服务器</li><li>应用程序需要读取时请求B服务器</li></ul><p>考虑到实际场景中，<strong>读取的频率会远远高于写入</strong>，在这种情况下，读取服务器B大部分情况下只需要处理读请求，压力会降低。而且我们可以提供多个和B一样的读服务器，加上负载均衡，进一步减少读服务器的压力。</p><p>为什么说读的频率远远高于写入？以聊天软件为例：</p><ul><li>当用户打开聊天软件的主界面时，软件需要对当前聊天框里的所有联系人&#x2F;群组里面的消息进行一次查询；</li><li>当用户打开自己的个人信息时，软件需要查询个人信息（当然这个信息可能是本地早就缓存好了的）；</li><li>当用户打开朋友圈的时候，需要查询好友的朋友圈，并把最新的说说推送给当前用户</li><li>……</li></ul><p>上述的这一系列操作都是读查询，完全没有涉及到写。当用户使用聊天软件，没有发出消息时，聊天软件一直在做的都是读操作！以此类推，大部分软件在使用的时候，都是读操作居多，写操作相对较少。</p><h2 id="2-5-热点缓存"><a href="#2-5-热点缓存" class="headerlink" title="2.5 热点缓存"></a>2.5 热点缓存</h2><p>有一个经典的二八原则，在数据库场景也能适用：20%的数据能支撑80%的访问。</p><p>所以我们可以引入针对这20%的热点数据的<strong>缓存</strong>，保证这些热点数据能更快的被查询（读）。Redis可以说就是用来做缓存的。</p><p>缓存需要更快的查询速度，代价就是它存放不了太多的数据。比如Redis需要将数据存入内存中，内存的容量远远小于磁盘，存不了很多数据。所以缓存一定要使用适合场景的算法，保证缓存中的数据有尽可能高的命中率。</p><p>当然，这样会导致缓存服务器会承受较大的查询压力。不过完整数据库的查询压力又被进一步减少了。</p><h2 id="2-6-分库分表"><a href="#2-6-分库分表" class="headerlink" title="2.6 分库分表"></a>2.6 分库分表</h2><p>当一个服务器存储不下当前系统的<strong>全量数据</strong>时，就需要进行分库分表了。即将数据库进行一定的拆分，存放在多个服务器中。</p><p>如下图所示，将原本一个数据库的不同表，放在不同服务器中。这样一个服务器上就只用存放一部分数据，减少了存储容量的同时，也减少了单个服务器在查询方面的压力。同时，我们可以为某个表建立一个存储的集群，这也是依照负载均衡的基本思路来扩展主从。</p><p>如果一个表过大，没有办法放入一台主机，也可以根据表的<strong>主键</strong>来将该表拆分放入不同的服务器。比如服务器A放入主键1到10万，服务器B放入10万零1到20万等等……</p><p>这个拆分可以一直持续下去，直到性能满足了业务的需要。具体的拆分方式也是根据具体业务来进行处理的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/313e9c3894bd95766643b2d6150946b3.png" alt="image.png"></p><p>分布式的处理其实都是基于具体业务的需要来分析的。业务决定了我们应该选取的技术解决方案。</p><h2 id="2-7-微服务架构"><a href="#2-7-微服务架构" class="headerlink" title="2.7 微服务架构"></a>2.7 微服务架构</h2><p>前面提到的处理都是在服务器拆分、数据库拆分上处理的。我们的应用服务器依旧是一个服务器能完成这个业务的所有任务。这样会导致该应用服务器的代码非常庞大，且难以进行维护。</p><p>我们可以将整个系统根据功能进行拆分，用户管理是一个应用服务器、商品交易是一个应用服务器、交易处理也是一个应用服务器，在不同的服务器之间可以通过消息中间件之类的方式进行数据通信。</p><p>而诸如安全处理等大家都用得上的公共服务，可以单开一个进行处理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/e46480d91db2ab3edce15e0946c0a14c.png" alt="image.png"></p><p>实际上，微服务是在解决团队协作的问题。单一应用服务器在规模大了之后会非常非常复杂，而使用微服务架构，<strong>可以将团队按照业务拆分成不同的小组</strong>，每个小组只需要维护产品中的一部分服务，这样维护单个服务的难度就降低了，更重要的是，企业的组织架构的分配变得更加方便。</p><h3 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h3><p>微服务的优势：</p><ul><li>解决了团队组织架构分配的问题</li><li>方便代码功能的复用（比如不同服务它的用户管理模块的代码其实是差别不大的，方便进行复用）</li><li>不同的服务，可以进行针对性的部署（比如某些服务的性能需求不高，就可以部署在配置相对较差的服务器上）</li></ul><h3 id="微服务的缺点"><a href="#微服务的缺点" class="headerlink" title="微服务的缺点"></a>微服务的缺点</h3><p>微服务架构对应用服务的拆分会进一步扩大整个系统的复杂性，反正就是越拆越复杂。缺点如下：</p><ul><li>系统响应速度降低：因为不同的模块是在不同的服务集群上处理，它们之间需要使用网络进行通信，相比于单个完整的应用服务器，整个系统的响应速度降低了。要想保证系统响应速度降低幅度小，就得引入更多的硬件资源来处理（更快的网卡）</li><li>系统出现问题概率提高：因为微服务会引入更多的机器，导致出现问题的概率被提高。需要更多更详细的监控和告警方式来保证多台云服务器的可用性。</li></ul><h1 id="3-分布式中涉及到的相关概念"><a href="#3-分布式中涉及到的相关概念" class="headerlink" title="3.分布式中涉及到的相关概念"></a>3.分布式中涉及到的相关概念</h1><h2 id="3-1-应用Application-x2F-系统System"><a href="#3-1-应用Application-x2F-系统System" class="headerlink" title="3.1 应用Application&#x2F;系统System"></a>3.1 应用Application&#x2F;系统System</h2><p>一个应用（系统）就是一个或者一组服务器程序</p><h2 id="3-2-模块Module-x2F-组件Componet"><a href="#3-2-模块Module-x2F-组件Componet" class="headerlink" title="3.2 模块Module&#x2F;组件Componet"></a>3.2 模块Module&#x2F;组件Componet</h2><p>应用中的不同功能被拆分成不同的模块，共同组成最终的应用程序</p><h2 id="3-3-分布式Distributed"><a href="#3-3-分布式Distributed" class="headerlink" title="3.3 分布式Distributed"></a>3.3 分布式Distributed</h2><p>引入多个服务器&#x2F;主机，协同配合完成一系列工作（物理上的多个主机）</p><h2 id="3-4-集群Cluster"><a href="#3-4-集群Cluster" class="headerlink" title="3.4 集群Cluster"></a>3.4 集群Cluster</h2><p>引入多个服务器&#x2F;主机，协同配合完成一系列工作（逻辑上的多个主机）</p><h2 id="3-5-主Master-x2F-从Slave"><a href="#3-5-主Master-x2F-从Slave" class="headerlink" title="3.5 主Master&#x2F;从Slave"></a>3.5 主Master&#x2F;从Slave</h2><p>多个服务器节点中，一个是主节点，其他是从节点。<code>从节点</code>需要从<code>主节点</code>中同步数据。</p><h2 id="3-6-中间件Middleware"><a href="#3-6-中间件Middleware" class="headerlink" title="3.6 中间件Middleware"></a>3.6 中间件Middleware</h2><p>和具体业务无关，但在系统中需要使用的服务。比如数据库、缓存、消息队列等。</p><h2 id="3-7-可用性Availability"><a href="#3-7-可用性Availability" class="headerlink" title="3.7 可用性Availability"></a>3.7 可用性Availability</h2><p>系统整体可用时间&#x2F;总时间</p><blockquote><p>三个9代表可用性是<code>99.999%</code>；</p></blockquote><h2 id="3-8-响应时间Response-Time-RT"><a href="#3-8-响应时间Response-Time-RT" class="headerlink" title="3.8 响应时间Response Time RT"></a>3.8 响应时间Response Time RT</h2><p>用于衡量服务器的性能，响应时间越快越好</p><h2 id="3-9-吞吐Throughput和并发Concurrent"><a href="#3-9-吞吐Throughput和并发Concurrent" class="headerlink" title="3.9 吞吐Throughput和并发Concurrent"></a>3.9 吞吐Throughput和并发Concurrent</h2><p>衡量系统处理请求的能力，也是衡量性能的方式之一。</p><h1 id="4-Redis的特性"><a href="#4-Redis的特性" class="headerlink" title="4.Redis的特性"></a>4.Redis的特性</h1><p>我们可以在redis的官网上看到redis的特性，一个一个来认识一下吧</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/9aec7a8ebddb4dd911e41981cea8d11a.png" alt="image-20240210135822201"></p><h2 id="4-1-In-memory-data-structures"><a href="#4-1-In-memory-data-structures" class="headerlink" title="4.1 In-memory data structures"></a>4.1 In-memory data structures</h2><p>前面已经提到过，Redis是一个KV方式的内存级数据库，它的Key都是string，value可以是string、hash、list、set、zset、bitmaps、GEO等各种数据结构。</p><p>使用Key-Value方式来存放数据的数据库，被称为<code>非关系数据库</code>，NoSQL也是类似的含义。</p><h2 id="4-2-Progarmmability"><a href="#4-2-Progarmmability" class="headerlink" title="4.2 Progarmmability"></a>4.2 Progarmmability</h2><p>针对Redis的操作，可以通过简单的交互式命令来存放数据，也可以通过脚本来批量执行一些操作。</p><h2 id="4-3-Extentsibility"><a href="#4-3-Extentsibility" class="headerlink" title="4.3 Extentsibility"></a>4.3 Extentsibility</h2><p>Redis提供了一系列API，可以在Redis原有功能的基础上配置扩展，比如让Redis支持更多数据结构。支持C&#x2F;C++&#x2F;Rust语言。</p><h2 id="4-4-Persistence"><a href="#4-4-Persistence" class="headerlink" title="4.4 Persistence"></a>4.4 Persistence</h2><p>Redis是将数据存放在内存中的，但也提供了<strong>持久化</strong>方式来保证系统重启时数据不会丢失。</p><h2 id="4-5-Clustering"><a href="#4-5-Clustering" class="headerlink" title="4.5 Clustering"></a>4.5 Clustering</h2><p>Redis作为分布式系统的中间件，原生支持集群部署。</p><p>Horizontal scalability 指的是系统的水平扩展能力，类似于“分库分表”。</p><h2 id="4-6-High-availability"><a href="#4-6-High-availability" class="headerlink" title="4.6 High availability"></a>4.6 High availability</h2><p>Redis原生支持主从结构，从节点相当于主节点的备份，主节点失效时从节点能立马顶上去（替补）。</p><h2 id="4-7-天下武功唯快不破"><a href="#4-7-天下武功唯快不破" class="headerlink" title="4.7 天下武功唯快不破"></a>4.7 天下武功唯快不破</h2><p>Redis能被广泛的使用，最大的原因还是因为它很快！</p><ol><li>Redis数据在内存中，比访问硬盘的数据库快的多；</li><li>Redis的核心功能逻辑较为简单，只是操作内存中的数据结构；</li><li>Redis使用了IO多路复用(epoll)来处理网络请求；</li><li>Redis使用的单线程模型（高版本Redis引入了多线程），减少了线程竞争的不必要的开销。</li></ol><p>这里要补充一点，多线程提高效率的前提是执行的是CPU密集型的操作，多线程才能充分利用CPU的多核心资源。而Redis的核心功能只是操作内存中的数据，对CPU的负载并不高。</p><p>相比MySQL在增删改数据的时候需要关注数据库中的各种约束，这些检查就增加了负担，耗时也会被Redis的简单修改更长。</p><p>另外，IO多路复用是一个很重要的概念，它是操作系统提供的接口（比如Linux提供的C语言接口，而Redis正好就是C语言编写的）让一个线程有办法同时处理多个网络请求。如果没有多路复用，一个线程就只能给一个请求服务，Redis的单线程设计就不好用了。具体可以点击链接查看本站的博客。<a href="https://blog.musnow.top/posts/3390191280">【Linux】高级IO和多路转接 | select&#x2F;poll&#x2F;epoll | 慕雪的寒舍</a></p><h1 id="5-Redis的单线程模型"><a href="#5-Redis的单线程模型" class="headerlink" title="5.Redis的单线程模型"></a>5.Redis的单线程模型</h1><p>上文提到，Redis是采用单线程模型进行设计的，虽然高版本Redis引入了多线程，但只限于网络IO部分（多线程来处理网络请求）实际的存储操作还是使用单线程来处理的。</p><p>复习一下多线程并发可能导致的问题吧：假设两个Redis客户端链接了服务器，都希望对同一个key进行set操作，客户端A希望将key加一，客户端B也希望将key加一，这两个请求几乎同时发送给Redis的服务器，假设Redis服务器采用多线程来处理，那么就有可能出现</p><ul><li>A的请求读取了key的当前值，准备进行加一操作；</li><li>B的请求读取了key的当前值，也准备进行加一操作；</li><li>由于两个读取几乎是同时发生的，A和B的处理线程读取到的key的值一致；</li><li>最终导致key只被加一了（实际需要加二）；</li></ul><p>而实际上，Redis采用单线程模型，A和B的请求肯定会有个先后顺序，最终处理是<strong>串行</strong>（依次执行）的，要么是先处理A的加一，再处理B的加一，最终肯定能得到加二的正确结果。</p><p>Redis在网络IO上引入多线程，但在核心处理保持单线程，可以在提高网络IO处理效率的基础上，保证对数据的操作一定是串行的。</p><blockquote><p>这就好比一个食堂只有一个打饭窗口，中午下课了一堆人去食堂（网络IO多线程），但进了食堂之后还是得排队打饭（串行）。</p></blockquote><p>因为Redis的核心操作对CPU的负载并不高，所以它没有必要使用多线程来提高数据处理方面的效率（因为使用多线程就务必需要加锁&#x2F;解锁以及资源竞争，本来开门取东西只需要一下子就搞定了，现在还多了解锁&#x2F;关门上锁的步骤，效率可能不增反降）。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1>]]></content>
    
    
    <summary type="html">什么是Redis？什么是分布式系统？</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.musnow.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】gitea的ssh容器直通</title>
    <link href="https://blog.musnow.top/posts/1063684344/"/>
    <id>https://blog.musnow.top/posts/1063684344/</id>
    <published>2024-02-07T07:01:43.000Z</published>
    <updated>2024-02-24T03:01:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-跟着文档走"><a href="#1-跟着文档走" class="headerlink" title="1.跟着文档走"></a>1.跟着文档走</h1><p>gitea的安装比较简单，直接使用官方文档中的docker-compose文件即可。如果想实现ssh容器直通，需要对这个docker-compose文件做一定修改。</p><blockquote><p>如果你还没有安装docker，参考本站教程 <a href="https://blog.musnow.top/posts/2069190154">linux安装docker</a>；</p></blockquote><p>gitea的官方文档上有关于docker容器ssh直通的教程，但是写的不够清晰，有些问题我没有搞懂。本文基于我的折腾记录和docker安装的gitea 1.21.4文档</p><p><a href="https://docs.gitea.com/zh-cn/next/installation/install-with-docker#ssh-%E5%AE%B9%E5%99%A8%E7%9B%B4%E9%80%9A">使用 Docker 安装 | Gitea Documentation</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4a6a40b4f39a75d32fc7fc45919316ba.png" alt="image.png"></p><p>首先是跟着文章里面的步骤做，先创建一个git子用户。wsl中创建子用户的命令参考本站博客（使用adduser命令），注意创建的git用户的uid和gid是1001，docker-compose中的环境变量需要对应修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">USER_UID=1001</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">USER_GID=1001</span></span><br></pre></td></tr></table></figure><p>还需要新增一个路径映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- /home/git/.ssh/:/data/git/.ssh</span><br></pre></td></tr></table></figure><blockquote><p>注意：为了避免文件读写权限问题，我建议在创建git子用户后，在该子用户中操作docker-compose和新建gitea的映射文件夹，这样能保证1001用户和gitea容器一定能访问到文件夹且具有权限。</p></blockquote><p>在git用户中执行如下命令。出现的提示框全部回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u git ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;Gitea Host Key&quot;</span></span><br></pre></td></tr></table></figure><p>随后执行如下命令，即把<code>/home/git/.ssh/id_rsa.pub</code>写入<code>/home/git/.ssh/authorized_keys</code>文件。执行完毕后请不要再手动修改authorized_keys文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cat /home/git/.ssh/id_rsa.pub)</span>&quot;</span> &gt;&gt; /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>还需要创建一个脚本来执行ssh信息转发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/local/bin/gitea</span><br></pre></td></tr></table></figure><p>写入如下内容，可以通过<code>CTRL+SHIFT+V</code>直接粘贴。这里假设你将gitea容器的22端口转发到宿主机的2222端口（如果你的宿主机映射端口不同，可以修改脚本中的端口号）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 -o StrictHostKeyChecking=no git@127.0.0.1 &quot;SSH_ORIGINAL_COMMAND=\&quot;$SSH_ORIGINAL_COMMAND\&quot; $0 $@&quot;</span><br></pre></td></tr></table></figure><p>因为ssh容器直通都是本机处理的操作，所以我们可以在docker-compose中端口映射的时候限制来源IP地址为本地回环地址，这样就能保证只有宿主机中能访问2222端口到gitea中，而2222端口无法直接被外界访问。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="comment"># [...]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:2222:22&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ssh直通流程"><a href="#ssh直通流程" class="headerlink" title="ssh直通流程"></a>ssh直通流程</h2><p>配置完毕ssh直通后，git操作流程如下：</p><ol><li>用户使用<code>git@IP地址</code>访问主机，默认访问22端口；</li><li>主机验证git用户下<code>.ssh/authorized_keys</code>的<code>command</code>开头的公钥中，发现用户公钥；</li><li>主机执行command指定的脚本，将此次请求的信息转发给gitea容器的ssh端口；</li><li>gitea容器执行ssh请求处理；</li></ol><p>如果不使用容器直通，你可以选择用https来进行git操作，或者在ssh使用时添加端口号。二者都会比直接使用ssh麻烦一些。</p><h1 id="2-安装ssh服务"><a href="#2-安装ssh服务" class="headerlink" title="2.安装ssh服务"></a>2.安装ssh服务</h1><p>另外，默认情况下wsl中是没有ssh服务的，你会发现22端口无人使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# netstat -nltp | grep 22</span><br><span class="line">tcp        0      0 127.0.0.1:2222          0.0.0.0:*               LISTEN      2816/docker-proxy</span><br></pre></td></tr></table></figure><p>需要安装一下ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y openssh-server</span><br><span class="line">sudo systemctl start sshd</span><br></pre></td></tr></table></figure><p>使用如下命令查看服务状态以及是否启用了开机自启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# systemsystemctl status sshd</span><br><span class="line">● ssh.service - OpenBSD Secure Shell server</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Wed 2024-02-07 14:59:06 CST; 9min ago</span><br><span class="line">       Docs: man:sshd(8)</span><br><span class="line">             man:sshd_config(5)</span><br><span class="line">   Main PID: 5202 (sshd)</span><br><span class="line">      Tasks: 1 (limit: 9527)</span><br><span class="line">     Memory: 1.7M</span><br><span class="line">     CGroup: /system.slice/ssh.service</span><br><span class="line">             └─5202 &quot;sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups&quot;</span><br><span class="line"></span><br><span class="line">Feb 07 14:59:06 wsl-ubuntu systemd[1]: Starting OpenBSD Secure Shell server...</span><br><span class="line">Feb 07 14:59:06 wsl-ubuntu sshd[5202]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">Feb 07 14:59:06 wsl-ubuntu sshd[5202]: Server listening on :: port 22.</span><br><span class="line">Feb 07 14:59:06 wsl-ubuntu systemd[1]: Started OpenBSD Secure Shell server.</span><br><span class="line">[root:~]# sudo systemctl is-enabled sshd</span><br><span class="line">alias</span><br><span class="line">[root:~]# sudo systemctl is-enabled ssh</span><br><span class="line">enabled</span><br></pre></td></tr></table></figure><p>此时再看看22端口，就有人干活了，sshd服务启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# netstat -nltp | grep 22</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      5202/sshd: /usr/sbi</span><br><span class="line">tcp        0      0 127.0.0.1:2222          0.0.0.0:*               LISTEN      2816/docker-proxy</span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      5202/sshd: /usr/sbi</span><br></pre></td></tr></table></figure><h1 id="3-web界面添加用户ssh公钥"><a href="#3-web界面添加用户ssh公钥" class="headerlink" title="3.web界面添加用户ssh公钥"></a>3.web界面添加用户ssh公钥</h1><p>随后就是和github一样的操作， 在gitea的web页面添加用户的公钥。</p><p><a href="https://blog.musnow.top/posts/3625274788/">【Linux】如何使用 ssh 密钥配置 git</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4e28dd20b29a4e7ebaabcce3c09ac579.png" alt="image.png"></p><p>添加完毕后，检查一下git用户里面的<code>/home/git/.ssh/authorized_keys</code>文件是否有变动，文件应该如下格式，会有一个<code>command=</code>存放了你刚刚在gitea web页面添加的用户公钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa &lt;Gitea Host Key&gt;</span><br><span class="line"></span><br><span class="line"># other keys from users</span><br><span class="line">command=&quot;/usr/local/bin/gitea --config=/data/gitea/conf/app.ini serv key-1&quot;,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty &lt;user pubkey&gt;</span><br></pre></td></tr></table></figure><p>文档中关于这一块的描述不够清楚（我感觉是机翻的问题）</p><blockquote><p>原文：重要提示：来自 git 用户的公钥需要“按原样”添加，而通过 Gitea 网络界面添加的所有其他公钥将以 <code>command=&quot;/app [...]</code> 作为前缀。</p></blockquote><p>其实这个说明的意思是，默认情况下的<code>authorized_keys</code>文件中应该只有下面的内容（即“按原样”添加），而gitea web页面添加的其他公钥应该都是以<code>command=&quot;</code> 作为前缀，<strong>自动</strong>添加到<code>authorized_keys</code>文件之后的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa &lt;Gitea Host Key&gt;</span><br></pre></td></tr></table></figure><p>说白了就是，在执行完毕上文提到的将<code>id_rsa.pub</code>文件的内容写入<code>authorized_keys</code>的操作后，<strong>我们就不要手动修改authorized_keys这个文件了</strong>！如果出现问题，再依照文档中的这个提示检查该文件中的公钥格式是否正确。</p><p>官网文档中还提到了下面几个注意事项，我们全都不用管！只要你没有修改过配置文件和gitea容器中的环境，这些配置项都是默认情况下就OK了的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4a3b6349ff4e3db039e87550910597d8.png" alt="image.png"></p><h1 id="4-验证是否直通成功"><a href="#4-验证是否直通成功" class="headerlink" title="4.验证是否直通成功"></a>4.验证是否直通成功</h1><p>尝试验证ssh是否成功，这里的ip是wsl的本机ip，可以在wsl中通过ifconfig命令查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@172.26.39.91</span><br></pre></td></tr></table></figure><p>如果出现下面的情况，说明22端口没有被成功开放，请检查:</p><ul><li>宿主机中的22端口是否已经配置了sshd服务，并正常监听22端口；</li><li>在web页面添加的用户公钥是否添加到了<code>/home/git/.ssh/authorized_keys</code>文件中；</li><li><code>/usr/local/bin/gitea</code>脚本中的命令无误。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS D:\test-git&gt; git clone git@172.26.39.91:musnows/test-action.git</span><br><span class="line">Cloning into &#x27;test-action&#x27;...</span><br><span class="line">ssh: connect to host 172.26.39.91 port 22: Connection refused</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><p>如果看到了下面的内容，可以说明我们wsl中的的ssh服务已经成功启动了，但是没有成功通过脚本验证git用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS D:\test-git&gt; ssh -T git@172.26.39.91</span><br><span class="line">The authenticity of host &#x27;172.26.39.91 (172.26.39.91)&#x27; can&#x27;t be established.</span><br><span class="line">ED25519 key fingerprint is SHA256:xRPtWVSIsHrqmP3VaBD+ZR24nE6SWmgjWUYENN0IfB8.</span><br><span class="line">This key is not known by any other names</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line">Warning: Permanently added &#x27;172.26.39.91&#x27; (ED25519) to the list of known hosts.</span><br><span class="line">bash: line 1: /usr/local/bin/gitea: Permission denied</span><br></pre></td></tr></table></figure><p>这是因为我们的git用户没有办法执行<code>/usr/local/bin/gitea</code>脚本，还记得吗，这个脚本是通过sudo创建的，默认情况下是一个文本文件，且只有root用户有权限访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# ll /usr/local/bin/gitea</span><br><span class="line">-rw-r--r-- 1 root root 109 Feb  7 14:47 /usr/local/bin/gitea</span><br></pre></td></tr></table></figure><p>解决办法很简单，将其权限改成777即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# chmod 777 /usr/local/bin/gitea</span><br><span class="line">[root:~]# ll /usr/local/bin/gitea</span><br><span class="line">-rwxrwxrwx 1 root root 109 Feb  7 14:47 /usr/local/bin/gitea*</span><br></pre></td></tr></table></figure><p>此时再次测试，发现成功直通gitea容器内ssh！这里会显示你在web页面中添加的ssh密钥的名字<code>user from windows</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS D:\test-git&gt; ssh -T git@172.26.39.91</span><br><span class="line">Warning: Permanently added &#x27;[127.0.0.1]:2222&#x27; (ED25519) to the list of known hosts.</span><br><span class="line">Hi there, musnows! You&#x27;ve successfully authenticated with the key named user from windows, but Gitea does not provide shell access.</span><br><span class="line">If this is unexpected, please log in with password and setup Gitea under another user.</span><br></pre></td></tr></table></figure><p>再试试能不能通过ssh克隆仓库，搞定！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS D:\test-git&gt; git clone git@172.26.39.91:musnows/test-action.git</span><br><span class="line">Cloning into &#x27;test-action&#x27;...</span><br><span class="line">remote: Enumerating objects: 80, done.</span><br><span class="line">remote: Counting objects: 100% (80/80), done.</span><br><span class="line">remote: Compressing objects: 100% (58/58), done.</span><br><span class="line">remote: Total 80 (delta 22), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Receiving objects: 100% (80/80), 56.15 KiB | 9.36 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (22/22), done.</span><br></pre></td></tr></table></figure><h1 id="5-docker-compose文件"><a href="#5-docker-compose文件" class="headerlink" title="5.docker-compose文件"></a>5.docker-compose文件</h1><p>下面给出本文所用的gitea容器docker-compose文件，只在官方文档所提供的版本上做了少量修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitea/gitea:1.21.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_UID=1001</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_GID=1001</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/git/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/git/.ssh/:/data/git/.ssh</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;30000:3000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:2222:22&quot;</span></span><br></pre></td></tr></table></figure><p>注意，在初始化gitea的时候不要修改web界面和ssh的监听端口（对应的是容器内的端口），否则上文的ssh直通可能会失败！</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>如果有疑问，欢迎在评论区交流。</p><p>相关参考：<a href="https://moqiaoduo.cn/310.html">如何通过Docker搭建Gitea并配置SSL和SSH直通 - 莫乔多博客</a></p>]]></content>
    
    
    <summary type="html">docker安装的gitea在wsl2上配置ssh容器直通</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
    <category term="gitea" scheme="https://blog.musnow.top/tags/gitea/"/>
    
  </entry>
  
  <entry>
    <title>【WSL】wsl中ubuntu无法通过useradd添加用户</title>
    <link href="https://blog.musnow.top/posts/803882566/"/>
    <id>https://blog.musnow.top/posts/803882566/</id>
    <published>2024-02-07T06:59:43.000Z</published>
    <updated>2024-02-16T00:58:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>适用于hexo-butterfly主题的front-matter模板。</p><h1 id="情况说明"><a href="#情况说明" class="headerlink" title="情况说明"></a>情况说明</h1><p>在wsl2中的ubuntu22.04无法使用useradd添加用户，表现为执行命令后，只出现该用户和用户组，但<code>/home</code>目录下没有出现该用户的家目录文件夹，且无法使用<code>su - 用户名</code>成功切换到该用户上。</p><p>如下所示，我先从wsl子用户切换到root用户，然后执行useradd命令，发现用户创建没有完全成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wsl:~$ sudo su - </span><br><span class="line"></span><br><span class="line">root:~# useradd git</span><br><span class="line">root:~# ls /home</span><br><span class="line">wsl</span><br><span class="line">root:~# sudo adduser git</span><br><span class="line">adduser: The user `git&#x27; already exists.</span><br><span class="line">root:~# userdel -r git</span><br><span class="line">userdel: git mail spool (/var/mail/git) not found</span><br><span class="line">userdel: git home directory (/home/git) not found</span><br><span class="line">root:~# userdel -r git</span><br><span class="line">userdel: user &#x27;git&#x27; does not exist</span><br></pre></td></tr></table></figure><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><del>这是因为wsl2和传统的VMware类型虚拟机有一定区别，其不支持使用useradd直接添加用户</del>，而是提供了adduser命令来处理。准确来说是Ubuntu22.04不支持useradd，而是需要使用adduser。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser &lt;新的用户名&gt;</span><br></pre></td></tr></table></figure><p>使用这个命令则可以正常创建用户，如下所示我创建了一个用户名为git的用户。需要填写用户信息的部分直接回车跳过即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root:~# sudo adduser git</span><br><span class="line">Adding user `git&#x27; ...</span><br><span class="line">Adding new group `git&#x27; (1001) ...</span><br><span class="line">Adding new user `git&#x27; (1001) with group `git&#x27; ...</span><br><span class="line">Creating home directory `/home/git&#x27; ...</span><br><span class="line">Copying files from `/etc/skel&#x27; ...</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for git</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">        Full Name []:</span><br><span class="line">        Room Number []:</span><br><span class="line">        Work Phone []:</span><br><span class="line">        Home Phone []:</span><br><span class="line">        Other []:</span><br><span class="line">Is the information correct? [Y/n] y</span><br><span class="line">root:~# ls /home</span><br><span class="line">git  wsl</span><br></pre></td></tr></table></figure><p>使用id命令可以查看新用户的用户组以及uid等相关信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:~# id git</span><br><span class="line">uid=1001(git) gid=1001(git) groups=1001(git)</span><br></pre></td></tr></table></figure><p>注意，该新用户不在<code>/etc/sudoers</code>文件中，无法使用sudo命令。需要修改该文件，在如下位置之后添加一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL:ALL) ALL</span><br><span class="line"># 新增此行</span><br><span class="line">用户名 ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl中ubuntu无法通过useradd添加用户,应该使用adduser命令</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Linux" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite3】MySQL8转sqlite3需要对sql做的一些处理</title>
    <link href="https://blog.musnow.top/posts/2778694447/"/>
    <id>https://blog.musnow.top/posts/2778694447/</id>
    <published>2024-02-06T03:19:37.000Z</published>
    <updated>2024-02-06T04:07:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>最近编写我的kook机器人的时候，发现MySQL对于这种低访问频次的应用并不友好，经常出现断连的问题，具体到python中的报错如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pymysql.err.InterfaceError: (0, &#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>出现这种报错，就可以认为是MySQL那端因为自身策略中断了和你的应用的链接。因为我的机器人和MySQL是在同一台主机上，肯定不是网络本身问题导致的。</p><p>所以我需要将MySQL数据库换成sqlite3数据库。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/701727d98b31f035e72bef4e76b341a1.png"></p><h1 id="MySQL转sqlite3"><a href="#MySQL转sqlite3" class="headerlink" title="MySQL转sqlite3"></a>MySQL转sqlite3</h1><h2 id="导出MySQL中的数据"><a href="#导出MySQL中的数据" class="headerlink" title="导出MySQL中的数据"></a>导出MySQL中的数据</h2><p>好在我的机器人使用的是python的peewee这个ORM库，只需要修改底层的DB引擎就能快速在MySQL和sqlite3之间切换。我们要解决的只是怎么把MySQL8.0.30的数据导入到sqlite3中。</p><blockquote><p>本文测试使用的版本为：<code>MySQL 8.0.30</code> 和 <code>sqlite3 3.44.0</code></p></blockquote><p>首先是从MySQL将数据库里面的所有数据导出为sql文件，因为我安装了1panel服务器面板，所以可以直接使用面板的备份功能，再把备份好的tar下载下来（里面就是sql文件）</p><p>这里给出用命令行来处理的方式，一般使用的工具为mysqldump，在安装MySQL的时候这个工具应该就会连带安装。我的MySQL是用docker安装的，docker容器内的终端也有这个命令工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~/docker]# docker exec -it mysql /bin/bash</span><br><span class="line">bash-4.4# mysqldump</span><br><span class="line">Usage: mysqldump [OPTIONS] database [tables]</span><br><span class="line">OR     mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]</span><br><span class="line">OR     mysqldump [OPTIONS] --all-databases [OPTIONS]</span><br><span class="line">For more options, use mysqldump --help</span><br><span class="line">bash-4.4# </span><br></pre></td></tr></table></figure><p>导出整个数据库的数据到sql的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u username -ppassword dbname &gt; dbname.sql；</span><br></pre></td></tr></table></figure><p>比如我有个testdb数据库，将其导入testdb.sql的命令如下，这里我直接使用了root用户来处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 testdb &gt; testdb.sql</span><br></pre></td></tr></table></figure><p>因为在命令行使用密码被认为是不安全的，所以键入如上命令的时候会有一个警告，可以忽略它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.</span><br></pre></td></tr></table></figure><p>ls查看一下，当前路径上已经有我们需要的sql数据文件了。</p><h2 id="docker内文件拷贝到宿主机"><a href="#docker内文件拷贝到宿主机" class="headerlink" title="docker内文件拷贝到宿主机"></a>docker内文件拷贝到宿主机</h2><p>因为我现在的这个操作是在一个docker容器里面，我还需要将其从docker中拷贝出来，方法有两个</p><ol><li>将sql文件拷贝到docker的持久化目录中（即映射到了宿主机的目录中）；</li><li>使用docker copy命令；</li></ol><p>对于1panel安装的MySQL容器而言，你可以在容器的详细设置里面看到映射路径的关系。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/83b63cefa278acce4ddaf80fcbe5fe56.png" alt="image.png"></p><p>如果使用docker cp命令，格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 容器ID:容器内路径 宿主机路径</span><br></pre></td></tr></table></figure><p>这里的容器ID可以是容器的名字，也可以是docker ps命令查看到的容器<code>CONTAINER ID</code>；mysqldump命令弄出来的sql文件是在容器内的根目录上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker cp mysql:/testdb.sql ~/testdb.sql</span></span><br><span class="line">Successfully copied 9.85MB to /root/testdb.sql</span><br></pre></td></tr></table></figure><h2 id="修改sql文件"><a href="#修改sql文件" class="headerlink" title="修改sql文件"></a>修改sql文件</h2><p>MySQL导出的sql文件不能直接被sqlite3识别，在我的机器人数据库中遇到如下几个问题，需要修改sql文件。</p><ul><li>用peewee创建sqlite数据库时生成的create table语句替换MySQL导出的sql文件内部已有的建表语句；</li><li>删除sql文件中的<code>LOCK TABLES </code>和<code>UNLOCK TABLES;</code>，因为sqlite不支持；</li><li>sql文件中的转义字符<code>\&quot;</code>替换成<code>&quot;</code>。因为在sqlite3中不需要进行此转义。如果不修改，那么在sqlite3中list的json字符串中就会留有<code>\&quot;</code>导致无法被<code>json.loads</code>（猜测sqlite3中<code>&#39;</code>的优先级高于<code>&quot;</code>）</li></ul><p>首先是把python中peewee使用的数据库模型改成sqlite，然后启动一下这个机器人，此时peewee就会创建一个db文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 数据库文件名.db</span><br></pre></td></tr></table></figure><p>进入该db文件后执行如下查询命令，能看到sqlite3的建表语句，将其替换掉MySQL中导出sql里面的建表命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT sql FROM sqlite_master WHERE type=&#x27;table&#x27;;</span><br></pre></td></tr></table></figure><p>如果你用的不是peewee这种ORM库，则还需要自行修改建表命令为sqlite3的命令（可以问问gpt让他帮你改一下，或者自己重写一个）。比如在sqlite3中就不支持表后跟随的<code>AUTO_INCREMENT=4728</code>语句。</p><h2 id="文件导入到sqlite3"><a href="#文件导入到sqlite3" class="headerlink" title="文件导入到sqlite3"></a>文件导入到sqlite3</h2><p>sqlite3的导入命令格式如下，左侧是数据库文件名字，右侧是需要导入的源sql文件。为了避免文件名编码问题，建议使用全英文名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 数据库名字.db &lt; 需要导入的文件.sql</span><br></pre></td></tr></table></figure><p>这个命令成功的时候不会有任何输出，使用如下命令进入导入后生成的db文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 数据库名字.db</span><br></pre></td></tr></table></figure><p>不出意外的话，所有数据就已经导入到这个新的数据库文件中了，检查一下和MySQL中的数据库有没有不一样的地方吧！</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>有更多问题，欢迎评论留言讨论。</p>]]></content>
    
    
    <summary type="html">MySQL8转sqlite3需要对sql做的一些处理</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据库SQL" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/"/>
    
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
    <category term="sqlite3" scheme="https://blog.musnow.top/tags/sqlite3/"/>
    
  </entry>
  
  <entry>
    <title>【win】使用分区助手扩容C盘</title>
    <link href="https://blog.musnow.top/posts/3746722946/"/>
    <id>https://blog.musnow.top/posts/3746722946/</id>
    <published>2024-02-02T01:15:20.000Z</published>
    <updated>2024-02-02T02:33:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h2><p>如果你像我一样，用的是联想的笔记本，这3年内的联想笔记本都会出厂分盘（据我所知是这样的），C盘雷打不动的200GB，D盘中会存放一个原厂的驱动文件夹，包括你这台电脑的所有驱动。</p><p>但是，200GB很快就会被某些奇奇怪怪的软件缓存给撑满，即便我把微信和QQ两个软件的资料文件夹给转移到D盘了，C盘在用了几个月后就莫名其妙的只剩下50G甚至更少了，看着让人很是焦绿，还是给它扩容一下吧。</p><h2 id="分区助手"><a href="#分区助手" class="headerlink" title="分区助手"></a>分区助手</h2><p>windows是自带磁盘分区管理的，<code>右键我的电脑-属性-存储-磁盘管理</code>，这里能到你的系统里面的所有物理硬盘，和每个硬盘的分区情况，可以在这里对分区进行一定的调整。</p><p>但很遗憾的是，在这里并不能对C盘进行扩容操作，当你给D盘<code>压缩卷</code>后再右键C盘，会发现<code>扩展卷</code>按钮是灰色的，无法被点击，也就无法扩容。</p><p>这时候就需要使用第三方工具来操作了：<a href="https://www.disktool.cn/">傲梅分区助手、轻松备份、数据恢复(恢复之星)、远程控制（AnyViewer）等软件免费下载官网</a></p><blockquote><p>注意：之前在B站看过相关视频，有不少人评论说使用该工具导致系统盘内资料丢失的（虽然在我的几次搞机使用体验中并没有遇到）。为了保险起见，请先备份你的<strong>C盘所在物理盘</strong>内的所有文件后再进行操作！数据无价！<strong>备份，备份，备份</strong>！！</p></blockquote><p>下载软件后安装，安装完毕后打开软件会让你输入一个免费使用密码，这个密码一直是1122（至少一年没变过了，如果不行就去它们的公众号获取一下最新密码吧）</p><p>本次测试使用的是新版10.2版本。</p><p>进入软件后看到的界面和windows自带的磁盘管理类似，这里能看到原装1TB的固态分了一个C盘和一个D盘（下图中已经是我操作后的结果了，所以C盘是300GB）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/9247b21d9bbd6d8997a14dc33c912316.png" alt="image.png"></p><p>如果你想扩容C盘，右键红色框框区域的C盘，选择<code>调整/移动分区</code>，会打开如下界面。勾选<code>从(*)分区中划分空间给(C)</code>，此时右侧会出现一个下拉菜单，勾选D盘（一定不要勾选那两个<code>*</code>开头的保留分区），此时就可以输入你想给C盘扩容后的容量了，比如想把C盘扩容到300GB就输入300即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/c89b075a1e132a8adaca64af27a4b18c.png" alt="image.png"></p><p>再次提醒：进行下一步之前，请先备份C盘所在文件夹的资料文件！！！</p><p>作为示例，这里我输入C盘扩容到350GB</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/72abda5f856a99013ca91cee16406a4b.png" alt="image.png"></p><p>点击确定，会发现下方分区大小已经变化了，但实际上我们的操作还没提交，右上角可以看到提交按钮亮起，有三个操作需要进行</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/d0076d1aa4c517a429d324713be9b0d7.png" alt="image.png"></p><p>这三个操作分别是缩容D盘，移动分区，扩容C盘。这里显示的预期时间很夸张，但实际上15分钟左右就能完成。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/2ad8be24ca47afcb336e76c97e9e9220.png" alt="image.png"></p><p>此时点击执行，会让你选择在什么模式下操作，一般情况选择Windows PE模式即可。选择后点击确定，分区助手就会重启电脑并开始扩容操作。</p><p>再次提醒：这一步的确定后就没有回头路了！！！一定要备份哦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/19bc8602625ff5e20b5d57c7ed8294c3.png" alt="image.png"></p><p>会先在软件内走个进度条，随后重启电脑进入PE模式操作，PE界面长下面这样。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/a70195203766f4672afd546e10a34eea.png" alt="image.png"></p><p>耐心等待他完成即可，分区助手会自动重启电脑回到windows。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>然后就搞定了！成功将C盘从200GB扩容到300GB，且两个盘的资料都在。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/be620570e1124c946d5b6c531992ae58.png" alt="image.png"></p><p>最后还是得上个提醒，虽然我这边实测能成功，但不代表你那边一定能保留资料！备份准没错哦。</p>]]></content>
    
    
    <summary type="html">使用分区助手扩容windows的C盘</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Artalk】可信域名未配置导致的跨域访问问题</title>
    <link href="https://blog.musnow.top/posts/1277415323/"/>
    <id>https://blog.musnow.top/posts/1277415323/</id>
    <published>2024-01-31T03:40:00.000Z</published>
    <updated>2024-01-31T13:11:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天折腾halo的时候，发现artalk出现跨域访问报错，内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access to fetch at &#x27;https://artk.musnow.top/api/stat&#x27; from origin &#x27;https://halo.musnow.top&#x27; has been blocked by CORS policy: The &#x27;Access-Control-Allow-Origin&#x27; header contains multiple values &#x27;, https://halo.musnow.top&#x27;, but only one is allowed. </span><br><span class="line">Have the server send the header with a valid value, or, if an opaque response serves your needs, set the request&#x27;s mode to &#x27;no-cors&#x27; to fetch the resource with CORS disabled.</span><br></pre></td></tr></table></figure><p>尝试在nginx里面加了一个跨域访问头，依旧没有解决这个问题</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Access-Control-Allow-Origin <span class="string">&#x27;https://halo.musnow.top&#x27;</span> always;</span><br></pre></td></tr></table></figure><p>后来咨询其他老哥才知道，这是artalk内部可信域名配置的问题，不需要修改nginx配置文件。(记得把上方的nginx配置删掉)</p><p>我只添加了站点的可信域名，artalk系统设置里面还有一个可信域名配置</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/6d160c66af4d1c70cfb05cce383131f8.png" alt="image.png"></p><p>设置了之后需要重启artalk容器，才能让修改生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart artalk-go</span><br></pre></td></tr></table></figure><p>现在就OK了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/8ca3eab60bfb00557e0284d19b668de8.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">artalk后台可信域名未配置导致的跨域访问问题</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="博客" scheme="https://blog.musnow.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】内置函数</title>
    <link href="https://blog.musnow.top/posts/4252514363/"/>
    <id>https://blog.musnow.top/posts/4252514363/</id>
    <published>2024-01-30T07:45:00.000Z</published>
    <updated>2024-02-15T07:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>像编程语言一样，MySQL同样也提供了一部分内置函数供用户在SQL中进行调用。这些内置函数能简单处理一部分数据，避免我们在不同的用户层语言中进行逻辑编写。</p><h1 id="1-日期函数"><a href="#1-日期函数" class="headerlink" title="1.日期函数"></a>1.日期函数</h1><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>current_date()</td><td>当前日期</td></tr><tr><td>current_time()</td><td>当前时间</td></tr><tr><td>current_timestamp()</td><td>当前日期和时间</td></tr><tr><td>now()</td><td>当前日期和时间（同上）</td></tr><tr><td>unix_timestamp()</td><td>当前时间戳数字</td></tr><tr><td>date(datetime)</td><td>返回datetime参数中的日期部分</td></tr><tr><td>date_add(date,interval d_value_type)</td><td>在date中添加日期或时间，interval后的参数可以是<code>year/month/day/hour/mintue/second</code></td></tr><tr><td>date_sub(date,interval d_value_type)</td><td>在date中减去日期或时间，interval后的参数可以是<code>year/month/day/hour/mintue/second</code></td></tr><tr><td>datediff(date1,date2)</td><td>计算两个日期的时间差，单位为天</td></tr><tr><td>date_format(date,format_string)</td><td>根据format_string字符串来格式化时间显示</td></tr><tr><td>year(date)</td><td>获取日期中的年份</td></tr><tr><td>month(date)</td><td>获取日期中的月份</td></tr><tr><td>day(date)</td><td>获取日期中的天</td></tr><tr><td>str_to_date(string,format_string)</td><td>字符串转时间</td></tr></tbody></table><p>下面挨个做个演示</p><h2 id="1-1-获取日期和时间"><a href="#1-1-获取日期和时间" class="headerlink" title="1.1 获取日期和时间"></a>1.1 获取日期和时间</h2><p>获取时间分为获取当前日期，获取当前时间，和获取当前日期+时间；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select current_time();</span><br><span class="line">+----------------+</span><br><span class="line">| current_time() |</span><br><span class="line">+----------------+</span><br><span class="line">| 14:27:49       |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select now();</span><br><span class="line">+---------------------+</span><br><span class="line">| now()               |</span><br><span class="line">+---------------------+</span><br><span class="line">| 2024-01-30 14:27:53 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select current_date();</span><br><span class="line">+----------------+</span><br><span class="line">| current_date() |</span><br><span class="line">+----------------+</span><br><span class="line">| 2024-01-30     |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select current_timestamp();</span><br><span class="line">+---------------------+</span><br><span class="line">| current_timestamp() |</span><br><span class="line">+---------------------+</span><br><span class="line">| 2024-01-30 14:30:39 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>经过测试可以发现，在MySQL中，<code>current_timestamp()</code>函数和<code>now()</code>函数的效果等效。</p><p>只有<code>UNIX_TIMESTAMP()</code>函数返回的才是时间戳的数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; SELECT UNIX_TIMESTAMP();</span><br><span class="line">+------------------+</span><br><span class="line">| UNIX_TIMESTAMP() |</span><br><span class="line">+------------------+</span><br><span class="line">|       1706596346 |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/f6e691162d0c2360f990ab378809588b.png" alt="image-20240130143435696"></p><h2 id="1-2-获取时间的部分值"><a href="#1-2-获取时间的部分值" class="headerlink" title="1.2 获取时间的部分值"></a>1.2 获取时间的部分值</h2><p>使用YEAR\MONTH\DAY函数从一个时间中提取日期的部分信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW()) <span class="keyword">AS</span> current_year;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW()) <span class="keyword">AS</span> current_month;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(NOW()) <span class="keyword">AS</span> current_day;</span><br></pre></td></tr></table></figure><p>执行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; SELECT YEAR(NOW()) AS current_year;</span><br><span class="line">+--------------+</span><br><span class="line">| current_year |</span><br><span class="line">+--------------+</span><br><span class="line">|         2024 |</span><br><span class="line">+--------------+</span><br><span class="line">1 row in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; SELECT MONTH(NOW()) AS current_month;</span><br><span class="line">+---------------+</span><br><span class="line">| current_month |</span><br><span class="line">+---------------+</span><br><span class="line">|             1 |</span><br><span class="line">+---------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; SELECT DAY(NOW()) AS current_day;</span><br><span class="line">+-------------+</span><br><span class="line">| current_day |</span><br><span class="line">+-------------+</span><br><span class="line">|          30 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="1-3-时间运算"><a href="#1-3-时间运算" class="headerlink" title="1.3 时间运算"></a>1.3 时间运算</h2><p>MySQL中时间可以直接用加减进行运算，时间列和时间函数返回的时间之间可以通过大于小于来比较大小；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; SELECT NOW() + INTERVAL 1 DAY;</span><br><span class="line">+------------------------+</span><br><span class="line">| NOW() + INTERVAL 1 DAY |</span><br><span class="line">+------------------------+</span><br><span class="line">| 2024-01-31 14:49:57    |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>在大学数据库的考试中一般会给出一张表，存了学生的出生日期，让你筛选出年龄小于20岁的学生，此时就需要进行年份的提取和时间计算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设学生表中是id,name,birth三个字段</span></span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">year</span>(now()) <span class="operator">-</span> <span class="keyword">year</span>(birth)) <span class="operator">&lt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>下面演示表格中提到的<code>date_add/date_sub</code>运算函数的用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在日期的基础上加上时间</span></span><br><span class="line"><span class="keyword">select</span> date_add(<span class="string">&#x27;2024-1-1&#x27;</span>,<span class="type">interval</span> <span class="number">2</span> <span class="keyword">month</span>);</span><br><span class="line"><span class="comment">-- 在日期的基础上减去时间</span></span><br><span class="line"><span class="keyword">select</span> date_sub(<span class="string">&#x27;2023-10-1&#x27;</span>, <span class="type">interval</span> <span class="number">2</span> <span class="keyword">day</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二个参数可选的时间间隔</span></span><br><span class="line"><span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span></span><br><span class="line"><span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span></span><br><span class="line"><span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line"><span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">HOUR</span></span><br><span class="line"><span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MINUTE</span></span><br><span class="line"><span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">SECOND</span></span><br></pre></td></tr></table></figure><p>效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select date_sub(&#x27;2023-10-1&#x27;, interval 2 day);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| date_sub(&#x27;2023-10-1&#x27;, interval 2 day) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| 2023-09-29                            |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select date_add(&#x27;2024-1-1&#x27;,interval 2 month);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| date_add(&#x27;2024-1-1&#x27;,interval 2 month) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| 2024-03-01                            |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>另外，MySQL中是允许日期中出现前导0的，依旧可以被正常识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select date_sub(&#x27;2023-01-01&#x27;, interval 2 day);</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| date_sub(&#x27;2023-01-01&#x27;, interval 2 day) |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| 2022-12-30                             |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>使用datediff函数计算两个日期的差值（日期要用单引号传入）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; SELECT DATEDIFF(&#x27;2022-01-30&#x27;, &#x27;2022-01-15&#x27;);</span><br><span class="line">+--------------------------------------+</span><br><span class="line">| DATEDIFF(&#x27;2022-01-30&#x27;, &#x27;2022-01-15&#x27;) |</span><br><span class="line">+--------------------------------------+</span><br><span class="line">|                                   15 |</span><br><span class="line">+--------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>具体例子：在msg表中查询两分钟内发布的消息，可以用<code>date_add</code>函数来实现。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> msg </span><br><span class="line"><span class="keyword">where</span> date_add(sendtime, <span class="type">interval</span> <span class="number">2</span> <span class="keyword">minute</span>) <span class="operator">&gt;</span> now();</span><br></pre></td></tr></table></figure><h2 id="1-4-日期格式化"><a href="#1-4-日期格式化" class="headerlink" title="1.4 日期格式化"></a>1.4 日期格式化</h2><p>使用date_format函数将时间格式化输出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DATE_FORMAT(now(),<span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个格式化字符串中，你可以把一些值给写死，比如将分钟和秒写死为0点0分；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DATE_FORMAT(now(),<span class="string">&#x27;%Y-%m-%d %H:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p>最终效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select DATE_FORMAT(now(),&#x27;%Y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| DATE_FORMAT(now(),&#x27;%Y-%m-%d %H:%i:%s&#x27;) |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| 2024-01-30 14:59:33                    |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select DATE_FORMAT(now(),&#x27;%Y-%m-%d %H:00:00&#x27;);</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| DATE_FORMAT(now(),&#x27;%Y-%m-%d %H:00:00&#x27;) |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| 2024-01-30 14:00:00                    |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>年份Y可以为小y，此时只显示年份的后二位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select DATE_FORMAT(now(),&#x27;%y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| DATE_FORMAT(now(),&#x27;%y-%m-%d %H:%i:%s&#x27;) |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| 24-01-30 15:00:23                      |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="1-5-字符串转时间"><a href="#1-5-字符串转时间" class="headerlink" title="1.5 字符串转时间"></a>1.5 字符串转时间</h2><p><code>str_to_date</code>函数可以将给定的时间字符串和给定的字符串时间格式，转换为一个datetime类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> str_to_date(<span class="string">&#x27;2024-01-02 20:37:14&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>);</span><br></pre></td></tr></table></figure><p>效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select str_to_date(&#x27;2024-01-02 20:37:14&#x27;, &#x27;%Y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">| str_to_date(&#x27;2024-01-02 20:37:14&#x27;, &#x27;%Y-%m-%d %H:%i:%s&#x27;) |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">| 2024-01-02 20:37:14                                     |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>如果你给定的格式化字符串和时间字符串不符合，则无法成功转换，结果为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select str_to_date(&#x27;2024-01-02 20:37:14&#x27;, &#x27;%y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">| str_to_date(&#x27;2024-01-02 20:37:14&#x27;, &#x27;%y-%m-%d %H:%i:%s&#x27;) |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">| NULL                                                    |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="1-6-其他参考函数"><a href="#1-6-其他参考函数" class="headerlink" title="1.6 其他参考函数"></a>1.6 其他参考函数</h2><p>以下是比较全的MySQL日期函数，可供参考</p><details><summary>点我查看</summary><p>原文链接：<a href="https://blog.csdn.net/qinshijangshan/article/details/72874667">MySQL之日期时间处理函数</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL日期时间处理函数</span></span><br><span class="line"><span class="comment">-- 当前日期：2017-05-12（突然发现今天512，是不是会拉防空警报）</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="keyword">FROM</span> DUAL;<span class="comment">-- 当前日期时间：2017-05-12 11:41:47</span></span><br><span class="line"><span class="comment">-- 在MySQL里也存在和Oracle里类似的dual虚拟表：官方声明纯粹是为了满足select ... from...这一习惯问题，mysql会忽略对该表的引用。</span></span><br><span class="line"><span class="comment">-- 那么MySQL中就不用DUAL了吧。</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW();<span class="comment">-- 当前日期时间：2017-05-12 11:41:55</span></span><br><span class="line"><span class="comment">-- 除了 now() 函数能获得当前的日期时间外，MySQL 中还有下面的函数：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>();<span class="comment">-- 2017-05-15 10:19:31</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>;<span class="comment">-- 2017-05-15 10:19:51</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOCALTIME</span>();<span class="comment">-- 2017-05-15 10:20:00</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOCALTIME</span>;<span class="comment">-- 2017-05-15 10:20:10</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOCALTIMESTAMP</span>();<span class="comment">-- 2017-05-15 10:20:21(v4.0.6)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOCALTIMESTAMP</span>;<span class="comment">-- 2017-05-15 10:20:30(v4.0.6)</span></span><br><span class="line"><span class="comment">-- 这些日期时间函数，都等同于 now()。鉴于 now() 函数简短易记，建议总是使用 now()来替代上面列出的函数。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> SYSDATE();<span class="comment">-- 当前日期时间：2017-05-12 11:42:03</span></span><br><span class="line"><span class="comment">-- sysdate() 日期时间函数跟 now() 类似，</span></span><br><span class="line"><span class="comment">-- 不同之处在于：now() 在执行开始时值就得到了;sysdate() 在函数执行时动态得到值。</span></span><br><span class="line"><span class="comment">-- 看下面的例子就明白了：</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW(), SLEEP(<span class="number">3</span>), NOW();</span><br><span class="line"><span class="keyword">SELECT</span> SYSDATE(), SLEEP(<span class="number">3</span>), SYSDATE();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> CURDATE();<span class="comment">-- 当前日期：2017-05-12</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>();<span class="comment">-- 当前日期：等同于 CURDATE()</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>;<span class="comment">-- 当前日期：等同于 CURDATE()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> CURTIME();<span class="comment">-- 当前时间：11:42:47</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIME</span>();<span class="comment">-- 当前时间：等同于 CURTIME()</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIME</span>;<span class="comment">-- 当前时间：等同于 CURTIME()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 获得当前 UTC 日期时间函数</span></span><br><span class="line"><span class="keyword">SELECT</span> UTC_TIMESTAMP(), UTC_DATE(), UTC_TIME()</span><br><span class="line"><span class="comment">-- MySQL 获得当前时间戳函数：current_timestamp, current_timestamp()</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>, <span class="built_in">CURRENT_TIMESTAMP</span>();<span class="comment">-- 2017-05-15 10:32:21 | 2017-05-15 10:32:21</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL 日期时间 Extract（选取） 函数</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@dt</span> <span class="operator">=</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">DATE</span>(<span class="variable">@dt</span>);<span class="comment">-- 获取日期：2017-05-15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">TIME</span>(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 获取时间：10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 获取年份</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 获取月份</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 获取日</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">HOUR</span>(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 获取时</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MINUTE</span>(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 获取分</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SECOND</span>(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 获取秒</span></span><br><span class="line"><span class="keyword">SELECT</span> MICROSECOND(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 获取毫秒</span></span><br><span class="line"><span class="keyword">SELECT</span> QUARTER(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 获取季度</span></span><br><span class="line"><span class="keyword">SELECT</span> WEEK(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 20 (获取周)</span></span><br><span class="line"><span class="keyword">SELECT</span> WEEK(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>, <span class="number">7</span>);<span class="comment">-- ****** 测试此函数在MySQL5.6下无效</span></span><br><span class="line"><span class="keyword">SELECT</span> WEEKOFYEAR(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 同week()</span></span><br><span class="line"><span class="keyword">SELECT</span> DAYOFYEAR(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 135 (日期在年度中第几天)</span></span><br><span class="line"><span class="keyword">SELECT</span> DAYOFMONTH(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 5 (日期在月度中第几天)</span></span><br><span class="line"><span class="keyword">SELECT</span> DAYOFWEEK(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 2 (日期在周中第几天；周日为第一天)</span></span><br><span class="line"><span class="keyword">SELECT</span> WEEKDAY(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 0</span></span><br><span class="line"><span class="keyword">SELECT</span> WEEKDAY(<span class="string">&#x27;2017-05-21 10:37:14.123456&#x27;</span>);<span class="comment">-- 6(与dayofweek()都表示日期在周的第几天，只是参考标准不同，weekday()周一为第0天，周日为第6天)</span></span><br><span class="line"><span class="keyword">SELECT</span> YEARWEEK(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 201720(年和周)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(<span class="keyword">DAY</span> <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(<span class="keyword">HOUR</span> <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(<span class="keyword">MINUTE</span> <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(<span class="keyword">SECOND</span> <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(MICROSECOND <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(QUARTER <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(WEEK <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(YEAR_MONTH <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(DAY_HOUR <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(DAY_MINUTE <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 151037(日时分)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(DAY_SECOND <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 15103714(日时分秒)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(DAY_MICROSECOND <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 15103714123456(日时分秒毫秒)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(HOUR_MINUTE <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 1037(时分)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(HOUR_SECOND <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 103714(时分秒)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(HOUR_MICROSECOND <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 103714123456(日时分秒毫秒)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(MINUTE_SECOND <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 3714(分秒)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(MINUTE_MICROSECOND <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 3714123456(分秒毫秒)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">EXTRACT</span>(SECOND_MICROSECOND <span class="keyword">FROM</span> <span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- 14123456(秒毫秒)</span></span><br><span class="line"><span class="comment">-- MySQL Extract() 函数除了没有date(),time() 的功能外，其他功能一应具全。</span></span><br><span class="line"><span class="comment">-- 并且还具有选取‘day_microsecond&#x27; 等功能。</span></span><br><span class="line"><span class="comment">-- 注意这里不是只选取 day 和 microsecond，而是从日期的 day 部分一直选取到 microsecond 部分。</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> DAYNAME(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- Monday(返回英文星期)</span></span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>);<span class="comment">-- May(返回英文月份)</span></span><br><span class="line"><span class="keyword">SELECT</span> LAST_DAY(<span class="string">&#x27;2016-02-01&#x27;</span>);<span class="comment">-- 2016-02-29 (返回月份中最后一天)</span></span><br><span class="line"><span class="keyword">SELECT</span> LAST_DAY(<span class="string">&#x27;2016-05-01&#x27;</span>);<span class="comment">-- 2016-05-31</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- DATE_ADD(date,INTERVAL expr type) 从日期加上指定的时间间隔</span></span><br><span class="line"><span class="comment">-- type参数可参考：http://www.w3school.com.cn/sql/func_date_sub.asp</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>);<span class="comment">-- 表示：2018-05-15 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> QUARTER);<span class="comment">-- 表示：2017-08-15 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>);<span class="comment">-- 表示：2017-06-15 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> WEEK);<span class="comment">-- 表示：2017-05-22 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>);<span class="comment">-- 表示：2017-05-16 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">HOUR</span>);<span class="comment">-- 表示：2017-05-15 11:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MINUTE</span>);<span class="comment">-- 表示：2017-05-15 10:38:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">SECOND</span>);<span class="comment">-- 表示：2017-05-15 10:37:15.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> MICROSECOND);<span class="comment">-- 表示：2017-05-15 10:37:14.123457</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- DATE_SUB(date,INTERVAL expr type) 从日期减去指定的时间间隔</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>);<span class="comment">-- 表示：2016-05-15 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> QUARTER);<span class="comment">-- 表示：2017-02-15 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>);<span class="comment">-- 表示：2017-04-15 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> WEEK);<span class="comment">-- 表示：2017-05-08 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>);<span class="comment">-- 表示：2017-05-14 10:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">HOUR</span>);<span class="comment">-- 表示：2017-05-15 09:37:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MINUTE</span>);<span class="comment">-- 表示：2017-05-15 10:36:14.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">SECOND</span>);<span class="comment">-- 表示：2017-05-15 10:37:13.123456</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(<span class="string">&#x27;2017-05-15 10:37:14.123456&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">1</span> MICROSECOND);<span class="comment">-- 表示：2017-05-15 10:37:14.123455</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 经特殊日期测试，DATE_SUB(date,INTERVAL expr type)可放心使用</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(CURDATE(),<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>);<span class="comment">-- 前一天：2017-05-11</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(CURDATE(),<span class="type">INTERVAL</span> <span class="number">-1</span> <span class="keyword">DAY</span>);<span class="comment">-- 后一天：2017-05-13</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(CURDATE(),<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>);<span class="comment">-- 一个月前日期：2017-04-12</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(CURDATE(),<span class="type">INTERVAL</span> <span class="number">-1</span> <span class="keyword">MONTH</span>);<span class="comment">-- 一个月后日期：2017-06-12</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(CURDATE(),<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>);<span class="comment">-- 一年前日期：2016-05-12</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(CURDATE(),<span class="type">INTERVAL</span> <span class="number">-1</span> <span class="keyword">YEAR</span>);<span class="comment">-- 一年后日期：20178-06-12</span></span><br><span class="line"><span class="comment">-- MySQL date_sub() 日期时间函数 和 date_add() 用法一致，并且可以用INTERNAL -1 xxx的形式互换使用；</span></span><br><span class="line"><span class="comment">-- 另外，MySQL 中还有两个函数 subdate(), subtime()，建议，用 date_sub() 来替代。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL 另类日期函数：period_add(P,N), period_diff(P1,P2)</span></span><br><span class="line"><span class="comment">-- 函数参数“P” 的格式为“YYYYMM” 或者 “YYMM”，第二个参数“N” 表示增加或减去 N month（月）。</span></span><br><span class="line"><span class="comment">-- MySQL period_add(P,N)：日期加/减去N月。</span></span><br><span class="line"><span class="keyword">SELECT</span> PERIOD_ADD(<span class="number">201705</span>,<span class="number">2</span>), PERIOD_ADD(<span class="number">201705</span>,<span class="number">-2</span>);<span class="comment">-- 201707  20170503</span></span><br><span class="line"><span class="comment">-- period_diff(P1,P2)：日期 P1-P2，返回 N 个月。</span></span><br><span class="line"><span class="keyword">SELECT</span> PERIOD_DIFF(<span class="number">201706</span>, <span class="number">201703</span>);<span class="comment">-- </span></span><br><span class="line"><span class="comment">-- datediff(date1,date2)：两个日期相减 date1 - date2，返回天数</span></span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;2017-06-05&#x27;</span>,<span class="string">&#x27;2017-05-29&#x27;</span>);<span class="comment">-- 7</span></span><br><span class="line"><span class="comment">-- TIMEDIFF(time1,time2)：两个日期相减 time1 - time2，返回 TIME 差值</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMEDIFF(<span class="string">&#x27;2017-06-05 19:28:37&#x27;</span>, <span class="string">&#x27;2017-06-05 17:00:00&#x27;</span>);<span class="comment">-- 02:28:37</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL日期转换函数</span></span><br><span class="line"><span class="keyword">SELECT</span> TIME_TO_SEC(<span class="string">&#x27;01:00:05&#x27;</span>); <span class="comment">-- 3605</span></span><br><span class="line"><span class="keyword">SELECT</span> SEC_TO_TIME(<span class="number">3605</span>);<span class="comment">-- 01:00:05</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL （日期、天数）转换函数：to_days(date), from_days(days)</span></span><br><span class="line"><span class="keyword">SELECT</span> TO_DAYS(<span class="string">&#x27;0000-00-00&#x27;</span>); <span class="comment">-- NULL </span></span><br><span class="line"><span class="keyword">SELECT</span> TO_DAYS(<span class="string">&#x27;2017-06-05&#x27;</span>); <span class="comment">-- 736850</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_DAYS(<span class="number">0</span>);           <span class="comment">-- &#x27;0000-00-00&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_DAYS(<span class="number">736850</span>);      <span class="comment">-- &#x27;2017-06-05&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL Str to Date （字符串转换为日期）函数：str_to_date(str, format)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE(<span class="string">&#x27;06.05.2017 19:40:30&#x27;</span>, <span class="string">&#x27;%m.%d.%Y %H:%i:%s&#x27;</span>);<span class="comment">-- 2017-06-05 19:40:30</span></span><br><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE(<span class="string">&#x27;06/05/2017&#x27;</span>, <span class="string">&#x27;%m/%d/%Y&#x27;</span>);                  <span class="comment">-- 2017-06-05</span></span><br><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE(<span class="string">&#x27;2017/12/3&#x27;</span>,<span class="string">&#x27;%Y/%m/%d&#x27;</span>)       <span class="comment">-- 2017-12-03</span></span><br><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE(<span class="string">&#x27;20:09:30&#x27;</span>, <span class="string">&#x27;%h:%i:%s&#x27;</span>)       <span class="comment">-- NULL(超过12时的小时用小写h，得到的结果为NULL)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 日期时间格式化</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(<span class="string">&#x27;2017-05-12 17:03:51&#x27;</span>, <span class="string">&#x27;%Y年%m月%d日 %H时%i分%s秒&#x27;</span>);<span class="comment">-- 2017年05月12日 17时03分51秒(具体需要什么格式的数据根据实际情况来;小写h为12小时制;)</span></span><br><span class="line"><span class="keyword">SELECT</span> TIME_FORMAT(<span class="string">&#x27;2017-05-12 17:03:51&#x27;</span>, <span class="string">&#x27;%Y年%m月%d日 %H时%i分%s秒&#x27;</span>);<span class="comment">-- 0000年00月00日 17时03分51秒(time_format()只能用于时间的格式化)</span></span><br><span class="line"><span class="comment">-- STR_TO_DATE()和DATE_FORMATE()为互逆操作</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL 获得国家地区时间格式函数：get_format()</span></span><br><span class="line"><span class="comment">-- MySQL get_format() 语法：get_format(date|time|datetime, &#x27;eur&#x27;|&#x27;usa&#x27;|&#x27;jis&#x27;|&#x27;iso&#x27;|&#x27;internal&#x27;</span></span><br><span class="line"><span class="comment">-- MySQL get_format() 用法的全部示例：</span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">DATE</span>,<span class="string">&#x27;usa&#x27;</span>);   <span class="comment">-- &#x27;%m.%d.%Y&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">DATE</span>,<span class="string">&#x27;jis&#x27;</span>);   <span class="comment">-- &#x27;%Y-%m-%d&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">DATE</span>,<span class="string">&#x27;iso&#x27;</span>);   <span class="comment">-- &#x27;%Y-%m-%d&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">DATE</span>,<span class="string">&#x27;eur&#x27;</span>);   <span class="comment">-- &#x27;%d.%m.%Y&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">DATE</span>,<span class="string">&#x27;internal&#x27;</span>);   <span class="comment">-- &#x27;%Y%m%d&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(DATETIME,<span class="string">&#x27;usa&#x27;</span>);   <span class="comment">-- &#x27;%Y-%m-%d %H.%i.%s&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(DATETIME,<span class="string">&#x27;jis&#x27;</span>);   <span class="comment">-- &#x27;%Y-%m-%d %H:%i:%s&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(DATETIME,<span class="string">&#x27;iso&#x27;</span>);   <span class="comment">-- &#x27;%Y-%m-%d %H:%i:%s&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(DATETIME,<span class="string">&#x27;eur&#x27;</span>);   <span class="comment">-- &#x27;%Y-%m-%d %H.%i.%s&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(DATETIME,<span class="string">&#x27;internal&#x27;</span>); <span class="comment">-- &#x27;%Y%m%d%H%i%s&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">TIME</span>,<span class="string">&#x27;usa&#x27;</span>);   <span class="comment">-- &#x27;%h:%i:%s %p&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">TIME</span>,<span class="string">&#x27;jis&#x27;</span>);   <span class="comment">-- &#x27;%H:%i:%s&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">TIME</span>,<span class="string">&#x27;iso&#x27;</span>);   <span class="comment">-- &#x27;%H:%i:%s&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">TIME</span>,<span class="string">&#x27;eur&#x27;</span>);   <span class="comment">-- &#x27;%H.%i.%s&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> GET_FORMAT(<span class="type">TIME</span>,<span class="string">&#x27;internal&#x27;</span>);     <span class="comment">-- &#x27;%H%i%s&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL 拼凑日期、时间函数：makdedate(year,dayofyear), maketime(hour,minute,second)</span></span><br><span class="line"><span class="keyword">SELECT</span> MAKEDATE(<span class="number">2017</span>,<span class="number">31</span>);   <span class="comment">-- &#x27;2017-01-31&#x27; </span></span><br><span class="line"><span class="keyword">SELECT</span> MAKEDATE(<span class="number">2017</span>,<span class="number">32</span>);   <span class="comment">-- &#x27;2017-02-01&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> MAKETIME(<span class="number">19</span>,<span class="number">52</span>,<span class="number">35</span>);  <span class="comment">-- &#x27;19:52:35&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL 时区（timezone）转换函数：convert_tz(dt,from_tz,to_tz)</span></span><br><span class="line"><span class="keyword">SELECT</span> CONVERT_TZ(<span class="string">&#x27;2017-06-05 19:54:12&#x27;</span>, <span class="string">&#x27;+08:00&#x27;</span>, <span class="string">&#x27;+00:00&#x27;</span>); <span class="comment">-- 2017-06-05 11:54:12</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL （Unix 时间戳、日期）转换函数</span></span><br><span class="line"><span class="comment">-- unix_timestamp(), unix_timestamp(date), from_unixtime(unix_timestamp), from_unixtime(unix_timestamp,format)</span></span><br><span class="line"><span class="comment">-- 将具体时间时间转为timestamp</span></span><br><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP();<span class="comment">-- 当前时间的时间戳：1494815779</span></span><br><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP(<span class="string">&#x27;2017-05-15&#x27;</span>);<span class="comment">-- 指定日期的时间戳：1494777600</span></span><br><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP(<span class="string">&#x27;2017-05-15 10:37:14&#x27;</span>);<span class="comment">-- 指定日期时间的时间戳：1494815834</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 将时间戳转为具体时间</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1494815834</span>);<span class="comment">-- 2017-05-15 10:37:14</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1494815834</span>, <span class="string">&#x27;%Y年%m月%d日 %h时%分:%s秒&#x27;</span>);<span class="comment">-- 获取时间戳对应的格式化日期时间</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- MySQL 时间戳（timestamp）转换、增、减函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">TIMESTAMP</span>(<span class="string">&#x27;2017-05-15&#x27;</span>);<span class="comment">-- 2017-05-15 00:00:00</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">TIMESTAMP</span>(<span class="string">&#x27;2017-05-15 08:12:25&#x27;</span>, <span class="string">&#x27;01:01:01&#x27;</span>);<span class="comment">-- 2017-05-15 09:13:26</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2017-05-15 08:12:25&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>);<span class="comment">-- 2017-05-16 08:12:25</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMESTAMPADD(<span class="keyword">DAY</span>, <span class="number">1</span>, <span class="string">&#x27;2017-05-15 08:12:25&#x27;</span>);<span class="comment">-- 2017-05-16 08:12:25; MySQL timestampadd() 函数类似于 date_add()。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">YEAR</span>, <span class="string">&#x27;2017-06-01&#x27;</span>, <span class="string">&#x27;2016-05-15&#x27;</span>);<span class="comment">-- -1</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">MONTH</span>, <span class="string">&#x27;2017-06-01&#x27;</span>, <span class="string">&#x27;2016-06-15&#x27;</span>);<span class="comment">-- -11</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">DAY</span>, <span class="string">&#x27;2017-06-01&#x27;</span>, <span class="string">&#x27;2016-06-15&#x27;</span>);<span class="comment">-- -351</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">HOUR</span>, <span class="string">&#x27;2017-06-01 08:12:25&#x27;</span>, <span class="string">&#x27;2016-06-15 00:00:00&#x27;</span>);<span class="comment">-- -8432</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, <span class="string">&#x27;2017-06-01 08:12:25&#x27;</span>, <span class="string">&#x27;2016-06-15 00:00:00&#x27;</span>);<span class="comment">-- -505932</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">SECOND</span>, <span class="string">&#x27;2017-06-01 08:12:25&#x27;</span>, <span class="string">&#x27;2016-06-15 00:00:00&#x27;</span>);<span class="comment">-- -30355945</span></span><br></pre></td></tr></table></figure></details><h2 id="1-7-自动赋值时间戳"><a href="#1-7-自动赋值时间戳" class="headerlink" title="1.7 自动赋值时间戳"></a>1.7 自动赋值时间戳</h2><p>官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/timestamp-initialization.html">https://dev.mysql.com/doc/refman/8.0/en/timestamp-initialization.html</a></p><p>MySQL有时间函数，也可以在插入和操作数据的时候自动帮我们更新时间。下面是一个示例语句，在TIMESTAMP和DATETIME类型中都可以这么使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">  ts <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  dt DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>ON UPDATE</code>语句的含义为当行被更新的时候，就自动更新为当前时间（即更新时间）</p><p>举个具体的例子：用户表中，我们的一条记录可以有两个时间字段，一个是更新时间，即用户信息被用户修改后的时间（这个时间可以用来限制用户多久才能修改一次个人信息等操作），另外一个是插入时间，即用户注册的时间。</p><p>此时可以让MySQL来自动帮我们维护插入时间和更新时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> your_table (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  data <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updated_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="2-字符串函数"><a href="#2-字符串函数" class="headerlink" title="2.字符串函数"></a>2.字符串函数</h1><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>charset(str)</td><td>返回字符串的字符集</td></tr><tr><td>concat(str1,str2[,…])</td><td>拼接多个字符串</td></tr><tr><td>instr(str,substr)</td><td>返回substr在str中出现的位置，不存在则返回0</td></tr><tr><td>ucase(string)</td><td>字符串转大写</td></tr><tr><td>lcase(string)</td><td>字符串转小写</td></tr><tr><td>left(string,length)&#x2F;right(string,length)</td><td>从string的左边&#x2F;右边起取length个字符</td></tr><tr><td>length(string)</td><td>字符串长度</td></tr><tr><td>replace(str,search_str,replace_str)</td><td>将str中的replace_str部分替换为search_str</td></tr><tr><td>strcmp(str1,str2)</td><td>逐字符比较两个字符串的大小</td></tr><tr><td>substring(str,position [,length])</td><td>从str的position开始取length个字符</td></tr><tr><td>ltrim(strin)&#x2F;rtrim(str)&#x2F;trim(str)</td><td>去除字符串中的前空格或者后空格</td></tr></tbody></table><p>简单测试一下这些函数的使用吧</p><h2 id="2-1-查看字符串字符集"><a href="#2-1-查看字符串字符集" class="headerlink" title="2.1 查看字符串字符集"></a>2.1 查看字符串字符集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select charset(&quot;你好&quot;);</span><br><span class="line">+-------------------+</span><br><span class="line">| charset(&quot;你好&quot;)   |</span><br><span class="line">+-------------------+</span><br><span class="line">| utf8mb3           |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select charset(&quot;125412446&quot;);</span><br><span class="line">+----------------------+</span><br><span class="line">| charset(&quot;125412446&quot;) |</span><br><span class="line">+----------------------+</span><br><span class="line">| utf8mb3              |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select charset(name) from student;</span><br><span class="line">+---------------+</span><br><span class="line">| charset(name) |</span><br><span class="line">+---------------+</span><br><span class="line">| utf8mb4       |</span><br><span class="line">| utf8mb4       |</span><br><span class="line">| utf8mb4       |</span><br><span class="line">| utf8mb4       |</span><br><span class="line">| utf8mb4       |</span><br><span class="line">+---------------+</span><br><span class="line">5 rows in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="2-2-字符串拼接"><a href="#2-2-字符串拼接" class="headerlink" title="2.2 字符串拼接"></a>2.2 字符串拼接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select concat(&#x27;你好&#x27;,&#x27;，&#x27;,&#x27;今天天气不错&#x27;);</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">| concat(&#x27;你好&#x27;,&#x27;，&#x27;,&#x27;今天天气不错&#x27;)          |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">| 你好，今天天气不错                          |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="2-3-子字符串查询"><a href="#2-3-子字符串查询" class="headerlink" title="2.3 子字符串查询"></a>2.3 子字符串查询</h2><p>使用instr查询，在第一个参数中查询第二个参数的字符串。找到了子串后，返回起始位置的偏移量（并非下标），没有找到返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select instr(&#x27;abcdef&#x27;,&#x27;bc&#x27;);</span><br><span class="line">+----------------------+</span><br><span class="line">| instr(&#x27;abcdef&#x27;,&#x27;bc&#x27;) |</span><br><span class="line">+----------------------+</span><br><span class="line">|                    2 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select instr(&#x27;abcdef&#x27;,&#x27;asdfa&#x27;);</span><br><span class="line">+-------------------------+</span><br><span class="line">| instr(&#x27;abcdef&#x27;,&#x27;asdfa&#x27;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">|                       0 |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="2-4-字符串比较"><a href="#2-4-字符串比较" class="headerlink" title="2.4 字符串比较"></a>2.4 字符串比较</h2><p>和C语言中用的是同一个函数名strcmp；</p><ul><li>第一个字符串更大返回<code>1</code>；</li><li>第二个字符串更大返回<code>-1</code>；</li><li>两个字符串相同返回<code>0</code>（忽略大小写）；</li></ul><p>注意它的比较是根据字符的ASCII码来逐字符比较的，比如小写字母的ASCII码就更大，所以AB和ad比较的结果是负一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select strcmp(&#x27;AB&#x27;,&#x27;AB&#x27;);</span><br><span class="line">+-------------------+</span><br><span class="line">| strcmp(&#x27;AB&#x27;,&#x27;AB&#x27;) |</span><br><span class="line">+-------------------+</span><br><span class="line">|                 0 |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select strcmp(&#x27;AB&#x27;,&#x27;aB&#x27;);</span><br><span class="line">+-------------------+</span><br><span class="line">| strcmp(&#x27;AB&#x27;,&#x27;aB&#x27;) |</span><br><span class="line">+-------------------+</span><br><span class="line">|                 0 |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select strcmp(&#x27;AB&#x27;,&#x27;ad&#x27;);</span><br><span class="line">+-------------------+</span><br><span class="line">| strcmp(&#x27;AB&#x27;,&#x27;ad&#x27;) |</span><br><span class="line">+-------------------+</span><br><span class="line">|                -1 |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select strcmp(&#x27;AB&#x27;,&#x27;ABC&#x27;);</span><br><span class="line">+--------------------+</span><br><span class="line">| strcmp(&#x27;AB&#x27;,&#x27;ABC&#x27;) |</span><br><span class="line">+--------------------+</span><br><span class="line">|                 -1 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select strcmp(&#x27;ABcd&#x27;,&#x27;ABC&#x27;);</span><br><span class="line">+----------------------+</span><br><span class="line">| strcmp(&#x27;ABcd&#x27;,&#x27;ABC&#x27;) |</span><br><span class="line">+----------------------+</span><br><span class="line">|                    1 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中文比较应该也是类似的逻辑，只不过中文编码这方面我不太懂，就不深入探究了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select strcmp(&#x27;你好&#x27;,&#x27;你好吗&#x27;);</span><br><span class="line">+------------------------------+</span><br><span class="line">| strcmp(&#x27;你好&#x27;,&#x27;你好吗&#x27;)      |</span><br><span class="line">+------------------------------+</span><br><span class="line">|                           -1 |</span><br><span class="line">+------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select strcmp(&#x27;你好&#x27;,&#x27;你&#x27;);</span><br><span class="line">+------------------------+</span><br><span class="line">| strcmp(&#x27;你好&#x27;,&#x27;你&#x27;)    |</span><br><span class="line">+------------------------+</span><br><span class="line">|                      1 |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select strcmp(&#x27;你好&#x27;,&#x27;你好&#x27;);</span><br><span class="line">+---------------------------+</span><br><span class="line">| strcmp(&#x27;你好&#x27;,&#x27;你好&#x27;)     |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                         0 |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select strcmp(&#x27;你好&#x27;,&#x27;在吗&#x27;);</span><br><span class="line">+---------------------------+</span><br><span class="line">| strcmp(&#x27;你好&#x27;,&#x27;在吗&#x27;)     |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                        -1 |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="2-5-大小写转换"><a href="#2-5-大小写转换" class="headerlink" title="2.5 大小写转换"></a>2.5 大小写转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select ucase(&#x27;adfasbasdf324r&#x27;);</span><br><span class="line">+-------------------------+</span><br><span class="line">| ucase(&#x27;adfasbasdf324r&#x27;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">| ADFASBASDF324R          |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select lcase(&#x27;ADSB3QRdsadsfweq2&#x27;);</span><br><span class="line">+----------------------------+</span><br><span class="line">| lcase(&#x27;ADSB3QRdsadsfweq2&#x27;) |</span><br><span class="line">+----------------------------+</span><br><span class="line">| adsb3qrdsadsfweq2          |</span><br><span class="line">+----------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="2-6-截取字符串"><a href="#2-6-截取字符串" class="headerlink" title="2.6 截取字符串"></a>2.6 截取字符串</h2><p>left和right用于从字符串的左边或右边开始截取给定长度的串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select left(&#x27;123456&#x27;,2);</span><br><span class="line">+------------------+</span><br><span class="line">| left(&#x27;123456&#x27;,2) |</span><br><span class="line">+------------------+</span><br><span class="line">| 12               |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select right(&#x27;123456&#x27;,2);</span><br><span class="line">+-------------------+</span><br><span class="line">| right(&#x27;123456&#x27;,2) |</span><br><span class="line">+-------------------+</span><br><span class="line">| 56                |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>对于中文而言也是截取两个汉字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select right(&#x27;这是一个测试&#x27;,2);</span><br><span class="line">+-------------------------------+</span><br><span class="line">| right(&#x27;这是一个测试&#x27;,2)       |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| 测试                          |</span><br><span class="line">+-------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select left(&#x27;这是一个测试&#x27;,2);</span><br><span class="line">+------------------------------+</span><br><span class="line">| left(&#x27;这是一个测试&#x27;,2)       |</span><br><span class="line">+------------------------------+</span><br><span class="line">| 这是                         |</span><br><span class="line">+------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>然后还有substring函数，可以从给定位置截取字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select substring(&#x27;123456&#x27;,2,2);</span><br><span class="line">+-------------------------+</span><br><span class="line">| substring(&#x27;123456&#x27;,2,2) |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 23                      |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="2-7-去除空格"><a href="#2-7-去除空格" class="headerlink" title="2.7 去除空格"></a>2.7 去除空格</h2><p>ltrim和rtrim用于去除字符串左侧或者右侧的空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select ltrim(&#x27; 测试&#x27;);</span><br><span class="line">+------------------+</span><br><span class="line">| ltrim(&#x27; 测试&#x27;)   |</span><br><span class="line">+------------------+</span><br><span class="line">| 测试             |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select rtrim(&#x27;右边空格测试              &#x27;);</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| rtrim(&#x27;右边空格测试              &#x27;)       |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| 右边空格测试                              |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>trim是同时去除字符串左侧和右侧的空格，不会对字符串内部的空格做操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select trim(&#x27; 空 格 去除测试 &#x27;);</span><br><span class="line">+--------------------------------+</span><br><span class="line">| trim( &#x27;空 格 去除测试 &#x27;)       |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| 空 格 去除测试                 |</span><br><span class="line">+--------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select trim(&#x27;空 格 去除测试&#x27;);</span><br><span class="line">+------------------------------+</span><br><span class="line">| trim(&#x27;空 格 去除测试&#x27;)       |</span><br><span class="line">+------------------------------+</span><br><span class="line">| 空 格 去除测试               |</span><br><span class="line">+------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="2-8-字符串长度"><a href="#2-8-字符串长度" class="headerlink" title="2.8 字符串长度"></a>2.8 字符串长度</h2><p>注意，当前为了支持中文，我们使用了utf8作为MySQL的字符集，在utf8中中文是3字节存储的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select *,length(name) from stu;</span><br><span class="line">+------+--------+--------------+</span><br><span class="line">| id   | name   | length(name) |</span><br><span class="line">+------+--------+--------------+</span><br><span class="line">|    1 | jack   |            4 |</span><br><span class="line">|    2 | tom    |            3 |</span><br><span class="line">|    3 | kity   |            4 |</span><br><span class="line">|    4 | nono   |            4 |</span><br><span class="line">|    5 | 小明   |            6 |</span><br><span class="line">+------+--------+--------------+</span><br><span class="line">5 rows in set (0.000 sec)</span><br></pre></td></tr></table></figure><h1 id="3-数学函数"><a href="#3-数学函数" class="headerlink" title="3.数学函数"></a>3.数学函数</h1><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>abs(num)</td><td>绝对值</td></tr><tr><td>bin(decimal_num)</td><td>十进制转二进制</td></tr><tr><td>hex(decimal_num)</td><td>十进制转十六进制</td></tr><tr><td>conv(num,from_base,to_base)</td><td>进制转换</td></tr><tr><td>ceiling(num)</td><td>向上取整</td></tr><tr><td>floor(num)</td><td>向下取整</td></tr><tr><td>rand()</td><td>返回随机浮点数，范围<code>[0.0, 1.0)</code></td></tr><tr><td>mod(num,denominator)</td><td>取模，求余</td></tr><tr><td>format(num,dnum)</td><td>保留num的dnum位小数</td></tr></tbody></table><h2 id="3-1-绝对值"><a href="#3-1-绝对值" class="headerlink" title="3.1 绝对值"></a>3.1 绝对值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select abs(-1241.12431);</span><br><span class="line">+------------------+</span><br><span class="line">| abs(-1241.12431) |</span><br><span class="line">+------------------+</span><br><span class="line">|       1241.12431 |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="3-2-进制转换"><a href="#3-2-进制转换" class="headerlink" title="3.2 进制转换"></a>3.2 进制转换</h2><p>十进制转二进制和十六进制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select bin(100);</span><br><span class="line">+----------+</span><br><span class="line">| bin(100) |</span><br><span class="line">+----------+</span><br><span class="line">| 1100100  |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select hex(100);</span><br><span class="line">+----------+</span><br><span class="line">| hex(100) |</span><br><span class="line">+----------+</span><br><span class="line">| 64       |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>在任意进制中转换，源进制和目标进制都是通过数字传入，比如<code>2/8/10/16</code>；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conv(目标数字,源进制,目标进制);</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]<span class="operator">&gt;</span> <span class="keyword">select</span> conv(<span class="number">100</span>,<span class="number">2</span>,<span class="number">16</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> conv(<span class="number">100</span>,<span class="number">2</span>,<span class="number">16</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]<span class="operator">&gt;</span> <span class="keyword">select</span> conv(<span class="number">100</span>,<span class="number">16</span>,<span class="number">10</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> conv(<span class="number">100</span>,<span class="number">16</span>,<span class="number">10</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">256</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]<span class="operator">&gt;</span> <span class="keyword">select</span> conv(<span class="number">100</span>,<span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> conv(<span class="number">100</span>,<span class="number">2</span>,<span class="number">10</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><h2 id="3-3-向下和向上取整"><a href="#3-3-向下和向上取整" class="headerlink" title="3.3 向下和向上取整"></a>3.3 向下和向上取整</h2><p>向下取整和向上取整是基于小数的</p><ul><li>向下取整：不管小数有几位，都去除小数，整数部分不变；</li><li>向上取整：不管小数有几位，都去除小数，并把整数部分加一；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select ceiling(99);</span><br><span class="line">+-------------+</span><br><span class="line">| ceiling(99) |</span><br><span class="line">+-------------+</span><br><span class="line">|          99 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select floor(99.1);</span><br><span class="line">+-------------+</span><br><span class="line">| floor(99.1) |</span><br><span class="line">+-------------+</span><br><span class="line">|          99 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select ceiling(99.2);</span><br><span class="line">+---------------+</span><br><span class="line">| ceiling(99.2) |</span><br><span class="line">+---------------+</span><br><span class="line">|           100 |</span><br><span class="line">+---------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="3-4-模运算"><a href="#3-4-模运算" class="headerlink" title="3.4 模运算"></a>3.4 模运算</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mod</span>(a,b); <span class="comment">-- 等价于 a/b 的余数</span></span><br></pre></td></tr></table></figure><p>效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; SELECT MOD(17, 5);</span><br><span class="line">+------------+</span><br><span class="line">| MOD(17, 5) |</span><br><span class="line">+------------+</span><br><span class="line">|          2 |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; SELECT MOD(15, 5);</span><br><span class="line">+------------+</span><br><span class="line">| MOD(15, 5) |</span><br><span class="line">+------------+</span><br><span class="line">|          0 |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; SELECT MOD(13, 5);</span><br><span class="line">+------------+</span><br><span class="line">| MOD(13, 5) |</span><br><span class="line">+------------+</span><br><span class="line">|          3 |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="3-5-小数格式化"><a href="#3-5-小数格式化" class="headerlink" title="3.5 小数格式化"></a>3.5 小数格式化</h2><p>使用format函数，第二个参数指定保留几位小数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select format(3.1415,2);</span><br><span class="line">+------------------+</span><br><span class="line">| format(3.1415,2) |</span><br><span class="line">+------------------+</span><br><span class="line">| 3.14             |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="3-6-获取随机数"><a href="#3-6-获取随机数" class="headerlink" title="3.6 获取随机数"></a>3.6 获取随机数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select rand();</span><br><span class="line">+--------------------+</span><br><span class="line">| rand()             |</span><br><span class="line">+--------------------+</span><br><span class="line">| 0.5338426274562652 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select rand();</span><br><span class="line">+--------------------+</span><br><span class="line">| rand()             |</span><br><span class="line">+--------------------+</span><br><span class="line">| 0.7618099523352552 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h1 id="4-其他函数"><a href="#4-其他函数" class="headerlink" title="4.其他函数"></a>4.其他函数</h1><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>user()</td><td>查询当前用户</td></tr><tr><td>database()</td><td>查询当前所在数据库</td></tr><tr><td>password(str)</td><td>对密码进行加密</td></tr><tr><td>md5(str)</td><td>计算字符串的md5</td></tr><tr><td>ifnull(val1,val2)</td><td>如果val1为null，返回val2，否则返回val1</td></tr></tbody></table><p>这里只对ifnull函数做个测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; select ifnull(null,&#x27;124&#x27;);</span><br><span class="line">+--------------------+</span><br><span class="line">| ifnull(null,&#x27;124&#x27;) |</span><br><span class="line">+--------------------+</span><br><span class="line">| 124                |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select ifnull(&#x27;aba&#x27;,&#x27;124&#x27;);</span><br><span class="line">+---------------------+</span><br><span class="line">| ifnull(&#x27;aba&#x27;,&#x27;124&#x27;) |</span><br><span class="line">+---------------------+</span><br><span class="line">| aba                 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; select ifnull(&#x27;&#x27;,&#x27;124&#x27;);</span><br><span class="line">+------------------+</span><br><span class="line">| ifnull(&#x27;&#x27;,&#x27;124&#x27;) |</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于MySQL内置函数的章节就这些了，如果后续遇到本文没有记录的函数，会更新本文！</p>]]></content>
    
    
    <summary type="html">对于MySQL内置函数的相关介绍</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据库SQL" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/"/>
    
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】用户管理</title>
    <link href="https://blog.musnow.top/posts/1572064315/"/>
    <id>https://blog.musnow.top/posts/1572064315/</id>
    <published>2024-01-30T01:40:00.000Z</published>
    <updated>2024-01-30T03:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>用户管理是mysql权限控制的重要一环。</p><h1 id="1-MySQL的用户表"><a href="#1-MySQL的用户表" class="headerlink" title="1.MySQL的用户表"></a>1.MySQL的用户表</h1><p>在MySQL数据库中，所有的用户都存在系统数据库mysql的user表内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; use mysql;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">MariaDB [mysql]&gt; select host,user,authentication_string from user;</span><br><span class="line">+-----------+-------------+-----------------------+</span><br><span class="line">| Host      | User        | authentication_string |</span><br><span class="line">+-----------+-------------+-----------------------+</span><br><span class="line">| localhost | mariadb.sys |                       |</span><br><span class="line">| localhost | root        | invalid               |</span><br><span class="line">| localhost | mysql       | invalid               |</span><br><span class="line">+-----------+-------------+-----------------------+</span><br><span class="line">3 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>因为我这是一个刚刚初始化的数据库，内部只有系统自带的几个用户。当我们使用<code>mysql -uroot</code>链接数据库时，其实就是使用了root用户。默认情况下root用户没有密码，所以<code>authentication_string</code>字段显示invalid；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> <span class="keyword">user</span>; <span class="comment">-- 查看表的结构</span></span><br></pre></td></tr></table></figure><p>对这张表里的字段做一个简单的解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">host：用户可以从什么主机上链接数据库，localhost代表只允许本地链接</span><br><span class="line">user：用户名</span><br><span class="line">password：旧版本使用的密码字段</span><br><span class="line">authentication_string：新版本使用的密码字段，用户密码用password函数加密后的字符串；</span><br><span class="line">很多很多以_priv结尾的字段：用户权限记录</span><br></pre></td></tr></table></figure><p>用户和权限管理的存在，让我们可以对MySQL中不同的表进行一定的权限风控，避免某个用户的误操作让整个数据库产生不可逆的损失。</p><h1 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h1><h2 id="2-1-创建用户"><a href="#2-1-创建用户" class="headerlink" title="2.1 创建用户"></a>2.1 创建用户</h2><p>在MySQL中创建用户的语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;登陆主机或IP&#x27;</span></span><br><span class="line">identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; create user &#x27;mu&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.006 sec)</span><br></pre></td></tr></table></figure><p>这里我使用了<code>%</code>作为登录主机，其等价于IP层面理解的<code>0.0.0.0</code>，即该用户允许任何来源地的链接。</p><p>再次查询用户表，可以看到此时mu用户是有<code>authentication_string</code>字段的，其值是通过password函数加密后的123456；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]&gt; select host,user,authentication_string from user;</span><br><span class="line">+-----------+-------------+-------------------------------------------+</span><br><span class="line">| Host      | User        | authentication_string                     |</span><br><span class="line">+-----------+-------------+-------------------------------------------+</span><br><span class="line">| localhost | mariadb.sys |                                           |</span><br><span class="line">| localhost | root        | invalid                                   |</span><br><span class="line">| localhost | mysql       | invalid                                   |</span><br><span class="line">| %         | mu          | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |</span><br><span class="line">+-----------+-------------+-------------------------------------------+</span><br><span class="line">4 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>我们也可以自行调用password函数，可以看到输出值和上表中的值一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]&gt; select password(&#x27;123456&#x27;);</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| password(&#x27;123456&#x27;)                        |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>此时想用这个新用户进行登录，在linux的命令行中输入如下命令进行登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p密码</span><br></pre></td></tr></table></figure><blockquote><p>如果你现在处于Linux的子用户，登录MySQL的root用户需要sudo权限，但登录新创建的MySQL用户是不需要sudo的。</p></blockquote><p>示例如下，登录MySQL后可以用<code>select user();</code>语句查看当前登录的用户是谁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">❯ mysql -umu -p123456</span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 35</span><br><span class="line">Server version: 10.6.16-MariaDB-0ubuntu0.22.04.1 Ubuntu 22.04</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.    </span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select user();</span><br><span class="line">+--------------+</span><br><span class="line">| user()       |</span><br><span class="line">+--------------+</span><br><span class="line">| mu@localhost |</span><br><span class="line">+--------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h2 id="2-2-删除用户"><a href="#2-2-删除用户" class="headerlink" title="2.2 删除用户"></a>2.2 删除用户</h2><p>只有高权限用户或者root用户才能删除其他用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果在传入用户名时不提供主机名，则主机名默认为<code>%</code>；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>;</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]&gt; drop user &#x27;mu&#x27;@&#x27;192.168.1.30&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.006 sec)</span><br></pre></td></tr></table></figure><h3 id="为什么在删除用户的时候需要指定主机名？"><a href="#为什么在删除用户的时候需要指定主机名？" class="headerlink" title="为什么在删除用户的时候需要指定主机名？"></a>为什么在删除用户的时候需要指定主机名？</h3><p>为什么在删除用户的时候需要指定主机名？因为同一个用户名，不同主机名是可以创建多个的，MySQL并没有限制一个用户名只能创建一条记录。</p><p>比如我们可以允许<strong>张三</strong>在IP1和IP2登录，这样就能创建两条用户记录，这两条用户记录的用户名都是张三，但可以有不同的登录来源host和不同的密码。这样我们可以控制单个用户在不同主机上的不同权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]&gt; create user &#x27;mu&#x27;@&#x27;192.168.1.30&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.006 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; select host,user,authentication_string from user;</span><br><span class="line">+--------------+-------------+-------------------------------------------+        </span><br><span class="line">| Host         | User        | authentication_string                     |        </span><br><span class="line">+--------------+-------------+-------------------------------------------+        </span><br><span class="line">| localhost    | mariadb.sys |                                           |        </span><br><span class="line">| localhost    | root        | invalid                                   |        </span><br><span class="line">| localhost    | mysql       | invalid                                   |        </span><br><span class="line">| %            | mu          | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |        </span><br><span class="line">| 192.168.1.30 | mu          | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |        </span><br><span class="line">+--------------+-------------+-------------------------------------------+        </span><br><span class="line">5 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><h2 id="2-3-设置用户密码"><a href="#2-3-设置用户密码" class="headerlink" title="2.3 设置用户密码"></a>2.3 设置用户密码</h2><p>设置当前用户的密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> password<span class="operator">=</span>password(<span class="string">&#x27;新密码&#x27;</span>);</span><br></pre></td></tr></table></figure><p>修改特定用户的密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span><span class="operator">=</span>password(<span class="string">&#x27;新密码&#x27;</span>);</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]&gt; set password for &#x27;mu&#x27;@&#x27;%&#x27;=password(&#x27;654321&#x27;);</span><br><span class="line">Query OK, 0 rows affected (0.006 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; select host,user,authentication_string from user;</span><br><span class="line">+-----------+-------------+-------------------------------------------+</span><br><span class="line">| Host      | User        | authentication_string                     |</span><br><span class="line">+-----------+-------------+-------------------------------------------+</span><br><span class="line">| localhost | mariadb.sys |                                           |</span><br><span class="line">| localhost | root        | invalid                                   |</span><br><span class="line">| localhost | mysql       | invalid                                   |</span><br><span class="line">| %         | mu          | *2A032F7C5BA932872F0F045E0CF6B53CF702F2C5 |</span><br><span class="line">+-----------+-------------+-------------------------------------------+</span><br><span class="line">4 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><h2 id="2-4-命令汇总小结"><a href="#2-4-命令汇总小结" class="headerlink" title="2.4 命令汇总小结"></a>2.4 命令汇总小结</h2><p>在我的实际使用中，最常用的用户管理就是在配置需要使用MySQL数据库的docker时的操作了。需要给一个新的docker设置新的数据库，并创建一个用户给这个docker来操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果是docker安装的MySQL</span></span><br><span class="line"><span class="comment">-- 需要先在Linux系统中进入MySQL容器的终端里面</span></span><br><span class="line">docker <span class="keyword">exec</span> <span class="operator">-</span>it 容器名 <span class="operator">/</span>bin<span class="operator">/</span>sh</span><br><span class="line"><span class="comment">-- 在终端命令行中执行如下命令</span></span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p密码</span><br><span class="line"><span class="comment">-- 进入MySQL命令行后，创建数据库和用户</span></span><br><span class="line"><span class="keyword">create</span> database 数据库名字;</span><br><span class="line"><span class="comment">-- 数据库名字要和上面创建的这个数据库对应</span></span><br><span class="line"><span class="comment">-- 给定新表的所有权限到新用户上</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;用户的密码&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> 数据库名字.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="3-权限管理"><a href="#3-权限管理" class="headerlink" title="3.权限管理"></a>3.权限管理</h1><h2 id="3-1-权限列表"><a href="#3-1-权限列表" class="headerlink" title="3.1 权限列表"></a>3.1 权限列表</h2><p>MySQL数据库提供的权限非常细致，列表如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/01/bc621d3a1fada1faa98c2c0303df0890.png" alt="image-20240130103510001"></p><h2 id="3-2-给用户授权"><a href="#3-2-给用户授权" class="headerlink" title="3.2 给用户授权"></a>3.2 给用户授权</h2><p>授权的语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库.对象名 </span><br><span class="line"><span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机&#x27;</span> [identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果需要授予多个权限，用逗号分隔。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">delete</span> <span class="keyword">on</span> 数据库.对象名 </span><br><span class="line"><span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机&#x27;</span> [identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果想授予所有权限，可以使用<code>all</code>，或者<code>all privileges</code>，二者都代表所有权限，没有区别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> [privileges] <span class="keyword">on</span> ... </span><br></pre></td></tr></table></figure><p>几点说明</p><ul><li>命令中的<code>[identified by &#39;密码&#39;]</code>是可选项，如果用户存在，则修改其密码。如果用户不存在，则以该密码创建用户。</li><li><code>数据库.对象名</code>可使用<code>*.*</code> ，代表当前MySQL中的所有数据对象；</li><li><code>数据库.*</code>代表某个数据库中的所有对象；</li></ul><h3 id="授权示例"><a href="#授权示例" class="headerlink" title="授权示例"></a>授权示例</h3><p>刚创建的用户是没有任何权限的，如下所示，我刚刚创建的mu用户并没有看到原本已有的<code>stu_test</code>数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select user();</span><br><span class="line">+--------------+</span><br><span class="line">| user()       |</span><br><span class="line">+--------------+</span><br><span class="line">| mu@localhost |</span><br><span class="line">+--------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>使用如下命令给用户授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> stu_test.student <span class="keyword">to</span> <span class="string">&#x27;mu&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>授权之后，mu用户就能看到这个表了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| stu_test           |</span><br><span class="line">+--------------------+</span><br><span class="line">2 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>mu用户可以进行查询操作，但是不能删改student表，操作会被数据库拒绝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; use stu_test;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">MariaDB [stu_test]&gt; select * from student;</span><br><span class="line">+------+--------+</span><br><span class="line">| id   | name   |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | 张三   |</span><br><span class="line">|    2 | 李四   |</span><br><span class="line">|    3 | 王五   |</span><br><span class="line">|    4 | 赵六   |</span><br><span class="line">|    5 | 刘七   |</span><br><span class="line">+------+--------+</span><br><span class="line">5 rows in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; insert into student values (6,&#x27;王璐&#x27;);</span><br><span class="line">ERROR 1142 (42000): INSERT command denied to user &#x27;mu&#x27;@&#x27;localhost&#x27; for table `stu_test`.`student`</span><br></pre></td></tr></table></figure><p>再次给予更新和删除的权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">update</span>,<span class="keyword">delete</span>,<span class="keyword">insert</span> <span class="keyword">on</span> stu_test.student <span class="keyword">to</span> <span class="string">&#x27;mu&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时mu用户就能进行插入和删除等操作了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; insert into student values (6,&#x27;王璐&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.006 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [stu_test]&gt; delete from student where id = 5;</span><br><span class="line">Query OK, 1 row affected (0.007 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h3><p>如果发现赋予权限后用户还是不能执行某些操作，可以用如下命令刷新权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h2 id="3-3-回收权限"><a href="#3-3-回收权限" class="headerlink" title="3.3 回收权限"></a>3.3 回收权限</h2><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库.对象名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机&#x27;</span>;</span><br></pre></td></tr></table></figure><p>比如回收mu用户对于student表的插入权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">insert</span> <span class="keyword">on</span> stu_test.student <span class="keyword">from</span> <span class="string">&#x27;mu&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时mu用户又不能进行插入操作了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [stu_test]&gt; insert into student values (7,&#x27;你好&#x27;);</span><br><span class="line">ERROR 1142 (42000): INSERT command denied to user &#x27;mu&#x27;@&#x27;localhost&#x27; for table `stu_test`.`student`</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>MySQL中用户管理的基本操作就是这些了。在实际项目中，用户管理是数据库安全性的重要一环，得多加注意。</p>]]></content>
    
    
    <summary type="html">mysql和mariadb中用户管理的相关内容</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据库SQL" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/"/>
    
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
</feed>
